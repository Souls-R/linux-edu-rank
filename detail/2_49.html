<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_48.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><span>[49]</span><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_50.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 356c05d58af05d582e634b54b40050c73609617b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 14 13:30:03 2012 -0400

    sysfs: get rid of some lockdep false positives
    
    This patch (as1554) fixes a lockdep false-positive report.  The
    problem arises because lockdep is unable to deal with the
    tree-structured locks created by the device core and sysfs.
    
    This particular problem involves a sysfs attribute method that
    unregisters itself, not from the device it was called for, but from a
    descendant device.  Lockdep doesn't understand the distinction and
    reports a possible deadlock, even though the operation is safe.
    
    This is the sort of thing that would normally be handled by using a
    nested lock annotation; unfortunately it's not feasible to do that
    here.  There's no sensible way to tell sysfs when attribute removal
    occurs in the context of a parent attribute method.
    
    As a workaround, the patch adds a new flag to struct attribute
    telling sysfs not to inform lockdep when it acquires a readlock on a
    sysfs_dirent instance for the attribute.  The readlock is still
    acquired, but lockdep doesn't know about it and hence does not
    complain about impossible deadlock scenarios.
    
    Also added are macros for static initialization of attribute
    structures with the ignore_lockdep flag set.  The three offending
    attributes in the USB subsystem are converted to use the new macros.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Tejun Heo &lt;tj@kernel.org&gt;
    CC: Eric W. Biederman &lt;ebiederm@xmission.com&gt;
    CC: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 566d9f94f735..9a56e3adf476 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -73,7 +73,7 @@ set_bConfigurationValue(struct device *dev, struct device_attribute *attr,
 	return (value &lt; 0) ? value : count;
 }
 
-static DEVICE_ATTR(bConfigurationValue, S_IRUGO | S_IWUSR,
+static DEVICE_ATTR_IGNORE_LOCKDEP(bConfigurationValue, S_IRUGO | S_IWUSR,
 		show_bConfigurationValue, set_bConfigurationValue);
 
 /* String fields */
@@ -595,7 +595,7 @@ static ssize_t usb_dev_authorized_store(struct device *dev,
 	return result &lt; 0? result : size;
 }
 
-static DEVICE_ATTR(authorized, 0644,
+static DEVICE_ATTR_IGNORE_LOCKDEP(authorized, 0644,
 	    usb_dev_authorized_show, usb_dev_authorized_store);
 
 /* "Safely remove a device" */
@@ -618,7 +618,7 @@ static ssize_t usb_remove_store(struct device *dev,
 	usb_unlock_device(udev);
 	return rc;
 }
-static DEVICE_ATTR(remove, 0200, NULL, usb_remove_store);
+static DEVICE_ATTR_IGNORE_LOCKDEP(remove, 0200, NULL, usb_remove_store);
 
 
 static struct attribute *dev_attrs[] = {
diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c
index 24fa995f0312..e6bb9b2a4cbe 100644
--- a/fs/sysfs/dir.c
+++ b/fs/sysfs/dir.c
@@ -132,6 +132,24 @@ static void sysfs_unlink_sibling(struct sysfs_dirent *sd)
 	rb_erase(&amp;sd-&gt;s_rb, &amp;sd-&gt;s_parent-&gt;s_dir.children);
 }
 
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+
+/* Test for attributes that want to ignore lockdep for read-locking */
+static bool ignore_lockdep(struct sysfs_dirent *sd)
+{
+	return sysfs_type(sd) == SYSFS_KOBJ_ATTR &amp;&amp;
+			sd-&gt;s_attr.attr-&gt;ignore_lockdep;
+}
+
+#else
+
+static inline bool ignore_lockdep(struct sysfs_dirent *sd)
+{
+	return true;
+}
+
+#endif
+
 /**
  *	sysfs_get_active - get an active reference to sysfs_dirent
  *	@sd: sysfs_dirent to get an active reference to
@@ -155,15 +173,17 @@ struct sysfs_dirent *sysfs_get_active(struct sysfs_dirent *sd)
 			return NULL;
 
 		t = atomic_cmpxchg(&amp;sd-&gt;s_active, v, v + 1);
-		if (likely(t == v)) {
-			rwsem_acquire_read(&amp;sd-&gt;dep_map, 0, 1, _RET_IP_);
-			return sd;
-		}
+		if (likely(t == v))
+			break;
 		if (t &lt; 0)
 			return NULL;
 
 		cpu_relax();
 	}
+
+	if (likely(!ignore_lockdep(sd)))
+		rwsem_acquire_read(&amp;sd-&gt;dep_map, 0, 1, _RET_IP_);
+	return sd;
 }
 
 /**
@@ -180,7 +200,8 @@ void sysfs_put_active(struct sysfs_dirent *sd)
 	if (unlikely(!sd))
 		return;
 
-	rwsem_release(&amp;sd-&gt;dep_map, 1, _RET_IP_);
+	if (likely(!ignore_lockdep(sd)))
+		rwsem_release(&amp;sd-&gt;dep_map, 1, _RET_IP_);
 	v = atomic_dec_return(&amp;sd-&gt;s_active);
 	if (likely(v != SD_DEACTIVATED_BIAS))
 		return;
diff --git a/include/linux/device.h b/include/linux/device.h
index a8db2cfa2c81..e04f5776f6d0 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -504,6 +504,9 @@ ssize_t device_store_int(struct device *dev, struct device_attribute *attr,
 #define DEVICE_INT_ATTR(_name, _mode, _var) \
 	struct dev_ext_attribute dev_attr_##_name = \
 		{ __ATTR(_name, _mode, device_show_int, device_store_int), &amp;(_var) }
+#define DEVICE_ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) \
+	struct device_attribute dev_attr_##_name =		\
+		__ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store)
 
 extern int device_create_file(struct device *device,
 			      const struct device_attribute *entry);
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index 0010009b2f00..381f06db2fe5 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -27,6 +27,7 @@ struct attribute {
 	const char		*name;
 	umode_t			mode;
 #ifdef CONFIG_DEBUG_LOCK_ALLOC
+	bool			ignore_lockdep:1;
 	struct lock_class_key	*key;
 	struct lock_class_key	skey;
 #endif
@@ -80,6 +81,17 @@ struct attribute_group {
 
 #define __ATTR_NULL { .attr = { .name = NULL } }
 
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+#define __ATTR_IGNORE_LOCKDEP(_name, _mode, _show, _store) {	\
+	.attr = {.name = __stringify(_name), .mode = _mode,	\
+			.ignore_lockdep = true },		\
+	.show		= _show,				\
+	.store		= _store,				\
+}
+#else
+#define __ATTR_IGNORE_LOCKDEP	__ATTR
+#endif
+
 #define attr_name(_attr) (_attr).attr.name
 
 struct file;</pre><hr><pre>commit df767b71e5816692134d59c0c17e0f77cd73333d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 8 15:15:25 2012 -0400

    usb-storage: unusual_devs entry for Yarvik PMP400 MP4 player
    
    This patch (as1553) adds an unusual_dev entrie for the Yarvik PMP400
    MP4 music player.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Jesse Feddema &lt;jdfeddema@gmail.com&gt;
    Tested-by: Jesse Feddema &lt;jdfeddema@gmail.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 856ad92c40de..8f3cbb8dc81b 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1885,6 +1885,13 @@ UNUSUAL_DEV(  0x1652, 0x6600, 0x0201, 0x0201,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
+/* Reported by Jesse Feddema &lt;jdfeddema@gmail.com&gt; */
+UNUSUAL_DEV(  0x177f, 0x0400, 0x0000, 0x0000,
+		"Yarvik",
+		"PMP400",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_BULK_IGNORE_TAG | US_FL_MAX_SECTORS_64 ),
+
 /* Reported by Hans de Goede &lt;hdegoede@redhat.com&gt;
  * These Appotech controllers are found in Picture Frames, they provide a
  * (buggy) emulation of a cdrom drive which contains the windows software</pre><hr><pre>commit 1949f9e2435cc2e87c63da167af63faafc49b388
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 7 13:22:52 2012 -0400

    USB: xhci-hcd: print URB's expected length in decimal, not hex
    
    This patch changes the output format specifier of a debugging line in
    the xhci-hcd driver.  An URB's transfer_buffer_length should be
    printed in decimal; there's no reason to print it in hex.  Especially
    since the actual_length value, printed earlier on the same line, is
    already in decimal.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index d40194c8ca60..329fd2a98dd6 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2272,7 +2272,7 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 					(status != 0 &amp;&amp;
 					 !usb_endpoint_xfer_isoc(&amp;urb-&gt;ep-&gt;desc)))
 				xhci_dbg(xhci, "Giveback URB %p, len = %d, "
-						"expected = %x, status = %d\n",
+						"expected = %d, status = %d\n",
 						urb, urb-&gt;actual_length,
 						urb-&gt;transfer_buffer_length,
 						status);</pre><hr><pre>commit c7f3619b90fc4c43ed326ec8b3f0299374763c92
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 7 11:24:05 2012 -0400

    usb-serial: clean up unneeded PM-related fields
    
    This patch (as1551) cleans up the PM-related entries in the usb_driver
    structures of the various USB serial driver modules.  Those entries
    are now filled in by the usb-serial core during driver registration,
    so they don't need to be initialized explicitly in the source code.
    
    The same is true of the one remaining no_dynamic_id entry.
    
    reset_resume remains a small problem, because the serial core doesn't
    support it.  The patch ignores these entries.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c
index 70c46b0426ff..ba4f067cf277 100644
--- a/drivers/usb/serial/ch341.c
+++ b/drivers/usb/serial/ch341.c
@@ -599,11 +599,8 @@ static struct usb_driver ch341_driver = {
 	.name		= "ch341",
 	.probe		= usb_serial_probe,
 	.disconnect	= usb_serial_disconnect,
-	.suspend	= usb_serial_suspend,
-	.resume		= usb_serial_resume,
 	.reset_resume	= ch341_reset_resume,
 	.id_table	= id_table,
-	.supports_autosuspend =	1,
 };
 
 static struct usb_serial_driver ch341_device = {
diff --git a/drivers/usb/serial/f81232.c b/drivers/usb/serial/f81232.c
index 46aee85210e2..c32486d73a76 100644
--- a/drivers/usb/serial/f81232.c
+++ b/drivers/usb/serial/f81232.c
@@ -355,10 +355,6 @@ static struct usb_driver f81232_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.suspend =      usb_serial_suspend,
-	.resume =       usb_serial_resume,
-	.no_dynamic_id = 	1,
-	.supports_autosuspend =	1,
 };
 
 static struct usb_serial_driver f81232_device = {
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index ae0b4aa9aa59..d1674bc3d4fa 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -1224,11 +1224,6 @@ static struct usb_driver option_driver = {
 	.name       = "option",
 	.probe      = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
-#ifdef CONFIG_PM
-	.suspend    = usb_serial_suspend,
-	.resume     = usb_serial_resume,
-	.supports_autosuspend =	1,
-#endif
 	.id_table   = option_ids,
 };
 
diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 9eec2c3574d8..34e51a04dde0 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -100,9 +100,6 @@ static struct usb_driver pl2303_driver = {
 	.probe =	usb_serial_probe,
 	.disconnect =	usb_serial_disconnect,
 	.id_table =	id_table,
-	.suspend =      usb_serial_suspend,
-	.resume =       usb_serial_resume,
-	.supports_autosuspend =	1,
 };
 
 #define SET_LINE_REQUEST_TYPE		0x21
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index 201f2810d503..3696924c1eb3 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -117,9 +117,6 @@ static struct usb_driver qcdriver = {
 	.probe			= usb_serial_probe,
 	.disconnect		= usb_serial_disconnect,
 	.id_table		= id_table,
-	.suspend		= usb_serial_suspend,
-	.resume			= usb_serial_resume,
-	.supports_autosuspend	= true,
 };
 
 static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index f298ddaac684..7b7771491a64 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -1055,11 +1055,8 @@ static struct usb_driver sierra_driver = {
 	.name       = "sierra",
 	.probe      = usb_serial_probe,
 	.disconnect = usb_serial_disconnect,
-	.suspend    = usb_serial_suspend,
-	.resume     = usb_serial_resume,
 	.reset_resume = sierra_reset_resume,
 	.id_table   = id_table,
-	.supports_autosuspend =	1,
 };
 
 static struct usb_serial_driver sierra_device = {
diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index cda513bb01c7..9820492cf885 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -68,9 +68,6 @@ static struct usb_driver ssu100_driver = {
 	.probe			       = usb_serial_probe,
 	.disconnect		       = usb_serial_disconnect,
 	.id_table		       = id_table,
-	.suspend		       = usb_serial_suspend,
-	.resume			       = usb_serial_resume,
-	.supports_autosuspend	       = 1,
 };
 
 struct ssu100_port_private {</pre><hr><pre>commit 5cbe61c5aff0a8ada691eb8b07dbfb55c303f640
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 7 11:20:06 2012 -0400

    usb-serial: ftdi_sio: fix oops during autosuspend
    
    This patch (as1550) fixes a bug in the usb-serial core that affects
    the ftdi_sio driver and most likely others as well.  The core
    implements suspend and resume routines, but it doesn't store pointers
    to those routines in the usb_driver structures that it registers,
    even though it does set those drivers' supports_autosuspend flag.  The
    end result is that when one of these devices is autosuspended, we try
    to call through a NULL pointer.
    
    The patch fixes the problem by setting the suspend and resume method
    pointers to the appropriate routines in the USB serial core, along
    with the supports_autosuspend field, in each driver as it is
    registered.
    
    This should be back-ported to all the stable kernels that have the new
    usb_serial_register_drivers() interface.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Frank Schäfer &lt;schaefer.frank@gmx.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 906f06e97fde..f7b263e237ef 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -1336,7 +1336,6 @@ static int usb_serial_register(struct usb_serial_driver *driver)
 				driver-&gt;description);
 		return -EINVAL;
 	}
-	driver-&gt;usb_driver-&gt;supports_autosuspend = 1;
 
 	/* Add this device to our list of devices */
 	mutex_lock(&amp;table_lock);
@@ -1371,7 +1370,7 @@ static void usb_serial_deregister(struct usb_serial_driver *device)
  * @serial_drivers: NULL-terminated array of pointers to drivers to be registered
  *
  * Registers @udriver and all the drivers in the @serial_drivers array.
- * Automatically fills in the .no_dynamic_id field in @udriver and
+ * Automatically fills in the .no_dynamic_id and PM fields in @udriver and
  * the .usb_driver field in each serial driver.
  */
 int usb_serial_register_drivers(struct usb_driver *udriver,
@@ -1390,11 +1389,17 @@ int usb_serial_register_drivers(struct usb_driver *udriver,
 	 * the serial drivers are registered, because the probe would
 	 * simply fail for lack of a matching serial driver.
 	 * Therefore save off udriver's id_table until we are all set.
+	 *
+	 * Suspend/resume support is implemented in the usb-serial core,
+	 * so fill in the PM-related fields in udriver.
 	 */
 	saved_id_table = udriver-&gt;id_table;
 	udriver-&gt;id_table = NULL;
 
 	udriver-&gt;no_dynamic_id = 1;
+	udriver-&gt;supports_autosuspend = 1;
+	udriver-&gt;suspend = usb_serial_suspend;
+	udriver-&gt;resume = usb_serial_resume;
 	rc = usb_register(udriver);
 	if (rc)
 		return rc;</pre><hr><pre>commit ebf20de453042c066a289b90dd14d59de03dba2f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 1 11:28:49 2012 -0400

    EHCI: update PM methods in ehci-tegra.c
    
    This patch (as1547) rearranges the Power Management parts of the
    ehci-tegra driver to match the conventions used in other EHCI platform
    drivers.  In particular, the controller should not be powered down by
    the root hub's suspend routine; the controller's power level should be
    managed by the controller's own PM methods.
    
    The end result of the patch is that the standard ehci_bus_suspend()
    and ehci_bus_resume() methods can be used instead of special-purpose
    routines.  The driver now uses the standard dev_pm_ops methods instead
    of legacy power management.  Since there is no supported wakeup
    mechanism for the controller, runtime suspend is forbidden by default
    (this can be overridden via sysfs, if desired).
    
    These adjustments are needed in order to make ehci-tegra compatible
    with recent changes to the USB core.  The core now checks the root
    hub's status following bus suspend; if the controller is automatically
    powered down during bus suspend then the check will fail and the root
    hub will be resumed immediately.  Doing the controller power-down in a
    separate method avoids this problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Stephen Warren &lt;swarren@wwwdotorg.org&gt;
    Tested-by: Stephen Warren &lt;swarren@wwwdotorg.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index 86183366647f..73f3525e6921 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -24,6 +24,7 @@
 #include &lt;linux/gpio.h&gt;
 #include &lt;linux/of.h&gt;
 #include &lt;linux/of_gpio.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;mach/usb_phy.h&gt;
 #include &lt;mach/iomap.h&gt;
@@ -37,9 +38,7 @@ struct tegra_ehci_hcd {
 	struct clk *emc_clk;
 	struct usb_phy *transceiver;
 	int host_resumed;
-	int bus_suspended;
 	int port_resuming;
-	int power_down_on_bus_suspend;
 	enum tegra_usb_phy_port_speed port_speed;
 };
 
@@ -273,120 +272,6 @@ static void tegra_ehci_restart(struct usb_hcd *hcd)
 	up_write(&amp;ehci_cf_port_reset_rwsem);
 }
 
-static int tegra_usb_suspend(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-	struct ehci_regs __iomem *hw = tegra-&gt;ehci-&gt;regs;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;tegra-&gt;ehci-&gt;lock, flags);
-
-	tegra-&gt;port_speed = (readl(&amp;hw-&gt;port_status[0]) &gt;&gt; 26) &amp; 0x3;
-	ehci_halt(tegra-&gt;ehci);
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	spin_unlock_irqrestore(&amp;tegra-&gt;ehci-&gt;lock, flags);
-
-	tegra_ehci_power_down(hcd);
-	return 0;
-}
-
-static int tegra_usb_resume(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
-	struct ehci_regs __iomem *hw = ehci-&gt;regs;
-	unsigned long val;
-
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	tegra_ehci_power_up(hcd);
-
-	if (tegra-&gt;port_speed &gt; TEGRA_USB_PHY_PORT_SPEED_HIGH) {
-		/* Wait for the phy to detect new devices
-		 * before we restart the controller */
-		msleep(10);
-		goto restart;
-	}
-
-	/* Force the phy to keep data lines in suspend state */
-	tegra_ehci_phy_restore_start(tegra-&gt;phy, tegra-&gt;port_speed);
-
-	/* Enable host mode */
-	tdi_reset(ehci);
-
-	/* Enable Port Power */
-	val = readl(&amp;hw-&gt;port_status[0]);
-	val |= PORT_POWER;
-	writel(val, &amp;hw-&gt;port_status[0]);
-	udelay(10);
-
-	/* Check if the phy resume from LP0. When the phy resume from LP0
-	 * USB register will be reset. */
-	if (!readl(&amp;hw-&gt;async_next)) {
-		/* Program the field PTC based on the saved speed mode */
-		val = readl(&amp;hw-&gt;port_status[0]);
-		val &amp;= ~PORT_TEST(~0);
-		if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_HIGH)
-			val |= PORT_TEST_FORCE;
-		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_FULL)
-			val |= PORT_TEST(6);
-		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)
-			val |= PORT_TEST(7);
-		writel(val, &amp;hw-&gt;port_status[0]);
-		udelay(10);
-
-		/* Disable test mode by setting PTC field to NORMAL_OP */
-		val = readl(&amp;hw-&gt;port_status[0]);
-		val &amp;= ~PORT_TEST(~0);
-		writel(val, &amp;hw-&gt;port_status[0]);
-		udelay(10);
-	}
-
-	/* Poll until CCS is enabled */
-	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_CONNECT,
-						 PORT_CONNECT, 2000)) {
-		pr_err("%s: timeout waiting for PORT_CONNECT\n", __func__);
-		goto restart;
-	}
-
-	/* Poll until PE is enabled */
-	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_PE,
-						 PORT_PE, 2000)) {
-		pr_err("%s: timeout waiting for USB_PORTSC1_PE\n", __func__);
-		goto restart;
-	}
-
-	/* Clear the PCI status, to avoid an interrupt taken upon resume */
-	val = readl(&amp;hw-&gt;status);
-	val |= STS_PCD;
-	writel(val, &amp;hw-&gt;status);
-
-	/* Put controller in suspend mode by writing 1 to SUSP bit of PORTSC */
-	val = readl(&amp;hw-&gt;port_status[0]);
-	if ((val &amp; PORT_POWER) &amp;&amp; (val &amp; PORT_PE)) {
-		val |= PORT_SUSPEND;
-		writel(val, &amp;hw-&gt;port_status[0]);
-
-		/* Wait until port suspend completes */
-		if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_SUSPEND,
-							 PORT_SUSPEND, 1000)) {
-			pr_err("%s: timeout waiting for PORT_SUSPEND\n",
-								__func__);
-			goto restart;
-		}
-	}
-
-	tegra_ehci_phy_restore_end(tegra-&gt;phy);
-	return 0;
-
-restart:
-	if (tegra-&gt;port_speed &lt;= TEGRA_USB_PHY_PORT_SPEED_HIGH)
-		tegra_ehci_phy_restore_end(tegra-&gt;phy);
-
-	tegra_ehci_restart(hcd);
-	return 0;
-}
-
 static void tegra_ehci_shutdown(struct usb_hcd *hcd)
 {
 	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
@@ -434,36 +319,6 @@ static int tegra_ehci_setup(struct usb_hcd *hcd)
 	return retval;
 }
 
-#ifdef CONFIG_PM
-static int tegra_ehci_bus_suspend(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-	int error_status = 0;
-
-	error_status = ehci_bus_suspend(hcd);
-	if (!error_status &amp;&amp; tegra-&gt;power_down_on_bus_suspend) {
-		tegra_usb_suspend(hcd);
-		tegra-&gt;bus_suspended = 1;
-	}
-
-	return error_status;
-}
-
-static int tegra_ehci_bus_resume(struct usb_hcd *hcd)
-{
-	struct tegra_ehci_hcd *tegra = dev_get_drvdata(hcd-&gt;self.controller);
-
-	if (tegra-&gt;bus_suspended &amp;&amp; tegra-&gt;power_down_on_bus_suspend) {
-		tegra_usb_resume(hcd);
-		tegra-&gt;bus_suspended = 0;
-	}
-
-	tegra_usb_phy_preresume(tegra-&gt;phy);
-	tegra-&gt;port_resuming = 1;
-	return ehci_bus_resume(hcd);
-}
-#endif
-
 struct temp_buffer {
 	void *kmalloc_ptr;
 	void *old_xfer_buffer;
@@ -574,8 +429,8 @@ static const struct hc_driver tegra_ehci_hc_driver = {
 	.hub_control		= tegra_ehci_hub_control,
 	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
 #ifdef CONFIG_PM
-	.bus_suspend		= tegra_ehci_bus_suspend,
-	.bus_resume		= tegra_ehci_bus_resume,
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
 	.port_handed_over	= ehci_port_handed_over,
@@ -608,6 +463,183 @@ static int setup_vbus_gpio(struct platform_device *pdev)
 	return err;
 }
 
+#ifdef CONFIG_PM
+
+static int controller_suspend(struct device *dev)
+{
+	struct tegra_ehci_hcd *tegra =
+			platform_get_drvdata(to_platform_device(dev));
+	struct ehci_hcd	*ehci = tegra-&gt;ehci;
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	struct ehci_regs __iomem *hw = ehci-&gt;regs;
+	unsigned long flags;
+
+	if (time_before(jiffies, ehci-&gt;next_statechange))
+		msleep(10);
+
+	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+
+	tegra-&gt;port_speed = (readl(&amp;hw-&gt;port_status[0]) &gt;&gt; 26) &amp; 0x3;
+	ehci_halt(ehci);
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+
+	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+
+	tegra_ehci_power_down(hcd);
+	return 0;
+}
+
+static int controller_resume(struct device *dev)
+{
+	struct tegra_ehci_hcd *tegra =
+			platform_get_drvdata(to_platform_device(dev));
+	struct ehci_hcd	*ehci = tegra-&gt;ehci;
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	struct ehci_regs __iomem *hw = ehci-&gt;regs;
+	unsigned long val;
+
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+	tegra_ehci_power_up(hcd);
+
+	if (tegra-&gt;port_speed &gt; TEGRA_USB_PHY_PORT_SPEED_HIGH) {
+		/* Wait for the phy to detect new devices
+		 * before we restart the controller */
+		msleep(10);
+		goto restart;
+	}
+
+	/* Force the phy to keep data lines in suspend state */
+	tegra_ehci_phy_restore_start(tegra-&gt;phy, tegra-&gt;port_speed);
+
+	/* Enable host mode */
+	tdi_reset(ehci);
+
+	/* Enable Port Power */
+	val = readl(&amp;hw-&gt;port_status[0]);
+	val |= PORT_POWER;
+	writel(val, &amp;hw-&gt;port_status[0]);
+	udelay(10);
+
+	/* Check if the phy resume from LP0. When the phy resume from LP0
+	 * USB register will be reset. */
+	if (!readl(&amp;hw-&gt;async_next)) {
+		/* Program the field PTC based on the saved speed mode */
+		val = readl(&amp;hw-&gt;port_status[0]);
+		val &amp;= ~PORT_TEST(~0);
+		if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_HIGH)
+			val |= PORT_TEST_FORCE;
+		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_FULL)
+			val |= PORT_TEST(6);
+		else if (tegra-&gt;port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)
+			val |= PORT_TEST(7);
+		writel(val, &amp;hw-&gt;port_status[0]);
+		udelay(10);
+
+		/* Disable test mode by setting PTC field to NORMAL_OP */
+		val = readl(&amp;hw-&gt;port_status[0]);
+		val &amp;= ~PORT_TEST(~0);
+		writel(val, &amp;hw-&gt;port_status[0]);
+		udelay(10);
+	}
+
+	/* Poll until CCS is enabled */
+	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_CONNECT,
+						 PORT_CONNECT, 2000)) {
+		pr_err("%s: timeout waiting for PORT_CONNECT\n", __func__);
+		goto restart;
+	}
+
+	/* Poll until PE is enabled */
+	if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_PE,
+						 PORT_PE, 2000)) {
+		pr_err("%s: timeout waiting for USB_PORTSC1_PE\n", __func__);
+		goto restart;
+	}
+
+	/* Clear the PCI status, to avoid an interrupt taken upon resume */
+	val = readl(&amp;hw-&gt;status);
+	val |= STS_PCD;
+	writel(val, &amp;hw-&gt;status);
+
+	/* Put controller in suspend mode by writing 1 to SUSP bit of PORTSC */
+	val = readl(&amp;hw-&gt;port_status[0]);
+	if ((val &amp; PORT_POWER) &amp;&amp; (val &amp; PORT_PE)) {
+		val |= PORT_SUSPEND;
+		writel(val, &amp;hw-&gt;port_status[0]);
+
+		/* Wait until port suspend completes */
+		if (handshake(ehci, &amp;hw-&gt;port_status[0], PORT_SUSPEND,
+							 PORT_SUSPEND, 1000)) {
+			pr_err("%s: timeout waiting for PORT_SUSPEND\n",
+								__func__);
+			goto restart;
+		}
+	}
+
+	tegra_ehci_phy_restore_end(tegra-&gt;phy);
+	goto done;
+
+ restart:
+	if (tegra-&gt;port_speed &lt;= TEGRA_USB_PHY_PORT_SPEED_HIGH)
+		tegra_ehci_phy_restore_end(tegra-&gt;phy);
+
+	tegra_ehci_restart(hcd);
+
+ done:
+	tegra_usb_phy_preresume(tegra-&gt;phy);
+	tegra-&gt;port_resuming = 1;
+	return 0;
+}
+
+static int tegra_ehci_suspend(struct device *dev)
+{
+	struct tegra_ehci_hcd *tegra =
+			platform_get_drvdata(to_platform_device(dev));
+	struct usb_hcd *hcd = ehci_to_hcd(tegra-&gt;ehci);
+	int rc = 0;
+
+	/*
+	 * When system sleep is supported and USB controller wakeup is
+	 * implemented: If the controller is runtime-suspended and the
+	 * wakeup setting needs to be changed, call pm_runtime_resume().
+	 */
+	if (HCD_HW_ACCESSIBLE(hcd))
+		rc = controller_suspend(dev);
+	return rc;
+}
+
+static int tegra_ehci_resume(struct device *dev)
+{
+	int rc;
+
+	rc = controller_resume(dev);
+	if (rc == 0) {
+		pm_runtime_disable(dev);
+		pm_runtime_set_active(dev);
+		pm_runtime_enable(dev);
+	}
+	return rc;
+}
+
+static int tegra_ehci_runtime_suspend(struct device *dev)
+{
+	return controller_suspend(dev);
+}
+
+static int tegra_ehci_runtime_resume(struct device *dev)
+{
+	return controller_resume(dev);
+}
+
+static const struct dev_pm_ops tegra_ehci_pm_ops = {
+	.suspend	= tegra_ehci_suspend,
+	.resume		= tegra_ehci_resume,
+	.runtime_suspend = tegra_ehci_runtime_suspend,
+	.runtime_resume	= tegra_ehci_runtime_resume,
+};
+
+#endif
+
 static u64 tegra_ehci_dma_mask = DMA_BIT_MASK(32);
 
 static int tegra_ehci_probe(struct platform_device *pdev)
@@ -722,7 +754,6 @@ static int tegra_ehci_probe(struct platform_device *pdev)
 	}
 
 	tegra-&gt;host_resumed = 1;
-	tegra-&gt;power_down_on_bus_suspend = pdata-&gt;power_down_on_bus_suspend;
 	tegra-&gt;ehci = hcd_to_ehci(hcd);
 
 	irq = platform_get_irq(pdev, 0);
@@ -746,6 +777,14 @@ static int tegra_ehci_probe(struct platform_device *pdev)
 		goto fail;
 	}
 
+	pm_runtime_set_active(&amp;pdev-&gt;dev);
+	pm_runtime_get_noresume(&amp;pdev-&gt;dev);
+
+	/* Don't skip the pm_runtime_forbid call if wakeup isn't working */
+	/* if (!pdata-&gt;power_down_on_bus_suspend) */
+		pm_runtime_forbid(&amp;pdev-&gt;dev);
+	pm_runtime_enable(&amp;pdev-&gt;dev);
+	pm_runtime_put_sync(&amp;pdev-&gt;dev);
 	return err;
 
 fail:
@@ -772,33 +811,6 @@ static int tegra_ehci_probe(struct platform_device *pdev)
 	return err;
 }
 
-#ifdef CONFIG_PM
-static int tegra_ehci_resume(struct platform_device *pdev)
-{
-	struct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = ehci_to_hcd(tegra-&gt;ehci);
-
-	if (tegra-&gt;bus_suspended)
-		return 0;
-
-	return tegra_usb_resume(hcd);
-}
-
-static int tegra_ehci_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = ehci_to_hcd(tegra-&gt;ehci);
-
-	if (tegra-&gt;bus_suspended)
-		return 0;
-
-	if (time_before(jiffies, tegra-&gt;ehci-&gt;next_statechange))
-		msleep(10);
-
-	return tegra_usb_suspend(hcd);
-}
-#endif
-
 static int tegra_ehci_remove(struct platform_device *pdev)
 {
 	struct tegra_ehci_hcd *tegra = platform_get_drvdata(pdev);
@@ -807,6 +819,10 @@ static int tegra_ehci_remove(struct platform_device *pdev)
 	if (tegra == NULL || hcd == NULL)
 		return -EINVAL;
 
+	pm_runtime_get_sync(&amp;pdev-&gt;dev);
+	pm_runtime_disable(&amp;pdev-&gt;dev);
+	pm_runtime_put_noidle(&amp;pdev-&gt;dev);
+
 #ifdef CONFIG_USB_OTG_UTILS
 	if (tegra-&gt;transceiver) {
 		otg_set_host(tegra-&gt;transceiver-&gt;otg, NULL);
@@ -847,13 +863,12 @@ static struct of_device_id tegra_ehci_of_match[] __devinitdata = {
 static struct platform_driver tegra_ehci_driver = {
 	.probe		= tegra_ehci_probe,
 	.remove		= tegra_ehci_remove,
-#ifdef CONFIG_PM
-	.suspend	= tegra_ehci_suspend,
-	.resume		= tegra_ehci_resume,
-#endif
 	.shutdown	= tegra_ehci_hcd_shutdown,
 	.driver		= {
 		.name	= "tegra-ehci",
 		.of_match_table = tegra_ehci_of_match,
+#ifdef CONFIG_PM
+		.pm	= &amp;tegra_ehci_pm_ops,
+#endif
 	}
 };</pre><hr><pre>commit 320cd1e750f1bf3e47eb41209dcb2be07264cb76
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 26 11:31:57 2012 -0400

    usb: gadget: udc-core: fix incompatibility with dummy-hcd
    
    This patch (as1548) fixes a recently-introduced incompatibility
    between the UDC core and the dummy-hcd driver.  Commit
    8ae8090c82eb407267001f75b3d256b3bd4ae691 (usb: gadget: udc-core: fix
    asymmetric calls in remove_driver) moved the usb_gadget_udc_stop()
    call in usb_gadget_remove_driver() below the usb_gadget_disconnect()
    call.
    
    As a result, usb_gadget_disconnect() gets called at a time when the
    gadget driver believes it has been unbound but dummy-hcd believes
    it has not.  A nasty error ensues when dummy-hcd calls the gadget
    driver's disconnect method a second time.
    
    To fix the problem, this patch moves the gadget driver's unbind
    notification after the usb_gadget_disconnect() call.  Now nothing
    happens between the two unbind notifications, so nothing goes wrong.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Alexander Shishkin &lt;alexander.shishkin@linux.intel.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index df1bd87232dd..e5e44f8cde9a 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -263,8 +263,8 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 
 	if (udc_is_newstyle(udc)) {
 		udc-&gt;driver-&gt;disconnect(udc-&gt;gadget);
-		udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
 		usb_gadget_disconnect(udc-&gt;gadget);
+		udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
 		usb_gadget_udc_stop(udc-&gt;gadget, udc-&gt;driver);
 	} else {
 		usb_gadget_stop(udc-&gt;gadget, udc-&gt;driver);</pre><hr><pre>commit 151b61284776be2d6f02d48c23c3625678960b97
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 24 14:07:22 2012 -0400

    USB: EHCI: fix crash during suspend on ASUS computers
    
    This patch (as1545) fixes a problem affecting several ASUS computers:
    The machine crashes or corrupts memory when going into suspend if the
    ehci-hcd driver is bound to any controllers.  Users have been forced
    to unbind or unload ehci-hcd before putting their systems to sleep.
    
    After extensive testing, it was determined that the machines don't
    like going into suspend when any EHCI controllers are in the PCI D3
    power state.  Presumably this is a firmware bug, but there's nothing
    we can do about it except to avoid putting the controllers in D3
    during system sleep.
    
    The patch adds a new flag to indicate whether the problem is present,
    and avoids changing the controller's power state if the flag is set.
    Runtime suspend is unaffected; this matters only for system suspend.
    However as a side effect, the controller will not respond to remote
    wakeup requests while the system is asleep.  Hence USB wakeup is not
    functional -- but of course, this is already true in the current state
    of affairs.
    
    This fixes Bugzilla #42728.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Steven Rostedt &lt;rostedt@goodmis.org&gt;
    Tested-by: Andrey Rahmatullin &lt;wrar@wrar.name&gt;
    Tested-by: Oleksij Rempel (fishor) &lt;bug-track@fisher-privat.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 622b4a48e732..57ed9e400c06 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -493,6 +493,15 @@ static int hcd_pci_suspend_noirq(struct device *dev)
 
 	pci_save_state(pci_dev);
 
+	/*
+	 * Some systems crash if an EHCI controller is in D3 during
+	 * a sleep transition.  We have to leave such controllers in D0.
+	 */
+	if (hcd-&gt;broken_pci_sleep) {
+		dev_dbg(dev, "Staying in PCI D0\n");
+		return retval;
+	}
+
 	/* If the root hub is dead rather than suspended, disallow remote
 	 * wakeup.  usb_hc_died() should ensure that both hosts are marked as
 	 * dying, so we only need to check the primary roothub.
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 01bb7241d6ef..fe8dc069164e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -144,6 +144,14 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 			hcd-&gt;has_tt = 1;
 			tdi_reset(ehci);
 		}
+		if (pdev-&gt;subsystem_vendor == PCI_VENDOR_ID_ASUSTEK) {
+			/* EHCI #1 or #2 on 6 Series/C200 Series chipset */
+			if (pdev-&gt;device == 0x1c26 || pdev-&gt;device == 0x1c2d) {
+				ehci_info(ehci, "broken D3 during system sleep on ASUS\n");
+				hcd-&gt;broken_pci_sleep = 1;
+				device_set_wakeup_capable(&amp;pdev-&gt;dev, false);
+			}
+		}
 		break;
 	case PCI_VENDOR_ID_TDI:
 		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 5de415707c23..d28cc78a38e4 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -126,6 +126,8 @@ struct usb_hcd {
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
+	unsigned		broken_pci_sleep:1;	/* Don't put the
+			controller in PCI-D3 for system sleep */
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */</pre><hr><pre>commit 3d9545cc375d117554a9b35dfddadf9189c62775
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 23 13:54:36 2012 -0400

    EHCI: maintain the ehci-&gt;command value properly
    
    The ehci-hcd driver is a little haphazard about keeping track of the
    state of the USBCMD register.  The ehci-&gt;command field is supposed to
    hold the register's value (apart from a few special bits) at all
    times, but it isn't maintained properly.
    
    This patch (as1543) cleans up the situation.  It keeps ehci-&gt;command
    up-to-date, and uses that value rather than reading the register from
    the hardware whenever possible.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 680e1a31fb87..7561966fbdc4 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -1025,10 +1025,8 @@ static ssize_t debug_lpm_write(struct file *file, const char __user *user_buf,
 		if (strict_strtoul(buf + 5, 16, &amp;hird))
 			return -EINVAL;
 		printk(KERN_INFO "setting hird %s %lu\n", buf + 6, hird);
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-		temp &amp;= ~CMD_HIRD;
-		temp |= hird &lt;&lt; 24;
-		ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
+		ehci-&gt;command = (ehci-&gt;command &amp; ~CMD_HIRD) | (hird &lt;&lt; 24);
+		ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	} else if (strncmp(buf, "disable", 7) == 0) {
 		if (strict_strtoul(buf + 8, 10, &amp;port))
 			return -EINVAL;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a87c0573c860..de1e689d3df0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -226,8 +226,13 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	if ((temp &amp; STS_HALT) != 0)
 		return 0;
 
+	/*
+	 * This routine gets called during probe before ehci-&gt;command
+	 * has been initialized, so we can't rely on its value.
+	 */
+	ehci-&gt;command &amp;= ~CMD_RUN;
 	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	temp &amp;= ~CMD_RUN;
+	temp &amp;= ~(CMD_RUN | CMD_IAAD);
 	ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
 	return handshake (ehci, &amp;ehci-&gt;regs-&gt;status,
 			  STS_HALT, STS_HALT, 16 * 125);
@@ -347,6 +352,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	if (ehci-&gt;debug)
 		dbgp_external_startup();
 
+	ehci-&gt;command = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	ehci-&gt;port_c_suspend = ehci-&gt;suspended_ports =
 			ehci-&gt;resuming_ports = 0;
 	return retval;
@@ -363,16 +369,14 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 #endif
 
 	/* wait for any schedule enables/disables to take effect */
-	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) &lt;&lt; 10;
-	temp &amp;= STS_ASS | STS_PSS;
+	temp = (ehci-&gt;command &lt;&lt; 10) &amp; (STS_ASS | STS_PSS);
 	if (handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
 					STS_ASS | STS_PSS, temp, 16 * 125))
 		return;
 
 	/* then disable anything that's still active */
-	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	temp &amp;= ~(CMD_ASE | CMD_IAAD | CMD_PSE);
-	ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;command &amp;= ~(CMD_ASE | CMD_PSE);
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 
 	/* hardware can take 16 microframes to turn off ... */
 	handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 402e766df2fe..fc9e7cc6ac9b 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -233,7 +233,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	/* stop schedules, clean any completed work */
 	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		ehci_quiesce (ehci);
-	ehci-&gt;command = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	ehci_work(ehci);
 
 	/* Unlike other USB host controller types, EHCI doesn't have
@@ -374,6 +373,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	ehci_writel(ehci, (u32) ehci-&gt;async-&gt;qh_dma, &amp;ehci-&gt;regs-&gt;async_next);
 
 	/* restore CMD_RUN, framelist size, and irq threshold */
+	ehci-&gt;command |= CMD_RUN;
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 36ca5077cdf7..13f4f980841a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -981,14 +981,12 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head = ehci-&gt;async;
 	timer_action_done (ehci, TIMER_ASYNC_OFF);
 	if (!head-&gt;qh_next.qh) {
-		u32	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-
-		if (!(cmd &amp; CMD_ASE)) {
+		if (!(ehci-&gt;command &amp; CMD_ASE)) {
 			/* in case a clear of CMD_ASE didn't take yet */
 			(void)handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
 					STS_ASS, 0, 150);
-			cmd |= CMD_ASE;
-			ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+			ehci-&gt;command |= CMD_ASE;
+			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 			/* posted write need not be known to HC yet ... */
 		}
 	}
@@ -1204,7 +1202,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	int		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	struct ehci_qh	*prev;
 
 #ifdef DEBUG
@@ -1222,8 +1219,8 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		if (ehci-&gt;rh_state != EHCI_RH_HALTED
 				&amp;&amp; !ehci-&gt;reclaim) {
 			/* ... and CMD_IAAD clear */
-			ehci_writel(ehci, cmd &amp; ~CMD_ASE,
-				    &amp;ehci-&gt;regs-&gt;command);
+			ehci-&gt;command &amp;= ~CMD_ASE;
+			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 			wmb ();
 			// handshake later, if we need to
 			timer_action_done (ehci, TIMER_ASYNC_OFF);
@@ -1253,8 +1250,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		return;
 	}
 
-	cmd |= CMD_IAAD;
-	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+	ehci_writel(ehci, ehci-&gt;command | CMD_IAAD, &amp;ehci-&gt;regs-&gt;command);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	iaa_watchdog_start(ehci);
 }
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index a60679cbbf85..ffe8fc3bc7ef 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -481,7 +481,6 @@ static int tt_no_collision (
 
 static int enable_periodic (struct ehci_hcd *ehci)
 {
-	u32	cmd;
 	int	status;
 
 	if (ehci-&gt;periodic_sched++)
@@ -497,8 +496,8 @@ static int enable_periodic (struct ehci_hcd *ehci)
 		return status;
 	}
 
-	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) | CMD_PSE;
-	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;command |= CMD_PSE;
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... PSS happens later */
 
 	/* make sure ehci_work scans these */
@@ -511,7 +510,6 @@ static int enable_periodic (struct ehci_hcd *ehci)
 
 static int disable_periodic (struct ehci_hcd *ehci)
 {
-	u32	cmd;
 	int	status;
 
 	if (--ehci-&gt;periodic_sched)
@@ -537,8 +535,8 @@ static int disable_periodic (struct ehci_hcd *ehci)
 		return status;
 	}
 
-	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) &amp; ~CMD_PSE;
-	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;command &amp;= ~CMD_PSE;
+	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... */
 
 	free_cached_lists(ehci);</pre><hr><pre>commit 6feff1b92bedab133c5835e510d11f62e843b257
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 17 15:23:25 2012 -0400

    EHCI: don't try to clear the IAAD bit
    
    This patch (as1541) corrects a small mistake in ehci-hcd.  The IAAD
    (Interrupt on Async Advance Doorbell) bit in the USBCMD register is
    designed, as its name says, to act as a "doorbell".  That is, the
    driver activates the bit by setting it to 1, and the hardware
    deactivates it later by setting it back to 0.  The driver cannot clear
    the bit by writing a 0 to it; such writes are simply ignored.
    
    Therefore there is no reason for ehci-hcd to try to clear the bit.
    The patch removes the two instances where such attempts occur.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 057cdda7a489..343f40c23b5f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -415,9 +415,6 @@ static void ehci_iaa_watchdog(unsigned long param)
 		 * CMD_IAAD when it sets STS_IAA.)
 		 */
 		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-		if (cmd &amp; CMD_IAAD)
-			ehci_writel(ehci, cmd &amp; ~CMD_IAAD,
-					&amp;ehci-&gt;regs-&gt;command);
 
 		/* If IAA is set here it either legitimately triggered
 		 * before we cleared IAAD above (but _way_ late, so we'll
@@ -887,11 +884,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status &amp; STS_IAA) {
 		/* guard against (alleged) silicon errata */
-		if (cmd &amp; CMD_IAAD) {
-			ehci_writel(ehci, cmd &amp; ~CMD_IAAD,
-					&amp;ehci-&gt;regs-&gt;command);
+		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		}
 		if (ehci-&gt;reclaim) {
 			COUNT(ehci-&gt;stats.reclaim);
 			end_unlink_async(ehci);</pre>
    <div class="pagination">
        <a href='2_48.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><span>[49]</span><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_50.html'>Next&gt;&gt;</a>
    <div>
</body>
