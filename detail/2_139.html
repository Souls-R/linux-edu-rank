<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_138.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><span>[139]</span><a href='2_140.html'>140</a><a href='2_140.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2532178a68b5ce4e421d50ea1b1dcc0a1359f19d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:14:31 2005 -0400

    [PATCH] UHCI: Don't store device pointer in QH or TD
    
    This patch simplifies the uhci-hcd driver by removing the device pointer
    currently stored in the QH and TD structures.  Those pointers weren't
    being used for anything other than to increment the device's reference
    count, which is unnecessary since the device is used only when an URB
    completes, and outstanding URBs take their own reference to the device.
    As a useful side effect, this change means that uhci-hcd no longer needs
    to have the root-hub device available in the start routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 53ba8a56592e..6b87bd74b046 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -634,14 +634,14 @@ static int uhci_start(struct usb_hcd *hcd)
 		goto err_alloc_root_hub;
 	}
 
-	uhci-&gt;term_td = uhci_alloc_td(uhci, udev);
+	uhci-&gt;term_td = uhci_alloc_td(uhci);
 	if (!uhci-&gt;term_td) {
 		dev_err(uhci_dev(uhci), "unable to allocate terminating TD\n");
 		goto err_alloc_term_td;
 	}
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++) {
-		uhci-&gt;skelqh[i] = uhci_alloc_qh(uhci, udev);
+		uhci-&gt;skelqh[i] = uhci_alloc_qh(uhci);
 		if (!uhci-&gt;skelqh[i]) {
 			dev_err(uhci_dev(uhci), "unable to allocate QH\n");
 			goto err_alloc_skelqh;
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index d7c67b73eb7a..bf9c5f9b508b 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -114,7 +114,6 @@ struct uhci_qh {
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct usb_device *dev;
 	struct urb_priv *urbp;
 
 	struct list_head list;		/* P: uhci-&gt;frame_list_lock */
@@ -206,7 +205,6 @@ struct uhci_td {
 	/* Software fields */
 	dma_addr_t dma_handle;
 
-	struct usb_device *dev;
 	struct urb *urb;
 
 	struct list_head list;		/* P: urb-&gt;lock */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 77f264851e98..5f18084a116d 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -48,7 +48,7 @@ static inline void uhci_moveto_complete(struct uhci_hcd *uhci,
 	list_move_tail(&amp;urbp-&gt;urb_list, &amp;uhci-&gt;complete_list);
 }
 
-static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci, struct usb_device *dev)
+static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 {
 	dma_addr_t dma_handle;
 	struct uhci_td *td;
@@ -63,14 +63,11 @@ static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci, struct usb_device *d
 	td-&gt;buffer = 0;
 
 	td-&gt;frame = -1;
-	td-&gt;dev = dev;
 
 	INIT_LIST_HEAD(&amp;td-&gt;list);
 	INIT_LIST_HEAD(&amp;td-&gt;remove_list);
 	INIT_LIST_HEAD(&amp;td-&gt;fl_list);
 
-	usb_get_dev(dev);
-
 	return td;
 }
 
@@ -170,13 +167,10 @@ static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
 	if (!list_empty(&amp;td-&gt;fl_list))
 		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
 
-	if (td-&gt;dev)
-		usb_put_dev(td-&gt;dev);
-
 	dma_pool_free(uhci-&gt;td_pool, td, td-&gt;dma_handle);
 }
 
-static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci, struct usb_device *dev)
+static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci)
 {
 	dma_addr_t dma_handle;
 	struct uhci_qh *qh;
@@ -190,14 +184,11 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci, struct usb_device *d
 	qh-&gt;element = UHCI_PTR_TERM;
 	qh-&gt;link = UHCI_PTR_TERM;
 
-	qh-&gt;dev = dev;
 	qh-&gt;urbp = NULL;
 
 	INIT_LIST_HEAD(&amp;qh-&gt;list);
 	INIT_LIST_HEAD(&amp;qh-&gt;remove_list);
 
-	usb_get_dev(dev);
-
 	return qh;
 }
 
@@ -208,9 +199,6 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	if (!list_empty(&amp;qh-&gt;remove_list))
 		dev_warn(uhci_dev(uhci), "qh %p still in remove_list!\n", qh);
 
-	if (qh-&gt;dev)
-		usb_put_dev(qh-&gt;dev);
-
 	dma_pool_free(uhci-&gt;qh_pool, qh, qh-&gt;dma_handle);
 }
 
@@ -599,7 +587,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	/*
 	 * Build the TD for the control request setup packet
 	 */
-	td = uhci_alloc_td(uhci, urb-&gt;dev);
+	td = uhci_alloc_td(uhci);
 	if (!td)
 		return -ENOMEM;
 
@@ -628,7 +616,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 		if (pktsze &gt; maxsze)
 			pktsze = maxsze;
 
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 
@@ -646,7 +634,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	/*
 	 * Build the final TD for control status 
 	 */
-	td = uhci_alloc_td(uhci, urb-&gt;dev);
+	td = uhci_alloc_td(uhci);
 	if (!td)
 		return -ENOMEM;
 
@@ -668,7 +656,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	uhci_fill_td(td, status | TD_CTRL_IOC,
 		destination | uhci_explen(UHCI_NULL_DATA_SIZE), 0);
 
-	qh = uhci_alloc_qh(uhci, urb-&gt;dev);
+	qh = uhci_alloc_qh(uhci);
 	if (!qh)
 		return -ENOMEM;
 
@@ -867,7 +855,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 				status &amp;= ~TD_CTRL_SPD;
 		}
 
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 
@@ -893,7 +881,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	 */
 	if (usb_pipeout(urb-&gt;pipe) &amp;&amp; (urb-&gt;transfer_flags &amp; URB_ZERO_PACKET) &amp;&amp;
 	    !len &amp;&amp; urb-&gt;transfer_buffer_length) {
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 
@@ -915,7 +903,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 	 * flag setting. */
 	td-&gt;status |= cpu_to_le32(TD_CTRL_IOC);
 
-	qh = uhci_alloc_qh(uhci, urb-&gt;dev);
+	qh = uhci_alloc_qh(uhci);
 	if (!qh)
 		return -ENOMEM;
 
@@ -1098,7 +1086,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 		if (!urb-&gt;iso_frame_desc[i].length)
 			continue;
 
-		td = uhci_alloc_td(uhci, urb-&gt;dev);
+		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
 </pre><hr><pre>commit 7d35b9298539d2818c51fe9070b08cf9876016f4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 25 11:18:32 2005 -0400

    [PATCH] usbcore: Remove hub_set_power_budget
    
    This patch removes the hub_set_power_budget routine, which was used by a
    couple of HCDs to indicate that the root hub was running on battery power.
    In its place is a new field added to struct usb_hcd, which HCDs can set
    before the root hub is registered.  Special-case code in the hub driver
    knows to look at this field when configuring a root hub.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index ac5752778e39..3837f68bb7b3 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -87,6 +87,7 @@ struct usb_hcd {	/* usb_bus.hcpriv points to this */
 	void __iomem		*regs;		/* device memory/io */
 	u64			rsrc_start;	/* memory/io resource start */
 	u64			rsrc_len;	/* memory/io resource length */
+	unsigned		power_budget;	/* in mA, 0 = no limit */
 
 #define HCD_BUFFER_POOLS	4
 	struct dma_pool		*pool [HCD_BUFFER_POOLS];
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6d1a330d577b..63ee3d97b6a9 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -643,15 +643,21 @@ static int hub_configure(struct usb_hub *hub,
 		message = "can't get hub status";
 		goto fail;
 	}
-	cpu_to_le16s(&amp;hubstatus);
-	if ((hubstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
+	le16_to_cpus(&amp;hubstatus);
+	if (hdev == hdev-&gt;bus-&gt;root_hub) {
+		struct usb_hcd *hcd =
+				container_of(hdev-&gt;bus, struct usb_hcd, self);
+
+		hub-&gt;power_budget = min(500u, hcd-&gt;power_budget) / 2;
+	} else if ((hubstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 		dev_dbg(hub_dev, "hub controller current requirement: %dmA\n",
 			hub-&gt;descriptor-&gt;bHubContrCurrent);
 		hub-&gt;power_budget = (501 - hub-&gt;descriptor-&gt;bHubContrCurrent)
 					/ 2;
+	}
+	if (hub-&gt;power_budget)
 		dev_dbg(hub_dev, "%dmA bus power budget for children\n",
 			hub-&gt;power_budget * 2);
-	}
 
 
 	ret = hub_hub_status(hub, &amp;hubstatus, &amp;hubchange);
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index d114b847d56f..53bf5649621e 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -224,15 +224,4 @@ struct usb_hub {
 	struct work_struct	leds;
 };
 
-/* use this for low-powered root hubs */
-static inline void
-hub_set_power_budget (struct usb_device *hubdev, unsigned mA)
-{
-	struct usb_hub	*hub;
-
-	hub = (struct usb_hub *)
-		usb_get_intfdata (hubdev-&gt;actconfig-&gt;interface[0]);
-	hub-&gt;power_budget = min(mA,(unsigned)500)/2;
-}
-
 #endif /* __LINUX_HUB_H */</pre><hr><pre>commit d5926ae7a827bdd06b588ffbc56fd4525cd9214a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 21 15:56:37 2005 -0400

    [PATCH] usbcore support for root-hub IRQ instead of polling
    
    This is a revised version of an earlier patch to add support to usbcore
    for driving root hubs by interrupts rather than polling.
    
    There's a temporary flag added to struct usb_hcd, marking devices whose
    drivers are aware of the new mechanism.  By default that flag doesn't get
    set so drivers will continue to see the same polling behavior as before.
    This way we can convert the HCDs one by one to use interrupt-based event
    reporting, and the temporary flag can be removed when they're all done.
    
    Also included is a small change to the hcd_disable_endpoint routine.
    Although endpoints normally shouldn't be disabled while a controller is
    suspended, it's legal to do so when the controller's driver is being
    rmmod'ed.
    
    Lastly the patch adds a new callback, .hub_irq_enable, for use by HCDs
    where the root hub's port-change interrupts are level-triggered rather
    than edge-triggered.  The callback is invoked each time khubd has finished
    processing a root hub, to let the HCD know that the interrupt can safely
    be re-enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 0da23732e807..1180c157b717 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -519,119 +519,120 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 /*-------------------------------------------------------------------------*/
 
 /*
- * Root Hub interrupt transfers are synthesized with a timer.
- * Completions are called in_interrupt() but not in_irq().
+ * Root Hub interrupt transfers are polled using a timer if the
+ * driver requests it; otherwise the driver is responsible for
+ * calling usb_hcd_poll_rh_status() when an event occurs.
  *
- * Note: some root hubs (including common UHCI based designs) can't
- * correctly issue port change IRQs.  They're the ones that _need_ a
- * timer; most other root hubs don't.  Some systems could save a
- * lot of battery power by eliminating these root hub timer IRQs.
+ * Completions are called in_interrupt(), but they may or may not
+ * be in_irq().
  */
+void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
+{
+	struct urb	*urb;
+	int		length;
+	unsigned long	flags;
+	char		buffer[4];	/* Any root hubs with &gt; 31 ports? */
 
-static void rh_report_status (unsigned long ptr);
+	if (!hcd-&gt;uses_new_polling &amp;&amp; !hcd-&gt;status_urb)
+		return;
 
-static int rh_status_urb (struct usb_hcd *hcd, struct urb *urb) 
-{
-	int	len = 1 + (urb-&gt;dev-&gt;maxchild / 8);
+	length = hcd-&gt;driver-&gt;hub_status_data(hcd, buffer);
+	if (length &gt; 0) {
 
-	/* rh_timer protected by hcd_data_lock */
-	if (hcd-&gt;rh_timer.data || urb-&gt;transfer_buffer_length &lt; len) {
-		dev_dbg (hcd-&gt;self.controller,
-				"not queuing rh status urb, stat %d\n",
-				urb-&gt;status);
-		return -EINVAL;
+		/* try to complete the status urb */
+		local_irq_save (flags);
+		spin_lock(&amp;hcd_root_hub_lock);
+		urb = hcd-&gt;status_urb;
+		if (urb) {
+			spin_lock(&amp;urb-&gt;lock);
+			if (urb-&gt;status == -EINPROGRESS) {
+				hcd-&gt;poll_pending = 0;
+				hcd-&gt;status_urb = NULL;
+				urb-&gt;status = 0;
+				urb-&gt;hcpriv = NULL;
+				urb-&gt;actual_length = length;
+				memcpy(urb-&gt;transfer_buffer, buffer, length);
+			} else		/* urb has been unlinked */
+				length = 0;
+			spin_unlock(&amp;urb-&gt;lock);
+		} else
+			length = 0;
+		spin_unlock(&amp;hcd_root_hub_lock);
+
+		/* local irqs are always blocked in completions */
+		if (length &gt; 0)
+			usb_hcd_giveback_urb (hcd, urb, NULL);
+		else
+			hcd-&gt;poll_pending = 1;
+		local_irq_restore (flags);
 	}
 
-	init_timer (&amp;hcd-&gt;rh_timer);
-	hcd-&gt;rh_timer.function = rh_report_status;
-	hcd-&gt;rh_timer.data = (unsigned long) urb;
-	/* USB 2.0 spec says 256msec; this is close enough */
-	hcd-&gt;rh_timer.expires = jiffies + HZ/4;
-	add_timer (&amp;hcd-&gt;rh_timer);
-	urb-&gt;hcpriv = hcd;	/* nonzero to indicate it's queued */
-	return 0;
+	/* The USB 2.0 spec says 256 ms.  This is close enough and won't
+	 * exceed that limit if HZ is 100. */
+	if (hcd-&gt;uses_new_polling ? hcd-&gt;poll_rh :
+			(length == 0 &amp;&amp; hcd-&gt;status_urb != NULL))
+		mod_timer (&amp;hcd-&gt;rh_timer, jiffies + msecs_to_jiffies(250));
 }
+EXPORT_SYMBOL_GPL(usb_hcd_poll_rh_status);
 
 /* timer callback */
+static void rh_timer_func (unsigned long _hcd)
+{
+	usb_hcd_poll_rh_status((struct usb_hcd *) _hcd);
+}
+
+/*-------------------------------------------------------------------------*/
 
-static void rh_report_status (unsigned long ptr)
+static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)
 {
-	struct urb	*urb;
-	struct usb_hcd	*hcd;
-	int		length = 0;
+	int		retval;
 	unsigned long	flags;
+	int		len = 1 + (urb-&gt;dev-&gt;maxchild / 8);
 
-	urb = (struct urb *) ptr;
-	local_irq_save (flags);
-	spin_lock (&amp;urb-&gt;lock);
+	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
+	if (urb-&gt;status != -EINPROGRESS)	/* already unlinked */
+		retval = urb-&gt;status;
+	else if (hcd-&gt;status_urb || urb-&gt;transfer_buffer_length &lt; len) {
+		dev_dbg (hcd-&gt;self.controller, "not queuing rh status urb\n");
+		retval = -EINVAL;
+	} else {
+		hcd-&gt;status_urb = urb;
+		urb-&gt;hcpriv = hcd;	/* indicate it's queued */
 
-	/* do nothing if the urb's been unlinked */
-	if (!urb-&gt;dev
-			|| urb-&gt;status != -EINPROGRESS
-			|| (hcd = urb-&gt;dev-&gt;bus-&gt;hcpriv) == NULL) {
-		spin_unlock (&amp;urb-&gt;lock);
-		local_irq_restore (flags);
-		return;
-	}
+		if (!hcd-&gt;uses_new_polling)
+			mod_timer (&amp;hcd-&gt;rh_timer, jiffies +
+					msecs_to_jiffies(250));
 
-	/* complete the status urb, or retrigger the timer */
-	spin_lock (&amp;hcd_data_lock);
-	if (urb-&gt;dev-&gt;state == USB_STATE_CONFIGURED) {
-		length = hcd-&gt;driver-&gt;hub_status_data (
-					hcd, urb-&gt;transfer_buffer);
-		if (length &gt; 0) {
-			hcd-&gt;rh_timer.data = 0;
-			urb-&gt;actual_length = length;
-			urb-&gt;status = 0;
-			urb-&gt;hcpriv = NULL;
-		} else
-			mod_timer (&amp;hcd-&gt;rh_timer, jiffies + HZ/4);
+		/* If a status change has already occurred, report it ASAP */
+		else if (hcd-&gt;poll_pending)
+			mod_timer (&amp;hcd-&gt;rh_timer, jiffies);
+		retval = 0;
 	}
-	spin_unlock (&amp;hcd_data_lock);
-	spin_unlock (&amp;urb-&gt;lock);
-
-	/* local irqs are always blocked in completions */
-	if (length &gt; 0)
-		usb_hcd_giveback_urb (hcd, urb, NULL);
-	local_irq_restore (flags);
+	spin_unlock_irqrestore (&amp;hcd_root_hub_lock, flags);
+	return retval;
 }
 
-/*-------------------------------------------------------------------------*/
-
 static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 {
-	if (usb_pipeint (urb-&gt;pipe)) {
-		int		retval;
-		unsigned long	flags;
-
-		spin_lock_irqsave (&amp;hcd_data_lock, flags);
-		retval = rh_status_urb (hcd, urb);
-		spin_unlock_irqrestore (&amp;hcd_data_lock, flags);
-		return retval;
-	}
+	if (usb_pipeint (urb-&gt;pipe))
+		return rh_queue_status (hcd, urb);
 	if (usb_pipecontrol (urb-&gt;pipe))
 		return rh_call_control (hcd, urb);
-	else
-		return -EINVAL;
+	return -EINVAL;
 }
 
 /*-------------------------------------------------------------------------*/
 
+/* Asynchronous unlinks of root-hub control URBs are legal, but they
+ * don't do anything.  Status URB unlinks must be made in process context
+ * with interrupts enabled.
+ */
 static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
-	unsigned long	flags;
-
-	/* note:  always a synchronous unlink */
-	if ((unsigned long) urb == hcd-&gt;rh_timer.data) {
-		del_timer_sync (&amp;hcd-&gt;rh_timer);
-		hcd-&gt;rh_timer.data = 0;
-
-		local_irq_save (flags);
-		urb-&gt;hcpriv = NULL;
-		usb_hcd_giveback_urb (hcd, urb, NULL);
-		local_irq_restore (flags);
+	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
+		if (in_interrupt())
+			return 0;		/* nothing to do */
 
-	} else if (usb_pipeendpoint(urb-&gt;pipe) == 0) {
 		spin_lock_irq(&amp;urb-&gt;lock);	/* from usb_kill_urb */
 		++urb-&gt;reject;
 		spin_unlock_irq(&amp;urb-&gt;lock);
@@ -642,8 +643,22 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		spin_lock_irq(&amp;urb-&gt;lock);
 		--urb-&gt;reject;
 		spin_unlock_irq(&amp;urb-&gt;lock);
-	} else
-		return -EINVAL;
+
+	} else {				/* Status URB */
+		if (!hcd-&gt;uses_new_polling)
+			del_timer_sync (&amp;hcd-&gt;rh_timer);
+		local_irq_disable ();
+		spin_lock (&amp;hcd_root_hub_lock);
+		if (urb == hcd-&gt;status_urb) {
+			hcd-&gt;status_urb = NULL;
+			urb-&gt;hcpriv = NULL;
+		} else
+			urb = NULL;		/* wasn't fully queued */
+		spin_unlock (&amp;hcd_root_hub_lock);
+		if (urb)
+			usb_hcd_giveback_urb (hcd, urb, NULL);
+		local_irq_enable ();
+	}
 
 	return 0;
 }
@@ -885,6 +900,16 @@ int usb_hcd_register_root_hub (struct usb_device *usb_dev, struct usb_hcd *hcd)
 }
 EXPORT_SYMBOL_GPL(usb_hcd_register_root_hub);
 
+void usb_enable_root_hub_irq (struct usb_bus *bus)
+{
+	struct usb_hcd *hcd;
+
+	hcd = container_of (bus, struct usb_hcd, self);
+	if (hcd-&gt;driver-&gt;hub_irq_enable &amp;&amp; !hcd-&gt;poll_rh &amp;&amp;
+			hcd-&gt;state != HC_STATE_HALT)
+		hcd-&gt;driver-&gt;hub_irq_enable (hcd);
+}
+
 
 /*-------------------------------------------------------------------------*/
 
@@ -1348,7 +1373,8 @@ hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
 
 	hcd = udev-&gt;bus-&gt;hcpriv;
 
-	WARN_ON (!HC_IS_RUNNING (hcd-&gt;state) &amp;&amp; hcd-&gt;state != HC_STATE_HALT);
+	WARN_ON (!HC_IS_RUNNING (hcd-&gt;state) &amp;&amp; hcd-&gt;state != HC_STATE_HALT &amp;&amp;
+			udev-&gt;state != USB_STATE_NOTATTACHED);
 
 	local_irq_disable ();
 
@@ -1612,6 +1638,8 @@ void usb_hc_died (struct usb_hcd *hcd)
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
 	if (hcd-&gt;rh_registered) {
+		hcd-&gt;poll_rh = 0;
+		del_timer(&amp;hcd-&gt;rh_timer);
 
 		/* make khubd clean up old urbs and devices */
 		usb_set_device_state (hcd-&gt;self.root_hub,
@@ -1665,6 +1693,8 @@ struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
 	hcd-&gt;self.bus_name = bus_name;
 
 	init_timer(&amp;hcd-&gt;rh_timer);
+	hcd-&gt;rh_timer.function = rh_timer_func;
+	hcd-&gt;rh_timer.data = (unsigned long) hcd;
 
 	hcd-&gt;driver = driver;
 	hcd-&gt;product_desc = (driver-&gt;product_desc) ? driver-&gt;product_desc :
@@ -1748,6 +1778,8 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		goto err3;
 	}
 
+	if (hcd-&gt;uses_new_polling &amp;&amp; hcd-&gt;poll_rh)
+		usb_hcd_poll_rh_status(hcd);
 	return retval;
 
  err3:
@@ -1782,6 +1814,9 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	spin_unlock_irq (&amp;hcd_root_hub_lock);
 	usb_disconnect(&amp;hcd-&gt;self.root_hub);
 
+	hcd-&gt;poll_rh = 0;
+	del_timer_sync(&amp;hcd-&gt;rh_timer);
+
 	hcd-&gt;driver-&gt;stop(hcd);
 	hcd-&gt;state = HC_STATE_HALT;
 
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 325a51656c3f..ac5752778e39 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -65,7 +65,8 @@ struct usb_hcd {	/* usb_bus.hcpriv points to this */
 	const char		*product_desc;	/* product/vendor string */
 	char			irq_descr[24];	/* driver + bus # */
 
-	struct timer_list	rh_timer;	/* drives root hub */
+	struct timer_list	rh_timer;	/* drives root-hub polling */
+	struct urb		*status_urb;	/* the current status urb */
 
 	/*
 	 * hardware info/state
@@ -76,6 +77,12 @@ struct usb_hcd {	/* usb_bus.hcpriv points to this */
 	unsigned		remote_wakeup:1;/* sw should use wakeup? */
 	unsigned		rh_registered:1;/* is root hub registered? */
 
+	/* The next flag is a stopgap, to be removed when all the HCDs
+	 * support the new root-hub polling mechanism. */
+	unsigned		uses_new_polling:1;
+	unsigned		poll_rh:1;	/* poll for rh status? */
+	unsigned		poll_pending:1;	/* status has changed? */
+
 	int			irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
 	u64			rsrc_start;	/* memory/io resource start */
@@ -207,6 +214,8 @@ struct hc_driver {
 	int		(*hub_suspend)(struct usb_hcd *);
 	int		(*hub_resume)(struct usb_hcd *);
 	int		(*start_port_reset)(struct usb_hcd *, unsigned port_num);
+	void		(*hub_irq_enable)(struct usb_hcd *);
+		/* Needed only if port-change IRQs are level-triggered */
 };
 
 extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb, struct pt_regs *regs);
@@ -243,7 +252,9 @@ void hcd_buffer_free (struct usb_bus *bus, size_t size,
 
 /* generic bus glue, needed for host controllers that don't use PCI */
 extern irqreturn_t usb_hcd_irq (int irq, void *__hcd, struct pt_regs *r);
+
 extern void usb_hc_died (struct usb_hcd *hcd);
+extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
 
 /* -------------------------------------------------------------------------- */
 
@@ -360,6 +371,8 @@ extern wait_queue_head_t usb_kill_urb_queue;
 extern struct usb_bus *usb_bus_get (struct usb_bus *bus);
 extern void usb_bus_put (struct usb_bus *bus);
 
+extern void usb_enable_root_hub_irq (struct usb_bus *bus);
+
 extern int usb_find_interface_driver (struct usb_device *dev,
 	struct usb_interface *interface);
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a8d879a85d04..6d1a330d577b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2787,6 +2787,11 @@ static void hub_events(void)
 
 		hub-&gt;activating = 0;
 
+		/* If this is a root hub, tell the HCD it's okay to
+		 * re-enable port-change interrupts now. */
+		if (!hdev-&gt;parent)
+			usb_enable_root_hub_irq(hdev-&gt;bus);
+
 loop:
 		usb_unlock_device(hdev);
 		usb_put_intf(intf);</pre><hr><pre>commit 02597d2deec2a3de0e2b52c1f83904b65626a0d5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 28 14:51:27 2005 -0400

    [PATCH] USB UHCI: Add shutdown method
    
    After all the discussion you might not be interested in this still, but
    nevertheless here it is.  This patch adds a shutdown method to the
    uhci-hcd driver.  Its prerequisite is the patch you wrote adding shutdown
    support for PCI.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index cec070fa8c83..53ba8a56592e 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -154,6 +154,7 @@ static void reset_hc(struct uhci_hcd *uhci)
 
 /*
  * Last rites for a defunct/nonfunctional controller
+ * or one we don't want to use any more.
  */
 static void hc_died(struct uhci_hcd *uhci)
 {
@@ -525,6 +526,20 @@ static int uhci_reset(struct usb_hcd *hcd)
 	return 0;
 }
 
+/* Make sure the controller is quiescent and that we're not using it
+ * any more.  This is mainly for the benefit of programs which, like kexec,
+ * expect the hardware to be idle: not doing DMA or generating IRQs.
+ *
+ * This routine may be called in a damaged or failing kernel.  Hence we
+ * do not acquire the spinlock before shutting down the controller.
+ */
+static void uhci_shutdown(struct pci_dev *pdev)
+{
+	struct usb_hcd *hcd = (struct usb_hcd *) pci_get_drvdata(pdev);
+
+	hc_died(hcd_to_uhci(hcd));
+}
+
 /*
  * Allocate a frame list, and then setup the skeleton
  *
@@ -939,6 +954,7 @@ static struct pci_driver uhci_pci_driver = {
 
 	.probe =	usb_hcd_pci_probe,
 	.remove =	usb_hcd_pci_remove,
+	.shutdown =	uhci_shutdown,
 
 #ifdef	CONFIG_PM
 	.suspend =	usb_hcd_pci_suspend,</pre><hr><pre>commit c074b416b94c0aa4a371f24bf6cc13d8cf1fab59
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 22 14:39:12 2005 -0400

    [PATCH] USB UHCI: improved reset handling
    
    This patch improves the strategy uhci-hcd uses for performing controller
    resets and checking whether they are needed.
    
            The HCRESET command doesn't affect the Suspend, Resume,
            or Reset bits in the port status &amp; control registers, so
            the driver must clear them by itself.  This means the
            code to figure out how many ports there are has to be moved
            to an earlier spot in the driver.
    
            The R/WC bits in the USBLEGSUP register can be set by the
            hardware even in the absence of BIOS meddling with legacy
            support features.  Hence it's not a good idea to check them
            while trying to determine whether the BIOS has altered the
            controller's state.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 25a718eb1d0f..cec070fa8c83 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -112,6 +112,8 @@ static inline void restart_timer(struct uhci_hcd *uhci)
  */
 static void reset_hc(struct uhci_hcd *uhci)
 {
+	int port;
+
 	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
 	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
 	 */
@@ -135,6 +137,13 @@ static void reset_hc(struct uhci_hcd *uhci)
 	outw(0, uhci-&gt;io_addr + USBINTR);
 	outw(0, uhci-&gt;io_addr + USBCMD);
 
+	/* HCRESET doesn't affect the Suspend, Reset, and Resume Detect
+	 * bits in the port status and control registers.
+	 * We have to clear them by hand.
+	 */
+	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port)
+		outw(0, uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
+
 	uhci-&gt;port_c_suspend = uhci-&gt;suspended_ports =
 			uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
@@ -166,14 +175,14 @@ static void check_and_reset_hc(struct uhci_hcd *uhci)
 	 * When restarting a suspended controller, we expect all the
 	 * settings to be the same as we left them:
 	 *
-	 *	PIRQ and SMI disabled, no R/WC bits set in USBLEGSUP;
+	 *	PIRQ and SMI disabled, no R/W bits set in USBLEGSUP;
 	 *	Controller is stopped and configured with EGSM set;
 	 *	No interrupts enabled except possibly Resume Detect.
 	 *
 	 * If any of these conditions are violated we do a complete reset.
 	 */
 	pci_read_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, &amp;legsup);
-	if (legsup &amp; ~USBLEGSUP_RO) {
+	if (legsup &amp; ~(USBLEGSUP_RO | USBLEGSUP_RWC)) {
 		dev_dbg(uhci_dev(uhci), "%s: legsup = 0x%04x\n",
 				__FUNCTION__, legsup);
 		goto reset_needed;
@@ -478,9 +487,37 @@ static void release_uhci(struct uhci_hcd *uhci)
 static int uhci_reset(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned io_size = (unsigned) hcd-&gt;rsrc_len;
+	int port;
 
 	uhci-&gt;io_addr = (unsigned long) hcd-&gt;rsrc_start;
 
+	/* The UHCI spec says devices must have 2 ports, and goes on to say
+	 * they may have more but gives no way to determine how many there
+	 * are.  However, according to the UHCI spec, Bit 7 of the port
+	 * status and control register is always set to 1.  So we try to
+	 * use this to our advantage.
+	 */
+	for (port = 0; port &lt; (io_size - USBPORTSC1) / 2; port++) {
+		unsigned int portstatus;
+
+		portstatus = inw(uhci-&gt;io_addr + USBPORTSC1 + (port * 2));
+		if (!(portstatus &amp; 0x0080))
+			break;
+	}
+	if (debug)
+		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
+
+	/* Anything less than 2 or greater than 7 is weird,
+	 * so we'll ignore it.
+	 */
+	if (port &lt; 2 || port &gt; UHCI_RH_MAXCHILD) {
+		dev_info(uhci_dev(uhci), "port count misdetected? "
+				"forcing to 2 ports\n");
+		port = 2;
+	}
+	uhci-&gt;rh_numports = port;
+
 	/* Kick BIOS off this hardware and reset if the controller
 	 * isn't already safely quiescent.
 	 */
@@ -508,13 +545,11 @@ static int uhci_start(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int retval = -EBUSY;
-	int i, port;
-	unsigned io_size;
+	int i;
 	dma_addr_t dma_handle;
 	struct usb_device *udev;
 	struct dentry *dentry;
 
-	io_size = (unsigned) hcd-&gt;rsrc_len;
 	hcd-&gt;uses_new_polling = 1;
 	if (pci_find_capability(to_pci_dev(uhci_dev(uhci)), PCI_CAP_ID_PM))
 		hcd-&gt;can_wakeup = 1;		/* Assume it supports PME# */
@@ -578,30 +613,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	/* Initialize the root hub */
 
-	/* UHCI specs says devices must have 2 ports, but goes on to say */
-	/*  they may have more but give no way to determine how many they */
-	/*  have. However, according to the UHCI spec, Bit 7 is always set */
-	/*  to 1. So we try to use this to our advantage */
-	for (port = 0; port &lt; (io_size - 0x10) / 2; port++) {
-		unsigned int portstatus;
-
-		portstatus = inw(uhci-&gt;io_addr + 0x10 + (port * 2));
-		if (!(portstatus &amp; 0x0080))
-			break;
-	}
-	if (debug)
-		dev_info(uhci_dev(uhci), "detected %d ports\n", port);
-
-	/* This is experimental so anything less than 2 or greater than 8 is */
-	/*  something weird and we'll ignore it */
-	if (port &lt; 2 || port &gt; UHCI_RH_MAXCHILD) {
-		dev_info(uhci_dev(uhci), "port count misdetected? "
-				"forcing to 2 ports\n");
-		port = 2;
-	}
-
-	uhci-&gt;rh_numports = port;
-
 	udev = usb_alloc_dev(NULL, &amp;hcd-&gt;self, 0);
 	if (!udev) {
 		dev_err(uhci_dev(uhci), "unable to allocate root hub\n");</pre><hr><pre>commit 6c1b445c226dd82d0961725dec8051b95003723a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 21 16:04:58 2005 -0400

    [PATCH] USB UHCI: Use root-hub IRQs while suspended
    
    This patch, which has as478b as a prerequisite, enables the uhci-hcd
    driver to take advantage of root-hub IRQs rather than polling during the
    time it is suspended.  (Unfortunately the hardware doesn't support
    port-change interrupts while the controller is running.)  It also turns
    off the driver's private timer while the controller is suspended, as it
    isn't needed then.  The combined elimination of polling interrupts and
    timer interrupts ought to be enough to allow some systems to save a
    noticeable amount of power while they are otherwise idle.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 82e608a4bbd0..25a718eb1d0f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -84,6 +84,8 @@ static char *errbuf;
 
 static kmem_cache_t *uhci_up_cachep;	/* urb_priv */
 
+static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);
+static void wakeup_rh(struct uhci_hcd *uhci);
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 
 /* If a transfer is still active after this much time, turn off FSBR */
@@ -133,12 +135,12 @@ static void reset_hc(struct uhci_hcd *uhci)
 	outw(0, uhci-&gt;io_addr + USBINTR);
 	outw(0, uhci-&gt;io_addr + USBCMD);
 
-	uhci-&gt;resume_detect = 0;
 	uhci-&gt;port_c_suspend = uhci-&gt;suspended_ports =
 			uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
+	uhci_to_hcd(uhci)-&gt;poll_rh = 0;
 }
 
 /*
@@ -148,6 +150,7 @@ static void hc_died(struct uhci_hcd *uhci)
 {
 	reset_hc(uhci);
 	uhci-&gt;hc_inaccessible = 1;
+	del_timer(&amp;uhci-&gt;stall_timer);
 }
 
 /*
@@ -302,14 +305,14 @@ __acquires(uhci-&gt;lock)
 
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
-	uhci-&gt;resume_detect = 0;
+	del_timer(&amp;uhci-&gt;stall_timer);
+	uhci_to_hcd(uhci)-&gt;poll_rh = !int_enable;
 
 	uhci_scan_schedule(uhci, NULL);
 }
 
 static void start_rh(struct uhci_hcd *uhci)
 {
-	uhci-&gt;rh_state = UHCI_RH_RUNNING;
 	uhci-&gt;is_stopped = 0;
 	smp_wmb();
 
@@ -320,6 +323,9 @@ static void start_rh(struct uhci_hcd *uhci)
 	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
 			uhci-&gt;io_addr + USBINTR);
 	mb();
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
+	uhci_to_hcd(uhci)-&gt;poll_rh = 1;
+	restart_timer(uhci);
 }
 
 static void wakeup_rh(struct uhci_hcd *uhci)
@@ -353,36 +359,9 @@ __acquires(uhci-&gt;lock)
 	}
 
 	start_rh(uhci);
-}
-
-static void rh_state_transitions(struct uhci_hcd *uhci)
-{
-	switch (uhci-&gt;rh_state) {
-	    case UHCI_RH_RUNNING:
-		/* are any devices attached? */
-		if (!any_ports_active(uhci)) {
-			uhci-&gt;rh_state = UHCI_RH_RUNNING_NODEVS;
-			uhci-&gt;auto_stop_time = jiffies + HZ;
-		}
-		break;
 
-	    case UHCI_RH_RUNNING_NODEVS:
-		/* auto-stop if nothing connected for 1 second */
-		if (any_ports_active(uhci))
-			uhci-&gt;rh_state = UHCI_RH_RUNNING;
-		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
-			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
-		break;
-
-	    case UHCI_RH_AUTO_STOPPED:
-		/* wakeup if requested by a device */
-		if (uhci-&gt;resume_detect)
-			wakeup_rh(uhci);
-		break;
-
-	    default:
-		break;
-	}
+	/* Restart root hub polling */
+	mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer, jiffies);
 }
 
 static void stall_callback(unsigned long _uhci)
@@ -394,14 +373,8 @@ static void stall_callback(unsigned long _uhci)
 	uhci_scan_schedule(uhci, NULL);
 	check_fsbr(uhci);
 
-	/* Poll for and perform state transitions */
-	if (!uhci-&gt;hc_inaccessible) {
-		rh_state_transitions(uhci);
-		if (uhci-&gt;suspended_ports)
-			uhci_check_ports(uhci);
-	}
-
-	restart_timer(uhci);
+	if (!uhci-&gt;is_stopped)
+		restart_timer(uhci);
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
@@ -443,7 +416,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 	}
 
 	if (status &amp; USBSTS_RD)
-		uhci-&gt;resume_detect = 1;
+		usb_hcd_poll_rh_status(hcd);
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	uhci_scan_schedule(uhci, regs);
@@ -542,6 +515,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	struct dentry *dentry;
 
 	io_size = (unsigned) hcd-&gt;rsrc_len;
+	hcd-&gt;uses_new_polling = 1;
 	if (pci_find_capability(to_pci_dev(uhci_dev(uhci)), PCI_CAP_ID_PM))
 		hcd-&gt;can_wakeup = 1;		/* Assume it supports PME# */
 
@@ -714,8 +688,6 @@ static int uhci_start(struct usb_hcd *hcd)
 	configure_hc(uhci);
 	start_rh(uhci);
 
-	restart_timer(uhci);
-
 	udev-&gt;speed = USB_SPEED_FULL;
 
 	if (usb_hcd_register_root_hub(udev, hcd) != 0) {
@@ -730,8 +702,8 @@ static int uhci_start(struct usb_hcd *hcd)
  * error exits:
  */
 err_start_root_hub:
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
 	reset_hc(uhci);
+	del_timer_sync(&amp;uhci-&gt;stall_timer);
 
 err_alloc_skelqh:
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
@@ -771,13 +743,12 @@ static void uhci_stop(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
-	del_timer_sync(&amp;uhci-&gt;stall_timer);
-
 	spin_lock_irq(&amp;uhci-&gt;lock);
 	reset_hc(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	
+
+	del_timer_sync(&amp;uhci-&gt;stall_timer);
 	release_uhci(uhci);
 }
 
@@ -844,6 +815,8 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 
 done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
+	if (rc == 0)
+		del_timer_sync(&amp;hcd-&gt;rh_timer);
 	return rc;
 }
 
@@ -875,6 +848,9 @@ static int uhci_resume(struct usb_hcd *hcd)
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
+
+	if (hcd-&gt;poll_rh)
+		usb_hcd_poll_rh_status(hcd);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 827df5e06800..d7c67b73eb7a 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -327,18 +327,19 @@ static inline int __interval_to_skel(int interval)
  * driver learns to autosuspend.)
  */
 enum uhci_rh_state {
-	/* In the next 4 states the HC must be halted */
-	UHCI_RH_RESET,			/* These two must come first */
+	/* In the following states the HC must be halted.
+	 * These two must come first */
+	UHCI_RH_RESET,
 	UHCI_RH_SUSPENDED,
 
 	UHCI_RH_AUTO_STOPPED,
 	UHCI_RH_RESUMING,
 
-	/* In the next state the HC changes from running to halted, so it
-	 * can legally appear either way */
+	/* In this state the HC changes from running to halted,
+	 * so it can legally appear either way. */
 	UHCI_RH_SUSPENDING,
 
-	/* In the next two states it's an error if the HC is halted.
+	/* In the following states it's an error if the HC is halted.
 	 * These two must come last */
 	UHCI_RH_RUNNING,		/* The normal state */
 	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
@@ -380,7 +381,6 @@ struct uhci_hcd {
 
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
-	unsigned int resume_detect:1;		/* Need a Global Resume */
 	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
 
 	/* Support for port suspend/resume/reset */
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 13652de52203..4eace2b19ddb 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -49,22 +49,16 @@ static int any_ports_active(struct uhci_hcd *uhci)
 	return 0;
 }
 
-static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
+static inline int get_hub_status_data(struct uhci_hcd *uhci, char *buf)
 {
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int port;
 
-	if (uhci-&gt;hc_inaccessible)
-		return 0;
-
 	*buf = 0;
 	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
 		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; RWC_BITS) ||
 				test_bit(port, &amp;uhci-&gt;port_c_suspend))
 			*buf |= (1 &lt;&lt; (port + 1));
 	}
-	if (*buf &amp;&amp; uhci-&gt;is_stopped)
-		uhci-&gt;resume_detect = 1;
 	return !!*buf;
 }
 
@@ -134,6 +128,11 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
 						msecs_to_jiffies(20);
+
+				/* Make sure we see the port again
+				 * after the resuming period is over. */
+				mod_timer(&amp;uhci_to_hcd(uhci)-&gt;rh_timer,
+						uhci-&gt;ports_timeout);
 			} else if (time_after_eq(jiffies,
 						uhci-&gt;ports_timeout)) {
 				uhci_finish_suspend(uhci, port, port_addr);
@@ -142,6 +141,60 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 	}
 }
 
+static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned long flags;
+	int status;
+
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+	if (uhci-&gt;hc_inaccessible) {
+		status = 0;
+		goto done;
+	}
+
+	uhci_check_ports(uhci);
+	status = get_hub_status_data(uhci, buf);
+
+	switch (uhci-&gt;rh_state) {
+	    case UHCI_RH_SUSPENDING:
+	    case UHCI_RH_SUSPENDED:
+		/* if port change, ask to be resumed */
+		if (status)
+			usb_hcd_resume_root_hub(hcd);
+		break;
+
+	    case UHCI_RH_AUTO_STOPPED:
+		/* if port change, auto start */
+		if (status)
+			wakeup_rh(uhci);
+		break;
+
+	    case UHCI_RH_RUNNING:
+		/* are any devices attached? */
+		if (!any_ports_active(uhci)) {
+			uhci-&gt;rh_state = UHCI_RH_RUNNING_NODEVS;
+			uhci-&gt;auto_stop_time = jiffies + HZ;
+		}
+		break;
+
+	    case UHCI_RH_RUNNING_NODEVS:
+		/* auto-stop if nothing connected for 1 second */
+		if (any_ports_active(uhci))
+			uhci-&gt;rh_state = UHCI_RH_RUNNING;
+		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
+			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
+		break;
+
+	    default:
+		break;
+	}
+
+done:
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+	return status;
+}
+
 /* size of returned buffer is part of USB spec */
 static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			u16 wIndex, char *buf, u16 wLength)
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index f5c75885f7be..77f264851e98 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -32,6 +32,8 @@ static void uhci_free_pending_tds(struct uhci_hcd *uhci);
  */
 static inline void uhci_set_next_interrupt(struct uhci_hcd *uhci)
 {
+	if (uhci-&gt;is_stopped)
+		mod_timer(&amp;uhci-&gt;stall_timer, jiffies);
 	uhci-&gt;term_td-&gt;status |= cpu_to_le32(TD_CTRL_IOC); 
 }
 
@@ -1497,6 +1499,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
  rescan:
 	uhci-&gt;need_rescan = 0;
 
+	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
 
 	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;qh_remove_age)</pre><hr><pre>commit 4daaa87c8f19c5f1978470e9e91b74d9e0fb0f8e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:30:08 2005 -0400

    [PATCH] USB UHCI: Fix up loose ends
    
    This patch tidies up a few loose ends left by the preceding patches.
    It indicates the controller supports remote wakeup whenever the PM
    capability is present -- which shouldn't cause any harm if the
    assumption turns out to be wrong.  It refuses to suspend the
    controller if the root hub is still active, and it refuses to resume
    the root hub if the controller is suspended.  It adds checks for a
    dead controller in several spots, and it adds memory barriers as
    needed to insure that I/O operations are completed before moving on.
    
    Actually I'm not certain the last part is being done correctly.  With
    code like this:
    
            outw(..., ...);
            mb();
            udelay(5);
    
    do we know for certain that the outw() will complete _before_ the
    delay begins?  If not, how should this be written?
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 730ba3a621ae..82e608a4bbd0 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -13,18 +13,13 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
  *
  * Intel documents this fairly well, and as far as I know there
  * are no royalties or anything like that, but even so there are
  * people who decided that they want to do the same thing in a
  * completely different way.
  *
- * WARNING! The USB documentation is downright evil. Most of it
- * is just crap, written by a committee. You're better off ignoring
- * most of it, the important stuff is:
- *  - the low-level protocol (fairly simple but lots of small details)
- *  - working around the horridness of the rest
  */
 
 #include &lt;linux/config.h&gt;
@@ -146,6 +141,15 @@ static void reset_hc(struct uhci_hcd *uhci)
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 }
 
+/*
+ * Last rites for a defunct/nonfunctional controller
+ */
+static void hc_died(struct uhci_hcd *uhci)
+{
+	reset_hc(uhci);
+	uhci-&gt;hc_inaccessible = 1;
+}
+
 /*
  * Initialize a controller that was newly discovered or has just been
  * resumed.  In either case we can't be sure of its previous state.
@@ -287,6 +291,8 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(1);
 		spin_lock_irq(&amp;uhci-&gt;lock);
+		if (uhci-&gt;hc_inaccessible)	/* Died */
+			return;
 	}
 	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
 		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
@@ -335,6 +341,8 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(20);
 		spin_lock_irq(&amp;uhci-&gt;lock);
+		if (uhci-&gt;hc_inaccessible)	/* Died */
+			return;
 
 		/* End Global Resume and wait for EOP to be sent */
 		outw(USBCMD_CF, uhci-&gt;io_addr + USBCMD);
@@ -387,9 +395,11 @@ static void stall_callback(unsigned long _uhci)
 	check_fsbr(uhci);
 
 	/* Poll for and perform state transitions */
-	rh_state_transitions(uhci);
-	if (uhci-&gt;suspended_ports &amp;&amp; !uhci-&gt;hc_inaccessible)
-		uhci_check_ports(uhci);
+	if (!uhci-&gt;hc_inaccessible) {
+		rh_state_transitions(uhci);
+		if (uhci-&gt;suspended_ports)
+			uhci_check_ports(uhci);
+	}
 
 	restart_timer(uhci);
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
@@ -399,6 +409,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned short status;
+	unsigned long flags;
 
 	/*
 	 * Read the interrupt status, and write it back to clear the
@@ -417,20 +428,26 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 		if (status &amp; USBSTS_HCPE)
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
-		if ((status &amp; USBSTS_HCH) &amp;&amp;
-				uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
-			dev_err(uhci_dev(uhci), "host controller halted, "
+		if (status &amp; USBSTS_HCH) {
+			spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+			if (uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
+				dev_err(uhci_dev(uhci),
+					"host controller halted, "
 					"very bad!\n");
-			/* FIXME: Reset the controller, fix the offending TD */
+				hc_died(uhci);
+				spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+				return IRQ_HANDLED;
+			}
+			spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 		}
 	}
 
 	if (status &amp; USBSTS_RD)
 		uhci-&gt;resume_detect = 1;
 
-	spin_lock(&amp;uhci-&gt;lock);
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	uhci_scan_schedule(uhci, regs);
-	spin_unlock(&amp;uhci-&gt;lock);
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -525,10 +542,15 @@ static int uhci_start(struct usb_hcd *hcd)
 	struct dentry *dentry;
 
 	io_size = (unsigned) hcd-&gt;rsrc_len;
+	if (pci_find_capability(to_pci_dev(uhci_dev(uhci)), PCI_CAP_ID_PM))
+		hcd-&gt;can_wakeup = 1;		/* Assume it supports PME# */
 
-	dentry = debugfs_create_file(hcd-&gt;self.bus_name, S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root, uhci, &amp;uhci_debug_operations);
+	dentry = debugfs_create_file(hcd-&gt;self.bus_name,
+			S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root, uhci,
+			&amp;uhci_debug_operations);
 	if (!dentry) {
-		dev_err(uhci_dev(uhci), "couldn't create uhci debugfs entry\n");
+		dev_err(uhci_dev(uhci),
+				"couldn't create uhci debugfs entry\n");
 		retval = -ENOMEM;
 		goto err_create_debug_entry;
 	}
@@ -765,7 +787,8 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	suspend_rh(uhci, UHCI_RH_SUSPENDED);
+	if (!uhci-&gt;hc_inaccessible)		/* Not dead */
+		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
@@ -773,26 +796,44 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 static int uhci_rh_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	int rc = 0;
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	wakeup_rh(uhci);
+	if (uhci-&gt;hc_inaccessible) {
+		if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
+			dev_warn(uhci_dev(uhci), "HC isn't running!\n");
+			rc = -ENODEV;
+		}
+		/* Otherwise the HC is dead */
+	} else
+		wakeup_rh(uhci);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	return 0;
+	return rc;
 }
 
 static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	int rc = 0;
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
+	if (uhci-&gt;hc_inaccessible)	/* Dead or already suspended */
+		goto done;
 
 #ifndef CONFIG_USB_SUSPEND
 	/* Otherwise this would never happen */
 	suspend_rh(uhci, UHCI_RH_SUSPENDED);
 #endif
 
+	if (uhci-&gt;rh_state &gt; UHCI_RH_SUSPENDED) {
+		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
+		hcd-&gt;state = HC_STATE_RUNNING;
+		rc = -EBUSY;
+		goto done;
+	};
+
 	/* All PCI host controllers are required to disable IRQ generation
 	 * at the source, so we must turn off PIRQ.
 	 */
@@ -801,8 +842,9 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 
 	/* FIXME: Enable non-PME# remote wakeup? */
 
+done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
-	return 0;
+	return rc;
 }
 
 static int uhci_resume(struct usb_hcd *hcd)
@@ -811,6 +853,8 @@ static int uhci_resume(struct usb_hcd *hcd)
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
+	if (uhci-&gt;rh_state == UHCI_RH_RESET)	/* Dead */
+		return 0;
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
 	/* FIXME: Disable non-PME# remote wakeup? */</pre><hr><pre>commit a8bed8b6be75bc5a46aa599ab360d5f1db291c8f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:29:00 2005 -0400

    [PATCH] USB UHCI: Add root-hub suspend/resume support
    
    This patch implements (finally!) separate suspend and resume routines
    for the root hub and the controller in the UHCI driver.  It also
    changes the sequence used to reset the controller during initial
    probing, so as to preserve the existing state during a Resume-From-Disk.
    (This new sequence is what should be used in the PCI Quirks code for
    early USB handoffs, incidentally.)  Lastly it adds a notion of the
    controller being "inaccessible" while in a PCI low-power state, when
    normal I/O operations shouldn't be allowed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 57b36dcea5d0..730ba3a621ae 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -109,28 +109,113 @@ static inline void restart_timer(struct uhci_hcd *uhci)
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
+/*
+ * Make sure the controller is completely inactive, unable to
+ * generate interrupts or do DMA.
+ */
 static void reset_hc(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci-&gt;io_addr;
+	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
+	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
+	 */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
+			USBLEGSUP_RWC);
 
-	/* Turn off PIRQ, SMI, and all interrupts.  This also turns off
-	 * the BIOS's USB Legacy Support.
+	/* Reset the HC - this will force us to get a
+	 * new notification of any already connected
+	 * ports due to the virtual disconnect that it
+	 * implies.
 	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
-	outw(0, uhci-&gt;io_addr + USBINTR);
+	outw(USBCMD_HCRESET, uhci-&gt;io_addr + USBCMD);
+	mb();
+	udelay(5);
+	if (inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_HCRESET)
+		dev_warn(uhci_dev(uhci), "HCRESET not completed yet!\n");
 
-	/* Global reset for 50ms */
-	outw(USBCMD_GRESET, io_addr + USBCMD);
-	msleep(50);
-	outw(0, io_addr + USBCMD);
+	/* Just to be safe, disable interrupt requests and
+	 * make sure the controller is stopped.
+	 */
+	outw(0, uhci-&gt;io_addr + USBINTR);
+	outw(0, uhci-&gt;io_addr + USBCMD);
 
-	/* Another 10ms delay */
-	msleep(10);
 	uhci-&gt;resume_detect = 0;
-	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci-&gt;port_c_suspend = uhci-&gt;suspended_ports =
+			uhci-&gt;resuming_ports = 0;
 	uhci-&gt;rh_state = UHCI_RH_RESET;
+	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 }
 
+/*
+ * Initialize a controller that was newly discovered or has just been
+ * resumed.  In either case we can't be sure of its previous state.
+ */
+static void check_and_reset_hc(struct uhci_hcd *uhci)
+{
+	u16 legsup;
+	unsigned int cmd, intr;
+
+	/*
+	 * When restarting a suspended controller, we expect all the
+	 * settings to be the same as we left them:
+	 *
+	 *	PIRQ and SMI disabled, no R/WC bits set in USBLEGSUP;
+	 *	Controller is stopped and configured with EGSM set;
+	 *	No interrupts enabled except possibly Resume Detect.
+	 *
+	 * If any of these conditions are violated we do a complete reset.
+	 */
+	pci_read_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, &amp;legsup);
+	if (legsup &amp; ~USBLEGSUP_RO) {
+		dev_dbg(uhci_dev(uhci), "%s: legsup = 0x%04x\n",
+				__FUNCTION__, legsup);
+		goto reset_needed;
+	}
+
+	cmd = inw(uhci-&gt;io_addr + USBCMD);
+	if ((cmd &amp; USBCMD_RS) || !(cmd &amp; USBCMD_CF) || !(cmd &amp; USBCMD_EGSM)) {
+		dev_dbg(uhci_dev(uhci), "%s: cmd = 0x%04x\n",
+				__FUNCTION__, cmd);
+		goto reset_needed;
+	}
+
+	intr = inw(uhci-&gt;io_addr + USBINTR);
+	if (intr &amp; (~USBINTR_RESUME)) {
+		dev_dbg(uhci_dev(uhci), "%s: intr = 0x%04x\n",
+				__FUNCTION__, intr);
+		goto reset_needed;
+	}
+	return;
+
+reset_needed:
+	dev_dbg(uhci_dev(uhci), "Performing full reset\n");
+	reset_hc(uhci);
+}
+
+/*
+ * Store the basic register settings needed by the controller.
+ */
+static void configure_hc(struct uhci_hcd *uhci)
+{
+	/* Set the frame length to the default: 1 ms exactly */
+	outb(USBSOF_DEFAULT, uhci-&gt;io_addr + USBSOF);
+
+	/* Store the frame list base address */
+	outl(uhci-&gt;fl-&gt;dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
+
+	/* Set the current frame number */
+	outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
+
+	/* Mark controller as running before we enable interrupts */
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
+	mb();
+
+	/* Enable PIRQ */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
+			USBLEGSUP_DEFAULT);
+}
+
+
 static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 {
 	int port;
@@ -163,7 +248,7 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 	return 0;
 }
 
-static void suspend_hc(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
+static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
 __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
@@ -189,6 +274,7 @@ __acquires(uhci-&gt;lock)
 			0 : USBINTR_RESUME);
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
 	outw(USBCMD_EGSM | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+	mb();
 	udelay(5);
 
 	/* If we're auto-stopping then no devices have been attached
@@ -215,7 +301,22 @@ __acquires(uhci-&gt;lock)
 	uhci_scan_schedule(uhci, NULL);
 }
 
-static void wakeup_hc(struct uhci_hcd *uhci)
+static void start_rh(struct uhci_hcd *uhci)
+{
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
+	uhci-&gt;is_stopped = 0;
+	smp_wmb();
+
+	/* Mark it configured and running with a 64-byte max packet.
+	 * All interrupts are enabled, even though RESUME won't do anything.
+	 */
+	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci-&gt;io_addr + USBCMD);
+	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
+			uhci-&gt;io_addr + USBINTR);
+	mb();
+}
+
+static void wakeup_rh(struct uhci_hcd *uhci)
 __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
@@ -237,62 +338,13 @@ __acquires(uhci-&gt;lock)
 
 		/* End Global Resume and wait for EOP to be sent */
 		outw(USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+		mb();
 		udelay(4);
 		if (inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_FGR)
 			dev_warn(uhci_dev(uhci), "FGR not stopped yet!\n");
 	}
 
-	uhci-&gt;rh_state = UHCI_RH_RUNNING;
-	uhci-&gt;is_stopped = 0;
-	smp_wmb();
-
-	/* Mark it configured and running with a 64-byte max packet.
-	 * All interrupts are enabled, even though RD won't do anything.
-	 */
-	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci-&gt;io_addr + USBCMD);
-	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
-			uhci-&gt;io_addr + USBINTR);
-}
-
-static int start_hc(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int timeout = 10;
-
-	/*
-	 * Reset the HC - this will force us to get a
-	 * new notification of any already connected
-	 * ports due to the virtual disconnect that it
-	 * implies.
-	 */
-	outw(USBCMD_HCRESET, io_addr + USBCMD);
-	while (inw(io_addr + USBCMD) &amp; USBCMD_HCRESET) {
-		if (--timeout &lt; 0) {
-			dev_err(uhci_dev(uhci), "USBCMD_HCRESET timed out!\n");
-			return -ETIMEDOUT;
-		}
-		msleep(1);
-	}
-
-	/* Mark controller as running before we enable interrupts */
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
-
-	/* Turn on PIRQ and all interrupts */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
-	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
-		io_addr + USBINTR);
-
-	/* Start at frame 0 */
-	outw(0, io_addr + USBFRNUM);
-	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
-
-	/* Run and mark it configured with a 64-byte max packet */
-	uhci-&gt;rh_state = UHCI_RH_RUNNING;
-	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
-	uhci-&gt;is_stopped = 0;
-
-	return 0;
+	start_rh(uhci);
 }
 
 static void rh_state_transitions(struct uhci_hcd *uhci)
@@ -311,13 +363,13 @@ static void rh_state_transitions(struct uhci_hcd *uhci)
 		if (any_ports_active(uhci))
 			uhci-&gt;rh_state = UHCI_RH_RUNNING;
 		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
-			suspend_hc(uhci, UHCI_RH_AUTO_STOPPED);
+			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
 		break;
 
 	    case UHCI_RH_AUTO_STOPPED:
 		/* wakeup if requested by a device */
 		if (uhci-&gt;resume_detect)
-			wakeup_hc(uhci);
+			wakeup_rh(uhci);
 		break;
 
 	    default:
@@ -336,7 +388,7 @@ static void stall_callback(unsigned long _uhci)
 
 	/* Poll for and perform state transitions */
 	rh_state_transitions(uhci);
-	if (unlikely(uhci-&gt;suspended_ports))
+	if (uhci-&gt;suspended_ports &amp;&amp; !uhci-&gt;hc_inaccessible)
 		uhci_check_ports(uhci);
 
 	restart_timer(uhci);
@@ -346,7 +398,6 @@ static void stall_callback(unsigned long _uhci)
 static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long io_addr = uhci-&gt;io_addr;
 	unsigned short status;
 
 	/*
@@ -354,10 +405,10 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 	 * interrupt cause.  Contrary to the UHCI specification, the
 	 * "HC Halted" status bit is persistent: it is RO, not R/WC.
 	 */
-	status = inw(io_addr + USBSTS);
+	status = inw(uhci-&gt;io_addr + USBSTS);
 	if (!(status &amp; ~USBSTS_HCH))	/* shared interrupt, not mine */
 		return IRQ_NONE;
-	outw(status, io_addr + USBSTS);		/* Clear it */
+	outw(status, uhci-&gt;io_addr + USBSTS);		/* Clear it */
 
 	if (status &amp; ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
 		if (status &amp; USBSTS_HSE)
@@ -440,10 +491,10 @@ static int uhci_reset(struct usb_hcd *hcd)
 
 	uhci-&gt;io_addr = (unsigned long) hcd-&gt;rsrc_start;
 
-	/* Kick BIOS off this hardware and reset, so we won't get
-	 * interrupts from any previous setup.
+	/* Kick BIOS off this hardware and reset if the controller
+	 * isn't already safely quiescent.
 	 */
-	reset_hc(uhci);
+	check_and_reset_hc(uhci);
 	return 0;
 }
 
@@ -634,11 +685,12 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	/*
 	 * Some architectures require a full mb() to enforce completion of
-	 * the memory writes above before the I/O transfers in start_hc().
+	 * the memory writes above before the I/O transfers in configure_hc().
 	 */
 	mb();
-	if ((retval = start_hc(uhci)) != 0)
-		goto err_alloc_skelqh;
+
+	configure_hc(uhci);
+	start_rh(uhci);
 
 	restart_timer(uhci);
 
@@ -656,9 +708,8 @@ static int uhci_start(struct usb_hcd *hcd)
  * error exits:
  */
 err_start_root_hub:
-	reset_hc(uhci);
-
 	del_timer_sync(&amp;uhci-&gt;stall_timer);
+	reset_hc(uhci);
 
 err_alloc_skelqh:
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; i++)
@@ -699,9 +750,9 @@ static void uhci_stop(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	del_timer_sync(&amp;uhci-&gt;stall_timer);
-	reset_hc(uhci);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
+	reset_hc(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	
@@ -709,12 +760,47 @@ static void uhci_stop(struct usb_hcd *hcd)
 }
 
 #ifdef CONFIG_PM
+static int uhci_rh_suspend(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	spin_lock_irq(&amp;uhci-&gt;lock);
+	suspend_rh(uhci, UHCI_RH_SUSPENDED);
+	spin_unlock_irq(&amp;uhci-&gt;lock);
+	return 0;
+}
+
+static int uhci_rh_resume(struct usb_hcd *hcd)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	spin_lock_irq(&amp;uhci-&gt;lock);
+	wakeup_rh(uhci);
+	spin_unlock_irq(&amp;uhci-&gt;lock);
+	return 0;
+}
+
 static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
+	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
+
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	suspend_hc(uhci, UHCI_RH_SUSPENDED);
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	suspend_rh(uhci, UHCI_RH_SUSPENDED);
+#endif
+
+	/* All PCI host controllers are required to disable IRQ generation
+	 * at the source, so we must turn off PIRQ.
+	 */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
+	uhci-&gt;hc_inaccessible = 1;
+
+	/* FIXME: Enable non-PME# remote wakeup? */
+
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
@@ -723,28 +809,28 @@ static int uhci_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
+	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
+
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
 
-		/*
-		 * Some systems don't maintain the UHCI register values
-		 * during a PM suspend/resume cycle, so reinitialize
-		 * the Frame Number, Framelist Base Address, Interrupt
-		 * Enable, and Legacy Support registers.
-		 */
-		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-				0);
-		outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
-		outl(uhci-&gt;fl-&gt;dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
-		outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC |
-				USBINTR_SP, uhci-&gt;io_addr + USBINTR);
-		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-				USBLEGSUP_DEFAULT);
-		wakeup_hc(uhci);
-	}
-	spin_unlock_irq(&amp;uhci-&gt;lock);
+	/* FIXME: Disable non-PME# remote wakeup? */
+
+	uhci-&gt;hc_inaccessible = 0;
+
+	/* The BIOS may have changed the controller settings during a
+	 * system wakeup.  Check it and reconfigure to avoid problems.
+	 */
+	check_and_reset_hc(uhci);
+	configure_hc(uhci);
+
+#ifndef CONFIG_USB_SUSPEND
+	/* Otherwise this would never happen */
+	wakeup_rh(uhci);
+#endif
+	if (uhci-&gt;rh_state == UHCI_RH_RESET)
+		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 
-	hcd-&gt;state = HC_STATE_RUNNING;
+	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
 #endif
@@ -792,6 +878,8 @@ static const struct hc_driver uhci_driver = {
 #ifdef CONFIG_PM
 	.suspend =		uhci_suspend,
 	.resume =		uhci_resume,
+	.hub_suspend =		uhci_rh_suspend,
+	.hub_resume =		uhci_rh_resume,
 #endif
 	.stop =			uhci_stop,
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 4bac57c74ec2..827df5e06800 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -41,6 +41,7 @@
 #define USBFRNUM	6
 #define USBFLBASEADD	8
 #define USBSOF		12
+#define   USBSOF_DEFAULT	64	/* Frame length is exactly 1 ms */
 
 /* USB port status and control registers */
 #define USBPORTSC1	16
@@ -66,6 +67,8 @@
 /* Legacy support register */
 #define USBLEGSUP		0xc0
 #define   USBLEGSUP_DEFAULT	0x2000	/* only PIRQ enable set */
+#define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
+#define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
 #define UHCI_NULL_DATA_SIZE	0x7FF	/* for UHCI controller TD */
 
@@ -325,8 +328,9 @@ static inline int __interval_to_skel(int interval)
  */
 enum uhci_rh_state {
 	/* In the next 4 states the HC must be halted */
-	UHCI_RH_RESET,
+	UHCI_RH_RESET,			/* These two must come first */
 	UHCI_RH_SUSPENDED,
+
 	UHCI_RH_AUTO_STOPPED,
 	UHCI_RH_RESUMING,
 
@@ -334,7 +338,8 @@ enum uhci_rh_state {
 	 * can legally appear either way */
 	UHCI_RH_SUSPENDING,
 
-	/* In the next two states it's an error if the HC is halted */
+	/* In the next two states it's an error if the HC is halted.
+	 * These two must come last */
 	UHCI_RH_RUNNING,		/* The normal state */
 	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
 };
@@ -376,6 +381,7 @@ struct uhci_hcd {
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
 	unsigned int resume_detect:1;		/* Need a Global Resume */
+	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index fc34fee2ab07..13652de52203 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -54,6 +54,9 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int port;
 
+	if (uhci-&gt;hc_inaccessible)
+		return 0;
+
 	*buf = 0;
 	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
 		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; RWC_BITS) ||
@@ -150,6 +153,9 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	u16 wPortChange, wPortStatus;
 	unsigned long flags;
 
+	if (uhci-&gt;hc_inaccessible)
+		return -ETIMEDOUT;
+
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	switch (typeReq) {
 </pre><hr><pre>commit c8f4fe4358c5e0a79b4bd47b814d19f1d1d06f21
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:27:32 2005 -0400

    [PATCH] USB UHCI: Add root hub states
    
    This patch starts making some serious changes to the UHCI driver.
    There's a set of private states for the root hub, and the internal
    routines for suspending and resuming work completely differently, with
    transitions based on the new states.  Now the driver distinguishes
    between a privately auto-stopped state and a publicly suspended state,
    and it will properly suspend controllers with broken resume-detect
    interrupts instead of resetting them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 24c73c5a3435..4538a98b6f9d 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -237,6 +237,37 @@ static int uhci_show_sc(int port, unsigned short status, char *buf, int len)
 	return out - buf;
 }
 
+static int uhci_show_root_hub_state(struct uhci_hcd *uhci, char *buf, int len)
+{
+	char *out = buf;
+	char *rh_state;
+
+	/* Try to make sure there's enough memory */
+	if (len &lt; 60)
+		return 0;
+
+	switch (uhci-&gt;rh_state) {
+	    case UHCI_RH_RESET:
+		rh_state = "reset";		break;
+	    case UHCI_RH_SUSPENDED:
+		rh_state = "suspended";		break;
+	    case UHCI_RH_AUTO_STOPPED:
+		rh_state = "auto-stopped";	break;
+	    case UHCI_RH_RESUMING:
+		rh_state = "resuming";		break;
+	    case UHCI_RH_SUSPENDING:
+		rh_state = "suspending";	break;
+	    case UHCI_RH_RUNNING:
+		rh_state = "running";		break;
+	    case UHCI_RH_RUNNING_NODEVS:
+		rh_state = "running, no devs";	break;
+	    default:
+		rh_state = "?";			break;
+	}
+	out += sprintf(out, "Root-hub state: %s\n", rh_state);
+	return out - buf;
+}
+
 static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 {
 	char *out = buf;
@@ -408,6 +439,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
+	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
 	out += uhci_show_status(uhci, out, len - (out - buf));
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index c17bd7ebc021..57b36dcea5d0 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -64,7 +64,7 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v2.2"
+#define DRIVER_VERSION "v2.3"
 #define DRIVER_AUTHOR "Linus 'Frodo Rabbit' Torvalds, Johannes Erdfelt, \
 Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
 Alan Stern"
@@ -109,33 +109,6 @@ static inline void restart_timer(struct uhci_hcd *uhci)
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
-static int suspend_allowed(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int i;
-
-	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor != PCI_VENDOR_ID_INTEL)
-		return 1;
-
-	/* Some of Intel's USB controllers have a bug that causes false
-	 * resume indications if any port has an over current condition.
-	 * To prevent problems, we will not allow a global suspend if
-	 * any ports are OC.
-	 *
-	 * Some motherboards using Intel's chipsets (but not using all
-	 * the USB ports) appear to hardwire the over current inputs active
-	 * to disable the USB ports.
-	 */
-
-	/* check for over current condition on any port */
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++) {
-		if (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_OC)
-			return 0;
-	}
-
-	return 1;
-}
-
 static void reset_hc(struct uhci_hcd *uhci)
 {
 	unsigned long io_addr = uhci-&gt;io_addr;
@@ -147,7 +120,6 @@ static void reset_hc(struct uhci_hcd *uhci)
 	outw(0, uhci-&gt;io_addr + USBINTR);
 
 	/* Global reset for 50ms */
-	uhci-&gt;state = UHCI_RESET;
 	outw(USBCMD_GRESET, io_addr + USBCMD);
 	msleep(50);
 	outw(0, io_addr + USBCMD);
@@ -156,63 +128,130 @@ static void reset_hc(struct uhci_hcd *uhci)
 	msleep(10);
 	uhci-&gt;resume_detect = 0;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci-&gt;rh_state = UHCI_RH_RESET;
 }
 
-static void suspend_hc(struct uhci_hcd *uhci)
+static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 {
-	unsigned long io_addr = uhci-&gt;io_addr;
+	int port;
 
-	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
-	uhci-&gt;state = UHCI_SUSPENDED;
-	uhci-&gt;resume_detect = 0;
-	outw(USBCMD_EGSM, io_addr + USBCMD);
+	switch (to_pci_dev(uhci_dev(uhci))-&gt;vendor) {
+	    default:
+		break;
+
+	    case PCI_VENDOR_ID_GENESYS:
+		/* Genesys Logic's GL880S controllers don't generate
+		 * resume-detect interrupts.
+		 */
+		return 1;
+
+	    case PCI_VENDOR_ID_INTEL:
+		/* Some of Intel's USB controllers have a bug that causes
+		 * resume-detect interrupts if any port has an over-current
+		 * condition.  To make matters worse, some motherboards
+		 * hardwire unused USB ports' over-current inputs active!
+		 * To prevent problems, we will not enable resume-detect
+		 * interrupts if any ports are OC.
+		 */
+		for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
+			if (inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp;
+					USBPORTSC_OC)
+				return 1;
+		}
+		break;
+	}
+	return 0;
+}
+
+static void suspend_hc(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
+__releases(uhci-&gt;lock)
+__acquires(uhci-&gt;lock)
+{
+	int auto_stop;
+	int int_enable;
+
+	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
+	dev_dbg(uhci_dev(uhci), "%s%s\n", __FUNCTION__,
+			(auto_stop ? " (auto-stop)" : ""));
+
+	/* If we get a suspend request when we're already auto-stopped
+	 * then there's nothing to do.
+	 */
+	if (uhci-&gt;rh_state == UHCI_RH_AUTO_STOPPED) {
+		uhci-&gt;rh_state = new_state;
+		return;
+	}
+
+	/* Enable resume-detect interrupts if they work.
+	 * Then enter Global Suspend mode, still configured.
+	 */
+	int_enable = (resume_detect_interrupts_are_broken(uhci) ?
+			0 : USBINTR_RESUME);
+	outw(int_enable, uhci-&gt;io_addr + USBINTR);
+	outw(USBCMD_EGSM | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+	udelay(5);
+
+	/* If we're auto-stopping then no devices have been attached
+	 * for a while, so there shouldn't be any active URBs and the
+	 * controller should stop after a few microseconds.  Otherwise
+	 * we will give the controller one frame to stop.
+	 */
+	if (!auto_stop &amp;&amp; !(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH)) {
+		uhci-&gt;rh_state = UHCI_RH_SUSPENDING;
+		spin_unlock_irq(&amp;uhci-&gt;lock);
+		msleep(1);
+		spin_lock_irq(&amp;uhci-&gt;lock);
+	}
+	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
+		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
 
-	/* FIXME: Wait for the controller to actually stop */
 	uhci_get_current_frame_number(uhci);
+	smp_wmb();
+
+	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
+	uhci-&gt;resume_detect = 0;
 
 	uhci_scan_schedule(uhci, NULL);
 }
 
 static void wakeup_hc(struct uhci_hcd *uhci)
+__releases(uhci-&gt;lock)
+__acquires(uhci-&gt;lock)
 {
-	unsigned long io_addr = uhci-&gt;io_addr;
+	dev_dbg(uhci_dev(uhci), "%s%s\n", __FUNCTION__,
+			uhci-&gt;rh_state == UHCI_RH_AUTO_STOPPED ?
+				" (auto-start)" : "");
 
-	switch (uhci-&gt;state) {
-		case UHCI_SUSPENDED:		/* Start the resume */
-			dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
-
-			/* Global resume for &gt;= 20ms */
-			outw(USBCMD_FGR | USBCMD_EGSM, io_addr + USBCMD);
-			uhci-&gt;state = UHCI_RESUMING_1;
-			uhci-&gt;state_end = jiffies + msecs_to_jiffies(20);
-			uhci-&gt;is_stopped = 0;
-			break;
+	/* If we are auto-stopped then no devices are attached so there's
+	 * no need for wakeup signals.  Otherwise we send Global Resume
+	 * for 20 ms.
+	 */
+	if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
+		uhci-&gt;rh_state = UHCI_RH_RESUMING;
+		outw(USBCMD_FGR | USBCMD_EGSM | USBCMD_CF,
+				uhci-&gt;io_addr + USBCMD);
+		spin_unlock_irq(&amp;uhci-&gt;lock);
+		msleep(20);
+		spin_lock_irq(&amp;uhci-&gt;lock);
 
-		case UHCI_RESUMING_1:		/* End global resume */
-			uhci-&gt;state = UHCI_RESUMING_2;
-			outw(0, io_addr + USBCMD);
-			/* Falls through */
-
-		case UHCI_RESUMING_2:		/* Wait for EOP to be sent */
-			if (inw(io_addr + USBCMD) &amp; USBCMD_FGR)
-				break;
-
-			/* Run for at least 1 second, and
-			 * mark it configured with a 64-byte max packet */
-			uhci-&gt;state = UHCI_RUNNING_GRACE;
-			uhci-&gt;state_end = jiffies + HZ;
-			outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP,
-					io_addr + USBCMD);
-			break;
+		/* End Global Resume and wait for EOP to be sent */
+		outw(USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+		udelay(4);
+		if (inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_FGR)
+			dev_warn(uhci_dev(uhci), "FGR not stopped yet!\n");
+	}
 
-		case UHCI_RUNNING_GRACE:	/* Now allowed to suspend */
-			uhci-&gt;state = UHCI_RUNNING;
-			break;
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
+	uhci-&gt;is_stopped = 0;
+	smp_wmb();
 
-		default:
-			break;
-	}
+	/* Mark it configured and running with a 64-byte max packet.
+	 * All interrupts are enabled, even though RD won't do anything.
+	 */
+	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, uhci-&gt;io_addr + USBCMD);
+	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
+			uhci-&gt;io_addr + USBINTR);
 }
 
 static int start_hc(struct uhci_hcd *uhci)
@@ -249,49 +288,40 @@ static int start_hc(struct uhci_hcd *uhci)
 	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
 
 	/* Run and mark it configured with a 64-byte max packet */
-	uhci-&gt;state = UHCI_RUNNING_GRACE;
-	uhci-&gt;state_end = jiffies + HZ;
+	uhci-&gt;rh_state = UHCI_RH_RUNNING;
 	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
 	uhci-&gt;is_stopped = 0;
 
 	return 0;
 }
 
-static void hc_state_transitions(struct uhci_hcd *uhci)
+static void rh_state_transitions(struct uhci_hcd *uhci)
 {
-	switch (uhci-&gt;state) {
-		case UHCI_RUNNING:
-
-			/* global suspend if nothing connected for 1 second */
-			if (!any_ports_active(uhci) &amp;&amp; suspend_allowed(uhci)) {
-				uhci-&gt;state = UHCI_SUSPENDING_GRACE;
-				uhci-&gt;state_end = jiffies + HZ;
-			}
-			break;
-
-		case UHCI_SUSPENDING_GRACE:
-			if (any_ports_active(uhci))
-				uhci-&gt;state = UHCI_RUNNING;
-			else if (time_after_eq(jiffies, uhci-&gt;state_end))
-				suspend_hc(uhci);
-			break;
-
-		case UHCI_SUSPENDED:
-
-			/* wakeup if requested by a device */
-			if (uhci-&gt;resume_detect)
-				wakeup_hc(uhci);
-			break;
-
-		case UHCI_RESUMING_1:
-		case UHCI_RESUMING_2:
-		case UHCI_RUNNING_GRACE:
-			if (time_after_eq(jiffies, uhci-&gt;state_end))
-				wakeup_hc(uhci);
-			break;
-
-		default:
-			break;
+	switch (uhci-&gt;rh_state) {
+	    case UHCI_RH_RUNNING:
+		/* are any devices attached? */
+		if (!any_ports_active(uhci)) {
+			uhci-&gt;rh_state = UHCI_RH_RUNNING_NODEVS;
+			uhci-&gt;auto_stop_time = jiffies + HZ;
+		}
+		break;
+
+	    case UHCI_RH_RUNNING_NODEVS:
+		/* auto-stop if nothing connected for 1 second */
+		if (any_ports_active(uhci))
+			uhci-&gt;rh_state = UHCI_RH_RUNNING;
+		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
+			suspend_hc(uhci, UHCI_RH_AUTO_STOPPED);
+		break;
+
+	    case UHCI_RH_AUTO_STOPPED:
+		/* wakeup if requested by a device */
+		if (uhci-&gt;resume_detect)
+			wakeup_hc(uhci);
+		break;
+
+	    default:
+		break;
 	}
 }
 
@@ -305,8 +335,8 @@ static void stall_callback(unsigned long _uhci)
 	check_fsbr(uhci);
 
 	/* Poll for and perform state transitions */
-	hc_state_transitions(uhci);
-	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
+	rh_state_transitions(uhci);
+	if (unlikely(uhci-&gt;suspended_ports))
 		uhci_check_ports(uhci);
 
 	restart_timer(uhci);
@@ -336,7 +366,8 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 		if (status &amp; USBSTS_HCPE)
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
-		if ((status &amp; USBSTS_HCH) &amp;&amp; uhci-&gt;state &gt; 0) {
+		if ((status &amp; USBSTS_HCH) &amp;&amp;
+				uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
 			dev_err(uhci_dev(uhci), "host controller halted, "
 					"very bad!\n");
 			/* FIXME: Reset the controller, fix the offending TD */
@@ -683,17 +714,7 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-
-	/* Don't try to suspend broken motherboards, reset instead */
-	if (suspend_allowed(uhci))
-		suspend_hc(uhci);
-	else {
-		spin_unlock_irq(&amp;uhci-&gt;lock);
-		reset_hc(uhci);
-		spin_lock_irq(&amp;uhci-&gt;lock);
-		uhci_scan_schedule(uhci, NULL);
-	}
-
+	suspend_hc(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return 0;
 }
@@ -701,13 +722,9 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 static int uhci_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int rc;
-
-	pci_set_master(to_pci_dev(uhci_dev(uhci)));
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-
-	if (uhci-&gt;state == UHCI_SUSPENDED) {
+	if (uhci-&gt;rh_state == UHCI_RH_SUSPENDED) {
 
 		/*
 		 * Some systems don't maintain the UHCI register values
@@ -721,19 +738,13 @@ static int uhci_resume(struct usb_hcd *hcd)
 		outl(uhci-&gt;fl-&gt;dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
 		outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC |
 				USBINTR_SP, uhci-&gt;io_addr + USBINTR);
-		uhci-&gt;resume_detect = 1;
 		pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
 				USBLEGSUP_DEFAULT);
-	} else {
-		spin_unlock_irq(&amp;uhci-&gt;lock);
-		reset_hc(uhci);
-		if ((rc = start_hc(uhci)) != 0)
-			return rc;
-		spin_lock_irq(&amp;uhci-&gt;lock);
+		wakeup_hc(uhci);
 	}
-	hcd-&gt;state = HC_STATE_RUNNING;
-
 	spin_unlock_irq(&amp;uhci-&gt;lock);
+
+	hcd-&gt;state = HC_STATE_RUNNING;
 	return 0;
 }
 #endif
@@ -750,13 +761,15 @@ static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,
 static int uhci_hcd_get_frame_number(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	int frame_number;
 	unsigned long flags;
+	int is_stopped;
+	int frame_number;
 
 	/* Minimize latency by avoiding the spinlock */
 	local_irq_save(flags);
-	rmb();
-	frame_number = (uhci-&gt;is_stopped ? uhci-&gt;frame_number :
+	is_stopped = uhci-&gt;is_stopped;
+	smp_rmb();
+	frame_number = (is_stopped ? uhci-&gt;frame_number :
 			inw(uhci-&gt;io_addr + USBFRNUM));
 	local_irq_restore(flags);
 	return frame_number;
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 02255d69e1fe..4bac57c74ec2 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -314,26 +314,29 @@ static inline int __interval_to_skel(int interval)
 }
 
 /*
- * Device states for the host controller.
+ * States for the root hub.
  *
  * To prevent "bouncing" in the presence of electrical noise,
- * we insist on a 1-second "grace" period, before switching to
- * the RUNNING or SUSPENDED states, during which the state is
- * not allowed to change.
- *
- * The resume process is divided into substates in order to avoid
- * potentially length delays during the timer handler.
- *
- * States in which the host controller is halted must have values &lt;= 0.
+ * when there are no devices attached we delay for 1 second in the
+ * RUNNING_NODEVS state before switching to the AUTO_STOPPED state.
+ * 
+ * (Note that the AUTO_STOPPED state won't be necessary once the hub
+ * driver learns to autosuspend.)
  */
-enum uhci_state {
-	UHCI_RESET,
-	UHCI_RUNNING_GRACE,		/* Before RUNNING */
-	UHCI_RUNNING,			/* The normal state */
-	UHCI_SUSPENDING_GRACE,		/* Before SUSPENDED */
-	UHCI_SUSPENDED = -10,		/* When no devices are attached */
-	UHCI_RESUMING_1,
-	UHCI_RESUMING_2
+enum uhci_rh_state {
+	/* In the next 4 states the HC must be halted */
+	UHCI_RH_RESET,
+	UHCI_RH_SUSPENDED,
+	UHCI_RH_AUTO_STOPPED,
+	UHCI_RH_RESUMING,
+
+	/* In the next state the HC changes from running to halted, so it
+	 * can legally appear either way */
+	UHCI_RH_SUSPENDING,
+
+	/* In the next two states it's an error if the HC is halted */
+	UHCI_RH_RUNNING,		/* The normal state */
+	UHCI_RH_RUNNING_NODEVS,		/* Running with no devices attached */
 };
 
 /*
@@ -363,8 +366,9 @@ struct uhci_hcd {
 	int fsbr;				/* Full-speed bandwidth reclamation */
 	unsigned long fsbrtimeout;		/* FSBR delay */
 
-	enum uhci_state state;			/* FIXME: needs a spinlock */
-	unsigned long state_end;		/* Time of next transition */
+	enum uhci_rh_state rh_state;
+	unsigned long auto_stop_time;		/* When to AUTO_STOP */
+
 	unsigned int frame_number;		/* As of last check */
 	unsigned int is_stopped;
 #define UHCI_IS_STOPPED		9999		/* Larger than a frame # */
@@ -451,4 +455,11 @@ struct urb_priv {
  * #2 urb-&gt;lock
  */
 
+
+/* Some special IDs */
+
+#define PCI_VENDOR_ID_GENESYS		0x17a0
+#define PCI_DEVICE_ID_GL880S_UHCI	0x8083
+#define PCI_DEVICE_ID_GL880S_EHCI	0x8084
+
 #endif
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index ddb19cbf4b75..fc34fee2ab07 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -60,7 +60,7 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 				test_bit(port, &amp;uhci-&gt;port_c_suspend))
 			*buf |= (1 &lt;&lt; (port + 1));
 	}
-	if (*buf &amp;&amp; uhci-&gt;state == UHCI_SUSPENDED)
+	if (*buf &amp;&amp; uhci-&gt;is_stopped)
 		uhci-&gt;resume_detect = 1;
 	return !!*buf;
 }</pre><hr><pre>commit f5946f8220a866dcdb8edc6abe23c1443e252425
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:26:00 2005 -0400

    [PATCH] USB UHCI: Minor improvements
    
    This patch makes a few small improvements in the UHCI driver.  Some
    code is moved between different source files and a more useful pointer
    is passed to a callback routine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 8b6c87ef486b..c17bd7ebc021 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -100,22 +100,15 @@ static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 /* to make sure it doesn't hog all of the bandwidth */
 #define DEPTH_INTERVAL 5
 
+static inline void restart_timer(struct uhci_hcd *uhci)
+{
+	mod_timer(&amp;uhci-&gt;stall_timer, jiffies + msecs_to_jiffies(100));
+}
+
 #include "uhci-hub.c"
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
-static int ports_active(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int connection = 0;
-	int i;
-
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++)
-		connection |= (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_CCS);
-
-	return connection;
-}
-
 static int suspend_allowed(struct uhci_hcd *uhci)
 {
 	unsigned long io_addr = uhci-&gt;io_addr;
@@ -270,14 +263,14 @@ static void hc_state_transitions(struct uhci_hcd *uhci)
 		case UHCI_RUNNING:
 
 			/* global suspend if nothing connected for 1 second */
-			if (!ports_active(uhci) &amp;&amp; suspend_allowed(uhci)) {
+			if (!any_ports_active(uhci) &amp;&amp; suspend_allowed(uhci)) {
 				uhci-&gt;state = UHCI_SUSPENDING_GRACE;
 				uhci-&gt;state_end = jiffies + HZ;
 			}
 			break;
 
 		case UHCI_SUSPENDING_GRACE:
-			if (ports_active(uhci))
+			if (any_ports_active(uhci))
 				uhci-&gt;state = UHCI_RUNNING;
 			else if (time_after_eq(jiffies, uhci-&gt;state_end))
 				suspend_hc(uhci);
@@ -302,58 +295,24 @@ static void hc_state_transitions(struct uhci_hcd *uhci)
 	}
 }
 
-static int init_stall_timer(struct usb_hcd *hcd);
-
-static void stall_callback(unsigned long ptr)
+static void stall_callback(unsigned long _uhci)
 {
-	struct usb_hcd *hcd = (struct usb_hcd *)ptr;
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	struct urb_priv *up;
+	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	uhci_scan_schedule(uhci, NULL);
-
-	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *u = up-&gt;urb;
-
-		spin_lock(&amp;u-&gt;lock);
-
-		/* Check if the FSBR timed out */
-		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
-			uhci_fsbr_timeout(uhci, u);
-
-		spin_unlock(&amp;u-&gt;lock);
-	}
-
-	/* Really disable FSBR */
-	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
-		uhci-&gt;fsbrtimeout = 0;
-		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	}
+	check_fsbr(uhci);
 
 	/* Poll for and perform state transitions */
 	hc_state_transitions(uhci);
 	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
 		uhci_check_ports(uhci);
 
-	init_stall_timer(hcd);
+	restart_timer(uhci);
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
-static int init_stall_timer(struct usb_hcd *hcd)
-{
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-
-	init_timer(&amp;uhci-&gt;stall_timer);
-	uhci-&gt;stall_timer.function = stall_callback;
-	uhci-&gt;stall_timer.data = (unsigned long)hcd;
-	uhci-&gt;stall_timer.expires = jiffies + msecs_to_jiffies(100);
-	add_timer(&amp;uhci-&gt;stall_timer);
-
-	return 0;
-}
-
 static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
@@ -509,6 +468,10 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
+	init_timer(&amp;uhci-&gt;stall_timer);
+	uhci-&gt;stall_timer.function = stall_callback;
+	uhci-&gt;stall_timer.data = (unsigned long) uhci;
+
 	uhci-&gt;fl = dma_alloc_coherent(uhci_dev(uhci), sizeof(*uhci-&gt;fl),
 			&amp;dma_handle, 0);
 	if (!uhci-&gt;fl) {
@@ -646,7 +609,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	if ((retval = start_hc(uhci)) != 0)
 		goto err_alloc_skelqh;
 
-	init_stall_timer(hcd);
+	restart_timer(uhci);
 
 	udev-&gt;speed = USB_SPEED_FULL;
 
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 4c45ba8390f8..ddb19cbf4b75 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -33,6 +33,22 @@ static __u8 root_hub_hub_des[] =
 /* status change bits:  nonzero writes will clear */
 #define RWC_BITS	(USBPORTSC_OCC | USBPORTSC_PEC | USBPORTSC_CSC)
 
+/* A port that either is connected or has a changed-bit set will prevent
+ * us from AUTO_STOPPING.
+ */
+static int any_ports_active(struct uhci_hcd *uhci)
+{
+	int port;
+
+	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
+		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp;
+				(USBPORTSC_CCS | RWC_BITS)) ||
+				test_bit(port, &amp;uhci-&gt;port_c_suspend))
+			return 1;
+	}
+	return 0;
+}
+
 static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 2a7c19501f24..f5c75885f7be 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1537,3 +1537,26 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	/* Wake up anyone waiting for an URB to complete */
 	wake_up_all(&amp;uhci-&gt;waitqh);
 }
+
+static void check_fsbr(struct uhci_hcd *uhci)
+{
+	struct urb_priv *up;
+
+	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
+		struct urb *u = up-&gt;urb;
+
+		spin_lock(&amp;u-&gt;lock);
+
+		/* Check if the FSBR timed out */
+		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
+			uhci_fsbr_timeout(uhci, u);
+
+		spin_unlock(&amp;u-&gt;lock);
+	}
+
+	/* Really disable FSBR */
+	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
+		uhci-&gt;fsbrtimeout = 0;
+		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	}
+}</pre>
    <div class="pagination">
        <a href='2_138.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><span>[139]</span><a href='2_140.html'>140</a><a href='2_140.html'>Next&gt;&gt;</a>
    <div>
</body>
