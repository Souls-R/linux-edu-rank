<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_94.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><span>[95]</span><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_96.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 70a1c9e086c2e267fbc4533cb870f34999b531d6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 6 17:00:58 2008 -0500

    USB: remove dev-&gt;power.power_state
    
    power.power_state is scheduled for removal.  This patch (as1053)
    removes all uses of that field from drivers/usb.  Almost all of them
    were write-only, the most significant exceptions being sl811-hcd.c and
    u132-hcd.c.
    
    Part of this patch was written by Pavel Machek.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Acked-by: Pavel Machek &lt;pavel@ucw.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ebccdefcc6f2..2ea333a43d65 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -794,8 +794,6 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 
  done:
 	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	if (status == 0)
-		udev-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
@@ -824,10 +822,8 @@ static int usb_resume_device(struct usb_device *udev)
 
  done:
 	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	if (status == 0) {
+	if (status == 0)
 		udev-&gt;autoresume_disabled = 0;
-		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
-	}
 	return status;
 }
 
@@ -1180,8 +1176,7 @@ static int usb_resume_both(struct usb_device *udev)
 		}
 	} else {
 
-		/* Needed for setting udev-&gt;dev.power.power_state.event,
-		 * for possible debugging message, and for reset_resume. */
+		/* Needed for reset-resume */
 		status = usb_resume_device(udev);
 	}
 
@@ -1194,7 +1189,8 @@ static int usb_resume_both(struct usb_device *udev)
 
  done:
 	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	udev-&gt;reset_resume = 0;
+	if (!status)
+		udev-&gt;reset_resume = 0;
 	return status;
 }
 
diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 84760ddbc332..739407bb8492 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -73,7 +73,6 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (pci_enable_device(dev) &lt; 0)
 		return -ENODEV;
 	dev-&gt;current_state = PCI_D0;
-	dev-&gt;dev.power.power_state = PMSG_ON;
 
 	if (!dev-&gt;irq) {
 		dev_err(&amp;dev-&gt;dev,
@@ -302,8 +301,6 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 
 done:
 	if (retval == 0) {
-		dev-&gt;dev.power.power_state = PMSG_SUSPEND;
-
 #ifdef CONFIG_PPC_PMAC
 		/* Disable ASIC clocks for USB */
 		if (machine_is(powermac)) {
@@ -406,8 +403,6 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 	pci_set_master(dev);
 	pci_restore_state(dev);
 
-	dev-&gt;dev.power.power_state = PMSG_ON;
-
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
 	if (hcd-&gt;driver-&gt;resume) {
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 2375194a9d43..1bf8ccb9c58d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -114,13 +114,11 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 static inline void mark_active(struct usb_interface *f)
 {
 	f-&gt;is_active = 1;
-	f-&gt;dev.power.power_state.event = PM_EVENT_ON;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
 	f-&gt;is_active = 0;
-	f-&gt;dev.power.power_state.event = PM_EVENT_SUSPEND;
 }
 
 static inline int is_active(const struct usb_interface *f)
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index cbe44535c0f0..e454775c2ff2 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -900,7 +900,6 @@ static int dummy_udc_suspend (struct platform_device *pdev, pm_message_t state)
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
 
-	pdev-&gt;dev.power.power_state = state;
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
@@ -915,7 +914,6 @@ static int dummy_udc_resume (struct platform_device *pdev)
 	set_link_state (dum);
 	spin_unlock_irq (&amp;dum-&gt;lock);
 
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
 }
diff --git a/drivers/usb/gadget/omap_udc.c b/drivers/usb/gadget/omap_udc.c
index ee1e9a314cd1..56277d24f041 100644
--- a/drivers/usb/gadget/omap_udc.c
+++ b/drivers/usb/gadget/omap_udc.c
@@ -1265,8 +1265,6 @@ static int can_pullup(struct omap_udc *udc)
 
 static void pullup_enable(struct omap_udc *udc)
 {
-	udc-&gt;gadget.dev.parent-&gt;power.power_state = PMSG_ON;
-	udc-&gt;gadget.dev.power.power_state = PMSG_ON;
 	UDC_SYSCON1_REG |= UDC_PULLUP_EN;
 	if (!gadget_is_otg(&amp;udc-&gt;gadget) &amp;&amp; !cpu_is_omap15xx())
 		OTG_CTRL_REG |= OTG_BSESSVLD;
@@ -3061,8 +3059,6 @@ static int omap_udc_suspend(struct platform_device *dev, pm_message_t message)
 		omap_pullup(&amp;udc-&gt;gadget, 0);
 	}
 
-	udc-&gt;gadget.dev.power.power_state = PMSG_SUSPEND;
-	udc-&gt;gadget.dev.parent-&gt;power.power_state = PMSG_SUSPEND;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 38eb92e5dc42..4af90df8e7de 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -670,7 +670,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 
-	if (buf-&gt;bus-&gt;controller-&gt;power.power_state.event) {
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
 		size = scnprintf (next, size,
 			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
 			"%s\n"
diff --git a/drivers/usb/host/ehci-ps3.c b/drivers/usb/host/ehci-ps3.c
index bbda58eb8813..69782221bcf3 100644
--- a/drivers/usb/host/ehci-ps3.c
+++ b/drivers/usb/host/ehci-ps3.c
@@ -125,7 +125,6 @@ static int ps3_ehci_probe(struct ps3_system_bus_device *dev)
 		goto fail_irq;
 	}
 
-	dev-&gt;core.power.power_state = PMSG_ON;
 	dev-&gt;core.dma_mask = &amp;dummy_mask; /* FIXME: for improper usb code */
 
 	hcd = usb_create_hcd(&amp;ps3_ehci_hc_driver, &amp;dev-&gt;core, dev-&gt;core.bus_id);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 203a3359a648..66d773c726f6 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1442,11 +1442,6 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 		break;
 	case HCCONTROL_USB_OPER:
 		spin_unlock_irq(&amp;isp116x-&gt;lock);
-		/* Without setting power_state here the
-		   SUSPENDED state won't be removed from
-		   sysfs/usbN/power.state as a response to remote
-		   wakeup. Maybe in the future. */
-		hcd-&gt;self.root_hub-&gt;dev.power.power_state = PMSG_ON;
 		return 0;
 	default:
 		/* HCCONTROL_USB_RESET: this may happen, when during
@@ -1460,7 +1455,6 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 		if ((isp116x-&gt;rhdesca &amp; RH_A_NDP) == 2)
 			isp116x_hub_control(hcd, SetPortFeature,
 					    USB_PORT_FEAT_POWER, 2, NULL, 0);
-		hcd-&gt;self.root_hub-&gt;dev.power.power_state = PMSG_ON;
 		return 0;
 	}
 
@@ -1486,8 +1480,6 @@ static int isp116x_bus_resume(struct usb_hcd *hcd)
 	isp116x_write_reg32(isp116x, HCCONTROL,
 			    (val &amp; ~HCCONTROL_HCFS) | HCCONTROL_USB_OPER);
 	spin_unlock_irq(&amp;isp116x-&gt;lock);
-	/* see analogous comment above */
-	hcd-&gt;self.root_hub-&gt;dev.power.power_state = PMSG_ON;
 	hcd-&gt;state = HC_STATE_RUNNING;
 
 	return 0;
@@ -1663,7 +1655,6 @@ static int __devinit isp116x_probe(struct platform_device *pdev)
 static int isp116x_suspend(struct platform_device *dev, pm_message_t state)
 {
 	VDBG("%s: state %x\n", __func__, state.event);
-	dev-&gt;dev.power.power_state = state;
 	return 0;
 }
 
@@ -1672,8 +1663,7 @@ static int isp116x_suspend(struct platform_device *dev, pm_message_t state)
 */
 static int isp116x_resume(struct platform_device *dev)
 {
-	VDBG("%s:  state %x\n", __func__, dev-&gt;power.power_state.event);
-	dev-&gt;dev.power.power_state = PMSG_ON;
+	VDBG("%s\n", __func__);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index a22c30aa745d..e06bfaebec54 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -655,7 +655,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 		hcd-&gt;product_desc,
 		hcd_name);
 
-	if (bus-&gt;controller-&gt;power.power_state.event) {
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
 		size -= scnprintf (next, size,
 			"SUSPENDED (no register access)\n");
 		goto done;
diff --git a/drivers/usb/host/ohci-ep93xx.c b/drivers/usb/host/ohci-ep93xx.c
index 156e93a9d0df..40c683f8987d 100644
--- a/drivers/usb/host/ohci-ep93xx.c
+++ b/drivers/usb/host/ohci-ep93xx.c
@@ -177,7 +177,6 @@ static int ohci_hcd_ep93xx_drv_suspend(struct platform_device *pdev, pm_message_
 
 	ep93xx_stop_hc(&amp;pdev-&gt;dev);
 	hcd-&gt;state = HC_STATE_SUSPENDED;
-	pdev-&gt;dev.power.power_state = PMSG_SUSPEND;
 
 	return 0;
 }
@@ -193,7 +192,6 @@ static int ohci_hcd_ep93xx_drv_resume(struct platform_device *pdev)
 	ohci-&gt;next_statechange = jiffies;
 
 	ep93xx_start_hc(&amp;pdev-&gt;dev);
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(hcd);
 
 	return 0;
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index 7bfca1ed1b58..2aafa7b6c81f 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -505,7 +505,6 @@ static int ohci_omap_suspend(struct platform_device *dev, pm_message_t message)
 
 	omap_ohci_clock_power(0);
 	ohci_to_hcd(ohci)-&gt;state = HC_STATE_SUSPENDED;
-	dev-&gt;dev.power.power_state = PMSG_SUSPEND;
 	return 0;
 }
 
@@ -518,7 +517,6 @@ static int ohci_omap_resume(struct platform_device *dev)
 	ohci-&gt;next_statechange = jiffies;
 
 	omap_ohci_clock_power(1);
-	dev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(platform_get_drvdata(dev));
 	return 0;
 }
diff --git a/drivers/usb/host/ohci-ps3.c b/drivers/usb/host/ohci-ps3.c
index 01a0caeaa6bc..c1935ae537f8 100644
--- a/drivers/usb/host/ohci-ps3.c
+++ b/drivers/usb/host/ohci-ps3.c
@@ -127,7 +127,6 @@ static int ps3_ohci_probe(struct ps3_system_bus_device *dev)
 		goto fail_irq;
 	}
 
-	dev-&gt;core.power.power_state = PMSG_ON;
 	dev-&gt;core.dma_mask = &amp;dummy_mask; /* FIXME: for improper usb code */
 
 	hcd = usb_create_hcd(&amp;ps3_ohci_hc_driver, &amp;dev-&gt;core, dev-&gt;core.bus_id);
diff --git a/drivers/usb/host/ohci-pxa27x.c b/drivers/usb/host/ohci-pxa27x.c
index 8ad9b3b604b5..5d470263eed8 100644
--- a/drivers/usb/host/ohci-pxa27x.c
+++ b/drivers/usb/host/ohci-pxa27x.c
@@ -339,7 +339,6 @@ static int ohci_hcd_pxa27x_drv_suspend(struct platform_device *pdev, pm_message_
 
 	pxa27x_stop_hc(&amp;pdev-&gt;dev);
 	hcd-&gt;state = HC_STATE_SUSPENDED;
-	pdev-&gt;dev.power.power_state = PMSG_SUSPEND;
 
 	return 0;
 }
@@ -357,7 +356,6 @@ static int ohci_hcd_pxa27x_drv_resume(struct platform_device *pdev)
 	if ((status = pxa27x_start_hc(&amp;pdev-&gt;dev)) &lt; 0)
 		return status;
 
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(hcd);
 
 	return 0;
diff --git a/drivers/usb/host/ohci-sm501.c b/drivers/usb/host/ohci-sm501.c
index 8ffcd3e5f56b..ab1e366d7790 100644
--- a/drivers/usb/host/ohci-sm501.c
+++ b/drivers/usb/host/ohci-sm501.c
@@ -224,7 +224,6 @@ static int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)
 
 	sm501_unit_power(dev-&gt;parent, SM501_GATE_USB_HOST, 0);
 	ohci_to_hcd(ohci)-&gt;state = HC_STATE_SUSPENDED;
-	dev-&gt;power.power_state = PMSG_SUSPEND;
 	return 0;
 }
 
@@ -238,7 +237,6 @@ static int ohci_sm501_resume(struct platform_device *pdev)
 	ohci-&gt;next_statechange = jiffies;
 
 	sm501_unit_power(dev-&gt;parent, SM501_GATE_USB_HOST, 1);
-	dev-&gt;power.power_state = PMSG_ON;
 	usb_hcd_resume_root_hub(platform_get_drvdata(pdev));
 	return 0;
 }
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index afd4fbe7713c..b46ff9a80b66 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -2107,13 +2107,11 @@ static struct hc_driver r8a66597_hc_driver = {
 #if defined(CONFIG_PM)
 static int r8a66597_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	pdev-&gt;dev.power.power_state = state;
 	return 0;
 }
 
 static int r8a66597_resume(struct platform_device *pdev)
 {
-	pdev-&gt;dev.power.power_state = PMSG_ON;
 	return 0;
 }
 #else	/* if defined(CONFIG_PM) */
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 629bca0ebe8f..df256d61e2c6 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -94,12 +94,10 @@ static void port_power(struct sl811 *sl811, int is_on)
 
 		sl811-&gt;port1 = (1 &lt;&lt; USB_PORT_FEAT_POWER);
 		sl811-&gt;irq_enable = SL11H_INTMASK_INSRMV;
-		hcd-&gt;self.controller-&gt;power.power_state = PMSG_ON;
 	} else {
 		sl811-&gt;port1 = 0;
 		sl811-&gt;irq_enable = 0;
 		hcd-&gt;state = HC_STATE_HALT;
-		hcd-&gt;self.controller-&gt;power.power_state = PMSG_SUSPEND;
 	}
 	sl811-&gt;ctrl1 = 0;
 	sl811_write(sl811, SL11H_IRQ_ENABLE, 0);
@@ -1772,8 +1770,6 @@ sl811h_suspend(struct platform_device *dev, pm_message_t state)
 		port_power(sl811, 0);
 		break;
 	}
-	if (retval == 0)
-		dev-&gt;dev.power.power_state = state;
 	return retval;
 }
 
@@ -1786,15 +1782,13 @@ sl811h_resume(struct platform_device *dev)
 	/* with no "check to see if VBUS is still powered" board hook,
 	 * let's assume it'd only be powered to enable remote wakeup.
 	 */
-	if (dev-&gt;dev.power.power_state.event == PM_EVENT_SUSPEND
-			|| !device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)) {
+	if (!sl811-&gt;port1 || !device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)) {
 		sl811-&gt;port1 = 0;
 		port_power(sl811, 1);
 		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 		return 0;
 	}
 
-	dev-&gt;dev.power.power_state = PMSG_ON;
 	return sl811h_bus_resume(hcd);
 }
 
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 8e117a795e93..6e9b7edff528 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -1534,11 +1534,9 @@ static void u132_power(struct u132 *u132, int is_on)
                 if (u132-&gt;power)
                         return;
                 u132-&gt;power = 1;
-                hcd-&gt;self.controller-&gt;power.power_state = PMSG_ON;
         } else {
                 u132-&gt;power = 0;
                 hcd-&gt;state = HC_STATE_HALT;
-                hcd-&gt;self.controller-&gt;power.power_state = PMSG_SUSPEND;
         }
 }
 
@@ -3227,8 +3225,6 @@ static int u132_suspend(struct platform_device *pdev, pm_message_t state)
                         }
 			break;
 		}
-                if (retval == 0)
-                        pdev-&gt;dev.power.power_state = state;
                 return retval;
         }
 }
@@ -3246,14 +3242,13 @@ static int u132_resume(struct platform_device *pdev)
                 return -ESHUTDOWN;
         } else {
                 int retval = 0;
-                if (pdev-&gt;dev.power.power_state.event == PM_EVENT_SUSPEND) {
+		if (!u132-&gt;port[0].power) {
                         int ports = MAX_U132_PORTS;
                         while (ports-- &gt; 0) {
                                 port_power(u132, ports, 1);
                         }
                         retval = 0;
                 } else {
-                        pdev-&gt;dev.power.power_state = PMSG_ON;
                         retval = u132_bus_resume(hcd);
                 }
                 return retval;
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 17100471e461..2c4fd4d6df95 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -1564,7 +1564,8 @@ usbtest_ioctl (struct usb_interface *intf, unsigned int code, void *buf)
 	if (mutex_lock_interruptible(&amp;dev-&gt;lock))
 		return -ERESTARTSYS;
 
-	if (intf-&gt;dev.power.power_state.event != PM_EVENT_ON) {
+	/* FIXME: What if a system sleep starts while a test is running? */
+	if (!intf-&gt;is_active) {
 		mutex_unlock(&amp;dev-&gt;lock);
 		return -EHOSTUNREACH;
 	}</pre><hr><pre>commit 9214d1d80c19016172e685ce7bde0ea757c49097
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 6 11:04:13 2008 -0500

    USB: enable USB-PERSIST by default
    
    This patch (as1052) enables USB-PERSIST for all devices by default.
    The user won't have to remember to enable it explicitly for devices
    containing mounted filesystems.
    
    Eventually userspace tools like hal may be able to set the persist
    attribute automatically when a filesystem is mounted on a USB device.
    When that time comes this patch can be reverted, if people think it
    matters.
    
    This approach has the advantage of giving the user the ability to turn
    off USB-PERSIST for devices with mounted filesystems, rather than
    making the kernel always assume it should be on.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index f384edf35b44..2e2019390290 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -98,12 +98,14 @@ void usb_detect_quirks(struct usb_device *udev)
 		udev-&gt;autosuspend_disabled = 1;
 #endif
 
-#ifdef	CONFIG_PM
+	/* For the present, all devices default to USB-PERSIST enabled */
+#if 0		/* was: #ifdef CONFIG_PM */
 	/* Hubs are automatically enabled for USB-PERSIST */
 	if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
 		udev-&gt;persist_enabled = 1;
+
 #else
-	/* In the absense of PM, we can safely enable USB-PERSIST
+	/* In the absence of PM, we can safely enable USB-PERSIST
 	 * for all devices.  It will affect things like hub resets
 	 * and EMF-related port disables.
 	 */</pre><hr><pre>commit eb764c4be1e5db3ee34df5745e98cf2f148c7320
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 3 15:16:04 2008 -0500

    USB: check serial-number string after device reset
    
    This patch (as1048) extends the descriptor checking after a device is
    reset.  Now the SerialNumber string descriptor is compared to its old
    value, in addition to the device and configuration descriptors.
    
    As a consequence, the kmalloc() call in usb_string() is now on the
    error-handling pathway for usb-storage.  Hence its allocation type is
    changed to GFO_NOIO.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/persist.txt b/Documentation/usb/persist.txt
index bea58dbd30fe..d56cb1a11550 100644
--- a/Documentation/usb/persist.txt
+++ b/Documentation/usb/persist.txt
@@ -136,10 +136,10 @@ aren't guaranteed to be 100% accurate.
 
 If you replace one USB device with another of the same type (same
 manufacturer, same IDs, and so on) there's an excellent chance the
-kernel won't detect the change.  Serial numbers and other strings are
-not compared.  In many cases it wouldn't help if they were, because
-manufacturers frequently omit serial numbers entirely in their
-devices.
+kernel won't detect the change.  The serial number string and other
+descriptors are compared with the kernel's stored values, but this
+might not help since manufacturers frequently omit serial numbers
+entirely in their devices.
 
 Furthermore it's quite possible to leave a USB device exactly the same
 while changing its media.  If you replace the flash memory card in a
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6dc589955d75..9fc5179dfc60 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3010,16 +3010,36 @@ void usb_hub_cleanup(void)
 	usb_deregister(&amp;hub_driver);
 } /* usb_hub_cleanup() */
 
-static int config_descriptors_changed(struct usb_device *udev)
-{
-	unsigned			index;
-	unsigned			len = 0;
-	struct usb_config_descriptor	*buf;
+static int descriptors_changed(struct usb_device *udev,
+		struct usb_device_descriptor *old_device_descriptor)
+{
+	int		changed = 0;
+	unsigned	index;
+	unsigned	serial_len = 0;
+	unsigned	len;
+	unsigned	old_length;
+	int		length;
+	char		*buf;
+
+	if (memcmp(&amp;udev-&gt;descriptor, old_device_descriptor,
+			sizeof(*old_device_descriptor)) != 0)
+		return 1;
+
+	/* Since the idVendor, idProduct, and bcdDevice values in the
+	 * device descriptor haven't changed, we will assume the
+	 * Manufacturer and Product strings haven't changed either.
+	 * But the SerialNumber string could be different (e.g., a
+	 * different flash card of the same brand).
+	 */
+	if (udev-&gt;serial)
+		serial_len = strlen(udev-&gt;serial) + 1;
 
+	len = serial_len;
 	for (index = 0; index &lt; udev-&gt;descriptor.bNumConfigurations; index++) {
-		if (len &lt; le16_to_cpu(udev-&gt;config[index].desc.wTotalLength))
-			len = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
+		old_length = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
+		len = max(len, old_length);
 	}
+
 	buf = kmalloc(len, GFP_NOIO);
 	if (buf == NULL) {
 		dev_err(&amp;udev-&gt;dev, "no mem to re-read configs after reset\n");
@@ -3027,25 +3047,41 @@ static int config_descriptors_changed(struct usb_device *udev)
 		return 1;
 	}
 	for (index = 0; index &lt; udev-&gt;descriptor.bNumConfigurations; index++) {
-		int length;
-		int old_length = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
-
+		old_length = le16_to_cpu(udev-&gt;config[index].desc.wTotalLength);
 		length = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,
 				old_length);
-		if (length &lt; old_length) {
+		if (length != old_length) {
 			dev_dbg(&amp;udev-&gt;dev, "config index %d, error %d\n",
 					index, length);
+			changed = 1;
 			break;
 		}
 		if (memcmp (buf, udev-&gt;rawdescriptors[index], old_length)
 				!= 0) {
 			dev_dbg(&amp;udev-&gt;dev, "config index %d changed (#%d)\n",
-				index, buf-&gt;bConfigurationValue);
+				index,
+				((struct usb_config_descriptor *) buf)-&gt;
+					bConfigurationValue);
+			changed = 1;
 			break;
 		}
 	}
+
+	if (!changed &amp;&amp; serial_len) {
+		length = usb_string(udev, udev-&gt;descriptor.iSerialNumber,
+				buf, serial_len);
+		if (length + 1 != serial_len) {
+			dev_dbg(&amp;udev-&gt;dev, "serial string error %d\n",
+					length);
+			changed = 1;
+		} else if (memcmp(buf, udev-&gt;serial, length) != 0) {
+			dev_dbg(&amp;udev-&gt;dev, "serial string changed\n");
+			changed = 1;
+		}
+	}
+
 	kfree(buf);
-	return index != udev-&gt;descriptor.bNumConfigurations;
+	return changed;
 }
 
 /**
@@ -3118,8 +3154,7 @@ int usb_reset_device(struct usb_device *udev)
 		goto re_enumerate;
  
 	/* Device might have changed firmware (DFU or similar) */
-	if (memcmp(&amp;udev-&gt;descriptor, &amp;descriptor, sizeof descriptor)
-			|| config_descriptors_changed (udev)) {
+	if (descriptors_changed(udev, &amp;descriptor)) {
 		dev_info(&amp;udev-&gt;dev, "device firmware changed\n");
 		udev-&gt;descriptor = descriptor;	/* for disconnect() calls */
 		goto re_enumerate;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index c311f67b7f08..a3695b5115ff 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -784,7 +784,7 @@ int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
 	if (size &lt;= 0 || !buf || !index)
 		return -EINVAL;
 	buf[0] = 0;
-	tbuf = kmalloc(256, GFP_KERNEL);
+	tbuf = kmalloc(256, GFP_NOIO);
 	if (!tbuf)
 		return -ENOMEM;
 </pre><hr><pre>commit feccc30d90155bcbc937f87643182a43d25873eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 3 15:15:59 2008 -0500

    USB: remove CONFIG_USB_PERSIST setting
    
    This patch (as1047) removes the USB_PERSIST Kconfig option, enabling
    it permanently.  It also prevents the power/persist attribute from
    being created for hub devices; there's no point in having it since
    USB-PERSIST is always turned on for hubs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/persist.txt b/Documentation/usb/persist.txt
index df54d645cbb5..bea58dbd30fe 100644
--- a/Documentation/usb/persist.txt
+++ b/Documentation/usb/persist.txt
@@ -2,7 +2,7 @@
 
 		   Alan Stern &lt;stern@rowland.harvard.edu&gt;
 
-		 September 2, 2006 (Updated May 29, 2007)
+		September 2, 2006 (Updated February 25, 2008)
 
 
 	What is the problem?
@@ -65,9 +65,10 @@ much better.)
 
 	What is the solution?
 
-Setting CONFIG_USB_PERSIST will cause the kernel to work around these
-issues.  It enables a mode in which the core USB device data
-structures are allowed to persist across a power-session disruption.
+The kernel includes a feature called USB-persist.  It tries to work
+around these issues by allowing the core USB device data structures to
+persist across a power-session disruption.
+
 It works like this.  If the kernel sees that a USB host controller is
 not in the expected state during resume (i.e., if the controller was
 reset or otherwise had lost power) then it applies a persistence check
@@ -80,28 +81,30 @@ re-enumeration shows that the device now attached to that port has the
 same descriptors as before, including the Vendor and Product IDs, then
 the kernel continues to use the same device structure.  In effect, the
 kernel treats the device as though it had merely been reset instead of
-unplugged.
+unplugged.  The same thing happens if the host controller is in the
+expected state but a USB device was unplugged and then replugged.
 
 If no device is now attached to the port, or if the descriptors are
 different from what the kernel remembers, then the treatment is what
 you would expect.  The kernel destroys the old device structure and
 behaves as though the old device had been unplugged and a new device
-plugged in, just as it would without the CONFIG_USB_PERSIST option.
+plugged in.
 
 The end result is that the USB device remains available and usable.
 Filesystem mounts and memory mappings are unaffected, and the world is
 now a good and happy place.
 
-Note that even when CONFIG_USB_PERSIST is set, the "persist" feature
-will be applied only to those devices for which it is enabled.  You
-can enable the feature by doing (as root):
+Note that the "USB-persist" feature will be applied only to those
+devices for which it is enabled.  You can enable the feature by doing
+(as root):
 
 	echo 1 &gt;/sys/bus/usb/devices/.../power/persist
 
 where the "..." should be filled in the with the device's ID.  Disable
 the feature by writing 0 instead of 1.  For hubs the feature is
-automatically and permanently enabled, so you only have to worry about
-setting it for devices where it really matters.
+automatically and permanently enabled and the power/persist file
+doesn't even exist, so you only have to worry about setting it for
+devices where it really matters.
 
 
 	Is this the best solution?
@@ -112,19 +115,19 @@ centralized Logical Volume Manager.  Such a solution would allow you
 to plug in a USB flash device, create a persistent volume associated
 with it, unplug the flash device, plug it back in later, and still
 have the same persistent volume associated with the device.  As such
-it would be more far-reaching than CONFIG_USB_PERSIST.
+it would be more far-reaching than USB-persist.
 
 On the other hand, writing a persistent volume manager would be a big
 job and using it would require significant input from the user.  This
 solution is much quicker and easier -- and it exists now, a giant
 point in its favor!
 
-Furthermore, the USB_PERSIST option applies to _all_ USB devices, not
+Furthermore, the USB-persist feature applies to _all_ USB devices, not
 just mass-storage devices.  It might turn out to be equally useful for
 other device types, such as network interfaces.
 
 
-	WARNING: Using CONFIG_USB_PERSIST can be dangerous!!
+	WARNING: USB-persist can be dangerous!!
 
 When recovering an interrupted power session the kernel does its best
 to make sure the USB device hasn't been changed; that is, the same
@@ -152,5 +155,5 @@ but yourself.
 YOU HAVE BEEN WARNED!  USE AT YOUR OWN RISK!
 
 That having been said, most of the time there shouldn't be any trouble
-at all.  The "persist" feature can be extremely useful.  Make the most
-of it.
+at all.  The USB-persist feature can be extremely useful.  Make the
+most of it.
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index a2b0aa48b8ea..c15621d64579 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -102,31 +102,6 @@ config USB_SUSPEND
 
 	  If you are unsure about this, say N here.
 
-config USB_PERSIST
-	bool "USB device persistence during system suspend (DANGEROUS)"
-	depends on USB &amp;&amp; PM &amp;&amp; EXPERIMENTAL
-	default n
-	help
-
-	  If you say Y here and enable the "power/persist" attribute
-	  for a USB device, the device's data structures will remain
-	  persistent across system suspend, even if the USB bus loses
-	  power.  (This includes hibernation, also known as swsusp or
-	  suspend-to-disk.)  The devices will reappear as if by magic
-	  when the system wakes up, with no need to unmount USB
-	  filesystems, rmmod host-controller drivers, or do anything
-	  else.
-
-	  	WARNING: This option can be dangerous!
-
-	  If a USB device is replaced by another of the same type while
-	  the system is asleep, there's a good chance the kernel won't
-	  detect the change.  Likewise if the media in a USB storage
-	  device is replaced.  When this happens it's almost certain to
-	  cause data corruption and maybe even crash your system.
-
-	  If you are unsure, say N here.
-
 config USB_OTG
 	bool
 	depends on USB &amp;&amp; EXPERIMENTAL
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index df68e2562582..6dc589955d75 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -30,12 +30,6 @@
 #include "hcd.h"
 #include "hub.h"
 
-#ifdef	CONFIG_USB_PERSIST
-#define	USB_PERSIST	1
-#else
-#define	USB_PERSIST	0
-#endif
-
 /* if we are in debug mode, always announce new devices */
 #ifdef DEBUG
 #ifndef CONFIG_USB_ANNOUNCE_NEW_DEVICES
@@ -695,7 +689,7 @@ static void hub_restart(struct usb_hub *hub, int type)
 		 * turn off the various status changes to prevent
 		 * khubd from disconnecting it later.
 		 */
-		if (USB_PERSIST &amp;&amp; udev-&gt;persist_enabled &amp;&amp; status == 0 &amp;&amp;
+		if (udev-&gt;persist_enabled &amp;&amp; status == 0 &amp;&amp;
 				!(portstatus &amp; USB_PORT_STAT_ENABLE)) {
 			if (portchange &amp; USB_PORT_STAT_C_ENABLE)
 				clear_port_feature(hub-&gt;hdev, port1,
@@ -1923,9 +1917,8 @@ static int finish_port_resume(struct usb_device *udev)
  * the host and the device is the same as it was when the device
  * suspended.
  *
- * If CONFIG_USB_PERSIST and @udev-&gt;reset_resume are both set then this
- * routine won't check that the port is still enabled.  Furthermore,
- * if @udev-&gt;reset_resume is set then finish_port_resume() above will
+ * If @udev-&gt;reset_resume is set then this routine won't check that the
+ * port is still enabled.  Furthermore, finish_port_resume() above will
  * reset @udev.  The end result is that a broken power session can be
  * recovered and @udev will appear to persist across a loss of VBUS power.
  *
@@ -1937,8 +1930,8 @@ static int finish_port_resume(struct usb_device *udev)
  * to it will be lost.  Using the USB_PERSIST facility, the device can be
  * made to appear as if it had not disconnected.
  *
- * This facility is inherently dangerous.  Although usb_reset_device()
- * makes every effort to insure that the same device is present after the
+ * This facility can be dangerous.  Although usb_reset_device() makes
+ * every effort to insure that the same device is present after the
  * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
  * quite possible for a device to remain unaltered but its media to be
  * changed.  If the user replaces a flash memory card while the system is
@@ -1983,7 +1976,7 @@ int usb_port_resume(struct usb_device *udev)
 		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
 
  SuspendCleared:
-		if (USB_PERSIST &amp;&amp; udev-&gt;reset_resume)
+		if (udev-&gt;reset_resume)
 			want_flags = USB_PORT_STAT_POWER
 					| USB_PORT_STAT_CONNECTION;
 		else
@@ -2113,10 +2106,10 @@ static int hub_reset_resume(struct usb_interface *intf)
  *
  * The USB host controller driver calls this function when its root hub
  * is resumed and Vbus power has been interrupted or the controller
- * has been reset.  The routine marks @rhdev as having lost power.  When
- * the hub driver is resumed it will take notice; if CONFIG_USB_PERSIST
- * is enabled then it will carry out power-session recovery, otherwise
- * it will disconnect all the child devices.
+ * has been reset.  The routine marks @rhdev as having lost power.
+ * When the hub driver is resumed it will take notice and carry out
+ * power-session recovery for all the "USB-PERSIST"-enabled child devices;
+ * the others will be disconnected.
  */
 void usb_root_hub_lost_power(struct usb_device *rhdev)
 {
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index dfc5418ea10c..f384edf35b44 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -97,4 +97,16 @@ void usb_detect_quirks(struct usb_device *udev)
 	if (udev-&gt;descriptor.bDeviceClass != USB_CLASS_HUB)
 		udev-&gt;autosuspend_disabled = 1;
 #endif
+
+#ifdef	CONFIG_PM
+	/* Hubs are automatically enabled for USB-PERSIST */
+	if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
+		udev-&gt;persist_enabled = 1;
+#else
+	/* In the absense of PM, we can safely enable USB-PERSIST
+	 * for all devices.  It will affect things like hub resets
+	 * and EMF-related port disables.
+	 */
+	udev-&gt;persist_enabled = 1;
+#endif	/* CONFIG_PM */
 }
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index a37ccbd1e007..5b20a60de8ba 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -180,11 +180,9 @@ show_urbnum(struct device *dev, struct device_attribute *attr, char *buf)
 static DEVICE_ATTR(urbnum, S_IRUGO, show_urbnum, NULL);
 
 
-#if defined(CONFIG_USB_PERSIST) || defined(CONFIG_USB_SUSPEND)
-static const char power_group[] = "power";
-#endif
+#ifdef	CONFIG_PM
 
-#ifdef	CONFIG_USB_PERSIST
+static const char power_group[] = "power";
 
 static ssize_t
 show_persist(struct device *dev, struct device_attribute *attr, char *buf)
@@ -222,12 +220,13 @@ static int add_persist_attributes(struct device *dev)
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		/* Hubs are automatically enabled for USB_PERSIST */
-		if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB)
-			udev-&gt;persist_enabled = 1;
-		rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
-				&amp;dev_attr_persist.attr,
-				power_group);
+		/* Hubs are automatically enabled for USB_PERSIST,
+		 * no point in creating the attribute file.
+		 */
+		if (udev-&gt;descriptor.bDeviceClass != USB_CLASS_HUB)
+			rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
+					&amp;dev_attr_persist.attr,
+					power_group);
 	}
 	return rc;
 }
@@ -238,13 +237,12 @@ static void remove_persist_attributes(struct device *dev)
 			&amp;dev_attr_persist.attr,
 			power_group);
 }
-
 #else
 
 #define add_persist_attributes(dev)	0
 #define remove_persist_attributes(dev)	do {} while (0)
 
-#endif	/* CONFIG_USB_PERSIST */
+#endif	/* CONFIG_PM */
 
 #ifdef	CONFIG_USB_SUSPEND
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 8d513a15d0cd..fea9e47192db 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -28,7 +28,7 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_USB_PERSIST
+#ifdef	CONFIG_PM
 
 static int ehci_hub_control(
 	struct usb_hcd	*hcd,
@@ -104,15 +104,6 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	ehci-&gt;owned_ports = 0;
 }
 
-#else	/* CONFIG_USB_PERSIST */
-
-static inline void ehci_handover_companion_ports(struct ehci_hcd *ehci)
-{ }
-
-#endif
-
-#ifdef	CONFIG_PM
-
 static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 583e0481dfa0..7e31cacfe69c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -387,6 +387,7 @@ struct usb_device {
 
 	unsigned can_submit:1;		/* URBs may be submitted */
 	unsigned discon_suspended:1;	/* Disconnected while suspended */
+	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	unsigned authorized:1;		/* Policy has said we can use it */
 	unsigned wusb:1;		/* Device is Wireless USB */
@@ -433,7 +434,6 @@ struct usb_device {
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 	unsigned reset_resume:1;	/* needs reset instead of resume */
-	unsigned persist_enabled:1;	/* USB_PERSIST enabled for this dev */
 	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
 	unsigned autoresume_disabled:1;  /*  disabled by the user */
 	unsigned skip_sys_resume:1;	/* skip the next system resume */</pre><hr><pre>commit 5e6effaed6da94e727cd45f945ad2489af8570b3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 3 15:15:51 2008 -0500

    USB: make USB-PERSIST work after every system sleep
    
    This patch (as1046) makes USB-PERSIST work more in accordance with
    the documentation.  Currently it takes effect only in cases where the
    root hub has lost power or been reset, but it is supposed to operate
    whenever a power session was dropped during a system sleep.
    
    A new hub_restart() routine carries out the duties required during a
    reset or a reset-resume.  It checks to see whether occupied ports are
    still enabled, and if they aren't then it clears the enable-change and
    connect-change features (to prevent interference by khubd) and sets
    the child device's reset_resume flag.  It also checks ports that are
    supposed to be unoccupied to verify that the firmware hasn't left the
    port in an enabled state.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 087e3bb70e09..df68e2562582 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -644,6 +644,81 @@ static void hub_stop(struct usb_hub *hub)
 	hub_quiesce(hub);
 }
 
+#define HUB_RESET		1
+#define HUB_RESUME		2
+#define HUB_RESET_RESUME	3
+
+#ifdef CONFIG_PM
+
+static void hub_restart(struct usb_hub *hub, int type)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int port1;
+
+	/* Check each of the children to see if they require
+	 * USB-PERSIST handling or disconnection.  Also check
+	 * each unoccupied port to make sure it is still disabled.
+	 */
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		struct usb_device *udev = hdev-&gt;children[port1-1];
+		int status = 0;
+		u16 portstatus, portchange;
+
+		if (!udev || udev-&gt;state == USB_STATE_NOTATTACHED) {
+			if (type != HUB_RESET) {
+				status = hub_port_status(hub, port1,
+						&amp;portstatus, &amp;portchange);
+				if (status == 0 &amp;&amp; (portstatus &amp;
+						USB_PORT_STAT_ENABLE))
+					clear_port_feature(hdev, port1,
+							USB_PORT_FEAT_ENABLE);
+			}
+			continue;
+		}
+
+		/* Was the power session lost while we were suspended? */
+		switch (type) {
+		case HUB_RESET_RESUME:
+			portstatus = 0;
+			portchange = USB_PORT_STAT_C_CONNECTION;
+			break;
+
+		case HUB_RESET:
+		case HUB_RESUME:
+			status = hub_port_status(hub, port1,
+					&amp;portstatus, &amp;portchange);
+			break;
+		}
+
+		/* For "USB_PERSIST"-enabled children we must
+		 * mark the child device for reset-resume and
+		 * turn off the various status changes to prevent
+		 * khubd from disconnecting it later.
+		 */
+		if (USB_PERSIST &amp;&amp; udev-&gt;persist_enabled &amp;&amp; status == 0 &amp;&amp;
+				!(portstatus &amp; USB_PORT_STAT_ENABLE)) {
+			if (portchange &amp; USB_PORT_STAT_C_ENABLE)
+				clear_port_feature(hub-&gt;hdev, port1,
+						USB_PORT_FEAT_C_ENABLE);
+			if (portchange &amp; USB_PORT_STAT_C_CONNECTION)
+				clear_port_feature(hub-&gt;hdev, port1,
+						USB_PORT_FEAT_C_CONNECTION);
+			udev-&gt;reset_resume = 1;
+		}
+
+		/* Otherwise for a reset_resume we must disconnect the child,
+		 * but as we may not lock the child device here
+		 * we have to do a "logical" disconnect.
+		 */
+		else if (type == HUB_RESET_RESUME)
+			hub_port_logical_disconnect(hub, port1);
+	}
+
+	hub_activate(hub);
+}
+
+#endif	/* CONFIG_PM */
+
 /* caller has locked the hub device */
 static int hub_pre_reset(struct usb_interface *intf)
 {
@@ -2015,49 +2090,20 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 
 static int hub_resume(struct usb_interface *intf)
 {
-	struct usb_hub		*hub = usb_get_intfdata (intf);
-
-	dev_dbg(&amp;intf-&gt;dev, "%s\n", __FUNCTION__);
+	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	/* tell khubd to look for changes on this hub */
-	hub_activate(hub);
+	dev_dbg(&amp;intf-&gt;dev, "%s\n", __func__);
+	hub_restart(hub, HUB_RESUME);
 	return 0;
 }
 
 static int hub_reset_resume(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
-	struct usb_device *hdev = hub-&gt;hdev;
-	int port1;
 
+	dev_dbg(&amp;intf-&gt;dev, "%s\n", __func__);
 	hub_power_on(hub);
-
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
-		struct usb_device *child = hdev-&gt;children[port1-1];
-
-		if (child) {
-
-			/* For "USB_PERSIST"-enabled children we must
-			 * mark the child device for reset-resume and
-			 * turn off the connect-change status to prevent
-			 * khubd from disconnecting it later.
-			 */
-			if (USB_PERSIST &amp;&amp; child-&gt;persist_enabled) {
-				child-&gt;reset_resume = 1;
-				clear_port_feature(hdev, port1,
-						USB_PORT_FEAT_C_CONNECTION);
-
-			/* Otherwise we must disconnect the child,
-			 * but as we may not lock the child device here
-			 * we have to do a "logical" disconnect.
-			 */
-			} else {
-				hub_port_logical_disconnect(hub, port1);
-			}
-		}
-	}
-
-	hub_activate(hub);
+	hub_restart(hub, HUB_RESET_RESUME);
 	return 0;
 }
 </pre><hr><pre>commit 3eb14915a300f539f271e3716f2421bb0697ed48
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 3 15:15:43 2008 -0500

    USB: reorganize code in hub.c
    
    This patch (as1045) reorganizes some code in the hub driver.
    hub_port_status() is moved earlier in the file, and a new hub_stop()
    routine is created to do the work currently in hub_preset() (i.e.,
    disconnect all child devices and quiesce the hub).
    
    There are no functional changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a42db75c2336..087e3bb70e09 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -333,6 +333,27 @@ static int get_port_status(struct usb_device *hdev, int port1,
 	return status;
 }
 
+static int hub_port_status(struct usb_hub *hub, int port1,
+		u16 *status, u16 *change)
+{
+	int ret;
+
+	mutex_lock(&amp;hub-&gt;status_mutex);
+	ret = get_port_status(hub-&gt;hdev, port1, &amp;hub-&gt;status-&gt;port);
+	if (ret &lt; 4) {
+		dev_err(hub-&gt;intfdev,
+			"%s failed (err = %d)\n", __func__, ret);
+		if (ret &gt;= 0)
+			ret = -EIO;
+	} else {
+		*status = le16_to_cpu(hub-&gt;status-&gt;port.wPortStatus);
+		*change = le16_to_cpu(hub-&gt;status-&gt;port.wPortChange);
+		ret = 0;
+	}
+	mutex_unlock(&amp;hub-&gt;status_mutex);
+	return ret;
+}
+
 static void kick_khubd(struct usb_hub *hub)
 {
 	unsigned long	flags;
@@ -610,9 +631,8 @@ static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
 }
 
 /* caller has locked the hub device */
-static int hub_pre_reset(struct usb_interface *intf)
+static void hub_stop(struct usb_hub *hub)
 {
-	struct usb_hub *hub = usb_get_intfdata(intf);
 	struct usb_device *hdev = hub-&gt;hdev;
 	int i;
 
@@ -622,6 +642,14 @@ static int hub_pre_reset(struct usb_interface *intf)
 			usb_disconnect(&amp;hdev-&gt;children[i]);
 	}
 	hub_quiesce(hub);
+}
+
+/* caller has locked the hub device */
+static int hub_pre_reset(struct usb_interface *intf)
+{
+	struct usb_hub *hub = usb_get_intfdata(intf);
+
+	hub_stop(hub);
 	return 0;
 }
 
@@ -910,7 +938,7 @@ static void hub_disconnect(struct usb_interface *intf)
 
 	/* Disconnect all children and quiesce the hub */
 	hub-&gt;error = 0;
-	hub_pre_reset(intf);
+	hub_stop(hub);
 
 	usb_set_intfdata (intf, NULL);
 
@@ -1510,28 +1538,6 @@ int usb_authorize_device(struct usb_device *usb_dev)
 }
 
 
-static int hub_port_status(struct usb_hub *hub, int port1,
-			       u16 *status, u16 *change)
-{
-	int ret;
-
-	mutex_lock(&amp;hub-&gt;status_mutex);
-	ret = get_port_status(hub-&gt;hdev, port1, &amp;hub-&gt;status-&gt;port);
-	if (ret &lt; 4) {
-		dev_err (hub-&gt;intfdev,
-			"%s failed (err = %d)\n", __FUNCTION__, ret);
-		if (ret &gt;= 0)
-			ret = -EIO;
-	} else {
-		*status = le16_to_cpu(hub-&gt;status-&gt;port.wPortStatus);
-		*change = le16_to_cpu(hub-&gt;status-&gt;port.wPortChange); 
-		ret = 0;
-	}
-	mutex_unlock(&amp;hub-&gt;status_mutex);
-	return ret;
-}
-
-
 /* Returns 1 if @hub is a WUSB root hub, 0 otherwise */
 static unsigned hub_is_wusb(struct usb_hub *hub)
 {
@@ -2726,7 +2732,7 @@ static void hub_events(void)
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
 			hub-&gt;error = -ENODEV;
-			hub_pre_reset(intf);
+			hub_stop(hub);
 			goto loop;
 		}
 </pre><hr><pre>commit 3bb1af5243d41af9518728445e9c9bd30dd47237
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 3 15:15:36 2008 -0500

    USB: EHCI: carry out port handover during each root-hub resume
    
    This patch (as1044) causes EHCI port handover for non-high-speed
    devices to occur during every root-hub resume, not just in cases where
    the controller lost power or was reset.  This is necessary because:
    
            When some machines go into suspend, they remove power from
            on-board USB devices while retaining suspend current for USB
            controllers.
    
            The user might well unplug a USB device while the system is
            suspended and then plug it back in before resuming.
    
    A corresponding change is made to the core resume routine; now
    high-speed root hubs will always be resumed when the system wakes up,
    even if they were suspended before the system went to sleep.  If this
    weren't done then EHCI port handover wouldn't work, since it is called
    when the EHCI root hub is resumed.
    
    Finally, a comment is added to the hub driver explaining the khubd has
    to be freezable; if it weren't frozen then it could interfere with
    port handover.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 801b6f142fa7..ebccdefcc6f2 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1523,9 +1523,14 @@ static int usb_suspend(struct device *dev, pm_message_t message)
 	udev = to_usb_device(dev);
 
 	/* If udev is already suspended, we can skip this suspend and
-	 * we should also skip the upcoming system resume. */
+	 * we should also skip the upcoming system resume.  High-speed
+	 * root hubs are an exception; they need to resume whenever the
+	 * system wakes up in order for USB-PERSIST port handover to work
+	 * properly.
+	 */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		udev-&gt;skip_sys_resume = 1;
+		if (udev-&gt;parent || udev-&gt;speed != USB_SPEED_HIGH)
+			udev-&gt;skip_sys_resume = 1;
 		return 0;
 	}
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 57aeca160f38..a42db75c2336 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2890,7 +2890,13 @@ static void hub_events(void)
 
 static int hub_thread(void *__unused)
 {
+	/* khubd needs to be freezable to avoid intefering with USB-PERSIST
+	 * port handover.  Otherwise it might see that a full-speed device
+	 * was gone before the EHCI controller had handed its port over to
+	 * the companion full-speed controller.
+	 */
 	set_freezable();
+
 	do {
 		hub_events();
 		wait_event_freezable(khubd_wait,
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4e065e556e4b..8d513a15d0cd 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -281,9 +281,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	spin_unlock_irq (&amp;ehci-&gt;lock);
-
-	if (!power_okay)
-		ehci_handover_companion_ports(ehci);
+	ehci_handover_companion_ports(ehci);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 72ccd56e36dd..040bd8632eb3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -329,7 +329,6 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
-	ehci_handover_companion_ports(ehci);
 
 	hcd-&gt;state = HC_STATE_SUSPENDED;
 	return 0;</pre><hr><pre>commit 9a3df1f7de0ecaf77a1dde86f2a4dc020f37f87e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 19 22:39:13 2008 +0100

    PM: Convert wakeup flag accessors to inline functions
    
    This patch (as1058) improves the wakeup macros in include/linux/pm.h.
    All but the trivial ones are converted to inline routines, which
    requires moving them to a separate header file since they depend on
    the definition of struct device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/include/linux/device.h b/include/linux/device.h
index d57661129cb2..d7a1ae063b65 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -475,6 +475,9 @@ struct device {
 	void	(*release)(struct device *dev);
 };
 
+/* Get the wakeup routines, which depend on struct device */
+#include &lt;linux/pm_wakeup.h&gt;
+
 #ifdef CONFIG_NUMA
 static inline int dev_to_node(struct device *dev)
 {
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3342627e2bd6..1de72cbbe0d1 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -212,54 +212,10 @@ static inline int device_suspend(pm_message_t state)
 	return 0;
 }
 
-#define suspend_report_result(fn, ret) do { } while (0)
+#define suspend_report_result(fn, ret)		do {} while (0)
 
 #endif /* !CONFIG_PM_SLEEP */
 
-#ifdef CONFIG_PM
-
-#define device_set_wakeup_enable(dev,val) \
-	((dev)-&gt;power.should_wakeup = !!(val))
-#define device_may_wakeup(dev) \
-	(device_can_wakeup(dev) &amp;&amp; (dev)-&gt;power.should_wakeup)
-
-/*
- * Platform hook to activate device wakeup capability, if that's not already
- * handled by enable_irq_wake() etc.
- * Returns zero on success, else negative errno
- */
-extern int (*platform_enable_wakeup)(struct device *dev, int is_on);
-
-static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
-{
-	if (platform_enable_wakeup)
-		return (*platform_enable_wakeup)(dev, is_on);
-	return 0;
-}
-
-#else /* !CONFIG_PM */
-
-#define device_set_wakeup_enable(dev,val)	do{}while(0)
-#define device_may_wakeup(dev)			(0)
-
-static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
-{
-	return 0;
-}
-
-#endif /* !CONFIG_PM */
-
-/* changes to device_may_wakeup take effect on the next pm state change.
- * by default, devices should wakeup if they can.
- */
-#define device_can_wakeup(dev) \
-	((dev)-&gt;power.can_wakeup)
-#define device_init_wakeup(dev,val) \
-	do { \
-		device_can_wakeup(dev) = !!(val); \
-		device_set_wakeup_enable(dev,val); \
-	} while(0)
-
 /*
  * Global Power Management flags
  * Used to keep APM and ACPI from both being active
diff --git a/include/linux/pm_wakeup.h b/include/linux/pm_wakeup.h
new file mode 100644
index 000000000000..f0d0b2cb8d20
--- /dev/null
+++ b/include/linux/pm_wakeup.h
@@ -0,0 +1,90 @@
+/*
+ *  pm_wakeup.h - Power management wakeup interface
+ *
+ *  Copyright (C) 2008 Alan Stern
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _LINUX_PM_WAKEUP_H
+#define _LINUX_PM_WAKEUP_H
+
+#ifndef _DEVICE_H_
+# error "please don't include this file directly"
+#endif
+
+#ifdef CONFIG_PM
+
+/* changes to device_may_wakeup take effect on the next pm state change.
+ * by default, devices should wakeup if they can.
+ */
+static inline void device_init_wakeup(struct device *dev, int val)
+{
+	dev-&gt;power.can_wakeup = dev-&gt;power.should_wakeup = !!val;
+}
+
+static inline int device_can_wakeup(struct device *dev)
+{
+	return dev-&gt;power.can_wakeup;
+}
+
+static inline void device_set_wakeup_enable(struct device *dev, int val)
+{
+	dev-&gt;power.should_wakeup = !!val;
+}
+
+static inline int device_may_wakeup(struct device *dev)
+{
+	return dev-&gt;power.can_wakeup &amp; dev-&gt;power.should_wakeup;
+}
+
+/*
+ * Platform hook to activate device wakeup capability, if that's not already
+ * handled by enable_irq_wake() etc.
+ * Returns zero on success, else negative errno
+ */
+extern int (*platform_enable_wakeup)(struct device *dev, int is_on);
+
+static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
+{
+	if (platform_enable_wakeup)
+		return (*platform_enable_wakeup)(dev, is_on);
+	return 0;
+}
+
+#else /* !CONFIG_PM */
+
+/* For some reason the next two routines work even without CONFIG_PM */
+static inline void device_init_wakeup(struct device *dev, int val)
+{
+	dev-&gt;power.can_wakeup = !!val;
+}
+
+static inline int device_can_wakeup(struct device *dev)
+{
+	return dev-&gt;power.can_wakeup;
+}
+
+#define device_set_wakeup_enable(dev, val)	do {} while (0)
+#define device_may_wakeup(dev)			0
+
+static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
+{
+	return 0;
+}
+
+#endif /* !CONFIG_PM */
+
+#endif /* _LINUX_PM_WAKEUP_H */</pre><hr><pre>commit d288e47c471e1090e80c62ad95882fafbf3f499d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 19 22:37:42 2008 +0100

    PM: Make wakeup flags available whenever CONFIG_PM is set
    
    The various wakeup flags and their accessor macros in struct
    dev_pm_info should be available whenever CONFIG_PM is enabled, not
    just when CONFIG_PM_SLEEP is on.  Otherwise remote wakeup won't always
    be configurable for runtime power management.  This patch (as1056b)
    fixes the oversight.
    
    David Brownell adds:
            More accurately, fixes the "regression" ... as noted sometime
            last summer, after 296699de6bdc717189a331ab6bbe90e05c94db06
            introduced CONFIG_SUSPEND.  But that didn't make the regression
            list for that kernel, ergo the delay in fixing it.
    
    [rjw: rebased]
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 93a146940b91..5630af302b2f 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -57,8 +57,6 @@ static DEFINE_MUTEX(dpm_list_mtx);
 /* 'true' if all devices have been suspended, protected by dpm_list_mtx */
 static bool all_sleeping;
 
-int (*platform_enable_wakeup)(struct device *dev, int is_on);
-
 /**
  *	device_pm_add - add a device to the list of active devices
  *	@dev:	Device to be added to the list
diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index f2ed179cd695..d11f74b038db 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -6,6 +6,8 @@
 #include &lt;linux/string.h&gt;
 #include "power.h"
 
+int (*platform_enable_wakeup)(struct device *dev, int is_on);
+
 
 /*
  *	wakeup - Report/change current wakeup option for device
diff --git a/include/linux/pm.h b/include/linux/pm.h
index e6b9f29e27d7..3342627e2bd6 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -183,9 +183,9 @@ typedef struct pm_message {
 struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned		can_wakeup:1;
+	unsigned		should_wakeup:1;
 	bool			sleeping:1;	/* Owned by the PM core */
 #ifdef	CONFIG_PM_SLEEP
-	unsigned		should_wakeup:1;
 	struct list_head	entry;
 #endif
 };
@@ -198,11 +198,6 @@ extern void device_resume(void);
 extern int device_suspend(pm_message_t state);
 extern int device_prepare_suspend(pm_message_t state);
 
-#define device_set_wakeup_enable(dev,val) \
-	((dev)-&gt;power.should_wakeup = !!(val))
-#define device_may_wakeup(dev) \
-	(device_can_wakeup(dev) &amp;&amp; (dev)-&gt;power.should_wakeup)
-
 extern void __suspend_report_result(const char *function, void *fn, int ret);
 
 #define suspend_report_result(fn, ret)					\
@@ -210,6 +205,24 @@ extern void __suspend_report_result(const char *function, void *fn, int ret);
 		__suspend_report_result(__FUNCTION__, fn, ret);		\
 	} while (0)
 
+#else /* !CONFIG_PM_SLEEP */
+
+static inline int device_suspend(pm_message_t state)
+{
+	return 0;
+}
+
+#define suspend_report_result(fn, ret) do { } while (0)
+
+#endif /* !CONFIG_PM_SLEEP */
+
+#ifdef CONFIG_PM
+
+#define device_set_wakeup_enable(dev,val) \
+	((dev)-&gt;power.should_wakeup = !!(val))
+#define device_may_wakeup(dev) \
+	(device_can_wakeup(dev) &amp;&amp; (dev)-&gt;power.should_wakeup)
+
 /*
  * Platform hook to activate device wakeup capability, if that's not already
  * handled by enable_irq_wake() etc.
@@ -224,24 +237,17 @@ static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 	return 0;
 }
 
-#else /* !CONFIG_PM_SLEEP */
-
-static inline int device_suspend(pm_message_t state)
-{
-	return 0;
-}
+#else /* !CONFIG_PM */
 
 #define device_set_wakeup_enable(dev,val)	do{}while(0)
 #define device_may_wakeup(dev)			(0)
 
-#define suspend_report_result(fn, ret) do { } while (0)
-
 static inline int call_platform_enable_wakeup(struct device *dev, int is_on)
 {
 	return 0;
 }
 
-#endif /* !CONFIG_PM_SLEEP */
+#endif /* !CONFIG_PM */
 
 /* changes to device_may_wakeup take effect on the next pm state change.
  * by default, devices should wakeup if they can.</pre><hr><pre>commit 74081f8667d73ad59961cf63be5f0e9d6a87c8a3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 19 22:35:13 2008 +0100

    PM: Fix misuse of wakeup flag accessors in serial core
    
    This patch (as1059) fixes a mistake in the way the serial core
    initializes a device's wakeup settings.  It should use the accessor
    routine instead of relying on a macro producing an lvalue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index c32c1ca75f63..a9ca03ead3e5 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2422,7 +2422,7 @@ int uart_add_one_port(struct uart_driver *drv, struct uart_port *port)
 	 */
 	tty_dev = tty_register_device(drv-&gt;tty_driver, port-&gt;line, port-&gt;dev);
 	if (likely(!IS_ERR(tty_dev))) {
-		device_can_wakeup(tty_dev) = 1;
+		device_init_wakeup(tty_dev, 1);
 		device_set_wakeup_enable(tty_dev, 0);
 	} else
 		printk(KERN_ERR "Cannot register tty device on line %d\n",</pre>
    <div class="pagination">
        <a href='2_94.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><span>[95]</span><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_96.html'>Next&gt;&gt;</a>
    <div>
</body>
