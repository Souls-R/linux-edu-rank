<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_14.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><span>[15]</span><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_16.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8eca355fa8af660557fbdd5506bde1392eee9bfe
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Oct 21 16:27:44 2009 -0700

    [SCSI] fcoe: initialize return value in fcoe_destroy
    
    When doing echo ethX &gt; /sys..../destroy I am getting
    errors when the tear down succeeds. It looks like the
    reason for this is because the rc var is not getting set
    when the destruction works. This just sets it to zero.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Robert Love &lt;robert.w.love@intel.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/fcoe/fcoe.c b/drivers/scsi/fcoe/fcoe.c
index 7c898875838f..8702c8d728dd 100644
--- a/drivers/scsi/fcoe/fcoe.c
+++ b/drivers/scsi/fcoe/fcoe.c
@@ -1631,7 +1631,7 @@ static int fcoe_destroy(const char *buffer, struct kernel_param *kp)
 {
 	struct fcoe_interface *fcoe;
 	struct net_device *netdev;
-	int rc;
+	int rc = 0;
 
 	mutex_lock(&amp;fcoe_config_mutex);
 #ifdef CONFIG_FCOE_MODULE</pre><hr><pre>commit ad63082626f99651d261ccd8698ce4e997362f7e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Sep 28 15:50:52 2009 -0500

    [SCSI] fix propogation of integrity errors
    
    When the Integrity check is done in scsi_io_completion it will
    set error to -EILSEQ. However, at this point error is no longer
    used, and blk_end_request_err has -EIO hardcoded.
    
    It looks like there was just porting mistake with this patch
    http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=3e695f89c5debb735e4ff051e9e58d8fb4e95110
    and we meant to send error upwards, so this patch changes the hard
    coded EIO to the error variable.
    
    I have only boot tested this patch.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Acked-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 5987da857103..108655230b59 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -898,7 +898,7 @@ void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)
 				scsi_print_sense("", cmd);
 			scsi_print_command(cmd);
 		}
-		if (blk_end_request_err(req, -EIO))
+		if (blk_end_request_err(req, error))
 			scsi_requeue_command(q, cmd);
 		else
 			scsi_next_command(cmd);</pre><hr><pre>commit 661134ad3765348ecd6150a92e736bf28ba40f80
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Sat Sep 5 07:35:33 2009 +0530

    [SCSI] libiscsi, bnx2i: make bound ep check common
    
    bnx2i currently has a check for if a ep is properly bound, so if
    iscsi_queuecommand/xmit_task is called while there is no ep
    we will not queue IO.
    
    be2iscsi sends IO from queuecommand/xmit_task like how bnx2i does
    and needs a similar test. This patch has us just use the suspend_bit
    test for this.
    
    When ep_poll has succeeed iscsid will call conn_bind, the LLD will
    then call iscsi_conn_bind which will clear the suspend bit.
    When ep_disconnect is called (or if there is a conn error) we set
    the suspend bit. For the ep_disconnect case I am adding a helper
    in this patch that will take the session lock to make sure
    iscsi_queuecommand/xmit_task is not running and it will set
    the suspend bit.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Jayamohan Kallickal &lt;jayamohank@serverengines.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 67b2a2b00286..8dc73c489a17 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1571,6 +1571,12 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 		goto fault;
 	}
 
+	if (test_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx)) {
+		reason = FAILURE_SESSION_IN_RECOVERY;
+		sc-&gt;result = DID_REQUEUE;
+		goto fault;
+	}
+
 	if (iscsi_check_cmdsn_window_closed(conn)) {
 		reason = FAILURE_WINDOW_CLOSED;
 		goto reject;
@@ -1810,6 +1816,33 @@ static void fail_scsi_tasks(struct iscsi_conn *conn, unsigned lun,
 	}
 }
 
+/**
+ * iscsi_suspend_queue - suspend iscsi_queuecommand
+ * @conn: iscsi conn to stop queueing IO on
+ *
+ * This grabs the session lock to make sure no one is in
+ * xmit_task/queuecommand, and then sets suspend to prevent
+ * new commands from being queued. This only needs to be called
+ * by offload drivers that need to sync a path like ep disconnect
+ * with the iscsi_queuecommand/xmit_task. To start IO again libiscsi
+ * will call iscsi_start_tx and iscsi_unblock_session when in FFP.
+ */
+void iscsi_suspend_queue(struct iscsi_conn *conn)
+{
+	spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
+}
+EXPORT_SYMBOL_GPL(iscsi_suspend_queue);
+
+/**
+ * iscsi_suspend_tx - suspend iscsi_data_xmit
+ * @conn: iscsi conn tp stop processing IO on.
+ *
+ * This function sets the suspend bit to prevent iscsi_data_xmit
+ * from sending new IO, and if work is queued on the xmit thread
+ * it will wait for it to be completed.
+ */
 void iscsi_suspend_tx(struct iscsi_conn *conn)
 {
 	struct Scsi_Host *shost = conn-&gt;session-&gt;host;
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 439c8b75cb69..887e57e3e223 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -390,6 +390,7 @@ extern void iscsi_session_failure(struct iscsi_session *session,
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
 extern void iscsi_suspend_tx(struct iscsi_conn *conn);
+extern void iscsi_suspend_queue(struct iscsi_conn *conn);
 extern void iscsi_conn_queue_work(struct iscsi_conn *conn);
 
 #define iscsi_conn_printk(prefix, _c, fmt, a...) \</pre><hr><pre>commit 4c0ba5d2593b5156327263f3ef6d7399dc0717b8
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Sat Sep 5 07:34:23 2009 +0530

    [SCSI] libiscsi: add completion function for drivers that do not need pdu processing
    
    beiscsi does not need the iscsi scsi cmd processing. It does not
    even get this info on the completion path. This adds a function
    to just update the sequencing numbers and complete a task.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Jayamohan Kallickal &lt;jayamohank@serverengines.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index a7ee4bb40708..67b2a2b00286 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -109,12 +109,9 @@ inline void iscsi_conn_queue_work(struct iscsi_conn *conn)
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_queue_work);
 
-void
-iscsi_update_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
+static void __iscsi_update_cmdsn(struct iscsi_session *session,
+				 uint32_t exp_cmdsn, uint32_t max_cmdsn)
 {
-	uint32_t max_cmdsn = be32_to_cpu(hdr-&gt;max_cmdsn);
-	uint32_t exp_cmdsn = be32_to_cpu(hdr-&gt;exp_cmdsn);
-
 	/*
 	 * standard specifies this check for when to update expected and
 	 * max sequence numbers
@@ -138,6 +135,12 @@ iscsi_update_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
 			iscsi_conn_queue_work(session-&gt;leadconn);
 	}
 }
+
+void iscsi_update_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
+{
+	__iscsi_update_cmdsn(session, be32_to_cpu(hdr-&gt;exp_cmdsn),
+			     be32_to_cpu(hdr-&gt;max_cmdsn));
+}
 EXPORT_SYMBOL_GPL(iscsi_update_cmdsn);
 
 /**
@@ -499,6 +502,31 @@ static void iscsi_complete_task(struct iscsi_task *task, int state)
 	__iscsi_put_task(task);
 }
 
+/**
+ * iscsi_complete_scsi_task - finish scsi task normally
+ * @task: iscsi task for scsi cmd
+ * @exp_cmdsn: expected cmd sn in cpu format
+ * @max_cmdsn: max cmd sn in cpu format
+ *
+ * This is used when drivers do not need or cannot perform
+ * lower level pdu processing.
+ *
+ * Called with session lock
+ */
+void iscsi_complete_scsi_task(struct iscsi_task *task,
+			      uint32_t exp_cmdsn, uint32_t max_cmdsn)
+{
+	struct iscsi_conn *conn = task-&gt;conn;
+
+	ISCSI_DBG_SESSION(conn-&gt;session, "[itt 0x%x]\n", task-&gt;itt);
+
+	conn-&gt;last_recv = jiffies;
+	__iscsi_update_cmdsn(conn-&gt;session, exp_cmdsn, max_cmdsn);
+	iscsi_complete_task(task, ISCSI_TASK_COMPLETED);
+}
+EXPORT_SYMBOL_GPL(iscsi_complete_scsi_task);
+
+
 /*
  * session lock must be held and if not called for a task that is
  * still pending or from the xmit thread, then xmit thread must
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 61afeb59a836..439c8b75cb69 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -415,6 +415,8 @@ extern struct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_task(struct iscsi_task *task);
 extern void iscsi_put_task(struct iscsi_task *task);
 extern void __iscsi_get_task(struct iscsi_task *task);
+extern void iscsi_complete_scsi_task(struct iscsi_task *task,
+				     uint32_t exp_cmdsn, uint32_t max_cmdsn);
 
 /*
  * generic helpers</pre><hr><pre>commit 70b31c152dc49ef70bd2b34ad53ccbd9bb4116d4
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Aug 20 15:11:03 2009 -0500

    [SCSI] libiscsi, iscsi_tcp: check suspend bit before each call to xmit_task
    
    If we had multiple tasks on the cmd or requeue  lists, and iscsi_tcp
    returns a error, the write_space function can still run and queue
    iscsi_data_xmit. If it was a legetimate problem and iscsi_conn_failure
    was run but we raced and iscsi_data_xmit was run first it could miss
    the suspend bit checks, and start trying to send data again and hit
    another timeout. A similar problem is present when using cxgb3i.
    
    This has libiscsi check the suspend bit before calling the xmit
    task callout, so we at least do not try sending multiple tasks
    (one could be sent).
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 1d7a8b7e8a75..a7ee4bb40708 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1280,6 +1280,9 @@ static int iscsi_xmit_task(struct iscsi_conn *conn)
 	struct iscsi_task *task = conn-&gt;task;
 	int rc;
 
+	if (test_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx))
+		return -ENODATA;
+
 	__iscsi_get_task(task);
 	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 	rc = conn-&gt;session-&gt;tt-&gt;xmit_task(task);
@@ -1329,7 +1332,7 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 	int rc = 0;
 
 	spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-	if (unlikely(conn-&gt;suspend_tx)) {
+	if (test_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx)) {
 		ISCSI_DBG_SESSION(conn-&gt;session, "Tx suspended!\n");
 		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 		return -ENODATA;
@@ -1338,7 +1341,7 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 	if (conn-&gt;task) {
 		rc = iscsi_xmit_task(conn);
 	        if (rc)
-		        goto again;
+		        goto done;
 	}
 
 	/*
@@ -1358,7 +1361,7 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		}
 		rc = iscsi_xmit_task(conn);
 		if (rc)
-			goto again;
+			goto done;
 	}
 
 	/* process pending command queue */
@@ -1379,14 +1382,14 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 				list_add_tail(&amp;conn-&gt;task-&gt;running,
 					      &amp;conn-&gt;cmdqueue);
 				conn-&gt;task = NULL;
-				goto again;
+				goto done;
 			} else
 				fail_scsi_task(conn-&gt;task, DID_ABORT);
 			continue;
 		}
 		rc = iscsi_xmit_task(conn);
 		if (rc)
-			goto again;
+			goto done;
 		/*
 		 * we could continuously get new task requests so
 		 * we need to check the mgmt queue for nops that need to
@@ -1412,16 +1415,14 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		conn-&gt;task-&gt;state = ISCSI_TASK_RUNNING;
 		rc = iscsi_xmit_task(conn);
 		if (rc)
-			goto again;
+			goto done;
 		if (!list_empty(&amp;conn-&gt;mgmtqueue))
 			goto check_mgmt;
 	}
 	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 	return -ENODATA;
 
-again:
-	if (unlikely(conn-&gt;suspend_tx))
-		rc = -ENODATA;
+done:
 	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 	return rc;
 }</pre><hr><pre>commit d1af8a328755f51c9b76157a8692e56520d3fd94
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Aug 20 15:11:02 2009 -0500

    [SCSI] iscsi_tcp: add new conn error to indicate tcp conn closed
    
    If a target closed the connection, we will detect it in the
    state_changed or data_ready callout. This adds a new conn
    error value to use for this problem, so it is not confused
    with when the initiator throws a conn error and drops
    the connection.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index c7e2ff24ee9e..2b1b834a098b 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -109,11 +109,14 @@ static int iscsi_sw_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
  */
 static inline int iscsi_sw_sk_state_check(struct sock *sk)
 {
-	if ((sk-&gt;sk_state == TCP_CLOSE_WAIT ||
-	     sk-&gt;sk_state == TCP_CLOSE) &amp;&amp;
-	    !atomic_read(&amp;sk-&gt;sk_rmem_alloc))
-		return -ECONNRESET;
+	struct iscsi_conn *conn = (struct iscsi_conn*)sk-&gt;sk_user_data;
 
+	if ((sk-&gt;sk_state == TCP_CLOSE_WAIT || sk-&gt;sk_state == TCP_CLOSE) &amp;&amp;
+	    !atomic_read(&amp;sk-&gt;sk_rmem_alloc)) {
+		ISCSI_SW_TCP_DBG(conn, "TCP_CLOSE|TCP_CLOSE_WAIT\n");
+		iscsi_conn_failure(conn, ISCSI_ERR_TCP_CONN_CLOSE);
+		return -ECONNRESET;
+	}
 	return 0;
 }
 
@@ -135,11 +138,7 @@ static void iscsi_sw_tcp_data_ready(struct sock *sk, int flag)
 	rd_desc.count = 1;
 	tcp_read_sock(sk, &amp;rd_desc, iscsi_sw_tcp_recv);
 
-	if (iscsi_sw_sk_state_check(sk) &lt; 0) {
-		ISCSI_SW_TCP_DBG(conn, "iscsi_tcp_data_ready: "
-				 "TCP_CLOSE|TCP_CLOSE_WAIT\n");
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-	}
+	iscsi_sw_sk_state_check(sk);
 
 	read_unlock(&amp;sk-&gt;sk_callback_lock);
 
@@ -161,11 +160,7 @@ static void iscsi_sw_tcp_state_change(struct sock *sk)
 	conn = (struct iscsi_conn*)sk-&gt;sk_user_data;
 	session = conn-&gt;session;
 
-	if (iscsi_sw_sk_state_check(sk) &lt; 0) {
-		ISCSI_SW_TCP_DBG(conn, "iscsi_tcp_state_change: "
-				 "TCP_CLOSE|TCP_CLOSE_WAIT\n");
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-	}
+	iscsi_sw_sk_state_check(sk);
 
 	tcp_conn = conn-&gt;dd_data;
 	tcp_sw_conn = tcp_conn-&gt;dd_data;
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 4426f00da5ff..d67dda2b6aa0 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -262,6 +262,7 @@ enum iscsi_err {
 	ISCSI_ERR_NO_SCSI_CMD		= ISCSI_ERR_BASE + 17,
 	ISCSI_ERR_INVALID_HOST		= ISCSI_ERR_BASE + 18,
 	ISCSI_ERR_XMIT_FAILED		= ISCSI_ERR_BASE + 19,
+	ISCSI_ERR_TCP_CONN_CLOSE	= ISCSI_ERR_BASE + 20,
 };
 
 /*</pre><hr><pre>commit 632248aab3170004e24512a4378fc6d9d7f3b4ac
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Aug 20 15:11:01 2009 -0500

    [SCSI] iscsi class: Add logging to scsi_transport_iscsi.c
    
    Logging for connections and sessions in the scsi_transport_iscsi module
    is now controlled by module parameters.
    
    Signed-off-by: Erez Zilber &lt;erezzi.list@gmail.com&gt;
    [Mike Christie: newline fixups and modification of some dbg statements]
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index b47240ca4b19..ad897df36615 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -36,6 +36,38 @@
 
 #define ISCSI_TRANSPORT_VERSION "2.0-870"
 
+static int dbg_session;
+module_param_named(debug_session, dbg_session, int,
+		   S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug_session,
+		 "Turn on debugging for sessions in scsi_transport_iscsi "
+		 "module. Set to 1 to turn on, and zero to turn off. Default "
+		 "is off.");
+
+static int dbg_conn;
+module_param_named(debug_conn, dbg_conn, int,
+		   S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug_conn,
+		 "Turn on debugging for connections in scsi_transport_iscsi "
+		 "module. Set to 1 to turn on, and zero to turn off. Default "
+		 "is off.");
+
+#define ISCSI_DBG_TRANS_SESSION(_session, dbg_fmt, arg...)		\
+	do {								\
+		if (dbg_session)					\
+			iscsi_cls_session_printk(KERN_INFO, _session,	\
+						 "%s: " dbg_fmt,	\
+						 __func__, ##arg);	\
+	} while (0);
+
+#define ISCSI_DBG_TRANS_CONN(_conn, dbg_fmt, arg...)			\
+	do {								\
+		if (dbg_conn)						\
+			iscsi_cls_conn_printk(KERN_INFO, _conn,		\
+					      "%s: " dbg_fmt,		\
+					      __func__, ##arg);	\
+	} while (0);
+
 struct iscsi_internal {
 	struct scsi_transport_template t;
 	struct iscsi_transport *iscsi_transport;
@@ -377,6 +409,7 @@ static void iscsi_session_release(struct device *dev)
 
 	shost = iscsi_session_to_shost(session);
 	scsi_host_put(shost);
+	ISCSI_DBG_TRANS_SESSION(session, "Completing session release\n");
 	kfree(session);
 }
 
@@ -441,6 +474,9 @@ static int iscsi_user_scan_session(struct device *dev, void *data)
 		return 0;
 
 	session = iscsi_dev_to_session(dev);
+
+	ISCSI_DBG_TRANS_SESSION(session, "Scanning session\n");
+
 	shost = iscsi_session_to_shost(session);
 	ihost = shost-&gt;shost_data;
 
@@ -448,8 +484,7 @@ static int iscsi_user_scan_session(struct device *dev, void *data)
 	spin_lock_irqsave(&amp;session-&gt;lock, flags);
 	if (session-&gt;state != ISCSI_SESSION_LOGGED_IN) {
 		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
-		mutex_unlock(&amp;ihost-&gt;mutex);
-		return 0;
+		goto user_scan_exit;
 	}
 	id = session-&gt;target_id;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
@@ -462,7 +497,10 @@ static int iscsi_user_scan_session(struct device *dev, void *data)
 			scsi_scan_target(&amp;session-&gt;dev, 0, id,
 					 scan_data-&gt;lun, 1);
 	}
+
+user_scan_exit:
 	mutex_unlock(&amp;ihost-&gt;mutex);
+	ISCSI_DBG_TRANS_SESSION(session, "Completed session scan\n");
 	return 0;
 }
 
@@ -522,7 +560,9 @@ static void session_recovery_timedout(struct work_struct *work)
 	if (session-&gt;transport-&gt;session_recovery_timedout)
 		session-&gt;transport-&gt;session_recovery_timedout(session);
 
+	ISCSI_DBG_TRANS_SESSION(session, "Unblocking SCSI target\n");
 	scsi_target_unblock(&amp;session-&gt;dev);
+	ISCSI_DBG_TRANS_SESSION(session, "Completed unblocking SCSI target\n");
 }
 
 static void __iscsi_unblock_session(struct work_struct *work)
@@ -534,6 +574,7 @@ static void __iscsi_unblock_session(struct work_struct *work)
 	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
 	unsigned long flags;
 
+	ISCSI_DBG_TRANS_SESSION(session, "Unblocking session\n");
 	/*
 	 * The recovery and unblock work get run from the same workqueue,
 	 * so try to cancel it if it was going to run after this unblock.
@@ -553,6 +594,7 @@ static void __iscsi_unblock_session(struct work_struct *work)
 		if (scsi_queue_work(shost, &amp;session-&gt;scan_work))
 			atomic_inc(&amp;ihost-&gt;nr_scans);
 	}
+	ISCSI_DBG_TRANS_SESSION(session, "Completed unblocking session\n");
 }
 
 /**
@@ -579,10 +621,12 @@ static void __iscsi_block_session(struct work_struct *work)
 				     block_work);
 	unsigned long flags;
 
+	ISCSI_DBG_TRANS_SESSION(session, "Blocking session\n");
 	spin_lock_irqsave(&amp;session-&gt;lock, flags);
 	session-&gt;state = ISCSI_SESSION_FAILED;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	scsi_target_block(&amp;session-&gt;dev);
+	ISCSI_DBG_TRANS_SESSION(session, "Completed SCSI target blocking\n");
 	queue_delayed_work(iscsi_eh_timer_workq, &amp;session-&gt;recovery_work,
 			   session-&gt;recovery_tmo * HZ);
 }
@@ -602,6 +646,8 @@ static void __iscsi_unbind_session(struct work_struct *work)
 	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
 	unsigned long flags;
 
+	ISCSI_DBG_TRANS_SESSION(session, "Unbinding session\n");
+
 	/* Prevent new scans and make sure scanning is not in progress */
 	mutex_lock(&amp;ihost-&gt;mutex);
 	spin_lock_irqsave(&amp;session-&gt;lock, flags);
@@ -616,6 +662,7 @@ static void __iscsi_unbind_session(struct work_struct *work)
 
 	scsi_remove_target(&amp;session-&gt;dev);
 	iscsi_session_event(session, ISCSI_KEVENT_UNBIND_SESSION);
+	ISCSI_DBG_TRANS_SESSION(session, "Completed target removal\n");
 }
 
 struct iscsi_cls_session *
@@ -647,6 +694,8 @@ iscsi_alloc_session(struct Scsi_Host *shost, struct iscsi_transport *transport,
 	device_initialize(&amp;session-&gt;dev);
 	if (dd_size)
 		session-&gt;dd_data = &amp;session[1];
+
+	ISCSI_DBG_TRANS_SESSION(session, "Completed session allocation\n");
 	return session;
 }
 EXPORT_SYMBOL_GPL(iscsi_alloc_session);
@@ -712,6 +761,7 @@ int iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)
 	spin_unlock_irqrestore(&amp;sesslock, flags);
 
 	iscsi_session_event(session, ISCSI_KEVENT_CREATE_SESSION);
+	ISCSI_DBG_TRANS_SESSION(session, "Completed session adding\n");
 	return 0;
 
 release_host:
@@ -752,6 +802,7 @@ static void iscsi_conn_release(struct device *dev)
 	struct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev);
 	struct device *parent = conn-&gt;dev.parent;
 
+	ISCSI_DBG_TRANS_CONN(conn, "Releasing conn\n");
 	kfree(conn);
 	put_device(parent);
 }
@@ -774,6 +825,8 @@ void iscsi_remove_session(struct iscsi_cls_session *session)
 	unsigned long flags;
 	int err;
 
+	ISCSI_DBG_TRANS_SESSION(session, "Removing session\n");
+
 	spin_lock_irqsave(&amp;sesslock, flags);
 	list_del(&amp;session-&gt;sess_list);
 	spin_unlock_irqrestore(&amp;sesslock, flags);
@@ -807,12 +860,15 @@ void iscsi_remove_session(struct iscsi_cls_session *session)
 					 "for session. Error %d.\n", err);
 
 	transport_unregister_device(&amp;session-&gt;dev);
+
+	ISCSI_DBG_TRANS_SESSION(session, "Completing session removal\n");
 	device_del(&amp;session-&gt;dev);
 }
 EXPORT_SYMBOL_GPL(iscsi_remove_session);
 
 void iscsi_free_session(struct iscsi_cls_session *session)
 {
+	ISCSI_DBG_TRANS_SESSION(session, "Freeing session\n");
 	iscsi_session_event(session, ISCSI_KEVENT_DESTROY_SESSION);
 	put_device(&amp;session-&gt;dev);
 }
@@ -828,6 +884,7 @@ EXPORT_SYMBOL_GPL(iscsi_free_session);
 int iscsi_destroy_session(struct iscsi_cls_session *session)
 {
 	iscsi_remove_session(session);
+	ISCSI_DBG_TRANS_SESSION(session, "Completing session destruction\n");
 	iscsi_free_session(session);
 	return 0;
 }
@@ -885,6 +942,8 @@ iscsi_create_conn(struct iscsi_cls_session *session, int dd_size, uint32_t cid)
 	list_add(&amp;conn-&gt;conn_list, &amp;connlist);
 	conn-&gt;active = 1;
 	spin_unlock_irqrestore(&amp;connlock, flags);
+
+	ISCSI_DBG_TRANS_CONN(conn, "Completed conn creation\n");
 	return conn;
 
 release_parent_ref:
@@ -912,6 +971,7 @@ int iscsi_destroy_conn(struct iscsi_cls_conn *conn)
 	spin_unlock_irqrestore(&amp;connlock, flags);
 
 	transport_unregister_device(&amp;conn-&gt;dev);
+	ISCSI_DBG_TRANS_CONN(conn, "Completing conn destruction\n");
 	device_unregister(&amp;conn-&gt;dev);
 	return 0;
 }
@@ -1200,6 +1260,9 @@ int iscsi_session_event(struct iscsi_cls_session *session,
 					 "Cannot notify userspace of session "
 					 "event %u. Check iscsi daemon\n",
 					 event);
+
+	ISCSI_DBG_TRANS_SESSION(session, "Completed handling event %d rc %d\n",
+				event, rc);
 	return rc;
 }
 EXPORT_SYMBOL_GPL(iscsi_session_event);
@@ -1221,6 +1284,8 @@ iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_endpoint *ep,
 	shost = iscsi_session_to_shost(session);
 	ev-&gt;r.c_session_ret.host_no = shost-&gt;host_no;
 	ev-&gt;r.c_session_ret.sid = session-&gt;sid;
+	ISCSI_DBG_TRANS_SESSION(session,
+				"Completed creating transport session\n");
 	return 0;
 }
 
@@ -1246,6 +1311,8 @@ iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 
 	ev-&gt;r.c_conn_ret.sid = session-&gt;sid;
 	ev-&gt;r.c_conn_ret.cid = conn-&gt;cid;
+
+	ISCSI_DBG_TRANS_CONN(conn, "Completed creating transport conn\n");
 	return 0;
 }
 
@@ -1258,8 +1325,10 @@ iscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev
 	if (!conn)
 		return -EINVAL;
 
+	ISCSI_DBG_TRANS_CONN(conn, "Destroying transport conn\n");
 	if (transport-&gt;destroy_conn)
 		transport-&gt;destroy_conn(conn);
+
 	return 0;
 }
 </pre><hr><pre>commit b06fc73a9ebd352065dd4dd3139fb53ed72ac970
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Aug 20 15:11:00 2009 -0500

    [SCSI] qla4xxx: Removed residual from overrun debug print
    
    The residual variable is only valid for udnerrun so do
    not print it out for the overrun case.
    
    Signed-off-by: Karen Higgins &lt;karen.higgins@qlogic.com&gt;
    [Mike Christie: Fix coding style issues in patch]
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_isr.c b/drivers/scsi/qla4xxx/ql4_isr.c
index 8025ee16588e..c196d55eae39 100644
--- a/drivers/scsi/qla4xxx/ql4_isr.c
+++ b/drivers/scsi/qla4xxx/ql4_isr.c
@@ -227,11 +227,11 @@ static void qla4xxx_status_entry(struct scsi_qla_host *ha,
 	case SCS_DATA_UNDERRUN:
 	case SCS_DATA_OVERRUN:
 		if ((sts_entry-&gt;iscsiFlags &amp; ISCSI_FLAG_RESIDUAL_OVER) ||
-			(sts_entry-&gt;completionStatus == SCS_DATA_OVERRUN)) {
-			DEBUG2(printk("scsi%ld:%d:%d:%d: %s: " "Data overrun, "
-				      "residual = 0x%x\n", ha-&gt;host_no,
+		     (sts_entry-&gt;completionStatus == SCS_DATA_OVERRUN)) {
+			DEBUG2(printk("scsi%ld:%d:%d:%d: %s: " "Data overrun\n",
+				      ha-&gt;host_no,
 				      cmd-&gt;device-&gt;channel, cmd-&gt;device-&gt;id,
-				      cmd-&gt;device-&gt;lun, __func__, residual));
+				      cmd-&gt;device-&gt;lun, __func__));
 
 			cmd-&gt;result = DID_ERROR &lt;&lt; 16;
 			break;</pre><hr><pre>commit 8afa1439fcff58da8f28c1d083046f229f6ab3de
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Aug 20 15:10:59 2009 -0500

    [SCSI] libiscsi: handle immediate command rejections
    
    If we sent multiple pdus as immediate the target could be
    rejecting some and we have just been dropping the rejection
    notification. This adds code to handle nop-out rejections,
    so if a nop-out was sent as a ping and rejected we do not
    mark the connection bad. Instead we just clean up the timers
    since we have pdu making a rount trip we know the connection
    is good.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index c68cb53a984b..1d7a8b7e8a75 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -857,27 +857,102 @@ static void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)
 	}
 }
 
+static int iscsi_nop_out_rsp(struct iscsi_task *task,
+			     struct iscsi_nopin *nop, char *data, int datalen)
+{
+	struct iscsi_conn *conn = task-&gt;conn;
+	int rc = 0;
+
+	if (conn-&gt;ping_task != task) {
+		/*
+		 * If this is not in response to one of our
+		 * nops then it must be from userspace.
+		 */
+		if (iscsi_recv_pdu(conn-&gt;cls_conn, (struct iscsi_hdr *)nop,
+				   data, datalen))
+			rc = ISCSI_ERR_CONN_FAILED;
+	} else
+		mod_timer(&amp;conn-&gt;transport_timer, jiffies + conn-&gt;recv_timeout);
+	iscsi_complete_task(task, ISCSI_TASK_COMPLETED);
+	return rc;
+}
+
 static int iscsi_handle_reject(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 			       char *data, int datalen)
 {
 	struct iscsi_reject *reject = (struct iscsi_reject *)hdr;
 	struct iscsi_hdr rejected_pdu;
+	int opcode, rc = 0;
 
 	conn-&gt;exp_statsn = be32_to_cpu(reject-&gt;statsn) + 1;
 
-	if (reject-&gt;reason == ISCSI_REASON_DATA_DIGEST_ERROR) {
-		if (ntoh24(reject-&gt;dlength) &gt; datalen)
-			return ISCSI_ERR_PROTO;
+	if (ntoh24(reject-&gt;dlength) &gt; datalen ||
+	    ntoh24(reject-&gt;dlength) &lt; sizeof(struct iscsi_hdr)) {
+		iscsi_conn_printk(KERN_ERR, conn, "Cannot handle rejected "
+				  "pdu. Invalid data length (pdu dlength "
+				  "%u, datalen %d\n", ntoh24(reject-&gt;dlength),
+				  datalen);
+		return ISCSI_ERR_PROTO;
+	}
+	memcpy(&amp;rejected_pdu, data, sizeof(struct iscsi_hdr));
+	opcode = rejected_pdu.opcode &amp; ISCSI_OPCODE_MASK;
 
-		if (ntoh24(reject-&gt;dlength) &gt;= sizeof(struct iscsi_hdr)) {
-			memcpy(&amp;rejected_pdu, data, sizeof(struct iscsi_hdr));
-			iscsi_conn_printk(KERN_ERR, conn,
-					  "pdu (op 0x%x) rejected "
-					  "due to DataDigest error.\n",
-					  rejected_pdu.opcode);
+	switch (reject-&gt;reason) {
+	case ISCSI_REASON_DATA_DIGEST_ERROR:
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "pdu (op 0x%x itt 0x%x) rejected "
+				  "due to DataDigest error.\n",
+				  rejected_pdu.itt, opcode);
+		break;
+	case ISCSI_REASON_IMM_CMD_REJECT:
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "pdu (op 0x%x itt 0x%x) rejected. Too many "
+				  "immediate commands.\n",
+				  rejected_pdu.itt, opcode);
+		/*
+		 * We only send one TMF at a time so if the target could not
+		 * handle it, then it should get fixed (RFC mandates that
+		 * a target can handle one immediate TMF per conn).
+		 *
+		 * For nops-outs, we could have sent more than one if
+		 * the target is sending us lots of nop-ins
+		 */
+		if (opcode != ISCSI_OP_NOOP_OUT)
+			return 0;
+
+		 if (rejected_pdu.itt == cpu_to_be32(ISCSI_RESERVED_TAG))
+			/*
+			 * nop-out in response to target's nop-out rejected.
+			 * Just resend.
+			 */
+			iscsi_send_nopout(conn,
+					  (struct iscsi_nopin*)&amp;rejected_pdu);
+		else {
+			struct iscsi_task *task;
+			/*
+			 * Our nop as ping got dropped. We know the target
+			 * and transport are ok so just clean up
+			 */
+			task = iscsi_itt_to_task(conn, rejected_pdu.itt);
+			if (!task) {
+				iscsi_conn_printk(KERN_ERR, conn,
+						 "Invalid pdu reject. Could "
+						 "not lookup rejected task.\n");
+				rc = ISCSI_ERR_BAD_ITT;
+			} else
+				rc = iscsi_nop_out_rsp(task,
+					(struct iscsi_nopin*)&amp;rejected_pdu,
+					NULL, 0);
 		}
+		break;
+	default:
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "pdu (op 0x%x itt 0x%x) rejected. Reason "
+				  "code 0x%x\n", rejected_pdu.itt,
+				  rejected_pdu.opcode, reject-&gt;reason);
+		break;
 	}
-	return 0;
+	return rc;
 }
 
 /**
@@ -1038,15 +1113,8 @@ int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		}
 		conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
 
-		if (conn-&gt;ping_task != task)
-			/*
-			 * If this is not in response to one of our
-			 * nops then it must be from userspace.
-			 */
-			goto recv_pdu;
-
-		mod_timer(&amp;conn-&gt;transport_timer, jiffies + conn-&gt;recv_timeout);
-		iscsi_complete_task(task, ISCSI_TASK_COMPLETED);
+		rc = iscsi_nop_out_rsp(task, (struct iscsi_nopin*)hdr,
+				       data, datalen);
 		break;
 	default:
 		rc = ISCSI_ERR_BAD_OPCODE;</pre><hr><pre>commit d3305f3407fa3e9452079ec6cc8379067456e4aa
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Aug 20 15:10:58 2009 -0500

    [SCSI] libiscsi: don't increment cmdsn if cmd is not sent
    
    We increment session-&gt;cmdsn at the top of iscsi_prep_scsi_cmd_pdu, but
    if the prep  ecb or prep bidi or init_task calls fails then we leave the
    session-&gt;cmdsn incremented. This moves the cmdsn manipulation to the end
    of the function when we know it has succeeded.
    
    It also adds a session-&gt;cmdsn--; in queuecommand for if a driver like
    bnx2i tries to send a a task from that context but it fails. We do not
    have to do this in the xmit thread context because that code will retry
    the same task if the initial call fails.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index a751f6230c22..c68cb53a984b 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -301,8 +301,6 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	hdr-&gt;flags = ISCSI_ATTR_SIMPLE;
 	int_to_scsilun(sc-&gt;device-&gt;lun, (struct scsi_lun *)hdr-&gt;lun);
 	memcpy(task-&gt;lun, hdr-&gt;lun, sizeof(task-&gt;lun));
-	hdr-&gt;cmdsn = task-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
-	session-&gt;cmdsn++;
 	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
 	cmd_len = sc-&gt;cmd_len;
 	if (cmd_len &lt; ISCSI_CDB_SIZE)
@@ -388,6 +386,8 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 		return -EIO;
 
 	task-&gt;state = ISCSI_TASK_RUNNING;
+	hdr-&gt;cmdsn = task-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+	session-&gt;cmdsn++;
 
 	conn-&gt;scsicmd_pdus_cnt++;
 	ISCSI_DBG_SESSION(session, "iscsi prep [%s cid %d sc %p cdb 0x%x "
@@ -1497,6 +1497,7 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 			}
 		}
 		if (session-&gt;tt-&gt;xmit_task(task)) {
+			session-&gt;cmdsn--;
 			reason = FAILURE_SESSION_NOT_READY;
 			goto prepd_reject;
 		}</pre>
    <div class="pagination">
        <a href='5_14.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><span>[15]</span><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_16.html'>Next&gt;&gt;</a>
    <div>
</body>
