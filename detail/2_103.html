<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_102.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><span>[103]</span><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_104.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 18ea5d00d05fa6300606f0711748016c95fb26dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:10:36 2007 -0400

    USB: avoid urb-&gt;pipe in usbmon
    
    This patch (as949) changes the usbmon driver to use the new urb-&gt;ep
    field rather than urb-&gt;pipe.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index c03dfd7a9d36..0b0d77c669da 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -354,7 +354,7 @@ static inline char mon_bin_get_setup(unsigned char *setupb,
     const struct urb *urb, char ev_type)
 {
 
-	if (!usb_pipecontrol(urb-&gt;pipe) || ev_type != 'S')
+	if (!usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc) || ev_type != 'S')
 		return '-';
 
 	if (urb-&gt;dev-&gt;bus-&gt;uses_dma &amp;&amp;
@@ -410,7 +410,7 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	if (length &gt;= rp-&gt;b_size/5)
 		length = rp-&gt;b_size/5;
 
-	if (usb_pipein(urb-&gt;pipe)) {
+	if (usb_urb_dir_in(urb)) {
 		if (ev_type == 'S') {
 			length = 0;
 			data_tag = '&lt;';
@@ -440,10 +440,22 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	 */
 	memset(ep, 0, PKT_SIZE);
 	ep-&gt;type = ev_type;
-	ep-&gt;xfer_type = usb_pipetype(urb-&gt;pipe);
-	/* We use the fact that usb_pipein() returns 0x80 */
-	ep-&gt;epnum = usb_pipeendpoint(urb-&gt;pipe) | usb_pipein(urb-&gt;pipe);
-	ep-&gt;devnum = usb_pipedevice(urb-&gt;pipe);
+	switch (usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc)) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		ep-&gt;xfer_type = PIPE_CONTROL;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		ep-&gt;xfer_type = PIPE_BULK;
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		ep-&gt;xfer_type = PIPE_INTERRUPT;
+		break;
+	default:
+		ep-&gt;xfer_type = PIPE_ISOCHRONOUS;
+		break;
+	}
+	ep-&gt;epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
 	ep-&gt;busnum = urb-&gt;dev-&gt;bus-&gt;busnum;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;ts_sec = ts.tv_sec;
@@ -500,10 +512,22 @@ static void mon_bin_error(void *data, struct urb *urb, int error)
 
 	memset(ep, 0, PKT_SIZE);
 	ep-&gt;type = 'E';
-	ep-&gt;xfer_type = usb_pipetype(urb-&gt;pipe);
-	/* We use the fact that usb_pipein() returns 0x80 */
-	ep-&gt;epnum = usb_pipeendpoint(urb-&gt;pipe) | usb_pipein(urb-&gt;pipe);
-	ep-&gt;devnum = usb_pipedevice(urb-&gt;pipe);
+	switch (usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc)) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		ep-&gt;xfer_type = PIPE_CONTROL;
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+		ep-&gt;xfer_type = PIPE_BULK;
+		break;
+	case USB_ENDPOINT_XFER_INT:
+		ep-&gt;xfer_type = PIPE_INTERRUPT;
+		break;
+	default:
+		ep-&gt;xfer_type = PIPE_ISOCHRONOUS;
+		break;
+	}
+	ep-&gt;epnum = urb-&gt;ep-&gt;desc.bEndpointAddress;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
 	ep-&gt;busnum = urb-&gt;dev-&gt;bus-&gt;busnum;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;status = error;
diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index ce61d8b0fd86..e58f761d060f 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -154,8 +154,8 @@ static void mon_complete(struct usb_bus *ubus, struct urb *urb)
 		 * This should not happen.
 		 * At this point we do not even know the bus number...
 		 */
-		printk(KERN_ERR TAG ": Null mon bus in URB, pipe 0x%x\n",
-		    urb-&gt;pipe);
+		printk(KERN_ERR TAG ": Null mon bus in URB, address %p\n",
+		    urb);
 		return;
 	}
 
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 8f27a9e1c36b..9d0070ceef52 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -50,10 +50,12 @@ struct mon_iso_desc {
 struct mon_event_text {
 	struct list_head e_link;
 	int type;		/* submit, complete, etc. */
-	unsigned int pipe;	/* Pipe */
 	unsigned long id;	/* From pointer, most of the time */
 	unsigned int tstamp;
+	int xfertype;
 	int busnum;
+	int devnum;
+	int epnum;
 	int length;		/* Depends on type: xfer length or act length */
 	int status;
 	int interval;
@@ -61,6 +63,7 @@ struct mon_event_text {
 	int error_count;
 	char setup_flag;
 	char data_flag;
+	char is_in;
 	int numdesc;		/* Full number */
 	struct mon_iso_desc isodesc[ISODESC_MAX];
 	unsigned char setup[SETUP_MAX];
@@ -121,7 +124,7 @@ static inline char mon_text_get_setup(struct mon_event_text *ep,
     struct urb *urb, char ev_type, struct mon_bus *mbus)
 {
 
-	if (!usb_pipecontrol(urb-&gt;pipe) || ev_type != 'S')
+	if (ep-&gt;xfertype != USB_ENDPOINT_XFER_CONTROL || ev_type != 'S')
 		return '-';
 
 	if (urb-&gt;dev-&gt;bus-&gt;uses_dma &amp;&amp;
@@ -138,14 +141,12 @@ static inline char mon_text_get_setup(struct mon_event_text *ep,
 static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
     int len, char ev_type, struct mon_bus *mbus)
 {
-	int pipe = urb-&gt;pipe;
-
 	if (len &lt;= 0)
 		return 'L';
 	if (len &gt;= DATA_MAX)
 		len = DATA_MAX;
 
-	if (usb_pipein(pipe)) {
+	if (ep-&gt;is_in) {
 		if (ev_type != 'C')
 			return '&lt;';
 	} else {
@@ -203,24 +204,28 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 	}
 
 	ep-&gt;type = ev_type;
-	ep-&gt;pipe = urb-&gt;pipe;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;busnum = urb-&gt;dev-&gt;bus-&gt;busnum;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
+	ep-&gt;epnum = usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;xfertype = usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;is_in = usb_urb_dir_in(urb);
 	ep-&gt;tstamp = stamp;
 	ep-&gt;length = (ev_type == 'S') ?
 	    urb-&gt;transfer_buffer_length : urb-&gt;actual_length;
 	/* Collecting status makes debugging sense for submits, too */
 	ep-&gt;status = urb-&gt;status;
 
-	if (usb_pipeint(urb-&gt;pipe)) {
+	if (ep-&gt;xfertype == USB_ENDPOINT_XFER_INT) {
 		ep-&gt;interval = urb-&gt;interval;
-	} else if (usb_pipeisoc(urb-&gt;pipe)) {
+	} else if (ep-&gt;xfertype == USB_ENDPOINT_XFER_ISOC) {
 		ep-&gt;interval = urb-&gt;interval;
 		ep-&gt;start_frame = urb-&gt;start_frame;
 		ep-&gt;error_count = urb-&gt;error_count;
 	}
 	ep-&gt;numdesc = urb-&gt;number_of_packets;
-	if (usb_pipeisoc(urb-&gt;pipe) &amp;&amp; urb-&gt;number_of_packets &gt; 0) {
+	if (ep-&gt;xfertype == USB_ENDPOINT_XFER_ISOC &amp;&amp;
+			urb-&gt;number_of_packets &gt; 0) {
 		if ((ndesc = urb-&gt;number_of_packets) &gt; ISODESC_MAX)
 			ndesc = ISODESC_MAX;
 		fp = urb-&gt;iso_frame_desc;
@@ -268,9 +273,12 @@ static void mon_text_error(void *data, struct urb *urb, int error)
 	}
 
 	ep-&gt;type = 'E';
-	ep-&gt;pipe = urb-&gt;pipe;
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;busnum = 0;
+	ep-&gt;devnum = urb-&gt;dev-&gt;devnum;
+	ep-&gt;epnum = usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;xfertype = usb_endpoint_type(&amp;urb-&gt;ep-&gt;desc);
+	ep-&gt;is_in = usb_urb_dir_in(urb);
 	ep-&gt;tstamp = 0;
 	ep-&gt;length = 0;
 	ep-&gt;status = error;
@@ -413,10 +421,10 @@ static ssize_t mon_text_read_u(struct file *file, char __user *buf,
 	mon_text_read_head_u(rp, &amp;ptr, ep);
 	if (ep-&gt;type == 'E') {
 		mon_text_read_statset(rp, &amp;ptr, ep);
-	} else if (usb_pipeisoc(ep-&gt;pipe)) {
+	} else if (ep-&gt;xfertype == USB_ENDPOINT_XFER_ISOC) {
 		mon_text_read_isostat(rp, &amp;ptr, ep);
 		mon_text_read_isodesc(rp, &amp;ptr, ep);
-	} else if (usb_pipeint(ep-&gt;pipe)) {
+	} else if (ep-&gt;xfertype == USB_ENDPOINT_XFER_INT) {
 		mon_text_read_intstat(rp, &amp;ptr, ep);
 	} else {
 		mon_text_read_statset(rp, &amp;ptr, ep);
@@ -468,18 +476,17 @@ static void mon_text_read_head_t(struct mon_reader_text *rp,
 {
 	char udir, utype;
 
-	udir = usb_pipein(ep-&gt;pipe) ? 'i' : 'o';
-	switch (usb_pipetype(ep-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS:	utype = 'Z'; break;
-	case PIPE_INTERRUPT:	utype = 'I'; break;
-	case PIPE_CONTROL:	utype = 'C'; break;
+	udir = (ep-&gt;is_in ? 'i' : 'o');
+	switch (ep-&gt;xfertype) {
+	case USB_ENDPOINT_XFER_ISOC:	utype = 'Z'; break;
+	case USB_ENDPOINT_XFER_INT:	utype = 'I'; break;
+	case USB_ENDPOINT_XFER_CONTROL:	utype = 'C'; break;
 	default: /* PIPE_BULK */  utype = 'B';
 	}
 	p-&gt;cnt += snprintf(p-&gt;pbuf + p-&gt;cnt, p-&gt;limit - p-&gt;cnt,
 	    "%lx %u %c %c%c:%03u:%02u",
 	    ep-&gt;id, ep-&gt;tstamp, ep-&gt;type,
-	    utype, udir,
-	    usb_pipedevice(ep-&gt;pipe), usb_pipeendpoint(ep-&gt;pipe));
+	    utype, udir, ep-&gt;devnum, ep-&gt;epnum);
 }
 
 static void mon_text_read_head_u(struct mon_reader_text *rp,
@@ -487,18 +494,17 @@ static void mon_text_read_head_u(struct mon_reader_text *rp,
 {
 	char udir, utype;
 
-	udir = usb_pipein(ep-&gt;pipe) ? 'i' : 'o';
-	switch (usb_pipetype(ep-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS:	utype = 'Z'; break;
-	case PIPE_INTERRUPT:	utype = 'I'; break;
-	case PIPE_CONTROL:	utype = 'C'; break;
+	udir = (ep-&gt;is_in ? 'i' : 'o');
+	switch (ep-&gt;xfertype) {
+	case USB_ENDPOINT_XFER_ISOC:	utype = 'Z'; break;
+	case USB_ENDPOINT_XFER_INT:	utype = 'I'; break;
+	case USB_ENDPOINT_XFER_CONTROL:	utype = 'C'; break;
 	default: /* PIPE_BULK */  utype = 'B';
 	}
 	p-&gt;cnt += snprintf(p-&gt;pbuf + p-&gt;cnt, p-&gt;limit - p-&gt;cnt,
 	    "%lx %u %c %c%c:%d:%03u:%u",
 	    ep-&gt;id, ep-&gt;tstamp, ep-&gt;type,
-	    utype, udir,
-	    ep-&gt;busnum, usb_pipedevice(ep-&gt;pipe), usb_pipeendpoint(ep-&gt;pipe));
+	    utype, udir, ep-&gt;busnum, ep-&gt;devnum, ep-&gt;epnum);
 }
 
 static void mon_text_read_statset(struct mon_reader_text *rp,</pre><hr><pre>commit 93cf9b909efb773f74b5d87659d41f957ccbce7e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:09:28 2007 -0400

    USB: avoid urb-&gt;pipe in usbfs
    
    This patch (as948) removes most of the references to urb-&gt;pipe from
    the usbfs routines in devio.c.  The one tricky aspect is in
    snoop_urb(), which can be called before the URB is submitted and which
    uses usb_urb_dir_in().  For this to work properly, the URB's direction
    flag must be set manually in proc_do_submiturb().
    
    The patch also fixes a minor bug; the wValue, wIndex, and wLength
    fields were snooped in proc_do_submiturb() without conversion from
    le16 to CPU-byte-ordering.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 927a181120a9..b9f1edd6af53 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -289,10 +289,8 @@ static void snoop_urb(struct urb *urb, void __user *userurb)
 	if (!usbfs_snoop)
 		return;
 
-	if (urb-&gt;pipe &amp; USB_DIR_IN)
-		dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=IN\n");
-	else
-		dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=OUT\n");
+	dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=%s\n",
+			usb_urb_dir_in(urb) ? "IN" : "OUT");
 	dev_info(&amp;urb-&gt;dev-&gt;dev, "userurb=%p\n", userurb);
 	dev_info(&amp;urb-&gt;dev-&gt;dev, "transfer_buffer_length=%d\n",
 		 urb-&gt;transfer_buffer_length);
@@ -910,6 +908,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	struct usb_ctrlrequest *dr = NULL;
 	unsigned int u, totlen, isofrmlen;
 	int ret, ifnum = -1;
+	int is_in;
 
 	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP|USBDEVFS_URB_SHORT_NOT_OK|
 			   URB_NO_FSBR|URB_ZERO_PACKET))
@@ -924,16 +923,18 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if ((ret = checkintf(ps, ifnum)))
 			return ret;
 	}
-	if ((uurb-&gt;endpoint &amp; USB_ENDPOINT_DIR_MASK) != 0)
-		ep = ps-&gt;dev-&gt;ep_in [uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
-	else
-		ep = ps-&gt;dev-&gt;ep_out [uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
+	if ((uurb-&gt;endpoint &amp; USB_ENDPOINT_DIR_MASK) != 0) {
+		is_in = 1;
+		ep = ps-&gt;dev-&gt;ep_in[uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
+	} else {
+		is_in = 0;
+		ep = ps-&gt;dev-&gt;ep_out[uurb-&gt;endpoint &amp; USB_ENDPOINT_NUMBER_MASK];
+	}
 	if (!ep)
 		return -ENOENT;
 	switch(uurb-&gt;type) {
 	case USBDEVFS_URB_TYPE_CONTROL:
-		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-				!= USB_ENDPOINT_XFER_CONTROL)
+		if (!usb_endpoint_xfer_control(&amp;ep-&gt;desc))
 			return -EINVAL;
 		/* min 8 byte setup packet, max 8 byte setup plus an arbitrary data stage */
 		if (uurb-&gt;buffer_length &lt; 8 || uurb-&gt;buffer_length &gt; (8 + MAX_USBFS_BUFFER_SIZE))
@@ -952,23 +953,32 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			kfree(dr);
 			return ret;
 		}
-		uurb-&gt;endpoint = (uurb-&gt;endpoint &amp; ~USB_ENDPOINT_DIR_MASK) | (dr-&gt;bRequestType &amp; USB_ENDPOINT_DIR_MASK);
 		uurb-&gt;number_of_packets = 0;
 		uurb-&gt;buffer_length = le16_to_cpup(&amp;dr-&gt;wLength);
 		uurb-&gt;buffer += 8;
-		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ?  VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length)) {
+		if ((dr-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; uurb-&gt;buffer_length) {
+			is_in = 1;
+			uurb-&gt;endpoint |= USB_DIR_IN;
+		} else {
+			is_in = 0;
+			uurb-&gt;endpoint &amp;= ~USB_DIR_IN;
+		}
+		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
+				uurb-&gt;buffer, uurb-&gt;buffer_length)) {
 			kfree(dr);
 			return -EFAULT;
 		}
 		snoop(&amp;ps-&gt;dev-&gt;dev, "control urb: bRequest=%02x "
 			"bRrequestType=%02x wValue=%04x "
 			"wIndex=%04x wLength=%04x\n",
-			dr-&gt;bRequest, dr-&gt;bRequestType, dr-&gt;wValue,
-			dr-&gt;wIndex, dr-&gt;wLength);
+			dr-&gt;bRequest, dr-&gt;bRequestType,
+			__le16_to_cpup(&amp;dr-&gt;wValue),
+			__le16_to_cpup(&amp;dr-&gt;wIndex),
+			__le16_to_cpup(&amp;dr-&gt;wLength));
 		break;
 
 	case USBDEVFS_URB_TYPE_BULK:
-		switch (ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
+		switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
 		case USB_ENDPOINT_XFER_CONTROL:
 		case USB_ENDPOINT_XFER_ISOC:
 			return -EINVAL;
@@ -977,7 +987,8 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		uurb-&gt;number_of_packets = 0;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length))
+		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
+				uurb-&gt;buffer, uurb-&gt;buffer_length))
 			return -EFAULT;
 		snoop(&amp;ps-&gt;dev-&gt;dev, "bulk urb\n");
 		break;
@@ -986,8 +997,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		/* arbitrary limit */
 		if (uurb-&gt;number_of_packets &lt; 1 || uurb-&gt;number_of_packets &gt; 128)
 			return -EINVAL;
-		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-				!= USB_ENDPOINT_XFER_ISOC)
+		if (!usb_endpoint_xfer_isoc(&amp;ep-&gt;desc))
 			return -EINVAL;
 		isofrmlen = sizeof(struct usbdevfs_iso_packet_desc) * uurb-&gt;number_of_packets;
 		if (!(isopkt = kmalloc(isofrmlen, GFP_KERNEL)))
@@ -1014,12 +1024,12 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 
 	case USBDEVFS_URB_TYPE_INTERRUPT:
 		uurb-&gt;number_of_packets = 0;
-		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-				!= USB_ENDPOINT_XFER_INT)
+		if (!usb_endpoint_xfer_int(&amp;ep-&gt;desc))
 			return -EINVAL;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length))
+		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
+				uurb-&gt;buffer, uurb-&gt;buffer_length))
 			return -EFAULT;
 		snoop(&amp;ps-&gt;dev-&gt;dev, "interrupt urb\n");
 		break;
@@ -1039,8 +1049,11 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		return -ENOMEM;
 	}
         as-&gt;urb-&gt;dev = ps-&gt;dev;
-        as-&gt;urb-&gt;pipe = (uurb-&gt;type &lt;&lt; 30) | __create_pipe(ps-&gt;dev, uurb-&gt;endpoint &amp; 0xf) | (uurb-&gt;endpoint &amp; USB_DIR_IN);
-        as-&gt;urb-&gt;transfer_flags = uurb-&gt;flags;
+        as-&gt;urb-&gt;pipe = (uurb-&gt;type &lt;&lt; 30) |
+			__create_pipe(ps-&gt;dev, uurb-&gt;endpoint &amp; 0xf) |
+			(uurb-&gt;endpoint &amp; USB_DIR_IN);
+        as-&gt;urb-&gt;transfer_flags = uurb-&gt;flags |
+			(is_in ? URB_DIR_IN : URB_DIR_OUT);
 	as-&gt;urb-&gt;transfer_buffer_length = uurb-&gt;buffer_length;
 	as-&gt;urb-&gt;setup_packet = (unsigned char*)dr;
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
@@ -1070,13 +1083,13 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	as-&gt;uid = current-&gt;uid;
 	as-&gt;euid = current-&gt;euid;
 	security_task_getsecid(current, &amp;as-&gt;secid);
-	if (!(uurb-&gt;endpoint &amp; USB_DIR_IN)) {
-		if (copy_from_user(as-&gt;urb-&gt;transfer_buffer, uurb-&gt;buffer, as-&gt;urb-&gt;transfer_buffer_length)) {
+	if (!is_in) {
+		if (copy_from_user(as-&gt;urb-&gt;transfer_buffer, uurb-&gt;buffer,
+				as-&gt;urb-&gt;transfer_buffer_length)) {
 			free_async(as);
 			return -EFAULT;
 		}
 	}
-	snoop(&amp;as-&gt;urb-&gt;dev-&gt;dev, "submit urb\n");
 	snoop_urb(as-&gt;urb, as-&gt;userurb);
         async_newpending(as);
         if ((ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL))) {
@@ -1126,7 +1139,7 @@ static int processcompl(struct async *as, void __user * __user *arg)
 	if (put_user(urb-&gt;error_count, &amp;userurb-&gt;error_count))
 		return -EFAULT;
 
-	if (usb_pipeisoc(urb-&gt;pipe)) {
+	if (usb_endpoint_xfer_isoc(&amp;urb-&gt;ep-&gt;desc)) {
 		for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 			if (put_user(urb-&gt;iso_frame_desc[i].actual_length,
 				     &amp;userurb-&gt;iso_frame_desc[i].actual_length))
@@ -1240,7 +1253,7 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 	if (put_user(urb-&gt;error_count, &amp;userurb-&gt;error_count))
 		return -EFAULT;
 
-	if (usb_pipeisoc(urb-&gt;pipe)) {
+	if (usb_endpoint_xfer_isoc(&amp;urb-&gt;ep-&gt;desc)) {
 		for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 			if (put_user(urb-&gt;iso_frame_desc[i].actual_length,
 				     &amp;userurb-&gt;iso_frame_desc[i].actual_length))</pre><hr><pre>commit 4326ed0be93574dac5b5e475713015159108bd88
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:08:43 2007 -0400

    USB: address-0 handling during device initialization
    
    This patch (as947) changes the device initialization and enumeration
    code in hub.c; now udev-&gt;devnum will be set to 0 while the device is
    being accessed at address 0.  Until now this wasn't needed because the
    address value was passed as part of urb-&gt;pipe; without that field the
    device address must be stored elsewhere.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c8a01f66df70..34be27a6cbb4 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1481,6 +1481,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 		case 0:
 			/* TRSTRCY = 10 ms; plus some extra */
 			msleep(10 + 40);
+		  	udev-&gt;devnum = 0;	/* Device now at address 0 */
 			/* FALL THROUGH */
 		case -ENOTCONN:
 		case -ENODEV:
@@ -2005,20 +2006,21 @@ static void ep0_reinit(struct usb_device *udev)
 #define usb_sndaddr0pipe()	(PIPE_CONTROL &lt;&lt; 30)
 #define usb_rcvaddr0pipe()	((PIPE_CONTROL &lt;&lt; 30) | USB_DIR_IN)
 
-static int hub_set_address(struct usb_device *udev)
+static int hub_set_address(struct usb_device *udev, int devnum)
 {
 	int retval;
 
-	if (udev-&gt;devnum == 0)
+	if (devnum &lt;= 1)
 		return -EINVAL;
 	if (udev-&gt;state == USB_STATE_ADDRESS)
 		return 0;
 	if (udev-&gt;state != USB_STATE_DEFAULT)
 		return -EINVAL;
 	retval = usb_control_msg(udev, usb_sndaddr0pipe(),
-		USB_REQ_SET_ADDRESS, 0, udev-&gt;devnum, 0,
+		USB_REQ_SET_ADDRESS, 0, devnum, 0,
 		NULL, 0, USB_CTRL_SET_TIMEOUT);
 	if (retval == 0) {
+		udev-&gt;devnum = devnum;	/* Device now using proper address */
 		usb_set_device_state(udev, USB_STATE_ADDRESS);
 		ep0_reinit(udev);
 	}
@@ -2045,6 +2047,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	unsigned		delay = HUB_SHORT_RESET_TIME;
 	enum usb_device_speed	oldspeed = udev-&gt;speed;
 	char 			*speed, *type;
+	int			devnum = udev-&gt;devnum;
 
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
@@ -2074,7 +2077,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		goto fail;
 	}
 	oldspeed = udev-&gt;speed;
-  
+
 	/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...
 	 * it's fixed size except for full speed devices.
 	 * For Wireless USB devices, ep0 max packet is always 512 (tho
@@ -2115,7 +2118,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	dev_info (&amp;udev-&gt;dev,
 		  "%s %s speed %sUSB device using %s and address %d\n",
 		  (udev-&gt;config) ? "reset" : "new", speed, type,
-		  udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, udev-&gt;devnum);
+		  udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, devnum);
 
 	/* Set up TT records, if needed  */
 	if (hdev-&gt;tt) {
@@ -2202,7 +2205,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		}
 
 		for (j = 0; j &lt; SET_ADDRESS_TRIES; ++j) {
-			retval = hub_set_address(udev);
+			retval = hub_set_address(udev, devnum);
 			if (retval &gt;= 0)
 				break;
 			msleep(200);
@@ -2210,7 +2213,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		if (retval &lt; 0) {
 			dev_err(&amp;udev-&gt;dev,
 				"device not accepting address %d, error %d\n",
-				udev-&gt;devnum, retval);
+				devnum, retval);
 			goto fail;
 		}
  
@@ -2263,8 +2266,10 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	retval = 0;
 
 fail:
-	if (retval)
+	if (retval) {
 		hub_port_disable(hub, port1, 0);
+		udev-&gt;devnum = devnum;	/* for disconnect processing */
+	}
 	mutex_unlock(&amp;usb_address0_mutex);
 	return retval;
 }
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 1a64a6a850f3..1acca8696bcd 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -284,9 +284,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	if (!urb || urb-&gt;hcpriv || !urb-&gt;complete)
 		return -EINVAL;
-	if (!(dev = urb-&gt;dev) ||
-	    (dev-&gt;state &lt; USB_STATE_DEFAULT) ||
-	    (!dev-&gt;bus) || (dev-&gt;devnum &lt;= 0))
+	if (!(dev = urb-&gt;dev) || dev-&gt;state &lt; USB_STATE_DEFAULT)
 		return -ENODEV;
 	if (dev-&gt;bus-&gt;controller-&gt;power.power_state.event != PM_EVENT_ON
 			|| dev-&gt;state == USB_STATE_SUSPENDED)</pre><hr><pre>commit 5e60a16139c2a48b9876b0ff910671eee5fb32ec
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:07:21 2007 -0400

    USB: avoid using urb-&gt;pipe in usbcore
    
    This patch (as946) eliminates many of the uses of urb-&gt;pipe in
    usbcore.  Unfortunately there will have to be a significant API
    change, affecting all USB drivers, before we can remove it entirely.
    This patch contents itself with changing only the interface to
    usb_buffer_map_sg() and friends: The pipe argument is replaced with a
    direction flag.  That can be done easily because those routines get
    used in only one place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index bcbaedc897d5..739c5e0aa3b8 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -635,9 +635,9 @@ static int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)
 
 static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 {
-	if (usb_pipeint (urb-&gt;pipe))
+	if (usb_endpoint_xfer_int(&amp;urb-&gt;ep-&gt;desc))
 		return rh_queue_status (hcd, urb);
-	if (usb_pipecontrol (urb-&gt;pipe))
+	if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc))
 		return rh_call_control (hcd, urb);
 	return -EINVAL;
 }
@@ -651,7 +651,7 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
 	unsigned long	flags;
 
-	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
+	if (usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc) == 0) {	/* Control URB */
 		;	/* Do nothing */
 
 	} else {				/* Status URB */
@@ -918,7 +918,7 @@ static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
 	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 
 	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
-		if (usb_pipecontrol (urb-&gt;pipe)
+		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
 					sizeof (struct usb_ctrlrequest),
@@ -1001,7 +1001,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	 * unless it uses pio or talks to another transport.
 	 */
 	if (hcd-&gt;self.uses_dma) {
-		if (usb_pipecontrol (urb-&gt;pipe)
+		if (usb_endpoint_xfer_control(&amp;urb-&gt;ep-&gt;desc)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			urb-&gt;setup_dma = dma_map_single (
 					hcd-&gt;self.controller,
@@ -1201,11 +1201,13 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	spin_lock(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
+		int	is_in;
 
 		/* the urb may already have been unlinked */
 		if (urb-&gt;status != -EINPROGRESS)
 			continue;
 		usb_get_urb (urb);
+		is_in = usb_urb_dir_in(urb);
 		spin_unlock(&amp;hcd_urb_list_lock);
 
 		spin_lock (&amp;urb-&gt;lock);
@@ -1216,19 +1218,25 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 		/* kick hcd unless it's already returning this */
 		if (tmp == -EINPROGRESS) {
-			tmp = urb-&gt;pipe;
 			unlink1 (hcd, urb);
 			dev_dbg (hcd-&gt;self.controller,
-				"shutdown urb %p pipe %08x ep%d%s%s\n",
-				urb, tmp, usb_pipeendpoint (tmp),
-				(tmp &amp; USB_DIR_IN) ? "in" : "out",
-				({ char *s; \
-				 switch (usb_pipetype (tmp)) { \
-				 case PIPE_CONTROL:	s = ""; break; \
-				 case PIPE_BULK:	s = "-bulk"; break; \
-				 case PIPE_INTERRUPT:	s = "-intr"; break; \
-				 default: 		s = "-iso"; break; \
-				}; s;}));
+				"shutdown urb %p ep%d%s%s\n",
+				urb, usb_endpoint_num(&amp;ep-&gt;desc),
+				is_in ? "in" : "out",
+				({	char *s;
+
+					switch (usb_endpoint_type(&amp;ep-&gt;desc)) {
+					case USB_ENDPOINT_XFER_CONTROL:
+						s = ""; break;
+					case USB_ENDPOINT_XFER_BULK:
+						s = "-bulk"; break;
+					case USB_ENDPOINT_XFER_INT:
+						s = "-intr"; break;
+					default:
+				 		s = "-iso"; break;
+					};
+					s;
+				}));
 		}
 		usb_put_urb (urb);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 0d618647758e..a26a7292b61a 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -59,8 +59,8 @@ static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)
 		dev_dbg(&amp;urb-&gt;dev-&gt;dev,
 			"%s timed out on ep%d%s len=%d/%d\n",
 			current-&gt;comm,
-			usb_pipeendpoint(urb-&gt;pipe),
-			usb_pipein(urb-&gt;pipe) ? "in" : "out",
+			usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc),
+			usb_urb_dir_in(urb) ? "in" : "out",
 			urb-&gt;actual_length,
 			urb-&gt;transfer_buffer_length);
 	} else
@@ -250,7 +250,8 @@ static void sg_clean (struct usb_sg_request *io)
 		io-&gt;urbs = NULL;
 	}
 	if (io-&gt;dev-&gt;dev.dma_mask != NULL)
-		usb_buffer_unmap_sg (io-&gt;dev, io-&gt;pipe, io-&gt;sg, io-&gt;nents);
+		usb_buffer_unmap_sg (io-&gt;dev, usb_pipein(io-&gt;pipe),
+				io-&gt;sg, io-&gt;nents);
 	io-&gt;dev = NULL;
 }
 
@@ -278,8 +279,8 @@ static void sg_complete (struct urb *urb)
 		dev_err (io-&gt;dev-&gt;bus-&gt;controller,
 			"dev %s ep%d%s scatterlist error %d/%d\n",
 			io-&gt;dev-&gt;devpath,
-			usb_pipeendpoint (urb-&gt;pipe),
-			usb_pipein (urb-&gt;pipe) ? "in" : "out",
+			usb_endpoint_num(&amp;urb-&gt;ep-&gt;desc),
+			usb_urb_dir_in(urb) ? "in" : "out",
 			status, io-&gt;status);
 		// BUG ();
 	}
@@ -379,7 +380,8 @@ int usb_sg_init (
 	 */
 	dma = (dev-&gt;dev.dma_mask != NULL);
 	if (dma)
-		io-&gt;entries = usb_buffer_map_sg (dev, pipe, sg, nents);
+		io-&gt;entries = usb_buffer_map_sg(dev, usb_pipein(pipe),
+				sg, nents);
 	else
 		io-&gt;entries = nents;
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index d3c68d8eafb2..67e2e582e463 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -748,7 +748,7 @@ void usb_buffer_unmap(struct urb *urb)
 /**
  * usb_buffer_map_sg - create scatterlist DMA mapping(s) for an endpoint
  * @dev: device to which the scatterlist will be mapped
- * @pipe: endpoint defining the mapping direction
+ * @is_in: mapping transfer direction
  * @sg: the scatterlist to map
  * @nents: the number of entries in the scatterlist
  *
@@ -771,14 +771,13 @@ void usb_buffer_unmap(struct urb *urb)
  *
  * Reverse the effect of this call with usb_buffer_unmap_sg().
  */
-int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
+int usb_buffer_map_sg(const struct usb_device *dev, int is_in,
 		      struct scatterlist *sg, int nents)
 {
 	struct usb_bus		*bus;
 	struct device		*controller;
 
 	if (!dev
-			|| usb_pipecontrol(pipe)
 			|| !(bus = dev-&gt;bus)
 			|| !(controller = bus-&gt;controller)
 			|| !controller-&gt;dma_mask)
@@ -786,7 +785,7 @@ int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
 
 	// FIXME generic api broken like pci, can't report errors
 	return dma_map_sg(controller, sg, nents,
-			usb_pipein(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
 /* XXX DISABLED, no users currently.  If you wish to re-enable this
@@ -799,14 +798,14 @@ int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
 /**
  * usb_buffer_dmasync_sg - synchronize DMA and CPU view of scatterlist buffer(s)
  * @dev: device to which the scatterlist will be mapped
- * @pipe: endpoint defining the mapping direction
+ * @is_in: mapping transfer direction
  * @sg: the scatterlist to synchronize
  * @n_hw_ents: the positive return value from usb_buffer_map_sg
  *
  * Use this when you are re-using a scatterlist's data buffers for
  * another USB request.
  */
-void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,
 			   struct scatterlist *sg, int n_hw_ents)
 {
 	struct usb_bus		*bus;
@@ -819,20 +818,20 @@ void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
 		return;
 
 	dma_sync_sg(controller, sg, n_hw_ents,
-			usb_pipein(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 #endif
 
 /**
  * usb_buffer_unmap_sg - free DMA mapping(s) for a scatterlist
  * @dev: device to which the scatterlist will be mapped
- * @pipe: endpoint defining the mapping direction
+ * @is_in: mapping transfer direction
  * @sg: the scatterlist to unmap
  * @n_hw_ents: the positive return value from usb_buffer_map_sg
  *
  * Reverses the effect of usb_buffer_map_sg().
  */
-void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,
 			 struct scatterlist *sg, int n_hw_ents)
 {
 	struct usb_bus		*bus;
@@ -845,7 +844,7 @@ void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
 		return;
 
 	dma_unmap_sg(controller, sg, n_hw_ents,
-			usb_pipein(pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+			is_in ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
 /* format to disable USB on kernel command line is: nousb */
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 9d08f5a5ba76..019ae963a9fe 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1422,13 +1422,13 @@ void usb_buffer_unmap (struct urb *urb);
 #endif
 
 struct scatterlist;
-int usb_buffer_map_sg(const struct usb_device *dev, unsigned pipe,
+int usb_buffer_map_sg(const struct usb_device *dev, int is_in,
 		      struct scatterlist *sg, int nents);
 #if 0
-void usb_buffer_dmasync_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_dmasync_sg(const struct usb_device *dev, int is_in,
 			   struct scatterlist *sg, int n_hw_ents);
 #endif
-void usb_buffer_unmap_sg(const struct usb_device *dev, unsigned pipe,
+void usb_buffer_unmap_sg(const struct usb_device *dev, int is_in,
 			 struct scatterlist *sg, int n_hw_ents);
 
 /*-------------------------------------------------------------------*</pre><hr><pre>commit fea3409112a93581db18da4c4332c8bf8d68af6b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:06:16 2007 -0400

    USB: add direction bit to urb-&gt;transfer_flags
    
    This patch (as945) adds a bit to urb-&gt;transfer_flags for recording the
    direction of the URB.  The bit is set/cleared automatically in
    usb_submit_urb() so drivers don't have to worry about it (although as
    a result, it isn't valid until the URB has been submitted).  Inline
    routines are added for easily checking an URB's direction.  They
    replace calls to usb_pipein in the DMA-mapping parts of hcd.c.
    
    For non-control endpoints, the direction is determined directly from
    the endpoint descriptor.  However control endpoints are
    bi-directional; for them the direction is determined from the
    bRequestType byte and the wLength value in the setup packet.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index cc5b1d3c3680..bcbaedc897d5 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -928,7 +928,7 @@ static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
 			dma_unmap_single (hcd-&gt;self.controller,
 					urb-&gt;transfer_dma,
 					urb-&gt;transfer_buffer_length,
-					usb_pipein (urb-&gt;pipe)
+					usb_urb_dir_in(urb)
 					    ? DMA_FROM_DEVICE
 					    : DMA_TO_DEVICE);
 	}
@@ -1014,7 +1014,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 					hcd-&gt;self.controller,
 					urb-&gt;transfer_buffer,
 					urb-&gt;transfer_buffer_length,
-					usb_pipein (urb-&gt;pipe)
+					usb_urb_dir_in(urb)
 					    ? DMA_FROM_DEVICE
 					    : DMA_TO_DEVICE);
 	}
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index ff53acb4fab2..1a64a6a850f3 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -309,7 +309,21 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * and don't need to duplicate tests
 	 */
 	xfertype = usb_endpoint_type(&amp;ep-&gt;desc);
-	is_out = usb_pipeout(urb-&gt;pipe);
+	if (xfertype == USB_ENDPOINT_XFER_CONTROL) {
+		struct usb_ctrlrequest *setup =
+				(struct usb_ctrlrequest *) urb-&gt;setup_packet;
+
+		if (!setup)
+			return -ENOEXEC;
+		is_out = !(setup-&gt;bRequestType &amp; USB_DIR_IN) ||
+				!setup-&gt;wLength;
+	} else {
+		is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
+	}
+
+	/* Cache the direction for later use */
+	urb-&gt;transfer_flags = (urb-&gt;transfer_flags &amp; ~URB_DIR_MASK) |
+			(is_out ? URB_DIR_OUT : URB_DIR_IN);
 
 	if (xfertype != USB_ENDPOINT_XFER_CONTROL &amp;&amp;
 			dev-&gt;state &lt; USB_STATE_CONFIGURED)
@@ -363,7 +377,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
-			URB_NO_INTERRUPT);
+			URB_NO_INTERRUPT | URB_DIR_MASK);
 	switch (xfertype) {
 	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 818a1b4f737a..9d08f5a5ba76 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1021,6 +1021,8 @@ extern int usb_disabled(void);
 
 /*
  * urb-&gt;transfer_flags:
+ *
+ * Note: URB_DIR_IN/OUT is automatically set in usb_submit_urb().
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
 #define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
@@ -1033,6 +1035,10 @@ extern int usb_disabled(void);
 					 * needed */
 #define URB_FREE_BUFFER		0x0100	/* Free transfer buffer with the URB */
 
+#define URB_DIR_IN		0x0200	/* Transfer from device to host */
+#define URB_DIR_OUT		0
+#define URB_DIR_MASK		URB_DIR_IN
+
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
 	unsigned int length;		/* expected length */
@@ -1380,6 +1386,30 @@ extern void usb_unanchor_urb(struct urb *urb);
 extern int usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,
 					 unsigned int timeout);
 
+/**
+ * usb_urb_dir_in - check if an URB describes an IN transfer
+ * @urb: URB to be checked
+ *
+ * Returns 1 if @urb describes an IN transfer (device-to-host),
+ * otherwise 0.
+ */
+static inline int usb_urb_dir_in(struct urb *urb)
+{
+	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) != URB_DIR_OUT;
+}
+
+/**
+ * usb_urb_dir_out - check if an URB describes an OUT transfer
+ * @urb: URB to be checked
+ *
+ * Returns 1 if @urb describes an OUT transfer (host-to-device),
+ * otherwise 0.
+ */
+static inline int usb_urb_dir_out(struct urb *urb)
+{
+	return (urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_OUT;
+}
+
 void *usb_buffer_alloc (struct usb_device *dev, size_t size,
 	gfp_t mem_flags, dma_addr_t *dma);
 void usb_buffer_free (struct usb_device *dev, size_t size,</pre><hr><pre>commit bdd016ba64d909329cb4bacacc8443901c00e112
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:05:22 2007 -0400

    USB: add ep-&gt;enable
    
    This patch (as944) adds an explicit "enabled" field to the
    usb_host_endpoint structure and uses it in place of the current
    mechanism.  This is merely a time-space tradeoff; it makes checking
    whether URBs may be submitted to an endpoint simpler.  The existing
    mechanism is efficient when converting urb-&gt;pipe to an endpoint
    pointer, but it's not so efficient when urb-&gt;ep is used instead.
    
    As a side effect, the procedure for enabling an endpoint is now a
    little more complicated.  The ad-hoc inline code in usb.c and hub.c
    for enabling ep0 is now replaced with calls to usb_enable_endpoint,
    which is no longer static.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index fb82c500caf4..cc5b1d3c3680 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -943,7 +943,6 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 {
 	int			status;
 	struct usb_hcd		*hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
-	struct usb_host_endpoint *ep;
 	unsigned long		flags;
 
 	if (!hcd)
@@ -960,9 +959,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	// FIXME:  verify that quiescing hc works right (RH cleans up)
 
 	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
-	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
-			[usb_pipeendpoint(urb-&gt;pipe)];
-	if (unlikely(ep != urb-&gt;ep))
+	if (unlikely(!urb-&gt;ep-&gt;enabled))
 		status = -ENOENT;
 	else if (unlikely (urb-&gt;reject))
 		status = -EPERM;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f7b337feb3ea..c8a01f66df70 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1999,7 +1999,7 @@ static void ep0_reinit(struct usb_device *udev)
 {
 	usb_disable_endpoint(udev, 0 + USB_DIR_IN);
 	usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
-	udev-&gt;ep_in[0] = udev-&gt;ep_out[0] = &amp;udev-&gt;ep0;
+	usb_enable_endpoint(udev, &amp;udev-&gt;ep0);
 }
 
 #define usb_sndaddr0pipe()	(PIPE_CONTROL &lt;&lt; 30)
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index d8f7b089a8f0..0d618647758e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1013,8 +1013,10 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 		ep = dev-&gt;ep_in[epnum];
 		dev-&gt;ep_in[epnum] = NULL;
 	}
-	if (ep &amp;&amp; dev-&gt;bus)
+	if (ep) {
+		ep-&gt;enabled = 0;
 		usb_hcd_endpoint_disable(dev, ep);
+	}
 }
 
 /**
@@ -1096,23 +1098,21 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
  * Resets the endpoint toggle, and sets dev-&gt;ep_{in,out} pointers.
  * For control endpoints, both the input and output sides are handled.
  */
-static void
-usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
+void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
 {
-	unsigned int epaddr = ep-&gt;desc.bEndpointAddress;
-	unsigned int epnum = epaddr &amp; USB_ENDPOINT_NUMBER_MASK;
-	int is_control;
+	int epnum = usb_endpoint_num(&amp;ep-&gt;desc);
+	int is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
+	int is_control = usb_endpoint_xfer_control(&amp;ep-&gt;desc);
 
-	is_control = ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
-			== USB_ENDPOINT_XFER_CONTROL);
-	if (usb_endpoint_out(epaddr) || is_control) {
+	if (is_out || is_control) {
 		usb_settoggle(dev, epnum, 1, 0);
 		dev-&gt;ep_out[epnum] = ep;
 	}
-	if (!usb_endpoint_out(epaddr) || is_control) {
+	if (!is_out || is_control) {
 		usb_settoggle(dev, epnum, 0, 0);
 		dev-&gt;ep_in[epnum] = ep;
 	}
+	ep-&gt;enabled = 1;
 }
 
 /*
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 0fee5c66fd64..d3c68d8eafb2 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -260,7 +260,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	dev-&gt;ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
 	/* ep0 maxpacket comes later, from device descriptor */
-	dev-&gt;ep_in[0] = dev-&gt;ep_out[0] = &amp;dev-&gt;ep0;
+	usb_enable_endpoint(dev, &amp;dev-&gt;ep0);
 
 	/* Save readable and stable topology id, distinguishing devices
 	 * by location for diagnostics, tools, driver model, etc.  The
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index ad5fa0338f49..cde6e52b84fe 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -8,6 +8,8 @@ extern int usb_create_ep_files(struct device *parent, struct usb_host_endpoint *
 				struct usb_device *udev);
 extern void usb_remove_ep_files(struct usb_host_endpoint *endpoint);
 
+extern void usb_enable_endpoint(struct usb_device *dev,
+		struct usb_host_endpoint *ep);
 extern void usb_disable_endpoint (struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface (struct usb_device *dev,
 		struct usb_interface *intf);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 105e3e9362d0..818a1b4f737a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -52,6 +52,7 @@ struct ep_device;
  * @ep_dev: ep_device for sysfs info
  * @extra: descriptors following this endpoint in the configuration
  * @extralen: how many bytes of "extra" are valid
+ * @enabled: URBs may be submitted to this endpoint
  *
  * USB requests are always queued to a given endpoint, identified by a
  * descriptor within an active interface in a given USB configuration.
@@ -64,6 +65,7 @@ struct usb_host_endpoint {
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;
+	int enabled;
 };
 
 /* host-side wrapper for one interface setting's parsed descriptors */</pre><hr><pre>commit 5b653c79c04c6b152b8dc7d18f8c8a7f77f4b235
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 30 17:04:37 2007 -0400

    USB: add urb-&gt;ep
    
    This patch (as943) prepares the way for eliminating urb-&gt;pipe by
    introducing an endpoint pointer into struct urb.  For now urb-&gt;ep
    is set by usb_submit_urb() from the pipe value; eventually drivers
    will set it themselves and we will remove urb-&gt;pipe completely.
    
    The patch also adds new inline routines to retrieve an endpoint
    descriptor's number and transfer type, essentially as replacements for
    usb_pipeendpoint and usb_pipetype.
    
    usb_submit_urb(), usb_hcd_submit_urb(), and usb_hcd_unlink_urb() are
    converted to use the new field and new routines.  Other parts of
    usbcore will be converted in later patches.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 42ef1d5f6c8a..fb82c500caf4 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -962,14 +962,14 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
 	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
 			[usb_pipeendpoint(urb-&gt;pipe)];
-	if (unlikely (!ep))
+	if (unlikely(ep != urb-&gt;ep))
 		status = -ENOENT;
 	else if (unlikely (urb-&gt;reject))
 		status = -EPERM;
 	else switch (hcd-&gt;state) {
 	case HC_STATE_RUNNING:
 	case HC_STATE_RESUMING:
-		list_add_tail (&amp;urb-&gt;urb_list, &amp;ep-&gt;urb_list);
+		list_add_tail (&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
 		status = 0;
 		break;
 	default:
@@ -1022,7 +1022,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 					    : DMA_TO_DEVICE);
 	}
 
-	status = hcd-&gt;driver-&gt;urb_enqueue (hcd, ep, urb, mem_flags);
+	status = hcd-&gt;driver-&gt;urb_enqueue (hcd, urb-&gt;ep, urb, mem_flags);
 done:
 	if (unlikely (status)) {
 		urb_unlink(hcd, urb);
@@ -1071,7 +1071,6 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
  */
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
-	struct usb_host_endpoint	*ep;
 	struct usb_hcd			*hcd = NULL;
 	struct device			*sys = NULL;
 	unsigned long			flags;
@@ -1082,10 +1081,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 		return -EINVAL;
 	if (!urb-&gt;dev || !urb-&gt;dev-&gt;bus)
 		return -ENODEV;
-	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
-			[usb_pipeendpoint(urb-&gt;pipe)];
-	if (!ep)
-		return -ENODEV;
 
 	/*
 	 * we contend for urb-&gt;status with the hcd core,
@@ -1109,7 +1104,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	}
 
 	/* insist the urb is still queued */
-	list_for_each(tmp, &amp;ep-&gt;urb_list) {
+	list_for_each(tmp, &amp;urb-&gt;ep-&gt;urb_list) {
 		if (tmp == &amp;urb-&gt;urb_list)
 			break;
 	}
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index be630228461c..ff53acb4fab2 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -277,9 +277,10 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  */
 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
-	int			pipe, temp, max;
-	struct usb_device	*dev;
-	int			is_out;
+	int				xfertype, max;
+	struct usb_device		*dev;
+	struct usb_host_endpoint	*ep;
+	int				is_out;
 
 	if (!urb || urb-&gt;hcpriv || !urb-&gt;complete)
 		return -EINVAL;
@@ -291,30 +292,34 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			|| dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
 
+	/* For now, get the endpoint from the pipe.  Eventually drivers
+	 * will be required to set urb-&gt;ep directly and we will eliminate
+	 * urb-&gt;pipe.
+	 */
+	ep = (usb_pipein(urb-&gt;pipe) ? dev-&gt;ep_in : dev-&gt;ep_out)
+			[usb_pipeendpoint(urb-&gt;pipe)];
+	if (!ep)
+		return -ENOENT;
+
+	urb-&gt;ep = ep;
 	urb-&gt;status = -EINPROGRESS;
 	urb-&gt;actual_length = 0;
 
 	/* Lots of sanity checks, so HCDs can rely on clean data
 	 * and don't need to duplicate tests
 	 */
-	pipe = urb-&gt;pipe;
-	temp = usb_pipetype(pipe);
-	is_out = usb_pipeout(pipe);
+	xfertype = usb_endpoint_type(&amp;ep-&gt;desc);
+	is_out = usb_pipeout(urb-&gt;pipe);
 
-	if (!usb_pipecontrol(pipe) &amp;&amp; dev-&gt;state &lt; USB_STATE_CONFIGURED)
+	if (xfertype != USB_ENDPOINT_XFER_CONTROL &amp;&amp;
+			dev-&gt;state &lt; USB_STATE_CONFIGURED)
 		return -ENODEV;
 
-	/* FIXME there should be a sharable lock protecting us against
-	 * config/altsetting changes and disconnects, kicking in here.
-	 * (here == before maxpacket, and eventually endpoint type,
-	 * checks get made.)
-	 */
-
-	max = usb_maxpacket(dev, pipe, is_out);
+	max = le16_to_cpu(ep-&gt;desc.wMaxPacketSize);
 	if (max &lt;= 0) {
 		dev_dbg(&amp;dev-&gt;dev,
 			"bogus endpoint ep%d%s in %s (bad maxpacket %d)\n",
-			usb_pipeendpoint(pipe), is_out ? "out" : "in",
+			usb_endpoint_num(&amp;ep-&gt;desc), is_out ? "out" : "in",
 			__FUNCTION__, max);
 		return -EMSGSIZE;
 	}
@@ -323,7 +328,7 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * but drivers only control those sizes for ISO.
 	 * while we're checking, initialize return status.
 	 */
-	if (temp == PIPE_ISOCHRONOUS) {
+	if (xfertype == USB_ENDPOINT_XFER_ISOC) {
 		int	n, len;
 
 		/* "high bandwidth" mode, 1-3 packets/uframe? */
@@ -359,19 +364,19 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	/* enforce simple/standard policy */
 	allowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP |
 			URB_NO_INTERRUPT);
-	switch (temp) {
-	case PIPE_BULK:
+	switch (xfertype) {
+	case USB_ENDPOINT_XFER_BULK:
 		if (is_out)
 			allowed |= URB_ZERO_PACKET;
 		/* FALLTHROUGH */
-	case PIPE_CONTROL:
+	case USB_ENDPOINT_XFER_CONTROL:
 		allowed |= URB_NO_FSBR;	/* only affects UHCI */
 		/* FALLTHROUGH */
 	default:			/* all non-iso endpoints */
 		if (!is_out)
 			allowed |= URB_SHORT_NOT_OK;
 		break;
-	case PIPE_ISOCHRONOUS:
+	case USB_ENDPOINT_XFER_ISOC:
 		allowed |= URB_ISO_ASAP;
 		break;
 	}
@@ -393,9 +398,9 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 	 * supports different values... this uses EHCI/UHCI defaults (and
 	 * EHCI can use smaller non-default values).
 	 */
-	switch (temp) {
-	case PIPE_ISOCHRONOUS:
-	case PIPE_INTERRUPT:
+	switch (xfertype) {
+	case USB_ENDPOINT_XFER_ISOC:
+	case USB_ENDPOINT_XFER_INT:
 		/* too small? */
 		if (urb-&gt;interval &lt;= 0)
 			return -EINVAL;
@@ -405,29 +410,29 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 			// NOTE usb handles 2^15
 			if (urb-&gt;interval &gt; (1024 * 8))
 				urb-&gt;interval = 1024 * 8;
-			temp = 1024 * 8;
+			max = 1024 * 8;
 			break;
 		case USB_SPEED_FULL:	/* units are frames/msec */
 		case USB_SPEED_LOW:
-			if (temp == PIPE_INTERRUPT) {
+			if (xfertype == USB_ENDPOINT_XFER_INT) {
 				if (urb-&gt;interval &gt; 255)
 					return -EINVAL;
 				// NOTE ohci only handles up to 32
-				temp = 128;
+				max = 128;
 			} else {
 				if (urb-&gt;interval &gt; 1024)
 					urb-&gt;interval = 1024;
 				// NOTE usb and ohci handle up to 2^15
-				temp = 1024;
+				max = 1024;
 			}
 			break;
 		default:
 			return -EINVAL;
 		}
 		/* power of two? */
-		while (temp &gt; urb-&gt;interval)
-			temp &gt;&gt;= 1;
-		urb-&gt;interval = temp;
+		while (max &gt; urb-&gt;interval)
+			max &gt;&gt;= 1;
+		urb-&gt;interval = max;
 	}
 
 	return usb_hcd_submit_urb(urb, mem_flags);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4f33a58fa9d1..105e3e9362d0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -554,6 +554,29 @@ static inline int usb_make_path (struct usb_device *dev, char *buf,
 
 /*-------------------------------------------------------------------------*/
 
+/**
+ * usb_endpoint_num - get the endpoint's number
+ * @epd: endpoint to be checked
+ *
+ * Returns @epd's number: 0 to 15.
+ */
+static inline int usb_endpoint_num(const struct usb_endpoint_descriptor *epd)
+{
+	return epd-&gt;bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK;
+}
+
+/**
+ * usb_endpoint_type - get the endpoint's transfer type
+ * @epd: endpoint to be checked
+ *
+ * Returns one of USB_ENDPOINT_XFER_{CONTROL, ISOC, BULK, INT} according
+ * to @epd's transfer type.
+ */
+static inline int usb_endpoint_type(const struct usb_endpoint_descriptor *epd)
+{
+	return epd-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
+}
+
 /**
  * usb_endpoint_dir_in - check if the endpoint has IN direction
  * @epd: endpoint to be checked
@@ -1037,6 +1060,8 @@ typedef void (*usb_complete_t)(struct urb *);
  * @urb_list: For use by current owner of the URB.
  * @anchor_list: membership in the list of an anchor
  * @anchor: to anchor URBs to a common mooring
+ * @ep: Points to the endpoint's data structure.  Will eventually
+ *	replace @pipe.
  * @pipe: Holds endpoint number, direction, type, and more.
  *	Create these values with the eight macros available;
  *	usb_{snd,rcv}TYPEpipe(dev,endpoint), where the TYPE is "ctrl"
@@ -1212,6 +1237,7 @@ struct urb
 	struct list_head anchor_list;	/* the URB may be anchored by the driver */
 	struct usb_anchor *anchor;
 	struct usb_device *dev; 	/* (in) pointer to associated device */
+	struct usb_host_endpoint *ep;	/* (internal) pointer to endpoint struct */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
 	unsigned int transfer_flags;	/* (in) URB_SHORT_NOT_OK | ...*/</pre><hr><pre>commit cd59abfcc441b2abb4cf2cd62c1eb0f02a60e8dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 21 15:36:56 2007 -0400

    PM: merge device power-management source files
    
    This patch (as993) merges the suspend.c and resume.c files in
    drivers/base/power into main.c, making some public symbols private.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/power/Makefile b/drivers/base/power/Makefile
index 9caeaea753a3..a803733c839e 100644
--- a/drivers/base/power/Makefile
+++ b/drivers/base/power/Makefile
@@ -1,5 +1,5 @@
 obj-y			:= shutdown.o
-obj-$(CONFIG_PM_SLEEP)	+= main.o suspend.o resume.o sysfs.o
+obj-$(CONFIG_PM_SLEEP)	+= main.o sysfs.o
 obj-$(CONFIG_PM_TRACE)	+= trace.o
 
 ifeq ($(CONFIG_DEBUG_DRIVER),y)
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index eb9f38d0aa58..0ab4ab21f564 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -20,19 +20,24 @@
  */
 
 #include &lt;linux/device.h&gt;
+#include &lt;linux/kallsyms.h&gt;
 #include &lt;linux/mutex.h&gt;
+#include &lt;linux/pm.h&gt;
+#include &lt;linux/resume-trace.h&gt;
 
+#include "../base.h"
 #include "power.h"
 
 LIST_HEAD(dpm_active);
-LIST_HEAD(dpm_off);
-LIST_HEAD(dpm_off_irq);
+static LIST_HEAD(dpm_off);
+static LIST_HEAD(dpm_off_irq);
 
-DEFINE_MUTEX(dpm_mtx);
-DEFINE_MUTEX(dpm_list_mtx);
+static DEFINE_MUTEX(dpm_mtx);
+static DEFINE_MUTEX(dpm_list_mtx);
 
 int (*platform_enable_wakeup)(struct device *dev, int is_on);
 
+
 int device_pm_add(struct device *dev)
 {
 	int error;
@@ -61,3 +66,334 @@ void device_pm_remove(struct device *dev)
 }
 
 
+/*------------------------- Resume routines -------------------------*/
+
+/**
+ *	resume_device - Restore state for one device.
+ *	@dev:	Device.
+ *
+ */
+
+static int resume_device(struct device * dev)
+{
+	int error = 0;
+
+	TRACE_DEVICE(dev);
+	TRACE_RESUME(0);
+
+	down(&amp;dev-&gt;sem);
+
+	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume) {
+		dev_dbg(dev,"resuming\n");
+		error = dev-&gt;bus-&gt;resume(dev);
+	}
+
+	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;resume) {
+		dev_dbg(dev,"resuming\n");
+		error = dev-&gt;type-&gt;resume(dev);
+	}
+
+	if (!error &amp;&amp; dev-&gt;class &amp;&amp; dev-&gt;class-&gt;resume) {
+		dev_dbg(dev,"class resume\n");
+		error = dev-&gt;class-&gt;resume(dev);
+	}
+
+	up(&amp;dev-&gt;sem);
+
+	TRACE_RESUME(error);
+	return error;
+}
+
+
+static int resume_device_early(struct device * dev)
+{
+	int error = 0;
+
+	TRACE_DEVICE(dev);
+	TRACE_RESUME(0);
+	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume_early) {
+		dev_dbg(dev,"EARLY resume\n");
+		error = dev-&gt;bus-&gt;resume_early(dev);
+	}
+	TRACE_RESUME(error);
+	return error;
+}
+
+/*
+ * Resume the devices that have either not gone through
+ * the late suspend, or that did go through it but also
+ * went through the early resume
+ */
+static void dpm_resume(void)
+{
+	mutex_lock(&amp;dpm_list_mtx);
+	while(!list_empty(&amp;dpm_off)) {
+		struct list_head * entry = dpm_off.next;
+		struct device * dev = to_device(entry);
+
+		get_device(dev);
+		list_move_tail(entry, &amp;dpm_active);
+
+		mutex_unlock(&amp;dpm_list_mtx);
+		resume_device(dev);
+		mutex_lock(&amp;dpm_list_mtx);
+		put_device(dev);
+	}
+	mutex_unlock(&amp;dpm_list_mtx);
+}
+
+
+/**
+ *	device_resume - Restore state of each device in system.
+ *
+ *	Walk the dpm_off list, remove each entry, resume the device,
+ *	then add it to the dpm_active list.
+ */
+
+void device_resume(void)
+{
+	might_sleep();
+	mutex_lock(&amp;dpm_mtx);
+	dpm_resume();
+	mutex_unlock(&amp;dpm_mtx);
+}
+
+EXPORT_SYMBOL_GPL(device_resume);
+
+
+/**
+ *	dpm_power_up - Power on some devices.
+ *
+ *	Walk the dpm_off_irq list and power each device up. This
+ *	is used for devices that required they be powered down with
+ *	interrupts disabled. As devices are powered on, they are moved
+ *	to the dpm_active list.
+ *
+ *	Interrupts must be disabled when calling this.
+ */
+
+static void dpm_power_up(void)
+{
+	while(!list_empty(&amp;dpm_off_irq)) {
+		struct list_head * entry = dpm_off_irq.next;
+		struct device * dev = to_device(entry);
+
+		list_move_tail(entry, &amp;dpm_off);
+		resume_device_early(dev);
+	}
+}
+
+
+/**
+ *	device_power_up - Turn on all devices that need special attention.
+ *
+ *	Power on system devices then devices that required we shut them down
+ *	with interrupts disabled.
+ *	Called with interrupts disabled.
+ */
+
+void device_power_up(void)
+{
+	sysdev_resume();
+	dpm_power_up();
+}
+
+EXPORT_SYMBOL_GPL(device_power_up);
+
+
+/*------------------------- Suspend routines -------------------------*/
+
+/*
+ * The entries in the dpm_active list are in a depth first order, simply
+ * because children are guaranteed to be discovered after parents, and
+ * are inserted at the back of the list on discovery.
+ *
+ * All list on the suspend path are done in reverse order, so we operate
+ * on the leaves of the device tree (or forests, depending on how you want
+ * to look at it ;) first. As nodes are removed from the back of the list,
+ * they are inserted into the front of their destintation lists.
+ *
+ * Things are the reverse on the resume path - iterations are done in
+ * forward order, and nodes are inserted at the back of their destination
+ * lists. This way, the ancestors will be accessed before their descendents.
+ */
+
+static inline char *suspend_verb(u32 event)
+{
+	switch (event) {
+	case PM_EVENT_SUSPEND:	return "suspend";
+	case PM_EVENT_FREEZE:	return "freeze";
+	case PM_EVENT_PRETHAW:	return "prethaw";
+	default:		return "(unknown suspend event)";
+	}
+}
+
+
+static void
+suspend_device_dbg(struct device *dev, pm_message_t state, char *info)
+{
+	dev_dbg(dev, "%s%s%s\n", info, suspend_verb(state.event),
+		((state.event == PM_EVENT_SUSPEND) &amp;&amp; device_may_wakeup(dev)) ?
+		", may wakeup" : "");
+}
+
+/**
+ *	suspend_device - Save state of one device.
+ *	@dev:	Device.
+ *	@state:	Power state device is entering.
+ */
+
+static int suspend_device(struct device * dev, pm_message_t state)
+{
+	int error = 0;
+
+	down(&amp;dev-&gt;sem);
+	if (dev-&gt;power.power_state.event) {
+		dev_dbg(dev, "PM: suspend %d--&gt;%d\n",
+			dev-&gt;power.power_state.event, state.event);
+	}
+
+	if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;suspend) {
+		suspend_device_dbg(dev, state, "class ");
+		error = dev-&gt;class-&gt;suspend(dev, state);
+		suspend_report_result(dev-&gt;class-&gt;suspend, error);
+	}
+
+	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;suspend) {
+		suspend_device_dbg(dev, state, "type ");
+		error = dev-&gt;type-&gt;suspend(dev, state);
+		suspend_report_result(dev-&gt;type-&gt;suspend, error);
+	}
+
+	if (!error &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend) {
+		suspend_device_dbg(dev, state, "");
+		error = dev-&gt;bus-&gt;suspend(dev, state);
+		suspend_report_result(dev-&gt;bus-&gt;suspend, error);
+	}
+	up(&amp;dev-&gt;sem);
+	return error;
+}
+
+
+/*
+ * This is called with interrupts off, only a single CPU
+ * running. We can't acquire a mutex or semaphore (and we don't
+ * need the protection)
+ */
+static int suspend_device_late(struct device *dev, pm_message_t state)
+{
+	int error = 0;
+
+	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend_late) {
+		suspend_device_dbg(dev, state, "LATE ");
+		error = dev-&gt;bus-&gt;suspend_late(dev, state);
+		suspend_report_result(dev-&gt;bus-&gt;suspend_late, error);
+	}
+	return error;
+}
+
+/**
+ *	device_suspend - Save state and stop all devices in system.
+ *	@state:		Power state to put each device in.
+ *
+ *	Walk the dpm_active list, call -&gt;suspend() for each device, and move
+ *	it to the dpm_off list.
+ *
+ *	(For historical reasons, if it returns -EAGAIN, that used to mean
+ *	that the device would be called again with interrupts disabled.
+ *	These days, we use the "suspend_late()" callback for that, so we
+ *	print a warning and consider it an error).
+ *
+ *	If we get a different error, try and back out.
+ *
+ *	If we hit a failure with any of the devices, call device_resume()
+ *	above to bring the suspended devices back to life.
+ *
+ */
+
+int device_suspend(pm_message_t state)
+{
+	int error = 0;
+
+	might_sleep();
+	mutex_lock(&amp;dpm_mtx);
+	mutex_lock(&amp;dpm_list_mtx);
+	while (!list_empty(&amp;dpm_active) &amp;&amp; error == 0) {
+		struct list_head * entry = dpm_active.prev;
+		struct device * dev = to_device(entry);
+
+		get_device(dev);
+		mutex_unlock(&amp;dpm_list_mtx);
+
+		error = suspend_device(dev, state);
+
+		mutex_lock(&amp;dpm_list_mtx);
+
+		/* Check if the device got removed */
+		if (!list_empty(&amp;dev-&gt;power.entry)) {
+			/* Move it to the dpm_off list */
+			if (!error)
+				list_move(&amp;dev-&gt;power.entry, &amp;dpm_off);
+		}
+		if (error)
+			printk(KERN_ERR "Could not suspend device %s: "
+				"error %d%s\n",
+				kobject_name(&amp;dev-&gt;kobj), error,
+				error == -EAGAIN ? " (please convert to suspend_late)" : "");
+		put_device(dev);
+	}
+	mutex_unlock(&amp;dpm_list_mtx);
+	if (error)
+		dpm_resume();
+
+	mutex_unlock(&amp;dpm_mtx);
+	return error;
+}
+
+EXPORT_SYMBOL_GPL(device_suspend);
+
+/**
+ *	device_power_down - Shut down special devices.
+ *	@state:		Power state to enter.
+ *
+ *	Walk the dpm_off_irq list, calling -&gt;power_down() for each device that
+ *	couldn't power down the device with interrupts enabled. When we're
+ *	done, power down system devices.
+ */
+
+int device_power_down(pm_message_t state)
+{
+	int error = 0;
+	struct device * dev;
+
+	while (!list_empty(&amp;dpm_off)) {
+		struct list_head * entry = dpm_off.prev;
+
+		dev = to_device(entry);
+		error = suspend_device_late(dev, state);
+		if (error)
+			goto Error;
+		list_move(&amp;dev-&gt;power.entry, &amp;dpm_off_irq);
+	}
+
+	error = sysdev_suspend(state);
+ Done:
+	return error;
+ Error:
+	printk(KERN_ERR "Could not power down device %s: "
+		"error %d\n", kobject_name(&amp;dev-&gt;kobj), error);
+	dpm_power_up();
+	goto Done;
+}
+
+EXPORT_SYMBOL_GPL(device_power_down);
+
+void __suspend_report_result(const char *function, void *fn, int ret)
+{
+	if (ret) {
+		printk(KERN_ERR "%s(): ", function);
+		print_fn_descriptor_symbol("%s() returns ", (unsigned long)fn);
+		printk("%d\n", ret);
+	}
+}
+EXPORT_SYMBOL_GPL(__suspend_report_result);
diff --git a/drivers/base/power/power.h b/drivers/base/power/power.h
index 49e64dbcce96..5c4efd493fa5 100644
--- a/drivers/base/power/power.h
+++ b/drivers/base/power/power.h
@@ -11,32 +11,11 @@ extern void device_shutdown(void);
  * main.c
  */
 
-/*
- * Used to synchronize global power management operations.
- */
-extern struct mutex dpm_mtx;
-
-/*
- * Used to serialize changes to the dpm_* lists.
- */
-extern struct mutex dpm_list_mtx;
-
-/*
- * The PM lists.
- */
-extern struct list_head dpm_active;
-extern struct list_head dpm_off;
-extern struct list_head dpm_off_irq;
-
-
-static inline struct dev_pm_info * to_pm_info(struct list_head * entry)
-{
-	return container_of(entry, struct dev_pm_info, entry);
-}
+extern struct list_head dpm_active;	/* The active device list */
 
 static inline struct device * to_device(struct list_head * entry)
 {
-	return container_of(to_pm_info(entry), struct device, power);
+	return container_of(entry, struct device, power.entry);
 }
 
 extern int device_pm_add(struct device *);
@@ -49,13 +28,6 @@ extern void device_pm_remove(struct device *);
 extern int dpm_sysfs_add(struct device *);
 extern void dpm_sysfs_remove(struct device *);
 
-/*
- * resume.c
- */
-
-extern void dpm_resume(void);
-extern void dpm_power_up(void);
-
 #else /* CONFIG_PM_SLEEP */
 
 
diff --git a/drivers/base/power/resume.c b/drivers/base/power/resume.c
deleted file mode 100644
index 67948bac9938..000000000000
--- a/drivers/base/power/resume.c
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * resume.c - Functions for waking devices up.
- *
- * Copyright (c) 2003 Patrick Mochel
- * Copyright (c) 2003 Open Source Development Labs
- *
- * This file is released under the GPLv2
- *
- */
-
-#include &lt;linux/device.h&gt;
-#include &lt;linux/resume-trace.h&gt;
-#include "../base.h"
-#include "power.h"
-
-
-/**
- *	resume_device - Restore state for one device.
- *	@dev:	Device.
- *
- */
-
-static int resume_device(struct device * dev)
-{
-	int error = 0;
-
-	TRACE_DEVICE(dev);
-	TRACE_RESUME(0);
-
-	down(&amp;dev-&gt;sem);
-
-	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume) {
-		dev_dbg(dev,"resuming\n");
-		error = dev-&gt;bus-&gt;resume(dev);
-	}
-
-	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;resume) {
-		dev_dbg(dev,"resuming\n");
-		error = dev-&gt;type-&gt;resume(dev);
-	}
-
-	if (!error &amp;&amp; dev-&gt;class &amp;&amp; dev-&gt;class-&gt;resume) {
-		dev_dbg(dev,"class resume\n");
-		error = dev-&gt;class-&gt;resume(dev);
-	}
-
-	up(&amp;dev-&gt;sem);
-
-	TRACE_RESUME(error);
-	return error;
-}
-
-
-static int resume_device_early(struct device * dev)
-{
-	int error = 0;
-
-	TRACE_DEVICE(dev);
-	TRACE_RESUME(0);
-	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;resume_early) {
-		dev_dbg(dev,"EARLY resume\n");
-		error = dev-&gt;bus-&gt;resume_early(dev);
-	}
-	TRACE_RESUME(error);
-	return error;
-}
-
-/*
- * Resume the devices that have either not gone through
- * the late suspend, or that did go through it but also
- * went through the early resume
- */
-void dpm_resume(void)
-{
-	mutex_lock(&amp;dpm_list_mtx);
-	while(!list_empty(&amp;dpm_off)) {
-		struct list_head * entry = dpm_off.next;
-		struct device * dev = to_device(entry);
-
-		get_device(dev);
-		list_move_tail(entry, &amp;dpm_active);
-
-		mutex_unlock(&amp;dpm_list_mtx);
-		resume_device(dev);
-		mutex_lock(&amp;dpm_list_mtx);
-		put_device(dev);
-	}
-	mutex_unlock(&amp;dpm_list_mtx);
-}
-
-
-/**
- *	device_resume - Restore state of each device in system.
- *
- *	Walk the dpm_off list, remove each entry, resume the device,
- *	then add it to the dpm_active list.
- */
-
-void device_resume(void)
-{
-	might_sleep();
-	mutex_lock(&amp;dpm_mtx);
-	dpm_resume();
-	mutex_unlock(&amp;dpm_mtx);
-}
-
-EXPORT_SYMBOL_GPL(device_resume);
-
-
-/**
- *	dpm_power_up - Power on some devices.
- *
- *	Walk the dpm_off_irq list and power each device up. This
- *	is used for devices that required they be powered down with
- *	interrupts disabled. As devices are powered on, they are moved
- *	to the dpm_active list.
- *
- *	Interrupts must be disabled when calling this.
- */
-
-void dpm_power_up(void)
-{
-	while(!list_empty(&amp;dpm_off_irq)) {
-		struct list_head * entry = dpm_off_irq.next;
-		struct device * dev = to_device(entry);
-
-		list_move_tail(entry, &amp;dpm_off);
-		resume_device_early(dev);
-	}
-}
-
-
-/**
- *	device_power_up - Turn on all devices that need special attention.
- *
- *	Power on system devices then devices that required we shut them down
- *	with interrupts disabled.
- *	Called with interrupts disabled.
- */
-
-void device_power_up(void)
-{
-	sysdev_resume();
-	dpm_power_up();
-}
-
-EXPORT_SYMBOL_GPL(device_power_up);
-
-
diff --git a/drivers/base/power/suspend.c b/drivers/base/power/suspend.c
deleted file mode 100644
index 204517afb15e..000000000000
--- a/drivers/base/power/suspend.c
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- * suspend.c - Functions for putting devices to sleep.
- *
- * Copyright (c) 2003 Patrick Mochel
- * Copyright (c) 2003 Open Source Development Labs
- *
- * This file is released under the GPLv2
- *
- */
-
-#include &lt;linux/device.h&gt;
-#include &lt;linux/kallsyms.h&gt;
-#include &lt;linux/pm.h&gt;
-#include "../base.h"
-#include "power.h"
-
-/*
- * The entries in the dpm_active list are in a depth first order, simply
- * because children are guaranteed to be discovered after parents, and
- * are inserted at the back of the list on discovery.
- *
- * All list on the suspend path are done in reverse order, so we operate
- * on the leaves of the device tree (or forests, depending on how you want
- * to look at it ;) first. As nodes are removed from the back of the list,
- * they are inserted into the front of their destintation lists.
- *
- * Things are the reverse on the resume path - iterations are done in
- * forward order, and nodes are inserted at the back of their destination
- * lists. This way, the ancestors will be accessed before their descendents.
- */
-
-static inline char *suspend_verb(u32 event)
-{
-	switch (event) {
-	case PM_EVENT_SUSPEND:	return "suspend";
-	case PM_EVENT_FREEZE:	return "freeze";
-	case PM_EVENT_PRETHAW:	return "prethaw";
-	default:		return "(unknown suspend event)";
-	}
-}
-
-
-static void
-suspend_device_dbg(struct device *dev, pm_message_t state, char *info)
-{
-	dev_dbg(dev, "%s%s%s\n", info, suspend_verb(state.event),
-		((state.event == PM_EVENT_SUSPEND) &amp;&amp; device_may_wakeup(dev)) ?
-		", may wakeup" : "");
-}
-
-/**
- *	suspend_device - Save state of one device.
- *	@dev:	Device.
- *	@state:	Power state device is entering.
- */
-
-static int suspend_device(struct device * dev, pm_message_t state)
-{
-	int error = 0;
-
-	down(&amp;dev-&gt;sem);
-	if (dev-&gt;power.power_state.event) {
-		dev_dbg(dev, "PM: suspend %d--&gt;%d\n",
-			dev-&gt;power.power_state.event, state.event);
-	}
-
-	if (dev-&gt;class &amp;&amp; dev-&gt;class-&gt;suspend) {
-		suspend_device_dbg(dev, state, "class ");
-		error = dev-&gt;class-&gt;suspend(dev, state);
-		suspend_report_result(dev-&gt;class-&gt;suspend, error);
-	}
-
-	if (!error &amp;&amp; dev-&gt;type &amp;&amp; dev-&gt;type-&gt;suspend) {
-		suspend_device_dbg(dev, state, "type ");
-		error = dev-&gt;type-&gt;suspend(dev, state);
-		suspend_report_result(dev-&gt;type-&gt;suspend, error);
-	}
-
-	if (!error &amp;&amp; dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend) {
-		suspend_device_dbg(dev, state, "");
-		error = dev-&gt;bus-&gt;suspend(dev, state);
-		suspend_report_result(dev-&gt;bus-&gt;suspend, error);
-	}
-	up(&amp;dev-&gt;sem);
-	return error;
-}
-
-
-/*
- * This is called with interrupts off, only a single CPU
- * running. We can't acquire a mutex or semaphore (and we don't
- * need the protection)
- */
-static int suspend_device_late(struct device *dev, pm_message_t state)
-{
-	int error = 0;
-
-	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;suspend_late) {
-		suspend_device_dbg(dev, state, "LATE ");
-		error = dev-&gt;bus-&gt;suspend_late(dev, state);
-		suspend_report_result(dev-&gt;bus-&gt;suspend_late, error);
-	}
-	return error;
-}
-
-/**
- *	device_suspend - Save state and stop all devices in system.
- *	@state:		Power state to put each device in.
- *
- *	Walk the dpm_active list, call -&gt;suspend() for each device, and move
- *	it to the dpm_off list.
- *
- *	(For historical reasons, if it returns -EAGAIN, that used to mean
- *	that the device would be called again with interrupts disabled.
- *	These days, we use the "suspend_late()" callback for that, so we
- *	print a warning and consider it an error).
- *
- *	If we get a different error, try and back out.
- *
- *	If we hit a failure with any of the devices, call device_resume()
- *	above to bring the suspended devices back to life.
- *
- */
-
-int device_suspend(pm_message_t state)
-{
-	int error = 0;
-
-	might_sleep();
-	mutex_lock(&amp;dpm_mtx);
-	mutex_lock(&amp;dpm_list_mtx);
-	while (!list_empty(&amp;dpm_active) &amp;&amp; error == 0) {
-		struct list_head * entry = dpm_active.prev;
-		struct device * dev = to_device(entry);
-
-		get_device(dev);
-		mutex_unlock(&amp;dpm_list_mtx);
-
-		error = suspend_device(dev, state);
-
-		mutex_lock(&amp;dpm_list_mtx);
-
-		/* Check if the device got removed */
-		if (!list_empty(&amp;dev-&gt;power.entry)) {
-			/* Move it to the dpm_off list */
-			if (!error)
-				list_move(&amp;dev-&gt;power.entry, &amp;dpm_off);
-		}
-		if (error)
-			printk(KERN_ERR "Could not suspend device %s: "
-				"error %d%s\n",
-				kobject_name(&amp;dev-&gt;kobj), error,
-				error == -EAGAIN ? " (please convert to suspend_late)" : "");
-		put_device(dev);
-	}
-	mutex_unlock(&amp;dpm_list_mtx);
-	if (error)
-		dpm_resume();
-
-	mutex_unlock(&amp;dpm_mtx);
-	return error;
-}
-
-EXPORT_SYMBOL_GPL(device_suspend);
-
-/**
- *	device_power_down - Shut down special devices.
- *	@state:		Power state to enter.
- *
- *	Walk the dpm_off_irq list, calling -&gt;power_down() for each device that
- *	couldn't power down the device with interrupts enabled. When we're
- *	done, power down system devices.
- */
-
-int device_power_down(pm_message_t state)
-{
-	int error = 0;
-	struct device * dev;
-
-	while (!list_empty(&amp;dpm_off)) {
-		struct list_head * entry = dpm_off.prev;
-
-		dev = to_device(entry);
-		error = suspend_device_late(dev, state);
-		if (error)
-			goto Error;
-		list_move(&amp;dev-&gt;power.entry, &amp;dpm_off_irq);
-	}
-
-	error = sysdev_suspend(state);
- Done:
-	return error;
- Error:
-	printk(KERN_ERR "Could not power down device %s: "
-		"error %d\n", kobject_name(&amp;dev-&gt;kobj), error);
-	dpm_power_up();
-	goto Done;
-}
-
-EXPORT_SYMBOL_GPL(device_power_down);
-
-void __suspend_report_result(const char *function, void *fn, int ret)
-{
-	if (ret) {
-		printk(KERN_ERR "%s(): ", function);
-		print_fn_descriptor_symbol("%s() returns ", (unsigned long)fn);
-		printk("%d\n", ret);
-	}
-}
-EXPORT_SYMBOL_GPL(__suspend_report_result);</pre><hr><pre>commit 7d2c592609a7da950b458403f1936d382f38ff9c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 20 10:48:05 2007 -0400

    USB: disable autosuspend by default for non-hubs
    
    This patch (as965) disables autosuspend by default for all USB devices
    other than hubs.  We are seeing too many devices that can't suspend or
    resume properly, the blacklist is growing unreasonably quickly, and
    this sort of thing should be handled in userspace.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 7f17d0fd76c0..ebf3dc20110a 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -152,4 +152,10 @@ void usb_detect_quirks(struct usb_device *udev)
 	/* do any special quirk handling here if needed */
 	if (udev-&gt;quirks &amp; USB_QUIRK_NO_AUTOSUSPEND)
 		usb_autosuspend_quirk(udev);
+
+	/* By default, disable autosuspend for all non-hubs */
+#ifdef	CONFIG_USB_SUSPEND
+	if (udev-&gt;descriptor.bDeviceClass != USB_CLASS_HUB)
+		udev-&gt;autosuspend_delay = -1;
+#endif
 }</pre><hr><pre>commit c269b6abd65c24517b70ccc9430c4c50dbc0dc84
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 4 10:12:44 2007 -0400

    USB: prevent Genesys USB-IDE from autosuspending
    
    This patch (as986) prevents the troublesome Genesys USB-IDE adapter
    from autosuspending.  It may not be necessary for all such devices,
    but the one in Bugzilla #8892 sometimes fails to resume.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index af3b627a93cf..e388cbceaad9 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -70,6 +70,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x05cc, 0x2267), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 	/* Ultima Electronics Corp.*/
 	{ USB_DEVICE(0x05d8, 0x4005), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+
+	/* Genesys USB-to-IDE */
+	{ USB_DEVICE(0x0503, 0x0702), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+
 	/* Agfa Snapscan1212u */
 	{ USB_DEVICE(0x06bd, 0x2061), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 	/* Seagate RSS LLC */</pre>
    <div class="pagination">
        <a href='2_102.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><span>[103]</span><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_104.html'>Next&gt;&gt;</a>
    <div>
</body>
