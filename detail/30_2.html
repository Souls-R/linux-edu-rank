<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Auburn University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Auburn University</h1>
    <div class="pagination">
        <a href='30.html'>&lt;&lt;Prev</a><a href='30.html'>1</a><span>[2]</span><a href='30_3.html'>3</a><a href='30_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b31210d737f383c14a02b20ab68e1a5770818f2d
Author: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
Date:   Sun Nov 1 13:02:59 2009 -0300

    V4L/DVB (13265): gspca_mr97310a: Partly back off red gain change for Sakar Digital VGA camera
    
    gspca_mr97310a: Partly back off red gain change for Sakar Digital VGA camera
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
    Signed-off-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index a97061a9e44a..57ea1c772214 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -769,7 +769,7 @@ static int start_vga_cam(struct gspca_dev *gspca_dev)
 			{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,
 				/* adjusted blue, green, red gain correct
 				   too much blue from the Sakar Digital */
-				0x05, 0x01, 0x05}, 8}
+				0x05, 0x01, 0x04}, 8}
 		};
 
 		const struct sensor_w_data color_no_adj[] = {</pre><hr><pre>commit 64f4d9a367b4fe329ba78e3171d1abb1338a951f
Author: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
Date:   Fri Oct 30 04:43:39 2009 -0300

    V4L/DVB (13245): gspca_mr97310a: Change blue gain setting for Sakar Digital VGA camera
    
    gspca_mr97310a: Change blue gain setting for Sakar Digital VGA camera
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
    Signed-off-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index b66169256dc4..a97061a9e44a 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -78,6 +78,7 @@ struct sd {
 	u8 cam_type;	/* 0 is CIF and 1 is VGA */
 	u8 sensor_type;	/* We use 0 and 1 here, too. */
 	u8 do_lcd_stop;
+	u8 adj_colors;
 
 	int brightness;
 	u16 exposure;
@@ -525,6 +526,7 @@ static int sd_config(struct gspca_dev *gspca_dev,
 
 		sd-&gt;sensor_type = 1;
 		sd-&gt;do_lcd_stop = 0;
+		sd-&gt;adj_colors = 0;
 		if ((gspca_dev-&gt;usb_buf[0] != 0x03) &amp;&amp;
 					(gspca_dev-&gt;usb_buf[0] != 0x04)) {
 			PDEBUG(D_ERR, "Unknown VGA Sensor id Byte 0: %02x",
@@ -532,6 +534,10 @@ static int sd_config(struct gspca_dev *gspca_dev,
 			PDEBUG(D_ERR, "Defaults assumed, may not work");
 			PDEBUG(D_ERR, "Please report this");
 		}
+		/* Sakar Digital color needs to be adjusted. */
+		if ((gspca_dev-&gt;usb_buf[0] == 0x03) &amp;&amp;
+					(gspca_dev-&gt;usb_buf[1] == 0x50))
+			sd-&gt;adj_colors = 1;
 		if (gspca_dev-&gt;usb_buf[0] == 0x04) {
 			sd-&gt;do_lcd_stop = 1;
 			switch (gspca_dev-&gt;usb_buf[1]) {
@@ -759,9 +765,20 @@ static int start_vga_cam(struct gspca_dev *gspca_dev)
 		err_code = sensor_write_regs(gspca_dev, vga_sensor0_init_data,
 					 ARRAY_SIZE(vga_sensor0_init_data));
 	} else {	/* sd-&gt;sensor_type = 1 */
-		const struct sensor_w_data vga_sensor1_init_data[] = {
+		const struct sensor_w_data color_adj[] = {
+			{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,
+				/* adjusted blue, green, red gain correct
+				   too much blue from the Sakar Digital */
+				0x05, 0x01, 0x05}, 8}
+		};
+
+		const struct sensor_w_data color_no_adj[] = {
 			{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,
-				0x07, 0x00, 0x01}, 8},
+				/* default blue, green, red gain settings */
+				0x07, 0x00, 0x01}, 8}
+		};
+
+		const struct sensor_w_data vga_sensor1_init_data[] = {
 			{0x11, 0x04, {0x01}, 1},
 			/*{0x0a, 0x00, {0x00, 0x01, 0x00, 0x00, 0x01, */
 			{0x0a, 0x00, {0x01, 0x06, 0x00, 0x00, 0x01,
@@ -771,6 +788,17 @@ static int start_vga_cam(struct gspca_dev *gspca_dev)
 			{0x11, 0x04, {0x01}, 1},
 			{0, 0, {0}, 0}
 		};
+
+		if (sd-&gt;adj_colors)
+			err_code = sensor_write_regs(gspca_dev, color_adj,
+					 ARRAY_SIZE(color_adj));
+		else
+			err_code = sensor_write_regs(gspca_dev, color_no_adj,
+					 ARRAY_SIZE(color_no_adj));
+
+		if (err_code &lt; 0)
+			return err_code;
+
 		err_code = sensor_write_regs(gspca_dev, vga_sensor1_init_data,
 					 ARRAY_SIZE(vga_sensor1_init_data));
 	}</pre><hr><pre>commit 1160a3818ec387ddadfd173b3bceea654a474b74
Author: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
Date:   Fri Oct 30 04:29:56 2009 -0300

    V4L/DVB (13244): gspca_mr97310a: Fix / update some comments
    
    gspca_mr97310a: Fix / update some comments
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
    Signed-off-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index d316b56e396e..b66169256dc4 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -18,7 +18,9 @@
  * Several previously unsupported cameras are owned and have been tested by
  * Hans de Goede &lt;hdgoede@redhat.com&gt; and
  * Thomas Kaiser &lt;thomas@kaiser-linux.li&gt; and
- * Theodore Kilgore &lt;kilgota@auburn.edu&gt;
+ * Theodore Kilgore &lt;kilgota@auburn.edu&gt; and
+ * Edmond Rodriguez &lt;erodrig_97@yahoo.com&gt; and
+ * Aurelien Jacobs &lt;aurel@gnuage.org&gt;
  *
  * The MR97311A support in gspca/mars.c has been helpful in understanding some
  * of the registers in these cameras.
@@ -105,8 +107,8 @@ static void setgain(struct gspca_dev *gspca_dev);
 
 /* V4L2 controls supported by the driver */
 static struct ctrl sd_ctrls[] = {
-/* Seprate brightness control description for Argus QuickClix as it has
-   different limits from to other mr97310a camera's */
+/* Separate brightness control description for Argus QuickClix as it has
+   different limits from the other mr97310a cameras */
 	{
 #define NORM_BRIGHTNESS_IDX 0
 		{
@@ -428,7 +430,7 @@ static int isoc_enable(struct gspca_dev *gspca_dev)
 	return mr_write(gspca_dev, 2);
 }
 
-/* this function is called at probe time */
+/* This function is called at probe time */
 static int sd_config(struct gspca_dev *gspca_dev,
 		     const struct usb_device_id *id)
 {
@@ -441,11 +443,11 @@ static int sd_config(struct gspca_dev *gspca_dev,
 	cam-&gt;nmodes = ARRAY_SIZE(vga_mode);
 	sd-&gt;do_lcd_stop = 0;
 
-	/* Now, logical layout of the driver must fall sacrifice to the
-	 * realities of the hardware supported. We have to sort out several
-	 * cameras which share the USB ID but are in fact different inside.
-	 * We need to start the initialization process for the cameras in
-	 * order to classify them. Some of the supported cameras require the
+	/* Several of the supported CIF cameras share the same USB ID but
+	 * require different initializations and different control settings.
+	 * The same is true of the VGA cameras. Therefore, we are forced
+	 * to start the initialization process in order to determine which
+	 * camera is present. Some of the supported cameras require the
 	 * memory pointer to be set to 0 as the very first item of business
 	 * or else they will not stream. So we do that immediately.
 	 */
@@ -464,9 +466,10 @@ static int sd_config(struct gspca_dev *gspca_dev,
 		if (err_code &lt; 0)
 			return err_code;
 		/*
-		 * The various CIF cameras share the same USB ID but use
-		 * different init routines and different controls. We need to
-		 * detect which one is connected!
+		 * All but one of the known CIF cameras share the same USB ID,
+		 * but two different init routines are in use, and the control
+		 * settings are different, too. We need to detect which camera
+		 * of the two known varieties is connected!
 		 *
 		 * A list of known CIF cameras follows. They all report either
 		 * 0002 for type 0 or 0003 for type 1.
@@ -481,6 +484,7 @@ static int sd_config(struct gspca_dev *gspca_dev,
 		 * Vivitar Mini		1		T. Kilgore
 		 * Elta-Media 8212dc	1		T. Kaiser
 		 * Philips dig. keych.	1		T. Kilgore
+		 * Trust Spyc@m 100	1		A. Jacobs
 		 */
 		switch (gspca_dev-&gt;usb_buf[1]) {
 		case 2:</pre><hr><pre>commit b3e440eef8a842736d63cc6a6594d80dfbb75fd9
Author: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
Date:   Fri Oct 9 03:54:49 2009 -0300

    V4L/DVB (13139): gspca_mr97310a: Improve VGA sensor type detection
    
    Improve (and also simplify :) gspca_mr97310a: VGA sensor type detection.
    As it was still failing on some machines (not with some cams, but on
    some machines interesting enough).
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
    Signed-off-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index f4c83b367900..abc56e37efcb 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -431,12 +431,13 @@ static int sd_config(struct gspca_dev *gspca_dev,
 	if (err_code &lt; 0)
 		return err_code;
 
+	err_code = stream_start(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
+
 	if (id-&gt;idProduct == 0x010e) {
 		sd-&gt;cam_type = CAM_TYPE_CIF;
 		cam-&gt;nmodes--;
-		err_code = stream_start(gspca_dev);
-		if (err_code &lt; 0)
-			return err_code;
 		err_code = cam_get_response16(gspca_dev, 0x06, 1);
 		if (err_code &lt; 0)
 			return err_code;
@@ -476,74 +477,52 @@ static int sd_config(struct gspca_dev *gspca_dev,
 	} else {
 		sd-&gt;cam_type = CAM_TYPE_VGA;
 
-		/*
-		 * VGA cams also have two different sensor types. Detection
-		 * requires a two-step process.
-		 *
-		 * Here is a report on the result of the first test for the
-		 * known MR97310a VGA cameras. If you have another to report,
-		 * please do.
-		 *
-		 * Name		byte just read			sd-&gt;sensor_type
-		 *				sd-&gt;do_lcd_stop
-		 * Aiptek Pencam VGA+	0x31		0	1
-		 * ION digital		0x31		0	1
-		 * Sakar Digital 77379	0x31		0	1
-		 * Argus DC-1620	0x30		1	0
-		 * Argus QuickClix	0x30		1	1 (see note)
-		 * Note that this test fails to distinguish sd-&gt;sensor_type
-		 * for the two cameras which have reported 0x30.
-		 * Another test will be run on them.
-		 * But the sd-&gt;do_lcd_stop setting is needed, too.
-		 */
-
-		err_code = cam_get_response16(gspca_dev, 0x20, 1);
-		if (err_code &lt; 0)
-			return err_code;
-		sd-&gt;sensor_type = gspca_dev-&gt;usb_buf[0] &amp; 1;
-		sd-&gt;do_lcd_stop = (~gspca_dev-&gt;usb_buf[0]) &amp; 1;
-		err_code = stream_start(gspca_dev);
+		err_code = cam_get_response16(gspca_dev, 0x07, 1);
 		if (err_code &lt; 0)
 			return err_code;
 
 		/*
-		 * A second test can now resolve any remaining ambiguity in the
-		 * identification of the camera's sensor type. Specifically,
-		 * it now gives the correct sensor_type for the Argus DC-1620
-		 * and the Argus QuickClix.
-		 *
-		 * This second test is only run if needed,
-		 * but additional results from testing some other cameras
-		 * are recorded here, too:
+		 * Here is a table of the responses to the previous command
+		 * from the known MR97310A VGA cameras.
 		 *
 		 * Name			gspca_dev-&gt;usb_buf[]	sd-&gt;sensor_type
+		 *				sd-&gt;do_lcd_stop
+		 * Aiptek Pencam VGA+	0300		0		1
+		 * ION digital		0350		0		1
+		 * Argus DC-1620	0450		1		0
+		 * Argus QuickClix	0420		1		1
 		 *
-		 * Aiptek Pencam VGA+	0300	(test not needed)	1
-		 * ION digital		0350	(test not needed)	1
-		 * Argus DC-1620	0450	(remains as type 0)	0
-		 * Argus QuickClix	0420	(corrected to type 1)	1
+		 * Based upon these results, we assume default settings
+		 * and then correct as necessary, as follows.
 		 *
-		 * This test even seems able to distinguish one VGA cam from
-		 * another which may be useful. However, the CIF type 1 cameras
-		 * do not like it.
 		 */
 
-		if (!sd-&gt;sensor_type) {
-			err_code = cam_get_response16(gspca_dev, 0x07, 1);
-			if (err_code &lt; 0)
-				return err_code;
-
+		sd-&gt;sensor_type = 1;
+		sd-&gt;do_lcd_stop = 0;
+		if ((gspca_dev-&gt;usb_buf[0] != 0x03) &amp;&amp;
+					(gspca_dev-&gt;usb_buf[0] != 0x04)) {
+			PDEBUG(D_ERR, "Unknown VGA Sensor id Byte 0: %02x",
+					gspca_dev-&gt;usb_buf[1]);
+			PDEBUG(D_ERR, "Defaults assumed, may not work");
+			PDEBUG(D_ERR, "Please report this");
+		}
+		if (gspca_dev-&gt;usb_buf[0] == 0x04) {
+			sd-&gt;do_lcd_stop = 1;
 			switch (gspca_dev-&gt;usb_buf[1]) {
 			case 0x50:
+				sd-&gt;sensor_type = 0;
+				PDEBUG(D_PROBE, "sensor_type corrected to 0");
 				break;
 			case 0x20:
-				sd-&gt;sensor_type = 1;
-				PDEBUG(D_PROBE, "sensor_type corrected to 1");
+				/* Nothing to do here. */
 				break;
 			default:
-				PDEBUG(D_ERR, "Unknown VGA Sensor id : %02x",
-				       gspca_dev-&gt;usb_buf[1]);
-				return -ENODEV;
+				PDEBUG(D_ERR,
+					"Unknown VGA Sensor id Byte 1: %02x",
+					gspca_dev-&gt;usb_buf[1]);
+				PDEBUG(D_ERR,
+					"Defaults assumed, may not work");
+				PDEBUG(D_ERR, "Please report this");
 			}
 		}
 		PDEBUG(D_PROBE, "MR97310A VGA camera detected, sensor: %d",</pre><hr><pre>commit 930bf78c20187f3cbbf0775cd317616c6b681a8a
Author: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
Date:   Mon Oct 5 05:11:35 2009 -0300

    V4L/DVB (13137): gspca_mr97310a: Add controls for vga cams with sensor type 0
    
    This patch adds controls for vga cams with sensor type 0, in order to
    correctly report the present controls, the probing of the sensor type
    has been moved from sd_start to sd_config, since this made the sensor
    type probing unreliable the detection method was changed.
    
    Note this requires the camera to enter streaming mode, so sd_config now
    briefly makes the camera stream.
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
    Signed-off-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index f8328b9efae5..f4c83b367900 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -1,23 +1,28 @@
 /*
  * Mars MR97310A library
  *
+ * The original mr97310a driver, which supported the Aiptek Pencam VGA+, is
  * Copyright (C) 2009 Kyle Guinn &lt;elyk03@gmail.com&gt;
  *
  * Support for the MR97310A cameras in addition to the Aiptek Pencam VGA+
  * and for the routines for detecting and classifying these various cameras,
+ * is Copyright (C) 2009 Theodore Kilgore &lt;kilgota@auburn.edu&gt;
  *
+ * Support for the control settings for the CIF cameras is
+ * Copyright (C) 2009 Hans de Goede &lt;hdgoede@redhat.com&gt; and
+ * Thomas Kaiser &lt;thomas@kaiser-linux.li&gt;
+ *
+ * Support for the control settings for the VGA cameras is
  * Copyright (C) 2009 Theodore Kilgore &lt;kilgota@auburn.edu&gt;
  *
- * Acknowledgements:
+ * Several previously unsupported cameras are owned and have been tested by
+ * Hans de Goede &lt;hdgoede@redhat.com&gt; and
+ * Thomas Kaiser &lt;thomas@kaiser-linux.li&gt; and
+ * Theodore Kilgore &lt;kilgota@auburn.edu&gt;
  *
  * The MR97311A support in gspca/mars.c has been helpful in understanding some
  * of the registers in these cameras.
  *
- * Hans de Goede &lt;hdgoede@redhat.com&gt; and
- * Thomas Kaiser &lt;thomas@kaiser-linux.li&gt;
- * have assisted with their experience. Each of them has also helped by
- * testing a previously unsupported camera.
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -40,11 +45,9 @@
 #define CAM_TYPE_CIF			0
 #define CAM_TYPE_VGA			1
 
-#define MR97310A_BRIGHTNESS_MIN		-254
-#define MR97310A_BRIGHTNESS_MAX		255
 #define MR97310A_BRIGHTNESS_DEFAULT	0
 
-#define MR97310A_EXPOSURE_MIN		300
+#define MR97310A_EXPOSURE_MIN		0
 #define MR97310A_EXPOSURE_MAX		4095
 #define MR97310A_EXPOSURE_DEFAULT	1000
 
@@ -82,6 +85,7 @@ struct sensor_w_data {
 	int len;
 };
 
+static void sd_stopN(struct gspca_dev *gspca_dev);
 static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val);
 static int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val);
 static int sd_setexposure(struct gspca_dev *gspca_dev, __s32 val);
@@ -94,14 +98,16 @@ static void setgain(struct gspca_dev *gspca_dev);
 
 /* V4L2 controls supported by the driver */
 static struct ctrl sd_ctrls[] = {
+/* Seprate brightness control description for Argus QuickClix as it has
+   different limits from to other mr97310a camera's */
 	{
-#define BRIGHTNESS_IDX 0
+#define NORM_BRIGHTNESS_IDX 0
 		{
 			.id = V4L2_CID_BRIGHTNESS,
 			.type = V4L2_CTRL_TYPE_INTEGER,
 			.name = "Brightness",
-			.minimum = MR97310A_BRIGHTNESS_MIN,
-			.maximum = MR97310A_BRIGHTNESS_MAX,
+			.minimum = -254,
+			.maximum = 255,
 			.step = 1,
 			.default_value = MR97310A_BRIGHTNESS_DEFAULT,
 			.flags = 0,
@@ -110,7 +116,22 @@ static struct ctrl sd_ctrls[] = {
 		.get = sd_getbrightness,
 	},
 	{
-#define EXPOSURE_IDX 1
+#define ARGUS_QC_BRIGHTNESS_IDX 1
+		{
+			.id = V4L2_CID_BRIGHTNESS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Brightness",
+			.minimum = 0,
+			.maximum = 15,
+			.step = 1,
+			.default_value = MR97310A_BRIGHTNESS_DEFAULT,
+			.flags = 0,
+		},
+		.set = sd_setbrightness,
+		.get = sd_getbrightness,
+	},
+	{
+#define EXPOSURE_IDX 2
 		{
 			.id = V4L2_CID_EXPOSURE,
 			.type = V4L2_CTRL_TYPE_INTEGER,
@@ -125,7 +146,7 @@ static struct ctrl sd_ctrls[] = {
 		.get = sd_getexposure,
 	},
 	{
-#define GAIN_IDX 2
+#define GAIN_IDX 3
 		{
 			.id = V4L2_CID_GAIN,
 			.type = V4L2_CTRL_TYPE_INTEGER,
@@ -230,12 +251,17 @@ static int sensor_write1(struct gspca_dev *gspca_dev, u8 reg, u8 data)
 	int rc;
 
 	buf = data;
-	rc = sensor_write_reg(gspca_dev, reg, 0x01, &amp;buf, 1);
+	if (sd-&gt;cam_type == CAM_TYPE_CIF) {
+		rc = sensor_write_reg(gspca_dev, reg, 0x01, &amp;buf, 1);
+		confirm_reg = sd-&gt;sensor_type ? 0x13 : 0x11;
+	} else {
+		rc = sensor_write_reg(gspca_dev, reg, 0x00, &amp;buf, 1);
+		confirm_reg = 0x11;
+	}
 	if (rc &lt; 0)
 		return rc;
 
 	buf = 0x01;
-	confirm_reg = sd-&gt;sensor_type ? 0x13 : 0x11;
 	rc = sensor_write_reg(gspca_dev, confirm_reg, 0x00, &amp;buf, 1);
 	if (rc &lt; 0)
 		return rc;
@@ -243,18 +269,26 @@ static int sensor_write1(struct gspca_dev *gspca_dev, u8 reg, u8 data)
 	return 0;
 }
 
-static int cam_get_response16(struct gspca_dev *gspca_dev)
+static int cam_get_response16(struct gspca_dev *gspca_dev, u8 reg, int verbose)
 {
-	__u8 *data = gspca_dev-&gt;usb_buf;
 	int err_code;
 
-	data[0] = 0x21;
+	gspca_dev-&gt;usb_buf[0] = reg;
 	err_code = mr_write(gspca_dev, 1);
 	if (err_code &lt; 0)
 		return err_code;
 
 	err_code = mr_read(gspca_dev, 16);
-	return err_code;
+	if (err_code &lt; 0)
+		return err_code;
+
+	if (verbose)
+		PDEBUG(D_PROBE, "Register: %02x reads %02x%02x%02x", reg,
+		       gspca_dev-&gt;usb_buf[0],
+		       gspca_dev-&gt;usb_buf[1],
+		       gspca_dev-&gt;usb_buf[2]);
+
+	return 0;
 }
 
 static int zero_the_pointer(struct gspca_dev *gspca_dev)
@@ -264,7 +298,7 @@ static int zero_the_pointer(struct gspca_dev *gspca_dev)
 	u8 status = 0;
 	int tries = 0;
 
-	err_code = cam_get_response16(gspca_dev);
+	err_code = cam_get_response16(gspca_dev, 0x21, 0);
 	if (err_code &lt; 0)
 		return err_code;
 
@@ -275,7 +309,7 @@ static int zero_the_pointer(struct gspca_dev *gspca_dev)
 	if (err_code &lt; 0)
 		return err_code;
 
-	err_code = cam_get_response16(gspca_dev);
+	err_code = cam_get_response16(gspca_dev, 0x21, 0);
 	if (err_code &lt; 0)
 		return err_code;
 
@@ -285,7 +319,7 @@ static int zero_the_pointer(struct gspca_dev *gspca_dev)
 	if (err_code &lt; 0)
 		return err_code;
 
-	err_code = cam_get_response16(gspca_dev);
+	err_code = cam_get_response16(gspca_dev, 0x21, 0);
 	if (err_code &lt; 0)
 		return err_code;
 
@@ -295,7 +329,7 @@ static int zero_the_pointer(struct gspca_dev *gspca_dev)
 	if (err_code &lt; 0)
 		return err_code;
 
-	err_code = cam_get_response16(gspca_dev);
+	err_code = cam_get_response16(gspca_dev, 0x21, 0);
 	if (err_code &lt; 0)
 		return err_code;
 
@@ -306,7 +340,7 @@ static int zero_the_pointer(struct gspca_dev *gspca_dev)
 		return err_code;
 
 	while (status != 0x0a &amp;&amp; tries &lt; 256) {
-		err_code = cam_get_response16(gspca_dev);
+		err_code = cam_get_response16(gspca_dev, 0x21, 0);
 		status = data[0];
 		tries++;
 		if (err_code &lt; 0)
@@ -323,7 +357,7 @@ static int zero_the_pointer(struct gspca_dev *gspca_dev)
 		if (err_code &lt; 0)
 			return err_code;
 
-		err_code = cam_get_response16(gspca_dev);
+		err_code = cam_get_response16(gspca_dev, 0x21, 0);
 		status = data[0];
 		tries++;
 		if (err_code &lt; 0)
@@ -342,22 +376,34 @@ static int zero_the_pointer(struct gspca_dev *gspca_dev)
 	return 0;
 }
 
-static u8 get_sensor_id(struct gspca_dev *gspca_dev)
+static int stream_start(struct gspca_dev *gspca_dev)
 {
-	int err_code;
-
-	gspca_dev-&gt;usb_buf[0] = 0x1e;
-	err_code = mr_write(gspca_dev, 1);
-	if (err_code &lt; 0)
-		return err_code;
+	gspca_dev-&gt;usb_buf[0] = 0x01;
+	gspca_dev-&gt;usb_buf[1] = 0x01;
+	return mr_write(gspca_dev, 2);
+}
 
-	err_code = mr_read(gspca_dev, 16);
-	if (err_code &lt; 0)
-		return err_code;
+static void stream_stop(struct gspca_dev *gspca_dev)
+{
+	gspca_dev-&gt;usb_buf[0] = 0x01;
+	gspca_dev-&gt;usb_buf[1] = 0x00;
+	if (mr_write(gspca_dev, 2) &lt; 0)
+		PDEBUG(D_ERR, "Stream Stop failed");
+}
 
-	PDEBUG(D_PROBE, "Byte zero reported is %01x", gspca_dev-&gt;usb_buf[0]);
+static void lcd_stop(struct gspca_dev *gspca_dev)
+{
+	gspca_dev-&gt;usb_buf[0] = 0x19;
+	gspca_dev-&gt;usb_buf[1] = 0x54;
+	if (mr_write(gspca_dev, 2) &lt; 0)
+		PDEBUG(D_ERR, "LCD Stop failed");
+}
 
-	return gspca_dev-&gt;usb_buf[0];
+static int isoc_enable(struct gspca_dev *gspca_dev)
+{
+	gspca_dev-&gt;usb_buf[0] = 0x00;
+	gspca_dev-&gt;usb_buf[1] = 0x4d;  /* ISOC transfering enable... */
+	return mr_write(gspca_dev, 2);
 }
 
 /* this function is called at probe time */
@@ -366,60 +412,172 @@ static int sd_config(struct gspca_dev *gspca_dev,
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	struct cam *cam;
-	__u8 *data = gspca_dev-&gt;usb_buf;
 	int err_code;
 
 	cam = &amp;gspca_dev-&gt;cam;
 	cam-&gt;cam_mode = vga_mode;
 	cam-&gt;nmodes = ARRAY_SIZE(vga_mode);
+	sd-&gt;do_lcd_stop = 0;
+
+	/* Now, logical layout of the driver must fall sacrifice to the
+	 * realities of the hardware supported. We have to sort out several
+	 * cameras which share the USB ID but are in fact different inside.
+	 * We need to start the initialization process for the cameras in
+	 * order to classify them. Some of the supported cameras require the
+	 * memory pointer to be set to 0 as the very first item of business
+	 * or else they will not stream. So we do that immediately.
+	 */
+	err_code = zero_the_pointer(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
 
 	if (id-&gt;idProduct == 0x010e) {
 		sd-&gt;cam_type = CAM_TYPE_CIF;
 		cam-&gt;nmodes--;
-
-		data[0] = 0x01;
-		data[1] = 0x01;
-		err_code = mr_write(gspca_dev, 2);
+		err_code = stream_start(gspca_dev);
+		if (err_code &lt; 0)
+			return err_code;
+		err_code = cam_get_response16(gspca_dev, 0x06, 1);
 		if (err_code &lt; 0)
 			return err_code;
-
-		msleep(200);
-		data[0] = get_sensor_id(gspca_dev);
 		/*
-		 * Known CIF cameras. If you have another to report, please do
+		 * The various CIF cameras share the same USB ID but use
+		 * different init routines and different controls. We need to
+		 * detect which one is connected!
 		 *
-		 * Name			byte just read		sd-&gt;sensor_type
-		 *					reported by
-		 * Sakar Spy-shot	0x28		T. Kilgore	0
-		 * Innovage		0xf5 (unstable)	T. Kilgore	0
-		 * Vivitar Mini		0x53		H. De Goede	0
-		 * Vivitar Mini		0x04 / 0x24	E. Rodriguez	0
-		 * Vivitar Mini		0x08		T. Kilgore	1
-		 * Elta-Media 8212dc	0x23		T. Kaiser	1
-		 * Philips dig. keych.	0x37		T. Kilgore	1
+		 * A list of known CIF cameras follows. They all report either
+		 * 0002 for type 0 or 0003 for type 1.
+		 * If you have another to report, please do
+		 *
+		 * Name		sd-&gt;sensor_type		reported by
+		 *
+		 * Sakar Spy-shot	0		T. Kilgore
+		 * Innovage		0		T. Kilgore
+		 * Vivitar Mini		0		H. De Goede
+		 * Vivitar Mini		0		E. Rodriguez
+		 * Vivitar Mini		1		T. Kilgore
+		 * Elta-Media 8212dc	1		T. Kaiser
+		 * Philips dig. keych.	1		T. Kilgore
 		 */
-		if ((data[0] &amp; 0x78) == 8 ||
-		    ((data[0] &amp; 0x2) == 0x2 &amp;&amp; data[0] != 0x53))
-			sd-&gt;sensor_type = 1;
-		else
+		switch (gspca_dev-&gt;usb_buf[1]) {
+		case 2:
 			sd-&gt;sensor_type = 0;
-
+			break;
+		case 3:
+			sd-&gt;sensor_type = 1;
+			break;
+		default:
+			PDEBUG(D_ERR, "Unknown CIF Sensor id : %02x",
+			       gspca_dev-&gt;usb_buf[1]);
+			return -ENODEV;
+		}
 		PDEBUG(D_PROBE, "MR97310A CIF camera detected, sensor: %d",
 		       sd-&gt;sensor_type);
+	} else {
+		sd-&gt;cam_type = CAM_TYPE_VGA;
 
-		if (force_sensor_type != -1) {
-			sd-&gt;sensor_type = !! force_sensor_type;
-			PDEBUG(D_PROBE, "Forcing sensor type to: %d",
-			       sd-&gt;sensor_type);
+		/*
+		 * VGA cams also have two different sensor types. Detection
+		 * requires a two-step process.
+		 *
+		 * Here is a report on the result of the first test for the
+		 * known MR97310a VGA cameras. If you have another to report,
+		 * please do.
+		 *
+		 * Name		byte just read			sd-&gt;sensor_type
+		 *				sd-&gt;do_lcd_stop
+		 * Aiptek Pencam VGA+	0x31		0	1
+		 * ION digital		0x31		0	1
+		 * Sakar Digital 77379	0x31		0	1
+		 * Argus DC-1620	0x30		1	0
+		 * Argus QuickClix	0x30		1	1 (see note)
+		 * Note that this test fails to distinguish sd-&gt;sensor_type
+		 * for the two cameras which have reported 0x30.
+		 * Another test will be run on them.
+		 * But the sd-&gt;do_lcd_stop setting is needed, too.
+		 */
+
+		err_code = cam_get_response16(gspca_dev, 0x20, 1);
+		if (err_code &lt; 0)
+			return err_code;
+		sd-&gt;sensor_type = gspca_dev-&gt;usb_buf[0] &amp; 1;
+		sd-&gt;do_lcd_stop = (~gspca_dev-&gt;usb_buf[0]) &amp; 1;
+		err_code = stream_start(gspca_dev);
+		if (err_code &lt; 0)
+			return err_code;
+
+		/*
+		 * A second test can now resolve any remaining ambiguity in the
+		 * identification of the camera's sensor type. Specifically,
+		 * it now gives the correct sensor_type for the Argus DC-1620
+		 * and the Argus QuickClix.
+		 *
+		 * This second test is only run if needed,
+		 * but additional results from testing some other cameras
+		 * are recorded here, too:
+		 *
+		 * Name			gspca_dev-&gt;usb_buf[]	sd-&gt;sensor_type
+		 *
+		 * Aiptek Pencam VGA+	0300	(test not needed)	1
+		 * ION digital		0350	(test not needed)	1
+		 * Argus DC-1620	0450	(remains as type 0)	0
+		 * Argus QuickClix	0420	(corrected to type 1)	1
+		 *
+		 * This test even seems able to distinguish one VGA cam from
+		 * another which may be useful. However, the CIF type 1 cameras
+		 * do not like it.
+		 */
+
+		if (!sd-&gt;sensor_type) {
+			err_code = cam_get_response16(gspca_dev, 0x07, 1);
+			if (err_code &lt; 0)
+				return err_code;
+
+			switch (gspca_dev-&gt;usb_buf[1]) {
+			case 0x50:
+				break;
+			case 0x20:
+				sd-&gt;sensor_type = 1;
+				PDEBUG(D_PROBE, "sensor_type corrected to 1");
+				break;
+			default:
+				PDEBUG(D_ERR, "Unknown VGA Sensor id : %02x",
+				       gspca_dev-&gt;usb_buf[1]);
+				return -ENODEV;
+			}
 		}
+		PDEBUG(D_PROBE, "MR97310A VGA camera detected, sensor: %d",
+		       sd-&gt;sensor_type);
+	}
+	/* Stop streaming as we've started it to probe the sensor type. */
+	sd_stopN(gspca_dev);
 
+	if (force_sensor_type != -1) {
+		sd-&gt;sensor_type = !!force_sensor_type;
+		PDEBUG(D_PROBE, "Forcing sensor type to: %d",
+		       sd-&gt;sensor_type);
+	}
+
+	/* Setup controls depending on camera type */
+	if (sd-&gt;cam_type == CAM_TYPE_CIF) {
+		/* No brightness for sensor_type 0 */
 		if (sd-&gt;sensor_type == 0)
-			gspca_dev-&gt;ctrl_dis = (1 &lt;&lt; BRIGHTNESS_IDX);
+			gspca_dev-&gt;ctrl_dis = (1 &lt;&lt; NORM_BRIGHTNESS_IDX) |
+					      (1 &lt;&lt; ARGUS_QC_BRIGHTNESS_IDX);
+		else
+			gspca_dev-&gt;ctrl_dis = (1 &lt;&lt; ARGUS_QC_BRIGHTNESS_IDX);
 	} else {
-		sd-&gt;cam_type = CAM_TYPE_VGA;
-		PDEBUG(D_PROBE, "MR97310A VGA camera detected");
-		gspca_dev-&gt;ctrl_dis = (1 &lt;&lt; BRIGHTNESS_IDX) |
-				      (1 &lt;&lt; EXPOSURE_IDX) | (1 &lt;&lt; GAIN_IDX);
+		/* All controls need to be disabled if VGA sensor_type is 0 */
+		if (sd-&gt;sensor_type == 0)
+			gspca_dev-&gt;ctrl_dis = (1 &lt;&lt; NORM_BRIGHTNESS_IDX) |
+					      (1 &lt;&lt; ARGUS_QC_BRIGHTNESS_IDX) |
+					      (1 &lt;&lt; EXPOSURE_IDX) |
+					      (1 &lt;&lt; GAIN_IDX);
+		else if (sd-&gt;do_lcd_stop)
+			/* Argus QuickClix has different brightness limits */
+			gspca_dev-&gt;ctrl_dis = (1 &lt;&lt; NORM_BRIGHTNESS_IDX);
+		else
+			gspca_dev-&gt;ctrl_dis = (1 &lt;&lt; ARGUS_QC_BRIGHTNESS_IDX);
 	}
 
 	sd-&gt;brightness = MR97310A_BRIGHTNESS_DEFAULT;
@@ -455,11 +613,6 @@ static int start_cif_cam(struct gspca_dev *gspca_dev)
 	};
 
 	/* Note: Some of the above descriptions guessed from MR97113A driver */
-	data[0] = 0x01;
-	data[1] = 0x01;
-	err_code = mr_write(gspca_dev, 2);
-	if (err_code &lt; 0)
-		return err_code;
 
 	memcpy(data, startup_string, 11);
 	if (sd-&gt;sensor_type)
@@ -533,22 +686,7 @@ static int start_cif_cam(struct gspca_dev *gspca_dev)
 		err_code = sensor_write_regs(gspca_dev, cif_sensor1_init_data,
 					 ARRAY_SIZE(cif_sensor1_init_data));
 	}
-	if (err_code &lt; 0)
-		return err_code;
-
-	setbrightness(gspca_dev);
-	setexposure(gspca_dev);
-	setgain(gspca_dev);
-
-	msleep(200);
-
-	data[0] = 0x00;
-	data[1] = 0x4d;  /* ISOC transfering enable... */
-	err_code = mr_write(gspca_dev, 2);
-	if (err_code &lt; 0)
-		return err_code;
-
-	return 0;
+	return err_code;
 }
 
 static int start_vga_cam(struct gspca_dev *gspca_dev)
@@ -558,84 +696,8 @@ static int start_vga_cam(struct gspca_dev *gspca_dev)
 	int err_code;
 	const __u8 startup_string[] = {0x00, 0x0d, 0x01, 0x00, 0x00, 0x2b,
 				       0x00, 0x00, 0x00, 0x50, 0xc0};
-
 	/* What some of these mean is explained in start_cif_cam(), above */
-	sd-&gt;sof_read = 0;
-
-	/*
-	 * We have to know which camera we have, because the register writes
-	 * depend upon the camera. This test, run before we actually enter
-	 * the initialization routine, distinguishes most of the cameras, If
-	 * needed, another routine is done later, too.
-	 */
-	memset(data, 0, 16);
-	data[0] = 0x20;
-	err_code = mr_write(gspca_dev, 1);
-	if (err_code &lt; 0)
-		return err_code;
-
-	err_code = mr_read(gspca_dev, 16);
-	if (err_code &lt; 0)
-		return err_code;
-
-	PDEBUG(D_PROBE, "Byte reported is %02x", data[0]);
-
-	msleep(200);
-	/*
-	 * Known VGA cameras. If you have another to report, please do
-	 *
-	 * Name			byte just read		sd-&gt;sensor_type
-	 *				sd-&gt;do_lcd_stop
-	 * Aiptek Pencam VGA+	0x31		0	1
-	 * ION digital		0x31		0	1
-	 * Argus DC-1620	0x30		1	0
-	 * Argus QuickClix	0x30		1	1 (not caught here)
-	 */
-	sd-&gt;sensor_type = data[0] &amp; 1;
-	sd-&gt;do_lcd_stop = (~data[0]) &amp; 1;
-
-
-
-	/* Streaming setup begins here. */
-
-
-	data[0] = 0x01;
-	data[1] = 0x01;
-	err_code = mr_write(gspca_dev, 2);
-	if (err_code &lt; 0)
-		return err_code;
-
-	/*
-	 * A second test can now resolve any remaining ambiguity in the
-	 * identification of the camera type,
-	 */
-	if (!sd-&gt;sensor_type) {
-		data[0] = get_sensor_id(gspca_dev);
-		if (data[0] == 0x7f) {
-			sd-&gt;sensor_type = 1;
-			PDEBUG(D_PROBE, "sensor_type corrected to 1");
-		}
-		msleep(200);
-	}
-
-	if (force_sensor_type != -1) {
-		sd-&gt;sensor_type = !! force_sensor_type;
-		PDEBUG(D_PROBE, "Forcing sensor type to: %d",
-		       sd-&gt;sensor_type);
-	}
 
-	/*
-	 * Known VGA cameras.
-	 * This test is only run if the previous test returned 0x30, but
-	 * here is the information for all others, too, just for reference.
-	 *
-	 * Name			byte just read		sd-&gt;sensor_type
-	 *
-	 * Aiptek Pencam VGA+	0xfb	(this test not run)	1
-	 * ION digital		0xbd	(this test not run)	1
-	 * Argus DC-1620	0xe5	(no change)		0
-	 * Argus QuickClix	0x7f	(reclassified)		1
-	 */
 	memcpy(data, startup_string, 11);
 	if (!sd-&gt;sensor_type) {
 		data[5]  = 0x00;
@@ -704,14 +766,6 @@ static int start_vga_cam(struct gspca_dev *gspca_dev)
 		err_code = sensor_write_regs(gspca_dev, vga_sensor1_init_data,
 					 ARRAY_SIZE(vga_sensor1_init_data));
 	}
-	if (err_code &lt; 0)
-		return err_code;
-
-	msleep(200);
-	data[0] = 0x00;
-	data[1] = 0x4d;  /* ISOC transfering enable... */
-	err_code = mr_write(gspca_dev, 2);
-
 	return err_code;
 }
 
@@ -719,82 +773,101 @@ static int sd_start(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	int err_code;
-	struct cam *cam;
 
-	cam = &amp;gspca_dev-&gt;cam;
 	sd-&gt;sof_read = 0;
-	/*
-	 * Some of the supported cameras require the memory pointer to be
-	 * set to 0, or else they will not stream.
-	 */
-	zero_the_pointer(gspca_dev);
-	msleep(200);
+
+	/* Some of the VGA cameras require the memory pointer
+	 * to be set to 0 again. We have been forced to start the
+	 * stream somewhere else to detect the hardware, and closed it,
+	 * and now since we are restarting the stream we need to do a
+	 * completely fresh and clean start. */
+	err_code = zero_the_pointer(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = stream_start(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
+
 	if (sd-&gt;cam_type == CAM_TYPE_CIF) {
 		err_code = start_cif_cam(gspca_dev);
 	} else {
 		err_code = start_vga_cam(gspca_dev);
 	}
-	return err_code;
+	if (err_code &lt; 0)
+		return err_code;
+
+	setbrightness(gspca_dev);
+	setexposure(gspca_dev);
+	setgain(gspca_dev);
+
+	return isoc_enable(gspca_dev);
 }
 
 static void sd_stopN(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
-	int result;
-
-	gspca_dev-&gt;usb_buf[0] = 1;
-	gspca_dev-&gt;usb_buf[1] = 0;
-	result = mr_write(gspca_dev, 2);
-	if (result &lt; 0)
-		PDEBUG(D_ERR, "Camera Stop failed");
 
+	stream_stop(gspca_dev);
 	/* Not all the cams need this, but even if not, probably a good idea */
 	zero_the_pointer(gspca_dev);
-	if (sd-&gt;do_lcd_stop) {
-		gspca_dev-&gt;usb_buf[0] = 0x19;
-		gspca_dev-&gt;usb_buf[1] = 0x54;
-		result = mr_write(gspca_dev, 2);
-		if (result &lt; 0)
-			PDEBUG(D_ERR, "Camera Stop failed");
-	}
+	if (sd-&gt;do_lcd_stop)
+		lcd_stop(gspca_dev);
 }
 
 static void setbrightness(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	u8 val;
-
-	if (gspca_dev-&gt;ctrl_dis &amp; (1 &lt;&lt; BRIGHTNESS_IDX))
+	u8 sign_reg = 7;  /* This reg and the next one used on CIF cams. */
+	u8 value_reg = 8; /* VGA cams seem to use regs 0x0b and 0x0c */
+	const u8 quick_clix_table[] =
+	/*	  0  1  2   3  4  5  6  7  8  9  10  11  12  13  14  15 */
+		{ 0, 4, 8, 12, 1, 2, 3, 5, 6, 9,  7, 10, 13, 11, 14, 15};
+	/*
+	 * This control is disabled for CIF type 1 and VGA type 0 cameras.
+	 * It does not quite act linearly for the Argus QuickClix camera,
+	 * but it does control brightness. The values are 0 - 15 only, and
+	 * the table above makes them act consecutively.
+	 */
+	if ((gspca_dev-&gt;ctrl_dis &amp; (1 &lt;&lt; NORM_BRIGHTNESS_IDX)) &amp;&amp;
+	    (gspca_dev-&gt;ctrl_dis &amp; (1 &lt;&lt; ARGUS_QC_BRIGHTNESS_IDX)))
 		return;
 
+	if (sd-&gt;cam_type == CAM_TYPE_VGA) {
+		sign_reg += 4;
+		value_reg += 4;
+	}
+
 	/* Note register 7 is also seen as 0x8x or 0xCx in dumps */
 	if (sd-&gt;brightness &gt; 0) {
-		sensor_write1(gspca_dev, 7, 0x00);
+		sensor_write1(gspca_dev, sign_reg, 0x00);
 		val = sd-&gt;brightness;
 	} else {
-		sensor_write1(gspca_dev, 7, 0x01);
-		val = 257 - sd-&gt;brightness;
+		sensor_write1(gspca_dev, sign_reg, 0x01);
+		val = (257 - sd-&gt;brightness);
 	}
-	sensor_write1(gspca_dev, 8, val);
+	/* Use lookup table for funky Argus QuickClix brightness */
+	if (sd-&gt;do_lcd_stop)
+		val = quick_clix_table[val];
+
+	sensor_write1(gspca_dev, value_reg, val);
 }
 
 static void setexposure(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
-	u8 val;
+	int exposure;
 
 	if (gspca_dev-&gt;ctrl_dis &amp; (1 &lt;&lt; EXPOSURE_IDX))
 		return;
 
-	if (sd-&gt;sensor_type) {
-		val = sd-&gt;exposure &gt;&gt; 4;
-		sensor_write1(gspca_dev, 3, val);
-		val = sd-&gt;exposure &amp; 0xf;
-		sensor_write1(gspca_dev, 4, val);
+	if (sd-&gt;cam_type == CAM_TYPE_CIF &amp;&amp; sd-&gt;sensor_type == 1) {
+		/* This cam does not like very low exposure settings */
+		exposure = (sd-&gt;exposure &lt; 300) ? 300 : sd-&gt;exposure;
+		sensor_write1(gspca_dev, 3, exposure &gt;&gt; 4);
+		sensor_write1(gspca_dev, 4, exposure &amp; 0x0f);
 	} else {
-		u8 clockdiv;
-		int exposure;
-
 		/* We have both a clock divider and an exposure register.
 		   We first calculate the clock divider, as that determines
 		   the maximum exposure and then we calculayte the exposure
@@ -802,7 +875,7 @@ static void setexposure(struct gspca_dev *gspca_dev)
 
 		   Note our 0 - 4095 exposure is mapped to 0 - 511
 		   milliseconds exposure time */
-		clockdiv = (60 * sd-&gt;exposure + 7999) / 8000;
+		u8 clockdiv = (60 * sd-&gt;exposure + 7999) / 8000;
 
 		/* Limit framerate to not exceed usb bandwidth */
 		if (clockdiv &lt; 3 &amp;&amp; gspca_dev-&gt;width &gt;= 320)
@@ -810,6 +883,9 @@ static void setexposure(struct gspca_dev *gspca_dev)
 		else if (clockdiv &lt; 2)
 			clockdiv = 2;
 
+		if (sd-&gt;cam_type == CAM_TYPE_VGA &amp;&amp; clockdiv &lt; 4)
+			clockdiv = 4;
+
 		/* Frame exposure time in ms = 1000 * clockdiv / 60 -&gt;
 		exposure = (sd-&gt;exposure / 8) * 511 / (1000 * clockdiv / 60) */
 		exposure = (60 * 511 * sd-&gt;exposure) / (8000 * clockdiv);
@@ -832,7 +908,7 @@ static void setgain(struct gspca_dev *gspca_dev)
 	if (gspca_dev-&gt;ctrl_dis &amp; (1 &lt;&lt; GAIN_IDX))
 		return;
 
-	if (sd-&gt;sensor_type) {
+	if (sd-&gt;cam_type == CAM_TYPE_CIF &amp;&amp; sd-&gt;sensor_type == 1) {
 		sensor_write1(gspca_dev, 0x0e, sd-&gt;gain);
 	} else {
 		sensor_write1(gspca_dev, 0x10, sd-&gt;gain);</pre><hr><pre>commit 32345b059676169444d8d3c4a59009adcdf93885
Author: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
Date:   Sun Nov 1 12:59:42 2009 -0300

    V4L/DVB (13264): gspca_mr97310a: Change vstart for CIF sensor type 1 cams
    
    gspca_mr97310a: Change vstart for CIF sensor type 1 cams
    
    This fixes the distortion at the end of the frame, and avoids the bad frame
    dropping done because of this distortion, trippling the framerate!
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@banach.math.auburn.edu&gt;
    Signed-off-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index 140c8f320e47..f8328b9efae5 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -483,7 +483,7 @@ static int start_cif_cam(struct gspca_dev *gspca_dev)
 		data[3] = 0x2c;			   /* reg 2, H size/8 */
 		data[4] = 0x48;			   /* reg 3, V size/4 */
 		data[6] = 0x06;			   /* reg 5, H start  */
-		data[8] = 0x06 + sd-&gt;sensor_type;  /* reg 7, V start  */
+		data[8] = 0x06 - sd-&gt;sensor_type;  /* reg 7, V start  */
 		break;
 	}
 	err_code = mr_write(gspca_dev, 11);</pre><hr><pre>commit 70136081fc67ea77d849f86fa323e5773c8e40ea
Author: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
Date:   Fri Dec 25 05:15:10 2009 -0300

    V4L/DVB (13991): gspca_mr973010a: Fix cif type 1 cameras not streaming on UHCI controllers
    
    If you read the mail to Oliver Neukum on the linux-usb list, then you know
    that I found a cure for the mysterious problem that the MR97310a CIF "type
    1" cameras have been freezing up and refusing to stream if hooked up to a
    machine with a UHCI controller.
    
    Namely, the cure is that if the camera is an mr97310a CIF type 1 camera, you
    have to send it 0xa0, 0x00. Somehow, this is a timing reset command, or
    such. It un-blocks whatever was previously stopping the CIF type 1 cameras
    from working on the UHCI-based machines.
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
    Signed-off-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index a9178d9d6745..d842e8184426 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -697,6 +697,12 @@ static int start_cif_cam(struct gspca_dev *gspca_dev)
 			{0x13, 0x00, {0x01}, 1},
 			{0, 0, {0}, 0}
 		};
+		/* Without this command the cam won't work with USB-UHCI */
+		gspca_dev-&gt;usb_buf[0] = 0x0a;
+		gspca_dev-&gt;usb_buf[1] = 0x00;
+		err_code = mr_write(gspca_dev, 2);
+		if (err_code &lt; 0)
+			return err_code;
 		err_code = sensor_write_regs(gspca_dev, cif_sensor1_init_data,
 					 ARRAY_SIZE(cif_sensor1_init_data));
 	}</pre><hr><pre>commit 89f0863c4225aaed2763f526815c54a9e1b0f788
Author: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
Date:   Fri Aug 14 06:51:52 2009 -0300

    V4L/DVB (12618): gspca: mr97310a add support for CIF and more VGA camera's
    
    This patch adds supports for mr97310a camera's with CIF sensors (2 different
    types) and for VGA mr97310a camera with a different sensor then supported
    until now.
    
    This patch also add support for controls for one of the 2 CIF sensors, this
    was written by Thomas Kaiser &lt;thomas@kaiser-linux.li&gt;
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
    Signed-off-by: Thomas Kaiser &lt;thomas@kaiser-linux.li&gt;
    Signed-off-by: Hans de Goede &lt;hdgoede@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index 30132513400c..3a3edf82a361 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -3,6 +3,21 @@
  *
  * Copyright (C) 2009 Kyle Guinn &lt;elyk03@gmail.com&gt;
  *
+ * Support for the MR97310A cameras in addition to the Aiptek Pencam VGA+
+ * and for the routines for detecting and classifying these various cameras,
+ *
+ * Copyright (C) 2009 Theodore Kilgore &lt;kilgota@auburn.edu&gt;
+ *
+ * Acknowledgements:
+ *
+ * The MR97311A support in gspca/mars.c has been helpful in understanding some
+ * of the registers in these cameras.
+ *
+ * Hans de Goede &lt;hdgoede@redhat.com&gt; and
+ * Thomas Kaiser &lt;thomas@kaiser-linux.li&gt;
+ * have assisted with their experience. Each of them has also helped by
+ * testing a previously unsupported camera.
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -22,7 +37,23 @@
 
 #include "gspca.h"
 
-MODULE_AUTHOR("Kyle Guinn &lt;elyk03@gmail.com&gt;");
+#define CAM_TYPE_CIF			0
+#define CAM_TYPE_VGA			1
+
+#define MR97310A_BRIGHTNESS_MIN		-254
+#define MR97310A_BRIGHTNESS_MAX		255
+#define MR97310A_BRIGHTNESS_DEFAULT	0
+
+#define MR97310A_EXPOSURE_MIN		300
+#define MR97310A_EXPOSURE_MAX		4095
+#define MR97310A_EXPOSURE_DEFAULT	1000
+
+#define MR97310A_GAIN_MIN		0
+#define MR97310A_GAIN_MAX		31
+#define MR97310A_GAIN_DEFAULT		25
+
+MODULE_AUTHOR("Kyle Guinn &lt;elyk03@gmail.com&gt;,"
+	      "Theodore Kilgore &lt;kilgota@auburn.edu&gt;");
 MODULE_DESCRIPTION("GSPCA/Mars-Semi MR97310A USB Camera Driver");
 MODULE_LICENSE("GPL");
 
@@ -30,10 +61,75 @@ MODULE_LICENSE("GPL");
 struct sd {
 	struct gspca_dev gspca_dev;  /* !! must be the first item */
 	u8 sof_read;
+	u8 cam_type;	/* 0 is CIF and 1 is VGA */
+	u8 sensor_type;	/* We use 0 and 1 here, too. */
+	u8 do_lcd_stop;
+	u8 regs[15];
+
+	int brightness;
+	u16 exposure;
+	u8 autogain;
+	u8 gain;
 };
 
+struct sensor_w_data {
+	u8 reg;
+	u8 flags;
+	u8 data[16];
+	int len;
+};
+
+static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setexposure(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getexposure(struct gspca_dev *gspca_dev, __s32 *val);
+static int sd_setgain(struct gspca_dev *gspca_dev, __s32 val);
+static int sd_getgain(struct gspca_dev *gspca_dev, __s32 *val);
+
 /* V4L2 controls supported by the driver */
 static struct ctrl sd_ctrls[] = {
+	{
+		{
+			.id = V4L2_CID_BRIGHTNESS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Brightness",
+			.minimum = MR97310A_BRIGHTNESS_MIN,
+			.maximum = MR97310A_BRIGHTNESS_MAX,
+			.step = 1,
+			.default_value = MR97310A_BRIGHTNESS_DEFAULT,
+			.flags = 0,
+		},
+		.set = sd_setbrightness,
+		.get = sd_getbrightness,
+	},
+	{
+		{
+			.id = V4L2_CID_EXPOSURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Exposure",
+			.minimum = MR97310A_EXPOSURE_MIN,
+			.maximum = MR97310A_EXPOSURE_MAX,
+			.step = 1,
+			.default_value = MR97310A_EXPOSURE_DEFAULT,
+			.flags = 0,
+		},
+		.set = sd_setexposure,
+		.get = sd_getexposure,
+	},
+	{
+		{
+			.id = V4L2_CID_GAIN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Gain",
+			.minimum = MR97310A_GAIN_MIN,
+			.maximum = MR97310A_GAIN_MAX,
+			.step = 1,
+			.default_value = MR97310A_GAIN_DEFAULT,
+			.flags = 0,
+		},
+		.set = sd_setgain,
+		.get = sd_getgain,
+	},
 };
 
 static const struct v4l2_pix_format vga_mode[] = {
@@ -65,7 +161,7 @@ static const struct v4l2_pix_format vga_mode[] = {
 };
 
 /* the bytes to write are in gspca_dev-&gt;usb_buf */
-static int reg_w(struct gspca_dev *gspca_dev, int len)
+static int mr_write(struct gspca_dev *gspca_dev, int len)
 {
 	int rc;
 
@@ -78,15 +174,200 @@ static int reg_w(struct gspca_dev *gspca_dev, int len)
 	return rc;
 }
 
+/* the bytes are read into gspca_dev-&gt;usb_buf */
+static int mr_read(struct gspca_dev *gspca_dev, int len)
+{
+	int rc;
+
+	rc = usb_bulk_msg(gspca_dev-&gt;dev,
+			  usb_rcvbulkpipe(gspca_dev-&gt;dev, 3),
+			  gspca_dev-&gt;usb_buf, len, NULL, 500);
+	if (rc &lt; 0)
+		PDEBUG(D_ERR, "reg read [%02x] error %d",
+		       gspca_dev-&gt;usb_buf[0], rc);
+	return rc;
+}
+
+static int sensor_write_reg(struct gspca_dev *gspca_dev, u8 reg, u8 flags,
+	const u8 *data, int len)
+{
+	gspca_dev-&gt;usb_buf[0] = 0x1f;
+	gspca_dev-&gt;usb_buf[1] = flags;
+	gspca_dev-&gt;usb_buf[2] = reg;
+	memcpy(gspca_dev-&gt;usb_buf + 3, data, len);
+
+	return mr_write(gspca_dev, len + 3);
+}
+
+static int sensor_write_regs(struct gspca_dev *gspca_dev,
+	const struct sensor_w_data *data, int len)
+{
+	int i, rc;
+
+	for (i = 0; i &lt; len; i++) {
+		rc = sensor_write_reg(gspca_dev, data[i].reg, data[i].flags,
+					  data[i].data, data[i].len);
+		if (rc &lt; 0)
+			return rc;
+	}
+
+	return 0;
+}
+
+static int sensor_write1(struct gspca_dev *gspca_dev, u8 reg, u8 data)
+{
+	u8 buf;
+	int rc;
+
+	buf = data;
+	rc = sensor_write_reg(gspca_dev, reg, 0x01, &amp;buf, 1);
+	if (rc &lt; 0)
+		return rc;
+
+	buf = 0x01;
+	rc = sensor_write_reg(gspca_dev, 0x13, 0x00, &amp;buf, 1);
+	if (rc &lt; 0)
+		return rc;
+
+	return 0;
+}
+
+static int cam_get_response16(struct gspca_dev *gspca_dev)
+{
+	__u8 *data = gspca_dev-&gt;usb_buf;
+	int err_code;
+
+	data[0] = 0x21;
+	err_code = mr_write(gspca_dev, 1);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = mr_read(gspca_dev, 16);
+	return err_code;
+}
+
+static int zero_the_pointer(struct gspca_dev *gspca_dev)
+{
+	__u8 *data = gspca_dev-&gt;usb_buf;
+	int err_code;
+	u8 status = 0;
+	int tries = 0;
+
+	err_code = cam_get_response16(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = mr_write(gspca_dev, 1);
+	data[0] = 0x19;
+	data[1] = 0x51;
+	err_code = mr_write(gspca_dev, 2);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = cam_get_response16(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
+
+	data[0] = 0x19;
+	data[1] = 0xba;
+	err_code = mr_write(gspca_dev, 2);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = cam_get_response16(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
+
+	data[0] = 0x19;
+	data[1] = 0x00;
+	err_code = mr_write(gspca_dev, 2);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = cam_get_response16(gspca_dev);
+	if (err_code &lt; 0)
+		return err_code;
+
+	data[0] = 0x19;
+	data[1] = 0x00;
+	err_code = mr_write(gspca_dev, 2);
+	if (err_code &lt; 0)
+		return err_code;
+
+	while (status != 0x0a &amp;&amp; tries &lt; 256) {
+		err_code = cam_get_response16(gspca_dev);
+		status = data[0];
+		tries++;
+		if (err_code &lt; 0)
+			return err_code;
+	}
+	PDEBUG(D_ERR, "status is %02x", status);
+
+	tries = 0;
+	while (tries &lt; 4) {
+		data[0] = 0x19;
+		data[1] = 0x00;
+		err_code = mr_write(gspca_dev, 2);
+		if (err_code &lt; 0)
+			return err_code;
+
+		err_code = cam_get_response16(gspca_dev);
+		status = data[0];
+		tries++;
+		if (err_code &lt; 0)
+			return err_code;
+	}
+	PDEBUG(D_ERR, "Read 16 bytes from camera");
+
+	data[0] = 0x19;
+	err_code = mr_write(gspca_dev, 1);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = mr_read(gspca_dev, 16);
+	if (err_code &lt; 0)
+		return err_code;
+
+	return 0;
+}
+
+static u8 get_sensor_id(struct gspca_dev *gspca_dev)
+{
+	int err_code;
+
+	gspca_dev-&gt;usb_buf[0] = 0x1e;
+	err_code = mr_write(gspca_dev, 1);
+	if (err_code &lt; 0)
+		return err_code;
+
+	err_code = mr_read(gspca_dev, 16);
+	if (err_code &lt; 0)
+		return err_code;
+
+	PDEBUG(D_ERR, "Read 16 bytes from camera");
+	PDEBUG(D_ERR, "Byte zero reported is %01x", gspca_dev-&gt;usb_buf[0]);
+
+	return gspca_dev-&gt;usb_buf[0];
+}
+
 /* this function is called at probe time */
 static int sd_config(struct gspca_dev *gspca_dev,
 		     const struct usb_device_id *id)
 {
+	struct sd *sd = (struct sd *) gspca_dev;
 	struct cam *cam;
 
 	cam = &amp;gspca_dev-&gt;cam;
 	cam-&gt;cam_mode = vga_mode;
 	cam-&gt;nmodes = ARRAY_SIZE(vga_mode);
+	sd-&gt;cam_type = CAM_TYPE_VGA;
+	PDEBUG(D_PROBE,
+		"MR97310A camera detected"
+		" (vid/pid 0x%04X:0x%04X)", id-&gt;idVendor, id-&gt;idProduct);
+	if (id-&gt;idProduct == 0x010e) {
+		cam-&gt;nmodes--;
+		sd-&gt;cam_type = CAM_TYPE_CIF;
+	}
 	return 0;
 }
 
@@ -96,183 +377,468 @@ static int sd_init(struct gspca_dev *gspca_dev)
 	return 0;
 }
 
-static int sd_start(struct gspca_dev *gspca_dev)
+static int adjust_cif_sensor(struct gspca_dev *gspca_dev)
+{
+	/*
+	 * FIXME: The following sequence resets brightness, contrast, and
+	 * related  settings. Some of the values are adjustable, presumably
+	 * based upon what is detected in the frames. Here, only some
+	 * vaules are used which are compromises. When more is known about
+	 * what is done here, this needs to be moved out to presently
+	 * nonexistent functions which do controls. The same control messages
+	 * do work for all of the CIF cameras.
+	 */
+
+	const struct sensor_w_data  cif_sensor1_adjust_data[] = {
+		{0x02, 0x01, {0x10, 0x12, 0x0a}, 3},
+		/* Last or possibly two last bytes adjustable, above. */
+		{0x13, 0x04, {0x01}, 1}, /* seems to mean "write" */
+		{0x05, 0x01, {0x22, 0x00, 0x81, 0x06}, 4},
+		/* Last or possibly two last bytes adjustable, above. */
+		{0x13, 0x04, {0x01}, 1},
+		{0x09, 0x02, {0x05, 0x00, 0x00, 0x05, 0x07, 0x16}, 6},
+		/* Last or possibly two last bytes adjustable, above. */
+		{0x13, 0x04, {0x01}, 1},
+		{0, 0, {0}, 0}
+	};
+
+	return sensor_write_regs(gspca_dev, cif_sensor1_adjust_data,
+				 ARRAY_SIZE(cif_sensor1_adjust_data));
+}
+
+static int start_cif_cam(struct gspca_dev *gspca_dev)
 {
 	struct sd *sd = (struct sd *) gspca_dev;
 	__u8 *data = gspca_dev-&gt;usb_buf;
 	int err_code;
-
-	sd-&gt;sof_read = 0;
-
-	/* Note:  register descriptions guessed from MR97113A driver */
-
+	const __u8 startup_string[] = {
+		0x00,
+		0x0d,
+		0x01,
+		0x00, /* Hsize/8 for 352 or 320 */
+		0x00, /* Vsize/4 for 288 or 240 */
+		0x13, /* or 0xbb, depends on sensor */
+		0x00, /* Hstart, depends on res. */
+		0x00, /* reserved ? */
+		0x00, /* Vstart, depends on res. and sensor */
+		0x50, /* 0x54 to get 176 or 160 */
+		0xc0
+	};
+
+	/* Note: Some of the above descriptions guessed from MR97113A driver */
+	sd-&gt;sensor_type = 0;
 	data[0] = 0x01;
 	data[1] = 0x01;
-	err_code = reg_w(gspca_dev, 2);
+	err_code = mr_write(gspca_dev, 2);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x00;
-	data[1] = 0x0d;
-	data[2] = 0x01;
-	data[5] = 0x2b;
-	data[7] = 0x00;
-	data[9] = 0x50;  /* reg 8, no scale down */
-	data[10] = 0xc0;
+	msleep(200);
+	data[0] = get_sensor_id(gspca_dev);
+	/*
+	 * Known CIF cameras. If you have another to report, please do
+	 *
+	 * Name			byte just read		sd-&gt;sensor_type
+	 *					reported by
+	 * Sakar Spy-shot	0x28		T. Kilgore	0
+	 * Innovage		0xf5 (unstable)	T. Kilgore	0
+	 * Vivitar Mini		0x53		H. De Goede	0
+	 * Vivitar Mini		0x08		T. Kilgore	1
+	 * Elta-Media 8212dc	0x23		T. Kaiser	1
+	 * Philips dig. keych.	0x37		T. Kilgore	1
+	 */
+	if ((data[0] &amp; 0x78) == 8 || (data[0] &amp; 0x2) == 0x2)
+		sd-&gt;sensor_type = 1;
+
+	PDEBUG(D_ERR, "Sensor type is %01x", sd-&gt;sensor_type);
+	memcpy(data, startup_string, 11);
+	if (sd-&gt;sensor_type)
+		data[5] = 0xbb;
 
 	switch (gspca_dev-&gt;width) {
 	case 160:
-		data[9] |= 0x0c;  /* reg 8, 4:1 scale down */
+		data[9] |= 0x04;  /* reg 8, 2:1 scale down from 320 */
 		/* fall thru */
 	case 320:
-		data[9] |= 0x04;  /* reg 8, 2:1 scale down */
-		/* fall thru */
-	case 640:
 	default:
-		data[3] = 0x50;  /* reg 2, H size */
-		data[4] = 0x78;  /* reg 3, V size */
-		data[6] = 0x04;  /* reg 5, H start */
-		data[8] = 0x03;  /* reg 7, V start */
+		data[3] = 0x28;			   /* reg 2, H size/8 */
+		data[4] = 0x3c;			   /* reg 3, V size/4 */
+		data[6] = 0x14;			   /* reg 5, H start  */
+		data[8] = 0x1a + sd-&gt;sensor_type;  /* reg 7, V start  */
 		break;
-
 	case 176:
-		data[9] |= 0x04;  /* reg 8, 2:1 scale down */
+		data[9] |= 0x04;  /* reg 8, 2:1 scale down from 352 */
 		/* fall thru */
 	case 352:
-		data[3] = 0x2c;  /* reg 2, H size */
-		data[4] = 0x48;  /* reg 3, V size */
-		data[6] = 0x94;  /* reg 5, H start */
-		data[8] = 0x63;  /* reg 7, V start */
+		data[3] = 0x2c;			   /* reg 2, H size/8 */
+		data[4] = 0x48;			   /* reg 3, V size/4 */
+		data[6] = 0x06;			   /* reg 5, H start  */
+		data[8] = 0x06 + sd-&gt;sensor_type;  /* reg 7, V start  */
 		break;
 	}
-
-	err_code = reg_w(gspca_dev, 11);
+	err_code = mr_write(gspca_dev, 11);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x0a;
-	data[1] = 0x80;
-	err_code = reg_w(gspca_dev, 2);
+	if (!sd-&gt;sensor_type) {
+		const struct sensor_w_data cif_sensor0_init_data[] = {
+			{0x02, 0x00, {0x03, 0x5a, 0xb5, 0x01,
+				      0x0f, 0x14, 0x0f, 0x10}, 8},
+			{0x0c, 0x00, {0x04, 0x01, 0x01, 0x00, 0x1f}, 5},
+			{0x12, 0x00, {0x07}, 1},
+			{0x1f, 0x00, {0x06}, 1},
+			{0x27, 0x00, {0x04}, 1},
+			{0x29, 0x00, {0x0c}, 1},
+			{0x40, 0x00, {0x40, 0x00, 0x04}, 3},
+			{0x50, 0x00, {0x60}, 1},
+			{0x60, 0x00, {0x06}, 1},
+			{0x6b, 0x00, {0x85, 0x85, 0xc8, 0xc8, 0xc8, 0xc8}, 6},
+			{0x72, 0x00, {0x1e, 0x56}, 2},
+			{0x75, 0x00, {0x58, 0x40, 0xa2, 0x02, 0x31, 0x02,
+				      0x31, 0x80, 0x00}, 9},
+			{0x11, 0x00, {0x01}, 1},
+			{0, 0, {0}, 0}
+		};
+		err_code = sensor_write_regs(gspca_dev, cif_sensor0_init_data,
+					 ARRAY_SIZE(cif_sensor0_init_data));
+	} else {	/* sd-&gt;sensor_type = 1 */
+		const struct sensor_w_data cif_sensor1_init_data[] = {
+			{0x02, 0x00, {0x10}, 1},
+			{0x03, 0x01, {0x12}, 1},
+			{0x04, 0x01, {0x05}, 1},
+			{0x05, 0x01, {0x65}, 1},
+			{0x06, 0x01, {0x32}, 1},
+			{0x07, 0x01, {0x00}, 1},
+			{0x08, 0x02, {0x06}, 1},
+			{0x09, 0x02, {0x0e}, 1},
+			{0x0a, 0x02, {0x05}, 1},
+			{0x0b, 0x02, {0x05}, 1},
+			{0x0c, 0x02, {0x0f}, 1},
+			{0x0d, 0x02, {0x00}, 1},
+			{0x0e, 0x02, {0x0c}, 1},
+			{0x0f, 0x00, {0x00}, 1},
+			{0x10, 0x00, {0x06}, 1},
+			{0x11, 0x00, {0x07}, 1},
+			{0x12, 0x00, {0x00}, 1},
+			{0x13, 0x00, {0x01}, 1},
+			{0, 0, {0}, 0}
+		};
+		err_code = sensor_write_regs(gspca_dev, cif_sensor1_init_data,
+					 ARRAY_SIZE(cif_sensor1_init_data));
+	}
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x14;
-	data[1] = 0x0a;
-	err_code = reg_w(gspca_dev, 2);
+	msleep(200);
+	data[0] = 0x00;
+	data[1] = 0x4d;  /* ISOC transfering enable... */
+	err_code = mr_write(gspca_dev, 2);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x1b;
-	data[1] = 0x00;
-	err_code = reg_w(gspca_dev, 2);
+	msleep(200);
+	err_code = adjust_cif_sensor(gspca_dev);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x15;
-	data[1] = 0x16;
-	err_code = reg_w(gspca_dev, 2);
-	if (err_code &lt; 0)
-		return err_code;
+	msleep(200);
+	return 0;
+}
 
-	data[0] = 0x16;
-	data[1] = 0x10;
-	err_code = reg_w(gspca_dev, 2);
-	if (err_code &lt; 0)
-		return err_code;
+static int start_vga_cam(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	__u8 *data = gspca_dev-&gt;usb_buf;
+	int err_code;
+	const __u8 startup_string[] = {0x00, 0x0d, 0x01, 0x00, 0x00, 0x2b,
+				       0x00, 0x00, 0x00, 0x50, 0xc0};
 
-	data[0] = 0x17;
-	data[1] = 0x3a;
-	err_code = reg_w(gspca_dev, 2);
-	if (err_code &lt; 0)
-		return err_code;
+	/* What some of these mean is explained in start_cif_cam(), above */
+	sd-&gt;sof_read = 0;
 
-	data[0] = 0x18;
-	data[1] = 0x68;
-	err_code = reg_w(gspca_dev, 2);
+	/*
+	 * We have to know which camera we have, because the register writes
+	 * depend upon the camera. This test, run before we actually enter
+	 * the initialization routine, distinguishes most of the cameras, If
+	 * needed, another routine is done later, too.
+	 */
+	memset(data, 0, 16);
+	data[0] = 0x20;
+	err_code = mr_write(gspca_dev, 1);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x1f;
-	data[1] = 0x00;
-	data[2] = 0x02;
-	data[3] = 0x06;
-	data[4] = 0x59;
-	data[5] = 0x0c;
-	data[6] = 0x16;
-	data[7] = 0x00;
-	data[8] = 0x07;
-	data[9] = 0x00;
-	data[10] = 0x01;
-	err_code = reg_w(gspca_dev, 11);
+	err_code = mr_read(gspca_dev, 16);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x1f;
-	data[1] = 0x04;
-	data[2] = 0x11;
-	data[3] = 0x01;
-	err_code = reg_w(gspca_dev, 4);
-	if (err_code &lt; 0)
-		return err_code;
+	PDEBUG(D_ERR, "Read 16 bytes from camera");
+	PDEBUG(D_ERR, "Byte reported is %02x", data[0]);
 
-	data[0] = 0x1f;
-	data[1] = 0x00;
-	data[2] = 0x0a;
-	data[3] = 0x00;
-	data[4] = 0x01;
-	data[5] = 0x00;
-	data[6] = 0x00;
-	data[7] = 0x01;
-	data[8] = 0x00;
-	data[9] = 0x0a;
-	err_code = reg_w(gspca_dev, 10);
-	if (err_code &lt; 0)
-		return err_code;
+	msleep(200);
+	/*
+	 * Known VGA cameras. If you have another to report, please do
+	 *
+	 * Name			byte just read		sd-&gt;sensor_type
+	 *				sd-&gt;do_lcd_stop
+	 * Aiptek Pencam VGA+	0x31		0	1
+	 * ION digital		0x31		0	1
+	 * Argus DC-1620	0x30		1	0
+	 * Argus QuickClix	0x30		1	1 (not caught here)
+	 */
+	sd-&gt;sensor_type = data[0] &amp; 1;
+	sd-&gt;do_lcd_stop = (~data[0]) &amp; 1;
 
-	data[0] = 0x1f;
-	data[1] = 0x04;
-	data[2] = 0x11;
-	data[3] = 0x01;
-	err_code = reg_w(gspca_dev, 4);
+
+
+	/* Streaming setup begins here. */
+
+
+	data[0] = 0x01;
+	data[1] = 0x01;
+	err_code = mr_write(gspca_dev, 2);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x1f;
-	data[1] = 0x00;
-	data[2] = 0x12;
-	data[3] = 0x00;
-	data[4] = 0x63;
-	data[5] = 0x00;
-	data[6] = 0x70;
-	data[7] = 0x00;
-	data[8] = 0x00;
-	err_code = reg_w(gspca_dev, 9);
+	/*
+	 * A second test can now resolve any remaining ambiguity in the
+	 * identification of the camera type,
+	 */
+	if (!sd-&gt;sensor_type) {
+		data[0] = get_sensor_id(gspca_dev);
+		if (data[0] == 0x7f) {
+			sd-&gt;sensor_type = 1;
+			PDEBUG(D_ERR, "sensor_type corrected to 1");
+		}
+		msleep(200);
+	}
+
+	/*
+	 * Known VGA cameras.
+	 * This test is only run if the previous test returned 0x30, but
+	 * here is the information for all others, too, just for reference.
+	 *
+	 * Name			byte just read		sd-&gt;sensor_type
+	 *
+	 * Aiptek Pencam VGA+	0xfb	(this test not run)	1
+	 * ION digital		0xbd	(this test not run)	1
+	 * Argus DC-1620	0xe5	(no change)		0
+	 * Argus QuickClix	0x7f	(reclassified)		1
+	 */
+	memcpy(data, startup_string, 11);
+	if (!sd-&gt;sensor_type) {
+		data[5]  = 0x00;
+		data[10] = 0x91;
+	}
+
+	switch (gspca_dev-&gt;width) {
+	case 160:
+		data[9] |= 0x0c;  /* reg 8, 4:1 scale down */
+		/* fall thru */
+	case 320:
+		data[9] |= 0x04;  /* reg 8, 2:1 scale down */
+		/* fall thru */
+	case 640:
+	default:
+		data[3] = 0x50;  /* reg 2, H size/8 */
+		data[4] = 0x78;  /* reg 3, V size/4 */
+		data[6] = 0x04;  /* reg 5, H start */
+		data[8] = 0x03;  /* reg 7, V start */
+		if (sd-&gt;do_lcd_stop)
+			data[8] = 0x04;  /* Bayer tile shifted */
+		break;
+
+	case 176:
+		data[9] |= 0x04;  /* reg 8, 2:1 scale down */
+		/* fall thru */
+	case 352:
+		data[3] = 0x2c;  /* reg 2, H size */
+		data[4] = 0x48;  /* reg 3, V size */
+		data[6] = 0x94;  /* reg 5, H start */
+		data[8] = 0x63;  /* reg 7, V start */
+		if (sd-&gt;do_lcd_stop)
+			data[8] = 0x64;  /* Bayer tile shifted */
+		break;
+	}
+
+	err_code = mr_write(gspca_dev, 11);
 	if (err_code &lt; 0)
 		return err_code;
 
-	data[0] = 0x1f;
-	data[1] = 0x04;
-	data[2] = 0x11;
-	data[3] = 0x01;
-	err_code = reg_w(gspca_dev, 4);
+	if (!sd-&gt;sensor_type) {
+		/* The only known sensor_type 0 cam is the Argus DC-1620 */
+		const struct sensor_w_data vga_sensor0_init_data[] = {
+			{0x01, 0x00, {0x0c, 0x00, 0x04}, 3},
+			{0x14, 0x00, {0x01, 0xe4, 0x02, 0x84}, 4},
+			{0x20, 0x00, {0x00, 0x80, 0x00, 0x08}, 4},
+			{0x25, 0x00, {0x03, 0xa9, 0x80}, 3},
+			{0x30, 0x00, {0x30, 0x18, 0x10, 0x18}, 4},
+			{0, 0, {0}, 0}
+		};
+		err_code = sensor_write_regs(gspca_dev, vga_sensor0_init_data,
+					 ARRAY_SIZE(vga_sensor0_init_data));
+	} else {	/* sd-&gt;sensor_type = 1 */
+		const struct sensor_w_data vga_sensor1_init_data[] = {
+			{0x02, 0x00, {0x06, 0x59, 0x0c, 0x16, 0x00,
+				0x07, 0x00, 0x01}, 8},
+			{0x11, 0x04, {0x01}, 1},
+			/*{0x0a, 0x00, {0x00, 0x01, 0x00, 0x00, 0x01, */
+			{0x0a, 0x00, {0x01, 0x06, 0x00, 0x00, 0x01,
+				0x00, 0x0a}, 7},
+			{0x11, 0x04, {0x01}, 1},
+			{0x12, 0x00, {0x00, 0x63, 0x00, 0x70, 0x00, 0x00}, 6},
+			{0x11, 0x04, {0x01}, 1},
+			{0, 0, {0}, 0}
+		};
+		err_code = sensor_write_regs(gspca_dev, vga_sensor1_init_data,
+					 ARRAY_SIZE(vga_sensor1_init_data));
+	}
 	if (err_code &lt; 0)
 		return err_code;
 
+	msleep(200);
 	data[0] = 0x00;
 	data[1] = 0x4d;  /* ISOC transfering enable... */
-	err_code = reg_w(gspca_dev, 2);
+	err_code = mr_write(gspca_dev, 2);
+
+	return err_code;
+}
+
+static int sd_start(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	int err_code;
+	struct cam *cam;
+
+	/* TEST TEST */
+	int i;
+	for (i = 2; i &lt;= 14; i++)
+		sd-&gt;regs[i] = sd_ctrls[i - 2].qctrl.default_value;
+
+	cam = &amp;gspca_dev-&gt;cam;
+	sd-&gt;sof_read = 0;
+	/*
+	 * Some of the supported cameras require the memory pointer to be
+	 * set to 0, or else they will not stream.
+	 */
+	zero_the_pointer(gspca_dev);
+	msleep(200);
+	if (sd-&gt;cam_type == CAM_TYPE_CIF) {
+		PDEBUG(D_ERR, "CIF camera");
+		err_code = start_cif_cam(gspca_dev);
+	} else {
+		PDEBUG(D_ERR, "VGA camera");
+		err_code = start_vga_cam(gspca_dev);
+	}
 	return err_code;
 }
 
 static void sd_stopN(struct gspca_dev *gspca_dev)
 {
+	struct sd *sd = (struct sd *) gspca_dev;
 	int result;
 
 	gspca_dev-&gt;usb_buf[0] = 1;
 	gspca_dev-&gt;usb_buf[1] = 0;
-	result = reg_w(gspca_dev, 2);
+	result = mr_write(gspca_dev, 2);
 	if (result &lt; 0)
 		PDEBUG(D_ERR, "Camera Stop failed");
+
+	/* Not all the cams need this, but even if not, probably a good idea */
+	zero_the_pointer(gspca_dev);
+	if (sd-&gt;do_lcd_stop) {
+		gspca_dev-&gt;usb_buf[0] = 0x19;
+		gspca_dev-&gt;usb_buf[1] = 0x54;
+		result = mr_write(gspca_dev, 2);
+		if (result &lt; 0)
+			PDEBUG(D_ERR, "Camera Stop failed");
+	}
+}
+
+static void setbrightness(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	u8 val;
+	if (sd-&gt;brightness &gt; 0) {
+		sensor_write1(gspca_dev, 7, 0);
+		val = sd-&gt;brightness;
+	} else {
+		sensor_write1(gspca_dev, 7, 1);
+		val = 257 - sd-&gt;brightness;
+	}
+	sensor_write1(gspca_dev, 8, val);
+}
+
+static void setexposure(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+	u8 val;
+
+	val = sd-&gt;exposure &gt;&gt; 4;
+	sensor_write1(gspca_dev, 3, val);
+	val = sd-&gt;exposure &amp; 0xf;
+	sensor_write1(gspca_dev, 4, val);
+}
+
+static void setgain(struct gspca_dev *gspca_dev)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sensor_write1(gspca_dev, 3, sd-&gt;gain);
+}
+
+static int sd_setbrightness(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd-&gt;brightness = val;
+	if (gspca_dev-&gt;streaming)
+		setbrightness(gspca_dev);
+	return 0;
+}
+
+static int sd_getbrightness(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd-&gt;brightness;
+	return 0;
+}
+
+static int sd_setexposure(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd-&gt;exposure = val;
+	if (gspca_dev-&gt;streaming)
+		setexposure(gspca_dev);
+	return 0;
+}
+
+static int sd_getexposure(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd-&gt;exposure;
+	return 0;
+}
+
+static int sd_setgain(struct gspca_dev *gspca_dev, __s32 val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	sd-&gt;gain = val;
+	if (gspca_dev-&gt;streaming)
+		setgain(gspca_dev);
+	return 0;
+}
+
+static int sd_getgain(struct gspca_dev *gspca_dev, __s32 *val)
+{
+	struct sd *sd = (struct sd *) gspca_dev;
+
+	*val = sd-&gt;gain;
+	return 0;
 }
 
 /* Include pac common sof detection functions */
@@ -320,8 +886,9 @@ static const struct sd_desc sd_desc = {
 
 /* -- module initialisation -- */
 static const __devinitdata struct usb_device_id device_table[] = {
-	{USB_DEVICE(0x08ca, 0x0111)},
-	{USB_DEVICE(0x093a, 0x010f)},
+	{USB_DEVICE(0x08ca, 0x0111)},	/* Aiptek Pencam VGA+ */
+	{USB_DEVICE(0x093a, 0x010f)},	/* All other known MR97310A VGA cams */
+	{USB_DEVICE(0x093a, 0x010e)},	/* All known MR97310A CIF cams */
 	{}
 };
 MODULE_DEVICE_TABLE(usb, device_table);</pre><hr><pre>commit 3040b043423c1726a14595d500f6409070b1e722
Author: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
Date:   Mon Aug 3 04:13:23 2009 -0300

    V4L/DVB (12459): gspca - jeilinj: New subdriver for Jeilin chip.
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
    Signed-off-by: Jean-Francois Moine &lt;moinejf@free.fr&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/Documentation/video4linux/gspca.txt b/Documentation/video4linux/gspca.txt
index b43702470130..76203a2213ad 100644
--- a/Documentation/video4linux/gspca.txt
+++ b/Documentation/video4linux/gspca.txt
@@ -239,6 +239,7 @@ pac7311		093a:2626	Labtec 2200
 pac7311		093a:2629	Genious iSlim 300
 pac7311		093a:262a	Webcam 300k
 pac7311		093a:262c	Philips SPC 230 NC
+jeilinj		0979:0280	Sakar 57379
 zc3xx		0ac8:0302	Z-star Vimicro zc0302
 vc032x		0ac8:0321	Vimicro generic vc0321
 vc032x		0ac8:0323	Vimicro Vc0323
diff --git a/drivers/media/video/gspca/Kconfig b/drivers/media/video/gspca/Kconfig
index f114dd1507c2..e800c22a9a89 100644
--- a/drivers/media/video/gspca/Kconfig
+++ b/drivers/media/video/gspca/Kconfig
@@ -47,6 +47,15 @@ config USB_GSPCA_FINEPIX
 	  To compile this driver as a module, choose M here: the
 	  module will be called gspca_finepix.
 
+config USB_GSPCA_JEILINJ
+	tristate "Jeilin JPEG USB V4L2 driver"
+	depends on VIDEO_V4L2 &amp;&amp; USB_GSPCA
+	help
+	  Say Y here if you want support for cameras based on this Jeilin chip.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called gspca_jeilinj.
+
 config USB_GSPCA_MARS
 	tristate "Mars USB Camera Driver"
 	depends on VIDEO_V4L2 &amp;&amp; USB_GSPCA
diff --git a/drivers/media/video/gspca/Makefile b/drivers/media/video/gspca/Makefile
index f6d3b86e9ad5..035616b5e867 100644
--- a/drivers/media/video/gspca/Makefile
+++ b/drivers/media/video/gspca/Makefile
@@ -2,6 +2,7 @@ obj-$(CONFIG_USB_GSPCA)          += gspca_main.o
 obj-$(CONFIG_USB_GSPCA_CONEX)    += gspca_conex.o
 obj-$(CONFIG_USB_GSPCA_ETOMS)    += gspca_etoms.o
 obj-$(CONFIG_USB_GSPCA_FINEPIX)  += gspca_finepix.o
+obj-$(CONFIG_USB_GSPCA_JEILINJ)  += gspca_jeilinj.o
 obj-$(CONFIG_USB_GSPCA_MARS)     += gspca_mars.o
 obj-$(CONFIG_USB_GSPCA_MR97310A) += gspca_mr97310a.o
 obj-$(CONFIG_USB_GSPCA_OV519)    += gspca_ov519.o
@@ -30,6 +31,7 @@ gspca_main-objs     := gspca.o
 gspca_conex-objs    := conex.o
 gspca_etoms-objs    := etoms.o
 gspca_finepix-objs  := finepix.o
+gspca_jeilinj-objs  := jeilinj.o
 gspca_mars-objs     := mars.o
 gspca_mr97310a-objs := mr97310a.o
 gspca_ov519-objs    := ov519.o
diff --git a/drivers/media/video/gspca/jeilinj.c b/drivers/media/video/gspca/jeilinj.c
new file mode 100644
index 000000000000..dbfa3ed6e8ef
--- /dev/null
+++ b/drivers/media/video/gspca/jeilinj.c
@@ -0,0 +1,388 @@
+/*
+ * Jeilinj subdriver
+ *
+ * Supports some Jeilin dual-mode cameras which use bulk transport and
+ * download raw JPEG data.
+ *
+ * Copyright (C) 2009 Theodore Kilgore
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#define MODULE_NAME "jeilinj"
+
+#include &lt;linux/workqueue.h&gt;
+#include "gspca.h"
+#include "jpeg.h"
+
+MODULE_AUTHOR("Theodore Kilgore &lt;kilgota@auburn.edu&gt;");
+MODULE_DESCRIPTION("GSPCA/JEILINJ USB Camera Driver");
+MODULE_LICENSE("GPL");
+
+/* Default timeouts, in ms */
+#define JEILINJ_CMD_TIMEOUT 500
+#define JEILINJ_DATA_TIMEOUT 1000
+
+/* Maximum transfer size to use. */
+#define JEILINJ_MAX_TRANSFER 0x200
+
+#define FRAME_HEADER_LEN 0x10
+
+/* Structure to hold all of our device specific stuff */
+struct sd {
+	struct gspca_dev gspca_dev;	/* !! must be the first item */
+	const struct v4l2_pix_format *cap_mode;
+	/* Driver stuff */
+	struct work_struct work_struct;
+	struct workqueue_struct *work_thread;
+	u8 quality;				 /* image quality */
+	u8 jpegqual;				/* webcam quality */
+	u8 *jpeg_hdr;
+};
+
+	struct jlj_command {
+		unsigned char instruction[2];
+		unsigned char ack_wanted;
+	};
+
+/* AFAICT these cameras will only do 320x240. */
+static struct v4l2_pix_format jlj_mode[] = {
+	{ 320, 240, V4L2_PIX_FMT_JPEG, V4L2_FIELD_NONE,
+		.bytesperline = 320,
+		.sizeimage = 320 * 240,
+		.colorspace = V4L2_COLORSPACE_JPEG,
+		.priv = 0}
+};
+
+/*
+ * cam uses endpoint 0x03 to send commands, 0x84 for read commands,
+ * and 0x82 for bulk transfer.
+ */
+
+/* All commands are two bytes only */
+static int jlj_write2(struct gspca_dev *gspca_dev, unsigned char *command)
+{
+	int retval;
+
+	memcpy(gspca_dev-&gt;usb_buf, command, 2);
+	retval = usb_bulk_msg(gspca_dev-&gt;dev,
+			usb_sndbulkpipe(gspca_dev-&gt;dev, 3),
+			gspca_dev-&gt;usb_buf, 2, NULL, 500);
+	if (retval &lt; 0)
+		PDEBUG(D_ERR, "command write [%02x] error %d",
+				gspca_dev-&gt;usb_buf[0], retval);
+	return retval;
+}
+
+/* Responses are one byte only */
+static int jlj_read1(struct gspca_dev *gspca_dev, unsigned char response)
+{
+	int retval;
+
+	retval = usb_bulk_msg(gspca_dev-&gt;dev,
+	usb_rcvbulkpipe(gspca_dev-&gt;dev, 0x84),
+				gspca_dev-&gt;usb_buf, 1, NULL, 500);
+	response = gspca_dev-&gt;usb_buf[0];
+	if (retval &lt; 0)
+		PDEBUG(D_ERR, "read command [%02x] error %d",
+				gspca_dev-&gt;usb_buf[0], retval);
+	return retval;
+}
+
+static int jlj_start(struct gspca_dev *gspca_dev)
+{
+	int i;
+	int retval = -1;
+	u8 response = 0xff;
+	struct jlj_command start_commands[] = {
+		{{0x71, 0x81}, 0},
+		{{0x70, 0x05}, 0},
+		{{0x95, 0x70}, 1},
+		{{0x71, 0x81}, 0},
+		{{0x70, 0x04}, 0},
+		{{0x95, 0x70}, 1},
+		{{0x71, 0x00}, 0},
+		{{0x70, 0x08}, 0},
+		{{0x95, 0x70}, 1},
+		{{0x94, 0x02}, 0},
+		{{0xde, 0x24}, 0},
+		{{0x94, 0x02}, 0},
+		{{0xdd, 0xf0}, 0},
+		{{0x94, 0x02}, 0},
+		{{0xe3, 0x2c}, 0},
+		{{0x94, 0x02}, 0},
+		{{0xe4, 0x00}, 0},
+		{{0x94, 0x02}, 0},
+		{{0xe5, 0x00}, 0},
+		{{0x94, 0x02}, 0},
+		{{0xe6, 0x2c}, 0},
+		{{0x94, 0x03}, 0},
+		{{0xaa, 0x00}, 0},
+		{{0x71, 0x1e}, 0},
+		{{0x70, 0x06}, 0},
+		{{0x71, 0x80}, 0},
+		{{0x70, 0x07}, 0}
+	};
+	for (i = 0; i &lt; ARRAY_SIZE(start_commands); i++) {
+		retval = jlj_write2(gspca_dev, start_commands[i].instruction);
+		if (retval &lt; 0)
+			return retval;
+		if (start_commands[i].ack_wanted)
+			retval = jlj_read1(gspca_dev, response);
+		if (retval &lt; 0)
+			return retval;
+	}
+	PDEBUG(D_ERR, "jlj_start retval is %d", retval);
+	return retval;
+}
+
+static int jlj_stop(struct gspca_dev *gspca_dev)
+{
+	int i;
+	int retval;
+	struct jlj_command stop_commands[] = {
+		{{0x71, 0x00}, 0},
+		{{0x70, 0x09}, 0},
+		{{0x71, 0x80}, 0},
+		{{0x70, 0x05}, 0}
+	};
+	for (i = 0; i &lt; ARRAY_SIZE(stop_commands); i++) {
+		retval = jlj_write2(gspca_dev, stop_commands[i].instruction);
+		if (retval &lt; 0)
+			return retval;
+	}
+	return retval;
+}
+
+/* This function is called as a workqueue function and runs whenever the camera
+ * is streaming data. Because it is a workqueue function it is allowed to sleep
+ * so we can use synchronous USB calls. To avoid possible collisions with other
+ * threads attempting to use the camera's USB interface the gspca usb_lock is
+ * used when performing the one USB control operation inside the workqueue,
+ * which tells the camera to close the stream. In practice the only thing
+ * which needs to be protected against is the usb_set_interface call that
+ * gspca makes during stream_off. Otherwise the camera doesn't provide any
+ * controls that the user could try to change.
+ */
+
+static void jlj_dostream(struct work_struct *work)
+{
+	struct sd *dev = container_of(work, struct sd, work_struct);
+	struct gspca_dev *gspca_dev = &amp;dev-&gt;gspca_dev;
+	struct gspca_frame *frame;
+	int blocks_left; /* 0x200-sized blocks remaining in current frame. */
+	int size_in_blocks;
+	int act_len;
+	int discarding = 0; /* true if we failed to get space for frame. */
+	int packet_type;
+	int ret;
+	u8 *buffer;
+
+	buffer = kmalloc(JEILINJ_MAX_TRANSFER, GFP_KERNEL | GFP_DMA);
+	if (!buffer) {
+		PDEBUG(D_ERR, "Couldn't allocate USB buffer");
+		goto quit_stream;
+	}
+	while (gspca_dev-&gt;present &amp;&amp; gspca_dev-&gt;streaming) {
+		if (!gspca_dev-&gt;present)
+			goto quit_stream;
+		/* Start a new frame, and add the JPEG header, first thing */
+		frame = gspca_get_i_frame(gspca_dev);
+		if (frame &amp;&amp; !discarding)
+			gspca_frame_add(gspca_dev, FIRST_PACKET, frame,
+					dev-&gt;jpeg_hdr, JPEG_HDR_SZ);
+		 else
+			discarding = 1;
+		/*
+		 * Now request data block 0. Line 0 reports the size
+		 * to download, in blocks of size 0x200, and also tells the
+		 * "actual" data size, in bytes, which seems best to ignore.
+		 */
+		ret = usb_bulk_msg(gspca_dev-&gt;dev,
+				usb_rcvbulkpipe(gspca_dev-&gt;dev, 0x82),
+				buffer, JEILINJ_MAX_TRANSFER, &amp;act_len,
+				JEILINJ_DATA_TIMEOUT);
+		PDEBUG(D_STREAM,
+			"Got %d bytes out of %d for Block 0",
+			act_len, JEILINJ_MAX_TRANSFER);
+		if (ret &lt; 0 || act_len &lt; FRAME_HEADER_LEN)
+			goto quit_stream;
+		size_in_blocks = buffer[0x0a];
+		blocks_left = buffer[0x0a] - 1;
+		PDEBUG(D_STREAM, "blocks_left = 0x%x", blocks_left);
+		packet_type = INTER_PACKET;
+		if (frame &amp;&amp; !discarding)
+			/* Toss line 0 of data block 0, keep the rest. */
+			gspca_frame_add(gspca_dev, packet_type,
+				frame, buffer + FRAME_HEADER_LEN,
+				JEILINJ_MAX_TRANSFER - FRAME_HEADER_LEN);
+			else
+				discarding = 1;
+		while (blocks_left &gt; 0) {
+			if (!gspca_dev-&gt;present)
+				goto quit_stream;
+			ret = usb_bulk_msg(gspca_dev-&gt;dev,
+				usb_rcvbulkpipe(gspca_dev-&gt;dev, 0x82),
+				buffer, JEILINJ_MAX_TRANSFER, &amp;act_len,
+				JEILINJ_DATA_TIMEOUT);
+			if (ret &lt; 0 || act_len &lt; JEILINJ_MAX_TRANSFER)
+				goto quit_stream;
+			PDEBUG(D_STREAM,
+				"%d blocks remaining for frame", blocks_left);
+			blocks_left -= 1;
+			if (blocks_left == 0)
+				packet_type = LAST_PACKET;
+			else
+				packet_type = INTER_PACKET;
+			if (frame &amp;&amp; !discarding)
+				gspca_frame_add(gspca_dev, packet_type,
+						frame, buffer,
+						JEILINJ_MAX_TRANSFER);
+			else
+				discarding = 1;
+		}
+	}
+quit_stream:
+	mutex_lock(&amp;gspca_dev-&gt;usb_lock);
+	if (gspca_dev-&gt;present)
+		jlj_stop(gspca_dev);
+	mutex_unlock(&amp;gspca_dev-&gt;usb_lock);
+	kfree(buffer);
+}
+
+/* This function is called at probe time just before sd_init */
+static int sd_config(struct gspca_dev *gspca_dev,
+		const struct usb_device_id *id)
+{
+	struct cam *cam = &amp;gspca_dev-&gt;cam;
+	struct sd *dev  = (struct sd *) gspca_dev;
+
+	dev-&gt;quality  = 85;
+	dev-&gt;jpegqual = 85;
+	PDEBUG(D_PROBE,
+		"JEILINJ camera detected"
+		" (vid/pid 0x%04X:0x%04X)", id-&gt;idVendor, id-&gt;idProduct);
+	cam-&gt;cam_mode = jlj_mode;
+	cam-&gt;nmodes = 1;
+	cam-&gt;bulk = 1;
+	/* We don't use the buffer gspca allocates so make it small. */
+	cam-&gt;bulk_size = 32;
+	INIT_WORK(&amp;dev-&gt;work_struct, jlj_dostream);
+	return 0;
+}
+
+/* called on streamoff with alt==0 and on disconnect */
+/* the usb_lock is held at entry - restore on exit */
+static void sd_stop0(struct gspca_dev *gspca_dev)
+{
+	struct sd *dev = (struct sd *) gspca_dev;
+
+	/* wait for the work queue to terminate */
+	mutex_unlock(&amp;gspca_dev-&gt;usb_lock);
+	/* This waits for jlj_dostream to finish */
+	destroy_workqueue(dev-&gt;work_thread);
+	dev-&gt;work_thread = NULL;
+	mutex_lock(&amp;gspca_dev-&gt;usb_lock);
+	kfree(dev-&gt;jpeg_hdr);
+}
+
+/* this function is called at probe and resume time */
+static int sd_init(struct gspca_dev *gspca_dev)
+{
+	return 0;
+}
+
+/* Set up for getting frames. */
+static int sd_start(struct gspca_dev *gspca_dev)
+{
+	struct sd *dev = (struct sd *) gspca_dev;
+	int ret;
+
+	/* create the JPEG header */
+	dev-&gt;jpeg_hdr = kmalloc(JPEG_HDR_SZ, GFP_KERNEL);
+	jpeg_define(dev-&gt;jpeg_hdr, gspca_dev-&gt;height, gspca_dev-&gt;width,
+			0x21);          /* JPEG 422 */
+	jpeg_set_qual(dev-&gt;jpeg_hdr, dev-&gt;quality);
+	PDEBUG(D_STREAM, "Start streaming at 320x240");
+	ret = jlj_start(gspca_dev);
+	if (ret &lt; 0) {
+		PDEBUG(D_ERR, "Start streaming command failed");
+		return ret;
+	}
+	/* Start the workqueue function to do the streaming */
+	dev-&gt;work_thread = create_singlethread_workqueue(MODULE_NAME);
+	queue_work(dev-&gt;work_thread, &amp;dev-&gt;work_struct);
+
+	return 0;
+}
+
+/* Table of supported USB devices */
+static const __devinitdata struct usb_device_id device_table[] = {
+	{USB_DEVICE(0x0979, 0x0280)},
+	{}
+};
+
+MODULE_DEVICE_TABLE(usb, device_table);
+
+/* sub-driver description */
+static const struct sd_desc sd_desc = {
+	.name   = MODULE_NAME,
+	.config = sd_config,
+	.init   = sd_init,
+	.start  = sd_start,
+	.stop0  = sd_stop0,
+};
+
+/* -- device connect -- */
+static int sd_probe(struct usb_interface *intf,
+		const struct usb_device_id *id)
+{
+	return gspca_dev_probe(intf, id,
+			&amp;sd_desc,
+			sizeof(struct sd),
+			THIS_MODULE);
+}
+
+static struct usb_driver sd_driver = {
+	.name       = MODULE_NAME,
+	.id_table   = device_table,
+	.probe      = sd_probe,
+	.disconnect = gspca_disconnect,
+#ifdef CONFIG_PM
+	.suspend = gspca_suspend,
+	.resume  = gspca_resume,
+#endif
+};
+
+/* -- module insert / remove -- */
+static int __init sd_mod_init(void)
+{
+	int ret;
+
+	ret = usb_register(&amp;sd_driver);
+	if (ret &lt; 0)
+		return ret;
+	PDEBUG(D_PROBE, "registered");
+	return 0;
+}
+
+static void __exit sd_mod_exit(void)
+{
+	usb_deregister(&amp;sd_driver);
+	PDEBUG(D_PROBE, "deregistered");
+}
+
+module_init(sd_mod_init);
+module_exit(sd_mod_exit);</pre><hr><pre>commit ebf58f70e853b9ffe50d6b194d3679b7dc2cac9c
Author: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
Date:   Sun Apr 5 15:36:04 2009 -0300

    V4L/DVB (11483): gspca - mr97310a: Webcam 093a:010f added.
    
    Signed-off-by: Theodore Kilgore &lt;kilgota@auburn.edu&gt;
    Signed-off-by: Jean-Francois Moine &lt;moinejf@free.fr&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/Documentation/video4linux/gspca.txt b/Documentation/video4linux/gspca.txt
index 98529e03a46e..e418a8fb9c66 100644
--- a/Documentation/video4linux/gspca.txt
+++ b/Documentation/video4linux/gspca.txt
@@ -209,6 +209,7 @@ sunplus		08ca:2050	Medion MD 41437
 sunplus		08ca:2060	Aiptek PocketDV5300
 tv8532		0923:010f	ICM532 cams
 mars		093a:050f	Mars-Semi Pc-Camera
+mr97310a	093a:010f	Sakar Digital no. 77379
 pac207		093a:2460	Qtec Webcam 100
 pac207		093a:2461	HP Webcam
 pac207		093a:2463	Philips SPC 220 NC
diff --git a/drivers/media/video/gspca/mr97310a.c b/drivers/media/video/gspca/mr97310a.c
index f9da55b20fa3..30132513400c 100644
--- a/drivers/media/video/gspca/mr97310a.c
+++ b/drivers/media/video/gspca/mr97310a.c
@@ -321,6 +321,7 @@ static const struct sd_desc sd_desc = {
 /* -- module initialisation -- */
 static const __devinitdata struct usb_device_id device_table[] = {
 	{USB_DEVICE(0x08ca, 0x0111)},
+	{USB_DEVICE(0x093a, 0x010f)},
 	{}
 };
 MODULE_DEVICE_TABLE(usb, device_table);</pre>
    <div class="pagination">
        <a href='30.html'>&lt;&lt;Prev</a><a href='30.html'>1</a><span>[2]</span><a href='30_3.html'>3</a><a href='30_3.html'>Next&gt;&gt;</a>
    <div>
</body>
