<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_71.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><span>[72]</span><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_73.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit aa0baaef97c89de2ef216fcc017215ee01662a10
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 21 02:46:11 2009 +0100

    PM: Use pm_runtime_put_sync in system resume
    
    This patch (as1317) fixes a bug in the PM core.  When a device is
    resumed following a system sleep, the core decrements the device's
    runtime PM usage counter but doesn't issue an idle notification if the
    counter reaches 0.  This could prevent an otherwise unused device from
    being runtime-suspended again after the system sleep.
    
    The fix is to call pm_runtime_put_sync() instead of
    pm_runtime_put_noidle().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 8052dafc0ba9..48adf80926a0 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -607,7 +607,7 @@ static void dpm_complete(pm_message_t state)
 			mutex_unlock(&amp;dpm_list_mtx);
 
 			device_complete(dev, state);
-			pm_runtime_put_noidle(dev);
+			pm_runtime_put_sync(dev);
 
 			mutex_lock(&amp;dpm_list_mtx);
 		}
@@ -880,7 +880,7 @@ static int dpm_prepare(pm_message_t state)
 		pm_runtime_get_noresume(dev);
 		if (pm_runtime_barrier(dev) &amp;&amp; device_may_wakeup(dev)) {
 			/* Wake-up requested during system sleep transition. */
-			pm_runtime_put_noidle(dev);
+			pm_runtime_put_sync(dev);
 			error = -EBUSY;
 		} else {
 			error = device_prepare(dev, state);</pre><hr><pre>commit 1d531c14d2ed4b24472a4d773f00ed6d1cd34ee7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Dec 13 20:28:30 2009 +0100

    PM: allow for usage_count &gt; 0 in pm_runtime_get()
    
    This patch (as1308c) fixes __pm_runtime_get().  Currently the routine
    will resume a device if the prior usage count was 0.  But this isn't
    right; thanks to pm_runtime_get_noresume() the usage count can be
    positive even while the device is suspended.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 5a01ecef4af3..40d7720a4b21 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -701,15 +701,15 @@ EXPORT_SYMBOL_GPL(pm_request_resume);
  * @dev: Device to handle.
  * @sync: If set and the device is suspended, resume it synchronously.
  *
- * Increment the usage count of the device and if it was zero previously,
- * resume it or submit a resume request for it, depending on the value of @sync.
+ * Increment the usage count of the device and resume it or submit a resume
+ * request for it, depending on the value of @sync.
  */
 int __pm_runtime_get(struct device *dev, bool sync)
 {
-	int retval = 1;
+	int retval;
 
-	if (atomic_add_return(1, &amp;dev-&gt;power.usage_count) == 1)
-		retval = sync ? pm_runtime_resume(dev) : pm_request_resume(dev);
+	atomic_inc(&amp;dev-&gt;power.usage_count);
+	retval = sync ? pm_runtime_resume(dev) : pm_request_resume(dev);
 
 	return retval;
 }</pre><hr><pre>commit f3f6faa9edf67c1018270793e0547b0f81abb47e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 7 16:47:43 2009 -0500

    USB: usb-storage: fix bug in fill_inquiry
    
    This patch (as1312) fixes a minor bug in usb-storage.  The
    fill_inquiry() routine neglects to pre-load the inquiry data buffer
    with spaces.  As a result, if the vendor name is shorter than 8
    characters or the product name is shorter than 16, the remainder will
    be filled with garbage.
    
    The patch also removes some unnecessary calls to strlen().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index f5c0264caa33..5a53d4f0dd11 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -232,6 +232,7 @@ void fill_inquiry_response(struct us_data *us, unsigned char *data,
 	if (data_len&lt;36) // You lose.
 		return;
 
+	memset(data+8, ' ', 28);
 	if(data[0]&amp;0x20) { /* USB device currently not connected. Return
 			      peripheral qualifier 001b ("...however, the
 			      physical device is not currently connected
@@ -241,15 +242,15 @@ void fill_inquiry_response(struct us_data *us, unsigned char *data,
 			      device, it may return zeros or ASCII spaces 
 			      (20h) in those fields until the data is
 			      available from the device."). */
-		memset(data+8,0,28);
 	} else {
 		u16 bcdDevice = le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.bcdDevice);
-		memcpy(data+8, us-&gt;unusual_dev-&gt;vendorName, 
-			strlen(us-&gt;unusual_dev-&gt;vendorName) &gt; 8 ? 8 :
-			strlen(us-&gt;unusual_dev-&gt;vendorName));
-		memcpy(data+16, us-&gt;unusual_dev-&gt;productName, 
-			strlen(us-&gt;unusual_dev-&gt;productName) &gt; 16 ? 16 :
-			strlen(us-&gt;unusual_dev-&gt;productName));
+		int n;
+
+		n = strlen(us-&gt;unusual_dev-&gt;vendorName);
+		memcpy(data+8, us-&gt;unusual_dev-&gt;vendorName, min(8, n));
+		n = strlen(us-&gt;unusual_dev-&gt;productName);
+		memcpy(data+16, us-&gt;unusual_dev-&gt;productName, min(16, n));
+
 		data[32] = 0x30 + ((bcdDevice&gt;&gt;12) &amp; 0x0F);
 		data[33] = 0x30 + ((bcdDevice&gt;&gt;8) &amp; 0x0F);
 		data[34] = 0x30 + ((bcdDevice&gt;&gt;4) &amp; 0x0F);</pre><hr><pre>commit a0bb108112a872c0b0c4b3ef4974f95fb75b155d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 7 16:39:16 2009 -0500

    USB: usb-storage: add BAD_SENSE flag
    
    This patch (as1311) fixes a problem in usb-storage: Some devices are
    pretty broken when it comes to reporting sense data.  The information
    they send back indicates that they have more than 18 bytes of sense
    data available, but when the system asks for more than 18 they fail or
    hang.  The symptom is that probing fails with multiple resets.
    
    The patch adds a new BAD_SENSE flag to indicate that usb-storage
    should never ask for more than 18 bytes of sense data.  The flag can
    be set in an unusual_devs entry or via the "quirks=" module parameter,
    and it is set automatically whenever a REQUEST SENSE command for more
    than 18 bytes fails or times out.
    
    An unusual_devs entry is added for the Agfa photo frame, which uses a
    Prolific chip having this bug.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Daniel Kukula &lt;daniel.kuku@gmail.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 777dc8a32df8..3f886e298f62 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -2663,6 +2663,8 @@ and is between 256 and 4096 characters. It is defined in the file
 			to a common usb-storage quirk flag as follows:
 				a = SANE_SENSE (collect more than 18 bytes
 					of sense data);
+				b = BAD_SENSE (don't collect more than 18
+					bytes of sense data);
 				c = FIX_CAPACITY (decrease the reported
 					device capacity by one sector);
 				h = CAPACITY_HEURISTICS (decrease the
diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 589f6b4404f0..cc313d16d727 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -666,10 +666,11 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	 * to wait for at least one CHECK_CONDITION to determine
 	 * SANE_SENSE support
 	 */
-	if ((srb-&gt;cmnd[0] == ATA_16 || srb-&gt;cmnd[0] == ATA_12) &amp;&amp;
+	if (unlikely((srb-&gt;cmnd[0] == ATA_16 || srb-&gt;cmnd[0] == ATA_12) &amp;&amp;
 	    result == USB_STOR_TRANSPORT_GOOD &amp;&amp;
 	    !(us-&gt;fflags &amp; US_FL_SANE_SENSE) &amp;&amp;
-	    !(srb-&gt;cmnd[2] &amp; 0x20)) {
+	    !(us-&gt;fflags &amp; US_FL_BAD_SENSE) &amp;&amp;
+	    !(srb-&gt;cmnd[2] &amp; 0x20))) {
 		US_DEBUGP("-- SAT supported, increasing auto-sense\n");
 		us-&gt;fflags |= US_FL_SANE_SENSE;
 	}
@@ -718,6 +719,12 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
 			US_DEBUGP("-- auto-sense aborted\n");
 			srb-&gt;result = DID_ABORT &lt;&lt; 16;
+
+			/* If SANE_SENSE caused this problem, disable it */
+			if (sense_size != US_SENSE_SIZE) {
+				us-&gt;fflags &amp;= ~US_FL_SANE_SENSE;
+				us-&gt;fflags |= US_FL_BAD_SENSE;
+			}
 			goto Handle_Errors;
 		}
 
@@ -727,10 +734,11 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		 * (small) sense request. This fixes some USB GSM modems
 		 */
 		if (temp_result == USB_STOR_TRANSPORT_FAILED &amp;&amp;
-		    (us-&gt;fflags &amp; US_FL_SANE_SENSE) &amp;&amp;
-		    sense_size != US_SENSE_SIZE) {
+				sense_size != US_SENSE_SIZE) {
 			US_DEBUGP("-- auto-sense failure, retry small sense\n");
 			sense_size = US_SENSE_SIZE;
+			us-&gt;fflags &amp;= ~US_FL_SANE_SENSE;
+			us-&gt;fflags |= US_FL_BAD_SENSE;
 			goto Retry_Sense;
 		}
 
@@ -754,6 +762,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		 */
 		if (srb-&gt;sense_buffer[7] &gt; (US_SENSE_SIZE - 8) &amp;&amp;
 		    !(us-&gt;fflags &amp; US_FL_SANE_SENSE) &amp;&amp;
+		    !(us-&gt;fflags &amp; US_FL_BAD_SENSE) &amp;&amp;
 		    (srb-&gt;sense_buffer[0] &amp; 0x7C) == 0x70) {
 			US_DEBUGP("-- SANE_SENSE support enabled\n");
 			us-&gt;fflags |= US_FL_SANE_SENSE;
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index d4f034ebaa8a..64a0a2c27e12 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -818,6 +818,13 @@ UNUSUAL_DEV( 0x066f, 0x8000, 0x0001, 0x0001,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_CAPACITY ),
 
+/* Reported by Daniel Kukula &lt;daniel.kuku@gmail.com&gt; */
+UNUSUAL_DEV( 0x067b, 0x1063, 0x0100, 0x0100,
+		"Prolific Technology, Inc.",
+		"Prolific Storage Gadget",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_BAD_SENSE ),
+
 /* Reported by Rogerio Brito &lt;rbrito@ime.usp.br&gt; */
 UNUSUAL_DEV( 0x067b, 0x2317, 0x0001, 0x001,
 		"Prolific Technology, Inc.",
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 1599d86154c4..f5c0264caa33 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -463,6 +463,9 @@ static void adjust_quirks(struct us_data *us)
 		case 'a':
 			f |= US_FL_SANE_SENSE;
 			break;
+		case 'b':
+			f |= US_FL_BAD_SENSE;
+			break;
 		case 'c':
 			f |= US_FL_FIX_CAPACITY;
 			break;
diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h
index 3d15fb9bc116..a4b947e470a5 100644
--- a/include/linux/usb_usual.h
+++ b/include/linux/usb_usual.h
@@ -56,7 +56,9 @@
 	US_FLAG(SANE_SENSE,     0x00008000)			\
 		/* Sane Sense (&gt; 18 bytes) */			\
 	US_FLAG(CAPACITY_OK,	0x00010000)			\
-		/* READ CAPACITY response is correct */
+		/* READ CAPACITY response is correct */		\
+	US_FLAG(BAD_SENSE,	0x00020000)			\
+		/* Bad Sense (never more than 18 bytes) */
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };</pre><hr><pre>commit 8e4ceb38eb5bbaef22fc00abe9bc11e26bea2ab5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 7 13:01:37 2009 -0500

    USB: prepare for changover to Runtime PM framework
    
    This patch (as1303) revises the USB Power Management infrastructure to
    make it compatible with the new driver-model Runtime PM framework:
    
            Drivers are no longer allowed to access intf-&gt;pm_usage_cnt
            directly; the PM framework manages its own usage counters.
    
            usb_autopm_set_interface() is eliminated, because it directly
            sets intf-&gt;pm_usage_cnt.
    
            usb_autopm_enable() and usb_autopm_disable() are eliminated,
            because they call usb_autopm_set_interface().
    
            usb_autopm_get_interface_no_resume() and
            usb_autopm_put_interface_no_suspend() are added.  They
            correspond to pm_runtime_get_noresume() and
            pm_runtime_put_noidle() in the PM framework.
    
            The power/level attribute no longer accepts "suspend", only
            "on" and "auto".  The PM framework doesn't allow devices to be
            forced into a suspended mode.
    
    The hub driver contains the only code that violates the new
    guidelines.  It is updated to use the new interface routines instead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index 8817368203d6..c7c1dc2f8017 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -2,7 +2,7 @@
 
 		 Alan Stern &lt;stern@rowland.harvard.edu&gt;
 
-			    October 5, 2007
+			    November 10, 2009
 
 
 
@@ -123,9 +123,9 @@ relevant attribute files are: wakeup, level, and autosuspend.
 
 	power/level
 
-		This file contains one of three words: "on", "auto",
-		or "suspend".  You can write those words to the file
-		to change the device's setting.
+		This file contains one of two words: "on" or "auto".
+		You can write those words to the file to change the
+		device's setting.
 
 		"on" means that the device should be resumed and
 		autosuspend is not allowed.  (Of course, system
@@ -134,10 +134,10 @@ relevant attribute files are: wakeup, level, and autosuspend.
 		"auto" is the normal state in which the kernel is
 		allowed to autosuspend and autoresume the device.
 
-		"suspend" means that the device should remain
-		suspended, and autoresume is not allowed.  (But remote
-		wakeup may still be allowed, since it is controlled
-		separately by the power/wakeup attribute.)
+		(In kernels up to 2.6.32, you could also specify
+		"suspend", meaning that the device should remain
+		suspended and autoresume was not allowed.  This
+		setting is no longer supported.)
 
 	power/autosuspend
 
@@ -313,13 +313,14 @@ three of the methods listed above.  In addition, a driver indicates
 that it supports autosuspend by setting the .supports_autosuspend flag
 in its usb_driver structure.  It is then responsible for informing the
 USB core whenever one of its interfaces becomes busy or idle.  The
-driver does so by calling these five functions:
+driver does so by calling these six functions:
 
 	int  usb_autopm_get_interface(struct usb_interface *intf);
 	void usb_autopm_put_interface(struct usb_interface *intf);
-	int  usb_autopm_set_interface(struct usb_interface *intf);
 	int  usb_autopm_get_interface_async(struct usb_interface *intf);
 	void usb_autopm_put_interface_async(struct usb_interface *intf);
+	void usb_autopm_get_interface_no_resume(struct usb_interface *intf);
+	void usb_autopm_put_interface_no_suspend(struct usb_interface *intf);
 
 The functions work by maintaining a counter in the usb_interface
 structure.  When intf-&gt;pm_usage_count is &gt; 0 then the interface is
@@ -331,11 +332,13 @@ considered to be idle, and the kernel may autosuspend the device.
 associated with the device itself rather than any of its interfaces.
 This field is used only by the USB core.)
 
-The driver owns intf-&gt;pm_usage_count; it can modify the value however
-and whenever it likes.  A nice aspect of the non-async usb_autopm_*
-routines is that the changes they make are protected by the usb_device
-structure's PM mutex (udev-&gt;pm_mutex); however drivers may change
-pm_usage_count without holding the mutex.  Drivers using the async
+Drivers must not modify intf-&gt;pm_usage_count directly; its value
+should be changed only be using the functions listed above.  Drivers
+are responsible for insuring that the overall change to pm_usage_count
+during their lifetime balances out to 0 (it may be necessary for the
+disconnect method to call usb_autopm_put_interface() one or more times
+to fulfill this requirement).  The first two routines use the PM mutex
+in struct usb_device for mutual exclusion; drivers using the async
 routines are responsible for their own synchronization and mutual
 exclusion.
 
@@ -347,11 +350,6 @@ exclusion.
 	attempts an autosuspend if the new value is &lt;= 0 and the
 	device isn't suspended.
 
-	usb_autopm_set_interface() leaves pm_usage_count alone.
-	It attempts an autoresume if the value is &gt; 0 and the device
-	is suspended, and it attempts an autosuspend if the value is
-	&lt;= 0 and the device isn't suspended.
-
 	usb_autopm_get_interface_async() and
 	usb_autopm_put_interface_async() do almost the same things as
 	their non-async counterparts.  The differences are: they do
@@ -360,13 +358,11 @@ exclusion.
 	such as an URB's completion handler, but when they return the
 	device will not generally not yet be in the desired state.
 
-There also are a couple of utility routines drivers can use:
-
-	usb_autopm_enable() sets pm_usage_cnt to 0 and then calls
-	usb_autopm_set_interface(), which will attempt an autosuspend.
-
-	usb_autopm_disable() sets pm_usage_cnt to 1 and then calls
-	usb_autopm_set_interface(), which will attempt an autoresume.
+	usb_autopm_get_interface_no_resume() and
+	usb_autopm_put_interface_no_suspend() merely increment or
+	decrement the pm_usage_count value; they do not attempt to
+	carry out an autoresume or an autosuspend.  Hence they can be
+	called in an atomic context.
 
 The conventional usage pattern is that a driver calls
 usb_autopm_get_interface() in its open routine and
@@ -400,11 +396,11 @@ though, setting this flag won't cause the kernel to autoresume it.
 Normally a driver would set this flag in its probe method, at which
 time the device is guaranteed not to be autosuspended.)
 
-The usb_autopm_* routines have to run in a sleepable process context;
-they must not be called from an interrupt handler or while holding a
-spinlock.  In fact, the entire autosuspend mechanism is not well geared
-toward interrupt-driven operation.  However there is one thing a
-driver can do in an interrupt handler:
+The synchronous usb_autopm_* routines have to run in a sleepable
+process context; they must not be called from an interrupt handler or
+while holding a spinlock.  In fact, the entire autosuspend mechanism
+is not well geared toward interrupt-driven operation.  However there
+is one thing a driver can do in an interrupt handler:
 
 	usb_mark_last_busy(struct usb_device *udev);
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8016a296010e..7a05bab73960 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -948,8 +948,6 @@ static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 
  done:
 	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __func__, status);
-	if (status == 0)
-		udev-&gt;autoresume_disabled = 0;
 	return status;
 }
 
@@ -1280,11 +1278,6 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		if ((msg.event &amp; PM_EVENT_AUTO) &amp;&amp;
-				udev-&gt;autoresume_disabled) {
-			status = -EPERM;
-			goto done;
-		}
 		if (parent) {
 			status = usb_autoresume_device(parent);
 			if (status == 0) {
@@ -1638,8 +1631,6 @@ int usb_autopm_get_interface_async(struct usb_interface *intf)
 
 	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
 		status = -ENODEV;
-	else if (udev-&gt;autoresume_disabled)
-		status = -EPERM;
 	else {
 		atomic_inc(&amp;intf-&gt;pm_usage_cnt);
 		if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0 &amp;&amp;
@@ -1652,28 +1643,6 @@ int usb_autopm_get_interface_async(struct usb_interface *intf)
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface_async);
 
-/**
- * usb_autopm_set_interface - set a USB interface's autosuspend state
- * @intf: the usb_interface whose state should be set
- *
- * This routine sets the autosuspend state of @intf's device according
- * to @intf's usage counter, which the caller must have set previously.
- * If the counter is &lt;= 0, the device is autosuspended (if it isn't
- * already suspended and if nothing else prevents the autosuspend).  If
- * the counter is &gt; 0, the device is autoresumed (if it isn't already
- * awake).
- */
-int usb_autopm_set_interface(struct usb_interface *intf)
-{
-	int	status;
-
-	status = usb_autopm_do_interface(intf, 0);
-	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
-	return status;
-}
-EXPORT_SYMBOL_GPL(usb_autopm_set_interface);
-
 #else
 
 void usb_autosuspend_work(struct work_struct *work)
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5413d712cae0..b38fd6730e2a 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -71,6 +71,7 @@ struct usb_hub {
 
 	unsigned		mA_per_port;	/* current for each child */
 
+	unsigned		init_done:1;
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		disconnected:1;
@@ -375,12 +376,13 @@ static void kick_khubd(struct usb_hub *hub)
 {
 	unsigned long	flags;
 
-	/* Suppress autosuspend until khubd runs */
-	atomic_set(&amp;to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt, 1);
-
 	spin_lock_irqsave(&amp;hub_event_lock, flags);
 	if (!hub-&gt;disconnected &amp;&amp; list_empty(&amp;hub-&gt;event_list)) {
 		list_add_tail(&amp;hub-&gt;event_list, &amp;hub_event_list);
+
+		/* Suppress autosuspend until khubd runs */
+		usb_autopm_get_interface_no_resume(
+				to_usb_interface(hub-&gt;intfdev));
 		wake_up(&amp;khubd_wait);
 	}
 	spin_unlock_irqrestore(&amp;hub_event_lock, flags);
@@ -665,7 +667,7 @@ int usb_remove_device(struct usb_device *udev)
 }
 
 enum hub_activation_type {
-	HUB_INIT, HUB_INIT2, HUB_INIT3,
+	HUB_INIT, HUB_INIT2, HUB_INIT3,		/* INITs must come first */
 	HUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,
 };
 
@@ -710,8 +712,8 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 					msecs_to_jiffies(delay));
 
 			/* Suppress autosuspend until init is done */
-			atomic_set(&amp;to_usb_interface(hub-&gt;intfdev)-&gt;
-					pm_usage_cnt, 1);
+			usb_autopm_get_interface_no_resume(
+					to_usb_interface(hub-&gt;intfdev));
 			return;		/* Continues at init2: below */
 		} else {
 			hub_power_on(hub, true);
@@ -818,6 +820,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	}
  init3:
 	hub-&gt;quiescing = 0;
+	hub-&gt;init_done = 1;
 
 	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
 	if (status &lt; 0)
@@ -827,6 +830,10 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 
 	/* Scan all ports that need attention */
 	kick_khubd(hub);
+
+	/* Allow autosuspend if it was suppressed */
+	if (type &lt;= HUB_INIT3)
+		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
 }
 
 /* Implement the continuations for the delays above */
@@ -854,6 +861,11 @@ static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)
 	int i;
 
 	cancel_delayed_work_sync(&amp;hub-&gt;init_work);
+	if (!hub-&gt;init_done) {
+		hub-&gt;init_done = 1;
+		usb_autopm_put_interface_no_suspend(
+				to_usb_interface(hub-&gt;intfdev));
+	}
 
 	/* khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
@@ -1176,7 +1188,10 @@ static void hub_disconnect(struct usb_interface *intf)
 
 	/* Take the hub off the event list and don't let it be added again */
 	spin_lock_irq(&amp;hub_event_lock);
-	list_del_init(&amp;hub-&gt;event_list);
+	if (!list_empty(&amp;hub-&gt;event_list)) {
+		list_del_init(&amp;hub-&gt;event_list);
+		usb_autopm_put_interface_no_suspend(intf);
+	}
 	hub-&gt;disconnected = 1;
 	spin_unlock_irq(&amp;hub_event_lock);
 
@@ -3235,7 +3250,7 @@ static void hub_events(void)
 		 * disconnected while waiting for the lock to succeed. */
 		usb_lock_device(hdev);
 		if (unlikely(hub-&gt;disconnected))
-			goto loop;
+			goto loop2;
 
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
@@ -3384,11 +3399,15 @@ static void hub_events(void)
 			}
 		}
 
-loop_autopm:
-		/* Allow autosuspend if we're not going to run again */
-		if (list_empty(&amp;hub-&gt;event_list))
-			usb_autopm_enable(intf);
-loop:
+ loop_autopm:
+		/* Balance the usb_autopm_get_interface() above */
+		usb_autopm_put_interface_no_suspend(intf);
+ loop:
+		/* Balance the usb_autopm_get_interface_no_resume() in
+		 * kick_khubd() and allow autosuspend.
+		 */
+		usb_autopm_put_interface(intf);
+ loop2:
 		usb_unlock_device(hdev);
 		kref_put(&amp;hub-&gt;kref, hub_release);
 
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index ae763974be25..15477008b631 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -327,7 +327,6 @@ static DEVICE_ATTR(autosuspend, S_IRUGO | S_IWUSR,
 
 static const char on_string[] = "on";
 static const char auto_string[] = "auto";
-static const char suspend_string[] = "suspend";
 
 static ssize_t
 show_level(struct device *dev, struct device_attribute *attr, char *buf)
@@ -335,13 +334,8 @@ show_level(struct device *dev, struct device_attribute *attr, char *buf)
 	struct usb_device *udev = to_usb_device(dev);
 	const char *p = auto_string;
 
-	if (udev-&gt;state == USB_STATE_SUSPENDED) {
-		if (udev-&gt;autoresume_disabled)
-			p = suspend_string;
-	} else {
-		if (udev-&gt;autosuspend_disabled)
-			p = on_string;
-	}
+	if (udev-&gt;state != USB_STATE_SUSPENDED &amp;&amp; udev-&gt;autosuspend_disabled)
+		p = on_string;
 	return sprintf(buf, "%s\n", p);
 }
 
@@ -353,7 +347,7 @@ set_level(struct device *dev, struct device_attribute *attr,
 	int len = count;
 	char *cp;
 	int rc = 0;
-	int old_autosuspend_disabled, old_autoresume_disabled;
+	int old_autosuspend_disabled;
 
 	cp = memchr(buf, '\n', count);
 	if (cp)
@@ -361,7 +355,6 @@ set_level(struct device *dev, struct device_attribute *attr,
 
 	usb_lock_device(udev);
 	old_autosuspend_disabled = udev-&gt;autosuspend_disabled;
-	old_autoresume_disabled = udev-&gt;autoresume_disabled;
 
 	/* Setting the flags without calling usb_pm_lock is a subject to
 	 * races, but who cares...
@@ -369,28 +362,18 @@ set_level(struct device *dev, struct device_attribute *attr,
 	if (len == sizeof on_string - 1 &amp;&amp;
 			strncmp(buf, on_string, len) == 0) {
 		udev-&gt;autosuspend_disabled = 1;
-		udev-&gt;autoresume_disabled = 0;
 		rc = usb_external_resume_device(udev, PMSG_USER_RESUME);
 
 	} else if (len == sizeof auto_string - 1 &amp;&amp;
 			strncmp(buf, auto_string, len) == 0) {
 		udev-&gt;autosuspend_disabled = 0;
-		udev-&gt;autoresume_disabled = 0;
 		rc = usb_external_resume_device(udev, PMSG_USER_RESUME);
 
-	} else if (len == sizeof suspend_string - 1 &amp;&amp;
-			strncmp(buf, suspend_string, len) == 0) {
-		udev-&gt;autosuspend_disabled = 0;
-		udev-&gt;autoresume_disabled = 1;
-		rc = usb_external_suspend_device(udev, PMSG_USER_SUSPEND);
-
 	} else
 		rc = -EINVAL;
 
-	if (rc) {
+	if (rc)
 		udev-&gt;autosuspend_disabled = old_autosuspend_disabled;
-		udev-&gt;autoresume_disabled = old_autoresume_disabled;
-	}
 	usb_unlock_device(udev);
 	return (rc &lt; 0 ? rc : count);
 }
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 4b6f6db544ee..6af3581e1114 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -432,7 +432,6 @@ struct usb_tt;
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
  * @autosuspend_disabled: autosuspend disabled by the user
- * @autoresume_disabled: autoresume disabled by the user
  * @skip_sys_resume: skip the next system resume
  * @wusb_dev: if this is a Wireless USB device, link to the WUSB
  *	specific data for the device.
@@ -516,7 +515,6 @@ struct usb_device {
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
 	unsigned autosuspend_disabled:1;
-	unsigned autoresume_disabled:1;
 	unsigned skip_sys_resume:1;
 #endif
 	struct wusb_dev *wusb_dev;
@@ -542,22 +540,20 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
-extern int usb_autopm_set_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface_async(struct usb_interface *intf);
 extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 
-static inline void usb_autopm_enable(struct usb_interface *intf)
+static inline void usb_autopm_get_interface_no_resume(
+		struct usb_interface *intf)
 {
-	atomic_set(&amp;intf-&gt;pm_usage_cnt, 0);
-	usb_autopm_set_interface(intf);
+	atomic_inc(&amp;intf-&gt;pm_usage_cnt);
 }
-
-static inline void usb_autopm_disable(struct usb_interface *intf)
+static inline void usb_autopm_put_interface_no_suspend(
+		struct usb_interface *intf)
 {
-	atomic_set(&amp;intf-&gt;pm_usage_cnt, 1);
-	usb_autopm_set_interface(intf);
+	atomic_dec(&amp;intf-&gt;pm_usage_cnt);
 }
 
 static inline void usb_mark_last_busy(struct usb_device *udev)
@@ -567,12 +563,8 @@ static inline void usb_mark_last_busy(struct usb_device *udev)
 
 #else
 
-static inline int usb_autopm_set_interface(struct usb_interface *intf)
-{ return 0; }
-
 static inline int usb_autopm_get_interface(struct usb_interface *intf)
 { return 0; }
-
 static inline int usb_autopm_get_interface_async(struct usb_interface *intf)
 { return 0; }
 
@@ -580,9 +572,11 @@ static inline void usb_autopm_put_interface(struct usb_interface *intf)
 { }
 static inline void usb_autopm_put_interface_async(struct usb_interface *intf)
 { }
-static inline void usb_autopm_enable(struct usb_interface *intf)
+static inline void usb_autopm_get_interface_no_resume(
+		struct usb_interface *intf)
 { }
-static inline void usb_autopm_disable(struct usb_interface *intf)
+static inline void usb_autopm_put_interface_no_suspend(
+		struct usb_interface *intf)
 { }
 static inline void usb_mark_last_busy(struct usb_device *udev)
 { }</pre><hr><pre>commit fb34d53752d5bec5acc73422e462a9c68aeeaa2a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 13 11:53:59 2009 -0500

    USB: remove the auto_pm flag
    
    This patch (as1302) removes the auto_pm flag from struct usb_device.
    The flag's only purpose was to distinguish between autosuspends and
    external suspends, but that information is now available in the
    pm_message_t argument passed to suspend methods.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index ad642615ad4c..8817368203d6 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -423,15 +423,16 @@ an URB had completed too recently.
 
 External suspend calls should never be allowed to fail in this way,
 only autosuspend calls.  The driver can tell them apart by checking
-udev-&gt;auto_pm; this flag will be set to 1 for internal PM events
-(autosuspend or autoresume) and 0 for external PM events.
+the PM_EVENT_AUTO bit in the message.event argument to the suspend
+method; this bit will be set for internal PM events (autosuspend) and
+clear for external PM events.
 
 Many of the ingredients in the autosuspend framework are oriented
 towards interfaces: The usb_interface structure contains the
 pm_usage_cnt field, and the usb_autopm_* routines take an interface
 pointer as their argument.  But somewhat confusingly, a few of the
-pieces (usb_mark_last_busy() and udev-&gt;auto_pm) use the usb_device
-structure instead.  Drivers need to keep this straight; they can call
+pieces (i.e., usb_mark_last_busy()) use the usb_device structure
+instead.  Drivers need to keep this straight; they can call
 interface_to_usbdev() to find the device structure for a given
 interface.
 
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 44bc8bbabf54..4d2905996751 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -1066,7 +1066,7 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 		return 0;
 
 	spin_lock_irq(&amp;data-&gt;txlock);
-	if (!(interface_to_usbdev(intf)-&gt;auto_pm &amp;&amp; data-&gt;tx_in_flight)) {
+	if (!((message.event &amp; PM_EVENT_AUTO) &amp;&amp; data-&gt;tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &amp;data-&gt;flags);
 		spin_unlock_irq(&amp;data-&gt;txlock);
 	} else {
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 0258289f3b3e..e2997a8d5e1b 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1253,10 +1253,9 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct hid_device *hid = usb_get_intfdata(intf);
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
-	struct usb_device *udev = interface_to_usbdev(intf);
 	int status;
 
-	if (udev-&gt;auto_pm) {
+	if (message.event &amp; PM_EVENT_AUTO) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);	/* Sync with error handler */
 		if (!test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)
 		    &amp;&amp; !test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl)
@@ -1281,7 +1280,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 			return -EIO;
 	}
 
-	if (!ignoreled &amp;&amp; udev-&gt;auto_pm) {
+	if (!ignoreled &amp;&amp; (message.event &amp; PM_EVENT_AUTO)) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);
 		if (test_bit(HID_LED_ON, &amp;usbhid-&gt;iofl)) {
 			spin_unlock_irq(&amp;usbhid-&gt;lock);
@@ -1294,7 +1293,8 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 	hid_cancel_delayed_stuff(usbhid);
 	hid_cease_io(usbhid);
 
-	if (udev-&gt;auto_pm &amp;&amp; test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
+	if ((message.event &amp; PM_EVENT_AUTO) &amp;&amp;
+			test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
 		/* lost race against keypresses */
 		status = hid_start_in(hid);
 		if (status &lt; 0)
diff --git a/drivers/net/wimax/i2400m/usb.c b/drivers/net/wimax/i2400m/usb.c
index 47e84ef355c5..3b48681f8a0d 100644
--- a/drivers/net/wimax/i2400m/usb.c
+++ b/drivers/net/wimax/i2400m/usb.c
@@ -579,7 +579,7 @@ void i2400mu_disconnect(struct usb_interface *iface)
  *
  *    As well, the device might refuse going to sleep for whichever
  *    reason. In this case we just fail. For system suspend/hibernate,
- *    we *can't* fail. We look at usb_dev-&gt;auto_pm to see if the
+ *    we *can't* fail. We check PM_EVENT_AUTO to see if the
  *    suspend call comes from the USB stack or from the system and act
  *    in consequence.
  *
@@ -591,14 +591,11 @@ int i2400mu_suspend(struct usb_interface *iface, pm_message_t pm_msg)
 	int result = 0;
 	struct device *dev = &amp;iface-&gt;dev;
 	struct i2400mu *i2400mu = usb_get_intfdata(iface);
-#ifdef CONFIG_PM
-	struct usb_device *usb_dev = i2400mu-&gt;usb_dev;
-#endif
 	unsigned is_autosuspend = 0;
 	struct i2400m *i2400m = &amp;i2400mu-&gt;i2400m;
 
 #ifdef CONFIG_PM
-	if (usb_dev-&gt;auto_pm &gt; 0)
+	if (pm_msg.event &amp; PM_EVENT_AUTO)
 		is_autosuspend = 1;
 #endif
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 4f864472c5c4..8016a296010e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1341,7 +1341,6 @@ static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
 	int	status = 0;
 
 	usb_pm_lock(udev);
-	udev-&gt;auto_pm = 1;
 	udev-&gt;pm_usage_cnt += inc_usage_cnt;
 	WARN_ON(udev-&gt;pm_usage_cnt &lt; 0);
 	if (inc_usage_cnt)
@@ -1473,7 +1472,6 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
 		status = -ENODEV;
 	else {
-		udev-&gt;auto_pm = 1;
 		atomic_add(inc_usage_cnt, &amp;intf-&gt;pm_usage_cnt);
 		udev-&gt;last_busy = jiffies;
 		if (inc_usage_cnt &gt;= 0 &amp;&amp;
@@ -1707,7 +1705,6 @@ int usb_external_suspend_device(struct usb_device *udev, pm_message_t msg)
 
 	do_unbind_rebind(udev, DO_UNBIND);
 	usb_pm_lock(udev);
-	udev-&gt;auto_pm = 0;
 	status = usb_suspend_both(udev, msg);
 	usb_pm_unlock(udev);
 	return status;
@@ -1730,7 +1727,6 @@ int usb_external_resume_device(struct usb_device *udev, pm_message_t msg)
 	int	status;
 
 	usb_pm_lock(udev);
-	udev-&gt;auto_pm = 0;
 	status = usb_resume_both(udev, msg);
 	udev-&gt;last_busy = jiffies;
 	usb_pm_unlock(udev);
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 0d46bbec44b7..8751ec79a159 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -1313,7 +1313,7 @@ static int option_suspend(struct usb_serial *serial, pm_message_t message)
 
 	dbg("%s entered", __func__);
 
-	if (serial-&gt;dev-&gt;auto_pm) {
+	if (message.event &amp; PM_EVENT_AUTO) {
 		spin_lock_irq(&amp;intfdata-&gt;susp_lock);
 		b = intfdata-&gt;in_flight;
 		spin_unlock_irq(&amp;intfdata-&gt;susp_lock);
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index c5c41aed106d..ac1b6449fb6a 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -1005,7 +1005,7 @@ static int sierra_suspend(struct usb_serial *serial, pm_message_t message)
 	struct sierra_intf_private *intfdata;
 	int b;
 
-	if (serial-&gt;dev-&gt;auto_pm) {
+	if (message.event &amp; PM_EVENT_AUTO) {
 		intfdata = serial-&gt;private;
 		spin_lock_irq(&amp;intfdata-&gt;susp_lock);
 		b = intfdata-&gt;in_flight;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 6e91ee4f5b81..4b6f6db544ee 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -429,7 +429,6 @@ struct usb_tt;
  * @last_busy: time of last use
  * @autosuspend_delay: in jiffies
  * @connect_time: time device was first connected
- * @auto_pm: autosuspend/resume in progress
  * @do_remote_wakeup:  remote wakeup should be enabled
  * @reset_resume: needs reset instead of resume
  * @autosuspend_disabled: autosuspend disabled by the user
@@ -514,7 +513,6 @@ struct usb_device {
 	int autosuspend_delay;
 	unsigned long connect_time;
 
-	unsigned auto_pm:1;
 	unsigned do_remote_wakeup:1;
 	unsigned reset_resume:1;
 	unsigned autosuspend_disabled:1;</pre><hr><pre>commit b375e1169d8ecc9e9db3ecba8147d484b5510833
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 6 12:32:23 2009 -0500

    USB: add scatter-gather support to usbmon
    
    This patch (as1301) adds support to usbmon for scatter-gather URBs.
    The text interface looks at only the first scatterlist element, since
    it never copies more than 32 bytes of data anyway.  The binary
    interface copies as much data as possible up to the first
    non-addressable buffer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index 10f3205798e8..385ec0520167 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -16,6 +16,7 @@
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/smp_lock.h&gt;
+#include &lt;linux/scatterlist.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
 
@@ -221,7 +222,7 @@ static void mon_free_buff(struct mon_pgmap *map, int npages);
 /*
  * This is a "chunked memcpy". It does not manipulate any counters.
  */
-static void mon_copy_to_buff(const struct mon_reader_bin *this,
+static unsigned int mon_copy_to_buff(const struct mon_reader_bin *this,
     unsigned int off, const unsigned char *from, unsigned int length)
 {
 	unsigned int step_len;
@@ -246,6 +247,7 @@ static void mon_copy_to_buff(const struct mon_reader_bin *this,
 		from += step_len;
 		length -= step_len;
 	}
+	return off;
 }
 
 /*
@@ -394,14 +396,44 @@ static inline char mon_bin_get_setup(unsigned char *setupb,
 	return 0;
 }
 
-static char mon_bin_get_data(const struct mon_reader_bin *rp,
-    unsigned int offset, struct urb *urb, unsigned int length)
+static unsigned int mon_bin_get_data(const struct mon_reader_bin *rp,
+    unsigned int offset, struct urb *urb, unsigned int length,
+    char *flag)
 {
+	int i;
+	struct scatterlist *sg;
+	unsigned int this_len;
+
+	*flag = 0;
+	if (urb-&gt;num_sgs == 0) {
+		if (urb-&gt;transfer_buffer == NULL) {
+			*flag = 'Z';
+			return length;
+		}
+		mon_copy_to_buff(rp, offset, urb-&gt;transfer_buffer, length);
+		length = 0;
 
-	if (urb-&gt;transfer_buffer == NULL)
-		return 'Z';
-	mon_copy_to_buff(rp, offset, urb-&gt;transfer_buffer, length);
-	return 0;
+	} else {
+		/* If IOMMU coalescing occurred, we cannot trust sg_page */
+		if (urb-&gt;sg-&gt;nents != urb-&gt;num_sgs) {
+			*flag = 'D';
+			return length;
+		}
+
+		/* Copy up to the first non-addressable segment */
+		for_each_sg(urb-&gt;sg-&gt;sg, sg, urb-&gt;num_sgs, i) {
+			if (length == 0 || PageHighMem(sg_page(sg)))
+				break;
+			this_len = min_t(unsigned int, sg-&gt;length, length);
+			offset = mon_copy_to_buff(rp, offset, sg_virt(sg),
+					this_len);
+			length -= this_len;
+		}
+		if (i == 0)
+			*flag = 'D';
+	}
+
+	return length;
 }
 
 static void mon_bin_get_isodesc(const struct mon_reader_bin *rp,
@@ -536,8 +568,9 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	}
 
 	if (length != 0) {
-		ep-&gt;flag_data = mon_bin_get_data(rp, offset, urb, length);
-		if (ep-&gt;flag_data != 0) {	/* Yes, it's 0x00, not '0' */
+		length = mon_bin_get_data(rp, offset, urb, length,
+				&amp;ep-&gt;flag_data);
+		if (length &gt; 0) {
 			delta = (ep-&gt;len_cap + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
 			ep-&gt;len_cap -= length;
 			delta -= (ep-&gt;len_cap + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 9f1a9227ebe6..047568ff223d 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -10,6 +10,7 @@
 #include &lt;linux/time.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/debugfs.h&gt;
+#include &lt;linux/scatterlist.h&gt;
 #include &lt;asm/uaccess.h&gt;
 
 #include "usb_mon.h"
@@ -137,6 +138,8 @@ static inline char mon_text_get_setup(struct mon_event_text *ep,
 static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
     int len, char ev_type, struct mon_bus *mbus)
 {
+	void *src;
+
 	if (len &lt;= 0)
 		return 'L';
 	if (len &gt;= DATA_MAX)
@@ -150,10 +153,24 @@ static inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,
 			return '&gt;';
 	}
 
-	if (urb-&gt;transfer_buffer == NULL)
-		return 'Z';	/* '0' would be not as pretty. */
+	if (urb-&gt;num_sgs == 0) {
+		src = urb-&gt;transfer_buffer;
+		if (src == NULL)
+			return 'Z';	/* '0' would be not as pretty. */
+	} else {
+		struct scatterlist *sg = urb-&gt;sg-&gt;sg;
+
+		/* If IOMMU coalescing occurred, we cannot trust sg_page */
+		if (urb-&gt;sg-&gt;nents != urb-&gt;num_sgs ||
+				PageHighMem(sg_page(sg)))
+			return 'D';
+
+		/* For the text interface we copy only the first sg buffer */
+		len = min_t(int, sg-&gt;length, len);
+		src = sg_virt(sg);
+	}
 
-	memcpy(ep-&gt;data, urb-&gt;transfer_buffer, len);
+	memcpy(ep-&gt;data, src, len);
 	return 0;
 }
 </pre><hr><pre>commit 40f8db8f8f5af2cafeb976ae15e11aca641a931d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 6 12:29:40 2009 -0500

    USB: EHCI: add native scatter-gather support
    
    This patch (as1300) adds native scatter-gather support to ehci-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2a3265087ef3..5859522d6edd 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -605,6 +605,8 @@ static int ehci_init(struct usb_hcd *hcd)
 	}
 	ehci-&gt;command = temp;
 
+	/* Accept arbitrarily long scatter-gather lists */
+	hcd-&gt;self.sg_tablesize = ~0;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 139a2cc3f641..a427d3b00634 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -616,9 +616,11 @@ qh_urb_transaction (
 ) {
 	struct ehci_qtd		*qtd, *qtd_prev;
 	dma_addr_t		buf;
-	int			len, maxpacket;
+	int			len, this_sg_len, maxpacket;
 	int			is_input;
 	u32			token;
+	int			i;
+	struct scatterlist	*sg;
 
 	/*
 	 * URBs map to sequences of QTDs:  one logical transaction
@@ -659,7 +661,20 @@ qh_urb_transaction (
 	/*
 	 * data transfer stage:  buffer setup
 	 */
-	buf = urb-&gt;transfer_dma;
+	i = urb-&gt;num_sgs;
+	if (len &gt; 0 &amp;&amp; i &gt; 0) {
+		sg = urb-&gt;sg-&gt;sg;
+		buf = sg_dma_address(sg);
+
+		/* urb-&gt;transfer_buffer_length may be smaller than the
+		 * size of the scatterlist (or vice versa)
+		 */
+		this_sg_len = min_t(int, sg_dma_len(sg), len);
+	} else {
+		sg = NULL;
+		buf = urb-&gt;transfer_dma;
+		this_sg_len = len;
+	}
 
 	if (is_input)
 		token |= (1 /* "in" */ &lt;&lt; 8);
@@ -675,7 +690,9 @@ qh_urb_transaction (
 	for (;;) {
 		int this_qtd_len;
 
-		this_qtd_len = qtd_fill(ehci, qtd, buf, len, token, maxpacket);
+		this_qtd_len = qtd_fill(ehci, qtd, buf, this_sg_len, token,
+				maxpacket);
+		this_sg_len -= this_qtd_len;
 		len -= this_qtd_len;
 		buf += this_qtd_len;
 
@@ -691,8 +708,13 @@ qh_urb_transaction (
 		if ((maxpacket &amp; (this_qtd_len + (maxpacket - 1))) == 0)
 			token ^= QTD_TOGGLE;
 
-		if (likely (len &lt;= 0))
-			break;
+		if (likely(this_sg_len &lt;= 0)) {
+			if (--i &lt;= 0 || len &lt;= 0)
+				break;
+			sg = sg_next(sg);
+			buf = sg_dma_address(sg);
+			this_sg_len = min_t(int, sg_dma_len(sg), len);
+		}
 
 		qtd_prev = qtd;
 		qtd = ehci_qtd_alloc (ehci, flags);</pre><hr><pre>commit ed1db3ada189c9af592c4d2971b22b482b68aafe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 27 15:26:50 2009 -0400

    USB: fix a bug in the scatter-gather library
    
    This patch (as1298) fixes a bug in the new scatter-gather URB
    facility.  If an URB uses a scatterlist then it should not have the
    URB_NO_INTERRUPT flag set; otherwise the system won't be notified when
    the transfer completes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Vrabel &lt;david.vrabel@csr.com&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 8d874cad6581..adb9c8ee0c1f 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -403,7 +403,7 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 	if (!io-&gt;urbs)
 		goto nomem;
 
-	urb_flags = URB_NO_INTERRUPT;
+	urb_flags = 0;
 	if (dma)
 		urb_flags |= URB_NO_TRANSFER_DMA_MAP;
 	if (usb_pipein(pipe))
@@ -435,6 +435,7 @@ int usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,
 		io-&gt;urbs[0]-&gt;num_sgs = io-&gt;entries;
 		io-&gt;entries = 1;
 	} else {
+		urb_flags |= URB_NO_INTERRUPT;
 		for_each_sg(sg, sg, io-&gt;entries, i) {
 			unsigned len;
 </pre><hr><pre>commit 253e05724f9230910344357b1142ad8642ff9f5a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 27 15:20:13 2009 -0400

    USB: add a "remove hardware" sysfs attribute
    
    This patch (as1297) adds a "remove" attribute to each USB device's
    directory in sysfs.  Writing to this attribute causes the device to be
    deconfigured (the same as writing 0 to the "bConfigurationValue"
    attribute) and then tells the hub driver to disable the device's
    upstream port.  The device remains locked during these activities so
    there is no possibility of it getting reconfigured in between.  The
    port will remain disabled until after the device is unplugged.
    
    The purpose of this is to provide a means for user programs to imitate
    the "Safely remove hardware" applet in Windows.  Some devices do
    expect their ports to be disabled before they are unplugged, and they
    provide visual feedback to users indicating when they can safely be
    unplugged.
    
    The security implications are minimal.  Writing to the "remove"
    attribute is no more dangerous than writing to the
    "bConfigurationValue" attribute.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Zeuthen &lt;davidz@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 708c63826100..5413d712cae0 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -60,6 +60,8 @@ struct usb_hub {
 							status change */
 	unsigned long		busy_bits[1];	/* ports being reset or
 							resumed */
+	unsigned long		removed_bits[1]; /* ports with a "removed"
+							device present */
 #if USB_MAXCHILDREN &gt; 31 /* 8*sizeof(unsigned long) - 1 */
 #error event_bits[] is too short!
 #endif
@@ -635,6 +637,33 @@ static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
  	kick_khubd(hub);
 }
 
+/**
+ * usb_remove_device - disable a device's port on its parent hub
+ * @udev: device to be disabled and removed
+ * Context: @udev locked, must be able to sleep.
+ *
+ * After @udev's port has been disabled, khubd is notified and it will
+ * see that the device has been disconnected.  When the device is
+ * physically unplugged and something is plugged in, the events will
+ * be received and processed normally.
+ */
+int usb_remove_device(struct usb_device *udev)
+{
+	struct usb_hub *hub;
+	struct usb_interface *intf;
+
+	if (!udev-&gt;parent)	/* Can't remove a root hub */
+		return -EINVAL;
+	hub = hdev_to_hub(udev-&gt;parent);
+	intf = to_usb_interface(hub-&gt;intfdev);
+
+	usb_autopm_get_interface(intf);
+	set_bit(udev-&gt;portnum, hub-&gt;removed_bits);
+	hub_port_logical_disconnect(hub, udev-&gt;portnum);
+	usb_autopm_put_interface(intf);
+	return 0;
+}
+
 enum hub_activation_type {
 	HUB_INIT, HUB_INIT2, HUB_INIT3,
 	HUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,
@@ -730,6 +759,13 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 					USB_PORT_FEAT_C_ENABLE);
 		}
 
+		/* We can forget about a "removed" device when there's a
+		 * physical disconnect or the connect status changes.
+		 */
+		if (!(portstatus &amp; USB_PORT_STAT_CONNECTION) ||
+				(portchange &amp; USB_PORT_STAT_C_CONNECTION))
+			clear_bit(port1, hub-&gt;removed_bits);
+
 		if (!udev || udev-&gt;state == USB_STATE_NOTATTACHED) {
 			/* Tell khubd to disconnect the device or
 			 * check for a new connection
@@ -2965,6 +3001,13 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		usb_disconnect(&amp;hdev-&gt;children[port1-1]);
 	clear_bit(port1, hub-&gt;change_bits);
 
+	/* We can forget about a "removed" device when there's a physical
+	 * disconnect or the connect status changes.
+	 */
+	if (!(portstatus &amp; USB_PORT_STAT_CONNECTION) ||
+			(portchange &amp; USB_PORT_STAT_C_CONNECTION))
+		clear_bit(port1, hub-&gt;removed_bits);
+
 	if (portchange &amp; (USB_PORT_STAT_C_CONNECTION |
 				USB_PORT_STAT_C_ENABLE)) {
 		status = hub_port_debounce(hub, port1);
@@ -2978,8 +3021,11 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		}
 	}
 
-	/* Return now if debouncing failed or nothing is connected */
-	if (!(portstatus &amp; USB_PORT_STAT_CONNECTION)) {
+	/* Return now if debouncing failed or nothing is connected or
+	 * the device was "removed".
+	 */
+	if (!(portstatus &amp; USB_PORT_STAT_CONNECTION) ||
+			test_bit(port1, hub-&gt;removed_bits)) {
 
 		/* maybe switch power back on (e.g. root hub was reset) */
 		if ((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 7ec3041ae79e..470e2413a9cf 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -508,6 +508,28 @@ static ssize_t usb_dev_authorized_store(struct device *dev,
 static DEVICE_ATTR(authorized, 0644,
 	    usb_dev_authorized_show, usb_dev_authorized_store);
 
+/* "Safely remove a device" */
+static ssize_t usb_remove_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct usb_device *udev = to_usb_device(dev);
+	int rc = 0;
+
+	usb_lock_device(udev);
+	if (udev-&gt;state != USB_STATE_NOTATTACHED) {
+
+		/* To avoid races, first unconfigure and then remove */
+		usb_set_configuration(udev, -1);
+		rc = usb_remove_device(udev);
+	}
+	if (rc == 0)
+		rc = count;
+	usb_unlock_device(udev);
+	return rc;
+}
+static DEVICE_ATTR(remove, 0200, NULL, usb_remove_store);
+
 
 static struct attribute *dev_attrs[] = {
 	/* current configuration's attributes */
@@ -533,6 +555,7 @@ static struct attribute *dev_attrs[] = {
 	&amp;dev_attr_maxchild.attr,
 	&amp;dev_attr_quirks.attr,
 	&amp;dev_attr_authorized.attr,
+	&amp;dev_attr_remove.attr,
 	NULL,
 };
 static struct attribute_group dev_attr_grp = {
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 9a8b15e6377a..4c36c7f512a0 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -24,6 +24,7 @@ extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
 extern int usb_deauthorize_device(struct usb_device *);
 extern int usb_authorize_device(struct usb_device *);
 extern void usb_detect_quirks(struct usb_device *udev);
+extern int usb_remove_device(struct usb_device *udev);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);</pre>
    <div class="pagination">
        <a href='2_71.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><span>[72]</span><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_73.html'>Next&gt;&gt;</a>
    <div>
</body>
