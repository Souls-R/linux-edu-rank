<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Warsaw University of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Warsaw University of Technology</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit c396b9a03e3bb5e95e036bdb0c7d614e0e1a4e3d
Author: Patryk Kocielnik &lt;pkocieln@mion.elka.pw.edu.pl&gt;
Date:   Fri Jan 26 21:19:26 2018 +0100

    i2c: busses: i2c-sirf: Fix spelling: "formular" -&gt; "formula".
    
    Fix spelling.
    
    Signed-off-by: Patryk Kocielnik &lt;patryk.kocielnik@gmail.com&gt;
    [wsa: fixed "Initialization", too]
    Signed-off-by: Wolfram Sang &lt;wsa@the-dreams.de&gt;

diff --git a/drivers/i2c/busses/i2c-sirf.c b/drivers/i2c/busses/i2c-sirf.c
index 2fd8b6d00391..87197ece0f90 100644
--- a/drivers/i2c/busses/i2c-sirf.c
+++ b/drivers/i2c/busses/i2c-sirf.c
@@ -341,7 +341,7 @@ static int i2c_sirfsoc_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, adap);
 	init_completion(&amp;siic-&gt;done);
 
-	/* Controller Initalisation */
+	/* Controller initialisation */
 
 	writel(SIRFSOC_I2C_RESET, siic-&gt;base + SIRFSOC_I2C_CTRL);
 	while (readl(siic-&gt;base + SIRFSOC_I2C_CTRL) &amp; SIRFSOC_I2C_RESET)
@@ -369,7 +369,7 @@ static int i2c_sirfsoc_probe(struct platform_device *pdev)
 	 * but they start to affect the speed when clock is set to faster
 	 * frequencies.
 	 * Through the actual tests, use the different user_div value(which
-	 * in the divider formular 'Fio / (Fi2c * user_div)') to adapt
+	 * in the divider formula 'Fio / (Fi2c * user_div)') to adapt
 	 * the different ranges of i2c bus clock frequency, to make the SCL
 	 * more accurate.
 	 */</pre><hr><pre>commit cd36beec0b83d28dceb85696a23542bf1b97cc8c
Author: Bartlomiej Zolnierkiewicz &lt;B.Zolnierkiewicz@elka.pw.edu.pl&gt;
Date:   Fri Jan 5 16:36:21 2007 -0800

    [PATCH] via82cxxx: fix cable detection
    
    This patch fixes 2.6.15 regression, is straightforward and tested.
    
    Cable detection got broken probably while converting the driver to support
    multiple controllers.  Cable detection is done by examining how BIOS
    configured the attached devices.  The current code is broken in that it
    examines the status *after* modifying Clk66 configuration ending up
    detecting 40c cables as 80c.  This patch fixes it.
    
    Signed-off-by: Tejun Heo &lt;htejun@gmail.com&gt;
    Signed-off-by: Bartlomiej Zolnierkiewicz &lt;bzolnier@gmail.com&gt;
    Cc: Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/ide/pci/via82cxxx.c b/drivers/ide/pci/via82cxxx.c
index 61f1a9665a7f..381cc6f101ce 100644
--- a/drivers/ide/pci/via82cxxx.c
+++ b/drivers/ide/pci/via82cxxx.c
@@ -123,7 +123,7 @@ struct via82cxxx_dev
 static void via_set_speed(ide_hwif_t *hwif, u8 dn, struct ide_timing *timing)
 {
 	struct pci_dev *dev = hwif-&gt;pci_dev;
-	struct via82cxxx_dev *vdev = ide_get_hwifdata(hwif);
+	struct via82cxxx_dev *vdev = pci_get_drvdata(hwif-&gt;pci_dev);
 	u8 t;
 
 	if (~vdev-&gt;via_config-&gt;flags &amp; VIA_BAD_AST) {
@@ -162,7 +162,7 @@ static void via_set_speed(ide_hwif_t *hwif, u8 dn, struct ide_timing *timing)
 static int via_set_drive(ide_drive_t *drive, u8 speed)
 {
 	ide_drive_t *peer = HWIF(drive)-&gt;drives + (~drive-&gt;dn &amp; 1);
-	struct via82cxxx_dev *vdev = ide_get_hwifdata(drive-&gt;hwif);
+	struct via82cxxx_dev *vdev = pci_get_drvdata(drive-&gt;hwif-&gt;pci_dev);
 	struct ide_timing t, p;
 	unsigned int T, UT;
 
@@ -225,7 +225,7 @@ static void via82cxxx_tune_drive(ide_drive_t *drive, u8 pio)
 static int via82cxxx_ide_dma_check (ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
-	struct via82cxxx_dev *vdev = ide_get_hwifdata(hwif);
+	struct via82cxxx_dev *vdev = pci_get_drvdata(hwif-&gt;pci_dev);
 	u16 w80 = hwif-&gt;udma_four;
 
 	u16 speed = ide_find_best_mode(drive,
@@ -262,6 +262,53 @@ static struct via_isa_bridge *via_config_find(struct pci_dev **isa)
 	return via_config;
 }
 
+/*
+ * Check and handle 80-wire cable presence
+ */
+static void __devinit via_cable_detect(struct via82cxxx_dev *vdev, u32 u)
+{
+	int i;
+
+	switch (vdev-&gt;via_config-&gt;flags &amp; VIA_UDMA) {
+		case VIA_UDMA_66:
+			for (i = 24; i &gt;= 0; i -= 8)
+				if (((u &gt;&gt; (i &amp; 16)) &amp; 8) &amp;&amp;
+				    ((u &gt;&gt; i) &amp; 0x20) &amp;&amp;
+				     (((u &gt;&gt; i) &amp; 7) &lt; 2)) {
+					/*
+					 * 2x PCI clock and
+					 * UDMA w/ &lt; 3T/cycle
+					 */
+					vdev-&gt;via_80w |= (1 &lt;&lt; (1 - (i &gt;&gt; 4)));
+				}
+			break;
+
+		case VIA_UDMA_100:
+			for (i = 24; i &gt;= 0; i -= 8)
+				if (((u &gt;&gt; i) &amp; 0x10) ||
+				    (((u &gt;&gt; i) &amp; 0x20) &amp;&amp;
+				     (((u &gt;&gt; i) &amp; 7) &lt; 4))) {
+					/* BIOS 80-wire bit or
+					 * UDMA w/ &lt; 60ns/cycle
+					 */
+					vdev-&gt;via_80w |= (1 &lt;&lt; (1 - (i &gt;&gt; 4)));
+				}
+			break;
+
+		case VIA_UDMA_133:
+			for (i = 24; i &gt;= 0; i -= 8)
+				if (((u &gt;&gt; i) &amp; 0x10) ||
+				    (((u &gt;&gt; i) &amp; 0x20) &amp;&amp;
+				     (((u &gt;&gt; i) &amp; 7) &lt; 6))) {
+					/* BIOS 80-wire bit or
+					 * UDMA w/ &lt; 60ns/cycle
+					 */
+					vdev-&gt;via_80w |= (1 &lt;&lt; (1 - (i &gt;&gt; 4)));
+				}
+			break;
+	}
+}
+
 /**
  *	init_chipset_via82cxxx	-	initialization handler
  *	@dev: PCI device
@@ -274,14 +321,22 @@ static struct via_isa_bridge *via_config_find(struct pci_dev **isa)
 static unsigned int __devinit init_chipset_via82cxxx(struct pci_dev *dev, const char *name)
 {
 	struct pci_dev *isa = NULL;
+	struct via82cxxx_dev *vdev;
 	struct via_isa_bridge *via_config;
 	u8 t, v;
-	unsigned int u;
+	u32 u;
+
+	vdev = kzalloc(sizeof(*vdev), GFP_KERNEL);
+	if (!vdev) {
+		printk(KERN_ERR "VP_IDE: out of memory :(\n");
+		return -ENOMEM;
+	}
+	pci_set_drvdata(dev, vdev);
 
 	/*
 	 * Find the ISA bridge to see how good the IDE is.
 	 */
-	via_config = via_config_find(&amp;isa);
+	vdev-&gt;via_config = via_config = via_config_find(&amp;isa);
 
 	/* We checked this earlier so if it fails here deeep badness
 	   is involved */
@@ -289,16 +344,17 @@ static unsigned int __devinit init_chipset_via82cxxx(struct pci_dev *dev, const
 	BUG_ON(!via_config-&gt;id);
 
 	/*
-	 * Setup or disable Clk66 if appropriate
+	 * Detect cable and configure Clk66
 	 */
+	pci_read_config_dword(dev, VIA_UDMA_TIMING, &amp;u);
+
+	via_cable_detect(vdev, u);
 
 	if ((via_config-&gt;flags &amp; VIA_UDMA) == VIA_UDMA_66) {
 		/* Enable Clk66 */
-		pci_read_config_dword(dev, VIA_UDMA_TIMING, &amp;u);
 		pci_write_config_dword(dev, VIA_UDMA_TIMING, u|0x80008);
 	} else if (via_config-&gt;flags &amp; VIA_BAD_CLK66) {
 		/* Would cause trouble on 596a and 686 */
-		pci_read_config_dword(dev, VIA_UDMA_TIMING, &amp;u);
 		pci_write_config_dword(dev, VIA_UDMA_TIMING, u &amp; ~0x80008);
 	}
 
@@ -367,75 +423,11 @@ static unsigned int __devinit init_chipset_via82cxxx(struct pci_dev *dev, const
 	return 0;
 }
 
-/*
- * Check and handle 80-wire cable presence
- */
-static void __devinit via_cable_detect(struct pci_dev *dev, struct via82cxxx_dev *vdev)
-{
-	unsigned int u;
-	int i;
-	pci_read_config_dword(dev, VIA_UDMA_TIMING, &amp;u);
-
-	switch (vdev-&gt;via_config-&gt;flags &amp; VIA_UDMA) {
-
-		case VIA_UDMA_66:
-			for (i = 24; i &gt;= 0; i -= 8)
-				if (((u &gt;&gt; (i &amp; 16)) &amp; 8) &amp;&amp;
-				    ((u &gt;&gt; i) &amp; 0x20) &amp;&amp;
-				     (((u &gt;&gt; i) &amp; 7) &lt; 2)) {
-					/*
-					 * 2x PCI clock and
-					 * UDMA w/ &lt; 3T/cycle
-					 */
-					vdev-&gt;via_80w |= (1 &lt;&lt; (1 - (i &gt;&gt; 4)));
-				}
-			break;
-
-		case VIA_UDMA_100:
-			for (i = 24; i &gt;= 0; i -= 8)
-				if (((u &gt;&gt; i) &amp; 0x10) ||
-				    (((u &gt;&gt; i) &amp; 0x20) &amp;&amp;
-				     (((u &gt;&gt; i) &amp; 7) &lt; 4))) {
-					/* BIOS 80-wire bit or
-					 * UDMA w/ &lt; 60ns/cycle
-					 */
-					vdev-&gt;via_80w |= (1 &lt;&lt; (1 - (i &gt;&gt; 4)));
-				}
-			break;
-
-		case VIA_UDMA_133:
-			for (i = 24; i &gt;= 0; i -= 8)
-				if (((u &gt;&gt; i) &amp; 0x10) ||
-				    (((u &gt;&gt; i) &amp; 0x20) &amp;&amp;
-				     (((u &gt;&gt; i) &amp; 7) &lt; 6))) {
-					/* BIOS 80-wire bit or
-					 * UDMA w/ &lt; 60ns/cycle
-					 */
-					vdev-&gt;via_80w |= (1 &lt;&lt; (1 - (i &gt;&gt; 4)));
-				}
-			break;
-
-	}
-}
-
 static void __devinit init_hwif_via82cxxx(ide_hwif_t *hwif)
 {
-	struct via82cxxx_dev *vdev = kmalloc(sizeof(struct via82cxxx_dev),
-		GFP_KERNEL);
-	struct pci_dev *isa = NULL;
+	struct via82cxxx_dev *vdev = pci_get_drvdata(hwif-&gt;pci_dev);
 	int i;
 
-	if (vdev == NULL) {
-		printk(KERN_ERR "VP_IDE: out of memory :(\n");
-		return;
-	}
-
-	memset(vdev, 0, sizeof(struct via82cxxx_dev));
-	ide_set_hwifdata(hwif, vdev);
-
-	vdev-&gt;via_config = via_config_find(&amp;isa);
-	via_cable_detect(hwif-&gt;pci_dev, vdev);
-
 	hwif-&gt;autodma = 0;
 
 	hwif-&gt;tuneproc = &amp;via82cxxx_tune_drive;</pre><hr><pre>commit 85edae14e4ee5e68cf037e9e4bca7498ea16874d
Author: Michal Janusz Miroslaw &lt;M.Miroslaw@elka.pw.edu.pl&gt;
Date:   Thu Feb 23 09:49:35 2006 +0000

    [SERIAL] Trivial comment fix: include/linux/serial_reg.h
    
    Trivial comment fix for include/linux/serial_reg.h
    
    Signed-off-by: Russell King &lt;rmk+kernel@arm.linux.org.uk&gt;

diff --git a/include/linux/serial_reg.h b/include/linux/serial_reg.h
index 6a2bb955844b..3c8a6aa77415 100644
--- a/include/linux/serial_reg.h
+++ b/include/linux/serial_reg.h
@@ -247,10 +247,10 @@
 #define UART_CTR	0xFF
 
 /*
- * The 16C950 Additional Control Reigster
+ * The 16C950 Additional Control Register
  */
 #define UART_ACR_RXDIS	0x01	/* Receiver disable */
-#define UART_ACR_TXDIS	0x02	/* Receiver disable */
+#define UART_ACR_TXDIS	0x02	/* Transmitter disable */
 #define UART_ACR_DSRFC	0x04	/* DSR Flow Control */
 #define UART_ACR_TLENB	0x20	/* 950 trigger levels enable */
 #define UART_ACR_ICRRD	0x40	/* ICR Read enable */</pre><hr><pre>commit 1694899fd1af43636351aac97f415fd3c9cefb1d
Author: Dariusz M &lt;D.Marcinkiewicz@elka.pw.edu.pl&gt;
Date:   Thu Jul 28 18:06:13 2005 +0200

    [PATCH] USB: pl2303 driver, makes pl2303HX chip work correctly
    
    This trivial patch makes pl2303 driver work correctly with pl2303HX chip.
    Apparently some bug in HX version of pl2303 makes the chip loose some
    transmitted bytes or stop working at all after reception of
    USB_REQ_CLEAR_FEATURE mesage. Logs generated by UsbSnoop application reveal
    that windows driver does not send this type of messages to the converter.
    
    From: "Dariusz M." &lt;D.Marcinkiewicz@elka.pw.edu.pl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c
index 7eab5d4cf3a8..461474176cfb 100644
--- a/drivers/usb/serial/pl2303.c
+++ b/drivers/usb/serial/pl2303.c
@@ -538,8 +538,10 @@ static int pl2303_open (struct usb_serial_port *port, struct file *filp)
 
 	dbg("%s -  port %d", __FUNCTION__, port-&gt;number);
 
-	usb_clear_halt(serial-&gt;dev, port-&gt;write_urb-&gt;pipe);
-	usb_clear_halt(serial-&gt;dev, port-&gt;read_urb-&gt;pipe);
+	if (priv-&gt;type != HX) {
+		usb_clear_halt(serial-&gt;dev, port-&gt;write_urb-&gt;pipe);
+		usb_clear_halt(serial-&gt;dev, port-&gt;read_urb-&gt;pipe);
+	}
 
 	buf = kmalloc(10, GFP_KERNEL);
 	if (buf==NULL)</pre><hr><pre>commit c40d3d38a8f04fff4394c7323db239bce780db60
Author: Bartlomiej Zolnierkiewicz &lt;bzolnier@elka.pw.edu.pl&gt;
Date:   Thu Aug 18 22:09:21 2005 +0200

    [PATCH] ide-floppy: fix IDEFLOPPY_TICKS_DELAY
    
    * IDEFLOPPY_TICKS_DELAY assumed HZ == 100, fix it
    * increase the delay to 50ms (to match comment in the code)
    
    Thanks to Manfred Scherer &lt;manfred.scherer.mhm@t-online.de&gt;
    for reporting the problem and testing the patch.
    
    Signed-off-by: Bartlomiej Zolnierkiewicz &lt;bzolnier@elka.pw.edu.pl&gt;

diff --git a/drivers/ide/ide-floppy.c b/drivers/ide/ide-floppy.c
index 9eab6426148e..29c22fc278c6 100644
--- a/drivers/ide/ide-floppy.c
+++ b/drivers/ide/ide-floppy.c
@@ -317,7 +317,7 @@ typedef struct ide_floppy_obj {
 	unsigned long flags;
 } idefloppy_floppy_t;
 
-#define IDEFLOPPY_TICKS_DELAY	3	/* default delay for ZIP 100 */
+#define IDEFLOPPY_TICKS_DELAY	HZ/20	/* default delay for ZIP 100 (50ms) */
 
 /*
  *	Floppy flag bits values.</pre><hr><pre>commit 8604affde9d4f52f04342d6a37c77d95fa167e7a
Author: Bartlomiej Zolnierkiewicz &lt;bzolnier@elka.pw.edu.pl&gt;
Date:   Thu May 26 14:55:34 2005 +0200

    [PATCH] convert IDE device drivers to driver-model
    
    * add ide_bus_match() and export ide_bus_type
    * split ide_remove_driver_from_hwgroup() out of ide_unregister()
    * move device cleanup from ide_unregister() to drive_release_dev()
    * convert ide_driver_t-&gt;name to driver-&gt;name
    * convert ide_driver_t-&gt;{attach,cleanup} to driver-&gt;{probe,remove}
    * remove ide_driver_t-&gt;busy as ide_bus_type-&gt;subsys.rwsem
      protects against concurrent -&gt;{probe,remove} calls
    * make ide_{un}register_driver() void as it cannot fail now
    * use driver_{un}register() directly, remove ide_{un}register_driver()
    * use device_register() instead of ata_attach(), remove ata_attach()
    * add proc_print_driver() and ide_drivers_show(), remove ide_drivers_op
    * fix ide_replace_subdriver() and move it to ide-proc.c
    * remove ide_driver_t-&gt;drives, ide_drives and drives_lock
    * remove ide_driver_t-&gt;drivers, drivers and drivers_lock
    * remove ide_drive_t-&gt;driver and DRIVER() macro
    
    Signed-off-by: Bartlomiej Zolnierkiewicz &lt;bzolnier@elka.pw.edu.pl&gt;

diff --git a/drivers/ide/ide-cd.c b/drivers/ide/ide-cd.c
index 4f7ce7056228..f0bd242e030f 100644
--- a/drivers/ide/ide-cd.c
+++ b/drivers/ide/ide-cd.c
@@ -3255,16 +3255,12 @@ sector_t ide_cdrom_capacity (ide_drive_t *drive)
 	return capacity * sectors_per_frame;
 }
 
-static
-int ide_cdrom_cleanup(ide_drive_t *drive)
+static int ide_cd_remove(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	struct cdrom_info *info = drive-&gt;driver_data;
 
-	if (ide_unregister_subdriver(drive)) {
-		printk(KERN_ERR "%s: %s: failed to ide_unregister_subdriver\n",
-			__FUNCTION__, drive-&gt;name);
-		return 1;
-	}
+	ide_unregister_subdriver(drive, info-&gt;driver);
 
 	del_gendisk(info-&gt;disk);
 
@@ -3297,7 +3293,7 @@ static void ide_cd_release(struct kref *kref)
 	kfree(info);
 }
 
-static int ide_cdrom_attach (ide_drive_t *drive);
+static int ide_cd_probe(struct device *);
 
 #ifdef CONFIG_PROC_FS
 static int proc_idecd_read_capacity
@@ -3320,19 +3316,20 @@ static ide_proc_entry_t idecd_proc[] = {
 
 static ide_driver_t ide_cdrom_driver = {
 	.owner			= THIS_MODULE,
-	.name			= "ide-cdrom",
+	.gen_driver = {
+		.name		= "ide-cdrom",
+		.bus		= &amp;ide_bus_type,
+		.probe		= ide_cd_probe,
+		.remove		= ide_cd_remove,
+	},
 	.version		= IDECD_VERSION,
 	.media			= ide_cdrom,
-	.busy			= 0,
 	.supports_dsc_overlap	= 1,
-	.cleanup		= ide_cdrom_cleanup,
 	.do_request		= ide_do_rw_cdrom,
 	.end_request		= ide_end_request,
 	.error			= __ide_error,
 	.abort			= __ide_abort,
 	.proc			= idecd_proc,
-	.attach			= ide_cdrom_attach,
-	.drives			= LIST_HEAD_INIT(ide_cdrom_driver.drives),
 };
 
 static int idecd_open(struct inode * inode, struct file * file)
@@ -3418,8 +3415,9 @@ static char *ignore = NULL;
 module_param(ignore, charp, 0400);
 MODULE_DESCRIPTION("ATAPI CD-ROM Driver");
 
-static int ide_cdrom_attach (ide_drive_t *drive)
+static int ide_cd_probe(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	struct cdrom_info *info;
 	struct gendisk *g;
 	struct request_sense sense;
@@ -3453,11 +3451,8 @@ static int ide_cdrom_attach (ide_drive_t *drive)
 
 	ide_init_disk(g, drive);
 
-	if (ide_register_subdriver(drive, &amp;ide_cdrom_driver)) {
-		printk(KERN_ERR "%s: Failed to register the driver with ide.c\n",
-			drive-&gt;name);
-		goto out_put_disk;
-	}
+	ide_register_subdriver(drive, &amp;ide_cdrom_driver);
+
 	memset(info, 0, sizeof (struct cdrom_info));
 
 	kref_init(&amp;info-&gt;kref);
@@ -3470,7 +3465,6 @@ static int ide_cdrom_attach (ide_drive_t *drive)
 
 	drive-&gt;driver_data = info;
 
-	DRIVER(drive)-&gt;busy++;
 	g-&gt;minors = 1;
 	snprintf(g-&gt;devfs_name, sizeof(g-&gt;devfs_name),
 			"%s/cd", drive-&gt;devfs_name);
@@ -3478,8 +3472,7 @@ static int ide_cdrom_attach (ide_drive_t *drive)
 	g-&gt;flags = GENHD_FL_CD | GENHD_FL_REMOVABLE;
 	if (ide_cdrom_setup(drive)) {
 		struct cdrom_device_info *devinfo = &amp;info-&gt;devinfo;
-		DRIVER(drive)-&gt;busy--;
-		ide_unregister_subdriver(drive);
+		ide_unregister_subdriver(drive, &amp;ide_cdrom_driver);
 		if (info-&gt;buffer != NULL)
 			kfree(info-&gt;buffer);
 		if (info-&gt;toc != NULL)
@@ -3492,7 +3485,6 @@ static int ide_cdrom_attach (ide_drive_t *drive)
 		drive-&gt;driver_data = NULL;
 		goto failed;
 	}
-	DRIVER(drive)-&gt;busy--;
 
 	cdrom_read_toc(drive, &amp;sense);
 	g-&gt;fops = &amp;idecd_ops;
@@ -3500,23 +3492,20 @@ static int ide_cdrom_attach (ide_drive_t *drive)
 	add_disk(g);
 	return 0;
 
-out_put_disk:
-	put_disk(g);
 out_free_cd:
 	kfree(info);
 failed:
-	return 1;
+	return -ENODEV;
 }
 
 static void __exit ide_cdrom_exit(void)
 {
-	ide_unregister_driver(&amp;ide_cdrom_driver);
+	driver_unregister(&amp;ide_cdrom_driver.gen_driver);
 }
  
 static int ide_cdrom_init(void)
 {
-	ide_register_driver(&amp;ide_cdrom_driver);
-	return 0;
+	return driver_register(&amp;ide_cdrom_driver.gen_driver);
 }
 
 module_init(ide_cdrom_init);
diff --git a/drivers/ide/ide-disk.c b/drivers/ide/ide-disk.c
index 5d54f7756100..3302cd8eab4c 100644
--- a/drivers/ide/ide-disk.c
+++ b/drivers/ide/ide-disk.c
@@ -1024,14 +1024,16 @@ static void ide_cacheflush_p(ide_drive_t *drive)
 		printk(KERN_INFO "%s: wcache flush failed!\n", drive-&gt;name);
 }
 
-static int idedisk_cleanup (ide_drive_t *drive)
+static int ide_disk_remove(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	struct ide_disk_obj *idkp = drive-&gt;driver_data;
 	struct gendisk *g = idkp-&gt;disk;
 
 	ide_cacheflush_p(drive);
-	if (ide_unregister_subdriver(drive))
-		return 1;
+
+	ide_unregister_subdriver(drive, idkp-&gt;driver);
+
 	del_gendisk(g);
 
 	ide_disk_put(idkp);
@@ -1052,7 +1054,7 @@ static void ide_disk_release(struct kref *kref)
 	kfree(idkp);
 }
 
-static int idedisk_attach(ide_drive_t *drive);
+static int ide_disk_probe(struct device *dev);
 
 static void ide_device_shutdown(struct device *dev)
 {
@@ -1082,27 +1084,23 @@ static void ide_device_shutdown(struct device *dev)
 	dev-&gt;bus-&gt;suspend(dev, PMSG_SUSPEND);
 }
 
-/*
- *      IDE subdriver functions, registered with ide.c
- */
 static ide_driver_t idedisk_driver = {
 	.owner			= THIS_MODULE,
 	.gen_driver = {
+		.name		= "ide-disk",
+		.bus		= &amp;ide_bus_type,
+		.probe		= ide_disk_probe,
+		.remove		= ide_disk_remove,
 		.shutdown	= ide_device_shutdown,
 	},
-	.name			= "ide-disk",
 	.version		= IDEDISK_VERSION,
 	.media			= ide_disk,
-	.busy			= 0,
 	.supports_dsc_overlap	= 0,
-	.cleanup		= idedisk_cleanup,
 	.do_request		= ide_do_rw_disk,
 	.end_request		= ide_end_request,
 	.error			= __ide_error,
 	.abort			= __ide_abort,
 	.proc			= idedisk_proc,
-	.attach			= idedisk_attach,
-	.drives			= LIST_HEAD_INIT(idedisk_driver.drives),
 };
 
 static int idedisk_open(struct inode *inode, struct file *filp)
@@ -1199,8 +1197,9 @@ static struct block_device_operations idedisk_ops = {
 
 MODULE_DESCRIPTION("ATA DISK Driver");
 
-static int idedisk_attach(ide_drive_t *drive)
+static int ide_disk_probe(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	struct ide_disk_obj *idkp;
 	struct gendisk *g;
 
@@ -1222,10 +1221,7 @@ static int idedisk_attach(ide_drive_t *drive)
 
 	ide_init_disk(g, drive);
 
-	if (ide_register_subdriver(drive, &amp;idedisk_driver)) {
-		printk (KERN_ERR "ide-disk: %s: Failed to register the driver with ide.c\n", drive-&gt;name);
-		goto out_put_disk;
-	}
+	ide_register_subdriver(drive, &amp;idedisk_driver);
 
 	memset(idkp, 0, sizeof(*idkp));
 
@@ -1239,7 +1235,6 @@ static int idedisk_attach(ide_drive_t *drive)
 
 	drive-&gt;driver_data = idkp;
 
-	DRIVER(drive)-&gt;busy++;
 	idedisk_setup(drive);
 	if ((!drive-&gt;head || drive-&gt;head &gt; 16) &amp;&amp; !drive-&gt;select.b.lba) {
 		printk(KERN_ERR "%s: INVALID GEOMETRY: %d PHYSICAL HEADS?\n",
@@ -1247,7 +1242,7 @@ static int idedisk_attach(ide_drive_t *drive)
 		drive-&gt;attach = 0;
 	} else
 		drive-&gt;attach = 1;
-	DRIVER(drive)-&gt;busy--;
+
 	g-&gt;minors = 1 &lt;&lt; PARTN_BITS;
 	strcpy(g-&gt;devfs_name, drive-&gt;devfs_name);
 	g-&gt;driverfs_dev = &amp;drive-&gt;gendev;
@@ -1257,22 +1252,20 @@ static int idedisk_attach(ide_drive_t *drive)
 	add_disk(g);
 	return 0;
 
-out_put_disk:
-	put_disk(g);
 out_free_idkp:
 	kfree(idkp);
 failed:
-	return 1;
+	return -ENODEV;
 }
 
 static void __exit idedisk_exit (void)
 {
-	ide_unregister_driver(&amp;idedisk_driver);
+	driver_unregister(&amp;idedisk_driver.gen_driver);
 }
 
 static int idedisk_init (void)
 {
-	return ide_register_driver(&amp;idedisk_driver);
+	return driver_register(&amp;idedisk_driver.gen_driver);
 }
 
 module_init(idedisk_init);
diff --git a/drivers/ide/ide-floppy.c b/drivers/ide/ide-floppy.c
index 36c0b74a4e45..c949e98df4b6 100644
--- a/drivers/ide/ide-floppy.c
+++ b/drivers/ide/ide-floppy.c
@@ -1865,13 +1865,13 @@ static void idefloppy_setup (ide_drive_t *drive, idefloppy_floppy_t *floppy)
 	idefloppy_add_settings(drive);
 }
 
-static int idefloppy_cleanup (ide_drive_t *drive)
+static int ide_floppy_remove(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	idefloppy_floppy_t *floppy = drive-&gt;driver_data;
 	struct gendisk *g = floppy-&gt;disk;
 
-	if (ide_unregister_subdriver(drive))
-		return 1;
+	ide_unregister_subdriver(drive, floppy-&gt;driver);
 
 	del_gendisk(g);
 
@@ -1916,26 +1916,24 @@ static ide_proc_entry_t idefloppy_proc[] = {
 
 #endif	/* CONFIG_PROC_FS */
 
-static int idefloppy_attach(ide_drive_t *drive);
+static int ide_floppy_probe(struct device *);
 
-/*
- *	IDE subdriver functions, registered with ide.c
- */
 static ide_driver_t idefloppy_driver = {
 	.owner			= THIS_MODULE,
-	.name			= "ide-floppy",
+	.gen_driver = {
+		.name		= "ide-floppy",
+		.bus		= &amp;ide_bus_type,
+		.probe		= ide_floppy_probe,
+		.remove		= ide_floppy_remove,
+	},
 	.version		= IDEFLOPPY_VERSION,
 	.media			= ide_floppy,
-	.busy			= 0,
 	.supports_dsc_overlap	= 0,
-	.cleanup		= idefloppy_cleanup,
 	.do_request		= idefloppy_do_request,
 	.end_request		= idefloppy_do_end_request,
 	.error			= __ide_error,
 	.abort			= __ide_abort,
 	.proc			= idefloppy_proc,
-	.attach			= idefloppy_attach,
-	.drives			= LIST_HEAD_INIT(idefloppy_driver.drives),
 };
 
 static int idefloppy_open(struct inode *inode, struct file *filp)
@@ -2122,8 +2120,9 @@ static struct block_device_operations idefloppy_ops = {
 	.revalidate_disk= idefloppy_revalidate_disk
 };
 
-static int idefloppy_attach (ide_drive_t *drive)
+static int ide_floppy_probe(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	idefloppy_floppy_t *floppy;
 	struct gendisk *g;
 
@@ -2152,10 +2151,7 @@ static int idefloppy_attach (ide_drive_t *drive)
 
 	ide_init_disk(g, drive);
 
-	if (ide_register_subdriver(drive, &amp;idefloppy_driver)) {
-		printk (KERN_ERR "ide-floppy: %s: Failed to register the driver with ide.c\n", drive-&gt;name);
-		goto out_put_disk;
-	}
+	ide_register_subdriver(drive, &amp;idefloppy_driver);
 
 	memset(floppy, 0, sizeof(*floppy));
 
@@ -2169,9 +2165,8 @@ static int idefloppy_attach (ide_drive_t *drive)
 
 	drive-&gt;driver_data = floppy;
 
-	DRIVER(drive)-&gt;busy++;
 	idefloppy_setup (drive, floppy);
-	DRIVER(drive)-&gt;busy--;
+
 	g-&gt;minors = 1 &lt;&lt; PARTN_BITS;
 	g-&gt;driverfs_dev = &amp;drive-&gt;gendev;
 	strcpy(g-&gt;devfs_name, drive-&gt;devfs_name);
@@ -2181,19 +2176,17 @@ static int idefloppy_attach (ide_drive_t *drive)
 	add_disk(g);
 	return 0;
 
-out_put_disk:
-	put_disk(g);
 out_free_floppy:
 	kfree(floppy);
 failed:
-	return 1;
+	return -ENODEV;
 }
 
 MODULE_DESCRIPTION("ATAPI FLOPPY Driver");
 
 static void __exit idefloppy_exit (void)
 {
-	ide_unregister_driver(&amp;idefloppy_driver);
+	driver_unregister(&amp;idefloppy_driver.gen_driver);
 }
 
 /*
@@ -2202,8 +2195,7 @@ static void __exit idefloppy_exit (void)
 static int idefloppy_init (void)
 {
 	printk("ide-floppy driver " IDEFLOPPY_VERSION "\n");
-	ide_register_driver(&amp;idefloppy_driver);
-	return 0;
+	return driver_register(&amp;idefloppy_driver.gen_driver);
 }
 
 module_init(idefloppy_init);
diff --git a/drivers/ide/ide-probe.c b/drivers/ide/ide-probe.c
index 554473a95cf7..53b84a84f6cb 100644
--- a/drivers/ide/ide-probe.c
+++ b/drivers/ide/ide-probe.c
@@ -47,6 +47,7 @@
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/ide.h&gt;
+#include &lt;linux/devfs_fs_kernel.h&gt;
 #include &lt;linux/spinlock.h&gt;
 #include &lt;linux/kmod.h&gt;
 #include &lt;linux/pci.h&gt;
@@ -918,7 +919,7 @@ int probe_hwif_init_with_fixup(ide_hwif_t *hwif, void (*fixup)(ide_hwif_t *hwif)
 			   want them on default or a new "empty" class
 			   for hotplug reprobing ? */
 			if (drive-&gt;present) {
-				ata_attach(drive);
+				device_register(&amp;drive-&gt;gendev);
 			}
 		}
 	}
@@ -1279,10 +1280,51 @@ void ide_init_disk(struct gendisk *disk, ide_drive_t *drive)
 
 EXPORT_SYMBOL_GPL(ide_init_disk);
 
+static void ide_remove_drive_from_hwgroup(ide_drive_t *drive)
+{
+	ide_hwgroup_t *hwgroup = drive-&gt;hwif-&gt;hwgroup;
+
+	if (drive == drive-&gt;next) {
+		/* special case: last drive from hwgroup. */
+		BUG_ON(hwgroup-&gt;drive != drive);
+		hwgroup-&gt;drive = NULL;
+	} else {
+		ide_drive_t *walk;
+
+		walk = hwgroup-&gt;drive;
+		while (walk-&gt;next != drive)
+			walk = walk-&gt;next;
+		walk-&gt;next = drive-&gt;next;
+		if (hwgroup-&gt;drive == drive) {
+			hwgroup-&gt;drive = drive-&gt;next;
+			hwgroup-&gt;hwif = hwgroup-&gt;drive-&gt;hwif;
+		}
+	}
+	BUG_ON(hwgroup-&gt;drive == drive);
+}
+
 static void drive_release_dev (struct device *dev)
 {
 	ide_drive_t *drive = container_of(dev, ide_drive_t, gendev);
 
+	spin_lock_irq(&amp;ide_lock);
+	if (drive-&gt;devfs_name[0] != '\0') {
+		devfs_remove(drive-&gt;devfs_name);
+		drive-&gt;devfs_name[0] = '\0';
+	}
+	ide_remove_drive_from_hwgroup(drive);
+	if (drive-&gt;id != NULL) {
+		kfree(drive-&gt;id);
+		drive-&gt;id = NULL;
+	}
+	drive-&gt;present = 0;
+	/* Messed up locking ... */
+	spin_unlock_irq(&amp;ide_lock);
+	blk_cleanup_queue(drive-&gt;queue);
+	spin_lock_irq(&amp;ide_lock);
+	drive-&gt;queue = NULL;
+	spin_unlock_irq(&amp;ide_lock);
+
 	up(&amp;drive-&gt;gendev_rel_sem);
 }
 
@@ -1306,7 +1348,6 @@ static void init_gendisk (ide_hwif_t *hwif)
 		drive-&gt;gendev.driver_data = drive;
 		drive-&gt;gendev.release = drive_release_dev;
 		if (drive-&gt;present) {
-			device_register(&amp;drive-&gt;gendev);
 			sprintf(drive-&gt;devfs_name, "ide/host%d/bus%d/target%d/lun%d",
 				(hwif-&gt;channel &amp;&amp; hwif-&gt;mate) ?
 				hwif-&gt;mate-&gt;index : hwif-&gt;index,
@@ -1412,7 +1453,7 @@ int ideprobe_init (void)
 				hwif-&gt;chipset = ide_generic;
 			for (unit = 0; unit &lt; MAX_DRIVES; ++unit)
 				if (hwif-&gt;drives[unit].present)
-					ata_attach(&amp;hwif-&gt;drives[unit]);
+					device_register(&amp;hwif-&gt;drives[unit].gendev);
 		}
 	}
 	return 0;
diff --git a/drivers/ide/ide-proc.c b/drivers/ide/ide-proc.c
index 4b1e43b4118b..4063d2c34e3d 100644
--- a/drivers/ide/ide-proc.c
+++ b/drivers/ide/ide-proc.c
@@ -307,17 +307,41 @@ static int proc_ide_read_driver
 	(char *page, char **start, off_t off, int count, int *eof, void *data)
 {
 	ide_drive_t	*drive = (ide_drive_t *) data;
-	ide_driver_t	*driver = drive-&gt;driver;
+	struct device	*dev = &amp;drive-&gt;gendev;
+	ide_driver_t	*ide_drv;
 	int		len;
 
-	if (driver) {
+	down_read(&amp;dev-&gt;bus-&gt;subsys.rwsem);
+	if (dev-&gt;driver) {
+		ide_drv = container_of(dev-&gt;driver, ide_driver_t, gen_driver);
 		len = sprintf(page, "%s version %s\n",
-				driver-&gt;name, driver-&gt;version);
+				dev-&gt;driver-&gt;name, ide_drv-&gt;version);
 	} else
 		len = sprintf(page, "ide-default version 0.9.newide\n");
+	up_read(&amp;dev-&gt;bus-&gt;subsys.rwsem);
 	PROC_IDE_READ_RETURN(page,start,off,count,eof,len);
 }
 
+static int ide_replace_subdriver(ide_drive_t *drive, const char *driver)
+{
+	struct device *dev = &amp;drive-&gt;gendev;
+	int ret = 1;
+
+	down_write(&amp;dev-&gt;bus-&gt;subsys.rwsem);
+	device_release_driver(dev);
+	/* FIXME: device can still be in use by previous driver */
+	strlcpy(drive-&gt;driver_req, driver, sizeof(drive-&gt;driver_req));
+	device_attach(dev);
+	drive-&gt;driver_req[0] = 0;
+	if (dev-&gt;driver == NULL)
+		device_attach(dev);
+	if (dev-&gt;driver &amp;&amp; !strcmp(dev-&gt;driver-&gt;name, driver))
+		ret = 0;
+	up_write(&amp;dev-&gt;bus-&gt;subsys.rwsem);
+
+	return ret;
+}
+
 static int proc_ide_write_driver
 	(struct file *file, const char __user *buffer, unsigned long count, void *data)
 {
@@ -488,16 +512,32 @@ void destroy_proc_ide_interface(ide_hwif_t *hwif)
 	}
 }
 
-extern struct seq_operations ide_drivers_op;
+static int proc_print_driver(struct device_driver *drv, void *data)
+{
+	ide_driver_t *ide_drv = container_of(drv, ide_driver_t, gen_driver);
+	struct seq_file *s = data;
+
+	seq_printf(s, "%s version %s\n", drv-&gt;name, ide_drv-&gt;version);
+
+	return 0;
+}
+
+static int ide_drivers_show(struct seq_file *s, void *p)
+{
+	bus_for_each_drv(&amp;ide_bus_type, NULL, s, proc_print_driver);
+	return 0;
+}
+
 static int ide_drivers_open(struct inode *inode, struct file *file)
 {
-	return seq_open(file, &amp;ide_drivers_op);
+	return single_open(file, &amp;ide_drivers_show, NULL);
 }
+
 static struct file_operations ide_drivers_operations = {
 	.open		= ide_drivers_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release,
+	.release	= single_release,
 };
 
 void proc_ide_create(void)
diff --git a/drivers/ide/ide-tape.c b/drivers/ide/ide-tape.c
index 482544854985..5a3dc46008e6 100644
--- a/drivers/ide/ide-tape.c
+++ b/drivers/ide/ide-tape.c
@@ -4681,21 +4681,12 @@ static void idetape_setup (ide_drive_t *drive, idetape_tape_t *tape, int minor)
 	idetape_add_settings(drive);
 }
 
-static int idetape_cleanup (ide_drive_t *drive)
+static int ide_tape_remove(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	idetape_tape_t *tape = drive-&gt;driver_data;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;ide_lock, flags);
-	if (test_bit(IDETAPE_BUSY, &amp;tape-&gt;flags) || drive-&gt;usage ||
-	    tape-&gt;first_stage != NULL || tape-&gt;merge_stage_size) {
-		spin_unlock_irqrestore(&amp;ide_lock, flags);
-		return 1;
-	}
 
-	spin_unlock_irqrestore(&amp;ide_lock, flags);
-	DRIVER(drive)-&gt;busy = 0;
-	(void) ide_unregister_subdriver(drive);
+	ide_unregister_subdriver(drive, tape-&gt;driver);
 
 	ide_unregister_region(tape-&gt;disk);
 
@@ -4710,6 +4701,8 @@ static void ide_tape_release(struct kref *kref)
 	ide_drive_t *drive = tape-&gt;drive;
 	struct gendisk *g = tape-&gt;disk;
 
+	BUG_ON(tape-&gt;first_stage != NULL || tape-&gt;merge_stage_size);
+
 	drive-&gt;dsc_overlap = 0;
 	drive-&gt;driver_data = NULL;
 	devfs_remove("%s/mt", drive-&gt;devfs_name);
@@ -4747,26 +4740,24 @@ static ide_proc_entry_t idetape_proc[] = {
 
 #endif
 
-static int idetape_attach(ide_drive_t *drive);
+static int ide_tape_probe(struct device *);
 
-/*
- *	IDE subdriver functions, registered with ide.c
- */
 static ide_driver_t idetape_driver = {
 	.owner			= THIS_MODULE,
-	.name			= "ide-tape",
+	.gen_driver = {
+		.name		= "ide-tape",
+		.bus		= &amp;ide_bus_type,
+		.probe		= ide_tape_probe,
+		.remove		= ide_tape_remove,
+	},
 	.version		= IDETAPE_VERSION,
 	.media			= ide_tape,
-	.busy			= 1,
 	.supports_dsc_overlap 	= 1,
-	.cleanup		= idetape_cleanup,
 	.do_request		= idetape_do_request,
 	.end_request		= idetape_end_request,
 	.error			= __ide_error,
 	.abort			= __ide_abort,
 	.proc			= idetape_proc,
-	.attach			= idetape_attach,
-	.drives			= LIST_HEAD_INIT(idetape_driver.drives),
 };
 
 /*
@@ -4829,8 +4820,9 @@ static struct block_device_operations idetape_block_ops = {
 	.ioctl		= idetape_ioctl,
 };
 
-static int idetape_attach (ide_drive_t *drive)
+static int ide_tape_probe(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	idetape_tape_t *tape;
 	struct gendisk *g;
 	int minor;
@@ -4865,10 +4857,7 @@ static int idetape_attach (ide_drive_t *drive)
 
 	ide_init_disk(g, drive);
 
-	if (ide_register_subdriver(drive, &amp;idetape_driver)) {
-		printk(KERN_ERR "ide-tape: %s: Failed to register the driver with ide.c\n", drive-&gt;name);
-		goto out_put_disk;
-	}
+	ide_register_subdriver(drive, &amp;idetape_driver);
 
 	memset(tape, 0, sizeof(*tape));
 
@@ -4902,12 +4891,11 @@ static int idetape_attach (ide_drive_t *drive)
 	ide_register_region(g);
 
 	return 0;
-out_put_disk:
-	put_disk(g);
+
 out_free_tape:
 	kfree(tape);
 failed:
-	return 1;
+	return -ENODEV;
 }
 
 MODULE_DESCRIPTION("ATAPI Streaming TAPE Driver");
@@ -4915,7 +4903,7 @@ MODULE_LICENSE("GPL");
 
 static void __exit idetape_exit (void)
 {
-	ide_unregister_driver(&amp;idetape_driver);
+	driver_unregister(&amp;idetape_driver.gen_driver);
 	unregister_chrdev(IDETAPE_MAJOR, "ht");
 }
 
@@ -4928,8 +4916,7 @@ static int idetape_init (void)
 		printk(KERN_ERR "ide-tape: Failed to register character device interface\n");
 		return -EBUSY;
 	}
-	ide_register_driver(&amp;idetape_driver);
-	return 0;
+	return driver_register(&amp;idetape_driver.gen_driver);
 }
 
 module_init(idetape_init);
diff --git a/drivers/ide/ide.c b/drivers/ide/ide.c
index 973dec799b5c..dae1bd5b8c3e 100644
--- a/drivers/ide/ide.c
+++ b/drivers/ide/ide.c
@@ -196,8 +196,6 @@ ide_hwif_t ide_hwifs[MAX_HWIFS];	/* master data repository */
 
 EXPORT_SYMBOL(ide_hwifs);
 
-static struct list_head ide_drives = LIST_HEAD_INIT(ide_drives);
-
 /*
  * Do not even *think* about calling this!
  */
@@ -358,54 +356,6 @@ static int ide_system_bus_speed(void)
 	return system_bus_speed;
 }
 
-/*
- *	drives_lock protects the list of drives, drivers_lock the
- *	list of drivers.  Currently nobody takes both at once.
- */
-
-static DEFINE_SPINLOCK(drives_lock);
-static DEFINE_SPINLOCK(drivers_lock);
-static LIST_HEAD(drivers);
-
-/* Iterator for the driver list. */
-
-static void *m_start(struct seq_file *m, loff_t *pos)
-{
-	struct list_head *p;
-	loff_t l = *pos;
-	spin_lock(&amp;drivers_lock);
-	list_for_each(p, &amp;drivers)
-		if (!l--)
-			return list_entry(p, ide_driver_t, drivers);
-	return NULL;
-}
-
-static void *m_next(struct seq_file *m, void *v, loff_t *pos)
-{
-	struct list_head *p = ((ide_driver_t *)v)-&gt;drivers.next;
-	(*pos)++;
-	return p==&amp;drivers ? NULL : list_entry(p, ide_driver_t, drivers);
-}
-
-static void m_stop(struct seq_file *m, void *v)
-{
-	spin_unlock(&amp;drivers_lock);
-}
-
-static int show_driver(struct seq_file *m, void *v)
-{
-	ide_driver_t *driver = v;
-	seq_printf(m, "%s version %s\n", driver-&gt;name, driver-&gt;version);
-	return 0;
-}
-
-struct seq_operations ide_drivers_op = {
-	.start	= m_start,
-	.next	= m_next,
-	.stop	= m_stop,
-	.show	= show_driver
-};
-
 #ifdef CONFIG_PROC_FS
 struct proc_dir_entry *proc_ide_root;
 #endif
@@ -630,7 +580,7 @@ void ide_unregister(unsigned int index)
 	ide_hwif_t *hwif, *g;
 	static ide_hwif_t tmp_hwif; /* protected by ide_cfg_sem */
 	ide_hwgroup_t *hwgroup;
-	int irq_count = 0, unit, i;
+	int irq_count = 0, unit;
 
 	BUG_ON(index &gt;= MAX_HWIFS);
 
@@ -643,23 +593,22 @@ void ide_unregister(unsigned int index)
 		goto abort;
 	for (unit = 0; unit &lt; MAX_DRIVES; ++unit) {
 		drive = &amp;hwif-&gt;drives[unit];
-		if (!drive-&gt;present)
+		if (!drive-&gt;present) {
+			if (drive-&gt;devfs_name[0] != '\0') {
+				devfs_remove(drive-&gt;devfs_name);
+				drive-&gt;devfs_name[0] = '\0';
+			}
 			continue;
-		if (drive-&gt;usage || DRIVER(drive)-&gt;busy)
-			goto abort;
-		drive-&gt;dead = 1;
+		}
+		spin_unlock_irq(&amp;ide_lock);
+		device_unregister(&amp;drive-&gt;gendev);
+		down(&amp;drive-&gt;gendev_rel_sem);
+		spin_lock_irq(&amp;ide_lock);
 	}
 	hwif-&gt;present = 0;
 
 	spin_unlock_irq(&amp;ide_lock);
 
-	for (unit = 0; unit &lt; MAX_DRIVES; ++unit) {
-		drive = &amp;hwif-&gt;drives[unit];
-		if (!drive-&gt;present)
-			continue;
-		DRIVER(drive)-&gt;cleanup(drive);
-	}
-
 	destroy_proc_ide_interface(hwif);
 
 	hwgroup = hwif-&gt;hwgroup;
@@ -687,44 +636,6 @@ void ide_unregister(unsigned int index)
 	 * Remove us from the hwgroup, and free
 	 * the hwgroup if we were the only member
 	 */
-	for (i = 0; i &lt; MAX_DRIVES; ++i) {
-		drive = &amp;hwif-&gt;drives[i];
-		if (drive-&gt;devfs_name[0] != '\0') {
-			devfs_remove(drive-&gt;devfs_name);
-			drive-&gt;devfs_name[0] = '\0';
-		}
-		if (!drive-&gt;present)
-			continue;
-		if (drive == drive-&gt;next) {
-			/* special case: last drive from hwgroup. */
-			BUG_ON(hwgroup-&gt;drive != drive);
-			hwgroup-&gt;drive = NULL;
-		} else {
-			ide_drive_t *walk;
-
-			walk = hwgroup-&gt;drive;
-			while (walk-&gt;next != drive)
-				walk = walk-&gt;next;
-			walk-&gt;next = drive-&gt;next;
-			if (hwgroup-&gt;drive == drive) {
-				hwgroup-&gt;drive = drive-&gt;next;
-				hwgroup-&gt;hwif = HWIF(hwgroup-&gt;drive);
-			}
-		}
-		BUG_ON(hwgroup-&gt;drive == drive);
-		if (drive-&gt;id != NULL) {
-			kfree(drive-&gt;id);
-			drive-&gt;id = NULL;
-		}
-		drive-&gt;present = 0;
-		/* Messed up locking ... */
-		spin_unlock_irq(&amp;ide_lock);
-		blk_cleanup_queue(drive-&gt;queue);
-		device_unregister(&amp;drive-&gt;gendev);
-		down(&amp;drive-&gt;gendev_rel_sem);
-		spin_lock_irq(&amp;ide_lock);
-		drive-&gt;queue = NULL;
-	}
 	if (hwif-&gt;next == hwif) {
 		BUG_ON(hwgroup-&gt;hwif != hwif);
 		kfree(hwgroup);
@@ -1304,73 +1215,6 @@ int system_bus_clock (void)
 
 EXPORT_SYMBOL(system_bus_clock);
 
-/*
- *	Locking is badly broken here - since way back.  That sucker is
- * root-only, but that's not an excuse...  The real question is what
- * exclusion rules do we want here.
- */
-int ide_replace_subdriver (ide_drive_t *drive, const char *driver)
-{
-	if (!drive-&gt;present || drive-&gt;usage || drive-&gt;dead)
-		goto abort;
-	if (DRIVER(drive)-&gt;cleanup(drive))
-		goto abort;
-	strlcpy(drive-&gt;driver_req, driver, sizeof(drive-&gt;driver_req));
-	if (ata_attach(drive)) {
-		spin_lock(&amp;drives_lock);
-		list_del_init(&amp;drive-&gt;list);
-		spin_unlock(&amp;drives_lock);
-		drive-&gt;driver_req[0] = 0;
-		ata_attach(drive);
-	} else {
-		drive-&gt;driver_req[0] = 0;
-	}
-	if (drive-&gt;driver &amp;&amp; !strcmp(drive-&gt;driver-&gt;name, driver))
-		return 0;
-abort:
-	return 1;
-}
-
-/**
- *	ata_attach		-	attach an ATA/ATAPI device
- *	@drive: drive to attach
- *
- *	Takes a drive that is as yet not assigned to any midlayer IDE
- *	driver (or is assigned to the default driver) and figures out
- *	which driver would like to own it. If nobody claims the drive
- *	then it is automatically attached to the default driver used for
- *	unclaimed objects.
- *
- *	A return of zero indicates attachment to a driver, of one
- *	attachment to the default driver.
- *
- *	Takes drivers_lock.
- */
-
-int ata_attach(ide_drive_t *drive)
-{
-	struct list_head *p;
-	spin_lock(&amp;drivers_lock);
-	list_for_each(p, &amp;drivers) {
-		ide_driver_t *driver = list_entry(p, ide_driver_t, drivers);
-		if (!try_module_get(driver-&gt;owner))
-			continue;
-		spin_unlock(&amp;drivers_lock);
-		if (driver-&gt;attach(drive) == 0) {
-			module_put(driver-&gt;owner);
-			drive-&gt;gendev.driver = &amp;driver-&gt;gen_driver;
-			return 0;
-		}
-		spin_lock(&amp;drivers_lock);
-		module_put(driver-&gt;owner);
-	}
-	drive-&gt;gendev.driver = NULL;
-	spin_unlock(&amp;drivers_lock);
-	if (ide_register_subdriver(drive, NULL))
-		panic("ide: default attach failed");
-	return 1;
-}
-
 static int generic_ide_suspend(struct device *dev, pm_message_t state)
 {
 	ide_drive_t *drive = dev-&gt;driver_data;
@@ -2013,27 +1857,11 @@ static void __init probe_for_hwifs (void)
 #endif
 }
 
-int ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
+void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;ide_lock, flags);
-	if (!drive-&gt;present || drive-&gt;driver != NULL ||
-	    drive-&gt;usage || drive-&gt;dead) {
-		spin_unlock_irqrestore(&amp;ide_lock, flags);
-		return 1;
-	}
-	drive-&gt;driver = driver;
-	spin_unlock_irqrestore(&amp;ide_lock, flags);
-	spin_lock(&amp;drives_lock);
-	list_add_tail(&amp;drive-&gt;list, driver ? &amp;driver-&gt;drives : &amp;ide_drives);
-	spin_unlock(&amp;drives_lock);
-//	printk(KERN_INFO "%s: attached %s driver.\n", drive-&gt;name, driver-&gt;name);
 #ifdef CONFIG_PROC_FS
-	if (driver)
-		ide_add_proc_entries(drive-&gt;proc, driver-&gt;proc, drive);
+	ide_add_proc_entries(drive-&gt;proc, driver-&gt;proc, drive);
 #endif
-	return 0;
 }
 
 EXPORT_SYMBOL(ide_register_subdriver);
@@ -2041,136 +1869,51 @@ EXPORT_SYMBOL(ide_register_subdriver);
 /**
  *	ide_unregister_subdriver	-	disconnect drive from driver
  *	@drive: drive to unplug
+ *	@driver: driver
  *
  *	Disconnect a drive from the driver it was attached to and then
  *	clean up the various proc files and other objects attached to it.
  *
- *	Takes ide_setting_sem, ide_lock and drives_lock.
+ *	Takes ide_setting_sem and ide_lock.
  *	Caller must hold none of the locks.
- *
- *	No locking versus subdriver unload because we are moving to the
- *	default driver anyway. Wants double checking.
  */
 
-int ide_unregister_subdriver (ide_drive_t *drive)
+void ide_unregister_subdriver(ide_drive_t *drive, ide_driver_t *driver)
 {
 	unsigned long flags;
 	
 	down(&amp;ide_setting_sem);
 	spin_lock_irqsave(&amp;ide_lock, flags);
-	if (drive-&gt;usage || drive-&gt;driver == NULL || DRIVER(drive)-&gt;busy) {
-		spin_unlock_irqrestore(&amp;ide_lock, flags);
-		up(&amp;ide_setting_sem);
-		return 1;
-	}
 #ifdef CONFIG_PROC_FS
-	ide_remove_proc_entries(drive-&gt;proc, DRIVER(drive)-&gt;proc);
+	ide_remove_proc_entries(drive-&gt;proc, driver-&gt;proc);
 #endif
 	auto_remove_settings(drive);
-	drive-&gt;driver = NULL;
 	spin_unlock_irqrestore(&amp;ide_lock, flags);
 	up(&amp;ide_setting_sem);
-	spin_lock(&amp;drives_lock);
-	list_del_init(&amp;drive-&gt;list);
-	spin_unlock(&amp;drives_lock);
-	/* drive will be added to &amp;ide_drives in ata_attach() */
-	return 0;
 }
 
 EXPORT_SYMBOL(ide_unregister_subdriver);
 
-static int ide_drive_remove(struct device * dev)
-{
-	ide_drive_t * drive = container_of(dev,ide_drive_t,gendev);
-	DRIVER(drive)-&gt;cleanup(drive);
-	return 0;
-}
-
-/**
- *	ide_register_driver	-	register IDE device driver
- *	@driver: the IDE device driver
- *
- *	Register a new device driver and then scan the devices
- *	on the IDE bus in case any should be attached to the
- *	driver we have just registered.  If so attach them.
- *
- *	Takes drivers_lock and drives_lock.
- */
-
-int ide_register_driver(ide_driver_t *driver)
-{
-	struct list_head list;
-	struct list_head *list_loop;
-	struct list_head *tmp_storage;
-
-	spin_lock(&amp;drivers_lock);
-	list_add(&amp;driver-&gt;drivers, &amp;drivers);
-	spin_unlock(&amp;drivers_lock);
-
-	INIT_LIST_HEAD(&amp;list);
-	spin_lock(&amp;drives_lock);
-	list_splice_init(&amp;ide_drives, &amp;list);
-	spin_unlock(&amp;drives_lock);
-
-	list_for_each_safe(list_loop, tmp_storage, &amp;list) {
-		ide_drive_t *drive = container_of(list_loop, ide_drive_t, list);
-		list_del_init(&amp;drive-&gt;list);
-		if (drive-&gt;present)
-			ata_attach(drive);
-	}
-	driver-&gt;gen_driver.name = (char *) driver-&gt;name;
-	driver-&gt;gen_driver.bus = &amp;ide_bus_type;
-	driver-&gt;gen_driver.remove = ide_drive_remove;
-	return driver_register(&amp;driver-&gt;gen_driver);
-}
-
-EXPORT_SYMBOL(ide_register_driver);
-
-/**
- *	ide_unregister_driver	-	unregister IDE device driver
- *	@driver: the IDE device driver
- *
- *	Called when a driver module is being unloaded. We reattach any
- *	devices to whatever driver claims them next (typically the default
- *	driver).
- *
- *	Takes drivers_lock and called functions will take ide_setting_sem.
- */
-
-void ide_unregister_driver(ide_driver_t *driver)
-{
-	ide_drive_t *drive;
-
-	spin_lock(&amp;drivers_lock);
-	list_del(&amp;driver-&gt;drivers);
-	spin_unlock(&amp;drivers_lock);
-
-	driver_unregister(&amp;driver-&gt;gen_driver);
-
-	while(!list_empty(&amp;driver-&gt;drives)) {
-		drive = list_entry(driver-&gt;drives.next, ide_drive_t, list);
-		if (driver-&gt;cleanup(drive)) {
-			printk(KERN_ERR "%s: cleanup_module() called while still busy\n", drive-&gt;name);
-			BUG();
-		}
-		ata_attach(drive);
-	}
-}
-
-EXPORT_SYMBOL(ide_unregister_driver);
-
 /*
  * Probe module
  */
 
 EXPORT_SYMBOL(ide_lock);
 
+static int ide_bus_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
 struct bus_type ide_bus_type = {
 	.name		= "ide",
+	.match		= ide_bus_match,
 	.suspend	= generic_ide_suspend,
 	.resume		= generic_ide_resume,
 };
 
+EXPORT_SYMBOL_GPL(ide_bus_type);
+
 /*
  * This is gets invoked once during initialization, to set *everything* up
  */
diff --git a/drivers/scsi/ide-scsi.c b/drivers/scsi/ide-scsi.c
index 2e2486b035dd..d80c4c9d5a63 100644
--- a/drivers/scsi/ide-scsi.c
+++ b/drivers/scsi/ide-scsi.c
@@ -713,7 +713,6 @@ static void idescsi_add_settings(ide_drive_t *drive)
  */
 static void idescsi_setup (ide_drive_t *drive, idescsi_scsi_t *scsi)
 {
-	DRIVER(drive)-&gt;busy++;
 	if (drive-&gt;id &amp;&amp; (drive-&gt;id-&gt;config &amp; 0x0060) == 0x20)
 		set_bit (IDESCSI_DRQ_INTERRUPT, &amp;scsi-&gt;flags);
 	set_bit(IDESCSI_TRANSFORM, &amp;scsi-&gt;transform);
@@ -722,17 +721,16 @@ static void idescsi_setup (ide_drive_t *drive, idescsi_scsi_t *scsi)
 	set_bit(IDESCSI_LOG_CMD, &amp;scsi-&gt;log);
 #endif /* IDESCSI_DEBUG_LOG */
 	idescsi_add_settings(drive);
-	DRIVER(drive)-&gt;busy--;
 }
 
-static int idescsi_cleanup (ide_drive_t *drive)
+static int ide_scsi_remove(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	struct Scsi_Host *scsihost = drive-&gt;driver_data;
 	struct ide_scsi_obj *scsi = scsihost_to_idescsi(scsihost);
 	struct gendisk *g = scsi-&gt;disk;
 
-	if (ide_unregister_subdriver(drive))
-		return 1;
+	ide_unregister_subdriver(drive, scsi-&gt;driver);
 
 	ide_unregister_region(g);
 
@@ -746,7 +744,7 @@ static int idescsi_cleanup (ide_drive_t *drive)
 	return 0;
 }
 
-static int idescsi_attach(ide_drive_t *drive);
+static int ide_scsi_probe(struct device *);
 
 #ifdef CONFIG_PROC_FS
 static ide_proc_entry_t idescsi_proc[] = {
@@ -757,24 +755,22 @@ static ide_proc_entry_t idescsi_proc[] = {
 # define idescsi_proc	NULL
 #endif
 
-/*
- *	IDE subdriver functions, registered with ide.c
- */
 static ide_driver_t idescsi_driver = {
 	.owner			= THIS_MODULE,
-	.name			= "ide-scsi",
+	.gen_driver = {
+		.name		= "ide-scsi",
+		.bus		= &amp;ide_bus_type,
+		.probe		= ide_scsi_probe,
+		.remove		= ide_scsi_remove,
+	},
 	.version		= IDESCSI_VERSION,
 	.media			= ide_scsi,
-	.busy			= 0,
 	.supports_dsc_overlap	= 0,
 	.proc			= idescsi_proc,
-	.attach			= idescsi_attach,
-	.cleanup		= idescsi_cleanup,
 	.do_request		= idescsi_do_request,
 	.end_request		= idescsi_end_request,
 	.error                  = idescsi_atapi_error,
 	.abort                  = idescsi_atapi_abort,
-	.drives			= LIST_HEAD_INIT(idescsi_driver.drives),
 };
 
 static int idescsi_ide_open(struct inode *inode, struct file *filp)
@@ -821,8 +817,6 @@ static struct block_device_operations idescsi_ops = {
 	.ioctl		= idescsi_ide_ioctl,
 };
 
-static int idescsi_attach(ide_drive_t *drive);
-
 static int idescsi_slave_configure(struct scsi_device * sdp)
 {
 	/* Configure detected device */
@@ -1095,8 +1089,9 @@ static struct scsi_host_template idescsi_template = {
 	.proc_name		= "ide-scsi",
 };
 
-static int idescsi_attach(ide_drive_t *drive)
+static int ide_scsi_probe(struct device *dev)
 {
+	ide_drive_t *drive = to_ide_device(dev);
 	idescsi_scsi_t *idescsi;
 	struct Scsi_Host *host;
 	struct gendisk *g;
@@ -1112,7 +1107,7 @@ static int idescsi_attach(ide_drive_t *drive)
 	    !drive-&gt;present ||
 	    drive-&gt;media == ide_disk ||
 	    !(host = scsi_host_alloc(&amp;idescsi_template,sizeof(idescsi_scsi_t))))
-		return 1;
+		return -ENODEV;
 
 	g = alloc_disk(1 &lt;&lt; PARTN_BITS);
 	if (!g)
@@ -1138,20 +1133,19 @@ static int idescsi_attach(ide_drive_t *drive)
 	idescsi-&gt;host = host;
 	idescsi-&gt;disk = g;
 	g-&gt;private_data = &amp;idescsi-&gt;driver;
-	err = ide_register_subdriver(drive, &amp;idescsi_driver);
+	ide_register_subdriver(drive, &amp;idescsi_driver);
+	err = 0;
+	idescsi_setup(drive, idescsi);
+	g-&gt;fops = &amp;idescsi_ops;
+	ide_register_region(g);
+	err = scsi_add_host(host, &amp;drive-&gt;gendev);
 	if (!err) {
-		idescsi_setup (drive, idescsi);
-		g-&gt;fops = &amp;idescsi_ops;
-		ide_register_region(g);
-		err = scsi_add_host(host, &amp;drive-&gt;gendev);
-		if (!err) {
-			scsi_scan_host(host);
-			return 0;
-		}
-		/* fall through on error */
-		ide_unregister_region(g);
-		ide_unregister_subdriver(drive);
+		scsi_scan_host(host);
+		return 0;
 	}
+	/* fall through on error */
+	ide_unregister_region(g);
+	ide_unregister_subdriver(drive, &amp;idescsi_driver);
 
 	put_disk(g);
 out_host_put:
@@ -1161,12 +1155,12 @@ static int idescsi_attach(ide_drive_t *drive)
 
 static int __init init_idescsi_module(void)
 {
-	return ide_register_driver(&amp;idescsi_driver);
+	return driver_register(&amp;idescsi_driver.gen_driver);
 }
 
 static void __exit exit_idescsi_module(void)
 {
-	ide_unregister_driver(&amp;idescsi_driver);
+	driver_unregister(&amp;idescsi_driver.gen_driver);
 }
 
 module_init(init_idescsi_module);
diff --git a/include/linux/ide.h b/include/linux/ide.h
index 9cfc0999becb..336d6e509f59 100644
--- a/include/linux/ide.h
+++ b/include/linux/ide.h
@@ -664,7 +664,6 @@ typedef struct ide_drive_s {
 
 	struct request		*rq;	/* current request */
 	struct ide_drive_s 	*next;	/* circular list of hwgroup drives */
-	struct ide_driver_s	*driver;/* (ide_driver_t *) */
 	void		*driver_data;	/* extra driver data */
 	struct hd_driveid	*id;	/* drive model identification info */
 	struct proc_dir_entry *proc;	/* /proc/ide/ directory entry */
@@ -758,6 +757,8 @@ typedef struct ide_drive_s {
 	struct semaphore gendev_rel_sem;	/* to deal with device release() */
 } ide_drive_t;
 
+#define to_ide_device(dev)container_of(dev, ide_drive_t, gendev)
+
 #define IDE_CHIPSET_PCI_MASK	\
     ((1&lt;&lt;ide_pci)|(1&lt;&lt;ide_cmd646)|(1&lt;&lt;ide_ali14xx))
 #define IDE_CHIPSET_IS_PCI(c)	((IDE_CHIPSET_PCI_MASK &gt;&gt; (c)) &amp; 1)
@@ -1086,28 +1087,20 @@ enum {
  */
 typedef struct ide_driver_s {
 	struct module			*owner;
-	const char			*name;
 	const char			*version;
 	u8				media;
-	unsigned busy			: 1;
 	unsigned supports_dsc_overlap	: 1;
-	int		(*cleanup)(ide_drive_t *);
 	ide_startstop_t	(*do_request)(ide_drive_t *, struct request *, sector_t);
 	int		(*end_request)(ide_drive_t *, int, int);
 	ide_startstop_t	(*error)(ide_drive_t *, struct request *rq, u8, u8);
 	ide_startstop_t	(*abort)(ide_drive_t *, struct request *rq);
 	int		(*ioctl)(ide_drive_t *, struct inode *, struct file *, unsigned int, unsigned long);
 	ide_proc_entry_t	*proc;
-	int		(*attach)(ide_drive_t *);
 	void		(*ata_prebuilder)(ide_drive_t *);
 	void		(*atapi_prebuilder)(ide_drive_t *);
 	struct device_driver	gen_driver;
-	struct list_head drives;
-	struct list_head drivers;
 } ide_driver_t;
 
-#define DRIVER(drive)		((drive)-&gt;driver)
-
 int generic_ide_ioctl(ide_drive_t *, struct file *, struct block_device *, unsigned, unsigned long);
 
 /*
@@ -1328,8 +1321,6 @@ extern void ide_init_subdrivers(void);
 
 void ide_init_disk(struct gendisk *, ide_drive_t *);
 
-extern int ata_attach(ide_drive_t *);
-
 extern int ideprobe_init(void);
 
 extern void ide_scan_pcibus(int scan_direction) __init;
@@ -1342,11 +1333,8 @@ extern void default_hwif_iops(ide_hwif_t *);
 extern void default_hwif_mmiops(ide_hwif_t *);
 extern void default_hwif_transport(ide_hwif_t *);
 
-int ide_register_driver(ide_driver_t *driver);
-void ide_unregister_driver(ide_driver_t *driver);
-int ide_register_subdriver(ide_drive_t *, ide_driver_t *);
-int ide_unregister_subdriver (ide_drive_t *drive);
-int ide_replace_subdriver(ide_drive_t *drive, const char *driver);
+void ide_register_subdriver(ide_drive_t *, ide_driver_t *);
+void ide_unregister_subdriver(ide_drive_t *, ide_driver_t *);
 
 #define ON_BOARD		1
 #define NEVER_BOARD		0</pre><hr><pre>commit 50f794c8dcfd0e63f3034d7cfd41e563f35741aa
Author: Lukasz Stemach &lt;stelmacl@ee.pw.edu.pl&gt;
Date:   Mon Jan 23 15:22:13 2006 +0100

    [ALSA] cs4236 - Add PnP ids for Netfinity 3000
    
    Modules: CS4236+ driver
    
    PnP ids for Netfinity 3000 builtin soundcard.
    
    This one works for me.
    
    This patch was submitted through kernel Bugzilla #4214.
    
    Signed-off-by: Adrian Bunk &lt;bunk@stusta.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/isa/cs423x/cs4236.c b/sound/isa/cs423x/cs4236.c
index edf9279bf9d9..4fa431040564 100644
--- a/sound/isa/cs423x/cs4236.c
+++ b/sound/isa/cs423x/cs4236.c
@@ -178,6 +178,8 @@ static struct pnp_card_device_id snd_cs423x_pnpids[] = {
 	{ .id = "CSC7632", .devs = { { "CSC0000" }, { "CSC0010" }, { "PNPb006" } } },
 	/* SIC CrystalWave 32 (CS4232) */
 	{ .id = "CSCf032", .devs = { { "CSC0000" }, { "CSC0010" }, { "CSC0003" } } },
+	/* Netfinity 3000 on-board soundcard */
+	{ .id = "CSCe825", .devs = { { "CSC0100" }, { "CSC0110" }, { "CSC010f" } } },
 	/* --- */
 	{ .id = "" }	/* end */
 };</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
