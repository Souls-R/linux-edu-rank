<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_100.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><span>[101]</span><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_102.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 9347d51c52afcf1a77d2104f162cf8a085624c83
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:41:41 2007 -0400

    USB: reorganize urb-&gt;status use in usbmon
    
    This patch (as978) reorganizes the way usbmon uses urb-&gt;status.  It
    now accepts the status value as an argument.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 8b17babf5c55..4ac021e42cd8 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1275,7 +1275,7 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 		urb-&gt;status = -EREMOTEIO;
 
 	unmap_urb_for_dma(hcd, urb);
-	usbmon_urb_complete(&amp;hcd-&gt;self, urb);
+	usbmon_urb_complete(&amp;hcd-&gt;self, urb, urb-&gt;status);
 	usb_unanchor_urb(urb);
 
 	/* pass ownership to the completion handler */
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 745be2566f62..729b7a03acd8 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -413,7 +413,7 @@ static inline void usbfs_cleanup(void) { }
 struct usb_mon_operations {
 	void (*urb_submit)(struct usb_bus *bus, struct urb *urb);
 	void (*urb_submit_error)(struct usb_bus *bus, struct urb *urb, int err);
-	void (*urb_complete)(struct usb_bus *bus, struct urb *urb);
+	void (*urb_complete)(struct usb_bus *bus, struct urb *urb, int status);
 	/* void (*urb_unlink)(struct usb_bus *bus, struct urb *urb); */
 };
 
@@ -432,10 +432,11 @@ static inline void usbmon_urb_submit_error(struct usb_bus *bus, struct urb *urb,
 		(*mon_ops-&gt;urb_submit_error)(bus, urb, error);
 }
 
-static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb)
+static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
+		int status)
 {
 	if (bus-&gt;monitored)
-		(*mon_ops-&gt;urb_complete)(bus, urb);
+		(*mon_ops-&gt;urb_complete)(bus, urb, status);
 }
 
 int usb_mon_register(struct usb_mon_operations *ops);
@@ -446,7 +447,8 @@ void usb_mon_deregister(void);
 static inline void usbmon_urb_submit(struct usb_bus *bus, struct urb *urb) {}
 static inline void usbmon_urb_submit_error(struct usb_bus *bus, struct urb *urb,
     int error) {}
-static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb) {}
+static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
+		int status) {}
 
 #endif /* CONFIG_USB_MON */
 
diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index 3d6f03819ffd..f06e4e2b49d3 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -386,7 +386,7 @@ static char mon_bin_get_data(const struct mon_reader_bin *rp,
 }
 
 static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
-    char ev_type)
+    char ev_type, int status)
 {
 	const struct usb_endpoint_descriptor *epd = &amp;urb-&gt;ep-&gt;desc;
 	unsigned long flags;
@@ -452,7 +452,7 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	ep-&gt;id = (unsigned long) urb;
 	ep-&gt;ts_sec = ts.tv_sec;
 	ep-&gt;ts_usec = ts.tv_usec;
-	ep-&gt;status = urb-&gt;status;
+	ep-&gt;status = status;
 	ep-&gt;len_urb = urb_length;
 	ep-&gt;len_cap = length;
 
@@ -475,13 +475,13 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 static void mon_bin_submit(void *data, struct urb *urb)
 {
 	struct mon_reader_bin *rp = data;
-	mon_bin_event(rp, urb, 'S');
+	mon_bin_event(rp, urb, 'S', -EINPROGRESS);
 }
 
-static void mon_bin_complete(void *data, struct urb *urb)
+static void mon_bin_complete(void *data, struct urb *urb, int status)
 {
 	struct mon_reader_bin *rp = data;
-	mon_bin_event(rp, urb, 'C');
+	mon_bin_event(rp, urb, 'C', status);
 }
 
 static void mon_bin_error(void *data, struct urb *urb, int error)
diff --git a/drivers/usb/mon/mon_main.c b/drivers/usb/mon/mon_main.c
index 2e317bd79e92..b371ffd39d36 100644
--- a/drivers/usb/mon/mon_main.c
+++ b/drivers/usb/mon/mon_main.c
@@ -129,7 +129,8 @@ static void mon_submit_error(struct usb_bus *ubus, struct urb *urb, int error)
 
 /*
  */
-static void mon_bus_complete(struct mon_bus *mbus, struct urb *urb)
+static void mon_bus_complete(struct mon_bus *mbus, struct urb *urb,
+		int status)
 {
 	unsigned long flags;
 	struct list_head *pos;
@@ -139,18 +140,18 @@ static void mon_bus_complete(struct mon_bus *mbus, struct urb *urb)
 	mbus-&gt;cnt_events++;
 	list_for_each (pos, &amp;mbus-&gt;r_list) {
 		r = list_entry(pos, struct mon_reader, r_link);
-		r-&gt;rnf_complete(r-&gt;r_data, urb);
+		r-&gt;rnf_complete(r-&gt;r_data, urb, status);
 	}
 	spin_unlock_irqrestore(&amp;mbus-&gt;lock, flags);
 }
 
-static void mon_complete(struct usb_bus *ubus, struct urb *urb)
+static void mon_complete(struct usb_bus *ubus, struct urb *urb, int status)
 {
 	struct mon_bus *mbus;
 
 	if ((mbus = ubus-&gt;mon_bus) != NULL)
-		mon_bus_complete(mbus, urb);
-	mon_bus_complete(&amp;mon_bus0, urb);
+		mon_bus_complete(mbus, urb, status);
+	mon_bus_complete(&amp;mon_bus0, urb, status);
 }
 
 /* int (*unlink_urb) (struct urb *urb, int status); */
diff --git a/drivers/usb/mon/mon_text.c b/drivers/usb/mon/mon_text.c
index 663a702a17dd..ebb04ac4857b 100644
--- a/drivers/usb/mon/mon_text.c
+++ b/drivers/usb/mon/mon_text.c
@@ -183,7 +183,7 @@ static inline unsigned int mon_get_timestamp(void)
 }
 
 static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
-    char ev_type)
+    char ev_type, int status)
 {
 	struct mon_event_text *ep;
 	unsigned int stamp;
@@ -210,7 +210,7 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 	ep-&gt;length = (ev_type == 'S') ?
 	    urb-&gt;transfer_buffer_length : urb-&gt;actual_length;
 	/* Collecting status makes debugging sense for submits, too */
-	ep-&gt;status = urb-&gt;status;
+	ep-&gt;status = status;
 
 	if (ep-&gt;xfertype == USB_ENDPOINT_XFER_INT) {
 		ep-&gt;interval = urb-&gt;interval;
@@ -248,13 +248,13 @@ static void mon_text_event(struct mon_reader_text *rp, struct urb *urb,
 static void mon_text_submit(void *data, struct urb *urb)
 {
 	struct mon_reader_text *rp = data;
-	mon_text_event(rp, urb, 'S');
+	mon_text_event(rp, urb, 'S', -EINPROGRESS);
 }
 
-static void mon_text_complete(void *data, struct urb *urb)
+static void mon_text_complete(void *data, struct urb *urb, int status)
 {
 	struct mon_reader_text *rp = data;
-	mon_text_event(rp, urb, 'C');
+	mon_text_event(rp, urb, 'C', status);
 }
 
 static void mon_text_error(void *data, struct urb *urb, int error)
diff --git a/drivers/usb/mon/usb_mon.h b/drivers/usb/mon/usb_mon.h
index f68ad6d99ad7..f5d84ff8c101 100644
--- a/drivers/usb/mon/usb_mon.h
+++ b/drivers/usb/mon/usb_mon.h
@@ -46,7 +46,7 @@ struct mon_reader {
 
 	void (*rnf_submit)(void *data, struct urb *urb);
 	void (*rnf_error)(void *data, struct urb *urb, int error);
-	void (*rnf_complete)(void *data, struct urb *urb);
+	void (*rnf_complete)(void *data, struct urb *urb, int status);
 };
 
 void mon_reader_add(struct mon_bus *mbus, struct mon_reader *r);</pre><hr><pre>commit 888fda47051716765175d0008450126c837adb32
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:41:18 2007 -0400

    USB: reorganize urb-&gt;status use in r8a66597-hcd
    
    This patch (as977) reorganizes the way r8a66597-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    Parts of this patch were written by Yoshihiro Shimoda.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 98b9e0547544..fea6036771f6 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1109,7 +1109,7 @@ static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)
 
 /* this function must be called with interrupt disabled */
 static void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,
-		u16 pipenum, struct urb *urb)
+		u16 pipenum, struct urb *urb, int status)
 __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 {
 	int restart = 0;
@@ -1118,7 +1118,7 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 	r8a66597-&gt;timeout_map &amp;= ~(1 &lt;&lt; pipenum);
 
 	if (likely(td)) {
-		if (td-&gt;set_address &amp;&amp; (urb-&gt;status != 0 || urb-&gt;unlinked))
+		if (td-&gt;set_address &amp;&amp; (status != 0 || urb-&gt;unlinked))
 			r8a66597-&gt;address_map &amp;= ~(1 &lt;&lt; urb-&gt;setup_packet[2]);
 
 		pipe_toggle_save(r8a66597, td-&gt;pipe, urb);
@@ -1135,6 +1135,7 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 
 		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
 
+		urb-&gt;status = status;
 		spin_unlock(&amp;r8a66597-&gt;lock);
 		usb_hcd_giveback_urb(hcd, urb);
 		spin_lock(&amp;r8a66597-&gt;lock);
@@ -1167,11 +1168,10 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	fifo_change_from_pipe(r8a66597, td-&gt;pipe);
 	tmp = r8a66597_read(r8a66597, td-&gt;pipe-&gt;fifoctr);
 	if (unlikely((tmp &amp; FRDY) == 0)) {
-		urb-&gt;status = -EPIPE;
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, pipenum);
 		err("in fifo not ready (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td-&gt;urb);
+		finish_request(r8a66597, td, pipenum, td-&gt;urb, -EPIPE);
 		return;
 	}
 
@@ -1224,10 +1224,8 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 					   buf, size);
 	}
 
-	if (finish &amp;&amp; pipenum != 0) {
-		td-&gt;urb-&gt;status = status;
-		finish_request(r8a66597, td, pipenum, urb);
-	}
+	if (finish &amp;&amp; pipenum != 0)
+		finish_request(r8a66597, td, pipenum, urb, status);
 }
 
 static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
@@ -1245,11 +1243,10 @@ static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
 	fifo_change_from_pipe(r8a66597, td-&gt;pipe);
 	tmp = r8a66597_read(r8a66597, td-&gt;pipe-&gt;fifoctr);
 	if (unlikely((tmp &amp; FRDY) == 0)) {
-		urb-&gt;status = -EPIPE;
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, pipenum);
 		err("out write fifo not ready. (%d)", pipenum);
-		finish_request(r8a66597, td, pipenum, td-&gt;urb);
+		finish_request(r8a66597, td, pipenum, urb, -EPIPE);
 		return;
 	}
 
@@ -1294,7 +1291,7 @@ static void packet_write(struct r8a66597 *r8a66597, u16 pipenum)
 }
 
 
-static void check_next_phase(struct r8a66597 *r8a66597)
+static void check_next_phase(struct r8a66597 *r8a66597, int status)
 {
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, 0);
 	struct urb *urb;
@@ -1320,28 +1317,28 @@ static void check_next_phase(struct r8a66597 *r8a66597)
 		break;
 	case USB_PID_ACK:
 		finish = 1;
-		urb-&gt;status = 0;
 		break;
 	}
 
-	if (finish || urb-&gt;unlinked)
-		finish_request(r8a66597, td, 0, urb);
+	if (finish || status != 0 || urb-&gt;unlinked)
+		finish_request(r8a66597, td, 0, urb, status);
 	else
 		start_transfer(r8a66597, td);
 }
 
-static void set_urb_error(struct r8a66597 *r8a66597, u16 pipenum)
+static int get_urb_error(struct r8a66597 *r8a66597, u16 pipenum)
 {
 	struct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);
 
-	if (td &amp;&amp; td-&gt;urb) {
+	if (td) {
 		u16 pid = r8a66597_read(r8a66597, td-&gt;pipe-&gt;pipectr) &amp; PID;
 
 		if (pid == PID_NAK)
-			td-&gt;urb-&gt;status = -ECONNRESET;
+			return -ECONNRESET;
 		else
-			td-&gt;urb-&gt;status = -EPIPE;
+			return -EPIPE;
 	}
+	return 0;
 }
 
 static void irq_pipe_ready(struct r8a66597 *r8a66597)
@@ -1360,7 +1357,7 @@ static void irq_pipe_ready(struct r8a66597 *r8a66597)
 			packet_read(r8a66597, 0);
 		else
 			pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, 0);
 	}
 
 	for (pipenum = 1; pipenum &lt; R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1394,7 +1391,7 @@ static void irq_pipe_empty(struct r8a66597 *r8a66597)
 		td = r8a66597_get_td(r8a66597, 0);
 		if (td &amp;&amp; td-&gt;type != USB_PID_OUT)
 			disable_irq_empty(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, 0);
 	}
 
 	for (pipenum = 1; pipenum &lt; R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1409,8 +1406,8 @@ static void irq_pipe_empty(struct r8a66597 *r8a66597)
 			if ((tmp &amp; INBUFM) == 0) {
 				disable_irq_empty(r8a66597, pipenum);
 				pipe_irq_disable(r8a66597, pipenum);
-				td-&gt;urb-&gt;status = 0;
-				finish_request(r8a66597, td, pipenum, td-&gt;urb);
+				finish_request(r8a66597, td, pipenum, td-&gt;urb,
+						0);
 			}
 		}
 	}
@@ -1421,15 +1418,16 @@ static void irq_pipe_nrdy(struct r8a66597 *r8a66597)
 	u16 check;
 	u16 pipenum;
 	u16 mask;
+	int status;
 
 	mask = r8a66597_read(r8a66597, NRDYSTS)
 	       &amp; r8a66597_read(r8a66597, NRDYENB);
 	r8a66597_write(r8a66597, ~mask, NRDYSTS);
 	if (mask &amp; NRDY0) {
 		cfifo_change(r8a66597, 0);
-		set_urb_error(r8a66597, 0);
+		status = get_urb_error(r8a66597, 0);
 		pipe_irq_disable(r8a66597, 0);
-		check_next_phase(r8a66597);
+		check_next_phase(r8a66597, status);
 	}
 
 	for (pipenum = 1; pipenum &lt; R8A66597_MAX_NUM_PIPE; pipenum++) {
@@ -1440,10 +1438,10 @@ static void irq_pipe_nrdy(struct r8a66597 *r8a66597)
 			if (unlikely(!td))
 				continue;
 
-			set_urb_error(r8a66597, pipenum);
+			status = get_urb_error(r8a66597, pipenum);
 			pipe_irq_disable(r8a66597, pipenum);
 			pipe_stop(r8a66597, td-&gt;pipe);
-			finish_request(r8a66597, td, pipenum, td-&gt;urb);
+			finish_request(r8a66597, td, pipenum, td-&gt;urb, status);
 		}
 	}
 }
@@ -1463,6 +1461,7 @@ static irqreturn_t r8a66597_irq(struct usb_hcd *hcd)
 	u16 intsts0, intsts1, intsts2;
 	u16 intenb0, intenb1, intenb2;
 	u16 mask0, mask1, mask2;
+	int status;
 
 	spin_lock(&amp;r8a66597-&gt;lock);
 
@@ -1506,12 +1505,12 @@ static irqreturn_t r8a66597_irq(struct usb_hcd *hcd)
 		}
 		if (mask1 &amp; SIGN) {
 			r8a66597_write(r8a66597, ~SIGN, INTSTS1);
-			set_urb_error(r8a66597, 0);
-			check_next_phase(r8a66597);
+			status = get_urb_error(r8a66597, 0);
+			check_next_phase(r8a66597, status);
 		}
 		if (mask1 &amp; SACK) {
 			r8a66597_write(r8a66597, ~SACK, INTSTS1);
-			check_next_phase(r8a66597);
+			check_next_phase(r8a66597, 0);
 		}
 	}
 	if (mask0) {
@@ -1790,7 +1789,7 @@ static int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
 		pipe_stop(r8a66597, td-&gt;pipe);
 		pipe_irq_disable(r8a66597, td-&gt;pipenum);
 		disable_irq_empty(r8a66597, td-&gt;pipenum);
-		finish_request(r8a66597, td, td-&gt;pipenum, urb);
+		finish_request(r8a66597, td, td-&gt;pipenum, urb, status);
 	}
  done:
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);
@@ -1824,7 +1823,7 @@ static void r8a66597_endpoint_disable(struct usb_hcd *hcd,
 	td = r8a66597_get_td(r8a66597, pipenum);
 	if (td)
 		urb = td-&gt;urb;
-	finish_request(r8a66597, td, pipenum, urb);
+	finish_request(r8a66597, td, pipenum, urb, -ESHUTDOWN);
 	kfree(hep-&gt;hcpriv);
 	hep-&gt;hcpriv = NULL;
 	spin_unlock_irqrestore(&amp;r8a66597-&gt;lock, flags);</pre><hr><pre>commit 65e51098d9094c7e840b6d6291867b95538d9442
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:47 2007 -0400

    USB: reorganize urb-&gt;status use in sl811-hcd
    
    This patch (as976) reorganizes the way sl811-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    The patch also improves the handling of faults during the status stage
    of a control transfer, since it no longer needs to retain the error
    information from the earlier stages.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index f0fa94148d9d..515152809d37 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -435,11 +435,8 @@ static void finish_request(
 	if (usb_pipecontrol(urb-&gt;pipe))
 		ep-&gt;nextpid = USB_PID_SETUP;
 
-	spin_lock(&amp;urb-&gt;lock);
-	urb-&gt;status = status;
-	spin_unlock(&amp;urb-&gt;lock);
-
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
+	urb-&gt;status = status;
 	spin_unlock(&amp;sl811-&gt;lock);
 	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
 	spin_lock(&amp;sl811-&gt;lock);
@@ -537,27 +534,20 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 						bank + SL11H_XFERCNTREG);
 			if (len &gt; ep-&gt;length) {
 				len = ep-&gt;length;
-				urb-&gt;status = -EOVERFLOW;
+				urbstat = -EOVERFLOW;
 			}
 			urb-&gt;actual_length += len;
 			sl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),
 					buf, len);
 			usb_dotoggle(udev, ep-&gt;epnum, 0);
-			if (urb-&gt;actual_length == urb-&gt;transfer_buffer_length
-					|| len &lt; ep-&gt;maxpacket)
-				urbstat = 0;
-			if (usb_pipecontrol(urb-&gt;pipe) &amp;&amp; urbstat == 0) {
-
-				/* NOTE if the status stage STALLs (why?),
-				 * this reports the wrong urb status.
-				 */
-				spin_lock(&amp;urb-&gt;lock);
-				if (urb-&gt;status == -EINPROGRESS)
-					urb-&gt;status = urbstat;
-				spin_unlock(&amp;urb-&gt;lock);
-
-				urb = NULL;
-				ep-&gt;nextpid = USB_PID_ACK;
+			if (urbstat == -EINPROGRESS &amp;&amp;
+					(len &lt; ep-&gt;maxpacket ||
+						urb-&gt;actual_length ==
+						urb-&gt;transfer_buffer_length)) {
+				if (usb_pipecontrol(urb-&gt;pipe))
+					ep-&gt;nextpid = USB_PID_ACK;
+				else
+					urbstat = 0;
 			}
 			break;
 		case USB_PID_SETUP:
@@ -597,7 +587,7 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 				bank, status, ep, urbstat);
 	}
 
-	if (urb &amp;&amp; (urbstat != -EINPROGRESS || urb-&gt;unlinked))
+	if (urbstat != -EINPROGRESS || urb-&gt;unlinked)
 		finish_request(sl811, ep, urb, urbstat);
 }
 </pre><hr><pre>commit 55d8496837cf124f68656e4242a5e20eb592fd54
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:34 2007 -0400

    USB: reorganize urb-&gt;status use in ohci-hcd
    
    This patch (as975) reorganizes the way ohci-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index f61c6cdd06f2..ebab5ce8f5ce 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -24,7 +24,7 @@
  * small: 0) header + data packets 1) just header
  */
 static void __maybe_unused
-urb_print (struct urb * urb, char * str, int small)
+urb_print(struct urb * urb, char * str, int small, int status)
 {
 	unsigned int pipe= urb-&gt;pipe;
 
@@ -34,7 +34,7 @@ urb_print (struct urb * urb, char * str, int small)
 	}
 
 #ifndef	OHCI_VERBOSE_DEBUG
-	if (urb-&gt;status != 0)
+	if (status != 0)
 #endif
 	dbg("%s %p dev=%d ep=%d%s-%s flags=%x len=%d/%d stat=%d",
 		    str,
@@ -46,7 +46,7 @@ urb_print (struct urb * urb, char * str, int small)
 		    urb-&gt;transfer_flags,
 		    urb-&gt;actual_length,
 		    urb-&gt;transfer_buffer_length,
-		    urb-&gt;status);
+		    status);
 
 #ifdef	OHCI_VERBOSE_DEBUG
 	if (!small) {
@@ -66,7 +66,7 @@ urb_print (struct urb * urb, char * str, int small)
 						urb-&gt;transfer_buffer_length: urb-&gt;actual_length;
 			for (i = 0; i &lt; 16 &amp;&amp; i &lt; len; i++)
 				printk (" %02x", ((__u8 *) urb-&gt;transfer_buffer) [i]);
-			printk ("%s stat:%d\n", i &lt; len? "...": "", urb-&gt;status);
+			printk ("%s stat:%d\n", i &lt; len? "...": "", status);
 		}
 	}
 #endif
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 6b06ab69938f..f7c6ced2bc03 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -129,7 +129,7 @@ static int ohci_urb_enqueue (
 	int		retval = 0;
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "SUB", usb_pipein (pipe));
+	urb_print(urb, "SUB", usb_pipein(pipe), -EINPROGRESS);
 #endif
 
 	/* every endpoint has a ed, locate and maybe (re)initialize it */
@@ -240,8 +240,8 @@ static int ohci_urb_enqueue (
 }
 
 /*
- * decouple the URB from the HC queues (TDs, urb_priv); it's
- * already marked using urb-&gt;status.  reporting is always done
+ * decouple the URB from the HC queues (TDs, urb_priv).
+ * reporting is always done
  * asynchronously, and we might be dealing with an urb that's
  * partially transferred, or an ED with other urbs being unlinked.
  */
@@ -252,7 +252,7 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	int			rc;
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "UNLINK", 1);
+	urb_print(urb, "UNLINK", 1, status);
 #endif
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
@@ -277,7 +277,7 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		 * any more ... just clean up every urb's memory.
 		 */
 		if (urb-&gt;hcpriv)
-			finish_urb (ohci, urb);
+			finish_urb(ohci, urb, status);
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return rc;
@@ -927,9 +927,8 @@ static int ohci_restart (struct ohci_hcd *ohci)
 					ed, ed-&gt;state);
 		}
 
-		spin_lock (&amp;urb-&gt;lock);
-		urb-&gt;status = -ESHUTDOWN;
-		spin_unlock (&amp;urb-&gt;lock);
+		if (!urb-&gt;unlinked)
+			urb-&gt;unlinked = -ESHUTDOWN;
 	}
 	finish_unlinks (ohci, 0);
 	spin_unlock_irq(&amp;ohci-&gt;lock);
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 860e55ff67a1..13d31edd1a86 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -36,18 +36,15 @@ static void urb_free_priv (struct ohci_hcd *hc, urb_priv_t *urb_priv)
  * PRECONDITION:  ohci lock held, irqs blocked.
  */
 static void
-finish_urb (struct ohci_hcd *ohci, struct urb *urb)
+finish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)
 __releases(ohci-&gt;lock)
 __acquires(ohci-&gt;lock)
 {
 	// ASSERT (urb-&gt;hcpriv != 0);
 
 	urb_free_priv (ohci, urb-&gt;hcpriv);
-
-	spin_lock (&amp;urb-&gt;lock);
-	if (likely (urb-&gt;status == -EINPROGRESS))
-		urb-&gt;status = 0;
-	spin_unlock (&amp;urb-&gt;lock);
+	if (likely(status == -EINPROGRESS))
+		status = 0;
 
 	switch (usb_pipetype (urb-&gt;pipe)) {
 	case PIPE_ISOCHRONOUS:
@@ -59,12 +56,13 @@ __acquires(ohci-&gt;lock)
 	}
 
 #ifdef OHCI_VERBOSE_DEBUG
-	urb_print (urb, "RET", usb_pipeout (urb-&gt;pipe));
+	urb_print(urb, "RET", usb_pipeout (urb-&gt;pipe), status);
 #endif
 
 	/* urb-&gt;complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);
 	spin_unlock (&amp;ohci-&gt;lock);
+	urb-&gt;status = status;
 	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
 	spin_lock (&amp;ohci-&gt;lock);
 
@@ -702,19 +700,18 @@ static void td_submit_urb (
  * Done List handling functions
  *-------------------------------------------------------------------------*/
 
-/* calculate transfer length/status and update the urb
- * PRECONDITION:  irqsafe (only for urb-&gt;status locking)
- */
-static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
+/* calculate transfer length/status and update the urb */
+static int td_done(struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 {
 	u32	tdINFO = hc32_to_cpup (ohci, &amp;td-&gt;hwINFO);
 	int	cc = 0;
+	int	status = -EINPROGRESS;
 
 	list_del (&amp;td-&gt;td_list);
 
 	/* ISO ... drivers see per-TD length/status */
 	if (tdINFO &amp; TD_ISO) {
-		u16	tdPSW = ohci_hwPSW (ohci, td, 0);
+		u16	tdPSW = ohci_hwPSW(ohci, td, 0);
 		int	dlen = 0;
 
 		/* NOTE:  assumes FC in tdINFO == 0, and that
@@ -723,7 +720,7 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 
 		cc = (tdPSW &gt;&gt; 12) &amp; 0xF;
 		if (tdINFO &amp; TD_CC)	/* hc didn't touch? */
-			return;
+			return status;
 
 		if (usb_pipeout (urb-&gt;pipe))
 			dlen = urb-&gt;iso_frame_desc [td-&gt;index].length;
@@ -756,11 +753,8 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 		if (cc == TD_DATAUNDERRUN
 				&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))
 			cc = TD_CC_NOERROR;
-		if (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E) {
-			spin_lock (&amp;urb-&gt;lock);
-			urb-&gt;status = cc_to_error[cc];
-			spin_unlock (&amp;urb-&gt;lock);
-		}
+		if (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E)
+			status = cc_to_error[cc];
 
 		/* count all non-empty packets except control SETUP packet */
 		if ((type != PIPE_CONTROL || td-&gt;index != 0) &amp;&amp; tdBE != 0) {
@@ -779,6 +773,7 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 				urb-&gt;actual_length,
 				urb-&gt;transfer_buffer_length);
 	}
+	return status;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -979,7 +974,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			/* if URB is done, clean up */
 			if (urb_priv-&gt;td_cnt == urb_priv-&gt;length) {
 				modified = completed = 1;
-				finish_urb (ohci, urb);
+				finish_urb(ohci, urb, 0);
 			}
 		}
 		if (completed &amp;&amp; !list_empty (&amp;ed-&gt;td_list))
@@ -1062,14 +1057,15 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
 	struct urb	*urb = td-&gt;urb;
 	urb_priv_t	*urb_priv = urb-&gt;hcpriv;
 	struct ed	*ed = td-&gt;ed;
+	int		status;
 
 	/* update URB's length and status from TD */
-	td_done(ohci, urb, td);
+	status = td_done(ohci, urb, td);
 	urb_priv-&gt;td_cnt++;
 
 	/* If all this urb's TDs are done, call complete() */
 	if (urb_priv-&gt;td_cnt == urb_priv-&gt;length)
-		finish_urb(ohci, urb);
+		finish_urb(ohci, urb, status);
 
 	/* clean schedule:  unlink EDs that are no longer busy */
 	if (list_empty(&amp;ed-&gt;td_list)) {</pre><hr><pre>commit 14c04c0f88f228fee1f412be91d6edcb935c78aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:19 2007 -0400

    USB: reorganize urb-&gt;status use in ehci-hcd
    
    This patch (as974) reorganizes the way ehci-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    The patch also simplifies the handling of -EREMOTEIO, since the only
    use of that code is to set the do_status flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index a8f5408c161d..794d27e07807 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -139,63 +139,65 @@ qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 /*-------------------------------------------------------------------------*/
 
-static void qtd_copy_status (
+static int qtd_copy_status (
 	struct ehci_hcd *ehci,
 	struct urb *urb,
 	size_t length,
 	u32 token
 )
 {
+	int	status = -EINPROGRESS;
+
 	/* count IN/OUT bytes, not SETUP (even short packets) */
 	if (likely (QTD_PID (token) != 2))
 		urb-&gt;actual_length += length - QTD_LENGTH (token);
 
 	/* don't modify error codes */
 	if (unlikely(urb-&gt;unlinked))
-		return;
+		return status;
 
 	/* force cleanup after short read; not always an error */
 	if (unlikely (IS_SHORT_READ (token)))
-		urb-&gt;status = -EREMOTEIO;
+		status = -EREMOTEIO;
 
 	/* serious "can't proceed" faults reported by the hardware */
 	if (token &amp; QTD_STS_HALT) {
 		if (token &amp; QTD_STS_BABBLE) {
 			/* FIXME "must" disable babbling device's port too */
-			urb-&gt;status = -EOVERFLOW;
+			status = -EOVERFLOW;
 		} else if (token &amp; QTD_STS_MMF) {
 			/* fs/ls interrupt xfer missed the complete-split */
-			urb-&gt;status = -EPROTO;
+			status = -EPROTO;
 		} else if (token &amp; QTD_STS_DBE) {
-			urb-&gt;status = (QTD_PID (token) == 1) /* IN ? */
+			status = (QTD_PID (token) == 1) /* IN ? */
 				? -ENOSR  /* hc couldn't read data */
 				: -ECOMM; /* hc couldn't write data */
 		} else if (token &amp; QTD_STS_XACT) {
 			/* timeout, bad crc, wrong PID, etc; retried */
 			if (QTD_CERR (token))
-				urb-&gt;status = -EPIPE;
+				status = -EPIPE;
 			else {
 				ehci_dbg (ehci, "devpath %s ep%d%s 3strikes\n",
 					urb-&gt;dev-&gt;devpath,
 					usb_pipeendpoint (urb-&gt;pipe),
 					usb_pipein (urb-&gt;pipe) ? "in" : "out");
-				urb-&gt;status = -EPROTO;
+				status = -EPROTO;
 			}
 		/* CERR nonzero + no errors + halt --&gt; stall */
 		} else if (QTD_CERR (token))
-			urb-&gt;status = -EPIPE;
+			status = -EPIPE;
 		else	/* unknown */
-			urb-&gt;status = -EPROTO;
+			status = -EPROTO;
 
 		ehci_vdbg (ehci,
 			"dev%d ep%d%s qtd token %08x --&gt; status %d\n",
 			usb_pipedevice (urb-&gt;pipe),
 			usb_pipeendpoint (urb-&gt;pipe),
 			usb_pipein (urb-&gt;pipe) ? "in" : "out",
-			token, urb-&gt;status);
+			token, status);
 
 		/* if async CSPLIT failed, try cleaning out the TT buffer */
-		if (urb-&gt;status != -EPIPE
+		if (status != -EPIPE
 				&amp;&amp; urb-&gt;dev-&gt;tt &amp;&amp; !usb_pipeint (urb-&gt;pipe)
 				&amp;&amp; ((token &amp; QTD_STS_MMF) != 0
 					|| QTD_CERR(token) == 0)
@@ -212,10 +214,12 @@ static void qtd_copy_status (
 			usb_hub_tt_clear_buffer (urb-&gt;dev, urb-&gt;pipe);
 		}
 	}
+
+	return status;
 }
 
 static void
-ehci_urb_done (struct ehci_hcd *ehci, struct urb *urb)
+ehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)
 __releases(ehci-&gt;lock)
 __acquires(ehci-&gt;lock)
 {
@@ -231,17 +235,13 @@ __acquires(ehci-&gt;lock)
 		qh_put (qh);
 	}
 
-	spin_lock (&amp;urb-&gt;lock);
 	if (unlikely(urb-&gt;unlinked)) {
 		COUNT(ehci-&gt;stats.unlink);
 	} else {
-		if (likely(urb-&gt;status == -EINPROGRESS ||
-				(urb-&gt;status == -EREMOTEIO &amp;&amp;
-				 !(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))))
-			urb-&gt;status = 0;
+		if (likely(status == -EINPROGRESS))
+			status = 0;
 		COUNT(ehci-&gt;stats.complete);
 	}
-	spin_unlock (&amp;urb-&gt;lock);
 
 #ifdef EHCI_URB_TRACE
 	ehci_dbg (ehci,
@@ -249,13 +249,14 @@ __acquires(ehci-&gt;lock)
 		__FUNCTION__, urb-&gt;dev-&gt;devpath, urb,
 		usb_pipeendpoint (urb-&gt;pipe),
 		usb_pipein (urb-&gt;pipe) ? "in" : "out",
-		urb-&gt;status,
+		status,
 		urb-&gt;actual_length, urb-&gt;transfer_buffer_length);
 #endif
 
 	/* complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&amp;ehci-&gt;lock);
+	urb-&gt;status = status;
 	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
 	spin_lock (&amp;ehci-&gt;lock);
 }
@@ -276,6 +277,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	struct ehci_qtd		*last = NULL, *end = qh-&gt;dummy;
 	struct list_head	*entry, *tmp;
+	int			last_status = -EINPROGRESS;
 	int			stopped;
 	unsigned		count = 0;
 	int			do_status = 0;
@@ -304,6 +306,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		struct ehci_qtd	*qtd;
 		struct urb	*urb;
 		u32		token = 0;
+		int		qtd_status;
 
 		qtd = list_entry (entry, struct ehci_qtd, qtd_list);
 		urb = qtd-&gt;urb;
@@ -311,11 +314,12 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		/* clean up any state from previous QTD ...*/
 		if (last) {
 			if (likely (last-&gt;urb != urb)) {
-				ehci_urb_done (ehci, last-&gt;urb);
+				ehci_urb_done(ehci, last-&gt;urb, last_status);
 				count++;
 			}
 			ehci_qtd_free (ehci, last);
 			last = NULL;
+			last_status = -EINPROGRESS;
 		}
 
 		/* ignore urbs submitted during completions we reported */
@@ -351,13 +355,13 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			stopped = 1;
 
 			if (unlikely (!HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state)))
-				urb-&gt;status = -ESHUTDOWN;
+				last_status = -ESHUTDOWN;
 
 			/* ignore active urbs unless some previous qtd
 			 * for the urb faulted (including short read) or
 			 * its urb was canceled.  we may patch qh or qtds.
 			 */
-			if (likely(urb-&gt;status == -EINPROGRESS &amp;&amp;
+			if (likely(last_status == -EINPROGRESS &amp;&amp;
 					!urb-&gt;unlinked))
 				continue;
 
@@ -386,14 +390,14 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		}
 
 		/* remove it from the queue */
-		spin_lock (&amp;urb-&gt;lock);
-		qtd_copy_status (ehci, urb, qtd-&gt;length, token);
-		if (unlikely(urb-&gt;status == -EREMOTEIO)) {
+		qtd_status = qtd_copy_status(ehci, urb, qtd-&gt;length, token);
+		if (unlikely(qtd_status == -EREMOTEIO)) {
 			do_status = (!urb-&gt;unlinked &amp;&amp;
 					usb_pipecontrol(urb-&gt;pipe));
-			urb-&gt;status = 0;
+			qtd_status = 0;
 		}
-		spin_unlock (&amp;urb-&gt;lock);
+		if (likely(last_status == -EINPROGRESS))
+			last_status = qtd_status;
 
 		if (stopped &amp;&amp; qtd-&gt;qtd_list.prev != &amp;qh-&gt;qtd_list) {
 			last = list_entry (qtd-&gt;qtd_list.prev,
@@ -406,7 +410,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* last urb's completion might still need calling */
 	if (likely (last != NULL)) {
-		ehci_urb_done (ehci, last-&gt;urb);
+		ehci_urb_done(ehci, last-&gt;urb, last_status);
 		count++;
 		ehci_qtd_free (ehci, last);
 	}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 8b267b3fd2bb..80d99bce2b38 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1627,7 +1627,7 @@ itd_complete (
 
 	/* give urb back to the driver ... can be out-of-order */
 	dev = urb-&gt;dev;
-	ehci_urb_done (ehci, urb);
+	ehci_urb_done(ehci, urb, 0);
 	urb = NULL;
 
 	/* defer stopping schedule; completion can submit */
@@ -2000,7 +2000,7 @@ sitd_complete (
 
 	/* give urb back to the driver */
 	dev = urb-&gt;dev;
-	ehci_urb_done (ehci, urb);
+	ehci_urb_done(ehci, urb, 0);
 	urb = NULL;
 
 	/* defer stopping schedule; completion can submit */</pre><hr><pre>commit 4d2f110c51eec853c50f68cf068888a77551c8d3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:40:10 2007 -0400

    USB: reorganize urb-&gt;status use in dummy-hcd
    
    This patch (as973) reorganizes the way dummy-hcd sets urb-&gt;status.  It
    now keeps the information in a local variable until the last moment.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index f2b124cf3206..c1af7bab26f0 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1026,16 +1026,10 @@ static int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	return rc;
 }
 
-static void maybe_set_status (struct urb *urb, int status)
-{
-	spin_lock (&amp;urb-&gt;lock);
-	urb-&gt;status = status;
-	spin_unlock (&amp;urb-&gt;lock);
-}
-
 /* transfer up to a frame's worth; caller must own lock */
 static int
-transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
+transfer(struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit,
+		int *status)
 {
 	struct dummy_request	*req;
 
@@ -1103,15 +1097,15 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 		if (is_short) {
 			if (host_len == dev_len) {
 				req-&gt;req.status = 0;
-				maybe_set_status (urb, 0);
+				*status = 0;
 			} else if (to_host) {
 				req-&gt;req.status = 0;
 				if (dev_len &gt; host_len)
-					maybe_set_status (urb, -EOVERFLOW);
+					*status = -EOVERFLOW;
 				else
-					maybe_set_status (urb, 0);
+					*status = 0;
 			} else if (!to_host) {
-				maybe_set_status (urb, 0);
+				*status = 0;
 				if (host_len &gt; dev_len)
 					req-&gt;req.status = -EOVERFLOW;
 				else
@@ -1125,9 +1119,8 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 				req-&gt;req.status = 0;
 			if (urb-&gt;transfer_buffer_length == urb-&gt;actual_length
 					&amp;&amp; !(urb-&gt;transfer_flags
-						&amp; URB_ZERO_PACKET)) {
-				maybe_set_status (urb, 0);
-			}
+						&amp; URB_ZERO_PACKET))
+				*status = 0;
 		}
 
 		/* device side completion --&gt; continuable */
@@ -1143,7 +1136,7 @@ transfer (struct dummy *dum, struct urb *urb, struct dummy_ep *ep, int limit)
 		}
 
 		/* host side completion --&gt; terminate */
-		if (urb-&gt;status != -EINPROGRESS)
+		if (*status != -EINPROGRESS)
 			break;
 
 		/* rescan to continue with any other queued i/o */
@@ -1254,6 +1247,7 @@ static void dummy_timer (unsigned long _dum)
 		u8			address;
 		struct dummy_ep		*ep = NULL;
 		int			type;
+		int			status = -EINPROGRESS;
 
 		urb = urbp-&gt;urb;
 		if (urb-&gt;unlinked)
@@ -1279,7 +1273,7 @@ static void dummy_timer (unsigned long _dum)
 			dev_dbg (dummy_dev(dum),
 				"no ep configured for urb %p\n",
 				urb);
-			maybe_set_status (urb, -EPROTO);
+			status = -EPROTO;
 			goto return_urb;
 		}
 
@@ -1294,7 +1288,7 @@ static void dummy_timer (unsigned long _dum)
 			/* NOTE: must not be iso! */
 			dev_dbg (dummy_dev(dum), "ep %s halted, urb %p\n",
 					ep-&gt;ep.name, urb);
-			maybe_set_status (urb, -EPIPE);
+			status = -EPIPE;
 			goto return_urb;
 		}
 		/* FIXME make sure both ends agree on maxpacket */
@@ -1312,7 +1306,7 @@ static void dummy_timer (unsigned long _dum)
 			w_value = le16_to_cpu(setup.wValue);
 			if (le16_to_cpu(setup.wLength) !=
 					urb-&gt;transfer_buffer_length) {
-				maybe_set_status (urb, -EOVERFLOW);
+				status = -EOVERFLOW;
 				goto return_urb;
 			}
 
@@ -1342,7 +1336,7 @@ static void dummy_timer (unsigned long _dum)
 				if (setup.bRequestType != Dev_Request)
 					break;
 				dum-&gt;address = w_value;
-				maybe_set_status (urb, 0);
+				status = 0;
 				dev_dbg (udc_dev(dum), "set_address = %d\n",
 						w_value);
 				value = 0;
@@ -1369,7 +1363,7 @@ static void dummy_timer (unsigned long _dum)
 					if (value == 0) {
 						dum-&gt;devstatus |=
 							(1 &lt;&lt; w_value);
-						maybe_set_status (urb, 0);
+						status = 0;
 					}
 
 				} else if (setup.bRequestType == Ep_Request) {
@@ -1381,7 +1375,7 @@ static void dummy_timer (unsigned long _dum)
 					}
 					ep2-&gt;halted = 1;
 					value = 0;
-					maybe_set_status (urb, 0);
+					status = 0;
 				}
 				break;
 			case USB_REQ_CLEAR_FEATURE:
@@ -1391,7 +1385,7 @@ static void dummy_timer (unsigned long _dum)
 						dum-&gt;devstatus &amp;= ~(1 &lt;&lt;
 							USB_DEVICE_REMOTE_WAKEUP);
 						value = 0;
-						maybe_set_status (urb, 0);
+						status = 0;
 						break;
 					default:
 						value = -EOPNOTSUPP;
@@ -1406,7 +1400,7 @@ static void dummy_timer (unsigned long _dum)
 					}
 					ep2-&gt;halted = 0;
 					value = 0;
-					maybe_set_status (urb, 0);
+					status = 0;
 				}
 				break;
 			case USB_REQ_GET_STATUS:
@@ -1443,7 +1437,7 @@ static void dummy_timer (unsigned long _dum)
 					urb-&gt;actual_length = min (2,
 						urb-&gt;transfer_buffer_length);
 					value = 0;
-					maybe_set_status (urb, 0);
+					status = 0;
 				}
 				break;
 			}
@@ -1470,7 +1464,7 @@ static void dummy_timer (unsigned long _dum)
 					dev_dbg (udc_dev(dum),
 						"setup --&gt; %d\n",
 						value);
-				maybe_set_status (urb, -EPIPE);
+				status = -EPIPE;
 				urb-&gt;actual_length = 0;
 			}
 
@@ -1487,7 +1481,7 @@ static void dummy_timer (unsigned long _dum)
 			 * report random errors, to debug drivers.
 			 */
 			limit = max (limit, periodic_bytes (dum, ep));
-			maybe_set_status (urb, -ENOSYS);
+			status = -ENOSYS;
 			break;
 
 		case PIPE_INTERRUPT:
@@ -1501,12 +1495,12 @@ static void dummy_timer (unsigned long _dum)
 		default:
 		treat_control_like_bulk:
 			ep-&gt;last_io = jiffies;
-			total = transfer (dum, urb, ep, limit);
+			total = transfer(dum, urb, ep, limit, &amp;status);
 			break;
 		}
 
 		/* incomplete transfer? */
-		if (urb-&gt;status == -EINPROGRESS)
+		if (status == -EINPROGRESS)
 			continue;
 
 return_urb:
@@ -1517,6 +1511,7 @@ static void dummy_timer (unsigned long _dum)
 
 		usb_hcd_unlink_urb_from_ep(dummy_to_hcd(dum), urb);
 		spin_unlock (&amp;dum-&gt;lock);
+		urb-&gt;status = status;
 		usb_hcd_giveback_urb (dummy_to_hcd(dum), urb);
 		spin_lock (&amp;dum-&gt;lock);
 </pre><hr><pre>commit 12943f097e5a4a0550f52f98ab8f476435e2ce15
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 16:27:50 2007 -0400

    USB: less-restrictive command checking in g-file-storage
    
    This patch (as983) makes a test for minimum-length command sizes in
    g_file_storage less restrictive.  It doesn't matter because commands
    with bad lengths will be detected later on anyway, and doing it like
    this makes the driver interoperable with certain buggy hosts such as
    the JVC HiFi (reported by Samuel Hangouet).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 9998cd7af418..0551140010ee 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -2964,7 +2964,7 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 
 	/* Is the CBW meaningful? */
 	if (cbw-&gt;Lun &gt;= MAX_LUNS || cbw-&gt;Flags &amp; ~USB_BULK_IN_FLAG ||
-			cbw-&gt;Length &lt; 6 || cbw-&gt;Length &gt; MAX_COMMAND_SIZE) {
+			cbw-&gt;Length &lt;= 0 || cbw-&gt;Length &gt; MAX_COMMAND_SIZE) {
 		DBG(fsg, "non-meaningful CBW: lun = %u, flags = 0x%x, "
 				"cmdlen %u\n",
 				cbw-&gt;Lun, cbw-&gt;Flags, cbw-&gt;Length);</pre><hr><pre>commit 6e8fe43b26085a64327d1cbb751ab895f3ad3f5d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 22 13:08:40 2007 -0400

    USB: avoid the donelist after an error in ohci-hcd
    
    This patch (as972) changes ohci-hcd so that after an error occurs, the
    remaining TDs for the URB will be skipped over entirely instead of
    going through the donelist.  This enables the driver to give back the
    URB as soon as the error is detected, avoiding the need to store the
    error status in urb-&gt;status.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 3c793fad178d..860e55ff67a1 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -783,10 +783,10 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 
 /*-------------------------------------------------------------------------*/
 
-static inline struct td *
-ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
+static void ed_halted(struct ohci_hcd *ohci, struct td *td, int cc)
 {
 	struct urb		*urb = td-&gt;urb;
+	urb_priv_t		*urb_priv = urb-&gt;hcpriv;
 	struct ed		*ed = td-&gt;ed;
 	struct list_head	*tmp = td-&gt;td_list.next;
 	__hc32			toggle = ed-&gt;hwHeadP &amp; cpu_to_hc32 (ohci, ED_C);
@@ -798,13 +798,12 @@ ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
 	wmb ();
 	ed-&gt;hwHeadP &amp;= ~cpu_to_hc32 (ohci, ED_H);
 
-	/* put any later tds from this urb onto the donelist, after 'td',
-	 * order won't matter here: no errors, and nothing was transferred.
-	 * also patch the ed so it looks as if those tds completed normally.
+	/* Get rid of all later tds from this urb.  We don't have
+	 * to be careful: no errors and nothing was transferred.
+	 * Also patch the ed so it looks as if those tds completed normally.
 	 */
 	while (tmp != &amp;ed-&gt;td_list) {
 		struct td	*next;
-		__hc32		info;
 
 		next = list_entry (tmp, struct td, td_list);
 		tmp = next-&gt;td_list.next;
@@ -819,14 +818,9 @@ ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
 		 * then we need to leave the control STATUS packet queued
 		 * and clear ED_SKIP.
 		 */
-		info = next-&gt;hwINFO;
-		info |= cpu_to_hc32 (ohci, TD_DONE);
-		info &amp;= ~cpu_to_hc32 (ohci, TD_CC);
-		next-&gt;hwINFO = info;
-
-		next-&gt;next_dl_td = rev;
-		rev = next;
 
+		list_del(&amp;next-&gt;td_list);
+		urb_priv-&gt;td_cnt++;
 		ed-&gt;hwHeadP = next-&gt;hwNextTD | toggle;
 	}
 
@@ -852,8 +846,6 @@ ed_halted (struct ohci_hcd *ohci, struct td *td, int cc, struct td *rev)
 			hc32_to_cpu (ohci, td-&gt;hwINFO),
 			cc, cc_to_error [cc]);
 	}
-
-	return rev;
 }
 
 /* replies to the request have to be on a FIFO basis so
@@ -890,7 +882,7 @@ static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
 		 */
 		if (cc != TD_CC_NOERROR
 				&amp;&amp; (td-&gt;ed-&gt;hwHeadP &amp; cpu_to_hc32 (ohci, ED_H)))
-			td_rev = ed_halted (ohci, td, cc, td_rev);
+			ed_halted(ohci, td, cc);
 
 		td-&gt;next_dl_td = td_rev;
 		td_rev = td;</pre><hr><pre>commit 1f5a3d0f34fd5719081c6b8f3dbbcbe328d4da31
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 22 13:06:53 2007 -0400

    USB: fix mistake in usb_hcd_giveback_urb
    
    This patch (as971) fixes a small mistake: The URB's completion status
    needs to be adjusted before the URB is passed to usmon_urb_complete(),
    not afterward.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index ec17fc4d2861..8b17babf5c55 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1266,9 +1266,6 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
-	unmap_urb_for_dma(hcd, urb);
-	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
-	usb_unanchor_urb(urb);
 	urb-&gt;hcpriv = NULL;
 	if (unlikely(urb-&gt;unlinked))
 		urb-&gt;status = urb-&gt;unlinked;
@@ -1277,6 +1274,10 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 			!urb-&gt;status))
 		urb-&gt;status = -EREMOTEIO;
 
+	unmap_urb_for_dma(hcd, urb);
+	usbmon_urb_complete(&amp;hcd-&gt;self, urb);
+	usb_unanchor_urb(urb);
+
 	/* pass ownership to the completion handler */
 	urb-&gt;complete (urb);
 	atomic_dec (&amp;urb-&gt;use_count);</pre><hr><pre>commit eb23105462304fd35571fd0cab1de7aec79a9ec5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 21 15:40:36 2007 -0400

    USB: add urb-&gt;unlinked field
    
    This patch (as970) adds a new urb-&gt;unlinked field, which is used to
    store the status of unlinked URBs since we can't use urb-&gt;status for
    that purpose any more.  To help simplify the HCDs, usbcore will check
    urb-&gt;unlinked before calling the completion handler; if the value is
    set it will automatically override the status reported by the HCD.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 22a098b318c0..ec17fc4d2861 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -532,8 +532,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);
-	if (urb-&gt;status == -EINPROGRESS)
-		urb-&gt;status = status;
+	urb-&gt;status = status;
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 	/* This peculiar use of spinlocks echoes what real HC drivers do.
@@ -1024,6 +1023,7 @@ int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 	switch (hcd-&gt;state) {
 	case HC_STATE_RUNNING:
 	case HC_STATE_RESUMING:
+		urb-&gt;unlinked = 0;
 		list_add_tail(&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
 		break;
 	default:
@@ -1071,9 +1071,9 @@ int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 	/* Any status except -EINPROGRESS means something already started to
 	 * unlink this URB from the hardware.  So there's no more work to do.
 	 */
-	if (urb-&gt;status != -EINPROGRESS)
+	if (urb-&gt;unlinked)
 		return -EBUSY;
-	urb-&gt;status = status;
+	urb-&gt;unlinked = status;
 
 	/* IRQ setup can easily be broken so that USB controllers
 	 * never get completion IRQs ... maybe even the ones we need to
@@ -1259,6 +1259,10 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
  * the device driver won't cause problems if it frees, modifies,
  * or resubmits this URB.
+ *
+ * If @urb was unlinked, the value of @urb-&gt;status will be overridden by
+ * @urb-&gt;unlinked.  Erroneous short transfers are detected in case
+ * the HCD hasn't checked for them.
  */
 void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 {
@@ -1266,7 +1270,9 @@ void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
 	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
 	usb_unanchor_urb(urb);
 	urb-&gt;hcpriv = NULL;
-	if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+	if (unlikely(urb-&gt;unlinked))
+		urb-&gt;status = urb-&gt;unlinked;
+	else if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
 			urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length &amp;&amp;
 			!urb-&gt;status))
 		urb-&gt;status = -EREMOTEIO;
@@ -1305,8 +1311,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	is_in;
 
-		/* the urb may already have been unlinked */
-		if (urb-&gt;status != -EINPROGRESS)
+		if (urb-&gt;unlinked)
 			continue;
 		usb_get_urb (urb);
 		is_in = usb_urb_dir_in(urb);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 0cb032526ca2..f2b124cf3206 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1029,8 +1029,7 @@ static int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 static void maybe_set_status (struct urb *urb, int status)
 {
 	spin_lock (&amp;urb-&gt;lock);
-	if (urb-&gt;status == -EINPROGRESS)
-		urb-&gt;status = status;
+	urb-&gt;status = status;
 	spin_unlock (&amp;urb-&gt;lock);
 }
 
@@ -1257,10 +1256,9 @@ static void dummy_timer (unsigned long _dum)
 		int			type;
 
 		urb = urbp-&gt;urb;
-		if (urb-&gt;status != -EINPROGRESS) {
-			/* likely it was just unlinked */
+		if (urb-&gt;unlinked)
 			goto return_urb;
-		} else if (dum-&gt;rh_state != DUMMY_RH_RUNNING)
+		else if (dum-&gt;rh_state != DUMMY_RH_RUNNING)
 			continue;
 		type = usb_pipetype (urb-&gt;pipe);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index e80b5c417d74..a8f5408c161d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -151,7 +151,7 @@ static void qtd_copy_status (
 		urb-&gt;actual_length += length - QTD_LENGTH (token);
 
 	/* don't modify error codes */
-	if (unlikely (urb-&gt;status != -EINPROGRESS))
+	if (unlikely(urb-&gt;unlinked))
 		return;
 
 	/* force cleanup after short read; not always an error */
@@ -232,21 +232,14 @@ __acquires(ehci-&gt;lock)
 	}
 
 	spin_lock (&amp;urb-&gt;lock);
-	switch (urb-&gt;status) {
-	case -EINPROGRESS:		/* success */
-		urb-&gt;status = 0;
-	default:			/* fault */
-		COUNT (ehci-&gt;stats.complete);
-		break;
-	case -EREMOTEIO:		/* fault or normal */
-		if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))
+	if (unlikely(urb-&gt;unlinked)) {
+		COUNT(ehci-&gt;stats.unlink);
+	} else {
+		if (likely(urb-&gt;status == -EINPROGRESS ||
+				(urb-&gt;status == -EREMOTEIO &amp;&amp;
+				 !(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))))
 			urb-&gt;status = 0;
-		COUNT (ehci-&gt;stats.complete);
-		break;
-	case -ECONNRESET:		/* canceled */
-	case -ENOENT:
-		COUNT (ehci-&gt;stats.unlink);
-		break;
+		COUNT(ehci-&gt;stats.complete);
 	}
 	spin_unlock (&amp;urb-&gt;lock);
 
@@ -364,7 +357,8 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 * for the urb faulted (including short read) or
 			 * its urb was canceled.  we may patch qh or qtds.
 			 */
-			if (likely (urb-&gt;status == -EINPROGRESS))
+			if (likely(urb-&gt;status == -EINPROGRESS &amp;&amp;
+					!urb-&gt;unlinked))
 				continue;
 
 			/* issue status after short control reads */
@@ -395,7 +389,8 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		spin_lock (&amp;urb-&gt;lock);
 		qtd_copy_status (ehci, urb, qtd-&gt;length, token);
 		if (unlikely(urb-&gt;status == -EREMOTEIO)) {
-			do_status = usb_pipecontrol(urb-&gt;pipe);
+			do_status = (!urb-&gt;unlinked &amp;&amp;
+					usb_pipecontrol(urb-&gt;pipe));
 			urb-&gt;status = 0;
 		}
 		spin_unlock (&amp;urb-&gt;lock);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index c2919dbc3f54..35b3507ff401 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -455,11 +455,10 @@ static void postproc_atl_queue(struct isp116x *isp116x)
  done:
 		if (status != -EINPROGRESS) {
 			spin_lock(&amp;urb-&gt;lock);
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = status;
+			urb-&gt;status = status;
 			spin_unlock(&amp;urb-&gt;lock);
 		}
-		if (urb-&gt;status != -EINPROGRESS)
+		if (urb-&gt;status != -EINPROGRESS || urb-&gt;unlinked)
 			finish_request(isp116x, ep, urb);
 	}
 }
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 8aad6199cdcc..3c793fad178d 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -758,8 +758,7 @@ static void td_done (struct ohci_hcd *ohci, struct urb *urb, struct td *td)
 			cc = TD_CC_NOERROR;
 		if (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E) {
 			spin_lock (&amp;urb-&gt;lock);
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = cc_to_error [cc];
+			urb-&gt;status = cc_to_error[cc];
 			spin_unlock (&amp;urb-&gt;lock);
 		}
 
@@ -972,7 +971,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			urb = td-&gt;urb;
 			urb_priv = td-&gt;urb-&gt;hcpriv;
 
-			if (urb-&gt;status == -EINPROGRESS) {
+			if (!urb-&gt;unlinked) {
 				prev = &amp;td-&gt;hwNextTD;
 				continue;
 			}
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index 60248b01ce14..98b9e0547544 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -1118,7 +1118,7 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 	r8a66597-&gt;timeout_map &amp;= ~(1 &lt;&lt; pipenum);
 
 	if (likely(td)) {
-		if (td-&gt;set_address &amp;&amp; urb-&gt;status != 0)
+		if (td-&gt;set_address &amp;&amp; (urb-&gt;status != 0 || urb-&gt;unlinked))
 			r8a66597-&gt;address_map &amp;= ~(1 &lt;&lt; urb-&gt;setup_packet[2]);
 
 		pipe_toggle_save(r8a66597, td-&gt;pipe, urb);
@@ -1225,8 +1225,7 @@ static void packet_read(struct r8a66597 *r8a66597, u16 pipenum)
 	}
 
 	if (finish &amp;&amp; pipenum != 0) {
-		if (td-&gt;urb-&gt;status == -EINPROGRESS)
-			td-&gt;urb-&gt;status = status;
+		td-&gt;urb-&gt;status = status;
 		finish_request(r8a66597, td, pipenum, urb);
 	}
 }
@@ -1308,32 +1307,24 @@ static void check_next_phase(struct r8a66597 *r8a66597)
 	switch (td-&gt;type) {
 	case USB_PID_IN:
 	case USB_PID_OUT:
-		if (urb-&gt;status != -EINPROGRESS) {
-			finish = 1;
-			break;
-		}
 		if (check_transfer_finish(td, urb))
 			td-&gt;type = USB_PID_ACK;
 		break;
 	case USB_PID_SETUP:
-		if (urb-&gt;status != -EINPROGRESS)
-			finish = 1;
-		else if (urb-&gt;transfer_buffer_length == urb-&gt;actual_length) {
+		if (urb-&gt;transfer_buffer_length == urb-&gt;actual_length)
 			td-&gt;type = USB_PID_ACK;
-			urb-&gt;status = 0;
-		} else if (usb_pipeout(urb-&gt;pipe))
+		else if (usb_pipeout(urb-&gt;pipe))
 			td-&gt;type = USB_PID_OUT;
 		else
 			td-&gt;type = USB_PID_IN;
 		break;
 	case USB_PID_ACK:
 		finish = 1;
-		if (urb-&gt;status == -EINPROGRESS)
-			urb-&gt;status = 0;
+		urb-&gt;status = 0;
 		break;
 	}
 
-	if (finish)
+	if (finish || urb-&gt;unlinked)
 		finish_request(r8a66597, td, 0, urb);
 	else
 		start_transfer(r8a66597, td);
@@ -1418,8 +1409,7 @@ static void irq_pipe_empty(struct r8a66597 *r8a66597)
 			if ((tmp &amp; INBUFM) == 0) {
 				disable_irq_empty(r8a66597, pipenum);
 				pipe_irq_disable(r8a66597, pipenum);
-				if (td-&gt;urb-&gt;status == -EINPROGRESS)
-					td-&gt;urb-&gt;status = 0;
+				td-&gt;urb-&gt;status = 0;
 				finish_request(r8a66597, td, pipenum, td-&gt;urb);
 			}
 		}
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index e90953a9c9fb..f0fa94148d9d 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -436,8 +436,7 @@ static void finish_request(
 		ep-&gt;nextpid = USB_PID_SETUP;
 
 	spin_lock(&amp;urb-&gt;lock);
-	if (urb-&gt;status == -EINPROGRESS)
-		urb-&gt;status = status;
+	urb-&gt;status = status;
 	spin_unlock(&amp;urb-&gt;lock);
 
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
@@ -598,7 +597,7 @@ done(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)
 				bank, status, ep, urbstat);
 	}
 
-	if (urb &amp;&amp; (urbstat != -EINPROGRESS || urb-&gt;status != -EINPROGRESS))
+	if (urb &amp;&amp; (urbstat != -EINPROGRESS || urb-&gt;unlinked))
 		finish_request(sl811, ep, urb, urbstat);
 }
 
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 1381275d448f..db800a434b83 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -645,12 +645,12 @@ static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer + urb-&gt;actual_length;
                 u8 *b = buf;
@@ -716,8 +716,8 @@ static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -744,12 +744,12 @@ static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 urb-&gt;actual_length += len;
                 endp-&gt;toggle_bits = toggle_bits;
@@ -768,8 +768,8 @@ static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -797,12 +797,12 @@ static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer + urb-&gt;actual_length;
                 u8 *b = buf;
@@ -871,8 +871,8 @@ static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -898,18 +898,18 @@ static void u132_hcd_configure_empty_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -936,12 +936,12 @@ static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer;
                 u8 *b = buf;
@@ -980,8 +980,8 @@ static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1007,18 +1007,18 @@ static void u132_hcd_configure_empty_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1045,12 +1045,12 @@ static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 if (usb_pipein(urb-&gt;pipe)) {
                         int retval;
                         struct u132_ring *ring = endp-&gt;ring;
@@ -1077,8 +1077,8 @@ static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
                         return;
                 }
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1106,20 +1106,20 @@ static void u132_hcd_enumeration_empty_recv(void *data, struct urb *urb,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 u132-&gt;addr[0].address = 0;
                 endp-&gt;usb_addr = udev-&gt;usb_addr;
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1145,12 +1145,12 @@ static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 int retval;
                 struct u132_ring *ring = endp-&gt;ring;
                 up(&amp;u132-&gt;scheduler_lock);
@@ -1162,8 +1162,8 @@ static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
                         u132_hcd_giveback_urb(u132, endp, urb, retval);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1189,18 +1189,18 @@ static void u132_hcd_initial_empty_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1227,12 +1227,12 @@ static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 int retval;
                 struct u132_ring *ring = endp-&gt;ring;
                 u8 *u = urb-&gt;transfer_buffer;
@@ -1251,8 +1251,8 @@ static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
                         u132_hcd_giveback_urb(u132, endp, urb, retval);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -1279,12 +1279,12 @@ static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
                 u132_hcd_giveback_urb(u132, endp, urb, -EINTR);
                 return;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, -ENODEV);
                 return;
-        } else if (urb-&gt;status == -EINPROGRESS) {
+	} else if (!urb-&gt;unlinked) {
                 int retval;
                 struct u132_ring *ring = endp-&gt;ring;
                 up(&amp;u132-&gt;scheduler_lock);
@@ -1296,8 +1296,8 @@ static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
                         u132_hcd_giveback_urb(u132, endp, urb, retval);
                 return;
         } else {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p statu"
-                        "s=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
+				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
                 u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
                 return;
@@ -2279,8 +2279,8 @@ static int u132_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,
                         , u132-&gt;going);
                 return -ENODEV;
         } else if (u132-&gt;going &gt; 0) {
-                dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed urb="
-                        "%p status=%d\n", urb, urb-&gt;status);
+		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed "
+				"urb=%p\n", urb);
                 return -ESHUTDOWN;
         } else {
                 u8 usb_addr = usb_pipedevice(urb-&gt;pipe);
diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 1497371583b9..20cc58b97807 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -120,8 +120,8 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	out += sprintf(out, "%s%s", ptype, (urbp-&gt;fsbr ? " FSBR" : ""));
 	out += sprintf(out, " Actlen=%d", urbp-&gt;urb-&gt;actual_length);
 
-	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
-		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
+	if (urbp-&gt;urb-&gt;unlinked)
+		out += sprintf(out, " Unlinked=%d", urbp-&gt;urb-&gt;unlinked);
 	out += sprintf(out, "\n");
 
 	i = nactive = ninactive = 0;
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index fbc3af392c26..bab567266559 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1557,15 +1557,12 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 			break;
 
 		spin_lock(&amp;urb-&gt;lock);
-		if (urb-&gt;status == -EINPROGRESS)	/* Not dequeued */
-			urb-&gt;status = status;
-		else
-			status = ECONNRESET;		/* Not -ECONNRESET */
+		urb-&gt;status = status;
 		spin_unlock(&amp;urb-&gt;lock);
 
 		/* Dequeued but completed URBs can't be given back unless
 		 * the QH is stopped or has finished unlinking. */
-		if (status == ECONNRESET) {
+		if (urb-&gt;unlinked) {
 			if (QH_FINISHED_UNLINKING(qh))
 				qh-&gt;is_stopped = 1;
 			else if (!qh-&gt;is_stopped)
@@ -1588,7 +1585,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 restart:
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
-		if (urb-&gt;status != -EINPROGRESS) {
+		if (urb-&gt;unlinked) {
 
 			/* Fix up the TD links and save the toggles for
 			 * non-Isochronous queues.  For Isochronous queues,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 92d63c6b6fc6..5c7b79088add 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1245,6 +1245,7 @@ struct urb
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
+	int unlinked;			/* unlink error code */
 
 	/* public: documented fields in the urb that can be used by drivers */
 	struct list_head urb_list;	/* list head for use by the urb's</pre>
    <div class="pagination">
        <a href='2_100.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><span>[101]</span><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_102.html'>Next&gt;&gt;</a>
    <div>
</body>
