<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_38.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><span>[39]</span><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_40.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1f69f172c73a2bf0bf55da9346da8dccea9035cf
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Nov 15 17:06:58 2007 -0500

    nfsd: minor fs/nfsd/auth.h cleanup
    
    While we're here, let's remove the redundant (and now wrong) pathname in
    the comment, and the #ifdef __KERNEL__'s.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/auth.h b/fs/nfsd/auth.h
index 0fb9f7212195..78b3c0e93822 100644
--- a/fs/nfsd/auth.h
+++ b/fs/nfsd/auth.h
@@ -1,6 +1,4 @@
 /*
- * include/linux/nfsd/auth.h
- *
  * nfsd-specific authentication stuff.
  * uid/gid mapping not yet implemented.
  *
@@ -10,8 +8,6 @@
 #ifndef LINUX_NFSD_AUTH_H
 #define LINUX_NFSD_AUTH_H
 
-#ifdef __KERNEL__
-
 #define nfsd_luid(rq, uid)	((u32)(uid))
 #define nfsd_lgid(rq, gid)	((u32)(gid))
 #define nfsd_ruid(rq, uid)	((u32)(uid))
@@ -23,5 +19,4 @@
  */
 int nfsd_setuser(struct svc_rqst *, struct svc_export *);
 
-#endif /* __KERNEL__ */
 #endif /* LINUX_NFSD_AUTH_H */</pre><hr><pre>commit 2e8138a274d81d87591db0803b1e81f4284ff935
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Nov 15 17:05:43 2007 -0500

    nfsd: move nfsd/auth.h into fs/nfsd
    
    This header is used only in a few places in fs/nfsd, so there seems to
    be little point to having it in include/.  (Thanks to Robert Day for
    pointing this out.)
    
    Cc: Robert P. J. Day &lt;rpjday@crashcourse.ca&gt;
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/include/linux/nfsd/auth.h b/fs/nfsd/auth.h
similarity index 100%
rename from include/linux/nfsd/auth.h
rename to fs/nfsd/auth.h
diff --git a/fs/nfsd/nfs3xdr.c b/fs/nfsd/nfs3xdr.c
index be515c5a8154..4b1ffe3be7e2 100644
--- a/fs/nfsd/nfs3xdr.c
+++ b/fs/nfsd/nfs3xdr.c
@@ -21,6 +21,7 @@
 #include &lt;linux/sunrpc/svc.h&gt;
 #include &lt;linux/nfsd/nfsd.h&gt;
 #include &lt;linux/nfsd/xdr3.h&gt;
+#include "auth.h"
 
 #define NFSDDBG_FACILITY		NFSDDBG_XDR
 
diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index 468f17a78441..8fbd2dc08a92 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -22,6 +22,7 @@
 #include &lt;linux/sunrpc/svc.h&gt;
 #include &lt;linux/sunrpc/svcauth_gss.h&gt;
 #include &lt;linux/nfsd/nfsd.h&gt;
+#include "auth.h"
 
 #define NFSDDBG_FACILITY		NFSDDBG_FH
 
diff --git a/fs/nfsd/nfsxdr.c b/fs/nfsd/nfsxdr.c
index 7003c313272f..61ad61743d94 100644
--- a/fs/nfsd/nfsxdr.c
+++ b/fs/nfsd/nfsxdr.c
@@ -15,6 +15,7 @@
 #include &lt;linux/nfsd/nfsd.h&gt;
 #include &lt;linux/nfsd/xdr.h&gt;
 #include &lt;linux/mm.h&gt;
+#include "auth.h"
 
 #define NFSDDBG_FACILITY		NFSDDBG_XDR
 
diff --git a/include/linux/nfsd/Kbuild b/include/linux/nfsd/Kbuild
index d9c5455808e5..e726fc3a4375 100644
--- a/include/linux/nfsd/Kbuild
+++ b/include/linux/nfsd/Kbuild
@@ -4,4 +4,3 @@ unifdef-y += stats.h
 unifdef-y += syscall.h
 unifdef-y += nfsfh.h
 unifdef-y += debug.h
-unifdef-y += auth.h
diff --git a/include/linux/nfsd/nfsd.h b/include/linux/nfsd/nfsd.h
index a51a30f30cee..8caf4c4f64e6 100644
--- a/include/linux/nfsd/nfsd.h
+++ b/include/linux/nfsd/nfsd.h
@@ -20,7 +20,6 @@
 #include &lt;linux/nfsd/debug.h&gt;
 #include &lt;linux/nfsd/nfsfh.h&gt;
 #include &lt;linux/nfsd/export.h&gt;
-#include &lt;linux/nfsd/auth.h&gt;
 #include &lt;linux/nfsd/stats.h&gt;
 /*
  * nfsd version
diff --git a/include/linux/nfsd/syscall.h b/include/linux/nfsd/syscall.h
index 8bcddccb6c42..4e439765b705 100644
--- a/include/linux/nfsd/syscall.h
+++ b/include/linux/nfsd/syscall.h
@@ -18,7 +18,6 @@
 #include &lt;linux/nfsd/const.h&gt;
 #include &lt;linux/nfsd/export.h&gt;
 #include &lt;linux/nfsd/nfsfh.h&gt;
-#include &lt;linux/nfsd/auth.h&gt;
 
 /*
  * Version of the syscall interface</pre><hr><pre>commit dbf847ecb6318d3a22c6758fe39696d00f39063a
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Nov 8 17:20:34 2007 -0500

    knfsd: allow cache_register to return error on failure
    
    Newer server features such as nfsv4 and gss depend on proc to work, so a
    failure to initialize the proc files they need should be treated as
    fatal.
    
    Thanks to Andrew Morton for style fix and compile fix in case where
    CONFIG_NFSD_V4 is undefined.
    
    Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index d29b70a28f2b..cbbc594ef592 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -1637,13 +1637,19 @@ exp_verify_string(char *cp, int max)
 /*
  * Initialize the exports module.
  */
-void
+int
 nfsd_export_init(void)
 {
+	int rv;
 	dprintk("nfsd: initializing export module.\n");
 
-	cache_register(&amp;svc_export_cache);
-	cache_register(&amp;svc_expkey_cache);
+	rv = cache_register(&amp;svc_export_cache);
+	if (rv)
+		return rv;
+	rv = cache_register(&amp;svc_expkey_cache);
+	if (rv)
+		cache_unregister(&amp;svc_export_cache);
+	return rv;
 
 }
 
diff --git a/fs/nfsd/nfs4idmap.c b/fs/nfsd/nfs4idmap.c
index ef22179c49ad..996bd88b75ba 100644
--- a/fs/nfsd/nfs4idmap.c
+++ b/fs/nfsd/nfs4idmap.c
@@ -464,11 +464,18 @@ nametoid_update(struct ent *new, struct ent *old)
  * Exported API
  */
 
-void
+int
 nfsd_idmap_init(void)
 {
-	cache_register(&amp;idtoname_cache);
-	cache_register(&amp;nametoid_cache);
+	int rv;
+
+	rv = cache_register(&amp;idtoname_cache);
+	if (rv)
+		return rv;
+	rv = cache_register(&amp;nametoid_cache);
+	if (rv)
+		cache_unregister(&amp;idtoname_cache);
+	return rv;
 }
 
 void
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index 2b95597aa4a5..4aba92698581 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -707,9 +707,13 @@ static int __init init_nfsd(void)
 	retval = nfsd_reply_cache_init();
 	if (retval)
 		goto out_free_stat;
-	nfsd_export_init();	/* Exports table */
+	retval = nfsd_export_init();
+	if (retval)
+		goto out_free_cache;
 	nfsd_lockd_init();	/* lockd-&gt;nfsd callbacks */
-	nfsd_idmap_init();      /* Name to ID mapping */
+	retval = nfsd_idmap_init();
+	if (retval)
+		goto out_free_lockd;
 	retval = create_proc_exports_entry();
 	if (retval)
 		goto out_free_idmap;
@@ -720,10 +724,12 @@ static int __init init_nfsd(void)
 out_free_all:
 	remove_proc_entry("fs/nfs/exports", NULL);
 	remove_proc_entry("fs/nfs", NULL);
-	nfsd_idmap_shutdown();
 out_free_idmap:
+	nfsd_idmap_shutdown();
+out_free_lockd:
 	nfsd_lockd_shutdown();
 	nfsd_export_shutdown();
+out_free_cache:
 	nfsd_reply_cache_shutdown();
 out_free_stat:
 	nfsd_stat_shutdown();
diff --git a/include/linux/nfsd/export.h b/include/linux/nfsd/export.h
index bcb7abafbca9..3a1687251367 100644
--- a/include/linux/nfsd/export.h
+++ b/include/linux/nfsd/export.h
@@ -122,7 +122,7 @@ __be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp);
 /*
  * Function declarations
  */
-void			nfsd_export_init(void);
+int			nfsd_export_init(void);
 void			nfsd_export_shutdown(void);
 void			nfsd_export_flush(void);
 void			exp_readlock(void);
diff --git a/include/linux/nfsd_idmap.h b/include/linux/nfsd_idmap.h
index e82746fcad14..d4a2ac18bd4c 100644
--- a/include/linux/nfsd_idmap.h
+++ b/include/linux/nfsd_idmap.h
@@ -44,11 +44,16 @@
 #define IDMAP_NAMESZ 128
 
 #ifdef CONFIG_NFSD_V4
-void nfsd_idmap_init(void);
+int nfsd_idmap_init(void);
 void nfsd_idmap_shutdown(void);
 #else
-static inline void nfsd_idmap_init(void) {};
-static inline void nfsd_idmap_shutdown(void) {};
+static inline int nfsd_idmap_init(void)
+{
+	return 0;
+}
+static inline void nfsd_idmap_shutdown(void)
+{
+}
 #endif
 
 int nfsd_map_name_to_uid(struct svc_rqst *, const char *, size_t, __u32 *);
diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index b683b5ddeea9..03547d6abee5 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -169,7 +169,7 @@ extern int cache_check(struct cache_detail *detail,
 extern void cache_flush(void);
 extern void cache_purge(struct cache_detail *detail);
 #define NEVER (0x7FFFFFFF)
-extern void cache_register(struct cache_detail *cd);
+extern int cache_register(struct cache_detail *cd);
 extern void cache_unregister(struct cache_detail *cd);
 
 extern void qword_add(char **bpp, int *lp, char *str);
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index d329a12500aa..aa790bb4f7a1 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -1386,10 +1386,19 @@ int
 gss_svc_init(void)
 {
 	int rv = svc_auth_register(RPC_AUTH_GSS, &amp;svcauthops_gss);
-	if (rv == 0) {
-		cache_register(&amp;rsc_cache);
-		cache_register(&amp;rsi_cache);
-	}
+	if (rv)
+		return rv;
+	rv = cache_register(&amp;rsc_cache);
+	if (rv)
+		goto out1;
+	rv = cache_register(&amp;rsi_cache);
+	if (rv)
+		goto out2;
+	return 0;
+out2:
+	cache_unregister(&amp;rsc_cache);
+out1:
+	svc_auth_unregister(RPC_AUTH_GSS);
 	return rv;
 }
 
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index f41a7cc4cf62..50b1a8b441fe 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -304,20 +304,21 @@ static void remove_cache_proc_entries(struct cache_detail *cd)
 	remove_proc_entry(cd-&gt;name, proc_net_rpc);
 }
 
-static void create_cache_proc_entries(struct cache_detail *cd)
+#ifdef CONFIG_PROC_FS
+static int create_cache_proc_entries(struct cache_detail *cd)
 {
 	struct proc_dir_entry *p;
 
 	cd-&gt;proc_ent = proc_mkdir(cd-&gt;name, proc_net_rpc);
 	if (cd-&gt;proc_ent == NULL)
-		return;
+		goto out_nomem;
 	cd-&gt;proc_ent-&gt;owner = cd-&gt;owner;
 	cd-&gt;channel_ent = cd-&gt;content_ent = NULL;
 
 	p = create_proc_entry("flush", S_IFREG|S_IRUSR|S_IWUSR, cd-&gt;proc_ent);
 	cd-&gt;flush_ent = p;
 	if (p == NULL)
-		return;
+		goto out_nomem;
 	p-&gt;proc_fops = &amp;cache_flush_operations;
 	p-&gt;owner = cd-&gt;owner;
 	p-&gt;data = cd;
@@ -327,7 +328,7 @@ static void create_cache_proc_entries(struct cache_detail *cd)
 				      cd-&gt;proc_ent);
 		cd-&gt;channel_ent = p;
 		if (p == NULL)
-			return;
+			goto out_nomem;
 		p-&gt;proc_fops = &amp;cache_file_operations;
 		p-&gt;owner = cd-&gt;owner;
 		p-&gt;data = cd;
@@ -337,16 +338,30 @@ static void create_cache_proc_entries(struct cache_detail *cd)
 				      cd-&gt;proc_ent);
 		cd-&gt;content_ent = p;
 		if (p == NULL)
-			return;
+			goto out_nomem;
 		p-&gt;proc_fops = &amp;content_file_operations;
 		p-&gt;owner = cd-&gt;owner;
 		p-&gt;data = cd;
 	}
+	return 0;
+out_nomem:
+	remove_cache_proc_entries(cd);
+	return -ENOMEM;
 }
+#else /* CONFIG_PROC_FS */
+static int create_cache_proc_entries(struct cache_detail *cd)
+{
+	return 0;
+}
+#endif
 
-void cache_register(struct cache_detail *cd)
+int cache_register(struct cache_detail *cd)
 {
-	create_cache_proc_entries(cd);
+	int ret;
+
+	ret = create_cache_proc_entries(cd);
+	if (ret)
+		return ret;
 	rwlock_init(&amp;cd-&gt;hash_lock);
 	INIT_LIST_HEAD(&amp;cd-&gt;queue);
 	spin_lock(&amp;cache_list_lock);
@@ -360,6 +375,7 @@ void cache_register(struct cache_detail *cd)
 
 	/* start the cleaning process */
 	schedule_delayed_work(&amp;cache_cleaner, 0);
+	return 0;
 }
 
 void cache_unregister(struct cache_detail *cd)</pre><hr><pre>commit ffe9386b6e08e7132cb7730025d0ea310e08a182
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Nov 12 17:04:29 2007 -0500

    nfsd: move cache proc (un)registration to separate function
    
    Just some minor cleanup.
    
    Also I don't see much point in trying to register further proc entries
    if initial entries fail; so just stop trying in that case.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index 365586a999ea..f41a7cc4cf62 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -290,44 +290,63 @@ static const struct file_operations cache_flush_operations;
 static void do_cache_clean(struct work_struct *work);
 static DECLARE_DELAYED_WORK(cache_cleaner, do_cache_clean);
 
-void cache_register(struct cache_detail *cd)
+static void remove_cache_proc_entries(struct cache_detail *cd)
 {
-	cd-&gt;proc_ent = proc_mkdir(cd-&gt;name, proc_net_rpc);
-	if (cd-&gt;proc_ent) {
-		struct proc_dir_entry *p;
-		cd-&gt;proc_ent-&gt;owner = cd-&gt;owner;
-		cd-&gt;channel_ent = cd-&gt;content_ent = NULL;
+	if (cd-&gt;proc_ent == NULL)
+		return;
+	if (cd-&gt;flush_ent)
+		remove_proc_entry("flush", cd-&gt;proc_ent);
+	if (cd-&gt;channel_ent)
+		remove_proc_entry("channel", cd-&gt;proc_ent);
+	if (cd-&gt;content_ent)
+		remove_proc_entry("content", cd-&gt;proc_ent);
+	cd-&gt;proc_ent = NULL;
+	remove_proc_entry(cd-&gt;name, proc_net_rpc);
+}
 
-		p = create_proc_entry("flush", S_IFREG|S_IRUSR|S_IWUSR,
-				      cd-&gt;proc_ent);
-		cd-&gt;flush_ent =  p;
-		if (p) {
-			p-&gt;proc_fops = &amp;cache_flush_operations;
-			p-&gt;owner = cd-&gt;owner;
-			p-&gt;data = cd;
-		}
+static void create_cache_proc_entries(struct cache_detail *cd)
+{
+	struct proc_dir_entry *p;
 
-		if (cd-&gt;cache_request || cd-&gt;cache_parse) {
-			p = create_proc_entry("channel", S_IFREG|S_IRUSR|S_IWUSR,
-					      cd-&gt;proc_ent);
-			cd-&gt;channel_ent = p;
-			if (p) {
-				p-&gt;proc_fops = &amp;cache_file_operations;
-				p-&gt;owner = cd-&gt;owner;
-				p-&gt;data = cd;
-			}
-		}
-		if (cd-&gt;cache_show) {
-			p = create_proc_entry("content", S_IFREG|S_IRUSR|S_IWUSR,
-					      cd-&gt;proc_ent);
-			cd-&gt;content_ent = p;
-			if (p) {
-				p-&gt;proc_fops = &amp;content_file_operations;
-				p-&gt;owner = cd-&gt;owner;
-				p-&gt;data = cd;
-			}
-		}
+	cd-&gt;proc_ent = proc_mkdir(cd-&gt;name, proc_net_rpc);
+	if (cd-&gt;proc_ent == NULL)
+		return;
+	cd-&gt;proc_ent-&gt;owner = cd-&gt;owner;
+	cd-&gt;channel_ent = cd-&gt;content_ent = NULL;
+
+	p = create_proc_entry("flush", S_IFREG|S_IRUSR|S_IWUSR, cd-&gt;proc_ent);
+	cd-&gt;flush_ent = p;
+	if (p == NULL)
+		return;
+	p-&gt;proc_fops = &amp;cache_flush_operations;
+	p-&gt;owner = cd-&gt;owner;
+	p-&gt;data = cd;
+
+	if (cd-&gt;cache_request || cd-&gt;cache_parse) {
+		p = create_proc_entry("channel", S_IFREG|S_IRUSR|S_IWUSR,
+				      cd-&gt;proc_ent);
+		cd-&gt;channel_ent = p;
+		if (p == NULL)
+			return;
+		p-&gt;proc_fops = &amp;cache_file_operations;
+		p-&gt;owner = cd-&gt;owner;
+		p-&gt;data = cd;
+	}
+	if (cd-&gt;cache_show) {
+		p = create_proc_entry("content", S_IFREG|S_IRUSR|S_IWUSR,
+				      cd-&gt;proc_ent);
+		cd-&gt;content_ent = p;
+		if (p == NULL)
+			return;
+		p-&gt;proc_fops = &amp;content_file_operations;
+		p-&gt;owner = cd-&gt;owner;
+		p-&gt;data = cd;
 	}
+}
+
+void cache_register(struct cache_detail *cd)
+{
+	create_cache_proc_entries(cd);
 	rwlock_init(&amp;cd-&gt;hash_lock);
 	INIT_LIST_HEAD(&amp;cd-&gt;queue);
 	spin_lock(&amp;cache_list_lock);
@@ -358,17 +377,7 @@ void cache_unregister(struct cache_detail *cd)
 	list_del_init(&amp;cd-&gt;others);
 	write_unlock(&amp;cd-&gt;hash_lock);
 	spin_unlock(&amp;cache_list_lock);
-	if (cd-&gt;proc_ent) {
-		if (cd-&gt;flush_ent)
-			remove_proc_entry("flush", cd-&gt;proc_ent);
-		if (cd-&gt;channel_ent)
-			remove_proc_entry("channel", cd-&gt;proc_ent);
-		if (cd-&gt;content_ent)
-			remove_proc_entry("content", cd-&gt;proc_ent);
-
-		cd-&gt;proc_ent = NULL;
-		remove_proc_entry(cd-&gt;name, proc_net_rpc);
-	}
+	remove_cache_proc_entries(cd);
 	if (list_empty(&amp;cache_list)) {
 		/* module must be being unloaded so its safe to kill the worker */
 		cancel_delayed_work_sync(&amp;cache_cleaner);</pre><hr><pre>commit e331f606a85a2a9e84e9c63c94d43c0517136139
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Nov 12 17:32:21 2007 -0500

    nfsd: fail init on /proc/fs/nfs/exports creation failure
    
    I assume the reason failure of creation was ignored here was just to
    continue support embedded systems that want nfsd but not proc.
    
    However, in cases where proc is supported it would be clearer to fail
    entirely than to come up with some features disabled.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index 2bfda9b8f504..2b95597aa4a5 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -674,6 +674,27 @@ static struct file_system_type nfsd_fs_type = {
 	.kill_sb	= kill_litter_super,
 };
 
+#ifdef CONFIG_PROC_FS
+static int create_proc_exports_entry(void)
+{
+	struct proc_dir_entry *entry;
+
+	entry = proc_mkdir("fs/nfs", NULL);
+	if (!entry)
+		return -ENOMEM;
+	entry = create_proc_entry("fs/nfs/exports", 0, NULL);
+	if (!entry)
+		return -ENOMEM;
+	entry-&gt;proc_fops =  &amp;exports_operations;
+	return 0;
+}
+#else /* CONFIG_PROC_FS */
+static int create_proc_exports_entry(void)
+{
+	return 0;
+}
+#endif
+
 static int __init init_nfsd(void)
 {
 	int retval;
@@ -689,23 +710,21 @@ static int __init init_nfsd(void)
 	nfsd_export_init();	/* Exports table */
 	nfsd_lockd_init();	/* lockd-&gt;nfsd callbacks */
 	nfsd_idmap_init();      /* Name to ID mapping */
-	if (proc_mkdir("fs/nfs", NULL)) {
-		struct proc_dir_entry *entry;
-		entry = create_proc_entry("fs/nfs/exports", 0, NULL);
-		if (entry)
-			entry-&gt;proc_fops =  &amp;exports_operations;
-	}
+	retval = create_proc_exports_entry();
+	if (retval)
+		goto out_free_idmap;
 	retval = register_filesystem(&amp;nfsd_fs_type);
 	if (retval)
 		goto out_free_all;
 	return 0;
 out_free_all:
-	nfsd_idmap_shutdown();
-	nfsd_export_shutdown();
-	nfsd_reply_cache_shutdown();
 	remove_proc_entry("fs/nfs/exports", NULL);
 	remove_proc_entry("fs/nfs", NULL);
+	nfsd_idmap_shutdown();
+out_free_idmap:
 	nfsd_lockd_shutdown();
+	nfsd_export_shutdown();
+	nfsd_reply_cache_shutdown();
 out_free_stat:
 	nfsd_stat_shutdown();
 	nfsd4_free_slabs();</pre><hr><pre>commit 440bcc592052e42c7050a51489c65e18df4a0636
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Nov 12 17:09:49 2007 -0500

    nfsd: select CONFIG_PROC_FS in nfsv4 and gss server cases
    
    The server depends on upcalls under /proc to support nfsv4 and gss.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/Kconfig b/fs/Kconfig
index 219ec06a8c7e..987b5d7cb21a 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -1674,6 +1674,8 @@ config NFSD
 	select CRYPTO_MD5 if NFSD_V4
 	select CRYPTO if NFSD_V4
 	select FS_POSIX_ACL if NFSD_V4
+	select PROC_FS if NFSD_V4
+	select PROC_FS if SUNRPC_GSS
 	help
 	  If you want your Linux box to act as an NFS *server*, so that other
 	  computers on your local network which support NFS can access certain</pre><hr><pre>commit df95a9d4fb91d819d3fb55dd437056df59e7f15e
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Nov 8 16:09:59 2007 -0500

    knfsd: cache unregistration needn't return error
    
    There's really nothing much the caller can do if cache unregistration
    fails.  And indeed, all any caller does in this case is print an error
    and continue.  So just return void and move the printk's inside
    cache_unregister.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index 66d0aeb32a47..d29b70a28f2b 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -1670,10 +1670,8 @@ nfsd_export_shutdown(void)
 
 	exp_writelock();
 
-	if (cache_unregister(&amp;svc_expkey_cache))
-		printk(KERN_ERR "nfsd: failed to unregister expkey cache\n");
-	if (cache_unregister(&amp;svc_export_cache))
-		printk(KERN_ERR "nfsd: failed to unregister export cache\n");
+	cache_unregister(&amp;svc_expkey_cache);
+	cache_unregister(&amp;svc_export_cache);
 	svcauth_unix_purge();
 
 	exp_writeunlock();
diff --git a/fs/nfsd/nfs4idmap.c b/fs/nfsd/nfs4idmap.c
index 5b56c77c15c5..ef22179c49ad 100644
--- a/fs/nfsd/nfs4idmap.c
+++ b/fs/nfsd/nfs4idmap.c
@@ -474,10 +474,8 @@ nfsd_idmap_init(void)
 void
 nfsd_idmap_shutdown(void)
 {
-	if (cache_unregister(&amp;idtoname_cache))
-		printk(KERN_ERR "nfsd: failed to unregister idtoname cache\n");
-	if (cache_unregister(&amp;nametoid_cache))
-		printk(KERN_ERR "nfsd: failed to unregister nametoid cache\n");
+	cache_unregister(&amp;idtoname_cache);
+	cache_unregister(&amp;nametoid_cache);
 }
 
 /*
diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index bd7a6b0a87af..b683b5ddeea9 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -170,7 +170,7 @@ extern void cache_flush(void);
 extern void cache_purge(struct cache_detail *detail);
 #define NEVER (0x7FFFFFFF)
 extern void cache_register(struct cache_detail *cd);
-extern int cache_unregister(struct cache_detail *cd);
+extern void cache_unregister(struct cache_detail *cd);
 
 extern void qword_add(char **bpp, int *lp, char *str);
 extern void qword_addhex(char **bpp, int *lp, char *buf, int blen);
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index 73940df6c460..d329a12500aa 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -1396,9 +1396,7 @@ gss_svc_init(void)
 void
 gss_svc_shutdown(void)
 {
-	if (cache_unregister(&amp;rsc_cache))
-		printk(KERN_ERR "auth_rpcgss: failed to unregister rsc cache\n");
-	if (cache_unregister(&amp;rsi_cache))
-		printk(KERN_ERR "auth_rpcgss: failed to unregister rsi cache\n");
+	cache_unregister(&amp;rsc_cache);
+	cache_unregister(&amp;rsi_cache);
 	svc_auth_unregister(RPC_AUTH_GSS);
 }
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index 3b11277d27b1..365586a999ea 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -343,7 +343,7 @@ void cache_register(struct cache_detail *cd)
 	schedule_delayed_work(&amp;cache_cleaner, 0);
 }
 
-int cache_unregister(struct cache_detail *cd)
+void cache_unregister(struct cache_detail *cd)
 {
 	cache_purge(cd);
 	spin_lock(&amp;cache_list_lock);
@@ -351,7 +351,7 @@ int cache_unregister(struct cache_detail *cd)
 	if (cd-&gt;entries || atomic_read(&amp;cd-&gt;inuse)) {
 		write_unlock(&amp;cd-&gt;hash_lock);
 		spin_unlock(&amp;cache_list_lock);
-		return -EBUSY;
+		goto out;
 	}
 	if (current_detail == cd)
 		current_detail = NULL;
@@ -373,7 +373,9 @@ int cache_unregister(struct cache_detail *cd)
 		/* module must be being unloaded so its safe to kill the worker */
 		cancel_delayed_work_sync(&amp;cache_cleaner);
 	}
-	return 0;
+	return;
+out:
+	printk(KERN_ERR "nfsd: failed to unregister %s cache\n", cd-&gt;name);
 }
 
 /* clean cache tries to find something to clean
diff --git a/net/sunrpc/sunrpc_syms.c b/net/sunrpc/sunrpc_syms.c
index 1a7e309d008b..ef7dc78e2c7b 100644
--- a/net/sunrpc/sunrpc_syms.c
+++ b/net/sunrpc/sunrpc_syms.c
@@ -98,10 +98,8 @@ cleanup_sunrpc(void)
 	cleanup_socket_xprt();
 	unregister_rpc_pipefs();
 	rpc_destroy_mempool();
-	if (cache_unregister(&amp;ip_map_cache))
-		printk(KERN_ERR "sunrpc: failed to unregister ip_map cache\n");
-	if (cache_unregister(&amp;unix_gid_cache))
-	      printk(KERN_ERR "sunrpc: failed to unregister unix_gid cache\n");
+	cache_unregister(&amp;ip_map_cache);
+	cache_unregister(&amp;unix_gid_cache);
 #ifdef RPC_DEBUG
 	rpc_unregister_sysctl();
 #endif</pre><hr><pre>commit d5c3428b2cb26d605fddc4878f4fcc03c23df89f
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Nov 9 14:10:56 2007 -0500

    nfsd: fail module init on reply cache init failure
    
    If the reply cache initialization fails due to a kmalloc failure,
    currently we try to soldier on with a reduced (or nonexistant) reply
    cache.
    
    Better to just fail immediately: the failure is then much easier to
    understand and debug, and it could save us complexity in some later
    code.  (But actually, it doesn't help currently because the cache is
    also turned off in some odd failure cases; we should probably find a
    better way to handle those failure cases some day.)
    
    Fix some minor style problems while we're at it, and rename
    nfsd_cache_init() to remove the need for a comment describing it.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfscache.c b/fs/nfsd/nfscache.c
index 578f2c9d56be..5bfc2ac60d54 100644
--- a/fs/nfsd/nfscache.c
+++ b/fs/nfsd/nfscache.c
@@ -44,17 +44,17 @@ static int	nfsd_cache_append(struct svc_rqst *rqstp, struct kvec *vec);
  */
 static DEFINE_SPINLOCK(cache_lock);
 
-void
-nfsd_cache_init(void)
+int nfsd_reply_cache_init(void)
 {
 	struct svc_cacherep	*rp;
 	int			i;
 
 	INIT_LIST_HEAD(&amp;lru_head);
 	i = CACHESIZE;
-	while(i) {
+	while (i) {
 		rp = kmalloc(sizeof(*rp), GFP_KERNEL);
-		if (!rp) break;
+		if (!rp)
+			goto out_nomem;
 		list_add(&amp;rp-&gt;c_lru, &amp;lru_head);
 		rp-&gt;c_state = RC_UNUSED;
 		rp-&gt;c_type = RC_NOCACHE;
@@ -62,23 +62,19 @@ nfsd_cache_init(void)
 		i--;
 	}
 
-	if (i)
-		printk (KERN_ERR "nfsd: cannot allocate all %d cache entries, only got %d\n",
-			CACHESIZE, CACHESIZE-i);
-
 	hash_list = kcalloc (HASHSIZE, sizeof(struct hlist_head), GFP_KERNEL);
-	if (!hash_list) {
-		nfsd_cache_shutdown();
-		printk (KERN_ERR "nfsd: cannot allocate %Zd bytes for hash list\n",
-			HASHSIZE * sizeof(struct hlist_head));
-		return;
-	}
+	if (!hash_list)
+		goto out_nomem;
 
 	cache_disabled = 0;
+	return 0;
+out_nomem:
+	printk(KERN_ERR "nfsd: failed to allocate reply cache\n");
+	nfsd_reply_cache_shutdown();
+	return -ENOMEM;
 }
 
-void
-nfsd_cache_shutdown(void)
+void nfsd_reply_cache_shutdown(void)
 {
 	struct svc_cacherep	*rp;
 
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index ecf377944286..2bfda9b8f504 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -683,7 +683,9 @@ static int __init init_nfsd(void)
 	if (retval)
 		return retval;
 	nfsd_stat_init();	/* Statistics */
-	nfsd_cache_init();	/* RPC reply cache */
+	retval = nfsd_reply_cache_init();
+	if (retval)
+		goto out_free_stat;
 	nfsd_export_init();	/* Exports table */
 	nfsd_lockd_init();	/* lockd-&gt;nfsd callbacks */
 	nfsd_idmap_init();      /* Name to ID mapping */
@@ -700,11 +702,12 @@ static int __init init_nfsd(void)
 out_free_all:
 	nfsd_idmap_shutdown();
 	nfsd_export_shutdown();
-	nfsd_cache_shutdown();
+	nfsd_reply_cache_shutdown();
 	remove_proc_entry("fs/nfs/exports", NULL);
 	remove_proc_entry("fs/nfs", NULL);
-	nfsd_stat_shutdown();
 	nfsd_lockd_shutdown();
+out_free_stat:
+	nfsd_stat_shutdown();
 	nfsd4_free_slabs();
 	return retval;
 }
@@ -712,7 +715,7 @@ static int __init init_nfsd(void)
 static void __exit exit_nfsd(void)
 {
 	nfsd_export_shutdown();
-	nfsd_cache_shutdown();
+	nfsd_reply_cache_shutdown();
 	remove_proc_entry("fs/nfs/exports", NULL);
 	remove_proc_entry("fs/nfs", NULL);
 	nfsd_stat_shutdown();
diff --git a/include/linux/nfsd/cache.h b/include/linux/nfsd/cache.h
index 007480cd6a60..7b5d784cc858 100644
--- a/include/linux/nfsd/cache.h
+++ b/include/linux/nfsd/cache.h
@@ -72,8 +72,8 @@ enum {
  */
 #define RC_DELAY		(HZ/5)
 
-void	nfsd_cache_init(void);
-void	nfsd_cache_shutdown(void);
+int	nfsd_reply_cache_init(void);
+void	nfsd_reply_cache_shutdown(void);
 int	nfsd_cache_lookup(struct svc_rqst *, int);
 void	nfsd_cache_update(struct svc_rqst *, int, __be32 *);
 </pre><hr><pre>commit 26808d3f10b1213bbb6e27d441be40e20ab84611
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Nov 9 13:44:06 2007 -0500

    nfsd: cleanup nfsd module initialization cleanup
    
    Handle the failure case here with something closer to the standard
    kernel style.
    
    Doesn't really matter for now, but I'd like to add a few more failure
    cases, and then this'll help.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index d8d50a773a5b..ecf377944286 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -694,16 +694,18 @@ static int __init init_nfsd(void)
 			entry-&gt;proc_fops =  &amp;exports_operations;
 	}
 	retval = register_filesystem(&amp;nfsd_fs_type);
-	if (retval) {
-		nfsd_idmap_shutdown();
-		nfsd_export_shutdown();
-		nfsd_cache_shutdown();
-		remove_proc_entry("fs/nfs/exports", NULL);
-		remove_proc_entry("fs/nfs", NULL);
-		nfsd_stat_shutdown();
-		nfsd_lockd_shutdown();
-		nfsd4_free_slabs();
-	}
+	if (retval)
+		goto out_free_all;
+	return 0;
+out_free_all:
+	nfsd_idmap_shutdown();
+	nfsd_export_shutdown();
+	nfsd_cache_shutdown();
+	remove_proc_entry("fs/nfs/exports", NULL);
+	remove_proc_entry("fs/nfs", NULL);
+	nfsd_stat_shutdown();
+	nfsd_lockd_shutdown();
+	nfsd4_free_slabs();
 	return retval;
 }
 </pre><hr><pre>commit 46b25895767c606c630a97b03a895934a7a36a70
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Nov 9 12:31:55 2007 -0500

    knfsd: cleanup nfsd4 properly on module init failure
    
    We forgot to shut down the nfs4 state and idmapping code in this case.
    
    Acked-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index 77dc9893b7ba..d8d50a773a5b 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -695,12 +695,14 @@ static int __init init_nfsd(void)
 	}
 	retval = register_filesystem(&amp;nfsd_fs_type);
 	if (retval) {
+		nfsd_idmap_shutdown();
 		nfsd_export_shutdown();
 		nfsd_cache_shutdown();
 		remove_proc_entry("fs/nfs/exports", NULL);
 		remove_proc_entry("fs/nfs", NULL);
 		nfsd_stat_shutdown();
 		nfsd_lockd_shutdown();
+		nfsd4_free_slabs();
 	}
 	return retval;
 }</pre>
    <div class="pagination">
        <a href='4_38.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><span>[39]</span><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_40.html'>Next&gt;&gt;</a>
    <div>
</body>
