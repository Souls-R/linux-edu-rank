<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_113.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><span>[114]</span><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_115.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 629e4427aa817d5c9f11885420abf54b8f5967dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 22 16:08:53 2007 -0500

    EHCI: fix interrupt-driven remote wakeup
    
    Now that port status change notifications are interrupt-driven,
    ehci-hcd needs to tell usbcore when a remote-wakeup resume operation
    is finished -- we can no longer rely on the core to poll and find
    out.  This patch (as843) uses the root-hub status timer to force a
    poll after the resume is complete.
    
    The patch also changes the test for detecting when the TDRSMDN resume
    period has expired.  It's necessary to use time_after_eq() instead of
    time_after(), since the polling is triggered precisely by a timer.
    The same change is made for TDRSTR reset expiration, for consistency.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3cfba69e0767..0d83c6df1a3b 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -379,8 +379,8 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 			ehci-&gt;reset_done [i] = 0;
 		if ((temp &amp; mask) != 0
 				|| ((temp &amp; PORT_RESUME) != 0
-					&amp;&amp; time_after (jiffies,
-						ehci-&gt;reset_done [i]))) {
+					&amp;&amp; time_after_eq(jiffies,
+						ehci-&gt;reset_done[i]))) {
 			if (i &lt; 7)
 			    buf [0] |= 1 &lt;&lt; (i + 1);
 			else
@@ -554,31 +554,45 @@ static int ehci_hub_control (
 			status |= 1 &lt;&lt; USB_PORT_FEAT_C_OVER_CURRENT;
 
 		/* whoever resumes must GetPortStatus to complete it!! */
-		if ((temp &amp; PORT_RESUME)
-				&amp;&amp; time_after (jiffies,
-					ehci-&gt;reset_done [wIndex])) {
-			status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
-			ehci-&gt;reset_done [wIndex] = 0;
+		if (temp &amp; PORT_RESUME) {
 
-			/* stop resume signaling */
-			temp = ehci_readl(ehci, status_reg);
-			ehci_writel(ehci,
+			/* Remote Wakeup received? */
+			if (!ehci-&gt;reset_done[wIndex]) {
+				/* resume signaling for 20 msec */
+				ehci-&gt;reset_done[wIndex] = jiffies
+						+ msecs_to_jiffies(20);
+				/* check the port again */
+				mod_timer(&amp;ehci_to_hcd(ehci)-&gt;rh_timer,
+						ehci-&gt;reset_done[wIndex]);
+			}
+
+			/* resume completed? */
+			else if (time_after_eq(jiffies,
+					ehci-&gt;reset_done[wIndex])) {
+				status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+				ehci-&gt;reset_done[wIndex] = 0;
+
+				/* stop resume signaling */
+				temp = ehci_readl(ehci, status_reg);
+				ehci_writel(ehci,
 					temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
 					status_reg);
-			retval = handshake(ehci, status_reg,
+				retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
-			if (retval != 0) {
-				ehci_err (ehci, "port %d resume error %d\n",
-					wIndex + 1, retval);
-				goto error;
+				if (retval != 0) {
+					ehci_err(ehci,
+						"port %d resume error %d\n",
+						wIndex + 1, retval);
+					goto error;
+				}
+				temp &amp;= ~(PORT_SUSPEND|PORT_RESUME|(3&lt;&lt;10));
 			}
-			temp &amp;= ~(PORT_SUSPEND|PORT_RESUME|(3&lt;&lt;10));
 		}
 
 		/* whoever resets must GetPortStatus to complete it!! */
 		if ((temp &amp; PORT_RESET)
-				&amp;&amp; time_after (jiffies,
-					ehci-&gt;reset_done [wIndex])) {
+				&amp;&amp; time_after_eq(jiffies,
+					ehci-&gt;reset_done[wIndex])) {
 			status |= 1 &lt;&lt; USB_PORT_FEAT_C_RESET;
 			ehci-&gt;reset_done [wIndex] = 0;
 </pre><hr><pre>commit 49631ca7f3e2fd05186028b453fa27f75b830de7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 23:28:48 2007 -0800

    USB: gadgetfs AIO tweaks
    
    This patch (as837) fixes several mistakes in the AIO interface of the
    gadgetfs driver:
    
            The ki_retry method is not supposed to do a put on the kiocb.
            The extra call to aio_put_req() causes memory corruption.
            (Note: This call was removed before, by patch as691, and then
            mysteriously re-introduced later.)
    
            Even if a read transfer is cancelled, we can and should send
            to the user all the data that did manage to get transferred.
    
            Testing for AIO cancellation in the I/O completion handler
            is both racy and (now) unnecessary.  aio_complete() does its
            own checking, in a safe manner.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 1c5e1ee7e36b..34296e79edcf 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -576,7 +576,6 @@ static ssize_t ep_aio_read_retry(struct kiocb *iocb)
 	}
 	kfree(priv-&gt;buf);
 	kfree(priv);
-	aio_put_req(iocb);
 	return len;
 }
 
@@ -590,18 +589,17 @@ static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)
 	spin_lock(&amp;epdata-&gt;dev-&gt;lock);
 	priv-&gt;req = NULL;
 	priv-&gt;epdata = NULL;
-	if (priv-&gt;iv == NULL
-			|| unlikely(req-&gt;actual == 0)
-			|| unlikely(kiocbIsCancelled(iocb))) {
+
+	/* if this was a write or a read returning no data then we
+	 * don't need to copy anything to userspace, so we can
+	 * complete the aio request immediately.
+	 */
+	if (priv-&gt;iv == NULL || unlikely(req-&gt;actual == 0)) {
 		kfree(req-&gt;buf);
 		kfree(priv);
 		iocb-&gt;private = NULL;
 		/* aio_complete() reports bytes-transferred _and_ faults */
-		if (unlikely(kiocbIsCancelled(iocb)))
-			aio_put_req(iocb);
-		else
-			aio_complete(iocb,
-				req-&gt;actual ? req-&gt;actual : req-&gt;status,
+		aio_complete(iocb, req-&gt;actual ? req-&gt;actual : req-&gt;status,
 				req-&gt;status);
 	} else {
 		/* retry() won't report both; so we hide some faults */</pre><hr><pre>commit 57e06c11372eccf5acebdd4664eb025fee76c561
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:59:45 2007 -0500

    EHCI: force high-speed devices to run at full speed
    
    This patch (as710) adds a sysfs class-device attribute file named
    "companion" for EHCI controllers.  The file contains a list of port
    numbers that are dedicated to the companion controller; by writing a
    port number to the file the user can force a high-speed device
    attached directly to the computer to run at full speed.  (As far as I
    know it is not possible to do this for a device attached to an
    external hub.)  A port is removed from the file by writing the
    negative of its port number.
    
    Several users have asked for this facility and it seems like a useful
    thing to have.  Every now and then one runs across a device which
    behaves much better at full speed than at high speed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9ec896218feb..92c62911f574 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -388,6 +388,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	/* let companion controllers work when we aren't */
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
 
+	remove_companion_file(ehci);
 	remove_debug_files (ehci);
 
 	/* root hub is shut down separately (first, when possible) */
@@ -563,6 +564,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * since the class device isn't created that early.
 	 */
 	create_debug_files(ehci);
+	create_companion_file(ehci);
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 076474d95dbf..3cfba69e0767 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -188,6 +188,103 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 
 #endif	/* CONFIG_PM */
 
+/*-------------------------------------------------------------------------*/
+
+/* Display the ports dedicated to the companion controller */
+static ssize_t show_companion(struct class_device *class_dev, char *buf)
+{
+	struct ehci_hcd		*ehci;
+	int			nports, index, n;
+	int			count = PAGE_SIZE;
+	char			*ptr = buf;
+
+	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
+	nports = HCS_N_PORTS(ehci-&gt;hcs_params);
+
+	for (index = 0; index &lt; nports; ++index) {
+		if (test_bit(index, &amp;ehci-&gt;companion_ports)) {
+			n = scnprintf(ptr, count, "%d\n", index + 1);
+			ptr += n;
+			count -= n;
+		}
+	}
+	return ptr - buf;
+}
+
+/*
+ * Dedicate or undedicate a port to the companion controller.
+ * Syntax is "[-]portnum", where a leading '-' sign means
+ * return control of the port to the EHCI controller.
+ */
+static ssize_t store_companion(struct class_device *class_dev,
+		const char *buf, size_t count)
+{
+	struct ehci_hcd		*ehci;
+	int			portnum, new_owner, try;
+	u32 __iomem		*status_reg;
+	u32			port_status;
+
+	ehci = hcd_to_ehci(bus_to_hcd(class_get_devdata(class_dev)));
+	new_owner = PORT_OWNER;		/* Owned by companion */
+	if (sscanf(buf, "%d", &amp;portnum) != 1)
+		return -EINVAL;
+	if (portnum &lt; 0) {
+		portnum = - portnum;
+		new_owner = 0;		/* Owned by EHCI */
+	}
+	if (portnum &lt;= 0 || portnum &gt; HCS_N_PORTS(ehci-&gt;hcs_params))
+		return -ENOENT;
+	status_reg = &amp;ehci-&gt;regs-&gt;port_status[--portnum];
+	if (new_owner)
+		set_bit(portnum, &amp;ehci-&gt;companion_ports);
+	else
+		clear_bit(portnum, &amp;ehci-&gt;companion_ports);
+
+	/*
+	 * The controller won't set the OWNER bit if the port is
+	 * enabled, so this loop will sometimes require at least two
+	 * iterations: one to disable the port and one to set OWNER.
+	 */
+
+	for (try = 4; try &gt; 0; --try) {
+		spin_lock_irq(&amp;ehci-&gt;lock);
+		port_status = ehci_readl(ehci, status_reg);
+		if ((port_status &amp; PORT_OWNER) == new_owner
+				|| (port_status &amp; (PORT_OWNER | PORT_CONNECT))
+					== 0)
+			try = 0;
+		else {
+			port_status ^= PORT_OWNER;
+			port_status &amp;= ~(PORT_PE | PORT_RWC_BITS);
+			ehci_writel(ehci, port_status, status_reg);
+		}
+		spin_unlock_irq(&amp;ehci-&gt;lock);
+		if (try &gt; 1)
+			msleep(5);
+	}
+	return count;
+}
+static CLASS_DEVICE_ATTR(companion, 0644, show_companion, store_companion);
+
+static inline void create_companion_file(struct ehci_hcd *ehci)
+{
+	int	i;
+
+	/* with integrated TT there is no companion! */
+	if (!ehci_is_TDI(ehci))
+		i = class_device_create_file(ehci_to_hcd(ehci)-&gt;self.class_dev,
+				&amp;class_device_attr_companion);
+}
+
+static inline void remove_companion_file(struct ehci_hcd *ehci)
+{
+	/* with integrated TT there is no companion! */
+	if (!ehci_is_TDI(ehci))
+		class_device_remove_file(ehci_to_hcd(ehci)-&gt;self.class_dev,
+				&amp;class_device_attr_companion);
+}
+
+
 /*-------------------------------------------------------------------------*/
 
 static int check_reset_complete (
@@ -504,6 +601,16 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
+		/* transfer dedicated ports to the companion hc */
+		if ((temp &amp; PORT_CONNECT) &amp;&amp;
+				test_bit(wIndex, &amp;ehci-&gt;companion_ports)) {
+			temp &amp;= ~PORT_RWC_BITS;
+			temp |= PORT_OWNER;
+			ehci_writel(ehci, temp, status_reg);
+			ehci_dbg(ehci, "port %d --&gt; companion\n", wIndex + 1);
+			temp = ehci_readl(ehci, status_reg);
+		}
+
 		/*
 		 * Even if OWNER is set, there's no harm letting khubd
 		 * see the wPortStatus values (they should all be 0 except
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 3ce7249085d5..ec0da0343be4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -74,7 +74,11 @@ struct ehci_hcd {			/* one per controller */
 
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
-	unsigned long		bus_suspended;
+	/* bit vectors (one bit per port) */
+	unsigned long		bus_suspended;		/* which ports were
+			already suspended at the start of a bus suspend */
+	unsigned long		companion_ports;	/* which ports are
+			dedicated to the companion controller */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 625b5c9a0069ef1b61feb3ce599b39f1b04b5666
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:58:47 2007 -0500

    EHCI: don't hide ports owned by the companion
    
    This patch (as709) changes the way ehci-hcd presents port status
    values for ports owned by the companion controller.  It no longer
    hides the information; in particular, it allows the core to see the
    disconnect event that occurs when a full- or low-speed device is
    switched over to the companion.  This is required for the next patch
    in this series.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 12f881ff4b23..076474d95dbf 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -270,16 +270,14 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	for (i = 0; i &lt; ports; i++) {
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
-		if (temp &amp; PORT_OWNER) {
-			/* don't report this in GetPortStatus */
-			if (temp &amp; PORT_CSC) {
-				temp &amp;= ~PORT_RWC_BITS;
-				temp |= PORT_CSC;
-				ehci_writel(ehci, temp,
-					    &amp;ehci-&gt;regs-&gt;port_status [i]);
-			}
-			continue;
-		}
+
+		/*
+		 * Return status information even for ports with OWNER set.
+		 * Otherwise khubd wouldn't see the disconnect event when a
+		 * high-speed device is switched over to the companion
+		 * controller by the user.
+		 */
+
 		if (!(temp &amp; PORT_CONNECT))
 			ehci-&gt;reset_done [i] = 0;
 		if ((temp &amp; mask) != 0
@@ -377,8 +375,13 @@ static int ehci_hub_control (
 			goto error;
 		wIndex--;
 		temp = ehci_readl(ehci, status_reg);
-		if (temp &amp; PORT_OWNER)
-			break;
+
+		/*
+		 * Even if OWNER is set, so the port is owned by the
+		 * companion controller, khubd needs to be able to clear
+		 * the port-change status bits (especially
+		 * USB_PORT_FEAT_C_CONNECTION).
+		 */
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
@@ -501,24 +504,27 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
-		// don't show wPortStatus if it's owned by a companion hc
-		if (!(temp &amp; PORT_OWNER)) {
-			if (temp &amp; PORT_CONNECT) {
-				status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
-				// status may be from integrated TT
-				status |= ehci_port_speed(ehci, temp);
-			}
-			if (temp &amp; PORT_PE)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
-			if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
-				status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
-			if (temp &amp; PORT_OC)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
-			if (temp &amp; PORT_RESET)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
-			if (temp &amp; PORT_POWER)
-				status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+		/*
+		 * Even if OWNER is set, there's no harm letting khubd
+		 * see the wPortStatus values (they should all be 0 except
+		 * for PORT_POWER anyway).
+		 */
+
+		if (temp &amp; PORT_CONNECT) {
+			status |= 1 &lt;&lt; USB_PORT_FEAT_CONNECTION;
+			// status may be from integrated TT
+			status |= ehci_port_speed(ehci, temp);
 		}
+		if (temp &amp; PORT_PE)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
+		if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
+			status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
+		if (temp &amp; PORT_OC)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
+		if (temp &amp; PORT_RESET)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
+		if (temp &amp; PORT_POWER)
+			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
 
 #ifndef	EHCI_VERBOSE_DEBUG
 	if (status &amp; ~0xffff)	/* only if wPortChange is interesting */</pre><hr><pre>commit e6316565e568b3b5733be10cfca3c27259bef499
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:58:00 2007 -0500

    EHCI: local variable for port status register
    
    This patch (as708) introduces a local variable to hold the port
    status-register address in ehci-hub.c.  There's not much improvement
    in the object code, but it sure is a lot easier to read.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index df00fcbadfbc..12f881ff4b23 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -193,6 +193,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 static int check_reset_complete (
 	struct ehci_hcd	*ehci,
 	int		index,
+	u32 __iomem	*status_reg,
 	int		port_status
 ) {
 	if (!(port_status &amp; PORT_CONNECT)) {
@@ -217,8 +218,7 @@ static int check_reset_complete (
 		// what happens if HCS_N_CC(params) == 0 ?
 		port_status |= PORT_OWNER;
 		port_status &amp;= ~PORT_RWC_BITS;
-		ehci_writel(ehci, port_status,
-			    &amp;ehci-&gt;regs-&gt;port_status [index]);
+		ehci_writel(ehci, port_status, status_reg);
 
 	} else
 		ehci_dbg (ehci, "port %d high speed\n", index + 1);
@@ -347,6 +347,7 @@ static int ehci_hub_control (
 ) {
 	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
 	int		ports = HCS_N_PORTS (ehci-&gt;hcs_params);
+	u32 __iomem	*status_reg = &amp;ehci-&gt;regs-&gt;port_status[wIndex - 1];
 	u32		temp, status;
 	unsigned long	flags;
 	int		retval = 0;
@@ -375,18 +376,17 @@ static int ehci_hub_control (
 		if (!wIndex || wIndex &gt; ports)
 			goto error;
 		wIndex--;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+		temp = ehci_readl(ehci, status_reg);
 		if (temp &amp; PORT_OWNER)
 			break;
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
-			ehci_writel(ehci, temp &amp; ~PORT_PE,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp &amp; ~PORT_PE, status_reg);
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
 			ehci_writel(ehci, (temp &amp; ~PORT_RWC_BITS) | PORT_PEC,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			if (temp &amp; PORT_RESET)
@@ -399,7 +399,7 @@ static int ehci_hub_control (
 				/* resume signaling for 20 msec */
 				temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 				ehci_writel(ehci, temp | PORT_RESUME,
-					    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+						status_reg);
 				ehci-&gt;reset_done [wIndex] = jiffies
 						+ msecs_to_jiffies (20);
 			}
@@ -411,15 +411,15 @@ static int ehci_hub_control (
 			if (HCS_PPC (ehci-&gt;hcs_params))
 				ehci_writel(ehci,
 					  temp &amp; ~(PORT_RWC_BITS | PORT_POWER),
-					  &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					  status_reg);
 			break;
 		case USB_PORT_FEAT_C_CONNECTION:
 			ehci_writel(ehci, (temp &amp; ~PORT_RWC_BITS) | PORT_CSC,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			break;
 		case USB_PORT_FEAT_C_OVER_CURRENT:
 			ehci_writel(ehci, (temp &amp; ~PORT_RWC_BITS) | PORT_OCC,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			break;
 		case USB_PORT_FEAT_C_RESET:
 			/* GetPortStatus clears reset */
@@ -443,7 +443,7 @@ static int ehci_hub_control (
 			goto error;
 		wIndex--;
 		status = 0;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+		temp = ehci_readl(ehci, status_reg);
 
 		// wPortChange bits
 		if (temp &amp; PORT_CSC)
@@ -461,13 +461,11 @@ static int ehci_hub_control (
 			ehci-&gt;reset_done [wIndex] = 0;
 
 			/* stop resume signaling */
-			temp = ehci_readl(ehci,
-					  &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			temp = ehci_readl(ehci, status_reg);
 			ehci_writel(ehci,
-				    temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
-			retval = handshake(ehci,
-					   &amp;ehci-&gt;regs-&gt;port_status [wIndex],
+					temp &amp; ~(PORT_RWC_BITS | PORT_RESUME),
+					status_reg);
+			retval = handshake(ehci, status_reg,
 					   PORT_RESUME, 0, 2000 /* 2msec */);
 			if (retval != 0) {
 				ehci_err (ehci, "port %d resume error %d\n",
@@ -486,12 +484,11 @@ static int ehci_hub_control (
 
 			/* force reset to complete */
 			ehci_writel(ehci, temp &amp; ~(PORT_RWC_BITS | PORT_RESET),
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+					status_reg);
 			/* REVISIT:  some hardware needs 550+ usec to clear
 			 * this bit; seems too long to spin routinely...
 			 */
-			retval = handshake(ehci,
-					   &amp;ehci-&gt;regs-&gt;port_status [wIndex],
+			retval = handshake(ehci, status_reg,
 					PORT_RESET, 0, 750);
 			if (retval != 0) {
 				ehci_err (ehci, "port %d reset error %d\n",
@@ -500,9 +497,8 @@ static int ehci_hub_control (
 			}
 
 			/* see what we found out */
-			temp = check_reset_complete (ehci, wIndex,
-				ehci_readl(ehci,
-					   &amp;ehci-&gt;regs-&gt;port_status [wIndex]));
+			temp = check_reset_complete (ehci, wIndex, status_reg,
+					ehci_readl(ehci, status_reg));
 		}
 
 		// don't show wPortStatus if it's owned by a companion hc
@@ -547,7 +543,7 @@ static int ehci_hub_control (
 		if (!wIndex || wIndex &gt; ports)
 			goto error;
 		wIndex--;
-		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+		temp = ehci_readl(ehci, status_reg);
 		if (temp &amp; PORT_OWNER)
 			break;
 
@@ -561,13 +557,12 @@ static int ehci_hub_control (
 				goto error;
 			if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
 				temp |= PORT_WAKE_BITS;
-			ehci_writel(ehci, temp | PORT_SUSPEND,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci-&gt;hcs_params))
 				ehci_writel(ehci, temp | PORT_POWER,
-					    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+						status_reg);
 			break;
 		case USB_PORT_FEAT_RESET:
 			if (temp &amp; PORT_RESUME)
@@ -595,8 +590,7 @@ static int ehci_hub_control (
 				ehci-&gt;reset_done [wIndex] = jiffies
 						+ msecs_to_jiffies (50);
 			}
-			ehci_writel(ehci, temp,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp, status_reg);
 			break;
 
 		/* For downstream facing ports (these):  one hub port is put
@@ -611,8 +605,7 @@ static int ehci_hub_control (
 			ehci_quiesce(ehci);
 			ehci_halt(ehci);
 			temp |= selector &lt;&lt; 16;
-			ehci_writel(ehci, temp,
-				    &amp;ehci-&gt;regs-&gt;port_status [wIndex]);
+			ehci_writel(ehci, temp, status_reg);
 			break;
 
 		default:</pre><hr><pre>commit 896fbd7199035958013d106329843d8ae9618753
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:57:13 2007 -0500

    usbcore: remove unused bandwith-related code
    
    This patch (as841) removes from usbcore a couple of support routines
    meant to help with bandwidth allocation.  With the changes to uhci-hcd
    in the previous patch, these routines are no longer used anywhere.
    Also removed is the CONFIG_USB_BANDWIDTH option; it no longer does
    anything and is no longer needed since the HCDs now handle bandwidth
    issues correctly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index 3e66b2a9974a..2fc0f88a3d86 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -33,19 +33,6 @@ config USB_DEVICEFS
 
 	  Most users want to say Y here.
 
-config USB_BANDWIDTH
-	bool "Enforce USB bandwidth allocation (EXPERIMENTAL)"
-	depends on USB &amp;&amp; EXPERIMENTAL
-	help
-	  If you say Y here, the USB subsystem enforces USB bandwidth
-	  allocation and will prevent some device opens from succeeding
-	  if they would cause USB bandwidth usage to go above 90% of
-	  the bus bandwidth.
-
-	  If you say N here, these conditions will cause warning messages
-	  about USB bandwidth usage to be logged and some devices or
-	  drivers may not work correctly.
-
 config USB_DYNAMIC_MINORS
 	bool "Dynamic USB minor allocation (EXPERIMENTAL)"
 	depends on USB &amp;&amp; EXPERIMENTAL
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 10064af65d17..b26c19e8d19f 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -45,8 +45,6 @@
 #include "hub.h"
 
 
-// #define USB_BANDWIDTH_MESSAGES
-
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -891,136 +889,6 @@ long usb_calc_bus_time (int speed, int is_input, int isoc, int bytecount)
 }
 EXPORT_SYMBOL (usb_calc_bus_time);
 
-/*
- * usb_check_bandwidth():
- *
- * old_alloc is from host_controller-&gt;bandwidth_allocated in microseconds;
- * bustime is from calc_bus_time(), but converted to microseconds.
- *
- * returns &lt;bustime in us&gt; if successful,
- * or -ENOSPC if bandwidth request fails.
- *
- * FIXME:
- * This initial implementation does not use Endpoint.bInterval
- * in managing bandwidth allocation.
- * It probably needs to be expanded to use Endpoint.bInterval.
- * This can be done as a later enhancement (correction).
- *
- * This will also probably require some kind of
- * frame allocation tracking...meaning, for example,
- * that if multiple drivers request interrupts every 10 USB frames,
- * they don't all have to be allocated at
- * frame numbers N, N+10, N+20, etc.  Some of them could be at
- * N+11, N+21, N+31, etc., and others at
- * N+12, N+22, N+32, etc.
- *
- * Similarly for isochronous transfers...
- *
- * Individual HCDs can schedule more directly ... this logic
- * is not correct for high speed transfers.
- */
-int usb_check_bandwidth (struct usb_device *dev, struct urb *urb)
-{
-	unsigned int	pipe = urb-&gt;pipe;
-	long		bustime;
-	int		is_in = usb_pipein (pipe);
-	int		is_iso = usb_pipeisoc (pipe);
-	int		old_alloc = dev-&gt;bus-&gt;bandwidth_allocated;
-	int		new_alloc;
-
-
-	bustime = NS_TO_US (usb_calc_bus_time (dev-&gt;speed, is_in, is_iso,
-			usb_maxpacket (dev, pipe, !is_in)));
-	if (is_iso)
-		bustime /= urb-&gt;number_of_packets;
-
-	new_alloc = old_alloc + (int) bustime;
-	if (new_alloc &gt; FRAME_TIME_MAX_USECS_ALLOC) {
-#ifdef	DEBUG
-		char	*mode = 
-#ifdef CONFIG_USB_BANDWIDTH
-			"";
-#else
-			"would have ";
-#endif
-		dev_dbg (&amp;dev-&gt;dev, "usb_check_bandwidth %sFAILED: %d + %ld = %d usec\n",
-			mode, old_alloc, bustime, new_alloc);
-#endif
-#ifdef CONFIG_USB_BANDWIDTH
-		bustime = -ENOSPC;	/* report error */
-#endif
-	}
-
-	return bustime;
-}
-EXPORT_SYMBOL (usb_check_bandwidth);
-
-
-/**
- * usb_claim_bandwidth - records bandwidth for a periodic transfer
- * @dev: source/target of request
- * @urb: request (urb-&gt;dev == dev)
- * @bustime: bandwidth consumed, in (average) microseconds per frame
- * @isoc: true iff the request is isochronous
- *
- * Bus bandwidth reservations are recorded purely for diagnostic purposes.
- * HCDs are expected not to overcommit periodic bandwidth, and to record such
- * reservations whenever endpoints are added to the periodic schedule.
- *
- * FIXME averaging per-frame is suboptimal.  Better to sum over the HCD's
- * entire periodic schedule ... 32 frames for OHCI, 1024 for UHCI, settable
- * for EHCI (256/512/1024 frames, default 1024) and have the bus expose how
- * large its periodic schedule is.
- */
-void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb, int bustime, int isoc)
-{
-	dev-&gt;bus-&gt;bandwidth_allocated += bustime;
-	if (isoc)
-		dev-&gt;bus-&gt;bandwidth_isoc_reqs++;
-	else
-		dev-&gt;bus-&gt;bandwidth_int_reqs++;
-	urb-&gt;bandwidth = bustime;
-
-#ifdef USB_BANDWIDTH_MESSAGES
-	dev_dbg (&amp;dev-&gt;dev, "bandwidth alloc increased by %d (%s) to %d for %d requesters\n",
-		bustime,
-		isoc ? "ISOC" : "INTR",
-		dev-&gt;bus-&gt;bandwidth_allocated,
-		dev-&gt;bus-&gt;bandwidth_int_reqs + dev-&gt;bus-&gt;bandwidth_isoc_reqs);
-#endif
-}
-EXPORT_SYMBOL (usb_claim_bandwidth);
-
-
-/**
- * usb_release_bandwidth - reverses effect of usb_claim_bandwidth()
- * @dev: source/target of request
- * @urb: request (urb-&gt;dev == dev)
- * @isoc: true iff the request is isochronous
- *
- * This records that previously allocated bandwidth has been released.
- * Bandwidth is released when endpoints are removed from the host controller's
- * periodic schedule.
- */
-void usb_release_bandwidth (struct usb_device *dev, struct urb *urb, int isoc)
-{
-	dev-&gt;bus-&gt;bandwidth_allocated -= urb-&gt;bandwidth;
-	if (isoc)
-		dev-&gt;bus-&gt;bandwidth_isoc_reqs--;
-	else
-		dev-&gt;bus-&gt;bandwidth_int_reqs--;
-
-#ifdef USB_BANDWIDTH_MESSAGES
-	dev_dbg (&amp;dev-&gt;dev, "bandwidth alloc reduced by %d (%s) to %d for %d requesters\n",
-		urb-&gt;bandwidth,
-		isoc ? "ISOC" : "INTR",
-		dev-&gt;bus-&gt;bandwidth_allocated,
-		dev-&gt;bus-&gt;bandwidth_int_reqs + dev-&gt;bus-&gt;bandwidth_isoc_reqs);
-#endif
-	urb-&gt;bandwidth = 0;
-}
-EXPORT_SYMBOL (usb_release_bandwidth);
-
 
 /*-------------------------------------------------------------------------*/
 
@@ -1034,11 +902,6 @@ static void urb_unlink (struct urb *urb)
 {
 	unsigned long		flags;
 
-	/* Release any periodic transfer bandwidth */
-	if (urb-&gt;bandwidth)
-		usb_release_bandwidth (urb-&gt;dev, urb,
-			usb_pipeisoc (urb-&gt;pipe));
-
 	/* clear all state linking urb to this dev (and hcd) */
 
 	spin_lock_irqsave (&amp;hcd_data_lock, flags);
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 8f8df0d4382e..2a269ca20517 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -308,10 +308,6 @@ extern void usb_destroy_configuration(struct usb_device *dev);
 #define NS_TO_US(ns)	((ns + 500L) / 1000L)
 			/* convert &amp; round nanoseconds to microseconds */
 
-extern void usb_claim_bandwidth (struct usb_device *dev, struct urb *urb,
-		int bustime, int isoc);
-extern void usb_release_bandwidth (struct usb_device *dev, struct urb *urb,
-		int isoc);
 
 /*
  * Full/low speed bandwidth allocation constants/support.
@@ -324,8 +320,6 @@ extern void usb_release_bandwidth (struct usb_device *dev, struct urb *urb,
 #define FRAME_TIME_MAX_BITS_ALLOC	(90L * FRAME_TIME_BITS / 100L)
 #define FRAME_TIME_MAX_USECS_ALLOC	(90L * FRAME_TIME_USECS / 100L)
 
-extern int usb_check_bandwidth (struct usb_device *dev, struct urb *urb);
-
 /*
  * Ceiling [nano/micro]seconds (typical) for that many bytes at high speed
  * ISO is a bit less, no ACK ... from USB 2.0 spec, 5.11.3 (and needed
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 9801d08edacf..a4fa3e66c307 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -235,7 +235,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 
 	urb-&gt;status = -EINPROGRESS;
 	urb-&gt;actual_length = 0;
-	urb-&gt;bandwidth = 0;
 
 	/* Lots of sanity checks, so HCDs can rely on clean data
 	 * and don't need to duplicate tests
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 1c56386de709..3b08ab39550f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1110,7 +1110,6 @@ struct urb
 	struct kref kref;		/* reference count of the URB */
 	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
-	int bandwidth;			/* bandwidth for INT/ISO request */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
 </pre><hr><pre>commit 3ca2a3211ee5078d49b04fe7149ff2a76473be51
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 16 11:56:32 2007 -0500

    UHCI: fix bandwidth allocation
    
    This patch (as840) fixes the bandwidth allocation mechanism in
    uhci-hcd.  It has never worked correctly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 3fbb5ba80249..5d6c06bc4524 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -168,9 +168,13 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 			space, "", qh, qtype,
 			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		out += sprintf(out, "%*s    period %d frame %x desc [%p]\n",
-				space, "", qh-&gt;period, qh-&gt;iso_frame,
-				qh-&gt;iso_packet_desc);
+		out += sprintf(out, "%*s    period %d phase %d load %d us, "
+				"frame %x desc [%p]\n",
+				space, "", qh-&gt;period, qh-&gt;phase, qh-&gt;load,
+				qh-&gt;iso_frame, qh-&gt;iso_packet_desc);
+	else if (qh-&gt;type == USB_ENDPOINT_XFER_INT)
+		out += sprintf(out, "%*s    period %d phase %d load %d us\n",
+				space, "", qh-&gt;period, qh-&gt;phase, qh-&gt;load);
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
@@ -352,6 +356,17 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
 	out += uhci_show_status(uhci, out, len - (out - buf));
+
+	out += sprintf(out, "Periodic load table\n");
+	for (i = 0; i &lt; MAX_PHASE; ++i) {
+		out += sprintf(out, "\t%d", uhci-&gt;load[i]);
+		if (i % 8 == 7)
+			*out++ = '\n';
+	}
+	out += sprintf(out, "Total: %d, #INT: %d, #ISO: %d\n",
+			uhci-&gt;total_load,
+			uhci_to_hcd(uhci)-&gt;self.bandwidth_int_reqs,
+			uhci_to_hcd(uhci)-&gt;self.bandwidth_isoc_reqs);
 	if (debug &lt;= 1)
 		return out - buf;
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 108e3de2dc26..74469b5bcb61 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -83,6 +83,7 @@
 #define UHCI_MAX_SOF_NUMBER	2047	/* in an SOF packet */
 #define CAN_SCHEDULE_FRAMES	1000	/* how far in the future frames
 					 * can be scheduled */
+#define MAX_PHASE		32	/* Periodic scheduling length */
 
 /* When no queues need Full-Speed Bandwidth Reclamation,
  * delay this long before turning FSBR off */
@@ -141,6 +142,8 @@ struct uhci_qh {
 	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	unsigned int period;		/* For Interrupt and Isochronous QHs */
+	short phase;			/* Between 0 and period-1 */
+	short load;			/* Periodic time requirement, in us */
 	unsigned int iso_frame;		/* Frame # for iso_packet_desc */
 	int iso_status;			/* Status for Isochronous URBs */
 
@@ -153,6 +156,8 @@ struct uhci_qh {
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
 	unsigned int wait_expired:1;	/* QH_WAIT_TIMEOUT has expired */
+	unsigned int bandwidth_reserved:1;	/* Periodic bandwidth has
+						 * been allocated */
 } __attribute__((aligned(16)));
 
 /*
@@ -414,6 +419,9 @@ struct uhci_hcd {
 
 	wait_queue_head_t waitqh;		/* endpoint_disable waiters */
 	int num_waiting;			/* Number of waiters */
+
+	int total_load;				/* Sum of array values */
+	short load[MAX_PHASE];			/* Periodic allocations */
 };
 
 /* Convert between a usb_hcd pointer and the corresponding uhci_hcd */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 5afcc5227284..2cbb239e63f8 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -261,6 +261,14 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 		qh-&gt;udev = udev;
 		hep-&gt;hcpriv = qh;
 
+		if (qh-&gt;type == USB_ENDPOINT_XFER_INT ||
+				qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+			qh-&gt;load = usb_calc_bus_time(udev-&gt;speed,
+					usb_endpoint_dir_in(&amp;hep-&gt;desc),
+					qh-&gt;type == USB_ENDPOINT_XFER_ISOC,
+					le16_to_cpu(hep-&gt;desc.wMaxPacketSize))
+				/ 1000 + 1;
+
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
 		qh-&gt;type = -1;
@@ -496,6 +504,121 @@ static void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		wake_up_all(&amp;uhci-&gt;waitqh);
 }
 
+/*
+ * Find the highest existing bandwidth load for a given phase and period.
+ */
+static int uhci_highest_load(struct uhci_hcd *uhci, int phase, int period)
+{
+	int highest_load = uhci-&gt;load[phase];
+
+	for (phase += period; phase &lt; MAX_PHASE; phase += period)
+		highest_load = max_t(int, highest_load, uhci-&gt;load[phase]);
+	return highest_load;
+}
+
+/*
+ * Set qh-&gt;phase to the optimal phase for a periodic transfer and
+ * check whether the bandwidth requirement is acceptable.
+ */
+static int uhci_check_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	int minimax_load;
+
+	/* Find the optimal phase (unless it is already set) and get
+	 * its load value. */
+	if (qh-&gt;phase &gt;= 0)
+		minimax_load = uhci_highest_load(uhci, qh-&gt;phase, qh-&gt;period);
+	else {
+		int phase, load;
+		int max_phase = min_t(int, MAX_PHASE, qh-&gt;period);
+
+		qh-&gt;phase = 0;
+		minimax_load = uhci_highest_load(uhci, qh-&gt;phase, qh-&gt;period);
+		for (phase = 1; phase &lt; max_phase; ++phase) {
+			load = uhci_highest_load(uhci, phase, qh-&gt;period);
+			if (load &lt; minimax_load) {
+				minimax_load = load;
+				qh-&gt;phase = phase;
+			}
+		}
+	}
+
+	/* Maximum allowable periodic bandwidth is 90%, or 900 us per frame */
+	if (minimax_load + qh-&gt;load &gt; 900) {
+		dev_dbg(uhci_dev(uhci), "bandwidth allocation failed: "
+				"period %d, phase %d, %d + %d us\n",
+				qh-&gt;period, qh-&gt;phase, minimax_load, qh-&gt;load);
+		return -ENOSPC;
+	}
+	return 0;
+}
+
+/*
+ * Reserve a periodic QH's bandwidth in the schedule
+ */
+static void uhci_reserve_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	int i;
+	int load = qh-&gt;load;
+	char *p = "??";
+
+	for (i = qh-&gt;phase; i &lt; MAX_PHASE; i += qh-&gt;period) {
+		uhci-&gt;load[i] += load;
+		uhci-&gt;total_load += load;
+	}
+	uhci_to_hcd(uhci)-&gt;self.bandwidth_allocated =
+			uhci-&gt;total_load / MAX_PHASE;
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_INT:
+		++uhci_to_hcd(uhci)-&gt;self.bandwidth_int_reqs;
+		p = "INT";
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		++uhci_to_hcd(uhci)-&gt;self.bandwidth_isoc_reqs;
+		p = "ISO";
+		break;
+	}
+	qh-&gt;bandwidth_reserved = 1;
+	dev_dbg(uhci_dev(uhci),
+			"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",
+			"reserve", qh-&gt;udev-&gt;devnum,
+			qh-&gt;hep-&gt;desc.bEndpointAddress, p,
+			qh-&gt;period, qh-&gt;phase, load);
+}
+
+/*
+ * Release a periodic QH's bandwidth reservation
+ */
+static void uhci_release_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	int i;
+	int load = qh-&gt;load;
+	char *p = "??";
+
+	for (i = qh-&gt;phase; i &lt; MAX_PHASE; i += qh-&gt;period) {
+		uhci-&gt;load[i] -= load;
+		uhci-&gt;total_load -= load;
+	}
+	uhci_to_hcd(uhci)-&gt;self.bandwidth_allocated =
+			uhci-&gt;total_load / MAX_PHASE;
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_INT:
+		--uhci_to_hcd(uhci)-&gt;self.bandwidth_int_reqs;
+		p = "INT";
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		--uhci_to_hcd(uhci)-&gt;self.bandwidth_isoc_reqs;
+		p = "ISO";
+		break;
+	}
+	qh-&gt;bandwidth_reserved = 0;
+	dev_dbg(uhci_dev(uhci),
+			"%s dev %d ep%02x-%s, period %d, phase %d, %d us\n",
+			"release", qh-&gt;udev-&gt;devnum,
+			qh-&gt;hep-&gt;desc.bEndpointAddress, p,
+			qh-&gt;period, qh-&gt;phase, load);
+}
+
 static inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,
 		struct urb *urb)
 {
@@ -799,7 +922,6 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	wmb();
 	qh-&gt;dummy_td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
 	qh-&gt;dummy_td = td;
-	qh-&gt;period = urb-&gt;interval;
 
 	usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			usb_pipeout(urb-&gt;pipe), toggle);
@@ -830,28 +952,42 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
-	int exponent;
+	int ret;
 
 	/* USB 1.1 interrupt transfers only involve one packet per interval.
 	 * Drivers can submit URBs of any length, but longer ones will need
 	 * multiple intervals to complete.
 	 */
 
-	/* Figure out which power-of-two queue to use */
-	for (exponent = 7; exponent &gt;= 0; --exponent) {
-		if ((1 &lt;&lt; exponent) &lt;= urb-&gt;interval)
-			break;
-	}
-	if (exponent &lt; 0)
-		return -EINVAL;
-	urb-&gt;interval = 1 &lt;&lt; exponent;
+	if (!qh-&gt;bandwidth_reserved) {
+		int exponent;
 
-	if (qh-&gt;period == 0)
+		/* Figure out which power-of-two queue to use */
+		for (exponent = 7; exponent &gt;= 0; --exponent) {
+			if ((1 &lt;&lt; exponent) &lt;= urb-&gt;interval)
+				break;
+		}
+		if (exponent &lt; 0)
+			return -EINVAL;
+		qh-&gt;period = 1 &lt;&lt; exponent;
 		qh-&gt;skel = uhci-&gt;skelqh[UHCI_SKEL_INDEX(exponent)];
-	else if (qh-&gt;period != urb-&gt;interval)
-		return -EINVAL;		/* Can't change the period */
 
-	return uhci_submit_common(uhci, urb, qh);
+		/* For now, interrupt phase is fixed by the layout
+		 * of the QH lists. */
+		qh-&gt;phase = (qh-&gt;period / 2) &amp; (MAX_PHASE - 1);
+		ret = uhci_check_bandwidth(uhci, qh);
+		if (ret)
+			return ret;
+	} else if (qh-&gt;period &gt; urb-&gt;interval)
+		return -EINVAL;		/* Can't decrease the period */
+
+	ret = uhci_submit_common(uhci, urb, qh);
+	if (ret == 0) {
+		urb-&gt;interval = qh-&gt;period;
+		if (!qh-&gt;bandwidth_reserved)
+			uhci_reserve_bandwidth(uhci, qh);
+	}
+	return ret;
 }
 
 /*
@@ -998,15 +1134,32 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		return -EFBIG;
 
 	/* Check the period and figure out the starting frame number */
-	if (qh-&gt;period == 0) {
+	if (!qh-&gt;bandwidth_reserved) {
+		qh-&gt;period = urb-&gt;interval;
 		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+			qh-&gt;phase = -1;		/* Find the best phase */
+			i = uhci_check_bandwidth(uhci, qh);
+			if (i)
+				return i;
+
+			/* Allow a little time to allocate the TDs */
 			uhci_get_current_frame_number(uhci);
-			urb-&gt;start_frame = uhci-&gt;frame_number + 10;
+			frame = uhci-&gt;frame_number + 10;
+
+			/* Move forward to the first frame having the
+			 * correct phase */
+			urb-&gt;start_frame = frame + ((qh-&gt;phase - frame) &amp;
+					(qh-&gt;period - 1));
 		} else {
 			i = urb-&gt;start_frame - uhci-&gt;last_iso_frame;
 			if (i &lt;= 0 || i &gt;= UHCI_NUMFRAMES)
 				return -EINVAL;
+			qh-&gt;phase = urb-&gt;start_frame &amp; (qh-&gt;period - 1);
+			i = uhci_check_bandwidth(uhci, qh);
+			if (i)
+				return i;
 		}
+
 	} else if (qh-&gt;period != urb-&gt;interval) {
 		return -EINVAL;		/* Can't change the period */
 
@@ -1052,9 +1205,6 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	/* Set the interrupt-on-completion flag on the last packet. */
 	td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_IOC);
 
-	qh-&gt;skel = uhci-&gt;skel_iso_qh;
-	qh-&gt;period = urb-&gt;interval;
-
 	/* Add the TDs to the frame list */
 	frame = urb-&gt;start_frame;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
@@ -1068,6 +1218,9 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;iso_status = 0;
 	}
 
+	qh-&gt;skel = uhci-&gt;skel_iso_qh;
+	if (!qh-&gt;bandwidth_reserved)
+		uhci_reserve_bandwidth(uhci, qh);
 	return 0;
 }
 
@@ -1122,7 +1275,6 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	unsigned long flags;
 	struct urb_priv *urbp;
 	struct uhci_qh *qh;
-	int bustime;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
@@ -1152,35 +1304,11 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 		ret = uhci_submit_bulk(uhci, urb, qh);
 		break;
 	case USB_ENDPOINT_XFER_INT:
-		if (list_empty(&amp;qh-&gt;queue)) {
-			bustime = usb_check_bandwidth(urb-&gt;dev, urb);
-			if (bustime &lt; 0)
-				ret = bustime;
-			else {
-				ret = uhci_submit_interrupt(uhci, urb, qh);
-				if (ret == 0)
-					usb_claim_bandwidth(urb-&gt;dev, urb, bustime, 0);
-			}
-		} else {	/* inherit from parent */
-			struct urb_priv *eurbp;
-
-			eurbp = list_entry(qh-&gt;queue.prev, struct urb_priv,
-					node);
-			urb-&gt;bandwidth = eurbp-&gt;urb-&gt;bandwidth;
-			ret = uhci_submit_interrupt(uhci, urb, qh);
-		}
+		ret = uhci_submit_interrupt(uhci, urb, qh);
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
 		urb-&gt;error_count = 0;
-		bustime = usb_check_bandwidth(urb-&gt;dev, urb);
-		if (bustime &lt; 0) {
-			ret = bustime;
-			break;
-		}
-
 		ret = uhci_submit_isochronous(uhci, urb, qh);
-		if (ret == 0)
-			usb_claim_bandwidth(urb-&gt;dev, urb, bustime, 1);
 		break;
 	}
 	if (ret != 0)
@@ -1277,24 +1405,6 @@ __acquires(uhci-&gt;lock)
 
 	uhci_free_urb_priv(uhci, urbp);
 
-	switch (qh-&gt;type) {
-	case USB_ENDPOINT_XFER_ISOC:
-		/* Release bandwidth for Interrupt or Isoc. transfers */
-		if (urb-&gt;bandwidth)
-			usb_release_bandwidth(urb-&gt;dev, urb, 1);
-		break;
-	case USB_ENDPOINT_XFER_INT:
-		/* Release bandwidth for Interrupt or Isoc. transfers */
-		/* Make sure we don't release if we have a queued URB */
-		if (list_empty(&amp;qh-&gt;queue) &amp;&amp; urb-&gt;bandwidth)
-			usb_release_bandwidth(urb-&gt;dev, urb, 0);
-		else
-			/* bandwidth was passed on to queued URB, */
-			/* so don't let usb_unlink_urb() release it */
-			urb-&gt;bandwidth = 0;
-		break;
-	}
-
 	spin_unlock(&amp;uhci-&gt;lock);
 	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);
 	spin_lock(&amp;uhci-&gt;lock);
@@ -1303,9 +1413,8 @@ __acquires(uhci-&gt;lock)
 	 * reserved bandwidth. */
 	if (list_empty(&amp;qh-&gt;queue)) {
 		uhci_unlink_qh(uhci, qh);
-
-		/* Bandwidth stuff not yet implemented */
-		qh-&gt;period = 0;
+		if (qh-&gt;bandwidth_reserved)
+			uhci_release_bandwidth(uhci, qh);
 	}
 }
 </pre><hr><pre>commit f3f4906516a084bbd9aa3da7592e6b029fe78f5b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 16:18:05 2007 -0500

    usb-storage: SCSI level fixes
    
    This patch (as835) removes from usb-storage the code which sets all
    devices to a SCSI level of at least SCSI-2.  The original reasons for
    doing this no longer apply, and in fact it prevents certain kinds of
    ATA pass-thru commands from being used.
    
    The patch also marks CB and CBI devices that are SCSI-0 (legacy SCSI)
    as being single-LUN, since the combined SCSI-over-USB transport
    protocol has no way to convey LUN information to these devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e1072d52d641..70234f5dbeeb 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -110,23 +110,6 @@ static int slave_configure(struct scsi_device *sdev)
 	 * the end, scatter-gather buffers follow page boundaries. */
 	blk_queue_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
-	/* Set the SCSI level to at least 2.  We'll leave it at 3 if that's
-	 * what is originally reported.  We need this to avoid confusing
-	 * the SCSI layer with devices that report 0 or 1, but need 10-byte
-	 * commands (ala ATAPI devices behind certain bridges, or devices
-	 * which simply have broken INQUIRY data).
-	 *
-	 * NOTE: This means /dev/sg programs (ala cdrecord) will get the
-	 * actual information.  This seems to be the preference for
-	 * programs like that.
-	 *
-	 * NOTE: This also means that /proc/scsi/scsi and sysfs may report
-	 * the actual value or the modified one, depending on where the
-	 * data comes from.
-	 */
-	if (sdev-&gt;scsi_level &lt; SCSI_2)
-		sdev-&gt;scsi_level = sdev-&gt;sdev_target-&gt;scsi_level = SCSI_2;
-
 	/* Many devices have trouble transfering more than 32KB at a time,
 	 * while others have trouble with more than 64K. At this time we
 	 * are limiting both to 32K (64 sectores).
@@ -176,7 +159,9 @@ static int slave_configure(struct scsi_device *sdev)
 		 * a Get-Max-LUN request, we won't lose much by setting the
 		 * revision level down to 2.  The only devices that would be
 		 * affected are those with sparse LUNs. */
-		sdev-&gt;scsi_level = sdev-&gt;sdev_target-&gt;scsi_level = SCSI_2;
+		if (sdev-&gt;scsi_level &gt; SCSI_2)
+			sdev-&gt;sdev_target-&gt;scsi_level =
+					sdev-&gt;scsi_level = SCSI_2;
 
 		/* USB-IDE bridges tend to report SK = 0x04 (Non-recoverable
 		 * Hardware Error) when any low-level error occurs,
@@ -194,6 +179,16 @@ static int slave_configure(struct scsi_device *sdev)
 		sdev-&gt;use_10_for_ms = 1;
 	}
 
+	/* The CB and CBI transports have no way to pass LUN values
+	 * other than the bits in the second byte of a CDB.  But those
+	 * bits don't get set to the LUN value if the device reports
+	 * scsi_level == 0 (UNKNOWN).  Hence such devices must necessarily
+	 * be single-LUN.
+	 */
+	if ((us-&gt;protocol == US_PR_CB || us-&gt;protocol == US_PR_CBI) &amp;&amp;
+			sdev-&gt;scsi_level == SCSI_UNKNOWN)
+		us-&gt;max_lun = 0;
+
 	/* Some devices choke when they receive a PREVENT-ALLOW MEDIUM
 	 * REMOVAL command, so suppress those commands. */
 	if (us-&gt;flags &amp; US_FL_NOT_LOCKABLE)</pre><hr><pre>commit 85a975d0ce48dfa8dec5bf1bd970f8fd2c48af32
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 12:01:43 2007 -0500

    UHCI: no dummy TDs for Iso QHs
    
    Isochronous queues don't need a dummy TD because the Queue Header
    isn't managed by the hardware.  This patch (as836) removes the
    unnecessary dummy TDs.
    
    The patch also fixes a long-standing typo in a comment (a "don't" was
    missing -- potentially very confusing!).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index b40bc1ac9b8c..3fbb5ba80249 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -208,7 +208,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 					space, "", nurbs);
 	}
 
-	if (qh-&gt;udev) {
+	if (qh-&gt;dummy_td) {
 		out += sprintf(out, "%*s  Dummy TD\n", space, "");
 		out += uhci_show_td(qh-&gt;dummy_td, out, len - (out - buf), 0);
 	}
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 30b88459ac7d..5afcc5227284 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -248,16 +248,18 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 	INIT_LIST_HEAD(&amp;qh-&gt;node);
 
 	if (udev) {		/* Normal QH */
-		qh-&gt;dummy_td = uhci_alloc_td(uhci);
-		if (!qh-&gt;dummy_td) {
-			dma_pool_free(uhci-&gt;qh_pool, qh, dma_handle);
-			return NULL;
+		qh-&gt;type = hep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
+		if (qh-&gt;type != USB_ENDPOINT_XFER_ISOC) {
+			qh-&gt;dummy_td = uhci_alloc_td(uhci);
+			if (!qh-&gt;dummy_td) {
+				dma_pool_free(uhci-&gt;qh_pool, qh, dma_handle);
+				return NULL;
+			}
 		}
 		qh-&gt;state = QH_STATE_IDLE;
 		qh-&gt;hep = hep;
 		qh-&gt;udev = udev;
 		hep-&gt;hcpriv = qh;
-		qh-&gt;type = hep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
 
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
@@ -275,7 +277,8 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	list_del(&amp;qh-&gt;node);
 	if (qh-&gt;udev) {
 		qh-&gt;hep-&gt;hcpriv = NULL;
-		uhci_free_td(uhci, qh-&gt;dummy_td);
+		if (qh-&gt;dummy_td)
+			uhci_free_td(uhci, qh-&gt;dummy_td);
 	}
 	dma_pool_free(uhci-&gt;qh_pool, qh, qh-&gt;dma_handle);
 }
@@ -327,7 +330,7 @@ static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		goto done;
 	qh-&gt;element = UHCI_PTR_TERM;
 
-	/* Control pipes have to worry about toggles */
+	/* Control pipes don't have to worry about toggles */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
 		goto done;
 </pre><hr><pre>commit f3fe239b67424d88104e32076aec902c0642925f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 8 12:00:28 2007 -0500

    UHCI: improved debugging checks for the frame list
    
    This patch (as768) improves the debugging checks for the uhci-hcd
    frame list.  The number of entries displayed is limited to 10, and the
    driver now checks for the correct Skeleton QH link value at the end of
    each chain of Isochronous TDs.  The code to compute these link values
    is now used in two spots, so it is moved into its own separate
    subroutine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index e345f15b7d87..b40bc1ac9b8c 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -347,6 +347,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	struct uhci_qh *qh;
 	struct uhci_td *td;
 	struct list_head *tmp, *head;
+	int nframes, nerrs;
 
 	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
@@ -355,23 +356,60 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 		return out - buf;
 
 	out += sprintf(out, "Frame List\n");
+	nframes = 10;
+	nerrs = 0;
 	for (i = 0; i &lt; UHCI_NUMFRAMES; ++i) {
+		__le32 link, qh_dma;
+
+		j = 0;
 		td = uhci-&gt;frame_cpu[i];
+		link = uhci-&gt;frame[i];
 		if (!td)
-			continue;
+			goto check_link;
 
-		out += sprintf(out, "- Frame %d\n", i); \
-		if (td-&gt;dma_handle != (dma_addr_t)uhci-&gt;frame[i])
-			out += sprintf(out, "    frame list does not match td-&gt;dma_handle!\n");
+		if (nframes &gt; 0) {
+			out += sprintf(out, "- Frame %d -&gt; (%08x)\n",
+					i, le32_to_cpu(link));
+			j = 1;
+		}
 
 		head = &amp;td-&gt;fl_list;
 		tmp = head;
 		do {
 			td = list_entry(tmp, struct uhci_td, fl_list);
 			tmp = tmp-&gt;next;
-			out += uhci_show_td(td, out, len - (out - buf), 4);
+			if (cpu_to_le32(td-&gt;dma_handle) != link) {
+				if (nframes &gt; 0)
+					out += sprintf(out, "    link does "
+						"not match list entry!\n");
+				else
+					++nerrs;
+			}
+			if (nframes &gt; 0)
+				out += uhci_show_td(td, out,
+						len - (out - buf), 4);
+			link = td-&gt;link;
 		} while (tmp != head);
+
+check_link:
+		qh_dma = uhci_frame_skel_link(uhci, i);
+		if (link != qh_dma) {
+			if (nframes &gt; 0) {
+				if (!j) {
+					out += sprintf(out,
+						"- Frame %d -&gt; (%08x)\n",
+						i, le32_to_cpu(link));
+					j = 1;
+				}
+				out += sprintf(out, "   link does not match "
+					"QH (%08x)!\n", le32_to_cpu(qh_dma));
+			} else
+				++nerrs;
+		}
+		nframes -= j;
 	}
+	if (nerrs &gt; 0)
+		out += sprintf(out, "Skipped %d bad links\n", nerrs);
 
 	out += sprintf(out, "Skeleton QHs\n");
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index e0d4c2358b39..49b9d390b95f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -92,6 +92,34 @@ static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);
 static void wakeup_rh(struct uhci_hcd *uhci);
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 
+/*
+ * Calculate the link pointer DMA value for the first Skeleton QH in a frame.
+ */
+static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
+{
+	int skelnum;
+
+	/*
+	 * The interrupt queues will be interleaved as evenly as possible.
+	 * There's not much to be done about period-1 interrupts; they have
+	 * to occur in every frame.  But we can schedule period-2 interrupts
+	 * in odd-numbered frames, period-4 interrupts in frames congruent
+	 * to 2 (mod 4), and so on.  This way each frame only has two
+	 * interrupt QHs, which will help spread out bandwidth utilization.
+	 *
+	 * ffs (Find First bit Set) does exactly what we need:
+	 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[8],
+	 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[7], etc.
+	 * ffs &gt;= 7 =&gt; not on any high-period queue, so use
+	 *	skel_int1_qh = skelqh[9].
+	 * Add in UHCI_NUMFRAMES to insure at least one bit is set.
+	 */
+	skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
+	if (skelnum &lt;= 1)
+		skelnum = 9;
+	return UHCI_PTR_QH | cpu_to_le32(uhci-&gt;skelqh[skelnum]-&gt;dma_handle);
+}
+
 #include "uhci-debug.c"
 #include "uhci-q.c"
 #include "uhci-hub.c"
@@ -631,32 +659,11 @@ static int uhci_start(struct usb_hcd *hcd)
 	/*
 	 * Fill the frame list: make all entries point to the proper
 	 * interrupt queue.
-	 *
-	 * The interrupt queues will be interleaved as evenly as possible.
-	 * There's not much to be done about period-1 interrupts; they have
-	 * to occur in every frame.  But we can schedule period-2 interrupts
-	 * in odd-numbered frames, period-4 interrupts in frames congruent
-	 * to 2 (mod 4), and so on.  This way each frame only has two
-	 * interrupt QHs, which will help spread out bandwidth utilization.
 	 */
 	for (i = 0; i &lt; UHCI_NUMFRAMES; i++) {
-		int irq;
-
-		/*
-		 * ffs (Find First bit Set) does exactly what we need:
-		 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[8],
-		 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[7], etc.
-		 * ffs &gt;= 7 =&gt; not on any high-period queue, so use
-		 *	skel_int1_qh = skelqh[9].
-		 * Add UHCI_NUMFRAMES to insure at least one bit is set.
-		 */
-		irq = 8 - (int) __ffs(i + UHCI_NUMFRAMES);
-		if (irq &lt;= 1)
-			irq = 9;
 
 		/* Only place we don't use the frame list routines */
-		uhci-&gt;frame[i] = UHCI_PTR_QH |
-				cpu_to_le32(uhci-&gt;skelqh[irq]-&gt;dma_handle);
+		uhci-&gt;frame[i] = uhci_frame_skel_link(uhci, i);
 	}
 
 	/*</pre>
    <div class="pagination">
        <a href='2_113.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><span>[114]</span><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_115.html'>Next&gt;&gt;</a>
    <div>
</body>
