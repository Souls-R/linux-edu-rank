<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Georgia</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Georgia</h1>
    <div class="pagination">
        <a href='19_3.html'>&lt;&lt;Prev</a><a href='19.html'>1</a><a href='19_2.html'>2</a><a href='19_3.html'>3</a><span>[4]</span><a href='19_5.html'>5</a><a href='19_6.html'>6</a><a href='19_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2323d7baab2b18d87d9bc267452e387aa9f0060a
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Sun Aug 18 13:54:46 2019 -0500

    infiniband: hfi1: fix memory leaks
    
    In fault_opcodes_write(), 'data' is allocated through kcalloc(). However,
    it is not deallocated in the following execution if an error occurs,
    leading to memory leaks. To fix this issue, introduce the 'free_data' label
    to free 'data' before returning the error.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@mellanox.com&gt;
    Acked-by: Dennis Dalessandro &lt;dennis.dalessandro@intel.com&gt;
    Link: https://lore.kernel.org/r/1566154486-3713-1-git-send-email-wenwen@cs.uga.edu
    Signed-off-by: Doug Ledford &lt;dledford@redhat.com&gt;

diff --git a/drivers/infiniband/hw/hfi1/fault.c b/drivers/infiniband/hw/hfi1/fault.c
index 814324d17295..986c12153e62 100644
--- a/drivers/infiniband/hw/hfi1/fault.c
+++ b/drivers/infiniband/hw/hfi1/fault.c
@@ -141,12 +141,14 @@ static ssize_t fault_opcodes_write(struct file *file, const char __user *buf,
 	if (!data)
 		return -ENOMEM;
 	copy = min(len, datalen - 1);
-	if (copy_from_user(data, buf, copy))
-		return -EFAULT;
+	if (copy_from_user(data, buf, copy)) {
+		ret = -EFAULT;
+		goto free_data;
+	}
 
 	ret = debugfs_file_get(file-&gt;f_path.dentry);
 	if (unlikely(ret))
-		return ret;
+		goto free_data;
 	ptr = data;
 	token = ptr;
 	for (ptr = data; *ptr; ptr = end + 1, token = ptr) {
@@ -195,6 +197,7 @@ static ssize_t fault_opcodes_write(struct file *file, const char __user *buf,
 	ret = len;
 
 	debugfs_file_put(file-&gt;f_path.dentry);
+free_data:
 	kfree(data);
 	return ret;
 }</pre><hr><pre>commit b08afa064c320e5d85cdc27228426b696c4c8dae
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Sun Aug 18 14:29:31 2019 -0500

    infiniband: hfi1: fix a memory leak bug
    
    In fault_opcodes_read(), 'data' is not deallocated if debugfs_file_get()
    fails, leading to a memory leak. To fix this bug, introduce the 'free_data'
    label to free 'data' before returning the error.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@mellanox.com&gt;
    Acked-by: Dennis Dalessandro &lt;dennis.dalessandro@intel.com&gt;
    Link: https://lore.kernel.org/r/1566156571-4335-1-git-send-email-wenwen@cs.uga.edu
    Signed-off-by: Doug Ledford &lt;dledford@redhat.com&gt;

diff --git a/drivers/infiniband/hw/hfi1/fault.c b/drivers/infiniband/hw/hfi1/fault.c
index 93613e5def9b..814324d17295 100644
--- a/drivers/infiniband/hw/hfi1/fault.c
+++ b/drivers/infiniband/hw/hfi1/fault.c
@@ -214,7 +214,7 @@ static ssize_t fault_opcodes_read(struct file *file, char __user *buf,
 		return -ENOMEM;
 	ret = debugfs_file_get(file-&gt;f_path.dentry);
 	if (unlikely(ret))
-		return ret;
+		goto free_data;
 	bit = find_first_bit(fault-&gt;opcodes, bitsize);
 	while (bit &lt; bitsize) {
 		zero = find_next_zero_bit(fault-&gt;opcodes, bitsize, bit);
@@ -232,6 +232,7 @@ static ssize_t fault_opcodes_read(struct file *file, char __user *buf,
 	data[size - 1] = '\n';
 	data[size] = '\0';
 	ret = simple_read_from_buffer(buf, len, pos, data, size);
+free_data:
 	kfree(data);
 	return ret;
 }</pre><hr><pre>commit 5c1baaa82cea2c815a5180ded402a7cd455d1810
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Sun Aug 18 15:23:01 2019 -0500

    IB/mlx4: Fix memory leaks
    
    In mlx4_ib_alloc_pv_bufs(), 'tun_qp-&gt;tx_ring' is allocated through
    kcalloc(). However, it is not always deallocated in the following execution
    if an error occurs, leading to memory leaks. To fix this issue, free
    'tun_qp-&gt;tx_ring' whenever an error occurs.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Acked-by: Leon Romanovsky &lt;leonro@mellanox.com&gt;
    Link: https://lore.kernel.org/r/1566159781-4642-1-git-send-email-wenwen@cs.uga.edu
    Signed-off-by: Doug Ledford &lt;dledford@redhat.com&gt;

diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c
index 68c951491a08..57079110af9b 100644
--- a/drivers/infiniband/hw/mlx4/mad.c
+++ b/drivers/infiniband/hw/mlx4/mad.c
@@ -1677,8 +1677,6 @@ static int mlx4_ib_alloc_pv_bufs(struct mlx4_ib_demux_pv_ctx *ctx,
 				    tx_buf_size, DMA_TO_DEVICE);
 		kfree(tun_qp-&gt;tx_ring[i].buf.addr);
 	}
-	kfree(tun_qp-&gt;tx_ring);
-	tun_qp-&gt;tx_ring = NULL;
 	i = MLX4_NUM_TUNNEL_BUFS;
 err:
 	while (i &gt; 0) {
@@ -1687,6 +1685,8 @@ static int mlx4_ib_alloc_pv_bufs(struct mlx4_ib_demux_pv_ctx *ctx,
 				    rx_buf_size, DMA_FROM_DEVICE);
 		kfree(tun_qp-&gt;ring[i].addr);
 	}
+	kfree(tun_qp-&gt;tx_ring);
+	tun_qp-&gt;tx_ring = NULL;
 	kfree(tun_qp-&gt;ring);
 	tun_qp-&gt;ring = NULL;
 	return -ENOMEM;</pre><hr><pre>commit 962411b05a6d3342aa649e39cda1704c1fc042c6
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Fri Aug 16 01:56:08 2019 -0500

    dmaengine: ti: omap-dma: Add cleanup in omap_dma_probe()
    
    If devm_request_irq() fails to disable all interrupts, no cleanup is
    performed before retuning the error. To fix this issue, invoke
    omap_dma_free() to do the cleanup.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Acked-by: Peter Ujfalusi &lt;peter.ujfalusi@ti.com&gt;
    Link: https://lore.kernel.org/r/1565938570-7528-1-git-send-email-wenwen@cs.uga.edu
    Signed-off-by: Vinod Koul &lt;vkoul@kernel.org&gt;

diff --git a/drivers/dma/ti/omap-dma.c b/drivers/dma/ti/omap-dma.c
index ba27802efcd0..d07c0d5de7a2 100644
--- a/drivers/dma/ti/omap-dma.c
+++ b/drivers/dma/ti/omap-dma.c
@@ -1540,8 +1540,10 @@ static int omap_dma_probe(struct platform_device *pdev)
 
 		rc = devm_request_irq(&amp;pdev-&gt;dev, irq, omap_dma_irq,
 				      IRQF_SHARED, "omap-dma-engine", od);
-		if (rc)
+		if (rc) {
+			omap_dma_free(od);
 			return rc;
+		}
 	}
 
 	if (omap_dma_glbl_read(od, CAPS_0) &amp; CAPS_0_SUPPORT_LL123)</pre><hr><pre>commit 2c231c0c1dec42192aca0f87f2dc68b8f0cbc7d2
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Fri Aug 16 01:48:55 2019 -0500

    dmaengine: ti: dma-crossbar: Fix a memory leak bug
    
    In ti_dra7_xbar_probe(), 'rsv_events' is allocated through kcalloc(). Then
    of_property_read_u32_array() is invoked to search for the property.
    However, if this process fails, 'rsv_events' is not deallocated, leading to
    a memory leak bug. To fix this issue, free 'rsv_events' before returning
    the error.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Acked-by: Peter Ujfalusi &lt;peter.ujfalusi@ti.com&gt;
    Link: https://lore.kernel.org/r/1565938136-7249-1-git-send-email-wenwen@cs.uga.edu
    Signed-off-by: Vinod Koul &lt;vkoul@kernel.org&gt;

diff --git a/drivers/dma/ti/dma-crossbar.c b/drivers/dma/ti/dma-crossbar.c
index ad2f0a4cd6a4..f255056696ee 100644
--- a/drivers/dma/ti/dma-crossbar.c
+++ b/drivers/dma/ti/dma-crossbar.c
@@ -391,8 +391,10 @@ static int ti_dra7_xbar_probe(struct platform_device *pdev)
 
 		ret = of_property_read_u32_array(node, pname, (u32 *)rsv_events,
 						 nelm * 2);
-		if (ret)
+		if (ret) {
+			kfree(rsv_events);
 			return ret;
+		}
 
 		for (i = 0; i &lt; nelm; i++) {
 			ti_dra7_xbar_reserve(rsv_events[i][0], rsv_events[i][1],</pre><hr><pre>commit cfddf9f4c9f038c91c6c61d5cf3a161731b5c418
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Mon Aug 19 18:47:34 2019 -0500

    locks: fix a memory leak bug in __break_lease()
    
    In __break_lease(), the file lock 'new_fl' is allocated in lease_alloc().
    However, it is not deallocated in the following execution if
    smp_load_acquire() fails, leading to a memory leak bug. To fix this issue,
    free 'new_fl' before returning the error.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Signed-off-by: Jeff Layton &lt;jlayton@kernel.org&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 24d1db632f6c..a364ebc5cec3 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1592,7 +1592,7 @@ int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)
 	ctx = smp_load_acquire(&amp;inode-&gt;i_flctx);
 	if (!ctx) {
 		WARN_ON_ONCE(1);
-		return error;
+		goto free_lock;
 	}
 
 	percpu_down_read(&amp;file_rwsem);
@@ -1672,6 +1672,7 @@ int __break_lease(struct inode *inode, unsigned int mode, unsigned int type)
 	spin_unlock(&amp;ctx-&gt;flc_lock);
 	percpu_up_read(&amp;file_rwsem);
 	locks_dispose_list(&amp;dispose);
+free_lock:
 	locks_free_lock(new_fl);
 	return error;
 }</pre><hr><pre>commit b4a81b87a4cfe2bb26a4a943b748d96a43ef20e8
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Tue Aug 20 00:33:54 2019 -0500

    ecryptfs: fix a memory leak bug in ecryptfs_init_messaging()
    
    In ecryptfs_init_messaging(), if the allocation for 'ecryptfs_msg_ctx_arr'
    fails, the previously allocated 'ecryptfs_daemon_hash' is not deallocated,
    leading to a memory leak bug. To fix this issue, free
    'ecryptfs_daemon_hash' before returning the error.
    
    Cc: stable@vger.kernel.org
    Fixes: 88b4a07e6610 ("[PATCH] eCryptfs: Public key transport mechanism")
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Signed-off-by: Tyler Hicks &lt;tyhicks@canonical.com&gt;

diff --git a/fs/ecryptfs/messaging.c b/fs/ecryptfs/messaging.c
index d668e60b85b5..c05ca39aa449 100644
--- a/fs/ecryptfs/messaging.c
+++ b/fs/ecryptfs/messaging.c
@@ -379,6 +379,7 @@ int __init ecryptfs_init_messaging(void)
 					* ecryptfs_message_buf_len),
 				       GFP_KERNEL);
 	if (!ecryptfs_msg_ctx_arr) {
+		kfree(ecryptfs_daemon_hash);
 		rc = -ENOMEM;
 		goto out;
 	}</pre><hr><pre>commit fe2e082f5da5b4a0a92ae32978f81507ef37ec66
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Tue Aug 20 00:16:40 2019 -0500

    ecryptfs: fix a memory leak bug in parse_tag_1_packet()
    
    In parse_tag_1_packet(), if tag 1 packet contains a key larger than
    ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES, no cleanup is executed, leading to a
    memory leak on the allocated 'auth_tok_list_item'. To fix this issue, go to
    the label 'out_free' to perform the cleanup work.
    
    Cc: stable@vger.kernel.org
    Fixes: dddfa461fc89 ("[PATCH] eCryptfs: Public key; packet management")
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Signed-off-by: Tyler Hicks &lt;tyhicks@canonical.com&gt;

diff --git a/fs/ecryptfs/keystore.c b/fs/ecryptfs/keystore.c
index 216fbe6a4837..4dc09638de8f 100644
--- a/fs/ecryptfs/keystore.c
+++ b/fs/ecryptfs/keystore.c
@@ -1304,7 +1304,7 @@ parse_tag_1_packet(struct ecryptfs_crypt_stat *crypt_stat,
 		printk(KERN_WARNING "Tag 1 packet contains key larger "
 		       "than ECRYPTFS_MAX_ENCRYPTED_KEY_BYTES\n");
 		rc = -EINVAL;
-		goto out;
+		goto out_free;
 	}
 	memcpy((*new_auth_tok)-&gt;session_key.encrypted_key,
 	       &amp;data[(*packet_size)], (body_size - (ECRYPTFS_SIG_SIZE + 2)));</pre><hr><pre>commit 44ef3a03252844a8753479b0cea7f29e4a804bdc
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Thu Aug 15 15:29:51 2019 -0500

    wimax/i2400m: fix a memory leak bug
    
    In i2400m_barker_db_init(), 'options_orig' is allocated through kstrdup()
    to hold the original command line options. Then, the options are parsed.
    However, if an error occurs during the parsing process, 'options_orig' is
    not deallocated, leading to a memory leak bug. To fix this issue, free
    'options_orig' before returning the error.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/wimax/i2400m/fw.c b/drivers/net/wimax/i2400m/fw.c
index e9fc168bb734..489cba9b284d 100644
--- a/drivers/net/wimax/i2400m/fw.c
+++ b/drivers/net/wimax/i2400m/fw.c
@@ -351,13 +351,15 @@ int i2400m_barker_db_init(const char *_options)
 			}
 			result = i2400m_barker_db_add(barker);
 			if (result &lt; 0)
-				goto error_add;
+				goto error_parse_add;
 		}
 		kfree(options_orig);
 	}
 	return 0;
 
+error_parse_add:
 error_parse:
+	kfree(options_orig);
 error_add:
 	kfree(i2400m_barker_db);
 	return result;</pre><hr><pre>commit f1472cb09f11ddb41d4be84f0650835cb65a9073
Author: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
Date:   Wed Aug 14 13:56:43 2019 -0500

    net: kalmia: fix memory leaks
    
    In kalmia_init_and_get_ethernet_addr(), 'usb_buf' is allocated through
    kmalloc(). In the following execution, if the 'status' returned by
    kalmia_send_init_packet() is not 0, 'usb_buf' is not deallocated, leading
    to memory leaks. To fix this issue, add the 'out' label to free 'usb_buf'.
    
    Signed-off-by: Wenwen Wang &lt;wenwen@cs.uga.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/usb/kalmia.c b/drivers/net/usb/kalmia.c
index d62b6706a537..fc5895f85cee 100644
--- a/drivers/net/usb/kalmia.c
+++ b/drivers/net/usb/kalmia.c
@@ -113,16 +113,16 @@ kalmia_init_and_get_ethernet_addr(struct usbnet *dev, u8 *ethernet_addr)
 	status = kalmia_send_init_packet(dev, usb_buf, ARRAY_SIZE(init_msg_1),
 					 usb_buf, 24);
 	if (status != 0)
-		return status;
+		goto out;
 
 	memcpy(usb_buf, init_msg_2, 12);
 	status = kalmia_send_init_packet(dev, usb_buf, ARRAY_SIZE(init_msg_2),
 					 usb_buf, 28);
 	if (status != 0)
-		return status;
+		goto out;
 
 	memcpy(ethernet_addr, usb_buf + 10, ETH_ALEN);
-
+out:
 	kfree(usb_buf);
 	return status;
 }</pre>
    <div class="pagination">
        <a href='19_3.html'>&lt;&lt;Prev</a><a href='19.html'>1</a><a href='19_2.html'>2</a><a href='19_3.html'>3</a><span>[4]</span><a href='19_5.html'>5</a><a href='19_6.html'>6</a><a href='19_5.html'>Next&gt;&gt;</a>
    <div>
</body>
