<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_11.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><span>[12]</span><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_13.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6e49949c5e9e04d64e16df3723dd3f5bd25a29e2
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Sun Apr 25 07:03:57 2010 -0500

    [SCSI] Log msg when getting Unit Attention
    
    If the user accidentally changes LUN mappings or it occurs
    due to a bug, then it can cause data corruption that can take
    months and months to track down. This patch adds a log
    message when getting REPORT_LUNS_DATA_CHANGED and it adds
    a generic message for other Unit Attentions with asc == 0x3f.
    
    We are working on adding support for handling of these errors,
    but I think until then we should at least log a message so
    tracking down problems as a result of one of these changes
    is a little easier.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
index a5d630f5f519..c60cffbefa3c 100644
--- a/drivers/scsi/scsi_error.c
+++ b/drivers/scsi/scsi_error.c
@@ -307,6 +307,19 @@ static int scsi_check_sense(struct scsi_cmnd *scmd)
 		    (sshdr.asc == 0x04) &amp;&amp; (sshdr.ascq == 0x02))
 			return FAILED;
 
+		if (sshdr.asc == 0x3f &amp;&amp; sshdr.ascq == 0x0e)
+			scmd_printk(KERN_WARNING, scmd,
+				    "Warning! Received an indication that the "
+				    "LUN assignments on this target have "
+				    "changed. The Linux SCSI layer does not "
+				    "automatically remap LUN assignments.\n");
+		else if (sshdr.asc == 0x3f)
+			scmd_printk(KERN_WARNING, scmd,
+				    "Warning! Received an indication that the "
+				    "operating parameters on this target have "
+				    "changed. The Linux SCSI layer does not "
+				    "automatically adjust these parameters.\n");
+
 		if (blk_barrier_rq(scmd-&gt;request))
 			/*
 			 * barrier requests should always retry on UA</pre><hr><pre>commit fa95d206e4a4fb549bdb9fe71091417f4912178f
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Jun 9 03:30:08 2010 -0500

    [SCSI] be2iscsi: fix disconnection cleanup
    
    This patch fixes 4 bugs in the connection connect/disconnect
    cleanup path.
    
    1. If beiscsi_open_conn fails beiscsi_free_ep was always being
    called, and if beiscsi_open_conn failed because beiscsi_get_cid
    failed then we would free an unallocated cid.
    
    2. If beiscsi_ep_connect failed due to a beiscsi_open_conn failure
    it was leaking iscsi_endpoints.
    
    3. beiscsi_ep_disconnect was leaking iscsi_endpoints.
    beiscsi_ep_disconnect should free the iscsi_endpoint. We cannot
    do it in beiscsi_conn_stop because that is only called for
    iscsi connection cleanup. If beiscsi_ep_connect returns
    success, but then the poll function fails or the connect
    times out then beiscsi_ep_disconnect will be called to clean
    up the ep. The conn_stop callout will not be called in that path.
    
    4. beiscsi_conn_stop was freeing the iscsi_endpoint then accessing
    it a couple lines later.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c
index c3928cb8b042..454027ccbf16 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -441,6 +441,31 @@ static int beiscsi_get_cid(struct beiscsi_hba *phba)
 	return cid;
 }
 
+/**
+ * beiscsi_put_cid - Free the cid
+ * @phba: The phba for which the cid is being freed
+ * @cid: The cid to free
+ */
+static void beiscsi_put_cid(struct beiscsi_hba *phba, unsigned short cid)
+{
+	phba-&gt;avlbl_cids++;
+	phba-&gt;cid_array[phba-&gt;cid_free++] = cid;
+	if (phba-&gt;cid_free == phba-&gt;params.cxns_per_ctrl)
+		phba-&gt;cid_free = 0;
+}
+
+/**
+ * beiscsi_free_ep - free endpoint
+ * @ep:	pointer to iscsi endpoint structure
+ */
+static void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep)
+{
+	struct beiscsi_hba *phba = beiscsi_ep-&gt;phba;
+
+	beiscsi_put_cid(phba, beiscsi_ep-&gt;ep_cid);
+	beiscsi_ep-&gt;phba = NULL;
+}
+
 /**
  * beiscsi_open_conn - Ask FW to open a TCP connection
  * @ep:	endpoint to be used
@@ -475,7 +500,7 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 	if (beiscsi_ep-&gt;ep_cid &gt; (phba-&gt;fw_config.iscsi_cid_start +
 				  phba-&gt;params.cxns_per_ctrl * 2)) {
 		SE_DEBUG(DBG_LVL_1, "Failed in allocate iscsi cid\n");
-		return ret;
+		goto free_ep;
 	}
 
 	beiscsi_ep-&gt;cid_vld = 0;
@@ -493,10 +518,10 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 	status = phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x000000FF;
 	if (status || extd_status) {
 		SE_DEBUG(DBG_LVL_1, "mgmt_open_connection Failed"
-				    " status = %d extd_status = %d \n",
+				    " status = %d extd_status = %d\n",
 				    status, extd_status);
 		free_mcc_tag(&amp;phba-&gt;ctrl, tag);
-		return -1;
+		goto free_ep;
 	} else {
 		wrb = queue_get_wrb(mccq, wrb_num);
 		free_mcc_tag(&amp;phba-&gt;ctrl, tag);
@@ -508,31 +533,10 @@ static int beiscsi_open_conn(struct iscsi_endpoint *ep,
 		SE_DEBUG(DBG_LVL_8, "mgmt_open_connection Success\n");
 	}
 	return 0;
-}
-
-/**
- * beiscsi_put_cid - Free the cid
- * @phba: The phba for which the cid is being freed
- * @cid: The cid to free
- */
-static void beiscsi_put_cid(struct beiscsi_hba *phba, unsigned short cid)
-{
-	phba-&gt;avlbl_cids++;
-	phba-&gt;cid_array[phba-&gt;cid_free++] = cid;
-	if (phba-&gt;cid_free == phba-&gt;params.cxns_per_ctrl)
-		phba-&gt;cid_free = 0;
-}
-
-/**
- * beiscsi_free_ep - free endpoint
- * @ep:	pointer to iscsi endpoint structure
- */
-static void beiscsi_free_ep(struct beiscsi_endpoint *beiscsi_ep)
-{
-	struct beiscsi_hba *phba = beiscsi_ep-&gt;phba;
 
-	beiscsi_put_cid(phba, beiscsi_ep-&gt;ep_cid);
-	beiscsi_ep-&gt;phba = NULL;
+free_ep:
+	beiscsi_free_ep(beiscsi_ep);
+	return -1;
 }
 
 /**
@@ -585,7 +589,7 @@ beiscsi_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,
 	return ep;
 
 free_ep:
-	beiscsi_free_ep(beiscsi_ep);
+	iscsi_destroy_endpoint(ep);
 	return ERR_PTR(ret);
 }
 
@@ -631,30 +635,6 @@ static int beiscsi_close_conn(struct  beiscsi_endpoint *beiscsi_ep, int flag)
 	return ret;
 }
 
-/**
- * beiscsi_ep_disconnect - Tears down the TCP connection
- * @ep:	endpoint to be used
- *
- * Tears down the TCP connection
- */
-void beiscsi_ep_disconnect(struct iscsi_endpoint *ep)
-{
-	struct beiscsi_conn *beiscsi_conn;
-	struct beiscsi_endpoint *beiscsi_ep;
-	struct beiscsi_hba *phba;
-
-	beiscsi_ep = ep-&gt;dd_data;
-	phba = beiscsi_ep-&gt;phba;
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect for ep_cid = %d\n",
-			     beiscsi_ep-&gt;ep_cid);
-
-	if (beiscsi_ep-&gt;conn) {
-		beiscsi_conn = beiscsi_ep-&gt;conn;
-		iscsi_suspend_queue(beiscsi_conn-&gt;conn);
-	}
-
-}
-
 /**
  * beiscsi_unbind_conn_to_cid - Unbind the beiscsi_conn from phba conn table
  * @phba: The phba instance
@@ -673,28 +653,35 @@ static int beiscsi_unbind_conn_to_cid(struct beiscsi_hba *phba,
 }
 
 /**
- * beiscsi_conn_stop - Invalidate and stop the connection
- * @cls_conn: pointer to get iscsi_conn
- * @flag: The type of connection closure
+ * beiscsi_ep_disconnect - Tears down the TCP connection
+ * @ep:	endpoint to be used
+ *
+ * Tears down the TCP connection
  */
-void beiscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
+void beiscsi_ep_disconnect(struct iscsi_endpoint *ep)
 {
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct beiscsi_conn *beiscsi_conn = conn-&gt;dd_data;
+	struct beiscsi_conn *beiscsi_conn;
 	struct beiscsi_endpoint *beiscsi_ep;
-	struct iscsi_session *session = conn-&gt;session;
-	struct Scsi_Host *shost = iscsi_session_to_shost(session-&gt;cls_session);
-	struct beiscsi_hba *phba = iscsi_host_priv(shost);
+	struct beiscsi_hba *phba;
 	unsigned int tag;
 	unsigned short savecfg_flag = CMD_ISCSI_SESSION_SAVE_CFG_ON_FLASH;
 
-	beiscsi_ep = beiscsi_conn-&gt;ep;
-	if (!beiscsi_ep) {
-		SE_DEBUG(DBG_LVL_8, "In beiscsi_conn_stop , no beiscsi_ep\n");
+	beiscsi_ep = ep-&gt;dd_data;
+	phba = beiscsi_ep-&gt;phba;
+	SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect for ep_cid = %d\n",
+			     beiscsi_ep-&gt;ep_cid);
+
+	if (!beiscsi_ep-&gt;conn) {
+		SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect, no "
+			 "beiscsi_ep\n");
 		return;
 	}
-	SE_DEBUG(DBG_LVL_8, "In beiscsi_conn_stop  ep_cid = %d\n",
-			     beiscsi_ep-&gt;ep_cid);
+	beiscsi_conn = beiscsi_ep-&gt;conn;
+	iscsi_suspend_queue(beiscsi_conn-&gt;conn);
+
+	SE_DEBUG(DBG_LVL_8, "In beiscsi_ep_disconnect ep_cid = %d\n",
+		 beiscsi_ep-&gt;ep_cid);
+
 	tag = mgmt_invalidate_connection(phba, beiscsi_ep,
 					    beiscsi_ep-&gt;ep_cid, 1,
 					    savecfg_flag);
@@ -707,9 +694,9 @@ void beiscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 					 phba-&gt;ctrl.mcc_numtag[tag]);
 		free_mcc_tag(&amp;phba-&gt;ctrl, tag);
 	}
+
 	beiscsi_close_conn(beiscsi_ep, CONNECTION_UPLOAD_GRACEFUL);
 	beiscsi_free_ep(beiscsi_ep);
-	iscsi_destroy_endpoint(beiscsi_ep-&gt;openiscsi_ep);
 	beiscsi_unbind_conn_to_cid(phba, beiscsi_ep-&gt;ep_cid);
-	iscsi_conn_stop(cls_conn, flag);
+	iscsi_destroy_endpoint(beiscsi_ep-&gt;openiscsi_ep);
 }
diff --git a/drivers/scsi/be2iscsi/be_iscsi.h b/drivers/scsi/be2iscsi/be_iscsi.h
index 1f512c28cbf9..870cdb2a73e4 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.h
+++ b/drivers/scsi/be2iscsi/be_iscsi.h
@@ -59,8 +59,6 @@ int beiscsi_set_param(struct iscsi_cls_conn *cls_conn,
 
 int beiscsi_conn_start(struct iscsi_cls_conn *cls_conn);
 
-void beiscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag);
-
 struct iscsi_endpoint *beiscsi_ep_connect(struct Scsi_Host *shost,
 					  struct sockaddr *dst_addr,
 					  int non_blocking);
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index dd5b105f8f47..854414551bb0 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -3955,7 +3955,7 @@ struct iscsi_transport beiscsi_iscsi_transport = {
 	.get_session_param = iscsi_session_get_param,
 	.get_host_param = beiscsi_get_host_param,
 	.start_conn = beiscsi_conn_start,
-	.stop_conn = beiscsi_conn_stop,
+	.stop_conn = iscsi_conn_stop,
 	.send_pdu = iscsi_conn_send_pdu,
 	.xmit_task = beiscsi_task_xmit,
 	.cleanup_task = beiscsi_cleanup_task,</pre><hr><pre>commit 8c38a2951026e6b428d3ce6e518d123c35becd18
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri May 21 18:24:16 2010 -0500

    [SCSI] iscsi_tcp: remove sk_sleep check
    
    There is no need to call sk_sleep before calling wake_up_interruptible,
    because the wait_queue_head is now with the socket.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index bf55d3057413..fec47de72535 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -601,10 +601,8 @@ static void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
 	write_unlock_bh(&amp;tcp_sw_conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
 
-	if (sk_sleep(sock-&gt;sk)) {
-		sock-&gt;sk-&gt;sk_err = EIO;
-		wake_up_interruptible(sk_sleep(sock-&gt;sk));
-	}
+	sock-&gt;sk-&gt;sk_err = EIO;
+	wake_up_interruptible(sk_sleep(sock-&gt;sk));
 
 	iscsi_conn_stop(cls_conn, flag);
 	iscsi_sw_tcp_release_conn(conn);</pre><hr><pre>commit b33a84a384776fb2593dac4d77c72050f9e181b0
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Apr 12 18:06:18 2010 +0000

    ibft: convert iscsi_ibft module to iscsi boot lib
    
    This patch just converts the iscsi_ibft module to the
    iscsi boot sysfs lib module.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Konrad Rzeszutek Wilk &lt;konrad@kernel.org&gt;
    Signed-off-by: Peter Jones &lt;pjones@redhat.com&gt;

diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 571d2182613d..a6c670b8ce52 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -132,6 +132,7 @@ config ISCSI_BOOT_SYSFS
 
 config ISCSI_IBFT
 	tristate "iSCSI Boot Firmware Table Attributes module"
+	select ISCSI_BOOT_SYSFS
 	depends on ISCSI_IBFT_FIND
 	default	n
 	help
diff --git a/drivers/firmware/iscsi_ibft.c b/drivers/firmware/iscsi_ibft.c
index b3ab24f9d78f..4f04ec0410a0 100644
--- a/drivers/firmware/iscsi_ibft.c
+++ b/drivers/firmware/iscsi_ibft.c
@@ -82,6 +82,7 @@
 #include &lt;linux/string.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/acpi.h&gt;
+#include &lt;linux/iscsi_boot_sysfs.h&gt;
 
 #define IBFT_ISCSI_VERSION "0.5.0"
 #define IBFT_ISCSI_DATE "2010-Feb-25"
@@ -169,74 +170,6 @@ enum ibft_id {
 	id_end_marker,
 };
 
-/*
- * We do not support the other types, hence the usage of NULL.
- * This maps to the enum ibft_id.
- */
-static const char *ibft_id_names[] =
-	{NULL, NULL, "initiator", "ethernet%d", "target%d", NULL, NULL};
-
-/*
- * The text attributes names for each of the kobjects.
-*/
-enum ibft_eth_properties_enum {
-	ibft_eth_index,
-	ibft_eth_flags,
-	ibft_eth_ip_addr,
-	ibft_eth_subnet_mask,
-	ibft_eth_origin,
-	ibft_eth_gateway,
-	ibft_eth_primary_dns,
-	ibft_eth_secondary_dns,
-	ibft_eth_dhcp,
-	ibft_eth_vlan,
-	ibft_eth_mac,
-	/* ibft_eth_pci_bdf - this is replaced by link to the device itself. */
-	ibft_eth_hostname,
-	ibft_eth_end_marker,
-};
-
-static const char *ibft_eth_properties[] =
-	{"index", "flags", "ip-addr", "subnet-mask", "origin", "gateway",
-	"primary-dns", "secondary-dns", "dhcp", "vlan", "mac", "hostname",
-	NULL};
-
-enum ibft_tgt_properties_enum {
-	ibft_tgt_index,
-	ibft_tgt_flags,
-	ibft_tgt_ip_addr,
-	ibft_tgt_port,
-	ibft_tgt_lun,
-	ibft_tgt_chap_type,
-	ibft_tgt_nic_assoc,
-	ibft_tgt_name,
-	ibft_tgt_chap_name,
-	ibft_tgt_chap_secret,
-	ibft_tgt_rev_chap_name,
-	ibft_tgt_rev_chap_secret,
-	ibft_tgt_end_marker,
-};
-
-static const char *ibft_tgt_properties[] =
-	{"index", "flags", "ip-addr", "port", "lun", "chap-type", "nic-assoc",
-	"target-name", "chap-name", "chap-secret", "rev-chap-name",
-	"rev-chap-name-secret", NULL};
-
-enum ibft_initiator_properties_enum {
-	ibft_init_index,
-	ibft_init_flags,
-	ibft_init_isns_server,
-	ibft_init_slp_server,
-	ibft_init_pri_radius_server,
-	ibft_init_sec_radius_server,
-	ibft_init_initiator_name,
-	ibft_init_end_marker,
-};
-
-static const char *ibft_initiator_properties[] =
-	{"index", "flags", "isns-server", "slp-server", "pri-radius-server",
-	"sec-radius-server", "initiator-name", NULL};
-
 /*
  * The kobject and attribute structures.
  */
@@ -249,29 +182,9 @@ struct ibft_kobject {
 		struct ibft_tgt *tgt;
 		struct ibft_hdr *hdr;
 	};
-	struct kobject kobj;
-	struct list_head node;
 };
 
-struct ibft_attribute {
-	struct attribute attr;
-	ssize_t (*show) (struct  ibft_kobject *entry,
-			 struct ibft_attribute *attr, char *buf);
-	union {
-		struct ibft_initiator *initiator;
-		struct ibft_nic *nic;
-		struct ibft_tgt *tgt;
-		struct ibft_hdr *hdr;
-	};
-	struct kobject *kobj;
-	int type; /* The enum of the type. This can be any value of:
-		ibft_eth_properties_enum, ibft_tgt_properties_enum,
-		or ibft_initiator_properties_enum. */
-	struct list_head node;
-};
-
-static LIST_HEAD(ibft_attr_list);
-static LIST_HEAD(ibft_kobject_list);
+static struct iscsi_boot_kset *boot_kset;
 
 static const char nulls[16];
 
@@ -310,35 +223,27 @@ static ssize_t sprintf_string(char *str, int len, char *buf)
 static int ibft_verify_hdr(char *t, struct ibft_hdr *hdr, int id, int length)
 {
 	if (hdr-&gt;id != id) {
-		printk(KERN_ERR "iBFT error: We expected the " \
+		printk(KERN_ERR "iBFT error: We expected the %s " \
 				"field header.id to have %d but " \
-				"found %d instead!\n", id, hdr-&gt;id);
+				"found %d instead!\n", t, id, hdr-&gt;id);
 		return -ENODEV;
 	}
 	if (hdr-&gt;length != length) {
-		printk(KERN_ERR "iBFT error: We expected the " \
+		printk(KERN_ERR "iBFT error: We expected the %s " \
 				"field header.length to have %d but " \
-				"found %d instead!\n", length, hdr-&gt;length);
+				"found %d instead!\n", t, length, hdr-&gt;length);
 		return -ENODEV;
 	}
 
 	return 0;
 }
 
-static void ibft_release(struct kobject *kobj)
-{
-	struct ibft_kobject *ibft =
-		container_of(kobj, struct ibft_kobject, kobj);
-	kfree(ibft);
-}
-
 /*
  *  Routines for parsing the iBFT data to be human readable.
  */
-static ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
-					struct ibft_attribute *attr,
-					char *buf)
+static ssize_t ibft_attr_show_initiator(void *data, int type, char *buf)
 {
+	struct ibft_kobject *entry = data;
 	struct ibft_initiator *initiator = entry-&gt;initiator;
 	void *ibft_loc = entry-&gt;header;
 	char *str = buf;
@@ -346,26 +251,26 @@ static ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
 	if (!initiator)
 		return 0;
 
-	switch (attr-&gt;type) {
-	case ibft_init_index:
+	switch (type) {
+	case ISCSI_BOOT_INI_INDEX:
 		str += sprintf(str, "%d\n", initiator-&gt;hdr.index);
 		break;
-	case ibft_init_flags:
+	case ISCSI_BOOT_INI_FLAGS:
 		str += sprintf(str, "%d\n", initiator-&gt;hdr.flags);
 		break;
-	case ibft_init_isns_server:
+	case ISCSI_BOOT_INI_ISNS_SERVER:
 		str += sprintf_ipaddr(str, initiator-&gt;isns_server);
 		break;
-	case ibft_init_slp_server:
+	case ISCSI_BOOT_INI_SLP_SERVER:
 		str += sprintf_ipaddr(str, initiator-&gt;slp_server);
 		break;
-	case ibft_init_pri_radius_server:
+	case ISCSI_BOOT_INI_PRI_RADIUS_SERVER:
 		str += sprintf_ipaddr(str, initiator-&gt;pri_radius_server);
 		break;
-	case ibft_init_sec_radius_server:
+	case ISCSI_BOOT_INI_SEC_RADIUS_SERVER:
 		str += sprintf_ipaddr(str, initiator-&gt;sec_radius_server);
 		break;
-	case ibft_init_initiator_name:
+	case ISCSI_BOOT_INI_INITIATOR_NAME:
 		str += sprintf_string(str, initiator-&gt;initiator_name_len,
 				      (char *)ibft_loc +
 				      initiator-&gt;initiator_name_off);
@@ -377,10 +282,9 @@ static ssize_t ibft_attr_show_initiator(struct ibft_kobject *entry,
 	return str - buf;
 }
 
-static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
-				  struct ibft_attribute *attr,
-				  char *buf)
+static ssize_t ibft_attr_show_nic(void *data, int type, char *buf)
 {
+	struct ibft_kobject *entry = data;
 	struct ibft_nic *nic = entry-&gt;nic;
 	void *ibft_loc = entry-&gt;header;
 	char *str = buf;
@@ -389,42 +293,42 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 	if (!nic)
 		return 0;
 
-	switch (attr-&gt;type) {
-	case ibft_eth_index:
+	switch (type) {
+	case ISCSI_BOOT_ETH_INDEX:
 		str += sprintf(str, "%d\n", nic-&gt;hdr.index);
 		break;
-	case ibft_eth_flags:
+	case ISCSI_BOOT_ETH_FLAGS:
 		str += sprintf(str, "%d\n", nic-&gt;hdr.flags);
 		break;
-	case ibft_eth_ip_addr:
+	case ISCSI_BOOT_ETH_IP_ADDR:
 		str += sprintf_ipaddr(str, nic-&gt;ip_addr);
 		break;
-	case ibft_eth_subnet_mask:
+	case ISCSI_BOOT_ETH_SUBNET_MASK:
 		val = cpu_to_be32(~((1 &lt;&lt; (32-nic-&gt;subnet_mask_prefix))-1));
 		str += sprintf(str, "%pI4", &amp;val);
 		break;
-	case ibft_eth_origin:
+	case ISCSI_BOOT_ETH_ORIGIN:
 		str += sprintf(str, "%d\n", nic-&gt;origin);
 		break;
-	case ibft_eth_gateway:
+	case ISCSI_BOOT_ETH_GATEWAY:
 		str += sprintf_ipaddr(str, nic-&gt;gateway);
 		break;
-	case ibft_eth_primary_dns:
+	case ISCSI_BOOT_ETH_PRIMARY_DNS:
 		str += sprintf_ipaddr(str, nic-&gt;primary_dns);
 		break;
-	case ibft_eth_secondary_dns:
+	case ISCSI_BOOT_ETH_SECONDARY_DNS:
 		str += sprintf_ipaddr(str, nic-&gt;secondary_dns);
 		break;
-	case ibft_eth_dhcp:
+	case ISCSI_BOOT_ETH_DHCP:
 		str += sprintf_ipaddr(str, nic-&gt;dhcp);
 		break;
-	case ibft_eth_vlan:
+	case ISCSI_BOOT_ETH_VLAN:
 		str += sprintf(str, "%d\n", nic-&gt;vlan);
 		break;
-	case ibft_eth_mac:
+	case ISCSI_BOOT_ETH_MAC:
 		str += sprintf(str, "%pM\n", nic-&gt;mac);
 		break;
-	case ibft_eth_hostname:
+	case ISCSI_BOOT_ETH_HOSTNAME:
 		str += sprintf_string(str, nic-&gt;hostname_len,
 				      (char *)ibft_loc + nic-&gt;hostname_off);
 		break;
@@ -435,10 +339,9 @@ static ssize_t ibft_attr_show_nic(struct ibft_kobject *entry,
 	return str - buf;
 };
 
-static ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
-				     struct ibft_attribute *attr,
-				     char *buf)
+static ssize_t ibft_attr_show_target(void *data, int type, char *buf)
 {
+	struct ibft_kobject *entry = data;
 	struct ibft_tgt *tgt = entry-&gt;tgt;
 	void *ibft_loc = entry-&gt;header;
 	char *str = buf;
@@ -447,48 +350,48 @@ static ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
 	if (!tgt)
 		return 0;
 
-	switch (attr-&gt;type) {
-	case ibft_tgt_index:
+	switch (type) {
+	case ISCSI_BOOT_TGT_INDEX:
 		str += sprintf(str, "%d\n", tgt-&gt;hdr.index);
 		break;
-	case ibft_tgt_flags:
+	case ISCSI_BOOT_TGT_FLAGS:
 		str += sprintf(str, "%d\n", tgt-&gt;hdr.flags);
 		break;
-	case ibft_tgt_ip_addr:
+	case ISCSI_BOOT_TGT_IP_ADDR:
 		str += sprintf_ipaddr(str, tgt-&gt;ip_addr);
 		break;
-	case ibft_tgt_port:
+	case ISCSI_BOOT_TGT_PORT:
 		str += sprintf(str, "%d\n", tgt-&gt;port);
 		break;
-	case ibft_tgt_lun:
+	case ISCSI_BOOT_TGT_LUN:
 		for (i = 0; i &lt; 8; i++)
 			str += sprintf(str, "%x", (u8)tgt-&gt;lun[i]);
 		str += sprintf(str, "\n");
 		break;
-	case ibft_tgt_nic_assoc:
+	case ISCSI_BOOT_TGT_NIC_ASSOC:
 		str += sprintf(str, "%d\n", tgt-&gt;nic_assoc);
 		break;
-	case ibft_tgt_chap_type:
+	case ISCSI_BOOT_TGT_CHAP_TYPE:
 		str += sprintf(str, "%d\n", tgt-&gt;chap_type);
 		break;
-	case ibft_tgt_name:
+	case ISCSI_BOOT_TGT_NAME:
 		str += sprintf_string(str, tgt-&gt;tgt_name_len,
 				      (char *)ibft_loc + tgt-&gt;tgt_name_off);
 		break;
-	case ibft_tgt_chap_name:
+	case ISCSI_BOOT_TGT_CHAP_NAME:
 		str += sprintf_string(str, tgt-&gt;chap_name_len,
 				      (char *)ibft_loc + tgt-&gt;chap_name_off);
 		break;
-	case ibft_tgt_chap_secret:
+	case ISCSI_BOOT_TGT_CHAP_SECRET:
 		str += sprintf_string(str, tgt-&gt;chap_secret_len,
 				      (char *)ibft_loc + tgt-&gt;chap_secret_off);
 		break;
-	case ibft_tgt_rev_chap_name:
+	case ISCSI_BOOT_TGT_REV_CHAP_NAME:
 		str += sprintf_string(str, tgt-&gt;rev_chap_name_len,
 				      (char *)ibft_loc +
 				      tgt-&gt;rev_chap_name_off);
 		break;
-	case ibft_tgt_rev_chap_secret:
+	case ISCSI_BOOT_TGT_REV_CHAP_SECRET:
 		str += sprintf_string(str, tgt-&gt;rev_chap_secret_len,
 				      (char *)ibft_loc +
 				      tgt-&gt;rev_chap_secret_off);
@@ -500,40 +403,6 @@ static ssize_t ibft_attr_show_target(struct ibft_kobject *entry,
 	return str - buf;
 }
 
-/*
- * The routine called for all sysfs attributes.
- */
-static ssize_t ibft_show_attribute(struct kobject *kobj,
-				    struct attribute *attr,
-				    char *buf)
-{
-	struct ibft_kobject *dev =
-		container_of(kobj, struct ibft_kobject, kobj);
-	struct ibft_attribute *ibft_attr =
-		container_of(attr, struct ibft_attribute, attr);
-	ssize_t ret = -EIO;
-	char *str = buf;
-
-	if (!capable(CAP_SYS_ADMIN))
-		return -EACCES;
-
-	if (ibft_attr-&gt;show)
-		ret = ibft_attr-&gt;show(dev, ibft_attr, str);
-
-	return ret;
-}
-
-static const struct sysfs_ops ibft_attr_ops = {
-	.show = ibft_show_attribute,
-};
-
-static struct kobj_type ibft_ktype = {
-	.release = ibft_release,
-	.sysfs_ops = &amp;ibft_attr_ops,
-};
-
-static struct kset *ibft_kset;
-
 static int __init ibft_check_device(void)
 {
 	int len;
@@ -560,13 +429,150 @@ static int __init ibft_check_device(void)
 	return 0;
 }
 
+/*
+ * Helper routiners to check to determine if the entry is valid
+ * in the proper iBFT structure.
+ */
+static mode_t ibft_check_nic_for(void *data, int type)
+{
+	struct ibft_kobject *entry = data;
+	struct ibft_nic *nic = entry-&gt;nic;
+	mode_t rc = 0;
+
+	switch (type) {
+	case ISCSI_BOOT_ETH_INDEX:
+	case ISCSI_BOOT_ETH_FLAGS:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_IP_ADDR:
+		if (memcmp(nic-&gt;ip_addr, nulls, sizeof(nic-&gt;ip_addr)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_SUBNET_MASK:
+		if (nic-&gt;subnet_mask_prefix)
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_ORIGIN:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_GATEWAY:
+		if (memcmp(nic-&gt;gateway, nulls, sizeof(nic-&gt;gateway)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_PRIMARY_DNS:
+		if (memcmp(nic-&gt;primary_dns, nulls,
+			   sizeof(nic-&gt;primary_dns)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_SECONDARY_DNS:
+		if (memcmp(nic-&gt;secondary_dns, nulls,
+			   sizeof(nic-&gt;secondary_dns)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_DHCP:
+		if (memcmp(nic-&gt;dhcp, nulls, sizeof(nic-&gt;dhcp)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_VLAN:
+	case ISCSI_BOOT_ETH_MAC:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_ETH_HOSTNAME:
+		if (nic-&gt;hostname_off)
+			rc = S_IRUGO;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static mode_t __init ibft_check_tgt_for(void *data, int type)
+{
+	struct ibft_kobject *entry = data;
+	struct ibft_tgt *tgt = entry-&gt;tgt;
+	mode_t rc = 0;
+
+	switch (type) {
+	case ISCSI_BOOT_TGT_INDEX:
+	case ISCSI_BOOT_TGT_FLAGS:
+	case ISCSI_BOOT_TGT_IP_ADDR:
+	case ISCSI_BOOT_TGT_PORT:
+	case ISCSI_BOOT_TGT_LUN:
+	case ISCSI_BOOT_TGT_NIC_ASSOC:
+	case ISCSI_BOOT_TGT_CHAP_TYPE:
+		rc = S_IRUGO;
+	case ISCSI_BOOT_TGT_NAME:
+		if (tgt-&gt;tgt_name_len)
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_TGT_CHAP_NAME:
+	case ISCSI_BOOT_TGT_CHAP_SECRET:
+		if (tgt-&gt;chap_name_len)
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_TGT_REV_CHAP_NAME:
+	case ISCSI_BOOT_TGT_REV_CHAP_SECRET:
+		if (tgt-&gt;rev_chap_name_len)
+			rc = S_IRUGO;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+static mode_t __init ibft_check_initiator_for(void *data, int type)
+{
+	struct ibft_kobject *entry = data;
+	struct ibft_initiator *init = entry-&gt;initiator;
+	mode_t rc = 0;
+
+	switch (type) {
+	case ISCSI_BOOT_INI_INDEX:
+	case ISCSI_BOOT_INI_FLAGS:
+		rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_ISNS_SERVER:
+		if (memcmp(init-&gt;isns_server, nulls,
+			   sizeof(init-&gt;isns_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_SLP_SERVER:
+		if (memcmp(init-&gt;slp_server, nulls,
+			   sizeof(init-&gt;slp_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_PRI_RADIUS_SERVER:
+		if (memcmp(init-&gt;pri_radius_server, nulls,
+			   sizeof(init-&gt;pri_radius_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_SEC_RADIUS_SERVER:
+		if (memcmp(init-&gt;sec_radius_server, nulls,
+			   sizeof(init-&gt;sec_radius_server)))
+			rc = S_IRUGO;
+		break;
+	case ISCSI_BOOT_INI_INITIATOR_NAME:
+		if (init-&gt;initiator_name_len)
+			rc = S_IRUGO;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
 /*
  * Helper function for ibft_register_kobjects.
  */
 static int __init ibft_create_kobject(struct acpi_table_ibft *header,
-				       struct ibft_hdr *hdr,
-				       struct list_head *list)
+				      struct ibft_hdr *hdr)
 {
+	struct iscsi_boot_kobj *boot_kobj = NULL;
 	struct ibft_kobject *ibft_kobj = NULL;
 	struct ibft_nic *nic = (struct ibft_nic *)hdr;
 	struct pci_dev *pci_dev;
@@ -583,14 +589,47 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 	case id_initiator:
 		rc = ibft_verify_hdr("initiator", hdr, id_initiator,
 				     sizeof(*ibft_kobj-&gt;initiator));
+		if (rc)
+			break;
+
+		boot_kobj = iscsi_boot_create_initiator(boot_kset, hdr-&gt;index,
+						ibft_kobj,
+						ibft_attr_show_initiator,
+						ibft_check_initiator_for);
+		if (!boot_kobj) {
+			rc = -ENOMEM;
+			goto free_ibft_obj;
+		}
 		break;
 	case id_nic:
 		rc = ibft_verify_hdr("ethernet", hdr, id_nic,
 				     sizeof(*ibft_kobj-&gt;nic));
+		if (rc)
+			break;
+
+		boot_kobj = iscsi_boot_create_ethernet(boot_kset, hdr-&gt;index,
+						       ibft_kobj,
+						       ibft_attr_show_nic,
+						       ibft_check_nic_for);
+		if (!boot_kobj) {
+			rc = -ENOMEM;
+			goto free_ibft_obj;
+		}
 		break;
 	case id_target:
 		rc = ibft_verify_hdr("target", hdr, id_target,
 				     sizeof(*ibft_kobj-&gt;tgt));
+		if (rc)
+			break;
+
+		boot_kobj = iscsi_boot_create_target(boot_kset, hdr-&gt;index,
+						     ibft_kobj,
+						     ibft_attr_show_target,
+						     ibft_check_tgt_for);
+		if (!boot_kobj) {
+			rc = -ENOMEM;
+			goto free_ibft_obj;
+		}
 		break;
 	case id_reserved:
 	case id_control:
@@ -608,22 +647,10 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 
 	if (rc) {
 		/* Skip adding this kobject, but exit with non-fatal error. */
-		kfree(ibft_kobj);
-		goto out_invalid_struct;
-	}
-
-	ibft_kobj-&gt;kobj.kset = ibft_kset;
-
-	rc = kobject_init_and_add(&amp;ibft_kobj-&gt;kobj, &amp;ibft_ktype,
-				  NULL, ibft_id_names[hdr-&gt;id], hdr-&gt;index);
-
-	if (rc) {
-		kfree(ibft_kobj);
-		goto out;
+		rc = 0;
+		goto free_ibft_obj;
 	}
 
-	kobject_uevent(&amp;ibft_kobj-&gt;kobj, KOBJ_ADD);
-
 	if (hdr-&gt;id == id_nic) {
 		/*
 		* We don't search for the device in other domains than
@@ -634,19 +661,16 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
 		pci_dev = pci_get_bus_and_slot((nic-&gt;pci_bdf &amp; 0xff00) &gt;&gt; 8,
 					       (nic-&gt;pci_bdf &amp; 0xff));
 		if (pci_dev) {
-			rc = sysfs_create_link(&amp;ibft_kobj-&gt;kobj,
+			rc = sysfs_create_link(&amp;boot_kobj-&gt;kobj,
 					       &amp;pci_dev-&gt;dev.kobj, "device");
 			pci_dev_put(pci_dev);
 		}
 	}
+	return 0;
 
-	/* Nothing broke so lets add it to the list. */
-	list_add_tail(&amp;ibft_kobj-&gt;node, list);
-out:
+free_ibft_obj:
+	kfree(ibft_kobj);
 	return rc;
-out_invalid_struct:
-	/* Unsupported structs are skipped. */
-	return 0;
 }
 
 /*
@@ -654,8 +678,7 @@ static int __init ibft_create_kobject(struct acpi_table_ibft *header,
  * found add them on the passed-in list. We do not support the other
  * fields at this point, so they are skipped.
  */
-static int __init ibft_register_kobjects(struct acpi_table_ibft *header,
-					  struct list_head *list)
+static int __init ibft_register_kobjects(struct acpi_table_ibft *header)
 {
 	struct ibft_control *control = NULL;
 	void *ptr, *end;
@@ -680,8 +703,7 @@ static int __init ibft_register_kobjects(struct acpi_table_ibft *header,
 		if (offset &amp;&amp; offset &lt; header-&gt;header.length &amp;&amp;
 						offset &lt; eot_offset) {
 			rc = ibft_create_kobject(header,
-						 (void *)header + offset,
-						 list);
+						 (void *)header + offset);
 			if (rc)
 				break;
 		}
@@ -690,240 +712,28 @@ static int __init ibft_register_kobjects(struct acpi_table_ibft *header,
 	return rc;
 }
 
-static void ibft_unregister(struct list_head *attr_list,
-			     struct list_head *kobj_list)
+static void ibft_unregister(void)
 {
-	struct ibft_kobject *data = NULL, *n;
-	struct ibft_attribute *attr = NULL, *m;
-
-	list_for_each_entry_safe(attr, m, attr_list, node) {
-		sysfs_remove_file(attr-&gt;kobj, &amp;attr-&gt;attr);
-		list_del(&amp;attr-&gt;node);
-		kfree(attr);
+	struct iscsi_boot_kobj *boot_kobj, *tmp_kobj;
+	struct ibft_kobject *ibft_kobj;
+
+	list_for_each_entry_safe(boot_kobj, tmp_kobj,
+				 &amp;boot_kset-&gt;kobj_list, list) {
+		ibft_kobj = boot_kobj-&gt;data;
+		if (ibft_kobj-&gt;hdr-&gt;id == id_nic)
+			sysfs_remove_link(&amp;boot_kobj-&gt;kobj, "device");
 	};
-	list_del_init(attr_list);
-
-	list_for_each_entry_safe(data, n, kobj_list, node) {
-		list_del(&amp;data-&gt;node);
-		if (data-&gt;hdr-&gt;id == id_nic)
-			sysfs_remove_link(&amp;data-&gt;kobj, "device");
-		kobject_put(&amp;data-&gt;kobj);
-	};
-	list_del_init(kobj_list);
 }
 
-static int __init ibft_create_attribute(struct ibft_kobject *kobj_data,
-					 int type,
-					 const char *name,
-					 ssize_t (*show)(struct ibft_kobject *,
-							 struct ibft_attribute*,
-							 char *buf),
-					 struct list_head *list)
+static void ibft_cleanup(void)
 {
-	struct ibft_attribute *attr = NULL;
-	struct ibft_hdr *hdr = kobj_data-&gt;hdr;
-
-	attr = kmalloc(sizeof(*attr), GFP_KERNEL);
-	if (!attr)
-		return -ENOMEM;
-
-	attr-&gt;attr.name = name;
-	attr-&gt;attr.mode = S_IRUSR;
-
-	attr-&gt;hdr = hdr;
-	attr-&gt;show = show;
-	attr-&gt;kobj = &amp;kobj_data-&gt;kobj;
-	attr-&gt;type = type;
-
-	list_add_tail(&amp;attr-&gt;node, list);
-
-	return 0;
-}
-
-/*
- * Helper routiners to check to determine if the entry is valid
- * in the proper iBFT structure.
- */
-static int __init ibft_check_nic_for(struct ibft_nic *nic, int entry)
-{
-	int rc = 0;
-
-	switch (entry) {
-	case ibft_eth_index:
-	case ibft_eth_flags:
-		rc = 1;
-		break;
-	case ibft_eth_ip_addr:
-		if (memcmp(nic-&gt;ip_addr, nulls, sizeof(nic-&gt;ip_addr)))
-			rc = 1;
-		break;
-	case ibft_eth_subnet_mask:
-		if (nic-&gt;subnet_mask_prefix)
-			rc = 1;
-		break;
-	case ibft_eth_origin:
-		rc = 1;
-		break;
-	case ibft_eth_gateway:
-		if (memcmp(nic-&gt;gateway, nulls, sizeof(nic-&gt;gateway)))
-			rc = 1;
-		break;
-	case ibft_eth_primary_dns:
-		if (memcmp(nic-&gt;primary_dns, nulls,
-			   sizeof(nic-&gt;primary_dns)))
-			rc = 1;
-		break;
-	case ibft_eth_secondary_dns:
-		if (memcmp(nic-&gt;secondary_dns, nulls,
-			   sizeof(nic-&gt;secondary_dns)))
-			rc = 1;
-		break;
-	case ibft_eth_dhcp:
-		if (memcmp(nic-&gt;dhcp, nulls, sizeof(nic-&gt;dhcp)))
-			rc = 1;
-		break;
-	case ibft_eth_vlan:
-	case ibft_eth_mac:
-		rc = 1;
-		break;
-	case ibft_eth_hostname:
-		if (nic-&gt;hostname_off)
-			rc = 1;
-		break;
-	default:
-		break;
-	}
-
-	return rc;
+	ibft_unregister();
+	iscsi_boot_destroy_kset(boot_kset);
 }
 
-static int __init ibft_check_tgt_for(struct ibft_tgt *tgt, int entry)
-{
-	int rc = 0;
-
-	switch (entry) {
-	case ibft_tgt_index:
-	case ibft_tgt_flags:
-	case ibft_tgt_ip_addr:
-	case ibft_tgt_port:
-	case ibft_tgt_lun:
-	case ibft_tgt_nic_assoc:
-	case ibft_tgt_chap_type:
-		rc = 1;
-	case ibft_tgt_name:
-		if (tgt-&gt;tgt_name_len)
-			rc = 1;
-		break;
-	case ibft_tgt_chap_name:
-	case ibft_tgt_chap_secret:
-		if (tgt-&gt;chap_name_len)
-			rc = 1;
-		break;
-	case ibft_tgt_rev_chap_name:
-	case ibft_tgt_rev_chap_secret:
-		if (tgt-&gt;rev_chap_name_len)
-			rc = 1;
-		break;
-	default:
-		break;
-	}
-
-	return rc;
-}
-
-static int __init ibft_check_initiator_for(struct ibft_initiator *init,
-					    int entry)
-{
-	int rc = 0;
-
-	switch (entry) {
-	case ibft_init_index:
-	case ibft_init_flags:
-		rc = 1;
-		break;
-	case ibft_init_isns_server:
-		if (memcmp(init-&gt;isns_server, nulls,
-			   sizeof(init-&gt;isns_server)))
-			rc = 1;
-		break;
-	case ibft_init_slp_server:
-		if (memcmp(init-&gt;slp_server, nulls,
-			   sizeof(init-&gt;slp_server)))
-			rc = 1;
-		break;
-	case ibft_init_pri_radius_server:
-		if (memcmp(init-&gt;pri_radius_server, nulls,
-			   sizeof(init-&gt;pri_radius_server)))
-			rc = 1;
-		break;
-	case ibft_init_sec_radius_server:
-		if (memcmp(init-&gt;sec_radius_server, nulls,
-			   sizeof(init-&gt;sec_radius_server)))
-			rc = 1;
-		break;
-	case ibft_init_initiator_name:
-		if (init-&gt;initiator_name_len)
-			rc = 1;
-		break;
-	default:
-		break;
-	}
-
-	return rc;
-}
-
-/*
- *  Register the attributes for all of the kobjects.
- */
-static int __init ibft_register_attributes(struct list_head *kobject_list,
-					    struct list_head *attr_list)
+static void __exit ibft_exit(void)
 {
-	int rc = 0, i = 0;
-	struct ibft_kobject *data = NULL;
-	struct ibft_attribute *attr = NULL, *m;
-
-	list_for_each_entry(data, kobject_list, node) {
-		switch (data-&gt;hdr-&gt;id) {
-		case id_nic:
-			for (i = 0; i &lt; ibft_eth_end_marker &amp;&amp; !rc; i++)
-				if (ibft_check_nic_for(data-&gt;nic, i))
-					rc = ibft_create_attribute(data, i,
-						ibft_eth_properties[i],
-						ibft_attr_show_nic, attr_list);
-			break;
-		case id_target:
-			for (i = 0; i &lt; ibft_tgt_end_marker &amp;&amp; !rc; i++)
-				if (ibft_check_tgt_for(data-&gt;tgt, i))
-					rc = ibft_create_attribute(data, i,
-						ibft_tgt_properties[i],
-						ibft_attr_show_target,
-						attr_list);
-			break;
-		case id_initiator:
-			for (i = 0; i &lt; ibft_init_end_marker &amp;&amp; !rc; i++)
-				if (ibft_check_initiator_for(
-					data-&gt;initiator, i))
-					rc = ibft_create_attribute(data, i,
-						ibft_initiator_properties[i],
-						ibft_attr_show_initiator,
-						attr_list);
-			break;
-		default:
-			break;
-		}
-		if (rc)
-			break;
-	}
-	list_for_each_entry_safe(attr, m, attr_list, node) {
-		rc = sysfs_create_file(attr-&gt;kobj, &amp;attr-&gt;attr);
-		if (rc) {
-			list_del(&amp;attr-&gt;node);
-			kfree(attr);
-			break;
-		}
-	}
-
-	return rc;
+	ibft_cleanup();
 }
 
 /*
@@ -933,26 +743,20 @@ static int __init ibft_init(void)
 {
 	int rc = 0;
 
-	ibft_kset = kset_create_and_add("ibft", NULL, firmware_kobj);
-	if (!ibft_kset)
-		return -ENOMEM;
-
 	if (ibft_addr) {
 		printk(KERN_INFO "iBFT detected at 0x%llx.\n",
 		       (u64)isa_virt_to_bus(ibft_addr));
 
 		rc = ibft_check_device();
 		if (rc)
-			goto out_firmware_unregister;
+			return rc;
 
-		/* Scan the IBFT for data and register the kobjects. */
-		rc = ibft_register_kobjects(ibft_addr, &amp;ibft_kobject_list);
-		if (rc)
-			goto out_free;
+		boot_kset = iscsi_boot_create_kset("ibft");
+		if (!boot_kset)
+			return -ENOMEM;
 
-		/* Register the attributes */
-		rc = ibft_register_attributes(&amp;ibft_kobject_list,
-					      &amp;ibft_attr_list);
+		/* Scan the IBFT for data and register the kobjects. */
+		rc = ibft_register_kobjects(ibft_addr);
 		if (rc)
 			goto out_free;
 	} else
@@ -961,17 +765,9 @@ static int __init ibft_init(void)
 	return 0;
 
 out_free:
-	ibft_unregister(&amp;ibft_attr_list, &amp;ibft_kobject_list);
-out_firmware_unregister:
-	kset_unregister(ibft_kset);
+	ibft_cleanup();
 	return rc;
 }
 
-static void __exit ibft_exit(void)
-{
-	ibft_unregister(&amp;ibft_attr_list, &amp;ibft_kobject_list);
-	kset_unregister(ibft_kset);
-}
-
 module_init(ibft_init);
 module_exit(ibft_exit);</pre><hr><pre>commit ba4ee30c6c797de148dcc7254cf6d531aba71d9b
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Apr 12 18:06:17 2010 +0000

    ibft: separate ibft parsing from sysfs interface
    
    Not all iscsi drivers support ibft. For drivers like be2iscsi
    that do not but are bootable through a vendor firmware specific
    format/process this patch moves the sysfs interface from the ibft code
    to a lib module. This then allows userspace tools to search for iscsi boot
    info in a common place and in a common format.
    
    ibft iscsi boot info is exported in the same place as it was
    before: /sys/firmware/ibft.
    
    vendor/fw boot info gets export in /sys/firmware/iscsi_bootX, where X is the
    scsi host number of the HBA. Underneath these parent dirs, the
    target, ethernet, and initiator dirs are the same as they were before.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Konrad Rzeszutek Wilk &lt;konrad@kernel.org&gt;
    Signed-off-by: Peter Jones &lt;pjones@redhat.com&gt;

diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index 1b03ba1d0834..571d2182613d 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -122,6 +122,14 @@ config ISCSI_IBFT_FIND
 	  is necessary for iSCSI Boot Firmware Table Attributes module to work
 	  properly.
 
+config ISCSI_BOOT_SYSFS
+	tristate "iSCSI Boot Sysfs Interface"
+	default	n
+	help
+	  This option enables support for exposing iSCSI boot information
+	  via sysfs to userspace. If you wish to export this information,
+	  say Y. Otherwise, say N.
+
 config ISCSI_IBFT
 	tristate "iSCSI Boot Firmware Table Attributes module"
 	depends on ISCSI_IBFT_FIND
diff --git a/drivers/firmware/Makefile b/drivers/firmware/Makefile
index 1c3c17343dbe..5fe7e1662922 100644
--- a/drivers/firmware/Makefile
+++ b/drivers/firmware/Makefile
@@ -10,4 +10,5 @@ obj-$(CONFIG_DCDBAS)		+= dcdbas.o
 obj-$(CONFIG_DMIID)		+= dmi-id.o
 obj-$(CONFIG_ISCSI_IBFT_FIND)	+= iscsi_ibft_find.o
 obj-$(CONFIG_ISCSI_IBFT)	+= iscsi_ibft.o
+obj-$(CONFIG_ISCSI_BOOT_SYSFS)	+= iscsi_boot_sysfs.o
 obj-$(CONFIG_FIRMWARE_MEMMAP)	+= memmap.o
diff --git a/drivers/firmware/iscsi_boot_sysfs.c b/drivers/firmware/iscsi_boot_sysfs.c
new file mode 100644
index 000000000000..df6bff7366cf
--- /dev/null
+++ b/drivers/firmware/iscsi_boot_sysfs.c
@@ -0,0 +1,481 @@
+/*
+ * Export the iSCSI boot info to userland via sysfs.
+ *
+ * Copyright (C) 2010 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2010 Mike Christie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License v2.0 as published by
+ * the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/string.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/sysfs.h&gt;
+#include &lt;linux/capability.h&gt;
+#include &lt;linux/iscsi_boot_sysfs.h&gt;
+
+
+MODULE_AUTHOR("Mike Christie &lt;michaelc@cs.wisc.edu&gt;");
+MODULE_DESCRIPTION("sysfs interface and helpers to export iSCSI boot information");
+MODULE_LICENSE("GPL");
+/*
+ * The kobject and attribute structures.
+ */
+struct iscsi_boot_attr {
+	struct attribute attr;
+	int type;
+	ssize_t (*show) (void *data, int type, char *buf);
+};
+
+/*
+ * The routine called for all sysfs attributes.
+ */
+static ssize_t iscsi_boot_show_attribute(struct kobject *kobj,
+					 struct attribute *attr, char *buf)
+{
+	struct iscsi_boot_kobj *boot_kobj =
+			container_of(kobj, struct iscsi_boot_kobj, kobj);
+	struct iscsi_boot_attr *boot_attr =
+			container_of(attr, struct iscsi_boot_attr, attr);
+	ssize_t ret = -EIO;
+	char *str = buf;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (boot_kobj-&gt;show)
+		ret = boot_kobj-&gt;show(boot_kobj-&gt;data, boot_attr-&gt;type, str);
+	return ret;
+}
+
+static const struct sysfs_ops iscsi_boot_attr_ops = {
+	.show = iscsi_boot_show_attribute,
+};
+
+static void iscsi_boot_kobj_release(struct kobject *kobj)
+{
+	struct iscsi_boot_kobj *boot_kobj =
+			container_of(kobj, struct iscsi_boot_kobj, kobj);
+
+	kfree(boot_kobj-&gt;data);
+	kfree(boot_kobj);
+}
+
+static struct kobj_type iscsi_boot_ktype = {
+	.release = iscsi_boot_kobj_release,
+	.sysfs_ops = &amp;iscsi_boot_attr_ops,
+};
+
+#define iscsi_boot_rd_attr(fnname, sysfs_name, attr_type)		\
+static struct iscsi_boot_attr iscsi_boot_attr_##fnname = {	\
+	.attr	= { .name = __stringify(sysfs_name), .mode = 0444 },	\
+	.type	= attr_type,						\
+}
+
+/* Target attrs */
+iscsi_boot_rd_attr(tgt_index, index, ISCSI_BOOT_TGT_INDEX);
+iscsi_boot_rd_attr(tgt_flags, flags, ISCSI_BOOT_TGT_FLAGS);
+iscsi_boot_rd_attr(tgt_ip, ip-addr, ISCSI_BOOT_TGT_IP_ADDR);
+iscsi_boot_rd_attr(tgt_port, port, ISCSI_BOOT_TGT_PORT);
+iscsi_boot_rd_attr(tgt_lun, lun, ISCSI_BOOT_TGT_LUN);
+iscsi_boot_rd_attr(tgt_chap, chap-type, ISCSI_BOOT_TGT_CHAP_TYPE);
+iscsi_boot_rd_attr(tgt_nic, nic-assoc, ISCSI_BOOT_TGT_NIC_ASSOC);
+iscsi_boot_rd_attr(tgt_name, target-name, ISCSI_BOOT_TGT_NAME);
+iscsi_boot_rd_attr(tgt_chap_name, chap-name, ISCSI_BOOT_TGT_CHAP_NAME);
+iscsi_boot_rd_attr(tgt_chap_secret, chap-secret, ISCSI_BOOT_TGT_CHAP_SECRET);
+iscsi_boot_rd_attr(tgt_chap_rev_name, rev-chap-name,
+		   ISCSI_BOOT_TGT_REV_CHAP_NAME);
+iscsi_boot_rd_attr(tgt_chap_rev_secret, rev-chap-name-secret,
+		   ISCSI_BOOT_TGT_REV_CHAP_SECRET);
+
+static struct attribute *target_attrs[] = {
+	&amp;iscsi_boot_attr_tgt_index.attr,
+	&amp;iscsi_boot_attr_tgt_flags.attr,
+	&amp;iscsi_boot_attr_tgt_ip.attr,
+	&amp;iscsi_boot_attr_tgt_port.attr,
+	&amp;iscsi_boot_attr_tgt_lun.attr,
+	&amp;iscsi_boot_attr_tgt_chap.attr,
+	&amp;iscsi_boot_attr_tgt_nic.attr,
+	&amp;iscsi_boot_attr_tgt_name.attr,
+	&amp;iscsi_boot_attr_tgt_chap_name.attr,
+	&amp;iscsi_boot_attr_tgt_chap_secret.attr,
+	&amp;iscsi_boot_attr_tgt_chap_rev_name.attr,
+	&amp;iscsi_boot_attr_tgt_chap_rev_secret.attr,
+	NULL
+};
+
+static mode_t iscsi_boot_tgt_attr_is_visible(struct kobject *kobj,
+					     struct attribute *attr, int i)
+{
+	struct iscsi_boot_kobj *boot_kobj =
+			container_of(kobj, struct iscsi_boot_kobj, kobj);
+
+	if (attr ==  &amp;iscsi_boot_attr_tgt_index.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_INDEX);
+	else if (attr == &amp;iscsi_boot_attr_tgt_flags.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_FLAGS);
+	else if (attr == &amp;iscsi_boot_attr_tgt_ip.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					      ISCSI_BOOT_TGT_IP_ADDR);
+	else if (attr == &amp;iscsi_boot_attr_tgt_port.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					      ISCSI_BOOT_TGT_PORT);
+	else if (attr == &amp;iscsi_boot_attr_tgt_lun.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					      ISCSI_BOOT_TGT_LUN);
+	else if (attr == &amp;iscsi_boot_attr_tgt_chap.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_CHAP_TYPE);
+	else if (attr == &amp;iscsi_boot_attr_tgt_nic.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_NIC_ASSOC);
+	else if (attr == &amp;iscsi_boot_attr_tgt_name.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_NAME);
+	else if (attr == &amp;iscsi_boot_attr_tgt_chap_name.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_CHAP_NAME);
+	else if (attr == &amp;iscsi_boot_attr_tgt_chap_secret.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_CHAP_SECRET);
+	else if (attr == &amp;iscsi_boot_attr_tgt_chap_rev_name.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_REV_CHAP_NAME);
+	else if (attr == &amp;iscsi_boot_attr_tgt_chap_rev_secret.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_TGT_REV_CHAP_SECRET);
+	return 0;
+}
+
+static struct attribute_group iscsi_boot_target_attr_group = {
+	.attrs = target_attrs,
+	.is_visible = iscsi_boot_tgt_attr_is_visible,
+};
+
+/* Ethernet attrs */
+iscsi_boot_rd_attr(eth_index, index, ISCSI_BOOT_ETH_INDEX);
+iscsi_boot_rd_attr(eth_flags, flags, ISCSI_BOOT_ETH_FLAGS);
+iscsi_boot_rd_attr(eth_ip, ip-addr, ISCSI_BOOT_ETH_IP_ADDR);
+iscsi_boot_rd_attr(eth_subnet, subnet-mask, ISCSI_BOOT_ETH_SUBNET_MASK);
+iscsi_boot_rd_attr(eth_origin, origin, ISCSI_BOOT_ETH_ORIGIN);
+iscsi_boot_rd_attr(eth_gateway, gateway, ISCSI_BOOT_ETH_GATEWAY);
+iscsi_boot_rd_attr(eth_primary_dns, primary-dns, ISCSI_BOOT_ETH_PRIMARY_DNS);
+iscsi_boot_rd_attr(eth_secondary_dns, secondary-dns,
+		   ISCSI_BOOT_ETH_SECONDARY_DNS);
+iscsi_boot_rd_attr(eth_dhcp, dhcp, ISCSI_BOOT_ETH_DHCP);
+iscsi_boot_rd_attr(eth_vlan, vlan, ISCSI_BOOT_ETH_VLAN);
+iscsi_boot_rd_attr(eth_mac, mac, ISCSI_BOOT_ETH_MAC);
+iscsi_boot_rd_attr(eth_hostname, hostname, ISCSI_BOOT_ETH_HOSTNAME);
+
+static struct attribute *ethernet_attrs[] = {
+	&amp;iscsi_boot_attr_eth_index.attr,
+	&amp;iscsi_boot_attr_eth_flags.attr,
+	&amp;iscsi_boot_attr_eth_ip.attr,
+	&amp;iscsi_boot_attr_eth_subnet.attr,
+	&amp;iscsi_boot_attr_eth_origin.attr,
+	&amp;iscsi_boot_attr_eth_gateway.attr,
+	&amp;iscsi_boot_attr_eth_primary_dns.attr,
+	&amp;iscsi_boot_attr_eth_secondary_dns.attr,
+	&amp;iscsi_boot_attr_eth_dhcp.attr,
+	&amp;iscsi_boot_attr_eth_vlan.attr,
+	&amp;iscsi_boot_attr_eth_mac.attr,
+	&amp;iscsi_boot_attr_eth_hostname.attr,
+	NULL
+};
+
+static mode_t iscsi_boot_eth_attr_is_visible(struct kobject *kobj,
+					     struct attribute *attr, int i)
+{
+	struct iscsi_boot_kobj *boot_kobj =
+			container_of(kobj, struct iscsi_boot_kobj, kobj);
+
+	if (attr ==  &amp;iscsi_boot_attr_eth_index.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_INDEX);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_flags.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_FLAGS);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_ip.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_IP_ADDR);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_subnet.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_SUBNET_MASK);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_origin.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_ORIGIN);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_gateway.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_GATEWAY);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_primary_dns.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_PRIMARY_DNS);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_secondary_dns.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_SECONDARY_DNS);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_dhcp.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_DHCP);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_vlan.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_VLAN);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_mac.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_MAC);
+	else if (attr ==  &amp;iscsi_boot_attr_eth_hostname.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_ETH_HOSTNAME);
+	return 0;
+}
+
+static struct attribute_group iscsi_boot_ethernet_attr_group = {
+	.attrs = ethernet_attrs,
+	.is_visible = iscsi_boot_eth_attr_is_visible,
+};
+
+/* Initiator attrs */
+iscsi_boot_rd_attr(ini_index, index, ISCSI_BOOT_INI_INDEX);
+iscsi_boot_rd_attr(ini_flags, flags, ISCSI_BOOT_INI_FLAGS);
+iscsi_boot_rd_attr(ini_isns, isns-server, ISCSI_BOOT_INI_ISNS_SERVER);
+iscsi_boot_rd_attr(ini_slp, slp-server, ISCSI_BOOT_INI_SLP_SERVER);
+iscsi_boot_rd_attr(ini_primary_radius, pri-radius-server,
+		   ISCSI_BOOT_INI_PRI_RADIUS_SERVER);
+iscsi_boot_rd_attr(ini_secondary_radius, sec-radius-server,
+		   ISCSI_BOOT_INI_SEC_RADIUS_SERVER);
+iscsi_boot_rd_attr(ini_name, initiator-name, ISCSI_BOOT_INI_INITIATOR_NAME);
+
+static struct attribute *initiator_attrs[] = {
+	&amp;iscsi_boot_attr_ini_index.attr,
+	&amp;iscsi_boot_attr_ini_flags.attr,
+	&amp;iscsi_boot_attr_ini_isns.attr,
+	&amp;iscsi_boot_attr_ini_slp.attr,
+	&amp;iscsi_boot_attr_ini_primary_radius.attr,
+	&amp;iscsi_boot_attr_ini_secondary_radius.attr,
+	&amp;iscsi_boot_attr_ini_name.attr,
+	NULL
+};
+
+static mode_t iscsi_boot_ini_attr_is_visible(struct kobject *kobj,
+					     struct attribute *attr, int i)
+{
+	struct iscsi_boot_kobj *boot_kobj =
+			container_of(kobj, struct iscsi_boot_kobj, kobj);
+
+	if (attr ==  &amp;iscsi_boot_attr_ini_index.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_INI_INDEX);
+	if (attr ==  &amp;iscsi_boot_attr_ini_flags.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_INI_FLAGS);
+	if (attr ==  &amp;iscsi_boot_attr_ini_isns.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_INI_ISNS_SERVER);
+	if (attr ==  &amp;iscsi_boot_attr_ini_slp.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_INI_SLP_SERVER);
+	if (attr ==  &amp;iscsi_boot_attr_ini_primary_radius.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_INI_PRI_RADIUS_SERVER);
+	if (attr ==  &amp;iscsi_boot_attr_ini_secondary_radius.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_INI_SEC_RADIUS_SERVER);
+	if (attr ==  &amp;iscsi_boot_attr_ini_name.attr)
+		return boot_kobj-&gt;is_visible(boot_kobj-&gt;data,
+					     ISCSI_BOOT_INI_INITIATOR_NAME);
+
+	return 0;
+}
+
+static struct attribute_group iscsi_boot_initiator_attr_group = {
+	.attrs = initiator_attrs,
+	.is_visible = iscsi_boot_ini_attr_is_visible,
+};
+
+static struct iscsi_boot_kobj *
+iscsi_boot_create_kobj(struct iscsi_boot_kset *boot_kset,
+		       struct attribute_group *attr_group,
+		       const char *name, int index, void *data,
+		       ssize_t (*show) (void *data, int type, char *buf),
+		       mode_t (*is_visible) (void *data, int type))
+{
+	struct iscsi_boot_kobj *boot_kobj;
+
+	boot_kobj = kzalloc(sizeof(*boot_kobj), GFP_KERNEL);
+	if (!boot_kobj)
+		return NULL;
+	INIT_LIST_HEAD(&amp;boot_kobj-&gt;list);
+
+	boot_kobj-&gt;kobj.kset = boot_kset-&gt;kset;
+	if (kobject_init_and_add(&amp;boot_kobj-&gt;kobj, &amp;iscsi_boot_ktype,
+				 NULL, name, index)) {
+		kfree(boot_kobj);
+		return NULL;
+	}
+	boot_kobj-&gt;data = data;
+	boot_kobj-&gt;show = show;
+	boot_kobj-&gt;is_visible = is_visible;
+
+	if (sysfs_create_group(&amp;boot_kobj-&gt;kobj, attr_group)) {
+		/*
+		 * We do not want to free this because the caller
+		 * will assume that since the creation call failed
+		 * the boot kobj was not setup and the normal release
+		 * path is not being run.
+		 */
+		boot_kobj-&gt;data = NULL;
+		kobject_put(&amp;boot_kobj-&gt;kobj);
+		return NULL;
+	}
+	boot_kobj-&gt;attr_group = attr_group;
+
+	kobject_uevent(&amp;boot_kobj-&gt;kobj, KOBJ_ADD);
+	/* Nothing broke so lets add it to the list. */
+	list_add_tail(&amp;boot_kobj-&gt;list, &amp;boot_kset-&gt;kobj_list);
+	return boot_kobj;
+}
+
+static void iscsi_boot_remove_kobj(struct iscsi_boot_kobj *boot_kobj)
+{
+	list_del(&amp;boot_kobj-&gt;list);
+	sysfs_remove_group(&amp;boot_kobj-&gt;kobj, boot_kobj-&gt;attr_group);
+	kobject_put(&amp;boot_kobj-&gt;kobj);
+}
+
+/**
+ * iscsi_boot_create_target() - create boot target sysfs dir
+ * @boot_kset: boot kset
+ * @index: the target id
+ * @data: driver specific data for target
+ * @show: attr show function
+ * @is_visible: attr visibility function
+ *
+ * Note: The boot sysfs lib will free the data passed in for the caller
+ * when all refs to the target kobject have been released.
+ */
+struct iscsi_boot_kobj *
+iscsi_boot_create_target(struct iscsi_boot_kset *boot_kset, int index,
+			 void *data,
+			 ssize_t (*show) (void *data, int type, char *buf),
+			 mode_t (*is_visible) (void *data, int type))
+{
+	return iscsi_boot_create_kobj(boot_kset, &amp;iscsi_boot_target_attr_group,
+				      "target%d", index, data, show, is_visible);
+}
+EXPORT_SYMBOL_GPL(iscsi_boot_create_target);
+
+/**
+ * iscsi_boot_create_initiator() - create boot initiator sysfs dir
+ * @boot_kset: boot kset
+ * @index: the initiator id
+ * @data: driver specific data
+ * @show: attr show function
+ * @is_visible: attr visibility function
+ *
+ * Note: The boot sysfs lib will free the data passed in for the caller
+ * when all refs to the initiator kobject have been released.
+ */
+struct iscsi_boot_kobj *
+iscsi_boot_create_initiator(struct iscsi_boot_kset *boot_kset, int index,
+			    void *data,
+			    ssize_t (*show) (void *data, int type, char *buf),
+			    mode_t (*is_visible) (void *data, int type))
+{
+	return iscsi_boot_create_kobj(boot_kset,
+				      &amp;iscsi_boot_initiator_attr_group,
+				      "initiator", index, data, show,
+				      is_visible);
+}
+EXPORT_SYMBOL_GPL(iscsi_boot_create_initiator);
+
+/**
+ * iscsi_boot_create_ethernet() - create boot ethernet sysfs dir
+ * @boot_kset: boot kset
+ * @index: the ethernet device id
+ * @data: driver specific data
+ * @show: attr show function
+ * @is_visible: attr visibility function
+ *
+ * Note: The boot sysfs lib will free the data passed in for the caller
+ * when all refs to the ethernet kobject have been released.
+ */
+struct iscsi_boot_kobj *
+iscsi_boot_create_ethernet(struct iscsi_boot_kset *boot_kset, int index,
+			   void *data,
+			   ssize_t (*show) (void *data, int type, char *buf),
+			   mode_t (*is_visible) (void *data, int type))
+{
+	return iscsi_boot_create_kobj(boot_kset,
+				      &amp;iscsi_boot_ethernet_attr_group,
+				      "ethernet%d", index, data, show,
+				      is_visible);
+}
+EXPORT_SYMBOL_GPL(iscsi_boot_create_ethernet);
+
+/**
+ * iscsi_boot_create_kset() - creates root sysfs tree
+ * @set_name: name of root dir
+ */
+struct iscsi_boot_kset *iscsi_boot_create_kset(const char *set_name)
+{
+	struct iscsi_boot_kset *boot_kset;
+
+	boot_kset = kzalloc(sizeof(*boot_kset), GFP_KERNEL);
+	if (!boot_kset)
+		return NULL;
+
+	boot_kset-&gt;kset = kset_create_and_add(set_name, NULL, firmware_kobj);
+	if (!boot_kset-&gt;kset) {
+		kfree(boot_kset);
+		return NULL;
+	}
+
+	INIT_LIST_HEAD(&amp;boot_kset-&gt;kobj_list);
+	return boot_kset;
+}
+EXPORT_SYMBOL_GPL(iscsi_boot_create_kset);
+
+/**
+ * iscsi_boot_create_host_kset() - creates root sysfs tree for a scsi host
+ * @hostno: host number of scsi host
+ */
+struct iscsi_boot_kset *iscsi_boot_create_host_kset(unsigned int hostno)
+{
+	struct iscsi_boot_kset *boot_kset;
+	char *set_name;
+
+	set_name = kasprintf(GFP_KERNEL, "iscsi_boot%u", hostno);
+	if (!set_name)
+		return NULL;
+
+	boot_kset = iscsi_boot_create_kset(set_name);
+	kfree(set_name);
+	return boot_kset;
+}
+EXPORT_SYMBOL_GPL(iscsi_boot_create_host_kset);
+
+/**
+ * iscsi_boot_destroy_kset() - destroy kset and kobjects under it
+ * @boot_kset: boot kset
+ *
+ * This will remove the kset and kobjects and attrs under it.
+ */
+void iscsi_boot_destroy_kset(struct iscsi_boot_kset *boot_kset)
+{
+	struct iscsi_boot_kobj *boot_kobj, *tmp_kobj;
+
+	list_for_each_entry_safe(boot_kobj, tmp_kobj,
+				 &amp;boot_kset-&gt;kobj_list, list)
+		iscsi_boot_remove_kobj(boot_kobj);
+
+	kset_unregister(boot_kset-&gt;kset);
+}
+EXPORT_SYMBOL_GPL(iscsi_boot_destroy_kset);
diff --git a/include/linux/iscsi_boot_sysfs.h b/include/linux/iscsi_boot_sysfs.h
new file mode 100644
index 000000000000..f1e6c184f14f
--- /dev/null
+++ b/include/linux/iscsi_boot_sysfs.h
@@ -0,0 +1,123 @@
+/*
+ * Export the iSCSI boot info to userland via sysfs.
+ *
+ * Copyright (C) 2010 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2010 Mike Christie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License v2.0 as published by
+ * the Free Software Foundation
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _ISCSI_BOOT_SYSFS_
+#define _ISCSI_BOOT_SYSFS_
+
+/*
+ * The text attributes names for each of the kobjects.
+*/
+enum iscsi_boot_eth_properties_enum {
+	ISCSI_BOOT_ETH_INDEX,
+	ISCSI_BOOT_ETH_FLAGS,
+	ISCSI_BOOT_ETH_IP_ADDR,
+	ISCSI_BOOT_ETH_SUBNET_MASK,
+	ISCSI_BOOT_ETH_ORIGIN,
+	ISCSI_BOOT_ETH_GATEWAY,
+	ISCSI_BOOT_ETH_PRIMARY_DNS,
+	ISCSI_BOOT_ETH_SECONDARY_DNS,
+	ISCSI_BOOT_ETH_DHCP,
+	ISCSI_BOOT_ETH_VLAN,
+	ISCSI_BOOT_ETH_MAC,
+	/* eth_pci_bdf - this is replaced by link to the device itself. */
+	ISCSI_BOOT_ETH_HOSTNAME,
+	ISCSI_BOOT_ETH_END_MARKER,
+};
+
+enum iscsi_boot_tgt_properties_enum {
+	ISCSI_BOOT_TGT_INDEX,
+	ISCSI_BOOT_TGT_FLAGS,
+	ISCSI_BOOT_TGT_IP_ADDR,
+	ISCSI_BOOT_TGT_PORT,
+	ISCSI_BOOT_TGT_LUN,
+	ISCSI_BOOT_TGT_CHAP_TYPE,
+	ISCSI_BOOT_TGT_NIC_ASSOC,
+	ISCSI_BOOT_TGT_NAME,
+	ISCSI_BOOT_TGT_CHAP_NAME,
+	ISCSI_BOOT_TGT_CHAP_SECRET,
+	ISCSI_BOOT_TGT_REV_CHAP_NAME,
+	ISCSI_BOOT_TGT_REV_CHAP_SECRET,
+	ISCSI_BOOT_TGT_END_MARKER,
+};
+
+enum iscsi_boot_initiator_properties_enum {
+	ISCSI_BOOT_INI_INDEX,
+	ISCSI_BOOT_INI_FLAGS,
+	ISCSI_BOOT_INI_ISNS_SERVER,
+	ISCSI_BOOT_INI_SLP_SERVER,
+	ISCSI_BOOT_INI_PRI_RADIUS_SERVER,
+	ISCSI_BOOT_INI_SEC_RADIUS_SERVER,
+	ISCSI_BOOT_INI_INITIATOR_NAME,
+	ISCSI_BOOT_INI_END_MARKER,
+};
+
+struct attribute_group;
+
+struct iscsi_boot_kobj {
+	struct kobject kobj;
+	struct attribute_group *attr_group;
+	struct list_head list;
+
+	/*
+	 * Pointer to store driver specific info. If set this will
+	 * be freed for the LLD when the kobj release function is called.
+	 */
+	void *data;
+	/*
+	 * Driver specific show function.
+	 *
+	 * The enum of the type. This can be any value of the above
+	 * properties.
+	 */
+	ssize_t (*show) (void *data, int type, char *buf);
+
+	/*
+	 * Drivers specific visibility function.
+	 * The function should return if they the attr should be readable
+	 * writable or should not be shown.
+	 *
+	 * The enum of the type. This can be any value of the above
+	 * properties.
+	 */
+	mode_t (*is_visible) (void *data, int type);
+};
+
+struct iscsi_boot_kset {
+	struct list_head kobj_list;
+	struct kset *kset;
+};
+
+struct iscsi_boot_kobj *
+iscsi_boot_create_initiator(struct iscsi_boot_kset *boot_kset, int index,
+			    void *data,
+			    ssize_t (*show) (void *data, int type, char *buf),
+			    mode_t (*is_visible) (void *data, int type));
+
+struct iscsi_boot_kobj *
+iscsi_boot_create_ethernet(struct iscsi_boot_kset *boot_kset, int index,
+			   void *data,
+			   ssize_t (*show) (void *data, int type, char *buf),
+			   mode_t (*is_visible) (void *data, int type));
+struct iscsi_boot_kobj *
+iscsi_boot_create_target(struct iscsi_boot_kset *boot_kset, int index,
+			 void *data,
+			 ssize_t (*show) (void *data, int type, char *buf),
+			 mode_t (*is_visible) (void *data, int type));
+
+struct iscsi_boot_kset *iscsi_boot_create_kset(const char *set_name);
+struct iscsi_boot_kset *iscsi_boot_create_host_kset(unsigned int hostno);
+void iscsi_boot_destroy_kset(struct iscsi_boot_kset *boot_kset);
+
+#endif</pre><hr><pre>commit 96b1f96dcab87756c0a1e7ba76bc5dc2add82b88
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Sat Apr 24 16:21:19 2010 -0500

    [SCSI] libiscsi: regression: fix header digest errors
    
    This fixes a regression introduced with this commit:
    
    commit d3305f3407fa3e9452079ec6cc8379067456e4aa
    Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Date:   Thu Aug 20 15:10:58 2009 -0500
    
        [SCSI] libiscsi: don't increment cmdsn if cmd is not sent
    
    in 2.6.32.
    
    When I moved the hdr-&gt;cmdsn after init_task, I added
    a bug when header digests are used. The problem is
    that the LLD may calculate the header digest in init_task,
    so if we then set the cmdsn after the init_task call we
    change what the digest will be calculated by the target.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: Stable Tree &lt;stable@kernel.org&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 6d5ae4474bb3..633e09036357 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -471,12 +471,12 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 
 	WARN_ON(hdrlength &gt;= 256);
 	hdr-&gt;hlength = hdrlength &amp; 0xFF;
+	hdr-&gt;cmdsn = task-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 
 	if (session-&gt;tt-&gt;init_task &amp;&amp; session-&gt;tt-&gt;init_task(task))
 		return -EIO;
 
 	task-&gt;state = ISCSI_TASK_RUNNING;
-	hdr-&gt;cmdsn = task-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	session-&gt;cmdsn++;
 
 	conn-&gt;scsicmd_pdus_cnt++;</pre><hr><pre>commit 5738d4449c1baf05e8345684d12371f76296473d
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Apr 9 22:07:37 2010 -0500

    [SCSI] scsi_dh_emc: request flag cleanup
    
    blk_get_request sets the cmd_flags, so we should not and do not
    need to set them. If we did set them to a different value then
    it can cause a oops in the elevator code.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/device_handler/scsi_dh_emc.c b/drivers/scsi/device_handler/scsi_dh_emc.c
index e8a0bc3efd49..6faf472f7537 100644
--- a/drivers/scsi/device_handler/scsi_dh_emc.c
+++ b/drivers/scsi/device_handler/scsi_dh_emc.c
@@ -285,13 +285,11 @@ static struct request *get_req(struct scsi_device *sdev, int cmd,
 	switch (cmd) {
 	case MODE_SELECT:
 		len = sizeof(short_trespass);
-		rq-&gt;cmd_flags |= REQ_RW;
 		rq-&gt;cmd[1] = 0x10;
 		rq-&gt;cmd[4] = len;
 		break;
 	case MODE_SELECT_10:
 		len = sizeof(long_trespass);
-		rq-&gt;cmd_flags |= REQ_RW;
 		rq-&gt;cmd[1] = 0x10;
 		rq-&gt;cmd[8] = len;
 		break;</pre><hr><pre>commit d7d05548a62c87ee55b0c81933669177f885aa8d
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Mar 31 14:41:35 2010 -0500

    [SCSI] iscsi_tcp: fix relogin/shutdown hang
    
    When I made this patch:
    b64e77f70b8c11766e967e3485331a9e6ef01390
    it was to solve a problem where we were already on the waitqueue
    becuase a connection problem/logout caused us to be on there
    when we were cleaning up the session. If we happen to get
    on queue for more normal reasons like their just does not happen
    to be any send space at the same time we are closing the connection
    we hit a race and get stuck in the wait.
    
    We should not check if the waitqueue is active
    because we could race with the network code. If
    the network xmit code is just about to enter the
    prepare to wait when we check for the waitqueue to
    be active then we will miss each other and the
    network code will fall into the wait and we will
    not run wake_up.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 0ee725ced511..02143af7c1af 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -599,7 +599,7 @@ static void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
 	write_unlock_bh(&amp;tcp_sw_conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
 
-	if (sock-&gt;sk-&gt;sk_sleep &amp;&amp; waitqueue_active(sock-&gt;sk-&gt;sk_sleep)) {
+	if (sock-&gt;sk-&gt;sk_sleep) {
 		sock-&gt;sk-&gt;sk_err = EIO;
 		wake_up_interruptible(sock-&gt;sk-&gt;sk_sleep);
 	}</pre><hr><pre>commit 4ae0a6c15efcc37e94e3f30e3533bdec03c53126
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Mar 9 14:14:51 2010 -0600

    [SCSI] libiscsi: Fix recovery slowdown regression
    
    We could be failing/stopping a connection due to libiscsi starting
    recovery/cleanup, but the xmit path or scsi eh thread path
    could be dropping the connection at the same time.
    
    As a result the session-&gt;state gets set to failed instead of in
    recovery. We end up not blocking the session
    and so the replacement timeout never gets started and we only end up
    failing the IO when scsi_softirq_done sees that the
    cmd has been running for (cmd-&gt;allowed + 1) * rq-&gt;timeout secs.
    
    We used to fail the IO right away so users are seeing a long
    delay when using dm-multipath. This problem was added in
    2.6.28.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 685eaec53218..7688b8f83e98 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -3087,14 +3087,15 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 		session-&gt;state = ISCSI_STATE_TERMINATE;
 	else if (conn-&gt;stop_stage != STOP_CONN_RECOVER)
 		session-&gt;state = ISCSI_STATE_IN_RECOVERY;
+
+	old_stop_stage = conn-&gt;stop_stage;
+	conn-&gt;stop_stage = flag;
 	spin_unlock_bh(&amp;session-&gt;lock);
 
 	del_timer_sync(&amp;conn-&gt;transport_timer);
 	iscsi_suspend_tx(conn);
 
 	spin_lock_bh(&amp;session-&gt;lock);
-	old_stop_stage = conn-&gt;stop_stage;
-	conn-&gt;stop_stage = flag;
 	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
 	spin_unlock_bh(&amp;session-&gt;lock);
 </pre><hr><pre>commit cd4a8814d44672bd2c8f04a472121bfbe193809c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Feb 18 17:32:03 2010 -0600

    [SCSI] scsi_dh_alua: add netapp to dev list
    
    Newer Netapp target software supports ALUA, so
    this patch adds them to the scsi_dev_alua dev list.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/device_handler/scsi_dh_alua.c b/drivers/scsi/device_handler/scsi_dh_alua.c
index 4f0d0138f48b..ee372bf55332 100644
--- a/drivers/scsi/device_handler/scsi_dh_alua.c
+++ b/drivers/scsi/device_handler/scsi_dh_alua.c
@@ -717,6 +717,7 @@ static const struct scsi_dh_devlist alua_dev_list[] = {
 	{"IBM", "2145" },
 	{"Pillar", "Axiom" },
 	{"Intel", "Multi-Flex"},
+	{"NETAPP", "LUN"},
 	{NULL, NULL}
 };
 </pre>
    <div class="pagination">
        <a href='5_11.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><span>[12]</span><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_13.html'>Next&gt;&gt;</a>
    <div>
</body>
