<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_126.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><span>[127]</span><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_128.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2775562ad2af2fc131ef7987166db6e42217528f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 5 16:32:02 2006 -0400

    [PATCH] USB: UHCI: fix obscure bug in enqueue()
    
    This patch (as676) fixes a small bug in uhci-hcd's enqueue routine.  When
    an URB is unlinked or gets an error and the completion handler queues
    another URB for the same endpoint, the queue shouldn't be allowed to start
    up again until the handler returns.  Not even if the new URB is the only
    one on its queue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 8639e9035931..693e92c1bd9e 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1148,8 +1148,9 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 
 	/* If the new URB is the first and only one on this QH then either
 	 * the QH is new and idle or else it's unlinked and waiting to
-	 * become idle, so we can activate it right away. */
-	if (qh-&gt;queue.next == &amp;urbp-&gt;node)
+	 * become idle, so we can activate it right away.  But only if the
+	 * queue isn't stopped. */
+	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped)
 		uhci_activate_qh(uhci, qh);
 	goto done;
 
@@ -1293,27 +1294,32 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		if (urb-&gt;status == -EINPROGRESS)	/* Not dequeued */
 			urb-&gt;status = status;
 		else
-			status = -ECONNRESET;
+			status = ECONNRESET;		/* Not -ECONNRESET */
 		spin_unlock(&amp;urb-&gt;lock);
 
 		/* Dequeued but completed URBs can't be given back unless
 		 * the QH is stopped or has finished unlinking. */
-		if (status == -ECONNRESET &amp;&amp;
-				!(qh-&gt;is_stopped || QH_FINISHED_UNLINKING(qh)))
-			return;
+		if (status == ECONNRESET) {
+			if (QH_FINISHED_UNLINKING(qh))
+				qh-&gt;is_stopped = 1;
+			else if (!qh-&gt;is_stopped)
+				return;
+		}
 
 		uhci_giveback_urb(uhci, qh, urb, regs);
-		if (qh-&gt;is_stopped)
+		if (status &lt; 0)
 			break;
 	}
 
 	/* If the QH is neither stopped nor finished unlinking (normal case),
 	 * our work here is done. */
- restart:
-	if (!(qh-&gt;is_stopped || QH_FINISHED_UNLINKING(qh)))
+	if (QH_FINISHED_UNLINKING(qh))
+		qh-&gt;is_stopped = 1;
+	else if (!qh-&gt;is_stopped)
 		return;
 
 	/* Otherwise give back each of the dequeued URBs */
+restart:
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
 		if (urb-&gt;status != -EINPROGRESS) {</pre><hr><pre>commit 4de7d2c231a8624a47417977be0768c5b5257c4f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 5 16:26:58 2006 -0400

    [PATCH] USB: UHCI: store the endpoint type in the QH structure
    
    This patch (as675) simplifies uhci-hcd slightly by storing each endpoint's
    type in the corresponding Queue Header structure.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index e1239319655c..28c1c51ec475 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -98,6 +98,7 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	char *out = buf;
 	struct uhci_td *td;
 	int i, nactive, ninactive;
+	char *ptype;
 
 	if (len &lt; 200)
 		return 0;
@@ -110,13 +111,14 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 			(usb_pipein(urbp-&gt;urb-&gt;pipe) ? "IN" : "OUT"));
 
 	switch (usb_pipetype(urbp-&gt;urb-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS: out += sprintf(out, "ISO"); break;
-	case PIPE_INTERRUPT: out += sprintf(out, "INT"); break;
-	case PIPE_BULK: out += sprintf(out, "BLK"); break;
-	case PIPE_CONTROL: out += sprintf(out, "CTL"); break;
+	case PIPE_ISOCHRONOUS: ptype = "ISO"; break;
+	case PIPE_INTERRUPT: ptype = "INT"; break;
+	case PIPE_BULK: ptype = "BLK"; break;
+	default:
+	case PIPE_CONTROL: ptype = "CTL"; break;
 	}
 
-	out += sprintf(out, "%s", (urbp-&gt;fsbr ? " FSBR" : ""));
+	out += sprintf(out, "%s%s", ptype, (urbp-&gt;fsbr ? " FSBR" : ""));
 
 	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
 		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
@@ -147,13 +149,23 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	char *out = buf;
 	int i, nurbs;
 	__le32 element = qh_element(qh);
+	char *qtype;
 
 	/* Try to make sure there's enough memory */
 	if (len &lt; 80 * 6)
 		return 0;
 
-	out += sprintf(out, "%*s[%p] link (%08x) element (%08x)\n", space, "",
-			qh, le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_ISOC: qtype = "ISO"; break;
+	case USB_ENDPOINT_XFER_INT: qtype = "INT"; break;
+	case USB_ENDPOINT_XFER_BULK: qtype = "BLK"; break;
+	case USB_ENDPOINT_XFER_CONTROL: qtype = "CTL"; break;
+	default: qtype = "Skel" ; break;
+	}
+
+	out += sprintf(out, "%*s[%p] %s QH link (%08x) element (%08x)\n",
+			space, "", qh, qtype,
+			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index d5c8f4d92823..8e5778650493 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -132,6 +132,7 @@ struct uhci_qh {
 
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
+	int type;			/* Queue type (control, bulk, etc) */
 
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index a06d84c19e13..8639e9035931 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -179,10 +179,12 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 		qh-&gt;hep = hep;
 		qh-&gt;udev = udev;
 		hep-&gt;hcpriv = qh;
+		qh-&gt;type = hep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK;
 
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
 		qh-&gt;udev = NULL;
+		qh-&gt;type = -1;
 	}
 	return qh;
 }
@@ -217,8 +219,8 @@ static void uhci_save_toggle(struct uhci_qh *qh, struct urb *urb)
 	qh-&gt;element = UHCI_PTR_TERM;
 
 	/* Only bulk and interrupt pipes have to worry about toggles */
-	if (!(usb_pipetype(urb-&gt;pipe) == PIPE_BULK ||
-			usb_pipetype(urb-&gt;pipe) == PIPE_INTERRUPT))
+	if (!(qh-&gt;type == USB_ENDPOINT_XFER_BULK ||
+			qh-&gt;type == USB_ENDPOINT_XFER_INT))
 		return;
 
 	/* Find the first active TD; that's the device's toggle state */
@@ -1099,14 +1101,14 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	}
 	urbp-&gt;qh = qh;
 
-	switch (usb_pipetype(urb-&gt;pipe)) {
-	case PIPE_CONTROL:
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_CONTROL:
 		ret = uhci_submit_control(uhci, urb, qh);
 		break;
-	case PIPE_BULK:
+	case USB_ENDPOINT_XFER_BULK:
 		ret = uhci_submit_bulk(uhci, urb, qh);
 		break;
-	case PIPE_INTERRUPT:
+	case USB_ENDPOINT_XFER_INT:
 		if (list_empty(&amp;qh-&gt;queue)) {
 			bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 			if (bustime &lt; 0)
@@ -1125,7 +1127,7 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 			ret = uhci_submit_interrupt(uhci, urb, qh);
 		}
 		break;
-	case PIPE_ISOCHRONOUS:
+	case USB_ENDPOINT_XFER_ISOC:
 		bustime = usb_check_bandwidth(urb-&gt;dev, urb);
 		if (bustime &lt; 0) {
 			ret = bustime;
@@ -1175,7 +1177,7 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 		goto done;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
-	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
+	if (urbp-&gt;qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 	uhci_unlink_qh(uhci, urbp-&gt;qh);
 
@@ -1195,7 +1197,7 @@ __acquires(uhci-&gt;lock)
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
 	/* Isochronous TDs get unlinked directly from the frame list */
-	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 
 	/* If the URB isn't first on its queue, adjust the link pointer
@@ -1224,13 +1226,13 @@ __acquires(uhci-&gt;lock)
 	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
 	uhci_free_urb_priv(uhci, urbp);
 
-	switch (usb_pipetype(urb-&gt;pipe)) {
-	case PIPE_ISOCHRONOUS:
+	switch (qh-&gt;type) {
+	case USB_ENDPOINT_XFER_ISOC:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		if (urb-&gt;bandwidth)
 			usb_release_bandwidth(urb-&gt;dev, urb, 1);
 		break;
-	case PIPE_INTERRUPT:
+	case USB_ENDPOINT_XFER_INT:
 		/* Release bandwidth for Interrupt or Isoc. transfers */
 		/* Make sure we don't release if we have a queued URB */
 		if (list_empty(&amp;qh-&gt;queue) &amp;&amp; urb-&gt;bandwidth)
@@ -1273,14 +1275,14 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
 		urb = urbp-&gt;urb;
 
-		switch (usb_pipetype(urb-&gt;pipe)) {
-		case PIPE_CONTROL:
+		switch (qh-&gt;type) {
+		case USB_ENDPOINT_XFER_CONTROL:
 			status = uhci_result_control(uhci, urb);
 			break;
-		case PIPE_ISOCHRONOUS:
+		case USB_ENDPOINT_XFER_ISOC:
 			status = uhci_result_isochronous(uhci, urb);
 			break;
-		default:	/* PIPE_BULK or PIPE_INTERRUPT */
+		default:	/* USB_ENDPOINT_XFER_BULK or _INT */
 			status = uhci_result_common(uhci, urb);
 			break;
 		}</pre><hr><pre>commit 2d61bde7a0e630e1906e6478b6b2a7aeaaa8f8da
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 5 16:23:42 2006 -0400

    [PATCH] USB: net2280: add a shutdown routine
    
    The net2280 board has an annoying habit of surviving soft reboots with
    interrupts enabled.  This patch (as674) adds a shutdown routine to the
    driver so that the board can be put in a quiescent state.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 020d3c42b1af..1facdea56a8a 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2966,6 +2966,22 @@ static int net2280_probe (struct pci_dev *pdev, const struct pci_device_id *id)
 	return retval;
 }
 
+/* make sure the board is quiescent; otherwise it will continue
+ * generating IRQs across the upcoming reboot.
+ */
+
+static void net2280_shutdown (struct pci_dev *pdev)
+{
+	struct net2280		*dev = pci_get_drvdata (pdev);
+
+	/* disable IRQs */
+	writel (0, &amp;dev-&gt;regs-&gt;pciirqenb0);
+	writel (0, &amp;dev-&gt;regs-&gt;pciirqenb1);
+
+	/* disable the pullup so the host will think we're gone */
+	writel (0, &amp;dev-&gt;usb-&gt;usbctl);
+}
+
 
 /*-------------------------------------------------------------------------*/
 
@@ -2995,6 +3011,7 @@ static struct pci_driver net2280_pci_driver = {
 
 	.probe =	net2280_probe,
 	.remove =	net2280_remove,
+	.shutdown =	net2280_shutdown,
 
 	/* FIXME add power management support */
 };</pre><hr><pre>commit 4489a5712b086621a6c3f669057d2996245cd3fb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 27 15:54:22 2006 -0400

    [PATCH] USB: usbcore: always turn on hub port power
    
    Some hubs claim not to support port-power switching, and right now the
    hub driver believes them and does not enable power to their ports.
    However it turns out that even though they don't actually switch power,
    they do ignore all events on a port until told to turn on the power!
    This problem has been reported by several users.
    
    This revised patch (as672b) makes the hub driver always try to turn on
    port power to all hubs, regardless of what the hub descriptor says.  It
    also adds a comment explaining the need for this.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 90b8d43c6b33..1b1846e6473b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -432,15 +432,22 @@ static void hub_power_on(struct usb_hub *hub)
 {
 	int port1;
 	unsigned pgood_delay = hub-&gt;descriptor-&gt;bPwrOn2PwrGood * 2;
-	u16 wHubCharacteristics = le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
-
-	/* if hub supports power switching, enable power on each port */
-	if ((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2) {
+	u16 wHubCharacteristics =
+			le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
+
+	/* Enable power on each port.  Some hubs have reserved values
+	 * of LPSM (&gt; 2) in their descriptors, even though they are
+	 * USB 2.0 hubs.  Some hubs do not implement port-power switching
+	 * but only emulate it.  In all cases, the ports won't work
+	 * unless we send these messages to the hub.
+	 */
+	if ((wHubCharacteristics &amp; HUB_CHAR_LPSM) &lt; 2)
 		dev_dbg(hub-&gt;intfdev, "enabling power on all ports\n");
-		for (port1 = 1; port1 &lt;= hub-&gt;descriptor-&gt;bNbrPorts; port1++)
-			set_port_feature(hub-&gt;hdev, port1,
-					USB_PORT_FEAT_POWER);
-	}
+	else
+		dev_dbg(hub-&gt;intfdev, "trying to enable port power on "
+				"non-switchable hub\n");
+	for (port1 = 1; port1 &lt;= hub-&gt;descriptor-&gt;bNbrPorts; port1++)
+		set_port_feature(hub-&gt;hdev, port1, USB_PORT_FEAT_POWER);
 
 	/* Wait at least 100 msec for power to become stable */
 	msleep(max(pgood_delay, (unsigned) 100));</pre><hr><pre>commit 3e95637a48820ff8bedb33e6439def96ccff1de5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 16 17:10:48 2006 -0400

    [PATCH] Driver Core: Make dev_info and friends print the bus name if there is no driver
    
    This patch (as721) makes dev_info and related macros print the device's
    bus name if the device doesn't have a driver, instead of printing just a
    blank.  If the device isn't on a bus either... well, then it does leave
    a blank space.  But it will be easier for someone else to change if they
    want.
    
    Cc: Matthew Wilcox &lt;matthew@wil.cx&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index a979bc3f49a9..d0f84ff78776 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -29,6 +29,22 @@ int (*platform_notify_remove)(struct device * dev) = NULL;
  * sysfs bindings for devices.
  */
 
+/**
+ * dev_driver_string - Return a device's driver name, if at all possible
+ * @dev: struct device to get the name of
+ *
+ * Will return the device's driver's name if it is bound to a device.  If
+ * the device is not bound to a device, it will return the name of the bus
+ * it is attached to.  If it is not attached to a bus either, an empty
+ * string will be returned.
+ */
+const char *dev_driver_string(struct device *dev)
+{
+	return dev-&gt;driver ? dev-&gt;driver-&gt;name :
+			(dev-&gt;bus ? dev-&gt;bus-&gt;name : "");
+}
+EXPORT_SYMBOL_GPL(dev_driver_string);
+
 #define to_dev(obj) container_of(obj, struct device, kobj)
 #define to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)
 
diff --git a/include/linux/device.h b/include/linux/device.h
index b473f4278910..1e5f30da98bc 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -416,8 +416,9 @@ extern int firmware_register(struct subsystem *);
 extern void firmware_unregister(struct subsystem *);
 
 /* debugging and troubleshooting/diagnostic helpers. */
+extern const char *dev_driver_string(struct device *dev);
 #define dev_printk(level, dev, format, arg...)	\
-	printk(level "%s %s: " format , (dev)-&gt;driver ? (dev)-&gt;driver-&gt;name : "" , (dev)-&gt;bus_id , ## arg)
+	printk(level "%s %s: " format , dev_driver_string(dev) , (dev)-&gt;bus_id , ## arg)
 
 #ifdef DEBUG
 #define dev_dbg(dev, format, arg...)		\</pre><hr><pre>commit f07d5b946510a54937a75a3654941e855ffdc4c2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 9 15:23:03 2006 -0700

    [NET]: Make netdev_chain a raw notifier.
    
    From: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    This chain does it's own locking via the RTNL semaphore, and
    can also run recursively so adding a new mutex here was causing
    deadlocks.
    
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/core/dev.c b/net/core/dev.c
index 9ab3cfa58466..ced57430f6d8 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -193,7 +193,7 @@ static inline struct hlist_head *dev_index_hash(int ifindex)
  *	Our notifier list
  */
 
-static BLOCKING_NOTIFIER_HEAD(netdev_chain);
+static RAW_NOTIFIER_HEAD(netdev_chain);
 
 /*
  *	Device drivers call our routines to queue packets here. We empty the
@@ -736,7 +736,7 @@ int dev_change_name(struct net_device *dev, char *newname)
 	if (!err) {
 		hlist_del(&amp;dev-&gt;name_hlist);
 		hlist_add_head(&amp;dev-&gt;name_hlist, dev_name_hash(dev-&gt;name));
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGENAME, dev);
 	}
 
@@ -751,7 +751,7 @@ int dev_change_name(struct net_device *dev, char *newname)
  */
 void netdev_features_change(struct net_device *dev)
 {
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_FEAT_CHANGE, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_FEAT_CHANGE, dev);
 }
 EXPORT_SYMBOL(netdev_features_change);
 
@@ -766,7 +766,7 @@ EXPORT_SYMBOL(netdev_features_change);
 void netdev_state_change(struct net_device *dev)
 {
 	if (dev-&gt;flags &amp; IFF_UP) {
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGE, dev);
 		rtmsg_ifinfo(RTM_NEWLINK, dev, 0);
 	}
@@ -864,7 +864,7 @@ int dev_open(struct net_device *dev)
 		/*
 		 *	... and announce new interface.
 		 */
-		blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_UP, dev);
+		raw_notifier_call_chain(&amp;netdev_chain, NETDEV_UP, dev);
 	}
 	return ret;
 }
@@ -887,7 +887,7 @@ int dev_close(struct net_device *dev)
 	 *	Tell people we are going down, so that they can
 	 *	prepare to death, when device is still operating.
 	 */
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_GOING_DOWN, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_GOING_DOWN, dev);
 
 	dev_deactivate(dev);
 
@@ -924,7 +924,7 @@ int dev_close(struct net_device *dev)
 	/*
 	 * Tell people we are down
 	 */
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_DOWN, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_DOWN, dev);
 
 	return 0;
 }
@@ -955,7 +955,7 @@ int register_netdevice_notifier(struct notifier_block *nb)
 	int err;
 
 	rtnl_lock();
-	err = blocking_notifier_chain_register(&amp;netdev_chain, nb);
+	err = raw_notifier_chain_register(&amp;netdev_chain, nb);
 	if (!err) {
 		for (dev = dev_base; dev; dev = dev-&gt;next) {
 			nb-&gt;notifier_call(nb, NETDEV_REGISTER, dev);
@@ -983,7 +983,7 @@ int unregister_netdevice_notifier(struct notifier_block *nb)
 	int err;
 
 	rtnl_lock();
-	err = blocking_notifier_chain_unregister(&amp;netdev_chain, nb);
+	err = raw_notifier_chain_unregister(&amp;netdev_chain, nb);
 	rtnl_unlock();
 	return err;
 }
@@ -994,12 +994,12 @@ int unregister_netdevice_notifier(struct notifier_block *nb)
  *      @v:   pointer passed unmodified to notifier function
  *
  *	Call all network notifier blocks.  Parameters and return value
- *	are as for blocking_notifier_call_chain().
+ *	are as for raw_notifier_call_chain().
  */
 
 int call_netdevice_notifiers(unsigned long val, void *v)
 {
-	return blocking_notifier_call_chain(&amp;netdev_chain, val, v);
+	return raw_notifier_call_chain(&amp;netdev_chain, val, v);
 }
 
 /* When &gt; 0 there are consumers of rx skb time stamps */
@@ -2308,7 +2308,7 @@ int dev_change_flags(struct net_device *dev, unsigned flags)
 	if (dev-&gt;flags &amp; IFF_UP &amp;&amp;
 	    ((old_flags ^ dev-&gt;flags) &amp;~ (IFF_UP | IFF_PROMISC | IFF_ALLMULTI |
 					  IFF_VOLATILE)))
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGE, dev);
 
 	if ((flags ^ dev-&gt;gflags) &amp; IFF_PROMISC) {
@@ -2353,7 +2353,7 @@ int dev_set_mtu(struct net_device *dev, int new_mtu)
 	else
 		dev-&gt;mtu = new_mtu;
 	if (!err &amp;&amp; dev-&gt;flags &amp; IFF_UP)
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGEMTU, dev);
 	return err;
 }
@@ -2370,7 +2370,7 @@ int dev_set_mac_address(struct net_device *dev, struct sockaddr *sa)
 		return -ENODEV;
 	err = dev-&gt;set_mac_address(dev, sa);
 	if (!err)
-		blocking_notifier_call_chain(&amp;netdev_chain,
+		raw_notifier_call_chain(&amp;netdev_chain,
 				NETDEV_CHANGEADDR, dev);
 	return err;
 }
@@ -2427,7 +2427,7 @@ static int dev_ifsioc(struct ifreq *ifr, unsigned int cmd)
 				return -EINVAL;
 			memcpy(dev-&gt;broadcast, ifr-&gt;ifr_hwaddr.sa_data,
 			       min(sizeof ifr-&gt;ifr_hwaddr.sa_data, (size_t) dev-&gt;addr_len));
-			blocking_notifier_call_chain(&amp;netdev_chain,
+			raw_notifier_call_chain(&amp;netdev_chain,
 					    NETDEV_CHANGEADDR, dev);
 			return 0;
 
@@ -2882,7 +2882,7 @@ int register_netdevice(struct net_device *dev)
 	write_unlock_bh(&amp;dev_base_lock);
 
 	/* Notify protocols, that a new device appeared. */
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_REGISTER, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_REGISTER, dev);
 
 	/* Finish registration after unlock */
 	net_set_todo(dev);
@@ -2961,7 +2961,7 @@ static void netdev_wait_allrefs(struct net_device *dev)
 			rtnl_lock();
 
 			/* Rebroadcast unregister notification */
-			blocking_notifier_call_chain(&amp;netdev_chain,
+			raw_notifier_call_chain(&amp;netdev_chain,
 					    NETDEV_UNREGISTER, dev);
 
 			if (test_bit(__LINK_STATE_LINKWATCH_PENDING,
@@ -3216,7 +3216,7 @@ int unregister_netdevice(struct net_device *dev)
 	/* Notify protocols, that we are about to destroy
 	   this device. They should clean all the things.
 	*/
-	blocking_notifier_call_chain(&amp;netdev_chain, NETDEV_UNREGISTER, dev);
+	raw_notifier_call_chain(&amp;netdev_chain, NETDEV_UNREGISTER, dev);
 	
 	/*
 	 *	Flush the multicast chain</pre><hr><pre>commit 436f5762bcd4929825a0725d4bc78337e6fc0d8f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 2 15:22:41 2006 -0400

    [PATCH] USB: usbcore: don't check the device's power source
    
    The choose_configuration() routine contains code the determine the
    device's power source, so that configurations requiring external power
    can be ruled out if the device is running on bus power.  Unfortunately
    it turns out that some devices have errors in their config descriptors
    and other devices don't like the GET_DEVICE_STATUS request.
    
    Since that information wasn't used for anything else, this patch (as673)
    removes the code, leaving only a comment.  It fixes bugzilla entry
    #6448.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0c87f73f2933..90b8d43c6b33 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1168,19 +1168,9 @@ static inline const char *plural(int n)
 static int choose_configuration(struct usb_device *udev)
 {
 	int i;
-	u16 devstatus;
-	int bus_powered;
 	int num_configs;
 	struct usb_host_config *c, *best;
 
-	/* If this fails, assume the device is bus-powered */
-	devstatus = 0;
-	usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-	le16_to_cpus(&amp;devstatus);
-	bus_powered = ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0);
-	dev_dbg(&amp;udev-&gt;dev, "device is %s-powered\n",
-			bus_powered ? "bus" : "self");
-
 	best = NULL;
 	c = udev-&gt;config;
 	num_configs = udev-&gt;descriptor.bNumConfigurations;
@@ -1197,6 +1187,19 @@ static int choose_configuration(struct usb_device *udev)
 		 * similar errors in their descriptors.  If the next test
 		 * were allowed to execute, such configurations would always
 		 * be rejected and the devices would not work as expected.
+		 * In the meantime, we run the risk of selecting a config
+		 * that requires external power at a time when that power
+		 * isn't available.  It seems to be the lesser of two evils.
+		 *
+		 * Bugzilla #6448 reports a device that appears to crash
+		 * when it receives a GET_DEVICE_STATUS request!  We don't
+		 * have any other way to tell whether a device is self-powered,
+		 * but since we don't use that information anywhere but here,
+		 * the call has been removed.
+		 *
+		 * Maybe the GET_DEVICE_STATUS call and the test below can
+		 * be reinstated when device firmwares become more reliable.
+		 * Don't hold your breath.
 		 */
 #if 0
 		/* Rule out self-powered configs for a bus-powered device */</pre><hr><pre>commit 9fb81ce63671f9743517f628dac935269f2581a9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 14 16:46:28 2006 -0400

    [PATCH] USB: net2280: set driver data before it is used
    
    This patch (as671) fixes a bug in the error pathway for the net2280
    probe routine.  A failure during probe will cause the driver to call
    pci_get_drvdata before the corresponding pci_set_drvdata has been set.
    The patch also does a kzalloc conversion.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index b2d507f16b85..0b9293493957 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2833,13 +2833,13 @@ static int net2280_probe (struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 
 	/* alloc, and start init */
-	dev = kmalloc (sizeof *dev, SLAB_KERNEL);
+	dev = kzalloc (sizeof *dev, SLAB_KERNEL);
 	if (dev == NULL){
 		retval = -ENOMEM;
 		goto done;
 	}
 
-	memset (dev, 0, sizeof *dev);
+	pci_set_drvdata (pdev, dev);
 	spin_lock_init (&amp;dev-&gt;lock);
 	dev-&gt;pdev = pdev;
 	dev-&gt;gadget.ops = &amp;net2280_ops;
@@ -2952,7 +2952,6 @@ static int net2280_probe (struct pci_dev *pdev, const struct pci_device_id *id)
 	dev-&gt;chiprev = get_idx_reg (dev-&gt;regs, REG_CHIPREV) &amp; 0xffff;
 
 	/* done */
-	pci_set_drvdata (pdev, dev);
 	INFO (dev, "%s\n", driver_desc);
 	INFO (dev, "irq %s, pci mem %p, chip rev %04x\n",
 			bufp, base, dev-&gt;chiprev);</pre><hr><pre>commit 658ad5e001a17be5fadaa8d57d1aa7f7c62628c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 14 16:44:11 2006 -0400

    [PATCH] USB: net2280: check for shared IRQs
    
    This patch (as670) adds a check for whether a shared IRQ was actually
    generated by the net2280 device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index c842b194cf0f..b2d507f16b85 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2742,6 +2742,10 @@ static irqreturn_t net2280_irq (int irq, void *_dev, struct pt_regs * r)
 {
 	struct net2280		*dev = _dev;
 
+	/* shared interrupt, not ours */
+	if (!(readl(&amp;dev-&gt;regs-&gt;irqstat0) &amp; (1 &lt;&lt; INTA_ASSERTED)))
+		return IRQ_NONE;
+
 	spin_lock (&amp;dev-&gt;lock);
 
 	/* handle disconnect, dma, and more */</pre><hr><pre>commit 317e83b842ba39776054219ae29844127876416a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 14 16:42:03 2006 -0400

    [PATCH] USB: net2280: send 0-length packets for ep0
    
    This patch (as669) fixes a bug in the net2280 driver.  Now it will
    properly send zero-length packets on ep0 until the control status stage
    occurs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 2d5cededcbd7..c842b194cf0f 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -2280,9 +2280,7 @@ static void handle_ep_small (struct net2280_ep *ep)
 		/* if we wrote it all, we're usually done */
 		if (req-&gt;req.actual == req-&gt;req.length) {
 			if (ep-&gt;num == 0) {
-				/* wait for control status */
-				if (mode != 2)
-					req = NULL;
+				/* send zlps until the status stage */
 			} else if (!req-&gt;req.zero || len != ep-&gt;ep.maxpacket)
 				mode = 2;
 		}</pre>
    <div class="pagination">
        <a href='2_126.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><span>[127]</span><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_128.html'>Next&gt;&gt;</a>
    <div>
</body>
