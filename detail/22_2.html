<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Maine System</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Maine System</h1>
    <div class="pagination">
        <a href='22.html'>&lt;&lt;Prev</a><a href='22.html'>1</a><span>[2]</span><a href='22_3.html'>3</a><a href='22_4.html'>4</a><a href='22_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6e316f9c19a088586fd9ae058f9ea35b271571f3
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Sun Jun 15 02:01:58 2014 -0400

    blackfin, perf: Use common PMU interrupt disabled code
    
    Transition to using the new generic PERF_PMU_CAP_NO_INTERRUPT method for
    failing a sampling event when no PMU interrupt is available.
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Signed-off-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;
    Cc: Paul Mackerras &lt;paulus@samba.org&gt;
    Cc: Steven Miao &lt;realmz6@gmail.com&gt;
    Cc: adi-buildroot-devel@lists.sourceforge.net
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1406150200360.16738@vincent-weaver-1.umelst.maine.edu
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/arch/blackfin/kernel/perf_event.c b/arch/blackfin/kernel/perf_event.c
index 974e55496db3..ea2032013cc2 100644
--- a/arch/blackfin/kernel/perf_event.c
+++ b/arch/blackfin/kernel/perf_event.c
@@ -389,14 +389,6 @@ static int bfin_pmu_event_init(struct perf_event *event)
 	if (attr-&gt;exclude_hv || attr-&gt;exclude_idle)
 		return -EPERM;
 
-	/*
-	 * All of the on-chip counters are "limited", in that they have
-	 * no interrupts, and are therefore unable to do sampling without
-	 * further work and timer assistance.
-	 */
-	if (hwc-&gt;sample_period)
-		return -EINVAL;
-
 	ret = 0;
 	switch (attr-&gt;type) {
 	case PERF_TYPE_RAW:
@@ -490,6 +482,13 @@ static int __init bfin_pmu_init(void)
 {
 	int ret;
 
+	/*
+	 * All of the on-chip counters are "limited", in that they have
+	 * no interrupts, and are therefore unable to do sampling without
+	 * further work and timer assistance.
+	 */
+	pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;
+
 	ret = perf_pmu_register(&amp;pmu, "cpu", PERF_TYPE_RAW);
 	if (!ret)
 		perf_cpu_notifier(bfin_pmu_notifier);</pre><hr><pre>commit 2cc9e588b0ff80c209c59a3e369c73e591535ba8
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Sun Jun 15 02:00:18 2014 -0400

    arc, perf: Use common PMU interrupt disabled code
    
    Transition to using the new generic PERF_PMU_CAP_NO_INTERRUPT method for
    failing a sampling event when no PMU interrupt is available.
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Acked-by: Vineet Gupta &lt;vgupta@synopsys.com&gt;
    Signed-off-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;
    Cc: Grant Likely &lt;grant.likely@linaro.org&gt;
    Cc: Paul Mackerras &lt;paulus@samba.org&gt;
    Cc: Rob Herring &lt;robh+dt@kernel.org&gt;
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1406150159280.16738@vincent-weaver-1.umelst.maine.edu
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/arch/arc/kernel/perf_event.c b/arch/arc/kernel/perf_event.c
index 63177e4cb66d..b9a5685a990e 100644
--- a/arch/arc/kernel/perf_event.c
+++ b/arch/arc/kernel/perf_event.c
@@ -99,10 +99,6 @@ static int arc_pmu_event_init(struct perf_event *event)
 	struct hw_perf_event *hwc = &amp;event-&gt;hw;
 	int ret;
 
-	/* ARC 700 PMU does not support sampling events */
-	if (is_sampling_event(event))
-		return -ENOENT;
-
 	switch (event-&gt;attr.type) {
 	case PERF_TYPE_HARDWARE:
 		if (event-&gt;attr.config &gt;= PERF_COUNT_HW_MAX)
@@ -298,6 +294,9 @@ static int arc_pmu_device_probe(struct platform_device *pdev)
 		.read		= arc_pmu_read,
 	};
 
+	/* ARC 700 PMU does not support sampling events */
+	arc_pmu-&gt;pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;
+
 	ret = perf_pmu_register(&amp;arc_pmu-&gt;pmu, pdev-&gt;name, PERF_TYPE_RAW);
 
 	return ret;</pre><hr><pre>commit c184c980de30dc5f6fec4b281928aa6743708da9
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Fri May 16 17:18:07 2014 -0400

    perf/x86: Use common PMU interrupt disabled code
    
    Make the x86 perf code use the new common PMU interrupt disabled code.
    
    Typically most x86 machines have working PMU interrupts, although
    some older p6-class machines had this problem.
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Signed-off-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1405161715560.11099@vincent-weaver-1.umelst.maine.edu
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c
index 32029e35f2b9..2bdfbff8a4f6 100644
--- a/arch/x86/kernel/cpu/perf_event.c
+++ b/arch/x86/kernel/cpu/perf_event.c
@@ -303,15 +303,6 @@ int x86_setup_perfctr(struct perf_event *event)
 		hwc-&gt;sample_period = x86_pmu.max_period;
 		hwc-&gt;last_period = hwc-&gt;sample_period;
 		local64_set(&amp;hwc-&gt;period_left, hwc-&gt;sample_period);
-	} else {
-		/*
-		 * If we have a PMU initialized but no APIC
-		 * interrupts, we cannot sample hardware
-		 * events (user-space has to fall back and
-		 * sample via a hrtimer based software event):
-		 */
-		if (!x86_pmu.apic)
-			return -EOPNOTSUPP;
 	}
 
 	if (attr-&gt;type == PERF_TYPE_RAW)
@@ -1367,6 +1358,15 @@ static void __init pmu_check_apic(void)
 	x86_pmu.apic = 0;
 	pr_info("no APIC, boot with the \"lapic\" boot parameter to force-enable it.\n");
 	pr_info("no hardware sampling interrupt available.\n");
+
+	/*
+	 * If we have a PMU initialized but no APIC
+	 * interrupts, we cannot sample hardware
+	 * events (user-space has to fall back and
+	 * sample via a hrtimer based software event):
+	 */
+	pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;
+
 }
 
 static struct attribute_group x86_pmu_format_group = {</pre><hr><pre>commit edcb4d3c36a6429caa03ddfeab4cbb153c7002b2
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Fri May 16 17:15:49 2014 -0400

    perf/ARM: Use common PMU interrupt disabled code
    
    Make the ARM perf code use the new common PMU interrupt disabled code.
    
    This allows perf to work on ARM machines without a working PMU
    interrupt (for example, raspberry pi).
    
    Acked-by: Will Deacon &lt;will.deacon@arm.com&gt;
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    [peterz: applied changes suggested by Will]
    Signed-off-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;
    Cc: Grant Likely &lt;grant.likely@linaro.org&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Cc: Paul Mackerras &lt;paulus@samba.org&gt;
    Cc: Rob Herring &lt;robh+dt@kernel.org&gt;
    Cc: Russell King &lt;linux@arm.linux.org.uk&gt;
    Cc: Will Deacon &lt;will.deacon@arm.com&gt;
    Cc: devicetree@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1405161712190.11099@vincent-weaver-1.umelst.maine.edu
    [ Small readability tweaks to the code. ]
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;
    
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index a6bc431cde70..4238bcba9d60 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -410,7 +410,7 @@ __hw_perf_event_init(struct perf_event *event)
 	 */
 	hwc-&gt;config_base	    |= (unsigned long)mapping;
 
-	if (!hwc-&gt;sample_period) {
+	if (!is_sampling_event(event)) {
 		/*
 		 * For non-sampling runs, limit the sample_period to half
 		 * of the counter width. That way, the new counter value
diff --git a/arch/arm/kernel/perf_event_cpu.c b/arch/arm/kernel/perf_event_cpu.c
index 51798d7854ac..bbdbffd06cf7 100644
--- a/arch/arm/kernel/perf_event_cpu.c
+++ b/arch/arm/kernel/perf_event_cpu.c
@@ -126,8 +126,8 @@ static int cpu_pmu_request_irq(struct arm_pmu *cpu_pmu, irq_handler_t handler)
 
 	irqs = min(pmu_device-&gt;num_resources, num_possible_cpus());
 	if (irqs &lt; 1) {
-		pr_err("no irqs for PMUs defined\n");
-		return -ENODEV;
+		printk_once("perf/ARM: No irqs for PMU defined, sampling events not supported\n");
+		return 0;
 	}
 
 	irq = platform_get_irq(pmu_device, 0);
@@ -191,6 +191,10 @@ static void cpu_pmu_init(struct arm_pmu *cpu_pmu)
 	/* Ensure the PMU has sane values out of reset. */
 	if (cpu_pmu-&gt;reset)
 		on_each_cpu(cpu_pmu-&gt;reset, cpu_pmu, 1);
+
+	/* If no interrupts available, set the corresponding capability flag */
+	if (!platform_get_irq(cpu_pmu-&gt;plat_device, 0))
+		cpu_pmu-&gt;pmu.capabilities |= PERF_PMU_CAP_NO_INTERRUPT;
 }
 
 /*</pre><hr><pre>commit 53b25335dd60981ad608da7890420898a34469a6
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Fri May 16 17:12:12 2014 -0400

    perf: Disable sampled events if no PMU interrupt
    
    Add common code to generate -ENOTSUPP at event creation time if an
    architecture attempts to create a sampled event and
    PERF_PMU_NO_INTERRUPT is set.
    
    This adds a new pmu-&gt;capabilities flag.  Initially we only support
    PERF_PMU_NO_INTERRUPT (to indicate a PMU has no support for generating
    hardware interrupts) but there are other capabilities that can be
    added later.
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Acked-by: Will Deacon &lt;will.deacon@arm.com&gt;
    [peterz: rename to PERF_PMU_CAP_* and moved the pmu::capabilities word into a hole]
    Signed-off-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1405161708060.11099@vincent-weaver-1.umelst.maine.edu
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;
    
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h
index af6dcf1d9e47..267c8f37012c 100644
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@ -166,6 +166,11 @@ struct perf_event;
  */
 #define PERF_EVENT_TXN 0x1
 
+/**
+ * pmu::capabilities flags
+ */
+#define PERF_PMU_CAP_NO_INTERRUPT		0x01
+
 /**
  * struct pmu - generic performance monitoring unit
  */
@@ -178,6 +183,11 @@ struct pmu {
 	const char			*name;
 	int				type;
 
+	/*
+	 * various common per-pmu feature flags
+	 */
+	int				capabilities;
+
 	int * __percpu			pmu_disable_count;
 	struct perf_cpu_context * __percpu pmu_cpu_context;
 	int				task_ctx_nr;
diff --git a/kernel/events/core.c b/kernel/events/core.c
index a62d142ad498..e9ef0c6646af 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -7120,6 +7120,13 @@ SYSCALL_DEFINE5(perf_event_open,
 		}
 	}
 
+	if (is_sampling_event(event)) {
+		if (event-&gt;pmu-&gt;capabilities &amp; PERF_PMU_CAP_NO_INTERRUPT) {
+			err = -ENOTSUPP;
+			goto err_alloc;
+		}
+	}
+
 	account_event(event);
 
 	/*</pre><hr><pre>commit e69af4657e7764d03ad555f0b583d9c4217bcefa
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Wed Apr 2 00:49:55 2014 -0400

    perf/x86: Enable DRAM RAPL support on Intel Haswell
    
    It turns out all Haswell processors (including the Desktop
    variant)  support RAPL DRAM readings in addition to package,
    pp0, and pp1.
    
    I've confirmed RAPL DRAM readings on my model 60 Haswell
    desktop.
    
    See the 4th-gen-core-family-desktop-vol-2-datasheet.pdf
    available from the Intel website for confirmation.
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Paul Mackerras &lt;paulus@samba.org&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@ghostprotocols.net&gt;
    Cc: Stephane Eranian &lt;eranian@gmail.com&gt;
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1404020045290.17889@vincent-weaver-1.um.maine.edu
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/arch/x86/kernel/cpu/perf_event_intel_rapl.c b/arch/x86/kernel/cpu/perf_event_intel_rapl.c
index 5ad35ad94d0f..3cec947e3b98 100644
--- a/arch/x86/kernel/cpu/perf_event_intel_rapl.c
+++ b/arch/x86/kernel/cpu/perf_event_intel_rapl.c
@@ -59,7 +59,7 @@
 #define INTEL_RAPL_PKG		0x2	/* pseudo-encoding */
 #define RAPL_IDX_RAM_NRG_STAT	2	/* DRAM */
 #define INTEL_RAPL_RAM		0x3	/* pseudo-encoding */
-#define RAPL_IDX_PP1_NRG_STAT	3	/* DRAM */
+#define RAPL_IDX_PP1_NRG_STAT	3	/* gpu */
 #define INTEL_RAPL_PP1		0x4	/* pseudo-encoding */
 
 /* Clients have PP0, PKG */
@@ -72,6 +72,12 @@
 			 1&lt;&lt;RAPL_IDX_PKG_NRG_STAT|\
 			 1&lt;&lt;RAPL_IDX_RAM_NRG_STAT)
 
+/* Servers have PP0, PKG, RAM, PP1 */
+#define RAPL_IDX_HSW	(1&lt;&lt;RAPL_IDX_PP0_NRG_STAT|\
+			 1&lt;&lt;RAPL_IDX_PKG_NRG_STAT|\
+			 1&lt;&lt;RAPL_IDX_RAM_NRG_STAT|\
+			 1&lt;&lt;RAPL_IDX_PP1_NRG_STAT)
+
 /*
  * event code: LSB 8 bits, passed in attr-&gt;config
  * any other bit is reserved
@@ -425,6 +431,24 @@ static struct attribute *rapl_events_cln_attr[] = {
 	NULL,
 };
 
+static struct attribute *rapl_events_hsw_attr[] = {
+	EVENT_PTR(rapl_cores),
+	EVENT_PTR(rapl_pkg),
+	EVENT_PTR(rapl_gpu),
+	EVENT_PTR(rapl_ram),
+
+	EVENT_PTR(rapl_cores_unit),
+	EVENT_PTR(rapl_pkg_unit),
+	EVENT_PTR(rapl_gpu_unit),
+	EVENT_PTR(rapl_ram_unit),
+
+	EVENT_PTR(rapl_cores_scale),
+	EVENT_PTR(rapl_pkg_scale),
+	EVENT_PTR(rapl_gpu_scale),
+	EVENT_PTR(rapl_ram_scale),
+	NULL,
+};
+
 static struct attribute_group rapl_pmu_events_group = {
 	.name = "events",
 	.attrs = NULL, /* patched at runtime */
@@ -631,11 +655,14 @@ static int __init rapl_pmu_init(void)
 	switch (boot_cpu_data.x86_model) {
 	case 42: /* Sandy Bridge */
 	case 58: /* Ivy Bridge */
-	case 60: /* Haswell */
-	case 69: /* Haswell-Celeron */
 		rapl_cntr_mask = RAPL_IDX_CLN;
 		rapl_pmu_events_group.attrs = rapl_events_cln_attr;
 		break;
+	case 60: /* Haswell */
+	case 69: /* Haswell-Celeron */
+		rapl_cntr_mask = RAPL_IDX_HSW;
+		rapl_pmu_events_group.attrs = rapl_events_hsw_attr;
+		break;
 	case 45: /* Sandy Bridge-EP */
 	case 62: /* IvyTown */
 		rapl_cntr_mask = RAPL_IDX_SRV;</pre><hr><pre>commit 14ac652b67fe08b0dca78995a4298aad38345a31
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Tue Dec 31 16:54:16 2013 -0500

    ARM: bcm2835: perf_event support for Raspberry-Pi
    
    The following patch enables performance counter support on Raspberry-Pi.
    
    We have this working on the 2708 based rasp-pi kernels by manually putting
    the device registration in the platform files.
    
    This change does things properly in a device tree.  The boot messages look
    proper, but my rasp-pi hangs somewhere in USB enabling when running a
    stock 3.13-rc6 kernel so I have been unable to fully test this change.
    
    I also understand that the rasp-pi 1176 pmu support is missing the
    overflow interrupt.  I'm not sure if that's true of all 2835
    implementations.  If not, then this patch will need to be changed a bit.
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    [swarren, fixed DT node sort order]
    Signed-off-by: Stephen Warren &lt;swarren@wwwdotorg.org&gt;

diff --git a/arch/arm/boot/dts/bcm2835.dtsi b/arch/arm/boot/dts/bcm2835.dtsi
index b021c96d3ba1..beb8659813b2 100644
--- a/arch/arm/boot/dts/bcm2835.dtsi
+++ b/arch/arm/boot/dts/bcm2835.dtsi
@@ -113,6 +113,10 @@ usb {
 			reg = &lt;0x7e980000 0x10000&gt;;
 			interrupts = &lt;1 9&gt;;
 		};
+
+		arm-pmu {
+			compatible = "arm,arm1176-pmu";
+		};
 	};
 
 	clocks {</pre><hr><pre>commit 88fee52e58ca14d8465b614774ed0bf08e1a7790
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Mon Dec 30 15:39:45 2013 -0500

    perf list: Fix checking for supported events on older kernels
    
    "perf list" listing of hardware events doesn't work on older ARM devices.
    The change enabling event detection:
    
     commit b41f1cec91c37eeea6fdb15effbfa24ea0a5536b
     Author: Namhyung Kim &lt;namhyung.kim@lge.com&gt;
     Date:   Tue Aug 27 11:41:53 2013 +0900
    
         perf list: Skip unsupported events
    
    uses the following code in tools/perf/util/parse-events.c:
    
            struct perf_event_attr attr = {
                    .type = type,
                    .config = config,
                    .disabled = 1,
                    .exclude_kernel = 1,
            };
    
    On ARM machines pre-dating the Cortex-A15 this doesn't work, as these
    machines don't support .exclude_kernel.  So starting with 3.12 "perf
    list" does not report any hardware events at all on older machines (seen
    on Rasp-Pi, Pandaboard, Beagleboard, etc).
    
    This version of the patch makes changes suggested by Namhyung Kim to
    check for EACCESS and retry (instead of just dropping the
    exclude_kernel) so we can properly handle machines where
    /proc/sys/kernel/perf_event_paranoid is set to 2.
    
    Reported-by: Chad Paradis &lt;chad.paradis@umit.maine.edu&gt;
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Acked-by: Namhyung Kim &lt;namhyung@kernel.org&gt;
    Cc: Chad Paradis &lt;chad.paradis@umit.maine.edu&gt;
    Cc: Ingo Molnar &lt;mingo@redhat.com&gt;
    Cc: Namhyung Kim &lt;namhyung@kernel.org&gt;
    Cc: Paul Mackerras &lt;paulus@samba.org&gt;
    Cc: Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1312301536150.28814@vincent-weaver-1.um.maine.edu
    Signed-off-by: Arnaldo Carvalho de Melo &lt;acme@redhat.com&gt;

diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c
index d248fca6d7ed..1e15df10a88c 100644
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@ -1091,12 +1091,12 @@ int is_valid_tracepoint(const char *event_string)
 static bool is_event_supported(u8 type, unsigned config)
 {
 	bool ret = true;
+	int open_return;
 	struct perf_evsel *evsel;
 	struct perf_event_attr attr = {
 		.type = type,
 		.config = config,
 		.disabled = 1,
-		.exclude_kernel = 1,
 	};
 	struct {
 		struct thread_map map;
@@ -1108,7 +1108,20 @@ static bool is_event_supported(u8 type, unsigned config)
 
 	evsel = perf_evsel__new(&amp;attr);
 	if (evsel) {
-		ret = perf_evsel__open(evsel, NULL, &amp;tmap.map) &gt;= 0;
+		open_return = perf_evsel__open(evsel, NULL, &amp;tmap.map);
+		ret = open_return &gt;= 0;
+
+		if (open_return == -EACCES) {
+			/*
+			 * This happens if the paranoid value
+			 * /proc/sys/kernel/perf_event_paranoid is set to 2
+			 * Re-run with exclude_kernel set; we don't do that
+			 * by default as some ARM machines do not support it.
+			 *
+			 */
+			evsel-&gt;attr.exclude_kernel = 1;
+			ret = perf_evsel__open(evsel, NULL, &amp;tmap.map) &gt;= 0;
+		}
 		perf_evsel__delete(evsel);
 	}
 </pre><hr><pre>commit 0022cedd4a7d8a87841351e2b018bb6794cf2e67
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Fri Nov 15 12:39:45 2013 -0500

    perf/trace: Properly use u64 to hold event_id
    
    The 64-bit attr.config value for perf trace events was being copied into
    an "int" before doing a comparison, meaning the top 32 bits were
    being truncated.
    
    As far as I can tell this didn't cause any errors, but it did mean
    it was possible to create valid aliases for all the tracepoint ids
    which I don't think was intended.  (For example, 0xffffffff00000018
    and 0x18 both enable the same tracepoint).
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Signed-off-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1311151236100.11932@vincent-weaver-1.um.maine.edu
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/kernel/trace/trace_event_perf.c b/kernel/trace/trace_event_perf.c
index 630889f68b1d..e854f420e033 100644
--- a/kernel/trace/trace_event_perf.c
+++ b/kernel/trace/trace_event_perf.c
@@ -179,7 +179,7 @@ static int perf_trace_event_init(struct ftrace_event_call *tp_event,
 int perf_trace_init(struct perf_event *p_event)
 {
 	struct ftrace_event_call *tp_event;
-	int event_id = p_event-&gt;attr.config;
+	u64 event_id = p_event-&gt;attr.config;
 	int ret = -EINVAL;
 
 	mutex_lock(&amp;event_mutex);</pre><hr><pre>commit a8e0108cac181a7b141dacaa99ea52efaf9b5f07
Author: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
Date:   Tue Sep 17 14:53:41 2013 -0400

    perf: Fix UAPI export of PERF_EVENT_IOC_ID
    
    Without the following patch I have problems compiling code using
    the new PERF_EVENT_IOC_ID ioctl().  It looks like u64 was used
    instead of __u64
    
    Signed-off-by: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Acked-by: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@ghostprotocols.net&gt;
    Link: http://lkml.kernel.org/r/alpine.DEB.2.10.1309171450380.11444@vincent-weaver-1.um.maine.edu
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/include/uapi/linux/perf_event.h b/include/uapi/linux/perf_event.h
index ca1d90bcb74d..40a1fb807396 100644
--- a/include/uapi/linux/perf_event.h
+++ b/include/uapi/linux/perf_event.h
@@ -324,7 +324,7 @@ struct perf_event_attr {
 #define PERF_EVENT_IOC_PERIOD		_IOW('$', 4, __u64)
 #define PERF_EVENT_IOC_SET_OUTPUT	_IO ('$', 5)
 #define PERF_EVENT_IOC_SET_FILTER	_IOW('$', 6, char *)
-#define PERF_EVENT_IOC_ID		_IOR('$', 7, u64 *)
+#define PERF_EVENT_IOC_ID		_IOR('$', 7, __u64 *)
 
 enum perf_event_ioc_flags {
 	PERF_IOC_FLAG_GROUP		= 1U &lt;&lt; 0,</pre>
    <div class="pagination">
        <a href='22.html'>&lt;&lt;Prev</a><a href='22.html'>1</a><span>[2]</span><a href='22_3.html'>3</a><a href='22_4.html'>4</a><a href='22_3.html'>Next&gt;&gt;</a>
    <div>
</body>
