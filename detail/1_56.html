<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_55.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><span>[56]</span><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_57.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit f3b59291a69d0b734be1fc8be489fef2dd846d3d
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Nov 15 23:08:57 2012 -0500

    ext4: remove calls to ext4_jbd2_file_inode() from delalloc write path
    
    The calls to ext4_jbd2_file_inode() are needed to guarantee that we do
    not expose stale data in the data=ordered mode.  However, they are not
    necessary because in all of the cases where we have newly allocated
    blocks in the delayed allocation write path, we immediately submit the
    dirty pages for I/O.  Hence, we can avoid the overhead of adding the
    inode to the list of inodes whose data pages will be to be flushed out
    to disk completely during the next commit operation.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 52f7ff2f2e7e..cf5d30a7cce3 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1636,15 +1636,6 @@ static void mpage_da_map_and_submit(struct mpage_da_data *mpd)
 
 		for (i = 0; i &lt; map.m_len; i++)
 			unmap_underlying_metadata(bdev, map.m_pblk + i);
-
-		if (ext4_should_order_data(mpd-&gt;inode)) {
-			err = ext4_jbd2_file_inode(handle, mpd-&gt;inode);
-			if (err) {
-				/* Only if the journal is aborted */
-				mpd-&gt;retval = err;
-				goto submit_io;
-			}
-		}
 	}
 
 	/*
@@ -2592,17 +2583,8 @@ static int ext4_da_write_end(struct file *file,
 	if (copied &amp;&amp; new_i_size &gt; EXT4_I(inode)-&gt;i_disksize) {
 		if (ext4_da_should_update_i_disksize(page, end)) {
 			down_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
-			if (new_i_size &gt; EXT4_I(inode)-&gt;i_disksize) {
-				/*
-				 * Updating i_disksize when extending file
-				 * without needing block allocation
-				 */
-				if (ext4_should_order_data(inode))
-					ret = ext4_jbd2_file_inode(handle,
-								   inode);
-
+			if (new_i_size &gt; EXT4_I(inode)-&gt;i_disksize)
 				EXT4_I(inode)-&gt;i_disksize = new_i_size;
-			}
 			up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
 			/* We need to mark inode dirty even if
 			 * new_i_size is less that inode-&gt;i_size</pre><hr><pre>commit dffe9d8da715bed4d395883add90a2d150d85729
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Nov 10 22:20:05 2012 -0500

    ext4: do not use ext4_error() when there is no space in dir leaf for csum
    
    If there is no space for a checksum in a directory leaf node,
    previously we would use EXT4_ERROR_INODE() which would mark the file
    system as inconsistent.  While it would be nice to use e2fsck -D, it
    certainly isn't required, so just print a warning using
    ext4_warning().
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: "Darrick J. Wong" &lt;darrick.wong@oracle.com&gt;

diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 6d600a69fc9d..580af3dfc0eb 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -261,6 +261,12 @@ static __le32 ext4_dirent_csum(struct inode *inode,
 	return cpu_to_le32(csum);
 }
 
+static void warn_no_space_for_csum(struct inode *inode)
+{
+	ext4_warning(inode-&gt;i_sb, "no space in directory inode %lu leaf for "
+		     "checksum.  Please run e2fsck -D.", inode-&gt;i_ino);
+}
+
 int ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)
 {
 	struct ext4_dir_entry_tail *t;
@@ -271,8 +277,7 @@ int ext4_dirent_csum_verify(struct inode *inode, struct ext4_dir_entry *dirent)
 
 	t = get_dirent_tail(inode, dirent);
 	if (!t) {
-		EXT4_ERROR_INODE(inode, "metadata_csum set but no space in dir "
-				 "leaf for checksum.  Please run e2fsck -D.");
+		warn_no_space_for_csum(inode);
 		return 0;
 	}
 
@@ -294,8 +299,7 @@ static void ext4_dirent_csum_set(struct inode *inode,
 
 	t = get_dirent_tail(inode, dirent);
 	if (!t) {
-		EXT4_ERROR_INODE(inode, "metadata_csum set but no space in dir "
-				 "leaf for checksum.  Please run e2fsck -D.");
+		warn_no_space_for_csum(inode);
 		return;
 	}
 
@@ -377,8 +381,7 @@ static int ext4_dx_csum_verify(struct inode *inode,
 	count = le16_to_cpu(c-&gt;count);
 	if (count_offset + (limit * sizeof(struct dx_entry)) &gt;
 	    EXT4_BLOCK_SIZE(inode-&gt;i_sb) - sizeof(struct dx_tail)) {
-		EXT4_ERROR_INODE(inode, "metadata_csum set but no space for "
-				 "tree checksum found.  Run e2fsck -D.");
+		warn_no_space_for_csum(inode);
 		return 1;
 	}
 	t = (struct dx_tail *)(((struct dx_entry *)c) + limit);
@@ -408,8 +411,7 @@ static void ext4_dx_csum_set(struct inode *inode, struct ext4_dir_entry *dirent)
 	count = le16_to_cpu(c-&gt;count);
 	if (count_offset + (limit * sizeof(struct dx_entry)) &gt;
 	    EXT4_BLOCK_SIZE(inode-&gt;i_sb) - sizeof(struct dx_tail)) {
-		EXT4_ERROR_INODE(inode, "metadata_csum set but no space for "
-				 "tree checksum.  Run e2fsck -D.");
+		warn_no_space_for_csum(inode);
 		return;
 	}
 	t = (struct dx_tail *)(((struct dx_entry *)c) + limit);</pre><hr><pre>commit 06db49e68ae70cf16819b85a14057acb2820776a
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 10 01:06:58 2012 -0400

    ext4: fix metadata checksum calculation for the superblock
    
    The function ext4_handle_dirty_super() was calculating the superblock
    on the wrong block data.  As a result, when the superblock is modified
    while it is mounted (most commonly, when inodes are added or removed
    from the orphan list), the superblock checksum would be wrong.  We
    didn't notice because the superblock *was* being correctly calculated
    in ext4_commit_super(), and this would get called when the file system
    was unmounted.  So the problem only became obvious if the system
    crashed while the file system was mounted.
    
    Fix this by removing the poorly designed function signature for
    ext4_superblock_csum_set(); if it only took a single argument, the
    pointer to a struct superblock, the ambiguity which caused this
    mistake would have been impossible.
    
    Reported-by: George Spelvin &lt;linux@horizon.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 3ab2539b7b2e..78971cfd9c7f 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2063,8 +2063,7 @@ extern int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count);
 extern int ext4_calculate_overhead(struct super_block *sb);
 extern int ext4_superblock_csum_verify(struct super_block *sb,
 				       struct ext4_super_block *es);
-extern void ext4_superblock_csum_set(struct super_block *sb,
-				     struct ext4_super_block *es);
+extern void ext4_superblock_csum_set(struct super_block *sb);
 extern void *ext4_kvmalloc(size_t size, gfp_t flags);
 extern void *ext4_kvzalloc(size_t size, gfp_t flags);
 extern void ext4_kvfree(void *ptr);
diff --git a/fs/ext4/ext4_jbd2.c b/fs/ext4/ext4_jbd2.c
index bfa65b49d424..b4323ba846b5 100644
--- a/fs/ext4/ext4_jbd2.c
+++ b/fs/ext4/ext4_jbd2.c
@@ -143,17 +143,13 @@ int __ext4_handle_dirty_super(const char *where, unsigned int line,
 	struct buffer_head *bh = EXT4_SB(sb)-&gt;s_sbh;
 	int err = 0;
 
+	ext4_superblock_csum_set(sb);
 	if (ext4_handle_valid(handle)) {
-		ext4_superblock_csum_set(sb,
-				(struct ext4_super_block *)bh-&gt;b_data);
 		err = jbd2_journal_dirty_metadata(handle, bh);
 		if (err)
 			ext4_journal_abort_handle(where, line, __func__,
 						  bh, handle, err);
-	} else {
-		ext4_superblock_csum_set(sb,
-				(struct ext4_super_block *)bh-&gt;b_data);
+	} else
 		mark_buffer_dirty(bh);
-	}
 	return err;
 }
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 982f6fc22c88..5ededf135335 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -143,9 +143,10 @@ int ext4_superblock_csum_verify(struct super_block *sb,
 	return es-&gt;s_checksum == ext4_superblock_csum(sb, es);
 }
 
-void ext4_superblock_csum_set(struct super_block *sb,
-			      struct ext4_super_block *es)
+void ext4_superblock_csum_set(struct super_block *sb)
 {
+	struct ext4_super_block *es = EXT4_SB(sb)-&gt;s_es;
+
 	if (!EXT4_HAS_RO_COMPAT_FEATURE(sb,
 		EXT4_FEATURE_RO_COMPAT_METADATA_CSUM))
 		return;
@@ -4387,7 +4388,7 @@ static int ext4_commit_super(struct super_block *sb, int sync)
 		cpu_to_le32(percpu_counter_sum_positive(
 				&amp;EXT4_SB(sb)-&gt;s_freeinodes_counter));
 	BUFFER_TRACE(sbh, "marking dirty");
-	ext4_superblock_csum_set(sb, es);
+	ext4_superblock_csum_set(sb);
 	mark_buffer_dirty(sbh);
 	if (sync) {
 		error = sync_dirty_buffer(sbh);</pre><hr><pre>commit 041bbb6d369811e948ae01f3d00414264076be35
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Sep 30 23:04:56 2012 -0400

    ext4: fix mtime update in nodelalloc mode
    
    Commits 5e8830dc85d0 and 41c4d25f78c0 introduced a regression into
    v3.6-rc1 for ext4 in nodealloc mode, such that mtime updates would not
    take place for files modified via mmap if the page was already in the
    page cache.  This would also affect ext3 file systems mounted using
    the ext4 file system driver.
    
    The problem was that ext4_page_mkwrite() had a shortcut which would
    avoid calling __block_page_mkwrite() under some circumstances, and the
    above two commit transferred the responsibility of calling
    file_update_time() to __block_page_mkwrite --- which woudln't get
    called in some circumstances.
    
    Since __block_page_mkwrite() only has three callers,
    block_page_mkwrite(), ext4_page_mkwrite, and nilfs_page_mkwrite(), the
    best way to solve this is to move the responsibility for calling
    file_update_time() to its caller.
    
    This problem was found via xfstests #215 with a file system mounted
    with -o nodelalloc.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Jan Kara &lt;jack@suse.cz&gt;
    Cc: KONISHI Ryusuke &lt;konishi.ryusuke@lab.ntt.co.jp&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/buffer.c b/fs/buffer.c
index 9f6d2e41281d..1fe3968357a9 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2318,12 +2318,6 @@ int __block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 	loff_t size;
 	int ret;
 
-	/*
-	 * Update file times before taking page lock. We may end up failing the
-	 * fault so this update may be superfluous but who really cares...
-	 */
-	file_update_time(vma-&gt;vm_file);
-
 	lock_page(page);
 	size = i_size_read(inode);
 	if ((page-&gt;mapping != inode-&gt;i_mapping) ||
@@ -2361,6 +2355,13 @@ int block_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf,
 	struct super_block *sb = vma-&gt;vm_file-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb;
 
 	sb_start_pagefault(sb);
+
+	/*
+	 * Update file times before taking page lock. We may end up failing the
+	 * fault so this update may be superfluous but who really cares...
+	 */
+	file_update_time(vma-&gt;vm_file);
+
 	ret = __block_page_mkwrite(vma, vmf, get_block);
 	sb_end_pagefault(sb);
 	return block_page_mkwrite_return(ret);
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 09308ad0f314..f18e786e87b0 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4788,6 +4788,7 @@ int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 	int retries = 0;
 
 	sb_start_pagefault(inode-&gt;i_sb);
+	file_update_time(vma-&gt;vm_file);
 	/* Delalloc case is easy... */
 	if (test_opt(inode-&gt;i_sb, DELALLOC) &amp;&amp;
 	    !ext4_should_journal_data(inode) &amp;&amp;
diff --git a/fs/nilfs2/file.c b/fs/nilfs2/file.c
index a4d56ac02e6c..5b387a4c293e 100644
--- a/fs/nilfs2/file.c
+++ b/fs/nilfs2/file.c
@@ -116,6 +116,7 @@ static int nilfs_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)
 	if (unlikely(ret))
 		goto out;
 
+	file_update_time(vma-&gt;vm_file);
 	ret = __block_page_mkwrite(vma, vmf, nilfs_get_block);
 	if (ret) {
 		nilfs_transaction_abort(inode-&gt;i_sb);</pre><hr><pre>commit bbdd68086ca4a8976226e23efd08e2058d34dd81
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Sep 27 09:29:33 2012 -0400

    fs: reserve fallocate flag codepoint
    
    As discussed at the Plumber's Conference, reserve the bit 0x04 in
    fallocate() to prevent collisions with a commonly used out-of-tree
    patch which implements the no-hide-stale feature.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/include/linux/falloc.h b/include/linux/falloc.h
index 73e0b628e058..d39b824a780c 100644
--- a/include/linux/falloc.h
+++ b/include/linux/falloc.h
@@ -3,6 +3,7 @@
 
 #define FALLOC_FL_KEEP_SIZE	0x01 /* default is extend size */
 #define FALLOC_FL_PUNCH_HOLE	0x02 /* de-allocates range */
+#define FALLOC_FL_NO_HIDE_STALE	0x04 /* reserved codepoint */
 
 #ifdef __KERNEL__
 </pre><hr><pre>commit 641f14560035bbb86500ea4b3a27ad27f034725b
Author: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
Date:   Sun Sep 23 20:27:32 2012 +0200

    hwmon: (coretemp) Use get_online_cpus to avoid races involving CPU hotplug
    
    coretemp_init loops with for_each_online_cpu, adding platform_devices
    and sysfs interfaces, then calls register_hotcpu_notifier.  There is a
    race if a CPU is offlined or onlined after the loop, but before
    register_hotcpu_notifier.  The race might result in the absence of a
    platform_device+sysfs interface for an online CPU, or the presence of
    a platform_device+sysfs interface for an offline CPU.  A similar race
    occurs during coretemp_exit, after the module calls
    unregister_hotcpu_notifier, but before it unregisters all devices, a
    CPU might offline and a device for an offline CPU will exist for a
    short while.
    
    This fix surrounds for_each_online_cpu and register_hotcpu_notifier
    with get_online_cpus+put_online_cpus; and surrounds
    unregister_hotcpu_notifier and device unregistering with
    get_online_cpus+put_online_cpus.
    
    Build tested.
    
    Signed-off-by: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
    Signed-off-by: Jean Delvare &lt;khali@linux-fr.org&gt;

diff --git a/drivers/hwmon/coretemp.c b/drivers/hwmon/coretemp.c
index 0fa356fe82cc..984a3f13923b 100644
--- a/drivers/hwmon/coretemp.c
+++ b/drivers/hwmon/coretemp.c
@@ -815,17 +815,20 @@ static int __init coretemp_init(void)
 	if (err)
 		goto exit;
 
+	get_online_cpus();
 	for_each_online_cpu(i)
 		get_core_online(i);
 
 #ifndef CONFIG_HOTPLUG_CPU
 	if (list_empty(&amp;pdev_list)) {
+		put_online_cpus();
 		err = -ENODEV;
 		goto exit_driver_unreg;
 	}
 #endif
 
 	register_hotcpu_notifier(&amp;coretemp_cpu_notifier);
+	put_online_cpus();
 	return 0;
 
 #ifndef CONFIG_HOTPLUG_CPU
@@ -840,6 +843,7 @@ static void __exit coretemp_exit(void)
 {
 	struct pdev_entry *p, *n;
 
+	get_online_cpus();
 	unregister_hotcpu_notifier(&amp;coretemp_cpu_notifier);
 	mutex_lock(&amp;pdev_list_mutex);
 	list_for_each_entry_safe(p, n, &amp;pdev_list, list) {
@@ -848,6 +852,7 @@ static void __exit coretemp_exit(void)
 		kfree(p);
 	}
 	mutex_unlock(&amp;pdev_list_mutex);
+	put_online_cpus();
 	platform_driver_unregister(&amp;coretemp_driver);
 }
 </pre><hr><pre>commit 1ec3ddfd27a77db55b8c0e80bcd27c656473fb96
Author: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
Date:   Sun Sep 23 20:27:32 2012 +0200

    hwmon: (via-cputemp) Use get_online_cpus to avoid races involving CPU hotplug
    
    via_cputemp_init loops with for_each_online_cpu, adding
    platform_devices, then calls register_hotcpu_notifier.  If a CPU is
    offlined between the loop and register_hotcpu_notifier, then later
    onlined, via_cputemp_device_add will attempt to add platform devices
    with the same ID.  A similar race occurs during via_cputemp_exit,
    after the module calls unregister_hotcpu_notifier, a CPU might offline
    and a device will exist for a CPU that is offline.
    
    This fix surrounds for_each_online_cpu and register_hotcpu_notifier
    with get_online_cpus+put_online_cpus; and surrounds
    unregister_hotcpu_notifier and device unregistering with
    get_online_cpus+put_online_cpus.
    
    Build tested.
    
    Signed-off-by: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
    Acked-by: Harald Welte &lt;laforge@gnumonks.org&gt;
    Signed-off-by: Jean Delvare &lt;khali@linux-fr.org&gt;

diff --git a/drivers/hwmon/via-cputemp.c b/drivers/hwmon/via-cputemp.c
index ee4ebc198a94..2e56c6ce9fb6 100644
--- a/drivers/hwmon/via-cputemp.c
+++ b/drivers/hwmon/via-cputemp.c
@@ -328,6 +328,7 @@ static int __init via_cputemp_init(void)
 	if (err)
 		goto exit;
 
+	get_online_cpus();
 	for_each_online_cpu(i) {
 		struct cpuinfo_x86 *c = &amp;cpu_data(i);
 
@@ -347,12 +348,14 @@ static int __init via_cputemp_init(void)
 
 #ifndef CONFIG_HOTPLUG_CPU
 	if (list_empty(&amp;pdev_list)) {
+		put_online_cpus();
 		err = -ENODEV;
 		goto exit_driver_unreg;
 	}
 #endif
 
 	register_hotcpu_notifier(&amp;via_cputemp_cpu_notifier);
+	put_online_cpus();
 	return 0;
 
 #ifndef CONFIG_HOTPLUG_CPU
@@ -367,6 +370,7 @@ static void __exit via_cputemp_exit(void)
 {
 	struct pdev_entry *p, *n;
 
+	get_online_cpus();
 	unregister_hotcpu_notifier(&amp;via_cputemp_cpu_notifier);
 	mutex_lock(&amp;pdev_list_mutex);
 	list_for_each_entry_safe(p, n, &amp;pdev_list, list) {
@@ -375,6 +379,7 @@ static void __exit via_cputemp_exit(void)
 		kfree(p);
 	}
 	mutex_unlock(&amp;pdev_list_mutex);
+	put_online_cpus();
 	platform_driver_unregister(&amp;via_cputemp_driver);
 }
 </pre><hr><pre>commit 429227bbe55647aa42f8f63cac61e4544e248629
Author: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
Date:   Fri Aug 3 12:34:50 2012 -0700

    Use get_online_cpus to avoid races involving CPU hotplug
    
    If arch/x86/kernel/cpuid.c is a module, a CPU might offline or online
    between the for_each_online_cpu() loop and the call to
    register_hotcpu_notifier in cpuid_init or the call to
    unregister_hotcpu_notifier in cpuid_exit.  The potential races can
    lead to leaks/duplicates, attempts to destroy non-existant devices, or
    random pointer dereferences.
    
    For example, in cpuid_exit if:
    
            for_each_online_cpu(cpu)
                    cpuid_device_destroy(cpu);
            class_destroy(cpuid_class);
            __unregister_chrdev(CPUID_MAJOR, 0, NR_CPUS, "cpu/cpuid");
            &lt;----- CPU onlines
            unregister_hotcpu_notifier(&amp;cpuid_class_cpu_notifier);
    
    the hotcpu notifier will attempt to create a device for the
    cpuid_class, which the module already destroyed.
    
    This fix surrounds for_each_online_cpu and register_hotcpu_notifier or
    unregister_hotcpu_notifier with get_online_cpus+put_online_cpus.
    
    Tested on a VM.
    
    Signed-off-by: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;

diff --git a/arch/x86/kernel/cpuid.c b/arch/x86/kernel/cpuid.c
index 39472dd2323f..60c78917190c 100644
--- a/arch/x86/kernel/cpuid.c
+++ b/arch/x86/kernel/cpuid.c
@@ -199,12 +199,14 @@ static int __init cpuid_init(void)
 		goto out_chrdev;
 	}
 	cpuid_class-&gt;devnode = cpuid_devnode;
+	get_online_cpus();
 	for_each_online_cpu(i) {
 		err = cpuid_device_create(i);
 		if (err != 0)
 			goto out_class;
 	}
 	register_hotcpu_notifier(&amp;cpuid_class_cpu_notifier);
+	put_online_cpus();
 
 	err = 0;
 	goto out;
@@ -214,6 +216,7 @@ static int __init cpuid_init(void)
 	for_each_online_cpu(i) {
 		cpuid_device_destroy(i);
 	}
+	put_online_cpus();
 	class_destroy(cpuid_class);
 out_chrdev:
 	__unregister_chrdev(CPUID_MAJOR, 0, NR_CPUS, "cpu/cpuid");
@@ -225,11 +228,13 @@ static void __exit cpuid_exit(void)
 {
 	int cpu = 0;
 
+	get_online_cpus();
 	for_each_online_cpu(cpu)
 		cpuid_device_destroy(cpu);
 	class_destroy(cpuid_class);
 	__unregister_chrdev(CPUID_MAJOR, 0, NR_CPUS, "cpu/cpuid");
 	unregister_hotcpu_notifier(&amp;cpuid_class_cpu_notifier);
+	put_online_cpus();
 }
 
 module_init(cpuid_init);</pre><hr><pre>commit a2db672aa305a045404615e5222ba681bab6cf58
Author: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
Date:   Fri Aug 3 12:33:27 2012 -0700

    Use get_online_cpus to avoid races involving CPU hotplug
    
    If arch/x86/kernel/msr.c is a module, a CPU might offline or online
    between the for_each_online_cpu(i) loop and the call to
    register_hotcpu_notifier in msr_init or the call to
    unregister_hotcpu_notifier in msr_exit. The potential races can lead
    to leaks/duplicates, attempts to destroy non-existant devices, or
    random pointer dereferences.
    
    For example, in msr_init if:
    
            for_each_online_cpu(i) {
                    err = msr_device_create(i);
                    if (err != 0)
                            goto out_class;
            }
            &lt;----- CPU offlines
            register_hotcpu_notifier(&amp;msr_class_cpu_notifier);
    
    and the CPU never onlines before msr_exit, then the module will never
    call msr_device_destroy for the associated CPU.
    
    This fix surrounds for_each_online_cpu and register_hotcpu_notifier or
    unregister_hotcpu_notifier with get_online_cpus+put_online_cpus.
    
    Tested on a VM.
    
    Signed-off-by: Silas Boyd-Wickizer &lt;sbw@mit.edu&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;

diff --git a/arch/x86/kernel/msr.c b/arch/x86/kernel/msr.c
index eb113693f043..a7c5661f8496 100644
--- a/arch/x86/kernel/msr.c
+++ b/arch/x86/kernel/msr.c
@@ -257,12 +257,14 @@ static int __init msr_init(void)
 		goto out_chrdev;
 	}
 	msr_class-&gt;devnode = msr_devnode;
+	get_online_cpus();
 	for_each_online_cpu(i) {
 		err = msr_device_create(i);
 		if (err != 0)
 			goto out_class;
 	}
 	register_hotcpu_notifier(&amp;msr_class_cpu_notifier);
+	put_online_cpus();
 
 	err = 0;
 	goto out;
@@ -271,6 +273,7 @@ static int __init msr_init(void)
 	i = 0;
 	for_each_online_cpu(i)
 		msr_device_destroy(i);
+	put_online_cpus();
 	class_destroy(msr_class);
 out_chrdev:
 	__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");
@@ -281,11 +284,13 @@ static int __init msr_init(void)
 static void __exit msr_exit(void)
 {
 	int cpu = 0;
+	get_online_cpus();
 	for_each_online_cpu(cpu)
 		msr_device_destroy(cpu);
 	class_destroy(msr_class);
 	__unregister_chrdev(MSR_MAJOR, 0, NR_CPUS, "cpu/msr");
 	unregister_hotcpu_notifier(&amp;msr_class_cpu_notifier);
+	put_online_cpus();
 }
 
 module_init(msr_init);</pre><hr><pre>commit 00d4e7362ed01987183e9528295de3213031309c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Sep 19 22:42:36 2012 -0400

    ext4: fix potential deadlock in ext4_nonda_switch()
    
    In ext4_nonda_switch(), if the file system is getting full we used to
    call writeback_inodes_sb_if_idle().  The problem is that we can be
    holding i_mutex already, and this causes a potential deadlock when
    writeback_inodes_sb_if_idle() when it tries to take s_umount.  (See
    lockdep output below).
    
    As it turns out we don't need need to hold s_umount; the fact that we
    are in the middle of the write(2) system call will keep the superblock
    pinned.  Unfortunately writeback_inodes_sb() checks to make sure
    s_umount is taken, and the VFS uses a different mechanism for making
    sure the file system doesn't get unmounted out from under us.  The
    simplest way of dealing with this is to just simply grab s_umount
    using a trylock, and skip kicking the writeback flusher thread in the
    very unlikely case that we can't take a read lock on s_umount without
    blocking.
    
    Also, we now check the cirteria for kicking the writeback thread
    before we decide to whether to fall back to non-delayed writeback, so
    if there are any outstanding delayed allocation writes, we try to get
    them resolved as soon as possible.
    
       [ INFO: possible circular locking dependency detected ]
       3.6.0-rc1-00042-gce894ca #367 Not tainted
       -------------------------------------------------------
       dd/8298 is trying to acquire lock:
        (&amp;type-&gt;s_umount_key#18){++++..}, at: [&lt;c02277d4&gt;] writeback_inodes_sb_if_idle+0x28/0x46
    
       but task is already holding lock:
        (&amp;sb-&gt;s_type-&gt;i_mutex_key#8){+.+...}, at: [&lt;c01ddcce&gt;] generic_file_aio_write+0x5f/0xd3
    
       which lock already depends on the new lock.
    
       2 locks held by dd/8298:
        #0:  (sb_writers#2){.+.+.+}, at: [&lt;c01ddcc5&gt;] generic_file_aio_write+0x56/0xd3
        #1:  (&amp;sb-&gt;s_type-&gt;i_mutex_key#8){+.+...}, at: [&lt;c01ddcce&gt;] generic_file_aio_write+0x5f/0xd3
    
       stack backtrace:
       Pid: 8298, comm: dd Not tainted 3.6.0-rc1-00042-gce894ca #367
       Call Trace:
        [&lt;c015b79c&gt;] ? console_unlock+0x345/0x372
        [&lt;c06d62a1&gt;] print_circular_bug+0x190/0x19d
        [&lt;c019906c&gt;] __lock_acquire+0x86d/0xb6c
        [&lt;c01999db&gt;] ? mark_held_locks+0x5c/0x7b
        [&lt;c0199724&gt;] lock_acquire+0x66/0xb9
        [&lt;c02277d4&gt;] ? writeback_inodes_sb_if_idle+0x28/0x46
        [&lt;c06db935&gt;] down_read+0x28/0x58
        [&lt;c02277d4&gt;] ? writeback_inodes_sb_if_idle+0x28/0x46
        [&lt;c02277d4&gt;] writeback_inodes_sb_if_idle+0x28/0x46
        [&lt;c026f3b2&gt;] ext4_nonda_switch+0xe1/0xf4
        [&lt;c0271ece&gt;] ext4_da_write_begin+0x27/0x193
        [&lt;c01dcdb0&gt;] generic_file_buffered_write+0xc8/0x1bb
        [&lt;c01ddc47&gt;] __generic_file_aio_write+0x1dd/0x205
        [&lt;c01ddce7&gt;] generic_file_aio_write+0x78/0xd3
        [&lt;c026d336&gt;] ext4_file_write+0x480/0x4a6
        [&lt;c0198c1d&gt;] ? __lock_acquire+0x41e/0xb6c
        [&lt;c0180944&gt;] ? sched_clock_cpu+0x11a/0x13e
        [&lt;c01967e9&gt;] ? trace_hardirqs_off+0xb/0xd
        [&lt;c018099f&gt;] ? local_clock+0x37/0x4e
        [&lt;c0209f2c&gt;] do_sync_write+0x67/0x9d
        [&lt;c0209ec5&gt;] ? wait_on_retry_sync_kiocb+0x44/0x44
        [&lt;c020a7b9&gt;] vfs_write+0x7b/0xe6
        [&lt;c020a9a6&gt;] sys_write+0x3b/0x64
        [&lt;c06dd4bd&gt;] syscall_call+0x7/0xb
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index ca76b5ed6c9e..0a31197590d7 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2462,6 +2462,16 @@ static int ext4_nonda_switch(struct super_block *sb)
 	free_blocks  = EXT4_C2B(sbi,
 		percpu_counter_read_positive(&amp;sbi-&gt;s_freeclusters_counter));
 	dirty_blocks = percpu_counter_read_positive(&amp;sbi-&gt;s_dirtyclusters_counter);
+	/*
+	 * Start pushing delalloc when 1/2 of free blocks are dirty.
+	 */
+	if (dirty_blocks &amp;&amp; (free_blocks &lt; 2 * dirty_blocks) &amp;&amp;
+	    !writeback_in_progress(sb-&gt;s_bdi) &amp;&amp;
+	    down_read_trylock(&amp;sb-&gt;s_umount)) {
+		writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);
+		up_read(&amp;sb-&gt;s_umount);
+	}
+
 	if (2 * free_blocks &lt; 3 * dirty_blocks ||
 		free_blocks &lt; (dirty_blocks + EXT4_FREECLUSTERS_WATERMARK)) {
 		/*
@@ -2470,13 +2480,6 @@ static int ext4_nonda_switch(struct super_block *sb)
 		 */
 		return 1;
 	}
-	/*
-	 * Even if we don't switch but are nearing capacity,
-	 * start pushing delalloc when 1/2 of free blocks are dirty.
-	 */
-	if (free_blocks &lt; 2 * dirty_blocks)
-		writeback_inodes_sb_if_idle(sb, WB_REASON_FS_FREE_SPACE);
-
 	return 0;
 }
 
diff --git a/fs/fs-writeback.c b/fs/fs-writeback.c
index be3efc4f64f4..5602d73d4ec7 100644
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@ -63,6 +63,7 @@ int writeback_in_progress(struct backing_dev_info *bdi)
 {
 	return test_bit(BDI_writeback_running, &amp;bdi-&gt;state);
 }
+EXPORT_SYMBOL(writeback_in_progress);
 
 static inline struct backing_dev_info *inode_to_bdi(struct inode *inode)
 {</pre>
    <div class="pagination">
        <a href='1_55.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><span>[56]</span><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_57.html'>Next&gt;&gt;</a>
    <div>
</body>
