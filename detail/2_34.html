<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_33.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><span>[34]</span><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_35.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e4e18cbd52c8efb0d73a66d0598dc887c0feefb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 3 13:58:59 2013 -0400

    USB: EHCI: code rearrangement in iso_stream_schedule()
    
    This patch interchanges the "if" and "else" branches of the big "if"
    statement in iso_stream_schedule(), in preparation for the next patch
    in this series.  That is, it changes
    
            if (likely(!...)) {
                    A
            } else {
                    B
            }
    
    to
    
            if (unlikely(...)) {
                    B
            } else {
                    A
            }
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 85dd24ed97a6..208518bc6e36 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1384,12 +1384,57 @@ iso_stream_schedule (
 
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
-	/* Typical case: reuse current schedule, stream is still active.
+	/*
+	 * Need to schedule; when's the next (u)frame we could start?
+	 * This is bigger than ehci-&gt;i_thresh allows; scheduling itself
+	 * isn't free, the delay should handle reasonably slow cpus.  It
+	 * can also help high bandwidth if the dma and irq loads don't
+	 * jump until after the queue is primed.
+	 */
+	if (unlikely(list_empty(&amp;stream-&gt;td_list))) {
+		int done = 0;
+
+		base = now &amp; ~0x07;
+		start = base + SCHEDULING_DELAY;
+
+		/* find a uframe slot with enough bandwidth.
+		 * Early uframes are more precious because full-speed
+		 * iso IN transfers can't use late uframes,
+		 * and therefore they should be allocated last.
+		 */
+		next = start;
+		start += period;
+		do {
+			start--;
+			/* check schedule: enough space? */
+			if (stream-&gt;highspeed) {
+				if (itd_slot_ok(ehci, mod, start,
+						stream-&gt;usecs, period))
+					done = 1;
+			} else {
+				if ((start % 8) &gt;= 6)
+					continue;
+				if (sitd_slot_ok(ehci, mod, stream,
+						start, sched, period))
+					done = 1;
+			}
+		} while (start &gt; next &amp;&amp; !done);
+
+		/* no room in the schedule */
+		if (!done) {
+			ehci_dbg(ehci, "iso sched full %p", urb);
+			status = -ENOSPC;
+			goto fail;
+		}
+	}
+
+	/*
+	 * Typical case: reuse current schedule, stream is still active.
 	 * Hopefully there are no gaps from the host falling behind
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
 	 */
-	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
+	else {
 
 		/* Take the isochronous scheduling threshold into account */
 		if (ehci-&gt;i_thresh)
@@ -1436,49 +1481,6 @@ iso_stream_schedule (
 		start += base;
 	}
 
-	/* need to schedule; when's the next (u)frame we could start?
-	 * this is bigger than ehci-&gt;i_thresh allows; scheduling itself
-	 * isn't free, the delay should handle reasonably slow cpus.  it
-	 * can also help high bandwidth if the dma and irq loads don't
-	 * jump until after the queue is primed.
-	 */
-	else {
-		int done = 0;
-
-		base = now &amp; ~0x07;
-		start = base + SCHEDULING_DELAY;
-
-		/* find a uframe slot with enough bandwidth.
-		 * Early uframes are more precious because full-speed
-		 * iso IN transfers can't use late uframes,
-		 * and therefore they should be allocated last.
-		 */
-		next = start;
-		start += period;
-		do {
-			start--;
-			/* check schedule: enough space? */
-			if (stream-&gt;highspeed) {
-				if (itd_slot_ok(ehci, mod, start,
-						stream-&gt;usecs, period))
-					done = 1;
-			} else {
-				if ((start % 8) &gt;= 6)
-					continue;
-				if (sitd_slot_ok(ehci, mod, stream,
-						start, sched, period))
-					done = 1;
-			}
-		} while (start &gt; next &amp;&amp; !done);
-
-		/* no room in the schedule */
-		if (!done) {
-			ehci_dbg(ehci, "iso sched full %p", urb);
-			status = -ENOSPC;
-			goto fail;
-		}
-	}
-
 	/* Tried to schedule too far into the future? */
 	if (unlikely(start - base + span - period &gt;= mod)) {
 		ehci_dbg(ehci, "request %p would overflow (%u+%u &gt;= %u)\n",</pre><hr><pre>commit c7ccde6eac6d3c4bc6110cc3fd76ef3823bc0831
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 3 13:58:43 2013 -0400

    USB: see if URB comes from a completion handler
    
    Now that URBs can be completed inside tasklets, we need a way of
    determining whether a completion handler for a given endpoint is
    currently running.  Otherwise it's not possible to maintain the API
    guarantee about keeping isochronous streams synchronous when an
    underrun occurs.
    
    This patch adds a field and a routine to check whether a completion
    handler for a periodic endpoint is running.  At the moment no
    analogous routine appears to be necessary for async endpoints, but one
    can always be added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Ming Lei &lt;tom.leiming@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index d6a8d23f047b..3a2e82a9c115 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1703,7 +1703,9 @@ static void usb_giveback_urb_bh(unsigned long param)
 
 		urb = list_entry(local_list.next, struct urb, urb_list);
 		list_del_init(&amp;urb-&gt;urb_list);
+		bh-&gt;completing_ep = urb-&gt;ep;
 		__usb_hcd_giveback_urb(urb);
+		bh-&gt;completing_ep = NULL;
 	}
 
 	/* check if there are new URBs to giveback */
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 75efc45eaa2f..8c865134c881 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -73,6 +73,7 @@ struct giveback_urb_bh {
 	spinlock_t lock;
 	struct list_head  head;
 	struct tasklet_struct bh;
+	struct usb_host_endpoint *completing_ep;
 };
 
 struct usb_hcd {
@@ -378,6 +379,12 @@ static inline int hcd_giveback_urb_in_bh(struct usb_hcd *hcd)
 	return hcd-&gt;driver-&gt;flags &amp; HCD_BH;
 }
 
+static inline bool hcd_periodic_completion_in_progress(struct usb_hcd *hcd,
+		struct usb_host_endpoint *ep)
+{
+	return hcd-&gt;high_prio_bh.completing_ep == ep;
+}
+
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
 extern int usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);</pre><hr><pre>commit 5f5610f69be3a925b1f79af27150bb7377bc9ad6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:18:15 2013 -0400

    usb: gadget: fix a bug and a WARN_ON in dummy-hcd
    
    This patch fixes a NULL pointer dereference and a WARN_ON in
    dummy-hcd.  These things were the result of moving to the UDC core
    framework, and possibly of changes to that framework.
    
    Now unloading a gadget driver causes the UDC to be stopped after the
    gadget driver is unbound, not before.  Therefore the "driver" argument
    to dummy_udc_stop() can be NULL, so we must not try to print the
    driver's name without checking first.
    
    Also, the UDC framework automatically unregisters the gadget when the
    UDC is deleted.  Therefore a sysfs attribute file attached to the
    gadget must be removed before the UDC is deleted, not after.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 06ecd08fd57a..b8a2376971a4 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -923,8 +923,9 @@ static int dummy_udc_stop(struct usb_gadget *g,
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
-	dev_dbg(udc_dev(dum), "unregister gadget driver '%s'\n",
-			driver-&gt;driver.name);
+	if (driver)
+		dev_dbg(udc_dev(dum), "unregister gadget driver '%s'\n",
+				driver-&gt;driver.name);
 
 	dum-&gt;driver = NULL;
 
@@ -1000,8 +1001,8 @@ static int dummy_udc_remove(struct platform_device *pdev)
 {
 	struct dummy	*dum = platform_get_drvdata(pdev);
 
-	usb_del_gadget_udc(&amp;dum-&gt;gadget);
 	device_remove_file(&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	usb_del_gadget_udc(&amp;dum-&gt;gadget);
 	return 0;
 }
 </pre><hr><pre>commit 984f1733fcee3fbc78d47e26c5096921c5d9946a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 6 11:49:51 2013 -0400

    [SCSI] sd: Fix potential out-of-bounds access
    
    This patch fixes an out-of-bounds error in sd_read_cache_type(), found
    by Google's AddressSanitizer tool.  When the loop ends, we know that
    "offset" lies beyond the end of the data in the buffer, so no Caching
    mode page was found.  In theory it may be present, but the buffer size
    is limited to 512 bytes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Dmitry Vyukov &lt;dvyukov@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index b58e8f815a00..e62d17d41d4e 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -2420,14 +2420,9 @@ sd_read_cache_type(struct scsi_disk *sdkp, unsigned char *buffer)
 			}
 		}
 
-		if (modepage == 0x3F) {
-			sd_printk(KERN_ERR, sdkp, "No Caching mode page "
-				  "present\n");
-			goto defaults;
-		} else if ((buffer[offset] &amp; 0x3f) != modepage) {
-			sd_printk(KERN_ERR, sdkp, "Got wrong page\n");
-			goto defaults;
-		}
+		sd_printk(KERN_ERR, sdkp, "No Caching mode page found\n");
+		goto defaults;
+
 	Page_found:
 		if (modepage == 8) {
 			sdkp-&gt;WCE = ((buffer[offset + 2] &amp; 0x04) != 0);</pre><hr><pre>commit 9d8924297cd9c256c23c02abae40202563452453
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 30 10:46:00 2013 -0400

    USB: fix build error when CONFIG_PM_SLEEP isn't enabled
    
    This patch fixes a build error that occurs when CONFIG_PM is enabled
    and CONFIG_PM_SLEEP isn't:
    
    &gt;&gt; drivers/usb/host/ohci-pci.c:294:10: error: 'usb_hcd_pci_pm_ops' undeclared here (not in a function)
          .pm = &amp;usb_hcd_pci_pm_ops
    
    Since the usb_hcd_pci_pm_ops structure is defined and used when
    CONFIG_PM is enabled, its declaration should not be protected by
    CONFIG_PM_SLEEP.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: kbuild test robot &lt;fengguang.wu@intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index a9c7d44bd2ed..75efc45eaa2f 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -428,7 +428,7 @@ extern int usb_hcd_pci_probe(struct pci_dev *dev,
 extern void usb_hcd_pci_remove(struct pci_dev *dev);
 extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 extern const struct dev_pm_ops usb_hcd_pci_pm_ops;
 #endif
 #endif /* CONFIG_PCI */</pre><hr><pre>commit 69820e01aa756b8d228143d997f71523c1e97984
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 26 15:01:40 2013 -0400

    USB: OHCI: Allow runtime PM without system sleep
    
    Since ohci-hcd supports runtime PM, the .pm field in its pci_driver
    structure should be protected by CONFIG_PM rather than
    CONFIG_PM_SLEEP.
    
    Without this change, OHCI controllers won't do runtime suspend if
    system suspend or hibernation isn't enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    cc: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 08613e241894..767a5eeff848 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -289,7 +289,7 @@ static struct pci_driver ohci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	usb_hcd_pci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&amp;usb_hcd_pci_pm_ops
 	},</pre><hr><pre>commit d3474049ab6cfcf14274f5ab9f20c8f50b083eab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 26 10:53:53 2013 -0400

    USB: OHCI: fix build error related to ohci_suspend/resume
    
    Commit 9a11899c5e69 (USB: OHCI: add missing PCI PM callbacks to
    ohci-pci.c) added missing ohci_suspend and ohci_resume callback
    pointers, but forgot that these callbacks are declared and defined
    only when CONFIG_PM is enabled.
    
    This patch adds a preprocessor conditional to avoid build errors when
    PM is disabled.
    
    Reported-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Tested-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Reported-by: Meelis Roos &lt;mroos@linux.ee&gt;,
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 0f1d193fef02..279b04910f00 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -305,9 +305,11 @@ static int __init ohci_pci_init(void)
 
 	ohci_init_driver(&amp;ohci_pci_hc_driver, &amp;pci_overrides);
 
+#ifdef	CONFIG_PM
 	/* Entries for the PCI suspend/resume callbacks are special */
 	ohci_pci_hc_driver.pci_suspend = ohci_suspend;
 	ohci_pci_hc_driver.pci_resume = ohci_resume;
+#endif
 
 	return pci_register_driver(&amp;ohci_pci_driver);
 }</pre><hr><pre>commit 9a11899c5e699a8d2551692dfcd4372e39dcbdf6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 21 10:33:17 2013 -0400

    USB: OHCI: add missing PCI PM callbacks to ohci-pci.c
    
    Commit c1117afb8589 (USB: OHCI: make ohci-pci a separate driver)
    neglected to preserve the entries for the pci_suspend and pci_resume
    driver callbacks.  As a result, OHCI controllers don't work properly
    during suspend and after hibernation.
    
    This patch adds the missing callbacks to the driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Steve Cotton &lt;steve@s.cotton.clara.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 08613e241894..0f1d193fef02 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -304,6 +304,11 @@ static int __init ohci_pci_init(void)
 	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
 
 	ohci_init_driver(&amp;ohci_pci_hc_driver, &amp;pci_overrides);
+
+	/* Entries for the PCI suspend/resume callbacks are special */
+	ohci_pci_hc_driver.pci_suspend = ohci_suspend;
+	ohci_pci_hc_driver.pci_resume = ohci_resume;
+
 	return pci_register_driver(&amp;ohci_pci_driver);
 }
 module_init(ohci_pci_init);</pre><hr><pre>commit aa5ceae24bf8dff1d6fe87c6c4b08e69c6d33550
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:39:02 2013 -0400

    USB: handle LPM errors during device suspend correctly
    
    The hub driver's usb_port_suspend() routine doesn't handle errors
    related to Link Power Management properly.  It always returns failure,
    it doesn't try to clean up the wakeup setting, (in the case of system
    sleep) it doesn't try to go ahead with the port suspend regardless,
    and it doesn't try to apply the new power-off mechanism.
    
    This patch fixes these problems.
    
    Note: Sarah fixed this patch to apply against 3.11, since the original
    commit (4fae6f0fa86f92e6bc7429371b1e177ad0aaac66 "USB: handle LPM errors
    during device suspend correctly") called usb_disable_remote_wakeup,
    which won't be added until 3.12.
    
    This patch should be backported to kernels as old as 3.5, that
    contain the commit 8306095fd2c1100e8244c09bf560f97aca5a311d "USB:
    Disable USB 3.0 LPM in critical sections.".  There will be merge
    conflicts, since LTM wasn't added until 3.6.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Cc: stable@vger.kernel.org

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 558313de4911..8287953e066c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2918,7 +2918,6 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_hub	*hub = usb_hub_to_struct_hub(udev-&gt;parent);
 	struct usb_port *port_dev = hub-&gt;ports[udev-&gt;portnum - 1];
-	enum pm_qos_flags_status pm_qos_stat;
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	bool		really_suspend = true;
@@ -2956,7 +2955,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 					status);
 			/* bail if autosuspend is requested */
 			if (PMSG_IS_AUTO(msg))
-				return status;
+				goto err_wakeup;
 		}
 	}
 
@@ -2965,14 +2964,16 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		usb_set_usb2_hardware_lpm(udev, 0);
 
 	if (usb_disable_ltm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LTM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LTM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_ltm;
 	}
 	if (usb_unlocked_disable_lpm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LPM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LPM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_lpm3;
 	}
 
 	/* see 7.1.7.6 */
@@ -3000,28 +3001,31 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	if (status) {
 		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
-		/* paranoia:  "should not happen" */
-		if (udev-&gt;do_remote_wakeup) {
-			if (!hub_is_superspeed(hub-&gt;hdev)) {
-				(void) usb_control_msg(udev,
-						usb_sndctrlpipe(udev, 0),
-						USB_REQ_CLEAR_FEATURE,
-						USB_RECIP_DEVICE,
-						USB_DEVICE_REMOTE_WAKEUP, 0,
-						NULL, 0,
-						USB_CTRL_SET_TIMEOUT);
-			} else
-				(void) usb_disable_function_remotewakeup(udev);
-
-		}
 
+		/* Try to enable USB3 LPM and LTM again */
+		usb_unlocked_enable_lpm(udev);
+ err_lpm3:
+		usb_enable_ltm(udev);
+ err_ltm:
 		/* Try to enable USB2 hardware LPM again */
 		if (udev-&gt;usb2_hw_lpm_capable == 1)
 			usb_set_usb2_hardware_lpm(udev, 1);
 
-		/* Try to enable USB3 LTM and LPM again */
-		usb_enable_ltm(udev);
-		usb_unlocked_enable_lpm(udev);
+		if (udev-&gt;do_remote_wakeup) {
+			if (udev-&gt;speed &lt; USB_SPEED_SUPER)
+				usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+						USB_REQ_CLEAR_FEATURE,
+						USB_RECIP_DEVICE,
+						USB_DEVICE_REMOTE_WAKEUP, 0,
+						NULL, 0, USB_CTRL_SET_TIMEOUT);
+			else
+				usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+						USB_REQ_CLEAR_FEATURE,
+						USB_RECIP_INTERFACE,
+						USB_INTRF_FUNC_SUSPEND, 0,
+						NULL, 0, USB_CTRL_SET_TIMEOUT);
+		}
+ err_wakeup:
 
 		/* System sleep transitions should never fail */
 		if (!PMSG_IS_AUTO(msg))
@@ -3043,14 +3047,15 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	 * Check whether current status meets the requirement of
 	 * usb port power off mechanism
 	 */
-	pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
-			PM_QOS_FLAG_NO_POWER_OFF);
-	if (!udev-&gt;do_remote_wakeup
-			&amp;&amp; pm_qos_stat != PM_QOS_FLAGS_ALL
-			&amp;&amp; udev-&gt;persist_enabled
-			&amp;&amp; !status) {
-		pm_runtime_put_sync(&amp;port_dev-&gt;dev);
-		port_dev-&gt;did_runtime_put = true;
+	if (status == 0 &amp;&amp; !udev-&gt;do_remote_wakeup &amp;&amp; udev-&gt;persist_enabled) {
+		enum pm_qos_flags_status pm_qos_stat;
+
+		pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
+				PM_QOS_FLAG_NO_POWER_OFF);
+		if (pm_qos_stat != PM_QOS_FLAGS_ALL) {
+			pm_runtime_put_sync(&amp;port_dev-&gt;dev);
+			port_dev-&gt;did_runtime_put = true;
+		}
 	}
 
 	usb_mark_last_busy(hub-&gt;hdev);</pre><hr><pre>commit 24f531371de17010f2b1b57d90e42240032e7733
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 7 10:58:05 2013 -0400

    USB: EHCI: accept very late isochronous URBs
    
    Since commits 4005ad4390bf (EHCI: implement new semantics for
    URB_ISO_ASAP) and c75c5ab575af (ALSA: USB: adjust for changed 3.8 USB
    API) became widely distributed, people have been experiencing problems
    with audio transfers.  The slightest underrun causes complete failure,
    requiring the audio stream to be restarted.
    
    It turns out that the current isochronous API doesn't handle underruns
    in the best way.  The ALSA developers would much rather have transfers
    that are submitted too late be accepted and complete in the normal
    fashion, rather than being refused outright.
    
    This patch implements the requested approach.  When an isochronous URB
    submission is so late that all its scheduled slots have already
    expired, a debugging message will be printed in the log and the URB
    will be accepted as usual.  Assuming it was submitted by a completion
    handler (which is normally the case), it will complete shortly
    thereafter with all the usb_iso_packet_descriptor status fields marked
    -EXDEV.
    
    This fixes (for ehci-hcd)
    
            https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1191603
    
    It should be applied to all kernels that include commit 4005ad4390bf.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Maksim Boyko &lt;maksboyko@yandex.ru&gt;
    CC: Clemens Ladisch &lt;clemens@ladisch.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index f80d0330d548..8e3c878f38cf 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1391,21 +1391,20 @@ iso_stream_schedule (
 
 		/* Behind the scheduling threshold? */
 		if (unlikely(start &lt; next)) {
+			unsigned now2 = (now - base) &amp; (mod - 1);
 
 			/* USB_ISO_ASAP: Round up to the first available slot */
 			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
 				start += (next - start + period - 1) &amp; -period;
 
 			/*
-			 * Not ASAP: Use the next slot in the stream.  If
-			 * the entire URB falls before the threshold, fail.
+			 * Not ASAP: Use the next slot in the stream,
+			 * no matter what.
 			 */
-			else if (start + span - period &lt; next) {
-				ehci_dbg(ehci, "iso urb late %p (%u+%u &lt; %u)\n",
+			else if (start + span - period &lt; now2) {
+				ehci_dbg(ehci, "iso underrun %p (%u+%u &lt; %u)\n",
 						urb, start + base,
-						span - period, next + base);
-				status = -EXDEV;
-				goto fail;
+						span - period, now2 + base);
 			}
 		}
 </pre>
    <div class="pagination">
        <a href='2_33.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><span>[34]</span><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_35.html'>Next&gt;&gt;</a>
    <div>
</body>
