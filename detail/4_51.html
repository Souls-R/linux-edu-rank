<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_50.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><span>[51]</span><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_52.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2e0af86f618c697b44e2d67dff151256c58201c4
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Mon Mar 20 13:44:26 2006 -0500

    locks: remove unused posix_block_lock
    
    posix_lock_file() is used to add a blocked lock to Lockd's block, so
    posix_block_lock() is no longer needed.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/locks.c b/fs/locks.c
index d2c5306e3db0..cb940b142c5f 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1954,21 +1954,6 @@ void locks_remove_flock(struct file *filp)
 	unlock_kernel();
 }
 
-/**
- *	posix_block_lock - blocks waiting for a file lock
- *	@blocker: the lock which is blocking
- *	@waiter: the lock which conflicts and has to wait
- *
- * lockd needs to block waiting for locks.
- */
-void
-posix_block_lock(struct file_lock *blocker, struct file_lock *waiter)
-{
-	locks_insert_block(blocker, waiter);
-}
-
-EXPORT_SYMBOL(posix_block_lock);
-
 /**
  *	posix_unblock_lock - stop waiting for a file lock
  *      @filp:   how the file was opened
diff --git a/include/linux/fs.h b/include/linux/fs.h
index be21e860a9f2..b01482c721ae 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -757,7 +757,6 @@ extern void locks_remove_flock(struct file *);
 extern struct file_lock *posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
-extern void posix_block_lock(struct file_lock *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
 extern int posix_locks_deadlock(struct file_lock *, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);</pre><hr><pre>commit a85f193e2fb7d53e48ae6a9d9ea990bfb4cea555
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Mon Mar 20 13:44:25 2006 -0500

    lockd: make nlmsvc_lock use only posix_lock_file
    
    Reorganize nlmsvc_lock() to make full use of posix_lock_file(), which does
    eveything nlmsvc_lock() needs - no need to call posix_test_lock(),
    posix_locks_deadlock(), or posix_block_lock() separately.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.c
index 58bbfede94ec..f5398097b84b 100644
--- a/fs/lockd/svclock.c
+++ b/fs/lockd/svclock.c
@@ -297,7 +297,6 @@ u32
 nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 			struct nlm_lock *lock, int wait, struct nlm_cookie *cookie)
 {
-	struct file_lock	*conflock;
 	struct nlm_block	*block;
 	int			error;
 	u32			ret;
@@ -320,14 +319,15 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 	/* Lock file against concurrent access */
 	down(&amp;file-&gt;f_sema);
 
-	if (!(conflock = posix_test_lock(file-&gt;f_file, &amp;lock-&gt;fl))) {
-		error = posix_lock_file(file-&gt;f_file, &amp;lock-&gt;fl);
+	error = posix_lock_file(file-&gt;f_file, &amp;lock-&gt;fl);
+
+	dprintk("lockd: posix_lock_file returned %d\n", error);
 
+	if (error != -EAGAIN) {
 		if (block)
 			nlmsvc_delete_block(block, 0);
 		up(&amp;file-&gt;f_sema);
 
-		dprintk("lockd: posix_lock_file returned %d\n", -error);
 		switch(-error) {
 		case 0:
 			ret = nlm_granted;
@@ -335,9 +335,6 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 		case EDEADLK:
 			ret = nlm_deadlock;
 			goto out;
-		case EAGAIN:
-			ret = nlm_lck_denied;
-			goto out;
 		default:			/* includes ENOLCK */
 			ret = nlm_lck_denied_nolocks;
 			goto out;
@@ -349,11 +346,6 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 		goto out_unlock;
 	}
 
-	if (posix_locks_deadlock(&amp;lock-&gt;fl, conflock)) {
-		ret = nlm_deadlock;
-		goto out_unlock;
-	}
-
 	/* If we don't have a block, create and initialize it. Then
 	 * retry because we may have slept in kmalloc. */
 	/* We have to release f_sema as nlmsvc_create_block may try to
@@ -369,13 +361,6 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 	/* Append to list of blocked */
 	nlmsvc_insert_block(block, NLM_NEVER);
 
-	if (list_empty(&amp;block-&gt;b_call.a_args.lock.fl.fl_block)) {
-		/* Now add block to block list of the conflicting lock
-		   if we haven't done so. */
-		dprintk("lockd: blocking on this lock.\n");
-		posix_block_lock(conflock, &amp;block-&gt;b_call.a_args.lock.fl);
-	}
-
 	ret = nlm_lck_blocked;
 out_unlock:
 	up(&amp;file-&gt;f_sema);</pre><hr><pre>commit 5de0e5024a4e21251fd80dbfdb83316ce97086bc
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Mon Mar 20 13:44:25 2006 -0500

    lockd: simplify nlmsvc_grant_blocked
    
    Reorganize nlmsvc_grant_blocked() to make full use of posix_lock_file().  Note
    that there's no need for separate calls to posix_test_lock(),
    posix_locks_deadlock(), or posix_block_lock().
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.c
index 42dd105456c5..58bbfede94ec 100644
--- a/fs/lockd/svclock.c
+++ b/fs/lockd/svclock.c
@@ -519,7 +519,6 @@ nlmsvc_grant_blocked(struct nlm_block *block)
 {
 	struct nlm_file		*file = block-&gt;b_file;
 	struct nlm_lock		*lock = &amp;block-&gt;b_call.a_args.lock;
-	struct file_lock	*conflock;
 	int			error;
 
 	dprintk("lockd: grant blocked lock %p\n", block);
@@ -539,19 +538,15 @@ nlmsvc_grant_blocked(struct nlm_block *block)
 	}
 
 	/* Try the lock operation again */
-	if ((conflock = posix_test_lock(file-&gt;f_file, &amp;lock-&gt;fl)) != NULL) {
-		/* Bummer, we blocked again */
+	error = posix_lock_file(file-&gt;f_file, &amp;lock-&gt;fl);
+	switch (error) {
+	case 0:
+		break;
+	case -EAGAIN:
 		dprintk("lockd: lock still blocked\n");
 		nlmsvc_insert_block(block, NLM_NEVER);
-		posix_block_lock(conflock, &amp;lock-&gt;fl);
 		goto out_unlock;
-	}
-
-	/* Alright, no conflicting lock. Now lock it for real. If the
-	 * following yields an error, this is most probably due to low
-	 * memory. Retry the lock in a few seconds.
-	 */
-	if ((error = posix_lock_file(file-&gt;f_file, &amp;lock-&gt;fl)) &lt; 0) {
+	default:
 		printk(KERN_WARNING "lockd: unexpected error %d in %s!\n",
 				-error, __FUNCTION__);
 		nlmsvc_insert_block(block, 10 * HZ);</pre><hr><pre>commit 15dadef9460ad8d3b1d5ede1c1697dc79af44a72
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Mon Mar 20 13:44:24 2006 -0500

    lockd: clean up nlmsvc_lock
    
    Slightly more consistent dprintk error reporting, consolidate some up()'s.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.c
index a525a141dd3b..42dd105456c5 100644
--- a/fs/lockd/svclock.c
+++ b/fs/lockd/svclock.c
@@ -300,6 +300,7 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 	struct file_lock	*conflock;
 	struct nlm_block	*block;
 	int			error;
+	u32			ret;
 
 	dprintk("lockd: nlmsvc_lock(%s/%ld, ty=%d, pi=%d, %Ld-%Ld, bl=%d)\n",
 				file-&gt;f_file-&gt;f_dentry-&gt;d_inode-&gt;i_sb-&gt;s_id,
@@ -329,24 +330,28 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 		dprintk("lockd: posix_lock_file returned %d\n", -error);
 		switch(-error) {
 		case 0:
-			return nlm_granted;
+			ret = nlm_granted;
+			goto out;
 		case EDEADLK:
-			return nlm_deadlock;
+			ret = nlm_deadlock;
+			goto out;
 		case EAGAIN:
-			return nlm_lck_denied;
+			ret = nlm_lck_denied;
+			goto out;
 		default:			/* includes ENOLCK */
-			return nlm_lck_denied_nolocks;
+			ret = nlm_lck_denied_nolocks;
+			goto out;
 		}
 	}
 
 	if (!wait) {
-		up(&amp;file-&gt;f_sema);
-		return nlm_lck_denied;
+		ret = nlm_lck_denied;
+		goto out_unlock;
 	}
 
 	if (posix_locks_deadlock(&amp;lock-&gt;fl, conflock)) {
-		up(&amp;file-&gt;f_sema);
-		return nlm_deadlock;
+		ret = nlm_deadlock;
+		goto out_unlock;
 	}
 
 	/* If we don't have a block, create and initialize it. Then
@@ -371,8 +376,12 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 		posix_block_lock(conflock, &amp;block-&gt;b_call.a_args.lock.fl);
 	}
 
+	ret = nlm_lck_blocked;
+out_unlock:
 	up(&amp;file-&gt;f_sema);
-	return nlm_lck_blocked;
+out:
+	dprintk("lockd: nlmsvc_lock returned %u\n", ret);
+	return ret;
 }
 
 /*
@@ -535,8 +544,7 @@ nlmsvc_grant_blocked(struct nlm_block *block)
 		dprintk("lockd: lock still blocked\n");
 		nlmsvc_insert_block(block, NLM_NEVER);
 		posix_block_lock(conflock, &amp;lock-&gt;fl);
-		up(&amp;file-&gt;f_sema);
-		return;
+		goto out_unlock;
 	}
 
 	/* Alright, no conflicting lock. Now lock it for real. If the
@@ -547,8 +555,7 @@ nlmsvc_grant_blocked(struct nlm_block *block)
 		printk(KERN_WARNING "lockd: unexpected error %d in %s!\n",
 				-error, __FUNCTION__);
 		nlmsvc_insert_block(block, 10 * HZ);
-		up(&amp;file-&gt;f_sema);
-		return;
+		goto out_unlock;
 	}
 
 callback:
@@ -565,6 +572,7 @@ nlmsvc_grant_blocked(struct nlm_block *block)
 	if (nlmsvc_async_call(&amp;block-&gt;b_call, NLMPROC_GRANTED_MSG,
 						&amp;nlmsvc_grant_ops) &lt; 0)
 		nlm_release_host(block-&gt;b_call.a_host);
+out_unlock:
 	up(&amp;file-&gt;f_sema);
 }
 </pre><hr><pre>commit 5274881992b8a632620f69346401da66e480a23b
Author: Fred Isaman &lt;iisaman@citi.umich.edu&gt;
Date:   Wed Jan 18 17:43:43 2006 -0800

    [PATCH] nfsd4: clean up settattr code
    
    Clean up some unnecessary special-casing in the setattr code..
    
    Signed-off-by: Fred Isaman &lt;iisaman@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index b3f169f400db..a00fe8686293 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -594,10 +594,6 @@ nfsd4_setattr(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_se
 {
 	int status = nfs_ok;
 
-	if (!current_fh-&gt;fh_dentry)
-		return nfserr_nofilehandle;
-
-	status = nfs_ok;
 	if (setattr-&gt;sa_iattr.ia_valid &amp; ATTR_SIZE) {
 		nfs4_lock_state();
 		status = nfs4_preprocess_stateid_op(current_fh,
@@ -799,17 +795,13 @@ nfsd4_proc_compound(struct svc_rqst *rqstp,
 		/* All operations except RENEW, SETCLIENTID, RESTOREFH
 		* SETCLIENTID_CONFIRM, PUTFH and PUTROOTFH
 		* require a valid current filehandle
-		*
-		* SETATTR NOFILEHANDLE error handled in nfsd4_setattr
-		* due to required returned bitmap argument
 		*/
 		if ((!current_fh-&gt;fh_dentry) &amp;&amp;
 		   !((op-&gt;opnum == OP_PUTFH) || (op-&gt;opnum == OP_PUTROOTFH) ||
 		   (op-&gt;opnum == OP_SETCLIENTID) ||
 		   (op-&gt;opnum == OP_SETCLIENTID_CONFIRM) ||
 		   (op-&gt;opnum == OP_RENEW) || (op-&gt;opnum == OP_RESTOREFH) ||
-		   (op-&gt;opnum == OP_RELEASE_LOCKOWNER) ||
-		   (op-&gt;opnum == OP_SETATTR))) {
+		   (op-&gt;opnum == OP_RELEASE_LOCKOWNER))) {
 			op-&gt;status = nfserr_nofilehandle;
 			goto encode_op;
 		}</pre><hr><pre>commit 34081efc12aaaa12f20e5b59f3cb98ba6e27fb34
Author: Fred Isaman &lt;iisaman@citi.umich.edu&gt;
Date:   Wed Jan 18 17:43:40 2006 -0800

    [PATCH] nfsd4: Fix bug in rdattr_error return
    
    Fix bug in rdattr_error return which causes correct error code to be
    overwritten by nfserr_toosmall.
    
    Signed-off-by: Fred Isaman &lt;iisaman@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 6b743327686c..69d3501173a8 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1764,10 +1764,11 @@ nfsd4_encode_dirent(struct readdir_cd *ccd, const char *name, int namlen,
 		 */
 		if (!(cd-&gt;rd_bmval[0] &amp; FATTR4_WORD0_RDATTR_ERROR))
 			goto fail;
-		nfserr = nfserr_toosmall;
 		p = nfsd4_encode_rdattr_error(p, buflen, nfserr);
-		if (p == NULL)
+		if (p == NULL) {
+			nfserr = nfserr_toosmall;
 			goto fail;
+		}
 	}
 	cd-&gt;buflen -= (p - cd-&gt;buffer);
 	cd-&gt;buffer = p;</pre><hr><pre>commit 6c26d08f02f829a833d393c3f1b196538a9ec2c4
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:38 2006 -0800

    [PATCH] nfsd4: fix open_downgrade
    
    Bad bookkeeping of the share reservations when handling open upgrades was
    causing open downgrade to fail.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 7167dcf8e1fe..82c36ccd8b5c 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1609,26 +1609,26 @@ nfs4_upgrade_open(struct svc_rqst *rqstp, struct svc_fh *cur_fh, struct nfs4_sta
 {
 	struct file *filp = stp-&gt;st_vfs_file;
 	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
-	unsigned int share_access;
+	unsigned int share_access, new_writer;
 	int status;
 
 	set_access(&amp;share_access, stp-&gt;st_access_bmap);
-	share_access = ~share_access;
-	share_access &amp;= open-&gt;op_share_access;
-
-	if (!(share_access &amp; NFS4_SHARE_ACCESS_WRITE))
-		return nfsd4_truncate(rqstp, cur_fh, open);
+	new_writer = (~share_access) &amp; open-&gt;op_share_access
+			&amp; NFS4_SHARE_ACCESS_WRITE;
 
-	status = get_write_access(inode);
-	if (status)
-		return nfserrno(status);
+	if (new_writer) {
+		status = get_write_access(inode);
+		if (status)
+			return nfserrno(status);
+	}
 	status = nfsd4_truncate(rqstp, cur_fh, open);
 	if (status) {
-		put_write_access(inode);
+		if (new_writer)
+			put_write_access(inode);
 		return status;
 	}
 	/* remember the open */
-	filp-&gt;f_mode = (filp-&gt;f_mode | FMODE_WRITE) &amp; ~FMODE_READ;
+	filp-&gt;f_mode |= open-&gt;op_share_access;
 	set_bit(open-&gt;op_share_access, &amp;stp-&gt;st_access_bmap);
 	set_bit(open-&gt;op_share_deny, &amp;stp-&gt;st_deny_bmap);
 </pre><hr><pre>commit fb553c0f17444e090db951b96df4d2d71b4f4b6b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:36 2006 -0800

    [PATCH] nfsd4: don't create on open that fails due to ERR_GRACE
    
    In an earlier patch (commit b648330a1d741d5df8a5076b2a0a2519c69c8f41) I noted
    that a too-early grace-period check was preventing us from bumping the
    sequence id on open.  Unfortunately in that patch I stupidly moved the
    grace-period check back too far, so now an open for create can succesfully
    create the file while still returning ERR_GRACE.
    
    The correct place for that check is after we've set the open_owner and handled
    any replays, but before we actually start mucking with the filesystem.
    
    Thanks to Avishay Traeger for reporting the bug.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 89028f2d8d26..b3f169f400db 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -192,6 +192,14 @@ nfsd4_open(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open
 	}
 	if (status)
 		goto out;
+
+	/* Openowner is now set, so sequence id will get bumped.  Now we need
+	 * these checks before we do any creates: */
+	if (nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)
+		return nfserr_grace;
+	if (!nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
+		return nfserr_no_grace;
+
 	switch (open-&gt;op_claim_type) {
 		case NFS4_OPEN_CLAIM_DELEGATE_CUR:
 			status = nfserr_inval;
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index b92dc9e08973..7167dcf8e1fe 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1732,12 +1732,6 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	struct nfs4_delegation *dp = NULL;
 	int status;
 
-	if (nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)
-		return nfserr_grace;
-
-	if (!nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
-		return nfserr_no_grace;
-
 	status = nfserr_inval;
 	if (!TEST_ACCESS(open-&gt;op_share_access) || !TEST_DENY(open-&gt;op_share_deny))
 		goto out;</pre><hr><pre>commit 0f442aa299bb47046db4077d9c122a1b539311ce
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:34 2006 -0800

    [PATCH] nfsd4: simplify process-open1 logic
    
    nfsd4_process_open1 is very highly nested; flatten it out a bit.
    
    Also, the preceding comment, which just outlines the logic, seems redundant.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index dc792b6b4513..b92dc9e08973 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1429,90 +1429,61 @@ static struct lock_manager_operations nfsd_lease_mng_ops = {
 };
 
 
-/*
- * nfsd4_process_open1()
- * 	lookup stateowner.
- * 		found:
- * 			check confirmed 
- * 				confirmed:
- * 					check seqid
- * 				not confirmed:
- * 					delete owner
- * 					create new owner
- * 		notfound:
- * 			verify clientid
- * 			create new owner
- *
- * called with nfs4_lock_state() held.
- */
 int
 nfsd4_process_open1(struct nfsd4_open *open)
 {
-	int status;
 	clientid_t *clientid = &amp;open-&gt;op_clientid;
 	struct nfs4_client *clp = NULL;
 	unsigned int strhashval;
 	struct nfs4_stateowner *sop = NULL;
 
-	status = nfserr_inval;
 	if (!check_name(open-&gt;op_owner))
-		goto out;
+		return nfserr_inval;
 
 	if (STALE_CLIENTID(&amp;open-&gt;op_clientid))
 		return nfserr_stale_clientid;
 
 	strhashval = ownerstr_hashval(clientid-&gt;cl_id, open-&gt;op_owner);
 	sop = find_openstateowner_str(strhashval, open);
-	if (sop) {
-		open-&gt;op_stateowner = sop;
-		if (!sop-&gt;so_confirmed) {
-			/* Replace any unconfirmed stateowner without
-			 * even checking for replays */
-			clp = sop-&gt;so_client;
-			release_stateowner(sop);
-		} else if (open-&gt;op_seqid == sop-&gt;so_seqid) {
-			/* normal case */
-			goto renew;
-		} else if (open-&gt;op_seqid == sop-&gt;so_seqid - 1) {
-			/* replay */
-			if (sop-&gt;so_replay.rp_buflen)
-				return NFSERR_REPLAY_ME;
-			else {
-				/* The original OPEN failed so spectacularly
-				 * that we don't even have replay data saved!
-				 * Therefore, we have no choice but to continue
-				 * processing this OPEN; presumably, we'll
-				 * fail again for the same reason.
-				 */
-				dprintk("nfsd4_process_open1:"
-					" replay with no replay cache\n");
-				goto renew;
-			}
-		} else {
-			status = nfserr_bad_seqid;
-			goto out;
-		}
-	} else {
-		/* nfs4_stateowner not found.
-		 * Verify clientid and instantiate new nfs4_stateowner.
-		 * If verify fails this is presumably the result of the
-		 * client's lease expiring.
-		 */
-		status = nfserr_expired;
+	open-&gt;op_stateowner = sop;
+	if (!sop) {
+		/* Make sure the client's lease hasn't expired. */
 		clp = find_confirmed_client(clientid);
 		if (clp == NULL)
-			goto out;
+			return nfserr_expired;
+		goto renew;
 	}
-	status = nfserr_resource;
-	sop = alloc_init_open_stateowner(strhashval, clp, open);
-	if (sop == NULL)
-		goto out;
-	open-&gt;op_stateowner = sop;
+	if (!sop-&gt;so_confirmed) {
+		/* Replace unconfirmed owners without checking for replay. */
+		clp = sop-&gt;so_client;
+		release_stateowner(sop);
+		open-&gt;op_stateowner = NULL;
+		goto renew;
+	}
+	if (open-&gt;op_seqid == sop-&gt;so_seqid - 1) {
+		if (sop-&gt;so_replay.rp_buflen)
+			return NFSERR_REPLAY_ME;
+		/* The original OPEN failed so spectacularly
+		 * that we don't even have replay data saved!
+		 * Therefore, we have no choice but to continue
+		 * processing this OPEN; presumably, we'll
+		 * fail again for the same reason.
+		 */
+		dprintk("nfsd4_process_open1: replay with no replay cache\n");
+		goto renew;
+	}
+	if (open-&gt;op_seqid != sop-&gt;so_seqid)
+		return nfserr_bad_seqid;
 renew:
-	status = nfs_ok;
+	if (open-&gt;op_stateowner == NULL) {
+		sop = alloc_init_open_stateowner(strhashval, clp, open);
+		if (sop == NULL)
+			return nfserr_resource;
+		open-&gt;op_stateowner = sop;
+	}
+	list_del_init(&amp;sop-&gt;so_close_lru);
 	renew_client(sop-&gt;so_client);
-out:
-	return status;
+	return nfs_ok;
 }
 
 static inline int</pre><hr><pre>commit 375c5547cbf39423078535affac66c8afdc8fafb
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:33 2006 -0800

    [PATCH] nfsd4: nfs4state.c miscellaneous goto removals
    
    Remove some goto's that made the logic here a little more tortuous than
    necessary.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 69ee182575ab..89028f2d8d26 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -592,25 +592,21 @@ nfsd4_setattr(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_se
 	status = nfs_ok;
 	if (setattr-&gt;sa_iattr.ia_valid &amp; ATTR_SIZE) {
 		nfs4_lock_state();
-		if ((status = nfs4_preprocess_stateid_op(current_fh,
-						&amp;setattr-&gt;sa_stateid,
-						CHECK_FH | WR_STATE, NULL))) {
-			dprintk("NFSD: nfsd4_setattr: couldn't process stateid!\n");
-			goto out_unlock;
-		}
+		status = nfs4_preprocess_stateid_op(current_fh,
+			&amp;setattr-&gt;sa_stateid, CHECK_FH | WR_STATE, NULL);
 		nfs4_unlock_state();
+		if (status) {
+			dprintk("NFSD: nfsd4_setattr: couldn't process stateid!");
+			return status;
+		}
 	}
 	status = nfs_ok;
 	if (setattr-&gt;sa_acl != NULL)
 		status = nfsd4_set_nfs4_acl(rqstp, current_fh, setattr-&gt;sa_acl);
 	if (status)
-		goto out;
+		return status;
 	status = nfsd_setattr(rqstp, current_fh, &amp;setattr-&gt;sa_iattr,
 				0, (time_t)0);
-out:
-	return status;
-out_unlock:
-	nfs4_unlock_state();
 	return status;
 }
 
@@ -628,15 +624,17 @@ nfsd4_write(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_writ
 		return nfserr_inval;
 
 	nfs4_lock_state();
-	if ((status = nfs4_preprocess_stateid_op(current_fh, stateid,
-					CHECK_FH | WR_STATE, &amp;filp))) {
-		dprintk("NFSD: nfsd4_write: couldn't process stateid!\n");
-		goto out;
-	}
+	status = nfs4_preprocess_stateid_op(current_fh, stateid,
+					CHECK_FH | WR_STATE, &amp;filp);
 	if (filp)
 		get_file(filp);
 	nfs4_unlock_state();
 
+	if (status) {
+		dprintk("NFSD: nfsd4_write: couldn't process stateid!\n");
+		return status;
+	}
+
 	write-&gt;wr_bytes_written = write-&gt;wr_buflen;
 	write-&gt;wr_how_written = write-&gt;wr_stable_how;
 	p = (u32 *)write-&gt;wr_verifier.data;
@@ -652,9 +650,6 @@ nfsd4_write(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_writ
 	if (status == nfserr_symlink)
 		status = nfserr_inval;
 	return status;
-out:
-	nfs4_unlock_state();
-	return status;
 }
 
 /* This routine never returns NFS_OK!  If there are no other errors, it</pre>
    <div class="pagination">
        <a href='4_50.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><span>[51]</span><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_52.html'>Next&gt;&gt;</a>
    <div>
</body>
