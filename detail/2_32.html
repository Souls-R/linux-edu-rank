<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_31.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><span>[32]</span><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_33.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4a71f242e51767e75c7ecdba890debab2c0dceaf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:15:14 2013 -0400

    USB: EHCI: fix sparse errors
    
    This patch fixes several sparse errors in ehci-hcd introduced by
    commit 3d091a6f7039 (USB: EHCI: AMD periodic frame list table quirk).
    Although the problem fixed by that commit affects only little-endian
    systems, the source code has to use types appropriate for big-endian
    too.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 52a77734a225..c0fb6a8ae6a3 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -224,11 +224,11 @@ static int ehci_mem_init (struct ehci_hcd *ehci, gfp_t flags)
 		hw-&gt;hw_next = EHCI_LIST_END(ehci);
 		hw-&gt;hw_qtd_next = EHCI_LIST_END(ehci);
 		hw-&gt;hw_alt_next = EHCI_LIST_END(ehci);
-		hw-&gt;hw_token &amp;= ~QTD_STS_ACTIVE;
 		ehci-&gt;dummy-&gt;hw = hw;
 
 		for (i = 0; i &lt; ehci-&gt;periodic_size; i++)
-			ehci-&gt;periodic[i] = ehci-&gt;dummy-&gt;qh_dma;
+			ehci-&gt;periodic[i] = cpu_to_hc32(ehci,
+					ehci-&gt;dummy-&gt;qh_dma);
 	} else {
 		for (i = 0; i &lt; ehci-&gt;periodic_size; i++)
 			ehci-&gt;periodic[i] = EHCI_LIST_END(ehci);
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index fbeb82e552b8..e113fd73aeae 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -103,7 +103,7 @@ static void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
 		*hw_p = *shadow_next_periodic(ehci, &amp;here,
 				Q_NEXT_TYPE(ehci, *hw_p));
 	else
-		*hw_p = ehci-&gt;dummy-&gt;qh_dma;
+		*hw_p = cpu_to_hc32(ehci, ehci-&gt;dummy-&gt;qh_dma);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2446,7 +2446,8 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				    q.itd-&gt;hw_next != EHCI_LIST_END(ehci))
 					*hw_p = q.itd-&gt;hw_next;
 				else
-					*hw_p = ehci-&gt;dummy-&gt;qh_dma;
+					*hw_p = cpu_to_hc32(ehci,
+							ehci-&gt;dummy-&gt;qh_dma);
 				type = Q_NEXT_TYPE(ehci, q.itd-&gt;hw_next);
 				wmb();
 				modified = itd_complete (ehci, q.itd);
@@ -2481,7 +2482,8 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				    q.sitd-&gt;hw_next != EHCI_LIST_END(ehci))
 					*hw_p = q.sitd-&gt;hw_next;
 				else
-					*hw_p = ehci-&gt;dummy-&gt;qh_dma;
+					*hw_p = cpu_to_hc32(ehci,
+							ehci-&gt;dummy-&gt;qh_dma);
 				type = Q_NEXT_TYPE(ehci, q.sitd-&gt;hw_next);
 				wmb();
 				modified = sitd_complete (ehci, q.sitd);</pre><hr><pre>commit 5d8f681f3d14880d5b509eb32a910ba90ef28c36
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 18 11:13:08 2013 -0400

    USB: EHCI: fix type mismatch in check_intr_schedule
    
    This patch fixes a type mismatch in ehci-hcd caused by commit
    b35c5009bbf6 (USB: EHCI: create per-TT bandwidth tables).  The c_maskp
    parameter in check_intr_schedule() was changed to point to unsigned
    int rather than __hc32, but the prototype declaration wasn't adjusted
    accordingly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: kbuild test robot &lt;fengguang.wu@intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 7ce5c2a2fe31..fbeb82e552b8 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -794,7 +794,7 @@ static int check_intr_schedule (
 	unsigned		frame,
 	unsigned		uframe,
 	struct ehci_qh		*qh,
-	__hc32			*c_maskp,
+	unsigned		*c_maskp,
 	struct ehci_tt		*tt
 )
 {</pre><hr><pre>commit a393a807d0c805e7c723315ff0e88a857055e9c6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:36 2013 -0400

    USB: EHCI: start new isochronous streams ASAP
    
    This patch changes the initial delay before the startup of a newly
    scheduled isochronous stream.  Currently the stream doesn't start
    for at least 5 ms (40 microframes).  This value is just an estimate;
    it has no real justification.
    
    Instead, we can start the stream as soon as possible after the
    scheduling computations are complete.  Essentially this requires
    nothing more than reading the frame counter after the stream is
    scheduled, instead of before.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index b5f957d322e3..7ce5c2a2fe31 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1491,8 +1491,6 @@ sitd_slot_ok (
  * given EHCI_TUNE_FLS and the slop).  Or, write a smarter scheduler!
  */
 
-#define SCHEDULING_DELAY	40	/* microframes */
-
 static int
 iso_stream_schedule (
 	struct ehci_hcd		*ehci,
@@ -1506,27 +1504,13 @@ iso_stream_schedule (
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
 	bool			empty = list_empty(&amp;stream-&gt;td_list);
+	bool			new_stream = false;
 
 	period = stream-&gt;uperiod;
 	span = sched-&gt;span;
 	if (!stream-&gt;highspeed)
 		span &lt;&lt;= 3;
 
-	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
-
-	/* Take the isochronous scheduling threshold into account */
-	if (ehci-&gt;i_thresh)
-		next = now + ehci-&gt;i_thresh;	/* uframe cache */
-	else
-		next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
-
-	/*
-	 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
-	 * TDs scheduled for earlier than that.
-	 */
-	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
-	next = (next - base) &amp; (mod - 1);
-
 	/* Start a new isochronous stream? */
 	if (unlikely(empty &amp;&amp; !hcd_periodic_completion_in_progress(
 			ehci_to_hcd(ehci), urb-&gt;ep))) {
@@ -1542,7 +1526,7 @@ iso_stream_schedule (
 			}
 			compute_tt_budget(ehci-&gt;tt_budget, tt);
 
-			start = (now &amp; ~0x07) + SCHEDULING_DELAY;
+			start = ((-(++ehci-&gt;random_frame)) &lt;&lt; 3) &amp; (period - 1);
 
 			/* find a uframe slot with enough bandwidth.
 			 * Early uframes are more precious because full-speed
@@ -1585,17 +1569,35 @@ iso_stream_schedule (
 			start = (stream-&gt;ps.phase &lt;&lt; 3) + stream-&gt;ps.phase_uf;
 		}
 
-		start = (start - base) &amp; (mod - 1);
-		goto use_start;
+		stream-&gt;next_uframe = start;
+		new_stream = true;
 	}
 
+	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
+
+	/* Take the isochronous scheduling threshold into account */
+	if (ehci-&gt;i_thresh)
+		next = now + ehci-&gt;i_thresh;	/* uframe cache */
+	else
+		next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
+
+	/*
+	 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
+	 * TDs scheduled for earlier than that.
+	 */
+	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
+	next = (next - base) &amp; (mod - 1);
+	start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
+
+	if (unlikely(new_stream))
+		goto do_ASAP;
+
 	/*
 	 * Typical case: reuse current schedule, stream may still be active.
 	 * Hopefully there are no gaps from the host falling behind
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
 	 */
-	start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
 	now2 = (now - base) &amp; (mod - 1);
 
 	/* Is the schedule already full? */</pre><hr><pre>commit b35c5009bbf619d8885b4b3c8b102d09002acfe5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 22:16:21 2013 -0400

    USB: EHCI: create per-TT bandwidth tables
    
    This patch continues the scheduling changes in ehci-hcd by adding a
    table to store the bandwidth allocation below each TT.  This will
    speed up the scheduling code, as it will no longer need to read
    through the entire schedule to compute the bandwidth currently in use.
    
    Properly speaking, the FS/LS budget calculations should be done in
    terms of full-speed bytes per microframe, as described in the USB-2
    spec.  However the driver currently uses microseconds per microframe,
    and the scheduling code isn't robust enough at this point to change
    over.  For the time being, we leave the calculations as they are.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 5bbfb1f9929c..4a9c2edbcb2b 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -536,10 +536,14 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 static ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)
 {
 	struct ehci_hcd		*ehci;
+	struct ehci_tt		*tt;
+	struct ehci_per_sched	*ps;
 	unsigned		temp, size;
 	char			*next;
 	unsigned		i;
 	u8			*bw;
+	u16			*bf;
+	u8			budget[EHCI_BANDWIDTH_SIZE];
 
 	ehci = hcd_to_ehci(bus_to_hcd(buf-&gt;bus));
 	next = buf-&gt;output_buf;
@@ -563,6 +567,50 @@ static ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)
 		size -= temp;
 		next += temp;
 	}
+
+	/* Dump all the FS/LS tables */
+	list_for_each_entry(tt, &amp;ehci-&gt;tt_list, tt_list) {
+		temp = scnprintf(next, size,
+				"\nTT %s port %d  FS/LS bandwidth allocation (us per frame)\n",
+				dev_name(&amp;tt-&gt;usb_tt-&gt;hub-&gt;dev),
+				tt-&gt;tt_port + !!tt-&gt;usb_tt-&gt;multi);
+		size -= temp;
+		next += temp;
+
+		bf = tt-&gt;bandwidth;
+		temp = scnprintf(next, size,
+				"  %5u%5u%5u%5u%5u%5u%5u%5u\n",
+				bf[0], bf[1], bf[2], bf[3],
+					bf[4], bf[5], bf[6], bf[7]);
+		size -= temp;
+		next += temp;
+
+		temp = scnprintf(next, size,
+				"FS/LS budget (us per microframe)\n");
+		size -= temp;
+		next += temp;
+		compute_tt_budget(budget, tt);
+		for (i = 0; i &lt; EHCI_BANDWIDTH_SIZE; i += 8) {
+			bw = &amp;budget[i];
+			temp = scnprintf(next, size,
+					"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\n",
+					i, bw[0], bw[1], bw[2], bw[3],
+						bw[4], bw[5], bw[6], bw[7]);
+			size -= temp;
+			next += temp;
+		}
+		list_for_each_entry(ps, &amp;tt-&gt;ps_list, ps_list) {
+			temp = scnprintf(next, size,
+					"%s ep %02x:  %4u @ %2u.%u+%u mask %04x\n",
+					dev_name(&amp;ps-&gt;udev-&gt;dev),
+					ps-&gt;ep-&gt;desc.bEndpointAddress,
+					ps-&gt;tt_usecs,
+					ps-&gt;bw_phase, ps-&gt;phase_uf,
+					ps-&gt;bw_period, ps-&gt;cs_mask);
+			size -= temp;
+			next += temp;
+		}
+	}
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	return next - buf-&gt;output_buf;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 398e8fa3032f..e66706aa9f0c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,6 +110,9 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 #include "ehci.h"
 #include "pci-quirks.h"
 
+static void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],
+		struct ehci_tt *tt);
+
 /*
  * The MosChip MCS9990 controller updates its microframe counter
  * a little before the frame counter, and occasionally we will read
@@ -484,6 +487,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	INIT_LIST_HEAD(&amp;ehci-&gt;intr_qh_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
+	INIT_LIST_HEAD(&amp;ehci-&gt;tt_list);
 
 	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
 		/* periodic schedule size can be smaller than default */
@@ -1051,6 +1055,19 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
+/* Device addition and removal */
+
+static void ehci_remove_device(struct usb_hcd *hcd, struct usb_device *udev)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	drop_tt(udev);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+}
+
+/*-------------------------------------------------------------------------*/
+
 #ifdef	CONFIG_PM
 
 /* suspend/resume, section 4.3 */
@@ -1194,6 +1211,11 @@ static const struct hc_driver ehci_hc_driver = {
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
 	.port_handed_over =	ehci_port_handed_over,
+
+	/*
+	 * device support
+	 */
+	.free_dev =		ehci_remove_device,
 };
 
 void ehci_init_driver(struct hc_driver *drv,
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 790a64c0da5c..b5f957d322e3 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -106,6 +106,103 @@ static void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
 		*hw_p = ehci-&gt;dummy-&gt;qh_dma;
 }
 
+/*-------------------------------------------------------------------------*/
+
+/* Bandwidth and TT management */
+
+/* Find the TT data structure for this device; create it if necessary */
+static struct ehci_tt *find_tt(struct usb_device *udev)
+{
+	struct usb_tt		*utt = udev-&gt;tt;
+	struct ehci_tt		*tt, **tt_index, **ptt;
+	unsigned		port;
+	bool			allocated_index = false;
+
+	if (!utt)
+		return NULL;		/* Not below a TT */
+
+	/*
+	 * Find/create our data structure.
+	 * For hubs with a single TT, we get it directly.
+	 * For hubs with multiple TTs, there's an extra level of pointers.
+	 */
+	tt_index = NULL;
+	if (utt-&gt;multi) {
+		tt_index = utt-&gt;hcpriv;
+		if (!tt_index) {		/* Create the index array */
+			tt_index = kzalloc(utt-&gt;hub-&gt;maxchild *
+					sizeof(*tt_index), GFP_ATOMIC);
+			if (!tt_index)
+				return ERR_PTR(-ENOMEM);
+			utt-&gt;hcpriv = tt_index;
+			allocated_index = true;
+		}
+		port = udev-&gt;ttport - 1;
+		ptt = &amp;tt_index[port];
+	} else {
+		port = 0;
+		ptt = (struct ehci_tt **) &amp;utt-&gt;hcpriv;
+	}
+
+	tt = *ptt;
+	if (!tt) {				/* Create the ehci_tt */
+		struct ehci_hcd		*ehci =
+				hcd_to_ehci(bus_to_hcd(udev-&gt;bus));
+
+		tt = kzalloc(sizeof(*tt), GFP_ATOMIC);
+		if (!tt) {
+			if (allocated_index) {
+				utt-&gt;hcpriv = NULL;
+				kfree(tt_index);
+			}
+			return ERR_PTR(-ENOMEM);
+		}
+		list_add_tail(&amp;tt-&gt;tt_list, &amp;ehci-&gt;tt_list);
+		INIT_LIST_HEAD(&amp;tt-&gt;ps_list);
+		tt-&gt;usb_tt = utt;
+		tt-&gt;tt_port = port;
+		*ptt = tt;
+	}
+
+	return tt;
+}
+
+/* Release the TT above udev, if it's not in use */
+static void drop_tt(struct usb_device *udev)
+{
+	struct usb_tt		*utt = udev-&gt;tt;
+	struct ehci_tt		*tt, **tt_index, **ptt;
+	int			cnt, i;
+
+	if (!utt || !utt-&gt;hcpriv)
+		return;		/* Not below a TT, or never allocated */
+
+	cnt = 0;
+	if (utt-&gt;multi) {
+		tt_index = utt-&gt;hcpriv;
+		ptt = &amp;tt_index[udev-&gt;ttport - 1];
+
+		/* How many entries are left in tt_index? */
+		for (i = 0; i &lt; utt-&gt;hub-&gt;maxchild; ++i)
+			cnt += !!tt_index[i];
+	} else {
+		tt_index = NULL;
+		ptt = (struct ehci_tt **) &amp;utt-&gt;hcpriv;
+	}
+
+	tt = *ptt;
+	if (!tt || !list_empty(&amp;tt-&gt;ps_list))
+		return;		/* never allocated, or still in use */
+
+	list_del(&amp;tt-&gt;tt_list);
+	*ptt = NULL;
+	kfree(tt);
+	if (cnt == 1) {
+		utt-&gt;hcpriv = NULL;
+		kfree(tt_index);
+	}
+}
+
 static void bandwidth_dbg(struct ehci_hcd *ehci, int sign, char *type,
 		struct ehci_per_sched *ps)
 {
@@ -125,6 +222,8 @@ static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
 	unsigned		i, j, m;
 	int			usecs = qh-&gt;ps.usecs;
 	int			c_usecs = qh-&gt;ps.c_usecs;
+	int			tt_usecs = qh-&gt;ps.tt_usecs;
+	struct ehci_tt		*tt;
 
 	if (qh-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
 		return;
@@ -135,6 +234,7 @@ static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
 	if (sign &lt; 0) {		/* Release bandwidth */
 		usecs = -usecs;
 		c_usecs = -c_usecs;
+		tt_usecs = -tt_usecs;
 	}
 
 	/* Entire transaction (high speed) or start-split (full/low speed) */
@@ -153,11 +253,60 @@ static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
 			}
 		}
 	}
+
+	/* FS/LS bus bandwidth */
+	if (tt_usecs) {
+		tt = find_tt(qh-&gt;ps.udev);
+		if (sign &gt; 0)
+			list_add_tail(&amp;qh-&gt;ps.ps_list, &amp;tt-&gt;ps_list);
+		else
+			list_del(&amp;qh-&gt;ps.ps_list);
+
+		for (i = start_uf &gt;&gt; 3; i &lt; EHCI_BANDWIDTH_FRAMES;
+				i += qh-&gt;ps.bw_period)
+			tt-&gt;bandwidth[i] += tt_usecs;
+	}
 }
 
 /*-------------------------------------------------------------------------*/
 
-static int same_tt (struct usb_device *dev1, struct usb_device *dev2)
+static void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],
+		struct ehci_tt *tt)
+{
+	struct ehci_per_sched	*ps;
+	unsigned		uframe, uf, x;
+	u8			*budget_line;
+
+	if (!tt)
+		return;
+	memset(budget_table, 0, EHCI_BANDWIDTH_SIZE);
+
+	/* Add up the contributions from all the endpoints using this TT */
+	list_for_each_entry(ps, &amp;tt-&gt;ps_list, ps_list) {
+		for (uframe = ps-&gt;bw_phase &lt;&lt; 3; uframe &lt; EHCI_BANDWIDTH_SIZE;
+				uframe += ps-&gt;bw_uperiod) {
+			budget_line = &amp;budget_table[uframe];
+			x = ps-&gt;tt_usecs;
+
+			/* propagate the time forward */
+			for (uf = ps-&gt;phase_uf; uf &lt; 8; ++uf) {
+				x += budget_line[uf];
+
+				/* Each microframe lasts 125 us */
+				if (x &lt;= 125) {
+					budget_line[uf] = x;
+					break;
+				} else {
+					budget_line[uf] = 125;
+					x -= 125;
+				}
+			}
+		}
+	}
+}
+
+static int __maybe_unused same_tt(struct usb_device *dev1,
+		struct usb_device *dev2)
 {
 	if (!dev1-&gt;tt || !dev2-&gt;tt)
 		return 0;
@@ -205,68 +354,6 @@ static inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])
 	}
 }
 
-/* How many of the tt's periodic downstream 1000 usecs are allocated?
- *
- * While this measures the bandwidth in terms of usecs/uframe,
- * the low/fullspeed bus has no notion of uframes, so any particular
- * low/fullspeed transfer can "carry over" from one uframe to the next,
- * since the TT just performs downstream transfers in sequence.
- *
- * For example two separate 100 usec transfers can start in the same uframe,
- * and the second one would "carry over" 75 usecs into the next uframe.
- */
-static void
-periodic_tt_usecs (
-	struct ehci_hcd *ehci,
-	struct usb_device *dev,
-	unsigned frame,
-	unsigned short tt_usecs[8]
-)
-{
-	__hc32			*hw_p = &amp;ehci-&gt;periodic [frame];
-	union ehci_shadow	*q = &amp;ehci-&gt;pshadow [frame];
-	unsigned char		uf;
-
-	memset(tt_usecs, 0, 16);
-
-	while (q-&gt;ptr) {
-		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
-		case Q_TYPE_ITD:
-			hw_p = &amp;q-&gt;itd-&gt;hw_next;
-			q = &amp;q-&gt;itd-&gt;itd_next;
-			continue;
-		case Q_TYPE_QH:
-			if (same_tt(dev, q-&gt;qh-&gt;ps.udev)) {
-				uf = tt_start_uframe(ehci, q-&gt;qh-&gt;hw-&gt;hw_info2);
-				tt_usecs[uf] += q-&gt;qh-&gt;ps.tt_usecs;
-			}
-			hw_p = &amp;q-&gt;qh-&gt;hw-&gt;hw_next;
-			q = &amp;q-&gt;qh-&gt;qh_next;
-			continue;
-		case Q_TYPE_SITD:
-			if (same_tt(dev, q-&gt;sitd-&gt;urb-&gt;dev)) {
-				uf = tt_start_uframe(ehci, q-&gt;sitd-&gt;hw_uframe);
-				tt_usecs[uf] += q-&gt;sitd-&gt;stream-&gt;ps.tt_usecs;
-			}
-			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
-			q = &amp;q-&gt;sitd-&gt;sitd_next;
-			continue;
-		// case Q_TYPE_FSTN:
-		default:
-			ehci_dbg(ehci, "ignoring periodic frame %d FSTN\n",
-					frame);
-			hw_p = &amp;q-&gt;fstn-&gt;hw_next;
-			q = &amp;q-&gt;fstn-&gt;fstn_next;
-		}
-	}
-
-	carryover_tt_bandwidth(tt_usecs);
-
-	if (max_tt_usecs[7] &lt; tt_usecs[7])
-		ehci_err(ehci, "frame %d tt sched overrun: %d usecs\n",
-			frame, tt_usecs[7] - max_tt_usecs[7]);
-}
-
 /*
  * Return true if the device's tt's downstream bus is available for a
  * periodic transfer of the specified length (usecs), starting at the
@@ -290,20 +377,29 @@ periodic_tt_usecs (
  */
 static int tt_available (
 	struct ehci_hcd		*ehci,
-	unsigned		period,
-	struct usb_device	*dev,
+	struct ehci_per_sched	*ps,
+	struct ehci_tt		*tt,
 	unsigned		frame,
-	unsigned		uframe,
-	u16			usecs
+	unsigned		uframe
 )
 {
+	unsigned		period = ps-&gt;bw_period;
+	unsigned		usecs = ps-&gt;tt_usecs;
+
 	if ((period == 0) || (uframe &gt;= 7))	/* error */
 		return 0;
 
-	for (; frame &lt; ehci-&gt;periodic_size; frame += period) {
-		unsigned short tt_usecs[8];
+	for (frame &amp;= period - 1; frame &lt; EHCI_BANDWIDTH_FRAMES;
+			frame += period) {
+		unsigned	i, uf;
+		unsigned short	tt_usecs[8];
+
+		if (tt-&gt;bandwidth[frame] + usecs &gt; 900)
+			return 0;
 
-		periodic_tt_usecs (ehci, dev, frame, tt_usecs);
+		uf = frame &lt;&lt; 3;
+		for (i = 0; i &lt; 8; (++i, ++uf))
+			tt_usecs[i] = ehci-&gt;tt_budget[uf];
 
 		if (max_tt_usecs[uframe] &lt;= tt_usecs[uframe])
 			return 0;
@@ -315,7 +411,7 @@ static int tt_available (
 		 */
 		if (125 &lt; usecs) {
 			int ufs = (usecs / 125);
-			int i;
+
 			for (i = uframe; i &lt; (uframe + ufs) &amp;&amp; i &lt; 8; i++)
 				if (0 &lt; tt_usecs[i])
 					return 0;
@@ -697,8 +793,9 @@ static int check_intr_schedule (
 	struct ehci_hcd		*ehci,
 	unsigned		frame,
 	unsigned		uframe,
-	const struct ehci_qh	*qh,
-	__hc32			*c_maskp
+	struct ehci_qh		*qh,
+	__hc32			*c_maskp,
+	struct ehci_tt		*tt
 )
 {
 	int		retval = -ENOSPC;
@@ -716,8 +813,7 @@ static int check_intr_schedule (
 	}
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-	if (tt_available(ehci, qh-&gt;ps.bw_period, qh-&gt;ps.udev, frame, uframe,
-				qh-&gt;ps.tt_usecs)) {
+	if (tt_available(ehci, &amp;qh-&gt;ps, tt, frame, uframe)) {
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
@@ -763,10 +859,11 @@ static int check_intr_schedule (
  */
 static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	int		status;
+	int		status = 0;
 	unsigned	uframe;
 	unsigned	c_mask;
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
+	struct ehci_tt		*tt;
 
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 
@@ -778,7 +875,12 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	uframe = 0;
 	c_mask = 0;
-	status = -ENOSPC;
+	tt = find_tt(qh-&gt;ps.udev);
+	if (IS_ERR(tt)) {
+		status = PTR_ERR(tt);
+		goto done;
+	}
+	compute_tt_budget(ehci-&gt;tt_budget, tt);
 
 	/* else scan the schedule to find a group of slots such that all
 	 * uframes have enough periodic bandwidth available.
@@ -788,22 +890,24 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		int		i;
 		unsigned	frame;
 
-		for (i = qh-&gt;ps.bw_period; status &amp;&amp; i &gt; 0; --i) {
+		for (i = qh-&gt;ps.bw_period; i &gt; 0; --i) {
 			frame = ++ehci-&gt;random_frame &amp; (qh-&gt;ps.bw_period - 1);
 			for (uframe = 0; uframe &lt; 8; uframe++) {
 				status = check_intr_schedule(ehci,
-						frame, uframe, qh, &amp;c_mask);
+						frame, uframe, qh, &amp;c_mask, tt);
 				if (status == 0)
-					break;
+					goto got_it;
 			}
 		}
 
 	/* qh-&gt;ps.bw_period == 0 means every uframe */
 	} else {
-		status = check_intr_schedule(ehci, 0, 0, qh, &amp;c_mask);
+		status = check_intr_schedule(ehci, 0, 0, qh, &amp;c_mask, tt);
 	}
 	if (status)
 		goto done;
+
+ got_it:
 	qh-&gt;ps.phase = (qh-&gt;ps.period ? ehci-&gt;random_frame &amp;
 			(qh-&gt;ps.period - 1) : 0);
 	qh-&gt;ps.bw_phase = qh-&gt;ps.phase &amp; (qh-&gt;ps.bw_period - 1);
@@ -1232,6 +1336,8 @@ static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
 	unsigned		s_mask, c_mask, m;
 	int			usecs = stream-&gt;ps.usecs;
 	int			c_usecs = stream-&gt;ps.c_usecs;
+	int			tt_usecs = stream-&gt;ps.tt_usecs;
+	struct ehci_tt		*tt;
 
 	if (stream-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
 		return;
@@ -1242,6 +1348,7 @@ static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
 	if (sign &lt; 0) {		/* Release bandwidth */
 		usecs = -usecs;
 		c_usecs = -c_usecs;
+		tt_usecs = -tt_usecs;
 	}
 
 	if (!stream-&gt;splits) {		/* High speed */
@@ -1264,6 +1371,16 @@ static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
 					ehci-&gt;bandwidth[i+j] += c_usecs;
 			}
 		}
+
+		tt = find_tt(stream-&gt;ps.udev);
+		if (sign &gt; 0)
+			list_add_tail(&amp;stream-&gt;ps.ps_list, &amp;tt-&gt;ps_list);
+		else
+			list_del(&amp;stream-&gt;ps.ps_list);
+
+		for (i = uframe &gt;&gt; 3; i &lt; EHCI_BANDWIDTH_FRAMES;
+				i += stream-&gt;ps.bw_period)
+			tt-&gt;bandwidth[i] += tt_usecs;
 	}
 }
 
@@ -1292,7 +1409,8 @@ sitd_slot_ok (
 	struct ehci_hcd		*ehci,
 	struct ehci_iso_stream	*stream,
 	unsigned		uframe,
-	struct ehci_iso_sched	*sched
+	struct ehci_iso_sched	*sched,
+	struct ehci_tt		*tt
 )
 {
 	unsigned		mask, tmp;
@@ -1317,8 +1435,7 @@ sitd_slot_ok (
 	 * tt_available scheduling guarantees 10+% for control/bulk.
 	 */
 	uf = uframe &amp; 7;
-	if (!tt_available(ehci, stream-&gt;ps.bw_period,
-			stream-&gt;ps.udev, frame, uf, stream-&gt;ps.tt_usecs))
+	if (!tt_available(ehci, &amp;stream-&gt;ps, tt, frame, uf))
 		return 0;
 #else
 	/* tt must be idle for start(s), any gap, and csplit.
@@ -1417,6 +1534,13 @@ iso_stream_schedule (
 		/* Schedule the endpoint */
 		if (stream-&gt;ps.phase == NO_FRAME) {
 			int		done = 0;
+			struct ehci_tt	*tt = find_tt(stream-&gt;ps.udev);
+
+			if (IS_ERR(tt)) {
+				status = PTR_ERR(tt);
+				goto fail;
+			}
+			compute_tt_budget(ehci-&gt;tt_budget, tt);
 
 			start = (now &amp; ~0x07) + SCHEDULING_DELAY;
 
@@ -1437,7 +1561,7 @@ iso_stream_schedule (
 					if ((start % 8) &gt;= 6)
 						continue;
 					if (sitd_slot_ok(ehci, stream, start,
-							sched))
+							sched, tt))
 						done = 1;
 				}
 			} while (start &gt; next &amp;&amp; !done);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 12504fbded56..e8f41c5e771b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -61,6 +61,7 @@ struct ehci_stats {
 struct ehci_per_sched {
 	struct usb_device	*udev;		/* access to the TT */
 	struct usb_host_endpoint *ep;
+	struct list_head	ps_list;	/* node on ehci_tt's ps_list */
 	u16			tt_usecs;	/* time on the FS/LS bus */
 	u16			cs_mask;	/* C-mask and S-mask bytes */
 	u16			period;		/* actual period in frames */
@@ -256,6 +257,9 @@ struct ehci_hcd {			/* one per controller */
 #define EHCI_BANDWIDTH_FRAMES	(EHCI_BANDWIDTH_SIZE &gt;&gt; 3)
 	u8			bandwidth[EHCI_BANDWIDTH_SIZE];
 						/* us allocated per uframe */
+	u8			tt_budget[EHCI_BANDWIDTH_SIZE];
+						/* us budgeted per uframe */
+	struct list_head	tt_list;
 
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
@@ -595,6 +599,35 @@ struct ehci_fstn {
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * USB-2.0 Specification Sections 11.14 and 11.18
+ * Scheduling and budgeting split transactions using TTs
+ *
+ * A hub can have a single TT for all its ports, or multiple TTs (one for each
+ * port).  The bandwidth and budgeting information for the full/low-speed bus
+ * below each TT is self-contained and independent of the other TTs or the
+ * high-speed bus.
+ *
+ * "Bandwidth" refers to the number of microseconds on the FS/LS bus allocated
+ * to an interrupt or isochronous endpoint for each frame.  "Budget" refers to
+ * the best-case estimate of the number of full-speed bytes allocated to an
+ * endpoint for each microframe within an allocated frame.
+ *
+ * Removal of an endpoint invalidates a TT's budget.  Instead of trying to
+ * keep an up-to-date record, we recompute the budget when it is needed.
+ */
+
+struct ehci_tt {
+	u16			bandwidth[EHCI_BANDWIDTH_FRAMES];
+
+	struct list_head	tt_list;	/* List of all ehci_tt's */
+	struct list_head	ps_list;	/* Items using this TT */
+	struct usb_tt		*usb_tt;
+	int			tt_port;	/* TT port number */
+};
+
+/*-------------------------------------------------------------------------*/
+
 /* Prepare the PORTSC wakeup flags during controller suspend/resume */
 
 #define ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup)	\</pre><hr><pre>commit 7c4bb942986fc2aa7ca4fccfed665d24525a0e21
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:22 2013 -0400

    USB: add a private-data pointer to struct usb_tt
    
    For improved scheduling of transfers through a Transaction Translator,
    ehci-hcd will need to store a bunch of information associated with the
    FS/LS bus on the downstream side of the TT.  This patch adds a pointer
    for such HCD-private data to the usb_tt structure.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index dbe3cd19ffd8..b8aba196f7f1 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -506,6 +506,7 @@ struct usb_tt {
 	struct usb_device	*hub;	/* upstream highspeed hub */
 	int			multi;	/* true means one TT per port */
 	unsigned		think_time;	/* think time in ns */
+	void			*hcpriv;	/* HCD private data */
 
 	/* for control/bulk error recovery (CLEAR_TT_BUFFER) */
 	spinlock_t		lock;</pre><hr><pre>commit d0ce5c6b9208c79fc725c578eebdeb5724faf17d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:13 2013 -0400

    USB: EHCI: use a bandwidth-allocation table
    
    This patch significantly changes the scheduling code in ehci-hcd.
    Instead of calculating the current bandwidth utilization by trudging
    through the schedule and adding up the times used by the existing
    transfers, we will now maintain a table holding the time used for each
    of 64 microframes.  This will drastically speed up the bandwidth
    computations.
    
    In addition, it eliminates a theoretical bug.  An isochronous endpoint
    may have bandwidth reserved even at times when it has no transfers
    listed in the schedule.  The table will keep track of the reserved
    bandwidth, whereas adding up entries in the schedule would miss it.
    
    As a corollary, we can keep bandwidth reserved for endpoints even
    when they aren't in active use.  Eventually the bandwidth will be
    reserved when a new alternate setting is installed; for now the
    endpoint's reservation takes place when its first URB is submitted.
    
    A drawback of this approach is that transfers with an interval larger
    than 64 microframes will have to be charged for bandwidth as though
    the interval was 64.  In practice this shouldn't matter much;
    transfers with longer intervals tend to be rather short anyway (things
    like hubs or HID devices).
    
    Another minor drawback is that we will keep track of two different
    period and phase values: the actual ones and the ones used for
    bandwidth allocation (which are limited to 64).  This adds only a
    small amount of overhead: 3 bytes for each endpoint.
    
    The patch also adds a new debugfs file named "bandwidth" to display
    the information stored in the new table.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 09e5bc8e2b98..5bbfb1f9929c 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -334,6 +334,7 @@ static inline void remove_debug_files (struct ehci_hcd *bus) { }
 /* troubleshooting help: expose state in debugfs */
 
 static int debug_async_open(struct inode *, struct file *);
+static int debug_bandwidth_open(struct inode *, struct file *);
 static int debug_periodic_open(struct inode *, struct file *);
 static int debug_registers_open(struct inode *, struct file *);
 
@@ -347,6 +348,13 @@ static const struct file_operations debug_async_fops = {
 	.release	= debug_close,
 	.llseek		= default_llseek,
 };
+static const struct file_operations debug_bandwidth_fops = {
+	.owner		= THIS_MODULE,
+	.open		= debug_bandwidth_open,
+	.read		= debug_output,
+	.release	= debug_close,
+	.llseek		= default_llseek,
+};
 static const struct file_operations debug_periodic_fops = {
 	.owner		= THIS_MODULE,
 	.open		= debug_periodic_open,
@@ -525,6 +533,41 @@ static ssize_t fill_async_buffer(struct debug_buffer *buf)
 	return strlen(buf-&gt;output_buf);
 }
 
+static ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)
+{
+	struct ehci_hcd		*ehci;
+	unsigned		temp, size;
+	char			*next;
+	unsigned		i;
+	u8			*bw;
+
+	ehci = hcd_to_ehci(bus_to_hcd(buf-&gt;bus));
+	next = buf-&gt;output_buf;
+	size = buf-&gt;alloc_size;
+
+	*next = 0;
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
+
+	/* Dump the HS bandwidth table */
+	temp = scnprintf(next, size,
+			"HS bandwidth allocation (us per microframe)\n");
+	size -= temp;
+	next += temp;
+	for (i = 0; i &lt; EHCI_BANDWIDTH_SIZE; i += 8) {
+		bw = &amp;ehci-&gt;bandwidth[i];
+		temp = scnprintf(next, size,
+				"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\n",
+				i, bw[0], bw[1], bw[2], bw[3],
+					bw[4], bw[5], bw[6], bw[7]);
+		size -= temp;
+		next += temp;
+	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	return next - buf-&gt;output_buf;
+}
+
 #define DBG_SCHED_LIMIT 64
 static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 {
@@ -919,6 +962,7 @@ static int debug_close(struct inode *inode, struct file *file)
 
 	return 0;
 }
+
 static int debug_async_open(struct inode *inode, struct file *file)
 {
 	file-&gt;private_data = alloc_buffer(inode-&gt;i_private, fill_async_buffer);
@@ -926,6 +970,14 @@ static int debug_async_open(struct inode *inode, struct file *file)
 	return file-&gt;private_data ? 0 : -ENOMEM;
 }
 
+static int debug_bandwidth_open(struct inode *inode, struct file *file)
+{
+	file-&gt;private_data = alloc_buffer(inode-&gt;i_private,
+			fill_bandwidth_buffer);
+
+	return file-&gt;private_data ? 0 : -ENOMEM;
+}
+
 static int debug_periodic_open(struct inode *inode, struct file *file)
 {
 	struct debug_buffer *buf;
@@ -958,6 +1010,10 @@ static inline void create_debug_files (struct ehci_hcd *ehci)
 						&amp;debug_async_fops))
 		goto file_error;
 
+	if (!debugfs_create_file("bandwidth", S_IRUGO, ehci-&gt;debug_dir, bus,
+						&amp;debug_bandwidth_fops))
+		goto file_error;
+
 	if (!debugfs_create_file("periodic", S_IRUGO, ehci-&gt;debug_dir, bus,
 						&amp;debug_periodic_fops))
 		goto file_error;
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b2e4e4b3cfae..398e8fa3032f 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -956,6 +956,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			goto idle_timeout;
 
 		/* BUG_ON(!list_empty(&amp;stream-&gt;free_list)); */
+		reserve_release_iso_bandwidth(ehci, stream, -1);
 		kfree(stream);
 		goto done;
 	}
@@ -982,6 +983,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		if (qh-&gt;clearing_tt)
 			goto idle_timeout;
 		if (list_empty (&amp;qh-&gt;qtd_list)) {
+			if (qh-&gt;ps.bw_uperiod)
+				reserve_release_intr_bandwidth(ehci, qh, -1);
 			qh_destroy(ehci, qh);
 			break;
 		}
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 9bfaa21707bd..db05bd8ee9d5 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -797,6 +797,8 @@ qh_make (
 	 * For control/bulk requests, the HC or TT handles these.
 	 */
 	if (type == PIPE_INTERRUPT) {
+		unsigned	tmp;
+
 		qh-&gt;ps.usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
@@ -816,6 +818,14 @@ qh_make (
 				urb-&gt;interval = ehci-&gt;periodic_size &lt;&lt; 3;
 			}
 			qh-&gt;ps.period = urb-&gt;interval &gt;&gt; 3;
+
+			/* period for bandwidth allocation */
+			tmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,
+					1 &lt;&lt; (urb-&gt;ep-&gt;desc.bInterval - 1));
+
+			/* Allow urb-&gt;interval to override */
+			qh-&gt;ps.bw_uperiod = min_t(unsigned, tmp, urb-&gt;interval);
+			qh-&gt;ps.bw_period = qh-&gt;ps.bw_uperiod &gt;&gt; 3;
 		} else {
 			int		think_time;
 
@@ -839,6 +849,15 @@ qh_make (
 			if (urb-&gt;interval &gt; ehci-&gt;periodic_size)
 				urb-&gt;interval = ehci-&gt;periodic_size;
 			qh-&gt;ps.period = urb-&gt;interval;
+
+			/* period for bandwidth allocation */
+			tmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,
+					urb-&gt;ep-&gt;desc.bInterval);
+			tmp = rounddown_pow_of_two(tmp);
+
+			/* Allow urb-&gt;interval to override */
+			qh-&gt;ps.bw_period = min_t(unsigned, tmp, urb-&gt;interval);
+			qh-&gt;ps.bw_uperiod = qh-&gt;ps.bw_period &lt;&lt; 3;
 		}
 	}
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1fafcda0ae81..790a64c0da5c 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -106,75 +106,53 @@ static void periodic_unlink (struct ehci_hcd *ehci, unsigned frame, void *ptr)
 		*hw_p = ehci-&gt;dummy-&gt;qh_dma;
 }
 
-/* how many of the uframe's 125 usecs are allocated? */
-static unsigned short
-periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
+static void bandwidth_dbg(struct ehci_hcd *ehci, int sign, char *type,
+		struct ehci_per_sched *ps)
 {
-	__hc32			*hw_p = &amp;ehci-&gt;periodic [frame];
-	union ehci_shadow	*q = &amp;ehci-&gt;pshadow [frame];
-	unsigned		usecs = 0;
-	struct ehci_qh_hw	*hw;
+	dev_dbg(&amp;ps-&gt;udev-&gt;dev,
+			"ep %02x: %s %s @ %u+%u (%u.%u+%u) [%u/%u us] mask %04x\n",
+			ps-&gt;ep-&gt;desc.bEndpointAddress,
+			(sign &gt;= 0 ? "reserve" : "release"), type,
+			(ps-&gt;bw_phase &lt;&lt; 3) + ps-&gt;phase_uf, ps-&gt;bw_uperiod,
+			ps-&gt;phase, ps-&gt;phase_uf, ps-&gt;period,
+			ps-&gt;usecs, ps-&gt;c_usecs, ps-&gt;cs_mask);
+}
 
-	while (q-&gt;ptr) {
-		switch (hc32_to_cpu(ehci, Q_NEXT_TYPE(ehci, *hw_p))) {
-		case Q_TYPE_QH:
-			hw = q-&gt;qh-&gt;hw;
-			/* is it in the S-mask? */
-			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci, 1 &lt;&lt; uframe))
-				usecs += q-&gt;qh-&gt;ps.usecs;
-			/* ... or C-mask? */
-			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci,
-					1 &lt;&lt; (8 + uframe)))
-				usecs += q-&gt;qh-&gt;ps.c_usecs;
-			hw_p = &amp;hw-&gt;hw_next;
-			q = &amp;q-&gt;qh-&gt;qh_next;
-			break;
-		// case Q_TYPE_FSTN:
-		default:
-			/* for "save place" FSTNs, count the relevant INTR
-			 * bandwidth from the previous frame
-			 */
-			if (q-&gt;fstn-&gt;hw_prev != EHCI_LIST_END(ehci)) {
-				ehci_dbg (ehci, "ignoring FSTN cost ...\n");
-			}
-			hw_p = &amp;q-&gt;fstn-&gt;hw_next;
-			q = &amp;q-&gt;fstn-&gt;fstn_next;
-			break;
-		case Q_TYPE_ITD:
-			if (q-&gt;itd-&gt;hw_transaction[uframe])
-				usecs += q-&gt;itd-&gt;stream-&gt;ps.usecs;
-			hw_p = &amp;q-&gt;itd-&gt;hw_next;
-			q = &amp;q-&gt;itd-&gt;itd_next;
-			break;
-		case Q_TYPE_SITD:
-			/* is it in the S-mask?  (count SPLIT, DATA) */
-			if (q-&gt;sitd-&gt;hw_uframe &amp; cpu_to_hc32(ehci,
-					1 &lt;&lt; uframe)) {
-				if (q-&gt;sitd-&gt;hw_fullspeed_ep &amp;
-						cpu_to_hc32(ehci, 1&lt;&lt;31))
-					usecs += q-&gt;sitd-&gt;stream-&gt;ps.usecs;
-				else	/* worst case for OUT start-split */
-					usecs += HS_USECS_ISO (188);
-			}
+static void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,
+		struct ehci_qh *qh, int sign)
+{
+	unsigned		start_uf;
+	unsigned		i, j, m;
+	int			usecs = qh-&gt;ps.usecs;
+	int			c_usecs = qh-&gt;ps.c_usecs;
 
-			/* ... C-mask?  (count CSPLIT, DATA) */
-			if (q-&gt;sitd-&gt;hw_uframe &amp;
-					cpu_to_hc32(ehci, 1 &lt;&lt; (8 + uframe))) {
-				/* worst case for IN complete-split */
-				usecs += q-&gt;sitd-&gt;stream-&gt;ps.c_usecs;
-			}
+	if (qh-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
+		return;
+	start_uf = qh-&gt;ps.bw_phase &lt;&lt; 3;
 
-			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
-			q = &amp;q-&gt;sitd-&gt;sitd_next;
-			break;
+	bandwidth_dbg(ehci, sign, "intr", &amp;qh-&gt;ps);
+
+	if (sign &lt; 0) {		/* Release bandwidth */
+		usecs = -usecs;
+		c_usecs = -c_usecs;
+	}
+
+	/* Entire transaction (high speed) or start-split (full/low speed) */
+	for (i = start_uf + qh-&gt;ps.phase_uf; i &lt; EHCI_BANDWIDTH_SIZE;
+			i += qh-&gt;ps.bw_uperiod)
+		ehci-&gt;bandwidth[i] += usecs;
+
+	/* Complete-split (full/low speed) */
+	if (qh-&gt;ps.c_usecs) {
+		/* NOTE: adjustments needed for FSTN */
+		for (i = start_uf; i &lt; EHCI_BANDWIDTH_SIZE;
+				i += qh-&gt;ps.bw_uperiod) {
+			for ((j = 2, m = 1 &lt;&lt; (j+8)); j &lt; 8; (++j, m &lt;&lt;= 1)) {
+				if (qh-&gt;ps.cs_mask &amp; m)
+					ehci-&gt;bandwidth[i+j] += c_usecs;
+			}
 		}
 	}
-#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)
-	if (usecs &gt; ehci-&gt;uframe_periodic_max)
-		ehci_err (ehci, "uframe %d sched overrun: %d usecs\n",
-			frame * 8 + uframe, usecs);
-#endif
-	return usecs;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -524,8 +502,8 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;exception = 0;
 
 	/* update per-qh bandwidth for debugfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;ps.period
-		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;ps.bw_period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.bw_period)
 		: (qh-&gt;ps.usecs * 8);
 
 	list_add(&amp;qh-&gt;intr_node, &amp;ehci-&gt;intr_qh_list);
@@ -562,8 +540,8 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		periodic_unlink (ehci, i, qh);
 
 	/* update per-qh bandwidth for debugfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;ps.period
-		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;ps.bw_period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.bw_period)
 		: (qh-&gt;ps.usecs * 8);
 
 	dev_dbg(&amp;qh-&gt;ps.udev-&gt;dev,
@@ -693,11 +671,9 @@ static int check_period (
 	struct ehci_hcd *ehci,
 	unsigned	frame,
 	unsigned	uframe,
-	unsigned	period,
+	unsigned	uperiod,
 	unsigned	usecs
 ) {
-	int		claimed;
-
 	/* complete split running into next frame?
 	 * given FSTN support, we could sometimes check...
 	 */
@@ -707,25 +683,10 @@ static int check_period (
 	/* convert "usecs we need" to "max already claimed" */
 	usecs = ehci-&gt;uframe_periodic_max - usecs;
 
-	/* we "know" 2 and 4 uframe intervals were rejected; so
-	 * for period 0, check _every_ microframe in the schedule.
-	 */
-	if (unlikely (period == 0)) {
-		do {
-			for (uframe = 0; uframe &lt; 7; uframe++) {
-				claimed = periodic_usecs (ehci, frame, uframe);
-				if (claimed &gt; usecs)
-					return 0;
-			}
-		} while ((frame += 1) &lt; ehci-&gt;periodic_size);
-
-	/* just check the specified uframe, at that period */
-	} else {
-		do {
-			claimed = periodic_usecs (ehci, frame, uframe);
-			if (claimed &gt; usecs)
-				return 0;
-		} while ((frame += period) &lt; ehci-&gt;periodic_size);
+	for (uframe += frame &lt;&lt; 3; uframe &lt; EHCI_BANDWIDTH_SIZE;
+			uframe += uperiod) {
+		if (ehci-&gt;bandwidth[uframe] &gt; usecs)
+			return 0;
 	}
 
 	// success!
@@ -746,7 +707,7 @@ static int check_intr_schedule (
 	if (qh-&gt;ps.c_usecs &amp;&amp; uframe &gt;= 6)	/* FSTN territory? */
 		goto done;
 
-	if (!check_period(ehci, frame, uframe, qh-&gt;ps.period, qh-&gt;ps.usecs))
+	if (!check_period(ehci, frame, uframe, qh-&gt;ps.bw_uperiod, qh-&gt;ps.usecs))
 		goto done;
 	if (!qh-&gt;ps.c_usecs) {
 		retval = 0;
@@ -755,21 +716,21 @@ static int check_intr_schedule (
 	}
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-	if (tt_available(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, uframe,
+	if (tt_available(ehci, qh-&gt;ps.bw_period, qh-&gt;ps.udev, frame, uframe,
 				qh-&gt;ps.tt_usecs)) {
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
 		for (i = uframe+2; i &lt; 8 &amp;&amp; i &lt;= uframe+4; i++)
 			if (!check_period(ehci, frame, i,
-					qh-&gt;ps.period, qh-&gt;ps.c_usecs))
+					qh-&gt;ps.bw_uperiod, qh-&gt;ps.c_usecs))
 				goto done;
 			else
 				mask |= 1 &lt;&lt; i;
 
 		retval = 0;
 
-		*c_maskp = cpu_to_hc32(ehci, mask &lt;&lt; 8);
+		*c_maskp = mask;
 	}
 #else
 	/* Make sure this tt's buffer is also available for CSPLITs.
@@ -780,15 +741,15 @@ static int check_intr_schedule (
 	 * one smart pass...
 	 */
 	mask = 0x03 &lt;&lt; (uframe + qh-&gt;gap_uf);
-	*c_maskp = cpu_to_hc32(ehci, mask &lt;&lt; 8);
+	*c_maskp = mask;
 
 	mask |= 1 &lt;&lt; uframe;
-	if (tt_no_collision(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, mask)) {
+	if (tt_no_collision(ehci, qh-&gt;ps.bw_period, qh-&gt;ps.udev, frame, mask)) {
 		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf + 1,
-				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
+				qh-&gt;ps.bw_uperiod, qh-&gt;ps.c_usecs))
 			goto done;
 		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf,
-				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
+				qh-&gt;ps.bw_uperiod, qh-&gt;ps.c_usecs))
 			goto done;
 		retval = 0;
 	}
@@ -804,60 +765,57 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	int		status;
 	unsigned	uframe;
-	__hc32		c_mask;
-	unsigned	frame;		/* 0..(qh-&gt;period - 1), or NO_FRAME */
+	unsigned	c_mask;
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
-	frame = qh-&gt;ps.phase;
 
 	/* reuse the previous schedule slots, if we can */
-	if (frame != NO_FRAME) {
-		uframe = ffs(hc32_to_cpup(ehci, &amp;hw-&gt;hw_info2) &amp; QH_SMASK);
-		status = check_intr_schedule (ehci, frame, --uframe,
-				qh, &amp;c_mask);
-	} else {
-		uframe = 0;
-		c_mask = 0;
-		status = -ENOSPC;
+	if (qh-&gt;ps.phase != NO_FRAME) {
+		ehci_dbg(ehci, "reused qh %p schedule\n", qh);
+		return 0;
 	}
 
+	uframe = 0;
+	c_mask = 0;
+	status = -ENOSPC;
+
 	/* else scan the schedule to find a group of slots such that all
 	 * uframes have enough periodic bandwidth available.
 	 */
-	if (status) {
-		/* "normal" case, uframing flexible except with splits */
-		if (qh-&gt;ps.period) {
-			int		i;
-
-			for (i = qh-&gt;ps.period; status &amp;&amp; i &gt; 0; --i) {
-				frame = ++ehci-&gt;random_frame % qh-&gt;ps.period;
-				for (uframe = 0; uframe &lt; 8; uframe++) {
-					status = check_intr_schedule (ehci,
-							frame, uframe, qh,
-							&amp;c_mask);
-					if (status == 0)
-						break;
-				}
+	/* "normal" case, uframing flexible except with splits */
+	if (qh-&gt;ps.bw_period) {
+		int		i;
+		unsigned	frame;
+
+		for (i = qh-&gt;ps.bw_period; status &amp;&amp; i &gt; 0; --i) {
+			frame = ++ehci-&gt;random_frame &amp; (qh-&gt;ps.bw_period - 1);
+			for (uframe = 0; uframe &lt; 8; uframe++) {
+				status = check_intr_schedule(ehci,
+						frame, uframe, qh, &amp;c_mask);
+				if (status == 0)
+					break;
 			}
-
-		/* qh-&gt;ps.period == 0 means every uframe */
-		} else {
-			frame = 0;
-			status = check_intr_schedule (ehci, 0, 0, qh, &amp;c_mask);
 		}
-		if (status)
-			goto done;
-		qh-&gt;ps.phase = frame;
 
-		/* reset S-frame and (maybe) C-frame masks */
-		hw-&gt;hw_info2 &amp;= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));
-		hw-&gt;hw_info2 |= qh-&gt;ps.period
-			? cpu_to_hc32(ehci, 1 &lt;&lt; uframe)
-			: cpu_to_hc32(ehci, QH_SMASK);
-		hw-&gt;hw_info2 |= c_mask;
-	} else
-		ehci_dbg (ehci, "reused qh %p schedule\n", qh);
+	/* qh-&gt;ps.bw_period == 0 means every uframe */
+	} else {
+		status = check_intr_schedule(ehci, 0, 0, qh, &amp;c_mask);
+	}
+	if (status)
+		goto done;
+	qh-&gt;ps.phase = (qh-&gt;ps.period ? ehci-&gt;random_frame &amp;
+			(qh-&gt;ps.period - 1) : 0);
+	qh-&gt;ps.bw_phase = qh-&gt;ps.phase &amp; (qh-&gt;ps.bw_period - 1);
+	qh-&gt;ps.phase_uf = uframe;
+	qh-&gt;ps.cs_mask = qh-&gt;ps.period ?
+			(c_mask &lt;&lt; 8) | (1 &lt;&lt; uframe) :
+			QH_SMASK;
+
+	/* reset S-frame and (maybe) C-frame masks */
+	hw-&gt;hw_info2 &amp;= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));
+	hw-&gt;hw_info2 |= cpu_to_hc32(ehci, qh-&gt;ps.cs_mask);
+	reserve_release_intr_bandwidth(ehci, qh, 1);
 
 done:
 	return status;
@@ -969,6 +927,7 @@ iso_stream_alloc (gfp_t mem_flags)
 		INIT_LIST_HEAD(&amp;stream-&gt;td_list);
 		INIT_LIST_HEAD(&amp;stream-&gt;free_list);
 		stream-&gt;next_uframe = NO_FRAME;
+		stream-&gt;ps.phase = NO_FRAME;
 	}
 	return stream;
 }
@@ -983,10 +942,10 @@ iso_stream_init (
 	static const u8 smask_out [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };
 
 	struct usb_device	*dev = urb-&gt;dev;
-	unsigned		interval = urb-&gt;interval;
 	u32			buf1;
 	unsigned		epnum, maxp;
 	int			is_input;
+	unsigned		tmp;
 
 	/*
 	 * this might be a "high bandwidth" highspeed endpoint,
@@ -1020,9 +979,17 @@ iso_stream_init (
 		 */
 		stream-&gt;ps.usecs = HS_USECS_ISO(maxp);
 
-		stream-&gt;bandwidth = stream-&gt;ps.usecs * 8 / interval;
-		stream-&gt;uperiod = interval;
-		stream-&gt;ps.period = interval &gt;&gt; 3;
+		/* period for bandwidth allocation */
+		tmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,
+				1 &lt;&lt; (urb-&gt;ep-&gt;desc.bInterval - 1));
+
+		/* Allow urb-&gt;interval to override */
+		stream-&gt;ps.bw_uperiod = min_t(unsigned, tmp, urb-&gt;interval);
+
+		stream-&gt;uperiod = urb-&gt;interval;
+		stream-&gt;ps.period = urb-&gt;interval &gt;&gt; 3;
+		stream-&gt;bandwidth = stream-&gt;ps.usecs * 8 /
+				stream-&gt;ps.bw_uperiod;
 
 	} else {
 		u32		addr;
@@ -1047,20 +1014,28 @@ iso_stream_init (
 			addr |= 1 &lt;&lt; 31;
 			stream-&gt;ps.c_usecs = stream-&gt;ps.usecs;
 			stream-&gt;ps.usecs = HS_USECS_ISO(1);
-			stream-&gt;raw_mask = 1;
+			stream-&gt;ps.cs_mask = 1;
 
 			/* c-mask as specified in USB 2.0 11.18.4 3.c */
 			tmp = (1 &lt;&lt; (hs_transfers + 2)) - 1;
-			stream-&gt;raw_mask |= tmp &lt;&lt; (8 + 2);
+			stream-&gt;ps.cs_mask |= tmp &lt;&lt; (8 + 2);
 		} else
-			stream-&gt;raw_mask = smask_out [hs_transfers - 1];
+			stream-&gt;ps.cs_mask = smask_out[hs_transfers - 1];
+
+		/* period for bandwidth allocation */
+		tmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,
+				1 &lt;&lt; (urb-&gt;ep-&gt;desc.bInterval - 1));
 
+		/* Allow urb-&gt;interval to override */
+		stream-&gt;ps.bw_period = min_t(unsigned, tmp, urb-&gt;interval);
+		stream-&gt;ps.bw_uperiod = stream-&gt;ps.bw_period &lt;&lt; 3;
+
+		stream-&gt;ps.period = urb-&gt;interval;
+		stream-&gt;uperiod = urb-&gt;interval &lt;&lt; 3;
 		stream-&gt;bandwidth = (stream-&gt;ps.usecs + stream-&gt;ps.c_usecs) /
-				interval;
-		stream-&gt;uperiod = interval &lt;&lt; 3;
-		stream-&gt;ps.period = interval;
+				stream-&gt;ps.bw_period;
 
-		/* stream-&gt;splits gets created from raw_mask later */
+		/* stream-&gt;splits gets created from cs_mask later */
 		stream-&gt;address = cpu_to_hc32(ehci, addr);
 	}
 
@@ -1249,45 +1224,84 @@ itd_urb_transaction (
 
 /*-------------------------------------------------------------------------*/
 
+static void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,
+		struct ehci_iso_stream *stream, int sign)
+{
+	unsigned		uframe;
+	unsigned		i, j;
+	unsigned		s_mask, c_mask, m;
+	int			usecs = stream-&gt;ps.usecs;
+	int			c_usecs = stream-&gt;ps.c_usecs;
+
+	if (stream-&gt;ps.phase == NO_FRAME)	/* Bandwidth wasn't reserved */
+		return;
+	uframe = stream-&gt;ps.bw_phase &lt;&lt; 3;
+
+	bandwidth_dbg(ehci, sign, "iso", &amp;stream-&gt;ps);
+
+	if (sign &lt; 0) {		/* Release bandwidth */
+		usecs = -usecs;
+		c_usecs = -c_usecs;
+	}
+
+	if (!stream-&gt;splits) {		/* High speed */
+		for (i = uframe + stream-&gt;ps.phase_uf; i &lt; EHCI_BANDWIDTH_SIZE;
+				i += stream-&gt;ps.bw_uperiod)
+			ehci-&gt;bandwidth[i] += usecs;
+
+	} else {			/* Full speed */
+		s_mask = stream-&gt;ps.cs_mask;
+		c_mask = s_mask &gt;&gt; 8;
+
+		/* NOTE: adjustment needed for frame overflow */
+		for (i = uframe; i &lt; EHCI_BANDWIDTH_SIZE;
+				i += stream-&gt;ps.bw_uperiod) {
+			for ((j = stream-&gt;ps.phase_uf, m = 1 &lt;&lt; j); j &lt; 8;
+					(++j, m &lt;&lt;= 1)) {
+				if (s_mask &amp; m)
+					ehci-&gt;bandwidth[i+j] += usecs;
+				else if (c_mask &amp; m)
+					ehci-&gt;bandwidth[i+j] += c_usecs;
+			}
+		}
+	}
+}
+
 static inline int
 itd_slot_ok (
 	struct ehci_hcd		*ehci,
-	u32			mod,
-	u32			uframe,
-	u8			usecs,
-	u32			period
+	struct ehci_iso_stream	*stream,
+	unsigned		uframe
 )
 {
-	uframe %= period;
-	do {
-		/* can't commit more than uframe_periodic_max usec */
-		if (periodic_usecs (ehci, uframe &gt;&gt; 3, uframe &amp; 0x7)
-				&gt; (ehci-&gt;uframe_periodic_max - usecs))
-			return 0;
+	unsigned		usecs;
+
+	/* convert "usecs we need" to "max already claimed" */
+	usecs = ehci-&gt;uframe_periodic_max - stream-&gt;ps.usecs;
 
-		/* we know urb-&gt;interval is 2^N uframes */
-		uframe += period;
-	} while (uframe &lt; mod);
+	for (uframe &amp;= stream-&gt;ps.bw_uperiod - 1; uframe &lt; EHCI_BANDWIDTH_SIZE;
+			uframe += stream-&gt;ps.bw_uperiod) {
+		if (ehci-&gt;bandwidth[uframe] &gt; usecs)
+			return 0;
+	}
 	return 1;
 }
 
 static inline int
 sitd_slot_ok (
 	struct ehci_hcd		*ehci,
-	u32			mod,
 	struct ehci_iso_stream	*stream,
-	u32			uframe,
-	struct ehci_iso_sched	*sched,
-	u32			period_uframes
+	unsigned		uframe,
+	struct ehci_iso_sched	*sched
 )
 {
-	u32			mask, tmp;
-	u32			frame, uf;
+	unsigned		mask, tmp;
+	unsigned		frame, uf;
 
-	mask = stream-&gt;raw_mask &lt;&lt; (uframe &amp; 7);
+	mask = stream-&gt;ps.cs_mask &lt;&lt; (uframe &amp; 7);
 
 	/* for OUT, don't wrap SSPLIT into H-microframe 7 */
-	if (((stream-&gt;raw_mask &amp; 0xff) &lt;&lt; (uframe &amp; 7)) &gt;= (1 &lt;&lt; 7))
+	if (((stream-&gt;ps.cs_mask &amp; 0xff) &lt;&lt; (uframe &amp; 7)) &gt;= (1 &lt;&lt; 7))
 		return 0;
 
 	/* for IN, don't wrap CSPLIT into the next frame */
@@ -1295,7 +1309,7 @@ sitd_slot_ok (
 		return 0;
 
 	/* check bandwidth */
-	uframe %= period_uframes;
+	uframe &amp;= stream-&gt;ps.bw_uperiod - 1;
 	frame = uframe &gt;&gt; 3;
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
@@ -1303,55 +1317,49 @@ sitd_slot_ok (
 	 * tt_available scheduling guarantees 10+% for control/bulk.
 	 */
 	uf = uframe &amp; 7;
-	if (!tt_available(ehci, period_uframes &gt;&gt; 3,
+	if (!tt_available(ehci, stream-&gt;ps.bw_period,
 			stream-&gt;ps.udev, frame, uf, stream-&gt;ps.tt_usecs))
 		return 0;
 #else
 	/* tt must be idle for start(s), any gap, and csplit.
 	 * assume scheduling slop leaves 10+% for control/bulk.
 	 */
-	if (!tt_no_collision(ehci, period_uframes &gt;&gt; 3,
+	if (!tt_no_collision(ehci, stream-&gt;ps.bw_period,
 			stream-&gt;ps.udev, frame, mask))
 		return 0;
 #endif
 
-	/* this multi-pass logic is simple, but performance may
-	 * suffer when the schedule data isn't cached.
-	 */
 	do {
-		u32		max_used;
-
-		frame = uframe &gt;&gt; 3;
-		uf = uframe &amp; 7;
+		unsigned	max_used;
+		unsigned	i;
 
 		/* check starts (OUT uses more than one) */
+		uf = uframe;
 		max_used = ehci-&gt;uframe_periodic_max - stream-&gt;ps.usecs;
-		for (tmp = stream-&gt;raw_mask &amp; 0xff; tmp; tmp &gt;&gt;= 1, uf++) {
-			if (periodic_usecs (ehci, frame, uf) &gt; max_used)
+		for (tmp = stream-&gt;ps.cs_mask &amp; 0xff; tmp; tmp &gt;&gt;= 1, uf++) {
+			if (ehci-&gt;bandwidth[uf] &gt; max_used)
 				return 0;
 		}
 
 		/* for IN, check CSPLIT */
 		if (stream-&gt;ps.c_usecs) {
-			uf = uframe &amp; 7;
 			max_used = ehci-&gt;uframe_periodic_max -
 					stream-&gt;ps.c_usecs;
-			do {
-				tmp = 1 &lt;&lt; uf;
-				tmp &lt;&lt;= 8;
-				if ((stream-&gt;raw_mask &amp; tmp) == 0)
+			uf = uframe &amp; ~7;
+			tmp = 1 &lt;&lt; (2+8);
+			for (i = (uframe &amp; 7) + 2; i &lt; 8; (++i, tmp &lt;&lt;= 1)) {
+				if ((stream-&gt;ps.cs_mask &amp; tmp) == 0)
 					continue;
-				if (periodic_usecs (ehci, frame, uf)
-						&gt; max_used)
+				if (ehci-&gt;bandwidth[uf+i] &gt; max_used)
 					return 0;
-			} while (++uf &lt; 8);
+			}
 		}
 
-		/* we know urb-&gt;interval is 2^N uframes */
-		uframe += period_uframes;
-	} while (uframe &lt; mod);
+		uframe += stream-&gt;ps.bw_uperiod;
+	} while (uframe &lt; EHCI_BANDWIDTH_SIZE);
 
-	stream-&gt;splits = cpu_to_hc32(ehci, stream-&gt;raw_mask &lt;&lt; (uframe &amp; 7));
+	stream-&gt;ps.cs_mask &lt;&lt;= uframe &amp; 7;
+	stream-&gt;splits = cpu_to_hc32(ehci, stream-&gt;ps.cs_mask);
 	return 1;
 }
 
@@ -1382,12 +1390,10 @@ iso_stream_schedule (
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
 	bool			empty = list_empty(&amp;stream-&gt;td_list);
 
-	period = urb-&gt;interval;
+	period = stream-&gt;uperiod;
 	span = sched-&gt;span;
-	if (!stream-&gt;highspeed) {
-		period &lt;&lt;= 3;
+	if (!stream-&gt;highspeed)
 		span &lt;&lt;= 3;
-	}
 
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
@@ -1404,47 +1410,55 @@ iso_stream_schedule (
 	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
 	next = (next - base) &amp; (mod - 1);
 
-	/*
-	 * Need to schedule; when's the next (u)frame we could start?
-	 * This is bigger than ehci-&gt;i_thresh allows; scheduling itself
-	 * isn't free, the delay should handle reasonably slow cpus.  It
-	 * can also help high bandwidth if the dma and irq loads don't
-	 * jump until after the queue is primed.
-	 */
+	/* Start a new isochronous stream? */
 	if (unlikely(empty &amp;&amp; !hcd_periodic_completion_in_progress(
 			ehci_to_hcd(ehci), urb-&gt;ep))) {
-		int done = 0;
 
-		start = (now &amp; ~0x07) + SCHEDULING_DELAY;
+		/* Schedule the endpoint */
+		if (stream-&gt;ps.phase == NO_FRAME) {
+			int		done = 0;
 
-		/* find a uframe slot with enough bandwidth.
-		 * Early uframes are more precious because full-speed
-		 * iso IN transfers can't use late uframes,
-		 * and therefore they should be allocated last.
-		 */
-		next = start;
-		start += period;
-		do {
-			start--;
-			/* check schedule: enough space? */
-			if (stream-&gt;highspeed) {
-				if (itd_slot_ok(ehci, mod, start,
-						stream-&gt;ps.usecs, period))
-					done = 1;
-			} else {
-				if ((start % 8) &gt;= 6)
-					continue;
-				if (sitd_slot_ok(ehci, mod, stream,
-						start, sched, period))
-					done = 1;
+			start = (now &amp; ~0x07) + SCHEDULING_DELAY;
+
+			/* find a uframe slot with enough bandwidth.
+			 * Early uframes are more precious because full-speed
+			 * iso IN transfers can't use late uframes,
+			 * and therefore they should be allocated last.
+			 */
+			next = start;
+			start += period;
+			do {
+				start--;
+				/* check schedule: enough space? */
+				if (stream-&gt;highspeed) {
+					if (itd_slot_ok(ehci, stream, start))
+						done = 1;
+				} else {
+					if ((start % 8) &gt;= 6)
+						continue;
+					if (sitd_slot_ok(ehci, stream, start,
+							sched))
+						done = 1;
+				}
+			} while (start &gt; next &amp;&amp; !done);
+
+			/* no room in the schedule */
+			if (!done) {
+				ehci_dbg(ehci, "iso sched full %p", urb);
+				status = -ENOSPC;
+				goto fail;
 			}
-		} while (start &gt; next &amp;&amp; !done);
+			stream-&gt;ps.phase = (start &gt;&gt; 3) &amp;
+					(stream-&gt;ps.period - 1);
+			stream-&gt;ps.bw_phase = stream-&gt;ps.phase &amp;
+					(stream-&gt;ps.bw_period - 1);
+			stream-&gt;ps.phase_uf = start &amp; 7;
+			reserve_release_iso_bandwidth(ehci, stream, 1);
+		}
 
-		/* no room in the schedule */
-		if (!done) {
-			ehci_dbg(ehci, "iso sched full %p", urb);
-			status = -ENOSPC;
-			goto fail;
+		/* New stream is already scheduled; use the upcoming slot */
+		else {
+			start = (stream-&gt;ps.phase &lt;&lt; 3) + stream-&gt;ps.phase_uf;
 		}
 
 		start = (start - base) &amp; (mod - 1);
@@ -1452,7 +1466,7 @@ iso_stream_schedule (
 	}
 
 	/*
-	 * Typical case: reuse current schedule, stream is still active.
+	 * Typical case: reuse current schedule, stream may still be active.
 	 * Hopefully there are no gaps from the host falling behind
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
index 14ced00ba220..f6459dfb6f54 100644
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -97,8 +97,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 {
 	struct ehci_hcd		*ehci;
 	unsigned		uframe_periodic_max;
-	unsigned		frame, uframe;
-	unsigned short		allocated_max;
+	unsigned		uframe;
 	unsigned long		flags;
 	ssize_t			ret;
 
@@ -122,16 +121,14 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 
 	/*
 	 * for request to decrease max periodic bandwidth, we have to check
-	 * every microframe in the schedule to see whether the decrease is
-	 * possible.
+	 * to see whether the decrease is possible.
 	 */
 	if (uframe_periodic_max &lt; ehci-&gt;uframe_periodic_max) {
-		allocated_max = 0;
+		u8		allocated_max = 0;
 
-		for (frame = 0; frame &lt; ehci-&gt;periodic_size; ++frame)
-			for (uframe = 0; uframe &lt; 7; ++uframe)
-				allocated_max = max(allocated_max,
-						    periodic_usecs (ehci, frame, uframe));
+		for (uframe = 0; uframe &lt; EHCI_BANDWIDTH_SIZE; ++uframe)
+			allocated_max = max(allocated_max,
+					ehci-&gt;bandwidth[uframe]);
 
 		if (allocated_max &gt; uframe_periodic_max) {
 			ehci_info(ehci,
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index e2b64c40d94f..12504fbded56 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -62,10 +62,16 @@ struct ehci_per_sched {
 	struct usb_device	*udev;		/* access to the TT */
 	struct usb_host_endpoint *ep;
 	u16			tt_usecs;	/* time on the FS/LS bus */
+	u16			cs_mask;	/* C-mask and S-mask bytes */
 	u16			period;		/* actual period in frames */
 	u16			phase;		/* actual phase, frame part */
+	u8			bw_phase;	/* same, for bandwidth
+						   reservation */
 	u8			phase_uf;	/* uframe part of the phase */
 	u8			usecs, c_usecs;	/* times on the HS bus */
+	u8			bw_uperiod;	/* period in microframes, for
+						   bandwidth reservation */
+	u8			bw_period;	/* same, in frames */
 };
 #define NO_FRAME	29999			/* frame not assigned yet */
 
@@ -245,6 +251,12 @@ struct ehci_hcd {			/* one per controller */
 	struct dentry		*debug_dir;
 #endif
 
+	/* bandwidth usage */
+#define EHCI_BANDWIDTH_SIZE	64
+#define EHCI_BANDWIDTH_FRAMES	(EHCI_BANDWIDTH_SIZE &gt;&gt; 3)
+	u8			bandwidth[EHCI_BANDWIDTH_SIZE];
+						/* us allocated per uframe */
+
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
 };
@@ -469,7 +481,6 @@ struct ehci_iso_stream {
 	 */
 	u16			uperiod;	/* period in uframes */
 	u16			maxp;
-	u16			raw_mask;
 	unsigned		bandwidth;
 
 	/* This is used to initialize iTD's hw_bufp fields */</pre><hr><pre>commit ffa0248e643175cea3887c7058916af53104d8e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:29:03 2013 -0400

    USB: EHCI: create a "periodic schedule info" struct
    
    This patch begins the process of unifying the scheduling parameters
    that ehci-hcd uses for interrupt and isochronous transfers.  It
    creates an ehci_per_sched structure, which will be stored in both
    ehci_qh and ehci_iso_stream structures, and will contain the common
    scheduling information needed for both.
    
    Initially we merely create the new structure and move some existing
    fields into it.  Later patches will add more fields and utilize these
    structures in improved scheduling algorithms.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index da7d7fcccb8a..09e5bc8e2b98 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -571,7 +571,7 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 			case Q_TYPE_QH:
 				hw = p.qh-&gt;hw;
 				temp = scnprintf (next, size, " qh%d-%04x/%p",
-						p.qh-&gt;period,
+						p.qh-&gt;ps.period,
 						hc32_to_cpup(ehci,
 							&amp;hw-&gt;hw_info2)
 							/* uframe masks */
@@ -618,7 +618,8 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 						speed_char (scratch),
 						scratch &amp; 0x007f,
 						(scratch &gt;&gt; 8) &amp; 0x000f, type,
-						p.qh-&gt;usecs, p.qh-&gt;c_usecs,
+						p.qh-&gt;ps.usecs,
+						p.qh-&gt;ps.c_usecs,
 						temp,
 						0x7ff &amp; (scratch &gt;&gt; 16));
 
@@ -645,7 +646,7 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 			case Q_TYPE_SITD:
 				temp = scnprintf (next, size,
 					" sitd%d-%04x/%p",
-					p.sitd-&gt;stream-&gt;interval,
+					p.sitd-&gt;stream-&gt;ps.period,
 					hc32_to_cpup(ehci, &amp;p.sitd-&gt;hw_uframe)
 						&amp; 0x0000ffff,
 					p.sitd);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 652018f93632..b2e4e4b3cfae 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1029,7 +1029,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
-			usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
+			usb_settoggle(qh-&gt;ps.udev, epnum, is_out, 0);
 			qh-&gt;exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index e321804c3475..9bfaa21707bd 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -105,9 +105,9 @@ qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 
 		is_out = qh-&gt;is_out;
 		epnum = (hc32_to_cpup(ehci, &amp;hw-&gt;hw_info1) &gt;&gt; 8) &amp; 0x0f;
-		if (unlikely (!usb_gettoggle (qh-&gt;dev, epnum, is_out))) {
+		if (unlikely(!usb_gettoggle(qh-&gt;ps.udev, epnum, is_out))) {
 			hw-&gt;hw_token &amp;= ~cpu_to_hc32(ehci, QTD_TOGGLE);
-			usb_settoggle (qh-&gt;dev, epnum, is_out, 1);
+			usb_settoggle(qh-&gt;ps.udev, epnum, is_out, 1);
 		}
 	}
 
@@ -797,26 +797,25 @@ qh_make (
 	 * For control/bulk requests, the HC or TT handles these.
 	 */
 	if (type == PIPE_INTERRUPT) {
-		qh-&gt;usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
+		qh-&gt;ps.usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
-		qh-&gt;start = NO_FRAME;
+		qh-&gt;ps.phase = NO_FRAME;
 
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH) {
-			qh-&gt;c_usecs = 0;
+			qh-&gt;ps.c_usecs = 0;
 			qh-&gt;gap_uf = 0;
 
-			qh-&gt;period = urb-&gt;interval &gt;&gt; 3;
-			if (qh-&gt;period == 0 &amp;&amp; urb-&gt;interval != 1) {
+			if (urb-&gt;interval &gt; 1 &amp;&amp; urb-&gt;interval &lt; 8) {
 				/* NOTE interval 2 or 4 uframes could work.
 				 * But interval 1 scheduling is simpler, and
 				 * includes high bandwidth.
 				 */
 				urb-&gt;interval = 1;
-			} else if (qh-&gt;period &gt; ehci-&gt;periodic_size) {
-				qh-&gt;period = ehci-&gt;periodic_size;
-				urb-&gt;interval = qh-&gt;period &lt;&lt; 3;
+			} else if (urb-&gt;interval &gt; ehci-&gt;periodic_size &lt;&lt; 3) {
+				urb-&gt;interval = ehci-&gt;periodic_size &lt;&lt; 3;
 			}
+			qh-&gt;ps.period = urb-&gt;interval &gt;&gt; 3;
 		} else {
 			int		think_time;
 
@@ -826,27 +825,26 @@ qh_make (
 
 			/* FIXME this just approximates SPLIT/CSPLIT times */
 			if (is_input) {		// SPLIT, gap, CSPLIT+DATA
-				qh-&gt;c_usecs = qh-&gt;usecs + HS_USECS (0);
-				qh-&gt;usecs = HS_USECS (1);
+				qh-&gt;ps.c_usecs = qh-&gt;ps.usecs + HS_USECS(0);
+				qh-&gt;ps.usecs = HS_USECS(1);
 			} else {		// SPLIT+DATA, gap, CSPLIT
-				qh-&gt;usecs += HS_USECS (1);
-				qh-&gt;c_usecs = HS_USECS (0);
+				qh-&gt;ps.usecs += HS_USECS(1);
+				qh-&gt;ps.c_usecs = HS_USECS(0);
 			}
 
 			think_time = tt ? tt-&gt;think_time : 0;
-			qh-&gt;tt_usecs = NS_TO_US (think_time +
+			qh-&gt;ps.tt_usecs = NS_TO_US(think_time +
 					usb_calc_bus_time (urb-&gt;dev-&gt;speed,
 					is_input, 0, max_packet (maxp)));
-			qh-&gt;period = urb-&gt;interval;
-			if (qh-&gt;period &gt; ehci-&gt;periodic_size) {
-				qh-&gt;period = ehci-&gt;periodic_size;
-				urb-&gt;interval = qh-&gt;period;
-			}
+			if (urb-&gt;interval &gt; ehci-&gt;periodic_size)
+				urb-&gt;interval = ehci-&gt;periodic_size;
+			qh-&gt;ps.period = urb-&gt;interval;
 		}
 	}
 
 	/* support for tt scheduling, and access to toggles */
-	qh-&gt;dev = urb-&gt;dev;
+	qh-&gt;ps.udev = urb-&gt;dev;
+	qh-&gt;ps.ep = urb-&gt;ep;
 
 	/* using TT? */
 	switch (urb-&gt;dev-&gt;speed) {
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 37e97a70894a..1fafcda0ae81 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -121,11 +121,11 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 			hw = q-&gt;qh-&gt;hw;
 			/* is it in the S-mask? */
 			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci, 1 &lt;&lt; uframe))
-				usecs += q-&gt;qh-&gt;usecs;
+				usecs += q-&gt;qh-&gt;ps.usecs;
 			/* ... or C-mask? */
 			if (hw-&gt;hw_info2 &amp; cpu_to_hc32(ehci,
 					1 &lt;&lt; (8 + uframe)))
-				usecs += q-&gt;qh-&gt;c_usecs;
+				usecs += q-&gt;qh-&gt;ps.c_usecs;
 			hw_p = &amp;hw-&gt;hw_next;
 			q = &amp;q-&gt;qh-&gt;qh_next;
 			break;
@@ -142,7 +142,7 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 			break;
 		case Q_TYPE_ITD:
 			if (q-&gt;itd-&gt;hw_transaction[uframe])
-				usecs += q-&gt;itd-&gt;stream-&gt;usecs;
+				usecs += q-&gt;itd-&gt;stream-&gt;ps.usecs;
 			hw_p = &amp;q-&gt;itd-&gt;hw_next;
 			q = &amp;q-&gt;itd-&gt;itd_next;
 			break;
@@ -152,7 +152,7 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 					1 &lt;&lt; uframe)) {
 				if (q-&gt;sitd-&gt;hw_fullspeed_ep &amp;
 						cpu_to_hc32(ehci, 1&lt;&lt;31))
-					usecs += q-&gt;sitd-&gt;stream-&gt;usecs;
+					usecs += q-&gt;sitd-&gt;stream-&gt;ps.usecs;
 				else	/* worst case for OUT start-split */
 					usecs += HS_USECS_ISO (188);
 			}
@@ -161,7 +161,7 @@ periodic_usecs (struct ehci_hcd *ehci, unsigned frame, unsigned uframe)
 			if (q-&gt;sitd-&gt;hw_uframe &amp;
 					cpu_to_hc32(ehci, 1 &lt;&lt; (8 + uframe))) {
 				/* worst case for IN complete-split */
-				usecs += q-&gt;sitd-&gt;stream-&gt;c_usecs;
+				usecs += q-&gt;sitd-&gt;stream-&gt;ps.c_usecs;
 			}
 
 			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
@@ -258,9 +258,9 @@ periodic_tt_usecs (
 			q = &amp;q-&gt;itd-&gt;itd_next;
 			continue;
 		case Q_TYPE_QH:
-			if (same_tt(dev, q-&gt;qh-&gt;dev)) {
+			if (same_tt(dev, q-&gt;qh-&gt;ps.udev)) {
 				uf = tt_start_uframe(ehci, q-&gt;qh-&gt;hw-&gt;hw_info2);
-				tt_usecs[uf] += q-&gt;qh-&gt;tt_usecs;
+				tt_usecs[uf] += q-&gt;qh-&gt;ps.tt_usecs;
 			}
 			hw_p = &amp;q-&gt;qh-&gt;hw-&gt;hw_next;
 			q = &amp;q-&gt;qh-&gt;qh_next;
@@ -268,7 +268,7 @@ periodic_tt_usecs (
 		case Q_TYPE_SITD:
 			if (same_tt(dev, q-&gt;sitd-&gt;urb-&gt;dev)) {
 				uf = tt_start_uframe(ehci, q-&gt;sitd-&gt;hw_uframe);
-				tt_usecs[uf] += q-&gt;sitd-&gt;stream-&gt;tt_usecs;
+				tt_usecs[uf] += q-&gt;sitd-&gt;stream-&gt;ps.tt_usecs;
 			}
 			hw_p = &amp;q-&gt;sitd-&gt;hw_next;
 			q = &amp;q-&gt;sitd-&gt;sitd_next;
@@ -391,7 +391,7 @@ static int tt_no_collision (
 				continue;
 			case Q_TYPE_QH:
 				hw = here.qh-&gt;hw;
-				if (same_tt (dev, here.qh-&gt;dev)) {
+				if (same_tt(dev, here.qh-&gt;ps.udev)) {
 					u32		mask;
 
 					mask = hc32_to_cpu(ehci,
@@ -471,19 +471,19 @@ static void disable_periodic(struct ehci_hcd *ehci)
 static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	unsigned	i;
-	unsigned	period = qh-&gt;period;
+	unsigned	period = qh-&gt;ps.period;
 
-	dev_dbg (&amp;qh-&gt;dev-&gt;dev,
+	dev_dbg(&amp;qh-&gt;ps.udev-&gt;dev,
 		"link qh%d-%04x/%p start %d [%d/%d us]\n",
 		period, hc32_to_cpup(ehci, &amp;qh-&gt;hw-&gt;hw_info2)
 			&amp; (QH_CMASK | QH_SMASK),
-		qh, qh-&gt;start, qh-&gt;usecs, qh-&gt;c_usecs);
+		qh, qh-&gt;ps.phase, qh-&gt;ps.usecs, qh-&gt;ps.c_usecs);
 
 	/* high bandwidth, or otherwise every microframe */
 	if (period == 0)
 		period = 1;
 
-	for (i = qh-&gt;start; i &lt; ehci-&gt;periodic_size; i += period) {
+	for (i = qh-&gt;ps.phase; i &lt; ehci-&gt;periodic_size; i += period) {
 		union ehci_shadow	*prev = &amp;ehci-&gt;pshadow[i];
 		__hc32			*hw_p = &amp;ehci-&gt;periodic[i];
 		union ehci_shadow	here = *prev;
@@ -503,7 +503,7 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		 * enables sharing interior tree nodes
 		 */
 		while (here.ptr &amp;&amp; qh != here.qh) {
-			if (qh-&gt;period &gt; here.qh-&gt;period)
+			if (qh-&gt;ps.period &gt; here.qh-&gt;ps.period)
 				break;
 			prev = &amp;here.qh-&gt;qh_next;
 			hw_p = &amp;here.qh-&gt;hw-&gt;hw_next;
@@ -523,10 +523,10 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;xacterrs = 0;
 	qh-&gt;exception = 0;
 
-	/* update per-qh bandwidth for usbfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;period
-		? ((qh-&gt;usecs + qh-&gt;c_usecs) / qh-&gt;period)
-		: (qh-&gt;usecs * 8);
+	/* update per-qh bandwidth for debugfs */
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated += qh-&gt;ps.period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+		: (qh-&gt;ps.usecs * 8);
 
 	list_add(&amp;qh-&gt;intr_node, &amp;ehci-&gt;intr_qh_list);
 
@@ -556,22 +556,21 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 */
 
 	/* high bandwidth, or otherwise part of every microframe */
-	if ((period = qh-&gt;period) == 0)
-		period = 1;
+	period = qh-&gt;ps.period ? : 1;
 
-	for (i = qh-&gt;start; i &lt; ehci-&gt;periodic_size; i += period)
+	for (i = qh-&gt;ps.phase; i &lt; ehci-&gt;periodic_size; i += period)
 		periodic_unlink (ehci, i, qh);
 
-	/* update per-qh bandwidth for usbfs */
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;period
-		? ((qh-&gt;usecs + qh-&gt;c_usecs) / qh-&gt;period)
-		: (qh-&gt;usecs * 8);
+	/* update per-qh bandwidth for debugfs */
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated -= qh-&gt;ps.period
+		? ((qh-&gt;ps.usecs + qh-&gt;ps.c_usecs) / qh-&gt;ps.period)
+		: (qh-&gt;ps.usecs * 8);
 
-	dev_dbg (&amp;qh-&gt;dev-&gt;dev,
+	dev_dbg(&amp;qh-&gt;ps.udev-&gt;dev,
 		"unlink qh%d-%04x/%p start %d [%d/%d us]\n",
-		qh-&gt;period,
+		qh-&gt;ps.period,
 		hc32_to_cpup(ehci, &amp;qh-&gt;hw-&gt;hw_info2) &amp; (QH_CMASK | QH_SMASK),
-		qh, qh-&gt;start, qh-&gt;usecs, qh-&gt;c_usecs);
+		qh, qh-&gt;ps.phase, qh-&gt;ps.usecs, qh-&gt;ps.c_usecs);
 
 	/* qh-&gt;qh_next still "live" to HC */
 	qh-&gt;qh_state = QH_STATE_UNLINK;
@@ -744,26 +743,26 @@ static int check_intr_schedule (
 	int		retval = -ENOSPC;
 	u8		mask = 0;
 
-	if (qh-&gt;c_usecs &amp;&amp; uframe &gt;= 6)		/* FSTN territory? */
+	if (qh-&gt;ps.c_usecs &amp;&amp; uframe &gt;= 6)	/* FSTN territory? */
 		goto done;
 
-	if (!check_period (ehci, frame, uframe, qh-&gt;period, qh-&gt;usecs))
+	if (!check_period(ehci, frame, uframe, qh-&gt;ps.period, qh-&gt;ps.usecs))
 		goto done;
-	if (!qh-&gt;c_usecs) {
+	if (!qh-&gt;ps.c_usecs) {
 		retval = 0;
 		*c_maskp = 0;
 		goto done;
 	}
 
 #ifdef CONFIG_USB_EHCI_TT_NEWSCHED
-	if (tt_available (ehci, qh-&gt;period, qh-&gt;dev, frame, uframe,
-				qh-&gt;tt_usecs)) {
+	if (tt_available(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, uframe,
+				qh-&gt;ps.tt_usecs)) {
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
 		for (i = uframe+2; i &lt; 8 &amp;&amp; i &lt;= uframe+4; i++)
-			if (!check_period (ehci, frame, i,
-						qh-&gt;period, qh-&gt;c_usecs))
+			if (!check_period(ehci, frame, i,
+					qh-&gt;ps.period, qh-&gt;ps.c_usecs))
 				goto done;
 			else
 				mask |= 1 &lt;&lt; i;
@@ -784,12 +783,12 @@ static int check_intr_schedule (
 	*c_maskp = cpu_to_hc32(ehci, mask &lt;&lt; 8);
 
 	mask |= 1 &lt;&lt; uframe;
-	if (tt_no_collision (ehci, qh-&gt;period, qh-&gt;dev, frame, mask)) {
-		if (!check_period (ehci, frame, uframe + qh-&gt;gap_uf + 1,
-					qh-&gt;period, qh-&gt;c_usecs))
+	if (tt_no_collision(ehci, qh-&gt;ps.period, qh-&gt;ps.udev, frame, mask)) {
+		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf + 1,
+				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
 			goto done;
-		if (!check_period (ehci, frame, uframe + qh-&gt;gap_uf,
-					qh-&gt;period, qh-&gt;c_usecs))
+		if (!check_period(ehci, frame, uframe + qh-&gt;gap_uf,
+				qh-&gt;ps.period, qh-&gt;ps.c_usecs))
 			goto done;
 		retval = 0;
 	}
@@ -810,7 +809,7 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
-	frame = qh-&gt;start;
+	frame = qh-&gt;ps.phase;
 
 	/* reuse the previous schedule slots, if we can */
 	if (frame != NO_FRAME) {
@@ -828,11 +827,11 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 */
 	if (status) {
 		/* "normal" case, uframing flexible except with splits */
-		if (qh-&gt;period) {
+		if (qh-&gt;ps.period) {
 			int		i;
 
-			for (i = qh-&gt;period; status &amp;&amp; i &gt; 0; --i) {
-				frame = ++ehci-&gt;random_frame % qh-&gt;period;
+			for (i = qh-&gt;ps.period; status &amp;&amp; i &gt; 0; --i) {
+				frame = ++ehci-&gt;random_frame % qh-&gt;ps.period;
 				for (uframe = 0; uframe &lt; 8; uframe++) {
 					status = check_intr_schedule (ehci,
 							frame, uframe, qh,
@@ -842,18 +841,18 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 				}
 			}
 
-		/* qh-&gt;period == 0 means every uframe */
+		/* qh-&gt;ps.period == 0 means every uframe */
 		} else {
 			frame = 0;
 			status = check_intr_schedule (ehci, 0, 0, qh, &amp;c_mask);
 		}
 		if (status)
 			goto done;
-		qh-&gt;start = frame;
+		qh-&gt;ps.phase = frame;
 
 		/* reset S-frame and (maybe) C-frame masks */
 		hw-&gt;hw_info2 &amp;= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));
-		hw-&gt;hw_info2 |= qh-&gt;period
+		hw-&gt;hw_info2 |= qh-&gt;ps.period
 			? cpu_to_hc32(ehci, 1 &lt;&lt; uframe)
 			: cpu_to_hc32(ehci, QH_SMASK);
 		hw-&gt;hw_info2 |= c_mask;
@@ -978,25 +977,24 @@ static void
 iso_stream_init (
 	struct ehci_hcd		*ehci,
 	struct ehci_iso_stream	*stream,
-	struct usb_device	*dev,
-	int			pipe,
-	unsigned		interval
+	struct urb		*urb
 )
 {
 	static const u8 smask_out [] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };
 
+	struct usb_device	*dev = urb-&gt;dev;
+	unsigned		interval = urb-&gt;interval;
 	u32			buf1;
 	unsigned		epnum, maxp;
 	int			is_input;
-	long			bandwidth;
 
 	/*
 	 * this might be a "high bandwidth" highspeed endpoint,
 	 * as encoded in the ep descriptor's wMaxPacket field
 	 */
-	epnum = usb_pipeendpoint (pipe);
-	is_input = usb_pipein (pipe) ? USB_DIR_IN : 0;
-	maxp = usb_maxpacket(dev, pipe, !is_input);
+	epnum = usb_pipeendpoint(urb-&gt;pipe);
+	is_input = usb_pipein(urb-&gt;pipe) ? USB_DIR_IN : 0;
+	maxp = usb_endpoint_maxp(&amp;urb-&gt;ep-&gt;desc);
 	if (is_input) {
 		buf1 = (1 &lt;&lt; 11);
 	} else {
@@ -1020,9 +1018,11 @@ iso_stream_init (
 		/* usbfs wants to report the average usecs per frame tied up
 		 * when transfers on this endpoint are scheduled ...
 		 */
-		stream-&gt;usecs = HS_USECS_ISO (maxp);
-		bandwidth = stream-&gt;usecs * 8;
-		bandwidth /= interval;
+		stream-&gt;ps.usecs = HS_USECS_ISO(maxp);
+
+		stream-&gt;bandwidth = stream-&gt;ps.usecs * 8 / interval;
+		stream-&gt;uperiod = interval;
+		stream-&gt;ps.period = interval &gt;&gt; 3;
 
 	} else {
 		u32		addr;
@@ -1036,17 +1036,17 @@ iso_stream_init (
 			addr |= dev-&gt;tt-&gt;hub-&gt;devnum &lt;&lt; 16;
 		addr |= epnum &lt;&lt; 8;
 		addr |= dev-&gt;devnum;
-		stream-&gt;usecs = HS_USECS_ISO (maxp);
+		stream-&gt;ps.usecs = HS_USECS_ISO(maxp);
 		think_time = dev-&gt;tt ? dev-&gt;tt-&gt;think_time : 0;
-		stream-&gt;tt_usecs = NS_TO_US (think_time + usb_calc_bus_time (
+		stream-&gt;ps.tt_usecs = NS_TO_US(think_time + usb_calc_bus_time(
 				dev-&gt;speed, is_input, 1, maxp));
 		hs_transfers = max (1u, (maxp + 187) / 188);
 		if (is_input) {
 			u32	tmp;
 
 			addr |= 1 &lt;&lt; 31;
-			stream-&gt;c_usecs = stream-&gt;usecs;
-			stream-&gt;usecs = HS_USECS_ISO (1);
+			stream-&gt;ps.c_usecs = stream-&gt;ps.usecs;
+			stream-&gt;ps.usecs = HS_USECS_ISO(1);
 			stream-&gt;raw_mask = 1;
 
 			/* c-mask as specified in USB 2.0 11.18.4 3.c */
@@ -1054,18 +1054,20 @@ iso_stream_init (
 			stream-&gt;raw_mask |= tmp &lt;&lt; (8 + 2);
 		} else
 			stream-&gt;raw_mask = smask_out [hs_transfers - 1];
-		bandwidth = stream-&gt;usecs + stream-&gt;c_usecs;
-		bandwidth /= interval;
+
+		stream-&gt;bandwidth = (stream-&gt;ps.usecs + stream-&gt;ps.c_usecs) /
+				interval;
+		stream-&gt;uperiod = interval &lt;&lt; 3;
+		stream-&gt;ps.period = interval;
 
 		/* stream-&gt;splits gets created from raw_mask later */
 		stream-&gt;address = cpu_to_hc32(ehci, addr);
 	}
-	stream-&gt;bandwidth = bandwidth;
 
-	stream-&gt;udev = dev;
+	stream-&gt;ps.udev = dev;
+	stream-&gt;ps.ep = urb-&gt;ep;
 
 	stream-&gt;bEndpointAddress = is_input | epnum;
-	stream-&gt;interval = interval;
 	stream-&gt;maxp = maxp;
 }
 
@@ -1090,9 +1092,7 @@ iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 		stream = iso_stream_alloc(GFP_ATOMIC);
 		if (likely (stream != NULL)) {
 			ep-&gt;hcpriv = stream;
-			stream-&gt;ep = ep;
-			iso_stream_init(ehci, stream, urb-&gt;dev, urb-&gt;pipe,
-					urb-&gt;interval);
+			iso_stream_init(ehci, stream, urb);
 		}
 
 	/* if dev-&gt;ep [epnum] is a QH, hw is set */
@@ -1137,7 +1137,7 @@ itd_sched_init(
 	dma_addr_t	dma = urb-&gt;transfer_dma;
 
 	/* how many uframes are needed for these transfers */
-	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;interval;
+	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;uperiod;
 
 	/* figure out per-uframe itd fields that we'll need later
 	 * when we fit new itds into the schedule.
@@ -1304,14 +1304,14 @@ sitd_slot_ok (
 	 */
 	uf = uframe &amp; 7;
 	if (!tt_available(ehci, period_uframes &gt;&gt; 3,
-			stream-&gt;udev, frame, uf, stream-&gt;tt_usecs))
+			stream-&gt;ps.udev, frame, uf, stream-&gt;ps.tt_usecs))
 		return 0;
 #else
 	/* tt must be idle for start(s), any gap, and csplit.
 	 * assume scheduling slop leaves 10+% for control/bulk.
 	 */
 	if (!tt_no_collision(ehci, period_uframes &gt;&gt; 3,
-			stream-&gt;udev, frame, mask))
+			stream-&gt;ps.udev, frame, mask))
 		return 0;
 #endif
 
@@ -1325,16 +1325,17 @@ sitd_slot_ok (
 		uf = uframe &amp; 7;
 
 		/* check starts (OUT uses more than one) */
-		max_used = ehci-&gt;uframe_periodic_max - stream-&gt;usecs;
+		max_used = ehci-&gt;uframe_periodic_max - stream-&gt;ps.usecs;
 		for (tmp = stream-&gt;raw_mask &amp; 0xff; tmp; tmp &gt;&gt;= 1, uf++) {
 			if (periodic_usecs (ehci, frame, uf) &gt; max_used)
 				return 0;
 		}
 
 		/* for IN, check CSPLIT */
-		if (stream-&gt;c_usecs) {
+		if (stream-&gt;ps.c_usecs) {
 			uf = uframe &amp; 7;
-			max_used = ehci-&gt;uframe_periodic_max - stream-&gt;c_usecs;
+			max_used = ehci-&gt;uframe_periodic_max -
+					stream-&gt;ps.c_usecs;
 			do {
 				tmp = 1 &lt;&lt; uf;
 				tmp &lt;&lt;= 8;
@@ -1428,7 +1429,7 @@ iso_stream_schedule (
 			/* check schedule: enough space? */
 			if (stream-&gt;highspeed) {
 				if (itd_slot_ok(ehci, mod, start,
-						stream-&gt;usecs, period))
+						stream-&gt;ps.usecs, period))
 					done = 1;
 			} else {
 				if ((start % 8) &gt;= 6)
@@ -1668,7 +1669,7 @@ static void itd_link_urb(
 
 		itd_patch(ehci, itd, iso_sched, packet, uframe);
 
-		next_uframe += stream-&gt;interval;
+		next_uframe += stream-&gt;uperiod;
 		next_uframe &amp;= mod - 1;
 		packet++;
 
@@ -1808,9 +1809,9 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		ehci_dbg (ehci, "can't get iso stream\n");
 		return -ENOMEM;
 	}
-	if (unlikely (urb-&gt;interval != stream-&gt;interval)) {
+	if (unlikely(urb-&gt;interval != stream-&gt;uperiod)) {
 		ehci_dbg (ehci, "can't change iso interval %d --&gt; %d\n",
-			stream-&gt;interval, urb-&gt;interval);
+			stream-&gt;uperiod, urb-&gt;interval);
 		goto done;
 	}
 
@@ -1875,7 +1876,7 @@ sitd_sched_init(
 	dma_addr_t	dma = urb-&gt;transfer_dma;
 
 	/* how many frames are needed for these transfers */
-	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;interval;
+	iso_sched-&gt;span = urb-&gt;number_of_packets * stream-&gt;ps.period;
 
 	/* figure out per-frame sitd fields that we'll need later
 	 * when we fit new sitds into the schedule.
@@ -2069,7 +2070,7 @@ static void sitd_link_urb(
 		sitd_link(ehci, (next_uframe &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1),
 				sitd);
 
-		next_uframe += stream-&gt;interval &lt;&lt; 3;
+		next_uframe += stream-&gt;uperiod;
 	}
 	stream-&gt;next_uframe = next_uframe &amp; (mod - 1);
 
@@ -2188,9 +2189,9 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		ehci_dbg (ehci, "can't get iso stream\n");
 		return -ENOMEM;
 	}
-	if (urb-&gt;interval != stream-&gt;interval) {
+	if (urb-&gt;interval != stream-&gt;ps.period) {
 		ehci_dbg (ehci, "can't change iso interval %d --&gt; %d\n",
-			stream-&gt;interval, urb-&gt;interval);
+			stream-&gt;ps.period, urb-&gt;interval);
 		goto done;
 	}
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index b93eb59bb529..e2b64c40d94f 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -54,6 +54,19 @@ struct ehci_stats {
 	unsigned long		unlink;
 };
 
+/*
+ * Scheduling and budgeting information for periodic transfers, for both
+ * high-speed devices and full/low-speed devices lying behind a TT.
+ */
+struct ehci_per_sched {
+	struct usb_device	*udev;		/* access to the TT */
+	struct usb_host_endpoint *ep;
+	u16			tt_usecs;	/* time on the FS/LS bus */
+	u16			period;		/* actual period in frames */
+	u16			phase;		/* actual phase, frame part */
+	u8			phase_uf;	/* uframe part of the phase */
+	u8			usecs, c_usecs;	/* times on the HS bus */
+};
 #define NO_FRAME	29999			/* frame not assigned yet */
 
 /* ehci_hcd-&gt;lock guards shared data against other CPUs:
@@ -387,6 +400,7 @@ struct ehci_qh {
 	struct list_head	intr_node;	/* list of intr QHs */
 	struct ehci_qtd		*dummy;
 	struct list_head	unlink_node;
+	struct ehci_per_sched	ps;		/* scheduling info */
 
 	unsigned		unlink_cycle;
 
@@ -400,15 +414,8 @@ struct ehci_qh {
 	u8			xacterrs;	/* XactErr retry counter */
 #define	QH_XACTERR_MAX		32		/* XactErr retry limit */
 
-	/* periodic schedule info */
-	u8			usecs;		/* intr bandwidth */
 	u8			gap_uf;		/* uframes split/csplit gap */
-	u8			c_usecs;	/* ... split completion bw */
-	u16			tt_usecs;	/* tt downstream bandwidth */
-	unsigned short		period;		/* polling interval */
-	unsigned short		start;		/* where polling starts */
 
-	struct usb_device	*dev;		/* access to TT */
 	unsigned		is_out:1;	/* bulk or intr OUT */
 	unsigned		clearing_tt:1;	/* Clear-TT-Buf in progress */
 	unsigned		dequeue_during_giveback:1;
@@ -451,20 +458,16 @@ struct ehci_iso_stream {
 	u8			highspeed;
 	struct list_head	td_list;	/* queued itds/sitds */
 	struct list_head	free_list;	/* list of unused itds/sitds */
-	struct usb_device	*udev;
-	struct usb_host_endpoint *ep;
 
 	/* output of (re)scheduling */
+	struct ehci_per_sched	ps;		/* scheduling info */
 	unsigned		next_uframe;
 	__hc32			splits;
 
 	/* the rest is derived from the endpoint descriptor,
-	 * trusting urb-&gt;interval == f(epdesc-&gt;bInterval) and
 	 * including the extra info for hw_bufp[0..2]
 	 */
-	u8			usecs, c_usecs;
-	u16			interval;
-	u16			tt_usecs;
+	u16			uperiod;	/* period in uframes */
 	u16			maxp;
 	u16			raw_mask;
 	unsigned		bandwidth;</pre><hr><pre>commit 91a99b5e78849db90dc2f5e8dfa034af43bdb760
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:52 2013 -0400

    USB: EHCI: use consistent NO_FRAME value
    
    ehci-hcd is inconsistent in the sentinel values it uses to indicate
    that no frame number has been assigned for a periodic transfer.  Some
    places it uses NO_FRAME (defined as 65535), other places it uses -1,
    and elsewhere it uses 9999.
    
    This patch defines a value for NO_FRAME which can fit in a 16-bit
    signed integer, and changes the code to use it everywhere.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1fc2befc4fdc..37e97a70894a 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -813,7 +813,7 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	frame = qh-&gt;start;
 
 	/* reuse the previous schedule slots, if we can */
-	if (frame &lt; qh-&gt;period) {
+	if (frame != NO_FRAME) {
 		uframe = ffs(hc32_to_cpup(ehci, &amp;hw-&gt;hw_info2) &amp; QH_SMASK);
 		status = check_intr_schedule (ehci, frame, --uframe,
 				qh, &amp;c_mask);
@@ -969,7 +969,7 @@ iso_stream_alloc (gfp_t mem_flags)
 	if (likely (stream != NULL)) {
 		INIT_LIST_HEAD(&amp;stream-&gt;td_list);
 		INIT_LIST_HEAD(&amp;stream-&gt;free_list);
-		stream-&gt;next_uframe = -1;
+		stream-&gt;next_uframe = NO_FRAME;
 	}
 	return stream;
 }
@@ -1236,7 +1236,7 @@ itd_urb_transaction (
 
 		memset (itd, 0, sizeof *itd);
 		itd-&gt;itd_dma = itd_dma;
-		itd-&gt;frame = 9999;		/* an invalid value */
+		itd-&gt;frame = NO_FRAME;
 		list_add (&amp;itd-&gt;itd_list, &amp;sched-&gt;td_list);
 	}
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
@@ -1967,7 +1967,7 @@ sitd_urb_transaction (
 
 		memset (sitd, 0, sizeof *sitd);
 		sitd-&gt;sitd_dma = sitd_dma;
-		sitd-&gt;frame = 9999;		/* an invalid value */
+		sitd-&gt;frame = NO_FRAME;
 		list_add (&amp;sitd-&gt;sitd_list, &amp;iso_sched-&gt;td_list);
 	}
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 2d401927e143..b93eb59bb529 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -54,6 +54,8 @@ struct ehci_stats {
 	unsigned long		unlink;
 };
 
+#define NO_FRAME	29999			/* frame not assigned yet */
+
 /* ehci_hcd-&gt;lock guards shared data against other CPUs:
  *   ehci_hcd:	async, unlink, periodic (and shadow), ...
  *   usb_host_endpoint: hcpriv
@@ -405,7 +407,6 @@ struct ehci_qh {
 	u16			tt_usecs;	/* tt downstream bandwidth */
 	unsigned short		period;		/* polling interval */
 	unsigned short		start;		/* where polling starts */
-#define NO_FRAME ((unsigned short)~0)			/* pick new start */
 
 	struct usb_device	*dev;		/* access to TT */
 	unsigned		is_out:1;	/* bulk or intr OUT */
@@ -454,7 +455,7 @@ struct ehci_iso_stream {
 	struct usb_host_endpoint *ep;
 
 	/* output of (re)scheduling */
-	int			next_uframe;
+	unsigned		next_uframe;
 	__hc32			splits;
 
 	/* the rest is derived from the endpoint descriptor,</pre><hr><pre>commit 27c4a31d6739095d613c6e72fb44867bc28c699f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:44 2013 -0400

    USB: EHCI: change toggle only upon successful reset
    
    ehci-hcd uses a value of 0 in an endpoint's toggle flag to indicate
    that the endpoint has been reset (and therefore the Data Toggle bit
    needs to be cleared in the endpoint's QH overlay region).
    
    The toggle flag should be set to 0 only when ehci_endpoint_reset()
    succeeds.  This patch moves the usb_settoggle() call into the
    appropriate branch of the "if" statement.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 3e3ca839e6ce..652018f93632 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1022,7 +1022,6 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	 * the toggle bit in the QH.
 	 */
 	if (qh) {
-		usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
 		} else {
@@ -1030,6 +1029,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
+			usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 			qh-&gt;exception = 1;
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				start_unlink_async(ehci, qh);</pre><hr><pre>commit 8c05dc598e5bc0eb33791de23157cf1e47cb580e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:31 2013 -0400

    USB: EHCI: No SSPLIT allowed in uframe 7
    
    The scheduling code in ehci-hcd contains an error.  For full-speed
    isochronous-OUT transfers, the EHCI spec forbids scheduling
    Start-Split transactions in H-microframe 7, but the driver allows it
    anyway.  This patch adds a check to prevent it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 4b0903c6c616..1fc2befc4fdc 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1286,6 +1286,10 @@ sitd_slot_ok (
 
 	mask = stream-&gt;raw_mask &lt;&lt; (uframe &amp; 7);
 
+	/* for OUT, don't wrap SSPLIT into H-microframe 7 */
+	if (((stream-&gt;raw_mask &amp; 0xff) &lt;&lt; (uframe &amp; 7)) &gt;= (1 &lt;&lt; 7))
+		return 0;
+
 	/* for IN, don't wrap CSPLIT into the next frame */
 	if (mask &amp; ~0xffff)
 		return 0;</pre>
    <div class="pagination">
        <a href='2_31.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><span>[32]</span><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_33.html'>Next&gt;&gt;</a>
    <div>
</body>
