<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_139.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><span>[140]</span>
    </div>
    <hr>
    <pre>commit 014e73c99aa408f3766afe8d11a1caa3a708b736
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 9 17:24:42 2005 -0400

    [PATCH] USB UHCI: subroutine reordering
    
    This patch moves a few subroutines around in the uhci-hcd source file.
    Nothing else is changed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 49bd83ee0c75..8b6c87ef486b 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -90,7 +90,6 @@ static char *errbuf;
 static kmem_cache_t *uhci_up_cachep;	/* urb_priv */
 
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
-static void hc_state_transitions(struct uhci_hcd *uhci);
 
 /* If a transfer is still active after this much time, turn off FSBR */
 #define IDLE_TIMEOUT	msecs_to_jiffies(50)
@@ -105,96 +104,43 @@ static void hc_state_transitions(struct uhci_hcd *uhci);
 #include "uhci-debug.c"
 #include "uhci-q.c"
 
-static int init_stall_timer(struct usb_hcd *hcd);
-
-static void stall_callback(unsigned long ptr)
-{
-	struct usb_hcd *hcd = (struct usb_hcd *)ptr;
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	struct urb_priv *up;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
-	uhci_scan_schedule(uhci, NULL);
-
-	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
-		struct urb *u = up-&gt;urb;
-
-		spin_lock(&amp;u-&gt;lock);
-
-		/* Check if the FSBR timed out */
-		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
-			uhci_fsbr_timeout(uhci, u);
-
-		spin_unlock(&amp;u-&gt;lock);
-	}
-
-	/* Really disable FSBR */
-	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
-		uhci-&gt;fsbrtimeout = 0;
-		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	}
-
-	/* Poll for and perform state transitions */
-	hc_state_transitions(uhci);
-	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
-		uhci_check_ports(uhci);
-
-	init_stall_timer(hcd);
-	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
-}
-
-static int init_stall_timer(struct usb_hcd *hcd)
+static int ports_active(struct uhci_hcd *uhci)
 {
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	unsigned long io_addr = uhci-&gt;io_addr;
+	int connection = 0;
+	int i;
 
-	init_timer(&amp;uhci-&gt;stall_timer);
-	uhci-&gt;stall_timer.function = stall_callback;
-	uhci-&gt;stall_timer.data = (unsigned long)hcd;
-	uhci-&gt;stall_timer.expires = jiffies + msecs_to_jiffies(100);
-	add_timer(&amp;uhci-&gt;stall_timer);
+	for (i = 0; i &lt; uhci-&gt;rh_numports; i++)
+		connection |= (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_CCS);
 
-	return 0;
+	return connection;
 }
 
-static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
+static int suspend_allowed(struct uhci_hcd *uhci)
 {
-	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long io_addr = uhci-&gt;io_addr;
-	unsigned short status;
+	int i;
 
-	/*
-	 * Read the interrupt status, and write it back to clear the
-	 * interrupt cause.  Contrary to the UHCI specification, the
-	 * "HC Halted" status bit is persistent: it is RO, not R/WC.
+	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor != PCI_VENDOR_ID_INTEL)
+		return 1;
+
+	/* Some of Intel's USB controllers have a bug that causes false
+	 * resume indications if any port has an over current condition.
+	 * To prevent problems, we will not allow a global suspend if
+	 * any ports are OC.
+	 *
+	 * Some motherboards using Intel's chipsets (but not using all
+	 * the USB ports) appear to hardwire the over current inputs active
+	 * to disable the USB ports.
 	 */
-	status = inw(io_addr + USBSTS);
-	if (!(status &amp; ~USBSTS_HCH))	/* shared interrupt, not mine */
-		return IRQ_NONE;
-	outw(status, io_addr + USBSTS);		/* Clear it */
 
-	if (status &amp; ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
-		if (status &amp; USBSTS_HSE)
-			dev_err(uhci_dev(uhci), "host system error, "
-					"PCI problems?\n");
-		if (status &amp; USBSTS_HCPE)
-			dev_err(uhci_dev(uhci), "host controller process "
-					"error, something bad happened!\n");
-		if ((status &amp; USBSTS_HCH) &amp;&amp; uhci-&gt;state &gt; 0) {
-			dev_err(uhci_dev(uhci), "host controller halted, "
-					"very bad!\n");
-			/* FIXME: Reset the controller, fix the offending TD */
-		}
+	/* check for over current condition on any port */
+	for (i = 0; i &lt; uhci-&gt;rh_numports; i++) {
+		if (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_OC)
+			return 0;
 	}
 
-	if (status &amp; USBSTS_RD)
-		uhci-&gt;resume_detect = 1;
-
-	spin_lock(&amp;uhci-&gt;lock);
-	uhci_scan_schedule(uhci, regs);
-	spin_unlock(&amp;uhci-&gt;lock);
-
-	return IRQ_HANDLED;
+	return 1;
 }
 
 static void reset_hc(struct uhci_hcd *uhci)
@@ -276,43 +222,46 @@ static void wakeup_hc(struct uhci_hcd *uhci)
 	}
 }
 
-static int ports_active(struct uhci_hcd *uhci)
+static int start_hc(struct uhci_hcd *uhci)
 {
 	unsigned long io_addr = uhci-&gt;io_addr;
-	int connection = 0;
-	int i;
-
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++)
-		connection |= (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_CCS);
+	int timeout = 10;
 
-	return connection;
-}
+	/*
+	 * Reset the HC - this will force us to get a
+	 * new notification of any already connected
+	 * ports due to the virtual disconnect that it
+	 * implies.
+	 */
+	outw(USBCMD_HCRESET, io_addr + USBCMD);
+	while (inw(io_addr + USBCMD) &amp; USBCMD_HCRESET) {
+		if (--timeout &lt; 0) {
+			dev_err(uhci_dev(uhci), "USBCMD_HCRESET timed out!\n");
+			return -ETIMEDOUT;
+		}
+		msleep(1);
+	}
 
-static int suspend_allowed(struct uhci_hcd *uhci)
-{
-	unsigned long io_addr = uhci-&gt;io_addr;
-	int i;
+	/* Mark controller as running before we enable interrupts */
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
 
-	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor != PCI_VENDOR_ID_INTEL)
-		return 1;
+	/* Turn on PIRQ and all interrupts */
+	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
+			USBLEGSUP_DEFAULT);
+	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
+		io_addr + USBINTR);
 
-	/* Some of Intel's USB controllers have a bug that causes false
-	 * resume indications if any port has an over current condition.
-	 * To prevent problems, we will not allow a global suspend if
-	 * any ports are OC.
-	 *
-	 * Some motherboards using Intel's chipsets (but not using all
-	 * the USB ports) appear to hardwire the over current inputs active
-	 * to disable the USB ports.
-	 */
+	/* Start at frame 0 */
+	outw(0, io_addr + USBFRNUM);
+	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
 
-	/* check for over current condition on any port */
-	for (i = 0; i &lt; uhci-&gt;rh_numports; i++) {
-		if (inw(io_addr + USBPORTSC1 + i * 2) &amp; USBPORTSC_OC)
-			return 0;
-	}
+	/* Run and mark it configured with a 64-byte max packet */
+	uhci-&gt;state = UHCI_RUNNING_GRACE;
+	uhci-&gt;state_end = jiffies + HZ;
+	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
+	uhci-&gt;is_stopped = 0;
 
-	return 1;
+	return 0;
 }
 
 static void hc_state_transitions(struct uhci_hcd *uhci)
@@ -353,56 +302,106 @@ static void hc_state_transitions(struct uhci_hcd *uhci)
 	}
 }
 
-/*
- * Store the current frame number in uhci-&gt;frame_number if the controller
- * is runnning
- */
-static void uhci_get_current_frame_number(struct uhci_hcd *uhci)
+static int init_stall_timer(struct usb_hcd *hcd);
+
+static void stall_callback(unsigned long ptr)
 {
-	if (!uhci-&gt;is_stopped)
-		uhci-&gt;frame_number = inw(uhci-&gt;io_addr + USBFRNUM);
+	struct usb_hcd *hcd = (struct usb_hcd *)ptr;
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	struct urb_priv *up;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+	uhci_scan_schedule(uhci, NULL);
+
+	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
+		struct urb *u = up-&gt;urb;
+
+		spin_lock(&amp;u-&gt;lock);
+
+		/* Check if the FSBR timed out */
+		if (up-&gt;fsbr &amp;&amp; !up-&gt;fsbr_timeout &amp;&amp; time_after_eq(jiffies, up-&gt;fsbrtime + IDLE_TIMEOUT))
+			uhci_fsbr_timeout(uhci, u);
+
+		spin_unlock(&amp;u-&gt;lock);
+	}
+
+	/* Really disable FSBR */
+	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
+		uhci-&gt;fsbrtimeout = 0;
+		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	}
+
+	/* Poll for and perform state transitions */
+	hc_state_transitions(uhci);
+	if (unlikely(uhci-&gt;suspended_ports &amp;&amp; uhci-&gt;state != UHCI_SUSPENDED))
+		uhci_check_ports(uhci);
+
+	init_stall_timer(hcd);
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
-static int start_hc(struct uhci_hcd *uhci)
+static int init_stall_timer(struct usb_hcd *hcd)
 {
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+
+	init_timer(&amp;uhci-&gt;stall_timer);
+	uhci-&gt;stall_timer.function = stall_callback;
+	uhci-&gt;stall_timer.data = (unsigned long)hcd;
+	uhci-&gt;stall_timer.expires = jiffies + msecs_to_jiffies(100);
+	add_timer(&amp;uhci-&gt;stall_timer);
+
+	return 0;
+}
+
+static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
+{
+	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long io_addr = uhci-&gt;io_addr;
-	int timeout = 10;
+	unsigned short status;
 
 	/*
-	 * Reset the HC - this will force us to get a
-	 * new notification of any already connected
-	 * ports due to the virtual disconnect that it
-	 * implies.
+	 * Read the interrupt status, and write it back to clear the
+	 * interrupt cause.  Contrary to the UHCI specification, the
+	 * "HC Halted" status bit is persistent: it is RO, not R/WC.
 	 */
-	outw(USBCMD_HCRESET, io_addr + USBCMD);
-	while (inw(io_addr + USBCMD) &amp; USBCMD_HCRESET) {
-		if (--timeout &lt; 0) {
-			dev_err(uhci_dev(uhci), "USBCMD_HCRESET timed out!\n");
-			return -ETIMEDOUT;
+	status = inw(io_addr + USBSTS);
+	if (!(status &amp; ~USBSTS_HCH))	/* shared interrupt, not mine */
+		return IRQ_NONE;
+	outw(status, io_addr + USBSTS);		/* Clear it */
+
+	if (status &amp; ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {
+		if (status &amp; USBSTS_HSE)
+			dev_err(uhci_dev(uhci), "host system error, "
+					"PCI problems?\n");
+		if (status &amp; USBSTS_HCPE)
+			dev_err(uhci_dev(uhci), "host controller process "
+					"error, something bad happened!\n");
+		if ((status &amp; USBSTS_HCH) &amp;&amp; uhci-&gt;state &gt; 0) {
+			dev_err(uhci_dev(uhci), "host controller halted, "
+					"very bad!\n");
+			/* FIXME: Reset the controller, fix the offending TD */
 		}
-		msleep(1);
 	}
 
-	/* Mark controller as running before we enable interrupts */
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
-
-	/* Turn on PIRQ and all interrupts */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
-	outw(USBINTR_TIMEOUT | USBINTR_RESUME | USBINTR_IOC | USBINTR_SP,
-		io_addr + USBINTR);
+	if (status &amp; USBSTS_RD)
+		uhci-&gt;resume_detect = 1;
 
-	/* Start at frame 0 */
-	outw(0, io_addr + USBFRNUM);
-	outl(uhci-&gt;fl-&gt;dma_handle, io_addr + USBFLBASEADD);
+	spin_lock(&amp;uhci-&gt;lock);
+	uhci_scan_schedule(uhci, regs);
+	spin_unlock(&amp;uhci-&gt;lock);
 
-	/* Run and mark it configured with a 64-byte max packet */
-	uhci-&gt;state = UHCI_RUNNING_GRACE;
-	uhci-&gt;state_end = jiffies + HZ;
-	outw(USBCMD_RS | USBCMD_CF | USBCMD_MAXP, io_addr + USBCMD);
-	uhci-&gt;is_stopped = 0;
+	return IRQ_HANDLED;
+}
 
-	return 0;
+/*
+ * Store the current frame number in uhci-&gt;frame_number if the controller
+ * is runnning
+ */
+static void uhci_get_current_frame_number(struct uhci_hcd *uhci)
+{
+	if (!uhci-&gt;is_stopped)
+		uhci-&gt;frame_number = inw(uhci-&gt;io_addr + USBFRNUM);
 }
 
 /*</pre><hr><pre>commit d794ac7ae3613c2abfb678617ac7d74c8ff0099c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 18 12:43:25 2005 -0400

    [PATCH] USB: g_file_storage: export "stall" parameter
    
    This patch changes the g_file_storage driver to make the "stall" module
    parameter generally available; currently it is available only if the
    testing version of the module has been configured.  It also fixes a typo
    in a comment -- thanks, Pat!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 507a24924177..f5ce45c4b2a3 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -81,6 +81,10 @@
  *	removable		Default false, boolean for removable media
  *	luns=N			Default N = number of filenames, number of
  *					LUNs to support
+ *	stall			Default determined according to the type of
+ *					USB device controller (usually true),
+ *					boolean to permit the driver to halt
+ *					bulk endpoints
  *	transport=XXX		Default BBB, transport name (CB, CBI, or BBB)
  *	protocol=YYY		Default SCSI, protocol name (RBC, 8020 or
  *					ATAPI, QIC, UFI, 8070, or SCSI;
@@ -91,14 +95,10 @@
  *	buflen=N		Default N=16384, buffer size used (will be
  *					rounded down to a multiple of
  *					PAGE_CACHE_SIZE)
- *	stall			Default determined according to the type of
- *					USB device controller (usually true),
- *					boolean to permit the driver to halt
- *					bulk endpoints
  *
  * If CONFIG_USB_FILE_STORAGE_TEST is not set, only the "file", "ro",
- * "removable", and "luns" options are available; default values are used
- * for everything else.
+ * "removable", "luns", and "stall" options are available; default values
+ * are used for everything else.
  *
  * The pathnames of the backing files and the ro settings are available in
  * the attribute files "file" and "ro" in the lun&lt;n&gt; subdirectory of the
@@ -342,14 +342,15 @@ static struct {
 	int		num_ros;
 	unsigned int	nluns;
 
+	int		removable;
+	int		can_stall;
+
 	char		*transport_parm;
 	char		*protocol_parm;
-	int		removable;
 	unsigned short	vendor;
 	unsigned short	product;
 	unsigned short	release;
 	unsigned int	buflen;
-	int		can_stall;
 
 	int		transport_type;
 	char		*transport_name;
@@ -360,11 +361,11 @@ static struct {
 	.transport_parm		= "BBB",
 	.protocol_parm		= "SCSI",
 	.removable		= 0,
+	.can_stall		= 1,
 	.vendor			= DRIVER_VENDOR_ID,
 	.product		= DRIVER_PRODUCT_ID,
 	.release		= 0xffff,	// Use controller chip type
 	.buflen			= 16384,
-	.can_stall		= 1,
 	};
 
 
@@ -380,6 +381,9 @@ MODULE_PARM_DESC(luns, "number of LUNs");
 module_param_named(removable, mod_data.removable, bool, S_IRUGO);
 MODULE_PARM_DESC(removable, "true to simulate removable media");
 
+module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
+MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
+
 
 /* In the non-TEST version, only the module parameters listed above
  * are available. */
@@ -404,9 +408,6 @@ MODULE_PARM_DESC(release, "USB release number");
 module_param_named(buflen, mod_data.buflen, uint, S_IRUGO);
 MODULE_PARM_DESC(buflen, "I/O buffer size");
 
-module_param_named(stall, mod_data.can_stall, bool, S_IRUGO);
-MODULE_PARM_DESC(stall, "false to prevent bulk stalls");
-
 #endif /* CONFIG_USB_FILE_STORAGE_TEST */
 
 
@@ -2657,7 +2658,7 @@ static int check_command(struct fsg_dev *fsg, int cmnd_size,
 		}
 	}
 
-	/* Check that the LUN values are oonsistent */
+	/* Check that the LUN values are consistent */
 	if (transport_is_bbb()) {
 		if (fsg-&gt;lun != lun)
 			DBG(fsg, "using LUN %d from CBW, "</pre><hr><pre>commit 76f4af8efc72b6091d230cbe718cedca06d2d79e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 5 11:56:54 2005 -0400

    [PATCH] USB: g_file_storage: Consolidate min()s
    
    This patch simplifies the g_file_storage driver by consolidating a bunch
    of min() calculations at a single spot.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index a9be85103d23..507a24924177 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -1312,7 +1312,7 @@ static int class_setup_req(struct fsg_dev *fsg,
 			}
 			VDBG(fsg, "get max LUN\n");
 			*(u8 *) req-&gt;buf = fsg-&gt;nluns - 1;
-			value = min(w_length, (u16) 1);
+			value = 1;
 			break;
 		}
 	}
@@ -1360,7 +1360,6 @@ static int standard_setup_req(struct fsg_dev *fsg,
 	int			value = -EOPNOTSUPP;
 	u16			w_index = ctrl-&gt;wIndex;
 	u16			w_value = ctrl-&gt;wValue;
-	u16			w_length = ctrl-&gt;wLength;
 
 	/* Usually this just stores reply data in the pre-allocated ep0 buffer,
 	 * but config change events will also reconfigure hardware. */
@@ -1374,7 +1373,7 @@ static int standard_setup_req(struct fsg_dev *fsg,
 
 		case USB_DT_DEVICE:
 			VDBG(fsg, "get device descriptor\n");
-			value = min(w_length, (u16) sizeof device_desc);
+			value = sizeof device_desc;
 			memcpy(req-&gt;buf, &amp;device_desc, value);
 			break;
 #ifdef CONFIG_USB_GADGET_DUALSPEED
@@ -1382,7 +1381,7 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			VDBG(fsg, "get device qualifier\n");
 			if (!fsg-&gt;gadget-&gt;is_dualspeed)
 				break;
-			value = min(w_length, (u16) sizeof dev_qualifier);
+			value = sizeof dev_qualifier;
 			memcpy(req-&gt;buf, &amp;dev_qualifier, value);
 			break;
 
@@ -1401,8 +1400,6 @@ static int standard_setup_req(struct fsg_dev *fsg,
 					req-&gt;buf,
 					w_value &gt;&gt; 8,
 					w_value &amp; 0xff);
-			if (value &gt;= 0)
-				value = min(w_length, (u16) value);
 			break;
 
 		case USB_DT_STRING:
@@ -1411,8 +1408,6 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			/* wIndex == language code */
 			value = usb_gadget_get_string(&amp;stringtab,
 					w_value &amp; 0xff, req-&gt;buf);
-			if (value &gt;= 0)
-				value = min(w_length, (u16) value);
 			break;
 		}
 		break;
@@ -1438,7 +1433,7 @@ static int standard_setup_req(struct fsg_dev *fsg,
 			break;
 		VDBG(fsg, "get configuration\n");
 		*(u8 *) req-&gt;buf = fsg-&gt;config;
-		value = min(w_length, (u16) 1);
+		value = 1;
 		break;
 
 	case USB_REQ_SET_INTERFACE:
@@ -1466,14 +1461,14 @@ static int standard_setup_req(struct fsg_dev *fsg,
 		}
 		VDBG(fsg, "get interface\n");
 		*(u8 *) req-&gt;buf = 0;
-		value = min(w_length, (u16) 1);
+		value = 1;
 		break;
 
 	default:
 		VDBG(fsg,
 			"unknown control req %02x.%02x v%04x i%04x l%u\n",
 			ctrl-&gt;bRequestType, ctrl-&gt;bRequest,
-			w_value, w_index, w_length);
+			w_value, w_index, ctrl-&gt;wLength);
 	}
 
 	return value;
@@ -1485,6 +1480,7 @@ static int fsg_setup(struct usb_gadget *gadget,
 {
 	struct fsg_dev		*fsg = get_gadget_data(gadget);
 	int			rc;
+	int			w_length = ctrl-&gt;wLength;
 
 	++fsg-&gt;ep0_req_tag;		// Record arrival of a new request
 	fsg-&gt;ep0req-&gt;context = NULL;
@@ -1498,8 +1494,9 @@ static int fsg_setup(struct usb_gadget *gadget,
 
 	/* Respond with data/status or defer until later? */
 	if (rc &gt;= 0 &amp;&amp; rc != DELAYED_STATUS) {
+		rc = min(rc, w_length);
 		fsg-&gt;ep0req-&gt;length = rc;
-		fsg-&gt;ep0req-&gt;zero = (rc &lt; ctrl-&gt;wLength &amp;&amp;
+		fsg-&gt;ep0req-&gt;zero = (rc &lt; w_length &amp;&amp;
 				(rc % gadget-&gt;ep0-&gt;maxpacket) == 0);
 		fsg-&gt;ep0req_name = (ctrl-&gt;bRequestType &amp; USB_DIR_IN ?
 				"ep0-in" : "ep0-out");</pre><hr><pre>commit f409661877a25d11c2495bcd879807f17c286684
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 6 15:41:08 2005 -0400

    [PATCH] usbcore: Don't call device_release_driver recursively
    
    This patch fixes usb_driver_release_interface() to make it avoid calling
    device_release_driver() recursively, i.e., when invoked from within the
    disconnect routine for the same device.  The patch applies to your
    "driver" tree.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 66678763c24d..a3c42203213a 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -322,9 +322,15 @@ void usb_driver_release_interface(struct usb_driver *driver,
 	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
 		return;
 
-	/* don't disconnect from disconnect(), or before dev_add() */
-	if (!klist_node_attached(&amp;dev-&gt;knode_driver) &amp;&amp; !klist_node_attached(&amp;dev-&gt;knode_bus))
+	/* don't release from within disconnect() */
+	if (iface-&gt;condition != USB_INTERFACE_BOUND)
+		return;
+
+	/* release only after device_add() */
+	if (klist_node_attached(&amp;dev-&gt;knode_bus)) {
+		iface-&gt;condition = USB_INTERFACE_UNBINDING;
 		device_release_driver(dev);
+	}
 
 	dev-&gt;driver = NULL;
 	usb_set_intfdata(iface, NULL);</pre><hr><pre>commit c95a6b057b108c2b7add35cba1354f9af921349e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 6 15:38:33 2005 -0400

    [PATCH] driver core: Fix races in driver_detach()
    
    This patch is intended for your "driver" tree.  It fixes several subtle
    races in driver_detach() and device_release_driver() in the driver-model
    core.
    
    The major change is to use klist_remove() rather than klist_del() when
    taking a device off its driver's list.  There's no other way to guarantee
    that the list pointers will be updated before some other driver binds to
    the device.  For this to work driver_detach() can't use a klist iterator,
    so the loop over the devices must be written out in full.  In addition the
    patch protects against the possibility that, when a driver and a device
    are unregistered at the same time, one may be unloaded from memory before
    the other is finished using it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 8510918109e0..eab2030c506d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -177,41 +177,66 @@ void driver_attach(struct device_driver * drv)
  *	@dev:	device.
  *
  *	Manually detach device from driver.
- *	Note that this is called without incrementing the bus
- *	reference count nor taking the bus's rwsem. Be sure that
- *	those are accounted for before calling this function.
+ *
+ *	__device_release_driver() must be called with @dev-&gt;sem held.
  */
-void device_release_driver(struct device * dev)
+
+static void __device_release_driver(struct device * dev)
 {
 	struct device_driver * drv;
 
-	down(&amp;dev-&gt;sem);
-	if (dev-&gt;driver) {
-		drv = dev-&gt;driver;
+	drv = dev-&gt;driver;
+	if (drv) {
+		get_driver(drv);
 		sysfs_remove_link(&amp;drv-&gt;kobj, kobject_name(&amp;dev-&gt;kobj));
 		sysfs_remove_link(&amp;dev-&gt;kobj, "driver");
-		klist_del(&amp;dev-&gt;knode_driver);
+		klist_remove(&amp;dev-&gt;knode_driver);
 
 		if (drv-&gt;remove)
 			drv-&gt;remove(dev);
 		dev-&gt;driver = NULL;
+		put_driver(drv);
 	}
-	up(&amp;dev-&gt;sem);
 }
 
-static int __remove_driver(struct device * dev, void * unused)
+void device_release_driver(struct device * dev)
 {
-	device_release_driver(dev);
-	return 0;
+	/*
+	 * If anyone calls device_release_driver() recursively from
+	 * within their -&gt;remove callback for the same device, they
+	 * will deadlock right here.
+	 */
+	down(&amp;dev-&gt;sem);
+	__device_release_driver(dev);
+	up(&amp;dev-&gt;sem);
 }
 
+
 /**
  * driver_detach - detach driver from all devices it controls.
  * @drv: driver.
  */
 void driver_detach(struct device_driver * drv)
 {
-	driver_for_each_device(drv, NULL, NULL, __remove_driver);
+	struct device * dev;
+
+	for (;;) {
+		spin_lock_irq(&amp;drv-&gt;klist_devices.k_lock);
+		if (list_empty(&amp;drv-&gt;klist_devices.k_list)) {
+			spin_unlock_irq(&amp;drv-&gt;klist_devices.k_lock);
+			break;
+		}
+		dev = list_entry(drv-&gt;klist_devices.k_list.prev,
+				struct device, knode_driver.n_node);
+		get_device(dev);
+		spin_unlock_irq(&amp;drv-&gt;klist_devices.k_lock);
+
+		down(&amp;dev-&gt;sem);
+		if (dev-&gt;driver == drv)
+			__device_release_driver(dev);
+		up(&amp;dev-&gt;sem);
+		put_device(dev);
+	}
 }
 
 </pre><hr><pre>commit 8835f6657316162a8937d3f26ccd8f5886ba3845
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 18 17:39:30 2005 -0700

    [PATCH] USB: USB API documentation modification
    
    In response to complaints about excessive latency in the uhci-hcd driver
    I'm planning to convert it to a top-half/bottom-half design.  It turns out
    that to do this, the USB API has to be modified slightly since the driver
    will not be able to meet one of the guarantees in the current API.  This
    patch changes some kerneldoc, specifying the weaker guarantee.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index dc838f81742c..16972159a57a 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -420,12 +420,16 @@ int usb_submit_urb(struct urb *urb, int mem_flags)
  *
  * Host Controller Drivers (HCDs) place all the URBs for a particular
  * endpoint in a queue.  Normally the queue advances as the controller
- * hardware processes each request.  But when an URB terminates with any
- * fault (such as an error, or being unlinked) its queue stops, at least
- * until that URB's completion routine returns.  It is guaranteed that
- * the queue will not restart until all its unlinked URBs have been fully
- * retired, with their completion routines run, even if that's not until
- * some time after the original completion handler returns.
+ * hardware processes each request.  But when an URB terminates with an
+ * error its queue stops, at least until that URB's completion routine
+ * returns.  It is guaranteed that the queue will not restart until all
+ * its unlinked URBs have been fully retired, with their completion
+ * routines run, even if that's not until some time after the original
+ * completion handler returns.  Normally the same behavior and guarantees
+ * apply when an URB terminates because it was unlinked; however if an
+ * URB is unlinked before the hardware has started to execute it, then
+ * its queue is not guaranteed to stop until all the preceding URBs have
+ * completed.
  *
  * This means that USB device drivers can safely build deep queues for
  * large or complex transfers, and clean them up reliably after any sort</pre>
    <div class="pagination">
        <a href='2_139.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><span>[140]</span>
    <div>
</body>
