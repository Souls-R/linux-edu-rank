<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_44.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><span>[45]</span><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_46.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6d34ac199a4af5c678a3a8f3275aeb2586b72da3
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri May 11 16:09:32 2007 -0400

    locks: make posix_test_lock() interface more consistent
    
    Since posix_test_lock(), like fcntl() and -&gt;lock(), indicates absence or
    presence of a conflict lock by setting fl_type to, respectively, F_UNLCK
    or something other than F_UNLCK, the return value is no longer needed.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 4c73b857dded..4a8072736efa 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -659,7 +659,7 @@ static int locks_block_on_timeout(struct file_lock *blocker, struct file_lock *w
 	return result;
 }
 
-int
+void
 posix_test_lock(struct file *filp, struct file_lock *fl)
 {
 	struct file_lock *cfl;
@@ -671,14 +671,12 @@ posix_test_lock(struct file *filp, struct file_lock *fl)
 		if (posix_locks_conflict(cfl, fl))
 			break;
 	}
-	if (cfl) {
+	if (cfl)
 		__locks_copy_lock(fl, cfl);
-		unlock_kernel();
-		return 1;
-	} else
+	else
 		fl-&gt;fl_type = F_UNLCK;
 	unlock_kernel();
-	return 0;
+	return;
 }
 
 EXPORT_SYMBOL(posix_test_lock);
diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index 13ac6fa2b62b..c87dc713b5d7 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -402,7 +402,9 @@ static int do_getlk(struct file *filp, int cmd, struct file_lock *fl)
 
 	lock_kernel();
 	/* Try local locking first */
-	if (posix_test_lock(filp, fl)) {
+	posix_test_lock(filp, fl);
+	if (fl-&gt;fl_type != F_UNLCK) {
+		/* found a conflict */
 		goto out;
 	}
 
diff --git a/include/linux/fs.h b/include/linux/fs.h
index b188c2e5338d..80deaaf1b746 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -862,7 +862,7 @@ extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
-extern int posix_test_lock(struct file *, struct file_lock *);
+extern void posix_test_lock(struct file *, struct file_lock *);
 extern int posix_lock_file(struct file *, struct file_lock *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);</pre><hr><pre>commit 370f6599e8bc03fd9fc6d1a1be00ae0c6373ca59
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jun 8 15:23:34 2007 -0400

    nfs: disable leases over NFS
    
    As Peter Staubach says elsewhere
    (http://marc.info/?l=linux-kernel&amp;m=118113649526444&amp;w=2):
    
    &gt; The problem is that some file system such as NFSv2 and NFSv3 do
    &gt; not have sufficient support to be able to support leases correctly.
    &gt; In particular for these two file systems, there is no over the wire
    &gt; protocol support.
    &gt;
    &gt; Currently, these two file systems fail the fcntl(F_SETLEASE) call
    &gt; accidentally, due to a reference counting difference.  These file
    &gt; systems should fail more consciously, with a proper error to
    &gt; indicate that the call is invalid for them.
    
    Define an nfs setlease method that just returns -EINVAL.
    
    If someone can demonstrate a real need, perhaps we could reenable
    them in the presence of the "nolock" mount option.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Cc: Peter Staubach &lt;staubach@redhat.com&gt;
    Cc: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index 8689b736fdd9..13ac6fa2b62b 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -53,6 +53,7 @@ static int  nfs_fsync(struct file *, struct dentry *dentry, int datasync);
 static int nfs_check_flags(int flags);
 static int nfs_lock(struct file *filp, int cmd, struct file_lock *fl);
 static int nfs_flock(struct file *filp, int cmd, struct file_lock *fl);
+static int nfs_setlease(struct file *file, long arg, struct file_lock **fl);
 
 const struct file_operations nfs_file_operations = {
 	.llseek		= nfs_file_llseek,
@@ -69,6 +70,7 @@ const struct file_operations nfs_file_operations = {
 	.flock		= nfs_flock,
 	.splice_read	= nfs_file_splice_read,
 	.check_flags	= nfs_check_flags,
+	.setlease	= nfs_setlease,
 };
 
 const struct inode_operations nfs_file_inode_operations = {
@@ -558,3 +560,13 @@ static int nfs_flock(struct file *filp, int cmd, struct file_lock *fl)
 		return do_unlk(filp, cmd, fl);
 	return do_setlk(filp, cmd, fl);
 }
+
+static int nfs_setlease(struct file *file, long arg, struct file_lock **fl)
+{
+	/*
+	 * There is no protocol support for leases, so we have no way
+	 * to implement them correctly in the face of opens by other
+	 * clients.
+	 */
+	return -EINVAL;
+}</pre><hr><pre>commit 4698afe8e3a725576366f86560a8a8242b21b9f7
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jul 4 17:21:37 2007 -0400

    locks: export setlease to filesystems
    
    Export setlease so it can used by filesystems to implement their lease
    methods.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 94f5d8065e3a..4c73b857dded 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1336,7 +1336,7 @@ int fcntl_getlease(struct file *filp)
  *
  *	Called with kernel lock held.
  */
-static int setlease(struct file *filp, long arg, struct file_lock **flp)
+int setlease(struct file *filp, long arg, struct file_lock **flp)
 {
 	struct file_lock *fl, **before, **my_before = NULL, *lease;
 	struct dentry *dentry = filp-&gt;f_path.dentry;
@@ -1421,6 +1421,7 @@ static int setlease(struct file *filp, long arg, struct file_lock **flp)
 out:
 	return error;
 }
+EXPORT_SYMBOL(setlease);
 
  /**
  *	vfs_setlease        -       sets a lease on an open file
diff --git a/include/linux/fs.h b/include/linux/fs.h
index c8ddf34e9710..b188c2e5338d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -872,6 +872,7 @@ extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
+extern int setlease(struct file *, long, struct file_lock **);
 extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);</pre><hr><pre>commit a9933cea7a1d80dd9efae9f1acd857f5dce742b9
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Jun 7 17:09:49 2007 -0400

    locks: rename lease functions to reflect locks.c conventions
    
    We've been using the convention that vfs_foo is the function that calls
    a filesystem-specific foo method if it exists, or falls back on a
    generic method if it doesn't; thus vfs_foo is what is called when some
    other part of the kernel (normally lockd or nfsd) wants to get a lock,
    whereas foo is what filesystems call to use the underlying local
    functionality as part of their lock implementation.
    
    So rename setlease to vfs_setlease (which will call a
    filesystem-specific setlease after a later patch) and __setlease to
    setlease.
    
    Also, vfs_setlease need only be GPL-exported as long as it's only needed
    by lockd and nfsd.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 0e5873b0be54..a65d85c1fdc2 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1326,7 +1326,7 @@ int fcntl_getlease(struct file *filp)
 }
 
 /**
- *	__setlease	-	sets a lease on an open file
+ *	setlease	-	sets a lease on an open file
  *	@filp: file pointer
  *	@arg: type of lease to obtain
  *	@flp: input - file_lock to use, output - file_lock inserted
@@ -1336,7 +1336,7 @@ int fcntl_getlease(struct file *filp)
  *
  *	Called with kernel lock held.
  */
-static int __setlease(struct file *filp, long arg, struct file_lock **flp)
+static int setlease(struct file *filp, long arg, struct file_lock **flp)
 {
 	struct file_lock *fl, **before, **my_before = NULL, *lease;
 	struct dentry *dentry = filp-&gt;f_path.dentry;
@@ -1423,7 +1423,7 @@ static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 }
 
  /**
- *	setlease        -       sets a lease on an open file
+ *	vfs_setlease        -       sets a lease on an open file
  *	@filp: file pointer
  *	@arg: type of lease to obtain
  *	@lease: file_lock to use
@@ -1432,18 +1432,17 @@ static int __setlease(struct file *filp, long arg, struct file_lock **flp)
  *	The fl_lmops fl_break function is required by break_lease
  */
 
-int setlease(struct file *filp, long arg, struct file_lock **lease)
+int vfs_setlease(struct file *filp, long arg, struct file_lock **lease)
 {
 	int error;
 
 	lock_kernel();
-	error = __setlease(filp, arg, lease);
+	error = setlease(filp, arg, lease);
 	unlock_kernel();
 
 	return error;
 }
-
-EXPORT_SYMBOL(setlease);
+EXPORT_SYMBOL_GPL(vfs_setlease);
 
 /**
  *	fcntl_setlease	-	sets a lease on an open file
@@ -1469,7 +1468,7 @@ int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
 
 	lock_kernel();
 
-	error = __setlease(filp, arg, &amp;flp);
+	error = vfs_setlease(filp, arg, &amp;flp);
 	if (error || arg == F_UNLCK)
 		goto out_unlock;
 
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index e4a4c87ec8c6..6284807bd37e 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -256,7 +256,7 @@ nfs4_close_delegation(struct nfs4_delegation *dp)
 	/* The following nfsd_close may not actually close the file,
 	 * but we want to remove the lease in any case. */
 	if (dp-&gt;dl_flock)
-		setlease(filp, F_UNLCK, &amp;dp-&gt;dl_flock);
+		vfs_setlease(filp, F_UNLCK, &amp;dp-&gt;dl_flock);
 	nfsd_close(filp);
 }
 
@@ -1402,7 +1402,7 @@ void nfsd_release_deleg_cb(struct file_lock *fl)
 /*
  * Set the delegation file_lock back pointer.
  *
- * Called from __setlease() with lock_kernel() held.
+ * Called from setlease() with lock_kernel() held.
  */
 static
 void nfsd_copy_lock_deleg_cb(struct file_lock *new, struct file_lock *fl)
@@ -1416,7 +1416,7 @@ void nfsd_copy_lock_deleg_cb(struct file_lock *new, struct file_lock *fl)
 }
 
 /*
- * Called from __setlease() with lock_kernel() held
+ * Called from setlease() with lock_kernel() held
  */
 static
 int nfsd_same_client_deleg_cb(struct file_lock *onlist, struct file_lock *try)
@@ -1716,10 +1716,10 @@ nfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open, struct nfs4_sta
 	fl.fl_file = stp-&gt;st_vfs_file;
 	fl.fl_pid = current-&gt;tgid;
 
-	/* setlease checks to see if delegation should be handed out.
+	/* vfs_setlease checks to see if delegation should be handed out.
 	 * the lock_manager callbacks fl_mylease and fl_change are used
 	 */
-	if ((status = setlease(stp-&gt;st_vfs_file,
+	if ((status = vfs_setlease(stp-&gt;st_vfs_file,
 		flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK, &amp;flp))) {
 		dprintk("NFSD: setlease failed [%d], no delegation\n", status);
 		unhash_delegation(dp);
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 98205f680476..a24f029accc0 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -872,7 +872,7 @@ extern int vfs_cancel_lock(struct file *filp, struct file_lock *fl);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);
-extern int setlease(struct file *, long, struct file_lock **);
+extern int vfs_setlease(struct file *, long, struct file_lock **);
 extern int lease_modify(struct file_lock **, int);
 extern int lock_may_read(struct inode *, loff_t start, unsigned long count);
 extern int lock_may_write(struct inode *, loff_t start, unsigned long count);</pre><hr><pre>commit 6d5e8b05caf074ae5676ad9aaf92e381226a14a7
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu May 31 17:03:46 2007 -0400

    locks: share more common lease code
    
    Share more code between setlease (used by nfsd) and fcntl.
    
    Also some minor cleanup.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by: Christoph Hellwig &lt;hch@infradead.org&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 838ca542c556..0e5873b0be54 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1343,6 +1343,14 @@ static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 	struct inode *inode = dentry-&gt;d_inode;
 	int error, rdlease_count = 0, wrlease_count = 0;
 
+	if ((current-&gt;fsuid != inode-&gt;i_uid) &amp;&amp; !capable(CAP_LEASE))
+		return -EACCES;
+	if (!S_ISREG(inode-&gt;i_mode))
+		return -EINVAL;
+	error = security_file_lock(filp, arg);
+	if (error)
+		return error;
+
 	time_out_leases(inode);
 
 	BUG_ON(!(*flp)-&gt;fl_lmops-&gt;fl_break);
@@ -1426,18 +1434,8 @@ static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 
 int setlease(struct file *filp, long arg, struct file_lock **lease)
 {
-	struct dentry *dentry = filp-&gt;f_path.dentry;
-	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
-	if ((current-&gt;fsuid != inode-&gt;i_uid) &amp;&amp; !capable(CAP_LEASE))
-		return -EACCES;
-	if (!S_ISREG(inode-&gt;i_mode))
-		return -EINVAL;
-	error = security_file_lock(filp, arg);
-	if (error)
-		return error;
-
 	lock_kernel();
 	error = __setlease(filp, arg, lease);
 	unlock_kernel();
@@ -1464,14 +1462,6 @@ int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
 	struct inode *inode = dentry-&gt;d_inode;
 	int error;
 
-	if ((current-&gt;fsuid != inode-&gt;i_uid) &amp;&amp; !capable(CAP_LEASE))
-		return -EACCES;
-	if (!S_ISREG(inode-&gt;i_mode))
-		return -EINVAL;
-	error = security_file_lock(filp, arg);
-	if (error)
-		return error;
-
 	locks_init_lock(&amp;fl);
 	error = lease_init(filp, arg, &amp;fl);
 	if (error)
@@ -1485,9 +1475,9 @@ int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
 
 	error = fasync_helper(fd, filp, 1, &amp;flp-&gt;fl_fasync);
 	if (error &lt; 0) {
-		/* remove lease just inserted by __setlease */
+		/* remove lease just inserted by setlease */
 		flp-&gt;fl_type = F_UNLCK | F_INPROGRESS;
-		flp-&gt;fl_break_time = jiffies- 10;
+		flp-&gt;fl_break_time = jiffies - 10;
 		time_out_leases(inode);
 		goto out_unlock;
 	}</pre><hr><pre>commit e32b8ee27b486f682a6d13533cfe6549c8abcdef
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Mar 1 14:34:35 2007 -0500

    locks: clean up lease_alloc()
    
    Return the newly allocated structure as the return value instead of
    using a struct ** parameter.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 3c23fd261022..838ca542c556 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -458,22 +458,20 @@ static int lease_init(struct file *filp, int type, struct file_lock *fl)
 }
 
 /* Allocate a file_lock initialised to this type of lease */
-static int lease_alloc(struct file *filp, int type, struct file_lock **flp)
+static struct file_lock *lease_alloc(struct file *filp, int type)
 {
 	struct file_lock *fl = locks_alloc_lock();
 	int error = -ENOMEM;
 
 	if (fl == NULL)
-		goto out;
+		return ERR_PTR(error);
 
 	error = lease_init(filp, type, fl);
 	if (error) {
 		locks_free_lock(fl);
-		fl = NULL;
+		return ERR_PTR(error);
 	}
-out:
-	*flp = fl;
-	return error;
+	return fl;
 }
 
 /* Check if two locks overlap each other.
@@ -1179,12 +1177,10 @@ int __break_lease(struct inode *inode, unsigned int mode)
 	int error = 0, future;
 	struct file_lock *new_fl, *flock;
 	struct file_lock *fl;
-	int alloc_err;
 	unsigned long break_time;
 	int i_have_this_lease = 0;
 
-	alloc_err = lease_alloc(NULL, mode &amp; FMODE_WRITE ? F_WRLCK : F_RDLCK,
-			&amp;new_fl);
+	new_fl = lease_alloc(NULL, mode &amp; FMODE_WRITE ? F_WRLCK : F_RDLCK);
 
 	lock_kernel();
 
@@ -1212,8 +1208,9 @@ int __break_lease(struct inode *inode, unsigned int mode)
 		goto out;
 	}
 
-	if (alloc_err &amp;&amp; !i_have_this_lease &amp;&amp; ((mode &amp; O_NONBLOCK) == 0)) {
-		error = alloc_err;
+	if (IS_ERR(new_fl) &amp;&amp; !i_have_this_lease
+			&amp;&amp; ((mode &amp; O_NONBLOCK) == 0)) {
+		error = PTR_ERR(new_fl);
 		goto out;
 	}
 
@@ -1260,7 +1257,7 @@ int __break_lease(struct inode *inode, unsigned int mode)
 
 out:
 	unlock_kernel();
-	if (!alloc_err)
+	if (!IS_ERR(new_fl))
 		locks_free_lock(new_fl);
 	return error;
 }</pre><hr><pre>commit d2ab0b0c4c2570921a9ec1eff1e3a5143e05b231
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sat Jun 30 12:40:32 2007 -0400

    locks: convert an -EINVAL return to a BUG
    
    There's no point trying to return an error in these cases, which all represent
    bugs in the callers.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 924e4a7fb1d5..3c23fd261022 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1348,9 +1348,7 @@ static int __setlease(struct file *filp, long arg, struct file_lock **flp)
 
 	time_out_leases(inode);
 
-	error = -EINVAL;
-	if (!flp || !(*flp) || !(*flp)-&gt;fl_lmops || !(*flp)-&gt;fl_lmops-&gt;fl_break)
-		goto out;
+	BUG_ON(!(*flp)-&gt;fl_lmops-&gt;fl_break);
 
 	lease = *flp;
 </pre><hr><pre>commit 87250dd26a34c65ae31d08837174222889007641
Author: david m. richter &lt;richterd@citi.umich.edu&gt;
Date:   Wed May 9 16:10:27 2007 -0400

    leases: minor break_lease() comment clarification
    
    clarify that break_lease() checks for presence of any lock, not just leases.
    
    Signed-off-by: David M. Richter &lt;richterd@citi.umich.edu&gt;
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 431a8b871fce..924e4a7fb1d5 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1169,9 +1169,9 @@ static void time_out_leases(struct inode *inode)
  *	@inode: the inode of the file to return
  *	@mode: the open mode (read or write)
  *
- *	break_lease (inlined for speed) has checked there already
- *	is a lease on this file.  Leases are broken on a call to open()
- *	or truncate().  This function can sleep unless you
+ *	break_lease (inlined for speed) has checked there already is at least
+ *	some kind of lock (maybe a lease) on this file.  Leases are broken on
+ *	a call to open() or truncate().  This function can sleep unless you
  *	specified %O_NONBLOCK to your open().
  */
 int __break_lease(struct inode *inode, unsigned int mode)</pre><hr><pre>commit 1269bc69b6649282091bb7007372acf4ab8357fd
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 17 04:04:52 2007 -0700

    knfsd: nfsd: enforce per-flavor id squashing
    
    Allow root squashing to vary per-pseudoflavor, so that you can (for example)
    allow root access only when sufficiently strong security is in use.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/nfsd/auth.c b/fs/nfsd/auth.c
index 6e92b0fe5323..cf61dc8ae942 100644
--- a/fs/nfsd/auth.c
+++ b/fs/nfsd/auth.c
@@ -12,17 +12,31 @@
 
 #define	CAP_NFSD_MASK (CAP_FS_MASK|CAP_TO_MASK(CAP_SYS_RESOURCE))
 
+static int nfsexp_flags(struct svc_rqst *rqstp, struct svc_export *exp)
+{
+	struct exp_flavor_info *f;
+	struct exp_flavor_info *end = exp-&gt;ex_flavors + exp-&gt;ex_nflavors;
+
+	for (f = exp-&gt;ex_flavors; f &lt; end; f++) {
+		if (f-&gt;pseudoflavor == rqstp-&gt;rq_flavor)
+			return f-&gt;flags;
+	}
+	return exp-&gt;ex_flags;
+
+}
+
 int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp)
 {
 	struct svc_cred	cred = rqstp-&gt;rq_cred;
 	int i;
+	int flags = nfsexp_flags(rqstp, exp);
 	int ret;
 
-	if (exp-&gt;ex_flags &amp; NFSEXP_ALLSQUASH) {
+	if (flags &amp; NFSEXP_ALLSQUASH) {
 		cred.cr_uid = exp-&gt;ex_anon_uid;
 		cred.cr_gid = exp-&gt;ex_anon_gid;
 		cred.cr_group_info = groups_alloc(0);
-	} else if (exp-&gt;ex_flags &amp; NFSEXP_ROOTSQUASH) {
+	} else if (flags &amp; NFSEXP_ROOTSQUASH) {
 		struct group_info *gi;
 		if (!cred.cr_uid)
 			cred.cr_uid = exp-&gt;ex_anon_uid;
diff --git a/include/linux/nfsd/export.h b/include/linux/nfsd/export.h
index a01f775cb944..78feb7beff75 100644
--- a/include/linux/nfsd/export.h
+++ b/include/linux/nfsd/export.h
@@ -43,7 +43,8 @@
 #define NFSEXP_ALLFLAGS		0xFE3F
 
 /* The flags that may vary depending on security flavor: */
-#define NFSEXP_SECINFO_FLAGS	0
+#define NFSEXP_SECINFO_FLAGS	(NFSEXP_READONLY | NFSEXP_ROOTSQUASH \
+					| NFSEXP_ALLSQUASH)
 
 #ifdef __KERNEL__
 </pre><hr><pre>commit 9091224f3cff4721f295df29e8a99705a63bc4c7
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 17 04:04:52 2007 -0700

    knfsd: nfsd: allow auth_sys nlm on rpcsec_gss exports
    
    Our clients (like other clients, as far as I know) use only auth_sys for nlm,
    even when using rpcsec_gss for the main nfs operations.
    
    Administrators that want to deny non-kerberos-authenticated locking requests
    will need to turn off NFS protocol versions less than 4....
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index 8d2b49914843..0eb464a39aae 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -249,10 +249,16 @@ fh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, int type, int access)
 	if (error)
 		goto out;
 
-	/* Check security flavor */
-	error = check_nfsd_access(exp, rqstp);
-	if (error)
-		goto out;
+	if (!(access &amp; MAY_LOCK)) {
+		/*
+		 * pseudoflavor restrictions are not enforced on NLM,
+		 * which clients virtually always use auth_sys for,
+		 * even while using RPCSEC_GSS for NFS.
+		 */
+		error = check_nfsd_access(exp, rqstp);
+		if (error)
+			goto out;
+	}
 
 	/* Finally, check access permissions. */
 	error = nfsd_permission(rqstp, exp, dentry, access);</pre>
    <div class="pagination">
        <a href='4_44.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><span>[45]</span><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_46.html'>Next&gt;&gt;</a>
    <div>
</body>
