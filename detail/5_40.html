<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_39.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><span>[40]</span><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_41.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ffbfe92533810bf1bb76fd275400825ef8898ed9
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 18 20:31:36 2006 -0500

    [SCSI] iscsi: kill dtask mempools
    
    Discovered by steven@hayter.me.uk and patch by michaelc@cs.wisc.edu
    
    The dtask mempool is reserving 261120 items per session! Since we are now
    sending headers with sendmsg there is no reason for the mempool and that
    was causing us to us carzy amounts of mem. We can preallicate a header in
    the r2t and task struct and reuse them
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 7c2ed7bb7e94..08357a6c7e09 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -67,9 +67,6 @@ MODULE_VERSION("0:4.445");
 static unsigned int iscsi_max_lun = 512;
 module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
 
-/* global data */
-static kmem_cache_t *taskcache;
-
 static inline void
 iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
@@ -195,16 +192,6 @@ __iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	if (unlikely(!sc))
 		return;
 
-	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
-		struct iscsi_data_task *dtask, *n;
-
-		/* WRITE: cleanup Data-Out's if any */
-		list_for_each_entry_safe(dtask, n, &amp;tcp_ctask-&gt;dataqueue,
-					 item) {
-			list_del(&amp;dtask-&gt;item);
-			mempool_free(dtask, tcp_ctask-&gt;datapool);
-		}
-	}
 	tcp_ctask-&gt;xmstate = XMSTATE_IDLE;
 	tcp_ctask-&gt;r2t = NULL;
 }
@@ -286,14 +273,10 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 			struct iscsi_r2t_info *r2t)
 {
 	struct iscsi_data *hdr;
-	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
-	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
-	INIT_LIST_HEAD(&amp;dtask-&gt;item);
-	hdr = &amp;dtask-&gt;hdr;
+	hdr = &amp;r2t-&gt;dtask.hdr;
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr-&gt;ttt = r2t-&gt;ttt;
 	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
@@ -319,8 +302,6 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	iscsi_buf_init_iov(&amp;r2t-&gt;headbuf, (char*)hdr,
 			   sizeof(struct iscsi_hdr));
 
-	r2t-&gt;dtask = dtask;
-
 	if (sc-&gt;use_sg) {
 		int i, sg_count = 0;
 		struct scatterlist *sg = sc-&gt;request_buffer;
@@ -352,8 +333,6 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 		iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
 			    (char*)sc-&gt;request_buffer + r2t-&gt;data_offset,
 			    r2t-&gt;data_count);
-
-	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
 }
 
 /**
@@ -1229,14 +1208,10 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_data *hdr;
-	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
 	int new_offset;
 
-	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
-	INIT_LIST_HEAD(&amp;dtask-&gt;item);
-	hdr = &amp;dtask-&gt;hdr;
+	hdr = &amp;r2t-&gt;dtask.hdr;
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr-&gt;ttt = r2t-&gt;ttt;
 	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
@@ -1260,8 +1235,6 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	iscsi_buf_init_iov(&amp;r2t-&gt;headbuf, (char*)hdr,
 			   sizeof(struct iscsi_hdr));
 
-	r2t-&gt;dtask = dtask;
-
 	if (sc-&gt;use_sg &amp;&amp; !iscsi_buf_left(&amp;r2t-&gt;sendbuf)) {
 		BUG_ON(tcp_ctask-&gt;bad_sg == r2t-&gt;sg);
 		iscsi_buf_init_sg(&amp;r2t-&gt;sendbuf, r2t-&gt;sg);
@@ -1270,8 +1243,6 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 		iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
 			    (char*)sc-&gt;request_buffer + new_offset,
 			    r2t-&gt;data_count);
-
-	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
 }
 
 static void
@@ -1280,17 +1251,11 @@ iscsi_unsolicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_data_task *dtask;
 
-	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
-	BUG_ON(!dtask);
-	INIT_LIST_HEAD(&amp;dtask-&gt;item);
-
+	dtask = tcp_ctask-&gt;dtask = &amp;tcp_ctask-&gt;unsol_dtask;
 	iscsi_prep_unsolicit_data_pdu(ctask, &amp;dtask-&gt;hdr,
 				      tcp_ctask-&gt;r2t_data_count);
 	iscsi_buf_init_iov(&amp;tcp_ctask-&gt;headbuf, (char*)&amp;dtask-&gt;hdr,
 			   sizeof(struct iscsi_hdr));
-
-	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
-	tcp_ctask-&gt;dtask = dtask;
 }
 
 /**
@@ -1534,7 +1499,6 @@ handle_xmstate_uns_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
 	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_INIT) {
 		iscsi_unsolicit_data_init(conn, ctask);
-		BUG_ON(!tcp_ctask-&gt;dtask);
 		dtask = tcp_ctask-&gt;dtask;
 		if (conn-&gt;hdrdgst_en)
 			iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
@@ -1643,7 +1607,7 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_r2t_info *r2t = tcp_ctask-&gt;r2t;
-	struct iscsi_data_task *dtask = r2t-&gt;dtask;
+	struct iscsi_data_task *dtask = &amp;r2t-&gt;dtask;
 	int left;
 
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
@@ -1857,7 +1821,7 @@ iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		r2t = tcp_ctask-&gt;r2t;
 		if (conn-&gt;hdrdgst_en)
 			iscsi_hdr_digest(conn, &amp;r2t-&gt;headbuf,
-					(u8*)r2t-&gt;dtask-&gt;hdrext);
+					(u8*)r2t-&gt;dtask.hdrext);
 		if (iscsi_sendhdr(conn, &amp;r2t-&gt;headbuf, r2t-&gt;data_count)) {
 			tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
 			tcp_ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
@@ -2113,21 +2077,6 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 					(void**)tcp_ctask-&gt;r2ts);
 			goto r2t_alloc_fail;
 		}
-
-		/*
-		 * number of
-		 * Data-Out PDU's within R2T-sequence can be quite big;
-		 * using mempool
-		 */
-		tcp_ctask-&gt;datapool = mempool_create_slab_pool(ISCSI_DTASK_DEFAULT_MAX,
-							       taskcache);
-		if (tcp_ctask-&gt;datapool == NULL) {
-			kfifo_free(tcp_ctask-&gt;r2tqueue);
-			iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
-					(void**)tcp_ctask-&gt;r2ts);
-			goto r2t_alloc_fail;
-		}
-		INIT_LIST_HEAD(&amp;tcp_ctask-&gt;dataqueue);
 	}
 
 	return 0;
@@ -2137,7 +2086,6 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
 		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
-		mempool_destroy(tcp_ctask-&gt;datapool);
 		kfifo_free(tcp_ctask-&gt;r2tqueue);
 		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
 				(void**)tcp_ctask-&gt;r2ts);
@@ -2154,7 +2102,6 @@ iscsi_r2tpool_free(struct iscsi_session *session)
 		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
 		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
-		mempool_destroy(tcp_ctask-&gt;datapool);
 		kfifo_free(tcp_ctask-&gt;r2tqueue);
 		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
 				(void**)tcp_ctask-&gt;r2ts);
@@ -2496,21 +2443,6 @@ iscsi_tcp_session_create(struct iscsi_transport *iscsit,
 
 static void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session)
 {
-	struct iscsi_session *session = class_to_transport_session(cls_session);
-	struct iscsi_data_task *dtask, *n;
-	int cmd_i;
-
-	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
-		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
-		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
-
-		list_for_each_entry_safe(dtask, n, &amp;tcp_ctask-&gt;dataqueue,
-					 item) {
-			list_del(&amp;dtask-&gt;item);
-			mempool_free(dtask, tcp_ctask-&gt;datapool);
-		}
-	}
-
 	iscsi_r2tpool_free(class_to_transport_session(cls_session));
 	iscsi_session_teardown(cls_session);
 }
@@ -2592,14 +2524,8 @@ iscsi_tcp_init(void)
 	}
 	iscsi_tcp_transport.max_lun = iscsi_max_lun;
 
-	taskcache = kmem_cache_create("iscsi_taskcache",
-			sizeof(struct iscsi_data_task), 0,
-			SLAB_HWCACHE_ALIGN, NULL, NULL);
-	if (!taskcache)
-		return -ENOMEM;
-
 	if (!iscsi_register_transport(&amp;iscsi_tcp_transport))
-		kmem_cache_destroy(taskcache);
+		return -ENODEV;
 
 	return 0;
 }
@@ -2608,7 +2534,6 @@ static void __exit
 iscsi_tcp_exit(void)
 {
 	iscsi_unregister_transport(&amp;iscsi_tcp_transport);
-	kmem_cache_destroy(taskcache);
 }
 
 module_init(iscsi_tcp_init);
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index c5918854d595..808302832e68 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -118,11 +118,9 @@ struct iscsi_buf {
 struct iscsi_data_task {
 	struct iscsi_data	hdr;			/* PDU */
 	char			hdrext[sizeof(__u32)];	/* Header-Digest */
-	struct list_head	item;			/* data queue item */
 	struct iscsi_buf	digestbuf;		/* digest buffer */
 	uint32_t		digest;			/* data digest */
 };
-#define ISCSI_DTASK_DEFAULT_MAX	ISCSI_SG_TABLESIZE * PAGE_SIZE / 512
 
 struct iscsi_tcp_mgmt_task {
 	struct iscsi_hdr	hdr;
@@ -144,7 +142,7 @@ struct iscsi_r2t_info {
 	int			data_count;	/* DATA-Out payload progress */
 	struct scatterlist	*sg;		/* per-R2T SG list */
 	int			solicit_datasn;
-	struct iscsi_data_task   *dtask;        /* which data task */
+	struct iscsi_data_task   dtask;        /* which data task */
 };
 
 struct iscsi_tcp_cmd_task {
@@ -167,14 +165,13 @@ struct iscsi_tcp_cmd_task {
 	struct iscsi_queue	r2tpool;
 	struct kfifo		*r2tqueue;
 	struct iscsi_r2t_info	**r2ts;
-	struct list_head	dataqueue;		/* Data-Out dataqueue */
-	mempool_t		*datapool;
 	uint32_t		datadigest;		/* for recover digest */
 	int			digest_count;
 	uint32_t		immdigest;		/* for imm data */
 	struct iscsi_buf	immbuf;			/* for imm data digest */
-	struct iscsi_data_task   *dtask;		/* data task in progress*/
-	int			digest_offset;		/* for partial buff digest */
+	struct iscsi_data_task	*dtask;		/* data task in progress*/
+	struct iscsi_data_task	unsol_dtask;	/* unsol data task */
+	int			digest_offset;	/* for partial buff digest */
 };
 
 #endif /* ISCSI_H */</pre><hr><pre>commit d36ab6f3212053b260214bc915687765e2fd1178
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 18 20:31:34 2006 -0500

    [SCSI] iscsi: only preallocate login buffer
    
    We only use the mtask data buffer for login tasks so we do not
    need to preallocate a buffer for every mtask. This saves
    8 * 31 KB.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 4750d4888100..580c0505603c 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1258,15 +1258,6 @@ iscsi_session_setup(struct iscsi_transport *iscsit,
 		if (mgmt_task_size)
 			mtask-&gt;dd_data = &amp;mtask[1];
 		mtask-&gt;itt = ISCSI_MGMT_ITT_OFFSET + cmd_i;
-		mtask-&gt;data = kmalloc(DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH,
-				     GFP_KERNEL);
-		if (!mtask-&gt;data) {
-			int j;
-
-			for (j = 0; j &lt; cmd_i; j++)
-				kfree(session-&gt;mgmt_cmds[j]-&gt;data);
-			goto immdata_alloc_fail;
-		}
 	}
 
 	if (scsi_add_host(shost, NULL))
@@ -1282,9 +1273,6 @@ iscsi_session_setup(struct iscsi_transport *iscsit,
 cls_session_fail:
 	scsi_remove_host(shost);
 add_host_fail:
-	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
-		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
-immdata_alloc_fail:
 	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
 mgmtpool_alloc_fail:
 	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
@@ -1305,13 +1293,9 @@ void iscsi_session_teardown(struct iscsi_cls_session *cls_session)
 {
 	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	int cmd_i;
 
 	scsi_remove_host(shost);
 
-	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
-		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
-
 	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
 	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
 
@@ -1331,6 +1315,7 @@ iscsi_conn_setup(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	struct iscsi_session *session = class_to_transport_session(cls_session);
 	struct iscsi_conn *conn;
 	struct iscsi_cls_conn *cls_conn;
+	char *data;
 
 	cls_conn = iscsi_create_conn(cls_session, conn_idx);
 	if (!cls_conn)
@@ -1376,12 +1361,20 @@ iscsi_conn_setup(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	}
 	spin_unlock_bh(&amp;session-&gt;lock);
 
+	data = kmalloc(DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH, GFP_KERNEL);
+	if (!data)
+		goto login_mtask_data_alloc_fail;
+	conn-&gt;login_mtask-&gt;data = data;
+
 	init_timer(&amp;conn-&gt;tmabort_timer);
 	mutex_init(&amp;conn-&gt;xmitmutex);
 	init_waitqueue_head(&amp;conn-&gt;ehwait);
 
 	return cls_conn;
 
+login_mtask_data_alloc_fail:
+	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
+		    sizeof(void*));
 login_mtask_alloc_fail:
 	kfifo_free(conn-&gt;mgmtqueue);
 mgmtqueue_alloc_fail:
@@ -1451,6 +1444,7 @@ void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
 	}
 
 	spin_lock_bh(&amp;session-&gt;lock);
+	kfree(conn-&gt;login_mtask-&gt;data);
 	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
 		    sizeof(void*));
 	list_del(&amp;conn-&gt;item);</pre><hr><pre>commit 6e458cc943dd494ac68b570418f187883e555362
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 18 20:31:31 2006 -0500

    [SCSI] iscsi: dont use sendpage for iscsi headers
    
    From Zhen and ported by Mike:
    
    Don't use sendpage for the headers. sendpage for the pdu headers
    does not seem to have a performance impact, makes life harder
    for mutiple data pdus to be in flight and still trips up some
    network cards when it is from slab mem.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index d94038eafb9b..7c2ed7bb7e94 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -70,14 +70,6 @@ module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
 /* global data */
 static kmem_cache_t *taskcache;
 
-static inline void
-iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
-{
-	sg_init_one(&amp;ibuf-&gt;sg, (u8 *)vbuf, size);
-	ibuf-&gt;sent = 0;
-	ibuf-&gt;use_sendmsg = 0;
-}
-
 static inline void
 iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
@@ -324,7 +316,7 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 
 	r2t-&gt;sent = 0;
 
-	iscsi_buf_init_virt(&amp;r2t-&gt;headbuf, (char*)hdr,
+	iscsi_buf_init_iov(&amp;r2t-&gt;headbuf, (char*)hdr,
 			   sizeof(struct iscsi_hdr));
 
 	r2t-&gt;dtask = dtask;
@@ -1208,7 +1200,7 @@ iscsi_digest_final_send(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	if (final)
 		crypto_digest_final(tcp_conn-&gt;data_tx_tfm, (u8*)digest);
 
-	iscsi_buf_init_virt(buf, (char*)digest, 4);
+	iscsi_buf_init_iov(buf, (char*)digest, 4);
 	rc = iscsi_sendpage(conn, buf, &amp;tcp_ctask-&gt;digest_count, &amp;sent);
 	if (rc) {
 		tcp_ctask-&gt;datadigest = *digest;
@@ -1265,7 +1257,7 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	}
 	conn-&gt;dataout_pdus_cnt++;
 
-	iscsi_buf_init_virt(&amp;r2t-&gt;headbuf, (char*)hdr,
+	iscsi_buf_init_iov(&amp;r2t-&gt;headbuf, (char*)hdr,
 			   sizeof(struct iscsi_hdr));
 
 	r2t-&gt;dtask = dtask;
@@ -1294,7 +1286,7 @@ iscsi_unsolicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	iscsi_prep_unsolicit_data_pdu(ctask, &amp;dtask-&gt;hdr,
 				      tcp_ctask-&gt;r2t_data_count);
-	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;headbuf, (char*)&amp;dtask-&gt;hdr,
+	iscsi_buf_init_iov(&amp;tcp_ctask-&gt;headbuf, (char*)&amp;dtask-&gt;hdr,
 			   sizeof(struct iscsi_hdr));
 
 	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
@@ -1361,7 +1353,7 @@ iscsi_tcp_cmd_init(struct iscsi_cmd_task *ctask)
 	} else
 		tcp_ctask-&gt;xmstate = XMSTATE_R_HDR;
 
-	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;headbuf, (char*)ctask-&gt;hdr,
+	iscsi_buf_init_iov(&amp;tcp_ctask-&gt;headbuf, (char*)ctask-&gt;hdr,
 			    sizeof(struct iscsi_hdr));
 }
 
@@ -1758,7 +1750,7 @@ handle_xmstate_w_pad(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	int sent;
 
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_W_PAD;
-	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;sendbuf, (char*)&amp;tcp_ctask-&gt;pad,
+	iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf, (char*)&amp;tcp_ctask-&gt;pad,
 			    tcp_ctask-&gt;pad_count);
 	if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;tcp_ctask-&gt;pad_count,
 			   &amp;sent)) {
@@ -2078,8 +2070,8 @@ iscsi_tcp_mgmt_init(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask,
 {
 	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
 
-	iscsi_buf_init_virt(&amp;tcp_mtask-&gt;headbuf, (char*)mtask-&gt;hdr,
-				    sizeof(struct iscsi_hdr));
+	iscsi_buf_init_iov(&amp;tcp_mtask-&gt;headbuf, (char*)mtask-&gt;hdr,
+			   sizeof(struct iscsi_hdr));
 	tcp_mtask-&gt;xmstate = XMSTATE_IMM_HDR;
 
 	if (mtask-&gt;data_count)</pre><hr><pre>commit 665b44aee34e9f2c64558df4ec01d40576e45651
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 2 19:46:49 2006 -0500

    [SCSI] iscsi: dequeue all buffers from queue
    
    debugged by wrwhitehead@novell.com
    patch and analysis by fujita.tomonori@lab.ntt.co.jp
    
    Only tcp_read_sock and recv_actor (iscsi_tcp_data_recv for us) see
    desc.count. It is is used just for permitting tcp_read_sock to read
    the portion of data in the socket.
    
    When iscsi_tcp_data_recv sees a partial header, it sets
    desc.count. However, it is possible that the next skb (containing the
    rest of the header) still does not come. So I'm not sure that this
    scheme is completely correct.
    
    Ideally, we should use the exact length of the data in the socket for
    desc.count. However, it is not so simple (see SIOCINQ in
    tcp_ioctl). So I think that iscsi_tcp_data_recv can just stop playing
    with desc.count and tell tcp_read_sock to read the all skbs. As
    proposed already, if iscsi_tcp_data_ready sets desc.count to
    non-zero, tcp_read_sock does that.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index c0ce6ab81a9d..d94038eafb9b 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -922,11 +922,8 @@ iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 
 		rc = iscsi_data_recv(conn);
 		if (rc) {
-			if (rc == -EAGAIN) {
-				rd_desc-&gt;count = tcp_conn-&gt;in.datalen -
-						tcp_conn-&gt;in.ctask-&gt;data_count;
+			if (rc == -EAGAIN)
 				goto again;
-			}
 			iscsi_conn_failure(conn, rc);
 			return 0;
 		}
@@ -983,9 +980,14 @@ iscsi_tcp_data_ready(struct sock *sk, int flag)
 
 	read_lock(&amp;sk-&gt;sk_callback_lock);
 
-	/* use rd_desc to pass 'conn' to iscsi_tcp_data_recv */
+	/*
+	 * Use rd_desc to pass 'conn' to iscsi_tcp_data_recv.
+	 * We set count to 1 because we want the network layer to
+	 * hand us all the skbs that are available. iscsi_tcp_data_recv
+	 * handled pdus that cross buffers or pdus that still need data.
+	 */
 	rd_desc.arg.data = conn;
-	rd_desc.count = 0;
+	rd_desc.count = 1;
 	tcp_read_sock(sk, &amp;rd_desc, iscsi_tcp_data_recv);
 
 	read_unlock(&amp;sk-&gt;sk_callback_lock);</pre><hr><pre>commit 8d2860b3c3e933304f49171770658c00ed26fd79
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 2 19:46:47 2006 -0500

    [SCSI] iscsi: increment expstatsn during login
    
    debugged by Ming and Rohan:
    
    The problem Ming and Rohan debugged was that during a normal session
    login, open-iscsi is not incrementing the exp_statsn counter. It was
    stuck at zero. From the RFC, it looks like if the login response PDU has
    a successful status then we should be incrementing that value. Also from
    the RFC, it looks like if when we drop a connection then reconnect, we
    should be using the exp_statsn from the old connection in the next
    relogin attempt.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 41f4bb557ea6..c0ce6ab81a9d 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -2298,6 +2298,9 @@ iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 		BUG_ON(value);
 		session-&gt;ofmarker_en = value;
 		break;
+	case ISCSI_PARAM_EXP_STATSN:
+		conn-&gt;exp_statsn = value;
+		break;
 	default:
 		break;
 	}
@@ -2381,6 +2384,9 @@ iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 		inet = inet_sk(tcp_conn-&gt;sock-&gt;sk);
 		*value = be16_to_cpu(inet-&gt;dport);
 		mutex_unlock(&amp;conn-&gt;xmitmutex);
+	case ISCSI_PARAM_EXP_STATSN:
+		*value = conn-&gt;exp_statsn;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -2548,7 +2554,8 @@ static struct iscsi_transport iscsi_tcp_transport = {
 				  ISCSI_DATASEQ_INORDER_EN |
 				  ISCSI_ERL |
 				  ISCSI_CONN_PORT |
-				  ISCSI_CONN_ADDRESS,
+				  ISCSI_CONN_ADDRESS |
+				  ISCSI_EXP_STATSN,
 	.host_template		= &amp;iscsi_sht,
 	.conndata_size		= sizeof(struct iscsi_conn),
 	.max_conn		= 1,
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index a99f2ef44e87..4750d4888100 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -333,15 +333,21 @@ int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		debug_scsi("immrsp [op 0x%x cid %d itt 0x%x len %d]\n",
 			   opcode, conn-&gt;id, mtask-&gt;itt, datalen);
 
+		rc = iscsi_check_assign_cmdsn(session,
+					      (struct iscsi_nopin*)hdr);
+		if (rc)
+			goto done;
+
 		switch(opcode) {
+		case ISCSI_OP_LOGOUT_RSP:
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+			/* fall through */
 		case ISCSI_OP_LOGIN_RSP:
 		case ISCSI_OP_TEXT_RSP:
-		case ISCSI_OP_LOGOUT_RSP:
-			rc = iscsi_check_assign_cmdsn(session,
-						 (struct iscsi_nopin*)hdr);
-			if (rc)
-				break;
-
+			/*
+			 * login related PDU's exp_statsn is handled in
+			 * userspace
+			 */
 			rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen);
 			list_del(&amp;mtask-&gt;running);
 			if (conn-&gt;login_mtask != mtask)
@@ -349,15 +355,12 @@ int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 					    (void*)&amp;mtask, sizeof(void*));
 			break;
 		case ISCSI_OP_SCSI_TMFUNC_RSP:
-			rc = iscsi_check_assign_cmdsn(session,
-						 (struct iscsi_nopin*)hdr);
-			if (rc)
-				break;
-
 			if (datalen) {
 				rc = ISCSI_ERR_PROTO;
 				break;
 			}
+
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
 			conn-&gt;tmfrsp_pdus_cnt++;
 			if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
 				conn-&gt;tmabort_state =
@@ -373,10 +376,6 @@ int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 				rc = ISCSI_ERR_PROTO;
 				break;
 			}
-			rc = iscsi_check_assign_cmdsn(session,
-						(struct iscsi_nopin*)hdr);
-			if (rc)
-				break;
 			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
 
 			rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen);
@@ -404,6 +403,7 @@ int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		case ISCSI_OP_REJECT:
 			/* we need sth like iscsi_reject_rsp()*/
 		case ISCSI_OP_ASYNC_EVENT:
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
 			/* we need sth like iscsi_async_event_rsp() */
 			rc = ISCSI_ERR_BAD_OPCODE;
 			break;
@@ -414,6 +414,7 @@ int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	} else
 		rc = ISCSI_ERR_BAD_ITT;
 
+done:
 	return rc;
 }
 EXPORT_SYMBOL_GPL(__iscsi_complete_pdu);
@@ -730,6 +731,7 @@ iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
 	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
 
+		nop-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
 		if (!__kfifo_get(session-&gt;mgmtpool.queue,
 				 (void*)&amp;mtask, sizeof(void*))) {
 			spin_unlock_bh(&amp;session-&gt;lock);
@@ -738,7 +740,7 @@ iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	}
 
 	/*
-	 * pre-format CmdSN and ExpStatSN for outgoing PDU.
+	 * pre-format CmdSN for outgoing PDU.
 	 */
 	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
 		hdr-&gt;itt = mtask-&gt;itt | (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT) |
@@ -751,8 +753,6 @@ iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		/* do not advance CmdSN */
 		nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 
-	nop-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
-
 	if (data_size) {
 		memcpy(mtask-&gt;data, data, data_size);
 		mtask-&gt;data_count = data_size;
@@ -1647,7 +1647,7 @@ void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	case STOP_CONN_RECOVER:
 	case STOP_CONN_TERM:
 		iscsi_start_session_recovery(session, conn, flag);
-		return;
+		break;
 	case STOP_CONN_SUSPEND:
 		if (session-&gt;tt-&gt;suspend_conn_recv)
 			session-&gt;tt-&gt;suspend_conn_recv(conn);
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 1b96f7c4ce7a..44adafac861f 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -32,7 +32,7 @@
 #include &lt;scsi/iscsi_if.h&gt;
 
 #define ISCSI_SESSION_ATTRS 11
-#define ISCSI_CONN_ATTRS 10
+#define ISCSI_CONN_ATTRS 11
 #define ISCSI_HOST_ATTRS 0
 
 struct iscsi_internal {
@@ -1156,6 +1156,7 @@ iscsi_conn_int_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN, "%d");
 iscsi_conn_int_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN, "%d");
 iscsi_conn_int_attr(persistent_port, ISCSI_PARAM_PERSISTENT_PORT, "%d");
 iscsi_conn_int_attr(port, ISCSI_PARAM_CONN_PORT, "%d");
+iscsi_conn_int_attr(exp_statsn, ISCSI_PARAM_EXP_STATSN, "%u");
 
 #define iscsi_conn_str_attr_show(param)					\
 static ssize_t								\
@@ -1406,6 +1407,7 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	SETUP_CONN_RD_ATTR(ofmarker, ISCSI_OFMARKER_EN);
 	SETUP_CONN_RD_ATTR(address, ISCSI_CONN_ADDRESS);
 	SETUP_CONN_RD_ATTR(port, ISCSI_CONN_PORT);
+	SETUP_CONN_RD_ATTR(exp_statsn, ISCSI_EXP_STATSN);
 
 	if (tt-&gt;param_mask &amp; ISCSI_PERSISTENT_ADDRESS)
 		SETUP_CONN_RD_ATTR(persistent_address, ISCSI_PERSISTENT_ADDRESS);
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index feff74e544b7..253797c60095 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -188,6 +188,7 @@ enum iscsi_param {
 	ISCSI_PARAM_ERL,
 	ISCSI_PARAM_IFMARKER_EN,
 	ISCSI_PARAM_OFMARKER_EN,
+	ISCSI_PARAM_EXP_STATSN,
 	ISCSI_PARAM_TARGET_NAME,
 	ISCSI_PARAM_TPGT,
 	ISCSI_PARAM_PERSISTENT_ADDRESS,
@@ -216,6 +217,7 @@ enum iscsi_param {
 #define ISCSI_ERL			(1 &lt;&lt; ISCSI_PARAM_ERL)
 #define ISCSI_IFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_IFMARKER_EN)
 #define ISCSI_OFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_OFMARKER_EN)
+#define ISCSI_EXP_STATSN		(1 &lt;&lt; ISCSI_PARAM_EXP_STATSN)
 #define ISCSI_TARGET_NAME		(1 &lt;&lt; ISCSI_PARAM_TARGET_NAME)
 #define ISCSI_TPGT			(1 &lt;&lt; ISCSI_PARAM_TPGT)
 #define ISCSI_PERSISTENT_ADDRESS	(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_ADDRESS)</pre><hr><pre>commit ed2abc7ff19dc99c6242a70f8578a17b2ff0d0ce
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 2 19:46:40 2006 -0500

    [SCSI] iscsi: fix manamgement task oops
    
    from patmans@us.ibm.com and michaelc@cs.wisc.edu
    
    Fix bugs when forcing a mgmt task to fail and allow
    session recovery to cleanup the session/connection
    of any running mgmt tasks. When called during
    the in login state.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 274a1374ab64..8c51f6c36661 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1538,10 +1538,11 @@ flush_control_queues(struct iscsi_session *session, struct iscsi_conn *conn)
 	/* handle running */
 	list_for_each_entry_safe(mtask, tmp, &amp;conn-&gt;mgmt_run_list, running) {
 		debug_scsi("flushing running mgmt task itt 0x%x\n", mtask-&gt;itt);
+		list_del(&amp;mtask-&gt;running);
+
 		if (mtask == conn-&gt;login_mtask)
 			continue;
-		list_del(&amp;mtask-&gt;running);
-		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;mtask,
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;mtask,
 			   sizeof(void*));
 	}
 
@@ -1573,12 +1574,22 @@ static void fail_all_commands(struct iscsi_conn *conn)
 void iscsi_start_session_recovery(struct iscsi_session *session,
 				  struct iscsi_conn *conn, int flag)
 {
+	int old_stop_stage;
+
 	spin_lock_bh(&amp;session-&gt;lock);
-	if (conn-&gt;stop_stage == STOP_CONN_RECOVER ||
-	    conn-&gt;stop_stage == STOP_CONN_TERM) {
+	if (conn-&gt;stop_stage == STOP_CONN_TERM) {
 		spin_unlock_bh(&amp;session-&gt;lock);
 		return;
 	}
+
+	/*
+	 * When this is called for the in_login state, we only want to clean
+	 * up the login task and connection.
+	 */
+	if (conn-&gt;stop_stage != STOP_CONN_RECOVER)
+		session-&gt;conn_cnt--;
+
+	old_stop_stage = conn-&gt;stop_stage;
 	conn-&gt;stop_stage = flag;
 	spin_unlock_bh(&amp;session-&gt;lock);
 
@@ -1590,7 +1601,6 @@ void iscsi_start_session_recovery(struct iscsi_session *session,
 	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 
-	session-&gt;conn_cnt--;
 	if (session-&gt;conn_cnt == 0 || session-&gt;leadconn == conn)
 		session-&gt;state = ISCSI_STATE_FAILED;
 
@@ -1615,7 +1625,12 @@ void iscsi_start_session_recovery(struct iscsi_session *session,
 		conn-&gt;hdrdgst_en = 0;
 		conn-&gt;datadgst_en = 0;
 
-		if (session-&gt;state == ISCSI_STATE_FAILED)
+		/*
+		 * if this is called from the eh and and from userspace
+		 * then we only need to block once.
+		 */
+		if (session-&gt;state == ISCSI_STATE_FAILED &amp;&amp;
+		    old_stop_stage != STOP_CONN_RECOVER)
 			iscsi_block_session(session_to_cls(session));
 	}
 	mutex_unlock(&amp;conn-&gt;xmitmutex);</pre><hr><pre>commit 5bb0b55a3283369f1cd8ac76a6d8bda8e7a77055
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Apr 6 21:26:46 2006 -0500

    [SCSI] iscsi: convert iscsi tcp to libiscsi
    
    This just converts iscsi_tcp to the lib
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index aca3e23b1b9e..fe00a3f6d204 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -3,7 +3,8 @@
  *
  * Copyright (C) 2004 Dmitry Yusupov
  * Copyright (C) 2004 Alex Aizman
- * Copyright (C) 2005 Mike Christie
+ * Copyright (C) 2005 - 2006 Mike Christie
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
  * maintained by open-iscsi@googlegroups.com
  *
  * This program is free software; you can redistribute it and/or modify
@@ -36,10 +37,6 @@
 #include &lt;linux/mutex.h&gt;
 #include &lt;net/tcp.h&gt;
 #include &lt;scsi/scsi_cmnd.h&gt;
-#include &lt;scsi/scsi_device.h&gt;
-#include &lt;scsi/scsi_eh.h&gt;
-#include &lt;scsi/scsi_request.h&gt;
-#include &lt;scsi/scsi_tcq.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_transport_iscsi.h&gt;
@@ -52,21 +49,14 @@ MODULE_DESCRIPTION("iSCSI/TCP data-path");
 MODULE_LICENSE("GPL");
 MODULE_VERSION("0:4.445");
 /* #define DEBUG_TCP */
-/* #define DEBUG_SCSI */
 #define DEBUG_ASSERT
 
 #ifdef DEBUG_TCP
-#define debug_tcp(fmt...) printk(KERN_DEBUG "tcp: " fmt)
+#define debug_tcp(fmt...) printk(KERN_INFO "tcp: " fmt)
 #else
 #define debug_tcp(fmt...)
 #endif
 
-#ifdef DEBUG_SCSI
-#define debug_scsi(fmt...) printk(KERN_DEBUG "scsi: " fmt)
-#else
-#define debug_scsi(fmt...)
-#endif
-
 #ifndef DEBUG_ASSERT
 #ifdef BUG_ON
 #undef BUG_ON
@@ -74,17 +64,12 @@ MODULE_VERSION("0:4.445");
 #define BUG_ON(expr)
 #endif
 
-#define INVALID_SN_DELTA	0xffff
-
 static unsigned int iscsi_max_lun = 512;
 module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
 
 /* global data */
 static kmem_cache_t *taskcache;
 
-#define session_to_cls(_sess) \
-	hostdata_session(_sess-&gt;host-&gt;hostdata)
-
 static inline void
 iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
@@ -133,68 +118,39 @@ static inline void
 iscsi_hdr_digest(struct iscsi_conn *conn, struct iscsi_buf *buf,
 		 u8* crc)
 {
-	crypto_digest_digest(conn-&gt;tx_tfm, &amp;buf-&gt;sg, 1, crc);
-	buf-&gt;sg.length += sizeof(uint32_t);
-}
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 
-static void
-iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
-{
-	struct iscsi_session *session = conn-&gt;session;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;session-&gt;lock, flags);
-	if (session-&gt;conn_cnt == 1 || session-&gt;leadconn == conn)
-		session-&gt;state = ISCSI_STATE_FAILED;
-	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
-	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
-	iscsi_conn_error(conn-&gt;cls_conn, err);
+	crypto_digest_digest(tcp_conn-&gt;tx_tfm, &amp;buf-&gt;sg, 1, crc);
+	buf-&gt;sg.length += sizeof(uint32_t);
 }
 
 static inline int
-iscsi_check_assign_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
+iscsi_hdr_extract(struct iscsi_tcp_conn *tcp_conn)
 {
-	uint32_t max_cmdsn = be32_to_cpu(hdr-&gt;max_cmdsn);
-	uint32_t exp_cmdsn = be32_to_cpu(hdr-&gt;exp_cmdsn);
-
-	if (max_cmdsn &lt; exp_cmdsn -1 &amp;&amp;
-	    max_cmdsn &gt; exp_cmdsn - INVALID_SN_DELTA)
-		return ISCSI_ERR_MAX_CMDSN;
-	if (max_cmdsn &gt; session-&gt;max_cmdsn ||
-	    max_cmdsn &lt; session-&gt;max_cmdsn - INVALID_SN_DELTA)
-		session-&gt;max_cmdsn = max_cmdsn;
-	if (exp_cmdsn &gt; session-&gt;exp_cmdsn ||
-	    exp_cmdsn &lt; session-&gt;exp_cmdsn - INVALID_SN_DELTA)
-		session-&gt;exp_cmdsn = exp_cmdsn;
-
-	return 0;
-}
+	struct sk_buff *skb = tcp_conn-&gt;in.skb;
 
-static inline int
-iscsi_hdr_extract(struct iscsi_conn *conn)
-{
-	struct sk_buff *skb = conn-&gt;in.skb;
+	tcp_conn-&gt;in.zero_copy_hdr = 0;
 
-	if (conn-&gt;in.copy &gt;= conn-&gt;hdr_size &amp;&amp;
-	    conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER) {
+	if (tcp_conn-&gt;in.copy &gt;= tcp_conn-&gt;hdr_size &amp;&amp;
+	    tcp_conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER) {
 		/*
 		 * Zero-copy PDU Header: using connection context
 		 * to store header pointer.
 		 */
 		if (skb_shinfo(skb)-&gt;frag_list == NULL &amp;&amp;
-		    !skb_shinfo(skb)-&gt;nr_frags)
-			conn-&gt;in.hdr = (struct iscsi_hdr *)
-				((char*)skb-&gt;data + conn-&gt;in.offset);
-		else {
+		    !skb_shinfo(skb)-&gt;nr_frags) {
+			tcp_conn-&gt;in.hdr = (struct iscsi_hdr *)
+				((char*)skb-&gt;data + tcp_conn-&gt;in.offset);
+			tcp_conn-&gt;in.zero_copy_hdr = 1;
+		} else {
 			/* ignoring return code since we checked
 			 * in.copy before */
-			skb_copy_bits(skb, conn-&gt;in.offset,
-				&amp;conn-&gt;hdr, conn-&gt;hdr_size);
-			conn-&gt;in.hdr = &amp;conn-&gt;hdr;
+			skb_copy_bits(skb, tcp_conn-&gt;in.offset,
+				&amp;tcp_conn-&gt;hdr, tcp_conn-&gt;hdr_size);
+			tcp_conn-&gt;in.hdr = &amp;tcp_conn-&gt;hdr;
 		}
-		conn-&gt;in.offset += conn-&gt;hdr_size;
-		conn-&gt;in.copy -= conn-&gt;hdr_size;
+		tcp_conn-&gt;in.offset += tcp_conn-&gt;hdr_size;
+		tcp_conn-&gt;in.copy -= tcp_conn-&gt;hdr_size;
 	} else {
 		int hdr_remains;
 		int copylen;
@@ -204,30 +160,31 @@ iscsi_hdr_extract(struct iscsi_conn *conn)
 		 * copying it... This'll happen quite rarely.
 		 */
 
-		if (conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER)
-			conn-&gt;in.hdr_offset = 0;
+		if (tcp_conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER)
+			tcp_conn-&gt;in.hdr_offset = 0;
 
-		hdr_remains = conn-&gt;hdr_size - conn-&gt;in.hdr_offset;
+		hdr_remains = tcp_conn-&gt;hdr_size - tcp_conn-&gt;in.hdr_offset;
 		BUG_ON(hdr_remains &lt;= 0);
 
-		copylen = min(conn-&gt;in.copy, hdr_remains);
-		skb_copy_bits(skb, conn-&gt;in.offset,
-			(char*)&amp;conn-&gt;hdr + conn-&gt;in.hdr_offset, copylen);
+		copylen = min(tcp_conn-&gt;in.copy, hdr_remains);
+		skb_copy_bits(skb, tcp_conn-&gt;in.offset,
+			(char*)&amp;tcp_conn-&gt;hdr + tcp_conn-&gt;in.hdr_offset,
+			copylen);
 
 		debug_tcp("PDU gather offset %d bytes %d in.offset %d "
-		       "in.copy %d\n", conn-&gt;in.hdr_offset, copylen,
-		       conn-&gt;in.offset, conn-&gt;in.copy);
+		       "in.copy %d\n", tcp_conn-&gt;in.hdr_offset, copylen,
+		       tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy);
 
-		conn-&gt;in.offset += copylen;
-		conn-&gt;in.copy -= copylen;
+		tcp_conn-&gt;in.offset += copylen;
+		tcp_conn-&gt;in.copy -= copylen;
 		if (copylen &lt; hdr_remains)  {
-			conn-&gt;in_progress = IN_PROGRESS_HEADER_GATHER;
-			conn-&gt;in.hdr_offset += copylen;
+			tcp_conn-&gt;in_progress = IN_PROGRESS_HEADER_GATHER;
+			tcp_conn-&gt;in.hdr_offset += copylen;
 		        return -EAGAIN;
 		}
-		conn-&gt;in.hdr = &amp;conn-&gt;hdr;
-		conn-&gt;discontiguous_hdr_cnt++;
-	        conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+		tcp_conn-&gt;in.hdr = &amp;tcp_conn-&gt;hdr;
+		tcp_conn-&gt;discontiguous_hdr_cnt++;
+	        tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
 	}
 
 	return 0;
@@ -239,7 +196,7 @@ iscsi_hdr_extract(struct iscsi_conn *conn)
 static void
 __iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct scsi_cmnd *sc;
 
 	sc = ctask-&gt;sc;
@@ -248,88 +205,16 @@ __iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
 		struct iscsi_data_task *dtask, *n;
+
 		/* WRITE: cleanup Data-Out's if any */
-		list_for_each_entry_safe(dtask, n, &amp;ctask-&gt;dataqueue, item) {
+		list_for_each_entry_safe(dtask, n, &amp;tcp_ctask-&gt;dataqueue,
+					 item) {
 			list_del(&amp;dtask-&gt;item);
-			mempool_free(dtask, ctask-&gt;datapool);
+			mempool_free(dtask, tcp_ctask-&gt;datapool);
 		}
 	}
-	ctask-&gt;xmstate = XMSTATE_IDLE;
-	ctask-&gt;r2t = NULL;
-	ctask-&gt;sc = NULL;
-	list_del(&amp;ctask-&gt;running);
-
-	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
-
-	sc-&gt;scsi_done(sc);
-}
-
-static void
-iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_session *session = conn-&gt;session;
-
-	spin_lock(&amp;session-&gt;lock);
-	__iscsi_ctask_cleanup(conn, ctask);
-	spin_unlock(&amp;session-&gt;lock);
-}
-
-/**
- * iscsi_cmd_rsp - SCSI Command Response processing
- * @conn: iscsi connection
- * @ctask: scsi command task
- **/
-static int
-iscsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
-{
-	int rc;
-	struct iscsi_cmd_rsp *rhdr = (struct iscsi_cmd_rsp *)conn-&gt;in.hdr;
-	struct iscsi_session *session = conn-&gt;session;
-	struct scsi_cmnd *sc = ctask-&gt;sc;
-
-	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
-	if (rc) {
-		sc-&gt;result = (DID_ERROR &lt;&lt; 16);
-		goto out;
-	}
-
-	conn-&gt;exp_statsn = be32_to_cpu(rhdr-&gt;statsn) + 1;
-
-	sc-&gt;result = (DID_OK &lt;&lt; 16) | rhdr-&gt;cmd_status;
-
-	if (rhdr-&gt;response != ISCSI_STATUS_CMD_COMPLETED) {
-		sc-&gt;result = (DID_ERROR &lt;&lt; 16);
-		goto out;
-	}
-
-	if (rhdr-&gt;cmd_status == SAM_STAT_CHECK_CONDITION &amp;&amp; conn-&gt;senselen) {
-		int sensecopy = min(conn-&gt;senselen, SCSI_SENSE_BUFFERSIZE);
-
-		memcpy(sc-&gt;sense_buffer, conn-&gt;data + 2, sensecopy);
-		debug_scsi("copied %d bytes of sense\n", sensecopy);
-	}
-
-	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE)
-		goto out;
-
-	if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_UNDERFLOW) {
-		int res_count = be32_to_cpu(rhdr-&gt;residual_count);
-
-		if (res_count &gt; 0 &amp;&amp; res_count &lt;= sc-&gt;request_bufflen)
-			sc-&gt;resid = res_count;
-		else
-			sc-&gt;result = (DID_BAD_TARGET &lt;&lt; 16) | rhdr-&gt;cmd_status;
-	} else if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_BIDI_UNDERFLOW)
-		sc-&gt;result = (DID_BAD_TARGET &lt;&lt; 16) | rhdr-&gt;cmd_status;
-	else if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_OVERFLOW)
-		sc-&gt;resid = be32_to_cpu(rhdr-&gt;residual_count);
-
-out:
-	debug_scsi("done [sc %lx res %d itt 0x%x]\n",
-		   (long)sc, sc-&gt;result, ctask-&gt;itt);
-	conn-&gt;scsirsp_pdus_cnt++;
-	iscsi_ctask_cleanup(conn, ctask);
-	return rc;
+	tcp_ctask-&gt;xmstate = XMSTATE_IDLE;
+	tcp_ctask-&gt;r2t = NULL;
 }
 
 /**
@@ -341,7 +226,9 @@ static int
 iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	int rc;
-	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)conn-&gt;in.hdr;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn-&gt;in.hdr;
 	struct iscsi_session *session = conn-&gt;session;
 	int datasn = be32_to_cpu(rhdr-&gt;datasn);
 
@@ -351,9 +238,9 @@ iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	/*
 	 * setup Data-In byte counter (gets decremented..)
 	 */
-	ctask-&gt;data_count = conn-&gt;in.datalen;
+	ctask-&gt;data_count = tcp_conn-&gt;in.datalen;
 
-	if (conn-&gt;in.datalen == 0)
+	if (tcp_conn-&gt;in.datalen == 0)
 		return 0;
 
 	if (ctask-&gt;datasn != datasn)
@@ -361,8 +248,8 @@ iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	ctask-&gt;datasn++;
 
-	ctask-&gt;data_offset = be32_to_cpu(rhdr-&gt;offset);
-	if (ctask-&gt;data_offset + conn-&gt;in.datalen &gt; ctask-&gt;total_length)
+	tcp_ctask-&gt;data_offset = be32_to_cpu(rhdr-&gt;offset);
+	if (tcp_ctask-&gt;data_offset + tcp_conn-&gt;in.datalen &gt; ctask-&gt;total_length)
 		return ISCSI_ERR_DATA_OFFSET;
 
 	if (rhdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
@@ -409,8 +296,9 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	struct iscsi_data *hdr;
 	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
-	dtask = mempool_alloc(ctask-&gt;datapool, GFP_ATOMIC);
+	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
 	BUG_ON(!dtask);
 	INIT_LIST_HEAD(&amp;dtask-&gt;item);
 	hdr = &amp;dtask-&gt;hdr;
@@ -419,8 +307,8 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
 	r2t-&gt;solicit_datasn++;
 	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr.lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;itt = ctask-&gt;hdr.itt;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
 	hdr-&gt;exp_statsn = r2t-&gt;exp_statsn;
 	hdr-&gt;offset = cpu_to_be32(r2t-&gt;data_offset);
 	if (r2t-&gt;data_length &gt; conn-&gt;max_xmit_dlength) {
@@ -469,11 +357,11 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 		}
 		BUG_ON(r2t-&gt;sg == NULL);
 	} else
-		iscsi_buf_init_iov(&amp;ctask-&gt;sendbuf,
+		iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
 			    (char*)sc-&gt;request_buffer + r2t-&gt;data_offset,
 			    r2t-&gt;data_count);
 
-	list_add(&amp;dtask-&gt;item, &amp;ctask-&gt;dataqueue);
+	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
 }
 
 /**
@@ -486,17 +374,16 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_r2t_info *r2t;
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *)conn-&gt;in.hdr;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *)tcp_conn-&gt;in.hdr;
 	int r2tsn = be32_to_cpu(rhdr-&gt;r2tsn);
 	int rc;
 
-	if (conn-&gt;in.ahslen)
-		return ISCSI_ERR_AHSLEN;
-
-	if (conn-&gt;in.datalen)
+	if (tcp_conn-&gt;in.datalen)
 		return ISCSI_ERR_DATALEN;
 
-	if (ctask-&gt;exp_r2tsn &amp;&amp; ctask-&gt;exp_r2tsn != r2tsn)
+	if (tcp_ctask-&gt;exp_r2tsn &amp;&amp; tcp_ctask-&gt;exp_r2tsn != r2tsn)
 		return ISCSI_ERR_R2TSN;
 
 	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
@@ -514,7 +401,7 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		spin_unlock(&amp;session-&gt;lock);
 		return 0;
 	}
-	rc = __kfifo_get(ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
+	rc = __kfifo_get(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
 	BUG_ON(!rc);
 
 	r2t-&gt;exp_statsn = rhdr-&gt;statsn;
@@ -536,10 +423,10 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	iscsi_solicit_data_init(conn, ctask, r2t);
 
-	ctask-&gt;exp_r2tsn = r2tsn + 1;
-	ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
-	__kfifo_put(ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*));
-	__kfifo_put(conn-&gt;writequeue, (void*)&amp;ctask, sizeof(void*));
+	tcp_ctask-&gt;exp_r2tsn = r2tsn + 1;
+	tcp_ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
+	__kfifo_put(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*));
+	__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*));
 
 	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
 	conn-&gt;r2t_pdus_cnt++;
@@ -549,256 +436,136 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 }
 
 static int
-iscsi_hdr_recv(struct iscsi_conn *conn)
+iscsi_tcp_hdr_recv(struct iscsi_conn *conn)
 {
-	int rc = 0;
+	int rc = 0, opcode, ahslen;
 	struct iscsi_hdr *hdr;
-	struct iscsi_cmd_task *ctask;
 	struct iscsi_session *session = conn-&gt;session;
-	uint32_t cdgst, rdgst = 0;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	uint32_t cdgst, rdgst = 0, itt;
 
-	hdr = conn-&gt;in.hdr;
+	hdr = tcp_conn-&gt;in.hdr;
 
 	/* verify PDU length */
-	conn-&gt;in.datalen = ntoh24(hdr-&gt;dlength);
-	if (conn-&gt;in.datalen &gt; conn-&gt;max_recv_dlength) {
+	tcp_conn-&gt;in.datalen = ntoh24(hdr-&gt;dlength);
+	if (tcp_conn-&gt;in.datalen &gt; conn-&gt;max_recv_dlength) {
 		printk(KERN_ERR "iscsi_tcp: datalen %d &gt; %d\n",
-		       conn-&gt;in.datalen, conn-&gt;max_recv_dlength);
+		       tcp_conn-&gt;in.datalen, conn-&gt;max_recv_dlength);
 		return ISCSI_ERR_DATALEN;
 	}
-	conn-&gt;data_copied = 0;
+	tcp_conn-&gt;data_copied = 0;
 
 	/* read AHS */
-	conn-&gt;in.ahslen = hdr-&gt;hlength * 4;
-	conn-&gt;in.offset += conn-&gt;in.ahslen;
-	conn-&gt;in.copy -= conn-&gt;in.ahslen;
-	if (conn-&gt;in.copy &lt; 0) {
+	ahslen = hdr-&gt;hlength &lt;&lt; 2;
+	tcp_conn-&gt;in.offset += ahslen;
+	tcp_conn-&gt;in.copy -= ahslen;
+	if (tcp_conn-&gt;in.copy &lt; 0) {
 		printk(KERN_ERR "iscsi_tcp: can't handle AHS with length "
-		       "%d bytes\n", conn-&gt;in.ahslen);
+		       "%d bytes\n", ahslen);
 		return ISCSI_ERR_AHSLEN;
 	}
 
 	/* calculate read padding */
-	conn-&gt;in.padding = conn-&gt;in.datalen &amp; (ISCSI_PAD_LEN-1);
-	if (conn-&gt;in.padding) {
-		conn-&gt;in.padding = ISCSI_PAD_LEN - conn-&gt;in.padding;
-		debug_scsi("read padding %d bytes\n", conn-&gt;in.padding);
+	tcp_conn-&gt;in.padding = tcp_conn-&gt;in.datalen &amp; (ISCSI_PAD_LEN-1);
+	if (tcp_conn-&gt;in.padding) {
+		tcp_conn-&gt;in.padding = ISCSI_PAD_LEN - tcp_conn-&gt;in.padding;
+		debug_scsi("read padding %d bytes\n", tcp_conn-&gt;in.padding);
 	}
 
 	if (conn-&gt;hdrdgst_en) {
 		struct scatterlist sg;
 
 		sg_init_one(&amp;sg, (u8 *)hdr,
-			    sizeof(struct iscsi_hdr) + conn-&gt;in.ahslen);
-		crypto_digest_digest(conn-&gt;rx_tfm, &amp;sg, 1, (u8 *)&amp;cdgst);
+			    sizeof(struct iscsi_hdr) + ahslen);
+		crypto_digest_digest(tcp_conn-&gt;rx_tfm, &amp;sg, 1, (u8 *)&amp;cdgst);
 		rdgst = *(uint32_t*)((char*)hdr + sizeof(struct iscsi_hdr) +
-				     conn-&gt;in.ahslen);
+				     ahslen);
 		if (cdgst != rdgst) {
-			printk(KERN_ERR "iscsi_tcp: itt %x: hdrdgst error "
-			       "recv 0x%x calc 0x%x\n", conn-&gt;in.itt, rdgst,
-			       cdgst);
+			printk(KERN_ERR "iscsi_tcp: hdrdgst error "
+			       "recv 0x%x calc 0x%x\n", rdgst, cdgst);
 			return ISCSI_ERR_HDR_DGST;
 		}
 	}
 
-	/* save opcode for later */
-	conn-&gt;in.opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
-
+	opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
 	/* verify itt (itt encoding: age+cid+itt) */
-	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		if ((hdr-&gt;itt &amp; AGE_MASK) !=
-				(session-&gt;age &lt;&lt; AGE_SHIFT)) {
-			printk(KERN_ERR "iscsi_tcp: received itt %x expected "
-				"session age (%x)\n", hdr-&gt;itt,
-				session-&gt;age &amp; AGE_MASK);
-			return ISCSI_ERR_BAD_ITT;
-		}
-
-		if ((hdr-&gt;itt &amp; CID_MASK) != (conn-&gt;id &lt;&lt; CID_SHIFT)) {
-			printk(KERN_ERR "iscsi_tcp: received itt %x, expected "
-				"CID (%x)\n", hdr-&gt;itt, conn-&gt;id);
-			return ISCSI_ERR_BAD_ITT;
-		}
-		conn-&gt;in.itt = hdr-&gt;itt &amp; ITT_MASK;
-	} else
-		conn-&gt;in.itt = hdr-&gt;itt;
+	rc = iscsi_verify_itt(conn, hdr, &amp;itt);
+	if (rc == ISCSI_ERR_NO_SCSI_CMD) {
+		tcp_conn-&gt;in.datalen = 0; /* force drop */
+		return 0;
+	} else if (rc)
+		return rc;
 
 	debug_tcp("opcode 0x%x offset %d copy %d ahslen %d datalen %d\n",
-		  hdr-&gt;opcode, conn-&gt;in.offset, conn-&gt;in.copy,
-		  conn-&gt;in.ahslen, conn-&gt;in.datalen);
-
-	if (conn-&gt;in.itt &lt; session-&gt;cmds_max) {
-		ctask = (struct iscsi_cmd_task *)session-&gt;cmds[conn-&gt;in.itt];
-
-		if (!ctask-&gt;sc) {
-			printk(KERN_INFO "iscsi_tcp: dropping ctask with "
-			       "itt 0x%x\n", ctask-&gt;itt);
-			conn-&gt;in.datalen = 0; /* force drop */
-			return 0;
-		}
-
-		if (ctask-&gt;sc-&gt;SCp.phase != session-&gt;age) {
-			printk(KERN_ERR "iscsi_tcp: ctask's session age %d, "
-				"expected %d\n", ctask-&gt;sc-&gt;SCp.phase,
-				session-&gt;age);
-			return ISCSI_ERR_SESSION_FAILED;
-		}
-
-		conn-&gt;in.ctask = ctask;
-
-		debug_scsi("rsp [op 0x%x cid %d sc %lx itt 0x%x len %d]\n",
-			   hdr-&gt;opcode, conn-&gt;id, (long)ctask-&gt;sc,
-			   ctask-&gt;itt, conn-&gt;in.datalen);
-
-		switch(conn-&gt;in.opcode) {
-		case ISCSI_OP_SCSI_CMD_RSP:
-			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
-			if (!conn-&gt;in.datalen)
-				rc = iscsi_cmd_rsp(conn, ctask);
-			else
-				/*
-				 * got sense or response data; copying PDU
-				 * Header to the connection's header
-				 * placeholder
-				 */
-				memcpy(&amp;conn-&gt;hdr, hdr,
-				       sizeof(struct iscsi_hdr));
-			break;
-		case ISCSI_OP_SCSI_DATA_IN:
-			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
-			/* save flags for non-exceptional status */
-			conn-&gt;in.flags = hdr-&gt;flags;
-			/* save cmd_status for sense data */
-			conn-&gt;in.cmd_status =
-				((struct iscsi_data_rsp*)hdr)-&gt;cmd_status;
-			rc = iscsi_data_rsp(conn, ctask);
-			break;
-		case ISCSI_OP_R2T:
-			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
-			if (ctask-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE)
-				rc = iscsi_r2t_rsp(conn, ctask);
-			else
-				rc = ISCSI_ERR_PROTO;
-			break;
-		default:
-			rc = ISCSI_ERR_BAD_OPCODE;
-			break;
-		}
-	} else if (conn-&gt;in.itt &gt;= ISCSI_MGMT_ITT_OFFSET &amp;&amp;
-		   conn-&gt;in.itt &lt; ISCSI_MGMT_ITT_OFFSET +
-					session-&gt;mgmtpool_max) {
-		struct iscsi_mgmt_task *mtask = (struct iscsi_mgmt_task *)
-					session-&gt;mgmt_cmds[conn-&gt;in.itt -
-						ISCSI_MGMT_ITT_OFFSET];
-
-		debug_scsi("immrsp [op 0x%x cid %d itt 0x%x len %d]\n",
-			   conn-&gt;in.opcode, conn-&gt;id, mtask-&gt;itt,
-			   conn-&gt;in.datalen);
-
-		switch(conn-&gt;in.opcode) {
-		case ISCSI_OP_LOGIN_RSP:
-		case ISCSI_OP_TEXT_RSP:
-		case ISCSI_OP_LOGOUT_RSP:
-			rc = iscsi_check_assign_cmdsn(session,
-						 (struct iscsi_nopin*)hdr);
-			if (rc)
-				break;
+		  opcode, tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy,
+		  ahslen, tcp_conn-&gt;in.datalen);
 
-			if (!conn-&gt;in.datalen) {
-				rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr,
-						    NULL, 0);
-				if (conn-&gt;login_mtask != mtask) {
-					spin_lock(&amp;session-&gt;lock);
-					__kfifo_put(session-&gt;mgmtpool.queue,
-					    (void*)&amp;mtask, sizeof(void*));
-					spin_unlock(&amp;session-&gt;lock);
-				}
-			}
-			break;
-		case ISCSI_OP_SCSI_TMFUNC_RSP:
-			rc = iscsi_check_assign_cmdsn(session,
-						 (struct iscsi_nopin*)hdr);
-			if (rc)
-				break;
+	switch(opcode) {
+	case ISCSI_OP_SCSI_DATA_IN:
+		tcp_conn-&gt;in.ctask = session-&gt;cmds[itt];
+		rc = iscsi_data_rsp(conn, tcp_conn-&gt;in.ctask);
+		/* fall through */
+	case ISCSI_OP_SCSI_CMD_RSP:
+		tcp_conn-&gt;in.ctask = session-&gt;cmds[itt];
+		if (tcp_conn-&gt;in.datalen)
+			goto copy_hdr;
 
-			if (conn-&gt;in.datalen || conn-&gt;in.ahslen) {
-				rc = ISCSI_ERR_PROTO;
-				break;
-			}
-			conn-&gt;tmfrsp_pdus_cnt++;
-			spin_lock(&amp;session-&gt;lock);
-			if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
-				conn-&gt;tmabort_state =
-					((struct iscsi_tm_rsp *)hdr)-&gt;
-					response == ISCSI_TMF_RSP_COMPLETE ?
-						TMABORT_SUCCESS:TMABORT_FAILED;
-				/* unblock eh_abort() */
-				wake_up(&amp;conn-&gt;ehwait);
-			}
-			spin_unlock(&amp;session-&gt;lock);
-			break;
-		case ISCSI_OP_NOOP_IN:
-			if (hdr-&gt;ttt != ISCSI_RESERVED_TAG) {
-				rc = ISCSI_ERR_PROTO;
-				break;
-			}
-			rc = iscsi_check_assign_cmdsn(session,
-						(struct iscsi_nopin*)hdr);
-			if (rc)
-				break;
-			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
-
-			if (!conn-&gt;in.datalen) {
-				struct iscsi_mgmt_task *mtask;
-
-				rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr,
-						    NULL, 0);
-				mtask = (struct iscsi_mgmt_task *)
-					session-&gt;mgmt_cmds[conn-&gt;in.itt -
-							ISCSI_MGMT_ITT_OFFSET];
-				if (conn-&gt;login_mtask != mtask) {
-					spin_lock(&amp;session-&gt;lock);
-					__kfifo_put(session-&gt;mgmtpool.queue,
-						  (void*)&amp;mtask, sizeof(void*));
-					spin_unlock(&amp;session-&gt;lock);
-				}
-			}
-			break;
-		default:
-			rc = ISCSI_ERR_BAD_OPCODE;
-			break;
-		}
-	} else if (conn-&gt;in.itt == ISCSI_RESERVED_TAG) {
-		switch(conn-&gt;in.opcode) {
-		case ISCSI_OP_NOOP_IN:
-			if (!conn-&gt;in.datalen) {
-				rc = iscsi_check_assign_cmdsn(session,
-						 (struct iscsi_nopin*)hdr);
-				if (!rc &amp;&amp; hdr-&gt;ttt != ISCSI_RESERVED_TAG)
-					rc = iscsi_recv_pdu(conn-&gt;cls_conn,
-							    hdr, NULL, 0);
-			} else
-				rc = ISCSI_ERR_PROTO;
-			break;
-		case ISCSI_OP_REJECT:
-			/* we need sth like iscsi_reject_rsp()*/
-		case ISCSI_OP_ASYNC_EVENT:
-			/* we need sth like iscsi_async_event_rsp() */
-			rc = ISCSI_ERR_BAD_OPCODE;
-			break;
-		default:
-			rc = ISCSI_ERR_BAD_OPCODE;
-			break;
-		}
-	} else
-		rc = ISCSI_ERR_BAD_ITT;
+		spin_lock(&amp;session-&gt;lock);
+		__iscsi_ctask_cleanup(conn, tcp_conn-&gt;in.ctask);
+		rc = __iscsi_complete_pdu(conn, hdr, NULL, 0);
+		spin_unlock(&amp;session-&gt;lock);
+		break;
+	case ISCSI_OP_R2T:
+		tcp_conn-&gt;in.ctask = session-&gt;cmds[itt];
+		if (ahslen)
+			rc = ISCSI_ERR_AHSLEN;
+		else if (tcp_conn-&gt;in.ctask-&gt;sc-&gt;sc_data_direction ==
+								DMA_TO_DEVICE)
+			rc = iscsi_r2t_rsp(conn, tcp_conn-&gt;in.ctask);
+		else
+			rc = ISCSI_ERR_PROTO;
+		break;
+	case ISCSI_OP_LOGIN_RSP:
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_LOGOUT_RSP:
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_REJECT:
+	case ISCSI_OP_ASYNC_EVENT:
+		if (tcp_conn-&gt;in.datalen)
+			goto copy_hdr;
+	/* fall through */
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+		rc = iscsi_complete_pdu(conn, hdr, NULL, 0);
+		break;
+	default:
+		rc = ISCSI_ERR_BAD_OPCODE;
+		break;
+	}
 
 	return rc;
+
+copy_hdr:
+	/*
+	 * if we did zero copy for the header but we will need multiple
+	 * skbs to complete the command then we have to copy the header
+	 * for later use
+	 */
+	if (tcp_conn-&gt;in.zero_copy_hdr &amp;&amp; tcp_conn-&gt;in.copy &lt;
+	   (tcp_conn-&gt;in.datalen + tcp_conn-&gt;in.padding +
+	    (conn-&gt;datadgst_en ? 4 : 0))) {
+		debug_tcp("Copying header for later use. in.copy %d in.datalen"
+			  " %d\n", tcp_conn-&gt;in.copy, tcp_conn-&gt;in.datalen);
+		memcpy(&amp;tcp_conn-&gt;hdr, tcp_conn-&gt;in.hdr,
+		       sizeof(struct iscsi_hdr));
+		tcp_conn-&gt;in.hdr = &amp;tcp_conn-&gt;hdr;
+		tcp_conn-&gt;in.zero_copy_hdr = 0;
+	}
+	return 0;
 }
 
 /**
  * iscsi_ctask_copy - copy skb bits to the destanation cmd task
- * @conn: iscsi connection
+ * @conn: iscsi tcp connection
  * @ctask: scsi command task
  * @buf: buffer to copy to
  * @buf_size: size of buffer
@@ -820,110 +587,113 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
  *	buf_left		left to copy from in progress buffer
  **/
 static inline int
-iscsi_ctask_copy(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+iscsi_ctask_copy(struct iscsi_tcp_conn *tcp_conn, struct iscsi_cmd_task *ctask,
 		void *buf, int buf_size, int offset)
 {
-	int buf_left = buf_size - (conn-&gt;data_copied + offset);
-	int size = min(conn-&gt;in.copy, buf_left);
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	int buf_left = buf_size - (tcp_conn-&gt;data_copied + offset);
+	int size = min(tcp_conn-&gt;in.copy, buf_left);
 	int rc;
 
 	size = min(size, ctask-&gt;data_count);
 
 	debug_tcp("ctask_copy %d bytes at offset %d copied %d\n",
-	       size, conn-&gt;in.offset, conn-&gt;in.copied);
+	       size, tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copied);
 
 	BUG_ON(size &lt;= 0);
-	BUG_ON(ctask-&gt;sent + size &gt; ctask-&gt;total_length);
+	BUG_ON(tcp_ctask-&gt;sent + size &gt; ctask-&gt;total_length);
 
-	rc = skb_copy_bits(conn-&gt;in.skb, conn-&gt;in.offset,
-			   (char*)buf + (offset + conn-&gt;data_copied), size);
+	rc = skb_copy_bits(tcp_conn-&gt;in.skb, tcp_conn-&gt;in.offset,
+			   (char*)buf + (offset + tcp_conn-&gt;data_copied), size);
 	/* must fit into skb-&gt;len */
 	BUG_ON(rc);
 
-	conn-&gt;in.offset += size;
-	conn-&gt;in.copy -= size;
-	conn-&gt;in.copied += size;
-	conn-&gt;data_copied += size;
-	ctask-&gt;sent += size;
+	tcp_conn-&gt;in.offset += size;
+	tcp_conn-&gt;in.copy -= size;
+	tcp_conn-&gt;in.copied += size;
+	tcp_conn-&gt;data_copied += size;
+	tcp_ctask-&gt;sent += size;
 	ctask-&gt;data_count -= size;
 
-	BUG_ON(conn-&gt;in.copy &lt; 0);
+	BUG_ON(tcp_conn-&gt;in.copy &lt; 0);
 	BUG_ON(ctask-&gt;data_count &lt; 0);
 
-	if (buf_size != (conn-&gt;data_copied + offset)) {
+	if (buf_size != (tcp_conn-&gt;data_copied + offset)) {
 		if (!ctask-&gt;data_count) {
-			BUG_ON(buf_size - conn-&gt;data_copied &lt; 0);
+			BUG_ON(buf_size - tcp_conn-&gt;data_copied &lt; 0);
 			/* done with this PDU */
-			return buf_size - conn-&gt;data_copied;
+			return buf_size - tcp_conn-&gt;data_copied;
 		}
 		return -EAGAIN;
 	}
 
 	/* done with this buffer or with both - PDU and buffer */
-	conn-&gt;data_copied = 0;
+	tcp_conn-&gt;data_copied = 0;
 	return 0;
 }
 
 /**
  * iscsi_tcp_copy - copy skb bits to the destanation buffer
- * @conn: iscsi connection
- * @buf: buffer to copy to
- * @buf_size: number of bytes to copy
+ * @conn: iscsi tcp connection
  *
  * Notes:
  *	The function calls skb_copy_bits() and updates per-connection
  *	byte counters.
  **/
 static inline int
-iscsi_tcp_copy(struct iscsi_conn *conn, void *buf, int buf_size)
+iscsi_tcp_copy(struct iscsi_tcp_conn *tcp_conn)
 {
-	int buf_left = buf_size - conn-&gt;data_copied;
-	int size = min(conn-&gt;in.copy, buf_left);
+	void *buf = tcp_conn-&gt;data;
+	int buf_size = tcp_conn-&gt;in.datalen;
+	int buf_left = buf_size - tcp_conn-&gt;data_copied;
+	int size = min(tcp_conn-&gt;in.copy, buf_left);
 	int rc;
 
 	debug_tcp("tcp_copy %d bytes at offset %d copied %d\n",
-	       size, conn-&gt;in.offset, conn-&gt;data_copied);
+	       size, tcp_conn-&gt;in.offset, tcp_conn-&gt;data_copied);
 	BUG_ON(size &lt;= 0);
 
-	rc = skb_copy_bits(conn-&gt;in.skb, conn-&gt;in.offset,
-			   (char*)buf + conn-&gt;data_copied, size);
+	rc = skb_copy_bits(tcp_conn-&gt;in.skb, tcp_conn-&gt;in.offset,
+			   (char*)buf + tcp_conn-&gt;data_copied, size);
 	BUG_ON(rc);
 
-	conn-&gt;in.offset += size;
-	conn-&gt;in.copy -= size;
-	conn-&gt;in.copied += size;
-	conn-&gt;data_copied += size;
+	tcp_conn-&gt;in.offset += size;
+	tcp_conn-&gt;in.copy -= size;
+	tcp_conn-&gt;in.copied += size;
+	tcp_conn-&gt;data_copied += size;
 
-	if (buf_size != conn-&gt;data_copied)
+	if (buf_size != tcp_conn-&gt;data_copied)
 		return -EAGAIN;
 
 	return 0;
 }
 
 static inline void
-partial_sg_digest_update(struct iscsi_conn *conn, struct scatterlist *sg,
-			 int offset, int length)
+partial_sg_digest_update(struct iscsi_tcp_conn *tcp_conn,
+			 struct scatterlist *sg, int offset, int length)
 {
 	struct scatterlist temp;
 
 	memcpy(&amp;temp, sg, sizeof(struct scatterlist));
 	temp.offset = offset;
 	temp.length = length;
-	crypto_digest_update(conn-&gt;data_rx_tfm, &amp;temp, 1);
+	crypto_digest_update(tcp_conn-&gt;data_rx_tfm, &amp;temp, 1);
 }
 
 static void
-iscsi_recv_digest_update(struct iscsi_conn *conn, char* buf, int len)
+iscsi_recv_digest_update(struct iscsi_tcp_conn *tcp_conn, char* buf, int len)
 {
 	struct scatterlist tmp;
 
 	sg_init_one(&amp;tmp, buf, len);
-	crypto_digest_update(conn-&gt;data_rx_tfm, &amp;tmp, 1);
+	crypto_digest_update(tcp_conn-&gt;data_rx_tfm, &amp;tmp, 1);
 }
 
 static int iscsi_scsi_data_in(struct iscsi_conn *conn)
 {
-	struct iscsi_cmd_task *ctask = conn-&gt;in.ctask;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_cmd_task *ctask = tcp_conn-&gt;in.ctask;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
 	struct scatterlist *sg;
 	int i, offset, rc = 0;
@@ -935,31 +705,33 @@ static int iscsi_scsi_data_in(struct iscsi_conn *conn)
 	 */
 	if (!sc-&gt;use_sg) {
 		i = ctask-&gt;data_count;
-		rc = iscsi_ctask_copy(conn, ctask, sc-&gt;request_buffer,
-				      sc-&gt;request_bufflen, ctask-&gt;data_offset);
+		rc = iscsi_ctask_copy(tcp_conn, ctask, sc-&gt;request_buffer,
+				      sc-&gt;request_bufflen,
+				      tcp_ctask-&gt;data_offset);
 		if (rc == -EAGAIN)
 			return rc;
 		if (conn-&gt;datadgst_en)
-			iscsi_recv_digest_update(conn, sc-&gt;request_buffer, i);
+			iscsi_recv_digest_update(tcp_conn, sc-&gt;request_buffer,
+						 i);
 		rc = 0;
 		goto done;
 	}
 
-	offset = ctask-&gt;data_offset;
+	offset = tcp_ctask-&gt;data_offset;
 	sg = sc-&gt;request_buffer;
 
-	if (ctask-&gt;data_offset)
-		for (i = 0; i &lt; ctask-&gt;sg_count; i++)
+	if (tcp_ctask-&gt;data_offset)
+		for (i = 0; i &lt; tcp_ctask-&gt;sg_count; i++)
 			offset -= sg[i].length;
 	/* we've passed through partial sg*/
 	if (offset &lt; 0)
 		offset = 0;
 
-	for (i = ctask-&gt;sg_count; i &lt; sc-&gt;use_sg; i++) {
+	for (i = tcp_ctask-&gt;sg_count; i &lt; sc-&gt;use_sg; i++) {
 		char *dest;
 
 		dest = kmap_atomic(sg[i].page, KM_SOFTIRQ0);
-		rc = iscsi_ctask_copy(conn, ctask, dest + sg[i].offset,
+		rc = iscsi_ctask_copy(tcp_conn, ctask, dest + sg[i].offset,
 				      sg[i].length, offset);
 		kunmap_atomic(dest, KM_SOFTIRQ0);
 		if (rc == -EAGAIN)
@@ -968,15 +740,17 @@ static int iscsi_scsi_data_in(struct iscsi_conn *conn)
 		if (!rc) {
 			if (conn-&gt;datadgst_en) {
 				if (!offset)
-					crypto_digest_update(conn-&gt;data_rx_tfm,
-							     &amp;sg[i], 1);
+					crypto_digest_update(
+							tcp_conn-&gt;data_rx_tfm,
+							&amp;sg[i], 1);
 				else
-					partial_sg_digest_update(conn, &amp;sg[i],
+					partial_sg_digest_update(tcp_conn,
+							&amp;sg[i],
 							sg[i].offset + offset,
 							sg[i].length - offset);
 			}
 			offset = 0;
-			ctask-&gt;sg_count++;
+			tcp_ctask-&gt;sg_count++;
 		}
 
 		if (!ctask-&gt;data_count) {
@@ -984,24 +758,26 @@ static int iscsi_scsi_data_in(struct iscsi_conn *conn)
 				/*
 				 * data-in is complete, but buffer not...
 				 */
-				partial_sg_digest_update(conn, &amp;sg[i],
+				partial_sg_digest_update(tcp_conn, &amp;sg[i],
 						sg[i].offset, sg[i].length-rc);
 			rc = 0;
 			break;
 		}
 
-		if (!conn-&gt;in.copy)
+		if (!tcp_conn-&gt;in.copy)
 			return -EAGAIN;
 	}
 	BUG_ON(ctask-&gt;data_count);
 
 done:
 	/* check for non-exceptional status */
-	if (conn-&gt;in.flags &amp; ISCSI_FLAG_DATA_STATUS) {
+	if (tcp_conn-&gt;in.hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
 		debug_scsi("done [sc %lx res %d itt 0x%x]\n",
 			   (long)sc, sc-&gt;result, ctask-&gt;itt);
-		conn-&gt;scsirsp_pdus_cnt++;
-		iscsi_ctask_cleanup(conn, ctask);
+		spin_lock(&amp;conn-&gt;session-&gt;lock);
+		__iscsi_ctask_cleanup(conn, ctask);
+		__iscsi_complete_pdu(conn, tcp_conn-&gt;in.hdr, NULL, 0);
+		spin_unlock(&amp;conn-&gt;session-&gt;lock);
 	}
 
 	return rc;
@@ -1010,71 +786,38 @@ static int iscsi_scsi_data_in(struct iscsi_conn *conn)
 static int
 iscsi_data_recv(struct iscsi_conn *conn)
 {
-	struct iscsi_session *session = conn-&gt;session;
-	int rc = 0;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int rc = 0, opcode;
 
-	switch(conn-&gt;in.opcode) {
+	opcode = tcp_conn-&gt;in.hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
+	switch (opcode) {
 	case ISCSI_OP_SCSI_DATA_IN:
 		rc = iscsi_scsi_data_in(conn);
 		break;
-	case ISCSI_OP_SCSI_CMD_RSP: {
-		/*
-		 * SCSI Sense Data:
-		 * copying the entire Data Segment.
-		 */
-		if (iscsi_tcp_copy(conn, conn-&gt;data, conn-&gt;in.datalen)) {
-			rc = -EAGAIN;
-			goto exit;
-		}
-
-		/*
-		 * check for sense
-		 */
-		conn-&gt;in.hdr = &amp;conn-&gt;hdr;
-		conn-&gt;senselen = (conn-&gt;data[0] &lt;&lt; 8) | conn-&gt;data[1];
-		rc = iscsi_cmd_rsp(conn, conn-&gt;in.ctask);
-		if (!rc &amp;&amp; conn-&gt;datadgst_en)
-			iscsi_recv_digest_update(conn, conn-&gt;data,
-						 conn-&gt;in.datalen);
-	}
-	break;
+	case ISCSI_OP_SCSI_CMD_RSP:
+		spin_lock(&amp;conn-&gt;session-&gt;lock);
+		__iscsi_ctask_cleanup(conn, tcp_conn-&gt;in.ctask);
+		spin_unlock(&amp;conn-&gt;session-&gt;lock);
 	case ISCSI_OP_TEXT_RSP:
 	case ISCSI_OP_LOGIN_RSP:
-	case ISCSI_OP_NOOP_IN: {
-		struct iscsi_mgmt_task *mtask = NULL;
-
-		if (conn-&gt;in.itt != ISCSI_RESERVED_TAG)
-			mtask = (struct iscsi_mgmt_task *)
-				session-&gt;mgmt_cmds[conn-&gt;in.itt -
-					ISCSI_MGMT_ITT_OFFSET];
-
+	case ISCSI_OP_NOOP_IN:
+	case ISCSI_OP_ASYNC_EVENT:
+	case ISCSI_OP_REJECT:
 		/*
 		 * Collect data segment to the connection's data
 		 * placeholder
 		 */
-		if (iscsi_tcp_copy(conn, conn-&gt;data, conn-&gt;in.datalen)) {
+		if (iscsi_tcp_copy(tcp_conn)) {
 			rc = -EAGAIN;
 			goto exit;
 		}
 
-		rc = iscsi_recv_pdu(conn-&gt;cls_conn, conn-&gt;in.hdr,
-				    conn-&gt;data, conn-&gt;in.datalen);
-
-		if (!rc &amp;&amp; conn-&gt;datadgst_en &amp;&amp;
-			conn-&gt;in.opcode != ISCSI_OP_LOGIN_RSP)
-			iscsi_recv_digest_update(conn, conn-&gt;data,
-			  			conn-&gt;in.datalen);
-
-		if (mtask &amp;&amp; conn-&gt;login_mtask != mtask) {
-			spin_lock(&amp;session-&gt;lock);
-			__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;mtask,
-				    sizeof(void*));
-			spin_unlock(&amp;session-&gt;lock);
-		}
-	}
-	break;
-	case ISCSI_OP_ASYNC_EVENT:
-	case ISCSI_OP_REJECT:
+		rc = iscsi_complete_pdu(conn, tcp_conn-&gt;in.hdr, tcp_conn-&gt;data,
+					tcp_conn-&gt;in.datalen);
+		if (!rc &amp;&amp; conn-&gt;datadgst_en &amp;&amp; opcode != ISCSI_OP_LOGIN_RSP)
+			iscsi_recv_digest_update(tcp_conn, tcp_conn-&gt;data,
+			  			tcp_conn-&gt;in.datalen);
+		break;
 	default:
 		BUG_ON(1);
 	}
@@ -1095,6 +838,7 @@ iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 {
 	int rc;
 	struct iscsi_conn *conn = rd_desc-&gt;arg.data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	int processed;
 	char pad[ISCSI_PAD_LEN];
 	struct scatterlist sg;
@@ -1103,15 +847,15 @@ iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 	 * Save current SKB and its offset in the corresponding
 	 * connection context.
 	 */
-	conn-&gt;in.copy = skb-&gt;len - offset;
-	conn-&gt;in.offset = offset;
-	conn-&gt;in.skb = skb;
-	conn-&gt;in.len = conn-&gt;in.copy;
-	BUG_ON(conn-&gt;in.copy &lt;= 0);
-	debug_tcp("in %d bytes\n", conn-&gt;in.copy);
+	tcp_conn-&gt;in.copy = skb-&gt;len - offset;
+	tcp_conn-&gt;in.offset = offset;
+	tcp_conn-&gt;in.skb = skb;
+	tcp_conn-&gt;in.len = tcp_conn-&gt;in.copy;
+	BUG_ON(tcp_conn-&gt;in.copy &lt;= 0);
+	debug_tcp("in %d bytes\n", tcp_conn-&gt;in.copy);
 
 more:
-	conn-&gt;in.copied = 0;
+	tcp_conn-&gt;in.copied = 0;
 	rc = 0;
 
 	if (unlikely(conn-&gt;suspend_rx)) {
@@ -1119,9 +863,9 @@ iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 		return 0;
 	}
 
-	if (conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER ||
-	    conn-&gt;in_progress == IN_PROGRESS_HEADER_GATHER) {
-		rc = iscsi_hdr_extract(conn);
+	if (tcp_conn-&gt;in_progress == IN_PROGRESS_WAIT_HEADER ||
+	    tcp_conn-&gt;in_progress == IN_PROGRESS_HEADER_GATHER) {
+		rc = iscsi_hdr_extract(tcp_conn);
 		if (rc) {
 		       if (rc == -EAGAIN)
 				goto nomore;
@@ -1134,90 +878,94 @@ iscsi_tcp_data_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 		/*
 		 * Verify and process incoming PDU header.
 		 */
-		rc = iscsi_hdr_recv(conn);
-		if (!rc &amp;&amp; conn-&gt;in.datalen) {
+		rc = iscsi_tcp_hdr_recv(conn);
+		if (!rc &amp;&amp; tcp_conn-&gt;in.datalen) {
 			if (conn-&gt;datadgst_en) {
-				BUG_ON(!conn-&gt;data_rx_tfm);
-				crypto_digest_init(conn-&gt;data_rx_tfm);
+				BUG_ON(!tcp_conn-&gt;data_rx_tfm);
+				crypto_digest_init(tcp_conn-&gt;data_rx_tfm);
 			}
-			conn-&gt;in_progress = IN_PROGRESS_DATA_RECV;
+			tcp_conn-&gt;in_progress = IN_PROGRESS_DATA_RECV;
 		} else if (rc) {
 			iscsi_conn_failure(conn, rc);
 			return 0;
 		}
 	}
 
-	if (conn-&gt;in_progress == IN_PROGRESS_DDIGEST_RECV) {
+	if (tcp_conn-&gt;in_progress == IN_PROGRESS_DDIGEST_RECV) {
 		uint32_t recv_digest;
+
 		debug_tcp("extra data_recv offset %d copy %d\n",
-			  conn-&gt;in.offset, conn-&gt;in.copy);
-		skb_copy_bits(conn-&gt;in.skb, conn-&gt;in.offset,
+			  tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy);
+		skb_copy_bits(tcp_conn-&gt;in.skb, tcp_conn-&gt;in.offset,
 				&amp;recv_digest, 4);
-		conn-&gt;in.offset += 4;
-		conn-&gt;in.copy -= 4;
-		if (recv_digest != conn-&gt;in.datadgst) {
+		tcp_conn-&gt;in.offset += 4;
+		tcp_conn-&gt;in.copy -= 4;
+		if (recv_digest != tcp_conn-&gt;in.datadgst) {
 			debug_tcp("iscsi_tcp: data digest error!"
 				  "0x%x != 0x%x\n", recv_digest,
-				  conn-&gt;in.datadgst);
+				  tcp_conn-&gt;in.datadgst);
 			iscsi_conn_failure(conn, ISCSI_ERR_DATA_DGST);
 			return 0;
 		} else {
 			debug_tcp("iscsi_tcp: data digest match!"
 				  "0x%x == 0x%x\n", recv_digest,
-				  conn-&gt;in.datadgst);
-			conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+				  tcp_conn-&gt;in.datadgst);
+			tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
 		}
 	}
 
-	if (conn-&gt;in_progress == IN_PROGRESS_DATA_RECV &amp;&amp; conn-&gt;in.copy) {
+	if (tcp_conn-&gt;in_progress == IN_PROGRESS_DATA_RECV &amp;&amp;
+	   tcp_conn-&gt;in.copy) {
 
 		debug_tcp("data_recv offset %d copy %d\n",
-		       conn-&gt;in.offset, conn-&gt;in.copy);
+		       tcp_conn-&gt;in.offset, tcp_conn-&gt;in.copy);
 
 		rc = iscsi_data_recv(conn);
 		if (rc) {
 			if (rc == -EAGAIN) {
-				rd_desc-&gt;count = conn-&gt;in.datalen -
-						conn-&gt;in.ctask-&gt;data_count;
+				rd_desc-&gt;count = tcp_conn-&gt;in.datalen -
+						tcp_conn-&gt;in.ctask-&gt;data_count;
 				goto again;
 			}
 			iscsi_conn_failure(conn, rc);
 			return 0;
 		}
-		conn-&gt;in.copy -= conn-&gt;in.padding;
-		conn-&gt;in.offset += conn-&gt;in.padding;
+		tcp_conn-&gt;in.copy -= tcp_conn-&gt;in.padding;
+		tcp_conn-&gt;in.offset += tcp_conn-&gt;in.padding;
 		if (conn-&gt;datadgst_en) {
-			if (conn-&gt;in.padding) {
-				debug_tcp("padding -&gt; %d\n", conn-&gt;in.padding);
-				memset(pad, 0, conn-&gt;in.padding);
-				sg_init_one(&amp;sg, pad, conn-&gt;in.padding);
-				crypto_digest_update(conn-&gt;data_rx_tfm, &amp;sg, 1);
+			if (tcp_conn-&gt;in.padding) {
+				debug_tcp("padding -&gt; %d\n",
+					  tcp_conn-&gt;in.padding);
+				memset(pad, 0, tcp_conn-&gt;in.padding);
+				sg_init_one(&amp;sg, pad, tcp_conn-&gt;in.padding);
+				crypto_digest_update(tcp_conn-&gt;data_rx_tfm,
+						     &amp;sg, 1);
 			}
-			crypto_digest_final(conn-&gt;data_rx_tfm,
-					    (u8 *) &amp; conn-&gt;in.datadgst);
-			debug_tcp("rx digest 0x%x\n", conn-&gt;in.datadgst);
-			conn-&gt;in_progress = IN_PROGRESS_DDIGEST_RECV;
+			crypto_digest_final(tcp_conn-&gt;data_rx_tfm,
+					    (u8 *) &amp; tcp_conn-&gt;in.datadgst);
+			debug_tcp("rx digest 0x%x\n", tcp_conn-&gt;in.datadgst);
+			tcp_conn-&gt;in_progress = IN_PROGRESS_DDIGEST_RECV;
 		} else
-			conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+			tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
 	}
 
 	debug_tcp("f, processed %d from out of %d padding %d\n",
-	       conn-&gt;in.offset - offset, (int)len, conn-&gt;in.padding);
-	BUG_ON(conn-&gt;in.offset - offset &gt; len);
+	       tcp_conn-&gt;in.offset - offset, (int)len, tcp_conn-&gt;in.padding);
+	BUG_ON(tcp_conn-&gt;in.offset - offset &gt; len);
 
-	if (conn-&gt;in.offset - offset != len) {
+	if (tcp_conn-&gt;in.offset - offset != len) {
 		debug_tcp("continue to process %d bytes\n",
-		       (int)len - (conn-&gt;in.offset - offset));
+		       (int)len - (tcp_conn-&gt;in.offset - offset));
 		goto more;
 	}
 
 nomore:
-	processed = conn-&gt;in.offset - offset;
+	processed = tcp_conn-&gt;in.offset - offset;
 	BUG_ON(processed == 0);
 	return processed;
 
 again:
-	processed = conn-&gt;in.offset - offset;
+	processed = tcp_conn-&gt;in.offset - offset;
 	debug_tcp("c, processed %d from out of %d rd_desc_cnt %d\n",
 	          processed, (int)len, (int)rd_desc-&gt;count);
 	BUG_ON(processed == 0);
@@ -1246,6 +994,7 @@ iscsi_tcp_data_ready(struct sock *sk, int flag)
 static void
 iscsi_tcp_state_change(struct sock *sk)
 {
+	struct iscsi_tcp_conn *tcp_conn;
 	struct iscsi_conn *conn;
 	struct iscsi_session *session;
 	void (*old_state_change)(struct sock *);
@@ -1262,7 +1011,8 @@ iscsi_tcp_state_change(struct sock *sk)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 	}
 
-	old_state_change = conn-&gt;old_state_change;
+	tcp_conn = conn-&gt;dd_data;
+	old_state_change = tcp_conn-&gt;old_state_change;
 
 	read_unlock(&amp;sk-&gt;sk_callback_lock);
 
@@ -1277,23 +1027,26 @@ static void
 iscsi_write_space(struct sock *sk)
 {
 	struct iscsi_conn *conn = (struct iscsi_conn*)sk-&gt;sk_user_data;
-	conn-&gt;old_write_space(sk);
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	tcp_conn-&gt;old_write_space(sk);
 	debug_tcp("iscsi_write_space: cid %d\n", conn-&gt;id);
-	clear_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 }
 
 static void
 iscsi_conn_set_callbacks(struct iscsi_conn *conn)
 {
-	struct sock *sk = conn-&gt;sock-&gt;sk;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk = tcp_conn-&gt;sock-&gt;sk;
 
 	/* assign new callbacks */
 	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
 	sk-&gt;sk_user_data = conn;
-	conn-&gt;old_data_ready = sk-&gt;sk_data_ready;
-	conn-&gt;old_state_change = sk-&gt;sk_state_change;
-	conn-&gt;old_write_space = sk-&gt;sk_write_space;
+	tcp_conn-&gt;old_data_ready = sk-&gt;sk_data_ready;
+	tcp_conn-&gt;old_state_change = sk-&gt;sk_state_change;
+	tcp_conn-&gt;old_write_space = sk-&gt;sk_write_space;
 	sk-&gt;sk_data_ready = iscsi_tcp_data_ready;
 	sk-&gt;sk_state_change = iscsi_tcp_state_change;
 	sk-&gt;sk_write_space = iscsi_write_space;
@@ -1303,14 +1056,15 @@ iscsi_conn_set_callbacks(struct iscsi_conn *conn)
 static void
 iscsi_conn_restore_callbacks(struct iscsi_conn *conn)
 {
-	struct sock *sk = conn-&gt;sock-&gt;sk;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk = tcp_conn-&gt;sock-&gt;sk;
 
 	/* restore socket callbacks, see also: iscsi_conn_set_callbacks() */
 	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
 	sk-&gt;sk_user_data    = NULL;
-	sk-&gt;sk_data_ready   = conn-&gt;old_data_ready;
-	sk-&gt;sk_state_change = conn-&gt;old_state_change;
-	sk-&gt;sk_write_space  = conn-&gt;old_write_space;
+	sk-&gt;sk_data_ready   = tcp_conn-&gt;old_data_ready;
+	sk-&gt;sk_state_change = tcp_conn-&gt;old_state_change;
+	sk-&gt;sk_write_space  = tcp_conn-&gt;old_write_space;
 	sk-&gt;sk_no_check	 = 0;
 	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 }
@@ -1325,7 +1079,8 @@ iscsi_conn_restore_callbacks(struct iscsi_conn *conn)
 static inline int
 iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
 {
-	struct socket *sk = conn-&gt;sock;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct socket *sk = tcp_conn-&gt;sock;
 	int offset = buf-&gt;sg.offset + buf-&gt;sent;
 
 	/*
@@ -1339,7 +1094,8 @@ iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
 	if (buf-&gt;use_sendmsg)
 		return sock_no_sendpage(sk, buf-&gt;sg.page, offset, size, flags);
 	else
-		return conn-&gt;sendpage(sk, buf-&gt;sg.page, offset, size, flags);
+		return tcp_conn-&gt;sendpage(sk, buf-&gt;sg.page, offset, size,
+					  flags);
 }
 
 /**
@@ -1354,6 +1110,7 @@ iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
 static inline int
 iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
 {
+	struct iscsi_tcp_conn *tcp_conn;
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
 
@@ -1371,8 +1128,9 @@ iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
 			return -EAGAIN;
 		return 0;
 	} else if (res == -EAGAIN) {
-		conn-&gt;sendpage_failures_cnt++;
-		set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+		tcp_conn = conn-&gt;dd_data;
+		tcp_conn-&gt;sendpage_failures_cnt++;
+		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	} else if (res == -EPIPE)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 
@@ -1393,6 +1151,7 @@ static inline int
 iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 	       int *count, int *sent)
 {
+	struct iscsi_tcp_conn *tcp_conn;
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
 
@@ -1415,8 +1174,9 @@ iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 			return -EAGAIN;
 		return 0;
 	} else if (res == -EAGAIN) {
-		conn-&gt;sendpage_failures_cnt++;
-		set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+		tcp_conn = conn-&gt;dd_data;
+		tcp_conn-&gt;sendpage_failures_cnt++;
+		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	} else if (res == -EPIPE)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 
@@ -1424,30 +1184,35 @@ iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 }
 
 static inline void
-iscsi_data_digest_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_data_digest_init(struct iscsi_tcp_conn *tcp_conn,
+		      struct iscsi_cmd_task *ctask)
 {
-	BUG_ON(!conn-&gt;data_tx_tfm);
-	crypto_digest_init(conn-&gt;data_tx_tfm);
-	ctask-&gt;digest_count = 4;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	BUG_ON(!tcp_conn-&gt;data_tx_tfm);
+	crypto_digest_init(tcp_conn-&gt;data_tx_tfm);
+	tcp_ctask-&gt;digest_count = 4;
 }
 
 static int
 iscsi_digest_final_send(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 			struct iscsi_buf *buf, uint32_t *digest, int final)
 {
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	int rc = 0;
 	int sent = 0;
 
 	if (final)
-		crypto_digest_final(conn-&gt;data_tx_tfm, (u8*)digest);
+		crypto_digest_final(tcp_conn-&gt;data_tx_tfm, (u8*)digest);
 
 	iscsi_buf_init_virt(buf, (char*)digest, 4);
-	rc = iscsi_sendpage(conn, buf, &amp;ctask-&gt;digest_count, &amp;sent);
+	rc = iscsi_sendpage(conn, buf, &amp;tcp_ctask-&gt;digest_count, &amp;sent);
 	if (rc) {
-		ctask-&gt;datadigest = *digest;
-		ctask-&gt;xmstate |= XMSTATE_DATA_DIGEST;
+		tcp_ctask-&gt;datadigest = *digest;
+		tcp_ctask-&gt;xmstate |= XMSTATE_DATA_DIGEST;
 	} else
-		ctask-&gt;digest_count = 4;
+		tcp_ctask-&gt;digest_count = 4;
 	return rc;
 }
 
@@ -1468,12 +1233,13 @@ static void
 iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 			struct iscsi_r2t_info *r2t, int left)
 {
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_data *hdr;
 	struct iscsi_data_task *dtask;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
 	int new_offset;
 
-	dtask = mempool_alloc(ctask-&gt;datapool, GFP_ATOMIC);
+	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
 	BUG_ON(!dtask);
 	INIT_LIST_HEAD(&amp;dtask-&gt;item);
 	hdr = &amp;dtask-&gt;hdr;
@@ -1482,8 +1248,8 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
 	r2t-&gt;solicit_datasn++;
 	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr.lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;itt = ctask-&gt;hdr.itt;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
 	hdr-&gt;exp_statsn = r2t-&gt;exp_statsn;
 	new_offset = r2t-&gt;data_offset + r2t-&gt;sent;
 	hdr-&gt;offset = cpu_to_be32(new_offset);
@@ -1503,177 +1269,102 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	r2t-&gt;dtask = dtask;
 
 	if (sc-&gt;use_sg &amp;&amp; !iscsi_buf_left(&amp;r2t-&gt;sendbuf)) {
-		BUG_ON(ctask-&gt;bad_sg == r2t-&gt;sg);
+		BUG_ON(tcp_ctask-&gt;bad_sg == r2t-&gt;sg);
 		iscsi_buf_init_sg(&amp;r2t-&gt;sendbuf, r2t-&gt;sg);
 		r2t-&gt;sg += 1;
 	} else
-		iscsi_buf_init_iov(&amp;ctask-&gt;sendbuf,
+		iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
 			    (char*)sc-&gt;request_buffer + new_offset,
 			    r2t-&gt;data_count);
 
-	list_add(&amp;dtask-&gt;item, &amp;ctask-&gt;dataqueue);
+	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
 }
 
 static void
 iscsi_unsolicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_data *hdr;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_data_task *dtask;
 
-	dtask = mempool_alloc(ctask-&gt;datapool, GFP_ATOMIC);
+	dtask = mempool_alloc(tcp_ctask-&gt;datapool, GFP_ATOMIC);
 	BUG_ON(!dtask);
 	INIT_LIST_HEAD(&amp;dtask-&gt;item);
-	hdr = &amp;dtask-&gt;hdr;
-	memset(hdr, 0, sizeof(struct iscsi_data));
-	hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	hdr-&gt;datasn = cpu_to_be32(ctask-&gt;unsol_datasn);
-	ctask-&gt;unsol_datasn++;
-	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr.lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;itt = ctask-&gt;hdr.itt;
-	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
-	hdr-&gt;offset = cpu_to_be32(ctask-&gt;total_length -
-				  ctask-&gt;r2t_data_count -
-				  ctask-&gt;unsol_count);
-	if (ctask-&gt;unsol_count &gt; conn-&gt;max_xmit_dlength) {
-		hton24(hdr-&gt;dlength, conn-&gt;max_xmit_dlength);
-		ctask-&gt;data_count = conn-&gt;max_xmit_dlength;
-		hdr-&gt;flags = 0;
-	} else {
-		hton24(hdr-&gt;dlength, ctask-&gt;unsol_count);
-		ctask-&gt;data_count = ctask-&gt;unsol_count;
-		hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
-	}
 
-	iscsi_buf_init_virt(&amp;ctask-&gt;headbuf, (char*)hdr,
+	iscsi_prep_unsolicit_data_pdu(ctask, &amp;dtask-&gt;hdr,
+				      tcp_ctask-&gt;r2t_data_count);
+	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;headbuf, (char*)&amp;dtask-&gt;hdr,
 			   sizeof(struct iscsi_hdr));
 
-	list_add(&amp;dtask-&gt;item, &amp;ctask-&gt;dataqueue);
-
-	ctask-&gt;dtask = dtask;
+	list_add(&amp;dtask-&gt;item, &amp;tcp_ctask-&gt;dataqueue);
+	tcp_ctask-&gt;dtask = dtask;
 }
 
 /**
- * iscsi_cmd_init - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
+ * iscsi_tcp_cmd_init - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
  * @conn: iscsi connection
  * @ctask: scsi command task
  * @sc: scsi command
  **/
 static void
-iscsi_cmd_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
-		struct scsi_cmnd *sc)
+iscsi_tcp_cmd_init(struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_session *session = conn-&gt;session;
-
-	BUG_ON(__kfifo_len(ctask-&gt;r2tqueue));
-
-	INIT_LIST_HEAD(&amp;ctask-&gt;running);
-	ctask-&gt;sc = sc;
-	ctask-&gt;conn = conn;
-	ctask-&gt;hdr.opcode = ISCSI_OP_SCSI_CMD;
-	ctask-&gt;hdr.flags = ISCSI_ATTR_SIMPLE;
-	int_to_scsilun(sc-&gt;device-&gt;lun, (struct scsi_lun *)ctask-&gt;hdr.lun);
-	ctask-&gt;hdr.itt = ctask-&gt;itt | (conn-&gt;id &lt;&lt; CID_SHIFT) |
-			 (session-&gt;age &lt;&lt; AGE_SHIFT);
-	ctask-&gt;hdr.data_length = cpu_to_be32(sc-&gt;request_bufflen);
-	ctask-&gt;hdr.cmdsn = cpu_to_be32(session-&gt;cmdsn); session-&gt;cmdsn++;
-	ctask-&gt;hdr.exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
-	memcpy(ctask-&gt;hdr.cdb, sc-&gt;cmnd, sc-&gt;cmd_len);
-	memset(&amp;ctask-&gt;hdr.cdb[sc-&gt;cmd_len], 0, MAX_COMMAND_SIZE - sc-&gt;cmd_len);
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
-	ctask-&gt;mtask = NULL;
-	ctask-&gt;sent = 0;
-	ctask-&gt;sg_count = 0;
+	BUG_ON(__kfifo_len(tcp_ctask-&gt;r2tqueue));
 
-	ctask-&gt;total_length = sc-&gt;request_bufflen;
+	tcp_ctask-&gt;sent = 0;
+	tcp_ctask-&gt;sg_count = 0;
 
 	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
-		ctask-&gt;exp_r2tsn = 0;
-		ctask-&gt;hdr.flags |= ISCSI_FLAG_CMD_WRITE;
+		tcp_ctask-&gt;xmstate = XMSTATE_W_HDR;
+		tcp_ctask-&gt;exp_r2tsn = 0;
 		BUG_ON(ctask-&gt;total_length == 0);
+
 		if (sc-&gt;use_sg) {
 			struct scatterlist *sg = sc-&gt;request_buffer;
 
-			iscsi_buf_init_sg(&amp;ctask-&gt;sendbuf,
-					  &amp;sg[ctask-&gt;sg_count++]);
-			ctask-&gt;sg = sg;
-			ctask-&gt;bad_sg = sg + sc-&gt;use_sg;
-		} else {
-			iscsi_buf_init_iov(&amp;ctask-&gt;sendbuf, sc-&gt;request_buffer,
-					sc-&gt;request_bufflen);
-		}
+			iscsi_buf_init_sg(&amp;tcp_ctask-&gt;sendbuf,
+					  &amp;sg[tcp_ctask-&gt;sg_count++]);
+			tcp_ctask-&gt;sg = sg;
+			tcp_ctask-&gt;bad_sg = sg + sc-&gt;use_sg;
+		} else
+			iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf,
+					   sc-&gt;request_buffer,
+					   sc-&gt;request_bufflen);
 
-		/*
-		 * Write counters:
-		 *
-		 *	imm_count	bytes to be sent right after
-		 *			SCSI PDU Header
-		 *
-		 *	unsol_count	bytes(as Data-Out) to be sent
-		 *			without	R2T ack right after
-		 *			immediate data
-		 *
-		 *	r2t_data_count	bytes to be sent via R2T ack's
-		 *
-		 *      pad_count       bytes to be sent as zero-padding
-		 */
-		ctask-&gt;imm_count = 0;
-		ctask-&gt;unsol_count = 0;
-		ctask-&gt;unsol_datasn = 0;
-		ctask-&gt;xmstate = XMSTATE_W_HDR;
-		/* calculate write padding */
-		ctask-&gt;pad_count = ctask-&gt;total_length &amp; (ISCSI_PAD_LEN-1);
-		if (ctask-&gt;pad_count) {
-			ctask-&gt;pad_count = ISCSI_PAD_LEN - ctask-&gt;pad_count;
+		if (ctask-&gt;imm_count)
+			tcp_ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
+
+		tcp_ctask-&gt;pad_count = ctask-&gt;total_length &amp; (ISCSI_PAD_LEN-1);
+		if (tcp_ctask-&gt;pad_count) {
+			tcp_ctask-&gt;pad_count = ISCSI_PAD_LEN -
+							tcp_ctask-&gt;pad_count;
 			debug_scsi("write padding %d bytes\n",
-				ctask-&gt;pad_count);
-			ctask-&gt;xmstate |= XMSTATE_W_PAD;
+				   tcp_ctask-&gt;pad_count);
+			tcp_ctask-&gt;xmstate |= XMSTATE_W_PAD;
 		}
-		if (session-&gt;imm_data_en) {
-			if (ctask-&gt;total_length &gt;= session-&gt;first_burst)
-				ctask-&gt;imm_count = min(session-&gt;first_burst,
-							conn-&gt;max_xmit_dlength);
-			else
-				ctask-&gt;imm_count = min(ctask-&gt;total_length,
-							conn-&gt;max_xmit_dlength);
-			hton24(ctask-&gt;hdr.dlength, ctask-&gt;imm_count);
-			ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
-		} else
-			zero_data(ctask-&gt;hdr.dlength);
-
-		if (!session-&gt;initial_r2t_en)
-			ctask-&gt;unsol_count = min(session-&gt;first_burst,
-				ctask-&gt;total_length) - ctask-&gt;imm_count;
-		if (!ctask-&gt;unsol_count)
-			/* No unsolicit Data-Out's */
-			ctask-&gt;hdr.flags |= ISCSI_FLAG_CMD_FINAL;
-		else
-			ctask-&gt;xmstate |= XMSTATE_UNS_HDR | XMSTATE_UNS_INIT;
 
-		ctask-&gt;r2t_data_count = ctask-&gt;total_length -
+		if (ctask-&gt;unsol_count)
+			tcp_ctask-&gt;xmstate |= XMSTATE_UNS_HDR |
+						XMSTATE_UNS_INIT;
+		tcp_ctask-&gt;r2t_data_count = ctask-&gt;total_length -
 				    ctask-&gt;imm_count -
 				    ctask-&gt;unsol_count;
 
 		debug_scsi("cmd [itt %x total %d imm %d imm_data %d "
 			   "r2t_data %d]\n",
 			   ctask-&gt;itt, ctask-&gt;total_length, ctask-&gt;imm_count,
-			   ctask-&gt;unsol_count, ctask-&gt;r2t_data_count);
-	} else {
-		ctask-&gt;hdr.flags |= ISCSI_FLAG_CMD_FINAL;
-		if (sc-&gt;sc_data_direction == DMA_FROM_DEVICE)
-			ctask-&gt;hdr.flags |= ISCSI_FLAG_CMD_READ;
-		ctask-&gt;datasn = 0;
-		ctask-&gt;xmstate = XMSTATE_R_HDR;
-		zero_data(ctask-&gt;hdr.dlength);
-	}
+			   ctask-&gt;unsol_count, tcp_ctask-&gt;r2t_data_count);
+	} else
+		tcp_ctask-&gt;xmstate = XMSTATE_R_HDR;
 
-	iscsi_buf_init_virt(&amp;ctask-&gt;headbuf, (char*)&amp;ctask-&gt;hdr,
+	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;headbuf, (char*)ctask-&gt;hdr,
 			    sizeof(struct iscsi_hdr));
-	conn-&gt;scsicmd_pdus_cnt++;
 }
 
 /**
- * iscsi_mtask_xmit - xmit management(immediate) task
+ * iscsi_tcp_mtask_xmit - xmit management(immediate) task
  * @conn: iscsi connection
  * @mtask: task management task
  *
@@ -1687,70 +1378,87 @@ iscsi_cmd_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
  *		IN_PROGRESS_IMM_DATA - PDU Data xmit in progress
  **/
 static int
-iscsi_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
+iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
 {
+	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
 
 	debug_scsi("mtask deq [cid %d state %x itt 0x%x]\n",
-		conn-&gt;id, mtask-&gt;xmstate, mtask-&gt;itt);
+		conn-&gt;id, tcp_mtask-&gt;xmstate, mtask-&gt;itt);
 
-	if (mtask-&gt;xmstate &amp; XMSTATE_IMM_HDR) {
-		mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_HDR;
+	if (tcp_mtask-&gt;xmstate &amp; XMSTATE_IMM_HDR) {
+		tcp_mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_HDR;
 		if (mtask-&gt;data_count)
-			mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
+			tcp_mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
 		if (conn-&gt;c_stage != ISCSI_CONN_INITIAL_STAGE &amp;&amp;
 		    conn-&gt;stop_stage != STOP_CONN_RECOVER &amp;&amp;
 		    conn-&gt;hdrdgst_en)
-			iscsi_hdr_digest(conn, &amp;mtask-&gt;headbuf,
-					(u8*)mtask-&gt;hdrext);
-		if (iscsi_sendhdr(conn, &amp;mtask-&gt;headbuf, mtask-&gt;data_count)) {
-			mtask-&gt;xmstate |= XMSTATE_IMM_HDR;
+			iscsi_hdr_digest(conn, &amp;tcp_mtask-&gt;headbuf,
+					(u8*)tcp_mtask-&gt;hdrext);
+		if (iscsi_sendhdr(conn, &amp;tcp_mtask-&gt;headbuf,
+				  mtask-&gt;data_count)) {
+			tcp_mtask-&gt;xmstate |= XMSTATE_IMM_HDR;
 			if (mtask-&gt;data_count)
-				mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
+				tcp_mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
 			return -EAGAIN;
 		}
 	}
 
-	if (mtask-&gt;xmstate &amp; XMSTATE_IMM_DATA) {
+	if (tcp_mtask-&gt;xmstate &amp; XMSTATE_IMM_DATA) {
 		BUG_ON(!mtask-&gt;data_count);
-		mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
+		tcp_mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
 		/* FIXME: implement.
 		 * Virtual buffer could be spreaded across multiple pages...
 		 */
 		do {
-			if (iscsi_sendpage(conn, &amp;mtask-&gt;sendbuf,
-				   &amp;mtask-&gt;data_count, &amp;mtask-&gt;sent)) {
-				mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
+			if (iscsi_sendpage(conn, &amp;tcp_mtask-&gt;sendbuf,
+				   &amp;mtask-&gt;data_count, &amp;tcp_mtask-&gt;sent)) {
+				tcp_mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
 				return -EAGAIN;
 			}
 		} while (mtask-&gt;data_count);
 	}
 
-	BUG_ON(mtask-&gt;xmstate != XMSTATE_IDLE);
+	BUG_ON(tcp_mtask-&gt;xmstate != XMSTATE_IDLE);
+	if (mtask-&gt;hdr-&gt;itt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		struct iscsi_session *session = conn-&gt;session;
+
+		spin_lock_bh(&amp;session-&gt;lock);
+		list_del(&amp;conn-&gt;mtask-&gt;running);
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;mtask,
+			    sizeof(void*));
+		spin_unlock_bh(&amp;session-&gt;lock);
+	}
 	return 0;
 }
 
 static inline int
-handle_xmstate_r_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+handle_xmstate_r_hdr(struct iscsi_conn *conn,
+		     struct iscsi_tcp_cmd_task *tcp_ctask)
 {
-	ctask-&gt;xmstate &amp;= ~XMSTATE_R_HDR;
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_R_HDR;
 	if (conn-&gt;hdrdgst_en)
-		iscsi_hdr_digest(conn, &amp;ctask-&gt;headbuf, (u8*)ctask-&gt;hdrext);
-	if (!iscsi_sendhdr(conn, &amp;ctask-&gt;headbuf, 0)) {
-		BUG_ON(ctask-&gt;xmstate != XMSTATE_IDLE);
+		iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
+				 (u8*)tcp_ctask-&gt;hdrext);
+	if (!iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, 0)) {
+		BUG_ON(tcp_ctask-&gt;xmstate != XMSTATE_IDLE);
 		return 0; /* wait for Data-In */
 	}
-	ctask-&gt;xmstate |= XMSTATE_R_HDR;
+	tcp_ctask-&gt;xmstate |= XMSTATE_R_HDR;
 	return -EAGAIN;
 }
 
 static inline int
-handle_xmstate_w_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+handle_xmstate_w_hdr(struct iscsi_conn *conn,
+		     struct iscsi_cmd_task *ctask)
 {
-	ctask-&gt;xmstate &amp;= ~XMSTATE_W_HDR;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_W_HDR;
 	if (conn-&gt;hdrdgst_en)
-		iscsi_hdr_digest(conn, &amp;ctask-&gt;headbuf, (u8*)ctask-&gt;hdrext);
-	if (iscsi_sendhdr(conn, &amp;ctask-&gt;headbuf, ctask-&gt;imm_count)) {
-		ctask-&gt;xmstate |= XMSTATE_W_HDR;
+		iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
+				 (u8*)tcp_ctask-&gt;hdrext);
+	if (iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;imm_count)) {
+		tcp_ctask-&gt;xmstate |= XMSTATE_W_HDR;
 		return -EAGAIN;
 	}
 	return 0;
@@ -1760,13 +1468,15 @@ static inline int
 handle_xmstate_data_digest(struct iscsi_conn *conn,
 			   struct iscsi_cmd_task *ctask)
 {
-	ctask-&gt;xmstate &amp;= ~XMSTATE_DATA_DIGEST;
-	debug_tcp("resent data digest 0x%x\n", ctask-&gt;datadigest);
-	if (iscsi_digest_final_send(conn, ctask, &amp;ctask-&gt;immbuf,
-				    &amp;ctask-&gt;datadigest, 0)) {
-		ctask-&gt;xmstate |= XMSTATE_DATA_DIGEST;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_DATA_DIGEST;
+	debug_tcp("resent data digest 0x%x\n", tcp_ctask-&gt;datadigest);
+	if (iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
+				    &amp;tcp_ctask-&gt;datadigest, 0)) {
+		tcp_ctask-&gt;xmstate |= XMSTATE_DATA_DIGEST;
 		debug_tcp("resent data digest 0x%x fail!\n",
-			  ctask-&gt;datadigest);
+			  tcp_ctask-&gt;datadigest);
 		return -EAGAIN;
 	}
 	return 0;
@@ -1775,44 +1485,47 @@ handle_xmstate_data_digest(struct iscsi_conn *conn,
 static inline int
 handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
 	BUG_ON(!ctask-&gt;imm_count);
-	ctask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
 
 	if (conn-&gt;datadgst_en) {
-		iscsi_data_digest_init(conn, ctask);
-		ctask-&gt;immdigest = 0;
+		iscsi_data_digest_init(tcp_conn, ctask);
+		tcp_ctask-&gt;immdigest = 0;
 	}
 
 	for (;;) {
-		if (iscsi_sendpage(conn, &amp;ctask-&gt;sendbuf, &amp;ctask-&gt;imm_count,
-				   &amp;ctask-&gt;sent)) {
-			ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
+		if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;ctask-&gt;imm_count,
+				   &amp;tcp_ctask-&gt;sent)) {
+			tcp_ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
 			if (conn-&gt;datadgst_en) {
-				crypto_digest_final(conn-&gt;data_tx_tfm,
-						(u8*)&amp;ctask-&gt;immdigest);
+				crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
+						(u8*)&amp;tcp_ctask-&gt;immdigest);
 				debug_tcp("tx imm sendpage fail 0x%x\n",
-					  ctask-&gt;datadigest);
+					  tcp_ctask-&gt;datadigest);
 			}
 			return -EAGAIN;
 		}
 		if (conn-&gt;datadgst_en)
-			crypto_digest_update(conn-&gt;data_tx_tfm,
-					     &amp;ctask-&gt;sendbuf.sg, 1);
+			crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
+					     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
 
 		if (!ctask-&gt;imm_count)
 			break;
-		iscsi_buf_init_sg(&amp;ctask-&gt;sendbuf,
-				  &amp;ctask-&gt;sg[ctask-&gt;sg_count++]);
+		iscsi_buf_init_sg(&amp;tcp_ctask-&gt;sendbuf,
+				  &amp;tcp_ctask-&gt;sg[tcp_ctask-&gt;sg_count++]);
 	}
 
-	if (conn-&gt;datadgst_en &amp;&amp; !(ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
-		if (iscsi_digest_final_send(conn, ctask, &amp;ctask-&gt;immbuf,
-				            &amp;ctask-&gt;immdigest, 1)) {
+	if (conn-&gt;datadgst_en &amp;&amp; !(tcp_ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
+		if (iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
+				            &amp;tcp_ctask-&gt;immdigest, 1)) {
 			debug_tcp("sending imm digest 0x%x fail!\n",
-				  ctask-&gt;immdigest);
+				  tcp_ctask-&gt;immdigest);
 			return -EAGAIN;
 		}
-		debug_tcp("sending imm digest 0x%x\n", ctask-&gt;immdigest);
+		debug_tcp("sending imm digest 0x%x\n", tcp_ctask-&gt;immdigest);
 	}
 
 	return 0;
@@ -1821,52 +1534,55 @@ handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 static inline int
 handle_xmstate_uns_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_data_task *dtask;
 
-	ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
-	if (ctask-&gt;xmstate &amp; XMSTATE_UNS_INIT) {
+	tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_INIT) {
 		iscsi_unsolicit_data_init(conn, ctask);
-		BUG_ON(!ctask-&gt;dtask);
-		dtask = ctask-&gt;dtask;
+		BUG_ON(!tcp_ctask-&gt;dtask);
+		dtask = tcp_ctask-&gt;dtask;
 		if (conn-&gt;hdrdgst_en)
-			iscsi_hdr_digest(conn, &amp;ctask-&gt;headbuf,
+			iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
 					(u8*)dtask-&gt;hdrext);
-		ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_INIT;
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_INIT;
 	}
-	if (iscsi_sendhdr(conn, &amp;ctask-&gt;headbuf, ctask-&gt;data_count)) {
-		ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
-		ctask-&gt;xmstate |= XMSTATE_UNS_HDR;
+	if (iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;data_count)) {
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
+		tcp_ctask-&gt;xmstate |= XMSTATE_UNS_HDR;
 		return -EAGAIN;
 	}
 
 	debug_scsi("uns dout [itt 0x%x dlen %d sent %d]\n",
-		   ctask-&gt;itt, ctask-&gt;unsol_count, ctask-&gt;sent);
+		   ctask-&gt;itt, ctask-&gt;unsol_count, tcp_ctask-&gt;sent);
 	return 0;
 }
 
 static inline int
 handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_data_task *dtask = ctask-&gt;dtask;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_data_task *dtask = tcp_ctask-&gt;dtask;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 
 	BUG_ON(!ctask-&gt;data_count);
-	ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
 
 	if (conn-&gt;datadgst_en) {
-		iscsi_data_digest_init(conn, ctask);
+		iscsi_data_digest_init(tcp_conn, ctask);
 		dtask-&gt;digest = 0;
 	}
 
 	for (;;) {
-		int start = ctask-&gt;sent;
+		int start = tcp_ctask-&gt;sent;
 
-		if (iscsi_sendpage(conn, &amp;ctask-&gt;sendbuf, &amp;ctask-&gt;data_count,
-				   &amp;ctask-&gt;sent)) {
-			ctask-&gt;unsol_count -= ctask-&gt;sent - start;
-			ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
+		if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf,
+				   &amp;ctask-&gt;data_count, &amp;tcp_ctask-&gt;sent)) {
+			ctask-&gt;unsol_count -= tcp_ctask-&gt;sent - start;
+			tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
 			/* will continue with this ctask later.. */
 			if (conn-&gt;datadgst_en) {
-				crypto_digest_final(conn-&gt;data_tx_tfm,
+				crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
 						(u8 *)&amp;dtask-&gt;digest);
 				debug_tcp("tx uns data fail 0x%x\n",
 					  dtask-&gt;digest);
@@ -1874,21 +1590,21 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 			return -EAGAIN;
 		}
 
-		BUG_ON(ctask-&gt;sent &gt; ctask-&gt;total_length);
-		ctask-&gt;unsol_count -= ctask-&gt;sent - start;
+		BUG_ON(tcp_ctask-&gt;sent &gt; ctask-&gt;total_length);
+		ctask-&gt;unsol_count -= tcp_ctask-&gt;sent - start;
 
 		/*
 		 * XXX:we may run here with un-initial sendbuf.
 		 * so pass it
 		 */
-		if (conn-&gt;datadgst_en &amp;&amp; ctask-&gt;sent - start &gt; 0)
-			crypto_digest_update(conn-&gt;data_tx_tfm,
-					     &amp;ctask-&gt;sendbuf.sg, 1);
+		if (conn-&gt;datadgst_en &amp;&amp; tcp_ctask-&gt;sent - start &gt; 0)
+			crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
+					     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
 
 		if (!ctask-&gt;data_count)
 			break;
-		iscsi_buf_init_sg(&amp;ctask-&gt;sendbuf,
-				  &amp;ctask-&gt;sg[ctask-&gt;sg_count++]);
+		iscsi_buf_init_sg(&amp;tcp_ctask-&gt;sendbuf,
+				  &amp;tcp_ctask-&gt;sg[tcp_ctask-&gt;sg_count++]);
 	}
 	BUG_ON(ctask-&gt;unsol_count &lt; 0);
 
@@ -1908,11 +1624,11 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 			debug_tcp("sending uns digest 0x%x, more uns\n",
 				  dtask-&gt;digest);
 		}
-		ctask-&gt;xmstate |= XMSTATE_UNS_INIT;
+		tcp_ctask-&gt;xmstate |= XMSTATE_UNS_INIT;
 		return 1;
 	}
 
-	if (conn-&gt;datadgst_en &amp;&amp; !(ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
+	if (conn-&gt;datadgst_en &amp;&amp; !(tcp_ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
 		if (iscsi_digest_final_send(conn, ctask,
 					    &amp;dtask-&gt;digestbuf,
 					    &amp;dtask-&gt;digest, 1)) {
@@ -1930,15 +1646,17 @@ static inline int
 handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_r2t_info *r2t = ctask-&gt;r2t;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_r2t_info *r2t = tcp_ctask-&gt;r2t;
 	struct iscsi_data_task *dtask = r2t-&gt;dtask;
 	int left;
 
-	ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
-	ctask-&gt;dtask = dtask;
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
+	tcp_ctask-&gt;dtask = dtask;
 
 	if (conn-&gt;datadgst_en) {
-		iscsi_data_digest_init(conn, ctask);
+		iscsi_data_digest_init(tcp_conn, ctask);
 		dtask-&gt;digest = 0;
 	}
 solicit_again:
@@ -1949,10 +1667,10 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		goto data_out_done;
 
 	if (iscsi_sendpage(conn, &amp;r2t-&gt;sendbuf, &amp;r2t-&gt;data_count, &amp;r2t-&gt;sent)) {
-		ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
 		/* will continue with this ctask later.. */
 		if (conn-&gt;datadgst_en) {
-			crypto_digest_final(conn-&gt;data_tx_tfm,
+			crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
 					  (u8 *)&amp;dtask-&gt;digest);
 			debug_tcp("r2t data send fail 0x%x\n", dtask-&gt;digest);
 		}
@@ -1961,12 +1679,13 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	BUG_ON(r2t-&gt;data_count &lt; 0);
 	if (conn-&gt;datadgst_en)
-		crypto_digest_update(conn-&gt;data_tx_tfm, &amp;r2t-&gt;sendbuf.sg, 1);
+		crypto_digest_update(tcp_conn-&gt;data_tx_tfm, &amp;r2t-&gt;sendbuf.sg,
+				     1);
 
 	if (r2t-&gt;data_count) {
 		BUG_ON(ctask-&gt;sc-&gt;use_sg == 0);
 		if (!iscsi_buf_left(&amp;r2t-&gt;sendbuf)) {
-			BUG_ON(ctask-&gt;bad_sg == r2t-&gt;sg);
+			BUG_ON(tcp_ctask-&gt;bad_sg == r2t-&gt;sg);
 			iscsi_buf_init_sg(&amp;r2t-&gt;sendbuf, r2t-&gt;sg);
 			r2t-&gt;sg += 1;
 		}
@@ -1993,8 +1712,8 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 				  dtask-&gt;digest);
 		}
 		iscsi_solicit_data_cont(conn, ctask, r2t, left);
-		ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
-		ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
 		return 1;
 	}
 
@@ -2002,7 +1721,7 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	 * Done with this R2T. Check if there are more
 	 * outstanding R2Ts ready to be processed.
 	 */
-	BUG_ON(ctask-&gt;r2t_data_count - r2t-&gt;data_length &lt; 0);
+	BUG_ON(tcp_ctask-&gt;r2t_data_count - r2t-&gt;data_length &lt; 0);
 	if (conn-&gt;datadgst_en) {
 		if (iscsi_digest_final_send(conn, ctask, &amp;dtask-&gt;digestbuf,
 					    &amp;dtask-&gt;digest, 1)) {
@@ -2013,15 +1732,15 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		debug_tcp("r2t done dout digest 0x%x\n", dtask-&gt;digest);
 	}
 
-	ctask-&gt;r2t_data_count -= r2t-&gt;data_length;
-	ctask-&gt;r2t = NULL;
+	tcp_ctask-&gt;r2t_data_count -= r2t-&gt;data_length;
+	tcp_ctask-&gt;r2t = NULL;
 	spin_lock_bh(&amp;session-&gt;lock);
-	__kfifo_put(ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
+	__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
 	spin_unlock_bh(&amp;session-&gt;lock);
-	if (__kfifo_get(ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*))) {
-		ctask-&gt;r2t = r2t;
-		ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
-		ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
+	if (__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*))) {
+		tcp_ctask-&gt;r2t = r2t;
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
 		return 1;
 	}
 
@@ -2031,29 +1750,34 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 static inline int
 handle_xmstate_w_pad(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_data_task *dtask = ctask-&gt;dtask;
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_data_task *dtask = tcp_ctask-&gt;dtask;
 	int sent;
 
-	ctask-&gt;xmstate &amp;= ~XMSTATE_W_PAD;
-	iscsi_buf_init_virt(&amp;ctask-&gt;sendbuf, (char*)&amp;ctask-&gt;pad,
-			    ctask-&gt;pad_count);
-	if (iscsi_sendpage(conn, &amp;ctask-&gt;sendbuf, &amp;ctask-&gt;pad_count, &amp;sent)) {
-		ctask-&gt;xmstate |= XMSTATE_W_PAD;
+	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_W_PAD;
+	iscsi_buf_init_virt(&amp;tcp_ctask-&gt;sendbuf, (char*)&amp;tcp_ctask-&gt;pad,
+			    tcp_ctask-&gt;pad_count);
+	if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;tcp_ctask-&gt;pad_count,
+			   &amp;sent)) {
+		tcp_ctask-&gt;xmstate |= XMSTATE_W_PAD;
 		return -EAGAIN;
 	}
 
 	if (conn-&gt;datadgst_en) {
-		crypto_digest_update(conn-&gt;data_tx_tfm, &amp;ctask-&gt;sendbuf.sg, 1);
+		crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
+				     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
 		/* imm data? */
 		if (!dtask) {
-			if (iscsi_digest_final_send(conn, ctask, &amp;ctask-&gt;immbuf,
-						    &amp;ctask-&gt;immdigest, 1)) {
+			if (iscsi_digest_final_send(conn, ctask,
+						    &amp;tcp_ctask-&gt;immbuf,
+						    &amp;tcp_ctask-&gt;immdigest, 1)) {
 				debug_tcp("send padding digest 0x%x"
-					  "fail!\n", ctask-&gt;immdigest);
+					  "fail!\n", tcp_ctask-&gt;immdigest);
 				return -EAGAIN;
 			}
 			debug_tcp("done with padding, digest 0x%x\n",
-				  ctask-&gt;datadigest);
+				  tcp_ctask-&gt;datadigest);
 		} else {
 			if (iscsi_digest_final_send(conn, ctask,
 						    &amp;dtask-&gt;digestbuf,
@@ -2071,12 +1795,13 @@ handle_xmstate_w_pad(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 }
 
 static int
-iscsi_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	int rc = 0;
 
 	debug_scsi("ctask deq [cid %d xmstate %x itt 0x%x]\n",
-		conn-&gt;id, ctask-&gt;xmstate, ctask-&gt;itt);
+		conn-&gt;id, tcp_ctask-&gt;xmstate, ctask-&gt;itt);
 
 	/*
 	 * serialize with TMF AbortTask
@@ -2084,40 +1809,40 @@ iscsi_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	if (ctask-&gt;mtask)
 		return rc;
 
-	if (ctask-&gt;xmstate &amp; XMSTATE_R_HDR) {
-		rc = handle_xmstate_r_hdr(conn, ctask);
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_R_HDR) {
+		rc = handle_xmstate_r_hdr(conn, tcp_ctask);
 		return rc;
 	}
 
-	if (ctask-&gt;xmstate &amp; XMSTATE_W_HDR) {
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_W_HDR) {
 		rc = handle_xmstate_w_hdr(conn, ctask);
 		if (rc)
 			return rc;
 	}
 
 	/* XXX: for data digest xmit recover */
-	if (ctask-&gt;xmstate &amp; XMSTATE_DATA_DIGEST) {
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_DATA_DIGEST) {
 		rc = handle_xmstate_data_digest(conn, ctask);
 		if (rc)
 			return rc;
 	}
 
-	if (ctask-&gt;xmstate &amp; XMSTATE_IMM_DATA) {
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_IMM_DATA) {
 		rc = handle_xmstate_imm_data(conn, ctask);
 		if (rc)
 			return rc;
 	}
 
-	if (ctask-&gt;xmstate &amp; XMSTATE_UNS_HDR) {
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_HDR) {
 		BUG_ON(!ctask-&gt;unsol_count);
-		ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_HDR;
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_HDR;
 unsolicit_head_again:
 		rc = handle_xmstate_uns_hdr(conn, ctask);
 		if (rc)
 			return rc;
 	}
 
-	if (ctask-&gt;xmstate &amp; XMSTATE_UNS_DATA) {
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_DATA) {
 		rc = handle_xmstate_uns_data(conn, ctask);
 		if (rc == 1)
 			goto unsolicit_head_again;
@@ -2126,22 +1851,22 @@ iscsi_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		goto done;
 	}
 
-	if (ctask-&gt;xmstate &amp; XMSTATE_SOL_HDR) {
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_SOL_HDR) {
 		struct iscsi_r2t_info *r2t;
 
-		ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
-		ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
-		if (!ctask-&gt;r2t)
-			__kfifo_get(ctask-&gt;r2tqueue, (void*)&amp;ctask-&gt;r2t,
+		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_HDR;
+		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
+		if (!tcp_ctask-&gt;r2t)
+			__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;tcp_ctask-&gt;r2t,
 				    sizeof(void*));
 solicit_head_again:
-		r2t = ctask-&gt;r2t;
+		r2t = tcp_ctask-&gt;r2t;
 		if (conn-&gt;hdrdgst_en)
 			iscsi_hdr_digest(conn, &amp;r2t-&gt;headbuf,
 					(u8*)r2t-&gt;dtask-&gt;hdrext);
 		if (iscsi_sendhdr(conn, &amp;r2t-&gt;headbuf, r2t-&gt;data_count)) {
-			ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
-			ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
+			tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
+			tcp_ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
 			return -EAGAIN;
 		}
 
@@ -2150,7 +1875,7 @@ iscsi_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 			r2t-&gt;sent);
 	}
 
-	if (ctask-&gt;xmstate &amp; XMSTATE_SOL_DATA) {
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_SOL_DATA) {
 		rc = handle_xmstate_sol_data(conn, ctask);
 		if (rc == 1)
 			goto solicit_head_again;
@@ -2163,529 +1888,116 @@ iscsi_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	 * Last thing to check is whether we need to send write
 	 * padding. Note that we check for xmstate equality, not just the bit.
 	 */
-	if (ctask-&gt;xmstate == XMSTATE_W_PAD)
+	if (tcp_ctask-&gt;xmstate == XMSTATE_W_PAD)
 		rc = handle_xmstate_w_pad(conn, ctask);
 
 	return rc;
 }
 
-/**
- * iscsi_data_xmit - xmit any command into the scheduled connection
- * @conn: iscsi connection
- *
- * Notes:
- *	The function can return -EAGAIN in which case the caller must
- *	re-schedule it again later or recover. '0' return code means
- *	successful xmit.
- **/
-static int
-iscsi_data_xmit(struct iscsi_conn *conn)
+static struct iscsi_cls_conn *
+iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 {
-	if (unlikely(conn-&gt;suspend_tx)) {
-		debug_tcp("conn %d Tx suspended!\n", conn-&gt;id);
-		return 0;
-	}
+	struct iscsi_conn *conn;
+	struct iscsi_cls_conn *cls_conn;
+	struct iscsi_tcp_conn *tcp_conn;
 
+	cls_conn = iscsi_conn_setup(cls_session, conn_idx);
+	if (!cls_conn)
+		return NULL;
+	conn = cls_conn-&gt;dd_data;
 	/*
-	 * Transmit in the following order:
-	 *
-	 * 1) un-finished xmit (ctask or mtask)
-	 * 2) immediate control PDUs
-	 * 3) write data
-	 * 4) SCSI commands
-	 * 5) non-immediate control PDUs
-	 *
-	 * No need to lock around __kfifo_get as long as
-	 * there's one producer and one consumer.
+	 * due to strange issues with iser these are not set
+	 * in iscsi_conn_setup
 	 */
+	conn-&gt;max_recv_dlength = DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH;
 
-	BUG_ON(conn-&gt;ctask &amp;&amp; conn-&gt;mtask);
-
-	if (conn-&gt;ctask) {
-		if (iscsi_ctask_xmit(conn, conn-&gt;ctask))
-			goto again;
-		/* done with this in-progress ctask */
-		conn-&gt;ctask = NULL;
-	}
-	if (conn-&gt;mtask) {
-	        if (iscsi_mtask_xmit(conn, conn-&gt;mtask))
-		        goto again;
-		/* done with this in-progress mtask */
-		conn-&gt;mtask = NULL;
-	}
-
-	/* process immediate first */
-        if (unlikely(__kfifo_len(conn-&gt;immqueue))) {
-		struct iscsi_session *session = conn-&gt;session;
-	        while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;conn-&gt;mtask,
-			           sizeof(void*))) {
-		        if (iscsi_mtask_xmit(conn, conn-&gt;mtask))
-			        goto again;
-
-		        if (conn-&gt;mtask-&gt;hdr.itt ==
-					cpu_to_be32(ISCSI_RESERVED_TAG)) {
-			        spin_lock_bh(&amp;session-&gt;lock);
-			        __kfifo_put(session-&gt;mgmtpool.queue,
-					    (void*)&amp;conn-&gt;mtask, sizeof(void*));
-			        spin_unlock_bh(&amp;session-&gt;lock);
-		        }
-	        }
-		/* done with this mtask */
-		conn-&gt;mtask = NULL;
-	}
-
-	/* process write queue */
-	while (__kfifo_get(conn-&gt;writequeue, (void*)&amp;conn-&gt;ctask,
-			   sizeof(void*))) {
-		if (iscsi_ctask_xmit(conn, conn-&gt;ctask))
-			goto again;
-	}
-
-	/* process command queue */
-	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;conn-&gt;ctask,
-			   sizeof(void*))) {
-		list_add_tail(&amp;conn-&gt;ctask-&gt;running, &amp;conn-&gt;run_list);
-		if (iscsi_ctask_xmit(conn, conn-&gt;ctask))
-			goto again;
-	}
-	/* done with this ctask */
-	conn-&gt;ctask = NULL;
-
-	/* process the rest control plane PDUs, if any */
-        if (unlikely(__kfifo_len(conn-&gt;mgmtqueue))) {
-		struct iscsi_session *session = conn-&gt;session;
-
-	        while (__kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;conn-&gt;mtask,
-			           sizeof(void*))) {
-		        if (iscsi_mtask_xmit(conn, conn-&gt;mtask))
-			        goto again;
+	tcp_conn = kzalloc(sizeof(*tcp_conn), GFP_KERNEL);
+	if (!tcp_conn)
+		goto tcp_conn_alloc_fail;
 
-		        if (conn-&gt;mtask-&gt;hdr.itt ==
-					cpu_to_be32(ISCSI_RESERVED_TAG)) {
-			        spin_lock_bh(&amp;session-&gt;lock);
-			        __kfifo_put(session-&gt;mgmtpool.queue,
-					    (void*)&amp;conn-&gt;mtask,
-				            sizeof(void*));
-			        spin_unlock_bh(&amp;session-&gt;lock);
-		        }
-	        }
-		/* done with this mtask */
-		conn-&gt;mtask = NULL;
-	}
+	conn-&gt;dd_data = tcp_conn;
+	tcp_conn-&gt;iscsi_conn = conn;
+	tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+	/* initial operational parameters */
+	tcp_conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
+	tcp_conn-&gt;data_size = DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH;
 
-	return 0;
+	/* allocate initial PDU receive place holder */
+	if (tcp_conn-&gt;data_size &lt;= PAGE_SIZE)
+		tcp_conn-&gt;data = kmalloc(tcp_conn-&gt;data_size, GFP_KERNEL);
+	else
+		tcp_conn-&gt;data = (void*)__get_free_pages(GFP_KERNEL,
+					get_order(tcp_conn-&gt;data_size));
+	if (!tcp_conn-&gt;data)
+		goto max_recv_dlenght_alloc_fail;
 
-again:
-	if (unlikely(conn-&gt;suspend_tx))
-		return 0;
+	return cls_conn;
 
-	return -EAGAIN;
+max_recv_dlenght_alloc_fail:
+	kfree(tcp_conn);
+tcp_conn_alloc_fail:
+	iscsi_conn_teardown(cls_conn);
+	return NULL;
 }
 
 static void
-iscsi_xmitworker(void *data)
+iscsi_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)
 {
-	struct iscsi_conn *conn = data;
-
-	/*
-	 * serialize Xmit worker on a per-connection basis.
-	 */
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-	if (iscsi_data_xmit(conn))
-		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
-	mutex_unlock(&amp;conn-&gt;xmitmutex);
-}
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int digest = 0;
 
-enum {
-	FAILURE_BAD_HOST = 1,
-	FAILURE_SESSION_FAILED,
-	FAILURE_SESSION_FREED,
-	FAILURE_WINDOW_CLOSED,
-	FAILURE_SESSION_TERMINATE,
-	FAILURE_SESSION_RECOVERY_TIMEOUT,
-};
+	if (conn-&gt;hdrdgst_en || conn-&gt;datadgst_en)
+		digest = 1;
 
-static int
-iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
-{
-	struct Scsi_Host *host;
-	int reason = 0;
-	struct iscsi_session *session;
-	struct iscsi_conn *conn = NULL;
-	struct iscsi_cmd_task *ctask = NULL;
+	iscsi_conn_teardown(cls_conn);
 
-	sc-&gt;scsi_done = done;
-	sc-&gt;result = 0;
+	/* now free tcp_conn */
+	if (digest) {
+		if (tcp_conn-&gt;tx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;tx_tfm);
+		if (tcp_conn-&gt;rx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;rx_tfm);
+		if (tcp_conn-&gt;data_tx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
+		if (tcp_conn-&gt;data_rx_tfm)
+			crypto_free_tfm(tcp_conn-&gt;data_rx_tfm);
+	}
 
-	host = sc-&gt;device-&gt;host;
-	session = iscsi_hostdata(host-&gt;hostdata);
+	/* free conn-&gt;data, size = MaxRecvDataSegmentLength */
+	if (tcp_conn-&gt;data_size &lt;= PAGE_SIZE)
+		kfree(tcp_conn-&gt;data);
+	else
+		free_pages((unsigned long)tcp_conn-&gt;data,
+			   get_order(tcp_conn-&gt;data_size));
+	kfree(tcp_conn);
+}
 
-	spin_lock(&amp;session-&gt;lock);
+static int
+iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
+		    struct iscsi_cls_conn *cls_conn, uint32_t transport_fd,
+		    int is_leading)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct sock *sk;
+	struct socket *sock;
+	int err;
 
-	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
-		if (session-&gt;recovery_failed) {
-			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
-			goto fault;
-		} else if (session-&gt;state == ISCSI_STATE_FAILED) {
-			reason = FAILURE_SESSION_FAILED;
-			goto reject;
-		} else if (session-&gt;state == ISCSI_STATE_TERMINATE) {
-			reason = FAILURE_SESSION_TERMINATE;
-			goto fault;
-		}
-		reason = FAILURE_SESSION_FREED;
-		goto fault;
+	/* lookup for existing socket */
+	sock = sockfd_lookup(transport_fd, &amp;err);
+	if (!sock) {
+		printk(KERN_ERR "iscsi_tcp: sockfd_lookup failed %d\n", err);
+		return -EEXIST;
 	}
 
-	/*
-	 * Check for iSCSI window and take care of CmdSN wrap-around
-	 */
-	if ((int)(session-&gt;max_cmdsn - session-&gt;cmdsn) &lt; 0) {
-		reason = FAILURE_WINDOW_CLOSED;
-		goto reject;
-	}
+	err = iscsi_conn_bind(cls_session, cls_conn, is_leading);
+	if (err)
+		return err;
 
-	conn = session-&gt;leadconn;
-
-	__kfifo_get(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
-	BUG_ON(ctask-&gt;sc);
-
-	sc-&gt;SCp.phase = session-&gt;age;
-	sc-&gt;SCp.ptr = (char*)ctask;
-	iscsi_cmd_init(conn, ctask, sc);
-
-	__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*));
-	debug_scsi(
-	       "ctask enq [%s cid %d sc %lx itt 0x%x len %d cmdsn %d win %d]\n",
-		sc-&gt;sc_data_direction == DMA_TO_DEVICE ? "write" : "read",
-		conn-&gt;id, (long)sc, ctask-&gt;itt, sc-&gt;request_bufflen,
-		session-&gt;cmdsn, session-&gt;max_cmdsn - session-&gt;exp_cmdsn + 1);
-	spin_unlock(&amp;session-&gt;lock);
-
-	scsi_queue_work(host, &amp;conn-&gt;xmitwork);
-	return 0;
-
-reject:
-	spin_unlock(&amp;session-&gt;lock);
-	debug_scsi("cmd 0x%x rejected (%d)\n", sc-&gt;cmnd[0], reason);
-	return SCSI_MLQUEUE_HOST_BUSY;
-
-fault:
-	spin_unlock(&amp;session-&gt;lock);
-	printk(KERN_ERR "iscsi_tcp: cmd 0x%x is not queued (%d)\n",
-	       sc-&gt;cmnd[0], reason);
-	sc-&gt;result = (DID_NO_CONNECT &lt;&lt; 16);
-	sc-&gt;resid = sc-&gt;request_bufflen;
-	sc-&gt;scsi_done(sc);
-	return 0;
-}
-
-static int
-iscsi_change_queue_depth(struct scsi_device *sdev, int depth)
-{
-	if (depth &gt; ISCSI_MAX_CMD_PER_LUN)
-		depth = ISCSI_MAX_CMD_PER_LUN;
-	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
-	return sdev-&gt;queue_depth;
-}
-
-static int
-iscsi_pool_init(struct iscsi_queue *q, int max, void ***items, int item_size)
-{
-	int i;
-
-	*items = kmalloc(max * sizeof(void*), GFP_KERNEL);
-	if (*items == NULL)
-		return -ENOMEM;
-
-	q-&gt;max = max;
-	q-&gt;pool = kmalloc(max * sizeof(void*), GFP_KERNEL);
-	if (q-&gt;pool == NULL) {
-		kfree(*items);
-		return -ENOMEM;
-	}
-
-	q-&gt;queue = kfifo_init((void*)q-&gt;pool, max * sizeof(void*),
-			      GFP_KERNEL, NULL);
-	if (q-&gt;queue == ERR_PTR(-ENOMEM)) {
-		kfree(q-&gt;pool);
-		kfree(*items);
-		return -ENOMEM;
-	}
-
-	for (i = 0; i &lt; max; i++) {
-		q-&gt;pool[i] = kmalloc(item_size, GFP_KERNEL);
-		if (q-&gt;pool[i] == NULL) {
-			int j;
-
-			for (j = 0; j &lt; i; j++)
-				kfree(q-&gt;pool[j]);
-
-			kfifo_free(q-&gt;queue);
-			kfree(q-&gt;pool);
-			kfree(*items);
-			return -ENOMEM;
-		}
-		memset(q-&gt;pool[i], 0, item_size);
-		(*items)[i] = q-&gt;pool[i];
-		__kfifo_put(q-&gt;queue, (void*)&amp;q-&gt;pool[i], sizeof(void*));
-	}
-	return 0;
-}
-
-static void
-iscsi_pool_free(struct iscsi_queue *q, void **items)
-{
-	int i;
-
-	for (i = 0; i &lt; q-&gt;max; i++)
-		kfree(items[i]);
-	kfree(q-&gt;pool);
-	kfree(items);
-}
-
-static struct iscsi_cls_conn *
-iscsi_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	struct iscsi_conn *conn;
-	struct iscsi_cls_conn *cls_conn;
-
-	cls_conn = iscsi_create_conn(cls_session, conn_idx);
-	if (!cls_conn)
-		return NULL;
-	conn = cls_conn-&gt;dd_data;
-	memset(conn, 0, sizeof(*conn));
-
-	conn-&gt;cls_conn = cls_conn;
-	conn-&gt;c_stage = ISCSI_CONN_INITIAL_STAGE;
-	conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
-	conn-&gt;id = conn_idx;
-	conn-&gt;exp_statsn = 0;
-	conn-&gt;tmabort_state = TMABORT_INITIAL;
-	INIT_LIST_HEAD(&amp;conn-&gt;run_list);
-
-	/* initial operational parameters */
-	conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
-	conn-&gt;data_size = DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH;
-	conn-&gt;max_recv_dlength = DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH;
-
-	/* initialize general xmit PDU commands queue */
-	conn-&gt;xmitqueue = kfifo_alloc(session-&gt;cmds_max * sizeof(void*),
-					GFP_KERNEL, NULL);
-	if (conn-&gt;xmitqueue == ERR_PTR(-ENOMEM))
-		goto xmitqueue_alloc_fail;
-
-	/* initialize write response PDU commands queue */
-	conn-&gt;writequeue = kfifo_alloc(session-&gt;cmds_max * sizeof(void*),
-					GFP_KERNEL, NULL);
-	if (conn-&gt;writequeue == ERR_PTR(-ENOMEM))
-		goto writequeue_alloc_fail;
-
-	/* initialize general immediate &amp; non-immediate PDU commands queue */
-	conn-&gt;immqueue = kfifo_alloc(session-&gt;mgmtpool_max * sizeof(void*),
-			                GFP_KERNEL, NULL);
-	if (conn-&gt;immqueue == ERR_PTR(-ENOMEM))
-		goto immqueue_alloc_fail;
-
-	conn-&gt;mgmtqueue = kfifo_alloc(session-&gt;mgmtpool_max * sizeof(void*),
-			                GFP_KERNEL, NULL);
-	if (conn-&gt;mgmtqueue == ERR_PTR(-ENOMEM))
-		goto mgmtqueue_alloc_fail;
-
-	INIT_WORK(&amp;conn-&gt;xmitwork, iscsi_xmitworker, conn);
-
-	/* allocate login_mtask used for the login/text sequences */
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (!__kfifo_get(session-&gt;mgmtpool.queue,
-                         (void*)&amp;conn-&gt;login_mtask,
-			 sizeof(void*))) {
-		spin_unlock_bh(&amp;session-&gt;lock);
-		goto login_mtask_alloc_fail;
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	/* allocate initial PDU receive place holder */
-	if (conn-&gt;data_size &lt;= PAGE_SIZE)
-		conn-&gt;data = kmalloc(conn-&gt;data_size, GFP_KERNEL);
-	else
-		conn-&gt;data = (void*)__get_free_pages(GFP_KERNEL,
-					get_order(conn-&gt;data_size));
-	if (!conn-&gt;data)
-		goto max_recv_dlenght_alloc_fail;
-
-	init_timer(&amp;conn-&gt;tmabort_timer);
-	mutex_init(&amp;conn-&gt;xmitmutex);
-	init_waitqueue_head(&amp;conn-&gt;ehwait);
-
-	return cls_conn;
-
-max_recv_dlenght_alloc_fail:
-	spin_lock_bh(&amp;session-&gt;lock);
-	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
-		    sizeof(void*));
-	spin_unlock_bh(&amp;session-&gt;lock);
-login_mtask_alloc_fail:
-	kfifo_free(conn-&gt;mgmtqueue);
-mgmtqueue_alloc_fail:
-	kfifo_free(conn-&gt;immqueue);
-immqueue_alloc_fail:
-	kfifo_free(conn-&gt;writequeue);
-writequeue_alloc_fail:
-	kfifo_free(conn-&gt;xmitqueue);
-xmitqueue_alloc_fail:
-	iscsi_destroy_conn(cls_conn);
-	return NULL;
-}
-
-static void
-iscsi_conn_destroy(struct iscsi_cls_conn *cls_conn)
-{
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_session *session = conn-&gt;session;
-	unsigned long flags;
-
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-	if (conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE &amp;&amp; conn-&gt;sock) {
-		struct sock *sk = conn-&gt;sock-&gt;sk;
-
-		/*
-		 * conn_start() has never been called!
-		 * need to cleanup the socket.
-		 */
-		write_lock_bh(&amp;sk-&gt;sk_callback_lock);
-		set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
-		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
-
-		sock_hold(conn-&gt;sock-&gt;sk);
-		iscsi_conn_restore_callbacks(conn);
-		sock_put(conn-&gt;sock-&gt;sk);
-		sock_release(conn-&gt;sock);
-		conn-&gt;sock = NULL;
-	}
-
-	spin_lock_bh(&amp;session-&gt;lock);
-	conn-&gt;c_stage = ISCSI_CONN_CLEANUP_WAIT;
-	if (session-&gt;leadconn == conn) {
-		/*
-		 * leading connection? then give up on recovery.
-		 */
-		session-&gt;state = ISCSI_STATE_TERMINATE;
-		wake_up(&amp;conn-&gt;ehwait);
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	mutex_unlock(&amp;conn-&gt;xmitmutex);
-
-	/*
-	 * Block until all in-progress commands for this connection
-	 * time out or fail.
-	 */
-	for (;;) {
-		spin_lock_irqsave(session-&gt;host-&gt;host_lock, flags);
-		if (!session-&gt;host-&gt;host_busy) { /* OK for ERL == 0 */
-			spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
-			break;
-		}
-		spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
-		msleep_interruptible(500);
-		printk("conn_destroy(): host_busy %d host_failed %d\n",
-			session-&gt;host-&gt;host_busy, session-&gt;host-&gt;host_failed);
-		/*
-		 * force eh_abort() to unblock
-		 */
-		wake_up(&amp;conn-&gt;ehwait);
-	}
-
-	/* now free crypto */
-	if (conn-&gt;hdrdgst_en || conn-&gt;datadgst_en) {
-		if (conn-&gt;tx_tfm)
-			crypto_free_tfm(conn-&gt;tx_tfm);
-		if (conn-&gt;rx_tfm)
-			crypto_free_tfm(conn-&gt;rx_tfm);
-		if (conn-&gt;data_tx_tfm)
-			crypto_free_tfm(conn-&gt;data_tx_tfm);
-		if (conn-&gt;data_rx_tfm)
-			crypto_free_tfm(conn-&gt;data_rx_tfm);
-	}
-
-	/* free conn-&gt;data, size = MaxRecvDataSegmentLength */
-	if (conn-&gt;data_size &lt;= PAGE_SIZE)
-		kfree(conn-&gt;data);
-	else
-		free_pages((unsigned long)conn-&gt;data,
-					get_order(conn-&gt;data_size));
-
-	spin_lock_bh(&amp;session-&gt;lock);
-	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
-		    sizeof(void*));
-	list_del(&amp;conn-&gt;item);
-	if (list_empty(&amp;session-&gt;connections))
-		session-&gt;leadconn = NULL;
-	if (session-&gt;leadconn &amp;&amp; session-&gt;leadconn == conn)
-		session-&gt;leadconn = container_of(session-&gt;connections.next,
-			struct iscsi_conn, item);
-
-	if (session-&gt;leadconn == NULL)
-		/* none connections exits.. reset sequencing */
-		session-&gt;cmdsn = session-&gt;max_cmdsn = session-&gt;exp_cmdsn = 1;
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	kfifo_free(conn-&gt;xmitqueue);
-	kfifo_free(conn-&gt;writequeue);
-	kfifo_free(conn-&gt;immqueue);
-	kfifo_free(conn-&gt;mgmtqueue);
-
-	iscsi_destroy_conn(cls_conn);
-}
-
-static int
-iscsi_conn_bind(struct iscsi_cls_session *cls_session,
-		struct iscsi_cls_conn *cls_conn, uint32_t transport_fd,
-		int is_leading)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	struct iscsi_conn *tmp = ERR_PTR(-EEXIST), *conn = cls_conn-&gt;dd_data;
-	struct sock *sk;
-	struct socket *sock;
-	int err;
-
-	/* lookup for existing socket */
-	sock = sockfd_lookup(transport_fd, &amp;err);
-	if (!sock) {
-		printk(KERN_ERR "iscsi_tcp: sockfd_lookup failed %d\n", err);
-		return -EEXIST;
-	}
-
-	/* lookup for existing connection */
-	spin_lock_bh(&amp;session-&gt;lock);
-	list_for_each_entry(tmp, &amp;session-&gt;connections, item) {
-		if (tmp == conn) {
-			if (conn-&gt;c_stage != ISCSI_CONN_STOPPED ||
-			    conn-&gt;stop_stage == STOP_CONN_TERM) {
-				printk(KERN_ERR "iscsi_tcp: can't bind "
-				       "non-stopped connection (%d:%d)\n",
-				       conn-&gt;c_stage, conn-&gt;stop_stage);
-				spin_unlock_bh(&amp;session-&gt;lock);
-				return -EIO;
-			}
-			break;
-		}
-	}
-	if (tmp != conn) {
-		/* bind new iSCSI connection to session */
-		conn-&gt;session = session;
-
-		list_add(&amp;conn-&gt;item, &amp;session-&gt;connections);
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	if (conn-&gt;stop_stage != STOP_CONN_SUSPEND) {
-		/* bind iSCSI connection and socket */
-		conn-&gt;sock = sock;
+	if (conn-&gt;stop_stage != STOP_CONN_SUSPEND) {
+		/* bind iSCSI connection and socket */
+		tcp_conn-&gt;sock = sock;
 
 		/* setup Socket parameters */
 		sk = sock-&gt;sk;
@@ -2699,608 +2011,78 @@ iscsi_conn_bind(struct iscsi_cls_session *cls_session,
 		 * Intercept TCP callbacks for sendfile like receive
 		 * processing.
 		 */
+		conn-&gt;recv_lock = &amp;sk-&gt;sk_callback_lock;
 		iscsi_conn_set_callbacks(conn);
-
-		conn-&gt;sendpage = conn-&gt;sock-&gt;ops-&gt;sendpage;
-
+		tcp_conn-&gt;sendpage = tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
 		/*
 		 * set receive state machine into initial state
 		 */
-		conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
+		tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
 	}
 
-	if (is_leading)
-		session-&gt;leadconn = conn;
-
-	/*
-	 * Unblock xmitworker(), Login Phase will pass through.
-	 */
-	clear_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
-	clear_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-
 	return 0;
 }
 
 static void
-iscsi_session_recovery_timedout(struct iscsi_cls_session *csession)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(csession);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	struct iscsi_conn *conn = session-&gt;leadconn;
-
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
-		session-&gt;recovery_failed = 1;
-		if (conn)
-			wake_up(&amp;conn-&gt;ehwait);
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-}
-
-static int
-iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
-{
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_session *session = conn-&gt;session;
-	struct sock *sk;
-
-	/* FF phase warming up... */
-
-	if (session == NULL) {
-		printk(KERN_ERR "iscsi_tcp: can't start unbound connection\n");
-		return -EPERM;
-	}
-
-	sk = conn-&gt;sock-&gt;sk;
-	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
-	spin_lock_bh(&amp;session-&gt;lock);
-	conn-&gt;c_stage = ISCSI_CONN_STARTED;
-	session-&gt;state = ISCSI_STATE_LOGGED_IN;
-
-	switch(conn-&gt;stop_stage) {
-	case STOP_CONN_RECOVER:
-		/*
-		 * unblock eh_abort() if it is blocked. re-try all
-		 * commands after successful recovery
-		 */
-		session-&gt;conn_cnt++;
-		conn-&gt;stop_stage = 0;
-		conn-&gt;tmabort_state = TMABORT_INITIAL;
-		session-&gt;age++;
-		session-&gt;recovery_failed = 0;
-		spin_unlock_bh(&amp;session-&gt;lock);
-		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
-
-		iscsi_unblock_session(session_to_cls(session));
-		wake_up(&amp;conn-&gt;ehwait);
-		return 0;
-	case STOP_CONN_TERM:
-		session-&gt;conn_cnt++;
-		conn-&gt;stop_stage = 0;
-		break;
-	case STOP_CONN_SUSPEND:
-		conn-&gt;stop_stage = 0;
-		clear_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
-		clear_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-		break;
-	default:
-		break;
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
-
-	return 0;
-}
-
-static int
-iscsi_ctask_mtask_cleanup(struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_mgmt_task *mtask;
-
-	if (!ctask-&gt;mtask)
-		return -EINVAL;
-
-	while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*))) {
-		if (mtask == ctask-&gt;mtask)
-			break;
-		__kfifo_put(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*));
-	}
-
-	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;ctask-&gt;mtask,
-		    sizeof(void*));
-	ctask-&gt;mtask = NULL;
-	return 0;
-}
-
-static void
-fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask, int err)
+iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_r2t_info *r2t;
-	struct scsi_cmnd *sc;
 
 	/* flush ctask's r2t queues */
-	while (__kfifo_get(ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*)))
-		__kfifo_put(ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
-
-	iscsi_ctask_mtask_cleanup(ctask);
-
-	sc = ctask-&gt;sc;
-	if (!sc)
-		return;
-
-	sc-&gt;result = err;
-	sc-&gt;resid = sc-&gt;request_bufflen;
-
-	__iscsi_ctask_cleanup(conn, ctask);
-}
-
-/* Fail commands. Mutex and session lock held */
-static void
-fail_all_commands(struct iscsi_session *session, struct iscsi_conn *conn)
-{
-	struct iscsi_cmd_task *ctask, *tmp;
-
-	/* flush pending */
-	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*))) {
-		debug_scsi("failing pending sc %p itt 0x%x\n", ctask-&gt;sc,
-			   ctask-&gt;itt);
-		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
-	}
-
-	/* fail running */
-	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;run_list, running) {
-		debug_scsi("failing in progress sc %p itt 0x%x\n",
-			   ctask-&gt;sc, ctask-&gt;itt);
-		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
-	}
-
-	conn-&gt;ctask = NULL;
-}
-
-static void
-flush_control_queues(struct iscsi_session *session, struct iscsi_conn *conn)
-{
-	struct iscsi_mgmt_task *mtask;
-
-	/* TODO: handle running pdus */
-	while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*)) ||
-	       __kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*))) {
-		if (mtask == conn-&gt;login_mtask)
-			continue;
-		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;mtask,
+	while (__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*)))
+		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
 			    sizeof(void*));
-	}
 
-	if (conn-&gt;mtask &amp;&amp; conn-&gt;mtask != conn-&gt;login_mtask)
-		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;mtask,
-			    sizeof(void*));
-	conn-&gt;mtask = NULL;
+	__iscsi_ctask_cleanup(conn, ctask);
 }
 
 static void
-iscsi_suspend_conn_rx(struct iscsi_conn *conn)
+iscsi_tcp_suspend_conn_rx(struct iscsi_conn *conn)
 {
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct sock *sk;
 
-	BUG_ON(!conn-&gt;sock);
-	sk = conn-&gt;sock-&gt;sk;
+	if (!tcp_conn-&gt;sock)
+		return;
+
+	sk = tcp_conn-&gt;sock-&gt;sk;
 	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
-	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
 	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 }
 
 static void
-iscsi_start_session_recovery(struct iscsi_session *session,
-			     struct iscsi_conn *conn, int flag)
+iscsi_tcp_terminate_conn(struct iscsi_conn *conn)
 {
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (conn-&gt;stop_stage == STOP_CONN_RECOVER ||
-	    conn-&gt;stop_stage == STOP_CONN_TERM) {
-		spin_unlock_bh(&amp;session-&gt;lock);
-		return;
-	}
-	conn-&gt;stop_stage = flag;
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	iscsi_suspend_conn_rx(conn);
-
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-	spin_lock_bh(&amp;session-&gt;lock);
-	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
-	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 
-	session-&gt;conn_cnt--;
-	if (session-&gt;conn_cnt == 0 || session-&gt;leadconn == conn)
-		session-&gt;state = ISCSI_STATE_FAILED;
-
-	spin_unlock_bh(&amp;session-&gt;lock);
+	if (!tcp_conn-&gt;sock)
+		return;
 
-	/*
-	 * Socket must go now.
-	 */
-	sock_hold(conn-&gt;sock-&gt;sk);
+	sock_hold(tcp_conn-&gt;sock-&gt;sk);
 	iscsi_conn_restore_callbacks(conn);
-	sock_put(conn-&gt;sock-&gt;sk);
+	sock_put(tcp_conn-&gt;sock-&gt;sk);
 
-	/*
-	 * flush queues.
-	 */
-	spin_lock_bh(&amp;session-&gt;lock);
-	fail_all_commands(session, conn);
-	flush_control_queues(session, conn);
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	/*
-	 * release socket only after we stopped data_xmit()
-	 * activity and flushed all outstandings
-	 */
-	sock_release(conn-&gt;sock);
-	conn-&gt;sock = NULL;
-
-	/*
-	 * for connection level recovery we should not calculate
-	 * header digest. conn-&gt;hdr_size used for optimization
-	 * in hdr_extract() and will be re-negotiated at
-	 * set_param() time.
-	 */
-	if (flag == STOP_CONN_RECOVER) {
-		conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
-		conn-&gt;hdrdgst_en = 0;
-		conn-&gt;datadgst_en = 0;
-
-		if (session-&gt;state == ISCSI_STATE_FAILED)
-			iscsi_block_session(session_to_cls(session));
-	}
-	mutex_unlock(&amp;conn-&gt;xmitmutex);
+	sock_release(tcp_conn-&gt;sock);
+	tcp_conn-&gt;sock = NULL;
+	conn-&gt;recv_lock = NULL;
 }
 
+/* called with host lock */
 static void
-iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
-{
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_session *session = conn-&gt;session;
-
-	switch (flag) {
-	case STOP_CONN_RECOVER:
-	case STOP_CONN_TERM:
-		iscsi_start_session_recovery(session, conn, flag);
-		return;
-	case STOP_CONN_SUSPEND:
-		iscsi_suspend_conn_rx(conn);
-
-		mutex_lock(&amp;conn-&gt;xmitmutex);
-		spin_lock_bh(&amp;session-&gt;lock);
-
-		conn-&gt;stop_stage = flag;
-		conn-&gt;c_stage = ISCSI_CONN_STOPPED;
-		set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-
-		spin_unlock_bh(&amp;session-&gt;lock);
-		mutex_unlock(&amp;conn-&gt;xmitmutex);
-		break;
-	default:
-		printk(KERN_ERR "invalid stop flag %d\n", flag);
-	}
-}
-
-static int
-iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
-			char *data, uint32_t data_size)
+iscsi_tcp_mgmt_init(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask,
+		    char *data, uint32_t data_size)
 {
-	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;
-	struct iscsi_mgmt_task *mtask;
-
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
-		spin_unlock_bh(&amp;session-&gt;lock);
-		return -EPERM;
-	}
-	if (hdr-&gt;opcode == (ISCSI_OP_LOGIN | ISCSI_OP_IMMEDIATE) ||
-	    hdr-&gt;opcode == (ISCSI_OP_TEXT | ISCSI_OP_IMMEDIATE))
-		/*
-		 * Login and Text are sent serially, in
-		 * request-followed-by-response sequence.
-		 * Same mtask can be used. Same ITT must be used.
-		 * Note that login_mtask is preallocated at conn_create().
-		 */
-		mtask = conn-&gt;login_mtask;
-	else {
-	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
-	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
-
-		if (!__kfifo_get(session-&gt;mgmtpool.queue,
-				 (void*)&amp;mtask, sizeof(void*))) {
-			spin_unlock_bh(&amp;session-&gt;lock);
-			return -ENOSPC;
-		}
-	}
+	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
 
-	/*
-	 * pre-format CmdSN and ExpStatSN for outgoing PDU.
-	 */
-	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
-		hdr-&gt;itt = mtask-&gt;itt | (conn-&gt;id &lt;&lt; CID_SHIFT) |
-			   (session-&gt;age &lt;&lt; AGE_SHIFT);
-		nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
-		if (conn-&gt;c_stage == ISCSI_CONN_STARTED &amp;&amp;
-		    !(hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE))
-			session-&gt;cmdsn++;
-	} else
-		/* do not advance CmdSN */
-		nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
-
-	nop-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
-
-	memcpy(&amp;mtask-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
-
-	iscsi_buf_init_virt(&amp;mtask-&gt;headbuf, (char*)&amp;mtask-&gt;hdr,
+	iscsi_buf_init_virt(&amp;tcp_mtask-&gt;headbuf, (char*)mtask-&gt;hdr,
 				    sizeof(struct iscsi_hdr));
+	tcp_mtask-&gt;xmstate = XMSTATE_IMM_HDR;
 
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	if (data_size) {
-		memcpy(mtask-&gt;data, data, data_size);
-		mtask-&gt;data_count = data_size;
-	} else
-		mtask-&gt;data_count = 0;
-
-	mtask-&gt;xmstate = XMSTATE_IMM_HDR;
-
-	if (mtask-&gt;data_count) {
-		iscsi_buf_init_iov(&amp;mtask-&gt;sendbuf, (char*)mtask-&gt;data,
+	if (mtask-&gt;data_count)
+		iscsi_buf_init_iov(&amp;tcp_mtask-&gt;sendbuf, (char*)mtask-&gt;data,
 				    mtask-&gt;data_count);
-	}
-
-	debug_scsi("mgmtpdu [op 0x%x hdr-&gt;itt 0x%x datalen %d]\n",
-		   hdr-&gt;opcode, hdr-&gt;itt, data_size);
-
-	/*
-	 * since send_pdu() could be called at least from two contexts,
-	 * we need to serialize __kfifo_put, so we don't have to take
-	 * additional lock on fast data-path
-	 */
-        if (hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE)
-	        __kfifo_put(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*));
-	else
-	        __kfifo_put(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*));
-
-	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
-	return 0;
-}
-
-static int
-iscsi_eh_host_reset(struct scsi_cmnd *sc)
-{
-	struct Scsi_Host *host = sc-&gt;device-&gt;host;
-	struct iscsi_session *session = iscsi_hostdata(host-&gt;hostdata);
-	struct iscsi_conn *conn = session-&gt;leadconn;
-	int fail_session = 0;
-
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
-failed:
-		debug_scsi("failing host reset: session terminated "
-			   "[CID %d age %d]", conn-&gt;id, session-&gt;age);
-		spin_unlock_bh(&amp;session-&gt;lock);
-		return FAILED;
-	}
-
-	if (sc-&gt;SCp.phase == session-&gt;age) {
-		debug_scsi("failing connection CID %d due to SCSI host reset",
-			   conn-&gt;id);
-		fail_session = 1;
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	/*
-	 * we drop the lock here but the leadconn cannot be destoyed while
-	 * we are in the scsi eh
-	 */
-	if (fail_session) {
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-		/*
-		 * if userspace cannot respond then we must kick this off
-		 * here for it
-		 */
-		iscsi_start_session_recovery(session, conn, STOP_CONN_RECOVER);
-	}
-
-	debug_scsi("iscsi_eh_host_reset wait for relogin\n");
-	wait_event_interruptible(conn-&gt;ehwait,
-				 session-&gt;state == ISCSI_STATE_TERMINATE ||
-				 session-&gt;state == ISCSI_STATE_LOGGED_IN ||
-				 session-&gt;recovery_failed);
-	if (signal_pending(current))
-		flush_signals(current);
-
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (session-&gt;state == ISCSI_STATE_LOGGED_IN)
-		printk(KERN_INFO "host reset succeeded\n");
-	else
-		goto failed;
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	return SUCCESS;
-}
-
-static void
-iscsi_tmabort_timedout(unsigned long data)
-{
-	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)data;
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct iscsi_session *session = conn-&gt;session;
-
-	spin_lock(&amp;session-&gt;lock);
-	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
-		conn-&gt;tmabort_state = TMABORT_TIMEDOUT;
-		debug_scsi("tmabort timedout [sc %lx itt 0x%x]\n",
-			(long)ctask-&gt;sc, ctask-&gt;itt);
-		/* unblock eh_abort() */
-		wake_up(&amp;conn-&gt;ehwait);
-	}
-	spin_unlock(&amp;session-&gt;lock);
-}
-
-/* must be called with the mutex lock */
-static int
-iscsi_exec_abort_task(struct scsi_cmnd *sc, struct iscsi_cmd_task *ctask)
-{
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_tm *hdr = &amp;conn-&gt;tmhdr;
-	int rc;
-
-	/*
-	 * ctask timed out but session is OK requests must be serialized.
-	 */
-	memset(hdr, 0, sizeof(struct iscsi_tm));
-	hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;
-	hdr-&gt;flags = ISCSI_TM_FUNC_ABORT_TASK;
-	hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr.lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;rtt = ctask-&gt;hdr.itt;
-	hdr-&gt;refcmdsn = ctask-&gt;hdr.cmdsn;
-
-	rc = iscsi_conn_send_generic(conn, (struct iscsi_hdr *)hdr,
-				     NULL, 0);
-	if (rc) {
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-		debug_scsi("abort sent failure [itt 0x%x] %d", ctask-&gt;itt, rc);
-		return rc;
-	}
-
-	debug_scsi("abort sent [itt 0x%x]\n", ctask-&gt;itt);
-
-	spin_lock_bh(&amp;session-&gt;lock);
-	ctask-&gt;mtask = (struct iscsi_mgmt_task *)
-			session-&gt;mgmt_cmds[(hdr-&gt;itt &amp; ITT_MASK) -
-					ISCSI_MGMT_ITT_OFFSET];
-
-	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
-		conn-&gt;tmfcmd_pdus_cnt++;
-		conn-&gt;tmabort_timer.expires = 10*HZ + jiffies;
-		conn-&gt;tmabort_timer.function = iscsi_tmabort_timedout;
-		conn-&gt;tmabort_timer.data = (unsigned long)ctask;
-		add_timer(&amp;conn-&gt;tmabort_timer);
-		debug_scsi("abort set timeout [itt 0x%x]", ctask-&gt;itt);
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-	mutex_unlock(&amp;conn-&gt;xmitmutex);
-
-	/*
-	 * block eh thread until:
-	 *
-	 * 1) abort response
-	 * 2) abort timeout
-	 * 3) session is terminated or restarted or userspace has
-	 * given up on recovery
-	 */
-	wait_event_interruptible(conn-&gt;ehwait,
-				 sc-&gt;SCp.phase != session-&gt;age ||
-				 session-&gt;state != ISCSI_STATE_LOGGED_IN ||
-				 conn-&gt;tmabort_state != TMABORT_INITIAL ||
-				 session-&gt;recovery_failed);
-	if (signal_pending(current))
-		flush_signals(current);
-	del_timer_sync(&amp;conn-&gt;tmabort_timer);
-
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-	return 0;
-}
-
-static int
-iscsi_eh_abort(struct scsi_cmnd *sc)
-{
-	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
-	struct iscsi_cmd_task *tmp_ctask;
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct iscsi_session *session = conn-&gt;session;
-	int rc;
-
-	conn-&gt;eh_abort_cnt++;
-	debug_scsi("aborting [sc %p itt 0x%x]\n", sc, ctask-&gt;itt);
-
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-	spin_lock_bh(&amp;session-&gt;lock);
-
-	/*
-	 * If we are not logged in or we have started a new session
-	 * then let the host reset code handle this
-	 */
-	if (session-&gt;state != ISCSI_STATE_LOGGED_IN ||
-	    sc-&gt;SCp.phase != session-&gt;age)
-		goto failed;
-
-	/* ctask completed before time out */
-	if (!ctask-&gt;sc)
-		goto success;
-
-	/* what should we do here ? */
-	if (conn-&gt;ctask == ctask) {
-		printk(KERN_INFO "sc %p itt 0x%x partially sent. Failing "
-		       "abort\n", sc, ctask-&gt;itt);
-		goto failed;
-	}
-
-	/* check for the easy pending cmd abort */
-	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;tmp_ctask, sizeof(void*))) {
-		if (tmp_ctask-&gt;itt == ctask-&gt;itt) {
-			debug_scsi("found pending task\n");
-			goto success;
-		}
-		__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;tmp_ctask, sizeof(void*));
-	}
-
-	conn-&gt;tmabort_state = TMABORT_INITIAL;
-
-	spin_unlock_bh(&amp;session-&gt;lock);
-	rc = iscsi_exec_abort_task(sc, ctask);
-	spin_lock_bh(&amp;session-&gt;lock);
-
-	iscsi_ctask_mtask_cleanup(ctask);
-	if (rc || sc-&gt;SCp.phase != session-&gt;age ||
-	    session-&gt;state != ISCSI_STATE_LOGGED_IN)
-		goto failed;
-
-	/* ctask completed before tmf abort response */
-	if (!ctask-&gt;sc) {
-		debug_scsi("sc completed while abort in progress\n");
-		goto success;
-	}
-
-	if (conn-&gt;tmabort_state != TMABORT_SUCCESS) {
-		spin_unlock_bh(&amp;session-&gt;lock);
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-		spin_lock_bh(&amp;session-&gt;lock);
-		goto failed;
-	}
-
-success:
-	debug_scsi("abort success [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
-	spin_unlock_bh(&amp;session-&gt;lock);
-
-	/* clean up task if aborted */
-	if (conn-&gt;sock) {
-		struct sock *sk = conn-&gt;sock-&gt;sk;
-
-		write_lock_bh(&amp;sk-&gt;sk_callback_lock);
-		spin_lock(&amp;session-&gt;lock);
-		fail_command(conn, ctask, DRIVER_TIMEOUT &lt;&lt; 24);
-		spin_unlock(&amp;session-&gt;lock);
-		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
-	}
-	mutex_unlock(&amp;conn-&gt;xmitmutex);
-	return SUCCESS;
-
-failed:
-	spin_unlock_bh(&amp;session-&gt;lock);
-	mutex_unlock(&amp;conn-&gt;xmitmutex);
-
-	debug_scsi("abort failed [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
-	return FAILED;
 }
 
 static int
@@ -3314,6 +2096,7 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 	 */
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
 	        struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
 		/*
 		 * pre-allocated x4 as much r2ts to handle race when
@@ -3322,16 +2105,18 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 		 */
 
 		/* R2T pool */
-		if (iscsi_pool_init(&amp;ctask-&gt;r2tpool, session-&gt;max_r2t * 4,
-			(void***)&amp;ctask-&gt;r2ts, sizeof(struct iscsi_r2t_info))) {
+		if (iscsi_pool_init(&amp;tcp_ctask-&gt;r2tpool, session-&gt;max_r2t * 4,
+				    (void***)&amp;tcp_ctask-&gt;r2ts,
+				    sizeof(struct iscsi_r2t_info))) {
 			goto r2t_alloc_fail;
 		}
 
 		/* R2T xmit queue */
-		ctask-&gt;r2tqueue = kfifo_alloc(
+		tcp_ctask-&gt;r2tqueue = kfifo_alloc(
 		      session-&gt;max_r2t * 4 * sizeof(void*), GFP_KERNEL, NULL);
-		if (ctask-&gt;r2tqueue == ERR_PTR(-ENOMEM)) {
-			iscsi_pool_free(&amp;ctask-&gt;r2tpool, (void**)ctask-&gt;r2ts);
+		if (tcp_ctask-&gt;r2tqueue == ERR_PTR(-ENOMEM)) {
+			iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+					(void**)tcp_ctask-&gt;r2ts);
 			goto r2t_alloc_fail;
 		}
 
@@ -3340,24 +2125,28 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 		 * Data-Out PDU's within R2T-sequence can be quite big;
 		 * using mempool
 		 */
-		ctask-&gt;datapool = mempool_create_slab_pool(ISCSI_DTASK_DEFAULT_MAX,
-							   taskcache);
-		if (ctask-&gt;datapool == NULL) {
-			kfifo_free(ctask-&gt;r2tqueue);
-			iscsi_pool_free(&amp;ctask-&gt;r2tpool, (void**)ctask-&gt;r2ts);
+		tcp_ctask-&gt;datapool = mempool_create_slab_pool(ISCSI_DTASK_DEFAULT_MAX,
+							       taskcache);
+		if (tcp_ctask-&gt;datapool == NULL) {
+			kfifo_free(tcp_ctask-&gt;r2tqueue);
+			iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+					(void**)tcp_ctask-&gt;r2ts);
 			goto r2t_alloc_fail;
 		}
-		INIT_LIST_HEAD(&amp;ctask-&gt;dataqueue);
+		INIT_LIST_HEAD(&amp;tcp_ctask-&gt;dataqueue);
 	}
 
 	return 0;
 
 r2t_alloc_fail:
 	for (i = 0; i &lt; cmd_i; i++) {
-		mempool_destroy(session-&gt;cmds[i]-&gt;datapool);
-		kfifo_free(session-&gt;cmds[i]-&gt;r2tqueue);
-		iscsi_pool_free(&amp;session-&gt;cmds[i]-&gt;r2tpool,
-				(void**)session-&gt;cmds[i]-&gt;r2ts);
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		mempool_destroy(tcp_ctask-&gt;datapool);
+		kfifo_free(tcp_ctask-&gt;r2tqueue);
+		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+				(void**)tcp_ctask-&gt;r2ts);
 	}
 	return -ENOMEM;
 }
@@ -3368,128 +2157,14 @@ iscsi_r2tpool_free(struct iscsi_session *session)
 	int i;
 
 	for (i = 0; i &lt; session-&gt;cmds_max; i++) {
-		mempool_destroy(session-&gt;cmds[i]-&gt;datapool);
-		kfifo_free(session-&gt;cmds[i]-&gt;r2tqueue);
-		iscsi_pool_free(&amp;session-&gt;cmds[i]-&gt;r2tpool,
-				(void**)session-&gt;cmds[i]-&gt;r2ts);
-	}
-}
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 
-static struct scsi_host_template iscsi_sht = {
-	.name			= "iSCSI Initiator over TCP/IP, v."
-				  ISCSI_VERSION_STR,
-	.queuecommand           = iscsi_queuecommand,
-	.change_queue_depth	= iscsi_change_queue_depth,
-	.can_queue		= ISCSI_XMIT_CMDS_MAX - 1,
-	.sg_tablesize		= ISCSI_SG_TABLESIZE,
-	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
-	.eh_abort_handler       = iscsi_eh_abort,
-	.eh_host_reset_handler	= iscsi_eh_host_reset,
-	.use_clustering         = DISABLE_CLUSTERING,
-	.proc_name		= "iscsi_tcp",
-	.this_id		= -1,
-};
-
-static struct iscsi_transport iscsi_tcp_transport;
-
-static struct iscsi_cls_session *
-iscsi_session_create(struct scsi_transport_template *scsit,
-		     uint32_t initial_cmdsn, uint32_t *hostno)
-{
-	struct Scsi_Host *shost;
-	struct iscsi_session *session;
-	int cmd_i;
-
-	shost = iscsi_transport_create_session(scsit, &amp;iscsi_tcp_transport);
-	if (!shost)
-		return NULL; 
-
-	session = iscsi_hostdata(shost-&gt;hostdata);
-	memset(session, 0, sizeof(struct iscsi_session));
-	session-&gt;host = shost;
-	session-&gt;state = ISCSI_STATE_FREE;
-	session-&gt;mgmtpool_max = ISCSI_MGMT_CMDS_MAX;
-	session-&gt;cmds_max = ISCSI_XMIT_CMDS_MAX;
-	session-&gt;cmdsn = initial_cmdsn;
-	session-&gt;exp_cmdsn = initial_cmdsn + 1;
-	session-&gt;max_cmdsn = initial_cmdsn + 1;
-	session-&gt;max_r2t = 1;
-
-	*hostno = shost-&gt;host_no;
-
-	/* initialize SCSI PDU commands pool */
-	if (iscsi_pool_init(&amp;session-&gt;cmdpool, session-&gt;cmds_max,
-		(void***)&amp;session-&gt;cmds, sizeof(struct iscsi_cmd_task)))
-		goto cmdpool_alloc_fail;
-
-	/* pre-format cmds pool with ITT */
-	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++)
-		session-&gt;cmds[cmd_i]-&gt;itt = cmd_i;
-
-	spin_lock_init(&amp;session-&gt;lock);
-	INIT_LIST_HEAD(&amp;session-&gt;connections);
-
-	/* initialize immediate command pool */
-	if (iscsi_pool_init(&amp;session-&gt;mgmtpool, session-&gt;mgmtpool_max,
-		(void***)&amp;session-&gt;mgmt_cmds, sizeof(struct iscsi_mgmt_task)))
-		goto mgmtpool_alloc_fail;
-
-
-	/* pre-format immediate cmds pool with ITT */
-	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++) {
-		session-&gt;mgmt_cmds[cmd_i]-&gt;itt = ISCSI_MGMT_ITT_OFFSET + cmd_i;
-		session-&gt;mgmt_cmds[cmd_i]-&gt;data = kmalloc(
-			DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH, GFP_KERNEL);
-		if (!session-&gt;mgmt_cmds[cmd_i]-&gt;data) {
-			int j;
-
-			for (j = 0; j &lt; cmd_i; j++)
-				kfree(session-&gt;mgmt_cmds[j]-&gt;data);
-			goto immdata_alloc_fail;
-		}
+		mempool_destroy(tcp_ctask-&gt;datapool);
+		kfifo_free(tcp_ctask-&gt;r2tqueue);
+		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool,
+				(void**)tcp_ctask-&gt;r2ts);
 	}
-
-	if (iscsi_r2tpool_alloc(session))
-		goto r2tpool_alloc_fail;
-
-	return hostdata_session(shost-&gt;hostdata);
-
-r2tpool_alloc_fail:
-	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
-		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
-immdata_alloc_fail:
-	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
-mgmtpool_alloc_fail:
-	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
-cmdpool_alloc_fail:
-	iscsi_transport_destroy_session(shost);
-	return NULL;
-}
-
-static void
-iscsi_session_destroy(struct iscsi_cls_session *cls_session)
-{
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
-	int cmd_i;
-	struct iscsi_data_task *dtask, *n;
-
-	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
-		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
-		list_for_each_entry_safe(dtask, n, &amp;ctask-&gt;dataqueue, item) {
-			list_del(&amp;dtask-&gt;item);
-			mempool_free(dtask, ctask-&gt;datapool);
-		}
-	}
-
-	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
-		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
-
-	iscsi_r2tpool_free(session);
-	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
-	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
-
-	iscsi_transport_destroy_session(shost);
 }
 
 static int
@@ -3498,13 +2173,14 @@ iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 
 	switch(param) {
 	case ISCSI_PARAM_MAX_RECV_DLENGTH: {
-		char *saveptr = conn-&gt;data;
+		char *saveptr = tcp_conn-&gt;data;
 		gfp_t flags = GFP_KERNEL;
 
-		if (conn-&gt;data_size &gt;= value) {
+		if (tcp_conn-&gt;data_size &gt;= value) {
 			conn-&gt;max_recv_dlength = value;
 			break;
 		}
@@ -3515,21 +2191,21 @@ iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 		spin_unlock_bh(&amp;session-&gt;lock);
 
 		if (value &lt;= PAGE_SIZE)
-			conn-&gt;data = kmalloc(value, flags);
+			tcp_conn-&gt;data = kmalloc(value, flags);
 		else
-			conn-&gt;data = (void*)__get_free_pages(flags,
+			tcp_conn-&gt;data = (void*)__get_free_pages(flags,
 							     get_order(value));
-		if (conn-&gt;data == NULL) {
-			conn-&gt;data = saveptr;
+		if (tcp_conn-&gt;data == NULL) {
+			tcp_conn-&gt;data = saveptr;
 			return -ENOMEM;
 		}
-		if (conn-&gt;data_size &lt;= PAGE_SIZE)
+		if (tcp_conn-&gt;data_size &lt;= PAGE_SIZE)
 			kfree(saveptr);
 		else
 			free_pages((unsigned long)saveptr,
-				   get_order(conn-&gt;data_size));
+				   get_order(tcp_conn-&gt;data_size));
 		conn-&gt;max_recv_dlength = value;
-		conn-&gt;data_size = value;
+		tcp_conn-&gt;data_size = value;
 		}
 		break;
 	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
@@ -3537,49 +2213,51 @@ iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 		break;
 	case ISCSI_PARAM_HDRDGST_EN:
 		conn-&gt;hdrdgst_en = value;
-		conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
+		tcp_conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
 		if (conn-&gt;hdrdgst_en) {
-			conn-&gt;hdr_size += sizeof(__u32);
-			if (!conn-&gt;tx_tfm)
-				conn-&gt;tx_tfm = crypto_alloc_tfm("crc32c", 0);
-			if (!conn-&gt;tx_tfm)
+			tcp_conn-&gt;hdr_size += sizeof(__u32);
+			if (!tcp_conn-&gt;tx_tfm)
+				tcp_conn-&gt;tx_tfm = crypto_alloc_tfm("crc32c",
+								    0);
+			if (!tcp_conn-&gt;tx_tfm)
 				return -ENOMEM;
-			if (!conn-&gt;rx_tfm)
-				conn-&gt;rx_tfm = crypto_alloc_tfm("crc32c", 0);
-			if (!conn-&gt;rx_tfm) {
-				crypto_free_tfm(conn-&gt;tx_tfm);
+			if (!tcp_conn-&gt;rx_tfm)
+				tcp_conn-&gt;rx_tfm = crypto_alloc_tfm("crc32c",
+								    0);
+			if (!tcp_conn-&gt;rx_tfm) {
+				crypto_free_tfm(tcp_conn-&gt;tx_tfm);
 				return -ENOMEM;
 			}
 		} else {
-			if (conn-&gt;tx_tfm)
-				crypto_free_tfm(conn-&gt;tx_tfm);
-			if (conn-&gt;rx_tfm)
-				crypto_free_tfm(conn-&gt;rx_tfm);
+			if (tcp_conn-&gt;tx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;tx_tfm);
+			if (tcp_conn-&gt;rx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;rx_tfm);
 		}
 		break;
 	case ISCSI_PARAM_DATADGST_EN:
 		conn-&gt;datadgst_en = value;
 		if (conn-&gt;datadgst_en) {
-			if (!conn-&gt;data_tx_tfm)
-				conn-&gt;data_tx_tfm =
+			if (!tcp_conn-&gt;data_tx_tfm)
+				tcp_conn-&gt;data_tx_tfm =
 				    crypto_alloc_tfm("crc32c", 0);
-			if (!conn-&gt;data_tx_tfm)
+			if (!tcp_conn-&gt;data_tx_tfm)
 				return -ENOMEM;
-			if (!conn-&gt;data_rx_tfm)
-				conn-&gt;data_rx_tfm =
+			if (!tcp_conn-&gt;data_rx_tfm)
+				tcp_conn-&gt;data_rx_tfm =
 				    crypto_alloc_tfm("crc32c", 0);
-			if (!conn-&gt;data_rx_tfm) {
-				crypto_free_tfm(conn-&gt;data_tx_tfm);
+			if (!tcp_conn-&gt;data_rx_tfm) {
+				crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
 				return -ENOMEM;
 			}
 		} else {
-			if (conn-&gt;data_tx_tfm)
-				crypto_free_tfm(conn-&gt;data_tx_tfm);
-			if (conn-&gt;data_rx_tfm)
-				crypto_free_tfm(conn-&gt;data_rx_tfm);
+			if (tcp_conn-&gt;data_tx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;data_tx_tfm);
+			if (tcp_conn-&gt;data_rx_tfm)
+				crypto_free_tfm(tcp_conn-&gt;data_rx_tfm);
 		}
-		conn-&gt;sendpage = conn-&gt;datadgst_en ?
-			sock_no_sendpage : conn-&gt;sock-&gt;ops-&gt;sendpage;
+		tcp_conn-&gt;sendpage = conn-&gt;datadgst_en ?
+			sock_no_sendpage : tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
 		break;
 	case ISCSI_PARAM_INITIAL_R2T_EN:
 		session-&gt;initial_r2t_en = value;
@@ -3677,6 +2355,7 @@ iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 		     enum iscsi_param param, uint32_t *value)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct inet_sock *inet;
 
 	switch(param) {
@@ -3694,12 +2373,12 @@ iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 		break;
 	case ISCSI_PARAM_CONN_PORT:
 		mutex_lock(&amp;conn-&gt;xmitmutex);
-		if (!conn-&gt;sock) {
+		if (!tcp_conn-&gt;sock) {
 			mutex_unlock(&amp;conn-&gt;xmitmutex);
 			return -EINVAL;
 		}
 
-		inet = inet_sk(conn-&gt;sock-&gt;sk);
+		inet = inet_sk(tcp_conn-&gt;sock-&gt;sk);
 		*value = be16_to_cpu(inet-&gt;dport);
 		mutex_unlock(&amp;conn-&gt;xmitmutex);
 	default:
@@ -3714,6 +2393,7 @@ iscsi_conn_get_str_param(struct iscsi_cls_conn *cls_conn,
 			 enum iscsi_param param, char *buf)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct sock *sk;
 	struct inet_sock *inet;
 	struct ipv6_pinfo *np;
@@ -3722,12 +2402,12 @@ iscsi_conn_get_str_param(struct iscsi_cls_conn *cls_conn,
 	switch (param) {
 	case ISCSI_PARAM_CONN_ADDRESS:
 		mutex_lock(&amp;conn-&gt;xmitmutex);
-		if (!conn-&gt;sock) {
+		if (!tcp_conn-&gt;sock) {
 			mutex_unlock(&amp;conn-&gt;xmitmutex);
 			return -EINVAL;
 		}
 
-		sk = conn-&gt;sock-&gt;sk;
+		sk = tcp_conn-&gt;sock-&gt;sk;
 		if (sk-&gt;sk_family == PF_INET) {
 			inet = inet_sk(sk);
 			len = sprintf(buf, "%u.%u.%u.%u\n",
@@ -3751,6 +2431,7 @@ static void
 iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 
 	stats-&gt;txdata_octets = conn-&gt;txdata_octets;
 	stats-&gt;rxdata_octets = conn-&gt;rxdata_octets;
@@ -3763,27 +2444,92 @@ iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
 	stats-&gt;tmfrsp_pdus = conn-&gt;tmfrsp_pdus_cnt;
 	stats-&gt;custom_length = 3;
 	strcpy(stats-&gt;custom[0].desc, "tx_sendpage_failures");
-	stats-&gt;custom[0].value = conn-&gt;sendpage_failures_cnt;
+	stats-&gt;custom[0].value = tcp_conn-&gt;sendpage_failures_cnt;
 	strcpy(stats-&gt;custom[1].desc, "rx_discontiguous_hdr");
-	stats-&gt;custom[1].value = conn-&gt;discontiguous_hdr_cnt;
+	stats-&gt;custom[1].value = tcp_conn-&gt;discontiguous_hdr_cnt;
 	strcpy(stats-&gt;custom[2].desc, "eh_abort_cnt");
 	stats-&gt;custom[2].value = conn-&gt;eh_abort_cnt;
 }
 
-static int
-iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,
-		    char *data, uint32_t data_size)
+static struct iscsi_cls_session *
+iscsi_tcp_session_create(struct iscsi_transport *iscsit,
+			 struct scsi_transport_template *scsit,
+			 uint32_t initial_cmdsn, uint32_t *hostno)
 {
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	int rc;
+	struct iscsi_cls_session *cls_session;
+	struct iscsi_session *session;
+	uint32_t hn;
+	int cmd_i;
 
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-	rc = iscsi_conn_send_generic(conn, hdr, data, data_size);
-	mutex_unlock(&amp;conn-&gt;xmitmutex);
+	cls_session = iscsi_session_setup(iscsit, scsit,
+					 sizeof(struct iscsi_tcp_cmd_task),
+					 sizeof(struct iscsi_tcp_mgmt_task),
+					 initial_cmdsn, &amp;hn);
+	if (!cls_session)
+		return NULL;
+	*hostno = hn;
 
-	return rc;
+	session = class_to_transport_session(cls_session);
+	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		ctask-&gt;hdr = &amp;tcp_ctask-&gt;hdr;
+	}
+
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++) {
+		struct iscsi_mgmt_task *mtask = session-&gt;mgmt_cmds[cmd_i];
+		struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
+
+		mtask-&gt;hdr = &amp;tcp_mtask-&gt;hdr;
+	}
+
+	if (iscsi_r2tpool_alloc(class_to_transport_session(cls_session)))
+		goto r2tpool_alloc_fail;
+
+	return cls_session;
+
+r2tpool_alloc_fail:
+	iscsi_session_teardown(cls_session);
+	return NULL;
+}
+
+static void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_data_task *dtask, *n;
+	int cmd_i;
+
+	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+
+		list_for_each_entry_safe(dtask, n, &amp;tcp_ctask-&gt;dataqueue,
+					 item) {
+			list_del(&amp;dtask-&gt;item);
+			mempool_free(dtask, tcp_ctask-&gt;datapool);
+		}
+	}
+
+	iscsi_r2tpool_free(class_to_transport_session(cls_session));
+	iscsi_session_teardown(cls_session);
 }
 
+static struct scsi_host_template iscsi_sht = {
+	.name			= "iSCSI Initiator over TCP/IP, v."
+				  ISCSI_VERSION_STR,
+	.queuecommand           = iscsi_queuecommand,
+	.change_queue_depth	= iscsi_change_queue_depth,
+	.can_queue		= ISCSI_XMIT_CMDS_MAX - 1,
+	.sg_tablesize		= ISCSI_SG_TABLESIZE,
+	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
+	.eh_abort_handler       = iscsi_eh_abort,
+	.eh_host_reset_handler	= iscsi_eh_host_reset,
+	.use_clustering         = DISABLE_CLUSTERING,
+	.proc_name		= "iscsi_tcp",
+	.this_id		= -1,
+};
+
 static struct iscsi_transport iscsi_tcp_transport = {
 	.owner			= THIS_MODULE,
 	.name			= "tcp",
@@ -3804,23 +2550,34 @@ static struct iscsi_transport iscsi_tcp_transport = {
 				  ISCSI_CONN_PORT |
 				  ISCSI_CONN_ADDRESS,
 	.host_template		= &amp;iscsi_sht,
-	.hostdata_size		= sizeof(struct iscsi_session),
 	.conndata_size		= sizeof(struct iscsi_conn),
 	.max_conn		= 1,
 	.max_cmd_len		= ISCSI_TCP_MAX_CMD_LEN,
-	.create_session		= iscsi_session_create,
-	.destroy_session	= iscsi_session_destroy,
-	.create_conn		= iscsi_conn_create,
-	.bind_conn		= iscsi_conn_bind,
-	.destroy_conn		= iscsi_conn_destroy,
+	/* session management */
+	.create_session		= iscsi_tcp_session_create,
+	.destroy_session	= iscsi_tcp_session_destroy,
+	/* connection management */
+	.create_conn		= iscsi_tcp_conn_create,
+	.bind_conn		= iscsi_tcp_conn_bind,
+	.destroy_conn		= iscsi_tcp_conn_destroy,
 	.set_param		= iscsi_conn_set_param,
 	.get_conn_param		= iscsi_conn_get_param,
 	.get_conn_str_param	= iscsi_conn_get_str_param,
 	.get_session_param	= iscsi_session_get_param,
 	.start_conn		= iscsi_conn_start,
 	.stop_conn		= iscsi_conn_stop,
+	/* these are called as part of conn recovery */
+	.suspend_conn_recv	= iscsi_tcp_suspend_conn_rx,
+	.terminate_conn		= iscsi_tcp_terminate_conn,
+	/* IO */
 	.send_pdu		= iscsi_conn_send_pdu,
 	.get_stats		= iscsi_conn_get_stats,
+	.init_cmd_task		= iscsi_tcp_cmd_init,
+	.init_mgmt_task		= iscsi_tcp_mgmt_init,
+	.xmit_cmd_task		= iscsi_tcp_ctask_xmit,
+	.xmit_mgmt_task		= iscsi_tcp_mtask_xmit,
+	.cleanup_cmd_task	= iscsi_tcp_cleanup_ctask,
+	/* recovery */
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 };
 
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index 12ef64179b4c..c5918854d595 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -2,7 +2,8 @@
  * iSCSI Initiator TCP Transport
  * Copyright (C) 2004 Dmitry Yusupov
  * Copyright (C) 2004 Alex Aizman
- * Copyright (C) 2005 Mike Christie
+ * Copyright (C) 2005 - 2006 Mike Christie
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
  * maintained by open-iscsi@googlegroups.com
  *
  * This program is free software; you can redistribute it and/or modify
@@ -21,20 +22,7 @@
 #ifndef ISCSI_TCP_H
 #define ISCSI_TCP_H
 
-/* Session's states */
-#define ISCSI_STATE_FREE		1
-#define ISCSI_STATE_LOGGED_IN		2
-#define ISCSI_STATE_FAILED		3
-#define ISCSI_STATE_TERMINATE		4
-
-/* Connection's states */
-#define ISCSI_CONN_INITIAL_STAGE	0
-#define ISCSI_CONN_STARTED		1
-#define ISCSI_CONN_STOPPED		2
-#define ISCSI_CONN_CLEANUP_WAIT		3
-
-/* Connection suspend "bit" */
-#define SUSPEND_BIT			1
+#include &lt;scsi/libiscsi.h&gt;
 
 /* Socket's Receive state machine */
 #define IN_PROGRESS_WAIT_HEADER		0x0
@@ -42,12 +30,6 @@
 #define IN_PROGRESS_DATA_RECV		0x2
 #define IN_PROGRESS_DDIGEST_RECV	0x3
 
-/* Task Mgmt states */
-#define	TMABORT_INITIAL			0x0
-#define	TMABORT_SUCCESS			0x1
-#define	TMABORT_FAILED			0x2
-#define	TMABORT_TIMEDOUT		0x3
-
 /* xmit state machine */
 #define	XMSTATE_IDLE			0x0
 #define	XMSTATE_R_HDR			0x1
@@ -62,34 +44,14 @@
 #define	XMSTATE_W_PAD			0x200
 #define XMSTATE_DATA_DIGEST		0x400
 
-#define ISCSI_CONN_MAX			1
 #define ISCSI_CONN_RCVBUF_MIN		262144
 #define ISCSI_CONN_SNDBUF_MIN		262144
 #define ISCSI_PAD_LEN			4
 #define ISCSI_R2T_MAX			16
-#define ISCSI_XMIT_CMDS_MAX		128	/* must be power of 2 */
-#define ISCSI_MGMT_CMDS_MAX		32	/* must be power of 2 */
-#define ISCSI_MGMT_ITT_OFFSET		0xa00
 #define ISCSI_SG_TABLESIZE		SG_ALL
-#define ISCSI_DEF_CMD_PER_LUN		32
-#define ISCSI_MAX_CMD_PER_LUN		128
 #define ISCSI_TCP_MAX_CMD_LEN		16
 
-#define ITT_MASK			(0xfff)
-#define CID_SHIFT			12
-#define CID_MASK			(0xffff&lt;&lt;CID_SHIFT)
-#define AGE_SHIFT			28
-#define AGE_MASK			(0xf&lt;&lt;AGE_SHIFT)
-
-struct iscsi_queue {
-	struct kfifo		*queue;		/* FIFO Queue */
-	void			**pool;		/* Pool of elements */
-	int			max;		/* Max number of elements */
-};
-
-struct iscsi_session;
-struct iscsi_cmd_task;
-struct iscsi_mgmt_task;
+struct socket;
 
 /* Socket connection recieve helper */
 struct iscsi_tcp_recv {
@@ -104,48 +66,32 @@ struct iscsi_tcp_recv {
 	struct iscsi_cmd_task	*ctask;		/* current cmd in progress */
 
 	/* copied and flipped values */
-	int			opcode;
-	int			flags;
-	int			cmd_status;
-	int			ahslen;
 	int			datalen;
-	uint32_t		itt;
 	int			datadgst;
+	char			zero_copy_hdr;
 };
 
-struct iscsi_cls_conn;
-
-struct iscsi_conn {
-	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
+struct iscsi_tcp_conn {
+	struct iscsi_conn	*iscsi_conn;
+	struct socket		*sock;
 	struct iscsi_hdr	hdr;		/* header placeholder */
 	char			hdrext[4*sizeof(__u16) +
 				    sizeof(__u32)];
 	int			data_copied;
 	char			*data;		/* data placeholder */
-	struct socket           *sock;          /* TCP socket */
 	int			data_size;	/* actual recv_dlength */
 	int			stop_stage;	/* conn_stop() flag: *
 						 * stop to recover,  *
 						 * stop to terminate */
 	/* iSCSI connection-wide sequencing */
-	uint32_t		exp_statsn;
 	int			hdr_size;	/* PDU header size */
-	unsigned long		suspend_rx;	/* suspend Rx */
 
 	struct crypto_tfm	*rx_tfm;	/* CRC32C (Rx) */
 	struct crypto_tfm	*data_rx_tfm;	/* CRC32C (Rx) for data */
 
 	/* control data */
-	int			senselen;	/* scsi sense length */
-	int			id;		/* CID */
 	struct iscsi_tcp_recv	in;		/* TCP receive context */
-	struct iscsi_session	*session;	/* parent session */
-	struct list_head	item;		/* maintains list of conns */
 	int			in_progress;	/* connection state machine */
-	int			c_stage;	/* connection state */
-	struct iscsi_mgmt_task	*login_mtask;	/* mtask used for login/text */
-	struct iscsi_mgmt_task	*mtask;		/* xmit mtask in progress */
-	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
 
 	/* old values for socket callbacks */
 	void			(*old_data_ready)(struct sock *, int);
@@ -155,95 +101,14 @@ struct iscsi_conn {
 	/* xmit */
 	struct crypto_tfm	*tx_tfm;	/* CRC32C (Tx) */
 	struct crypto_tfm	*data_tx_tfm;	/* CRC32C (Tx) for data */
-	struct kfifo		*writequeue;	/* write cmds for Data-Outs */
-	struct kfifo		*immqueue;	/* immediate xmit queue */
-	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
-	struct kfifo		*xmitqueue;	/* data-path cmd queue */
-	struct list_head	run_list;	/* list of cmds in progress */
-	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
-	struct mutex		xmitmutex;	/* serializes connection xmit,
-						 * access to kfifos:	  *
-						 * xmitqueue, writequeue, *
-						 * immqueue, mgmtqueue    */
-	unsigned long		suspend_tx;	/* suspend Tx */
-
-	/* abort */
-	wait_queue_head_t	ehwait;		/* used in eh_abort()     */
-	struct iscsi_tm		tmhdr;
-	struct timer_list	tmabort_timer;  /* abort timer */
-	int			tmabort_state;  /* see TMABORT_INITIAL, etc.*/
-
-	/* negotiated params */
-	int			max_recv_dlength;
-	int			max_xmit_dlength;
-	int			hdrdgst_en;
-	int			datadgst_en;
 
-	/* MIB-statistics */
-	uint64_t		txdata_octets;
-	uint64_t		rxdata_octets;
-	uint32_t		scsicmd_pdus_cnt;
-	uint32_t		dataout_pdus_cnt;
-	uint32_t		scsirsp_pdus_cnt;
-	uint32_t		datain_pdus_cnt;
-	uint32_t		r2t_pdus_cnt;
-	uint32_t		tmfcmd_pdus_cnt;
-	int32_t			tmfrsp_pdus_cnt;
-
-	/* custom statistics */
+	/* MIB custom statistics */
 	uint32_t		sendpage_failures_cnt;
 	uint32_t		discontiguous_hdr_cnt;
-	uint32_t		eh_abort_cnt;
 
 	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
 };
 
-struct iscsi_session {
-	/* iSCSI session-wide sequencing */
-	uint32_t		cmdsn;
-	uint32_t		exp_cmdsn;
-	uint32_t		max_cmdsn;
-
-	/* configuration */
-	int			initial_r2t_en;
-	int			max_r2t;
-	int			imm_data_en;
-	int			first_burst;
-	int			max_burst;
-	int			time2wait;
-	int			time2retain;
-	int			pdu_inorder_en;
-	int			dataseq_inorder_en;
-	int			erl;
-	int			ifmarker_en;
-	int			ofmarker_en;
-
-	/* control data */
-	struct Scsi_Host	*host;
-	int			id;
-	struct iscsi_conn	*leadconn;	/* leading connection */
-	spinlock_t		lock;		/* protects session state, *
-						 * sequence numbers,       *
-						 * session resources:      *
-						 * - cmdpool,		   *
-						 * - mgmtpool,		   *
-						 * - r2tpool		   */
-	int			state;		/* session state           */
-	int			recovery_failed;
-	struct list_head	item;
-	void			*auth_client;
-	int			conn_cnt;
-	int			age;		/* counts session re-opens */
-
-	struct list_head	connections;	/* list of connections */
-	int			cmds_max;	/* size of cmds array */
-	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
-	struct iscsi_queue	cmdpool;	/* PDU's pool */
-	int			mgmtpool_max;	/* size of mgmt array */
-	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
-	struct iscsi_queue	mgmtpool;	/* Mgmt PDU's pool */
-};
-
 struct iscsi_buf {
 	struct scatterlist	sg;
 	unsigned int		sent;
@@ -259,16 +124,13 @@ struct iscsi_data_task {
 };
 #define ISCSI_DTASK_DEFAULT_MAX	ISCSI_SG_TABLESIZE * PAGE_SIZE / 512
 
-struct iscsi_mgmt_task {
-	struct iscsi_hdr	hdr;		/* mgmt. PDU */
-	char			hdrext[sizeof(__u32)];	/* Header-Digest */
-	char			*data;		/* mgmt payload */
+struct iscsi_tcp_mgmt_task {
+	struct iscsi_hdr	hdr;
+	char			hdrext[sizeof(__u32)]; /* Header-Digest */
 	int			xmstate;	/* mgmt xmit progress */
-	int			data_count;	/* counts data to be sent */
 	struct iscsi_buf	headbuf;	/* header buffer */
 	struct iscsi_buf	sendbuf;	/* in progress buffer */
 	int			sent;
-	uint32_t		itt;		/* this ITT */
 };
 
 struct iscsi_r2t_info {
@@ -285,34 +147,22 @@ struct iscsi_r2t_info {
 	struct iscsi_data_task   *dtask;        /* which data task */
 };
 
-struct iscsi_cmd_task {
-	struct iscsi_cmd	hdr;			/* iSCSI PDU header */
+struct iscsi_tcp_cmd_task {
+	struct iscsi_cmd	hdr;
 	char			hdrext[4*sizeof(__u16)+	/* AHS */
 				    sizeof(__u32)];	/* HeaderDigest */
 	char			pad[ISCSI_PAD_LEN];
-	int			itt;			/* this ITT */
-	int			datasn;			/* DataSN */
+	int			pad_count;		/* padded bytes */
 	struct iscsi_buf	headbuf;		/* header buf (xmit) */
 	struct iscsi_buf	sendbuf;		/* in progress buffer*/
+	int			xmstate;		/* xmit xtate machine */
 	int			sent;
 	struct scatterlist	*sg;			/* per-cmd SG list  */
 	struct scatterlist	*bad_sg;		/* assert statement */
 	int			sg_count;		/* SG's to process  */
-	uint32_t		unsol_datasn;
 	uint32_t		exp_r2tsn;
-	int			xmstate;		/* xmit xtate machine */
-	int			imm_count;		/* imm-data (bytes)   */
-	int			unsol_count;		/* unsolicited (bytes)*/
 	int			r2t_data_count;		/* R2T Data-Out bytes */
-	int			data_count;		/* remaining Data-Out */
-	int			pad_count;		/* padded bytes */
-	struct scsi_cmnd	*sc;			/* associated SCSI cmd*/
-	int			total_length;
 	int			data_offset;
-	struct iscsi_conn	*conn;			/* used connection    */
-	struct iscsi_mgmt_task	*mtask;			/* tmf mtask in progr */
-
-	struct list_head	running;		/* running cmd list */
 	struct iscsi_r2t_info	*r2t;			/* in progress R2T    */
 	struct iscsi_queue	r2tpool;
 	struct kfifo		*r2tqueue;</pre><hr><pre>commit 7996a778ff8c717cb1a7a294475c59cc8f1e9fb8
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Apr 6 21:13:41 2006 -0500

    [SCSI] iscsi: add libiscsi
    
    There is a lot of code duplcited between iscsi_tcp
    and the upcoming iscsi_iser driver. This patch puts
    the duplicated code in a lib. There is more code
    to move around but this takes care of the
    basics. For iscsi_offload if they use the lib we will
    probably move some things around. For example in the
    queuecommand we will not assume that the LLD wants
    to do queue_work, but it is better to handle that
    later when we know for sure what iscsi_offload looks
    like (we could probably do this for iscsi_iser though to).
    
    Ideally I would like to get the iscsi_transports modules
    to a place where all they really have to do is put data
    on the wire, but how to do that will hopefully be more clear
    when we see other modules like iscsi_offload. Or maybe
    iscsi_offload will not use the lib and it will just be
    iscsi_iser and iscsi_tcp and maybe the iscsi_tcp_tgt if that
    is allowed in mainline.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
index e513c3158ad9..efdff61c5808 100644
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -33,7 +33,7 @@ obj-$(CONFIG_SCSI_FC_ATTRS) 	+= scsi_transport_fc.o
 obj-$(CONFIG_SCSI_ISCSI_ATTRS)	+= scsi_transport_iscsi.o
 obj-$(CONFIG_SCSI_SAS_ATTRS)	+= scsi_transport_sas.o
 
-obj-$(CONFIG_ISCSI_TCP) 	+= iscsi_tcp.o
+obj-$(CONFIG_ISCSI_TCP) 	+= libiscsi.o	iscsi_tcp.o
 obj-$(CONFIG_SCSI_AMIGA7XX)	+= amiga7xx.o	53c7xx.o
 obj-$(CONFIG_A3000_SCSI)	+= a3000.o	wd33c93.o
 obj-$(CONFIG_A2091_SCSI)	+= a2091.o	wd33c93.o
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
new file mode 100644
index 000000000000..274a1374ab64
--- /dev/null
+++ b/drivers/scsi/libiscsi.c
@@ -0,0 +1,1697 @@
+/*
+ * iSCSI lib functions
+ *
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004 - 2006 Mike Christie
+ * Copyright (C) 2004 - 2005 Dmitry Yusupov
+ * Copyright (C) 2004 - 2005 Alex Aizman
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include &lt;linux/types.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/kfifo.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;net/tcp.h&gt;
+#include &lt;scsi/scsi_cmnd.h&gt;
+#include &lt;scsi/scsi_device.h&gt;
+#include &lt;scsi/scsi_eh.h&gt;
+#include &lt;scsi/scsi_tcq.h&gt;
+#include &lt;scsi/scsi_host.h&gt;
+#include &lt;scsi/scsi.h&gt;
+#include &lt;scsi/iscsi_proto.h&gt;
+#include &lt;scsi/scsi_transport.h&gt;
+#include &lt;scsi/scsi_transport_iscsi.h&gt;
+#include &lt;scsi/libiscsi.h&gt;
+
+struct iscsi_session *
+class_to_transport_session(struct iscsi_cls_session *cls_session)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	return iscsi_hostdata(shost-&gt;hostdata);
+}
+EXPORT_SYMBOL_GPL(class_to_transport_session);
+
+#define INVALID_SN_DELTA	0xffff
+
+int
+iscsi_check_assign_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
+{
+	uint32_t max_cmdsn = be32_to_cpu(hdr-&gt;max_cmdsn);
+	uint32_t exp_cmdsn = be32_to_cpu(hdr-&gt;exp_cmdsn);
+
+	if (max_cmdsn &lt; exp_cmdsn -1 &amp;&amp;
+	    max_cmdsn &gt; exp_cmdsn - INVALID_SN_DELTA)
+		return ISCSI_ERR_MAX_CMDSN;
+	if (max_cmdsn &gt; session-&gt;max_cmdsn ||
+	    max_cmdsn &lt; session-&gt;max_cmdsn - INVALID_SN_DELTA)
+		session-&gt;max_cmdsn = max_cmdsn;
+	if (exp_cmdsn &gt; session-&gt;exp_cmdsn ||
+	    exp_cmdsn &lt; session-&gt;exp_cmdsn - INVALID_SN_DELTA)
+		session-&gt;exp_cmdsn = exp_cmdsn;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_check_assign_cmdsn);
+
+void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *ctask,
+				   struct iscsi_data *hdr,
+				   int transport_data_cnt)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+
+	memset(hdr, 0, sizeof(struct iscsi_data));
+	hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+	hdr-&gt;datasn = cpu_to_be32(ctask-&gt;unsol_datasn);
+	ctask-&gt;unsol_datasn++;
+	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+
+	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
+	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
+
+	hdr-&gt;offset = cpu_to_be32(ctask-&gt;total_length -
+				  transport_data_cnt -
+				  ctask-&gt;unsol_count);
+
+	if (ctask-&gt;unsol_count &gt; conn-&gt;max_xmit_dlength) {
+		hton24(hdr-&gt;dlength, conn-&gt;max_xmit_dlength);
+		ctask-&gt;data_count = conn-&gt;max_xmit_dlength;
+		hdr-&gt;flags = 0;
+	} else {
+		hton24(hdr-&gt;dlength, ctask-&gt;unsol_count);
+		ctask-&gt;data_count = ctask-&gt;unsol_count;
+		hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
+	}
+}
+EXPORT_SYMBOL_GPL(iscsi_prep_unsolicit_data_pdu);
+
+/**
+ * iscsi_prep_scsi_cmd_pdu - prep iscsi scsi cmd pdu
+ * @ctask: iscsi cmd task
+ *
+ * Prep basic iSCSI PDU fields for a scsi cmd pdu. The LLD should set
+ * fields like dlength or final based on how much data it sends
+ */
+static void iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_cmd *hdr = ctask-&gt;hdr;
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+
+        hdr-&gt;opcode = ISCSI_OP_SCSI_CMD;
+        hdr-&gt;flags = ISCSI_ATTR_SIMPLE;
+        int_to_scsilun(sc-&gt;device-&gt;lun, (struct scsi_lun *)hdr-&gt;lun);
+        hdr-&gt;itt = ctask-&gt;itt | (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT) |
+                         (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT);
+        hdr-&gt;data_length = cpu_to_be32(sc-&gt;request_bufflen);
+        hdr-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+        session-&gt;cmdsn++;
+        hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
+        memcpy(hdr-&gt;cdb, sc-&gt;cmnd, sc-&gt;cmd_len);
+        memset(&amp;hdr-&gt;cdb[sc-&gt;cmd_len], 0, MAX_COMMAND_SIZE - sc-&gt;cmd_len);
+
+	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
+		hdr-&gt;flags |= ISCSI_FLAG_CMD_WRITE;
+		/*
+		 * Write counters:
+		 *
+		 *	imm_count	bytes to be sent right after
+		 *			SCSI PDU Header
+		 *
+		 *	unsol_count	bytes(as Data-Out) to be sent
+		 *			without	R2T ack right after
+		 *			immediate data
+		 *
+		 *	r2t_data_count	bytes to be sent via R2T ack's
+		 *
+		 *      pad_count       bytes to be sent as zero-padding
+		 */
+		ctask-&gt;imm_count = 0;
+		ctask-&gt;unsol_count = 0;
+		ctask-&gt;unsol_datasn = 0;
+
+		if (session-&gt;imm_data_en) {
+			if (ctask-&gt;total_length &gt;= session-&gt;first_burst)
+				ctask-&gt;imm_count = min(session-&gt;first_burst,
+							conn-&gt;max_xmit_dlength);
+			else
+				ctask-&gt;imm_count = min(ctask-&gt;total_length,
+							conn-&gt;max_xmit_dlength);
+			hton24(ctask-&gt;hdr-&gt;dlength, ctask-&gt;imm_count);
+		} else
+			zero_data(ctask-&gt;hdr-&gt;dlength);
+
+		if (!session-&gt;initial_r2t_en)
+			ctask-&gt;unsol_count = min(session-&gt;first_burst,
+				ctask-&gt;total_length) - ctask-&gt;imm_count;
+		if (!ctask-&gt;unsol_count)
+			/* No unsolicit Data-Out's */
+			ctask-&gt;hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
+	} else {
+		ctask-&gt;datasn = 0;
+		hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
+		zero_data(hdr-&gt;dlength);
+
+		if (sc-&gt;sc_data_direction == DMA_FROM_DEVICE)
+			hdr-&gt;flags |= ISCSI_FLAG_CMD_READ;
+	}
+
+	conn-&gt;scsicmd_pdus_cnt++;
+}
+EXPORT_SYMBOL_GPL(iscsi_prep_scsi_cmd_pdu);
+
+/**
+ * iscsi_complete_command - return command back to scsi-ml
+ * @session: iscsi session
+ * @ctask: iscsi cmd task
+ *
+ * Must be called with session lock.
+ * This function returns the scsi command to scsi-ml and returns
+ * the cmd task to the pool of available cmd tasks.
+ */
+static void iscsi_complete_command(struct iscsi_session *session,
+				   struct iscsi_cmd_task *ctask)
+{
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+
+	ctask-&gt;sc = NULL;
+	list_del_init(&amp;ctask-&gt;running);
+	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
+	sc-&gt;scsi_done(sc);
+}
+
+/**
+ * iscsi_cmd_rsp - SCSI Command Response processing
+ * @conn: iscsi connection
+ * @hdr: iscsi header
+ * @ctask: scsi command task
+ * @data: cmd data buffer
+ * @datalen: len of buffer
+ *
+ * iscsi_cmd_rsp sets up the scsi_cmnd fields based on the PDU and
+ * then completes the command and task.
+ **/
+static int iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+			      struct iscsi_cmd_task *ctask, char *data,
+			      int datalen)
+{
+	int rc;
+	struct iscsi_cmd_rsp *rhdr = (struct iscsi_cmd_rsp *)hdr;
+	struct iscsi_session *session = conn-&gt;session;
+	struct scsi_cmnd *sc = ctask-&gt;sc;
+
+	rc = iscsi_check_assign_cmdsn(session, (struct iscsi_nopin*)rhdr);
+	if (rc) {
+		sc-&gt;result = DID_ERROR &lt;&lt; 16;
+		goto out;
+	}
+
+	conn-&gt;exp_statsn = be32_to_cpu(rhdr-&gt;statsn) + 1;
+
+	sc-&gt;result = (DID_OK &lt;&lt; 16) | rhdr-&gt;cmd_status;
+
+	if (rhdr-&gt;response != ISCSI_STATUS_CMD_COMPLETED) {
+		sc-&gt;result = DID_ERROR &lt;&lt; 16;
+		goto out;
+	}
+
+	if (rhdr-&gt;cmd_status == SAM_STAT_CHECK_CONDITION) {
+		int senselen;
+
+		if (datalen &lt; 2) {
+invalid_datalen:
+			printk(KERN_ERR "Got CHECK_CONDITION but invalid "
+			       "data buffer size of %d\n", datalen);
+			sc-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
+			goto out;
+		}
+
+		senselen = (data[0] &lt;&lt; 8) | data[1];
+		if (datalen &lt; senselen)
+			goto invalid_datalen;
+
+		memcpy(sc-&gt;sense_buffer, data + 2,
+		       min(senselen, SCSI_SENSE_BUFFERSIZE));
+		debug_scsi("copied %d bytes of sense\n",
+			   min(senselen, SCSI_SENSE_BUFFERSIZE));
+	}
+
+	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE)
+		goto out;
+
+	if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_UNDERFLOW) {
+		int res_count = be32_to_cpu(rhdr-&gt;residual_count);
+
+		if (res_count &gt; 0 &amp;&amp; res_count &lt;= sc-&gt;request_bufflen)
+			sc-&gt;resid = res_count;
+		else
+			sc-&gt;result = (DID_BAD_TARGET &lt;&lt; 16) | rhdr-&gt;cmd_status;
+	} else if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_BIDI_UNDERFLOW)
+		sc-&gt;result = (DID_BAD_TARGET &lt;&lt; 16) | rhdr-&gt;cmd_status;
+	else if (rhdr-&gt;flags &amp; ISCSI_FLAG_CMD_OVERFLOW)
+		sc-&gt;resid = be32_to_cpu(rhdr-&gt;residual_count);
+
+out:
+	debug_scsi("done [sc %lx res %d itt 0x%x]\n",
+		   (long)sc, sc-&gt;result, ctask-&gt;itt);
+	conn-&gt;scsirsp_pdus_cnt++;
+
+	iscsi_complete_command(conn-&gt;session, ctask);
+	return rc;
+}
+
+/**
+ * __iscsi_complete_pdu - complete pdu
+ * @conn: iscsi conn
+ * @hdr: iscsi header
+ * @data: data buffer
+ * @datalen: len of data buffer
+ *
+ * Completes pdu processing by freeing any resources allocated at
+ * queuecommand or send generic. session lock must be held and verify
+ * itt must have been called.
+ */
+int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+			 char *data, int datalen)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	int opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, rc = 0;
+	struct iscsi_cmd_task *ctask;
+	struct iscsi_mgmt_task *mtask;
+	uint32_t itt;
+
+	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG))
+		itt = hdr-&gt;itt &amp; ISCSI_ITT_MASK;
+	else
+		itt = hdr-&gt;itt;
+
+	if (itt &lt; session-&gt;cmds_max) {
+		ctask = session-&gt;cmds[itt];
+
+		debug_scsi("cmdrsp [op 0x%x cid %d itt 0x%x len %d]\n",
+			   opcode, conn-&gt;id, ctask-&gt;itt, datalen);
+
+		switch(opcode) {
+		case ISCSI_OP_SCSI_CMD_RSP:
+			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
+			rc = iscsi_scsi_cmd_rsp(conn, hdr, ctask, data,
+						datalen);
+			break;
+		case ISCSI_OP_SCSI_DATA_IN:
+			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
+			if (hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
+				conn-&gt;scsirsp_pdus_cnt++;
+				iscsi_complete_command(session, ctask);
+			}
+			break;
+		case ISCSI_OP_R2T:
+			/* LLD handles this for now */
+			break;
+		default:
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		}
+	} else if (itt &gt;= ISCSI_MGMT_ITT_OFFSET &amp;&amp;
+		   itt &lt; ISCSI_MGMT_ITT_OFFSET + session-&gt;mgmtpool_max) {
+		mtask = session-&gt;mgmt_cmds[itt - ISCSI_MGMT_ITT_OFFSET];
+
+		debug_scsi("immrsp [op 0x%x cid %d itt 0x%x len %d]\n",
+			   opcode, conn-&gt;id, mtask-&gt;itt, datalen);
+
+		switch(opcode) {
+		case ISCSI_OP_LOGIN_RSP:
+		case ISCSI_OP_TEXT_RSP:
+		case ISCSI_OP_LOGOUT_RSP:
+			rc = iscsi_check_assign_cmdsn(session,
+						 (struct iscsi_nopin*)hdr);
+			if (rc)
+				break;
+
+			rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen);
+			list_del(&amp;mtask-&gt;running);
+			if (conn-&gt;login_mtask != mtask)
+				__kfifo_put(session-&gt;mgmtpool.queue,
+					    (void*)&amp;mtask, sizeof(void*));
+			break;
+		case ISCSI_OP_SCSI_TMFUNC_RSP:
+			rc = iscsi_check_assign_cmdsn(session,
+						 (struct iscsi_nopin*)hdr);
+			if (rc)
+				break;
+
+			if (datalen) {
+				rc = ISCSI_ERR_PROTO;
+				break;
+			}
+			conn-&gt;tmfrsp_pdus_cnt++;
+			if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
+				conn-&gt;tmabort_state =
+					((struct iscsi_tm_rsp *)hdr)-&gt;
+					response == ISCSI_TMF_RSP_COMPLETE ?
+						TMABORT_SUCCESS:TMABORT_FAILED;
+				/* unblock eh_abort() */
+				wake_up(&amp;conn-&gt;ehwait);
+			}
+			break;
+		case ISCSI_OP_NOOP_IN:
+			if (hdr-&gt;ttt != ISCSI_RESERVED_TAG) {
+				rc = ISCSI_ERR_PROTO;
+				break;
+			}
+			rc = iscsi_check_assign_cmdsn(session,
+						(struct iscsi_nopin*)hdr);
+			if (rc)
+				break;
+			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+
+			rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen);
+			list_del(&amp;mtask-&gt;running);
+			if (conn-&gt;login_mtask != mtask)
+				__kfifo_put(session-&gt;mgmtpool.queue,
+					    (void*)&amp;mtask, sizeof(void*));
+			break;
+		default:
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		}
+	} else if (itt == ISCSI_RESERVED_TAG) {
+		switch(opcode) {
+		case ISCSI_OP_NOOP_IN:
+			if (!datalen) {
+				rc = iscsi_check_assign_cmdsn(session,
+						 (struct iscsi_nopin*)hdr);
+				if (!rc &amp;&amp; hdr-&gt;ttt != ISCSI_RESERVED_TAG)
+					rc = iscsi_recv_pdu(conn-&gt;cls_conn,
+							    hdr, NULL, 0);
+			} else
+				rc = ISCSI_ERR_PROTO;
+			break;
+		case ISCSI_OP_REJECT:
+			/* we need sth like iscsi_reject_rsp()*/
+		case ISCSI_OP_ASYNC_EVENT:
+			/* we need sth like iscsi_async_event_rsp() */
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		default:
+			rc = ISCSI_ERR_BAD_OPCODE;
+			break;
+		}
+	} else
+		rc = ISCSI_ERR_BAD_ITT;
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(__iscsi_complete_pdu);
+
+int iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+		       char *data, int datalen)
+{
+	int rc;
+
+	spin_lock(&amp;conn-&gt;session-&gt;lock);
+	rc = __iscsi_complete_pdu(conn, hdr, data, datalen);
+	spin_unlock(&amp;conn-&gt;session-&gt;lock);
+	return rc;
+}
+EXPORT_SYMBOL_GPL(iscsi_complete_pdu);
+
+/* verify itt (itt encoding: age+cid+itt) */
+int iscsi_verify_itt(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+		     uint32_t *ret_itt)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_cmd_task *ctask;
+	uint32_t itt;
+
+	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		if ((hdr-&gt;itt &amp; ISCSI_AGE_MASK) !=
+		    (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT)) {
+			printk(KERN_ERR "iscsi_tcp: received itt %x expected "
+				"session age (%x)\n", hdr-&gt;itt,
+				session-&gt;age &amp; ISCSI_AGE_MASK);
+			return ISCSI_ERR_BAD_ITT;
+		}
+
+		if ((hdr-&gt;itt &amp; ISCSI_CID_MASK) !=
+		    (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT)) {
+			printk(KERN_ERR "iscsi_tcp: received itt %x, expected "
+				"CID (%x)\n", hdr-&gt;itt, conn-&gt;id);
+			return ISCSI_ERR_BAD_ITT;
+		}
+		itt = hdr-&gt;itt &amp; ISCSI_ITT_MASK;
+	} else
+		itt = hdr-&gt;itt;
+
+	if (itt &lt; session-&gt;cmds_max) {
+		ctask = session-&gt;cmds[itt];
+
+		if (!ctask-&gt;sc) {
+			printk(KERN_INFO "iscsi_tcp: dropping ctask with "
+			       "itt 0x%x\n", ctask-&gt;itt);
+			/* force drop */
+			return ISCSI_ERR_NO_SCSI_CMD;
+		}
+
+		if (ctask-&gt;sc-&gt;SCp.phase != session-&gt;age) {
+			printk(KERN_ERR "iscsi_tcp: ctask's session age %d, "
+				"expected %d\n", ctask-&gt;sc-&gt;SCp.phase,
+				session-&gt;age);
+			return ISCSI_ERR_SESSION_FAILED;
+		}
+	}
+
+	*ret_itt = itt;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_verify_itt);
+
+void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	if (session-&gt;conn_cnt == 1 || session-&gt;leadconn == conn)
+		session-&gt;state = ISCSI_STATE_FAILED;
+	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+	iscsi_conn_error(conn-&gt;cls_conn, err);
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_failure);
+
+/**
+ * iscsi_data_xmit - xmit any command into the scheduled connection
+ * @conn: iscsi connection
+ *
+ * Notes:
+ *	The function can return -EAGAIN in which case the caller must
+ *	re-schedule it again later or recover. '0' return code means
+ *	successful xmit.
+ **/
+static int iscsi_data_xmit(struct iscsi_conn *conn)
+{
+	struct iscsi_transport *tt;
+
+	if (unlikely(conn-&gt;suspend_tx)) {
+		debug_scsi("conn %d Tx suspended!\n", conn-&gt;id);
+		return 0;
+	}
+	tt = conn-&gt;session-&gt;tt;
+
+	/*
+	 * Transmit in the following order:
+	 *
+	 * 1) un-finished xmit (ctask or mtask)
+	 * 2) immediate control PDUs
+	 * 3) write data
+	 * 4) SCSI commands
+	 * 5) non-immediate control PDUs
+	 *
+	 * No need to lock around __kfifo_get as long as
+	 * there's one producer and one consumer.
+	 */
+
+	BUG_ON(conn-&gt;ctask &amp;&amp; conn-&gt;mtask);
+
+	if (conn-&gt;ctask) {
+		if (tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask))
+			goto again;
+		/* done with this in-progress ctask */
+		conn-&gt;ctask = NULL;
+	}
+	if (conn-&gt;mtask) {
+	        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+		        goto again;
+		/* done with this in-progress mtask */
+		conn-&gt;mtask = NULL;
+	}
+
+	/* process immediate first */
+        if (unlikely(__kfifo_len(conn-&gt;immqueue))) {
+	        while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;conn-&gt;mtask,
+			           sizeof(void*))) {
+			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
+				      &amp;conn-&gt;mgmt_run_list);
+		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+			        goto again;
+	        }
+		/* done with this mtask */
+		conn-&gt;mtask = NULL;
+	}
+
+	/* process command queue */
+	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;conn-&gt;ctask,
+			   sizeof(void*))) {
+		/*
+		 * iscsi tcp may readd the task to the xmitqueue to send
+		 * write data
+		 */
+		if (list_empty(&amp;conn-&gt;ctask-&gt;running))
+			list_add_tail(&amp;conn-&gt;ctask-&gt;running, &amp;conn-&gt;run_list);
+		if (tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask))
+			goto again;
+	}
+	/* done with this ctask */
+	conn-&gt;ctask = NULL;
+
+	/* process the rest control plane PDUs, if any */
+        if (unlikely(__kfifo_len(conn-&gt;mgmtqueue))) {
+	        while (__kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;conn-&gt;mtask,
+			           sizeof(void*))) {
+			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
+				      &amp;conn-&gt;mgmt_run_list);
+		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+			        goto again;
+	        }
+		/* done with this mtask */
+		conn-&gt;mtask = NULL;
+	}
+
+	return 0;
+
+again:
+	if (unlikely(conn-&gt;suspend_tx))
+		return 0;
+
+	return -EAGAIN;
+}
+
+static void iscsi_xmitworker(void *data)
+{
+	struct iscsi_conn *conn = data;
+
+	/*
+	 * serialize Xmit worker on a per-connection basis.
+	 */
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	if (iscsi_data_xmit(conn))
+		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+}
+
+enum {
+	FAILURE_BAD_HOST = 1,
+	FAILURE_SESSION_FAILED,
+	FAILURE_SESSION_FREED,
+	FAILURE_WINDOW_CLOSED,
+	FAILURE_SESSION_TERMINATE,
+	FAILURE_SESSION_RECOVERY_TIMEOUT,
+};
+
+int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
+{
+	struct Scsi_Host *host;
+	int reason = 0;
+	struct iscsi_session *session;
+	struct iscsi_conn *conn;
+	struct iscsi_cmd_task *ctask = NULL;
+
+	sc-&gt;scsi_done = done;
+	sc-&gt;result = 0;
+
+	host = sc-&gt;device-&gt;host;
+	session = iscsi_hostdata(host-&gt;hostdata);
+
+	spin_lock(&amp;session-&gt;lock);
+
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
+		if (session-&gt;recovery_failed) {
+			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
+			goto fault;
+		} else if (session-&gt;state == ISCSI_STATE_FAILED) {
+			reason = FAILURE_SESSION_FAILED;
+			goto reject;
+		} else if (session-&gt;state == ISCSI_STATE_TERMINATE) {
+			reason = FAILURE_SESSION_TERMINATE;
+			goto fault;
+		}
+		reason = FAILURE_SESSION_FREED;
+		goto fault;
+	}
+
+	/*
+	 * Check for iSCSI window and take care of CmdSN wrap-around
+	 */
+	if ((int)(session-&gt;max_cmdsn - session-&gt;cmdsn) &lt; 0) {
+		reason = FAILURE_WINDOW_CLOSED;
+		goto reject;
+	}
+
+	conn = session-&gt;leadconn;
+
+	__kfifo_get(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
+	sc-&gt;SCp.phase = session-&gt;age;
+	sc-&gt;SCp.ptr = (char *)ctask;
+
+	ctask-&gt;mtask = NULL;
+	ctask-&gt;conn = conn;
+	ctask-&gt;sc = sc;
+	INIT_LIST_HEAD(&amp;ctask-&gt;running);
+	ctask-&gt;total_length = sc-&gt;request_bufflen;
+	iscsi_prep_scsi_cmd_pdu(ctask);
+
+	session-&gt;tt-&gt;init_cmd_task(ctask);
+
+	__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*));
+	debug_scsi(
+	       "ctask enq [%s cid %d sc %lx itt 0x%x len %d cmdsn %d win %d]\n",
+		sc-&gt;sc_data_direction == DMA_TO_DEVICE ? "write" : "read",
+		conn-&gt;id, (long)sc, ctask-&gt;itt, sc-&gt;request_bufflen,
+		session-&gt;cmdsn, session-&gt;max_cmdsn - session-&gt;exp_cmdsn + 1);
+	spin_unlock(&amp;session-&gt;lock);
+
+	scsi_queue_work(host, &amp;conn-&gt;xmitwork);
+	return 0;
+
+reject:
+	spin_unlock(&amp;session-&gt;lock);
+	debug_scsi("cmd 0x%x rejected (%d)\n", sc-&gt;cmnd[0], reason);
+	return SCSI_MLQUEUE_HOST_BUSY;
+
+fault:
+	spin_unlock(&amp;session-&gt;lock);
+	printk(KERN_ERR "iscsi_tcp: cmd 0x%x is not queued (%d)\n",
+	       sc-&gt;cmnd[0], reason);
+	sc-&gt;result = (DID_NO_CONNECT &lt;&lt; 16);
+	sc-&gt;resid = sc-&gt;request_bufflen;
+	sc-&gt;scsi_done(sc);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_queuecommand);
+
+int iscsi_change_queue_depth(struct scsi_device *sdev, int depth)
+{
+	if (depth &gt; ISCSI_MAX_CMD_PER_LUN)
+		depth = ISCSI_MAX_CMD_PER_LUN;
+	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+	return sdev-&gt;queue_depth;
+}
+EXPORT_SYMBOL_GPL(iscsi_change_queue_depth);
+
+static int
+iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+			char *data, uint32_t data_size)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;
+	struct iscsi_mgmt_task *mtask;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		return -EPERM;
+	}
+	if (hdr-&gt;opcode == (ISCSI_OP_LOGIN | ISCSI_OP_IMMEDIATE) ||
+	    hdr-&gt;opcode == (ISCSI_OP_TEXT | ISCSI_OP_IMMEDIATE))
+		/*
+		 * Login and Text are sent serially, in
+		 * request-followed-by-response sequence.
+		 * Same mtask can be used. Same ITT must be used.
+		 * Note that login_mtask is preallocated at conn_create().
+		 */
+		mtask = conn-&gt;login_mtask;
+	else {
+	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
+	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
+
+		if (!__kfifo_get(session-&gt;mgmtpool.queue,
+				 (void*)&amp;mtask, sizeof(void*))) {
+			spin_unlock_bh(&amp;session-&gt;lock);
+			return -ENOSPC;
+		}
+	}
+
+	/*
+	 * pre-format CmdSN and ExpStatSN for outgoing PDU.
+	 */
+	if (hdr-&gt;itt != cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		hdr-&gt;itt = mtask-&gt;itt | (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT) |
+			   (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT);
+		nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+		if (conn-&gt;c_stage == ISCSI_CONN_STARTED &amp;&amp;
+		    !(hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE))
+			session-&gt;cmdsn++;
+	} else
+		/* do not advance CmdSN */
+		nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+
+	nop-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
+
+	if (data_size) {
+		memcpy(mtask-&gt;data, data, data_size);
+		mtask-&gt;data_count = data_size;
+	} else
+		mtask-&gt;data_count = 0;
+
+	INIT_LIST_HEAD(&amp;mtask-&gt;running);
+	memcpy(mtask-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
+	if (session-&gt;tt-&gt;init_mgmt_task)
+		session-&gt;tt-&gt;init_mgmt_task(conn, mtask, data, data_size);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	debug_scsi("mgmtpdu [op 0x%x hdr-&gt;itt 0x%x datalen %d]\n",
+		   hdr-&gt;opcode, hdr-&gt;itt, data_size);
+
+	/*
+	 * since send_pdu() could be called at least from two contexts,
+	 * we need to serialize __kfifo_put, so we don't have to take
+	 * additional lock on fast data-path
+	 */
+        if (hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE)
+	        __kfifo_put(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*));
+	else
+	        __kfifo_put(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*));
+
+	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
+	return 0;
+}
+
+int iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,
+			char *data, uint32_t data_size)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	int rc;
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	rc = iscsi_conn_send_generic(conn, hdr, data, data_size);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	return rc;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_send_pdu);
+
+void iscsi_session_recovery_timedout(struct iscsi_cls_session *cls_session)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_conn *conn = session-&gt;leadconn;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
+		session-&gt;recovery_failed = 1;
+		if (conn)
+			wake_up(&amp;conn-&gt;ehwait);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+}
+EXPORT_SYMBOL_GPL(iscsi_session_recovery_timedout);
+
+int iscsi_eh_host_reset(struct scsi_cmnd *sc)
+{
+	struct Scsi_Host *host = sc-&gt;device-&gt;host;
+	struct iscsi_session *session = iscsi_hostdata(host-&gt;hostdata);
+	struct iscsi_conn *conn = session-&gt;leadconn;
+	int fail_session = 0;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
+failed:
+		debug_scsi("failing host reset: session terminated "
+			   "[CID %d age %d]", conn-&gt;id, session-&gt;age);
+		spin_unlock_bh(&amp;session-&gt;lock);
+		return FAILED;
+	}
+
+	if (sc-&gt;SCp.phase == session-&gt;age) {
+		debug_scsi("failing connection CID %d due to SCSI host reset",
+			   conn-&gt;id);
+		fail_session = 1;
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * we drop the lock here but the leadconn cannot be destoyed while
+	 * we are in the scsi eh
+	 */
+	if (fail_session) {
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		/*
+		 * if userspace cannot respond then we must kick this off
+		 * here for it
+		 */
+		iscsi_start_session_recovery(session, conn, STOP_CONN_RECOVER);
+	}
+
+	debug_scsi("iscsi_eh_host_reset wait for relogin\n");
+	wait_event_interruptible(conn-&gt;ehwait,
+				 session-&gt;state == ISCSI_STATE_TERMINATE ||
+				 session-&gt;state == ISCSI_STATE_LOGGED_IN ||
+				 session-&gt;recovery_failed);
+	if (signal_pending(current))
+		flush_signals(current);
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state == ISCSI_STATE_LOGGED_IN)
+		printk(KERN_INFO "host reset succeeded\n");
+	else
+		goto failed;
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL_GPL(iscsi_eh_host_reset);
+
+static void iscsi_tmabort_timedout(unsigned long data)
+{
+	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)data;
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+
+	spin_lock(&amp;session-&gt;lock);
+	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
+		conn-&gt;tmabort_state = TMABORT_TIMEDOUT;
+		debug_scsi("tmabort timedout [sc %p itt 0x%x]\n",
+			ctask-&gt;sc, ctask-&gt;itt);
+		/* unblock eh_abort() */
+		wake_up(&amp;conn-&gt;ehwait);
+	}
+	spin_unlock(&amp;session-&gt;lock);
+}
+
+/* must be called with the mutex lock */
+static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
+				 struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_tm *hdr = &amp;conn-&gt;tmhdr;
+	int rc;
+
+	/*
+	 * ctask timed out but session is OK requests must be serialized.
+	 */
+	memset(hdr, 0, sizeof(struct iscsi_tm));
+	hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;
+	hdr-&gt;flags = ISCSI_TM_FUNC_ABORT_TASK;
+	hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;rtt = ctask-&gt;hdr-&gt;itt;
+	hdr-&gt;refcmdsn = ctask-&gt;hdr-&gt;cmdsn;
+
+	rc = iscsi_conn_send_generic(conn, (struct iscsi_hdr *)hdr,
+				     NULL, 0);
+	if (rc) {
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		debug_scsi("abort sent failure [itt 0x%x] %d", ctask-&gt;itt, rc);
+		return rc;
+	}
+
+	debug_scsi("abort sent [itt 0x%x]\n", ctask-&gt;itt);
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	ctask-&gt;mtask = (struct iscsi_mgmt_task *)
+			session-&gt;mgmt_cmds[(hdr-&gt;itt &amp; ISCSI_ITT_MASK) -
+					ISCSI_MGMT_ITT_OFFSET];
+
+	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
+		conn-&gt;tmfcmd_pdus_cnt++;
+		conn-&gt;tmabort_timer.expires = 10*HZ + jiffies;
+		conn-&gt;tmabort_timer.function = iscsi_tmabort_timedout;
+		conn-&gt;tmabort_timer.data = (unsigned long)ctask;
+		add_timer(&amp;conn-&gt;tmabort_timer);
+		debug_scsi("abort set timeout [itt 0x%x]", ctask-&gt;itt);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	/*
+	 * block eh thread until:
+	 *
+	 * 1) abort response
+	 * 2) abort timeout
+	 * 3) session is terminated or restarted or userspace has
+	 * given up on recovery
+	 */
+	wait_event_interruptible(conn-&gt;ehwait,
+				 sc-&gt;SCp.phase != session-&gt;age ||
+				 session-&gt;state != ISCSI_STATE_LOGGED_IN ||
+				 conn-&gt;tmabort_state != TMABORT_INITIAL ||
+				 session-&gt;recovery_failed);
+	if (signal_pending(current))
+		flush_signals(current);
+	del_timer_sync(&amp;conn-&gt;tmabort_timer);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	return 0;
+}
+
+/*
+ * xmit mutex and session lock must be held
+ */
+#define iscsi_remove_task(tasktype)					\
+static struct iscsi_##tasktype *					\
+iscsi_remove_##tasktype(struct kfifo *fifo, uint32_t itt)		\
+{									\
+	int i, nr_tasks = __kfifo_len(fifo) / sizeof(void*);		\
+	struct iscsi_##tasktype *task;					\
+									\
+	debug_scsi("searching %d tasks\n", nr_tasks);			\
+									\
+	for (i = 0; i &lt; nr_tasks; i++) {				\
+		__kfifo_get(fifo, (void*)&amp;task, sizeof(void*));		\
+		debug_scsi("check task %u\n", task-&gt;itt);		\
+									\
+		if (task-&gt;itt == itt) {					\
+			debug_scsi("matched task\n");			\
+			break;						\
+		}							\
+									\
+		__kfifo_put(fifo, (void*)&amp;task, sizeof(void*));		\
+	}								\
+	return NULL;							\
+}
+
+iscsi_remove_task(mgmt_task);
+iscsi_remove_task(cmd_task);
+
+static int iscsi_ctask_mtask_cleanup(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+
+	if (!ctask-&gt;mtask)
+		return -EINVAL;
+
+	if (!iscsi_remove_mgmt_task(conn-&gt;immqueue, ctask-&gt;mtask-&gt;itt))
+		list_del(&amp;ctask-&gt;mtask-&gt;running);
+	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;ctask-&gt;mtask,
+		    sizeof(void*));
+	ctask-&gt;mtask = NULL;
+	return 0;
+}
+
+/*
+ * session lock and xmitmutex must be held
+ */
+static void fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+			 int err)
+{
+	struct scsi_cmnd *sc;
+
+	conn-&gt;session-&gt;tt-&gt;cleanup_cmd_task(conn, ctask);
+	iscsi_ctask_mtask_cleanup(ctask);
+
+	sc = ctask-&gt;sc;
+	if (!sc)
+		return;
+	sc-&gt;result = err;
+	sc-&gt;resid = sc-&gt;request_bufflen;
+	iscsi_complete_command(conn-&gt;session, ctask);
+}
+
+int iscsi_eh_abort(struct scsi_cmnd *sc)
+{
+	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_cmd_task *pending_ctask;
+	int rc;
+
+	conn-&gt;eh_abort_cnt++;
+	debug_scsi("aborting [sc %p itt 0x%x]\n", sc, ctask-&gt;itt);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	spin_lock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * If we are not logged in or we have started a new session
+	 * then let the host reset code handle this
+	 */
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN ||
+	    sc-&gt;SCp.phase != session-&gt;age)
+		goto failed;
+
+	/* ctask completed before time out */
+	if (!ctask-&gt;sc)
+		goto success;
+
+	/* what should we do here ? */
+	if (conn-&gt;ctask == ctask) {
+		printk(KERN_INFO "sc %p itt 0x%x partially sent. Failing "
+		       "abort\n", sc, ctask-&gt;itt);
+		goto failed;
+	}
+
+	/* check for the easy pending cmd abort */
+	pending_ctask = iscsi_remove_cmd_task(conn-&gt;xmitqueue, ctask-&gt;itt);
+	if (pending_ctask) {
+		/* iscsi_tcp queues write transfers on the xmitqueue */
+		if (list_empty(&amp;pending_ctask-&gt;running)) {
+			debug_scsi("found pending task\n");
+			goto success;
+		} else
+			__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;pending_ctask,
+				    sizeof(void*));
+	}
+
+	conn-&gt;tmabort_state = TMABORT_INITIAL;
+
+	spin_unlock_bh(&amp;session-&gt;lock);
+	rc = iscsi_exec_abort_task(sc, ctask);
+	spin_lock_bh(&amp;session-&gt;lock);
+
+	iscsi_ctask_mtask_cleanup(ctask);
+	if (rc || sc-&gt;SCp.phase != session-&gt;age ||
+	    session-&gt;state != ISCSI_STATE_LOGGED_IN)
+		goto failed;
+
+	/* ctask completed before tmf abort response */
+	if (!ctask-&gt;sc) {
+		debug_scsi("sc completed while abort in progress\n");
+		goto success;
+	}
+
+	if (conn-&gt;tmabort_state != TMABORT_SUCCESS) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		spin_lock_bh(&amp;session-&gt;lock);
+		goto failed;
+	}
+
+success:
+	debug_scsi("abort success [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * clean up task if aborted. we have the xmitmutex so grab
+	 * the recv lock as a writer
+	 */
+	write_lock_bh(conn-&gt;recv_lock);
+	spin_lock(&amp;session-&gt;lock);
+	fail_command(conn, ctask, DID_ABORT &lt;&lt; 16);
+	spin_unlock(&amp;session-&gt;lock);
+	write_unlock_bh(conn-&gt;recv_lock);
+
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+	return SUCCESS;
+
+failed:
+	spin_unlock_bh(&amp;session-&gt;lock);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	debug_scsi("abort failed [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
+	return FAILED;
+}
+EXPORT_SYMBOL_GPL(iscsi_eh_abort);
+
+int
+iscsi_pool_init(struct iscsi_queue *q, int max, void ***items, int item_size)
+{
+	int i;
+
+	*items = kmalloc(max * sizeof(void*), GFP_KERNEL);
+	if (*items == NULL)
+		return -ENOMEM;
+
+	q-&gt;max = max;
+	q-&gt;pool = kmalloc(max * sizeof(void*), GFP_KERNEL);
+	if (q-&gt;pool == NULL) {
+		kfree(*items);
+		return -ENOMEM;
+	}
+
+	q-&gt;queue = kfifo_init((void*)q-&gt;pool, max * sizeof(void*),
+			      GFP_KERNEL, NULL);
+	if (q-&gt;queue == ERR_PTR(-ENOMEM)) {
+		kfree(q-&gt;pool);
+		kfree(*items);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i &lt; max; i++) {
+		q-&gt;pool[i] = kmalloc(item_size, GFP_KERNEL);
+		if (q-&gt;pool[i] == NULL) {
+			int j;
+
+			for (j = 0; j &lt; i; j++)
+				kfree(q-&gt;pool[j]);
+
+			kfifo_free(q-&gt;queue);
+			kfree(q-&gt;pool);
+			kfree(*items);
+			return -ENOMEM;
+		}
+		memset(q-&gt;pool[i], 0, item_size);
+		(*items)[i] = q-&gt;pool[i];
+		__kfifo_put(q-&gt;queue, (void*)&amp;q-&gt;pool[i], sizeof(void*));
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_pool_init);
+
+void iscsi_pool_free(struct iscsi_queue *q, void **items)
+{
+	int i;
+
+	for (i = 0; i &lt; q-&gt;max; i++)
+		kfree(items[i]);
+	kfree(q-&gt;pool);
+	kfree(items);
+}
+EXPORT_SYMBOL_GPL(iscsi_pool_free);
+
+/*
+ * iSCSI Session's hostdata organization:
+ *
+ *    *------------------* &lt;== hostdata_session(host-&gt;hostdata)
+ *    | ptr to class sess|
+ *    |------------------| &lt;== iscsi_hostdata(host-&gt;hostdata)
+ *    | iscsi_session    |
+ *    *------------------*
+ */
+
+#define hostdata_privsize(_sz)	(sizeof(unsigned long) + _sz + \
+				 _sz % sizeof(unsigned long))
+
+#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
+
+/**
+ * iscsi_session_setup - create iscsi cls session and host and session
+ * @scsit: scsi transport template
+ * @iscsit: iscsi transport template
+ * @initial_cmdsn: initial CmdSN
+ * @hostno: host no allocated
+ *
+ * This can be used by software iscsi_transports that allocate
+ * a session per scsi host.
+ **/
+struct iscsi_cls_session *
+iscsi_session_setup(struct iscsi_transport *iscsit,
+		    struct scsi_transport_template *scsit,
+		    int cmd_task_size, int mgmt_task_size,
+		    uint32_t initial_cmdsn, uint32_t *hostno)
+{
+	struct Scsi_Host *shost;
+	struct iscsi_session *session;
+	struct iscsi_cls_session *cls_session;
+	int cmd_i;
+
+	shost = scsi_host_alloc(iscsit-&gt;host_template,
+				hostdata_privsize(sizeof(*session)));
+	if (!shost)
+		return NULL;
+
+	shost-&gt;max_id = 1;
+	shost-&gt;max_channel = 0;
+	shost-&gt;max_lun = iscsit-&gt;max_lun;
+	shost-&gt;max_cmd_len = iscsit-&gt;max_cmd_len;
+	shost-&gt;transportt = scsit;
+	shost-&gt;transportt-&gt;create_work_queue = 1;
+	*hostno = shost-&gt;host_no;
+
+	session = iscsi_hostdata(shost-&gt;hostdata);
+	memset(session, 0, sizeof(struct iscsi_session));
+	session-&gt;host = shost;
+	session-&gt;state = ISCSI_STATE_FREE;
+	session-&gt;mgmtpool_max = ISCSI_MGMT_CMDS_MAX;
+	session-&gt;cmds_max = ISCSI_XMIT_CMDS_MAX;
+	session-&gt;cmdsn = initial_cmdsn;
+	session-&gt;exp_cmdsn = initial_cmdsn + 1;
+	session-&gt;max_cmdsn = initial_cmdsn + 1;
+	session-&gt;max_r2t = 1;
+	session-&gt;tt = iscsit;
+
+	/* initialize SCSI PDU commands pool */
+	if (iscsi_pool_init(&amp;session-&gt;cmdpool, session-&gt;cmds_max,
+			    (void***)&amp;session-&gt;cmds,
+			    cmd_task_size + sizeof(struct iscsi_cmd_task)))
+		goto cmdpool_alloc_fail;
+
+	/* pre-format cmds pool with ITT */
+	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
+		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+
+		if (cmd_task_size)
+			ctask-&gt;dd_data = &amp;ctask[1];
+		ctask-&gt;itt = cmd_i;
+	}
+
+	spin_lock_init(&amp;session-&gt;lock);
+	INIT_LIST_HEAD(&amp;session-&gt;connections);
+
+	/* initialize immediate command pool */
+	if (iscsi_pool_init(&amp;session-&gt;mgmtpool, session-&gt;mgmtpool_max,
+			   (void***)&amp;session-&gt;mgmt_cmds,
+			   mgmt_task_size + sizeof(struct iscsi_mgmt_task)))
+		goto mgmtpool_alloc_fail;
+
+
+	/* pre-format immediate cmds pool with ITT */
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++) {
+		struct iscsi_mgmt_task *mtask = session-&gt;mgmt_cmds[cmd_i];
+
+		if (mgmt_task_size)
+			mtask-&gt;dd_data = &amp;mtask[1];
+		mtask-&gt;itt = ISCSI_MGMT_ITT_OFFSET + cmd_i;
+		mtask-&gt;data = kmalloc(DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH,
+				     GFP_KERNEL);
+		if (!mtask-&gt;data) {
+			int j;
+
+			for (j = 0; j &lt; cmd_i; j++)
+				kfree(session-&gt;mgmt_cmds[j]-&gt;data);
+			goto immdata_alloc_fail;
+		}
+	}
+
+	if (scsi_add_host(shost, NULL))
+		goto add_host_fail;
+
+	cls_session = iscsi_create_session(shost, iscsit, 0);
+	if (!cls_session)
+		goto cls_session_fail;
+	*(unsigned long*)shost-&gt;hostdata = (unsigned long)cls_session;
+
+	return cls_session;
+
+cls_session_fail:
+	scsi_remove_host(shost);
+add_host_fail:
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
+		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
+immdata_alloc_fail:
+	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
+mgmtpool_alloc_fail:
+	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
+cmdpool_alloc_fail:
+	scsi_host_put(shost);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(iscsi_session_setup);
+
+/**
+ * iscsi_session_teardown - destroy session, host, and cls_session
+ * shost: scsi host
+ *
+ * This can be used by software iscsi_transports that allocate
+ * a session per scsi host.
+ **/
+void iscsi_session_teardown(struct iscsi_cls_session *cls_session)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	int cmd_i;
+
+	scsi_remove_host(shost);
+
+	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
+		kfree(session-&gt;mgmt_cmds[cmd_i]-&gt;data);
+
+	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
+	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
+
+	iscsi_destroy_session(cls_session);
+	scsi_host_put(shost);
+}
+EXPORT_SYMBOL_GPL(iscsi_session_teardown);
+
+/**
+ * iscsi_conn_setup - create iscsi_cls_conn and iscsi_conn
+ * @cls_session: iscsi_cls_session
+ * @conn_idx: cid
+ **/
+struct iscsi_cls_conn *
+iscsi_conn_setup(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_conn *conn;
+	struct iscsi_cls_conn *cls_conn;
+
+	cls_conn = iscsi_create_conn(cls_session, conn_idx);
+	if (!cls_conn)
+		return NULL;
+	conn = cls_conn-&gt;dd_data;
+	memset(conn, 0, sizeof(*conn));
+
+	conn-&gt;session = session;
+	conn-&gt;cls_conn = cls_conn;
+	conn-&gt;c_stage = ISCSI_CONN_INITIAL_STAGE;
+	conn-&gt;id = conn_idx;
+	conn-&gt;exp_statsn = 0;
+	conn-&gt;tmabort_state = TMABORT_INITIAL;
+	INIT_LIST_HEAD(&amp;conn-&gt;run_list);
+	INIT_LIST_HEAD(&amp;conn-&gt;mgmt_run_list);
+
+	/* initialize general xmit PDU commands queue */
+	conn-&gt;xmitqueue = kfifo_alloc(session-&gt;cmds_max * sizeof(void*),
+					GFP_KERNEL, NULL);
+	if (conn-&gt;xmitqueue == ERR_PTR(-ENOMEM))
+		goto xmitqueue_alloc_fail;
+
+	/* initialize general immediate &amp; non-immediate PDU commands queue */
+	conn-&gt;immqueue = kfifo_alloc(session-&gt;mgmtpool_max * sizeof(void*),
+			                GFP_KERNEL, NULL);
+	if (conn-&gt;immqueue == ERR_PTR(-ENOMEM))
+		goto immqueue_alloc_fail;
+
+	conn-&gt;mgmtqueue = kfifo_alloc(session-&gt;mgmtpool_max * sizeof(void*),
+			                GFP_KERNEL, NULL);
+	if (conn-&gt;mgmtqueue == ERR_PTR(-ENOMEM))
+		goto mgmtqueue_alloc_fail;
+
+	INIT_WORK(&amp;conn-&gt;xmitwork, iscsi_xmitworker, conn);
+
+	/* allocate login_mtask used for the login/text sequences */
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (!__kfifo_get(session-&gt;mgmtpool.queue,
+                         (void*)&amp;conn-&gt;login_mtask,
+			 sizeof(void*))) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		goto login_mtask_alloc_fail;
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	init_timer(&amp;conn-&gt;tmabort_timer);
+	mutex_init(&amp;conn-&gt;xmitmutex);
+	init_waitqueue_head(&amp;conn-&gt;ehwait);
+
+	return cls_conn;
+
+login_mtask_alloc_fail:
+	kfifo_free(conn-&gt;mgmtqueue);
+mgmtqueue_alloc_fail:
+	kfifo_free(conn-&gt;immqueue);
+immqueue_alloc_fail:
+	kfifo_free(conn-&gt;xmitqueue);
+xmitqueue_alloc_fail:
+	iscsi_destroy_conn(cls_conn);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_setup);
+
+/**
+ * iscsi_conn_teardown - teardown iscsi connection
+ * cls_conn: iscsi class connection
+ *
+ * TODO: we may need to make this into a two step process
+ * like scsi-mls remove + put host
+ */
+void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+	unsigned long flags;
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	if (conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE) {
+		if (session-&gt;tt-&gt;suspend_conn_recv)
+			session-&gt;tt-&gt;suspend_conn_recv(conn);
+
+		session-&gt;tt-&gt;terminate_conn(conn);
+	}
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	conn-&gt;c_stage = ISCSI_CONN_CLEANUP_WAIT;
+	if (session-&gt;leadconn == conn) {
+		/*
+		 * leading connection? then give up on recovery.
+		 */
+		session-&gt;state = ISCSI_STATE_TERMINATE;
+		wake_up(&amp;conn-&gt;ehwait);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	/*
+	 * Block until all in-progress commands for this connection
+	 * time out or fail.
+	 */
+	for (;;) {
+		spin_lock_irqsave(session-&gt;host-&gt;host_lock, flags);
+		if (!session-&gt;host-&gt;host_busy) { /* OK for ERL == 0 */
+			spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
+			break;
+		}
+		spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
+		msleep_interruptible(500);
+		printk("conn_destroy(): host_busy %d host_failed %d\n",
+			session-&gt;host-&gt;host_busy, session-&gt;host-&gt;host_failed);
+		/*
+		 * force eh_abort() to unblock
+		 */
+		wake_up(&amp;conn-&gt;ehwait);
+	}
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
+		    sizeof(void*));
+	list_del(&amp;conn-&gt;item);
+	if (list_empty(&amp;session-&gt;connections))
+		session-&gt;leadconn = NULL;
+	if (session-&gt;leadconn &amp;&amp; session-&gt;leadconn == conn)
+		session-&gt;leadconn = container_of(session-&gt;connections.next,
+			struct iscsi_conn, item);
+
+	if (session-&gt;leadconn == NULL)
+		/* no connections exits.. reset sequencing */
+		session-&gt;cmdsn = session-&gt;max_cmdsn = session-&gt;exp_cmdsn = 1;
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	kfifo_free(conn-&gt;xmitqueue);
+	kfifo_free(conn-&gt;immqueue);
+	kfifo_free(conn-&gt;mgmtqueue);
+
+	iscsi_destroy_conn(cls_conn);
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_teardown);
+
+int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+
+	if (session == NULL) {
+		printk(KERN_ERR "iscsi: can't start unbound connection\n");
+		return -EPERM;
+	}
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	conn-&gt;c_stage = ISCSI_CONN_STARTED;
+	session-&gt;state = ISCSI_STATE_LOGGED_IN;
+
+	switch(conn-&gt;stop_stage) {
+	case STOP_CONN_RECOVER:
+		/*
+		 * unblock eh_abort() if it is blocked. re-try all
+		 * commands after successful recovery
+		 */
+		session-&gt;conn_cnt++;
+		conn-&gt;stop_stage = 0;
+		conn-&gt;tmabort_state = TMABORT_INITIAL;
+		session-&gt;age++;
+		session-&gt;recovery_failed = 0;
+		spin_unlock_bh(&amp;session-&gt;lock);
+
+		iscsi_unblock_session(session_to_cls(session));
+		wake_up(&amp;conn-&gt;ehwait);
+		return 0;
+	case STOP_CONN_TERM:
+		session-&gt;conn_cnt++;
+		conn-&gt;stop_stage = 0;
+		break;
+	case STOP_CONN_SUSPEND:
+		conn-&gt;stop_stage = 0;
+		clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+		clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_start);
+
+static void
+flush_control_queues(struct iscsi_session *session, struct iscsi_conn *conn)
+{
+	struct iscsi_mgmt_task *mtask, *tmp;
+
+	/* handle pending */
+	while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*)) ||
+	       __kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*))) {
+		if (mtask == conn-&gt;login_mtask)
+			continue;
+		debug_scsi("flushing pending mgmt task itt 0x%x\n", mtask-&gt;itt);
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;mtask,
+			    sizeof(void*));
+	}
+
+	/* handle running */
+	list_for_each_entry_safe(mtask, tmp, &amp;conn-&gt;mgmt_run_list, running) {
+		debug_scsi("flushing running mgmt task itt 0x%x\n", mtask-&gt;itt);
+		if (mtask == conn-&gt;login_mtask)
+			continue;
+		list_del(&amp;mtask-&gt;running);
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;mtask,
+			   sizeof(void*));
+	}
+
+	conn-&gt;mtask = NULL;
+}
+
+/* Fail commands. Mutex and session lock held and recv side suspended */
+static void fail_all_commands(struct iscsi_conn *conn)
+{
+	struct iscsi_cmd_task *ctask, *tmp;
+
+	/* flush pending */
+	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*))) {
+		debug_scsi("failing pending sc %p itt 0x%x\n", ctask-&gt;sc,
+			   ctask-&gt;itt);
+		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
+	}
+
+	/* fail all other running */
+	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;run_list, running) {
+		debug_scsi("failing in progress sc %p itt 0x%x\n",
+			   ctask-&gt;sc, ctask-&gt;itt);
+		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
+	}
+
+	conn-&gt;ctask = NULL;
+}
+
+void iscsi_start_session_recovery(struct iscsi_session *session,
+				  struct iscsi_conn *conn, int flag)
+{
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (conn-&gt;stop_stage == STOP_CONN_RECOVER ||
+	    conn-&gt;stop_stage == STOP_CONN_TERM) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		return;
+	}
+	conn-&gt;stop_stage = flag;
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	if (session-&gt;tt-&gt;suspend_conn_recv)
+		session-&gt;tt-&gt;suspend_conn_recv(conn);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	spin_lock_bh(&amp;session-&gt;lock);
+	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+
+	session-&gt;conn_cnt--;
+	if (session-&gt;conn_cnt == 0 || session-&gt;leadconn == conn)
+		session-&gt;state = ISCSI_STATE_FAILED;
+
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	session-&gt;tt-&gt;terminate_conn(conn);
+	/*
+	 * flush queues.
+	 */
+	spin_lock_bh(&amp;session-&gt;lock);
+	fail_all_commands(conn);
+	flush_control_queues(session, conn);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * for connection level recovery we should not calculate
+	 * header digest. conn-&gt;hdr_size used for optimization
+	 * in hdr_extract() and will be re-negotiated at
+	 * set_param() time.
+	 */
+	if (flag == STOP_CONN_RECOVER) {
+		conn-&gt;hdrdgst_en = 0;
+		conn-&gt;datadgst_en = 0;
+
+		if (session-&gt;state == ISCSI_STATE_FAILED)
+			iscsi_block_session(session_to_cls(session));
+	}
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+}
+EXPORT_SYMBOL_GPL(iscsi_start_session_recovery);
+
+void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+
+	switch (flag) {
+	case STOP_CONN_RECOVER:
+	case STOP_CONN_TERM:
+		iscsi_start_session_recovery(session, conn, flag);
+		return;
+	case STOP_CONN_SUSPEND:
+		if (session-&gt;tt-&gt;suspend_conn_recv)
+			session-&gt;tt-&gt;suspend_conn_recv(conn);
+
+		mutex_lock(&amp;conn-&gt;xmitmutex);
+		spin_lock_bh(&amp;session-&gt;lock);
+
+		conn-&gt;stop_stage = flag;
+		conn-&gt;c_stage = ISCSI_CONN_STOPPED;
+		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+
+		spin_unlock_bh(&amp;session-&gt;lock);
+		mutex_unlock(&amp;conn-&gt;xmitmutex);
+		break;
+	default:
+		printk(KERN_ERR "invalid stop flag %d\n", flag);
+	}
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_stop);
+
+int iscsi_conn_bind(struct iscsi_cls_session *cls_session,
+		    struct iscsi_cls_conn *cls_conn, int is_leading)
+{
+	struct iscsi_session *session = class_to_transport_session(cls_session);
+	struct iscsi_conn *tmp = ERR_PTR(-EEXIST), *conn = cls_conn-&gt;dd_data;
+
+	/* lookup for existing connection */
+	spin_lock_bh(&amp;session-&gt;lock);
+	list_for_each_entry(tmp, &amp;session-&gt;connections, item) {
+		if (tmp == conn) {
+			if (conn-&gt;c_stage != ISCSI_CONN_STOPPED ||
+			    conn-&gt;stop_stage == STOP_CONN_TERM) {
+				printk(KERN_ERR "iscsi_tcp: can't bind "
+				       "non-stopped connection (%d:%d)\n",
+				       conn-&gt;c_stage, conn-&gt;stop_stage);
+				spin_unlock_bh(&amp;session-&gt;lock);
+				return -EIO;
+			}
+			break;
+		}
+	}
+	if (tmp != conn) {
+		/* bind new iSCSI connection to session */
+		conn-&gt;session = session;
+		list_add(&amp;conn-&gt;item, &amp;session-&gt;connections);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	if (is_leading)
+		session-&gt;leadconn = conn;
+
+	/*
+	 * Unblock xmitworker(), Login Phase will pass through.
+	 */
+	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_bind);
+
+MODULE_AUTHOR("Mike Christie");
+MODULE_DESCRIPTION("iSCSI library functions");
+MODULE_LICENSE("GPL");
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index e2b67e34d92e..bc9071d2d212 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -471,106 +471,6 @@ int iscsi_destroy_conn(struct iscsi_cls_conn *conn)
 
 EXPORT_SYMBOL_GPL(iscsi_destroy_conn);
 
-/*
- * These functions are used only by software iscsi_transports
- * which do not allocate and more their scsi_hosts since this
- * is initiated from userspace.
- */
-
-/*
- * iSCSI Session's hostdata organization:
- *
- *    *------------------* &lt;== hostdata_session(host-&gt;hostdata)
- *    | ptr to class sess|
- *    |------------------| &lt;== iscsi_hostdata(host-&gt;hostdata)
- *    | transport's data |
- *    *------------------*
- */
-
-#define hostdata_privsize(_t)	(sizeof(unsigned long) + _t-&gt;hostdata_size + \
-				 _t-&gt;hostdata_size % sizeof(unsigned long))
-
-#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
-
-/**
- * iscsi_transport_create_session - create iscsi cls session and host
- * scsit: scsi transport template
- * transport: iscsi transport template
- *
- * This can be used by software iscsi_transports that allocate
- * a session per scsi host.
- **/
-struct Scsi_Host *
-iscsi_transport_create_session(struct scsi_transport_template *scsit,
-			       struct iscsi_transport *transport)
-{
-	struct iscsi_cls_session *session;
-	struct Scsi_Host *shost;
-	unsigned long flags;
-
-	shost = scsi_host_alloc(transport-&gt;host_template,
-				hostdata_privsize(transport));
-	if (!shost) {
-		printk(KERN_ERR "iscsi: can not allocate SCSI host for "
-			"session\n");
-		return NULL;
-	}
-
-	shost-&gt;max_id = 1;
-	shost-&gt;max_channel = 0;
-	shost-&gt;max_lun = transport-&gt;max_lun;
-	shost-&gt;max_cmd_len = transport-&gt;max_cmd_len;
-	shost-&gt;transportt = scsit;
-	shost-&gt;transportt-&gt;create_work_queue = 1;
-
-	if (scsi_add_host(shost, NULL))
-		goto free_host;
-
-	session = iscsi_create_session(shost, transport, 0);
-	if (!session)
-		goto remove_host;
-
-	*(unsigned long*)shost-&gt;hostdata = (unsigned long)session;
-	spin_lock_irqsave(&amp;sesslock, flags);
-	list_add(&amp;session-&gt;sess_list, &amp;sesslist);
-	spin_unlock_irqrestore(&amp;sesslock, flags);
-	return shost;
-
-remove_host:
-	scsi_remove_host(shost);
-free_host:
-	scsi_host_put(shost);
-	return NULL;
-}
-
-EXPORT_SYMBOL_GPL(iscsi_transport_create_session);
-
-/**
- * iscsi_transport_destroy_session - destroy session and scsi host
- * shost: scsi host
- *
- * This can be used by software iscsi_transports that allocate
- * a session per scsi host.
- **/
-int iscsi_transport_destroy_session(struct Scsi_Host *shost)
-{
-	struct iscsi_cls_session *session;
-	unsigned long flags;
-
-	session = hostdata_session(shost-&gt;hostdata);
-	spin_lock_irqsave(&amp;sesslock, flags);
-	list_del(&amp;session-&gt;sess_list);
-	spin_unlock_irqrestore(&amp;sesslock, flags);
-	iscsi_destroy_session(session);
-
-	scsi_remove_host(shost);
-	/* ref from host alloc */
-	scsi_host_put(shost);
-	return 0;
-}
-
-EXPORT_SYMBOL_GPL(iscsi_transport_destroy_session);
-
 /*
  * iscsi interface functions
  */
@@ -857,14 +757,19 @@ iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_uevent *ev)
 {
 	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
 	struct iscsi_cls_session *session;
+	unsigned long flags;
 	uint32_t hostno;
 
-	session = transport-&gt;create_session(&amp;priv-&gt;t,
+	session = transport-&gt;create_session(transport, &amp;priv-&gt;t,
 					    ev-&gt;u.c_session.initial_cmdsn,
 					    &amp;hostno);
 	if (!session)
 		return -ENOMEM;
 
+	spin_lock_irqsave(&amp;sesslock, flags);
+	list_add(&amp;session-&gt;sess_list, &amp;sesslist);
+	spin_unlock_irqrestore(&amp;sesslock, flags);
+
 	ev-&gt;r.c_session_ret.host_no = hostno;
 	ev-&gt;r.c_session_ret.sid = session-&gt;sid;
 	return 0;
@@ -1032,6 +937,7 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	struct iscsi_internal *priv;
 	struct iscsi_cls_session *session;
 	struct iscsi_cls_conn *conn;
+	unsigned long flags;
 
 	priv = iscsi_if_transport_lookup(iscsi_ptr(ev-&gt;transport_handle));
 	if (!priv)
@@ -1047,9 +953,13 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		break;
 	case ISCSI_UEVENT_DESTROY_SESSION:
 		session = iscsi_session_lookup(ev-&gt;u.d_session.sid);
-		if (session)
+		if (session) {
+			spin_lock_irqsave(&amp;sesslock, flags);
+			list_del(&amp;session-&gt;sess_list);
+			spin_unlock_irqrestore(&amp;sesslock, flags);
+
 			transport-&gt;destroy_session(session);
-		else
+		} else
 			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_CREATE_CONN:
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index eebe2b15161b..47524c726ee8 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -148,7 +148,8 @@ enum iscsi_err {
 	ISCSI_ERR_SESSION_FAILED	= ISCSI_ERR_BASE + 13,
 	ISCSI_ERR_HDR_DGST		= ISCSI_ERR_BASE + 14,
 	ISCSI_ERR_DATA_DGST		= ISCSI_ERR_BASE + 15,
-	ISCSI_ERR_PARAM_NOT_FOUND	= ISCSI_ERR_BASE + 16
+	ISCSI_ERR_PARAM_NOT_FOUND	= ISCSI_ERR_BASE + 16,
+	ISCSI_ERR_NO_SCSI_CMD		= ISCSI_ERR_BASE + 17,
 };
 
 /*
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
new file mode 100644
index 000000000000..830700a4ed69
--- /dev/null
+++ b/include/scsi/libiscsi.h
@@ -0,0 +1,286 @@
+/*
+ * iSCSI lib definitions
+ *
+ * Copyright (C) 2006 Red Hat, Inc.  All rights reserved.
+ * Copyright (C) 2004 - 2006 Mike Christie
+ * Copyright (C) 2004 - 2005 Dmitry Yusupov
+ * Copyright (C) 2004 - 2005 Alex Aizman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef LIBISCSI_H
+#define LIBISCSI_H
+
+#include &lt;linux/types.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include &lt;scsi/iscsi_proto.h&gt;
+#include &lt;scsi/iscsi_if.h&gt;
+
+struct scsi_transport_template;
+struct scsi_device;
+struct Scsi_Host;
+struct scsi_cmnd;
+struct socket;
+struct iscsi_transport;
+struct iscsi_cls_session;
+struct iscsi_cls_conn;
+struct iscsi_session;
+struct iscsi_nopin;
+
+/* #define DEBUG_SCSI */
+#ifdef DEBUG_SCSI
+#define debug_scsi(fmt...) printk(KERN_INFO "scsi: " fmt)
+#else
+#define debug_scsi(fmt...)
+#endif
+
+#define ISCSI_XMIT_CMDS_MAX	128	/* must be power of 2 */
+#define ISCSI_MGMT_CMDS_MAX	32	/* must be power of 2 */
+#define ISCSI_CONN_MAX			1
+
+#define ISCSI_MGMT_ITT_OFFSET	0xa00
+
+#define ISCSI_DEF_CMD_PER_LUN		32
+#define ISCSI_MAX_CMD_PER_LUN		128
+
+/* Task Mgmt states */
+#define TMABORT_INITIAL			0x0
+#define TMABORT_SUCCESS			0x1
+#define TMABORT_FAILED			0x2
+#define TMABORT_TIMEDOUT		0x3
+
+/* Connection suspend "bit" */
+#define ISCSI_SUSPEND_BIT		1
+
+#define ISCSI_ITT_MASK			(0xfff)
+#define ISCSI_CID_SHIFT			12
+#define ISCSI_CID_MASK			(0xffff &lt;&lt; ISCSI_CID_SHIFT)
+#define ISCSI_AGE_SHIFT			28
+#define ISCSI_AGE_MASK			(0xf &lt;&lt; ISCSI_AGE_SHIFT)
+
+struct iscsi_mgmt_task {
+	/*
+	 * Becuae LLDs allocate their hdr differently, this is a pointer to
+	 * that storage. It must be setup at session creation time.
+	 */
+	struct iscsi_hdr	*hdr;
+	char			*data;		/* mgmt payload */
+	int			data_count;	/* counts data to be sent */
+	uint32_t		itt;		/* this ITT */
+	void			*dd_data;	/* driver/transport data */
+	struct list_head	running;
+};
+
+struct iscsi_cmd_task {
+	/*
+	 * Becuae LLDs allocate their hdr differently, this is a pointer to
+	 * that storage. It must be setup at session creation time.
+	 */
+	struct iscsi_cmd	*hdr;
+	int			itt;		/* this ITT */
+	int			datasn;		/* DataSN */
+
+	uint32_t		unsol_datasn;
+	int			imm_count;	/* imm-data (bytes)   */
+	int			unsol_count;	/* unsolicited (bytes)*/
+	int			data_count;	/* remaining Data-Out */
+	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
+	int			total_length;
+	struct iscsi_conn	*conn;		/* used connection    */
+	struct iscsi_mgmt_task	*mtask;		/* tmf mtask in progr */
+
+	struct list_head	running;	/* running cmd list */
+	void			*dd_data;	/* driver/transport data */
+};
+
+struct iscsi_conn {
+	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
+	void			*dd_data;	/* iscsi_transport data */
+	struct iscsi_session	*session;	/* parent session */
+	/*
+	 * LLDs should set this lock. It protects the transport recv
+	 * code
+	 */
+	rwlock_t		*recv_lock;
+	/*
+	 * conn_stop() flag: stop to recover, stop to terminate
+	 */
+        int			stop_stage;
+
+	/* iSCSI connection-wide sequencing */
+	uint32_t		exp_statsn;
+
+	/* control data */
+	int			id;		/* CID */
+	struct list_head	item;		/* maintains list of conns */
+	int			c_stage;	/* connection state */
+	struct iscsi_mgmt_task	*login_mtask;	/* mtask used for login/text */
+	struct iscsi_mgmt_task	*mtask;		/* xmit mtask in progress */
+	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
+
+	/* xmit */
+	struct kfifo		*immqueue;	/* immediate xmit queue */
+	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
+	struct list_head	mgmt_run_list;	/* list of control tasks */
+	struct kfifo		*xmitqueue;	/* data-path cmd queue */
+	struct list_head	run_list;	/* list of cmds in progress */
+	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
+	/*
+	 * serializes connection xmit, access to kfifos:
+	 * xmitqueue, immqueue, mgmtqueue
+	 */
+	struct mutex		xmitmutex;
+
+	unsigned long		suspend_tx;	/* suspend Tx */
+	unsigned long		suspend_rx;	/* suspend Rx */
+
+	/* abort */
+	wait_queue_head_t	ehwait;		/* used in eh_abort() */
+	struct iscsi_tm		tmhdr;
+	struct timer_list	tmabort_timer;
+	int			tmabort_state;	/* see TMABORT_INITIAL, etc.*/
+
+	/* negotiated params */
+	int			max_recv_dlength; /* initiator_max_recv_dsl*/
+	int			max_xmit_dlength; /* target_max_recv_dsl */
+	int			hdrdgst_en;
+	int			datadgst_en;
+
+	/* MIB-statistics */
+	uint64_t		txdata_octets;
+	uint64_t		rxdata_octets;
+	uint32_t		scsicmd_pdus_cnt;
+	uint32_t		dataout_pdus_cnt;
+	uint32_t		scsirsp_pdus_cnt;
+	uint32_t		datain_pdus_cnt;
+	uint32_t		r2t_pdus_cnt;
+	uint32_t		tmfcmd_pdus_cnt;
+	int32_t			tmfrsp_pdus_cnt;
+
+	/* custom statistics */
+	uint32_t		eh_abort_cnt;
+};
+
+struct iscsi_queue {
+	struct kfifo		*queue;		/* FIFO Queue */
+	void			**pool;		/* Pool of elements */
+	int			max;		/* Max number of elements */
+};
+
+struct iscsi_session {
+	/* iSCSI session-wide sequencing */
+	uint32_t		cmdsn;
+	uint32_t		exp_cmdsn;
+	uint32_t		max_cmdsn;
+
+	/* configuration */
+	int			initial_r2t_en;
+	int			max_r2t;
+	int			imm_data_en;
+	int			first_burst;
+	int			max_burst;
+	int			time2wait;
+	int			time2retain;
+	int			pdu_inorder_en;
+	int			dataseq_inorder_en;
+	int			erl;
+	int			ifmarker_en;
+	int			ofmarker_en;
+
+	/* control data */
+	struct iscsi_transport	*tt;
+	struct Scsi_Host	*host;
+	struct iscsi_conn	*leadconn;	/* leading connection */
+	spinlock_t		lock;		/* protects session state, *
+						 * sequence numbers,       *
+						 * session resources:      *
+						 * - cmdpool,		   *
+						 * - mgmtpool,		   *
+						 * - r2tpool		   */
+	int			state;		/* session state           */
+	int			recovery_failed;
+	struct list_head	item;
+	int			conn_cnt;
+	int			age;		/* counts session re-opens */
+
+	struct list_head	connections;	/* list of connections */
+	int			cmds_max;	/* size of cmds array */
+	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
+	struct iscsi_queue	cmdpool;	/* PDU's pool */
+	int			mgmtpool_max;	/* size of mgmt array */
+	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
+	struct iscsi_queue	mgmtpool;	/* Mgmt PDU's pool */
+};
+
+/*
+ * scsi host template
+ */
+extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
+extern int iscsi_eh_abort(struct scsi_cmnd *sc);
+extern int iscsi_eh_host_reset(struct scsi_cmnd *sc);
+extern int iscsi_queuecommand(struct scsi_cmnd *sc,
+			      void (*done)(struct scsi_cmnd *));
+
+/*
+ * session management
+ */
+extern struct iscsi_cls_session *
+iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
+		    int, int, uint32_t, uint32_t *);
+extern void iscsi_session_teardown(struct iscsi_cls_session *);
+extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
+extern void iscsi_start_session_recovery(struct iscsi_session *,
+					struct iscsi_conn *, int);
+extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
+
+#define session_to_cls(_sess) \
+	hostdata_session(_sess-&gt;host-&gt;hostdata)
+
+/*
+ * connection management
+ */
+extern struct iscsi_cls_conn *iscsi_conn_setup(struct iscsi_cls_session *,
+					       uint32_t);
+extern void iscsi_conn_teardown(struct iscsi_cls_conn *);
+extern int iscsi_conn_start(struct iscsi_cls_conn *);
+extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
+extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
+			   int);
+extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
+
+/*
+ * pdu and task processing
+ */
+extern int iscsi_check_assign_cmdsn(struct iscsi_session *,
+				    struct iscsi_nopin *);
+extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *,
+					struct iscsi_data *hdr,
+					int transport_data_cnt);
+extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
+				char *, uint32_t);
+extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+			      char *, int);
+extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+				char *, int);
+extern int iscsi_verify_itt(struct iscsi_conn *, struct iscsi_hdr *,
+			    uint32_t *);
+
+/*
+ * generic helpers
+ */
+extern void iscsi_pool_free(struct iscsi_queue *, void **);
+extern int iscsi_pool_init(struct iscsi_queue *, int, void ***, int);
+
+#endif
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 9d2b99159ee7..b332d6e839fe 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -2,7 +2,7 @@
  * iSCSI transport class definitions
  *
  * Copyright (C) IBM Corporation, 2004
- * Copyright (C) Mike Christie, 2004 - 2005
+ * Copyright (C) Mike Christie, 2004 - 2006
  * Copyright (C) Dmitry Yusupov, 2004 - 2005
  * Copyright (C) Alex Aizman, 2004 - 2005
  *
@@ -27,9 +27,13 @@
 #include &lt;scsi/iscsi_if.h&gt;
 
 struct scsi_transport_template;
+struct iscsi_transport;
 struct Scsi_Host;
 struct mempool_zone;
 struct iscsi_cls_conn;
+struct iscsi_conn;
+struct iscsi_cmd_task;
+struct iscsi_mgmt_task;
 
 /**
  * struct iscsi_transport - iSCSI Transport template
@@ -46,6 +50,20 @@ struct iscsi_cls_conn;
  * @start_conn:		set connection to be operational
  * @stop_conn:		suspend/recover/terminate connection
  * @send_pdu:		send iSCSI PDU, Login, Logout, NOP-Out, Reject, Text.
+ * @session_recovery_timedout: notify LLD a block during recovery timed out
+ * @suspend_conn_recv:	susepend the recv side of the connection
+ * @termincate_conn:	destroy socket connection. Called with mutex lock.
+ * @init_cmd_task:	Initialize a iscsi_cmd_task and any internal structs.
+ *			Called from queuecommand with session lock held.
+ * @init_mgmt_task:	Initialize a iscsi_mgmt_task and any internal structs.
+ *			Called from iscsi_conn_send_generic with xmitmutex.
+ * @xmit_cmd_task:	requests LLD to transfer cmd task
+ * @xmit_mgmt_task:	requests LLD to transfer mgmt task
+ * @cleanup_cmd_task:	requests LLD to fail cmd task. Called with xmitmutex
+ *			and session-&gt;lock after the connection has been
+ *			suspended and terminated during recovery. If called
+ *			from abort task then connection is not suspended
+ *			or terminated but sk_callback_lock is held
  *
  * Template API provided by iSCSI Transport
  */
@@ -56,8 +74,6 @@ struct iscsi_transport {
 	/* LLD sets this to indicate what values it can export to sysfs */
 	unsigned int param_mask;
 	struct scsi_host_template *host_template;
-	/* LLD session/scsi_host data size */
-	int hostdata_size;
 	/* LLD connection data size */
 	int conndata_size;
 	/* LLD session data size */
@@ -65,8 +81,8 @@ struct iscsi_transport {
 	int max_lun;
 	unsigned int max_conn;
 	unsigned int max_cmd_len;
-	struct iscsi_cls_session *(*create_session)
-		(struct scsi_transport_template *t, uint32_t sn, uint32_t *hn);
+	struct iscsi_cls_session *(*create_session) (struct iscsi_transport *it,
+		struct scsi_transport_template *t, uint32_t sn, uint32_t *hn);
 	void (*destroy_session) (struct iscsi_cls_session *session);
 	struct iscsi_cls_conn *(*create_conn) (struct iscsi_cls_session *sess,
 				uint32_t cid);
@@ -90,6 +106,18 @@ struct iscsi_transport {
 			 char *data, uint32_t data_size);
 	void (*get_stats) (struct iscsi_cls_conn *conn,
 			   struct iscsi_stats *stats);
+	void (*suspend_conn_recv) (struct iscsi_conn *conn);
+	void (*terminate_conn) (struct iscsi_conn *conn);
+	void (*init_cmd_task) (struct iscsi_cmd_task *ctask);
+	void (*init_mgmt_task) (struct iscsi_conn *conn,
+				struct iscsi_mgmt_task *mtask,
+				char *data, uint32_t data_size);
+	int (*xmit_cmd_task) (struct iscsi_conn *conn,
+			      struct iscsi_cmd_task *ctask);
+	void (*cleanup_cmd_task) (struct iscsi_conn *conn,
+				  struct iscsi_cmd_task *ctask);
+	int (*xmit_mgmt_task) (struct iscsi_conn *conn,
+			       struct iscsi_mgmt_task *mtask);
 	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
 };
 
@@ -106,6 +134,13 @@ extern void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error);
 extern int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 			  char *data, uint32_t data_size);
 
+
+/* Connection's states */
+#define ISCSI_CONN_INITIAL_STAGE	0
+#define ISCSI_CONN_STARTED		1
+#define ISCSI_CONN_STOPPED		2
+#define ISCSI_CONN_CLEANUP_WAIT		3
+
 struct iscsi_cls_conn {
 	struct list_head conn_list;	/* item in connlist */
 	void *dd_data;			/* LLD private data */
@@ -129,6 +164,12 @@ struct iscsi_cls_conn {
 #define iscsi_dev_to_conn(_dev) \
 	container_of(_dev, struct iscsi_cls_conn, dev)
 
+/* Session's states */
+#define ISCSI_STATE_FREE		1
+#define ISCSI_STATE_LOGGED_IN		2
+#define ISCSI_STATE_FAILED		3
+#define ISCSI_STATE_TERMINATE		4
+
 struct iscsi_cls_session {
 	struct list_head sess_list;		/* item in session_list */
 	struct list_head host_list;
@@ -174,12 +215,4 @@ extern int iscsi_destroy_conn(struct iscsi_cls_conn *conn);
 extern void iscsi_unblock_session(struct iscsi_cls_session *session);
 extern void iscsi_block_session(struct iscsi_cls_session *session);
 
-/*
- * session functions used by software iscsi
- */
-extern struct Scsi_Host *
-iscsi_transport_create_session(struct scsi_transport_template *scsit,
-                               struct iscsi_transport *transport);
-extern int iscsi_transport_destroy_session(struct Scsi_Host *shost);
-
 #endif</pre><hr><pre>commit 30a6c65236f9d26e3325cae468f330b833a3878c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Apr 6 21:13:39 2006 -0500

    [SCSI] iscsi: fix up iscsi eh
    
    The current iscsi_tcp eh is not nicely setup for dm-multipath
    and performs some extra task management functions when they
    are not needed.
    
    The attached patch:
    
    - Fixes the TMF issues. If a session is rebuilt
    then we do not send aborts.
    
    - Fixes the problem where if the host reset fired, we would
    return SUCCESS even though we had not really done anything
    yet. This ends up causing problem with scsi_error.c's TUR.
    
    - If someone has turned on the userspace nop daemon code to try
    and detect network problems before the scsi command timeout
    we can now drop and clean up the session before the scsi command
    timesout and fires the eh speeding up the time it takes for a
    command to go from one patch to another. For network problems
    we fail the command with DID_BUS_BUSY so if failfast is set
    scsi_decide_disposition fails the command up to dm for it to
    try on another path.
    
    - And we had to add some basic iscsi session block code. Previously
    if we were trying to repair a session we would retrun a MLQUEUE code
    in the queuecommand. This worked but it was not the most efficient
    or pretty thing to do since it would take a while to relogin
    to the target. For iscsi_tcp/open-iscsi a lot of the iscsi error handler
    is in userspace the block code is pretty bare. We will be
    adding to that for qla4xxx.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 6e510f3cfbf6..aca3e23b1b9e 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -82,6 +82,9 @@ module_param_named(max_lun, iscsi_max_lun, uint, S_IRUGO);
 /* global data */
 static kmem_cache_t *taskcache;
 
+#define session_to_cls(_sess) \
+	hostdata_session(_sess-&gt;host-&gt;hostdata)
+
 static inline void
 iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
@@ -230,17 +233,19 @@ iscsi_hdr_extract(struct iscsi_conn *conn)
 	return 0;
 }
 
-static inline void
-iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+/*
+ * must be called with session lock
+ */
+static void
+__iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
-	struct scsi_cmnd *sc = ctask-&gt;sc;
 	struct iscsi_session *session = conn-&gt;session;
+	struct scsi_cmnd *sc;
 
-	spin_lock(&amp;session-&gt;lock);
-	if (unlikely(!sc)) {
-		spin_unlock(&amp;session-&gt;lock);
+	sc = ctask-&gt;sc;
+	if (unlikely(!sc))
 		return;
-	}
+
 	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
 		struct iscsi_data_task *dtask, *n;
 		/* WRITE: cleanup Data-Out's if any */
@@ -252,7 +257,20 @@ iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	ctask-&gt;xmstate = XMSTATE_IDLE;
 	ctask-&gt;r2t = NULL;
 	ctask-&gt;sc = NULL;
+	list_del(&amp;ctask-&gt;running);
+
 	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
+
+	sc-&gt;scsi_done(sc);
+}
+
+static void
+iscsi_ctask_cleanup(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_session *session = conn-&gt;session;
+
+	spin_lock(&amp;session-&gt;lock);
+	__iscsi_ctask_cleanup(conn, ctask);
 	spin_unlock(&amp;session-&gt;lock);
 }
 
@@ -311,7 +329,6 @@ iscsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		   (long)sc, sc-&gt;result, ctask-&gt;itt);
 	conn-&gt;scsirsp_pdus_cnt++;
 	iscsi_ctask_cleanup(conn, ctask);
-	sc-&gt;scsi_done(sc);
 	return rc;
 }
 
@@ -395,6 +412,7 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 
 	dtask = mempool_alloc(ctask-&gt;datapool, GFP_ATOMIC);
 	BUG_ON(!dtask);
+	INIT_LIST_HEAD(&amp;dtask-&gt;item);
 	hdr = &amp;dtask-&gt;hdr;
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr-&gt;ttt = r2t-&gt;ttt;
@@ -710,8 +728,6 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 			conn-&gt;tmfrsp_pdus_cnt++;
 			spin_lock(&amp;session-&gt;lock);
 			if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
-				__kfifo_put(session-&gt;mgmtpool.queue,
-						(void*)&amp;mtask, sizeof(void*));
 				conn-&gt;tmabort_state =
 					((struct iscsi_tm_rsp *)hdr)-&gt;
 					response == ISCSI_TMF_RSP_COMPLETE ?
@@ -986,7 +1002,6 @@ static int iscsi_scsi_data_in(struct iscsi_conn *conn)
 			   (long)sc, sc-&gt;result, ctask-&gt;itt);
 		conn-&gt;scsirsp_pdus_cnt++;
 		iscsi_ctask_cleanup(conn, ctask);
-		sc-&gt;scsi_done(sc);
 	}
 
 	return rc;
@@ -1460,6 +1475,7 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 
 	dtask = mempool_alloc(ctask-&gt;datapool, GFP_ATOMIC);
 	BUG_ON(!dtask);
+	INIT_LIST_HEAD(&amp;dtask-&gt;item);
 	hdr = &amp;dtask-&gt;hdr;
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr-&gt;ttt = r2t-&gt;ttt;
@@ -1506,6 +1522,7 @@ iscsi_unsolicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	dtask = mempool_alloc(ctask-&gt;datapool, GFP_ATOMIC);
 	BUG_ON(!dtask);
+	INIT_LIST_HEAD(&amp;dtask-&gt;item);
 	hdr = &amp;dtask-&gt;hdr;
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
@@ -1550,6 +1567,7 @@ iscsi_cmd_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 
 	BUG_ON(__kfifo_len(ctask-&gt;r2tqueue));
 
+	INIT_LIST_HEAD(&amp;ctask-&gt;running);
 	ctask-&gt;sc = sc;
 	ctask-&gt;conn = conn;
 	ctask-&gt;hdr.opcode = ISCSI_OP_SCSI_CMD;
@@ -1680,7 +1698,7 @@ iscsi_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
 		if (mtask-&gt;data_count)
 			mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
 		if (conn-&gt;c_stage != ISCSI_CONN_INITIAL_STAGE &amp;&amp;
-	    	    conn-&gt;stop_stage != STOP_CONN_RECOVER &amp;&amp;
+		    conn-&gt;stop_stage != STOP_CONN_RECOVER &amp;&amp;
 		    conn-&gt;hdrdgst_en)
 			iscsi_hdr_digest(conn, &amp;mtask-&gt;headbuf,
 					(u8*)mtask-&gt;hdrext);
@@ -2226,6 +2244,7 @@ iscsi_data_xmit(struct iscsi_conn *conn)
 	/* process command queue */
 	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;conn-&gt;ctask,
 			   sizeof(void*))) {
+		list_add_tail(&amp;conn-&gt;ctask-&gt;running, &amp;conn-&gt;run_list);
 		if (iscsi_ctask_xmit(conn, conn-&gt;ctask))
 			goto again;
 	}
@@ -2277,11 +2296,14 @@ iscsi_xmitworker(void *data)
 	mutex_unlock(&amp;conn-&gt;xmitmutex);
 }
 
-#define FAILURE_BAD_HOST		1
-#define FAILURE_SESSION_FAILED		2
-#define FAILURE_SESSION_FREED		3
-#define FAILURE_WINDOW_CLOSED		4
-#define FAILURE_SESSION_TERMINATE	5
+enum {
+	FAILURE_BAD_HOST = 1,
+	FAILURE_SESSION_FAILED,
+	FAILURE_SESSION_FREED,
+	FAILURE_WINDOW_CLOSED,
+	FAILURE_SESSION_TERMINATE,
+	FAILURE_SESSION_RECOVERY_TIMEOUT,
+};
 
 static int
 iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
@@ -2297,12 +2319,14 @@ iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 
 	host = sc-&gt;device-&gt;host;
 	session = iscsi_hostdata(host-&gt;hostdata);
-	BUG_ON(host != session-&gt;host);
 
 	spin_lock(&amp;session-&gt;lock);
 
 	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
-		if (session-&gt;state == ISCSI_STATE_FAILED) {
+		if (session-&gt;recovery_failed) {
+			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
+			goto fault;
+		} else if (session-&gt;state == ISCSI_STATE_FAILED) {
 			reason = FAILURE_SESSION_FAILED;
 			goto reject;
 		} else if (session-&gt;state == ISCSI_STATE_TERMINATE) {
@@ -2350,11 +2374,6 @@ iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 	spin_unlock(&amp;session-&gt;lock);
 	printk(KERN_ERR "iscsi_tcp: cmd 0x%x is not queued (%d)\n",
 	       sc-&gt;cmnd[0], reason);
-	sc-&gt;sense_buffer[0] = 0x70;
-	sc-&gt;sense_buffer[2] = NOT_READY;
-	sc-&gt;sense_buffer[7] = 0x6;
-	sc-&gt;sense_buffer[12] = 0x08;
-	sc-&gt;sense_buffer[13] = 0x00;
 	sc-&gt;result = (DID_NO_CONNECT &lt;&lt; 16);
 	sc-&gt;resid = sc-&gt;request_bufflen;
 	sc-&gt;scsi_done(sc);
@@ -2445,6 +2464,7 @@ iscsi_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	conn-&gt;id = conn_idx;
 	conn-&gt;exp_statsn = 0;
 	conn-&gt;tmabort_state = TMABORT_INITIAL;
+	INIT_LIST_HEAD(&amp;conn-&gt;run_list);
 
 	/* initial operational parameters */
 	conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
@@ -2701,6 +2721,22 @@ iscsi_conn_bind(struct iscsi_cls_session *cls_session,
 	return 0;
 }
 
+static void
+iscsi_session_recovery_timedout(struct iscsi_cls_session *csession)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(csession);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	struct iscsi_conn *conn = session-&gt;leadconn;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
+		session-&gt;recovery_failed = 1;
+		if (conn)
+			wake_up(&amp;conn-&gt;ehwait);
+	}
+	spin_unlock_bh(&amp;session-&gt;lock);
+}
+
 static int
 iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 {
@@ -2716,7 +2752,6 @@ iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 	}
 
 	sk = conn-&gt;sock-&gt;sk;
-
 	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
 	spin_lock_bh(&amp;session-&gt;lock);
 	conn-&gt;c_stage = ISCSI_CONN_STARTED;
@@ -2732,8 +2767,13 @@ iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 		conn-&gt;stop_stage = 0;
 		conn-&gt;tmabort_state = TMABORT_INITIAL;
 		session-&gt;age++;
+		session-&gt;recovery_failed = 0;
+		spin_unlock_bh(&amp;session-&gt;lock);
+		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
+
+		iscsi_unblock_session(session_to_cls(session));
 		wake_up(&amp;conn-&gt;ehwait);
-		break;
+		return 0;
 	case STOP_CONN_TERM:
 		session-&gt;conn_cnt++;
 		conn-&gt;stop_stage = 0;
@@ -2752,105 +2792,199 @@ iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 	return 0;
 }
 
-static void
-iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
+static int
+iscsi_ctask_mtask_cleanup(struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_conn *conn = ctask-&gt;conn;
 	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_mgmt_task *mtask;
+
+	if (!ctask-&gt;mtask)
+		return -EINVAL;
+
+	while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*))) {
+		if (mtask == ctask-&gt;mtask)
+			break;
+		__kfifo_put(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*));
+	}
+
+	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;ctask-&gt;mtask,
+		    sizeof(void*));
+	ctask-&gt;mtask = NULL;
+	return 0;
+}
+
+static void
+fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask, int err)
+{
+	struct iscsi_r2t_info *r2t;
+	struct scsi_cmnd *sc;
+
+	/* flush ctask's r2t queues */
+	while (__kfifo_get(ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*)))
+		__kfifo_put(ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
+
+	iscsi_ctask_mtask_cleanup(ctask);
+
+	sc = ctask-&gt;sc;
+	if (!sc)
+		return;
+
+	sc-&gt;result = err;
+	sc-&gt;resid = sc-&gt;request_bufflen;
+
+	__iscsi_ctask_cleanup(conn, ctask);
+}
+
+/* Fail commands. Mutex and session lock held */
+static void
+fail_all_commands(struct iscsi_session *session, struct iscsi_conn *conn)
+{
+	struct iscsi_cmd_task *ctask, *tmp;
+
+	/* flush pending */
+	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;ctask, sizeof(void*))) {
+		debug_scsi("failing pending sc %p itt 0x%x\n", ctask-&gt;sc,
+			   ctask-&gt;itt);
+		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
+	}
+
+	/* fail running */
+	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;run_list, running) {
+		debug_scsi("failing in progress sc %p itt 0x%x\n",
+			   ctask-&gt;sc, ctask-&gt;itt);
+		fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
+	}
+
+	conn-&gt;ctask = NULL;
+}
+
+static void
+flush_control_queues(struct iscsi_session *session, struct iscsi_conn *conn)
+{
+	struct iscsi_mgmt_task *mtask;
+
+	/* TODO: handle running pdus */
+	while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;mtask, sizeof(void*)) ||
+	       __kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*))) {
+		if (mtask == conn-&gt;login_mtask)
+			continue;
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;mtask,
+			    sizeof(void*));
+	}
+
+	if (conn-&gt;mtask &amp;&amp; conn-&gt;mtask != conn-&gt;login_mtask)
+		__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;mtask,
+			    sizeof(void*));
+	conn-&gt;mtask = NULL;
+}
+
+static void
+iscsi_suspend_conn_rx(struct iscsi_conn *conn)
+{
 	struct sock *sk;
-	unsigned long flags;
 
 	BUG_ON(!conn-&gt;sock);
 	sk = conn-&gt;sock-&gt;sk;
 	write_lock_bh(&amp;sk-&gt;sk_callback_lock);
 	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
 	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
+}
 
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-
-	spin_lock_irqsave(session-&gt;host-&gt;host_lock, flags);
-	spin_lock(&amp;session-&gt;lock);
+static void
+iscsi_start_session_recovery(struct iscsi_session *session,
+			     struct iscsi_conn *conn, int flag)
+{
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (conn-&gt;stop_stage == STOP_CONN_RECOVER ||
+	    conn-&gt;stop_stage == STOP_CONN_TERM) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		return;
+	}
 	conn-&gt;stop_stage = flag;
+	spin_unlock_bh(&amp;session-&gt;lock);
+
+	iscsi_suspend_conn_rx(conn);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	spin_lock_bh(&amp;session-&gt;lock);
 	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
 	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 
-	if (flag != STOP_CONN_SUSPEND)
-		session-&gt;conn_cnt--;
-
+	session-&gt;conn_cnt--;
 	if (session-&gt;conn_cnt == 0 || session-&gt;leadconn == conn)
 		session-&gt;state = ISCSI_STATE_FAILED;
 
-	spin_unlock(&amp;session-&gt;lock);
-	spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
-
-	if (flag == STOP_CONN_TERM || flag == STOP_CONN_RECOVER) {
-		struct iscsi_cmd_task *ctask;
-		struct iscsi_mgmt_task *mtask;
+	spin_unlock_bh(&amp;session-&gt;lock);
 
-		/*
-		 * Socket must go now.
-		 */
-		sock_hold(conn-&gt;sock-&gt;sk);
-		iscsi_conn_restore_callbacks(conn);
-		sock_put(conn-&gt;sock-&gt;sk);
+	/*
+	 * Socket must go now.
+	 */
+	sock_hold(conn-&gt;sock-&gt;sk);
+	iscsi_conn_restore_callbacks(conn);
+	sock_put(conn-&gt;sock-&gt;sk);
 
-		/*
-		 * flush xmit queues.
-		 */
-		spin_lock_bh(&amp;session-&gt;lock);
-		while (__kfifo_get(conn-&gt;writequeue, (void*)&amp;ctask,
-			    sizeof(void*)) ||
-			__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;ctask,
-			    sizeof(void*))) {
-			struct iscsi_r2t_info *r2t;
-
-			/*
-			 * flush ctask's r2t queues
-			 */
-			while (__kfifo_get(ctask-&gt;r2tqueue, (void*)&amp;r2t,
-				sizeof(void*)))
-				__kfifo_put(ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
-					    sizeof(void*));
+	/*
+	 * flush queues.
+	 */
+	spin_lock_bh(&amp;session-&gt;lock);
+	fail_all_commands(session, conn);
+	flush_control_queues(session, conn);
+	spin_unlock_bh(&amp;session-&gt;lock);
 
-			spin_unlock_bh(&amp;session-&gt;lock);
-			local_bh_disable();
-			iscsi_ctask_cleanup(conn, ctask);
-			local_bh_enable();
-			spin_lock_bh(&amp;session-&gt;lock);
-		}
-		conn-&gt;ctask = NULL;
-		while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;mtask,
-			   sizeof(void*)) ||
-			__kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;mtask,
-			   sizeof(void*))) {
-			__kfifo_put(session-&gt;mgmtpool.queue,
-				    (void*)&amp;mtask, sizeof(void*));
-		}
-		conn-&gt;mtask = NULL;
-		spin_unlock_bh(&amp;session-&gt;lock);
+	/*
+	 * release socket only after we stopped data_xmit()
+	 * activity and flushed all outstandings
+	 */
+	sock_release(conn-&gt;sock);
+	conn-&gt;sock = NULL;
 
-		/*
-		 * release socket only after we stopped data_xmit()
-		 * activity and flushed all outstandings
-		 */
-		sock_release(conn-&gt;sock);
-		conn-&gt;sock = NULL;
+	/*
+	 * for connection level recovery we should not calculate
+	 * header digest. conn-&gt;hdr_size used for optimization
+	 * in hdr_extract() and will be re-negotiated at
+	 * set_param() time.
+	 */
+	if (flag == STOP_CONN_RECOVER) {
+		conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
+		conn-&gt;hdrdgst_en = 0;
+		conn-&gt;datadgst_en = 0;
 
-		/*
-		 * for connection level recovery we should not calculate
-		 * header digest. conn-&gt;hdr_size used for optimization
-		 * in hdr_extract() and will be re-negotiated at
-		 * set_param() time.
-		 */
-		if (flag == STOP_CONN_RECOVER) {
-			conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
-			conn-&gt;hdrdgst_en = 0;
-			conn-&gt;datadgst_en = 0;
-		}
+		if (session-&gt;state == ISCSI_STATE_FAILED)
+			iscsi_block_session(session_to_cls(session));
 	}
 	mutex_unlock(&amp;conn-&gt;xmitmutex);
 }
 
+static void
+iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+
+	switch (flag) {
+	case STOP_CONN_RECOVER:
+	case STOP_CONN_TERM:
+		iscsi_start_session_recovery(session, conn, flag);
+		return;
+	case STOP_CONN_SUSPEND:
+		iscsi_suspend_conn_rx(conn);
+
+		mutex_lock(&amp;conn-&gt;xmitmutex);
+		spin_lock_bh(&amp;session-&gt;lock);
+
+		conn-&gt;stop_stage = flag;
+		conn-&gt;c_stage = ISCSI_CONN_STOPPED;
+		set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+
+		spin_unlock_bh(&amp;session-&gt;lock);
+		mutex_unlock(&amp;conn-&gt;xmitmutex);
+		break;
+	default:
+		printk(KERN_ERR "invalid stop flag %d\n", flag);
+	}
+}
+
 static int
 iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 			char *data, uint32_t data_size)
@@ -2940,23 +3074,54 @@ iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 static int
 iscsi_eh_host_reset(struct scsi_cmnd *sc)
 {
-	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct iscsi_session *session = conn-&gt;session;
+	struct Scsi_Host *host = sc-&gt;device-&gt;host;
+	struct iscsi_session *session = iscsi_hostdata(host-&gt;hostdata);
+	struct iscsi_conn *conn = session-&gt;leadconn;
+	int fail_session = 0;
 
 	spin_lock_bh(&amp;session-&gt;lock);
 	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
+failed:
 		debug_scsi("failing host reset: session terminated "
 			   "[CID %d age %d]", conn-&gt;id, session-&gt;age);
 		spin_unlock_bh(&amp;session-&gt;lock);
 		return FAILED;
 	}
+
+	if (sc-&gt;SCp.phase == session-&gt;age) {
+		debug_scsi("failing connection CID %d due to SCSI host reset",
+			   conn-&gt;id);
+		fail_session = 1;
+	}
 	spin_unlock_bh(&amp;session-&gt;lock);
 
-	debug_scsi("failing connection CID %d due to SCSI host reset "
-		   "[itt 0x%x age %d]", conn-&gt;id, ctask-&gt;itt,
-		   session-&gt;age);
-	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	/*
+	 * we drop the lock here but the leadconn cannot be destoyed while
+	 * we are in the scsi eh
+	 */
+	if (fail_session) {
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		/*
+		 * if userspace cannot respond then we must kick this off
+		 * here for it
+		 */
+		iscsi_start_session_recovery(session, conn, STOP_CONN_RECOVER);
+	}
+
+	debug_scsi("iscsi_eh_host_reset wait for relogin\n");
+	wait_event_interruptible(conn-&gt;ehwait,
+				 session-&gt;state == ISCSI_STATE_TERMINATE ||
+				 session-&gt;state == ISCSI_STATE_LOGGED_IN ||
+				 session-&gt;recovery_failed);
+	if (signal_pending(current))
+		flush_signals(current);
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	if (session-&gt;state == ISCSI_STATE_LOGGED_IN)
+		printk(KERN_INFO "host reset succeeded\n");
+	else
+		goto failed;
+	spin_unlock_bh(&amp;session-&gt;lock);
 
 	return SUCCESS;
 }
@@ -2970,8 +3135,6 @@ iscsi_tmabort_timedout(unsigned long data)
 
 	spin_lock(&amp;session-&gt;lock);
 	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
-		__kfifo_put(session-&gt;mgmtpool.queue,
-				(void*)&amp;ctask-&gt;mtask, sizeof(void*));
 		conn-&gt;tmabort_state = TMABORT_TIMEDOUT;
 		debug_scsi("tmabort timedout [sc %lx itt 0x%x]\n",
 			(long)ctask-&gt;sc, ctask-&gt;itt);
@@ -2981,186 +3144,163 @@ iscsi_tmabort_timedout(unsigned long data)
 	spin_unlock(&amp;session-&gt;lock);
 }
 
+/* must be called with the mutex lock */
 static int
-iscsi_eh_abort(struct scsi_cmnd *sc)
+iscsi_exec_abort_task(struct scsi_cmnd *sc, struct iscsi_cmd_task *ctask)
 {
-	int rc;
-	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
 	struct iscsi_conn *conn = ctask-&gt;conn;
 	struct iscsi_session *session = conn-&gt;session;
-
-	conn-&gt;eh_abort_cnt++;
-	debug_scsi("aborting [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
+	struct iscsi_tm *hdr = &amp;conn-&gt;tmhdr;
+	int rc;
 
 	/*
-	 * two cases for ERL=0 here:
-	 *
-	 * 1) connection-level failure;
-	 * 2) recovery due protocol error;
+	 * ctask timed out but session is OK requests must be serialized.
 	 */
-	mutex_lock(&amp;conn-&gt;xmitmutex);
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
-		if (session-&gt;state == ISCSI_STATE_TERMINATE) {
-			spin_unlock_bh(&amp;session-&gt;lock);
-			mutex_unlock(&amp;conn-&gt;xmitmutex);
-			goto failed;
-		}
-		spin_unlock_bh(&amp;session-&gt;lock);
-	} else {
-		struct iscsi_tm *hdr = &amp;conn-&gt;tmhdr;
+	memset(hdr, 0, sizeof(struct iscsi_tm));
+	hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;
+	hdr-&gt;flags = ISCSI_TM_FUNC_ABORT_TASK;
+	hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
+	memcpy(hdr-&gt;lun, ctask-&gt;hdr.lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;rtt = ctask-&gt;hdr.itt;
+	hdr-&gt;refcmdsn = ctask-&gt;hdr.cmdsn;
 
-		/*
-		 * Still LOGGED_IN...
-		 */
+	rc = iscsi_conn_send_generic(conn, (struct iscsi_hdr *)hdr,
+				     NULL, 0);
+	if (rc) {
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		debug_scsi("abort sent failure [itt 0x%x] %d", ctask-&gt;itt, rc);
+		return rc;
+	}
 
-		if (!ctask-&gt;sc || sc-&gt;SCp.phase != session-&gt;age) {
-			/*
-			 * 1) ctask completed before time out. But session
-			 *    is still ok =&gt; Happy Retry.
-			 * 2) session was re-open during time out of ctask.
-			 */
-			spin_unlock_bh(&amp;session-&gt;lock);
-			mutex_unlock(&amp;conn-&gt;xmitmutex);
-			goto success;
-		}
-		conn-&gt;tmabort_state = TMABORT_INITIAL;
-		spin_unlock_bh(&amp;session-&gt;lock);
+	debug_scsi("abort sent [itt 0x%x]\n", ctask-&gt;itt);
 
-		/*
-		 * ctask timed out but session is OK
-		 * ERL=0 requires task mgmt abort to be issued on each
-		 * failed command. requests must be serialized.
-		 */
-		memset(hdr, 0, sizeof(struct iscsi_tm));
-		hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;
-		hdr-&gt;flags = ISCSI_TM_FUNC_ABORT_TASK;
-		hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
-		memcpy(hdr-&gt;lun, ctask-&gt;hdr.lun, sizeof(hdr-&gt;lun));
-		hdr-&gt;rtt = ctask-&gt;hdr.itt;
-		hdr-&gt;refcmdsn = ctask-&gt;hdr.cmdsn;
-
-		rc = iscsi_conn_send_generic(conn, (struct iscsi_hdr *)hdr,
-					     NULL, 0);
-		if (rc) {
-			iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-			debug_scsi("abort sent failure [itt 0x%x]", ctask-&gt;itt);
-		} else {
-			struct iscsi_r2t_info *r2t;
-
-			/*
-			 * TMF abort vs. TMF response race logic
-			 */
-			spin_lock_bh(&amp;session-&gt;lock);
-			ctask-&gt;mtask = (struct iscsi_mgmt_task *)
-				session-&gt;mgmt_cmds[(hdr-&gt;itt &amp; ITT_MASK) -
-							ISCSI_MGMT_ITT_OFFSET];
-			/*
-			 * have to flush r2tqueue to avoid r2t leaks
-			 */
-			while (__kfifo_get(ctask-&gt;r2tqueue, (void*)&amp;r2t,
-				sizeof(void*))) {
-				__kfifo_put(ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
-					sizeof(void*));
-			}
-			if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
-				conn-&gt;tmfcmd_pdus_cnt++;
-				conn-&gt;tmabort_timer.expires = 3*HZ + jiffies;
-				conn-&gt;tmabort_timer.function =
-						iscsi_tmabort_timedout;
-				conn-&gt;tmabort_timer.data = (unsigned long)ctask;
-				add_timer(&amp;conn-&gt;tmabort_timer);
-				debug_scsi("abort sent [itt 0x%x]", ctask-&gt;itt);
-			} else {
-				if (!ctask-&gt;sc ||
-				    conn-&gt;tmabort_state == TMABORT_SUCCESS) {
-					conn-&gt;tmabort_state = TMABORT_INITIAL;
-					spin_unlock_bh(&amp;session-&gt;lock);
-					mutex_unlock(&amp;conn-&gt;xmitmutex);
-					goto success;
-				}
-				conn-&gt;tmabort_state = TMABORT_INITIAL;
-				iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-			}
-			spin_unlock_bh(&amp;session-&gt;lock);
-		}
+	spin_lock_bh(&amp;session-&gt;lock);
+	ctask-&gt;mtask = (struct iscsi_mgmt_task *)
+			session-&gt;mgmt_cmds[(hdr-&gt;itt &amp; ITT_MASK) -
+					ISCSI_MGMT_ITT_OFFSET];
+
+	if (conn-&gt;tmabort_state == TMABORT_INITIAL) {
+		conn-&gt;tmfcmd_pdus_cnt++;
+		conn-&gt;tmabort_timer.expires = 10*HZ + jiffies;
+		conn-&gt;tmabort_timer.function = iscsi_tmabort_timedout;
+		conn-&gt;tmabort_timer.data = (unsigned long)ctask;
+		add_timer(&amp;conn-&gt;tmabort_timer);
+		debug_scsi("abort set timeout [itt 0x%x]", ctask-&gt;itt);
 	}
+	spin_unlock_bh(&amp;session-&gt;lock);
 	mutex_unlock(&amp;conn-&gt;xmitmutex);
 
-
 	/*
 	 * block eh thread until:
 	 *
-	 * 1) abort response;
-	 * 2) abort timeout;
-	 * 3) session re-opened;
-	 * 4) session terminated;
+	 * 1) abort response
+	 * 2) abort timeout
+	 * 3) session is terminated or restarted or userspace has
+	 * given up on recovery
 	 */
-	for (;;) {
-		int p_state = session-&gt;state;
-
-		rc = wait_event_interruptible(conn-&gt;ehwait,
-			(p_state == ISCSI_STATE_LOGGED_IN ?
-			 (session-&gt;state == ISCSI_STATE_TERMINATE ||
-			  conn-&gt;tmabort_state != TMABORT_INITIAL) :
-			 (session-&gt;state == ISCSI_STATE_TERMINATE ||
-			  session-&gt;state == ISCSI_STATE_LOGGED_IN)));
-		if (rc) {
-			/* shutdown.. */
-			session-&gt;state = ISCSI_STATE_TERMINATE;
-			goto failed;
-		}
+	wait_event_interruptible(conn-&gt;ehwait,
+				 sc-&gt;SCp.phase != session-&gt;age ||
+				 session-&gt;state != ISCSI_STATE_LOGGED_IN ||
+				 conn-&gt;tmabort_state != TMABORT_INITIAL ||
+				 session-&gt;recovery_failed);
+	if (signal_pending(current))
+		flush_signals(current);
+	del_timer_sync(&amp;conn-&gt;tmabort_timer);
 
-		if (signal_pending(current))
-			flush_signals(current);
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	return 0;
+}
 
-		if (session-&gt;state == ISCSI_STATE_TERMINATE)
-			goto failed;
+static int
+iscsi_eh_abort(struct scsi_cmnd *sc)
+{
+	struct iscsi_cmd_task *ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
+	struct iscsi_cmd_task *tmp_ctask;
+	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_session *session = conn-&gt;session;
+	int rc;
 
-		spin_lock_bh(&amp;session-&gt;lock);
-		if (sc-&gt;SCp.phase == session-&gt;age &amp;&amp;
-		   (conn-&gt;tmabort_state == TMABORT_TIMEDOUT ||
-		    conn-&gt;tmabort_state == TMABORT_FAILED)) {
-			conn-&gt;tmabort_state = TMABORT_INITIAL;
-			if (!ctask-&gt;sc) {
-				/*
-				 * ctask completed before tmf abort response or
-				 * time out.
-				 * But session is still ok =&gt; Happy Retry.
-				 */
-				spin_unlock_bh(&amp;session-&gt;lock);
-				break;
-			}
-			spin_unlock_bh(&amp;session-&gt;lock);
-			iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-			continue;
+	conn-&gt;eh_abort_cnt++;
+	debug_scsi("aborting [sc %p itt 0x%x]\n", sc, ctask-&gt;itt);
+
+	mutex_lock(&amp;conn-&gt;xmitmutex);
+	spin_lock_bh(&amp;session-&gt;lock);
+
+	/*
+	 * If we are not logged in or we have started a new session
+	 * then let the host reset code handle this
+	 */
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN ||
+	    sc-&gt;SCp.phase != session-&gt;age)
+		goto failed;
+
+	/* ctask completed before time out */
+	if (!ctask-&gt;sc)
+		goto success;
+
+	/* what should we do here ? */
+	if (conn-&gt;ctask == ctask) {
+		printk(KERN_INFO "sc %p itt 0x%x partially sent. Failing "
+		       "abort\n", sc, ctask-&gt;itt);
+		goto failed;
+	}
+
+	/* check for the easy pending cmd abort */
+	while (__kfifo_get(conn-&gt;xmitqueue, (void*)&amp;tmp_ctask, sizeof(void*))) {
+		if (tmp_ctask-&gt;itt == ctask-&gt;itt) {
+			debug_scsi("found pending task\n");
+			goto success;
 		}
+		__kfifo_put(conn-&gt;xmitqueue, (void*)&amp;tmp_ctask, sizeof(void*));
+	}
+
+	conn-&gt;tmabort_state = TMABORT_INITIAL;
+
+	spin_unlock_bh(&amp;session-&gt;lock);
+	rc = iscsi_exec_abort_task(sc, ctask);
+	spin_lock_bh(&amp;session-&gt;lock);
+
+	iscsi_ctask_mtask_cleanup(ctask);
+	if (rc || sc-&gt;SCp.phase != session-&gt;age ||
+	    session-&gt;state != ISCSI_STATE_LOGGED_IN)
+		goto failed;
+
+	/* ctask completed before tmf abort response */
+	if (!ctask-&gt;sc) {
+		debug_scsi("sc completed while abort in progress\n");
+		goto success;
+	}
+
+	if (conn-&gt;tmabort_state != TMABORT_SUCCESS) {
 		spin_unlock_bh(&amp;session-&gt;lock);
-		break;
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		spin_lock_bh(&amp;session-&gt;lock);
+		goto failed;
 	}
 
 success:
 	debug_scsi("abort success [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
-	rc = SUCCESS;
-	goto exit;
-
-failed:
-	debug_scsi("abort failed [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
-	rc = FAILED;
-
-exit:
-	del_timer_sync(&amp;conn-&gt;tmabort_timer);
+	spin_unlock_bh(&amp;session-&gt;lock);
 
-	mutex_lock(&amp;conn-&gt;xmitmutex);
+	/* clean up task if aborted */
 	if (conn-&gt;sock) {
 		struct sock *sk = conn-&gt;sock-&gt;sk;
 
 		write_lock_bh(&amp;sk-&gt;sk_callback_lock);
-		iscsi_ctask_cleanup(conn, ctask);
+		spin_lock(&amp;session-&gt;lock);
+		fail_command(conn, ctask, DRIVER_TIMEOUT &lt;&lt; 24);
+		spin_unlock(&amp;session-&gt;lock);
 		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 	}
 	mutex_unlock(&amp;conn-&gt;xmitmutex);
-	return rc;
+	return SUCCESS;
+
+failed:
+	spin_unlock_bh(&amp;session-&gt;lock);
+	mutex_unlock(&amp;conn-&gt;xmitmutex);
+
+	debug_scsi("abort failed [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
+	return FAILED;
 }
 
 static int
@@ -3359,16 +3499,6 @@ iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
 
-	spin_lock_bh(&amp;session-&gt;lock);
-	if (conn-&gt;c_stage != ISCSI_CONN_INITIAL_STAGE &amp;&amp;
-	    conn-&gt;stop_stage != STOP_CONN_RECOVER) {
-		printk(KERN_ERR "iscsi_tcp: can not change parameter [%d]\n",
-		       param);
-		spin_unlock_bh(&amp;session-&gt;lock);
-		return 0;
-	}
-	spin_unlock_bh(&amp;session-&gt;lock);
-
 	switch(param) {
 	case ISCSI_PARAM_MAX_RECV_DLENGTH: {
 		char *saveptr = conn-&gt;data;
@@ -3691,6 +3821,7 @@ static struct iscsi_transport iscsi_tcp_transport = {
 	.stop_conn		= iscsi_conn_stop,
 	.send_pdu		= iscsi_conn_send_pdu,
 	.get_stats		= iscsi_conn_get_stats,
+	.session_recovery_timedout = iscsi_session_recovery_timedout,
 };
 
 static int __init
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index ba26741ac154..12ef64179b4c 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -159,6 +159,7 @@ struct iscsi_conn {
 	struct kfifo		*immqueue;	/* immediate xmit queue */
 	struct kfifo		*mgmtqueue;	/* mgmt (control) xmit queue */
 	struct kfifo		*xmitqueue;	/* data-path cmd queue */
+	struct list_head	run_list;	/* list of cmds in progress */
 	struct work_struct	xmitwork;	/* per-conn. xmit workqueue */
 	struct mutex		xmitmutex;	/* serializes connection xmit,
 						 * access to kfifos:	  *
@@ -228,6 +229,7 @@ struct iscsi_session {
 						 * - mgmtpool,		   *
 						 * - r2tpool		   */
 	int			state;		/* session state           */
+	int			recovery_failed;
 	struct list_head	item;
 	void			*auth_client;
 	int			conn_cnt;
@@ -310,6 +312,7 @@ struct iscsi_cmd_task {
 	struct iscsi_conn	*conn;			/* used connection    */
 	struct iscsi_mgmt_task	*mtask;			/* tmf mtask in progr */
 
+	struct list_head	running;		/* running cmd list */
 	struct iscsi_r2t_info	*r2t;			/* in progress R2T    */
 	struct iscsi_queue	r2tpool;
 	struct kfifo		*r2tqueue;
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 72a71ebc9d03..e2b67e34d92e 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -31,17 +31,17 @@
 #include &lt;scsi/scsi_transport_iscsi.h&gt;
 #include &lt;scsi/iscsi_if.h&gt;
 
-#define ISCSI_SESSION_ATTRS 10
+#define ISCSI_SESSION_ATTRS 11
 #define ISCSI_CONN_ATTRS 10
+#define ISCSI_HOST_ATTRS 0
 
 struct iscsi_internal {
 	struct scsi_transport_template t;
 	struct iscsi_transport *iscsi_transport;
 	struct list_head list;
 	struct class_device cdev;
-	/*
-	 * We do not have any private or other attrs.
-	 */
+
+	struct class_device_attribute *host_attrs[ISCSI_HOST_ATTRS + 1];
 	struct transport_container conn_cont;
 	struct class_device_attribute *conn_attrs[ISCSI_CONN_ATTRS + 1];
 	struct transport_container session_cont;
@@ -114,6 +114,24 @@ static struct attribute_group iscsi_transport_group = {
 	.attrs = iscsi_transport_attrs,
 };
 
+static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
+			    struct class_device *cdev)
+{
+	struct Scsi_Host *shost = dev_to_shost(dev);
+	struct iscsi_host *ihost = shost-&gt;shost_data;
+
+	memset(ihost, 0, sizeof(*ihost));
+	INIT_LIST_HEAD(&amp;ihost-&gt;sessions);
+	mutex_init(&amp;ihost-&gt;mutex);
+	return 0;
+}
+
+static DECLARE_TRANSPORT_CLASS(iscsi_host_class,
+			       "iscsi_host",
+			       iscsi_setup_host,
+			       NULL,
+			       NULL);
+
 static DECLARE_TRANSPORT_CLASS(iscsi_session_class,
 			       "iscsi_session",
 			       NULL,
@@ -225,6 +243,54 @@ static int iscsi_is_session_dev(const struct device *dev)
 	return dev-&gt;release == iscsi_session_release;
 }
 
+static int iscsi_user_scan(struct Scsi_Host *shost, uint channel,
+			   uint id, uint lun)
+{
+	struct iscsi_host *ihost = shost-&gt;shost_data;
+	struct iscsi_cls_session *session;
+
+	mutex_lock(&amp;ihost-&gt;mutex);
+	list_for_each_entry(session, &amp;ihost-&gt;sessions, host_list) {
+		if ((channel == SCAN_WILD_CARD ||
+		     channel == session-&gt;channel) &amp;&amp;
+		    (id == SCAN_WILD_CARD || id == session-&gt;target_id))
+			scsi_scan_target(&amp;session-&gt;dev, session-&gt;channel,
+					 session-&gt;target_id, lun, 1);
+	}
+	mutex_unlock(&amp;ihost-&gt;mutex);
+
+	return 0;
+}
+
+static void session_recovery_timedout(void *data)
+{
+	struct iscsi_cls_session *session = data;
+
+	dev_printk(KERN_INFO, &amp;session-&gt;dev, "session recovery timed out "
+		  "after %d secs\n", session-&gt;recovery_tmo);
+
+	if (session-&gt;transport-&gt;session_recovery_timedout)
+		session-&gt;transport-&gt;session_recovery_timedout(session);
+
+	scsi_target_unblock(&amp;session-&gt;dev);
+}
+
+void iscsi_unblock_session(struct iscsi_cls_session *session)
+{
+	if (!cancel_delayed_work(&amp;session-&gt;recovery_work))
+		flush_scheduled_work();
+	scsi_target_unblock(&amp;session-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(iscsi_unblock_session);
+
+void iscsi_block_session(struct iscsi_cls_session *session)
+{
+	scsi_target_block(&amp;session-&gt;dev);
+	schedule_delayed_work(&amp;session-&gt;recovery_work,
+			     session-&gt;recovery_tmo * HZ);
+}
+EXPORT_SYMBOL_GPL(iscsi_block_session);
+
 /**
  * iscsi_create_session - create iscsi class session
  * @shost: scsi host
@@ -233,8 +299,10 @@ static int iscsi_is_session_dev(const struct device *dev)
  * This can be called from a LLD or iscsi_transport.
  **/
 struct iscsi_cls_session *
-iscsi_create_session(struct Scsi_Host *shost, struct iscsi_transport *transport)
+iscsi_create_session(struct Scsi_Host *shost,
+		     struct iscsi_transport *transport, int channel)
 {
+	struct iscsi_host *ihost;
 	struct iscsi_cls_session *session;
 	int err;
 
@@ -246,13 +314,22 @@ iscsi_create_session(struct Scsi_Host *shost, struct iscsi_transport *transport)
 	if (!session)
 		goto module_put;
 	session-&gt;transport = transport;
+	session-&gt;recovery_tmo = 120;
+	INIT_WORK(&amp;session-&gt;recovery_work, session_recovery_timedout, session);
+	INIT_LIST_HEAD(&amp;session-&gt;host_list);
+	INIT_LIST_HEAD(&amp;session-&gt;sess_list);
 
 	if (transport-&gt;sessiondata_size)
 		session-&gt;dd_data = &amp;session[1];
 
 	/* this is released in the dev's release function */
 	scsi_host_get(shost);
+	ihost = shost-&gt;shost_data;
+
 	session-&gt;sid = iscsi_session_nr++;
+	session-&gt;channel = channel;
+	session-&gt;target_id = ihost-&gt;next_target_id++;
+
 	snprintf(session-&gt;dev.bus_id, BUS_ID_SIZE, "session%u",
 		 session-&gt;sid);
 	session-&gt;dev.parent = &amp;shost-&gt;shost_gendev;
@@ -265,6 +342,10 @@ iscsi_create_session(struct Scsi_Host *shost, struct iscsi_transport *transport)
 	}
 	transport_register_device(&amp;session-&gt;dev);
 
+	mutex_lock(&amp;ihost-&gt;mutex);
+	list_add(&amp;session-&gt;host_list, &amp;ihost-&gt;sessions);
+	mutex_unlock(&amp;ihost-&gt;mutex);
+
 	return session;
 
 free_session:
@@ -285,6 +366,16 @@ EXPORT_SYMBOL_GPL(iscsi_create_session);
  **/
 int iscsi_destroy_session(struct iscsi_cls_session *session)
 {
+	struct Scsi_Host *shost = iscsi_session_to_shost(session);
+	struct iscsi_host *ihost = shost-&gt;shost_data;
+
+	if (!cancel_delayed_work(&amp;session-&gt;recovery_work))
+		flush_scheduled_work();
+
+	mutex_lock(&amp;ihost-&gt;mutex);
+	list_del(&amp;session-&gt;host_list);
+	mutex_unlock(&amp;ihost-&gt;mutex);
+
 	transport_unregister_device(&amp;session-&gt;dev);
 	device_unregister(&amp;session-&gt;dev);
 	return 0;
@@ -435,7 +526,7 @@ iscsi_transport_create_session(struct scsi_transport_template *scsit,
 	if (scsi_add_host(shost, NULL))
 		goto free_host;
 
-	session = iscsi_create_session(shost, transport);
+	session = iscsi_create_session(shost, transport, 0);
 	if (!session)
 		goto remove_host;
 
@@ -466,12 +557,13 @@ int iscsi_transport_destroy_session(struct Scsi_Host *shost)
 	struct iscsi_cls_session *session;
 	unsigned long flags;
 
-	scsi_remove_host(shost);
 	session = hostdata_session(shost-&gt;hostdata);
 	spin_lock_irqsave(&amp;sesslock, flags);
 	list_del(&amp;session-&gt;sess_list);
 	spin_unlock_irqrestore(&amp;sesslock, flags);
 	iscsi_destroy_session(session);
+
+	scsi_remove_host(shost);
 	/* ref from host alloc */
 	scsi_host_put(shost);
 	return 0;
@@ -594,6 +686,7 @@ iscsi_unicast_skb(struct mempool_zone *zone, struct sk_buff *skb)
 	}
 
 	spin_lock_irqsave(&amp;zone-&gt;freelock, flags);
+	INIT_LIST_HEAD(skb_to_lh(skb));
 	list_add(skb_to_lh(skb), &amp;zone-&gt;freequeue);
 	spin_unlock_irqrestore(&amp;zone-&gt;freelock, flags);
 
@@ -888,6 +981,11 @@ iscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 		return -EINVAL;
 
 	switch (ev-&gt;u.set_param.param) {
+	case ISCSI_PARAM_SESS_RECOVERY_TMO:
+		iscsi_copy_param(ev, &amp;value, data);
+		if (value != 0)
+			session-&gt;recovery_tmo = value;
+		break;
 	case ISCSI_PARAM_TARGET_NAME:
 		/* this should not change between logins */
 		if (session-&gt;targetname)
@@ -980,7 +1078,6 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 			ev-&gt;r.retcode = transport-&gt;start_conn(conn);
 		else
 			err = -EINVAL;
-
 		break;
 	case ISCSI_UEVENT_STOP_CONN:
 		conn = iscsi_conn_lookup(ev-&gt;u.stop_conn.sid, ev-&gt;u.stop_conn.cid);
@@ -1198,6 +1295,7 @@ static ISCSI_CLASS_ATTR(priv_sess, field, S_IRUGO, show_priv_session_##field, \
 			NULL)
 iscsi_priv_session_attr(targetname, "%s");
 iscsi_priv_session_attr(tpgt, "%d");
+iscsi_priv_session_attr(recovery_tmo, "%d");
 
 #define iscsi_priv_conn_attr_show(field, format)			\
 static ssize_t								\
@@ -1289,6 +1387,24 @@ static int iscsi_conn_match(struct attribute_container *cont,
 	return &amp;priv-&gt;conn_cont.ac == cont;
 }
 
+static int iscsi_host_match(struct attribute_container *cont,
+			    struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct iscsi_internal *priv;
+
+	if (!scsi_is_host_device(dev))
+		return 0;
+
+	shost = dev_to_shost(dev);
+	if (!shost-&gt;transportt  ||
+	    shost-&gt;transportt-&gt;host_attrs.ac.class != &amp;iscsi_host_class.class)
+		return 0;
+
+        priv = to_iscsi_internal(shost-&gt;transportt);
+        return &amp;priv-&gt;t.host_attrs.ac == cont;
+}
+
 struct scsi_transport_template *
 iscsi_register_transport(struct iscsi_transport *tt)
 {
@@ -1307,6 +1423,7 @@ iscsi_register_transport(struct iscsi_transport *tt)
 		return NULL;
 	INIT_LIST_HEAD(&amp;priv-&gt;list);
 	priv-&gt;iscsi_transport = tt;
+	priv-&gt;t.user_scan = iscsi_user_scan;
 
 	priv-&gt;cdev.class = &amp;iscsi_transport_class;
 	snprintf(priv-&gt;cdev.class_id, BUS_ID_SIZE, "%s", tt-&gt;name);
@@ -1318,6 +1435,14 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	if (err)
 		goto unregister_cdev;
 
+	/* host parameters */
+	priv-&gt;t.host_attrs.ac.attrs = &amp;priv-&gt;host_attrs[0];
+	priv-&gt;t.host_attrs.ac.class = &amp;iscsi_host_class.class;
+	priv-&gt;t.host_attrs.ac.match = iscsi_host_match;
+	priv-&gt;t.host_size = sizeof(struct iscsi_host);
+	priv-&gt;host_attrs[0] = NULL;
+	transport_container_register(&amp;priv-&gt;t.host_attrs);
+
 	/* connection parameters */
 	priv-&gt;conn_cont.ac.attrs = &amp;priv-&gt;conn_attrs[0];
 	priv-&gt;conn_cont.ac.class = &amp;iscsi_connection_class.class;
@@ -1361,6 +1486,7 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	SETUP_SESSION_RD_ATTR(data_pdu_in_order, ISCSI_PDU_INORDER_EN);
 	SETUP_SESSION_RD_ATTR(data_seq_in_order, ISCSI_DATASEQ_INORDER_EN);
 	SETUP_SESSION_RD_ATTR(erl, ISCSI_ERL);
+	SETUP_PRIV_SESSION_RD_ATTR(recovery_tmo);
 
 	if (tt-&gt;param_mask &amp; ISCSI_TARGET_NAME)
 		SETUP_SESSION_RD_ATTR(targetname, ISCSI_TARGET_NAME);
@@ -1408,6 +1534,7 @@ int iscsi_unregister_transport(struct iscsi_transport *tt)
 
 	transport_container_unregister(&amp;priv-&gt;conn_cont);
 	transport_container_unregister(&amp;priv-&gt;session_cont);
+	transport_container_unregister(&amp;priv-&gt;t.host_attrs);
 
 	sysfs_remove_group(&amp;priv-&gt;cdev.kobj, &amp;iscsi_transport_group);
 	class_device_unregister(&amp;priv-&gt;cdev);
@@ -1451,10 +1578,14 @@ static __init int iscsi_transport_init(void)
 	if (err)
 		return err;
 
-	err = transport_class_register(&amp;iscsi_connection_class);
+	err = transport_class_register(&amp;iscsi_host_class);
 	if (err)
 		goto unregister_transport_class;
 
+	err = transport_class_register(&amp;iscsi_connection_class);
+	if (err)
+		goto unregister_host_class;
+
 	err = transport_class_register(&amp;iscsi_session_class);
 	if (err)
 		goto unregister_conn_class;
@@ -1482,6 +1613,8 @@ static __init int iscsi_transport_init(void)
 	transport_class_unregister(&amp;iscsi_session_class);
 unregister_conn_class:
 	transport_class_unregister(&amp;iscsi_connection_class);
+unregister_host_class:
+	transport_class_unregister(&amp;iscsi_host_class);
 unregister_transport_class:
 	class_unregister(&amp;iscsi_transport_class);
 	return err;
@@ -1494,6 +1627,7 @@ static void __exit iscsi_transport_exit(void)
 	netlink_unregister_notifier(&amp;iscsi_nl_notifier);
 	transport_class_unregister(&amp;iscsi_connection_class);
 	transport_class_unregister(&amp;iscsi_session_class);
+	transport_class_unregister(&amp;iscsi_host_class);
 	class_unregister(&amp;iscsi_transport_class);
 }
 
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 2c3a89b64e71..eebe2b15161b 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -174,6 +174,7 @@ enum iscsi_param {
 	ISCSI_PARAM_TPGT,
 	ISCSI_PARAM_PERSISTENT_ADDRESS,
 	ISCSI_PARAM_PERSISTENT_PORT,
+	ISCSI_PARAM_SESS_RECOVERY_TMO,
 
 	/* pased in through bind conn using transport_fd */
 	ISCSI_PARAM_CONN_PORT,
@@ -201,6 +202,7 @@ enum iscsi_param {
 #define ISCSI_TPGT			(1 &lt;&lt; ISCSI_PARAM_TPGT)
 #define ISCSI_PERSISTENT_ADDRESS	(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_ADDRESS)
 #define ISCSI_PERSISTENT_PORT		(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_PORT)
+#define ISCSI_SESS_RECOVERY_TMO		(1 &lt;&lt; ISCSI_PARAM_SESS_RECOVERY_TMO)
 #define ISCSI_CONN_PORT			(1 &lt;&lt; ISCSI_PARAM_CONN_PORT)
 #define ISCSI_CONN_ADDRESS		(1 &lt;&lt; ISCSI_PARAM_CONN_ADDRESS)
 
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 4b200645c84b..9d2b99159ee7 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -90,6 +90,7 @@ struct iscsi_transport {
 			 char *data, uint32_t data_size);
 	void (*get_stats) (struct iscsi_cls_conn *conn,
 			   struct iscsi_stats *stats);
+	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
 };
 
 /*
@@ -130,12 +131,20 @@ struct iscsi_cls_conn {
 
 struct iscsi_cls_session {
 	struct list_head sess_list;		/* item in session_list */
+	struct list_head host_list;
 	struct iscsi_transport *transport;
 
 	/* iSCSI values used as unique id by userspace. */
 	char *targetname;
 	int tpgt;
 
+	/* recovery fields */
+	int recovery_tmo;
+	struct work_struct recovery_work;
+
+	int target_id;
+	int channel;
+
 	int sid;				/* session id */
 	void *dd_data;				/* LLD private data */
 	struct device dev;	/* sysfs transport/container device */
@@ -147,15 +156,23 @@ struct iscsi_cls_session {
 #define iscsi_session_to_shost(_session) \
 	dev_to_shost(_session-&gt;dev.parent)
 
+struct iscsi_host {
+	int next_target_id;
+	struct list_head sessions;
+	struct mutex mutex;
+};
+
 /*
  * session and connection functions that can be used by HW iSCSI LLDs
  */
 extern struct iscsi_cls_session *iscsi_create_session(struct Scsi_Host *shost,
-				struct iscsi_transport *t);
+				struct iscsi_transport *t, int channel);
 extern int iscsi_destroy_session(struct iscsi_cls_session *session);
 extern struct iscsi_cls_conn *iscsi_create_conn(struct iscsi_cls_session *sess,
 					    uint32_t cid);
 extern int iscsi_destroy_conn(struct iscsi_cls_conn *conn);
+extern void iscsi_unblock_session(struct iscsi_cls_session *session);
+extern void iscsi_block_session(struct iscsi_cls_session *session);
 
 /*
  * session functions used by software iscsi</pre><hr><pre>commit fd7255f51a13ea915099c7e488001dfbbeb05104
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Apr 6 21:13:36 2006 -0500

    [SCSI] iscsi: add sysfs attrs for uspace sync up
    
    For iscsi boot when going from initramfs to the real root we
    need to stop the userpsace iscsi daemon. To later restart it
    iscsid needs to be able to rebuild itself and part of that
    process is matching a session running the kernel with the
    iscsid representation. To do this the attached patch
    adds several required iscsi values. If the LLD does not provide
    them becuase, login is done in userspace, then the transport
    class and userspace set ths up for the LLD.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 6ecb4baa37e2..6e510f3cfbf6 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -3536,7 +3536,7 @@ iscsi_session_get_param(struct iscsi_cls_session *cls_session,
 		*value = session-&gt;ofmarker_en;
 		break;
 	default:
-		return ISCSI_ERR_PARAM_NOT_FOUND;
+		return -EINVAL;
 	}
 
 	return 0;
@@ -3547,6 +3547,7 @@ iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 		     enum iscsi_param param, uint32_t *value)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct inet_sock *inet;
 
 	switch(param) {
 	case ISCSI_PARAM_MAX_RECV_DLENGTH:
@@ -3561,13 +3562,61 @@ iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 	case ISCSI_PARAM_DATADGST_EN:
 		*value = conn-&gt;datadgst_en;
 		break;
+	case ISCSI_PARAM_CONN_PORT:
+		mutex_lock(&amp;conn-&gt;xmitmutex);
+		if (!conn-&gt;sock) {
+			mutex_unlock(&amp;conn-&gt;xmitmutex);
+			return -EINVAL;
+		}
+
+		inet = inet_sk(conn-&gt;sock-&gt;sk);
+		*value = be16_to_cpu(inet-&gt;dport);
+		mutex_unlock(&amp;conn-&gt;xmitmutex);
 	default:
-		return ISCSI_ERR_PARAM_NOT_FOUND;
+		return -EINVAL;
 	}
 
 	return 0;
 }
 
+static int
+iscsi_conn_get_str_param(struct iscsi_cls_conn *cls_conn,
+			 enum iscsi_param param, char *buf)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct sock *sk;
+	struct inet_sock *inet;
+	struct ipv6_pinfo *np;
+	int len = 0;
+
+	switch (param) {
+	case ISCSI_PARAM_CONN_ADDRESS:
+		mutex_lock(&amp;conn-&gt;xmitmutex);
+		if (!conn-&gt;sock) {
+			mutex_unlock(&amp;conn-&gt;xmitmutex);
+			return -EINVAL;
+		}
+
+		sk = conn-&gt;sock-&gt;sk;
+		if (sk-&gt;sk_family == PF_INET) {
+			inet = inet_sk(sk);
+			len = sprintf(buf, "%u.%u.%u.%u\n",
+				      NIPQUAD(inet-&gt;daddr));
+		} else {
+			np = inet6_sk(sk);
+			len = sprintf(buf,
+				"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
+				NIP6(np-&gt;daddr));
+		}
+		mutex_unlock(&amp;conn-&gt;xmitmutex);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return len;
+}
+
 static void
 iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
 {
@@ -3610,6 +3659,20 @@ static struct iscsi_transport iscsi_tcp_transport = {
 	.name			= "tcp",
 	.caps			= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST
 				  | CAP_DATADGST,
+	.param_mask		= ISCSI_MAX_RECV_DLENGTH |
+				  ISCSI_MAX_XMIT_DLENGTH |
+				  ISCSI_HDRDGST_EN |
+				  ISCSI_DATADGST_EN |
+				  ISCSI_INITIAL_R2T_EN |
+				  ISCSI_MAX_R2T |
+				  ISCSI_IMM_DATA_EN |
+				  ISCSI_FIRST_BURST |
+				  ISCSI_MAX_BURST |
+				  ISCSI_PDU_INORDER_EN |
+				  ISCSI_DATASEQ_INORDER_EN |
+				  ISCSI_ERL |
+				  ISCSI_CONN_PORT |
+				  ISCSI_CONN_ADDRESS,
 	.host_template		= &amp;iscsi_sht,
 	.hostdata_size		= sizeof(struct iscsi_session),
 	.conndata_size		= sizeof(struct iscsi_conn),
@@ -3622,6 +3685,7 @@ static struct iscsi_transport iscsi_tcp_transport = {
 	.destroy_conn		= iscsi_conn_destroy,
 	.set_param		= iscsi_conn_set_param,
 	.get_conn_param		= iscsi_conn_get_param,
+	.get_conn_str_param	= iscsi_conn_get_str_param,
 	.get_session_param	= iscsi_session_get_param,
 	.start_conn		= iscsi_conn_start,
 	.stop_conn		= iscsi_conn_stop,
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 10ff0f0210ba..72a71ebc9d03 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -31,21 +31,13 @@
 #include &lt;scsi/scsi_transport_iscsi.h&gt;
 #include &lt;scsi/iscsi_if.h&gt;
 
-#define ISCSI_SESSION_ATTRS 8
-#define ISCSI_CONN_ATTRS 6
+#define ISCSI_SESSION_ATTRS 10
+#define ISCSI_CONN_ATTRS 10
 
 struct iscsi_internal {
 	struct scsi_transport_template t;
 	struct iscsi_transport *iscsi_transport;
 	struct list_head list;
-	/*
-	 * based on transport capabilities, at register time we set these
-	 * bits to tell the transport class it wants attributes displayed
-	 * in sysfs or that it can support different iSCSI Data-Path
-	 * capabilities
-	 */
-	uint32_t param_mask;
-
 	struct class_device cdev;
 	/*
 	 * We do not have any private or other attrs.
@@ -223,6 +215,7 @@ static void iscsi_session_release(struct device *dev)
 
 	shost = iscsi_session_to_shost(session);
 	scsi_host_put(shost);
+	kfree(session-&gt;targetname);
 	kfree(session);
 	module_put(transport-&gt;owner);
 }
@@ -304,6 +297,7 @@ static void iscsi_conn_release(struct device *dev)
 	struct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev);
 	struct device *parent = conn-&gt;dev.parent;
 
+	kfree(conn-&gt;persistent_address);
 	kfree(conn);
 	put_device(parent);
 }
@@ -870,6 +864,67 @@ iscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev
 	return 0;
 }
 
+static void
+iscsi_copy_param(struct iscsi_uevent *ev, uint32_t *value, char *data)
+{
+	if (ev-&gt;u.set_param.len != sizeof(uint32_t))
+		BUG();
+	memcpy(value, data, min_t(uint32_t, sizeof(uint32_t),
+		ev-&gt;u.set_param.len));
+}
+
+static int
+iscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)
+{
+	char *data = (char*)ev + sizeof(*ev);
+	struct iscsi_cls_conn *conn;
+	struct iscsi_cls_session *session;
+	int err = 0;
+	uint32_t value = 0;
+
+	session = iscsi_session_lookup(ev-&gt;u.set_param.sid);
+	conn = iscsi_conn_lookup(ev-&gt;u.set_param.sid, ev-&gt;u.set_param.cid);
+	if (!conn || !session)
+		return -EINVAL;
+
+	switch (ev-&gt;u.set_param.param) {
+	case ISCSI_PARAM_TARGET_NAME:
+		/* this should not change between logins */
+		if (session-&gt;targetname)
+			return 0;
+
+		session-&gt;targetname = kstrdup(data, GFP_KERNEL);
+		if (!session-&gt;targetname)
+			return -ENOMEM;
+		break;
+	case ISCSI_PARAM_TPGT:
+		iscsi_copy_param(ev, &amp;value, data);
+		session-&gt;tpgt = value;
+		break;
+	case ISCSI_PARAM_PERSISTENT_PORT:
+		iscsi_copy_param(ev, &amp;value, data);
+		conn-&gt;persistent_port = value;
+		break;
+	case ISCSI_PARAM_PERSISTENT_ADDRESS:
+		/*
+		 * this is the address returned in discovery so it should
+		 * not change between logins.
+		 */
+		if (conn-&gt;persistent_address)
+			return 0;
+
+		conn-&gt;persistent_address = kstrdup(data, GFP_KERNEL);
+		if (!conn-&gt;persistent_address)
+			return -ENOMEM;
+		break;
+	default:
+		iscsi_copy_param(ev, &amp;value, data);
+		err = transport-&gt;set_param(conn, ev-&gt;u.set_param.param, value);
+	}
+
+	return err;
+}
+
 static int
 iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
@@ -917,12 +972,7 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_SET_PARAM:
-		conn = iscsi_conn_lookup(ev-&gt;u.set_param.sid, ev-&gt;u.set_param.cid);
-		if (conn)
-			ev-&gt;r.retcode =	transport-&gt;set_param(conn,
-				ev-&gt;u.set_param.param, ev-&gt;u.set_param.value);
-		else
-			err = -EINVAL;
+		err = iscsi_set_param(transport, ev);
 		break;
 	case ISCSI_UEVENT_START_CONN:
 		conn = iscsi_conn_lookup(ev-&gt;u.start_conn.sid, ev-&gt;u.start_conn.cid);
@@ -1028,6 +1078,10 @@ iscsi_if_rx(struct sock *sk, int len)
 #define iscsi_cdev_to_conn(_cdev) \
 	iscsi_dev_to_conn(_cdev-&gt;dev)
 
+#define ISCSI_CLASS_ATTR(_prefix,_name,_mode,_show,_store)		\
+struct class_device_attribute class_device_attr_##_prefix##_##_name =	\
+	__ATTR(_name,_mode,_show,_store)
+
 /*
  * iSCSI connection attrs
  */
@@ -1045,7 +1099,8 @@ show_conn_int_param_##param(struct class_device *cdev, char *buf)	\
 
 #define iscsi_conn_int_attr(field, param, format)			\
 	iscsi_conn_int_attr_show(param, format)				\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_conn_int_param_##param, NULL);
+static ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_int_param_##param, \
+			NULL);
 
 iscsi_conn_int_attr(max_recv_dlength, ISCSI_PARAM_MAX_RECV_DLENGTH, "%u");
 iscsi_conn_int_attr(max_xmit_dlength, ISCSI_PARAM_MAX_XMIT_DLENGTH, "%u");
@@ -1053,6 +1108,25 @@ iscsi_conn_int_attr(header_digest, ISCSI_PARAM_HDRDGST_EN, "%d");
 iscsi_conn_int_attr(data_digest, ISCSI_PARAM_DATADGST_EN, "%d");
 iscsi_conn_int_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN, "%d");
 iscsi_conn_int_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN, "%d");
+iscsi_conn_int_attr(persistent_port, ISCSI_PARAM_PERSISTENT_PORT, "%d");
+iscsi_conn_int_attr(port, ISCSI_PARAM_CONN_PORT, "%d");
+
+#define iscsi_conn_str_attr_show(param)					\
+static ssize_t								\
+show_conn_str_param_##param(struct class_device *cdev, char *buf)	\
+{									\
+	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
+	struct iscsi_transport *t = conn-&gt;transport;			\
+	return t-&gt;get_conn_str_param(conn, param, buf);			\
+}
+
+#define iscsi_conn_str_attr(field, param)				\
+	iscsi_conn_str_attr_show(param)					\
+static ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_str_param_##param, \
+			NULL);
+
+iscsi_conn_str_attr(persistent_address, ISCSI_PARAM_PERSISTENT_ADDRESS);
+iscsi_conn_str_attr(address, ISCSI_PARAM_CONN_ADDRESS);
 
 #define iscsi_cdev_to_session(_cdev) \
 	iscsi_dev_to_session(_cdev-&gt;dev)
@@ -1074,7 +1148,8 @@ show_session_int_param_##param(struct class_device *cdev, char *buf)	\
 
 #define iscsi_session_int_attr(field, param, format)			\
 	iscsi_session_int_attr_show(param, format)			\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_session_int_param_##param, NULL);
+static ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_int_param_##param, \
+			NULL);
 
 iscsi_session_int_attr(initial_r2t, ISCSI_PARAM_INITIAL_R2T_EN, "%d");
 iscsi_session_int_attr(max_outstanding_r2t, ISCSI_PARAM_MAX_R2T, "%hu");
@@ -1084,18 +1159,88 @@ iscsi_session_int_attr(max_burst_len, ISCSI_PARAM_MAX_BURST, "%u");
 iscsi_session_int_attr(data_pdu_in_order, ISCSI_PARAM_PDU_INORDER_EN, "%d");
 iscsi_session_int_attr(data_seq_in_order, ISCSI_PARAM_DATASEQ_INORDER_EN, "%d");
 iscsi_session_int_attr(erl, ISCSI_PARAM_ERL, "%d");
+iscsi_session_int_attr(tpgt, ISCSI_PARAM_TPGT, "%d");
 
-#define SETUP_SESSION_RD_ATTR(field, param)				\
-	if (priv-&gt;param_mask &amp; (1 &lt;&lt; param)) {				\
-		priv-&gt;session_attrs[count] = &amp;class_device_attr_##field;\
-		count++;						\
-	}
+#define iscsi_session_str_attr_show(param)				\
+static ssize_t								\
+show_session_str_param_##param(struct class_device *cdev, char *buf)	\
+{									\
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev); \
+	struct iscsi_transport *t = session-&gt;transport;			\
+	return t-&gt;get_session_str_param(session, param, buf);		\
+}
+
+#define iscsi_session_str_attr(field, param)				\
+	iscsi_session_str_attr_show(param)				\
+static ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_str_param_##param, \
+			NULL);
+
+iscsi_session_str_attr(targetname, ISCSI_PARAM_TARGET_NAME);
 
-#define SETUP_CONN_RD_ATTR(field, param)				\
-	if (priv-&gt;param_mask &amp; (1 &lt;&lt; param)) {				\
-		priv-&gt;conn_attrs[count] = &amp;class_device_attr_##field;	\
+/*
+ * Private session and conn attrs. userspace uses several iscsi values
+ * to identify each session between reboots. Some of these values may not
+ * be present in the iscsi_transport/LLD driver becuase userspace handles
+ * login (and failback for login redirect) so for these type of drivers
+ * the class manages the attrs and values for the iscsi_transport/LLD
+ */
+#define iscsi_priv_session_attr_show(field, format)			\
+static ssize_t								\
+show_priv_session_##field(struct class_device *cdev, char *buf)	\
+{									\
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev); \
+	return sprintf(buf, format"\n", session-&gt;field);		\
+}
+
+#define iscsi_priv_session_attr(field, format)				\
+	iscsi_priv_session_attr_show(field, format)			\
+static ISCSI_CLASS_ATTR(priv_sess, field, S_IRUGO, show_priv_session_##field, \
+			NULL)
+iscsi_priv_session_attr(targetname, "%s");
+iscsi_priv_session_attr(tpgt, "%d");
+
+#define iscsi_priv_conn_attr_show(field, format)			\
+static ssize_t								\
+show_priv_conn_##field(struct class_device *cdev, char *buf)		\
+{									\
+	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
+	return sprintf(buf, format"\n", conn-&gt;field);			\
+}
+
+#define iscsi_priv_conn_attr(field, format)				\
+	iscsi_priv_conn_attr_show(field, format)			\
+static ISCSI_CLASS_ATTR(priv_conn, field, S_IRUGO, show_priv_conn_##field, \
+			NULL)
+iscsi_priv_conn_attr(persistent_address, "%s");
+iscsi_priv_conn_attr(persistent_port, "%d");
+
+#define SETUP_PRIV_SESSION_RD_ATTR(field)				\
+do {									\
+	priv-&gt;session_attrs[count] = &amp;class_device_attr_priv_sess_##field; \
+	count++;							\
+} while (0)
+
+#define SETUP_SESSION_RD_ATTR(field, param_flag)			\
+do {									\
+	if (tt-&gt;param_mask &amp; param_flag) {				\
+		priv-&gt;session_attrs[count] = &amp;class_device_attr_sess_##field; \
 		count++;						\
-	}
+	}								\
+} while (0)
+
+#define SETUP_PRIV_CONN_RD_ATTR(field)					\
+do {									\
+	priv-&gt;conn_attrs[count] = &amp;class_device_attr_priv_conn_##field; \
+	count++;							\
+} while (0)
+
+#define SETUP_CONN_RD_ATTR(field, param_flag)				\
+do {									\
+	if (tt-&gt;param_mask &amp; param_flag) {				\
+		priv-&gt;conn_attrs[count] = &amp;class_device_attr_conn_##field; \
+		count++;						\
+	}								\
+} while (0)
 
 static int iscsi_session_match(struct attribute_container *cont,
 			   struct device *dev)
@@ -1173,31 +1318,30 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	if (err)
 		goto unregister_cdev;
 
-	/* setup parameters mask */
-	priv-&gt;param_mask = 0xFFFFFFFF;
-	if (!(tt-&gt;caps &amp; CAP_MULTI_R2T))
-		priv-&gt;param_mask &amp;= ~(1 &lt;&lt; ISCSI_PARAM_MAX_R2T);
-	if (!(tt-&gt;caps &amp; CAP_HDRDGST))
-		priv-&gt;param_mask &amp;= ~(1 &lt;&lt; ISCSI_PARAM_HDRDGST_EN);
-	if (!(tt-&gt;caps &amp; CAP_DATADGST))
-		priv-&gt;param_mask &amp;= ~(1 &lt;&lt; ISCSI_PARAM_DATADGST_EN);
-	if (!(tt-&gt;caps &amp; CAP_MARKERS)) {
-		priv-&gt;param_mask &amp;= ~(1 &lt;&lt; ISCSI_PARAM_IFMARKER_EN);
-		priv-&gt;param_mask &amp;= ~(1 &lt;&lt; ISCSI_PARAM_OFMARKER_EN);
-	}
-
 	/* connection parameters */
 	priv-&gt;conn_cont.ac.attrs = &amp;priv-&gt;conn_attrs[0];
 	priv-&gt;conn_cont.ac.class = &amp;iscsi_connection_class.class;
 	priv-&gt;conn_cont.ac.match = iscsi_conn_match;
 	transport_container_register(&amp;priv-&gt;conn_cont);
 
-	SETUP_CONN_RD_ATTR(max_recv_dlength, ISCSI_PARAM_MAX_RECV_DLENGTH);
-	SETUP_CONN_RD_ATTR(max_xmit_dlength, ISCSI_PARAM_MAX_XMIT_DLENGTH);
-	SETUP_CONN_RD_ATTR(header_digest, ISCSI_PARAM_HDRDGST_EN);
-	SETUP_CONN_RD_ATTR(data_digest, ISCSI_PARAM_DATADGST_EN);
-	SETUP_CONN_RD_ATTR(ifmarker, ISCSI_PARAM_IFMARKER_EN);
-	SETUP_CONN_RD_ATTR(ofmarker, ISCSI_PARAM_OFMARKER_EN);
+	SETUP_CONN_RD_ATTR(max_recv_dlength, ISCSI_MAX_RECV_DLENGTH);
+	SETUP_CONN_RD_ATTR(max_xmit_dlength, ISCSI_MAX_XMIT_DLENGTH);
+	SETUP_CONN_RD_ATTR(header_digest, ISCSI_HDRDGST_EN);
+	SETUP_CONN_RD_ATTR(data_digest, ISCSI_DATADGST_EN);
+	SETUP_CONN_RD_ATTR(ifmarker, ISCSI_IFMARKER_EN);
+	SETUP_CONN_RD_ATTR(ofmarker, ISCSI_OFMARKER_EN);
+	SETUP_CONN_RD_ATTR(address, ISCSI_CONN_ADDRESS);
+	SETUP_CONN_RD_ATTR(port, ISCSI_CONN_PORT);
+
+	if (tt-&gt;param_mask &amp; ISCSI_PERSISTENT_ADDRESS)
+		SETUP_CONN_RD_ATTR(persistent_address, ISCSI_PERSISTENT_ADDRESS);
+	else
+		SETUP_PRIV_CONN_RD_ATTR(persistent_address);
+
+	if (tt-&gt;param_mask &amp; ISCSI_PERSISTENT_PORT)
+		SETUP_CONN_RD_ATTR(persistent_port, ISCSI_PERSISTENT_PORT);
+	else
+		SETUP_PRIV_CONN_RD_ATTR(persistent_port);
 
 	BUG_ON(count &gt; ISCSI_CONN_ATTRS);
 	priv-&gt;conn_attrs[count] = NULL;
@@ -1209,14 +1353,24 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	priv-&gt;session_cont.ac.match = iscsi_session_match;
 	transport_container_register(&amp;priv-&gt;session_cont);
 
-	SETUP_SESSION_RD_ATTR(initial_r2t, ISCSI_PARAM_INITIAL_R2T_EN);
-	SETUP_SESSION_RD_ATTR(max_outstanding_r2t, ISCSI_PARAM_MAX_R2T);
-	SETUP_SESSION_RD_ATTR(immediate_data, ISCSI_PARAM_IMM_DATA_EN);
-	SETUP_SESSION_RD_ATTR(first_burst_len, ISCSI_PARAM_FIRST_BURST);
-	SETUP_SESSION_RD_ATTR(max_burst_len, ISCSI_PARAM_MAX_BURST);
-	SETUP_SESSION_RD_ATTR(data_pdu_in_order, ISCSI_PARAM_PDU_INORDER_EN);
-	SETUP_SESSION_RD_ATTR(data_seq_in_order,ISCSI_PARAM_DATASEQ_INORDER_EN)
-	SETUP_SESSION_RD_ATTR(erl, ISCSI_PARAM_ERL);
+	SETUP_SESSION_RD_ATTR(initial_r2t, ISCSI_INITIAL_R2T_EN);
+	SETUP_SESSION_RD_ATTR(max_outstanding_r2t, ISCSI_MAX_R2T);
+	SETUP_SESSION_RD_ATTR(immediate_data, ISCSI_IMM_DATA_EN);
+	SETUP_SESSION_RD_ATTR(first_burst_len, ISCSI_FIRST_BURST);
+	SETUP_SESSION_RD_ATTR(max_burst_len, ISCSI_MAX_BURST);
+	SETUP_SESSION_RD_ATTR(data_pdu_in_order, ISCSI_PDU_INORDER_EN);
+	SETUP_SESSION_RD_ATTR(data_seq_in_order, ISCSI_DATASEQ_INORDER_EN);
+	SETUP_SESSION_RD_ATTR(erl, ISCSI_ERL);
+
+	if (tt-&gt;param_mask &amp; ISCSI_TARGET_NAME)
+		SETUP_SESSION_RD_ATTR(targetname, ISCSI_TARGET_NAME);
+	else
+		SETUP_PRIV_SESSION_RD_ATTR(targetname);
+
+	if (tt-&gt;param_mask &amp; ISCSI_TPGT)
+		SETUP_SESSION_RD_ATTR(tpgt, ISCSI_TPGT);
+	else
+		SETUP_PRIV_SESSION_RD_ATTR(tpgt);
 
 	BUG_ON(count &gt; ISCSI_SESSION_ATTRS);
 	priv-&gt;session_attrs[count] = NULL;
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 933a91b1474e..2c3a89b64e71 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -86,7 +86,7 @@ struct iscsi_uevent {
 			uint32_t	sid;
 			uint32_t	cid;
 			uint32_t	param; /* enum iscsi_param */
-			uint32_t	value;
+			uint32_t	len;
 		} set_param;
 		struct msg_start_conn {
 			uint32_t	sid;
@@ -155,22 +155,54 @@ enum iscsi_err {
  * iSCSI Parameters (RFC3720)
  */
 enum iscsi_param {
-	ISCSI_PARAM_MAX_RECV_DLENGTH	= 0,
-	ISCSI_PARAM_MAX_XMIT_DLENGTH	= 1,
-	ISCSI_PARAM_HDRDGST_EN		= 2,
-	ISCSI_PARAM_DATADGST_EN		= 3,
-	ISCSI_PARAM_INITIAL_R2T_EN	= 4,
-	ISCSI_PARAM_MAX_R2T		= 5,
-	ISCSI_PARAM_IMM_DATA_EN		= 6,
-	ISCSI_PARAM_FIRST_BURST		= 7,
-	ISCSI_PARAM_MAX_BURST		= 8,
-	ISCSI_PARAM_PDU_INORDER_EN	= 9,
-	ISCSI_PARAM_DATASEQ_INORDER_EN	= 10,
-	ISCSI_PARAM_ERL			= 11,
-	ISCSI_PARAM_IFMARKER_EN		= 12,
-	ISCSI_PARAM_OFMARKER_EN		= 13,
+	/* passed in using netlink set param */
+	ISCSI_PARAM_MAX_RECV_DLENGTH,
+	ISCSI_PARAM_MAX_XMIT_DLENGTH,
+	ISCSI_PARAM_HDRDGST_EN,
+	ISCSI_PARAM_DATADGST_EN,
+	ISCSI_PARAM_INITIAL_R2T_EN,
+	ISCSI_PARAM_MAX_R2T,
+	ISCSI_PARAM_IMM_DATA_EN,
+	ISCSI_PARAM_FIRST_BURST,
+	ISCSI_PARAM_MAX_BURST,
+	ISCSI_PARAM_PDU_INORDER_EN,
+	ISCSI_PARAM_DATASEQ_INORDER_EN,
+	ISCSI_PARAM_ERL,
+	ISCSI_PARAM_IFMARKER_EN,
+	ISCSI_PARAM_OFMARKER_EN,
+	ISCSI_PARAM_TARGET_NAME,
+	ISCSI_PARAM_TPGT,
+	ISCSI_PARAM_PERSISTENT_ADDRESS,
+	ISCSI_PARAM_PERSISTENT_PORT,
+
+	/* pased in through bind conn using transport_fd */
+	ISCSI_PARAM_CONN_PORT,
+	ISCSI_PARAM_CONN_ADDRESS,
+
+	/* must always be last */
+	ISCSI_PARAM_MAX,
 };
-#define ISCSI_PARAM_MAX			14
+
+#define ISCSI_MAX_RECV_DLENGTH		(1 &lt;&lt; ISCSI_PARAM_MAX_RECV_DLENGTH)
+#define ISCSI_MAX_XMIT_DLENGTH		(1 &lt;&lt; ISCSI_PARAM_MAX_XMIT_DLENGTH)
+#define ISCSI_HDRDGST_EN		(1 &lt;&lt; ISCSI_PARAM_HDRDGST_EN)
+#define ISCSI_DATADGST_EN		(1 &lt;&lt; ISCSI_PARAM_DATADGST_EN)
+#define ISCSI_INITIAL_R2T_EN		(1 &lt;&lt; ISCSI_PARAM_INITIAL_R2T_EN)
+#define ISCSI_MAX_R2T			(1 &lt;&lt; ISCSI_PARAM_MAX_R2T)
+#define ISCSI_IMM_DATA_EN		(1 &lt;&lt; ISCSI_PARAM_IMM_DATA_EN)
+#define ISCSI_FIRST_BURST		(1 &lt;&lt; ISCSI_PARAM_FIRST_BURST)
+#define ISCSI_MAX_BURST			(1 &lt;&lt; ISCSI_PARAM_MAX_BURST)
+#define ISCSI_PDU_INORDER_EN		(1 &lt;&lt; ISCSI_PARAM_PDU_INORDER_EN)
+#define ISCSI_DATASEQ_INORDER_EN	(1 &lt;&lt; ISCSI_PARAM_DATASEQ_INORDER_EN)
+#define ISCSI_ERL			(1 &lt;&lt; ISCSI_PARAM_ERL)
+#define ISCSI_IFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_IFMARKER_EN)
+#define ISCSI_OFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_OFMARKER_EN)
+#define ISCSI_TARGET_NAME		(1 &lt;&lt; ISCSI_PARAM_TARGET_NAME)
+#define ISCSI_TPGT			(1 &lt;&lt; ISCSI_PARAM_TPGT)
+#define ISCSI_PERSISTENT_ADDRESS	(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_ADDRESS)
+#define ISCSI_PERSISTENT_PORT		(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_PORT)
+#define ISCSI_CONN_PORT			(1 &lt;&lt; ISCSI_PARAM_CONN_PORT)
+#define ISCSI_CONN_ADDRESS		(1 &lt;&lt; ISCSI_PARAM_CONN_ADDRESS)
 
 #define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
 #define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 631463cd4892..4b200645c84b 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -53,11 +53,11 @@ struct iscsi_transport {
 	struct module *owner;
 	char *name;
 	unsigned int caps;
+	/* LLD sets this to indicate what values it can export to sysfs */
+	unsigned int param_mask;
 	struct scsi_host_template *host_template;
 	/* LLD session/scsi_host data size */
 	int hostdata_size;
-	/* LLD iscsi_host data size */
-	int ihostdata_size;
 	/* LLD connection data size */
 	int conndata_size;
 	/* LLD session data size */
@@ -79,10 +79,13 @@ struct iscsi_transport {
 	int (*set_param) (struct iscsi_cls_conn *conn, enum iscsi_param param,
 			  uint32_t value);
 	int (*get_conn_param) (struct iscsi_cls_conn *conn,
-			       enum iscsi_param param,
-			       uint32_t *value);
+			       enum iscsi_param param, uint32_t *value);
 	int (*get_session_param) (struct iscsi_cls_session *session,
 				  enum iscsi_param param, uint32_t *value);
+	int (*get_conn_str_param) (struct iscsi_cls_conn *conn,
+				   enum iscsi_param param, char *buf);
+	int (*get_session_str_param) (struct iscsi_cls_session *session,
+				      enum iscsi_param param, char *buf);
 	int (*send_pdu) (struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 			 char *data, uint32_t data_size);
 	void (*get_stats) (struct iscsi_cls_conn *conn,
@@ -107,6 +110,14 @@ struct iscsi_cls_conn {
 	void *dd_data;			/* LLD private data */
 	struct iscsi_transport *transport;
 	uint32_t cid;			/* connection id */
+
+	/* portal/group values we got during discovery */
+	char *persistent_address;
+	int persistent_port;
+	/* portal/group values we are currently using */
+	char *address;
+	int port;
+
 	int active;			/* must be accessed with the connlock */
 	struct device dev;		/* sysfs transport/container device */
 	struct mempool_zone *z_error;
@@ -120,6 +131,11 @@ struct iscsi_cls_conn {
 struct iscsi_cls_session {
 	struct list_head sess_list;		/* item in session_list */
 	struct iscsi_transport *transport;
+
+	/* iSCSI values used as unique id by userspace. */
+	char *targetname;
+	int tpgt;
+
 	int sid;				/* session id */
 	void *dd_data;				/* LLD private data */
 	struct device dev;	/* sysfs transport/container device */</pre>
    <div class="pagination">
        <a href='5_39.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><span>[40]</span><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_41.html'>Next&gt;&gt;</a>
    <div>
</body>
