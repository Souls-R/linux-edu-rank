<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_75.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><span>[76]</span><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_77.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2023c610dc54a4f4130b0494309a9bd668ca3df8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 30 15:27:18 2009 -0400

    Driver core: add new device to bus's list before probing
    
    This patch (as1271) affects when new devices get linked into their
    bus's list of devices.  Currently this happens after probing, and it
    doesn't happen at all if probing fails.  Clearly this is wrong,
    because at that point quite a few symbolic links have already been
    created in sysfs.  We are committed to adding the device, so it should
    be linked into the bus's list regardless.
    
    In addition, this needs to happen before the uevent announcing the new
    device gets issued.  Otherwise user programs might try to access the
    device before it has been added to the bus.
    
    To fix both these problems, the patch moves the call to
    klist_add_tail() forward from bus_attach_device() to bus_add_device().
    Since bus_attach_device() now does nothing but probe for drivers, it
    has been renamed to bus_probe_device().  And lastly, the kerneldoc is
    updated.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/base.h b/drivers/base/base.h
index b528145a078f..1e52c125f437 100644
--- a/drivers/base/base.h
+++ b/drivers/base/base.h
@@ -104,7 +104,7 @@ extern int system_bus_init(void);
 extern int cpu_dev_init(void);
 
 extern int bus_add_device(struct device *dev);
-extern void bus_attach_device(struct device *dev);
+extern void bus_probe_device(struct device *dev);
 extern void bus_remove_device(struct device *dev);
 
 extern int bus_add_driver(struct device_driver *drv);
diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 4b04a15146d7..973bf2ad4e0d 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -459,8 +459,9 @@ static inline void remove_deprecated_bus_links(struct device *dev) { }
  * bus_add_device - add device to bus
  * @dev: device being added
  *
+ * - Add device's bus attributes.
+ * - Create links to device's bus.
  * - Add the device to its bus's list of devices.
- * - Create link to device's bus.
  */
 int bus_add_device(struct device *dev)
 {
@@ -483,6 +484,7 @@ int bus_add_device(struct device *dev)
 		error = make_deprecated_bus_links(dev);
 		if (error)
 			goto out_deprecated;
+		klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus, &amp;bus-&gt;p-&gt;klist_devices);
 	}
 	return 0;
 
@@ -498,24 +500,19 @@ int bus_add_device(struct device *dev)
 }
 
 /**
- * bus_attach_device - add device to bus
- * @dev: device tried to attach to a driver
+ * bus_probe_device - probe drivers for a new device
+ * @dev: device to probe
  *
- * - Add device to bus's list of devices.
- * - Try to attach to driver.
+ * - Automatically probe for a driver if the bus allows it.
  */
-void bus_attach_device(struct device *dev)
+void bus_probe_device(struct device *dev)
 {
 	struct bus_type *bus = dev-&gt;bus;
-	int ret = 0;
+	int ret;
 
-	if (bus) {
-		if (bus-&gt;p-&gt;drivers_autoprobe)
-			ret = device_attach(dev);
+	if (bus &amp;&amp; bus-&gt;p-&gt;drivers_autoprobe) {
+		ret = device_attach(dev);
 		WARN_ON(ret &lt; 0);
-		if (ret &gt;= 0)
-			klist_add_tail(&amp;dev-&gt;p-&gt;knode_bus,
-				       &amp;bus-&gt;p-&gt;klist_devices);
 	}
 }
 
diff --git a/drivers/base/core.c b/drivers/base/core.c
index 7ecb1938e590..c34774d0b9d3 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -945,7 +945,7 @@ int device_add(struct device *dev)
 					     BUS_NOTIFY_ADD_DEVICE, dev);
 
 	kobject_uevent(&amp;dev-&gt;kobj, KOBJ_ADD);
-	bus_attach_device(dev);
+	bus_probe_device(dev);
 	if (parent)
 		klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,
 			       &amp;parent-&gt;p-&gt;klist_children);</pre><hr><pre>commit ef4638f955f2c4a667c8af20769d03f5ed3781ca
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 31 10:41:40 2009 -0400

    USB: EHCI: fix counting of transaction error retries
    
    This patch (as1274) simplifies the counting of transaction-error
    retries.  Now we will count up from 0 to QH_XACTERR_MAX instead of
    down from QH_XACTERR_MAX to 0.
    
    The patch also fixes a small bug: qh-&gt;xacterr was not getting
    initialized for interrupt endpoints.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Matthijs Kooijman &lt;matthijs@stdin.nl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index b27380505576..7673554fa64d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -375,12 +375,11 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 				 */
 				if ((token &amp; QTD_STS_XACT) &amp;&amp;
 						QTD_CERR(token) == 0 &amp;&amp;
-						--qh-&gt;xacterrs &gt; 0 &amp;&amp;
+						++qh-&gt;xacterrs &lt; QH_XACTERR_MAX &amp;&amp;
 						!urb-&gt;unlinked) {
 					ehci_dbg(ehci,
 	"detected XactErr len %zu/%zu retry %d\n",
-	qtd-&gt;length - QTD_LENGTH(token), qtd-&gt;length,
-	QH_XACTERR_MAX - qh-&gt;xacterrs);
+	qtd-&gt;length - QTD_LENGTH(token), qtd-&gt;length, qh-&gt;xacterrs);
 
 					/* reset the token in the qtd and the
 					 * qh overlay (which still contains
@@ -494,7 +493,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		last = qtd;
 
 		/* reinit the xacterr counter for the next qtd */
-		qh-&gt;xacterrs = QH_XACTERR_MAX;
+		qh-&gt;xacterrs = 0;
 	}
 
 	/* last urb's completion might still need calling */
@@ -941,7 +940,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;hw_next = dma;
 
 	qh_get(qh);
-	qh-&gt;xacterrs = QH_XACTERR_MAX;
+	qh-&gt;xacterrs = 0;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
 }
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 74f7f83b29ad..edd61ee90323 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -542,6 +542,7 @@ static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		}
 	}
 	qh-&gt;qh_state = QH_STATE_LINKED;
+	qh-&gt;xacterrs = 0;
 	qh_get (qh);
 
 	/* update per-qh bandwidth for usbfs */</pre><hr><pre>commit 7a0f0d951273eee889c2441846842348ebc00a2a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 31 10:40:22 2009 -0400

    USB: EHCI: fix two new bugs related to Clear-TT-Buffer
    
    This patch (as1273) fixes two(!) bugs introduced by the new
    Clear-TT-Buffer implementation in ehci-hcd.
    
            It is now possible for an idle QH to have some URBs on its
            queue -- this will happen if a Clear-TT-Buffer is pending for
            the QH's endpoint.  Consequently we should not issue a warning
            when someone tries to unlink an URB from an idle QH; instead
            we should process the request immediately.
    
            The refcounts for QHs could get messed up, because
            submit_async() would increment the refcount when calling
            qh_link_async() and qh_link_async() would then refuse to link
            the QH into the schedule if a Clear-TT-Buffer was pending.
            Instead we should increment the refcount only when the QH
            actually is added to the schedule.  The current code tries to
            be clever by leaving the refcount alone if an unlink is
            immediately followed by a relink; the patch changes this to an
            unconditional decrement and increment (although they occur in
            the opposite order).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Tested-by: Manuel Lauss &lt;manuel.lauss@gmail.com&gt;
    Tested-by: Matthijs Kooijman &lt;matthijs@stdin.nl&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7d03549c3339..11c627ce6022 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -903,7 +903,8 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			/* already started */
 			break;
 		case QH_STATE_IDLE:
-			WARN_ON(1);
+			/* QH might be waiting for a Clear-TT-Buffer */
+			qh_completions(ehci, qh);
 			break;
 		}
 		break;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 9a1384747f3b..b27380505576 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -940,6 +940,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;qh_next.qh = qh;
 	head-&gt;hw_next = dma;
 
+	qh_get(qh);
 	qh-&gt;xacterrs = QH_XACTERR_MAX;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
@@ -1080,7 +1081,7 @@ submit_async (
 	 * the HC and TT handle it when the TT has a buffer ready.
 	 */
 	if (likely (qh-&gt;qh_state == QH_STATE_IDLE))
-		qh_link_async (ehci, qh_get (qh));
+		qh_link_async(ehci, qh);
  done:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	if (unlikely (qh == NULL))
@@ -1115,8 +1116,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 			&amp;&amp; HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))
 		qh_link_async (ehci, qh);
 	else {
-		qh_put (qh);		// refcount from async list
-
 		/* it's not free to turn the async schedule on/off; leave it
 		 * active but idle for a while once it empties.
 		 */
@@ -1124,6 +1123,7 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 				&amp;&amp; ehci-&gt;async-&gt;qh_next.qh == NULL)
 			timer_action (ehci, TIMER_ASYNC_OFF);
 	}
+	qh_put(qh);			/* refcount from async list */
 
 	if (next) {
 		ehci-&gt;reclaim = NULL;</pre><hr><pre>commit 01105a246345f011fde64d24a601090b646e9e4c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 30 15:28:14 2009 -0400

    USB: usbfs: fix -ENOENT error code to be -ENODEV
    
    This patch (as1272) changes the error code returned when an open call
    for a USB device node fails to locate the corresponding device.  The
    appropriate error code is -ENODEV, not -ENOENT.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e192fa05f8a1..4247eccf858c 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -595,7 +595,7 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	if (!ps)
 		goto out;
 
-	ret = -ENOENT;
+	ret = -ENODEV;
 
 	/* usbdev device-node */
 	if (imajor(inode) == USB_DEVICE_MAJOR)</pre><hr><pre>commit 0f157ef3a1284f41d9804ecb87fdcc8ea946b9fa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 28 11:56:17 2009 -0400

    USB: usbtest: no need for USB_DEVICEFS
    
    THis patch (as1270) allows the usbtest module to be built even when
    USB_DEVICEFS isn't configured.  Tests can be performed without
    USB_DEVICEFS, using the /dev/bus/usb/*/* device files.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/misc/Kconfig b/drivers/usb/misc/Kconfig
index a68d91a11bee..abe3aa67ed00 100644
--- a/drivers/usb/misc/Kconfig
+++ b/drivers/usb/misc/Kconfig
@@ -220,7 +220,7 @@ config USB_IOWARRIOR
 
 config USB_TEST
 	tristate "USB testing driver"
-	depends on USB &amp;&amp; USB_DEVICEFS
+	depends on USB
 	help
 	  This driver is for testing host controller software.  It is used
 	  with specialized device firmware for regression and stress testing,</pre><hr><pre>commit 9180135bc80ab11199d482b6111e23f74d65af4a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 11:04:54 2009 -0400

    USB: handle zero-length usbfs submissions correctly
    
    This patch (as1262) fixes a bug in usbfs: It refuses to accept
    zero-length transfers, and it insists that the buffer pointer be valid
    even if there is no data being transferred.
    
    The patch also consolidates a bunch of repetitive access_ok() checks
    into a single check, which incidentally fixes the lack of such a check
    for Isochronous URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 46ca2af5ef1c..38b8bce782d6 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -995,7 +995,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 				USBDEVFS_URB_ZERO_PACKET |
 				USBDEVFS_URB_NO_INTERRUPT))
 		return -EINVAL;
-	if (!uurb-&gt;buffer)
+	if (uurb-&gt;buffer_length &gt; 0 &amp;&amp; !uurb-&gt;buffer)
 		return -EINVAL;
 	if (!(uurb-&gt;type == USBDEVFS_URB_TYPE_CONTROL &amp;&amp;
 	    (uurb-&gt;endpoint &amp; ~USB_ENDPOINT_DIR_MASK) == 0)) {
@@ -1051,11 +1051,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			is_in = 0;
 			uurb-&gt;endpoint &amp;= ~USB_DIR_IN;
 		}
-		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
-				uurb-&gt;buffer, uurb-&gt;buffer_length)) {
-			kfree(dr);
-			return -EFAULT;
-		}
 		snoop(&amp;ps-&gt;dev-&gt;dev, "control urb: bRequest=%02x "
 			"bRrequestType=%02x wValue=%04x "
 			"wIndex=%04x wLength=%04x\n",
@@ -1075,9 +1070,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		uurb-&gt;number_of_packets = 0;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
-				uurb-&gt;buffer, uurb-&gt;buffer_length))
-			return -EFAULT;
 		snoop(&amp;ps-&gt;dev-&gt;dev, "bulk urb\n");
 		break;
 
@@ -1119,28 +1111,35 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EINVAL;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		if (!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
-				uurb-&gt;buffer, uurb-&gt;buffer_length))
-			return -EFAULT;
 		snoop(&amp;ps-&gt;dev-&gt;dev, "interrupt urb\n");
 		break;
 
 	default:
 		return -EINVAL;
 	}
-	as = alloc_async(uurb-&gt;number_of_packets);
-	if (!as) {
+	if (uurb-&gt;buffer_length &gt; 0 &amp;&amp;
+			!access_ok(is_in ? VERIFY_WRITE : VERIFY_READ,
+				uurb-&gt;buffer, uurb-&gt;buffer_length)) {
 		kfree(isopkt);
 		kfree(dr);
-		return -ENOMEM;
+		return -EFAULT;
 	}
-	as-&gt;urb-&gt;transfer_buffer = kmalloc(uurb-&gt;buffer_length, GFP_KERNEL);
-	if (!as-&gt;urb-&gt;transfer_buffer) {
+	as = alloc_async(uurb-&gt;number_of_packets);
+	if (!as) {
 		kfree(isopkt);
 		kfree(dr);
-		free_async(as);
 		return -ENOMEM;
 	}
+	if (uurb-&gt;buffer_length &gt; 0) {
+		as-&gt;urb-&gt;transfer_buffer = kmalloc(uurb-&gt;buffer_length,
+				GFP_KERNEL);
+		if (!as-&gt;urb-&gt;transfer_buffer) {
+			kfree(isopkt);
+			kfree(dr);
+			free_async(as);
+			return -ENOMEM;
+		}
+	}
 	as-&gt;urb-&gt;dev = ps-&gt;dev;
 	as-&gt;urb-&gt;pipe = (uurb-&gt;type &lt;&lt; 30) |
 			__create_pipe(ps-&gt;dev, uurb-&gt;endpoint &amp; 0xf) |
@@ -1182,7 +1181,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	kfree(isopkt);
 	as-&gt;ps = ps;
 	as-&gt;userurb = arg;
-	if (uurb-&gt;endpoint &amp; USB_DIR_IN)
+	if (is_in &amp;&amp; uurb-&gt;buffer_length &gt; 0)
 		as-&gt;userbuffer = uurb-&gt;buffer;
 	else
 		as-&gt;userbuffer = NULL;
@@ -1192,9 +1191,9 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	as-&gt;uid = cred-&gt;uid;
 	as-&gt;euid = cred-&gt;euid;
 	security_task_getsecid(current, &amp;as-&gt;secid);
-	if (!is_in) {
+	if (!is_in &amp;&amp; uurb-&gt;buffer_length &gt; 0) {
 		if (copy_from_user(as-&gt;urb-&gt;transfer_buffer, uurb-&gt;buffer,
-				as-&gt;urb-&gt;transfer_buffer_length)) {
+				uurb-&gt;buffer_length)) {
 			free_async(as);
 			return -EFAULT;
 		}</pre><hr><pre>commit ec6d67e39f5638c792eb7490bf32586ccb9d8005
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 14:34:59 2009 -0400

    USB: EHCI: report actual_length for iso transfers
    
    This patch (as1259b) makes ehci-hcd return the total number of bytes
    transferred in urb-&gt;actual_length for Isochronous transfers.
    Until now, the actual_length value was unaccountably left at 0.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 9d1babc7ff65..74f7f83b29ad 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1619,11 +1619,14 @@ itd_complete (
 				desc-&gt;status = -EPROTO;
 
 			/* HC need not update length with this error */
-			if (!(t &amp; EHCI_ISOC_BABBLE))
-				desc-&gt;actual_length = EHCI_ITD_LENGTH (t);
+			if (!(t &amp; EHCI_ISOC_BABBLE)) {
+				desc-&gt;actual_length = EHCI_ITD_LENGTH(t);
+				urb-&gt;actual_length += desc-&gt;actual_length;
+			}
 		} else if (likely ((t &amp; EHCI_ISOC_ACTIVE) == 0)) {
 			desc-&gt;status = 0;
-			desc-&gt;actual_length = EHCI_ITD_LENGTH (t);
+			desc-&gt;actual_length = EHCI_ITD_LENGTH(t);
+			urb-&gt;actual_length += desc-&gt;actual_length;
 		} else {
 			/* URB was too late */
 			desc-&gt;status = -EXDEV;
@@ -2014,7 +2017,8 @@ sitd_complete (
 			desc-&gt;status = -EPROTO;
 	} else {
 		desc-&gt;status = 0;
-		desc-&gt;actual_length = desc-&gt;length - SITD_LENGTH (t);
+		desc-&gt;actual_length = desc-&gt;length - SITD_LENGTH(t);
+		urb-&gt;actual_length += desc-&gt;actual_length;
 	}
 	stream-&gt;depth -= stream-&gt;interval &lt;&lt; 3;
 </pre><hr><pre>commit f092c240494f2d807401d93f95f683909b90af96
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 9 12:58:43 2009 -0400

    USB: option: remove unnecessary and erroneous code
    
    This patch (as1264) removes a bunch of unnecessary and erroneous stuff
    from the option USB-serial driver.  Clearly there's no need to verify
    that the device pointer stored in the URBs is right or to store the
    same pointer over again.  After all, the pointer can't change once it
    has been set up.
    
    There's also no need to call usb_clear_halt for the IN endpoint
    multiple times -- in fact, doing so is an error since every time after
    the first there will be active URBs queued for that endpoint.  Since
    the Clear-Halts don't appear to be needed at all, the patch simply
    removes them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 4526064752fa..98262dd552bb 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -748,7 +748,6 @@ static int option_write(struct tty_struct *tty, struct usb_serial_port *port,
 		memcpy(this_urb-&gt;transfer_buffer, buf, todo);
 		this_urb-&gt;transfer_buffer_length = todo;
 
-		this_urb-&gt;dev = port-&gt;serial-&gt;dev;
 		err = usb_submit_urb(this_urb, GFP_ATOMIC);
 		if (err) {
 			dbg("usb_submit_urb %p (write bulk) failed "
@@ -876,7 +875,6 @@ static void option_instat_callback(struct urb *urb)
 
 	/* Resubmit urb so we continue receiving IRQ data */
 	if (status != -ESHUTDOWN &amp;&amp; status != -ENOENT) {
-		urb-&gt;dev = serial-&gt;dev;
 		err = usb_submit_urb(urb, GFP_ATOMIC);
 		if (err)
 			dbg("%s: resubmit intr urb failed. (%d)",
@@ -937,23 +935,11 @@ static int option_open(struct tty_struct *tty,
 
 	dbg("%s", __func__);
 
-	/* Reset low level data toggle and start reading from endpoints */
+	/* Start reading from the IN endpoint */
 	for (i = 0; i &lt; N_IN_URB; i++) {
 		urb = portdata-&gt;in_urbs[i];
 		if (!urb)
 			continue;
-		if (urb-&gt;dev != serial-&gt;dev) {
-			dbg("%s: dev %p != %p", __func__,
-				urb-&gt;dev, serial-&gt;dev);
-			continue;
-		}
-
-		/*
-		 * make sure endpoint data toggle is synchronized with the
-		 * device
-		 */
-		usb_clear_halt(urb-&gt;dev, urb-&gt;pipe);
-
 		err = usb_submit_urb(urb, GFP_KERNEL);
 		if (err) {
 			dbg("%s: submit urb %d failed (%d) %d",
@@ -962,16 +948,6 @@ static int option_open(struct tty_struct *tty,
 		}
 	}
 
-	/* Reset low level data toggle on out endpoints */
-	for (i = 0; i &lt; N_OUT_URB; i++) {
-		urb = portdata-&gt;out_urbs[i];
-		if (!urb)
-			continue;
-		urb-&gt;dev = serial-&gt;dev;
-		/* usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
-				usb_pipeout(urb-&gt;pipe), 0); */
-	}
-
 	option_send_setup(port);
 
 	return 0;
@@ -1234,7 +1210,6 @@ static int option_resume(struct usb_serial *serial)
 			dbg("%s: No interrupt URB for port %d\n", __func__, i);
 			continue;
 		}
-		port-&gt;interrupt_in_urb-&gt;dev = serial-&gt;dev;
 		err = usb_submit_urb(port-&gt;interrupt_in_urb, GFP_NOIO);
 		dbg("Submitted interrupt URB for port %d (result %d)", i, err);
 		if (err &lt; 0) {</pre><hr><pre>commit 4d2fae8b3597bc787f1f1c06637ce5ab8187e5a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 9 12:59:57 2009 -0400

    USB: cypress_m8: remove invalid Clear-Halt
    
    This patch (as1265) removes an erroneous call to usb_clear_halt from
    the cypress_m8 driver.  The call isn't valid because it is made from
    interrupt context whereas usb_clear_halt is a blocking routine.
    
    Presumably the code has never been executed; if it did it would cause
    an oops.  So instead treat -EPIPE like any other sort of unexplained
    error.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/cypress_m8.c b/drivers/usb/serial/cypress_m8.c
index 9734085fd2fe..59adfe123110 100644
--- a/drivers/usb/serial/cypress_m8.c
+++ b/drivers/usb/serial/cypress_m8.c
@@ -1228,8 +1228,8 @@ static void cypress_read_int_callback(struct urb *urb)
 		/* precursor to disconnect so just go away */
 		return;
 	case -EPIPE:
-		usb_clear_halt(port-&gt;serial-&gt;dev, 0x81);
-		break;
+		/* Can't call usb_clear_halt while in_interrupt */
+		/* FALLS THROUGH */
 	default:
 		/* something ugly is going on... */
 		dev_err(&amp;urb-&gt;dev-&gt;dev,</pre><hr><pre>commit 7bae0a070db4bc2761dd9515f450cdfa3f3f248c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 7 09:50:14 2009 -0400

    USB: Sierra: fix oops upon device close
    
    This patch (as1263) fixes a mixup that occurred when conflicting
    patches for the sierra driver were merged incorrectly.  The former
    sierra_shutdown routine should have been become sierra_release, not
    sierra_disconnect.
    
    The symptom this fixes is an oops when the device file is closed after
    a Sierra device has been unplugged (Bugzilla #13675).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Peter Naulls &lt;peter@mushroomnetworks.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index 032f7aeb40a4..5062815baed0 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -814,7 +814,7 @@ static int sierra_startup(struct usb_serial *serial)
 	return 0;
 }
 
-static void sierra_disconnect(struct usb_serial *serial)
+static void sierra_release(struct usb_serial *serial)
 {
 	int i;
 	struct usb_serial_port *port;
@@ -830,7 +830,6 @@ static void sierra_disconnect(struct usb_serial *serial)
 		if (!portdata)
 			continue;
 		kfree(portdata);
-		usb_set_serial_port_data(port, NULL);
 	}
 }
 
@@ -853,7 +852,7 @@ static struct usb_serial_driver sierra_device = {
 	.tiocmget          = sierra_tiocmget,
 	.tiocmset          = sierra_tiocmset,
 	.attach            = sierra_startup,
-	.disconnect        = sierra_disconnect,
+	.release           = sierra_release,
 	.read_int_callback = sierra_instat_callback,
 };
 </pre>
    <div class="pagination">
        <a href='2_75.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><span>[76]</span><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_77.html'>Next&gt;&gt;</a>
    <div>
</body>
