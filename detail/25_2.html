<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Pennsylvania</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Pennsylvania</h1>
    <div class="pagination">
        <a href='25.html'>&lt;&lt;Prev</a><a href='25.html'>1</a><span>[2]</span><a href='25_3.html'>3</a><a href='25_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ab3f4980ec62b907e697ff0934a8e1d076a6d46d
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Tue May 4 14:20:16 2010 -0400

    HID: ntrig: add filtering module parameters
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 2c08365f3720..b6b0caeeac58 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -25,11 +25,32 @@
 #define NTRIG_DUPLICATE_USAGES	0x001
 
 static unsigned int min_width;
+module_param(min_width, uint, 0644);
+MODULE_PARM_DESC(min_width, "Minimum touch contact width to accept.");
+
 static unsigned int min_height;
+module_param(min_height, uint, 0644);
+MODULE_PARM_DESC(min_height, "Minimum touch contact height to accept.");
+
 static unsigned int activate_slack = 1;
+module_param(activate_slack, uint, 0644);
+MODULE_PARM_DESC(activate_slack, "Number of touch frames to ignore at "
+		 "the start of touch input.");
+
 static unsigned int deactivate_slack = 4;
+module_param(deactivate_slack, uint, 0644);
+MODULE_PARM_DESC(deactivate_slack, "Number of empty frames to ignore before "
+		 "deactivating touch.");
+
 static unsigned int activation_width = 64;
+module_param(activation_width, uint, 0644);
+MODULE_PARM_DESC(activation_width, "Width threshold to immediately start "
+		 "processing touch events.");
+
 static unsigned int activation_height = 32;
+module_param(activation_height, uint, 0644);
+MODULE_PARM_DESC(activation_height, "Height threshold to immediately start "
+		 "processing touch events.");
 
 struct ntrig_data {
 	/* Incoming raw values for a single contact */</pre><hr><pre>commit eab32f5f65574c7484ed883c2245758f5a98878c
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Tue May 4 14:20:17 2010 -0400

    HID: ntrig: add sysfs access to filter parameters
    
    This should make it a little more convenient to tweak the filtering
    parameters on the fly.  Also unlike load-time parameters, this provides
    independent tuning for each device conntected.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 227d01527c6a..2c08365f3720 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -68,6 +68,287 @@ struct ntrig_data {
 	__u16 sensor_physical_height;
 };
 
+
+static ssize_t show_phys_width(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;sensor_physical_width);
+}
+
+static DEVICE_ATTR(sensor_physical_width, S_IRUGO, show_phys_width, NULL);
+
+static ssize_t show_phys_height(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;sensor_physical_height);
+}
+
+static DEVICE_ATTR(sensor_physical_height, S_IRUGO, show_phys_height, NULL);
+
+static ssize_t show_log_width(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;sensor_logical_width);
+}
+
+static DEVICE_ATTR(sensor_logical_width, S_IRUGO, show_log_width, NULL);
+
+static ssize_t show_log_height(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;sensor_logical_height);
+}
+
+static DEVICE_ATTR(sensor_logical_height, S_IRUGO, show_log_height, NULL);
+
+static ssize_t show_min_width(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;min_width *
+				    nd-&gt;sensor_physical_width /
+				    nd-&gt;sensor_logical_width);
+}
+
+static ssize_t set_min_width(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	if (val &gt; nd-&gt;sensor_physical_width)
+		return -EINVAL;
+
+	nd-&gt;min_width = val * nd-&gt;sensor_logical_width /
+			      nd-&gt;sensor_physical_width;
+
+	return count;
+}
+
+static DEVICE_ATTR(min_width, S_IWUSR | S_IRUGO, show_min_width, set_min_width);
+
+static ssize_t show_min_height(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;min_height *
+				    nd-&gt;sensor_physical_height /
+				    nd-&gt;sensor_logical_height);
+}
+
+static ssize_t set_min_height(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	if (val &gt; nd-&gt;sensor_physical_height)
+		return -EINVAL;
+
+	nd-&gt;min_height = val * nd-&gt;sensor_logical_height /
+			       nd-&gt;sensor_physical_height;
+
+	return count;
+}
+
+static DEVICE_ATTR(min_height, S_IWUSR | S_IRUGO, show_min_height,
+		   set_min_height);
+
+static ssize_t show_activate_slack(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;activate_slack);
+}
+
+static ssize_t set_activate_slack(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	if (val &gt; 0x7f)
+		return -EINVAL;
+
+	nd-&gt;activate_slack = val;
+
+	return count;
+}
+
+static DEVICE_ATTR(activate_slack, S_IWUSR | S_IRUGO, show_activate_slack,
+		   set_activate_slack);
+
+static ssize_t show_activation_width(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;activation_width *
+				    nd-&gt;sensor_physical_width /
+				    nd-&gt;sensor_logical_width);
+}
+
+static ssize_t set_activation_width(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	if (val &gt; nd-&gt;sensor_physical_width)
+		return -EINVAL;
+
+	nd-&gt;activation_width = val * nd-&gt;sensor_logical_width /
+				     nd-&gt;sensor_physical_width;
+
+	return count;
+}
+
+static DEVICE_ATTR(activation_width, S_IWUSR | S_IRUGO, show_activation_width,
+		   set_activation_width);
+
+static ssize_t show_activation_height(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", nd-&gt;activation_height *
+				    nd-&gt;sensor_physical_height /
+				    nd-&gt;sensor_logical_height);
+}
+
+static ssize_t set_activation_height(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	if (val &gt; nd-&gt;sensor_physical_height)
+		return -EINVAL;
+
+	nd-&gt;activation_height = val * nd-&gt;sensor_logical_height /
+				      nd-&gt;sensor_physical_height;
+
+	return count;
+}
+
+static DEVICE_ATTR(activation_height, S_IWUSR | S_IRUGO,
+		   show_activation_height, set_activation_height);
+
+static ssize_t show_deactivate_slack(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	return sprintf(buf, "%d\n", -nd-&gt;deactivate_slack);
+}
+
+static ssize_t set_deactivate_slack(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t count)
+{
+	struct hid_device *hdev = container_of(dev, struct hid_device, dev);
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
+	unsigned long val;
+
+	if (strict_strtoul(buf, 0, &amp;val))
+		return -EINVAL;
+
+	/*
+	 * No more than 8 terminal frames have been observed so far
+	 * and higher slack is highly likely to leave the single
+	 * touch emulation stuck down.
+	 */
+	if (val &gt; 7)
+		return -EINVAL;
+
+	nd-&gt;deactivate_slack = -val;
+
+	return count;
+}
+
+static DEVICE_ATTR(deactivate_slack, S_IWUSR | S_IRUGO, show_deactivate_slack,
+		   set_deactivate_slack);
+
+static struct attribute *sysfs_attrs[] = {
+	&amp;dev_attr_sensor_physical_width.attr,
+	&amp;dev_attr_sensor_physical_height.attr,
+	&amp;dev_attr_sensor_logical_width.attr,
+	&amp;dev_attr_sensor_logical_height.attr,
+	&amp;dev_attr_min_height.attr,
+	&amp;dev_attr_min_width.attr,
+	&amp;dev_attr_activate_slack.attr,
+	&amp;dev_attr_activation_width.attr,
+	&amp;dev_attr_activation_height.attr,
+	&amp;dev_attr_deactivate_slack.attr,
+	NULL
+};
+
+static struct attribute_group ntrig_attribute_group = {
+	.attrs = sysfs_attrs
+};
+
 /*
  * this driver is aimed at two firmware versions in circulation:
  *  - dual pen/finger single touch
@@ -546,6 +827,8 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	if (report)
 		usbhid_submit_report(hdev, report, USB_DIR_OUT);
 
+	ret = sysfs_create_group(&amp;hdev-&gt;dev.kobj,
+			&amp;ntrig_attribute_group);
 
 	return 0;
 err_free:
@@ -555,6 +838,8 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 
 static void ntrig_remove(struct hid_device *hdev)
 {
+	sysfs_remove_group(&amp;hdev-&gt;dev.kobj,
+			&amp;ntrig_attribute_group);
 	hid_hw_stop(hdev);
 	kfree(hid_get_drvdata(hdev));
 }</pre><hr><pre>commit 369db2a6008e8fc3cf5006fa8aab71bd58adfc1f
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Tue May 4 14:20:15 2010 -0400

    HID: ntrig: add sensitivity and responsiveness support
    
    The old rejection size thresholds were too high for the 12" devices.
    Larger surfaces like the Dell Studio17 exacerbated the problem since
    contact size is reported on the same logical scale, making a contact
    look smaller to the larger screen.
    
    Since we have observed erroneous ghost events from these devices we
    still need to filter the incoming stream.
    
    The prior size threshold filter is still in place, though with
    defaults set to leave it off.
    
    This patch adds the two new classes of filters, those that reject
    live frames before activation, and those that reject empty frames
    until deactivation.  These filters are expressed in terms of a
    simple state machine for clarity (I hope).
    
    The activation filter has two components, slack and size, events
    are discarded until either is satisfied.  Slack is defined as
    the number of seemingly good contacts to read before accepting the
    stream as valid (if the threshold is reached in the middle of a frame
    the remainder of that frame is still discarded).
    
    The deactivation filter discards empty frames until hitting a
    deactivate slack.  This time measured in frames.  N-Trig devices
    emit 5-8 (observed so far) empty frames at the end of multitouch
    activity.  Ignoring the first few enables us to safely and gracefully
    handle erroneous empty frames, thus preventing a change in the tool
    state which would otherwise result in things like broken lines or
    dragged objects being dropped in bad places.
    
    Also, now that devices with different logical densities have
    been observed, the aforementioned sizes are scaled from physical
    to logical scales once those scales are identified.  Hopefully this
    should mean that a given threshold value means the same thing across
    differing devices.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 4777bbfa1cc2..227d01527c6a 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -24,6 +24,13 @@
 
 #define NTRIG_DUPLICATE_USAGES	0x001
 
+static unsigned int min_width;
+static unsigned int min_height;
+static unsigned int activate_slack = 1;
+static unsigned int deactivate_slack = 4;
+static unsigned int activation_width = 64;
+static unsigned int activation_height = 32;
+
 struct ntrig_data {
 	/* Incoming raw values for a single contact */
 	__u16 x, y, w, h;
@@ -37,6 +44,28 @@ struct ntrig_data {
 
 	__u8 mt_footer[4];
 	__u8 mt_foot_count;
+
+	/* The current activation state. */
+	__s8 act_state;
+
+	/* Empty frames to ignore before recognizing the end of activity */
+	__s8 deactivate_slack;
+
+	/* Frames to ignore before acknowledging the start of activity */
+	__s8 activate_slack;
+
+	/* Minimum size contact to accept */
+	__u16 min_width;
+	__u16 min_height;
+
+	/* Threshold to override activation slack */
+	__u16 activation_width;
+	__u16 activation_height;
+
+	__u16 sensor_logical_width;
+	__u16 sensor_logical_height;
+	__u16 sensor_physical_width;
+	__u16 sensor_physical_height;
 };
 
 /*
@@ -49,6 +78,8 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 		struct hid_field *field, struct hid_usage *usage,
 		unsigned long **bit, int *max)
 {
+	struct ntrig_data *nd = hid_get_drvdata(hdev);
+
 	/* No special mappings needed for the pen and single touch */
 	if (field-&gt;physical)
 		return 0;
@@ -62,6 +93,21 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 			input_set_abs_params(hi-&gt;input, ABS_X,
 					field-&gt;logical_minimum,
 					field-&gt;logical_maximum, 0, 0);
+
+			if (!nd-&gt;sensor_logical_width) {
+				nd-&gt;sensor_logical_width =
+					field-&gt;logical_maximum -
+					field-&gt;logical_minimum;
+				nd-&gt;sensor_physical_width =
+					field-&gt;physical_maximum -
+					field-&gt;physical_minimum;
+				nd-&gt;activation_width = activation_width *
+					nd-&gt;sensor_logical_width /
+					nd-&gt;sensor_physical_width;
+				nd-&gt;min_width = min_width *
+					nd-&gt;sensor_logical_width /
+					nd-&gt;sensor_physical_width;
+			}
 			return 1;
 		case HID_GD_Y:
 			hid_map_usage(hi, usage, bit, max,
@@ -69,6 +115,21 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 			input_set_abs_params(hi-&gt;input, ABS_Y,
 					field-&gt;logical_minimum,
 					field-&gt;logical_maximum, 0, 0);
+
+			if (!nd-&gt;sensor_logical_height) {
+				nd-&gt;sensor_logical_height =
+					field-&gt;logical_maximum -
+					field-&gt;logical_minimum;
+				nd-&gt;sensor_physical_height =
+					field-&gt;physical_maximum -
+					field-&gt;physical_minimum;
+				nd-&gt;activation_height = activation_height *
+					nd-&gt;sensor_logical_height /
+					nd-&gt;sensor_physical_height;
+				nd-&gt;min_height = min_height *
+					nd-&gt;sensor_logical_height /
+					nd-&gt;sensor_physical_height;
+			}
 			return 1;
 		}
 		return 0;
@@ -201,20 +262,68 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			if (nd-&gt;mt_foot_count != 4)
 				break;
 
-			/* Pen activity signal, trigger end of touch. */
+			/* Pen activity signal. */
 			if (nd-&gt;mt_footer[2]) {
+				/*
+				 * When the pen deactivates touch, we see a
+				 * bogus frame with ContactCount &gt; 0.
+				 * We can
+				 * save a bit of work by ensuring act_state &lt; 0
+				 * even if deactivation slack is turned off.
+				 */
+				nd-&gt;act_state = deactivate_slack - 1;
 				nd-&gt;confidence = 0;
 				break;
 			}
 
-			/* If the contact was invalid */
-			if (!(nd-&gt;confidence &amp;&amp; nd-&gt;mt_footer[0])
-					|| nd-&gt;w &lt;= 250
-					|| nd-&gt;h &lt;= 190) {
-				nd-&gt;confidence = 0;
+			/*
+			 * The first footer value indicates the presence of a
+			 * finger.
+			 */
+			if (nd-&gt;mt_footer[0]) {
+				/*
+				 * We do not want to process contacts under
+				 * the size threshold, but do not want to
+				 * ignore them for activation state
+				 */
+				if (nd-&gt;w &lt; nd-&gt;min_width ||
+				    nd-&gt;h &lt; nd-&gt;min_height)
+					nd-&gt;confidence = 0;
+			} else
 				break;
+
+			if (nd-&gt;act_state &gt; 0) {
+				/*
+				 * Contact meets the activation size threshold
+				 */
+				if (nd-&gt;w &gt;= nd-&gt;activation_width &amp;&amp;
+				    nd-&gt;h &gt;= nd-&gt;activation_height) {
+					if (nd-&gt;id)
+						/*
+						 * first contact, activate now
+						 */
+						nd-&gt;act_state = 0;
+					else {
+						/*
+						 * avoid corrupting this frame
+						 * but ensure next frame will
+						 * be active
+						 */
+						nd-&gt;act_state = 1;
+						break;
+					}
+				} else
+					/*
+					 * Defer adjusting the activation state
+					 * until the end of the frame.
+					 */
+					break;
 			}
 
+			/* Discarding this contact */
+			if (!nd-&gt;confidence)
+				break;
+
 			/* emit a normal (X, Y) for the first point only */
 			if (nd-&gt;id == 0) {
 				/*
@@ -227,8 +336,15 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
 			}
+
+			/* Emit MT events */
 			input_event(input, EV_ABS, ABS_MT_POSITION_X, nd-&gt;x);
 			input_event(input, EV_ABS, ABS_MT_POSITION_Y, nd-&gt;y);
+
+			/*
+			 * Translate from height and width to size
+			 * and orientation.
+			 */
 			if (nd-&gt;w &gt; nd-&gt;h) {
 				input_event(input, EV_ABS,
 						ABS_MT_ORIENTATION, 1);
@@ -248,12 +364,88 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			break;
 
 		case HID_DG_CONTACTCOUNT: /* End of a multitouch group */
-			if (!nd-&gt;reading_mt)
+			if (!nd-&gt;reading_mt) /* Just to be sure */
 				break;
 
 			nd-&gt;reading_mt = 0;
 
-			if (nd-&gt;first_contact_touch) {
+
+			/*
+			 * Activation state machine logic:
+			 *
+			 * Fundamental states:
+			 *	state &gt;  0: Inactive
+			 *	state &lt;= 0: Active
+			 *	state &lt;  -deactivate_slack:
+			 *		 Pen termination of touch
+			 *
+			 * Specific values of interest
+			 *	state == activate_slack
+			 *		 no valid input since the last reset
+			 *
+			 *	state == 0
+			 *		 general operational state
+			 *
+			 *	state == -deactivate_slack
+			 *		 read sufficient empty frames to accept
+			 *		 the end of input and reset
+			 */
+
+			if (nd-&gt;act_state &gt; 0) { /* Currently inactive */
+				if (value)
+					/*
+					 * Consider each live contact as
+					 * evidence of intentional activity.
+					 */
+					nd-&gt;act_state = (nd-&gt;act_state &gt; value)
+							? nd-&gt;act_state - value
+							: 0;
+				else
+					/*
+					 * Empty frame before we hit the
+					 * activity threshold, reset.
+					 */
+					nd-&gt;act_state = nd-&gt;activate_slack;
+
+				/*
+				 * Entered this block inactive and no
+				 * coordinates sent this frame, so hold off
+				 * on button state.
+				 */
+				break;
+			} else { /* Currently active */
+				if (value &amp;&amp; nd-&gt;act_state &gt;=
+					     nd-&gt;deactivate_slack)
+					/*
+					 * Live point: clear accumulated
+					 * deactivation count.
+					 */
+					nd-&gt;act_state = 0;
+				else if (nd-&gt;act_state &lt;= nd-&gt;deactivate_slack)
+					/*
+					 * We've consumed the deactivation
+					 * slack, time to deactivate and reset.
+					 */
+					nd-&gt;act_state =
+						nd-&gt;activate_slack;
+				else { /* Move towards deactivation */
+					nd-&gt;act_state--;
+					break;
+				}
+			}
+
+			if (nd-&gt;first_contact_touch &amp;&amp; nd-&gt;act_state &lt;= 0) {
+				/*
+				 * Check to see if we're ready to start
+				 * emitting touch events.
+				 *
+				 * Note: activation slack will decrease over
+				 * the course of the frame, and it will be
+				 * inconsistent from the start to the end of
+				 * the frame.  However if the frame starts
+				 * with slack, first_contact_touch will still
+				 * be 0 and we will not get to this point.
+				 */
 				input_report_key(input, BTN_TOOL_DOUBLETAP, 1);
 				input_report_key(input, BTN_TOUCH, 1);
 			} else {
@@ -263,7 +455,7 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			break;
 
 		default:
-			/* fallback to the generic hidinput handling */
+			/* fall-back to the generic hidinput handling */
 			return 0;
 		}
 	}
@@ -293,6 +485,16 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	}
 
 	nd-&gt;reading_mt = 0;
+	nd-&gt;min_width = 0;
+	nd-&gt;min_height = 0;
+	nd-&gt;activate_slack = activate_slack;
+	nd-&gt;act_state = activate_slack;
+	nd-&gt;deactivate_slack = -deactivate_slack;
+	nd-&gt;sensor_logical_width = 0;
+	nd-&gt;sensor_logical_height = 0;
+	nd-&gt;sensor_physical_width = 0;
+	nd-&gt;sensor_physical_height = 0;
+
 	hid_set_drvdata(hdev, nd);
 
 	ret = hid_parse(hdev);</pre><hr><pre>commit ed7e2ca24bfff5c7a09de8a05c536f68560b34fb
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Mon May 3 05:08:30 2010 -0400

    HID: ntrig: Remove unused macro, TripleTap and QuadTap
    
    Removing the higher number taps.  Their usage was incorrect
    and even if correct they should not be used for a touch screen.
    _MT_ events should be used to communicate multiple fingers.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 10b08d6ab37c..4777bbfa1cc2 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -24,9 +24,6 @@
 
 #define NTRIG_DUPLICATE_USAGES	0x001
 
-#define nt_map_key_clear(c)	hid_map_usage_clear(hi, usage, bit, max, \
-					EV_KEY, (c))
-
 struct ntrig_data {
 	/* Incoming raw values for a single contact */
 	__u16 x, y, w, h;
@@ -257,29 +254,10 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			nd-&gt;reading_mt = 0;
 
 			if (nd-&gt;first_contact_touch) {
-				switch (value) {
-				case 0:	/* for single touch devices */
-				case 1:
-					input_report_key(input,
-							BTN_TOOL_DOUBLETAP, 1);
-					break;
-				case 2:
-					input_report_key(input,
-							BTN_TOOL_TRIPLETAP, 1);
-					break;
-				case 3:
-				default:
-					input_report_key(input,
-							BTN_TOOL_QUADTAP, 1);
-				}
+				input_report_key(input, BTN_TOOL_DOUBLETAP, 1);
 				input_report_key(input, BTN_TOUCH, 1);
 			} else {
-				input_report_key(input,
-						BTN_TOOL_DOUBLETAP, 0);
-				input_report_key(input,
-						BTN_TOOL_TRIPLETAP, 0);
-				input_report_key(input,
-						BTN_TOOL_QUADTAP, 0);
+				input_report_key(input, BTN_TOOL_DOUBLETAP, 0);
 				input_report_key(input, BTN_TOUCH, 0);
 			}
 			break;
@@ -345,13 +323,7 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 			__clear_bit(BTN_TOOL_PEN, input-&gt;keybit);
 			__clear_bit(BTN_TOOL_FINGER, input-&gt;keybit);
 			__clear_bit(BTN_0, input-&gt;keybit);
-			/*
-			 * A little something special to enable
-			 * two and three finger taps.
-			 */
 			__set_bit(BTN_TOOL_DOUBLETAP, input-&gt;keybit);
-			__set_bit(BTN_TOOL_TRIPLETAP, input-&gt;keybit);
-			__set_bit(BTN_TOOL_QUADTAP, input-&gt;keybit);
 			/*
 			 * The physical touchscreen (single touch)
 			 * input has a value for physical, whereas</pre><hr><pre>commit 250d377522fd81459a4ea2350a794b453f37ce7d
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Mon May 3 05:08:29 2010 -0400

    HID: ntrig: TipSwitch for single touch mode touch.
    
    Include TipSwitch in the touch detection decision for some single touch
    firmwares.  Confidence and InRange are high for all finger events
    including those used to indicate the finger is no longer in contact with
    the sensor.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 58ba0d3d8aa5..10b08d6ab37c 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -31,10 +31,12 @@ struct ntrig_data {
 	/* Incoming raw values for a single contact */
 	__u16 x, y, w, h;
 	__u16 id;
-	__u8 confidence;
+
+	bool tipswitch;
+	bool confidence;
+	bool first_contact_touch;
 
 	bool reading_mt;
-	__u8 first_contact_confidence;
 
 	__u8 mt_footer[4];
 	__u8 mt_foot_count;
@@ -141,9 +143,10 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 		case 0xff000001:
 			/* Tag indicating the start of a multitouch group */
 			nd-&gt;reading_mt = 1;
-			nd-&gt;first_contact_confidence = 0;
+			nd-&gt;first_contact_touch = 0;
 			break;
 		case HID_DG_TIPSWITCH:
+			nd-&gt;tipswitch = value;
 			/* Prevent emission of touch until validated */
 			return 1;
 		case HID_DG_CONFIDENCE:
@@ -171,10 +174,14 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			 * to emit a normal (X, Y) position
 			 */
 			if (!nd-&gt;reading_mt) {
-				input_report_key(input, BTN_TOOL_DOUBLETAP,
-						 (nd-&gt;confidence != 0));
+				/*
+				 * TipSwitch indicates the presence of a
+				 * finger in single touch mode.
+				 */
 				input_report_key(input, BTN_TOUCH,
-						 (nd-&gt;confidence != 0));
+						 nd-&gt;tipswitch);
+				input_report_key(input, BTN_TOOL_DOUBLETAP,
+						 nd-&gt;tipswitch);
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
 			}
@@ -213,7 +220,13 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 
 			/* emit a normal (X, Y) for the first point only */
 			if (nd-&gt;id == 0) {
-				nd-&gt;first_contact_confidence = nd-&gt;confidence;
+				/*
+				 * TipSwitch is superfluous in multitouch
+				 * mode.  The footer events tell us
+				 * if there is a finger on the screen or
+				 * not.
+				 */
+				nd-&gt;first_contact_touch = nd-&gt;confidence;
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
 			}
@@ -243,7 +256,7 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 
 			nd-&gt;reading_mt = 0;
 
-			if (nd-&gt;first_contact_confidence) {
+			if (nd-&gt;first_contact_touch) {
 				switch (value) {
 				case 0:	/* for single touch devices */
 				case 1:</pre><hr><pre>commit 2170c5a8ae4b952e517e7b0565528914ddc11320
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Fri Apr 9 17:58:25 2010 -0400

    HID: ntrig: Emit TOUCH with DOUBLETAP for single touch
    
    I squelched TipSwitch in a recent patch which resulted in the loss
    of Touch events for single touch firmwares.  This patch just puts Touch back
    in for single touch, and bundles it with DoubleTap (like the multitouch code).
    The two events are used to convey the same message to different drivers.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index a418f9e19ce7..58ba0d3d8aa5 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -173,6 +173,8 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			if (!nd-&gt;reading_mt) {
 				input_report_key(input, BTN_TOOL_DOUBLETAP,
 						 (nd-&gt;confidence != 0));
+				input_report_key(input, BTN_TOUCH,
+						 (nd-&gt;confidence != 0));
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
 			}</pre><hr><pre>commit 2886539d5e649c22a6d2107eb431d3bee81e0e6d
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Wed Mar 10 16:10:28 2010 +0100

    HID: ntrig: fix touch events
    
    This reinstates the lost unpressing of BTN_TOUCH.  To prevent undesireably
    touch toggles this also deals with tip switch events.
    
    Added a trap to prevent going out of bounds for hidinputs with empty reports.
    
    Clear bits of unused buttons which result in misidentification.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 3234c729a895..edcc0c4247bb 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -140,6 +140,9 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			nd-&gt;reading_mt = 1;
 			nd-&gt;first_contact_confidence = 0;
 			break;
+		case HID_DG_TIPSWITCH:
+			/* Prevent emission of touch until validated */
+			return 1;
 		case HID_DG_CONFIDENCE:
 			nd-&gt;confidence = value;
 			break;
@@ -259,6 +262,7 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 						BTN_TOOL_TRIPLETAP, 0);
 				input_report_key(input,
 						BTN_TOOL_QUADTAP, 0);
+				input_report_key(input, BTN_TOUCH, 0);
 			}
 			break;
 
@@ -308,13 +312,20 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 
 
 	list_for_each_entry(hidinput, &amp;hdev-&gt;inputs, list) {
+		if (hidinput-&gt;report-&gt;maxfield &lt; 1)
+			continue;
+
 		input = hidinput-&gt;input;
 		switch (hidinput-&gt;report-&gt;field[0]-&gt;application) {
 		case HID_DG_PEN:
 			input-&gt;name = "N-Trig Pen";
 			break;
 		case HID_DG_TOUCHSCREEN:
+			/* These keys are redundant for fingers, clear them
+			 * to prevent incorrect identification */
 			__clear_bit(BTN_TOOL_PEN, input-&gt;keybit);
+			__clear_bit(BTN_TOOL_FINGER, input-&gt;keybit);
+			__clear_bit(BTN_0, input-&gt;keybit);
 			/*
 			 * A little something special to enable
 			 * two and three finger taps.</pre><hr><pre>commit ff5cf34c809cd5950579e46e7c10c29bc647aaf1
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Tue Feb 16 10:22:11 2010 -0500

    HID: hid-ntrig: Single touch mode tap
    
    Add DOUBLETAP to events emitted when in single touch only mode.
    
    Users with a single touch firmware report not seeing the DOUBLETAP events; this
    is a side effect of dropping old mapping for confidence. The confidence mapping
    may be fine for singletouch mode but causes problems in multitouch mode.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index f6f882da6267..3234c729a895 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -165,6 +165,8 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			 * to emit a normal (X, Y) position
 			 */
 			if (!nd-&gt;reading_mt) {
+				input_report_key(input, BTN_TOOL_DOUBLETAP,
+						 (nd-&gt;confidence != 0));
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
 			}</pre><hr><pre>commit dbf2b17de505d390b5ecf5b5944fc0c88f6d66fe
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Fri Feb 12 21:13:05 2010 -0500

    HID: hid-ntrig: multitouch cleanup and fix
    
    This cleans up the identification of multitouch groups and enables
    the end of group sync.
    
    Taps are now explicitly handled to adjust for the changes in the
    event stream in multitouch mode.  Added triple and quad tap for the
    benefit of tools that recognize different tap types but do not have
    full multi touch support.
    
    This cleans up the behavior particularly for the latest firmware, which
    didn't work particularly well with the older version of the driver.
    
    In this form, when multitouch is active, both mt and st events will come out of
    the "N-Trig MultiTouch" device.  And when its not st events will come out of
    "N-Trig Touchscreen".
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 1bda3a4bd71f..f6f882da6267 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -25,8 +25,16 @@
 					EV_KEY, (c))
 
 struct ntrig_data {
-	__s32 x, y, id, w, h;
-	bool reading_a_point, found_contact_id;
+	/* Incoming raw values for a single contact */
+	__u16 x, y, w, h;
+	__u16 id;
+	__u8 confidence;
+
+	bool reading_mt;
+	__u8 first_contact_confidence;
+
+	__u8 mt_footer[4];
+	__u8 mt_foot_count;
 };
 
 /*
@@ -39,8 +47,8 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 		struct hid_field *field, struct hid_usage *usage,
 		unsigned long **bit, int *max)
 {
-	/* No special mappings needed for the pen */
-	if (field-&gt;application == HID_DG_PEN)
+	/* No special mappings needed for the pen and single touch */
+	if (field-&gt;physical)
 		return 0;
 
 	switch (usage-&gt;hid &amp; HID_USAGE_PAGE) {
@@ -66,18 +74,12 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 	case HID_UP_DIGITIZER:
 		switch (usage-&gt;hid) {
 		/* we do not want to map these for now */
-		case HID_DG_CONTACTID: /* value is useless */
+		case HID_DG_CONTACTID: /* Not trustworthy, squelch for now */
 		case HID_DG_INPUTMODE:
 		case HID_DG_DEVICEINDEX:
-		case HID_DG_CONTACTCOUNT:
 		case HID_DG_CONTACTMAX:
 			return -1;
 
-		/* original mapping by Rafi Rubin */
-		case HID_DG_CONFIDENCE:
-			nt_map_key_clear(BTN_TOOL_DOUBLETAP);
-			return 1;
-
 		/* width/height mapped on TouchMajor/TouchMinor/Orientation */
 		case HID_DG_WIDTH:
 			hid_map_usage(hi, usage, bit, max,
@@ -104,8 +106,8 @@ static int ntrig_input_mapped(struct hid_device *hdev, struct hid_input *hi,
 		struct hid_field *field, struct hid_usage *usage,
 		unsigned long **bit, int *max)
 {
-	/* No special mappings needed for the pen */
-	if (field-&gt;application == HID_DG_PEN)
+	/* No special mappings needed for the pen and single touch */
+	if (field-&gt;physical)
 		return 0;
 
 	if (usage-&gt;type == EV_KEY || usage-&gt;type == EV_REL
@@ -133,17 +135,24 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 
         if (hid-&gt;claimed &amp; HID_CLAIMED_INPUT) {
 		switch (usage-&gt;hid) {
+		case 0xff000001:
+			/* Tag indicating the start of a multitouch group */
+			nd-&gt;reading_mt = 1;
+			nd-&gt;first_contact_confidence = 0;
+			break;
+		case HID_DG_CONFIDENCE:
+			nd-&gt;confidence = value;
+			break;
 		case HID_GD_X:
 			nd-&gt;x = value;
-			nd-&gt;reading_a_point = 1;
+			/* Clear the contact footer */
+			nd-&gt;mt_foot_count = 0;
 			break;
 		case HID_GD_Y:
 			nd-&gt;y = value;
 			break;
 		case HID_DG_CONTACTID:
 			nd-&gt;id = value;
-			/* we receive this only when in multitouch mode */
-			nd-&gt;found_contact_id = 1;
 			break;
 		case HID_DG_WIDTH:
 			nd-&gt;w = value;
@@ -155,7 +164,7 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			 * report received in a finger event. We want
 			 * to emit a normal (X, Y) position
 			 */
-			if (!nd-&gt;found_contact_id) {
+			if (!nd-&gt;reading_mt) {
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
 			}
@@ -167,10 +176,34 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			 * this usage tells if the contact point is real
 			 * or a placeholder
 			 */
-			if (!nd-&gt;reading_a_point || value != 1)
+
+			/* Shouldn't get more than 4 footer packets, so skip */
+			if (nd-&gt;mt_foot_count &gt;= 4)
+				break;
+
+			nd-&gt;mt_footer[nd-&gt;mt_foot_count++] = value;
+
+			/* if the footer isn't complete break */
+			if (nd-&gt;mt_foot_count != 4)
+				break;
+
+			/* Pen activity signal, trigger end of touch. */
+			if (nd-&gt;mt_footer[2]) {
+				nd-&gt;confidence = 0;
+				break;
+			}
+
+			/* If the contact was invalid */
+			if (!(nd-&gt;confidence &amp;&amp; nd-&gt;mt_footer[0])
+					|| nd-&gt;w &lt;= 250
+					|| nd-&gt;h &lt;= 190) {
+				nd-&gt;confidence = 0;
 				break;
+			}
+
 			/* emit a normal (X, Y) for the first point only */
 			if (nd-&gt;id == 0) {
+				nd-&gt;first_contact_confidence = nd-&gt;confidence;
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
 			}
@@ -192,8 +225,39 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 						ABS_MT_TOUCH_MINOR, nd-&gt;w);
 			}
 			input_mt_sync(field-&gt;hidinput-&gt;input);
-			nd-&gt;reading_a_point = 0;
-			nd-&gt;found_contact_id = 0;
+			break;
+
+		case HID_DG_CONTACTCOUNT: /* End of a multitouch group */
+			if (!nd-&gt;reading_mt)
+				break;
+
+			nd-&gt;reading_mt = 0;
+
+			if (nd-&gt;first_contact_confidence) {
+				switch (value) {
+				case 0:	/* for single touch devices */
+				case 1:
+					input_report_key(input,
+							BTN_TOOL_DOUBLETAP, 1);
+					break;
+				case 2:
+					input_report_key(input,
+							BTN_TOOL_TRIPLETAP, 1);
+					break;
+				case 3:
+				default:
+					input_report_key(input,
+							BTN_TOOL_QUADTAP, 1);
+				}
+				input_report_key(input, BTN_TOUCH, 1);
+			} else {
+				input_report_key(input,
+						BTN_TOOL_DOUBLETAP, 0);
+				input_report_key(input,
+						BTN_TOOL_TRIPLETAP, 0);
+				input_report_key(input,
+						BTN_TOOL_QUADTAP, 0);
+			}
 			break;
 
 		default:
@@ -224,8 +288,8 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		dev_err(&amp;hdev-&gt;dev, "cannot allocate N-Trig data\n");
 		return -ENOMEM;
 	}
-	nd-&gt;reading_a_point = 0;
-	nd-&gt;found_contact_id = 0;
+
+	nd-&gt;reading_mt = 0;
 	hid_set_drvdata(hdev, nd);
 
 	ret = hid_parse(hdev);
@@ -248,6 +312,14 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 			input-&gt;name = "N-Trig Pen";
 			break;
 		case HID_DG_TOUCHSCREEN:
+			__clear_bit(BTN_TOOL_PEN, input-&gt;keybit);
+			/*
+			 * A little something special to enable
+			 * two and three finger taps.
+			 */
+			__set_bit(BTN_TOOL_DOUBLETAP, input-&gt;keybit);
+			__set_bit(BTN_TOOL_TRIPLETAP, input-&gt;keybit);
+			__set_bit(BTN_TOOL_QUADTAP, input-&gt;keybit);
 			/*
 			 * The physical touchscreen (single touch)
 			 * input has a value for physical, whereas</pre><hr><pre>commit b0549cf1a35a92edf053d94066e60fb0ed02bb71
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Thu Feb 11 22:14:06 2010 -0500

    HID: n-trig: remove unnecessary tool switching
    
    With the pen and touch split apart, we no longer need to inject
    additional tool switching events.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 38b2364c8867..1bda3a4bd71f 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -27,9 +27,6 @@
 struct ntrig_data {
 	__s32 x, y, id, w, h;
 	bool reading_a_point, found_contact_id;
-	bool pen_active;
-	bool finger_active;
-	bool inverted;
 };
 
 /*
@@ -47,7 +44,6 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 		return 0;
 
 	switch (usage-&gt;hid &amp; HID_USAGE_PAGE) {
-
 	case HID_UP_GENDESK:
 		switch (usage-&gt;hid) {
 		case HID_GD_X:
@@ -111,6 +107,7 @@ static int ntrig_input_mapped(struct hid_device *hdev, struct hid_input *hi,
 	/* No special mappings needed for the pen */
 	if (field-&gt;application == HID_DG_PEN)
 		return 0;
+
 	if (usage-&gt;type == EV_KEY || usage-&gt;type == EV_REL
 			|| usage-&gt;type == EV_ABS)
 		clear_bit(usage-&gt;code, *bit);
@@ -136,18 +133,6 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 
         if (hid-&gt;claimed &amp; HID_CLAIMED_INPUT) {
 		switch (usage-&gt;hid) {
-
-		case HID_DG_INRANGE:
-			if (field-&gt;application &amp; 0x3)
-				nd-&gt;pen_active = (value != 0);
-			else
-				nd-&gt;finger_active = (value != 0);
-			return 0;
-
-		case HID_DG_INVERT:
-			nd-&gt;inverted = value;
-			return 0;
-
 		case HID_GD_X:
 			nd-&gt;x = value;
 			nd-&gt;reading_a_point = 1;
@@ -171,32 +156,8 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			 * to emit a normal (X, Y) position
 			 */
 			if (!nd-&gt;found_contact_id) {
-				if (nd-&gt;pen_active &amp;&amp; nd-&gt;finger_active) {
-					input_report_key(input, BTN_TOOL_DOUBLETAP, 0);
-					input_report_key(input, BTN_TOOL_DOUBLETAP, 1);
-				}
-				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
-				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
-			}
-			break;
-		case HID_DG_TIPPRESSURE:
-			/*
-			 * when in single touch mode, this is the last
-			 * report received in a pen event. We want
-			 * to emit a normal (X, Y) position
-			 */
-			if (! nd-&gt;found_contact_id) {
-				if (nd-&gt;pen_active &amp;&amp; nd-&gt;finger_active) {
-					input_report_key(input,
-							nd-&gt;inverted ? BTN_TOOL_RUBBER : BTN_TOOL_PEN
-							, 0);
-					input_report_key(input,
-							nd-&gt;inverted ? BTN_TOOL_RUBBER : BTN_TOOL_PEN
-							, 1);
-				}
 				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
 				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
-				input_event(input, EV_ABS, ABS_PRESSURE, value);
 			}
 			break;
 		case 0xff000002:</pre>
    <div class="pagination">
        <a href='25.html'>&lt;&lt;Prev</a><a href='25.html'>1</a><span>[2]</span><a href='25_3.html'>3</a><a href='25_3.html'>Next&gt;&gt;</a>
    <div>
</body>
