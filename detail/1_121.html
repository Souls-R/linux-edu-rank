<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_120.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><span>[121]</span><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_122.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7b16994437c7359832dd51d66c5c387995a91438
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Thu Jun 11 18:03:39 2020 -0400

    Makefile: Improve compressed debug info support detection
    
    Commit
      10e68b02c861 ("Makefile: support compressed debug info")
    added support for compressed debug sections.
    
    Support is detected by checking
    - does the compiler support -gz=zlib
    - does the assembler support --compressed-debug-sections=zlib
    - does the linker support --compressed-debug-sections=zlib
    
    However, the gcc driver's support for this option is somewhat
    convoluted. The driver's builtin specs are set based on the version of
    binutils that it was configured with. It reports an error if the
    configure-time linker/assembler (i.e., not necessarily the actual
    assembler that will be run) do not support the option, but only if the
    assembler (or linker) is actually invoked when -gz=zlib is passed.
    
    The cc-option check in scripts/Kconfig.include does not invoke the
    assembler, so the gcc driver reports success even if it does not support
    the option being passed to the assembler.
    
    Because the as-option check passes the option directly to the assembler
    via -Wa,--compressed-debug-sections=zlib, the gcc driver does not see
    this option and will never report an error.
    
    Combined with an installed version of binutils that is more recent than
    the one the compiler was built with, it is possible for all three tests
    to succeed, yet an actual compilation with -gz=zlib to fail.
    
    Moreover, it is unnecessary to explicitly pass
    --compressed-debug-sections=zlib to the assembler via -Wa, since the
    driver will do that automatically when it supports -gz=zlib.
    
    Convert the as-option to just -gz=zlib, simplifying it as well as
    performing a better test of the gcc driver's capabilities.
    
    Reported-by: kernel test robot &lt;lkp@intel.com&gt;
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Reviewed-by: Nick Desaulniers &lt;ndesaulniers@google.com&gt;
    Signed-off-by: Masahiro Yamada &lt;masahiroy@kernel.org&gt;

diff --git a/Makefile b/Makefile
index ae5d8220f431..29abe44ada91 100644
--- a/Makefile
+++ b/Makefile
@@ -828,7 +828,7 @@ endif
 
 ifdef CONFIG_DEBUG_INFO_COMPRESSED
 DEBUG_CFLAGS	+= -gz=zlib
-KBUILD_AFLAGS	+= -Wa,--compress-debug-sections=zlib
+KBUILD_AFLAGS	+= -gz=zlib
 KBUILD_LDFLAGS	+= --compress-debug-sections=zlib
 endif
 
diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug
index d74ac0fd6b2d..96999d4d2dda 100644
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@ -229,7 +229,7 @@ config DEBUG_INFO_COMPRESSED
 	bool "Compressed debugging information"
 	depends on DEBUG_INFO
 	depends on $(cc-option,-gz=zlib)
-	depends on $(as-option,-Wa$(comma)--compress-debug-sections=zlib)
+	depends on $(as-option,-gz=zlib)
 	depends on $(ld-option,--compress-debug-sections=zlib)
 	help
 	  Compress the debug information using zlib.  Requires GCC 5.0+ or Clang</pre><hr><pre>commit e9524fb97ab5b41b85e1d3408f8e513433798f3c
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Wed May 27 19:26:02 2020 -0400

    efi/x86: Don't blow away existing initrd
    
    Commit
    
      987053a30016 ("efi/x86: Move command-line initrd loading to efi_main")
    
    moved the command-line initrd loading into efi_main(), with a check
    to ensure that it was attempted only if the EFI stub was booted via
    efi_pe_entry rather than the EFI handover entry.
    
    However, in the case where it was booted via handover entry, and thus an
    initrd may have already been loaded by the bootloader, it then wrote 0
    for the initrd address and size, removing any existing initrd.
    
    Fix this by checking if size is positive before setting the fields in
    the bootparams structure.
    
    Fixes: 987053a30016 ("efi/x86: Move command-line initrd loading to efi_main")
    Reported-by: Dan Williams &lt;dan.j.williams@intel.com&gt;
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Signed-off-by: Borislav Petkov &lt;bp@suse.de&gt;
    Reviewed-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;
    Tested-by: Dan Williams &lt;dan.j.williams@intel.com&gt;
    Link: https://lkml.kernel.org/r/20200527232602.21596-1-nivedita@alum.mit.edu

diff --git a/drivers/firmware/efi/libstub/x86-stub.c b/drivers/firmware/efi/libstub/x86-stub.c
index 99a0cfb0c7ad..5a48d996ed71 100644
--- a/drivers/firmware/efi/libstub/x86-stub.c
+++ b/drivers/firmware/efi/libstub/x86-stub.c
@@ -768,10 +768,12 @@ unsigned long efi_main(efi_handle_t handle,
 			efi_err("Failed to load initrd!\n");
 			goto fail;
 		}
-		efi_set_u64_split(addr, &amp;hdr-&gt;ramdisk_image,
-				  &amp;boot_params-&gt;ext_ramdisk_image);
-		efi_set_u64_split(size, &amp;hdr-&gt;ramdisk_size,
-				  &amp;boot_params-&gt;ext_ramdisk_size);
+		if (size &gt; 0) {
+			efi_set_u64_split(addr, &amp;hdr-&gt;ramdisk_image,
+					  &amp;boot_params-&gt;ext_ramdisk_image);
+			efi_set_u64_split(size, &amp;hdr-&gt;ramdisk_size,
+					  &amp;boot_params-&gt;ext_ramdisk_size);
+		}
 	}
 
 	/*</pre><hr><pre>commit 9241dfe7f2772fc73c82eb950afb1c795d2c012c
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Sat May 23 18:15:13 2020 -0400

    efi/x86: Drop the special GDT for the EFI thunk
    
    Instead of using efi_gdt64 to switch back to 64-bit mode and then
    switching to the real boot-time GDT, just switch to the boot-time GDT
    directly. The two GDT's are identical other than efi_gdt64 not including
    the 32-bit code segment.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200523221513.1642948-1-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/arch/x86/boot/compressed/efi_thunk_64.S b/arch/x86/boot/compressed/efi_thunk_64.S
index 2b2049259619..c4bb0f9363f5 100644
--- a/arch/x86/boot/compressed/efi_thunk_64.S
+++ b/arch/x86/boot/compressed/efi_thunk_64.S
@@ -28,8 +28,6 @@ SYM_FUNC_START(__efi64_thunk)
 	push	%rbx
 
 	leaq	1f(%rip), %rbp
-	leaq	efi_gdt64(%rip), %rbx
-	movl	%ebx, 2(%rbx)		/* Fixup the gdt base address */
 
 	movl	%ds, %eax
 	push	%rax
@@ -48,7 +46,8 @@ SYM_FUNC_START(__efi64_thunk)
 	movl	%r8d, 0xc(%rsp)
 	movl	%r9d, 0x10(%rsp)
 
-	sgdt	0x14(%rsp)
+	leaq	0x14(%rsp), %rbx
+	sgdt	(%rbx)
 
 	/*
 	 * Switch to gdt with 32-bit segments. This is the firmware GDT
@@ -68,8 +67,7 @@ SYM_FUNC_START(__efi64_thunk)
 	pushq	%rax
 	lretq
 
-1:	lgdt	0x14(%rsp)
-	addq	$32, %rsp
+1:	addq	$32, %rsp
 	movq	%rdi, %rax
 
 	pop	%rbx
@@ -175,14 +173,3 @@ SYM_DATA_END(efi32_boot_cs)
 SYM_DATA_START(efi32_boot_ds)
 	.word	0
 SYM_DATA_END(efi32_boot_ds)
-
-SYM_DATA_START(efi_gdt64)
-	.word	efi_gdt64_end - efi_gdt64
-	.long	0			/* Filled out by user */
-	.word	0
-	.quad	0x0000000000000000	/* NULL descriptor */
-	.quad	0x00af9a000000ffff	/* __KERNEL_CS */
-	.quad	0x00cf92000000ffff	/* __KERNEL_DS */
-	.quad	0x0080890000000000	/* TS descriptor */
-	.quad   0x0000000000000000	/* TS continued */
-SYM_DATA_END_LABEL(efi_gdt64, SYM_L_LOCAL, efi_gdt64_end)</pre><hr><pre>commit 67d631b7c05eff955ccff4139327f0f92a5117e5
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Sat Feb 29 18:11:20 2020 -0500

    x86/mm: Stop printing BRK addresses
    
    This currently leaks kernel physical addresses into userspace.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Signed-off-by: Borislav Petkov &lt;bp@suse.de&gt;
    Acked-by: Kees Cook &lt;keescook@chromium.org&gt;
    Acked-by: Dave Hansen &lt;dave.hansen@intel.com&gt;
    Link: https://lkml.kernel.org/r/20200229231120.1147527-1-nivedita@alum.mit.edu

diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c
index 1bba16c5742b..a573a3e63f02 100644
--- a/arch/x86/mm/init.c
+++ b/arch/x86/mm/init.c
@@ -121,8 +121,6 @@ __ref void *alloc_low_pages(unsigned int num)
 	} else {
 		pfn = pgt_buf_end;
 		pgt_buf_end += num;
-		printk(KERN_DEBUG "BRK [%#010lx, %#010lx] PGTABLE\n",
-			pfn &lt;&lt; PAGE_SHIFT, (pgt_buf_end &lt;&lt; PAGE_SHIFT) - 1);
 	}
 
 	for (i = 0; i &lt; num; i++) {</pre><hr><pre>commit 80b1bfe1cb2f20225fb2d8f11d44af4a9d765396
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Wed May 20 20:29:21 2020 -0400

    efi/libstub: Don't parse overlong command lines
    
    Check if the command line passed in is larger than COMMAND_LINE_SIZE,
    and truncate it to the last full argument if so.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200521002921.69650-1-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index 9fb107e9355b..dbfaf8dcdda2 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -9,10 +9,12 @@
 
 #include &lt;stdarg.h&gt;
 
+#include &lt;linux/ctype.h&gt;
 #include &lt;linux/efi.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/printk.h&gt; /* For CONSOLE_LOGLEVEL_* */
 #include &lt;asm/efi.h&gt;
+#include &lt;asm/setup.h&gt;
 
 #include "efistub.h"
 
@@ -217,22 +219,33 @@ char *efi_convert_cmdline(efi_loaded_image_t *image,
 	unsigned long cmdline_addr = 0;
 	int options_chars = efi_table_attr(image, load_options_size) / 2;
 	const u16 *options = efi_table_attr(image, load_options);
-	int options_bytes = 0;  /* UTF-8 bytes */
+	int options_bytes = 0, safe_options_bytes = 0;  /* UTF-8 bytes */
+	bool in_quote = false;
 	efi_status_t status;
 
 	if (options) {
 		s2 = options;
-		while (options_chars--) {
+		while (options_bytes &lt; COMMAND_LINE_SIZE &amp;&amp; options_chars--) {
 			u16 c = *s2++;
 
-			if (c == L'\0' || c == L'\n')
-				break;
+			if (c &lt; 0x80) {
+				if (c == L'\0' || c == L'\n')
+					break;
+				if (c == L'"')
+					in_quote = !in_quote;
+				else if (!in_quote &amp;&amp; isspace((char)c))
+					safe_options_bytes = options_bytes;
+
+				options_bytes++;
+				continue;
+			}
+
 			/*
 			 * Get the number of UTF-8 bytes corresponding to a
 			 * UTF-16 character.
 			 * The first part handles everything in the BMP.
 			 */
-			options_bytes += 1 + (c &gt;= 0x80) + (c &gt;= 0x800);
+			options_bytes += 2 + (c &gt;= 0x800);
 			/*
 			 * Add one more byte for valid surrogate pairs. Invalid
 			 * surrogates will be replaced with 0xfffd and take up
@@ -253,6 +266,11 @@ char *efi_convert_cmdline(efi_loaded_image_t *image,
 				}
 			}
 		}
+		if (options_bytes &gt;= COMMAND_LINE_SIZE) {
+			options_bytes = safe_options_bytes;
+			efi_err("Command line is too long: truncated to %d bytes\n",
+				options_bytes);
+		}
 	}
 
 	options_bytes++;	/* NUL termination */</pre><hr><pre>commit 04b24409b42a9fcae2379a6ddcf9c827b9af7a45
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:16 2020 -0400

    efi/libstub: Use snprintf with %ls to convert the command line
    
    Now we can use snprintf to do the UTF-16 to UTF-8 translation for the
    command line.
    
    Drop the special "zero" trick to handle an empty command line. This was
    unnecessary even before this since with options_chars == 0,
    efi_utf16_to_utf8 would not have accessed options at all. snprintf won't
    access it either with a precision of 0.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-25-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index 4d544f395403..9fb107e9355b 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -205,46 +205,6 @@ efi_status_t efi_parse_options(char const *cmdline)
 	return EFI_SUCCESS;
 }
 
-/*
- * Convert an UTF-16 string, not necessarily null terminated, to UTF-8.
- */
-static u8 *efi_utf16_to_utf8(u8 *dst, const u16 *src, int n)
-{
-	unsigned int c;
-
-	while (n--) {
-		c = *src++;
-		if (n &amp;&amp; c &gt;= 0xd800 &amp;&amp; c &lt;= 0xdbff &amp;&amp;
-		    *src &gt;= 0xdc00 &amp;&amp; *src &lt;= 0xdfff) {
-			c = 0x10000 + ((c &amp; 0x3ff) &lt;&lt; 10) + (*src &amp; 0x3ff);
-			src++;
-			n--;
-		}
-		if (c &gt;= 0xd800 &amp;&amp; c &lt;= 0xdfff)
-			c = 0xfffd; /* Unmatched surrogate */
-		if (c &lt; 0x80) {
-			*dst++ = c;
-			continue;
-		}
-		if (c &lt; 0x800) {
-			*dst++ = 0xc0 + (c &gt;&gt; 6);
-			goto t1;
-		}
-		if (c &lt; 0x10000) {
-			*dst++ = 0xe0 + (c &gt;&gt; 12);
-			goto t2;
-		}
-		*dst++ = 0xf0 + (c &gt;&gt; 18);
-		*dst++ = 0x80 + ((c &gt;&gt; 12) &amp; 0x3f);
-	t2:
-		*dst++ = 0x80 + ((c &gt;&gt; 6) &amp; 0x3f);
-	t1:
-		*dst++ = 0x80 + (c &amp; 0x3f);
-	}
-
-	return dst;
-}
-
 /*
  * Convert the unicode UEFI command line to ASCII to pass to kernel.
  * Size of memory allocated return in *cmd_line_len.
@@ -254,18 +214,15 @@ char *efi_convert_cmdline(efi_loaded_image_t *image,
 			  int *cmd_line_len, unsigned long max_addr)
 {
 	const u16 *s2;
-	u8 *s1 = NULL;
 	unsigned long cmdline_addr = 0;
-	int load_options_chars = efi_table_attr(image, load_options_size) / 2;
+	int options_chars = efi_table_attr(image, load_options_size) / 2;
 	const u16 *options = efi_table_attr(image, load_options);
 	int options_bytes = 0;  /* UTF-8 bytes */
-	int options_chars = 0;  /* UTF-16 chars */
 	efi_status_t status;
-	u16 zero = 0;
 
 	if (options) {
 		s2 = options;
-		while (options_chars &lt; load_options_chars) {
+		while (options_chars--) {
 			u16 c = *s2++;
 
 			if (c == L'\0' || c == L'\n')
@@ -276,7 +233,6 @@ char *efi_convert_cmdline(efi_loaded_image_t *image,
 			 * The first part handles everything in the BMP.
 			 */
 			options_bytes += 1 + (c &gt;= 0x80) + (c &gt;= 0x800);
-			options_chars++;
 			/*
 			 * Add one more byte for valid surrogate pairs. Invalid
 			 * surrogates will be replaced with 0xfffd and take up
@@ -288,35 +244,25 @@ char *efi_convert_cmdline(efi_loaded_image_t *image,
 				 * we must ignore it since we can't access the
 				 * low surrogate.
 				 */
-				if (options_chars == load_options_chars) {
+				if (!options_chars) {
 					options_bytes -= 3;
-					options_chars--;
-					break;
 				} else if ((*s2 &amp; 0xfc00) == 0xdc00) {
 					options_bytes++;
-					options_chars++;
+					options_chars--;
 					s2++;
 				}
 			}
 		}
 	}
 
-	if (!options_chars) {
-		/* No command line options, so return empty string*/
-		options = &amp;zero;
-	}
-
 	options_bytes++;	/* NUL termination */
 
 	status = efi_allocate_pages(options_bytes, &amp;cmdline_addr, max_addr);
 	if (status != EFI_SUCCESS)
 		return NULL;
 
-	s1 = (u8 *)cmdline_addr;
-	s2 = (const u16 *)options;
-
-	s1 = efi_utf16_to_utf8(s1, s2, options_chars);
-	*s1 = '\0';
+	snprintf((char *)cmdline_addr, options_bytes, "%.*ls",
+		 options_bytes - 1, options);
 
 	*cmd_line_len = options_bytes;
 	return (char *)cmdline_addr;</pre><hr><pre>commit 15c316bcbc23b777eae4e21f129526190aa20af1
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:15 2020 -0400

    efi/libstub: Get the exact UTF-8 length
    
    efi_convert_cmdline currently overestimates the length of the equivalent
    UTF-8 encoding.
    
    snprintf can now be used to do the conversion to UTF-8, however, it does
    not have a way to specify the size of the UTF-16 string, only the size
    of the resulting UTF-8 string. So in order to use it, we need to
    precalculate the exact UTF-8 size.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-24-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index 0d0007355c1e..4d544f395403 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -205,15 +205,6 @@ efi_status_t efi_parse_options(char const *cmdline)
 	return EFI_SUCCESS;
 }
 
-/*
- * Get the number of UTF-8 bytes corresponding to an UTF-16 character.
- * This overestimates for surrogates, but that is okay.
- */
-static int efi_utf8_bytes(u16 c)
-{
-	return 1 + (c &gt;= 0x80) + (c &gt;= 0x800);
-}
-
 /*
  * Convert an UTF-16 string, not necessarily null terminated, to UTF-8.
  */
@@ -274,10 +265,39 @@ char *efi_convert_cmdline(efi_loaded_image_t *image,
 
 	if (options) {
 		s2 = options;
-		while (*s2 &amp;&amp; *s2 != '\n'
-		       &amp;&amp; options_chars &lt; load_options_chars) {
-			options_bytes += efi_utf8_bytes(*s2++);
+		while (options_chars &lt; load_options_chars) {
+			u16 c = *s2++;
+
+			if (c == L'\0' || c == L'\n')
+				break;
+			/*
+			 * Get the number of UTF-8 bytes corresponding to a
+			 * UTF-16 character.
+			 * The first part handles everything in the BMP.
+			 */
+			options_bytes += 1 + (c &gt;= 0x80) + (c &gt;= 0x800);
 			options_chars++;
+			/*
+			 * Add one more byte for valid surrogate pairs. Invalid
+			 * surrogates will be replaced with 0xfffd and take up
+			 * only 3 bytes.
+			 */
+			if ((c &amp; 0xfc00) == 0xd800) {
+				/*
+				 * If the very last word is a high surrogate,
+				 * we must ignore it since we can't access the
+				 * low surrogate.
+				 */
+				if (options_chars == load_options_chars) {
+					options_bytes -= 3;
+					options_chars--;
+					break;
+				} else if ((*s2 &amp; 0xfc00) == 0xdc00) {
+					options_bytes++;
+					options_chars++;
+					s2++;
+				}
+			}
 		}
 	}
 </pre><hr><pre>commit a713979e443d4036e76e13bb3d30e9fa248915aa
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:14 2020 -0400

    efi/libstub: Use %ls for filename
    
    efi_printk can now handle the UTF-16 filename, so print it using efi_err
    instead of a separate efi_char16_puts call.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-23-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/file.c b/drivers/firmware/efi/libstub/file.c
index 933536c5236a..2005e33b33d5 100644
--- a/drivers/firmware/efi/libstub/file.c
+++ b/drivers/firmware/efi/libstub/file.c
@@ -46,9 +46,7 @@ static efi_status_t efi_open_file(efi_file_protocol_t *volume,
 
 	status = volume-&gt;open(volume, &amp;fh, fi-&gt;filename, EFI_FILE_MODE_READ, 0);
 	if (status != EFI_SUCCESS) {
-		efi_err("Failed to open file: ");
-		efi_char16_puts(fi-&gt;filename);
-		efi_puts("\n");
+		efi_err("Failed to open file: %ls\n", fi-&gt;filename);
 		return status;
 	}
 </pre><hr><pre>commit 4b75bd363de3f3429c62359be4e4aa4da7fa233b
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:13 2020 -0400

    efi/libstub: Add UTF-8 decoding to efi_puts
    
    In order to be able to use the UTF-16 support added to vsprintf in the
    previous commit, enhance efi_puts to decode UTF-8 into UTF-16. Invalid
    UTF-8 encodings are passed through unchanged.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-22-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index f338d149aaa5..0d0007355c1e 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -36,17 +36,74 @@ void efi_char16_puts(efi_char16_t *str)
 		       output_string, str);
 }
 
+static
+u32 utf8_to_utf32(const u8 **s8)
+{
+	u32 c32;
+	u8 c0, cx;
+	size_t clen, i;
+
+	c0 = cx = *(*s8)++;
+	/*
+	 * The position of the most-significant 0 bit gives us the length of
+	 * a multi-octet encoding.
+	 */
+	for (clen = 0; cx &amp; 0x80; ++clen)
+		cx &lt;&lt;= 1;
+	/*
+	 * If the 0 bit is in position 8, this is a valid single-octet
+	 * encoding. If the 0 bit is in position 7 or positions 1-3, the
+	 * encoding is invalid.
+	 * In either case, we just return the first octet.
+	 */
+	if (clen &lt; 2 || clen &gt; 4)
+		return c0;
+	/* Get the bits from the first octet. */
+	c32 = cx &gt;&gt; clen--;
+	for (i = 0; i &lt; clen; ++i) {
+		/* Trailing octets must have 10 in most significant bits. */
+		cx = (*s8)[i] ^ 0x80;
+		if (cx &amp; 0xc0)
+			return c0;
+		c32 = (c32 &lt;&lt; 6) | cx;
+	}
+	/*
+	 * Check for validity:
+	 * - The character must be in the Unicode range.
+	 * - It must not be a surrogate.
+	 * - It must be encoded using the correct number of octets.
+	 */
+	if (c32 &gt; 0x10ffff ||
+	    (c32 &amp; 0xf800) == 0xd800 ||
+	    clen != (c32 &gt;= 0x80) + (c32 &gt;= 0x800) + (c32 &gt;= 0x10000))
+		return c0;
+	*s8 += clen;
+	return c32;
+}
+
 void efi_puts(const char *str)
 {
 	efi_char16_t buf[128];
 	size_t pos = 0, lim = ARRAY_SIZE(buf);
+	const u8 *s8 = (const u8 *)str;
+	u32 c32;
 
-	while (*str) {
-		if (*str == '\n')
+	while (*s8) {
+		if (*s8 == '\n')
 			buf[pos++] = L'\r';
-		/* Cast to unsigned char to avoid sign-extension */
-		buf[pos++] = (unsigned char)(*str++);
-		if (*str == '\0' || pos &gt;= lim - 2) {
+		c32 = utf8_to_utf32(&amp;s8);
+		if (c32 &lt; 0x10000) {
+			/* Characters in plane 0 use a single word. */
+			buf[pos++] = c32;
+		} else {
+			/*
+			 * Characters in other planes encode into a surrogate
+			 * pair.
+			 */
+			buf[pos++] = (0xd800 - (0x10000 &gt;&gt; 10)) + (c32 &gt;&gt; 10);
+			buf[pos++] = 0xdc00 + (c32 &amp; 0x3ff);
+		}
+		if (*s8 == '\0' || pos &gt;= lim - 2) {
 			buf[pos] = L'\0';
 			efi_char16_puts(buf);
 			pos = 0;</pre><hr><pre>commit d850a2ff918be0691f8d0544a2156c856c42da5b
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:12 2020 -0400

    efi/printf: Add support for wchar_t (UTF-16)
    
    Support %lc and %ls to output UTF-16 strings (converted to UTF-8).
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-21-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/vsprintf.c b/drivers/firmware/efi/libstub/vsprintf.c
index a3265a81adca..e65ef49a54cd 100644
--- a/drivers/firmware/efi/libstub/vsprintf.c
+++ b/drivers/firmware/efi/libstub/vsprintf.c
@@ -147,6 +147,7 @@ char *number(char *end, unsigned long long num, int base, char locase)
 #define LEFT	16		/* left justified */
 #define SMALL	32		/* Must be 32 == 0x20 */
 #define SPECIAL	64		/* 0x */
+#define WIDE	128		/* UTF-16 string */
 
 static
 int get_flags(const char **fmt)
@@ -238,6 +239,58 @@ char get_sign(long long *num, int flags)
 	return 0;
 }
 
+static
+size_t utf16s_utf8nlen(const u16 *s16, size_t maxlen)
+{
+	size_t len, clen;
+
+	for (len = 0; len &lt; maxlen &amp;&amp; *s16; len += clen) {
+		u16 c0 = *s16++;
+
+		/* First, get the length for a BMP character */
+		clen = 1 + (c0 &gt;= 0x80) + (c0 &gt;= 0x800);
+		if (len + clen &gt; maxlen)
+			break;
+		/*
+		 * If this is a high surrogate, and we're already at maxlen, we
+		 * can't include the character if it's a valid surrogate pair.
+		 * Avoid accessing one extra word just to check if it's valid
+		 * or not.
+		 */
+		if ((c0 &amp; 0xfc00) == 0xd800) {
+			if (len + clen == maxlen)
+				break;
+			if ((*s16 &amp; 0xfc00) == 0xdc00) {
+				++s16;
+				++clen;
+			}
+		}
+	}
+
+	return len;
+}
+
+static
+u32 utf16_to_utf32(const u16 **s16)
+{
+	u16 c0, c1;
+
+	c0 = *(*s16)++;
+	/* not a surrogate */
+	if ((c0 &amp; 0xf800) != 0xd800)
+		return c0;
+	/* invalid: low surrogate instead of high */
+	if (c0 &amp; 0x0400)
+		return 0xfffd;
+	c1 = **s16;
+	/* invalid: missing low surrogate */
+	if ((c1 &amp; 0xfc00) != 0xdc00)
+		return 0xfffd;
+	/* valid surrogate pair */
+	++(*s16);
+	return (0x10000 - (0xd800 &lt;&lt; 10) - 0xdc00) + (c0 &lt;&lt; 10) + c1;
+}
+
 #define PUTC(c) \
 do {				\
 	if (pos &lt; size)		\
@@ -325,18 +378,31 @@ int vsnprintf(char *buf, size_t size, const char *fmt, va_list ap)
 		switch (*fmt) {
 		case 'c':
 			flags &amp;= LEFT;
-			tmp[0] = (unsigned char)va_arg(args, int);
 			s = tmp;
-			precision = len = 1;
+			if (qualifier == 'l') {
+				((u16 *)tmp)[0] = (u16)va_arg(args, unsigned int);
+				((u16 *)tmp)[1] = L'\0';
+				precision = INT_MAX;
+				goto wstring;
+			} else {
+				tmp[0] = (unsigned char)va_arg(args, int);
+				precision = len = 1;
+			}
 			goto output;
 
 		case 's':
 			flags &amp;= LEFT;
 			if (precision &lt; 0)
 				precision = INT_MAX;
-			s = va_arg(args, char *);
+			s = va_arg(args, void *);
 			if (!s)
 				s = precision &lt; 6 ? "" : "(null)";
+			else if (qualifier == 'l') {
+		wstring:
+				flags |= WIDE;
+				precision = len = utf16s_utf8nlen((const u16 *)s, precision);
+				goto output;
+			}
 			precision = len = strnlen(s, precision);
 			goto output;
 
@@ -436,8 +502,43 @@ int vsnprintf(char *buf, size_t size, const char *fmt, va_list ap)
 		while (precision-- &gt; len)
 			PUTC('0');
 		/* Actual output */
-		while (len-- &gt; 0)
-			PUTC(*s++);
+		if (flags &amp; WIDE) {
+			const u16 *ws = (const u16 *)s;
+
+			while (len-- &gt; 0) {
+				u32 c32 = utf16_to_utf32(&amp;ws);
+				u8 *s8;
+				size_t clen;
+
+				if (c32 &lt; 0x80) {
+					PUTC(c32);
+					continue;
+				}
+
+				/* Number of trailing octets */
+				clen = 1 + (c32 &gt;= 0x800) + (c32 &gt;= 0x10000);
+
+				len -= clen;
+				s8 = (u8 *)&amp;buf[pos];
+
+				/* Avoid writing partial character */
+				PUTC('\0');
+				pos += clen;
+				if (pos &gt;= size)
+					continue;
+
+				/* Set high bits of leading octet */
+				*s8 = (0xf00 &gt;&gt; 1) &gt;&gt; clen;
+				/* Write trailing octets in reverse order */
+				for (s8 += clen; clen; --clen, c32 &gt;&gt;= 6)
+					*s8-- = 0x80 | (c32 &amp; 0x3f);
+				/* Set low bits of leading octet */
+				*s8 |= c32;
+			}
+		} else {
+			while (len-- &gt; 0)
+				PUTC(*s++);
+		}
 		/* Trailing padding with ' ' */
 		while (field_width-- &gt; 0)
 			PUTC(' ');</pre>
    <div class="pagination">
        <a href='1_120.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><span>[121]</span><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_122.html'>Next&gt;&gt;</a>
    <div>
</body>
