<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_92.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><span>[93]</span><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_94.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 460bcf57b128ce1c0dd553d905fedc097f9955c6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue May 12 07:37:56 2009 -0400

    Fix nobh_truncate_page() to not pass stack garbage to get_block()
    
    The nobh_truncate_page() function is used by ext2, exofs, and jfs.  Of
    these three, only ext2 and jfs's get_block() function pays attention
    to bh-&gt;b_size --- which is normally always the filesystem blocksize
    except when the get_block() function is called by either
    mpage_readpage(), mpage_readpages(), or the direct I/O routines in
    fs/direct_io.c.
    
    Unfortunately, nobh_truncate_page() does not initialize map_bh before
    calling the filesystem-supplied get_block() function.  So ext2 and jfs
    will try to calculate the number of blocks to map by taking stack
    garbage and shifting it left by inode-&gt;i_blkbits.  This should be
    *mostly* harmless (except the filesystem will do some unnneeded work)
    unless the stack garbage is less than filesystem's blocksize, in which
    case maxblocks will be zero, and the attempt to find out whether or
    not the filesystem has a hole at a given logical block will fail, and
    the page cache entry might not get zero'ed out.
    
    Also if the stack garbage in in map_bh-&gt;state happens to have the
    BH_Mapped bit set, there could be an attempt to call readpage() on a
    non-existent page, which could cause nobh_truncate_page() to return an
    error when it should not.
    
    Fix this by initializing map_bh-&gt;state and map_bh-&gt;size.
    
    Fortunately, it's probably fairly unlikely that ext2 and jfs users
    mount with nobh these days.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Dave Kleikamp &lt;shaggy@linux.vnet.ibm.com&gt;
    Cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;

diff --git a/fs/buffer.c b/fs/buffer.c
index aed297739eb0..49106127a4aa 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2736,6 +2736,8 @@ int nobh_truncate_page(struct address_space *mapping,
 		pos += blocksize;
 	}
 
+	map_bh.b_size = blocksize;
+	map_bh.b_state = 0;
 	err = get_block(inode, iblock, &amp;map_bh, 0);
 	if (err)
 		goto unlock;</pre><hr><pre>commit 2ae19acaa50a09c1099956efb895c0aca74ab050
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Apr 16 07:44:45 2009 -0400

    Documentation: Add "how to write a good patch summary" to SubmittingPatches
    
    Unfortunately many patch submissions are arriving with painfully poor
    patch descriptions.   As a result of the discussion on LKML:
    
          http://lkml.org/lkml/2009/4/15/296
    
    explain how to submit a better patch description, in the (perhaps
    vain) hope that maintainers won't end up having to rewrite the git
    commit logs as often as they do today.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Ingo Molnar &lt;mingo@elte.hu&gt;
    Signed-off-by: Jonathan Corbet &lt;corbet@lwn.net&gt;

diff --git a/Documentation/SubmittingPatches b/Documentation/SubmittingPatches
index 71b6da2b7175..6c456835c1fd 100644
--- a/Documentation/SubmittingPatches
+++ b/Documentation/SubmittingPatches
@@ -91,6 +91,10 @@ Be as specific as possible.  The WORST descriptions possible include
 things like "update driver X", "bug fix for driver X", or "this patch
 includes updates for subsystem X.  Please apply."
 
+The maintainer will thank you if you write your patch description in a
+form which can be easily pulled into Linux's source code management
+system, git, as a "commit log".  See #15, below.
+
 If your description starts to get long, that's a sign that you probably
 need to split up your patch.  See #3, next.
 
@@ -492,12 +496,33 @@ phrase" should not be a filename.  Do not use the same "summary
 phrase" for every patch in a whole patch series (where a "patch
 series" is an ordered sequence of multiple, related patches).
 
-Bear in mind that the "summary phrase" of your email becomes
-a globally-unique identifier for that patch.  It propagates
-all the way into the git changelog.  The "summary phrase" may
-later be used in developer discussions which refer to the patch.
-People will want to google for the "summary phrase" to read
-discussion regarding that patch.
+Bear in mind that the "summary phrase" of your email becomes a
+globally-unique identifier for that patch.  It propagates all the way
+into the git changelog.  The "summary phrase" may later be used in
+developer discussions which refer to the patch.  People will want to
+google for the "summary phrase" to read discussion regarding that
+patch.  It will also be the only thing that people may quickly see
+when, two or three months later, they are going through perhaps
+thousands of patches using tools such as "gitk" or "git log
+--oneline".
+
+For these reasons, the "summary" must be no more than 70-75
+characters, and it must describe both what the patch changes, as well
+as why the patch might be necessary.  It is challenging to be both
+succinct and descriptive, but that is what a well-written summary
+should do.
+
+The "summary phrase" may be prefixed by tags enclosed in square
+brackets: "Subject: [PATCH tag] &lt;summary phrase&gt;".  The tags are not
+considered part of the summary phrase, but describe how the patch
+should be treated.  Common tags might include a version descriptor if
+the multiple versions of the patch have been sent out in response to
+comments (i.e., "v1, v2, v3"), or "RFC" to indicate a request for
+comments.  If there are four patches in a patch series the individual
+patches may be numbered like this: 1/4, 2/4, 3/4, 4/4.  This assures
+that developers understand the order in which the patches should be
+applied and that they have reviewed or applied all of the patches in
+the patch series.
 
 A couple of example Subjects:
 
@@ -517,19 +542,31 @@ the patch author in the changelog.
 The explanation body will be committed to the permanent source
 changelog, so should make sense to a competent reader who has long
 since forgotten the immediate details of the discussion that might
-have led to this patch.
+have led to this patch.  Including symptoms of the failure which the
+patch addresses (kernel log messages, oops messages, etc.) is
+especially useful for people who might be searching the commit logs
+looking for the applicable patch.  If a patch fixes a compile failure,
+it may not be necessary to include _all_ of the compile failures; just
+enough that it is likely that someone searching for the patch can find
+it.  As in the "summary phrase", it is important to be both succinct as
+well as descriptive.
 
 The "---" marker line serves the essential purpose of marking for patch
 handling tools where the changelog message ends.
 
 One good use for the additional comments after the "---" marker is for
-a diffstat, to show what files have changed, and the number of inserted
-and deleted lines per file.  A diffstat is especially useful on bigger
-patches.  Other comments relevant only to the moment or the maintainer,
-not suitable for the permanent changelog, should also go here.
-Use diffstat options "-p 1 -w 70" so that filenames are listed from the
-top of the kernel source tree and don't use too much horizontal space
-(easily fit in 80 columns, maybe with some indentation).
+a diffstat, to show what files have changed, and the number of
+inserted and deleted lines per file.  A diffstat is especially useful
+on bigger patches.  Other comments relevant only to the moment or the
+maintainer, not suitable for the permanent changelog, should also go
+here.  A good example of such comments might be "patch changelogs"
+which describe what has changed between the v1 and v2 version of the
+patch.
+
+If you are going to include a diffstat after the "---" marker, please
+use diffstat options "-p 1 -w 70" so that filenames are listed from
+the top of the kernel source tree and don't use too much horizontal
+space (easily fit in 80 columns, maybe with some indentation).
 
 See more details on the proper patch format in the following
 references.</pre><hr><pre>commit 5adfee9c17314c1411095c23191c3cb0c2d25f9f
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Jul 8 17:11:24 2009 -0400

    ext4: fix no journal corruption with locale-gen
    
    If there is no journal, ext4_should_writeback_data() should return
    TRUE.  This will fix ext4_set_aops() to set ext4_da_ops in the case of
    delayed allocation; otherwise ext4_journaled_aops gets used by
    default, which doesn't handle delayed allocation properly.
    
    The advantage of using ext4_should_writeback_data() approach is that
    it should handle nobh better as well.
    
    Thanks to Curt Wohlgemuth for investigating this problem, and Aneesh
    Kumar for suggesting this approach.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4_jbd2.h b/fs/ext4/ext4_jbd2.h
index be2f426f6805..d574a85aca56 100644
--- a/fs/ext4/ext4_jbd2.h
+++ b/fs/ext4/ext4_jbd2.h
@@ -281,10 +281,10 @@ static inline int ext4_should_order_data(struct inode *inode)
 
 static inline int ext4_should_writeback_data(struct inode *inode)
 {
-	if (EXT4_JOURNAL(inode) == NULL)
-		return 0;
 	if (!S_ISREG(inode-&gt;i_mode))
 		return 0;
+	if (EXT4_JOURNAL(inode) == NULL)
+		return 1;
 	if (EXT4_I(inode)-&gt;i_flags &amp; EXT4_JOURNAL_DATA_FL)
 		return 0;
 	if (test_opt(inode-&gt;i_sb, DATA_FLAGS) == EXT4_MOUNT_WRITEBACK_DATA)</pre><hr><pre>commit f4a01017d678fe4baecf480e79d7c4f4b7ebc772
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Jul 5 22:08:16 2009 -0400

    ext4: Fix potential reclaim deadlock when truncating partial block
    
    The ext4_block_truncate_page() function previously called
    grab_cache_page(), which called find_or_create_page() with the
    __GFP_FS flag potentially set.  This could cause a deadlock if the
    system is low on memory and it attempts a memory reclaim, which could
    potentially call back into ext4.  So we need to call
    find_or_create_page() directly, and remove the __GFP_FP flag to avoid
    this potential deadlock.
    
    Thanks to Roland Dreier for reporting a lockdep warning which showed
    this problem.
    
    [20786.363249] =================================
    [20786.363257] [ INFO: inconsistent lock state ]
    [20786.363265] 2.6.31-2-generic #14~rbd4gitd960eea9
    [20786.363270] ---------------------------------
    [20786.363276] inconsistent {IN-RECLAIM_FS-W} -&gt; {RECLAIM_FS-ON-W} usage.
    [20786.363285] http/8397 [HC0[0]:SC0[0]:HE1:SE1] takes:
    [20786.363291]  (jbd2_handle){+.+.?.}, at: [&lt;ffffffff812008bb&gt;] jbd2_journal_start+0xdb/0x150
    [20786.363314] {IN-RECLAIM_FS-W} state was registered at:
    [20786.363320]   [&lt;ffffffff8108bef6&gt;] mark_irqflags+0xc6/0x1a0
    [20786.363334]   [&lt;ffffffff8108d347&gt;] __lock_acquire+0x287/0x430
    [20786.363345]   [&lt;ffffffff8108d595&gt;] lock_acquire+0xa5/0x150
    [20786.363355]   [&lt;ffffffff812008da&gt;] jbd2_journal_start+0xfa/0x150
    [20786.363365]   [&lt;ffffffff811d98a8&gt;] ext4_journal_start_sb+0x58/0x90
    [20786.363377]   [&lt;ffffffff811cce85&gt;] ext4_delete_inode+0xc5/0x2c0
    [20786.363389]   [&lt;ffffffff81146fa3&gt;] generic_delete_inode+0xd3/0x1a0
    [20786.363401]   [&lt;ffffffff81147095&gt;] generic_drop_inode+0x25/0x30
    [20786.363411]   [&lt;ffffffff81145ce2&gt;] iput+0x62/0x70
    [20786.363420]   [&lt;ffffffff81142878&gt;] dentry_iput+0x98/0x110
    [20786.363429]   [&lt;ffffffff81142a00&gt;] d_kill+0x50/0x80
    [20786.363438]   [&lt;ffffffff811444c5&gt;] dput+0x95/0x180
    [20786.363447]   [&lt;ffffffff8120de4b&gt;] ecryptfs_d_release+0x2b/0x70
    [20786.363459]   [&lt;ffffffff81142978&gt;] d_free+0x28/0x60
    [20786.363468]   [&lt;ffffffff81142a18&gt;] d_kill+0x68/0x80
    [20786.363477]   [&lt;ffffffff81142ad3&gt;] prune_one_dentry+0xa3/0xc0
    [20786.363487]   [&lt;ffffffff81142d61&gt;] __shrink_dcache_sb+0x271/0x290
    [20786.363497]   [&lt;ffffffff81142e89&gt;] prune_dcache+0x109/0x1b0
    [20786.363506]   [&lt;ffffffff81142f6f&gt;] shrink_dcache_memory+0x3f/0x50
    [20786.363516]   [&lt;ffffffff810f6d3d&gt;] shrink_slab+0x12d/0x190
    [20786.363527]   [&lt;ffffffff810f97d7&gt;] balance_pgdat+0x4d7/0x640
    [20786.363537]   [&lt;ffffffff810f9a57&gt;] kswapd+0x117/0x170
    [20786.363546]   [&lt;ffffffff810773ce&gt;] kthread+0x9e/0xb0
    [20786.363558]   [&lt;ffffffff8101430a&gt;] child_rip+0xa/0x20
    [20786.363569]   [&lt;ffffffffffffffff&gt;] 0xffffffffffffffff
    [20786.363598] irq event stamp: 15997
    [20786.363603] hardirqs last  enabled at (15997): [&lt;ffffffff81125f9d&gt;] kmem_cache_alloc+0xfd/0x1a0
    [20786.363617] hardirqs last disabled at (15996): [&lt;ffffffff81125f01&gt;] kmem_cache_alloc+0x61/0x1a0
    [20786.363628] softirqs last  enabled at (15966): [&lt;ffffffff810631ea&gt;] __do_softirq+0x14a/0x220
    [20786.363641] softirqs last disabled at (15861): [&lt;ffffffff8101440c&gt;] call_softirq+0x1c/0x30
    [20786.363651]
    [20786.363653] other info that might help us debug this:
    [20786.363660] 3 locks held by http/8397:
    [20786.363665]  #0:  (&amp;sb-&gt;s_type-&gt;i_mutex_key#8){+.+.+.}, at: [&lt;ffffffff8112ed24&gt;] do_truncate+0x64/0x90
    [20786.363685]  #1:  (&amp;sb-&gt;s_type-&gt;i_alloc_sem_key#5){+++++.}, at: [&lt;ffffffff81147f90&gt;] notify_change+0x250/0x350
    [20786.363707]  #2:  (jbd2_handle){+.+.?.}, at: [&lt;ffffffff812008bb&gt;] jbd2_journal_start+0xdb/0x150
    [20786.363724]
    [20786.363726] stack backtrace:
    [20786.363734] Pid: 8397, comm: http Tainted: G         C 2.6.31-2-generic #14~rbd4gitd960eea9
    [20786.363741] Call Trace:
    [20786.363752]  [&lt;ffffffff8108ad7c&gt;] print_usage_bug+0x18c/0x1a0
    [20786.363763]  [&lt;ffffffff8108b0c0&gt;] ? check_usage_backwards+0x0/0xb0
    [20786.363773]  [&lt;ffffffff8108bad2&gt;] mark_lock_irq+0xf2/0x280
    [20786.363783]  [&lt;ffffffff8108bd97&gt;] mark_lock+0x137/0x1d0
    [20786.363793]  [&lt;ffffffff8108c03c&gt;] mark_held_locks+0x6c/0xa0
    [20786.363803]  [&lt;ffffffff8108c11f&gt;] lockdep_trace_alloc+0xaf/0xe0
    [20786.363813]  [&lt;ffffffff810efbac&gt;] __alloc_pages_nodemask+0x7c/0x180
    [20786.363824]  [&lt;ffffffff810e9411&gt;] ? find_get_page+0x91/0xf0
    [20786.363835]  [&lt;ffffffff8111d3b7&gt;] alloc_pages_current+0x87/0xd0
    [20786.363845]  [&lt;ffffffff810e9827&gt;] __page_cache_alloc+0x67/0x70
    [20786.363856]  [&lt;ffffffff810eb7df&gt;] find_or_create_page+0x4f/0xb0
    [20786.363867]  [&lt;ffffffff811cb3be&gt;] ext4_block_truncate_page+0x3e/0x460
    [20786.363876]  [&lt;ffffffff812008da&gt;] ? jbd2_journal_start+0xfa/0x150
    [20786.363885]  [&lt;ffffffff812008bb&gt;] ? jbd2_journal_start+0xdb/0x150
    [20786.363895]  [&lt;ffffffff811c6415&gt;] ? ext4_meta_trans_blocks+0x75/0xf0
    [20786.363905]  [&lt;ffffffff811e8d8b&gt;] ext4_ext_truncate+0x1bb/0x1e0
    [20786.363916]  [&lt;ffffffff811072c5&gt;] ? unmap_mapping_range+0x75/0x290
    [20786.363926]  [&lt;ffffffff811ccc28&gt;] ext4_truncate+0x498/0x630
    [20786.363938]  [&lt;ffffffff8129b4ce&gt;] ? _raw_spin_unlock+0x5e/0xb0
    [20786.363947]  [&lt;ffffffff81107306&gt;] ? unmap_mapping_range+0xb6/0x290
    [20786.363957]  [&lt;ffffffff8108c3ad&gt;] ? trace_hardirqs_on+0xd/0x10
    [20786.363966]  [&lt;ffffffff811ffe58&gt;] ? jbd2_journal_stop+0x1f8/0x2e0
    [20786.363976]  [&lt;ffffffff81107690&gt;] vmtruncate+0xb0/0x110
    [20786.363986]  [&lt;ffffffff81147c05&gt;] inode_setattr+0x35/0x170
    [20786.363995]  [&lt;ffffffff811c9906&gt;] ext4_setattr+0x186/0x370
    [20786.364005]  [&lt;ffffffff81147eab&gt;] notify_change+0x16b/0x350
    [20786.364014]  [&lt;ffffffff8112ed30&gt;] do_truncate+0x70/0x90
    [20786.364021]  [&lt;ffffffff8112f48b&gt;] T.657+0xeb/0x110
    [20786.364021]  [&lt;ffffffff8112f4be&gt;] sys_ftruncate+0xe/0x10
    [20786.364021]  [&lt;ffffffff81013132&gt;] system_call_fastpath+0x16/0x1b
    
    Reported-by: Roland Dreier &lt;roland@digitalvampire.org&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 60a26f3a6f8b..9760ba09275e 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -3583,7 +3583,8 @@ int ext4_block_truncate_page(handle_t *handle,
 	struct page *page;
 	int err = 0;
 
-	page = grab_cache_page(mapping, from &gt;&gt; PAGE_CACHE_SHIFT);
+	page = find_or_create_page(mapping, from &gt;&gt; PAGE_CACHE_SHIFT,
+				   mapping_gfp_mask(mapping) &amp; ~__GFP_FS);
 	if (!page)
 		return -EINVAL;
 </pre><hr><pre>commit b574480507460b8e31b8d38dd4642219fc3b9a10
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Jun 20 23:34:44 2009 -0400

    jbd2: Remove GFP_ATOMIC kmalloc from inside spinlock critical region
    
    Fix jbd2_dev_to_name(), a function used when pretty-printting jbd2 and
    ext4 tracepoints.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 18bfd5dab642..7b545c3b3942 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -2410,6 +2410,7 @@ const char *jbd2_dev_to_name(dev_t device)
 	int	i = hash_32(device, CACHE_SIZE_BITS);
 	char	*ret;
 	struct block_device *bd;
+	static struct devname_cache *new_dev;
 
 	rcu_read_lock();
 	if (devcache[i] &amp;&amp; devcache[i]-&gt;device == device) {
@@ -2419,20 +2420,20 @@ const char *jbd2_dev_to_name(dev_t device)
 	}
 	rcu_read_unlock();
 
+	new_dev = kmalloc(sizeof(struct devname_cache), GFP_KERNEL);
+	if (!new_dev)
+		return "NODEV-ALLOCFAILURE"; /* Something non-NULL */
 	spin_lock(&amp;devname_cache_lock);
 	if (devcache[i]) {
 		if (devcache[i]-&gt;device == device) {
+			kfree(new_dev);
 			ret = devcache[i]-&gt;devname;
 			spin_unlock(&amp;devname_cache_lock);
 			return ret;
 		}
 		call_rcu(&amp;devcache[i]-&gt;rcu, free_devcache);
 	}
-	devcache[i] = kmalloc(sizeof(struct devname_cache), GFP_KERNEL);
-	if (!devcache[i]) {
-		spin_unlock(&amp;devname_cache_lock);
-		return "NODEV-ALLOCFAILURE"; /* Something non-NULL */
-	}
+	devcache[i] = new_dev;
 	devcache[i]-&gt;device = device;
 	bd = bdget(device);
 	if (bd) {</pre><hr><pre>commit 627ad9fd0733f0a31a266ff98a4a933eee710f0b
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Jun 20 23:21:41 2009 -0400

    ext4: Fix type warning on 64-bit platforms in tracing events header
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index acf4cc9cd36d..b456fb0a3c57 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -34,7 +34,8 @@ TRACE_EVENT(ext4_free_inode,
 
 	TP_printk("dev %s ino %lu mode %d uid %u gid %u blocks %llu",
 		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;ino, __entry-&gt;mode,
-		  __entry-&gt;uid, __entry-&gt;gid, __entry-&gt;blocks)
+		  __entry-&gt;uid, __entry-&gt;gid,
+		  (unsigned long long) __entry-&gt;blocks)
 );
 
 TRACE_EVENT(ext4_request_inode,</pre><hr><pre>commit 88b6edd17c62b7d346d21f4087893ce7d4ef828a
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 25 11:50:39 2009 -0400

    ext4: Clean up calls to ext4_get_group_desc()
    
    If the caller isn't planning on modifying the block group descriptors,
    there's no need to pass in a pointer to a struct buffer_head.  Nuking
    this saves a tiny amount of CPU time and stack space usage.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 82f7d1d7eae0..3743bd849bce 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -347,7 +347,6 @@ static int find_group_flex(struct super_block *sb, struct inode *parent,
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	struct ext4_group_desc *desc;
-	struct buffer_head *bh;
 	struct flex_groups *flex_group = sbi-&gt;s_flex_groups;
 	ext4_group_t parent_group = EXT4_I(parent)-&gt;i_block_group;
 	ext4_group_t parent_fbg_group = ext4_flex_group(sbi, parent_group);
@@ -402,7 +401,7 @@ static int find_group_flex(struct super_block *sb, struct inode *parent,
 found_flexbg:
 	for (i = best_flex * flex_size; i &lt; ngroups &amp;&amp;
 		     i &lt; (best_flex + 1) * flex_size; i++) {
-		desc = ext4_get_group_desc(sb, i, &amp;bh);
+		desc = ext4_get_group_desc(sb, i, NULL);
 		if (ext4_free_inodes_count(sb, desc)) {
 			*best_group = i;
 			goto out;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index eca6c057b119..91b98b58ccb9 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1660,7 +1660,6 @@ static int ext4_fill_flex_info(struct super_block *sb)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	struct ext4_group_desc *gdp = NULL;
-	struct buffer_head *bh;
 	ext4_group_t flex_group_count;
 	ext4_group_t flex_group;
 	int groups_per_flex = 0;
@@ -1693,7 +1692,7 @@ static int ext4_fill_flex_info(struct super_block *sb)
 	}
 
 	for (i = 0; i &lt; sbi-&gt;s_groups_count; i++) {
-		gdp = ext4_get_group_desc(sb, i, &amp;bh);
+		gdp = ext4_get_group_desc(sb, i, NULL);
 
 		flex_group = ext4_flex_group(sbi, i);
 		atomic_set(&amp;sbi-&gt;s_flex_groups[flex_group].free_inodes,</pre><hr><pre>commit 759d427aa5a9d88a81afd11817cdeb40aea85234
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 25 11:51:00 2009 -0400

    ext4: remove unused function __ext4_write_dirty_metadata
    
    The __ext4_write_dirty_metadata() function was introduced by commit
    0390131b, "ext4: Allow ext4 to run without a journal", but nothing
    ever used the function, either then or since.  So let's remove it and
    save a bit of space.
    
    Cc: Frank Mayhar &lt;fmayhar@google.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index dadd3f995db5..14c00fff3713 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4790,25 +4790,6 @@ int ext4_write_inode(struct inode *inode, int wait)
 	return ext4_force_commit(inode-&gt;i_sb);
 }
 
-int __ext4_write_dirty_metadata(struct inode *inode, struct buffer_head *bh)
-{
-	int err = 0;
-
-	mark_buffer_dirty(bh);
-	if (inode &amp;&amp; inode_needs_sync(inode)) {
-		sync_dirty_buffer(bh);
-		if (buffer_req(bh) &amp;&amp; !buffer_uptodate(bh)) {
-			ext4_error(inode-&gt;i_sb, __func__,
-				   "IO error syncing inode, "
-				   "inode=%lu, block=%llu",
-				   inode-&gt;i_ino,
-				   (unsigned long long)bh-&gt;b_blocknr);
-			err = -EIO;
-		}
-	}
-	return err;
-}
-
 /*
  * ext4_setattr()
  *</pre><hr><pre>commit 0568c518937ee3a9b6a94d18bae9c150fe5d6832
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun May 17 23:31:23 2009 -0400

    ext4: down i_data_sem only for read when walking tree for fiemap
    
    Not sure why I put this in as down_write originally; all we are
    doing is walking the tree, nothing will change under us and
    concurrent reads should be no problem.
    
    Signed-off-by: Eric Sandeen &lt;sandeen@redhat.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index d04b779b780e..d4e99e96fddb 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -3312,10 +3312,10 @@ int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 		 * Walk the extent tree gathering extent information.
 		 * ext4_ext_fiemap_cb will push extents back to user.
 		 */
-		down_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
+		down_read(&amp;EXT4_I(inode)-&gt;i_data_sem);
 		error = ext4_ext_walk_space(inode, start_blk, len_blks,
 					  ext4_ext_fiemap_cb, fieinfo);
-		up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
+		up_read(&amp;EXT4_I(inode)-&gt;i_data_sem);
 	}
 
 	return error;</pre><hr><pre>commit 6fd058f7791087648c683eb8572edf3be3c4c23c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun May 17 15:38:01 2009 -0400

    ext4: Add a comprehensive block validity check to ext4_get_blocks()
    
    To catch filesystem bugs or corruption which could lead to the
    filesystem getting severly damaged, this patch adds a facility for
    tracking all of the filesystem metadata blocks by contiguous regions
    in a red-black tree.  This allows quick searching of the tree to
    locate extents which might overlap with filesystem metadata blocks.
    
    This facility is also used by the multi-block allocator to assure that
    it is not allocating blocks out of the system zone, as well as by the
    routines used when reading indirect blocks and extents information
    from disk to make sure their contents are valid.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/Makefile b/fs/ext4/Makefile
index a8ff003a00f7..8a34710ecf40 100644
--- a/fs/ext4/Makefile
+++ b/fs/ext4/Makefile
@@ -5,8 +5,8 @@
 obj-$(CONFIG_EXT4_FS) += ext4.o
 
 ext4-y	:= balloc.o bitmap.o dir.o file.o fsync.o ialloc.o inode.o \
-		   ioctl.o namei.o super.o symlink.o hash.o resize.o extents.o \
-		   ext4_jbd2.o migrate.o mballoc.o
+		ioctl.o namei.o super.o symlink.o hash.o resize.o extents.o \
+		ext4_jbd2.o migrate.o mballoc.o block_validity.o
 
 ext4-$(CONFIG_EXT4_FS_XATTR)		+= xattr.o xattr_user.o xattr_trusted.o
 ext4-$(CONFIG_EXT4_FS_POSIX_ACL)	+= acl.o
diff --git a/fs/ext4/block_validity.c b/fs/ext4/block_validity.c
new file mode 100644
index 000000000000..50784ef07563
--- /dev/null
+++ b/fs/ext4/block_validity.c
@@ -0,0 +1,244 @@
+/*
+ *  linux/fs/ext4/block_validity.c
+ *
+ * Copyright (C) 2009
+ * Theodore Ts'o (tytso@mit.edu)
+ *
+ * Track which blocks in the filesystem are metadata blocks that
+ * should never be used as data blocks by files or directories.
+ */
+
+#include &lt;linux/time.h&gt;
+#include &lt;linux/fs.h&gt;
+#include &lt;linux/namei.h&gt;
+#include &lt;linux/quotaops.h&gt;
+#include &lt;linux/buffer_head.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/swap.h&gt;
+#include &lt;linux/pagemap.h&gt;
+#include &lt;linux/version.h&gt;
+#include &lt;linux/blkdev.h&gt;
+#include &lt;linux/mutex.h&gt;
+#include "ext4.h"
+
+struct ext4_system_zone {
+	struct rb_node	node;
+	ext4_fsblk_t	start_blk;
+	unsigned int	count;
+};
+
+static struct kmem_cache *ext4_system_zone_cachep;
+
+int __init init_ext4_system_zone(void)
+{
+	ext4_system_zone_cachep = KMEM_CACHE(ext4_system_zone,
+					     SLAB_RECLAIM_ACCOUNT);
+	if (ext4_system_zone_cachep == NULL)
+		return -ENOMEM;
+	return 0;
+}
+
+void exit_ext4_system_zone(void)
+{
+	kmem_cache_destroy(ext4_system_zone_cachep);
+}
+
+static inline int can_merge(struct ext4_system_zone *entry1,
+		     struct ext4_system_zone *entry2)
+{
+	if ((entry1-&gt;start_blk + entry1-&gt;count) == entry2-&gt;start_blk)
+		return 1;
+	return 0;
+}
+
+/*
+ * Mark a range of blocks as belonging to the "system zone" --- that
+ * is, filesystem metadata blocks which should never be used by
+ * inodes.
+ */
+static int add_system_zone(struct ext4_sb_info *sbi,
+			   ext4_fsblk_t start_blk,
+			   unsigned int count)
+{
+	struct ext4_system_zone *new_entry = NULL, *entry;
+	struct rb_node **n = &amp;sbi-&gt;system_blks.rb_node, *node;
+	struct rb_node *parent = NULL, *new_node = NULL;
+
+	while (*n) {
+		parent = *n;
+		entry = rb_entry(parent, struct ext4_system_zone, node);
+		if (start_blk &lt; entry-&gt;start_blk)
+			n = &amp;(*n)-&gt;rb_left;
+		else if (start_blk &gt;= (entry-&gt;start_blk + entry-&gt;count))
+			n = &amp;(*n)-&gt;rb_right;
+		else {
+			if (start_blk + count &gt; (entry-&gt;start_blk + 
+						 entry-&gt;count))
+				entry-&gt;count = (start_blk + count - 
+						entry-&gt;start_blk);
+			new_node = *n;
+			new_entry = rb_entry(new_node, struct ext4_system_zone,
+					     node);
+			break;
+		}
+	}
+
+	if (!new_entry) {
+		new_entry = kmem_cache_alloc(ext4_system_zone_cachep,
+					     GFP_KERNEL);
+		if (!new_entry)
+			return -ENOMEM;
+		new_entry-&gt;start_blk = start_blk;
+		new_entry-&gt;count = count;
+		new_node = &amp;new_entry-&gt;node;
+
+		rb_link_node(new_node, parent, n);
+		rb_insert_color(new_node, &amp;sbi-&gt;system_blks);
+	}
+
+	/* Can we merge to the left? */
+	node = rb_prev(new_node);
+	if (node) {
+		entry = rb_entry(node, struct ext4_system_zone, node);
+		if (can_merge(entry, new_entry)) {
+			new_entry-&gt;start_blk = entry-&gt;start_blk;
+			new_entry-&gt;count += entry-&gt;count;
+			rb_erase(node, &amp;sbi-&gt;system_blks);
+			kmem_cache_free(ext4_system_zone_cachep, entry);
+		}
+	}
+
+	/* Can we merge to the right? */
+	node = rb_next(new_node);
+	if (node) {
+		entry = rb_entry(node, struct ext4_system_zone, node);
+		if (can_merge(new_entry, entry)) {
+			new_entry-&gt;count += entry-&gt;count;
+			rb_erase(node, &amp;sbi-&gt;system_blks);
+			kmem_cache_free(ext4_system_zone_cachep, entry);
+		}
+	}
+	return 0;
+}
+
+static void debug_print_tree(struct ext4_sb_info *sbi)
+{
+	struct rb_node *node;
+	struct ext4_system_zone *entry;
+	int first = 1;
+
+	printk(KERN_INFO "System zones: ");
+	node = rb_first(&amp;sbi-&gt;system_blks);
+	while (node) {
+		entry = rb_entry(node, struct ext4_system_zone, node);
+		printk("%s%llu-%llu", first ? "" : ", ",
+		       entry-&gt;start_blk, entry-&gt;start_blk + entry-&gt;count - 1);
+		first = 0;
+		node = rb_next(node);
+	}
+	printk("\n");
+}
+
+int ext4_setup_system_zone(struct super_block *sb)
+{
+	ext4_group_t ngroups = ext4_get_groups_count(sb);
+	struct ext4_sb_info *sbi = EXT4_SB(sb);
+	struct ext4_group_desc *gdp;
+	ext4_group_t i;
+	int flex_size = ext4_flex_bg_size(sbi);
+	int ret;
+
+	if (!test_opt(sb, BLOCK_VALIDITY)) {
+		if (EXT4_SB(sb)-&gt;system_blks.rb_node)
+			ext4_release_system_zone(sb);
+		return 0;
+	}
+	if (EXT4_SB(sb)-&gt;system_blks.rb_node)
+		return 0;
+
+	for (i=0; i &lt; ngroups; i++) {
+		if (ext4_bg_has_super(sb, i) &amp;&amp;
+		    ((i &lt; 5) || ((i % flex_size) == 0)))
+			add_system_zone(sbi, ext4_group_first_block_no(sb, i),
+					sbi-&gt;s_gdb_count + 1);
+		gdp = ext4_get_group_desc(sb, i, NULL);
+		ret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);
+		if (ret)
+			return ret;
+		ret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);
+		if (ret)
+			return ret;
+		ret = add_system_zone(sbi, ext4_inode_table(sb, gdp),
+				sbi-&gt;s_itb_per_group);
+		if (ret)
+			return ret;
+	}
+
+	if (test_opt(sb, DEBUG))
+		debug_print_tree(EXT4_SB(sb));
+	return 0;
+}
+
+/* Called when the filesystem is unmounted */
+void ext4_release_system_zone(struct super_block *sb)
+{
+	struct rb_node	*n = EXT4_SB(sb)-&gt;system_blks.rb_node;
+	struct rb_node	*parent;
+	struct ext4_system_zone	*entry;
+
+	while (n) {
+		/* Do the node's children first */
+		if (n-&gt;rb_left) {
+			n = n-&gt;rb_left;
+			continue;
+		}
+		if (n-&gt;rb_right) {
+			n = n-&gt;rb_right;
+			continue;
+		}
+		/*
+		 * The node has no children; free it, and then zero
+		 * out parent's link to it.  Finally go to the
+		 * beginning of the loop and try to free the parent
+		 * node.
+		 */
+		parent = rb_parent(n);
+		entry = rb_entry(n, struct ext4_system_zone, node);
+		kmem_cache_free(ext4_system_zone_cachep, entry);
+		if (!parent)
+			EXT4_SB(sb)-&gt;system_blks.rb_node = NULL;
+		else if (parent-&gt;rb_left == n)
+			parent-&gt;rb_left = NULL;
+		else if (parent-&gt;rb_right == n)
+			parent-&gt;rb_right = NULL;
+		n = parent;
+	}
+	EXT4_SB(sb)-&gt;system_blks.rb_node = NULL;
+}
+
+/*
+ * Returns 1 if the passed-in block region (start_blk,
+ * start_blk+count) is valid; 0 if some part of the block region
+ * overlaps with filesystem metadata blocks.
+ */
+int ext4_data_block_valid(struct ext4_sb_info *sbi, ext4_fsblk_t start_blk,
+			  unsigned int count)
+{
+	struct ext4_system_zone *entry;
+	struct rb_node *n = sbi-&gt;system_blks.rb_node;
+
+	if ((start_blk &lt;= le32_to_cpu(sbi-&gt;s_es-&gt;s_first_data_block)) ||
+	    (start_blk + count &gt; ext4_blocks_count(sbi-&gt;s_es)))
+		return 0;
+	while (n) {
+		entry = rb_entry(n, struct ext4_system_zone, node);
+		if (start_blk + count - 1 &lt; entry-&gt;start_blk)
+			n = n-&gt;rb_left;
+		else if (start_blk &gt;= (entry-&gt;start_blk + entry-&gt;count))
+			n = n-&gt;rb_right;
+		else
+			return 0;
+	}
+	return 1;
+}
+
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index d164f1294e5f..4311cc85b534 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -696,6 +696,7 @@ struct ext4_inode_info {
 #define EXT4_MOUNT_I_VERSION            0x2000000 /* i_version support */
 #define EXT4_MOUNT_DELALLOC		0x8000000 /* Delalloc support */
 #define EXT4_MOUNT_DATA_ERR_ABORT	0x10000000 /* Abort on file data write */
+#define EXT4_MOUNT_BLOCK_VALIDITY	0x20000000 /* Block validity checking */
 
 /* Compatibility, for having both ext2_fs.h and ext4_fs.h included at once */
 #ifndef _LINUX_EXT2_FS_H
@@ -887,6 +888,7 @@ struct ext4_sb_info {
 	int s_jquota_fmt;			/* Format of quota to use */
 #endif
 	unsigned int s_want_extra_isize; /* New inodes should reserve # bytes */
+	struct rb_root system_blks;
 
 #ifdef EXTENTS_STATS
 	/* ext4 extents stats */
@@ -1618,6 +1620,15 @@ extern struct dentry *ext4_get_parent(struct dentry *child);
 extern const struct inode_operations ext4_symlink_inode_operations;
 extern const struct inode_operations ext4_fast_symlink_inode_operations;
 
+/* block_validity */
+extern void ext4_release_system_zone(struct super_block *sb);
+extern int ext4_setup_system_zone(struct super_block *sb);
+extern int __init init_ext4_system_zone(void);
+extern void exit_ext4_system_zone(void);
+extern int ext4_data_block_valid(struct ext4_sb_info *sbi,
+				 ext4_fsblk_t start_blk,
+				 unsigned int count);
+
 /* extents.c */
 extern int ext4_ext_tree_init(handle_t *handle, struct inode *);
 extern int ext4_ext_writepage_trans_blocks(struct inode *, int);
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 27c383c7b43c..d04b779b780e 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -326,32 +326,18 @@ ext4_ext_max_entries(struct inode *inode, int depth)
 
 static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
 {
-	ext4_fsblk_t block = ext_pblock(ext), valid_block;
+	ext4_fsblk_t block = ext_pblock(ext);
 	int len = ext4_ext_get_actual_len(ext);
-	struct ext4_super_block *es = EXT4_SB(inode-&gt;i_sb)-&gt;s_es;
 
-	valid_block = le32_to_cpu(es-&gt;s_first_data_block) +
-		EXT4_SB(inode-&gt;i_sb)-&gt;s_gdb_count;
-	if (unlikely(block &lt;= valid_block ||
-		     ((block + len) &gt; ext4_blocks_count(es))))
-		return 0;
-	else
-		return 1;
+	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
 
 static int ext4_valid_extent_idx(struct inode *inode,
 				struct ext4_extent_idx *ext_idx)
 {
-	ext4_fsblk_t block = idx_pblock(ext_idx), valid_block;
-	struct ext4_super_block *es = EXT4_SB(inode-&gt;i_sb)-&gt;s_es;
+	ext4_fsblk_t block = idx_pblock(ext_idx);
 
-	valid_block = le32_to_cpu(es-&gt;s_first_data_block) +
-		EXT4_SB(inode-&gt;i_sb)-&gt;s_gdb_count;
-	if (unlikely(block &lt;= valid_block ||
-		     (block &gt;= ext4_blocks_count(es))))
-		return 0;
-	else
-		return 1;
+	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, 1);
 }
 
 static int ext4_valid_extent_entries(struct inode *inode,
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index d7b7480682b9..dadd3f995db5 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -372,20 +372,21 @@ static int ext4_block_to_path(struct inode *inode,
 }
 
 static int __ext4_check_blockref(const char *function, struct inode *inode,
-				 __le32 *p, unsigned int max) {
-
-	unsigned int maxblocks = ext4_blocks_count(EXT4_SB(inode-&gt;i_sb)-&gt;s_es);
+				 __le32 *p, unsigned int max)
+{
 	__le32 *bref = p;
+	unsigned int blk;
+
 	while (bref &lt; p+max) {
-		if (unlikely(le32_to_cpu(*bref) &gt;= maxblocks)) {
+		blk = le32_to_cpu(*bref++);
+		if (blk &amp;&amp; 
+		    unlikely(!ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), 
+						    blk, 1))) {
 			ext4_error(inode-&gt;i_sb, function,
-				   "block reference %u &gt;= max (%u) "
-				   "in inode #%lu, offset=%d",
-				   le32_to_cpu(*bref), maxblocks,
-				   inode-&gt;i_ino, (int)(bref-p));
+				   "invalid block reference %u "
+				   "in inode #%lu", blk, inode-&gt;i_ino);
  			return -EIO;
  		}
-		bref++;
  	}
  	return 0;
 }
@@ -1125,6 +1126,21 @@ static void ext4_da_update_reserve_space(struct inode *inode, int used)
 		ext4_discard_preallocations(inode);
 }
 
+static int check_block_validity(struct inode *inode, sector_t logical,
+				sector_t phys, int len)
+{
+	if (!ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), phys, len)) {
+		ext4_error(inode-&gt;i_sb, "check_block_validity",
+			   "inode #%lu logical block %llu mapped to %llu "
+			   "(size %d)", inode-&gt;i_ino,
+			   (unsigned long long) logical,
+			   (unsigned long long) phys, len);
+		WARN_ON(1);
+		return -EIO;
+	}
+	return 0;
+}
+
 /*
  * The ext4_get_blocks() function tries to look up the requested blocks,
  * and returns if the blocks are already mapped.
@@ -1170,6 +1186,13 @@ int ext4_get_blocks(handle_t *handle, struct inode *inode, sector_t block,
 	}
 	up_read((&amp;EXT4_I(inode)-&gt;i_data_sem));
 
+	if (retval &gt; 0 &amp;&amp; buffer_mapped(bh)) {
+		int ret = check_block_validity(inode, block, 
+					       bh-&gt;b_blocknr, retval);
+		if (ret != 0)
+			return ret;
+	}
+
 	/* If it is only a block(s) look up */
 	if ((flags &amp; EXT4_GET_BLOCKS_CREATE) == 0)
 		return retval;
@@ -1245,6 +1268,12 @@ int ext4_get_blocks(handle_t *handle, struct inode *inode, sector_t block,
 		ext4_da_update_reserve_space(inode, retval);
 
 	up_write((&amp;EXT4_I(inode)-&gt;i_data_sem));
+	if (retval &gt; 0 &amp;&amp; buffer_mapped(bh)) {
+		int ret = check_block_validity(inode, block, 
+					       bh-&gt;b_blocknr, retval);
+		if (ret != 0)
+			return ret;
+	}
 	return retval;
 }
 
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 541bd9adffa2..ed8482e22c0e 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -2961,15 +2961,10 @@ ext4_mb_mark_diskspace_used(struct ext4_allocation_context *ac,
 		+ le32_to_cpu(es-&gt;s_first_data_block);
 
 	len = ac-&gt;ac_b_ex.fe_len;
-	if (in_range(ext4_block_bitmap(sb, gdp), block, len) ||
-	    in_range(ext4_inode_bitmap(sb, gdp), block, len) ||
-	    in_range(block, ext4_inode_table(sb, gdp),
-		     EXT4_SB(sb)-&gt;s_itb_per_group) ||
-	    in_range(block + len - 1, ext4_inode_table(sb, gdp),
-		     EXT4_SB(sb)-&gt;s_itb_per_group)) {
+	if (!ext4_data_block_valid(sbi, block, len)) {
 		ext4_error(sb, __func__,
-			   "Allocating block %llu in system zone of %d group\n",
-			   block, ac-&gt;ac_b_ex.fe_group);
+			   "Allocating blocks %llu-%llu which overlap "
+			   "fs metadata\n", block, block+len);
 		/* File system mounted not to panic on error
 		 * Fix the bitmap and repeat the block allocation
 		 * We leak some of the blocks here.
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index dc34ed3d1327..600b7ad699b5 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -568,6 +568,7 @@ static void ext4_put_super(struct super_block *sb)
 	struct ext4_super_block *es = sbi-&gt;s_es;
 	int i, err;
 
+	ext4_release_system_zone(sb);
 	ext4_mb_release(sb);
 	ext4_ext_release(sb);
 	ext4_xattr_put_super(sb);
@@ -1055,6 +1056,7 @@ enum {
 	Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err, Opt_resize,
 	Opt_usrquota, Opt_grpquota, Opt_i_version,
 	Opt_stripe, Opt_delalloc, Opt_nodelalloc,
+	Opt_block_validity, Opt_noblock_validity,
 	Opt_inode_readahead_blks, Opt_journal_ioprio
 };
 
@@ -1114,6 +1116,8 @@ static const match_table_t tokens = {
 	{Opt_resize, "resize"},
 	{Opt_delalloc, "delalloc"},
 	{Opt_nodelalloc, "nodelalloc"},
+	{Opt_block_validity, "block_validity"},
+	{Opt_noblock_validity, "noblock_validity"},
 	{Opt_inode_readahead_blks, "inode_readahead_blks=%u"},
 	{Opt_journal_ioprio, "journal_ioprio=%u"},
 	{Opt_auto_da_alloc, "auto_da_alloc=%u"},
@@ -1508,6 +1512,12 @@ static int parse_options(char *options, struct super_block *sb,
 		case Opt_delalloc:
 			set_opt(sbi-&gt;s_mount_opt, DELALLOC);
 			break;
+		case Opt_block_validity:
+			set_opt(sbi-&gt;s_mount_opt, BLOCK_VALIDITY);
+			break;
+		case Opt_noblock_validity:
+			clear_opt(sbi-&gt;s_mount_opt, BLOCK_VALIDITY);
+			break;
 		case Opt_inode_readahead_blks:
 			if (match_int(&amp;args[0], &amp;option))
 				return 0;
@@ -2826,6 +2836,13 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	} else if (test_opt(sb, DELALLOC))
 		printk(KERN_INFO "EXT4-fs: delayed allocation enabled\n");
 
+	err = ext4_setup_system_zone(sb);
+	if (err) {
+		printk(KERN_ERR "EXT4-fs: failed to initialize system "
+		       "zone (%d)\n", err);
+		goto failed_mount4;
+	}
+
 	ext4_ext_init(sb);
 	err = ext4_mb_init(sb, needs_recovery);
 	if (err) {
@@ -2875,6 +2892,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 
 failed_mount4:
 	printk(KERN_ERR "EXT4-fs (device %s): mount failed\n", sb-&gt;s_id);
+	ext4_release_system_zone(sb);
 	if (sbi-&gt;s_journal) {
 		jbd2_journal_destroy(sbi-&gt;s_journal);
 		sbi-&gt;s_journal = NULL;
@@ -3515,6 +3533,7 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 				sb-&gt;s_flags &amp;= ~MS_RDONLY;
 		}
 	}
+	ext4_setup_system_zone(sb);
 	if (sbi-&gt;s_journal == NULL)
 		ext4_commit_super(sb, 1);
 
@@ -3927,13 +3946,16 @@ static int __init init_ext4_fs(void)
 {
 	int err;
 
+	err = init_ext4_system_zone();
+	if (err)
+		return err;
 	ext4_kset = kset_create_and_add("ext4", NULL, fs_kobj);
 	if (!ext4_kset)
-		return -ENOMEM;
+		goto out4;
 	ext4_proc_root = proc_mkdir("fs/ext4", NULL);
 	err = init_ext4_mballoc();
 	if (err)
-		return err;
+		goto out3;
 
 	err = init_ext4_xattr();
 	if (err)
@@ -3958,6 +3980,11 @@ static int __init init_ext4_fs(void)
 	exit_ext4_xattr();
 out2:
 	exit_ext4_mballoc();
+out3:
+	remove_proc_entry("fs/ext4", NULL);
+	kset_unregister(ext4_kset);
+out4:
+	exit_ext4_system_zone();
 	return err;
 }
 
@@ -3972,6 +3999,7 @@ static void __exit exit_ext4_fs(void)
 	exit_ext4_mballoc();
 	remove_proc_entry("fs/ext4", NULL);
 	kset_unregister(ext4_kset);
+	exit_ext4_system_zone();
 }
 
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");</pre>
    <div class="pagination">
        <a href='1_92.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><span>[93]</span><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_94.html'>Next&gt;&gt;</a>
    <div>
</body>
