<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_27.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><span>[28]</span><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_29.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 31ed0bf439a15363c28c7a239f52eb127cb6feb3
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Feb 26 12:35:23 2008 -0600

    [SCSI] iscsi regression: check for zero max session cmds
    
    The old tools did not set max session cmds. This is a regression.
    I removed the check when merging the power of 2 patch.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 59f8445eab0d..bdd7de7da39a 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1708,8 +1708,8 @@ iscsi_session_setup(struct iscsi_transport *iscsit,
 		qdepth = ISCSI_DEF_CMD_PER_LUN;
 	}
 
-	if (!is_power_of_2(cmds_max) ||
-	    cmds_max &gt;= ISCSI_MGMT_ITT_OFFSET) {
+	if (!is_power_of_2(cmds_max) || cmds_max &gt;= ISCSI_MGMT_ITT_OFFSET ||
+	    cmds_max &lt; 2) {
 		if (cmds_max != 0)
 			printk(KERN_ERR "iscsi: invalid can_queue of %d. "
 			       "can_queue must be a power of 2 and between "
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 9981682d5302..dfb026b95a6a 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -33,7 +33,7 @@
 #define ISCSI_SESSION_ATTRS 19
 #define ISCSI_CONN_ATTRS 13
 #define ISCSI_HOST_ATTRS 4
-#define ISCSI_TRANSPORT_VERSION "2.0-868"
+#define ISCSI_TRANSPORT_VERSION "2.0-869"
 
 struct iscsi_internal {
 	int daemon_pid;</pre><hr><pre>commit 4c851879312702456c7fbd594f19a7a9d991c252
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:54 2008 -0600

    [SCSI] iscsi: bump version to 2.0-868
    
    Set iscsi version to 2.0-868
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 8e73ff02fb74..fac7534f3ec4 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -33,7 +33,7 @@
 #define ISCSI_SESSION_ATTRS 19
 #define ISCSI_CONN_ATTRS 13
 #define ISCSI_HOST_ATTRS 4
-#define ISCSI_TRANSPORT_VERSION "2.0-867"
+#define ISCSI_TRANSPORT_VERSION "2.0-868"
 
 struct iscsi_internal {
 	int daemon_pid;</pre><hr><pre>commit 8b1d03434ee44b08c57f50403eaeab099facebf5
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:53 2008 -0600

    [SCSI] libiscsi: fix session age rollover and remove cid encoding
    
    The session age mask is only 4 bits, but session-&gt;age is 32. When
    it gets larger then 15 and we try to or the bits some bits get
    dropped and the check for session age in iscsi_verify_itt is useless.
    
    The ISCSI_CID_MASK related bits are also useless since cid is always
    one.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 10ba76285852..59f8445eab0d 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -160,7 +160,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
 	hdr-&gt;opcode = ISCSI_OP_SCSI_CMD;
 	hdr-&gt;flags = ISCSI_ATTR_SIMPLE;
 	int_to_scsilun(sc-&gt;device-&gt;lun, (struct scsi_lun *)hdr-&gt;lun);
-	hdr-&gt;itt = build_itt(ctask-&gt;itt, conn-&gt;id, session-&gt;age);
+	hdr-&gt;itt = build_itt(ctask-&gt;itt, session-&gt;age);
 	hdr-&gt;data_length = cpu_to_be32(scsi_bufflen(sc));
 	hdr-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	session-&gt;cmdsn++;
@@ -705,14 +705,6 @@ int iscsi_verify_itt(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 			return ISCSI_ERR_BAD_ITT;
 		}
 
-		if (((__force u32)hdr-&gt;itt &amp; ISCSI_CID_MASK) !=
-		    (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT)) {
-			iscsi_conn_printk(KERN_ERR, conn,
-					  "iscsi: received itt %x, expected "
-					  "CID (%x)\n",
-					  (__force u32)hdr-&gt;itt, conn-&gt;id);
-			return ISCSI_ERR_BAD_ITT;
-		}
 		itt = get_itt(hdr-&gt;itt);
 	} else
 		itt = ~0U;
@@ -776,7 +768,7 @@ static void iscsi_prep_mtask(struct iscsi_conn *conn,
 	 */
 	nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	if (hdr-&gt;itt != RESERVED_ITT) {
-		hdr-&gt;itt = build_itt(mtask-&gt;itt, conn-&gt;id, session-&gt;age);
+		hdr-&gt;itt = build_itt(mtask-&gt;itt, session-&gt;age);
 		/*
 		 * TODO: We always use immediate, so we never hit this.
 		 * If we start to send tmfs or nops as non-immediate then
@@ -2036,6 +2028,8 @@ int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 		conn-&gt;stop_stage = 0;
 		conn-&gt;tmf_state = TMF_INITIAL;
 		session-&gt;age++;
+		if (session-&gt;age == 16)
+			session-&gt;age = 0;
 		break;
 	case STOP_CONN_TERM:
 		conn-&gt;stop_stage = 0;
diff --git a/include/scsi/iscsi_proto.h b/include/scsi/iscsi_proto.h
index 318a909e7ae1..5ffec8ad6964 100644
--- a/include/scsi/iscsi_proto.h
+++ b/include/scsi/iscsi_proto.h
@@ -45,8 +45,8 @@
 /* initiator tags; opaque for target */
 typedef uint32_t __bitwise__ itt_t;
 /* below makes sense only for initiator that created this tag */
-#define build_itt(itt, id, age) ((__force itt_t)\
-	((itt) | ((id) &lt;&lt; ISCSI_CID_SHIFT) | ((age) &lt;&lt; ISCSI_AGE_SHIFT)))
+#define build_itt(itt, age) ((__force itt_t)\
+	((itt) | ((age) &lt;&lt; ISCSI_AGE_SHIFT)))
 #define get_itt(itt) ((__force uint32_t)(itt_t)(itt) &amp; ISCSI_ITT_MASK)
 #define RESERVED_ITT ((__force itt_t)0xffffffff)
 
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 5784e4ff8edc..7b90b63fb5c7 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -70,8 +70,6 @@ enum {
 #define ISCSI_SUSPEND_BIT		1
 
 #define ISCSI_ITT_MASK			(0xfff)
-#define ISCSI_CID_SHIFT			12
-#define ISCSI_CID_MASK			(0xffff &lt;&lt; ISCSI_CID_SHIFT)
 #define ISCSI_AGE_SHIFT			28
 #define ISCSI_AGE_MASK			(0xf &lt;&lt; ISCSI_AGE_SHIFT)
 </pre><hr><pre>commit 322d739da83bbff0309c202181f79c08d9534880
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:52 2008 -0600

    [SCSI] iscsi: fix up iscsi printk prefix
    
    Some iscsi class messages have the dev_printk prefix and some libiscsi
    and iscsi_tcp messages have "iscsi" or the module name as a prefix which
    is normally pretty useless when trying to figure out which session
    or connection the message is attached to. This patch adds iscsi lib
    and class dev_printks so all messages have a common prefix that
    can be used to figure out which object printed it.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index b6f99dfbb038..8a178674cb18 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -629,8 +629,9 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	int rc;
 
 	if (tcp_conn-&gt;in.datalen) {
-		printk(KERN_ERR "iscsi_tcp: invalid R2t with datalen %d\n",
-		       tcp_conn-&gt;in.datalen);
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "invalid R2t with datalen %d\n",
+				  tcp_conn-&gt;in.datalen);
 		return ISCSI_ERR_DATALEN;
 	}
 
@@ -644,8 +645,9 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	iscsi_update_cmdsn(session, (struct iscsi_nopin*)rhdr);
 
 	if (!ctask-&gt;sc || session-&gt;state != ISCSI_STATE_LOGGED_IN) {
-		printk(KERN_INFO "iscsi_tcp: dropping R2T itt %d in "
-		       "recovery...\n", ctask-&gt;itt);
+		iscsi_conn_printk(KERN_INFO, conn,
+				  "dropping R2T itt %d in recovery.\n",
+				  ctask-&gt;itt);
 		return 0;
 	}
 
@@ -655,7 +657,8 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	r2t-&gt;exp_statsn = rhdr-&gt;statsn;
 	r2t-&gt;data_length = be32_to_cpu(rhdr-&gt;data_length);
 	if (r2t-&gt;data_length == 0) {
-		printk(KERN_ERR "iscsi_tcp: invalid R2T with zero data len\n");
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "invalid R2T with zero data len\n");
 		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
@@ -668,9 +671,10 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	r2t-&gt;data_offset = be32_to_cpu(rhdr-&gt;data_offset);
 	if (r2t-&gt;data_offset + r2t-&gt;data_length &gt; scsi_bufflen(ctask-&gt;sc)) {
-		printk(KERN_ERR "iscsi_tcp: invalid R2T with data len %u at "
-		       "offset %u and total length %d\n", r2t-&gt;data_length,
-		       r2t-&gt;data_offset, scsi_bufflen(ctask-&gt;sc));
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "invalid R2T with data len %u at offset %u "
+				  "and total length %d\n", r2t-&gt;data_length,
+				  r2t-&gt;data_offset, scsi_bufflen(ctask-&gt;sc));
 		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
@@ -736,8 +740,9 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 	/* verify PDU length */
 	tcp_conn-&gt;in.datalen = ntoh24(hdr-&gt;dlength);
 	if (tcp_conn-&gt;in.datalen &gt; conn-&gt;max_recv_dlength) {
-		printk(KERN_ERR "iscsi_tcp: datalen %d &gt; %d\n",
-		       tcp_conn-&gt;in.datalen, conn-&gt;max_recv_dlength);
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "iscsi_tcp: datalen %d &gt; %d\n",
+				  tcp_conn-&gt;in.datalen, conn-&gt;max_recv_dlength);
 		return ISCSI_ERR_DATALEN;
 	}
 
@@ -819,10 +824,12 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 		 * For now we fail until we find a vendor that needs it
 		 */
 		if (ISCSI_DEF_MAX_RECV_SEG_LEN &lt; tcp_conn-&gt;in.datalen) {
-			printk(KERN_ERR "iscsi_tcp: received buffer of len %u "
-			      "but conn buffer is only %u (opcode %0x)\n",
-			      tcp_conn-&gt;in.datalen,
-			      ISCSI_DEF_MAX_RECV_SEG_LEN, opcode);
+			iscsi_conn_printk(KERN_ERR, conn,
+					  "iscsi_tcp: received buffer of "
+					  "len %u but conn buffer is only %u "
+					  "(opcode %0x)\n",
+					  tcp_conn-&gt;in.datalen,
+					  ISCSI_DEF_MAX_RECV_SEG_LEN, opcode);
 			rc = ISCSI_ERR_PROTO;
 			break;
 		}
@@ -1496,30 +1503,25 @@ iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	tcp_conn-&gt;tx_hash.tfm = crypto_alloc_hash("crc32c", 0,
 						  CRYPTO_ALG_ASYNC);
 	tcp_conn-&gt;tx_hash.flags = 0;
-	if (IS_ERR(tcp_conn-&gt;tx_hash.tfm)) {
-		printk(KERN_ERR "Could not create connection due to crc32c "
-		       "loading error %ld. Make sure the crc32c module is "
-		       "built as a module or into the kernel\n",
-			PTR_ERR(tcp_conn-&gt;tx_hash.tfm));
+	if (IS_ERR(tcp_conn-&gt;tx_hash.tfm))
 		goto free_tcp_conn;
-	}
 
 	tcp_conn-&gt;rx_hash.tfm = crypto_alloc_hash("crc32c", 0,
 						  CRYPTO_ALG_ASYNC);
 	tcp_conn-&gt;rx_hash.flags = 0;
-	if (IS_ERR(tcp_conn-&gt;rx_hash.tfm)) {
-		printk(KERN_ERR "Could not create connection due to crc32c "
-		       "loading error %ld. Make sure the crc32c module is "
-		       "built as a module or into the kernel\n",
-			PTR_ERR(tcp_conn-&gt;rx_hash.tfm));
+	if (IS_ERR(tcp_conn-&gt;rx_hash.tfm))
 		goto free_tx_tfm;
-	}
 
 	return cls_conn;
 
 free_tx_tfm:
 	crypto_free_hash(tcp_conn-&gt;tx_hash.tfm);
 free_tcp_conn:
+	iscsi_conn_printk(KERN_ERR, conn,
+			  "Could not create connection due to crc32c "
+			  "loading error. Make sure the crc32c "
+			  "module is built as a module or into the "
+			  "kernel\n");
 	kfree(tcp_conn);
 tcp_conn_alloc_fail:
 	iscsi_conn_teardown(cls_conn);
@@ -1627,7 +1629,8 @@ iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 	/* lookup for existing socket */
 	sock = sockfd_lookup((int)transport_eph, &amp;err);
 	if (!sock) {
-		printk(KERN_ERR "iscsi_tcp: sockfd_lookup failed %d\n", err);
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "sockfd_lookup failed %d\n", err);
 		return -EEXIST;
 	}
 	/*
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index b2a1ec8725b8..10ba76285852 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -416,8 +416,9 @@ static void iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 
 		if (datalen &lt; 2) {
 invalid_datalen:
-			printk(KERN_ERR "iscsi: Got CHECK_CONDITION but "
-			       "invalid data buffer size of %d\n", datalen);
+			iscsi_conn_printk(KERN_ERR,  conn,
+					 "Got CHECK_CONDITION but invalid data "
+					 "buffer size of %d\n", datalen);
 			sc-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
 			goto out;
 		}
@@ -494,7 +495,7 @@ static void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)
 
 	mtask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)&amp;hdr, NULL, 0);
 	if (!mtask) {
-		printk(KERN_ERR "Could not send nopout\n");
+		iscsi_conn_printk(KERN_ERR, conn, "Could not send nopout\n");
 		return;
 	}
 
@@ -522,9 +523,10 @@ static int iscsi_handle_reject(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		if (ntoh24(reject-&gt;dlength) &gt;= sizeof(struct iscsi_hdr)) {
 			memcpy(&amp;rejected_pdu, data, sizeof(struct iscsi_hdr));
 			itt = get_itt(rejected_pdu.itt);
-			printk(KERN_ERR "itt 0x%x had pdu (op 0x%x) rejected "
-				"due to DataDigest error.\n", itt,
-				rejected_pdu.opcode);
+			iscsi_conn_printk(KERN_ERR, conn,
+					  "itt 0x%x had pdu (op 0x%x) rejected "
+					  "due to DataDigest error.\n", itt,
+					  rejected_pdu.opcode);
 		}
 	}
 	return 0;
@@ -696,16 +698,19 @@ int iscsi_verify_itt(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	if (hdr-&gt;itt != RESERVED_ITT) {
 		if (((__force u32)hdr-&gt;itt &amp; ISCSI_AGE_MASK) !=
 		    (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT)) {
-			printk(KERN_ERR "iscsi: received itt %x expected "
-				"session age (%x)\n", (__force u32)hdr-&gt;itt,
-				session-&gt;age &amp; ISCSI_AGE_MASK);
+			iscsi_conn_printk(KERN_ERR, conn,
+					  "received itt %x expected session "
+					  "age (%x)\n", (__force u32)hdr-&gt;itt,
+					  session-&gt;age &amp; ISCSI_AGE_MASK);
 			return ISCSI_ERR_BAD_ITT;
 		}
 
 		if (((__force u32)hdr-&gt;itt &amp; ISCSI_CID_MASK) !=
 		    (conn-&gt;id &lt;&lt; ISCSI_CID_SHIFT)) {
-			printk(KERN_ERR "iscsi: received itt %x, expected "
-				"CID (%x)\n", (__force u32)hdr-&gt;itt, conn-&gt;id);
+			iscsi_conn_printk(KERN_ERR, conn,
+					  "iscsi: received itt %x, expected "
+					  "CID (%x)\n",
+					  (__force u32)hdr-&gt;itt, conn-&gt;id);
 			return ISCSI_ERR_BAD_ITT;
 		}
 		itt = get_itt(hdr-&gt;itt);
@@ -716,16 +721,17 @@ int iscsi_verify_itt(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		ctask = session-&gt;cmds[itt];
 
 		if (!ctask-&gt;sc) {
-			printk(KERN_INFO "iscsi: dropping ctask with "
-			       "itt 0x%x\n", ctask-&gt;itt);
+			iscsi_conn_printk(KERN_INFO, conn, "dropping ctask "
+					  "with itt 0x%x\n", ctask-&gt;itt);
 			/* force drop */
 			return ISCSI_ERR_NO_SCSI_CMD;
 		}
 
 		if (ctask-&gt;sc-&gt;SCp.phase != session-&gt;age) {
-			printk(KERN_ERR "iscsi: ctask's session age %d, "
-				"expected %d\n", ctask-&gt;sc-&gt;SCp.phase,
-				session-&gt;age);
+			iscsi_conn_printk(KERN_ERR, conn,
+					  "iscsi: ctask's session age %d, "
+					  "expected %d\n", ctask-&gt;sc-&gt;SCp.phase,
+					  session-&gt;age);
 			return ISCSI_ERR_SESSION_FAILED;
 		}
 	}
@@ -1170,7 +1176,8 @@ int iscsi_eh_host_reset(struct scsi_cmnd *sc)
 	mutex_lock(&amp;session-&gt;eh_mutex);
 	spin_lock_bh(&amp;session-&gt;lock);
 	if (session-&gt;state == ISCSI_STATE_LOGGED_IN)
-		printk(KERN_INFO "iscsi: host reset succeeded\n");
+		iscsi_session_printk(KERN_INFO, session,
+				     "host reset succeeded\n");
 	else
 		goto failed;
 	spin_unlock_bh(&amp;session-&gt;lock);
@@ -1368,10 +1375,10 @@ static void iscsi_check_transport_timeouts(unsigned long data)
 	last_recv = conn-&gt;last_recv;
 	if (time_before_eq(last_recv + timeout + (conn-&gt;ping_timeout * HZ),
 			   jiffies)) {
-		printk(KERN_ERR "ping timeout of %d secs expired, "
-		       "last rx %lu, last ping %lu, now %lu\n",
-		       conn-&gt;ping_timeout, last_recv,
-		       conn-&gt;last_ping, jiffies);
+		iscsi_conn_printk(KERN_ERR, conn, "ping timeout of %d secs "
+				  "expired, last rx %lu, last ping %lu, "
+				  "now %lu\n", conn-&gt;ping_timeout, last_recv,
+				  conn-&gt;last_ping, jiffies);
 		spin_unlock(&amp;session-&gt;lock);
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 		return;
@@ -1952,9 +1959,10 @@ void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
 		}
 		spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);
 		msleep_interruptible(500);
-		printk(KERN_INFO "iscsi: scsi conn_destroy(): host_busy %d "
-		       "host_failed %d\n", session-&gt;host-&gt;host_busy,
-		       session-&gt;host-&gt;host_failed);
+		iscsi_conn_printk(KERN_INFO, conn, "iscsi conn_destroy(): "
+				  "host_busy %d host_failed %d\n",
+				  session-&gt;host-&gt;host_busy,
+				  session-&gt;host-&gt;host_failed);
 		/*
 		 * force eh_abort() to unblock
 		 */
@@ -1983,27 +1991,28 @@ int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 	struct iscsi_session *session = conn-&gt;session;
 
 	if (!session) {
-		printk(KERN_ERR "iscsi: can't start unbound connection\n");
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "can't start unbound connection\n");
 		return -EPERM;
 	}
 
 	if ((session-&gt;imm_data_en || !session-&gt;initial_r2t_en) &amp;&amp;
 	     session-&gt;first_burst &gt; session-&gt;max_burst) {
-		printk("iscsi: invalid burst lengths: "
-		       "first_burst %d max_burst %d\n",
-		       session-&gt;first_burst, session-&gt;max_burst);
+		iscsi_conn_printk(KERN_INFO, conn, "invalid burst lengths: "
+				  "first_burst %d max_burst %d\n",
+				  session-&gt;first_burst, session-&gt;max_burst);
 		return -EINVAL;
 	}
 
 	if (conn-&gt;ping_timeout &amp;&amp; !conn-&gt;recv_timeout) {
-		printk(KERN_ERR "iscsi: invalid recv timeout of zero "
-		      "Using 5 seconds\n.");
+		iscsi_conn_printk(KERN_ERR, conn, "invalid recv timeout of "
+				  "zero. Using 5 seconds\n.");
 		conn-&gt;recv_timeout = 5;
 	}
 
 	if (conn-&gt;recv_timeout &amp;&amp; !conn-&gt;ping_timeout) {
-		printk(KERN_ERR "iscsi: invalid ping timeout of zero "
-		      "Using 5 seconds.\n");
+		iscsi_conn_printk(KERN_ERR, conn, "invalid ping timeout of "
+				  "zero. Using 5 seconds.\n");
 		conn-&gt;ping_timeout = 5;
 	}
 
@@ -2147,7 +2156,8 @@ void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 		iscsi_start_session_recovery(session, conn, flag);
 		break;
 	default:
-		printk(KERN_ERR "iscsi: invalid stop flag %d\n", flag);
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "invalid stop flag %d\n", flag);
 	}
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_stop);
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 35834bf4ba86..8e73ff02fb74 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -350,8 +350,9 @@ static void session_recovery_timedout(struct work_struct *work)
 			     recovery_work.work);
 	unsigned long flags;
 
-	dev_printk(KERN_INFO, &amp;session-&gt;dev, "iscsi: session recovery timed "
-		  "out after %d secs\n", session-&gt;recovery_tmo);
+	iscsi_cls_session_printk(KERN_INFO, session,
+				 "session recovery timed out after %d secs\n",
+				 session-&gt;recovery_tmo);
 
 	spin_lock_irqsave(&amp;session-&gt;lock, flags);
 	switch (session-&gt;state) {
@@ -492,8 +493,8 @@ int iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)
 		 session-&gt;sid);
 	err = device_add(&amp;session-&gt;dev);
 	if (err) {
-		dev_printk(KERN_ERR, &amp;session-&gt;dev, "iscsi: could not "
-			   "register session's dev\n");
+		iscsi_cls_session_printk(KERN_ERR, session,
+					 "could not register session's dev\n");
 		goto release_host;
 	}
 	transport_register_device(&amp;session-&gt;dev);
@@ -597,8 +598,9 @@ void iscsi_remove_session(struct iscsi_cls_session *session)
 	err = device_for_each_child(&amp;session-&gt;dev, NULL,
 				    iscsi_iter_destroy_conn_fn);
 	if (err)
-		dev_printk(KERN_ERR, &amp;session-&gt;dev, "iscsi: Could not delete "
-			   "all connections for session. Error %d.\n", err);
+		iscsi_cls_session_printk(KERN_ERR, session,
+					 "Could not delete all connections "
+					 "for session. Error %d.\n", err);
 
 	transport_unregister_device(&amp;session-&gt;dev);
 	device_del(&amp;session-&gt;dev);
@@ -670,8 +672,8 @@ iscsi_create_conn(struct iscsi_cls_session *session, uint32_t cid)
 	conn-&gt;dev.release = iscsi_conn_release;
 	err = device_register(&amp;conn-&gt;dev);
 	if (err) {
-		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: could not register "
-			   "connection's dev\n");
+		iscsi_cls_session_printk(KERN_ERR, session, "could not "
+					 "register connection's dev\n");
 		goto release_parent_ref;
 	}
 	transport_register_device(&amp;conn-&gt;dev);
@@ -778,8 +780,8 @@ int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 	skb = alloc_skb(len, GFP_ATOMIC);
 	if (!skb) {
 		iscsi_conn_error(conn, ISCSI_ERR_CONN_FAILED);
-		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: can not deliver "
-			   "control PDU: OOM\n");
+		iscsi_cls_conn_printk(KERN_ERR, conn, "can not deliver "
+				      "control PDU: OOM\n");
 		return -ENOMEM;
 	}
 
@@ -819,8 +821,8 @@ void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error)
 
 	skb = alloc_skb(len, GFP_ATOMIC);
 	if (!skb) {
-		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: gracefully ignored "
-			  "conn error (%d)\n", error);
+		iscsi_cls_conn_printk(KERN_ERR, conn, "gracefully ignored "
+				      "conn error (%d)\n", error);
 		return;
 	}
 
@@ -834,8 +836,8 @@ void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error)
 
 	iscsi_broadcast_skb(skb, GFP_ATOMIC);
 
-	dev_printk(KERN_INFO, &amp;conn-&gt;dev, "iscsi: detected conn error (%d)\n",
-		   error);
+	iscsi_cls_conn_printk(KERN_INFO, conn, "detected conn error (%d)\n",
+			      error);
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_error);
 
@@ -890,8 +892,8 @@ iscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
 
 		skbstat = alloc_skb(len, GFP_ATOMIC);
 		if (!skbstat) {
-			dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: can not "
-				   "deliver stats: OOM\n");
+			iscsi_cls_conn_printk(KERN_ERR, conn, "can not "
+					      "deliver stats: OOM\n");
 			return -ENOMEM;
 		}
 
@@ -947,8 +949,9 @@ int iscsi_session_event(struct iscsi_cls_session *session,
 
 	skb = alloc_skb(len, GFP_KERNEL);
 	if (!skb) {
-		dev_printk(KERN_ERR, &amp;session-&gt;dev, "Cannot notify userspace "
-			  "of session event %u\n", event);
+		iscsi_cls_session_printk(KERN_ERR, session,
+					 "Cannot notify userspace of session "
+					 "event %u\n", event);
 		return -ENOMEM;
 	}
 
@@ -971,8 +974,8 @@ int iscsi_session_event(struct iscsi_cls_session *session,
 		ev-&gt;r.unbind_session.sid = session-&gt;sid;
 		break;
 	default:
-		dev_printk(KERN_ERR, &amp;session-&gt;dev, "Invalid event %u.\n",
-			   event);
+		iscsi_cls_session_printk(KERN_ERR, session, "Invalid event "
+					 "%u.\n", event);
 		kfree_skb(skb);
 		return -EINVAL;
 	}
@@ -983,8 +986,10 @@ int iscsi_session_event(struct iscsi_cls_session *session,
 	 */
 	rc = iscsi_broadcast_skb(skb, GFP_KERNEL);
 	if (rc &lt; 0)
-		dev_printk(KERN_ERR, &amp;session-&gt;dev, "Cannot notify userspace "
-			  "of session event %u. Check iscsi daemon\n", event);
+		iscsi_cls_session_printk(KERN_ERR, session,
+					 "Cannot notify userspace of session "
+					 "event %u. Check iscsi daemon\n",
+					 event);
 	return rc;
 }
 EXPORT_SYMBOL_GPL(iscsi_session_event);
@@ -1017,16 +1022,15 @@ iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 
 	session = iscsi_session_lookup(ev-&gt;u.c_conn.sid);
 	if (!session) {
-		printk(KERN_ERR "iscsi: invalid session %d\n",
+		printk(KERN_ERR "iscsi: invalid session %d.\n",
 		       ev-&gt;u.c_conn.sid);
 		return -EINVAL;
 	}
 
 	conn = transport-&gt;create_conn(session, ev-&gt;u.c_conn.cid);
 	if (!conn) {
-		printk(KERN_ERR "iscsi: couldn't create a new "
-			   "connection for session %d\n",
-			   session-&gt;sid);
+		iscsi_cls_session_printk(KERN_ERR, session,
+					 "couldn't create a new connection.");
 		return -ENOMEM;
 	}
 
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 278011fb3c2f..5784e4ff8edc 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -344,6 +344,10 @@ extern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
 #define session_to_cls(_sess) \
 	hostdata_session(_sess-&gt;host-&gt;hostdata)
 
+#define iscsi_session_printk(prefix, _sess, fmt, a...)	\
+	iscsi_cls_session_printk(prefix,		\
+		(struct iscsi_cls_session *)session_to_cls(_sess), fmt, ##a)
+
 /*
  * connection management
  */
@@ -358,6 +362,9 @@ extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
 
+#define iscsi_conn_printk(prefix, _c, fmt, a...) \
+	iscsi_cls_conn_printk(prefix, _c-&gt;cls_conn, fmt, ##a)
+
 /*
  * pdu and task processing
  */
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 83693ba09c29..dbc96ef4cc72 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -212,6 +212,12 @@ struct iscsi_host {
 /*
  * session and connection functions that can be used by HW iSCSI LLDs
  */
+#define iscsi_cls_session_printk(prefix, _cls_session, fmt, a...) \
+	dev_printk(prefix, &amp;(_cls_session)-&gt;dev, fmt, ##a)
+
+#define iscsi_cls_conn_printk(prefix, _cls_conn, fmt, a...) \
+	dev_printk(prefix, &amp;(_cls_conn)-&gt;dev, fmt, ##a)
+
 extern int iscsi_session_chkready(struct iscsi_cls_session *session);
 extern struct iscsi_cls_session *iscsi_alloc_session(struct Scsi_Host *shost,
 					struct iscsi_transport *transport);</pre><hr><pre>commit c238c3bba9b422a9b453c75e157b416204f22a71
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:51 2008 -0600

    [SCSI] iscsi class: fix iscsi conn attr counter
    
    There are 13 iscsi conn attrs, but since the IF/OF markers were not being
    used we did not notice that we forgot to increment the ISCSI_CONN_ATTRS
    counter.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index af1799723e7b..35834bf4ba86 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -31,7 +31,7 @@
 #include &lt;scsi/iscsi_if.h&gt;
 
 #define ISCSI_SESSION_ATTRS 19
-#define ISCSI_CONN_ATTRS 11
+#define ISCSI_CONN_ATTRS 13
 #define ISCSI_HOST_ATTRS 4
 #define ISCSI_TRANSPORT_VERSION "2.0-867"
 </pre><hr><pre>commit ad294e9cd11d029fc0d09ab129fba5bea46de0dc
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:50 2008 -0600

    [SCSI] libiscsi: fix setting of nop timer
    
    If we rollover then we could get a next_timeout of zero, so we need
    to set the new timer to that value.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index c8c00e173414..b2a1ec8725b8 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1384,14 +1384,11 @@ static void iscsi_check_transport_timeouts(unsigned long data)
 			iscsi_send_nopout(conn, NULL);
 		}
 		next_timeout = last_recv + timeout + (conn-&gt;ping_timeout * HZ);
-	} else {
+	} else
 		next_timeout = last_recv + timeout;
-	}
 
-	if (next_timeout) {
-		debug_scsi("Setting next tmo %lu\n", next_timeout);
-		mod_timer(&amp;conn-&gt;transport_timer, next_timeout);
-	}
+	debug_scsi("Setting next tmo %lu\n", next_timeout);
+	mod_timer(&amp;conn-&gt;transport_timer, next_timeout);
 done:
 	spin_unlock(&amp;session-&gt;lock);
 }</pre><hr><pre>commit 921601b7031f8a2c71f49f1b965ee00ebbca6886
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:49 2008 -0600

    [SCSI] qla4xxx: add async scan support
    
    qla4xxx has the old school startup/probe where it finds presetup sessions
    in its flash and then attempts to log into them before returning from the
    probe. This however, makes it very simple to add a iscsi class scan finished
    helper which the driver can use.
    
    In future patches Dave or I will rip apart the driver to make it more
    like qla2xxx, but for now this is a very simple two line patch which
    fixes the problem of trying to figure out when the initial sessions
    are done being scanned.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: David Somayajulu &lt;david.somayajulu@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index d4dd149b466f..c3c59d763037 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -89,6 +89,8 @@ static struct scsi_host_template qla4xxx_driver_template = {
 	.slave_alloc		= qla4xxx_slave_alloc,
 	.slave_destroy		= qla4xxx_slave_destroy,
 
+	.scan_finished		= iscsi_scan_finished,
+
 	.this_id		= -1,
 	.cmd_per_lun		= 3,
 	.use_clustering		= ENABLE_CLUSTERING,
@@ -1306,7 +1308,7 @@ static int __devinit qla4xxx_probe_adapter(struct pci_dev *pdev,
 	       qla4xxx_version_str, ha-&gt;pdev-&gt;device, pci_name(ha-&gt;pdev),
 	       ha-&gt;host_no, ha-&gt;firmware_version[0], ha-&gt;firmware_version[1],
 	       ha-&gt;patch_number, ha-&gt;build_number);
-
+	scsi_scan_host(host);
 	return 0;
 
 remove_host:</pre><hr><pre>commit 8aae18adb240a9eb1999b8245c56522cbefc9047
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:48 2008 -0600

    [SCSI] iscsi class: add async scan helper
    
    In qla4xxx's probe it will call the iscsi session setup functions
    for session that got setup on the initial start. This then makes
    it easy for the iscsi class to export a helper which indicates
    when those scans are done.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index af88955d0ec1..af1799723e7b 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -127,6 +127,7 @@ static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
 	memset(ihost, 0, sizeof(*ihost));
 	INIT_LIST_HEAD(&amp;ihost-&gt;sessions);
 	mutex_init(&amp;ihost-&gt;mutex);
+	atomic_set(&amp;ihost-&gt;nr_scans, 0);
 
 	snprintf(ihost-&gt;scan_workq_name, KOBJ_NAME_LEN, "iscsi_scan_%d",
 		shost-&gt;host_no);
@@ -284,6 +285,25 @@ static int iscsi_is_session_dev(const struct device *dev)
 	return dev-&gt;release == iscsi_session_release;
 }
 
+/**
+ * iscsi_scan_finished - helper to report when running scans are done
+ * @shost: scsi host
+ * @time: scan run time
+ *
+ * This function can be used by drives like qla4xxx to report to the scsi
+ * layer when the scans it kicked off at module load time are done.
+ */
+int iscsi_scan_finished(struct Scsi_Host *shost, unsigned long time)
+{
+	struct iscsi_host *ihost = shost-&gt;shost_data;
+	/*
+	 * qla4xxx will have kicked off some session unblocks before calling
+	 * scsi_scan_host, so just wait for them to complete.
+	 */
+	return !atomic_read(&amp;ihost-&gt;nr_scans);
+}
+EXPORT_SYMBOL_GPL(iscsi_scan_finished);
+
 static int iscsi_user_scan(struct Scsi_Host *shost, uint channel,
 			   uint id, uint lun)
 {
@@ -306,17 +326,21 @@ static void iscsi_scan_session(struct work_struct *work)
 {
 	struct iscsi_cls_session *session =
 			container_of(work, struct iscsi_cls_session, scan_work);
+	struct Scsi_Host *shost = iscsi_session_to_shost(session);
+	struct iscsi_host *ihost = shost-&gt;shost_data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;session-&gt;lock, flags);
 	if (session-&gt;state != ISCSI_SESSION_LOGGED_IN) {
 		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
-		return;
+		goto done;
 	}
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 
 	scsi_scan_target(&amp;session-&gt;dev, 0, session-&gt;target_id,
 			 SCAN_WILD_CARD, 1);
+done:
+	atomic_dec(&amp;ihost-&gt;nr_scans);
 }
 
 static void session_recovery_timedout(struct work_struct *work)
@@ -366,7 +390,15 @@ void iscsi_unblock_session(struct iscsi_cls_session *session)
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 
 	__iscsi_unblock_session(session);
-	queue_work(ihost-&gt;scan_workq, &amp;session-&gt;scan_work);
+	/*
+	 * Only do kernel scanning if the driver is properly hooked into
+	 * the async scanning code (drivers like iscsi_tcp do login and
+	 * scanning from userspace).
+	 */
+	if (shost-&gt;hostt-&gt;scan_finished) {
+		if (queue_work(ihost-&gt;scan_workq, &amp;session-&gt;scan_work))
+			atomic_inc(&amp;ihost-&gt;nr_scans);
+	}
 }
 EXPORT_SYMBOL_GPL(iscsi_unblock_session);
 
@@ -550,7 +582,7 @@ void iscsi_remove_session(struct iscsi_cls_session *session)
 	session-&gt;state = ISCSI_SESSION_FREE;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	__iscsi_unblock_session(session);
-	iscsi_unbind_session(session);
+	__iscsi_unbind_session(&amp;session-&gt;unbind_work);
 
 	/* flush running scans */
 	flush_workqueue(ihost-&gt;scan_workq);
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 1f0ec46b4f87..83693ba09c29 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -203,6 +203,7 @@ struct iscsi_cls_session {
 
 struct iscsi_host {
 	struct list_head sessions;
+	atomic_t nr_scans;
 	struct mutex mutex;
 	struct workqueue_struct *scan_workq;
 	char scan_workq_name[KOBJ_NAME_LEN];
@@ -229,6 +230,6 @@ extern struct iscsi_cls_conn *iscsi_create_conn(struct iscsi_cls_session *sess,
 extern int iscsi_destroy_conn(struct iscsi_cls_conn *conn);
 extern void iscsi_unblock_session(struct iscsi_cls_session *session);
 extern void iscsi_block_session(struct iscsi_cls_session *session);
-
+extern int iscsi_scan_finished(struct Scsi_Host *shost, unsigned long time);
 
 #endif</pre><hr><pre>commit 568d303b5b3f0f6432ae8f56ecdb0beb2341288e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:47 2008 -0600

    [SCSI] qla4xxx: fix recovery timer and session unblock race
    
    If qla4xxx is resetting up a session and the recovery timer
    fires we do not want to just set it to dead, because
    the dpc thread could have just set it to online and is in the
    middle of resetting it up.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: David Somayajulu &lt;david.somayajulu@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 437d169a9814..d4dd149b466f 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -124,16 +124,19 @@ static void qla4xxx_recovery_timedout(struct iscsi_cls_session *session)
 	struct ddb_entry *ddb_entry = session-&gt;dd_data;
 	struct scsi_qla_host *ha = ddb_entry-&gt;ha;
 
-	DEBUG2(printk("scsi%ld: %s: index [%d] port down retry count of (%d) "
-		      "secs exhausted, marking device DEAD.\n", ha-&gt;host_no,
-		      __func__, ddb_entry-&gt;fw_ddb_index,
-		      ha-&gt;port_down_retry_count));
+	if (atomic_read(&amp;ddb_entry-&gt;state) != DDB_STATE_ONLINE) {
+		atomic_set(&amp;ddb_entry-&gt;state, DDB_STATE_DEAD);
 
-	atomic_set(&amp;ddb_entry-&gt;state, DDB_STATE_DEAD);
+		DEBUG2(printk("scsi%ld: %s: index [%d] port down retry count "
+			      "of (%d) secs exhausted, marking device DEAD.\n",
+			      ha-&gt;host_no, __func__, ddb_entry-&gt;fw_ddb_index,
+			      ha-&gt;port_down_retry_count));
 
-	DEBUG2(printk("scsi%ld: %s: scheduling dpc routine - dpc flags = "
-		      "0x%lx\n", ha-&gt;host_no, __func__, ha-&gt;dpc_flags));
-	queue_work(ha-&gt;dpc_thread, &amp;ha-&gt;dpc_work);
+		DEBUG2(printk("scsi%ld: %s: scheduling dpc routine - dpc "
+			      "flags = 0x%lx\n",
+			      ha-&gt;host_no, __func__, ha-&gt;dpc_flags));
+		queue_work(ha-&gt;dpc_thread, &amp;ha-&gt;dpc_work);
+	}
 }
 
 static int qla4xxx_host_get_param(struct Scsi_Host *shost,</pre><hr><pre>commit bd976f62cd6c6dda1ce57bf3e84447e94844868a
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jan 31 13:36:46 2008 -0600

    [SCSI] iscsi class: add session scanning
    
    This just adds iscsi session scanning which works like fc rport scanning.
    The future patches will hook the drivers into Mathew Wilcox's async
    scanning infrastructure, so userspace does not have to special case
    iscsi and so userspace does not have to make a extra special case for
    hardware iscsi root scanning.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index f876b0ae521a..af88955d0ec1 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -128,11 +128,11 @@ static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
 	INIT_LIST_HEAD(&amp;ihost-&gt;sessions);
 	mutex_init(&amp;ihost-&gt;mutex);
 
-	snprintf(ihost-&gt;unbind_workq_name, KOBJ_NAME_LEN, "iscsi_unbind_%d",
+	snprintf(ihost-&gt;scan_workq_name, KOBJ_NAME_LEN, "iscsi_scan_%d",
 		shost-&gt;host_no);
-	ihost-&gt;unbind_workq = create_singlethread_workqueue(
-						ihost-&gt;unbind_workq_name);
-	if (!ihost-&gt;unbind_workq)
+	ihost-&gt;scan_workq = create_singlethread_workqueue(
+						ihost-&gt;scan_workq_name);
+	if (!ihost-&gt;scan_workq)
 		return -ENOMEM;
 	return 0;
 }
@@ -143,7 +143,7 @@ static int iscsi_remove_host(struct transport_container *tc, struct device *dev,
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct iscsi_host *ihost = shost-&gt;shost_data;
 
-	destroy_workqueue(ihost-&gt;unbind_workq);
+	destroy_workqueue(ihost-&gt;scan_workq);
 	return 0;
 }
 
@@ -302,6 +302,23 @@ static int iscsi_user_scan(struct Scsi_Host *shost, uint channel,
 	return 0;
 }
 
+static void iscsi_scan_session(struct work_struct *work)
+{
+	struct iscsi_cls_session *session =
+			container_of(work, struct iscsi_cls_session, scan_work);
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	if (session-&gt;state != ISCSI_SESSION_LOGGED_IN) {
+		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+		return;
+	}
+	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+
+	scsi_scan_target(&amp;session-&gt;dev, 0, session-&gt;target_id,
+			 SCAN_WILD_CARD, 1);
+}
+
 static void session_recovery_timedout(struct work_struct *work)
 {
 	struct iscsi_cls_session *session =
@@ -340,6 +357,8 @@ void __iscsi_unblock_session(struct iscsi_cls_session *session)
 
 void iscsi_unblock_session(struct iscsi_cls_session *session)
 {
+	struct Scsi_Host *shost = iscsi_session_to_shost(session);
+	struct iscsi_host *ihost = shost-&gt;shost_data;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;session-&gt;lock, flags);
@@ -347,6 +366,7 @@ void iscsi_unblock_session(struct iscsi_cls_session *session)
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 
 	__iscsi_unblock_session(session);
+	queue_work(ihost-&gt;scan_workq, &amp;session-&gt;scan_work);
 }
 EXPORT_SYMBOL_GPL(iscsi_unblock_session);
 
@@ -390,7 +410,7 @@ static int iscsi_unbind_session(struct iscsi_cls_session *session)
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_host *ihost = shost-&gt;shost_data;
 
-	return queue_work(ihost-&gt;unbind_workq, &amp;session-&gt;unbind_work);
+	return queue_work(ihost-&gt;scan_workq, &amp;session-&gt;unbind_work);
 }
 
 struct iscsi_cls_session *
@@ -411,6 +431,7 @@ iscsi_alloc_session(struct Scsi_Host *shost,
 	INIT_LIST_HEAD(&amp;session-&gt;host_list);
 	INIT_LIST_HEAD(&amp;session-&gt;sess_list);
 	INIT_WORK(&amp;session-&gt;unbind_work, __iscsi_unbind_session);
+	INIT_WORK(&amp;session-&gt;scan_work, iscsi_scan_session);
 	spin_lock_init(&amp;session-&gt;lock);
 
 	/* this is released in the dev's release function */
@@ -530,13 +551,15 @@ void iscsi_remove_session(struct iscsi_cls_session *session)
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	__iscsi_unblock_session(session);
 	iscsi_unbind_session(session);
+
+	/* flush running scans */
+	flush_workqueue(ihost-&gt;scan_workq);
 	/*
 	 * If the session dropped while removing devices then we need to make
 	 * sure it is not blocked
 	 */
 	if (!cancel_delayed_work(&amp;session-&gt;recovery_work))
 		flush_workqueue(iscsi_eh_timer_workq);
-	flush_workqueue(ihost-&gt;unbind_workq);
 
 	/* hw iscsi may not have removed all connections from session */
 	err = device_for_each_child(&amp;session-&gt;dev, NULL,
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 0e869d9a3856..1f0ec46b4f87 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -177,11 +177,12 @@ struct iscsi_cls_session {
 	struct list_head host_list;
 	struct iscsi_transport *transport;
 	spinlock_t lock;
+	struct work_struct scan_work;
+	struct work_struct unbind_work;
 
 	/* recovery fields */
 	int recovery_tmo;
 	struct delayed_work recovery_work;
-	struct work_struct unbind_work;
 
 	int target_id;
 
@@ -203,8 +204,8 @@ struct iscsi_cls_session {
 struct iscsi_host {
 	struct list_head sessions;
 	struct mutex mutex;
-	struct workqueue_struct *unbind_workq;
-	char unbind_workq_name[KOBJ_NAME_LEN];
+	struct workqueue_struct *scan_workq;
+	char scan_workq_name[KOBJ_NAME_LEN];
 };
 
 /*</pre>
    <div class="pagination">
        <a href='5_27.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><span>[28]</span><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_29.html'>Next&gt;&gt;</a>
    <div>
</body>
