<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_30.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><span>[31]</span><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_32.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a2fd66d069d86d793e9d39d4079b96f46d13f237
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Jun 23 11:03:54 2015 -0400

    ext4: set lazytime on remount if MS_LAZYTIME is set by mount
    
    Newer versions of mount parse the lazytime feature and pass it to the
    mount system call via the flags field in the mount system call,
    removing the lazytime string from the mount options list.  So we need
    to check for the presence of MS_LAZYTIME and set it in sb-&gt;s_flags in
    order for this flag to be set on a remount.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index bd4df9d379b2..90ec13fe8ac7 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4971,6 +4971,9 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 		set_task_ioprio(sbi-&gt;s_journal-&gt;j_task, journal_ioprio);
 	}
 
+	if (*flags &amp; MS_LAZYTIME)
+		sb-&gt;s_flags |= MS_LAZYTIME;
+
 	if ((*flags &amp; MS_RDONLY) != (sb-&gt;s_flags &amp; MS_RDONLY)) {
 		if (sbi-&gt;s_mount_flags &amp; EXT4_MF_FS_ABORTED) {
 			err = -EROFS;</pre><hr><pre>commit c5e298ae53dc2eb69f2f7153be03454c8a33c658
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Jun 21 01:25:29 2015 -0400

    ext4: prevent ext4_quota_write() from failing due to ENOSPC
    
    In order to prevent quota block tracking to be inaccurate when
    ext4_quota_write() fails with ENOSPC, we make two changes.  The quota
    file can now use the reserved block (since the quota file is arguably
    file system metadata), and ext4_quota_write() now uses
    ext4_should_retry_alloc() to retry the block allocation after a commit
    has completed and released some blocks for allocation.
    
    This fixes failures of xfstests generic/270:
    
    Quota error (device vdc): write_blk: dquota write failed
    Quota error (device vdc): qtree_write_dquot: Error -28 occurred while creating quota
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 1ba8b4ab03a8..d86d2622f826 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -4456,6 +4456,8 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 		ar.flags |= EXT4_MB_HINT_NOPREALLOC;
 	if (flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE)
 		ar.flags |= EXT4_MB_DELALLOC_RESERVED;
+	if (flags &amp; EXT4_GET_BLOCKS_METADATA_NOFAIL)
+		ar.flags |= EXT4_MB_USE_RESERVED;
 	newblock = ext4_mb_new_blocks(handle, &amp;ar, &amp;err);
 	if (!newblock)
 		goto out2;
diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c
index 958824019509..9962d577bad5 100644
--- a/fs/ext4/indirect.c
+++ b/fs/ext4/indirect.c
@@ -576,6 +576,8 @@ int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,
 		ar.flags = EXT4_MB_HINT_DATA;
 	if (flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE)
 		ar.flags |= EXT4_MB_DELALLOC_RESERVED;
+	if (flags &amp; EXT4_GET_BLOCKS_METADATA_NOFAIL)
+		ar.flags |= EXT4_MB_USE_RESERVED;
 
 	ar.goal = ext4_find_goal(inode, map-&gt;m_lblk, partial);
 
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 263a46c488c7..e8a67b8ba90c 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -731,18 +731,18 @@ int ext4_get_block(struct inode *inode, sector_t iblock,
  * `handle' can be NULL if create is zero
  */
 struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,
-				ext4_lblk_t block, int create)
+				ext4_lblk_t block, int map_flags)
 {
 	struct ext4_map_blocks map;
 	struct buffer_head *bh;
+	int create = map_flags &amp; EXT4_GET_BLOCKS_CREATE;
 	int err;
 
 	J_ASSERT(handle != NULL || create == 0);
 
 	map.m_lblk = block;
 	map.m_len = 1;
-	err = ext4_map_blocks(handle, inode, &amp;map,
-			      create ? EXT4_GET_BLOCKS_CREATE : 0);
+	err = ext4_map_blocks(handle, inode, &amp;map, map_flags);
 
 	if (err == 0)
 		return create ? ERR_PTR(-ENOSPC) : NULL;
@@ -788,11 +788,11 @@ struct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,
 }
 
 struct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,
-			       ext4_lblk_t block, int create)
+			       ext4_lblk_t block, int map_flags)
 {
 	struct buffer_head *bh;
 
-	bh = ext4_getblk(handle, inode, block, create);
+	bh = ext4_getblk(handle, inode, block, map_flags);
 	if (IS_ERR(bh))
 		return bh;
 	if (!bh || buffer_uptodate(bh))
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 5e7676f1e82f..e230b31251f7 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -61,7 +61,7 @@ static struct buffer_head *ext4_append(handle_t *handle,
 
 	*block = inode-&gt;i_size &gt;&gt; inode-&gt;i_sb-&gt;s_blocksize_bits;
 
-	bh = ext4_bread(handle, inode, *block, 1);
+	bh = ext4_bread(handle, inode, *block, EXT4_GET_BLOCKS_CREATE);
 	if (IS_ERR(bh))
 		return bh;
 	inode-&gt;i_size += inode-&gt;i_sb-&gt;s_blocksize;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 2858ac09f5a3..bd4df9d379b2 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -5438,6 +5438,7 @@ static ssize_t ext4_quota_write(struct super_block *sb, int type,
 	struct inode *inode = sb_dqopt(sb)-&gt;files[type];
 	ext4_lblk_t blk = off &gt;&gt; EXT4_BLOCK_SIZE_BITS(sb);
 	int err, offset = off &amp; (sb-&gt;s_blocksize - 1);
+	int retries = 0;
 	struct buffer_head *bh;
 	handle_t *handle = journal_current_handle();
 
@@ -5458,7 +5459,12 @@ static ssize_t ext4_quota_write(struct super_block *sb, int type,
 		return -EIO;
 	}
 
-	bh = ext4_bread(handle, inode, blk, 1);
+	do {
+		bh = ext4_bread(handle, inode, blk,
+				EXT4_GET_BLOCKS_CREATE |
+				EXT4_GET_BLOCKS_METADATA_NOFAIL);
+	} while (IS_ERR(bh) &amp;&amp; (PTR_ERR(bh) == -ENOSPC) &amp;&amp;
+		 ext4_should_retry_alloc(inode-&gt;i_sb, &amp;retries));
 	if (IS_ERR(bh))
 		return PTR_ERR(bh);
 	if (!bh)</pre><hr><pre>commit 89d96a6f8e6491f24fc8f99fd6ae66820e85c6c1
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Jun 20 22:50:33 2015 -0400

    ext4: call sync_blockdev() before invalidate_bdev() in put_super()
    
    Normally all of the buffers will have been forced out to disk before
    we call invalidate_bdev(), but there will be some cases, where a file
    system operation was aborted due to an ext4_error(), where there may
    still be some dirty buffers in the buffer cache for the device.  So
    try to force them out to memory before calling invalidate_bdev().
    
    This fixes a warning triggered by generic/081:
    
    WARNING: CPU: 1 PID: 3473 at /usr/projects/linux/ext4/fs/block_dev.c:56 __blkdev_put+0xb5/0x16f()
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index fdac076e0791..2858ac09f5a3 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -828,6 +828,7 @@ static void ext4_put_super(struct super_block *sb)
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
+	sync_blockdev(sb-&gt;s_bdev);
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*</pre><hr><pre>commit bdf96838aea6a265f2ae6cbcfb12a778c84a0b8e
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri Jun 12 23:45:33 2015 -0400

    ext4: fix race between truncate and __ext4_journalled_writepage()
    
    The commit cf108bca465d: "ext4: Invert the locking order of page_lock
    and transaction start" caused __ext4_journalled_writepage() to drop
    the page lock before the page was written back, as part of changing
    the locking order to jbd2_journal_start -&gt; page_lock.  However, this
    introduced a potential race if there was a truncate racing with the
    data=journalled writeback mode.
    
    Fix this by grabbing the page lock after starting the journal handle,
    and then checking to see if page had gotten truncated out from under
    us.
    
    This fixes a number of different warnings or BUG_ON's when running
    xfstests generic/086 in data=journalled mode, including:
    
    jbd2_journal_dirty_metadata: vdc-8: bad jh for block 115643: transaction (ee3fe7
    c0, 164), jh-&gt;b_transaction (  (null), 0), jh-&gt;b_next_transaction (  (null), 0), jlist 0
    
                              - and -
    
    kernel BUG at /usr/projects/linux/ext4/fs/jbd2/transaction.c:2200!
        ...
    Call Trace:
     [&lt;c02b2ded&gt;] ? __ext4_journalled_invalidatepage+0x117/0x117
     [&lt;c02b2de5&gt;] __ext4_journalled_invalidatepage+0x10f/0x117
     [&lt;c02b2ded&gt;] ? __ext4_journalled_invalidatepage+0x117/0x117
     [&lt;c027d883&gt;] ? lock_buffer+0x36/0x36
     [&lt;c02b2dfa&gt;] ext4_journalled_invalidatepage+0xd/0x22
     [&lt;c0229139&gt;] do_invalidatepage+0x22/0x26
     [&lt;c0229198&gt;] truncate_inode_page+0x5b/0x85
     [&lt;c022934b&gt;] truncate_inode_pages_range+0x156/0x38c
     [&lt;c0229592&gt;] truncate_inode_pages+0x11/0x15
     [&lt;c022962d&gt;] truncate_pagecache+0x55/0x71
     [&lt;c02b913b&gt;] ext4_setattr+0x4a9/0x560
     [&lt;c01ca542&gt;] ? current_kernel_time+0x10/0x44
     [&lt;c026c4d8&gt;] notify_change+0x1c7/0x2be
     [&lt;c0256a00&gt;] do_truncate+0x65/0x85
     [&lt;c0226f31&gt;] ? file_ra_state_init+0x12/0x29
    
                              - and -
    
    WARNING: CPU: 1 PID: 1331 at /usr/projects/linux/ext4/fs/jbd2/transaction.c:1396
    irty_metadata+0x14a/0x1ae()
        ...
    Call Trace:
     [&lt;c01b879f&gt;] ? console_unlock+0x3a1/0x3ce
     [&lt;c082cbb4&gt;] dump_stack+0x48/0x60
     [&lt;c0178b65&gt;] warn_slowpath_common+0x89/0xa0
     [&lt;c02ef2cf&gt;] ? jbd2_journal_dirty_metadata+0x14a/0x1ae
     [&lt;c0178bef&gt;] warn_slowpath_null+0x14/0x18
     [&lt;c02ef2cf&gt;] jbd2_journal_dirty_metadata+0x14a/0x1ae
     [&lt;c02d8615&gt;] __ext4_handle_dirty_metadata+0xd4/0x19d
     [&lt;c02b2f44&gt;] write_end_fn+0x40/0x53
     [&lt;c02b4a16&gt;] ext4_walk_page_buffers+0x4e/0x6a
     [&lt;c02b59e7&gt;] ext4_writepage+0x354/0x3b8
     [&lt;c02b2f04&gt;] ? mpage_release_unused_pages+0xd4/0xd4
     [&lt;c02b1b21&gt;] ? wait_on_buffer+0x2c/0x2c
     [&lt;c02b5a4b&gt;] ? ext4_writepage+0x3b8/0x3b8
     [&lt;c02b5a5b&gt;] __writepage+0x10/0x2e
     [&lt;c0225956&gt;] write_cache_pages+0x22d/0x32c
     [&lt;c02b5a4b&gt;] ? ext4_writepage+0x3b8/0x3b8
     [&lt;c02b6ee8&gt;] ext4_writepages+0x102/0x607
     [&lt;c019adfe&gt;] ? sched_clock_local+0x10/0x10e
     [&lt;c01a8a7c&gt;] ? __lock_is_held+0x2e/0x44
     [&lt;c01a8ad5&gt;] ? lock_is_held+0x43/0x51
     [&lt;c0226dff&gt;] do_writepages+0x1c/0x29
     [&lt;c0276bed&gt;] __writeback_single_inode+0xc3/0x545
     [&lt;c0277c07&gt;] writeback_sb_inodes+0x21f/0x36d
        ...
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 0554b0b5957b..263a46c488c7 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1701,19 +1701,32 @@ static int __ext4_journalled_writepage(struct page *page,
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
-	/* As soon as we unlock the page, it can go away, but we have
-	 * references to buffers so we are safe */
+	/*
+	 * We need to release the page lock before we start the
+	 * journal, so grab a reference so the page won't disappear
+	 * out from under us.
+	 */
+	get_page(page);
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
-		goto out;
+		put_page(page);
+		goto out_no_pagelock;
 	}
-
 	BUG_ON(!ext4_handle_valid(handle));
 
+	lock_page(page);
+	put_page(page);
+	if (page-&gt;mapping != mapping) {
+		/* The page got truncated from under us */
+		ext4_journal_stop(handle);
+		ret = 0;
+		goto out;
+	}
+
 	if (inline_data) {
 		BUFFER_TRACE(inode_bh, "get write access");
 		ret = ext4_journal_get_write_access(handle, inode_bh);
@@ -1739,6 +1752,8 @@ static int __ext4_journalled_writepage(struct page *page,
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
+	unlock_page(page);
+out_no_pagelock:
 	brelse(inode_bh);
 	return ret;
 }</pre><hr><pre>commit 1cb767cd4a79703105f4f3774c76896d621fdc54
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri Jun 12 23:44:33 2015 -0400

    ext4 crypto: fail the mount if blocksize != pagesize
    
    We currently don't correctly handle the case where blocksize !=
    pagesize, so disallow the mount in those cases.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 31e85bea9652..e13fe40d4a51 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4065,7 +4065,15 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 		}
 	}
 
-	if (unlikely(sbi-&gt;s_mount_flags &amp; EXT4_MF_TEST_DUMMY_ENCRYPTION) &amp;&amp;
+	if ((DUMMY_ENCRYPTION_ENABLED(sbi) ||
+	     EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_ENCRYPT)) &amp;&amp;
+	    (blocksize != PAGE_CACHE_SIZE)) {
+		ext4_msg(sb, KERN_ERR,
+			 "Unsupported blocksize for fs encryption");
+		goto failed_mount_wq;
+	}
+
+	if (DUMMY_ENCRYPTION_ENABLED(sbi) &amp;&amp;
 	    !(sb-&gt;s_flags &amp; MS_RDONLY) &amp;&amp;
 	    !EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_ENCRYPT)) {
 		EXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_ENCRYPT);</pre><hr><pre>commit ad0a0ce894d554b112afab6a48fd500e636686a6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Jun 8 11:54:56 2015 -0400

    ext4 crypto: fix ext4_get_crypto_ctx()'s calling convention in ext4_decrypt_one
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index f5c82e8b7b5c..45731558138c 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -396,8 +396,8 @@ int ext4_decrypt_one(struct inode *inode, struct page *page)
 
 	struct ext4_crypto_ctx *ctx = ext4_get_crypto_ctx(inode);
 
-	if (!ctx)
-		return -ENOMEM;
+	if (IS_ERR(ctx))
+		return PTR_ERR(ctx);
 	ret = ext4_decrypt(ctx, page);
 	ext4_release_crypto_ctx(ctx);
 	return ret;</pre><hr><pre>commit 3dbb5eb9a3aa04f40e551338eee5e8d06f352fe8
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Jun 3 09:32:39 2015 -0400

    ext4 crypto: allocate bounce pages using GFP_NOWAIT
    
    Previously we allocated bounce pages using a combination of
    alloc_page() and mempool_alloc() with the __GFP_WAIT bit set.
    Instead, use mempool_alloc() with GFP_NOWAIT.  The mempool_alloc()
    function will try using alloc_pages() initially, and then only use the
    mempool reserve of pages if alloc_pages() is unable to fulfill the
    request.
    
    This minimizes the the impact on the mm layer when we need to do a
    large amount of writeback of encrypted files, as Jaeguk Kim had
    reported that under a heavy fio workload on a system with restricted
    amounts memory (which unfortunately, includes many mobile handsets),
    he had observed the the OOM killer getting triggered several times.
    Using GFP_NOWAIT
    
    If the mempool_alloc() function fails, we will retry the page
    writeback at a later time; the function of the mempool is to ensure
    that we can writeback at least 32 pages at a time, so we can more
    efficiently dispatch I/O under high memory pressure situations.  In
    the future we should make this be a tunable so we can determine the
    best tradeoff between permanently sequestering memory and the ability
    to quickly launder pages so we can free up memory quickly when
    necessary.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index efcb7c04d172..f5c82e8b7b5c 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -71,12 +71,8 @@ void ext4_release_crypto_ctx(struct ext4_crypto_ctx *ctx)
 {
 	unsigned long flags;
 
-	if (ctx-&gt;flags &amp; EXT4_WRITE_PATH_FL &amp;&amp; ctx-&gt;w.bounce_page) {
-		if (ctx-&gt;flags &amp; EXT4_BOUNCE_PAGE_REQUIRES_FREE_ENCRYPT_FL)
-			__free_page(ctx-&gt;w.bounce_page);
-		else
-			mempool_free(ctx-&gt;w.bounce_page, ext4_bounce_page_pool);
-	}
+	if (ctx-&gt;flags &amp; EXT4_WRITE_PATH_FL &amp;&amp; ctx-&gt;w.bounce_page)
+		mempool_free(ctx-&gt;w.bounce_page, ext4_bounce_page_pool);
 	ctx-&gt;w.bounce_page = NULL;
 	ctx-&gt;w.control_page = NULL;
 	if (ctx-&gt;flags &amp; EXT4_CTX_REQUIRES_FREE_ENCRYPT_FL) {
@@ -317,22 +313,11 @@ static int ext4_page_crypto(struct ext4_crypto_ctx *ctx,
 
 static struct page *alloc_bounce_page(struct ext4_crypto_ctx *ctx)
 {
-	struct page *ciphertext_page = alloc_page(GFP_NOFS);
-
-	if (!ciphertext_page) {
-		/* This is a potential bottleneck, but at least we'll have
-		 * forward progress. */
-		ciphertext_page = mempool_alloc(ext4_bounce_page_pool,
-						 GFP_NOFS);
-		if (ciphertext_page == NULL)
-			return ERR_PTR(-ENOMEM);
-		ctx-&gt;flags &amp;= ~EXT4_BOUNCE_PAGE_REQUIRES_FREE_ENCRYPT_FL;
-	} else {
-		ctx-&gt;flags |= EXT4_BOUNCE_PAGE_REQUIRES_FREE_ENCRYPT_FL;
-	}
+	ctx-&gt;w.bounce_page = mempool_alloc(ext4_bounce_page_pool, GFP_NOWAIT);
+	if (ctx-&gt;w.bounce_page == NULL)
+		return ERR_PTR(-ENOMEM);
 	ctx-&gt;flags |= EXT4_WRITE_PATH_FL;
-	ctx-&gt;w.bounce_page = ciphertext_page;
-	return ciphertext_page;
+	return ctx-&gt;w.bounce_page;
 }
 
 /**
diff --git a/fs/ext4/ext4_crypto.h b/fs/ext4/ext4_crypto.h
index 34e0d2455881..ac7d4e813796 100644
--- a/fs/ext4/ext4_crypto.h
+++ b/fs/ext4/ext4_crypto.h
@@ -83,8 +83,7 @@ struct ext4_crypt_info {
 };
 
 #define EXT4_CTX_REQUIRES_FREE_ENCRYPT_FL             0x00000001
-#define EXT4_BOUNCE_PAGE_REQUIRES_FREE_ENCRYPT_FL     0x00000002
-#define EXT4_WRITE_PATH_FL			      0x00000004
+#define EXT4_WRITE_PATH_FL			      0x00000002
 
 struct ext4_crypto_ctx {
 	union {</pre><hr><pre>commit abdd438b26b409eaccf9c847fcf9c3ab52f1959e
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun May 31 13:35:39 2015 -0400

    ext4 crypto: handle unexpected lack of encryption keys
    
    Fix up attempts by users to try to write to a file when they don't
    have access to the encryption key.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index 1c9a8c499369..efcb7c04d172 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -104,7 +104,8 @@ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode)
 	unsigned long flags;
 	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
 
-	BUG_ON(ci == NULL);
+	if (ci == NULL)
+		return ERR_PTR(-ENOKEY);
 
 	/*
 	 * We first try getting the ctx from a free list because in
diff --git a/fs/ext4/crypto_policy.c b/fs/ext4/crypto_policy.c
index a1d434d0dea8..02c4e5df7afb 100644
--- a/fs/ext4/crypto_policy.c
+++ b/fs/ext4/crypto_policy.c
@@ -183,7 +183,8 @@ int ext4_inherit_context(struct inode *parent, struct inode *child)
 	if (res &lt; 0)
 		return res;
 	ci = EXT4_I(parent)-&gt;i_crypt_info;
-	BUG_ON(ci == NULL);
+	if (ci == NULL)
+		return -ENOKEY;
 
 	ctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;
 	if (DUMMY_ENCRYPTION_ENABLED(EXT4_SB(parent-&gt;i_sb))) {
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 875ca6b95a4b..ac517f15741c 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -226,6 +226,8 @@ static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)
 		int err = ext4_get_encryption_info(inode);
 		if (err)
 			return 0;
+		if (ext4_encryption_info(inode) == NULL)
+			return -ENOKEY;
 	}
 	file_accessed(file);
 	if (IS_DAX(file_inode(file))) {
@@ -278,6 +280,13 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 			ext4_journal_stop(handle);
 		}
 	}
+	if (ext4_encrypted_inode(inode)) {
+		ret = ext4_get_encryption_info(inode);
+		if (ret)
+			return -EACCES;
+		if (ext4_encryption_info(inode) == NULL)
+			return -ENOKEY;
+	}
 	/*
 	 * Set up the jbd2_inode if we are opening the inode for
 	 * writing and the journal is present
@@ -287,13 +296,7 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 		if (ret &lt; 0)
 			return ret;
 	}
-	ret = dquot_file_open(inode, filp);
-	if (!ret &amp;&amp; ext4_encrypted_inode(inode)) {
-		ret = ext4_get_encryption_info(inode);
-		if (ret)
-			ret = -EACCES;
-	}
-	return ret;
+	return dquot_file_open(inode, filp);
 }
 
 /*</pre><hr><pre>commit 4d3c4e5b8cae3bb45ba933a22670504239958aa1
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun May 31 13:35:32 2015 -0400

    ext4 crypto: allocate the right amount of memory for the on-disk symlink
    
    Previously we were taking the required padding when allocating space
    for the on-disk symlink.  This caused a buffer overrun which could
    trigger a krenel crash when running fsstress.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto_fname.c b/fs/ext4/crypto_fname.c
index 23af41f73e90..7dc4eb55913c 100644
--- a/fs/ext4/crypto_fname.c
+++ b/fs/ext4/crypto_fname.c
@@ -262,8 +262,20 @@ u32 ext4_fname_crypto_round_up(u32 size, u32 blksize)
 	return ((size+blksize-1)/blksize)*blksize;
 }
 
-/**
- * ext4_fname_crypto_alloc_obuff() -
+unsigned ext4_fname_encrypted_size(struct inode *inode, u32 ilen)
+{
+	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
+	int padding = 32;
+
+	if (ci)
+		padding = 4 &lt;&lt; (ci-&gt;ci_flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
+	if (ilen &lt; EXT4_CRYPTO_BLOCK_SIZE)
+		ilen = EXT4_CRYPTO_BLOCK_SIZE;
+	return ext4_fname_crypto_round_up(ilen, padding);
+}
+
+/*
+ * ext4_fname_crypto_alloc_buffer() -
  *
  * Allocates an output buffer that is sufficient for the crypto operation
  * specified by the context and the direction.
@@ -271,15 +283,8 @@ u32 ext4_fname_crypto_round_up(u32 size, u32 blksize)
 int ext4_fname_crypto_alloc_buffer(struct inode *inode,
 				   u32 ilen, struct ext4_str *crypto_str)
 {
-	unsigned int olen;
-	int padding = 16;
-	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
+	unsigned int olen = ext4_fname_encrypted_size(inode, ilen);
 
-	if (ci)
-		padding = 4 &lt;&lt; (ci-&gt;ci_flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
-	if (padding &lt; EXT4_CRYPTO_BLOCK_SIZE)
-		padding = EXT4_CRYPTO_BLOCK_SIZE;
-	olen = ext4_fname_crypto_round_up(ilen, padding);
 	crypto_str-&gt;len = olen;
 	if (olen &lt; EXT4_FNAME_CRYPTO_DIGEST_SIZE*2)
 		olen = EXT4_FNAME_CRYPTO_DIGEST_SIZE*2;
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index bd8d32d5214d..730c88d1b220 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2090,6 +2090,7 @@ static inline int ext4_sb_has_crypto(struct super_block *sb)
 /* crypto_fname.c */
 bool ext4_valid_filenames_enc_mode(uint32_t mode);
 u32 ext4_fname_crypto_round_up(u32 size, u32 blksize);
+unsigned ext4_fname_encrypted_size(struct inode *inode, u32 ilen);
 int ext4_fname_crypto_alloc_buffer(struct inode *inode,
 				   u32 ilen, struct ext4_str *crypto_str);
 int _ext4_fname_disk_to_usr(struct inode *inode,
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 401b099e3af3..bda4a5d6f5a5 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -3039,10 +3039,23 @@ static int ext4_symlink(struct inode *dir,
 
 	encryption_required = (ext4_encrypted_inode(dir) ||
 			       DUMMY_ENCRYPTION_ENABLED(EXT4_SB(dir-&gt;i_sb)));
-	if (encryption_required)
-		disk_link.len = encrypted_symlink_data_len(len) + 1;
-	if (disk_link.len &gt; dir-&gt;i_sb-&gt;s_blocksize)
-		return -ENAMETOOLONG;
+	if (encryption_required) {
+		err = ext4_get_encryption_info(dir);
+		if (err)
+			return err;
+		if (ext4_encryption_info(dir) == NULL)
+			return -EPERM;
+		disk_link.len = (ext4_fname_encrypted_size(dir, len) +
+				 sizeof(struct ext4_encrypted_symlink_data));
+		sd = kzalloc(disk_link.len, GFP_KERNEL);
+		if (!sd)
+			return -ENOMEM;
+	}
+
+	if (disk_link.len &gt; dir-&gt;i_sb-&gt;s_blocksize) {
+		err = -ENAMETOOLONG;
+		goto err_free_sd;
+	}
 
 	dquot_initialize(dir);
 
@@ -3073,18 +3086,14 @@ static int ext4_symlink(struct inode *dir,
 	if (IS_ERR(inode)) {
 		if (handle)
 			ext4_journal_stop(handle);
-		return PTR_ERR(inode);
+		err = PTR_ERR(inode);
+		goto err_free_sd;
 	}
 
 	if (encryption_required) {
 		struct qstr istr;
 		struct ext4_str ostr;
 
-		sd = kzalloc(disk_link.len, GFP_NOFS);
-		if (!sd) {
-			err = -ENOMEM;
-			goto err_drop_inode;
-		}
 		istr.name = (const unsigned char *) symname;
 		istr.len = len;
 		ostr.name = sd-&gt;encrypted_path;
@@ -3156,10 +3165,11 @@ static int ext4_symlink(struct inode *dir,
 err_drop_inode:
 	if (handle)
 		ext4_journal_stop(handle);
-	kfree(sd);
 	clear_nlink(inode);
 	unlock_new_inode(inode);
 	iput(inode);
+err_free_sd:
+	kfree(sd);
 	return err;
 }
 </pre><hr><pre>commit 82d0d3e7e69ab509b5c91b61f12bd3593a7c6dcb
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun May 31 13:35:22 2015 -0400

    ext4 crypto: clean up error handling in ext4_fname_setup_filename
    
    Fix a potential memory leak where fname-&gt;crypto_buf.name wouldn't get
    freed in some error paths, and also make the error handling easier to
    understand/audit.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto_fname.c b/fs/ext4/crypto_fname.c
index 29a2dc9a6f82..23af41f73e90 100644
--- a/fs/ext4/crypto_fname.c
+++ b/fs/ext4/crypto_fname.c
@@ -401,7 +401,7 @@ int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 	      ((iname-&gt;name[1] == '.') &amp;&amp; (iname-&gt;len == 2))))) {
 		fname-&gt;disk_name.name = (unsigned char *) iname-&gt;name;
 		fname-&gt;disk_name.len = iname-&gt;len;
-		goto out;
+		return 0;
 	}
 	ret = ext4_get_encryption_info(dir);
 	if (ret)
@@ -411,19 +411,16 @@ int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 		ret = ext4_fname_crypto_alloc_buffer(dir, iname-&gt;len,
 						     &amp;fname-&gt;crypto_buf);
 		if (ret &lt; 0)
-			goto out;
+			return ret;
 		ret = ext4_fname_encrypt(dir, iname, &amp;fname-&gt;crypto_buf);
 		if (ret &lt; 0)
-			goto out;
+			goto errout;
 		fname-&gt;disk_name.name = fname-&gt;crypto_buf.name;
 		fname-&gt;disk_name.len = fname-&gt;crypto_buf.len;
-		ret = 0;
-		goto out;
-	}
-	if (!lookup) {
-		ret = -EACCES;
-		goto out;
+		return 0;
 	}
+	if (!lookup)
+		return -EACCES;
 
 	/* We don't have the key and we are doing a lookup; decode the
 	 * user-supplied name
@@ -431,19 +428,17 @@ int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 	if (iname-&gt;name[0] == '_')
 		bigname = 1;
 	if ((bigname &amp;&amp; (iname-&gt;len != 33)) ||
-	    (!bigname &amp;&amp; (iname-&gt;len &gt; 43))) {
-		ret = -ENOENT;
-	}
+	    (!bigname &amp;&amp; (iname-&gt;len &gt; 43)))
+		return -ENOENT;
+
 	fname-&gt;crypto_buf.name = kmalloc(32, GFP_KERNEL);
-	if (fname-&gt;crypto_buf.name == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
+	if (fname-&gt;crypto_buf.name == NULL)
+		return -ENOMEM;
 	ret = digest_decode(iname-&gt;name + bigname, iname-&gt;len - bigname,
 			    fname-&gt;crypto_buf.name);
 	if (ret &lt; 0) {
 		ret = -ENOENT;
-		goto out;
+		goto errout;
 	}
 	fname-&gt;crypto_buf.len = ret;
 	if (bigname) {
@@ -453,8 +448,10 @@ int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 		fname-&gt;disk_name.name = fname-&gt;crypto_buf.name;
 		fname-&gt;disk_name.len = fname-&gt;crypto_buf.len;
 	}
-	ret = 0;
-out:
+	return 0;
+errout:
+	kfree(fname-&gt;crypto_buf.name);
+	fname-&gt;crypto_buf.name = NULL;
 	return ret;
 }
 </pre>
    <div class="pagination">
        <a href='1_30.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><span>[31]</span><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_32.html'>Next&gt;&gt;</a>
    <div>
</body>
