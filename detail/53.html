<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Cornell University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Cornell University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit 467e1436ba85f78b8c4610c4549eb255a8211c42
Author: Niranjan Sivakumar &lt;ns253@cornell.edu&gt;
Date:   Sat Sep 5 18:20:35 2015 +0200

    ALSA: hda - Fix white noise on Dell M3800
    
    The M3800 is very minor workstation variant of the XPS 15 which has
    already been patched for this issue.  I figured it's probably more
    important for this version of the laptop to be patched than the
    regular XPS as Dell sells is pre-configured with Ubuntu to be used as
    a Linux workstation.  I have tested the patch on my the hardware on
    Linux 4.2.0.
    
    Signed-off-by: Niranjan Sivakumar &lt;ns253@cornell.edu&gt;
    Cc: &lt;stable@vger.kernel.org&gt; # v4.1+
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index f71ee28bf0f3..a75b5611d1e4 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -6384,6 +6384,7 @@ static const struct snd_pci_quirk alc662_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1028, 0x05db, "Dell", ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x05fe, "Dell XPS 15", ALC668_FIXUP_DELL_XPS13),
 	SND_PCI_QUIRK(0x1028, 0x060a, "Dell XPS 13", ALC668_FIXUP_DELL_XPS13),
+	SND_PCI_QUIRK(0x1028, 0x060d, "Dell M3800", ALC668_FIXUP_DELL_XPS13),
 	SND_PCI_QUIRK(0x1028, 0x0625, "Dell", ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0626, "Dell", ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0696, "Dell", ALC668_FIXUP_DELL_MIC_NO_PRESENCE),</pre><hr><pre>commit 772a6e1fff9a8c942e982598632cfc41451e2e9a
Author: Jacob Kiefer &lt;jtk54@cornell.edu&gt;
Date:   Sun Aug 9 15:20:28 2015 -0400

    staging: rtl8723au: Fix Sparse errors in rtw_security.c
    
    This patch fixes the following sparse errors:
    
      CHECK   drivers/staging/rtl8723au/core/rtw_security.c
    drivers/staging/rtl8723au/core/rtw_security.c:189:39: \
      warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8723au/core/rtw_security.c:189:39:    \
      expected unsigned int [unsigned] [usertype] &lt;noident&gt;
    drivers/staging/rtl8723au/core/rtw_security.c:189:39:    \
      got restricted __le32 [usertype] &lt;noident&gt;
    drivers/staging/rtl8723au/core/rtw_security.c:197:39: \
      warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8723au/core/rtw_security.c:197:39:    \
      expected unsigned int [unsigned] [usertype] &lt;noident&gt;
    drivers/staging/rtl8723au/core/rtw_security.c:197:39:    \
      got restricted __le32 [usertype] &lt;noident&gt;
    drivers/staging/rtl8723au/core/rtw_security.c:682:39: \
      warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8723au/core/rtw_security.c:682:39:    \
      expected unsigned int [unsigned] [usertype] &lt;noident&gt;
    drivers/staging/rtl8723au/core/rtw_security.c:682:39:    \
      got restricted __le32 [usertype] &lt;noident&gt;
    drivers/staging/rtl8723au/core/rtw_security.c:694:39: \
      warning: incorrect type in assignment (different base types)
    drivers/staging/rtl8723au/core/rtw_security.c:694:39:    \
      expected unsigned int [unsigned] [usertype] &lt;noident&gt;
    drivers/staging/rtl8723au/core/rtw_security.c:694:39:    \
      got restricted __le32 [usertype] &lt;noident&gt;
    
    Signed-off-by: Jacob Kiefer &lt;jtk54@cornell.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtl8723au/core/rtw_security.c b/drivers/staging/rtl8723au/core/rtw_security.c
index af53c92fc3a2..3d40bab1d9c8 100644
--- a/drivers/staging/rtl8723au/core/rtw_security.c
+++ b/drivers/staging/rtl8723au/core/rtw_security.c
@@ -148,7 +148,7 @@ void rtw_wep_encrypt23a(struct rtw_adapter *padapter,
 		     struct xmit_frame *pxmitframe)
 {
 	/*  exclude ICV */
-	unsigned char crc[4];
+	__le32 crc;
 	struct arc4context mycontext;
 	int curfragnum, length, index;
 	u32 keylength;
@@ -186,18 +186,20 @@ void rtw_wep_encrypt23a(struct rtw_adapter *padapter,
 			length = pattrib-&gt;last_txcmdsz - pattrib-&gt;hdrlen -
 				pattrib-&gt;iv_len - pattrib-&gt;icv_len;
 
-			*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length));
+			crc = cpu_to_le32(getcrc32(payload, length));
 
 			arcfour_init(&amp;mycontext, wepkey, 3 + keylength);
 			arcfour_encrypt(&amp;mycontext, payload, payload, length);
-			arcfour_encrypt(&amp;mycontext, payload + length, crc, 4);
+			arcfour_encrypt(&amp;mycontext, payload + length,
+					(char *)&amp;crc, 4);
 		} else {
 			length = pxmitpriv-&gt;frag_len - pattrib-&gt;hdrlen -
 				pattrib-&gt;iv_len - pattrib-&gt;icv_len;
-			*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length));
+			crc = cpu_to_le32(getcrc32(payload, length));
 			arcfour_init(&amp;mycontext, wepkey, 3 + keylength);
 			arcfour_encrypt(&amp;mycontext, payload, payload, length);
-			arcfour_encrypt(&amp;mycontext, payload + length, crc, 4);
+			arcfour_encrypt(&amp;mycontext, payload + length,
+					(char *)&amp;crc, 4);
 
 			pframe += pxmitpriv-&gt;frag_len;
 			pframe = PTR_ALIGN(pframe, 4);
@@ -602,7 +604,7 @@ int rtw_tkip_encrypt23a(struct rtw_adapter *padapter,
 	u32 pnh;
 	u8 rc4key[16];
 	u8 ttkey[16];
-	u8 crc[4];
+	__le32 crc;
 	u8 hw_hdr_offset = 0;
 	struct arc4context mycontext;
 	int curfragnum, length;
@@ -679,11 +681,12 @@ int rtw_tkip_encrypt23a(struct rtw_adapter *padapter,
 				 "pattrib-&gt;iv_len =%x, pattrib-&gt;icv_len =%x\n",
 				 pattrib-&gt;iv_len,
 				 pattrib-&gt;icv_len);
-			*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length));
+			crc = cpu_to_le32(getcrc32(payload, length));
 
 			arcfour_init(&amp;mycontext, rc4key, 16);
 			arcfour_encrypt(&amp;mycontext, payload, payload, length);
-			arcfour_encrypt(&amp;mycontext, payload + length, crc, 4);
+			arcfour_encrypt(&amp;mycontext, payload + length,
+					(char *)&amp;crc, 4);
 
 		} else {
 			length = (pxmitpriv-&gt;frag_len -
@@ -691,10 +694,11 @@ int rtw_tkip_encrypt23a(struct rtw_adapter *padapter,
 				  pattrib-&gt;iv_len -
 				  pattrib-&gt;icv_len);
 
-			*((u32 *)crc) = cpu_to_le32(getcrc32(payload, length));
+			crc = cpu_to_le32(getcrc32(payload, length));
 			arcfour_init(&amp;mycontext, rc4key, 16);
 			arcfour_encrypt(&amp;mycontext, payload, payload, length);
-			arcfour_encrypt(&amp;mycontext, payload + length, crc, 4);
+			arcfour_encrypt(&amp;mycontext, payload + length,
+					(char *)&amp;crc, 4);
 
 			pframe += pxmitpriv-&gt;frag_len;
 			pframe  = PTR_ALIGN(pframe, 4);</pre><hr><pre>commit 9a2477c2cabddf6fa52eda49502017191b34acb6
Author: Kolbeinn Karlsson &lt;kk752@cornell.edu&gt;
Date:   Sun Jul 19 16:23:19 2015 -0400

    staging: lustre: make functions only used locally static
    
    Add a static modifier to two functions that have no
    separate declaration and are only used within the file they are
    defined in. This problem was reported by sparse.
    
    Signed-off-by: Kolbeinn Karlsson &lt;kk752@cornell.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/lustre/lustre/ptlrpc/events.c b/drivers/staging/lustre/lustre/ptlrpc/events.c
index 8cb1929fd31d..c8ef9e578263 100644
--- a/drivers/staging/lustre/lustre/ptlrpc/events.c
+++ b/drivers/staging/lustre/lustre/ptlrpc/events.c
@@ -485,7 +485,7 @@ int ptlrpc_uuid_to_peer(struct obd_uuid *uuid,
 	return rc;
 }
 
-void ptlrpc_ni_fini(void)
+static void ptlrpc_ni_fini(void)
 {
 	wait_queue_head_t waitq;
 	struct l_wait_info lwi;
@@ -529,7 +529,7 @@ lnet_pid_t ptl_get_pid(void)
 	return pid;
 }
 
-int ptlrpc_ni_init(void)
+static int ptlrpc_ni_init(void)
 {
 	int rc;
 	lnet_pid_t pid;</pre><hr><pre>commit 861e82d5b5a42d2eda34f3123b46162eaae9af80
Author: Jacob Kiefer &lt;jtk54@cornell.edu&gt;
Date:   Fri Jul 10 01:26:30 2015 -0400

    staging: style fix for octeon/ethernet-tx.c
    
    Broke line with greater than 80 characters into two lines and
    improved logical operator readability in hardware checksum if statement.
    
    Signed-off-by: Jacob Kiefer &lt;jtk54@cornell.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/octeon/ethernet-tx.c b/drivers/staging/octeon/ethernet-tx.c
index 7c1c1b052b7d..e2df041ca82d 100644
--- a/drivers/staging/octeon/ethernet-tx.c
+++ b/drivers/staging/octeon/ethernet-tx.c
@@ -396,10 +396,12 @@ int cvm_oct_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	/* Check if we can use the hardware checksumming */
 	if ((skb-&gt;protocol == htons(ETH_P_IP)) &amp;&amp;
-	    (ip_hdr(skb)-&gt;version == 4) &amp;&amp; (ip_hdr(skb)-&gt;ihl == 5) &amp;&amp;
-	    ((ip_hdr(skb)-&gt;frag_off == 0) || (ip_hdr(skb)-&gt;frag_off == htons(1 &lt;&lt; 14)))
-	    &amp;&amp; ((ip_hdr(skb)-&gt;protocol == IPPROTO_TCP)
-		|| (ip_hdr(skb)-&gt;protocol == IPPROTO_UDP))) {
+	    (ip_hdr(skb)-&gt;version == 4) &amp;&amp;
+	    (ip_hdr(skb)-&gt;ihl == 5) &amp;&amp;
+	    ((ip_hdr(skb)-&gt;frag_off == 0) ||
+	     (ip_hdr(skb)-&gt;frag_off == htons(1 &lt;&lt; 14))) &amp;&amp;
+	    ((ip_hdr(skb)-&gt;protocol == IPPROTO_TCP) ||
+	     (ip_hdr(skb)-&gt;protocol == IPPROTO_UDP))) {
 		/* Use hardware checksum calc */
 		pko_command.s.ipoffp1 = sizeof(struct ethhdr) + 1;
 	}</pre><hr><pre>commit 6c6bd754bf43d59756f094de144ecac239629dda
Author: Brian Rogan &lt;bcr6@cornell.edu&gt;
Date:   Mon Mar 27 11:57:01 2006 +1100

    [PATCH] powerpc: Add oprofile calltrace support
    
    Add oprofile calltrace support to powerpc. Disable spinlock backtracing
    now we can use calltrace info.
    
    (Updated to work on both 32bit and 64bit by me).
    
    Signed-off-by: Anton Blanchard &lt;anton@samba.org&gt;
    Signed-off-by: Paul Mackerras &lt;paulus@samba.org&gt;

diff --git a/arch/powerpc/oprofile/Makefile b/arch/powerpc/oprofile/Makefile
index 554cd7c75321..f5f9859a8338 100644
--- a/arch/powerpc/oprofile/Makefile
+++ b/arch/powerpc/oprofile/Makefile
@@ -6,7 +6,7 @@ DRIVER_OBJS := $(addprefix ../../../drivers/oprofile/, \
 		oprofilefs.o oprofile_stats.o \
 		timer_int.o )
 
-oprofile-y := $(DRIVER_OBJS) common.o
+oprofile-y := $(DRIVER_OBJS) common.o backtrace.o
 oprofile-$(CONFIG_PPC64) += op_model_rs64.o op_model_power4.o
 oprofile-$(CONFIG_FSL_BOOKE) += op_model_fsl_booke.o
 oprofile-$(CONFIG_PPC32) += op_model_7450.o
diff --git a/arch/powerpc/oprofile/backtrace.c b/arch/powerpc/oprofile/backtrace.c
new file mode 100644
index 000000000000..75f57bc96b40
--- /dev/null
+++ b/arch/powerpc/oprofile/backtrace.c
@@ -0,0 +1,126 @@
+/**
+ * Copyright (C) 2005 Brian Rogan &lt;bcr6@cornell.edu&gt;, IBM
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+**/
+
+#include &lt;linux/oprofile.h&gt;
+#include &lt;linux/sched.h&gt;
+#include &lt;asm/processor.h&gt;
+#include &lt;asm/uaccess.h&gt;
+
+#define STACK_SP(STACK)		*(STACK)
+
+#define STACK_LR64(STACK)	*((unsigned long *)(STACK) + 2)
+#define STACK_LR32(STACK)	*((unsigned int *)(STACK) + 1)
+
+#ifdef CONFIG_PPC64
+#define STACK_LR(STACK)		STACK_LR64(STACK)
+#else
+#define STACK_LR(STACK)		STACK_LR32(STACK)
+#endif
+
+static unsigned int user_getsp32(unsigned int sp, int is_first)
+{
+	unsigned int stack_frame[2];
+
+	if (!access_ok(VERIFY_READ, sp, sizeof(stack_frame)))
+		return 0;
+
+	/*
+	 * The most likely reason for this is that we returned -EFAULT,
+	 * which means that we've done all that we can do from
+	 * interrupt context.
+	 */
+	if (__copy_from_user_inatomic(stack_frame, (void *)(long)sp,
+					sizeof(stack_frame)))
+		return 0;
+
+	if (!is_first)
+		oprofile_add_trace(STACK_LR32(stack_frame));
+
+	/*
+	 * We do not enforce increasing stack addresses here because
+	 * we may transition to a different stack, eg a signal handler.
+	 */
+	return STACK_SP(stack_frame);
+}
+
+#ifdef CONFIG_PPC64
+static unsigned long user_getsp64(unsigned long sp, int is_first)
+{
+	unsigned long stack_frame[3];
+
+	if (!access_ok(VERIFY_READ, sp, sizeof(stack_frame)))
+		return 0;
+
+	if (__copy_from_user_inatomic(stack_frame, (void *)sp,
+					sizeof(stack_frame)))
+		return 0;
+
+	if (!is_first)
+		oprofile_add_trace(STACK_LR64(stack_frame));
+
+	return STACK_SP(stack_frame);
+}
+#endif
+
+static unsigned long kernel_getsp(unsigned long sp, int is_first)
+{
+	unsigned long *stack_frame = (unsigned long *)sp;
+
+	if (!validate_sp(sp, current, STACK_FRAME_OVERHEAD))
+		return 0;
+
+	if (!is_first)
+		oprofile_add_trace(STACK_LR(stack_frame));
+
+	/*
+	 * We do not enforce increasing stack addresses here because
+	 * we might be transitioning from an interrupt stack to a kernel
+	 * stack. validate_sp() is designed to understand this, so just
+	 * use it.
+	 */
+	return STACK_SP(stack_frame);
+}
+
+void op_powerpc_backtrace(struct pt_regs * const regs, unsigned int depth)
+{
+	unsigned long sp = regs-&gt;gpr[1];
+	int first_frame = 1;
+
+	/* We ditch the top stackframe so need to loop through an extra time */
+	depth += 1;
+
+	if (!user_mode(regs)) {
+		while (depth--) {
+			sp = kernel_getsp(sp, first_frame);
+			if (!sp)
+				break;
+			first_frame = 0;
+		}
+	} else {
+#ifdef CONFIG_PPC64
+		if (!test_thread_flag(TIF_32BIT)) {
+			while (depth--) {
+				sp = user_getsp64(sp, first_frame);
+				if (!sp)
+					break;
+				first_frame = 0;
+			}
+
+			return;
+		}
+#endif
+
+		while (depth--) {
+			sp = user_getsp32(sp, first_frame);
+			if (!sp)
+				break;
+			first_frame = 0;
+		}
+	}
+}
diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index cc2535be3a73..2b9143b0f6ba 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -126,8 +126,7 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 	sys.enable_kernel = 1;
 	sys.enable_user = 1;
 #ifdef CONFIG_PPC64
-	/* Turn on backtracing through spinlocks by default */
-	sys.backtrace_spinlocks = 1;
+	sys.backtrace_spinlocks = 0;
 #endif
 
 	return 0;
@@ -168,6 +167,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	ops-&gt;shutdown = op_powerpc_shutdown;
 	ops-&gt;start = op_powerpc_start;
 	ops-&gt;stop = op_powerpc_stop;
+	ops-&gt;backtrace = op_powerpc_backtrace;
 
 	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
 	       ops-&gt;cpu_type);
diff --git a/arch/powerpc/oprofile/op_model_power4.c b/arch/powerpc/oprofile/op_model_power4.c
index 4b06e53eb9b4..38db2efef3bc 100644
--- a/arch/powerpc/oprofile/op_model_power4.c
+++ b/arch/powerpc/oprofile/op_model_power4.c
@@ -293,7 +293,7 @@ static void power4_handle_interrupt(struct pt_regs *regs,
 		val = ctr_read(i);
 		if (val &lt; 0) {
 			if (oprofile_running &amp;&amp; ctr[i].enabled) {
-				oprofile_add_pc(pc, is_kernel, i);
+				oprofile_add_ext_sample(pc, regs, i, is_kernel);
 				ctr_write(i, reset_value[i]);
 			} else {
 				ctr_write(i, 0);
diff --git a/include/asm-powerpc/oprofile_impl.h b/include/asm-powerpc/oprofile_impl.h
index df4defc6321c..aa180e907a67 100644
--- a/include/asm-powerpc/oprofile_impl.h
+++ b/include/asm-powerpc/oprofile_impl.h
@@ -126,5 +126,7 @@ static inline void ctr_write(unsigned int i, unsigned int val)
 }
 #endif /* !CONFIG_FSL_BOOKE */
 
+extern void op_powerpc_backtrace(struct pt_regs * const regs, unsigned int depth);
+
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_OPROFILE_IMPL_H */</pre><hr><pre>commit 273577165cd206d2d6689ee4b18aa13de1ec4bde
Author: Brian Rogan &lt;bcr6@cornell.edu&gt;
Date:   Tue Mar 28 01:56:20 2006 -0800

    [PATCH] Add oprofile_add_ext_sample
    
    On ppc64 we look at a profiling register to work out the sample address and
    if it was in userspace or kernel.
    
    The backtrace interface oprofile_add_sample does not allow this.  Create
    oprofile_add_ext_sample and make oprofile_add_sample use it too.
    
    Signed-off-by: Anton Blanchard &lt;anton@samba.org&gt;
    Cc: Philippe Elie &lt;phil.el@wanadoo.fr&gt;
    Cc: John Levon &lt;levon@movementarian.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/oprofile/cpu_buffer.c b/drivers/oprofile/cpu_buffer.c
index 330d3869b41e..fc4bc9b94c74 100644
--- a/drivers/oprofile/cpu_buffer.c
+++ b/drivers/oprofile/cpu_buffer.c
@@ -217,11 +217,10 @@ static void oprofile_end_trace(struct oprofile_cpu_buffer * cpu_buf)
 	cpu_buf-&gt;tracing = 0;
 }
 
-void oprofile_add_sample(struct pt_regs * const regs, unsigned long event)
+void oprofile_add_ext_sample(unsigned long pc, struct pt_regs * const regs,
+				unsigned long event, int is_kernel)
 {
 	struct oprofile_cpu_buffer * cpu_buf = &amp;cpu_buffer[smp_processor_id()];
-	unsigned long pc = profile_pc(regs);
-	int is_kernel = !user_mode(regs);
 
 	if (!backtrace_depth) {
 		log_sample(cpu_buf, pc, is_kernel, event);
@@ -238,6 +237,14 @@ void oprofile_add_sample(struct pt_regs * const regs, unsigned long event)
 	oprofile_end_trace(cpu_buf);
 }
 
+void oprofile_add_sample(struct pt_regs * const regs, unsigned long event)
+{
+	int is_kernel = !user_mode(regs);
+	unsigned long pc = profile_pc(regs);
+
+	oprofile_add_ext_sample(pc, regs, event, is_kernel);
+}
+
 void oprofile_add_pc(unsigned long pc, int is_kernel, unsigned long event)
 {
 	struct oprofile_cpu_buffer * cpu_buf = &amp;cpu_buffer[smp_processor_id()];
diff --git a/include/linux/oprofile.h b/include/linux/oprofile.h
index 559c4c38a9c7..b5b3197dfd4f 100644
--- a/include/linux/oprofile.h
+++ b/include/linux/oprofile.h
@@ -61,6 +61,16 @@ void oprofile_arch_exit(void);
  */
 void oprofile_add_sample(struct pt_regs * const regs, unsigned long event);
 
+/**
+ * Add an extended sample.  Use this when the PC is not from the regs, and
+ * we cannot determine if we're in kernel mode from the regs.
+ *
+ * This function does perform a backtrace.
+ *
+ */
+void oprofile_add_ext_sample(unsigned long pc, struct pt_regs * const regs,
+				unsigned long event, int is_kernel);
+
 /* Use this instead when the PC value is not from the regs. Doesn't
  * backtrace. */
 void oprofile_add_pc(unsigned long pc, int is_kernel, unsigned long event);</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
