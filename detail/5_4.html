<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_3.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><span>[4]</span><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 5d9fb5cc1b88277bb28a2a54e51b34cacaa123c2
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 17 23:56:57 2012 -0500

    [SCSI] core, classes, mpt2sas: have scsi_internal_device_unblock take new state
    
    This has scsi_internal_device_unblock/scsi_target_unblock take
    the new state to set the devices as an argument instead of
    always setting to running. The patch also converts users of these
    functions.
    
    This allows the FC and iSCSI class to transition devices from blocked
    to transport-offline, so that when fast_io_fail/replacement_timeout
    has fired we do not set the devices back to running. Instead, we
    set them to SDEV_TRANSPORT_OFFLINE.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/mpt2sas/mpt2sas_base.h b/drivers/scsi/mpt2sas/mpt2sas_base.h
index b6dd3a5de7f9..b3a1a30055d6 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_base.h
+++ b/drivers/scsi/mpt2sas/mpt2sas_base.h
@@ -1158,6 +1158,7 @@ extern struct scsi_transport_template *mpt2sas_transport_template;
 extern int scsi_internal_device_block(struct scsi_device *sdev);
 extern u8 mpt2sas_stm_zero_smid_handler(struct MPT2SAS_ADAPTER *ioc,
     u8 msix_index, u32 reply);
-extern int scsi_internal_device_unblock(struct scsi_device *sdev);
+extern int scsi_internal_device_unblock(struct scsi_device *sdev,
+					enum scsi_device_state new_state);
 
 #endif /* MPT2SAS_BASE_H_INCLUDED */
diff --git a/drivers/scsi/mpt2sas/mpt2sas_scsih.c b/drivers/scsi/mpt2sas/mpt2sas_scsih.c
index 76973e8ca4ba..b1ebd6f8dab3 100644
--- a/drivers/scsi/mpt2sas/mpt2sas_scsih.c
+++ b/drivers/scsi/mpt2sas/mpt2sas_scsih.c
@@ -2904,7 +2904,7 @@ _scsih_ublock_io_all_device(struct MPT2SAS_ADAPTER *ioc)
 		dewtprintk(ioc, sdev_printk(KERN_INFO, sdev, "device_running, "
 		    "handle(0x%04x)\n",
 		    sas_device_priv_data-&gt;sas_target-&gt;handle));
-		scsi_internal_device_unblock(sdev);
+		scsi_internal_device_unblock(sdev, SDEV_RUNNING);
 	}
 }
 /**
@@ -2933,7 +2933,7 @@ _scsih_ublock_io_device(struct MPT2SAS_ADAPTER *ioc, u64 sas_address)
 			    "sas address(0x%016llx)\n", ioc-&gt;name,
 				(unsigned long long)sas_address));
 			sas_device_priv_data-&gt;block = 0;
-			scsi_internal_device_unblock(sdev);
+			scsi_internal_device_unblock(sdev, SDEV_RUNNING);
 		}
 	}
 }
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 340c569d4535..36521a0ac54b 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -2444,6 +2444,7 @@ EXPORT_SYMBOL_GPL(scsi_internal_device_block);
 /**
  * scsi_internal_device_unblock - resume a device after a block request
  * @sdev:	device to resume
+ * @new_state:	state to set devices to after unblocking
  *
  * Called by scsi lld's or the midlayer to restart the device queue
  * for the previously suspended scsi device.  Called from interrupt or
@@ -2453,25 +2454,30 @@ EXPORT_SYMBOL_GPL(scsi_internal_device_block);
  *
  * Notes:       
  *	This routine transitions the device to the SDEV_RUNNING state
- *	(which must be a legal transition) allowing the midlayer to
- *	goose the queue for this device.  This routine assumes the 
- *	host_lock is held upon entry.
+ *	or to one of the offline states (which must be a legal transition)
+ *	allowing the midlayer to goose the queue for this device. This
+ *	routine assumes the host_lock is held upon entry.
  */
 int
-scsi_internal_device_unblock(struct scsi_device *sdev)
+scsi_internal_device_unblock(struct scsi_device *sdev,
+			     enum scsi_device_state new_state)
 {
 	struct request_queue *q = sdev-&gt;request_queue; 
 	unsigned long flags;
-	
-	/* 
-	 * Try to transition the scsi device to SDEV_RUNNING
-	 * and goose the device queue if successful.  
+
+	/*
+	 * Try to transition the scsi device to SDEV_RUNNING or one of the
+	 * offlined states and goose the device queue if successful.
 	 */
 	if (sdev-&gt;sdev_state == SDEV_BLOCK)
-		sdev-&gt;sdev_state = SDEV_RUNNING;
-	else if (sdev-&gt;sdev_state == SDEV_CREATED_BLOCK)
-		sdev-&gt;sdev_state = SDEV_CREATED;
-	else if (sdev-&gt;sdev_state != SDEV_CANCEL &amp;&amp;
+		sdev-&gt;sdev_state = new_state;
+	else if (sdev-&gt;sdev_state == SDEV_CREATED_BLOCK) {
+		if (new_state == SDEV_TRANSPORT_OFFLINE ||
+		    new_state == SDEV_OFFLINE)
+			sdev-&gt;sdev_state = new_state;
+		else
+			sdev-&gt;sdev_state = SDEV_CREATED;
+	} else if (sdev-&gt;sdev_state != SDEV_CANCEL &amp;&amp;
 		 sdev-&gt;sdev_state != SDEV_OFFLINE)
 		return -EINVAL;
 
@@ -2512,26 +2518,26 @@ EXPORT_SYMBOL_GPL(scsi_target_block);
 static void
 device_unblock(struct scsi_device *sdev, void *data)
 {
-	scsi_internal_device_unblock(sdev);
+	scsi_internal_device_unblock(sdev, *(enum scsi_device_state *)data);
 }
 
 static int
 target_unblock(struct device *dev, void *data)
 {
 	if (scsi_is_target_device(dev))
-		starget_for_each_device(to_scsi_target(dev), NULL,
+		starget_for_each_device(to_scsi_target(dev), data,
 					device_unblock);
 	return 0;
 }
 
 void
-scsi_target_unblock(struct device *dev)
+scsi_target_unblock(struct device *dev, enum scsi_device_state new_state)
 {
 	if (scsi_is_target_device(dev))
-		starget_for_each_device(to_scsi_target(dev), NULL,
+		starget_for_each_device(to_scsi_target(dev), &amp;new_state,
 					device_unblock);
 	else
-		device_for_each_child(dev, NULL, target_unblock);
+		device_for_each_child(dev, &amp;new_state, target_unblock);
 }
 EXPORT_SYMBOL_GPL(scsi_target_unblock);
 
diff --git a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
index 07ce3f51701d..cbfe5df24a3b 100644
--- a/drivers/scsi/scsi_priv.h
+++ b/drivers/scsi/scsi_priv.h
@@ -2,6 +2,7 @@
 #define _SCSI_PRIV_H
 
 #include &lt;linux/device.h&gt;
+#include &lt;scsi/scsi_device.h&gt;
 
 struct request_queue;
 struct request;
@@ -172,6 +173,7 @@ extern struct list_head scsi_sd_probe_domain;
 
 #define SCSI_DEVICE_BLOCK_MAX_TIMEOUT	600	/* units in seconds */
 extern int scsi_internal_device_block(struct scsi_device *sdev);
-extern int scsi_internal_device_unblock(struct scsi_device *sdev);
+extern int scsi_internal_device_unblock(struct scsi_device *sdev,
+					enum scsi_device_state new_state);
 
 #endif /* _SCSI_PRIV_H */
diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 2fded793997c..2d1e68db9b3f 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -2495,11 +2495,9 @@ static void fc_terminate_rport_io(struct fc_rport *rport)
 		i-&gt;f-&gt;terminate_rport_io(rport);
 
 	/*
-	 * must unblock to flush queued IO. The caller will have set
-	 * the port_state or flags, so that fc_remote_port_chkready will
-	 * fail IO.
+	 * Must unblock to flush queued IO. scsi-ml will fail incoming reqs.
 	 */
-	scsi_target_unblock(&amp;rport-&gt;dev);
+	scsi_target_unblock(&amp;rport-&gt;dev, SDEV_TRANSPORT_OFFLINE);
 }
 
 /**
@@ -2830,8 +2828,8 @@ fc_remote_port_add(struct Scsi_Host *shost, int channel,
 
 				/* if target, initiate a scan */
 				if (rport-&gt;scsi_target_id != -1) {
-					scsi_target_unblock(&amp;rport-&gt;dev);
-
+					scsi_target_unblock(&amp;rport-&gt;dev,
+							    SDEV_RUNNING);
 					spin_lock_irqsave(shost-&gt;host_lock,
 							  flags);
 					rport-&gt;flags |= FC_RPORT_SCAN_PENDING;
@@ -2900,7 +2898,7 @@ fc_remote_port_add(struct Scsi_Host *shost, int channel,
 			spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 
 			if (ids-&gt;roles &amp; FC_PORT_ROLE_FCP_TARGET) {
-				scsi_target_unblock(&amp;rport-&gt;dev);
+				scsi_target_unblock(&amp;rport-&gt;dev, SDEV_RUNNING);
 
 				/* initiate a scan of the target */
 				spin_lock_irqsave(shost-&gt;host_lock, flags);
@@ -3105,7 +3103,7 @@ fc_remote_port_rolechg(struct fc_rport  *rport, u32 roles)
 		/* ensure any stgt delete functions are done */
 		fc_flush_work(shost);
 
-		scsi_target_unblock(&amp;rport-&gt;dev);
+		scsi_target_unblock(&amp;rport-&gt;dev, SDEV_RUNNING);
 		/* initiate a scan of the target */
 		spin_lock_irqsave(shost-&gt;host_lock, flags);
 		rport-&gt;flags |= FC_RPORT_SCAN_PENDING;
@@ -3149,7 +3147,7 @@ fc_timeout_deleted_rport(struct work_struct *work)
 			"blocked FC remote port time out: no longer"
 			" a FCP target, removing starget\n");
 		spin_unlock_irqrestore(shost-&gt;host_lock, flags);
-		scsi_target_unblock(&amp;rport-&gt;dev);
+		scsi_target_unblock(&amp;rport-&gt;dev, SDEV_TRANSPORT_OFFLINE);
 		fc_queue_work(shost, &amp;rport-&gt;stgt_delete_work);
 		return;
 	}
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 1cf640e575da..96ec21a959e9 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -907,7 +907,7 @@ static void session_recovery_timedout(struct work_struct *work)
 		session-&gt;transport-&gt;session_recovery_timedout(session);
 
 	ISCSI_DBG_TRANS_SESSION(session, "Unblocking SCSI target\n");
-	scsi_target_unblock(&amp;session-&gt;dev);
+	scsi_target_unblock(&amp;session-&gt;dev, SDEV_TRANSPORT_OFFLINE);
 	ISCSI_DBG_TRANS_SESSION(session, "Completed unblocking SCSI target\n");
 }
 
@@ -930,7 +930,7 @@ static void __iscsi_unblock_session(struct work_struct *work)
 	session-&gt;state = ISCSI_SESSION_LOGGED_IN;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	/* start IO */
-	scsi_target_unblock(&amp;session-&gt;dev);
+	scsi_target_unblock(&amp;session-&gt;dev, SDEV_RUNNING);
 	/*
 	 * Only do kernel scanning if the driver is properly hooked into
 	 * the async scanning code (drivers like iscsi_tcp do login and
@@ -1180,7 +1180,7 @@ void iscsi_remove_session(struct iscsi_cls_session *session)
 	session-&gt;state = ISCSI_SESSION_FREE;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 
-	scsi_target_unblock(&amp;session-&gt;dev);
+	scsi_target_unblock(&amp;session-&gt;dev, SDEV_TRANSPORT_OFFLINE);
 	/* flush running scans then delete devices */
 	scsi_flush_work(shost);
 	__iscsi_unbind_session(&amp;session-&gt;unbind_work);
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 404575857962..bd1a14d89009 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -374,7 +374,7 @@ extern void scsi_scan_target(struct device *parent, unsigned int channel,
 			     unsigned int id, unsigned int lun, int rescan);
 extern void scsi_target_reap(struct scsi_target *);
 extern void scsi_target_block(struct device *);
-extern void scsi_target_unblock(struct device *);
+extern void scsi_target_unblock(struct device *, enum scsi_device_state);
 extern void scsi_remove_target(struct device *);
 extern void int_to_scsilun(unsigned int, struct scsi_lun *);
 extern int scsilun_to_int(struct scsi_lun *);</pre><hr><pre>commit 1b8d26206134458044b0689f48194af00c96d406
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 17 23:56:56 2012 -0500

    [SCSI] add new SDEV_TRANSPORT_OFFLINE state
    
    This patch adds a new state SDEV_TRANSPORT_OFFLINE. It will
    be used by transport classes to offline devices for cases like
    when the fast_io_fail/recovery_tmo fires. In those cases we
    want all IO to fail, and we have not yet escalated to dev_loss_tmo
    behavior where we are removing the devices.
    
    Currently to handle this state, transport classes are setting
    the scsi_device's state to running, setting their internal
    session/port structs state to something that indicates failed,
    and then failing IO from some transport check in the queuecommand.
    
    The reason for the new value is so that users can distinguish
    between a device failure that is a result of a transport problem
    vs the wide range of errors that devices get offlined for
    when a scsi command times out and we offline the devices there.
    It also fixes the confusion as to why the transport class is
    failing IO, but has set the device state from blocked to running.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 6dfb9785d345..340c569d4535 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -1173,6 +1173,7 @@ int scsi_prep_state_check(struct scsi_device *sdev, struct request *req)
 	if (unlikely(sdev-&gt;sdev_state != SDEV_RUNNING)) {
 		switch (sdev-&gt;sdev_state) {
 		case SDEV_OFFLINE:
+		case SDEV_TRANSPORT_OFFLINE:
 			/*
 			 * If the device is offline we refuse to process any
 			 * commands.  The device must be brought online
@@ -2081,6 +2082,7 @@ scsi_device_set_state(struct scsi_device *sdev, enum scsi_device_state state)
 		switch (oldstate) {
 		case SDEV_CREATED:
 		case SDEV_OFFLINE:
+		case SDEV_TRANSPORT_OFFLINE:
 		case SDEV_QUIESCE:
 		case SDEV_BLOCK:
 			break;
@@ -2093,6 +2095,7 @@ scsi_device_set_state(struct scsi_device *sdev, enum scsi_device_state state)
 		switch (oldstate) {
 		case SDEV_RUNNING:
 		case SDEV_OFFLINE:
+		case SDEV_TRANSPORT_OFFLINE:
 			break;
 		default:
 			goto illegal;
@@ -2100,6 +2103,7 @@ scsi_device_set_state(struct scsi_device *sdev, enum scsi_device_state state)
 		break;
 
 	case SDEV_OFFLINE:
+	case SDEV_TRANSPORT_OFFLINE:
 		switch (oldstate) {
 		case SDEV_CREATED:
 		case SDEV_RUNNING:
@@ -2136,6 +2140,7 @@ scsi_device_set_state(struct scsi_device *sdev, enum scsi_device_state state)
 		case SDEV_RUNNING:
 		case SDEV_QUIESCE:
 		case SDEV_OFFLINE:
+		case SDEV_TRANSPORT_OFFLINE:
 		case SDEV_BLOCK:
 			break;
 		default:
@@ -2148,6 +2153,7 @@ scsi_device_set_state(struct scsi_device *sdev, enum scsi_device_state state)
 		case SDEV_CREATED:
 		case SDEV_RUNNING:
 		case SDEV_OFFLINE:
+		case SDEV_TRANSPORT_OFFLINE:
 		case SDEV_CANCEL:
 			break;
 		default:
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 04c2a278076e..5747478a2bf8 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -35,6 +35,7 @@ static const struct {
 	{ SDEV_DEL, "deleted" },
 	{ SDEV_QUIESCE, "quiesce" },
 	{ SDEV_OFFLINE,	"offline" },
+	{ SDEV_TRANSPORT_OFFLINE, "transport-offline" },
 	{ SDEV_BLOCK,	"blocked" },
 	{ SDEV_CREATED_BLOCK, "created-blocked" },
 };
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index ba9698852321..404575857962 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -42,6 +42,7 @@ enum scsi_device_state {
 				 * originate in the mid-layer) */
 	SDEV_OFFLINE,		/* Device offlined (by error handling or
 				 * user request */
+	SDEV_TRANSPORT_OFFLINE,	/* Offlined by transport class error handler */
 	SDEV_BLOCK,		/* Device blocked by scsi lld.  No
 				 * scsi commands from user or midlayer
 				 * should be issued to the scsi
@@ -421,6 +422,7 @@ static inline unsigned int sdev_id(struct scsi_device *sdev)
 static inline int scsi_device_online(struct scsi_device *sdev)
 {
 	return (sdev-&gt;sdev_state != SDEV_OFFLINE &amp;&amp;
+		sdev-&gt;sdev_state != SDEV_TRANSPORT_OFFLINE &amp;&amp;
 		sdev-&gt;sdev_state != SDEV_DEL);
 }
 static inline int scsi_device_blocked(struct scsi_device *sdev)</pre><hr><pre>commit f220fd4efb334a772f9a14b2372175f38d89355e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Sun Jun 3 00:29:45 2012 +0100

    dm mpath: delay retry of bypassed pg
    
    If I/O needs retrying and only bypassed priority groups are available,
    set the pg_init_delay_retry flag to wait before retrying.
    
    If, for example, the reason for the bypass is that the controller is
    getting reset or there is a firmware upgrade happening, retrying right
    away would cause a flood of log messages and retries for what could be a
    few seconds or even several minutes.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Acked-by: Mike Snitzer &lt;snitzer@redhat.com&gt;
    Signed-off-by: Alasdair G Kergon &lt;agk@redhat.com&gt;

diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c
index c35160786cf4..2469ba68dc2b 100644
--- a/drivers/md/dm-mpath.c
+++ b/drivers/md/dm-mpath.c
@@ -329,14 +329,18 @@ static void __choose_pgpath(struct multipath *m, size_t nr_bytes)
 	/*
 	 * Loop through priority groups until we find a valid path.
 	 * First time we skip PGs marked 'bypassed'.
-	 * Second time we only try the ones we skipped.
+	 * Second time we only try the ones we skipped, but set
+	 * pg_init_delay_retry so we do not hammer controllers.
 	 */
 	do {
 		list_for_each_entry(pg, &amp;m-&gt;priority_groups, list) {
 			if (pg-&gt;bypassed == bypassed)
 				continue;
-			if (!__choose_path_in_pg(m, pg, nr_bytes))
+			if (!__choose_path_in_pg(m, pg, nr_bytes)) {
+				if (!bypassed)
+					m-&gt;pg_init_delay_retry = 1;
 				return;
+			}
 		}
 	} while (bypassed--);
 </pre><hr><pre>commit b83d543fd934d565fb243ef348b06a61d794b31d
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 23 20:40:54 2012 -0500

    [SCSI] be2iscsi: fix dma free size mismatch regression
    
    This patch should go into 3.5 fixes. The bug was added in the
    patches for the 3.5 feature window.
    
    As you can see from the patch I made a mistake. During
    development I switched from passing a struct to the size of
    the struct, but left the sizeof. This results in us allocating
    4 bytes (sizeof(int)) but then calling pci_free_consistent
    with the size of the struct.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index 01bb04cd9e75..2a096795b9aa 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -571,13 +571,12 @@ static int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,
 static int mgmt_alloc_cmd_data(struct beiscsi_hba *phba, struct be_dma_mem *cmd,
 			       int iscsi_cmd, int size)
 {
-	cmd-&gt;va = pci_alloc_consistent(phba-&gt;ctrl.pdev, sizeof(size),
-				       &amp;cmd-&gt;dma);
+	cmd-&gt;va = pci_alloc_consistent(phba-&gt;ctrl.pdev, size, &amp;cmd-&gt;dma);
 	if (!cmd-&gt;va) {
 		SE_DEBUG(DBG_LVL_1, "Failed to allocate memory for if info\n");
 		return -ENOMEM;
 	}
-	memset(cmd-&gt;va, 0, sizeof(size));
+	memset(cmd-&gt;va, 0, size);
 	cmd-&gt;size = size;
 	be_cmd_hdr_prepare(cmd-&gt;va, CMD_SUBSYSTEM_ISCSI, iscsi_cmd, size);
 	return 0;</pre><hr><pre>commit 8fb2ef89b696624ea9853868e370d2e132e76f54
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Sun Apr 15 21:47:50 2012 -0500

    [SCSI] fc class: fix scanning when devs are offline
    
    When a rport is added back or the role is changed the fc class
    will queue a scan and then call scsi_target_unblock. The problem
    with this is if the devices are in the SDEV_OFFLINE state and
    the scan is run before the scsi_target_unblock, then the scan
    will see LUN0 as offline and the scan will fail. This patch moves
    the unblock call to before the scan, so we know the device state
    will be set correctly when the scan is run.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 80fbe2ac0b47..579760420d53 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -2808,17 +2808,20 @@ fc_remote_port_add(struct Scsi_Host *shost, int channel,
 						  FC_RPORT_DEVLOSS_PENDING |
 						  FC_RPORT_DEVLOSS_CALLBK_DONE);
 
+				spin_unlock_irqrestore(shost-&gt;host_lock, flags);
+
 				/* if target, initiate a scan */
 				if (rport-&gt;scsi_target_id != -1) {
+					scsi_target_unblock(&amp;rport-&gt;dev);
+
+					spin_lock_irqsave(shost-&gt;host_lock,
+							  flags);
 					rport-&gt;flags |= FC_RPORT_SCAN_PENDING;
 					scsi_queue_work(shost,
 							&amp;rport-&gt;scan_work);
 					spin_unlock_irqrestore(shost-&gt;host_lock,
 							flags);
-					scsi_target_unblock(&amp;rport-&gt;dev);
-				} else
-					spin_unlock_irqrestore(shost-&gt;host_lock,
-							flags);
+				}
 
 				fc_bsg_goose_queue(rport);
 
@@ -2876,16 +2879,17 @@ fc_remote_port_add(struct Scsi_Host *shost, int channel,
 			if (fci-&gt;f-&gt;dd_fcrport_size)
 				memset(rport-&gt;dd_data, 0,
 						fci-&gt;f-&gt;dd_fcrport_size);
+			spin_unlock_irqrestore(shost-&gt;host_lock, flags);
+
+			if (ids-&gt;roles &amp; FC_PORT_ROLE_FCP_TARGET) {
+				scsi_target_unblock(&amp;rport-&gt;dev);
 
-			if (rport-&gt;roles &amp; FC_PORT_ROLE_FCP_TARGET) {
 				/* initiate a scan of the target */
+				spin_lock_irqsave(shost-&gt;host_lock, flags);
 				rport-&gt;flags |= FC_RPORT_SCAN_PENDING;
 				scsi_queue_work(shost, &amp;rport-&gt;scan_work);
 				spin_unlock_irqrestore(shost-&gt;host_lock, flags);
-				scsi_target_unblock(&amp;rport-&gt;dev);
-			} else
-				spin_unlock_irqrestore(shost-&gt;host_lock, flags);
-
+			}
 			return rport;
 		}
 	}
@@ -3083,12 +3087,12 @@ fc_remote_port_rolechg(struct fc_rport  *rport, u32 roles)
 		/* ensure any stgt delete functions are done */
 		fc_flush_work(shost);
 
+		scsi_target_unblock(&amp;rport-&gt;dev);
 		/* initiate a scan of the target */
 		spin_lock_irqsave(shost-&gt;host_lock, flags);
 		rport-&gt;flags |= FC_RPORT_SCAN_PENDING;
 		scsi_queue_work(shost, &amp;rport-&gt;scan_work);
 		spin_unlock_irqrestore(shost-&gt;host_lock, flags);
-		scsi_target_unblock(&amp;rport-&gt;dev);
 	}
 }
 EXPORT_SYMBOL(fc_remote_port_rolechg);</pre><hr><pre>commit 0e43895ec1f405a25b5d57bc95c11fe17224ec43
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Apr 3 23:41:51 2012 -0500

    [SCSI] be2iscsi: adding functionality to change network settings using iscsiadm
    
    This patch allows iscsiadm to set/ delete static IP and enable /disable
    DHCP.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Jayamohan Kallickal &lt;jayamohan.kallickal@emulex.com&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/be2iscsi/be_cmds.h b/drivers/scsi/be2iscsi/be_cmds.h
index b15de3eaddf0..60d144550f76 100644
--- a/drivers/scsi/be2iscsi/be_cmds.h
+++ b/drivers/scsi/be2iscsi/be_cmds.h
@@ -163,7 +163,8 @@ struct be_mcc_mailbox {
 #define OPCODE_COMMON_ISCSI_CFG_REMOVE_SGL_PAGES        3
 #define OPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG		7
 #define OPCODE_COMMON_ISCSI_NTWK_SET_VLAN		14
-#define OPCODE_COMMON_ISCSI_NTWK_CONFIGURE_STATELESS_IP_ADDR	17
+#define OPCODE_COMMON_ISCSI_NTWK_CONFIG_STATELESS_IP_ADDR	17
+#define OPCODE_COMMON_ISCSI_NTWK_REL_STATELESS_IP_ADDR	18
 #define OPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR		21
 #define OPCODE_COMMON_ISCSI_NTWK_GET_DEFAULT_GATEWAY	22
 #define OPCODE_COMMON_ISCSI_NTWK_MODIFY_DEFAULT_GATEWAY 23
@@ -274,15 +275,15 @@ struct mgmt_conn_login_options {
 	struct	mgmt_auth_method_format auth_data;
 } __packed;
 
-struct ip_address_format {
+struct ip_addr_format {
 	u16 size_of_structure;
 	u8 reserved;
 	u8 ip_type;
-	u8 ip_address[16];
+	u8 addr[16];
 	u32 rsvd0;
 } __packed;
 
-struct	mgmt_conn_info {
+struct mgmt_conn_info {
 	u32	connection_handle;
 	u32	connection_status;
 	u16	src_port;
@@ -290,9 +291,9 @@ struct	mgmt_conn_info {
 	u16	dest_port_redirected;
 	u16	cid;
 	u32	estimated_throughput;
-	struct	ip_address_format	src_ipaddr;
-	struct	ip_address_format	dest_ipaddr;
-	struct	ip_address_format	dest_ipaddr_redirected;
+	struct	ip_addr_format	src_ipaddr;
+	struct	ip_addr_format	dest_ipaddr;
+	struct	ip_addr_format	dest_ipaddr_redirected;
 	struct	mgmt_conn_login_options	negotiated_login_options;
 } __packed;
 
@@ -322,43 +323,115 @@ struct mgmt_session_info {
 	struct	mgmt_conn_info	conn_list[1];
 } __packed;
 
-struct  be_cmd_req_get_session {
+struct be_cmd_get_session_req {
 	struct be_cmd_req_hdr hdr;
 	u32 session_handle;
 } __packed;
 
-struct  be_cmd_resp_get_session {
+struct be_cmd_get_session_resp {
 	struct be_cmd_resp_hdr hdr;
 	struct mgmt_session_info session_info;
 } __packed;
 
 struct mac_addr {
-	u16 size_of_struct;
+	u16 size_of_structure;
 	u8 addr[ETH_ALEN];
 } __packed;
 
-struct be_cmd_req_get_boot_target {
+struct be_cmd_get_boot_target_req {
 	struct be_cmd_req_hdr hdr;
 } __packed;
 
-struct be_cmd_resp_get_boot_target {
+struct be_cmd_get_boot_target_resp {
 	struct be_cmd_resp_hdr hdr;
 	u32  boot_session_count;
 	int  boot_session_handle;
 };
 
-struct be_cmd_req_mac_query {
+struct be_cmd_mac_query_req {
 	struct be_cmd_req_hdr hdr;
 	u8 type;
 	u8 permanent;
 	u16 if_id;
 } __packed;
 
-struct be_cmd_resp_mac_query {
+struct be_cmd_get_mac_resp {
 	struct be_cmd_resp_hdr hdr;
 	struct mac_addr mac;
 };
 
+struct be_ip_addr_subnet_format {
+	u16 size_of_structure;
+	u8 ip_type;
+	u8 ipv6_prefix_length;
+	u8 addr[16];
+	u8 subnet_mask[16];
+	u32 rsvd0;
+} __packed;
+
+struct be_cmd_get_if_info_req {
+	struct be_cmd_req_hdr hdr;
+	u32 interface_hndl;
+	u32 ip_type;
+} __packed;
+
+struct be_cmd_get_if_info_resp {
+	struct be_cmd_req_hdr hdr;
+	u32 interface_hndl;
+	u32 vlan_priority;
+	u32 ip_addr_count;
+	u32 dhcp_state;
+	struct be_ip_addr_subnet_format ip_addr;
+} __packed;
+
+struct be_ip_addr_record {
+	u32 action;
+	u32 interface_hndl;
+	struct be_ip_addr_subnet_format ip_addr;
+	u32 status;
+} __packed;
+
+struct be_ip_addr_record_params {
+	u32 record_entry_count;
+	struct be_ip_addr_record ip_record;
+} __packed;
+
+struct be_cmd_set_ip_addr_req {
+	struct be_cmd_req_hdr hdr;
+	struct be_ip_addr_record_params ip_params;
+} __packed;
+
+
+struct be_cmd_set_dhcp_req {
+	struct be_cmd_req_hdr hdr;
+	u32 interface_hndl;
+	u32 ip_type;
+	u32 flags;
+	u32 retry_count;
+} __packed;
+
+struct be_cmd_rel_dhcp_req {
+	struct be_cmd_req_hdr hdr;
+	u32 interface_hndl;
+	u32 ip_type;
+} __packed;
+
+struct be_cmd_set_def_gateway_req {
+	struct be_cmd_req_hdr hdr;
+	u32 action;
+	struct ip_addr_format ip_addr;
+} __packed;
+
+struct be_cmd_get_def_gateway_req {
+	struct be_cmd_req_hdr hdr;
+	u32 ip_type;
+} __packed;
+
+struct be_cmd_get_def_gateway_resp {
+	struct be_cmd_req_hdr hdr;
+	struct ip_addr_format ip_addr;
+} __packed;
+
 /******************** Create CQ ***************************/
 /**
  * Pseudo amap definition in which each bit of the actual structure is defined
@@ -489,7 +562,7 @@ struct be_cmd_req_modify_eq_delay {
 
 #define ETH_ALEN	6
 
-struct be_cmd_req_get_mac_addr {
+struct be_cmd_get_nic_conf_req {
 	struct be_cmd_req_hdr hdr;
 	u32 nic_port_count;
 	u32 speed;
@@ -501,7 +574,7 @@ struct be_cmd_req_get_mac_addr {
 	u32 rsvd[23];
 };
 
-struct be_cmd_resp_get_mac_addr {
+struct be_cmd_get_nic_conf_resp {
 	struct be_cmd_resp_hdr hdr;
 	u32 nic_port_count;
 	u32 speed;
@@ -541,12 +614,7 @@ int beiscsi_cmd_mccq_create(struct beiscsi_hba *phba,
 int be_poll_mcc(struct be_ctrl_info *ctrl);
 int mgmt_check_supported_fw(struct be_ctrl_info *ctrl,
 				      struct beiscsi_hba *phba);
-unsigned int be_cmd_get_mac_addr(struct beiscsi_hba *phba);
 unsigned int be_cmd_get_initname(struct beiscsi_hba *phba);
-unsigned int beiscsi_get_boot_target(struct beiscsi_hba *phba);
-unsigned int beiscsi_get_session_info(struct beiscsi_hba *phba,
-				  u32 boot_session_handle,
-				  struct be_dma_mem *nonemb_cmd);
 
 void free_mcc_tag(struct be_ctrl_info *ctrl, unsigned int tag);
 /*ISCSI Functuions */
@@ -727,7 +795,7 @@ struct be_eq_delay_params_in {
 
 struct tcp_connect_and_offload_in {
 	struct be_cmd_req_hdr hdr;
-	struct ip_address_format ip_address;
+	struct ip_addr_format ip_address;
 	u16 tcp_port;
 	u16 cid;
 	u16 cq_id;
@@ -804,7 +872,7 @@ struct be_fw_cfg {
 	u32 function_caps;
 } __packed;
 
-struct be_all_if_id {
+struct be_cmd_get_all_if_id_req {
 	struct be_cmd_req_hdr hdr;
 	u32 if_count;
 	u32 if_hndl_list[1];
diff --git a/drivers/scsi/be2iscsi/be_iscsi.c b/drivers/scsi/be2iscsi/be_iscsi.c
index 1af777474e42..46cc40e83b36 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.c
+++ b/drivers/scsi/be2iscsi/be_iscsi.c
@@ -23,6 +23,8 @@
 #include &lt;scsi/scsi_cmnd.h&gt;
 #include &lt;scsi/scsi_device.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
+#include &lt;scsi/scsi_netlink.h&gt;
+#include &lt;net/netlink.h&gt;
 #include &lt;scsi/scsi.h&gt;
 
 #include "be_iscsi.h"
@@ -207,6 +209,301 @@ int beiscsi_conn_bind(struct iscsi_cls_session *cls_session,
 	return beiscsi_bindconn_cid(phba, beiscsi_conn, beiscsi_ep-&gt;ep_cid);
 }
 
+static int beiscsi_create_ipv4_iface(struct beiscsi_hba *phba)
+{
+	if (phba-&gt;ipv4_iface)
+		return 0;
+
+	phba-&gt;ipv4_iface = iscsi_create_iface(phba-&gt;shost,
+					      &amp;beiscsi_iscsi_transport,
+					      ISCSI_IFACE_TYPE_IPV4,
+					      0, 0);
+	if (!phba-&gt;ipv4_iface) {
+		shost_printk(KERN_ERR, phba-&gt;shost, "Could not "
+			     "create default IPv4 address.\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int beiscsi_create_ipv6_iface(struct beiscsi_hba *phba)
+{
+	if (phba-&gt;ipv6_iface)
+		return 0;
+
+	phba-&gt;ipv6_iface = iscsi_create_iface(phba-&gt;shost,
+					      &amp;beiscsi_iscsi_transport,
+					      ISCSI_IFACE_TYPE_IPV6,
+					      0, 0);
+	if (!phba-&gt;ipv6_iface) {
+		shost_printk(KERN_ERR, phba-&gt;shost, "Could not "
+			     "create default IPv6 address.\n");
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+void beiscsi_create_def_ifaces(struct beiscsi_hba *phba)
+{
+	struct be_cmd_get_if_info_resp if_info;
+
+	if (!mgmt_get_if_info(phba, BE2_IPV4, &amp;if_info))
+		beiscsi_create_ipv4_iface(phba);
+
+	if (!mgmt_get_if_info(phba, BE2_IPV6, &amp;if_info))
+		beiscsi_create_ipv6_iface(phba);
+}
+
+void beiscsi_destroy_def_ifaces(struct beiscsi_hba *phba)
+{
+	if (phba-&gt;ipv6_iface)
+		iscsi_destroy_iface(phba-&gt;ipv6_iface);
+	if (phba-&gt;ipv4_iface)
+		iscsi_destroy_iface(phba-&gt;ipv4_iface);
+}
+
+static int
+beiscsi_set_static_ip(struct Scsi_Host *shost,
+		struct iscsi_iface_param_info *iface_param,
+		void *data, uint32_t dt_len)
+{
+	struct beiscsi_hba *phba = iscsi_host_priv(shost);
+	struct iscsi_iface_param_info *iface_ip = NULL;
+	struct iscsi_iface_param_info *iface_subnet = NULL;
+	struct nlattr *nla;
+	int ret;
+
+
+	switch (iface_param-&gt;param) {
+	case ISCSI_NET_PARAM_IPV4_BOOTPROTO:
+		nla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_ADDR);
+		if (nla)
+			iface_ip = nla_data(nla);
+
+		nla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_SUBNET);
+		if (nla)
+			iface_subnet = nla_data(nla);
+		break;
+	case ISCSI_NET_PARAM_IPV4_ADDR:
+		iface_ip = iface_param;
+		nla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_SUBNET);
+		if (nla)
+			iface_subnet = nla_data(nla);
+		break;
+	case ISCSI_NET_PARAM_IPV4_SUBNET:
+		iface_subnet = iface_param;
+		nla = nla_find(data, dt_len, ISCSI_NET_PARAM_IPV4_ADDR);
+		if (nla)
+			iface_ip = nla_data(nla);
+		break;
+	default:
+		shost_printk(KERN_ERR, shost, "Unsupported param %d\n",
+			     iface_param-&gt;param);
+	}
+
+	if (!iface_ip || !iface_subnet) {
+		shost_printk(KERN_ERR, shost, "IP and Subnet Mask required\n");
+		return -EINVAL;
+	}
+
+	ret = mgmt_set_ip(phba, iface_ip, iface_subnet,
+			ISCSI_BOOTPROTO_STATIC);
+
+	return ret;
+}
+
+static int
+beiscsi_set_ipv4(struct Scsi_Host *shost,
+		struct iscsi_iface_param_info *iface_param,
+		void *data, uint32_t dt_len)
+{
+	struct beiscsi_hba *phba = iscsi_host_priv(shost);
+	int ret = 0;
+
+	/* Check the param */
+	switch (iface_param-&gt;param) {
+	case ISCSI_NET_PARAM_IPV4_GW:
+		ret = mgmt_set_gateway(phba, iface_param);
+		break;
+	case ISCSI_NET_PARAM_IPV4_BOOTPROTO:
+		if (iface_param-&gt;value[0] == ISCSI_BOOTPROTO_DHCP)
+			ret = mgmt_set_ip(phba, iface_param,
+					NULL, ISCSI_BOOTPROTO_DHCP);
+		else if (iface_param-&gt;value[0] == ISCSI_BOOTPROTO_STATIC)
+			ret = beiscsi_set_static_ip(shost, iface_param,
+						    data, dt_len);
+		else
+			shost_printk(KERN_ERR, shost, "Invalid BOOTPROTO: %d\n",
+					iface_param-&gt;value[0]);
+		break;
+	case ISCSI_NET_PARAM_IFACE_ENABLE:
+		if (iface_param-&gt;value[0] == ISCSI_IFACE_ENABLE)
+			ret = beiscsi_create_ipv4_iface(phba);
+		else
+			iscsi_destroy_iface(phba-&gt;ipv4_iface);
+		break;
+	case ISCSI_NET_PARAM_IPV4_SUBNET:
+	case ISCSI_NET_PARAM_IPV4_ADDR:
+		ret = beiscsi_set_static_ip(shost, iface_param,
+					    data, dt_len);
+		break;
+	default:
+		shost_printk(KERN_ERR, shost, "Param %d not supported\n",
+			     iface_param-&gt;param);
+	}
+
+	return ret;
+}
+
+static int
+beiscsi_set_ipv6(struct Scsi_Host *shost,
+		struct iscsi_iface_param_info *iface_param,
+		void *data, uint32_t dt_len)
+{
+	struct beiscsi_hba *phba = iscsi_host_priv(shost);
+	int ret = 0;
+
+	switch (iface_param-&gt;param) {
+	case ISCSI_NET_PARAM_IFACE_ENABLE:
+		if (iface_param-&gt;value[0] == ISCSI_IFACE_ENABLE)
+			ret = beiscsi_create_ipv6_iface(phba);
+		else {
+			iscsi_destroy_iface(phba-&gt;ipv6_iface);
+			ret = 0;
+		}
+		break;
+	case ISCSI_NET_PARAM_IPV6_ADDR:
+		ret = mgmt_set_ip(phba, iface_param, NULL,
+				  ISCSI_BOOTPROTO_STATIC);
+		break;
+	default:
+		shost_printk(KERN_ERR, shost, "Param %d not supported\n",
+			     iface_param-&gt;param);
+	}
+
+	return ret;
+}
+
+int be2iscsi_iface_set_param(struct Scsi_Host *shost,
+		void *data, uint32_t dt_len)
+{
+	struct iscsi_iface_param_info *iface_param = NULL;
+	struct nlattr *attrib;
+	uint32_t rm_len = dt_len;
+	int ret = 0 ;
+
+	nla_for_each_attr(attrib, data, dt_len, rm_len) {
+		iface_param = nla_data(attrib);
+
+		if (iface_param-&gt;param_type != ISCSI_NET_PARAM)
+			continue;
+
+		/*
+		 * BE2ISCSI only supports 1 interface
+		 */
+		if (iface_param-&gt;iface_num) {
+			shost_printk(KERN_ERR, shost, "Invalid iface_num %d."
+				     "Only iface_num 0 is supported.\n",
+				     iface_param-&gt;iface_num);
+			return -EINVAL;
+		}
+
+		switch (iface_param-&gt;iface_type) {
+		case ISCSI_IFACE_TYPE_IPV4:
+			ret = beiscsi_set_ipv4(shost, iface_param,
+					       data, dt_len);
+			break;
+		case ISCSI_IFACE_TYPE_IPV6:
+			ret = beiscsi_set_ipv6(shost, iface_param,
+					       data, dt_len);
+			break;
+		default:
+			shost_printk(KERN_ERR, shost,
+				     "Invalid iface type :%d passed\n",
+				     iface_param-&gt;iface_type);
+			break;
+		}
+
+		if (ret)
+			return ret;
+	}
+
+	return ret;
+}
+
+static int be2iscsi_get_if_param(struct beiscsi_hba *phba,
+		struct iscsi_iface *iface, int param,
+		char *buf)
+{
+	struct be_cmd_get_if_info_resp if_info;
+	int len, ip_type = BE2_IPV4;
+
+	memset(&amp;if_info, 0, sizeof(if_info));
+
+	if (iface-&gt;iface_type == ISCSI_IFACE_TYPE_IPV6)
+		ip_type = BE2_IPV6;
+
+	len = mgmt_get_if_info(phba, ip_type, &amp;if_info);
+	if (len)
+		return len;
+
+	switch (param) {
+	case ISCSI_NET_PARAM_IPV4_ADDR:
+		len = sprintf(buf, "%pI4\n", &amp;if_info.ip_addr.addr);
+		break;
+	case ISCSI_NET_PARAM_IPV6_ADDR:
+		len = sprintf(buf, "%pI6\n", &amp;if_info.ip_addr.addr);
+		break;
+	case ISCSI_NET_PARAM_IPV4_BOOTPROTO:
+		if (!if_info.dhcp_state)
+			len = sprintf(buf, "static");
+		else
+			len = sprintf(buf, "dhcp");
+		break;
+	case ISCSI_NET_PARAM_IPV4_SUBNET:
+		len = sprintf(buf, "%pI4\n", &amp;if_info.ip_addr.subnet_mask);
+		break;
+	default:
+		WARN_ON(1);
+	}
+
+	return len;
+}
+
+int be2iscsi_iface_get_param(struct iscsi_iface *iface,
+		enum iscsi_param_type param_type,
+		int param, char *buf)
+{
+	struct Scsi_Host *shost = iscsi_iface_to_shost(iface);
+	struct beiscsi_hba *phba = iscsi_host_priv(shost);
+	struct be_cmd_get_def_gateway_resp gateway;
+	int len = -ENOSYS;
+
+	switch (param) {
+	case ISCSI_NET_PARAM_IPV4_ADDR:
+	case ISCSI_NET_PARAM_IPV4_SUBNET:
+	case ISCSI_NET_PARAM_IPV4_BOOTPROTO:
+	case ISCSI_NET_PARAM_IPV6_ADDR:
+		len = be2iscsi_get_if_param(phba, iface, param, buf);
+		break;
+	case ISCSI_NET_PARAM_IFACE_ENABLE:
+		len = sprintf(buf, "enabled");
+		break;
+	case ISCSI_NET_PARAM_IPV4_GW:
+		memset(&amp;gateway, 0, sizeof(gateway));
+		len = mgmt_get_gateway(phba, BE2_IPV4, &amp;gateway);
+		if (!len)
+			len = sprintf(buf, "%pI4\n", &amp;gateway.ip_addr.addr);
+		break;
+	default:
+		len = -ENOSYS;
+	}
+
+	return len;
+}
+
 /**
  * beiscsi_ep_get_param - get the iscsi parameter
  * @ep: pointer to iscsi ep
@@ -359,46 +656,21 @@ int beiscsi_get_host_param(struct Scsi_Host *shost,
 
 int beiscsi_get_macaddr(char *buf, struct beiscsi_hba *phba)
 {
-	struct be_cmd_resp_get_mac_addr *resp;
-	struct be_mcc_wrb *wrb;
-	unsigned int tag, wrb_num;
-	unsigned short status, extd_status;
-	struct be_queue_info *mccq = &amp;phba-&gt;ctrl.mcc_obj.q;
+	struct be_cmd_get_nic_conf_resp resp;
 	int rc;
 
-	if (phba-&gt;read_mac_address)
-		return sysfs_format_mac(buf, phba-&gt;mac_address,
-					ETH_ALEN);
+	if (strlen(phba-&gt;mac_address))
+		return strlcpy(buf, phba-&gt;mac_address, PAGE_SIZE);
 
-	tag = be_cmd_get_mac_addr(phba);
-	if (!tag) {
-		SE_DEBUG(DBG_LVL_1, "be_cmd_get_mac_addr Failed\n");
-		return -EBUSY;
-	} else
-		wait_event_interruptible(phba-&gt;ctrl.mcc_wait[tag],
-					 phba-&gt;ctrl.mcc_numtag[tag]);
+	memset(&amp;resp, 0, sizeof(resp));
+	rc = mgmt_get_nic_conf(phba, &amp;resp);
+	if (rc)
+		return rc;
 
-	wrb_num = (phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x00FF0000) &gt;&gt; 16;
-	extd_status = (phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x0000FF00) &gt;&gt; 8;
-	status = phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x000000FF;
-	if (status || extd_status) {
-		SE_DEBUG(DBG_LVL_1, "Failed to get be_cmd_get_mac_addr"
-				    " status = %d extd_status = %d\n",
-				    status, extd_status);
-		free_mcc_tag(&amp;phba-&gt;ctrl, tag);
-		return -EAGAIN;
-	}
-	wrb = queue_get_wrb(mccq, wrb_num);
-	free_mcc_tag(&amp;phba-&gt;ctrl, tag);
-	resp = embedded_payload(wrb);
-	memcpy(phba-&gt;mac_address, resp-&gt;mac_address, ETH_ALEN);
-	rc = sysfs_format_mac(buf, phba-&gt;mac_address,
-			       ETH_ALEN);
-	phba-&gt;read_mac_address = 1;
-	return rc;
+	memcpy(phba-&gt;mac_address, resp.mac_address, ETH_ALEN);
+	return sysfs_format_mac(buf, phba-&gt;mac_address, ETH_ALEN);
 }
 
-
 /**
  * beiscsi_conn_get_stats - get the iscsi stats
  * @cls_conn: pointer to iscsi cls conn
@@ -786,11 +1058,21 @@ void beiscsi_ep_disconnect(struct iscsi_endpoint *ep)
 umode_t be2iscsi_attr_is_visible(int param_type, int param)
 {
 	switch (param_type) {
+	case ISCSI_NET_PARAM:
+		switch (param) {
+		case ISCSI_NET_PARAM_IFACE_ENABLE:
+		case ISCSI_NET_PARAM_IPV4_ADDR:
+		case ISCSI_NET_PARAM_IPV4_SUBNET:
+		case ISCSI_NET_PARAM_IPV4_BOOTPROTO:
+		case ISCSI_NET_PARAM_IPV4_GW:
+		case ISCSI_NET_PARAM_IPV6_ADDR:
+			return S_IRUGO;
+		default:
+			return 0;
+		}
 	case ISCSI_HOST_PARAM:
 		switch (param) {
 		case ISCSI_HOST_PARAM_HWADDRESS:
-		case ISCSI_HOST_PARAM_IPADDRESS:
-		case ISCSI_HOST_PARAM_INITIATOR_NAME:
 			return S_IRUGO;
 		default:
 			return 0;
diff --git a/drivers/scsi/be2iscsi/be_iscsi.h b/drivers/scsi/be2iscsi/be_iscsi.h
index 5c45be134501..8b826fc06bcc 100644
--- a/drivers/scsi/be2iscsi/be_iscsi.h
+++ b/drivers/scsi/be2iscsi/be_iscsi.h
@@ -25,6 +25,21 @@
 
 #define BE2_IPV4  0x1
 #define BE2_IPV6  0x10
+#define BE2_DHCP_V4 0x05
+
+#define NON_BLOCKING 0x0
+#define BLOCKING 0x1
+
+void beiscsi_create_def_ifaces(struct beiscsi_hba *phba);
+
+void beiscsi_destroy_def_ifaces(struct beiscsi_hba *phba);
+
+int be2iscsi_iface_get_param(struct iscsi_iface *iface,
+			     enum iscsi_param_type param_type,
+			     int param, char *buf);
+
+int be2iscsi_iface_set_param(struct Scsi_Host *shost,
+			     void *data, uint32_t count);
 
 umode_t be2iscsi_attr_is_visible(int param_type, int param);
 
diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index ff6f851d6fb8..0b1d99c99fd2 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -231,10 +231,10 @@ static ssize_t beiscsi_show_boot_tgt_info(void *data, int type, char *buf)
 	case ISCSI_BOOT_TGT_IP_ADDR:
 		if (boot_conn-&gt;dest_ipaddr.ip_type == 0x1)
 			rc = sprintf(buf, "%pI4\n",
-				(char *)&amp;boot_conn-&gt;dest_ipaddr.ip_address);
+				(char *)&amp;boot_conn-&gt;dest_ipaddr.addr);
 		else
 			rc = sprintf(str, "%pI6\n",
-				(char *)&amp;boot_conn-&gt;dest_ipaddr.ip_address);
+				(char *)&amp;boot_conn-&gt;dest_ipaddr.addr);
 		break;
 	case ISCSI_BOOT_TGT_PORT:
 		rc = sprintf(str, "%d\n", boot_conn-&gt;dest_port);
@@ -312,12 +312,8 @@ static ssize_t beiscsi_show_boot_eth_info(void *data, int type, char *buf)
 		rc = sprintf(str, "0\n");
 		break;
 	case ISCSI_BOOT_ETH_MAC:
-		rc  = beiscsi_get_macaddr(buf, phba);
-		if (rc &lt; 0) {
-			SE_DEBUG(DBG_LVL_1, "beiscsi_get_macaddr Failed\n");
-			return rc;
-		}
-	break;
+		rc  = beiscsi_get_macaddr(str, phba);
+		break;
 	default:
 		rc = -ENOSYS;
 		break;
@@ -438,6 +434,7 @@ static struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev)
 	phba-&gt;shost = shost;
 	phba-&gt;pcidev = pci_dev_get(pcidev);
 	pci_set_drvdata(pcidev, phba);
+	phba-&gt;interface_handle = 0xFFFFFFFF;
 
 	if (iscsi_host_add(shost, &amp;phba-&gt;pcidev-&gt;dev))
 		goto free_devices;
@@ -3471,8 +3468,8 @@ static void hwi_disable_intr(struct beiscsi_hba *phba)
 
 static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 {
-	struct be_cmd_resp_get_boot_target *boot_resp;
-	struct be_cmd_resp_get_session *session_resp;
+	struct be_cmd_get_boot_target_resp *boot_resp;
+	struct be_cmd_get_session_resp *session_resp;
 	struct be_mcc_wrb *wrb;
 	struct be_dma_mem nonemb_cmd;
 	unsigned int tag, wrb_num;
@@ -3480,9 +3477,9 @@ static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 	struct be_queue_info *mccq = &amp;phba-&gt;ctrl.mcc_obj.q;
 	int ret = -ENOMEM;
 
-	tag = beiscsi_get_boot_target(phba);
+	tag = mgmt_get_boot_target(phba);
 	if (!tag) {
-		SE_DEBUG(DBG_LVL_1, "be_cmd_get_mac_addr Failed\n");
+		SE_DEBUG(DBG_LVL_1, "beiscsi_get_boot_info Failed\n");
 		return -EAGAIN;
 	} else
 		wait_event_interruptible(phba-&gt;ctrl.mcc_wait[tag],
@@ -3492,7 +3489,7 @@ static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 	extd_status = (phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x0000FF00) &gt;&gt; 8;
 	status = phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x000000FF;
 	if (status || extd_status) {
-		SE_DEBUG(DBG_LVL_1, "be_cmd_get_mac_addr Failed"
+		SE_DEBUG(DBG_LVL_1, "beiscsi_get_boot_info Failed"
 				    " status = %d extd_status = %d\n",
 				    status, extd_status);
 		free_mcc_tag(&amp;phba-&gt;ctrl, tag);
@@ -3518,8 +3515,8 @@ static int beiscsi_get_boot_info(struct beiscsi_hba *phba)
 	}
 
 	memset(nonemb_cmd.va, 0, sizeof(*session_resp));
-	tag = beiscsi_get_session_info(phba,
-		boot_resp-&gt;boot_session_handle, &amp;nonemb_cmd);
+	tag = mgmt_get_session_info(phba, boot_resp-&gt;boot_session_handle,
+				    &amp;nonemb_cmd);
 	if (!tag) {
 		SE_DEBUG(DBG_LVL_1, "beiscsi_get_session_info"
 			" Failed\n");
@@ -4267,6 +4264,7 @@ static void beiscsi_remove(struct pci_dev *pcidev)
 		return;
 	}
 
+	beiscsi_destroy_def_ifaces(phba);
 	beiscsi_quiesce(phba);
 	iscsi_boot_destroy_kset(phba-&gt;boot_kset);
 	iscsi_host_remove(phba-&gt;shost);
@@ -4453,8 +4451,9 @@ static int __devinit beiscsi_dev_probe(struct pci_dev *pcidev,
 		 * iscsi boot.
 		 */
 		shost_printk(KERN_ERR, phba-&gt;shost, "Could not set up "
-			     "iSCSI boot info.");
+			     "iSCSI boot info.\n");
 
+	beiscsi_create_def_ifaces(phba);
 	SE_DEBUG(DBG_LVL_8, "\n\n\n SUCCESS - DRIVER LOADED\n\n\n");
 	return 0;
 
@@ -4505,6 +4504,8 @@ struct iscsi_transport beiscsi_iscsi_transport = {
 	.bind_conn = beiscsi_conn_bind,
 	.destroy_conn = iscsi_conn_teardown,
 	.attr_is_visible = be2iscsi_attr_is_visible,
+	.set_iface_param = be2iscsi_iface_set_param,
+	.get_iface_param = be2iscsi_iface_get_param,
 	.set_param = beiscsi_set_param,
 	.get_conn_param = iscsi_conn_get_param,
 	.get_session_param = iscsi_session_get_param,
diff --git a/drivers/scsi/be2iscsi/be_main.h b/drivers/scsi/be2iscsi/be_main.h
index 13e3bef1d324..40fea6ec879c 100644
--- a/drivers/scsi/be2iscsi/be_main.h
+++ b/drivers/scsi/be2iscsi/be_main.h
@@ -316,6 +316,8 @@ struct beiscsi_hba {
 	struct iscsi_endpoint **ep_array;
 	struct iscsi_boot_kset *boot_kset;
 	struct Scsi_Host *shost;
+	struct iscsi_iface *ipv4_iface;
+	struct iscsi_iface *ipv6_iface;
 	struct {
 		/**
 		 * group together since they are used most frequently
@@ -345,7 +347,7 @@ struct beiscsi_hba {
 	struct work_struct work_cqs;	/* The work being queued */
 	struct be_ctrl_info ctrl;
 	unsigned int generation;
-	unsigned int read_mac_address;
+	unsigned int interface_handle;
 	struct mgmt_session_info boot_sess;
 	struct invalidate_command_table inv_tbl[128];
 
diff --git a/drivers/scsi/be2iscsi/be_mgmt.c b/drivers/scsi/be2iscsi/be_mgmt.c
index ccc3852a7f30..e6cb10d2e74e 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.c
+++ b/drivers/scsi/be2iscsi/be_mgmt.c
@@ -23,11 +23,11 @@
 #include "be_mgmt.h"
 #include "be_iscsi.h"
 
-unsigned int beiscsi_get_boot_target(struct beiscsi_hba *phba)
+unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba)
 {
 	struct be_ctrl_info *ctrl = &amp;phba-&gt;ctrl;
 	struct be_mcc_wrb *wrb;
-	struct be_cmd_req_get_mac_addr *req;
+	struct be_cmd_get_boot_target_req *req;
 	unsigned int tag = 0;
 
 	SE_DEBUG(DBG_LVL_8, "In bescsi_get_boot_target\n");
@@ -44,22 +44,22 @@ unsigned int beiscsi_get_boot_target(struct beiscsi_hba *phba)
 	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
 	be_cmd_hdr_prepare(&amp;req-&gt;hdr, CMD_SUBSYSTEM_ISCSI_INI,
 			   OPCODE_ISCSI_INI_BOOT_GET_BOOT_TARGET,
-			   sizeof(*req));
+			   sizeof(struct be_cmd_get_boot_target_resp));
 
 	be_mcc_notify(phba);
 	spin_unlock(&amp;ctrl-&gt;mbox_lock);
 	return tag;
 }
 
-unsigned int beiscsi_get_session_info(struct beiscsi_hba *phba,
-				  u32 boot_session_handle,
-				  struct be_dma_mem *nonemb_cmd)
+unsigned int mgmt_get_session_info(struct beiscsi_hba *phba,
+				   u32 boot_session_handle,
+				   struct be_dma_mem *nonemb_cmd)
 {
 	struct be_ctrl_info *ctrl = &amp;phba-&gt;ctrl;
 	struct be_mcc_wrb *wrb;
 	unsigned int tag = 0;
-	struct  be_cmd_req_get_session *req;
-	struct be_cmd_resp_get_session *resp;
+	struct  be_cmd_get_session_req *req;
+	struct be_cmd_get_session_resp *resp;
 	struct be_sge *sge;
 
 	SE_DEBUG(DBG_LVL_8, "In beiscsi_get_session_info\n");
@@ -396,7 +396,6 @@ int mgmt_open_connection(struct beiscsi_hba *phba,
 			 struct sockaddr *dst_addr,
 			 struct beiscsi_endpoint *beiscsi_ep,
 			 struct be_dma_mem *nonemb_cmd)
-
 {
 	struct hwi_controller *phwi_ctrlr;
 	struct hwi_context_memory *phwi_context;
@@ -442,17 +441,17 @@ int mgmt_open_connection(struct beiscsi_hba *phba,
 	if (dst_addr-&gt;sa_family == PF_INET) {
 		__be32 s_addr = daddr_in-&gt;sin_addr.s_addr;
 		req-&gt;ip_address.ip_type = BE2_IPV4;
-		req-&gt;ip_address.ip_address[0] = s_addr &amp; 0x000000ff;
-		req-&gt;ip_address.ip_address[1] = (s_addr &amp; 0x0000ff00) &gt;&gt; 8;
-		req-&gt;ip_address.ip_address[2] = (s_addr &amp; 0x00ff0000) &gt;&gt; 16;
-		req-&gt;ip_address.ip_address[3] = (s_addr &amp; 0xff000000) &gt;&gt; 24;
+		req-&gt;ip_address.addr[0] = s_addr &amp; 0x000000ff;
+		req-&gt;ip_address.addr[1] = (s_addr &amp; 0x0000ff00) &gt;&gt; 8;
+		req-&gt;ip_address.addr[2] = (s_addr &amp; 0x00ff0000) &gt;&gt; 16;
+		req-&gt;ip_address.addr[3] = (s_addr &amp; 0xff000000) &gt;&gt; 24;
 		req-&gt;tcp_port = ntohs(daddr_in-&gt;sin_port);
 		beiscsi_ep-&gt;dst_addr = daddr_in-&gt;sin_addr.s_addr;
 		beiscsi_ep-&gt;dst_tcpport = ntohs(daddr_in-&gt;sin_port);
 		beiscsi_ep-&gt;ip_type = BE2_IPV4;
 	} else if (dst_addr-&gt;sa_family == PF_INET6) {
 		req-&gt;ip_address.ip_type = BE2_IPV6;
-		memcpy(&amp;req-&gt;ip_address.ip_address,
+		memcpy(&amp;req-&gt;ip_address.addr,
 		       &amp;daddr_in6-&gt;sin6_addr.in6_u.u6_addr8, 16);
 		req-&gt;tcp_port = ntohs(daddr_in6-&gt;sin6_port);
 		beiscsi_ep-&gt;dst_tcpport = ntohs(daddr_in6-&gt;sin6_port);
@@ -487,34 +486,392 @@ int mgmt_open_connection(struct beiscsi_hba *phba,
 	return tag;
 }
 
-unsigned int be_cmd_get_mac_addr(struct beiscsi_hba *phba)
+unsigned int mgmt_get_all_if_id(struct beiscsi_hba *phba)
 {
 	struct be_ctrl_info *ctrl = &amp;phba-&gt;ctrl;
-	struct be_mcc_wrb *wrb;
-	struct be_cmd_req_get_mac_addr *req;
-	unsigned int tag = 0;
+	struct be_mcc_wrb *wrb = wrb_from_mbox(&amp;ctrl-&gt;mbox_mem);
+	struct be_cmd_get_all_if_id_req *req = embedded_payload(wrb);
+	struct be_cmd_get_all_if_id_req *pbe_allid = req;
+	int status = 0;
+
+	memset(wrb, 0, sizeof(*wrb));
+
+	spin_lock(&amp;ctrl-&gt;mbox_lock);
+
+	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
+	be_cmd_hdr_prepare(&amp;req-&gt;hdr, CMD_SUBSYSTEM_ISCSI,
+			   OPCODE_COMMON_ISCSI_NTWK_GET_ALL_IF_ID,
+			   sizeof(*req));
+	status = be_mbox_notify(ctrl);
+	if (!status)
+		phba-&gt;interface_handle = pbe_allid-&gt;if_hndl_list[0];
+	else {
+		shost_printk(KERN_WARNING, phba-&gt;shost,
+			     "Failed in mgmt_get_all_if_id\n");
+	}
+	spin_unlock(&amp;ctrl-&gt;mbox_lock);
+
+	return status;
+}
+
+static int mgmt_exec_nonemb_cmd(struct beiscsi_hba *phba,
+				struct be_dma_mem *nonemb_cmd, void *resp_buf,
+				int resp_buf_len)
+{
+	struct be_ctrl_info *ctrl = &amp;phba-&gt;ctrl;
+	struct be_mcc_wrb *wrb = wrb_from_mccq(phba);
+	unsigned short status, extd_status;
+	struct be_sge *sge;
+	unsigned int tag;
+	int rc = 0;
 
-	SE_DEBUG(DBG_LVL_8, "In be_cmd_get_mac_addr\n");
 	spin_lock(&amp;ctrl-&gt;mbox_lock);
 	tag = alloc_mcc_tag(phba);
 	if (!tag) {
 		spin_unlock(&amp;ctrl-&gt;mbox_lock);
-		return tag;
+		rc = -ENOMEM;
+		goto free_cmd;
 	}
-
-	wrb = wrb_from_mccq(phba);
-	req = embedded_payload(wrb);
+	memset(wrb, 0, sizeof(*wrb));
 	wrb-&gt;tag0 |= tag;
-	be_wrb_hdr_prepare(wrb, sizeof(*req), true, 0);
-	be_cmd_hdr_prepare(&amp;req-&gt;hdr, CMD_SUBSYSTEM_ISCSI,
-			   OPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG,
-			   sizeof(*req));
+	sge = nonembedded_sgl(wrb);
+
+	be_wrb_hdr_prepare(wrb, nonemb_cmd-&gt;size, false, 1);
+	sge-&gt;pa_hi = cpu_to_le32(upper_32_bits(nonemb_cmd-&gt;dma));
+	sge-&gt;pa_lo = cpu_to_le32(nonemb_cmd-&gt;dma &amp; 0xFFFFFFFF);
+	sge-&gt;len = cpu_to_le32(nonemb_cmd-&gt;size);
 
 	be_mcc_notify(phba);
 	spin_unlock(&amp;ctrl-&gt;mbox_lock);
-	return tag;
+
+	wait_event_interruptible(phba-&gt;ctrl.mcc_wait[tag],
+				 phba-&gt;ctrl.mcc_numtag[tag]);
+
+	extd_status = (phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x0000FF00) &gt;&gt; 8;
+	status = phba-&gt;ctrl.mcc_numtag[tag] &amp; 0x000000FF;
+	if (status || extd_status) {
+		SE_DEBUG(DBG_LVL_1,
+			 "mgmt_exec_nonemb_cmd Failed status = %d"
+			 "extd_status = %d\n", status, extd_status);
+		rc = -EIO;
+		goto free_tag;
+	}
+
+	if (resp_buf)
+		memcpy(resp_buf, nonemb_cmd-&gt;va, resp_buf_len);
+
+free_tag:
+	free_mcc_tag(&amp;phba-&gt;ctrl, tag);
+free_cmd:
+	pci_free_consistent(ctrl-&gt;pdev, nonemb_cmd-&gt;size,
+			    nonemb_cmd-&gt;va, nonemb_cmd-&gt;dma);
+	return rc;
+}
+
+static int mgmt_alloc_cmd_data(struct beiscsi_hba *phba, struct be_dma_mem *cmd,
+			       int iscsi_cmd, int size)
+{
+	cmd-&gt;va = pci_alloc_consistent(phba-&gt;ctrl.pdev, sizeof(size),
+				       &amp;cmd-&gt;dma);
+	if (!cmd-&gt;va) {
+		SE_DEBUG(DBG_LVL_1, "Failed to allocate memory for if info\n");
+		return -ENOMEM;
+	}
+	memset(cmd-&gt;va, 0, sizeof(size));
+	cmd-&gt;size = size;
+	be_cmd_hdr_prepare(cmd-&gt;va, CMD_SUBSYSTEM_ISCSI, iscsi_cmd, size);
+	return 0;
 }
 
+static int
+mgmt_static_ip_modify(struct beiscsi_hba *phba,
+		      struct be_cmd_get_if_info_resp *if_info,
+		      struct iscsi_iface_param_info *ip_param,
+		      struct iscsi_iface_param_info *subnet_param,
+		      uint32_t ip_action)
+{
+	struct be_cmd_set_ip_addr_req *req;
+	struct be_dma_mem nonemb_cmd;
+	uint32_t ip_type;
+	int rc;
+
+	rc = mgmt_alloc_cmd_data(phba, &amp;nonemb_cmd,
+				 OPCODE_COMMON_ISCSI_NTWK_MODIFY_IP_ADDR,
+				 sizeof(*req));
+	if (rc)
+		return rc;
+
+	ip_type = (ip_param-&gt;param == ISCSI_NET_PARAM_IPV6_ADDR) ?
+		BE2_IPV6 : BE2_IPV4 ;
+
+	req = nonemb_cmd.va;
+	req-&gt;ip_params.record_entry_count = 1;
+	req-&gt;ip_params.ip_record.action = ip_action;
+	req-&gt;ip_params.ip_record.interface_hndl =
+		phba-&gt;interface_handle;
+	req-&gt;ip_params.ip_record.ip_addr.size_of_structure =
+		sizeof(struct be_ip_addr_subnet_format);
+	req-&gt;ip_params.ip_record.ip_addr.ip_type = ip_type;
+
+	if (ip_action == IP_ACTION_ADD) {
+		memcpy(req-&gt;ip_params.ip_record.ip_addr.addr, ip_param-&gt;value,
+		       ip_param-&gt;len);
+
+		if (subnet_param)
+			memcpy(req-&gt;ip_params.ip_record.ip_addr.subnet_mask,
+			       subnet_param-&gt;value, subnet_param-&gt;len);
+	} else {
+		memcpy(req-&gt;ip_params.ip_record.ip_addr.addr,
+		       if_info-&gt;ip_addr.addr, ip_param-&gt;len);
+
+		memcpy(req-&gt;ip_params.ip_record.ip_addr.subnet_mask,
+		       if_info-&gt;ip_addr.subnet_mask, ip_param-&gt;len);
+	}
+
+	rc = mgmt_exec_nonemb_cmd(phba, &amp;nonemb_cmd, NULL, 0);
+	if (rc &lt; 0)
+		shost_printk(KERN_WARNING, phba-&gt;shost,
+			     "Failed to Modify existing IP Address\n");
+	return rc;
+}
+
+static int mgmt_modify_gateway(struct beiscsi_hba *phba, uint8_t *gt_addr,
+			       uint32_t gtway_action, uint32_t param_len)
+{
+	struct be_cmd_set_def_gateway_req *req;
+	struct be_dma_mem nonemb_cmd;
+	int rt_val;
+
+
+	rt_val = mgmt_alloc_cmd_data(phba, &amp;nonemb_cmd,
+				OPCODE_COMMON_ISCSI_NTWK_MODIFY_DEFAULT_GATEWAY,
+				sizeof(*req));
+	if (rt_val)
+		return rt_val;
+
+	req = nonemb_cmd.va;
+	req-&gt;action = gtway_action;
+	req-&gt;ip_addr.ip_type = BE2_IPV4;
+
+	memcpy(req-&gt;ip_addr.addr, gt_addr, param_len);
+
+	return mgmt_exec_nonemb_cmd(phba, &amp;nonemb_cmd, NULL, 0);
+}
+
+int mgmt_set_ip(struct beiscsi_hba *phba,
+		struct iscsi_iface_param_info *ip_param,
+		struct iscsi_iface_param_info *subnet_param,
+		uint32_t boot_proto)
+{
+	struct be_cmd_get_def_gateway_resp gtway_addr_set;
+	struct be_cmd_get_if_info_resp if_info;
+	struct be_cmd_set_dhcp_req *dhcpreq;
+	struct be_cmd_rel_dhcp_req *reldhcp;
+	struct be_dma_mem nonemb_cmd;
+	uint8_t *gtway_addr;
+	uint32_t ip_type;
+	int rc;
+
+	if (mgmt_get_all_if_id(phba))
+		return -EIO;
+
+	memset(&amp;if_info, 0, sizeof(if_info));
+	ip_type = (ip_param-&gt;param == ISCSI_NET_PARAM_IPV6_ADDR) ?
+		BE2_IPV6 : BE2_IPV4 ;
+
+	rc = mgmt_get_if_info(phba, ip_type, &amp;if_info);
+	if (rc)
+		return rc;
+
+	if (boot_proto == ISCSI_BOOTPROTO_DHCP) {
+		if (if_info.dhcp_state) {
+			shost_printk(KERN_WARNING, phba-&gt;shost,
+				     "DHCP Already Enabled\n");
+			return 0;
+		}
+		/* The ip_param-&gt;len is 1 in DHCP case. Setting
+		   proper IP len as this it is used while
+		   freeing the Static IP.
+		 */
+		ip_param-&gt;len = (ip_param-&gt;param == ISCSI_NET_PARAM_IPV6_ADDR) ?
+				IP_V6_LEN : IP_V4_LEN;
+
+	} else {
+		if (if_info.dhcp_state) {
+
+			memset(&amp;if_info, 0, sizeof(if_info));
+			rc = mgmt_alloc_cmd_data(phba, &amp;nonemb_cmd,
+				OPCODE_COMMON_ISCSI_NTWK_REL_STATELESS_IP_ADDR,
+				sizeof(*reldhcp));
+
+			if (rc)
+				return rc;
+
+			reldhcp = nonemb_cmd.va;
+			reldhcp-&gt;interface_hndl = phba-&gt;interface_handle;
+			reldhcp-&gt;ip_type = ip_type;
+
+			rc = mgmt_exec_nonemb_cmd(phba, &amp;nonemb_cmd, NULL, 0);
+			if (rc &lt; 0) {
+				shost_printk(KERN_WARNING, phba-&gt;shost,
+					     "Failed to Delete existing dhcp\n");
+				return rc;
+			}
+		}
+	}
+
+	/* Delete the Static IP Set */
+	if (if_info.ip_addr.addr[0]) {
+		rc = mgmt_static_ip_modify(phba, &amp;if_info, ip_param, NULL,
+					   IP_ACTION_DEL);
+		if (rc)
+			return rc;
+	}
+
+	/* Delete the Gateway settings if mode change is to DHCP */
+	if (boot_proto == ISCSI_BOOTPROTO_DHCP) {
+		memset(&amp;gtway_addr_set, 0, sizeof(gtway_addr_set));
+		rc = mgmt_get_gateway(phba, BE2_IPV4, &amp;gtway_addr_set);
+		if (rc) {
+			shost_printk(KERN_WARNING, phba-&gt;shost,
+				     "Failed to Get Gateway Addr\n");
+			return rc;
+		}
+
+		if (gtway_addr_set.ip_addr.addr[0]) {
+			gtway_addr = (uint8_t *)&amp;gtway_addr_set.ip_addr.addr;
+			rc = mgmt_modify_gateway(phba, gtway_addr,
+						 IP_ACTION_DEL, IP_V4_LEN);
+
+			if (rc) {
+				shost_printk(KERN_WARNING, phba-&gt;shost,
+					     "Failed to clear Gateway Addr Set\n");
+				return rc;
+			}
+		}
+	}
+
+	/* Set Adapter to DHCP/Static Mode */
+	if (boot_proto == ISCSI_BOOTPROTO_DHCP) {
+		rc = mgmt_alloc_cmd_data(phba, &amp;nonemb_cmd,
+			OPCODE_COMMON_ISCSI_NTWK_CONFIG_STATELESS_IP_ADDR,
+			sizeof(*dhcpreq));
+		if (rc)
+			return rc;
+
+		dhcpreq = nonemb_cmd.va;
+		dhcpreq-&gt;flags = BLOCKING;
+		dhcpreq-&gt;retry_count = 1;
+		dhcpreq-&gt;interface_hndl = phba-&gt;interface_handle;
+		dhcpreq-&gt;ip_type = BE2_DHCP_V4;
+
+		return mgmt_exec_nonemb_cmd(phba, &amp;nonemb_cmd, NULL, 0);
+	} else {
+		return mgmt_static_ip_modify(phba, &amp;if_info, ip_param,
+					     subnet_param, IP_ACTION_ADD);
+	}
+
+	return rc;
+}
+
+int mgmt_set_gateway(struct beiscsi_hba *phba,
+		     struct iscsi_iface_param_info *gateway_param)
+{
+	struct be_cmd_get_def_gateway_resp gtway_addr_set;
+	uint8_t *gtway_addr;
+	int rt_val;
+
+	memset(&amp;gtway_addr_set, 0, sizeof(gtway_addr_set));
+	rt_val = mgmt_get_gateway(phba, BE2_IPV4, &amp;gtway_addr_set);
+	if (rt_val) {
+		shost_printk(KERN_WARNING, phba-&gt;shost,
+			     "Failed to Get Gateway Addr\n");
+		return rt_val;
+	}
+
+	if (gtway_addr_set.ip_addr.addr[0]) {
+		gtway_addr = (uint8_t *)&amp;gtway_addr_set.ip_addr.addr;
+		rt_val = mgmt_modify_gateway(phba, gtway_addr, IP_ACTION_DEL,
+					     gateway_param-&gt;len);
+		if (rt_val) {
+			shost_printk(KERN_WARNING, phba-&gt;shost,
+				     "Failed to clear Gateway Addr Set\n");
+			return rt_val;
+		}
+	}
+
+	gtway_addr = (uint8_t *)&amp;gateway_param-&gt;value;
+	rt_val = mgmt_modify_gateway(phba, gtway_addr, IP_ACTION_ADD,
+				     gateway_param-&gt;len);
+
+	if (rt_val)
+		shost_printk(KERN_WARNING, phba-&gt;shost,
+			     "Failed to Set Gateway Addr\n");
+
+	return rt_val;
+}
+
+int mgmt_get_gateway(struct beiscsi_hba *phba, int ip_type,
+		     struct be_cmd_get_def_gateway_resp *gateway)
+{
+	struct be_cmd_get_def_gateway_req *req;
+	struct be_dma_mem nonemb_cmd;
+	int rc;
+
+	rc = mgmt_alloc_cmd_data(phba, &amp;nonemb_cmd,
+				 OPCODE_COMMON_ISCSI_NTWK_GET_DEFAULT_GATEWAY,
+				 sizeof(*gateway));
+	if (rc)
+		return rc;
+
+	req = nonemb_cmd.va;
+	req-&gt;ip_type = ip_type;
+
+	return mgmt_exec_nonemb_cmd(phba, &amp;nonemb_cmd, gateway,
+				    sizeof(*gateway));
+}
+
+int mgmt_get_if_info(struct beiscsi_hba *phba, int ip_type,
+		     struct be_cmd_get_if_info_resp *if_info)
+{
+	struct be_cmd_get_if_info_req *req;
+	struct be_dma_mem nonemb_cmd;
+	int rc;
+
+	if (mgmt_get_all_if_id(phba))
+		return -EIO;
+
+	rc = mgmt_alloc_cmd_data(phba, &amp;nonemb_cmd,
+				 OPCODE_COMMON_ISCSI_NTWK_GET_IF_INFO,
+				 sizeof(*if_info));
+	if (rc)
+		return rc;
+
+	req = nonemb_cmd.va;
+	req-&gt;interface_hndl = phba-&gt;interface_handle;
+	req-&gt;ip_type = ip_type;
+
+	return mgmt_exec_nonemb_cmd(phba, &amp;nonemb_cmd, if_info,
+				    sizeof(*if_info));
+}
+
+int mgmt_get_nic_conf(struct beiscsi_hba *phba,
+		      struct be_cmd_get_nic_conf_resp *nic)
+{
+	struct be_dma_mem nonemb_cmd;
+	int rc;
+
+	rc = mgmt_alloc_cmd_data(phba, &amp;nonemb_cmd,
+				 OPCODE_COMMON_ISCSI_NTWK_GET_NIC_CONFIG,
+				 sizeof(*nic));
+	if (rc)
+		return rc;
+
+	return mgmt_exec_nonemb_cmd(phba, &amp;nonemb_cmd, nic, sizeof(*nic));
+}
+
+
+
 unsigned int be_cmd_get_initname(struct beiscsi_hba *phba)
 {
 	unsigned int tag = 0;
diff --git a/drivers/scsi/be2iscsi/be_mgmt.h b/drivers/scsi/be2iscsi/be_mgmt.h
index 03400f3f666f..5c2e37693ca8 100644
--- a/drivers/scsi/be2iscsi/be_mgmt.h
+++ b/drivers/scsi/be2iscsi/be_mgmt.h
@@ -20,12 +20,16 @@
 #ifndef _BEISCSI_MGMT_
 #define _BEISCSI_MGMT_
 
-#include &lt;linux/types.h&gt;
-#include &lt;linux/list.h&gt;
 #include &lt;scsi/scsi_bsg_iscsi.h&gt;
 #include "be_iscsi.h"
 #include "be_main.h"
 
+#define IP_ACTION_ADD	0x01
+#define IP_ACTION_DEL	0x02
+
+#define IP_V6_LEN	16
+#define IP_V4_LEN	4
+
 /**
  * Pseudo amap definition in which each bit of the actual structure is defined
  * as a byte: used to calculate offset/shift/mask of each field
@@ -263,4 +267,27 @@ unsigned int mgmt_invalidate_connection(struct beiscsi_hba *phba,
 					 unsigned short issue_reset,
 					 unsigned short savecfg_flag);
 
+int mgmt_set_ip(struct beiscsi_hba *phba,
+		struct iscsi_iface_param_info *ip_param,
+		struct iscsi_iface_param_info *subnet_param,
+		uint32_t boot_proto);
+
+unsigned int mgmt_get_boot_target(struct beiscsi_hba *phba);
+
+unsigned int mgmt_get_session_info(struct beiscsi_hba *phba,
+				   u32 boot_session_handle,
+				   struct be_dma_mem *nonemb_cmd);
+
+int mgmt_get_nic_conf(struct beiscsi_hba *phba,
+		      struct be_cmd_get_nic_conf_resp *mac);
+
+int mgmt_get_if_info(struct beiscsi_hba *phba, int ip_type,
+		     struct be_cmd_get_if_info_resp *if_info);
+
+int mgmt_get_gateway(struct beiscsi_hba *phba, int ip_type,
+		     struct be_cmd_get_def_gateway_resp *gateway);
+
+int mgmt_set_gateway(struct beiscsi_hba *phba,
+		     struct iscsi_iface_param_info *gateway_param);
+
 #endif</pre><hr><pre>commit 1282ab76d983b2753b5cd4c9ae6b8019b0557b30
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Apr 18 03:06:00 2012 -0500

    [SCSI] be2iscsi: Freeing of WRB and SGL Handle in cleanup task
    
    The WRB and SGL Handle allocated for Login task were not freed
    back to the pool after the login process was done. This code
    releases the WRB and SGL Handle after the login process.
    
    v2:
    - Fix up locking so bh calls are not done when not needed.
    - Make beiscsi_cleanup_task static.
    
    Signed-off-by: Jayamohan Kallickal &lt;jayamohan.kallickal@emulex.com&gt;
    [various fixes]
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;JBottomley@Parallels.com&gt;

diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 23344c8c5b79..185cf394b9f0 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -1252,9 +1252,9 @@ hwi_complete_drvr_msgs(struct beiscsi_conn *beiscsi_conn,
 	task = pwrb_handle-&gt;pio_handle;
 
 	io_task = task-&gt;dd_data;
-	spin_lock(&amp;phba-&gt;mgmt_sgl_lock);
+	spin_lock_bh(&amp;phba-&gt;mgmt_sgl_lock);
 	free_mgmt_sgl_handle(phba, io_task-&gt;psgl_handle);
-	spin_unlock(&amp;phba-&gt;mgmt_sgl_lock);
+	spin_unlock_bh(&amp;phba-&gt;mgmt_sgl_lock);
 	spin_lock_bh(&amp;session-&gt;lock);
 	free_wrb_handle(phba, pwrb_context, pwrb_handle);
 	spin_unlock_bh(&amp;session-&gt;lock);
@@ -3693,6 +3693,57 @@ static void beiscsi_clean_port(struct beiscsi_hba *phba)
 	kfree(phba-&gt;ep_array);
 }
 
+static void beiscsi_cleanup_task(struct iscsi_task *task)
+{
+	struct beiscsi_io_task *io_task = task-&gt;dd_data;
+	struct iscsi_conn *conn = task-&gt;conn;
+	struct beiscsi_conn *beiscsi_conn = conn-&gt;dd_data;
+	struct beiscsi_hba *phba = beiscsi_conn-&gt;phba;
+	struct beiscsi_session *beiscsi_sess = beiscsi_conn-&gt;beiscsi_sess;
+	struct hwi_wrb_context *pwrb_context;
+	struct hwi_controller *phwi_ctrlr;
+
+	phwi_ctrlr = phba-&gt;phwi_ctrlr;
+	pwrb_context = &amp;phwi_ctrlr-&gt;wrb_context[beiscsi_conn-&gt;beiscsi_conn_cid
+			- phba-&gt;fw_config.iscsi_cid_start];
+
+	if (io_task-&gt;cmd_bhs) {
+		pci_pool_free(beiscsi_sess-&gt;bhs_pool, io_task-&gt;cmd_bhs,
+			      io_task-&gt;bhs_pa.u.a64.address);
+		io_task-&gt;cmd_bhs = NULL;
+	}
+
+	if (task-&gt;sc) {
+		if (io_task-&gt;pwrb_handle) {
+			free_wrb_handle(phba, pwrb_context,
+					io_task-&gt;pwrb_handle);
+			io_task-&gt;pwrb_handle = NULL;
+		}
+
+		if (io_task-&gt;psgl_handle) {
+			spin_lock(&amp;phba-&gt;io_sgl_lock);
+			free_io_sgl_handle(phba, io_task-&gt;psgl_handle);
+			spin_unlock(&amp;phba-&gt;io_sgl_lock);
+			io_task-&gt;psgl_handle = NULL;
+		}
+	} else {
+		if (!beiscsi_conn-&gt;login_in_progress) {
+			if (io_task-&gt;pwrb_handle) {
+				free_wrb_handle(phba, pwrb_context,
+						io_task-&gt;pwrb_handle);
+				io_task-&gt;pwrb_handle = NULL;
+			}
+			if (io_task-&gt;psgl_handle) {
+				spin_lock(&amp;phba-&gt;mgmt_sgl_lock);
+				free_mgmt_sgl_handle(phba,
+						     io_task-&gt;psgl_handle);
+				spin_unlock(&amp;phba-&gt;mgmt_sgl_lock);
+				io_task-&gt;psgl_handle = NULL;
+			}
+		}
+	}
+}
+
 void
 beiscsi_offload_connection(struct beiscsi_conn *beiscsi_conn,
 			   struct beiscsi_offload_params *params)
@@ -3701,12 +3752,19 @@ beiscsi_offload_connection(struct beiscsi_conn *beiscsi_conn,
 	struct iscsi_target_context_update_wrb *pwrb = NULL;
 	struct be_mem_descriptor *mem_descr;
 	struct beiscsi_hba *phba = beiscsi_conn-&gt;phba;
+	struct iscsi_task *task = beiscsi_conn-&gt;task;
+	struct iscsi_session *session = task-&gt;conn-&gt;session;
 	u32 doorbell = 0;
 
 	/*
 	 * We can always use 0 here because it is reserved by libiscsi for
 	 * login/startup related tasks.
 	 */
+	beiscsi_conn-&gt;login_in_progress = 0;
+	spin_lock_bh(&amp;session-&gt;lock);
+	beiscsi_cleanup_task(task);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
 	pwrb_handle = alloc_wrb_handle(phba, (beiscsi_conn-&gt;beiscsi_conn_cid -
 				       phba-&gt;fw_config.iscsi_cid_start));
 	pwrb = (struct iscsi_target_context_update_wrb *)pwrb_handle-&gt;pwrb;
@@ -3862,6 +3920,7 @@ static int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)
 				io_task-&gt;pwrb_handle =
 						beiscsi_conn-&gt;plogin_wrb_handle;
 			}
+			beiscsi_conn-&gt;task = task;
 		} else {
 			spin_lock(&amp;phba-&gt;mgmt_sgl_lock);
 			io_task-&gt;psgl_handle = alloc_mgmt_sgl_handle(phba);
@@ -3904,53 +3963,11 @@ static int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)
 	io_task-&gt;pwrb_handle = NULL;
 	pci_pool_free(beiscsi_sess-&gt;bhs_pool, io_task-&gt;cmd_bhs,
 		      io_task-&gt;bhs_pa.u.a64.address);
+	io_task-&gt;cmd_bhs = NULL;
 	SE_DEBUG(DBG_LVL_1, "Alloc of SGL_ICD Failed\n");
 	return -ENOMEM;
 }
 
-static void beiscsi_cleanup_task(struct iscsi_task *task)
-{
-	struct beiscsi_io_task *io_task = task-&gt;dd_data;
-	struct iscsi_conn *conn = task-&gt;conn;
-	struct beiscsi_conn *beiscsi_conn = conn-&gt;dd_data;
-	struct beiscsi_hba *phba = beiscsi_conn-&gt;phba;
-	struct beiscsi_session *beiscsi_sess = beiscsi_conn-&gt;beiscsi_sess;
-	struct hwi_wrb_context *pwrb_context;
-	struct hwi_controller *phwi_ctrlr;
-
-	phwi_ctrlr = phba-&gt;phwi_ctrlr;
-	pwrb_context = &amp;phwi_ctrlr-&gt;wrb_context[beiscsi_conn-&gt;beiscsi_conn_cid
-			- phba-&gt;fw_config.iscsi_cid_start];
-	if (io_task-&gt;pwrb_handle) {
-		free_wrb_handle(phba, pwrb_context, io_task-&gt;pwrb_handle);
-		io_task-&gt;pwrb_handle = NULL;
-	}
-
-	if (io_task-&gt;cmd_bhs) {
-		pci_pool_free(beiscsi_sess-&gt;bhs_pool, io_task-&gt;cmd_bhs,
-			      io_task-&gt;bhs_pa.u.a64.address);
-	}
-
-	if (task-&gt;sc) {
-		if (io_task-&gt;psgl_handle) {
-			spin_lock(&amp;phba-&gt;io_sgl_lock);
-			free_io_sgl_handle(phba, io_task-&gt;psgl_handle);
-			spin_unlock(&amp;phba-&gt;io_sgl_lock);
-			io_task-&gt;psgl_handle = NULL;
-		}
-	} else {
-		if (task-&gt;hdr &amp;&amp;
-		   ((task-&gt;hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) == ISCSI_OP_LOGIN))
-			return;
-		if (io_task-&gt;psgl_handle) {
-			spin_lock(&amp;phba-&gt;mgmt_sgl_lock);
-			free_mgmt_sgl_handle(phba, io_task-&gt;psgl_handle);
-			spin_unlock(&amp;phba-&gt;mgmt_sgl_lock);
-			io_task-&gt;psgl_handle = NULL;
-		}
-	}
-}
-
 static int beiscsi_iotask(struct iscsi_task *task, struct scatterlist *sg,
 			  unsigned int num_sg, unsigned int xferlen,
 			  unsigned int writedir)</pre><hr><pre>commit e8195b24feb208f6e944e7542779f4397776794d
Author: Matt Renzelmann &lt;mjr@cs.wisc.edu&gt;
Date:   Thu Apr 19 07:17:17 2012 +0000

    ks8851: Fix request_irq/free_irq mismatch
    
    The dev_id parameter passed to free_irq needs to match the one passed
    to the corresponding request_irq.
    
    Signed-off-by: Matt Renzelmann &lt;mjr@cs.wisc.edu&gt;
    Acked-by: Stephen Boyd &lt;sboyd@codeaurora.org&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/micrel/ks8851.c b/drivers/net/ethernet/micrel/ks8851.c
index ad10759e3459..f8dda009d3c0 100644
--- a/drivers/net/ethernet/micrel/ks8851.c
+++ b/drivers/net/ethernet/micrel/ks8851.c
@@ -1525,7 +1525,7 @@ static int __devinit ks8851_probe(struct spi_device *spi)
 
 
 err_netdev:
-	free_irq(ndev-&gt;irq, ndev);
+	free_irq(ndev-&gt;irq, ks);
 
 err_id:
 err_irq:</pre><hr><pre>commit 579b0637647de6e03e5707b32eb7c2ce56cc0f27
Author: Matt Renzelmann &lt;mjr@cs.wisc.edu&gt;
Date:   Thu Apr 12 17:42:43 2012 -0500

    hostap: GFP_ATOMIC/GFP_KERNEL cleanup
    
    The driver is allocating memory during initialization with GFP_ATOMIC
    even though GFP_KERNEL is sufficient.  This patch fixes it.
    
    Signed-off-by: Matt Renzelmann &lt;mjr@cs.wisc.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/hostap/hostap_main.c b/drivers/net/wireless/hostap/hostap_main.c
index bfa0d54221e8..627bc12074c7 100644
--- a/drivers/net/wireless/hostap/hostap_main.c
+++ b/drivers/net/wireless/hostap/hostap_main.c
@@ -244,8 +244,7 @@ u16 hostap_tx_callback_register(local_info_t *local,
 	unsigned long flags;
 	struct hostap_tx_callback_info *entry;
 
-	entry = kmalloc(sizeof(*entry),
-							   GFP_ATOMIC);
+	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
 	if (entry == NULL)
 		return 0;
 </pre><hr><pre>commit 51c61a2838c33dab7b6659b9a3e008bb1b40bc9b
Author: Matt Renzelmann &lt;mjr@cs.wisc.edu&gt;
Date:   Fri Apr 13 07:59:40 2012 +0000

    ks8851: Fix missing mutex_lock/unlock
    
    Move the ks8851_rdreg16 call above the call to request_irq and cache
    the result for subsequent repeated use.  A spurious interrupt may
    otherwise cause a crash.  Thanks to Stephen Boyd, Flavio Leitner, and
    Ben Hutchings for feedback.
    
    Signed-off-by: Matt Renzelmann &lt;mjr@cs.wisc.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/micrel/ks8851.c b/drivers/net/ethernet/micrel/ks8851.c
index c722aa607d07..e5dc0757f077 100644
--- a/drivers/net/ethernet/micrel/ks8851.c
+++ b/drivers/net/ethernet/micrel/ks8851.c
@@ -1418,6 +1418,7 @@ static int __devinit ks8851_probe(struct spi_device *spi)
 	struct net_device *ndev;
 	struct ks8851_net *ks;
 	int ret;
+	unsigned cider;
 
 	ndev = alloc_etherdev(sizeof(struct ks8851_net));
 	if (!ndev)
@@ -1484,8 +1485,8 @@ static int __devinit ks8851_probe(struct spi_device *spi)
 	ks8851_soft_reset(ks, GRR_GSR);
 
 	/* simple check for a valid chip being connected to the bus */
-
-	if ((ks8851_rdreg16(ks, KS_CIDER) &amp; ~CIDER_REV_MASK) != CIDER_ID) {
+	cider = ks8851_rdreg16(ks, KS_CIDER);
+	if ((cider &amp; ~CIDER_REV_MASK) != CIDER_ID) {
 		dev_err(&amp;spi-&gt;dev, "failed to read device ID\n");
 		ret = -ENODEV;
 		goto err_id;
@@ -1516,8 +1517,7 @@ static int __devinit ks8851_probe(struct spi_device *spi)
 	}
 
 	netdev_info(ndev, "revision %d, MAC %pM, IRQ %d, %s EEPROM\n",
-		    CIDER_REV_GET(ks8851_rdreg16(ks, KS_CIDER)),
-		    ndev-&gt;dev_addr, ndev-&gt;irq,
+		    CIDER_REV_GET(cider), ndev-&gt;dev_addr, ndev-&gt;irq,
 		    ks-&gt;rc_ccr &amp; CCR_EEPROM ? "has" : "no");
 
 	return 0;</pre>
    <div class="pagination">
        <a href='5_3.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><span>[4]</span><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_5.html'>Next&gt;&gt;</a>
    <div>
</body>
