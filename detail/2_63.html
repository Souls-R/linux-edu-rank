<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_62.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><span>[63]</span><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_64.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b409214c683ed06c26e2cdad0be546ad11463354
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 5 13:12:14 2010 -0400

    USB: remove fake "address-of" expressions
    
    Fake "address-of" expressions that evaluate to NULL generally confuse
    readers and can provoke compiler warnings.  This patch (as1412)
    removes three such fake expressions, using "#ifdef"s in their place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 880f65baf581..d7a4401ef019 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1791,15 +1791,13 @@ static const struct dev_pm_ops usb_bus_pm_ops = {
 	.runtime_idle =		usb_runtime_idle,
 };
 
-#else
-
-#define usb_bus_pm_ops	(*(const struct dev_pm_ops *) NULL)
-
 #endif /* CONFIG_USB_SUSPEND */
 
 struct bus_type usb_bus_type = {
 	.name =		"usb",
 	.match =	usb_device_match,
 	.uevent =	usb_uevent,
+#ifdef CONFIG_USB_SUSPEND
 	.pm =		&amp;usb_bus_pm_ops,
+#endif
 };
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 5ae14f6c1e7a..fdd4130fbb7d 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -317,10 +317,6 @@ static const struct dev_pm_ops usb_device_pm_ops = {
 	.restore =	usb_dev_restore,
 };
 
-#else
-
-#define usb_device_pm_ops	(*(struct dev_pm_ops *) NULL)
-
 #endif	/* CONFIG_PM */
 
 
@@ -338,7 +334,9 @@ struct device_type usb_device_type = {
 	.release =	usb_release_dev,
 	.uevent =	usb_dev_uevent,
 	.devnode = 	usb_devnode,
+#ifdef CONFIG_PM
 	.pm =		&amp;usb_device_pm_ops,
+#endif
 };
 
 
diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index c168999722d1..6e7fb5f38db6 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -17,7 +17,6 @@
 
 #include "uhci-hcd.h"
 
-#define uhci_debug_operations (* (const struct file_operations *) NULL)
 static struct dentry *uhci_debugfs_root;
 
 #ifdef DEBUG
@@ -558,7 +557,6 @@ static int uhci_debug_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-#undef uhci_debug_operations
 static const struct file_operations uhci_debug_operations = {
 	.owner =	THIS_MODULE,
 	.open =		uhci_debug_open,
@@ -566,6 +564,7 @@ static const struct file_operations uhci_debug_operations = {
 	.read =		uhci_debug_read,
 	.release =	uhci_debug_release,
 };
+#define UHCI_DEBUG_OPS
 
 #endif	/* CONFIG_DEBUG_FS */
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index b04506036b64..f52d04db28f4 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -597,7 +597,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int retval = -EBUSY;
 	int i;
-	struct dentry *dentry;
+	struct dentry __maybe_unused *dentry;
 
 	hcd-&gt;uses_new_polling = 1;
 
@@ -607,18 +607,16 @@ static int uhci_start(struct usb_hcd *hcd)
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
-	if (DEBUG_CONFIGURED) {
-		dentry = debugfs_create_file(hcd-&gt;self.bus_name,
-				S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root,
-				uhci, &amp;uhci_debug_operations);
-		if (!dentry) {
-			dev_err(uhci_dev(uhci), "couldn't create uhci "
-					"debugfs entry\n");
-			retval = -ENOMEM;
-			goto err_create_debug_entry;
-		}
-		uhci-&gt;dentry = dentry;
+#ifdef UHCI_DEBUG_OPS
+	dentry = debugfs_create_file(hcd-&gt;self.bus_name,
+			S_IFREG|S_IRUGO|S_IWUSR, uhci_debugfs_root,
+			uhci, &amp;uhci_debug_operations);
+	if (!dentry) {
+		dev_err(uhci_dev(uhci), "couldn't create uhci debugfs entry\n");
+		return -ENOMEM;
 	}
+	uhci-&gt;dentry = dentry;
+#endif
 
 	uhci-&gt;frame = dma_alloc_coherent(uhci_dev(uhci),
 			UHCI_NUMFRAMES * sizeof(*uhci-&gt;frame),
@@ -732,7 +730,6 @@ static int uhci_start(struct usb_hcd *hcd)
 err_alloc_frame:
 	debugfs_remove(uhci-&gt;dentry);
 
-err_create_debug_entry:
 	return retval;
 }
 </pre><hr><pre>commit f283925fe9ef4ee75dc43e4c2bfbbd6b8a70bd0a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 28 17:12:39 2010 -0400

    USB: usb-storage: implement autosuspend
    
    This patch (as1400) adds runtime-PM support to usb-storage.  It
    utilizes the SCSI layer's runtime-PM implementation, so its scope is
    limited.  Currently the only effect is that disk-like devices (such as
    card readers or flash drives) will be autosuspended if they aren't
    mounted and their device files aren't open.  This would apply, for
    example, to card readers that don't contain a memory card.
    
    Unfortunately this won't interact very well with the removable-media
    polling normally carried out by hal or DeviceKit.  Maybe those
    programs can be changed to use a longer polling interval, or maybe the
    default autosuspend time for usb-storage should be set to something
    below 1 second.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: James Bottomley &lt;James.Bottomley@suse.de&gt;
    Cc: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index a7d0bf9d92a7..90bb0175a152 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -336,6 +336,7 @@ static int usb_stor_control_thread(void * __us)
 		else {
 			US_DEBUG(usb_stor_show_command(us-&gt;srb));
 			us-&gt;proto_handler(us-&gt;srb, us);
+			usb_mark_last_busy(us-&gt;pusb_dev);
 		}
 
 		/* lock access to the state */
@@ -845,6 +846,7 @@ static int usb_stor_scan_thread(void * __us)
 		/* Should we unbind if no devices were detected? */
 	}
 
+	usb_autopm_put_interface(us-&gt;pusb_intf);
 	complete_and_exit(&amp;us-&gt;scanning_done, 0);
 }
 
@@ -968,6 +970,7 @@ int usb_stor_probe2(struct us_data *us)
 		goto BadDevice;
 	}
 
+	usb_autopm_get_interface_no_resume(us-&gt;pusb_intf);
 	wake_up_process(th);
 
 	return 0;
@@ -1040,6 +1043,7 @@ static struct usb_driver usb_storage_driver = {
 	.pre_reset =	usb_stor_pre_reset,
 	.post_reset =	usb_stor_post_reset,
 	.id_table =	usb_storage_usb_ids,
+	.supports_autosuspend = 1,
 	.soft_unbind =	1,
 };
 </pre><hr><pre>commit c4e0b508bcdd1af6b1b3c317042336936173591f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 27 11:28:42 2010 -0400

    USB: accept RNDIS configs if there's no alternative
    
    This patch (as1410) makes a slight change to the strategy used for
    choosing a default configuration.  Currently we skip configs whose
    first interface is RNDIS, if the kernel wasn't built with the
    corresponding driver.  This risks losing access to the other
    interfaces in those configs.  In addition, if there is only one config
    then we will end up not configuring the device at all.
    
    This changes the logic; now such configurations will be skipped only
    if there is at least one other config.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Adam Kropelin &lt;akropel1@rochester.rr.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 9a34ccb0a1c0..69ecd3c92311 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -105,8 +105,10 @@ int usb_choose_configuration(struct usb_device *udev)
 		/* When the first config's first interface is one of Microsoft's
 		 * pet nonstandard Ethernet-over-USB protocols, ignore it unless
 		 * this kernel has enabled the necessary host side driver.
+		 * But: Don't ignore it if it's the only config.
 		 */
-		if (i == 0 &amp;&amp; desc &amp;&amp; (is_rndis(desc) || is_activesync(desc))) {
+		if (i == 0 &amp;&amp; num_configs &gt; 1 &amp;&amp; desc &amp;&amp;
+				(is_rndis(desc) || is_activesync(desc))) {
 #if !defined(CONFIG_USB_NET_RNDIS_HOST) &amp;&amp; !defined(CONFIG_USB_NET_RNDIS_HOST_MODULE)
 			continue;
 #else</pre><hr><pre>commit 88d8aa462b8a2128a75b96a0134b22f724ca45d1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:57 2010 -0400

    USB: EHCI: remove dead code in the periodic scheduler
    
    This patch (as1409) removes some dead code from the ehci-hcd
    scheduler.  Thanks to the previous patch in this series, stream-&gt;depth
    is no longer used.  And stream-&gt;start and stream-&gt;rescheduled
    apparently have not been used for quite a while, except in some
    statistics-reporting code that never gets invoked.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 3381319a2b3f..a92526d6e5ae 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1074,15 +1074,6 @@ iso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)
 		if (stream-&gt;ep)
 			stream-&gt;ep-&gt;hcpriv = NULL;
 
-		if (stream-&gt;rescheduled) {
-			ehci_info (ehci, "ep%d%s-iso rescheduled "
-				"%lu times in %lu seconds\n",
-				stream-&gt;bEndpointAddress, is_in ? "in" : "out",
-				stream-&gt;rescheduled,
-				((jiffies - stream-&gt;start)/HZ)
-				);
-		}
-
 		kfree(stream);
 	}
 }
@@ -1617,7 +1608,6 @@ itd_link_urb (
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out",
 			urb-&gt;interval,
 			next_uframe &gt;&gt; 3, next_uframe &amp; 0x7);
-		stream-&gt;start = jiffies;
 	}
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs++;
 
@@ -1643,7 +1633,6 @@ itd_link_urb (
 		itd_patch(ehci, itd, iso_sched, packet, uframe);
 
 		next_uframe += stream-&gt;interval;
-		stream-&gt;depth += stream-&gt;interval;
 		next_uframe &amp;= mod - 1;
 		packet++;
 
@@ -1699,7 +1688,6 @@ itd_complete (
 
 		t = hc32_to_cpup(ehci, &amp;itd-&gt;hw_transaction [uframe]);
 		itd-&gt;hw_transaction [uframe] = 0;
-		stream-&gt;depth -= stream-&gt;interval;
 
 		/* report transfer status */
 		if (unlikely (t &amp; ISO_ERRS)) {
@@ -2029,7 +2017,6 @@ sitd_link_urb (
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out",
 			(next_uframe &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1),
 			stream-&gt;interval, hc32_to_cpu(ehci, stream-&gt;splits));
-		stream-&gt;start = jiffies;
 	}
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs++;
 
@@ -2054,7 +2041,6 @@ sitd_link_urb (
 				sitd);
 
 		next_uframe += stream-&gt;interval &lt;&lt; 3;
-		stream-&gt;depth += stream-&gt;interval &lt;&lt; 3;
 	}
 	stream-&gt;next_uframe = next_uframe &amp; (mod - 1);
 
@@ -2114,7 +2100,6 @@ sitd_complete (
 		desc-&gt;actual_length = desc-&gt;length - SITD_LENGTH(t);
 		urb-&gt;actual_length += desc-&gt;actual_length;
 	}
-	stream-&gt;depth -= stream-&gt;interval &lt;&lt; 3;
 
 	/* handle completion now? */
 	if ((urb_index + 1) != urb-&gt;number_of_packets)
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 2c050efd1deb..e5b9ece8a077 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -404,15 +404,12 @@ struct ehci_iso_stream {
 	u32			refcount;
 	u8			bEndpointAddress;
 	u8			highspeed;
-	u16			depth;		/* depth in uframes */
 	struct list_head	td_list;	/* queued itds/sitds */
 	struct list_head	free_list;	/* list of unused itds/sitds */
 	struct usb_device	*udev;
 	struct usb_host_endpoint *ep;
 
 	/* output of (re)scheduling */
-	unsigned long		start;		/* jiffies */
-	unsigned long		rescheduled;
 	int			next_uframe;
 	__hc32			splits;
 </pre><hr><pre>commit 1fb2e0558781b07d2ecaabf94c81c17ac820d8f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:53 2010 -0400

    USB: EHCI: reorganize isochronous scheduler routine
    
    This patch (as1408) rearranges the scheduling code in ehci-hcd, partly
    to improve its structure, but mainly to change the way it works.
    Whether or not a transfer exceeds the hardware schedule length will
    now be determined by looking at the last frame the transfer would use,
    instead of the first available frame following the end of the transfer.
    
    The benefit of this change is that it allows the driver to accept
    valid URBs which would otherwise be rejected.  For example, suppose
    the schedule length is 1024 frames, the endpoint period is 256 frames,
    and a four-packet URB is submitted.  The four transfers would occupy
    slots that are 0, 256, 512, and 768 frames past the current frame
    (plus an extra slop factor).  These don't exceed the 1024-frame limit,
    so the URB should be accepted.  But the current code notices that the
    next available slot would be 1024 frames (plus slop) in the future,
    which is beyond the limit, and so the URB is rejected unnecessarily.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index dd37350170bb..3381319a2b3f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1413,13 +1413,6 @@ iso_stream_schedule (
 		goto fail;
 	}
 
-	if (stream-&gt;depth + span &gt; mod) {
-		ehci_dbg (ehci, "request %p would overflow (%d+%d&gt;%d)\n",
-			urb, stream-&gt;depth, span, mod);
-		status = -EFBIG;
-		goto fail;
-	}
-
 	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
@@ -1428,7 +1421,7 @@ iso_stream_schedule (
 	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
-		start = stream-&gt;next_uframe;
+		u32	excess;
 
 		/* For high speed devices, allow scheduling within the
 		 * isochronous scheduling threshold.  For full speed devices
@@ -1440,21 +1433,23 @@ iso_stream_schedule (
 		else
 			next = now;
 
-		/* Fell behind (by up to twice the slop amount)? */
-		if (((start - next) &amp; (mod - 1)) &gt;=
-				mod - 2 * SCHEDULE_SLOP)
-			start += period * DIV_ROUND_UP(
-					(next - start) &amp; (mod - 1),
-					period);
-
-		/* Tried to schedule too far into the future? */
-		if (unlikely(((start - now) &amp; (mod - 1)) + span
-					&gt;= mod - 2 * SCHEDULE_SLOP)) {
+		/* Fell behind (by up to twice the slop amount)?
+		 * We decide based on the time of the last currently-scheduled
+		 * slot, not the time of the next available slot.
+		 */
+		excess = (stream-&gt;next_uframe - period - next) &amp; (mod - 1);
+		if (excess &gt;= mod - 2 * SCHEDULE_SLOP)
+			start = next + excess - mod + period *
+					DIV_ROUND_UP(mod - excess, period);
+		else
+			start = next + excess + period;
+		if (start - now &gt;= mod) {
+			ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
+					urb, start - now - period, period,
+					mod);
 			status = -EFBIG;
 			goto fail;
 		}
-		stream-&gt;next_uframe = start;
-		goto ready;
 	}
 
 	/* need to schedule; when's the next (u)frame we could start?
@@ -1463,51 +1458,60 @@ iso_stream_schedule (
 	 * can also help high bandwidth if the dma and irq loads don't
 	 * jump until after the queue is primed.
 	 */
-	start = SCHEDULE_SLOP + (now &amp; ~0x07);
-	start &amp;= mod - 1;
-	stream-&gt;next_uframe = start;
-
-	/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
-
-	/* find a uframe slot with enough bandwidth */
-	for (; start &lt; (stream-&gt;next_uframe + period); start++) {
-		int		enough_space;
-
-		/* check schedule: enough space? */
-		if (stream-&gt;highspeed)
-			enough_space = itd_slot_ok (ehci, mod, start,
-					stream-&gt;usecs, period);
-		else {
-			if ((start % 8) &gt;= 6)
-				continue;
-			enough_space = sitd_slot_ok (ehci, mod, stream,
-					start, sched, period);
+	else {
+		start = SCHEDULE_SLOP + (now &amp; ~0x07);
+
+		/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
+
+		/* find a uframe slot with enough bandwidth */
+		next = start + period;
+		for (; start &lt; next; start++) {
+
+			/* check schedule: enough space? */
+			if (stream-&gt;highspeed) {
+				if (itd_slot_ok(ehci, mod, start,
+						stream-&gt;usecs, period))
+					break;
+			} else {
+				if ((start % 8) &gt;= 6)
+					continue;
+				if (sitd_slot_ok(ehci, mod, stream,
+						start, sched, period))
+					break;
+			}
 		}
 
-		/* schedule it here if there's enough bandwidth */
-		if (enough_space) {
-			stream-&gt;next_uframe = start &amp; (mod - 1);
-			goto ready;
+		/* no room in the schedule */
+		if (start == next) {
+			ehci_dbg(ehci, "iso resched full %p (now %d max %d)\n",
+				urb, now, now + mod);
+			status = -ENOSPC;
+			goto fail;
 		}
 	}
 
-	/* no room in the schedule */
-	ehci_dbg (ehci, "iso %ssched full %p (now %d max %d)\n",
-		list_empty (&amp;stream-&gt;td_list) ? "" : "re",
-		urb, now, now + mod);
-	status = -ENOSPC;
+	/* Tried to schedule too far into the future? */
+	if (unlikely(start - now + span - period
+				&gt;= mod - 2 * SCHEDULE_SLOP)) {
+		ehci_dbg(ehci, "request %p would overflow (%d+%d &gt;= %d)\n",
+				urb, start - now, span - period,
+				mod - 2 * SCHEDULE_SLOP);
+		status = -EFBIG;
+		goto fail;
+	}
 
-fail:
-	iso_sched_free (stream, sched);
-	urb-&gt;hcpriv = NULL;
-	return status;
+	stream-&gt;next_uframe = start &amp; (mod - 1);
 
-ready:
 	/* report high speed start in uframes; full speed, in frames */
 	urb-&gt;start_frame = stream-&gt;next_uframe;
 	if (!stream-&gt;highspeed)
 		urb-&gt;start_frame &gt;&gt;= 3;
 	return 0;
+
+ fail:
+	iso_sched_free(stream, sched);
+	urb-&gt;hcpriv = NULL;
+	return status;
 }
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit ffda080353979273e8aa69fc1e6134f20643ae56
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:46 2010 -0400

    USB: EHCI: add missing frame -&gt; microframe conversion
    
    This patch (as1407) fixes a bug in ehci-hcd's isochronous scheduler.
    All its calculations should be done in terms of microframes, but for
    full-speed devices, sched-&gt;span is stored in frames.  It needs to be
    converted.
    
    This fix is liable to expose problems in other drivers.  The old code
    would accept URBs that should not have been accepted, so drivers have
    had no reason to avoid submitting URBs that exceeded the maximum
    schedule length.  In an attempt to partially compensate for this, the
    patch also adjusts the schedule length from a minimum of 256 frames up
    to a minimum of 512 frames.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2e704fa3cedf..34a928d3b7d2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -79,7 +79,13 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_RL_TT		0
 #define	EHCI_TUNE_MULT_HS	1	/* 1-3 transactions/uframe; 4.10.3 */
 #define	EHCI_TUNE_MULT_TT	1
-#define	EHCI_TUNE_FLS		2	/* (small) 256 frame schedule */
+/*
+ * Some drivers think it's safe to schedule isochronous transfers more than
+ * 256 ms into the future (partly as a result of an old bug in the scheduling
+ * code).  In an attempt to avoid trouble, we will use a minimum scheduling
+ * length of 512 frames instead of 256.
+ */
+#define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 27dd841b9aa2..dd37350170bb 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1395,28 +1395,31 @@ iso_stream_schedule (
 	struct ehci_iso_stream	*stream
 )
 {
-	u32			now, next, start, period;
+	u32			now, next, start, period, span;
 	int			status;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
 
-	if (sched-&gt;span &gt; (mod - SCHEDULE_SLOP)) {
+	period = urb-&gt;interval;
+	span = sched-&gt;span;
+	if (!stream-&gt;highspeed) {
+		period &lt;&lt;= 3;
+		span &lt;&lt;= 3;
+	}
+
+	if (span &gt; mod - SCHEDULE_SLOP) {
 		ehci_dbg (ehci, "iso request %p too long\n", urb);
 		status = -EFBIG;
 		goto fail;
 	}
 
-	if ((stream-&gt;depth + sched-&gt;span) &gt; mod) {
+	if (stream-&gt;depth + span &gt; mod) {
 		ehci_dbg (ehci, "request %p would overflow (%d+%d&gt;%d)\n",
-			urb, stream-&gt;depth, sched-&gt;span, mod);
+			urb, stream-&gt;depth, span, mod);
 		status = -EFBIG;
 		goto fail;
 	}
 
-	period = urb-&gt;interval;
-	if (!stream-&gt;highspeed)
-		period &lt;&lt;= 3;
-
 	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
@@ -1445,7 +1448,7 @@ iso_stream_schedule (
 					period);
 
 		/* Tried to schedule too far into the future? */
-		if (unlikely(((start - now) &amp; (mod - 1)) + sched-&gt;span
+		if (unlikely(((start - now) &amp; (mod - 1)) + span
 					&gt;= mod - 2 * SCHEDULE_SLOP)) {
 			status = -EFBIG;
 			goto fail;</pre><hr><pre>commit bccbefaae050186bed3bcc74b1fd1a9b8c6710b2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:36 2010 -0400

    USB: EHCI: simplify remainder computations
    
    This patch (as1406) adds a micro-optimization to ehci-hcd's scheduling
    code.  Instead of computing remainders with respect to the schedule
    length, use bitwise-and (which is quicker).  We know that the schedule
    length will always be a power of two, but the compiler doesn't have
    this information.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index efadced4ae67..27dd841b9aa2 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1417,7 +1417,7 @@ iso_stream_schedule (
 	if (!stream-&gt;highspeed)
 		period &lt;&lt;= 3;
 
-	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) % mod;
+	now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp; (mod - 1);
 
 	/* Typical case: reuse current schedule, stream is still active.
 	 * Hopefully there are no gaps from the host falling behind
@@ -1461,7 +1461,7 @@ iso_stream_schedule (
 	 * jump until after the queue is primed.
 	 */
 	start = SCHEDULE_SLOP + (now &amp; ~0x07);
-	start %= mod;
+	start &amp;= mod - 1;
 	stream-&gt;next_uframe = start;
 
 	/* NOTE:  assumes URB_ISO_ASAP, to limit complexity/bugs */
@@ -1483,7 +1483,7 @@ iso_stream_schedule (
 
 		/* schedule it here if there's enough bandwidth */
 		if (enough_space) {
-			stream-&gt;next_uframe = start % mod;
+			stream-&gt;next_uframe = start &amp; (mod - 1);
 			goto ready;
 		}
 	}
@@ -1599,7 +1599,7 @@ itd_link_urb (
 	struct ehci_iso_sched	*iso_sched = urb-&gt;hcpriv;
 	struct ehci_itd		*itd;
 
-	next_uframe = stream-&gt;next_uframe % mod;
+	next_uframe = stream-&gt;next_uframe &amp; (mod - 1);
 
 	if (unlikely (list_empty(&amp;stream-&gt;td_list))) {
 		ehci_to_hcd(ehci)-&gt;self.bandwidth_allocated
@@ -1637,13 +1637,13 @@ itd_link_urb (
 
 		next_uframe += stream-&gt;interval;
 		stream-&gt;depth += stream-&gt;interval;
-		next_uframe %= mod;
+		next_uframe &amp;= mod - 1;
 		packet++;
 
 		/* link completed itds into the schedule */
 		if (((next_uframe &gt;&gt; 3) != frame)
 				|| packet == urb-&gt;number_of_packets) {
-			itd_link (ehci, frame % ehci-&gt;periodic_size, itd);
+			itd_link(ehci, frame &amp; (ehci-&gt;periodic_size - 1), itd);
 			itd = NULL;
 		}
 	}
@@ -2020,7 +2020,7 @@ sitd_link_urb (
 			"sched devp %s ep%d%s-iso [%d] %dms/%04x\n",
 			urb-&gt;dev-&gt;devpath, stream-&gt;bEndpointAddress &amp; 0x0f,
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out",
-			(next_uframe &gt;&gt; 3) % ehci-&gt;periodic_size,
+			(next_uframe &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1),
 			stream-&gt;interval, hc32_to_cpu(ehci, stream-&gt;splits));
 		stream-&gt;start = jiffies;
 	}
@@ -2043,13 +2043,13 @@ sitd_link_urb (
 		sitd-&gt;urb = urb;
 
 		sitd_patch(ehci, stream, sitd, sched, packet);
-		sitd_link (ehci, (next_uframe &gt;&gt; 3) % ehci-&gt;periodic_size,
+		sitd_link(ehci, (next_uframe &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1),
 				sitd);
 
 		next_uframe += stream-&gt;interval &lt;&lt; 3;
 		stream-&gt;depth += stream-&gt;interval &lt;&lt; 3;
 	}
-	stream-&gt;next_uframe = next_uframe % mod;
+	stream-&gt;next_uframe = next_uframe &amp; (mod - 1);
 
 	/* don't need that schedule data any more */
 	iso_sched_free (stream, sched);
@@ -2258,7 +2258,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	now_uframe = ehci-&gt;next_uframe;
 	if (HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
 		clock = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
-		clock_frame = (clock &gt;&gt; 3) % ehci-&gt;periodic_size;
+		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
 	} else  {
 		clock = now_uframe + mod - 1;
 		clock_frame = -1;
@@ -2267,7 +2267,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		free_cached_lists(ehci);
 		ehci-&gt;clock_frame = clock_frame;
 	}
-	clock %= mod;
+	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
 
 	for (;;) {
@@ -2356,7 +2356,7 @@ scan_periodic (struct ehci_hcd *ehci)
 				 * frame is current.
 				 */
 				if (((frame == clock_frame) ||
-				     (((frame + 1) % ehci-&gt;periodic_size)
+				     (((frame + 1) &amp; (ehci-&gt;periodic_size - 1))
 				      == clock_frame))
 				    &amp;&amp; live
 				    &amp;&amp; (q.sitd-&gt;hw_results &amp;
@@ -2423,7 +2423,8 @@ scan_periodic (struct ehci_hcd *ehci)
 					|| ehci-&gt;periodic_sched == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
-			now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) % mod;
+			now = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index) &amp;
+					(mod - 1);
 			if (now_uframe == now)
 				break;
 
@@ -2436,7 +2437,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			}
 		} else {
 			now_uframe++;
-			now_uframe %= mod;
+			now_uframe &amp;= mod - 1;
 		}
 	}
 }</pre><hr><pre>commit ae68a83bdc1971cb02fefc7a686ba6d077065e71
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 14 11:03:23 2010 -0400

    USB: EHCI: remove PCI assumption
    
    This patch (as1405) fixes a small bug in ehci-hcd's isochronous
    scheduler.  Not all EHCI controllers are PCI, and the code shouldn't
    assume that they are.  Instead, introduce a special flag for
    controllers which need to delay iso scheduling for full-speed devices
    beyond the scheduling threshold.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Acked-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index f555e4f35a04..58b72d741d93 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -114,6 +114,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		break;
 	case PCI_VENDOR_ID_INTEL:
 		ehci-&gt;need_io_watchdog = 0;
+		ehci-&gt;fs_i_thresh = 1;
 		if (pdev-&gt;device == 0x27cc) {
 			ehci-&gt;broken_periodic = 1;
 			ehci_info(ehci, "using broken periodic workaround\n");
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index d640346f9b56..efadced4ae67 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1399,7 +1399,6 @@ iso_stream_schedule (
 	int			status;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
-	struct pci_dev		*pdev;
 
 	if (sched-&gt;span &gt; (mod - SCHEDULE_SLOP)) {
 		ehci_dbg (ehci, "iso request %p too long\n", urb);
@@ -1426,15 +1425,14 @@ iso_stream_schedule (
 	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
-		pdev = to_pci_dev(ehci_to_hcd(ehci)-&gt;self.controller);
 		start = stream-&gt;next_uframe;
 
 		/* For high speed devices, allow scheduling within the
-		 * isochronous scheduling threshold.  For full speed devices,
-		 * don't. (Work around for Intel ICH9 bug.)
+		 * isochronous scheduling threshold.  For full speed devices
+		 * and Intel PCI-based controllers, don't (work around for
+		 * Intel ICH9 bug).
 		 */
-		if (!stream-&gt;highspeed &amp;&amp;
-				pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)
+		if (!stream-&gt;highspeed &amp;&amp; ehci-&gt;fs_i_thresh)
 			next = now + ehci-&gt;i_thresh;
 		else
 			next = now;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index a4a63ce290e9..2c050efd1deb 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -130,6 +130,7 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		has_amcc_usb23:1;
 	unsigned		need_io_watchdog:1;
 	unsigned		broken_periodic:1;
+	unsigned		fs_i_thresh:1;	/* Intel iso scheduling */
 
 	/* required for usb32 quirk */
 	#define OHCI_CTRL_HCFS          (3 &lt;&lt; 6)</pre><hr><pre>commit 3da7cff4e79e4a7137b0dac1aaf6841b91bbff63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:57 2010 -0400

    USB: add runtime PM for PCI-based host controllers
    
    This patch (as1386) adds runtime-PM support for PCI-based USB host
    controllers.  By default autosuspend is disallowed; the user must
    enable it by writing "auto" to the controller's power/control sysfs
    attribute.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 352577baa53d..fe6b8d40a506 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -250,6 +250,9 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	if (retval != 0)
 		goto err4;
 	set_hs_companion(dev, hcd);
+
+	if (pci_dev_run_wake(dev))
+		pm_runtime_put_noidle(&amp;dev-&gt;dev);
 	return retval;
 
  err4:
@@ -292,6 +295,9 @@ void usb_hcd_pci_remove(struct pci_dev *dev)
 	if (!hcd)
 		return;
 
+	if (pci_dev_run_wake(dev))
+		pm_runtime_get_noresume(&amp;dev-&gt;dev);
+
 	/* Fake an interrupt request in order to give the driver a chance
 	 * to test whether the controller hardware has been removed (e.g.,
 	 * cardbus physical eject).
@@ -325,12 +331,13 @@ void usb_hcd_pci_shutdown(struct pci_dev *dev)
 	if (!hcd)
 		return;
 
-	if (hcd-&gt;driver-&gt;shutdown)
+	if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) &amp;&amp;
+			hcd-&gt;driver-&gt;shutdown)
 		hcd-&gt;driver-&gt;shutdown(hcd);
 }
 EXPORT_SYMBOL_GPL(usb_hcd_pci_shutdown);
 
-#ifdef	CONFIG_PM_SLEEP
+#ifdef	CONFIG_PM_OPS
 
 #ifdef	CONFIG_PPC_PMAC
 static void powermac_set_asic(struct pci_dev *pci_dev, int enable)
@@ -366,7 +373,7 @@ static int check_root_hub_suspended(struct device *dev)
 	return 0;
 }
 
-static int hcd_pci_suspend(struct device *dev)
+static int suspend_common(struct device *dev, bool do_wakeup)
 {
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
 	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
@@ -381,13 +388,7 @@ static int hcd_pci_suspend(struct device *dev)
 	if (retval)
 		return retval;
 
-	/* We might already be suspended (runtime PM -- not yet written) */
-	if (pci_dev-&gt;current_state != PCI_D0)
-		return retval;
-
 	if (hcd-&gt;driver-&gt;pci_suspend) {
-		bool	do_wakeup = device_may_wakeup(dev);
-
 		/* Optimization: Don't suspend if a root-hub wakeup is
 		 * pending and it would cause the HCD to wake up anyway.
 		 */
@@ -439,10 +440,8 @@ static int resume_common(struct device *dev, int event)
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
 	if (hcd-&gt;driver-&gt;pci_resume) {
-		/* This call should be made only during system resume,
-		 * not during runtime resume.
-		 */
-		wait_for_companions(pci_dev, hcd);
+		if (event != PM_EVENT_AUTO_RESUME)
+			wait_for_companions(pci_dev, hcd);
 
 		retval = hcd-&gt;driver-&gt;pci_resume(hcd,
 				event == PM_EVENT_RESTORE);
@@ -454,6 +453,13 @@ static int resume_common(struct device *dev, int event)
 	return retval;
 }
 
+#ifdef	CONFIG_PM_SLEEP
+
+static int hcd_pci_suspend(struct device *dev)
+{
+	return suspend_common(dev, device_may_wakeup(dev));
+}
+
 static int hcd_pci_suspend_noirq(struct device *dev)
 {
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
@@ -513,6 +519,46 @@ static int hcd_pci_restore(struct device *dev)
 	return resume_common(dev, PM_EVENT_RESTORE);
 }
 
+#else
+
+#define hcd_pci_suspend		NULL
+#define hcd_pci_suspend_noirq	NULL
+#define hcd_pci_resume_noirq	NULL
+#define hcd_pci_resume		NULL
+#define hcd_pci_restore		NULL
+
+#endif	/* CONFIG_PM_SLEEP */
+
+#ifdef	CONFIG_PM_RUNTIME
+
+static int hcd_pci_runtime_suspend(struct device *dev)
+{
+	int	retval;
+
+	retval = suspend_common(dev, true);
+	if (retval == 0)
+		powermac_set_asic(to_pci_dev(dev), 0);
+	dev_dbg(dev, "hcd_pci_runtime_suspend: %d\n", retval);
+	return retval;
+}
+
+static int hcd_pci_runtime_resume(struct device *dev)
+{
+	int	retval;
+
+	powermac_set_asic(to_pci_dev(dev), 1);
+	retval = resume_common(dev, PM_EVENT_AUTO_RESUME);
+	dev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);
+	return retval;
+}
+
+#else
+
+#define hcd_pci_runtime_suspend	NULL
+#define hcd_pci_runtime_resume	NULL
+
+#endif	/* CONFIG_PM_RUNTIME */
+
 const struct dev_pm_ops usb_hcd_pci_pm_ops = {
 	.suspend	= hcd_pci_suspend,
 	.suspend_noirq	= hcd_pci_suspend_noirq,
@@ -526,7 +572,9 @@ const struct dev_pm_ops usb_hcd_pci_pm_ops = {
 	.poweroff_noirq	= hcd_pci_suspend_noirq,
 	.restore_noirq	= hcd_pci_resume_noirq,
 	.restore	= hcd_pci_restore,
+	.runtime_suspend = hcd_pci_runtime_suspend,
+	.runtime_resume	= hcd_pci_runtime_resume,
 };
 EXPORT_SYMBOL_GPL(usb_hcd_pci_pm_ops);
 
-#endif	/* CONFIG_PM_SLEEP */
+#endif	/* CONFIG_PM_OPS */</pre><hr><pre>commit 0d436b425e07f9e4b0fe571cec061f5d136f1d8b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 25 14:02:49 2010 -0400

    USB: UHCI: add support for Intel's wakeup flags
    
    This patch (as1396) adds code to uhci-hcd to support the
    vendor-specific wakeup settings found in Intel's ICHx hardware.  A
    couple of unnecessary memory barriers are removed.  And the root hub
    isn't put back into the "suspended" state if power was lost during a
    system sleep -- there's not much point in doing so because the root hub
    will be resumed shortly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 9d4d81248f96..b04506036b64 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -176,6 +176,8 @@ static void check_and_reset_hc(struct uhci_hcd *uhci)
  */
 static void configure_hc(struct uhci_hcd *uhci)
 {
+	struct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));
+
 	/* Set the frame length to the default: 1 ms exactly */
 	outb(USBSOF_DEFAULT, uhci-&gt;io_addr + USBSOF);
 
@@ -191,8 +193,11 @@ static void configure_hc(struct uhci_hcd *uhci)
 	mb();
 
 	/* Enable PIRQ */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_DEFAULT);
+	pci_write_config_word(pdev, USBLEGSUP, USBLEGSUP_DEFAULT);
+
+	/* Disable platform-specific non-PME# wakeup */
+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)
+		pci_write_config_byte(pdev, USBRES_INTEL, 0);
 }
 
 
@@ -791,6 +796,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
+	struct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));
 	int rc = 0;
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __func__);
@@ -808,11 +814,15 @@ static int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)
 	/* All PCI host controllers are required to disable IRQ generation
 	 * at the source, so we must turn off PIRQ.
 	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
-	mb();
+	pci_write_config_word(pdev, USBLEGSUP, 0);
 	clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
-	/* FIXME: Enable non-PME# remote wakeup? */
+	/* Enable platform-specific non-PME# wakeup */
+	if (do_wakeup) {
+		if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)
+			pci_write_config_byte(pdev, USBRES_INTEL,
+					USBPORT1EN | USBPORT2EN);
+	}
 
 done_okay:
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
@@ -831,7 +841,6 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	 * even if the controller was dead.
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	mb();
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
@@ -839,8 +848,6 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	if (hibernated)
 		uhci_hc_died(uhci);
 
-	/* FIXME: Disable non-PME# remote wakeup? */
-
 	/* The firmware or a boot kernel may have changed the controller
 	 * settings during a system wakeup.  Check it and reconfigure
 	 * to avoid problems.
@@ -850,12 +857,9 @@ static int uhci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* If the controller was dead before, it's back alive now */
 	configure_hc(uhci);
 
-	if (uhci-&gt;rh_state == UHCI_RH_RESET) {
-
-		/* The controller had to be reset */
+	/* Tell the core if the controller had to be reset */
+	if (uhci-&gt;rh_state == UHCI_RH_RESET)
 		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
-		suspend_rh(uhci, UHCI_RH_SUSPENDED);
-	}
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 26bd1b2bcbfc..49bf2790f9c2 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -67,12 +67,17 @@
 #define   USBPORTSC_RES3	0x4000	/* reserved, write zeroes */
 #define   USBPORTSC_RES4	0x8000	/* reserved, write zeroes */
 
-/* Legacy support register */
+/* PCI legacy support register */
 #define USBLEGSUP		0xc0
 #define   USBLEGSUP_DEFAULT	0x2000	/* only PIRQ enable set */
 #define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
 #define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
+/* PCI Intel-specific resume-enable register */
+#define USBRES_INTEL		0xc4
+#define   USBPORT1EN		0x01
+#define   USBPORT2EN		0x02
+
 #define UHCI_PTR_BITS		cpu_to_le32(0x000F)
 #define UHCI_PTR_TERM		cpu_to_le32(0x0001)
 #define UHCI_PTR_QH		cpu_to_le32(0x0002)</pre>
    <div class="pagination">
        <a href='2_62.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><span>[63]</span><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_64.html'>Next&gt;&gt;</a>
    <div>
</body>
