<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_20.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><span>[21]</span><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_22.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 3e3b5dfcd16a3e254aab61bd1e8c417dd4503102
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Nov 16 23:26:52 2021 +0800

    NFC: reorder the logic in nfc_{un,}register_device
    
    There is a potential UAF between the unregistration routine and the NFC
    netlink operations.
    
    The race that cause that UAF can be shown as below:
    
     (FREE)                      |  (USE)
    nfcmrvl_nci_unregister_dev   |  nfc_genl_dev_up
      nci_close_device           |
      nci_unregister_device      |    nfc_get_device
        nfc_unregister_device    |    nfc_dev_up
          rfkill_destory         |
          device_del             |      rfkill_blocked
      ...                        |    ...
    
    The root cause for this race is concluded below:
    1. The rfkill_blocked (USE) in nfc_dev_up is supposed to be placed after
    the device_is_registered check.
    2. Since the netlink operations are possible just after the device_add
    in nfc_register_device, the nfc_dev_up() can happen anywhere during the
    rfkill creation process, which leads to data race.
    
    This patch reorder these actions to permit
    1. Once device_del is finished, the nfc_dev_up cannot dereference the
    rfkill object.
    2. The rfkill_register need to be placed after the device_add of nfc_dev
    because the parent device need to be created first. So this patch keeps
    the order but inject device_lock to prevent the data race.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Fixes: be055b2f89b5 ("NFC: RFKILL support")
    Reviewed-by: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Reviewed-by: Krzysztof Kozlowski &lt;krzysztof.kozlowski@canonical.com&gt;
    Link: https://lore.kernel.org/r/20211116152652.19217-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/nfc/core.c b/net/nfc/core.c
index 3c645c1d99c9..dc7a2404efdf 100644
--- a/net/nfc/core.c
+++ b/net/nfc/core.c
@@ -94,13 +94,13 @@ int nfc_dev_up(struct nfc_dev *dev)
 
 	device_lock(&amp;dev-&gt;dev);
 
-	if (dev-&gt;rfkill &amp;&amp; rfkill_blocked(dev-&gt;rfkill)) {
-		rc = -ERFKILL;
+	if (!device_is_registered(&amp;dev-&gt;dev)) {
+		rc = -ENODEV;
 		goto error;
 	}
 
-	if (!device_is_registered(&amp;dev-&gt;dev)) {
-		rc = -ENODEV;
+	if (dev-&gt;rfkill &amp;&amp; rfkill_blocked(dev-&gt;rfkill)) {
+		rc = -ERFKILL;
 		goto error;
 	}
 
@@ -1125,11 +1125,7 @@ int nfc_register_device(struct nfc_dev *dev)
 	if (rc)
 		pr_err("Could not register llcp device\n");
 
-	rc = nfc_genl_device_added(dev);
-	if (rc)
-		pr_debug("The userspace won't be notified that the device %s was added\n",
-			 dev_name(&amp;dev-&gt;dev));
-
+	device_lock(&amp;dev-&gt;dev);
 	dev-&gt;rfkill = rfkill_alloc(dev_name(&amp;dev-&gt;dev), &amp;dev-&gt;dev,
 				   RFKILL_TYPE_NFC, &amp;nfc_rfkill_ops, dev);
 	if (dev-&gt;rfkill) {
@@ -1138,6 +1134,12 @@ int nfc_register_device(struct nfc_dev *dev)
 			dev-&gt;rfkill = NULL;
 		}
 	}
+	device_unlock(&amp;dev-&gt;dev);
+
+	rc = nfc_genl_device_added(dev);
+	if (rc)
+		pr_debug("The userspace won't be notified that the device %s was added\n",
+			 dev_name(&amp;dev-&gt;dev));
 
 	return 0;
 }
@@ -1154,10 +1156,17 @@ void nfc_unregister_device(struct nfc_dev *dev)
 
 	pr_debug("dev_name=%s\n", dev_name(&amp;dev-&gt;dev));
 
+	rc = nfc_genl_device_removed(dev);
+	if (rc)
+		pr_debug("The userspace won't be notified that the device %s "
+			 "was removed\n", dev_name(&amp;dev-&gt;dev));
+
+	device_lock(&amp;dev-&gt;dev);
 	if (dev-&gt;rfkill) {
 		rfkill_unregister(dev-&gt;rfkill);
 		rfkill_destroy(dev-&gt;rfkill);
 	}
+	device_unlock(&amp;dev-&gt;dev);
 
 	if (dev-&gt;ops-&gt;check_presence) {
 		device_lock(&amp;dev-&gt;dev);
@@ -1167,11 +1176,6 @@ void nfc_unregister_device(struct nfc_dev *dev)
 		cancel_work_sync(&amp;dev-&gt;check_pres_work);
 	}
 
-	rc = nfc_genl_device_removed(dev);
-	if (rc)
-		pr_debug("The userspace won't be notified that the device %s "
-			 "was removed\n", dev_name(&amp;dev-&gt;dev));
-
 	nfc_llcp_unregister_device(dev);
 
 	mutex_lock(&amp;nfc_devlist_mutex);</pre><hr><pre>commit 86cdf8e38792545161dbe3350a7eced558ba4d15
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Mon Nov 15 22:56:00 2021 +0800

    NFC: reorganize the functions in nci_request
    
    There is a possible data race as shown below:
    
    thread-A in nci_request()       | thread-B in nci_close_device()
                                    | mutex_lock(&amp;ndev-&gt;req_lock);
    test_bit(NCI_UP, &amp;ndev-&gt;flags); |
    ...                             | test_and_clear_bit(NCI_UP, &amp;ndev-&gt;flags)
    mutex_lock(&amp;ndev-&gt;req_lock);    |
                                    |
    
    This race will allow __nci_request() to be awaked while the device is
    getting removed.
    
    Similar to commit e2cb6b891ad2 ("bluetooth: eliminate the potential race
    condition when removing the HCI controller"). this patch alters the
    function sequence in nci_request() to prevent the data races between the
    nci_close_device().
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Fixes: 6a2968aaf50c ("NFC: basic NCI protocol implementation")
    Link: https://lore.kernel.org/r/20211115145600.8320-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/nfc/nci/core.c b/net/nfc/nci/core.c
index 6fd873aa86be..1dd0269c1a72 100644
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@ -144,12 +144,15 @@ inline int nci_request(struct nci_dev *ndev,
 {
 	int rc;
 
-	if (!test_bit(NCI_UP, &amp;ndev-&gt;flags))
-		return -ENETDOWN;
-
 	/* Serialize all requests */
 	mutex_lock(&amp;ndev-&gt;req_lock);
-	rc = __nci_request(ndev, req, opt, timeout);
+	/* check the state after obtaing the lock against any races
+	 * from nci_close_device when the device gets removed.
+	 */
+	if (test_bit(NCI_UP, &amp;ndev-&gt;flags))
+		rc = __nci_request(ndev, req, opt, timeout);
+	else
+		rc = -ENETDOWN;
 	mutex_unlock(&amp;ndev-&gt;req_lock);
 
 	return rc;</pre><hr><pre>commit 81b1d548d00bcd028303c4f3150fa753b9b8aa71
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Nov 11 22:14:02 2021 +0800

    hamradio: remove needs_free_netdev to avoid UAF
    
    The former patch "defer 6pack kfree after unregister_netdev" reorders
    the kfree of two buffer after the unregister_netdev to prevent the race
    condition. It also adds free_netdev() function in sixpack_close(), which
    is a direct copy from the similar code in mkiss_close().
    
    However, in sixpack driver, the flag needs_free_netdev is set to true in
    sp_setup(), hence the unregister_netdev() will free the netdev
    automatically. Therefore, as the sp is netdev_priv, use-after-free
    occurs.
    
    This patch removes the needs_free_netdev = true and just let the
    free_netdev to finish this deallocation task.
    
    Fixes: 0b9111922b1f ("hamradio: defer 6pack kfree after unregister_netdev")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20211111141402.7551-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index bfdf89e54752..8a19a06b505d 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -306,7 +306,6 @@ static void sp_setup(struct net_device *dev)
 {
 	/* Finish setting up the DEVICE info. */
 	dev-&gt;netdev_ops		= &amp;sp_netdev_ops;
-	dev-&gt;needs_free_netdev	= true;
 	dev-&gt;mtu		= SIXP_MTU;
 	dev-&gt;hard_header_len	= AX25_MAX_HEADER_LEN;
 	dev-&gt;header_ops 	= &amp;ax25_header_ops;</pre><hr><pre>commit 0b9111922b1f399aba6ed1e1b8f2079c3da1aed8
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Mon Nov 8 18:37:59 2021 +0800

    hamradio: defer 6pack kfree after unregister_netdev
    
    There is a possible race condition (use-after-free) like below
    
     (USE)                       |  (FREE)
      dev_queue_xmit             |
       __dev_queue_xmit          |
        __dev_xmit_skb           |
         sch_direct_xmit         | ...
          xmit_one               |
           netdev_start_xmit     | tty_ldisc_kill
            __netdev_start_xmit  |  6pack_close
             sp_xmit             |   kfree
              sp_encaps          |
                                 |
    
    According to the patch "defer ax25 kfree after unregister_netdev", this
    patch reorder the kfree after the unregister_netdev to avoid the possible
    UAF as the unregister_netdev() is well synchronized and won't return if
    there is a running routine.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index f4e8793e995d..fb0a3825edd0 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -672,11 +672,13 @@ static void sixpack_close(struct tty_struct *tty)
 	del_timer_sync(&amp;sp-&gt;tx_t);
 	del_timer_sync(&amp;sp-&gt;resync_t);
 
-	/* Free all 6pack frame buffers. */
+	unregister_netdev(sp-&gt;dev);
+
+	/* Free all 6pack frame buffers after unreg. */
 	kfree(sp-&gt;rbuff);
 	kfree(sp-&gt;xbuff);
 
-	unregister_netdev(sp-&gt;dev);
+	free_netdev(sp-&gt;dev);
 }
 
 /* Perform I/O control on an active 6pack channel. */</pre><hr><pre>commit 3e0588c291d6ce225f2b891753ca41d45ba42469
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Mon Nov 8 18:37:21 2021 +0800

    hamradio: defer ax25 kfree after unregister_netdev
    
    There is a possible race condition (use-after-free) like below
    
     (USE)                       |  (FREE)
    ax25_sendmsg                 |
     ax25_queue_xmit             |
      dev_queue_xmit             |
       __dev_queue_xmit          |
        __dev_xmit_skb           |
         sch_direct_xmit         | ...
          xmit_one               |
           netdev_start_xmit     | tty_ldisc_kill
            __netdev_start_xmit  |  mkiss_close
             ax_xmit             |   kfree
              ax_encaps          |
                                 |
    
    Even though there are two synchronization primitives before the kfree:
    1. wait_for_completion(&amp;ax-&gt;dead). This can prevent the race with
    routines from mkiss_ioctl. However, it cannot stop the routine coming
    from upper layer, i.e., the ax25_sendmsg.
    
    2. netif_stop_queue(ax-&gt;dev). It seems that this line of code aims to
    halt the transmit queue but it fails to stop the routine that already
    being xmit.
    
    This patch reorder the kfree after the unregister_netdev to avoid the
    possible UAF as the unregister_netdev() is well synchronized and won't
    return if there is a running routine.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index 867252a0247b..e2b332b54f06 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -792,13 +792,14 @@ static void mkiss_close(struct tty_struct *tty)
 	 */
 	netif_stop_queue(ax-&gt;dev);
 
-	/* Free all AX25 frame buffers. */
-	kfree(ax-&gt;rbuff);
-	kfree(ax-&gt;xbuff);
-
 	ax-&gt;tty = NULL;
 
 	unregister_netdev(ax-&gt;dev);
+
+	/* Free all AX25 frame buffers after unreg. */
+	kfree(ax-&gt;rbuff);
+	kfree(ax-&gt;xbuff);
+
 	free_netdev(ax-&gt;dev);
 }
 </pre><hr><pre>commit aedddb4e45b34426cfbfa84454b6f203712733c5
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Nov 2 16:10:21 2021 +0800

    NFC: add necessary privilege flags in netlink layer
    
    The CAP_NET_ADMIN checks are needed to prevent attackers faking a
    device under NCIUARTSETDRIVER and exploit privileged commands.
    
    This patch add GENL_ADMIN_PERM flags in genl_ops to fulfill the check.
    Except for commands like NFC_CMD_GET_DEVICE, NFC_CMD_GET_TARGET,
    NFC_CMD_LLC_GET_PARAMS, and NFC_CMD_GET_SE, which are mainly information-
    read operations.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/nfc/netlink.c b/net/nfc/netlink.c
index 49089c50872e..334f63c9529e 100644
--- a/net/nfc/netlink.c
+++ b/net/nfc/netlink.c
@@ -1664,31 +1664,37 @@ static const struct genl_ops nfc_genl_ops[] = {
 		.cmd = NFC_CMD_DEV_UP,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_dev_up,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_DEV_DOWN,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_dev_down,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_START_POLL,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_start_poll,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_STOP_POLL,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_stop_poll,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_DEP_LINK_UP,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_dep_link_up,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_DEP_LINK_DOWN,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_dep_link_down,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_GET_TARGET,
@@ -1706,26 +1712,31 @@ static const struct genl_ops nfc_genl_ops[] = {
 		.cmd = NFC_CMD_LLC_SET_PARAMS,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_llc_set_params,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_LLC_SDREQ,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_llc_sdreq,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_FW_DOWNLOAD,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_fw_download,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_ENABLE_SE,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_enable_se,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_DISABLE_SE,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_disable_se,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_GET_SE,
@@ -1737,21 +1748,25 @@ static const struct genl_ops nfc_genl_ops[] = {
 		.cmd = NFC_CMD_SE_IO,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_se_io,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_ACTIVATE_TARGET,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_activate_target,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_VENDOR,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_vendor_cmd,
+		.flags = GENL_ADMIN_PERM,
 	},
 	{
 		.cmd = NFC_CMD_DEACTIVATE_TARGET,
 		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
 		.doit = nfc_genl_deactivate_target,
+		.flags = GENL_ADMIN_PERM,
 	},
 };
 </pre><hr><pre>commit 1b1499a817c90fd1ce9453a2c98d2a01cca0e775
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Oct 7 19:44:30 2021 +0200

    nfc: nci: fix the UAF of rf_conn_info object
    
    The nci_core_conn_close_rsp_packet() function will release the conn_info
    with given conn_id. However, it needs to set the rf_conn_info to NULL to
    prevent other routines like nci_rf_intf_activated_ntf_packet() to trigger
    the UAF.
    
    Reviewed-by: Krzysztof Kozlowski &lt;krzysztof.kozlowski@canonical.com&gt;
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: Krzysztof Kozlowski &lt;krzysztof.kozlowski@canonical.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/nfc/nci/rsp.c b/net/nfc/nci/rsp.c
index a2e72c003805..b911ab78bed9 100644
--- a/net/nfc/nci/rsp.c
+++ b/net/nfc/nci/rsp.c
@@ -334,6 +334,8 @@ static void nci_core_conn_close_rsp_packet(struct nci_dev *ndev,
 							 ndev-&gt;cur_conn_id);
 		if (conn_info) {
 			list_del(&amp;conn_info-&gt;list);
+			if (conn_info == ndev-&gt;rf_conn_info)
+				ndev-&gt;rf_conn_info = NULL;
 			devm_kfree(&amp;ndev-&gt;nfc_dev-&gt;dev, conn_info);
 		}
 	}</pre><hr><pre>commit 3e5f2d90c28f9454e421108554707620bc23269d
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Wed Sep 22 21:49:45 2021 +0800

    Bluetooth: btmtkuart: fix a memleak in mtk_hci_wmt_sync
    
    bdev-&gt;evt_skb will get freed in the normal path and one error path
    of mtk_hci_wmt_sync, while the other error paths do not free it,
    which may cause a memleak. This bug is suggested by a static analysis
    tool, please advise.
    
    Fixes: e0b67035a90b ("Bluetooth: mediatek: update the common setup between MT7622 and other devices")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Marcel Holtmann &lt;marcel@holtmann.org&gt;

diff --git a/drivers/bluetooth/btmtkuart.c b/drivers/bluetooth/btmtkuart.c
index e9d91d7c0db4..9ba22b13b4fa 100644
--- a/drivers/bluetooth/btmtkuart.c
+++ b/drivers/bluetooth/btmtkuart.c
@@ -158,8 +158,10 @@ static int mtk_hci_wmt_sync(struct hci_dev *hdev,
 	int err;
 
 	hlen = sizeof(*hdr) + wmt_params-&gt;dlen;
-	if (hlen &gt; 255)
-		return -EINVAL;
+	if (hlen &gt; 255) {
+		err = -EINVAL;
+		goto err_free_skb;
+	}
 
 	hdr = (struct mtk_wmt_hdr *)&amp;wc;
 	hdr-&gt;dir = 1;
@@ -173,7 +175,7 @@ static int mtk_hci_wmt_sync(struct hci_dev *hdev,
 	err = __hci_cmd_send(hdev, 0xfc6f, hlen, &amp;wc);
 	if (err &lt; 0) {
 		clear_bit(BTMTKUART_TX_WAIT_VND_EVT, &amp;bdev-&gt;tx_state);
-		return err;
+		goto err_free_skb;
 	}
 
 	/* The vendor specific WMT commands are all answered by a vendor
@@ -190,13 +192,14 @@ static int mtk_hci_wmt_sync(struct hci_dev *hdev,
 	if (err == -EINTR) {
 		bt_dev_err(hdev, "Execution of wmt command interrupted");
 		clear_bit(BTMTKUART_TX_WAIT_VND_EVT, &amp;bdev-&gt;tx_state);
-		return err;
+		goto err_free_skb;
 	}
 
 	if (err) {
 		bt_dev_err(hdev, "Execution of wmt command timed out");
 		clear_bit(BTMTKUART_TX_WAIT_VND_EVT, &amp;bdev-&gt;tx_state);
-		return -ETIMEDOUT;
+		err = -ETIMEDOUT;
+		goto err_free_skb;
 	}
 
 	/* Parse and handle the return WMT event */</pre><hr><pre>commit 9ddbc2a00d7f63fa9748f4278643193dac985f2d
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Fri Sep 3 15:35:43 2021 +0800

    qlcnic: Remove redundant unlock in qlcnic_pinit_from_rom
    
    Previous commit 68233c583ab4 removes the qlcnic_rom_lock()
    in qlcnic_pinit_from_rom(), but remains its corresponding
    unlock function, which is odd. I'm not very sure whether the
    lock is missing, or the unlock is redundant. This bug is
    suggested by a static analysis tool, please advise.
    
    Fixes: 68233c583ab4 ("qlcnic: updated reset sequence")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c
index 3d61a767a8a3..09f20c794754 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_init.c
@@ -437,7 +437,6 @@ int qlcnic_pinit_from_rom(struct qlcnic_adapter *adapter)
 	QLCWR32(adapter, QLCNIC_CRB_PEG_NET_4 + 0x3c, 1);
 	msleep(20);
 
-	qlcnic_rom_unlock(adapter);
 	/* big hammer don't reset CAM block on reset */
 	QLCWR32(adapter, QLCNIC_ROMUSB_GLB_SW_RESET, 0xfeffffff);
 </pre><hr><pre>commit a036ad088306a88de87e973981f2b9224e466c3f
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Aug 16 16:55:31 2021 +0800

    RDMA/bnxt_re: Remove unpaired rtnl unlock in bnxt_re_dev_init()
    
    The fixed commit removes all rtnl_lock() and rtnl_unlock() calls in
    function bnxt_re_dev_init(), but forgets to remove a rtnl_unlock() in the
    error handling path of bnxt_re_register_netdev(), which may cause a
    deadlock. This bug is suggested by a static analysis tool.
    
    Fixes: c2b777a95923 ("RDMA/bnxt_re: Refactor device add/remove functionalities")
    Link: https://lore.kernel.org/r/20210816085531.12167-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Acked-by: Selvin Xavier &lt;selvin.xavier@broadcom.com&gt;
    Reviewed-by: Jason Gunthorpe &lt;jgg@nvidia.com&gt;
    Signed-off-by: Jason Gunthorpe &lt;jgg@nvidia.com&gt;

diff --git a/drivers/infiniband/hw/bnxt_re/main.c b/drivers/infiniband/hw/bnxt_re/main.c
index a8688a92c760..4678bd6ec7d6 100644
--- a/drivers/infiniband/hw/bnxt_re/main.c
+++ b/drivers/infiniband/hw/bnxt_re/main.c
@@ -1397,7 +1397,6 @@ static int bnxt_re_dev_init(struct bnxt_re_dev *rdev, u8 wqe_mode)
 	memset(&amp;rattr, 0, sizeof(rattr));
 	rc = bnxt_re_register_netdev(rdev);
 	if (rc) {
-		rtnl_unlock();
 		ibdev_err(&amp;rdev-&gt;ibdev,
 			  "Failed to register with netedev: %#x\n", rc);
 		return -EINVAL;</pre>
    <div class="pagination">
        <a href='6_20.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><span>[21]</span><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_22.html'>Next&gt;&gt;</a>
    <div>
</body>
