<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_2.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><span>[3]</span><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_4.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 3ad53c40902005c50122be34e2b60dd763314180
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Sep 19 10:51:05 2018 -0600

    staging: comedi: ni_pcidio: implement INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    
    Adds implementation of the new INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    instruction.  This patch also adds data for this implementation, based on
    spec sheets from NI.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_pcidio.c b/drivers/staging/comedi/drivers/ni_pcidio.c
index 6692af5ff79b..b9a0dc6eac44 100644
--- a/drivers/staging/comedi/drivers/ni_pcidio.c
+++ b/drivers/staging/comedi/drivers/ni_pcidio.c
@@ -260,18 +260,22 @@ enum nidio_boardid {
 struct nidio_board {
 	const char *name;
 	unsigned int uses_firmware:1;
+	unsigned int dio_speed;
 };
 
 static const struct nidio_board nidio_boards[] = {
 	[BOARD_PCIDIO_32HS] = {
 		.name		= "pci-dio-32hs",
+		.dio_speed	= 50,
 	},
 	[BOARD_PXI6533] = {
 		.name		= "pxi-6533",
+		.dio_speed	= 50,
 	},
 	[BOARD_PCI6534] = {
 		.name		= "pci-6534",
 		.uses_firmware	= 1,
+		.dio_speed	= 50,
 	},
 };
 
@@ -467,6 +471,15 @@ static int ni_pcidio_insn_config(struct comedi_device *dev,
 {
 	int ret;
 
+	if (data[0] == INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS) {
+		const struct nidio_board *board = dev-&gt;board_ptr;
+
+		/* we don't care about actual channels */
+		data[1] = board-&gt;dio_speed;
+		data[2] = 0;
+		return 0;
+	}
+
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
 	if (ret)
 		return ret;</pre><hr><pre>commit 51fd3673838396844f15de0e906be5333bfbbc8d
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Sep 19 10:51:04 2018 -0600

    staging: comedi: ni_mio_common: implement INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    
    Adds implementation of the new INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    instruction.  This patch also adds data for digital subdevices that are
    streaming capable (within the ni_mio_* family).  Mostly, only the m-series
    devices are capable of digital streaming.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 44fcb3790113..961ea97966f5 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2464,6 +2464,7 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			     struct comedi_subdevice *s,
 			     struct comedi_insn *insn, unsigned int *data)
 {
+	const struct ni_board_struct *board = dev-&gt;board_ptr;
 	struct ni_private *devpriv = dev-&gt;private;
 
 	if (insn-&gt;n &lt; 1)
@@ -2498,6 +2499,15 @@ static int ni_ai_insn_config(struct comedi_device *dev,
 			}
 		}
 		return 2;
+	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
+		/* we don't care about actual channels */
+		/* data[3] : chanlist_len */
+		data[1] = ni_min_ai_scan_period_ns(dev, data[3]);
+		if (devpriv-&gt;is_611x || devpriv-&gt;is_6143)
+			data[2] = 0; /* simultaneous output */
+		else
+			data[2] = board-&gt;ai_speed;
+		return 0;
 	default:
 		break;
 	}
@@ -2834,6 +2844,11 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 		return 0;
 	case INSN_CONFIG_ARM:
 		return ni_ao_arm(dev, s);
+	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
+		/* we don't care about actual channels */
+		data[1] = board-&gt;ao_speed;
+		data[2] = 0;
+		return 0;
 	default:
 		break;
 	}
@@ -3475,6 +3490,15 @@ static int ni_m_series_dio_insn_config(struct comedi_device *dev,
 {
 	int ret;
 
+	if (data[0] == INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS) {
+		const struct ni_board_struct *board = dev-&gt;board_ptr;
+
+		/* we don't care about actual channels */
+		data[1] = board-&gt;dio_speed;
+		data[2] = 0;
+		return 0;
+	}
+
 	ret = comedi_dio_insn_config(dev, s, insn, data, 0);
 	if (ret)
 		return ret;
diff --git a/drivers/staging/comedi/drivers/ni_pcimio.c b/drivers/staging/comedi/drivers/ni_pcimio.c
index f9e466d18b3f..14b26fffe049 100644
--- a/drivers/staging/comedi/drivers/ni_pcimio.c
+++ b/drivers/staging/comedi/drivers/ni_pcimio.c
@@ -693,6 +693,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ai_speed	= 4000,
 		.reg_type	= ni_reg_622x,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PCI6221] = {
 		.name		= "pci-6221",
@@ -708,6 +709,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_622x,
 		.ao_speed	= 1200,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PCI6221_37PIN] = {
 		.name		= "pci-6221_37pin",
@@ -738,6 +740,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_622x,
 		.ao_speed	= 1200,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PCI6224] = {
 		.name		= "pci-6224",
@@ -749,6 +752,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_622x,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PXI6224] = {
 		.name		= "pxi-6224",
@@ -760,6 +764,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_622x,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PCI6225] = {
 		.name		= "pci-6225",
@@ -776,6 +781,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ao_speed	= 1200,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PXI6225] = {
 		.name		= "pxi-6225",
@@ -792,6 +798,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ao_speed	= 1200,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PCI6229] = {
 		.name		= "pci-6229",
@@ -824,6 +831,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ao_speed	= 1200,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 1000,
 	},
 	[BOARD_PCI6250] = {
 		.name		= "pci-6250",
@@ -844,6 +852,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ai_speed	= 800,
 		.reg_type	= ni_reg_625x,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6251] = {
 		.name		= "pci-6251",
@@ -859,6 +868,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_625x,
 		.ao_speed	= 350,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PXI6251] = {
 		.name		= "pxi-6251",
@@ -874,6 +884,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_625x,
 		.ao_speed	= 350,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCIE6251] = {
 		.name		= "pcie-6251",
@@ -889,6 +900,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_625x,
 		.ao_speed	= 350,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PXIE6251] = {
 		.name		= "pxie-6251",
@@ -904,6 +916,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_625x,
 		.ao_speed	= 350,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6254] = {
 		.name		= "pci-6254",
@@ -926,6 +939,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_625x,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6259] = {
 		.name		= "pci-6259",
@@ -958,6 +972,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ao_speed	= 350,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCIE6259] = {
 		.name		= "pcie-6259",
@@ -990,6 +1005,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ao_speed	= 350,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6280] = {
 		.name		= "pci-6280",
@@ -1012,6 +1028,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ao_fifo_depth	= 8191,
 		.reg_type	= ni_reg_628x,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6281] = {
 		.name		= "pci-6281",
@@ -1027,6 +1044,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_628x,
 		.ao_speed	= 350,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PXI6281] = {
 		.name		= "pxi-6281",
@@ -1042,6 +1060,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_628x,
 		.ao_speed	= 350,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6284] = {
 		.name		= "pci-6284",
@@ -1064,6 +1083,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.reg_type	= ni_reg_628x,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6289] = {
 		.name		= "pci-6289",
@@ -1096,6 +1116,7 @@ static const struct ni_board_struct ni_boards[] = {
 		.ao_speed	= 350,
 		.has_32dio_chan	= 1,
 		.caldac		= { caldac_none },
+		.dio_speed	= 100,
 	},
 	[BOARD_PCI6143] = {
 		.name		= "pci-6143",
diff --git a/drivers/staging/comedi/drivers/ni_stc.h b/drivers/staging/comedi/drivers/ni_stc.h
index 831088c5cabb..1c6bd25da962 100644
--- a/drivers/staging/comedi/drivers/ni_stc.h
+++ b/drivers/staging/comedi/drivers/ni_stc.h
@@ -953,6 +953,7 @@ struct ni_board_struct {
 	int reg_type;
 	unsigned int has_8255:1;
 	unsigned int has_32dio_chan:1;
+	unsigned int dio_speed; /* not for e-series */
 
 	enum caldac_enum caldac[3];
 };</pre><hr><pre>commit 832f33366c771855951313a9bab4926f2a0d37a1
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Sep 19 10:51:03 2018 -0600

    staging: comedi: add facility to directly query subdevice timing constraints
    
    Adds facility to directly query the hardware speed limits of subdevices,
    in particular for scan_begin and convert signals.  This information can be
    critical for integrating comedi with other hardware modules, and also
    comedi modules together with software where software requires specific
    timing capabilities in order to properly coordinate multiple devices.
    
    Currently, comedi_command_test almost satisfies this need, but really only
    for when *_src == TRIG_TIMER.  For *_src == TRIG_EXT, comedi_command_test
    does not help at all.  For many subdevices, one might simply use
    *_src==TRIG_TIMER in command_test in order to determine these limits.  For
    other subdevices, this tactic does not work since *_src == TRIG_TIMER might
    not be valid.  There is also the possibility that the timing limits are
    different between the TRIG_TIMER and TRIG_EXT modes.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/comedi.h b/drivers/staging/comedi/comedi.h
index bb961ac79b7e..cf7b2b970327 100644
--- a/drivers/staging/comedi/comedi.h
+++ b/drivers/staging/comedi/comedi.h
@@ -301,6 +301,8 @@ enum comedi_io_direction {
  * @INSN_CONFIG_PWM_SET_H_BRIDGE: Set PWM H bridge duty cycle and polarity for
  *				a relay simultaneously.
  * @INSN_CONFIG_PWM_GET_H_BRIDGE: Get PWM H bridge duty cycle and polarity.
+ * @INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS: Get the hardware timing restraints,
+ *				regardless of trigger sources.
  */
 enum configuration_ids {
 	INSN_CONFIG_DIO_INPUT = COMEDI_INPUT,
@@ -344,7 +346,8 @@ enum configuration_ids {
 	INSN_CONFIG_PWM_GET_PERIOD = 5001,
 	INSN_CONFIG_GET_PWM_STATUS = 5002,
 	INSN_CONFIG_PWM_SET_H_BRIDGE = 5003,
-	INSN_CONFIG_PWM_GET_H_BRIDGE = 5004
+	INSN_CONFIG_PWM_GET_H_BRIDGE = 5004,
+	INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS = 5005,
 };
 
 /**
diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index e18b61cdbdeb..548baa790507 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1216,6 +1216,10 @@ static int check_insn_config_length(struct comedi_insn *insn,
 		if (insn-&gt;n == 6)
 			return 0;
 		break;
+	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
+		if (insn-&gt;n &gt;= 4)
+			return 0;
+		break;
 		/*
 		 * by default we allow the insn since we don't have checks for
 		 * all possible cases yet</pre><hr><pre>commit 1cbca5852d6c16e85a21487a15d211195aacd4a1
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Oct 3 14:54:16 2018 -0600

    staging: comedi: ni_mio_common: protect register write overflow
    
    Fixes two problems introduced as early as
    commit 03aef4b6dc12  ("Staging: comedi: add ni_mio_common code"):
    (1) Ensures that the last four bits of NISTC_RTSI_TRIGB_OUT_REG register is
        not unduly overwritten on e-series devices.  On e-series devices, the
        first three of the last four bits are reserved.  The last bit defines
        the output selection of the RGOUT0 pin, otherwise known as
        RTSI_Sub_Selection.  For m-series devices, these last four bits are
        indeed used as the output selection of the RTSI7 pin (and the
        RTSI_Sub_Selection bit for the RGOUT0 pin is moved to the
        RTSI_Trig_Direction register.
    (2) Allows all 4 RTSI_BRD lines to be treated as valid sources for RTSI
        lines.
    
    This patch also cleans up the ni_get_rtsi_routing command for readability.
    
    Fixes: 03aef4b6dc12  ("Staging: comedi: add ni_mio_common code")
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 4dee2fc37aed..44fcb3790113 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -4980,7 +4980,10 @@ static int ni_valid_rtsi_output_source(struct comedi_device *dev,
 	case NI_RTSI_OUTPUT_G_SRC0:
 	case NI_RTSI_OUTPUT_G_GATE0:
 	case NI_RTSI_OUTPUT_RGOUT0:
-	case NI_RTSI_OUTPUT_RTSI_BRD_0:
+	case NI_RTSI_OUTPUT_RTSI_BRD(0):
+	case NI_RTSI_OUTPUT_RTSI_BRD(1):
+	case NI_RTSI_OUTPUT_RTSI_BRD(2):
+	case NI_RTSI_OUTPUT_RTSI_BRD(3):
 		return 1;
 	case NI_RTSI_OUTPUT_RTSI_OSC:
 		return (devpriv-&gt;is_m_series) ? 1 : 0;
@@ -5001,11 +5004,18 @@ static int ni_set_rtsi_routing(struct comedi_device *dev,
 		devpriv-&gt;rtsi_trig_a_output_reg |= NISTC_RTSI_TRIG(chan, src);
 		ni_stc_writew(dev, devpriv-&gt;rtsi_trig_a_output_reg,
 			      NISTC_RTSI_TRIGA_OUT_REG);
-	} else if (chan &lt; 8) {
+	} else if (chan &lt; NISTC_RTSI_TRIG_NUM_CHAN(devpriv-&gt;is_m_series)) {
 		devpriv-&gt;rtsi_trig_b_output_reg &amp;= ~NISTC_RTSI_TRIG_MASK(chan);
 		devpriv-&gt;rtsi_trig_b_output_reg |= NISTC_RTSI_TRIG(chan, src);
 		ni_stc_writew(dev, devpriv-&gt;rtsi_trig_b_output_reg,
 			      NISTC_RTSI_TRIGB_OUT_REG);
+	} else if (chan != NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
+		/* probably should never reach this, since the
+		 * ni_valid_rtsi_output_source above errors out if chan is too
+		 * high
+		 */
+		dev_err(dev-&gt;class_dev, "%s: unknown rtsi channel\n", __func__);
+		return -EINVAL;
 	}
 	return 2;
 }
@@ -5021,12 +5031,12 @@ static unsigned int ni_get_rtsi_routing(struct comedi_device *dev,
 	} else if (chan &lt; NISTC_RTSI_TRIG_NUM_CHAN(devpriv-&gt;is_m_series)) {
 		return NISTC_RTSI_TRIG_TO_SRC(chan,
 					      devpriv-&gt;rtsi_trig_b_output_reg);
-	} else {
-		if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN)
-			return NI_RTSI_OUTPUT_RTSI_OSC;
-		dev_err(dev-&gt;class_dev, "bug! should never get here?\n");
-		return 0;
+	} else if (chan == NISTC_RTSI_TRIG_OLD_CLK_CHAN) {
+		return NI_RTSI_OUTPUT_RTSI_OSC;
 	}
+
+	dev_err(dev-&gt;class_dev, "%s: unknown rtsi channel\n", __func__);
+	return -EINVAL;
 }
 
 static int ni_rtsi_insn_config(struct comedi_device *dev,</pre><hr><pre>commit f515f86b34b2e7d4b24cc9b7375c9e749895088e
Author: Olga Kornievskaia &lt;aglo@umich.edu&gt;
Date:   Thu Jun 29 09:25:36 2017 -0400

    fix parallelism for rpc tasks
    
    Hi folks,
    
    On a multi-core machine, is it expected that we can have parallel RPCs
    handled by each of the per-core workqueue?
    
    In testing a read workload, observing via "top" command that a single
    "kworker" thread is running servicing the requests (no parallelism).
    It's more prominent while doing these operations over krb5p mount.
    
    What has been suggested by Bruce is to try this and in my testing I
    see then the read workload spread among all the kworker threads.
    
    Signed-off-by: Olga Kornievskaia &lt;kolga@netapp.com&gt;
    Signed-off-by: Trond Myklebust &lt;trond.myklebust@primarydata.com&gt;

diff --git a/net/sunrpc/sched.c b/net/sunrpc/sched.c
index 25e6051e97f2..d9db2eab3a8d 100644
--- a/net/sunrpc/sched.c
+++ b/net/sunrpc/sched.c
@@ -1104,7 +1104,7 @@ static int rpciod_start(void)
 	 * Create the rpciod thread and wait for it to start.
 	 */
 	dprintk("RPC:       creating workqueue rpciod\n");
-	wq = alloc_workqueue("rpciod", WQ_MEM_RECLAIM, 0);
+	wq = alloc_workqueue("rpciod", WQ_MEM_RECLAIM | WQ_UNBOUND, 0);
 	if (!wq)
 		goto out_failed;
 	rpciod_workqueue = wq;</pre><hr><pre>commit 05b7278d510a6a1c23624caee5b0a9667a72e745
Author: Olga Kornievskaia &lt;aglo@umich.edu&gt;
Date:   Thu Mar 23 14:36:20 2017 -0400

    nfsd: fix oops on unsupported operation
    
    I'm hitting the BUG in nfsd4_max_reply() at fs/nfsd/nfs4proc.c:2495 when
    client sends an operation the server doesn't support.
    
    in nfsd4_max_reply() it checks for NULL rsize_bop but a non-supported
    operation wouldn't have that set.
    
    Cc: Kinglong Mee &lt;kinglongmee@gmail.com&gt;
    Fixes: 2282cd2c05e2 "NFSD: Get response size before operation..."
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index cbeeda1e94a2..d86031b6ad79 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -2489,7 +2489,7 @@ bool nfsd4_spo_must_allow(struct svc_rqst *rqstp)
 
 int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)
 {
-	if (op-&gt;opnum == OP_ILLEGAL)
+	if (op-&gt;opnum == OP_ILLEGAL || op-&gt;status == nfserr_notsupp)
 		return op_encode_hdr_size * sizeof(__be32);
 
 	BUG_ON(OPDESC(op)-&gt;op_rsize_bop == NULL);</pre><hr><pre>commit 1ffe8bdc09f8bfcaad76d71ae68b623c7e03f20f
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Mon Oct 10 08:14:19 2016 -0600

    staging: comedi: ni_mio_common: split out ao arming from ni_ao_inttrig
    
    AO device arming was previously done as a part of ni_ao_inttrig which is
    called as a result of the user calling comedi_internal_trigger.  For
    start_src == TRIG_EXT, this does not make very much sense since external
    triggers should not conceptually need to be software triggered also.  This
    patch splits out the arming functionality to allow arming to specifically
    and separately be done via the CONFIG_INSN_ARM ioctl command.
    
    In order to provide backwards compatibility, this patch also provides
    automatic arming if ni_ao_inttrig is simply called.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 0f97d7b611d7..9812508fe8d3 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2729,66 +2729,36 @@ static int ni_ao_insn_write(struct comedi_device *dev,
 	return insn-&gt;n;
 }
 
-static int ni_ao_insn_config(struct comedi_device *dev,
-			     struct comedi_subdevice *s,
-			     struct comedi_insn *insn, unsigned int *data)
-{
-	const struct ni_board_struct *board = dev-&gt;board_ptr;
-	struct ni_private *devpriv = dev-&gt;private;
-	unsigned int nbytes;
-
-	switch (data[0]) {
-	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
-		switch (data[1]) {
-		case COMEDI_OUTPUT:
-			nbytes = comedi_samples_to_bytes(s,
-							 board-&gt;ao_fifo_depth);
-			data[2] = 1 + nbytes;
-			if (devpriv-&gt;mite)
-				data[2] += devpriv-&gt;mite-&gt;fifo_size;
-			break;
-		case COMEDI_INPUT:
-			data[2] = 0;
-			break;
-		default:
-			return -EINVAL;
-		}
-		return 0;
-	default:
-		break;
-	}
-
-	return -EINVAL;
-}
-
-static int ni_ao_inttrig(struct comedi_device *dev,
-			 struct comedi_subdevice *s,
-			 unsigned int trig_num)
+/*
+ * Arms the AO device in preparation for a trigger event.
+ * This function also allocates and prepares a DMA channel (or FIFO if DMA is
+ * not used).  As a part of this preparation, this function preloads the DAC
+ * registers with the first values of the output stream.  This ensures that the
+ * first clock cycle after the trigger can be used for output.
+ *
+ * Note that this function _must_ happen after a user has written data to the
+ * output buffers via either mmap or write(fileno,...).
+ */
+static int ni_ao_arm(struct comedi_device *dev,
+		     struct comedi_subdevice *s)
 {
 	struct ni_private *devpriv = dev-&gt;private;
-	struct comedi_cmd *cmd = &amp;s-&gt;async-&gt;cmd;
 	int ret;
 	int interrupt_b_bits;
 	int i;
 	static const int timeout = 1000;
 
 	/*
-	 * Require trig_num == cmd-&gt;start_arg when cmd-&gt;start_src == TRIG_INT.
-	 * For backwards compatibility, also allow trig_num == 0 when
-	 * cmd-&gt;start_src != TRIG_INT (i.e. when cmd-&gt;start_src == TRIG_EXT);
-	 * in that case, the internal trigger is being used as a pre-trigger
-	 * before the external trigger.
+	 * Prevent ao from doing things like trying to allocate the ao dma
+	 * channel multiple times.
 	 */
-	if (!(trig_num == cmd-&gt;start_arg ||
-	      (trig_num == 0 &amp;&amp; cmd-&gt;start_src != TRIG_INT)))
+	if (!devpriv-&gt;ao_needs_arming) {
+		dev_dbg(dev-&gt;class_dev, "%s: device does not need arming!\n",
+			__func__);
 		return -EINVAL;
+	}
 
-	/*
-	 * Null trig at beginning prevent ao start trigger from executing more
-	 * than once per command (and doing things like trying to allocate the
-	 * ao dma channel multiple times).
-	 */
-	s-&gt;async-&gt;inttrig = NULL;
+	devpriv-&gt;ao_needs_arming = 0;
 
 	ni_set_bits(dev, NISTC_INTB_ENA_REG,
 		    NISTC_INTB_ENA_AO_FIFO | NISTC_INTB_ENA_AO_ERR, 0);
@@ -2840,6 +2810,75 @@ static int ni_ao_inttrig(struct comedi_device *dev,
 			   devpriv-&gt;ao_cmd1,
 		      NISTC_AO_CMD1_REG);
 
+	return 0;
+}
+
+static int ni_ao_insn_config(struct comedi_device *dev,
+			     struct comedi_subdevice *s,
+			     struct comedi_insn *insn, unsigned int *data)
+{
+	const struct ni_board_struct *board = dev-&gt;board_ptr;
+	struct ni_private *devpriv = dev-&gt;private;
+	unsigned int nbytes;
+
+	switch (data[0]) {
+	case INSN_CONFIG_GET_HARDWARE_BUFFER_SIZE:
+		switch (data[1]) {
+		case COMEDI_OUTPUT:
+			nbytes = comedi_samples_to_bytes(s,
+							 board-&gt;ao_fifo_depth);
+			data[2] = 1 + nbytes;
+			if (devpriv-&gt;mite)
+				data[2] += devpriv-&gt;mite-&gt;fifo_size;
+			break;
+		case COMEDI_INPUT:
+			data[2] = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+		return 0;
+	case INSN_CONFIG_ARM:
+		return ni_ao_arm(dev, s);
+	default:
+		break;
+	}
+
+	return -EINVAL;
+}
+
+static int ni_ao_inttrig(struct comedi_device *dev,
+			 struct comedi_subdevice *s,
+			 unsigned int trig_num)
+{
+	struct ni_private *devpriv = dev-&gt;private;
+	struct comedi_cmd *cmd = &amp;s-&gt;async-&gt;cmd;
+	int ret;
+
+	/*
+	 * Require trig_num == cmd-&gt;start_arg when cmd-&gt;start_src == TRIG_INT.
+	 * For backwards compatibility, also allow trig_num == 0 when
+	 * cmd-&gt;start_src != TRIG_INT (i.e. when cmd-&gt;start_src == TRIG_EXT);
+	 * in that case, the internal trigger is being used as a pre-trigger
+	 * before the external trigger.
+	 */
+	if (!(trig_num == cmd-&gt;start_arg ||
+	      (trig_num == 0 &amp;&amp; cmd-&gt;start_src != TRIG_INT)))
+		return -EINVAL;
+
+	/*
+	 * Null trig at beginning prevent ao start trigger from executing more
+	 * than once per command.
+	 */
+	s-&gt;async-&gt;inttrig = NULL;
+
+	if (devpriv-&gt;ao_needs_arming) {
+		/* only arm this device if it still needs arming */
+		ret = ni_ao_arm(dev, s);
+		if (ret)
+			return ret;
+	}
+
 	ni_stc_writew(dev, NISTC_AO_CMD2_START1_PULSE | devpriv-&gt;ao_cmd2,
 		      NISTC_AO_CMD2_REG);
 
@@ -3227,10 +3266,17 @@ static int ni_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	ni_ao_cmd_set_interrupts(dev, s);
 
 	/*
-	 * arm(ing) and star(ting) happen in ni_ao_inttrig, which _must_ be
-	 * called for ao commands since 1) TRIG_NOW is not supported and 2) DMA
-	 * must be setup and initially written to before arm/start happen.
+	 * arm(ing) must happen later so that DMA can be setup and DACs
+	 * preloaded with the actual output buffer before starting.
+	 *
+	 * start(ing) must happen _after_ arming is completed.  Starting can be
+	 * done either via ni_ao_inttrig, or via an external trigger.
+	 *
+	 * **Currently, ni_ao_inttrig will automatically attempt a call to
+	 * ni_ao_arm if the device still needs arming at that point.  This
+	 * allows backwards compatibility.
 	 */
+	devpriv-&gt;ao_needs_arming = 1;
 	return 0;
 }
 
diff --git a/drivers/staging/comedi/drivers/ni_stc.h b/drivers/staging/comedi/drivers/ni_stc.h
index 1966519cb6e5..f27b545f83eb 100644
--- a/drivers/staging/comedi/drivers/ni_stc.h
+++ b/drivers/staging/comedi/drivers/ni_stc.h
@@ -1053,6 +1053,20 @@ struct ni_private {
 	unsigned int is_67xx:1;
 	unsigned int is_6711:1;
 	unsigned int is_6713:1;
+
+	/*
+	 * Boolean value of whether device needs to be armed.
+	 *
+	 * Currently, only NI AO devices are known to be needing arming, since
+	 * the DAC registers must be preloaded before triggering.
+	 * This variable should only be set true during a command operation
+	 * (e.g ni_ao_cmd) and should then be set false by the arming
+	 * function (e.g. ni_ao_arm).
+	 *
+	 * This variable helps to ensure that multiple DMA allocations are not
+	 * possible.
+	 */
+	unsigned int ao_needs_arming:1;
 };
 
 static const struct comedi_lrange range_ni_E_ao_ext;</pre><hr><pre>commit cc7a6d6c4614bbf65d57dac31706fb01377d8371
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Sat Oct 8 15:38:43 2016 -0600

    staging: comedi: make constants slightly more consistent
    
    This makes INSN_CONFIG_DIO_{INPUT,OUTPUT,OPENDRAIN} simply be copies of the
    already-existing constants COMEDI_INPUT, COMEDI_OUTPUT, and
    COMEDI_OPENDRAIN.
    
    This change also ensures that if a user happens to use, for example,
    COMEDI_INPUT in place of where INSN_CONFIG_DIO_INPUT, the result will
    always be the same and also acceptable and correct usage.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/comedi.h b/drivers/staging/comedi/comedi.h
index a67ed578af5e..a1c1081906c5 100644
--- a/drivers/staging/comedi/comedi.h
+++ b/drivers/staging/comedi/comedi.h
@@ -244,6 +244,22 @@ enum comedi_subdevice_type {
 
 /* configuration instructions */
 
+/**
+ * enum comedi_io_direction - COMEDI I/O directions
+ * @COMEDI_INPUT:	Input.
+ * @COMEDI_OUTPUT:	Output.
+ * @COMEDI_OPENDRAIN:	Open-drain (or open-collector) output.
+ *
+ * These are used by the %INSN_CONFIG_DIO_QUERY configuration instruction to
+ * report a direction.  They may also be used in other places where a direction
+ * needs to be specified.
+ */
+enum comedi_io_direction {
+	COMEDI_INPUT = 0,
+	COMEDI_OUTPUT = 1,
+	COMEDI_OPENDRAIN = 2
+};
+
 /**
  * enum configuration_ids - COMEDI configuration instruction codes
  * @INSN_CONFIG_DIO_INPUT:	Configure digital I/O as input.
@@ -296,9 +312,9 @@ enum comedi_subdevice_type {
  * @INSN_CONFIG_PWM_GET_H_BRIDGE: Get PWM H bridge duty cycle and polarity.
  */
 enum configuration_ids {
-	INSN_CONFIG_DIO_INPUT = 0,
-	INSN_CONFIG_DIO_OUTPUT = 1,
-	INSN_CONFIG_DIO_OPENDRAIN = 2,
+	INSN_CONFIG_DIO_INPUT = COMEDI_INPUT,
+	INSN_CONFIG_DIO_OUTPUT = COMEDI_OUTPUT,
+	INSN_CONFIG_DIO_OPENDRAIN = COMEDI_OPENDRAIN,
 	INSN_CONFIG_ANALOG_TRIG = 16,
 /*	INSN_CONFIG_WAVEFORM = 17, */
 /*	INSN_CONFIG_TRIG = 18, */
@@ -396,22 +412,6 @@ enum comedi_digital_trig_op {
 	COMEDI_DIGITAL_TRIG_ENABLE_LEVELS = 2
 };
 
-/**
- * enum comedi_io_direction - COMEDI I/O directions
- * @COMEDI_INPUT:	Input.
- * @COMEDI_OUTPUT:	Output.
- * @COMEDI_OPENDRAIN:	Open-drain (or open-collector) output.
- *
- * These are used by the %INSN_CONFIG_DIO_QUERY configuration instruction to
- * report a direction.  They may also be used in other places where a direction
- * needs to be specified.
- */
-enum comedi_io_direction {
-	COMEDI_INPUT = 0,
-	COMEDI_OUTPUT = 1,
-	COMEDI_OPENDRAIN = 2
-};
-
 /**
  * enum comedi_support_level - support level for a COMEDI feature
  * @COMEDI_UNKNOWN_SUPPORT:	Unspecified support for feature.</pre><hr><pre>commit 5c53440daa050909e761ebcce8483b28fb163273
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Sat Oct 8 15:37:29 2016 -0600

    staging: comedi: porting NI_GPCT constants from comedi.org module
    
    Information pertaining to the NI_GPCT_ARM* registers were added to the
    comedi.org version of the comedi kernel.  This adds this information to
    the staging-tree version of the comedi kernel.  Relevant comments are also
    copied over.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/comedi.h b/drivers/staging/comedi/comedi.h
index 08fb26b51a5f..a67ed578af5e 100644
--- a/drivers/staging/comedi/comedi.h
+++ b/drivers/staging/comedi/comedi.h
@@ -1104,18 +1104,19 @@ enum ni_gpct_other_select {
 enum ni_gpct_arm_source {
 	NI_GPCT_ARM_IMMEDIATE = 0x0,
 	/*
-	 * Start both the counter and the adjacent pared
-	 * counter simultaneously
+	 * Start both the counter and the adjacent paired counter simultaneously
 	 */
 	NI_GPCT_ARM_PAIRED_IMMEDIATE = 0x1,
 	/*
-	 * NI doesn't document bits for selecting hardware arm triggers.
-	 * If the NI_GPCT_ARM_UNKNOWN bit is set, we will pass the least
-	 * significant bits (3 bits for 660x or 5 bits for m-series)
-	 * through to the hardware.  This will at least allow someone to
-	 * figure out what the bits do later.
+	 * If the NI_GPCT_HW_ARM bit is set, we will pass the least significant
+	 * bits (3 bits for 660x or 5 bits for m-series) through to the
+	 * hardware. To select a hardware trigger, pass the appropriate select
+	 * bit, e.g.,
+	 * NI_GPCT_HW_ARM | NI_GPCT_AI_START1_GATE_SELECT or
+	 * NI_GPCT_HW_ARM | NI_GPCT_PFI_GATE_SELECT(pfi_number)
 	 */
-	NI_GPCT_ARM_UNKNOWN = 0x1000,
+	NI_GPCT_HW_ARM = 0x1000,
+	NI_GPCT_ARM_UNKNOWN = NI_GPCT_HW_ARM,	/* for backward compatibility */
 };
 
 /* digital filtering options for ni 660x for use with INSN_CONFIG_FILTER. */</pre><hr><pre>commit f164cbf98fa8692ecbe1f870c50522985d34d1c2
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Jan 27 14:28:29 2016 -0700

    staging: comedi: ni_mio_common: add finite regeneration to dio output
    
    This patch continues the implementation of reinterpreting stop_arg when
    stop_src == TRIG_NONE for national instruments cdio output on e/m-series
    devices.  This is part of a series of patches that allow a user to have a
    specific buffer repeated as-is indefinitely.  The contents of the DMA
    buffer can be left static or changed by the user via mmap access to the DMA
    buffer.  If the contents are changed by the user, additional munging is not
    performed by the driver and only a single call to
    comedi_mark_buffer_written should be done.  The original behavior is
    preserved when stop_arg == 0, as would be the prior use case.
    
    As opposed to analog output, this patch is relatively simple.  First, the
    digital output capabilities are much more limited/simple as compared to the
    analog output device on NI e/m-series hardware, and second, this patch
    relies on changes made with the earlier patch to accomplish limiting the
    DMA buffer transfer.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 1a22c79c2817..929389b52572 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -3630,7 +3630,9 @@ static int ni_cdio_cmdtest(struct comedi_device *dev,
 	err |= comedi_check_trigger_arg_is(&amp;cmd-&gt;convert_arg, 0);
 	err |= comedi_check_trigger_arg_is(&amp;cmd-&gt;scan_end_arg,
 					   cmd-&gt;chanlist_len);
-	err |= comedi_check_trigger_arg_is(&amp;cmd-&gt;stop_arg, 0);
+	err |= comedi_check_trigger_arg_max(&amp;cmd-&gt;stop_arg,
+					    s-&gt;async-&gt;prealloc_bufsz /
+					    comedi_bytes_per_scan(s));
 
 	if (err)
 		return 3;
@@ -3707,6 +3709,7 @@ static int ni_cdo_inttrig(struct comedi_device *dev,
 
 static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 {
+	struct ni_private *devpriv = dev-&gt;private;
 	const struct comedi_cmd *cmd = &amp;s-&gt;async-&gt;cmd;
 	unsigned cdo_mode_bits;
 	int retval;
@@ -3731,6 +3734,10 @@ static int ni_cdio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	if (retval &lt; 0)
 		return retval;
 
+	ni_cmd_set_mite_transfer(devpriv-&gt;cdo_mite_ring, s, cmd,
+				 s-&gt;async-&gt;prealloc_bufsz /
+				 comedi_bytes_per_scan(s));
+
 	s-&gt;async-&gt;inttrig = ni_cdo_inttrig;
 
 	return 0;</pre>
    <div class="pagination">
        <a href='4_2.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><span>[3]</span><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_4.html'>Next&gt;&gt;</a>
    <div>
</body>
