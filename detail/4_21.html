<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_20.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><span>[21]</span><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_22.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e9dc122166b8d863d3057a66ada04838e5548e52
Merge: 560ab42ef923 405d8f8b1d93
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Aug 21 11:27:29 2009 -0400

    Merge branch 'nfs-for-2.6.32' of git://git.linux-nfs.org/projects/trondmy/nfs-2.6 into for-2.6.32-incoming
    
    Conflicts:
            net/sunrpc/cache.c

diff --cc net/sunrpc/cache.c
index bbd31f1215e7,45cdaff9b361..ade8a7e99cd3
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@@ -175,23 -177,13 +177,29 @@@ struct cache_head *sunrpc_cache_update(
  }
  EXPORT_SYMBOL_GPL(sunrpc_cache_update);
  
- static int cache_make_upcall(struct cache_detail *detail, struct cache_head *h);
+ static int cache_make_upcall(struct cache_detail *cd, struct cache_head *h)
+ {
+ 	if (!cd-&gt;cache_upcall)
+ 		return -EINVAL;
+ 	return cd-&gt;cache_upcall(cd, h);
+ }
  
 +static inline int cache_is_valid(struct cache_detail *detail, struct cache_head *h)
 +{
 +	if (!test_bit(CACHE_VALID, &amp;h-&gt;flags) ||
 +	    h-&gt;expiry_time &lt; get_seconds())
 +		return -EAGAIN;
 +	else if (detail-&gt;flush_time &gt; h-&gt;last_refresh)
 +		return -EAGAIN;
 +	else {
 +		/* entry is valid */
 +		if (test_bit(CACHE_NEGATIVE, &amp;h-&gt;flags))
 +			return -ENOENT;
 +		else
 +			return 0;
 +	}
 +}
++
  /*
   * This is the generic cache management routine for all
   * the authentication caches.
@@@ -924,19 -887,7 +903,7 @@@ static int cache_release(struct inode *
  
  
  
- static const struct file_operations cache_file_operations = {
- 	.owner		= THIS_MODULE,
- 	.llseek		= no_llseek,
- 	.read		= cache_read,
- 	.write		= cache_write,
- 	.poll		= cache_poll,
- 	.ioctl		= cache_ioctl, /* for FIONREAD */
- 	.open		= cache_open,
- 	.release	= cache_release,
- };
- 
- 
 -static void queue_loose(struct cache_detail *detail, struct cache_head *ch)
 +static void cache_dequeue(struct cache_detail *detail, struct cache_head *ch)
  {
  	struct cache_queue *cq;
  	spin_lock(&amp;queue_lock);</pre><hr><pre>commit 4dceef96756b667360741712a8e37490f8458516
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Aug 20 17:08:39 2009 -0400

    nfs: fix compile error in rpc_pipefs.h
    
    This include is needed for the definition of delayed_work.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/include/linux/sunrpc/rpc_pipe_fs.h b/include/linux/sunrpc/rpc_pipe_fs.h
index a92571a34556..cf14db975da0 100644
--- a/include/linux/sunrpc/rpc_pipe_fs.h
+++ b/include/linux/sunrpc/rpc_pipe_fs.h
@@ -3,6 +3,8 @@
 
 #ifdef __KERNEL__
 
+#include &lt;linux/workqueue.h&gt;
+
 struct rpc_pipe_msg {
 	struct list_head list;
 	void *data;</pre><hr><pre>commit 413d63d7106b914a4a004ac08698f10c618e4616
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 28 11:37:25 2009 -0400

    nfsd: minor write_pool_threads exit cleanup
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index 48da164bb597..b51e7ae8b570 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -784,11 +784,7 @@ static ssize_t write_pool_threads(struct file *file, char *buf, size_t size)
 		size -= len;
 		mesg += len;
 	}
-
-	kfree(nthreads);
-	mutex_unlock(&amp;nfsd_mutex);
-	return (mesg-buf);
-
+	rv = mesg - buf;
 out_free:
 	kfree(nthreads);
 	mutex_unlock(&amp;nfsd_mutex);</pre><hr><pre>commit e4636d535e32768c8c500641ddb144f56e3dc5c0
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Jun 15 19:07:13 2009 -0700

    nfsd: minor nfsd_vfs_write cleanup
    
    There's no need to check host_err &gt;= 0 every time here when we could
    check host_err &lt; 0 once, following the usual kernel style.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 6ad76a4cfc01..1cf70616a11e 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1053,19 +1053,20 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 	oldfs = get_fs(); set_fs(KERNEL_DS);
 	host_err = vfs_writev(file, (struct iovec __user *)vec, vlen, &amp;offset);
 	set_fs(oldfs);
-	if (host_err &gt;= 0) {
-		*cnt = host_err;
-		nfsdstats.io_write += host_err;
-		fsnotify_modify(file-&gt;f_path.dentry);
-	}
+	if (host_err &lt; 0)
+		goto out_nfserr;
+	*cnt = host_err;
+	nfsdstats.io_write += host_err;
+	fsnotify_modify(file-&gt;f_path.dentry);
 
 	/* clear setuid/setgid flag after write */
-	if (host_err &gt;= 0 &amp;&amp; (inode-&gt;i_mode &amp; (S_ISUID | S_ISGID)))
+	if (inode-&gt;i_mode &amp; (S_ISUID | S_ISGID))
 		kill_suid(dentry);
 
-	if (host_err &gt;= 0 &amp;&amp; stable &amp;&amp; use_wgather)
+	if (stable &amp;&amp; use_wgather)
 		host_err = wait_for_concurrent_writes(file);
 
+out_nfserr:
 	dprintk("nfsd: write complete host_err=%d\n", host_err);
 	if (host_err &gt;= 0)
 		err = 0;</pre><hr><pre>commit d911df7b8d44de41661363a4e29ee710180ba025
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Jun 15 16:03:53 2009 -0700

    nfsd: Pull write-gathering code out of nfsd_vfs_write
    
    This is a relatively self-contained piece of code that handles a special
    case--move it to its own function.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index ebf56c6040ca..6ad76a4cfc01 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -963,6 +963,43 @@ static void kill_suid(struct dentry *dentry)
 	mutex_unlock(&amp;dentry-&gt;d_inode-&gt;i_mutex);
 }
 
+/*
+ * Gathered writes: If another process is currently writing to the file,
+ * there's a high chance this is another nfsd (triggered by a bulk write
+ * from a client's biod). Rather than syncing the file with each write
+ * request, we sleep for 10 msec.
+ *
+ * I don't know if this roughly approximates C. Juszak's idea of
+ * gathered writes, but it's a nice and simple solution (IMHO), and it
+ * seems to work:-)
+ *
+ * Note: we do this only in the NFSv2 case, since v3 and higher have a
+ * better tool (separate unstable writes and commits) for solving this
+ * problem.
+ */
+static int wait_for_concurrent_writes(struct file *file)
+{
+	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
+	static ino_t last_ino;
+	static dev_t last_dev;
+	int err = 0;
+
+	if (atomic_read(&amp;inode-&gt;i_writecount) &gt; 1
+	    || (last_ino == inode-&gt;i_ino &amp;&amp; last_dev == inode-&gt;i_sb-&gt;s_dev)) {
+		dprintk("nfsd: write defer %d\n", task_pid_nr(current));
+		msleep(10);
+		dprintk("nfsd: write resume %d\n", task_pid_nr(current));
+	}
+
+	if (inode-&gt;i_state &amp; I_DIRTY) {
+		dprintk("nfsd: write sync %d\n", task_pid_nr(current));
+		err = nfsd_sync(file);
+	}
+	last_ino = inode-&gt;i_ino;
+	last_dev = inode-&gt;i_sb-&gt;s_dev;
+	return err;
+}
+
 static __be32
 nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 				loff_t offset, struct kvec *vec, int vlen,
@@ -1026,36 +1063,8 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 	if (host_err &gt;= 0 &amp;&amp; (inode-&gt;i_mode &amp; (S_ISUID | S_ISGID)))
 		kill_suid(dentry);
 
-	if (host_err &gt;= 0 &amp;&amp; stable &amp;&amp; use_wgather) {
-		static ino_t	last_ino;
-		static dev_t	last_dev;
-
-		/*
-		 * Gathered writes: If another process is currently
-		 * writing to the file, there's a high chance
-		 * this is another nfsd (triggered by a bulk write
-		 * from a client's biod). Rather than syncing the
-		 * file with each write request, we sleep for 10 msec.
-		 *
-		 * I don't know if this roughly approximates
-		 * C. Juszak's idea of gathered writes, but it's a
-		 * nice and simple solution (IMHO), and it seems to
-		 * work:-)
-		 */
-		if (atomic_read(&amp;inode-&gt;i_writecount) &gt; 1
-		    || (last_ino == inode-&gt;i_ino &amp;&amp; last_dev == inode-&gt;i_sb-&gt;s_dev)) {
-			dprintk("nfsd: write defer %d\n", task_pid_nr(current));
-			msleep(10);
-			dprintk("nfsd: write resume %d\n", task_pid_nr(current));
-		}
-
-		if (inode-&gt;i_state &amp; I_DIRTY) {
-			dprintk("nfsd: write sync %d\n", task_pid_nr(current));
-			host_err=nfsd_sync(file);
-		}
-		last_ino = inode-&gt;i_ino;
-		last_dev = inode-&gt;i_sb-&gt;s_dev;
-	}
+	if (host_err &gt;= 0 &amp;&amp; stable &amp;&amp; use_wgather)
+		host_err = wait_for_concurrent_writes(file);
 
 	dprintk("nfsd: write complete host_err=%d\n", host_err);
 	if (host_err &gt;= 0)</pre><hr><pre>commit 9d2a3f31d6d7832cd441eeda08bc2266cdd5d972
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Jun 15 18:47:56 2009 -0700

    nfsd: track last inode only in use_wgather case
    
    Updating last_ino and last_dev probably isn't useful in the !use_wgather
    case.
    
    Also remove some pointless ifdef'd-out code.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index f30cc4eadb0a..ebf56c6040ca 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1026,7 +1026,7 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 	if (host_err &gt;= 0 &amp;&amp; (inode-&gt;i_mode &amp; (S_ISUID | S_ISGID)))
 		kill_suid(dentry);
 
-	if (host_err &gt;= 0 &amp;&amp; stable) {
+	if (host_err &gt;= 0 &amp;&amp; stable &amp;&amp; use_wgather) {
 		static ino_t	last_ino;
 		static dev_t	last_dev;
 
@@ -1042,21 +1042,16 @@ nfsd_vfs_write(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 		 * nice and simple solution (IMHO), and it seems to
 		 * work:-)
 		 */
-		if (use_wgather) {
-			if (atomic_read(&amp;inode-&gt;i_writecount) &gt; 1
-			    || (last_ino == inode-&gt;i_ino &amp;&amp; last_dev == inode-&gt;i_sb-&gt;s_dev)) {
-				dprintk("nfsd: write defer %d\n", task_pid_nr(current));
-				msleep(10);
-				dprintk("nfsd: write resume %d\n", task_pid_nr(current));
-			}
+		if (atomic_read(&amp;inode-&gt;i_writecount) &gt; 1
+		    || (last_ino == inode-&gt;i_ino &amp;&amp; last_dev == inode-&gt;i_sb-&gt;s_dev)) {
+			dprintk("nfsd: write defer %d\n", task_pid_nr(current));
+			msleep(10);
+			dprintk("nfsd: write resume %d\n", task_pid_nr(current));
+		}
 
-			if (inode-&gt;i_state &amp; I_DIRTY) {
-				dprintk("nfsd: write sync %d\n", task_pid_nr(current));
-				host_err=nfsd_sync(file);
-			}
-#if 0
-			wake_up(&amp;inode-&gt;i_wait);
-#endif
+		if (inode-&gt;i_state &amp; I_DIRTY) {
+			dprintk("nfsd: write sync %d\n", task_pid_nr(current));
+			host_err=nfsd_sync(file);
 		}
 		last_ino = inode-&gt;i_ino;
 		last_dev = inode-&gt;i_sb-&gt;s_dev;</pre><hr><pre>commit 7eef4091a653c243a87e5375c54504cc03bec4d8
Merge: 0a93a47f042c 07a2039b8eb0
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Jun 15 18:08:07 2009 -0700

    Merge commit 'v2.6.30' into for-2.6.31
</pre><hr><pre>commit 7f4218354fe312b327af06c3d8c95ed5f214c8ca
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed May 27 18:51:06 2009 -0400

    nfsd: Revert "svcrpc: take advantage of tcp autotuning"
    
    This reverts commit 47a14ef1af48c696b214ac168f056ddc79793d0e "svcrpc:
    take advantage of tcp autotuning", which uncovered some further problems
    in the server rpc code, causing significant performance regressions in
    common cases.
    
    We will likely reinstate this patch after releasing 2.6.30 and applying
    some work on the underlying fixes to the problem (developed by Trond).
    
    Reported-by: Jeff Moyer &lt;jmoyer@redhat.com&gt;
    Cc: Olga Kornievskaia &lt;aglo@citi.umich.edu&gt;
    Cc: Jim Rees &lt;rees@umich.edu&gt;
    Cc: Trond Myklebust &lt;trond.myklebust@fys.uio.no&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/net/sunrpc/svcsock.c b/net/sunrpc/svcsock.c
index af3198814c15..9d504234af4a 100644
--- a/net/sunrpc/svcsock.c
+++ b/net/sunrpc/svcsock.c
@@ -345,6 +345,7 @@ static void svc_sock_setbufsize(struct socket *sock, unsigned int snd,
 	lock_sock(sock-&gt;sk);
 	sock-&gt;sk-&gt;sk_sndbuf = snd * 2;
 	sock-&gt;sk-&gt;sk_rcvbuf = rcv * 2;
+	sock-&gt;sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK|SOCK_RCVBUF_LOCK;
 	release_sock(sock-&gt;sk);
 #endif
 }
@@ -796,6 +797,23 @@ static int svc_tcp_recvfrom(struct svc_rqst *rqstp)
 		test_bit(XPT_CONN, &amp;svsk-&gt;sk_xprt.xpt_flags),
 		test_bit(XPT_CLOSE, &amp;svsk-&gt;sk_xprt.xpt_flags));
 
+	if (test_and_clear_bit(XPT_CHNGBUF, &amp;svsk-&gt;sk_xprt.xpt_flags))
+		/* sndbuf needs to have room for one request
+		 * per thread, otherwise we can stall even when the
+		 * network isn't a bottleneck.
+		 *
+		 * We count all threads rather than threads in a
+		 * particular pool, which provides an upper bound
+		 * on the number of threads which will access the socket.
+		 *
+		 * rcvbuf just needs to be able to hold a few requests.
+		 * Normally they will be removed from the queue
+		 * as soon a a complete request arrives.
+		 */
+		svc_sock_setbufsize(svsk-&gt;sk_sock,
+				    (serv-&gt;sv_nrthreads+3) * serv-&gt;sv_max_mesg,
+				    3 * serv-&gt;sv_max_mesg);
+
 	clear_bit(XPT_DATA, &amp;svsk-&gt;sk_xprt.xpt_flags);
 
 	/* Receive data. If we haven't got the record length yet, get
@@ -1043,6 +1061,15 @@ static void svc_tcp_init(struct svc_sock *svsk, struct svc_serv *serv)
 
 		tcp_sk(sk)-&gt;nonagle |= TCP_NAGLE_OFF;
 
+		/* initialise setting must have enough space to
+		 * receive and respond to one request.
+		 * svc_tcp_recvfrom will re-adjust if necessary
+		 */
+		svc_sock_setbufsize(svsk-&gt;sk_sock,
+				    3 * svsk-&gt;sk_xprt.xpt_server-&gt;sv_max_mesg,
+				    3 * svsk-&gt;sk_xprt.xpt_server-&gt;sv_max_mesg);
+
+		set_bit(XPT_CHNGBUF, &amp;svsk-&gt;sk_xprt.xpt_flags);
 		set_bit(XPT_DATA, &amp;svsk-&gt;sk_xprt.xpt_flags);
 		if (sk-&gt;sk_state != TCP_ESTABLISHED)
 			set_bit(XPT_CLOSE, &amp;svsk-&gt;sk_xprt.xpt_flags);
@@ -1112,14 +1139,8 @@ static struct svc_sock *svc_setup_socket(struct svc_serv *serv,
 	/* Initialize the socket */
 	if (sock-&gt;type == SOCK_DGRAM)
 		svc_udp_init(svsk, serv);
-	else {
-		/* initialise setting must have enough space to
-		 * receive and respond to one request.
-		 */
-		svc_sock_setbufsize(svsk-&gt;sk_sock, 4 * serv-&gt;sv_max_mesg,
-					4 * serv-&gt;sv_max_mesg);
+	else
 		svc_tcp_init(svsk, serv);
-	}
 
 	dprintk("svc: svc_setup_socket created %p (inet %p)\n",
 				svsk, svsk-&gt;sk_sk);</pre><hr><pre>commit 8daed1e549b55827758b3af7b8132a73fc51526f
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon May 11 16:10:19 2009 -0400

    nfsd: silence lockdep warning
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index 5275097a7565..b5348405046b 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -229,7 +229,7 @@ nfsd4_list_rec_dir(struct dentry *dir, recdir_func *f)
 		goto out;
 	status = vfs_readdir(filp, nfsd4_build_namelist, &amp;names);
 	fput(filp);
-	mutex_lock(&amp;dir-&gt;d_inode-&gt;i_mutex);
+	mutex_lock_nested(&amp;dir-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
 	while (!list_empty(&amp;names)) {
 		entry = list_entry(names.next, struct name_list, list);
 
@@ -264,7 +264,7 @@ nfsd4_unlink_clid_dir(char *name, int namlen)
 
 	dprintk("NFSD: nfsd4_unlink_clid_dir. name %.*s\n", namlen, name);
 
-	mutex_lock(&amp;rec_dir.dentry-&gt;d_inode-&gt;i_mutex);
+	mutex_lock_nested(&amp;rec_dir.dentry-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
 	dentry = lookup_one_len(name, rec_dir.dentry, namlen);
 	if (IS_ERR(dentry)) {
 		status = PTR_ERR(dentry);</pre><hr><pre>commit 89996df4b5b1a09c279f50b3fd03aa9df735f5cb
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed May 6 16:32:54 2009 -0400

    lockd: fix list corruption on lockd restart
    
    If lockd is signalled soon enough after restart then locks_start_grace()
    will try to re-add an entry to a list and trigger a lock corruption
    warning.
    
    Thanks to Wang Chen for the problem report and diagnosis.
    
    WARNING: at lib/list_debug.c:26 __list_add+0x27/0x5c()
    ...
    list_add corruption. next-&gt;prev should be prev (ef8fe958), but was ef8ff128.  (next=ef8ff128).
    ...
    Pid: 23062, comm: lockd Tainted: G        W  2.6.30-rc2 #3
    Call Trace:
    [&lt;c042d5b5&gt;] warn_slowpath+0x71/0xa0
    [&lt;c0422a96&gt;] ? update_curr+0x11d/0x125
    [&lt;c044b12d&gt;] ? trace_hardirqs_on_caller+0x18/0x150
    [&lt;c044b270&gt;] ? trace_hardirqs_on+0xb/0xd
    [&lt;c051c61a&gt;] ? _raw_spin_lock+0x53/0xfa
    [&lt;c051c89f&gt;] __list_add+0x27/0x5c
    [&lt;ef8f6daa&gt;] locks_start_grace+0x22/0x30 [lockd]
    [&lt;ef8f34da&gt;] set_grace_period+0x39/0x53 [lockd]
    [&lt;c06b8921&gt;] ? lock_kernel+0x1c/0x28
    [&lt;ef8f3558&gt;] lockd+0x64/0x164 [lockd]
    [&lt;c044b12d&gt;] ? trace_hardirqs_on_caller+0x18/0x150
    [&lt;c04227b0&gt;] ? complete+0x34/0x3e
    [&lt;ef8f34f4&gt;] ? lockd+0x0/0x164 [lockd]
    [&lt;ef8f34f4&gt;] ? lockd+0x0/0x164 [lockd]
    [&lt;c043dd42&gt;] kthread+0x45/0x6b
    [&lt;c043dcfd&gt;] ? kthread+0x0/0x6b
    [&lt;c0403c23&gt;] kernel_thread_helper+0x7/0x10
    
    Reported-by: Wang Chen &lt;wangchen@cn.fujitsu.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: stable@kernel.org

diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index abf83881f68a..1a54ae14a192 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -104,6 +104,16 @@ static void set_grace_period(void)
 	schedule_delayed_work(&amp;grace_period_end, grace_period);
 }
 
+static void restart_grace(void)
+{
+	if (nlmsvc_ops) {
+		cancel_delayed_work_sync(&amp;grace_period_end);
+		locks_end_grace(&amp;lockd_manager);
+		nlmsvc_invalidate_all();
+		set_grace_period();
+	}
+}
+
 /*
  * This is the lockd kernel thread
  */
@@ -149,10 +159,7 @@ lockd(void *vrqstp)
 
 		if (signalled()) {
 			flush_signals(current);
-			if (nlmsvc_ops) {
-				nlmsvc_invalidate_all();
-				set_grace_period();
-			}
+			restart_grace();
 			continue;
 		}
 </pre>
    <div class="pagination">
        <a href='4_20.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><span>[21]</span><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_22.html'>Next&gt;&gt;</a>
    <div>
</body>
