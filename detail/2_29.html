<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_28.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><span>[29]</span><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_30.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8b3ab0edaf6acd281243bf974fac7e01c9574d08
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:25:49 2014 -0400

    USB: OHCI: no shortcut for unlinking URBS from a dead controller
    
    When an URB is unlinked from a dead controller, ohci-hcd gives back
    the URB with no regard for cleaning up the internal data structures.
    This won't play nicely with the upcoming changes to the TD done
    list.
    
    Therefore make ohci_urb_dequeue() call finish_unlinks(), which uses
    td_done() to do a proper cleanup, rather than calling finish_urb()
    directly.  Also, remove the checks that urb_priv is non-NULL; the
    driver guarantees that urb_priv will never be NULL for a valid URB.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index a8f0e1b00e7d..52829276a44e 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -300,30 +300,24 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	unsigned long		flags;
 	int			rc;
+	urb_priv_t		*urb_priv;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
-	if (rc) {
-		;	/* Do nothing */
-	} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
-		urb_priv_t  *urb_priv;
+	if (rc == 0) {
 
 		/* Unless an IRQ completed the unlink while it was being
 		 * handed to us, flag it for unlink and giveback, and force
 		 * some upcoming INTR_SF to call finish_unlinks()
 		 */
 		urb_priv = urb-&gt;hcpriv;
-		if (urb_priv) {
-			if (urb_priv-&gt;ed-&gt;state == ED_OPER)
-				start_ed_unlink (ohci, urb_priv-&gt;ed);
+		if (urb_priv-&gt;ed-&gt;state == ED_OPER)
+			start_ed_unlink(ohci, urb_priv-&gt;ed);
+
+		if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
+			/* With HC dead, we can clean up right away */
+			finish_unlinks(ohci, 0);
 		}
-	} else {
-		/*
-		 * with HC dead, we won't respect hc queue pointers
-		 * any more ... just clean up every urb's memory.
-		 */
-		if (urb-&gt;hcpriv)
-			finish_urb(ohci, urb, status);
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return rc;</pre><hr><pre>commit 95d9a01d727fdb6d2b667ac374341c48777cc41e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:25:36 2014 -0400

    USB: OHCI: revert the ZF Micro orphan-TD quirk
    
    This patch reverts the important parts of commit 89a0fd18a96e (USB:
    OHCI handles more ZFMicro quirks), namely, the parts related to
    handling orphan TDs for interrupt endpoints.  A later patch in this
    series will introduce a more general mechanism that applies to all
    endpoint types and all controllers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 7570098b1cfa..a8f0e1b00e7d 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -355,8 +355,6 @@ ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 sanitize:
 		ed-&gt;state = ED_IDLE;
-		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
-			ohci-&gt;eds_scheduled--;
 		finish_unlinks (ohci, 0);
 	}
 
@@ -365,11 +363,6 @@ ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		/* major IRQ delivery trouble loses INTR_SF too... */
 		if (limit-- == 0) {
 			ohci_warn(ohci, "ED unlink timeout\n");
-			if (quirk_zfmicro(ohci)) {
-				ohci_warn(ohci, "Attempting ZF TD recovery\n");
-				ohci-&gt;ed_to_check = ed;
-				ohci-&gt;zf_delay = 2;
-			}
 			goto sanitize;
 		}
 		spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
@@ -431,93 +424,6 @@ ohci_shutdown (struct usb_hcd *hcd)
 	ohci_writel(ohci, ohci-&gt;fminterval, &amp;ohci-&gt;regs-&gt;fminterval);
 }
 
-static int check_ed(struct ohci_hcd *ohci, struct ed *ed)
-{
-	return (hc32_to_cpu(ohci, ed-&gt;hwINFO) &amp; ED_IN) != 0
-		&amp;&amp; (hc32_to_cpu(ohci, ed-&gt;hwHeadP) &amp; TD_MASK)
-			== (hc32_to_cpu(ohci, ed-&gt;hwTailP) &amp; TD_MASK)
-		&amp;&amp; !list_empty(&amp;ed-&gt;td_list);
-}
-
-/* ZF Micro watchdog timer callback. The ZF Micro chipset sometimes completes
- * an interrupt TD but neglects to add it to the donelist.  On systems with
- * this chipset, we need to periodically check the state of the queues to look
- * for such "lost" TDs.
- */
-static void unlink_watchdog_func(unsigned long _ohci)
-{
-	unsigned long	flags;
-	unsigned	max;
-	unsigned	seen_count = 0;
-	unsigned	i;
-	struct ed	**seen = NULL;
-	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
-
-	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
-	max = ohci-&gt;eds_scheduled;
-	if (!max)
-		goto done;
-
-	if (ohci-&gt;ed_to_check)
-		goto out;
-
-	seen = kcalloc(max, sizeof *seen, GFP_ATOMIC);
-	if (!seen)
-		goto out;
-
-	for (i = 0; i &lt; NUM_INTS; i++) {
-		struct ed	*ed = ohci-&gt;periodic[i];
-
-		while (ed) {
-			unsigned	temp;
-
-			/* scan this branch of the periodic schedule tree */
-			for (temp = 0; temp &lt; seen_count; temp++) {
-				if (seen[temp] == ed) {
-					/* we've checked it and what's after */
-					ed = NULL;
-					break;
-				}
-			}
-			if (!ed)
-				break;
-			seen[seen_count++] = ed;
-			if (!check_ed(ohci, ed)) {
-				ed = ed-&gt;ed_next;
-				continue;
-			}
-
-			/* HC's TD list is empty, but HCD sees at least one
-			 * TD that's not been sent through the donelist.
-			 */
-			ohci-&gt;ed_to_check = ed;
-			ohci-&gt;zf_delay = 2;
-
-			/* The HC may wait until the next frame to report the
-			 * TD as done through the donelist and INTR_WDH.  (We
-			 * just *assume* it's not a multi-TD interrupt URB;
-			 * those could defer the IRQ more than one frame, using
-			 * DI...)  Check again after the next INTR_SF.
-			 */
-			ohci_writel(ohci, OHCI_INTR_SF,
-					&amp;ohci-&gt;regs-&gt;intrstatus);
-			ohci_writel(ohci, OHCI_INTR_SF,
-					&amp;ohci-&gt;regs-&gt;intrenable);
-
-			/* flush those writes */
-			(void) ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
-
-			goto out;
-		}
-	}
-out:
-	kfree(seen);
-	if (ohci-&gt;eds_scheduled)
-		mod_timer(&amp;ohci-&gt;unlink_watchdog, round_jiffies(jiffies + HZ));
-done:
-	spin_unlock_irqrestore(&amp;ohci-&gt;lock, flags);
-}
-
 /*-------------------------------------------------------------------------*
  * HC functions
  *-------------------------------------------------------------------------*/
@@ -761,15 +667,6 @@ static int ohci_run (struct ohci_hcd *ohci)
 	// POTPGT delay is bits 24-31, in 2 ms units.
 	mdelay ((val &gt;&gt; 23) &amp; 0x1fe);
 
-	if (quirk_zfmicro(ohci)) {
-		/* Create timer to watch for bad queue state on ZF Micro */
-		setup_timer(&amp;ohci-&gt;unlink_watchdog, unlink_watchdog_func,
-				(unsigned long) ohci);
-
-		ohci-&gt;eds_scheduled = 0;
-		ohci-&gt;ed_to_check = NULL;
-	}
-
 	ohci_dump(ohci);
 
 	return 0;
@@ -895,31 +792,6 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		spin_unlock (&amp;ohci-&gt;lock);
 	}
 
-	if (quirk_zfmicro(ohci) &amp;&amp; (ints &amp; OHCI_INTR_SF)) {
-		spin_lock(&amp;ohci-&gt;lock);
-		if (ohci-&gt;ed_to_check) {
-			struct ed *ed = ohci-&gt;ed_to_check;
-
-			if (check_ed(ohci, ed)) {
-				/* HC thinks the TD list is empty; HCD knows
-				 * at least one TD is outstanding
-				 */
-				if (--ohci-&gt;zf_delay == 0) {
-					struct td *td = list_entry(
-						ed-&gt;td_list.next,
-						struct td, td_list);
-					ohci_warn(ohci,
-						  "Reclaiming orphan TD %p\n",
-						  td);
-					takeback_td(ohci, td);
-					ohci-&gt;ed_to_check = NULL;
-				}
-			} else
-				ohci-&gt;ed_to_check = NULL;
-		}
-		spin_unlock(&amp;ohci-&gt;lock);
-	}
-
 	/* could track INTR_SO to reduce available PCI/... bandwidth */
 
 	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
@@ -928,9 +800,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	spin_lock (&amp;ohci-&gt;lock);
 	if (ohci-&gt;ed_rm_list)
 		finish_unlinks (ohci, ohci_frame_no(ohci));
-	if ((ints &amp; OHCI_INTR_SF) != 0
-			&amp;&amp; !ohci-&gt;ed_rm_list
-			&amp;&amp; !ohci-&gt;ed_to_check
+	if ((ints &amp; OHCI_INTR_SF) != 0 &amp;&amp; !ohci-&gt;ed_rm_list
 			&amp;&amp; ohci-&gt;rh_state == OHCI_RH_RUNNING)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;regs-&gt;intrdisable);
 	spin_unlock (&amp;ohci-&gt;lock);
@@ -961,8 +831,6 @@ static void ohci_stop (struct usb_hcd *hcd)
 	free_irq(hcd-&gt;irq, hcd);
 	hcd-&gt;irq = 0;
 
-	if (quirk_zfmicro(ohci))
-		del_timer(&amp;ohci-&gt;unlink_watchdog);
 	if (quirk_amdiso(ohci))
 		usb_amd_dev_put();
 
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index a6376f3e55cb..a9f4f04c3fad 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -187,10 +187,6 @@ static int ed_schedule (struct ohci_hcd *ohci, struct ed *ed)
 	ed-&gt;ed_prev = NULL;
 	ed-&gt;ed_next = NULL;
 	ed-&gt;hwNextED = 0;
-	if (quirk_zfmicro(ohci)
-			&amp;&amp; (ed-&gt;type == PIPE_INTERRUPT)
-			&amp;&amp; !(ohci-&gt;eds_scheduled++))
-		mod_timer(&amp;ohci-&gt;unlink_watchdog, round_jiffies(jiffies + HZ));
 	wmb ();
 
 	/* we care about rm_list when setting CLE/BLE in case the HC was at
@@ -977,19 +973,13 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 								TD_MASK;
 
 				/* INTR_WDH may need to clean up first */
-				if (td-&gt;td_dma != head) {
-					if (ed == ohci-&gt;ed_to_check)
-						ohci-&gt;ed_to_check = NULL;
-					else
-						goto skip_ed;
-				}
+				if (td-&gt;td_dma != head)
+					goto skip_ed;
 			}
 		}
 
 		/* ED's now officially unlinked, hc doesn't see */
 		ed-&gt;state = ED_IDLE;
-		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
-			ohci-&gt;eds_scheduled--;
 		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
 		ed-&gt;hwNextED = 0;
 		wmb();
@@ -1122,12 +1112,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 
 /*-------------------------------------------------------------------------*/
 
-/*
- * Used to take back a TD from the host controller. This would normally be
- * called from within dl_done_list, however it may be called directly if the
- * HC no longer sees the TD and it has not appeared on the donelist (after
- * two frames).  This bug has been observed on ZF Micro systems.
- */
+/* Take back a TD from the host controller */
 static void takeback_td(struct ohci_hcd *ohci, struct td *td)
 {
 	struct urb	*urb = td-&gt;urb;
@@ -1174,9 +1159,7 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
  *
  * This is the main path for handing urbs back to drivers.  The only other
  * normal path is finish_unlinks(), which unlinks URBs using ed_rm_list,
- * instead of scanning the (re-reversed) donelist as this does.  There's
- * an abnormal path too, handling a quirk in some Compaq silicon:  URBs
- * with TDs that appear to be orphaned are directly reclaimed.
+ * instead of scanning the (re-reversed) donelist as this does.
  */
 static void
 dl_done_list (struct ohci_hcd *ohci)
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 05e02a709d4f..392932dd6318 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -411,12 +411,6 @@ struct ohci_hcd {
 
 	struct work_struct	nec_work;	/* Worker for NEC quirk */
 
-	/* Needed for ZF Micro quirk */
-	struct timer_list	unlink_watchdog;
-	unsigned		eds_scheduled;
-	struct ed		*ed_to_check;
-	unsigned		zf_delay;
-
 	struct dentry		*debug_dir;
 	struct dentry		*debug_async;
 	struct dentry		*debug_periodic;</pre><hr><pre>commit 977dcfdc60311e7aa571cabf6f39c36dde13339e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 17 16:34:29 2014 -0400

    USB: OHCI: don't lose track of EDs when a controller dies
    
    This patch fixes a bug in ohci-hcd.  When an URB is unlinked, the
    corresponding Endpoint Descriptor is added to the ed_rm_list and taken
    off the hardware schedule.  Once the ED is no longer visible to the
    hardware, finish_unlinks() handles the URBs that were unlinked or have
    completed.  If any URBs remain attached to the ED, the ED is added
    back to the hardware schedule -- but only if the controller is
    running.
    
    This fails when a controller dies.  A non-empty ED does not get added
    back to the hardware schedule and does not remain on the ed_rm_list;
    ohci-hcd loses track of it.  The remaining URBs cannot be unlinked,
    which causes the USB stack to hang.
    
    The patch changes finish_unlinks() so that non-empty EDs remain on
    the ed_rm_list if the controller isn't running.  This requires moving
    some of the existing code around, to avoid modifying the ED's hardware
    fields more than once.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 517d04d5c150..a6376f3e55cb 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -311,8 +311,7 @@ static void periodic_unlink (struct ohci_hcd *ohci, struct ed *ed)
  *  - ED_OPER: when there's any request queued, the ED gets rescheduled
  *    immediately.  HC should be working on them.
  *
- *  - ED_IDLE:  when there's no TD queue. there's no reason for the HC
- *    to care about this ED; safe to disable the endpoint.
+ *  - ED_IDLE: when there's no TD queue or the HC isn't running.
  *
  * When finish_unlinks() runs later, after SOF interrupt, it will often
  * complete one or more URB unlinks before making that state change.
@@ -954,6 +953,10 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 		int			completed, modified;
 		__hc32			*prev;
 
+		/* Is this ED already invisible to the hardware? */
+		if (ed-&gt;state == ED_IDLE)
+			goto ed_idle;
+
 		/* only take off EDs that the HC isn't using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
@@ -983,12 +986,20 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			}
 		}
 
+		/* ED's now officially unlinked, hc doesn't see */
+		ed-&gt;state = ED_IDLE;
+		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
+			ohci-&gt;eds_scheduled--;
+		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
+		ed-&gt;hwNextED = 0;
+		wmb();
+		ed-&gt;hwINFO &amp;= ~cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE);
+ed_idle:
+
 		/* reentrancy:  if we drop the schedule lock, someone might
 		 * have modified this list.  normally it's just prepending
 		 * entries (which we'd ignore), but paranoia won't hurt.
 		 */
-		*last = ed-&gt;ed_next;
-		ed-&gt;ed_next = NULL;
 		modified = 0;
 
 		/* unlink urbs as requested, but rescan the list after
@@ -1046,19 +1057,20 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 		if (completed &amp;&amp; !list_empty (&amp;ed-&gt;td_list))
 			goto rescan_this;
 
-		/* ED's now officially unlinked, hc doesn't see */
-		ed-&gt;state = ED_IDLE;
-		if (quirk_zfmicro(ohci) &amp;&amp; ed-&gt;type == PIPE_INTERRUPT)
-			ohci-&gt;eds_scheduled--;
-		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
-		ed-&gt;hwNextED = 0;
-		wmb ();
-		ed-&gt;hwINFO &amp;= ~cpu_to_hc32 (ohci, ED_SKIP | ED_DEQUEUE);
-
-		/* but if there's work queued, reschedule */
-		if (!list_empty (&amp;ed-&gt;td_list)) {
-			if (ohci-&gt;rh_state == OHCI_RH_RUNNING)
-				ed_schedule (ohci, ed);
+		/*
+		 * If no TDs are queued, take ED off the ed_rm_list.
+		 * Otherwise, if the HC is running, reschedule.
+		 * If not, leave it on the list for further dequeues.
+		 */
+		if (list_empty(&amp;ed-&gt;td_list)) {
+			*last = ed-&gt;ed_next;
+			ed-&gt;ed_next = NULL;
+		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
+			*last = ed-&gt;ed_next;
+			ed-&gt;ed_next = NULL;
+			ed_schedule(ohci, ed);
+		} else {
+			last = &amp;ed-&gt;ed_next;
 		}
 
 		if (modified)</pre><hr><pre>commit 256dbcd80f1ccf8abf421c1d72ba79a4e29941dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 17 16:32:26 2014 -0400

    USB: OHCI: fix bugs in debug routines
    
    The debug routine fill_async_buffer() in ohci-hcd is buggy: It never
    produces any output because it forgets to initialize the output buffer
    size.  Also, the debug routine ohci_dump() has an unused argument.
    
    This patch adds the correct initialization and removes the unused
    argument.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index 45032e933e18..04f2186939d2 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -236,7 +236,7 @@ ohci_dump_roothub (
 	}
 }
 
-static void ohci_dump (struct ohci_hcd *controller, int verbose)
+static void ohci_dump(struct ohci_hcd *controller)
 {
 	ohci_dbg (controller, "OHCI controller state\n");
 
@@ -464,15 +464,16 @@ show_list (struct ohci_hcd *ohci, char *buf, size_t count, struct ed *ed)
 static ssize_t fill_async_buffer(struct debug_buffer *buf)
 {
 	struct ohci_hcd		*ohci;
-	size_t			temp;
+	size_t			temp, size;
 	unsigned long		flags;
 
 	ohci = buf-&gt;ohci;
+	size = PAGE_SIZE;
 
 	/* display control and bulk lists together, for simplicity */
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-	temp = show_list(ohci, buf-&gt;page, buf-&gt;count, ohci-&gt;ed_controltail);
-	temp += show_list(ohci, buf-&gt;page + temp, buf-&gt;count - temp,
+	temp = show_list(ohci, buf-&gt;page, size, ohci-&gt;ed_controltail);
+	temp += show_list(ohci, buf-&gt;page + temp, size - temp,
 			  ohci-&gt;ed_bulktail);
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 7f94c586c5dc..7570098b1cfa 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -76,8 +76,8 @@ static const char	hcd_name [] = "ohci_hcd";
 #include "ohci.h"
 #include "pci-quirks.h"
 
-static void ohci_dump (struct ohci_hcd *ohci, int verbose);
-static void ohci_stop (struct usb_hcd *hcd);
+static void ohci_dump(struct ohci_hcd *ohci);
+static void ohci_stop(struct usb_hcd *hcd);
 
 #include "ohci-hub.c"
 #include "ohci-dbg.c"
@@ -770,7 +770,7 @@ static int ohci_run (struct ohci_hcd *ohci)
 		ohci-&gt;ed_to_check = NULL;
 	}
 
-	ohci_dump (ohci, 1);
+	ohci_dump(ohci);
 
 	return 0;
 }
@@ -851,7 +851,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 			usb_hc_died(hcd);
 		}
 
-		ohci_dump (ohci, 1);
+		ohci_dump(ohci);
 		ohci_usb_reset (ohci);
 	}
 
@@ -951,7 +951,7 @@ static void ohci_stop (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
-	ohci_dump (ohci, 1);
+	ohci_dump(ohci);
 
 	if (quirk_nec(ohci))
 		flush_work(&amp;ohci-&gt;nec_work);</pre><hr><pre>commit 6f65126c76e38e671c64ec171acff8a99c4de749
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 17 16:30:01 2014 -0400

    USB: OHCI: add SG support
    
    Apparently nobody ever remembered to add Scatter-Gather support to
    ohci-hcd.  This patch adds it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 6f8ec52c7e0c..7f94c586c5dc 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -109,6 +109,33 @@ MODULE_PARM_DESC (no_handshake, "true (not default) disables BIOS handshake");
 
 /*-------------------------------------------------------------------------*/
 
+static int number_of_tds(struct urb *urb)
+{
+	int			len, i, num, this_sg_len;
+	struct scatterlist	*sg;
+
+	len = urb-&gt;transfer_buffer_length;
+	i = urb-&gt;num_mapped_sgs;
+
+	if (len &gt; 0 &amp;&amp; i &gt; 0) {		/* Scatter-gather transfer */
+		num = 0;
+		sg = urb-&gt;sg;
+		for (;;) {
+			this_sg_len = min_t(int, sg_dma_len(sg), len);
+			num += DIV_ROUND_UP(this_sg_len, 4096);
+			len -= this_sg_len;
+			if (--i &lt;= 0 || len &lt;= 0)
+				break;
+			sg = sg_next(sg);
+		}
+
+	} else {			/* Non-SG transfer */
+		/* one TD for every 4096 Bytes (could be up to 8K) */
+		num = DIV_ROUND_UP(len, 4096);
+	}
+	return num;
+}
+
 /*
  * queue up an urb for anything except the root hub
  */
@@ -142,12 +169,8 @@ static int ohci_urb_enqueue (
 		// case PIPE_INTERRUPT:
 		// case PIPE_BULK:
 		default:
-			/* one TD for every 4096 Bytes (can be up to 8K) */
-			size += urb-&gt;transfer_buffer_length / 4096;
-			/* ... and for any remaining bytes ... */
-			if ((urb-&gt;transfer_buffer_length % 4096) != 0)
-				size++;
-			/* ... and maybe a zero length packet to wrap it up */
+			size += number_of_tds(urb);
+			/* maybe a zero-length packet to wrap it up */
 			if (size == 0)
 				size++;
 			else if ((urb-&gt;transfer_flags &amp; URB_ZERO_PACKET) != 0
@@ -506,6 +529,9 @@ static int ohci_init (struct ohci_hcd *ohci)
 	int ret;
 	struct usb_hcd *hcd = ohci_to_hcd(ohci);
 
+	/* Accept arbitrarily long scatter-gather lists */
+	hcd-&gt;self.sg_tablesize = ~0;
+
 	if (distrust_firmware)
 		ohci-&gt;flags |= OHCI_QUIRK_HUB_POWER;
 
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index d4253e319428..517d04d5c150 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -602,6 +602,8 @@ static void td_submit_urb (
 	u32		info = 0;
 	int		is_out = usb_pipeout (urb-&gt;pipe);
 	int		periodic = 0;
+	int		i, this_sg_len, n;
+	struct scatterlist	*sg;
 
 	/* OHCI handles the bulk/interrupt data toggles itself.  We just
 	 * use the device toggle bits for resetting, and rely on the fact
@@ -615,10 +617,24 @@ static void td_submit_urb (
 
 	list_add (&amp;urb_priv-&gt;pending, &amp;ohci-&gt;pending);
 
-	if (data_len)
-		data = urb-&gt;transfer_dma;
-	else
-		data = 0;
+	i = urb-&gt;num_mapped_sgs;
+	if (data_len &gt; 0 &amp;&amp; i &gt; 0) {
+		sg = urb-&gt;sg;
+		data = sg_dma_address(sg);
+
+		/*
+		 * urb-&gt;transfer_buffer_length may be smaller than the
+		 * size of the scatterlist (or vice versa)
+		 */
+		this_sg_len = min_t(int, sg_dma_len(sg), data_len);
+	} else {
+		sg = NULL;
+		if (data_len)
+			data = urb-&gt;transfer_dma;
+		else
+			data = 0;
+		this_sg_len = data_len;
+	}
 
 	/* NOTE:  TD_CC is set so we can tell which TDs the HC processed by
 	 * using TD_CC_GET, as well as by seeing them on the done list.
@@ -639,17 +655,29 @@ static void td_submit_urb (
 			? TD_T_TOGGLE | TD_CC | TD_DP_OUT
 			: TD_T_TOGGLE | TD_CC | TD_DP_IN;
 		/* TDs _could_ transfer up to 8K each */
-		while (data_len &gt; 4096) {
-			td_fill (ohci, info, data, 4096, urb, cnt);
-			data += 4096;
-			data_len -= 4096;
+		for (;;) {
+			n = min(this_sg_len, 4096);
+
+			/* maybe avoid ED halt on final TD short read */
+			if (n &gt;= data_len || (i == 1 &amp;&amp; n &gt;= this_sg_len)) {
+				if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))
+					info |= TD_R;
+			}
+			td_fill(ohci, info, data, n, urb, cnt);
+			this_sg_len -= n;
+			data_len -= n;
+			data += n;
 			cnt++;
+
+			if (this_sg_len &lt;= 0) {
+				if (--i &lt;= 0 || data_len &lt;= 0)
+					break;
+				sg = sg_next(sg);
+				data = sg_dma_address(sg);
+				this_sg_len = min_t(int, sg_dma_len(sg),
+						data_len);
+			}
 		}
-		/* maybe avoid ED halt on final TD short read */
-		if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK))
-			info |= TD_R;
-		td_fill (ohci, info, data, data_len, urb, cnt);
-		cnt++;
 		if ((urb-&gt;transfer_flags &amp; URB_ZERO_PACKET)
 				&amp;&amp; cnt &lt; urb_priv-&gt;length) {
 			td_fill (ohci, info, 0, 0, urb, cnt);</pre><hr><pre>commit 1299cff9fa39811cd1b3f1731527b062425f0541
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 17 15:40:57 2014 -0400

    USB: shutdown all URBs after controller death
    
    When a host controller dies, we don't need to wait for a driver to
    time out.  We can shut down its URBs immediately.  Without this
    change, we can end up waiting 30 seconds for a mass-storage transfer
    to time out.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 4aeb10034de7..9bffd26cea05 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -417,10 +417,11 @@ static int usb_unbind_interface(struct device *dev)
 	 */
 	lpm_disable_error = usb_unlocked_disable_lpm(udev);
 
-	/* Terminate all URBs for this interface unless the driver
-	 * supports "soft" unbinding.
+	/*
+	 * Terminate all URBs for this interface unless the driver
+	 * supports "soft" unbinding and the device is still present.
 	 */
-	if (!driver-&gt;soft_unbind)
+	if (!driver-&gt;soft_unbind || udev-&gt;state == USB_STATE_NOTATTACHED)
 		usb_disable_interface(udev, intf, false);
 
 	driver-&gt;disconnect(intf);</pre><hr><pre>commit b14bf2d0c0358140041d1c1805a674376964d0e0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 30 11:04:21 2014 -0400

    usb-storage/SCSI: Add broken_fua blacklist flag
    
    Some buggy JMicron USB-ATA bridges don't know how to translate the FUA
    bit in READs or WRITEs.  This patch adds an entry in unusual_devs.h
    and a blacklist flag to tell the sd driver not to use FUA.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Michael Büsch &lt;m@bues.ch&gt;
    Tested-by: Michael Büsch &lt;m@bues.ch&gt;
    Acked-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index e9689d57ccb6..6825eda1114a 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -2441,7 +2441,10 @@ sd_read_cache_type(struct scsi_disk *sdkp, unsigned char *buffer)
 		}
 
 		sdkp-&gt;DPOFUA = (data.device_specific &amp; 0x10) != 0;
-		if (sdkp-&gt;DPOFUA &amp;&amp; !sdkp-&gt;device-&gt;use_10_for_rw) {
+		if (sdp-&gt;broken_fua) {
+			sd_first_printk(KERN_NOTICE, sdkp, "Disabling FUA\n");
+			sdkp-&gt;DPOFUA = 0;
+		} else if (sdkp-&gt;DPOFUA &amp;&amp; !sdkp-&gt;device-&gt;use_10_for_rw) {
 			sd_first_printk(KERN_NOTICE, sdkp,
 				  "Uses READ/WRITE(6), disabling FUA\n");
 			sdkp-&gt;DPOFUA = 0;
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 9d38ddc8da49..866b5df36ed1 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -256,6 +256,10 @@ static int slave_configure(struct scsi_device *sdev)
 		if (us-&gt;fflags &amp; US_FL_WRITE_CACHE)
 			sdev-&gt;wce_default_on = 1;
 
+		/* A few buggy USB-ATA bridges don't understand FUA */
+		if (us-&gt;fflags &amp; US_FL_BROKEN_FUA)
+			sdev-&gt;broken_fua = 1;
+
 	} else {
 
 		/* Non-disk-type devices don't need to blacklist any pages
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 174a447868cd..80a5b366255f 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1936,6 +1936,13 @@ UNUSUAL_DEV(  0x14cd, 0x6600, 0x0201, 0x0201,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
+/* Reported by Michael Büsch &lt;m@bues.ch&gt; */
+UNUSUAL_DEV(  0x152d, 0x0567, 0x0114, 0x0114,
+		"JMicron",
+		"USB to ATA/ATAPI Bridge",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_BROKEN_FUA ),
+
 /* Reported by Alexandre Oliva &lt;oliva@lsd.ic.unicamp.br&gt;
  * JMicron responds to USN and several other SCSI ioctls with a
  * residue that causes subsequent I/O requests to fail.  */
diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h
index 1a64b26046ed..9b7de1b46437 100644
--- a/include/linux/usb_usual.h
+++ b/include/linux/usb_usual.h
@@ -70,7 +70,9 @@
 	US_FLAG(NEEDS_CAP16,	0x00400000)			\
 		/* cannot handle READ_CAPACITY_10 */		\
 	US_FLAG(IGNORE_UAS,	0x00800000)			\
-		/* Device advertises UAS but it is broken */
+		/* Device advertises UAS but it is broken */	\
+	US_FLAG(BROKEN_FUA,	0x01000000)			\
+		/* Cannot handle FUA in WRITE or READ CDBs */	\
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 5853c913d2b0..27ab31017f09 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -173,6 +173,7 @@ struct scsi_device {
 	unsigned is_visible:1;	/* is the device visible in sysfs */
 	unsigned wce_default_on:1;	/* Cache is ON by default */
 	unsigned no_dif:1;	/* T10 PI (DIF) should be disabled */
+	unsigned broken_fua:1;		/* Don't set FUA bit */
 
 	atomic_t disk_events_disable_depth; /* disable depth for disk events */
 </pre><hr><pre>commit 32b36eeae6a859670d2939a7d6136cb5e9ed64f8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 3 11:11:34 2014 -0400

    USB: usbtest: add a timeout for scatter-gather tests
    
    In usbtest, tests 5 - 8 use the scatter-gather library in usbcore
    without any sort of timeout.  If there's a problem in the gadget or
    host controller being tested, the test can hang.
    
    This patch adds a 10-second timeout to the tests, so that they will
    fail gracefully with an ETIMEDOUT error instead of hanging.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Huang Rui &lt;ray.huang@amd.com&gt;
    Tested-by: Huang Rui &lt;ray.huang@amd.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 51a6da256772..829f446064ea 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -7,7 +7,7 @@
 #include &lt;linux/moduleparam.h&gt;
 #include &lt;linux/scatterlist.h&gt;
 #include &lt;linux/mutex.h&gt;
-
+#include &lt;linux/timer.h&gt;
 #include &lt;linux/usb.h&gt;
 
 #define SIMPLE_IO_TIMEOUT	10000	/* in milliseconds */
@@ -484,6 +484,14 @@ alloc_sglist(int nents, int max, int vary)
 	return sg;
 }
 
+static void sg_timeout(unsigned long _req)
+{
+	struct usb_sg_request	*req = (struct usb_sg_request *) _req;
+
+	req-&gt;status = -ETIMEDOUT;
+	usb_sg_cancel(req);
+}
+
 static int perform_sglist(
 	struct usbtest_dev	*tdev,
 	unsigned		iterations,
@@ -495,6 +503,9 @@ static int perform_sglist(
 {
 	struct usb_device	*udev = testdev_to_usbdev(tdev);
 	int			retval = 0;
+	struct timer_list	sg_timer;
+
+	setup_timer_on_stack(&amp;sg_timer, sg_timeout, (unsigned long) req);
 
 	while (retval == 0 &amp;&amp; iterations-- &gt; 0) {
 		retval = usb_sg_init(req, udev, pipe,
@@ -505,7 +516,10 @@ static int perform_sglist(
 
 		if (retval)
 			break;
+		mod_timer(&amp;sg_timer, jiffies +
+				msecs_to_jiffies(SIMPLE_IO_TIMEOUT));
 		usb_sg_wait(req);
+		del_timer_sync(&amp;sg_timer);
 		retval = req-&gt;status;
 
 		/* FIXME check resulting data pattern */</pre><hr><pre>commit b0a50e92bda3c4aeb8017d4e6c6e92146ebd5c9b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 3 11:00:27 2014 -0400

    USB: EHCI: avoid BIOS handover on the HASEE E200
    
    Leandro Liptak reports that his HASEE E200 computer hangs when we ask
    the BIOS to hand over control of the EHCI host controller.  This
    definitely sounds like a bug in the BIOS, but at the moment there is
    no way to fix it.
    
    This patch works around the problem by avoiding the handoff whenever
    the motherboard and BIOS version match those of Leandro's computer.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Leandro Liptak &lt;leandroliptak@gmail.com&gt;
    Tested-by: Leandro Liptak &lt;leandroliptak@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 4a6d3dd68572..2f3acebb577a 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -656,6 +656,14 @@ static const struct dmi_system_id ehci_dmi_nohandoff_table[] = {
 			DMI_MATCH(DMI_BIOS_VERSION, "Lucid-"),
 		},
 	},
+	{
+		/* HASEE E200 */
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "HASEE"),
+			DMI_MATCH(DMI_BOARD_NAME, "E210"),
+			DMI_MATCH(DMI_BIOS_VERSION, "6.00"),
+		},
+	},
 	{ }
 };
 
@@ -665,9 +673,14 @@ static void ehci_bios_handoff(struct pci_dev *pdev,
 {
 	int try_handoff = 1, tried_handoff = 0;
 
-	/* The Pegatron Lucid tablet sporadically waits for 98 seconds trying
-	 * the handoff on its unused controller.  Skip it. */
-	if (pdev-&gt;vendor == 0x8086 &amp;&amp; pdev-&gt;device == 0x283a) {
+	/*
+	 * The Pegatron Lucid tablet sporadically waits for 98 seconds trying
+	 * the handoff on its unused controller.  Skip it.
+	 *
+	 * The HASEE E200 hangs when the semaphore is set (bugzilla #77021).
+	 */
+	if (pdev-&gt;vendor == 0x8086 &amp;&amp; (pdev-&gt;device == 0x283a ||
+			pdev-&gt;device == 0x27cc)) {
 		if (dmi_check_system(ehci_dmi_nohandoff_table))
 			try_handoff = 0;
 	}</pre><hr><pre>commit 600856c231ccb0cbf8afcf09066a8ab2a93ab03d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 18:08:07 2014 -0700

    USB: mutual exclusion for resetting a hub and power-managing a port
    
    The USB core doesn't properly handle mutual exclusion between
    resetting a hub and changing the power states of the hub's ports.  We
    need to avoid sending port-power requests to the hub while it is being
    reset, because such requests cannot succeed.
    
    This patch fixes the problem by keeping track of when a reset is in
    progress.  At such times, attempts to suspend (power-off) a port will
    fail immediately with -EBUSY, and calls to usb_port_runtime_resume()
    will update the power_is_on flag and return immediately.  When the
    reset is complete, hub_activate() will automatically restore each port
    to the proper power state.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 726fa072c3fe..5f43c22ba787 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1276,12 +1276,22 @@ static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)
 		flush_work(&amp;hub-&gt;tt.clear_work);
 }
 
+static void hub_pm_barrier_for_all_ports(struct usb_hub *hub)
+{
+	int i;
+
+	for (i = 0; i &lt; hub-&gt;hdev-&gt;maxchild; ++i)
+		pm_runtime_barrier(&amp;hub-&gt;ports[i]-&gt;dev);
+}
+
 /* caller has locked the hub device */
 static int hub_pre_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
 	hub_quiesce(hub, HUB_PRE_RESET);
+	hub-&gt;in_reset = 1;
+	hub_pm_barrier_for_all_ports(hub);
 	return 0;
 }
 
@@ -1290,6 +1300,8 @@ static int hub_post_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
+	hub-&gt;in_reset = 0;
+	hub_pm_barrier_for_all_ports(hub);
 	hub_activate(hub, HUB_POST_RESET);
 	return 0;
 }
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 33bcb2c6f90a..f9b521e60128 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -66,6 +66,7 @@ struct usb_hub {
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		disconnected:1;
+	unsigned		in_reset:1;
 
 	unsigned		quirk_check_port_auto_suspend:1;
 
diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 51542f852393..37647e080599 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -81,6 +81,10 @@ static int usb_port_runtime_resume(struct device *dev)
 
 	if (!hub)
 		return -EINVAL;
+	if (hub-&gt;in_reset) {
+		port_dev-&gt;power_is_on = 1;
+		return 0;
+	}
 
 	usb_autopm_get_interface(intf);
 	set_bit(port1, hub-&gt;busy_bits);
@@ -117,6 +121,8 @@ static int usb_port_runtime_suspend(struct device *dev)
 
 	if (!hub)
 		return -EINVAL;
+	if (hub-&gt;in_reset)
+		return -EBUSY;
 
 	if (dev_pm_qos_flags(&amp;port_dev-&gt;dev, PM_QOS_FLAG_NO_POWER_OFF)
 			== PM_QOS_FLAGS_ALL)</pre>
    <div class="pagination">
        <a href='2_28.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><span>[29]</span><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_30.html'>Next&gt;&gt;</a>
    <div>
</body>
