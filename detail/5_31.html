<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_30.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><span>[31]</span><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_32.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6724add1b5cfb020ba8f5532efe430d1ccd5fc30
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Aug 15 01:38:30 2007 -0500

    [SCSI] libiscsi: sync up iscsi and scsi eh's access to the connection
    
    The iscsi eh could be tearing down the session/connection while
    the scsi eh is still sending task management functions. If when
    we drop the session lock to grab the recv lock, the iscsi eh
    tears down the connection we will oops.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index f5915d4d63d9..efceed451b46 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1056,7 +1056,9 @@ static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
 	ctask-&gt;mtask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)hdr,
 					    NULL, 0);
 	if (!ctask-&gt;mtask) {
+		spin_unlock_bh(&amp;session-&gt;lock);
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		spin_lock_bh(&amp;session-&gt;lock)
 		debug_scsi("abort sent failure [itt 0x%x]\n", ctask-&gt;itt);
 		return -EPERM;
 	}
@@ -1073,6 +1075,7 @@ static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
 		debug_scsi("abort set timeout [itt 0x%x]\n", ctask-&gt;itt);
 	}
 	spin_unlock_bh(&amp;session-&gt;lock);
+	mutex_unlock(&amp;session-&gt;eh_mutex);
 	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
 
 	/*
@@ -1090,6 +1093,7 @@ static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
 	if (signal_pending(current))
 		flush_signals(current);
 	del_timer_sync(&amp;conn-&gt;tmabort_timer);
+	mutex_lock(&amp;session-&gt;eh_mutex);
 	spin_lock_bh(&amp;session-&gt;lock);
 	return 0;
 }
@@ -1165,31 +1169,45 @@ static void fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	__iscsi_put_ctask(ctask);
 }
 
+static void iscsi_suspend_tx(struct iscsi_conn *conn)
+{
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	scsi_flush_work(conn-&gt;session-&gt;host);
+}
+
+static void iscsi_start_tx(struct iscsi_conn *conn)
+{
+	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
+}
+
 int iscsi_eh_abort(struct scsi_cmnd *sc)
 {
+	struct Scsi_Host *host = sc-&gt;device-&gt;host;
+	struct iscsi_session *session = iscsi_hostdata(host-&gt;hostdata);
 	struct iscsi_cmd_task *ctask;
 	struct iscsi_conn *conn;
-	struct iscsi_session *session;
 	int rc;
 
+	mutex_lock(&amp;session-&gt;eh_mutex);
+	spin_lock_bh(&amp;session-&gt;lock);
 	/*
 	 * if session was ISCSI_STATE_IN_RECOVERY then we may not have
 	 * got the command.
 	 */
 	if (!sc-&gt;SCp.ptr) {
 		debug_scsi("sc never reached iscsi layer or it completed.\n");
+		spin_unlock_bh(&amp;session-&gt;lock);
+		mutex_unlock(&amp;session-&gt;eh_mutex);
 		return SUCCESS;
 	}
 
 	ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
 	conn = ctask-&gt;conn;
-	session = conn-&gt;session;
 
 	conn-&gt;eh_abort_cnt++;
 	debug_scsi("aborting [sc %p itt 0x%x]\n", sc, ctask-&gt;itt);
 
-	spin_lock_bh(&amp;session-&gt;lock);
-
 	/*
 	 * If we are not logged in or we have started a new session
 	 * then let the host reset code handle this
@@ -1226,6 +1244,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	switch (conn-&gt;tmabort_state) {
 	case TMABORT_SUCCESS:
 		spin_unlock_bh(&amp;session-&gt;lock);
+		iscsi_suspend_tx(conn);
 		/*
 		 * clean up task if aborted. grab the recv lock as a writer
 		 */
@@ -1234,11 +1253,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 		fail_command(conn, ctask, DID_ABORT &lt;&lt; 16);
 		spin_unlock(&amp;session-&gt;lock);
 		write_unlock_bh(conn-&gt;recv_lock);
-		/*
-		 * make sure xmit thread is not still touching the
-		 * ctask/scsi_cmnd
-		 */
-		scsi_flush_work(session-&gt;host);
+		iscsi_start_tx(conn);
 		goto success_unlocked;
 	case TMABORT_NOT_FOUND:
 		if (!ctask-&gt;sc) {
@@ -1258,12 +1273,14 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	spin_unlock_bh(&amp;session-&gt;lock);
 success_unlocked:
 	debug_scsi("abort success [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
+	mutex_unlock(&amp;session-&gt;eh_mutex);
 	return SUCCESS;
 
 failed:
 	spin_unlock_bh(&amp;session-&gt;lock);
 failed_unlocked:
 	debug_scsi("abort failed [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
+	mutex_unlock(&amp;session-&gt;eh_mutex);
 	return FAILED;
 }
 EXPORT_SYMBOL_GPL(iscsi_eh_abort);
@@ -1410,6 +1427,7 @@ iscsi_session_setup(struct iscsi_transport *iscsit,
 	session-&gt;max_cmdsn = initial_cmdsn + 1;
 	session-&gt;max_r2t = 1;
 	session-&gt;tt = iscsit;
+	mutex_init(&amp;session-&gt;eh_mutex);
 
 	/* initialize SCSI PDU commands pool */
 	if (iscsi_pool_init(&amp;session-&gt;cmdpool, session-&gt;cmds_max,
@@ -1743,9 +1761,22 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 {
 	int old_stop_stage;
 
+	mutex_lock(&amp;session-&gt;eh_mutex);
 	spin_lock_bh(&amp;session-&gt;lock);
 	if (conn-&gt;stop_stage == STOP_CONN_TERM) {
 		spin_unlock_bh(&amp;session-&gt;lock);
+		mutex_unlock(&amp;session-&gt;eh_mutex);
+		return;
+	}
+
+	/*
+	 * The LLD either freed/unset the lock on us, or userspace called
+	 * stop but did not create a proper connection (connection was never
+	 * bound or it was unbound then stop was called).
+	 */
+	if (!conn-&gt;recv_lock) {
+		spin_unlock_bh(&amp;session-&gt;lock);
+		mutex_unlock(&amp;session-&gt;eh_mutex);
 		return;
 	}
 
@@ -1762,9 +1793,9 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 	old_stop_stage = conn-&gt;stop_stage;
 	conn-&gt;stop_stage = flag;
 	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
-	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	spin_unlock_bh(&amp;session-&gt;lock);
-	scsi_flush_work(session-&gt;host);
+
+	iscsi_suspend_tx(conn);
 
 	write_lock_bh(conn-&gt;recv_lock);
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
@@ -1793,6 +1824,7 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 	fail_all_commands(conn);
 	flush_control_queues(session, conn);
 	spin_unlock_bh(&amp;session-&gt;lock);
+	mutex_unlock(&amp;session-&gt;eh_mutex);
 }
 
 void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 007d442412e2..b4b31132618b 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -205,6 +205,13 @@ struct iscsi_queue {
 };
 
 struct iscsi_session {
+	/*
+	 * Syncs up the scsi eh thread with the iscsi eh thread when sending
+	 * task management functions. This must be taken before the session
+	 * and recv lock.
+	 */
+	struct mutex		eh_mutex;
+
 	/* iSCSI session-wide sequencing */
 	uint32_t		cmdsn;
 	uint32_t		exp_cmdsn;</pre><hr><pre>commit 96809f1b15eddae2325b2ab78e6f931edc969074
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Aug 15 01:38:29 2007 -0500

    [SCSI] libiscsi: fix null ptr regression when aborting a command with data to transfer
    
    We do not want to send data if we are aborting a task. There is
    a check in iscsi_xmit_ctask, but right before calling this we overwrite
    the state so we always go right past the test. Sending data causes problems
    because when we clean up from a successful abort the LLD assumes that
    the task is not running.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 5606d1e62978..f5915d4d63d9 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -737,12 +737,19 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		 */
 		conn-&gt;ctask = list_entry(conn-&gt;xmitqueue.next,
 					 struct iscsi_cmd_task, running);
-		if (conn-&gt;ctask-&gt;state == ISCSI_TASK_PENDING) {
+		switch (conn-&gt;ctask-&gt;state) {
+		case ISCSI_TASK_ABORTING:
+			break;
+		case ISCSI_TASK_PENDING:
 			iscsi_prep_scsi_cmd_pdu(conn-&gt;ctask);
 			conn-&gt;session-&gt;tt-&gt;init_cmd_task(conn-&gt;ctask);
+			/* fall through */
+		default:
+			conn-&gt;ctask-&gt;state = ISCSI_TASK_RUNNING;
+			break;
 		}
-		conn-&gt;ctask-&gt;state = ISCSI_TASK_RUNNING;
 		list_move_tail(conn-&gt;xmitqueue.next, &amp;conn-&gt;run_list);
+
 		rc = iscsi_xmit_ctask(conn);
 		if (rc)
 			goto again;</pre><hr><pre>commit b6d44fe9582b9d90a0b16f508ac08a90d899bf56
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jul 26 12:46:47 2007 -0500

    [SCSI] iscsi_tcp: Turn off bounce buffers
    
    It was found by LSI that on setups with large amounts of memory
    we were bouncing buffers when we did not need to. If the iscsi tcp
    code touches the data buffer (or a helper does),
    it will kmap the buffer. iscsi_tcp also does not interact with hardware,
    so it does not have any hw dma restrictions. This patch sets the bounce
    buffer settings for our device queue so buffers should not be bounced
    because of a driver limit.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 93034b43effc..a21455d0274c 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -2216,6 +2216,7 @@ static void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session)
 
 static int iscsi_tcp_slave_configure(struct scsi_device *sdev)
 {
+	blk_queue_bounce_limit(sdev-&gt;request_queue, BLK_BOUNCE_ANY);
 	blk_queue_dma_alignment(sdev-&gt;request_queue, 0);
 	return 0;
 }</pre><hr><pre>commit e07264071f7f2b02a2973cb28d9fdf5eb8866cc1
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jul 26 12:46:48 2007 -0500

    [SCSI] libiscsi: fix cmd seqeunce number checking
    
    We should not be checking the cmd windown for just handling r2t responses.
    And if the window closes in on us, always have scsi-ml requeue the command
    from our queuecommand function.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 271a2d671b89..5606d1e62978 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -596,9 +596,16 @@ static void iscsi_prep_mtask(struct iscsi_conn *conn,
 	nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	if (hdr-&gt;itt != RESERVED_ITT) {
 		hdr-&gt;itt = build_itt(mtask-&gt;itt, conn-&gt;id, session-&gt;age);
+		/*
+		 * TODO: We always use immediate, so we never hit this.
+		 * If we start to send tmfs or nops as non-immediate then
+		 * we should start checking the cmdsn numbers for mgmt tasks.
+		 */
 		if (conn-&gt;c_stage == ISCSI_CONN_STARTED &amp;&amp;
-		    !(hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE))
+		    !(hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE)) {
+			session-&gt;queued_cmdsn++;
 			session-&gt;cmdsn++;
+		}
 	}
 
 	if (session-&gt;tt-&gt;init_mgmt_task)
@@ -641,9 +648,11 @@ static int iscsi_check_cmdsn_window_closed(struct iscsi_conn *conn)
 	/*
 	 * Check for iSCSI window and take care of CmdSN wrap-around
 	 */
-	if (!iscsi_sna_lte(session-&gt;cmdsn, session-&gt;max_cmdsn)) {
-		debug_scsi("iSCSI CmdSN closed. MaxCmdSN %u CmdSN %u\n",
-			   session-&gt;max_cmdsn, session-&gt;cmdsn);
+	if (!iscsi_sna_lte(session-&gt;queued_cmdsn, session-&gt;max_cmdsn)) {
+		debug_scsi("iSCSI CmdSN closed. ExpCmdSn %u MaxCmdSN %u "
+			   "CmdSN %u/%u\n", session-&gt;exp_cmdsn,
+			   session-&gt;max_cmdsn, session-&gt;cmdsn,
+			   session-&gt;queued_cmdsn);
 		return -ENOSPC;
 	}
 	return 0;
@@ -722,11 +731,6 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 
 	/* process command queue */
 	while (!list_empty(&amp;conn-&gt;xmitqueue)) {
-		rc = iscsi_check_cmdsn_window_closed(conn);
-		if (rc) {
-			spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-			return rc;
-		}
 		/*
 		 * iscsi tcp may readd the task to the xmitqueue to send
 		 * write data
@@ -834,12 +838,6 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 		goto fault;
 	}
 
-	/*
-	 * We check this here and in data xmit, because if we get to the point
-	 * that this check is hitting the window then we have enough IO in
-	 * flight and enough IO waiting to be transmitted it is better
-	 * to let the scsi/block layer queue up.
-	 */
 	if (iscsi_check_cmdsn_window_closed(conn)) {
 		reason = FAILURE_WINDOW_CLOSED;
 		goto reject;
@@ -850,6 +848,8 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 		reason = FAILURE_OOM;
 		goto reject;
 	}
+	session-&gt;queued_cmdsn++;
+
 	sc-&gt;SCp.phase = session-&gt;age;
 	sc-&gt;SCp.ptr = (char *)ctask;
 
@@ -1140,7 +1140,13 @@ static void fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	if (!sc)
 		return;
 
-	if (ctask-&gt;state != ISCSI_TASK_PENDING)
+	if (ctask-&gt;state == ISCSI_TASK_PENDING)
+		/*
+		 * cmd never made it to the xmit thread, so we should not count
+		 * the cmd in the sequencing
+		 */
+		conn-&gt;session-&gt;queued_cmdsn--;
+	else
 		conn-&gt;session-&gt;tt-&gt;cleanup_cmd_task(conn, ctask);
 	iscsi_ctask_mtask_cleanup(ctask);
 
@@ -1392,7 +1398,7 @@ iscsi_session_setup(struct iscsi_transport *iscsit,
 	session-&gt;state = ISCSI_STATE_FREE;
 	session-&gt;mgmtpool_max = ISCSI_MGMT_CMDS_MAX;
 	session-&gt;cmds_max = cmds_max;
-	session-&gt;cmdsn = initial_cmdsn;
+	session-&gt;queued_cmdsn = session-&gt;cmdsn = initial_cmdsn;
 	session-&gt;exp_cmdsn = initial_cmdsn + 1;
 	session-&gt;max_cmdsn = initial_cmdsn + 1;
 	session-&gt;max_r2t = 1;
@@ -1616,11 +1622,8 @@ void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
 	kfree(conn-&gt;persistent_address);
 	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
 		    sizeof(void*));
-	if (session-&gt;leadconn == conn) {
+	if (session-&gt;leadconn == conn)
 		session-&gt;leadconn = NULL;
-		/* no connections exits.. reset sequencing */
-		session-&gt;cmdsn = session-&gt;max_cmdsn = session-&gt;exp_cmdsn = 1;
-	}
 	spin_unlock_bh(&amp;session-&gt;lock);
 
 	kfifo_free(conn-&gt;mgmtqueue);
@@ -1650,6 +1653,7 @@ int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 	spin_lock_bh(&amp;session-&gt;lock);
 	conn-&gt;c_stage = ISCSI_CONN_STARTED;
 	session-&gt;state = ISCSI_STATE_LOGGED_IN;
+	session-&gt;queued_cmdsn = session-&gt;cmdsn;
 
 	switch(conn-&gt;stop_stage) {
 	case STOP_CONN_RECOVER:
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 3f631b08a1ab..007d442412e2 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -210,6 +210,9 @@ struct iscsi_session {
 	uint32_t		exp_cmdsn;
 	uint32_t		max_cmdsn;
 
+	/* This tracks the reqs queued into the initiator */
+	uint32_t		queued_cmdsn;
+
 	/* configuration */
 	int			initial_r2t_en;
 	unsigned		max_r2t;</pre><hr><pre>commit 7974392c0b0d4e7a2a17ca3597d51a29b9841aa5
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jul 26 12:46:46 2007 -0500

    [SCSI] iscsi_tcp, ib_iser Enable module refcounting for iscsi host template
    
    This prevents the iscsi modules from being unloaded while
    there are active mounts from an iscsi target.
    
    Signed-off-by: Olaf Kirch &lt;olaf.kirch@oracle.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 5db314380271..bad8dacafd10 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -548,6 +548,7 @@ iscsi_iser_ep_disconnect(__u64 ep_handle)
 }
 
 static struct scsi_host_template iscsi_iser_sht = {
+	.module                 = THIS_MODULE,
 	.name                   = "iSCSI Initiator over iSER, v." DRV_VER,
 	.queuecommand           = iscsi_queuecommand,
 	.can_queue		= ISCSI_DEF_XMIT_CMDS_MAX - 1,
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 7829ab1e2fb4..93034b43effc 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -2221,6 +2221,7 @@ static int iscsi_tcp_slave_configure(struct scsi_device *sdev)
 }
 
 static struct scsi_host_template iscsi_sht = {
+	.module			= THIS_MODULE,
 	.name			= "iSCSI Initiator over TCP/IP",
 	.queuecommand           = iscsi_queuecommand,
 	.change_queue_depth	= iscsi_change_queue_depth,</pre><hr><pre>commit 464bb99ea448dc2f017be9150a8be9ab1f021979
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jul 26 12:46:45 2007 -0500

    [SCSI] libiscsi: make sure session is not blocked when removing host
    
    When we logout we block the session since we are not taking any more
    commands, but when we call remove host we want to make sure any
    IO that got queued up and blocked gets failed upwards quickly, so
    we unblock the session and fail it.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 4d85ce100192..271a2d671b89 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1473,6 +1473,7 @@ void iscsi_session_teardown(struct iscsi_cls_session *cls_session)
 	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
 	struct module *owner = cls_session-&gt;transport-&gt;owner;
 
+	iscsi_unblock_session(cls_session);
 	scsi_remove_host(shost);
 
 	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);</pre><hr><pre>commit d8196ed2181b4595eaf464a5bcbddb6c28649a39
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 30 12:57:25 2007 -0500

    [SCSI] iscsi class, iscsi_tcp, iser, qla4xxx: add netdevname sysfs attr
    
    iSCSI must support software iscsi (iscsi_tcp, iser), hardware iscsi (qla4xxx),
    and partial offload (broadcom). To be able to allow each stack or driver
    or port (virtual or physical) to be able to log into the same target portal
    we use the initiator tuple [[HWADDRESS | NETDEVNAME], INITIATOR_NAME] and
    the target tuple [TARGETNAME, CONN_ADDRESS, CONN_PORT] to id a session.
    This patch adds the netdev name, which is used by software iscsi when
    it binds a session to a netdevice using the SO_BINDTODEVICE sock opt.
    It cannot use HWADDRESS because if someone did vlans then the same netdevice
    will have the same mac and the initiator,target id will not be unique.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: Roland Dreier &lt;rdreier@cisco.com&gt;
    Cc: David C Somayajulu &lt;david.somayajulu@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index bed583c426e6..1bf173decade 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -583,6 +583,7 @@ static struct iscsi_transport iscsi_iser_transport = {
 				  ISCSI_USERNAME | ISCSI_PASSWORD |
 				  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS |
+				  ISCSI_HOST_NETDEV_NAME |
 				  ISCSI_HOST_INITIATOR_NAME,
 	.host_template          = &amp;iscsi_iser_sht,
 	.conndata_size		= sizeof(struct iscsi_conn),
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index da66fb524b5b..d5a6527b3b3d 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -2303,7 +2303,8 @@ static struct iscsi_transport iscsi_tcp_transport = {
 				  ISCSI_USERNAME | ISCSI_PASSWORD |
 				  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS | ISCSI_HOST_IPADDRESS |
-				  ISCSI_HOST_INITIATOR_NAME,
+				  ISCSI_HOST_INITIATOR_NAME |
+				  ISCSI_HOST_NETDEV_NAME,
 	.host_template		= &amp;iscsi_sht,
 	.conndata_size		= sizeof(struct iscsi_conn),
 	.max_conn		= 1,
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 1632866f52cc..865dd5739f0e 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1483,6 +1483,7 @@ void iscsi_session_teardown(struct iscsi_cls_session *cls_session)
 	kfree(session-&gt;username);
 	kfree(session-&gt;username_in);
 	kfree(session-&gt;targetname);
+	kfree(session-&gt;netdev);
 	kfree(session-&gt;hwaddress);
 	kfree(session-&gt;initiatorname);
 
@@ -2040,6 +2041,12 @@ int iscsi_host_get_param(struct Scsi_Host *shost, enum iscsi_host_param param,
 	int len;
 
 	switch (param) {
+	case ISCSI_HOST_PARAM_NETDEV_NAME:
+		if (!session-&gt;netdev)
+			len = sprintf(buf, "%s\n", "default");
+		else
+			len = sprintf(buf, "%s\n", session-&gt;netdev);
+		break;
 	case ISCSI_HOST_PARAM_HWADDRESS:
 		if (!session-&gt;hwaddress)
 			len = sprintf(buf, "%s\n", "default");
@@ -2067,6 +2074,10 @@ int iscsi_host_set_param(struct Scsi_Host *shost, enum iscsi_host_param param,
 	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
 
 	switch (param) {
+	case ISCSI_HOST_PARAM_NETDEV_NAME:
+		if (!session-&gt;netdev)
+			session-&gt;netdev = kstrdup(buf, GFP_KERNEL);
+		break;
 	case ISCSI_HOST_PARAM_HWADDRESS:
 		if (!session-&gt;hwaddress)
 			session-&gt;hwaddress = kstrdup(buf, GFP_KERNEL);
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index b87b460832ea..e69160a7bc60 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -102,7 +102,8 @@ static struct scsi_host_template qla4xxx_driver_template = {
 static struct iscsi_transport qla4xxx_iscsi_transport = {
 	.owner			= THIS_MODULE,
 	.name			= DRIVER_NAME,
-	.caps			= CAP_FW_DB | CAP_SENDTARGETS_OFFLOAD,
+	.caps			= CAP_FW_DB | CAP_SENDTARGETS_OFFLOAD |
+				  CAP_DATA_PATH_OFFLOAD,
 	.param_mask		= ISCSI_CONN_PORT | ISCSI_CONN_ADDRESS |
 				  ISCSI_TARGET_NAME | ISCSI_TPGT,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS |
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 9b54eea20560..34c1860a259d 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -32,7 +32,7 @@
 
 #define ISCSI_SESSION_ATTRS 15
 #define ISCSI_CONN_ATTRS 11
-#define ISCSI_HOST_ATTRS 3
+#define ISCSI_HOST_ATTRS 4
 #define ISCSI_TRANSPORT_VERSION "2.0-724"
 
 struct iscsi_internal {
@@ -1261,8 +1261,9 @@ show_host_param_##param(struct class_device *cdev, char *buf)		\
 static ISCSI_CLASS_ATTR(host, field, S_IRUGO, show_host_param_##param,	\
 			NULL);
 
-iscsi_host_attr(ipaddress, ISCSI_HOST_PARAM_IPADDRESS);
+iscsi_host_attr(netdev, ISCSI_HOST_PARAM_NETDEV_NAME);
 iscsi_host_attr(hwaddress, ISCSI_HOST_PARAM_HWADDRESS);
+iscsi_host_attr(ipaddress, ISCSI_HOST_PARAM_IPADDRESS);
 iscsi_host_attr(initiatorname, ISCSI_HOST_PARAM_INITIATOR_NAME);
 
 #define SETUP_PRIV_SESSION_RD_ATTR(field)				\
@@ -1399,6 +1400,7 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	priv-&gt;t.host_size = sizeof(struct iscsi_host);
 	transport_container_register(&amp;priv-&gt;t.host_attrs);
 
+	SETUP_HOST_RD_ATTR(netdev, ISCSI_HOST_NETDEV_NAME);
 	SETUP_HOST_RD_ATTR(ipaddress, ISCSI_HOST_IPADDRESS);
 	SETUP_HOST_RD_ATTR(hwaddress, ISCSI_HOST_HWADDRESS);
 	SETUP_HOST_RD_ATTR(initiatorname, ISCSI_HOST_INITIATOR_NAME);
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 642998069e00..50e907f42048 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -271,12 +271,14 @@ enum iscsi_param {
 enum iscsi_host_param {
 	ISCSI_HOST_PARAM_HWADDRESS,
 	ISCSI_HOST_PARAM_INITIATOR_NAME,
+	ISCSI_HOST_PARAM_NETDEV_NAME,
 	ISCSI_HOST_PARAM_IPADDRESS,
 	ISCSI_HOST_PARAM_MAX,
 };
 
 #define ISCSI_HOST_HWADDRESS		(1 &lt;&lt; ISCSI_HOST_PARAM_HWADDRESS)
 #define ISCSI_HOST_INITIATOR_NAME	(1 &lt;&lt; ISCSI_HOST_PARAM_INITIATOR_NAME)
+#define ISCSI_HOST_NETDEV_NAME		(1 &lt;&lt; ISCSI_HOST_PARAM_NETDEV_NAME)
 #define ISCSI_HOST_IPADDRESS		(1 &lt;&lt; ISCSI_HOST_PARAM_IPADDRESS)
 
 #define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
@@ -303,6 +305,7 @@ enum iscsi_host_param {
 #define CAP_MARKERS		0x100
 #define CAP_FW_DB		0x200
 #define CAP_SENDTARGETS_OFFLOAD	0x400
+#define CAP_DATA_PATH_OFFLOAD	0x800
 
 /*
  * These flags describes reason of stop_conn() call
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index eea33f7b1544..3f631b08a1ab 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -228,8 +228,9 @@ struct iscsi_session {
 	char			*password_in;
 	char			*targetname;
 	char			*initiatorname;
-	/* hw address being used for iscsi connection */
+	/* hw address or netdev iscsi connection is bound to */
 	char			*hwaddress;
+	char			*netdev;
 	/* control data */
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;</pre><hr><pre>commit 2223696192c687f2853e42b7c1e0d3ef002081fd
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 30 12:57:24 2007 -0500

    [SCSI] iscsi class, qla4xxx, iscsi_tcp: export local address
    
    This patch exports the local address for the session. For
    qla4xxx this is the ip of the hba's port. For software
    this is the src addr of the socket.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: David C Somayajulu &lt;david.somayajulu@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 7ce177e30a53..da66fb524b5b 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1870,18 +1870,22 @@ iscsi_tcp_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 static void
 iscsi_tcp_release_conn(struct iscsi_conn *conn)
 {
+	struct iscsi_session *session = conn-&gt;session;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct socket *sock = tcp_conn-&gt;sock;
 
-	if (!tcp_conn-&gt;sock)
+	if (!sock)
 		return;
 
-	sock_hold(tcp_conn-&gt;sock-&gt;sk);
+	sock_hold(sock-&gt;sk);
 	iscsi_conn_restore_callbacks(tcp_conn);
-	sock_put(tcp_conn-&gt;sock-&gt;sk);
+	sock_put(sock-&gt;sk);
 
-	sockfd_put(tcp_conn-&gt;sock);
+	spin_lock_bh(&amp;session-&gt;lock);
 	tcp_conn-&gt;sock = NULL;
 	conn-&gt;recv_lock = NULL;
+	spin_unlock_bh(&amp;session-&gt;lock);
+	sockfd_put(sock);
 }
 
 static void
@@ -1912,6 +1916,46 @@ iscsi_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	tcp_conn-&gt;hdr_size = sizeof(struct iscsi_hdr);
 }
 
+static int iscsi_tcp_get_addr(struct iscsi_conn *conn, struct socket *sock,
+			      char *buf, int *port,
+			      int (*getname)(struct socket *, struct sockaddr *,
+					int *addrlen))
+{
+	struct sockaddr_storage *addr;
+	struct sockaddr_in6 *sin6;
+	struct sockaddr_in *sin;
+	int rc = 0, len;
+
+	addr = kmalloc(GFP_KERNEL, sizeof(*addr));
+	if (!addr)
+		return -ENOMEM;
+
+	if (getname(sock, (struct sockaddr *) addr, &amp;len)) {
+		rc = -ENODEV;
+		goto free_addr;
+	}
+
+	switch (addr-&gt;ss_family) {
+	case AF_INET:
+		sin = (struct sockaddr_in *)addr;
+		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
+		sprintf(buf, NIPQUAD_FMT, NIPQUAD(sin-&gt;sin_addr.s_addr));
+		*port = be16_to_cpu(sin-&gt;sin_port);
+		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
+		break;
+	case AF_INET6:
+		sin6 = (struct sockaddr_in6 *)addr;
+		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
+		sprintf(buf, NIP6_FMT, NIP6(sin6-&gt;sin6_addr));
+		*port = be16_to_cpu(sin6-&gt;sin6_port);
+		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
+		break;
+	}
+free_addr:
+	kfree(addr);
+	return rc;
+}
+
 static int
 iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 		    struct iscsi_cls_conn *cls_conn, uint64_t transport_eph,
@@ -1929,10 +1973,24 @@ iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 		printk(KERN_ERR "iscsi_tcp: sockfd_lookup failed %d\n", err);
 		return -EEXIST;
 	}
+	/*
+	 * copy these values now because if we drop the session
+	 * userspace may still want to query the values since we will
+	 * be using them for the reconnect
+	 */
+	err = iscsi_tcp_get_addr(conn, sock, conn-&gt;portal_address,
+				 &amp;conn-&gt;portal_port, kernel_getpeername);
+	if (err)
+		goto free_socket;
+
+	err = iscsi_tcp_get_addr(conn, sock, conn-&gt;local_address,
+				&amp;conn-&gt;local_port, kernel_getsockname);
+	if (err)
+		goto free_socket;
 
 	err = iscsi_conn_bind(cls_session, cls_conn, is_leading);
 	if (err)
-		return err;
+		goto free_socket;
 
 	/* bind iSCSI connection and socket */
 	tcp_conn-&gt;sock = sock;
@@ -1956,8 +2014,11 @@ iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 	 * set receive state machine into initial state
 	 */
 	tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
-
 	return 0;
+
+free_socket:
+	sockfd_put(sock);
+	return err;
 }
 
 /* called with host lock */
@@ -2077,33 +2138,18 @@ iscsi_tcp_conn_get_param(struct iscsi_cls_conn *cls_conn,
 			 enum iscsi_param param, char *buf)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
-	struct inet_sock *inet;
-	struct ipv6_pinfo *np;
-	struct sock *sk;
 	int len;
 
 	switch(param) {
 	case ISCSI_PARAM_CONN_PORT:
-		if (!tcp_conn-&gt;sock)
-			return -EINVAL;
-
-		inet = inet_sk(tcp_conn-&gt;sock-&gt;sk);
-		len = sprintf(buf, "%hu\n", be16_to_cpu(inet-&gt;dport));
+		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
+		len = sprintf(buf, "%hu\n", conn-&gt;portal_port);
+		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 		break;
 	case ISCSI_PARAM_CONN_ADDRESS:
-		if (!tcp_conn-&gt;sock)
-			return -EINVAL;
-
-		sk = tcp_conn-&gt;sock-&gt;sk;
-		if (sk-&gt;sk_family == PF_INET) {
-			inet = inet_sk(sk);
-			len = sprintf(buf, NIPQUAD_FMT "\n",
-				      NIPQUAD(inet-&gt;daddr));
-		} else {
-			np = inet6_sk(sk);
-			len = sprintf(buf, NIP6_FMT "\n", NIP6(np-&gt;daddr));
-		}
+		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
+		len = sprintf(buf, "%s\n", conn-&gt;portal_address);
+		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 		break;
 	default:
 		return iscsi_conn_get_param(cls_conn, param, buf);
@@ -2112,6 +2158,29 @@ iscsi_tcp_conn_get_param(struct iscsi_cls_conn *cls_conn,
 	return len;
 }
 
+static int
+iscsi_tcp_host_get_param(struct Scsi_Host *shost, enum iscsi_host_param param,
+			 char *buf)
+{
+        struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	int len;
+
+	switch (param) {
+	case ISCSI_HOST_PARAM_IPADDRESS:
+		spin_lock_bh(&amp;session-&gt;lock);
+		if (!session-&gt;leadconn)
+			len = -ENODEV;
+		else
+			len = sprintf(buf, "%s\n",
+				     session-&gt;leadconn-&gt;local_address);
+		spin_unlock_bh(&amp;session-&gt;lock);
+		break;
+	default:
+		return iscsi_host_get_param(shost, param, buf);
+	}
+	return len;
+}
+
 static void
 iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
 {
@@ -2233,7 +2302,7 @@ static struct iscsi_transport iscsi_tcp_transport = {
 				  ISCSI_TARGET_NAME | ISCSI_TPGT |
 				  ISCSI_USERNAME | ISCSI_PASSWORD |
 				  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN,
-	.host_param_mask	= ISCSI_HOST_HWADDRESS |
+	.host_param_mask	= ISCSI_HOST_HWADDRESS | ISCSI_HOST_IPADDRESS |
 				  ISCSI_HOST_INITIATOR_NAME,
 	.host_template		= &amp;iscsi_sht,
 	.conndata_size		= sizeof(struct iscsi_conn),
@@ -2252,7 +2321,7 @@ static struct iscsi_transport iscsi_tcp_transport = {
 	.start_conn		= iscsi_conn_start,
 	.stop_conn		= iscsi_tcp_conn_stop,
 	/* iscsi host params */
-	.get_host_param		= iscsi_host_get_param,
+	.get_host_param		= iscsi_tcp_host_get_param,
 	.set_host_param		= iscsi_host_set_param,
 	/* IO */
 	.send_pdu		= iscsi_conn_send_pdu,
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 315ab691056f..b87b460832ea 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -106,6 +106,7 @@ static struct iscsi_transport qla4xxx_iscsi_transport = {
 	.param_mask		= ISCSI_CONN_PORT | ISCSI_CONN_ADDRESS |
 				  ISCSI_TARGET_NAME | ISCSI_TPGT,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS |
+				  ISCSI_HOST_IPADDRESS |
 				  ISCSI_HOST_INITIATOR_NAME,
 	.sessiondata_size	= sizeof(struct ddb_entry),
 	.host_template		= &amp;qla4xxx_driver_template,
@@ -192,8 +193,13 @@ static int qla4xxx_host_get_param(struct Scsi_Host *shost,
 	case ISCSI_HOST_PARAM_HWADDRESS:
 		len = format_addr(buf, ha-&gt;my_mac, MAC_ADDR_LEN);
 		break;
+	case ISCSI_HOST_PARAM_IPADDRESS:
+		len = sprintf(buf, "%d.%d.%d.%d\n", ha-&gt;ip_address[0],
+			      ha-&gt;ip_address[1], ha-&gt;ip_address[2],
+			      ha-&gt;ip_address[3]);
+		break;
 	case ISCSI_HOST_PARAM_INITIATOR_NAME:
-		len = sprintf(buf, ha-&gt;name_string);
+		len = sprintf(buf, "%s\n", ha-&gt;name_string);
 		break;
 	default:
 		return -ENOSYS;
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 859bd2100856..9b54eea20560 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -32,7 +32,7 @@
 
 #define ISCSI_SESSION_ATTRS 15
 #define ISCSI_CONN_ATTRS 11
-#define ISCSI_HOST_ATTRS 2
+#define ISCSI_HOST_ATTRS 3
 #define ISCSI_TRANSPORT_VERSION "2.0-724"
 
 struct iscsi_internal {
@@ -1261,6 +1261,7 @@ show_host_param_##param(struct class_device *cdev, char *buf)		\
 static ISCSI_CLASS_ATTR(host, field, S_IRUGO, show_host_param_##param,	\
 			NULL);
 
+iscsi_host_attr(ipaddress, ISCSI_HOST_PARAM_IPADDRESS);
 iscsi_host_attr(hwaddress, ISCSI_HOST_PARAM_HWADDRESS);
 iscsi_host_attr(initiatorname, ISCSI_HOST_PARAM_INITIATOR_NAME);
 
@@ -1398,6 +1399,7 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	priv-&gt;t.host_size = sizeof(struct iscsi_host);
 	transport_container_register(&amp;priv-&gt;t.host_attrs);
 
+	SETUP_HOST_RD_ATTR(ipaddress, ISCSI_HOST_IPADDRESS);
 	SETUP_HOST_RD_ATTR(hwaddress, ISCSI_HOST_HWADDRESS);
 	SETUP_HOST_RD_ATTR(initiatorname, ISCSI_HOST_INITIATOR_NAME);
 	BUG_ON(count &gt; ISCSI_HOST_ATTRS);
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 81a542506dfe..642998069e00 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -271,11 +271,13 @@ enum iscsi_param {
 enum iscsi_host_param {
 	ISCSI_HOST_PARAM_HWADDRESS,
 	ISCSI_HOST_PARAM_INITIATOR_NAME,
+	ISCSI_HOST_PARAM_IPADDRESS,
 	ISCSI_HOST_PARAM_MAX,
 };
 
 #define ISCSI_HOST_HWADDRESS		(1 &lt;&lt; ISCSI_HOST_PARAM_HWADDRESS)
 #define ISCSI_HOST_INITIATOR_NAME	(1 &lt;&lt; ISCSI_HOST_PARAM_INITIATOR_NAME)
+#define ISCSI_HOST_IPADDRESS		(1 &lt;&lt; ISCSI_HOST_PARAM_IPADDRESS)
 
 #define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
 #define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 2f303a3b270e..eea33f7b1544 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -72,6 +72,8 @@ struct iscsi_nopin;
 #define ISCSI_AGE_SHIFT			28
 #define ISCSI_AGE_MASK			(0xf &lt;&lt; ISCSI_AGE_SHIFT)
 
+#define ISCSI_ADDRESS_BUF_LEN		64
+
 struct iscsi_mgmt_task {
 	/*
 	 * Becuae LLDs allocate their hdr differently, this is a pointer to
@@ -174,6 +176,12 @@ struct iscsi_conn {
 	/* values userspace uses to id a conn */
 	int			persistent_port;
 	char			*persistent_address;
+	/* remote portal currently connected to */
+	int			portal_port;
+	char			portal_address[ISCSI_ADDRESS_BUF_LEN];
+	/* local address */
+	int			local_port;
+	char			local_address[ISCSI_ADDRESS_BUF_LEN];
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;</pre><hr><pre>commit 4e7aba73f9f6e9fe6d3fa10d3fd63cd4882ba3d0
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 30 12:57:23 2007 -0500

    [SCSI] iscsi_tcp: fix fd leak
    
    This patch should fix the file descriptor leak problem. A quick look
    through the kernel shows that users of sockfd_lookup use sockfd_put to
    release their handle. We were using sock_release which from the comments
    and code look like it does not release the get() on the file from the
    lookup.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 4e9f0d9a55ea..7ce177e30a53 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -29,6 +29,7 @@
 #include &lt;linux/types.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/inet.h&gt;
+#include &lt;linux/file.h&gt;
 #include &lt;linux/blkdev.h&gt;
 #include &lt;linux/crypto.h&gt;
 #include &lt;linux/delay.h&gt;
@@ -1878,7 +1879,7 @@ iscsi_tcp_release_conn(struct iscsi_conn *conn)
 	iscsi_conn_restore_callbacks(tcp_conn);
 	sock_put(tcp_conn-&gt;sock-&gt;sk);
 
-	sock_release(tcp_conn-&gt;sock);
+	sockfd_put(tcp_conn-&gt;sock);
 	tcp_conn-&gt;sock = NULL;
 	conn-&gt;recv_lock = NULL;
 }</pre><hr><pre>commit 0ab823db869f1c9454c5b031a9b8f8812ccd0aa7
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 30 12:57:22 2007 -0500

    [SCSI] qla4xxx: add iscsi_transport capps for fw capacilities
    
    Userspace will want to know what the driver/FW/HW capabilites
    when it comes to some operations like if the hardware can
    do discovery or if it can store iscsi info like what target
    was used for boot. This patch adds some new caps so userspace
    can tell if the driver supports hardware/fw based sendtargets
    discovery and if the hardware has some flash which may be
    holding or can contain some iscsi target info
    .
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: David C Somayajulu &lt;david.somayajulu@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 7502bb4808d6..315ab691056f 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -102,6 +102,7 @@ static struct scsi_host_template qla4xxx_driver_template = {
 static struct iscsi_transport qla4xxx_iscsi_transport = {
 	.owner			= THIS_MODULE,
 	.name			= DRIVER_NAME,
+	.caps			= CAP_FW_DB | CAP_SENDTARGETS_OFFLOAD,
 	.param_mask		= ISCSI_CONN_PORT | ISCSI_CONN_ADDRESS |
 				  ISCSI_TARGET_NAME | ISCSI_TPGT,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS |
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index a046a329189c..81a542506dfe 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -299,6 +299,8 @@ enum iscsi_host_param {
 #define CAP_MULTI_CONN		0x40
 #define CAP_TEXT_NEGO		0x80
 #define CAP_MARKERS		0x100
+#define CAP_FW_DB		0x200
+#define CAP_SENDTARGETS_OFFLOAD	0x400
 
 /*
  * These flags describes reason of stop_conn() call</pre>
    <div class="pagination">
        <a href='5_30.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><span>[31]</span><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_32.html'>Next&gt;&gt;</a>
    <div>
</body>
