<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_45.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><span>[46]</span><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_47.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 32830f207691176234b4c4dd17f0d7ab6d87d94b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:53 2012 -0400

    USB: EHCI: use hrtimer for unlinking empty async QHs
    
    This patch (as1583) changes ehci-hcd to use an hrtimer event for
    unlinking empty (unused) async QHs instead of using a kernel timer.
    
    The check for empty QHs is moved to a new routine, where it doesn't
    require going through an entire scan of both the async and periodic
    schedules.  And it can unlink multiple QHs at once, unlike the current
    code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 86e8ee169c67..74ffd20edff8 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -94,8 +94,6 @@ static const char	hcd_name [] = "ehci_hcd";
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
-#define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
-						/* 5-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -130,15 +128,6 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 static void
 timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 {
-	/* Don't override timeouts which shrink or (later) disable
-	 * the async ring; just the I/O watchdog.  Note that if a
-	 * SHRINK were pending, OFF would never be requested.
-	 */
-	if (timer_pending(&amp;ehci-&gt;watchdog)
-			&amp;&amp; (BIT(TIMER_ASYNC_SHRINK)
-				&amp; ehci-&gt;actions))
-		return;
-
 	if (!test_and_set_bit(action, &amp;ehci-&gt;actions)) {
 		unsigned long t;
 
@@ -148,10 +137,6 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 				return;
 			t = EHCI_IO_JIFFIES;
 			break;
-		/* case TIMER_ASYNC_SHRINK: */
-		default:
-			t = EHCI_SHRINK_JIFFIES;
-			break;
 		}
 		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
 	}
@@ -307,6 +292,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 /*-------------------------------------------------------------------------*/
 
 static void end_unlink_async(struct ehci_hcd *ehci);
+static void unlink_empty_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index a3822700e496..5d84562e2716 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -300,6 +300,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
+	unlink_empty_async(ehci);
 	ehci_handle_intr_unlinks(ehci);
 	end_free_itds(ehci);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 181832921c53..bae931767825 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1205,7 +1205,7 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 			end_unlink_async(ehci);
 
 	/* Otherwise start a new IAA cycle */
-	} else {
+	} else if (likely(ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();
 
@@ -1253,6 +1253,39 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	}
 }
 
+static void unlink_empty_async(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh, *next;
+	bool			stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+	bool			check_unlinks_later = false;
+
+	/* Unlink all the async QHs that have been empty for a timer cycle */
+	next = ehci-&gt;async-&gt;qh_next.qh;
+	while (next) {
+		qh = next;
+		next = qh-&gt;qh_next.qh;
+
+		if (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+				qh-&gt;qh_state == QH_STATE_LINKED) {
+			if (!stopped &amp;&amp; qh-&gt;unlink_cycle ==
+					ehci-&gt;async_unlink_cycle)
+				check_unlinks_later = true;
+			else
+				single_unlink_async(ehci, qh);
+		}
+	}
+
+	/* Start a new IAA cycle if any QHs are waiting for it */
+	if (ehci-&gt;async_unlink)
+		start_iaa_cycle(ehci, false);
+
+	/* QHs that haven't been empty for long enough will be handled later */
+	if (check_unlinks_later) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);
+		++ehci-&gt;async_unlink_cycle;
+	}
+}
+
 /* makes sure the async qh will become idle */
 /* caller must own ehci-&gt;lock */
 
@@ -1277,12 +1310,8 @@ static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void scan_async (struct ehci_hcd *ehci)
 {
-	bool			stopped;
 	struct ehci_qh		*qh;
-	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
-
-	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-	stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+	bool			check_unlinks_later = false;
 
 	ehci-&gt;qh_scan_next = ehci-&gt;async-&gt;qh_next.qh;
 	while (ehci-&gt;qh_scan_next) {
@@ -1301,28 +1330,27 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * in single_unlink_async().
 			 */
 			temp = qh_completions(ehci, qh);
-			if (qh-&gt;needs_rescan)
+			if (qh-&gt;needs_rescan) {
 				start_unlink_async(ehci, qh);
-			qh-&gt;unlink_time = jiffies + EHCI_SHRINK_JIFFIES;
-			if (temp != 0)
+			} else if (list_empty(&amp;qh-&gt;qtd_list)
+					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
+				qh-&gt;unlink_cycle = ehci-&gt;async_unlink_cycle;
+				check_unlinks_later = true;
+			} else if (temp != 0)
 				goto rescan;
 		}
+	}
 
-		/* unlink idle entries, reducing DMA usage as well
-		 * as HCD schedule-scanning costs.  delay for any qh
-		 * we just scanned, there's a not-unusual case that it
-		 * doesn't stay idle for long.
-		 * (plus, avoids some kind of re-activation race.)
-		 */
-		if (list_empty(&amp;qh-&gt;qtd_list)
-				&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
-			if (!ehci-&gt;async_unlink &amp;&amp; (stopped ||
-					time_after_eq(jiffies, qh-&gt;unlink_time)))
-				start_unlink_async(ehci, qh);
-			else
-				action = TIMER_ASYNC_SHRINK;
-		}
+	/*
+	 * Unlink empty entries, reducing DMA usage as well
+	 * as HCD schedule-scanning costs.  Delay for any qh
+	 * we just scanned, there's a not-unusual case that it
+	 * doesn't stay idle for long.
+	 */
+	if (check_unlinks_later &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
+			!(ehci-&gt;enabled_hrtimer_events &amp;
+				BIT(EHCI_HRTIMER_ASYNC_UNLINKS))) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);
+		++ehci-&gt;async_unlink_cycle;
 	}
-	if (action == TIMER_ASYNC_SHRINK)
-		timer_action (ehci, TIMER_ASYNC_SHRINK);
 }
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 8ca5f152f5bd..a823290b5139 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	6 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
@@ -347,6 +348,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	unlink_empty_async,		/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 1a782775881b..303c36cc99c9 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -84,6 +84,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_FREE_ITDS,		/* Wait for unused iTDs and siTDs */
+	EHCI_HRTIMER_ASYNC_UNLINKS,	/* Unlink empty async QHs */
 	EHCI_HRTIMER_IAA_WATCHDOG,	/* Handle lost IAA interrupts */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
@@ -123,6 +124,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*async_iaa;
 	struct ehci_qh		*qh_scan_next;
+	unsigned		async_unlink_cycle;
 	unsigned		async_count;	/* async activity count */
 
 	/* periodic schedule support */
@@ -232,7 +234,6 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
-	TIMER_ASYNC_SHRINK,
 };
 
 static inline void
@@ -382,7 +383,6 @@ struct ehci_qh {
 	struct ehci_qtd		*dummy;
 	struct ehci_qh		*unlink_next;	/* next on unlink list */
 
-	unsigned long		unlink_time;
 	unsigned		unlink_cycle;
 	unsigned		stamp;
 </pre><hr><pre>commit 3c273a056bf46167f0a1309c2ba72282a17d2541
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:49 2012 -0400

    USB: EHCI: unlink multiple async QHs together
    
    This patch (as1582) changes ehci-hcd's strategy for unlinking async
    QHs.  Currently the driver never unlinks more than one QH at a time.
    This can be inefficient and cause unnecessary delays, since a QH
    cannot be reused while it is waiting to be unlinked.
    
    The new strategy unlinks all the waiting QHs at once.  In practice the
    improvement won't be very big, because it's somewhat uncommon to have
    two or more QHs waiting to be unlinked at any time.  But it does
    happen, and in any case, doing things this way makes more sense IMO.
    
    The change requires the async unlinking code to be refactored
    slightly.  Now in addition to the routines for starting and ending an
    unlink, there are new routines for unlinking a single QH and starting
    an IAA cycle.  This approach is needed because there are two separate
    paths for unlinking async QHs:
    
            When a transfer error occurs or an URB is cancelled, the QH
            must be unlinked right away;
    
            When a QH has been idle sufficiently long, it is unlinked
            to avoid consuming DMA bandwidth uselessly.
    
    In the first case we want the unlink to proceed as quickly as
    possible, whereas in the second case we can afford to batch several
    QHs together and unlink them all at once.  Hence the division of
    labor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f74ba277c22d..86e8ee169c67 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -795,7 +795,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci-&gt;async_unlink) {
+		if (ehci-&gt;async_iaa) {
 			COUNT(ehci-&gt;stats.iaa);
 			end_unlink_async(ehci);
 		} else
@@ -926,33 +926,6 @@ static int ehci_urb_enqueue (
 	}
 }
 
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
-{
-	/* failfast */
-	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING &amp;&amp; ehci-&gt;async_unlink)
-		end_unlink_async(ehci);
-
-	/* If the QH isn't linked then there's nothing we can do
-	 * unless we were called during a giveback, in which case
-	 * qh_completions() has to deal with it.
-	 */
-	if (qh-&gt;qh_state != QH_STATE_LINKED) {
-		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
-			qh-&gt;needs_rescan = 1;
-		return;
-	}
-
-	/* defer till later if busy */
-	if (ehci-&gt;async_unlink) {
-		qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
-		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
-		ehci-&gt;async_unlink_last = qh;
-
-	/* start IAA cycle */
-	} else
-		start_unlink_async (ehci, qh);
-}
-
 /* remove from hardware lists
  * completions normally happen asynchronously
  */
@@ -979,7 +952,7 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
 		case QH_STATE_COMPLETING:
-			unlink_async(ehci, qh);
+			start_unlink_async(ehci, qh);
 			break;
 		case QH_STATE_UNLINK:
 		case QH_STATE_UNLINK_WAIT:
@@ -1070,7 +1043,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		 * may already be unlinked.
 		 */
 		if (tmp)
-			unlink_async(ehci, qh);
+			start_unlink_async(ehci, qh);
 		/* FALL THROUGH */
 	case QH_STATE_UNLINK:		/* wait for hw to finish? */
 	case QH_STATE_UNLINK_WAIT:
@@ -1133,7 +1106,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * re-linking will call qh_refresh().
 			 */
 			if (eptype == USB_ENDPOINT_XFER_BULK)
-				unlink_async(ehci, qh);
+				start_unlink_async(ehci, qh);
 			else
 				start_unlink_intr(ehci, qh);
 		}
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3097872b1e74..a3822700e496 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -299,8 +299,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_halt (ehci);
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
-	if (ehci-&gt;async_unlink)
-		end_unlink_async(ehci);
+	end_unlink_async(ehci);
 	ehci_handle_intr_unlinks(ehci);
 	end_free_itds(ehci);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 7b35933d91a6..181832921c53 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -293,9 +293,6 @@ __acquires(ehci-&gt;lock)
 	spin_lock (&amp;ehci-&gt;lock);
 }
 
-static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
-static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
-
 static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*
@@ -1166,82 +1163,114 @@ submit_async (
 
 /*-------------------------------------------------------------------------*/
 
-/* the async qh for the qtds being unlinked are now gone from the HC */
-
-static void end_unlink_async (struct ehci_hcd *ehci)
+static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	struct ehci_qh		*qh = ehci-&gt;async_unlink;
-	struct ehci_qh		*next;
+	struct ehci_qh		*prev;
 
-	// qh-&gt;hw_next = cpu_to_hc32(qh-&gt;qh_dma);
-	qh-&gt;qh_state = QH_STATE_IDLE;
-	qh-&gt;qh_next.qh = NULL;
+	/* Add to the end of the list of QHs waiting for the next IAAD */
+	qh-&gt;qh_state = QH_STATE_UNLINK;
+	if (ehci-&gt;async_unlink)
+		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
+	else
+		ehci-&gt;async_unlink = qh;
+	ehci-&gt;async_unlink_last = qh;
+
+	/* Unlink it from the schedule */
+	prev = ehci-&gt;async;
+	while (prev-&gt;qh_next.qh != qh)
+		prev = prev-&gt;qh_next.qh;
+
+	prev-&gt;hw-&gt;hw_next = qh-&gt;hw-&gt;hw_next;
+	prev-&gt;qh_next = qh-&gt;qh_next;
+	if (ehci-&gt;qh_scan_next == qh)
+		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
+}
 
-	/* other unlink(s) may be pending (in QH_STATE_UNLINK_WAIT) */
-	next = qh-&gt;unlink_next;
-	ehci-&gt;async_unlink = next;
-	qh-&gt;unlink_next = NULL;
+static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
+{
+	/*
+	 * Do nothing if an IAA cycle is already running or
+	 * if one will be started shortly.
+	 */
+	if (ehci-&gt;async_iaa || ehci-&gt;async_unlinking)
+		return;
 
-	qh_completions (ehci, qh);
+	/* Do all the waiting QHs at once */
+	ehci-&gt;async_iaa = ehci-&gt;async_unlink;
+	ehci-&gt;async_unlink = NULL;
 
-	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)
-		qh_link_async (ehci, qh);
+	/* If the controller isn't running, we don't have to wait for it */
+	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
+		if (!nested)		/* Avoid recursion */
+			end_unlink_async(ehci);
 
-	disable_async(ehci);
+	/* Otherwise start a new IAA cycle */
+	} else {
+		/* Make sure the unlinks are all visible to the hardware */
+		wmb();
 
-	if (next) {
-		ehci-&gt;async_unlink = NULL;
-		start_unlink_async (ehci, next);
+		ehci_writel(ehci, ehci-&gt;command | CMD_IAAD,
+				&amp;ehci-&gt;regs-&gt;command);
+		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+		ehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);
 	}
+}
+
+/* the async qh for the qtds being unlinked are now gone from the HC */
+
+static void end_unlink_async(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh;
 
 	if (ehci-&gt;has_synopsys_hc_bug)
 		ehci_writel(ehci, (u32) ehci-&gt;async-&gt;qh_dma,
 			    &amp;ehci-&gt;regs-&gt;async_next);
+
+	/* Process the idle QHs */
+ restart:
+	ehci-&gt;async_unlinking = true;
+	while (ehci-&gt;async_iaa) {
+		qh = ehci-&gt;async_iaa;
+		ehci-&gt;async_iaa = qh-&gt;unlink_next;
+		qh-&gt;unlink_next = NULL;
+
+		qh-&gt;qh_state = QH_STATE_IDLE;
+		qh-&gt;qh_next.qh = NULL;
+
+		qh_completions(ehci, qh);
+		if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+				ehci-&gt;rh_state == EHCI_RH_RUNNING)
+			qh_link_async(ehci, qh);
+		disable_async(ehci);
+	}
+	ehci-&gt;async_unlinking = false;
+
+	/* Start a new IAA cycle if any QHs are waiting for it */
+	if (ehci-&gt;async_unlink) {
+		start_iaa_cycle(ehci, true);
+		if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING))
+			goto restart;
+	}
 }
 
 /* makes sure the async qh will become idle */
 /* caller must own ehci-&gt;lock */
 
-static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	struct ehci_qh	*prev;
-
-#ifdef DEBUG
-	assert_spin_locked(&amp;ehci-&gt;lock);
-	if (ehci-&gt;async_unlink
-			|| (qh-&gt;qh_state != QH_STATE_LINKED
-				&amp;&amp; qh-&gt;qh_state != QH_STATE_UNLINK_WAIT)
-			)
-		BUG ();
-#endif
-
-	qh-&gt;qh_state = QH_STATE_UNLINK;
-	ehci-&gt;async_unlink = qh;
-	if (!qh-&gt;unlink_next)
-		ehci-&gt;async_unlink_last = qh;
-
-	prev = ehci-&gt;async;
-	while (prev-&gt;qh_next.qh != qh)
-		prev = prev-&gt;qh_next.qh;
-
-	prev-&gt;hw-&gt;hw_next = qh-&gt;hw-&gt;hw_next;
-	prev-&gt;qh_next = qh-&gt;qh_next;
-	if (ehci-&gt;qh_scan_next == qh)
-		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
-	wmb ();
-
-	/* If the controller isn't running, we don't have to wait for it */
-	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
-		/* if (unlikely (qh-&gt;unlink_next != 0))
-		 *	this will recurse, probably not much
-		 */
-		end_unlink_async (ehci);
+	/*
+	 * If the QH isn't linked then there's nothing we can do
+	 * unless we were called during a giveback, in which case
+	 * qh_completions() has to deal with it.
+	 */
+	if (qh-&gt;qh_state != QH_STATE_LINKED) {
+		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
+			qh-&gt;needs_rescan = 1;
 		return;
 	}
 
-	ehci_writel(ehci, ehci-&gt;command | CMD_IAAD, &amp;ehci-&gt;regs-&gt;command);
-	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	ehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);
+	single_unlink_async(ehci, qh);
+	start_iaa_cycle(ehci, false);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1269,11 +1298,11 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * drops the lock.  That's why ehci-&gt;qh_scan_next
 			 * always holds the next qh to scan; if the next qh
 			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted
-			 * in start_unlink_async().
+			 * in single_unlink_async().
 			 */
 			temp = qh_completions(ehci, qh);
 			if (qh-&gt;needs_rescan)
-				unlink_async(ehci, qh);
+				start_unlink_async(ehci, qh);
 			qh-&gt;unlink_time = jiffies + EHCI_SHRINK_JIFFIES;
 			if (temp != 0)
 				goto rescan;
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index aab042064226..8ca5f152f5bd 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -211,6 +211,7 @@ static void ehci_handle_controller_death(struct ehci_hcd *ehci)
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 	ehci_work(ehci);
+	end_unlink_async(ehci);
 
 	/* Not in process context, so don't try to reset the controller */
 }
@@ -304,7 +305,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	 * (a) SMP races against real IAA firing and retriggering, and
 	 * (b) clean HC shutdown, when IAA watchdog was pending.
 	 */
-	if (ehci-&gt;async_unlink) {
+	if (ehci-&gt;async_iaa) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index d9414aae610f..1a782775881b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -114,12 +114,14 @@ struct ehci_hcd {			/* one per controller */
 	/* general schedule support */
 	unsigned		scanning:1;
 	bool			intr_unlinking:1;
+	bool			async_unlinking:1;
 
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct ehci_qh		*async_unlink;
 	struct ehci_qh		*async_unlink_last;
+	struct ehci_qh		*async_iaa;
 	struct ehci_qh		*qh_scan_next;
 	unsigned		async_count;	/* async activity count */
 </pre><hr><pre>commit 9d9387475af261949f61a5ec465e1f762d7be08a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:44 2012 -0400

    USB: EHCI: use hrtimer for the IAA watchdog
    
    This patch (as1581) replaces the iaa_watchdog kernel timer used by
    ehci-hcd with an hrtimer event, in keeping with the general conversion
    to high-res timers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fb1966cf5649..f74ba277c22d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -93,7 +93,6 @@ static const char	hcd_name [] = "ehci_hcd";
  */
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
-#define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
 						/* 5-ms async qh unlink delay */
@@ -322,51 +321,6 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_iaa_watchdog(unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
-
-	/* Lost IAA irqs wedge things badly; seen first with a vt8235.
-	 * So we need this watchdog, but must protect it against both
-	 * (a) SMP races against real IAA firing and retriggering, and
-	 * (b) clean HC shutdown, when IAA watchdog was pending.
-	 */
-	if (ehci-&gt;async_unlink
-			&amp;&amp; !timer_pending(&amp;ehci-&gt;iaa_watchdog)
-			&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
-		u32 cmd, status;
-
-		/* If we get here, IAA is *REALLY* late.  It's barely
-		 * conceivable that the system is so busy that CMD_IAAD
-		 * is still legitimately set, so let's be sure it's
-		 * clear before we read STS_IAA.  (The HC should clear
-		 * CMD_IAAD when it sets STS_IAA.)
-		 */
-		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-
-		/* If IAA is set here it either legitimately triggered
-		 * before we cleared IAAD above (but _way_ late, so we'll
-		 * still count it as lost) ... or a silicon erratum:
-		 * - VIA seems to set IAA without triggering the IRQ;
-		 * - IAAD potentially cleared without setting IAA.
-		 */
-		status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
-		if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
-			COUNT (ehci-&gt;stats.lost_iaa);
-			ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
-		}
-
-		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
-				status, cmd);
-		end_unlink_async(ehci);
-	}
-
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
-}
-
 static void ehci_watchdog(unsigned long param)
 {
 	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
@@ -418,7 +372,6 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
 	del_timer_sync(&amp;ehci-&gt;watchdog);
-	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
@@ -491,7 +444,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* no more interrupts ... */
 	del_timer_sync (&amp;ehci-&gt;watchdog);
-	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;enabled_hrtimer_events = 0;
@@ -547,10 +499,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci-&gt;watchdog.function = ehci_watchdog;
 	ehci-&gt;watchdog.data = (unsigned long) ehci;
 
-	init_timer(&amp;ehci-&gt;iaa_watchdog);
-	ehci-&gt;iaa_watchdog.function = ehci_iaa_watchdog;
-	ehci-&gt;iaa_watchdog.data = (unsigned long) ehci;
-
 	hrtimer_init(&amp;ehci-&gt;hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 	ehci-&gt;hrtimer.function = ehci_hrtimer_func;
 	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
@@ -830,6 +778,20 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* complete the unlinking of some qh [4.15.2.3] */
 	if (status &amp; STS_IAA) {
+
+		/* Turn off the IAA watchdog */
+		ehci-&gt;enabled_hrtimer_events &amp;= ~BIT(EHCI_HRTIMER_IAA_WATCHDOG);
+
+		/*
+		 * Mild optimization: Allow another IAAD to reset the
+		 * hrtimer, if one occurs before the next expiration.
+		 * In theory we could always cancel the hrtimer, but
+		 * tests show that about half the time it will be reset
+		 * for some other event anyway.
+		 */
+		if (ehci-&gt;next_hrtimer_event == EHCI_HRTIMER_IAA_WATCHDOG)
+			++ehci-&gt;next_hrtimer_event;
+
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6ad806bbe468..3097872b1e74 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -209,7 +209,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 	del_timer_sync(&amp;ehci-&gt;watchdog);
-	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index d68764ef4476..7b35933d91a6 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1173,8 +1173,6 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh = ehci-&gt;async_unlink;
 	struct ehci_qh		*next;
 
-	iaa_watchdog_done(ehci);
-
 	// qh-&gt;hw_next = cpu_to_hc32(qh-&gt;qh_dma);
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	qh-&gt;qh_next.qh = NULL;
@@ -1243,7 +1241,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	ehci_writel(ehci, ehci-&gt;command | CMD_IAAD, &amp;ehci-&gt;regs-&gt;command);
 	(void)ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
-	iaa_watchdog_start(ehci);
+	ehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 8feb60ff4228..aab042064226 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -291,6 +292,49 @@ static void end_free_itds(struct ehci_hcd *ehci)
 }
 
 
+/* Handle lost (or very late) IAA interrupts */
+static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
+{
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
+	/*
+	 * Lost IAA irqs wedge things badly; seen first with a vt8235.
+	 * So we need this watchdog, but must protect it against both
+	 * (a) SMP races against real IAA firing and retriggering, and
+	 * (b) clean HC shutdown, when IAA watchdog was pending.
+	 */
+	if (ehci-&gt;async_unlink) {
+		u32 cmd, status;
+
+		/* If we get here, IAA is *REALLY* late.  It's barely
+		 * conceivable that the system is so busy that CMD_IAAD
+		 * is still legitimately set, so let's be sure it's
+		 * clear before we read STS_IAA.  (The HC should clear
+		 * CMD_IAAD when it sets STS_IAA.)
+		 */
+		cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+
+		/*
+		 * If IAA is set here it either legitimately triggered
+		 * after the watchdog timer expired (_way_ late, so we'll
+		 * still count it as lost) ... or a silicon erratum:
+		 * - VIA seems to set IAA without triggering the IRQ;
+		 * - IAAD potentially cleared without setting IAA.
+		 */
+		status = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
+		if ((status &amp; STS_IAA) || !(cmd &amp; CMD_IAAD)) {
+			COUNT(ehci-&gt;stats.lost_iaa);
+			ehci_writel(ehci, STS_IAA, &amp;ehci-&gt;regs-&gt;status);
+		}
+
+		ehci_vdbg(ehci, "IAA watchdog: status %x cmd %x\n",
+				status, cmd);
+		end_unlink_async(ehci);
+	}
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -302,6 +346,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 755e30b0000b..d9414aae610f 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -84,6 +84,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_FREE_ITDS,		/* Wait for unused iTDs and siTDs */
+	EHCI_HRTIMER_IAA_WATCHDOG,	/* Handle lost IAA interrupts */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
@@ -168,7 +169,6 @@ struct ehci_hcd {			/* one per controller */
 	struct dma_pool		*itd_pool;	/* itd per iso urb */
 	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
 
-	struct timer_list	iaa_watchdog;
 	struct timer_list	watchdog;
 	unsigned long		actions;
 	unsigned		periodic_stamp;
@@ -228,20 +228,6 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 	return container_of ((void *) ehci, struct usb_hcd, hcd_priv);
 }
 
-
-static inline void
-iaa_watchdog_start(struct ehci_hcd *ehci)
-{
-	WARN_ON(timer_pending(&amp;ehci-&gt;iaa_watchdog));
-	mod_timer(&amp;ehci-&gt;iaa_watchdog,
-			jiffies + msecs_to_jiffies(EHCI_IAA_MSECS));
-}
-
-static inline void iaa_watchdog_done(struct ehci_hcd *ehci)
-{
-	del_timer(&amp;ehci-&gt;iaa_watchdog);
-}
-
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
 	TIMER_ASYNC_SHRINK,</pre><hr><pre>commit 8c5bf7be56f1a8aecc1f802f132d53f556a9bc45
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:39 2012 -0400

    USB: EHCI: don't refcount iso_stream structures
    
    This patch (as1580) makes ehci_iso_stream structures behave more like
    QHs, in that they will remain allocated until their isochronous
    endpoint is disabled.  This will come in useful in the future, when
    periodic bandwidth gets allocated as an altsetting is installed rather
    than on-the-fly.
    
    For now, the change to the ehci_iso_stream lifetimes means that each
    structure is always deallocated at exactly one spot in
    ehci_endpoint_disable() and never used again.  As a result, it is no
    longer necessary to use reference counting on these things, and the
    patch removes it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 98b945840c9e..fb1966cf5649 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1085,8 +1085,14 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	 * accelerate iso completions ... so spin a while.
 	 */
 	if (qh-&gt;hw == NULL) {
-		ehci_vdbg (ehci, "iso delay\n");
-		goto idle_timeout;
+		struct ehci_iso_stream	*stream = ep-&gt;hcpriv;
+
+		if (!list_empty(&amp;stream-&gt;td_list))
+			goto idle_timeout;
+
+		/* BUG_ON(!list_empty(&amp;stream-&gt;free_list)); */
+		kfree(stream);
+		goto done;
 	}
 
 	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
@@ -1127,8 +1133,8 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			list_empty (&amp;qh-&gt;qtd_list) ? "" : "(has tds)");
 		break;
 	}
+ done:
 	ep-&gt;hcpriv = NULL;
-done:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 }
 
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 1e4f13c11b6a..11b2f21d7ac1 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -934,7 +934,6 @@ iso_stream_alloc (gfp_t mem_flags)
 		INIT_LIST_HEAD(&amp;stream-&gt;td_list);
 		INIT_LIST_HEAD(&amp;stream-&gt;free_list);
 		stream-&gt;next_uframe = -1;
-		stream-&gt;refcount = 1;
 	}
 	return stream;
 }
@@ -1034,32 +1033,6 @@ iso_stream_init (
 	stream-&gt;maxp = maxp;
 }
 
-static void
-iso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)
-{
-	stream-&gt;refcount--;
-
-	/* free whenever just a dev-&gt;ep reference remains.
-	 * not like a QH -- no persistent state (toggle, halt)
-	 */
-	if (stream-&gt;refcount == 1) {
-		// BUG_ON (!list_empty(&amp;stream-&gt;td_list));
-
-		if (stream-&gt;ep)
-			stream-&gt;ep-&gt;hcpriv = NULL;
-
-		kfree(stream);
-	}
-}
-
-static inline struct ehci_iso_stream *
-iso_stream_get (struct ehci_iso_stream *stream)
-{
-	if (likely (stream != NULL))
-		stream-&gt;refcount++;
-	return stream;
-}
-
 static struct ehci_iso_stream *
 iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 {
@@ -1080,7 +1053,6 @@ iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 	if (unlikely (stream == NULL)) {
 		stream = iso_stream_alloc(GFP_ATOMIC);
 		if (likely (stream != NULL)) {
-			/* dev-&gt;ep owns the initial refcount */
 			ep-&gt;hcpriv = stream;
 			stream-&gt;ep = ep;
 			iso_stream_init(ehci, stream, urb-&gt;dev, urb-&gt;pipe,
@@ -1095,9 +1067,6 @@ iso_stream_find (struct ehci_hcd *ehci, struct urb *urb)
 		stream = NULL;
 	}
 
-	/* caller guarantees an eventual matching iso_stream_put */
-	stream = iso_stream_get (stream);
-
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	return stream;
 }
@@ -1611,7 +1580,7 @@ static void itd_link_urb(
 			itd = list_entry (iso_sched-&gt;td_list.next,
 					struct ehci_itd, itd_list);
 			list_move_tail (&amp;itd-&gt;itd_list, &amp;stream-&gt;td_list);
-			itd-&gt;stream = iso_stream_get (stream);
+			itd-&gt;stream = stream;
 			itd-&gt;urb = urb;
 			itd_init (ehci, stream, itd);
 		}
@@ -1735,7 +1704,6 @@ itd_complete (
 			dev-&gt;devpath, stream-&gt;bEndpointAddress &amp; 0x0f,
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out");
 	}
-	iso_stream_put (ehci, stream);
 
 done:
 	itd-&gt;urb = NULL;
@@ -1750,7 +1718,6 @@ itd_complete (
 		start_free_itds(ehci);
 	}
 
-	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -1807,12 +1774,9 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		itd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
 	else
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
-done_not_linked:
+ done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-
-done:
-	if (unlikely (status &lt; 0))
-		iso_stream_put (ehci, stream);
+ done:
 	return status;
 }
 
@@ -2028,7 +1992,7 @@ static void sitd_link_urb(
 		sitd = list_entry (sched-&gt;td_list.next,
 				struct ehci_sitd, sitd_list);
 		list_move_tail (&amp;sitd-&gt;sitd_list, &amp;stream-&gt;td_list);
-		sitd-&gt;stream = iso_stream_get (stream);
+		sitd-&gt;stream = stream;
 		sitd-&gt;urb = urb;
 
 		sitd_patch(ehci, stream, sitd, sched, packet);
@@ -2126,7 +2090,6 @@ sitd_complete (
 			dev-&gt;devpath, stream-&gt;bEndpointAddress &amp; 0x0f,
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out");
 	}
-	iso_stream_put (ehci, stream);
 
 done:
 	sitd-&gt;urb = NULL;
@@ -2141,7 +2104,6 @@ sitd_complete (
 		start_free_itds(ehci);
 	}
 
-	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -2195,12 +2157,9 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 		sitd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
 	else
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
-done_not_linked:
+ done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-
-done:
-	if (status &lt; 0)
-		iso_stream_put (ehci, stream);
+ done:
 	return status;
 }
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bcfbb175e2b4..755e30b0000b 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -386,7 +386,7 @@ struct ehci_qh_hw {
 } __attribute__ ((aligned(32)));
 
 struct ehci_qh {
-	struct ehci_qh_hw	*hw;
+	struct ehci_qh_hw	*hw;		/* Must come first */
 	/* the rest is HCD-private */
 	dma_addr_t		qh_dma;		/* address of qh */
 	union ehci_shadow	qh_next;	/* ptr to qh; or periodic */
@@ -453,7 +453,6 @@ struct ehci_iso_stream {
 	/* first field matches ehci_hq, but is NULL */
 	struct ehci_qh_hw	*hw;
 
-	u32			refcount;
 	u8			bEndpointAddress;
 	u8			highspeed;
 	struct list_head	td_list;	/* queued itds/sitds */</pre><hr><pre>commit 55934eb3b9fa52eb53b9d7342267fc73c38206aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:35 2012 -0400

    USB: EHCI: use hrtimer for (s)iTD deallocation
    
    This patch (as1579) adds an hrtimer event to handle deallocation of
    iTDs and siTDs in ehci-hcd.
    
    Because of the frame-oriented approach used by the EHCI periodic
    schedule, the hardware can continue to access the Transfer Descriptor
    for isochronous (or split-isochronous) transactions for up to a
    millisecond after the transaction completes.  The iTD (or siTD) must
    not be reused before then.
    
    The strategy currently used involves putting completed iTDs on a list
    of cached entries and every so often returning them to the endpoint's
    free list.  The new strategy reduces overhead by putting completed
    iTDs back on the free list immediately, although they are not reused
    until it is safe to do so.
    
    When the isochronous endpoint stops (its queue becomes empty), the
    iTDs on its free list get moved to a global list, from which they will
    be deallocated after a minimum of 2 ms.  This delay is what the new
    hrtimer event is for.
    
    Overall this may not be a tremendous improvement over the current
    code, but to me it seems a lot more clear and logical.  In addition,
    it removes the need for each iTD to keep a reference to the
    ehci_iso_stream it belongs to, since the iTD never needs to be moved
    back to the stream's free list from the global list.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 1676c66b8530..98b945840c9e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -509,6 +509,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	spin_lock_irq (&amp;ehci-&gt;lock);
 	if (ehci-&gt;async)
 		ehci_work (ehci);
+	end_free_itds(ehci);
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	ehci_mem_cleanup (ehci);
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 8aa740dc510d..6ad806bbe468 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -303,6 +303,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	if (ehci-&gt;async_unlink)
 		end_unlink_async(ehci);
 	ehci_handle_intr_unlinks(ehci);
+	end_free_itds(ehci);
 
 	/* allow remote wakeup */
 	mask = INTR_MASK;
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index 93132d8ad360..ef2c3a1eca4b 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -118,7 +118,6 @@ static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, gfp_t flags)
 
 static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
-	free_cached_lists(ehci);
 	if (ehci-&gt;async)
 		qh_destroy(ehci, ehci-&gt;async);
 	ehci-&gt;async = NULL;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index eec8446f8ded..1e4f13c11b6a 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1045,31 +1045,6 @@ iso_stream_put(struct ehci_hcd *ehci, struct ehci_iso_stream *stream)
 	if (stream-&gt;refcount == 1) {
 		// BUG_ON (!list_empty(&amp;stream-&gt;td_list));
 
-		while (!list_empty (&amp;stream-&gt;free_list)) {
-			struct list_head	*entry;
-
-			entry = stream-&gt;free_list.next;
-			list_del (entry);
-
-			/* knows about ITD vs SITD */
-			if (stream-&gt;highspeed) {
-				struct ehci_itd		*itd;
-
-				itd = list_entry (entry, struct ehci_itd,
-						itd_list);
-				dma_pool_free (ehci-&gt;itd_pool, itd,
-						itd-&gt;itd_dma);
-			} else {
-				struct ehci_sitd	*sitd;
-
-				sitd = list_entry (entry, struct ehci_sitd,
-						sitd_list);
-				dma_pool_free (ehci-&gt;sitd_pool, sitd,
-						sitd-&gt;sitd_dma);
-			}
-		}
-
-		stream-&gt;bEndpointAddress &amp;= 0x0f;
 		if (stream-&gt;ep)
 			stream-&gt;ep-&gt;hcpriv = NULL;
 
@@ -1230,17 +1205,19 @@ itd_urb_transaction (
 	spin_lock_irqsave (&amp;ehci-&gt;lock, flags);
 	for (i = 0; i &lt; num_itds; i++) {
 
-		/* free_list.next might be cache-hot ... but maybe
-		 * the HC caches it too. avoid that issue for now.
+		/*
+		 * Use iTDs from the free list, but not iTDs that may
+		 * still be in use by the hardware.
 		 */
-
-		/* prefer previously-allocated itds */
-		if (likely (!list_empty(&amp;stream-&gt;free_list))) {
-			itd = list_entry (stream-&gt;free_list.prev,
+		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
+			itd = list_first_entry(&amp;stream-&gt;free_list,
 					struct ehci_itd, itd_list);
+			if (itd-&gt;frame == ehci-&gt;clock_frame)
+				goto alloc_itd;
 			list_del (&amp;itd-&gt;itd_list);
 			itd_dma = itd-&gt;itd_dma;
 		} else {
+ alloc_itd:
 			spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 			itd = dma_pool_alloc (ehci-&gt;itd_pool, mem_flags,
 					&amp;itd_dma);
@@ -1762,24 +1739,18 @@ itd_complete (
 
 done:
 	itd-&gt;urb = NULL;
-	if (ehci-&gt;clock_frame != itd-&gt;frame || itd-&gt;index[7] != -1) {
-		/* OK to recycle this ITD now. */
-		itd-&gt;stream = NULL;
-		list_move(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	} else {
-		/* HW might remember this ITD, so we can't recycle it yet.
-		 * Move it to a safe place until a new frame starts.
-		 */
-		list_move(&amp;itd-&gt;itd_list, &amp;ehci-&gt;cached_itd_list);
-		if (stream-&gt;refcount == 2) {
-			/* If iso_stream_put() were called here, stream
-			 * would be freed.  Instead, just prevent reuse.
-			 */
-			stream-&gt;ep-&gt;hcpriv = NULL;
-			stream-&gt;ep = NULL;
-		}
+
+	/* Add to the end of the free list for later reuse */
+	list_move_tail(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
+
+	/* Recycle the iTDs when the pipeline is empty (ep no longer in use) */
+	if (list_empty(&amp;stream-&gt;td_list)) {
+		list_splice_tail_init(&amp;stream-&gt;free_list,
+				&amp;ehci-&gt;cached_itd_list);
+		start_free_itds(ehci);
 	}
+
+	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -1930,17 +1901,19 @@ sitd_urb_transaction (
 		 * means we never need two sitds for full speed packets.
 		 */
 
-		/* free_list.next might be cache-hot ... but maybe
-		 * the HC caches it too. avoid that issue for now.
+		/*
+		 * Use siTDs from the free list, but not siTDs that may
+		 * still be in use by the hardware.
 		 */
-
-		/* prefer previously-allocated sitds */
-		if (!list_empty(&amp;stream-&gt;free_list)) {
-			sitd = list_entry (stream-&gt;free_list.prev,
+		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
+			sitd = list_first_entry(&amp;stream-&gt;free_list,
 					 struct ehci_sitd, sitd_list);
+			if (sitd-&gt;frame == ehci-&gt;clock_frame)
+				goto alloc_sitd;
 			list_del (&amp;sitd-&gt;sitd_list);
 			sitd_dma = sitd-&gt;sitd_dma;
 		} else {
+ alloc_sitd:
 			spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 			sitd = dma_pool_alloc (ehci-&gt;sitd_pool, mem_flags,
 					&amp;sitd_dma);
@@ -2157,24 +2130,18 @@ sitd_complete (
 
 done:
 	sitd-&gt;urb = NULL;
-	if (ehci-&gt;clock_frame != sitd-&gt;frame) {
-		/* OK to recycle this SITD now. */
-		sitd-&gt;stream = NULL;
-		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	} else {
-		/* HW might remember this SITD, so we can't recycle it yet.
-		 * Move it to a safe place until a new frame starts.
-		 */
-		list_move(&amp;sitd-&gt;sitd_list, &amp;ehci-&gt;cached_sitd_list);
-		if (stream-&gt;refcount == 2) {
-			/* If iso_stream_put() were called here, stream
-			 * would be freed.  Instead, just prevent reuse.
-			 */
-			stream-&gt;ep-&gt;hcpriv = NULL;
-			stream-&gt;ep = NULL;
-		}
+
+	/* Add to the end of the free list for later reuse */
+	list_move_tail(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
+
+	/* Recycle the siTDs when the pipeline is empty (ep no longer in use) */
+	if (list_empty(&amp;stream-&gt;td_list)) {
+		list_splice_tail_init(&amp;stream-&gt;free_list,
+				&amp;ehci-&gt;cached_sitd_list);
+		start_free_itds(ehci);
 	}
+
+	iso_stream_put(ehci, stream);
 	return retval;
 }
 
@@ -2239,28 +2206,6 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 /*-------------------------------------------------------------------------*/
 
-static void free_cached_lists(struct ehci_hcd *ehci)
-{
-	struct ehci_itd *itd, *n;
-	struct ehci_sitd *sitd, *sn;
-
-	list_for_each_entry_safe(itd, n, &amp;ehci-&gt;cached_itd_list, itd_list) {
-		struct ehci_iso_stream	*stream = itd-&gt;stream;
-		itd-&gt;stream = NULL;
-		list_move(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	}
-
-	list_for_each_entry_safe(sitd, sn, &amp;ehci-&gt;cached_sitd_list, sitd_list) {
-		struct ehci_iso_stream	*stream = sitd-&gt;stream;
-		sitd-&gt;stream = NULL;
-		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
-		iso_stream_put(ehci, stream);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
 static void
 scan_periodic (struct ehci_hcd *ehci)
 {
@@ -2282,10 +2227,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		clock = now_uframe + mod - 1;
 		clock_frame = -1;
 	}
-	if (ehci-&gt;clock_frame != clock_frame) {
-		free_cached_lists(ehci);
-		ehci-&gt;clock_frame = clock_frame;
-	}
+	ehci-&gt;clock_frame = clock_frame;
 	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
 	++ehci-&gt;periodic_stamp;
@@ -2463,7 +2405,6 @@ scan_periodic (struct ehci_hcd *ehci)
 			clock = now;
 			clock_frame = clock &gt;&gt; 3;
 			if (ehci-&gt;clock_frame != clock_frame) {
-				free_cached_lists(ehci);
 				ehci-&gt;clock_frame = clock_frame;
 				++ehci-&gt;periodic_stamp;
 			}
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 0c5326a8883c..8feb60ff4228 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -71,6 +71,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
+	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -165,7 +166,6 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
 	if (want == 0) {	/* Stopped */
-		free_cached_lists(ehci);
 		if (ehci-&gt;periodic_count &gt; 0) {
 
 			/* make sure ehci_work scans these */
@@ -188,9 +188,6 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 static void ehci_disable_PSE(struct ehci_hcd *ehci)
 {
 	ehci_clear_command_bit(ehci, CMD_PSE);
-
-	/* Poll to see when it actually stops */
-	ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 }
 
 
@@ -250,6 +247,50 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 }
 
 
+/* Start another free-iTDs/siTDs cycle */
+static void start_free_itds(struct ehci_hcd *ehci)
+{
+	if (!(ehci-&gt;enabled_hrtimer_events &amp; BIT(EHCI_HRTIMER_FREE_ITDS))) {
+		ehci-&gt;last_itd_to_free = list_entry(
+				ehci-&gt;cached_itd_list.prev,
+				struct ehci_itd, itd_list);
+		ehci-&gt;last_sitd_to_free = list_entry(
+				ehci-&gt;cached_sitd_list.prev,
+				struct ehci_sitd, sitd_list);
+		ehci_enable_event(ehci, EHCI_HRTIMER_FREE_ITDS, true);
+	}
+}
+
+/* Wait for controller to stop using old iTDs and siTDs */
+static void end_free_itds(struct ehci_hcd *ehci)
+{
+	struct ehci_itd		*itd, *n;
+	struct ehci_sitd	*sitd, *sn;
+
+	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING) {
+		ehci-&gt;last_itd_to_free = NULL;
+		ehci-&gt;last_sitd_to_free = NULL;
+	}
+
+	list_for_each_entry_safe(itd, n, &amp;ehci-&gt;cached_itd_list, itd_list) {
+		list_del(&amp;itd-&gt;itd_list);
+		dma_pool_free(ehci-&gt;itd_pool, itd, itd-&gt;itd_dma);
+		if (itd == ehci-&gt;last_itd_to_free)
+			break;
+	}
+	list_for_each_entry_safe(sitd, sn, &amp;ehci-&gt;cached_sitd_list, sitd_list) {
+		list_del(&amp;sitd-&gt;sitd_list);
+		dma_pool_free(ehci-&gt;sitd_pool, sitd, sitd-&gt;sitd_dma);
+		if (sitd == ehci-&gt;last_sitd_to_free)
+			break;
+	}
+
+	if (!list_empty(&amp;ehci-&gt;cached_itd_list) ||
+			!list_empty(&amp;ehci-&gt;cached_sitd_list))
+		start_free_itds(ehci);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -260,6 +301,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
+	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 6874d89b0b64..bcfbb175e2b4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -83,6 +83,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
 	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
+	EHCI_HRTIMER_FREE_ITDS,		/* Wait for unused iTDs and siTDs */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
@@ -139,7 +140,9 @@ struct ehci_hcd {			/* one per controller */
 
 	/* list of itds &amp; sitds completed while clock_frame was still active */
 	struct list_head	cached_itd_list;
+	struct ehci_itd		*last_itd_to_free;
 	struct list_head	cached_sitd_list;
+	struct ehci_sitd	*last_sitd_to_free;
 	unsigned		clock_frame;
 
 	/* per root hub port */
@@ -250,8 +253,6 @@ timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
 	clear_bit (action, &amp;ehci-&gt;actions);
 }
 
-static void free_cached_lists(struct ehci_hcd *ehci);
-
 /*-------------------------------------------------------------------------*/
 
 #include &lt;linux/usb/ehci_def.h&gt;</pre><hr><pre>commit bf6387bcd16975ba8952b094f262a359d74e1c8a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:31 2012 -0400

    USB: EHCI: use hrtimer for controller death
    
    This patch (as1578) adds an hrtimer event to handle the death of an
    EHCI controller.  When a controller dies, it doesn't necessarily stop
    running right away.  The new event polls at 1-ms intervals to see when
    all activity has safely stopped.  This replaces a busy-wait polling
    loop in the current code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index edcfd2c4295e..1676c66b8530 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -888,20 +888,20 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status &amp; STS_FATAL) != 0)) {
 		ehci_err(ehci, "fatal error\n");
-		ehci-&gt;rh_state = EHCI_RH_STOPPING;
 		dbg_cmd(ehci, "fatal", cmd);
 		dbg_status(ehci, "fatal", status);
-		ehci_halt(ehci);
 dead:
-		ehci-&gt;enabled_hrtimer_events = 0;
-		hrtimer_try_to_cancel(&amp;ehci-&gt;hrtimer);
-		ehci_reset(ehci);
-		ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
 		usb_hc_died(hcd);
-		/* generic layer kills/unlinks all urbs, then
-		 * uses ehci_stop to clean up the rest
-		 */
-		bh = 1;
+
+		/* Don't let the controller do anything more */
+		ehci-&gt;rh_state = EHCI_RH_STOPPING;
+		ehci-&gt;command &amp;= ~(CMD_RUN | CMD_ASE | CMD_PSE);
+		ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+		ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
+		ehci_handle_controller_death(ehci);
+
+		/* Handle completions when the controller stops */
+		bh = 0;
 	}
 
 	if (bh)
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index bd8b591771b0..0c5326a8883c 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -69,6 +69,7 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
 static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
@@ -193,6 +194,30 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 }
 
 
+/* Poll the STS_HALT status bit; see when a dead controller stops */
+static void ehci_handle_controller_death(struct ehci_hcd *ehci)
+{
+	if (!(ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status) &amp; STS_HALT)) {
+
+		/* Give up after a few milliseconds */
+		if (ehci-&gt;died_poll_count++ &lt; 5) {
+			/* Try again later */
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_DEAD, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the controller to stop, giving up\n");
+	}
+
+	/* Clean up the mess */
+	ehci-&gt;rh_state = EHCI_RH_HALTED;
+	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;configured_flag);
+	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
+	ehci_work(ehci);
+
+	/* Not in process context, so don't try to reset the controller */
+}
+
+
 /* Handle unlinked interrupt QHs once they are gone from the hardware */
 static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 {
@@ -233,6 +258,7 @@ static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
 static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index f36f1f85d7fd..6874d89b0b64 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -81,6 +81,7 @@ enum ehci_rh_state {
 enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_ASS,		/* Poll for async schedule off */
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
+	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
@@ -97,6 +98,7 @@ struct ehci_hcd {			/* one per controller */
 
 	int			PSS_poll_count;
 	int			ASS_poll_count;
+	int			died_poll_count;
 
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;</pre><hr><pre>commit df2022553dd8d34d49e16c19d851ea619438f0ef
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:26 2012 -0400

    USB: EHCI: use hrtimer for interrupt QH unlink
    
    This patch (as1577) adds hrtimer support for unlinking interrupt QHs
    in ehci-hcd.  The current code relies on a fixed delay of either 2 or
    55 us, which is not always adequate and in any case is totally bogus.
    Thanks to internal caching, the EHCI hardware may continue to access
    an interrupt QH for more than a millisecond after it has been unlinked.
    
    In fact, the EHCI spec doesn't say how long to wait before using an
    unlinked interrupt QH.  The patch sets the delay to 9 microframes
    minimum, which ought to be adequate.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 21d6fbc0a327..edcfd2c4295e 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -309,6 +309,8 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
+static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
+static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 #include "ehci-timer.c"
 #include "ehci-hub.c"
@@ -1034,7 +1036,7 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
 		case QH_STATE_COMPLETING:
-			intr_deschedule (ehci, qh);
+			start_unlink_intr(ehci, qh);
 			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
@@ -1164,7 +1166,7 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			if (eptype == USB_ENDPOINT_XFER_BULK)
 				unlink_async(ehci, qh);
 			else
-				intr_deschedule(ehci, qh);
+				start_unlink_intr(ehci, qh);
 		}
 	}
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 25329e4b844f..8aa740dc510d 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -302,6 +302,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	if (ehci-&gt;async_unlink)
 		end_unlink_async(ehci);
+	ehci_handle_intr_unlinks(ehci);
 
 	/* allow remote wakeup */
 	mask = INTR_MASK;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 69b1861e4325..eec8446f8ded 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -578,12 +578,20 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	unsigned	i;
 	unsigned	period;
 
-	// FIXME:
-	// IF this isn't high speed
-	//   and this qh is active in the current uframe
-	//   (and overlay token SplitXstate is false?)
-	// THEN
-	//   qh-&gt;hw_info1 |= cpu_to_hc32(1 &lt;&lt; 7 /* "ignore" */);
+	/*
+	 * If qh is for a low/full-speed device, simply unlinking it
+	 * could interfere with an ongoing split transaction.  To unlink
+	 * it safely would require setting the QH_INACTIVATE bit and
+	 * waiting at least one frame, as described in EHCI 4.12.2.5.
+	 *
+	 * We won't bother with any of this.  Instead, we assume that the
+	 * only reason for unlinking an interrupt QH while the current URB
+	 * is still active is to dequeue all the URBs (flush the whole
+	 * endpoint queue).
+	 *
+	 * If rebalancing the periodic schedule is ever implemented, this
+	 * approach will no longer be valid.
+	 */
 
 	/* high bandwidth, or otherwise part of every microframe */
 	if ((period = qh-&gt;period) == 0)
@@ -608,12 +616,8 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;qh_next.ptr = NULL;
 }
 
-static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	unsigned		wait;
-	struct ehci_qh_hw	*hw = qh-&gt;hw;
-	int			rc;
-
 	/* If the QH isn't linked then there's nothing we can do
 	 * unless we were called during a giveback, in which case
 	 * qh_completions() has to deal with it.
@@ -626,28 +630,45 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	qh_unlink_periodic (ehci, qh);
 
-	/* simple/paranoid:  always delay, expecting the HC needs to read
-	 * qh-&gt;hw_next or finish a writeback after SPLIT/CSPLIT ... and
-	 * expect khubd to clean up after any CSPLITs we won't issue.
-	 * active high speed queues may need bigger delays...
+	/* Make sure the unlinks are visible before starting the timer */
+	wmb();
+
+	/*
+	 * The EHCI spec doesn't say how long it takes the controller to
+	 * stop accessing an unlinked interrupt QH.  The timer delay is
+	 * 9 uframes; presumably that will be long enough.
 	 */
-	if (list_empty (&amp;qh-&gt;qtd_list)
-			|| (cpu_to_hc32(ehci, QH_CMASK)
-					&amp; hw-&gt;hw_info2) != 0)
-		wait = 2;
+	qh-&gt;unlink_cycle = ehci-&gt;intr_unlink_cycle;
+
+	/* New entries go at the end of the intr_unlink list */
+	if (ehci-&gt;intr_unlink)
+		ehci-&gt;intr_unlink_last-&gt;unlink_next = qh;
 	else
-		wait = 55;	/* worst case: 3 * 1024 */
+		ehci-&gt;intr_unlink = qh;
+	ehci-&gt;intr_unlink_last = qh;
+
+	if (ehci-&gt;intr_unlinking)
+		;	/* Avoid recursive calls */
+	else if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
+		ehci_handle_intr_unlinks(ehci);
+	else if (ehci-&gt;intr_unlink == qh) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
+		++ehci-&gt;intr_unlink_cycle;
+	}
+}
+
+static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
+{
+	struct ehci_qh_hw	*hw = qh-&gt;hw;
+	int			rc;
 
-	udelay (wait);
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
-	wmb ();
 
 	qh_completions(ehci, qh);
 
 	/* reschedule QH iff another request is queued */
-	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
-			ehci-&gt;rh_state == EHCI_RH_RUNNING) {
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		rc = qh_schedule(ehci, qh);
 
 		/* An error here likely indicates handshake failure
@@ -2302,7 +2323,7 @@ scan_periodic (struct ehci_hcd *ehci)
 						temp.qh-&gt;stamp = ehci-&gt;periodic_stamp;
 					if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
 							temp.qh-&gt;needs_rescan))
-						intr_deschedule(ehci, temp.qh);
+						start_unlink_intr(ehci, temp.qh);
 				}
 				break;
 			case Q_TYPE_FSTN:
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 1e907dd3bb1b..bd8b591771b0 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -69,6 +69,7 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
 static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
+	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
@@ -192,6 +193,38 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 }
 
 
+/* Handle unlinked interrupt QHs once they are gone from the hardware */
+static void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)
+{
+	bool		stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+
+	/*
+	 * Process all the QHs on the intr_unlink list that were added
+	 * before the current unlink cycle began.  The list is in
+	 * temporal order, so stop when we reach the first entry in the
+	 * current cycle.  But if the root hub isn't running then
+	 * process all the QHs on the list.
+	 */
+	ehci-&gt;intr_unlinking = true;
+	while (ehci-&gt;intr_unlink) {
+		struct ehci_qh	*qh = ehci-&gt;intr_unlink;
+
+		if (!stopped &amp;&amp; qh-&gt;unlink_cycle == ehci-&gt;intr_unlink_cycle)
+			break;
+		ehci-&gt;intr_unlink = qh-&gt;unlink_next;
+		qh-&gt;unlink_next = NULL;
+		end_unlink_intr(ehci, qh);
+	}
+
+	/* Handle remaining entries later */
+	if (ehci-&gt;intr_unlink) {
+		ehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);
+		++ehci-&gt;intr_unlink_cycle;
+	}
+	ehci-&gt;intr_unlinking = false;
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -200,6 +233,7 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
 static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
+	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bf06bbb77ba4..f36f1f85d7fd 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -81,6 +81,7 @@ enum ehci_rh_state {
 enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_ASS,		/* Poll for async schedule off */
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
+	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
@@ -106,13 +107,16 @@ struct ehci_hcd {			/* one per controller */
 	spinlock_t		lock;
 	enum ehci_rh_state	rh_state;
 
+	/* general schedule support */
+	unsigned		scanning:1;
+	bool			intr_unlinking:1;
+
 	/* async schedule support */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct ehci_qh		*async_unlink;
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*qh_scan_next;
-	unsigned		scanning : 1;
 	unsigned		async_count;	/* async activity count */
 
 	/* periodic schedule support */
@@ -123,6 +127,9 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		i_thresh;	/* uframes HC might cache */
 
 	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
+	struct ehci_qh		*intr_unlink;
+	struct ehci_qh		*intr_unlink_last;
+	unsigned		intr_unlink_cycle;
 	int			next_uframe;	/* scan periodic, start here */
 	unsigned		periodic_count;	/* periodic activity count */
 	unsigned		uframe_periodic_max; /* max periodic time per uframe */
@@ -385,6 +392,7 @@ struct ehci_qh {
 	struct ehci_qh		*unlink_next;	/* next on unlink list */
 
 	unsigned long		unlink_time;
+	unsigned		unlink_cycle;
 	unsigned		stamp;
 
 	u8			needs_rescan;	/* Dequeue during giveback */</pre><hr><pre>commit 314466101c6ae14f6f5db8a86eda1509ba2c02a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:21 2012 -0400

    USB: EHCI: use hrtimer for async schedule
    
    This patch (as1576) adds hrtimer support for managing ehci-hcd's
    async schedule.  Just as with the earlier change to the periodic
    schedule management, two new hrtimer events take care of everything.
    
    One event polls at 1-ms intervals to see when the Asynchronous
    Schedule Status (ASS) flag matches the Asynchronous Schedule Enable
    (ASE) value; the schedule's state must not be changed until it does.
    The other event delays for 15 ms after the async schedule becomes
    empty before turning it off.
    
    The new events replace a busy-wait poll and a kernel timer usage.
    They also replace the rather illogical method currently used for
    indicating the async schedule should be turned off: attempting to
    unlink the dedicated QH at the head of the async list.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fd7ae16f77be..21d6fbc0a327 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -95,7 +95,6 @@ static const char	hcd_name [] = "ehci_hcd";
 
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
-#define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
 #define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
 						/* 5-ms async qh unlink delay */
 
@@ -137,7 +136,7 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 	 * SHRINK were pending, OFF would never be requested.
 	 */
 	if (timer_pending(&amp;ehci-&gt;watchdog)
-			&amp;&amp; ((BIT(TIMER_ASYNC_SHRINK) | BIT(TIMER_ASYNC_OFF))
+			&amp;&amp; (BIT(TIMER_ASYNC_SHRINK)
 				&amp; ehci-&gt;actions))
 		return;
 
@@ -150,9 +149,6 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 				return;
 			t = EHCI_IO_JIFFIES;
 			break;
-		case TIMER_ASYNC_OFF:
-			t = EHCI_ASYNC_JIFFIES;
-			break;
 		/* case TIMER_ASYNC_SHRINK: */
 		default:
 			t = EHCI_SHRINK_JIFFIES;
@@ -376,10 +372,6 @@ static void ehci_watchdog(unsigned long param)
 
 	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 
-	/* stop async processing after it's idled a bit */
-	if (test_bit (TIMER_ASYNC_OFF, &amp;ehci-&gt;actions))
-		start_unlink_async (ehci, ehci-&gt;async);
-
 	/* ehci could run by timer, without IRQs ... */
 	ehci_work (ehci);
 
@@ -470,7 +462,8 @@ static void ehci_work (struct ehci_hcd *ehci)
 	if (ehci-&gt;scanning)
 		return;
 	ehci-&gt;scanning = 1;
-	scan_async (ehci);
+	if (ehci-&gt;async_count)
+		scan_async(ehci);
 	if (ehci-&gt;next_uframe != -1)
 		scan_periodic (ehci);
 	ehci-&gt;scanning = 0;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 285d5a0f3f70..d68764ef4476 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -964,6 +964,30 @@ qh_make (
 
 /*-------------------------------------------------------------------------*/
 
+static void enable_async(struct ehci_hcd *ehci)
+{
+	if (ehci-&gt;async_count++)
+		return;
+
+	/* Stop waiting to turn off the async schedule */
+	ehci-&gt;enabled_hrtimer_events &amp;= ~BIT(EHCI_HRTIMER_DISABLE_ASYNC);
+
+	/* Don't start the schedule until ASS is 0 */
+	ehci_poll_ASS(ehci);
+}
+
+static void disable_async(struct ehci_hcd *ehci)
+{
+	if (--ehci-&gt;async_count)
+		return;
+
+	/* The async schedule and async_unlink list are supposed to be empty */
+	WARN_ON(ehci-&gt;async-&gt;qh_next.qh || ehci-&gt;async_unlink);
+
+	/* Don't turn off the schedule until ASS is 1 */
+	ehci_poll_ASS(ehci);
+}
+
 /* move qh (and its qtds) onto async queue; maybe enable queue.  */
 
 static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -977,24 +1001,11 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	WARN_ON(qh-&gt;qh_state != QH_STATE_IDLE);
 
-	/* (re)start the async schedule? */
-	head = ehci-&gt;async;
-	timer_action_done (ehci, TIMER_ASYNC_OFF);
-	if (!head-&gt;qh_next.qh) {
-		if (!(ehci-&gt;command &amp; CMD_ASE)) {
-			/* in case a clear of CMD_ASE didn't take yet */
-			(void)handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
-					STS_ASS, 0, 150);
-			ehci-&gt;command |= CMD_ASE;
-			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-			/* posted write need not be known to HC yet ... */
-		}
-	}
-
 	/* clear halt and/or toggle; and maybe recover from silicon quirk */
 	qh_refresh(ehci, qh);
 
 	/* splice right after start */
+	head = ehci-&gt;async;
 	qh-&gt;qh_next = head-&gt;qh_next;
 	qh-&gt;hw-&gt;hw_next = head-&gt;hw-&gt;hw_next;
 	wmb ();
@@ -1005,6 +1016,8 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;xacterrs = 0;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
+
+	enable_async(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1173,16 +1186,10 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 
 	qh_completions (ehci, qh);
 
-	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		qh_link_async (ehci, qh);
-	} else {
-		/* it's not free to turn the async schedule on/off; leave it
-		 * active but idle for a while once it empties.
-		 */
-		if (ehci-&gt;rh_state == EHCI_RH_RUNNING
-				&amp;&amp; ehci-&gt;async-&gt;qh_next.qh == NULL)
-			timer_action (ehci, TIMER_ASYNC_OFF);
-	}
+
+	disable_async(ehci);
 
 	if (next) {
 		ehci-&gt;async_unlink = NULL;
@@ -1210,21 +1217,6 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		BUG ();
 #endif
 
-	/* stop async schedule right now? */
-	if (unlikely (qh == ehci-&gt;async)) {
-		/* can't get here without STS_ASS set */
-		if (ehci-&gt;rh_state != EHCI_RH_HALTED
-				&amp;&amp; !ehci-&gt;async_unlink) {
-			/* ... and CMD_IAAD clear */
-			ehci-&gt;command &amp;= ~CMD_ASE;
-			ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
-			wmb ();
-			// handshake later, if we need to
-			timer_action_done (ehci, TIMER_ASYNC_OFF);
-		}
-		return;
-	}
-
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	ehci-&gt;async_unlink = qh;
 	if (!qh-&gt;unlink_next)
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index ecd3296157c6..1e907dd3bb1b 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -67,8 +67,10 @@ static void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)
  * the event types indexed by enum ehci_hrtimer_event in ehci.h.
  */
 static unsigned event_delays_ns[] = {
+	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_ASS */
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_PSS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
+	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
 
 /* Enable a pending hrtimer event */
@@ -91,6 +93,51 @@ static void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,
 }
 
 
+/* Poll the STS_ASS status bit; see when it agrees with CMD_ASE */
+static void ehci_poll_ASS(struct ehci_hcd *ehci)
+{
+	unsigned	actual, want;
+
+	/* Don't enable anything if the controller isn't running (e.g., died) */
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		return;
+
+	want = (ehci-&gt;command &amp; CMD_ASE) ? STS_ASS : 0;
+	actual = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status) &amp; STS_ASS;
+
+	if (want != actual) {
+
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+			return;
+		}
+		ehci_warn(ehci, "Waited too long for the async schedule status, giving up\n");
+	}
+	ehci-&gt;ASS_poll_count = 0;
+
+	/* The status is up-to-date; restart or stop the schedule as needed */
+	if (want == 0) {	/* Stopped */
+		if (ehci-&gt;async_count &gt; 0)
+			ehci_set_command_bit(ehci, CMD_ASE);
+
+	} else {		/* Running */
+		if (ehci-&gt;async_count == 0) {
+
+			/* Turn off the schedule after a while */
+			ehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_ASYNC,
+					true);
+		}
+	}
+}
+
+/* Turn off the async schedule after a brief delay */
+static void ehci_disable_ASE(struct ehci_hcd *ehci)
+{
+	ehci_clear_command_bit(ehci, CMD_ASE);
+}
+
+
 /* Poll the STS_PSS status bit; see when it agrees with CMD_PSE */
 static void ehci_poll_PSS(struct ehci_hcd *ehci)
 {
@@ -151,8 +198,10 @@ static void ehci_disable_PSE(struct ehci_hcd *ehci)
  * enum ehci_hrtimer_event in ehci.h.
  */
 static void (*event_handlers[])(struct ehci_hcd *) = {
+	ehci_poll_ASS,			/* EHCI_HRTIMER_POLL_ASS */
 	ehci_poll_PSS,			/* EHCI_HRTIMER_POLL_PSS */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
+	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index da2e0ab23850..bf06bbb77ba4 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -79,8 +79,10 @@ enum ehci_rh_state {
  * ehci-timer.c) in parallel with this list.
  */
 enum ehci_hrtimer_event {
+	EHCI_HRTIMER_POLL_ASS,		/* Poll for async schedule off */
 	EHCI_HRTIMER_POLL_PSS,		/* Poll for periodic schedule off */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
+	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
 };
 #define EHCI_HRTIMER_NO_EVENT	99
@@ -93,6 +95,7 @@ struct ehci_hcd {			/* one per controller */
 	struct hrtimer		hrtimer;
 
 	int			PSS_poll_count;
+	int			ASS_poll_count;
 
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;
@@ -110,6 +113,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*qh_scan_next;
 	unsigned		scanning : 1;
+	unsigned		async_count;	/* async activity count */
 
 	/* periodic schedule support */
 #define	DEFAULT_I_TDPS		1024		/* some HCs can do less */
@@ -229,7 +233,6 @@ static inline void iaa_watchdog_done(struct ehci_hcd *ehci)
 enum ehci_timer_action {
 	TIMER_IO_WATCHDOG,
 	TIMER_ASYNC_SHRINK,
-	TIMER_ASYNC_OFF,
 };
 
 static inline void</pre><hr><pre>commit 9671cd7a91059bcd27665a884ee6568d31ef6857
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:16 2012 -0400

    USB: EHCI: remove PS3 status polling
    
    This patch (as1575) removes special code added for status polling of
    the EHCI controller in PS3 systems.  While the controller is running,
    the polling is now carried out by an hrtimer handler.  When the
    controller is suspending or stopping, we use the same polling routine
    as the old code -- but in neither case do we need to conclude that the
    controller has died if the polling goes on for too long.
    
    As a result the entire handshake_on_error_set_halt() routine is now
    unused, so it is removed from the driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 7e00ca095cea..fd7ae16f77be 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -235,68 +235,6 @@ static int ehci_halt (struct ehci_hcd *ehci)
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
-#if defined(CONFIG_USB_SUSPEND) &amp;&amp; defined(CONFIG_PPC_PS3)
-
-/*
- * The EHCI controller of the Cell Super Companion Chip used in the
- * PS3 will stop the root hub after all root hub ports are suspended.
- * When in this condition handshake will return -ETIMEDOUT.  The
- * STS_HLT bit will not be set, so inspection of the frame index is
- * used here to test for the condition.  If the condition is found
- * return success to allow the USB suspend to complete.
- */
-
-static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
-					 void __iomem *ptr, u32 mask, u32 done,
-					 int usec)
-{
-	unsigned int old_index;
-	int error;
-
-	if (!firmware_has_feature(FW_FEATURE_PS3_LV1))
-		return -ETIMEDOUT;
-
-	old_index = ehci_read_frame_index(ehci);
-
-	error = handshake(ehci, ptr, mask, done, usec);
-
-	if (error == -ETIMEDOUT &amp;&amp; ehci_read_frame_index(ehci) == old_index)
-		return 0;
-
-	return error;
-}
-
-#else
-
-static int handshake_for_broken_root_hub(struct ehci_hcd *ehci,
-					 void __iomem *ptr, u32 mask, u32 done,
-					 int usec)
-{
-	return -ETIMEDOUT;
-}
-
-#endif
-
-static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
-				       u32 mask, u32 done, int usec)
-{
-	int error;
-
-	error = handshake(ehci, ptr, mask, done, usec);
-	if (error == -ETIMEDOUT)
-		error = handshake_for_broken_root_hub(ehci, ptr, mask, done,
-						      usec);
-
-	if (error) {
-		ehci_halt(ehci);
-		ehci-&gt;rh_state = EHCI_RH_HALTED;
-		ehci_err(ehci, "force halt; handshake %p %08x %08x -&gt; %d\n",
-			ptr, mask, done, error);
-	}
-
-	return error;
-}
-
 /* put TDI/ARC silicon into EHCI mode */
 static void tdi_reset (struct ehci_hcd *ehci)
 {
@@ -361,17 +299,14 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 	/* wait for any schedule enables/disables to take effect */
 	temp = (ehci-&gt;command &lt;&lt; 10) &amp; (STS_ASS | STS_PSS);
-	if (handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
-					STS_ASS | STS_PSS, temp, 16 * 125))
-		return;
+	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, temp, 16 * 125);
 
 	/* then disable anything that's still active */
 	ehci-&gt;command &amp;= ~(CMD_ASE | CMD_PSE);
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 
 	/* hardware can take 16 microframes to turn off ... */
-	handshake_on_error_set_halt(ehci, &amp;ehci-&gt;regs-&gt;status,
-				    STS_ASS | STS_PSS, 0, 16 * 125);
+	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, 0, 16 * 125);
 }
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit b015cb79ce84944076a8a849055f898f2a4d6be8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:10 2012 -0400

    USB: EHCI: return void instead of 0
    
    This patch (as1574) changes the return type of multiple functions in
    ehci-sched.c from int to void.  The values they return are now always
    0, so there's no reason for them to return any value at all.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index f5c15880c65a..69b1861e4325 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -479,29 +479,27 @@ static int tt_no_collision (
 
 /*-------------------------------------------------------------------------*/
 
-static int enable_periodic (struct ehci_hcd *ehci)
+static void enable_periodic(struct ehci_hcd *ehci)
 {
 	if (ehci-&gt;periodic_count++)
-		return 0;
+		return;
 
 	/* Stop waiting to turn off the periodic schedule */
 	ehci-&gt;enabled_hrtimer_events &amp;= ~BIT(EHCI_HRTIMER_DISABLE_PERIODIC);
 
 	/* Don't start the schedule until PSS is 0 */
 	ehci_poll_PSS(ehci);
-	return 0;
 }
 
-static int disable_periodic (struct ehci_hcd *ehci)
+static void disable_periodic(struct ehci_hcd *ehci)
 {
 	if (--ehci-&gt;periodic_count)
-		return 0;
+		return;
 
 	ehci-&gt;next_uframe = -1;		/* the periodic schedule is empty */
 
 	/* Don't turn off the schedule until PSS is 1 */
 	ehci_poll_PSS(ehci);
-	return 0;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -512,7 +510,7 @@ static int disable_periodic (struct ehci_hcd *ehci)
  * this just links in a qh; caller guarantees uframe masks are set right.
  * no FSTN support (yet; ehci 0.96+)
  */
-static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	unsigned	i;
 	unsigned	period = qh-&gt;period;
@@ -572,10 +570,10 @@ static int qh_link_periodic (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		: (qh-&gt;usecs * 8);
 
 	/* maybe enable periodic schedule processing */
-	return enable_periodic(ehci);
+	enable_periodic(ehci);
 }
 
-static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
+static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	unsigned	i;
 	unsigned	period;
@@ -608,8 +606,6 @@ static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* qh-&gt;qh_next still "live" to HC */
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	qh-&gt;qh_next.ptr = NULL;
-
-	return 0;
 }
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -843,7 +839,7 @@ static int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		ehci_dbg (ehci, "reused qh %p schedule\n", qh);
 
 	/* stuff into the periodic schedule */
-	status = qh_link_periodic (ehci, qh);
+	qh_link_periodic(ehci, qh);
 done:
 	return status;
 }
@@ -1574,8 +1570,7 @@ itd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_itd *itd)
 }
 
 /* fit urb's itds into the selected schedule slot; activate as needed */
-static int
-itd_link_urb (
+static void itd_link_urb(
 	struct ehci_hcd		*ehci,
 	struct urb		*urb,
 	unsigned		mod,
@@ -1646,7 +1641,7 @@ itd_link_urb (
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
-	return enable_periodic(ehci);
+	enable_periodic(ehci);
 }
 
 #define	ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
@@ -1726,7 +1721,7 @@ itd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
-	(void) disable_periodic(ehci);
+	disable_periodic(ehci);
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {
@@ -1993,8 +1988,7 @@ sitd_link (struct ehci_hcd *ehci, unsigned frame, struct ehci_sitd *sitd)
 }
 
 /* fit urb's sitds into the selected schedule slot; activate as needed */
-static int
-sitd_link_urb (
+static void sitd_link_urb(
 	struct ehci_hcd		*ehci,
 	struct urb		*urb,
 	unsigned		mod,
@@ -2056,7 +2050,7 @@ sitd_link_urb (
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
-	return enable_periodic(ehci);
+	enable_periodic(ehci);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2122,7 +2116,7 @@ sitd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
-	(void) disable_periodic(ehci);
+	disable_periodic(ehci);
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {</pre>
    <div class="pagination">
        <a href='2_45.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><span>[46]</span><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_47.html'>Next&gt;&gt;</a>
    <div>
</body>
