<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_17.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><span>[18]</span><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_19.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit dd0af9f94e54efb13ee050ebac11909215ef02c2
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Apr 21 15:32:33 2009 -0500

    [SCSI] cxgb3i: fix can_queue and cmd_per_lun initialization
    
    cxgb3i was setting can_queue to only 128 commands, and was
    setting the can_queue and cmd_per_lun to the same value.
    
    This sets the can_queue to 1024 commands, and sets the cmd_per_lun
    to a safer default of 32.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/cxgb3i/cxgb3i.h b/drivers/scsi/cxgb3i/cxgb3i.h
index d362860e7504..59b0958d2d11 100644
--- a/drivers/scsi/cxgb3i/cxgb3i.h
+++ b/drivers/scsi/cxgb3i/cxgb3i.h
@@ -34,7 +34,7 @@
 #include "cxgb3i_offload.h"
 #include "cxgb3i_ddp.h"
 
-#define CXGB3I_SCSI_QDEPTH_DFLT	128
+#define CXGB3I_SCSI_HOST_QDEPTH 1024
 #define CXGB3I_MAX_TARGET	CXGB3I_MAX_CONN
 #define CXGB3I_MAX_LUN		512
 #define ISCSI_PDU_NONPAYLOAD_MAX \
diff --git a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
index b3ca3a05f0d9..9212400b9b13 100644
--- a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
+++ b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
@@ -876,10 +876,10 @@ static struct scsi_host_template cxgb3i_host_template = {
 	.proc_name		= "cxgb3i",
 	.queuecommand		= iscsi_queuecommand,
 	.change_queue_depth	= iscsi_change_queue_depth,
-	.can_queue		= CXGB3I_SCSI_QDEPTH_DFLT - 1,
+	.can_queue		= CXGB3I_SCSI_HOST_QDEPTH,
 	.sg_tablesize		= SG_ALL,
 	.max_sectors		= 0xFFFF,
-	.cmd_per_lun		= CXGB3I_SCSI_QDEPTH_DFLT,
+	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
 	.eh_abort_handler	= iscsi_eh_abort,
 	.eh_device_reset_handler = iscsi_eh_device_reset,
 	.eh_target_reset_handler = iscsi_eh_target_reset,</pre><hr><pre>commit 6b5d6c443a9b4fd71b633cef66b5db4de8a85787
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Apr 21 15:32:32 2009 -0500

    [SCSI] cxgb3i, iser, iscsi_tcp: set target can queue
    
    Set target can queue limit to the number of preallocated
    session tasks we have.
    
    This along with the cxgb3i can_queue patch will fix a throughput
    problem where it could only queue one LU worth of data at a time.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 13d7674b293d..75223f50de58 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -599,6 +599,7 @@ static struct scsi_host_template iscsi_iser_sht = {
 	.eh_abort_handler       = iscsi_eh_abort,
 	.eh_device_reset_handler= iscsi_eh_device_reset,
 	.eh_target_reset_handler= iscsi_eh_target_reset,
+	.target_alloc		= iscsi_target_alloc,
 	.use_clustering         = DISABLE_CLUSTERING,
 	.proc_name              = "iscsi_iser",
 	.this_id                = -1,
diff --git a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
index fff8e4327644..b3ca3a05f0d9 100644
--- a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
+++ b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
@@ -883,6 +883,7 @@ static struct scsi_host_template cxgb3i_host_template = {
 	.eh_abort_handler	= iscsi_eh_abort,
 	.eh_device_reset_handler = iscsi_eh_device_reset,
 	.eh_target_reset_handler = iscsi_eh_target_reset,
+	.target_alloc		= iscsi_target_alloc,
 	.use_clustering		= DISABLE_CLUSTERING,
 	.this_id		= -1,
 };
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index f97fc7e9de79..b7c092d63bbe 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -851,6 +851,7 @@ static struct scsi_host_template iscsi_sw_tcp_sht = {
 	.use_clustering         = DISABLE_CLUSTERING,
 	.slave_alloc            = iscsi_sw_tcp_slave_alloc,
 	.slave_configure        = iscsi_sw_tcp_slave_configure,
+	.target_alloc		= iscsi_target_alloc,
 	.proc_name		= "iscsi_tcp",
 	.this_id		= -1,
 };
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 689628359169..e72b4ad47d35 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1463,6 +1463,16 @@ int iscsi_change_queue_depth(struct scsi_device *sdev, int depth)
 }
 EXPORT_SYMBOL_GPL(iscsi_change_queue_depth);
 
+int iscsi_target_alloc(struct scsi_target *starget)
+{
+	struct iscsi_cls_session *cls_session = starget_to_session(starget);
+	struct iscsi_session *session = cls_session-&gt;dd_data;
+
+	starget-&gt;can_queue = session-&gt;scsi_cmds_max;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_target_alloc);
+
 void iscsi_session_recovery_timedout(struct iscsi_cls_session *cls_session)
 {
 	struct iscsi_session *session = cls_session-&gt;dd_data;
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 7ffaed2f94dd..0289f5745fb9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -36,6 +36,7 @@ struct scsi_transport_template;
 struct scsi_host_template;
 struct scsi_device;
 struct Scsi_Host;
+struct scsi_target;
 struct scsi_cmnd;
 struct socket;
 struct iscsi_transport;
@@ -350,6 +351,7 @@ extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
 					  bool xmit_can_sleep);
 extern void iscsi_host_remove(struct Scsi_Host *shost);
 extern void iscsi_host_free(struct Scsi_Host *shost);
+extern int iscsi_target_alloc(struct scsi_target *starget);
 
 /*
  * session management</pre><hr><pre>commit 9a6510eb3f030cedba32664498a610dc6d084d46
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Apr 21 15:32:31 2009 -0500

    [SCSI] iscsi_tcp: don't fire conn error if pdu init fails
    
    If a command's scsi cmd pdu setup fails then we can just fail
    the IO to the scsi layer. If a DATA_OUT for a R2T fails then
    we will want to drop the session, because it means we got a
    bad request from the target (iscsi protocol error).
    
    This patch has us propogate the error upwards so libiscsi_tcp
    or libiscsi can decide what the best action is to take. It
    also fixes a bug where we could try to grab the session lock
    while holding it, because if iscsi_tcp drops the session in the
    pdu setup callout the session lock is held when setting up the
    scsi cmd pdu.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index b3e5e08e44ab..f97fc7e9de79 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -463,7 +463,7 @@ static int iscsi_sw_tcp_pdu_init(struct iscsi_task *task,
 	}
 
 	if (err) {
-		iscsi_conn_failure(conn, err);
+		/* got invalid offset/len */
 		return -EIO;
 	}
 	return 0;
diff --git a/drivers/scsi/libiscsi_tcp.c b/drivers/scsi/libiscsi_tcp.c
index 91f8ce4d8d08..b579ca9f4836 100644
--- a/drivers/scsi/libiscsi_tcp.c
+++ b/drivers/scsi/libiscsi_tcp.c
@@ -1036,8 +1036,11 @@ int iscsi_tcp_task_xmit(struct iscsi_task *task)
 
 	rc = conn-&gt;session-&gt;tt-&gt;init_pdu(task, r2t-&gt;data_offset + r2t-&gt;sent,
 					 r2t-&gt;data_count);
-	if (rc)
+	if (rc) {
+		iscsi_conn_failure(conn, ISCSI_ERR_XMIT_FAILED);
 		return rc;
+	}
+
 	r2t-&gt;sent += r2t-&gt;data_count;
 	goto flush;
 }</pre><hr><pre>commit b4efdd586bc08cdf5977cad0a90091f44546a930
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Apr 9 15:57:10 2009 -0500

    [SCSI] fix q-&gt;lock not held warning when target is busy
    
    We cannot call blk_plug_device from scsi_target_queue_ready
    because the q lock is not held. And we do not need to call
    it from there because when we return 0, the scsi_request_fn
    not_ready handling will plug the queue for us if needed.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index d1cb64ad1a3f..bb218c8b6e98 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -1291,10 +1291,8 @@ static inline int scsi_target_queue_ready(struct Scsi_Host *shost,
 		if (--starget-&gt;target_blocked == 0) {
 			SCSI_LOG_MLQUEUE(3, starget_printk(KERN_INFO, starget,
 					 "unblocking target at zero depth\n"));
-		} else {
-			blk_plug_device(sdev-&gt;request_queue);
+		} else
 			return 0;
-		}
 	}
 
 	if (scsi_target_is_busy(starget)) {</pre><hr><pre>commit 5b2639d59afe0a30e1b955b23c52ee9099888058
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Apr 1 13:11:28 2009 -0500

    [SCSI] cxgb3i: call ddp release function directly
    
    cxgb3i_ddp_cleanup just calls ddp_release directly so there is
    no reason for the wrapper. This patch just renames ddp_release
    to cxgb3i_ddp_cleanup and removes the old wrapper function.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/cxgb3i/cxgb3i_ddp.c b/drivers/scsi/cxgb3i/cxgb3i_ddp.c
index 275d2da443be..d06a661c209f 100644
--- a/drivers/scsi/cxgb3i/cxgb3i_ddp.c
+++ b/drivers/scsi/cxgb3i/cxgb3i_ddp.c
@@ -587,12 +587,12 @@ int cxgb3i_adapter_ddp_info(struct t3cdev *tdev,
 }
 
 /**
- * ddp_release - release the cxgb3 adapter's ddp resource
+ * cxgb3i_ddp_cleanup - release the cxgb3 adapter's ddp resource
  * @tdev: t3cdev adapter
  * release all the resource held by the ddp pagepod manager for a given
  * adapter if needed
  */
-static void ddp_release(struct t3cdev *tdev)
+void cxgb3i_ddp_cleanup(struct t3cdev *tdev)
 {
 	int i = 0;
 	struct cxgb3i_ddp_info *ddp = (struct cxgb3i_ddp_info *)tdev-&gt;ulp_iscsi;
@@ -714,11 +714,3 @@ void cxgb3i_ddp_init(struct t3cdev *tdev)
 	}
 	ddp_init(tdev);
 }
-
-/**
- * cxgb3i_ddp_cleaup - clean up ddp function
- */
-void cxgb3i_ddp_cleanup(struct t3cdev *tdev)
-{
-	ddp_release(tdev);
-}</pre><hr><pre>commit ed6f7744f90a0efc6874f2ab93e4e593741079c9
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Apr 1 13:11:25 2009 -0500

    [SCSI] cxgb3i: re-read ddp settings information after chip reset
    
    Orignally from Karen Xie, but merge conflicts/errors fixed up by
    Mike Christie.
    
    Signed-off-by: Karen Xie &lt;kxie@chelsio.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/cxgb3i/cxgb3i.h b/drivers/scsi/cxgb3i/cxgb3i.h
index 0942227aa7ba..d362860e7504 100644
--- a/drivers/scsi/cxgb3i/cxgb3i.h
+++ b/drivers/scsi/cxgb3i/cxgb3i.h
@@ -141,7 +141,7 @@ int cxgb3i_iscsi_init(void);
 void cxgb3i_iscsi_cleanup(void);
 
 struct cxgb3i_adapter *cxgb3i_adapter_find_by_tdev(struct t3cdev *);
-struct cxgb3i_adapter *cxgb3i_adapter_open(struct t3cdev *);
+void cxgb3i_adapter_open(struct t3cdev *);
 void cxgb3i_adapter_close(struct t3cdev *);
 
 struct cxgb3i_hba *cxgb3i_hba_find_by_netdev(struct net_device *);
diff --git a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
index ff6bfd66733f..fff8e4327644 100644
--- a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
+++ b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
@@ -71,37 +71,34 @@ struct cxgb3i_adapter *cxgb3i_adapter_find_by_tdev(struct t3cdev *tdev)
 	return NULL;
 }
 
-/**
- * cxgb3i_adapter_open - init a s3 adapter structure and any h/w settings
- * @t3dev: t3cdev adapter
- * return the resulting cxgb3i_adapter struct
- */
-struct cxgb3i_adapter *cxgb3i_adapter_open(struct t3cdev *t3dev)
+static inline int adapter_update(struct cxgb3i_adapter *snic)
 {
-	struct cxgb3i_adapter *snic;
-	struct adapter *adapter = tdev2adap(t3dev);
-	int i;
+	cxgb3i_log_info("snic 0x%p, t3dev 0x%p, updating.\n",
+			snic, snic-&gt;tdev);
+	return cxgb3i_adapter_ddp_info(snic-&gt;tdev, &amp;snic-&gt;tag_format,
+					&amp;snic-&gt;tx_max_size,
+					&amp;snic-&gt;rx_max_size);
+}
 
-	snic = kzalloc(sizeof(*snic), GFP_KERNEL);
-	if (!snic) {
-		cxgb3i_api_debug("cxgb3 %s, OOM.\n", t3dev-&gt;name);
-		return NULL;
-	}
-	spin_lock_init(&amp;snic-&gt;lock);
+static int adapter_add(struct cxgb3i_adapter *snic)
+{
+	struct t3cdev *t3dev = snic-&gt;tdev;
+	struct adapter *adapter = tdev2adap(t3dev);
+	int i, err;
 
-	snic-&gt;tdev = t3dev;
 	snic-&gt;pdev = adapter-&gt;pdev;
 	snic-&gt;tag_format.sw_bits = sw_tag_idx_bits + sw_tag_age_bits;
 
-	if (cxgb3i_adapter_ddp_init(t3dev, &amp;snic-&gt;tag_format,
+	err = cxgb3i_adapter_ddp_info(t3dev, &amp;snic-&gt;tag_format,
 				    &amp;snic-&gt;tx_max_size,
-				    &amp;snic-&gt;rx_max_size) &lt; 0)
-		goto free_snic;
+				    &amp;snic-&gt;rx_max_size);
+	if (err &lt; 0)
+		return err;
 
 	for_each_port(adapter, i) {
 		snic-&gt;hba[i] = cxgb3i_hba_host_add(snic, adapter-&gt;port[i]);
 		if (!snic-&gt;hba[i])
-			goto ulp_cleanup;
+			return -EINVAL;
 	}
 	snic-&gt;hba_cnt = adapter-&gt;params.nports;
 
@@ -110,13 +107,40 @@ struct cxgb3i_adapter *cxgb3i_adapter_open(struct t3cdev *t3dev)
 	list_add_tail(&amp;snic-&gt;list_head, &amp;cxgb3i_snic_list);
 	write_unlock(&amp;cxgb3i_snic_rwlock);
 
-	return snic;
+	cxgb3i_log_info("t3dev 0x%p open, snic 0x%p, %u scsi hosts added.\n",
+			t3dev, snic, snic-&gt;hba_cnt);
+	return 0;
+}
 
-ulp_cleanup:
-	cxgb3i_adapter_ddp_cleanup(t3dev);
-free_snic:
-	kfree(snic);
-	return NULL;
+/**
+ * cxgb3i_adapter_open - init a s3 adapter structure and any h/w settings
+ * @t3dev: t3cdev adapter
+ */
+void cxgb3i_adapter_open(struct t3cdev *t3dev)
+{
+	struct cxgb3i_adapter *snic = cxgb3i_adapter_find_by_tdev(t3dev);
+	int err;
+
+	if (snic)
+		err = adapter_update(snic);
+	else {
+		snic = kzalloc(sizeof(*snic), GFP_KERNEL);
+		if (snic) {
+			spin_lock_init(&amp;snic-&gt;lock);
+			snic-&gt;tdev = t3dev;
+			err = adapter_add(snic);
+		} else
+			err = -ENOMEM;
+	}
+
+	if (err &lt; 0) {
+		cxgb3i_log_info("snic 0x%p, f 0x%x, t3dev 0x%p open, err %d.\n",
+				snic, snic ? snic-&gt;flags : 0, t3dev, err);
+		if (snic) {
+			snic-&gt;flags &amp;= ~CXGB3I_ADAPTER_FLAG_RESET;
+			cxgb3i_adapter_close(t3dev);
+		}
+	}
 }
 
 /**
@@ -125,31 +149,29 @@ struct cxgb3i_adapter *cxgb3i_adapter_open(struct t3cdev *t3dev)
  */
 void cxgb3i_adapter_close(struct t3cdev *t3dev)
 {
+	struct cxgb3i_adapter *snic = cxgb3i_adapter_find_by_tdev(t3dev);
 	int i;
-	struct cxgb3i_adapter *snic;
+
+	if (!snic || snic-&gt;flags &amp; CXGB3I_ADAPTER_FLAG_RESET) {
+		cxgb3i_log_info("t3dev 0x%p close, snic 0x%p, f 0x%x.\n",
+				t3dev, snic, snic ? snic-&gt;flags : 0);
+		return;
+	}
 
 	/* remove from the list */
 	write_lock(&amp;cxgb3i_snic_rwlock);
-	list_for_each_entry(snic, &amp;cxgb3i_snic_list, list_head) {
-		if (snic-&gt;tdev == t3dev) {
-			list_del(&amp;snic-&gt;list_head);
-			break;
-		}
-	}
+	list_del(&amp;snic-&gt;list_head);
 	write_unlock(&amp;cxgb3i_snic_rwlock);
 
-	if (snic) {
-		for (i = 0; i &lt; snic-&gt;hba_cnt; i++) {
-			if (snic-&gt;hba[i]) {
-				cxgb3i_hba_host_remove(snic-&gt;hba[i]);
-				snic-&gt;hba[i] = NULL;
-			}
+	for (i = 0; i &lt; snic-&gt;hba_cnt; i++) {
+		if (snic-&gt;hba[i]) {
+			cxgb3i_hba_host_remove(snic-&gt;hba[i]);
+			snic-&gt;hba[i] = NULL;
 		}
-
-		/* release ddp resources */
-		cxgb3i_adapter_ddp_cleanup(snic-&gt;tdev);
-		kfree(snic);
 	}
+	cxgb3i_log_info("t3dev 0x%p close, snic 0x%p, %u scsi hosts removed.\n",
+			t3dev, snic, snic-&gt;hba_cnt);
+	kfree(snic);
 }
 
 /**
@@ -189,7 +211,8 @@ struct cxgb3i_hba *cxgb3i_hba_host_add(struct cxgb3i_adapter *snic,
 	shost = iscsi_host_alloc(&amp;cxgb3i_host_template,
 				 sizeof(struct cxgb3i_hba), 1);
 	if (!shost) {
-		cxgb3i_log_info("iscsi_host_alloc failed.\n");
+		cxgb3i_log_info("snic 0x%p, ndev 0x%p, host_alloc failed.\n",
+				snic, ndev);
 		return NULL;
 	}
 
@@ -207,7 +230,8 @@ struct cxgb3i_hba *cxgb3i_hba_host_add(struct cxgb3i_adapter *snic,
 	pci_dev_get(snic-&gt;pdev);
 	err = iscsi_host_add(shost, &amp;snic-&gt;pdev-&gt;dev);
 	if (err) {
-		cxgb3i_log_info("iscsi_host_add failed.\n");
+		cxgb3i_log_info("snic 0x%p, ndev 0x%p, host_add failed.\n",
+				snic, ndev);
 		goto pci_dev_put;
 	}
 </pre><hr><pre>commit 728996829b3e2a3bbacb7390e6c040dd839cdf21
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Mar 5 14:46:07 2009 -0600

    [SCSI] libiscsi: fix possbile null ptr session command cleanup
    
    If the iscsi eh fires when the current task is a nop, then
    the task-&gt;sc pointer is null. fail_all_commands could
    then try to do task-&gt;sc-&gt;device and oops. We actually do
    not need to access the curr task in this path, because
    if it is a cmd task the fail_command call will handle
    this and if it is mgmt task then the flush of the mgmt
    queues will handle that.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index d07017911139..dfaa8adf099e 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1603,8 +1603,11 @@ static void fail_all_commands(struct iscsi_conn *conn, unsigned lun,
 {
 	struct iscsi_task *task, *tmp;
 
-	if (conn-&gt;task &amp;&amp; (conn-&gt;task-&gt;sc-&gt;device-&gt;lun == lun || lun == -1))
-		conn-&gt;task = NULL;
+	if (conn-&gt;task) {
+		if (lun == -1 ||
+		    (conn-&gt;task-&gt;sc &amp;&amp; conn-&gt;task-&gt;sc-&gt;device-&gt;lun == lun))
+			conn-&gt;task = NULL;
+	}
 
 	/* flush pending */
 	list_for_each_entry_safe(task, tmp, &amp;conn-&gt;xmitqueue, running) {</pre><hr><pre>commit 5e7facb77ff4b6961d936773fb1f175f7abf76b7
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Mar 5 14:46:06 2009 -0600

    [SCSI] iscsi class: remove host no argument from session creation callout
    
    We do not need to have llds set the host no for the session's
    parent, because we know the session's parent is going to be
    the host. This removes it from the session creation callback
    and converts the drivers.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 6c61ed12f299..13d7674b293d 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -397,7 +397,7 @@ static void iscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)
 static struct iscsi_cls_session *
 iscsi_iser_session_create(struct iscsi_endpoint *ep,
 			  uint16_t cmds_max, uint16_t qdepth,
-			  uint32_t initial_cmdsn, uint32_t *hostno)
+			  uint32_t initial_cmdsn)
 {
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
@@ -423,7 +423,6 @@ iscsi_iser_session_create(struct iscsi_endpoint *ep,
 	if (iscsi_host_add(shost,
 			   ep ? ib_conn-&gt;device-&gt;ib_device-&gt;dma_device : NULL))
 		goto free_host;
-	*hostno = shost-&gt;host_no;
 
 	/*
 	 * we do not support setting can_queue cmd_per_lun from userspace yet
diff --git a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
index 307f55e329f5..ae4a93090725 100644
--- a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
+++ b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
@@ -334,13 +334,12 @@ static void cxgb3i_ep_disconnect(struct iscsi_endpoint *ep)
  * @cmds_max:		max # of commands
  * @qdepth:		scsi queue depth
  * @initial_cmdsn:	initial iscsi CMDSN for this session
- * @host_no:		pointer to return host no
  *
  * Creates a new iSCSI session
  */
 static struct iscsi_cls_session *
 cxgb3i_session_create(struct iscsi_endpoint *ep, u16 cmds_max, u16 qdepth,
-		      u32 initial_cmdsn, u32 *host_no)
+		      u32 initial_cmdsn)
 {
 	struct cxgb3i_endpoint *cep;
 	struct cxgb3i_hba *hba;
@@ -359,8 +358,6 @@ cxgb3i_session_create(struct iscsi_endpoint *ep, u16 cmds_max, u16 qdepth,
 	cxgb3i_api_debug("ep 0x%p, cep 0x%p, hba 0x%p.\n", ep, cep, hba);
 	BUG_ON(hba != iscsi_host_priv(shost));
 
-	*host_no = shost-&gt;host_no;
-
 	cls_session = iscsi_session_setup(&amp;cxgb3i_iscsi_transport, shost,
 					  cmds_max,
 					  sizeof(struct iscsi_tcp_task) +
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index ad8676c98c68..b3e5e08e44ab 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -765,8 +765,7 @@ iscsi_sw_tcp_conn_get_stats(struct iscsi_cls_conn *cls_conn,
 
 static struct iscsi_cls_session *
 iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
-			    uint16_t qdepth, uint32_t initial_cmdsn,
-			    uint32_t *hostno)
+			    uint16_t qdepth, uint32_t initial_cmdsn)
 {
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
@@ -789,7 +788,6 @@ iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 
 	if (iscsi_host_add(shost, NULL))
 		goto free_host;
-	*hostno = shost-&gt;host_no;
 
 	cls_session = iscsi_session_setup(&amp;iscsi_sw_tcp_transport, shost,
 					  cmds_max,
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 4f22f9e37c5a..2340e2c5c021 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -1197,14 +1197,15 @@ iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_endpoint *ep,
 {
 	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
 	struct iscsi_cls_session *session;
-	uint32_t host_no;
+	struct Scsi_Host *shost;
 
 	session = transport-&gt;create_session(ep, cmds_max, queue_depth,
-					    initial_cmdsn, &amp;host_no);
+					    initial_cmdsn);
 	if (!session)
 		return -ENOMEM;
 
-	ev-&gt;r.c_session_ret.host_no = host_no;
+	shost = iscsi_session_to_shost(session);
+	ev-&gt;r.c_session_ret.host_no = shost-&gt;host_no;
 	ev-&gt;r.c_session_ret.sid = session-&gt;sid;
 	return 0;
 }
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index ac29fbd35544..457588e1119b 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -88,7 +88,7 @@ struct iscsi_transport {
 	uint64_t host_param_mask;
 	struct iscsi_cls_session *(*create_session) (struct iscsi_endpoint *ep,
 					uint16_t cmds_max, uint16_t qdepth,
-					uint32_t sn, uint32_t *hn);
+					uint32_t sn);
 	void (*destroy_session) (struct iscsi_cls_session *session);
 	struct iscsi_cls_conn *(*create_conn) (struct iscsi_cls_session *sess,
 				uint32_t cid);</pre><hr><pre>commit 40a06e755d8524cd0b24f795e8bdce5ad19fc41b
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Mar 5 14:46:05 2009 -0600

    [SCSI] libiscsi: pass session failure a session struct
    
    The api for conn and session failures is akward because
    one takes a conn from the lib and one takes a session
    from the class. This syncs up the interfaces to use
    structs from the lib.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index d12f9794fcd0..d07017911139 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1069,10 +1069,9 @@ struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *conn, itt_t itt)
 }
 EXPORT_SYMBOL_GPL(iscsi_itt_to_ctask);
 
-void iscsi_session_failure(struct iscsi_cls_session *cls_session,
+void iscsi_session_failure(struct iscsi_session *session,
 			   enum iscsi_err err)
 {
-	struct iscsi_session *session = cls_session-&gt;dd_data;
 	struct iscsi_conn *conn;
 	struct device *dev;
 	unsigned long flags;
@@ -2097,7 +2096,7 @@ EXPORT_SYMBOL_GPL(iscsi_host_alloc);
 
 static void iscsi_notify_host_removed(struct iscsi_cls_session *cls_session)
 {
-	iscsi_session_failure(cls_session, ISCSI_ERR_INVALID_HOST);
+	iscsi_session_failure(cls_session-&gt;dd_data, ISCSI_ERR_INVALID_HOST);
 }
 
 /**
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 84eded91b945..7ffaed2f94dd 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -378,7 +378,7 @@ extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
 extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
 			   int);
 extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
-extern void iscsi_session_failure(struct iscsi_cls_session *cls_session,
+extern void iscsi_session_failure(struct iscsi_session *session,
 				  enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);</pre><hr><pre>commit 4d1083509a69a36cc1394f188b7b8956e5526a16
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Mar 5 14:46:04 2009 -0600

    [SCSI] iscsi lib: remove qdepth param from iscsi host allocation
    
    The qdepth setting was useful when we needed libiscsi to verify
    the setting. Now we just need to make sure if older tools
    passed in zero then we need to set some default.
    
    So this patch just has us use the sht-&gt;cmd_per_lun or if
    for LLD does a host per session then we can set it on per
    host basis.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index a50cd53e2753..6c61ed12f299 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -404,7 +404,7 @@ iscsi_iser_session_create(struct iscsi_endpoint *ep,
 	struct Scsi_Host *shost;
 	struct iser_conn *ib_conn;
 
-	shost = iscsi_host_alloc(&amp;iscsi_iser_sht, 0, ISER_DEF_CMD_PER_LUN, 1);
+	shost = iscsi_host_alloc(&amp;iscsi_iser_sht, 0, 1);
 	if (!shost)
 		return NULL;
 	shost-&gt;transportt = iscsi_iser_scsi_transport;
diff --git a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
index f6ed9c62efb0..307f55e329f5 100644
--- a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
+++ b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
@@ -170,8 +170,7 @@ struct cxgb3i_hba *cxgb3i_hba_host_add(struct cxgb3i_adapter *snic,
 	int err;
 
 	shost = iscsi_host_alloc(&amp;cxgb3i_host_template,
-				 sizeof(struct cxgb3i_hba),
-				 CXGB3I_SCSI_QDEPTH_DFLT, 1);
+				 sizeof(struct cxgb3i_hba), 1);
 	if (!shost) {
 		cxgb3i_log_info("iscsi_host_alloc failed.\n");
 		return NULL;
@@ -843,7 +842,7 @@ static struct scsi_host_template cxgb3i_host_template = {
 	.can_queue		= CXGB3I_SCSI_QDEPTH_DFLT - 1,
 	.sg_tablesize		= SG_ALL,
 	.max_sectors		= 0xFFFF,
-	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
+	.cmd_per_lun		= CXGB3I_SCSI_QDEPTH_DFLT,
 	.eh_abort_handler	= iscsi_eh_abort,
 	.eh_device_reset_handler = iscsi_eh_device_reset,
 	.eh_target_reset_handler = iscsi_eh_target_reset,
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 79a706a94c68..ad8676c98c68 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -777,10 +777,11 @@ iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 		return NULL;
 	}
 
-	shost = iscsi_host_alloc(&amp;iscsi_sw_tcp_sht, 0, qdepth, 1);
+	shost = iscsi_host_alloc(&amp;iscsi_sw_tcp_sht, 0, 1);
 	if (!shost)
 		return NULL;
 	shost-&gt;transportt = iscsi_sw_tcp_scsi_transport;
+	shost-&gt;cmd_per_lun = qdepth;
 	shost-&gt;max_lun = iscsi_max_lun;
 	shost-&gt;max_id = 0;
 	shost-&gt;max_channel = 0;
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index ff891543df22..d12f9794fcd0 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -2046,6 +2046,9 @@ int iscsi_host_add(struct Scsi_Host *shost, struct device *pdev)
 	if (!shost-&gt;can_queue)
 		shost-&gt;can_queue = ISCSI_DEF_XMIT_CMDS_MAX;
 
+	if (!shost-&gt;cmd_per_lun)
+		shost-&gt;cmd_per_lun = ISCSI_DEF_CMD_PER_LUN;
+
 	if (!shost-&gt;transportt-&gt;eh_timed_out)
 		shost-&gt;transportt-&gt;eh_timed_out = iscsi_eh_cmd_timed_out;
 	return scsi_add_host(shost, pdev);
@@ -2056,15 +2059,13 @@ EXPORT_SYMBOL_GPL(iscsi_host_add);
  * iscsi_host_alloc - allocate a host and driver data
  * @sht: scsi host template
  * @dd_data_size: driver host data size
- * @qdepth: default device queue depth
  * @xmit_can_sleep: bool indicating if LLD will queue IO from a work queue
  *
  * This should be called by partial offload and software iscsi drivers.
  * To access the driver specific memory use the iscsi_host_priv() macro.
  */
 struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
-				   int dd_data_size, uint16_t qdepth,
-				   bool xmit_can_sleep)
+				   int dd_data_size, bool xmit_can_sleep)
 {
 	struct Scsi_Host *shost;
 	struct iscsi_host *ihost;
@@ -2072,10 +2073,6 @@ struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
 	shost = scsi_host_alloc(sht, sizeof(struct iscsi_host) + dd_data_size);
 	if (!shost)
 		return NULL;
-
-	if (qdepth == 0)
-		qdepth = ISCSI_DEF_CMD_PER_LUN;
-	shost-&gt;cmd_per_lun = qdepth;
 	ihost = shost_priv(shost);
 
 	if (xmit_can_sleep) {
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index b0b8a6992497..84eded91b945 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -346,7 +346,7 @@ extern int iscsi_host_get_param(struct Scsi_Host *shost,
 				enum iscsi_host_param param, char *buf);
 extern int iscsi_host_add(struct Scsi_Host *shost, struct device *pdev);
 extern struct Scsi_Host *iscsi_host_alloc(struct scsi_host_template *sht,
-					  int dd_data_size, uint16_t qdepth,
+					  int dd_data_size,
 					  bool xmit_can_sleep);
 extern void iscsi_host_remove(struct Scsi_Host *shost);
 extern void iscsi_host_free(struct Scsi_Host *shost);</pre>
    <div class="pagination">
        <a href='5_17.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><span>[18]</span><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_19.html'>Next&gt;&gt;</a>
    <div>
</body>
