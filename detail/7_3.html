<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Minnesota</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Minnesota</h1>
    <div class="pagination">
        <a href='7_2.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><span>[3]</span><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_4.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e2dabc4f7e7b60299c20a36d6a7b24ed9bf8e572
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Tue Nov 30 19:08:48 2021 +0800

    net: qlogic: qlcnic: Fix a NULL pointer dereference in qlcnic_83xx_add_rings()
    
    In qlcnic_83xx_add_rings(), the indirect function of
    ahw-&gt;hw_ops-&gt;alloc_mbx_args will be called to allocate memory for
    cmd.req.arg, and there is a dereference of it in qlcnic_83xx_add_rings(),
    which could lead to a NULL pointer dereference on failure of the
    indirect function like qlcnic_83xx_alloc_mbx_args().
    
    Fix this bug by adding a check of alloc_mbx_args(), this patch
    imitates the logic of mbx_cmd()'s failure handling.
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_QLCNIC=m show no new warnings, and our
    static analyzer no longer warns about this code.
    
    Fixes: 7f9664525f9c ("qlcnic: 83xx memory map and HW access routine")
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Link: https://lore.kernel.org/r/20211130110848.109026-1-zhou1615@umn.edu
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index d51bac7ba5af..bd0607680329 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@ -1077,8 +1077,14 @@ static int qlcnic_83xx_add_rings(struct qlcnic_adapter *adapter)
 	sds_mbx_size = sizeof(struct qlcnic_sds_mbx);
 	context_id = recv_ctx-&gt;context_id;
 	num_sds = adapter-&gt;drv_sds_rings - QLCNIC_MAX_SDS_RINGS;
-	ahw-&gt;hw_ops-&gt;alloc_mbx_args(&amp;cmd, adapter,
-				    QLCNIC_CMD_ADD_RCV_RINGS);
+	err = ahw-&gt;hw_ops-&gt;alloc_mbx_args(&amp;cmd, adapter,
+					QLCNIC_CMD_ADD_RCV_RINGS);
+	if (err) {
+		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
+			"Failed to alloc mbx args %d\n", err);
+		return err;
+	}
+
 	cmd.req.arg[1] = 0 | (num_sds &lt;&lt; 8) | (context_id &lt;&lt; 16);
 
 	/* set up status rings, mbx 2-81 */</pre><hr><pre>commit 49a8bf50caa2fb0fb2eb1c89923ea61192227c32
Author: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
Date:   Tue Nov 30 22:15:44 2021 +0800

    drm/i915/gem: Fix a NULL pointer dereference in igt_request_rewind()
    
    In igt_request_rewind(), mock_context(i915, "A") is assigned to ctx[0]
    and used in i915_gem_context_get_engine(). There is a dereference
    of ctx[0] in i915_gem_context_get_engine(), which could lead to a NULL
    pointer dereference on failure of mock_context(i915, "A") .
    
    So as mock_context(i915, "B").
    
    Although this bug is not serious for it belongs to testing code, it is
    better to be fixed to avoid unexpected failure in testing.
    
    Fix this bugs by adding checks about ctx[0] and ctx[1].
    
    This bug was found by a static analyzer. The analysis employs
    differential checking to identify inconsistent security operations
    (e.g., checks or kfrees) between two code paths and confirms that the
    inconsistent operations are not recovered in the current function or
    the callers, so they constitute bugs.
    
    Note that, as a bug found by static analysis, it can be a false
    positive or hard to trigger. Multiple researchers have cross-reviewed
    the bug.
    
    Builds with CONFIG_DRM_I915_SELFTEST=y show no new warnings,
    and our static analyzer no longer warns about this code.
    
    References: 591c0fb85d1c ("drm/i915: Exercise request cancellation using a mock selftest")
    [tursulin: Replaced fixes with references to avoid.]
    Signed-off-by: Zhou Qingyang &lt;zhou1615@umn.edu&gt;
    Reviewed-by: Tvrtko Ursulin &lt;tvrtko.ursulin@intel.com&gt;
    Signed-off-by: Tvrtko Ursulin &lt;tvrtko.ursulin@intel.com&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/20211130141545.153899-1-zhou1615@umn.edu

diff --git a/drivers/gpu/drm/i915/selftests/i915_request.c b/drivers/gpu/drm/i915/selftests/i915_request.c
index 6496671a113c..9979ef9197cd 100644
--- a/drivers/gpu/drm/i915/selftests/i915_request.c
+++ b/drivers/gpu/drm/i915/selftests/i915_request.c
@@ -209,6 +209,10 @@ static int igt_request_rewind(void *arg)
 	int err = -EINVAL;
 
 	ctx[0] = mock_context(i915, "A");
+	if (!ctx[0]) {
+		err = -ENOMEM;
+		goto err_ctx_0;
+	}
 
 	ce = i915_gem_context_get_engine(ctx[0], RCS0);
 	GEM_BUG_ON(IS_ERR(ce));
@@ -223,6 +227,10 @@ static int igt_request_rewind(void *arg)
 	i915_request_add(request);
 
 	ctx[1] = mock_context(i915, "B");
+	if (!ctx[1]) {
+		err = -ENOMEM;
+		goto err_ctx_1;
+	}
 
 	ce = i915_gem_context_get_engine(ctx[1], RCS0);
 	GEM_BUG_ON(IS_ERR(ce));
@@ -261,9 +269,11 @@ static int igt_request_rewind(void *arg)
 	i915_request_put(vip);
 err_context_1:
 	mock_context_close(ctx[1]);
+err_ctx_1:
 	i915_request_put(request);
 err_context_0:
 	mock_context_close(ctx[0]);
+err_ctx_0:
 	mock_device_flush(i915);
 	return err;
 }</pre><hr><pre>commit 0c85a7e87465f2d4cbc768e245f4f45b2f299b05
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Tue Apr 6 19:09:12 2021 -0500

    net/rds: Avoid potential use after free in rds_send_remove_from_sock
    
    In case of rs failure in rds_send_remove_from_sock(), the 'rm' resource
    is freed and later under spinlock, causing potential use-after-free.
    Set the free pointer to NULL to avoid undefined behavior.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Acked-by: Santosh Shilimkar &lt;santosh.shilimkar@oracle.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/rds/message.c b/net/rds/message.c
index 799034e0f513..4fc66ff0f1ec 100644
--- a/net/rds/message.c
+++ b/net/rds/message.c
@@ -180,6 +180,7 @@ void rds_message_put(struct rds_message *rm)
 		rds_message_purge(rm);
 
 		kfree(rm);
+		rm = NULL;
 	}
 }
 EXPORT_SYMBOL_GPL(rds_message_put);
diff --git a/net/rds/send.c b/net/rds/send.c
index 985d0b7713ac..fe5264b9d4b3 100644
--- a/net/rds/send.c
+++ b/net/rds/send.c
@@ -665,7 +665,7 @@ static void rds_send_remove_from_sock(struct list_head *messages, int status)
 unlock_and_drop:
 		spin_unlock_irqrestore(&amp;rm-&gt;m_rs_lock, flags);
 		rds_message_put(rm);
-		if (was_on_sock)
+		if (was_on_sock &amp;&amp; rm)
 			rds_message_put(rm);
 	}
 </pre><hr><pre>commit 57cc666d36adc7b45e37ba4cd7bc4e44ec4c43d7
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Sun Jun 14 05:58:41 2020 +0200

    media: st-delta: Fix reference count leak in delta_run_work
    
    delta_run_work() calls delta_get_sync() that increments
    the reference counter. In case of failure, decrement the reference
    count by calling delta_put_autosuspend().
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/platform/sti/delta/delta-v4l2.c b/drivers/media/platform/sti/delta/delta-v4l2.c
index 2503224eeee5..c691b3d81549 100644
--- a/drivers/media/platform/sti/delta/delta-v4l2.c
+++ b/drivers/media/platform/sti/delta/delta-v4l2.c
@@ -954,8 +954,10 @@ static void delta_run_work(struct work_struct *work)
 	/* enable the hardware */
 	if (!dec-&gt;pm) {
 		ret = delta_get_sync(ctx);
-		if (ret)
+		if (ret) {
+			delta_put_autosuspend(ctx);
 			goto err;
+		}
 	}
 
 	/* decode this access unit */</pre><hr><pre>commit 6f4432bae9f2d12fc1815b5e26cc07e69bcad0df
Author: Qiushi Wu &lt;wu000273@umn.edu&gt;
Date:   Sun Jun 14 05:31:06 2020 +0200

    media: sti: Fix reference count leaks
    
    pm_runtime_get_sync() increments the runtime PM usage counter even
    when it returns an error code, causing incorrect ref count if
    pm_runtime_put_noidle() is not called in error handling paths.
    Thus call pm_runtime_put_noidle() if pm_runtime_get_sync() fails.
    
    Signed-off-by: Qiushi Wu &lt;wu000273@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/platform/sti/hva/hva-hw.c b/drivers/media/platform/sti/hva/hva-hw.c
index 8533d3bc6d5c..43f279e2a6a3 100644
--- a/drivers/media/platform/sti/hva/hva-hw.c
+++ b/drivers/media/platform/sti/hva/hva-hw.c
@@ -272,6 +272,7 @@ static unsigned long int hva_hw_get_ip_version(struct hva_dev *hva)
 
 	if (pm_runtime_get_sync(dev) &lt; 0) {
 		dev_err(dev, "%s     failed to get pm_runtime\n", HVA_PREFIX);
+		pm_runtime_put_noidle(dev);
 		mutex_unlock(&amp;hva-&gt;protect_mutex);
 		return -EFAULT;
 	}
@@ -553,6 +554,7 @@ void hva_hw_dump_regs(struct hva_dev *hva, struct seq_file *s)
 
 	if (pm_runtime_get_sync(dev) &lt; 0) {
 		seq_puts(s, "Cannot wake up IP\n");
+		pm_runtime_put_noidle(dev);
 		mutex_unlock(&amp;hva-&gt;protect_mutex);
 		return;
 	}</pre><hr><pre>commit 7ef64ceea0008c17e94a8a2c60c5d6d46f481996
Author: Qiushi Wu &lt;wu000273@umn.edu&gt;
Date:   Sun Jun 14 05:18:29 2020 +0200

    media: exynos4-is: Fix several reference count leaks due to pm_runtime_get_sync
    
    On calling pm_runtime_get_sync() the reference count of the device
    is incremented. In case of failure, decrement the
    reference count before returning the error.
    
    Signed-off-by: Qiushi Wu &lt;wu000273@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/platform/exynos4-is/fimc-isp.c b/drivers/media/platform/exynos4-is/fimc-isp.c
index cde0d254ec1c..a77c49b18511 100644
--- a/drivers/media/platform/exynos4-is/fimc-isp.c
+++ b/drivers/media/platform/exynos4-is/fimc-isp.c
@@ -305,8 +305,10 @@ static int fimc_isp_subdev_s_power(struct v4l2_subdev *sd, int on)
 
 	if (on) {
 		ret = pm_runtime_get_sync(&amp;is-&gt;pdev-&gt;dev);
-		if (ret &lt; 0)
+		if (ret &lt; 0) {
+			pm_runtime_put(&amp;is-&gt;pdev-&gt;dev);
 			return ret;
+		}
 		set_bit(IS_ST_PWR_ON, &amp;is-&gt;state);
 
 		ret = fimc_is_start_firmware(is);
diff --git a/drivers/media/platform/exynos4-is/fimc-lite.c b/drivers/media/platform/exynos4-is/fimc-lite.c
index 9c666f663ab4..fdd0d369b192 100644
--- a/drivers/media/platform/exynos4-is/fimc-lite.c
+++ b/drivers/media/platform/exynos4-is/fimc-lite.c
@@ -471,7 +471,7 @@ static int fimc_lite_open(struct file *file)
 	set_bit(ST_FLITE_IN_USE, &amp;fimc-&gt;state);
 	ret = pm_runtime_get_sync(&amp;fimc-&gt;pdev-&gt;dev);
 	if (ret &lt; 0)
-		goto unlock;
+		goto err_pm;
 
 	ret = v4l2_fh_open(file);
 	if (ret &lt; 0)</pre><hr><pre>commit c47f7c779ef0458a58583f00c9ed71b7f5a4d0a2
Author: Qiushi Wu &lt;wu000273@umn.edu&gt;
Date:   Sun Jun 14 05:10:58 2020 +0200

    media: exynos4-is: Fix a reference count leak due to pm_runtime_get_sync
    
    On calling pm_runtime_get_sync() the reference count of the device
    is incremented. In case of failure, decrement the
    reference count before returning the error.
    
    Signed-off-by: Qiushi Wu &lt;wu000273@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/platform/exynos4-is/media-dev.c b/drivers/media/platform/exynos4-is/media-dev.c
index 7d92793a8e74..e636c33e847b 100644
--- a/drivers/media/platform/exynos4-is/media-dev.c
+++ b/drivers/media/platform/exynos4-is/media-dev.c
@@ -509,8 +509,10 @@ static int fimc_md_register_sensor_entities(struct fimc_md *fmd)
 		return -ENXIO;
 
 	ret = pm_runtime_get_sync(fmd-&gt;pmf);
-	if (ret &lt; 0)
+	if (ret &lt; 0) {
+		pm_runtime_put(fmd-&gt;pmf);
 		return ret;
+	}
 
 	fmd-&gt;num_sensors = 0;
 </pre><hr><pre>commit 64157b2cb1940449e7df2670e85781c690266588
Author: Qiushi Wu &lt;wu000273@umn.edu&gt;
Date:   Sun Jun 14 05:01:11 2020 +0200

    media: exynos4-is: Fix a reference count leak
    
    pm_runtime_get_sync() increments the runtime PM usage counter even
    when it returns an error code, causing incorrect ref count if
    pm_runtime_put_noidle() is not called in error handling paths.
    Thus call pm_runtime_put_noidle() if pm_runtime_get_sync() fails.
    
    Signed-off-by: Qiushi Wu &lt;wu000273@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/platform/exynos4-is/mipi-csis.c b/drivers/media/platform/exynos4-is/mipi-csis.c
index 540151bbf58f..1aac167abb17 100644
--- a/drivers/media/platform/exynos4-is/mipi-csis.c
+++ b/drivers/media/platform/exynos4-is/mipi-csis.c
@@ -510,8 +510,10 @@ static int s5pcsis_s_stream(struct v4l2_subdev *sd, int enable)
 	if (enable) {
 		s5pcsis_clear_counters(state);
 		ret = pm_runtime_get_sync(&amp;state-&gt;pdev-&gt;dev);
-		if (ret &amp;&amp; ret != 1)
+		if (ret &amp;&amp; ret != 1) {
+			pm_runtime_put_noidle(&amp;state-&gt;pdev-&gt;dev);
 			return ret;
+		}
 	}
 
 	mutex_lock(&amp;state-&gt;lock);</pre><hr><pre>commit 7dae2aaaf432767ca7aa11fa84643a7c2600dbdd
Author: Qiushi Wu &lt;wu000273@umn.edu&gt;
Date:   Sun Jun 14 04:56:05 2020 +0200

    media: ti-vpe: Fix a missing check and reference count leak
    
    pm_runtime_get_sync() increments the runtime PM usage counter even
    when it returns an error code, causing incorrect ref count if
    pm_runtime_put_noidle() is not called in error handling paths.
    And also, when the call of function vpe_runtime_get() failed,
    we won't call vpe_runtime_put().
    Thus call pm_runtime_put_noidle() if pm_runtime_get_sync() fails
    inside vpe_runtime_get().
    
    Fixes: 4571912743ac ("[media] v4l: ti-vpe: Add VPE mem to mem driver")
    Signed-off-by: Qiushi Wu &lt;wu000273@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/platform/ti-vpe/vpe.c b/drivers/media/platform/ti-vpe/vpe.c
index 346f8212791c..779dd74b82d0 100644
--- a/drivers/media/platform/ti-vpe/vpe.c
+++ b/drivers/media/platform/ti-vpe/vpe.c
@@ -2475,6 +2475,8 @@ static int vpe_runtime_get(struct platform_device *pdev)
 
 	r = pm_runtime_get_sync(&amp;pdev-&gt;dev);
 	WARN_ON(r &lt; 0);
+	if (r)
+		pm_runtime_put_noidle(&amp;pdev-&gt;dev);
 	return r &lt; 0 ? r : 0;
 }
 </pre><hr><pre>commit 88f50a05f907d96a27a9ce3cc9e8cbb91a6f0f22
Author: Qiushi Wu &lt;wu000273@umn.edu&gt;
Date:   Sun Jun 14 04:36:59 2020 +0200

    media: stm32-dcmi: Fix a reference count leak
    
    Calling pm_runtime_get_sync increments the counter even in case of
    failure, causing incorrect ref count if pm_runtime_put is not
    called in error handling paths. Thus replace the jump target
    "err_release_buffers" by "err_pm_putw".
    
    Fixes: 152e0bf60219 ("media: stm32-dcmi: add power saving support")
    Signed-off-by: Qiushi Wu &lt;wu000273@umn.edu&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/media/platform/stm32/stm32-dcmi.c b/drivers/media/platform/stm32/stm32-dcmi.c
index b8931490b83b..fd1c41cba52f 100644
--- a/drivers/media/platform/stm32/stm32-dcmi.c
+++ b/drivers/media/platform/stm32/stm32-dcmi.c
@@ -733,7 +733,7 @@ static int dcmi_start_streaming(struct vb2_queue *vq, unsigned int count)
 	if (ret &lt; 0) {
 		dev_err(dcmi-&gt;dev, "%s: Failed to start streaming, cannot get sync (%d)\n",
 			__func__, ret);
-		goto err_release_buffers;
+		goto err_pm_put;
 	}
 
 	ret = media_pipeline_start(&amp;dcmi-&gt;vdev-&gt;entity, &amp;dcmi-&gt;pipeline);
@@ -837,8 +837,6 @@ static int dcmi_start_streaming(struct vb2_queue *vq, unsigned int count)
 
 err_pm_put:
 	pm_runtime_put(dcmi-&gt;dev);
-
-err_release_buffers:
 	spin_lock_irq(&amp;dcmi-&gt;irqlock);
 	/*
 	 * Return all buffers to vb2 in QUEUED state.</pre>
    <div class="pagination">
        <a href='7_2.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><span>[3]</span><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_4.html'>Next&gt;&gt;</a>
    <div>
</body>
