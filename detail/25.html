<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Pennsylvania</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Pennsylvania</h1>
    <div class="pagination">
        <span>[1]</span><a href='25_2.html'>2</a><a href='25_3.html'>3</a><a href='25_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 9824ae4aff2793947ea78c4c8147bb6c59efdcba
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Sun Jul 3 17:13:53 2011 -0300

    [media] mceusb: increase default timeout to 100ms
    
    This matches the typical timeout advertised by hardware, once we're
    actually interpreting it correctly.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jarod Wilson &lt;jarod@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c
index b928a61736d7..ec972dc25790 100644
--- a/drivers/media/rc/mceusb.c
+++ b/drivers/media/rc/mceusb.c
@@ -1079,7 +1079,7 @@ static struct rc_dev *mceusb_init_rc_dev(struct mceusb_dev *ir)
 	rc-&gt;priv = ir;
 	rc-&gt;driver_type = RC_DRIVER_IR_RAW;
 	rc-&gt;allowed_protos = RC_TYPE_ALL;
-	rc-&gt;timeout = US_TO_NS(1000);
+	rc-&gt;timeout = MS_TO_NS(100);
 	if (!ir-&gt;flags.no_tx) {
 		rc-&gt;s_tx_mask = mceusb_set_tx_mask;
 		rc-&gt;s_tx_carrier = mceusb_set_tx_carrier;</pre><hr><pre>commit f3e456cb899304bed183247ed3228f7ff855eebd
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Sun Jul 3 17:13:52 2011 -0300

    [media] mceusb: Timeout unit corrections
    
    Unit missmatch in mceusb_handle_command.  It should be converting to us,
    not 1/10th of ms.
    
    mceusb_dev_printdata 100us/ms -&gt; 1000us/ms
    
    Alter format of fix slightly and update comment to match proper reality.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jarod Wilson &lt;jarod@redhat.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@redhat.com&gt;

diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c
index 06dfe0957b5e..b928a61736d7 100644
--- a/drivers/media/rc/mceusb.c
+++ b/drivers/media/rc/mceusb.c
@@ -558,9 +558,10 @@ static void mceusb_dev_printdata(struct mceusb_dev *ir, char *buf,
 				 inout, data1);
 			break;
 		case MCE_CMD_S_TIMEOUT:
-			/* value is in units of 50us, so x*50/100 or x/2 ms */
+			/* value is in units of 50us, so x*50/1000 ms */
 			dev_info(dev, "%s receive timeout of %d ms\n",
-				 inout, ((data1 &lt;&lt; 8) | data2) / 2);
+				 inout,
+				 ((data1 &lt;&lt; 8) | data2) * MCE_TIME_UNIT / 1000);
 			break;
 		case MCE_CMD_G_TIMEOUT:
 			dev_info(dev, "Get receive timeout\n");
@@ -847,7 +848,7 @@ static void mceusb_handle_command(struct mceusb_dev *ir, int index)
 	switch (ir-&gt;buf_in[index]) {
 	/* 2-byte return value commands */
 	case MCE_CMD_S_TIMEOUT:
-		ir-&gt;rc-&gt;timeout = US_TO_NS((hi &lt;&lt; 8 | lo) / 2);
+		ir-&gt;rc-&gt;timeout = US_TO_NS((hi &lt;&lt; 8 | lo) * MCE_TIME_UNIT);
 		break;
 
 	/* 1-byte return value commands */</pre><hr><pre>commit cffbcd0c23bf17c411b35d13fceb25bd5ec9afea
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Sun May 15 23:33:23 2011 -0400

    Kconfig: fix copy/paste-ism for dell-wmi-aio driver
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 0485e394712a..485c09eef424 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -111,7 +111,7 @@ config DELL_WMI_AIO
 	  All-In-One machines.
 
 	  To compile this driver as a module, choose M here: the module will
-	  be called dell-wmi.
+	  be called dell-wmi-aio.
 
 
 config FUJITSU_LAPTOP</pre><hr><pre>commit 7b2a64c96ad53c4299f7e6ddf8c2f99cb48940a9
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Wed Mar 9 23:33:52 2011 -0500

    HID: hid-ntrig: init settle and mode check
    
    Adding a wait before the wakeup signal.
    
    As a precautionary measure sanity check the current sensor mode.  If
    needed reset it to "dual".
    
    When the device is responding poorly and needs the wakeup call, it was
    missing it.  Giving it a chance to settle first improves the chances
    that signal gets through.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Tested-by: Peter Hutterer &lt;peter.hutterer@who-t.net&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index dffffa763bd7..9fae2ebdd758 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -110,6 +110,36 @@ static int ntrig_version_string(unsigned char *raw, char *buf)
 	return sprintf(buf, "%u.%u.%u.%u.%u", a, b, c, d, e);
 }
 
+static inline int ntrig_get_mode(struct hid_device *hdev)
+{
+	struct hid_report *report = hdev-&gt;report_enum[HID_FEATURE_REPORT].
+				    report_id_hash[0x0d];
+
+	if (!report)
+		return -EINVAL;
+
+	usbhid_submit_report(hdev, report, USB_DIR_IN);
+	usbhid_wait_io(hdev);
+	return (int)report-&gt;field[0]-&gt;value[0];
+}
+
+static inline void ntrig_set_mode(struct hid_device *hdev, const int mode)
+{
+	struct hid_report *report;
+	__u8 mode_commands[4] = { 0xe, 0xf, 0x1b, 0x10 };
+
+	if (mode &lt; 0 || mode &gt; 3)
+		return;
+
+	report = hdev-&gt;report_enum[HID_FEATURE_REPORT].
+		 report_id_hash[mode_commands[mode]];
+
+	if (!report)
+		return;
+
+	usbhid_submit_report(hdev, report, USB_DIR_IN);
+}
+
 static void ntrig_report_version(struct hid_device *hdev)
 {
 	int ret;
@@ -905,8 +935,19 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 
 	/* This is needed for devices with more recent firmware versions */
 	report = hdev-&gt;report_enum[HID_FEATURE_REPORT].report_id_hash[0x0a];
-	if (report)
-		usbhid_submit_report(hdev, report, USB_DIR_OUT);
+	if (report) {
+		/* Let the device settle to ensure the wakeup message gets
+		 * through */
+		usbhid_wait_io(hdev);
+		usbhid_submit_report(hdev, report, USB_DIR_IN);
+
+		/*
+		 * Sanity check: if the current mode is invalid reset it to
+		 * something reasonable.
+		 */
+		if (ntrig_get_mode(hdev) &gt;= 4)
+			ntrig_set_mode(hdev, 3);
+	}
 
 	ntrig_report_version(hdev);
 </pre><hr><pre>commit ff4046294ba215abeaf45c10ab6cbfae41978b14
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Mon Mar 7 21:13:28 2011 -0500

    HID: ntrig remove if and drop an indent
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Tested-by: Peter Hutterer &lt;peter.hutterer@who-t.net&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index f152b5114f05..dffffa763bd7 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -557,268 +557,266 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 	if (field-&gt;application == HID_DG_PEN)
 		return 0;
 
-        if (hid-&gt;claimed &amp; HID_CLAIMED_INPUT) {
-		switch (usage-&gt;hid) {
-		case 0xff000001:
-			/* Tag indicating the start of a multitouch group */
-			nd-&gt;reading_mt = 1;
-			nd-&gt;first_contact_touch = 0;
-			break;
-		case HID_DG_TIPSWITCH:
-			nd-&gt;tipswitch = value;
-			/* Prevent emission of touch until validated */
-			return 1;
-		case HID_DG_CONFIDENCE:
-			nd-&gt;confidence = value;
-			break;
-		case HID_GD_X:
-			nd-&gt;x = value;
-			/* Clear the contact footer */
-			nd-&gt;mt_foot_count = 0;
-			break;
-		case HID_GD_Y:
-			nd-&gt;y = value;
-			break;
-		case HID_DG_CONTACTID:
-			nd-&gt;id = value;
-			break;
-		case HID_DG_WIDTH:
-			nd-&gt;w = value;
-			break;
-		case HID_DG_HEIGHT:
-			nd-&gt;h = value;
+	switch (usage-&gt;hid) {
+	case 0xff000001:
+		/* Tag indicating the start of a multitouch group */
+		nd-&gt;reading_mt = 1;
+		nd-&gt;first_contact_touch = 0;
+		break;
+	case HID_DG_TIPSWITCH:
+		nd-&gt;tipswitch = value;
+		/* Prevent emission of touch until validated */
+		return 1;
+	case HID_DG_CONFIDENCE:
+		nd-&gt;confidence = value;
+		break;
+	case HID_GD_X:
+		nd-&gt;x = value;
+		/* Clear the contact footer */
+		nd-&gt;mt_foot_count = 0;
+		break;
+	case HID_GD_Y:
+		nd-&gt;y = value;
+		break;
+	case HID_DG_CONTACTID:
+		nd-&gt;id = value;
+		break;
+	case HID_DG_WIDTH:
+		nd-&gt;w = value;
+		break;
+	case HID_DG_HEIGHT:
+		nd-&gt;h = value;
+		/*
+		 * when in single touch mode, this is the last
+		 * report received in a finger event. We want
+		 * to emit a normal (X, Y) position
+		 */
+		if (!nd-&gt;reading_mt) {
 			/*
-			 * when in single touch mode, this is the last
-			 * report received in a finger event. We want
-			 * to emit a normal (X, Y) position
+			 * TipSwitch indicates the presence of a
+			 * finger in single touch mode.
 			 */
-			if (!nd-&gt;reading_mt) {
-				/*
-				 * TipSwitch indicates the presence of a
-				 * finger in single touch mode.
-				 */
-				input_report_key(input, BTN_TOUCH,
-						 nd-&gt;tipswitch);
-				input_report_key(input, BTN_TOOL_DOUBLETAP,
-						 nd-&gt;tipswitch);
-				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
-				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
-			}
+			input_report_key(input, BTN_TOUCH,
+					 nd-&gt;tipswitch);
+			input_report_key(input, BTN_TOOL_DOUBLETAP,
+					 nd-&gt;tipswitch);
+			input_event(input, EV_ABS, ABS_X, nd-&gt;x);
+			input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
+		}
+		break;
+	case 0xff000002:
+		/*
+		 * we receive this when the device is in multitouch
+		 * mode. The first of the three values tagged with
+		 * this usage tells if the contact point is real
+		 * or a placeholder
+		 */
+
+		/* Shouldn't get more than 4 footer packets, so skip */
+		if (nd-&gt;mt_foot_count &gt;= 4)
 			break;
-		case 0xff000002:
-			/*
-			 * we receive this when the device is in multitouch
-			 * mode. The first of the three values tagged with
-			 * this usage tells if the contact point is real
-			 * or a placeholder
-			 */
 
-			/* Shouldn't get more than 4 footer packets, so skip */
-			if (nd-&gt;mt_foot_count &gt;= 4)
-				break;
+		nd-&gt;mt_footer[nd-&gt;mt_foot_count++] = value;
 
-			nd-&gt;mt_footer[nd-&gt;mt_foot_count++] = value;
+		/* if the footer isn't complete break */
+		if (nd-&gt;mt_foot_count != 4)
+			break;
 
-			/* if the footer isn't complete break */
-			if (nd-&gt;mt_foot_count != 4)
-				break;
+		/* Pen activity signal. */
+		if (nd-&gt;mt_footer[2]) {
+			/*
+			 * When the pen deactivates touch, we see a
+			 * bogus frame with ContactCount &gt; 0.
+			 * We can
+			 * save a bit of work by ensuring act_state &lt; 0
+			 * even if deactivation slack is turned off.
+			 */
+			nd-&gt;act_state = deactivate_slack - 1;
+			nd-&gt;confidence = 0;
+			break;
+		}
 
-			/* Pen activity signal. */
-			if (nd-&gt;mt_footer[2]) {
-				/*
-				 * When the pen deactivates touch, we see a
-				 * bogus frame with ContactCount &gt; 0.
-				 * We can
-				 * save a bit of work by ensuring act_state &lt; 0
-				 * even if deactivation slack is turned off.
-				 */
-				nd-&gt;act_state = deactivate_slack - 1;
+		/*
+		 * The first footer value indicates the presence of a
+		 * finger.
+		 */
+		if (nd-&gt;mt_footer[0]) {
+			/*
+			 * We do not want to process contacts under
+			 * the size threshold, but do not want to
+			 * ignore them for activation state
+			 */
+			if (nd-&gt;w &lt; nd-&gt;min_width ||
+			    nd-&gt;h &lt; nd-&gt;min_height)
 				nd-&gt;confidence = 0;
-				break;
-			}
+		} else
+			break;
 
+		if (nd-&gt;act_state &gt; 0) {
 			/*
-			 * The first footer value indicates the presence of a
-			 * finger.
+			 * Contact meets the activation size threshold
 			 */
-			if (nd-&gt;mt_footer[0]) {
-				/*
-				 * We do not want to process contacts under
-				 * the size threshold, but do not want to
-				 * ignore them for activation state
-				 */
-				if (nd-&gt;w &lt; nd-&gt;min_width ||
-				    nd-&gt;h &lt; nd-&gt;min_height)
-					nd-&gt;confidence = 0;
-			} else
-				break;
-
-			if (nd-&gt;act_state &gt; 0) {
-				/*
-				 * Contact meets the activation size threshold
-				 */
-				if (nd-&gt;w &gt;= nd-&gt;activation_width &amp;&amp;
-				    nd-&gt;h &gt;= nd-&gt;activation_height) {
-					if (nd-&gt;id)
-						/*
-						 * first contact, activate now
-						 */
-						nd-&gt;act_state = 0;
-					else {
-						/*
-						 * avoid corrupting this frame
-						 * but ensure next frame will
-						 * be active
-						 */
-						nd-&gt;act_state = 1;
-						break;
-					}
-				} else
+			if (nd-&gt;w &gt;= nd-&gt;activation_width &amp;&amp;
+			    nd-&gt;h &gt;= nd-&gt;activation_height) {
+				if (nd-&gt;id)
 					/*
-					 * Defer adjusting the activation state
-					 * until the end of the frame.
+					 * first contact, activate now
 					 */
+					nd-&gt;act_state = 0;
+				else {
+					/*
+					 * avoid corrupting this frame
+					 * but ensure next frame will
+					 * be active
+					 */
+					nd-&gt;act_state = 1;
 					break;
-			}
-
-			/* Discarding this contact */
-			if (!nd-&gt;confidence)
-				break;
-
-			/* emit a normal (X, Y) for the first point only */
-			if (nd-&gt;id == 0) {
+				}
+			} else
 				/*
-				 * TipSwitch is superfluous in multitouch
-				 * mode.  The footer events tell us
-				 * if there is a finger on the screen or
-				 * not.
+				 * Defer adjusting the activation state
+				 * until the end of the frame.
 				 */
-				nd-&gt;first_contact_touch = nd-&gt;confidence;
-				input_event(input, EV_ABS, ABS_X, nd-&gt;x);
-				input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
-			}
+				break;
+		}
 
-			/* Emit MT events */
-			input_event(input, EV_ABS, ABS_MT_POSITION_X, nd-&gt;x);
-			input_event(input, EV_ABS, ABS_MT_POSITION_Y, nd-&gt;y);
+		/* Discarding this contact */
+		if (!nd-&gt;confidence)
+			break;
 
+		/* emit a normal (X, Y) for the first point only */
+		if (nd-&gt;id == 0) {
 			/*
-			 * Translate from height and width to size
-			 * and orientation.
+			 * TipSwitch is superfluous in multitouch
+			 * mode.  The footer events tell us
+			 * if there is a finger on the screen or
+			 * not.
 			 */
-			if (nd-&gt;w &gt; nd-&gt;h) {
-				input_event(input, EV_ABS,
-						ABS_MT_ORIENTATION, 1);
-				input_event(input, EV_ABS,
-						ABS_MT_TOUCH_MAJOR, nd-&gt;w);
-				input_event(input, EV_ABS,
-						ABS_MT_TOUCH_MINOR, nd-&gt;h);
-			} else {
-				input_event(input, EV_ABS,
-						ABS_MT_ORIENTATION, 0);
-				input_event(input, EV_ABS,
-						ABS_MT_TOUCH_MAJOR, nd-&gt;h);
-				input_event(input, EV_ABS,
-						ABS_MT_TOUCH_MINOR, nd-&gt;w);
-			}
-			input_mt_sync(field-&gt;hidinput-&gt;input);
-			break;
+			nd-&gt;first_contact_touch = nd-&gt;confidence;
+			input_event(input, EV_ABS, ABS_X, nd-&gt;x);
+			input_event(input, EV_ABS, ABS_Y, nd-&gt;y);
+		}
 
-		case HID_DG_CONTACTCOUNT: /* End of a multitouch group */
-			if (!nd-&gt;reading_mt) /* Just to be sure */
-				break;
+		/* Emit MT events */
+		input_event(input, EV_ABS, ABS_MT_POSITION_X, nd-&gt;x);
+		input_event(input, EV_ABS, ABS_MT_POSITION_Y, nd-&gt;y);
+
+		/*
+		 * Translate from height and width to size
+		 * and orientation.
+		 */
+		if (nd-&gt;w &gt; nd-&gt;h) {
+			input_event(input, EV_ABS,
+					ABS_MT_ORIENTATION, 1);
+			input_event(input, EV_ABS,
+					ABS_MT_TOUCH_MAJOR, nd-&gt;w);
+			input_event(input, EV_ABS,
+					ABS_MT_TOUCH_MINOR, nd-&gt;h);
+		} else {
+			input_event(input, EV_ABS,
+					ABS_MT_ORIENTATION, 0);
+			input_event(input, EV_ABS,
+					ABS_MT_TOUCH_MAJOR, nd-&gt;h);
+			input_event(input, EV_ABS,
+					ABS_MT_TOUCH_MINOR, nd-&gt;w);
+		}
+		input_mt_sync(field-&gt;hidinput-&gt;input);
+		break;
 
-			nd-&gt;reading_mt = 0;
+	case HID_DG_CONTACTCOUNT: /* End of a multitouch group */
+		if (!nd-&gt;reading_mt) /* Just to be sure */
+			break;
 
+		nd-&gt;reading_mt = 0;
+
+
+		/*
+		 * Activation state machine logic:
+		 *
+		 * Fundamental states:
+		 *	state &gt;  0: Inactive
+		 *	state &lt;= 0: Active
+		 *	state &lt;  -deactivate_slack:
+		 *		 Pen termination of touch
+		 *
+		 * Specific values of interest
+		 *	state == activate_slack
+		 *		 no valid input since the last reset
+		 *
+		 *	state == 0
+		 *		 general operational state
+		 *
+		 *	state == -deactivate_slack
+		 *		 read sufficient empty frames to accept
+		 *		 the end of input and reset
+		 */
+
+		if (nd-&gt;act_state &gt; 0) { /* Currently inactive */
+			if (value)
+				/*
+				 * Consider each live contact as
+				 * evidence of intentional activity.
+				 */
+				nd-&gt;act_state = (nd-&gt;act_state &gt; value)
+						? nd-&gt;act_state - value
+						: 0;
+			else
+				/*
+				 * Empty frame before we hit the
+				 * activity threshold, reset.
+				 */
+				nd-&gt;act_state = nd-&gt;activate_slack;
 
 			/*
-			 * Activation state machine logic:
-			 *
-			 * Fundamental states:
-			 *	state &gt;  0: Inactive
-			 *	state &lt;= 0: Active
-			 *	state &lt;  -deactivate_slack:
-			 *		 Pen termination of touch
-			 *
-			 * Specific values of interest
-			 *	state == activate_slack
-			 *		 no valid input since the last reset
-			 *
-			 *	state == 0
-			 *		 general operational state
-			 *
-			 *	state == -deactivate_slack
-			 *		 read sufficient empty frames to accept
-			 *		 the end of input and reset
+			 * Entered this block inactive and no
+			 * coordinates sent this frame, so hold off
+			 * on button state.
 			 */
-
-			if (nd-&gt;act_state &gt; 0) { /* Currently inactive */
-				if (value)
-					/*
-					 * Consider each live contact as
-					 * evidence of intentional activity.
-					 */
-					nd-&gt;act_state = (nd-&gt;act_state &gt; value)
-							? nd-&gt;act_state - value
-							: 0;
-				else
-					/*
-					 * Empty frame before we hit the
-					 * activity threshold, reset.
-					 */
-					nd-&gt;act_state = nd-&gt;activate_slack;
-
+			break;
+		} else { /* Currently active */
+			if (value &amp;&amp; nd-&gt;act_state &gt;=
+				     nd-&gt;deactivate_slack)
 				/*
-				 * Entered this block inactive and no
-				 * coordinates sent this frame, so hold off
-				 * on button state.
+				 * Live point: clear accumulated
+				 * deactivation count.
 				 */
-				break;
-			} else { /* Currently active */
-				if (value &amp;&amp; nd-&gt;act_state &gt;=
-					     nd-&gt;deactivate_slack)
-					/*
-					 * Live point: clear accumulated
-					 * deactivation count.
-					 */
-					nd-&gt;act_state = 0;
-				else if (nd-&gt;act_state &lt;= nd-&gt;deactivate_slack)
-					/*
-					 * We've consumed the deactivation
-					 * slack, time to deactivate and reset.
-					 */
-					nd-&gt;act_state =
-						nd-&gt;activate_slack;
-				else { /* Move towards deactivation */
-					nd-&gt;act_state--;
-					break;
-				}
-			}
-
-			if (nd-&gt;first_contact_touch &amp;&amp; nd-&gt;act_state &lt;= 0) {
+				nd-&gt;act_state = 0;
+			else if (nd-&gt;act_state &lt;= nd-&gt;deactivate_slack)
 				/*
-				 * Check to see if we're ready to start
-				 * emitting touch events.
-				 *
-				 * Note: activation slack will decrease over
-				 * the course of the frame, and it will be
-				 * inconsistent from the start to the end of
-				 * the frame.  However if the frame starts
-				 * with slack, first_contact_touch will still
-				 * be 0 and we will not get to this point.
+				 * We've consumed the deactivation
+				 * slack, time to deactivate and reset.
 				 */
-				input_report_key(input, BTN_TOOL_DOUBLETAP, 1);
-				input_report_key(input, BTN_TOUCH, 1);
-			} else {
-				input_report_key(input, BTN_TOOL_DOUBLETAP, 0);
-				input_report_key(input, BTN_TOUCH, 0);
+				nd-&gt;act_state =
+					nd-&gt;activate_slack;
+			else { /* Move towards deactivation */
+				nd-&gt;act_state--;
+				break;
 			}
-			break;
+		}
 
-		default:
-			/* fall-back to the generic hidinput handling */
-			return 0;
+		if (nd-&gt;first_contact_touch &amp;&amp; nd-&gt;act_state &lt;= 0) {
+			/*
+			 * Check to see if we're ready to start
+			 * emitting touch events.
+			 *
+			 * Note: activation slack will decrease over
+			 * the course of the frame, and it will be
+			 * inconsistent from the start to the end of
+			 * the frame.  However if the frame starts
+			 * with slack, first_contact_touch will still
+			 * be 0 and we will not get to this point.
+			 */
+			input_report_key(input, BTN_TOOL_DOUBLETAP, 1);
+			input_report_key(input, BTN_TOUCH, 1);
+		} else {
+			input_report_key(input, BTN_TOOL_DOUBLETAP, 0);
+			input_report_key(input, BTN_TOUCH, 0);
 		}
+		break;
+
+	default:
+		/* fall-back to the generic hidinput handling */
+		return 0;
 	}
 
 not_claimed_input:</pre><hr><pre>commit 6638dedaec6e3d32654f0ac5786f5d32963e208b
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Wed Mar 9 23:33:51 2011 -0500

    HID: ntrig: apply NO_INIT_REPORTS quirk
    
    Probing reports does bad things with some ntrig firmwares, better to
    just leave them alone.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index a93e58ca81ed..f152b5114f05 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -839,7 +839,8 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	struct hid_report *report;
 
 	if (id-&gt;driver_data)
-		hdev-&gt;quirks |= HID_QUIRK_MULTI_INPUT;
+		hdev-&gt;quirks |= HID_QUIRK_MULTI_INPUT
+				| HID_QUIRK_NO_INIT_REPORTS;
 
 	nd = kmalloc(sizeof(struct ntrig_data), GFP_KERNEL);
 	if (!nd) {</pre><hr><pre>commit f41a52d3010579949a3b9fd76783120d9643b60b
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Tue Mar 8 00:24:29 2011 -0500

    HID: ntrig don't dereference unclaimed hidinput
    
    Check before dereferencing field-&gt;hidinput to fix a reported invalid
    deference bug.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index beb403421e72..a93e58ca81ed 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -539,8 +539,19 @@ static int ntrig_input_mapped(struct hid_device *hdev, struct hid_input *hi,
 static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 			struct hid_usage *usage, __s32 value)
 {
-	struct input_dev *input = field-&gt;hidinput-&gt;input;
 	struct ntrig_data *nd = hid_get_drvdata(hid);
+	struct input_dev *input;
+
+	/* Skip processing if not a claimed input */
+	if (!(hid-&gt;claimed &amp; HID_CLAIMED_INPUT))
+		goto not_claimed_input;
+
+	/* This function is being called before the structures are fully
+	 * initialized */
+	if(!(field-&gt;hidinput &amp;&amp; field-&gt;hidinput-&gt;input))
+		return -EINVAL;
+
+	input = field-&gt;hidinput-&gt;input;
 
 	/* No special handling needed for the pen */
 	if (field-&gt;application == HID_DG_PEN)
@@ -810,6 +821,8 @@ static int ntrig_event (struct hid_device *hid, struct hid_field *field,
 		}
 	}
 
+not_claimed_input:
+
 	/* we have handled the hidinput part, now remains hiddev */
 	if ((hid-&gt;claimed &amp; HID_CLAIMED_HIDDEV) &amp;&amp; hid-&gt;hiddev_hid_event)
 		hid-&gt;hiddev_hid_event(hid, field, usage, value);</pre><hr><pre>commit 0277873c05158c5efc97c23d52e6aec6250bde0f
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Wed Sep 8 11:46:14 2010 +0200

    HID: ntrig: identify firmware version
    
    This adds firmware version polling to the end of probe and reports the
    version both in the raw form and proccessed to match the formatting used
    by N-Trig.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Acked-by: Dmitry Torokhov &lt;dmitry.torokhov@gmail.com&gt;
    Acked-by: Jiri Slaby &lt;jslaby@suse.cz&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index 43e95dee9290..69169efa1e16 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -90,6 +90,55 @@ struct ntrig_data {
 };
 
 
+/*
+ * This function converts the 4 byte raw firmware code into
+ * a string containing 5 comma separated numbers.
+ */
+static int ntrig_version_string(unsigned char *raw, char *buf)
+{
+	__u8 a =  (raw[1] &amp; 0x0e) &gt;&gt; 1;
+	__u8 b =  (raw[0] &amp; 0x3c) &gt;&gt; 2;
+	__u8 c = ((raw[0] &amp; 0x03) &lt;&lt; 3) | ((raw[3] &amp; 0xe0) &gt;&gt; 5);
+	__u8 d = ((raw[3] &amp; 0x07) &lt;&lt; 3) | ((raw[2] &amp; 0xe0) &gt;&gt; 5);
+	__u8 e =   raw[2] &amp; 0x07;
+
+	/*
+	 * As yet unmapped bits:
+	 * 0b11000000 0b11110001 0b00011000 0b00011000
+	 */
+
+	return sprintf(buf, "%u.%u.%u.%u.%u", a, b, c, d, e);
+}
+
+static void ntrig_report_version(struct hid_device *hdev)
+{
+	int ret;
+	char buf[20];
+	struct usb_device *usb_dev = hid_to_usb_dev(hdev);
+	unsigned char *data = kmalloc(8, GFP_KERNEL);
+
+	if (!data)
+		goto err_free;
+
+	ret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),
+			      USB_REQ_CLEAR_FEATURE,
+			      USB_TYPE_CLASS | USB_RECIP_INTERFACE |
+			      USB_DIR_IN,
+			      0x30c, 1, data, 8,
+			      USB_CTRL_SET_TIMEOUT);
+
+	if (ret == 8) {
+		ret = ntrig_version_string(&amp;data[2], buf);
+
+		dev_info(&amp;hdev-&gt;dev,
+			 "Firmware version: %s (%02x%02x %02x%02x)\n",
+			 buf, data[2], data[3], data[4], data[5]);
+	}
+
+err_free:
+	kfree(data);
+}
+
 static ssize_t show_phys_width(struct device *dev,
 			       struct device_attribute *attr,
 			       char *buf)
@@ -848,6 +897,8 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 	if (report)
 		usbhid_submit_report(hdev, report, USB_DIR_OUT);
 
+	ntrig_report_version(hdev);
+
 	ret = sysfs_create_group(&amp;hdev-&gt;dev.kobj,
 			&amp;ntrig_attribute_group);
 </pre><hr><pre>commit a52dc34c0eea991115a9d789e9461f06768fa360
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Thu Aug 26 00:54:55 2010 -0400

    HID: ntrig: a bit of whitespace cleanup
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-ntrig.c b/drivers/hid/hid-ntrig.c
index fb69b8c4953f..43e95dee9290 100644
--- a/drivers/hid/hid-ntrig.c
+++ b/drivers/hid/hid-ntrig.c
@@ -377,8 +377,8 @@ static struct attribute_group ntrig_attribute_group = {
  */
 
 static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
-		struct hid_field *field, struct hid_usage *usage,
-		unsigned long **bit, int *max)
+			       struct hid_field *field, struct hid_usage *usage,
+			       unsigned long **bit, int *max)
 {
 	struct ntrig_data *nd = hid_get_drvdata(hdev);
 
@@ -448,13 +448,13 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 		/* width/height mapped on TouchMajor/TouchMinor/Orientation */
 		case HID_DG_WIDTH:
 			hid_map_usage(hi, usage, bit, max,
-					EV_ABS, ABS_MT_TOUCH_MAJOR);
+				      EV_ABS, ABS_MT_TOUCH_MAJOR);
 			return 1;
 		case HID_DG_HEIGHT:
 			hid_map_usage(hi, usage, bit, max,
-					EV_ABS, ABS_MT_TOUCH_MINOR);
+				      EV_ABS, ABS_MT_TOUCH_MINOR);
 			input_set_abs_params(hi-&gt;input, ABS_MT_ORIENTATION,
-					0, 1, 0, 0);
+					     0, 1, 0, 0);
 			return 1;
 		}
 		return 0;
@@ -468,8 +468,8 @@ static int ntrig_input_mapping(struct hid_device *hdev, struct hid_input *hi,
 }
 
 static int ntrig_input_mapped(struct hid_device *hdev, struct hid_input *hi,
-		struct hid_field *field, struct hid_usage *usage,
-		unsigned long **bit, int *max)
+			      struct hid_field *field, struct hid_usage *usage,
+			      unsigned long **bit, int *max)
 {
 	/* No special mappings needed for the pen and single touch */
 	if (field-&gt;physical)
@@ -489,7 +489,7 @@ static int ntrig_input_mapped(struct hid_device *hdev, struct hid_input *hi,
  * and call input_mt_sync after each point if necessary
  */
 static int ntrig_event (struct hid_device *hid, struct hid_field *field,
-		                        struct hid_usage *usage, __s32 value)
+			struct hid_usage *usage, __s32 value)
 {
 	struct input_dev *input = field-&gt;hidinput-&gt;input;
 	struct ntrig_data *nd = hid_get_drvdata(hid);
@@ -860,7 +860,7 @@ static int ntrig_probe(struct hid_device *hdev, const struct hid_device_id *id)
 static void ntrig_remove(struct hid_device *hdev)
 {
 	sysfs_remove_group(&amp;hdev-&gt;dev.kobj,
-			&amp;ntrig_attribute_group);
+			   &amp;ntrig_attribute_group);
 	hid_hw_stop(hdev);
 	kfree(hid_get_drvdata(hdev));
 }</pre><hr><pre>commit 29cf28ae8dc244f89e213dc198f2286659d521b5
Author: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
Date:   Thu Aug 26 00:54:54 2010 -0400

    HID: ntrig: add documention
    
    The doctumentation includes a brief introduction to the driver and
    explanations of the filtering parameters as well as a discussion
    of the need for and working of the filters.
    
    Signed-off-by: Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/Documentation/input/ntrig.txt b/Documentation/input/ntrig.txt
new file mode 100644
index 000000000000..be1fd981f73f
--- /dev/null
+++ b/Documentation/input/ntrig.txt
@@ -0,0 +1,126 @@
+N-Trig touchscreen Driver
+-------------------------
+	Copyright (c) 2008-2010 Rafi Rubin &lt;rafi@seas.upenn.edu&gt;
+	Copyright (c) 2009-2010 Stephane Chatty
+
+This driver provides support for N-Trig pen and multi-touch sensors.  Single
+and multi-touch events are translated to the appropriate protocols for
+the hid and input systems.  Pen events are sufficiently hid compliant and
+are left to the hid core.  The driver also provides additional filtering
+and utility functions accessible with sysfs and module parameters.
+
+This driver has been reported to work properly with multiple N-Trig devices
+attached.
+
+
+Parameters
+----------
+
+Note: values set at load time are global and will apply to all applicable
+devices.  Adjusting parameters with sysfs will override the load time values,
+but only for that one device.
+
+The following parameters are used to configure filters to reduce noise:
+
+activate_slack		number of fingers to ignore before processing events
+
+activation_height	size threshold to activate immediately
+activation_width
+
+min_height		size threshold bellow which fingers are ignored
+min_width		both to decide activation and during activity
+
+deactivate_slack	the number of "no contact" frames to ignore before
+			propagating the end of activity events
+
+When the last finger is removed from the device, it sends a number of empty
+frames.  By holding off on deactivation for a few frames we can tolerate false
+erroneous disconnects, where the sensor may mistakenly not detect a finger that
+is still present.  Thus deactivate_slack addresses problems where a users might
+see breaks in lines during drawing, or drop an object during a long drag.
+
+
+Additional sysfs items
+----------------------
+
+These nodes just provide easy access to the ranges reported by the device.
+sensor_logical_height	the range for positions reported during activity
+sensor_logical_width
+
+sensor_physical_height	internal ranges not used for normal events but
+sensor_physical_width	useful for tuning
+
+All N-Trig devices with product id of 1 report events in the ranges of
+X: 0-9600
+Y: 0-7200
+However not all of these devices have the same physical dimensions.  Most
+seem to be 12" sensors (Dell Latitude XT and XT2 and the HP TX2), and
+at least one model (Dell Studio 17) has a 17" sensor.  The ratio of physical
+to logical sizes is used to adjust the size based filter parameters.
+
+
+Filtering
+---------
+
+With the release of the early multi-touch firmwares it became increasingly
+obvious that these sensors were prone to erroneous events.  Users reported
+seeing both inappropriately dropped contact and ghosts, contacts reported
+where no finger was actually touching the screen.
+
+Deactivation slack helps prevent dropped contact for single touch use, but does
+not address the problem of dropping one of more contacts while other contacts
+are still active.  Drops in the multi-touch context require additional
+processing and should be handled in tandem with tacking.
+
+As observed ghost contacts are similar to actual use of the sensor, but they
+seem to have different profiles.  Ghost activity typically shows up as small
+short lived touches.  As such, I assume that the longer the continuous stream
+of events the more likely those events are from a real contact, and that the
+larger the size of each contact the more likely it is real.  Balancing the
+goals of preventing ghosts and accepting real events quickly (to minimize
+user observable latency), the filter accumulates confidence for incoming
+events until it hits thresholds and begins propagating.  In the interest in
+minimizing stored state as well as the cost of operations to make a decision,
+I've kept that decision simple.
+
+Time is measured in terms of the number of fingers reported, not frames since
+the probability of multiple simultaneous ghosts is expected to drop off
+dramatically with increasing numbers.  Rather than accumulate weight as a
+function of size, I just use it as a binary threshold.  A sufficiently large
+contact immediately overrides the waiting period and leads to activation.
+
+Setting the activation size thresholds to large values will result in deciding
+primarily on activation slack.  If you see longer lived ghosts, turning up the
+activation slack while reducing the size thresholds may suffice to eliminate
+the ghosts while keeping the screen quite responsive to firm taps.
+
+Contacts continue to be filtered with min_height and min_width even after
+the initial activation filter is satisfied.  The intent is to provide
+a mechanism for filtering out ghosts in the form of an extra finger while
+you actually are using the screen.  In practice this sort of ghost has
+been far less problematic or relatively rare and I've left the defaults
+set to 0 for both parameters, effectively turning off that filter.
+
+I don't know what the optimal values are for these filters.  If the defaults
+don't work for you, please play with the parameters.  If you do find other
+values more comfortable, I would appreciate feedback.
+
+The calibration of these devices does drift over time.  If ghosts or contact
+dropping worsen and interfere with the normal usage of your device, try
+recalibrating it.
+
+
+Calibration
+-----------
+
+The N-Trig windows tools provide calibration and testing routines.  Also an
+unofficial unsupported set of user space tools including a calibrator is
+available at:
+http://code.launchpad.net/~rafi-seas/+junk/ntrig_calib
+
+
+Tracking
+--------
+
+As of yet, all tested N-Trig firmwares do not track fingers.  When multiple
+contacts are active they seem to be sorted primarily by Y position.</pre>
    <div class="pagination">
        <span>[1]</span><a href='25_2.html'>2</a><a href='25_3.html'>3</a><a href='25_2.html'>Next&gt;&gt;</a>
    <div>
</body>
