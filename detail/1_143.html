<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_142.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><span>[143]</span><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_144.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit f3980dc50c5117a952baee7135aae50d48304af3
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Thu Jan 23 02:45:02 2014 -0500

    drm/nouveau: resume display if any later suspend bits fail
    
    If either idling channels or suspending the fence were to fail, the
    display would never be resumed. Also if a client fails, resume the fence
    (not functionally important, but it would potentially leak memory).
    
    See https://bugs.freedesktop.org/show_bug.cgi?id=70213
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c
index eecc6ca377c8..78c8e7146d56 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c
@@ -503,19 +503,21 @@ nouveau_do_suspend(struct drm_device *dev)
 	if (drm-&gt;cechan) {
 		ret = nouveau_channel_idle(drm-&gt;cechan);
 		if (ret)
-			return ret;
+			goto fail_display;
 	}
 
 	if (drm-&gt;channel) {
 		ret = nouveau_channel_idle(drm-&gt;channel);
 		if (ret)
-			return ret;
+			goto fail_display;
 	}
 
 	NV_INFO(drm, "suspending client object trees...\n");
 	if (drm-&gt;fence &amp;&amp; nouveau_fence(drm)-&gt;suspend) {
-		if (!nouveau_fence(drm)-&gt;suspend(drm))
-			return -ENOMEM;
+		if (!nouveau_fence(drm)-&gt;suspend(drm)) {
+			ret = -ENOMEM;
+			goto fail_display;
+		}
 	}
 
 	list_for_each_entry(cli, &amp;drm-&gt;clients, head) {
@@ -537,6 +539,10 @@ nouveau_do_suspend(struct drm_device *dev)
 		nouveau_client_init(&amp;cli-&gt;base);
 	}
 
+	if (drm-&gt;fence &amp;&amp; nouveau_fence(drm)-&gt;resume)
+		nouveau_fence(drm)-&gt;resume(drm);
+
+fail_display:
 	if (dev-&gt;mode_config.num_crtc) {
 		NV_INFO(drm, "resuming display...\n");
 		nouveau_display_resume(dev);</pre><hr><pre>commit ea7dce90105ff2eb81958498d6d9f30a0753bbe8
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Fri Jan 17 00:13:05 2014 -0500

    drm/nv50/gr: print mpc trap name when it's not an mp trap
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c b/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
index 0f8d18ae6802..30ed19c52e05 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
@@ -315,6 +315,20 @@ static const struct nouveau_bitfield nv50_mp_exec_errors[] = {
 	{}
 };
 
+static const struct nouveau_bitfield nv50_mpc_traps[] = {
+	{ 0x0000001, "LOCAL_LIMIT_READ" },
+	{ 0x0000010, "LOCAL_LIMIT_WRITE" },
+	{ 0x0000040, "STACK_LIMIT" },
+	{ 0x0000100, "GLOBAL_LIMIT_READ" },
+	{ 0x0001000, "GLOBAL_LIMIT_WRITE" },
+	{ 0x0010000, "MP0" },
+	{ 0x0020000, "MP1" },
+	{ 0x0040000, "GLOBAL_LIMIT_RED" },
+	{ 0x0400000, "GLOBAL_LIMIT_ATOM" },
+	{ 0x4000000, "MP2" },
+	{}
+};
+
 static const struct nouveau_bitfield nv50_graph_trap_m2mf[] = {
 	{ 0x00000001, "NOTIFY" },
 	{ 0x00000002, "IN" },
@@ -524,6 +538,12 @@ nv50_priv_tp_trap(struct nv50_graph_priv *priv, int type, u32 ustatus_old,
 				nv50_priv_mp_trap(priv, i, display);
 				ustatus &amp;= ~0x04030000;
 			}
+			if (ustatus &amp;&amp; display) {
+				nv_error("%s - TP%d:", name, i);
+				nouveau_bitfield_print(nv50_mpc_traps, ustatus);
+				pr_cont("\n");
+				ustatus = 0;
+			}
 			break;
 		case 8: /* PROP error */
 			if (display)</pre><hr><pre>commit f750ecc95068b2b492819ca15182fc4c632b4cca
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Fri Jan 17 06:19:46 2014 -0500

    drm/nv50/gr: update list of mp errors, make it a bitfield
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c b/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
index a489ac2f3382..0f8d18ae6802 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
@@ -304,12 +304,14 @@ nv84_graph_tlb_flush(struct nouveau_engine *engine)
 	return timeout ? -EBUSY : 0;
 }
 
-static const struct nouveau_enum nv50_mp_exec_error_names[] = {
-	{ 3, "STACK_UNDERFLOW", NULL },
-	{ 4, "QUADON_ACTIVE", NULL },
-	{ 8, "TIMEOUT", NULL },
-	{ 0x10, "INVALID_OPCODE", NULL },
-	{ 0x40, "BREAKPOINT", NULL },
+static const struct nouveau_bitfield nv50_mp_exec_errors[] = {
+	{ 0x01, "STACK_UNDERFLOW" },
+	{ 0x02, "STACK_MISMATCH" },
+	{ 0x04, "QUADON_ACTIVE" },
+	{ 0x08, "TIMEOUT" },
+	{ 0x10, "INVALID_OPCODE" },
+	{ 0x20, "PM_OVERFLOW" },
+	{ 0x40, "BREAKPOINT" },
 	{}
 };
 
@@ -474,8 +476,8 @@ nv50_priv_mp_trap(struct nv50_graph_priv *priv, int tpid, int display)
 			oplow = nv_rd32(priv, addr + 0x70);
 			ophigh = nv_rd32(priv, addr + 0x74);
 			nv_error(priv, "TRAP_MP_EXEC - "
-					"TP %d MP %d: ", tpid, i);
-			nouveau_enum_print(nv50_mp_exec_error_names, status);
+					"TP %d MP %d:", tpid, i);
+			nouveau_bitfield_print(nv50_mp_exec_errors, status);
 			pr_cont(" at %06x warp %d, opcode %08x %08x\n",
 					pc&amp;0xffffff, pc &gt;&gt; 24,
 					oplow, ophigh);</pre><hr><pre>commit e2dd003dfa81de3247d7edae5d1a49427cf5a2c4
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Thu Jan 16 02:47:11 2014 -0500

    drm/nv50/gr: add more trap names to print on error
    
    Also avoids printing the errors bitfield if that information has already
    been shown.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c b/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
index 03de5175dd9f..a489ac2f3382 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/nv50.c
@@ -396,6 +396,60 @@ static const struct nouveau_bitfield nv50_graph_intr_name[] = {
 	{}
 };
 
+static const struct nouveau_bitfield nv50_graph_trap_prop[] = {
+	{ 0x00000004, "SURF_WIDTH_OVERRUN" },
+	{ 0x00000008, "SURF_HEIGHT_OVERRUN" },
+	{ 0x00000010, "DST2D_FAULT" },
+	{ 0x00000020, "ZETA_FAULT" },
+	{ 0x00000040, "RT_FAULT" },
+	{ 0x00000080, "CUDA_FAULT" },
+	{ 0x00000100, "DST2D_STORAGE_TYPE_MISMATCH" },
+	{ 0x00000200, "ZETA_STORAGE_TYPE_MISMATCH" },
+	{ 0x00000400, "RT_STORAGE_TYPE_MISMATCH" },
+	{ 0x00000800, "DST2D_LINEAR_MISMATCH" },
+	{ 0x00001000, "RT_LINEAR_MISMATCH" },
+	{}
+};
+
+static void
+nv50_priv_prop_trap(struct nv50_graph_priv *priv,
+		    u32 ustatus_addr, u32 ustatus, u32 tp)
+{
+	u32 e0c = nv_rd32(priv, ustatus_addr + 0x04);
+	u32 e10 = nv_rd32(priv, ustatus_addr + 0x08);
+	u32 e14 = nv_rd32(priv, ustatus_addr + 0x0c);
+	u32 e18 = nv_rd32(priv, ustatus_addr + 0x10);
+	u32 e1c = nv_rd32(priv, ustatus_addr + 0x14);
+	u32 e20 = nv_rd32(priv, ustatus_addr + 0x18);
+	u32 e24 = nv_rd32(priv, ustatus_addr + 0x1c);
+
+	/* CUDA memory: l[], g[] or stack. */
+	if (ustatus &amp; 0x00000080) {
+		if (e18 &amp; 0x80000000) {
+			/* g[] read fault? */
+			nv_error(priv, "TRAP_PROP - TP %d - CUDA_FAULT - Global read fault at address %02x%08x\n",
+					 tp, e14, e10 | ((e18 &gt;&gt; 24) &amp; 0x1f));
+			e18 &amp;= ~0x1f000000;
+		} else if (e18 &amp; 0xc) {
+			/* g[] write fault? */
+			nv_error(priv, "TRAP_PROP - TP %d - CUDA_FAULT - Global write fault at address %02x%08x\n",
+				 tp, e14, e10 | ((e18 &gt;&gt; 7) &amp; 0x1f));
+			e18 &amp;= ~0x00000f80;
+		} else {
+			nv_error(priv, "TRAP_PROP - TP %d - Unknown CUDA fault at address %02x%08x\n",
+				 tp, e14, e10);
+		}
+		ustatus &amp;= ~0x00000080;
+	}
+	if (ustatus) {
+		nv_error(priv, "TRAP_PROP - TP %d -", tp);
+		nouveau_bitfield_print(nv50_graph_trap_prop, ustatus);
+		pr_cont(" - Address %02x%08x\n", e14, e10);
+	}
+	nv_error(priv, "TRAP_PROP - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
+		 tp, e0c, e18, e1c, e20, e24);
+}
+
 static void
 nv50_priv_mp_trap(struct nv50_graph_priv *priv, int tpid, int display)
 {
@@ -469,58 +523,11 @@ nv50_priv_tp_trap(struct nv50_graph_priv *priv, int type, u32 ustatus_old,
 				ustatus &amp;= ~0x04030000;
 			}
 			break;
-		case 8: /* TPDMA error */
-			{
-			u32 e0c = nv_rd32(priv, ustatus_addr + 4);
-			u32 e10 = nv_rd32(priv, ustatus_addr + 8);
-			u32 e14 = nv_rd32(priv, ustatus_addr + 0xc);
-			u32 e18 = nv_rd32(priv, ustatus_addr + 0x10);
-			u32 e1c = nv_rd32(priv, ustatus_addr + 0x14);
-			u32 e20 = nv_rd32(priv, ustatus_addr + 0x18);
-			u32 e24 = nv_rd32(priv, ustatus_addr + 0x1c);
-			/* 2d engine destination */
-			if (ustatus &amp; 0x00000010) {
-				if (display) {
-					nv_error(priv, "TRAP_TPDMA_2D - TP %d - Unknown fault at address %02x%08x\n",
-							i, e14, e10);
-					nv_error(priv, "TRAP_TPDMA_2D - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
-							i, e0c, e18, e1c, e20, e24);
-				}
-				ustatus &amp;= ~0x00000010;
-			}
-			/* Render target */
-			if (ustatus &amp; 0x00000040) {
-				if (display) {
-					nv_error(priv, "TRAP_TPDMA_RT - TP %d - Unknown fault at address %02x%08x\n",
-							i, e14, e10);
-					nv_error(priv, "TRAP_TPDMA_RT - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
-							i, e0c, e18, e1c, e20, e24);
-				}
-				ustatus &amp;= ~0x00000040;
-			}
-			/* CUDA memory: l[], g[] or stack. */
-			if (ustatus &amp; 0x00000080) {
-				if (display) {
-					if (e18 &amp; 0x80000000) {
-						/* g[] read fault? */
-						nv_error(priv, "TRAP_TPDMA - TP %d - Global read fault at address %02x%08x\n",
-								i, e14, e10 | ((e18 &gt;&gt; 24) &amp; 0x1f));
-						e18 &amp;= ~0x1f000000;
-					} else if (e18 &amp; 0xc) {
-						/* g[] write fault? */
-						nv_error(priv, "TRAP_TPDMA - TP %d - Global write fault at address %02x%08x\n",
-								i, e14, e10 | ((e18 &gt;&gt; 7) &amp; 0x1f));
-						e18 &amp;= ~0x00000f80;
-					} else {
-						nv_error(priv, "TRAP_TPDMA - TP %d - Unknown CUDA fault at address %02x%08x\n",
-								i, e14, e10);
-					}
-					nv_error(priv, "TRAP_TPDMA - TP %d - e0c: %08x, e18: %08x, e1c: %08x, e20: %08x, e24: %08x\n",
-							i, e0c, e18, e1c, e20, e24);
-				}
-				ustatus &amp;= ~0x00000080;
-			}
-			}
+		case 8: /* PROP error */
+			if (display)
+				nv50_priv_prop_trap(
+						priv, ustatus_addr, ustatus, i);
+			ustatus = 0;
 			break;
 		}
 		if (ustatus) {
@@ -727,11 +734,11 @@ nv50_graph_trap_handler(struct nv50_graph_priv *priv, u32 display,
 		status &amp;= ~0x080;
 	}
 
-	/* TPDMA:  Handles TP-initiated uncached memory accesses:
+	/* PROP:  Handles TP-initiated uncached memory accesses:
 	 * l[], g[], stack, 2d surfaces, render targets. */
 	if (status &amp; 0x100) {
 		nv50_priv_tp_trap(priv, 8, 0x408e08, 0x408708, display,
-				    "TRAP_TPDMA");
+				    "TRAP_PROP");
 		nv_wr32(priv, 0x400108, 0x100);
 		status &amp;= ~0x100;
 	}
@@ -760,7 +767,7 @@ nv50_graph_intr(struct nouveau_subdev *subdev)
 	u32 mthd = (addr &amp; 0x00001ffc);
 	u32 data = nv_rd32(priv, 0x400708);
 	u32 class = nv_rd32(priv, 0x400814);
-	u32 show = stat;
+	u32 show = stat, show_bitfield = stat;
 	int chid;
 
 	engctx = nouveau_engctx_get(engine, inst);
@@ -778,21 +785,26 @@ nv50_graph_intr(struct nouveau_subdev *subdev)
 		nv_error(priv, "DATA_ERROR ");
 		nouveau_enum_print(nv50_data_error_names, ecode);
 		pr_cont("\n");
+		show_bitfield &amp;= ~0x00100000;
 	}
 
 	if (stat &amp; 0x00200000) {
 		if (!nv50_graph_trap_handler(priv, show, chid, (u64)inst &lt;&lt; 12,
 				engctx))
 			show &amp;= ~0x00200000;
+		show_bitfield &amp;= ~0x00200000;
 	}
 
 	nv_wr32(priv, 0x400100, stat);
 	nv_wr32(priv, 0x400500, 0x00010001);
 
 	if (show) {
-		nv_error(priv, "%s", "");
-		nouveau_bitfield_print(nv50_graph_intr_name, show);
-		pr_cont("\n");
+		show &amp;= show_bitfield;
+		if (show) {
+			nv_error(priv, "%s", "");
+			nouveau_bitfield_print(nv50_graph_intr_name, show);
+			pr_cont("\n");
+		}
 		nv_error(priv,
 			 "ch %d [0x%010llx %s] subc %d class 0x%04x mthd 0x%04x data 0x%08x\n",
 			 chid, (u64)inst &lt;&lt; 12, nouveau_client_name(engctx),</pre><hr><pre>commit f87cd8b695d372087685976460fac1ec6ba2fca9
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sun Jan 19 04:18:15 2014 -0500

    drm/nouveau/devinit: lock/unlock crtc regs for all devices, not just pre-nv50
    
    Also make nv_lockvgac work for nv50+ devices. This should fix
    IO_CONDITION and related VBIOS opcodes that read/write the crtc regs.
    
    See https://bugs.freedesktop.org/show_bug.cgi?id=60680
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/disp/vga.c b/drivers/gpu/drm/nouveau/core/engine/disp/vga.c
index 5a1c68474597..8836c3cb99c3 100644
--- a/drivers/gpu/drm/nouveau/core/engine/disp/vga.c
+++ b/drivers/gpu/drm/nouveau/core/engine/disp/vga.c
@@ -138,10 +138,15 @@ nv_wrvgai(void *obj, int head, u16 port, u8 index, u8 value)
 bool
 nv_lockvgac(void *obj, bool lock)
 {
+	struct nouveau_device *dev = nv_device(obj);
+
 	bool locked = !nv_rdvgac(obj, 0, 0x1f);
 	u8 data = lock ? 0x99 : 0x57;
-	nv_wrvgac(obj, 0, 0x1f, data);
-	if (nv_device(obj)-&gt;chipset == 0x11) {
+	if (dev-&gt;card_type &lt; NV_50)
+		nv_wrvgac(obj, 0, 0x1f, data);
+	else
+		nv_wrvgac(obj, 0, 0x3f, data);
+	if (dev-&gt;chipset == 0x11) {
 		if (!(nv_rd32(obj, 0x001084) &amp; 0x10000000))
 			nv_wrvgac(obj, 1, 0x1f, data);
 	}
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
index 6b23d9a0b953..8fa34e8152c2 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
@@ -26,6 +26,7 @@
 
 #include &lt;subdev/bios.h&gt;
 #include &lt;subdev/bios/init.h&gt;
+#include &lt;subdev/vga.h&gt;
 
 #include "priv.h"
 
@@ -38,6 +39,9 @@ _nouveau_devinit_fini(struct nouveau_object *object, bool suspend)
 	if (suspend)
 		devinit-&gt;post = true;
 
+	/* unlock the extended vga crtc regs */
+	nv_lockvgac(devinit, false);
+
 	return nouveau_subdev_fini(&amp;devinit-&gt;base, suspend);
 }
 
@@ -61,6 +65,17 @@ _nouveau_devinit_init(struct nouveau_object *object)
 	return 0;
 }
 
+void
+_nouveau_devinit_dtor(struct nouveau_object *object)
+{
+	struct nouveau_devinit *devinit = (void *)object;
+
+	/* lock crtc regs */
+	nv_lockvgac(devinit, true);
+
+	nouveau_subdev_destroy(&amp;devinit-&gt;base);
+}
+
 int
 nouveau_devinit_create_(struct nouveau_object *parent,
 			struct nouveau_object *engine,
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
index 24025e4e882a..7037eae46e44 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
@@ -388,17 +388,21 @@ int
 nv04_devinit_fini(struct nouveau_object *object, bool suspend)
 {
 	struct nv04_devinit_priv *priv = (void *)object;
+	int ret;
 
 	/* make i2c busses accessible */
 	nv_mask(priv, 0x000200, 0x00000001, 0x00000001);
 
-	/* unlock extended vga crtc regs, and unslave crtcs */
-	nv_lockvgac(priv, false);
+	ret = nouveau_devinit_fini(&amp;priv-&gt;base, suspend);
+	if (ret)
+		return ret;
+
+	/* unslave crtcs */
 	if (priv-&gt;owner &lt; 0)
 		priv-&gt;owner = nv_rdvgaowner(priv);
 	nv_wrvgaowner(priv, 0);
 
-	return nouveau_devinit_fini(&amp;priv-&gt;base, suspend);
+	return 0;
 }
 
 int
@@ -426,9 +430,8 @@ nv04_devinit_dtor(struct nouveau_object *object)
 {
 	struct nv04_devinit_priv *priv = (void *)object;
 
-	/* restore vga owner saved at first init, and lock crtc regs  */
+	/* restore vga owner saved at first init */
 	nv_wrvgaowner(priv, priv-&gt;owner);
-	nv_lockvgac(priv, true);
 
 	nouveau_devinit_destroy(&amp;priv-&gt;base);
 }
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h b/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h
index c4179b6d6eca..822a2fbf44a5 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h
@@ -15,8 +15,10 @@ struct nouveau_devinit_impl {
 
 #define nouveau_devinit_create(p,e,o,d)                                        \
 	nouveau_devinit_create_((p), (e), (o), sizeof(**d), (void **)d)
-#define nouveau_devinit_destroy(p)                                             \
-	nouveau_subdev_destroy(&amp;(p)-&gt;base)
+#define nouveau_devinit_destroy(p) ({                                          \
+	struct nouveau_devinit *d = (p);                                       \
+	_nouveau_devinit_dtor(nv_object(d));                                   \
+})
 #define nouveau_devinit_init(p) ({                                             \
 	struct nouveau_devinit *d = (p);                                       \
 	_nouveau_devinit_init(nv_object(d));                                   \
@@ -28,7 +30,7 @@ struct nouveau_devinit_impl {
 
 int nouveau_devinit_create_(struct nouveau_object *, struct nouveau_object *,
 			    struct nouveau_oclass *, int, void **);
-#define _nouveau_devinit_dtor _nouveau_subdev_dtor
+void _nouveau_devinit_dtor(struct nouveau_object *);
 int _nouveau_devinit_init(struct nouveau_object *);
 int _nouveau_devinit_fini(struct nouveau_object *, bool suspend);
 </pre><hr><pre>commit 4019aaa2b314a5be9886ae1db64ff8c6d3c060ed
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Tue Jan 14 16:29:06 2014 +1000

    drm/nv50-/devinit: prevent use of engines marked as disabled by hw/vbios
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/Makefile b/drivers/gpu/drm/nouveau/Makefile
index d1dd49b344ec..e88145ba1bf5 100644
--- a/drivers/gpu/drm/nouveau/Makefile
+++ b/drivers/gpu/drm/nouveau/Makefile
@@ -72,7 +72,10 @@ nouveau-y += core/subdev/devinit/nv10.o
 nouveau-y += core/subdev/devinit/nv1a.o
 nouveau-y += core/subdev/devinit/nv20.o
 nouveau-y += core/subdev/devinit/nv50.o
+nouveau-y += core/subdev/devinit/nv84.o
+nouveau-y += core/subdev/devinit/nv98.o
 nouveau-y += core/subdev/devinit/nva3.o
+nouveau-y += core/subdev/devinit/nvaf.o
 nouveau-y += core/subdev/devinit/nvc0.o
 nouveau-y += core/subdev/fb/base.o
 nouveau-y += core/subdev/fb/nv04.o
diff --git a/drivers/gpu/drm/nouveau/core/engine/copy/nvc0.c b/drivers/gpu/drm/nouveau/core/engine/copy/nvc0.c
index 993df09ad643..ac3291f781f6 100644
--- a/drivers/gpu/drm/nouveau/core/engine/copy/nvc0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/copy/nvc0.c
@@ -105,9 +105,6 @@ nvc0_copy0_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	struct nvc0_copy_priv *priv;
 	int ret;
 
-	if (nv_rd32(parent, 0x022500) &amp; 0x00000100)
-		return -ENODEV;
-
 	ret = nouveau_falcon_create(parent, engine, oclass, 0x104000, true,
 				    "PCE0", "copy0", &amp;priv);
 	*pobject = nv_object(priv);
@@ -133,9 +130,6 @@ nvc0_copy1_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	struct nvc0_copy_priv *priv;
 	int ret;
 
-	if (nv_rd32(parent, 0x022500) &amp; 0x00000200)
-		return -ENODEV;
-
 	ret = nouveau_falcon_create(parent, engine, oclass, 0x105000, true,
 				    "PCE1", "copy1", &amp;priv);
 	*pobject = nv_object(priv);
diff --git a/drivers/gpu/drm/nouveau/core/engine/copy/nve0.c b/drivers/gpu/drm/nouveau/core/engine/copy/nve0.c
index 30f1ef1edcc5..748a61eb3c6f 100644
--- a/drivers/gpu/drm/nouveau/core/engine/copy/nve0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/copy/nve0.c
@@ -88,9 +88,6 @@ nve0_copy0_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	struct nve0_copy_priv *priv;
 	int ret;
 
-	if (nv_rd32(parent, 0x022500) &amp; 0x00000100)
-		return -ENODEV;
-
 	ret = nouveau_engine_create(parent, engine, oclass, true,
 				    "PCE0", "copy0", &amp;priv);
 	*pobject = nv_object(priv);
@@ -112,9 +109,6 @@ nve0_copy1_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	struct nve0_copy_priv *priv;
 	int ret;
 
-	if (nv_rd32(parent, 0x022500) &amp; 0x00000200)
-		return -ENODEV;
-
 	ret = nouveau_engine_create(parent, engine, oclass, true,
 				    "PCE1", "copy1", &amp;priv);
 	*pobject = nv_object(priv);
diff --git a/drivers/gpu/drm/nouveau/core/engine/device/nv50.c b/drivers/gpu/drm/nouveau/core/engine/device/nv50.c
index 5ae94475a3f1..81d5c26643d5 100644
--- a/drivers/gpu/drm/nouveau/core/engine/device/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/engine/device/nv50.c
@@ -90,7 +90,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nv84_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv84_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv50_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv50_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -118,7 +118,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nv84_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv84_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv50_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv50_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -146,7 +146,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nv84_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv84_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv50_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv50_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -174,7 +174,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nv84_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv84_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv94_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv94_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -202,7 +202,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nv84_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv84_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv94_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv94_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -230,7 +230,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nv84_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv98_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv98_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv94_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -258,7 +258,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nv84_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv84_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv98_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv94_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -286,7 +286,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nvaa_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv98_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv98_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv94_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -314,7 +314,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] =  nvaa_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nv84_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv50_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nv98_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv98_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv94_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
@@ -430,7 +430,7 @@ nv50_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_SUBDEV_CLOCK  ] = &amp;nva3_clock_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_THERM  ] = &amp;nva3_therm_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MXM    ] = &amp;nv50_mxm_oclass;
-		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nva3_devinit_oclass;
+		device-&gt;oclass[NVDEV_SUBDEV_DEVINIT] =  nvaf_devinit_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_MC     ] =  nv98_mc_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_BUS    ] =  nv94_bus_oclass;
 		device-&gt;oclass[NVDEV_SUBDEV_TIMER  ] = &amp;nv04_timer_oclass;
diff --git a/drivers/gpu/drm/nouveau/core/engine/disp/nvd0.c b/drivers/gpu/drm/nouveau/core/engine/disp/nvd0.c
index 378a015091d2..d52c0f50a1a9 100644
--- a/drivers/gpu/drm/nouveau/core/engine/disp/nvd0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/disp/nvd0.c
@@ -967,9 +967,6 @@ nvd0_disp_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	int heads = nv_rd32(parent, 0x022448);
 	int ret;
 
-	if (nv_rd32(parent, 0x022500) &amp; 0x00000001)
-		return -ENODEV;
-
 	ret = nouveau_disp_create(parent, engine, oclass, heads,
 				  "PDISP", "display", &amp;priv);
 	*pobject = nv_object(priv);
diff --git a/drivers/gpu/drm/nouveau/core/engine/disp/nve0.c b/drivers/gpu/drm/nouveau/core/engine/disp/nve0.c
index fb1fe6ae5e74..20725b363d58 100644
--- a/drivers/gpu/drm/nouveau/core/engine/disp/nve0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/disp/nve0.c
@@ -54,9 +54,6 @@ nve0_disp_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	int heads = nv_rd32(parent, 0x022448);
 	int ret;
 
-	if (nv_rd32(parent, 0x022500) &amp; 0x00000001)
-		return -ENODEV;
-
 	ret = nouveau_disp_create(parent, engine, oclass, heads,
 				  "PDISP", "display", &amp;priv);
 	*pobject = nv_object(priv);
diff --git a/drivers/gpu/drm/nouveau/core/engine/disp/nvf0.c b/drivers/gpu/drm/nouveau/core/engine/disp/nvf0.c
index 42aa6b97dbea..a488c36e40f9 100644
--- a/drivers/gpu/drm/nouveau/core/engine/disp/nvf0.c
+++ b/drivers/gpu/drm/nouveau/core/engine/disp/nvf0.c
@@ -54,9 +54,6 @@ nvf0_disp_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	int heads = nv_rd32(parent, 0x022448);
 	int ret;
 
-	if (nv_rd32(parent, 0x022500) &amp; 0x00000001)
-		return -ENODEV;
-
 	ret = nouveau_disp_create(parent, engine, oclass, heads,
 				  "PDISP", "display", &amp;priv);
 	*pobject = nv_object(priv);
diff --git a/drivers/gpu/drm/nouveau/core/include/subdev/devinit.h b/drivers/gpu/drm/nouveau/core/include/subdev/devinit.h
index e59384d04870..ed1ac68c38b3 100644
--- a/drivers/gpu/drm/nouveau/core/include/subdev/devinit.h
+++ b/drivers/gpu/drm/nouveau/core/include/subdev/devinit.h
@@ -23,7 +23,10 @@ extern struct nouveau_oclass *nv10_devinit_oclass;
 extern struct nouveau_oclass *nv1a_devinit_oclass;
 extern struct nouveau_oclass *nv20_devinit_oclass;
 extern struct nouveau_oclass *nv50_devinit_oclass;
+extern struct nouveau_oclass *nv84_devinit_oclass;
+extern struct nouveau_oclass *nv98_devinit_oclass;
 extern struct nouveau_oclass *nva3_devinit_oclass;
+extern struct nouveau_oclass *nvaf_devinit_oclass;
 extern struct nouveau_oclass *nvc0_devinit_oclass;
 
 #endif
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
index 6013c42503d1..6b23d9a0b953 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/base.c
@@ -44,12 +44,21 @@ _nouveau_devinit_fini(struct nouveau_object *object, bool suspend)
 int
 _nouveau_devinit_init(struct nouveau_object *object)
 {
+	struct nouveau_devinit_impl *impl = (void *)object-&gt;oclass;
 	struct nouveau_devinit *devinit = (void *)object;
-	int ret = nouveau_subdev_init(&amp;devinit-&gt;base);
+	int ret;
+
+	ret = nouveau_subdev_init(&amp;devinit-&gt;base);
+	if (ret)
+		return ret;
+
+	ret = nvbios_init(&amp;devinit-&gt;base, devinit-&gt;post);
 	if (ret)
 		return ret;
 
-	return nvbios_init(&amp;devinit-&gt;base, devinit-&gt;post);
+	if (impl-&gt;disable)
+		nv_device(devinit)-&gt;disable_mask |= impl-&gt;disable(devinit);
+	return 0;
 }
 
 int
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.c
index f81509eb6c3e..b46c62a1d5d8 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.c
@@ -30,7 +30,7 @@
 
 #include "nv50.h"
 
-static int
+int
 nv50_devinit_pll_set(struct nouveau_devinit *devinit, u32 type, u32 freq)
 {
 	struct nv50_devinit_priv *priv = (void *)devinit;
@@ -74,6 +74,19 @@ nv50_devinit_pll_set(struct nouveau_devinit *devinit, u32 type, u32 freq)
 	return 0;
 }
 
+static u64
+nv50_devinit_disable(struct nouveau_devinit *devinit)
+{
+	struct nv50_devinit_priv *priv = (void *)devinit;
+	u32 r001540 = nv_rd32(priv, 0x001540);
+	u64 disable = 0ULL;
+
+	if (!(r001540 &amp; 0x40000000))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_MPEG);
+
+	return disable;
+}
+
 int
 nv50_devinit_init(struct nouveau_object *object)
 {
@@ -146,4 +159,5 @@ nv50_devinit_oclass = &amp;(struct nouveau_devinit_impl) {
 		.fini = _nouveau_devinit_fini,
 	},
 	.pll_set = nv50_devinit_pll_set,
+	.disable = nv50_devinit_disable,
 }.base;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.h b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.h
index f87e483b0977..141c27e9f182 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.h
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv50.h
@@ -11,5 +11,8 @@ int  nv50_devinit_ctor(struct nouveau_object *, struct nouveau_object *,
 		       struct nouveau_oclass *, void *, u32,
 		       struct nouveau_object **);
 int  nv50_devinit_init(struct nouveau_object *);
+int  nv50_devinit_pll_set(struct nouveau_devinit *, u32, u32);
+
+int  nva3_devinit_pll_set(struct nouveau_devinit *, u32, u32);
 
 #endif
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv84.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv84.c
new file mode 100644
index 000000000000..787422505d87
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv84.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include "nv50.h"
+
+static u64
+nv84_devinit_disable(struct nouveau_devinit *devinit)
+{
+	struct nv50_devinit_priv *priv = (void *)devinit;
+	u32 r001540 = nv_rd32(priv, 0x001540);
+	u32 r00154c = nv_rd32(priv, 0x00154c);
+	u64 disable = 0ULL;
+
+	if (!(r001540 &amp; 0x40000000)) {
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_MPEG);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_VP);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_BSP);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_CRYPT);
+	}
+
+	if (!(r00154c &amp; 0x00000004))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_DISP);
+	if (!(r00154c &amp; 0x00000020))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_BSP);
+	if (!(r00154c &amp; 0x00000040))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_CRYPT);
+
+	return disable;
+}
+
+struct nouveau_oclass *
+nv84_devinit_oclass = &amp;(struct nouveau_devinit_impl) {
+	.base.handle = NV_SUBDEV(DEVINIT, 0x84),
+	.base.ofuncs = &amp;(struct nouveau_ofuncs) {
+		.ctor = nv50_devinit_ctor,
+		.dtor = _nouveau_devinit_dtor,
+		.init = nv50_devinit_init,
+		.fini = _nouveau_devinit_fini,
+	},
+	.pll_set = nv50_devinit_pll_set,
+	.disable = nv84_devinit_disable,
+}.base;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv98.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv98.c
new file mode 100644
index 000000000000..2b0e963fc6f0
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv98.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include "nv50.h"
+
+static u64
+nv98_devinit_disable(struct nouveau_devinit *devinit)
+{
+	struct nv50_devinit_priv *priv = (void *)devinit;
+	u32 r001540 = nv_rd32(priv, 0x001540);
+	u32 r00154c = nv_rd32(priv, 0x00154c);
+	u64 disable = 0ULL;
+
+	if (!(r001540 &amp; 0x40000000)) {
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_VP);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_BSP);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_PPP);
+	}
+
+	if (!(r00154c &amp; 0x00000004))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_DISP);
+	if (!(r00154c &amp; 0x00000020))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_BSP);
+	if (!(r00154c &amp; 0x00000040))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_CRYPT);
+
+	return disable;
+}
+
+struct nouveau_oclass *
+nv98_devinit_oclass = &amp;(struct nouveau_devinit_impl) {
+	.base.handle = NV_SUBDEV(DEVINIT, 0x98),
+	.base.ofuncs = &amp;(struct nouveau_ofuncs) {
+		.ctor = nv50_devinit_ctor,
+		.dtor = _nouveau_devinit_dtor,
+		.init = nv50_devinit_init,
+		.fini = _nouveau_devinit_fini,
+	},
+	.pll_set = nv50_devinit_pll_set,
+	.disable = nv98_devinit_disable,
+}.base;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nva3.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nva3.c
index 67f55940b00e..6dedf1dad7f7 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/nva3.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nva3.c
@@ -24,7 +24,7 @@
 
 #include "nv50.h"
 
-static int
+int
 nva3_devinit_pll_set(struct nouveau_devinit *devinit, u32 type, u32 freq)
 {
 	struct nv50_devinit_priv *priv = (void *)devinit;
@@ -58,6 +58,29 @@ nva3_devinit_pll_set(struct nouveau_devinit *devinit, u32 type, u32 freq)
 	return ret;
 }
 
+static u64
+nva3_devinit_disable(struct nouveau_devinit *devinit)
+{
+	struct nv50_devinit_priv *priv = (void *)devinit;
+	u32 r001540 = nv_rd32(priv, 0x001540);
+	u32 r00154c = nv_rd32(priv, 0x00154c);
+	u64 disable = 0ULL;
+
+	if (!(r001540 &amp; 0x40000000)) {
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_VP);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_PPP);
+	}
+
+	if (!(r00154c &amp; 0x00000004))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_DISP);
+	if (!(r00154c &amp; 0x00000020))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_BSP);
+	if (!(r00154c &amp; 0x00000200))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_COPY0);
+
+	return disable;
+}
+
 struct nouveau_oclass *
 nva3_devinit_oclass = &amp;(struct nouveau_devinit_impl) {
 	.base.handle = NV_SUBDEV(DEVINIT, 0xa3),
@@ -68,4 +91,5 @@ nva3_devinit_oclass = &amp;(struct nouveau_devinit_impl) {
 		.fini = _nouveau_devinit_fini,
 	},
 	.pll_set = nva3_devinit_pll_set,
+	.disable = nva3_devinit_disable,
 }.base;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nvaf.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nvaf.c
new file mode 100644
index 000000000000..4fc68d27eff3
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nvaf.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2013 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include "nv50.h"
+
+static u64
+nvaf_devinit_disable(struct nouveau_devinit *devinit)
+{
+	struct nv50_devinit_priv *priv = (void *)devinit;
+	u32 r001540 = nv_rd32(priv, 0x001540);
+	u32 r00154c = nv_rd32(priv, 0x00154c);
+	u64 disable = 0;
+
+	if (!(r001540 &amp; 0x40000000)) {
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_VP);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_PPP);
+	}
+
+	if (!(r00154c &amp; 0x00000004))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_DISP);
+	if (!(r00154c &amp; 0x00000020))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_BSP);
+	if (!(r00154c &amp; 0x00000040))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_VIC);
+	if (!(r00154c &amp; 0x00000200))
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_COPY0);
+
+	return disable;
+}
+
+struct nouveau_oclass *
+nvaf_devinit_oclass = &amp;(struct nouveau_devinit_impl) {
+	.base.handle = NV_SUBDEV(DEVINIT, 0xaf),
+	.base.ofuncs = &amp;(struct nouveau_ofuncs) {
+		.ctor = nv50_devinit_ctor,
+		.dtor = _nouveau_devinit_dtor,
+		.init = nv50_devinit_init,
+		.fini = _nouveau_devinit_fini,
+	},
+	.pll_set = nva3_devinit_pll_set,
+	.disable = nvaf_devinit_disable,
+}.base;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nvc0.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nvc0.c
index ced0e8241b34..fa7e63766b1b 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/nvc0.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nvc0.c
@@ -59,6 +59,33 @@ nvc0_devinit_pll_set(struct nouveau_devinit *devinit, u32 type, u32 freq)
 	return ret;
 }
 
+static u64
+nvc0_devinit_disable(struct nouveau_devinit *devinit)
+{
+	struct nv50_devinit_priv *priv = (void *)devinit;
+	u32 r022500 = nv_rd32(priv, 0x022500);
+	u64 disable = 0ULL;
+
+	if (r022500 &amp; 0x00000001)
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_DISP);
+
+	if (r022500 &amp; 0x00000002) {
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_VP);
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_PPP);
+	}
+
+	if (r022500 &amp; 0x00000004)
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_BSP);
+	if (r022500 &amp; 0x00000008)
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_VENC);
+	if (r022500 &amp; 0x00000100)
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_COPY0);
+	if (r022500 &amp; 0x00000200)
+		disable |= (1ULL &lt;&lt; NVDEV_ENGINE_COPY1);
+
+	return disable;
+}
+
 static int
 nvc0_devinit_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 		  struct nouveau_oclass *oclass, void *data, u32 size,
@@ -87,4 +114,5 @@ nvc0_devinit_oclass = &amp;(struct nouveau_devinit_impl) {
 		.fini = _nouveau_devinit_fini,
 	},
 	.pll_set = nvc0_devinit_pll_set,
+	.disable = nvc0_devinit_disable,
 }.base;
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h b/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h
index ae8de97ecf16..c4179b6d6eca 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/priv.h
@@ -10,6 +10,7 @@ struct nouveau_devinit_impl {
 	struct nouveau_oclass base;
 	void (*meminit)(struct nouveau_devinit *);
 	int  (*pll_set)(struct nouveau_devinit *, u32 type, u32 freq);
+	u64  (*disable)(struct nouveau_devinit *);
 };
 
 #define nouveau_devinit_create(p,e,o,d)                                        \</pre><hr><pre>commit f0d13e3a851ef29691076d89ff7ee69f004037a7
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Thu Jan 9 21:19:11 2014 -0500

    drm/nouveau/device: provide a way for devinit to mark engines as disabled
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/core/engine.c b/drivers/gpu/drm/nouveau/core/core/engine.c
index c8bed4a26833..1f6954ae9dd3 100644
--- a/drivers/gpu/drm/nouveau/core/core/engine.c
+++ b/drivers/gpu/drm/nouveau/core/core/engine.c
@@ -42,11 +42,24 @@ nouveau_engine_create_(struct nouveau_object *parent,
 	if (ret)
 		return ret;
 
-	if ( parent &amp;&amp;
-	    !nouveau_boolopt(nv_device(parent)-&gt;cfgopt, iname, enable)) {
-		if (!enable)
-			nv_warn(engine, "disabled, %s=1 to enable\n", iname);
-		return -ENODEV;
+	if (parent) {
+		struct nouveau_device *device = nv_device(parent);
+		int engidx = nv_engidx(nv_object(engine));
+
+		if (device-&gt;disable_mask &amp; (1ULL &lt;&lt; engidx)) {
+			if (!nouveau_boolopt(device-&gt;cfgopt, iname, false)) {
+				nv_debug(engine, "engine disabled by hw/fw\n");
+				return -ENODEV;
+			}
+
+			nv_warn(engine, "ignoring hw/fw engine disable\n");
+		}
+
+		if (!nouveau_boolopt(device-&gt;cfgopt, iname, enable)) {
+			if (!enable)
+				nv_warn(engine, "disabled, %s=1 to enable\n", iname);
+			return -ENODEV;
+		}
 	}
 
 	INIT_LIST_HEAD(&amp;engine-&gt;contexts);
diff --git a/drivers/gpu/drm/nouveau/core/include/core/device.h b/drivers/gpu/drm/nouveau/core/include/core/device.h
index 24809c10b4b3..7b8ea221b00d 100644
--- a/drivers/gpu/drm/nouveau/core/include/core/device.h
+++ b/drivers/gpu/drm/nouveau/core/include/core/device.h
@@ -71,6 +71,7 @@ struct nouveau_device {
 	const char *dbgopt;
 	const char *name;
 	const char *cname;
+	u64 disable_mask;
 
 	enum {
 		NV_04    = 0x04,</pre><hr><pre>commit 90d6db1635d5e225623af2e2e859feb607345287
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Dec 7 11:42:19 2013 -0500

    drm/nouveau/falcon: use vmalloc to create firwmare copies
    
    Some firmware images may be large (64K), so using kmalloc memory is
    inappropriate for them. Use vmalloc instead, to avoid high-order
    allocation failures.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/core/engine/falcon.c b/drivers/gpu/drm/nouveau/core/engine/falcon.c
index e03fc8e4dc1d..5e077e4ed7f6 100644
--- a/drivers/gpu/drm/nouveau/core/engine/falcon.c
+++ b/drivers/gpu/drm/nouveau/core/engine/falcon.c
@@ -56,6 +56,16 @@ _nouveau_falcon_wr32(struct nouveau_object *object, u64 addr, u32 data)
 	nv_wr32(falcon, falcon-&gt;addr + addr, data);
 }
 
+static void *
+vmemdup(const void *src, size_t len)
+{
+	void *p = vmalloc(len);
+
+	if (p)
+		memcpy(p, src, len);
+	return p;
+}
+
 int
 _nouveau_falcon_init(struct nouveau_object *object)
 {
@@ -111,7 +121,7 @@ _nouveau_falcon_init(struct nouveau_object *object)
 
 		ret = request_firmware(&amp;fw, name, &amp;device-&gt;pdev-&gt;dev);
 		if (ret == 0) {
-			falcon-&gt;code.data = kmemdup(fw-&gt;data, fw-&gt;size, GFP_KERNEL);
+			falcon-&gt;code.data = vmemdup(fw-&gt;data, fw-&gt;size);
 			falcon-&gt;code.size = fw-&gt;size;
 			falcon-&gt;data.data = NULL;
 			falcon-&gt;data.size = 0;
@@ -134,7 +144,7 @@ _nouveau_falcon_init(struct nouveau_object *object)
 			return ret;
 		}
 
-		falcon-&gt;data.data = kmemdup(fw-&gt;data, fw-&gt;size, GFP_KERNEL);
+		falcon-&gt;data.data = vmemdup(fw-&gt;data, fw-&gt;size);
 		falcon-&gt;data.size = fw-&gt;size;
 		release_firmware(fw);
 		if (!falcon-&gt;data.data)
@@ -149,7 +159,7 @@ _nouveau_falcon_init(struct nouveau_object *object)
 			return ret;
 		}
 
-		falcon-&gt;code.data = kmemdup(fw-&gt;data, fw-&gt;size, GFP_KERNEL);
+		falcon-&gt;code.data = vmemdup(fw-&gt;data, fw-&gt;size);
 		falcon-&gt;code.size = fw-&gt;size;
 		release_firmware(fw);
 		if (!falcon-&gt;code.data)
@@ -235,8 +245,8 @@ _nouveau_falcon_fini(struct nouveau_object *object, bool suspend)
 	if (!suspend) {
 		nouveau_gpuobj_ref(NULL, &amp;falcon-&gt;core);
 		if (falcon-&gt;external) {
-			kfree(falcon-&gt;data.data);
-			kfree(falcon-&gt;code.data);
+			vfree(falcon-&gt;data.data);
+			vfree(falcon-&gt;code.data);
 			falcon-&gt;code.data = NULL;
 		}
 	}</pre><hr><pre>commit ab9b18a6a13c438505d3419bd59dcd8e1856cedd
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Fri Nov 15 11:26:45 2013 -0500

    drm/nv04/plane: add support for nv04/nv05 video overlay
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv04/overlay.c b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
index ba40c7be3787..ab03f7719d2d 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/overlay.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
@@ -55,6 +55,8 @@ struct nouveau_plane {
 	int hue;
 	int saturation;
 	int iturbt_709;
+
+	void (*set_params)(struct nouveau_plane *);
 };
 
 static uint32_t formats[] = {
@@ -183,9 +185,9 @@ nv10_disable_plane(struct drm_plane *plane)
 }
 
 static void
-nv10_destroy_plane(struct drm_plane *plane)
+nv_destroy_plane(struct drm_plane *plane)
 {
-	nv10_disable_plane(plane);
+	plane-&gt;funcs-&gt;disable_plane(plane);
 	drm_plane_cleanup(plane);
 	kfree(plane);
 }
@@ -218,9 +220,9 @@ nv10_set_params(struct nouveau_plane *plane)
 }
 
 static int
-nv10_set_property(struct drm_plane *plane,
-		  struct drm_property *property,
-		  uint64_t value)
+nv_set_property(struct drm_plane *plane,
+		struct drm_property *property,
+		uint64_t value)
 {
 	struct nouveau_plane *nv_plane = (struct nouveau_plane *)plane;
 
@@ -239,15 +241,16 @@ nv10_set_property(struct drm_plane *plane,
 	else
 		return -EINVAL;
 
-	nv10_set_params(nv_plane);
+	if (nv_plane-&gt;set_params)
+		nv_plane-&gt;set_params(nv_plane);
 	return 0;
 }
 
 static const struct drm_plane_funcs nv10_plane_funcs = {
 	.update_plane = nv10_update_plane,
 	.disable_plane = nv10_disable_plane,
-	.set_property = nv10_set_property,
-	.destroy = nv10_destroy_plane,
+	.set_property = nv_set_property,
+	.destroy = nv_destroy_plane,
 };
 
 static void
@@ -322,8 +325,159 @@ nv10_overlay_init(struct drm_device *device)
 	drm_object_attach_property(&amp;plane-&gt;base.base,
 				   plane-&gt;props.iturbt_709, plane-&gt;iturbt_709);
 
+	plane-&gt;set_params = nv10_set_params;
 	nv10_set_params(plane);
-	nv_wr32(dev, NV_PVIDEO_STOP, 1);
+	nv10_disable_plane(&amp;plane-&gt;base);
+	return;
+cleanup:
+	drm_plane_cleanup(&amp;plane-&gt;base);
+err:
+	kfree(plane);
+	nv_error(dev, "Failed to create plane\n");
+}
+
+static int
+nv04_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
+		  struct drm_framebuffer *fb, int crtc_x, int crtc_y,
+		  unsigned int crtc_w, unsigned int crtc_h,
+		  uint32_t src_x, uint32_t src_y,
+		  uint32_t src_w, uint32_t src_h)
+{
+	struct nouveau_device *dev = nouveau_dev(plane-&gt;dev);
+	struct nouveau_plane *nv_plane = (struct nouveau_plane *)plane;
+	struct nouveau_framebuffer *nv_fb = nouveau_framebuffer(fb);
+	struct nouveau_bo *cur = nv_plane-&gt;cur;
+	uint32_t overlay = 1;
+	int brightness = (nv_plane-&gt;brightness - 512) * 62 / 512;
+	int pitch, ret, i;
+
+	/* Source parameters given in 16.16 fixed point, ignore fractional. */
+	src_x &gt;&gt;= 16;
+	src_y &gt;&gt;= 16;
+	src_w &gt;&gt;= 16;
+	src_h &gt;&gt;= 16;
+
+	pitch = ALIGN(src_w * 4, 0x100);
+
+	if (pitch &gt; 0xffff)
+		return -ERANGE;
+
+	/* TODO: Compute an offset? Not sure how to do this for YUYV. */
+	if (src_x != 0 || src_y != 0)
+		return -ERANGE;
+
+	if (crtc_w &lt; src_w || crtc_h &lt; src_h)
+		return -ERANGE;
+
+	ret = nouveau_bo_pin(nv_fb-&gt;nvbo, TTM_PL_FLAG_VRAM);
+	if (ret)
+		return ret;
+
+	nv_plane-&gt;cur = nv_fb-&gt;nvbo;
+
+	nv_wr32(dev, NV_PVIDEO_OE_STATE, 0);
+	nv_wr32(dev, NV_PVIDEO_SU_STATE, 0);
+	nv_wr32(dev, NV_PVIDEO_RM_STATE, 0);
+
+	for (i = 0; i &lt; 2; i++) {
+		nv_wr32(dev, NV_PVIDEO_BUFF0_START_ADDRESS + 4 * i,
+			nv_fb-&gt;nvbo-&gt;bo.offset);
+		nv_wr32(dev, NV_PVIDEO_BUFF0_PITCH_LENGTH + 4 * i, pitch);
+		nv_wr32(dev, NV_PVIDEO_BUFF0_OFFSET + 4 * i, 0);
+	}
+	nv_wr32(dev, NV_PVIDEO_WINDOW_START, crtc_y &lt;&lt; 16 | crtc_x);
+	nv_wr32(dev, NV_PVIDEO_WINDOW_SIZE, crtc_h &lt;&lt; 16 | crtc_w);
+	nv_wr32(dev, NV_PVIDEO_STEP_SIZE,
+		(uint32_t)(((src_h - 1) &lt;&lt; 11) / (crtc_h - 1)) &lt;&lt; 16 | (uint32_t)(((src_w - 1) &lt;&lt; 11) / (crtc_w - 1)));
+
+	/* It should be possible to convert hue/contrast to this */
+	nv_wr32(dev, NV_PVIDEO_RED_CSC_OFFSET, 0x69 - brightness);
+	nv_wr32(dev, NV_PVIDEO_GREEN_CSC_OFFSET, 0x3e + brightness);
+	nv_wr32(dev, NV_PVIDEO_BLUE_CSC_OFFSET, 0x89 - brightness);
+	nv_wr32(dev, NV_PVIDEO_CSC_ADJUST, 0);
+
+	nv_wr32(dev, NV_PVIDEO_CONTROL_Y, 0x001); /* (BLUR_ON, LINE_HALF) */
+	nv_wr32(dev, NV_PVIDEO_CONTROL_X, 0x111); /* (WEIGHT_HEAVY, SHARPENING_ON, SMOOTHING_ON) */
+
+	nv_wr32(dev, NV_PVIDEO_FIFO_BURST_LENGTH, 0x03);
+	nv_wr32(dev, NV_PVIDEO_FIFO_THRES_SIZE, 0x38);
+
+	nv_wr32(dev, NV_PVIDEO_KEY, nv_plane-&gt;colorkey);
+
+	if (nv_plane-&gt;colorkey &amp; (1 &lt;&lt; 24))
+		overlay |= 0x10;
+	if (fb-&gt;pixel_format == DRM_FORMAT_YUYV)
+		overlay |= 0x100;
+
+	nv_wr32(dev, NV_PVIDEO_OVERLAY, overlay);
+
+	nv_wr32(dev, NV_PVIDEO_SU_STATE, nv_rd32(dev, NV_PVIDEO_SU_STATE) ^ (1 &lt;&lt; 16));
+
+	if (cur)
+		nouveau_bo_unpin(cur);
+
+	return 0;
+}
+
+static int
+nv04_disable_plane(struct drm_plane *plane)
+{
+	struct nouveau_device *dev = nouveau_dev(plane-&gt;dev);
+	struct nouveau_plane *nv_plane = (struct nouveau_plane *)plane;
+
+	nv_mask(dev, NV_PVIDEO_OVERLAY, 1, 0);
+	nv_wr32(dev, NV_PVIDEO_OE_STATE, 0);
+	nv_wr32(dev, NV_PVIDEO_SU_STATE, 0);
+	nv_wr32(dev, NV_PVIDEO_RM_STATE, 0);
+	if (nv_plane-&gt;cur) {
+		nouveau_bo_unpin(nv_plane-&gt;cur);
+		nv_plane-&gt;cur = NULL;
+	}
+
+	return 0;
+}
+
+static const struct drm_plane_funcs nv04_plane_funcs = {
+	.update_plane = nv04_update_plane,
+	.disable_plane = nv04_disable_plane,
+	.set_property = nv_set_property,
+	.destroy = nv_destroy_plane,
+};
+
+static void
+nv04_overlay_init(struct drm_device *device)
+{
+	struct nouveau_device *dev = nouveau_dev(device);
+	struct nouveau_plane *plane = kzalloc(sizeof(struct nouveau_plane), GFP_KERNEL);
+	int ret;
+
+	if (!plane)
+		return;
+
+	ret = drm_plane_init(device, &amp;plane-&gt;base, 1 /* single crtc */,
+			     &amp;nv04_plane_funcs,
+			     formats, 2, false);
+	if (ret)
+		goto err;
+
+	/* Set up the plane properties */
+	plane-&gt;props.colorkey = drm_property_create_range(
+			device, 0, "colorkey", 0, 0x01ffffff);
+	plane-&gt;props.brightness = drm_property_create_range(
+			device, 0, "brightness", 0, 1024);
+	if (!plane-&gt;props.colorkey ||
+	    !plane-&gt;props.brightness)
+		goto cleanup;
+
+	plane-&gt;colorkey = 0;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.colorkey, plane-&gt;colorkey);
+
+	plane-&gt;brightness = 512;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.brightness, plane-&gt;brightness);
+
+	nv04_disable_plane(&amp;plane-&gt;base);
 	return;
 cleanup:
 	drm_plane_cleanup(&amp;plane-&gt;base);
@@ -336,6 +490,8 @@ void
 nouveau_overlay_init(struct drm_device *device)
 {
 	struct nouveau_device *dev = nouveau_dev(device);
-	if (dev-&gt;chipset &gt;= 0x10 &amp;&amp; dev-&gt;chipset &lt;= 0x40)
+	if (dev-&gt;chipset &lt; 0x10)
+		nv04_overlay_init(device);
+	else if (dev-&gt;chipset &lt;= 0x40)
 		nv10_overlay_init(device);
 }</pre><hr><pre>commit 7ffb078172d6906c4712914321c551d4f595875f
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Fri Nov 15 11:26:44 2013 -0500

    drm/nv10/plane: add YUYV support
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv04/overlay.c b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
index 32e7064b819b..ba40c7be3787 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/overlay.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
@@ -58,6 +58,7 @@ struct nouveau_plane {
 };
 
 static uint32_t formats[] = {
+	DRM_FORMAT_YUYV,
 	DRM_FORMAT_UYVY,
 	DRM_FORMAT_NV12,
 };
@@ -140,10 +141,10 @@ nv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 	nv_wr32(dev, NV_PVIDEO_POINT_OUT(flip), crtc_y &lt;&lt; 16 | crtc_x);
 	nv_wr32(dev, NV_PVIDEO_SIZE_OUT(flip), crtc_h &lt;&lt; 16 | crtc_w);
 
-	if (fb-&gt;pixel_format == DRM_FORMAT_NV12) {
+	if (fb-&gt;pixel_format != DRM_FORMAT_UYVY)
 		format |= NV_PVIDEO_FORMAT_COLOR_LE_CR8YB8CB8YA8;
+	if (fb-&gt;pixel_format == DRM_FORMAT_NV12)
 		format |= NV_PVIDEO_FORMAT_PLANAR;
-	}
 	if (nv_plane-&gt;iturbt_709)
 		format |= NV_PVIDEO_FORMAT_MATRIX_ITURBT709;
 	if (nv_plane-&gt;colorkey &amp; (1 &lt;&lt; 24))
@@ -266,7 +267,7 @@ nv10_overlay_init(struct drm_device *device)
 	case 0x15:
 	case 0x1a:
 	case 0x20:
-		num_formats = 1;
+		num_formats = 2;
 		break;
 	}
 </pre>
    <div class="pagination">
        <a href='1_142.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><span>[143]</span><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_144.html'>Next&gt;&gt;</a>
    <div>
</body>
