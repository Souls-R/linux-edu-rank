<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_81.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><span>[82]</span><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_83.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 5126a2674ddac0804450f59da25a058cca629d38
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 23 12:02:05 2009 -0500

    USB: usb-storage: add IGNORE_RESIDUE flag for Genesys Logic adapters
    
    This patch (as1219) adds the IGNORE_RESIDUE flag to the unusual_devs
    entries for Genesys Logic's USB-IDE adapter.  Although this device
    usually gets the residue correct, there is one command crucial to the
    operation of CD and DVD drives which it messes up.
    
    Tested-by: Mike Lampard &lt;mike@mtgambier.net&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 50dc33a6065b..6f59c8e510ea 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -907,13 +907,13 @@ UNUSUAL_DEV(  0x05e3, 0x0701, 0x0000, 0xffff,
 		"Genesys Logic",
 		"USB to IDE Optical",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_GO_SLOW | US_FL_MAX_SECTORS_64 ),
+		US_FL_GO_SLOW | US_FL_MAX_SECTORS_64 | US_FL_IGNORE_RESIDUE ),
 
 UNUSUAL_DEV(  0x05e3, 0x0702, 0x0000, 0xffff,
 		"Genesys Logic",
 		"USB to IDE Disk",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_GO_SLOW | US_FL_MAX_SECTORS_64 ),
+		US_FL_GO_SLOW | US_FL_MAX_SECTORS_64 | US_FL_IGNORE_RESIDUE ),
 
 /* Reported by Ben Efros &lt;ben@pc-doctor.com&gt; */
 UNUSUAL_DEV(  0x05e3, 0x0723, 0x9451, 0x9451,</pre><hr><pre>commit 506e9469833c66ed6bb9acd902e208f7301b6adb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Feb 4 15:48:03 2009 -0500

    USB: usb-storage: add Pentax to the bad-vendor list
    
    This patch (as1202) adds Pentax to usb-storage's list of bad vendors
    whose devices always need the CAPACITY_HEURISTICS flag.  This is in
    addition to the existing entries: Nokia, Nikon, and Motorola.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Virgo PÃ¤rna &lt;virgo.parna@mail.ee&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 2a42b862aa9f..727c506417cc 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -64,6 +64,7 @@
  */
 #define VENDOR_ID_NOKIA		0x0421
 #define VENDOR_ID_NIKON		0x04b0
+#define VENDOR_ID_PENTAX	0x0a17
 #define VENDOR_ID_MOTOROLA	0x22b8
 
 /***********************************************************************
@@ -158,6 +159,7 @@ static int slave_configure(struct scsi_device *sdev)
 		switch (le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idVendor)) {
 		case VENDOR_ID_NOKIA:
 		case VENDOR_ID_NIKON:
+		case VENDOR_ID_PENTAX:
 		case VENDOR_ID_MOTOROLA:
 			if (!(us-&gt;fflags &amp; (US_FL_FIX_CAPACITY |
 					US_FL_CAPACITY_OK)))
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 69269f739563..8e878cab8dc7 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1354,21 +1354,6 @@ UNUSUAL_DEV( 0x0a17, 0x0004, 0x1000, 0x1000,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
 
-
-/* Submitted by Per Winkvist &lt;per.winkvist@uk.com&gt; */
-UNUSUAL_DEV( 0x0a17, 0x006, 0x0000, 0xffff,
-		"Pentax",
-		"Optio S/S4",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_INQUIRY ),
-
-/* Reported by Jaak Ristioja &lt;Ristioja@gmail.com&gt; */
-UNUSUAL_DEV( 0x0a17, 0x006e, 0x0100, 0x0100,
-		"Pentax",
-		"K10D",
-		US_SC_DEVICE, US_PR_DEVICE, NULL,
-		US_FL_FIX_CAPACITY ),
-
 /* These are virtual windows driver CDs, which the zd1211rw driver
  * automatically converts into WLAN devices. */
 UNUSUAL_DEV( 0x0ace, 0x2011, 0x0101, 0x0101,</pre><hr><pre>commit 0d020aae0a154cffce680a7775c74788fa0bea92
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 2 09:51:01 2009 -0500

    USB: usb-storage: remove WARN from last-sector hacks
    
    This patch (as1201) removes the WARN() from the last-sector hacks in
    usb-storage, thereby making the code match the version now in
    .27-stable and .28-stable.  The WARN() isn't needed, since there is no
    longer any intention of assuming that all storage devices have an even
    number of sectors, and it annoys users for no good reason.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 1d5438e6363b..fb65d221cedf 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -558,32 +558,10 @@ static void last_sector_hacks(struct us_data *us, struct scsi_cmnd *srb)
 
 	if (srb-&gt;result == SAM_STAT_GOOD &amp;&amp; scsi_get_resid(srb) == 0) {
 
-		/* The command succeeded.  If the capacity is odd
-		 * (i.e., if the sector number is even) then the
-		 * "always-even" heuristic would be wrong for this
-		 * device.  Issue a WARN() so that the kerneloops.org
-		 * project will be notified and we will then know to
-		 * mark the device with a CAPACITY_OK flag.  Hopefully
-		 * this will occur for only a few devices.
-		 *
-		 * Use the sign of us-&gt;last_sector_hacks to tell whether
-		 * the warning has already been issued; we don't need
-		 * more than one warning per device.
+		/* The command succeeded.  We know this device doesn't
+		 * have the last-sector bug, so stop checking it.
 		 */
-		if (!(sector &amp; 1) &amp;&amp; us-&gt;use_last_sector_hacks &gt; 0) {
-			unsigned vid = le16_to_cpu(
-					us-&gt;pusb_dev-&gt;descriptor.idVendor);
-			unsigned pid = le16_to_cpu(
-					us-&gt;pusb_dev-&gt;descriptor.idProduct);
-			unsigned rev = le16_to_cpu(
-					us-&gt;pusb_dev-&gt;descriptor.bcdDevice);
-
-			WARN(1, "%s: Successful last sector success at %u, "
-					"device %04x:%04x:%04x\n",
-					sdkp-&gt;disk-&gt;disk_name, sector,
-					vid, pid, rev);
-			us-&gt;use_last_sector_hacks = -1;
-		}
+		us-&gt;use_last_sector_hacks = 0;
 
 	} else {
 		/* The command failed.  Allow up to 3 retries in case this
@@ -599,14 +577,6 @@ static void last_sector_hacks(struct us_data *us, struct scsi_cmnd *srb)
 		srb-&gt;result = SAM_STAT_CHECK_CONDITION;
 		memcpy(srb-&gt;sense_buffer, record_not_found,
 				sizeof(record_not_found));
-
-		/* In theory we might want to issue a WARN() here if the
-		 * capacity is even, since it could indicate the device
-		 * has the READ CAPACITY bug _and_ the real capacity is
-		 * odd.  But it could also indicate that the device
-		 * simply can't access its last sector, a failure mode
-		 * which is surprisingly common.  So no warning.
-		 */
 	}
 
  done:</pre><hr><pre>commit 501950d846218ed80a776d2aae5aed9c8b92e778
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 13 11:33:42 2009 -0500

    USB: fix char-device disconnect handling
    
    This patch (as1198) fixes a conceptual bug: Somewhere along the line
    we managed to confuse USB class devices with USB char devices.  As a
    result, the code to send a disconnect signal to userspace would not be
    built if both CONFIG_USB_DEVICE_CLASS and CONFIG_USB_DEVICEFS were
    disabled.
    
    The usb_fs_classdev_common_remove() routine has been renamed to
    usbdev_remove() and it is now called whenever any USB device is
    removed, not just when a class device is unregistered.  The notifier
    registration and unregistration calls are no longer conditionally
    compiled.  And since the common removal code will always be called as
    part of the char device interface, there's no need to call it again as
    part of the usbfs interface; thus the invocation of
    usb_fs_classdev_common_remove() has been taken out of
    usbfs_remove_device().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
    Tested-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 26fece124e0e..7513bb083c15 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1700,7 +1700,7 @@ const struct file_operations usbdev_file_operations = {
 	.release =	usbdev_release,
 };
 
-void usb_fs_classdev_common_remove(struct usb_device *udev)
+static void usbdev_remove(struct usb_device *udev)
 {
 	struct dev_state *ps;
 	struct siginfo sinfo;
@@ -1742,10 +1742,15 @@ static void usb_classdev_remove(struct usb_device *dev)
 {
 	if (dev-&gt;usb_classdev)
 		device_unregister(dev-&gt;usb_classdev);
-	usb_fs_classdev_common_remove(dev);
 }
 
-static int usb_classdev_notify(struct notifier_block *self,
+#else
+#define usb_classdev_add(dev)		0
+#define usb_classdev_remove(dev)	do {} while (0)
+
+#endif
+
+static int usbdev_notify(struct notifier_block *self,
 			       unsigned long action, void *dev)
 {
 	switch (action) {
@@ -1755,15 +1760,15 @@ static int usb_classdev_notify(struct notifier_block *self,
 		break;
 	case USB_DEVICE_REMOVE:
 		usb_classdev_remove(dev);
+		usbdev_remove(dev);
 		break;
 	}
 	return NOTIFY_OK;
 }
 
 static struct notifier_block usbdev_nb = {
-	.notifier_call = 	usb_classdev_notify,
+	.notifier_call = 	usbdev_notify,
 };
-#endif
 
 static struct cdev usb_device_cdev;
 
@@ -1798,9 +1803,8 @@ int __init usb_devio_init(void)
 	 * to /sys/dev
 	 */
 	usb_classdev_class-&gt;dev_kobj = NULL;
-
-	usb_register_notify(&amp;usbdev_nb);
 #endif
+	usb_register_notify(&amp;usbdev_nb);
 out:
 	return retval;
 
@@ -1811,8 +1815,8 @@ int __init usb_devio_init(void)
 
 void usb_devio_cleanup(void)
 {
-#ifdef CONFIG_USB_DEVICE_CLASS
 	usb_unregister_notify(&amp;usbdev_nb);
+#ifdef CONFIG_USB_DEVICE_CLASS
 	class_destroy(usb_classdev_class);
 #endif
 	cdev_del(&amp;usb_device_cdev);
diff --git a/drivers/usb/core/inode.c b/drivers/usb/core/inode.c
index 2a129cb7bb56..dff5760a37f6 100644
--- a/drivers/usb/core/inode.c
+++ b/drivers/usb/core/inode.c
@@ -717,7 +717,6 @@ static void usbfs_remove_device(struct usb_device *dev)
 		fs_remove_file (dev-&gt;usbfs_dentry);
 		dev-&gt;usbfs_dentry = NULL;
 	}
-	usb_fs_classdev_common_remove(dev);
 }
 
 static int usbfs_notify(struct notifier_block *self, unsigned long action, void *dev)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 9d0f33fe8719..79d8a9ea559b 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -152,7 +152,6 @@ extern struct usb_driver usbfs_driver;
 extern const struct file_operations usbfs_devices_fops;
 extern const struct file_operations usbdev_file_operations;
 extern void usbfs_conn_disc_event(void);
-extern void usb_fs_classdev_common_remove(struct usb_device *udev);
 
 extern int usb_devio_init(void);
 extern void usb_devio_cleanup(void);</pre><hr><pre>commit bcca06efea883bdf3803a0bb0ffa60f26730387d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 13 11:35:54 2009 -0500

    USB: don't enable wakeup by default for PCI host controllers
    
    This patch (as1199) changes the initial wakeup settings for PCI USB
    host controllers.  The controllers are marked as capable of waking the
    system, but wakeup is not enabled by default.
    
    It turns out that enabling wakeup for USB host controllers has a lot
    of bad consequences.  As the simplest example, if a USB mouse or
    keyboard is unplugged immediately after the computer is put to sleep,
    the unplug will cause the system to wake back up again!  We are better
    off marking them as wakeup-capable and leaving wakeup disabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 507741ed4482..99432785f438 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -128,7 +128,6 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	}
 
 	pci_set_master(dev);
-	device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
 
 	retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index bdc6e86e1f8b..9faa5c8fe025 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -230,7 +230,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 		pci_read_config_word(pdev, 0x62, &amp;port_wake);
 		if (port_wake &amp; 0x0001) {
 			dev_warn(&amp;pdev-&gt;dev, "Enabling legacy PCI PM\n");
-			device_init_wakeup(&amp;pdev-&gt;dev, 1);
+			device_set_wakeup_capable(&amp;pdev-&gt;dev, 1);
 		}
 	}
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 65a9609f4ad6..5cf5f1eca4f4 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -593,12 +593,10 @@ static int ohci_run (struct ohci_hcd *ohci)
 	 * to be checked in case boot firmware (BIOS/SMM/...) has set up
 	 * wakeup in a way the bus isn't aware of (e.g., legacy PCI PM).
 	 * If the bus glue detected wakeup capability then it should
-	 * already be enabled.  Either way, if wakeup should be enabled
-	 * but isn't, we'll enable it now.
+	 * already be enabled; if so we'll just enable it again.
 	 */
-	if ((ohci-&gt;hc_control &amp; OHCI_CTRL_RWC) != 0
-			&amp;&amp; !device_can_wakeup(hcd-&gt;self.controller))
-		device_init_wakeup(hcd-&gt;self.controller, 1);
+	if ((ohci-&gt;hc_control &amp; OHCI_CTRL_RWC) != 0)
+		device_set_wakeup_capable(hcd-&gt;self.controller, 1);
 
 	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
 	case OHCI_USB_OPER:</pre><hr><pre>commit ddeac4e75f2527a340f9dc655bde49bb2429b39b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 15 17:03:33 2009 -0500

    USB: fix toggle mismatch in disable_endpoint paths
    
    This patch (as1200) finishes some fixes that were left incomplete by
    an earlier patch.
    
    Although nobody has addressed this issue in the past, it turns out
    that we need to distinguish between two different modes of disabling
    and enabling endpoints.  In one mode only the data structures in
    usbcore are affected, and in the other mode the host controller and
    device hardware states are affected as well.
    
    The earlier patch added an extra argument to the routines in the
    enable_endpoint pathways to reflect this difference.  This patch adds
    corresponding arguments to the disable_endpoint pathways.  Without
    this change, the endpoint toggle state can get out of sync between
    the host and the device.  The exact mechanism depends on the details
    of the host controller (whether or not it stores its own copy of the
    toggle values).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Dan Streetman &lt;ddstreet@ieee.org&gt;
    Tested-by: Dan Streetman &lt;ddstreet@ieee.org&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 98760553bc95..d0a21a5f8201 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -284,7 +284,7 @@ static int usb_unbind_interface(struct device *dev)
 	 * supports "soft" unbinding.
 	 */
 	if (!driver-&gt;soft_unbind)
-		usb_disable_interface(udev, intf);
+		usb_disable_interface(udev, intf, false);
 
 	driver-&gt;disconnect(intf);
 	usb_cancel_queued_reset(intf);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 94d5ee263c20..cd50d86029e7 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2382,8 +2382,8 @@ static int hub_port_debounce(struct usb_hub *hub, int port1)
 
 void usb_ep0_reinit(struct usb_device *udev)
 {
-	usb_disable_endpoint(udev, 0 + USB_DIR_IN);
-	usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
+	usb_disable_endpoint(udev, 0 + USB_DIR_IN, true);
+	usb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);
 	usb_enable_endpoint(udev, &amp;udev-&gt;ep0, true);
 }
 EXPORT_SYMBOL_GPL(usb_ep0_reinit);
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index de51667dd64d..31fb204f44c6 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1039,14 +1039,15 @@ static void remove_intf_ep_devs(struct usb_interface *intf)
  * @dev: the device whose endpoint is being disabled
  * @epaddr: the endpoint's address.  Endpoint number for output,
  *	endpoint number + USB_DIR_IN for input
+ * @reset_hardware: flag to erase any endpoint state stored in the
+ *	controller hardware
  *
- * Deallocates hcd/hardware state for this endpoint ... and nukes all
- * pending urbs.
- *
- * If the HCD hasn't registered a disable() function, this sets the
- * endpoint's maxpacket size to 0 to prevent further submissions.
+ * Disables the endpoint for URB submission and nukes all pending URBs.
+ * If @reset_hardware is set then also deallocates hcd/hardware state
+ * for the endpoint.
  */
-void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
+void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,
+		bool reset_hardware)
 {
 	unsigned int epnum = epaddr &amp; USB_ENDPOINT_NUMBER_MASK;
 	struct usb_host_endpoint *ep;
@@ -1056,15 +1057,18 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 
 	if (usb_endpoint_out(epaddr)) {
 		ep = dev-&gt;ep_out[epnum];
-		dev-&gt;ep_out[epnum] = NULL;
+		if (reset_hardware)
+			dev-&gt;ep_out[epnum] = NULL;
 	} else {
 		ep = dev-&gt;ep_in[epnum];
-		dev-&gt;ep_in[epnum] = NULL;
+		if (reset_hardware)
+			dev-&gt;ep_in[epnum] = NULL;
 	}
 	if (ep) {
 		ep-&gt;enabled = 0;
 		usb_hcd_flush_endpoint(dev, ep);
-		usb_hcd_disable_endpoint(dev, ep);
+		if (reset_hardware)
+			usb_hcd_disable_endpoint(dev, ep);
 	}
 }
 
@@ -1072,17 +1076,21 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
  * usb_disable_interface -- Disable all endpoints for an interface
  * @dev: the device whose interface is being disabled
  * @intf: pointer to the interface descriptor
+ * @reset_hardware: flag to erase any endpoint state stored in the
+ *	controller hardware
  *
  * Disables all the endpoints for the interface's current altsetting.
  */
-void usb_disable_interface(struct usb_device *dev, struct usb_interface *intf)
+void usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,
+		bool reset_hardware)
 {
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int i;
 
 	for (i = 0; i &lt; alt-&gt;desc.bNumEndpoints; ++i) {
 		usb_disable_endpoint(dev,
-				alt-&gt;endpoint[i].desc.bEndpointAddress);
+				alt-&gt;endpoint[i].desc.bEndpointAddress,
+				reset_hardware);
 	}
 }
 
@@ -1103,8 +1111,8 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 	dev_dbg(&amp;dev-&gt;dev, "%s nuking %s URBs\n", __func__,
 		skip_ep0 ? "non-ep0" : "all");
 	for (i = skip_ep0; i &lt; 16; ++i) {
-		usb_disable_endpoint(dev, i);
-		usb_disable_endpoint(dev, i + USB_DIR_IN);
+		usb_disable_endpoint(dev, i, true);
+		usb_disable_endpoint(dev, i + USB_DIR_IN, true);
 	}
 	dev-&gt;toggle[0] = dev-&gt;toggle[1] = 0;
 
@@ -1274,7 +1282,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 		remove_intf_ep_devs(iface);
 		usb_remove_sysfs_intf_files(iface);
 	}
-	usb_disable_interface(dev, iface);
+	usb_disable_interface(dev, iface, true);
 
 	iface-&gt;cur_altsetting = alt;
 
@@ -1353,8 +1361,8 @@ int usb_reset_configuration(struct usb_device *dev)
 	 */
 
 	for (i = 1; i &lt; 16; ++i) {
-		usb_disable_endpoint(dev, i);
-		usb_disable_endpoint(dev, i + USB_DIR_IN);
+		usb_disable_endpoint(dev, i, true);
+		usb_disable_endpoint(dev, i + USB_DIR_IN, true);
 	}
 
 	config = dev-&gt;actconfig;
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 386177867a8a..9d0f33fe8719 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -15,9 +15,10 @@ extern void usb_enable_endpoint(struct usb_device *dev,
 		struct usb_host_endpoint *ep, bool reset_toggle);
 extern void usb_enable_interface(struct usb_device *dev,
 		struct usb_interface *intf, bool reset_toggles);
-extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr);
+extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,
+		bool reset_hardware);
 extern void usb_disable_interface(struct usb_device *dev,
-		struct usb_interface *intf);
+		struct usb_interface *intf, bool reset_hardware);
 extern void usb_release_interface_cache(struct kref *ref);
 extern void usb_disable_device(struct usb_device *dev, int skip_ep0);
 extern int usb_deauthorize_device(struct usb_device *);</pre><hr><pre>commit bebd590ca27e80ffe3129ab4f0a3124f0a340f43
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 16 14:06:58 2008 -0500

    PCI: fix incorrect error return in pci_enable_wake
    
    This patch (as1186) fixes a minor mistake in pci_enable_wake().  When
    the routine is asked to disable remote wakeup, it should not return an
    error merely because the device is not allowed to do wakeups!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index d4d71fae6233..1fb7cff4cdae 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1091,7 +1091,7 @@ int pci_enable_wake(struct pci_dev *dev, pci_power_t state, int enable)
 	int error = 0;
 	bool pme_done = false;
 
-	if (!device_may_wakeup(&amp;dev-&gt;dev))
+	if (enable &amp;&amp; !device_may_wakeup(&amp;dev-&gt;dev))
 		return -EINVAL;
 
 	/*</pre><hr><pre>commit 2caf7fcdb8532045680f06b67b9e63f0c9613aaa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 31 11:31:33 2008 -0500

    USB: re-enable interface after driver unbinds
    
    This patch (as1197) fixes an error introduced recently.  Since a
    significant number of devices can't handle Set-Interface requests, we
    no longer call usb_set_interface() when a driver unbinds from an
    interface, provided the interface is already in altsetting 0.  However
    the interface still does get disabled, and the call to
    usb_set_interface() was the only thing re-enabling it.  Since the
    interface doesn't get re-enabled, further attempts to use it fail.
    
    So the patch adds a call to usb_enable_interface() when a driver
    unbinds and the interface is in altsetting 0.  For this to work
    right, the interface's endpoints have to be re-enabled but their
    toggles have to be left alone.  Therefore an additional argument is
    added to usb_enable_endpoint() and usb_enable_interface(), a flag
    indicating whether or not the endpoint toggles should be reset.
    
    This is a forward-ported version of a patch which fixes Bugzilla
    #12301.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: David Roka &lt;roka@dawid.hu&gt;
    Reported-by: Erik Ekman &lt;erik@kryo.se&gt;
    Tested-by: Erik Ekman &lt;erik@kryo.se&gt;
    Tested-by: Alon Bar-Lev &lt;alon.barlev@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 41c06025506e..98760553bc95 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -295,9 +295,12 @@ static int usb_unbind_interface(struct device *dev)
 	 * altsetting means creating new endpoint device entries).
 	 * When either of these happens, defer the Set-Interface.
 	 */
-	if (intf-&gt;cur_altsetting-&gt;desc.bAlternateSetting == 0)
-		;	/* Already in altsetting 0 so skip Set-Interface */
-	else if (!error &amp;&amp; intf-&gt;dev.power.status == DPM_ON)
+	if (intf-&gt;cur_altsetting-&gt;desc.bAlternateSetting == 0) {
+		/* Already in altsetting 0 so skip Set-Interface.
+		 * Just re-enable it without affecting the endpoint toggles.
+		 */
+		usb_enable_interface(udev, intf, false);
+	} else if (!error &amp;&amp; intf-&gt;dev.power.status == DPM_ON)
 		usb_set_interface(udev, intf-&gt;altsetting[0].
 				desc.bInterfaceNumber, 0);
 	else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 756b8d9993fc..d5d0e40b1e2d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2384,7 +2384,7 @@ void usb_ep0_reinit(struct usb_device *udev)
 {
 	usb_disable_endpoint(udev, 0 + USB_DIR_IN);
 	usb_disable_endpoint(udev, 0 + USB_DIR_OUT);
-	usb_enable_endpoint(udev, &amp;udev-&gt;ep0);
+	usb_enable_endpoint(udev, &amp;udev-&gt;ep0, true);
 }
 EXPORT_SYMBOL_GPL(usb_ep0_reinit);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 5589686981f1..de51667dd64d 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1143,22 +1143,26 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
  * usb_enable_endpoint - Enable an endpoint for USB communications
  * @dev: the device whose interface is being enabled
  * @ep: the endpoint
+ * @reset_toggle: flag to set the endpoint's toggle back to 0
  *
- * Resets the endpoint toggle, and sets dev-&gt;ep_{in,out} pointers.
+ * Resets the endpoint toggle if asked, and sets dev-&gt;ep_{in,out} pointers.
  * For control endpoints, both the input and output sides are handled.
  */
-void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
+void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep,
+		bool reset_toggle)
 {
 	int epnum = usb_endpoint_num(&amp;ep-&gt;desc);
 	int is_out = usb_endpoint_dir_out(&amp;ep-&gt;desc);
 	int is_control = usb_endpoint_xfer_control(&amp;ep-&gt;desc);
 
 	if (is_out || is_control) {
-		usb_settoggle(dev, epnum, 1, 0);
+		if (reset_toggle)
+			usb_settoggle(dev, epnum, 1, 0);
 		dev-&gt;ep_out[epnum] = ep;
 	}
 	if (!is_out || is_control) {
-		usb_settoggle(dev, epnum, 0, 0);
+		if (reset_toggle)
+			usb_settoggle(dev, epnum, 0, 0);
 		dev-&gt;ep_in[epnum] = ep;
 	}
 	ep-&gt;enabled = 1;
@@ -1168,17 +1172,18 @@ void usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep)
  * usb_enable_interface - Enable all the endpoints for an interface
  * @dev: the device whose interface is being enabled
  * @intf: pointer to the interface descriptor
+ * @reset_toggles: flag to set the endpoints' toggles back to 0
  *
  * Enables all the endpoints for the interface's current altsetting.
  */
-static void usb_enable_interface(struct usb_device *dev,
-				 struct usb_interface *intf)
+void usb_enable_interface(struct usb_device *dev,
+		struct usb_interface *intf, bool reset_toggles)
 {
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int i;
 
 	for (i = 0; i &lt; alt-&gt;desc.bNumEndpoints; ++i)
-		usb_enable_endpoint(dev, &amp;alt-&gt;endpoint[i]);
+		usb_enable_endpoint(dev, &amp;alt-&gt;endpoint[i], reset_toggles);
 }
 
 /**
@@ -1303,7 +1308,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * during the SETUP stage - hence EP0 toggles are "don't care" here.
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
-	usb_enable_interface(dev, iface);
+	usb_enable_interface(dev, iface, true);
 	if (device_is_registered(&amp;iface-&gt;dev)) {
 		usb_create_sysfs_intf_files(iface);
 		create_intf_ep_devs(iface);
@@ -1382,7 +1387,7 @@ int usb_reset_configuration(struct usb_device *dev)
 			usb_remove_sysfs_intf_files(intf);
 		}
 		intf-&gt;cur_altsetting = alt;
-		usb_enable_interface(dev, intf);
+		usb_enable_interface(dev, intf, true);
 		if (device_is_registered(&amp;intf-&gt;dev)) {
 			usb_create_sysfs_intf_files(intf);
 			create_intf_ep_devs(intf);
@@ -1685,7 +1690,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 			alt = &amp;intf-&gt;altsetting[0];
 
 		intf-&gt;cur_altsetting = alt;
-		usb_enable_interface(dev, intf);
+		usb_enable_interface(dev, intf, true);
 		intf-&gt;dev.parent = &amp;dev-&gt;dev;
 		intf-&gt;dev.driver = NULL;
 		intf-&gt;dev.bus = &amp;usb_bus_type;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index c0821564a3fe..dcfc072630c1 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -362,7 +362,7 @@ struct usb_device *usb_alloc_dev(struct usb_device *parent,
 	dev-&gt;ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
 	/* ep0 maxpacket comes later, from device descriptor */
-	usb_enable_endpoint(dev, &amp;dev-&gt;ep0);
+	usb_enable_endpoint(dev, &amp;dev-&gt;ep0, true);
 	dev-&gt;can_submit = 1;
 
 	/* Save readable and stable topology id, distinguishing devices
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 381eae90c3b7..386177867a8a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -12,7 +12,9 @@ extern int usb_create_ep_devs(struct device *parent,
 extern void usb_remove_ep_devs(struct usb_host_endpoint *endpoint);
 
 extern void usb_enable_endpoint(struct usb_device *dev,
-		struct usb_host_endpoint *ep);
+		struct usb_host_endpoint *ep, bool reset_toggle);
+extern void usb_enable_interface(struct usb_device *dev,
+		struct usb_interface *intf, bool reset_toggles);
 extern void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr);
 extern void usb_disable_interface(struct usb_device *dev,
 		struct usb_interface *intf);</pre><hr><pre>commit df718962bf91c7bd345060aadaa24b03f6140b07
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 19 10:27:56 2008 -0500

    USB: cancel pending Set-Config requests if userspace gets there first
    
    This patch (as1195) eliminates a potential problem identified by
    Oliver Neukum.  When a driver queues an asynchronous Set-Config
    request using usb_driver_set_configuration(), the request should be
    cancelled if userspace changes the configuration first.  The patch
    introduces a linked list of pending async Set-Config requests, and
    uses it to invalidate the requests for a particular device whenever
    that device's configuration is set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 7943901c641c..5589686981f1 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -18,6 +18,8 @@
 #include "hcd.h"	/* for usbcore internals */
 #include "usb.h"
 
+static void cancel_async_set_config(struct usb_device *udev);
+
 struct api_context {
 	struct completion	done;
 	int			status;
@@ -1636,6 +1638,9 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (dev-&gt;state != USB_STATE_ADDRESS)
 		usb_disable_device(dev, 1);	/* Skip ep0 */
 
+	/* Get rid of pending async Set-Config requests for this device */
+	cancel_async_set_config(dev);
+
 	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
 			      NULL, 0, USB_CTRL_SET_TIMEOUT);
@@ -1725,10 +1730,14 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	return 0;
 }
 
+static LIST_HEAD(set_config_list);
+static DEFINE_SPINLOCK(set_config_lock);
+
 struct set_config_request {
 	struct usb_device	*udev;
 	int			config;
 	struct work_struct	work;
+	struct list_head	node;
 };
 
 /* Worker routine for usb_driver_set_configuration() */
@@ -1736,14 +1745,35 @@ static void driver_set_config_work(struct work_struct *work)
 {
 	struct set_config_request *req =
 		container_of(work, struct set_config_request, work);
+	struct usb_device *udev = req-&gt;udev;
 
-	usb_lock_device(req-&gt;udev);
-	usb_set_configuration(req-&gt;udev, req-&gt;config);
-	usb_unlock_device(req-&gt;udev);
-	usb_put_dev(req-&gt;udev);
+	usb_lock_device(udev);
+	spin_lock(&amp;set_config_lock);
+	list_del(&amp;req-&gt;node);
+	spin_unlock(&amp;set_config_lock);
+
+	if (req-&gt;config &gt;= -1)		/* Is req still valid? */
+		usb_set_configuration(udev, req-&gt;config);
+	usb_unlock_device(udev);
+	usb_put_dev(udev);
 	kfree(req);
 }
 
+/* Cancel pending Set-Config requests for a device whose configuration
+ * was just changed
+ */
+static void cancel_async_set_config(struct usb_device *udev)
+{
+	struct set_config_request *req;
+
+	spin_lock(&amp;set_config_lock);
+	list_for_each_entry(req, &amp;set_config_list, node) {
+		if (req-&gt;udev == udev)
+			req-&gt;config = -999;	/* Mark as cancelled */
+	}
+	spin_unlock(&amp;set_config_lock);
+}
+
 /**
  * usb_driver_set_configuration - Provide a way for drivers to change device configurations
  * @udev: the device whose configuration is being updated
@@ -1775,6 +1805,10 @@ int usb_driver_set_configuration(struct usb_device *udev, int config)
 	req-&gt;config = config;
 	INIT_WORK(&amp;req-&gt;work, driver_set_config_work);
 
+	spin_lock(&amp;set_config_lock);
+	list_add(&amp;req-&gt;node, &amp;set_config_list);
+	spin_unlock(&amp;set_config_lock);
+
 	usb_get_dev(udev);
 	schedule_work(&amp;req-&gt;work);
 	return 0;</pre><hr><pre>commit 6fd9086a518d4f14213a32fe6c9ac17fabebbc1e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 17 17:20:38 2008 -0500

    USB: automatically enable wakeup for PCI host controllers
    
    This patch (as1193b) enables wakeup during initialization for all PCI
    host controllers, and it removes some code (and comments!) that are no
    longer needed now that the PCI core automatically initializes wakeup
    settings for all new devices.
    
    The idea is that the bus should initialize wakeup, and the bus glue
    or controller driver should enable it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 99432785f438..507741ed4482 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -128,6 +128,7 @@ int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 	}
 
 	pci_set_master(dev);
+	device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
 
 	retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6af47a0937b8..bdc6e86e1f8b 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -219,15 +219,19 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	pci_read_config_byte(pdev, 0x60, &amp;ehci-&gt;sbrn);
 
-	/* Workaround current PCI init glitch:  wakeup bits aren't
-	 * being set from PCI PM capability.
+	/* Keep this around for a while just in case some EHCI
+	 * implementation uses legacy PCI PM support.  This test
+	 * can be removed on 17 Dec 2009 if the dev_warn() hasn't
+	 * been triggered by then.
 	 */
 	if (!device_can_wakeup(&amp;pdev-&gt;dev)) {
 		u16	port_wake;
 
 		pci_read_config_word(pdev, 0x62, &amp;port_wake);
-		if (port_wake &amp; 0x0001)
+		if (port_wake &amp; 0x0001) {
+			dev_warn(&amp;pdev-&gt;dev, "Enabling legacy PCI PM\n");
 			device_init_wakeup(&amp;pdev-&gt;dev, 1);
+		}
 	}
 
 #ifdef	CONFIG_USB_SUSPEND
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 8aa3f4556a32..65a9609f4ad6 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -589,13 +589,15 @@ static int ohci_run (struct ohci_hcd *ohci)
 		/* also: power/overcurrent flags in roothub.a */
 	}
 
-	/* Reset USB nearly "by the book".  RemoteWakeupConnected was
-	 * saved if boot firmware (BIOS/SMM/...) told us it's connected,
-	 * or if bus glue did the same (e.g. for PCI add-in cards with
-	 * PCI PM support).
+	/* Reset USB nearly "by the book".  RemoteWakeupConnected has
+	 * to be checked in case boot firmware (BIOS/SMM/...) has set up
+	 * wakeup in a way the bus isn't aware of (e.g., legacy PCI PM).
+	 * If the bus glue detected wakeup capability then it should
+	 * already be enabled.  Either way, if wakeup should be enabled
+	 * but isn't, we'll enable it now.
 	 */
 	if ((ohci-&gt;hc_control &amp; OHCI_CTRL_RWC) != 0
-			&amp;&amp; !device_may_wakeup(hcd-&gt;self.controller))
+			&amp;&amp; !device_can_wakeup(hcd-&gt;self.controller))
 		device_init_wakeup(hcd-&gt;self.controller, 1);
 
 	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 8380cc2e961a..8b28ae7865ba 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -355,9 +355,9 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 
 		/* RWC may not be set for add-in PCI cards, since boot
 		 * firmware probably ignored them.  This transfers PCI
-		 * PM wakeup capabilities (once the PCI layer is fixed).
+		 * PM wakeup capabilities.
 		 */
-		if (device_may_wakeup(&amp;pdev-&gt;dev))
+		if (device_can_wakeup(&amp;pdev-&gt;dev))
 			ohci-&gt;hc_control |= OHCI_CTRL_RWC;
 	}
 #endif /* CONFIG_PM */</pre>
    <div class="pagination">
        <a href='2_81.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><span>[82]</span><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_83.html'>Next&gt;&gt;</a>
    <div>
</body>
