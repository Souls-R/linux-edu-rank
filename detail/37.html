<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by City College of San Francisco</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by City College of San Francisco</h1>
    <div class="pagination">
        <span>[1]</span><a href='37_2.html'>2</a><a href='37_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ba272e3bbeaee3b34ca6c616f7ad8d3c65f33f79
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Mon Sep 18 15:52:40 2017 -0700

    Staging: iio: meter: ade7759: update locking method for write frequency
    
    iio_dev-&gt;mlock is to be used only by the IIO core for protecting
    device mode changes between INDIO_DIRECT and INDIO_BUFFER.
    
    This patch replaces the use of mlock with the already established
    buf_lock mutex.
    
    Introducing an 'unlocked' spi_write_reg_16 function to be used by
    ade7759_write_frequency avoids nested locks and maintains atomicity
    between bus and device frequency changes.
    
    Based on the solution found in ade7754 patch here:
    https://marc.info/?l=linux-iio&amp;m=149086659008991&amp;w=2
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Jonathan Cameron &lt;Jonathan.Cameron@huawei.com&gt;

diff --git a/drivers/staging/iio/meter/ade7759.c b/drivers/staging/iio/meter/ade7759.c
index 7639e90d1c94..cd75f60aded3 100644
--- a/drivers/staging/iio/meter/ade7759.c
+++ b/drivers/staging/iio/meter/ade7759.c
@@ -60,7 +60,7 @@
 /**
  * struct ade7759_state - device instance specific data
  * @us:			actual spi_device
- * @buf_lock:		mutex to protect tx and rx
+ * @buf_lock:		mutex to protect tx and rx and write frequency
  * @tx:			transmit buffer
  * @rx:			receive buffer
  **/
@@ -89,19 +89,30 @@ static int ade7759_spi_write_reg_8(struct device *dev,
 	return ret;
 }
 
-static int ade7759_spi_write_reg_16(struct device *dev,
+/*Unlocked version of ade7759_spi_write_reg_16 function */
+static int __ade7759_spi_write_reg_16(struct device *dev,
 		u8 reg_address,
 		u16 value)
 {
-	int ret;
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ade7759_state *st = iio_priv(indio_dev);
 
-	mutex_lock(&amp;st-&gt;buf_lock);
 	st-&gt;tx[0] = ADE7759_WRITE_REG(reg_address);
 	st-&gt;tx[1] = (value &gt;&gt; 8) &amp; 0xFF;
 	st-&gt;tx[2] = value &amp; 0xFF;
-	ret = spi_write(st-&gt;us, st-&gt;tx, 3);
+	return spi_write(st-&gt;us, st-&gt;tx, 3);
+}
+
+static int ade7759_spi_write_reg_16(struct device *dev,
+		u8 reg_address,
+		u16 value)
+{
+	int ret;
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	struct ade7759_state *st = iio_priv(indio_dev);
+
+	mutex_lock(&amp;st-&gt;buf_lock);
+	ret = __ade7759_spi_write_reg_16(dev, reg_address, value);
 	mutex_unlock(&amp;st-&gt;buf_lock);
 
 	return ret;
@@ -429,7 +440,7 @@ static ssize_t ade7759_write_frequency(struct device *dev,
 	if (!val)
 		return -EINVAL;
 
-	mutex_lock(&amp;indio_dev-&gt;mlock);
+	mutex_lock(&amp;st-&gt;buf_lock);
 
 	t = 27900 / val;
 	if (t &gt; 0)
@@ -447,10 +458,10 @@ static ssize_t ade7759_write_frequency(struct device *dev,
 	reg &amp;= ~(3 &lt;&lt; 13);
 	reg |= t &lt;&lt; 13;
 
-	ret = ade7759_spi_write_reg_16(dev, ADE7759_MODE, reg);
+	ret = __ade7759_spi_write_reg_16(dev, ADE7759_MODE, reg);
 
 out:
-	mutex_unlock(&amp;indio_dev-&gt;mlock);
+	mutex_unlock(&amp;st-&gt;buf_lock);
 
 	return ret ? ret : len;
 }</pre><hr><pre>commit dff1e0ef86cba81bf3d892036a28e8b889b7e72c
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Mon Feb 20 13:53:07 2017 -0800

    staging: vt6656: remove blank lines at opening and closing braces
    
    Removes unnecessary blank lines after opening and before closing braces.
    These instances were found by checkpatch.pl.
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Acked-by: Julia Lawall &lt;julia.lawall@lip6.fr&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/vt6656/wcmd.c b/drivers/staging/vt6656/wcmd.c
index 9f6cc2ef08dd..b2fc17f1381b 100644
--- a/drivers/staging/vt6656/wcmd.c
+++ b/drivers/staging/vt6656/wcmd.c
@@ -45,7 +45,6 @@ static void vnt_cmd_timer_wait(struct vnt_private *priv, unsigned long msecs)
 
 static int vnt_cmd_complete(struct vnt_private *priv)
 {
-
 	priv-&gt;command_state = WLAN_CMD_IDLE;
 	if (priv-&gt;free_cmd_queue == CMD_Q_SIZE) {
 		/* Command Queue Empty */
@@ -165,7 +164,6 @@ void vnt_run_command(struct work_struct *work)
 
 int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
 {
-
 	if (priv-&gt;free_cmd_queue == 0)
 		return false;
 
@@ -178,7 +176,6 @@ int vnt_schedule_command(struct vnt_private *priv, enum vnt_cmd command)
 		vnt_cmd_complete(priv);
 
 	return true;
-
 }
 
 void vnt_reset_command_timer(struct vnt_private *priv)</pre><hr><pre>commit 3efc66167007f4bd77d7690bf35ef1339b8bf374
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Sun Feb 19 21:14:29 2017 -0800

    staging: sm750fb: add spaces around operators
    
    Add spaces around operators -, *, ?:, &gt;&gt;, &lt;&lt; to conform to kernel style.
    These instances were found with checkpatch.pl
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Acked-by: Julia Lawall &lt;julia.lawall@lip6.fr&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/sm750fb/sm750_cursor.c b/drivers/staging/sm750fb/sm750_cursor.c
index b1651b0d2034..dbc8bb1fa9c1 100644
--- a/drivers/staging/sm750fb/sm750_cursor.c
+++ b/drivers/staging/sm750fb/sm750_cursor.c
@@ -111,14 +111,14 @@ void sm750_hw_cursor_setData(struct lynx_cursor *cursor,
 		data = 0;
 
 		for (j = 0; j &lt; 8; j++) {
-			if (mask &amp; (0x80&gt;&gt;j)) {
+			if (mask &amp; (0x80 &gt;&gt; j)) {
 				if (rop == ROP_XOR)
 					opr = mask ^ color;
 				else
 					opr = mask &amp; color;
 
 				/* 2 stands for forecolor and 1 for backcolor */
-				data |= ((opr &amp; (0x80&gt;&gt;j))?2:1)&lt;&lt;(j*2);
+				data |= ((opr &amp; (0x80 &gt;&gt; j)) ? 2 : 1) &lt;&lt; (j * 2);
 			}
 		}
 		iowrite16(data, pbuffer);
@@ -165,13 +165,13 @@ void sm750_hw_cursor_setData2(struct lynx_cursor *cursor,
 		data = 0;
 
 		for (j = 0; j &lt; 8; j++) {
-			if (mask &amp; (1&lt;&lt;j))
-				data |= ((color &amp; (1&lt;&lt;j))?1:2)&lt;&lt;(j*2);
+			if (mask &amp; (1 &lt;&lt; j))
+				data |= ((color &amp; (1 &lt;&lt; j)) ? 1 : 2) &lt;&lt; (j * 2);
 		}
 		iowrite16(data, pbuffer);
 
 		/* assume pitch is 1,2,4,8,...*/
-		if (!(i&amp;(pitch-1))) {
+		if (!(i &amp; (pitch - 1))) {
 			/* need a return */
 			pstart += offset;
 			pbuffer = pstart;</pre><hr><pre>commit 144634a6b42146834fb58ddd629545edd3e518db
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Sun Feb 19 20:38:57 2017 -0800

    staging: sm750fb: add curly braces to if-statements
    
    Add curly braces to if-statements for style compliance.
    These cases are found by checkpatch.pl
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/sm750fb/sm750.c b/drivers/staging/sm750fb/sm750.c
index e49f8845f923..332a3ef27ba8 100644
--- a/drivers/staging/sm750fb/sm750.c
+++ b/drivers/staging/sm750fb/sm750.c
@@ -954,23 +954,23 @@ static void sm750fb_setup(struct sm750_dev *sm750_dev, char *src)
 		dev_info(&amp;sm750_dev-&gt;pdev-&gt;dev, "opt=%s\n", opt);
 		dev_info(&amp;sm750_dev-&gt;pdev-&gt;dev, "src=%s\n", src);
 
-		if (!strncmp(opt, "swap", strlen("swap")))
+		if (!strncmp(opt, "swap", strlen("swap"))) {
 			swap = 1;
-		else if (!strncmp(opt, "nocrt", strlen("nocrt")))
+		} else if (!strncmp(opt, "nocrt", strlen("nocrt"))) {
 			sm750_dev-&gt;nocrt = 1;
-		else if (!strncmp(opt, "36bit", strlen("36bit")))
+		} else if (!strncmp(opt, "36bit", strlen("36bit"))) {
 			sm750_dev-&gt;pnltype = sm750_doubleTFT;
-		else if (!strncmp(opt, "18bit", strlen("18bit")))
+		} else if (!strncmp(opt, "18bit", strlen("18bit"))) {
 			sm750_dev-&gt;pnltype = sm750_dualTFT;
-		else if (!strncmp(opt, "24bit", strlen("24bit")))
+		} else if (!strncmp(opt, "24bit", strlen("24bit"))) {
 			sm750_dev-&gt;pnltype = sm750_24TFT;
-		else if (!strncmp(opt, "nohwc0", strlen("nohwc0")))
+		} else if (!strncmp(opt, "nohwc0", strlen("nohwc0"))) {
 			g_hwcursor &amp;= ~0x1;
-		else if (!strncmp(opt, "nohwc1", strlen("nohwc1")))
+		} else if (!strncmp(opt, "nohwc1", strlen("nohwc1"))) {
 			g_hwcursor &amp;= ~0x2;
-		else if (!strncmp(opt, "nohwc", strlen("nohwc")))
+		} else if (!strncmp(opt, "nohwc", strlen("nohwc"))) {
 			g_hwcursor = 0;
-		else {
+		} else {
 			if (!g_fbmode[0]) {
 				g_fbmode[0] = opt;
 				dev_info(&amp;sm750_dev-&gt;pdev-&gt;dev,
@@ -1168,13 +1168,13 @@ static int __init lynxfb_setup(char *options)
 	 */
 	while ((opt = strsep(&amp;options, ":")) != NULL) {
 		/* options that mean for any lynx chips are configured here */
-		if (!strncmp(opt, "noaccel", strlen("noaccel")))
+		if (!strncmp(opt, "noaccel", strlen("noaccel"))) {
 			g_noaccel = 1;
-		else if (!strncmp(opt, "nomtrr", strlen("nomtrr")))
+		} else if (!strncmp(opt, "nomtrr", strlen("nomtrr"))) {
 			g_nomtrr = 1;
-		else if (!strncmp(opt, "dual", strlen("dual")))
+		} else if (!strncmp(opt, "dual", strlen("dual"))) {
 			g_dualview = 1;
-		else {
+		} else {
 			strcat(tmp, opt);
 			tmp += strlen(opt);
 			if (options)</pre><hr><pre>commit d680d24eacac3124fc0d6a2fab0eef0074f09efd
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Sun Feb 19 18:30:00 2017 -0800

    staging: ks7010: remove unecessary spaces after casts
    
    Remove spaces after casts found by checkpatch.pl. In some cases,
    remove returns after casts and place them on a single line.
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c
index fab06f29ec8b..a533408cf0b9 100644
--- a/drivers/staging/ks7010/ks_hostif.c
+++ b/drivers/staging/ks7010/ks_hostif.c
@@ -379,9 +379,8 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 				       (priv-&gt;rxp) + ((priv-&gt;rx_size) - 8), 8);
 				priv-&gt;rx_size = priv-&gt;rx_size - 8;
 				if (auth_type &gt; 0 &amp;&amp; auth_type &lt; 4) {	/* auth_type check */
-					MichaelMICFunction(&amp;michel_mic, (uint8_t *) priv-&gt;wpa.key[auth_type - 1].rx_mic_key, (uint8_t *) priv-&gt;rxp, (int)priv-&gt;rx_size, (uint8_t) 0,	/* priority */
-							   (uint8_t *)
-							   michel_mic.Result);
+					MichaelMICFunction(&amp;michel_mic, (uint8_t *)priv-&gt;wpa.key[auth_type - 1].rx_mic_key, (uint8_t *)priv-&gt;rxp, (int)priv-&gt;rx_size, (uint8_t)0,	/* priority */
+							   (uint8_t *)michel_mic.Result);
 				}
 				if (memcmp(michel_mic.Result, RecvMIC, 8)) {
 					now = jiffies;
@@ -400,7 +399,7 @@ void hostif_data_indication(struct ks_wlan_private *priv)
 					} else if (mic_failure-&gt;failure == 1) {
 						mic_failure-&gt;failure = 2;
 						mic_failure-&gt;counter =
-						    (uint16_t) ((now -
+						    (uint16_t)((now -
 								 mic_failure-&gt;
 								 last_failure_time)
 								/ HZ);
@@ -1217,37 +1216,37 @@ int hostif_data_request(struct ks_wlan_private *priv, struct sk_buff *packet)
 		    &amp;&amp; !(priv-&gt;wpa.key[1].key_len)
 		    &amp;&amp; !(priv-&gt;wpa.key[2].key_len)
 		    &amp;&amp; !(priv-&gt;wpa.key[3].key_len)) {
-			pp-&gt;auth_type = cpu_to_le16((uint16_t) TYPE_AUTH);	/* no encryption */
+			pp-&gt;auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);	/* no encryption */
 		} else {
 			if (priv-&gt;wpa.pairwise_suite == IW_AUTH_CIPHER_TKIP) {
-				MichaelMICFunction(&amp;michel_mic, (uint8_t *) priv-&gt;wpa.key[0].tx_mic_key, (uint8_t *) &amp;pp-&gt;data[0], (int)packet_len, (uint8_t) 0,	/* priority */
-						   (uint8_t *) michel_mic.
+				MichaelMICFunction(&amp;michel_mic, (uint8_t *)priv-&gt;wpa.key[0].tx_mic_key, (uint8_t *)&amp;pp-&gt;data[0], (int)packet_len, (uint8_t)0,	/* priority */
+						   (uint8_t *)michel_mic.
 						   Result);
 				memcpy(p, michel_mic.Result, 8);
 				length += 8;
 				packet_len += 8;
 				p += 8;
 				pp-&gt;auth_type =
-				    cpu_to_le16((uint16_t) TYPE_DATA);
+				    cpu_to_le16((uint16_t)TYPE_DATA);
 
 			} else if (priv-&gt;wpa.pairwise_suite ==
 				   IW_AUTH_CIPHER_CCMP) {
 				pp-&gt;auth_type =
-				    cpu_to_le16((uint16_t) TYPE_DATA);
+				    cpu_to_le16((uint16_t)TYPE_DATA);
 			}
 		}
 	} else {
 		if (eth_proto == ETHER_PROTOCOL_TYPE_EAP)
-			pp-&gt;auth_type = cpu_to_le16((uint16_t) TYPE_AUTH);
+			pp-&gt;auth_type = cpu_to_le16((uint16_t)TYPE_AUTH);
 		else
-			pp-&gt;auth_type = cpu_to_le16((uint16_t) TYPE_DATA);
+			pp-&gt;auth_type = cpu_to_le16((uint16_t)TYPE_DATA);
 	}
 
 	/* header value set */
 	pp-&gt;header.size =
 	    cpu_to_le16((uint16_t)
 			(sizeof(*pp) - sizeof(pp-&gt;header.size) + packet_len));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_DATA_REQ);
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_DATA_REQ);
 
 	/* tx request */
 	result =
@@ -1291,9 +1290,9 @@ void hostif_mib_get_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_MIB_GET_REQ);
-	pp-&gt;mib_attribute = cpu_to_le32((uint32_t) mib_attribute);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_MIB_GET_REQ);
+	pp-&gt;mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1324,10 +1323,10 @@ void hostif_mib_set_request(struct ks_wlan_private *priv,
 	pp-&gt;header.size =
 	    cpu_to_le16((uint16_t)
 			(sizeof(*pp) - sizeof(pp-&gt;header.size) + size));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_MIB_SET_REQ);
-	pp-&gt;mib_attribute = cpu_to_le32((uint32_t) mib_attribute);
-	pp-&gt;mib_value.size = cpu_to_le16((uint16_t) size);
-	pp-&gt;mib_value.type = cpu_to_le16((uint16_t) type);
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_MIB_SET_REQ);
+	pp-&gt;mib_attribute = cpu_to_le32((uint32_t)mib_attribute);
+	pp-&gt;mib_value.size = cpu_to_le16((uint16_t)size);
+	pp-&gt;mib_value.type = cpu_to_le16((uint16_t)type);
 	memcpy(&amp;pp-&gt;mib_value.body, vp, size);
 
 	/* send to device request */
@@ -1350,9 +1349,9 @@ void hostif_start_request(struct ks_wlan_private *priv, unsigned char mode)
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_START_REQ);
-	pp-&gt;mode = cpu_to_le16((uint16_t) mode);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_START_REQ);
+	pp-&gt;mode = cpu_to_le16((uint16_t)mode);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1378,12 +1377,12 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 	}
 	memset(pp, 0, sizeof(*pp));
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_PS_ADH_SET_REQ);
-	pp-&gt;phy_type = cpu_to_le16((uint16_t) (priv-&gt;reg.phy_type));
-	pp-&gt;cts_mode = cpu_to_le16((uint16_t) (priv-&gt;reg.cts_mode));
-	pp-&gt;scan_type = cpu_to_le16((uint16_t) (priv-&gt;reg.scan_type));
-	pp-&gt;channel = cpu_to_le16((uint16_t) (priv-&gt;reg.channel));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_PS_ADH_SET_REQ);
+	pp-&gt;phy_type = cpu_to_le16((uint16_t)(priv-&gt;reg.phy_type));
+	pp-&gt;cts_mode = cpu_to_le16((uint16_t)(priv-&gt;reg.cts_mode));
+	pp-&gt;scan_type = cpu_to_le16((uint16_t)(priv-&gt;reg.scan_type));
+	pp-&gt;channel = cpu_to_le16((uint16_t)(priv-&gt;reg.channel));
 	pp-&gt;rate_set.size = priv-&gt;reg.rate_set.size;
 	memcpy(&amp;pp-&gt;rate_set.body[0], &amp;priv-&gt;reg.rate_set.body[0],
 	       priv-&gt;reg.rate_set.size);
@@ -1398,7 +1397,7 @@ void hostif_ps_adhoc_set_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &amp;= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM */
 	}
-	pp-&gt;capability = cpu_to_le16((uint16_t) capability);
+	pp-&gt;capability = cpu_to_le16((uint16_t)capability);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1420,11 +1419,11 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_INFRA_SET_REQ);
-	pp-&gt;phy_type = cpu_to_le16((uint16_t) (priv-&gt;reg.phy_type));
-	pp-&gt;cts_mode = cpu_to_le16((uint16_t) (priv-&gt;reg.cts_mode));
-	pp-&gt;scan_type = cpu_to_le16((uint16_t) (priv-&gt;reg.scan_type));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET_REQ);
+	pp-&gt;phy_type = cpu_to_le16((uint16_t)(priv-&gt;reg.phy_type));
+	pp-&gt;cts_mode = cpu_to_le16((uint16_t)(priv-&gt;reg.cts_mode));
+	pp-&gt;scan_type = cpu_to_le16((uint16_t)(priv-&gt;reg.scan_type));
 
 	pp-&gt;rate_set.size = priv-&gt;reg.rate_set.size;
 	memcpy(&amp;pp-&gt;rate_set.body[0], &amp;priv-&gt;reg.rate_set.body[0],
@@ -1442,10 +1441,10 @@ void hostif_infrastructure_set_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &amp;= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp-&gt;capability = cpu_to_le16((uint16_t) capability);
+	pp-&gt;capability = cpu_to_le16((uint16_t)capability);
 	pp-&gt;beacon_lost_count =
-	    cpu_to_le16((uint16_t) (priv-&gt;reg.beacon_lost_count));
-	pp-&gt;auth_type = cpu_to_le16((uint16_t) (priv-&gt;reg.authenticate_type));
+	    cpu_to_le16((uint16_t)(priv-&gt;reg.beacon_lost_count));
+	pp-&gt;auth_type = cpu_to_le16((uint16_t)(priv-&gt;reg.authenticate_type));
 
 	pp-&gt;channel_list.body[0] = 1;
 	pp-&gt;channel_list.body[1] = 8;
@@ -1486,11 +1485,11 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_INFRA_SET2_REQ);
-	pp-&gt;phy_type = cpu_to_le16((uint16_t) (priv-&gt;reg.phy_type));
-	pp-&gt;cts_mode = cpu_to_le16((uint16_t) (priv-&gt;reg.cts_mode));
-	pp-&gt;scan_type = cpu_to_le16((uint16_t) (priv-&gt;reg.scan_type));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_INFRA_SET2_REQ);
+	pp-&gt;phy_type = cpu_to_le16((uint16_t)(priv-&gt;reg.phy_type));
+	pp-&gt;cts_mode = cpu_to_le16((uint16_t)(priv-&gt;reg.cts_mode));
+	pp-&gt;scan_type = cpu_to_le16((uint16_t)(priv-&gt;reg.scan_type));
 
 	pp-&gt;rate_set.size = priv-&gt;reg.rate_set.size;
 	memcpy(&amp;pp-&gt;rate_set.body[0], &amp;priv-&gt;reg.rate_set.body[0],
@@ -1508,10 +1507,10 @@ static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &amp;= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp-&gt;capability = cpu_to_le16((uint16_t) capability);
+	pp-&gt;capability = cpu_to_le16((uint16_t)capability);
 	pp-&gt;beacon_lost_count =
-	    cpu_to_le16((uint16_t) (priv-&gt;reg.beacon_lost_count));
-	pp-&gt;auth_type = cpu_to_le16((uint16_t) (priv-&gt;reg.authenticate_type));
+	    cpu_to_le16((uint16_t)(priv-&gt;reg.beacon_lost_count));
+	pp-&gt;auth_type = cpu_to_le16((uint16_t)(priv-&gt;reg.authenticate_type));
 
 	pp-&gt;channel_list.body[0] = 1;
 	pp-&gt;channel_list.body[1] = 8;
@@ -1556,12 +1555,12 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 	}
 	memset(pp, 0, sizeof(*pp));
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_ADH_SET_REQ);
-	pp-&gt;phy_type = cpu_to_le16((uint16_t) (priv-&gt;reg.phy_type));
-	pp-&gt;cts_mode = cpu_to_le16((uint16_t) (priv-&gt;reg.cts_mode));
-	pp-&gt;scan_type = cpu_to_le16((uint16_t) (priv-&gt;reg.scan_type));
-	pp-&gt;channel = cpu_to_le16((uint16_t) (priv-&gt;reg.channel));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+	pp-&gt;phy_type = cpu_to_le16((uint16_t)(priv-&gt;reg.phy_type));
+	pp-&gt;cts_mode = cpu_to_le16((uint16_t)(priv-&gt;reg.cts_mode));
+	pp-&gt;scan_type = cpu_to_le16((uint16_t)(priv-&gt;reg.scan_type));
+	pp-&gt;channel = cpu_to_le16((uint16_t)(priv-&gt;reg.channel));
 	pp-&gt;rate_set.size = priv-&gt;reg.rate_set.size;
 	memcpy(&amp;pp-&gt;rate_set.body[0], &amp;priv-&gt;reg.rate_set.body[0],
 	       priv-&gt;reg.rate_set.size);
@@ -1578,7 +1577,7 @@ void hostif_adhoc_set_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &amp;= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp-&gt;capability = cpu_to_le16((uint16_t) capability);
+	pp-&gt;capability = cpu_to_le16((uint16_t)capability);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1601,11 +1600,11 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 	}
 	memset(pp, 0, sizeof(*pp));
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_ADH_SET_REQ);
-	pp-&gt;phy_type = cpu_to_le16((uint16_t) (priv-&gt;reg.phy_type));
-	pp-&gt;cts_mode = cpu_to_le16((uint16_t) (priv-&gt;reg.cts_mode));
-	pp-&gt;scan_type = cpu_to_le16((uint16_t) (priv-&gt;reg.scan_type));
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_ADH_SET_REQ);
+	pp-&gt;phy_type = cpu_to_le16((uint16_t)(priv-&gt;reg.phy_type));
+	pp-&gt;cts_mode = cpu_to_le16((uint16_t)(priv-&gt;reg.cts_mode));
+	pp-&gt;scan_type = cpu_to_le16((uint16_t)(priv-&gt;reg.scan_type));
 	pp-&gt;rate_set.size = priv-&gt;reg.rate_set.size;
 	memcpy(&amp;pp-&gt;rate_set.body[0], &amp;priv-&gt;reg.rate_set.body[0],
 	       priv-&gt;reg.rate_set.size);
@@ -1622,7 +1621,7 @@ void hostif_adhoc_set2_request(struct ks_wlan_private *priv)
 		capability |= BSS_CAP_SHORT_SLOT_TIME;	/* ShortSlotTime support */
 		capability &amp;= ~(BSS_CAP_DSSS_OFDM);	/* DSSS OFDM not support */
 	}
-	pp-&gt;capability = cpu_to_le16((uint16_t) capability);
+	pp-&gt;capability = cpu_to_le16((uint16_t)capability);
 
 	pp-&gt;channel_list.body[0] = priv-&gt;reg.channel;
 	pp-&gt;channel_list.size = 1;
@@ -1647,8 +1646,8 @@ void hostif_stop_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_STOP_REQ);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_STOP_REQ);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1669,14 +1668,14 @@ void hostif_phy_information_request(struct ks_wlan_private *priv)
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_PHY_INFO_REQ);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_PHY_INFO_REQ);
 	if (priv-&gt;reg.phy_info_timer) {
-		pp-&gt;type = cpu_to_le16((uint16_t) TIME_TYPE);
-		pp-&gt;time = cpu_to_le16((uint16_t) (priv-&gt;reg.phy_info_timer));
+		pp-&gt;type = cpu_to_le16((uint16_t)TIME_TYPE);
+		pp-&gt;time = cpu_to_le16((uint16_t)(priv-&gt;reg.phy_info_timer));
 	} else {
-		pp-&gt;type = cpu_to_le16((uint16_t) NORMAL_TYPE);
-		pp-&gt;time = cpu_to_le16((uint16_t) 0);
+		pp-&gt;type = cpu_to_le16((uint16_t)NORMAL_TYPE);
+		pp-&gt;time = cpu_to_le16((uint16_t)0);
 	}
 
 	/* send to device request */
@@ -1700,11 +1699,11 @@ void hostif_power_mngmt_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_POWERMGT_REQ);
-	pp-&gt;mode = cpu_to_le32((uint32_t) mode);
-	pp-&gt;wake_up = cpu_to_le32((uint32_t) wake_up);
-	pp-&gt;receiveDTIMs = cpu_to_le32((uint32_t) receiveDTIMs);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_POWERMGT_REQ);
+	pp-&gt;mode = cpu_to_le32((uint32_t)mode);
+	pp-&gt;wake_up = cpu_to_le32((uint32_t)wake_up);
+	pp-&gt;receiveDTIMs = cpu_to_le32((uint32_t)receiveDTIMs);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1726,9 +1725,8 @@ void hostif_sleep_request(struct ks_wlan_private *priv, unsigned long mode)
 			return;
 		}
 		pp-&gt;header.size =
-		    cpu_to_le16((uint16_t)
-				(sizeof(*pp) - sizeof(pp-&gt;header.size)));
-		pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_SLEEP_REQ);
+		    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+		pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_SLEEP_REQ);
 
 		/* send to device request */
 		ps_confirm_wait_inc(priv);
@@ -1759,12 +1757,12 @@ void hostif_bss_scan_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_SCAN_REQ);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_SCAN_REQ);
 	pp-&gt;scan_type = scan_type;
 
-	pp-&gt;ch_time_min = cpu_to_le32((uint32_t) 110);	/* default value */
-	pp-&gt;ch_time_max = cpu_to_le32((uint32_t) 130);	/* default value */
+	pp-&gt;ch_time_min = cpu_to_le32((uint32_t)110);	/* default value */
+	pp-&gt;ch_time_max = cpu_to_le32((uint32_t)130);	/* default value */
 	pp-&gt;channel_list.body[0] = 1;
 	pp-&gt;channel_list.body[1] = 8;
 	pp-&gt;channel_list.body[2] = 2;
@@ -1815,10 +1813,10 @@ void hostif_mic_failure_request(struct ks_wlan_private *priv,
 		return;
 	}
 	pp-&gt;header.size =
-	    cpu_to_le16((uint16_t) (sizeof(*pp) - sizeof(pp-&gt;header.size)));
-	pp-&gt;header.event = cpu_to_le16((uint16_t) HIF_MIC_FAILURE_REQ);
-	pp-&gt;failure_count = cpu_to_le16((uint16_t) failure_count);
-	pp-&gt;timer = cpu_to_le16((uint16_t) timer);
+	    cpu_to_le16((uint16_t)(sizeof(*pp) - sizeof(pp-&gt;header.size)));
+	pp-&gt;header.event = cpu_to_le16((uint16_t)HIF_MIC_FAILURE_REQ);
+	pp-&gt;failure_count = cpu_to_le16((uint16_t)failure_count);
+	pp-&gt;timer = cpu_to_le16((uint16_t)timer);
 
 	/* send to device request */
 	ps_confirm_wait_inc(priv);
@@ -1871,7 +1869,7 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_WEP_INDEX_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv-&gt;reg.wep_index));
+		val = cpu_to_le32((uint32_t)(priv-&gt;reg.wep_index));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &amp;val);
 		break;
@@ -1908,7 +1906,7 @@ void hostif_sme_set_wep(struct ks_wlan_private *priv, int type)
 					       &amp;priv-&gt;reg.wep_key[3].val[0]);
 		break;
 	case SME_WEP_FLAG_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv-&gt;reg.privacy_invoked));
+		val = cpu_to_le32((uint32_t)(priv-&gt;reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
 				       sizeof(val), MIB_VALUE_TYPE_BOOL, &amp;val);
 		break;
@@ -1936,7 +1934,7 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_RSN_UCAST_REQUEST:
-		wpa_suite.size = cpu_to_le16((uint16_t) 1);
+		wpa_suite.size = cpu_to_le16((uint16_t)1);
 		switch (priv-&gt;wpa.pairwise_suite) {
 		case IW_AUTH_CIPHER_NONE:
 			if (priv-&gt;wpa.version == IW_AUTH_WPA_VERSION_WPA2)
@@ -2034,7 +2032,7 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 				       &amp;wpa_suite.suite[0][0]);
 		break;
 	case SME_RSN_AUTH_REQUEST:
-		wpa_suite.size = cpu_to_le16((uint16_t) 1);
+		wpa_suite.size = cpu_to_le16((uint16_t)1);
 		switch (priv-&gt;wpa.key_mgmt_suite) {
 		case IW_AUTH_KEY_MGMT_802_1X:
 			if (priv-&gt;wpa.version == IW_AUTH_WPA_VERSION_WPA2)
@@ -2078,23 +2076,23 @@ void hostif_sme_set_rsn(struct ks_wlan_private *priv, int type)
 				       MIB_VALUE_TYPE_OSTRING, &amp;wpa_suite);
 		break;
 	case SME_RSN_ENABLED_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv-&gt;wpa.rsn_enabled));
+		val = cpu_to_le32((uint32_t)(priv-&gt;wpa.rsn_enabled));
 		hostif_mib_set_request(priv, DOT11_RSN_ENABLED,
 				       sizeof(val), MIB_VALUE_TYPE_BOOL, &amp;val);
 		break;
 	case SME_RSN_MODE_REQUEST:
 		if (priv-&gt;wpa.version == IW_AUTH_WPA_VERSION_WPA2) {
 			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t) RSN_MODE_WPA2);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+			    cpu_to_le32((uint32_t)RSN_MODE_WPA2);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		} else if (priv-&gt;wpa.version == IW_AUTH_WPA_VERSION_WPA) {
 			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t) RSN_MODE_WPA);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+			    cpu_to_le32((uint32_t)RSN_MODE_WPA);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		} else {
 			rsn_mode.rsn_mode =
-			    cpu_to_le32((uint32_t) RSN_MODE_NONE);
-			rsn_mode.rsn_capability = cpu_to_le16((uint16_t) 0);
+			    cpu_to_le32((uint32_t)RSN_MODE_NONE);
+			rsn_mode.rsn_capability = cpu_to_le16((uint16_t)0);
 		}
 		hostif_mib_set_request(priv, LOCAL_RSN_MODE, sizeof(rsn_mode),
 				       MIB_VALUE_TYPE_OSTRING, &amp;rsn_mode);
@@ -2187,7 +2185,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		break;
 	case MODE_INFRASTRUCTURE:
 		/* Infrastructure mode */
-		if (!is_valid_ether_addr((u8 *) priv-&gt;reg.bssid)) {
+		if (!is_valid_ether_addr((u8 *)priv-&gt;reg.bssid)) {
 			hostif_infrastructure_set_request(priv);
 		} else {
 			hostif_infrastructure_set2_request(priv);
@@ -2197,7 +2195,7 @@ void hostif_sme_mode_setup(struct ks_wlan_private *priv)
 		break;
 	case MODE_ADHOC:
 		/* IEEE802.11 Ad-Hoc mode */
-		if (!is_valid_ether_addr((u8 *) priv-&gt;reg.bssid)) {
+		if (!is_valid_ether_addr((u8 *)priv-&gt;reg.bssid)) {
 			hostif_adhoc_set_request(priv);
 		} else {
 			hostif_adhoc_set2_request(priv);
@@ -2227,13 +2225,13 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 	memset(set_address, 0, NIC_MAX_MCAST_LIST * ETH_ALEN);
 
 	if (dev-&gt;flags &amp; IFF_PROMISC) {
-		filter_type = cpu_to_le32((uint32_t) MCAST_FILTER_PROMISC);
+		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_PROMISC);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
 				       &amp;filter_type);
 	} else if ((netdev_mc_count(dev) &gt; NIC_MAX_MCAST_LIST)
 		   || (dev-&gt;flags &amp; IFF_ALLMULTI)) {
-		filter_type = cpu_to_le32((uint32_t) MCAST_FILTER_MCASTALL);
+		filter_type = cpu_to_le32((uint32_t)MCAST_FILTER_MCASTALL);
 		hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 				       sizeof(filter_type), MIB_VALUE_TYPE_BOOL,
 				       &amp;filter_type);
@@ -2252,7 +2250,7 @@ void hostif_sme_multicast_set(struct ks_wlan_private *priv)
 					       &amp;set_address[0]);
 		} else {
 			filter_type =
-			    cpu_to_le32((uint32_t) MCAST_FILTER_MCAST);
+			    cpu_to_le32((uint32_t)MCAST_FILTER_MCAST);
 			priv-&gt;sme_i.sme_flag |= SME_MULTICAST;
 			hostif_mib_set_request(priv, LOCAL_MULTICAST_FILTER,
 					       sizeof(filter_type),
@@ -2330,12 +2328,12 @@ void hostif_sme_set_key(struct ks_wlan_private *priv, int type)
 
 	switch (type) {
 	case SME_SET_FLAG:
-		val = cpu_to_le32((uint32_t) (priv-&gt;reg.privacy_invoked));
+		val = cpu_to_le32((uint32_t)(priv-&gt;reg.privacy_invoked));
 		hostif_mib_set_request(priv, DOT11_PRIVACY_INVOKED,
 				       sizeof(val), MIB_VALUE_TYPE_BOOL, &amp;val);
 		break;
 	case SME_SET_TXKEY:
-		val = cpu_to_le32((uint32_t) (priv-&gt;wpa.txkey));
+		val = cpu_to_le32((uint32_t)(priv-&gt;wpa.txkey));
 		hostif_mib_set_request(priv, DOT11_WEP_DEFAULT_KEY_ID,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &amp;val);
 		break;
@@ -2404,7 +2402,7 @@ void hostif_sme_set_pmksa(struct ks_wlan_private *priv)
 			i++;
 		}
 	}
-	pmkcache.size = cpu_to_le16((uint16_t) (priv-&gt;pmklist.size));
+	pmkcache.size = cpu_to_le16((uint16_t)(priv-&gt;pmklist.size));
 	hostif_mib_set_request(priv, LOCAL_PMK,
 			       sizeof(priv-&gt;pmklist.size) + (ETH_ALEN +
 							     IW_PMKID_LEN) *
@@ -2478,12 +2476,12 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_stop_request(priv);
 		break;
 	case SME_RTS_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv-&gt;reg.rts));
+		val = cpu_to_le32((uint32_t)(priv-&gt;reg.rts));
 		hostif_mib_set_request(priv, DOT11_RTS_THRESHOLD,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &amp;val);
 		break;
 	case SME_FRAGMENTATION_THRESHOLD_REQUEST:
-		val = cpu_to_le32((uint32_t) (priv-&gt;reg.fragment));
+		val = cpu_to_le32((uint32_t)(priv-&gt;reg.fragment));
 		hostif_mib_set_request(priv, DOT11_FRAGMENTATION_THRESHOLD,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &amp;val);
 		break;
@@ -2560,7 +2558,7 @@ void hostif_sme_execute(struct ks_wlan_private *priv, int event)
 		hostif_sme_sleep_set(priv);
 		break;
 	case SME_SET_REGION:
-		val = cpu_to_le32((uint32_t) (priv-&gt;region));
+		val = cpu_to_le32((uint32_t)(priv-&gt;region));
 		hostif_mib_set_request(priv, LOCAL_REGION,
 				       sizeof(val), MIB_VALUE_TYPE_INT, &amp;val);
 		break;</pre><hr><pre>commit a8ba84626b1b33ff53c4adaff9b69304eb41877f
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Mon Feb 20 12:24:40 2017 -0800

    staging: xgifb: add braces around if-statements
    
    Add braces to instances of if-statements found by checkpatch.pl
    to conform to kernel style.
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/xgifb/XGI_main_26.c b/drivers/staging/xgifb/XGI_main_26.c
index 68952358933c..69ed137337ce 100644
--- a/drivers/staging/xgifb/XGI_main_26.c
+++ b/drivers/staging/xgifb/XGI_main_26.c
@@ -1480,9 +1480,9 @@ static void XGIfb_detect_VB(struct xgifb_video_info *xgifb_info)
 
 	cr32 = xgifb_reg_get(XGICR, IND_XGI_SCRATCH_REG_CR32);
 
-	if ((cr32 &amp; SIS_CRT1) &amp;&amp; !XGIfb_crt1off)
+	if ((cr32 &amp; SIS_CRT1) &amp;&amp; !XGIfb_crt1off) {
 		XGIfb_crt1off = 0;
-	else {
+	} else {
 		if (cr32 &amp; 0x5F)
 			XGIfb_crt1off = 1;
 		else
@@ -1500,18 +1500,19 @@ static void XGIfb_detect_VB(struct xgifb_video_info *xgifb_info)
 			xgifb_info-&gt;display2 = XGIFB_DISP_NONE;
 	}
 
-	if (XGIfb_tvplug != -1)
+	if (XGIfb_tvplug != -1) {
 		/* Override with option */
 		xgifb_info-&gt;TV_plug = XGIfb_tvplug;
-	else if (cr32 &amp; SIS_VB_HIVISION) {
+	} else if (cr32 &amp; SIS_VB_HIVISION) {
 		xgifb_info-&gt;TV_type = TVMODE_HIVISION;
 		xgifb_info-&gt;TV_plug = TVPLUG_SVIDEO;
-	} else if (cr32 &amp; SIS_VB_SVIDEO)
+	} else if (cr32 &amp; SIS_VB_SVIDEO) {
 		xgifb_info-&gt;TV_plug = TVPLUG_SVIDEO;
-	else if (cr32 &amp; SIS_VB_COMPOSITE)
+	} else if (cr32 &amp; SIS_VB_COMPOSITE) {
 		xgifb_info-&gt;TV_plug = TVPLUG_COMPOSITE;
-	else if (cr32 &amp; SIS_VB_SCART)
+	} else if (cr32 &amp; SIS_VB_SCART) {
 		xgifb_info-&gt;TV_plug = TVPLUG_SCART;
+	}
 
 	if (xgifb_info-&gt;TV_type == 0) {
 		temp = xgifb_reg_get(XGICR, 0x38);</pre><hr><pre>commit 0f0c106aa95243c5e59f06fb447ed7ea89818be1
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Fri Mar 3 07:38:37 2017 -0800

    staging: iio: meter: ade7753: Clean up includes
    
    Alphabetize header files.
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Jonathan Cameron &lt;jic23@kernel.org&gt;

diff --git a/drivers/staging/iio/meter/ade7753.c b/drivers/staging/iio/meter/ade7753.c
index 063ff2789b71..dfd8b71d6a41 100644
--- a/drivers/staging/iio/meter/ade7753.c
+++ b/drivers/staging/iio/meter/ade7753.c
@@ -6,20 +6,19 @@
  * Licensed under the GPL-2 or later.
  */
 
-#include &lt;linux/interrupt.h&gt;
-#include &lt;linux/irq.h&gt;
 #include &lt;linux/delay.h&gt;
-#include &lt;linux/mutex.h&gt;
 #include &lt;linux/device.h&gt;
+#include &lt;linux/interrupt.h&gt;
+#include &lt;linux/irq.h&gt;
 #include &lt;linux/kernel.h&gt;
-#include &lt;linux/spi/spi.h&gt;
-#include &lt;linux/slab.h&gt;
-#include &lt;linux/sysfs.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/module.h&gt;
-
+#include &lt;linux/mutex.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/sysfs.h&gt;
 #include &lt;linux/iio/iio.h&gt;
 #include &lt;linux/iio/sysfs.h&gt;
+#include &lt;linux/spi/spi.h&gt;
 #include "meter.h"
 
 #define ADE7753_WAVEFORM   0x01</pre><hr><pre>commit 63a98d2511e2d2fb6fb305c0093ad8a066c43d08
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Fri Mar 3 07:35:52 2017 -0800

    staging: iio: meter: ade7753: Move header content to implementation file
    
    The contents of ade7753.h are only used in ade7753.c. Move the header
    contents to the implementation file and delete the header file.
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Jonathan Cameron &lt;jic23@kernel.org&gt;

diff --git a/drivers/staging/iio/meter/ade7753.c b/drivers/staging/iio/meter/ade7753.c
index 671dc9971610..063ff2789b71 100644
--- a/drivers/staging/iio/meter/ade7753.c
+++ b/drivers/staging/iio/meter/ade7753.c
@@ -21,7 +21,74 @@
 #include &lt;linux/iio/iio.h&gt;
 #include &lt;linux/iio/sysfs.h&gt;
 #include "meter.h"
-#include "ade7753.h"
+
+#define ADE7753_WAVEFORM   0x01
+#define ADE7753_AENERGY    0x02
+#define ADE7753_RAENERGY   0x03
+#define ADE7753_LAENERGY   0x04
+#define ADE7753_VAENERGY   0x05
+#define ADE7753_RVAENERGY  0x06
+#define ADE7753_LVAENERGY  0x07
+#define ADE7753_LVARENERGY 0x08
+#define ADE7753_MODE       0x09
+#define ADE7753_IRQEN      0x0A
+#define ADE7753_STATUS     0x0B
+#define ADE7753_RSTSTATUS  0x0C
+#define ADE7753_CH1OS      0x0D
+#define ADE7753_CH2OS      0x0E
+#define ADE7753_GAIN       0x0F
+#define ADE7753_PHCAL      0x10
+#define ADE7753_APOS       0x11
+#define ADE7753_WGAIN      0x12
+#define ADE7753_WDIV       0x13
+#define ADE7753_CFNUM      0x14
+#define ADE7753_CFDEN      0x15
+#define ADE7753_IRMS       0x16
+#define ADE7753_VRMS       0x17
+#define ADE7753_IRMSOS     0x18
+#define ADE7753_VRMSOS     0x19
+#define ADE7753_VAGAIN     0x1A
+#define ADE7753_VADIV      0x1B
+#define ADE7753_LINECYC    0x1C
+#define ADE7753_ZXTOUT     0x1D
+#define ADE7753_SAGCYC     0x1E
+#define ADE7753_SAGLVL     0x1F
+#define ADE7753_IPKLVL     0x20
+#define ADE7753_VPKLVL     0x21
+#define ADE7753_IPEAK      0x22
+#define ADE7753_RSTIPEAK   0x23
+#define ADE7753_VPEAK      0x24
+#define ADE7753_RSTVPEAK   0x25
+#define ADE7753_TEMP       0x26
+#define ADE7753_PERIOD     0x27
+#define ADE7753_TMODE      0x3D
+#define ADE7753_CHKSUM     0x3E
+#define ADE7753_DIEREV     0x3F
+
+#define ADE7753_READ_REG(a)    a
+#define ADE7753_WRITE_REG(a) ((a) | 0x80)
+
+#define ADE7753_MAX_TX    4
+#define ADE7753_MAX_RX    4
+#define ADE7753_STARTUP_DELAY 1000
+
+#define ADE7753_SPI_SLOW    (u32)(300 * 1000)
+#define ADE7753_SPI_BURST   (u32)(1000 * 1000)
+#define ADE7753_SPI_FAST    (u32)(2000 * 1000)
+
+/**
+ * struct ade7753_state - device instance specific data
+ * @us:         actual spi_device
+ * @tx:         transmit buffer
+ * @rx:         receive buffer
+ * @buf_lock:       mutex to protect tx and rx
+ **/
+struct ade7753_state {
+	    struct spi_device   *us;
+		    struct mutex        buf_lock;
+			    u8          tx[ADE7753_MAX_TX] ____cacheline_aligned;
+				    u8          rx[ADE7753_MAX_RX];
+};
 
 static int ade7753_spi_write_reg_8(struct device *dev,
 				   u8 reg_address,
diff --git a/drivers/staging/iio/meter/ade7753.h b/drivers/staging/iio/meter/ade7753.h
deleted file mode 100644
index bfe749156bce..000000000000
--- a/drivers/staging/iio/meter/ade7753.h
+++ /dev/null
@@ -1,72 +0,0 @@
-#ifndef _ADE7753_H
-#define _ADE7753_H
-
-#define ADE7753_WAVEFORM   0x01
-#define ADE7753_AENERGY    0x02
-#define ADE7753_RAENERGY   0x03
-#define ADE7753_LAENERGY   0x04
-#define ADE7753_VAENERGY   0x05
-#define ADE7753_RVAENERGY  0x06
-#define ADE7753_LVAENERGY  0x07
-#define ADE7753_LVARENERGY 0x08
-#define ADE7753_MODE       0x09
-#define ADE7753_IRQEN      0x0A
-#define ADE7753_STATUS     0x0B
-#define ADE7753_RSTSTATUS  0x0C
-#define ADE7753_CH1OS      0x0D
-#define ADE7753_CH2OS      0x0E
-#define ADE7753_GAIN       0x0F
-#define ADE7753_PHCAL      0x10
-#define ADE7753_APOS       0x11
-#define ADE7753_WGAIN      0x12
-#define ADE7753_WDIV       0x13
-#define ADE7753_CFNUM      0x14
-#define ADE7753_CFDEN      0x15
-#define ADE7753_IRMS       0x16
-#define ADE7753_VRMS       0x17
-#define ADE7753_IRMSOS     0x18
-#define ADE7753_VRMSOS     0x19
-#define ADE7753_VAGAIN     0x1A
-#define ADE7753_VADIV      0x1B
-#define ADE7753_LINECYC    0x1C
-#define ADE7753_ZXTOUT     0x1D
-#define ADE7753_SAGCYC     0x1E
-#define ADE7753_SAGLVL     0x1F
-#define ADE7753_IPKLVL     0x20
-#define ADE7753_VPKLVL     0x21
-#define ADE7753_IPEAK      0x22
-#define ADE7753_RSTIPEAK   0x23
-#define ADE7753_VPEAK      0x24
-#define ADE7753_RSTVPEAK   0x25
-#define ADE7753_TEMP       0x26
-#define ADE7753_PERIOD     0x27
-#define ADE7753_TMODE      0x3D
-#define ADE7753_CHKSUM     0x3E
-#define ADE7753_DIEREV     0x3F
-
-#define ADE7753_READ_REG(a)    a
-#define ADE7753_WRITE_REG(a) ((a) | 0x80)
-
-#define ADE7753_MAX_TX    4
-#define ADE7753_MAX_RX    4
-#define ADE7753_STARTUP_DELAY 1000
-
-#define ADE7753_SPI_SLOW	(u32)(300 * 1000)
-#define ADE7753_SPI_BURST	(u32)(1000 * 1000)
-#define ADE7753_SPI_FAST	(u32)(2000 * 1000)
-
-/**
- * struct ade7753_state - device instance specific data
- * @us:			actual spi_device
- * @tx:			transmit buffer
- * @rx:			receive buffer
- * @buf_lock:		mutex to protect tx and rx
- **/
-struct ade7753_state {
-	struct spi_device	*us;
-	struct mutex		buf_lock;
-	u8			tx[ADE7753_MAX_TX] ____cacheline_aligned;
-	u8			rx[ADE7753_MAX_RX];
-};
-
-#endif</pre><hr><pre>commit 3adc4aae0e597a7cdcb9ed3f99d0933bf9a4aaa6
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Wed Sep 21 15:13:20 2016 -0700

    staging: speakup: Remove unnecessary parentheses
    
    Issue found by checkpatch.
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/speakup/synth.c b/drivers/staging/speakup/synth.c
index 810a21408715..54b2f3918628 100644
--- a/drivers/staging/speakup/synth.c
+++ b/drivers/staging/speakup/synth.c
@@ -407,7 +407,7 @@ static int do_synth_init(struct spk_synth *in_synth)
 	if (!spk_quiet_boot)
 		synth_printf("%s found\n", synth-&gt;long_name);
 	if (synth-&gt;attributes.name
-	&amp;&amp; sysfs_create_group(speakup_kobj, &amp;(synth-&gt;attributes)) &lt; 0)
+	&amp;&amp; sysfs_create_group(speakup_kobj, &amp;synth-&gt;attributes) &lt; 0)
 		return -ENOMEM;
 	synth_flags = synth-&gt;flags;
 	wake_up_interruptible_all(&amp;speakup_event);
@@ -429,7 +429,7 @@ void synth_release(void)
 	del_timer(&amp;thread_timer);
 	spin_unlock_irqrestore(&amp;speakup_info.spinlock, flags);
 	if (synth-&gt;attributes.name)
-		sysfs_remove_group(speakup_kobj, &amp;(synth-&gt;attributes));
+		sysfs_remove_group(speakup_kobj, &amp;synth-&gt;attributes);
 	for (var = synth-&gt;vars; var-&gt;var_id != MAXVARS; var++)
 		speakup_unregister_var(var-&gt;var_id);
 	spk_stop_serial_interrupt();</pre><hr><pre>commit a8886770dcf27082fe0fa64592e0054d02cea90d
Author: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
Date:   Wed Sep 14 10:18:28 2016 -0700

    staging: iio: ad5933: align arguments on new line with open parenthesis
    
    Issue found by checkpatch: "Alignment should match open parenthesis."
    Multiple lines are also reduced to a single line where possible.
    
    Signed-off-by: Katie Dunne &lt;kdunne@mail.ccsf.edu&gt;
    Signed-off-by: Jonathan Cameron &lt;jic23@kernel.org&gt;

diff --git a/drivers/staging/iio/impedance-analyzer/ad5933.c b/drivers/staging/iio/impedance-analyzer/ad5933.c
index 24c348d2f5bb..5eecf1cb1028 100644
--- a/drivers/staging/iio/impedance-analyzer/ad5933.c
+++ b/drivers/staging/iio/impedance-analyzer/ad5933.c
@@ -156,8 +156,7 @@ static const struct iio_chan_spec ad5933_channels[] = {
 	},
 };
 
-static int ad5933_i2c_write(struct i2c_client *client,
-			      u8 reg, u8 len, u8 *data)
+static int ad5933_i2c_write(struct i2c_client *client, u8 reg, u8 len, u8 *data)
 {
 	int ret;
 
@@ -171,8 +170,7 @@ static int ad5933_i2c_write(struct i2c_client *client,
 	return 0;
 }
 
-static int ad5933_i2c_read(struct i2c_client *client,
-			      u8 reg, u8 len, u8 *data)
+static int ad5933_i2c_read(struct i2c_client *client, u8 reg, u8 len, u8 *data)
 {
 	int ret;
 
@@ -269,7 +267,8 @@ static int ad5933_setup(struct ad5933_state *st)
 	dat = cpu_to_be16(st-&gt;settling_cycles);
 
 	ret = ad5933_i2c_write(st-&gt;client,
-			AD5933_REG_SETTLING_CYCLES, 2, (u8 *)&amp;dat);
+			       AD5933_REG_SETTLING_CYCLES,
+			       2, (u8 *)&amp;dat);
 	if (ret &lt; 0)
 		return ret;
 
@@ -294,8 +293,8 @@ static void ad5933_calc_out_ranges(struct ad5933_state *st)
  */
 
 static ssize_t ad5933_show_frequency(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+				     struct device_attribute *attr,
+				     char *buf)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad5933_state *st = iio_priv(indio_dev);
@@ -322,9 +321,9 @@ static ssize_t ad5933_show_frequency(struct device *dev,
 }
 
 static ssize_t ad5933_store_frequency(struct device *dev,
-					 struct device_attribute *attr,
-					 const char *buf,
-					 size_t len)
+				      struct device_attribute *attr,
+				      const char *buf,
+				      size_t len)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad5933_state *st = iio_priv(indio_dev);
@@ -357,8 +356,8 @@ static IIO_DEVICE_ATTR(out_voltage0_freq_increment, S_IRUGO | S_IWUSR,
 			AD5933_REG_FREQ_INC);
 
 static ssize_t ad5933_show(struct device *dev,
-					struct device_attribute *attr,
-					char *buf)
+			   struct device_attribute *attr,
+			   char *buf)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad5933_state *st = iio_priv(indio_dev);
@@ -399,9 +398,9 @@ static ssize_t ad5933_show(struct device *dev,
 }
 
 static ssize_t ad5933_store(struct device *dev,
-					 struct device_attribute *attr,
-					 const char *buf,
-					 size_t len)
+			    struct device_attribute *attr,
+			    const char *buf,
+			    size_t len)
 {
 	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
 	struct ad5933_state *st = iio_priv(indio_dev);
@@ -451,7 +450,8 @@ static ssize_t ad5933_store(struct device *dev,
 
 		dat = cpu_to_be16(val);
 		ret = ad5933_i2c_write(st-&gt;client,
-				AD5933_REG_SETTLING_CYCLES, 2, (u8 *)&amp;dat);
+				       AD5933_REG_SETTLING_CYCLES,
+				       2, (u8 *)&amp;dat);
 		break;
 	case AD5933_FREQ_POINTS:
 		val = clamp(val, (u16)0, (u16)511);
@@ -545,8 +545,8 @@ static int ad5933_read_raw(struct iio_dev *indio_dev,
 			goto out;
 
 		ret = ad5933_i2c_read(st-&gt;client,
-				AD5933_REG_TEMP_DATA, 2,
-				(u8 *)&amp;dat);
+				      AD5933_REG_TEMP_DATA,
+				      2, (u8 *)&amp;dat);
 		if (ret &lt; 0)
 			goto out;
 		mutex_unlock(&amp;indio_dev-&gt;mlock);
@@ -705,7 +705,7 @@ static void ad5933_work(struct work_struct *work)
 }
 
 static int ad5933_probe(struct i2c_client *client,
-				   const struct i2c_device_id *id)
+			const struct i2c_device_id *id)
 {
 	int ret, voltage_uv = 0;
 	struct ad5933_platform_data *pdata = dev_get_platdata(&amp;client-&gt;dev);</pre>
    <div class="pagination">
        <span>[1]</span><a href='37_2.html'>2</a><a href='37_2.html'>Next&gt;&gt;</a>
    <div>
</body>
