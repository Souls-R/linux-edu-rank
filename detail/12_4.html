<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Science and Technology of China</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Science and Technology of China</h1>
    <div class="pagination">
        <a href='12_3.html'>&lt;&lt;Prev</a><a href='12.html'>1</a><a href='12_2.html'>2</a><a href='12_3.html'>3</a><span>[4]</span><a href='12_5.html'>5</a><a href='12_6.html'>6</a><a href='12_7.html'>7</a><a href='12_8.html'>8</a><a href='12_9.html'>9</a><a href='12_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1b479fb801602b22512f53c19b1f93a4fc5d5d9d
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Sun Mar 28 00:50:08 2021 -0700

    drivers/net/wan/hdlc_fr: Fix a double free in pvc_xmit
    
    In pvc_xmit, if __skb_pad(skb, pad, false) failed, it will free
    the skb in the first time and goto drop. But the same skb is freed
    by kfree_skb(skb) in the second time in drop.
    
    Maintaining the original function unchanged, my patch adds a new
    label out to avoid the double free if __skb_pad() failed.
    
    Fixes: f5083d0cee08a ("drivers/net/wan/hdlc_fr: Improvements to the code of pvc_xmit")
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/wan/hdlc_fr.c b/drivers/net/wan/hdlc_fr.c
index 0720f5f92caa..4d9dc7d15908 100644
--- a/drivers/net/wan/hdlc_fr.c
+++ b/drivers/net/wan/hdlc_fr.c
@@ -415,7 +415,7 @@ static netdev_tx_t pvc_xmit(struct sk_buff *skb, struct net_device *dev)
 
 		if (pad &gt; 0) { /* Pad the frame with zeros */
 			if (__skb_pad(skb, pad, false))
-				goto drop;
+				goto out;
 			skb_put(skb, pad);
 		}
 	}
@@ -448,8 +448,9 @@ static netdev_tx_t pvc_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 
 drop:
-	dev-&gt;stats.tx_dropped++;
 	kfree_skb(skb);
+out:
+	dev-&gt;stats.tx_dropped++;
 	return NETDEV_TX_OK;
 }
 </pre><hr><pre>commit adb76a520d068a54ee5ca82e756cf8e5a47363a4
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Mon Mar 22 09:13:25 2021 -0700

    IB/isert: Fix a use after free in isert_connect_request
    
    The device is got by isert_device_get() with refcount is 1, and is
    assigned to isert_conn by
      isert_conn-&gt;device = device.
    
    When isert_create_qp() failed, device will be freed with
    isert_device_put().
    
    Later, the device is used in isert_free_login_buf(isert_conn) by the
    isert_conn-&gt;device-&gt;ib_device statement.
    
    Free the device in the correct order.
    
    Fixes: ae9ea9ed38c9 ("iser-target: Split some logic in isert_connect_request to routines")
    Link: https://lore.kernel.org/r/20210322161325.7491-1-lyl2019@mail.ustc.edu.cn
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Acked-by: Sagi Grimberg &lt;sagi@grimberg.me&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@nvidia.com&gt;
    Reviewed-by: Max Gurtovoy &lt;mgurtovoy@nvidia.com&gt;
    Signed-off-by: Jason Gunthorpe &lt;jgg@nvidia.com&gt;

diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index 7305ed8976c2..18266f07c58d 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -438,23 +438,23 @@ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 	isert_init_conn(isert_conn);
 	isert_conn-&gt;cm_id = cma_id;
 
-	ret = isert_alloc_login_buf(isert_conn, cma_id-&gt;device);
-	if (ret)
-		goto out;
-
 	device = isert_device_get(cma_id);
 	if (IS_ERR(device)) {
 		ret = PTR_ERR(device);
-		goto out_rsp_dma_map;
+		goto out;
 	}
 	isert_conn-&gt;device = device;
 
+	ret = isert_alloc_login_buf(isert_conn, cma_id-&gt;device);
+	if (ret)
+		goto out_conn_dev;
+
 	isert_set_nego_params(isert_conn, &amp;event-&gt;param.conn);
 
 	isert_conn-&gt;qp = isert_create_qp(isert_conn, cma_id);
 	if (IS_ERR(isert_conn-&gt;qp)) {
 		ret = PTR_ERR(isert_conn-&gt;qp);
-		goto out_conn_dev;
+		goto out_rsp_dma_map;
 	}
 
 	ret = isert_login_post_recv(isert_conn);
@@ -473,10 +473,10 @@ isert_connect_request(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)
 
 out_destroy_qp:
 	isert_destroy_qp(isert_conn);
-out_conn_dev:
-	isert_device_put(device);
 out_rsp_dma_map:
 	isert_free_login_buf(isert_conn);
+out_conn_dev:
+	isert_device_put(device);
 out:
 	kfree(isert_conn);
 	rdma_reject(cma_id, NULL, 0, IB_CM_REJ_CONSUMER_DEFINED);</pre><hr><pre>commit 52762efa2b256ed1c5274e5177cbd52ee11a2f6a
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Mon Mar 22 18:46:56 2021 -0700

    gpu/xen: Fix a use after free in xen_drm_drv_init
    
    In function displback_changed, has the call chain
    displback_connect(front_info)-&gt;xen_drm_drv_init(front_info).
    We can see that drm_info is assigned to front_info-&gt;drm_info
    and drm_info is freed in fail branch in xen_drm_drv_init().
    
    Later displback_disconnect(front_info) is called and it calls
    xen_drm_drv_fini(front_info) cause a use after free by
    drm_info = front_info-&gt;drm_info statement.
    
    My patch has done two things. First fixes the fail label which
    drm_info = kzalloc() failed and still free the drm_info.
    Second sets front_info-&gt;drm_info to NULL to avoid uaf.
    
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Reviewed-by: Oleksandr Andrushchenko &lt;oleksandr_andrushchenko@epam.com&gt;
    Signed-off-by: Oleksandr Andrushchenko &lt;oleksandr_andrushchenko@epam.com&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/20210323014656.10068-1-lyl2019@mail.ustc.edu.cn

diff --git a/drivers/gpu/drm/xen/xen_drm_front.c b/drivers/gpu/drm/xen/xen_drm_front.c
index 30d9adf31c84..9f14d99c763c 100644
--- a/drivers/gpu/drm/xen/xen_drm_front.c
+++ b/drivers/gpu/drm/xen/xen_drm_front.c
@@ -521,7 +521,7 @@ static int xen_drm_drv_init(struct xen_drm_front_info *front_info)
 	drm_dev = drm_dev_alloc(&amp;xen_drm_driver, dev);
 	if (IS_ERR(drm_dev)) {
 		ret = PTR_ERR(drm_dev);
-		goto fail;
+		goto fail_dev;
 	}
 
 	drm_info-&gt;drm_dev = drm_dev;
@@ -551,8 +551,10 @@ static int xen_drm_drv_init(struct xen_drm_front_info *front_info)
 	drm_kms_helper_poll_fini(drm_dev);
 	drm_mode_config_cleanup(drm_dev);
 	drm_dev_put(drm_dev);
-fail:
+fail_dev:
 	kfree(drm_info);
+	front_info-&gt;drm_info = NULL;
+fail:
 	return ret;
 }
 </pre><hr><pre>commit 37df9f3fedb6aeaff5564145e8162aab912c9284
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Wed Mar 24 03:37:24 2021 -0700

    video: hyperv_fb: Fix a double free in hvfb_probe
    
    Function hvfb_probe() calls hvfb_getmem(), expecting upon return that
    info-&gt;apertures is either NULL or points to memory that should be freed
    by framebuffer_release().  But hvfb_getmem() is freeing the memory and
    leaving the pointer non-NULL, resulting in a double free if an error
    occurs or later if hvfb_remove() is called.
    
    Fix this by removing all kfree(info-&gt;apertures) calls in hvfb_getmem().
    This will allow framebuffer_release() to free the memory, which follows
    the pattern of other fbdev drivers.
    
    Fixes: 3a6fb6c4255c ("video: hyperv: hyperv_fb: Use physical memory for fb on HyperV Gen 1 VMs.")
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Reviewed-by: Michael Kelley &lt;mikelley@microsoft.com&gt;
    Link: https://lore.kernel.org/r/20210324103724.4189-1-lyl2019@mail.ustc.edu.cn
    Signed-off-by: Wei Liu &lt;wei.liu@kernel.org&gt;

diff --git a/drivers/video/fbdev/hyperv_fb.c b/drivers/video/fbdev/hyperv_fb.c
index c8b0ae676809..4dc9077dd2ac 100644
--- a/drivers/video/fbdev/hyperv_fb.c
+++ b/drivers/video/fbdev/hyperv_fb.c
@@ -1031,7 +1031,6 @@ static int hvfb_getmem(struct hv_device *hdev, struct fb_info *info)
 			PCI_DEVICE_ID_HYPERV_VIDEO, NULL);
 		if (!pdev) {
 			pr_err("Unable to find PCI Hyper-V video\n");
-			kfree(info-&gt;apertures);
 			return -ENODEV;
 		}
 
@@ -1129,7 +1128,6 @@ static int hvfb_getmem(struct hv_device *hdev, struct fb_info *info)
 	} else {
 		pci_dev_put(pdev);
 	}
-	kfree(info-&gt;apertures);
 
 	return 0;
 
@@ -1141,7 +1139,6 @@ static int hvfb_getmem(struct hv_device *hdev, struct fb_info *info)
 err1:
 	if (!gen2vm)
 		pci_dev_put(pdev);
-	kfree(info-&gt;apertures);
 
 	return -ENOMEM;
 }</pre><hr><pre>commit 9ceee7d0841a8f7d7644021ba7d4cc1fbc7966e3
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Wed Mar 10 00:31:27 2021 -0800

    firmware/efi: Fix a use after bug in efi_mem_reserve_persistent
    
    In the for loop in efi_mem_reserve_persistent(), prsv = rsv-&gt;next
    use the unmapped rsv. Use the unmapped pages will cause segment
    fault.
    
    Fixes: 18df7577adae6 ("efi/memreserve: deal with memreserve entries in unmapped memory")
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index df3f9bcab581..4b7ee3fa9224 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -927,7 +927,7 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 	}
 
 	/* first try to find a slot in an existing linked list entry */
-	for (prsv = efi_memreserve_root-&gt;next; prsv; prsv = rsv-&gt;next) {
+	for (prsv = efi_memreserve_root-&gt;next; prsv; ) {
 		rsv = memremap(prsv, sizeof(*rsv), MEMREMAP_WB);
 		index = atomic_fetch_add_unless(&amp;rsv-&gt;count, 1, rsv-&gt;size);
 		if (index &lt; rsv-&gt;size) {
@@ -937,6 +937,7 @@ int __ref efi_mem_reserve_persistent(phys_addr_t addr, u64 size)
 			memunmap(rsv);
 			return efi_mem_reserve_iomem(addr, size);
 		}
+		prsv = rsv-&gt;next;
 		memunmap(rsv);
 	}
 </pre><hr><pre>commit c8c165dea4c8f5ad67b1240861e4f6c5395fa4ac
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Wed Mar 10 22:46:36 2021 -0800

    scsi: st: Fix a use after free in st_open()
    
    In st_open(), if STp-&gt;in_use is true, STp will be freed by
    scsi_tape_put(). However, STp is still used by DEBC_printk() after. It is
    better to DEBC_printk() before scsi_tape_put().
    
    Link: https://lore.kernel.org/r/20210311064636.10522-1-lyl2019@mail.ustc.edu.cn
    Acked-by: Kai Mäkisara &lt;kai.makisara@kolumbus.fi&gt;
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c
index 841ad2fc369a..9ca536aae784 100644
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@ -1269,8 +1269,8 @@ static int st_open(struct inode *inode, struct file *filp)
 	spin_lock(&amp;st_use_lock);
 	if (STp-&gt;in_use) {
 		spin_unlock(&amp;st_use_lock);
-		scsi_tape_put(STp);
 		DEBC_printk(STp, "Device already in use.\n");
+		scsi_tape_put(STp);
 		return (-EBUSY);
 	}
 </pre><hr><pre>commit 2bb817712e2f77486d6ee17e7efaf91997a685f8
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Wed Mar 10 22:30:05 2021 -0800

    scsi: myrs: Fix a double free in myrs_cleanup()
    
    In myrs_cleanup(), cs-&gt;mmio_base will be freed twice by iounmap().
    
    Link: https://lore.kernel.org/r/20210311063005.9963-1-lyl2019@mail.ustc.edu.cn
    Fixes: 77266186397c ("scsi: myrs: Add Mylex RAID controller (SCSI interface)")
    Reviewed-by: Hannes Reinecke &lt;hare@suse.de&gt;
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/drivers/scsi/myrs.c b/drivers/scsi/myrs.c
index 4adf9ded296a..329fd025c718 100644
--- a/drivers/scsi/myrs.c
+++ b/drivers/scsi/myrs.c
@@ -2273,12 +2273,12 @@ static void myrs_cleanup(struct myrs_hba *cs)
 	if (cs-&gt;mmio_base) {
 		cs-&gt;disable_intr(cs);
 		iounmap(cs-&gt;mmio_base);
+		cs-&gt;mmio_base = NULL;
 	}
 	if (cs-&gt;irq)
 		free_irq(cs-&gt;irq, cs);
 	if (cs-&gt;io_addr)
 		release_region(cs-&gt;io_addr, 0x80);
-	iounmap(cs-&gt;mmio_base);
 	pci_set_drvdata(pdev, NULL);
 	pci_disable_device(pdev);
 	scsi_host_put(cs-&gt;host);</pre><hr><pre>commit db74623a3850db99cb9692fda9e836a56b74198d
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Wed Mar 10 20:01:40 2021 -0800

    net/qlcnic: Fix a use after free in qlcnic_83xx_get_minidump_template
    
    In qlcnic_83xx_get_minidump_template, fw_dump-&gt;tmpl_hdr was freed by
    vfree(). But unfortunately, it is used when extended is true.
    
    Fixes: 7061b2bdd620e ("qlogic: Deletion of unnecessary checks before two function calls")
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
index 7760a3394e93..7ecb3dfe30bd 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
@@ -1425,6 +1425,7 @@ void qlcnic_83xx_get_minidump_template(struct qlcnic_adapter *adapter)
 
 	if (fw_dump-&gt;tmpl_hdr == NULL || current_version &gt; prev_version) {
 		vfree(fw_dump-&gt;tmpl_hdr);
+		fw_dump-&gt;tmpl_hdr = NULL;
 
 		if (qlcnic_83xx_md_check_extended_dump_capability(adapter))
 			extended = !qlcnic_83xx_extend_md_capab(adapter);
@@ -1443,6 +1444,8 @@ void qlcnic_83xx_get_minidump_template(struct qlcnic_adapter *adapter)
 			struct qlcnic_83xx_dump_template_hdr *hdr;
 
 			hdr = fw_dump-&gt;tmpl_hdr;
+			if (!hdr)
+				return;
 			hdr-&gt;drv_cap_mask = 0x1f;
 			fw_dump-&gt;cap_mask = 0x1f;
 			dev_info(&amp;pdev-&gt;dev,</pre><hr><pre>commit abec6561fc4e0fbb19591a0b35676d8c783b5493
Author: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
Date:   Wed Mar 10 21:44:13 2021 -0800

    nvme-rdma: Fix a use after free in nvmet_rdma_write_data_done
    
    In nvmet_rdma_write_data_done, rsp is recoverd by wc-&gt;wr_cqe and freed by
    nvmet_rdma_release_rsp(). But after that, pr_info() used the freed
    chunk's member object and could leak the freed chunk address with
    wc-&gt;wr_cqe by computing the offset.
    
    Signed-off-by: Lv Yunlong &lt;lyl2019@mail.ustc.edu.cn&gt;
    Signed-off-by: Christoph Hellwig &lt;hch@lst.de&gt;

diff --git a/drivers/nvme/target/rdma.c b/drivers/nvme/target/rdma.c
index 06b6b742bb21..6c1f3ab7649c 100644
--- a/drivers/nvme/target/rdma.c
+++ b/drivers/nvme/target/rdma.c
@@ -802,9 +802,8 @@ static void nvmet_rdma_write_data_done(struct ib_cq *cq, struct ib_wc *wc)
 		nvmet_req_uninit(&amp;rsp-&gt;req);
 		nvmet_rdma_release_rsp(rsp);
 		if (wc-&gt;status != IB_WC_WR_FLUSH_ERR) {
-			pr_info("RDMA WRITE for CQE 0x%p failed with status %s (%d).\n",
-				wc-&gt;wr_cqe, ib_wc_status_msg(wc-&gt;status),
-				wc-&gt;status);
+			pr_info("RDMA WRITE for CQE failed with status %s (%d).\n",
+				ib_wc_status_msg(wc-&gt;status), wc-&gt;status);
 			nvmet_rdma_error_comp(queue);
 		}
 		return;</pre><hr><pre>commit d1c2b5010d07e967d7cbcc232a86b2308d824ca3
Author: He Chunhui &lt;hchunhui@mail.ustc.edu.cn&gt;
Date:   Tue Jul 26 06:16:52 2016 +0000

    net: neigh: disallow transition to NUD_STALE if lladdr is unchanged in neigh_update()
    
    NUD_STALE is used when the caller(e.g. arp_process()) can't guarantee
    neighbour reachability. If the entry was NUD_VALID and lladdr is unchanged,
    the entry state should not be changed.
    
    Currently the code puts an extra "NUD_CONNECTED" condition. So if old state
    was NUD_DELAY or NUD_PROBE (they are NUD_VALID but not NUD_CONNECTED), the
    state can be changed to NUD_STALE.
    
    This may cause problem. Because NUD_STALE lladdr doesn't guarantee
    reachability, when we send traffic, the state will be changed to
    NUD_DELAY. In normal case, if we get no confirmation (by dst_confirm()),
    we will change the state to NUD_PROBE and send probe traffic. But now the
    state may be reset to NUD_STALE again(e.g. by broadcast ARP packets),
    so the probe traffic will not be sent. This situation may happen again and
    again, and packets will be sent to an non-reachable lladdr forever.
    
    The fix is to remove the "NUD_CONNECTED" condition. After that the
    "NEIGH_UPDATE_F_WEAK_OVERRIDE" condition (used by IPv6) in that branch will
    be redundant, so remove it.
    
    This change may increase probe traffic, but it's essential since NUD_STALE
    lladdr is unreliable. To ensure correctness, we prefer to resolve lladdr,
    when we can't get confirmation, even while remote packets try to set
    NUD_STALE state.
    
    Signed-off-by: Chunhui He &lt;hchunhui@mail.ustc.edu.cn&gt;
    Signed-off-by: Julian Anastasov &lt;ja@ssi.bg&gt;
    Reviewed-by: Hannes Frederic Sowa &lt;hannes@stressinduktion.org&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index 5cdc62a8eb84..cf26e04c4046 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -1060,8 +1060,6 @@ static void neigh_update_hhs(struct neighbour *neigh)
 	NEIGH_UPDATE_F_WEAK_OVERRIDE will suspect existing "connected"
 				lladdr instead of overriding it
 				if it is different.
-				It also allows to retain current state
-				if lladdr is unchanged.
 	NEIGH_UPDATE_F_ADMIN	means that the change is administrative.
 
 	NEIGH_UPDATE_F_OVERRIDE_ISROUTER allows to override existing
@@ -1150,10 +1148,7 @@ int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,
 			} else
 				goto out;
 		} else {
-			if (lladdr == neigh-&gt;ha &amp;&amp; new == NUD_STALE &amp;&amp;
-			    ((flags &amp; NEIGH_UPDATE_F_WEAK_OVERRIDE) ||
-			     (old &amp; NUD_CONNECTED))
-			    )
+			if (lladdr == neigh-&gt;ha &amp;&amp; new == NUD_STALE)
 				new = old;
 		}
 	}</pre>
    <div class="pagination">
        <a href='12_3.html'>&lt;&lt;Prev</a><a href='12.html'>1</a><a href='12_2.html'>2</a><a href='12_3.html'>3</a><span>[4]</span><a href='12_5.html'>5</a><a href='12_6.html'>6</a><a href='12_7.html'>7</a><a href='12_8.html'>8</a><a href='12_9.html'>9</a><a href='12_5.html'>Next&gt;&gt;</a>
    <div>
</body>
