<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_118.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><span>[119]</span><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_120.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8d1a243ba5dda5c1a3cca5df8fb19ab8b138f074
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 14:46:16 2006 -0400

    OHCI: add auto-stop support
    
    This patch (as790b) adds "autostop" support to ohci-hcd: the driver
    will automatically stop the host controller when no devices have been
    connected for at least one second.  This feature is useful when the
    USB autosuspend facility isn't available, such as when
    CONFIG_USB_SUSPEND hasn't been set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 1027aa04583d..d1d68c402251 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -715,17 +715,8 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd, struct pt_regs *ptregs)
 		return IRQ_NOTMINE;
 	}
 
-	/* NOTE:  vendors didn't always make the same implementation
-	 * choices for RHSC.  Sometimes it triggers on an edge (like
-	 * setting and maybe clearing a port status change bit); and
-	 * it's level-triggered on other silicon, active until khubd
-	 * clears all active port status change bits.  Poll by timer
-	 * til it's fully debounced and the difference won't matter.
-	 */
 	if (ints &amp; OHCI_INTR_RHSC) {
 		ohci_vdbg (ohci, "rhsc\n");
-		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;regs-&gt;intrdisable);
-		hcd-&gt;poll_rh = 1;
 		ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
 		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;regs-&gt;intrstatus);
 		usb_hcd_poll_rh_status(hcd);
@@ -743,13 +734,18 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd, struct pt_regs *ptregs)
 	if (ints &amp; OHCI_INTR_RD) {
 		ohci_vdbg (ohci, "resume detect\n");
 		ohci_writel (ohci, OHCI_INTR_RD, &amp;regs-&gt;intrstatus);
-		if (hcd-&gt;state != HC_STATE_QUIESCING)
+		hcd-&gt;poll_rh = 1;
+		if (ohci-&gt;autostop) {
+			spin_lock (&amp;ohci-&gt;lock);
+			ohci_rh_resume (ohci);
+			spin_unlock (&amp;ohci-&gt;lock);
+		} else
 			usb_hcd_resume_root_hub(hcd);
 	}
 
 	if (ints &amp; OHCI_INTR_WDH) {
 		if (HC_IS_RUNNING(hcd-&gt;state))
-			ohci_writel (ohci, OHCI_INTR_WDH, &amp;regs-&gt;intrdisable);	
+			ohci_writel (ohci, OHCI_INTR_WDH, &amp;regs-&gt;intrdisable);
 		spin_lock (&amp;ohci-&gt;lock);
 		dl_done_list (ohci, ptregs);
 		spin_unlock (&amp;ohci-&gt;lock);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index ef4965450de5..f36cbd02736d 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -41,31 +41,20 @@ static void ohci_rhsc_enable (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
-	hcd-&gt;poll_rh = 0;
 	ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
 }
 
-#ifdef	CONFIG_PM
-
 #define OHCI_SCHED_ENABLES \
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
 static void dl_done_list (struct ohci_hcd *, struct pt_regs *);
 static void finish_unlinks (struct ohci_hcd *, u16 , struct pt_regs *);
-static int ohci_restart (struct ohci_hcd *ohci);
 
-static int ohci_bus_suspend (struct usb_hcd *hcd)
+static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
+__releases(ohci-&gt;lock)
+__acquires(ohci-&gt;lock)
 {
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	int			status = 0;
-	unsigned long		flags;
-
-	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))) {
-		spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
-		return -ESHUTDOWN;
-	}
 
 	ohci-&gt;hc_control = ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
@@ -81,15 +70,16 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 		ohci_dbg (ohci, "needs reinit!\n");
 		goto done;
 	case OHCI_USB_SUSPEND:
-		ohci_dbg (ohci, "already suspended\n");
-		goto done;
+		if (!ohci-&gt;autostop) {
+			ohci_dbg (ohci, "already suspended\n");
+			goto done;
+		}
 	}
-	ohci_dbg (ohci, "suspend root hub\n");
+	ohci_dbg (ohci, "%s root hub\n",
+			autostop ? "auto-stop" : "suspend");
 
 	/* First stop any processing */
-	if (ohci-&gt;hc_control &amp; OHCI_SCHED_ENABLES) {
-		int		limit;
-
+	if (!autostop &amp;&amp; (ohci-&gt;hc_control &amp; OHCI_SCHED_ENABLES)) {
 		ohci-&gt;hc_control &amp;= ~OHCI_SCHED_ENABLES;
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 		ohci-&gt;hc_control = ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
@@ -99,24 +89,17 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 		 * then the last WDH could take 6+ msec
 		 */
 		ohci_dbg (ohci, "stopping schedules ...\n");
-		limit = 2000;
-		while (limit &gt; 0) {
-			udelay (250);
-			limit =- 250;
-			if (ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus)
-					&amp; OHCI_INTR_SF)
-				break;
-		}
-		dl_done_list (ohci, NULL);
-		mdelay (7);
+		ohci-&gt;autostop = 0;
+		spin_unlock_irq (&amp;ohci-&gt;lock);
+		msleep (8);
+		spin_lock_irq (&amp;ohci-&gt;lock);
 	}
 	dl_done_list (ohci, NULL);
 	finish_unlinks (ohci, ohci_frame_no(ohci), NULL);
-	ohci_writel (ohci, ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus),
-			&amp;ohci-&gt;regs-&gt;intrstatus);
 
 	/* maybe resume can wake root hub */
-	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev))
+	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev) ||
+			autostop)
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
 	else {
 		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
@@ -132,13 +115,12 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 
 	/* no resumes until devices finish suspending */
-	ohci-&gt;next_statechange = jiffies + msecs_to_jiffies (5);
-
-	/* no timer polling */
-	hcd-&gt;poll_rh = 0;
+	if (!autostop) {
+		ohci-&gt;next_statechange = jiffies + msecs_to_jiffies (5);
+		ohci-&gt;autostop = 0;
+	}
 
 done:
-	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return status;
 }
 
@@ -151,24 +133,16 @@ static inline struct ed *find_head (struct ed *ed)
 }
 
 /* caller has locked the root hub */
-static int ohci_bus_resume (struct usb_hcd *hcd)
+static int ohci_rh_resume (struct ohci_hcd *ohci)
+__releases(ohci-&gt;lock)
+__acquires(ohci-&gt;lock)
 {
-	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	struct usb_hcd		*hcd = ohci_to_hcd (ohci);
 	u32			temp, enables;
 	int			status = -EINPROGRESS;
-	unsigned long		flags;
-
-	if (time_before (jiffies, ohci-&gt;next_statechange))
-		msleep(5);
-
-	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))) {
-		spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
-		return -ESHUTDOWN;
-	}
-
+	int			autostopped = ohci-&gt;autostop;
 
+	ohci-&gt;autostop = 0;
 	ohci-&gt;hc_control = ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 
 	if (ohci-&gt;hc_control &amp; (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
@@ -188,7 +162,8 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 		ohci-&gt;hc_control |= OHCI_USB_RESUME;
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
-		ohci_dbg (ohci, "resume root hub\n");
+		ohci_dbg (ohci, "%s root hub\n",
+				autostopped ? "auto-start" : "resume");
 		break;
 	case OHCI_USB_RESUME:
 		/* HCFS changes sometime after INTR_RD */
@@ -203,16 +178,26 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 		ohci_dbg (ohci, "lost power\n");
 		status = -EBUSY;
 	}
-	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
+#ifdef	CONFIG_PM
 	if (status == -EBUSY) {
-		(void) ohci_init (ohci);
-		return ohci_restart (ohci);
+		if (!autostopped) {
+			static int ohci_restart (struct ohci_hcd *ohci);
+
+			spin_unlock_irq (&amp;ohci-&gt;lock);
+			(void) ohci_init (ohci);
+			status = ohci_restart (ohci);
+			spin_lock_irq (&amp;ohci-&gt;lock);
+		}
+		return status;
 	}
+#endif
 	if (status != -EINPROGRESS)
 		return status;
+	if (autostopped)
+		goto skip_resume;
+	spin_unlock_irq (&amp;ohci-&gt;lock);
 
 	temp = ohci-&gt;num_ports;
-	enables = 0;
 	while (temp--) {
 		u32 stat = ohci_readl (ohci,
 				       &amp;ohci-&gt;regs-&gt;roothub.portstatus [temp]);
@@ -245,17 +230,21 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	/* Sometimes PCI D3 suspend trashes frame timings ... */
 	periodic_reinit (ohci);
 
+	/* the following code is executed with ohci-&gt;lock held and
+	 * irqs disabled if and only if autostopped is true
+	 */
+
+skip_resume:
 	/* interrupts might have been disabled */
 	ohci_writel (ohci, OHCI_INTR_INIT, &amp;ohci-&gt;regs-&gt;intrenable);
 	if (ohci-&gt;ed_rm_list)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;ohci-&gt;regs-&gt;intrenable);
-	ohci_writel (ohci, ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus),
-			&amp;ohci-&gt;regs-&gt;intrstatus);
 
 	/* Then re-enable operations */
 	ohci_writel (ohci, OHCI_USB_OPER, &amp;ohci-&gt;regs-&gt;control);
 	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
-	msleep (3);
+	if (!autostopped)
+		msleep (3);
 
 	temp = ohci-&gt;hc_control;
 	temp &amp;= OHCI_CTRL_RWC;
@@ -265,7 +254,11 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 
 	/* TRSMRCY */
-	msleep (10);
+	if (!autostopped) {
+		msleep (10);
+		spin_lock_irq (&amp;ohci-&gt;lock);
+	}
+	/* now ohci-&gt;lock is always held and irqs are always disabled */
 
 	/* keep it alive for more than ~5x suspend + resume costs */
 	ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
@@ -302,6 +295,45 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	return 0;
 }
 
+#ifdef	CONFIG_PM
+
+static int ohci_bus_suspend (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			rc;
+
+	spin_lock_irq (&amp;ohci-&gt;lock);
+
+	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)))
+		rc = -ESHUTDOWN;
+	else
+		rc = ohci_rh_suspend (ohci, 0);
+	spin_unlock_irq (&amp;ohci-&gt;lock);
+	return rc;
+}
+
+static int ohci_bus_resume (struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
+	int			rc;
+
+	if (time_before (jiffies, ohci-&gt;next_statechange))
+		msleep(5);
+
+	spin_lock_irq (&amp;ohci-&gt;lock);
+
+	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)))
+		rc = -ESHUTDOWN;
+	else
+		rc = ohci_rh_resume (ohci);
+	spin_unlock_irq (&amp;ohci-&gt;lock);
+
+	/* poll until we know a device is connected or we autostop */
+	if (rc == 0)
+		usb_hcd_poll_rh_status(hcd);
+	return rc;
+}
+
 #endif	/* CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
@@ -313,17 +345,11 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		i, changed = 0, length = 1;
+	int		any_connected = 0, rhsc_enabled = 1;
 	unsigned long	flags;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 
-	/* handle autosuspended root:  finish resuming before
-	 * letting khubd or root hub timer see state changes.
-	 */
-	if (unlikely((ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) != OHCI_USB_OPER
-		     || !HC_IS_RUNNING(hcd-&gt;state)))
-		goto done;
-
 	/* undocumented erratum seen on at least rev D */
 	if ((ohci-&gt;flags &amp; OHCI_QUIRK_AMD756)
 			&amp;&amp; (roothub_a (ohci) &amp; RH_A_NDP) &gt; MAX_ROOT_PORTS) {
@@ -347,6 +373,9 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	for (i = 0; i &lt; ohci-&gt;num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);
 
+		/* can't autostop if ports are connected */
+		any_connected |= (status &amp; RH_PS_CCS);
+
 		if (status &amp; (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
 				| RH_PS_OCIC | RH_PS_PRSC)) {
 			changed = 1;
@@ -354,15 +383,69 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 			    buf [0] |= 1 &lt;&lt; (i + 1);
 			else
 			    buf [1] |= 1 &lt;&lt; (i - 7);
-			continue;
 		}
 	}
 
-	/* after root hub changes, stop polling after debouncing
-	 * for a while and maybe kicking in autosuspend
+	/* NOTE:  vendors didn't always make the same implementation
+	 * choices for RHSC.  Sometimes it triggers on an edge (like
+	 * setting and maybe clearing a port status change bit); and
+	 * it's level-triggered on other silicon, active until khubd
+	 * clears all active port status change bits.  If it's still
+	 * set (level-triggered) we must disable it and rely on
+	 * polling until khubd re-enables it.
 	 */
-	if (changed)
-		ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
+	if (ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp; OHCI_INTR_RHSC) {
+		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
+		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrdisable);
+		rhsc_enabled = 0;
+	}
+	hcd-&gt;poll_rh = 1;
+
+	/* carry out appropriate state changes */
+	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
+
+	case OHCI_USB_OPER:
+		/* keep on polling until we know a device is connected
+		 * and RHSC is enabled */
+		if (!ohci-&gt;autostop) {
+			if (any_connected) {
+				if (rhsc_enabled)
+					hcd-&gt;poll_rh = 0;
+			} else {
+				ohci-&gt;autostop = 1;
+				ohci-&gt;next_statechange = jiffies + HZ;
+			}
+
+		/* if no devices have been attached for one second, autostop */
+		} else {
+			if (changed || any_connected) {
+				ohci-&gt;autostop = 0;
+				ohci-&gt;next_statechange = jiffies +
+						STATECHANGE_DELAY;
+			} else if (time_after_eq (jiffies,
+						ohci-&gt;next_statechange)
+					&amp;&amp; !ohci-&gt;ed_rm_list
+					&amp;&amp; !(ohci-&gt;hc_control &amp;
+						OHCI_SCHED_ENABLES)) {
+				ohci_rh_suspend (ohci, 1);
+			}
+		}
+		break;
+
+	/* if there is a port change, autostart or ask to be resumed */
+	case OHCI_USB_SUSPEND:
+	case OHCI_USB_RESUME:
+		if (changed) {
+			if (ohci-&gt;autostop)
+				ohci_rh_resume (ohci);
+			else
+				usb_hcd_resume_root_hub (hcd);
+		} else {
+			/* everything is idle, no need for polling */
+			hcd-&gt;poll_rh = 0;
+		}
+		break;
+	}
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 93fdc3c35341..a2f42a2f47c6 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -388,6 +388,7 @@ struct ohci_hcd {
 	u32 			hc_control;	/* copy of hc control reg */
 	unsigned long		next_statechange;	/* suspend/resume */
 	u32			fminterval;		/* saved register */
+	unsigned		autostop:1;	/* rh auto stopping/stopped */
 
 	unsigned long		flags;		/* for HC bugs */
 #define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */</pre><hr><pre>commit 1f7e1a3b7e05c833229c4b6e9d3c96262df59e99
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 15:41:21 2006 -0400

    OHCI: remove existing autosuspend code
    
    The autosuspend technique used by ohci-hcd doesn't mesh well with the
    newer USB core autosuspend code.  This patch (as789) removes ohci-hcd's
    autosuspend support.  Now the driver will be usable, but it won't
    automatically go into a low-power state when no devices are connected.
    That's for a later patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 0b899339cac8..ef4965450de5 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -41,6 +41,7 @@ static void ohci_rhsc_enable (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
+	hcd-&gt;poll_rh = 0;
 	ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
 }
 
@@ -117,8 +118,10 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	/* maybe resume can wake root hub */
 	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev))
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
-	else
+	else {
+		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
 		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_RWE;
+	}
 
 	/* Suspend hub ... this is the "global (to this bus) suspend" mode,
 	 * which doesn't imply ports will first be individually suspended.
@@ -310,20 +313,16 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		i, changed = 0, length = 1;
-	int		can_suspend;
 	unsigned long	flags;
 
-	can_suspend = device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev);
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
 
 	/* handle autosuspended root:  finish resuming before
 	 * letting khubd or root hub timer see state changes.
 	 */
 	if (unlikely((ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) != OHCI_USB_OPER
-		     || !HC_IS_RUNNING(hcd-&gt;state))) {
-		can_suspend = 0;
+		     || !HC_IS_RUNNING(hcd-&gt;state)))
 		goto done;
-	}
 
 	/* undocumented erratum seen on at least rev D */
 	if ((ohci-&gt;flags &amp; OHCI_QUIRK_AMD756)
@@ -348,10 +347,6 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	for (i = 0; i &lt; ohci-&gt;num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);
 
-		/* can't autosuspend with active ports */
-		if ((status &amp; RH_PS_PES) &amp;&amp; !(status &amp; RH_PS_PSS))
-			can_suspend = 0;
-
 		if (status &amp; (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC
 				| RH_PS_OCIC | RH_PS_PRSC)) {
 			changed = 1;
@@ -366,42 +361,12 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	/* after root hub changes, stop polling after debouncing
 	 * for a while and maybe kicking in autosuspend
 	 */
-	if (changed) {
+	if (changed)
 		ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
-		can_suspend = 0;
-	} else if (time_before (jiffies, ohci-&gt;next_statechange)) {
-		can_suspend = 0;
-	} else {
-#ifdef	CONFIG_PM
-		can_suspend = can_suspend
-			&amp;&amp; !ohci-&gt;ed_rm_list
-			&amp;&amp; ((OHCI_CTRL_HCFS | OHCI_SCHED_ENABLES)
-					&amp; ohci-&gt;hc_control)
-				== OHCI_USB_OPER;
-#endif
-		if (hcd-&gt;uses_new_polling) {
-			hcd-&gt;poll_rh = 0;
-			/* use INTR_RHSC iff INTR_RD won't apply */
-			if (!can_suspend)
-				ohci_writel (ohci, OHCI_INTR_RHSC,
-						&amp;ohci-&gt;regs-&gt;intrenable);
-		}
-	}
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 
-#ifdef	CONFIG_PM
-	/* save power by autosuspending idle root hubs;
-	 * INTR_RD wakes us when there's work
-	 */
-	if (can_suspend &amp;&amp; usb_trylock_device (hcd-&gt;self.root_hub) == 0) {
-		ohci_vdbg (ohci, "autosuspend\n");
-		(void) ohci_bus_suspend (hcd);
-		usb_unlock_device (hcd-&gt;self.root_hub);
-	}
-#endif
-
 	return changed ? length : 0;
 }
 
@@ -572,9 +537,6 @@ static int ohci_hub_control (
 			break;
 		case USB_PORT_FEAT_SUSPEND:
 			temp = RH_PS_POCI;
-			if ((ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS)
-					!= OHCI_USB_OPER)
-				usb_hcd_resume_root_hub(hcd);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			temp = RH_PS_PSSC;</pre><hr><pre>commit d19ac7da72ab950c315d0da0aa03464587d88b53
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 15:41:12 2006 -0400

    USB: allow both root-hub interrupts and polling
    
    Originally I didn't think any host controller driver would ever use
    interrupts and polling at the same time, but it turns out ohci-hcd wants
    to do exactly that.  This patch (as788) makes it possible.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 0d5cbf254e5e..37f9f5e7425d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -836,8 +836,7 @@ void usb_enable_root_hub_irq (struct usb_bus *bus)
 	struct usb_hcd *hcd;
 
 	hcd = container_of (bus, struct usb_hcd, self);
-	if (hcd-&gt;driver-&gt;hub_irq_enable &amp;&amp; !hcd-&gt;poll_rh &amp;&amp;
-			hcd-&gt;state != HC_STATE_HALT)
+	if (hcd-&gt;driver-&gt;hub_irq_enable &amp;&amp; hcd-&gt;state != HC_STATE_HALT)
 		hcd-&gt;driver-&gt;hub_irq_enable (hcd);
 }
 </pre><hr><pre>commit 2de9eaefa7330b8e3d3fc5f31288cb1e826173a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 14:31:15 2006 -0400

    USB: g_file_storage: fix "ignoring return value" warnings
    
    This patch (as792) fixes "ignoring return value" warnings in
    file_storage.c.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 8d7f1e84cd7b..d472c9c29904 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -3873,21 +3873,26 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 	for (i = 0; i &lt; fsg-&gt;nluns; ++i) {
 		curlun = &amp;fsg-&gt;luns[i];
 		curlun-&gt;ro = mod_data.ro[i];
+		curlun-&gt;dev.release = lun_release;
 		curlun-&gt;dev.parent = &amp;gadget-&gt;dev;
 		curlun-&gt;dev.driver = &amp;fsg_driver.driver;
 		dev_set_drvdata(&amp;curlun-&gt;dev, fsg);
 		snprintf(curlun-&gt;dev.bus_id, BUS_ID_SIZE,
 				"%s-lun%d", gadget-&gt;dev.bus_id, i);
 
-		if ((rc = device_register(&amp;curlun-&gt;dev)) != 0)
+		if ((rc = device_register(&amp;curlun-&gt;dev)) != 0) {
 			INFO(fsg, "failed to register LUN%d: %d\n", i, rc);
-		else {
-			curlun-&gt;registered = 1;
-			curlun-&gt;dev.release = lun_release;
-			device_create_file(&amp;curlun-&gt;dev, &amp;dev_attr_ro);
-			device_create_file(&amp;curlun-&gt;dev, &amp;dev_attr_file);
-			kref_get(&amp;fsg-&gt;ref);
+			goto out;
+		}
+		if ((rc = device_create_file(&amp;curlun-&gt;dev,
+					&amp;dev_attr_ro)) != 0 ||
+				(rc = device_create_file(&amp;curlun-&gt;dev,
+					&amp;dev_attr_file)) != 0) {
+			device_unregister(&amp;curlun-&gt;dev);
+			goto out;
 		}
+		curlun-&gt;registered = 1;
+		kref_get(&amp;fsg-&gt;ref);
 
 		if (mod_data.file[i] &amp;&amp; *mod_data.file[i]) {
 			if ((rc = open_backing_file(curlun,</pre><hr><pre>commit efd54a364121f61b2050b1df5ecb1b8329c4eaba
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 25 11:55:56 2006 -0400

    USB: dummy-hcd: fix "warn-unused-result" messages
    
    This patch (as758) fixes the "warn-unused-result" messages in dummy-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index fdab97a27c08..4d2946e540cf 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -816,15 +816,14 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 	dum-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
 	dev_dbg (udc_dev(dum), "binding gadget driver '%s'\n",
 			driver-&gt;driver.name);
-	if ((retval = driver-&gt;bind (&amp;dum-&gt;gadget)) != 0) {
-		dum-&gt;driver = NULL;
-		dum-&gt;gadget.dev.driver = NULL;
-		return retval;
-	}
+	if ((retval = driver-&gt;bind (&amp;dum-&gt;gadget)) != 0)
+		goto err_bind_gadget;
 
 	driver-&gt;driver.bus = dum-&gt;gadget.dev.parent-&gt;bus;
-	driver_register (&amp;driver-&gt;driver);
-	device_bind_driver (&amp;dum-&gt;gadget.dev);
+	if ((retval = driver_register (&amp;driver-&gt;driver)) != 0)
+		goto err_register;
+	if ((retval = device_bind_driver (&amp;dum-&gt;gadget.dev)) != 0)
+		goto err_bind_driver;
 
 	/* khubd will enumerate this in a while */
 	spin_lock_irq (&amp;dum-&gt;lock);
@@ -834,6 +833,19 @@ usb_gadget_register_driver (struct usb_gadget_driver *driver)
 
 	usb_hcd_poll_rh_status (dummy_to_hcd (dum));
 	return 0;
+
+err_bind_driver:
+	driver_unregister (&amp;driver-&gt;driver);
+err_register:
+	driver-&gt;unbind (&amp;dum-&gt;gadget);
+	spin_lock_irq (&amp;dum-&gt;lock);
+	dum-&gt;pullup = 0;
+	set_link_state (dum);
+	spin_unlock_irq (&amp;dum-&gt;lock);
+err_bind_gadget:
+	dum-&gt;driver = NULL;
+	dum-&gt;gadget.dev.driver = NULL;
+	return retval;
 }
 EXPORT_SYMBOL (usb_gadget_register_driver);
 
@@ -916,7 +928,9 @@ static int dummy_udc_probe (struct platform_device *pdev)
 	usb_get_hcd (dummy_to_hcd (dum));
 
 	platform_set_drvdata (pdev, dum);
-	device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	rc = device_create_file (&amp;dum-&gt;gadget.dev, &amp;dev_attr_function);
+	if (rc &lt; 0)
+		device_unregister (&amp;dum-&gt;gadget.dev);
 	return rc;
 }
 
@@ -1864,8 +1878,7 @@ static int dummy_start (struct usb_hcd *hcd)
 #endif
 
 	/* FIXME 'urbs' should be a per-device thing, maybe in usbcore */
-	device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
-	return 0;
+	return device_create_file (dummy_dev(dum), &amp;dev_attr_urbs);
 }
 
 static void dummy_stop (struct usb_hcd *hcd)</pre><hr><pre>commit bd859281c09b4318153dc7222b5e9052aad83b61
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 19 10:14:07 2006 -0400

    USB: create new workqueue thread for USB autosuspend
    
    This patch (as787) creates a new workqueue thread to handle delayed
    USB autosuspend requests.  Previously the code used keventd.  However
    it turns out that the hub driver's suspend routine calls
    flush_scheduled_work(), making it a poor candidate for running in
    keventd (the call immediately deadlocks).  The solution is to use a
    new thread instead of keventd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index c2aad6a4d49f..ee18d187ca17 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -24,6 +24,7 @@
 
 #include &lt;linux/device.h&gt;
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/workqueue.h&gt;
 #include "hcd.h"
 #include "usb.h"
 
@@ -1131,7 +1132,7 @@ void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
 	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
 	if (udev-&gt;pm_usage_cnt &lt;= 0)
-		schedule_delayed_work(&amp;udev-&gt;autosuspend,
+		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 				USB_AUTOSUSPEND_DELAY);
 	mutex_unlock(&amp;udev-&gt;pm_mutex);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
@@ -1215,10 +1216,10 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 	struct usb_device	*udev = interface_to_usbdev(intf);
 
 	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
-	if (intf-&gt;condition != USB_INTERFACE_UNBOUND) {
-		if (--intf-&gt;pm_usage_cnt &lt;= 0)
-			schedule_delayed_work(&amp;udev-&gt;autosuspend,
-					USB_AUTOSUSPEND_DELAY);
+	if (intf-&gt;condition != USB_INTERFACE_UNBOUND &amp;&amp;
+			--intf-&gt;pm_usage_cnt &lt;= 0) {
+		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
+				USB_AUTOSUSPEND_DELAY);
 	}
 	mutex_unlock(&amp;udev-&gt;pm_mutex);
 	// dev_dbg(&amp;intf-&gt;dev, "%s: cnt %d\n",
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 60ef4ef0101a..239f8e5d247f 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -33,6 +33,7 @@
 #include &lt;linux/smp_lock.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/mutex.h&gt;
+#include &lt;linux/workqueue.h&gt;
 
 #include &lt;asm/io.h&gt;
 #include &lt;asm/scatterlist.h&gt;
@@ -47,6 +48,8 @@ const char *usbcore_name = "usbcore";
 
 static int nousb;	/* Disable USB when built into kernel image */
 
+struct workqueue_struct *ksuspend_usb_wq;	/* For autosuspend */
+
 
 /**
  * usb_ifnum_to_if - get the interface object with a given interface number
@@ -170,9 +173,9 @@ static void usb_release_dev(struct device *dev)
 
 	udev = to_usb_device(dev);
 
-#ifdef	CONFIG_PM
+#ifdef	CONFIG_USB_SUSPEND
 	cancel_delayed_work(&amp;udev-&gt;autosuspend);
-	flush_scheduled_work();
+	flush_workqueue(ksuspend_usb_wq);
 #endif
 	usb_destroy_configuration(udev);
 	usb_put_hcd(bus_to_hcd(udev-&gt;bus));
@@ -184,6 +187,28 @@ static void usb_release_dev(struct device *dev)
 
 #ifdef	CONFIG_PM
 
+static int ksuspend_usb_init(void)
+{
+	ksuspend_usb_wq = create_singlethread_workqueue("ksuspend_usbd");
+	if (!ksuspend_usb_wq)
+		return -ENOMEM;
+	return 0;
+}
+
+static void ksuspend_usb_cleanup(void)
+{
+	destroy_workqueue(ksuspend_usb_wq);
+}
+
+#else
+
+#define ksuspend_usb_init()	0
+#define ksuspend_usb_cleanup()	do {} while (0)
+
+#endif
+
+#ifdef	CONFIG_USB_SUSPEND
+
 /* usb_autosuspend_work - callback routine to autosuspend a USB device */
 static void usb_autosuspend_work(void *_udev)
 {
@@ -195,6 +220,11 @@ static void usb_autosuspend_work(void *_udev)
 	mutex_unlock(&amp;udev-&gt;pm_mutex);
 }
 
+#else
+
+static void usb_autosuspend_work(void *_udev)
+{}
+
 #endif
 
 /**
@@ -976,9 +1006,12 @@ static int __init usb_init(void)
 		return 0;
 	}
 
+	retval = ksuspend_usb_init();
+	if (retval)
+		goto out;
 	retval = bus_register(&amp;usb_bus_type);
 	if (retval) 
-		goto out;
+		goto bus_register_failed;
 	retval = usb_host_init();
 	if (retval)
 		goto host_init_failed;
@@ -1014,6 +1047,8 @@ static int __init usb_init(void)
 	usb_host_cleanup();
 host_init_failed:
 	bus_unregister(&amp;usb_bus_type);
+bus_register_failed:
+	ksuspend_usb_cleanup();
 out:
 	return retval;
 }
@@ -1035,6 +1070,7 @@ static void __exit usb_exit(void)
 	usb_hub_cleanup();
 	usb_host_cleanup();
 	bus_unregister(&amp;usb_bus_type);
+	ksuspend_usb_cleanup();
 }
 
 subsys_initcall(usb_init);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 0c09ecced6e1..fb6eb41c374f 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -62,6 +62,7 @@ extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
 
 #endif
 
+extern struct workqueue_struct *ksuspend_usb_wq;
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 </pre><hr><pre>commit 7923811a46f7e29ae8052edf2461e6c6b8ec2415
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 28 12:11:56 2006 -0400

    USB: unusual-devs entry for Nokia E60
    
    This patch (as794) adds an unusual_devs entry for the Nokia E60.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 40bf159f7d54..16baa105ed0a 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -152,6 +152,13 @@ UNUSUAL_DEV(  0x0421, 0x042e, 0x0100, 0x0100,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE | US_FL_FIX_CAPACITY ),
 
+/* Reported by Jon Hart &lt;Jon.Hart@web.de&gt; */
+UNUSUAL_DEV(  0x0421, 0x0434, 0x0100, 0x0100,
+		"Nokia",
+		"E60",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY | US_FL_IGNORE_RESIDUE ),
+
 /* Reported by Sumedha Swamy &lt;sumedhaswamy@gmail.com&gt; and
  * Einar Th. Einarsson &lt;einarthered@gmail.com&gt; */
 UNUSUAL_DEV(  0x0421, 0x0444, 0x0100, 0x0100,</pre><hr><pre>commit 353a4098c61272b33a02ec5802fb3859fec91a0e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 19 10:07:58 2006 -0400

    USB: force root hub resume after power loss
    
    This patch(as785) forces the PM core to resume a root hub after a
    power loss during system sleep.  If the root hub had been suspended
    before the system sleep then normally the PM core would not resume it
    afterward.  Without this resume, various sorts of wakeup events (like
    port change events) can get lost.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c74baad19b16..00441cde4588 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1053,6 +1053,12 @@ void usb_root_hub_lost_power(struct usb_device *rhdev)
 	unsigned long flags;
 
 	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
+
+	/* Make sure no potential wakeup events get lost,
+	 * by forcing the root hub to be resumed.
+	 */
+	rhdev-&gt;dev.power.prev_state.event = PM_EVENT_ON;
+
 	spin_lock_irqsave(&amp;device_state_lock, flags);
 	hub = hdev_to_hub(rhdev);
 	for (port1 = 1; port1 &lt;= rhdev-&gt;maxchild; ++port1) {</pre><hr><pre>commit 592fbbe4bc339399d363dd55f0391e0623400706
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 19 10:08:43 2006 -0400

    USB: fix root-hub resume when CONFIG_USB_SUSPEND is not set
    
    This patch (as786) removes a redundant test and fixes a problem
    involving repeated system sleeps when CONFIG_USB_SUSPEND is not set.
    During the first wakeup, the root hub's dev.power.power_state.event
    field doesn't get updated, causing it not to be suspended during the
    second sleep transition.
    
    This takes care of the issue raised by Rafael J. Wysocki and Mattia
    Dongili.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2b2000ac05ab..0d063c8ca4b4 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1071,10 +1071,15 @@ int usb_resume_both(struct usb_device *udev)
 					PM_EVENT_ON)
 				status = -EHOSTUNREACH;
 		}
-		if (status == 0 &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
+		if (status == 0)
 			status = resume_device(udev);
 		if (parent)
 			mutex_unlock(&amp;parent-&gt;pm_mutex);
+	} else {
+
+		/* Needed only for setting udev-&gt;dev.power.power_state.event
+		 * and for possible debugging message. */
+		status = resume_device(udev);
 	}
 
 	/* Now the parent won't suspend until we are finished */</pre><hr><pre>commit 02c399ee45a54987c152fe5f627ed949bb55f187
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 30 15:47:11 2006 -0400

    usbcore: remove usb_suspend_root_hub
    
    This patch (as740) removes the existing support for autosuspend of
    root hubs.  That support fit in rather awkwardly with the rest of
    usbcore and it was used only by ohci-hcd.  It won't be needed any more
    since the hub driver will take care of autosuspending all hubs, root
    or external.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 9dfc812de034..e86f62957085 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1431,50 +1431,6 @@ int hcd_bus_resume (struct usb_bus *bus)
 	return status;
 }
 
-/*
- * usb_hcd_suspend_root_hub - HCD autosuspends downstream ports
- * @hcd: host controller for this root hub
- *
- * This call arranges that usb_hcd_resume_root_hub() is safe to call later;
- * that the HCD's root hub polling is deactivated; and that the root's hub
- * driver is suspended.  HCDs may call this to autosuspend when their root
- * hub's downstream ports are all inactive:  unpowered, disconnected,
- * disabled, or suspended.
- *
- * The HCD will autoresume on device connect change detection (using SRP
- * or a D+/D- pullup).  The HCD also autoresumes on remote wakeup signaling
- * from any ports that are suspended (if that is enabled).  In most cases,
- * overcurrent signaling (on powered ports) will also start autoresume.
- *
- * Always called with IRQs blocked.
- */
-void usb_hcd_suspend_root_hub (struct usb_hcd *hcd)
-{
-	struct urb	*urb;
-
-	spin_lock (&amp;hcd_root_hub_lock);
-	usb_suspend_root_hub (hcd-&gt;self.root_hub);
-
-	/* force status urb to complete/unlink while suspended */
-	if (hcd-&gt;status_urb) {
-		urb = hcd-&gt;status_urb;
-		urb-&gt;status = -ECONNRESET;
-		urb-&gt;hcpriv = NULL;
-		urb-&gt;actual_length = 0;
-
-		del_timer (&amp;hcd-&gt;rh_timer);
-		hcd-&gt;poll_pending = 0;
-		hcd-&gt;status_urb = NULL;
-	} else
-		urb = NULL;
-	spin_unlock (&amp;hcd_root_hub_lock);
-	hcd-&gt;state = HC_STATE_SUSPENDED;
-
-	if (urb)
-		usb_hcd_giveback_urb (hcd, urb, NULL);
-}
-EXPORT_SYMBOL_GPL(usb_hcd_suspend_root_hub);
-
 /**
  * usb_hcd_resume_root_hub - called by HCD to resume its root hub 
  * @hcd: host controller for this root hub
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 7a2bcba2ae61..676877c15f81 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -368,17 +368,11 @@ extern int usb_find_interface_driver (struct usb_device *dev,
 #define usb_endpoint_out(ep_dir)	(!((ep_dir) &amp; USB_DIR_IN))
 
 #ifdef CONFIG_PM
-extern void usb_hcd_suspend_root_hub (struct usb_hcd *hcd);
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
 extern void usb_root_hub_lost_power (struct usb_device *rhdev);
 extern int hcd_bus_suspend (struct usb_bus *bus);
 extern int hcd_bus_resume (struct usb_bus *bus);
 #else
-static inline void usb_hcd_suspend_root_hub(struct usb_hcd *hcd)
-{
-	return;
-}
-
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index dee812bc6c43..7479bd329abb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -452,18 +452,14 @@ static void hub_power_on(struct usb_hub *hub)
 	msleep(max(pgood_delay, (unsigned) 100));
 }
 
-static inline void __hub_quiesce(struct usb_hub *hub)
+static void hub_quiesce(struct usb_hub *hub)
 {
 	/* (nonblocking) khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
 	hub-&gt;activating = 0;
 	hub-&gt;resume_root_hub = 0;
-}
 
-static void hub_quiesce(struct usb_hub *hub)
-{
 	/* (blocking) stop khubd and related activity */
-	__hub_quiesce(hub);
 	usb_kill_urb(hub-&gt;urb);
 	if (hub-&gt;has_indicators)
 		cancel_delayed_work(&amp;hub-&gt;leds);
@@ -1914,18 +1910,6 @@ static inline int remote_wakeup(struct usb_device *udev)
 #define hub_resume NULL
 #endif
 
-void usb_suspend_root_hub(struct usb_device *hdev)
-{
-	struct usb_hub *hub = hdev_to_hub(hdev);
-
-	/* This also makes any led blinker stop retriggering.  We're called
-	 * from irq, so the blinker might still be scheduled.  Caller promises
-	 * that the root hub status URB will be canceled.
-	 */
-	__hub_quiesce(hub);
-	mark_quiesced(to_usb_interface(hub-&gt;intfdev));
-}
-
 void usb_resume_root_hub(struct usb_device *hdev)
 {
 	struct usb_hub *hub = hdev_to_hub(hdev);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 10688ad73c6d..e8bc2e48913a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -20,7 +20,6 @@ extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_kick_khubd(struct usb_device *dev);
-extern void usb_suspend_root_hub(struct usb_device *hdev);
 extern void usb_resume_root_hub(struct usb_device *dev);
 
 extern int  usb_hub_init(void);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index f1b1ed086bde..0b899339cac8 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -135,9 +135,6 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	hcd-&gt;poll_rh = 0;
 
 done:
-	/* external suspend vs self autosuspend ... same effect */
-	if (status == 0)
-		usb_hcd_suspend_root_hub(hcd);
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
 	return status;
 }</pre>
    <div class="pagination">
        <a href='2_118.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><span>[119]</span><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_120.html'>Next&gt;&gt;</a>
    <div>
</body>
