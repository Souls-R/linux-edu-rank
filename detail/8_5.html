<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of New South Wales</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of New South Wales</h1>
    <div class="pagination">
        <a href='8_4.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><span>[5]</span><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_6.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6a806c510de490318846b53bbfec463d02ca274b
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Fri Jul 15 03:56:35 2005 -0700

    [PATCH] md/raid1: clear bitmap when fullsync completes
    
    We need to be careful differentiating between a resync of a complete array,
    in which we can clear the bitmap, and a resync of a degraded array, in
    which we cannot.
    
    This patch cleans all that up.
    
    Cc: Paul Clements &lt;paul.clements@steeleye.com&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c
index 95980ad6b27b..0c2ed99a3832 100644
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@ -1345,7 +1345,8 @@ void bitmap_endwrite(struct bitmap *bitmap, sector_t offset, unsigned long secto
 	}
 }
 
-int bitmap_start_sync(struct bitmap *bitmap, sector_t offset, int *blocks)
+int bitmap_start_sync(struct bitmap *bitmap, sector_t offset, int *blocks,
+			int degraded)
 {
 	bitmap_counter_t *bmc;
 	int rv;
@@ -1362,8 +1363,10 @@ int bitmap_start_sync(struct bitmap *bitmap, sector_t offset, int *blocks)
 			rv = 1;
 		else if (NEEDED(*bmc)) {
 			rv = 1;
-			*bmc |= RESYNC_MASK;
-			*bmc &amp;= ~NEEDED_MASK;
+			if (!degraded) { /* don't set/clear bits if degraded */
+				*bmc |= RESYNC_MASK;
+				*bmc &amp;= ~NEEDED_MASK;
+			}
 		}
 	}
 	spin_unlock_irq(&amp;bitmap-&gt;lock);
diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index ff1dbec864af..5f253ee536bb 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -1126,21 +1126,19 @@ static sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, i
 		 * only be one in raid1 resync.
 		 * We can find the current addess in mddev-&gt;curr_resync
 		 */
-		if (!conf-&gt;fullsync) {
-			if (mddev-&gt;curr_resync &lt; max_sector)
-				bitmap_end_sync(mddev-&gt;bitmap,
-						mddev-&gt;curr_resync,
+		if (mddev-&gt;curr_resync &lt; max_sector) /* aborted */
+			bitmap_end_sync(mddev-&gt;bitmap, mddev-&gt;curr_resync,
 						&amp;sync_blocks, 1);
-			bitmap_close_sync(mddev-&gt;bitmap);
-		}
-		if (mddev-&gt;curr_resync &gt;= max_sector)
+		else /* completed sync */
 			conf-&gt;fullsync = 0;
+
+		bitmap_close_sync(mddev-&gt;bitmap);
 		close_sync(conf);
 		return 0;
 	}
 
-	if (!conf-&gt;fullsync &amp;&amp;
-	    !bitmap_start_sync(mddev-&gt;bitmap, sector_nr, &amp;sync_blocks)) {
+	if (!bitmap_start_sync(mddev-&gt;bitmap, sector_nr, &amp;sync_blocks, mddev-&gt;degraded) &amp;&amp;
+	    !conf-&gt;fullsync) {
 		/* We can skip this block, and probably several more */
 		*skipped = 1;
 		return sync_blocks;
@@ -1243,15 +1241,15 @@ static sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, i
 			len = (max_sector - sector_nr) &lt;&lt; 9;
 		if (len == 0)
 			break;
-		if (!conf-&gt;fullsync) {
-			if (sync_blocks == 0) {
-				if (!bitmap_start_sync(mddev-&gt;bitmap,
-						       sector_nr, &amp;sync_blocks))
-					break;
-				if (sync_blocks &lt; (PAGE_SIZE&gt;&gt;9))
-					BUG();
-				if (len &gt; (sync_blocks&lt;&lt;9)) len = sync_blocks&lt;&lt;9;
-			}
+		if (sync_blocks == 0) {
+			if (!bitmap_start_sync(mddev-&gt;bitmap, sector_nr,
+					&amp;sync_blocks, mddev-&gt;degraded) &amp;&amp;
+					!conf-&gt;fullsync)
+				break;
+			if (sync_blocks &lt; (PAGE_SIZE&gt;&gt;9))
+				BUG();
+			if (len &gt; (sync_blocks&lt;&lt;9))
+				len = sync_blocks&lt;&lt;9;
 		}
 
 		for (i=0 ; i &lt; conf-&gt;raid_disks; i++) {
@@ -1264,7 +1262,8 @@ static sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, i
 					while (i &gt; 0) {
 						i--;
 						bio = r1_bio-&gt;bios[i];
-						if (bio-&gt;bi_end_io==NULL) continue;
+						if (bio-&gt;bi_end_io==NULL)
+							continue;
 						/* remove last page from this bio */
 						bio-&gt;bi_vcnt--;
 						bio-&gt;bi_size -= len;
diff --git a/include/linux/raid/bitmap.h b/include/linux/raid/bitmap.h
index e24b74b11150..6213e976eade 100644
--- a/include/linux/raid/bitmap.h
+++ b/include/linux/raid/bitmap.h
@@ -262,7 +262,7 @@ void bitmap_write_all(struct bitmap *bitmap);
 int bitmap_startwrite(struct bitmap *bitmap, sector_t offset, unsigned long sectors);
 void bitmap_endwrite(struct bitmap *bitmap, sector_t offset, unsigned long sectors,
 		     int success);
-int bitmap_start_sync(struct bitmap *bitmap, sector_t offset, int *blocks);
+int bitmap_start_sync(struct bitmap *bitmap, sector_t offset, int *blocks, int degraded);
 void bitmap_end_sync(struct bitmap *bitmap, sector_t offset, int *blocks, int aborted);
 void bitmap_close_sync(struct bitmap *bitmap);
 </pre><hr><pre>commit 1eb29128c644581fa51f822545921394ad4f719f
Author: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Fri Jul 15 03:56:27 2005 -0700

    [PATCH] Fix raid0's attempt to divide by 64bit numbers
    
    Apparently sector_div is only guaranteed to work with a 32bit divisor, even
    on 64bit architectures.  So allow for this in raid0.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c
index e11dd14d0b43..2120710172c5 100644
--- a/drivers/md/raid0.c
+++ b/drivers/md/raid0.c
@@ -314,16 +314,16 @@ static int raid0_run (mddev_t *mddev)
 		sector_t space = conf-&gt;hash_spacing;
 		int round;
 		conf-&gt;preshift = 0;
-		if (sizeof(sector_t) &gt; sizeof(unsigned long)) {
+		if (sizeof(sector_t) &gt; sizeof(u32)) {
 			/*shift down space and s so that sector_div will work */
-			while (space &gt; (sector_t) (~(unsigned long)0)) {
+			while (space &gt; (sector_t) (~(u32)0)) {
 				s &gt;&gt;= 1;
 				space &gt;&gt;= 1;
 				s += 1; /* force round-up */
 				conf-&gt;preshift++;
 			}
 		}
-		round = sector_div(s, (unsigned long)space) ? 1 : 0;
+		round = sector_div(s, (u32)space) ? 1 : 0;
 		nb_zone = s + round;
 	}
 	printk("raid0 : nb_zone is %d.\n", nb_zone);
@@ -443,7 +443,7 @@ static int raid0_make_request (request_queue_t *q, struct bio *bio)
 		volatile
 #endif
 		sector_t x = block &gt;&gt; conf-&gt;preshift;
-		sector_div(x, (unsigned long)conf-&gt;hash_spacing);
+		sector_div(x, (u32)conf-&gt;hash_spacing);
 		zone = conf-&gt;hash_table[x];
 	}
  </pre><hr><pre>commit bef5a66fd7fd8d606da5c9f210e2673f4e636f57
Author: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Mon Jul 11 01:05:47 2005 -0500

    Input: serio_raw - fix Kconfig help
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Vojtech Pavlik &lt;vojtech@suse.cz&gt;
    Signed-off-by: Dmitry Torokhov &lt;dtor@mail.ru&gt;

diff --git a/drivers/input/serio/Kconfig b/drivers/input/serio/Kconfig
index b3710733b36b..98acf170252c 100644
--- a/drivers/input/serio/Kconfig
+++ b/drivers/input/serio/Kconfig
@@ -175,7 +175,7 @@ config SERIO_RAW
 	  allocating minor 1 (that historically corresponds to /dev/psaux)
 	  first. To bind this driver to a serio port use sysfs interface:
 
-	      echo -n "serio_raw" &gt; /sys/bus/serio/devices/serioX/driver
+	      echo -n "serio_raw" &gt; /sys/bus/serio/devices/serioX/drvctl
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called serio_raw.</pre><hr><pre>commit e34ac862ee6644378bfe6ea65c2e0dda4545513d
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:30 2005 -0700

    [PATCH] nfsd4: fix fh_expire_type
    
    After discussion at the recent NFSv4 bake-a-thon, I realized that my
    assumption that NFS4_FH_PERSISTENT required filehandles to persist was a
    misreading of the spec.  This also fixes an interoperability problem with the
    Solaris client.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 1515c5b8096f..4c4146350236 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1366,9 +1366,9 @@ nfsd4_encode_fattr(struct svc_fh *fhp, struct svc_export *exp,
 		if ((buflen -= 4) &lt; 0)
 			goto out_resource;
 		if (exp-&gt;ex_flags &amp; NFSEXP_NOSUBTREECHECK)
-			WRITE32(NFS4_FH_VOLATILE_ANY);
+			WRITE32(NFS4_FH_PERSISTENT);
 		else
-			WRITE32(NFS4_FH_VOLATILE_ANY|NFS4_FH_VOL_RENAME);
+			WRITE32(NFS4_FH_PERSISTENT|NFS4_FH_VOL_RENAME);
 	}
 	if (bmval0 &amp; FATTR4_WORD0_CHANGE) {
 		/*</pre><hr><pre>commit 4c4cd222ee329025840bc2f8cebf71d36c62440c
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:27 2005 -0700

    [PATCH] nfsd4: check lock type against openmode.
    
    We shouldn't be allowing, e.g., write locks on files not open for read.  To
    enforce this, we add a pointer from the lock stateid back to the open stateid
    it came from, so that the check will continue to be correct even after the
    open is upgraded or downgraded.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 59b214f01b6d..b83f8fb441e1 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1160,6 +1160,7 @@ init_stateid(struct nfs4_stateid *stp, struct nfs4_file *fp, struct nfsd4_open *
 	stp-&gt;st_deny_bmap = 0;
 	__set_bit(open-&gt;op_share_access, &amp;stp-&gt;st_access_bmap);
 	__set_bit(open-&gt;op_share_deny, &amp;stp-&gt;st_deny_bmap);
+	stp-&gt;st_openstp = NULL;
 }
 
 static void
@@ -2158,12 +2159,18 @@ nfs4_preprocess_stateid_op(struct svc_fh *current_fh, stateid_t *stateid, int fl
 	return status;
 }
 
+static inline int
+setlkflg (int type)
+{
+	return (type == NFS4_READW_LT || type == NFS4_READ_LT) ?
+		RD_STATE : WR_STATE;
+}
 
 /* 
  * Checks for sequence id mutating operations. 
  */
 static int
-nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *stateid, int flags, struct nfs4_stateowner **sopp, struct nfs4_stateid **stpp, clientid_t *lockclid)
+nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *stateid, int flags, struct nfs4_stateowner **sopp, struct nfs4_stateid **stpp, struct nfsd4_lock *lock)
 {
 	struct nfs4_stateid *stp;
 	struct nfs4_stateowner *sop;
@@ -2201,21 +2208,31 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 		goto check_replay;
 	}
 
-	/* for new lock stateowners:
-	 * check that the lock-&gt;v.new.open_stateid
-	 * refers to an open stateowner
-	 *
-	 * check that the lockclid (nfs4_lock-&gt;v.new.clientid) is the same
-	 * as the open_stateid-&gt;st_stateowner-&gt;so_client-&gt;clientid
-	 */
-	if (lockclid) {
+	if (lock) {
 		struct nfs4_stateowner *sop = stp-&gt;st_stateowner;
+		clientid_t *lockclid = &amp;lock-&gt;v.new.clientid;
 		struct nfs4_client *clp = sop-&gt;so_client;
+		int lkflg = 0;
+		int status;
+
+		lkflg = setlkflg(lock-&gt;lk_type);
+
+		if (lock-&gt;lk_is_new) {
+                       if (!sop-&gt;so_is_open_owner)
+			       return nfserr_bad_stateid;
+                       if (!cmp_clid(&amp;clp-&gt;cl_clientid, lockclid))
+			       return nfserr_bad_stateid;
+                       /* stp is the open stateid */
+                       status = nfs4_check_openmode(stp, lkflg);
+                       if (status)
+			       return status;
+               } else {
+                       /* stp is the lock stateid */
+                       status = nfs4_check_openmode(stp-&gt;st_openstp, lkflg);
+                       if (status)
+			       return status;
+               }
 
-		if (!sop-&gt;so_is_open_owner)
-			return nfserr_bad_stateid;
-		if (!cmp_clid(&amp;clp-&gt;cl_clientid, lockclid))
-			return nfserr_bad_stateid;
 	}
 
 	if ((flags &amp; CHECK_FH) &amp;&amp; nfs4_check_fh(current_fh, stp)) {
@@ -2642,6 +2659,7 @@ alloc_init_lock_stateid(struct nfs4_stateowner *sop, struct nfs4_file *fp, struc
 	stp-&gt;st_vfs_file = open_stp-&gt;st_vfs_file; /* FIXME refcount?? */
 	stp-&gt;st_access_bmap = open_stp-&gt;st_access_bmap;
 	stp-&gt;st_deny_bmap = open_stp-&gt;st_deny_bmap;
+	stp-&gt;st_openstp = open_stp;
 
 out:
 	return stp;
@@ -2697,8 +2715,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 				        lock-&gt;lk_new_open_seqid,
 		                        &amp;lock-&gt;lk_new_open_stateid,
 		                        CHECK_FH | OPEN_STATE,
-		                        &amp;open_sop, &amp;open_stp,
-					&amp;lock-&gt;v.new.clientid);
+		                        &amp;open_sop, &amp;open_stp, lock);
 		if (status)
 			goto out;
 		/* create lockowner and lock stateid */
@@ -2726,7 +2743,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 				       lock-&gt;lk_old_lock_seqid, 
 				       &amp;lock-&gt;lk_old_lock_stateid, 
 				       CHECK_FH | LOCK_STATE, 
-				       &amp;lock-&gt;lk_stateowner, &amp;lock_stp, NULL);
+				       &amp;lock-&gt;lk_stateowner, &amp;lock_stp, lock);
 		if (status)
 			goto out;
 	}
diff --git a/include/linux/nfsd/state.h b/include/linux/nfsd/state.h
index 2d19431f47ea..8bf23cf8b603 100644
--- a/include/linux/nfsd/state.h
+++ b/include/linux/nfsd/state.h
@@ -237,6 +237,10 @@ struct nfs4_file {
 *       st_perlockowner: (open stateid) list of lock nfs4_stateowners
 * 	st_access_bmap: used only for open stateid
 * 	st_deny_bmap: used only for open stateid
+*	st_openstp: open stateid lock stateid was derived from
+*
+* XXX: open stateids and lock stateids have diverged sufficiently that
+* we should consider defining separate structs for the two cases.
 */
 
 struct nfs4_stateid {
@@ -250,6 +254,7 @@ struct nfs4_stateid {
 	struct file                 * st_vfs_file;
 	unsigned long                 st_access_bmap;
 	unsigned long                 st_deny_bmap;
+	struct nfs4_stateid         * st_openstp;
 };
 
 /* flags for preprocess_seqid_op() */</pre><hr><pre>commit 3a4f98bbf481cb9f755005ac569ceb5303e1b69f
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:26 2005 -0700

    [PATCH] nfsd4: clean up nfs4_preprocess_seqid_op
    
    As long as we're here, do some miscellaneous cleanup.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 67e03b5d0d83..59b214f01b6d 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2165,7 +2165,6 @@ nfs4_preprocess_stateid_op(struct svc_fh *current_fh, stateid_t *stateid, int fl
 static int
 nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *stateid, int flags, struct nfs4_stateowner **sopp, struct nfs4_stateid **stpp, clientid_t *lockclid)
 {
-	int status;
 	struct nfs4_stateid *stp;
 	struct nfs4_stateowner *sop;
 
@@ -2173,19 +2172,17 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 			"stateid = (%08x/%08x/%08x/%08x)\n", seqid,
 		stateid-&gt;si_boot, stateid-&gt;si_stateownerid, stateid-&gt;si_fileid,
 		stateid-&gt;si_generation);
-			        
+
 	*stpp = NULL;
 	*sopp = NULL;
 
-	status = nfserr_bad_stateid;
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid)) {
 		printk("NFSD: preprocess_seqid_op: magic stateid!\n");
-		goto out;
+		return nfserr_bad_stateid;
 	}
 
-	status = nfserr_stale_stateid;
 	if (STALE_STATEID(stateid))
-		goto out;
+		return nfserr_stale_stateid;
 	/*
 	* We return BAD_STATEID if filehandle doesn't match stateid, 
 	* the confirmed flag is incorrecly set, or the generation 
@@ -2204,8 +2201,6 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 		goto check_replay;
 	}
 
-	status = nfserr_bad_stateid;
-
 	/* for new lock stateowners:
 	 * check that the lock-&gt;v.new.open_stateid
 	 * refers to an open stateowner
@@ -2218,14 +2213,14 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 		struct nfs4_client *clp = sop-&gt;so_client;
 
 		if (!sop-&gt;so_is_open_owner)
-			goto out;
+			return nfserr_bad_stateid;
 		if (!cmp_clid(&amp;clp-&gt;cl_clientid, lockclid))
-			goto out;
+			return nfserr_bad_stateid;
 	}
 
 	if ((flags &amp; CHECK_FH) &amp;&amp; nfs4_check_fh(current_fh, stp)) {
 		printk("NFSD: preprocess_seqid_op: fh-stateid mismatch!\n");
-		goto out;
+		return nfserr_bad_stateid;
 	}
 
 	*stpp = stp;
@@ -2239,45 +2234,38 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 	if (seqid != sop-&gt;so_seqid)
 		goto check_replay;
 
-	if (sop-&gt;so_confirmed) {
-		if (flags &amp; CONFIRM) {
-			printk("NFSD: preprocess_seqid_op: expected unconfirmed stateowner!\n");
-			goto out;
-		}
+	if (sop-&gt;so_confirmed &amp;&amp; flags &amp; CONFIRM) {
+		printk("NFSD: preprocess_seqid_op: expected"
+				" unconfirmed stateowner!\n");
+		return nfserr_bad_stateid;
 	}
-	else {
-		if (!(flags &amp; CONFIRM)) {
-			printk("NFSD: preprocess_seqid_op: stateowner not confirmed yet!\n");
-			goto out;
-		}
+	if (!sop-&gt;so_confirmed &amp;&amp; !(flags &amp; CONFIRM)) {
+		printk("NFSD: preprocess_seqid_op: stateowner not"
+				" confirmed yet!\n");
+		return nfserr_bad_stateid;
 	}
 	if (stateid-&gt;si_generation &gt; stp-&gt;st_stateid.si_generation) {
 		printk("NFSD: preprocess_seqid_op: future stateid?!\n");
-		goto out;
+		return nfserr_bad_stateid;
 	}
 
-	status = nfserr_old_stateid;
 	if (stateid-&gt;si_generation &lt; stp-&gt;st_stateid.si_generation) {
 		printk("NFSD: preprocess_seqid_op: old stateid!\n");
-		goto out;
+		return nfserr_old_stateid;
 	}
 	renew_client(sop-&gt;so_client);
-	status = nfs_ok;
+	return nfs_ok;
 
-out:
-	return status;
 check_replay:
 	if (seqid == sop-&gt;so_seqid - 1) {
 		printk("NFSD: preprocess_seqid_op: retransmission?\n");
 		/* indicate replay to calling function */
-		status = NFSERR_REPLAY_ME;
-	} else  {
-		printk("NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d\n", sop-&gt;so_seqid, seqid);
-
-		*sopp = NULL;
-		status = nfserr_bad_seqid;
+		return NFSERR_REPLAY_ME;
 	}
-	goto out;
+	printk("NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d)\n",
+			sop-&gt;so_seqid, seqid);
+	*sopp = NULL;
+	return nfserr_bad_seqid;
 }
 
 int</pre><hr><pre>commit f8816512fcfde986326a2eb0f5a58e463d9904d8
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:25 2005 -0700

    [PATCH] nfsd4: clarify close_lru handling
    
    The handling of close_lru in preprocess_stateid_op was a source of some
    confusion here recently.  Try to make the logic a little clearer, by renaming
    find_openstateowner_id to make its purpose clearer and untangling some
    unnecessarily complicated goto's.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 7694fb8aae35..67e03b5d0d83 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1988,14 +1988,11 @@ laundromat_main(void *not_used)
 	queue_delayed_work(laundry_wq, &amp;laundromat_work, t*HZ);
 }
 
-/* search ownerid_hashtbl[] and close_lru for stateid owner
- * (stateid-&gt;si_stateownerid)
- */
 static struct nfs4_stateowner *
-find_openstateowner_id(u32 st_id, int flags) {
+search_close_lru(u32 st_id, int flags)
+{
 	struct nfs4_stateowner *local = NULL;
 
-	dprintk("NFSD: find_openstateowner_id %d\n", st_id);
 	if (flags &amp; CLOSE_STATE) {
 		list_for_each_entry(local, &amp;close_lru, so_close_lru) {
 			if (local-&gt;so_id == st_id)
@@ -2193,13 +2190,19 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 	* We return BAD_STATEID if filehandle doesn't match stateid, 
 	* the confirmed flag is incorrecly set, or the generation 
 	* number is incorrect.  
-	* If there is no entry in the openfile table for this id, 
-	* we can't always return BAD_STATEID;
-	* this might be a retransmitted CLOSE which has arrived after 
-	* the openfile has been released.
 	*/
-	if (!(stp = find_stateid(stateid, flags)))
-		goto no_nfs4_stateid;
+	stp = find_stateid(stateid, flags);
+	if (stp == NULL) {
+		/*
+		 * Also, we should make sure this isn't just the result of
+		 * a replayed close:
+		 */
+		sop = search_close_lru(stateid-&gt;si_stateownerid, flags);
+		if (sop == NULL)
+			return nfserr_bad_stateid;
+		*sopp = sop;
+		goto check_replay;
+	}
 
 	status = nfserr_bad_stateid;
 
@@ -2263,21 +2266,6 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 
 out:
 	return status;
-
-no_nfs4_stateid:
-
-	/*
-	* We determine whether this is a bad stateid or a replay, 
-	* starting by trying to look up the stateowner.
-	* If stateowner is not found - stateid is bad.
-	*/
-	if (!(sop = find_openstateowner_id(stateid-&gt;si_stateownerid, flags))) {
-		printk("NFSD: preprocess_seqid_op: no stateowner or nfs4_stateid!\n");
-		status = nfserr_bad_stateid;
-		goto out;
-	}
-	*sopp = sop;
-
 check_replay:
 	if (seqid == sop-&gt;so_seqid - 1) {
 		printk("NFSD: preprocess_seqid_op: retransmission?\n");</pre><hr><pre>commit 52fd004e296ac07cde820af9e3139d47dda03cf8
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:24 2005 -0700

    [PATCH] nfsd4: renew lease on seqid modifying operations
    
    nfs4_preprocess_seqid_op is called by NFSv4 operations that imply an implicit
    renewal of the client lease.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 3647c942915e..7694fb8aae35 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2258,7 +2258,7 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 		printk("NFSD: preprocess_seqid_op: old stateid!\n");
 		goto out;
 	}
-	/* XXX renew the client lease here */
+	renew_client(sop-&gt;so_client);
 	status = nfs_ok;
 
 out:</pre><hr><pre>commit b700949b781480819e53bdc38a53f053226dd75e
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:23 2005 -0700

    [PATCH] nfsd4: return better error on io incompatible with open mode
    
    from RFC 3530:
    "Share reservations are established by OPEN operations and by their
    nature are mandatory in that when the OPEN denies READ or WRITE
    operations, that denial results in such operations being rejected
    with error NFS4ERR_LOCKED."
    
    (Note that share_denied is really only a legal error for OPEN.)
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index b96714ae3dd7..3647c942915e 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1295,7 +1295,7 @@ nfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)
 	fp = find_file(ino);
 	if (!fp)
 		return nfs_ok;
-	ret = nfserr_share_denied;
+	ret = nfserr_locked;
 	/* Search for conflicting share reservations */
 	list_for_each_entry(stp, &amp;fp-&gt;fi_stateids, st_perfile) {
 		if (test_bit(deny_type, &amp;stp-&gt;st_deny_bmap) ||
diff --git a/include/linux/nfsd/nfsd.h b/include/linux/nfsd/nfsd.h
index c2da1b62d416..6d5a24f3fc6d 100644
--- a/include/linux/nfsd/nfsd.h
+++ b/include/linux/nfsd/nfsd.h
@@ -231,6 +231,7 @@ void		nfsd_lockd_shutdown(void);
 #define	nfserr_reclaim_bad	__constant_htonl(NFSERR_RECLAIM_BAD)
 #define	nfserr_badname		__constant_htonl(NFSERR_BADNAME)
 #define	nfserr_cb_path_down	__constant_htonl(NFSERR_CB_PATH_DOWN)
+#define	nfserr_locked		__constant_htonl(NFSERR_LOCKED)
 
 /* error codes for internal use */
 /* if a request fails due to kmalloc failure, it gets dropped.</pre><hr><pre>commit 444c2c07c2d7a6936d1381d381ab80e3f5541427
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:22 2005 -0700

    [PATCH] nfsd4: always update stateid on open
    
    An OPEN from the same client/open stateowner requires a stateid update because
    of the share/deny access update.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 386daac508f5..b96714ae3dd7 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1820,6 +1820,7 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 		status = nfs4_upgrade_open(rqstp, current_fh, stp, open);
 		if (status)
 			goto out;
+		update_stateid(&amp;stp-&gt;st_stateid);
 	} else {
 		/* Stateid was not found, this is a new OPEN */
 		int flags = 0;</pre>
    <div class="pagination">
        <a href='8_4.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><span>[5]</span><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_6.html'>Next&gt;&gt;</a>
    <div>
</body>
