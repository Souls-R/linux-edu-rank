<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_9.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><span>[10]</span><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_11.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 878520ac45f9f698432d4276db3d9144b83931b6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Nov 19 21:54:15 2019 -0500

    ext4: save the error code which triggered an ext4_error() in the superblock
    
    This allows the cause of an ext4_error() report to be categorized
    based on whether it was triggered due to an I/O error, or an memory
    allocation error, or other possible causes.  Most errors are caused by
    a detected file system inconsistency, so the default code stored in
    the superblock will be EXT4_ERR_EFSCORRUPTED.
    
    Link: https://lore.kernel.org/r/20191204032335.7683-1-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index 0b202e00d93f..102c38527a10 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -506,6 +506,7 @@ int ext4_wait_block_bitmap(struct super_block *sb, ext4_group_t block_group,
 		return -EFSCORRUPTED;
 	wait_on_buffer(bh);
 	if (!buffer_uptodate(bh)) {
+		ext4_set_errno(sb, EIO);
 		ext4_error(sb, "Cannot read block bitmap - "
 			   "block_group = %u, block_bitmap = %llu",
 			   block_group, (unsigned long long) bh-&gt;b_blocknr);
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index f8578caba40d..b00d07bad45b 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1343,7 +1343,8 @@ struct ext4_super_block {
 	__u8	s_lastcheck_hi;
 	__u8	s_first_error_time_hi;
 	__u8	s_last_error_time_hi;
-	__u8	s_pad[2];
+	__u8	s_first_error_errcode;
+	__u8    s_last_error_errcode;
 	__le16  s_encoding;		/* Filename charset encoding */
 	__le16  s_encoding_flags;	/* Filename charset encoding flags */
 	__le32	s_reserved[95];		/* Padding to the end of the block */
@@ -1574,6 +1575,32 @@ static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)
 		 ino &lt;= le32_to_cpu(EXT4_SB(sb)-&gt;s_es-&gt;s_inodes_count));
 }
 
+/*
+ * Error number codes for s_{first,last}_error_errno
+ *
+ * Linux errno numbers are architecture specific, so we need to translate
+ * them into something which is architecture independent.   We don't define
+ * codes for all errno's; just the ones which are most likely to be the cause
+ * of an ext4_error() call.
+ */
+#define EXT4_ERR_UNKNOWN	 1
+#define EXT4_ERR_EIO		 2
+#define EXT4_ERR_ENOMEM		 3
+#define EXT4_ERR_EFSBADCRC	 4
+#define EXT4_ERR_EFSCORRUPTED	 5
+#define EXT4_ERR_ENOSPC		 6
+#define EXT4_ERR_ENOKEY		 7
+#define EXT4_ERR_EROFS		 8
+#define EXT4_ERR_EFBIG		 9
+#define EXT4_ERR_EEXIST		10
+#define EXT4_ERR_ERANGE		11
+#define EXT4_ERR_EOVERFLOW	12
+#define EXT4_ERR_EBUSY		13
+#define EXT4_ERR_ENOTDIR	14
+#define EXT4_ERR_ENOTEMPTY	15
+#define EXT4_ERR_ESHUTDOWN	16
+#define EXT4_ERR_EFAULT		17
+
 /*
  * Inode dynamic state flags
  */
@@ -2688,6 +2715,7 @@ extern const char *ext4_decode_error(struct super_block *sb, int errno,
 extern void ext4_mark_group_bitmap_corrupted(struct super_block *sb,
 					     ext4_group_t block_group,
 					     unsigned int flags);
+extern void ext4_set_errno(struct super_block *sb, int err);
 
 extern __printf(4, 5)
 void __ext4_error(struct super_block *, const char *, unsigned int,
diff --git a/fs/ext4/ext4_jbd2.c b/fs/ext4/ext4_jbd2.c
index d3b8cdea5df7..19217a3f1ae4 100644
--- a/fs/ext4/ext4_jbd2.c
+++ b/fs/ext4/ext4_jbd2.c
@@ -58,6 +58,7 @@ static int ext4_journal_check_start(struct super_block *sb)
 	 * take the FS itself readonly cleanly.
 	 */
 	if (journal &amp;&amp; is_journal_aborted(journal)) {
+		ext4_set_errno(sb, -journal-&gt;j_errno);
 		ext4_abort(sb, "Detected aborted journal");
 		return -EROFS;
 	}
@@ -249,6 +250,7 @@ int __ext4_forget(const char *where, unsigned int line, handle_t *handle,
 	if (err) {
 		ext4_journal_abort_handle(where, line, __func__,
 					  bh, handle, err);
+		ext4_set_errno(inode-&gt;i_sb, -err);
 		__ext4_abort(inode-&gt;i_sb, where, line,
 			   "error %d when attempting revoke", err);
 	}
@@ -320,6 +322,7 @@ int __ext4_handle_dirty_metadata(const char *where, unsigned int line,
 				es = EXT4_SB(inode-&gt;i_sb)-&gt;s_es;
 				es-&gt;s_last_error_block =
 					cpu_to_le64(bh-&gt;b_blocknr);
+				ext4_set_errno(inode-&gt;i_sb, EIO);
 				ext4_error_inode(inode, where, line,
 						 bh-&gt;b_blocknr,
 					"IO error syncing itable block");
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 0e8708b77da6..ee83fe7c98aa 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -492,6 +492,7 @@ static int __ext4_ext_check(const char *function, unsigned int line,
 	return 0;
 
 corrupted:
+	ext4_set_errno(inode-&gt;i_sb, -err);
 	ext4_error_inode(inode, function, line, 0,
 			 "pblk %llu bad header/extent: %s - magic %x, "
 			 "entries %u, max %u(%u), depth %u(%u)",
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 8ca4a23129aa..0151ba8ea439 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -194,6 +194,7 @@ ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)
 	wait_on_buffer(bh);
 	if (!buffer_uptodate(bh)) {
 		put_bh(bh);
+		ext4_set_errno(sb, EIO);
 		ext4_error(sb, "Cannot read inode bitmap - "
 			   "block_group = %u, inode_bitmap = %llu",
 			   block_group, bitmap_blk);
@@ -1223,6 +1224,7 @@ struct inode *ext4_orphan_get(struct super_block *sb, unsigned long ino)
 	inode = ext4_iget(sb, ino, EXT4_IGET_NORMAL);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
+		ext4_set_errno(sb, -err);
 		ext4_error(sb, "couldn't read orphan inode %lu (err %d)",
 			   ino, err);
 		return inode;
diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index 2fec62d764fa..e61603f47035 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -98,6 +98,7 @@ int ext4_get_max_inline_size(struct inode *inode)
 
 	error = ext4_get_inode_loc(inode, &amp;iloc);
 	if (error) {
+		ext4_set_errno(inode-&gt;i_sb, -error);
 		ext4_error_inode(inode, __func__, __LINE__, 0,
 				 "can't get inode location %lu",
 				 inode-&gt;i_ino);
@@ -1761,6 +1762,7 @@ bool empty_inline_dir(struct inode *dir, int *has_inline_data)
 
 	err = ext4_get_inode_loc(dir, &amp;iloc);
 	if (err) {
+		ext4_set_errno(dir-&gt;i_sb, -err);
 		EXT4_ERROR_INODE(dir, "error %d getting inode %lu block",
 				 err, dir-&gt;i_ino);
 		return true;
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 629a25d999f0..23fa585206f0 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -271,6 +271,7 @@ void ext4_evict_inode(struct inode *inode)
 	if (inode-&gt;i_blocks) {
 		err = ext4_truncate(inode);
 		if (err) {
+			ext4_set_errno(inode-&gt;i_sb, -err);
 			ext4_error(inode-&gt;i_sb,
 				   "couldn't truncate inode %lu (err %d)",
 				   inode-&gt;i_ino, err);
@@ -2478,10 +2479,12 @@ static int mpage_map_and_submit_extent(handle_t *handle,
 			EXT4_I(inode)-&gt;i_disksize = disksize;
 		up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
 		err2 = ext4_mark_inode_dirty(handle, inode);
-		if (err2)
+		if (err2) {
+			ext4_set_errno(inode-&gt;i_sb, -err2);
 			ext4_error(inode-&gt;i_sb,
 				   "Failed to mark inode %lu dirty",
 				   inode-&gt;i_ino);
+		}
 		if (!err)
 			err = err2;
 	}
@@ -4338,6 +4341,7 @@ static int __ext4_get_inode_loc(struct inode *inode,
 		blk_finish_plug(&amp;plug);
 		wait_on_buffer(bh);
 		if (!buffer_uptodate(bh)) {
+			ext4_set_errno(inode-&gt;i_sb, EIO);
 			EXT4_ERROR_INODE_BLOCK(inode, block,
 					       "unable to read itable block");
 			brelse(bh);
@@ -4552,6 +4556,7 @@ struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
 	}
 
 	if (!ext4_inode_csum_verify(inode, raw_inode, ei)) {
+		ext4_set_errno(inode-&gt;i_sb, EFSBADCRC);
 		ext4_error_inode(inode, function, line, 0,
 				 "iget: checksum invalid");
 		ret = -EFSBADCRC;
@@ -5090,6 +5095,7 @@ int ext4_write_inode(struct inode *inode, struct writeback_control *wbc)
 		if (wbc-&gt;sync_mode == WB_SYNC_ALL &amp;&amp; !wbc-&gt;for_sync)
 			sync_dirty_buffer(iloc.bh);
 		if (buffer_req(iloc.bh) &amp;&amp; !buffer_uptodate(iloc.bh)) {
+			ext4_set_errno(inode-&gt;i_sb, EIO);
 			EXT4_ERROR_INODE_BLOCK(inode, iloc.bh-&gt;b_blocknr,
 					 "IO error syncing inode");
 			err = -EIO;
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index a3e2767bdf2f..f64838187559 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -3895,6 +3895,7 @@ ext4_mb_discard_group_preallocations(struct super_block *sb,
 	bitmap_bh = ext4_read_block_bitmap(sb, group);
 	if (IS_ERR(bitmap_bh)) {
 		err = PTR_ERR(bitmap_bh);
+		ext4_set_errno(sb, -err);
 		ext4_error(sb, "Error %d reading block bitmap for %u",
 			   err, group);
 		return 0;
@@ -4063,6 +4064,7 @@ void ext4_discard_preallocations(struct inode *inode)
 		err = ext4_mb_load_buddy_gfp(sb, group, &amp;e4b,
 					     GFP_NOFS|__GFP_NOFAIL);
 		if (err) {
+			ext4_set_errno(sb, -err);
 			ext4_error(sb, "Error %d loading buddy information for %u",
 				   err, group);
 			continue;
@@ -4071,6 +4073,7 @@ void ext4_discard_preallocations(struct inode *inode)
 		bitmap_bh = ext4_read_block_bitmap(sb, group);
 		if (IS_ERR(bitmap_bh)) {
 			err = PTR_ERR(bitmap_bh);
+			ext4_set_errno(sb, -err);
 			ext4_error(sb, "Error %d reading block bitmap for %u",
 					err, group);
 			ext4_mb_unload_buddy(&amp;e4b);
@@ -4325,6 +4328,7 @@ ext4_mb_discard_lg_preallocations(struct super_block *sb,
 		err = ext4_mb_load_buddy_gfp(sb, group, &amp;e4b,
 					     GFP_NOFS|__GFP_NOFAIL);
 		if (err) {
+			ext4_set_errno(sb, -err);
 			ext4_error(sb, "Error %d loading buddy information for %u",
 				   err, group);
 			continue;
diff --git a/fs/ext4/mmp.c b/fs/ext4/mmp.c
index 2305b4374fd3..1c44b1a32001 100644
--- a/fs/ext4/mmp.c
+++ b/fs/ext4/mmp.c
@@ -173,8 +173,10 @@ static int kmmpd(void *data)
 		 * (s_mmp_update_interval * 60) seconds.
 		 */
 		if (retval) {
-			if ((failed_writes % 60) == 0)
+			if ((failed_writes % 60) == 0) {
+				ext4_set_errno(sb, -retval);
 				ext4_error(sb, "Error writing to MMP block");
+			}
 			failed_writes++;
 		}
 
@@ -205,6 +207,7 @@ static int kmmpd(void *data)
 
 			retval = read_mmp_block(sb, &amp;bh_check, mmp_block);
 			if (retval) {
+				ext4_set_errno(sb, -retval);
 				ext4_error(sb, "error reading MMP data: %d",
 					   retval);
 				goto exit_thread;
@@ -218,6 +221,7 @@ static int kmmpd(void *data)
 					     "Error while updating MMP info. "
 					     "The filesystem seems to have been"
 					     " multiply mounted.");
+				ext4_set_errno(sb, EBUSY);
 				ext4_error(sb, "abort");
 				put_bh(bh_check);
 				retval = -EBUSY;
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 1cb42d940784..1bb6099397af 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -156,6 +156,7 @@ static struct buffer_head *__ext4_read_dirblock(struct inode *inode,
 		if (ext4_dx_csum_verify(inode, dirent))
 			set_buffer_verified(bh);
 		else {
+			ext4_set_errno(inode-&gt;i_sb, EFSBADCRC);
 			ext4_error_inode(inode, func, line, block,
 					 "Directory index failed checksum");
 			brelse(bh);
@@ -166,6 +167,7 @@ static struct buffer_head *__ext4_read_dirblock(struct inode *inode,
 		if (ext4_dirblock_csum_verify(inode, bh))
 			set_buffer_verified(bh);
 		else {
+			ext4_set_errno(inode-&gt;i_sb, EFSBADCRC);
 			ext4_error_inode(inode, func, line, block,
 					 "Directory block failed checksum");
 			brelse(bh);
@@ -1527,6 +1529,7 @@ static struct buffer_head *__ext4_find_entry(struct inode *dir,
 			goto next;
 		wait_on_buffer(bh);
 		if (!buffer_uptodate(bh)) {
+			ext4_set_errno(sb, EIO);
 			EXT4_ERROR_INODE(dir, "reading directory lblock %lu",
 					 (unsigned long) block);
 			brelse(bh);
@@ -1537,6 +1540,7 @@ static struct buffer_head *__ext4_find_entry(struct inode *dir,
 		    !is_dx_internal_node(dir, block,
 					 (struct ext4_dir_entry *)bh-&gt;b_data) &amp;&amp;
 		    !ext4_dirblock_csum_verify(dir, bh)) {
+			ext4_set_errno(sb, EFSBADCRC);
 			EXT4_ERROR_INODE(dir, "checksumming directory "
 					 "block %lu", (unsigned long)block);
 			brelse(bh);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index c3d66bb7fd96..f1a5c14c2a93 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -367,6 +367,8 @@ static void __save_error_info(struct super_block *sb, const char *func,
 	ext4_update_tstamp(es, s_last_error_time);
 	strncpy(es-&gt;s_last_error_func, func, sizeof(es-&gt;s_last_error_func));
 	es-&gt;s_last_error_line = cpu_to_le32(line);
+	if (es-&gt;s_last_error_errcode == 0)
+		es-&gt;s_last_error_errcode = EXT4_ERR_EFSCORRUPTED;
 	if (!es-&gt;s_first_error_time) {
 		es-&gt;s_first_error_time = es-&gt;s_last_error_time;
 		es-&gt;s_first_error_time_hi = es-&gt;s_last_error_time_hi;
@@ -375,6 +377,7 @@ static void __save_error_info(struct super_block *sb, const char *func,
 		es-&gt;s_first_error_line = cpu_to_le32(line);
 		es-&gt;s_first_error_ino = es-&gt;s_last_error_ino;
 		es-&gt;s_first_error_block = es-&gt;s_last_error_block;
+		es-&gt;s_first_error_errcode = es-&gt;s_last_error_errcode;
 	}
 	/*
 	 * Start the daily error reporting function if it hasn't been
@@ -631,6 +634,66 @@ const char *ext4_decode_error(struct super_block *sb, int errno,
 	return errstr;
 }
 
+void ext4_set_errno(struct super_block *sb, int err)
+{
+	if (err &lt; 0)
+		err = -err;
+
+	switch (err) {
+	case EIO:
+		err = EXT4_ERR_EIO;
+		break;
+	case ENOMEM:
+		err = EXT4_ERR_ENOMEM;
+		break;
+	case EFSBADCRC:
+		err = EXT4_ERR_EFSBADCRC;
+		break;
+	case EFSCORRUPTED:
+		err = EXT4_ERR_EFSCORRUPTED;
+		break;
+	case ENOSPC:
+		err = EXT4_ERR_ENOSPC;
+		break;
+	case ENOKEY:
+		err = EXT4_ERR_ENOKEY;
+		break;
+	case EROFS:
+		err = EXT4_ERR_EROFS;
+		break;
+	case EFBIG:
+		err = EXT4_ERR_EFBIG;
+		break;
+	case EEXIST:
+		err = EXT4_ERR_EEXIST;
+		break;
+	case ERANGE:
+		err = EXT4_ERR_ERANGE;
+		break;
+	case EOVERFLOW:
+		err = EXT4_ERR_EOVERFLOW;
+		break;
+	case EBUSY:
+		err = EXT4_ERR_EBUSY;
+		break;
+	case ENOTDIR:
+		err = EXT4_ERR_ENOTDIR;
+		break;
+	case ENOTEMPTY:
+		err = EXT4_ERR_ENOTEMPTY;
+		break;
+	case ESHUTDOWN:
+		err = EXT4_ERR_ESHUTDOWN;
+		break;
+	case EFAULT:
+		err = EXT4_ERR_EFAULT;
+		break;
+	default:
+		err = EXT4_ERR_UNKNOWN;
+	}
+	EXT4_SB(sb)-&gt;s_es-&gt;s_last_error_errcode = err;
+}
+
 /* __ext4_std_error decodes expected errors from journaling functions
  * automatically and invokes the appropriate error response.  */
 
@@ -655,6 +718,7 @@ void __ext4_std_error(struct super_block *sb, const char *function,
 		       sb-&gt;s_id, function, line, errstr);
 	}
 
+	ext4_set_errno(sb, -errno);
 	save_error_info(sb, function, line);
 	ext4_handle_error(sb);
 }
@@ -982,8 +1046,10 @@ static void ext4_put_super(struct super_block *sb)
 		aborted = is_journal_aborted(sbi-&gt;s_journal);
 		err = jbd2_journal_destroy(sbi-&gt;s_journal);
 		sbi-&gt;s_journal = NULL;
-		if ((err &lt; 0) &amp;&amp; !aborted)
+		if ((err &lt; 0) &amp;&amp; !aborted) {
+			ext4_set_errno(sb, -err);
 			ext4_abort(sb, "Couldn't clean up the journal");
+		}
 	}
 
 	ext4_unregister_sysfs(sb);
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index 8966a5439a22..246fbeeb6366 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -2879,9 +2879,11 @@ int ext4_xattr_delete_inode(handle_t *handle, struct inode *inode,
 		bh = ext4_sb_bread(inode-&gt;i_sb, EXT4_I(inode)-&gt;i_file_acl, REQ_PRIO);
 		if (IS_ERR(bh)) {
 			error = PTR_ERR(bh);
-			if (error == -EIO)
+			if (error == -EIO) {
+				ext4_set_errno(inode-&gt;i_sb, EIO);
 				EXT4_ERROR_INODE(inode, "block %llu read error",
 						 EXT4_I(inode)-&gt;i_file_acl);
+			}
 			bh = NULL;
 			goto cleanup;
 		}</pre><hr><pre>commit a562c687d115fe5a90be1e27745cc771c1e6cbd9
Merge: cf2834a5ed57 bc6385dab125
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Dec 26 09:57:24 2019 -0500

    Merge branch 'rk/inode_lock' into dev
    
    These are ilock patches which helps improve the current inode lock scalabiliy
    problem in ext4 DIO mixed read/write workload case. The problem was first
    reported by Joseph [1]. This should help improve mixed read/write workload
    cases for databases which use directIO.
    
    These patches are based upon upstream discussion with Jan Kara &amp; Joseph [2].
    
    The problem really is that in case of DIO overwrites, we start with
    a exclusive lock and then downgrade it later to shared lock. This causes a
    scalability problem in case of mixed DIO read/write workload case.
    i.e. if we have any ongoing DIO reads and then comes a DIO writes,
    (since writes starts with excl. inode lock) then it has to wait until the
    shared lock is released (which only happens when DIO read is completed).
    Same is true for vice versa as well.
    The same can be easily observed with perf-tools trace analysis [3].
    
    For more details, including performance numbers, please see [4].
    
    [1] https://lore.kernel.org/linux-ext4/1566871552-60946-4-git-send-email-joseph.qi@linux.alibaba.com/
    [2] https://lore.kernel.org/linux-ext4/20190910215720.GA7561@quack2.suse.cz/
    [3] https://raw.githubusercontent.com/riteshharjani/LinuxStudy/master/ext4/perf.report
    [4] https://lore.kernel.org/r/20191212055557.11151-1-riteshh@linux.ibm.com
</pre><hr><pre>commit cf2834a5ed57562d6a1a8170724704149f0ae0a4
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Dec 14 16:42:52 2019 -0500

    ext4: treat buffers contining write errors as valid in ext4_sb_bread()
    
    In commit 7963e5ac9012 ("ext4: treat buffers with write errors as
    containing valid data") we missed changing ext4_sb_bread() to use
    ext4_buffer_uptodate().  So fix this oversight.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 2937a8873fe1..c3d66bb7fd96 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -154,7 +154,7 @@ ext4_sb_bread(struct super_block *sb, sector_t block, int op_flags)
 
 	if (bh == NULL)
 		return ERR_PTR(-ENOMEM);
-	if (buffer_uptodate(bh))
+	if (ext4_buffer_uptodate(bh))
 		return bh;
 	ll_rw_block(REQ_OP_READ, REQ_META | op_flags, 1, &amp;bh);
 	wait_on_buffer(bh);</pre><hr><pre>commit 9803387c55f7d2ce69aa64340c5fdc6b3027dbc8
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Dec 15 01:09:03 2019 -0500

    ext4: validate the debug_want_extra_isize mount option at parse time
    
    Instead of setting s_want_extra_size and then making sure that it is a
    valid value afterwards, validate the field before we set it.  This
    avoids races and other problems when remounting the file system.
    
    Link: https://lore.kernel.org/r/20191215063020.GA11512@mit.edu
    Cc: stable@kernel.org
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Reported-and-tested-by: syzbot+4a39a025912b265cacef@syzkaller.appspotmail.com

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index b205112ca051..46b6d5b150ac 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1886,6 +1886,13 @@ static int handle_mount_opt(struct super_block *sb, char *opt, int token,
 		}
 		sbi-&gt;s_commit_interval = HZ * arg;
 	} else if (token == Opt_debug_want_extra_isize) {
+		if ((arg &amp; 1) ||
+		    (arg &lt; 4) ||
+		    (arg &gt; (sbi-&gt;s_inode_size - EXT4_GOOD_OLD_INODE_SIZE))) {
+			ext4_msg(sb, KERN_ERR,
+				 "Invalid want_extra_isize %d", arg);
+			return -1;
+		}
 		sbi-&gt;s_want_extra_isize = arg;
 	} else if (token == Opt_max_batch_time) {
 		sbi-&gt;s_max_batch_time = arg;
@@ -3540,40 +3547,6 @@ int ext4_calculate_overhead(struct super_block *sb)
 	return 0;
 }
 
-static void ext4_clamp_want_extra_isize(struct super_block *sb)
-{
-	struct ext4_sb_info *sbi = EXT4_SB(sb);
-	struct ext4_super_block *es = sbi-&gt;s_es;
-	unsigned def_extra_isize = sizeof(struct ext4_inode) -
-						EXT4_GOOD_OLD_INODE_SIZE;
-
-	if (sbi-&gt;s_inode_size == EXT4_GOOD_OLD_INODE_SIZE) {
-		sbi-&gt;s_want_extra_isize = 0;
-		return;
-	}
-	if (sbi-&gt;s_want_extra_isize &lt; 4) {
-		sbi-&gt;s_want_extra_isize = def_extra_isize;
-		if (ext4_has_feature_extra_isize(sb)) {
-			if (sbi-&gt;s_want_extra_isize &lt;
-			    le16_to_cpu(es-&gt;s_want_extra_isize))
-				sbi-&gt;s_want_extra_isize =
-					le16_to_cpu(es-&gt;s_want_extra_isize);
-			if (sbi-&gt;s_want_extra_isize &lt;
-			    le16_to_cpu(es-&gt;s_min_extra_isize))
-				sbi-&gt;s_want_extra_isize =
-					le16_to_cpu(es-&gt;s_min_extra_isize);
-		}
-	}
-	/* Check if enough inode space is available */
-	if ((sbi-&gt;s_want_extra_isize &gt; sbi-&gt;s_inode_size) ||
-	    (EXT4_GOOD_OLD_INODE_SIZE + sbi-&gt;s_want_extra_isize &gt;
-							sbi-&gt;s_inode_size)) {
-		sbi-&gt;s_want_extra_isize = def_extra_isize;
-		ext4_msg(sb, KERN_INFO,
-			 "required extra inode space not available");
-	}
-}
-
 static void ext4_set_resv_clusters(struct super_block *sb)
 {
 	ext4_fsblk_t resv_clusters;
@@ -3781,6 +3754,68 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	 */
 	sbi-&gt;s_li_wait_mult = EXT4_DEF_LI_WAIT_MULT;
 
+	if (le32_to_cpu(es-&gt;s_rev_level) == EXT4_GOOD_OLD_REV) {
+		sbi-&gt;s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;
+		sbi-&gt;s_first_ino = EXT4_GOOD_OLD_FIRST_INO;
+	} else {
+		sbi-&gt;s_inode_size = le16_to_cpu(es-&gt;s_inode_size);
+		sbi-&gt;s_first_ino = le32_to_cpu(es-&gt;s_first_ino);
+		if (sbi-&gt;s_first_ino &lt; EXT4_GOOD_OLD_FIRST_INO) {
+			ext4_msg(sb, KERN_ERR, "invalid first ino: %u",
+				 sbi-&gt;s_first_ino);
+			goto failed_mount;
+		}
+		if ((sbi-&gt;s_inode_size &lt; EXT4_GOOD_OLD_INODE_SIZE) ||
+		    (!is_power_of_2(sbi-&gt;s_inode_size)) ||
+		    (sbi-&gt;s_inode_size &gt; blocksize)) {
+			ext4_msg(sb, KERN_ERR,
+			       "unsupported inode size: %d",
+			       sbi-&gt;s_inode_size);
+			goto failed_mount;
+		}
+		/*
+		 * i_atime_extra is the last extra field available for
+		 * [acm]times in struct ext4_inode. Checking for that
+		 * field should suffice to ensure we have extra space
+		 * for all three.
+		 */
+		if (sbi-&gt;s_inode_size &gt;= offsetof(struct ext4_inode, i_atime_extra) +
+			sizeof(((struct ext4_inode *)0)-&gt;i_atime_extra)) {
+			sb-&gt;s_time_gran = 1;
+			sb-&gt;s_time_max = EXT4_EXTRA_TIMESTAMP_MAX;
+		} else {
+			sb-&gt;s_time_gran = NSEC_PER_SEC;
+			sb-&gt;s_time_max = EXT4_NON_EXTRA_TIMESTAMP_MAX;
+		}
+		sb-&gt;s_time_min = EXT4_TIMESTAMP_MIN;
+	}
+	if (sbi-&gt;s_inode_size &gt; EXT4_GOOD_OLD_INODE_SIZE) {
+		sbi-&gt;s_want_extra_isize = sizeof(struct ext4_inode) -
+			EXT4_GOOD_OLD_INODE_SIZE;
+		if (ext4_has_feature_extra_isize(sb)) {
+			unsigned v, max = (sbi-&gt;s_inode_size -
+					   EXT4_GOOD_OLD_INODE_SIZE);
+
+			v = le16_to_cpu(es-&gt;s_want_extra_isize);
+			if (v &gt; max) {
+				ext4_msg(sb, KERN_ERR,
+					 "bad s_want_extra_isize: %d", v);
+				goto failed_mount;
+			}
+			if (sbi-&gt;s_want_extra_isize &lt; v)
+				sbi-&gt;s_want_extra_isize = v;
+
+			v = le16_to_cpu(es-&gt;s_min_extra_isize);
+			if (v &gt; max) {
+				ext4_msg(sb, KERN_ERR,
+					 "bad s_min_extra_isize: %d", v);
+				goto failed_mount;
+			}
+			if (sbi-&gt;s_want_extra_isize &lt; v)
+				sbi-&gt;s_want_extra_isize = v;
+		}
+	}
+
 	if (sbi-&gt;s_es-&gt;s_mount_opts[0]) {
 		char *s_mount_opts = kstrndup(sbi-&gt;s_es-&gt;s_mount_opts,
 					      sizeof(sbi-&gt;s_es-&gt;s_mount_opts),
@@ -4019,42 +4054,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 						      has_huge_files);
 	sb-&gt;s_maxbytes = ext4_max_size(sb-&gt;s_blocksize_bits, has_huge_files);
 
-	if (le32_to_cpu(es-&gt;s_rev_level) == EXT4_GOOD_OLD_REV) {
-		sbi-&gt;s_inode_size = EXT4_GOOD_OLD_INODE_SIZE;
-		sbi-&gt;s_first_ino = EXT4_GOOD_OLD_FIRST_INO;
-	} else {
-		sbi-&gt;s_inode_size = le16_to_cpu(es-&gt;s_inode_size);
-		sbi-&gt;s_first_ino = le32_to_cpu(es-&gt;s_first_ino);
-		if (sbi-&gt;s_first_ino &lt; EXT4_GOOD_OLD_FIRST_INO) {
-			ext4_msg(sb, KERN_ERR, "invalid first ino: %u",
-				 sbi-&gt;s_first_ino);
-			goto failed_mount;
-		}
-		if ((sbi-&gt;s_inode_size &lt; EXT4_GOOD_OLD_INODE_SIZE) ||
-		    (!is_power_of_2(sbi-&gt;s_inode_size)) ||
-		    (sbi-&gt;s_inode_size &gt; blocksize)) {
-			ext4_msg(sb, KERN_ERR,
-			       "unsupported inode size: %d",
-			       sbi-&gt;s_inode_size);
-			goto failed_mount;
-		}
-		/*
-		 * i_atime_extra is the last extra field available for [acm]times in
-		 * struct ext4_inode. Checking for that field should suffice to ensure
-		 * we have extra space for all three.
-		 */
-		if (sbi-&gt;s_inode_size &gt;= offsetof(struct ext4_inode, i_atime_extra) +
-			sizeof(((struct ext4_inode *)0)-&gt;i_atime_extra)) {
-			sb-&gt;s_time_gran = 1;
-			sb-&gt;s_time_max = EXT4_EXTRA_TIMESTAMP_MAX;
-		} else {
-			sb-&gt;s_time_gran = NSEC_PER_SEC;
-			sb-&gt;s_time_max = EXT4_NON_EXTRA_TIMESTAMP_MAX;
-		}
-
-		sb-&gt;s_time_min = EXT4_TIMESTAMP_MIN;
-	}
-
 	sbi-&gt;s_desc_size = le16_to_cpu(es-&gt;s_desc_size);
 	if (ext4_has_feature_64bit(sb)) {
 		if (sbi-&gt;s_desc_size &lt; EXT4_MIN_DESC_SIZE_64BIT ||
@@ -4503,8 +4502,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	} else if (ret)
 		goto failed_mount4a;
 
-	ext4_clamp_want_extra_isize(sb);
-
 	ext4_set_resv_clusters(sb);
 
 	err = ext4_setup_system_zone(sb);
@@ -5292,8 +5289,6 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 		goto restore_opts;
 	}
 
-	ext4_clamp_want_extra_isize(sb);
-
 	if ((old_opts.s_mount_opt &amp; EXT4_MOUNT_JOURNAL_CHECKSUM) ^
 	    test_opt(sb, JOURNAL_CHECKSUM)) {
 		ext4_msg(sb, KERN_ERR, "changing journal_checksum "</pre><hr><pre>commit 707d1a2f601bea6110a5633054253c0cb71b44c1
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Dec 8 19:43:46 2019 -0500

    ext4: optimize __ext4_check_dir_entry()
    
    Make __ext4_check_dir_entry() a bit easier to understand, and reduce
    the object size of the function by over 11%.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Link: https://lore.kernel.org/r/20191209004346.38526-1-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index 6305d5ec25af..9f00fc0bf21d 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -72,6 +72,7 @@ int __ext4_check_dir_entry(const char *function, unsigned int line,
 	const char *error_msg = NULL;
 	const int rlen = ext4_rec_len_from_disk(de-&gt;rec_len,
 						dir-&gt;i_sb-&gt;s_blocksize);
+	const int next_offset = ((char *) de - buf) + rlen;
 
 	if (unlikely(rlen &lt; EXT4_DIR_REC_LEN(1)))
 		error_msg = "rec_len is smaller than minimal";
@@ -79,13 +80,11 @@ int __ext4_check_dir_entry(const char *function, unsigned int line,
 		error_msg = "rec_len % 4 != 0";
 	else if (unlikely(rlen &lt; EXT4_DIR_REC_LEN(de-&gt;name_len)))
 		error_msg = "rec_len is too small for name_len";
-	else if (unlikely(((char *) de - buf) + rlen &gt; size))
+	else if (unlikely(next_offset &gt; size))
 		error_msg = "directory entry overrun";
-	else if (unlikely(((char *) de - buf) + rlen &gt;
-			  size - EXT4_DIR_REC_LEN(1) &amp;&amp;
-			  ((char *) de - buf) + rlen != size)) {
+	else if (unlikely(next_offset &gt; size - EXT4_DIR_REC_LEN(1) &amp;&amp;
+			  next_offset != size))
 		error_msg = "directory entry too close to block end";
-	}
 	else if (unlikely(le32_to_cpu(de-&gt;inode) &gt;
 			le32_to_cpu(EXT4_SB(dir-&gt;i_sb)-&gt;s_es-&gt;s_inodes_count)))
 		error_msg = "inode out of bounds";</pre><hr><pre>commit db5cce1afc8d2475d2c1c37c2a8267dd0e151526
Author: Anders Kaseorg &lt;andersk@mit.edu&gt;
Date:   Mon Dec 2 17:09:20 2019 -0500

    Revert "iwlwifi: assign directly to iwl_trans-&gt;cfg in QuZ detection"
    
    This reverts commit 968dcfb4905245dc64d65312c0d17692fa087b99.
    
    Both that commit and commit 809805a820c6445f7a701ded24fdc6bbc841d1e4
    attempted to fix the same bug (dead assignments to the local variable
    cfg), but they did so in incompatible ways. When they were both merged,
    independently of each other, the combination actually caused the bug to
    reappear, leading to a firmware crash on boot for some cards.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=205719
    
    Signed-off-by: Anders Kaseorg &lt;andersk@mit.edu&gt;
    Acked-by: Luca Coelho &lt;luciano.coelho@intel.com&gt;
    Signed-off-by: Kalle Valo &lt;kvalo@codeaurora.org&gt;

diff --git a/drivers/net/wireless/intel/iwlwifi/pcie/drv.c b/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
index 040cec17d3ad..b0b7eca1754e 100644
--- a/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
+++ b/drivers/net/wireless/intel/iwlwifi/pcie/drv.c
@@ -1111,18 +1111,18 @@ static int iwl_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	/* same thing for QuZ... */
 	if (iwl_trans-&gt;hw_rev == CSR_HW_REV_TYPE_QUZ) {
-		if (iwl_trans-&gt;cfg == &amp;iwl_ax101_cfg_qu_hr)
-			iwl_trans-&gt;cfg = &amp;iwl_ax101_cfg_quz_hr;
-		else if (iwl_trans-&gt;cfg == &amp;iwl_ax201_cfg_qu_hr)
-			iwl_trans-&gt;cfg = &amp;iwl_ax201_cfg_quz_hr;
-		else if (iwl_trans-&gt;cfg == &amp;iwl9461_2ac_cfg_qu_b0_jf_b0)
-			iwl_trans-&gt;cfg = &amp;iwl9461_2ac_cfg_quz_a0_jf_b0_soc;
-		else if (iwl_trans-&gt;cfg == &amp;iwl9462_2ac_cfg_qu_b0_jf_b0)
-			iwl_trans-&gt;cfg = &amp;iwl9462_2ac_cfg_quz_a0_jf_b0_soc;
-		else if (iwl_trans-&gt;cfg == &amp;iwl9560_2ac_cfg_qu_b0_jf_b0)
-			iwl_trans-&gt;cfg = &amp;iwl9560_2ac_cfg_quz_a0_jf_b0_soc;
-		else if (iwl_trans-&gt;cfg == &amp;iwl9560_2ac_160_cfg_qu_b0_jf_b0)
-			iwl_trans-&gt;cfg = &amp;iwl9560_2ac_160_cfg_quz_a0_jf_b0_soc;
+		if (cfg == &amp;iwl_ax101_cfg_qu_hr)
+			cfg = &amp;iwl_ax101_cfg_quz_hr;
+		else if (cfg == &amp;iwl_ax201_cfg_qu_hr)
+			cfg = &amp;iwl_ax201_cfg_quz_hr;
+		else if (cfg == &amp;iwl9461_2ac_cfg_qu_b0_jf_b0)
+			cfg = &amp;iwl9461_2ac_cfg_quz_a0_jf_b0_soc;
+		else if (cfg == &amp;iwl9462_2ac_cfg_qu_b0_jf_b0)
+			cfg = &amp;iwl9462_2ac_cfg_quz_a0_jf_b0_soc;
+		else if (cfg == &amp;iwl9560_2ac_cfg_qu_b0_jf_b0)
+			cfg = &amp;iwl9560_2ac_cfg_quz_a0_jf_b0_soc;
+		else if (cfg == &amp;iwl9560_2ac_160_cfg_qu_b0_jf_b0)
+			cfg = &amp;iwl9560_2ac_160_cfg_quz_a0_jf_b0_soc;
 	}
 
 #endif</pre><hr><pre>commit dfdeeb41fb08fbe11d3cfefba9c0fcd00c95a36d
Merge: 3c845acd0237 c7df4a1ecb85
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Nov 19 12:25:42 2019 -0500

    Merge branch 'tt/misc' into dev
</pre><hr><pre>commit c7df4a1ecb8579838ec8c56b2bb6a6716e974f37
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Nov 11 22:18:13 2019 -0500

    ext4: work around deleting a file with i_nlink == 0 safely
    
    If the file system is corrupted such that a file's i_links_count is
    too small, then it's possible that when unlinking that file, i_nlink
    will already be zero.  Previously we were working around this kind of
    corruption by forcing i_nlink to one; but we were doing this before
    trying to delete the directory entry --- and if the file system is
    corrupted enough that ext4_delete_entry() fails, then we exit with
    i_nlink elevated, and this causes the orphan inode list handling to be
    FUBAR'ed, such that when we unmount the file system, the orphan inode
    list can get corrupted.
    
    A better way to fix this is to simply skip trying to call drop_nlink()
    if i_nlink is already zero, thus moving the check to the place where
    it makes the most sense.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=205433
    
    Link: https://lore.kernel.org/r/20191112032903.8828-1-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@kernel.org
    Reviewed-by: Andreas Dilger &lt;adilger@dilger.ca&gt;

diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index a67cae3c8ff5..a856997d87b5 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -3196,18 +3196,17 @@ static int ext4_unlink(struct inode *dir, struct dentry *dentry)
 	if (IS_DIRSYNC(dir))
 		ext4_handle_sync(handle);
 
-	if (inode-&gt;i_nlink == 0) {
-		ext4_warning_inode(inode, "Deleting file '%.*s' with no links",
-				   dentry-&gt;d_name.len, dentry-&gt;d_name.name);
-		set_nlink(inode, 1);
-	}
 	retval = ext4_delete_entry(handle, dir, de, bh);
 	if (retval)
 		goto end_unlink;
 	dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(dir);
 	ext4_update_dx_flag(dir);
 	ext4_mark_inode_dirty(handle, dir);
-	drop_nlink(inode);
+	if (inode-&gt;i_nlink == 0)
+		ext4_warning_inode(inode, "Deleting file '%.*s' with no links",
+				   dentry-&gt;d_name.len, dentry-&gt;d_name.name);
+	else
+		drop_nlink(inode);
 	if (!inode-&gt;i_nlink)
 		ext4_orphan_add(handle, inode);
 	inode-&gt;i_ctime = current_time(inode);</pre><hr><pre>commit 4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Nov 7 21:43:41 2019 -0500

    ext4: add more paranoia checking in ext4_expand_extra_isize handling
    
    It's possible to specify a non-zero s_want_extra_isize via debugging
    option, and this can cause bad things(tm) to happen when using a file
    system with an inode size of 128 bytes.
    
    Add better checking when the file system is mounted, as well as when
    we are actually doing the trying to do the inode expansion.
    
    Link: https://lore.kernel.org/r/20191110121510.GH23325@mit.edu
    Reported-by: syzbot+f8d6f8386ceacdbfff57@syzkaller.appspotmail.com
    Reported-by: syzbot+33d7ea72e47de3bdf4e1@syzkaller.appspotmail.com
    Reported-by: syzbot+44b6763edfc17144296f@syzkaller.appspotmail.com
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@kernel.org

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 381813205f99..c6e3fe287b50 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -5569,8 +5569,23 @@ static int __ext4_expand_extra_isize(struct inode *inode,
 {
 	struct ext4_inode *raw_inode;
 	struct ext4_xattr_ibody_header *header;
+	unsigned int inode_size = EXT4_INODE_SIZE(inode-&gt;i_sb);
+	struct ext4_inode_info *ei = EXT4_I(inode);
 	int error;
 
+	/* this was checked at iget time, but double check for good measure */
+	if ((EXT4_GOOD_OLD_INODE_SIZE + ei-&gt;i_extra_isize &gt; inode_size) ||
+	    (ei-&gt;i_extra_isize &amp; 3)) {
+		EXT4_ERROR_INODE(inode, "bad extra_isize %u (inode size %u)",
+				 ei-&gt;i_extra_isize,
+				 EXT4_INODE_SIZE(inode-&gt;i_sb));
+		return -EFSCORRUPTED;
+	}
+	if ((new_extra_isize &lt; ei-&gt;i_extra_isize) ||
+	    (new_extra_isize &lt; 4) ||
+	    (new_extra_isize &gt; inode_size - EXT4_GOOD_OLD_INODE_SIZE))
+		return -EINVAL;	/* Should never happen */
+
 	raw_inode = ext4_raw_inode(iloc);
 
 	header = IHDR(inode, raw_inode);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 7796e2ffc294..71af8780d4ee 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3545,12 +3545,15 @@ static void ext4_clamp_want_extra_isize(struct super_block *sb)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	struct ext4_super_block *es = sbi-&gt;s_es;
+	unsigned def_extra_isize = sizeof(struct ext4_inode) -
+						EXT4_GOOD_OLD_INODE_SIZE;
 
-	/* determine the minimum size of new large inodes, if present */
-	if (sbi-&gt;s_inode_size &gt; EXT4_GOOD_OLD_INODE_SIZE &amp;&amp;
-	    sbi-&gt;s_want_extra_isize == 0) {
-		sbi-&gt;s_want_extra_isize = sizeof(struct ext4_inode) -
-						     EXT4_GOOD_OLD_INODE_SIZE;
+	if (sbi-&gt;s_inode_size == EXT4_GOOD_OLD_INODE_SIZE) {
+		sbi-&gt;s_want_extra_isize = 0;
+		return;
+	}
+	if (sbi-&gt;s_want_extra_isize &lt; 4) {
+		sbi-&gt;s_want_extra_isize = def_extra_isize;
 		if (ext4_has_feature_extra_isize(sb)) {
 			if (sbi-&gt;s_want_extra_isize &lt;
 			    le16_to_cpu(es-&gt;s_want_extra_isize))
@@ -3563,10 +3566,10 @@ static void ext4_clamp_want_extra_isize(struct super_block *sb)
 		}
 	}
 	/* Check if enough inode space is available */
-	if (EXT4_GOOD_OLD_INODE_SIZE + sbi-&gt;s_want_extra_isize &gt;
-							sbi-&gt;s_inode_size) {
-		sbi-&gt;s_want_extra_isize = sizeof(struct ext4_inode) -
-						       EXT4_GOOD_OLD_INODE_SIZE;
+	if ((sbi-&gt;s_want_extra_isize &gt; sbi-&gt;s_inode_size) ||
+	    (EXT4_GOOD_OLD_INODE_SIZE + sbi-&gt;s_want_extra_isize &gt;
+							sbi-&gt;s_inode_size)) {
+		sbi-&gt;s_want_extra_isize = def_extra_isize;
 		ext4_msg(sb, KERN_INFO,
 			 "required extra inode space not available");
 	}</pre><hr><pre>commit 8d0d47ea1640b23678306c007ccc813b5b930af4
Merge: a6d4040846bf 378f32bab371
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Nov 5 16:21:09 2019 -0500

    Merge branch 'mb/dio' into master
</pre>
    <div class="pagination">
        <a href='1_9.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><span>[10]</span><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_11.html'>Next&gt;&gt;</a>
    <div>
</body>
