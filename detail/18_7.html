<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Queensland</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Queensland</h1>
    <div class="pagination">
        <a href='18_6.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><a href='18_3.html'>3</a><a href='18_4.html'>4</a><a href='18_5.html'>5</a><a href='18_6.html'>6</a><span>[7]</span>
    </div>
    <hr>
    <pre>commit b9f4ad57f70b8a29851b4f4247294f4aba6ae815
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Jan 9 18:21:39 2006 -0200

    V4L/DVB (3329): cx88_subids whitespace cleanup
    
    - Clean up a recently introduced spaces vs tabs whitespace problem.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@brturbo.com.br&gt;

diff --git a/drivers/media/video/cx88/cx88-cards.c b/drivers/media/video/cx88/cx88-cards.c
index a5b939622f82..a76d54503b6f 100644
--- a/drivers/media/video/cx88/cx88-cards.c
+++ b/drivers/media/video/cx88/cx88-cards.c
@@ -1237,14 +1237,14 @@ struct cx88_subid cx88_subids[] = {
 		.subdevice = 0x0025,
 		.card      = CX88_BOARD_DNTV_LIVE_DVB_T_PRO,
 	},{
-	       .subvendor = 0x17de,
-	       .subdevice = 0x08a1,
-	       .card      = CX88_BOARD_KWORLD_DVB_T_CX22702,
+		.subvendor = 0x17de,
+		.subdevice = 0x08a1,
+		.card      = CX88_BOARD_KWORLD_DVB_T_CX22702,
 	},{
 		.subvendor = 0x18ac,
 		.subdevice = 0xdb50,
 		.card      = CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL,
-       }
+	},
 };
 const unsigned int cx88_idcount = ARRAY_SIZE(cx88_subids);
 </pre><hr><pre>commit 3d7d027a9bf41437aa93baf14a1aada521ad9b12
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Jan 9 18:21:31 2006 -0200

    V4L/DVB (3315): Use correct AGC settings for DNTV Live! DVB-T Pro
    
    - My original settings for this board were incorrect and resulted in
    an increased number of signal dropouts.  Replace this with the settings
    from the Windows driver.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@brturbo.com.br&gt;

diff --git a/drivers/media/video/cx88/cx88-dvb.c b/drivers/media/video/cx88/cx88-dvb.c
index 8a5997bf4ccd..42c012aaa849 100644
--- a/drivers/media/video/cx88/cx88-dvb.c
+++ b/drivers/media/video/cx88/cx88-dvb.c
@@ -112,7 +112,7 @@ static struct videobuf_queue_ops dvb_qops = {
 /* ------------------------------------------------------------------ */
 
 #ifdef HAVE_MT352
-static int generic_mt352_demod_init(struct dvb_frontend* fe)
+static int dvico_fusionhdtv_demod_init(struct dvb_frontend* fe)
 {
 	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x39 };
 	static u8 reset []         = { RESET,      0x80 };
@@ -191,7 +191,7 @@ static int mt352_pll_set(struct dvb_frontend* fe,
 
 static struct mt352_config dvico_fusionhdtv = {
 	.demod_address = 0x0F,
-	.demod_init    = generic_mt352_demod_init,
+	.demod_init    = dvico_fusionhdtv_demod_init,
 	.pll_set       = mt352_pll_set,
 };
 
@@ -208,6 +208,29 @@ static struct mt352_config dvico_fusionhdtv_dual = {
 };
 
 #ifdef HAVE_VP3054_I2C
+static int dntv_live_dvbt_pro_demod_init(struct dvb_frontend* fe)
+{
+	static u8 clock_config []  = { 0x89, 0x38, 0x38 };
+	static u8 reset []         = { 0x50, 0x80 };
+	static u8 adc_ctl_1_cfg [] = { 0x8E, 0x40 };
+	static u8 agc_cfg []       = { 0x67, 0x10, 0x20, 0x00, 0xFF, 0xFF,
+				       0x00, 0xFF, 0x00, 0x40, 0x40 };
+	static u8 dntv_extra[]     = { 0xB5, 0x7A };
+	static u8 capt_range_cfg[] = { 0x75, 0x32 };
+
+	mt352_write(fe, clock_config,   sizeof(clock_config));
+	udelay(2000);
+	mt352_write(fe, reset,          sizeof(reset));
+	mt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));
+
+	mt352_write(fe, agc_cfg,        sizeof(agc_cfg));
+	udelay(2000);
+	mt352_write(fe, dntv_extra,     sizeof(dntv_extra));
+	mt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));
+
+	return 0;
+}
+
 static int philips_fmd1216_pll_init(struct dvb_frontend *fe)
 {
 	struct cx8802_dev *dev= fe-&gt;dvb-&gt;priv;
@@ -265,7 +288,7 @@ static int dntv_live_dvbt_pro_pll_set(struct dvb_frontend* fe,
 static struct mt352_config dntv_live_dvbt_pro_config = {
 	.demod_address = 0x0f,
 	.no_tuner      = 1,
-	.demod_init    = generic_mt352_demod_init,
+	.demod_init    = dntv_live_dvbt_pro_demod_init,
 	.pll_set       = dntv_live_dvbt_pro_pll_set,
 };
 #endif</pre><hr><pre>commit 7c239703a942117c3446ca06af537fc3ea12fb24
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Jan 9 18:21:29 2006 -0200

    V4L/DVB (3312): DViCO USB IR Remote support
    
    - Add support for the remote control receiver inside the DViCO FusionHDTV
    DVB-T Dual Digital, and a keymap for the MCE remote bundled with it.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@brturbo.com.br&gt;

diff --git a/drivers/media/dvb/dvb-usb/cxusb.c b/drivers/media/dvb/dvb-usb/cxusb.c
index 9622a79d6e68..163b69405b95 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.c
+++ b/drivers/media/dvb/dvb-usb/cxusb.c
@@ -15,6 +15,7 @@
  * part
  *
  * Copyright (C) 2005 Patrick Boettcher (patrick.boettcher@desy.de)
+ * Copyright (C) 2006 Chris Pascoe (c.pascoe@itee.uq.edu.au)
  *
  *	This program is free software; you can redistribute it and/or modify it
  *	under the terms of the GNU General Public License as published by the Free
@@ -159,6 +160,30 @@ static int cxusb_streaming_ctrl(struct dvb_usb_device *d, int onoff)
 	return 0;
 }
 
+static int cxusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
+{
+	struct dvb_usb_rc_key *keymap = d-&gt;props.rc_key_map;
+	u8 irCode[4];
+	int i;
+
+	cxusb_ctrl_msg(d, CMD_GET_IR_CODE, NULL, 0, irCode, 4);
+
+	*event = 0;
+	*state = REMOTE_NO_KEY_PRESSED;
+
+	for (i = 0; i &lt; d-&gt;props.rc_key_map_size; i++) {
+		if (keymap[i].custom == irCode[2] &amp;&amp;
+		    keymap[i].data == irCode[3]) {
+			*event = keymap[i].event;
+			*state = REMOTE_KEY_PRESSED;
+
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
 static int cxusb_dee1601_demod_init(struct dvb_frontend* fe)
 {
 	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x38 };
@@ -372,6 +397,54 @@ static struct dvb_usb_properties cxusb_bluebird_lgh064f_properties = {
 	}
 };
 
+struct dvb_usb_rc_key dvico_mce_rc_keys[] = {
+	{ 0xfe, 0x02, KEY_TV },
+	{ 0xfe, 0x0e, KEY_MP3 },
+	{ 0xfe, 0x1a, KEY_DVD },
+	{ 0xfe, 0x1e, KEY_FAVORITES },
+	{ 0xfe, 0x16, KEY_SETUP },
+	{ 0xfe, 0x46, KEY_POWER2 },
+	{ 0xfe, 0x0a, KEY_EPG },
+	{ 0xfe, 0x49, KEY_BACK },
+	{ 0xfe, 0x4d, KEY_MENU },
+	{ 0xfe, 0x51, KEY_UP },
+	{ 0xfe, 0x5b, KEY_LEFT },
+	{ 0xfe, 0x5f, KEY_RIGHT },
+	{ 0xfe, 0x53, KEY_DOWN },
+	{ 0xfe, 0x5e, KEY_OK },
+	{ 0xfe, 0x59, KEY_INFO },
+	{ 0xfe, 0x55, KEY_TAB },
+	{ 0xfe, 0x0f, KEY_PREVIOUSSONG },/* Replay */
+	{ 0xfe, 0x12, KEY_NEXTSONG },	/* Skip */
+	{ 0xfe, 0x42, KEY_ENTER	 },	/* Windows/Start */
+	{ 0xfe, 0x15, KEY_VOLUMEUP },
+	{ 0xfe, 0x05, KEY_VOLUMEDOWN },
+	{ 0xfe, 0x11, KEY_CHANNELUP },
+	{ 0xfe, 0x09, KEY_CHANNELDOWN },
+	{ 0xfe, 0x52, KEY_CAMERA },
+	{ 0xfe, 0x5a, KEY_TUNER },	/* Live */
+	{ 0xfe, 0x19, KEY_OPEN },
+	{ 0xfe, 0x0b, KEY_1 },
+	{ 0xfe, 0x17, KEY_2 },
+	{ 0xfe, 0x1b, KEY_3 },
+	{ 0xfe, 0x07, KEY_4 },
+	{ 0xfe, 0x50, KEY_5 },
+	{ 0xfe, 0x54, KEY_6 },
+	{ 0xfe, 0x48, KEY_7 },
+	{ 0xfe, 0x4c, KEY_8 },
+	{ 0xfe, 0x58, KEY_9 },
+	{ 0xfe, 0x13, KEY_ANGLE },	/* Aspect */
+	{ 0xfe, 0x03, KEY_0 },
+	{ 0xfe, 0x1f, KEY_ZOOM },
+	{ 0xfe, 0x43, KEY_REWIND },
+	{ 0xfe, 0x47, KEY_PLAYPAUSE },
+	{ 0xfe, 0x4f, KEY_FASTFORWARD },
+	{ 0xfe, 0x57, KEY_MUTE },
+	{ 0xfe, 0x0d, KEY_STOP },
+	{ 0xfe, 0x01, KEY_RECORD },
+	{ 0xfe, 0x4e, KEY_POWER },
+};
+
 static struct dvb_usb_properties cxusb_bluebird_dee1601_properties = {
 	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
 
@@ -389,6 +462,11 @@ static struct dvb_usb_properties cxusb_bluebird_dee1601_properties = {
 
 	.i2c_algo         = &amp;cxusb_i2c_algo,
 
+	.rc_interval      = 150,
+	.rc_key_map       = dvico_mce_rc_keys,
+	.rc_key_map_size  = ARRAY_SIZE(dvico_mce_rc_keys),
+	.rc_query         = cxusb_rc_query,
+
 	.generic_bulk_ctrl_endpoint = 0x01,
 	/* parameter for the MPEG2-data transfer */
 	.urb = {
diff --git a/drivers/media/dvb/dvb-usb/cxusb.h b/drivers/media/dvb/dvb-usb/cxusb.h
index 135c2a81f581..087c99427853 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.h
+++ b/drivers/media/dvb/dvb-usb/cxusb.h
@@ -21,6 +21,8 @@ extern int dvb_usb_cxusb_debug;
 #define CMD_STREAMING_ON  0x36
 #define CMD_STREAMING_OFF 0x37
 
+#define CMD_GET_IR_CODE   0x47
+
 #define CMD_ANALOG        0x50
 #define CMD_DIGITAL       0x51
 </pre><hr><pre>commit 43eabb4e2284146f8bfae8730ae41c218b724b7d
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Jan 9 18:21:28 2006 -0200

    V4L/DVB (3311): DViCO FusionHDTV DVB-T Dual Digital PCI support
    
    - Support for DVB reception on the PCI half of the DViCO DVB-T Dual Digital.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@brturbo.com.br&gt;

diff --git a/Documentation/video4linux/CARDLIST.cx88 b/Documentation/video4linux/CARDLIST.cx88
index 3d02b1f27d28..34b6e59f2968 100644
--- a/Documentation/video4linux/CARDLIST.cx88
+++ b/Documentation/video4linux/CARDLIST.cx88
@@ -42,3 +42,4 @@
  41 -&gt; Hauppauge WinTV-HVR1100 DVB-T/Hybrid (Low Profile)  [0070:9800,0070:9802]
  42 -&gt; digitalnow DNTV Live! DVB-T Pro                     [1822:0025]
  43 -&gt; KWorld/VStream XPert DVB-T with cx22702             [17de:08a1]
+ 44 -&gt; DViCO FusionHDTV DVB-T Dual Digital                 [18ac:db50]
diff --git a/drivers/media/video/cx88/cx88-cards.c b/drivers/media/video/cx88/cx88-cards.c
index ae2fdf62c8ba..a5b939622f82 100644
--- a/drivers/media/video/cx88/cx88-cards.c
+++ b/drivers/media/video/cx88/cx88-cards.c
@@ -1031,6 +1031,23 @@ struct cx88_board cx88_boards[] = {
 		}},
 		.dvb            = 1,
 	},
+	[CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL] = {
+		.name           = "DViCO FusionHDTV DVB-T Dual Digital",
+		.tuner_type     = TUNER_ABSENT, /* No analog tuner */
+		.radio_type     = UNSET,
+		.tuner_addr	= ADDR_UNSET,
+		.radio_addr	= ADDR_UNSET,
+		.input          = {{
+			.type   = CX88_VMUX_COMPOSITE1,
+			.vmux   = 1,
+			.gpio0  = 0x000027df,
+		 },{
+			.type   = CX88_VMUX_SVIDEO,
+			.vmux   = 2,
+			.gpio0  = 0x000027df,
+		}},
+		.dvb            = 1,
+	},
 
 };
 const unsigned int cx88_bcount = ARRAY_SIZE(cx88_boards);
@@ -1223,6 +1240,10 @@ struct cx88_subid cx88_subids[] = {
 	       .subvendor = 0x17de,
 	       .subdevice = 0x08a1,
 	       .card      = CX88_BOARD_KWORLD_DVB_T_CX22702,
+	},{
+		.subvendor = 0x18ac,
+		.subdevice = 0xdb50,
+		.card      = CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL,
        }
 };
 const unsigned int cx88_idcount = ARRAY_SIZE(cx88_subids);
@@ -1405,6 +1426,7 @@ void cx88_card_setup(struct cx88_core *core)
 		break;
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PLUS:
+	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL:
 		/* GPIO0:0 is hooked to mt352 reset pin */
 		cx_set(MO_GP0_IO, 0x00000101);
 		cx_clear(MO_GP0_IO, 0x00000001);
diff --git a/drivers/media/video/cx88/cx88-dvb.c b/drivers/media/video/cx88/cx88-dvb.c
index dad8a0d564fb..8a5997bf4ccd 100644
--- a/drivers/media/video/cx88/cx88-dvb.c
+++ b/drivers/media/video/cx88/cx88-dvb.c
@@ -132,6 +132,27 @@ static int generic_mt352_demod_init(struct dvb_frontend* fe)
 	return 0;
 }
 
+static int dvico_dual_demod_init(struct dvb_frontend *fe)
+{
+	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x38 };
+	static u8 reset []         = { RESET,      0x80 };
+	static u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };
+	static u8 agc_cfg []       = { AGC_TARGET, 0x28, 0x20 };
+	static u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };
+	static u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };
+
+	mt352_write(fe, clock_config,   sizeof(clock_config));
+	udelay(200);
+	mt352_write(fe, reset,          sizeof(reset));
+	mt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));
+
+	mt352_write(fe, agc_cfg,        sizeof(agc_cfg));
+	mt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));
+	mt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));
+
+	return 0;
+}
+
 static int dntv_live_dvbt_demod_init(struct dvb_frontend* fe)
 {
 	static u8 clock_config []  = { 0x89, 0x38, 0x39 };
@@ -180,6 +201,12 @@ static struct mt352_config dntv_live_dvbt_config = {
 	.pll_set       = mt352_pll_set,
 };
 
+static struct mt352_config dvico_fusionhdtv_dual = {
+	.demod_address = 0x0F,
+	.demod_init    = dvico_dual_demod_init,
+	.pll_set       = mt352_pll_set,
+};
+
 #ifdef HAVE_VP3054_I2C
 static int philips_fmd1216_pll_init(struct dvb_frontend *fe)
 {
@@ -481,6 +508,14 @@ static int dvb_register(struct cx8802_dev *dev)
 		printk("%s: built without vp3054 support\n", dev-&gt;core-&gt;name);
 #endif
 		break;
+	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL:
+		/* The tin box says DEE1601, but it seems to be DTT7579
+		 * compatible, with a slightly different MT352 AGC gain. */
+		dev-&gt;core-&gt;pll_addr = 0x61;
+		dev-&gt;core-&gt;pll_desc = &amp;dvb_pll_thomson_dtt7579;
+		dev-&gt;dvb.frontend = mt352_attach(&amp;dvico_fusionhdtv_dual,
+						 &amp;dev-&gt;core-&gt;i2c_adap);
+		break;
 #endif
 #ifdef HAVE_OR51132
 	case CX88_BOARD_PCHDTV_HD3000:
diff --git a/drivers/media/video/cx88/cx88.h b/drivers/media/video/cx88/cx88.h
index 120e5049a46f..e9fd55b57fa6 100644
--- a/drivers/media/video/cx88/cx88.h
+++ b/drivers/media/video/cx88/cx88.h
@@ -186,6 +186,7 @@ extern struct sram_channel cx88_sram_channels[];
 #define CX88_BOARD_HAUPPAUGE_HVR1100LP     41
 #define CX88_BOARD_DNTV_LIVE_DVB_T_PRO     42
 #define CX88_BOARD_KWORLD_DVB_T_CX22702    43
+#define CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL 44
 
 enum cx88_itype {
 	CX88_VMUX_COMPOSITE1 = 1,</pre><hr><pre>commit 0029ee143d66ca89d0e8b074abb452cf4ca2c53c
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Jan 9 18:21:28 2006 -0200

    V4L/DVB (3310): DViCO Dual Digital DVB-T / USB bluebird updates
    
    - Add support for the USB portion of the DViCO Dual Digital board.
    Patch correct "warm" USB IDs into bluebird firmware before download.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@brturbo.com.br&gt;

diff --git a/drivers/media/dvb/dvb-usb/cxusb.c b/drivers/media/dvb/dvb-usb/cxusb.c
index 2c1b1e5992a3..9622a79d6e68 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.c
+++ b/drivers/media/dvb/dvb-usb/cxusb.c
@@ -26,6 +26,8 @@
 
 #include "cx22702.h"
 #include "lgdt330x.h"
+#include "mt352.h"
+#include "mt352_priv.h"
 
 /* debug */
 int dvb_usb_cxusb_debug;
@@ -157,6 +159,27 @@ static int cxusb_streaming_ctrl(struct dvb_usb_device *d, int onoff)
 	return 0;
 }
 
+static int cxusb_dee1601_demod_init(struct dvb_frontend* fe)
+{
+	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x38 };
+	static u8 reset []         = { RESET,      0x80 };
+	static u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };
+	static u8 agc_cfg []       = { AGC_TARGET, 0x28, 0x20 };
+	static u8 gpp_ctl_cfg []   = { GPP_CTL,    0x33 };
+	static u8 capt_range_cfg[] = { CAPT_RANGE, 0x32 };
+
+	mt352_write(fe, clock_config,   sizeof(clock_config));
+	udelay(200);
+	mt352_write(fe, reset,          sizeof(reset));
+	mt352_write(fe, adc_ctl_1_cfg,  sizeof(adc_ctl_1_cfg));
+
+	mt352_write(fe, agc_cfg,        sizeof(agc_cfg));
+	mt352_write(fe, gpp_ctl_cfg,    sizeof(gpp_ctl_cfg));
+	mt352_write(fe, capt_range_cfg, sizeof(capt_range_cfg));
+
+	return 0;
+}
+
 struct cx22702_config cxusb_cx22702_config = {
 	.demod_address = 0x63,
 
@@ -172,6 +195,12 @@ struct lgdt330x_config cxusb_lgdt330x_config = {
 	.pll_set       = dvb_usb_pll_set_i2c,
 };
 
+struct mt352_config cxusb_dee1601_config = {
+	.demod_address = 0x0f,
+	.demod_init    = cxusb_dee1601_demod_init,
+	.pll_set       = dvb_usb_pll_set,
+};
+
 /* Callbacks for DVB USB */
 static int cxusb_fmd1216me_tuner_attach(struct dvb_usb_device *d)
 {
@@ -193,6 +222,13 @@ static int cxusb_lgh064f_tuner_attach(struct dvb_usb_device *d)
 	return 0;
 }
 
+static int cxusb_dee1601_tuner_attach(struct dvb_usb_device *d)
+{
+	d-&gt;pll_addr = 0x61;
+	d-&gt;pll_desc = &amp;dvb_pll_thomson_dtt7579;
+	return 0;
+}
+
 static int cxusb_cx22702_frontend_attach(struct dvb_usb_device *d)
 {
 	u8 b;
@@ -220,15 +256,31 @@ static int cxusb_lgdt330x_frontend_attach(struct dvb_usb_device *d)
 	return -EIO;
 }
 
+static int cxusb_dee1601_frontend_attach(struct dvb_usb_device *d)
+{
+	if (usb_set_interface(d-&gt;udev,0,0) &lt; 0)
+		err("set interface failed");
+
+	cxusb_ctrl_msg(d,CMD_DIGITAL, NULL, 0, NULL, 0);
+
+	if ((d-&gt;fe = mt352_attach(&amp;cxusb_dee1601_config, &amp;d-&gt;i2c_adap)) != NULL)
+		return 0;
+
+	return -EIO;
+}
+
 /* DVB USB Driver stuff */
 static struct dvb_usb_properties cxusb_medion_properties;
 static struct dvb_usb_properties cxusb_bluebird_lgh064f_properties;
+static struct dvb_usb_properties cxusb_bluebird_dee1601_properties;
 
 static int cxusb_probe(struct usb_interface *intf,
 		const struct usb_device_id *id)
 {
 	if (dvb_usb_device_init(intf,&amp;cxusb_medion_properties,THIS_MODULE,NULL) == 0 ||
-		dvb_usb_device_init(intf,&amp;cxusb_bluebird_lgh064f_properties,THIS_MODULE,NULL) == 0) {
+		dvb_usb_device_init(intf,&amp;cxusb_bluebird_lgh064f_properties,THIS_MODULE,NULL) == 0 ||
+		dvb_usb_device_init(intf,&amp;cxusb_bluebird_dee1601_properties,THIS_MODULE,NULL) == 0
+		){
 		return 0;
 	}
 
@@ -239,6 +291,8 @@ static struct usb_device_id cxusb_table [] = {
 		{ USB_DEVICE(USB_VID_MEDION, USB_PID_MEDION_MD95700) },
 		{ USB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LG064F_COLD) },
 		{ USB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_LG064F_WARM) },
+		{ USB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DEE1601_COLD) },
+		{ USB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DEE1601_WARM) },
 		{}		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE (usb, cxusb_table);
@@ -318,6 +372,45 @@ static struct dvb_usb_properties cxusb_bluebird_lgh064f_properties = {
 	}
 };
 
+static struct dvb_usb_properties cxusb_bluebird_dee1601_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+
+	.usb_ctrl         = CYPRESS_FX2,
+	.firmware         = "dvb-usb-bluebird-01.fw",
+	/* use usb alt setting 0 for EP4 transfer (dvb-t),
+	   use usb alt setting 7 for EP2 transfer (atsc) */
+
+	.size_of_priv     = sizeof(struct cxusb_state),
+
+	.streaming_ctrl   = cxusb_streaming_ctrl,
+	.power_ctrl       = cxusb_power_ctrl,
+	.frontend_attach  = cxusb_dee1601_frontend_attach,
+	.tuner_attach     = cxusb_dee1601_tuner_attach,
+
+	.i2c_algo         = &amp;cxusb_i2c_algo,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+	/* parameter for the MPEG2-data transfer */
+	.urb = {
+		.type = DVB_USB_BULK,
+		.count = 5,
+		.endpoint = 0x04,
+		.u = {
+			.bulk = {
+				.buffersize = 8192,
+			}
+		}
+	},
+
+	.num_device_descs = 1,
+	.devices = {
+		{   "DViCO FusionHDTV DVB-T Dual USB",
+			{ &amp;cxusb_table[3], NULL },
+			{ &amp;cxusb_table[4], NULL },
+		},
+	}
+};
+
 static struct usb_driver cxusb_driver = {
 	.name		= "dvb_usb_cxusb",
 	.probe		= cxusb_probe,
diff --git a/drivers/media/dvb/dvb-usb/dvb-usb-firmware.c b/drivers/media/dvb/dvb-usb/dvb-usb-firmware.c
index 51ce7403999b..b2670476c3f2 100644
--- a/drivers/media/dvb/dvb-usb/dvb-usb-firmware.c
+++ b/drivers/media/dvb/dvb-usb/dvb-usb-firmware.c
@@ -74,6 +74,27 @@ static int usb_cypress_load_firmware(struct usb_device *udev, const struct firmw
 	return ret;
 }
 
+/*
+ * DViCO bluebird firmware needs the "warm" product ID to be patched into the
+ * firmware file before download.
+ */
+#define BLUEBIRD_01_ID_OFFSET 6638
+static int dvb_usb_patch_dvico_firmware(struct usb_device *udev, const struct firmware *fw)
+{
+	if (fw-&gt;size &lt; BLUEBIRD_01_ID_OFFSET + 4)
+		return -EINVAL;
+
+	if (fw-&gt;data[BLUEBIRD_01_ID_OFFSET] == (USB_VID_DVICO &amp; 0xff) &amp;&amp;
+	    fw-&gt;data[BLUEBIRD_01_ID_OFFSET + 1] == USB_VID_DVICO &gt;&gt; 8) {
+		fw-&gt;data[BLUEBIRD_01_ID_OFFSET + 2] = udev-&gt;descriptor.idProduct + 1;
+		fw-&gt;data[BLUEBIRD_01_ID_OFFSET + 3] = udev-&gt;descriptor.idProduct &gt;&gt; 8;
+
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
 int dvb_usb_download_firmware(struct usb_device *udev, struct dvb_usb_properties *props)
 {
 	int ret;
@@ -88,6 +109,12 @@ int dvb_usb_download_firmware(struct usb_device *udev, struct dvb_usb_properties
 
 	info("downloading firmware from file '%s'",props-&gt;firmware);
 
+	if (le16_to_cpu(udev-&gt;descriptor.idVendor) == USB_VID_DVICO) {
+		ret = dvb_usb_patch_dvico_firmware(udev, fw);
+		if (ret != 0)
+			warn("this firmware file not recognised");
+	}
+
 	switch (props-&gt;usb_ctrl) {
 		case CYPRESS_AN2135:
 		case CYPRESS_AN2235:
diff --git a/drivers/media/dvb/dvb-usb/dvb-usb-ids.h b/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
index 784adfe1c070..d22934383226 100644
--- a/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
+++ b/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
@@ -86,13 +86,15 @@
 #define USB_PID_WINTV_NOVA_T_USB2_COLD		0x9300
 #define USB_PID_WINTV_NOVA_T_USB2_WARM		0x9301
 #define USB_PID_NEBULA_DIGITV				0x0201
-#define USB_PID_DVICO_BLUEBIRD_LGZ201		0xdb00
-#define USB_PID_DVICO_BLUEBIRD_TH7579		0xdb10
 #define USB_PID_DVICO_BLUEBIRD_LGDT			0xd820
-#define USB_PID_DVICO_BLUEBIRD_LGZ201_1		0xdb01
-#define USB_PID_DVICO_BLUEBIRD_TH7579_2		0xdb11
 #define USB_PID_DVICO_BLUEBIRD_LG064F_COLD		0xd500
-#define USB_PID_DVICO_BLUEBIRD_LG064F_WARM		0xd700
+#define USB_PID_DVICO_BLUEBIRD_LG064F_WARM		0xd501
+#define USB_PID_DVICO_BLUEBIRD_LGZ201_COLD		0xdb00
+#define USB_PID_DVICO_BLUEBIRD_LGZ201_WARM		0xdb01
+#define USB_PID_DVICO_BLUEBIRD_TH7579_COLD		0xdb10
+#define USB_PID_DVICO_BLUEBIRD_TH7579_WARM		0xdb11
+#define USB_PID_DVICO_BLUEBIRD_DEE1601_COLD		0xdb50
+#define USB_PID_DVICO_BLUEBIRD_DEE1601_WARM		0xdb51
 #define USB_PID_MEDION_MD95700				0x0932
 #define USB_PID_KYE_DVB_T_COLD				0x701e
 #define USB_PID_KYE_DVB_T_WARM				0x701f</pre><hr><pre>commit fc40b261db15d010455ad0a4e2ac59da2ced730f
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Jan 9 15:25:35 2006 -0200

    V4L/DVB (3220): Add support for VP-3054 HDTV board
    
    
    - Added support for VP-3054 (aka DigitalNow DNTV Live! DVB-T Pro!).
    - This board has a secondary I2C bus and remote control.
    - Added a new module to handle secondary I2C bus on this board.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@brturbo.com.br&gt;

diff --git a/Documentation/video4linux/CARDLIST.cx88 b/Documentation/video4linux/CARDLIST.cx88
index bb93a0a1871c..956cf833e931 100644
--- a/Documentation/video4linux/CARDLIST.cx88
+++ b/Documentation/video4linux/CARDLIST.cx88
@@ -40,3 +40,4 @@
  39 -&gt; KWorld DVB-S 100                                    [17de:08b2]
  40 -&gt; Hauppauge WinTV-HVR1100 DVB-T/Hybrid                [0070:9400,0070:9402]
  41 -&gt; Hauppauge WinTV-HVR1100 DVB-T/Hybrid (Low Profile)  [0070:9800,0070:9802]
+ 42 -&gt; digitalnow DNTV Live! DVB-T Pro                     [1822:0025]
diff --git a/drivers/media/video/cx88/Makefile b/drivers/media/video/cx88/Makefile
index 90a7ace55f64..e4b2134fe567 100644
--- a/drivers/media/video/cx88/Makefile
+++ b/drivers/media/video/cx88/Makefile
@@ -4,7 +4,7 @@ cx8800-objs	:= cx88-video.o cx88-vbi.o
 cx8802-objs	:= cx88-mpeg.o
 
 obj-$(CONFIG_VIDEO_CX88) += cx88xx.o cx8800.o cx8802.o cx88-blackbird.o
-obj-$(CONFIG_VIDEO_CX88_DVB) += cx88-dvb.o
+obj-$(CONFIG_VIDEO_CX88_DVB) += cx88-dvb.o cx88-vp3054-i2c.o
 
 EXTRA_CFLAGS += -I$(src)/..
 EXTRA_CFLAGS += -I$(srctree)/drivers/media/dvb/dvb-core
@@ -17,5 +17,6 @@ extra-cflags-$(CONFIG_DVB_LGDT330X)  += -DHAVE_LGDT330X=1
 extra-cflags-$(CONFIG_DVB_MT352)     += -DHAVE_MT352=1
 extra-cflags-$(CONFIG_DVB_NXT200X)   += -DHAVE_NXT200X=1
 extra-cflags-$(CONFIG_DVB_CX24123)   += -DHAVE_CX24123=1
+extra-cflags-$(CONFIG_VIDEO_CX88_DVB)+= -DHAVE_VP3054_I2C=1
 
 EXTRA_CFLAGS += $(extra-cflags-y) $(extra-cflags-m)
diff --git a/drivers/media/video/cx88/cx88-cards.c b/drivers/media/video/cx88/cx88-cards.c
index 85798e1fa047..6b17d1e1e520 100644
--- a/drivers/media/video/cx88/cx88-cards.c
+++ b/drivers/media/video/cx88/cx88-cards.c
@@ -982,6 +982,33 @@ struct cx88_board cx88_boards[] = {
 		/* fixme: Add radio support */
 		.dvb		= 1,
 	},
+	[CX88_BOARD_DNTV_LIVE_DVB_T_PRO] = {
+		.name           = "digitalnow DNTV Live! DVB-T Pro",
+		.tuner_type     = TUNER_PHILIPS_FMD1216ME_MK3,
+		.radio_type     = UNSET,
+		.tuner_addr	= ADDR_UNSET,
+		.radio_addr	= ADDR_UNSET,
+		.tda9887_conf   = TDA9887_PRESENT | TDA9887_PORT1_ACTIVE |
+				  TDA9887_PORT2_ACTIVE,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+			.gpio0  = 0xf80808,
+		},{
+			.type   = CX88_VMUX_COMPOSITE1,
+			.vmux   = 1,
+			.gpio0	= 0xf80808,
+		},{
+			.type   = CX88_VMUX_SVIDEO,
+			.vmux   = 2,
+			.gpio0	= 0xf80808,
+		}},
+		.radio = {
+			 .type  = CX88_RADIO,
+			 .gpio0 = 0xf80808,
+		},
+		.dvb            = 1,
+	},
 };
 const unsigned int cx88_bcount = ARRAY_SIZE(cx88_boards);
 
@@ -1165,6 +1192,10 @@ struct cx88_subid cx88_subids[] = {
 		.subvendor = 0x0070,
 		.subdevice = 0x9001,
 		.card      = CX88_BOARD_HAUPPAUGE_DVB_T1,
+	},{
+		.subvendor = 0x1822,
+		.subdevice = 0x0025,
+		.card      = CX88_BOARD_DNTV_LIVE_DVB_T_PRO,
 	},
 };
 const unsigned int cx88_idcount = ARRAY_SIZE(cx88_subids);
@@ -1362,6 +1393,9 @@ void cx88_card_setup(struct cx88_core *core)
 		cx_clear(MO_GP0_IO, 0x00000007);
 		cx_set(MO_GP2_IO, 0x00000101);
 		break;
+	case CX88_BOARD_DNTV_LIVE_DVB_T_PRO:
+		cx_write(MO_GP0_IO, 0x00080808);
+		break;
 	case CX88_BOARD_ATI_HDTVWONDER:
 		if (0 == core-&gt;i2c_rc) {
 			/* enable tuner */
diff --git a/drivers/media/video/cx88/cx88-dvb.c b/drivers/media/video/cx88/cx88-dvb.c
index ed5cfe5f5c0e..201050478711 100644
--- a/drivers/media/video/cx88/cx88-dvb.c
+++ b/drivers/media/video/cx88/cx88-dvb.c
@@ -3,7 +3,7 @@
  * device driver for Conexant 2388x based TV cards
  * MPEG Transport Stream (DVB) routines
  *
- * (c) 2004 Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
+ * (c) 2004, 2005 Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
  * (c) 2004 Gerd Knorr &lt;kraxel@bytesex.org&gt; [SuSE Labs]
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -35,6 +35,9 @@
 #ifdef HAVE_MT352
 # include "mt352.h"
 # include "mt352_priv.h"
+# ifdef HAVE_VP3054_I2C
+#  include "cx88-vp3054-i2c.h"
+# endif
 #endif
 #ifdef HAVE_CX22702
 # include "cx22702.h"
@@ -108,7 +111,7 @@ static struct videobuf_queue_ops dvb_qops = {
 /* ------------------------------------------------------------------ */
 
 #ifdef HAVE_MT352
-static int dvico_fusionhdtv_demod_init(struct dvb_frontend* fe)
+static int generic_mt352_demod_init(struct dvb_frontend* fe)
 {
 	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x39 };
 	static u8 reset []         = { RESET,      0x80 };
@@ -166,7 +169,7 @@ static int mt352_pll_set(struct dvb_frontend* fe,
 
 static struct mt352_config dvico_fusionhdtv = {
 	.demod_address = 0x0F,
-	.demod_init    = dvico_fusionhdtv_demod_init,
+	.demod_init    = generic_mt352_demod_init,
 	.pll_set       = mt352_pll_set,
 };
 
@@ -175,6 +178,69 @@ static struct mt352_config dntv_live_dvbt_config = {
 	.demod_init    = dntv_live_dvbt_demod_init,
 	.pll_set       = mt352_pll_set,
 };
+
+#ifdef HAVE_VP3054_I2C
+static int philips_fmd1216_pll_init(struct dvb_frontend *fe)
+{
+	struct cx8802_dev *dev= fe-&gt;dvb-&gt;priv;
+
+	/* this message is to set up ATC and ALC */
+	static u8 fmd1216_init[] = { 0x0b, 0xdc, 0x9c, 0xa0 };
+	struct i2c_msg msg =
+		{ .addr = dev-&gt;core-&gt;pll_addr, .flags = 0,
+		  .buf = fmd1216_init, .len = sizeof(fmd1216_init) };
+	int err;
+
+	if ((err = i2c_transfer(&amp;dev-&gt;core-&gt;i2c_adap, &amp;msg, 1)) != 1) {
+		if (err &lt; 0)
+			return err;
+		else
+			return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static int dntv_live_dvbt_pro_pll_set(struct dvb_frontend* fe,
+				      struct dvb_frontend_parameters* params,
+				      u8* pllbuf)
+{
+	struct cx8802_dev *dev= fe-&gt;dvb-&gt;priv;
+	struct i2c_msg msg =
+		{ .addr = dev-&gt;core-&gt;pll_addr, .flags = 0,
+		  .buf = pllbuf+1, .len = 4 };
+	int err;
+
+	/* Switch PLL to DVB mode */
+	err = philips_fmd1216_pll_init(fe);
+	if (err)
+		return err;
+
+	/* Tune PLL */
+	pllbuf[0] = dev-&gt;core-&gt;pll_addr &lt;&lt; 1;
+	dvb_pll_configure(dev-&gt;core-&gt;pll_desc, pllbuf+1,
+			  params-&gt;frequency,
+			  params-&gt;u.ofdm.bandwidth);
+	if ((err = i2c_transfer(&amp;dev-&gt;core-&gt;i2c_adap, &amp;msg, 1)) != 1) {
+		printk(KERN_WARNING "cx88-dvb: %s error "
+			   "(addr %02x &lt;- %02x, err = %i)\n",
+			   __FUNCTION__, pllbuf[0], pllbuf[1], err);
+		if (err &lt; 0)
+			return err;
+		else
+			return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static struct mt352_config dntv_live_dvbt_pro_config = {
+	.demod_address = 0x0f,
+	.no_tuner      = 1,
+	.demod_init    = generic_mt352_demod_init,
+	.pll_set       = dntv_live_dvbt_pro_pll_set,
+};
+#endif
 #endif
 
 #ifdef HAVE_CX22702
@@ -403,6 +469,16 @@ static int dvb_register(struct cx8802_dev *dev)
 		dev-&gt;dvb.frontend = mt352_attach(&amp;dntv_live_dvbt_config,
 						 &amp;dev-&gt;core-&gt;i2c_adap);
 		break;
+	case CX88_BOARD_DNTV_LIVE_DVB_T_PRO:
+#ifdef HAVE_VP3054_I2C
+		dev-&gt;core-&gt;pll_addr = 0x61;
+		dev-&gt;core-&gt;pll_desc = &amp;dvb_pll_fmd1216me;
+		dev-&gt;dvb.frontend = mt352_attach(&amp;dntv_live_dvbt_pro_config,
+			&amp;((struct vp3054_i2c_state *)dev-&gt;card_priv)-&gt;adap);
+#else
+		printk("%s: built without vp3054 support\n", dev-&gt;core-&gt;name);
+#endif
+		break;
 #endif
 #ifdef HAVE_OR51132
 	case CX88_BOARD_PCHDTV_HD3000:
@@ -532,6 +608,12 @@ static int __devinit dvb_probe(struct pci_dev *pci_dev,
 	if (0 != err)
 		goto fail_free;
 
+#ifdef HAVE_VP3054_I2C
+	err = vp3054_i2c_probe(dev);
+	if (0 != err)
+		goto fail_free;
+#endif
+
 	/* dvb stuff */
 	printk("%s/2: cx2388x based dvb card\n", core-&gt;name);
 	videobuf_queue_init(&amp;dev-&gt;dvb.dvbq, &amp;dvb_qops,
@@ -567,6 +649,10 @@ static void __devexit dvb_remove(struct pci_dev *pci_dev)
 	/* dvb */
 	videobuf_dvb_unregister(&amp;dev-&gt;dvb);
 
+#ifdef HAVE_VP3054_I2C
+	vp3054_i2c_remove(dev);
+#endif
+
 	/* common */
 	cx8802_fini_common(dev);
 	cx88_core_put(dev-&gt;core,dev-&gt;pci);
diff --git a/drivers/media/video/cx88/cx88-input.c b/drivers/media/video/cx88/cx88-input.c
index 649bbf7bcc29..f40f97026b84 100644
--- a/drivers/media/video/cx88/cx88-input.c
+++ b/drivers/media/video/cx88/cx88-input.c
@@ -5,7 +5,7 @@
  *
  * Copyright (c) 2003 Pavel Machek
  * Copyright (c) 2004 Gerd Knorr
- * Copyright (c) 2004 Chris Pascoe
+ * Copyright (c) 2004, 2005 Chris Pascoe
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -305,6 +305,66 @@ static IR_KEYTAB_TYPE ir_codes_avertv_303[IR_KEYTAB_SIZE] = {
 
 /* ---------------------------------------------------------------------- */
 
+/* DigitalNow DNTV Live! DVB-T Pro Remote */
+static IR_KEYTAB_TYPE ir_codes_dntv_live_dvbt_pro[IR_KEYTAB_SIZE] = {
+	[ 0x16 ] = KEY_POWER,
+	[ 0x5b ] = KEY_HOME,
+
+	[ 0x55 ] = KEY_TV,		/* live tv */
+	[ 0x58 ] = KEY_TUNER,		/* digital Radio */
+	[ 0x5a ] = KEY_RADIO,		/* FM radio */
+	[ 0x59 ] = KEY_DVD,		/* dvd menu */
+	[ 0x03 ] = KEY_1,
+	[ 0x01 ] = KEY_2,
+	[ 0x06 ] = KEY_3,
+	[ 0x09 ] = KEY_4,
+	[ 0x1d ] = KEY_5,
+	[ 0x1f ] = KEY_6,
+	[ 0x0d ] = KEY_7,
+	[ 0x19 ] = KEY_8,
+	[ 0x1b ] = KEY_9,
+	[ 0x0c ] = KEY_CANCEL,
+	[ 0x15 ] = KEY_0,
+	[ 0x4a ] = KEY_CLEAR,
+	[ 0x13 ] = KEY_BACK,
+	[ 0x00 ] = KEY_TAB,
+	[ 0x4b ] = KEY_UP,
+	[ 0x4e ] = KEY_LEFT,
+	[ 0x4f ] = KEY_OK,
+	[ 0x52 ] = KEY_RIGHT,
+	[ 0x51 ] = KEY_DOWN,
+	[ 0x1e ] = KEY_VOLUMEUP,
+	[ 0x0a ] = KEY_VOLUMEDOWN,
+	[ 0x02 ] = KEY_CHANNELDOWN,
+	[ 0x05 ] = KEY_CHANNELUP,
+	[ 0x11 ] = KEY_RECORD,
+	[ 0x14 ] = KEY_PLAY,
+	[ 0x4c ] = KEY_PAUSE,
+	[ 0x1a ] = KEY_STOP,
+	[ 0x40 ] = KEY_REWIND,
+	[ 0x12 ] = KEY_FASTFORWARD,
+	[ 0x41 ] = KEY_PREVIOUSSONG,	/* replay |&lt; */
+	[ 0x42 ] = KEY_NEXTSONG,	/* skip &gt;| */
+	[ 0x54 ] = KEY_CAMERA,		/* capture */
+	[ 0x50 ] = KEY_LANGUAGE,	/* sap */
+	[ 0x47 ] = KEY_TV2,		/* pip */
+	[ 0x4d ] = KEY_SCREEN,
+	[ 0x43 ] = KEY_SUBTITLE,
+	[ 0x10 ] = KEY_MUTE,
+	[ 0x49 ] = KEY_AUDIO,		/* l/r */
+	[ 0x07 ] = KEY_SLEEP,
+	[ 0x08 ] = KEY_VIDEO,		/* a/v */
+	[ 0x0e ] = KEY_PREVIOUS,	/* recall */
+	[ 0x45 ] = KEY_ZOOM,		/* zoom + */
+	[ 0x46 ] = KEY_ANGLE,		/* zoom - */
+	[ 0x56 ] = KEY_RED,
+	[ 0x57 ] = KEY_GREEN,
+	[ 0x5c ] = KEY_YELLOW,
+	[ 0x5d ] = KEY_BLUE,
+};
+
+/* ---------------------------------------------------------------------- */
+
 struct cx88_IR {
 	struct cx88_core *core;
 	struct input_dev *input;
@@ -313,7 +373,7 @@ struct cx88_IR {
 	char phys[32];
 
 	/* sample from gpio pin 16 */
-	int sampling;
+	u32 sampling;
 	u32 samples[16];
 	int scount;
 	unsigned long release;
@@ -431,7 +491,7 @@ int cx88_ir_init(struct cx88_core *core, struct pci_dev *pci)
 	case CX88_BOARD_TERRATEC_CINERGY_1400_DVB_T1:
 		ir_codes = ir_codes_cinergy_1400;
 		ir_type = IR_TYPE_PD;
-		ir-&gt;sampling = 1;
+		ir-&gt;sampling = 0xeb04; /* address */
 		break;
 	case CX88_BOARD_HAUPPAUGE:
 	case CX88_BOARD_HAUPPAUGE_DVB_T1:
@@ -484,6 +544,11 @@ int cx88_ir_init(struct cx88_core *core, struct pci_dev *pci)
 		ir-&gt;mask_keydown = 0x02;
 		ir-&gt;polling      = 50; /* ms */
 		break;
+	case CX88_BOARD_DNTV_LIVE_DVB_T_PRO:
+		ir_codes = ir_codes_dntv_live_dvbt_pro;
+		ir_type = IR_TYPE_PD;
+		ir-&gt;sampling = 0xff00; /* address */
+		break;
 	}
 
 	if (NULL == ir_codes) {
@@ -541,6 +606,10 @@ int cx88_ir_fini(struct cx88_core *core)
 	if (NULL == ir)
 		return 0;
 
+	if (ir-&gt;sampling) {
+		cx_write(MO_DDSCFG_IO, 0x0);
+		core-&gt;pci_irqmask &amp;= ~(1 &lt;&lt; 18);
+	}
 	if (ir-&gt;polling) {
 		del_timer(&amp;ir-&gt;timer);
 		flush_scheduled_work();
@@ -592,6 +661,7 @@ void cx88_ir_irq(struct cx88_core *core)
 	/* decode it */
 	switch (core-&gt;board) {
 	case CX88_BOARD_TERRATEC_CINERGY_1400_DVB_T1:
+	case CX88_BOARD_DNTV_LIVE_DVB_T_PRO:
 		ircode = ir_decode_pulsedistance(ir-&gt;samples, ir-&gt;scount, 1, 4);
 
 		if (ircode == 0xffffffff) { /* decoding error */
@@ -607,7 +677,7 @@ void cx88_ir_irq(struct cx88_core *core)
 			break;
 		}
 
-		if ((ircode &amp; 0xffff) != 0xeb04) { /* wrong address */
+		if ((ircode &amp; 0xffff) != (ir-&gt;sampling &amp; 0xffff)) { /* wrong address */
 			ir_dprintk("pulse distance decoded wrong address\n");
 			break;
 		}
diff --git a/drivers/media/video/cx88/cx88-vp3054-i2c.c b/drivers/media/video/cx88/cx88-vp3054-i2c.c
new file mode 100644
index 000000000000..372cd29cedbd
--- /dev/null
+++ b/drivers/media/video/cx88/cx88-vp3054-i2c.c
@@ -0,0 +1,173 @@
+/*
+
+    cx88-vp3054-i2c.c  --  support for the secondary I2C bus of the
+			   DNTV Live! DVB-T Pro (VP-3054), wired as:
+			   GPIO[0] -&gt; SCL, GPIO[1] -&gt; SDA
+
+    (c) 2005 Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/moduleparam.h&gt;
+#include &lt;linux/init.h&gt;
+
+#include &lt;asm/io.h&gt;
+
+#include "cx88.h"
+#include "cx88-vp3054-i2c.h"
+
+
+/* ----------------------------------------------------------------------- */
+
+static void vp3054_bit_setscl(void *data, int state)
+{
+	struct cx8802_dev *dev = data;
+	struct cx88_core *core = dev-&gt;core;
+	struct vp3054_i2c_state *vp3054_i2c = dev-&gt;card_priv;
+
+	if (state) {
+		vp3054_i2c-&gt;state |=  0x0001;	/* SCL high */
+		vp3054_i2c-&gt;state &amp;= ~0x0100;	/* external pullup */
+	} else {
+		vp3054_i2c-&gt;state &amp;= ~0x0001;	/* SCL low */
+		vp3054_i2c-&gt;state |=  0x0100;	/* drive pin */
+	}
+	cx_write(MO_GP0_IO, 0x010000 | vp3054_i2c-&gt;state);
+	cx_read(MO_GP0_IO);
+}
+
+static void vp3054_bit_setsda(void *data, int state)
+{
+	struct cx8802_dev *dev = data;
+	struct cx88_core *core = dev-&gt;core;
+	struct vp3054_i2c_state *vp3054_i2c = dev-&gt;card_priv;
+
+	if (state) {
+		vp3054_i2c-&gt;state |=  0x0002;	/* SDA high */
+		vp3054_i2c-&gt;state &amp;= ~0x0200;	/* tristate pin */
+	} else {
+		vp3054_i2c-&gt;state &amp;= ~0x0002;	/* SDA low */
+		vp3054_i2c-&gt;state |=  0x0200;	/* drive pin */
+	}
+	cx_write(MO_GP0_IO, 0x020000 | vp3054_i2c-&gt;state);
+	cx_read(MO_GP0_IO);
+}
+
+static int vp3054_bit_getscl(void *data)
+{
+	struct cx8802_dev *dev = data;
+	struct cx88_core *core = dev-&gt;core;
+	u32 state;
+
+	state = cx_read(MO_GP0_IO);
+	return (state &amp; 0x01) ? 1 : 0;
+}
+
+static int vp3054_bit_getsda(void *data)
+{
+	struct cx8802_dev *dev = data;
+	struct cx88_core *core = dev-&gt;core;
+	u32 state;
+
+	state = cx_read(MO_GP0_IO);
+	return (state &amp; 0x02) ? 1 : 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static struct i2c_algo_bit_data vp3054_i2c_algo_template = {
+	.setsda  = vp3054_bit_setsda,
+	.setscl  = vp3054_bit_setscl,
+	.getsda  = vp3054_bit_getsda,
+	.getscl  = vp3054_bit_getscl,
+	.udelay  = 16,
+	.mdelay  = 10,
+	.timeout = 200,
+};
+
+/* ----------------------------------------------------------------------- */
+
+static struct i2c_adapter vp3054_i2c_adap_template = {
+	.name              = "cx2388x",
+	.owner             = THIS_MODULE,
+	.id                = I2C_HW_B_CX2388x,
+};
+
+static struct i2c_client vp3054_i2c_client_template = {
+	.name	= "VP-3054",
+};
+
+int vp3054_i2c_probe(struct cx8802_dev *dev)
+{
+	struct cx88_core *core = dev-&gt;core;
+	struct vp3054_i2c_state *vp3054_i2c;
+	int rc;
+
+	if (core-&gt;board != CX88_BOARD_DNTV_LIVE_DVB_T_PRO)
+		return 0;
+
+	dev-&gt;card_priv = kzalloc(sizeof(*vp3054_i2c), GFP_KERNEL);
+	if (dev-&gt;card_priv == NULL)
+		return -ENOMEM;
+	vp3054_i2c = dev-&gt;card_priv;
+
+	memcpy(&amp;vp3054_i2c-&gt;adap, &amp;vp3054_i2c_adap_template,
+	       sizeof(vp3054_i2c-&gt;adap));
+	memcpy(&amp;vp3054_i2c-&gt;algo, &amp;vp3054_i2c_algo_template,
+	       sizeof(vp3054_i2c-&gt;algo));
+	memcpy(&amp;vp3054_i2c-&gt;client, &amp;vp3054_i2c_client_template,
+	       sizeof(vp3054_i2c-&gt;client));
+
+	vp3054_i2c-&gt;adap.class |= I2C_CLASS_TV_DIGITAL;
+
+	vp3054_i2c-&gt;adap.dev.parent = &amp;dev-&gt;pci-&gt;dev;
+	strlcpy(vp3054_i2c-&gt;adap.name, core-&gt;name,
+		sizeof(vp3054_i2c-&gt;adap.name));
+	vp3054_i2c-&gt;algo.data = dev;
+	i2c_set_adapdata(&amp;vp3054_i2c-&gt;adap, dev);
+	vp3054_i2c-&gt;adap.algo_data = &amp;vp3054_i2c-&gt;algo;
+	vp3054_i2c-&gt;client.adapter = &amp;vp3054_i2c-&gt;adap;
+
+	vp3054_bit_setscl(dev,1);
+	vp3054_bit_setsda(dev,1);
+
+	rc = i2c_bit_add_bus(&amp;vp3054_i2c-&gt;adap);
+	if (0 != rc) {
+		printk("%s: vp3054_i2c register FAILED\n", core-&gt;name);
+
+		kfree(dev-&gt;card_priv);
+		dev-&gt;card_priv = NULL;
+	}
+
+	return rc;
+}
+
+void vp3054_i2c_remove(struct cx8802_dev *dev)
+{
+	struct vp3054_i2c_state *vp3054_i2c = dev-&gt;card_priv;
+
+	if (vp3054_i2c == NULL ||
+	    dev-&gt;core-&gt;board != CX88_BOARD_DNTV_LIVE_DVB_T_PRO)
+		return;
+
+	i2c_bit_del_bus(&amp;vp3054_i2c-&gt;adap);
+	kfree(vp3054_i2c);
+}
+
+EXPORT_SYMBOL(vp3054_i2c_probe);
+EXPORT_SYMBOL(vp3054_i2c_remove);
diff --git a/drivers/media/video/cx88/cx88-vp3054-i2c.h b/drivers/media/video/cx88/cx88-vp3054-i2c.h
new file mode 100644
index 000000000000..b7a0a04d2423
--- /dev/null
+++ b/drivers/media/video/cx88/cx88-vp3054-i2c.h
@@ -0,0 +1,35 @@
+/*
+
+    cx88-vp3054-i2c.h  --  support for the secondary I2C bus of the
+			   DNTV Live! DVB-T Pro (VP-3054), wired as:
+			   GPIO[0] -&gt; SCL, GPIO[1] -&gt; SDA
+
+    (c) 2005 Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+*/
+
+/* ----------------------------------------------------------------------- */
+struct vp3054_i2c_state {
+	struct i2c_adapter         adap;
+	struct i2c_algo_bit_data   algo;
+	struct i2c_client          client;
+	u32                        state;
+};
+
+/* ----------------------------------------------------------------------- */
+int  vp3054_i2c_probe(struct cx8802_dev *dev);
+void vp3054_i2c_remove(struct cx8802_dev *dev);
diff --git a/drivers/media/video/cx88/cx88.h b/drivers/media/video/cx88/cx88.h
index 0bbf68b325c4..6d370d1b333f 100644
--- a/drivers/media/video/cx88/cx88.h
+++ b/drivers/media/video/cx88/cx88.h
@@ -184,6 +184,7 @@ extern struct sram_channel cx88_sram_channels[];
 #define CX88_BOARD_KWORLD_DVBS_100         39
 #define CX88_BOARD_HAUPPAUGE_HVR1100       40
 #define CX88_BOARD_HAUPPAUGE_HVR1100LP     41
+#define CX88_BOARD_DNTV_LIVE_DVB_T_PRO     42
 
 enum cx88_itype {
 	CX88_VMUX_COMPOSITE1 = 1,
@@ -422,6 +423,8 @@ struct cx8802_dev {
 	struct videobuf_dvb        dvb;
 	void*                      fe_handle;
 	int                        (*fe_release)(void *handle);
+
+	void			   *card_priv;
 	/* for switching modulation types */
 	unsigned char              ts_gen_cntrl;
 </pre><hr><pre>commit 889aee805a0c286e33965cc678ea16672d6c5666
Author: Christopher Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Jan 9 15:25:28 2006 -0200

    V4L/DVB (3192): Fix bttv sub-device unregister
    
    
    - Fixes sub-device release for BTTV. Without this, DVB modules can't be reloaded
    
    Signed-off-by: Ricardo Cerqueira &lt;v4l@cerqueira.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@brturbo.com.br&gt;

diff --git a/drivers/media/video/bttv-driver.c b/drivers/media/video/bttv-driver.c
index 4e25c92ac8c4..69a147b85f1a 100644
--- a/drivers/media/video/bttv-driver.c
+++ b/drivers/media/video/bttv-driver.c
@@ -4075,8 +4075,6 @@ static int __devinit bttv_probe(struct pci_dev *dev,
 	}
 
 	/* add subdevices */
-	if (btv-&gt;has_remote)
-		bttv_sub_add_device(&amp;btv-&gt;c, "remote");
 	if (bttv_tvcards[btv-&gt;c.type].has_dvb)
 		bttv_sub_add_device(&amp;btv-&gt;c, "dvb");
 
@@ -4117,7 +4115,7 @@ static void __devexit bttv_remove(struct pci_dev *pci_dev)
 	btv-&gt;shutdown=1;
 	wake_up(&amp;btv-&gt;gpioq);
 	bttv_input_fini(btv);
-	//bttv_sub_del_devices(&amp;btv-&gt;c);
+	bttv_sub_del_devices(&amp;btv-&gt;c);
 
 	/* unregister i2c_bus + input */
 	fini_bttv_i2c(btv);</pre>
    <div class="pagination">
        <a href='18_6.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><a href='18_3.html'>3</a><a href='18_4.html'>4</a><a href='18_5.html'>5</a><a href='18_6.html'>6</a><span>[7]</span>
    <div>
</body>
