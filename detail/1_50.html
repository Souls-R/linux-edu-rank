<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_49.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><span>[50]</span><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_51.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit f4afb4f4e3e9af626ad695c87e4f9aaa780b29ec
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Jun 6 11:40:37 2013 -0400

    ext4: optimize test_root()
    
    The test_root() function could potentially loop forever due to
    overflow issues.  So rewrite test_root() to avoid this issue; as a
    bonus, it is 38% faster when benchmarked via a test loop:
    
    int main(int argc, char **argv)
    {
            int  i;
    
            for (i = 0; i &lt; 1 &lt;&lt; 24; i++) {
                    if (test_root(i, 7))
                            printf("%d\n", i);
            }
    }
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index d0f13eada0ed..58339393fa6e 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -682,11 +682,15 @@ ext4_fsblk_t ext4_count_free_clusters(struct super_block *sb)
 
 static inline int test_root(ext4_group_t a, int b)
 {
-	int num = b;
-
-	while (a &gt; num)
-		num *= b;
-	return num == a;
+	while (1) {
+		if (a &lt; b)
+			return 0;
+		if (a == b)
+			return 1;
+		if ((a % b) != 0)
+			return 0;
+		a = a / b;
+	}
 }
 
 static int ext4_group_sparse(ext4_group_t group)</pre><hr><pre>commit 2f2e09eb15849562aede80ed007658e4504ded26
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Jun 6 11:16:43 2013 -0400

    ext4: add sanity check to ext4_get_group_info()
    
    The group number passed to ext4_get_group_info() should be valid, but
    let's add an assert to check this before we start creating a pointer
    based on that group number and dereferencing it.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index bd9890f6d9ce..f85f1fb49df8 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2313,6 +2313,7 @@ struct ext4_group_info *ext4_get_group_info(struct super_block *sb,
 {
 	 struct ext4_group_info ***grp_info;
 	 long indexv, indexh;
+	 BUG_ON(group &gt;= EXT4_SB(sb)-&gt;s_groups_count);
 	 grp_info = EXT4_SB(sb)-&gt;s_group_info;
 	 indexv = group &gt;&gt; (EXT4_DESC_PER_BLOCK_BITS(sb));
 	 indexh = group &amp; ((EXT4_DESC_PER_BLOCK(sb)) - 1);</pre><hr><pre>commit b302ef2d3c73d8a07ed2f0679ce35f00b6dcacef
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Jun 6 11:14:31 2013 -0400

    ext4: verify group number in verify_group_input() before using it
    
    Check the group number for sanity earilier, before calling routines
    such as ext4_bg_has_super() or ext4_group_overhead_blocks().
    
    Reported-by: Jonathan Salwan &lt;jonathan.salwan@gmail.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index b27c96d01965..6ed4df27da8d 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -79,12 +79,20 @@ static int verify_group_input(struct super_block *sb,
 	ext4_fsblk_t end = start + input-&gt;blocks_count;
 	ext4_group_t group = input-&gt;group;
 	ext4_fsblk_t itend = input-&gt;inode_table + sbi-&gt;s_itb_per_group;
-	unsigned overhead = ext4_group_overhead_blocks(sb, group);
-	ext4_fsblk_t metaend = start + overhead;
+	unsigned overhead;
+	ext4_fsblk_t metaend;
 	struct buffer_head *bh = NULL;
 	ext4_grpblk_t free_blocks_count, offset;
 	int err = -EINVAL;
 
+	if (group != sbi-&gt;s_groups_count) {
+		ext4_warning(sb, "Cannot add at group %u (only %u groups)",
+			     input-&gt;group, sbi-&gt;s_groups_count);
+		return -EINVAL;
+	}
+
+	overhead = ext4_group_overhead_blocks(sb, group);
+	metaend = start + overhead;
 	input-&gt;free_blocks_count = free_blocks_count =
 		input-&gt;blocks_count - 2 - overhead - sbi-&gt;s_itb_per_group;
 
@@ -96,10 +104,7 @@ static int verify_group_input(struct super_block *sb,
 		       free_blocks_count, input-&gt;reserved_blocks);
 
 	ext4_get_group_no_and_offset(sb, start, NULL, &amp;offset);
-	if (group != sbi-&gt;s_groups_count)
-		ext4_warning(sb, "Cannot add at group %u (only %u groups)",
-			     input-&gt;group, sbi-&gt;s_groups_count);
-	else if (offset != 0)
+	if (offset != 0)
 			ext4_warning(sb, "Last group not full");
 	else if (input-&gt;reserved_blocks &gt; input-&gt;blocks_count / 5)
 		ext4_warning(sb, "Reserved blocks too high (%u)",</pre><hr><pre>commit a1d8d9a757cd46e044a3f6061c315eda14bf697e
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Jun 6 10:18:22 2013 -0400

    ext4: add check to io_submit_init_bio
    
    The bio_alloc() function can return NULL if the memory allocation
    fails.  So we need to check for this.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c
index ce8c15a7eabc..48786cdb5e6c 100644
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@ -372,6 +372,8 @@ static int io_submit_init_bio(struct ext4_io_submit *io,
 	struct bio *bio;
 
 	bio = bio_alloc(GFP_NOIO, min(nvecs, BIO_MAX_PAGES));
+	if (!bio)
+		return -ENOMEM;
 	bio-&gt;bi_sector = bh-&gt;b_blocknr * (bh-&gt;b_size &gt;&gt; 9);
 	bio-&gt;bi_bdev = bh-&gt;b_bdev;
 	bio-&gt;bi_end_io = ext4_end_bio;</pre><hr><pre>commit a549984b8c95acbecefd1fdd4bfdbea4d29b0588
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat May 11 19:07:42 2013 -0400

    ext4: revert "ext4: use io_end for multiple bios"
    
    This reverts commit 4eec708d263f0ee10861d69251708a225b64cac7.
    
    Multiple users have reported crashes which is apparently caused by
    this commit.  Thanks to Dmitry Monakhov for bisecting it.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Dmitry Monakhov &lt;dmonakhov@openvz.org&gt;
    Cc: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 0aabb344b02e..5aae3d12d400 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -209,7 +209,6 @@ typedef struct ext4_io_end {
 	ssize_t			size;		/* size of the extent */
 	struct kiocb		*iocb;		/* iocb struct for AIO */
 	int			result;		/* error value for AIO */
-	atomic_t		count;		/* reference counter */
 } ext4_io_end_t;
 
 struct ext4_io_submit {
@@ -2651,14 +2650,11 @@ extern int ext4_move_extents(struct file *o_filp, struct file *d_filp,
 
 /* page-io.c */
 extern int __init ext4_init_pageio(void);
+extern void ext4_add_complete_io(ext4_io_end_t *io_end);
 extern void ext4_exit_pageio(void);
 extern void ext4_ioend_shutdown(struct inode *);
+extern void ext4_free_io_end(ext4_io_end_t *io);
 extern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);
-extern ext4_io_end_t *ext4_get_io_end(ext4_io_end_t *io_end);
-extern int ext4_put_io_end(ext4_io_end_t *io_end);
-extern void ext4_put_io_end_defer(ext4_io_end_t *io_end);
-extern void ext4_io_submit_init(struct ext4_io_submit *io,
-				struct writeback_control *wbc);
 extern void ext4_end_io_work(struct work_struct *work);
 extern void ext4_io_submit(struct ext4_io_submit *io);
 extern int ext4_bio_write_page(struct ext4_io_submit *io,
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 793d44b84d7f..d66656992358 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1487,10 +1487,7 @@ static int mpage_da_submit_io(struct mpage_da_data *mpd,
 	struct ext4_io_submit io_submit;
 
 	BUG_ON(mpd-&gt;next_page &lt;= mpd-&gt;first_page);
-	ext4_io_submit_init(&amp;io_submit, mpd-&gt;wbc);
-	io_submit.io_end = ext4_init_io_end(inode, GFP_NOFS);
-	if (!io_submit.io_end)
-		return -ENOMEM;
+	memset(&amp;io_submit, 0, sizeof(io_submit));
 	/*
 	 * We need to start from the first_page to the next_page - 1
 	 * to make sure we also write the mapped dirty buffer_heads.
@@ -1578,8 +1575,6 @@ static int mpage_da_submit_io(struct mpage_da_data *mpd,
 		pagevec_release(&amp;pvec);
 	}
 	ext4_io_submit(&amp;io_submit);
-	/* Drop io_end reference we got from init */
-	ext4_put_io_end_defer(io_submit.io_end);
 	return ret;
 }
 
@@ -2238,16 +2233,9 @@ static int ext4_writepage(struct page *page,
 		 */
 		return __ext4_journalled_writepage(page, len);
 
-	ext4_io_submit_init(&amp;io_submit, wbc);
-	io_submit.io_end = ext4_init_io_end(inode, GFP_NOFS);
-	if (!io_submit.io_end) {
-		redirty_page_for_writepage(wbc, page);
-		return -ENOMEM;
-	}
+	memset(&amp;io_submit, 0, sizeof(io_submit));
 	ret = ext4_bio_write_page(&amp;io_submit, page, len, wbc);
 	ext4_io_submit(&amp;io_submit);
-	/* Drop io_end reference we got from init */
-	ext4_put_io_end_defer(io_submit.io_end);
 	return ret;
 }
 
@@ -3078,13 +3066,9 @@ static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
 	struct inode *inode = file_inode(iocb-&gt;ki_filp);
         ext4_io_end_t *io_end = iocb-&gt;private;
 
-	/* if not async direct IO just return */
-	if (!io_end) {
-		inode_dio_done(inode);
-		if (is_async)
-			aio_complete(iocb, ret, 0);
-		return;
-	}
+	/* if not async direct IO or dio with 0 bytes write, just return */
+	if (!io_end || !size)
+		goto out;
 
 	ext_debug("ext4_end_io_dio(): io_end 0x%p "
 		  "for inode %lu, iocb 0x%p, offset %llu, size %zd\n",
@@ -3092,13 +3076,25 @@ static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
 		  size);
 
 	iocb-&gt;private = NULL;
+
+	/* if not aio dio with unwritten extents, just free io and return */
+	if (!(io_end-&gt;flag &amp; EXT4_IO_END_UNWRITTEN)) {
+		ext4_free_io_end(io_end);
+out:
+		inode_dio_done(inode);
+		if (is_async)
+			aio_complete(iocb, ret, 0);
+		return;
+	}
+
 	io_end-&gt;offset = offset;
 	io_end-&gt;size = size;
 	if (is_async) {
 		io_end-&gt;iocb = iocb;
 		io_end-&gt;result = ret;
 	}
-	ext4_put_io_end_defer(io_end);
+
+	ext4_add_complete_io(io_end);
 }
 
 /*
@@ -3132,7 +3128,6 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
 	get_block_t *get_block_func = NULL;
 	int dio_flags = 0;
 	loff_t final_size = offset + count;
-	ext4_io_end_t *io_end = NULL;
 
 	/* Use the old path for reads and writes beyond i_size. */
 	if (rw != WRITE || final_size &gt; inode-&gt;i_size)
@@ -3171,16 +3166,13 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
 	iocb-&gt;private = NULL;
 	ext4_inode_aio_set(inode, NULL);
 	if (!is_sync_kiocb(iocb)) {
-		io_end = ext4_init_io_end(inode, GFP_NOFS);
+		ext4_io_end_t *io_end = ext4_init_io_end(inode, GFP_NOFS);
 		if (!io_end) {
 			ret = -ENOMEM;
 			goto retake_lock;
 		}
 		io_end-&gt;flag |= EXT4_IO_END_DIRECT;
-		/*
-		 * Grab reference for DIO. Will be dropped in ext4_end_io_dio()
-		 */
-		iocb-&gt;private = ext4_get_io_end(io_end);
+		iocb-&gt;private = io_end;
 		/*
 		 * we save the io structure for current async direct
 		 * IO, so that later ext4_map_blocks() could flag the
@@ -3204,27 +3196,26 @@ static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,
 				   NULL,
 				   dio_flags);
 
+	if (iocb-&gt;private)
+		ext4_inode_aio_set(inode, NULL);
 	/*
-	 * Put our reference to io_end. This can free the io_end structure e.g.
-	 * in sync IO case or in case of error. It can even perform extent
-	 * conversion if all bios we submitted finished before we got here.
-	 * Note that in that case iocb-&gt;private can be already set to NULL
-	 * here.
+	 * The io_end structure takes a reference to the inode, that
+	 * structure needs to be destroyed and the reference to the
+	 * inode need to be dropped, when IO is complete, even with 0
+	 * byte write, or failed.
+	 *
+	 * In the successful AIO DIO case, the io_end structure will
+	 * be destroyed and the reference to the inode will be dropped
+	 * after the end_io call back function is called.
+	 *
+	 * In the case there is 0 byte write, or error case, since VFS
+	 * direct IO won't invoke the end_io call back function, we
+	 * need to free the end_io structure here.
 	 */
-	if (io_end) {
-		ext4_inode_aio_set(inode, NULL);
-		ext4_put_io_end(io_end);
-		/*
-		 * In case of error or no write ext4_end_io_dio() was not
-		 * called so we have to put iocb's reference.
-		 */
-		if (ret &lt;= 0 &amp;&amp; ret != -EIOCBQUEUED) {
-			WARN_ON(iocb-&gt;private != io_end);
-			ext4_put_io_end(io_end);
-			iocb-&gt;private = NULL;
-		}
-	}
-	if (ret &gt; 0 &amp;&amp; !overwrite &amp;&amp; ext4_test_inode_state(inode,
+	if (ret != -EIOCBQUEUED &amp;&amp; ret &lt;= 0 &amp;&amp; iocb-&gt;private) {
+		ext4_free_io_end(iocb-&gt;private);
+		iocb-&gt;private = NULL;
+	} else if (ret &gt; 0 &amp;&amp; !overwrite &amp;&amp; ext4_test_inode_state(inode,
 						EXT4_STATE_DIO_UNWRITTEN)) {
 		int err;
 		/*
diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c
index 5929cd0baa20..6626aba57ebb 100644
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@ -61,28 +61,15 @@ void ext4_ioend_shutdown(struct inode *inode)
 		cancel_work_sync(&amp;EXT4_I(inode)-&gt;i_unwritten_work);
 }
 
-static void ext4_release_io_end(ext4_io_end_t *io_end)
+void ext4_free_io_end(ext4_io_end_t *io)
 {
-	BUG_ON(!list_empty(&amp;io_end-&gt;list));
-	BUG_ON(io_end-&gt;flag &amp; EXT4_IO_END_UNWRITTEN);
-
-	if (atomic_dec_and_test(&amp;EXT4_I(io_end-&gt;inode)-&gt;i_ioend_count))
-		wake_up_all(ext4_ioend_wq(io_end-&gt;inode));
-	if (io_end-&gt;flag &amp; EXT4_IO_END_DIRECT)
-		inode_dio_done(io_end-&gt;inode);
-	if (io_end-&gt;iocb)
-		aio_complete(io_end-&gt;iocb, io_end-&gt;result, 0);
-	kmem_cache_free(io_end_cachep, io_end);
-}
-
-static void ext4_clear_io_unwritten_flag(ext4_io_end_t *io_end)
-{
-	struct inode *inode = io_end-&gt;inode;
+	BUG_ON(!io);
+	BUG_ON(!list_empty(&amp;io-&gt;list));
+	BUG_ON(io-&gt;flag &amp; EXT4_IO_END_UNWRITTEN);
 
-	io_end-&gt;flag &amp;= ~EXT4_IO_END_UNWRITTEN;
-	/* Wake up anyone waiting on unwritten extent conversion */
-	if (atomic_dec_and_test(&amp;EXT4_I(inode)-&gt;i_unwritten))
-		wake_up_all(ext4_ioend_wq(inode));
+	if (atomic_dec_and_test(&amp;EXT4_I(io-&gt;inode)-&gt;i_ioend_count))
+		wake_up_all(ext4_ioend_wq(io-&gt;inode));
+	kmem_cache_free(io_end_cachep, io);
 }
 
 /* check a range of space and convert unwritten extents to written. */
@@ -105,8 +92,13 @@ static int ext4_end_io(ext4_io_end_t *io)
 			 "(inode %lu, offset %llu, size %zd, error %d)",
 			 inode-&gt;i_ino, offset, size, ret);
 	}
-	ext4_clear_io_unwritten_flag(io);
-	ext4_release_io_end(io);
+	/* Wake up anyone waiting on unwritten extent conversion */
+	if (atomic_dec_and_test(&amp;EXT4_I(inode)-&gt;i_unwritten))
+		wake_up_all(ext4_ioend_wq(inode));
+	if (io-&gt;flag &amp; EXT4_IO_END_DIRECT)
+		inode_dio_done(inode);
+	if (io-&gt;iocb)
+		aio_complete(io-&gt;iocb, io-&gt;result, 0);
 	return ret;
 }
 
@@ -137,7 +129,7 @@ static void dump_completed_IO(struct inode *inode)
 }
 
 /* Add the io_end to per-inode completed end_io list. */
-static void ext4_add_complete_io(ext4_io_end_t *io_end)
+void ext4_add_complete_io(ext4_io_end_t *io_end)
 {
 	struct ext4_inode_info *ei = EXT4_I(io_end-&gt;inode);
 	struct workqueue_struct *wq;
@@ -174,6 +166,8 @@ static int ext4_do_flush_completed_IO(struct inode *inode)
 		err = ext4_end_io(io);
 		if (unlikely(!ret &amp;&amp; err))
 			ret = err;
+		io-&gt;flag &amp;= ~EXT4_IO_END_UNWRITTEN;
+		ext4_free_io_end(io);
 	}
 	return ret;
 }
@@ -205,43 +199,10 @@ ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags)
 		atomic_inc(&amp;EXT4_I(inode)-&gt;i_ioend_count);
 		io-&gt;inode = inode;
 		INIT_LIST_HEAD(&amp;io-&gt;list);
-		atomic_set(&amp;io-&gt;count, 1);
 	}
 	return io;
 }
 
-void ext4_put_io_end_defer(ext4_io_end_t *io_end)
-{
-	if (atomic_dec_and_test(&amp;io_end-&gt;count)) {
-		if (!(io_end-&gt;flag &amp; EXT4_IO_END_UNWRITTEN) || !io_end-&gt;size) {
-			ext4_release_io_end(io_end);
-			return;
-		}
-		ext4_add_complete_io(io_end);
-	}
-}
-
-int ext4_put_io_end(ext4_io_end_t *io_end)
-{
-	int err = 0;
-
-	if (atomic_dec_and_test(&amp;io_end-&gt;count)) {
-		if (io_end-&gt;flag &amp; EXT4_IO_END_UNWRITTEN) {
-			err = ext4_convert_unwritten_extents(io_end-&gt;inode,
-						io_end-&gt;offset, io_end-&gt;size);
-			ext4_clear_io_unwritten_flag(io_end);
-		}
-		ext4_release_io_end(io_end);
-	}
-	return err;
-}
-
-ext4_io_end_t *ext4_get_io_end(ext4_io_end_t *io_end)
-{
-	atomic_inc(&amp;io_end-&gt;count);
-	return io_end;
-}
-
 /*
  * Print an buffer I/O error compatible with the fs/buffer.c.  This
  * provides compatibility with dmesg scrapers that look for a specific
@@ -324,7 +285,12 @@ static void ext4_end_bio(struct bio *bio, int error)
 			     bi_sector &gt;&gt; (inode-&gt;i_blkbits - 9));
 	}
 
-	ext4_put_io_end_defer(io_end);
+	if (!(io_end-&gt;flag &amp; EXT4_IO_END_UNWRITTEN)) {
+		ext4_free_io_end(io_end);
+		return;
+	}
+
+	ext4_add_complete_io(io_end);
 }
 
 void ext4_io_submit(struct ext4_io_submit *io)
@@ -338,37 +304,40 @@ void ext4_io_submit(struct ext4_io_submit *io)
 		bio_put(io-&gt;io_bio);
 	}
 	io-&gt;io_bio = NULL;
-}
-
-void ext4_io_submit_init(struct ext4_io_submit *io,
-			 struct writeback_control *wbc)
-{
-	io-&gt;io_op = (wbc-&gt;sync_mode == WB_SYNC_ALL ?  WRITE_SYNC : WRITE);
-	io-&gt;io_bio = NULL;
+	io-&gt;io_op = 0;
 	io-&gt;io_end = NULL;
 }
 
-static int io_submit_init_bio(struct ext4_io_submit *io,
-			      struct buffer_head *bh)
+static int io_submit_init(struct ext4_io_submit *io,
+			  struct inode *inode,
+			  struct writeback_control *wbc,
+			  struct buffer_head *bh)
 {
+	ext4_io_end_t *io_end;
+	struct page *page = bh-&gt;b_page;
 	int nvecs = bio_get_nr_vecs(bh-&gt;b_bdev);
 	struct bio *bio;
 
+	io_end = ext4_init_io_end(inode, GFP_NOFS);
+	if (!io_end)
+		return -ENOMEM;
 	bio = bio_alloc(GFP_NOIO, min(nvecs, BIO_MAX_PAGES));
 	bio-&gt;bi_sector = bh-&gt;b_blocknr * (bh-&gt;b_size &gt;&gt; 9);
 	bio-&gt;bi_bdev = bh-&gt;b_bdev;
+	bio-&gt;bi_private = io-&gt;io_end = io_end;
 	bio-&gt;bi_end_io = ext4_end_bio;
-	bio-&gt;bi_private = ext4_get_io_end(io-&gt;io_end);
-	if (!io-&gt;io_end-&gt;size)
-		io-&gt;io_end-&gt;offset = (bh-&gt;b_page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT)
-				     + bh_offset(bh);
+
+	io_end-&gt;offset = (page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT) + bh_offset(bh);
+
 	io-&gt;io_bio = bio;
+	io-&gt;io_op = (wbc-&gt;sync_mode == WB_SYNC_ALL ?  WRITE_SYNC : WRITE);
 	io-&gt;io_next_block = bh-&gt;b_blocknr;
 	return 0;
 }
 
 static int io_submit_add_bh(struct ext4_io_submit *io,
 			    struct inode *inode,
+			    struct writeback_control *wbc,
 			    struct buffer_head *bh)
 {
 	ext4_io_end_t *io_end;
@@ -379,18 +348,18 @@ static int io_submit_add_bh(struct ext4_io_submit *io,
 		ext4_io_submit(io);
 	}
 	if (io-&gt;io_bio == NULL) {
-		ret = io_submit_init_bio(io, bh);
+		ret = io_submit_init(io, inode, wbc, bh);
 		if (ret)
 			return ret;
 	}
-	ret = bio_add_page(io-&gt;io_bio, bh-&gt;b_page, bh-&gt;b_size, bh_offset(bh));
-	if (ret != bh-&gt;b_size)
-		goto submit_and_retry;
 	io_end = io-&gt;io_end;
 	if (test_clear_buffer_uninit(bh))
 		ext4_set_io_unwritten_flag(inode, io_end);
-	io_end-&gt;size += bh-&gt;b_size;
+	io-&gt;io_end-&gt;size += bh-&gt;b_size;
 	io-&gt;io_next_block++;
+	ret = bio_add_page(io-&gt;io_bio, bh-&gt;b_page, bh-&gt;b_size, bh_offset(bh));
+	if (ret != bh-&gt;b_size)
+		goto submit_and_retry;
 	return 0;
 }
 
@@ -462,7 +431,7 @@ int ext4_bio_write_page(struct ext4_io_submit *io,
 	do {
 		if (!buffer_async_write(bh))
 			continue;
-		ret = io_submit_add_bh(io, inode, bh);
+		ret = io_submit_add_bh(io, inode, wbc, bh);
 		if (ret) {
 			/*
 			 * We only get here on ENOMEM.  Not much else</pre><hr><pre>commit 0d606e2c9fccdd4e67febf1e2da500e1bfe9e045
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Apr 23 08:59:35 2013 -0400

    ext4: fix type-widening bug in inode table readahead code
    
    Due to a missing cast, the high 32-bits of a 64-bit block number used
    when calculating the readahead block for inode tables can get lost.
    This means we can end up fetching the wrong blocks for readahead for
    file systems &gt; 16TB.
    
    Linus found this when experimenting with an enhacement to the sparse
    static code checker which checks for missing widening casts before
    binary "not" operators.
    
    Reported-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index d7518e2728f1..793d44b84d7f 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4011,13 +4011,14 @@ static int __ext4_get_inode_loc(struct inode *inode,
 		if (EXT4_SB(sb)-&gt;s_inode_readahead_blks) {
 			ext4_fsblk_t b, end, table;
 			unsigned num;
+			__u32 ra_blks = EXT4_SB(sb)-&gt;s_inode_readahead_blks;
 
 			table = ext4_inode_table(sb, gdp);
 			/* s_inode_readahead_blks is always a power of 2 */
-			b = block &amp; ~(EXT4_SB(sb)-&gt;s_inode_readahead_blks-1);
+			b = block &amp; ~((ext4_fsblk_t) ra_blks - 1);
 			if (table &gt; b)
 				b = table;
-			end = b + EXT4_SB(sb)-&gt;s_inode_readahead_blks;
+			end = b + ra_blks;
 			num = EXT4_INODES_PER_GROUP(sb);
 			if (ext4_has_group_desc_csum(sb))
 				num -= ext4_itable_unused_count(sb, gdp);</pre><hr><pre>commit 3f8a6411fbada1fa482276591e037f3b1adcf55b
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Apr 21 22:56:32 2013 -0400

    ext4: add check for inodes_count overflow in new resize ioctl
    
    Addresses-Red-Hat-Bugzilla: #913245
    
    Reported-by: Eric Sandeen &lt;sandeen@redhat.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Carlos Maiolino &lt;cmaiolino@redhat.com&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index 08d2312c0fd4..b27c96d01965 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -1882,6 +1882,10 @@ int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)
 		return 0;
 
 	n_group = ext4_get_group_number(sb, n_blocks_count - 1);
+	if (n_group &gt; (0xFFFFFFFFUL / EXT4_INODES_PER_GROUP(sb))) {
+		ext4_warning(sb, "resize would cause inodes_count overflow");
+		return -EINVAL;
+	}
 	ext4_get_group_no_and_offset(sb, o_blocks_count - 1, &amp;o_group, &amp;offset);
 
 	n_desc_blocks = num_desc_blocks(sb, n_group + 1);</pre><hr><pre>commit 7f3e3c7cfcec148ccca9c0dd2dbfd7b00b7ac10f
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Apr 21 20:32:03 2013 -0400

    ext4: fix Kconfig documentation for CONFIG_EXT4_DEBUG
    
    Fox the Kconfig documentation for CONFIG_EXT4_DEBUG to match the
    change made by commit a0b30c1229: ext4: use module parameters instead
    of debugfs for mballoc_debug
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/Kconfig b/fs/ext4/Kconfig
index 987358740cb9..efea5d5c44ce 100644
--- a/fs/ext4/Kconfig
+++ b/fs/ext4/Kconfig
@@ -71,4 +71,5 @@ config EXT4_DEBUG
 	  Enables run-time debugging support for the ext4 filesystem.
 
 	  If you select Y here, then you will be able to turn on debugging
-	  with a command such as "echo 1 &gt; /sys/kernel/debug/ext4/mballoc-debug"
+	  with a command such as:
+		echo 1 &gt; /sys/module/ext4/parameters/mballoc_debug</pre><hr><pre>commit c5c72d814cf0f650010337c73638b25e6d14d2d4
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Apr 21 20:19:43 2013 -0400

    ext4: fix online resizing for ext3-compat file systems
    
    Commit fb0a387dcdc restricts block allocations for indirect-mapped
    files to block groups less than s_blockfile_groups.  However, the
    online resizing code wasn't setting s_blockfile_groups, so the newly
    added block groups were not available for non-extent mapped files.
    
    Reported-by: Eric Sandeen &lt;sandeen@redhat.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index e3498534a2c1..08d2312c0fd4 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -1341,6 +1341,8 @@ static void ext4_update_super(struct super_block *sb,
 
 	/* Update the global fs size fields */
 	sbi-&gt;s_groups_count += flex_gd-&gt;count;
+	sbi-&gt;s_blockfile_groups = min_t(ext4_group_t, sbi-&gt;s_groups_count,
+			(EXT4_MAX_BLOCK_FILE_PHYS / EXT4_BLOCKS_PER_GROUP(sb)));
 
 	/* Update the reserved block counts only once the new group is
 	 * active. */</pre><hr><pre>commit f783f091e49ce4896e6b026af82d76e0537c6089
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Apr 21 16:47:54 2013 -0400

    jbd2: trace when lock_buffer in do_get_write_access takes a long time
    
    While investigating interactivity problems it was clear that processes
    sometimes stall for long periods of times if an attempt is made to
    lock a buffer which is undergoing writeback.  It would stall in
    a trace looking something like
    
    [&lt;ffffffff811a39de&gt;] __lock_buffer+0x2e/0x30
    [&lt;ffffffff8123a60f&gt;] do_get_write_access+0x43f/0x4b0
    [&lt;ffffffff8123a7cb&gt;] jbd2_journal_get_write_access+0x2b/0x50
    [&lt;ffffffff81220f79&gt;] __ext4_journal_get_write_access+0x39/0x80
    [&lt;ffffffff811f3198&gt;] ext4_reserve_inode_write+0x78/0xa0
    [&lt;ffffffff811f3209&gt;] ext4_mark_inode_dirty+0x49/0x220
    [&lt;ffffffff811f57d1&gt;] ext4_dirty_inode+0x41/0x60
    [&lt;ffffffff8119ac3e&gt;] __mark_inode_dirty+0x4e/0x2d0
    [&lt;ffffffff8118b9b9&gt;] update_time+0x79/0xc0
    [&lt;ffffffff8118ba98&gt;] file_update_time+0x98/0x100
    [&lt;ffffffff81110ffc&gt;] __generic_file_aio_write+0x17c/0x3b0
    [&lt;ffffffff811112aa&gt;] generic_file_aio_write+0x7a/0xf0
    [&lt;ffffffff811ea853&gt;] ext4_file_write+0x83/0xd0
    [&lt;ffffffff81172b23&gt;] do_sync_write+0xa3/0xe0
    [&lt;ffffffff811731ae&gt;] vfs_write+0xae/0x180
    [&lt;ffffffff8117361d&gt;] sys_write+0x4d/0x90
    [&lt;ffffffff8159d62d&gt;] system_call_fastpath+0x1a/0x1f
    [&lt;ffffffffffffffff&gt;] 0xffffffffffffffff
    
    Signed-off-by: Mel Gorman &lt;mgorman@suse.de&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index a1920da22802..10f524c59ea8 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -639,6 +639,7 @@ do_get_write_access(handle_t *handle, struct journal_head *jh,
 	int error;
 	char *frozen_buffer = NULL;
 	int need_copy = 0;
+	unsigned long start_lock, time_lock;
 
 	if (is_handle_aborted(handle))
 		return -EROFS;
@@ -654,9 +655,16 @@ do_get_write_access(handle_t *handle, struct journal_head *jh,
 
 	/* @@@ Need to check for errors here at some point. */
 
+ 	start_lock = jiffies;
 	lock_buffer(bh);
 	jbd_lock_bh_state(bh);
 
+	/* If it takes too long to lock the buffer, trace it */
+	time_lock = jbd2_time_diff(start_lock, jiffies);
+	if (time_lock &gt; HZ/10)
+		trace_jbd2_lock_buffer_stall(bh-&gt;b_bdev-&gt;bd_dev,
+			jiffies_to_msecs(time_lock));
+
 	/* We now hold the buffer lock so it is safe to query the buffer
 	 * state.  Is the buffer dirty?
 	 *
diff --git a/include/trace/events/jbd2.h b/include/trace/events/jbd2.h
index 070df49e4a1d..c1d1f3eb242d 100644
--- a/include/trace/events/jbd2.h
+++ b/include/trace/events/jbd2.h
@@ -358,6 +358,27 @@ TRACE_EVENT(jbd2_write_superblock,
 		  MINOR(__entry-&gt;dev), __entry-&gt;write_op)
 );
 
+TRACE_EVENT(jbd2_lock_buffer_stall,
+
+	TP_PROTO(dev_t dev, unsigned long stall_ms),
+
+	TP_ARGS(dev, stall_ms),
+
+	TP_STRUCT__entry(
+		__field(        dev_t, dev	)
+		__field(unsigned long, stall_ms	)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= dev;
+		__entry-&gt;stall_ms	= stall_ms;
+	),
+
+	TP_printk("dev %d,%d stall_ms %lu",
+		MAJOR(__entry-&gt;dev), MINOR(__entry-&gt;dev),
+		__entry-&gt;stall_ms)
+);
+
 #endif /* _TRACE_JBD2_H */
 
 /* This part must be outside protection */</pre>
    <div class="pagination">
        <a href='1_49.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><span>[50]</span><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_51.html'>Next&gt;&gt;</a>
    <div>
</body>
