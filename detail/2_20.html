<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_19.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><span>[20]</span><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_21.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1fbbb78f25d1291274f320462bf6908906f538db
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 21 13:22:00 2017 -0400

    USB: g_mass_storage: Fix deadlock when driver is unbound
    
    As a holdover from the old g_file_storage gadget, the g_mass_storage
    legacy gadget driver attempts to unregister itself when its main
    operating thread terminates (if it hasn't been unregistered already).
    This is not strictly necessary; it was never more than an attempt to
    have the gadget fail cleanly if something went wrong and the main
    thread was killed.
    
    However, now that the UDC core manages gadget drivers independently of
    UDC drivers, this scheme doesn't work any more.  A simple test:
    
            modprobe dummy-hcd
            modprobe g-mass-storage file=...
            rmmod dummy-hcd
    
    ends up in a deadlock with the following backtrace:
    
     sysrq: SysRq : Show Blocked State
       task                PC stack   pid father
     file-storage    D    0  1130      2 0x00000000
     Call Trace:
      __schedule+0x53e/0x58c
      schedule+0x6e/0x77
      schedule_preempt_disabled+0xd/0xf
      __mutex_lock.isra.1+0x129/0x224
      ? _raw_spin_unlock_irqrestore+0x12/0x14
      __mutex_lock_slowpath+0x12/0x14
      mutex_lock+0x28/0x2b
      usb_gadget_unregister_driver+0x29/0x9b [udc_core]
      usb_composite_unregister+0x10/0x12 [libcomposite]
      msg_cleanup+0x1d/0x20 [g_mass_storage]
      msg_thread_exits+0xd/0xdd7 [g_mass_storage]
      fsg_main_thread+0x1395/0x13d6 [usb_f_mass_storage]
      ? __schedule+0x573/0x58c
      kthread+0xd9/0xdb
      ? do_set_interface+0x25c/0x25c [usb_f_mass_storage]
      ? init_completion+0x1e/0x1e
      ret_from_fork+0x19/0x24
     rmmod           D    0  1155    683 0x00000000
     Call Trace:
      __schedule+0x53e/0x58c
      schedule+0x6e/0x77
      schedule_timeout+0x26/0xbc
      ? __schedule+0x573/0x58c
      do_wait_for_common+0xb3/0x128
      ? usleep_range+0x81/0x81
      ? wake_up_q+0x3f/0x3f
      wait_for_common+0x2e/0x45
      wait_for_completion+0x17/0x19
      fsg_common_put+0x34/0x81 [usb_f_mass_storage]
      fsg_free_inst+0x13/0x1e [usb_f_mass_storage]
      usb_put_function_instance+0x1a/0x25 [libcomposite]
      msg_unbind+0x2a/0x42 [g_mass_storage]
      __composite_unbind+0x4a/0x6f [libcomposite]
      composite_unbind+0x12/0x14 [libcomposite]
      usb_gadget_remove_driver+0x4f/0x77 [udc_core]
      usb_del_gadget_udc+0x52/0xcc [udc_core]
      dummy_udc_remove+0x27/0x2c [dummy_hcd]
      platform_drv_remove+0x1d/0x31
      device_release_driver_internal+0xe9/0x16d
      device_release_driver+0x11/0x13
      bus_remove_device+0xd2/0xe2
      device_del+0x19f/0x221
      ? selinux_capable+0x22/0x27
      platform_device_del+0x21/0x63
      platform_device_unregister+0x10/0x1a
      cleanup+0x20/0x817 [dummy_hcd]
      SyS_delete_module+0x10c/0x197
      ? ____fput+0xd/0xf
      ? task_work_run+0x55/0x62
      ? prepare_exit_to_usermode+0x65/0x75
      do_fast_syscall_32+0x86/0xc3
      entry_SYSENTER_32+0x4e/0x7c
    
    What happens is that removing the dummy-hcd driver causes the UDC core
    to unbind the gadget driver, which it does while holding the udc_lock
    mutex.  The unbind routine in g_mass_storage tells the main thread to
    exit and waits for it to terminate.
    
    But as mentioned above, when the main thread exits it tries to
    unregister the mass-storage function driver.  Via the composite
    framework this ends up calling usb_gadget_unregister_driver(), which
    tries to acquire the udc_lock mutex.  The result is deadlock.
    
    The simplest way to fix the problem is not to be so clever: The main
    thread doesn't have to unregister the function driver.  The side
    effects won't be so terrible; if the gadget is still attached to a USB
    host when the main thread is killed, it will appear to the host as
    though the gadget's firmware has crashed -- a reasonably accurate
    interpretation, and an all-too-common occurrence for USB mass-storage
    devices.
    
    In fact, the code to unregister the driver when the main thread exits
    is specific to g-mass-storage; it is not used when f-mass-storage is
    included as a function in a larger composite device.  Therefore the
    entire mechanism responsible for this (the fsg_operations structure
    with its -&gt;thread_exits method, the fsg_common_set_ops() routine, and
    the msg_thread_exits() callback routine) can all be eliminated.  Even
    the msg_registered bitflag can be removed, because now the driver is
    unregistered in only one place rather than in two places.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;
    Acked-by: Michal Nazarewicz &lt;mina86@mina86.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index d6bd0244b008..5153e29870c3 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -307,8 +307,6 @@ struct fsg_common {
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
 
-	/* Callback functions. */
-	const struct fsg_operations	*ops;
 	/* Gadget's private data. */
 	void			*private_data;
 
@@ -2438,6 +2436,7 @@ static void handle_exception(struct fsg_common *common)
 static int fsg_main_thread(void *common_)
 {
 	struct fsg_common	*common = common_;
+	int			i;
 
 	/*
 	 * Allow the thread to be killed by a signal, but set the signal mask
@@ -2476,21 +2475,16 @@ static int fsg_main_thread(void *common_)
 	common-&gt;thread_task = NULL;
 	spin_unlock_irq(&amp;common-&gt;lock);
 
-	if (!common-&gt;ops || !common-&gt;ops-&gt;thread_exits
-	 || common-&gt;ops-&gt;thread_exits(common) &lt; 0) {
-		int i;
+	/* Eject media from all LUNs */
 
-		down_write(&amp;common-&gt;filesem);
-		for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); i++) {
-			struct fsg_lun *curlun = common-&gt;luns[i];
-			if (!curlun || !fsg_lun_is_open(curlun))
-				continue;
+	down_write(&amp;common-&gt;filesem);
+	for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); i++) {
+		struct fsg_lun *curlun = common-&gt;luns[i];
 
+		if (curlun &amp;&amp; fsg_lun_is_open(curlun))
 			fsg_lun_close(curlun);
-			curlun-&gt;unit_attention_data = SS_MEDIUM_NOT_PRESENT;
-		}
-		up_write(&amp;common-&gt;filesem);
 	}
+	up_write(&amp;common-&gt;filesem);
 
 	/* Let fsg_unbind() know the thread has exited */
 	complete_and_exit(&amp;common-&gt;thread_notifier, 0);
@@ -2681,13 +2675,6 @@ void fsg_common_remove_luns(struct fsg_common *common)
 }
 EXPORT_SYMBOL_GPL(fsg_common_remove_luns);
 
-void fsg_common_set_ops(struct fsg_common *common,
-			const struct fsg_operations *ops)
-{
-	common-&gt;ops = ops;
-}
-EXPORT_SYMBOL_GPL(fsg_common_set_ops);
-
 void fsg_common_free_buffers(struct fsg_common *common)
 {
 	_fsg_common_free_buffers(common-&gt;buffhds, common-&gt;fsg_num_buffers);
diff --git a/drivers/usb/gadget/function/f_mass_storage.h b/drivers/usb/gadget/function/f_mass_storage.h
index d3902313b8ac..dc05ca0c4359 100644
--- a/drivers/usb/gadget/function/f_mass_storage.h
+++ b/drivers/usb/gadget/function/f_mass_storage.h
@@ -60,17 +60,6 @@ struct fsg_module_parameters {
 struct fsg_common;
 
 /* FSF callback functions */
-struct fsg_operations {
-	/*
-	 * Callback function to call when thread exits.  If no
-	 * callback is set or it returns value lower then zero MSF
-	 * will force eject all LUNs it operates on (including those
-	 * marked as non-removable or with prevent_medium_removal flag
-	 * set).
-	 */
-	int (*thread_exits)(struct fsg_common *common);
-};
-
 struct fsg_lun_opts {
 	struct config_group group;
 	struct fsg_lun *lun;
@@ -142,9 +131,6 @@ void fsg_common_remove_lun(struct fsg_lun *lun);
 
 void fsg_common_remove_luns(struct fsg_common *common);
 
-void fsg_common_set_ops(struct fsg_common *common,
-			const struct fsg_operations *ops);
-
 int fsg_common_create_lun(struct fsg_common *common, struct fsg_lun_config *cfg,
 			  unsigned int id, const char *name,
 			  const char **name_pfx);
diff --git a/drivers/usb/gadget/legacy/mass_storage.c b/drivers/usb/gadget/legacy/mass_storage.c
index e99ab57ee3e5..fcba59782f26 100644
--- a/drivers/usb/gadget/legacy/mass_storage.c
+++ b/drivers/usb/gadget/legacy/mass_storage.c
@@ -107,15 +107,6 @@ static unsigned int fsg_num_buffers = CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS;
 
 FSG_MODULE_PARAMETERS(/* no prefix */, mod_data);
 
-static unsigned long msg_registered;
-static void msg_cleanup(void);
-
-static int msg_thread_exits(struct fsg_common *common)
-{
-	msg_cleanup();
-	return 0;
-}
-
 static int msg_do_config(struct usb_configuration *c)
 {
 	struct fsg_opts *opts;
@@ -154,9 +145,6 @@ static struct usb_configuration msg_config_driver = {
 
 static int msg_bind(struct usb_composite_dev *cdev)
 {
-	static const struct fsg_operations ops = {
-		.thread_exits = msg_thread_exits,
-	};
 	struct fsg_opts *opts;
 	struct fsg_config config;
 	int status;
@@ -173,8 +161,6 @@ static int msg_bind(struct usb_composite_dev *cdev)
 	if (status)
 		goto fail;
 
-	fsg_common_set_ops(opts-&gt;common, &amp;ops);
-
 	status = fsg_common_set_cdev(opts-&gt;common, cdev, config.can_stall);
 	if (status)
 		goto fail_set_cdev;
@@ -256,18 +242,12 @@ MODULE_LICENSE("GPL");
 
 static int __init msg_init(void)
 {
-	int ret;
-
-	ret = usb_composite_probe(&amp;msg_driver);
-	set_bit(0, &amp;msg_registered);
-
-	return ret;
+	return usb_composite_probe(&amp;msg_driver);
 }
 module_init(msg_init);
 
-static void msg_cleanup(void)
+static void __exit msg_cleanup(void)
 {
-	if (test_and_clear_bit(0, &amp;msg_registered))
-		usb_composite_unregister(&amp;msg_driver);
+	usb_composite_unregister(&amp;msg_driver);
 }
 module_exit(msg_cleanup);</pre><hr><pre>commit 520b72fc64debf8a86c3853b8e486aa5982188f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 21 13:23:58 2017 -0400

    USB: gadgetfs: Fix crash caused by inadequate synchronization
    
    The gadgetfs driver (drivers/usb/gadget/legacy/inode.c) was written
    before the UDC and composite frameworks were adopted; it is a legacy
    driver.  As such, it expects that once bound to a UDC controller, it
    will not be unbound until it unregisters itself.
    
    However, the UDC framework does unbind function drivers while they are
    still registered.  When this happens, it can cause the gadgetfs driver
    to misbehave or crash.  For example, userspace can cause a crash by
    opening the device file and doing an ioctl call before setting up a
    configuration (found by Andrey Konovalov using the syzkaller fuzzer).
    
    This patch adds checks and synchronization to prevent these bad
    behaviors.  It adds a udc_usage counter that the driver increments at
    times when it is using a gadget interface without holding the private
    spinlock.  The unbind routine waits for this counter to go to 0 before
    returning, thereby ensuring that the UDC is no longer in use.
    
    The patch also adds a check in the dev_ioctl() routine to make sure
    the driver is bound to a UDC before dereferencing the gadget pointer,
    and it makes destroy_ep_files() synchronize with the endpoint I/O
    routines, to prevent the user from accessing an endpoint data
    structure after it has been removed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 956b3dc7c3a4..5c28bee327e1 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -28,7 +28,7 @@
 #include &lt;linux/aio.h&gt;
 #include &lt;linux/uio.h&gt;
 #include &lt;linux/refcount.h&gt;
-
+#include &lt;linux/delay.h&gt;
 #include &lt;linux/device.h&gt;
 #include &lt;linux/moduleparam.h&gt;
 
@@ -116,6 +116,7 @@ enum ep0_state {
 struct dev_data {
 	spinlock_t			lock;
 	refcount_t			count;
+	int				udc_usage;
 	enum ep0_state			state;		/* P: lock */
 	struct usb_gadgetfs_event	event [N_EVENT];
 	unsigned			ev_next;
@@ -513,9 +514,9 @@ static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)
 		INIT_WORK(&amp;priv-&gt;work, ep_user_copy_worker);
 		schedule_work(&amp;priv-&gt;work);
 	}
-	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);
 
 	usb_ep_free_request(ep, req);
+	spin_unlock(&amp;epdata-&gt;dev-&gt;lock);
 	put_ep(epdata);
 }
 
@@ -939,9 +940,11 @@ ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)
 			struct usb_request	*req = dev-&gt;req;
 
 			if ((retval = setup_req (ep, req, 0)) == 0) {
+				++dev-&gt;udc_usage;
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				retval = usb_ep_queue (ep, req, GFP_KERNEL);
 				spin_lock_irq (&amp;dev-&gt;lock);
+				--dev-&gt;udc_usage;
 			}
 			dev-&gt;state = STATE_DEV_CONNECTED;
 
@@ -1134,6 +1137,7 @@ ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 			retval = setup_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req, len);
 			if (retval == 0) {
 				dev-&gt;state = STATE_DEV_CONNECTED;
+				++dev-&gt;udc_usage;
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				if (copy_from_user (dev-&gt;req-&gt;buf, buf, len))
 					retval = -EFAULT;
@@ -1145,6 +1149,7 @@ ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 						GFP_KERNEL);
 				}
 				spin_lock_irq(&amp;dev-&gt;lock);
+				--dev-&gt;udc_usage;
 				if (retval &lt; 0) {
 					clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
 				} else
@@ -1246,9 +1251,21 @@ static long dev_ioctl (struct file *fd, unsigned code, unsigned long value)
 	struct usb_gadget	*gadget = dev-&gt;gadget;
 	long ret = -ENOTTY;
 
-	if (gadget-&gt;ops-&gt;ioctl)
+	spin_lock_irq(&amp;dev-&gt;lock);
+	if (dev-&gt;state == STATE_DEV_OPENED ||
+			dev-&gt;state == STATE_DEV_UNBOUND) {
+		/* Not bound to a UDC */
+	} else if (gadget-&gt;ops-&gt;ioctl) {
+		++dev-&gt;udc_usage;
+		spin_unlock_irq(&amp;dev-&gt;lock);
+
 		ret = gadget-&gt;ops-&gt;ioctl (gadget, code, value);
 
+		spin_lock_irq(&amp;dev-&gt;lock);
+		--dev-&gt;udc_usage;
+	}
+	spin_unlock_irq(&amp;dev-&gt;lock);
+
 	return ret;
 }
 
@@ -1466,10 +1483,12 @@ gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 				if (value &lt; 0)
 					break;
 
+				++dev-&gt;udc_usage;
 				spin_unlock (&amp;dev-&gt;lock);
 				value = usb_ep_queue (gadget-&gt;ep0, dev-&gt;req,
 							GFP_KERNEL);
 				spin_lock (&amp;dev-&gt;lock);
+				--dev-&gt;udc_usage;
 				if (value &lt; 0) {
 					clean_req (gadget-&gt;ep0, dev-&gt;req);
 					break;
@@ -1493,8 +1512,12 @@ gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 		req-&gt;length = value;
 		req-&gt;zero = value &lt; w_length;
 
+		++dev-&gt;udc_usage;
 		spin_unlock (&amp;dev-&gt;lock);
 		value = usb_ep_queue (gadget-&gt;ep0, req, GFP_KERNEL);
+		spin_lock(&amp;dev-&gt;lock);
+		--dev-&gt;udc_usage;
+		spin_unlock(&amp;dev-&gt;lock);
 		if (value &lt; 0) {
 			DBG (dev, "ep_queue --&gt; %d\n", value);
 			req-&gt;status = 0;
@@ -1521,21 +1544,24 @@ static void destroy_ep_files (struct dev_data *dev)
 		/* break link to FS */
 		ep = list_first_entry (&amp;dev-&gt;epfiles, struct ep_data, epfiles);
 		list_del_init (&amp;ep-&gt;epfiles);
+		spin_unlock_irq (&amp;dev-&gt;lock);
+
 		dentry = ep-&gt;dentry;
 		ep-&gt;dentry = NULL;
 		parent = d_inode(dentry-&gt;d_parent);
 
 		/* break link to controller */
+		mutex_lock(&amp;ep-&gt;lock);
 		if (ep-&gt;state == STATE_EP_ENABLED)
 			(void) usb_ep_disable (ep-&gt;ep);
 		ep-&gt;state = STATE_EP_UNBOUND;
 		usb_ep_free_request (ep-&gt;ep, ep-&gt;req);
 		ep-&gt;ep = NULL;
+		mutex_unlock(&amp;ep-&gt;lock);
+
 		wake_up (&amp;ep-&gt;wait);
 		put_ep (ep);
 
-		spin_unlock_irq (&amp;dev-&gt;lock);
-
 		/* break link to dcache */
 		inode_lock(parent);
 		d_delete (dentry);
@@ -1606,6 +1632,11 @@ gadgetfs_unbind (struct usb_gadget *gadget)
 
 	spin_lock_irq (&amp;dev-&gt;lock);
 	dev-&gt;state = STATE_DEV_UNBOUND;
+	while (dev-&gt;udc_usage &gt; 0) {
+		spin_unlock_irq(&amp;dev-&gt;lock);
+		usleep_range(1000, 2000);
+		spin_lock_irq(&amp;dev-&gt;lock);
+	}
 	spin_unlock_irq (&amp;dev-&gt;lock);
 
 	destroy_ep_files (dev);</pre><hr><pre>commit 6e76c01e71551cb221c1f3deacb9dcd9a7346784
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 21 16:12:01 2017 -0400

    USB: gadgetfs: fix copy_to_user while holding spinlock
    
    The gadgetfs driver as a long-outstanding FIXME, regarding a call of
    copy_to_user() made while holding a spinlock.  This patch fixes the
    issue by dropping the spinlock and using the dev-&gt;udc_usage mechanism
    introduced by another recent patch to guard against status changes
    while the lock isn't held.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 684900fcfe24..956b3dc7c3a4 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -983,11 +983,14 @@ ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)
 				retval = -EIO;
 			else {
 				len = min (len, (size_t)dev-&gt;req-&gt;actual);
-// FIXME don't call this with the spinlock held ...
+				++dev-&gt;udc_usage;
+				spin_unlock_irq(&amp;dev-&gt;lock);
 				if (copy_to_user (buf, dev-&gt;req-&gt;buf, len))
 					retval = -EFAULT;
 				else
 					retval = len;
+				spin_lock_irq(&amp;dev-&gt;lock);
+				--dev-&gt;udc_usage;
 				clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
 				/* NOTE userspace can't yet choose to stall */
 			}</pre><hr><pre>commit 786de92b3cb26012d3d0f00ee37adf14527f35c4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 22 11:56:49 2017 -0400

    USB: uas: fix bug in handling of alternate settings
    
    The uas driver has a subtle bug in the way it handles alternate
    settings.  The uas_find_uas_alt_setting() routine returns an
    altsetting value (the bAlternateSetting number in the descriptor), but
    uas_use_uas_driver() then treats that value as an index to the
    intf-&gt;altsetting array, which it isn't.
    
    Normally this doesn't cause any problems because the various
    alternate settings have bAlternateSetting values 0, 1, 2, ..., so the
    value is equal to the index in the array.  But this is not guaranteed,
    and Andrey Konovalov used the syzkaller fuzzer with KASAN to get a
    slab-out-of-bounds error by violating this assumption.
    
    This patch fixes the bug by making uas_find_uas_alt_setting() return a
    pointer to the altsetting entry rather than either the value or the
    index.  Pointers are less subject to misinterpretation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: Oliver Neukum &lt;oneukum@suse.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h
index f58caa9e6a27..a155cd02bce2 100644
--- a/drivers/usb/storage/uas-detect.h
+++ b/drivers/usb/storage/uas-detect.h
@@ -9,7 +9,8 @@ static int uas_is_interface(struct usb_host_interface *intf)
 		intf-&gt;desc.bInterfaceProtocol == USB_PR_UAS);
 }
 
-static int uas_find_uas_alt_setting(struct usb_interface *intf)
+static struct usb_host_interface *uas_find_uas_alt_setting(
+		struct usb_interface *intf)
 {
 	int i;
 
@@ -17,10 +18,10 @@ static int uas_find_uas_alt_setting(struct usb_interface *intf)
 		struct usb_host_interface *alt = &amp;intf-&gt;altsetting[i];
 
 		if (uas_is_interface(alt))
-			return alt-&gt;desc.bAlternateSetting;
+			return alt;
 	}
 
-	return -ENODEV;
+	return NULL;
 }
 
 static int uas_find_endpoints(struct usb_host_interface *alt,
@@ -58,14 +59,14 @@ static int uas_use_uas_driver(struct usb_interface *intf,
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);
 	unsigned long flags = id-&gt;driver_info;
-	int r, alt;
-
+	struct usb_host_interface *alt;
+	int r;
 
 	alt = uas_find_uas_alt_setting(intf);
-	if (alt &lt; 0)
+	if (!alt)
 		return 0;
 
-	r = uas_find_endpoints(&amp;intf-&gt;altsetting[alt], eps);
+	r = uas_find_endpoints(alt, eps);
 	if (r &lt; 0)
 		return 0;
 
diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c
index cfb1e3bbd434..63cf981ed81c 100644
--- a/drivers/usb/storage/uas.c
+++ b/drivers/usb/storage/uas.c
@@ -873,14 +873,14 @@ MODULE_DEVICE_TABLE(usb, uas_usb_ids);
 static int uas_switch_interface(struct usb_device *udev,
 				struct usb_interface *intf)
 {
-	int alt;
+	struct usb_host_interface *alt;
 
 	alt = uas_find_uas_alt_setting(intf);
-	if (alt &lt; 0)
-		return alt;
+	if (!alt)
+		return -ENODEV;
 
-	return usb_set_interface(udev,
-			intf-&gt;altsetting[0].desc.bInterfaceNumber, alt);
+	return usb_set_interface(udev, alt-&gt;desc.bInterfaceNumber,
+			alt-&gt;desc.bAlternateSetting);
 }
 
 static int uas_configure_endpoints(struct uas_dev_info *devinfo)</pre><hr><pre>commit 113f6eb6d50cfa5e2a1cdcf1678b12661fa272ab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 21 15:59:30 2017 -0400

    usb-storage: unusual_devs entry to fix write-access regression for Seagate external drives
    
    Kris Lindgren reports that without the NO_WP_DETECT flag, his Seagate
    external disk drive fails all write accesses.  This regresssion dates
    back approximately to the start of the 4.x kernel releases.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Kris Lindgren &lt;kris.lindgren@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 5a70c33ef0e0..eb06d88b41d6 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1459,6 +1459,13 @@ UNUSUAL_DEV( 0x0bc2, 0x3010, 0x0000, 0x0000,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_SANE_SENSE ),
 
+/* Reported by Kris Lindgren &lt;kris.lindgren@gmail.com&gt; */
+UNUSUAL_DEV( 0x0bc2, 0x3332, 0x0000, 0x9999,
+		"Seagate",
+		"External",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_NO_WP_DETECT ),
+
 UNUSUAL_DEV(  0x0d49, 0x7310, 0x0000, 0x9999,
 		"Maxtor",
 		"USB to SATA",</pre><hr><pre>commit a4fd4a724d6c30ad671046d83be2e9be2f11d275
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 21 16:02:05 2017 -0400

    usb-storage: fix bogus hardware error messages for ATA pass-thru devices
    
    Ever since commit a621bac3044e ("scsi_lib: correctly retry failed zero
    length REQ_TYPE_FS commands"), people have been getting bogus error
    messages for USB disk drives using ATA pass-thru.  For example:
    
    [ 1344.880193] sd 6:0:0:0: [sdb] Attached SCSI disk
    [ 1345.069152] sd 6:0:0:0: [sdb] tag#0 FAILED Result: hostbyte=DID_ERROR driverbyte=DRIVER_SENSE
    [ 1345.069159] sd 6:0:0:0: [sdb] tag#0 Sense Key : Hardware Error [current] [descriptor]
    [ 1345.069162] sd 6:0:0:0: [sdb] tag#0 Add. Sense: No additional sense information
    [ 1345.069168] sd 6:0:0:0: [sdb] tag#0 CDB: ATA command pass through(16) 85 06 20 00 00 00 00 00 00 00 00 00 00 00 e5 00
    [ 1345.172252] sd 6:0:0:0: [sdb] tag#0 FAILED Result: hostbyte=DID_ERROR driverbyte=DRIVER_SENSE
    [ 1345.172258] sd 6:0:0:0: [sdb] tag#0 Sense Key : Hardware Error [current] [descriptor]
    [ 1345.172261] sd 6:0:0:0: [sdb] tag#0 Add. Sense: No additional sense information
    [ 1345.172266] sd 6:0:0:0: [sdb] tag#0 CDB: ATA command pass through(12)/Blank a1 06 20 da 00 00 4f c2 00 b0 00 00
    
    These messages can be quite annoying, because programs like udisks2
    provoke them every 10 minutes or so.  Other programs can also have
    this effect, such as those in smartmontools.
    
    I don't fully understand how that commit induced the SCSI core to log
    these error messages, but the underlying cause for them is code added
    to usb-storage by commit f1a0743bc0e7 ("USB: storage: When a device
    returns no sense data, call it a Hardware Error").  At the time it was
    necessary to do this, in order to prevent an infinite retry loop with
    some not-so-great mass storage devices.
    
    However, the ATA pass-thru protocol uses SCSI sense data to return
    command status values, and some devices always report Check Condition
    status for ATA pass-thru commands to ensure that the host retrieves
    the sense data, even if the command succeeded.  This violates the USB
    mass-storage protocol (Check Condition status is supposed to mean the
    command failed), but we can't help that.
    
    This patch attempts to mitigate the problem of these bogus error
    reports by changing usb-storage.  The HARDWARE ERROR sense key will be
    inserted only for commands that aren't ATA pass-thru.
    
    Thanks to Ewan Milne for pointing out that this mechanism was present
    in usb-storage.  8 years after writing it, I had completely forgotten
    its existence.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Kris Lindgren &lt;kris.lindgren@gmail.com&gt;
    Ref: https://bugzilla.redhat.com/show_bug.cgi?id=1351305
    CC: Ewan D. Milne &lt;emilne@redhat.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 1a59f335b063..a3ccb899df60 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -834,13 +834,25 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 			if (result == USB_STOR_TRANSPORT_GOOD) {
 				srb-&gt;result = SAM_STAT_GOOD;
 				srb-&gt;sense_buffer[0] = 0x0;
+			}
+
+			/*
+			 * ATA-passthru commands use sense data to report
+			 * the command completion status, and often devices
+			 * return Check Condition status when nothing is
+			 * wrong.
+			 */
+			else if (srb-&gt;cmnd[0] == ATA_16 ||
+					srb-&gt;cmnd[0] == ATA_12) {
+				/* leave the data alone */
+			}
 
 			/*
 			 * If there was a problem, report an unspecified
 			 * hardware error to prevent the higher layers from
 			 * entering an infinite retry loop.
 			 */
-			} else {
+			else {
 				srb-&gt;result = DID_ERROR &lt;&lt; 16;
 				if ((sshdr.response_code &amp; 0x72) == 0x72)
 					srb-&gt;sense_buffer[1] = HARDWARE_ERROR;</pre><hr><pre>commit afd7fd81f22bf90474216515dbd6088f9bd70343
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 17 14:49:55 2017 -0400

    USB: Gadget core: fix inconsistency in the interface tousb_add_gadget_udc_release()
    
    The usb_add_gadget_udc_release() routine in the USB gadget core will
    sometimes but not always call the gadget's release function when an
    error occurs.  More specifically, if the struct usb_udc allocation
    fails then the release function is not called, and for other errors it
    is.
    
    As a result, users of this routine cannot know whether they need to
    deallocate the memory containing the gadget structure following an
    error.  This leads to unavoidable memory leaks or double frees.
    
    This patch fixes the problem by splitting the existing
    device_register() call into device_initialize() and device_add(), and
    doing the udc allocation in between.  That way, even if the allocation
    fails it is still possible to call device_del(), and so the release
    function will be always called following an error.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Alexey Khoroshilov &lt;khoroshilov@ispras.ru&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index c1cef6a11ecb..75c51ca4ee0f 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1133,6 +1133,7 @@ static int check_pending_gadget_drivers(struct usb_udc *udc)
  * @release: a gadget release function.
  *
  * Returns zero on success, negative errno otherwise.
+ * Calls the gadget release function in the latter case.
  */
 int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
@@ -1140,10 +1141,6 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	struct usb_udc		*udc;
 	int			ret = -ENOMEM;
 
-	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
-	if (!udc)
-		goto err1;
-
 	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);
 	gadget-&gt;dev.parent = parent;
@@ -1153,7 +1150,13 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	else
 		gadget-&gt;dev.release = usb_udc_nop_release;
 
-	ret = device_register(&amp;gadget-&gt;dev);
+	device_initialize(&amp;gadget-&gt;dev);
+
+	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
+	if (!udc)
+		goto err1;
+
+	ret = device_add(&amp;gadget-&gt;dev);
 	if (ret)
 		goto err2;
 
@@ -1200,10 +1203,10 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	device_del(&amp;gadget-&gt;dev);
 
 err2:
-	put_device(&amp;gadget-&gt;dev);
 	kfree(udc);
 
 err1:
+	put_device(&amp;gadget-&gt;dev);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usb_add_gadget_udc_release);</pre><hr><pre>commit 94c43b9897abf4ea366ed4dba027494e080c7050
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 1 10:41:56 2017 -0400

    USB: Check for dropped connection before switching to full speed
    
    Some buggy USB disk adapters disconnect and reconnect multiple times
    during the enumeration procedure.  This may lead to a device
    connecting at full speed instead of high speed, because when the USB
    stack sees that a device isn't able to enumerate at high speed, it
    tries to hand the connection over to a full-speed companion
    controller.
    
    The logic for doing this is careful to check that the device is still
    connected.  But this check is inadequate if the device disconnects and
    reconnects before the check is done.  The symptom is that a device
    works, but much more slowly than it is capable of operating.
    
    The situation was made worse recently by commit 22547c4cc4fe ("usb:
    hub: Wait for connection to be reestablished after port reset"), which
    increases the delay following a reset before a disconnect is
    recognized, thus giving the device more time to reconnect.
    
    This patch makes the check more robust.  If the device was
    disconnected at any time during enumeration, we will now skip the
    full-speed handover.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Zdenek Kabelac &lt;zkabelac@redhat.com&gt;
    Reviewed-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6e6797d145dd..822f8c50e423 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -4725,7 +4725,8 @@ hub_power_remaining(struct usb_hub *hub)
 static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		u16 portchange)
 {
-	int status, i;
+	int status = -ENODEV;
+	int i;
 	unsigned unit_load;
 	struct usb_device *hdev = hub-&gt;hdev;
 	struct usb_hcd *hcd = bus_to_hcd(hdev-&gt;bus);
@@ -4929,9 +4930,10 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 
 done:
 	hub_port_disable(hub, port1, 1);
-	if (hcd-&gt;driver-&gt;relinquish_port &amp;&amp; !hub-&gt;hdev-&gt;parent)
-		hcd-&gt;driver-&gt;relinquish_port(hcd, port1);
-
+	if (hcd-&gt;driver-&gt;relinquish_port &amp;&amp; !hub-&gt;hdev-&gt;parent) {
+		if (status != -ENOTCONN &amp;&amp; status != -ENODEV)
+			hcd-&gt;driver-&gt;relinquish_port(hcd, port1);
+	}
 }
 
 /* Handle physical or logical connection change events.</pre><hr><pre>commit 8b52291a0743fc4db4a7495c846a6f31ee84d282
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 26 11:49:19 2017 -0400

    usb-storage: fix deadlock involving host lock and scsi_done
    
    Christoph Hellwig says that since version 4.12, the kernel switched to
    using blk-mq by default.  The old code used a softirq for handling
    request completions, but blk-mq can handle completions in the caller's
    context.  This may cause a problem for usb-storage, because it invokes
    the -&gt;scsi_done callback while holding the host lock, and the
    completion routine sometimes tries to acquire the same lock (when
    running the error handler, for example).
    
    The consequence is that the existing code will sometimes deadlock upon
    error completion of a SCSI command (with a lockdep warning).
    
    This is easy enough to fix, since usb-storage doesn't really need to
    hold the host lock while the callback runs.  It was simpler to write
    it that way, but moving the call outside the locked region is pretty
    easy and there's no downside.  That's what this patch does.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Arthur Marsh &lt;arthur.marsh@internode.on.net&gt;
    CC: Christoph Hellwig &lt;hch@lst.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 06615934fed1..0dceb9fa3a06 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -315,6 +315,7 @@ static int usb_stor_control_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
 	struct Scsi_Host *host = us_to_host(us);
+	struct scsi_cmnd *srb;
 
 	for (;;) {
 		usb_stor_dbg(us, "*** thread sleeping\n");
@@ -330,6 +331,7 @@ static int usb_stor_control_thread(void * __us)
 		scsi_lock(host);
 
 		/* When we are called with no command pending, we're done */
+		srb = us-&gt;srb;
 		if (us-&gt;srb == NULL) {
 			scsi_unlock(host);
 			mutex_unlock(&amp;us-&gt;dev_mutex);
@@ -398,14 +400,11 @@ static int usb_stor_control_thread(void * __us)
 		/* lock access to the state */
 		scsi_lock(host);
 
-		/* indicate that the command is done */
-		if (us-&gt;srb-&gt;result != DID_ABORT &lt;&lt; 16) {
-			usb_stor_dbg(us, "scsi cmd done, result=0x%x\n",
-				     us-&gt;srb-&gt;result);
-			us-&gt;srb-&gt;scsi_done(us-&gt;srb);
-		} else {
+		/* was the command aborted? */
+		if (us-&gt;srb-&gt;result == DID_ABORT &lt;&lt; 16) {
 SkipForAbort:
 			usb_stor_dbg(us, "scsi command aborted\n");
+			srb = NULL;	/* Don't call srb-&gt;scsi_done() */
 		}
 
 		/*
@@ -429,6 +428,13 @@ static int usb_stor_control_thread(void * __us)
 
 		/* unlock the device pointers */
 		mutex_unlock(&amp;us-&gt;dev_mutex);
+
+		/* now that the locks are released, notify the SCSI core */
+		if (srb) {
+			usb_stor_dbg(us, "scsi cmd done, result=0x%x\n",
+					srb-&gt;result);
+			srb-&gt;scsi_done(srb);
+		}
 	} /* for (;;) */
 
 	/* Wait until we are told to stop */</pre><hr><pre>commit f16443a034c7aa359ddf6f0f9bc40d01ca31faea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 13 15:23:42 2017 -0400

    USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks
    
    Using the syzkaller kernel fuzzer, Andrey Konovalov generated the
    following error in gadgetfs:
    
    &gt; BUG: KASAN: use-after-free in __lock_acquire+0x3069/0x3690
    &gt; kernel/locking/lockdep.c:3246
    &gt; Read of size 8 at addr ffff88003a2bdaf8 by task kworker/3:1/903
    &gt;
    &gt; CPU: 3 PID: 903 Comm: kworker/3:1 Not tainted 4.12.0-rc4+ #35
    &gt; Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    &gt; Workqueue: usb_hub_wq hub_event
    &gt; Call Trace:
    &gt;  __dump_stack lib/dump_stack.c:16 [inline]
    &gt;  dump_stack+0x292/0x395 lib/dump_stack.c:52
    &gt;  print_address_description+0x78/0x280 mm/kasan/report.c:252
    &gt;  kasan_report_error mm/kasan/report.c:351 [inline]
    &gt;  kasan_report+0x230/0x340 mm/kasan/report.c:408
    &gt;  __asan_report_load8_noabort+0x19/0x20 mm/kasan/report.c:429
    &gt;  __lock_acquire+0x3069/0x3690 kernel/locking/lockdep.c:3246
    &gt;  lock_acquire+0x22d/0x560 kernel/locking/lockdep.c:3855
    &gt;  __raw_spin_lock include/linux/spinlock_api_smp.h:142 [inline]
    &gt;  _raw_spin_lock+0x2f/0x40 kernel/locking/spinlock.c:151
    &gt;  spin_lock include/linux/spinlock.h:299 [inline]
    &gt;  gadgetfs_suspend+0x89/0x130 drivers/usb/gadget/legacy/inode.c:1682
    &gt;  set_link_state+0x88e/0xae0 drivers/usb/gadget/udc/dummy_hcd.c:455
    &gt;  dummy_hub_control+0xd7e/0x1fb0 drivers/usb/gadget/udc/dummy_hcd.c:2074
    &gt;  rh_call_control drivers/usb/core/hcd.c:689 [inline]
    &gt;  rh_urb_enqueue drivers/usb/core/hcd.c:846 [inline]
    &gt;  usb_hcd_submit_urb+0x92f/0x20b0 drivers/usb/core/hcd.c:1650
    &gt;  usb_submit_urb+0x8b2/0x12c0 drivers/usb/core/urb.c:542
    &gt;  usb_start_wait_urb+0x148/0x5b0 drivers/usb/core/message.c:56
    &gt;  usb_internal_control_msg drivers/usb/core/message.c:100 [inline]
    &gt;  usb_control_msg+0x341/0x4d0 drivers/usb/core/message.c:151
    &gt;  usb_clear_port_feature+0x74/0xa0 drivers/usb/core/hub.c:412
    &gt;  hub_port_disable+0x123/0x510 drivers/usb/core/hub.c:4177
    &gt;  hub_port_init+0x1ed/0x2940 drivers/usb/core/hub.c:4648
    &gt;  hub_port_connect drivers/usb/core/hub.c:4826 [inline]
    &gt;  hub_port_connect_change drivers/usb/core/hub.c:4999 [inline]
    &gt;  port_event drivers/usb/core/hub.c:5105 [inline]
    &gt;  hub_event+0x1ae1/0x3d40 drivers/usb/core/hub.c:5185
    &gt;  process_one_work+0xc08/0x1bd0 kernel/workqueue.c:2097
    &gt;  process_scheduled_works kernel/workqueue.c:2157 [inline]
    &gt;  worker_thread+0xb2b/0x1860 kernel/workqueue.c:2233
    &gt;  kthread+0x363/0x440 kernel/kthread.c:231
    &gt;  ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:424
    &gt;
    &gt; Allocated by task 9958:
    &gt;  save_stack_trace+0x1b/0x20 arch/x86/kernel/stacktrace.c:59
    &gt;  save_stack+0x43/0xd0 mm/kasan/kasan.c:513
    &gt;  set_track mm/kasan/kasan.c:525 [inline]
    &gt;  kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:617
    &gt;  kmem_cache_alloc_trace+0x87/0x280 mm/slub.c:2745
    &gt;  kmalloc include/linux/slab.h:492 [inline]
    &gt;  kzalloc include/linux/slab.h:665 [inline]
    &gt;  dev_new drivers/usb/gadget/legacy/inode.c:170 [inline]
    &gt;  gadgetfs_fill_super+0x24f/0x540 drivers/usb/gadget/legacy/inode.c:1993
    &gt;  mount_single+0xf6/0x160 fs/super.c:1192
    &gt;  gadgetfs_mount+0x31/0x40 drivers/usb/gadget/legacy/inode.c:2019
    &gt;  mount_fs+0x9c/0x2d0 fs/super.c:1223
    &gt;  vfs_kern_mount.part.25+0xcb/0x490 fs/namespace.c:976
    &gt;  vfs_kern_mount fs/namespace.c:2509 [inline]
    &gt;  do_new_mount fs/namespace.c:2512 [inline]
    &gt;  do_mount+0x41b/0x2d90 fs/namespace.c:2834
    &gt;  SYSC_mount fs/namespace.c:3050 [inline]
    &gt;  SyS_mount+0xb0/0x120 fs/namespace.c:3027
    &gt;  entry_SYSCALL_64_fastpath+0x1f/0xbe
    &gt;
    &gt; Freed by task 9960:
    &gt;  save_stack_trace+0x1b/0x20 arch/x86/kernel/stacktrace.c:59
    &gt;  save_stack+0x43/0xd0 mm/kasan/kasan.c:513
    &gt;  set_track mm/kasan/kasan.c:525 [inline]
    &gt;  kasan_slab_free+0x72/0xc0 mm/kasan/kasan.c:590
    &gt;  slab_free_hook mm/slub.c:1357 [inline]
    &gt;  slab_free_freelist_hook mm/slub.c:1379 [inline]
    &gt;  slab_free mm/slub.c:2961 [inline]
    &gt;  kfree+0xed/0x2b0 mm/slub.c:3882
    &gt;  put_dev+0x124/0x160 drivers/usb/gadget/legacy/inode.c:163
    &gt;  gadgetfs_kill_sb+0x33/0x60 drivers/usb/gadget/legacy/inode.c:2027
    &gt;  deactivate_locked_super+0x8d/0xd0 fs/super.c:309
    &gt;  deactivate_super+0x21e/0x310 fs/super.c:340
    &gt;  cleanup_mnt+0xb7/0x150 fs/namespace.c:1112
    &gt;  __cleanup_mnt+0x1b/0x20 fs/namespace.c:1119
    &gt;  task_work_run+0x1a0/0x280 kernel/task_work.c:116
    &gt;  exit_task_work include/linux/task_work.h:21 [inline]
    &gt;  do_exit+0x18a8/0x2820 kernel/exit.c:878
    &gt;  do_group_exit+0x14e/0x420 kernel/exit.c:982
    &gt;  get_signal+0x784/0x1780 kernel/signal.c:2318
    &gt;  do_signal+0xd7/0x2130 arch/x86/kernel/signal.c:808
    &gt;  exit_to_usermode_loop+0x1ac/0x240 arch/x86/entry/common.c:157
    &gt;  prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]
    &gt;  syscall_return_slowpath+0x3ba/0x410 arch/x86/entry/common.c:263
    &gt;  entry_SYSCALL_64_fastpath+0xbc/0xbe
    &gt;
    &gt; The buggy address belongs to the object at ffff88003a2bdae0
    &gt;  which belongs to the cache kmalloc-1024 of size 1024
    &gt; The buggy address is located 24 bytes inside of
    &gt;  1024-byte region [ffff88003a2bdae0, ffff88003a2bdee0)
    &gt; The buggy address belongs to the page:
    &gt; page:ffffea0000e8ae00 count:1 mapcount:0 mapping:          (null)
    &gt; index:0x0 compound_mapcount: 0
    &gt; flags: 0x100000000008100(slab|head)
    &gt; raw: 0100000000008100 0000000000000000 0000000000000000 0000000100170017
    &gt; raw: ffffea0000ed3020 ffffea0000f5f820 ffff88003e80efc0 0000000000000000
    &gt; page dumped because: kasan: bad access detected
    &gt;
    &gt; Memory state around the buggy address:
    &gt;  ffff88003a2bd980: fb fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    &gt;  ffff88003a2bda00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    &gt; &gt;ffff88003a2bda80: fc fc fc fc fc fc fc fc fc fc fc fc fb fb fb fb
    &gt;                                                                 ^
    &gt;  ffff88003a2bdb00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    &gt;  ffff88003a2bdb80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    &gt; ==================================================================
    
    What this means is that the gadgetfs_suspend() routine was trying to
    access dev-&gt;lock after it had been deallocated.  The root cause is a
    race in the dummy_hcd driver; the dummy_udc_stop() routine can race
    with the rest of the driver because it contains no locking.  And even
    when proper locking is added, it can still race with the
    set_link_state() function because that function incorrectly drops the
    private spinlock before invoking any gadget driver callbacks.
    
    The result of this race, as seen above, is that set_link_state() can
    invoke a callback in gadgetfs even after gadgetfs has been unbound
    from dummy_hcd's UDC and its private data structures have been
    deallocated.
    
    include/linux/usb/gadget.h documents that the -&gt;reset, -&gt;disconnect,
    -&gt;suspend, and -&gt;resume callbacks may be invoked in interrupt context.
    In general this is necessary, to prevent races with gadget driver
    removal.  This patch fixes dummy_hcd to retain the spinlock across
    these calls, and it adds a spinlock acquisition to dummy_udc_stop() to
    prevent the race.
    
    The net2280 driver makes the same mistake of dropping the private
    spinlock for its -&gt;disconnect and -&gt;reset callback invocations.  The
    patch fixes it too.
    
    Lastly, since gadgetfs_suspend() may be invoked in interrupt context,
    it cannot assume that interrupts are enabled when it runs.  It must
    use spin_lock_irqsave() instead of spin_lock_irq().  The patch fixes
    that bug as well.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 5ffd879f7886..684900fcfe24 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1679,9 +1679,10 @@ static void
 gadgetfs_suspend (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
+	unsigned long		flags;
 
 	INFO (dev, "suspended from state %d\n", dev-&gt;state);
-	spin_lock (&amp;dev-&gt;lock);
+	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 	switch (dev-&gt;state) {
 	case STATE_DEV_SETUP:		// VERY odd... host died??
 	case STATE_DEV_CONNECTED:
@@ -1692,7 +1693,7 @@ gadgetfs_suspend (struct usb_gadget *gadget)
 	default:
 		break;
 	}
-	spin_unlock (&amp;dev-&gt;lock);
+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 }
 
 static struct usb_gadget_driver gadgetfs_driver = {
diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index ccabb51cb98d..7635fd7cc328 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -442,23 +442,16 @@ static void set_link_state(struct dummy_hcd *dum_hcd)
 		/* Report reset and disconnect events to the driver */
 		if (dum-&gt;driver &amp;&amp; (disconnect || reset)) {
 			stop_activity(dum);
-			spin_unlock(&amp;dum-&gt;lock);
 			if (reset)
 				usb_gadget_udc_reset(&amp;dum-&gt;gadget, dum-&gt;driver);
 			else
 				dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
-			spin_lock(&amp;dum-&gt;lock);
 		}
 	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {
-		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {
-			spin_unlock(&amp;dum-&gt;lock);
+		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
-			spin_lock(&amp;dum-&gt;lock);
-		} else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume) {
-			spin_unlock(&amp;dum-&gt;lock);
+		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
-			spin_lock(&amp;dum-&gt;lock);
-		}
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
@@ -983,7 +976,9 @@ static int dummy_udc_stop(struct usb_gadget *g)
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
+	spin_lock_irq(&amp;dum-&gt;lock);
 	dum-&gt;driver = NULL;
+	spin_unlock_irq(&amp;dum-&gt;lock);
 
 	return 0;
 }
diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index 6cf07857eaca..f2cbd7f8005e 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -2470,11 +2470,8 @@ static void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)
 		nuke(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
-	if (driver) {
-		spin_unlock(&amp;dev-&gt;lock);
+	if (driver)
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
-		spin_lock(&amp;dev-&gt;lock);
-	}
 
 	usb_reinit(dev);
 }
@@ -3348,8 +3345,6 @@ static void handle_stat0_irqs(struct net2280 *dev, u32 stat)
 		BIT(PCI_RETRY_ABORT_INTERRUPT))
 
 static void handle_stat1_irqs(struct net2280 *dev, u32 stat)
-__releases(dev-&gt;lock)
-__acquires(dev-&gt;lock)
 {
 	struct net2280_ep	*ep;
 	u32			tmp, num, mask, scratch;
@@ -3390,14 +3385,12 @@ __acquires(dev-&gt;lock)
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				ep0_start(dev);
-				spin_unlock(&amp;dev-&gt;lock);
 				if (reset)
 					usb_gadget_udc_reset
 						(&amp;dev-&gt;gadget, dev-&gt;driver);
 				else
 					(dev-&gt;driver-&gt;disconnect)
 						(&amp;dev-&gt;gadget);
-				spin_lock(&amp;dev-&gt;lock);
 				return;
 			}
 		}</pre>
    <div class="pagination">
        <a href='2_19.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><span>[20]</span><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_21.html'>Next&gt;&gt;</a>
    <div>
</body>
