<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of New South Wales</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of New South Wales</h1>
    <div class="pagination">
        <a href='8_5.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><a href='8_5.html'>5</a><span>[6]</span><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_7.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e66770cd7b0c36f28a2f6eb0957c0575ac8b3787
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:21 2005 -0700

    [PATCH] nfsd4: relax new lock seqid check
    
    We're insisting that the lock sequence id field passed in the
    open_to_lockowner struct always be zero.  This is probably thanks to the
    sentence in rfc3530: "The first request issued for any given lock_owner is
    issued with a sequence number of zero."
    
    But there doesn't seem to be any problem with allowing initial sequence
    numbers other than zero.  And currently this is causing lock reclaims from the
    Linux client to fail.
    
    In the spirit of "be liberal in what you accept, conservative in what you
    send", we'll relax the check (and patch the Linux client as well).
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index f60bcad77f71..386daac508f5 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2715,11 +2715,6 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 			goto out;
 		}
 
-		/* is the new lock seqid presented by the client zero? */
-		status = nfserr_bad_seqid;
-		if (lock-&gt;v.new.lock_seqid != 0)
-			goto out;
-
 		/* validate and update open stateid and open seqid */
 		status = nfs4_preprocess_seqid_op(current_fh, 
 				        lock-&gt;lk_new_open_seqid,</pre><hr><pre>commit 7fb64cee34f5dc743f697041717cafda8a94b5ac
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:20 2005 -0700

    [PATCH] nfsd4: seqid comments
    
    Add some comments on the use of so_seqid, in an attempt to avoid some of the
    confusion outlined in the previous patch....
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 5207068cde1a..1515c5b8096f 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1210,10 +1210,10 @@ nfsd4_decode_compound(struct nfsd4_compoundargs *argp)
 	save = resp-&gt;p;
 
 /*
- * Routine for encoding the result of a
- * "seqid-mutating" NFSv4 operation.  This is
- * where seqids are incremented, and the
- * replay cache is filled.
+ * Routine for encoding the result of a "seqid-mutating" NFSv4 operation.  This
+ * is where sequence id's are incremented, and the replay cache is filled.
+ * Note that we increment sequence id's here, at the last moment, so we're sure
+ * we know whether the error to be returned is a sequence id mutating error.
  */
 
 #define ENCODE_SEQID_OP_TAIL(stateowner) do {			\
diff --git a/include/linux/nfsd/state.h b/include/linux/nfsd/state.h
index a84a3fa99be1..2d19431f47ea 100644
--- a/include/linux/nfsd/state.h
+++ b/include/linux/nfsd/state.h
@@ -203,7 +203,9 @@ struct nfs4_stateowner {
 	int			so_is_open_owner; /* 1=openowner,0=lockowner */
 	u32                     so_id;
 	struct nfs4_client *    so_client;
-	u32                     so_seqid;    
+	/* after increment in ENCODE_SEQID_OP_TAIL, represents the next
+	 * sequence id expected from the client: */
+	u32                     so_seqid;
 	struct xdr_netobj       so_owner;     /* open owner name */
 	int                     so_confirmed; /* successful OPEN_CONFIRM? */
 	struct nfs4_replay	so_replay;</pre><hr><pre>commit bd9aac523b812d58e644fde5e59f5697fb9e3822
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:19 2005 -0700

    [PATCH] nfsd4: fix open_reclaim seqid
    
    The sequence number we store in the sequence id is the last one we received
    from the client.  So on the next operation we'll check that the client gives
    us the next higher number.
    
    We increment sequence id's at the last moment, in encode, so that we're sure
    of knowing the right error return.  (The decision to increment the sequence id
    depends on the exact error returned.)
    
    However on the *first* use of a sequence number, if we set the sequence number
    to the one received from the client and then let the increment happen on
    encode, we'll be left with a sequence number one to high.
    
    For that reason, ENCODE_SEQID_OP_TAIL only increments the sequence id on
    *confirmed* stateowners.
    
    This creates a problem for open reclaims, which are confirmed on first use.
    Therefore the open reclaim code, as a special exception, *decrements* the
    sequence id, cancelling out the undesired increment on encode.  But this
    prevents the sequence id from ever being incremented in the case where
    multiple reclaims are sent with the same openowner.  Yuch!
    
    We could add another exception to the open reclaim code, decrementing the
    sequence id only if this is the first use of the open owner.
    
    But it's simpler by far to modify the meaning of the op_seqid field: instead
    of representing the previous value sent by the client, we take op_seqid, after
    encoding, to represent the *next* sequence id that we expect from the client.
    This eliminates the need for special-case handling of the first use of a
    stateowner.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 74cd9bf3e0a1..f60bcad77f71 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1483,7 +1483,7 @@ nfsd4_process_open1(struct nfsd4_open *open)
 	if (sop) {
 		open-&gt;op_stateowner = sop;
 		/* check for replay */
-		if (open-&gt;op_seqid == sop-&gt;so_seqid){
+		if (open-&gt;op_seqid == sop-&gt;so_seqid - 1){
 			if (sop-&gt;so_replay.rp_buflen)
 				return NFSERR_REPLAY_ME;
 			else {
@@ -1498,7 +1498,7 @@ nfsd4_process_open1(struct nfsd4_open *open)
 				goto renew;
 			}
 		} else if (sop-&gt;so_confirmed) {
-			if (open-&gt;op_seqid == sop-&gt;so_seqid + 1)
+			if (open-&gt;op_seqid == sop-&gt;so_seqid)
 				goto renew;
 			status = nfserr_bad_seqid;
 			goto out;
@@ -1684,13 +1684,11 @@ nfs4_upgrade_open(struct svc_rqst *rqstp, struct svc_fh *cur_fh, struct nfs4_sta
 }
 
 
-/* decrement seqid on successful reclaim, it will be bumped in encode_open */
 static void
 nfs4_set_claim_prev(struct nfsd4_open *open)
 {
 	open-&gt;op_stateowner-&gt;so_confirmed = 1;
 	open-&gt;op_stateowner-&gt;so_client-&gt;cl_firststate = 1;
-	open-&gt;op_stateowner-&gt;so_seqid--;
 }
 
 /*
@@ -2234,7 +2232,7 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 	*  For the moment, we ignore the possibility of 
 	*  generation number wraparound.
 	*/
-	if (seqid != sop-&gt;so_seqid + 1)
+	if (seqid != sop-&gt;so_seqid)
 		goto check_replay;
 
 	if (sop-&gt;so_confirmed) {
@@ -2280,12 +2278,12 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 	*sopp = sop;
 
 check_replay:
-	if (seqid == sop-&gt;so_seqid) {
+	if (seqid == sop-&gt;so_seqid - 1) {
 		printk("NFSD: preprocess_seqid_op: retransmission?\n");
 		/* indicate replay to calling function */
 		status = NFSERR_REPLAY_ME;
 	} else  {
-		printk("NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d\n", sop-&gt;so_seqid +1, seqid);
+		printk("NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d\n", sop-&gt;so_seqid, seqid);
 
 		*sopp = NULL;
 		status = nfserr_bad_seqid;
@@ -2608,7 +2606,6 @@ find_lockstateowner_str(struct inode *inode, clientid_t *clid,
  * occured. 
  *
  * strhashval = lock_ownerstr_hashval 
- * so_seqid = lock-&gt;lk_new_lock_seqid - 1: it gets bumped in encode 
  */
 
 static struct nfs4_stateowner *
@@ -2633,7 +2630,7 @@ alloc_init_lock_stateowner(unsigned int strhashval, struct nfs4_client *clp, str
 	sop-&gt;so_is_open_owner = 0;
 	sop-&gt;so_id = current_ownerid++;
 	sop-&gt;so_client = clp;
-	sop-&gt;so_seqid = lock-&gt;lk_new_lock_seqid - 1;
+	sop-&gt;so_seqid = lock-&gt;lk_new_lock_seqid;
 	sop-&gt;so_confirmed = 1;
 	rp = &amp;sop-&gt;so_replay;
 	rp-&gt;rp_status = NFSERR_SERVERFAULT;
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 91fb171d2ace..5207068cde1a 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1218,8 +1218,7 @@ nfsd4_decode_compound(struct nfsd4_compoundargs *argp)
 
 #define ENCODE_SEQID_OP_TAIL(stateowner) do {			\
 	if (seqid_mutating_err(nfserr) &amp;&amp; stateowner) { 	\
-		if (stateowner-&gt;so_confirmed)			\
-			stateowner-&gt;so_seqid++;			\
+		stateowner-&gt;so_seqid++;				\
 		stateowner-&gt;so_replay.rp_status = nfserr;   	\
 		stateowner-&gt;so_replay.rp_buflen = 		\
 			  (((char *)(resp)-&gt;p - (char *)save)); \</pre><hr><pre>commit 893f87701c9e5bd5610dfbb3f8bf1135f86d85cb
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:17 2005 -0700

    [PATCH] nfsd4: comment indentation
    
    Yeah, it's trivial, but this drives me up the wall....
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 142b63bc2051..74cd9bf3e0a1 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2704,11 +2704,11 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 	nfs4_lock_state();
 
 	if (lock-&gt;lk_is_new) {
-	/*
-	 * Client indicates that this is a new lockowner.
-	 * Use open owner and open stateid to create lock owner and lock 
-	 * stateid.
-	 */
+		/*
+		 * Client indicates that this is a new lockowner.
+		 * Use open owner and open stateid to create lock owner and
+		 * lock stateid.
+		 */
 		struct nfs4_stateid *open_stp = NULL;
 		struct nfs4_file *fp;
 		
@@ -2842,10 +2842,10 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 out_destroy_new_stateid:
 	if (lock-&gt;lk_is_new) {
 		dprintk("NFSD: nfsd4_lock: destroy new stateid!\n");
-	/*
-	* An error encountered after instantiation of the new
-	* stateid has forced us to destroy it.
-	*/
+		/*
+		 * An error encountered after instantiation of the new
+		 * stateid has forced us to destroy it.
+		 */
 		if (!seqid_mutating_err(status))
 			open_sop-&gt;so_seqid--;
 </pre><hr><pre>commit 375151773125f56b7f6d798d914ea469256b330b
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:16 2005 -0700

    [PATCH] nfsd4: stop overusing RECLAIM_BAD
    
    A misreading of the spec lead us to convert all errors on open and lock
    reclaims to RECLAIM_BAD.  This causes problems--for example, a reboot within
    the grace period could lead to reclaims with stale stateid's, and we'd like to
    return STALE errors in those cases.
    
    What rfc3530 actually says about RECLAIM_BAD: "The reclaim provided by the
    client does not match any of the server's state consistency checks and is
    bad." I'm assuming that "state consistency checks" refers to checks for
    consistency with the state recorded to stable storage, and that the error
    should be reserved for that case.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 92968c94c6e6..142b63bc2051 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1531,8 +1531,6 @@ nfsd4_process_open1(struct nfsd4_open *open)
 	status = nfs_ok;
 	renew_client(sop-&gt;so_client);
 out:
-	if (status &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
-		status = nfserr_reclaim_bad;
 	return status;
 }
 
@@ -1688,17 +1686,11 @@ nfs4_upgrade_open(struct svc_rqst *rqstp, struct svc_fh *cur_fh, struct nfs4_sta
 
 /* decrement seqid on successful reclaim, it will be bumped in encode_open */
 static void
-nfs4_set_claim_prev(struct nfsd4_open *open, int *status)
+nfs4_set_claim_prev(struct nfsd4_open *open)
 {
-	if (open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS) {
-		if (*status)
-			*status = nfserr_reclaim_bad;
-		else {
-			open-&gt;op_stateowner-&gt;so_confirmed = 1;
-			open-&gt;op_stateowner-&gt;so_client-&gt;cl_firststate = 1;
-			open-&gt;op_stateowner-&gt;so_seqid--;
-		}
-	}
+	open-&gt;op_stateowner-&gt;so_confirmed = 1;
+	open-&gt;op_stateowner-&gt;so_client-&gt;cl_firststate = 1;
+	open-&gt;op_stateowner-&gt;so_seqid--;
 }
 
 /*
@@ -1863,8 +1855,8 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 out:
 	if (fp)
 		put_nfs4_file(fp);
-	/* CLAIM_PREVIOUS has different error returns */
-	nfs4_set_claim_prev(open, &amp;status);
+	if (status == 0 &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
+		nfs4_set_claim_prev(open);
 	/*
 	* To finish the open response, we just need to set the rflags.
 	*/
@@ -2738,11 +2730,8 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 		                        CHECK_FH | OPEN_STATE,
 		                        &amp;open_sop, &amp;open_stp,
 					&amp;lock-&gt;v.new.clientid);
-		if (status) {
-			if (lock-&gt;lk_reclaim)
-				status = nfserr_reclaim_bad;
+		if (status)
 			goto out;
-		}
 		/* create lockowner and lock stateid */
 		fp = open_stp-&gt;st_file;
 		strhashval = lock_ownerstr_hashval(fp-&gt;fi_inode, </pre><hr><pre>commit 0dd395dc76071a06eea39839cc946c1241af3650
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:15 2005 -0700

    [PATCH] nfsd4: ERR_GRACE should bump seqid on lock
    
    A GRACE or NOGRACE response to a lock request should also bump the sequence
    id.  So we delay the handling of grace period errors till after we've found
    the relevant owner.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 568d5deacac0..92968c94c6e6 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2706,11 +2706,6 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 		(long long) lock-&gt;lk_offset,
 		(long long) lock-&gt;lk_length);
 
-	if (nfs4_in_grace() &amp;&amp; !lock-&gt;lk_reclaim)
-		return nfserr_grace;
-	if (!nfs4_in_grace() &amp;&amp; lock-&gt;lk_reclaim)
-		return nfserr_no_grace;
-
 	if (check_lock_length(lock-&gt;lk_offset, lock-&gt;lk_length))
 		 return nfserr_inval;
 
@@ -2785,6 +2780,13 @@ nfsd4_lock(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_lock
 		goto out;
 	}
 
+	status = nfserr_grace;
+	if (nfs4_in_grace() &amp;&amp; !lock-&gt;lk_reclaim)
+		goto out;
+	status = nfserr_no_grace;
+	if (!nfs4_in_grace() &amp;&amp; lock-&gt;lk_reclaim)
+		goto out;
+
 	locks_init_lock(&amp;file_lock);
 	switch (lock-&gt;lk_type) {
 		case NFS4_READ_LT:</pre><hr><pre>commit b648330a1d741d5df8a5076b2a0a2519c69c8f41
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:15 2005 -0700

    [PATCH] nfsd4: ERR_GRACE should bump seqid on open
    
    The GRACE and NOGRACE errors should bump the sequence id on open.  So we delay
    the handling of these errors until nfsd4_process_open2, at which point we've
    set the open owner, so the encode routine will be able to bump the sequence
    id.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index d71f14517b9c..e08edc17c6a0 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -169,12 +169,6 @@ nfsd4_open(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open
 		(int)open-&gt;op_fname.len, open-&gt;op_fname.data,
 		open-&gt;op_stateowner);
 
-	if (nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)
-		return nfserr_grace;
-
-	if (!nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
-		return nfserr_no_grace;
-
 	/* This check required by spec. */
 	if (open-&gt;op_create &amp;&amp; open-&gt;op_claim_type != NFS4_OPEN_CLAIM_NULL)
 		return nfserr_inval;
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index e388c9070de4..568d5deacac0 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1790,6 +1790,12 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	struct nfs4_delegation *dp = NULL;
 	int status;
 
+	if (nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)
+		return nfserr_grace;
+
+	if (!nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
+		return nfserr_no_grace;
+
 	status = nfserr_inval;
 	if (!TEST_ACCESS(open-&gt;op_share_access) || !TEST_DENY(open-&gt;op_share_deny))
 		goto out;</pre><hr><pre>commit 0fa822e452084032b8495ca0d8e0199329847815
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:14 2005 -0700

    [PATCH] nfsd4: fix release_lockowner
    
    We oops in list_for_each_entry(), because release_stateowner frees something
    on the list we're traversing.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 9f9db40b5666..e388c9070de4 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -3084,7 +3084,12 @@ nfsd4_release_lockowner(struct svc_rqst *rqstp, struct nfsd4_release_lockowner *
 	 * of the lockowner state released; so don't release any until all
 	 * have been checked. */
 	status = nfs_ok;
-	list_for_each_entry(sop, &amp;matches, so_perclient) {
+	while (!list_empty(&amp;matches)) {
+		sop = list_entry(matches.next, struct nfs4_stateowner,
+								so_perclient);
+		/* unhash_stateowner deletes so_perclient only
+		 * for openowners. */
+		list_del(&amp;sop-&gt;so_perclient);
 		release_stateowner(sop);
 	}
 out:</pre><hr><pre>commit 67be431350941765e211eeed237c12def3aaba70
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:13 2005 -0700

    [PATCH] nfsd4: prevent multiple unlinks of recovery directories
    
    Make sure we don't try to delete client recovery directories multiple times;
    fixes some spurious error messages.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index 53abb333732e..57ed50fe7f85 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -316,6 +316,7 @@ nfsd4_remove_clid_dir(struct nfs4_client *clp)
 	if (!rec_dir_init || !clp-&gt;cl_firststate)
 		return;
 
+	clp-&gt;cl_firststate = 0;
 	nfs4_save_user(&amp;uid, &amp;gid);
 	status = nfsd4_unlink_clid_dir(clp-&gt;cl_recdir, HEXDIR_LEN-1);
 	nfs4_reset_user(uid, gid);</pre><hr><pre>commit cdc5524e8a257b1c91dd8e4cdfbab979f4e17a60
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Jul 7 17:59:12 2005 -0700

    [PATCH] nfsd4: lookup_one_len takes i_sem
    
    Oops, this lookup_one_len needs the i_sem.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index bb40083b6b7d..53abb333732e 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -289,7 +289,9 @@ nfsd4_unlink_clid_dir(char *name, int namlen)
 
 	dprintk("NFSD: nfsd4_unlink_clid_dir. name %.*s\n", namlen, name);
 
+	down(&amp;rec_dir.dentry-&gt;d_inode-&gt;i_sem);
 	dentry = lookup_one_len(name, rec_dir.dentry, namlen);
+	up(&amp;rec_dir.dentry-&gt;d_inode-&gt;i_sem);
 	if (IS_ERR(dentry)) {
 		status = PTR_ERR(dentry);
 		return status;</pre>
    <div class="pagination">
        <a href='8_5.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><a href='8_5.html'>5</a><span>[6]</span><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_7.html'>Next&gt;&gt;</a>
    <div>
</body>
