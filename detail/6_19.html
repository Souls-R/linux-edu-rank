<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_18.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><span>[19]</span><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_20.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0fcddf9c7c10202946d5b19409efbdff744fba88
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sat Apr 9 15:21:35 2022 +0800

    drivers: staging: rtl8192eu: Fix deadlock in rtw_joinbss_event_prehandle
    
    There is a deadlock in rtw_joinbss_event_prehandle(), which is shown below:
    
       (Thread 1)                |      (Thread 2)
                                 | _set_timer()
    rtw_joinbss_event_prehandle()|  mod_timer()
     spin_lock_bh() //(1)        |  (wait a time)
     ...                         | rtw_join_timeout_handler()
                                 |  _rtw_join_timeout_handler()
     del_timer_sync()            |   spin_lock_bh() //(2)
     (wait timer to stop)        |   ...
    
    We hold pmlmepriv-&gt;lock in position (1) of thread 1 and
    use del_timer_sync() to wait timer to stop, but timer handler
    also need pmlmepriv-&gt;lock in position (2) of thread 2.
    As a result, rtw_joinbss_event_prehandle() will block forever.
    
    This patch extracts del_timer_sync() from the protection of
    spin_lock_bh(), which could let timer handler to obtain
    the needed lock. What`s more, we change spin_lock_bh() to
    spin_lock_irq() in _rtw_join_timeout_handler() in order to
    prevent deadlock.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20220409072135.74248-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/r8188eu/core/rtw_mlme.c b/drivers/staging/r8188eu/core/rtw_mlme.c
index aa39f07847c2..3e9882f89f76 100644
--- a/drivers/staging/r8188eu/core/rtw_mlme.c
+++ b/drivers/staging/r8188eu/core/rtw_mlme.c
@@ -1070,8 +1070,10 @@ void rtw_joinbss_event_prehandle(struct adapter *adapter, u8 *pbuf)
 				rtw_indicate_connect(adapter);
 			}
 
+			spin_unlock_bh(&amp;pmlmepriv-&gt;lock);
 			/* s5. Cancel assoc_timer */
 			del_timer_sync(&amp;pmlmepriv-&gt;assoc_timer);
+			spin_lock_bh(&amp;pmlmepriv-&gt;lock);
 		} else {
 			spin_unlock_bh(&amp;pmlmepriv-&gt;scanned_queue.lock);
 			goto ignore_joinbss_callback;
@@ -1315,7 +1317,7 @@ void _rtw_join_timeout_handler (struct adapter *adapter)
 	if (adapter-&gt;bDriverStopped || adapter-&gt;bSurpriseRemoved)
 		return;
 
-	spin_lock_bh(&amp;pmlmepriv-&gt;lock);
+	spin_lock_irq(&amp;pmlmepriv-&gt;lock);
 
 	if (rtw_to_roaming(adapter) &gt; 0) { /* join timeout caused by roaming */
 		while (1) {
@@ -1334,7 +1336,7 @@ void _rtw_join_timeout_handler (struct adapter *adapter)
 		rtw_indicate_disconnect(adapter);
 		free_scanqueue(pmlmepriv);/*  */
 	}
-	spin_unlock_bh(&amp;pmlmepriv-&gt;lock);
+	spin_unlock_irq(&amp;pmlmepriv-&gt;lock);
 
 }
 </pre><hr><pre>commit 041879b12ddb0c6c83ed9c0bdd10dc82a056f2fc
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sat Apr 9 14:49:53 2022 +0800

    drivers: staging: rtl8192bs: Fix deadlock in rtw_joinbss_event_prehandle()
    
    There is a deadlock in rtw_joinbss_event_prehandle(), which is shown
    below:
    
       (Thread 1)                |      (Thread 2)
                                 | _set_timer()
    rtw_joinbss_event_prehandle()|  mod_timer()
     spin_lock_bh() //(1)        |  (wait a time)
     ...                         | _rtw_join_timeout_handler()
     del_timer_sync()            |  spin_lock_bh() //(2)
     (wait timer to stop)        |  ...
    
    We hold pmlmepriv-&gt;lock in position (1) of thread 1 and
    use del_timer_sync() to wait timer to stop, but timer handler
    also need pmlmepriv-&gt;lock in position (2) of thread 2.
    As a result, rtw_joinbss_event_prehandle() will block forever.
    
    This patch extracts del_timer_sync() from the protection of
    spin_lock_bh(), which could let timer handler to obtain
    the needed lock. What`s more, we change spin_lock_bh() to
    spin_lock_irq() in _rtw_join_timeout_handler() in order to
    prevent deadlock.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20220409064953.67420-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtl8723bs/core/rtw_mlme.c b/drivers/staging/rtl8723bs/core/rtw_mlme.c
index f7db483a5641..f2242cf2dfb4 100644
--- a/drivers/staging/rtl8723bs/core/rtw_mlme.c
+++ b/drivers/staging/rtl8723bs/core/rtw_mlme.c
@@ -1240,8 +1240,10 @@ void rtw_joinbss_event_prehandle(struct adapter *adapter, u8 *pbuf)
 
 			spin_unlock_bh(&amp;pmlmepriv-&gt;scanned_queue.lock);
 
+			spin_unlock_bh(&amp;pmlmepriv-&gt;lock);
 			/* s5. Cancel assoc_timer */
 			del_timer_sync(&amp;pmlmepriv-&gt;assoc_timer);
+			spin_lock_bh(&amp;pmlmepriv-&gt;lock);
 		} else {
 			spin_unlock_bh(&amp;(pmlmepriv-&gt;scanned_queue.lock));
 		}
@@ -1547,7 +1549,7 @@ void _rtw_join_timeout_handler(struct timer_list *t)
 	if (adapter-&gt;bDriverStopped || adapter-&gt;bSurpriseRemoved)
 		return;
 
-	spin_lock_bh(&amp;pmlmepriv-&gt;lock);
+	spin_lock_irq(&amp;pmlmepriv-&gt;lock);
 
 	if (rtw_to_roam(adapter) &gt; 0) { /* join timeout caused by roaming */
 		while (1) {
@@ -1575,7 +1577,7 @@ void _rtw_join_timeout_handler(struct timer_list *t)
 
 	}
 
-	spin_unlock_bh(&amp;pmlmepriv-&gt;lock);
+	spin_unlock_irq(&amp;pmlmepriv-&gt;lock);
 }
 
 /*</pre><hr><pre>commit cc7ad0d77b51c872d629bcd98aea463a3c4109e7
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sat Apr 9 14:18:35 2022 +0800

    drivers: staging: rtl8723bs: Fix deadlock in rtw_surveydone_event_callback()
    
    There is a deadlock in rtw_surveydone_event_callback(),
    which is shown below:
    
       (Thread 1)                  |      (Thread 2)
                                   | _set_timer()
    rtw_surveydone_event_callback()|  mod_timer()
     spin_lock_bh() //(1)          |  (wait a time)
     ...                           | rtw_scan_timeout_handler()
     del_timer_sync()              |  spin_lock_bh() //(2)
     (wait timer to stop)          |  ...
    
    We hold pmlmepriv-&gt;lock in position (1) of thread 1 and use
    del_timer_sync() to wait timer to stop, but timer handler
    also need pmlmepriv-&gt;lock in position (2) of thread 2.
    As a result, rtw_surveydone_event_callback() will block forever.
    
    This patch extracts del_timer_sync() from the protection of
    spin_lock_bh(), which could let timer handler to obtain
    the needed lock. What`s more, we change spin_lock_bh() in
    rtw_scan_timeout_handler() to spin_lock_irq(). Otherwise,
    spin_lock_bh() will also cause deadlock() in timer handler.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20220409061836.60529-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtl8723bs/core/rtw_mlme.c b/drivers/staging/rtl8723bs/core/rtw_mlme.c
index a45df775d535..f7db483a5641 100644
--- a/drivers/staging/rtl8723bs/core/rtw_mlme.c
+++ b/drivers/staging/rtl8723bs/core/rtw_mlme.c
@@ -751,7 +751,9 @@ void rtw_surveydone_event_callback(struct adapter	*adapter, u8 *pbuf)
 	}
 
 	if (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {
+		spin_unlock_bh(&amp;pmlmepriv-&gt;lock);
 		del_timer_sync(&amp;pmlmepriv-&gt;scan_to_timer);
+		spin_lock_bh(&amp;pmlmepriv-&gt;lock);
 		_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 	}
 
@@ -1586,11 +1588,11 @@ void rtw_scan_timeout_handler(struct timer_list *t)
 						  mlmepriv.scan_to_timer);
 	struct	mlme_priv *pmlmepriv = &amp;adapter-&gt;mlmepriv;
 
-	spin_lock_bh(&amp;pmlmepriv-&gt;lock);
+	spin_lock_irq(&amp;pmlmepriv-&gt;lock);
 
 	_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);
 
-	spin_unlock_bh(&amp;pmlmepriv-&gt;lock);
+	spin_unlock_irq(&amp;pmlmepriv-&gt;lock);
 
 	rtw_indicate_scan_done(adapter, true);
 }</pre><hr><pre>commit ec4eb8a86ade4d22633e1da2a7d85a846b7d1798
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Tue Apr 5 21:22:06 2022 +0800

    drivers: net: slip: fix NPD bug in sl_tx_timeout()
    
    When a slip driver is detaching, the slip_close() will act to
    cleanup necessary resources and sl-&gt;tty is set to NULL in
    slip_close(). Meanwhile, the packet we transmit is blocked,
    sl_tx_timeout() will be called. Although slip_close() and
    sl_tx_timeout() use sl-&gt;lock to synchronize, we don`t judge
    whether sl-&gt;tty equals to NULL in sl_tx_timeout() and the
    null pointer dereference bug will happen.
    
       (Thread 1)                 |      (Thread 2)
                                  | slip_close()
                                  |   spin_lock_bh(&amp;sl-&gt;lock)
                                  |   ...
    ...                           |   sl-&gt;tty = NULL //(1)
    sl_tx_timeout()               |   spin_unlock_bh(&amp;sl-&gt;lock)
      spin_lock(&amp;sl-&gt;lock);       |
      ...                         |   ...
      tty_chars_in_buffer(sl-&gt;tty)|
        if (tty-&gt;ops-&gt;..) //(2)   |
        ...                       |   synchronize_rcu()
    
    We set NULL to sl-&gt;tty in position (1) and dereference sl-&gt;tty
    in position (2).
    
    This patch adds check in sl_tx_timeout(). If sl-&gt;tty equals to
    NULL, sl_tx_timeout() will goto out.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Jiri Slaby &lt;jirislaby@kernel.org&gt;
    Link: https://lore.kernel.org/r/20220405132206.55291-1-duoming@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c
index 88396ff99f03..6865d32270e5 100644
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@ -469,7 +469,7 @@ static void sl_tx_timeout(struct net_device *dev, unsigned int txqueue)
 	spin_lock(&amp;sl-&gt;lock);
 
 	if (netif_queue_stopped(dev)) {
-		if (!netif_running(dev))
+		if (!netif_running(dev) || !sl-&gt;tty)
 			goto out;
 
 		/* May be we must check transmitter timeout here ?</pre><hr><pre>commit 82e31755e55fbcea6a9dfaae5fe4860ade17cbc0
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Mon Mar 28 21:00:15 2022 +0800

    ax25: Fix UAF bugs in ax25 timers
    
    There are race conditions that may lead to UAF bugs in
    ax25_heartbeat_expiry(), ax25_t1timer_expiry(), ax25_t2timer_expiry(),
    ax25_t3timer_expiry() and ax25_idletimer_expiry(), when we call
    ax25_release() to deallocate ax25_dev.
    
    One of the UAF bugs caused by ax25_release() is shown below:
    
          (Thread 1)                    |      (Thread 2)
    ax25_dev_device_up() //(1)          |
    ...                                 | ax25_kill_by_device()
    ax25_bind()          //(2)          |
    ax25_connect()                      | ...
     ax25_std_establish_data_link()     |
      ax25_start_t1timer()              | ax25_dev_device_down() //(3)
       mod_timer(&amp;ax25-&gt;t1timer,..)     |
                                        | ax25_release()
       (wait a time)                    |  ...
                                        |  ax25_dev_put(ax25_dev) //(4)FREE
       ax25_t1timer_expiry()            |
        ax25-&gt;ax25_dev-&gt;values[..] //USE|  ...
         ...                            |
    
    We increase the refcount of ax25_dev in position (1) and (2), and
    decrease the refcount of ax25_dev in position (3) and (4).
    The ax25_dev will be freed in position (4) and be used in
    ax25_t1timer_expiry().
    
    The fail log is shown below:
    ==============================================================
    
    [  106.116942] BUG: KASAN: use-after-free in ax25_t1timer_expiry+0x1c/0x60
    [  106.116942] Read of size 8 at addr ffff88800bda9028 by task swapper/0/0
    [  106.116942] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.17.0-06123-g0905eec574
    [  106.116942] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-14
    [  106.116942] Call Trace:
    ...
    [  106.116942]  ax25_t1timer_expiry+0x1c/0x60
    [  106.116942]  call_timer_fn+0x122/0x3d0
    [  106.116942]  __run_timers.part.0+0x3f6/0x520
    [  106.116942]  run_timer_softirq+0x4f/0xb0
    [  106.116942]  __do_softirq+0x1c2/0x651
    ...
    
    This patch adds del_timer_sync() in ax25_release(), which could ensure
    that all timers stop before we deallocate ax25_dev.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: Paolo Abeni &lt;pabeni@redhat.com&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index f5686c463bc0..363d47f94532 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -1053,6 +1053,11 @@ static int ax25_release(struct socket *sock)
 		ax25_destroy_socket(ax25);
 	}
 	if (ax25_dev) {
+		del_timer_sync(&amp;ax25-&gt;timer);
+		del_timer_sync(&amp;ax25-&gt;t1timer);
+		del_timer_sync(&amp;ax25-&gt;t2timer);
+		del_timer_sync(&amp;ax25-&gt;t3timer);
+		del_timer_sync(&amp;ax25-&gt;idletimer);
 		dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
 		ax25_dev_put(ax25_dev);
 	}</pre><hr><pre>commit 5352a761308397a0e6250fdc629bb3f615b94747
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Mon Mar 28 21:00:14 2022 +0800

    ax25: fix UAF bug in ax25_send_control()
    
    There are UAF bugs in ax25_send_control(), when we call ax25_release()
    to deallocate ax25_dev. The possible race condition is shown below:
    
          (Thread 1)              |     (Thread 2)
    ax25_dev_device_up() //(1)    |
                                  | ax25_kill_by_device()
    ax25_bind()          //(2)    |
    ax25_connect()                | ...
     ax25-&gt;state = AX25_STATE_1   |
     ...                          | ax25_dev_device_down() //(3)
    
          (Thread 3)
    ax25_release()                |
     ax25_dev_put()  //(4) FREE   |
     case AX25_STATE_1:           |
      ax25_send_control()         |
       alloc_skb()       //USE    |
    
    The refcount of ax25_dev increases in position (1) and (2), and
    decreases in position (3) and (4). The ax25_dev will be freed
    before dereference sites in ax25_send_control().
    
    The following is part of the report:
    
    [  102.297448] BUG: KASAN: use-after-free in ax25_send_control+0x33/0x210
    [  102.297448] Read of size 8 at addr ffff888009e6e408 by task ax25_close/602
    [  102.297448] Call Trace:
    [  102.303751]  ax25_send_control+0x33/0x210
    [  102.303751]  ax25_release+0x356/0x450
    [  102.305431]  __sock_release+0x6d/0x120
    [  102.305431]  sock_close+0xf/0x20
    [  102.305431]  __fput+0x11f/0x420
    [  102.305431]  task_work_run+0x86/0xd0
    [  102.307130]  get_signal+0x1075/0x1220
    [  102.308253]  arch_do_signal_or_restart+0x1df/0xc00
    [  102.308253]  exit_to_user_mode_prepare+0x150/0x1e0
    [  102.308253]  syscall_exit_to_user_mode+0x19/0x50
    [  102.308253]  do_syscall_64+0x48/0x90
    [  102.308253]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [  102.308253] RIP: 0033:0x405ae7
    
    This patch defers the free operation of ax25_dev and net_device after
    all corresponding dereference sites in ax25_release() to avoid UAF.
    
    Fixes: 9fd75b66b8f6 ("ax25: Fix refcount leaks caused by ax25_cb_del()")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: Paolo Abeni &lt;pabeni@redhat.com&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 992b6e5d85d7..f5686c463bc0 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -991,10 +991,6 @@ static int ax25_release(struct socket *sock)
 	sock_orphan(sk);
 	ax25 = sk_to_ax25(sk);
 	ax25_dev = ax25-&gt;ax25_dev;
-	if (ax25_dev) {
-		dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
-		ax25_dev_put(ax25_dev);
-	}
 
 	if (sk-&gt;sk_type == SOCK_SEQPACKET) {
 		switch (ax25-&gt;state) {
@@ -1056,6 +1052,10 @@ static int ax25_release(struct socket *sock)
 		sk-&gt;sk_state_change(sk);
 		ax25_destroy_socket(ax25);
 	}
+	if (ax25_dev) {
+		dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
+		ax25_dev_put(ax25_dev);
+	}
 
 	sock-&gt;sk   = NULL;
 	release_sock(sk);</pre><hr><pre>commit 7781607938c8371d4c2b243527430241c62e39c2
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sat Mar 26 18:43:46 2022 +0800

    net/x25: Fix null-ptr-deref caused by x25_disconnect
    
    When the link layer is terminating, x25-&gt;neighbour will be set to NULL
    in x25_disconnect(). As a result, it could cause null-ptr-deref bugs in
    x25_sendmsg(),x25_recvmsg() and x25_connect(). One of the bugs is
    shown below.
    
        (Thread 1)                 |  (Thread 2)
    x25_link_terminated()          | x25_recvmsg()
     x25_kill_by_neigh()           |  ...
      x25_disconnect()             |  lock_sock(sk)
       ...                         |  ...
       x25-&gt;neighbour = NULL //(1) |
       ...                         |  x25-&gt;neighbour-&gt;extended //(2)
    
    The code sets NULL to x25-&gt;neighbour in position (1) and dereferences
    x25-&gt;neighbour in position (2), which could cause null-ptr-deref bug.
    
    This patch adds lock_sock() in x25_kill_by_neigh() in order to synchronize
    with x25_sendmsg(), x25_recvmsg() and x25_connect(). What`s more, the
    sock held by lock_sock() is not NULL, because it is extracted from x25_list
    and uses x25_list_lock to synchronize.
    
    Fixes: 4becb7ee5b3d ("net/x25: Fix x25_neigh refcnt leak when x25 disconnect")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/x25/af_x25.c b/net/x25/af_x25.c
index 3583354a7d7f..3a171828638b 100644
--- a/net/x25/af_x25.c
+++ b/net/x25/af_x25.c
@@ -1765,10 +1765,15 @@ void x25_kill_by_neigh(struct x25_neigh *nb)
 
 	write_lock_bh(&amp;x25_list_lock);
 
-	sk_for_each(s, &amp;x25_list)
-		if (x25_sk(s)-&gt;neighbour == nb)
+	sk_for_each(s, &amp;x25_list) {
+		if (x25_sk(s)-&gt;neighbour == nb) {
+			write_unlock_bh(&amp;x25_list_lock);
+			lock_sock(s);
 			x25_disconnect(s, ENETUNREACH, 0, 0);
-
+			release_sock(s);
+			write_lock_bh(&amp;x25_list_lock);
+		}
+	}
 	write_unlock_bh(&amp;x25_list_lock);
 
 	/* Remove any related forwards */</pre><hr><pre>commit fc6d01ff9ef03b66d4a3a23b46fc3c3d8cf92009
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Fri Mar 18 08:54:05 2022 +0800

    ax25: Fix NULL pointer dereferences in ax25 timers
    
    The previous commit 7ec02f5ac8a5 ("ax25: fix NPD bug in ax25_disconnect")
    move ax25_disconnect into lock_sock() in order to prevent NPD bugs. But
    there are race conditions that may lead to null pointer dereferences in
    ax25_heartbeat_expiry(), ax25_t1timer_expiry(), ax25_t2timer_expiry(),
    ax25_t3timer_expiry() and ax25_idletimer_expiry(), when we use
    ax25_kill_by_device() to detach the ax25 device.
    
    One of the race conditions that cause null pointer dereferences can be
    shown as below:
    
          (Thread 1)                    |      (Thread 2)
    ax25_connect()                      |
     ax25_std_establish_data_link()     |
      ax25_start_t1timer()              |
       mod_timer(&amp;ax25-&gt;t1timer,..)     |
                                        | ax25_kill_by_device()
       (wait a time)                    |  ...
                                        |  s-&gt;ax25_dev = NULL; //(1)
       ax25_t1timer_expiry()            |
        ax25-&gt;ax25_dev-&gt;values[..] //(2)|  ...
         ...                            |
    
    We set null to ax25_cb-&gt;ax25_dev in position (1) and dereference
    the null pointer in position (2).
    
    The corresponding fail log is shown below:
    ===============================================================
    BUG: kernel NULL pointer dereference, address: 0000000000000050
    CPU: 1 PID: 0 Comm: swapper/1 Not tainted 5.17.0-rc6-00794-g45690b7d0
    RIP: 0010:ax25_t1timer_expiry+0x12/0x40
    ...
    Call Trace:
     call_timer_fn+0x21/0x120
     __run_timers.part.0+0x1ca/0x250
     run_timer_softirq+0x2c/0x60
     __do_softirq+0xef/0x2f3
     irq_exit_rcu+0xb6/0x100
     sysvec_apic_timer_interrupt+0xa2/0xd0
    ...
    
    This patch moves ax25_disconnect() before s-&gt;ax25_dev = NULL
    and uses del_timer_sync() to delete timers in ax25_disconnect().
    If ax25_disconnect() is called by ax25_kill_by_device() or
    ax25-&gt;ax25_dev is NULL, the reason in ax25_disconnect() will be
    equal to ENETUNREACH, it will wait all timers to stop before we
    set null to s-&gt;ax25_dev in ax25_kill_by_device().
    
    Fixes: 7ec02f5ac8a5 ("ax25: fix NPD bug in ax25_disconnect")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index cf8847cfc664..992b6e5d85d7 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -89,20 +89,20 @@ static void ax25_kill_by_device(struct net_device *dev)
 			sk = s-&gt;sk;
 			if (!sk) {
 				spin_unlock_bh(&amp;ax25_list_lock);
-				s-&gt;ax25_dev = NULL;
 				ax25_disconnect(s, ENETUNREACH);
+				s-&gt;ax25_dev = NULL;
 				spin_lock_bh(&amp;ax25_list_lock);
 				goto again;
 			}
 			sock_hold(sk);
 			spin_unlock_bh(&amp;ax25_list_lock);
 			lock_sock(sk);
+			ax25_disconnect(s, ENETUNREACH);
 			s-&gt;ax25_dev = NULL;
 			if (sk-&gt;sk_socket) {
 				dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
 				ax25_dev_put(ax25_dev);
 			}
-			ax25_disconnect(s, ENETUNREACH);
 			release_sock(sk);
 			spin_lock_bh(&amp;ax25_list_lock);
 			sock_put(sk);
diff --git a/net/ax25/ax25_subr.c b/net/ax25/ax25_subr.c
index 15ab812c4fe4..3a476e4f6cd0 100644
--- a/net/ax25/ax25_subr.c
+++ b/net/ax25/ax25_subr.c
@@ -261,12 +261,20 @@ void ax25_disconnect(ax25_cb *ax25, int reason)
 {
 	ax25_clear_queues(ax25);
 
-	if (!ax25-&gt;sk || !sock_flag(ax25-&gt;sk, SOCK_DESTROY))
-		ax25_stop_heartbeat(ax25);
-	ax25_stop_t1timer(ax25);
-	ax25_stop_t2timer(ax25);
-	ax25_stop_t3timer(ax25);
-	ax25_stop_idletimer(ax25);
+	if (reason == ENETUNREACH) {
+		del_timer_sync(&amp;ax25-&gt;timer);
+		del_timer_sync(&amp;ax25-&gt;t1timer);
+		del_timer_sync(&amp;ax25-&gt;t2timer);
+		del_timer_sync(&amp;ax25-&gt;t3timer);
+		del_timer_sync(&amp;ax25-&gt;idletimer);
+	} else {
+		if (!ax25-&gt;sk || !sock_flag(ax25-&gt;sk, SOCK_DESTROY))
+			ax25_stop_heartbeat(ax25);
+		ax25_stop_t1timer(ax25);
+		ax25_stop_t2timer(ax25);
+		ax25_stop_t3timer(ax25);
+		ax25_stop_idletimer(ax25);
+	}
 
 	ax25-&gt;state = AX25_STATE_0;
 </pre><hr><pre>commit 9fd75b66b8f68498454d685dc4ba13192ae069b0
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Fri Mar 18 08:54:04 2022 +0800

    ax25: Fix refcount leaks caused by ax25_cb_del()
    
    The previous commit d01ffb9eee4a ("ax25: add refcount in ax25_dev to
    avoid UAF bugs") and commit feef318c855a ("ax25: fix UAF bugs of
    net_device caused by rebinding operation") increase the refcounts of
    ax25_dev and net_device in ax25_bind() and decrease the matching refcounts
    in ax25_kill_by_device() in order to prevent UAF bugs, but there are
    reference count leaks.
    
    The root cause of refcount leaks is shown below:
    
         (Thread 1)                      |      (Thread 2)
    ax25_bind()                          |
     ...                                 |
     ax25_addr_ax25dev()                 |
      ax25_dev_hold()   //(1)            |
      ...                                |
     dev_hold_track()   //(2)            |
     ...                                 | ax25_destroy_socket()
                                         |  ax25_cb_del()
                                         |   ...
                                         |   hlist_del_init() //(3)
                                         |
                                         |
         (Thread 3)                      |
    ax25_kill_by_device()                |
     ...                                 |
     ax25_for_each(s, &amp;ax25_list) {      |
      if (s-&gt;ax25_dev == ax25_dev) //(4) |
       ...                               |
    
    Firstly, we use ax25_bind() to increase the refcount of ax25_dev in
    position (1) and increase the refcount of net_device in position (2).
    Then, we use ax25_cb_del() invoked by ax25_destroy_socket() to delete
    ax25_cb in hlist in position (3) before calling ax25_kill_by_device().
    Finally, the decrements of refcounts in ax25_kill_by_device() will not
    be executed, because no s-&gt;ax25_dev equals to ax25_dev in position (4).
    
    This patch adds decrements of refcounts in ax25_release() and use
    lock_sock() to do synchronization. If refcounts decrease in ax25_release(),
    the decrements of refcounts in ax25_kill_by_device() will not be
    executed and vice versa.
    
    Fixes: d01ffb9eee4a ("ax25: add refcount in ax25_dev to avoid UAF bugs")
    Fixes: 87563a043cef ("ax25: fix reference count leaks of ax25_dev")
    Fixes: feef318c855a ("ax25: fix UAF bugs of net_device caused by rebinding operation")
    Reported-by: Thomas Osterried &lt;thomas@osterried.de&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 6bd097180772..cf8847cfc664 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -98,8 +98,10 @@ static void ax25_kill_by_device(struct net_device *dev)
 			spin_unlock_bh(&amp;ax25_list_lock);
 			lock_sock(sk);
 			s-&gt;ax25_dev = NULL;
-			dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
-			ax25_dev_put(ax25_dev);
+			if (sk-&gt;sk_socket) {
+				dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
+				ax25_dev_put(ax25_dev);
+			}
 			ax25_disconnect(s, ENETUNREACH);
 			release_sock(sk);
 			spin_lock_bh(&amp;ax25_list_lock);
@@ -979,14 +981,20 @@ static int ax25_release(struct socket *sock)
 {
 	struct sock *sk = sock-&gt;sk;
 	ax25_cb *ax25;
+	ax25_dev *ax25_dev;
 
 	if (sk == NULL)
 		return 0;
 
 	sock_hold(sk);
-	sock_orphan(sk);
 	lock_sock(sk);
+	sock_orphan(sk);
 	ax25 = sk_to_ax25(sk);
+	ax25_dev = ax25-&gt;ax25_dev;
+	if (ax25_dev) {
+		dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
+		ax25_dev_put(ax25_dev);
+	}
 
 	if (sk-&gt;sk_type == SOCK_SEQPACKET) {
 		switch (ax25-&gt;state) {</pre><hr><pre>commit 71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Tue Mar 8 16:12:23 2022 +0800

    ax25: Fix NULL pointer dereference in ax25_kill_by_device
    
    When two ax25 devices attempted to establish connection, the requester use ax25_create(),
    ax25_bind() and ax25_connect() to initiate connection. The receiver use ax25_rcv() to
    accept connection and use ax25_create_cb() in ax25_rcv() to create ax25_cb, but the
    ax25_cb-&gt;sk is NULL. When the receiver is detaching, a NULL pointer dereference bug
    caused by sock_hold(sk) in ax25_kill_by_device() will happen. The corresponding
    fail log is shown below:
    
    ===============================================================
    BUG: KASAN: null-ptr-deref in ax25_device_event+0xfd/0x290
    Call Trace:
    ...
    ax25_device_event+0xfd/0x290
    raw_notifier_call_chain+0x5e/0x70
    dev_close_many+0x174/0x220
    unregister_netdevice_many+0x1f7/0xa60
    unregister_netdevice_queue+0x12f/0x170
    unregister_netdev+0x13/0x20
    mkiss_close+0xcd/0x140
    tty_ldisc_release+0xc0/0x220
    tty_release_struct+0x17/0xa0
    tty_release+0x62d/0x670
    ...
    
    This patch add condition check in ax25_kill_by_device(). If s-&gt;sk is
    NULL, it will goto if branch to kill device.
    
    Fixes: 4e0f718daf97 ("ax25: improve the incomplete fix to avoid UAF and NPD bugs")
    Reported-by: Thomas Osterried &lt;thomas@osterried.de&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index d53cbb4e2503..6bd097180772 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -87,6 +87,13 @@ static void ax25_kill_by_device(struct net_device *dev)
 	ax25_for_each(s, &amp;ax25_list) {
 		if (s-&gt;ax25_dev == ax25_dev) {
 			sk = s-&gt;sk;
+			if (!sk) {
+				spin_unlock_bh(&amp;ax25_list_lock);
+				s-&gt;ax25_dev = NULL;
+				ax25_disconnect(s, ENETUNREACH);
+				spin_lock_bh(&amp;ax25_list_lock);
+				goto again;
+			}
 			sock_hold(sk);
 			spin_unlock_bh(&amp;ax25_list_lock);
 			lock_sock(sk);</pre>
    <div class="pagination">
        <a href='6_18.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><span>[19]</span><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_20.html'>Next&gt;&gt;</a>
    <div>
</body>
