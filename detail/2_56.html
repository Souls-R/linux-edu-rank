<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_55.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><span>[56]</span><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_57.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e8799906045302776b35b66b16495c575db3b69c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 18 16:31:30 2011 -0400

    USB: EHCI: remove usages of hcd-&gt;state
    
    This patch (as1483) improves the ehci-hcd driver family by getting rid
    of the reliance on the hcd-&gt;state variable.  It has no clear owner and
    it isn't protected by the usual HCD locks.  In its place, the patch
    adds a new, private ehci-&gt;rh_state field to record the state of the
    root hub.
    
    Along the way, the patch removes a couple of lines containing
    redundant assignments to the state variable.  Also, the QUIESCING
    state simply gets changed to the RUNNING state, because the driver
    doesn't make any distinction between them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Jingoo Han &lt;jg1.han@samsung.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index 42ae57409908..4363fea85151 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -293,7 +293,7 @@ static int ehci_hcd_au1xxx_drv_resume(struct device *dev)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 40a844c1dbb4..9952505d2357 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -697,6 +697,19 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 }
 #undef DBG_SCHED_LIMIT
 
+static const char *rh_state_string(struct ehci_hcd *ehci)
+{
+	switch (ehci-&gt;rh_state) {
+	case EHCI_RH_HALTED:
+		return "halted";
+	case EHCI_RH_SUSPENDED:
+		return "suspended";
+	case EHCI_RH_RUNNING:
+		return "running";
+	}
+	return "?";
+}
+
 static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 {
 	struct usb_hcd		*hcd;
@@ -730,11 +743,11 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	temp = scnprintf (next, size,
 		"bus %s, device %s\n"
 		"%s\n"
-		"EHCI %x.%02x, hcd state %d\n",
+		"EHCI %x.%02x, rh state %s\n",
 		hcd-&gt;self.controller-&gt;bus-&gt;name,
 		dev_name(hcd-&gt;self.controller),
 		hcd-&gt;product_desc,
-		i &gt;&gt; 8, i &amp; 0x0ff, hcd-&gt;state);
+		i &gt;&gt; 8, i &amp; 0x0ff, rh_state_string(ehci));
 	size -= temp;
 	next += temp;
 
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 34a3140d1e5f..3bf9f16b4fd8 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -392,7 +392,7 @@ static int ehci_fsl_mpc512x_drv_suspend(struct device *dev)
 
 	dev_dbg(dev, "suspending...\n");
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 	dev-&gt;power.power_state = PMSG_SUSPEND;
 
 	/* ignore non-host interrupts */
@@ -481,7 +481,7 @@ static int ehci_fsl_mpc512x_drv_resume(struct device *dev)
 	ehci_writel(ehci, pdata-&gt;pm_portsc, &amp;ehci-&gt;regs-&gt;port_status[0]);
 
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	hcd-&gt;state = HC_STATE_RUNNING;
+	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 	dev-&gt;power.power_state = PMSG_ON;
 
 	tmp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 2af3e2a89efc..8696489cde56 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -238,7 +238,7 @@ static int handshake_on_error_set_halt(struct ehci_hcd *ehci, void __iomem *ptr,
 	error = handshake(ehci, ptr, mask, done, usec);
 	if (error) {
 		ehci_halt(ehci);
-		ehci_to_hcd(ehci)-&gt;state = HC_STATE_HALT;
+		ehci-&gt;rh_state = EHCI_RH_HALTED;
 		ehci_err(ehci, "force halt; handshake %p %08x %08x -&gt; %d\n",
 			ptr, mask, done, error);
 	}
@@ -278,7 +278,7 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	command |= CMD_RESET;
 	dbg_cmd (ehci, "reset", command);
 	ehci_writel(ehci, command, &amp;ehci-&gt;regs-&gt;command);
-	ehci_to_hcd(ehci)-&gt;state = HC_STATE_HALT;
+	ehci-&gt;rh_state = EHCI_RH_HALTED;
 	ehci-&gt;next_statechange = jiffies;
 	retval = handshake (ehci, &amp;ehci-&gt;regs-&gt;command,
 			    CMD_RESET, 0, 250 * 1000);
@@ -307,7 +307,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	u32	temp;
 
 #ifdef DEBUG
-	if (!HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 		BUG ();
 #endif
 
@@ -356,7 +356,7 @@ static void ehci_iaa_watchdog(unsigned long param)
 	 */
 	if (ehci-&gt;reclaim
 			&amp;&amp; !timer_pending(&amp;ehci-&gt;iaa_watchdog)
-			&amp;&amp; HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+			&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		u32 cmd, status;
 
 		/* If we get here, IAA is *REALLY* late.  It's barely
@@ -496,7 +496,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * misplace IRQs, and should let us run completely without IRQs.
 	 * such lossage has been observed on both VT6202 and VT8235.
 	 */
-	if (HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state) &amp;&amp;
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
 			(ehci-&gt;async-&gt;qh_next.ptr != NULL ||
 			 ehci-&gt;periodic_sched != 0))
 		timer_action (ehci, TIMER_IO_WATCHDOG);
@@ -516,7 +516,7 @@ static void ehci_stop (struct usb_hcd *hcd)
 	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
-	if (HC_IS_RUNNING (hcd-&gt;state))
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		ehci_quiesce (ehci);
 
 	ehci_silence_controller(ehci);
@@ -741,7 +741,7 @@ static int ehci_run (struct usb_hcd *hcd)
 	 * be started before the port switching actions could complete.
 	 */
 	down_write(&amp;ehci_cf_port_reset_rwsem);
-	hcd-&gt;state = HC_STATE_RUNNING;
+	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
 	msleep(5);
@@ -788,7 +788,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* Shared IRQ? */
 	masked_status = status &amp; INTR_MASK;
-	if (!masked_status || unlikely(hcd-&gt;state == HC_STATE_HALT)) {
+	if (!masked_status || unlikely(ehci-&gt;rh_state == EHCI_RH_HALTED)) {
 		spin_unlock(&amp;ehci-&gt;lock);
 		return IRQ_NONE;
 	}
@@ -952,7 +952,7 @@ static int ehci_urb_enqueue (
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	/* failfast */
-	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state) &amp;&amp; ehci-&gt;reclaim)
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING &amp;&amp; ehci-&gt;reclaim)
 		end_unlink_async(ehci);
 
 	/* If the QH isn't linked then there's nothing we can do
@@ -1079,7 +1079,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		goto idle_timeout;
 	}
 
-	if (!HC_IS_RUNNING (hcd-&gt;state))
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
 	case QH_STATE_LINKED:
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index e051b30c1847..c6104c4f1f38 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -236,10 +236,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	}
 
 	/* stop schedules, clean any completed work */
-	if (HC_IS_RUNNING(hcd-&gt;state)) {
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		ehci_quiesce (ehci);
-		hcd-&gt;state = HC_STATE_QUIESCING;
-	}
 	ehci-&gt;command = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	ehci_work(ehci);
 
@@ -313,7 +311,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	/* turn off now-idle HC */
 	ehci_halt (ehci);
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	if (ehci-&gt;reclaim)
 		end_unlink_async(ehci);
@@ -382,6 +380,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 
 	/* restore CMD_RUN, framelist size, and irq threshold */
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+	ehci-&gt;rh_state = EHCI_RH_RUNNING;
 
 	/* Some controller/firmware combinations need a delay during which
 	 * they set up the port statuses.  See Bugzilla #8190. */
@@ -452,7 +451,6 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	}
 
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(5);
-	hcd-&gt;state = HC_STATE_RUNNING;
 
 	/* Now we can safely re-enable irqs */
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
@@ -564,7 +562,7 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	u32		ppcd = 0;
 
 	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
-	if (!HC_IS_RUNNING(hcd-&gt;state))
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 		return 0;
 
 	/* init status to no-changes */
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 1102ce65a3a9..8311de7c0a75 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -439,7 +439,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 0917e3a32465..6ce0b3a9a0f9 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -153,7 +153,7 @@ static void ehci_clear_tt_buffer_complete(struct usb_hcd *hcd,
 	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 	qh-&gt;clearing_tt = 0;
 	if (qh-&gt;qh_state == QH_STATE_IDLE &amp;&amp; !list_empty(&amp;qh-&gt;qtd_list)
-			&amp;&amp; HC_IS_RUNNING(hcd-&gt;state))
+			&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)
 		qh_link_async(ehci, qh);
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 }
@@ -425,7 +425,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 		/* stop scanning when we reach qtds the hc is using */
 		} else if (likely (!stopped
-				&amp;&amp; HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))) {
+				&amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
 			break;
 
 		/* scan the whole queue for unlinks whenever it stops */
@@ -433,7 +433,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			stopped = 1;
 
 			/* cancel everything if we halt, suspend, etc */
-			if (!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state))
+			if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
 				last_status = -ESHUTDOWN;
 
 			/* this qtd is active; skip it unless a previous qtd
@@ -977,9 +977,8 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			/* in case a clear of CMD_ASE didn't take yet */
 			(void)handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
 					STS_ASS, 0, 150);
-			cmd |= CMD_ASE | CMD_RUN;
+			cmd |= CMD_ASE;
 			ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
-			ehci_to_hcd(ehci)-&gt;state = HC_STATE_RUNNING;
 			/* posted write need not be known to HC yet ... */
 		}
 	}
@@ -1168,14 +1167,13 @@ static void end_unlink_async (struct ehci_hcd *ehci)
 
 	qh_completions (ehci, qh);
 
-	if (!list_empty (&amp;qh-&gt;qtd_list)
-			&amp;&amp; HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state))
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		qh_link_async (ehci, qh);
-	else {
+	} else {
 		/* it's not free to turn the async schedule on/off; leave it
 		 * active but idle for a while once it empties.
 		 */
-		if (HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state)
+		if (ehci-&gt;rh_state == EHCI_RH_RUNNING
 				&amp;&amp; ehci-&gt;async-&gt;qh_next.qh == NULL)
 			timer_action (ehci, TIMER_ASYNC_OFF);
 	}
@@ -1211,7 +1209,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* stop async schedule right now? */
 	if (unlikely (qh == ehci-&gt;async)) {
 		/* can't get here without STS_ASS set */
-		if (ehci_to_hcd(ehci)-&gt;state != HC_STATE_HALT
+		if (ehci-&gt;rh_state != EHCI_RH_HALTED
 				&amp;&amp; !ehci-&gt;reclaim) {
 			/* ... and CMD_IAAD clear */
 			ehci_writel(ehci, cmd &amp; ~CMD_ASE,
@@ -1237,7 +1235,7 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	wmb ();
 
 	/* If the controller isn't running, we don't have to wait for it */
-	if (unlikely(!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state))) {
+	if (unlikely(ehci-&gt;rh_state != EHCI_RH_RUNNING)) {
 		/* if (unlikely (qh-&gt;reclaim != 0))
 		 *	this will recurse, probably not much
 		 */
@@ -1260,7 +1258,7 @@ static void scan_async (struct ehci_hcd *ehci)
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-	stopped = !HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state);
+	stopped = (ehci-&gt;rh_state != EHCI_RH_RUNNING);
 
 	ehci-&gt;qh_scan_next = ehci-&gt;async-&gt;qh_next.qh;
 	while (ehci-&gt;qh_scan_next) {
diff --git a/drivers/usb/host/ehci-s5p.c b/drivers/usb/host/ehci-s5p.c
index b3958b3d3163..318e0c6d0ab1 100644
--- a/drivers/usb/host/ehci-s5p.c
+++ b/drivers/usb/host/ehci-s5p.c
@@ -269,7 +269,7 @@ static int s5p_ehci_resume(struct device *dev)
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 2abf8543f083..488151bb45cb 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -479,7 +479,6 @@ static int enable_periodic (struct ehci_hcd *ehci)
 	cmd = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) | CMD_PSE;
 	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... PSS happens later */
-	ehci_to_hcd(ehci)-&gt;state = HC_STATE_RUNNING;
 
 	/* make sure ehci_work scans these */
 	ehci-&gt;next_uframe = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index)
@@ -677,7 +676,7 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	/* reschedule QH iff another request is queued */
 	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
-			HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+			ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		rc = qh_schedule(ehci, qh);
 
 		/* An error here likely indicates handshake failure
@@ -2275,7 +2274,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	 * Touches as few pages as possible:  cache-friendly.
 	 */
 	now_uframe = ehci-&gt;next_uframe;
-	if (HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+	if (ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		clock = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
 	} else  {
@@ -2310,7 +2309,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			union ehci_shadow	temp;
 			int			live;
 
-			live = HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state);
+			live = (ehci-&gt;rh_state == EHCI_RH_RUNNING);
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_QH:
 				/* handle any completions */
@@ -2435,7 +2434,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		 * We can't advance our scan without collecting the ISO
 		 * transfers that are still pending in this frame.
 		 */
-		if (incomplete &amp;&amp; HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+		if (incomplete &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 			ehci-&gt;next_uframe = now_uframe;
 			break;
 		}
@@ -2451,7 +2450,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		if (now_uframe == clock) {
 			unsigned	now;
 
-			if (!HC_IS_RUNNING (ehci_to_hcd(ehci)-&gt;state)
+			if (ehci-&gt;rh_state != EHCI_RH_RUNNING
 					|| ehci-&gt;periodic_sched == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index cc7d337ec355..c161d97de7dd 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -62,6 +62,12 @@ struct ehci_stats {
 
 #define	EHCI_MAX_ROOT_PORTS	15		/* see HCS_N_PORTS */
 
+enum ehci_rh_state {
+	EHCI_RH_HALTED,
+	EHCI_RH_SUSPENDED,
+	EHCI_RH_RUNNING
+};
+
 struct ehci_hcd {			/* one per controller */
 	/* glue to PCI and HCD framework */
 	struct ehci_caps __iomem *caps;
@@ -70,6 +76,7 @@ struct ehci_hcd {			/* one per controller */
 
 	__u32			hcs_params;	/* cached register copy */
 	spinlock_t		lock;
+	enum ehci_rh_state	rh_state;
 
 	/* async schedule support */
 	struct ehci_qh		*async;</pre><hr><pre>commit 5b1b0b812a7b1a5b968c5d06d90d1cb88621b941
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 19 23:49:48 2011 +0200

    PM / Runtime: Add macro to test for runtime PM events
    
    This patch (as1482) adds a macro for testing whether or not a
    pm_message value represents an autosuspend or autoresume (i.e., a
    runtime PM) event.  Encapsulating this notion seems preferable to
    open-coding the test all over the place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index c9ffa9ced7ee..e8662a5fbc5d 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -439,10 +439,10 @@ cause autosuspends to fail with -EBUSY if the driver needs to use the
 device.
 
 External suspend calls should never be allowed to fail in this way,
-only autosuspend calls.  The driver can tell them apart by checking
-the PM_EVENT_AUTO bit in the message.event argument to the suspend
-method; this bit will be set for internal PM events (autosuspend) and
-clear for external PM events.
+only autosuspend calls.  The driver can tell them apart by applying
+the PMSG_IS_AUTO() macro to the message argument to the suspend
+method; it will return True for internal PM events (autosuspend) and
+False for external PM events.
 
 
 	Mutual exclusion
diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c
index 91d13a9e8c65..91b190c40497 100644
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@ -1103,7 +1103,7 @@ static int btusb_suspend(struct usb_interface *intf, pm_message_t message)
 		return 0;
 
 	spin_lock_irq(&amp;data-&gt;txlock);
-	if (!((message.event &amp; PM_EVENT_AUTO) &amp;&amp; data-&gt;tx_in_flight)) {
+	if (!(PMSG_IS_AUTO(message) &amp;&amp; data-&gt;tx_in_flight)) {
 		set_bit(BTUSB_SUSPENDING, &amp;data-&gt;flags);
 		spin_unlock_irq(&amp;data-&gt;txlock);
 	} else {
diff --git a/drivers/hid/hid-picolcd.c b/drivers/hid/hid-picolcd.c
index 9d8710f8bc79..1782693819f3 100644
--- a/drivers/hid/hid-picolcd.c
+++ b/drivers/hid/hid-picolcd.c
@@ -2409,7 +2409,7 @@ static int picolcd_raw_event(struct hid_device *hdev,
 #ifdef CONFIG_PM
 static int picolcd_suspend(struct hid_device *hdev, pm_message_t message)
 {
-	if (message.event &amp; PM_EVENT_AUTO)
+	if (PMSG_IS_AUTO(message))
 		return 0;
 
 	picolcd_suspend_backlight(hid_get_drvdata(hdev));
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index ad978f5748d3..a9fa294ee7d3 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1332,7 +1332,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);	/* Sync with error handler */
 		if (!test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)
 		    &amp;&amp; !test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl)
@@ -1367,7 +1367,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 			return -EIO;
 	}
 
-	if (!ignoreled &amp;&amp; (message.event &amp; PM_EVENT_AUTO)) {
+	if (!ignoreled &amp;&amp; PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);
 		if (test_bit(HID_LED_ON, &amp;usbhid-&gt;iofl)) {
 			spin_unlock_irq(&amp;usbhid-&gt;lock);
@@ -1380,8 +1380,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 	hid_cancel_delayed_stuff(usbhid);
 	hid_cease_io(usbhid);
 
-	if ((message.event &amp; PM_EVENT_AUTO) &amp;&amp;
-			test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
+	if (PMSG_IS_AUTO(message) &amp;&amp; test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
 		/* lost race against keypresses */
 		status = hid_start_in(hid);
 		if (status &lt; 0)
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index ce395fe5de26..f1c435ba5284 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -1470,7 +1470,7 @@ int usbnet_suspend (struct usb_interface *intf, pm_message_t message)
 	if (!dev-&gt;suspend_count++) {
 		spin_lock_irq(&amp;dev-&gt;txq.lock);
 		/* don't autosuspend while transmitting */
-		if (dev-&gt;txq.qlen &amp;&amp; (message.event &amp; PM_EVENT_AUTO)) {
+		if (dev-&gt;txq.qlen &amp;&amp; PMSG_IS_AUTO(message)) {
 			spin_unlock_irq(&amp;dev-&gt;txq.lock);
 			return -EBUSY;
 		} else {
diff --git a/drivers/net/wimax/i2400m/usb.c b/drivers/net/wimax/i2400m/usb.c
index 298f2b0b6311..9a644d052f1e 100644
--- a/drivers/net/wimax/i2400m/usb.c
+++ b/drivers/net/wimax/i2400m/usb.c
@@ -599,7 +599,7 @@ void i2400mu_disconnect(struct usb_interface *iface)
  *
  *    As well, the device might refuse going to sleep for whichever
  *    reason. In this case we just fail. For system suspend/hibernate,
- *    we *can't* fail. We check PM_EVENT_AUTO to see if the
+ *    we *can't* fail. We check PMSG_IS_AUTO to see if the
  *    suspend call comes from the USB stack or from the system and act
  *    in consequence.
  *
@@ -615,7 +615,7 @@ int i2400mu_suspend(struct usb_interface *iface, pm_message_t pm_msg)
 	struct i2400m *i2400m = &amp;i2400mu-&gt;i2400m;
 
 #ifdef CONFIG_PM
-	if (pm_msg.event &amp; PM_EVENT_AUTO)
+	if (PMSG_IS_AUTO(pm_msg))
 		is_autosuspend = 1;
 #endif
 
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index dac7676ce21b..94e6c5c09dd8 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -1305,7 +1305,7 @@ static int acm_suspend(struct usb_interface *intf, pm_message_t message)
 	struct acm *acm = usb_get_intfdata(intf);
 	int cnt;
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		int b;
 
 		spin_lock_irq(&amp;acm-&gt;write_lock);
diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c
index 2b9ff518b509..42f180aca3fb 100644
--- a/drivers/usb/class/cdc-wdm.c
+++ b/drivers/usb/class/cdc-wdm.c
@@ -798,11 +798,11 @@ static int wdm_suspend(struct usb_interface *intf, pm_message_t message)
 	dev_dbg(&amp;desc-&gt;intf-&gt;dev, "wdm%d_suspend\n", intf-&gt;minor);
 
 	/* if this is an autosuspend the caller does the locking */
-	if (!(message.event &amp; PM_EVENT_AUTO))
+	if (!PMSG_IS_AUTO(message))
 		mutex_lock(&amp;desc-&gt;lock);
 	spin_lock_irq(&amp;desc-&gt;iuspin);
 
-	if ((message.event &amp; PM_EVENT_AUTO) &amp;&amp;
+	if (PMSG_IS_AUTO(message) &amp;&amp;
 			(test_bit(WDM_IN_USE, &amp;desc-&gt;flags)
 			|| test_bit(WDM_RESPONDING, &amp;desc-&gt;flags))) {
 		spin_unlock_irq(&amp;desc-&gt;iuspin);
@@ -815,7 +815,7 @@ static int wdm_suspend(struct usb_interface *intf, pm_message_t message)
 		kill_urbs(desc);
 		cancel_work_sync(&amp;desc-&gt;rxwork);
 	}
-	if (!(message.event &amp; PM_EVENT_AUTO))
+	if (!PMSG_IS_AUTO(message))
 		mutex_unlock(&amp;desc-&gt;lock);
 
 	return rv;
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 34e3da5aa72a..e03042883c68 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1046,8 +1046,7 @@ static int usb_resume_device(struct usb_device *udev, pm_message_t msg)
 	/* Non-root devices on a full/low-speed bus must wait for their
 	 * companion high-speed root hub, in case a handoff is needed.
 	 */
-	if (!(msg.event &amp; PM_EVENT_AUTO) &amp;&amp; udev-&gt;parent &amp;&amp;
-			udev-&gt;bus-&gt;hs_companion)
+	if (!PMSG_IS_AUTO(msg) &amp;&amp; udev-&gt;parent &amp;&amp; udev-&gt;bus-&gt;hs_companion)
 		device_pm_wait_for_dev(&amp;udev-&gt;dev,
 				&amp;udev-&gt;bus-&gt;hs_companion-&gt;root_hub-&gt;dev);
 
@@ -1075,7 +1074,7 @@ static int usb_suspend_interface(struct usb_device *udev,
 
 	if (driver-&gt;suspend) {
 		status = driver-&gt;suspend(intf, msg);
-		if (status &amp;&amp; !(msg.event &amp; PM_EVENT_AUTO))
+		if (status &amp;&amp; !PMSG_IS_AUTO(msg))
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"suspend", status);
 	} else {
@@ -1189,7 +1188,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 			status = usb_suspend_interface(udev, intf, msg);
 
 			/* Ignore errors during system sleep transitions */
-			if (!(msg.event &amp; PM_EVENT_AUTO))
+			if (!PMSG_IS_AUTO(msg))
 				status = 0;
 			if (status != 0)
 				break;
@@ -1199,7 +1198,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 		status = usb_suspend_device(udev, msg);
 
 		/* Again, ignore errors during system sleep transitions */
-		if (!(msg.event &amp; PM_EVENT_AUTO))
+		if (!PMSG_IS_AUTO(msg))
 			status = 0;
 	}
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 8669ba3fe794..da582f4e486b 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1960,7 +1960,7 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 	int		old_state = hcd-&gt;state;
 
 	dev_dbg(&amp;rhdev-&gt;dev, "bus %s%s\n",
-			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "suspend");
+			(PMSG_IS_AUTO(msg) ? "auto-" : ""), "suspend");
 	if (HCD_DEAD(hcd)) {
 		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "suspend");
 		return 0;
@@ -1996,7 +1996,7 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 	int		old_state = hcd-&gt;state;
 
 	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
-			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "resume");
+			(PMSG_IS_AUTO(msg) ? "auto-" : ""), "resume");
 	if (HCD_DEAD(hcd)) {
 		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "resume");
 		return 0;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a428aa080a36..ee50e0bf84e8 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2342,7 +2342,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 			dev_dbg(&amp;udev-&gt;dev, "won't remote wakeup, status %d\n",
 					status);
 			/* bail if autosuspend is requested */
-			if (msg.event &amp; PM_EVENT_AUTO)
+			if (PMSG_IS_AUTO(msg))
 				return status;
 		}
 	}
@@ -2367,12 +2367,12 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 				USB_CTRL_SET_TIMEOUT);
 
 		/* System sleep transitions should never fail */
-		if (!(msg.event &amp; PM_EVENT_AUTO))
+		if (!PMSG_IS_AUTO(msg))
 			status = 0;
 	} else {
 		/* device has up to 10 msec to fully suspend */
 		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
-				(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""));
+				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
 		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		msleep(10);
 	}
@@ -2523,7 +2523,7 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	} else {
 		/* drive resume for at least 20 msec */
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
-				(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""));
+				(PMSG_IS_AUTO(msg) ? "auto-" : ""));
 		msleep(25);
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
@@ -2625,7 +2625,7 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 		udev = hdev-&gt;children [port1-1];
 		if (udev &amp;&amp; udev-&gt;can_submit) {
 			dev_warn(&amp;intf-&gt;dev, "port %d nyet suspended\n", port1);
-			if (msg.event &amp; PM_EVENT_AUTO)
+			if (PMSG_IS_AUTO(msg))
 				return -EBUSY;
 		}
 	}
diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c
index d5d136a53b61..b18179bda0d8 100644
--- a/drivers/usb/serial/sierra.c
+++ b/drivers/usb/serial/sierra.c
@@ -1009,7 +1009,7 @@ static int sierra_suspend(struct usb_serial *serial, pm_message_t message)
 	struct sierra_intf_private *intfdata;
 	int b;
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		intfdata = serial-&gt;private;
 		spin_lock_irq(&amp;intfdata-&gt;susp_lock);
 		b = intfdata-&gt;in_flight;
diff --git a/drivers/usb/serial/usb_wwan.c b/drivers/usb/serial/usb_wwan.c
index e4fad5e643d7..d555ca9567b8 100644
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@ -651,7 +651,7 @@ int usb_wwan_suspend(struct usb_serial *serial, pm_message_t message)
 
 	dbg("%s entered", __func__);
 
-	if (message.event &amp; PM_EVENT_AUTO) {
+	if (PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;intfdata-&gt;susp_lock);
 		b = intfdata-&gt;in_flight;
 		spin_unlock_irq(&amp;intfdata-&gt;susp_lock);
diff --git a/include/linux/pm.h b/include/linux/pm.h
index f7c84c9abd30..18de9f893497 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -366,6 +366,8 @@ extern struct dev_pm_ops generic_subsys_pm_ops;
 #define PMSG_AUTO_RESUME	((struct pm_message) \
 					{ .event = PM_EVENT_AUTO_RESUME, })
 
+#define PMSG_IS_AUTO(msg)	(((msg).event &amp; PM_EVENT_AUTO) != 0)
+
 /**
  * Device run-time power management status.
  *
diff --git a/sound/usb/card.c b/sound/usb/card.c
index 781d9e61adfb..d5754fa5e551 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -628,7 +628,7 @@ static int usb_audio_suspend(struct usb_interface *intf, pm_message_t message)
 	if (chip == (void *)-1L)
 		return 0;
 
-	if (!(message.event &amp; PM_EVENT_AUTO)) {
+	if (!PMSG_IS_AUTO(message)) {
 		snd_power_change_state(chip-&gt;card, SNDRV_CTL_POWER_D3hot);
 		if (!chip-&gt;num_suspended_intf++) {
 			list_for_each(p, &amp;chip-&gt;pcm_list) {</pre><hr><pre>commit e04f5f7e423018bcec84c11af2058cdce87816f3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 19 14:01:23 2011 -0400

    EHCI: fix direction handling for interrupt data toggles
    
    This patch (as1480) fixes a rather obscure bug in ehci-hcd.  The
    qh_update() routine needs to know the number and direction of the
    endpoint corresponding to its QH argument.  The number can be taken
    directly from the QH data structure, but the direction isn't stored
    there.  The direction is taken instead from the first qTD linked to
    the QH.
    
    However, it turns out that for interrupt transfers, qh_update() gets
    called before the qTDs are linked to the QH.  As a result, qh_update()
    computes a bogus direction value, which messes up the endpoint toggle
    handling.  Under the right combination of circumstances this causes
    usb_reset_endpoint() not to work correctly, which causes packets to be
    dropped and communications to fail.
    
    Now, it's silly for the QH structure not to have direct access to all
    the descriptor information for the corresponding endpoint.  Ultimately
    it may get a pointer to the usb_host_endpoint structure; for now,
    adding a copy of the direction flag solves the immediate problem.
    
    This allows the Spyder2 color-calibration system (a low-speed USB
    device that sends all its interrupt data packets with the toggle set
    to 0 and hance requires constant use of usb_reset_endpoint) to work
    when connected through a high-speed hub.  Thanks to Graeme Gill for
    supplying the hardware that allowed me to track down this bug.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Graeme Gill &lt;graeme@argyllcms.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 9bf3c0d983c4..0917e3a32465 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -103,7 +103,7 @@ qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 	if (!(hw-&gt;hw_info1 &amp; cpu_to_hc32(ehci, 1 &lt;&lt; 14))) {
 		unsigned	is_out, epnum;
 
-		is_out = !(qtd-&gt;hw_token &amp; cpu_to_hc32(ehci, 1 &lt;&lt; 8));
+		is_out = qh-&gt;is_out;
 		epnum = (hc32_to_cpup(ehci, &amp;hw-&gt;hw_info1) &gt;&gt; 8) &amp; 0x0f;
 		if (unlikely (!usb_gettoggle (qh-&gt;dev, epnum, is_out))) {
 			hw-&gt;hw_token &amp;= ~cpu_to_hc32(ehci, QTD_TOGGLE);
@@ -946,6 +946,7 @@ qh_make (
 	hw = qh-&gt;hw;
 	hw-&gt;hw_info1 = cpu_to_hc32(ehci, info1);
 	hw-&gt;hw_info2 = cpu_to_hc32(ehci, info2);
+	qh-&gt;is_out = !is_input;
 	usb_settoggle (urb-&gt;dev, usb_pipeendpoint (urb-&gt;pipe), !is_input, 1);
 	qh_refresh (ehci, qh);
 	return qh;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index e4feec3457fb..cc7d337ec355 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -377,6 +377,7 @@ struct ehci_qh {
 #define NO_FRAME ((unsigned short)~0)			/* pick new start */
 
 	struct usb_device	*dev;		/* access to TT */
+	unsigned		is_out:1;	/* bulk or intr OUT */
 	unsigned		clearing_tt:1;	/* Clear-TT-Buf in progress */
 };
 </pre><hr><pre>commit 6ea12a04d295235ed67010a09fdea58c949e3eb0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 15 17:22:15 2011 -0400

    USB: OHCI: fix another regression for NVIDIA controllers
    
    The NVIDIA series of OHCI controllers continues to be troublesome.  A
    few people using the MCP67 chipset have reported that even with the
    most recent kernels, the OHCI controller fails to handle new
    connections and spams the system log with "unable to enumerate USB
    port" messages.  This is different from the other problems previously
    reported for NVIDIA OHCI controllers, although it is probably related.
    
    It turns out that the MCP67 controller does not like to be kept in the
    RESET state very long.  After only a few seconds, it decides not to
    work any more.  This patch (as1479) changes the PCI initialization
    quirk code so that NVIDIA controllers are switched into the SUSPEND
    state after 50 ms of RESET.  With no interrupts enabled and all the
    downstream devices reset, and thus unable to send wakeup requests,
    this should be perfectly safe (even for non-NVIDIA hardware).
    
    The removal code in ohci-hcd hasn't been changed; it will still leave
    the controller in the RESET state.  As a result, if someone unloads
    ohci-hcd and then reloads it, the controller won't work again until
    the system is rebooted.  If anybody complains about this, the removal
    code can be updated similarly.
    
    This fixes Bugzilla #22052.
    
    Tested-by: Larry Finger &lt;Larry.Finger@lwfinger.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index b5a7304fcbef..a9d315906e3d 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -35,6 +35,8 @@
 #define OHCI_INTRSTATUS		0x0c
 #define OHCI_INTRENABLE		0x10
 #define OHCI_INTRDISABLE	0x14
+#define OHCI_FMINTERVAL		0x34
+#define OHCI_HCR		(1 &lt;&lt; 0)	/* host controller reset */
 #define OHCI_OCR		(1 &lt;&lt; 3)	/* ownership change request */
 #define OHCI_CTRL_RWC		(1 &lt;&lt; 9)	/* remote wakeup connected */
 #define OHCI_CTRL_IR		(1 &lt;&lt; 8)	/* interrupt routing */
@@ -497,6 +499,32 @@ static void __devinit quirk_usb_handoff_ohci(struct pci_dev *pdev)
 
 	/* reset controller, preserving RWC (and possibly IR) */
 	writel(control &amp; OHCI_CTRL_MASK, base + OHCI_CONTROL);
+	readl(base + OHCI_CONTROL);
+
+	/* Some NVIDIA controllers stop working if kept in RESET for too long */
+	if (pdev-&gt;vendor == PCI_VENDOR_ID_NVIDIA) {
+		u32 fminterval;
+		int cnt;
+
+		/* drive reset for at least 50 ms (7.1.7.5) */
+		msleep(50);
+
+		/* software reset of the controller, preserving HcFmInterval */
+		fminterval = readl(base + OHCI_FMINTERVAL);
+		writel(OHCI_HCR, base + OHCI_CMDSTATUS);
+
+		/* reset requires max 10 us delay */
+		for (cnt = 30; cnt &gt; 0; --cnt) {	/* ... allow extra time */
+			if ((readl(base + OHCI_CMDSTATUS) &amp; OHCI_HCR) == 0)
+				break;
+			udelay(1);
+		}
+		writel(fminterval, base + OHCI_FMINTERVAL);
+
+		/* Now we're in the SUSPEND state with all devices reset
+		 * and wakeups and interrupts disabled
+		 */
+	}
 
 	/*
 	 * disable interrupts</pre><hr><pre>commit 004c19682884d4f40000ce1ded53f4a1d0b18206
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 5 12:34:05 2011 -0400

    USB: EHCI: go back to using the system clock for QH unlinks
    
    This patch (as1477) fixes a problem affecting a few types of EHCI
    controller.  Contrary to what one might expect, these controllers
    automatically stop their internal frame counter when no ports are
    enabled.  Since ehci-hcd currently relies on the frame counter for
    determining when it should unlink QHs from the async schedule, those
    controllers run into trouble: The frame counter stops and the QHs
    never get unlinked.
    
    Some systems have also experienced other problems traced back to
    commit b963801164618e25fbdc0cd452ce49c3628b46c8 (USB: ehci-hcd unlink
    speedups), which made the original switch from using the system clock
    to using the frame counter.  It never became clear what the reason was
    for these problems, but evidently it is related to use of the frame
    counter.
    
    To fix all these problems, this patch more or less reverts that commit
    and goes back to using the system clock.  But this can't be done
    cleanly because other changes have since been made to the scan_async()
    subroutine.  One of these changes involved the tricky logic that tries
    to avoid rescanning QHs that have already been seen when the scanning
    loop is restarted, which happens whenever an URB is given back.
    Switching back to clock-based unlinks would make this logic even more
    complicated.
    
    Therefore the new code doesn't rescan the entire async list whenever a
    giveback occurs.  Instead it rescans only the current QH and continues
    on from there.  This requires the use of a separate pointer to keep
    track of the next QH to scan, since the current QH may be unlinked
    while the scanning is in progress.  That new pointer must be global,
    so that it can be adjusted forward whenever the _next_ QH gets
    unlinked.  (uhci-hcd uses this same trick.)
    
    Simplification of the scanning loop removes a level of indentation,
    which accounts for the size of the patch.  The amount of code changed
    is relatively small, and it isn't exactly a reversion of the
    b963801164 commit.
    
    This fixes Bugzilla #32432.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@kernel.org&gt;
    Tested-by: Matej Kenda &lt;matejken@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 4ee62bef3723..2902199fa8ff 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -90,7 +90,8 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_FRAMES	5		/* async qh unlink delay */
+#define EHCI_SHRINK_JIFFIES	(DIV_ROUND_UP(HZ, 200) + 1)
+						/* 200-ms async qh unlink delay */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
@@ -148,10 +149,7 @@ timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
 			break;
 		/* case TIMER_ASYNC_SHRINK: */
 		default:
-			/* add a jiffie since we synch against the
-			 * 8 KHz uframe counter.
-			 */
-			t = DIV_ROUND_UP(EHCI_SHRINK_FRAMES * HZ, 1000) + 1;
+			t = EHCI_SHRINK_JIFFIES;
 			break;
 		}
 		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 5d6bc624c961..9bf3c0d983c4 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1231,6 +1231,8 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 	prev-&gt;hw-&gt;hw_next = qh-&gt;hw-&gt;hw_next;
 	prev-&gt;qh_next = qh-&gt;qh_next;
+	if (ehci-&gt;qh_scan_next == qh)
+		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
 	wmb ();
 
 	/* If the controller isn't running, we don't have to wait for it */
@@ -1256,53 +1258,49 @@ static void scan_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
-	ehci-&gt;stamp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
-rescan:
 	stopped = !HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state);
-	qh = ehci-&gt;async-&gt;qh_next.qh;
-	if (likely (qh != NULL)) {
-		do {
-			/* clean any finished work for this qh */
-			if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; (stopped ||
-					qh-&gt;stamp != ehci-&gt;stamp)) {
-				int temp;
-
-				/* unlinks could happen here; completion
-				 * reporting drops the lock.  rescan using
-				 * the latest schedule, but don't rescan
-				 * qhs we already finished (no looping)
-				 * unless the controller is stopped.
-				 */
-				qh = qh_get (qh);
-				qh-&gt;stamp = ehci-&gt;stamp;
-				temp = qh_completions (ehci, qh);
-				if (qh-&gt;needs_rescan)
-					unlink_async(ehci, qh);
-				qh_put (qh);
-				if (temp != 0) {
-					goto rescan;
-				}
-			}
 
-			/* unlink idle entries, reducing DMA usage as well
-			 * as HCD schedule-scanning costs.  delay for any qh
-			 * we just scanned, there's a not-unusual case that it
-			 * doesn't stay idle for long.
-			 * (plus, avoids some kind of re-activation race.)
+	ehci-&gt;qh_scan_next = ehci-&gt;async-&gt;qh_next.qh;
+	while (ehci-&gt;qh_scan_next) {
+		qh = ehci-&gt;qh_scan_next;
+		ehci-&gt;qh_scan_next = qh-&gt;qh_next.qh;
+ rescan:
+		/* clean any finished work for this qh */
+		if (!list_empty(&amp;qh-&gt;qtd_list)) {
+			int temp;
+
+			/*
+			 * Unlinks could happen here; completion reporting
+			 * drops the lock.  That's why ehci-&gt;qh_scan_next
+			 * always holds the next qh to scan; if the next qh
+			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted
+			 * in start_unlink_async().
 			 */
-			if (list_empty(&amp;qh-&gt;qtd_list)
-					&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
-				if (!ehci-&gt;reclaim &amp;&amp; (stopped ||
-					((ehci-&gt;stamp - qh-&gt;stamp) &amp; 0x1fff)
-						&gt;= EHCI_SHRINK_FRAMES * 8))
-					start_unlink_async(ehci, qh);
-				else
-					action = TIMER_ASYNC_SHRINK;
-			}
+			qh = qh_get(qh);
+			temp = qh_completions(ehci, qh);
+			if (qh-&gt;needs_rescan)
+				unlink_async(ehci, qh);
+			qh-&gt;unlink_time = jiffies + EHCI_SHRINK_JIFFIES;
+			qh_put(qh);
+			if (temp != 0)
+				goto rescan;
+		}
 
-			qh = qh-&gt;qh_next.qh;
-		} while (qh);
+		/* unlink idle entries, reducing DMA usage as well
+		 * as HCD schedule-scanning costs.  delay for any qh
+		 * we just scanned, there's a not-unusual case that it
+		 * doesn't stay idle for long.
+		 * (plus, avoids some kind of re-activation race.)
+		 */
+		if (list_empty(&amp;qh-&gt;qtd_list)
+				&amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED) {
+			if (!ehci-&gt;reclaim &amp;&amp; (stopped ||
+					time_after_eq(jiffies, qh-&gt;unlink_time)))
+				start_unlink_async(ehci, qh);
+			else
+				action = TIMER_ASYNC_SHRINK;
+		}
 	}
 	if (action == TIMER_ASYNC_SHRINK)
 		timer_action (ehci, TIMER_ASYNC_SHRINK);
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index fa3129fe1ee0..e4feec3457fb 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -75,6 +75,7 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async;
 	struct ehci_qh		*dummy;		/* For AMD quirk use */
 	struct ehci_qh		*reclaim;
+	struct ehci_qh		*qh_scan_next;
 	unsigned		scanning : 1;
 
 	/* periodic schedule support */
@@ -119,7 +120,6 @@ struct ehci_hcd {			/* one per controller */
 	struct timer_list	iaa_watchdog;
 	struct timer_list	watchdog;
 	unsigned long		actions;
-	unsigned		stamp;
 	unsigned		periodic_stamp;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
@@ -345,6 +345,7 @@ struct ehci_qh {
 	struct ehci_qh		*reclaim;	/* next to reclaim */
 
 	struct ehci_hcd		*ehci;
+	unsigned long		unlink_time;
 
 	/*
 	 * Do NOT use atomic operations for QH refcounting. On some CPUs</pre><hr><pre>commit ca5c485f55d326d9a23e4badd05890148aa53f74
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 6 17:03:45 2011 -0400

    USB: additional regression fix for device removal
    
    Commit e534c5b831c8b8e9f5edee5c8a37753c808b80dc (USB: fix regression
    occurring during device removal) didn't go far enough.  It failed to
    take into account that when a driver claims multiple interfaces, it may
    release them all at the same time.  As a result, some interfaces can
    get released before they are unregistered, and we deadlock trying to
    acquire the bandwidth_mutex that we already own.
    
    This patch (asl478) handles this case by setting the "unregistering"
    flag on all the interfaces before removing any of them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Tested-by: Éric Piel &lt;eric.piel@tremplin-utc.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index e0719b4ee189..0b5ec234c787 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1147,6 +1147,14 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 	 * any drivers bound to them (a key side effect)
 	 */
 	if (dev-&gt;actconfig) {
+		/*
+		 * FIXME: In order to avoid self-deadlock involving the
+		 * bandwidth_mutex, we have to mark all the interfaces
+		 * before unregistering any of them.
+		 */
+		for (i = 0; i &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces; i++)
+			dev-&gt;actconfig-&gt;interface[i]-&gt;unregistering = 1;
+
 		for (i = 0; i &lt; dev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			struct usb_interface	*interface;
 
@@ -1156,7 +1164,6 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 				continue;
 			dev_dbg(&amp;dev-&gt;dev, "unregistering interface %s\n",
 				dev_name(&amp;interface-&gt;dev));
-			interface-&gt;unregistering = 1;
 			remove_intf_ep_devs(interface);
 			device_del(&amp;interface-&gt;dev);
 		}</pre><hr><pre>commit 69c843b45eb3b8f267019e6a05860c9c48337419
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 6 10:52:23 2011 +0200

    PM / Runtime: Prevent runtime_resume from racing with probe
    
    This patch (as1475) adds device_lock() and device_unlock() calls to
    the store methods for the power/control and power/autosuspend_delay_ms
    sysfs attribute files.  We don't want badly timed writes to these
    files to cause runtime_resume callbacks to occur while a driver is
    being probed for a device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/sysfs.c b/drivers/base/power/sysfs.c
index a9f5b8979611..942d6a7c9ae1 100644
--- a/drivers/base/power/sysfs.c
+++ b/drivers/base/power/sysfs.c
@@ -116,12 +116,14 @@ static ssize_t control_store(struct device * dev, struct device_attribute *attr,
 	cp = memchr(buf, '\n', n);
 	if (cp)
 		len = cp - buf;
+	device_lock(dev);
 	if (len == sizeof ctrl_auto - 1 &amp;&amp; strncmp(buf, ctrl_auto, len) == 0)
 		pm_runtime_allow(dev);
 	else if (len == sizeof ctrl_on - 1 &amp;&amp; strncmp(buf, ctrl_on, len) == 0)
 		pm_runtime_forbid(dev);
 	else
-		return -EINVAL;
+		n = -EINVAL;
+	device_unlock(dev);
 	return n;
 }
 
@@ -205,7 +207,9 @@ static ssize_t autosuspend_delay_ms_store(struct device *dev,
 	if (strict_strtol(buf, 10, &amp;delay) != 0 || delay != (int) delay)
 		return -EINVAL;
 
+	device_lock(dev);
 	pm_runtime_set_autosuspend_delay(dev, delay);
+	device_unlock(dev);
 	return n;
 }
 </pre><hr><pre>commit e534c5b831c8b8e9f5edee5c8a37753c808b80dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 1 16:43:02 2011 -0400

    USB: fix regression occurring during device removal
    
    This patch (as1476) fixes a regression introduced by
    fccf4e86200b8f5edd9a65da26f150e32ba79808 (USB: Free bandwidth when
    usb_disable_device is called).  usb_disconnect() grabs the
    bandwidth_mutex before calling usb_disable_device(), which calls down
    indirectly to usb_set_interface(), which tries to acquire the
    bandwidth_mutex.
    
    The fix causes usb_set_interface() to return early when it is called
    for an interface that has already been unregistered, which is what
    happens in usb_disable_device().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 64c7ab4702df..e0719b4ee189 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1286,6 +1286,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 			interface);
 		return -EINVAL;
 	}
+	if (iface-&gt;unregistering)
+		return -ENODEV;
 
 	alt = usb_altnum_to_altsetting(iface, alternate);
 	if (!alt) {</pre><hr><pre>commit 6d0e0e84f66d32c33511984dd3badd32364b863c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jun 18 22:42:09 2011 +0200

    PM: Fix async resume following suspend failure
    
    The PM core doesn't handle suspend failures correctly when it comes to
    asynchronously suspended devices.  These devices are moved onto the
    dpm_suspended_list as soon as the corresponding async thread is
    started up, and they remain on the list even if they fail to suspend
    or the sleep transition is cancelled before they get suspended.  As a
    result, when the PM core unwinds the transition, it tries to resume
    the devices even though they were never suspended.
    
    This patch (as1474) fixes the problem by adding a new "is_suspended"
    flag to dev_pm_info.  Devices are resumed only if the flag is set.
    
    [rjw:
     * Moved the dev-&gt;power.is_suspended check into device_resume(),
       because we need to complete dev-&gt;power.completion and clear
       dev-&gt;power.is_prepared too for devices whose
       dev-&gt;power.is_suspended flags are unset.
     * Fixed __device_suspend() to avoid setting dev-&gt;power.is_suspended
       if async_error is different from zero.]
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Cc: stable@kernel.org

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index bf5a59ac1957..06f09bf89cb2 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -58,6 +58,7 @@ static int async_error;
 void device_pm_init(struct device *dev)
 {
 	dev-&gt;power.is_prepared = false;
+	dev-&gt;power.is_suspended = false;
 	init_completion(&amp;dev-&gt;power.completion);
 	complete_all(&amp;dev-&gt;power.completion);
 	dev-&gt;power.wakeup = NULL;
@@ -517,6 +518,9 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	 */
 	dev-&gt;power.is_prepared = false;
 
+	if (!dev-&gt;power.is_suspended)
+		goto Unlock;
+
 	if (dev-&gt;pwr_domain) {
 		pm_dev_dbg(dev, state, "power domain ");
 		error = pm_op(dev, &amp;dev-&gt;pwr_domain-&gt;ops, state);
@@ -552,6 +556,9 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	}
 
  End:
+	dev-&gt;power.is_suspended = false;
+
+ Unlock:
 	device_unlock(dev);
 	complete_all(&amp;dev-&gt;power.completion);
 
@@ -839,11 +846,11 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	device_lock(dev);
 
 	if (async_error)
-		goto End;
+		goto Unlock;
 
 	if (pm_wakeup_pending()) {
 		async_error = -EBUSY;
-		goto End;
+		goto Unlock;
 	}
 
 	if (dev-&gt;pwr_domain) {
@@ -881,6 +888,9 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	}
 
  End:
+	dev-&gt;power.is_suspended = !error;
+
+ Unlock:
 	device_unlock(dev);
 	complete_all(&amp;dev-&gt;power.completion);
 
diff --git a/include/linux/pm.h b/include/linux/pm.h
index cc536bd80984..411e4f4be52b 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -426,6 +426,7 @@ struct dev_pm_info {
 	unsigned int		can_wakeup:1;
 	unsigned int		async_suspend:1;
 	bool			is_prepared:1;	/* Owned by the PM core */
+	bool			is_suspended:1;	/* Ditto */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;</pre><hr><pre>commit f76b168b6f117a49d36307053e1acbe30580ea5b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jun 18 20:22:23 2011 +0200

    PM: Rename dev_pm_info.in_suspend to is_prepared
    
    This patch (as1473) renames the "in_suspend" field in struct
    dev_pm_info to "is_prepared", in preparation for an upcoming change.
    The new name is more descriptive of what the field really means.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Cc: stable@kernel.org

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index aa6320207745..bf5a59ac1957 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -57,7 +57,7 @@ static int async_error;
  */
 void device_pm_init(struct device *dev)
 {
-	dev-&gt;power.in_suspend = false;
+	dev-&gt;power.is_prepared = false;
 	init_completion(&amp;dev-&gt;power.completion);
 	complete_all(&amp;dev-&gt;power.completion);
 	dev-&gt;power.wakeup = NULL;
@@ -91,7 +91,7 @@ void device_pm_add(struct device *dev)
 	pr_debug("PM: Adding info for %s:%s\n",
 		 dev-&gt;bus ? dev-&gt;bus-&gt;name : "No Bus", dev_name(dev));
 	mutex_lock(&amp;dpm_list_mtx);
-	if (dev-&gt;parent &amp;&amp; dev-&gt;parent-&gt;power.in_suspend)
+	if (dev-&gt;parent &amp;&amp; dev-&gt;parent-&gt;power.is_prepared)
 		dev_warn(dev, "parent %s should not be sleeping\n",
 			dev_name(dev-&gt;parent));
 	list_add_tail(&amp;dev-&gt;power.entry, &amp;dpm_list);
@@ -511,7 +511,11 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	dpm_wait(dev-&gt;parent, async);
 	device_lock(dev);
 
-	dev-&gt;power.in_suspend = false;
+	/*
+	 * This is a fib.  But we'll allow new children to be added below
+	 * a resumed device, even if the device hasn't been completed yet.
+	 */
+	dev-&gt;power.is_prepared = false;
 
 	if (dev-&gt;pwr_domain) {
 		pm_dev_dbg(dev, state, "power domain ");
@@ -670,7 +674,7 @@ void dpm_complete(pm_message_t state)
 		struct device *dev = to_device(dpm_prepared_list.prev);
 
 		get_device(dev);
-		dev-&gt;power.in_suspend = false;
+		dev-&gt;power.is_prepared = false;
 		list_move(&amp;dev-&gt;power.entry, &amp;list);
 		mutex_unlock(&amp;dpm_list_mtx);
 
@@ -1042,7 +1046,7 @@ int dpm_prepare(pm_message_t state)
 			put_device(dev);
 			break;
 		}
-		dev-&gt;power.in_suspend = true;
+		dev-&gt;power.is_prepared = true;
 		if (!list_empty(&amp;dev-&gt;power.entry))
 			list_move_tail(&amp;dev-&gt;power.entry, &amp;dpm_prepared_list);
 		put_device(dev);
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index e35a17687c05..aa3cc465a601 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -375,7 +375,7 @@ static int usb_unbind_interface(struct device *dev)
 		 * Just re-enable it without affecting the endpoint toggles.
 		 */
 		usb_enable_interface(udev, intf, false);
-	} else if (!error &amp;&amp; !intf-&gt;dev.power.in_suspend) {
+	} else if (!error &amp;&amp; !intf-&gt;dev.power.is_prepared) {
 		r = usb_set_interface(udev, intf-&gt;altsetting[0].
 				desc.bInterfaceNumber, 0);
 		if (r &lt; 0)
@@ -960,7 +960,7 @@ void usb_rebind_intf(struct usb_interface *intf)
 	}
 
 	/* Try to rebind the interface */
-	if (!intf-&gt;dev.power.in_suspend) {
+	if (!intf-&gt;dev.power.is_prepared) {
 		intf-&gt;needs_binding = 0;
 		rc = device_attach(&amp;intf-&gt;dev);
 		if (rc &lt; 0)
@@ -1107,7 +1107,7 @@ static int usb_resume_interface(struct usb_device *udev,
 	if (intf-&gt;condition == USB_INTERFACE_UNBOUND) {
 
 		/* Carry out a deferred switch to altsetting 0 */
-		if (intf-&gt;needs_altsetting0 &amp;&amp; !intf-&gt;dev.power.in_suspend) {
+		if (intf-&gt;needs_altsetting0 &amp;&amp; !intf-&gt;dev.power.is_prepared) {
 			usb_set_interface(udev, intf-&gt;altsetting[0].
 					desc.bInterfaceNumber, 0);
 			intf-&gt;needs_altsetting0 = 0;
diff --git a/include/linux/device.h b/include/linux/device.h
index c66111affca9..553fd37b173b 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -654,13 +654,13 @@ static inline int device_is_registered(struct device *dev)
 
 static inline void device_enable_async_suspend(struct device *dev)
 {
-	if (!dev-&gt;power.in_suspend)
+	if (!dev-&gt;power.is_prepared)
 		dev-&gt;power.async_suspend = true;
 }
 
 static inline void device_disable_async_suspend(struct device *dev)
 {
-	if (!dev-&gt;power.in_suspend)
+	if (!dev-&gt;power.is_prepared)
 		dev-&gt;power.async_suspend = false;
 }
 
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 3160648ccdda..cc536bd80984 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -425,7 +425,7 @@ struct dev_pm_info {
 	pm_message_t		power_state;
 	unsigned int		can_wakeup:1;
 	unsigned int		async_suspend:1;
-	unsigned int		in_suspend:1;	/* Owned by the PM core */
+	bool			is_prepared:1;	/* Owned by the PM core */
 	spinlock_t		lock;
 #ifdef CONFIG_PM_SLEEP
 	struct list_head	entry;</pre>
    <div class="pagination">
        <a href='2_55.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><span>[56]</span><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_57.html'>Next&gt;&gt;</a>
    <div>
</body>
