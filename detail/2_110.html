<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_109.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><span>[110]</span><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_111.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit bf87ce5a06ed2cb13ad04f065706cf36ab021549
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 5 16:07:44 2007 -0400

    USB: remove unneeded WARN_ON
    
    This patch (as883) removes an out-of-date WARN_ON from the main HCD
    endpoint-disable routine.  The warning is triggered whenever an
    endpoint is disabled while the root hub is suspended.  In the past
    that may not have been legal, but it definitely is legal now.  Merely
    unbinding a USB driver will do it.
    
    Furthermore, I've never seen any occurrences of this warning that
    really did signal an actual bug or error condition.  At this point it
    has outlived its purpose.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 40cf882293e6..9ad2970a095d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1175,10 +1175,6 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	struct urb		*urb;
 
 	hcd = bus_to_hcd(udev-&gt;bus);
-
-	WARN_ON (!HC_IS_RUNNING (hcd-&gt;state) &amp;&amp; hcd-&gt;state != HC_STATE_HALT &amp;&amp;
-			udev-&gt;state != USB_STATE_NOTATTACHED);
-
 	local_irq_disable ();
 
 	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */</pre><hr><pre>commit ef7f6c7084b333c7524dcd297e0578d43733a2a2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 5 16:03:49 2007 -0400

    USB: more autosuspend timer stuff
    
    This patch (as879) ties up some loose ends from an earlier patch.
    These are things I didn't think to include at the time but which
    clearly belonged there.
    
            If an autosuspend fails because driver activity races with
            the autosuspend call, restart the autosuspend timer.
    
            When a device is resumed by an external request, it counts
            as device activity and should update the last_busy time so
            that the next autoresume won't occur immediately.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index b9f7f90aef82..2619986e5300 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -983,7 +983,10 @@ static int autosuspend_check(struct usb_device *udev)
 
 #else
 
-#define autosuspend_check(udev)		0
+static inline int autosuspend_check(struct usb_device *udev)
+{
+	return 0;
+}
 
 #endif	/* CONFIG_USB_SUSPEND */
 
@@ -1041,7 +1044,6 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 		if (status &lt; 0)
 			goto done;
 	}
-	cancel_delayed_work(&amp;udev-&gt;autosuspend);
 
 	/* Suspend all the interfaces and then udev itself */
 	if (udev-&gt;actconfig) {
@@ -1062,9 +1064,16 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 			usb_resume_interface(intf);
 		}
 
+		/* Try another autosuspend when the interfaces aren't busy */
+		if (udev-&gt;auto_pm)
+			autosuspend_check(udev);
+
 	/* If the suspend succeeded, propagate it up the tree */
-	} else if (parent)
-		usb_autosuspend_device(parent);
+	} else {
+		cancel_delayed_work(&amp;udev-&gt;autosuspend);
+		if (parent)
+			usb_autosuspend_device(parent);
+	}
 
  done:
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
@@ -1475,6 +1484,7 @@ int usb_external_resume_device(struct usb_device *udev)
 	usb_pm_lock(udev);
 	udev-&gt;auto_pm = 0;
 	status = usb_resume_both(udev);
+	udev-&gt;last_busy = jiffies;
 	usb_pm_unlock(udev);
 
 	/* Now that the device is awake, we can start trying to autosuspend</pre><hr><pre>commit 4fe5354f61cad4c0550285283c83c66c070c198e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 5 16:06:53 2007 -0400

    EHCI: fix problem with BIOS handoff
    
    This patch (as882) fixes a problem with the EHCI BIOS handoff.  On my
    machine, the BIOS configures the controller and the handoff fails,
    leaving the controller configured.  During resume-from-disk, this
    confuses ehci-hcd into thinking that the controller has not been
    tampered with.
    
    The problem is fixed by turning off the Configured Flag whenever a
    BIOS handoff is attempted, whether it succeeds or not.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 20861650905e..c225159ca3d3 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -44,6 +44,7 @@
 #define EHCI_USBSTS		4		/* status register */
 #define EHCI_USBSTS_HALTED	(1 &lt;&lt; 12)	/* HCHalted bit */
 #define EHCI_USBINTR		8		/* interrupt register */
+#define EHCI_CONFIGFLAG		0x40		/* configured flag register */
 #define EHCI_USBLEGSUP		0		/* legacy support register */
 #define EHCI_USBLEGSUP_BIOS	(1 &lt;&lt; 16)	/* BIOS semaphore */
 #define EHCI_USBLEGSUP_OS	(1 &lt;&lt; 24)	/* OS semaphore */
@@ -216,6 +217,7 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 	u32	hcc_params, val;
 	u8	offset, cap_length;
 	int	count = 256/4;
+	int	tried_handoff = 0;
 
 	if (!mmio_resource_enabled(pdev, 0))
 		return;
@@ -273,6 +275,7 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 			 */
 			msec = 5000;
 			while ((cap &amp; EHCI_USBLEGSUP_BIOS) &amp;&amp; (msec &gt; 0)) {
+				tried_handoff = 1;
 				msleep(10);
 				msec -= 10;
 				pci_read_config_dword(pdev, offset, &amp;cap);
@@ -292,6 +295,12 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 			pci_write_config_dword(pdev,
 					offset + EHCI_USBLEGCTLSTS,
 					0);
+
+			/* If the BIOS ever owned the controller then we
+			 * can't expect any power sessions to remain intact.
+			 */
+			if (tried_handoff)
+				writel(0, op_reg_base + EHCI_CONFIGFLAG);
 			break;
 		case 0:			/* illegal reserved capability */
 			cap = 0;</pre><hr><pre>commit 09ff92fea2890c697a36d8b26f5a3ea725ef8fb4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 21 09:55:04 2007 -0400

    [SCSI] sd: fix refcounting regression in suspend/resume routines
    
    This patch (as909) fixes a couple of refcounting errors in the sd
    driver's suspend and resume methods.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 00e46662296f..3d8c9cb24f91 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1789,7 +1789,7 @@ static void sd_shutdown(struct device *dev)
 static int sd_suspend(struct device *dev, pm_message_t mesg)
 {
 	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
-	int ret;
+	int ret = 0;
 
 	if (!sdkp)
 		return 0;	/* this can happen */
@@ -1798,30 +1798,34 @@ static int sd_suspend(struct device *dev, pm_message_t mesg)
 		sd_printk(KERN_NOTICE, sdkp, "Synchronizing SCSI cache\n");
 		ret = sd_sync_cache(sdkp);
 		if (ret)
-			return ret;
+			goto done;
 	}
 
 	if (mesg.event == PM_EVENT_SUSPEND &amp;&amp;
 	    sdkp-&gt;device-&gt;manage_start_stop) {
 		sd_printk(KERN_NOTICE, sdkp, "Stopping disk\n");
 		ret = sd_start_stop_device(sdkp, 0);
-		if (ret)
-			return ret;
 	}
 
-	return 0;
+done:
+	scsi_disk_put(sdkp);
+	return ret;
 }
 
 static int sd_resume(struct device *dev)
 {
 	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
+	int ret = 0;
 
 	if (!sdkp-&gt;device-&gt;manage_start_stop)
-		return 0;
+		goto done;
 
 	sd_printk(KERN_NOTICE, sdkp, "Starting disk\n");
+	ret = sd_start_stop_device(sdkp, 1);
 
-	return sd_start_stop_device(sdkp, 1);
+done:
+	scsi_disk_put(sdkp);
+	return ret;
 }
 
 /**</pre><hr><pre>commit 83f7d958eab2fbc6b159ee92bf1493924e1d0f72
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 25 15:15:43 2007 -0400

    USB: add "busnum" attribute for USB devices
    
    This patch (as903) adds a "busnum" sysfs attribute for USB devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 2ea47a38aefa..e7c982377488 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -117,6 +117,16 @@ show_speed(struct device *dev, struct device_attribute *attr, char *buf)
 }
 static DEVICE_ATTR(speed, S_IRUGO, show_speed, NULL);
 
+static ssize_t
+show_busnum(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev;
+
+	udev = to_usb_device(dev);
+	return sprintf(buf, "%d\n", udev-&gt;bus-&gt;busnum);
+}
+static DEVICE_ATTR(busnum, S_IRUGO, show_busnum, NULL);
+
 static ssize_t
 show_devnum(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -347,6 +357,7 @@ static struct attribute *dev_attrs[] = {
 	&amp;dev_attr_bNumConfigurations.attr,
 	&amp;dev_attr_bMaxPacketSize0.attr,
 	&amp;dev_attr_speed.attr,
+	&amp;dev_attr_busnum.attr,
 	&amp;dev_attr_devnum.attr,
 	&amp;dev_attr_version.attr,
 	&amp;dev_attr_maxchild.attr,</pre><hr><pre>commit 8c9862e512f59ae3f41f83c109be12f93e37bb2d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 11 12:06:16 2007 -0400

    USB: fix signed jiffies issue in autosuspend logic
    
    This patch (as897) changes the autosuspend timer code to use the
    standard types and macros in dealing with jiffies values.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 631f30582481..b9f7f90aef82 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -932,7 +932,7 @@ static int autosuspend_check(struct usb_device *udev)
 {
 	int			i;
 	struct usb_interface	*intf;
-	long			suspend_time;
+	unsigned long		suspend_time;
 
 	/* For autosuspend, fail fast if anything is in use or autosuspend
 	 * is disabled.  Also fail if any interfaces require remote wakeup
@@ -964,11 +964,18 @@ static int autosuspend_check(struct usb_device *udev)
 	/* If everything is okay but the device hasn't been idle for long
 	 * enough, queue a delayed autosuspend request.
 	 */
-	suspend_time -= jiffies;
-	if (suspend_time &gt; 0) {
-		if (!timer_pending(&amp;udev-&gt;autosuspend.timer))
+	if (time_after(suspend_time, jiffies)) {
+		if (!timer_pending(&amp;udev-&gt;autosuspend.timer)) {
+
+			/* The value of jiffies may change between the
+			 * time_after() comparison above and the subtraction
+			 * below.  That's okay; the system behaves sanely
+			 * when a timer is registered for the present moment
+			 * or for the past.
+			 */
 			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-					suspend_time);
+					suspend_time - jiffies);
+			}
 		return -EAGAIN;
 	}
 	return 0;</pre><hr><pre>commit 1941044aa9632aa8debbb94a3c8a5ed0ebddade8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 27 13:33:59 2007 -0400

    USB: add "last_busy" field for use in autosuspend
    
    This patch (as877) adds a "last_busy" field to struct usb_device, for
    use by the autosuspend framework.  Now if an autosuspend call comes at
    a time when the device isn't busy but hasn't yet been idle for long
    enough, the timer can be set to exactly the desired value.  And we
    will be ready to handle things like HID drivers, which can't maintain
    a useful usage count and must rely on the time-of-last-use to decide
    when to autosuspend.
    
    The patch also makes some related minor improvements:
    
            Move the calls to the autosuspend condition-checking routine
            into usb_suspend_both(), which is the only place where it
            really matters.
    
            If the autosuspend timer is already running, don't stop
            and restart it.
    
            Replace immediate returns with gotos so that the optional
            debugging ouput won't be bypassed.
    
            If autoresume is disabled but the device is already awake,
            don't return an error for an autoresume call.
    
            Don't try to autoresume a device if it isn't suspended.
            (Yes, this undercuts the previous change -- so sue me.)
    
            Don't duplicate existing code in the autosuspend work routine.
    
            Fix the kerneldoc in usb_autopm_put_interface(): If an
            autoresume call fails, the usage counter is left unchanged.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 593386eb974d..631f30582481 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -932,6 +932,7 @@ static int autosuspend_check(struct usb_device *udev)
 {
 	int			i;
 	struct usb_interface	*intf;
+	long			suspend_time;
 
 	/* For autosuspend, fail fast if anything is in use or autosuspend
 	 * is disabled.  Also fail if any interfaces require remote wakeup
@@ -943,6 +944,7 @@ static int autosuspend_check(struct usb_device *udev)
 	if (udev-&gt;autosuspend_delay &lt; 0 || udev-&gt;autosuspend_disabled)
 		return -EPERM;
 
+	suspend_time = udev-&gt;last_busy + udev-&gt;autosuspend_delay;
 	if (udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
@@ -958,6 +960,17 @@ static int autosuspend_check(struct usb_device *udev)
 			}
 		}
 	}
+
+	/* If everything is okay but the device hasn't been idle for long
+	 * enough, queue a delayed autosuspend request.
+	 */
+	suspend_time -= jiffies;
+	if (suspend_time &gt; 0) {
+		if (!timer_pending(&amp;udev-&gt;autosuspend.timer))
+			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
+					suspend_time);
+		return -EAGAIN;
+	}
 	return 0;
 }
 
@@ -1010,19 +1023,18 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	struct usb_interface	*intf;
 	struct usb_device	*parent = udev-&gt;parent;
 
-	cancel_delayed_work(&amp;udev-&gt;autosuspend);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
-	if (udev-&gt;state == USB_STATE_SUSPENDED)
-		return 0;
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			udev-&gt;state == USB_STATE_SUSPENDED)
+		goto done;
 
 	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 
 	if (udev-&gt;auto_pm) {
 		status = autosuspend_check(udev);
 		if (status &lt; 0)
-			return status;
+			goto done;
 	}
+	cancel_delayed_work(&amp;udev-&gt;autosuspend);
 
 	/* Suspend all the interfaces and then udev itself */
 	if (udev-&gt;actconfig) {
@@ -1047,6 +1059,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	} else if (parent)
 		usb_autosuspend_device(parent);
 
+ done:
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
@@ -1086,14 +1099,18 @@ static int usb_resume_both(struct usb_device *udev)
 	struct usb_interface	*intf;
 	struct usb_device	*parent = udev-&gt;parent;
 
-	if (udev-&gt;auto_pm &amp;&amp; udev-&gt;autoresume_disabled)
-		return -EPERM;
 	cancel_delayed_work(&amp;udev-&gt;autosuspend);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return -ENODEV;
+	if (udev-&gt;state == USB_STATE_NOTATTACHED) {
+		status = -ENODEV;
+		goto done;
+	}
 
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
+		if (udev-&gt;auto_pm &amp;&amp; udev-&gt;autoresume_disabled) {
+			status = -EPERM;
+			goto done;
+		}
 		if (parent) {
 			status = usb_autoresume_device(parent);
 			if (status == 0) {
@@ -1139,24 +1156,13 @@ static int usb_resume_both(struct usb_device *udev)
 		}
 	}
 
+ done:
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
 
 #ifdef CONFIG_USB_SUSPEND
 
-/* usb_autosuspend_work - callback routine to autosuspend a USB device */
-void usb_autosuspend_work(struct work_struct *work)
-{
-	struct usb_device *udev =
-		container_of(work, struct usb_device, autosuspend.work);
-
-	usb_pm_lock(udev);
-	udev-&gt;auto_pm = 1;
-	usb_suspend_both(udev, PMSG_SUSPEND);
-	usb_pm_unlock(udev);
-}
-
 /* Internal routine to adjust a device's usage counter and change
  * its autosuspend state.
  */
@@ -1165,20 +1171,34 @@ static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
 	int	status = 0;
 
 	usb_pm_lock(udev);
+	udev-&gt;auto_pm = 1;
 	udev-&gt;pm_usage_cnt += inc_usage_cnt;
 	WARN_ON(udev-&gt;pm_usage_cnt &lt; 0);
 	if (inc_usage_cnt &gt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &gt; 0) {
-		udev-&gt;auto_pm = 1;
-		status = usb_resume_both(udev);
+		if (udev-&gt;state == USB_STATE_SUSPENDED)
+			status = usb_resume_both(udev);
 		if (status != 0)
 			udev-&gt;pm_usage_cnt -= inc_usage_cnt;
-	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
-		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				udev-&gt;autosuspend_delay);
+		else if (inc_usage_cnt)
+			udev-&gt;last_busy = jiffies;
+	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &lt;= 0) {
+		if (inc_usage_cnt)
+			udev-&gt;last_busy = jiffies;
+		status = usb_suspend_both(udev, PMSG_SUSPEND);
+	}
 	usb_pm_unlock(udev);
 	return status;
 }
 
+/* usb_autosuspend_work - callback routine to autosuspend a USB device */
+void usb_autosuspend_work(struct work_struct *work)
+{
+	struct usb_device *udev =
+		container_of(work, struct usb_device, autosuspend.work);
+
+	usb_autopm_do_device(udev, 0);
+}
+
 /**
  * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces
  * @udev: the usb_device to autosuspend
@@ -1270,15 +1290,20 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
 		status = -ENODEV;
 	else {
+		udev-&gt;auto_pm = 1;
 		intf-&gt;pm_usage_cnt += inc_usage_cnt;
 		if (inc_usage_cnt &gt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &gt; 0) {
-			udev-&gt;auto_pm = 1;
-			status = usb_resume_both(udev);
+			if (udev-&gt;state == USB_STATE_SUSPENDED)
+				status = usb_resume_both(udev);
 			if (status != 0)
 				intf-&gt;pm_usage_cnt -= inc_usage_cnt;
-		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
-			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-					udev-&gt;autosuspend_delay);
+			else if (inc_usage_cnt)
+				udev-&gt;last_busy = jiffies;
+		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &lt;= 0) {
+			if (inc_usage_cnt)
+				udev-&gt;last_busy = jiffies;
+			status = usb_suspend_both(udev, PMSG_SUSPEND);
+		}
 	}
 	usb_pm_unlock(udev);
 	return status;
@@ -1337,11 +1362,14 @@ EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
  * or @intf is unbound.  A typical example would be a character-device
  * driver when its device file is opened.
  *
- * The routine increments @intf's usage counter.  So long as the counter
- * is greater than 0, autosuspend will not be allowed for @intf or its
- * usb_device.  When the driver is finished using @intf it should call
- * usb_autopm_put_interface() to decrement the usage counter and queue
- * a delayed autosuspend request (if the counter is &lt;= 0).
+ *
+ * The routine increments @intf's usage counter.  (However if the
+ * autoresume fails then the counter is re-decremented.)  So long as the
+ * counter is greater than 0, autosuspend will not be allowed for @intf
+ * or its usb_device.  When the driver is finished using @intf it should
+ * call usb_autopm_put_interface() to decrement the usage counter and
+ * queue a delayed autosuspend request (if the counter is &lt;= 0).
+ *
  *
  * Note that @intf-&gt;pm_usage_cnt is owned by the interface driver.  The
  * core will not change its value other than the increment and decrement
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 8bc3ce6d9666..40cf882293e6 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1306,6 +1306,7 @@ static void hcd_resume_work(struct work_struct *work)
 	struct usb_device *udev = hcd-&gt;self.root_hub;
 
 	usb_lock_device(udev);
+	usb_mark_last_busy(udev);
 	usb_external_resume_device(udev);
 	usb_unlock_device(udev);
 }
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2a0b15e42bc7..bde29ab2b504 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1859,6 +1859,7 @@ static int remote_wakeup(struct usb_device *udev)
 	usb_lock_device(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
+		usb_mark_last_busy(udev);
 		status = usb_external_resume_device(udev);
 	}
 	usb_unlock_device(udev);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index f9e4445d5b53..cfbd2bb8fa2c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -398,6 +398,7 @@ struct usb_device {
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
+	unsigned long last_busy;	/* time of last use */
 	int autosuspend_delay;		/* in jiffies */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
@@ -443,6 +444,11 @@ static inline void usb_autopm_disable(struct usb_interface *intf)
 	usb_autopm_set_interface(intf);
 }
 
+static inline void usb_mark_last_busy(struct usb_device *udev)
+{
+	udev-&gt;last_busy = jiffies;
+}
+
 #else
 
 static inline int usb_autopm_set_interface(struct usb_interface *intf)
@@ -457,6 +463,8 @@ static inline void usb_autopm_enable(struct usb_interface *intf)
 { }
 static inline void usb_autopm_disable(struct usb_interface *intf)
 { }
+static inline void usb_mark_last_busy(struct usb_device *udev)
+{ }
 #endif
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit 2add5229d77a3de08015feef437653e02372162f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 20 14:59:39 2007 -0400

    USB: add power/level sysfs attribute
    
    This patch (as874) adds another piece to the user-visible part of the
    USB autosuspend interface.  The new power/level sysfs attribute allows
    users to force the device on (with autosuspend off), force the device
    to sleep (with autoresume off), or return to normal automatic operation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/ABI/testing/sysfs-bus-usb b/Documentation/ABI/testing/sysfs-bus-usb
index 00a84326325f..f9937add033d 100644
--- a/Documentation/ABI/testing/sysfs-bus-usb
+++ b/Documentation/ABI/testing/sysfs-bus-usb
@@ -13,3 +13,29 @@ Description:
 
 		The autosuspend delay for newly-created devices is set to
 		the value of the usbcore.autosuspend module parameter.
+
+What:		/sys/bus/usb/devices/.../power/level
+Date:		March 2007
+KernelVersion:	2.6.21
+Contact:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
+Description:
+		Each USB device directory will contain a file named
+		power/level.  This file holds a power-level setting for
+		the device, one of "on", "auto", or "suspend".
+
+		"on" means that the device is not allowed to autosuspend,
+		although normal suspends for system sleep will still
+		be honored.  "auto" means the device will autosuspend
+		and autoresume in the usual manner, according to the
+		capabilities of its driver.  "suspend" means the device
+		is forced into a suspended state and it will not autoresume
+		in response to I/O requests.  However remote-wakeup requests
+		from the device may still be enabled (the remote-wakeup
+		setting is controlled separately by the power/wakeup
+		attribute).
+
+		During normal use, devices should be left in the "auto"
+		level.  The other levels are meant for administrative uses.
+		If you want to suspend a device immediately but leave it
+		free to wake up in response to I/O requests, you should
+		write "0" to power/autosuspend.
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 884179f1e163..9b6a60fafddb 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -872,8 +872,10 @@ static int usb_resume_device(struct usb_device *udev)
 
 done:
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
-	if (status == 0)
+	if (status == 0) {
+		udev-&gt;autoresume_disabled = 0;
 		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+	}
 	return status;
 }
 
@@ -970,7 +972,7 @@ static int autosuspend_check(struct usb_device *udev)
 	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 	if (udev-&gt;pm_usage_cnt &gt; 0)
 		return -EBUSY;
-	if (udev-&gt;autosuspend_delay &lt; 0)
+	if (udev-&gt;autosuspend_delay &lt; 0 || udev-&gt;autosuspend_disabled)
 		return -EPERM;
 
 	if (udev-&gt;actconfig) {
@@ -1116,6 +1118,8 @@ static int usb_resume_both(struct usb_device *udev)
 	struct usb_interface	*intf;
 	struct usb_device	*parent = udev-&gt;parent;
 
+	if (udev-&gt;auto_pm &amp;&amp; udev-&gt;autoresume_disabled)
+		return -EPERM;
 	cancel_delayed_work(&amp;udev-&gt;autosuspend);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
@@ -1486,9 +1490,14 @@ static int usb_suspend(struct device *dev, pm_message_t message)
 
 static int usb_resume(struct device *dev)
 {
+	struct usb_device	*udev;
+
 	if (!is_usb_device(dev))	/* Ignore PM for interfaces */
 		return 0;
-	return usb_external_resume_device(to_usb_device(dev));
+	udev = to_usb_device(dev);
+	if (udev-&gt;autoresume_disabled)
+		return -EPERM;
+	return usb_external_resume_device(udev);
 }
 
 #else
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index f08ec85a6d64..739f520908aa 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -42,7 +42,7 @@ static void usb_autosuspend_quirk(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
 	/* disable autosuspend, but allow the user to re-enable it via sysfs */
-	udev-&gt;autosuspend_delay = 0;
+	udev-&gt;autosuspend_disabled = 1;
 #endif
 }
 
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 731001f7d2c1..2ea47a38aefa 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -11,6 +11,7 @@
 
 
 #include &lt;linux/kernel.h&gt;
+#include &lt;linux/string.h&gt;
 #include &lt;linux/usb.h&gt;
 #include "usb.h"
 
@@ -184,9 +185,8 @@ set_autosuspend(struct device *dev, struct device_attribute *attr,
 	if (value &gt;= 0)
 		usb_try_autosuspend_device(udev);
 	else {
-		usb_lock_device(udev);
-		usb_external_resume_device(udev);
-		usb_unlock_device(udev);
+		if (usb_autoresume_device(udev) == 0)
+			usb_autosuspend_device(udev);
 	}
 	return count;
 }
@@ -194,21 +194,94 @@ set_autosuspend(struct device *dev, struct device_attribute *attr,
 static DEVICE_ATTR(autosuspend, S_IRUGO | S_IWUSR,
 		show_autosuspend, set_autosuspend);
 
+static const char on_string[] = "on";
+static const char auto_string[] = "auto";
+static const char suspend_string[] = "suspend";
+
+static ssize_t
+show_level(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev = to_usb_device(dev);
+	const char *p = auto_string;
+
+	if (udev-&gt;state == USB_STATE_SUSPENDED) {
+		if (udev-&gt;autoresume_disabled)
+			p = suspend_string;
+	} else {
+		if (udev-&gt;autosuspend_disabled)
+			p = on_string;
+	}
+	return sprintf(buf, "%s\n", p);
+}
+
+static ssize_t
+set_level(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct usb_device *udev = to_usb_device(dev);
+	int len = count;
+	char *cp;
+	int rc = 0;
+
+	cp = memchr(buf, '\n', count);
+	if (cp)
+		len = cp - buf;
+
+	usb_lock_device(udev);
+
+	/* Setting the flags without calling usb_pm_lock is a subject to
+	 * races, but who cares...
+	 */
+	if (len == sizeof on_string - 1 &amp;&amp;
+			strncmp(buf, on_string, len) == 0) {
+		udev-&gt;autosuspend_disabled = 1;
+		udev-&gt;autoresume_disabled = 0;
+		rc = usb_external_resume_device(udev);
+
+	} else if (len == sizeof auto_string - 1 &amp;&amp;
+			strncmp(buf, auto_string, len) == 0) {
+		udev-&gt;autosuspend_disabled = 0;
+		udev-&gt;autoresume_disabled = 0;
+		rc = usb_external_resume_device(udev);
+
+	} else if (len == sizeof suspend_string - 1 &amp;&amp;
+			strncmp(buf, suspend_string, len) == 0) {
+		udev-&gt;autosuspend_disabled = 0;
+		udev-&gt;autoresume_disabled = 1;
+		rc = usb_external_suspend_device(udev, PMSG_SUSPEND);
+
+	} else
+		rc = -EINVAL;
+
+	usb_unlock_device(udev);
+	return (rc &lt; 0 ? rc : count);
+}
+
+static DEVICE_ATTR(level, S_IRUGO | S_IWUSR, show_level, set_level);
+
 static char power_group[] = "power";
 
 static int add_power_attributes(struct device *dev)
 {
 	int rc = 0;
 
-	if (is_usb_device(dev))
+	if (is_usb_device(dev)) {
 		rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
 				&amp;dev_attr_autosuspend.attr,
 				power_group);
+		if (rc == 0)
+			rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
+					&amp;dev_attr_level.attr,
+					power_group);
+	}
 	return rc;
 }
 
 static void remove_power_attributes(struct device *dev)
 {
+	sysfs_remove_file_from_group(&amp;dev-&gt;kobj,
+			&amp;dev_attr_level.attr,
+			power_group);
 	sysfs_remove_file_from_group(&amp;dev-&gt;kobj,
 			&amp;dev_attr_autosuspend.attr,
 			power_group);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index cc24d089faa0..5e8e144afbae 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -398,6 +398,8 @@ struct usb_device {
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
+	unsigned autosuspend_disabled:1; /* autosuspend and autoresume */
+	unsigned autoresume_disabled:1;  /*  disabled by the user */
 #endif
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)</pre><hr><pre>commit 0cef7727c953056bb3ef9852a79d9658a1d8df4e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 19 15:33:11 2007 -0400

    UHCI: Add some WARN_ON()s
    
    This patch (as872) adds some WARN_ON()s to various error checks which
    are never supposed to fail.  Unsettlingly, one of them has shown up in
    a user's log!  Maybe making the warning more visible and having the
    call-stack information available will help pinpoint the source of the
    problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 19a0cc02b9a2..4aed305982ec 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -123,10 +123,14 @@ static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 
 static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
 {
-	if (!list_empty(&amp;td-&gt;list))
+	if (!list_empty(&amp;td-&gt;list)) {
 		dev_warn(uhci_dev(uhci), "td %p still in list!\n", td);
-	if (!list_empty(&amp;td-&gt;fl_list))
+		WARN_ON(1);
+	}
+	if (!list_empty(&amp;td-&gt;fl_list)) {
 		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
+		WARN_ON(1);
+	}
 
 	dma_pool_free(uhci-&gt;td_pool, td, td-&gt;dma_handle);
 }
@@ -291,8 +295,10 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
 	WARN_ON(qh-&gt;state != QH_STATE_IDLE &amp;&amp; qh-&gt;udev);
-	if (!list_empty(&amp;qh-&gt;queue))
+	if (!list_empty(&amp;qh-&gt;queue)) {
 		dev_warn(uhci_dev(uhci), "qh %p list not empty!\n", qh);
+		WARN_ON(1);
+	}
 
 	list_del(&amp;qh-&gt;node);
 	if (qh-&gt;udev) {
@@ -740,9 +746,11 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 {
 	struct uhci_td *td, *tmp;
 
-	if (!list_empty(&amp;urbp-&gt;node))
+	if (!list_empty(&amp;urbp-&gt;node)) {
 		dev_warn(uhci_dev(uhci), "urb %p still on QH's list!\n",
 				urbp-&gt;urb);
+		WARN_ON(1);
+	}
 
 	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
 		uhci_remove_td_from_urbp(td);</pre><hr><pre>commit e198a31489146bb723fef179e5d1d18c8225f246
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 15 15:54:30 2007 -0400

    EHCI: add delay to bus_resume before accessing ports
    
    This patch (as870) adds a delay to ehci-hcd's bus_resume routine.
    Apparently there are controllers and/or BIOSes out there which need
    such a delay to get the ports back into their correct state.  This
    fixes Bugzilla #8190.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 1813b7cac294..f4d301bc83b9 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -136,6 +136,10 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	/* restore CMD_RUN, framelist size, and irq threshold */
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 
+	/* Some controller/firmware combinations need a delay during which
+	 * they set up the port statuses.  See Bugzilla #8190. */
+	mdelay(8);
+
 	/* manually resume the ports we suspended during bus_suspend() */
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 	while (i--) {</pre>
    <div class="pagination">
        <a href='2_109.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><span>[110]</span><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_111.html'>Next&gt;&gt;</a>
    <div>
</body>
