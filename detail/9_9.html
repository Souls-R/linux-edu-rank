<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by State University of New York at Stony Brook</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by State University of New York at Stony Brook</h1>
    <div class="pagination">
        <a href='9_8.html'>&lt;&lt;Prev</a><a href='9.html'>1</a><a href='9_2.html'>2</a><a href='9_3.html'>3</a><a href='9_4.html'>4</a><a href='9_5.html'>5</a><a href='9_6.html'>6</a><a href='9_7.html'>7</a><a href='9_8.html'>8</a><span>[9]</span><a href='9_10.html'>10</a><a href='9_11.html'>11</a><a href='9_12.html'>12</a><a href='9_13.html'>13</a><a href='9_14.html'>14</a><a href='9_10.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 76a0f17429f5dd82186eec2ee2f37f5a5237d1a8
Author: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:52 2006 -0800

    [PATCH] struct path: convert atm
    
    Signed-off-by: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/net/atm/proc.c b/net/atm/proc.c
index 91fe5f53ff11..739866bfe9e9 100644
--- a/net/atm/proc.c
+++ b/net/atm/proc.c
@@ -393,7 +393,7 @@ static ssize_t proc_dev_atm_read(struct file *file, char __user *buf,
 	if (count == 0) return 0;
 	page = get_zeroed_page(GFP_KERNEL);
 	if (!page) return -ENOMEM;
-	dev = PDE(file-&gt;f_dentry-&gt;d_inode)-&gt;data;
+	dev = PDE(file-&gt;f_path.dentry-&gt;d_inode)-&gt;data;
 	if (!dev-&gt;ops-&gt;proc_read)
 		length = -EINVAL;
 	else {</pre><hr><pre>commit 8ac0352bb20c5a8c051218c689d263b4591d50e1
Author: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:51 2006 -0800

    [PATCH] struct path: convert alpha
    
    Signed-off-by: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/arch/alpha/kernel/osf_sys.c b/arch/alpha/kernel/osf_sys.c
index ad6173651995..fb804043b320 100644
--- a/arch/alpha/kernel/osf_sys.c
+++ b/arch/alpha/kernel/osf_sys.c
@@ -277,7 +277,7 @@ osf_fstatfs(unsigned long fd, struct osf_statfs __user *buffer, unsigned long bu
 	retval = -EBADF;
 	file = fget(fd);
 	if (file) {
-		retval = do_osf_statfs(file-&gt;f_dentry, buffer, bufsiz);
+		retval = do_osf_statfs(file-&gt;f_path.dentry, buffer, bufsiz);
 		fput(file);
 	}
 	return retval;</pre><hr><pre>commit 1d56a96956158d0fb1902c56ffa0e38caa39bddb
Author: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:50 2006 -0800

    [PATCH] struct path: convert afs
    
    Signed-off-by: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/afs/dir.c b/fs/afs/dir.c
index a6ec75c56fcf..4acd04134055 100644
--- a/fs/afs/dir.c
+++ b/fs/afs/dir.c
@@ -392,10 +392,10 @@ static int afs_dir_readdir(struct file *file, void *cookie, filldir_t filldir)
 	unsigned fpos;
 	int ret;
 
-	_enter("{%Ld,{%lu}}", file-&gt;f_pos, file-&gt;f_dentry-&gt;d_inode-&gt;i_ino);
+	_enter("{%Ld,{%lu}}", file-&gt;f_pos, file-&gt;f_path.dentry-&gt;d_inode-&gt;i_ino);
 
 	fpos = file-&gt;f_pos;
-	ret = afs_dir_iterate(file-&gt;f_dentry-&gt;d_inode, &amp;fpos, cookie, filldir);
+	ret = afs_dir_iterate(file-&gt;f_path.dentry-&gt;d_inode, &amp;fpos, cookie, filldir);
 	file-&gt;f_pos = fpos;
 
 	_leave(" = %d", ret);
diff --git a/fs/afs/mntpt.c b/fs/afs/mntpt.c
index 99785a79d043..f33b1a81a761 100644
--- a/fs/afs/mntpt.c
+++ b/fs/afs/mntpt.c
@@ -136,11 +136,11 @@ static int afs_mntpt_open(struct inode *inode, struct file *file)
 {
 	kenter("%p,%p{%p{%s},%s}",
 	       inode, file,
-	       file-&gt;f_dentry-&gt;d_parent,
-	       file-&gt;f_dentry-&gt;d_parent ?
-	       file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name :
+	       file-&gt;f_path.dentry-&gt;d_parent,
+	       file-&gt;f_path.dentry-&gt;d_parent ?
+	       file-&gt;f_path.dentry-&gt;d_parent-&gt;d_name.name :
 	       (const unsigned char *) "",
-	       file-&gt;f_dentry-&gt;d_name.name);
+	       file-&gt;f_path.dentry-&gt;d_name.name);
 
 	return -EREMOTE;
 } /* end afs_mntpt_open() */</pre><hr><pre>commit 514653e25962c37b11fe648e4ef1c1130f697bcb
Author: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
Date:   Fri Dec 8 02:36:50 2006 -0800

    [PATCH] struct path: convert adfs
    
    Signed-off-by: Josef Sipek &lt;jsipek@fsl.cs.sunysb.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/adfs/dir.c b/fs/adfs/dir.c
index d3c7905b2ddc..2b8903893d3f 100644
--- a/fs/adfs/dir.c
+++ b/fs/adfs/dir.c
@@ -28,7 +28,7 @@ static DEFINE_RWLOCK(adfs_dir_lock);
 static int
 adfs_readdir(struct file *filp, void *dirent, filldir_t filldir)
 {
-	struct inode *inode = filp-&gt;f_dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	struct super_block *sb = inode-&gt;i_sb;
 	struct adfs_dir_ops *ops = ADFS_SB(sb)-&gt;s_dir;
 	struct object_info obj;</pre><hr><pre>commit fe0fc013cd8bbd2f4737c1b2694b37dd7fe459cb
Author: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
Date:   Mon Jan 4 18:17:02 2010 -0500

    ecryptfs: fix interpose/interpolate typos in comments
    
    Signed-off-by: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
    Acked-by: Dustin Kirkland &lt;kirkland@canonical.com&gt;
    Signed-off-by: Tyler Hicks &lt;tyhicks@linux.vnet.ibm.com&gt;

diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c
index 567bc4b9f70a..ea2f92101dfe 100644
--- a/fs/ecryptfs/main.c
+++ b/fs/ecryptfs/main.c
@@ -585,8 +585,8 @@ static int ecryptfs_read_super(struct super_block *sb, const char *dev_name)
  *                        with as much information as it can before needing
  *                        the lower filesystem.
  * ecryptfs_read_super(): this accesses the lower filesystem and uses
- *                        ecryptfs_interpolate to perform most of the linking
- * ecryptfs_interpolate(): links the lower filesystem into ecryptfs
+ *                        ecryptfs_interpose to perform most of the linking
+ * ecryptfs_interpose(): links the lower filesystem into ecryptfs (inode.c)
  */
 static int ecryptfs_get_sb(struct file_system_type *fs_type, int flags,
 			const char *dev_name, void *raw_data,</pre><hr><pre>commit 3469b57329f80db5a41cf42d1c8f7690269f57e7
Author: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
Date:   Sun Dec 6 18:51:15 2009 -0500

    ecryptfs: pass matching flags to interpose as defined and used there
    
    ecryptfs_interpose checks if one of the flags passed is
    ECRYPTFS_INTERPOSE_FLAG_D_ADD, defined as 0x00000001 in ecryptfs_kernel.h.
    But the only user of ecryptfs_interpose to pass a non-zero flag to it, has
    hard-coded the value as "1". This could spell trouble if any of these values
    changes in the future.
    
    Signed-off-by: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
    Cc: Dustin Kirkland &lt;kirkland@canonical.com&gt;
    Cc: Al Viro &lt;viro@zeniv.linux.org.uk&gt;
    Signed-off-by: Tyler Hicks &lt;tyhicks@linux.vnet.ibm.com&gt;

diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c
index e03415293625..4a430ab4115c 100644
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -282,7 +282,8 @@ int ecryptfs_lookup_and_interpose_lower(struct dentry *ecryptfs_dentry,
 		goto out;
 	}
 	rc = ecryptfs_interpose(lower_dentry, ecryptfs_dentry,
-				ecryptfs_dir_inode-&gt;i_sb, 1);
+				ecryptfs_dir_inode-&gt;i_sb,
+				ECRYPTFS_INTERPOSE_FLAG_D_ADD);
 	if (rc) {
 		printk(KERN_ERR "%s: Error interposing; rc = [%d]\n",
 		       __func__, rc);</pre><hr><pre>commit c44a66d674688f1e1d0b2f6f56bd9c6a1b061cae
Author: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
Date:   Sun Dec 6 18:05:30 2009 -0500

    ecryptfs: remove unnecessary d_drop calls in ecryptfs_link
    
    Unnecessary because it would unhash perfectly valid dentries, causing them
    to have to be re-looked up the next time they're needed, which presumably is
    right after.
    
    Signed-off-by: Aseem Rastogi &lt;arastogi@cs.sunysb.edu&gt;
    Signed-off-by: Shrikar archak &lt;shrikar84@gmail.com&gt;
    Signed-off-by: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
    Cc: Saumitra Bhanage &lt;sbhanage@cs.sunysb.edu&gt;
    Cc: Al Viro &lt;viro@zeniv.linux.org.uk&gt;
    Signed-off-by: Tyler Hicks &lt;tyhicks@linux.vnet.ibm.com&gt;

diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c
index 764dc777b268..e03415293625 100644
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -463,9 +463,6 @@ static int ecryptfs_link(struct dentry *old_dentry, struct inode *dir,
 	unlock_dir(lower_dir_dentry);
 	dput(lower_new_dentry);
 	dput(lower_old_dentry);
-	d_drop(lower_old_dentry);
-	d_drop(new_dentry);
-	d_drop(old_dentry);
 	return rc;
 }
 </pre><hr><pre>commit 0d132f7364694da8f7cafd49e2fc2721b73e96e4
Author: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
Date:   Sat Dec 5 21:17:09 2009 -0500

    ecryptfs: don't ignore return value from lock_rename
    
    Signed-off-by: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
    Cc: Dustin Kirkland &lt;kirkland@canonical.com&gt;
    Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Cc: Al Viro &lt;viro@zeniv.linux.org.uk&gt;
    Signed-off-by: Tyler Hicks &lt;tyhicks@linux.vnet.ibm.com&gt;

diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c
index 5726d7adaf5b..764dc777b268 100644
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -614,6 +614,7 @@ ecryptfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	struct dentry *lower_new_dentry;
 	struct dentry *lower_old_dir_dentry;
 	struct dentry *lower_new_dir_dentry;
+	struct dentry *trap = NULL;
 
 	lower_old_dentry = ecryptfs_dentry_to_lower(old_dentry);
 	lower_new_dentry = ecryptfs_dentry_to_lower(new_dentry);
@@ -621,7 +622,17 @@ ecryptfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	dget(lower_new_dentry);
 	lower_old_dir_dentry = dget_parent(lower_old_dentry);
 	lower_new_dir_dentry = dget_parent(lower_new_dentry);
-	lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+	trap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+	/* source should not be ancestor of target */
+	if (trap == lower_old_dentry) {
+		rc = -EINVAL;
+		goto out_lock;
+	}
+	/* target should not be ancestor of source */
+	if (trap == lower_new_dentry) {
+		rc = -ENOTEMPTY;
+		goto out_lock;
+	}
 	rc = vfs_rename(lower_old_dir_dentry-&gt;d_inode, lower_old_dentry,
 			lower_new_dir_dentry-&gt;d_inode, lower_new_dentry);
 	if (rc)</pre><hr><pre>commit e27759d7a333d1f25d628c4f7caf845c51be51c2
Author: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
Date:   Thu Dec 3 13:35:27 2009 -0500

    ecryptfs: initialize private persistent file before dereferencing pointer
    
    Ecryptfs_open dereferences a pointer to the private lower file (the one
    stored in the ecryptfs inode), without checking if the pointer is NULL.
    Right afterward, it initializes that pointer if it is NULL.  Swap order of
    statements to first initialize.  Bug discovered by Duckjin Kang.
    
    Signed-off-by: Duckjin Kang &lt;fromdj2k@gmail.com&gt;
    Signed-off-by: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
    Cc: Dustin Kirkland &lt;kirkland@canonical.com&gt;
    Cc: Al Viro &lt;viro@zeniv.linux.org.uk&gt;
    Cc: &lt;stable@kernel.org&gt;
    Signed-off-by: Tyler Hicks &lt;tyhicks@linux.vnet.ibm.com&gt;

diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c
index 3efc7fdc3c39..dde7bb48bb5f 100644
--- a/fs/ecryptfs/file.c
+++ b/fs/ecryptfs/file.c
@@ -191,13 +191,6 @@ static int ecryptfs_open(struct inode *inode, struct file *file)
 				      | ECRYPTFS_ENCRYPTED);
 	}
 	mutex_unlock(&amp;crypt_stat-&gt;cs_mutex);
-	if ((ecryptfs_inode_to_private(inode)-&gt;lower_file-&gt;f_flags &amp; O_RDONLY)
-	    &amp;&amp; !(file-&gt;f_flags &amp; O_RDONLY)) {
-		rc = -EPERM;
-		printk(KERN_WARNING "%s: Lower persistent file is RO; eCryptfs "
-		       "file must hence be opened RO\n", __func__);
-		goto out;
-	}
 	if (!ecryptfs_inode_to_private(inode)-&gt;lower_file) {
 		rc = ecryptfs_init_persistent_file(ecryptfs_dentry);
 		if (rc) {
@@ -208,6 +201,13 @@ static int ecryptfs_open(struct inode *inode, struct file *file)
 			goto out;
 		}
 	}
+	if ((ecryptfs_inode_to_private(inode)-&gt;lower_file-&gt;f_flags &amp; O_RDONLY)
+	    &amp;&amp; !(file-&gt;f_flags &amp; O_RDONLY)) {
+		rc = -EPERM;
+		printk(KERN_WARNING "%s: Lower persistent file is RO; eCryptfs "
+		       "file must hence be opened RO\n", __func__);
+		goto out;
+	}
 	ecryptfs_set_file_lower(
 		file, ecryptfs_inode_to_private(inode)-&gt;lower_file);
 	if (S_ISDIR(ecryptfs_dentry-&gt;d_inode-&gt;i_mode)) {</pre><hr><pre>commit 1b8ab8159ef8f818f870a1d2e3b6953d80eefd3f
Author: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
Date:   Thu Dec 3 21:56:09 2009 -0500

    VFS/fsstack: handle 32-bit smp + preempt + large files in fsstack_copy_inode_size
    
    Copy the inode size and blocks from one inode to another correctly on 32-bit
    systems with CONFIG_SMP, CONFIG_PREEMPT, or CONFIG_LBDAF.  Use proper inode
    spinlocks only when i_size/i_blocks cannot fit in one 32-bit word.
    
    Signed-off-by: Hugh Dickins &lt;hugh.dickins@tiscali.co.uk&gt;
    Signed-off-by: Erez Zadok &lt;ezk@cs.sunysb.edu&gt;
    Signed-off-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;

diff --git a/fs/stack.c b/fs/stack.c
index 0e20e43ad740..4a6f7f440658 100644
--- a/fs/stack.c
+++ b/fs/stack.c
@@ -7,10 +7,58 @@
  * This function cannot be inlined since i_size_{read,write} is rather
  * heavy-weight on 32-bit systems
  */
-void fsstack_copy_inode_size(struct inode *dst, const struct inode *src)
+void fsstack_copy_inode_size(struct inode *dst, struct inode *src)
 {
-	i_size_write(dst, i_size_read((struct inode *)src));
-	dst-&gt;i_blocks = src-&gt;i_blocks;
+	loff_t i_size;
+	blkcnt_t i_blocks;
+
+	/*
+	 * i_size_read() includes its own seqlocking and protection from
+	 * preemption (see include/linux/fs.h): we need nothing extra for
+	 * that here, and prefer to avoid nesting locks than attempt to keep
+	 * i_size and i_blocks in sync together.
+	 */
+	i_size = i_size_read(src);
+
+	/*
+	 * But if CONFIG_LBDAF (on 32-bit), we ought to make an effort to
+	 * keep the two halves of i_blocks in sync despite SMP or PREEMPT -
+	 * though stat's generic_fillattr() doesn't bother, and we won't be
+	 * applying quotas (where i_blocks does become important) at the
+	 * upper level.
+	 *
+	 * We don't actually know what locking is used at the lower level;
+	 * but if it's a filesystem that supports quotas, it will be using
+	 * i_lock as in inode_add_bytes().  tmpfs uses other locking, and
+	 * its 32-bit is (just) able to exceed 2TB i_size with the aid of
+	 * holes; but its i_blocks cannot carry into the upper long without
+	 * almost 2TB swap - let's ignore that case.
+	 */
+	if (sizeof(i_blocks) &gt; sizeof(long))
+		spin_lock(&amp;src-&gt;i_lock);
+	i_blocks = src-&gt;i_blocks;
+	if (sizeof(i_blocks) &gt; sizeof(long))
+		spin_unlock(&amp;src-&gt;i_lock);
+
+	/*
+	 * If CONFIG_SMP or CONFIG_PREEMPT on 32-bit, it's vital for
+	 * fsstack_copy_inode_size() to hold some lock around
+	 * i_size_write(), otherwise i_size_read() may spin forever (see
+	 * include/linux/fs.h).  We don't necessarily hold i_mutex when this
+	 * is called, so take i_lock for that case.
+	 *
+	 * And if CONFIG_LBADF (on 32-bit), continue our effort to keep the
+	 * two halves of i_blocks in sync despite SMP or PREEMPT: use i_lock
+	 * for that case too, and do both at once by combining the tests.
+	 *
+	 * There is none of this locking overhead in the 64-bit case.
+	 */
+	if (sizeof(i_size) &gt; sizeof(long) || sizeof(i_blocks) &gt; sizeof(long))
+		spin_lock(&amp;dst-&gt;i_lock);
+	i_size_write(dst, i_size);
+	dst-&gt;i_blocks = i_blocks;
+	if (sizeof(i_size) &gt; sizeof(long) || sizeof(i_blocks) &gt; sizeof(long))
+		spin_unlock(&amp;dst-&gt;i_lock);
 }
 EXPORT_SYMBOL_GPL(fsstack_copy_inode_size);
 
diff --git a/include/linux/fs_stack.h b/include/linux/fs_stack.h
index aa60311900dd..da317c7163ab 100644
--- a/include/linux/fs_stack.h
+++ b/include/linux/fs_stack.h
@@ -9,7 +9,7 @@
 
 /* externs for fs/stack.c */
 extern void fsstack_copy_attr_all(struct inode *dest, const struct inode *src);
-extern void fsstack_copy_inode_size(struct inode *dst, const struct inode *src);
+extern void fsstack_copy_inode_size(struct inode *dst, struct inode *src);
 
 /* inlines */
 static inline void fsstack_copy_attr_atime(struct inode *dest,</pre>
    <div class="pagination">
        <a href='9_8.html'>&lt;&lt;Prev</a><a href='9.html'>1</a><a href='9_2.html'>2</a><a href='9_3.html'>3</a><a href='9_4.html'>4</a><a href='9_5.html'>5</a><a href='9_6.html'>6</a><a href='9_7.html'>7</a><a href='9_8.html'>8</a><span>[9]</span><a href='9_10.html'>10</a><a href='9_11.html'>11</a><a href='9_12.html'>12</a><a href='9_13.html'>13</a><a href='9_14.html'>14</a><a href='9_10.html'>Next&gt;&gt;</a>
    <div>
</body>
