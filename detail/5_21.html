<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_20.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><span>[21]</span><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_22.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0f9c7449ce050759d10424048b96d1bd0d59dcc1
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Dec 2 00:32:06 2008 -0600

    [SCSI] iser: convert iser to new alloc_pdu api
    
    This just converts iser to new alloc_pdu api. It still
    preallocates the pdu, so there is no difference.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 1e5b6446231d..78bf5e4538cb 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -119,6 +119,14 @@ iscsi_iser_recv(struct iscsi_conn *conn,
 	iscsi_conn_failure(conn, rc);
 }
 
+static int iscsi_iser_pdu_alloc(struct iscsi_task *task)
+{
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
+
+	task-&gt;hdr = (struct iscsi_hdr *)&amp;iser_task-&gt;desc.iscsi_header;
+	task-&gt;hdr_max = sizeof(iser_task-&gt;desc.iscsi_header);
+	return 0;
+}
 
 /**
  * iscsi_iser_task_init - Initialize task
@@ -180,25 +188,26 @@ static int
 iscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,
 				 struct iscsi_task *task)
 {
-	struct iscsi_data  hdr;
+	struct iscsi_r2t_info *r2t = &amp;task-&gt;unsol_r2t;
+	struct iscsi_data hdr;
 	int error = 0;
 
 	/* Send data-out PDUs while there's still unsolicited data to send */
-	while (task-&gt;unsol_count &gt; 0) {
-		iscsi_prep_unsolicit_data_pdu(task, &amp;hdr);
+	while (iscsi_task_has_unsol_data(task)) {
+		iscsi_prep_data_out_pdu(task, r2t, &amp;hdr);
 		debug_scsi("Sending data-out: itt 0x%x, data count %d\n",
-			   hdr.itt, task-&gt;data_count);
+			   hdr.itt, r2t-&gt;data_count);
 
 		/* the buffer description has been passed with the command */
 		/* Send the command */
 		error = iser_send_data_out(conn, task, &amp;hdr);
 		if (error) {
-			task-&gt;unsol_datasn--;
+			r2t-&gt;datasn--;
 			goto iscsi_iser_task_xmit_unsol_data_exit;
 		}
-		task-&gt;unsol_count -= task-&gt;data_count;
+		r2t-&gt;sent += r2t-&gt;data_count;
 		debug_scsi("Need to send %d more as data-out PDUs\n",
-			   task-&gt;unsol_count);
+			   r2t-&gt;data_length - r2t-&gt;sent);
 	}
 
 iscsi_iser_task_xmit_unsol_data_exit:
@@ -220,7 +229,7 @@ iscsi_iser_task_xmit(struct iscsi_task *task)
 
 		debug_scsi("cmd [itt %x total %d imm %d unsol_data %d\n",
 			   task-&gt;itt, scsi_bufflen(task-&gt;sc),
-			   task-&gt;imm_count, task-&gt;unsol_count);
+			   task-&gt;imm_count, task-&gt;unsol_r2t.data_length);
 	}
 
 	debug_scsi("task deq [cid %d itt 0x%x]\n",
@@ -235,7 +244,7 @@ iscsi_iser_task_xmit(struct iscsi_task *task)
 	}
 
 	/* Send unsolicited data-out PDU(s) if necessary */
-	if (task-&gt;unsol_count)
+	if (iscsi_task_has_unsol_data(task))
 		error = iscsi_iser_task_xmit_unsol_data(conn, task);
 
  iscsi_iser_task_xmit_exit:
@@ -244,13 +253,15 @@ iscsi_iser_task_xmit(struct iscsi_task *task)
 	return error;
 }
 
-static void
-iscsi_iser_cleanup_task(struct iscsi_conn *conn, struct iscsi_task *task)
+static void iscsi_iser_cleanup_task(struct iscsi_task *task)
 {
 	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 
-	/* mgmt tasks do not need special cleanup */
-	if (!task-&gt;sc)
+	/*
+	 * mgmt tasks do not need special cleanup and we do not
+	 * allocate anything in the init task callout
+	 */
+	if (!task-&gt;sc || task-&gt;state == ISCSI_TASK_PENDING)
 		return;
 
 	if (iser_task-&gt;status == ISER_TASK_STATUS_STARTED) {
@@ -391,9 +402,6 @@ iscsi_iser_session_create(struct iscsi_endpoint *ep,
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
 	struct Scsi_Host *shost;
-	int i;
-	struct iscsi_task *task;
-	struct iscsi_iser_task *iser_task;
 	struct iser_conn *ib_conn;
 
 	shost = iscsi_host_alloc(&amp;iscsi_iser_sht, 0, ISCSI_MAX_CMD_PER_LUN);
@@ -430,13 +438,6 @@ iscsi_iser_session_create(struct iscsi_endpoint *ep,
 	session = cls_session-&gt;dd_data;
 
 	shost-&gt;can_queue = session-&gt;scsi_cmds_max;
-	/* libiscsi setup itts, data and pool so just set desc fields */
-	for (i = 0; i &lt; session-&gt;cmds_max; i++) {
-		task = session-&gt;cmds[i];
-		iser_task = task-&gt;dd_data;
-		task-&gt;hdr = (struct iscsi_cmd *)&amp;iser_task-&gt;desc.iscsi_header;
-		task-&gt;hdr_max = sizeof(iser_task-&gt;desc.iscsi_header);
-	}
 	return cls_session;
 
 remove_host:
@@ -652,6 +653,7 @@ static struct iscsi_transport iscsi_iser_transport = {
 	.init_task		= iscsi_iser_task_init,
 	.xmit_task		= iscsi_iser_task_xmit,
 	.cleanup_task		= iscsi_iser_cleanup_task,
+	.alloc_pdu		= iscsi_iser_pdu_alloc,
 	/* recovery */
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index ed1aff21b7ea..e209cb8dd948 100644
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -353,8 +353,7 @@ int iser_send_command(struct iscsi_conn *conn,
 	unsigned long edtl;
 	int err = 0;
 	struct iser_data_buf *data_buf;
-
-	struct iscsi_cmd *hdr =  task-&gt;hdr;
+	struct iscsi_cmd *hdr =  (struct iscsi_cmd *)task-&gt;hdr;
 	struct scsi_cmnd *sc  =  task-&gt;sc;
 
 	if (!iser_conn_state_comp(iser_conn-&gt;ib_conn, ISER_CONN_UP)) {
@@ -393,7 +392,7 @@ int iser_send_command(struct iscsi_conn *conn,
 		err = iser_prepare_write_cmd(task,
 					     task-&gt;imm_count,
 				             task-&gt;imm_count +
-					     task-&gt;unsol_count,
+					     task-&gt;unsol_r2t.data_length,
 					     edtl);
 		if (err)
 			goto send_command_error;</pre><hr><pre>commit 577577da6d197ea3dcf3ee19c4f902fbd3a9390a
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Dec 2 00:32:05 2008 -0600

    [SCSI] libiscsi: prepare libiscsi for new offload engines by modifying unsol data code
    
    cxgb3i offloads data transfers. It does not offload the entire scsi/iscsi
    procssing like qla4xxx and it does not offload the iscsi sequence
    processing like how bnx2i does. cxgb3i relies on iscsi_tcp for the
    seqeunce handling so this changes how we transfer unsolicitied data by
    adding a common r2t struct and helpers.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 3fdee7370ccc..80cbcdce7fa3 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -88,34 +88,47 @@ iscsi_update_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
 }
 EXPORT_SYMBOL_GPL(iscsi_update_cmdsn);
 
-void iscsi_prep_unsolicit_data_pdu(struct iscsi_task *task,
-				   struct iscsi_data *hdr)
+/**
+ * iscsi_prep_data_out_pdu - initialize Data-Out
+ * @task: scsi command task
+ * @r2t: R2T info
+ * @hdr: iscsi data in pdu
+ *
+ * Notes:
+ *	Initialize Data-Out within this R2T sequence and finds
+ *	proper data_offset within this SCSI command.
+ *
+ *	This function is called with connection lock taken.
+ **/
+void iscsi_prep_data_out_pdu(struct iscsi_task *task, struct iscsi_r2t_info *r2t,
+			   struct iscsi_data *hdr)
 {
 	struct iscsi_conn *conn = task-&gt;conn;
+	unsigned int left = r2t-&gt;data_length - r2t-&gt;sent;
+
+	task-&gt;hdr_len = sizeof(struct iscsi_data);
 
 	memset(hdr, 0, sizeof(struct iscsi_data));
-	hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	hdr-&gt;datasn = cpu_to_be32(task-&gt;unsol_datasn);
-	task-&gt;unsol_datasn++;
+	hdr-&gt;ttt = r2t-&gt;ttt;
+	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;datasn);
+	r2t-&gt;datasn++;
 	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr-&gt;lun, task-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
-
-	hdr-&gt;itt = task-&gt;hdr-&gt;itt;
-	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
-	hdr-&gt;offset = cpu_to_be32(task-&gt;unsol_offset);
-
-	if (task-&gt;unsol_count &gt; conn-&gt;max_xmit_dlength) {
+	memcpy(hdr-&gt;lun, task-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;itt = task-&gt;hdr_itt;
+	hdr-&gt;exp_statsn = r2t-&gt;exp_statsn;
+	hdr-&gt;offset = cpu_to_be32(r2t-&gt;data_offset + r2t-&gt;sent);
+	if (left &gt; conn-&gt;max_xmit_dlength) {
 		hton24(hdr-&gt;dlength, conn-&gt;max_xmit_dlength);
-		task-&gt;data_count = conn-&gt;max_xmit_dlength;
-		task-&gt;unsol_offset += task-&gt;data_count;
+		r2t-&gt;data_count = conn-&gt;max_xmit_dlength;
 		hdr-&gt;flags = 0;
 	} else {
-		hton24(hdr-&gt;dlength, task-&gt;unsol_count);
-		task-&gt;data_count = task-&gt;unsol_count;
+		hton24(hdr-&gt;dlength, left);
+		r2t-&gt;data_count = left;
 		hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
 	}
+	conn-&gt;dataout_pdus_cnt++;
 }
-EXPORT_SYMBOL_GPL(iscsi_prep_unsolicit_data_pdu);
+EXPORT_SYMBOL_GPL(iscsi_prep_data_out_pdu);
 
 static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
 {
@@ -206,11 +219,17 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 {
 	struct iscsi_conn *conn = task-&gt;conn;
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_cmd *hdr = task-&gt;hdr;
 	struct scsi_cmnd *sc = task-&gt;sc;
+	struct iscsi_cmd *hdr;
 	unsigned hdrlength, cmd_len;
 	int rc;
 
+	rc = conn-&gt;session-&gt;tt-&gt;alloc_pdu(task);
+	if (rc)
+		return rc;
+	hdr = (struct iscsi_cmd *) task-&gt;hdr;
+	memset(hdr, 0, sizeof(*hdr));
+
 	task-&gt;hdr_len = 0;
 	rc = iscsi_add_hdr(task, sizeof(*hdr));
 	if (rc)
@@ -218,8 +237,9 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	hdr-&gt;opcode = ISCSI_OP_SCSI_CMD;
 	hdr-&gt;flags = ISCSI_ATTR_SIMPLE;
 	int_to_scsilun(sc-&gt;device-&gt;lun, (struct scsi_lun *)hdr-&gt;lun);
-	hdr-&gt;itt = build_itt(task-&gt;itt, session-&gt;age);
-	hdr-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
+	memcpy(task-&gt;lun, hdr-&gt;lun, sizeof(task-&gt;lun));
+	hdr-&gt;itt = task-&gt;hdr_itt = build_itt(task-&gt;itt, session-&gt;age);
+	hdr-&gt;cmdsn = task-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	session-&gt;cmdsn++;
 	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
 	cmd_len = sc-&gt;cmd_len;
@@ -242,6 +262,8 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	}
 	if (sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
 		unsigned out_len = scsi_out(sc)-&gt;length;
+		struct iscsi_r2t_info *r2t = &amp;task-&gt;unsol_r2t;
+
 		hdr-&gt;data_length = cpu_to_be32(out_len);
 		hdr-&gt;flags |= ISCSI_FLAG_CMD_WRITE;
 		/*
@@ -254,13 +276,11 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 		 *			without	R2T ack right after
 		 *			immediate data
 		 *
-		 *	r2t_data_count	bytes to be sent via R2T ack's
+		 *	r2t data_length bytes to be sent via R2T ack's
 		 *
 		 *      pad_count       bytes to be sent as zero-padding
 		 */
-		task-&gt;unsol_count = 0;
-		task-&gt;unsol_offset = 0;
-		task-&gt;unsol_datasn = 0;
+		memset(r2t, 0, sizeof(*r2t));
 
 		if (session-&gt;imm_data_en) {
 			if (out_len &gt;= session-&gt;first_burst)
@@ -274,12 +294,14 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 			zero_data(hdr-&gt;dlength);
 
 		if (!session-&gt;initial_r2t_en) {
-			task-&gt;unsol_count = min(session-&gt;first_burst, out_len)
-							     - task-&gt;imm_count;
-			task-&gt;unsol_offset = task-&gt;imm_count;
+			r2t-&gt;data_length = min(session-&gt;first_burst, out_len) -
+					       task-&gt;imm_count;
+			r2t-&gt;data_offset = task-&gt;imm_count;
+			r2t-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
+			r2t-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
 		}
 
-		if (!task-&gt;unsol_count)
+		if (!task-&gt;unsol_r2t.data_length)
 			/* No unsolicit Data-Out's */
 			hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
 	} else {
@@ -300,8 +322,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	WARN_ON(hdrlength &gt;= 256);
 	hdr-&gt;hlength = hdrlength &amp; 0xFF;
 
-	if (conn-&gt;session-&gt;tt-&gt;init_task &amp;&amp;
-	    conn-&gt;session-&gt;tt-&gt;init_task(task))
+	if (session-&gt;tt-&gt;init_task &amp;&amp; session-&gt;tt-&gt;init_task(task))
 		return -EIO;
 
 	task-&gt;state = ISCSI_TASK_RUNNING;
@@ -332,6 +353,7 @@ static void iscsi_complete_command(struct iscsi_task *task)
 	struct iscsi_session *session = conn-&gt;session;
 	struct scsi_cmnd *sc = task-&gt;sc;
 
+	session-&gt;tt-&gt;cleanup_task(task);
 	list_del_init(&amp;task-&gt;running);
 	task-&gt;state = ISCSI_TASK_COMPLETED;
 	task-&gt;sc = NULL;
@@ -402,8 +424,6 @@ static void fail_command(struct iscsi_conn *conn, struct iscsi_task *task,
 		 * the cmd in the sequencing
 		 */
 		conn-&gt;session-&gt;queued_cmdsn--;
-	else
-		conn-&gt;session-&gt;tt-&gt;cleanup_task(conn, task);
 
 	sc-&gt;result = err;
 	if (!scsi_bidi_cmnd(sc))
@@ -423,7 +443,7 @@ static int iscsi_prep_mgmt_task(struct iscsi_conn *conn,
 				struct iscsi_task *task)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_hdr *hdr = (struct iscsi_hdr *)task-&gt;hdr;
+	struct iscsi_hdr *hdr = task-&gt;hdr;
 	struct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;
 
 	if (conn-&gt;session-&gt;state == ISCSI_STATE_LOGGING_OUT)
@@ -456,6 +476,7 @@ static int iscsi_prep_mgmt_task(struct iscsi_conn *conn,
 	if ((hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) == ISCSI_OP_LOGOUT)
 		session-&gt;state = ISCSI_STATE_LOGGING_OUT;
 
+	task-&gt;state = ISCSI_TASK_RUNNING;
 	list_move_tail(&amp;task-&gt;running, &amp;conn-&gt;mgmt_run_list);
 	debug_scsi("mgmtpdu [op 0x%x hdr-&gt;itt 0x%x datalen %d]\n",
 		   hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, hdr-&gt;itt,
@@ -505,23 +526,38 @@ __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	} else
 		task-&gt;data_count = 0;
 
+	if (conn-&gt;session-&gt;tt-&gt;alloc_pdu(task)) {
+		iscsi_conn_printk(KERN_ERR, conn, "Could not allocate "
+				 "pdu for mgmt task.\n");
+		goto requeue_task;
+	}
+	task-&gt;hdr_len = sizeof(struct iscsi_hdr);
+
 	memcpy(task-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
 	INIT_LIST_HEAD(&amp;task-&gt;running);
 	list_add_tail(&amp;task-&gt;running, &amp;conn-&gt;mgmtqueue);
 
 	if (session-&gt;tt-&gt;caps &amp; CAP_DATA_PATH_OFFLOAD) {
-		if (iscsi_prep_mgmt_task(conn, task)) {
-			__iscsi_put_task(task);
-			return NULL;
-		}
+		if (iscsi_prep_mgmt_task(conn, task))
+			goto free_task;
 
 		if (session-&gt;tt-&gt;xmit_task(task))
-			task = NULL;
+			goto free_task;
 
 	} else
 		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 
 	return task;
+
+free_task:
+	__iscsi_put_task(task);
+	return NULL;
+
+requeue_task:
+	if (task != conn-&gt;login_task)
+		__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;task,
+			    sizeof(void*));
+	return NULL;
 }
 
 int iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,
@@ -1136,8 +1172,13 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 			fail_command(conn, conn-&gt;task, DID_IMM_RETRY &lt;&lt; 16);
 			continue;
 		}
-		if (iscsi_prep_scsi_cmd_pdu(conn-&gt;task)) {
-			fail_command(conn, conn-&gt;task, DID_ABORT &lt;&lt; 16);
+		rc = iscsi_prep_scsi_cmd_pdu(conn-&gt;task);
+		if (rc) {
+			if (rc == -ENOMEM) {
+				conn-&gt;task = NULL;
+				goto again;
+			} else
+				fail_command(conn, conn-&gt;task, DID_ABORT &lt;&lt; 16);
 			continue;
 		}
 		rc = iscsi_xmit_task(conn);
@@ -1195,6 +1236,26 @@ static void iscsi_xmitworker(struct work_struct *work)
 	} while (rc &gt;= 0 || rc == -EAGAIN);
 }
 
+static inline struct iscsi_task *iscsi_alloc_task(struct iscsi_conn *conn,
+						  struct scsi_cmnd *sc)
+{
+	struct iscsi_task *task;
+
+	if (!__kfifo_get(conn-&gt;session-&gt;cmdpool.queue,
+			 (void *) &amp;task, sizeof(void *)))
+		return NULL;
+
+	sc-&gt;SCp.phase = conn-&gt;session-&gt;age;
+	sc-&gt;SCp.ptr = (char *) task;
+
+	atomic_set(&amp;task-&gt;refcount, 1);
+	task-&gt;state = ISCSI_TASK_PENDING;
+	task-&gt;conn = conn;
+	task-&gt;sc = sc;
+	INIT_LIST_HEAD(&amp;task-&gt;running);
+	return task;
+}
+
 enum {
 	FAILURE_BAD_HOST = 1,
 	FAILURE_SESSION_FAILED,
@@ -1281,33 +1342,27 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 		goto reject;
 	}
 
-	if (!__kfifo_get(session-&gt;cmdpool.queue, (void*)&amp;task,
-			 sizeof(void*))) {
+	task = iscsi_alloc_task(conn, sc);
+	if (!task) {
 		reason = FAILURE_OOM;
 		goto reject;
 	}
-	sc-&gt;SCp.phase = session-&gt;age;
-	sc-&gt;SCp.ptr = (char *)task;
-
-	atomic_set(&amp;task-&gt;refcount, 1);
-	task-&gt;state = ISCSI_TASK_PENDING;
-	task-&gt;conn = conn;
-	task-&gt;sc = sc;
-	INIT_LIST_HEAD(&amp;task-&gt;running);
 	list_add_tail(&amp;task-&gt;running, &amp;conn-&gt;xmitqueue);
 
 	if (session-&gt;tt-&gt;caps &amp; CAP_DATA_PATH_OFFLOAD) {
-		if (iscsi_prep_scsi_cmd_pdu(task)) {
-			sc-&gt;result = DID_ABORT &lt;&lt; 16;
-			sc-&gt;scsi_done = NULL;
-			iscsi_complete_command(task);
-			goto fault;
+		reason = iscsi_prep_scsi_cmd_pdu(task);
+		if (reason) {
+			if (reason == -ENOMEM) {
+				reason = FAILURE_OOM;
+				goto prepd_reject;
+			} else {
+				sc-&gt;result = DID_ABORT &lt;&lt; 16;
+				goto prepd_fault;
+			}
 		}
 		if (session-&gt;tt-&gt;xmit_task(task)) {
-			sc-&gt;scsi_done = NULL;
-			iscsi_complete_command(task);
 			reason = FAILURE_SESSION_NOT_READY;
-			goto reject;
+			goto prepd_reject;
 		}
 	} else
 		scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
@@ -1317,12 +1372,18 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 	spin_lock(host-&gt;host_lock);
 	return 0;
 
+prepd_reject:
+	sc-&gt;scsi_done = NULL;
+	iscsi_complete_command(task);
 reject:
 	spin_unlock(&amp;session-&gt;lock);
 	debug_scsi("cmd 0x%x rejected (%d)\n", sc-&gt;cmnd[0], reason);
 	spin_lock(host-&gt;host_lock);
 	return SCSI_MLQUEUE_TARGET_BUSY;
 
+prepd_fault:
+	sc-&gt;scsi_done = NULL;
+	iscsi_complete_command(task);
 fault:
 	spin_unlock(&amp;session-&gt;lock);
 	debug_scsi("iscsi: cmd 0x%x is not queued (%d)\n", sc-&gt;cmnd[0], reason);
@@ -1634,9 +1695,9 @@ static void iscsi_prep_abort_task_pdu(struct iscsi_task *task,
 	hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;
 	hdr-&gt;flags = ISCSI_TM_FUNC_ABORT_TASK &amp; ISCSI_FLAG_TM_FUNC_MASK;
 	hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
-	memcpy(hdr-&gt;lun, task-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;rtt = task-&gt;hdr-&gt;itt;
-	hdr-&gt;refcmdsn = task-&gt;hdr-&gt;cmdsn;
+	memcpy(hdr-&gt;lun, task-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;rtt = task-&gt;hdr_itt;
+	hdr-&gt;refcmdsn = task-&gt;cmdsn;
 }
 
 int iscsi_eh_abort(struct scsi_cmnd *sc)
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 61e53f14f7e1..51500573c0b8 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -93,24 +93,38 @@ enum {
 	ISCSI_TASK_RUNNING,
 };
 
+struct iscsi_r2t_info {
+	__be32			ttt;		/* copied from R2T */
+	__be32			exp_statsn;	/* copied from R2T */
+	uint32_t		data_length;	/* copied from R2T */
+	uint32_t		data_offset;	/* copied from R2T */
+	int			data_count;	/* DATA-Out payload progress */
+	int			datasn;
+	/* LLDs should set/update these values */
+	int			sent;		/* R2T sequence progress */
+};
+
 struct iscsi_task {
 	/*
 	 * Because LLDs allocate their hdr differently, this is a pointer
 	 * and length to that storage. It must be setup at session
 	 * creation time.
 	 */
-	struct iscsi_cmd	*hdr;
+	struct iscsi_hdr	*hdr;
 	unsigned short		hdr_max;
 	unsigned short		hdr_len;	/* accumulated size of hdr used */
+	/* copied values in case we need to send tmfs */
+	itt_t			hdr_itt;
+	__be32			cmdsn;
+	uint8_t			lun[8];
+
 	int			itt;		/* this ITT */
 
-	uint32_t		unsol_datasn;
 	unsigned		imm_count;	/* imm-data (bytes)   */
-	unsigned		unsol_count;	/* unsolicited (bytes)*/
 	/* offset in unsolicited stream (bytes); */
-	unsigned		unsol_offset;
-	unsigned		data_count;	/* remaining Data-Out */
+	struct iscsi_r2t_info	unsol_r2t;
 	char			*data;		/* mgmt payload */
+	unsigned		data_count;
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
 	struct iscsi_conn	*conn;		/* used connection    */
 
@@ -121,6 +135,11 @@ struct iscsi_task {
 	void			*dd_data;	/* driver/transport data */
 };
 
+static inline int iscsi_task_has_unsol_data(struct iscsi_task *task)
+{
+	return task-&gt;unsol_r2t.data_length &gt; task-&gt;unsol_r2t.sent;
+}
+
 static inline void* iscsi_next_hdr(struct iscsi_task *task)
 {
 	return (void*)task-&gt;hdr + task-&gt;hdr_len;
@@ -376,8 +395,9 @@ extern void iscsi_suspend_tx(struct iscsi_conn *conn);
  * pdu and task processing
  */
 extern void iscsi_update_cmdsn(struct iscsi_session *, struct iscsi_nopin *);
-extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_task *,
-					struct iscsi_data *hdr);
+extern void iscsi_prep_data_out_pdu(struct iscsi_task *task,
+				    struct iscsi_r2t_info *r2t,
+				    struct iscsi_data *hdr);
 extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index c667cc396545..c928234c018f 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -113,10 +113,15 @@ struct iscsi_transport {
 			 char *data, uint32_t data_size);
 	void (*get_stats) (struct iscsi_cls_conn *conn,
 			   struct iscsi_stats *stats);
+
 	int (*init_task) (struct iscsi_task *task);
 	int (*xmit_task) (struct iscsi_task *task);
-	void (*cleanup_task) (struct iscsi_conn *conn,
-				  struct iscsi_task *task);
+	void (*cleanup_task) (struct iscsi_task *task);
+
+	int (*alloc_pdu) (struct iscsi_task *task);
+	int (*xmit_pdu) (struct iscsi_task *task);
+	int (*init_pdu) (struct iscsi_task *task, unsigned int offset,
+			 unsigned int count);
 	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
 	struct iscsi_endpoint *(*ep_connect) (struct sockaddr *dst_addr,
 					      int non_blocking);</pre><hr><pre>commit 63c62f1cb980241513c82cacd5b9f878527c6647
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Dec 2 00:32:04 2008 -0600

    [SCSI] iscsi_tcp: prepare helpers for LLDs that can offload some operations
    
    cxgb3i is unlike qla4xxx and bnx2i in that it does not offload entire
    scsi commands or iscsi sequences. Instead it only offloads the transfer
    of a ISCSI DATA_IN pdu's data, the digests and padding. This patch fixes up the
    iscsi tcp recv path so that it exports its skb recv processing so
    cxgb3i and other drivers can call them. All they have to do is pass
    the function the skb with the hdr or data pdu header and this function
    will do the rest.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index e11bce6ab63c..464de780d953 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -486,7 +486,8 @@ iscsi_tcp_data_recv_prep(struct iscsi_tcp_conn *tcp_conn)
 	struct iscsi_conn *conn = tcp_conn-&gt;iscsi_conn;
 	struct hash_desc *rx_hash = NULL;
 
-	if (conn-&gt;datadgst_en)
+	if (conn-&gt;datadgst_en &amp;
+	    !(conn-&gt;session-&gt;tt-&gt;caps &amp; CAP_DIGEST_OFFLOAD))
 		rx_hash = &amp;tcp_conn-&gt;rx_hash;
 
 	iscsi_segment_init_linear(&amp;tcp_conn-&gt;in.segment,
@@ -774,7 +775,8 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 			 * we move on to the next scatterlist entry and
 			 * update the digest per-entry.
 			 */
-			if (conn-&gt;datadgst_en)
+			if (conn-&gt;datadgst_en &amp;&amp;
+			    !(conn-&gt;session-&gt;tt-&gt;caps &amp; CAP_DIGEST_OFFLOAD))
 				rx_hash = &amp;tcp_conn-&gt;rx_hash;
 
 			debug_tcp("iscsi_tcp_begin_data_in(%p, offset=%d, "
@@ -902,34 +904,52 @@ iscsi_tcp_hdr_recv_done(struct iscsi_tcp_conn *tcp_conn,
 	 * and go back for more. */
 	if (conn-&gt;hdrdgst_en) {
 		if (segment-&gt;digest_len == 0) {
+			/*
+			 * Even if we offload the digest processing we
+			 * splice it in so we can increment the skb/segment
+			 * counters in preparation for the data segment.
+			 */
 			iscsi_tcp_segment_splice_digest(segment,
 							segment-&gt;recv_digest);
 			return 0;
 		}
-		iscsi_tcp_dgst_header(&amp;tcp_conn-&gt;rx_hash, hdr,
-				      segment-&gt;total_copied - ISCSI_DIGEST_SIZE,
-				      segment-&gt;digest);
 
-		if (!iscsi_tcp_dgst_verify(tcp_conn, segment))
-			return ISCSI_ERR_HDR_DGST;
+		if (!(conn-&gt;session-&gt;tt-&gt;caps &amp; CAP_DIGEST_OFFLOAD)) {
+			iscsi_tcp_dgst_header(&amp;tcp_conn-&gt;rx_hash, hdr,
+				segment-&gt;total_copied - ISCSI_DIGEST_SIZE,
+				segment-&gt;digest);
+
+			if (!iscsi_tcp_dgst_verify(tcp_conn, segment))
+				return ISCSI_ERR_HDR_DGST;
+		}
 	}
 
 	tcp_conn-&gt;in.hdr = hdr;
 	return iscsi_tcp_hdr_dissect(conn, hdr);
 }
 
+inline int iscsi_tcp_recv_segment_is_hdr(struct iscsi_tcp_conn *tcp_conn)
+{
+	return tcp_conn-&gt;in.segment.done == iscsi_tcp_hdr_recv_done;
+}
+
+enum {
+	ISCSI_TCP_SEGMENT_DONE,		/* curr seg has been processed */
+	ISCSI_TCP_SKB_DONE,		/* skb is out of data */
+	ISCSI_TCP_CONN_ERR,		/* iscsi layer has fired a conn err */
+	ISCSI_TCP_SUSPENDED,		/* conn is suspended */
+};
+
 /**
- * iscsi_tcp_recv - TCP receive in sendfile fashion
- * @rd_desc: read descriptor
- * @skb: socket buffer
+ * iscsi_tcp_recv_skb - Process skb
+ * @conn: iscsi connection
+ * @skb: network buffer with header and/or data segment
  * @offset: offset in skb
- * @len: skb-&gt;len - offset
- **/
-static int
-iscsi_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
-	       unsigned int offset, size_t len)
+ * @offload: bool indicating if transfer was offloaded
+ */
+int iscsi_tcp_recv_skb(struct iscsi_conn *conn, struct sk_buff *skb,
+		       unsigned int offset, bool offloaded, int *status)
 {
-	struct iscsi_conn *conn = rd_desc-&gt;arg.data;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct iscsi_segment *segment = &amp;tcp_conn-&gt;in.segment;
 	struct skb_seq_state seq;
@@ -940,9 +960,15 @@ iscsi_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 
 	if (unlikely(conn-&gt;suspend_rx)) {
 		debug_tcp("conn %d Rx suspended!\n", conn-&gt;id);
+		*status = ISCSI_TCP_SUSPENDED;
 		return 0;
 	}
 
+	if (offloaded) {
+		segment-&gt;total_copied = segment-&gt;total_size;
+		goto segment_done;
+	}
+
 	skb_prepare_seq_read(skb, offset, skb-&gt;len, &amp;seq);
 	while (1) {
 		unsigned int avail;
@@ -952,7 +978,9 @@ iscsi_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 		if (avail == 0) {
 			debug_tcp("no more data avail. Consumed %d\n",
 				  consumed);
-			break;
+			*status = ISCSI_TCP_SKB_DONE;
+			skb_abort_seq_read(&amp;seq);
+			goto skb_done;
 		}
 		BUG_ON(segment-&gt;copied &gt;= segment-&gt;size);
 
@@ -962,25 +990,55 @@ iscsi_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 		consumed += rc;
 
 		if (segment-&gt;total_copied &gt;= segment-&gt;total_size) {
-			debug_tcp("segment done\n");
-			rc = segment-&gt;done(tcp_conn, segment);
-			if (rc != 0) {
-				skb_abort_seq_read(&amp;seq);
-				goto error;
-			}
-
-			/* The done() functions sets up the
-			 * next segment. */
+			skb_abort_seq_read(&amp;seq);
+			goto segment_done;
 		}
 	}
-	skb_abort_seq_read(&amp;seq);
+
+segment_done:
+	*status = ISCSI_TCP_SEGMENT_DONE;
+	debug_tcp("segment done\n");
+	rc = segment-&gt;done(tcp_conn, segment);
+	if (rc != 0) {
+		*status = ISCSI_TCP_CONN_ERR;
+		debug_tcp("Error receiving PDU, errno=%d\n", rc);
+		iscsi_conn_failure(conn, rc);
+		return 0;
+	}
+	/* The done() functions sets up the next segment. */
+
+skb_done:
 	conn-&gt;rxdata_octets += consumed;
 	return consumed;
+}
+EXPORT_SYMBOL_GPL(iscsi_tcp_recv_skb);
 
-error:
-	debug_tcp("Error receiving PDU, errno=%d\n", rc);
-	iscsi_conn_failure(conn, rc);
-	return 0;
+/**
+ * iscsi_tcp_recv - TCP receive in sendfile fashion
+ * @rd_desc: read descriptor
+ * @skb: socket buffer
+ * @offset: offset in skb
+ * @len: skb-&gt;len - offset
+ **/
+static int
+iscsi_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
+	       unsigned int offset, size_t len)
+{
+	struct iscsi_conn *conn = rd_desc-&gt;arg.data;
+	unsigned int consumed, total_consumed = 0;
+	int status;
+
+	debug_tcp("in %d bytes\n", skb-&gt;len - offset);
+
+	do {
+		status = 0;
+		consumed = iscsi_tcp_recv_skb(conn, skb, offset, 0, &amp;status);
+		offset += consumed;
+		total_consumed += consumed;
+	} while (consumed != 0 &amp;&amp; status != ISCSI_TCP_SKB_DONE);
+
+	debug_tcp("read %d bytes status %d\n", skb-&gt;len - offset, status);
+	return total_consumed;
 }
 
 static void
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 0c9514de5df7..8e008c96e795 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -333,8 +333,9 @@ enum iscsi_host_param {
 #define CAP_TEXT_NEGO		0x80
 #define CAP_MARKERS		0x100
 #define CAP_FW_DB		0x200
-#define CAP_SENDTARGETS_OFFLOAD	0x400
-#define CAP_DATA_PATH_OFFLOAD	0x800
+#define CAP_SENDTARGETS_OFFLOAD	0x400	/* offload discovery process */
+#define CAP_DATA_PATH_OFFLOAD	0x800	/* offload entire IO path */
+#define CAP_DIGEST_OFFLOAD	0x1000	/* offload hdr and data digests */
 
 /*
  * These flags describes reason of stop_conn() call</pre><hr><pre>commit d3acf0226debeae22d87808f8f298386bd08e391
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Dec 1 12:13:00 2008 -0600

    [SCSI] libiscsi REGRESSION: fix passthrough support with older iscsi tools
    
    This regression was added in 2.6.27, when the mtask and ctask were
    merged into the the common task struct. The patch applies to
    scsi-rc-fixes, but also applies to 2.6.27 with some offsets.
    
    The problem is that __iscsi_conn_send_pdu assumes that userspace was
    not sending nops with the format it is checking for in the "if" below.
    It turns out that older userspace tools are. This patch moves the
    setting of the internal ping_task tracker (it tracks libiscsi current
    outstanding nop) to iscsi_send_nopout which is only used by kernel callers.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 801c7cf54d2e..3fdee7370ccc 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -489,12 +489,6 @@ __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		if (!__kfifo_get(session-&gt;cmdpool.queue,
 				 (void*)&amp;task, sizeof(void*)))
 			return NULL;
-
-		if ((hdr-&gt;opcode == (ISCSI_OP_NOOP_OUT | ISCSI_OP_IMMEDIATE)) &amp;&amp;
-		     hdr-&gt;ttt == RESERVED_ITT) {
-			conn-&gt;ping_task = task;
-			conn-&gt;last_ping = jiffies;
-		}
 	}
 	/*
 	 * released in complete pdu for task we expect a response for, and
@@ -703,6 +697,11 @@ static void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)
 	task = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)&amp;hdr, NULL, 0);
 	if (!task)
 		iscsi_conn_printk(KERN_ERR, conn, "Could not send nopout\n");
+	else if (!rhdr) {
+		/* only track our nops */
+		conn-&gt;ping_task = task;
+		conn-&gt;last_ping = jiffies;
+	}
 }
 
 static int iscsi_handle_reject(struct iscsi_conn *conn, struct iscsi_hdr *hdr,</pre><hr><pre>commit 2a3a59e5c977654d3aad5bc11cc0aca2303a7f44
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Nov 11 13:42:35 2008 -0600

    [SCSI] Fix hang in starved list processing
    
    Close possible infinite loop with interrupts off when devices are
    added back to the starved list.
    
    Fixes: http://bugzilla.kernel.org/show_bug.cgi?id=11898
    
    Reported-by: &lt;alex.shi@intel.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index f5d3b96890dc..fa45a1a66867 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -567,15 +567,18 @@ static inline int scsi_host_is_busy(struct Scsi_Host *shost)
  */
 static void scsi_run_queue(struct request_queue *q)
 {
-	struct scsi_device *starved_head = NULL, *sdev = q-&gt;queuedata;
+	struct scsi_device *sdev = q-&gt;queuedata;
 	struct Scsi_Host *shost = sdev-&gt;host;
+	LIST_HEAD(starved_list);
 	unsigned long flags;
 
 	if (scsi_target(sdev)-&gt;single_lun)
 		scsi_single_lun_run(sdev);
 
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
-	while (!list_empty(&amp;shost-&gt;starved_list) &amp;&amp; !scsi_host_is_busy(shost)) {
+	list_splice_init(&amp;shost-&gt;starved_list, &amp;starved_list);
+
+	while (!list_empty(&amp;starved_list)) {
 		int flagset;
 
 		/*
@@ -588,24 +591,18 @@ static void scsi_run_queue(struct request_queue *q)
 		 * scsi_request_fn must get the host_lock before checking
 		 * or modifying starved_list or starved_entry.
 		 */
-		sdev = list_entry(shost-&gt;starved_list.next,
-					  struct scsi_device, starved_entry);
-		/*
-		 * The *queue_ready functions can add a device back onto the
-		 * starved list's tail, so we must check for a infinite loop.
-		 */
-		if (sdev == starved_head)
+		if (scsi_host_is_busy(shost))
 			break;
-		if (!starved_head)
-			starved_head = sdev;
 
+		sdev = list_entry(starved_list.next,
+				  struct scsi_device, starved_entry);
+		list_del_init(&amp;sdev-&gt;starved_entry);
 		if (scsi_target_is_busy(scsi_target(sdev))) {
 			list_move_tail(&amp;sdev-&gt;starved_entry,
 				       &amp;shost-&gt;starved_list);
 			continue;
 		}
 
-		list_del_init(&amp;sdev-&gt;starved_entry);
 		spin_unlock(shost-&gt;host_lock);
 
 		spin_lock(sdev-&gt;request_queue-&gt;queue_lock);
@@ -621,6 +618,8 @@ static void scsi_run_queue(struct request_queue *q)
 
 		spin_lock(shost-&gt;host_lock);
 	}
+	/* put any unprocessed entries back */
+	list_splice(&amp;starved_list, &amp;shost-&gt;starved_list);
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 
 	blk_run_queue(q);</pre><hr><pre>commit a343914831a8e29d89af3b26495ab1136a9e3153
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 24 11:46:15 2008 -0500

    libiscsi: fix locking in iscsi_eh_device_reset
    
    We must be using the bh spin locking functions in
    iscsi_eh_device_reset becuase the session lock interacts with
    a thread and softirq.
    
    This patch also fixes up a bogus comment and check in fail_command,
    because no one drops the lock (bnx2i did but it is not going
    upstream yet and there were other refcount changes for that).
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 5aa0db150436..801c7cf54d2e 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -404,11 +404,6 @@ static void fail_command(struct iscsi_conn *conn, struct iscsi_task *task,
 		conn-&gt;session-&gt;queued_cmdsn--;
 	else
 		conn-&gt;session-&gt;tt-&gt;cleanup_task(conn, task);
-	/*
-	 * Check if cleanup_task dropped the lock and the command completed,
-	 */
-	if (!task-&gt;sc)
-		return;
 
 	sc-&gt;result = err;
 	if (!scsi_bidi_cmnd(sc))
@@ -1829,10 +1824,10 @@ int iscsi_eh_device_reset(struct scsi_cmnd *sc)
 
 	iscsi_suspend_tx(conn);
 
-	spin_lock(&amp;session-&gt;lock);
+	spin_lock_bh(&amp;session-&gt;lock);
 	fail_all_commands(conn, sc-&gt;device-&gt;lun, DID_ERROR);
 	conn-&gt;tmf_state = TMF_INITIAL;
-	spin_unlock(&amp;session-&gt;lock);
+	spin_unlock_bh(&amp;session-&gt;lock);
 
 	iscsi_start_tx(conn);
 	goto done;</pre><hr><pre>commit 87cd9eab2dfbdf7d367d7ab30e88176d7b08b83e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 24 11:46:14 2008 -0500

    libiscsi: check reason why we are stopping iscsi session to determine error value
    
    Some wires got crossed on some patches and I messed up in the code
    below when rebuilding a patch. We want to be checking if flag
    equaled the value indicating if we killing the session due to
    final logout or if we just trying to relogin.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index e3e57cce4886..5aa0db150436 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -2453,7 +2453,7 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 	 * flush queues.
 	 */
 	spin_lock_bh(&amp;session-&gt;lock);
-	if (STOP_CONN_RECOVER)
+	if (flag == STOP_CONN_RECOVER)
 		fail_all_commands(conn, -1, DID_TRANSPORT_DISRUPTED);
 	else
 		fail_all_commands(conn, -1, DID_ERROR);</pre><hr><pre>commit 6f481e3cefeb33094e87af176587e6a3027f104e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 24 11:46:13 2008 -0500

    [SCSI] iscsi_tcp: return a descriptive error value during connection errors
    
    The segment-&gt;done functions return a iscsi error value which gives
    a lot more info than conn failed, so this patch has us return
    that value. I also add a new one for xmit failures.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 4f096de81525..ed6c54cae7b1 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -979,7 +979,7 @@ iscsi_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,
 
 error:
 	debug_tcp("Error receiving PDU, errno=%d\n", rc);
-	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	iscsi_conn_failure(conn, rc);
 	return 0;
 }
 
@@ -1098,8 +1098,10 @@ iscsi_xmit(struct iscsi_conn *conn)
 
 	while (1) {
 		rc = iscsi_tcp_xmit_segment(tcp_conn, segment);
-		if (rc &lt; 0)
+		if (rc &lt; 0) {
+			rc = ISCSI_ERR_XMIT_FAILED;
 			goto error;
+		}
 		if (rc == 0)
 			break;
 
@@ -1108,7 +1110,7 @@ iscsi_xmit(struct iscsi_conn *conn)
 		if (segment-&gt;total_copied &gt;= segment-&gt;total_size) {
 			if (segment-&gt;done != NULL) {
 				rc = segment-&gt;done(tcp_conn, segment);
-				if (rc &lt; 0)
+				if (rc != 0)
 					goto error;
 			}
 		}
@@ -1123,8 +1125,8 @@ iscsi_xmit(struct iscsi_conn *conn)
 	/* Transmit error. We could initiate error recovery
 	 * here. */
 	debug_tcp("Error sending PDU, errno=%d\n", rc);
-	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-	return rc;
+	iscsi_conn_failure(conn, rc);
+	return -EIO;
 }
 
 /**
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index f274d248a91f..0c9514de5df7 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -214,6 +214,7 @@ enum iscsi_err {
 	ISCSI_ERR_PARAM_NOT_FOUND	= ISCSI_ERR_BASE + 16,
 	ISCSI_ERR_NO_SCSI_CMD		= ISCSI_ERR_BASE + 17,
 	ISCSI_ERR_INVALID_HOST		= ISCSI_ERR_BASE + 18,
+	ISCSI_ERR_XMIT_FAILED		= ISCSI_ERR_BASE + 19,
 };
 
 /*</pre><hr><pre>commit 8e12452549ba2dfa17db97bc495172fac221a7ab
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 24 11:46:12 2008 -0500

    [SCSI] libiscsi: rename host reset to target reset
    
    I had this in my patchset to add target reset support, but
    it got dropped due to patching conflicts. This initial patch
    just renames the function and users. We are actually just
    dropping the session, and so this does not have anything to do
    with the host exactly. It does for software iscsi because
    we allocate a host per session, but for cxgb3i this makes no
    sense.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 0474da173eb1..1e5b6446231d 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -598,7 +598,7 @@ static struct scsi_host_template iscsi_iser_sht = {
 	.cmd_per_lun            = ISCSI_MAX_CMD_PER_LUN,
 	.eh_abort_handler       = iscsi_eh_abort,
 	.eh_device_reset_handler= iscsi_eh_device_reset,
-	.eh_host_reset_handler	= iscsi_eh_host_reset,
+	.eh_target_reset_handler= iscsi_eh_target_reset,
 	.use_clustering         = DISABLE_CLUSTERING,
 	.proc_name              = "iscsi_iser",
 	.this_id                = -1,
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 752f42884cc1..4f096de81525 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1909,7 +1909,7 @@ static struct scsi_host_template iscsi_sht = {
 	.cmd_per_lun		= ISCSI_DEF_CMD_PER_LUN,
 	.eh_abort_handler       = iscsi_eh_abort,
 	.eh_device_reset_handler= iscsi_eh_device_reset,
-	.eh_host_reset_handler	= iscsi_eh_host_reset,
+	.eh_target_reset_handler= iscsi_eh_target_reset,
 	.use_clustering         = DISABLE_CLUSTERING,
 	.slave_configure        = iscsi_tcp_slave_configure,
 	.proc_name		= "iscsi_tcp",
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 390781894be9..e3e57cce4886 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1367,7 +1367,7 @@ void iscsi_session_recovery_timedout(struct iscsi_cls_session *cls_session)
 }
 EXPORT_SYMBOL_GPL(iscsi_session_recovery_timedout);
 
-int iscsi_eh_host_reset(struct scsi_cmnd *sc)
+int iscsi_eh_target_reset(struct scsi_cmnd *sc)
 {
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
@@ -1381,7 +1381,7 @@ int iscsi_eh_host_reset(struct scsi_cmnd *sc)
 	spin_lock_bh(&amp;session-&gt;lock);
 	if (session-&gt;state == ISCSI_STATE_TERMINATE) {
 failed:
-		debug_scsi("failing host reset: session terminated "
+		debug_scsi("failing target reset: session terminated "
 			   "[CID %d age %d]\n", conn-&gt;id, session-&gt;age);
 		spin_unlock_bh(&amp;session-&gt;lock);
 		mutex_unlock(&amp;session-&gt;eh_mutex);
@@ -1396,7 +1396,7 @@ int iscsi_eh_host_reset(struct scsi_cmnd *sc)
 	 */
 	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 
-	debug_scsi("iscsi_eh_host_reset wait for relogin\n");
+	debug_scsi("iscsi_eh_target_reset wait for relogin\n");
 	wait_event_interruptible(conn-&gt;ehwait,
 				 session-&gt;state == ISCSI_STATE_TERMINATE ||
 				 session-&gt;state == ISCSI_STATE_LOGGED_IN ||
@@ -1408,14 +1408,14 @@ int iscsi_eh_host_reset(struct scsi_cmnd *sc)
 	spin_lock_bh(&amp;session-&gt;lock);
 	if (session-&gt;state == ISCSI_STATE_LOGGED_IN)
 		iscsi_session_printk(KERN_INFO, session,
-				     "host reset succeeded\n");
+				     "target reset succeeded\n");
 	else
 		goto failed;
 	spin_unlock_bh(&amp;session-&gt;lock);
 	mutex_unlock(&amp;session-&gt;eh_mutex);
 	return SUCCESS;
 }
-EXPORT_SYMBOL_GPL(iscsi_eh_host_reset);
+EXPORT_SYMBOL_GPL(iscsi_eh_target_reset);
 
 static void iscsi_tmf_timedout(unsigned long data)
 {
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 7d8cd159f592..61e53f14f7e1 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -313,7 +313,7 @@ struct iscsi_host {
  */
 extern int iscsi_change_queue_depth(struct scsi_device *sdev, int depth);
 extern int iscsi_eh_abort(struct scsi_cmnd *sc);
-extern int iscsi_eh_host_reset(struct scsi_cmnd *sc);
+extern int iscsi_eh_target_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
 extern int iscsi_queuecommand(struct scsi_cmnd *sc,
 			      void (*done)(struct scsi_cmnd *));</pre><hr><pre>commit 21536062d98938dfcfbae593a26c154e359749dc
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 24 11:46:11 2008 -0500

    [SCSI] iscsi class: fix endpoint id handling
    
    Some endpoint code was using unsigned int and some
    was using uint64_t. This converts it all to uint64_t.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index f9e45f83e467..4a803ebaf508 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -138,7 +138,7 @@ static ssize_t
 show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
 {
 	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
-	return sprintf(buf, "%u\n", ep-&gt;id);
+	return sprintf(buf, "%llu\n", (unsigned long long) ep-&gt;id);
 }
 static ISCSI_ATTR(ep, handle, S_IRUGO, show_ep_handle, NULL);
 
@@ -156,7 +156,7 @@ static struct attribute_group iscsi_endpoint_group = {
 static int iscsi_match_epid(struct device *dev, void *data)
 {
 	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
-	unsigned int *epid = (unsigned int *) data;
+	uint64_t *epid = (uint64_t *) data;
 
 	return *epid == ep-&gt;id;
 }
@@ -166,7 +166,7 @@ iscsi_create_endpoint(int dd_size)
 {
 	struct device *dev;
 	struct iscsi_endpoint *ep;
-	unsigned int id;
+	uint64_t id;
 	int err;
 
 	for (id = 1; id &lt; ISCSI_MAX_EPID; id++) {
@@ -187,7 +187,8 @@ iscsi_create_endpoint(int dd_size)
 
 	ep-&gt;id = id;
 	ep-&gt;dev.class = &amp;iscsi_endpoint_class;
-	snprintf(ep-&gt;dev.bus_id, BUS_ID_SIZE, "ep-%u", id);
+	snprintf(ep-&gt;dev.bus_id, BUS_ID_SIZE, "ep-%llu",
+		 (unsigned long long) id);
 	err = device_register(&amp;ep-&gt;dev);
         if (err)
                 goto free_ep;
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 8749d4d8e244..c667cc396545 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -208,7 +208,7 @@ extern void iscsi_host_for_each_session(struct Scsi_Host *shost,
 struct iscsi_endpoint {
 	void *dd_data;			/* LLD private data */
 	struct device dev;
-	unsigned int id;
+	uint64_t id;
 };
 
 /*</pre>
    <div class="pagination">
        <a href='5_20.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><span>[21]</span><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_22.html'>Next&gt;&gt;</a>
    <div>
</body>
