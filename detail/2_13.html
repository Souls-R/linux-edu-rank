<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_12.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><span>[13]</span><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_14.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4ed3350539aa931f58c939fcd803c7510584e143
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 13 16:15:38 2019 -0400

    USB: usbfs: Add a capability flag for runtime suspend
    
    The recent commit 7794f486ed0b ("usbfs: Add ioctls for runtime power
    management") neglected to add a corresponding capability flag.  This
    patch rectifies the omission.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Mayuresh Kulkarni &lt;mkulkarni@opensource.cirrus.com&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908131613490.1941-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 5db7b6dbcb44..24d4a801ca64 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -44,6 +44,12 @@
 
 #include "usb.h"
 
+#ifdef CONFIG_PM
+#define MAYBE_CAP_SUSPEND	USBDEVFS_CAP_SUSPEND
+#else
+#define MAYBE_CAP_SUSPEND	0
+#endif
+
 #define USB_MAXBUS			64
 #define USB_DEVICE_MAX			(USB_MAXBUS * 128)
 #define USB_SG_SIZE			16384 /* split-size for large txs */
@@ -2310,7 +2316,8 @@ static int proc_get_capabilities(struct usb_dev_state *ps, void __user *arg)
 
 	caps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM |
 			USBDEVFS_CAP_REAP_AFTER_DISCONNECT | USBDEVFS_CAP_MMAP |
-			USBDEVFS_CAP_DROP_PRIVILEGES | USBDEVFS_CAP_CONNINFO_EX;
+			USBDEVFS_CAP_DROP_PRIVILEGES |
+			USBDEVFS_CAP_CONNINFO_EX | MAYBE_CAP_SUSPEND;
 	if (!ps-&gt;dev-&gt;bus-&gt;no_stop_on_short)
 		caps |= USBDEVFS_CAP_BULK_CONTINUATION;
 	if (ps-&gt;dev-&gt;bus-&gt;sg_tablesize)
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index d24bbb6d3ca1..cf525cddeb94 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -158,6 +158,7 @@ struct usbdevfs_hub_portinfo {
 #define USBDEVFS_CAP_MMAP			0x20
 #define USBDEVFS_CAP_DROP_PRIVILEGES		0x40
 #define USBDEVFS_CAP_CONNINFO_EX		0x80
+#define USBDEVFS_CAP_SUSPEND			0x100
 
 /* USBDEVFS_DISCONNECT_CLAIM flags &amp; struct */
 </pre><hr><pre>commit 303911cfc5b95d33687d9046133ff184cf5043ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 12 16:11:07 2019 -0400

    USB: core: Fix races in character device registration and deregistraion
    
    The syzbot fuzzer has found two (!) races in the USB character device
    registration and deregistration routines.  This patch fixes the races.
    
    The first race results from the fact that usb_deregister_dev() sets
    usb_minors[intf-&gt;minor] to NULL before calling device_destroy() on the
    class device.  This leaves a window during which another thread can
    allocate the same minor number but will encounter a duplicate name
    error when it tries to register its own class device.  A typical error
    message in the system log would look like:
    
        sysfs: cannot create duplicate filename '/class/usbmisc/ldusb0'
    
    The patch fixes this race by destroying the class device first.
    
    The second race is in usb_register_dev().  When that routine runs, it
    first allocates a minor number, then drops minor_rwsem, and then
    creates the class device.  If the device creation fails, the minor
    number is deallocated and the whole routine returns an error.  But
    during the time while minor_rwsem was dropped, there is a window in
    which the minor number is allocated and so another thread can
    successfully open the device file.  Typically this results in
    use-after-free errors or invalid accesses when the other thread closes
    its open file reference, because the kernel then tries to release
    resources that were already deallocated when usb_register_dev()
    failed.  The patch fixes this race by keeping minor_rwsem locked
    throughout the entire routine.
    
    Reported-and-tested-by: syzbot+30cf45ebfe0b0c4847a1@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908121607590.1659-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/file.c b/drivers/usb/core/file.c
index 65de6f73b672..558890ada0e5 100644
--- a/drivers/usb/core/file.c
+++ b/drivers/usb/core/file.c
@@ -193,9 +193,10 @@ int usb_register_dev(struct usb_interface *intf,
 		intf-&gt;minor = minor;
 		break;
 	}
-	up_write(&amp;minor_rwsem);
-	if (intf-&gt;minor &lt; 0)
+	if (intf-&gt;minor &lt; 0) {
+		up_write(&amp;minor_rwsem);
 		return -EXFULL;
+	}
 
 	/* create a usb class device for this usb interface */
 	snprintf(name, sizeof(name), class_driver-&gt;name, minor - minor_base);
@@ -203,12 +204,11 @@ int usb_register_dev(struct usb_interface *intf,
 				      MKDEV(USB_MAJOR, minor), class_driver,
 				      "%s", kbasename(name));
 	if (IS_ERR(intf-&gt;usb_dev)) {
-		down_write(&amp;minor_rwsem);
 		usb_minors[minor] = NULL;
 		intf-&gt;minor = -1;
-		up_write(&amp;minor_rwsem);
 		retval = PTR_ERR(intf-&gt;usb_dev);
 	}
+	up_write(&amp;minor_rwsem);
 	return retval;
 }
 EXPORT_SYMBOL_GPL(usb_register_dev);
@@ -234,12 +234,12 @@ void usb_deregister_dev(struct usb_interface *intf,
 		return;
 
 	dev_dbg(&amp;intf-&gt;dev, "removing %d minor\n", intf-&gt;minor);
+	device_destroy(usb_class-&gt;class, MKDEV(USB_MAJOR, intf-&gt;minor));
 
 	down_write(&amp;minor_rwsem);
 	usb_minors[intf-&gt;minor] = NULL;
 	up_write(&amp;minor_rwsem);
 
-	device_destroy(usb_class-&gt;class, MKDEV(USB_MAJOR, intf-&gt;minor));
 	intf-&gt;usb_dev = NULL;
 	intf-&gt;minor = -1;
 	destroy_usb_class();</pre><hr><pre>commit 7794f486ed0b1fa8022dd0a27b9babf86a46d1cf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 7 10:29:50 2019 -0400

    usbfs: Add ioctls for runtime power management
    
    It has been requested that usbfs should implement runtime power
    management, instead of forcing the device to remain at full power as
    long as the device file is open.  This patch introduces that new
    feature.
    
    It does so by adding three new usbfs ioctls:
    
            USBDEVFS_FORBID_SUSPEND: Prevents the device from going into
            runtime suspend (and causes a resume if the device is already
            suspended).
    
            USBDEVFS_ALLOW_SUSPEND: Allows the device to go into runtime
            suspend.  Some time may elapse before the device actually is
            suspended, depending on things like the autosuspend delay.
    
            USBDEVFS_WAIT_FOR_RESUME: Blocks until the call is interrupted
            by a signal or at least one runtime resume has occurred since
            the most recent ALLOW_SUSPEND ioctl call (which may mean
            immediately, even if the device is currently suspended).  In
            the latter case, the device is prevented from suspending again
            just as if FORBID_SUSPEND was called before the ioctl returns.
    
    For backward compatibility, when the device file is first opened
    runtime suspends are forbidden.  The userspace program can then allow
    suspends whenever it wants, and either resume the device directly (by
    forbidding suspends again) or wait for a resume from some other source
    (such as a remote wakeup).  URBs submitted to a suspended device will
    fail or will complete with an appropriate error code.
    
    This combination of ioctls is sufficient for user programs to have
    nearly the same degree of control over a device's runtime power
    behavior as kernel drivers do.
    
    Still lacking is documentation for the new ioctls.  I intend to add it
    later, after the existing documentation for the usbfs userspace API is
    straightened out into a reasonable form.
    
    Suggested-by: Mayuresh Kulkarni &lt;mkulkarni@opensource.cirrus.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908071013220.1514-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b265ab5405f9..cdd34dcb2395 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -48,6 +48,9 @@
 #define USB_DEVICE_MAX			(USB_MAXBUS * 128)
 #define USB_SG_SIZE			16384 /* split-size for large txs */
 
+/* Mutual exclusion for ps-&gt;list in resume vs. release and remove */
+static DEFINE_MUTEX(usbfs_mutex);
+
 struct usb_dev_state {
 	struct list_head list;      /* state list */
 	struct usb_device *dev;
@@ -57,14 +60,17 @@ struct usb_dev_state {
 	struct list_head async_completed;
 	struct list_head memory_list;
 	wait_queue_head_t wait;     /* wake up if a request completed */
+	wait_queue_head_t wait_for_resume;   /* wake up upon runtime resume */
 	unsigned int discsignr;
 	struct pid *disc_pid;
 	const struct cred *cred;
 	sigval_t disccontext;
 	unsigned long ifclaimed;
 	u32 disabled_bulk_eps;
-	bool privileges_dropped;
 	unsigned long interface_allowed_mask;
+	int not_yet_resumed;
+	bool suspend_allowed;
+	bool privileges_dropped;
 };
 
 struct usb_memory {
@@ -694,9 +700,7 @@ static void driver_disconnect(struct usb_interface *intf)
 	destroy_async_on_interface(ps, ifnum);
 }
 
-/* The following routines are merely placeholders.  There is no way
- * to inform a user task about suspend or resumes.
- */
+/* We don't care about suspend/resume of claimed interfaces */
 static int driver_suspend(struct usb_interface *intf, pm_message_t msg)
 {
 	return 0;
@@ -707,12 +711,32 @@ static int driver_resume(struct usb_interface *intf)
 	return 0;
 }
 
+/* The following routines apply to the entire device, not interfaces */
+void usbfs_notify_suspend(struct usb_device *udev)
+{
+	/* We don't need to handle this */
+}
+
+void usbfs_notify_resume(struct usb_device *udev)
+{
+	struct usb_dev_state *ps;
+
+	/* Protect against simultaneous remove or release */
+	mutex_lock(&amp;usbfs_mutex);
+	list_for_each_entry(ps, &amp;udev-&gt;filelist, list) {
+		WRITE_ONCE(ps-&gt;not_yet_resumed, 0);
+		wake_up_all(&amp;ps-&gt;wait_for_resume);
+	}
+	mutex_unlock(&amp;usbfs_mutex);
+}
+
 struct usb_driver usbfs_driver = {
 	.name =		"usbfs",
 	.probe =	driver_probe,
 	.disconnect =	driver_disconnect,
 	.suspend =	driver_suspend,
 	.resume =	driver_resume,
+	.supports_autosuspend = 1,
 };
 
 static int claimintf(struct usb_dev_state *ps, unsigned int ifnum)
@@ -997,9 +1021,12 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	INIT_LIST_HEAD(&amp;ps-&gt;async_completed);
 	INIT_LIST_HEAD(&amp;ps-&gt;memory_list);
 	init_waitqueue_head(&amp;ps-&gt;wait);
+	init_waitqueue_head(&amp;ps-&gt;wait_for_resume);
 	ps-&gt;disc_pid = get_pid(task_pid(current));
 	ps-&gt;cred = get_current_cred();
 	smp_wmb();
+
+	/* Can't race with resume; the device is already active */
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
 	usb_unlock_device(dev);
@@ -1025,7 +1052,10 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	usb_lock_device(dev);
 	usb_hub_release_all_ports(dev, ps);
 
+	/* Protect against simultaneous resume */
+	mutex_lock(&amp;usbfs_mutex);
 	list_del_init(&amp;ps-&gt;list);
+	mutex_unlock(&amp;usbfs_mutex);
 
 	for (ifnum = 0; ps-&gt;ifclaimed &amp;&amp; ifnum &lt; 8*sizeof(ps-&gt;ifclaimed);
 			ifnum++) {
@@ -1033,7 +1063,8 @@ static int usbdev_release(struct inode *inode, struct file *file)
 			releaseintf(ps, ifnum);
 	}
 	destroy_all_async(ps);
-	usb_autosuspend_device(dev);
+	if (!ps-&gt;suspend_allowed)
+		usb_autosuspend_device(dev);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
 	put_pid(ps-&gt;disc_pid);
@@ -2384,6 +2415,47 @@ static int proc_drop_privileges(struct usb_dev_state *ps, void __user *arg)
 	return 0;
 }
 
+static int proc_forbid_suspend(struct usb_dev_state *ps)
+{
+	int ret = 0;
+
+	if (ps-&gt;suspend_allowed) {
+		ret = usb_autoresume_device(ps-&gt;dev);
+		if (ret == 0)
+			ps-&gt;suspend_allowed = false;
+		else if (ret != -ENODEV)
+			ret = -EIO;
+	}
+	return ret;
+}
+
+static int proc_allow_suspend(struct usb_dev_state *ps)
+{
+	if (!connected(ps))
+		return -ENODEV;
+
+	WRITE_ONCE(ps-&gt;not_yet_resumed, 1);
+	if (!ps-&gt;suspend_allowed) {
+		usb_autosuspend_device(ps-&gt;dev);
+		ps-&gt;suspend_allowed = true;
+	}
+	return 0;
+}
+
+static int proc_wait_for_resume(struct usb_dev_state *ps)
+{
+	int ret;
+
+	usb_unlock_device(ps-&gt;dev);
+	ret = wait_event_interruptible(ps-&gt;wait_for_resume,
+			READ_ONCE(ps-&gt;not_yet_resumed) == 0);
+	usb_lock_device(ps-&gt;dev);
+
+	if (ret != 0)
+		return -EINTR;
+	return proc_forbid_suspend(ps);
+}
+
 /*
  * NOTE:  All requests here that have interface numbers as parameters
  * are assuming that somehow the configuration has been prevented from
@@ -2578,6 +2650,15 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 	case USBDEVFS_GET_SPEED:
 		ret = ps-&gt;dev-&gt;speed;
 		break;
+	case USBDEVFS_FORBID_SUSPEND:
+		ret = proc_forbid_suspend(ps);
+		break;
+	case USBDEVFS_ALLOW_SUSPEND:
+		ret = proc_allow_suspend(ps);
+		break;
+	case USBDEVFS_WAIT_FOR_RESUME:
+		ret = proc_wait_for_resume(ps);
+		break;
 	}
 
 	/* Handle variable-length commands */
@@ -2651,15 +2732,20 @@ static void usbdev_remove(struct usb_device *udev)
 {
 	struct usb_dev_state *ps;
 
+	/* Protect against simultaneous resume */
+	mutex_lock(&amp;usbfs_mutex);
 	while (!list_empty(&amp;udev-&gt;filelist)) {
 		ps = list_entry(udev-&gt;filelist.next, struct usb_dev_state, list);
 		destroy_all_async(ps);
 		wake_up_all(&amp;ps-&gt;wait);
+		WRITE_ONCE(ps-&gt;not_yet_resumed, 0);
+		wake_up_all(&amp;ps-&gt;wait_for_resume);
 		list_del_init(&amp;ps-&gt;list);
 		if (ps-&gt;discsignr)
 			kill_pid_usb_asyncio(ps-&gt;discsignr, EPIPE, ps-&gt;disccontext,
 					     ps-&gt;disc_pid, ps-&gt;cred);
 	}
+	mutex_unlock(&amp;usbfs_mutex);
 }
 
 static int usbdev_notify(struct notifier_block *self,
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 1ac9c1e5f773..38f8b3e31762 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -257,6 +257,8 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	else
 		rc = usb_port_suspend(udev, msg);
 
+	if (rc == 0)
+		usbfs_notify_suspend(udev);
 	return rc;
 }
 
@@ -273,6 +275,9 @@ static int generic_resume(struct usb_device *udev, pm_message_t msg)
 		rc = hcd_bus_resume(udev, msg);
 	else
 		rc = usb_port_resume(udev, msg);
+
+	if (rc == 0)
+		usbfs_notify_resume(udev);
 	return rc;
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index bd8d01f85a13..2932d1ec5def 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -95,6 +95,9 @@ extern int usb_runtime_idle(struct device *dev);
 extern int usb_enable_usb2_hardware_lpm(struct usb_device *udev);
 extern int usb_disable_usb2_hardware_lpm(struct usb_device *udev);
 
+extern void usbfs_notify_suspend(struct usb_device *udev);
+extern void usbfs_notify_resume(struct usb_device *udev);
+
 #else
 
 static inline int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index 78efe870c2b7..d24bbb6d3ca1 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -223,5 +223,8 @@ struct usbdevfs_streams {
  * extending size of the data returned.
  */
 #define USBDEVFS_CONNINFO_EX(len)  _IOC(_IOC_READ, 'U', 32, len)
+#define USBDEVFS_FORBID_SUSPEND    _IO('U', 33)
+#define USBDEVFS_ALLOW_SUSPEND     _IO('U', 34)
+#define USBDEVFS_WAIT_FOR_RESUME   _IO('U', 35)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */</pre><hr><pre>commit 257adc0fbe9f0a26695f4d68bdbf2886f5a3ecd0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 25 16:00:26 2019 -0400

    USB: core: Fix compiler warnings in devio.c
    
    In the current kernel, devio.c generates a number of compiler warnings
    about taking the address of a member of a packed structure.  The
    warnings all look like this one:
    
            drivers/usb/core/devio.c: In function ‘proc_do_submiturb’:
            drivers/usb/core/devio.c:1489:43: warning: taking address of packed member of ‘struct usb_ctrlrequest’ may result in an unaligned pointer value [-Waddress-of-packed-member]
             1489 |   if (uurb-&gt;buffer_length &lt; (le16_to_cpup(&amp;dr-&gt;wLength) + 8)) {
                  |                                           ^~~~~~~~~~~~
    
    These warnings can easily be eliminated by changing various
    le16_to_cpup() calls to use le16_to_cpu() instead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 0100a54165cd..a951ce69f10e 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1510,15 +1510,15 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 			ret = -EFAULT;
 			goto error;
 		}
-		if (uurb-&gt;buffer_length &lt; (le16_to_cpup(&amp;dr-&gt;wLength) + 8)) {
+		if (uurb-&gt;buffer_length &lt; (le16_to_cpu(dr-&gt;wLength) + 8)) {
 			ret = -EINVAL;
 			goto error;
 		}
 		ret = check_ctrlrecip(ps, dr-&gt;bRequestType, dr-&gt;bRequest,
-				      le16_to_cpup(&amp;dr-&gt;wIndex));
+				      le16_to_cpu(dr-&gt;wIndex));
 		if (ret)
 			goto error;
-		uurb-&gt;buffer_length = le16_to_cpup(&amp;dr-&gt;wLength);
+		uurb-&gt;buffer_length = le16_to_cpu(dr-&gt;wLength);
 		uurb-&gt;buffer += 8;
 		if ((dr-&gt;bRequestType &amp; USB_DIR_IN) &amp;&amp; uurb-&gt;buffer_length) {
 			is_in = 1;
@@ -1533,9 +1533,9 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 			"bRequest=%02x wValue=%04x "
 			"wIndex=%04x wLength=%04x\n",
 			dr-&gt;bRequestType, dr-&gt;bRequest,
-			__le16_to_cpup(&amp;dr-&gt;wValue),
-			__le16_to_cpup(&amp;dr-&gt;wIndex),
-			__le16_to_cpup(&amp;dr-&gt;wLength));
+			__le16_to_cpu(dr-&gt;wValue),
+			__le16_to_cpu(dr-&gt;wIndex),
+			__le16_to_cpu(dr-&gt;wLength));
 		u = sizeof(struct usb_ctrlrequest);
 		break;
 </pre><hr><pre>commit ffed60971f3d95923b99ea970862c6ab6a22c20f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 25 16:03:58 2019 -0400

    USB: core: Remove usbfs_mutex
    
    Commit 4a2a8a2cce86 ("usbfs: private mutex for open, release, and
    remove") is now obsolete.  The commit was created back when we had
    to handle both usbfs device nodes and the old usbdevfs filesystem
    (/proc/bus/usb/), but usbdevfs no longer exists.
    
    This means there's no longer any need to hold a mutex during two
    separate removal operations (and thus during an entire notifier chain
    call).  Furthermore, the one remaining remove/release pair doesn't
    race with open thanks to the synchronization provided by the device
    model core in bus_find_device().  Remove and release don't race with
    each other because they both run with the device lock held.
    
    The upshot is that usbfs_mutex isn't needed any more.  This patch
    removes it entirely.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 186790b06b11..0100a54165cd 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -48,9 +48,6 @@
 #define USB_DEVICE_MAX			(USB_MAXBUS * 128)
 #define USB_SG_SIZE			16384 /* split-size for large txs */
 
-/* Mutual exclusion for removal, open, and release */
-DEFINE_MUTEX(usbfs_mutex);
-
 struct usb_dev_state {
 	struct list_head list;      /* state list */
 	struct usb_device *dev;
@@ -979,15 +976,9 @@ static int usbdev_open(struct inode *inode, struct file *file)
 
 	ret = -ENODEV;
 
-	/* Protect against simultaneous removal or release */
-	mutex_lock(&amp;usbfs_mutex);
-
 	/* usbdev device-node */
 	if (imajor(inode) == USB_DEVICE_MAJOR)
 		dev = usbdev_lookup_by_devt(inode-&gt;i_rdev);
-
-	mutex_unlock(&amp;usbfs_mutex);
-
 	if (!dev)
 		goto out_free_ps;
 
diff --git a/drivers/usb/core/notify.c b/drivers/usb/core/notify.c
index ab474b11523e..e6143663778f 100644
--- a/drivers/usb/core/notify.c
+++ b/drivers/usb/core/notify.c
@@ -53,11 +53,8 @@ void usb_notify_add_device(struct usb_device *udev)
 
 void usb_notify_remove_device(struct usb_device *udev)
 {
-	/* Protect against simultaneous usbfs open */
-	mutex_lock(&amp;usbfs_mutex);
 	blocking_notifier_call_chain(&amp;usb_notifier_list,
 			USB_DEVICE_REMOVE, udev);
-	mutex_unlock(&amp;usbfs_mutex);
 }
 
 void usb_notify_add_bus(struct usb_bus *ubus)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index d95a5358f73d..bd8d01f85a13 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -169,7 +169,6 @@ extern const struct attribute_group *usb_device_groups[];
 extern const struct attribute_group *usb_interface_groups[];
 
 /* usbfs stuff */
-extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;
 extern const struct file_operations usbfs_devices_fops;
 extern const struct file_operations usbdev_file_operations;</pre><hr><pre>commit 6e41e2257f1094acc37618bf6c856115374c6922
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 20 10:44:21 2019 -0400

    p54usb: Fix race between disconnect and firmware loading
    
    The syzbot fuzzer found a bug in the p54 USB wireless driver.  The
    issue involves a race between disconnect and the firmware-loader
    callback routine, and it has several aspects.
    
    One big problem is that when the firmware can't be loaded, the
    callback routine tries to unbind the driver from the USB _device_ (by
    calling device_release_driver) instead of from the USB _interface_ to
    which it is actually bound (by calling usb_driver_release_interface).
    
    The race involves access to the private data structure.  The driver's
    disconnect handler waits for a completion that is signalled by the
    firmware-loader callback routine.  As soon as the completion is
    signalled, you have to assume that the private data structure may have
    been deallocated by the disconnect handler -- even if the firmware was
    loaded without errors.  However, the callback routine does access the
    private data several times after that point.
    
    Another problem is that, in order to ensure that the USB device
    structure hasn't been freed when the callback routine runs, the driver
    takes a reference to it.  This isn't good enough any more, because now
    that the callback routine calls usb_driver_release_interface, it has
    to ensure that the interface structure hasn't been freed.
    
    Finally, the driver takes an unnecessary reference to the USB device
    structure in the probe function and drops the reference in the
    disconnect handler.  This extra reference doesn't accomplish anything,
    because the USB core already guarantees that a device structure won't
    be deallocated while a driver is still bound to any of its interfaces.
    
    To fix these problems, this patch makes the following changes:
    
            Call usb_driver_release_interface() rather than
            device_release_driver().
    
            Don't signal the completion until after the important
            information has been copied out of the private data structure,
            and don't refer to the private data at all thereafter.
    
            Lock udev (the interface's parent) before unbinding the driver
            instead of locking udev-&gt;parent.
    
            During the firmware loading process, take a reference to the
            USB interface instead of the USB device.
    
            Don't take an unnecessary reference to the device during probe
            (and then don't drop it during disconnect).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+200d4bb11b23d929335f@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Christian Lamparter &lt;chunkeey@gmail.com&gt;
    Signed-off-by: Kalle Valo &lt;kvalo@codeaurora.org&gt;

diff --git a/drivers/net/wireless/intersil/p54/p54usb.c b/drivers/net/wireless/intersil/p54/p54usb.c
index b0b86f701061..15661da6eedc 100644
--- a/drivers/net/wireless/intersil/p54/p54usb.c
+++ b/drivers/net/wireless/intersil/p54/p54usb.c
@@ -33,6 +33,8 @@ MODULE_ALIAS("prism54usb");
 MODULE_FIRMWARE("isl3886usb");
 MODULE_FIRMWARE("isl3887usb");
 
+static struct usb_driver p54u_driver;
+
 /*
  * Note:
  *
@@ -921,9 +923,9 @@ static void p54u_load_firmware_cb(const struct firmware *firmware,
 {
 	struct p54u_priv *priv = context;
 	struct usb_device *udev = priv-&gt;udev;
+	struct usb_interface *intf = priv-&gt;intf;
 	int err;
 
-	complete(&amp;priv-&gt;fw_wait_load);
 	if (firmware) {
 		priv-&gt;fw = firmware;
 		err = p54u_start_ops(priv);
@@ -932,26 +934,22 @@ static void p54u_load_firmware_cb(const struct firmware *firmware,
 		dev_err(&amp;udev-&gt;dev, "Firmware not found.\n");
 	}
 
-	if (err) {
-		struct device *parent = priv-&gt;udev-&gt;dev.parent;
-
-		dev_err(&amp;udev-&gt;dev, "failed to initialize device (%d)\n", err);
-
-		if (parent)
-			device_lock(parent);
+	complete(&amp;priv-&gt;fw_wait_load);
+	/*
+	 * At this point p54u_disconnect may have already freed
+	 * the "priv" context. Do not use it anymore!
+	 */
+	priv = NULL;
 
-		device_release_driver(&amp;udev-&gt;dev);
-		/*
-		 * At this point p54u_disconnect has already freed
-		 * the "priv" context. Do not use it anymore!
-		 */
-		priv = NULL;
+	if (err) {
+		dev_err(&amp;intf-&gt;dev, "failed to initialize device (%d)\n", err);
 
-		if (parent)
-			device_unlock(parent);
+		usb_lock_device(udev);
+		usb_driver_release_interface(&amp;p54u_driver, intf);
+		usb_unlock_device(udev);
 	}
 
-	usb_put_dev(udev);
+	usb_put_intf(intf);
 }
 
 static int p54u_load_firmware(struct ieee80211_hw *dev,
@@ -972,14 +970,14 @@ static int p54u_load_firmware(struct ieee80211_hw *dev,
 	dev_info(&amp;priv-&gt;udev-&gt;dev, "Loading firmware file %s\n",
 	       p54u_fwlist[i].fw);
 
-	usb_get_dev(udev);
+	usb_get_intf(intf);
 	err = request_firmware_nowait(THIS_MODULE, 1, p54u_fwlist[i].fw,
 				      device, GFP_KERNEL, priv,
 				      p54u_load_firmware_cb);
 	if (err) {
 		dev_err(&amp;priv-&gt;udev-&gt;dev, "(p54usb) cannot load firmware %s "
 					  "(%d)!\n", p54u_fwlist[i].fw, err);
-		usb_put_dev(udev);
+		usb_put_intf(intf);
 	}
 
 	return err;
@@ -1011,8 +1009,6 @@ static int p54u_probe(struct usb_interface *intf,
 	skb_queue_head_init(&amp;priv-&gt;rx_queue);
 	init_usb_anchor(&amp;priv-&gt;submitted);
 
-	usb_get_dev(udev);
-
 	/* really lazy and simple way of figuring out if we're a 3887 */
 	/* TODO: should just stick the identification in the device table */
 	i = intf-&gt;altsetting-&gt;desc.bNumEndpoints;
@@ -1053,10 +1049,8 @@ static int p54u_probe(struct usb_interface *intf,
 		priv-&gt;upload_fw = p54u_upload_firmware_net2280;
 	}
 	err = p54u_load_firmware(dev, intf);
-	if (err) {
-		usb_put_dev(udev);
+	if (err)
 		p54_free_common(dev);
-	}
 	return err;
 }
 
@@ -1072,7 +1066,6 @@ static void p54u_disconnect(struct usb_interface *intf)
 	wait_for_completion(&amp;priv-&gt;fw_wait_load);
 	p54_unregister_common(dev);
 
-	usb_put_dev(interface_to_usbdev(intf));
 	release_firmware(priv-&gt;fw);
 	p54_free_common(dev);
 }</pre><hr><pre>commit 4289ee7d5a8343eaddd0986f8fb492868e2f546f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 20 11:55:58 2019 -0400

    tools/memory-model: Improve data-race detection
    
    Herbert Xu recently reported a problem concerning RCU and compiler
    barriers.  In the course of discussing the problem, he put forth a
    litmus test which illustrated a serious defect in the Linux Kernel
    Memory Model's data-race-detection code [1].
    
    The defect was that the LKMM assumed visibility and executes-before
    ordering of plain accesses had to be mediated by marked accesses.  In
    Herbert's litmus test this wasn't so, and the LKMM claimed the litmus
    test was allowed and contained a data race although neither is true.
    
    In fact, plain accesses can be ordered by fences even in the absence
    of marked accesses.  In most cases this doesn't matter, because most
    fences only order accesses within a single thread.  But the rcu-fence
    relation is different; it can order (and induce visibility between)
    accesses in different threads -- events which otherwise might be
    concurrent.  This makes it relevant to data-race detection.
    
    This patch makes two changes to the memory model to incorporate the
    new insight:
    
            If a store is separated by a fence from another access,
            the store is necessarily visible to the other access (as
            reflected in the ww-vis and wr-vis relations).  Similarly,
            if a load is separated by a fence from another access then
            the load necessarily executes before the other access (as
            reflected in the rw-xbstar relation).
    
            If a store is separated by a strong fence from a marked access
            then it is necessarily visible to any access that executes
            after the marked access (as reflected in the ww-vis and wr-vis
            relations).
    
    With these changes, the LKMM gives the desired result for Herbert's
    litmus test and other related ones [2].
    
    [1]     https://lore.kernel.org/lkml/Pine.LNX.4.44L0.1906041026570.1731-100000@iolanthe.rowland.org/
    
    [2]     https://github.com/paulmckrcu/litmus/blob/master/manual/plain/C-S-rcunoderef-1.litmus
            https://github.com/paulmckrcu/litmus/blob/master/manual/plain/C-S-rcunoderef-2.litmus
            https://github.com/paulmckrcu/litmus/blob/master/manual/plain/C-S-rcunoderef-3.litmus
            https://github.com/paulmckrcu/litmus/blob/master/manual/plain/C-S-rcunoderef-4.litmus
            https://github.com/paulmckrcu/litmus/blob/master/manual/plain/strong-vis.litmus
    
    Reported-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Andrea Parri &lt;andrea.parri@amarulasolutions.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.ibm.com&gt;
    Tested-by: Akira Yokosawa &lt;akiyks@gmail.com&gt;

diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index ca2f4297b4e6..ea2ff4b94074 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -179,9 +179,11 @@ let r-post-bounded = (nonrw-fence | ([~Noreturn] ; fencerel(Rmb) ; [R4rmb]))? ;
 	[Marked]
 
 (* Visibility and executes-before for plain accesses *)
-let ww-vis = w-post-bounded ; vis ; w-pre-bounded
-let wr-vis = w-post-bounded ; vis ; r-pre-bounded
-let rw-xbstar = r-post-bounded ; xbstar ; w-pre-bounded
+let ww-vis = fence | (strong-fence ; xbstar ; w-pre-bounded) |
+	(w-post-bounded ; vis ; w-pre-bounded)
+let wr-vis = fence | (strong-fence ; xbstar ; r-pre-bounded) |
+	(w-post-bounded ; vis ; r-pre-bounded)
+let rw-xbstar = fence | (r-post-bounded ; xbstar ; w-pre-bounded)
 
 (* Potential races *)
 let pre-race = ext &amp; ((Plain * M) | ((M \ IW) * Plain))</pre><hr><pre>commit 15aa25cbf0ccc4bd63ed6f2a8065decb7f5e6f89
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 20 11:55:46 2019 -0400

    tools/memory-model: Change definition of rcu-fence
    
    The rcu-fence relation in the Linux Kernel Memory Model is not well
    named.  It doesn't act like any other fence relation, in that it does
    not relate events before a fence to events after that fence.  All it
    does is relate certain RCU events to one another (those that are
    ordered by the RCU Guarantee); this induces an actual
    strong-fence-like relation linking events preceding the first RCU
    event to those following the second.
    
    This patch renames rcu-fence, now called rcu-order.  It adds a new
    definition of rcu-fence, something which should have been present all
    along because it is used in the rb relation.  And it modifies the
    fence and strong-fence relations by making them incorporate the new
    rcu-fence.
    
    As a result of this change, there is no longer any need to define
    full-fence in the section for detecting data races.  It can simply be
    replaced by the updated strong-fence relation.
    
    This change should have no effect on the operation of the memory model.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Andrea Parri &lt;andrea.parri@amarulasolutions.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.ibm.com&gt;

diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index 8b61218c99fd..ca2f4297b4e6 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -122,24 +122,28 @@ let rcu-link = po? ; hb* ; pb* ; prop ; po
 
 (*
  * Any sequence containing at least as many grace periods as RCU read-side
- * critical sections (joined by rcu-link) acts as a generalized strong fence.
+ * critical sections (joined by rcu-link) induces order like a generalized
+ * inter-CPU strong fence.
  * Likewise for SRCU grace periods and read-side critical sections, provided
  * the synchronize_srcu() and srcu_read_[un]lock() calls refer to the same
  * struct srcu_struct location.
  *)
-let rec rcu-fence = rcu-gp | srcu-gp |
+let rec rcu-order = rcu-gp | srcu-gp |
 	(rcu-gp ; rcu-link ; rcu-rscsi) |
 	((srcu-gp ; rcu-link ; srcu-rscsi) &amp; loc) |
 	(rcu-rscsi ; rcu-link ; rcu-gp) |
 	((srcu-rscsi ; rcu-link ; srcu-gp) &amp; loc) |
-	(rcu-gp ; rcu-link ; rcu-fence ; rcu-link ; rcu-rscsi) |
-	((srcu-gp ; rcu-link ; rcu-fence ; rcu-link ; srcu-rscsi) &amp; loc) |
-	(rcu-rscsi ; rcu-link ; rcu-fence ; rcu-link ; rcu-gp) |
-	((srcu-rscsi ; rcu-link ; rcu-fence ; rcu-link ; srcu-gp) &amp; loc) |
-	(rcu-fence ; rcu-link ; rcu-fence)
+	(rcu-gp ; rcu-link ; rcu-order ; rcu-link ; rcu-rscsi) |
+	((srcu-gp ; rcu-link ; rcu-order ; rcu-link ; srcu-rscsi) &amp; loc) |
+	(rcu-rscsi ; rcu-link ; rcu-order ; rcu-link ; rcu-gp) |
+	((srcu-rscsi ; rcu-link ; rcu-order ; rcu-link ; srcu-gp) &amp; loc) |
+	(rcu-order ; rcu-link ; rcu-order)
+let rcu-fence = po ; rcu-order ; po?
+let fence = fence | rcu-fence
+let strong-fence = strong-fence | rcu-fence
 
 (* rb orders instructions just as pb does *)
-let rb = prop ; po ; rcu-fence ; po? ; hb* ; pb* ; [Marked]
+let rb = prop ; rcu-fence ; hb* ; pb* ; [Marked]
 
 irreflexive rb as rcu
 
@@ -163,9 +167,8 @@ flag ~empty mixed-accesses as mixed-accesses
 
 (* Executes-before and visibility *)
 let xbstar = (hb | pb | rb)*
-let full-fence = strong-fence | (po ; rcu-fence ; po?)
 let vis = cumul-fence* ; rfe? ; [Marked] ;
-	((full-fence ; [Marked] ; xbstar) | (xbstar &amp; int))
+	((strong-fence ; [Marked] ; xbstar) | (xbstar &amp; int))
 
 (* Boundaries for lifetimes of plain accesses *)
 let w-pre-bounded = [Marked] ; (addr | fence)?</pre><hr><pre>commit f9de417121001879d92a86960647adb06b5b81bf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 20 11:55:36 2019 -0400

    tools/memory-model: Expand definition of barrier
    
    Commit 66be4e66a7f4 ("rcu: locking and unlocking need to always be at
    least barriers") added compiler barriers back into rcu_read_lock() and
    rcu_read_unlock().  Furthermore, srcu_read_lock() and
    srcu_read_unlock() have always contained compiler barriers.
    
    The Linux Kernel Memory Model ought to know about these barriers.
    This patch adds them into the memory model.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Andrea Parri &lt;andrea.parri@amarulasolutions.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.ibm.com&gt;

diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index 36d367054811..8b61218c99fd 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -45,7 +45,8 @@ let strong-fence = mb | gp
 let nonrw-fence = strong-fence | po-rel | acq-po
 let fence = nonrw-fence | wmb | rmb
 let barrier = fencerel(Barrier | Rmb | Wmb | Mb | Sync-rcu | Sync-srcu |
-		Before-atomic | After-atomic | Acquire | Release) |
+		Before-atomic | After-atomic | Acquire | Release |
+		Rcu-lock | Rcu-unlock | Srcu-lock | Srcu-unlock) |
 	(po ; [Release]) | ([Acquire] ; po)
 
 (**********************************)</pre><hr><pre>commit 2966f8d440c3d2b6ef6c44093a9f9c42701a077a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 3 13:13:44 2019 -0400

    Documentation: atomic_t.txt: Explain ordering provided by smp_mb__{before,after}_atomic()
    
    The description of smp_mb__before_atomic() and smp_mb__after_atomic()
    in Documentation/atomic_t.txt is slightly terse and misleading.  It
    does not clearly state which other instructions are ordered by these
    barriers.
    
    This improves the text to make the actual ordering implications clear,
    and also to explain how these barriers differ from a RELEASE or
    ACQUIRE ordering.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Jonathan Corbet &lt;corbet@lwn.net&gt;
    Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Acked-by: Andrea Parri &lt;andrea.parri@amarulasolutions.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.ibm.com&gt;

diff --git a/Documentation/atomic_t.txt b/Documentation/atomic_t.txt
index dca3fb0554db..b3afe69d03a1 100644
--- a/Documentation/atomic_t.txt
+++ b/Documentation/atomic_t.txt
@@ -187,8 +187,14 @@ The barriers:
 
   smp_mb__{before,after}_atomic()
 
-only apply to the RMW ops and can be used to augment/upgrade the ordering
-inherent to the used atomic op. These barriers provide a full smp_mb().
+only apply to the RMW atomic ops and can be used to augment/upgrade the
+ordering inherent to the op. These barriers act almost like a full smp_mb():
+smp_mb__before_atomic() orders all earlier accesses against the RMW op
+itself and all accesses following it, and smp_mb__after_atomic() orders all
+later accesses against the RMW op and all accesses preceding it. However,
+accesses between the smp_mb__{before,after}_atomic() and the RMW op are not
+ordered, so it is advisable to place the barrier right next to the RMW atomic
+op whenever possible.
 
 These helper barriers exist because architectures have varying implicit
 ordering on their SMP atomic primitives. For example our TSO architectures
@@ -212,7 +218,9 @@ Further, while something like:
   atomic_dec(&amp;X);
 
 is a 'typical' RELEASE pattern, the barrier is strictly stronger than
-a RELEASE. Similarly for something like:
+a RELEASE because it orders preceding instructions against both the read
+and write parts of the atomic_dec(), and against all following instructions
+as well. Similarly, something like:
 
   atomic_inc(&amp;X);
   smp_mb__after_atomic();
@@ -244,7 +252,8 @@ strictly stronger than ACQUIRE. As illustrated:
 
 This should not happen; but a hypothetical atomic_inc_acquire() --
 (void)atomic_fetch_inc_acquire() for instance -- would allow the outcome,
-since then:
+because it would not order the W part of the RMW against the following
+WRITE_ONCE.  Thus:
 
   P1			P2
 </pre>
    <div class="pagination">
        <a href='2_12.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><span>[13]</span><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_14.html'>Next&gt;&gt;</a>
    <div>
</body>
