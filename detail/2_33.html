<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_32.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><span>[33]</span><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_34.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2b90f01b219e390e1f1bf68dd7a2333efb3e3eff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:21 2013 -0400

    USB: EHCI: compute full-speed bandwidth usage correctly
    
    Although the bandwidth statistics maintained by ehci-hcd show up only
    in the /sys/kernel/debug/usb/devices file, they ought to be calculated
    correctly.  The calculation for full-speed isochronous endpoints is
    wrong; it mistakenly yields bytes per microframe instead of bytes per
    frame.  The "interval" value, which is in frames, should not be
    converted to microframes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 34b5945fafa5..4b0903c6c616 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1055,7 +1055,7 @@ iso_stream_init (
 		} else
 			stream-&gt;raw_mask = smask_out [hs_transfers - 1];
 		bandwidth = stream-&gt;usecs + stream-&gt;c_usecs;
-		bandwidth /= interval &lt;&lt; 3;
+		bandwidth /= interval;
 
 		/* stream-&gt;splits gets created from raw_mask later */
 		stream-&gt;address = cpu_to_hc32(ehci, addr);</pre><hr><pre>commit e24371a6be9c5c00b56607bd425cc409cba75d88
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:12 2013 -0400

    USB: EHCI: check the right uframes for CSPLIT
    
    The check_intr_schedule() routine in ehci-hcd looks at the wrong
    microframes when checking to see if a full-speed or low-speed
    interrupt endpoint will fit in the periodic schedule.  If the
    Start-Split transaction is scheduled for microframe N then the
    Complete-Split transactions get scheduled for microframes N+2, N+3, and
    N+4.  However the code considers N+1, N+2, and N+3 instead.
    
    This patch fixes the limits on the "for" loop and also improves the
    use of whitespace.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index dcbaad94d607..34b5945fafa5 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -761,7 +761,7 @@ static int check_intr_schedule (
 		unsigned i;
 
 		/* TODO : this may need FSTN for SSPLIT in uframe 5. */
-		for (i=uframe+1; i&lt;8 &amp;&amp; i&lt;uframe+4; i++)
+		for (i = uframe+2; i &lt; 8 &amp;&amp; i &lt;= uframe+4; i++)
 			if (!check_period (ehci, frame, i,
 						qh-&gt;period, qh-&gt;c_usecs))
 				goto done;</pre><hr><pre>commit 63fb3a280061c5a1d9190015e5a074213f9d23c0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 11 11:28:02 2013 -0400

    USB: NS_TO_US should round up
    
    Host controller drivers use the NS_TO_US macro to convert transaction
    times, which are computed in nanoseconds, to microseconds for
    scheduling.  Periodic scheduling requires worst-case estimates, but
    the macro does its conversion using round-to-nearest.  This patch
    changes it to use round-up, giving a correct worst-case value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index fc64b6825f5e..dbe3cd19ffd8 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -564,9 +564,8 @@ extern void usb_ep0_reinit(struct usb_device *);
 		 * of (7/6 * 8 * bytecount) = 9.33 * bytecount */
 		/* bytecount = data payload byte count */
 
-#define NS_TO_US(ns)	((ns + 500L) / 1000L)
-			/* convert &amp; round nanoseconds to microseconds */
-
+#define NS_TO_US(ns)	DIV_ROUND_UP(ns, 1000L)
+			/* convert nanoseconds to microseconds, rounding up */
 
 /*
  * Full/low speed bandwidth allocation constants/support.</pre><hr><pre>commit 976b6c064a957445eb0573b270f2d0282630e9b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:51:58 2013 -0400

    ALSA: improve buffer size computations for USB PCM audio
    
    This patch changes the way URBs are allocated and their sizes are
    determined for PCM playback in the snd-usb-audio driver.  Currently
    the driver allocates too few URBs for endpoints that don't use
    implicit sync, making underruns more likely to occur.  This may be a
    holdover from before I/O delays could be measured accurately; in any
    case, it is no longer necessary.
    
    The patch allocates as many URBs as possible, subject to four
    limitations:
    
            The total number of URBs for the endpoint is not allowed to
            exceed MAX_URBS (which the patch increases from 8 to 12).
    
            The total number of packets per URB is not allowed to exceed
            MAX_PACKS (or MAX_PACKS_HS for high-speed devices), which is
            decreased from 20 to 6.
    
            The total duration of queued data is not allowed to exceed
            MAX_QUEUE, which is decreased from 24 ms to 18 ms.
    
            The total number of ALSA frames in the output queue is not
            allowed to exceed the ALSA buffer size.
    
    The last requirement is the hardest to implement.  Currently the
    number of URBs needed to fill a buffer cannot be determined in
    advance, because a buffer contains a fixed number of frames whereas
    the number of frames in an URB varies to match shifts in the device's
    clock rate.  To solve this problem, the patch changes the logic for
    deciding how many packets an URB should contain.  Rather than using as
    many as possible without exceeding an ALSA period boundary, now the
    driver uses only as many packets as needed to transfer a predetermined
    number of frames.  As a result, unless the device's clock has an
    exceedingly variable rate, the number of URBs making up each period
    (and hence each buffer) will remain constant.
    
    The overall effect of the patch is that playback works better in
    low-latency settings.  The user can still specify values for
    frames/period and periods/buffer that exceed the capabilities of the
    hardware, of course.  But for values that are within those
    capabilities, the performance will be improved.  For example, testing
    shows that a high-speed device can handle 32 frames/period and 3
    periods/buffer at 48 KHz, whereas the current driver starts to get
    glitchy at 64 frames/period and 2 periods/buffer.
    
    A side effect of these changes is that the "nrpacks" module parameter
    is no longer used.  The patch removes it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Clemens Ladisch &lt;clemens@ladisch.de&gt;
    Tested-by: Daniel Mack &lt;zonque@gmail.com&gt;
    Tested-by: Eldad Zack &lt;eldad@fogrefinery.com&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/usb/card.c b/sound/usb/card.c
index 64952e2d3ed1..d1f54dfe41d5 100644
--- a/sound/usb/card.c
+++ b/sound/usb/card.c
@@ -79,7 +79,6 @@ static bool enable[SNDRV_CARDS] = SNDRV_DEFAULT_ENABLE_PNP;/* Enable this card *
 /* Vendor/product IDs for this card */
 static int vid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
 static int pid[SNDRV_CARDS] = { [0 ... (SNDRV_CARDS-1)] = -1 };
-static int nrpacks = 8;		/* max. number of packets per urb */
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
 static bool autoclock = true;
@@ -94,8 +93,6 @@ module_param_array(vid, int, NULL, 0444);
 MODULE_PARM_DESC(vid, "Vendor ID for the USB audio device.");
 module_param_array(pid, int, NULL, 0444);
 MODULE_PARM_DESC(pid, "Product ID for the USB audio device.");
-module_param(nrpacks, int, 0644);
-MODULE_PARM_DESC(nrpacks, "Max. number of packets per URB.");
 module_param_array(device_setup, int, NULL, 0444);
 MODULE_PARM_DESC(device_setup, "Specific device setup (if needed).");
 module_param(ignore_ctl_error, bool, 0444);
@@ -374,7 +371,6 @@ static int snd_usb_audio_create(struct usb_device *dev, int idx,
 	chip-&gt;dev = dev;
 	chip-&gt;card = card;
 	chip-&gt;setup = device_setup[idx];
-	chip-&gt;nrpacks = nrpacks;
 	chip-&gt;autoclock = autoclock;
 	chip-&gt;probing = 1;
 
@@ -756,10 +752,6 @@ static struct usb_driver usb_audio_driver = {
 
 static int __init snd_usb_audio_init(void)
 {
-	if (nrpacks &lt; 1 || nrpacks &gt; MAX_PACKS) {
-		printk(KERN_WARNING "invalid nrpacks value.\n");
-		return -EINVAL;
-	}
 	return usb_register(&amp;usb_audio_driver);
 }
 
diff --git a/sound/usb/card.h b/sound/usb/card.h
index 5ecacaa90b53..ca98a9b915c9 100644
--- a/sound/usb/card.h
+++ b/sound/usb/card.h
@@ -2,11 +2,11 @@
 #define __USBAUDIO_CARD_H
 
 #define MAX_NR_RATES	1024
-#define MAX_PACKS	20
+#define MAX_PACKS	6		/* per URB */
 #define MAX_PACKS_HS	(MAX_PACKS * 8)	/* in high speed mode */
-#define MAX_URBS	8
+#define MAX_URBS	12
 #define SYNC_URBS	4	/* always four urbs for sync */
-#define MAX_QUEUE	24	/* try not to exceed this queue length, in ms */
+#define MAX_QUEUE	18	/* try not to exceed this queue length, in ms */
 
 struct audioformat {
 	struct list_head list;
@@ -87,6 +87,7 @@ struct snd_usb_endpoint {
 	unsigned int phase;		/* phase accumulator */
 	unsigned int maxpacksize;	/* max packet size in bytes */
 	unsigned int maxframesize;      /* max packet size in frames */
+	unsigned int max_urb_frames;	/* max URB size in frames */
 	unsigned int curpacksize;	/* current packet size in bytes (for capture) */
 	unsigned int curframesize;      /* current packet size in frames (for capture) */
 	unsigned int syncmaxsize;	/* sync endpoint packet size */
@@ -116,6 +117,8 @@ struct snd_usb_substream {
 	unsigned int channels_max;	/* max channels in the all audiofmts */
 	unsigned int cur_rate;		/* current rate (for hw_params callback) */
 	unsigned int period_bytes;	/* current period bytes (for hw_params callback) */
+	unsigned int period_frames;	/* current frames per period */
+	unsigned int buffer_periods;	/* current periods per buffer */
 	unsigned int altset_idx;     /* USB data format: index of alternate setting */
 	unsigned int txfr_quirk:1;	/* allow sub-frame alignment */
 	unsigned int fmt_type;		/* USB audio format type (1-3) */
@@ -125,6 +128,7 @@ struct snd_usb_substream {
 
 	unsigned int hwptr_done;	/* processed byte position in the buffer */
 	unsigned int transfer_done;		/* processed frames since last period update */
+	unsigned int frame_limit;	/* limits number of packets in URB */
 
 	/* data and sync endpoints for this stream */
 	unsigned int ep_num;		/* the endpoint number */
diff --git a/sound/usb/endpoint.c b/sound/usb/endpoint.c
index 93e970f2b3c0..21dc6422d747 100644
--- a/sound/usb/endpoint.c
+++ b/sound/usb/endpoint.c
@@ -574,11 +574,14 @@ static int data_ep_set_params(struct snd_usb_endpoint *ep,
 			      snd_pcm_format_t pcm_format,
 			      unsigned int channels,
 			      unsigned int period_bytes,
+			      unsigned int frames_per_period,
+			      unsigned int periods_per_buffer,
 			      struct audioformat *fmt,
 			      struct snd_usb_endpoint *sync_ep)
 {
-	unsigned int maxsize, i, urb_packs, total_packs, packs_per_ms;
-	int is_playback = usb_pipeout(ep-&gt;pipe);
+	unsigned int maxsize, minsize, packs_per_ms, max_packs_per_urb;
+	unsigned int max_packs_per_period, urbs_per_period, urb_packs;
+	unsigned int max_urbs, i;
 	int frame_bits = snd_pcm_format_physical_width(pcm_format) * channels;
 
 	if (pcm_format == SNDRV_PCM_FORMAT_DSD_U16_LE &amp;&amp; fmt-&gt;dsd_dop) {
@@ -611,58 +614,67 @@ static int data_ep_set_params(struct snd_usb_endpoint *ep,
 	else
 		ep-&gt;curpacksize = maxsize;
 
-	if (snd_usb_get_speed(ep-&gt;chip-&gt;dev) != USB_SPEED_FULL)
+	if (snd_usb_get_speed(ep-&gt;chip-&gt;dev) != USB_SPEED_FULL) {
 		packs_per_ms = 8 &gt;&gt; ep-&gt;datainterval;
-	else
-		packs_per_ms = 1;
-
-	if (is_playback &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep)) {
-		urb_packs = max(ep-&gt;chip-&gt;nrpacks, 1);
-		urb_packs = min(urb_packs, (unsigned int) MAX_PACKS);
+		max_packs_per_urb = MAX_PACKS_HS;
 	} else {
-		urb_packs = 1;
+		packs_per_ms = 1;
+		max_packs_per_urb = MAX_PACKS;
 	}
+	if (sync_ep &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep))
+		max_packs_per_urb = min(max_packs_per_urb,
+					1U &lt;&lt; sync_ep-&gt;syncinterval);
+	max_packs_per_urb = max(1u, max_packs_per_urb &gt;&gt; ep-&gt;datainterval);
 
-	urb_packs *= packs_per_ms;
+	/*
+	 * Capture endpoints need to use small URBs because there's no way
+	 * to tell in advance where the next period will end, and we don't
+	 * want the next URB to complete much after the period ends.
+	 *
+	 * Playback endpoints with implicit sync much use the same parameters
+	 * as their corresponding capture endpoint.
+	 */
+	if (usb_pipein(ep-&gt;pipe) ||
+			snd_usb_endpoint_implicit_feedback_sink(ep)) {
 
-	if (sync_ep &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep))
-		urb_packs = min(urb_packs, 1U &lt;&lt; sync_ep-&gt;syncinterval);
+		/* make capture URBs &lt;= 1 ms and smaller than a period */
+		urb_packs = min(max_packs_per_urb, packs_per_ms);
+		while (urb_packs &gt; 1 &amp;&amp; urb_packs * maxsize &gt;= period_bytes)
+			urb_packs &gt;&gt;= 1;
+		ep-&gt;nurbs = MAX_URBS;
 
-	/* decide how many packets to be used */
-	if (is_playback &amp;&amp; !snd_usb_endpoint_implicit_feedback_sink(ep)) {
-		unsigned int minsize, maxpacks;
+	/*
+	 * Playback endpoints without implicit sync are adjusted so that
+	 * a period fits as evenly as possible in the smallest number of
+	 * URBs.  The total number of URBs is adjusted to the size of the
+	 * ALSA buffer, subject to the MAX_URBS and MAX_QUEUE limits.
+	 */
+	} else {
 		/* determine how small a packet can be */
-		minsize = (ep-&gt;freqn &gt;&gt; (16 - ep-&gt;datainterval))
-			  * (frame_bits &gt;&gt; 3);
+		minsize = (ep-&gt;freqn &gt;&gt; (16 - ep-&gt;datainterval)) *
+				(frame_bits &gt;&gt; 3);
 		/* with sync from device, assume it can be 12% lower */
 		if (sync_ep)
 			minsize -= minsize &gt;&gt; 3;
 		minsize = max(minsize, 1u);
-		total_packs = (period_bytes + minsize - 1) / minsize;
-		/* we need at least two URBs for queueing */
-		if (total_packs &lt; 2) {
-			total_packs = 2;
-		} else {
-			/* and we don't want too long a queue either */
-			maxpacks = max(MAX_QUEUE * packs_per_ms, urb_packs * 2);
-			total_packs = min(total_packs, maxpacks);
-		}
-	} else {
-		while (urb_packs &gt; 1 &amp;&amp; urb_packs * maxsize &gt;= period_bytes)
-			urb_packs &gt;&gt;= 1;
-		total_packs = MAX_URBS * urb_packs;
-	}
 
-	ep-&gt;nurbs = (total_packs + urb_packs - 1) / urb_packs;
-	if (ep-&gt;nurbs &gt; MAX_URBS) {
-		/* too much... */
-		ep-&gt;nurbs = MAX_URBS;
-		total_packs = MAX_URBS * urb_packs;
-	} else if (ep-&gt;nurbs &lt; 2) {
-		/* too little - we need at least two packets
-		 * to ensure contiguous playback/capture
-		 */
-		ep-&gt;nurbs = 2;
+		/* how many packets will contain an entire ALSA period? */
+		max_packs_per_period = DIV_ROUND_UP(period_bytes, minsize);
+
+		/* how many URBs will contain a period? */
+		urbs_per_period = DIV_ROUND_UP(max_packs_per_period,
+				max_packs_per_urb);
+		/* how many packets are needed in each URB? */
+		urb_packs = DIV_ROUND_UP(max_packs_per_period, urbs_per_period);
+
+		/* limit the number of frames in a single URB */
+		ep-&gt;max_urb_frames = DIV_ROUND_UP(frames_per_period,
+					urbs_per_period);
+
+		/* try to use enough URBs to contain an entire ALSA buffer */
+		max_urbs = min((unsigned) MAX_URBS,
+				MAX_QUEUE * packs_per_ms / urb_packs);
+		ep-&gt;nurbs = min(max_urbs, urbs_per_period * periods_per_buffer);
 	}
 
 	/* allocate and initialize data urbs */
@@ -670,8 +682,7 @@ static int data_ep_set_params(struct snd_usb_endpoint *ep,
 		struct snd_urb_ctx *u = &amp;ep-&gt;urb[i];
 		u-&gt;index = i;
 		u-&gt;ep = ep;
-		u-&gt;packets = (i + 1) * total_packs / ep-&gt;nurbs
-			- i * total_packs / ep-&gt;nurbs;
+		u-&gt;packets = urb_packs;
 		u-&gt;buffer_size = maxsize * u-&gt;packets;
 
 		if (fmt-&gt;fmt_type == UAC_FORMAT_TYPE_II)
@@ -748,6 +759,8 @@ static int sync_ep_set_params(struct snd_usb_endpoint *ep,
  * @pcm_format: the audio fomat.
  * @channels: the number of audio channels.
  * @period_bytes: the number of bytes in one alsa period.
+ * @period_frames: the number of frames in one alsa period.
+ * @buffer_periods: the number of periods in one alsa buffer.
  * @rate: the frame rate.
  * @fmt: the USB audio format information
  * @sync_ep: the sync endpoint to use, if any
@@ -760,6 +773,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				snd_pcm_format_t pcm_format,
 				unsigned int channels,
 				unsigned int period_bytes,
+				unsigned int period_frames,
+				unsigned int buffer_periods,
 				unsigned int rate,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep)
@@ -793,7 +808,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 	switch (ep-&gt;type) {
 	case  SND_USB_ENDPOINT_TYPE_DATA:
 		err = data_ep_set_params(ep, pcm_format, channels,
-					 period_bytes, fmt, sync_ep);
+					 period_bytes, period_frames,
+					 buffer_periods, fmt, sync_ep);
 		break;
 	case  SND_USB_ENDPOINT_TYPE_SYNC:
 		err = sync_ep_set_params(ep, fmt);
diff --git a/sound/usb/endpoint.h b/sound/usb/endpoint.h
index 2287adf5ca59..3bd02f0d226c 100644
--- a/sound/usb/endpoint.h
+++ b/sound/usb/endpoint.h
@@ -12,6 +12,8 @@ int snd_usb_endpoint_set_params(struct snd_usb_endpoint *ep,
 				snd_pcm_format_t pcm_format,
 				unsigned int channels,
 				unsigned int period_bytes,
+				unsigned int period_frames,
+				unsigned int buffer_periods,
 				unsigned int rate,
 				struct audioformat *fmt,
 				struct snd_usb_endpoint *sync_ep);
diff --git a/sound/usb/pcm.c b/sound/usb/pcm.c
index b375d58871e7..19e79953f2e3 100644
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@ -595,6 +595,7 @@ static int configure_sync_endpoint(struct snd_usb_substream *subs)
 						   subs-&gt;pcm_format,
 						   subs-&gt;channels,
 						   subs-&gt;period_bytes,
+						   0, 0,
 						   subs-&gt;cur_rate,
 						   subs-&gt;cur_audiofmt,
 						   NULL);
@@ -631,6 +632,7 @@ static int configure_sync_endpoint(struct snd_usb_substream *subs)
 					  subs-&gt;pcm_format,
 					  sync_fp-&gt;channels,
 					  sync_period_bytes,
+					  0, 0,
 					  subs-&gt;cur_rate,
 					  sync_fp,
 					  NULL);
@@ -653,6 +655,8 @@ static int configure_endpoint(struct snd_usb_substream *subs)
 					  subs-&gt;pcm_format,
 					  subs-&gt;channels,
 					  subs-&gt;period_bytes,
+					  subs-&gt;period_frames,
+					  subs-&gt;buffer_periods,
 					  subs-&gt;cur_rate,
 					  subs-&gt;cur_audiofmt,
 					  subs-&gt;sync_endpoint);
@@ -689,6 +693,8 @@ static int snd_usb_hw_params(struct snd_pcm_substream *substream,
 
 	subs-&gt;pcm_format = params_format(hw_params);
 	subs-&gt;period_bytes = params_period_bytes(hw_params);
+	subs-&gt;period_frames = params_period_size(hw_params);
+	subs-&gt;buffer_periods = params_periods(hw_params);
 	subs-&gt;channels = params_channels(hw_params);
 	subs-&gt;cur_rate = params_rate(hw_params);
 
@@ -1363,6 +1369,7 @@ static void prepare_playback_urb(struct snd_usb_substream *subs,
 	frames = 0;
 	urb-&gt;number_of_packets = 0;
 	spin_lock_irqsave(&amp;subs-&gt;lock, flags);
+	subs-&gt;frame_limit += ep-&gt;max_urb_frames;
 	for (i = 0; i &lt; ctx-&gt;packets; i++) {
 		if (ctx-&gt;packet_size[i])
 			counts = ctx-&gt;packet_size[i];
@@ -1377,6 +1384,7 @@ static void prepare_playback_urb(struct snd_usb_substream *subs,
 		subs-&gt;transfer_done += counts;
 		if (subs-&gt;transfer_done &gt;= runtime-&gt;period_size) {
 			subs-&gt;transfer_done -= runtime-&gt;period_size;
+			subs-&gt;frame_limit = 0;
 			period_elapsed = 1;
 			if (subs-&gt;fmt_type == UAC_FORMAT_TYPE_II) {
 				if (subs-&gt;transfer_done &gt; 0) {
@@ -1399,8 +1407,10 @@ static void prepare_playback_urb(struct snd_usb_substream *subs,
 				break;
 			}
 		}
-		if (period_elapsed &amp;&amp;
-		    !snd_usb_endpoint_implicit_feedback_sink(subs-&gt;data_endpoint)) /* finish at the period boundary */
+		/* finish at the period boundary or after enough frames */
+		if ((period_elapsed ||
+				subs-&gt;transfer_done &gt;= subs-&gt;frame_limit) &amp;&amp;
+		    !snd_usb_endpoint_implicit_feedback_sink(ep))
 			break;
 	}
 	bytes = frames * ep-&gt;stride;
diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h
index caabe9b3af49..5d2fe0530745 100644
--- a/sound/usb/usbaudio.h
+++ b/sound/usb/usbaudio.h
@@ -55,7 +55,6 @@ struct snd_usb_audio {
 	struct list_head mixer_list;	/* list of mixer interfaces */
 
 	int setup;			/* from the 'device_setup' module param */
-	int nrpacks;			/* from the 'nrpacks' module param */
 	bool autoclock;			/* from the 'autoclock' module param */
 
 	struct usb_host_interface *ctrl_intf;	/* the audio control interface */</pre><hr><pre>commit 232275a089dfd2e77377a85f11d0a4e3ca60e612
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:43:39 2013 -0400

    USB: fix substandard locking for the sysfs files
    
    This patch straightens out some locking issues in the USB sysfs
    interface:
    
            Deauthorization will destroy existing configurations.
            Attributes that read from udev-&gt;actconfig need to lock the
            device to prevent races.  Likewise for the rawdescriptor
            values.
    
            Attributes that access an interface's current alternate
            setting should use ACCESS_ONCE() to obtain the cur_altsetting
            pointer, to protect against concurrent altsetting changes.
    
            The supports_autosuspend() attribute routine accesses values
            from an interface's driver, so it should lock the interface
            (rather than the usb_device) to protect against concurrent
            unbinds.  Once this is done, the routine can be simplified
            considerably.
    
    Scalar values that are stored directly in the usb_device structure are
    always available.  They do not require any locking.  The same is true
    of the cached interface string descriptor, because it is not
    deallocated until the usb_host_interface structure is destroyed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 6d2c8edb1ffe..59cb5f99467a 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -23,14 +23,16 @@ static ssize_t field##_show(struct device *dev,				\
 {									\
 	struct usb_device *udev;					\
 	struct usb_host_config *actconfig;				\
+	ssize_t rc = 0;							\
 									\
 	udev = to_usb_device(dev);					\
+	usb_lock_device(udev);						\
 	actconfig = udev-&gt;actconfig;					\
 	if (actconfig)							\
-		return sprintf(buf, format_string,			\
+		rc = sprintf(buf, format_string,			\
 				actconfig-&gt;desc.field);			\
-	else								\
-		return 0;						\
+	usb_unlock_device(udev);					\
+	return rc;							\
 }									\
 
 #define usb_actconfig_attr(field, format_string)		\
@@ -45,12 +47,15 @@ static ssize_t bMaxPower_show(struct device *dev,
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
+	ssize_t rc = 0;
 
 	udev = to_usb_device(dev);
+	usb_lock_device(udev);
 	actconfig = udev-&gt;actconfig;
-	if (!actconfig)
-		return 0;
-	return sprintf(buf, "%dmA\n", usb_get_max_power(udev, actconfig));
+	if (actconfig)
+		rc = sprintf(buf, "%dmA\n", usb_get_max_power(udev, actconfig));
+	usb_unlock_device(udev);
+	return rc;
 }
 static DEVICE_ATTR_RO(bMaxPower);
 
@@ -59,12 +64,15 @@ static ssize_t configuration_show(struct device *dev,
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
+	ssize_t rc = 0;
 
 	udev = to_usb_device(dev);
+	usb_lock_device(udev);
 	actconfig = udev-&gt;actconfig;
-	if ((!actconfig) || (!actconfig-&gt;string))
-		return 0;
-	return sprintf(buf, "%s\n", actconfig-&gt;string);
+	if (actconfig &amp;&amp; actconfig-&gt;string)
+		rc = sprintf(buf, "%s\n", actconfig-&gt;string);
+	usb_unlock_device(udev);
+	return rc;
 }
 static DEVICE_ATTR_RO(configuration);
 
@@ -764,6 +772,7 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 	 * Following that are the raw descriptor entries for all the
 	 * configurations (config plus subsidiary descriptors).
 	 */
+	usb_lock_device(udev);
 	for (cfgno = -1; cfgno &lt; udev-&gt;descriptor.bNumConfigurations &amp;&amp;
 			nleft &gt; 0; ++cfgno) {
 		if (cfgno &lt; 0) {
@@ -784,6 +793,7 @@ read_descriptors(struct file *filp, struct kobject *kobj,
 			off -= srclen;
 		}
 	}
+	usb_unlock_device(udev);
 	return count - nleft;
 }
 
@@ -870,9 +880,7 @@ static ssize_t interface_show(struct device *dev, struct device_attribute *attr,
 	char *string;
 
 	intf = to_usb_interface(dev);
-	string = intf-&gt;cur_altsetting-&gt;string;
-	barrier();		/* The altsetting might change! */
-
+	string = ACCESS_ONCE(intf-&gt;cur_altsetting-&gt;string);
 	if (!string)
 		return 0;
 	return sprintf(buf, "%s\n", string);
@@ -888,7 +896,7 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 
 	intf = to_usb_interface(dev);
 	udev = interface_to_usbdev(intf);
-	alt = intf-&gt;cur_altsetting;
+	alt = ACCESS_ONCE(intf-&gt;cur_altsetting);
 
 	return sprintf(buf, "usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X"
 			"ic%02Xisc%02Xip%02Xin%02X\n",
@@ -909,23 +917,14 @@ static ssize_t supports_autosuspend_show(struct device *dev,
 					 struct device_attribute *attr,
 					 char *buf)
 {
-	struct usb_interface *intf;
-	struct usb_device *udev;
-	int ret;
+	int s;
 
-	intf = to_usb_interface(dev);
-	udev = interface_to_usbdev(intf);
-
-	usb_lock_device(udev);
+	device_lock(dev);
 	/* Devices will be autosuspended even when an interface isn't claimed */
-	if (!intf-&gt;dev.driver ||
-			to_usb_driver(intf-&gt;dev.driver)-&gt;supports_autosuspend)
-		ret = sprintf(buf, "%u\n", 1);
-	else
-		ret = sprintf(buf, "%u\n", 0);
-	usb_unlock_device(udev);
+	s = (!dev-&gt;driver || to_usb_driver(dev-&gt;driver)-&gt;supports_autosuspend);
+	device_unlock(dev);
 
-	return ret;
+	return sprintf(buf, "%u\n", s);
 }
 static DEVICE_ATTR_RO(supports_autosuspend);
 </pre><hr><pre>commit f875fdbf344b9fde207f66b392c40845dd7e5aa6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:45:25 2013 -0400

    USB: fix PM config symbol in uhci-hcd, ehci-hcd, and xhci-hcd
    
    Since uhci-hcd, ehci-hcd, and xhci-hcd support runtime PM, the .pm
    field in their pci_driver structures should be protected by CONFIG_PM
    rather than CONFIG_PM_SLEEP.  The corresponding change has already
    been made for ohci-hcd.
    
    Without this change, controllers won't do runtime suspend if system
    suspend or hibernation isn't enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6bd299e61f58..854c2ec7b699 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -361,7 +361,7 @@ static struct pci_driver ehci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown = 	usb_hcd_pci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&amp;usb_hcd_pci_pm_ops
 	},
diff --git a/drivers/usb/host/uhci-pci.c b/drivers/usb/host/uhci-pci.c
index c300bd2f7d1c..0f228c46eeda 100644
--- a/drivers/usb/host/uhci-pci.c
+++ b/drivers/usb/host/uhci-pci.c
@@ -293,7 +293,7 @@ static struct pci_driver uhci_pci_driver = {
 	.remove =	usb_hcd_pci_remove,
 	.shutdown =	uhci_shutdown,
 
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver =	{
 		.pm =	&amp;usb_hcd_pci_pm_ops
 	},
diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c
index c2d495057eb5..236c3aabe940 100644
--- a/drivers/usb/host/xhci-pci.c
+++ b/drivers/usb/host/xhci-pci.c
@@ -351,7 +351,7 @@ static struct pci_driver xhci_pci_driver = {
 	/* suspend and resume implemented later */
 
 	.shutdown = 	usb_hcd_pci_shutdown,
-#ifdef CONFIG_PM_SLEEP
+#ifdef CONFIG_PM
 	.driver = {
 		.pm = &amp;usb_hcd_pci_pm_ops
 	},</pre><hr><pre>commit a8693424c751b8247ee19bd8b857f1d4f432b972
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:46:45 2013 -0400

    USB: OHCI: accept very late isochronous URBs
    
    Commit 24f531371de1 (USB: EHCI: accept very late isochronous URBs)
    changed the isochronous API provided by ehci-hcd.  URBs submitted too
    late, so that the time slots for all their packets have already
    expired, are no longer rejected outright.  Instead the submission is
    accepted, and the URB completes normally with a -EXDEV error for each
    packet.  This is what client drivers expect.
    
    This patch implements the same policy in ohci-hcd.  The change is more
    complicated than it was in ehci-hcd, because ohci-hcd doesn't scan for
    isochronous completions in the same way as ehci-hcd does.  Rather, it
    depends on the hardware adding completed TDs to a "done queue".  Some
    OHCI controller don't handle this properly when a TD's time slot has
    already expired, so we have to avoid adding such TDs to the schedule
    in the first place.  As a result, if the URB was submitted too late
    then none of its TDs will get put on the schedule, so none of them
    will end up on the done queue, so the driver will never realize that
    the URB should be completed.
    
    To solve this problem, the patch adds one to urb_priv-&gt;td_cnt for such
    URBs, making it larger than urb_priv-&gt;length (td_cnt already gets set
    to the number of TD's that had to be skipped because their slots have
    expired).  Each time an URB is given back, the finish_urb() routine
    looks to see if urb_priv-&gt;td_cnt for the next URB on the same endpoint
    is marked in this way.  If so, it gives back the next URB right away.
    
    This should be applied to all kernels containing commit 815fa7b91761
    (USB: OHCI: fix logic for scheduling isochronous URBs).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 8f6b695af6a4..604cad1bcf9c 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -216,31 +216,26 @@ static int ohci_urb_enqueue (
 			frame &amp;= ~(ed-&gt;interval - 1);
 			frame |= ed-&gt;branch;
 			urb-&gt;start_frame = frame;
+			ed-&gt;last_iso = frame + ed-&gt;interval * (size - 1);
 		}
 	} else if (ed-&gt;type == PIPE_ISOCHRONOUS) {
 		u16	next = ohci_frame_no(ohci) + 1;
 		u16	frame = ed-&gt;last_iso + ed-&gt;interval;
+		u16	length = ed-&gt;interval * (size - 1);
 
 		/* Behind the scheduling threshold? */
 		if (unlikely(tick_before(frame, next))) {
 
-			/* USB_ISO_ASAP: Round up to the first available slot */
+			/* URB_ISO_ASAP: Round up to the first available slot */
 			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
 				frame += (next - frame + ed-&gt;interval - 1) &amp;
 						-ed-&gt;interval;
 
 			/*
-			 * Not ASAP: Use the next slot in the stream.  If
-			 * the entire URB falls before the threshold, fail.
+			 * Not ASAP: Use the next slot in the stream,
+			 * no matter what.
 			 */
 			} else {
-				if (tick_before(frame + ed-&gt;interval *
-					(urb-&gt;number_of_packets - 1), next)) {
-					retval = -EXDEV;
-					usb_hcd_unlink_urb_from_ep(hcd, urb);
-					goto fail;
-				}
-
 				/*
 				 * Some OHCI hardware doesn't handle late TDs
 				 * correctly.  After retiring them it proceeds
@@ -251,9 +246,16 @@ static int ohci_urb_enqueue (
 				urb_priv-&gt;td_cnt = DIV_ROUND_UP(
 						(u16) (next - frame),
 						ed-&gt;interval);
+				if (urb_priv-&gt;td_cnt &gt;= urb_priv-&gt;length) {
+					++urb_priv-&gt;td_cnt;	/* Mark it */
+					ohci_dbg(ohci, "iso underrun %p (%u+%u &lt; %u)\n",
+							urb, frame, length,
+							next);
+				}
 			}
 		}
 		urb-&gt;start_frame = frame;
+		ed-&gt;last_iso = frame + length;
 	}
 
 	/* fill the TDs and link them to the ed; and
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index df4a6707322d..e7f577e63624 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -41,9 +41,13 @@ finish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)
 __releases(ohci-&gt;lock)
 __acquires(ohci-&gt;lock)
 {
-	 struct device *dev = ohci_to_hcd(ohci)-&gt;self.controller;
+	struct device *dev = ohci_to_hcd(ohci)-&gt;self.controller;
+	struct usb_host_endpoint *ep = urb-&gt;ep;
+	struct urb_priv *urb_priv;
+
 	// ASSERT (urb-&gt;hcpriv != 0);
 
+ restart:
 	urb_free_priv (ohci, urb-&gt;hcpriv);
 	urb-&gt;hcpriv = NULL;
 	if (likely(status == -EINPROGRESS))
@@ -80,6 +84,21 @@ __acquires(ohci-&gt;lock)
 		ohci-&gt;hc_control &amp;= ~(OHCI_CTRL_PLE|OHCI_CTRL_IE);
 		ohci_writel (ohci, ohci-&gt;hc_control, &amp;ohci-&gt;regs-&gt;control);
 	}
+
+	/*
+	 * An isochronous URB that is sumitted too late won't have any TDs
+	 * (marked by the fact that the td_cnt value is larger than the
+	 * actual number of TDs).  If the next URB on this endpoint is like
+	 * that, give it back now.
+	 */
+	if (!list_empty(&amp;ep-&gt;urb_list)) {
+		urb = list_first_entry(&amp;ep-&gt;urb_list, struct urb, urb_list);
+		urb_priv = urb-&gt;hcpriv;
+		if (urb_priv-&gt;td_cnt &gt; urb_priv-&gt;length) {
+			status = 0;
+			goto restart;
+		}
+	}
 }
 
 
@@ -546,7 +565,6 @@ td_fill (struct ohci_hcd *ohci, u32 info,
 		td-&gt;hwCBP = cpu_to_hc32 (ohci, data &amp; 0xFFFFF000);
 		*ohci_hwPSWp(ohci, td, 0) = cpu_to_hc16 (ohci,
 						(data &amp; 0x0FFF) | 0xE000);
-		td-&gt;ed-&gt;last_iso = info &amp; 0xffff;
 	} else {
 		td-&gt;hwCBP = cpu_to_hc32 (ohci, data);
 	}
@@ -996,7 +1014,7 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 			urb_priv-&gt;td_cnt++;
 
 			/* if URB is done, clean up */
-			if (urb_priv-&gt;td_cnt == urb_priv-&gt;length) {
+			if (urb_priv-&gt;td_cnt &gt;= urb_priv-&gt;length) {
 				modified = completed = 1;
 				finish_urb(ohci, urb, 0);
 			}
@@ -1086,7 +1104,7 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
 	urb_priv-&gt;td_cnt++;
 
 	/* If all this urb's TDs are done, call complete() */
-	if (urb_priv-&gt;td_cnt == urb_priv-&gt;length)
+	if (urb_priv-&gt;td_cnt &gt;= urb_priv-&gt;length)
 		finish_urb(ohci, urb, status);
 
 	/* clean schedule:  unlink EDs that are no longer busy */</pre><hr><pre>commit bef073b067a7b1874a6b381e0035bb0516d71a77
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:47:20 2013 -0400

    USB: UHCI: accept very late isochronous URBs
    
    Commit 24f531371de1 (USB: EHCI: accept very late isochronous URBs)
    changed the isochronous API provided by ehci-hcd.  URBs submitted too
    late, so that the time slots for all their packets have already
    expired, are no longer rejected outright.  Instead the submission is
    accepted, and the URB completes normally with a -EXDEV error for each
    packet.  This is what client drivers expect.
    
    This patch implements the same policy in uhci-hcd.  It should be
    applied to all kernels containing commit c44b225077bb (UHCI: implement
    new semantics for URB_ISO_ASAP).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 041c6ddb695c..da6f56d996ce 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1303,7 +1303,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		}
 
 		/* Fell behind? */
-		if (uhci_frame_before_eq(frame, next)) {
+		if (!uhci_frame_before_eq(next, frame)) {
 
 			/* USB_ISO_ASAP: Round up to the first available slot */
 			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
@@ -1311,13 +1311,17 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 						-qh-&gt;period;
 
 			/*
-			 * Not ASAP: Use the next slot in the stream.  If
-			 * the entire URB falls before the threshold, fail.
+			 * Not ASAP: Use the next slot in the stream,
+			 * no matter what.
 			 */
 			else if (!uhci_frame_before_eq(next,
 					frame + (urb-&gt;number_of_packets - 1) *
 						qh-&gt;period))
-				return -EXDEV;
+				dev_dbg(uhci_dev(uhci), "iso underrun %p (%u+%u &lt; %u)\n",
+						urb, frame,
+						(urb-&gt;number_of_packets - 1) *
+							qh-&gt;period,
+						next);
 		}
 	}
 </pre><hr><pre>commit 8937669fd637e2edff05973cb1fdee5f910cbcc7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 24 15:48:05 2013 -0400

    USB: iMX21: accept very late isochronous URBs
    
    Commit 24f531371de1 (USB: EHCI: accept very late isochronous URBs)
    changed the isochronous API provided by ehci-hcd.  URBs submitted too
    late, so that the time slots for all their packets have already
    expired, are no longer rejected outright.  Instead the submission is
    accepted, and the URB completes normally with a -EXDEV error for each
    packet.  This is what client drivers expect.
    
    The same policy should be implemented in imx21-hcd, but I don't know
    enough about the hardware to do it.  As a second-best substitute, this
    patch treats very late isochronous submissions as though the
    URB_ISO_ASAP flag were set.  I don't have any way to test this change,
    unfortunately.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sascha Hauer &lt;kernel@pengutronix.de&gt;
    CC: Martin Fuzzey &lt;mfuzzey@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/imx21-hcd.c b/drivers/usb/host/imx21-hcd.c
index 60a5de505ca1..adb01d950a16 100644
--- a/drivers/usb/host/imx21-hcd.c
+++ b/drivers/usb/host/imx21-hcd.c
@@ -824,13 +824,13 @@ static int imx21_hc_urb_enqueue_isoc(struct usb_hcd *hcd,
 			i = DIV_ROUND_UP(wrap_frame(
 					cur_frame - urb-&gt;start_frame),
 					urb-&gt;interval);
-			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+
+			/* Treat underruns as if URB_ISO_ASAP was set */
+			if ((urb-&gt;transfer_flags &amp; URB_ISO_ASAP) ||
+					i &gt;= urb-&gt;number_of_packets) {
 				urb-&gt;start_frame = wrap_frame(urb-&gt;start_frame
 						+ i * urb-&gt;interval);
 				i = 0;
-			} else if (i &gt;= urb-&gt;number_of_packets) {
-				ret = -EXDEV;
-				goto alloc_dmem_failed;
 			}
 		}
 	}</pre><hr><pre>commit 46c73d1d3ebc38feed1d97c6980252a0a01f6a5b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 3 13:59:03 2013 -0400

    USB: EHCI: handle isochronous underruns with tasklets
    
    This patch updates the iso_stream_schedule() routine in ehci-sched.c
    to handle cases where an underrun causes an isochronous endpoint's
    queue to empty out, but the client driver wants to maintain
    synchronization with the device (i.e., the URB_ISO_ASAP flag is not
    set).  This could not happen until recently, when ehci-hcd switched
    over to completing URBs in a tasklet.
    
    (This may seem like an unlikely case to worry about, but underruns are
    all too common with the snd-usb-audio driver, which doesn't use
    URB_ISO_ASAP.)
    
    As part of the fix, some URBs may need to be given back when they are
    submitted.  This is necessary when the URB's scheduled slots all fall
    before the current value of ehci-&gt;last_iso_frame, and as an
    optimization we do it also when the slots all fall before the current
    frame number.
    
    As a second part of the fix, we may need to skip some but not all of
    an URB's packets.  This is necessary when some of the URB's scheduled
    slots fall before the current value of ehci-&gt;last_iso_frame and some
    of them fall after the current frame number.  A new field
    (first_packet) is added to struct ehci_iso_sched, to indicate how many
    packets should be skipped.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Ming Lei &lt;tom.leiming@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 208518bc6e36..dcbaad94d607 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1370,10 +1370,12 @@ iso_stream_schedule (
 	struct ehci_iso_stream	*stream
 )
 {
-	u32			now, base, next, start, period, span;
-	int			status;
+	u32			now, base, next, start, period, span, now2;
+	u32			wrap = 0, skip = 0;
+	int			status = 0;
 	unsigned		mod = ehci-&gt;periodic_size &lt;&lt; 3;
 	struct ehci_iso_sched	*sched = urb-&gt;hcpriv;
+	bool			empty = list_empty(&amp;stream-&gt;td_list);
 
 	period = urb-&gt;interval;
 	span = sched-&gt;span;
@@ -1384,6 +1386,19 @@ iso_stream_schedule (
 
 	now = ehci_read_frame_index(ehci) &amp; (mod - 1);
 
+	/* Take the isochronous scheduling threshold into account */
+	if (ehci-&gt;i_thresh)
+		next = now + ehci-&gt;i_thresh;	/* uframe cache */
+	else
+		next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
+
+	/*
+	 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
+	 * TDs scheduled for earlier than that.
+	 */
+	base = ehci-&gt;last_iso_frame &lt;&lt; 3;
+	next = (next - base) &amp; (mod - 1);
+
 	/*
 	 * Need to schedule; when's the next (u)frame we could start?
 	 * This is bigger than ehci-&gt;i_thresh allows; scheduling itself
@@ -1391,11 +1406,11 @@ iso_stream_schedule (
 	 * can also help high bandwidth if the dma and irq loads don't
 	 * jump until after the queue is primed.
 	 */
-	if (unlikely(list_empty(&amp;stream-&gt;td_list))) {
+	if (unlikely(empty &amp;&amp; !hcd_periodic_completion_in_progress(
+			ehci_to_hcd(ehci), urb-&gt;ep))) {
 		int done = 0;
 
-		base = now &amp; ~0x07;
-		start = base + SCHEDULING_DELAY;
+		start = (now &amp; ~0x07) + SCHEDULING_DELAY;
 
 		/* find a uframe slot with enough bandwidth.
 		 * Early uframes are more precious because full-speed
@@ -1426,6 +1441,9 @@ iso_stream_schedule (
 			status = -ENOSPC;
 			goto fail;
 		}
+
+		start = (start - base) &amp; (mod - 1);
+		goto use_start;
 	}
 
 	/*
@@ -1434,72 +1452,85 @@ iso_stream_schedule (
 	 * (irq delays etc).  If there are, the behavior depends on
 	 * whether URB_ISO_ASAP is set.
 	 */
-	else {
+	start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
+	now2 = (now - base) &amp; (mod - 1);
 
-		/* Take the isochronous scheduling threshold into account */
-		if (ehci-&gt;i_thresh)
-			next = now + ehci-&gt;i_thresh;	/* uframe cache */
-		else
-			next = (now + 2 + 7) &amp; ~0x07;	/* full frame cache */
+	/* Is the schedule already full? */
+	if (unlikely(!empty &amp;&amp; start &lt; period)) {
+		ehci_dbg(ehci, "iso sched full %p (%u-%u &lt; %u mod %u)\n",
+				urb, stream-&gt;next_uframe, base, period, mod);
+		status = -ENOSPC;
+		goto fail;
+	}
 
-		/*
-		 * Use ehci-&gt;last_iso_frame as the base.  There can't be any
-		 * TDs scheduled for earlier than that.
-		 */
-		base = ehci-&gt;last_iso_frame &lt;&lt; 3;
-		next = (next - base) &amp; (mod - 1);
-		start = (stream-&gt;next_uframe - base) &amp; (mod - 1);
-
-		/* Is the schedule already full? */
-		if (unlikely(start &lt; period)) {
-			ehci_dbg(ehci, "iso sched full %p (%u-%u &lt; %u mod %u)\n",
-					urb, stream-&gt;next_uframe, base,
-					period, mod);
-			status = -ENOSPC;
-			goto fail;
-		}
+	/* Is the next packet scheduled after the base time? */
+	if (likely(!empty || start &lt;= now2 + period)) {
 
-		/* Behind the scheduling threshold? */
-		if (unlikely(start &lt; next)) {
-			unsigned now2 = (now - base) &amp; (mod - 1);
+		/* URB_ISO_ASAP: make sure that start &gt;= next */
+		if (unlikely(start &lt; next &amp;&amp;
+				(urb-&gt;transfer_flags &amp; URB_ISO_ASAP)))
+			goto do_ASAP;
 
-			/* USB_ISO_ASAP: Round up to the first available slot */
-			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
-				start += (next - start + period - 1) &amp; -period;
+		/* Otherwise use start, if it's not in the past */
+		if (likely(start &gt;= now2))
+			goto use_start;
 
-			/*
-			 * Not ASAP: Use the next slot in the stream,
-			 * no matter what.
-			 */
-			else if (start + span - period &lt; now2) {
-				ehci_dbg(ehci, "iso underrun %p (%u+%u &lt; %u)\n",
-						urb, start + base,
-						span - period, now2 + base);
-			}
-		}
+	/* Otherwise we got an underrun while the queue was empty */
+	} else {
+		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+			goto do_ASAP;
+		wrap = mod;
+		now2 += mod;
+	}
 
-		start += base;
+	/* How many uframes and packets do we need to skip? */
+	skip = (now2 - start + period - 1) &amp; -period;
+	if (skip &gt;= span) {		/* Entirely in the past? */
+		ehci_dbg(ehci, "iso underrun %p (%u+%u &lt; %u) [%u]\n",
+				urb, start + base, span - period, now2 + base,
+				base);
+
+		/* Try to keep the last TD intact for scanning later */
+		skip = span - period;
+
+		/* Will it come before the current scan position? */
+		if (empty) {
+			skip = span;	/* Skip the entire URB */
+			status = 1;	/* and give it back immediately */
+			iso_sched_free(stream, sched);
+			sched = NULL;
+		}
 	}
+	urb-&gt;error_count = skip / period;
+	if (sched)
+		sched-&gt;first_packet = urb-&gt;error_count;
+	goto use_start;
 
+ do_ASAP:
+	/* Use the first slot after "next" */
+	start = next + ((start - next) &amp; (period - 1));
+
+ use_start:
 	/* Tried to schedule too far into the future? */
-	if (unlikely(start - base + span - period &gt;= mod)) {
+	if (unlikely(start + span - period &gt;= mod + wrap)) {
 		ehci_dbg(ehci, "request %p would overflow (%u+%u &gt;= %u)\n",
-				urb, start - base, span - period, mod);
+				urb, start, span - period, mod + wrap);
 		status = -EFBIG;
 		goto fail;
 	}
 
-	stream-&gt;next_uframe = start &amp; (mod - 1);
+	start += base;
+	stream-&gt;next_uframe = (start + skip) &amp; (mod - 1);
 
 	/* report high speed start in uframes; full speed, in frames */
-	urb-&gt;start_frame = stream-&gt;next_uframe;
+	urb-&gt;start_frame = start &amp; (mod - 1);
 	if (!stream-&gt;highspeed)
 		urb-&gt;start_frame &gt;&gt;= 3;
 
 	/* Make sure scan_isoc() sees these */
 	if (ehci-&gt;isoc_count == 0)
 		ehci-&gt;last_iso_frame = now &gt;&gt; 3;
-	return 0;
+	return status;
 
  fail:
 	iso_sched_free(stream, sched);
@@ -1612,7 +1643,8 @@ static void itd_link_urb(
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs++;
 
 	/* fill iTDs uframe by uframe */
-	for (packet = 0, itd = NULL; packet &lt; urb-&gt;number_of_packets; ) {
+	for (packet = iso_sched-&gt;first_packet, itd = NULL;
+			packet &lt; urb-&gt;number_of_packets;) {
 		if (itd == NULL) {
 			/* ASSERT:  we have all necessary itds */
 			// BUG_ON (list_empty (&amp;iso_sched-&gt;td_list));
@@ -1806,10 +1838,14 @@ static int itd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	if (unlikely(status))
 		goto done_not_linked;
 	status = iso_stream_schedule(ehci, urb, stream);
-	if (likely (status == 0))
+	if (likely(status == 0)) {
 		itd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
-	else
+	} else if (status &gt; 0) {
+		status = 0;
+		ehci_urb_done(ehci, urb, 0);
+	} else {
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+	}
  done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
  done:
@@ -2010,7 +2046,7 @@ static void sitd_link_urb(
 	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs++;
 
 	/* fill sITDs frame by frame */
-	for (packet = 0, sitd = NULL;
+	for (packet = sched-&gt;first_packet, sitd = NULL;
 			packet &lt; urb-&gt;number_of_packets;
 			packet++) {
 
@@ -2180,10 +2216,14 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 	if (unlikely(status))
 		goto done_not_linked;
 	status = iso_stream_schedule(ehci, urb, stream);
-	if (status == 0)
+	if (likely(status == 0)) {
 		sitd_link_urb (ehci, urb, ehci-&gt;periodic_size &lt;&lt; 3, stream);
-	else
+	} else if (status &gt; 0) {
+		status = 0;
+		ehci_urb_done(ehci, urb, 0);
+	} else {
 		usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
+	}
  done_not_linked:
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
  done:
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 291db7d09f22..2d401927e143 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -434,6 +434,7 @@ struct ehci_iso_packet {
 struct ehci_iso_sched {
 	struct list_head	td_list;
 	unsigned		span;
+	unsigned		first_packet;
 	struct ehci_iso_packet	packet [0];
 };
 </pre>
    <div class="pagination">
        <a href='2_32.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><span>[33]</span><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_34.html'>Next&gt;&gt;</a>
    <div>
</body>
