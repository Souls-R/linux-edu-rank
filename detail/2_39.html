<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_38.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><span>[39]</span><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_40.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6d5df8976266d8e40603601f7695537f9f3dc9e2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 18 12:04:54 2013 -0400

    USB: EHCI: decrease schedule-status poll timeout
    
    This patch (as1657) decreases the timeout used by ehci-hcd for polling
    the async and periodic schedule statuses.  The timeout is currently
    set to 20 ms, which is much too high.  Controllers should always
    update the schedule status within one or two ms of being told to do
    so; if they don't then something is wrong.
    
    Furthermore, bug reports have shown that sometimes controllers
    (particularly those made by VIA) don't update the status bit at all,
    even when the schedule does change state.  When this happens, polling
    for 20 ms would cause an unnecessarily long delay.
    
    The delay is reduced to somewhere between 2 and 4 ms, depending on the
    slop allowed by the kernel's high-res timers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..cc9ad5892d19 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,8 +113,8 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
+		/* Poll again later, but give up after about 2-4 ms */
+		if (ehci-&gt;ASS_poll_count++ &lt; 2) {
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
 			return;
 		}
@@ -159,8 +159,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;PSS_poll_count++ &lt; 20) {
+		/* Poll again later, but give up after about 2-4 ms */
+		if (ehci-&gt;PSS_poll_count++ &lt; 2) {
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 			return;
 		}</pre><hr><pre>commit 2a40f324541ee61c22146214349c2ce9f5c30bcf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 15 14:40:26 2013 -0400

    USB: EHCI: fix regression during bus resume
    
    This patch (as1663) fixes a regression caused by commit
    6e0c3339a6f19d748f16091d0a05adeb1e1f822b (USB: EHCI: unlink one async
    QH at a time).  In order to avoid keeping multiple QHs in an unusable
    intermediate state, that commit changed unlink_empty_async() so that
    it unlinks only one empty QH at a time.
    
    However, when the EHCI root hub is suspended, _all_ async QHs need to
    be unlinked.  ehci_bus_suspend() used to do this by calling
    unlink_empty_async(), but now this only unlinks one of the QHs, not
    all of them.
    
    The symptom is that when the root hub is resumed, USB communications
    don't work for some period of time.  This is because ehci-hcd doesn't
    realize it needs to restart the async schedule; it assumes that
    because some QHs are already on the schedule, the schedule must be
    running.
    
    The easiest way to fix the problem is add a new function that unlinks
    all the async QHs when the root hub is suspended.
    
    This patch should be applied to all kernels that have the 6e0c3339a6f1
    commit.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Adrian Bassett &lt;adrian.bassett@hotmail.co.uk&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5726cb144abf..416a6dce5e11 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -302,6 +302,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void unlink_empty_async(struct ehci_hcd *ehci);
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4d3b294f203e..7d06e77f6c4f 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -328,7 +328,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
-	unlink_empty_async(ehci);
+	unlink_empty_async_suspended(ehci);
 	ehci_handle_intr_unlinks(ehci);
 	end_free_itds(ehci);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 5464665f0b6a..23d136904285 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1316,6 +1316,19 @@ static void unlink_empty_async(struct ehci_hcd *ehci)
 	}
 }
 
+/* The root hub is suspended; unlink all the async QHs */
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh;
+
+	while (ehci-&gt;async-&gt;qh_next.qh) {
+		qh = ehci-&gt;async-&gt;qh_next.qh;
+		WARN_ON(!list_empty(&amp;qh-&gt;qtd_list));
+		single_unlink_async(ehci, qh);
+	}
+	start_iaa_cycle(ehci, false);
+}
+
 /* makes sure the async qh will become idle */
 /* caller must own ehci-&gt;lock */
 </pre><hr><pre>commit 54a419668b0f27b7982807fb2376d237e0a0ce05
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 12 12:44:39 2013 +0200

    USB: EHCI: split ehci-omap out to a separate driver
    
    This patch (as1645) converts ehci-omap over to the new "ehci-hcd is a
    library" approach, so that it can coexist peacefully with other EHCI
    platform drivers and can make use of the private area allocated at
    the end of struct ehci_hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index c59a1126926f..62f4e9a38557 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -155,7 +155,7 @@ config USB_EHCI_MXC
 	  Variation of ARC USB block used in some Freescale chips.
 
 config USB_EHCI_HCD_OMAP
-	bool "EHCI support for OMAP3 and later chips"
+	tristate "EHCI support for OMAP3 and later chips"
 	depends on USB_EHCI_HCD &amp;&amp; ARCH_OMAP
 	default y
 	---help---
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 001fbff2fdef..56de4106c8b3 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
 obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
 obj-$(CONFIG_USB_EHCI_HCD_PLATFORM)	+= ehci-platform.o
 obj-$(CONFIG_USB_EHCI_MXC)	+= ehci-mxc.o
+obj-$(CONFIG_USB_EHCI_HCD_OMAP)	+= ehci-omap.o
 
 obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
 obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b416a3fc9959..303b0222cd6d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1252,11 +1252,6 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_HCD_OMAP
-#include "ehci-omap.c"
-#define        PLATFORM_DRIVER         ehci_hcd_omap_driver
-#endif
-
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
@@ -1346,6 +1341,7 @@ MODULE_LICENSE ("GPL");
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_EHCI_MXC) &amp;&amp; \
+	!IS_ENABLED(CONFIG_USB_EHCI_HCD_OMAP) &amp;&amp; \
 	!defined(PLATFORM_DRIVER) &amp;&amp; \
 	!defined(PS3_SYSTEM_BUS_DRIVER) &amp;&amp; \
 	!defined(OF_PLATFORM_DRIVER) &amp;&amp; \
diff --git a/drivers/usb/host/ehci-omap.c b/drivers/usb/host/ehci-omap.c
index 0555ee42d7cb..fa667577d9b9 100644
--- a/drivers/usb/host/ehci-omap.c
+++ b/drivers/usb/host/ehci-omap.c
@@ -36,6 +36,9 @@
  *	- convert to use hwmod and runtime PM
  */
 
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/io.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/usb/ulpi.h&gt;
@@ -43,6 +46,10 @@
 #include &lt;linux/pm_runtime.h&gt;
 #include &lt;linux/gpio.h&gt;
 #include &lt;linux/clk.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/hcd.h&gt;
+
+#include "ehci.h"
 
 #include &lt;linux/platform_data/usb-omap.h&gt;
 
@@ -57,9 +64,11 @@
 #define	EHCI_INSNREG05_ULPI_EXTREGADD_SHIFT		8
 #define	EHCI_INSNREG05_ULPI_WRDATA_SHIFT		0
 
-/*-------------------------------------------------------------------------*/
+#define DRIVER_DESC "OMAP-EHCI Host Controller driver"
 
-static const struct hc_driver ehci_omap_hc_driver;
+static const char hcd_name[] = "ehci-omap";
+
+/*-------------------------------------------------------------------------*/
 
 
 static inline void ehci_write(void __iomem *base, u32 reg, u32 val)
@@ -166,6 +175,12 @@ static void disable_put_regulator(
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
 
+static struct hc_driver __read_mostly ehci_omap_hc_driver;
+
+static const struct ehci_driver_overrides ehci_omap_overrides __initdata = {
+	.reset =		omap_ehci_init,
+};
+
 /**
  * ehci_hcd_omap_probe - initialize TI-based HCDs
  *
@@ -315,56 +330,33 @@ static struct platform_driver ehci_hcd_omap_driver = {
 	/*.suspend		= ehci_hcd_omap_suspend, */
 	/*.resume		= ehci_hcd_omap_resume, */
 	.driver = {
-		.name		= "ehci-omap",
+		.name		= hcd_name,
 	}
 };
 
 /*-------------------------------------------------------------------------*/
 
-static const struct hc_driver ehci_omap_hc_driver = {
-	.description		= hcd_name,
-	.product_desc		= "OMAP-EHCI Host Controller",
-	.hcd_priv_size		= sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq			= ehci_irq,
-	.flags			= HCD_MEMORY | HCD_USB2,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset			= omap_ehci_init,
-	.start			= ehci_run,
-	.stop			= ehci_stop,
-	.shutdown		= ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue		= ehci_urb_enqueue,
-	.urb_dequeue		= ehci_urb_dequeue,
-	.endpoint_disable	= ehci_endpoint_disable,
-	.endpoint_reset		= ehci_endpoint_reset,
+static int __init ehci_omap_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
 
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number	= ehci_get_frame,
+	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
 
-	/*
-	 * root hub support
-	 */
-	.hub_status_data	= ehci_hub_status_data,
-	.hub_control		= ehci_hub_control,
-	.bus_suspend		= ehci_bus_suspend,
-	.bus_resume		= ehci_bus_resume,
+	ehci_init_driver(&amp;ehci_omap_hc_driver, &amp;ehci_omap_overrides);
+	return platform_driver_register(&amp;ehci_hcd_omap_driver);
+}
+module_init(ehci_omap_init);
 
-	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
-};
+static void __exit ehci_omap_cleanup(void)
+{
+	platform_driver_unregister(&amp;ehci_hcd_omap_driver);
+}
+module_exit(ehci_omap_cleanup);
 
 MODULE_ALIAS("platform:ehci-omap");
 MODULE_AUTHOR("Texas Instruments, Inc.");
 MODULE_AUTHOR("Felipe Balbi &lt;felipe.balbi@nokia.com&gt;");
 
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");</pre><hr><pre>commit feca7746d5d9e84b105a613b7f3b6ad00d327372
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 1 10:51:15 2013 -0500

    USB: EHCI: don't check DMA values in QH overlays
    
    This patch (as1661) fixes a rather obscure bug in ehci-hcd.  In a
    couple of places, the driver compares the DMA address stored in a QH's
    overlay region with the address of a particular qTD, in order to see
    whether that qTD is the one currently being processed by the hardware.
    (If it is then the status in the QH's overlay region is more
    up-to-date than the status in the qTD, and if it isn't then the
    overlay's value needs to be adjusted when the QH is added back to the
    active schedule.)
    
    However, DMA address in the overlay region isn't always valid.  It
    sometimes will contain a stale value, which may happen by coincidence
    to be equal to a qTD's DMA address.  Instead of checking the DMA
    address, we should check whether the overlay region is active and
    valid.  The patch tests the ACTIVE bit in the overlay, and clears this
    bit when the overlay becomes invalid (which happens when the
    currently-executing URB is unlinked).
    
    This is the second part of a fix for the regression reported at:
    
            https://bugs.launchpad.net/bugs/1088733
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Joseph Salisbury &lt;joseph.salisbury@canonical.com&gt;
    Reported-and-tested-by: Stephen Thirlwall &lt;sdt@dr.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 7bf2b4eeb9ce..5464665f0b6a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -135,7 +135,7 @@ qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		 * qtd is updated in qh_completions(). Update the QH
 		 * overlay here.
 		 */
-		if (cpu_to_hc32(ehci, qtd-&gt;qtd_dma) == qh-&gt;hw-&gt;hw_current) {
+		if (qh-&gt;hw-&gt;hw_token &amp; ACTIVE_BIT(ehci)) {
 			qh-&gt;hw-&gt;hw_qtd_next = qtd-&gt;hw_next;
 			qtd = NULL;
 		}
@@ -449,11 +449,19 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			else if (last_status == -EINPROGRESS &amp;&amp; !urb-&gt;unlinked)
 				continue;
 
-			/* qh unlinked; token in overlay may be most current */
-			if (state == QH_STATE_IDLE
-					&amp;&amp; cpu_to_hc32(ehci, qtd-&gt;qtd_dma)
-						== hw-&gt;hw_current) {
+			/*
+			 * If this was the active qtd when the qh was unlinked
+			 * and the overlay's token is active, then the overlay
+			 * hasn't been written back to the qtd yet so use its
+			 * token instead of the qtd's.  After the qtd is
+			 * processed and removed, the overlay won't be valid
+			 * any more.
+			 */
+			if (state == QH_STATE_IDLE &amp;&amp;
+					qh-&gt;qtd_list.next == &amp;qtd-&gt;qtd_list &amp;&amp;
+					(hw-&gt;hw_token &amp; ACTIVE_BIT(ehci))) {
 				token = hc32_to_cpu(ehci, hw-&gt;hw_token);
+				hw-&gt;hw_token &amp;= ~ACTIVE_BIT(ehci);
 
 				/* An unlink may leave an incomplete
 				 * async transaction in the TT buffer.</pre><hr><pre>commit 6402c796d3b4205d3d7296157956c5100a05d7d6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 1 10:50:08 2013 -0500

    USB: EHCI: work around silicon bug in Intel's EHCI controllers
    
    This patch (as1660) works around a hardware problem present in some
    (if not all) Intel EHCI controllers.  After a QH has been unlinked
    from the async schedule and the corresponding IAA interrupt has
    occurred, the controller is not supposed access the QH and its qTDs.
    There certainly shouldn't be any more DMA writes to those structures.
    Nevertheless, Intel's controllers have been observed to perform a
    final writeback to the QH's overlay region and to the most recent qTD.
    For more information and a test program to determine whether this
    problem is present in a particular controller, see
    
            http://marc.info/?l=linux-usb&amp;m=135492071812265&amp;w=2
            http://marc.info/?l=linux-usb&amp;m=136182570800963&amp;w=2
    
    This patch works around the problem by always waiting for two IAA
    cycles when unlinking an async QH.  The extra IAA delay gives the
    controller time to perform its final writeback.
    
    Surprisingly enough, the effects of this silicon bug have gone
    undetected until quite recently.  More through luck than anything
    else, it hasn't caused any apparent problems.  However, it does
    interact badly with the path that follows this one, so it needs to be
    addressed.
    
    This is the first part of a fix for the regression reported at:
    
            https://bugs.launchpad.net/bugs/1088733
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Stephen Thirlwall &lt;sdt@dr.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index b416a3fc9959..5726cb144abf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -748,11 +748,9 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		/* guard against (alleged) silicon errata */
 		if (cmd &amp; CMD_IAAD)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
-		if (ehci-&gt;async_iaa) {
+		if (ehci-&gt;async_iaa)
 			COUNT(ehci-&gt;stats.iaa);
-			end_unlink_async(ehci);
-		} else
-			ehci_dbg(ehci, "IAA with nothing unlinked?\n");
+		end_unlink_async(ehci);
 	}
 
 	/* remote wakeup [4.3.1] */
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index fd252f0cfb3a..7bf2b4eeb9ce 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1170,7 +1170,7 @@ static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	struct ehci_qh		*prev;
 
 	/* Add to the end of the list of QHs waiting for the next IAAD */
-	qh-&gt;qh_state = QH_STATE_UNLINK;
+	qh-&gt;qh_state = QH_STATE_UNLINK_WAIT;
 	if (ehci-&gt;async_unlink)
 		ehci-&gt;async_unlink_last-&gt;unlink_next = qh;
 	else
@@ -1213,9 +1213,19 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 
 		/* Do only the first waiting QH (nVidia bug?) */
 		qh = ehci-&gt;async_unlink;
-		ehci-&gt;async_iaa = qh;
-		ehci-&gt;async_unlink = qh-&gt;unlink_next;
-		qh-&gt;unlink_next = NULL;
+
+		/*
+		 * Intel (?) bug: The HC can write back the overlay region
+		 * even after the IAA interrupt occurs.  In self-defense,
+		 * always go through two IAA cycles for each QH.
+		 */
+		if (qh-&gt;qh_state == QH_STATE_UNLINK_WAIT) {
+			qh-&gt;qh_state = QH_STATE_UNLINK;
+		} else {
+			ehci-&gt;async_iaa = qh;
+			ehci-&gt;async_unlink = qh-&gt;unlink_next;
+			qh-&gt;unlink_next = NULL;
+		}
 
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();</pre><hr><pre>commit 221f8dfca89276d8aec54c6d07fbe20c281668f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 26 13:43:41 2013 -0500

    USB: EHCI: revert "remove ASS/PSS polling timeout"
    
    This patch (as1649) reverts commit
    55bcdce8a8228223ec4d17d8ded8134ed265d2c5 (USB: EHCI: remove ASS/PSS
    polling timeout).  That commit was written under the assumption that
    some controllers may take a very long time to turn off their async and
    periodic schedules.  It now appears that in fact the schedules do get
    turned off reasonably quickly, but some controllers occasionally leave
    the schedules' status bits turned on and consequently ehci-hcd can't
    tell that the schedules are off.
    
    VIA controllers in particular have this problem.  ehci-hcd tells the
    hardware to turn off the async schedule, the schedule does get turned
    off, but the status bit remains on.  Since the EHCI spec requires that
    the schedules not be re-enabled until the previous disable has taken
    effect, with an unlimited timeout the async schedule never gets turned
    back on.  The resulting symptom is that the system is unable to
    communicate with USB devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Ronald &lt;ronald645@gmail.com&gt;
    Reported-and-tested-by: Paul Hartman &lt;paul.hartman@gmail.com&gt;
    Reported-and-tested-by: Dieter Nützel &lt;dieter@nuetzel-hh.de&gt;
    Reported-and-tested-by: Jean Delvare &lt;khali@linux-fr.org&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index f904071d70df..20dbdcbe9b0f 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,15 +113,14 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later */
-		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
-		++ehci-&gt;ASS_poll_count;
-		return;
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+			return;
+		}
+		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
-
-	if (ehci-&gt;ASS_poll_count &gt; 20)
-		ehci_dbg(ehci, "ASS poll count reached %d\n",
-				ehci-&gt;ASS_poll_count);
 	ehci-&gt;ASS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
@@ -160,14 +159,14 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later */
-		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
-		return;
+		/* Poll again later, but give up after about 20 ms */
+		if (ehci-&gt;PSS_poll_count++ &lt; 20) {
+			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+			return;
+		}
+		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
-
-	if (ehci-&gt;PSS_poll_count &gt; 20)
-		ehci_dbg(ehci, "PSS poll count reached %d\n",
-				ehci-&gt;PSS_poll_count);
 	ehci-&gt;PSS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */</pre><hr><pre>commit 3e619d04159be54b3daa0b7036b0ce9e067f4b5d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:36:40 2013 -0500

    USB: EHCI: fix bug in scheduling periodic split transfers
    
    This patch (as1654) fixes a very old bug in ehci-hcd, connected with
    scheduling of periodic split transfers.  The calculations for
    full/low-speed bus usage are all carried out after the correction for
    bit-stuffing has been applied, but the values in the max_tt_usecs
    array assume it hasn't been.  The array should allow for allocation of
    up to 90% of the bus capacity, which is 900 us, not 780 us.
    
    The symptom caused by this bug is that any isochronous transfer to a
    full-speed device with a maxpacket size larger than about 980 bytes is
    always rejected with a -ENOSPC error.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 2b6917dc3996..b476daf49f6f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -213,7 +213,7 @@ static inline unsigned char tt_start_uframe(struct ehci_hcd *ehci, __hc32 mask)
 }
 
 static const unsigned char
-max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 30, 0 };
+max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 125, 25 };
 
 /* carryover low/fullspeed bandwidth that crosses uframe boundries */
 static inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])</pre><hr><pre>commit b09a61cc0bc2a7151f4ab652489e85253d5d0175
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:35:02 2013 -0500

    USB: EHCI: fix for leaking isochronous data
    
    This patch (as1653) fixes a bug in ehci-hcd.  Unlike iTD entries, an
    siTD entry in the periodic schedule may not complete until the frame
    after the one it belongs to.  Consequently, when scanning the periodic
    schedule it is necessary to start with the frame _preceding_ the one
    where the previous scan ended.
    
    Not doing this properly can result in memory leaks and failures to
    complete isochronous URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andy Leiserson &lt;andy@leiserson.org&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 69ebee73c0c1..2b6917dc3996 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -2212,11 +2212,11 @@ static void scan_isoc(struct ehci_hcd *ehci)
 	}
 	ehci-&gt;now_frame = now_frame;
 
+	frame = ehci-&gt;last_iso_frame;
 	for (;;) {
 		union ehci_shadow	q, *q_p;
 		__hc32			type, *hw_p;
 
-		frame = ehci-&gt;last_iso_frame;
 restart:
 		/* scan each element in frame's queue for completions */
 		q_p = &amp;ehci-&gt;pshadow [frame];
@@ -2321,6 +2321,9 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		/* Stop when we have reached the current frame */
 		if (frame == now_frame)
 			break;
-		ehci-&gt;last_iso_frame = (frame + 1) &amp; fmask;
+
+		/* The last frame may still have active siTDs */
+		ehci-&gt;last_iso_frame = frame;
+		frame = (frame + 1) &amp; fmask;
 	}
 }</pre><hr><pre>commit 2f0760774711c957c395b31131b848043af98edf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:40:14 2013 -0500

    USB: GADGET: optionally force full-speed for net2280 UDC
    
    This patch (as1656) adds a module parameter to the net2280 UDC driver
    to force full-speed operation.  It is intended for testing purposes,
    where one wants to check how well a full-speed device performs when
    attached to a high-speed bus.  Without this parameter it would be
    necessary to interpose a full-speed hub; otherwise the net2280 would
    connect at high speed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Felipe Balbi &lt;balbi@ti.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 708c0b55dcc8..a1b650e11339 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -116,6 +116,10 @@ static bool enable_suspend = 0;
 /* "modprobe net2280 enable_suspend=1" etc */
 module_param (enable_suspend, bool, S_IRUGO);
 
+/* force full-speed operation */
+static bool full_speed;
+module_param(full_speed, bool, 0444);
+MODULE_PARM_DESC(full_speed, "force full-speed mode -- for testing only!");
 
 #define	DIR_STRING(bAddress) (((bAddress) &amp; USB_DIR_IN) ? "in" : "out")
 
@@ -1899,6 +1903,10 @@ static int net2280_start(struct usb_gadget *_gadget,
 	retval = device_create_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_queues);
 	if (retval) goto err_func;
 
+	/* Enable force-full-speed testing mode, if desired */
+	if (full_speed)
+		writel(1 &lt;&lt; FORCE_FULL_SPEED_MODE, &amp;dev-&gt;usb-&gt;xcvrdiag);
+
 	/* ... then enable host detection and ep0; and we're ready
 	 * for set_configuration as well as eventual disconnect.
 	 */
@@ -1957,6 +1965,10 @@ static int net2280_stop(struct usb_gadget *_gadget,
 	dev-&gt;driver = NULL;
 
 	net2280_led_active (dev, 0);
+
+	/* Disable full-speed test mode */
+	writel(0, &amp;dev-&gt;usb-&gt;xcvrdiag);
+
 	device_remove_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_function);
 	device_remove_file (&amp;dev-&gt;pdev-&gt;dev, &amp;dev_attr_queues);
 
@@ -2841,6 +2853,9 @@ static void net2280_shutdown (struct pci_dev *pdev)
 
 	/* disable the pullup so the host will think we're gone */
 	writel (0, &amp;dev-&gt;usb-&gt;usbctl);
+
+	/* Disable full-speed test mode */
+	writel(0, &amp;dev-&gt;usb-&gt;xcvrdiag);
 }
 
 </pre><hr><pre>commit d0b4652f80c3276a57ede3b6b6d8159fa26c091f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 30 16:38:11 2013 -0500

    USB: altsetting overrides for usbtest
    
    The usbtest driver includes some rather simple-minded logic for
    selecting an altsetting to test.  It doesn't work well for the g_zero
    gadget, because it selects altsetting 0 (which doesn't have
    isochronous endpoints) rather than altsetting 1 (which does have them,
    if the gadget's hardware supports them).  This prevents usbtest's
    isochronous tests (15, 16, 22, and 23) from working with g_zero.
    
    Since g_zero is one of the most common gadget drivers used for USB
    testing, usbtest should do a better job of supporting it.  But since
    some programs may rely on the current scheme for selecting
    altsettings, I didn't want to change it.
    
    Instead, this patch (as1655) adds a module parameter to usbtest, which
    can be used to override the default altsetting.  Since usbtest is
    never used by normal users (most distributions probably don't even
    build it), the new module parameter won't inconvenience anybody.  In
    any case, it is entirely optional -- leaving it unset preserves the
    existing behavior.
    
    The patch also fixes a related bug in usbtest: After selecting an
    altsetting, the driver neglects to store its selection.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 268148de9714..8b4ca1cb450a 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -11,6 +11,12 @@
 #include &lt;linux/usb.h&gt;
 
 
+/*-------------------------------------------------------------------------*/
+
+static int override_alt = -1;
+module_param_named(alt, override_alt, int, 0644);
+MODULE_PARM_DESC(alt, "&gt;= 0 to override altsetting selection");
+
 /*-------------------------------------------------------------------------*/
 
 /* FIXME make these public somewhere; usbdevfs.h? */
@@ -103,6 +109,10 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 		iso_in = iso_out = NULL;
 		alt = intf-&gt;altsetting + tmp;
 
+		if (override_alt &gt;= 0 &amp;&amp;
+				override_alt != alt-&gt;desc.bAlternateSetting)
+			continue;
+
 		/* take the first altsetting with in-bulk + out-bulk;
 		 * ignore other endpoints and altsettings.
 		 */
@@ -144,6 +154,7 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 
 found:
 	udev = testdev_to_usbdev(dev);
+	dev-&gt;info-&gt;alt = alt-&gt;desc.bAlternateSetting;
 	if (alt-&gt;desc.bAlternateSetting != 0) {
 		tmp = usb_set_interface(udev,
 				alt-&gt;desc.bInterfaceNumber,
@@ -2280,7 +2291,7 @@ usbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)
 			wtest = " intr-out";
 		}
 	} else {
-		if (info-&gt;autoconf) {
+		if (override_alt &gt;= 0 || info-&gt;autoconf) {
 			int status;
 
 			status = get_endpoints(dev, intf);</pre>
    <div class="pagination">
        <a href='2_38.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><span>[39]</span><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_40.html'>Next&gt;&gt;</a>
    <div>
</body>
