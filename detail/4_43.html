<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_42.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><span>[43]</span><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_44.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c9b6cbe56d3ac471e6cd72a59ec9e324b3417016
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jul 27 16:36:45 2007 -0400

    knfsd: nfs4 name-&gt;id mapping not correctly parsing negative downcall
    
    Note that qword_get() returns length or -1, not an -ERROR.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by:  Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfs4idmap.c b/fs/nfsd/nfs4idmap.c
index 2ccffde81b84..4c0c683ce07a 100644
--- a/fs/nfsd/nfs4idmap.c
+++ b/fs/nfsd/nfs4idmap.c
@@ -207,6 +207,7 @@ idtoname_parse(struct cache_detail *cd, char *buf, int buflen)
 {
 	struct ent ent, *res;
 	char *buf1, *bp;
+	int len;
 	int error = -EINVAL;
 
 	if (buf[buflen - 1] != '\n')
@@ -248,10 +249,11 @@ idtoname_parse(struct cache_detail *cd, char *buf, int buflen)
 		goto out;
 
 	/* Name */
-	error = qword_get(&amp;buf, buf1, PAGE_SIZE);
-	if (error == -EINVAL)
+	error = -EINVAL;
+	len = qword_get(&amp;buf, buf1, PAGE_SIZE);
+	if (len &lt; 0)
 		goto out;
-	if (error == -ENOENT)
+	if (len == 0)
 		set_bit(CACHE_NEGATIVE, &amp;ent.h.flags);
 	else {
 		if (error &gt;= IDMAP_NAMESZ) {</pre><hr><pre>commit 2fdada03b3876ab9f84ede160f187e888cafefb4
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jul 27 16:10:37 2007 -0400

    knfsd: demote some printk()s to dprintk()s
    
    To quote a recent mail from Andrew Morton:
    
            Look: if there's a way in which an unprivileged user can trigger
            a printk we fix it, end of story.
    
    OK.  I assume that goes double for printk()s that might be triggered by
    random hosts on the internet.  So, disable some printk()s that look like
    they could be triggered by malfunctioning or malicious clients.  For
    now, just downgrade them to dprintk()s.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by:  Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 29b7e63cb32c..18ead1790bb3 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -238,12 +238,12 @@ nfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 			break;
              	case NFS4_OPEN_CLAIM_DELEGATE_PREV:
 			open-&gt;op_stateowner-&gt;so_confirmed = 1;
-			printk("NFSD: unsupported OPEN claim type %d\n",
+			dprintk("NFSD: unsupported OPEN claim type %d\n",
 				open-&gt;op_claim_type);
 			status = nfserr_notsupp;
 			goto out;
 		default:
-			printk("NFSD: Invalid OPEN claim type %d\n",
+			dprintk("NFSD: Invalid OPEN claim type %d\n",
 				open-&gt;op_claim_type);
 			status = nfserr_inval;
 			goto out;
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 578d809e85ec..2b20eb8589a0 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -509,7 +509,7 @@ check_name(struct xdr_netobj name) {
 	if (name.len == 0) 
 		return 0;
 	if (name.len &gt; NFS4_OPAQUE_LIMIT) {
-		printk("NFSD: check_name: name too long(%d)!\n", name.len);
+		dprintk("NFSD: check_name: name too long(%d)!\n", name.len);
 		return 0;
 	}
 	return 1;
@@ -1742,7 +1742,7 @@ nfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open, struct nfs4_sta
 	if (open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS
 			&amp;&amp; flag == NFS4_OPEN_DELEGATE_NONE
 			&amp;&amp; open-&gt;op_delegate_type != NFS4_OPEN_DELEGATE_NONE)
-		printk("NFSD: WARNING: refusing delegation reclaim\n");
+		dprintk("NFSD: WARNING: refusing delegation reclaim\n");
 	open-&gt;op_delegate_type = flag;
 }
 
@@ -2151,7 +2151,7 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 	*sopp = NULL;
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid)) {
-		printk("NFSD: preprocess_seqid_op: magic stateid!\n");
+		dprintk("NFSD: preprocess_seqid_op: magic stateid!\n");
 		return nfserr_bad_stateid;
 	}
 
@@ -2202,7 +2202,7 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 	}
 
 	if ((flags &amp; CHECK_FH) &amp;&amp; nfs4_check_fh(current_fh, stp)) {
-		printk("NFSD: preprocess_seqid_op: fh-stateid mismatch!\n");
+		dprintk("NFSD: preprocess_seqid_op: fh-stateid mismatch!\n");
 		return nfserr_bad_stateid;
 	}
 
@@ -2218,22 +2218,22 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 		goto check_replay;
 
 	if (sop-&gt;so_confirmed &amp;&amp; flags &amp; CONFIRM) {
-		printk("NFSD: preprocess_seqid_op: expected"
+		dprintk("NFSD: preprocess_seqid_op: expected"
 				" unconfirmed stateowner!\n");
 		return nfserr_bad_stateid;
 	}
 	if (!sop-&gt;so_confirmed &amp;&amp; !(flags &amp; CONFIRM)) {
-		printk("NFSD: preprocess_seqid_op: stateowner not"
+		dprintk("NFSD: preprocess_seqid_op: stateowner not"
 				" confirmed yet!\n");
 		return nfserr_bad_stateid;
 	}
 	if (stateid-&gt;si_generation &gt; stp-&gt;st_stateid.si_generation) {
-		printk("NFSD: preprocess_seqid_op: future stateid?!\n");
+		dprintk("NFSD: preprocess_seqid_op: future stateid?!\n");
 		return nfserr_bad_stateid;
 	}
 
 	if (stateid-&gt;si_generation &lt; stp-&gt;st_stateid.si_generation) {
-		printk("NFSD: preprocess_seqid_op: old stateid!\n");
+		dprintk("NFSD: preprocess_seqid_op: old stateid!\n");
 		return nfserr_old_stateid;
 	}
 	renew_client(sop-&gt;so_client);
@@ -2245,7 +2245,7 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 		/* indicate replay to calling function */
 		return nfserr_replay_me;
 	}
-	printk("NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d)\n",
+	dprintk("NFSD: preprocess_seqid_op: bad seqid (expected %d, got %d)\n",
 			sop-&gt;so_seqid, seqid);
 	*sopp = NULL;
 	return nfserr_bad_seqid;
@@ -2858,7 +2858,7 @@ nfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 			file_lock.fl_type = F_WRLCK;
 		break;
 		default:
-			printk("NFSD: nfs4_lockt: bad lock type!\n");
+			dprintk("NFSD: nfs4_lockt: bad lock type!\n");
 			status = nfserr_inval;
 		goto out;
 	}</pre><hr><pre>commit 599e0a2290b22d959c7748bda83da3614187a299
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Jul 26 17:04:54 2007 -0400

    knfsd: cleanup of nfsd4 cmp_* functions
    
    Benny Halevy suggested renaming cmp_* to same_* to make the meaning of
    the return value clearer.
    
    Fix some nearby style deviations while we're at it, including a small
    swath of creative indentation in nfs4_preprocess_seqid_op().
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by:  Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 3f559700788f..578d809e85ec 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -462,26 +462,28 @@ copy_cred(struct svc_cred *target, struct svc_cred *source) {
 }
 
 static inline int
-same_name(const char *n1, const char *n2) {
+same_name(const char *n1, const char *n2)
+{
 	return 0 == memcmp(n1, n2, HEXDIR_LEN);
 }
 
 static int
-cmp_verf(nfs4_verifier *v1, nfs4_verifier *v2) {
-	return(!memcmp(v1-&gt;data,v2-&gt;data,sizeof(v1-&gt;data)));
+same_verf(nfs4_verifier *v1, nfs4_verifier *v2)
+{
+	return 0 == memcmp(v1-&gt;data, v2-&gt;data, sizeof(v1-&gt;data));
 }
 
 static int
-cmp_clid(clientid_t * cl1, clientid_t * cl2) {
-	return((cl1-&gt;cl_boot == cl2-&gt;cl_boot) &amp;&amp;
-	   	(cl1-&gt;cl_id == cl2-&gt;cl_id));
+same_clid(clientid_t *cl1, clientid_t *cl2)
+{
+	return (cl1-&gt;cl_boot == cl2-&gt;cl_boot) &amp;&amp; (cl1-&gt;cl_id == cl2-&gt;cl_id);
 }
 
 /* XXX what about NGROUP */
 static int
-cmp_creds(struct svc_cred *cr1, struct svc_cred *cr2){
-	return(cr1-&gt;cr_uid == cr2-&gt;cr_uid);
-
+same_creds(struct svc_cred *cr1, struct svc_cred *cr2)
+{
+	return cr1-&gt;cr_uid == cr2-&gt;cr_uid;
 }
 
 static void
@@ -546,7 +548,7 @@ find_confirmed_client(clientid_t *clid)
 	unsigned int idhashval = clientid_hashval(clid-&gt;cl_id);
 
 	list_for_each_entry(clp, &amp;conf_id_hashtbl[idhashval], cl_idhash) {
-		if (cmp_clid(&amp;clp-&gt;cl_clientid, clid))
+		if (same_clid(&amp;clp-&gt;cl_clientid, clid))
 			return clp;
 	}
 	return NULL;
@@ -559,7 +561,7 @@ find_unconfirmed_client(clientid_t *clid)
 	unsigned int idhashval = clientid_hashval(clid-&gt;cl_id);
 
 	list_for_each_entry(clp, &amp;unconf_id_hashtbl[idhashval], cl_idhash) {
-		if (cmp_clid(&amp;clp-&gt;cl_clientid, clid))
+		if (same_clid(&amp;clp-&gt;cl_clientid, clid))
 			return clp;
 	}
 	return NULL;
@@ -753,7 +755,7 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		 * or different ip_address
 		 */
 		status = nfserr_clid_inuse;
-		if (!cmp_creds(&amp;conf-&gt;cl_cred, &amp;rqstp-&gt;rq_cred)
+		if (!same_creds(&amp;conf-&gt;cl_cred, &amp;rqstp-&gt;rq_cred)
 				|| conf-&gt;cl_addr != sin-&gt;sin_addr.s_addr) {
 			dprintk("NFSD: setclientid: string in use by client"
 				"at %u.%u.%u.%u\n", NIPQUAD(conf-&gt;cl_addr));
@@ -779,7 +781,7 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		gen_confirm(new);
 		gen_callback(new, setclid);
 		add_to_unconfirmed(new, strhashval);
-	} else if (cmp_verf(&amp;conf-&gt;cl_verifier, &amp;clverifier)) {
+	} else if (same_verf(&amp;conf-&gt;cl_verifier, &amp;clverifier)) {
 		/*
 		 * CASE 1:
 		 * cl_name match, confirmed, principal match
@@ -830,7 +832,7 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		gen_confirm(new);
 		gen_callback(new, setclid);
 		add_to_unconfirmed(new, strhashval);
-	} else if (!cmp_verf(&amp;conf-&gt;cl_confirm, &amp;unconf-&gt;cl_confirm)) {
+	} else if (!same_verf(&amp;conf-&gt;cl_confirm, &amp;unconf-&gt;cl_confirm)) {
 		/*	
 		 * CASE3:
 		 * confirmed found (name, principal match)
@@ -910,16 +912,16 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 		goto out;
 
 	if ((conf &amp;&amp; unconf) &amp;&amp; 
-	    (cmp_verf(&amp;unconf-&gt;cl_confirm, &amp;confirm)) &amp;&amp;
-	    (cmp_verf(&amp;conf-&gt;cl_verifier, &amp;unconf-&gt;cl_verifier)) &amp;&amp;
+	    (same_verf(&amp;unconf-&gt;cl_confirm, &amp;confirm)) &amp;&amp;
+	    (same_verf(&amp;conf-&gt;cl_verifier, &amp;unconf-&gt;cl_verifier)) &amp;&amp;
 	    (same_name(conf-&gt;cl_recdir,unconf-&gt;cl_recdir))  &amp;&amp;
-	    (!cmp_verf(&amp;conf-&gt;cl_confirm, &amp;unconf-&gt;cl_confirm))) {
+	    (!same_verf(&amp;conf-&gt;cl_confirm, &amp;unconf-&gt;cl_confirm))) {
 		/* CASE 1:
 		* unconf record that matches input clientid and input confirm.
 		* conf record that matches input clientid.
 		* conf and unconf records match names, verifiers
 		*/
-		if (!cmp_creds(&amp;conf-&gt;cl_cred, &amp;unconf-&gt;cl_cred)) 
+		if (!same_creds(&amp;conf-&gt;cl_cred, &amp;unconf-&gt;cl_cred))
 			status = nfserr_clid_inuse;
 		else {
 			/* XXX: We just turn off callbacks until we can handle
@@ -933,7 +935,7 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 		}
 	} else if ((conf &amp;&amp; !unconf) ||
 	    ((conf &amp;&amp; unconf) &amp;&amp; 
-	     (!cmp_verf(&amp;conf-&gt;cl_verifier, &amp;unconf-&gt;cl_verifier) ||
+	     (!same_verf(&amp;conf-&gt;cl_verifier, &amp;unconf-&gt;cl_verifier) ||
 	      !same_name(conf-&gt;cl_recdir, unconf-&gt;cl_recdir)))) {
 		/* CASE 2:
 		 * conf record that matches input clientid.
@@ -941,18 +943,18 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 		 * unconf-&gt;cl_name or unconf-&gt;cl_verifier don't match the
 		 * conf record.
 		 */
-		if (!cmp_creds(&amp;conf-&gt;cl_cred,&amp;rqstp-&gt;rq_cred))
+		if (!same_creds(&amp;conf-&gt;cl_cred, &amp;rqstp-&gt;rq_cred))
 			status = nfserr_clid_inuse;
 		else
 			status = nfs_ok;
 	} else if (!conf &amp;&amp; unconf
-			&amp;&amp; cmp_verf(&amp;unconf-&gt;cl_confirm, &amp;confirm)) {
+			&amp;&amp; same_verf(&amp;unconf-&gt;cl_confirm, &amp;confirm)) {
 		/* CASE 3:
 		 * conf record not found.
 		 * unconf record found.
 		 * unconf-&gt;cl_confirm matches input confirm
 		 */
-		if (!cmp_creds(&amp;unconf-&gt;cl_cred, &amp;rqstp-&gt;rq_cred)) {
+		if (!same_creds(&amp;unconf-&gt;cl_cred, &amp;rqstp-&gt;rq_cred)) {
 			status = nfserr_clid_inuse;
 		} else {
 			unsigned int hash =
@@ -967,8 +969,8 @@ nfsd4_setclientid_confirm(struct svc_rqst *rqstp,
 			conf = unconf;
 			status = nfs_ok;
 		}
-	} else if ((!conf || (conf &amp;&amp; !cmp_verf(&amp;conf-&gt;cl_confirm, &amp;confirm)))
-	    &amp;&amp; (!unconf || (unconf &amp;&amp; !cmp_verf(&amp;unconf-&gt;cl_confirm,
+	} else if ((!conf || (conf &amp;&amp; !same_verf(&amp;conf-&gt;cl_confirm, &amp;confirm)))
+	    &amp;&amp; (!unconf || (unconf &amp;&amp; !same_verf(&amp;unconf-&gt;cl_confirm,
 				    				&amp;confirm)))) {
 		/* CASE 4:
 		 * conf record not found, or if conf, conf-&gt;cl_confirm does not
@@ -1207,10 +1209,12 @@ move_to_close_lru(struct nfs4_stateowner *sop)
 }
 
 static int
-cmp_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner, clientid_t *clid) {
-	return ((sop-&gt;so_owner.len == owner-&gt;len) &amp;&amp; 
-	 !memcmp(sop-&gt;so_owner.data, owner-&gt;data, owner-&gt;len) &amp;&amp; 
-	  (sop-&gt;so_client-&gt;cl_clientid.cl_id == clid-&gt;cl_id));
+same_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner,
+							clientid_t *clid)
+{
+	return (sop-&gt;so_owner.len == owner-&gt;len) &amp;&amp;
+		0 == memcmp(sop-&gt;so_owner.data, owner-&gt;data, owner-&gt;len) &amp;&amp;
+		(sop-&gt;so_client-&gt;cl_clientid.cl_id == clid-&gt;cl_id);
 }
 
 static struct nfs4_stateowner *
@@ -1219,7 +1223,7 @@ find_openstateowner_str(unsigned int hashval, struct nfsd4_open *open)
 	struct nfs4_stateowner *so = NULL;
 
 	list_for_each_entry(so, &amp;ownerstr_hashtbl[hashval], so_strhash) {
-		if (cmp_owner_str(so, &amp;open-&gt;op_owner, &amp;open-&gt;op_clientid))
+		if (same_owner_str(so, &amp;open-&gt;op_owner, &amp;open-&gt;op_clientid))
 			return so;
 	}
 	return NULL;
@@ -2181,21 +2185,20 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 		lkflg = setlkflg(lock-&gt;lk_type);
 
 		if (lock-&gt;lk_is_new) {
-                       if (!sop-&gt;so_is_open_owner)
-			       return nfserr_bad_stateid;
-                       if (!cmp_clid(&amp;clp-&gt;cl_clientid, lockclid))
+			if (!sop-&gt;so_is_open_owner)
+				return nfserr_bad_stateid;
+			if (!same_clid(&amp;clp-&gt;cl_clientid, lockclid))
 			       return nfserr_bad_stateid;
-                       /* stp is the open stateid */
-                       status = nfs4_check_openmode(stp, lkflg);
-                       if (status)
-			       return status;
-               } else {
-                       /* stp is the lock stateid */
-                       status = nfs4_check_openmode(stp-&gt;st_openstp, lkflg);
-                       if (status)
-			       return status;
+			/* stp is the open stateid */
+			status = nfs4_check_openmode(stp, lkflg);
+			if (status)
+				return status;
+		} else {
+			/* stp is the lock stateid */
+			status = nfs4_check_openmode(stp-&gt;st_openstp, lkflg);
+			if (status)
+				return status;
                }
-
 	}
 
 	if ((flags &amp; CHECK_FH) &amp;&amp; nfs4_check_fh(current_fh, stp)) {
@@ -2561,7 +2564,7 @@ find_lockstateowner_str(struct inode *inode, clientid_t *clid,
 	struct nfs4_stateowner *op;
 
 	list_for_each_entry(op, &amp;lock_ownerstr_hashtbl[hashval], so_strhash) {
-		if (cmp_owner_str(op, owner, clid))
+		if (same_owner_str(op, owner, clid))
 			return op;
 	}
 	return NULL;
@@ -3025,7 +3028,7 @@ nfsd4_release_lockowner(struct svc_rqst *rqstp,
 	INIT_LIST_HEAD(&amp;matches);
 	for (i = 0; i &lt; LOCK_HASH_SIZE; i++) {
 		list_for_each_entry(sop, &amp;lock_ownerid_hashtbl[i], so_idhash) {
-			if (!cmp_owner_str(sop, owner, clid))
+			if (!same_owner_str(sop, owner, clid))
 				continue;
 			list_for_each_entry(stp, &amp;sop-&gt;so_stateids,
 					st_perstateowner) {</pre><hr><pre>commit 3b398f0ef8db6a9bb431474afd871f4295203d2d
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 24 21:38:18 2007 -0400

    knfsd: delete code made redundant by map_new_errors
    
    I moved this check into map_new_errors, but forgot to delete the
    original.  Oops.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by:  Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index 221eeaa68a2d..ef46f3228330 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -546,8 +546,6 @@ nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)
 	/* Now call the procedure handler, and encode NFS status. */
 	nfserr = proc-&gt;pc_func(rqstp, rqstp-&gt;rq_argp, rqstp-&gt;rq_resp);
 	nfserr = map_new_errors(rqstp-&gt;rq_vers, nfserr);
-	if (nfserr == nfserr_jukebox &amp;&amp; rqstp-&gt;rq_vers == 2)
-		nfserr = nfserr_dropit;
 	if (nfserr == nfserr_dropit) {
 		dprintk("nfsd: Dropping request; may be revisited later\n");
 		nfsd_cache_update(rqstp, RC_NOCACHE, NULL);</pre><hr><pre>commit dca1dd30ce0a6234acc751bb90efba1b49079669
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Jul 12 15:30:32 2007 -0400

    nfsd: remove unused cache_for_each macro
    
    This macro is unused.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by:  Neil Brown &lt;neilb@suse.de&gt;

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 3699dff7db8f..bd7a6b0a87af 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -136,16 +136,6 @@ sunrpc_cache_update(struct cache_detail *detail,
 		    struct cache_head *new, struct cache_head *old, int hash);
 
 
-#define cache_for_each(pos, detail, index, member) 						\
-	for (({read_lock(&amp;(detail)-&gt;hash_lock); index = (detail)-&gt;hash_size;}) ;		\
-	     ({if (index==0)read_unlock(&amp;(detail)-&gt;hash_lock); index--;});			\
-		)										\
-		for (pos = container_of((detail)-&gt;hash_table[index], typeof(*pos), member);	\
-		     &amp;pos-&gt;member;								\
-		     pos = container_of(pos-&gt;member.next, typeof(*pos), member))
-
-	     
-
 extern void cache_clean_deferred(void *owner);
 
 static inline struct cache_head  *cache_get(struct cache_head *h)</pre><hr><pre>commit 45457e0916f8253691a44d3574949b6d3d5872b1
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jun 22 17:26:32 2007 -0400

    nfsd: tone down inaccurate dprintk
    
    The nfserr_dropit happens routinely on upcalls (so a kmalloc failure is
    almost never the actual cause), but I occasionally get a complant from
    some tester that's worried because they ran across this message after
    turning on debugging to research some unrelated problem.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by:  Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index a8c89ae4c743..221eeaa68a2d 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -549,7 +549,7 @@ nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)
 	if (nfserr == nfserr_jukebox &amp;&amp; rqstp-&gt;rq_vers == 2)
 		nfserr = nfserr_dropit;
 	if (nfserr == nfserr_dropit) {
-		dprintk("nfsd: Dropping request due to malloc failure!\n");
+		dprintk("nfsd: Dropping request; may be revisited later\n");
 		nfsd_cache_update(rqstp, RC_NOCACHE, NULL);
 		return 0;
 	}</pre><hr><pre>commit afde94f398b62c8596a8d0cbfc25798f0b52a371
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Sep 26 14:38:08 2007 -0400

    SUNRPC: Fix default hostname created in rpc_create()
    
    Since 43780b87fa7..., rpc_create() fills in a default hostname based on
    the ip address if the servername passed in is null.  A small typo made
    that default incorrect.  (But this information appears to be used only
    for debugging right now, so I don't believe the typo causes any bugs in
    the current kernel.)
    
    Thanks to Olga Kornievskaia for bug report and testing.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: Olga Kornievskaia &lt;aglo@citi.umich.edu&gt;
    Cc: Chuck Lever &lt;chuck.lever@oracle.com&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/net/sunrpc/clnt.c b/net/sunrpc/clnt.c
index 6cdf53c489b7..e9866fc93df1 100644
--- a/net/sunrpc/clnt.c
+++ b/net/sunrpc/clnt.c
@@ -259,7 +259,7 @@ struct rpc_clnt *rpc_create(struct rpc_create_args *args)
 	 */
 	if (args-&gt;servername == NULL) {
 		struct sockaddr_in *addr =
-					(struct sockaddr_in *) &amp;args-&gt;address;
+					(struct sockaddr_in *) args-&gt;address;
 		snprintf(servername, sizeof(servername), NIPQUAD_FMT,
 			NIPQUAD(addr-&gt;sin_addr.s_addr));
 		args-&gt;servername = servername;</pre><hr><pre>commit bf19aacecbeebccb2c3d150a8bd9416b7dba81fe
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Sep 26 14:38:09 2007 -0400

    nfs: add server port to rpc_pipe info file
    
    On the client, when an alternate server port is specified on the mount
    commandline, we need to make sure gssd knows about it.
    
    Also, on the server side, when we're sending krb5 callbacks to the
    client, we'll use the same mechanism to let gssd know about the callback
    port.
    
    Thanks to Olga Kornievskaia for testing and for an earlier
    implementation.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Cc: Olga Kornievskaia &lt;aglo@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/net/sunrpc/rpc_pipe.c b/net/sunrpc/rpc_pipe.c
index ae83ac84f63b..c8433e8865aa 100644
--- a/net/sunrpc/rpc_pipe.c
+++ b/net/sunrpc/rpc_pipe.c
@@ -329,6 +329,7 @@ rpc_show_info(struct seq_file *m, void *v)
 			clnt-&gt;cl_prog, clnt-&gt;cl_vers);
 	seq_printf(m, "address: %s\n", rpc_peeraddr2str(clnt, RPC_DISPLAY_ADDR));
 	seq_printf(m, "protocol: %s\n", rpc_peeraddr2str(clnt, RPC_DISPLAY_PROTO));
+	seq_printf(m, "port: %s\n", rpc_peeraddr2str(clnt, RPC_DISPLAY_PORT));
 	return 0;
 }
 </pre><hr><pre>commit 9700382c3c9ff3e673e587084d76eedb3ba88668
Author: david m. richter &lt;richterd@citi.umich.edu&gt;
Date:   Tue Jul 31 00:39:12 2007 -0700

    VFS: fix a race in lease-breaking during truncate
    
    It is possible that another process could acquire a new file lease right
    after break_lease() is called during a truncate, but before lease-granting
    is disabled by the subsequent get_write_access().  Merely switching the
    order of the break_lease() and get_write_access() calls prevents this race.
    
    Signed-off-by: David M. Richter &lt;richterd@citi.umich.edu&gt;
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/open.c b/fs/open.c
index e27c205364d3..1d9e5e98bf4e 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -256,24 +256,26 @@ static long do_sys_truncate(const char __user * path, loff_t length)
 	if (IS_IMMUTABLE(inode) || IS_APPEND(inode))
 		goto dput_and_out;
 
-	/*
-	 * Make sure that there are no leases.
-	 */
-	error = break_lease(inode, FMODE_WRITE);
+	error = get_write_access(inode);
 	if (error)
 		goto dput_and_out;
 
-	error = get_write_access(inode);
+	/*
+	 * Make sure that there are no leases.  get_write_access() protects
+	 * against the truncate racing with a lease-granting setlease().
+	 */
+	error = break_lease(inode, FMODE_WRITE);
 	if (error)
-		goto dput_and_out;
+		goto put_write_and_out;
 
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
 		error = do_truncate(nd.dentry, length, 0, NULL);
 	}
-	put_write_access(inode);
 
+put_write_and_out:
+	put_write_access(inode);
 dput_and_out:
 	path_release(&amp;nd);
 out:</pre><hr><pre>commit 4a4b88317aa02c82e66e37debb764d4ff3eedd70
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 31 00:37:53 2007 -0700

    knfsd: eliminate unnecessary -ENOENT returns on export downcalls
    
    A succesful downcall with a negative result (which indicates that the given
    filesystem is not exported to the given user) should not return an error.
    
    Currently mountd is depending on stdio to write these downcalls.  With some
    versions of libc this appears to cause subsequent writes to attempt to write
    all accumulated data (for which writes previously failed) along with any new
    data.  This can prevent the kernel from seeing responses to later downcalls.
    Symptoms will be that nfsd fails to respond to certain requests.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Cc: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index 2d295dda4c1d..cba899a3494e 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -564,9 +564,10 @@ static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)
 
 	/* flags */
 	err = get_int(&amp;mesg, &amp;an_int);
-	if (err == -ENOENT)
+	if (err == -ENOENT) {
+		err = 0;
 		set_bit(CACHE_NEGATIVE, &amp;exp.h.flags);
-	else {
+	} else {
 		if (err || an_int &lt; 0) goto out;	
 		exp.ex_flags= an_int;
 	</pre>
    <div class="pagination">
        <a href='4_42.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><span>[43]</span><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_44.html'>Next&gt;&gt;</a>
    <div>
</body>
