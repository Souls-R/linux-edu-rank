<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_67.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><span>[68]</span><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_69.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 52b265a12768b9a72679bec825eb82c784116464
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 8 16:48:49 2010 -0500

    PCI: clearing wakeup flags not needed
    
    This patch (as1353) removes a couple of unnecessary assignments from
    the PCI core.  The should_wakeup flag is naturally initialized to 0;
    there's no need to clear it.
    
    Acked-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 37499127c801..60fcb6f02c91 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -1631,7 +1631,6 @@ void pci_pm_init(struct pci_dev *dev)
 		 * let the user space enable it to wake up the system as needed.
 		 */
 		device_set_wakeup_capable(&amp;dev-&gt;dev, true);
-		device_set_wakeup_enable(&amp;dev-&gt;dev, false);
 		/* Disable the PME# generation functionality */
 		pci_pme_active(dev, false);
 	} else {
@@ -1655,7 +1654,6 @@ void platform_pci_wakeup_init(struct pci_dev *dev)
 		return;
 
 	device_set_wakeup_capable(&amp;dev-&gt;dev, true);
-	device_set_wakeup_enable(&amp;dev-&gt;dev, false);
 	platform_pci_sleep_wake(dev, false);
 }
 </pre><hr><pre>commit d6f9cda1fd241bc7a1d896da94950fd972eca9b7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 26 23:53:55 2010 +0100

    PM: Improve device power management document
    
    Improve the device power management document after it's been
    updated by the previous patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/power/devices.txt b/Documentation/power/devices.txt
index 10018d19e0bf..57080cd74575 100644
--- a/Documentation/power/devices.txt
+++ b/Documentation/power/devices.txt
@@ -1,11 +1,13 @@
 Device Power Management
 
-(C) 2010 Rafael J. Wysocki &lt;rjw@sisk.pl&gt;, Novell Inc.
+Copyright (c) 2010 Rafael J. Wysocki &lt;rjw@sisk.pl&gt;, Novell Inc.
+Copyright (c) 2010 Alan Stern &lt;stern@rowland.harvard.edu&gt;
+
 
 Most of the code in Linux is device drivers, so most of the Linux power
-management code is also driver-specific.  Most drivers will do very little;
-others, especially for platforms with small batteries (like cell phones),
-will do a lot.
+management (PM) code is also driver-specific.  Most drivers will do very
+little; others, especially for platforms with small batteries (like cell
+phones), will do a lot.
 
 This writeup gives an overview of how drivers interact with system-wide
 power management goals, emphasizing the models and interfaces that are
@@ -19,9 +21,10 @@ Drivers will use one or both of these models to put devices into low-power
 states:
 
     System Sleep model:
-	Drivers can enter low power states as part of entering system-wide
-	low-power states like "suspend-to-ram", or (mostly for systems with
-	disks) "hibernate" (suspend-to-disk).
+	Drivers can enter low-power states as part of entering system-wide
+	low-power states like "suspend" (also known as "suspend-to-RAM"), or
+	(mostly for systems with disks) "hibernation" (also known as
+	"suspend-to-disk").
 
 	This is something that device, bus, and class drivers collaborate on
 	by implementing various role-specific suspend and resume methods to
@@ -29,41 +32,41 @@ states:
 	them without loss of data.
 
 	Some drivers can manage hardware wakeup events, which make the system
-	leave that low-power state.  This feature may be enabled or disabled
+	leave the low-power state.  This feature may be enabled or disabled
 	using the relevant /sys/devices/.../power/wakeup file (for Ethernet
 	drivers the ioctl interface used by ethtool may also be used for this
 	purpose); enabling it may cost some power usage, but let the whole
-	system enter low power states more often.
+	system enter low-power states more often.
 
     Runtime Power Management model:
-	Devices may also be put into low power states while the system is
+	Devices may also be put into low-power states while the system is
 	running, independently of other power management activity in principle.
 	However, devices are not generally independent of each other (for
-	example, parent device cannot be suspended unless all of its child
-	devices have been suspended).  Moreover,  depending on the bus type the
+	example, a parent device cannot be suspended unless all of its child
+	devices have been suspended).  Moreover, depending on the bus type the
 	device is on, it may be necessary to carry out some bus-specific
-	operations on the device for this purpose.  Also, devices put into low
-	power states at run time may require special handling during system-wide
-	power transitions, like suspend to RAM.
+	operations on the device for this purpose.  Devices put into low power
+	states at run time may require special handling during system-wide power
+	transitions (suspend or hibernation).
 
 	For these reasons not only the device driver itself, but also the
-	appropriate subsystem (bus type, device type or device class) driver
-	and the PM core are involved in the runtime power management of devices.
-	Like in the system sleep power management case, they need to collaborate
-	by implementing various role-specific suspend and resume methods, so
-	that the hardware is cleanly powered down and reactivated without data
-	or service loss.
-
-There's not a lot to be said about those low power states except that they
-are very system-specific, and often device-specific.  Also, that if enough
-devices have been put into low power states (at "run time"), the effect may be
-very similar to entering some system-wide low-power state (system sleep) ... and
-that synergies exist, so that several drivers using runtime PM might put the
-system into a state where even deeper power saving options are available.
-
-Most suspended devices will have quiesced all I/O:  no more DMA or IRQs, no
-more data read or written, and requests from upstream drivers are no longer
-accepted.  A given bus or platform may have different requirements though.
+	appropriate subsystem (bus type, device type or device class) driver and
+	the PM core are involved in runtime power management.  As in the system
+	sleep power management case, they need to collaborate by implementing
+	various role-specific suspend and resume methods, so that the hardware
+	is cleanly powered down and reactivated without data or service loss.
+
+There's not a lot to be said about those low-power states except that they are
+very system-specific, and often device-specific.  Also, that if enough devices
+have been put into low-power states (at runtime), the effect may be very similar
+to entering some system-wide low-power state (system sleep) ... and that
+synergies exist, so that several drivers using runtime PM might put the system
+into a state where even deeper power saving options are available.
+
+Most suspended devices will have quiesced all I/O: no more DMA or IRQs (except
+for wakeup events), no more data read or written, and requests from upstream
+drivers are no longer accepted.  A given bus or platform may have different
+requirements though.
 
 Examples of hardware wakeup events include an alarm from a real time clock,
 network wake-on-LAN packets, keyboard or mouse activity, and media insertion
@@ -72,10 +75,10 @@ or removal (for PCMCIA, MMC/SD, USB, and so on).
 
 Interfaces for Entering System Sleep States
 ===========================================
-There are programming interfaces provided for subsystem (bus type, device type,
-device class) and device drivers in order to allow them to participate in the
-power management of devices they are concerned with.  They cover the system
-sleep power management as well as the runtime power management of devices.
+There are programming interfaces provided for subsystems (bus type, device type,
+device class) and device drivers to allow them to participate in the power
+management of devices they are concerned with.  These interfaces cover both
+system sleep and runtime power management.
 
 
 Device Power Management Operations
@@ -106,16 +109,15 @@ struct dev_pm_ops {
 
 This structure is defined in include/linux/pm.h and the methods included in it
 are also described in that file.  Their roles will be explained in what follows.
-For now, it should be sufficient to remember that the last three of them are
-specific to runtime power management, while the remaining ones are used during
+For now, it should be sufficient to remember that the last three methods are
+specific to runtime power management while the remaining ones are used during
 system-wide power transitions.
 
-There also is an "old" or "legacy", deprecated way of implementing power
-management operations available at least for some subsystems.  This approach
-does not use struct dev_pm_ops objects and it only is suitable for implementing
-system sleep power management methods.  Therefore it is not described in this
-document, so please refer directly to the source code for more information about
-it.
+There also is a deprecated "old" or "legacy" interface for power management
+operations available at least for some subsystems.  This approach does not use
+struct dev_pm_ops objects and it is suitable only for implementing system sleep
+power management methods.  Therefore it is not described in this document, so
+please refer directly to the source code for more information about it.
 
 
 Subsystem-Level Methods
@@ -125,10 +127,10 @@ pointed to by the pm member of struct bus_type, struct device_type and
 struct class.  They are mostly of interest to the people writing infrastructure
 for buses, like PCI or USB, or device type and device class drivers.
 
-Bus drivers implement these methods as appropriate for the hardware and
-the drivers using it; PCI works differently from USB, and so on.  Not many
-people write subsystem-level drivers; most driver code is a "device driver" that
-builds on top of bus-specific framework code.
+Bus drivers implement these methods as appropriate for the hardware and the
+drivers using it; PCI works differently from USB, and so on.  Not many people
+write subsystem-level drivers; most driver code is a "device driver" that builds
+on top of bus-specific framework code.
 
 For more information on these driver calls, see the description later;
 they are called in phases for every device, respecting the parent-child
@@ -137,66 +139,78 @@ sequencing in the driver model tree.
 
 /sys/devices/.../power/wakeup files
 -----------------------------------
-All devices in the driver model have two flags to control handling of
-wakeup events, which are hardware signals that can force the device and/or
-system out of a low power state.  These are initialized by bus or device
-driver code using device_init_wakeup().
+All devices in the driver model have two flags to control handling of wakeup
+events (hardware signals that can force the device and/or system out of a low
+power state).  These flags are initialized by bus or device driver code using
+device_set_wakeup_capable() and device_set_wakeup_enable(), defined in
+include/linux/pm_wakeup.h.
 
 The "can_wakeup" flag just records whether the device (and its driver) can
-physically support wakeup events.  When that flag is clear, the sysfs
-"wakeup" file is empty, and device_may_wakeup() returns false.
-
-For devices that can issue wakeup events, a separate flag controls whether
-that device should try to use its wakeup mechanism.  The initial value of
-device_may_wakeup() will be false for the majority of devices, except for
-power buttons, keyboards, and Ethernet adapters whose WoL (wake-on-LAN) feature
-has been set up with ethtool.  Thus in the majority of cases the device's
-"wakeup" file will initially hold the value "disabled".  Userspace can change
-that to "enabled", so that device_may_wakeup() returns true, or change it back
-to "disabled", so that it returns false again.
+physically support wakeup events.  The device_set_wakeup_capable() routine
+affects this flag.  The "should_wakeup" flag controls whether the device should
+try to use its wakeup mechanism.  device_set_wakeup_enable() affects this flag;
+for the most part drivers should not change its value.  The initial value of
+should_wakeup is supposed to be false for the majority of devices; the major
+exceptions are power buttons, keyboards, and Ethernet adapters whose WoL
+(wake-on-LAN) feature has been set up with ethtool.
+
+Whether or not a device is capable of issuing wakeup events is a hardware
+matter, and the kernel is responsible for keeping track of it.  By contrast,
+whether or not a wakeup-capable device should issue wakeup events is a policy
+decision, and it is managed by user space through a sysfs attribute: the
+power/wakeup file.  User space can write the strings "enabled" or "disabled" to
+set or clear the should_wakeup flag, respectively.  Reads from the file will
+return the corresponding string if can_wakeup is true, but if can_wakeup is
+false then reads will return an empty string, to indicate that the device
+doesn't support wakeup events.  (But even though the file appears empty, writes
+will still affect the should_wakeup flag.)
+
+The device_may_wakeup() routine returns true only if both flags are set.
+Drivers should check this routine when putting devices in a low-power state
+during a system sleep transition, to see whether or not to enable the devices'
+wakeup mechanisms.  However for runtime power management, wakeup events should
+be enabled whenever the device and driver both support them, regardless of the
+should_wakeup flag.
 
 
 /sys/devices/.../power/control files
 ------------------------------------
-All devices in the driver model have a flag to control the desired behavior of
-its driver with respect to runtime power management.  This flag, called
-runtime_auto, is initialized by the bus type (or generally subsystem) code using
-pm_runtime_allow() or pm_runtime_forbid(), depending on whether or not the
-driver is supposed to power manage the device at run time by default,
-respectively.
-
-This setting may be adjusted by user space by writing either "on" or "auto" to
-the device's "control" file.  If "auto" is written, the device's runtime_auto
-flag will be set and the driver will be allowed to power manage the device if
-capable of doing that.  If "on" is written, the driver is not allowed to power
-manage the device which in turn is supposed to remain in the full power state at
-run time.  User space can check the current value of the runtime_auto flag by
-reading from the device's "control" file.
+Each device in the driver model has a flag to control whether it is subject to
+runtime power management.  This flag, called runtime_auto, is initialized by the
+bus type (or generally subsystem) code using pm_runtime_allow() or
+pm_runtime_forbid(); the default is to allow runtime power management.
+
+The setting can be adjusted by user space by writing either "on" or "auto" to
+the device's power/control sysfs file.  Writing "auto" calls pm_runtime_allow(),
+setting the flag and allowing the device to be runtime power-managed by its
+driver.  Writing "on" calls pm_runtime_forbid(), clearing the flag, returning
+the device to full power if it was in a low-power state, and preventing the
+device from being runtime power-managed.  User space can check the current value
+of the runtime_auto flag by reading the file.
 
 The device's runtime_auto flag has no effect on the handling of system-wide
-power transitions by its driver.  In particular, the device can (and in the
-majority of cases should and will) be put into a low power state during a
-system-wide transition to a sleep state (like "suspend-to-RAM") even though its
-runtime_auto flag is unset (in which case its "control" file contains "on").
+power transitions.  In particular, the device can (and in the majority of cases
+should and will) be put into a low-power state during a system-wide transition
+to a sleep state even though its runtime_auto flag is clear.
 
-For more information about the runtime power management framework for devices
-refer to Documentation/power/runtime_pm.txt.
+For more information about the runtime power management framework, refer to
+Documentation/power/runtime_pm.txt.
 
 
-Calling Drivers to Enter System Sleep States
-============================================
-When the system goes into a sleep state, each device's driver is asked
-to suspend the device by putting it into state compatible with the target
+Calling Drivers to Enter and Leave System Sleep States
+======================================================
+When the system goes into a sleep state, each device's driver is asked to
+suspend the device by putting it into a state compatible with the target
 system state.  That's usually some version of "off", but the details are
 system-specific.  Also, wakeup-enabled devices will usually stay partly
 functional in order to wake the system.
 
-When the system leaves that low power state, the device's driver is asked
-to resume it.  The suspend and resume operations always go together, and
-both are multi-phase operations.
+When the system leaves that low-power state, the device's driver is asked to
+resume it by returning it to full power.  The suspend and resume operations
+always go together, and both are multi-phase operations.
 
-For simple drivers, suspend might quiesce the device using the class code
-and then turn its hardware as "off" as possible with late_suspend.  The
+For simple drivers, suspend might quiesce the device using class code
+and then turn its hardware as "off" as possible during suspend_noirq.  The
 matching resume calls would then completely reinitialize the hardware
 before reactivating its class I/O queues.
 
@@ -224,269 +238,129 @@ devices have been suspended.  Device drivers must be prepared to cope with such
 situations.
 
 
-Suspending Devices
-------------------
-Suspending a given device is done in several phases.  Suspending the
-system always includes every phase, executing calls for every device
-before the next phase begins.  Not all busses or classes support all
-these callbacks; and not all drivers use all the callbacks.
-
-Generally, different callbacks are used depending on whether the system is
-going to the standby or memory sleep state ("suspend-to-RAM") or it is going to
-be hibernated ("suspend-to-disk").
+System Power Management Phases
+------------------------------
+Suspending or resuming the system is done in several phases.  Different phases
+are used for standby or memory sleep states ("suspend-to-RAM") and the
+hibernation state ("suspend-to-disk").  Each phase involves executing callbacks
+for every device before the next phase begins.  Not all busses or classes
+support all these callbacks and not all drivers use all the callbacks.  The
+various phases always run after tasks have been frozen and before they are
+unfrozen.  Furthermore, the *_noirq phases run at a time when IRQ handlers have
+been disabled (except for those marked with the IRQ_WAKEUP flag).
 
-If the system goes to the standby or memory sleep state the phases are seen by
-driver notifications issued in this order:
+Most phases use bus, type, and class callbacks (that is, methods defined in
+dev-&gt;bus-&gt;pm, dev-&gt;type-&gt;pm, and dev-&gt;class-&gt;pm).  The prepare and complete
+phases are exceptions; they use only bus callbacks.  When multiple callbacks
+are used in a phase, they are invoked in the order: &lt;class, type, bus&gt; during
+power-down transitions and in the opposite order during power-up transitions.
+For example, during the suspend phase the PM core invokes
 
-   1	bus-&gt;pm.prepare(dev) is called after tasks are frozen and it is supposed
-	to call the device driver's -&gt;pm.prepare() method.
+	dev-&gt;class-&gt;pm.suspend(dev);
+	dev-&gt;type-&gt;pm.suspend(dev);
+	dev-&gt;bus-&gt;pm.suspend(dev);
 
-	The purpose of this method is mainly to prevent new children of the
-	device from being registered after it has returned.  It also may be used
-	to generally prepare the device for the upcoming system transition, but
-	it should not put the device into a low power state.
+before moving on to the next device, whereas during the resume phase the core
+invokes
 
-   2	class-&gt;pm.suspend(dev) is called if dev is associated with a class that
-	has such a method.  It may invoke the device driver's -&gt;pm.suspend()
-	method, unless type-&gt;pm.suspend(dev) or bus-&gt;pm.suspend() does that.
+	dev-&gt;bus-&gt;pm.resume(dev);
+	dev-&gt;type-&gt;pm.resume(dev);
+	dev-&gt;class-&gt;pm.resume(dev);
 
-   3	type-&gt;pm.suspend(dev) is called if dev is associated with a device type
-	that has such a method.  It may invoke the device driver's
-	-&gt;pm.suspend() method, unless class-&gt;pm.suspend(dev) or
-	bus-&gt;pm.suspend() does that.
+These callbacks may in turn invoke device- or driver-specific methods stored in
+dev-&gt;driver-&gt;pm, but they don't have to.
 
-   4	bus-&gt;pm.suspend(dev) is called, if implemented.  It usually calls the
-	device driver's -&gt;pm.suspend() method.
 
-	This call should generally quiesce the device so that it doesn't do any
-	I/O after the call has returned.  It also may save the device registers
-	and put it into the appropriate low power state, depending on the bus
-	type the device is on.
-
-   5	bus-&gt;pm.suspend_noirq(dev) is called, if implemented.  It may call the
-	device driver's -&gt;pm.suspend_noirq() method, depending on the bus type
-	in question.
-
-	This method is invoked after device interrupts have been suspended,
-	which means that the driver's interrupt handler will not be called
-	while it is running.  It should save the values of the device's
-	registers that weren't saved previously and finally put the device into
-	the appropriate low power state.
+Entering System Suspend
+-----------------------
+When the system goes into the standby or memory sleep state, the phases are:
+
+		prepare, suspend, suspend_noirq.
+
+    1.	The prepare phase is meant to prevent races by preventing new devices
+	from being registered; the PM core would never know that all the
+	children of a device had been suspended if new children could be
+	registered at will.  (By contrast, devices may be unregistered at any
+	time.)  Unlike the other suspend-related phases, during the prepare
+	phase the device tree is traversed top-down.
+
+	The prepare phase uses only a bus callback.  After the callback method
+	returns, no new children may be registered below the device.  The method
+	may also prepare the device or driver in some way for the upcoming
+	system power transition, but it should not put the device into a
+	low-power state.
+
+    2.	The suspend methods should quiesce the device to stop it from performing
+	I/O.  They also may save the device registers and put it into the
+	appropriate low-power state, depending on the bus type the device is on,
+	and they may enable wakeup events.
+
+    3.	The suspend_noirq phase occurs after IRQ handlers have been disabled,
+	which means that the driver's interrupt handler will not be called while
+	the callback method is running.  The methods should save the values of
+	the device's registers that weren't saved previously and finally put the
+	device into the appropriate low-power state.
 
 	The majority of subsystems and device drivers need not implement this
-	method.  However, bus types allowing devices to share interrupt vectors,
-	like PCI, generally need to use it to prevent interrupt handling issues
-	from happening during suspend.
-
-At the end of those phases, drivers should normally have stopped all I/O
-transactions (DMA, IRQs), saved enough state that they can re-initialize
-or restore previous state (as needed by the hardware), and placed the
-device into a low-power state.  On many platforms they will also use
-gate off one or more clock sources; sometimes they will also switch off power
-supplies, or reduce voltages.  [Drivers supporting runtime PM may already have
-performed some or all of the steps needed to prepare for the upcoming system
-state transition.]
+	callback.  However, bus types allowing devices to share interrupt
+	vectors, like PCI, generally need it; otherwise a driver might encounter
+	an error during the suspend phase by fielding a shared interrupt
+	generated by some other device after its own device had been set to low
+	power.
+
+At the end of these phases, drivers should have stopped all I/O transactions
+(DMA, IRQs), saved enough state that they can re-initialize or restore previous
+state (as needed by the hardware), and placed the device into a low-power state.
+On many platforms they will gate off one or more clock sources; sometimes they
+will also switch off power supplies or reduce voltages.  (Drivers supporting
+runtime PM may already have performed some or all of these steps.)
 
 If device_may_wakeup(dev) returns true, the device should be prepared for
-generating hardware wakeup signals when the system is in the sleep state to
-trigger a system wakeup event.  For example, enable_irq_wake() might identify
+generating hardware wakeup signals to trigger a system wakeup event when the
+system is in the sleep state.  For example, enable_irq_wake() might identify
 GPIO signals hooked up to a switch or other external hardware, and
 pci_enable_wake() does something similar for the PCI PME signal.
 
-If a driver (or subsystem) fails it suspend method, the system won't enter the
-desired low power state; it will resume all the devices it's suspended so far.
-
-
-Hibernation Phases
-------------------
-Hibernating the system is more complicated than putting it into the standby or
-memory sleep state, because it involves creating a system image and saving it.
-Therefore there are more phases of hibernation and special device PM methods are
-used in this case.
-
-First, it is necessary to prepare the system for creating a hibernation image.
-This is similar to putting the system into the standby or memory sleep state,
-although it generally doesn't require that devices be put into low power states
-(that is even not desirable at this point).  Driver notifications are then
-issued in the following order:
-
-   1	bus-&gt;pm.prepare(dev) is called after tasks have been frozen and enough
-	memory has been freed.
-
-   2	class-&gt;pm.freeze(dev) is called if implemented.  It may invoke the
-        device driver's -&gt;pm.freeze() method, unless type-&gt;pm.freeze(dev) or
-        bus-&gt;pm.freeze() does that.
-
-   3	type-&gt;pm.freeze(dev) is called if implemented.  It may invoke the device
-	driver's -&gt;pm.suspend() method, unless class-&gt;pm.freeze(dev) or
-	bus-&gt;pm.freeze() does that.
-
-   4	bus-&gt;pm.freeze(dev) is called, if implemented.  It usually calls the
-	device driver's -&gt;pm.freeze() method.
-
-   5	bus-&gt;pm.freeze_noirq(dev) is called, if implemented.  It may call the
-	device driver's -&gt;pm.freeze_noirq() method, depending on the bus type
-	in question.
-
-The difference between -&gt;pm.freeze() and the corresponding -&gt;pm.suspend() (and
-similarly for the "noirq" variants) is that the former should avoid preparing
-devices to trigger system wakeup events and putting devices into low power
-states, although they generally have to save the values of device registers
-so that it's possible to restore them during system resume.
-
-Second, after the system image has been created, the functionality of devices
-has to be restored so that the image can be saved.  That is similar to resuming
-devices after the system has been woken up from the standby or memory sleep
-state, which is described below, and causes the following device notifications
-to be issued:
-
-   1	bus-&gt;pm.thaw_noirq(dev), if implemented; may call the device driver's
-	-&gt;pm.thaw_noirq() method, depending on the bus type in question.
-
-   2	bus-&gt;pm.thaw(dev), if implemented; usually calls the device driver's
-	-&gt;pm.thaw() method.
-
-   3	type-&gt;pm.thaw(dev), if implemented; may call the device driver's
-	-&gt;pm.thaw() method if not called by the bus type or class.
-
-   4	class-&gt;pm.thaw(dev), if implemented; may call the device driver's
-	-&gt;pm.thaw() method if not called by the bus type or device type.
-
-   5	bus-&gt;pm.complete(dev), if implemented; may call the device driver's
-	-&gt;pm.complete() method.
-
-Generally, the role of the -&gt;pm.thaw() methods (including the "noirq" variants)
-is to bring the device back to the fully functional state, so that it may be
-used for saving the image, if necessary.  The role of bus-&gt;pm.complete() is to
-reverse whatever bus-&gt;pm.prepare() did (likewise for the analogous device driver
-callbacks).
-
-After the image has been saved, the devices need to be prepared for putting the
-system into the low power state.  That is analogous to suspending them before
-putting the system into the standby or memory sleep state and involves the
-following device notifications:
-
-   1	bus-&gt;pm.prepare(dev).
-
-   2	class-&gt;pm.poweroff(dev), if implemented; may invoke the device driver's
-   	-&gt;pm.poweroff() method if not called by the bus type or device type.
-
-   3	type-&gt;pm.poweroff(dev), if implemented; may invoke the device driver's
-   	-&gt;pm.poweroff() method if not called by the bus type or device class.
-
-   4	bus-&gt;pm.poweroff(dev), if implemented; usually calls the device driver's
-   	-&gt;pm.poweroff() method (if not called by the device class or type).
-
-   5	bus-&gt;pm.poweroff_noirq(dev), if implemented; may call the device
-	driver's -&gt;pm.poweroff_noirq() method, depending on the bus type
-	in question.
-
-The difference between -&gt;pm.poweroff() and the corresponding -&gt;pm.suspend() (and
-analogously for the "noirq" variants) is that the former need not save the
-device's registers.  Still, they should prepare the device for triggering
-system wakeup events if necessary and finally put it into the appropriate low
-power state.
-
-
-Device Low Power (suspend) States
----------------------------------
-Device low-power states aren't standard.  One device might only handle
-"on" and "off, while another might support a dozen different versions of
-"on" (how many engines are active?), plus a state that gets back to "on"
-faster than from a full "off".
-
-Some busses define rules about what different suspend states mean.  PCI
-gives one example:  after the suspend sequence completes, a non-legacy
-PCI device may not perform DMA or issue IRQs, and any wakeup events it
-issues would be issued through the PME# bus signal.  Plus, there are
-several PCI-standard device states, some of which are optional.
-
-In contrast, integrated system-on-chip processors often use IRQs as the
-wakeup event sources (so drivers would call enable_irq_wake) and might
-be able to treat DMA completion as a wakeup event (sometimes DMA can stay
-active too, it'd only be the CPU and some peripherals that sleep).
-
-Some details here may be platform-specific.  Systems may have devices that
-can be fully active in certain sleep states, such as an LCD display that's
-refreshed using DMA while most of the system is sleeping lightly ... and
-its frame buffer might even be updated by a DSP or other non-Linux CPU while
-the Linux control processor stays idle.
-
-Moreover, the specific actions taken may depend on the target system state.
-One target system state might allow a given device to be very operational;
-another might require a hard shut down with re-initialization on resume.
-And two different target systems might use the same device in different
-ways; the aforementioned LCD might be active in one product's "standby",
-but a different product using the same SOC might work differently.
+If any of these callbacks returns an error, the system won't enter the desired
+low-power state.  Instead the PM core will unwind its actions by resuming all
+the devices that were suspended.
 
 
-Resuming Devices
-----------------
-Resuming is done in multiple phases, much like suspending, with all
-devices processing each phase's calls before the next phase begins.
+Leaving System Suspend
+----------------------
+When resuming from standby or memory sleep, the phases are:
 
-Again, however, different callbacks are used depending on whether the system is
-waking up from the standby or memory sleep state ("suspend-to-RAM") or from
-hibernation ("suspend-to-disk").
+		resume_noirq, resume, complete.
 
-If the system is waking up from the standby or memory sleep state, the phases
-are seen by driver notifications issued in this order:
-
-   1	bus-&gt;pm.resume_noirq(dev) is called, if implemented.  It may call the
-	device driver's -&gt;pm.resume_noirq() method, depending on the bus type in
-	question.
-
-	The role of this method is to perform actions that need to be performed
-	before device drivers' interrupt handlers are allowed to be invoked.  If
-	the given bus type permits devices to share interrupt vectors, like PCI,
-	this method should bring the device and its driver into a state in which
-	the driver can recognize if the device is the source of incoming
-	interrupts, if any, and handle them correctly.
+    1.	The resume_noirq callback methods should perform any actions needed
+	before the driver's interrupt handlers are invoked.  This generally
+	means undoing the actions of the suspend_noirq phase.  If the bus type
+	permits devices to share interrupt vectors, like PCI, the method should
+	bring the device and its driver into a state in which the driver can
+	recognize if the device is the source of incoming interrupts, if any,
+	and handle them correctly.
 
 	For example, the PCI bus type's -&gt;pm.resume_noirq() puts the device into
-	the full power state (D0 in the PCI terminology) and restores the
-	standard configuration registers of the device.  Then, it calls the
+	the full-power state (D0 in the PCI terminology) and restores the
+	standard configuration registers of the device.  Then it calls the
 	device driver's -&gt;pm.resume_noirq() method to perform device-specific
-	actions needed at this stage of resume.
-
-   2	bus-&gt;pm.resume(dev) is called, if implemented.  It usually calls the
-	device driver's -&gt;pm.resume() method.
-
-	This call should generally bring the the device back to the working
-	state, so that it can do I/O as requested after the call has returned.
-	However, it may be more convenient to use the device class or device
-	type -&gt;pm.resume() for this purpose, in which case the bus type's
-	-&gt;pm.resume() method need not be implemented at all.
-
-   3	type-&gt;pm.resume(dev) is called, if implemented.  It may invoke the
-	device driver's -&gt;pm.resume() method, unless class-&gt;pm.resume(dev) or
-	bus-&gt;pm.resume() does that.
-
-	For devices that are not associated with any bus type or device class
-	this method plays the role of bus-&gt;pm.resume().
-
-   4	class-&gt;pm.resume(dev) is called, if implemented.  It may invoke the
-	device driver's -&gt;pm.resume() method, unless bus-&gt;pm.resume(dev) or
-	type-&gt;pm.resume() does that.
-
-	For devices that are not associated with any bus type or device type
-	this method plays the role of bus-&gt;pm.resume().
+	actions.
 
-   5	bus-&gt;pm.complete(dev) is called, if implemented.  It is supposed to
-	invoke the device driver's -&gt;pm.complete() method.
+    2.	The resume methods should bring the the device back to its operating
+	state, so that it can perform normal I/O.  This generally involves
+	undoing the actions of the suspend phase.
 
-	The role of this method is to reverse whatever bus-&gt;pm.prepare(dev)
-	(or the driver's -&gt;pm.prepare()) did during suspend, if necessary.
+    3.	The complete phase uses only a bus callback.  The method should undo the
+	actions of the prepare phase.  Note, however, that new children may be
+	registered below the device as soon as the resume callbacks occur; it's
+	not necessary to wait until the complete phase.
 
-At the end of those phases, drivers should normally be as functional as
-they were before suspending:  I/O can be performed using DMA and IRQs, and
-the relevant clocks are gated on.  In principle the device need not be
-"fully on"; it might be in a runtime lowpower/suspend state during suspend and
-the resume callbacks may try to restore that state, but that need not be
-desirable from the user's point of view.  In fact, there are multiple reasons
-why it's better to always put devices into the "fully working" state in the
-system sleep resume callbacks and they are discussed in more detail in
-Documentation/power/runtime_pm.txt.
+At the end of these phases, drivers should be as functional as they were before
+suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
+gated on.  Even if the device was in a low-power state before the system sleep
+because of runtime power management, afterwards it should be back in its
+full-power state.  There are multiple reasons why it's best to do this; they are
+discussed in more detail in Documentation/power/runtime_pm.txt.
 
 However, the details here may again be platform-specific.  For example,
 some systems support multiple "run" states, and the mode in effect at
@@ -502,103 +376,156 @@ the suspend was carried out, but that can't be guaranteed (in fact, it ususally
 is not the case).
 
 Drivers must also be prepared to notice that the device has been removed
-while the system was powered off, whenever that's physically possible.
+while the system was powered down, whenever that's physically possible.
 PCMCIA, MMC, USB, Firewire, SCSI, and even IDE are common examples of busses
 where common Linux platforms will see such removal.  Details of how drivers
 will notice and handle such removals are currently bus-specific, and often
 involve a separate thread.
 
+These callbacks may return an error value, but the PM core will ignore such
+errors since there's nothing it can do about them other than printing them in
+the system log.
 
-Resume From Hibernation
------------------------
+
+Entering Hibernation
+--------------------
+Hibernating the system is more complicated than putting it into the standby or
+memory sleep state, because it involves creating and saving a system image.
+Therefore there are more phases for hibernation, with a different set of
+callbacks.  These phases always run after tasks have been frozen and memory has
+been freed.
+
+The general procedure for hibernation is to quiesce all devices (freeze), create
+an image of the system memory while everything is stable, reactivate all
+devices (thaw), write the image to permanent storage, and finally shut down the
+system (poweroff).  The phases used to accomplish this are:
+
+	prepare, freeze, freeze_noirq, thaw_noirq, thaw, complete,
+	prepare, poweroff, poweroff_noirq
+
+    1.	The prepare phase is discussed in the "Entering System Suspend" section
+	above.
+
+    2.	The freeze methods should quiesce the device so that it doesn't generate
+	IRQs or DMA, and they may need to save the values of device registers.
+	However the device does not have to be put in a low-power state, and to
+	save time it's best not to do so.  Also, the device should not be
+	prepared to generate wakeup events.
+
+    3.	The freeze_noirq phase is analogous to the suspend_noirq phase discussed
+	above, except again that the device should not be put in a low-power
+	state and should not be allowed to generate wakeup events.
+
+At this point the system image is created.  All devices should be inactive and
+the contents of memory should remain undisturbed while this happens, so that the
+image forms an atomic snapshot of the system state.
+
+    4.	The thaw_noirq phase is analogous to the resume_noirq phase discussed
+	above.  The main difference is that its methods can assume the device is
+	in the same state as at the end of the freeze_noirq phase.
+
+    5.	The thaw phase is analogous to the resume phase discussed above.  Its
+	methods should bring the device back to an operating state, so that it
+	can be used for saving the image if necessary.
+
+    6.	The complete phase is discussed in the "Leaving System Suspend" section
+	above.
+
+At this point the system image is saved, and the devices then need to be
+prepared for the upcoming system shutdown.  This is much like suspending them
+before putting the system into the standby or memory sleep state, and the phases
+are similar.
+
+    7.	The prepare phase is discussed above.
+
+    8.	The poweroff phase is analogous to the suspend phase.
+
+    9.	The poweroff_noirq phase is analogous to the suspend_noirq phase.
+
+The poweroff and poweroff_noirq callbacks should do essentially the same things
+as the suspend and suspend_noirq callbacks.  The only notable difference is that
+they need not store the device register values, because the registers should
+already have been stored during the freeze or freeze_noirq phases.
+
+
+Leaving Hibernation
+-------------------
 Resuming from hibernation is, again, more complicated than resuming from a sleep
 state in which the contents of main memory are preserved, because it requires
 a system image to be loaded into memory and the pre-hibernation memory contents
 to be restored before control can be passed back to the image kernel.
 
-In principle, the image might be loaded into memory and the pre-hibernation
-memory contents might be restored by the boot loader.  For this purpose,
-however, the boot loader would need to know the image kernel's entry point and
-there's no protocol defined for passing that information to boot loaders.  As
-a workaround, the boot loader loads a fresh instance of the kernel, called the
-boot kernel, into memory and passes control to it in a usual way.  Then, the
-boot kernel reads the hibernation image, restores the pre-hibernation memory
-contents and passes control to the image kernel.  Thus, in fact, two different
-kernels are involved in resuming from hibernation and in general they are not
-only different because they play different roles in this operation.  Actually,
-the boot kernel may be completely different from the image kernel.  Not only
-the configuration of it, but also the version of it may be different.
-The consequences of this are important to device drivers and their subsystems
-(bus types, device classes and device types) too.
-
-Namely, to be able to load the hibernation image into memory, the boot kernel
-needs to include at least the subset of device drivers allowing it to access the
-storage medium containing the image, although it generally doesn't need to
-include all of the drivers included into the image kernel.  After the image has
-been loaded the devices handled by those drivers need to be prepared for passing
-control back to the image kernel.  This is very similar to the preparation of
-devices for creating a hibernation image described above.  In fact, it is done
-in the same way, with the help of the -&gt;pm.prepare(), -&gt;pm.freeze() and
--&gt;pm.freeze_noirq() callbacks, but only for device drivers included in the boot
-kernel (whose versions may generally be different from the versions of the
-analogous drivers from the image kernel).
+Although in principle, the image might be loaded into memory and the
+pre-hibernation memory contents restored by the boot loader, in practice this
+can't be done because boot loaders aren't smart enough and there is no
+established protocol for passing the necessary information.  So instead, the
+boot loader loads a fresh instance of the kernel, called the boot kernel, into
+memory and passes control to it in the usual way.  Then the boot kernel reads
+the system image, restores the pre-hibernation memory contents, and passes
+control to the image kernel.  Thus two different kernels are involved in
+resuming from hibernation.  In fact, the boot kernel may be completely different
+from the image kernel: a different configuration and even a different version.
+This has important consequences for device drivers and their subsystems.
+
+To be able to load the system image into memory, the boot kernel needs to
+include at least a subset of device drivers allowing it to access the storage
+medium containing the image, although it doesn't need to include all of the
+drivers present in the image kernel.  After the image has been loaded, the
+devices managed by the boot kernel need to be prepared for passing control back
+to the image kernel.  This is very similar to the initial steps involved in
+creating a system image, and it is accomplished in the same way, using prepare,
+freeze, and freeze_noirq phases.  However the devices affected by these phases
+are only those having drivers in the boot kernel; other devices will still be in
+whatever state the boot loader left them.
 
 Should the restoration of the pre-hibernation memory contents fail, the boot
-kernel would carry out the procedure of "thawing" devices described above, using
-the -&gt;pm.thaw_noirq(), -&gt;pm.thaw(), and -&gt;pm.complete() callbacks provided by
-subsystems and device drivers.  This, however, is a very rare condition.  Most
-often the pre-hibernation memory contents are restored successfully and control
-is passed to the image kernel that is now responsible for bringing the system
-back to the working state.
+kernel would go through the "thawing" procedure described above, using the
+thaw_noirq, thaw, and complete phases, and then continue running normally.  This
+happens only rarely.  Most often the pre-hibernation memory contents are
+restored successfully and control is passed to the image kernel, which then
+becomes responsible for bringing the system back to the working state.
 
-To achieve this goal, among other things, the image kernel restores the
-pre-hibernation functionality of devices.  This operation is analogous to the
-resuming of devices after waking up from the memory sleep state, although it
-involves different device notifications which are the following:
+To achieve this, the image kernel must restore the devices' pre-hibernation
+functionality.  The operation is much like waking up from the memory sleep
+state, although it involves different phases:
 
-   1	bus-&gt;pm.restore_noirq(dev), if implemented; may call the device driver's
-	-&gt;pm.restore_noirq() method, depending on the bus type in question.
+	restore_noirq, restore, complete
 
-   2	bus-&gt;pm.restore(dev), if implemented; usually calls the device driver's
-	-&gt;pm.restore() method.
+    1.	The restore_noirq phase is analogous to the resume_noirq phase.
 
-   3	type-&gt;pm.restore(dev), if implemented; may call the device driver's
-	-&gt;pm.restore() method if not called by the bus type or class.
+    2.	The restore phase is analogous to the resume phase.
 
-   4	class-&gt;pm.restore(dev), if implemented; may call the device driver's
-	-&gt;pm.restore() method if not called by the bus type or device type.
+    3.	The complete phase is discussed above.
 
-   5	bus-&gt;pm.complete(dev), if implemented; may call the device driver's
-	-&gt;pm.complete() method.
-
-The roles of the -&gt;pm.restore_noirq() and -&gt;pm.restore() callbacks are analogous
-to the roles of the corresponding resume callbacks, but they must assume that
-the device may have been accessed before by the boot kernel.  Consequently, the
-state of the device before they are called may be different from the state of it
-right prior to calling the resume callbacks.  That difference usually doesn't
-matter, so the majority of device drivers can set their resume and restore
-callback pointers to the same routine.  Nevertheless, different callback
-pointers are used in case there is a situation where it actually matters.
+The main difference from resume[_noirq] is that restore[_noirq] must assume the
+device has been accessed and reconfigured by the boot loader or the boot kernel.
+Consequently the state of the device may be different from the state remembered
+from the freeze and freeze_noirq phases.  The device may even need to be reset
+and completely re-initialized.  In many cases this difference doesn't matter, so
+the resume[_noirq] and restore[_norq] method pointers can be set to the same
+routines.  Nevertheless, different callback pointers are used in case there is a
+situation where it actually matters.
 
 
 System Devices
 --------------
-System devices follow a slightly different API, which can be found in
+System devices (sysdevs) follow a slightly different API, which can be found in
 
 	include/linux/sysdev.h
 	drivers/base/sys.c
 
-System devices will only be suspended with interrupts disabled, and after
-all other devices have been suspended.  On resume, they will be resumed
-before any other devices, and also with interrupts disabled.
+System devices will be suspended with interrupts disabled, and after all other
+devices have been suspended.  On resume, they will be resumed before any other
+devices, and also with interrupts disabled.  These things occur in special
+"sysdev_driver" phases, which affect only system devices.
 
-That is, when the non-boot CPUs are all offline and IRQs are disabled on the
-remaining online CPU, then the sysdev_driver.suspend() phase is carried out, and
-the system enters a sleep state (or hibernation image is created).  During
-resume (or after the image has been created) the sysdev_driver.resume() phase
-is carried out, IRQs are enabled on the only online CPU, the non-boot CPUs are
-enabled and that is followed by the "early resume" phase (in which the "noirq"
-callbacks provided by subsystems and device drivers are invoked).
+Thus, after the suspend_noirq (or freeze_noirq or poweroff_noirq) phase, when
+the non-boot CPUs are all offline and IRQs are disabled on the remaining online
+CPU, then a sysdev_driver.suspend phase is carried out, and the system enters a
+sleep state (or a system image is created).  During resume (or after the image
+has been created or loaded) a sysdev_driver.resume phase is carried out, IRQs
+are enabled on the only online CPU, the non-boot CPUs are enabled, and the
+resume_noirq (or thaw_noirq or restore_noirq) phase begins.
 
 Code to actually enter and exit the system-wide low power state sometimes
 involves hardware details that are only known to the boot firmware, and
@@ -606,18 +533,47 @@ may leave a CPU running software (from SRAM or flash memory) that monitors
 the system and manages its wakeup sequence.
 
 
+Device Low Power (suspend) States
+---------------------------------
+Device low-power states aren't standard.  One device might only handle
+"on" and "off, while another might support a dozen different versions of
+"on" (how many engines are active?), plus a state that gets back to "on"
+faster than from a full "off".
+
+Some busses define rules about what different suspend states mean.  PCI
+gives one example:  after the suspend sequence completes, a non-legacy
+PCI device may not perform DMA or issue IRQs, and any wakeup events it
+issues would be issued through the PME# bus signal.  Plus, there are
+several PCI-standard device states, some of which are optional.
+
+In contrast, integrated system-on-chip processors often use IRQs as the
+wakeup event sources (so drivers would call enable_irq_wake) and might
+be able to treat DMA completion as a wakeup event (sometimes DMA can stay
+active too, it'd only be the CPU and some peripherals that sleep).
+
+Some details here may be platform-specific.  Systems may have devices that
+can be fully active in certain sleep states, such as an LCD display that's
+refreshed using DMA while most of the system is sleeping lightly ... and
+its frame buffer might even be updated by a DSP or other non-Linux CPU while
+the Linux control processor stays idle.
+
+Moreover, the specific actions taken may depend on the target system state.
+One target system state might allow a given device to be very operational;
+another might require a hard shut down with re-initialization on resume.
+And two different target systems might use the same device in different
+ways; the aforementioned LCD might be active in one product's "standby",
+but a different product using the same SOC might work differently.
+
+
 Power Management Notifiers
 --------------------------
-As stated in Documentation/power/notifiers.txt, there are some operations that
-cannot be carried out by the power management callbacks discussed above, because
-carrying them out at these points would be too late or too early.  To handle
-these cases subsystems and device drivers may register power management
-notifiers that are called before tasks are frozen and after they have been
-thawed.
-
-Generally speaking, the PM notifiers are suitable for performing actions that
-either require user space to be available, or at least won't interfere with user
-space in a wrong way.
+There are some operations that cannot be carried out by the power management
+callbacks discussed above, because the callbacks occur too late or too early.
+To handle these cases, subsystems and device drivers may register power
+management notifiers that are called before tasks are frozen and after they have
+been thawed.  Generally speaking, the PM notifiers are suitable for performing
+actions that either require user space to be available, or at least won't
+interfere with user space.
 
 For details refer to Documentation/power/notifiers.txt.
 
@@ -629,24 +585,23 @@ running. This feature is useful for devices that are not being used, and
 can offer significant power savings on a running system.  These devices
 often support a range of runtime power states, which might use names such
 as "off", "sleep", "idle", "active", and so on.  Those states will in some
-cases (like PCI) be partially constrained by a bus the device uses, and will
+cases (like PCI) be partially constrained by the bus the device uses, and will
 usually include hardware states that are also used in system sleep states.
 
-Note, however, that a system-wide power transition can be started while some
-devices are in low power states due to the runtime power management.  The system
-sleep PM callbacks should generally recognize such situations and react to them
-appropriately, but the recommended actions to be taken in that cases are
-subsystem-specific.
-
-In some cases the decision may be made at the subsystem level while in some
-other cases the device driver may be left to decide.  In some cases it may be
-desirable to leave a suspended device in that state during system-wide power
-transition, but in some other cases the device ought to be put back into the
-full power state, for example to be configured for system wakeup or so that its
-system wakeup capability can be disabled.  That all depends on the hardware
-and the design of the subsystem and device driver in question.
-
-During system-wide resume from a sleep state it's better to put devices into
-the full power state, as explained in Documentation/power/runtime_pm.txt.  Refer
-to that document for more information regarding this particular issue as well as
+A system-wide power transition can be started while some devices are in low
+power states due to runtime power management.  The system sleep PM callbacks
+should recognize such situations and react to them appropriately, but the
+necessary actions are subsystem-specific.
+
+In some cases the decision may be made at the subsystem level while in other
+cases the device driver may be left to decide.  In some cases it may be
+desirable to leave a suspended device in that state during a system-wide power
+transition, but in other cases the device must be put back into the full-power
+state temporarily, for example so that its system wakeup capability can be
+disabled.  This all depends on the hardware and the design of the subsystem and
+device driver in question.
+
+During system-wide resume from a sleep state it's best to put devices into the
+full-power state, as explained in Documentation/power/runtime_pm.txt.  Refer to
+that document for more information regarding this particular issue as well as
 for information on the device runtime power management framework in general.</pre><hr><pre>commit 240c7337a4cd3d91b196c5ef97ad461b3a22fa09
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Mar 23 00:50:07 2010 +0100

    PM: Allow runtime_suspend methods to call pm_schedule_suspend()
    
    This patch (as1361) changes the runtime PM interface slightly; it
    allows suspend requests to be scheduled while the runtime_suspend
    method is running.  If the method succeeds then the scheduled request
    is cancelled, whereas if the method fails then an idle notification is
    sent only if no request was scheduled.
    
    Being able to schedule suspend requests from within a runtime_suspend
    method is useful for drivers that need to test for idleness and
    suspend the device all while holding a single spinlock, or for drivers
    that want to check for idleness by polling.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 626dd147b75f..b0ec0e9f27e9 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -229,14 +229,16 @@ int __pm_runtime_suspend(struct device *dev, bool from_wq)
 
 	if (retval) {
 		dev-&gt;power.runtime_status = RPM_ACTIVE;
-		pm_runtime_cancel_pending(dev);
-
 		if (retval == -EAGAIN || retval == -EBUSY) {
-			notify = true;
+			if (dev-&gt;power.timer_expires == 0)
+				notify = true;
 			dev-&gt;power.runtime_error = 0;
+		} else {
+			pm_runtime_cancel_pending(dev);
 		}
 	} else {
 		dev-&gt;power.runtime_status = RPM_SUSPENDED;
+		pm_runtime_deactivate_timer(dev);
 
 		if (dev-&gt;parent) {
 			parent = dev-&gt;parent;
@@ -659,8 +661,6 @@ int pm_schedule_suspend(struct device *dev, unsigned int delay)
 
 	if (dev-&gt;power.runtime_status == RPM_SUSPENDED)
 		retval = 1;
-	else if (dev-&gt;power.runtime_status == RPM_SUSPENDING)
-		retval = -EINPROGRESS;
 	else if (atomic_read(&amp;dev-&gt;power.usage_count) &gt; 0
 	    || dev-&gt;power.disable_depth &gt; 0)
 		retval = -EAGAIN;</pre><hr><pre>commit fde4e2f73208b8f34f123791e39c0cb6bc74b32a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 7 10:41:10 2010 -0400

    HID: fix suspend crash by moving initializations earlier
    
    Although the usbhid driver allocates its usbhid structure in the probe
    routine, several critical fields in that structure don't get
    initialized until usbhid_start().  However if report descriptor
    parsing fails then usbhid_start() is never called.  This leads to
    problems during system suspend -- the system will freeze.
    
    This patch (as1378) fixes the bug by moving the initialization
    statements up into usbhid_probe().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Bruno Prmont &lt;bonbons@linux-vserver.org&gt;
    Tested-By: Bruno Prmont &lt;bonbons@linux-vserver.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 56d06cd8075b..7b85b696fdab 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -999,13 +999,6 @@ static int usbhid_start(struct hid_device *hid)
 		}
 	}
 
-	init_waitqueue_head(&amp;usbhid-&gt;wait);
-	INIT_WORK(&amp;usbhid-&gt;reset_work, hid_reset);
-	INIT_WORK(&amp;usbhid-&gt;restart_work, __usbhid_restart_queues);
-	setup_timer(&amp;usbhid-&gt;io_retry, hid_retry_timeout, (unsigned long) hid);
-
-	spin_lock_init(&amp;usbhid-&gt;lock);
-
 	usbhid-&gt;urbctrl = usb_alloc_urb(0, GFP_KERNEL);
 	if (!usbhid-&gt;urbctrl) {
 		ret = -ENOMEM;
@@ -1179,6 +1172,12 @@ static int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *
 	usbhid-&gt;intf = intf;
 	usbhid-&gt;ifnum = interface-&gt;desc.bInterfaceNumber;
 
+	init_waitqueue_head(&amp;usbhid-&gt;wait);
+	INIT_WORK(&amp;usbhid-&gt;reset_work, hid_reset);
+	INIT_WORK(&amp;usbhid-&gt;restart_work, __usbhid_restart_queues);
+	setup_timer(&amp;usbhid-&gt;io_retry, hid_retry_timeout, (unsigned long) hid);
+	spin_lock_init(&amp;usbhid-&gt;lock);
+
 	ret = hid_add_device(hid);
 	if (ret) {
 		if (ret != -ENODEV)</pre><hr><pre>commit fcf7d2141f4a363a4a8454c4a0f26bb69e766c5f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 20 10:37:57 2010 -0400

    USB: OHCI: don't look at the root hub to get the number of ports
    
    This patch (as1371) fixes a small bug in ohci-hcd.  The HCD already
    knows how many ports the controller has; there's no need to go looking
    at the root hub's usb_device structure to find out.  Especially since
    the root hub's maxchild value is set correctly only while the root hub
    is bound to the hub driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 32bbce9718f0..65cac8cc8921 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -697,7 +697,7 @@ static int ohci_hub_control (
 	u16		wLength
 ) {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
-	int		ports = hcd_to_bus (hcd)-&gt;root_hub-&gt;maxchild;
+	int		ports = ohci-&gt;num_ports;
 	u32		temp;
 	int		retval = 0;
 </pre><hr><pre>commit 62f9cfa3ece58268b3e92ca59c23b175f86205aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Apr 20 10:40:59 2010 -0400

    USB: don't choose configs with no interfaces
    
    This patch (as1372) fixes a bug in the routine that chooses the
    default configuration to install when a new USB device is detected.
    The algorithm is supposed to look for a config whose first interface
    is for a non-vendor-specific class.  But the way it's currently
    written, it will also accept a config with no interfaces at all, which
    is not very useful.  (Believe it or not, such things do exist.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andrew Victor &lt;avictor.za@gmail.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index bdf87a8414a1..2c95153c0f24 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -120,7 +120,7 @@ int usb_choose_configuration(struct usb_device *udev)
 		 * than a vendor-specific driver. */
 		else if (udev-&gt;descriptor.bDeviceClass !=
 						USB_CLASS_VENDOR_SPEC &amp;&amp;
-				(!desc || desc-&gt;bInterfaceClass !=
+				(desc &amp;&amp; desc-&gt;bInterfaceClass !=
 						USB_CLASS_VENDOR_SPEC)) {
 			best = c;
 			break;</pre><hr><pre>commit eef6a7d5c2f38adadab8240fabf43730fe796482
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 17:39:21 2010 +0900

    workqueue: warn about flush_scheduled_work()
    
    This patch (as1319) adds kerneldoc and a pointed warning to
    flush_scheduled_work().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Tejun Heo &lt;tj@kernel.org&gt;

diff --git a/kernel/workqueue.c b/kernel/workqueue.c
index 5bfb213984b2..0225fea89340 100644
--- a/kernel/workqueue.c
+++ b/kernel/workqueue.c
@@ -845,6 +845,30 @@ int schedule_on_each_cpu(work_func_t func)
 	return 0;
 }
 
+/**
+ * flush_scheduled_work - ensure that any scheduled work has run to completion.
+ *
+ * Forces execution of the kernel-global workqueue and blocks until its
+ * completion.
+ *
+ * Think twice before calling this function!  It's very easy to get into
+ * trouble if you don't take great care.  Either of the following situations
+ * will lead to deadlock:
+ *
+ *	One of the work items currently on the workqueue needs to acquire
+ *	a lock held by your code or its caller.
+ *
+ *	Your code is running in the context of a work routine.
+ *
+ * They will be detected by lockdep when they occur, but the first might not
+ * occur very often.  It depends on what work items are on the workqueue and
+ * what locks they need, which you have no control over.
+ *
+ * In most situations flushing the entire workqueue is overkill; you merely
+ * need to know that a particular work item isn't queued and isn't running.
+ * In such cases you should use cancel_delayed_work_sync() or
+ * cancel_work_sync() instead.
+ */
 void flush_scheduled_work(void)
 {
 	flush_workqueue(keventd_wq);</pre><hr><pre>commit 571dc79d62a163fd043de47d7d39bae58831e81e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 9 16:03:43 2010 -0400

    USB: put claimed interfaces in the "suspended" state
    
    This patch (as1370) fixes a bug in the USB runtime power management
    code.  When a driver claims an interface, it doesn't expect to need to
    call usb_autopm_get_interface() or usb_autopm_put_interface() for
    runtime PM to work.  Runtime PM can be controlled by the driver's
    primary interface; the additional interfaces it claims shouldn't
    interfere.  As things stand, the claimed interfaces will prevent the
    device from autosuspending.
    
    To fix this problem, the patch sets interfaces to the suspended state
    when they are claimed.
    
    Also, although in theory this shouldn't matter, the patch changes the
    suspend code so that interfaces are suspended in reverse order from
    detection and resuming.  This is how the PM core works, and we ought
    to use the same approach.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Debugged-and-tested-by: Dominik Brodowski &lt;linux@dominikbrodowski.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 64b91d6c5a5d..2f3dc4cdf79b 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -301,7 +301,7 @@ static int usb_probe_interface(struct device *dev)
 
 	intf-&gt;condition = USB_INTERFACE_BINDING;
 
-	/* Bound interfaces are initially active.  They are
+	/* Probed interfaces are initially active.  They are
 	 * runtime-PM-enabled only if the driver has autosuspend support.
 	 * They are sensitive to their children's power states.
 	 */
@@ -437,11 +437,11 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
-	/* Bound interfaces are initially active.  They are
+	/* Claimed interfaces are initially inactive (suspended).  They are
 	 * runtime-PM-enabled only if the driver has autosuspend support.
 	 * They are sensitive to their children's power states.
 	 */
-	pm_runtime_set_active(dev);
+	pm_runtime_set_suspended(dev);
 	pm_suspend_ignore_children(dev, false);
 	if (driver-&gt;supports_autosuspend)
 		pm_runtime_enable(dev);
@@ -1170,7 +1170,7 @@ static int usb_resume_interface(struct usb_device *udev,
 static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 {
 	int			status = 0;
-	int			i = 0;
+	int			i = 0, n = 0;
 	struct usb_interface	*intf;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
@@ -1179,7 +1179,8 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	/* Suspend all the interfaces and then udev itself */
 	if (udev-&gt;actconfig) {
-		for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+		n = udev-&gt;actconfig-&gt;desc.bNumInterfaces;
+		for (i = n - 1; i &gt;= 0; --i) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			status = usb_suspend_interface(udev, intf, msg);
 			if (status != 0)
@@ -1192,7 +1193,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
 		msg.event ^= (PM_EVENT_SUSPEND | PM_EVENT_RESUME);
-		while (--i &gt;= 0) {
+		while (++i &lt; n) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			usb_resume_interface(udev, intf, msg, 0);
 		}</pre><hr><pre>commit 0e5f231bc16ff9910882fa5b9d64d80e7691cfab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 8 16:56:37 2010 -0400

    USB: EHCI: defer reclamation of siTDs
    
    This patch (as1369) fixes a problem in ehci-hcd.  Some controllers
    occasionally run into trouble when the driver reclaims siTDs too
    quickly.  This can happen while streaming audio; it causes the
    controller to crash.
    
    The patch changes siTD reclamation to work the same way as iTD
    reclamation: Completed siTDs are stored on a list and not reused until
    at least one frame has passed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Nate Case &lt;ncase@xes-inc.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 207e7a85aeb0..13ead00aecd5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -543,6 +543,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 */
 	ehci-&gt;periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
+	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) &lt; 0)
 		return retval;
 
diff --git a/drivers/usb/host/ehci-mem.c b/drivers/usb/host/ehci-mem.c
index aeda96e0af67..1f3f01eacaf0 100644
--- a/drivers/usb/host/ehci-mem.c
+++ b/drivers/usb/host/ehci-mem.c
@@ -136,7 +136,7 @@ static inline void qh_put (struct ehci_qh *qh)
 
 static void ehci_mem_cleanup (struct ehci_hcd *ehci)
 {
-	free_cached_itd_list(ehci);
+	free_cached_lists(ehci);
 	if (ehci-&gt;async)
 		qh_put (ehci-&gt;async);
 	ehci-&gt;async = NULL;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index a0aaaaff2560..805ec633a652 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -510,7 +510,7 @@ static int disable_periodic (struct ehci_hcd *ehci)
 	ehci_writel(ehci, cmd, &amp;ehci-&gt;regs-&gt;command);
 	/* posted write ... */
 
-	free_cached_itd_list(ehci);
+	free_cached_lists(ehci);
 
 	ehci-&gt;next_uframe = -1;
 	return 0;
@@ -2139,13 +2139,27 @@ sitd_complete (
 			(stream-&gt;bEndpointAddress &amp; USB_DIR_IN) ? "in" : "out");
 	}
 	iso_stream_put (ehci, stream);
-	/* OK to recycle this SITD now that its completion callback ran. */
+
 done:
 	sitd-&gt;urb = NULL;
-	sitd-&gt;stream = NULL;
-	list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
-	iso_stream_put(ehci, stream);
-
+	if (ehci-&gt;clock_frame != sitd-&gt;frame) {
+		/* OK to recycle this SITD now. */
+		sitd-&gt;stream = NULL;
+		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
+		iso_stream_put(ehci, stream);
+	} else {
+		/* HW might remember this SITD, so we can't recycle it yet.
+		 * Move it to a safe place until a new frame starts.
+		 */
+		list_move(&amp;sitd-&gt;sitd_list, &amp;ehci-&gt;cached_sitd_list);
+		if (stream-&gt;refcount == 2) {
+			/* If iso_stream_put() were called here, stream
+			 * would be freed.  Instead, just prevent reuse.
+			 */
+			stream-&gt;ep-&gt;hcpriv = NULL;
+			stream-&gt;ep = NULL;
+		}
+	}
 	return retval;
 }
 
@@ -2211,9 +2225,10 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 /*-------------------------------------------------------------------------*/
 
-static void free_cached_itd_list(struct ehci_hcd *ehci)
+static void free_cached_lists(struct ehci_hcd *ehci)
 {
 	struct ehci_itd *itd, *n;
+	struct ehci_sitd *sitd, *sn;
 
 	list_for_each_entry_safe(itd, n, &amp;ehci-&gt;cached_itd_list, itd_list) {
 		struct ehci_iso_stream	*stream = itd-&gt;stream;
@@ -2221,6 +2236,13 @@ static void free_cached_itd_list(struct ehci_hcd *ehci)
 		list_move(&amp;itd-&gt;itd_list, &amp;stream-&gt;free_list);
 		iso_stream_put(ehci, stream);
 	}
+
+	list_for_each_entry_safe(sitd, sn, &amp;ehci-&gt;cached_sitd_list, sitd_list) {
+		struct ehci_iso_stream	*stream = sitd-&gt;stream;
+		sitd-&gt;stream = NULL;
+		list_move(&amp;sitd-&gt;sitd_list, &amp;stream-&gt;free_list);
+		iso_stream_put(ehci, stream);
+	}
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2247,7 +2269,7 @@ scan_periodic (struct ehci_hcd *ehci)
 		clock_frame = -1;
 	}
 	if (ehci-&gt;clock_frame != clock_frame) {
-		free_cached_itd_list(ehci);
+		free_cached_lists(ehci);
 		ehci-&gt;clock_frame = clock_frame;
 	}
 	clock %= mod;
@@ -2414,7 +2436,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			clock = now;
 			clock_frame = clock &gt;&gt; 3;
 			if (ehci-&gt;clock_frame != clock_frame) {
-				free_cached_itd_list(ehci);
+				free_cached_lists(ehci);
 				ehci-&gt;clock_frame = clock_frame;
 			}
 		} else {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index b1dce96dd621..556c0b48f3ab 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -87,8 +87,9 @@ struct ehci_hcd {			/* one per controller */
 	int			next_uframe;	/* scan periodic, start here */
 	unsigned		periodic_sched;	/* periodic activity count */
 
-	/* list of itds completed while clock_frame was still active */
+	/* list of itds &amp; sitds completed while clock_frame was still active */
 	struct list_head	cached_itd_list;
+	struct list_head	cached_sitd_list;
 	unsigned		clock_frame;
 
 	/* per root hub port */
@@ -195,7 +196,7 @@ timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
 	clear_bit (action, &amp;ehci-&gt;actions);
 }
 
-static void free_cached_itd_list(struct ehci_hcd *ehci);
+static void free_cached_lists(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/
 </pre><hr><pre>commit 5f677f1d45b2bf08085bbba7394392dfa586fa8e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 2 13:20:11 2010 -0400

    USB: fix remote wakeup settings during system sleep
    
    This patch (as1363) changes the way USB remote wakeup is handled
    during system sleeps.  It won't be enabled unless an interface driver
    specifically needs it.  Also, it won't be enabled during the FREEZE or
    QUIESCE phases of hibernation, when the system doesn't respond to
    wakeup events anyway.  Finally, if the device is already
    runtime-suspended with remote wakeup enabled, but wakeup is supposed
    to be disabled for the system sleep, the device gets woken up so that
    it can be suspended again with the proper wakeup setting.
    
    This will fix problems people have reported with certain USB webcams
    that generate wakeup requests when they shouldn't, and as a result
    cause system suspends to fail.  See
    
            https://bugs.launchpad.net/ubuntu/+source/linux/+bug/515109
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Erik Andrn &lt;erik.andren@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 6a3b5cae3a6e..64b91d6c5a5d 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1263,13 +1263,47 @@ static int usb_resume_both(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
+static void choose_wakeup(struct usb_device *udev, pm_message_t msg)
+{
+	int			w, i;
+	struct usb_interface	*intf;
+
+	/* Remote wakeup is needed only when we actually go to sleep.
+	 * For things like FREEZE and QUIESCE, if the device is already
+	 * autosuspended then its current wakeup setting is okay.
+	 */
+	if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_QUIESCE) {
+		if (udev-&gt;state != USB_STATE_SUSPENDED)
+			udev-&gt;do_remote_wakeup = 0;
+		return;
+	}
+
+	/* If remote wakeup is permitted, see whether any interface drivers
+	 * actually want it.
+	 */
+	w = 0;
+	if (device_may_wakeup(&amp;udev-&gt;dev) &amp;&amp; udev-&gt;actconfig) {
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			w |= intf-&gt;needs_remote_wakeup;
+		}
+	}
+
+	/* If the device is autosuspended with the wrong wakeup setting,
+	 * autoresume now so the setting can be changed.
+	 */
+	if (udev-&gt;state == USB_STATE_SUSPENDED &amp;&amp; w != udev-&gt;do_remote_wakeup)
+		pm_runtime_resume(&amp;udev-&gt;dev);
+	udev-&gt;do_remote_wakeup = w;
+}
+
 /* The device lock is held by the PM core */
 int usb_suspend(struct device *dev, pm_message_t msg)
 {
 	struct usb_device	*udev = to_usb_device(dev);
 
 	do_unbind_rebind(udev, DO_UNBIND);
-	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+	choose_wakeup(udev, msg);
 	return usb_suspend_both(udev, msg);
 }
 </pre>
    <div class="pagination">
        <a href='2_67.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><span>[68]</span><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_69.html'>Next&gt;&gt;</a>
    <div>
</body>
