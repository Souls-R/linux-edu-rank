<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <span>[1]</span><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2dc318ea9681c14c37bad2715097df4380a3c547
Author: Trevor Gross &lt;tmgross@umich.edu&gt;
Date:   Fri Nov 17 20:39:59 2023 -0500

    rust: macros: update 'paste!' macro to accept string literals
    
    Enable combining identifiers with literals in the 'paste!' macro. This
    allows combining user-specified strings with affixes to create
    namespaced identifiers.
    
    This sample code:
    
        macro_rules! m {
            ($name:lit) =&gt; {
                paste!(struct [&lt;_some_ $name _struct_&gt;] {})
            }
        }
    
        m!("foo_bar");
    
    Would previously cause a compilation error. It will now generate:
    
        struct _some_foo_bar_struct_ {}
    
    Signed-off-by: Trevor Gross &lt;tmgross@umich.edu&gt;
    Reviewed-by: Martin Rodriguez Reboredo &lt;yakoyoku@gmail.com&gt;
    Reviewed-by: Vincenzo Palazzo &lt;vincenzopalazzodev@gmail.com&gt;
    Reviewed-by: Alice Ryhl &lt;aliceryhl@google.com&gt;
    Reviewed-by: Benno Lossin &lt;benno.lossin@proton.me&gt;
    Reviewed-by: Gary Guo &lt;gary@garyguo.net&gt;
    Link: https://lore.kernel.org/r/20231118013959.37384-1-tmgross@umich.edu
    [ Added `:` before example block. ]
    Signed-off-by: Miguel Ojeda &lt;ojeda@kernel.org&gt;

diff --git a/rust/macros/lib.rs b/rust/macros/lib.rs
index c42105c2ff96..125f5ea74a16 100644
--- a/rust/macros/lib.rs
+++ b/rust/macros/lib.rs
@@ -254,8 +254,8 @@ pub fn pinned_drop(args: TokenStream, input: TokenStream) -&gt; TokenStream {
 /// Within the `paste!` macro, identifiers inside `[&lt;` and `&gt;]` are concatenated together to form a
 /// single identifier.
 ///
-/// This is similar to the [`paste`] crate, but with pasting feature limited to identifiers
-/// (literals, lifetimes and documentation strings are not supported). There is a difference in
+/// This is similar to the [`paste`] crate, but with pasting feature limited to identifiers and
+/// literals (lifetimes and documentation strings are not supported). There is a difference in
 /// supported modifiers as well.
 ///
 /// # Example
@@ -337,6 +337,24 @@ pub fn pinned_drop(args: TokenStream, input: TokenStream) -&gt; TokenStream {
 /// assert_eq!(br_ok(), binder_driver_return_protocol_BR_OK);
 /// ```
 ///
+/// # Literals
+///
+/// Literals can also be concatenated with other identifiers:
+///
+/// ```ignore
+/// macro_rules! create_numbered_fn {
+///     ($name:literal, $val:literal) =&gt; {
+///         kernel::macros::paste! {
+///             fn [&lt;some_ $name _fn $val&gt;]() -&gt; u32 { $val }
+///         }
+///     };
+/// }
+///
+/// create_numbered_fn!("foo", 100);
+///
+/// assert_eq!(some_foo_fn100(), 100)
+/// ```
+///
 /// [`paste`]: https://docs.rs/paste/
 #[proc_macro]
 pub fn paste(input: TokenStream) -&gt; TokenStream {
diff --git a/rust/macros/paste.rs b/rust/macros/paste.rs
index 385a78434224..f40d42b35b58 100644
--- a/rust/macros/paste.rs
+++ b/rust/macros/paste.rs
@@ -9,7 +9,15 @@ fn concat(tokens: &amp;[TokenTree], group_span: Span) -&gt; TokenTree {
     loop {
         match tokens.next() {
             None =&gt; break,
-            Some(TokenTree::Literal(lit)) =&gt; segments.push((lit.to_string(), lit.span())),
+            Some(TokenTree::Literal(lit)) =&gt; {
+                // Allow us to concat string literals by stripping quotes
+                let mut value = lit.to_string();
+                if value.starts_with('"') &amp;&amp; value.ends_with('"') {
+                    value.remove(0);
+                    value.pop();
+                }
+                segments.push((value, lit.span()));
+            }
             Some(TokenTree::Ident(ident)) =&gt; {
                 let mut value = ident.to_string();
                 if value.starts_with("r#") {</pre><hr><pre>commit 2285eb2f2429daadf9d57f08137b472139470aa9
Author: Trevor Gross &lt;tmgross@umich.edu&gt;
Date:   Thu Aug 3 02:04:37 2023 -0400

    docs: rust: clarify what 'rustup override' does
    
    The behavior of 'rustup override' is not very well known. Add a small
    note about what it does, so users have a better understanding of how it
    affects their system toolchain (i.e., it does not affect system
    toolchain and only sets a directory-specific override).
    
    Signed-off-by: Trevor Gross &lt;tmgross@umich.edu&gt;
    Reviewed-by: Martin Rodriguez Reboredo &lt;yakoyoku@gmail.com&gt;
    Reviewed-by: Alice Ryhl &lt;aliceryhl@google.com&gt;
    Link: https://lore.kernel.org/r/20230803060437.12157-3-tmgross@umich.edu
    [ Undid the `:` to `::` change. ]
    Signed-off-by: Miguel Ojeda &lt;ojeda@kernel.org&gt;

diff --git a/Documentation/rust/quick-start.rst b/Documentation/rust/quick-start.rst
index a0a47a6f216b..f382914f4191 100644
--- a/Documentation/rust/quick-start.rst
+++ b/Documentation/rust/quick-start.rst
@@ -38,7 +38,9 @@ and run::
 
 	rustup override set $(scripts/min-tool-version.sh rustc)
 
-Otherwise, fetch a standalone installer from:
+This will configure your working directory to use the correct version of
+``rustc`` without affecting your default toolchain. If you are not using
+``rustup``, fetch a standalone installer from:
 
 	https://forge.rust-lang.org/infra/other-installation-methods.html#standalone
 </pre><hr><pre>commit 8cb40124cf923d4627d2e29b84dbff72e41fa0ef
Author: Trevor Gross &lt;tmgross@umich.edu&gt;
Date:   Thu Aug 3 02:04:36 2023 -0400

    docs: rust: update instructions for obtaining 'core' source
    
    The source for Rust's 'core' library is needed to build the kernel with
    Rust support. This sometimes needs to be obtained by hand when using a
    standalone version of 'rustc' not managed by 'rustup'. Currently, the
    documentation suggests cloning the 'rust' repository to obtain these
    sources, but this is quite slow (on the order of a multiple minutes).
    
    Change this documentation to suggest using the source tarball instead.
    The tarball includes only needed files (&lt;5M) and is significantly faster
    to download; this is more in line with what 'rustup' does.
    
    Also simplify wording of the relevant section.
    
    Link: https://github.com/Rust-for-Linux/linux/pull/1024
    Signed-off-by: Trevor Gross &lt;tmgross@umich.edu&gt;
    Reviewed-by: Martin Rodriguez Reboredo &lt;yakoyoku@gmail.com&gt;
    Reviewed-by: Alice Ryhl &lt;aliceryhl@google.com&gt;
    Link: https://lore.kernel.org/r/20230803060437.12157-2-tmgross@umich.edu
    Signed-off-by: Miguel Ojeda &lt;ojeda@kernel.org&gt;

diff --git a/Documentation/rust/quick-start.rst b/Documentation/rust/quick-start.rst
index 1274cd74f767..a0a47a6f216b 100644
--- a/Documentation/rust/quick-start.rst
+++ b/Documentation/rust/quick-start.rst
@@ -56,16 +56,17 @@ If ``rustup`` is being used, run::
 The components are installed per toolchain, thus upgrading the Rust compiler
 version later on requires re-adding the component.
 
-Otherwise, if a standalone installer is used, the Rust repository may be cloned
-into the installation folder of the toolchain::
+Otherwise, if a standalone installer is used, the Rust source tree may be
+downloaded into the toolchain's installation folder::
 
-	git clone --recurse-submodules \
-		--branch $(scripts/min-tool-version.sh rustc) \
-		https://github.com/rust-lang/rust \
-		$(rustc --print sysroot)/lib/rustlib/src/rust
+	curl -L "https://static.rust-lang.org/dist/rust-src-$(scripts/min-tool-version.sh rustc).tar.gz" |
+		tar -xzf - -C "$(rustc --print sysroot)/lib" \
+		"rust-src-$(scripts/min-tool-version.sh rustc)/rust-src/lib/" \
+		--strip-components=3
 
 In this case, upgrading the Rust compiler version later on requires manually
-updating this clone.
+updating the source tree (this can be done by removing ``$(rustc --print
+sysroot)/lib/rustlib/src/rust`` then rerunning the above command).
 
 
 libclang</pre><hr><pre>commit f8bc1b2efa05183f10451b7618243a4278bf6b16
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Tue Dec 4 12:07:50 2018 -0700

    staging: comedi: change do_insn*_ioctl to allow more samples
    
    Changes do_insn*_ioctl functions to allow for data lengths for each
    comedi_insn of up to 2^16.  This patch also changes these functions to only
    allocate as much memory as is necessary for each comedi_insn, rather than
    allocating a fixed-sized scratch space.
    
    In testing some user-space code for the new INSN_DEVICE_CONFIG_GET_ROUTES
    facility with some newer hardware, I discovered that do_insn_ioctl and
    do_insnlist_ioctl limited the amount of data that can be passed into the
    kernel for insn's to a length of 256.  For some newer hardware, the number
    of routes can be greater than 1000.  Working around the old limits (256)
    would complicate the user-space/kernel interaction.
    
    The new upper limit is reasonable with current memory available and does
    not otherwise impact the memory footprint for any current or otherwise
    typical configuration.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/comedi_fops.c b/drivers/staging/comedi/comedi_fops.c
index ceb6ba5dd57c..5d2fcbfe02af 100644
--- a/drivers/staging/comedi/comedi_fops.c
+++ b/drivers/staging/comedi/comedi_fops.c
@@ -1501,25 +1501,21 @@ static int parse_insn(struct comedi_device *dev, struct comedi_insn *insn,
  *	data (for reads) to insns[].data pointers
  */
 /* arbitrary limits */
-#define MAX_SAMPLES 256
+#define MIN_SAMPLES 16
+#define MAX_SAMPLES 65536
 static int do_insnlist_ioctl(struct comedi_device *dev,
 			     struct comedi_insnlist __user *arg, void *file)
 {
 	struct comedi_insnlist insnlist;
 	struct comedi_insn *insns = NULL;
 	unsigned int *data = NULL;
+	unsigned int max_n_data_required = MIN_SAMPLES;
 	int i = 0;
 	int ret = 0;
 
 	if (copy_from_user(&amp;insnlist, arg, sizeof(insnlist)))
 		return -EFAULT;
 
-	data = kmalloc_array(MAX_SAMPLES, sizeof(unsigned int), GFP_KERNEL);
-	if (!data) {
-		ret = -ENOMEM;
-		goto error;
-	}
-
 	insns = kcalloc(insnlist.n_insns, sizeof(*insns), GFP_KERNEL);
 	if (!insns) {
 		ret = -ENOMEM;
@@ -1533,13 +1529,26 @@ static int do_insnlist_ioctl(struct comedi_device *dev,
 		goto error;
 	}
 
-	for (i = 0; i &lt; insnlist.n_insns; i++) {
+	/* Determine maximum memory needed for all instructions. */
+	for (i = 0; i &lt; insnlist.n_insns; ++i) {
 		if (insns[i].n &gt; MAX_SAMPLES) {
 			dev_dbg(dev-&gt;class_dev,
 				"number of samples too large\n");
 			ret = -EINVAL;
 			goto error;
 		}
+		max_n_data_required = max(max_n_data_required, insns[i].n);
+	}
+
+	/* Allocate scratch space for all instruction data. */
+	data = kmalloc_array(max_n_data_required, sizeof(unsigned int),
+			     GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	for (i = 0; i &lt; insnlist.n_insns; ++i) {
 		if (insns[i].insn &amp; INSN_MASK_WRITE) {
 			if (copy_from_user(data, insns[i].data,
 					   insns[i].n * sizeof(unsigned int))) {
@@ -1593,22 +1602,27 @@ static int do_insn_ioctl(struct comedi_device *dev,
 {
 	struct comedi_insn insn;
 	unsigned int *data = NULL;
+	unsigned int n_data = MIN_SAMPLES;
 	int ret = 0;
 
-	data = kmalloc_array(MAX_SAMPLES, sizeof(unsigned int), GFP_KERNEL);
-	if (!data) {
-		ret = -ENOMEM;
-		goto error;
-	}
-
 	if (copy_from_user(&amp;insn, arg, sizeof(insn))) {
-		ret = -EFAULT;
-		goto error;
+		return -EFAULT;
 	}
 
+	n_data = max(n_data, insn.n);
+
 	/* This is where the behavior of insn and insnlist deviate. */
-	if (insn.n &gt; MAX_SAMPLES)
+	if (insn.n &gt; MAX_SAMPLES) {
 		insn.n = MAX_SAMPLES;
+		n_data = MAX_SAMPLES;
+	}
+
+	data = kmalloc_array(n_data, sizeof(unsigned int), GFP_KERNEL);
+	if (!data) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
 	if (insn.insn &amp; INSN_MASK_WRITE) {
 		if (copy_from_user(data,
 				   insn.data,</pre><hr><pre>commit 4dc2a3cd27856531cf92762fea2eb9468efe552f
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Oct 24 08:33:40 2018 -0600

    staging: comedi: clarify/unify macros for NI macro-defined terminals
    
    Uses a single macro to define multiple macros that represent a series of
    terminals for NI devices.  This patch also redefines NI_MAX_COUNTERS as the
    maximum number of counters possible on NI devices (instead of the maximum
    index of the counters).  This was a little confusing and caused a bug in
    commit 347e244884c3b ("staging: comedi: tio: implement global tio/ctr routing")
    when setting/reading registers for counter terminals.
    
    Fixes: 347e244884c3b ("staging: comedi: tio: implement global tio/ctr routing")
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/comedi.h b/drivers/staging/comedi/comedi.h
index e90b17775284..09a940066c0e 100644
--- a/drivers/staging/comedi/comedi.h
+++ b/drivers/staging/comedi/comedi.h
@@ -1005,35 +1005,38 @@ enum i8254_mode {
  * and INSN_DEVICE_CONFIG_GET_ROUTES.
  */
 #define NI_NAMES_BASE	0x8000u
+
+#define _TERM_N(base, n, x)	((base) + ((x) &amp; ((n) - 1)))
+
 /*
  * not necessarily all allowed 64 PFIs are valid--certainly not for all devices
  */
-#define NI_PFI(x)	(NI_NAMES_BASE        + ((x) &amp; 0x3f))
+#define NI_PFI(x)		_TERM_N(NI_NAMES_BASE, 64, x)
 /* 8 trigger lines by standard, Some devices cannot talk to all eight. */
-#define TRIGGER_LINE(x)	(NI_PFI(-1)       + 1 + ((x) &amp; 0x7))
+#define TRIGGER_LINE(x)		_TERM_N(NI_PFI(-1) + 1, 8, x)
 /* 4 RTSI shared MUXes to route signals to/from TRIGGER_LINES on NI hardware */
-#define NI_RTSI_BRD(x)	(TRIGGER_LINE(-1) + 1 + ((x) &amp; 0x3))
+#define NI_RTSI_BRD(x)		_TERM_N(TRIGGER_LINE(-1) + 1, 4, x)
 
 /* *** Counter/timer names : 8 counters max *** */
-#define NI_COUNTER_NAMES_BASE  (NI_RTSI_BRD(-1)  + 1)
-#define NI_MAX_COUNTERS	       7
-#define NI_CtrSource(x)	       (NI_COUNTER_NAMES_BASE + ((x) &amp; NI_MAX_COUNTERS))
+#define NI_MAX_COUNTERS		8
+#define NI_COUNTER_NAMES_BASE	(NI_RTSI_BRD(-1)  + 1)
+#define NI_CtrSource(x)	      _TERM_N(NI_COUNTER_NAMES_BASE, NI_MAX_COUNTERS, x)
 /* Gate, Aux, A,B,Z are all treated, at times as gates */
-#define NI_GATES_NAMES_BASE    (NI_CtrSource(-1) + 1)
-#define NI_CtrGate(x)	       (NI_GATES_NAMES_BASE   + ((x) &amp; NI_MAX_COUNTERS))
-#define NI_CtrAux(x)	       (NI_CtrGate(-1)   + 1  + ((x) &amp; NI_MAX_COUNTERS))
-#define NI_CtrA(x)	       (NI_CtrAux(-1)    + 1  + ((x) &amp; NI_MAX_COUNTERS))
-#define NI_CtrB(x)	       (NI_CtrA(-1)      + 1  + ((x) &amp; NI_MAX_COUNTERS))
-#define NI_CtrZ(x)	       (NI_CtrB(-1)      + 1  + ((x) &amp; NI_MAX_COUNTERS))
-#define NI_GATES_NAMES_MAX     NI_CtrZ(-1)
-#define NI_CtrArmStartTrigger(x) (NI_CtrZ(-1)    + 1  + ((x) &amp; NI_MAX_COUNTERS))
+#define NI_GATES_NAMES_BASE	(NI_CtrSource(-1) + 1)
+#define NI_CtrGate(x)		_TERM_N(NI_GATES_NAMES_BASE, NI_MAX_COUNTERS, x)
+#define NI_CtrAux(x)		_TERM_N(NI_CtrGate(-1)  + 1, NI_MAX_COUNTERS, x)
+#define NI_CtrA(x)		_TERM_N(NI_CtrAux(-1)   + 1, NI_MAX_COUNTERS, x)
+#define NI_CtrB(x)		_TERM_N(NI_CtrA(-1)     + 1, NI_MAX_COUNTERS, x)
+#define NI_CtrZ(x)		_TERM_N(NI_CtrB(-1)     + 1, NI_MAX_COUNTERS, x)
+#define NI_GATES_NAMES_MAX	NI_CtrZ(-1)
+#define NI_CtrArmStartTrigger(x) _TERM_N(NI_CtrZ(-1)    + 1, NI_MAX_COUNTERS, x)
 #define NI_CtrInternalOutput(x) \
-		     (NI_CtrArmStartTrigger(-1)  + 1  + ((x) &amp; NI_MAX_COUNTERS))
+		      _TERM_N(NI_CtrArmStartTrigger(-1) + 1, NI_MAX_COUNTERS, x)
 /** external pin(s) labeled conveniently as Ctr&lt;i&gt;Out. */
-#define NI_CtrOut(x)  (NI_CtrInternalOutput(-1)  + 1  + ((x) &amp; NI_MAX_COUNTERS))
+#define NI_CtrOut(x)   _TERM_N(NI_CtrInternalOutput(-1) + 1, NI_MAX_COUNTERS, x)
 /** For Buffered sampling of ctr -- x series capability. */
-#define NI_CtrSampleClock(x)	(NI_CtrOut(-1)   + 1  + ((x) &amp; NI_MAX_COUNTERS))
-#define NI_COUNTER_NAMES_MAX   NI_CtrSampleClock(-1)
+#define NI_CtrSampleClock(x)	_TERM_N(NI_CtrOut(-1)   + 1, NI_MAX_COUNTERS, x)
+#define NI_COUNTER_NAMES_MAX	NI_CtrSampleClock(-1)
 
 enum ni_common_signal_names {
 	/* PXI_Star: this is a non-NI-specific signal */</pre><hr><pre>commit 9a1ec4eb6f3722a65a267bb7d14c371d73f66c5b
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Oct 24 08:46:59 2018 -0600

    staging: comedi: ni_mio_common: scale ao INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS
    
    Fixes implementation of INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS for
    ni_mio devices.  The previous patch should have used the channel
    information passed in to scale the result by the number of channels being
    used.
    
    Fixes: 51fd36738383 ("staging: comedi: ni_mio_common: implement INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS")
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index 2d1e0325d04d..5edf59ac6706 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -2843,7 +2843,8 @@ static int ni_ao_insn_config(struct comedi_device *dev,
 		return ni_ao_arm(dev, s);
 	case INSN_CONFIG_GET_CMD_TIMING_CONSTRAINTS:
 		/* we don't care about actual channels */
-		data[1] = board-&gt;ao_speed;
+		/* data[3] : chanlist_len */
+		data[1] = board-&gt;ao_speed * data[3];
 		data[2] = 0;
 		return 0;
 	default:</pre><hr><pre>commit fa86c00799ee1fb851261a0ef904200ecd9c8215
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Oct 3 14:56:12 2018 -0600

    staging: comedi: ni_660x: add device-global routing
    
    Provides the device-global routing interface for ni_660x devices.  Using
    the device-global names in comedi_cmd structures for commands was already
    supported through the ni_tio module.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_660x.c b/drivers/staging/comedi/drivers/ni_660x.c
index 59055f366138..e70a461e723f 100644
--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -568,6 +568,10 @@ static void ni_660x_select_pfi_output(struct comedi_device *dev,
 	unsigned int idle_chip = 0;
 	unsigned int bits;
 
+	if (chan &gt;= NI_PFI(0))
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+
 	if (board-&gt;n_chips &gt; 1) {
 		if (out_sel == NI_660X_PFI_OUTPUT_COUNTER &amp;&amp;
 		    chan &gt;= 8 &amp;&amp; chan &lt;= 23) {
@@ -603,6 +607,10 @@ static void ni_660x_set_pfi_direction(struct comedi_device *dev,
 	struct ni_660x_private *devpriv = dev-&gt;private;
 	u64 bit;
 
+	if (chan &gt;= NI_PFI(0))
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+
 	bit = 1ULL &lt;&lt; chan;
 
 	if (direction == COMEDI_OUTPUT) {
@@ -622,6 +630,10 @@ static unsigned int ni_660x_get_pfi_direction(struct comedi_device *dev,
 	struct ni_660x_private *devpriv = dev-&gt;private;
 	u64 bit;
 
+	if (chan &gt;= NI_PFI(0))
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+
 	bit = 1ULL &lt;&lt; chan;
 
 	return (devpriv-&gt;io_dir &amp; bit) ? COMEDI_OUTPUT : COMEDI_INPUT;
@@ -632,6 +644,10 @@ static int ni_660x_set_pfi_routing(struct comedi_device *dev,
 {
 	struct ni_660x_private *devpriv = dev-&gt;private;
 
+	if (chan &gt;= NI_PFI(0))
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+
 	switch (source) {
 	case NI_660X_PFI_OUTPUT_COUNTER:
 		if (chan &lt; 8)
@@ -654,6 +670,10 @@ static int ni_660x_get_pfi_routing(struct comedi_device *dev, unsigned int chan)
 {
 	struct ni_660x_private *devpriv = dev-&gt;private;
 
+	if (chan &gt;= NI_PFI(0))
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+
 	return devpriv-&gt;io_cfg[chan];
 }
 
@@ -662,6 +682,10 @@ static void ni_660x_set_pfi_filter(struct comedi_device *dev,
 {
 	unsigned int val;
 
+	if (chan &gt;= NI_PFI(0))
+		/* allow new and old names of pfi channels to work. */
+		chan -= NI_PFI(0);
+
 	val = ni_660x_read(dev, 0, NI660X_IO_CFG(chan));
 	val &amp;= ~NI660X_IO_CFG_IN_SEL_MASK(chan);
 	val |= NI660X_IO_CFG_IN_SEL(chan, value);
@@ -710,6 +734,240 @@ static int ni_660x_dio_insn_config(struct comedi_device *dev,
 	return insn-&gt;n;
 }
 
+static unsigned int _ni_get_valid_routes(struct comedi_device *dev,
+					 unsigned int n_pairs,
+					 unsigned int *pair_data)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+
+	return ni_get_valid_routes(&amp;devpriv-&gt;routing_tables, n_pairs,
+				   pair_data);
+}
+
+/*
+ * Retrieves the current source of the output selector for the given
+ * destination.  If the terminal for the destination is not already configured
+ * as an output, this function returns -EINVAL as error.
+ *
+ * Return: The register value of the destination output selector;
+ *	   -EINVAL if terminal is not configured for output.
+ */
+static inline int get_output_select_source(int dest, struct comedi_device *dev)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+	int reg = -1;
+
+	if (channel_is_pfi(dest)) {
+		if (ni_660x_get_pfi_direction(dev, dest) == COMEDI_OUTPUT)
+			reg = ni_660x_get_pfi_routing(dev, dest);
+	} else if (channel_is_rtsi(dest)) {
+		dev_dbg(dev-&gt;class_dev,
+			"%s: unhandled rtsi destination (%d) queried\n",
+			__func__, dest);
+		/*
+		 * The following can be enabled when RTSI routing info is
+		 * determined (not currently documented):
+		 * if (ni_get_rtsi_direction(dev, dest) == COMEDI_OUTPUT) {
+		 *	reg = ni_get_rtsi_routing(dev, dest);
+
+		 *	if (reg == NI_RTSI_OUTPUT_RGOUT0) {
+		 *		dest = NI_RGOUT0; ** prepare for lookup below **
+		 *		reg = get_rgout0_reg(dev);
+		 *	} else if (reg &gt;= NI_RTSI_OUTPUT_RTSI_BRD(0) &amp;&amp;
+		 *		   reg &lt;= NI_RTSI_OUTPUT_RTSI_BRD(3)) {
+		 *		const int i = reg - NI_RTSI_OUTPUT_RTSI_BRD(0);
+
+		 *		dest = NI_RTSI_BRD(i); ** prepare for lookup **
+		 *		reg = get_ith_rtsi_brd_reg(i, dev);
+		 *	}
+		 * }
+		 */
+	} else if (channel_is_ctr(dest)) {
+		reg = ni_tio_get_routing(devpriv-&gt;counter_dev, dest);
+	} else {
+		dev_dbg(dev-&gt;class_dev,
+			"%s: unhandled destination (%d) queried\n",
+			__func__, dest);
+	}
+
+	if (reg &gt;= 0)
+		return ni_find_route_source(CR_CHAN(reg), dest,
+					    &amp;devpriv-&gt;routing_tables);
+	return -EINVAL;
+}
+
+/*
+ * Test a route:
+ *
+ * Return: -1 if not connectible;
+ *	    0 if connectible and not connected;
+ *	    1 if connectible and connected.
+ */
+static inline int test_route(unsigned int src, unsigned int dest,
+			     struct comedi_device *dev)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+	s8 reg = ni_route_to_register(CR_CHAN(src), dest,
+				      &amp;devpriv-&gt;routing_tables);
+
+	if (reg &lt; 0)
+		return -1;
+	if (get_output_select_source(dest, dev) != CR_CHAN(src))
+		return 0;
+	return 1;
+}
+
+/* Connect the actual route.  */
+static inline int connect_route(unsigned int src, unsigned int dest,
+				struct comedi_device *dev)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+	s8 reg = ni_route_to_register(CR_CHAN(src), dest,
+				      &amp;devpriv-&gt;routing_tables);
+	s8 current_src;
+
+	if (reg &lt; 0)
+		/* route is not valid */
+		return -EINVAL;
+
+	current_src = get_output_select_source(dest, dev);
+	if (current_src == CR_CHAN(src))
+		return -EALREADY;
+	if (current_src &gt;= 0)
+		/* destination mux is already busy. complain, don't overwrite */
+		return -EBUSY;
+
+	/* The route is valid and available. Now connect... */
+	if (channel_is_pfi(CR_CHAN(dest))) {
+		/*
+		 * set routing and then direction so that the output does not
+		 * first get generated with the wrong pin
+		 */
+		ni_660x_set_pfi_routing(dev, dest, reg);
+		ni_660x_set_pfi_direction(dev, dest, COMEDI_OUTPUT);
+	} else if (channel_is_rtsi(CR_CHAN(dest))) {
+		dev_dbg(dev-&gt;class_dev, "%s: unhandled rtsi destination (%d)\n",
+			__func__, dest);
+		return -EINVAL;
+		/*
+		 * The following can be enabled when RTSI routing info is
+		 * determined (not currently documented):
+		 * if (reg == NI_RTSI_OUTPUT_RGOUT0) {
+		 *	int ret = incr_rgout0_src_use(src, dev);
+
+		 *	if (ret &lt; 0)
+		 *		return ret;
+		 * } else if (ni_rtsi_route_requires_mux(reg)) {
+		 *	** Attempt to allocate and  route (src-&gt;brd) **
+		 *	int brd = incr_rtsi_brd_src_use(src, dev);
+
+		 *	if (brd &lt; 0)
+		 *		return brd;
+
+		 *	** Now lookup the register value for (brd-&gt;dest) **
+		 *	reg = ni_lookup_route_register(brd, CR_CHAN(dest),
+		 *				       &amp;devpriv-&gt;routing_tables);
+		 * }
+
+		 * ni_set_rtsi_direction(dev, dest, COMEDI_OUTPUT);
+		 * ni_set_rtsi_routing(dev, dest, reg);
+		 */
+	} else if (channel_is_ctr(CR_CHAN(dest))) {
+		/*
+		 * we are adding back the channel modifier info to set
+		 * invert/edge info passed by the user
+		 */
+		ni_tio_set_routing(devpriv-&gt;counter_dev, dest,
+				   reg | (src &amp; ~CR_CHAN(-1)));
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static inline int disconnect_route(unsigned int src, unsigned int dest,
+				   struct comedi_device *dev)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+	s8 reg = ni_route_to_register(CR_CHAN(src), CR_CHAN(dest),
+				      &amp;devpriv-&gt;routing_tables);
+
+	if (reg &lt; 0)
+		/* route is not valid */
+		return -EINVAL;
+	if (get_output_select_source(dest, dev) != CR_CHAN(src))
+		/* cannot disconnect something not connected */
+		return -EINVAL;
+
+	/* The route is valid and is connected.  Now disconnect... */
+	if (channel_is_pfi(CR_CHAN(dest))) {
+		unsigned int source = ((CR_CHAN(dest) - NI_PFI(0)) &lt; 8)
+					? NI_660X_PFI_OUTPUT_DIO
+					: NI_660X_PFI_OUTPUT_COUNTER;
+
+		/* set the pfi to high impedance, and disconnect */
+		ni_660x_set_pfi_direction(dev, dest, COMEDI_INPUT);
+		ni_660x_set_pfi_routing(dev, dest, source);
+	} else if (channel_is_rtsi(CR_CHAN(dest))) {
+		dev_dbg(dev-&gt;class_dev, "%s: unhandled rtsi destination (%d)\n",
+			__func__, dest);
+		return -EINVAL;
+		/*
+		 * The following can be enabled when RTSI routing info is
+		 * determined (not currently documented):
+		 * if (reg == NI_RTSI_OUTPUT_RGOUT0) {
+		 *	int ret = decr_rgout0_src_use(src, dev);
+
+		 *	if (ret &lt; 0)
+		 *		return ret;
+		 * } else if (ni_rtsi_route_requires_mux(reg)) {
+		 *	** find which RTSI_BRD line is source for rtsi pin **
+		 *	int brd = ni_find_route_source(
+		 *		ni_get_rtsi_routing(dev, dest), CR_CHAN(dest),
+		 *		&amp;devpriv-&gt;routing_tables);
+
+		 *	if (brd &lt; 0)
+		 *		return brd;
+
+		 *	** decrement/disconnect RTSI_BRD line from source **
+		 *	decr_rtsi_brd_src_use(src, brd, dev);
+		 * }
+
+		 * ** set rtsi output selector to default state **
+		 * reg = default_rtsi_routing[CR_CHAN(dest) - TRIGGER_LINE(0)];
+		 * ni_set_rtsi_direction(dev, dest, COMEDI_INPUT);
+		 * ni_set_rtsi_routing(dev, dest, reg);
+		 */
+	} else if (channel_is_ctr(CR_CHAN(dest))) {
+		ni_tio_unset_routing(devpriv-&gt;counter_dev, dest);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ni_global_insn_config(struct comedi_device *dev,
+				 struct comedi_insn *insn,
+				 unsigned int *data)
+{
+	switch (data[0]) {
+	case INSN_DEVICE_CONFIG_TEST_ROUTE:
+		data[0] = test_route(data[1], data[2], dev);
+		return 2;
+	case INSN_DEVICE_CONFIG_CONNECT_ROUTE:
+		return connect_route(data[1], data[2], dev);
+	case INSN_DEVICE_CONFIG_DISCONNECT_ROUTE:
+		return disconnect_route(data[1], data[2], dev);
+	/*
+	 * This case is already handled one level up.
+	 * case INSN_DEVICE_CONFIG_GET_ROUTES:
+	 */
+	default:
+		return -EINVAL;
+	}
+	return 1;
+}
+
 static void ni_660x_init_tio_chips(struct comedi_device *dev,
 				   unsigned int n_chips)
 {
@@ -784,6 +1042,13 @@ static int ni_660x_auto_attach(struct comedi_device *dev,
 			 __func__, board-&gt;name);
 		dev_warn(dev-&gt;class_dev, "%s: High level NI signal names will not be available for this %s board.\n",
 			 __func__, board-&gt;name);
+	} else {
+		/*
+		 * only(?) assign insn_device_config if we have global names for
+		 * this device.
+		 */
+		dev-&gt;insn_device_config = ni_global_insn_config;
+		dev-&gt;get_valid_routes = _ni_get_valid_routes;
 	}
 
 	n_counters = board-&gt;n_chips * NI660X_COUNTERS_PER_CHIP;</pre><hr><pre>commit a0c5e8460011506978c833d72496ce0147d82b2f
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Oct 3 14:56:11 2018 -0600

    staging: comedi: ni_660x: clean up pfi routing
    
    Cleans up the pfi routing code to make it easier to follow, read, and also
    to prepare to use this cleaned up code for enabling the device-global
    routing interface for ni_660x devices.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_660x.c b/drivers/staging/comedi/drivers/ni_660x.c
index 0dfaf8ed093d..59055f366138 100644
--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -596,6 +596,37 @@ static void ni_660x_select_pfi_output(struct comedi_device *dev,
 	ni_660x_write(dev, active_chip, bits, NI660X_IO_CFG(chan));
 }
 
+static void ni_660x_set_pfi_direction(struct comedi_device *dev,
+				      unsigned int chan,
+				      unsigned int direction)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+	u64 bit;
+
+	bit = 1ULL &lt;&lt; chan;
+
+	if (direction == COMEDI_OUTPUT) {
+		devpriv-&gt;io_dir |= bit;
+		/* reset the output to currently assigned output value */
+		ni_660x_select_pfi_output(dev, chan, devpriv-&gt;io_cfg[chan]);
+	} else {
+		devpriv-&gt;io_dir &amp;= ~bit;
+		/* set pin to high-z; do not change currently assigned route */
+		ni_660x_select_pfi_output(dev, chan, 0);
+	}
+}
+
+static unsigned int ni_660x_get_pfi_direction(struct comedi_device *dev,
+					      unsigned int chan)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+	u64 bit;
+
+	bit = 1ULL &lt;&lt; chan;
+
+	return (devpriv-&gt;io_dir &amp; bit) ? COMEDI_OUTPUT : COMEDI_INPUT;
+}
+
 static int ni_660x_set_pfi_routing(struct comedi_device *dev,
 				   unsigned int chan, unsigned int source)
 {
@@ -614,36 +645,48 @@ static int ni_660x_set_pfi_routing(struct comedi_device *dev,
 	}
 
 	devpriv-&gt;io_cfg[chan] = source;
-	if (devpriv-&gt;io_dir &amp; (1ULL &lt;&lt; chan))
+	if (ni_660x_get_pfi_direction(dev, chan) == COMEDI_OUTPUT)
 		ni_660x_select_pfi_output(dev, chan, devpriv-&gt;io_cfg[chan]);
 	return 0;
 }
 
+static int ni_660x_get_pfi_routing(struct comedi_device *dev, unsigned int chan)
+{
+	struct ni_660x_private *devpriv = dev-&gt;private;
+
+	return devpriv-&gt;io_cfg[chan];
+}
+
+static void ni_660x_set_pfi_filter(struct comedi_device *dev,
+				   unsigned int chan, unsigned int value)
+{
+	unsigned int val;
+
+	val = ni_660x_read(dev, 0, NI660X_IO_CFG(chan));
+	val &amp;= ~NI660X_IO_CFG_IN_SEL_MASK(chan);
+	val |= NI660X_IO_CFG_IN_SEL(chan, value);
+	ni_660x_write(dev, 0, val, NI660X_IO_CFG(chan));
+}
+
 static int ni_660x_dio_insn_config(struct comedi_device *dev,
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
 {
-	struct ni_660x_private *devpriv = dev-&gt;private;
 	unsigned int chan = CR_CHAN(insn-&gt;chanspec);
-	u64 bit = 1ULL &lt;&lt; chan;
-	unsigned int val;
 	int ret;
 
 	switch (data[0]) {
 	case INSN_CONFIG_DIO_OUTPUT:
-		devpriv-&gt;io_dir |= bit;
-		ni_660x_select_pfi_output(dev, chan, devpriv-&gt;io_cfg[chan]);
+		ni_660x_set_pfi_direction(dev, chan, COMEDI_OUTPUT);
 		break;
 
 	case INSN_CONFIG_DIO_INPUT:
-		devpriv-&gt;io_dir &amp;= ~bit;
-		ni_660x_select_pfi_output(dev, chan, 0);	/* high-z */
+		ni_660x_set_pfi_direction(dev, chan, COMEDI_INPUT);
 		break;
 
 	case INSN_CONFIG_DIO_QUERY:
-		data[1] = (devpriv-&gt;io_dir &amp; bit) ? COMEDI_OUTPUT
-						  : COMEDI_INPUT;
+		data[1] = ni_660x_get_pfi_direction(dev, chan);
 		break;
 
 	case INSN_CONFIG_SET_ROUTING:
@@ -653,14 +696,11 @@ static int ni_660x_dio_insn_config(struct comedi_device *dev,
 		break;
 
 	case INSN_CONFIG_GET_ROUTING:
-		data[1] = devpriv-&gt;io_cfg[chan];
+		data[1] = ni_660x_get_pfi_routing(dev, chan);
 		break;
 
 	case INSN_CONFIG_FILTER:
-		val = ni_660x_read(dev, 0, NI660X_IO_CFG(chan));
-		val &amp;= ~NI660X_IO_CFG_IN_SEL_MASK(chan);
-		val |= NI660X_IO_CFG_IN_SEL(chan, data[1]);
-		ni_660x_write(dev, 0, val, NI660X_IO_CFG(chan));
+		ni_660x_set_pfi_filter(dev, chan, data[1]);
 		break;
 
 	default:
@@ -840,7 +880,7 @@ static int ni_660x_auto_attach(struct comedi_device *dev,
 					      : NI_660X_PFI_OUTPUT_COUNTER;
 
 		ni_660x_set_pfi_routing(dev, i, source);
-		ni_660x_select_pfi_output(dev, i, 0);		/* high-z */
+		ni_660x_set_pfi_direction(dev, i, COMEDI_INPUT);/* high-z */
 	}
 
 	/* Counter subdevices (4 NI TIO General Purpose Counters per chip) */</pre><hr><pre>commit 51c4ba6407ef9f5735bc6bf566211bb839892e4b
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Oct 3 14:56:10 2018 -0600

    staging: comedi: ni_660x: Add NI PCI-6608 to list of supported devices
    
    Previously, only the PXI version of the NI-6608 board was supported.  This
    change adds support for the PCI version as well.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_660x.c b/drivers/staging/comedi/drivers/ni_660x.c
index 498b2868c957..0dfaf8ed093d 100644
--- a/drivers/staging/comedi/drivers/ni_660x.c
+++ b/drivers/staging/comedi/drivers/ni_660x.c
@@ -7,7 +7,7 @@
  * Driver: ni_660x
  * Description: National Instruments 660x counter/timer boards
  * Devices: [National Instruments] PCI-6601 (ni_660x), PCI-6602, PXI-6602,
- *   PXI-6608, PCI-6624, PXI-6624
+ *   PCI-6608, PXI-6608, PCI-6624, PXI-6624
  * Author: J.P. Mellor &lt;jpmellor@rose-hulman.edu&gt;,
  *   Herman.Bruyninckx@mech.kuleuven.ac.be,
  *   Wim.Meeussen@mech.kuleuven.ac.be,
@@ -202,6 +202,7 @@ enum ni_660x_boardid {
 	BOARD_PCI6601,
 	BOARD_PCI6602,
 	BOARD_PXI6602,
+	BOARD_PCI6608,
 	BOARD_PXI6608,
 	BOARD_PCI6624,
 	BOARD_PXI6624
@@ -225,6 +226,10 @@ static const struct ni_660x_board ni_660x_boards[] = {
 		.name		= "PXI-6602",
 		.n_chips	= 2,
 	},
+	[BOARD_PCI6608] = {
+		.name		= "PCI-6608",
+		.n_chips	= 2,
+	},
 	[BOARD_PXI6608] = {
 		.name		= "PXI-6608",
 		.n_chips	= 2,
@@ -925,6 +930,7 @@ static const struct pci_device_id ni_660x_pci_table[] = {
 	{ PCI_VDEVICE(NI, 0x1310), BOARD_PCI6602 },
 	{ PCI_VDEVICE(NI, 0x1360), BOARD_PXI6602 },
 	{ PCI_VDEVICE(NI, 0x2c60), BOARD_PCI6601 },
+	{ PCI_VDEVICE(NI, 0x2db0), BOARD_PCI6608 },
 	{ PCI_VDEVICE(NI, 0x2cc0), BOARD_PXI6608 },
 	{ PCI_VDEVICE(NI, 0x1e30), BOARD_PCI6624 },
 	{ PCI_VDEVICE(NI, 0x1e40), BOARD_PXI6624 },</pre><hr><pre>commit 713ebc593978e67d9e6d708f34fa6c66470be536
Author: Spencer E. Olson &lt;olsonse@umich.edu&gt;
Date:   Wed Oct 3 14:56:09 2018 -0600

    staging: comedi: ni_mio_common: create device-global access to tio
    
    Adds tio sub-devices of ni_mio_common supported hardware to the
    implementation of test_route, connect_route, disconnect_route.  This change
    delegates the actual functionality to the ni_tio module.
    
    Signed-off-by: Spencer E. Olson &lt;olsonse@umich.edu&gt;
    Reviewed-by: Ian Abbott &lt;abbotti@mev.co.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c
index addea2446197..2d1e0325d04d 100644
--- a/drivers/staging/comedi/drivers/ni_mio_common.c
+++ b/drivers/staging/comedi/drivers/ni_mio_common.c
@@ -5644,6 +5644,8 @@ static int get_output_select_source(int dest, struct comedi_device *dev)
 			/* there are only two g_out outputs. */
 			return -EINVAL;
 		reg = ni_get_gout_routing(dest, dev);
+	} else if (channel_is_ctr(dest)) {
+		reg = ni_tio_get_routing(devpriv-&gt;counter_dev, dest);
 	} else {
 		dev_dbg(dev-&gt;class_dev, "%s: unhandled destination (%d) queried\n",
 			__func__, dest);
@@ -5732,6 +5734,13 @@ static int connect_route(unsigned int src, unsigned int dest,
 			return -EINVAL;
 		if (ni_set_gout_routing(src, dest, dev))
 			return -EINVAL;
+	} else if (channel_is_ctr(dest)) {
+		/*
+		 * we are adding back the channel modifier info to set
+		 * invert/edge info passed by the user
+		 */
+		ni_tio_set_routing(devpriv-&gt;counter_dev, dest,
+				   reg | (src &amp; ~CR_CHAN(-1)));
 	} else {
 		return -EINVAL;
 	}
@@ -5790,6 +5799,8 @@ static int disconnect_route(unsigned int src, unsigned int dest,
 			/* there are only two g_out outputs. */
 			return -EINVAL;
 		reg = ni_disable_gout_routing(dest, dev);
+	} else if (channel_is_ctr(dest)) {
+		ni_tio_unset_routing(devpriv-&gt;counter_dev, dest);
 	} else {
 		return -EINVAL;
 	}</pre>
    <div class="pagination">
        <span>[1]</span><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_2.html'>Next&gt;&gt;</a>
    <div>
</body>
