<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_114.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><span>[115]</span><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_116.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1737bf2c5e78e331ad0a30b8c34edd1016d043c0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 15 16:04:52 2006 -0500

    usbcore: remove unneeded error check
    
    This patch (as830) removes some unnecessary error checking.  According
    to the kerneldoc, schedule_work() can't fail.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 149aa8bfb1fe..8aca3574c2b5 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1545,11 +1545,7 @@ int usb_driver_set_configuration(struct usb_device *udev, int config)
 	INIT_WORK(&amp;req-&gt;work, driver_set_config_work);
 
 	usb_get_dev(udev);
-	if (!schedule_work(&amp;req-&gt;work)) {
-		usb_put_dev(udev);
-		kfree(req);
-		return -EINVAL;
-	}
+	schedule_work(&amp;req-&gt;work);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(usb_driver_set_configuration);</pre><hr><pre>commit 25c77b329467d563ec1fa5c3efab0b13996ce810
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 15 16:08:13 2006 -0500

    UHCI: support device_may_wakeup
    
    This patch (as831) adds device_may_wakeup() support to uhci-hcd; it
    has been lacking for a long time.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fecc8c971c17..e0d4c2358b39 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -257,7 +257,9 @@ __acquires(uhci-&gt;lock)
 	int_enable = USBINTR_RESUME;
 	if (remote_wakeup_is_broken(uhci))
 		egsm_enable = 0;
-	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable)
+	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable ||
+			!device_may_wakeup(
+				&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev))
 		uhci-&gt;working_RD = int_enable = 0;
 
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);</pre><hr><pre>commit c80a70d53fa0ca47ad122cd75fe32b6f41c04eb1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 15 16:06:25 2006 -0500

    UHCI: make test for ASUS motherboard more specific
    
    Instead of matching all motherboards whose name contains "A7V8X" for a
    remote-wakeup hardware bug, this patch (as829) matches only those
    boards whose name is exactly equal to "A7V8X".  Later motherboards
    don't seem to have the bug.
    
    (In fact, it's possible that only one motherboard in the world has the
    bug.  With only one user reporting problems, it's hard to tell.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index acd101caeeeb..fecc8c971c17 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -209,24 +209,16 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 
 static int remote_wakeup_is_broken(struct uhci_hcd *uhci)
 {
-	static struct dmi_system_id broken_wakeup_table[] = {
-		{
-			.ident = "Asus A7V8X",
-			.matches = {
-				DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK"),
-				DMI_MATCH(DMI_BOARD_NAME, "A7V8X"),
-				DMI_MATCH(DMI_BOARD_VERSION, "REV 1.xx"),
-			}
-		},
-		{ }
-	};
 	int port;
+	char *sys_info;
+	static char bad_Asus_board[] = "A7V8X";
 
 	/* One of Asus's motherboards has a bug which causes it to
 	 * wake up immediately from suspend-to-RAM if any of the ports
 	 * are connected.  In such cases we will not set EGSM.
 	 */
-	if (dmi_check_system(broken_wakeup_table)) {
+	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
+	if (sys_info &amp;&amp; !strcmp(sys_info, bad_Asus_board)) {
 		for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
 			if (inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp;
 					USBPORTSC_CCS)</pre><hr><pre>commit 5f8364b7d63acdc2216ca0f7d0a8557c318479ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 5 16:29:55 2006 -0500

    UHCI: module parameter to ignore overcurrent changes
    
    Certain boards seem to like to issue false overcurrent notifications,
    for example on ports that don't have anything connected to them.  This
    looks like a hardware error, at the level of noise to those ports'
    overcurrent input signals (or non-debounced VBUS comparators).  This
    surfaces to users as truly massive amounts of syslog spam from khubd
    (which is appropriate for real hardware problems, except for the
    volume from multiple ports).
    
    Using this new "ignore_oc" flag helps such systems work more sanely,
    by preventing such indications from getting to khubd (and spamming
    syslog).  The downside is of course that true overcurrent errors will
    be masked; they'll appear as spontaneous disconnects, without the
    diagnostics that will let users troubleshoot issues like
    short-circuited cables.  In addition, controllers with no devices
    attached will be forced to poll for new devices rather than relying on
    interrupts, since each overcurrent event would generate a new
    interrupt.
    
    This patch (as826) is essentially a copy of David Brownell's ignore_oc
    patch for ehci-hcd, ported to uhci-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index ef69c75780bf..25d298517104 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1714,6 +1714,14 @@ and is between 256 and 4096 characters. It is defined in the file
 	uart6850=	[HW,OSS]
 			Format: &lt;io&gt;,&lt;irq&gt;
 
+	uhci-hcd.ignore_oc=
+			[USB] Ignore overcurrent events (default N).
+			Some badly-designed motherboards generate lots of
+			bogus events, for ports that aren't wired to
+			anything.  Set this parameter to avoid log spamming.
+			Note that genuine overcurrent events won't be
+			reported either.
+
 	usbhid.mousepoll=
 			[USBHID] The interval which mice are to be polled at.
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index e87692c31be4..acd101caeeeb 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -60,6 +60,11 @@ Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
 Alan Stern"
 #define DRIVER_DESC "USB Universal Host Controller Interface driver"
 
+/* for flakey hardware, ignore overcurrent indicators */
+static int ignore_oc;
+module_param(ignore_oc, bool, S_IRUGO);
+MODULE_PARM_DESC(ignore_oc, "ignore hardware overcurrent indications");
+
 /*
  * debug = 0, no debugging messages
  * debug = 1, dump failed URBs except for stalls
@@ -169,6 +174,11 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 {
 	int port;
 
+	/* If we have to ignore overcurrent events then almost by definition
+	 * we can't depend on resume-detect interrupts. */
+	if (ignore_oc)
+		return 1;
+
 	switch (to_pci_dev(uhci_dev(uhci))-&gt;vendor) {
 	    default:
 		break;
@@ -921,7 +931,8 @@ static int __init uhci_hcd_init(void)
 {
 	int retval = -ENOMEM;
 
-	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "\n");
+	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "%s\n",
+			ignore_oc ? ", overcurrent ignored" : "");
 
 	if (usb_disabled())
 		return -ENODEV;
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index f8347f1a10b6..bacc25c53ba3 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -52,10 +52,20 @@ static int any_ports_active(struct uhci_hcd *uhci)
 static inline int get_hub_status_data(struct uhci_hcd *uhci, char *buf)
 {
 	int port;
+	int mask = RWC_BITS;
+
+	/* Some boards (both VIA and Intel apparently) report bogus
+	 * overcurrent indications, causing massive log spam unless
+	 * we completely ignore them.  This doesn't seem to be a problem
+	 * with the chipset so much as with the way it is connected on
+	 * the motherboard; if the overcurrent input is left to float
+	 * then it may constantly register false positives. */
+	if (ignore_oc)
+		mask &amp;= ~USBPORTSC_OCC;
 
 	*buf = 0;
 	for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
-		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; RWC_BITS) ||
+		if ((inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp; mask) ||
 				test_bit(port, &amp;uhci-&gt;port_c_suspend))
 			*buf |= (1 &lt;&lt; (port + 1));
 	}
@@ -263,7 +273,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			wPortChange |= USB_PORT_STAT_C_CONNECTION;
 		if (status &amp; USBPORTSC_PEC)
 			wPortChange |= USB_PORT_STAT_C_ENABLE;
-		if (status &amp; USBPORTSC_OCC)
+		if ((status &amp; USBPORTSC_OCC) &amp;&amp; !ignore_oc)
 			wPortChange |= USB_PORT_STAT_C_OVERCURRENT;
 
 		if (test_bit(port, &amp;uhci-&gt;port_c_suspend)) {</pre><hr><pre>commit a120586873d3d64de93bd6d593d237e131994e58
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 6 20:32:37 2006 -0800

    [PATCH] Allow NULL pointers in percpu_free
    
    The patch (as824b) makes percpu_free() ignore NULL arguments, as one would
    expect for a deallocation routine.  (Note that free_percpu is #defined as
    percpu_free in include/linux/percpu.h.) A few callers are updated to remove
    now-unneeded tests for NULL.  A few other callers already seem to assume
    that passing a NULL pointer to percpu_free() is okay!
    
    The patch also removes an unnecessary NULL check in percpu_depopulate().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/arch/i386/kernel/acpi/cstate.c b/arch/i386/kernel/acpi/cstate.c
index 4664b55f623e..12e937c1ce4b 100644
--- a/arch/i386/kernel/acpi/cstate.c
+++ b/arch/i386/kernel/acpi/cstate.c
@@ -156,10 +156,8 @@ static int __init ffh_cstate_init(void)
 
 static void __exit ffh_cstate_exit(void)
 {
-	if (cpu_cstate_entry) {
-		free_percpu(cpu_cstate_entry);
-		cpu_cstate_entry = NULL;
-	}
+	free_percpu(cpu_cstate_entry);
+	cpu_cstate_entry = NULL;
 }
 
 arch_initcall(ffh_cstate_init);
diff --git a/block/blktrace.c b/block/blktrace.c
index 74e02c04b2da..d3679dd1d220 100644
--- a/block/blktrace.c
+++ b/block/blktrace.c
@@ -394,8 +394,7 @@ static int blk_trace_setup(request_queue_t *q, struct block_device *bdev,
 	if (bt) {
 		if (bt-&gt;dropped_file)
 			debugfs_remove(bt-&gt;dropped_file);
-		if (bt-&gt;sequence)
-			free_percpu(bt-&gt;sequence);
+		free_percpu(bt-&gt;sequence);
 		if (bt-&gt;rchan)
 			relay_close(bt-&gt;rchan);
 		kfree(bt);
diff --git a/mm/allocpercpu.c b/mm/allocpercpu.c
index eaa9abeea536..b2486cf887a0 100644
--- a/mm/allocpercpu.c
+++ b/mm/allocpercpu.c
@@ -17,10 +17,9 @@
 void percpu_depopulate(void *__pdata, int cpu)
 {
 	struct percpu_data *pdata = __percpu_disguise(__pdata);
-	if (pdata-&gt;ptrs[cpu]) {
-		kfree(pdata-&gt;ptrs[cpu]);
-		pdata-&gt;ptrs[cpu] = NULL;
-	}
+
+	kfree(pdata-&gt;ptrs[cpu]);
+	pdata-&gt;ptrs[cpu] = NULL;
 }
 EXPORT_SYMBOL_GPL(percpu_depopulate);
 
@@ -123,6 +122,8 @@ EXPORT_SYMBOL_GPL(__percpu_alloc_mask);
  */
 void percpu_free(void *__pdata)
 {
+	if (unlikely(!__pdata))
+		return;
 	__percpu_depopulate_mask(__pdata, &amp;cpu_possible_map);
 	kfree(__percpu_disguise(__pdata));
 }
diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c
index 87c8f54872b7..e5cd83b2205d 100644
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@ -720,10 +720,8 @@ snmp6_mib_free(void *ptr[2])
 {
 	if (ptr == NULL)
 		return;
-	if (ptr[0])
-		free_percpu(ptr[0]);
-	if (ptr[1])
-		free_percpu(ptr[1]);
+	free_percpu(ptr[0]);
+	free_percpu(ptr[1]);
 	ptr[0] = ptr[1] = NULL;
 }
 </pre><hr><pre>commit 94fcda1f8ab5e0cacc381c5ca1cc9aa6ad523576
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:38:46 2006 -0500

    usbcore: remove unused argument in autosuspend
    
    Thanks to several earlier patches, usb_autosuspend_device() and
    usb_autoresume_device() are never called with a second argument other
    than 1.  This patch (as819) removes the now-redundant argument.
    
    It also consolidates some common code between those two routines,
    putting it into a new subroutine called usb_autopm_do_device().  And
    it includes a sizable kerneldoc update for the affected functions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index fed92be63b5e..3ed4cb2d56d9 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -561,7 +561,7 @@ static int usbdev_open(struct inode *inode, struct file *file)
 		dev = inode-&gt;i_private;
 	if (!dev)
 		goto out;
-	ret = usb_autoresume_device(dev, 1);
+	ret = usb_autoresume_device(dev);
 	if (ret)
 		goto out;
 
@@ -609,7 +609,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 			releaseintf(ps, ifnum);
 	}
 	destroy_all_async(ps);
-	usb_autosuspend_device(dev, 1);
+	usb_autosuspend_device(dev);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
 	put_pid(ps-&gt;disc_pid);
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 0fa15bd62c48..d6eb5ce1dd1d 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -205,7 +205,7 @@ static int usb_probe_interface(struct device *dev)
 	if (id) {
 		dev_dbg(dev, "%s - got id\n", __FUNCTION__);
 
-		error = usb_autoresume_device(udev, 1);
+		error = usb_autoresume_device(udev);
 		if (error)
 			return error;
 
@@ -229,7 +229,7 @@ static int usb_probe_interface(struct device *dev)
 		} else
 			intf-&gt;condition = USB_INTERFACE_BOUND;
 
-		usb_autosuspend_device(udev, 1);
+		usb_autosuspend_device(udev);
 	}
 
 	return error;
@@ -247,7 +247,7 @@ static int usb_unbind_interface(struct device *dev)
 
 	/* Autoresume for set_interface call below */
 	udev = interface_to_usbdev(intf);
-	error = usb_autoresume_device(udev, 1);
+	error = usb_autoresume_device(udev);
 
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
@@ -265,7 +265,7 @@ static int usb_unbind_interface(struct device *dev)
 	intf-&gt;needs_remote_wakeup = 0;
 
 	if (!error)
-		usb_autosuspend_device(udev, 1);
+		usb_autosuspend_device(udev);
 
 	return 0;
 }
@@ -940,6 +940,8 @@ static int usb_resume_interface(struct usb_interface *intf)
 	return status;
 }
 
+#ifdef	CONFIG_USB_SUSPEND
+
 /* Internal routine to check whether we may autosuspend a device. */
 static int autosuspend_check(struct usb_device *udev)
 {
@@ -970,6 +972,12 @@ static int autosuspend_check(struct usb_device *udev)
 	return 0;
 }
 
+#else
+
+#define autosuspend_check(udev)		0
+
+#endif
+
 /**
  * usb_suspend_both - suspend a USB device and its interfaces
  * @udev: the usb_device to suspend
@@ -1048,7 +1056,7 @@ int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	/* If the suspend succeeded, propagate it up the tree */
 	} else if (parent)
-		usb_autosuspend_device(parent, 1);
+		usb_autosuspend_device(parent);
 
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
@@ -1096,11 +1104,11 @@ int usb_resume_both(struct usb_device *udev)
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		if (parent) {
-			status = usb_autoresume_device(parent, 1);
+			status = usb_autoresume_device(parent);
 			if (status == 0) {
 				status = usb_resume_device(udev);
 				if (status) {
-					usb_autosuspend_device(parent, 1);
+					usb_autosuspend_device(parent);
 
 					/* It's possible usb_resume_device()
 					 * failed after the port was
@@ -1146,39 +1154,53 @@ int usb_resume_both(struct usb_device *udev)
 
 #ifdef CONFIG_USB_SUSPEND
 
+/* Internal routine to adjust a device's usage counter and change
+ * its autosuspend state.
+ */
+static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
+{
+	int	status = 0;
+
+	usb_pm_lock(udev);
+	udev-&gt;pm_usage_cnt += inc_usage_cnt;
+	WARN_ON(udev-&gt;pm_usage_cnt &lt; 0);
+	if (inc_usage_cnt &gt;= 0 &amp;&amp; udev-&gt;pm_usage_cnt &gt; 0) {
+		udev-&gt;auto_pm = 1;
+		status = usb_resume_both(udev);
+		if (status != 0)
+			udev-&gt;pm_usage_cnt -= inc_usage_cnt;
+	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
+		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
+				USB_AUTOSUSPEND_DELAY);
+	usb_pm_unlock(udev);
+	return status;
+}
+
 /**
  * usb_autosuspend_device - delayed autosuspend of a USB device and its interfaces
  * @udev: the usb_device to autosuspend
- * @dec_usage_cnt: flag to decrement @udev's PM-usage counter
  *
  * This routine should be called when a core subsystem is finished using
  * @udev and wants to allow it to autosuspend.  Examples would be when
  * @udev's device file in usbfs is closed or after a configuration change.
  *
- * @dec_usage_cnt should be 1 if the subsystem previously incremented
- * @udev's usage counter (such as by passing 1 to usb_autoresume_device);
- * otherwise it should be 0.
- *
- * If the usage counter for @udev or any of its active interfaces is greater
- * than 0, the autosuspend request will not be queued.  (If an interface
- * driver does not support autosuspend then its usage counter is permanently
- * positive.)  Likewise, if an interface driver requires remote-wakeup
- * capability during autosuspend but remote wakeup is disabled, the
- * autosuspend will fail.
+ * @udev's usage counter is decremented.  If it or any of the usage counters
+ * for an active interface is greater than 0, no autosuspend request will be
+ * queued.  (If an interface driver does not support autosuspend then its
+ * usage counter is permanently positive.)  Furthermore, if an interface
+ * driver requires remote-wakeup capability during autosuspend but remote
+ * wakeup is disabled, the autosuspend will fail.
  *
  * Often the caller will hold @udev's device lock, but this is not
  * necessary.
  *
  * This routine can run only in process context.
  */
-void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
+void usb_autosuspend_device(struct usb_device *udev)
 {
-	usb_pm_lock(udev);
-	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
-	if (autosuspend_check(udev) == 0)
-		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				USB_AUTOSUSPEND_DELAY);
-	usb_pm_unlock(udev);
+	int	status;
+
+	status = usb_autopm_do_device(udev, -1);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
 	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
@@ -1186,39 +1208,27 @@ void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 /**
  * usb_autoresume_device - immediately autoresume a USB device and its interfaces
  * @udev: the usb_device to autoresume
- * @inc_usage_cnt: flag to increment @udev's PM-usage counter
  *
  * This routine should be called when a core subsystem wants to use @udev
- * and needs to guarantee that it is not suspended.  In addition, the
- * caller can prevent @udev from being autosuspended subsequently.  (Note
- * that this will not prevent suspend events originating in the PM core.)
- * Examples would be when @udev's device file in usbfs is opened (autosuspend
- * should be prevented until the file is closed) or when a remote-wakeup
- * request is received (later autosuspends should not be prevented).
+ * and needs to guarantee that it is not suspended.  No autosuspend will
+ * occur until usb_autosuspend_device is called.  (Note that this will not
+ * prevent suspend events originating in the PM core.)  Examples would be
+ * when @udev's device file in usbfs is opened or when a remote-wakeup
+ * request is received.
  *
- * @inc_usage_cnt should be 1 to increment @udev's usage counter and prevent
- * autosuspends.  This prevention will persist until the usage counter is
- * decremented again (such as by passing 1 to usb_autosuspend_device).
- * Otherwise @inc_usage_cnt should be 0 to leave the usage counter unchanged.
- * Regardless, if the autoresume fails then the usage counter is not
- * incremented.
+ * @udev's usage counter is incremented to prevent subsequent autosuspends.
+ * However if the autoresume fails then the usage counter is re-decremented.
  *
  * Often the caller will hold @udev's device lock, but this is not
  * necessary (and attempting it might cause deadlock).
  *
  * This routine can run only in process context.
  */
-int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
+int usb_autoresume_device(struct usb_device *udev)
 {
 	int	status;
 
-	usb_pm_lock(udev);
-	udev-&gt;pm_usage_cnt += inc_usage_cnt;
-	udev-&gt;auto_pm = 1;
-	status = usb_resume_both(udev);
-	if (status != 0)
-		udev-&gt;pm_usage_cnt -= inc_usage_cnt;
-	usb_pm_unlock(udev);
+	status = usb_autopm_do_device(udev, 1);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
 	return status;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index e46d38b18249..0ce393eb3c4b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1234,7 +1234,7 @@ void usb_disconnect(struct usb_device **pdev)
 	if (udev-&gt;parent) {
 		usb_pm_lock(udev);
 		if (!udev-&gt;discon_suspended)
-			usb_autosuspend_device(udev-&gt;parent, 1);
+			usb_autosuspend_device(udev-&gt;parent);
 		usb_pm_unlock(udev);
 	}
 
@@ -1368,7 +1368,7 @@ static int __usb_new_device(void *void_data)
 
 	/* Increment the parent's count of unsuspended children */
 	if (udev-&gt;parent)
-		usb_autoresume_device(udev-&gt;parent, 1);
+		usb_autoresume_device(udev-&gt;parent);
 
 exit:
 	module_put(THIS_MODULE);
@@ -1881,12 +1881,12 @@ static int remote_wakeup(struct usb_device *udev)
 	usb_lock_device(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
-		status = usb_autoresume_device(udev, 1);
+		status = usb_autoresume_device(udev);
 
 		/* Give the interface drivers a chance to do something,
 		 * then autosuspend the device again. */
 		if (status == 0)
-			usb_autosuspend_device(udev, 1);
+			usb_autosuspend_device(udev);
 	}
 	usb_unlock_device(udev);
 	return status;
@@ -3099,7 +3099,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 	}
 
 	/* Prevent autosuspend during the reset */
-	usb_autoresume_device(udev, 1);
+	usb_autoresume_device(udev);
 
 	if (iface &amp;&amp; iface-&gt;condition != USB_INTERFACE_BINDING)
 		iface = NULL;
@@ -3142,7 +3142,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 		}
 	}
 
-	usb_autosuspend_device(udev, 1);
+	usb_autosuspend_device(udev);
 	return ret;
 }
 EXPORT_SYMBOL(usb_reset_composite_device);
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 5684d8722922..29b0fa9ff9d0 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1398,7 +1398,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	}
 
 	/* Wake up the device so we can send it the Set-Config request */
-	ret = usb_autoresume_device(dev, 1);
+	ret = usb_autoresume_device(dev);
 	if (ret)
 		goto free_interfaces;
 
@@ -1421,7 +1421,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	dev-&gt;actconfig = cp;
 	if (!cp) {
 		usb_set_device_state(dev, USB_STATE_ADDRESS);
-		usb_autosuspend_device(dev, 1);
+		usb_autosuspend_device(dev);
 		goto free_interfaces;
 	}
 	usb_set_device_state(dev, USB_STATE_CONFIGURED);
@@ -1490,7 +1490,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		usb_create_sysfs_intf_files (intf);
 	}
 
-	usb_autosuspend_device(dev, 1);
+	usb_autosuspend_device(dev);
 	return 0;
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 13322e33f912..17830a81be14 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -64,14 +64,13 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #define USB_AUTOSUSPEND_DELAY	(HZ*2)
 
-extern void usb_autosuspend_device(struct usb_device *udev, int dec_busy_cnt);
-extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
+extern void usb_autosuspend_device(struct usb_device *udev);
+extern int usb_autoresume_device(struct usb_device *udev);
 
 #else
 
-#define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
-static inline int usb_autoresume_device(struct usb_device *udev,
-		int inc_busy_cnt)
+#define usb_autosuspend_device(udev)	do {} while (0)
+static inline int usb_autoresume_device(struct usb_device *udev)
 {
 	return 0;
 }</pre><hr><pre>commit ee49fb5dc89d34f1794ac9362fa97c1a640f7ddd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 22 16:55:54 2006 -0500

    USB: keep count of unsuspended children
    
    This patch (as818b) simplifies autosuspend processing by keeping track
    of the number of unsuspended children of each USB hub.  This will
    permit us to avoid a good deal of unnecessary work all the time; we
    will no longer have to create a bunch of workqueue entries to carry
    out autosuspend requests, only to have them fail because one of the
    hub's children isn't suspended.
    
    The basic idea is simple.  There already is a usage counter in the
    usb_device structure for preventing autosuspends.  The patch just
    increments that counter for every unsuspended child.  There's only one
    tricky part: When a device disconnects we need to remember whether it
    was suspended at the time (leave the counter alone) or not (decrement
    the counter).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 40c1bf09b2b7..0fa15bd62c48 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1048,7 +1048,7 @@ int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	/* If the suspend succeeded, propagate it up the tree */
 	} else if (parent)
-		usb_autosuspend_device(parent, 0);
+		usb_autosuspend_device(parent, 1);
 
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
@@ -1096,9 +1096,25 @@ int usb_resume_both(struct usb_device *udev)
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		if (parent) {
-			usb_pm_lock(parent);
-			parent-&gt;auto_pm = 1;
-			status = usb_resume_both(parent);
+			status = usb_autoresume_device(parent, 1);
+			if (status == 0) {
+				status = usb_resume_device(udev);
+				if (status) {
+					usb_autosuspend_device(parent, 1);
+
+					/* It's possible usb_resume_device()
+					 * failed after the port was
+					 * unsuspended, causing udev to be
+					 * logically disconnected.  We don't
+					 * want usb_disconnect() to autosuspend
+					 * the parent again, so tell it that
+					 * udev disconnected while still
+					 * suspended. */
+					if (udev-&gt;state ==
+							USB_STATE_NOTATTACHED)
+						udev-&gt;discon_suspended = 1;
+				}
+			}
 		} else {
 
 			/* We can't progagate beyond the USB subsystem,
@@ -1107,11 +1123,9 @@ int usb_resume_both(struct usb_device *udev)
 			if (udev-&gt;dev.parent-&gt;power.power_state.event !=
 					PM_EVENT_ON)
 				status = -EHOSTUNREACH;
-		}
-		if (status == 0)
-			status = usb_resume_device(udev);
-		if (parent)
-			usb_pm_unlock(parent);
+			else
+				status = usb_resume_device(udev);
+ 		}
 	} else {
 
 		/* Needed only for setting udev-&gt;dev.power.power_state.event
@@ -1119,8 +1133,6 @@ int usb_resume_both(struct usb_device *udev)
 		status = usb_resume_device(udev);
 	}
 
-	/* Now the parent won't suspend until we are finished */
-
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 46df5e60764b..e46d38b18249 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1039,6 +1039,8 @@ static void recursively_mark_NOTATTACHED(struct usb_device *udev)
 		if (udev-&gt;children[i])
 			recursively_mark_NOTATTACHED(udev-&gt;children[i]);
 	}
+	if (udev-&gt;state == USB_STATE_SUSPENDED)
+		udev-&gt;discon_suspended = 1;
 	udev-&gt;state = USB_STATE_NOTATTACHED;
 }
 
@@ -1228,6 +1230,14 @@ void usb_disconnect(struct usb_device **pdev)
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
+	/* Decrement the parent's count of unsuspended children */
+	if (udev-&gt;parent) {
+		usb_pm_lock(udev);
+		if (!udev-&gt;discon_suspended)
+			usb_autosuspend_device(udev-&gt;parent, 1);
+		usb_pm_unlock(udev);
+	}
+
 	put_device(&amp;udev-&gt;dev);
 }
 
@@ -1356,6 +1366,10 @@ static int __usb_new_device(void *void_data)
 		goto fail;
 	}
 
+	/* Increment the parent's count of unsuspended children */
+	if (udev-&gt;parent)
+		usb_autoresume_device(udev-&gt;parent, 1);
+
 exit:
 	module_put(THIS_MODULE);
 	return err;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5634a2d91ec0..0cd73edeef13 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,6 +362,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
+	unsigned discon_suspended:1;	/* Disconnected while suspended */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 </pre><hr><pre>commit d25450c68767481f7c9cc4823a6da8235db40be6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:14:30 2006 -0500

    USB hub: simplify remote-wakeup handling
    
    This patch (as817) simplifies the remote-wakeup processing in the hub
    driver.  Now instead of using a specialized code path, it relies on
    the standard USB resume routines.  The hub_port_resume() function does
    an initial get_port_status() to see whether the port has already
    resumed itself (as it does when a remote-wakeup request is sent).
    This will slow down handling of other resume events slightly, but not
    enough to matter.
    
    The patch also changes the hub_port_status() routine, making it return
    an error if a short reply is received.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 55812a5ac661..46df5e60764b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1409,10 +1409,12 @@ static int hub_port_status(struct usb_hub *hub, int port1,
 	int ret;
 
 	ret = get_port_status(hub-&gt;hdev, port1, &amp;hub-&gt;status-&gt;port);
-	if (ret &lt; 0)
+	if (ret &lt; 4) {
 		dev_err (hub-&gt;intfdev,
 			"%s failed (err = %d)\n", __FUNCTION__, ret);
-	else {
+		if (ret &gt;= 0)
+			ret = -EIO;
+	} else {
 		*status = le16_to_cpu(hub-&gt;status-&gt;port.wPortStatus);
 		*change = le16_to_cpu(hub-&gt;status-&gt;port.wPortChange); 
 		ret = 0;
@@ -1760,6 +1762,12 @@ static int
 hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 {
 	int	status;
+	u16	portchange, portstatus;
+
+	/* Skip the initial Clear-Suspend step for a remote wakeup */
+	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
+	if (status == 0 &amp;&amp; !(portstatus &amp; USB_PORT_STAT_SUSPEND))
+		goto SuspendCleared;
 
 	// dev_dbg(hub-&gt;intfdev, "resume port %d\n", port1);
 
@@ -1773,9 +1781,6 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			"can't resume port %d, status %d\n",
 			port1, status);
 	} else {
-		u16		devstatus;
-		u16		portchange;
-
 		/* drive resume for at least 20 msec */
 		if (udev)
 			dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
@@ -1790,16 +1795,15 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 		 * stop resume signaling.  Then finish the resume
 		 * sequence.
 		 */
-		devstatus = portchange = 0;
-		status = hub_port_status(hub, port1,
-				&amp;devstatus, &amp;portchange);
+		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
+SuspendCleared:
 		if (status &lt; 0
-				|| (devstatus &amp; LIVE_FLAGS) != LIVE_FLAGS
-				|| (devstatus &amp; USB_PORT_STAT_SUSPEND) != 0
+				|| (portstatus &amp; LIVE_FLAGS) != LIVE_FLAGS
+				|| (portstatus &amp; USB_PORT_STAT_SUSPEND) != 0
 				) {
 			dev_dbg(hub-&gt;intfdev,
 				"port %d status %04x.%04x after resume, %d\n",
-				port1, portchange, devstatus, status);
+				port1, portchange, portstatus, status);
 			if (status &gt;= 0)
 				status = -ENODEV;
 		} else {
@@ -1860,23 +1864,16 @@ static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* All this just to avoid sending a port-resume message
-	 * to the parent hub! */
-
 	usb_lock_device(udev);
-	usb_pm_lock(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
-		/* TRSMRCY = 10 msec */
-		msleep(10);
-		status = finish_port_resume(udev);
+		status = usb_autoresume_device(udev, 1);
+
+		/* Give the interface drivers a chance to do something,
+		 * then autosuspend the device again. */
 		if (status == 0)
-			udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+			usb_autosuspend_device(udev, 1);
 	}
-	usb_pm_unlock(udev);
-
-	if (status == 0)
-		usb_autoresume_device(udev, 0);
 	usb_unlock_device(udev);
 	return status;
 }</pre><hr><pre>commit ce3615879ae85373c03744b45b7c2d7ae5e29b2a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:12:22 2006 -0500

    USB: struct usb_device: change flag to bitflag
    
    This patch (as816) changes an existing flag in the usb_device
    structure to a bitflag, preparing the way for more bitflags to come
    in the future.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 7729c0744886..5684d8722922 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -764,7 +764,7 @@ int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
 			err = -EINVAL;
 			goto errout;
 		} else {
-			dev-&gt;have_langid = -1;
+			dev-&gt;have_langid = 1;
 			dev-&gt;string_langid = tbuf[2] | (tbuf[3]&lt;&lt; 8);
 				/* always use the first langid listed */
 			dev_dbg (&amp;dev-&gt;dev, "default language 0x%04x\n",
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 864c6c21c21e..5634a2d91ec0 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -362,7 +362,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
-	int have_langid;		/* whether string_langid is valid */
+	unsigned have_langid:1;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
 	/* static strings from the device */</pre><hr><pre>commit 1f9fc882d92f3ff390455836f98d7ddc36d4e4c3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 20 11:06:59 2006 -0500

    OHCI: make autostop conditional on CONFIG_PM
    
    Unlike UHCI, OHCI does not exert any DMA load on the system when no
    devices are connected.  Consequently there is no advantage to doing
    an autostop other than the power savings, so we shouldn't compile the
    necessary code unless CONFIG_PM is enabled.
    
    This patch (as820) makes the root-hub suspend and resume routines
    conditional on CONFIG_PM.  It also prevents autostop from activating
    if the device_may_wakeup flag isn't set; some people use this flag to
    alert the driver about Resume-Detect bugs in the hardware.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 4c9492779ede..2441642cb7b4 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -56,7 +56,6 @@ static void finish_unlinks (struct ohci_hcd *, u16);
 
 #ifdef	CONFIG_PM
 static int ohci_restart(struct ohci_hcd *ohci);
-#endif
 
 static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
 __releases(ohci-&gt;lock)
@@ -187,7 +186,6 @@ __acquires(ohci-&gt;lock)
 		ohci_dbg (ohci, "lost power\n");
 		status = -EBUSY;
 	}
-#ifdef	CONFIG_PM
 	if (status == -EBUSY) {
 		if (!autostopped) {
 			spin_unlock_irq (&amp;ohci-&gt;lock);
@@ -197,7 +195,6 @@ __acquires(ohci-&gt;lock)
 		}
 		return status;
 	}
-#endif
 	if (status != -EINPROGRESS)
 		return status;
 	if (autostopped)
@@ -291,8 +288,6 @@ __acquires(ohci-&gt;lock)
 	return 0;
 }
 
-#ifdef	CONFIG_PM
-
 static int ohci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
@@ -330,6 +325,83 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	return rc;
 }
 
+/* Carry out polling-, autostop-, and autoresume-related state changes */
+static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
+		int any_connected)
+{
+	int	poll_rh = 1;
+
+	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
+
+	case OHCI_USB_OPER:
+		/* keep on polling until we know a device is connected
+		 * and RHSC is enabled */
+		if (!ohci-&gt;autostop) {
+			if (any_connected ||
+					!device_may_wakeup(&amp;ohci_to_hcd(ohci)
+						-&gt;self.root_hub-&gt;dev)) {
+				if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
+						OHCI_INTR_RHSC)
+					poll_rh = 0;
+			} else {
+				ohci-&gt;autostop = 1;
+				ohci-&gt;next_statechange = jiffies + HZ;
+			}
+
+		/* if no devices have been attached for one second, autostop */
+		} else {
+			if (changed || any_connected) {
+				ohci-&gt;autostop = 0;
+				ohci-&gt;next_statechange = jiffies +
+						STATECHANGE_DELAY;
+			} else if (time_after_eq(jiffies,
+						ohci-&gt;next_statechange)
+					&amp;&amp; !ohci-&gt;ed_rm_list
+					&amp;&amp; !(ohci-&gt;hc_control &amp;
+						OHCI_SCHED_ENABLES)) {
+				ohci_rh_suspend(ohci, 1);
+			}
+		}
+		break;
+
+	/* if there is a port change, autostart or ask to be resumed */
+	case OHCI_USB_SUSPEND:
+	case OHCI_USB_RESUME:
+		if (changed) {
+			if (ohci-&gt;autostop)
+				ohci_rh_resume(ohci);
+			else
+				usb_hcd_resume_root_hub(ohci_to_hcd(ohci));
+		} else {
+			/* everything is idle, no need for polling */
+			poll_rh = 0;
+		}
+		break;
+	}
+	return poll_rh;
+}
+
+#else	/* CONFIG_PM */
+
+static inline int ohci_rh_resume(struct ohci_hcd *ohci)
+{
+	return 0;
+}
+
+/* Carry out polling-related state changes.
+ * autostop isn't used when CONFIG_PM is turned off.
+ */
+static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
+		int any_connected)
+{
+	int	poll_rh = 1;
+
+	/* keep on polling until RHSC is enabled */
+	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp; OHCI_INTR_RHSC)
+		poll_rh = 0;
+	return poll_rh;
+}
+
 #endif	/* CONFIG_PM */
 
 /*-------------------------------------------------------------------------*/
@@ -382,55 +454,8 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		}
 	}
 
-	hcd-&gt;poll_rh = 1;
-
-	/* carry out appropriate state changes */
-	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
-
-	case OHCI_USB_OPER:
-		/* keep on polling until we know a device is connected
-		 * and RHSC is enabled */
-		if (!ohci-&gt;autostop) {
-			if (any_connected) {
-				if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
-						OHCI_INTR_RHSC)
-					hcd-&gt;poll_rh = 0;
-			} else {
-				ohci-&gt;autostop = 1;
-				ohci-&gt;next_statechange = jiffies + HZ;
-			}
-
-		/* if no devices have been attached for one second, autostop */
-		} else {
-			if (changed || any_connected) {
-				ohci-&gt;autostop = 0;
-				ohci-&gt;next_statechange = jiffies +
-						STATECHANGE_DELAY;
-			} else if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)
-					&amp;&amp; time_after_eq(jiffies,
-						ohci-&gt;next_statechange)
-					&amp;&amp; !ohci-&gt;ed_rm_list
-					&amp;&amp; !(ohci-&gt;hc_control &amp;
-						OHCI_SCHED_ENABLES)) {
-				ohci_rh_suspend (ohci, 1);
-			}
-		}
-		break;
-
-	/* if there is a port change, autostart or ask to be resumed */
-	case OHCI_USB_SUSPEND:
-	case OHCI_USB_RESUME:
-		if (changed) {
-			if (ohci-&gt;autostop)
-				ohci_rh_resume (ohci);
-			else
-				usb_hcd_resume_root_hub (hcd);
-		} else {
-			/* everything is idle, no need for polling */
-			hcd-&gt;poll_rh = 0;
-		}
-		break;
-	}
+	hcd-&gt;poll_rh = ohci_root_hub_state_changes(ohci, changed,
+			any_connected);
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);</pre>
    <div class="pagination">
        <a href='2_114.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><span>[115]</span><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_116.html'>Next&gt;&gt;</a>
    <div>
</body>
