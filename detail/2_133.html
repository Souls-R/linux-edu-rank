<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_132.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><span>[133]</span><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_134.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 39b7f1e25a412b0ef31e516cfc2fa4f40235f263
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 4 14:44:41 2005 -0500

    [SCSI] sd: Fix refcounting
    
    Currently the driver takes a reference only for requests coming by way
    of the gendisk, not for requests coming by way of the struct device or
    struct scsi_device.  Such requests can arrive in the rescan, flush,
    and shutdown pathways.
    
    The patch also makes the scsi_disk keep a reference to the underlying
    scsi_device, and it erases the scsi_device's pointer to the scsi_disk
    when the scsi_device is removed (since the pointer should no longer be
    used).
    
    This resolves Bugzilla entry #5237.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 9de8e186cb69..bb5b242ac6b4 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -177,24 +177,38 @@ static inline struct scsi_disk *scsi_disk(struct gendisk *disk)
 	return container_of(disk-&gt;private_data, struct scsi_disk, driver);
 }
 
-static struct scsi_disk *scsi_disk_get(struct gendisk *disk)
+static struct scsi_disk *__scsi_disk_get(struct gendisk *disk)
 {
 	struct scsi_disk *sdkp = NULL;
 
+	if (disk-&gt;private_data) {
+		sdkp = scsi_disk(disk);
+		if (scsi_device_get(sdkp-&gt;device) == 0)
+			kref_get(&amp;sdkp-&gt;kref);
+		else
+			sdkp = NULL;
+	}
+	return sdkp;
+}
+
+static struct scsi_disk *scsi_disk_get(struct gendisk *disk)
+{
+	struct scsi_disk *sdkp;
+
 	down(&amp;sd_ref_sem);
-	if (disk-&gt;private_data == NULL)
-		goto out;
-	sdkp = scsi_disk(disk);
-	kref_get(&amp;sdkp-&gt;kref);
-	if (scsi_device_get(sdkp-&gt;device))
-		goto out_put;
+	sdkp = __scsi_disk_get(disk);
 	up(&amp;sd_ref_sem);
 	return sdkp;
+}
 
- out_put:
-	kref_put(&amp;sdkp-&gt;kref, scsi_disk_release);
-	sdkp = NULL;
- out:
+static struct scsi_disk *scsi_disk_get_from_dev(struct device *dev)
+{
+	struct scsi_disk *sdkp;
+
+	down(&amp;sd_ref_sem);
+	sdkp = dev_get_drvdata(dev);
+	if (sdkp)
+		sdkp = __scsi_disk_get(sdkp-&gt;disk);
 	up(&amp;sd_ref_sem);
 	return sdkp;
 }
@@ -716,16 +730,17 @@ static int sd_sync_cache(struct scsi_device *sdp)
 
 static int sd_issue_flush(struct device *dev, sector_t *error_sector)
 {
+	int ret = 0;
 	struct scsi_device *sdp = to_scsi_device(dev);
-	struct scsi_disk *sdkp = dev_get_drvdata(dev);
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
 
 	if (!sdkp)
                return -ENODEV;
 
-	if (!sdkp-&gt;WCE)
-		return 0;
-
-	return sd_sync_cache(sdp);
+	if (sdkp-&gt;WCE)
+		ret = sd_sync_cache(sdp);
+	scsi_disk_put(sdkp);
+	return ret;
 }
 
 static void sd_end_flush(request_queue_t *q, struct request *flush_rq)
@@ -754,23 +769,30 @@ static void sd_end_flush(request_queue_t *q, struct request *flush_rq)
 static int sd_prepare_flush(request_queue_t *q, struct request *rq)
 {
 	struct scsi_device *sdev = q-&gt;queuedata;
-	struct scsi_disk *sdkp = dev_get_drvdata(&amp;sdev-&gt;sdev_gendev);
-
-	if (sdkp-&gt;WCE) {
-		memset(rq-&gt;cmd, 0, sizeof(rq-&gt;cmd));
-		rq-&gt;flags |= REQ_BLOCK_PC | REQ_SOFTBARRIER;
-		rq-&gt;timeout = SD_TIMEOUT;
-		rq-&gt;cmd[0] = SYNCHRONIZE_CACHE;
-		return 1;
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(&amp;sdev-&gt;sdev_gendev);
+	int ret = 0;
+
+	if (sdkp) {
+		if (sdkp-&gt;WCE) {
+			memset(rq-&gt;cmd, 0, sizeof(rq-&gt;cmd));
+			rq-&gt;flags |= REQ_BLOCK_PC | REQ_SOFTBARRIER;
+			rq-&gt;timeout = SD_TIMEOUT;
+			rq-&gt;cmd[0] = SYNCHRONIZE_CACHE;
+			ret = 1;
+		}
+		scsi_disk_put(sdkp);
 	}
-
-	return 0;
+	return ret;
 }
 
 static void sd_rescan(struct device *dev)
 {
-	struct scsi_disk *sdkp = dev_get_drvdata(dev);
-	sd_revalidate_disk(sdkp-&gt;disk);
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
+
+	if (sdkp) {
+		sd_revalidate_disk(sdkp-&gt;disk);
+		scsi_disk_put(sdkp);
+	}
 }
 
 
@@ -1561,6 +1583,7 @@ static int sd_probe(struct device *dev)
 	if (error)
 		goto out_put;
 
+	get_device(&amp;sdp-&gt;sdev_gendev);
 	sdkp-&gt;device = sdp;
 	sdkp-&gt;driver = &amp;sd_template;
 	sdkp-&gt;disk = gd;
@@ -1637,7 +1660,9 @@ static int sd_remove(struct device *dev)
 
 	del_gendisk(sdkp-&gt;disk);
 	sd_shutdown(dev);
+
 	down(&amp;sd_ref_sem);
+	dev_set_drvdata(dev, NULL);
 	kref_put(&amp;sdkp-&gt;kref, scsi_disk_release);
 	up(&amp;sd_ref_sem);
 
@@ -1663,8 +1688,8 @@ static void scsi_disk_release(struct kref *kref)
 	spin_unlock(&amp;sd_index_lock);
 
 	disk-&gt;private_data = NULL;
-
 	put_disk(disk);
+	put_device(&amp;sdkp-&gt;device-&gt;sdev_gendev);
 
 	kfree(sdkp);
 }
@@ -1677,18 +1702,18 @@ static void scsi_disk_release(struct kref *kref)
 static void sd_shutdown(struct device *dev)
 {
 	struct scsi_device *sdp = to_scsi_device(dev);
-	struct scsi_disk *sdkp = dev_get_drvdata(dev);
+	struct scsi_disk *sdkp = scsi_disk_get_from_dev(dev);
 
 	if (!sdkp)
 		return;         /* this can happen */
 
-	if (!sdkp-&gt;WCE)
-		return;
-
-	printk(KERN_NOTICE "Synchronizing SCSI cache for disk %s: \n",
-			sdkp-&gt;disk-&gt;disk_name);
-	sd_sync_cache(sdp);
-}	
+	if (sdkp-&gt;WCE) {
+		printk(KERN_NOTICE "Synchronizing SCSI cache for disk %s: \n",
+				sdkp-&gt;disk-&gt;disk_name);
+		sd_sync_cache(sdp);
+	}
+	scsi_disk_put(sdkp);
+}
 
 /**
  *	init_sd - entry point for this driver (both when built in or when</pre><hr><pre>commit 61e1a9ea4b425eb8c3b4965c35fe953bd881728f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 30 15:01:40 2005 -0800

    [PATCH] Add kthread_stop_sem()
    
    Enhance the kthread API by adding kthread_stop_sem, for use in stopping
    threads that spend their idle time waiting on a semaphore.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/include/linux/kthread.h b/include/linux/kthread.h
index 3fa786448db3..ebdd41fd1082 100644
--- a/include/linux/kthread.h
+++ b/include/linux/kthread.h
@@ -69,6 +69,18 @@ void kthread_bind(struct task_struct *k, unsigned int cpu);
  * was never called. */
 int kthread_stop(struct task_struct *k);
 
+/**
+ * kthread_stop_sem: stop a thread created by kthread_create().
+ * @k: thread created by kthread_create().
+ * @s: semaphore that @k waits on while idle.
+ *
+ * Does essentially the same thing as kthread_stop() above, but wakes
+ * @k by calling up(@s).
+ *
+ * Returns the result of threadfn(), or -EINTR if wake_up_process()
+ * was never called. */
+int kthread_stop_sem(struct task_struct *k, struct semaphore *s);
+
 /**
  * kthread_should_stop: should this kthread return now?
  *
diff --git a/kernel/kthread.c b/kernel/kthread.c
index f50f174e92da..e75950a1092c 100644
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@ -164,6 +164,12 @@ void kthread_bind(struct task_struct *k, unsigned int cpu)
 EXPORT_SYMBOL(kthread_bind);
 
 int kthread_stop(struct task_struct *k)
+{
+	return kthread_stop_sem(k, NULL);
+}
+EXPORT_SYMBOL(kthread_stop);
+
+int kthread_stop_sem(struct task_struct *k, struct semaphore *s)
 {
 	int ret;
 
@@ -178,7 +184,10 @@ int kthread_stop(struct task_struct *k)
 
 	/* Now set kthread_should_stop() to true, and wake it up. */
 	kthread_stop_info.k = k;
-	wake_up_process(k);
+	if (s)
+		up(s);
+	else
+		wake_up_process(k);
 	put_task_struct(k);
 
 	/* Once it dies, reset stop ptr, gather result and we're done. */
@@ -189,7 +198,7 @@ int kthread_stop(struct task_struct *k)
 
 	return ret;
 }
-EXPORT_SYMBOL(kthread_stop);
+EXPORT_SYMBOL(kthread_stop_sem);
 
 static __init int helper_init(void)
 {</pre><hr><pre>commit 4f62efe67f077db17dad03a1d4c9665000a3eb45
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 16:24:14 2005 -0400

    [PATCH] usbcore: Fix handling of sysfs strings and other attributes
    
    This patch (as592) makes a few small improvements to the way device
    strings are handled, and it fixes some bugs in a couple of other sysfs
    attribute routines.  (Look at show_configuration_string() to see what I
    mean.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 63f374e62db2..993019500cc3 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -112,8 +112,12 @@ void usb_release_interface_cache(struct kref *ref)
 	struct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);
 	int j;
 
-	for (j = 0; j &lt; intfc-&gt;num_altsetting; j++)
-		kfree(intfc-&gt;altsetting[j].endpoint);
+	for (j = 0; j &lt; intfc-&gt;num_altsetting; j++) {
+		struct usb_host_interface *alt = &amp;intfc-&gt;altsetting[j];
+
+		kfree(alt-&gt;endpoint);
+		kfree(alt-&gt;string);
+	}
 	kfree(intfc);
 }
 
@@ -420,8 +424,6 @@ void usb_destroy_configuration(struct usb_device *dev)
 		struct usb_host_config *cf = &amp;dev-&gt;config[c];
 
 		kfree(cf-&gt;string);
-		cf-&gt;string = NULL;
-
 		for (i = 0; i &lt; cf-&gt;desc.bNumInterfaces; i++) {
 			if (cf-&gt;intf_cache[i])
 				kref_put(&amp;cf-&gt;intf_cache[i]-&gt;ref, 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 8ba5854e5387..1bacb374b007 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1204,21 +1204,6 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
 {}
 #endif
 
-static void get_string(struct usb_device *udev, char **string, int index)
-{
-	char *buf;
-
-	if (!index)
-		return;
-	buf = kmalloc(256, GFP_KERNEL);
-	if (!buf)
-		return;
-	if (usb_string(udev, index, buf, 256) &gt; 0)
-		*string = buf;
-	else
-		kfree(buf);
-}
-
 
 #ifdef	CONFIG_USB_OTG
 #include "otg_whitelist.h"
@@ -1257,9 +1242,10 @@ int usb_new_device(struct usb_device *udev)
 	}
 
 	/* read the standard strings and cache them if present */
-	get_string(udev, &amp;udev-&gt;product, udev-&gt;descriptor.iProduct);
-	get_string(udev, &amp;udev-&gt;manufacturer, udev-&gt;descriptor.iManufacturer);
-	get_string(udev, &amp;udev-&gt;serial, udev-&gt;descriptor.iSerialNumber);
+	udev-&gt;product = usb_cache_string(udev, udev-&gt;descriptor.iProduct);
+	udev-&gt;manufacturer = usb_cache_string(udev,
+			udev-&gt;descriptor.iManufacturer);
+	udev-&gt;serial = usb_cache_string(udev, udev-&gt;descriptor.iSerialNumber);
 
 	/* Tell the world! */
 	dev_dbg(&amp;udev-&gt;dev, "new device strings: Mfr=%d, Product=%d, "
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 3519f317898e..644a3d4f12aa 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -787,6 +787,31 @@ int usb_string(struct usb_device *dev, int index, char *buf, size_t size)
 	return err;
 }
 
+/**
+ * usb_cache_string - read a string descriptor and cache it for later use
+ * @udev: the device whose string descriptor is being read
+ * @index: the descriptor index
+ *
+ * Returns a pointer to a kmalloc'ed buffer containing the descriptor string,
+ * or NULL if the index is 0 or the string could not be read.
+ */
+char *usb_cache_string(struct usb_device *udev, int index)
+{
+	char *buf;
+	char *smallbuf = NULL;
+	int len;
+
+	if (index &gt; 0 &amp;&amp; (buf = kmalloc(256, GFP_KERNEL)) != NULL) {
+		if ((len = usb_string(udev, index, buf, 256)) &gt; 0) {
+			if ((smallbuf = kmalloc(++len, GFP_KERNEL)) == NULL)
+				return buf;
+			memcpy(smallbuf, buf, len);
+		}
+		kfree(buf);
+	}
+	return smallbuf;
+}
+
 /*
  * usb_get_device_descriptor - (re)reads the device descriptor (usbcore)
  * @dev: the device whose device descriptor is being updated
@@ -1008,8 +1033,6 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 			dev_dbg (&amp;dev-&gt;dev, "unregistering interface %s\n",
 				interface-&gt;dev.bus_id);
 			usb_remove_sysfs_intf_files(interface);
-			kfree(interface-&gt;cur_altsetting-&gt;string);
-			interface-&gt;cur_altsetting-&gt;string = NULL;
 			device_del (&amp;interface-&gt;dev);
 		}
 
@@ -1422,12 +1445,9 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		}
 		kfree(new_interfaces);
 
-		if ((cp-&gt;desc.iConfiguration) &amp;&amp;
-		    (cp-&gt;string == NULL)) {
-			cp-&gt;string = kmalloc(256, GFP_KERNEL);
-			if (cp-&gt;string)
-				usb_string(dev, cp-&gt;desc.iConfiguration, cp-&gt;string, 256);
-		}
+		if (cp-&gt;string == NULL)
+			cp-&gt;string = usb_cache_string(dev,
+					cp-&gt;desc.iConfiguration);
 
 		/* Now that all the interfaces are set up, register them
 		 * to trigger binding of drivers to interfaces.  probe()
@@ -1437,13 +1457,12 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		 */
 		for (i = 0; i &lt; nintf; ++i) {
 			struct usb_interface *intf = cp-&gt;interface[i];
-			struct usb_interface_descriptor *desc;
+			struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 
-			desc = &amp;intf-&gt;altsetting [0].desc;
 			dev_dbg (&amp;dev-&gt;dev,
 				"adding %s (config #%d, interface %d)\n",
 				intf-&gt;dev.bus_id, configuration,
-				desc-&gt;bInterfaceNumber);
+				alt-&gt;desc.bInterfaceNumber);
 			ret = device_add (&amp;intf-&gt;dev);
 			if (ret != 0) {
 				dev_err(&amp;dev-&gt;dev,
@@ -1452,13 +1471,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 					ret);
 				continue;
 			}
-			if ((intf-&gt;cur_altsetting-&gt;desc.iInterface) &amp;&amp;
-			    (intf-&gt;cur_altsetting-&gt;string == NULL)) {
-				intf-&gt;cur_altsetting-&gt;string = kmalloc(256, GFP_KERNEL);
-				if (intf-&gt;cur_altsetting-&gt;string)
-					usb_string(dev, intf-&gt;cur_altsetting-&gt;desc.iInterface,
-						   intf-&gt;cur_altsetting-&gt;string, 256);
-			}
 			usb_create_sysfs_intf_files (intf);
 		}
 	}
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 4cca77cf0c48..edd83e014452 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -249,18 +249,12 @@ static ssize_t show_configuration_string(struct device *dev,
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
-	int len;
 
 	udev = to_usb_device (dev);
 	actconfig = udev-&gt;actconfig;
 	if ((!actconfig) || (!actconfig-&gt;string))
 		return 0;
-	len = sprintf(buf, actconfig-&gt;string, PAGE_SIZE);
-	if (len &lt; 0)
-		return 0;
-	buf[len] = '\n';
-	buf[len+1] = 0;
-	return len+1;
+	return sprintf(buf, "%s\n", actconfig-&gt;string);
 }
 static DEVICE_ATTR(configuration, S_IRUGO, show_configuration_string, NULL);
 
@@ -291,15 +285,9 @@ static ssize_t  show_##name(struct device *dev,				\
 		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
-	int len;							\
 									\
 	udev = to_usb_device (dev);					\
-	len = snprintf(buf, 256, "%s", udev-&gt;name);			\
-	if (len &lt; 0)							\
-		return 0;						\
-	buf[len] = '\n';						\
-	buf[len+1] = 0;							\
-	return len+1;							\
+	return sprintf(buf, "%s\n", udev-&gt;name);			\
 }									\
 static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);
 
@@ -449,11 +437,11 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 	usb_remove_ep_files(&amp;udev-&gt;ep0);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 
-	if (udev-&gt;descriptor.iManufacturer)
+	if (udev-&gt;manufacturer)
 		device_remove_file(dev, &amp;dev_attr_manufacturer);
-	if (udev-&gt;descriptor.iProduct)
+	if (udev-&gt;product)
 		device_remove_file(dev, &amp;dev_attr_product);
-	if (udev-&gt;descriptor.iSerialNumber)
+	if (udev-&gt;serial)
 		device_remove_file(dev, &amp;dev_attr_serial);
 	device_remove_file (dev, &amp;dev_attr_configuration);
 }
@@ -535,7 +523,8 @@ static struct attribute_group intf_attr_grp = {
 	.attrs = intf_attrs,
 };
 
-static inline void usb_create_intf_ep_files(struct usb_interface *intf)
+static inline void usb_create_intf_ep_files(struct usb_interface *intf,
+		struct usb_device *udev)
 {
 	struct usb_host_interface *iface_desc;
 	int i;
@@ -543,7 +532,7 @@ static inline void usb_create_intf_ep_files(struct usb_interface *intf)
 	iface_desc = intf-&gt;cur_altsetting;
 	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i)
 		usb_create_ep_files(&amp;intf-&gt;dev.kobj, &amp;iface_desc-&gt;endpoint[i],
-				interface_to_usbdev(intf));
+				udev);
 }
 
 static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
@@ -558,11 +547,16 @@ static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
 
 void usb_create_sysfs_intf_files (struct usb_interface *intf)
 {
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
+
 	sysfs_create_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
 
-	if (intf-&gt;cur_altsetting-&gt;string)
+	if (alt-&gt;string == NULL)
+		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
+	if (alt-&gt;string)
 		device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
-	usb_create_intf_ep_files(intf);
+	usb_create_intf_ep_files(intf, udev);
 }
 
 void usb_remove_sysfs_intf_files (struct usb_interface *intf)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 888dbe443695..1c4a68499dce 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -13,6 +13,7 @@ extern void usb_disable_device (struct usb_device *dev, int skip_ep0);
 
 extern int usb_get_device_descriptor(struct usb_device *dev,
 		unsigned int size);
+extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
 extern void usb_lock_all_devices(void);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index c500d6b5a16d..748d04385256 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -231,7 +231,7 @@ struct usb_interface_cache {
 struct usb_host_config {
 	struct usb_config_descriptor	desc;
 
-	char *string;
+	char *string;		/* iConfiguration string, if present */
 	/* the interfaces associated with this configuration,
 	 * stored in no particular order */
 	struct usb_interface *interface[USB_MAXINTERFACES];
@@ -351,9 +351,11 @@ struct usb_device {
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
-	char *product;
-	char *manufacturer;
-	char *serial;			/* static strings from the device */
+	/* static strings from the device */
+	char *product;			/* iProduct string, if present */
+	char *manufacturer;		/* iManufacturer string, if present */
+	char *serial;			/* iSerialNumber string, if present */
+
 	struct list_head filelist;
 	struct class_device *class_dev;
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the device */</pre><hr><pre>commit 16f16d117c1eb99451e4c73c87546eef05c66790
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:41:19 2005 -0400

    [PATCH] USB: Fix maxpacket length for ep0 on root hubs
    
    This patch (as591) fixes a rather innocuous bug that has been around for
    quite a long time: Virtual root hubs should have a maxpacket length of
    64 for endpoint 0.  I didn't realize it was wrong until I started
    looking through the endpoint attribute files.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 61ef9943757e..6c7ca5b08cd6 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -130,7 +130,7 @@ static const u8 usb2_rh_dev_descriptor [18] = {
 	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
 	0x00,	    /*  __u8  bDeviceSubClass; */
 	0x01,       /*  __u8  bDeviceProtocol; [ usb 2.0 single TT ]*/
-	0x08,       /*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x40,       /*  __u8  bMaxPacketSize0; 64 Bytes */
 
 	0x00, 0x00, /*  __le16 idVendor; */
  	0x00, 0x00, /*  __le16 idProduct; */
@@ -153,7 +153,7 @@ static const u8 usb11_rh_dev_descriptor [18] = {
 	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
 	0x00,	    /*  __u8  bDeviceSubClass; */
 	0x00,       /*  __u8  bDeviceProtocol; [ low/full speeds only ] */
-	0x08,       /*  __u8  bMaxPacketSize0; 8 Bytes */
+	0x40,       /*  __u8  bMaxPacketSize0; 64 Bytes */
 
 	0x00, 0x00, /*  __le16 idVendor; */
  	0x00, 0x00, /*  __le16 idProduct; */</pre><hr><pre>commit 0a1ef3b5a765a6f20e7b8caf295aad3276243966
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:38:24 2005 -0400

    [PATCH] usbcore: Use kzalloc instead of kmalloc/memset
    
    This patch (as590) fixes up all the remaining places where usbcore can
    use kzalloc rather than kmalloc/memset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 99595e07b653..63f374e62db2 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -188,10 +188,9 @@ static int usb_parse_interface(struct device *ddev, int cfgno,
 	}
 
 	len = sizeof(struct usb_host_endpoint) * num_ep;
-	alt-&gt;endpoint = kmalloc(len, GFP_KERNEL);
+	alt-&gt;endpoint = kzalloc(len, GFP_KERNEL);
 	if (!alt-&gt;endpoint)
 		return -ENOMEM;
-	memset(alt-&gt;endpoint, 0, len);
 
 	/* Parse all the endpoint descriptors */
 	n = 0;
@@ -353,10 +352,9 @@ static int usb_parse_configuration(struct device *ddev, int cfgidx,
 		}
 
 		len = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;
-		config-&gt;intf_cache[i] = intfc = kmalloc(len, GFP_KERNEL);
+		config-&gt;intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);
 		if (!intfc)
 			return -ENOMEM;
-		memset(intfc, 0, len);
 		kref_init(&amp;intfc-&gt;ref);
 	}
 
@@ -459,16 +457,14 @@ int usb_get_configuration(struct usb_device *dev)
 	}
 
 	length = ncfg * sizeof(struct usb_host_config);
-	dev-&gt;config = kmalloc(length, GFP_KERNEL);
+	dev-&gt;config = kzalloc(length, GFP_KERNEL);
 	if (!dev-&gt;config)
 		goto err2;
-	memset(dev-&gt;config, 0, length);
 
 	length = ncfg * sizeof(char *);
-	dev-&gt;rawdescriptors = kmalloc(length, GFP_KERNEL);
+	dev-&gt;rawdescriptors = kzalloc(length, GFP_KERNEL);
 	if (!dev-&gt;rawdescriptors)
 		goto err2;
-	memset(dev-&gt;rawdescriptors, 0, length);
 
 	buffer = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);
 	if (!buffer)
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index ffb2e242b100..942cd437dc48 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -210,10 +210,10 @@ static ssize_t usbdev_read(struct file *file, char __user *buf, size_t nbytes, l
 static struct async *alloc_async(unsigned int numisoframes)
 {
         unsigned int assize = sizeof(struct async) + numisoframes * sizeof(struct usb_iso_packet_descriptor);
-        struct async *as = kmalloc(assize, GFP_KERNEL);
+        struct async *as = kzalloc(assize, GFP_KERNEL);
+
         if (!as)
                 return NULL;
-        memset(as, 0, assize);
 	as-&gt;urb = usb_alloc_urb(numisoframes, GFP_KERNEL);
 	if (!as-&gt;urb) {
 		kfree(as);
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index e8f2b8d8f14d..61ef9943757e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -744,10 +744,9 @@ struct usb_bus *usb_alloc_bus (struct usb_operations *op)
 {
 	struct usb_bus *bus;
 
-	bus = kmalloc (sizeof *bus, GFP_KERNEL);
+	bus = kzalloc (sizeof *bus, GFP_KERNEL);
 	if (!bus)
 		return NULL;
-	memset(bus, 0, sizeof(struct usb_bus));
 	usb_bus_init (bus);
 	bus-&gt;op = op;
 	return bus;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 6a2ebd89916f..8ba5854e5387 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -865,14 +865,12 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	/* We found a hub */
 	dev_info (&amp;intf-&gt;dev, "USB hub found\n");
 
-	hub = kmalloc(sizeof(*hub), GFP_KERNEL);
+	hub = kzalloc(sizeof(*hub), GFP_KERNEL);
 	if (!hub) {
 		dev_dbg (&amp;intf-&gt;dev, "couldn't kmalloc hub struct\n");
 		return -ENOMEM;
 	}
 
-	memset(hub, 0, sizeof(*hub));
-
 	INIT_LIST_HEAD(&amp;hub-&gt;event_list);
 	hub-&gt;intfdev = &amp;intf-&gt;dev;
 	hub-&gt;hdev = hdev;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 5ad0d5e28119..3519f317898e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1350,7 +1350,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 		}
 
 		for (; n &lt; nintf; ++n) {
-			new_interfaces[n] = kmalloc(
+			new_interfaces[n] = kzalloc(
 					sizeof(struct usb_interface),
 					GFP_KERNEL);
 			if (!new_interfaces[n]) {
@@ -1391,7 +1391,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 			struct usb_host_interface *alt;
 
 			cp-&gt;interface[i] = intf = new_interfaces[i];
-			memset(intf, 0, sizeof(*intf));
 			intfc = cp-&gt;intf_cache[i];
 			intf-&gt;altsetting = intfc-&gt;altsetting;
 			intf-&gt;num_altsetting = intfc-&gt;num_altsetting;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 4eca4904938f..0eefff7bcb3c 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -704,12 +704,10 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 {
 	struct usb_device *dev;
 
-	dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
 		return NULL;
 
-	memset(dev, 0, sizeof(*dev));
-
 	bus = usb_bus_get(bus);
 	if (!bus) {
 		kfree(dev);</pre><hr><pre>commit b724ae77969fd832be71419dca74bece9af287ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:36:00 2005 -0400

    [PATCH] usbcore: Wrap lines before column 80
    
    I can't stand text lines that wrap-around in my 80-column windows.  This
    patch (as589) makes cosmetic changes to a couple of source files.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index f18317fb49ee..4cca77cf0c48 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -221,7 +221,8 @@ static void usb_remove_ep_files(struct usb_host_endpoint *endpoint)
 
 /* Active configuration fields */
 #define usb_actconfig_show(field, multiplier, format_string)		\
-static ssize_t  show_##field (struct device *dev, struct device_attribute *attr, char *buf)		\
+static ssize_t  show_##field (struct device *dev,			\
+		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
 	struct usb_host_config *actconfig;				\
@@ -243,7 +244,8 @@ usb_actconfig_attr (bNumInterfaces, 1, "%2d\n")
 usb_actconfig_attr (bmAttributes, 1, "%2x\n")
 usb_actconfig_attr (bMaxPower, 2, "%3dmA\n")
 
-static ssize_t show_configuration_string(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_configuration_string(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	struct usb_device *udev;
 	struct usb_host_config *actconfig;
@@ -266,7 +268,8 @@ static DEVICE_ATTR(configuration, S_IRUGO, show_configuration_string, NULL);
 usb_actconfig_show(bConfigurationValue, 1, "%u\n");
 
 static ssize_t
-set_bConfigurationValue (struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+set_bConfigurationValue (struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
 {
 	struct usb_device	*udev = udev = to_usb_device (dev);
 	int			config, value;
@@ -284,7 +287,8 @@ static DEVICE_ATTR(bConfigurationValue, S_IRUGO | S_IWUSR,
 
 /* String fields */
 #define usb_string_attr(name)						\
-static ssize_t  show_##name(struct device *dev, struct device_attribute *attr, char *buf)		\
+static ssize_t  show_##name(struct device *dev,				\
+		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
 	int len;							\
@@ -364,7 +368,8 @@ static DEVICE_ATTR(maxchild, S_IRUGO, show_maxchild, NULL);
 /* Descriptor fields */
 #define usb_descriptor_attr_le16(field, format_string)			\
 static ssize_t								\
-show_##field (struct device *dev, struct device_attribute *attr, char *buf)				\
+show_##field (struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
 {									\
 	struct usb_device *udev;					\
 									\
@@ -380,7 +385,8 @@ usb_descriptor_attr_le16(bcdDevice, "%04x\n")
 
 #define usb_descriptor_attr(field, format_string)			\
 static ssize_t								\
-show_##field (struct device *dev, struct device_attribute *attr, char *buf)				\
+show_##field (struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
 {									\
 	struct usb_device *udev;					\
 									\
@@ -455,11 +461,13 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 /* Interface fields */
 #define usb_intf_attr(field, format_string)				\
 static ssize_t								\
-show_##field (struct device *dev, struct device_attribute *attr, char *buf)				\
+show_##field (struct device *dev, struct device_attribute *attr,	\
+		char *buf)						\
 {									\
 	struct usb_interface *intf = to_usb_interface (dev);		\
 									\
-	return sprintf (buf, format_string, intf-&gt;cur_altsetting-&gt;desc.field); \
+	return sprintf (buf, format_string,				\
+			intf-&gt;cur_altsetting-&gt;desc.field); 		\
 }									\
 static DEVICE_ATTR(field, S_IRUGO, show_##field, NULL);
 
@@ -470,7 +478,8 @@ usb_intf_attr (bInterfaceClass, "%02x\n")
 usb_intf_attr (bInterfaceSubClass, "%02x\n")
 usb_intf_attr (bInterfaceProtocol, "%02x\n")
 
-static ssize_t show_interface_string(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_interface_string(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	struct usb_interface *intf;
 	struct usb_device *udev;
@@ -487,7 +496,8 @@ static ssize_t show_interface_string(struct device *dev, struct device_attribute
 }
 static DEVICE_ATTR(interface, S_IRUGO, show_interface_string, NULL);
 
-static ssize_t show_modalias(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_modalias(struct device *dev,
+		struct device_attribute *attr, char *buf)
 {
 	struct usb_interface *intf;
 	struct usb_device *udev;
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 465ff4585ca5..c500d6b5a16d 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -137,7 +137,8 @@ struct usb_interface {
 					 * active alternate setting */
 	unsigned num_altsetting;	/* number of alternate settings */
 
-	int minor;			/* minor number this interface is bound to */
+	int minor;			/* minor number this interface is
+					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
@@ -249,7 +250,7 @@ int __usb_get_extra_descriptor(char *buffer, unsigned size,
 	__usb_get_extra_descriptor((ifpoint)-&gt;extra,(ifpoint)-&gt;extralen,\
 		type,(void**)ptr)
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 struct usb_operations;
 
@@ -269,7 +270,8 @@ struct usb_bus {
 	unsigned is_b_host:1;		/* true during some HNP roleswitches */
 	unsigned b_hnp_enable:1;	/* OTG: did A-Host enable HNP? */
 
-	int devnum_next;		/* Next open device number in round-robin allocation */
+	int devnum_next;		/* Next open device number in
+					 * round-robin allocation */
 
 	struct usb_devmap devmap;	/* device address allocation map */
 	struct usb_operations *op;	/* Operations (specific to the HC) */
@@ -290,15 +292,16 @@ struct usb_bus {
 	struct dentry *usbfs_dentry;	/* usbfs dentry entry for the bus */
 
 	struct class_device *class_dev;	/* class device for this bus */
-	struct kref kref;		/* handles reference counting this bus */
-	void (*release)(struct usb_bus *bus);	/* function to destroy this bus's memory */
+	struct kref kref;		/* reference counting for this bus */
+	void (*release)(struct usb_bus *bus);
+
 #if defined(CONFIG_USB_MON)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
 #endif
 };
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /* This is arbitrary.
  * From USB 2.0 spec Table 11-13, offset 7, a hub can
@@ -327,7 +330,8 @@ struct usb_device {
 
 	struct semaphore serialize;
 
-	unsigned int toggle[2];		/* one bit for each endpoint ([0] = IN, [1] = OUT) */
+	unsigned int toggle[2];		/* one bit for each endpoint
+					 * ([0] = IN, [1] = OUT) */
 
 	struct usb_device *parent;	/* our hub, unless we're the root */
 	struct usb_bus *bus;		/* Bus we're part of */
@@ -344,7 +348,7 @@ struct usb_device {
 
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
-	int have_langid;		/* whether string_langid is valid yet */
+	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 
 	char *product;
@@ -441,22 +445,31 @@ extern struct usb_host_interface *usb_altnum_to_altsetting(
  * USB 2.0 root hubs (EHCI host controllers) will get one path ID if they are
  * high speed, and a different one if they are full or low speed.
  */
-static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
+static inline int usb_make_path (struct usb_device *dev, char *buf,
+		size_t size)
 {
 	int actual;
-	actual = snprintf (buf, size, "usb-%s-%s", dev-&gt;bus-&gt;bus_name, dev-&gt;devpath);
+	actual = snprintf (buf, size, "usb-%s-%s", dev-&gt;bus-&gt;bus_name,
+			dev-&gt;devpath);
 	return (actual &gt;= (int)size) ? -1 : actual;
 }
 
 /*-------------------------------------------------------------------------*/
 
-#define USB_DEVICE_ID_MATCH_DEVICE		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
-#define USB_DEVICE_ID_MATCH_DEV_RANGE		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
-#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION	(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
+#define USB_DEVICE_ID_MATCH_DEVICE \
+		(USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT)
+#define USB_DEVICE_ID_MATCH_DEV_RANGE \
+		(USB_DEVICE_ID_MATCH_DEV_LO | USB_DEVICE_ID_MATCH_DEV_HI)
+#define USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION \
+		(USB_DEVICE_ID_MATCH_DEVICE | USB_DEVICE_ID_MATCH_DEV_RANGE)
 #define USB_DEVICE_ID_MATCH_DEV_INFO \
-	(USB_DEVICE_ID_MATCH_DEV_CLASS | USB_DEVICE_ID_MATCH_DEV_SUBCLASS | USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
+		(USB_DEVICE_ID_MATCH_DEV_CLASS | \
+		USB_DEVICE_ID_MATCH_DEV_SUBCLASS | \
+		USB_DEVICE_ID_MATCH_DEV_PROTOCOL)
 #define USB_DEVICE_ID_MATCH_INT_INFO \
-	(USB_DEVICE_ID_MATCH_INT_CLASS | USB_DEVICE_ID_MATCH_INT_SUBCLASS | USB_DEVICE_ID_MATCH_INT_PROTOCOL)
+		(USB_DEVICE_ID_MATCH_INT_CLASS | \
+		USB_DEVICE_ID_MATCH_INT_SUBCLASS | \
+		USB_DEVICE_ID_MATCH_INT_PROTOCOL)
 
 /**
  * USB_DEVICE - macro used to describe a specific usb device
@@ -467,9 +480,11 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific device.
  */
 #define USB_DEVICE(vend,prod) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), .idProduct = (prod)
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE, .idVendor = (vend), \
+			.idProduct = (prod)
 /**
- * USB_DEVICE_VER - macro used to describe a specific usb device with a version range
+ * USB_DEVICE_VER - macro used to describe a specific usb device with a
+ *		version range
  * @vend: the 16 bit USB Vendor ID
  * @prod: the 16 bit USB Product ID
  * @lo: the bcdDevice_lo value
@@ -479,7 +494,9 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific device, with a version range.
  */
 #define USB_DEVICE_VER(vend,prod,lo,hi) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, .idVendor = (vend), .idProduct = (prod), .bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE_AND_VERSION, \
+	.idVendor = (vend), .idProduct = (prod), \
+	.bcdDevice_lo = (lo), .bcdDevice_hi = (hi)
 
 /**
  * USB_DEVICE_INFO - macro used to describe a class of usb devices
@@ -491,7 +508,8 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific class of devices.
  */
 #define USB_DEVICE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), .bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
+	.match_flags = USB_DEVICE_ID_MATCH_DEV_INFO, .bDeviceClass = (cl), \
+	.bDeviceSubClass = (sc), .bDeviceProtocol = (pr)
 
 /**
  * USB_INTERFACE_INFO - macro used to describe a class of usb interfaces 
@@ -503,9 +521,10 @@ static inline int usb_make_path (struct usb_device *dev, char *buf, size_t size)
  * specific class of interfaces.
  */
 #define USB_INTERFACE_INFO(cl,sc,pr) \
-	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), .bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
+	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO, .bInterfaceClass = (cl), \
+	.bInterfaceSubClass = (sc), .bInterfaceProtocol = (pr)
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /**
  * struct usb_driver - identifies USB driver to usbcore
@@ -558,7 +577,8 @@ struct usb_driver {
 
 	void (*disconnect) (struct usb_interface *intf);
 
-	int (*ioctl) (struct usb_interface *intf, unsigned int code, void *buf);
+	int (*ioctl) (struct usb_interface *intf, unsigned int code,
+			void *buf);
 
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
@@ -601,7 +621,7 @@ extern void usb_deregister_dev(struct usb_interface *intf,
 
 extern int usb_disabled(void);
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /*
  * URB support, for asynchronous request completions
@@ -611,12 +631,14 @@ extern int usb_disabled(void);
  * urb-&gt;transfer_flags:
  */
 #define URB_SHORT_NOT_OK	0x0001	/* report short reads as errors */
-#define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame ignored */
+#define URB_ISO_ASAP		0x0002	/* iso-only, urb-&gt;start_frame
+					 * ignored */
 #define URB_NO_TRANSFER_DMA_MAP	0x0004	/* urb-&gt;transfer_dma valid on submit */
 #define URB_NO_SETUP_DMA_MAP	0x0008	/* urb-&gt;setup_dma valid on submit */
 #define URB_NO_FSBR		0x0020	/* UHCI-specific */
-#define URB_ZERO_PACKET		0x0040	/* Finish bulk OUTs with short packet */
-#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt needed */
+#define URB_ZERO_PACKET		0x0040	/* Finish bulk OUT with short packet */
+#define URB_NO_INTERRUPT	0x0080	/* HINT: no non-error interrupt
+					 * needed */
 
 struct usb_iso_packet_descriptor {
 	unsigned int offset;
@@ -804,7 +826,8 @@ struct urb
 	u8 reject;			/* submissions will fail */
 
 	/* public, documented fields in the urb that can be used by drivers */
-	struct list_head urb_list;	/* list head for use by the urb owner */
+	struct list_head urb_list;	/* list head for use by the urb's
+					 * current owner */
 	struct usb_device *dev; 	/* (in) pointer to associated device */
 	unsigned int pipe;		/* (in) pipe information */
 	int status;			/* (return) non-ISO status */
@@ -817,14 +840,16 @@ struct urb
 	dma_addr_t setup_dma;		/* (in) dma addr for setup_packet */
 	int start_frame;		/* (modify) start frame (ISO) */
 	int number_of_packets;		/* (in) number of ISO packets */
-	int interval;			/* (modify) transfer interval (INT/ISO) */
+	int interval;			/* (modify) transfer interval
+					 * (INT/ISO) */
 	int error_count;		/* (return) number of ISO errors */
 	void *context;			/* (in) context for completion */
 	usb_complete_t complete;	/* (in) completion routine */
-	struct usb_iso_packet_descriptor iso_frame_desc[0];	/* (in) ISO ONLY */
+	struct usb_iso_packet_descriptor iso_frame_desc[0];
+					/* (in) ISO ONLY */
 };
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /**
  * usb_fill_control_urb - initializes a control urb
@@ -1049,7 +1074,7 @@ void usb_sg_cancel (struct usb_sg_request *io);
 void usb_sg_wait (struct usb_sg_request *io);
 
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /*
  * For various legacy reasons, Linux has a small cookie that's paired with
@@ -1090,23 +1115,34 @@ void usb_sg_wait (struct usb_sg_request *io);
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)-&gt;toggle[out] &gt;&gt; (ep)) &amp; 1)
 #define	usb_dotoggle(dev, ep, out)  ((dev)-&gt;toggle[out] ^= (1 &lt;&lt; (ep)))
-#define usb_settoggle(dev, ep, out, bit) ((dev)-&gt;toggle[out] = ((dev)-&gt;toggle[out] &amp; ~(1 &lt;&lt; (ep))) | ((bit) &lt;&lt; (ep)))
+#define usb_settoggle(dev, ep, out, bit) \
+		((dev)-&gt;toggle[out] = ((dev)-&gt;toggle[out] &amp; ~(1 &lt;&lt; (ep))) | \
+		 ((bit) &lt;&lt; (ep)))
 
 
-static inline unsigned int __create_pipe(struct usb_device *dev, unsigned int endpoint)
+static inline unsigned int __create_pipe(struct usb_device *dev,
+		unsigned int endpoint)
 {
 	return (dev-&gt;devnum &lt;&lt; 8) | (endpoint &lt;&lt; 15);
 }
 
 /* Create various pipes... */
-#define usb_sndctrlpipe(dev,endpoint)	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvctrlpipe(dev,endpoint)	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvisocpipe(dev,endpoint)	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndbulkpipe(dev,endpoint)	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvbulkpipe(dev,endpoint)	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
-#define usb_sndintpipe(dev,endpoint)	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint))
-#define usb_rcvintpipe(dev,endpoint)	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndctrlpipe(dev,endpoint)	\
+	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvctrlpipe(dev,endpoint)	\
+	((PIPE_CONTROL &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndisocpipe(dev,endpoint)	\
+	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvisocpipe(dev,endpoint)	\
+	((PIPE_ISOCHRONOUS &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndbulkpipe(dev,endpoint)	\
+	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvbulkpipe(dev,endpoint)	\
+	((PIPE_BULK &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
+#define usb_sndintpipe(dev,endpoint)	\
+	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint))
+#define usb_rcvintpipe(dev,endpoint)	\
+	((PIPE_INTERRUPT &lt;&lt; 30) | __create_pipe(dev,endpoint) | USB_DIR_IN)
 
 /*-------------------------------------------------------------------------*/
 
@@ -1130,7 +1166,7 @@ usb_maxpacket(struct usb_device *udev, int pipe, int is_out)
 	return le16_to_cpu(ep-&gt;desc.wMaxPacketSize);
 }
 
-/* -------------------------------------------------------------------------- */
+/* ----------------------------------------------------------------------- */
 
 /* Events from the usb core */
 #define USB_DEVICE_ADD		0x0001
@@ -1141,14 +1177,18 @@ extern void usb_register_notify(struct notifier_block *nb);
 extern void usb_unregister_notify(struct notifier_block *nb);
 
 #ifdef DEBUG
-#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , __FILE__ , ## arg)
+#define dbg(format, arg...) printk(KERN_DEBUG "%s: " format "\n" , \
+	__FILE__ , ## arg)
 #else
 #define dbg(format, arg...) do {} while (0)
 #endif
 
-#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , __FILE__ , ## arg)
-#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , __FILE__ , ## arg)
-#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , __FILE__ , ## arg)
+#define err(format, arg...) printk(KERN_ERR "%s: " format "\n" , \
+	__FILE__ , ## arg)
+#define info(format, arg...) printk(KERN_INFO "%s: " format "\n" , \
+	__FILE__ , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "%s: " format "\n" , \
+	__FILE__ , ## arg)
 
 
 #endif  /* __KERNEL__ */</pre><hr><pre>commit 0e6c8e8db508fcb292836b23d039649c5de29090
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 24 15:33:03 2005 -0400

    [PATCH] usbcore: endpoint attributes track altsetting changes
    
    This patch (as588) fixes the way endpoint attribute files are registered
    and unregistered.  Now they will correctly track along with altsetting
    changes.  This fixes bugzilla entry #5467.
    
    In a separate but related change, when a usb_reset_configuration call
    fails, the device state is not changed to USB_STATE_ADDRESS.  In the
    first place, failure means that we don't know what the state is, not
    that we know the device is unconfigured.  In the second place, doing
    this can potentially lead to a memory leak, since usbcore might not
    realize there still is a current configuration that needs to be
    destroyed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 574d0d4b3401..5ad0d5e28119 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1149,6 +1149,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
+	if (device_is_registered(&amp;iface-&gt;dev))
+		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
 	iface-&gt;cur_altsetting = alt;
@@ -1184,6 +1186,8 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
 	usb_enable_interface(dev, iface);
+	if (device_is_registered(&amp;iface-&gt;dev))
+		usb_create_sysfs_intf_files(iface);
 
 	return 0;
 }
@@ -1233,10 +1237,8 @@ int usb_reset_configuration(struct usb_device *dev)
 			USB_REQ_SET_CONFIGURATION, 0,
 			config-&gt;desc.bConfigurationValue, 0,
 			NULL, 0, USB_CTRL_SET_TIMEOUT);
-	if (retval &lt; 0) {
-		usb_set_device_state(dev, USB_STATE_ADDRESS);
+	if (retval &lt; 0)
 		return retval;
-	}
 
 	dev-&gt;toggle[0] = dev-&gt;toggle[1] = 0;
 
@@ -1245,6 +1247,8 @@ int usb_reset_configuration(struct usb_device *dev)
 		struct usb_interface *intf = config-&gt;interface[i];
 		struct usb_host_interface *alt;
 
+		if (device_is_registered(&amp;intf-&gt;dev))
+			usb_remove_sysfs_intf_files(intf);
 		alt = usb_altnum_to_altsetting(intf, 0);
 
 		/* No altsetting 0?  We'll assume the first altsetting.
@@ -1257,6 +1261,8 @@ int usb_reset_configuration(struct usb_device *dev)
 
 		intf-&gt;cur_altsetting = alt;
 		usb_enable_interface(dev, intf);
+		if (device_is_registered(&amp;intf-&gt;dev))
+			usb_create_sysfs_intf_files(intf);
 	}
 	return 0;
 }</pre><hr><pre>commit be69e5b1900a19a545becda822b18d6f09168ba5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 25 15:56:06 2005 -0400

    [PATCH] usbcore: Improve endpoint sysfs file handling
    
    This revised patch (as587b) improves the implementation of USB endpoint
    sysfs files.  Instead of storing a whole bunch of attributes for every
    single endpoint, each endpoint now gets its own kobject and they can
    share a static list of attributes.  The number of extra fields added to
    struct usb_host_endpoint has been reduced from 4 to 1.
    
    The bEndpointAddress field is retained even though it is redundant (it
    repeats the same information as the attributes' directory name).  The
    code avoids calling kobject_register, to prevent generating unwanted
    hotplug events.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 4bdbc9df6e03..f18317fb49ee 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -23,43 +23,56 @@
 #include "usb.h"
 
 /* endpoint stuff */
-struct endpoint_attribute {
-	struct device_attribute dev_attr;
-	struct usb_endpoint_descriptor *endpoint;
+struct ep_object {
+	struct usb_endpoint_descriptor *desc;
 	struct usb_device *udev;
+	struct kobject kobj;
 };
-#define to_endpoint_attr(_dev_attr) \
-	container_of(_dev_attr, struct endpoint_attribute, dev_attr)
-
-#define usb_ep_attr(field, format_string)					\
-static ssize_t show_ep_##field(struct device *dev, struct device_attribute *attr,	\
-			    char *buf)						\
-{										\
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);	\
-										\
-	return sprintf(buf, format_string, endpoint_attr-&gt;endpoint-&gt;field);	\
-}
+#define to_ep_object(_kobj) \
+	container_of(_kobj, struct ep_object, kobj)
+
+struct ep_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct usb_device *,
+			struct usb_endpoint_descriptor *, char *);
+};
+#define to_ep_attribute(_attr) \
+	container_of(_attr, struct ep_attribute, attr)
+
+#define EP_ATTR(_name)						\
+struct ep_attribute ep_##_name = {				\
+	.attr = {.name = #_name, .owner = THIS_MODULE,		\
+			.mode = S_IRUGO},			\
+	.show = show_ep_##_name}
+
+#define usb_ep_attr(field, format_string)			\
+static ssize_t show_ep_##field(struct usb_device *udev,		\
+		struct usb_endpoint_descriptor *desc, 		\
+		char *buf)					\
+{								\
+	return sprintf(buf, format_string, desc-&gt;field);	\
+}								\
+static EP_ATTR(field);
+
 usb_ep_attr(bLength, "%02x\n")
-usb_ep_attr(bDescriptorType, "%02x\n")
 usb_ep_attr(bEndpointAddress, "%02x\n")
 usb_ep_attr(bmAttributes, "%02x\n")
 usb_ep_attr(bInterval, "%02x\n")
 
-static ssize_t show_ep_wMaxPacketSize(struct device *dev,
-				      struct device_attribute *attr, char *buf)
+static ssize_t show_ep_wMaxPacketSize(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
-
 	return sprintf(buf, "%04x\n",
-		      le16_to_cpu(endpoint_attr-&gt;endpoint-&gt;wMaxPacketSize) &amp; 0x07ff);
+			le16_to_cpu(desc-&gt;wMaxPacketSize) &amp; 0x07ff);
 }
+static EP_ATTR(wMaxPacketSize);
 
-static ssize_t show_ep_type(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_ep_type(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
 	char *type = "unknown";
 
-	switch (endpoint_attr-&gt;endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
+	switch (desc-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
 	case USB_ENDPOINT_XFER_CONTROL:
 		type = "Control";
 		break;
@@ -75,35 +88,34 @@ static ssize_t show_ep_type(struct device *dev, struct device_attribute *attr, c
 	}
 	return sprintf(buf, "%s\n", type);
 }
+static EP_ATTR(type);
 
-static ssize_t show_ep_interval(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_ep_interval(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
-	struct usb_device *udev = endpoint_attr-&gt;udev;
-	struct usb_endpoint_descriptor *endpoint = endpoint_attr-&gt;endpoint;
 	char unit;
 	unsigned interval = 0;
 	unsigned in;
 
-	in = (endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN);
+	in = (desc-&gt;bEndpointAddress &amp; USB_DIR_IN);
 
-	switch (endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
+	switch (desc-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) {
 	case USB_ENDPOINT_XFER_CONTROL:
 		if (udev-&gt;speed == USB_SPEED_HIGH) 	/* uframes per NAK */
-			interval = endpoint-&gt;bInterval;
+			interval = desc-&gt;bInterval;
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
-		interval = 1 &lt;&lt; (endpoint-&gt;bInterval - 1);
+		interval = 1 &lt;&lt; (desc-&gt;bInterval - 1);
 		break;
 	case USB_ENDPOINT_XFER_BULK:
-		if (udev-&gt;speed == USB_SPEED_HIGH &amp;&amp; !in)	/* uframes per NAK */
-			interval = endpoint-&gt;bInterval;
+		if (udev-&gt;speed == USB_SPEED_HIGH &amp;&amp; !in) /* uframes per NAK */
+			interval = desc-&gt;bInterval;
 		break;
 	case USB_ENDPOINT_XFER_INT:
-		if (udev-&gt;speed == USB_SPEED_HIGH) {
-			interval = 1 &lt;&lt; (endpoint-&gt;bInterval - 1);
-		} else
-			interval = endpoint-&gt;bInterval;
+		if (udev-&gt;speed == USB_SPEED_HIGH)
+			interval = 1 &lt;&lt; (desc-&gt;bInterval - 1);
+		else
+			interval = desc-&gt;bInterval;
 		break;
 	}
 	interval *= (udev-&gt;speed == USB_SPEED_HIGH) ? 125 : 1000;
@@ -116,78 +128,95 @@ static ssize_t show_ep_interval(struct device *dev, struct device_attribute *att
 
 	return sprintf(buf, "%d%cs\n", interval, unit);
 }
+static EP_ATTR(interval);
 
-static ssize_t show_ep_direction(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t show_ep_direction(struct usb_device *udev,
+		struct usb_endpoint_descriptor *desc, char *buf)
 {
-	struct endpoint_attribute *endpoint_attr = to_endpoint_attr(attr);
 	char *direction;
 
-	if ((endpoint_attr-&gt;endpoint-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
-	    USB_ENDPOINT_XFER_CONTROL)
+	if ((desc-&gt;bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
+			USB_ENDPOINT_XFER_CONTROL)
 		direction = "both";
-	else if (endpoint_attr-&gt;endpoint-&gt;bEndpointAddress &amp; USB_DIR_IN)
+	else if (desc-&gt;bEndpointAddress &amp; USB_DIR_IN)
 		direction = "in";
 	else
 		direction = "out";
 	return sprintf(buf, "%s\n", direction);
 }
+static EP_ATTR(direction);
+
+static struct attribute *ep_attrs[] = {
+	&amp;ep_bLength.attr,
+	&amp;ep_bEndpointAddress.attr,
+	&amp;ep_bmAttributes.attr,
+	&amp;ep_bInterval.attr,
+	&amp;ep_wMaxPacketSize.attr,
+	&amp;ep_type.attr,
+	&amp;ep_interval.attr,
+	&amp;ep_direction.attr,
+	NULL,
+};
 
-static struct endpoint_attribute *create_ep_attr(struct usb_endpoint_descriptor *endpoint,
-						 struct usb_device *udev, char *name,
-		ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf))
+static void ep_object_release(struct kobject *kobj)
 {
-	struct endpoint_attribute *ep_attr;
-
-	ep_attr = kzalloc(sizeof(*ep_attr), GFP_KERNEL);
-	if (ep_attr) {
-		ep_attr-&gt;endpoint = endpoint;
-		ep_attr-&gt;udev = udev;
-		ep_attr-&gt;dev_attr.attr.name = name;
-		ep_attr-&gt;dev_attr.attr.mode = 0444;
-		ep_attr-&gt;dev_attr.attr.owner = THIS_MODULE;
-		ep_attr-&gt;dev_attr.show = show;
-	}
-	return ep_attr;
+	kfree(to_ep_object(kobj));
 }
 
-static void usb_create_ep_files(struct kobject *kobj, struct usb_host_endpoint *endpoint, struct usb_device *udev)
+static ssize_t ep_object_show(struct kobject *kobj, struct attribute *attr,
+		char *buf)
 {
-	struct usb_endpoint_descriptor *ep;
-
-	ep = &amp;endpoint-&gt;desc;
-
-	endpoint-&gt;attrs = kzalloc(sizeof(struct attribute *) * 10, GFP_KERNEL);
-	endpoint-&gt;attrs[0] = &amp;(create_ep_attr(ep, udev, "direction", show_ep_direction)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[1] = &amp;(create_ep_attr(ep, udev, "type", show_ep_type)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[2] = &amp;(create_ep_attr(ep, udev, "bLength", show_ep_bLength)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[3] = &amp;(create_ep_attr(ep, udev, "bDescriptorType", show_ep_bDescriptorType)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[4] = &amp;(create_ep_attr(ep, udev, "bEndpointAddress", show_ep_bEndpointAddress)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[5] = &amp;(create_ep_attr(ep, udev, "bmAttributes", show_ep_bmAttributes)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[6] = &amp;(create_ep_attr(ep, udev, "wMaxPacketSize", show_ep_wMaxPacketSize)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[7] = &amp;(create_ep_attr(ep, udev, "bInterval", show_ep_bInterval)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[8] = &amp;(create_ep_attr(ep, udev, "interval", show_ep_interval)-&gt;dev_attr.attr);
-	endpoint-&gt;attrs[9] = NULL;
-	endpoint-&gt;num_attrs = 9;
-
-	endpoint-&gt;attr_group = kzalloc(sizeof(*endpoint-&gt;attr_group), GFP_KERNEL);
-	endpoint-&gt;attr_name = kzalloc(10, GFP_KERNEL);
-	sprintf(endpoint-&gt;attr_name, "ep_%02x", endpoint-&gt;desc.bEndpointAddress);
-
-	endpoint-&gt;attr_group-&gt;attrs = endpoint-&gt;attrs;
-	endpoint-&gt;attr_group-&gt;name = endpoint-&gt;attr_name;
-	sysfs_create_group(kobj, endpoint-&gt;attr_group);
+	struct ep_object *ep_obj = to_ep_object(kobj);
+	struct ep_attribute *ep_attr = to_ep_attribute(attr);
+
+	return (ep_attr-&gt;show)(ep_obj-&gt;udev, ep_obj-&gt;desc, buf);
 }
 
-static void usb_remove_ep_files(struct kobject *kobj, struct usb_host_endpoint *endpoint)
+static struct sysfs_ops ep_object_sysfs_ops = {
+	.show =			ep_object_show,
+};
+
+static struct kobj_type ep_object_ktype = {
+	.release =		ep_object_release,
+	.sysfs_ops =		&amp;ep_object_sysfs_ops,
+	.default_attrs =	ep_attrs,
+};
+
+static void usb_create_ep_files(struct kobject *parent,
+		struct usb_host_endpoint *endpoint,
+		struct usb_device *udev)
 {
-	int i;
+	struct ep_object *ep_obj;
+	struct kobject *kobj;
+
+	ep_obj = kzalloc(sizeof(struct ep_object), GFP_KERNEL);
+	if (!ep_obj)
+		return;
 
-	sysfs_remove_group(kobj, endpoint-&gt;attr_group);
-	kfree(endpoint-&gt;attr_group);
-	kfree(endpoint-&gt;attr_name);
-	for (i = 0; i &lt; endpoint-&gt;num_attrs; ++i)
-		kfree(endpoint-&gt;attrs[i]);
-	kfree(endpoint-&gt;attrs);
+	ep_obj-&gt;desc = &amp;endpoint-&gt;desc;
+	ep_obj-&gt;udev = udev;
+
+	kobj = &amp;ep_obj-&gt;kobj;
+	kobject_set_name(kobj, "ep_%02x", endpoint-&gt;desc.bEndpointAddress);
+	kobj-&gt;parent = parent;
+	kobj-&gt;ktype = &amp;ep_object_ktype;
+
+	/* Don't use kobject_register, because it generates a hotplug event */
+	kobject_init(kobj);
+	if (kobject_add(kobj) == 0)
+		endpoint-&gt;kobj = kobj;
+	else
+		kobject_put(kobj);
+}
+
+static void usb_remove_ep_files(struct usb_host_endpoint *endpoint)
+{
+
+	if (endpoint-&gt;kobj) {
+		kobject_del(endpoint-&gt;kobj);
+		kobject_put(endpoint-&gt;kobj);
+		endpoint-&gt;kobj = NULL;
+	}
 }
 
 /* Active configuration fields */
@@ -411,7 +440,7 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 {
 	struct device *dev = &amp;udev-&gt;dev;
 
-	usb_remove_ep_files(&amp;dev-&gt;kobj, &amp;udev-&gt;ep0);
+	usb_remove_ep_files(&amp;udev-&gt;ep0);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 
 	if (udev-&gt;descriptor.iManufacturer)
@@ -496,7 +525,7 @@ static struct attribute_group intf_attr_grp = {
 	.attrs = intf_attrs,
 };
 
-static void usb_create_intf_ep_files(struct usb_interface *intf)
+static inline void usb_create_intf_ep_files(struct usb_interface *intf)
 {
 	struct usb_host_interface *iface_desc;
 	int i;
@@ -504,17 +533,17 @@ static void usb_create_intf_ep_files(struct usb_interface *intf)
 	iface_desc = intf-&gt;cur_altsetting;
 	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i)
 		usb_create_ep_files(&amp;intf-&gt;dev.kobj, &amp;iface_desc-&gt;endpoint[i],
-				    interface_to_usbdev(intf));
+				interface_to_usbdev(intf));
 }
 
-static void usb_remove_intf_ep_files(struct usb_interface *intf)
+static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
 {
 	struct usb_host_interface *iface_desc;
 	int i;
 
 	iface_desc = intf-&gt;cur_altsetting;
 	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i)
-		usb_remove_ep_files(&amp;intf-&gt;dev.kobj, &amp;iface_desc-&gt;endpoint[i]);
+		usb_remove_ep_files(&amp;iface_desc-&gt;endpoint[i]);
 }
 
 void usb_create_sysfs_intf_files (struct usb_interface *intf)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index a2d923fd54f9..465ff4585ca5 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -57,10 +57,7 @@ struct usb_host_endpoint {
 	struct usb_endpoint_descriptor	desc;
 	struct list_head		urb_list;
 	void				*hcpriv;
-	char 				*attr_name;
-	struct attribute_group		*attr_group;
-	struct attribute 		**attrs;
-	int				num_attrs;
+	struct kobject			*kobj;	/* For sysfs info */
 
 	unsigned char *extra;   /* Extra descriptors */
 	int extralen;</pre><hr><pre>commit 3f13e66e219238e025ff561d69826da9342c3f4a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:43:36 2005 -0700

    [PATCH] PATCH: usb-storage: use kthread API
    
    This patch is originally from Alan Stern (as569).  It has been rediffed
    against a current tree.
    
    This patch converts usb-storage to use the kthread API for creating its
    control and scanning threads.  The new code doesn't use kthread_stop
    because the threads need (or will need in the future) to exit
    asynchronously.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index c1a902691bc6..3847ebed2aa4 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -54,6 +54,7 @@
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/slab.h&gt;
+#include &lt;linux/kthread.h&gt;
 
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_cmnd.h&gt;
@@ -310,22 +311,7 @@ static int usb_stor_control_thread(void * __us)
 	struct us_data *us = (struct us_data *)__us;
 	struct Scsi_Host *host = us_to_host(us);
 
-	lock_kernel();
-
-	/*
-	 * This thread doesn't need any user-level access,
-	 * so get rid of all our resources.
-	 */
-	daemonize("usb-storage");
 	current-&gt;flags |= PF_NOFREEZE;
-	unlock_kernel();
-
-	/* acquire a reference to the host, so it won't be deallocated
-	 * until we're ready to exit */
-	scsi_host_get(host);
-
-	/* signal that we've started the thread */
-	complete(&amp;(us-&gt;notify));
 
 	for(;;) {
 		US_DEBUGP("*** thread sleeping.\n");
@@ -768,6 +754,7 @@ static int get_pipes(struct us_data *us)
 static int usb_stor_acquire_resources(struct us_data *us)
 {
 	int p;
+	struct task_struct *th;
 
 	us-&gt;current_urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!us-&gt;current_urb) {
@@ -784,17 +771,19 @@ static int usb_stor_acquire_resources(struct us_data *us)
 	}
 
 	/* Start up our control thread */
-	p = kernel_thread(usb_stor_control_thread, us, CLONE_VM);
-	if (p &lt; 0) {
+	th = kthread_create(usb_stor_control_thread, us, "usb-storage");
+	if (IS_ERR(th)) {
 		printk(KERN_WARNING USB_STORAGE 
 		       "Unable to start control thread\n");
-		return p;
+		return PTR_ERR(th);
 	}
-	us-&gt;pid = p;
-	atomic_inc(&amp;total_threads);
 
-	/* Wait for the thread to start */
-	wait_for_completion(&amp;(us-&gt;notify));
+	/* Take a reference to the host for the control thread and
+	 * count it among all the threads we have launched.  Then
+	 * start it up. */
+	scsi_host_get(us_to_host(us));
+	atomic_inc(&amp;total_threads);
+	wake_up_process(th);
 
 	return 0;
 }
@@ -890,21 +879,6 @@ static int usb_stor_scan_thread(void * __us)
 {
 	struct us_data *us = (struct us_data *)__us;
 
-	/*
-	 * This thread doesn't need any user-level access,
-	 * so get rid of all our resources.
-	 */
-	lock_kernel();
-	daemonize("usb-stor-scan");
-	unlock_kernel();
-
-	/* Acquire a reference to the host, so it won't be deallocated
-	 * until we're ready to exit */
-	scsi_host_get(us_to_host(us));
-
-	/* Signal that we've started the thread */
-	complete(&amp;(us-&gt;notify));
-
 	printk(KERN_DEBUG
 		"usb-storage: device found at %d\n", us-&gt;pusb_dev-&gt;devnum);
 
@@ -949,6 +923,7 @@ static int storage_probe(struct usb_interface *intf,
 	struct us_data *us;
 	const int id_index = id - storage_usb_ids; 
 	int result;
+	struct task_struct *th;
 
 	US_DEBUGP("USB Mass Storage device detected\n");
 
@@ -1029,17 +1004,21 @@ static int storage_probe(struct usb_interface *intf,
 	}
 
 	/* Start up the thread for delayed SCSI-device scanning */
-	result = kernel_thread(usb_stor_scan_thread, us, CLONE_VM);
-	if (result &lt; 0) {
+	th = kthread_create(usb_stor_scan_thread, us, "usb-stor-scan");
+	if (IS_ERR(th)) {
 		printk(KERN_WARNING USB_STORAGE 
 		       "Unable to start the device-scanning thread\n");
 		quiesce_and_remove_host(us);
+		result = PTR_ERR(th);
 		goto BadDevice;
 	}
-	atomic_inc(&amp;total_threads);
 
-	/* Wait for the thread to start */
-	wait_for_completion(&amp;(us-&gt;notify));
+	/* Take a reference to the host for the scanning thread and
+	 * count it among all the threads we have launched.  Then
+	 * start it up. */
+	scsi_host_get(us_to_host(us));
+	atomic_inc(&amp;total_threads);
+	wake_up_process(th);
 
 	return 0;
 
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index dfa4dc71dd3e..98b09711a739 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -161,9 +161,6 @@ struct us_data {
 	struct scsi_cmnd	*srb;		 /* current srb		*/
 	unsigned int		tag;		 /* current dCBWTag	*/
 
-	/* thread information */
-	int			pid;		 /* control thread	 */
-
 	/* control and bulk communications data */
 	struct urb		*current_urb;	 /* USB requests	 */
 	struct usb_ctrlrequest	*cr;		 /* control requests	 */</pre><hr><pre>commit ce2596df79ddbac605a290f4c7cf011cb40524fc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:41:39 2005 -0700

    [PATCH] PATCH: usb-storage: implement minimal PM
    
    This patch from Alan Stern started as as568.  It has been rediffed against
    a current tree.
    
    This patch adds minimal suspend/resume support to usb-storage.  Just enough
    for it to qualify as PM-aware.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index eb901817b7d2..c1a902691bc6 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -111,11 +111,6 @@ static atomic_t total_threads = ATOMIC_INIT(0);
 static DECLARE_COMPLETION(threads_gone);
 
 
-static int storage_probe(struct usb_interface *iface,
-			 const struct usb_device_id *id);
-
-static void storage_disconnect(struct usb_interface *iface);
-
 /* The entries in this table, except for final ones here
  * (USB_MASS_STORAGE_CLASS and the empty entry), correspond,
  * line for line with the entries of us_unsuaul_dev_list[].
@@ -233,13 +228,40 @@ static struct us_unusual_dev us_unusual_dev_list[] = {
 	{ NULL }
 };
 
-static struct usb_driver usb_storage_driver = {
-	.owner =	THIS_MODULE,
-	.name =		"usb-storage",
-	.probe =	storage_probe,
-	.disconnect =	storage_disconnect,
-	.id_table =	storage_usb_ids,
-};
+
+#ifdef CONFIG_PM	/* Minimal support for suspend and resume */
+
+static int storage_suspend(struct usb_interface *iface, pm_message_t message)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	/* Wait until no command is running */
+	down(&amp;us-&gt;dev_semaphore);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+	iface-&gt;dev.power.power_state.event = message.event;
+
+	/* When runtime PM is working, we'll set a flag to indicate
+	 * whether we should autoresume when a SCSI request arrives. */
+
+	up(&amp;us-&gt;dev_semaphore);
+	return 0;
+}
+
+static int storage_resume(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	down(&amp;us-&gt;dev_semaphore);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+	iface-&gt;dev.power.power_state.event = PM_EVENT_ON;
+
+	up(&amp;us-&gt;dev_semaphore);
+	return 0;
+}
+
+#endif /* CONFIG_PM */
 
 /*
  * fill_inquiry_response takes an unsigned char array (which must
@@ -1042,6 +1064,18 @@ static void storage_disconnect(struct usb_interface *intf)
  * Initialization and registration
  ***********************************************************************/
 
+static struct usb_driver usb_storage_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"usb-storage",
+	.probe =	storage_probe,
+	.disconnect =	storage_disconnect,
+#ifdef CONFIG_PM
+	.suspend =	storage_suspend,
+	.resume =	storage_resume,
+#endif
+	.id_table =	storage_usb_ids,
+};
+
 static int __init usb_stor_init(void)
 {
 	int retval;</pre>
    <div class="pagination">
        <a href='2_132.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><span>[133]</span><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_134.html'>Next&gt;&gt;</a>
    <div>
</body>
