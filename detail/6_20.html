<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_19.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><span>[20]</span><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_21.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fa78d2d1d64f147062e384a4a10a26a5f89944b5
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Feb 16 12:37:14 2022 +0800

    Bluetooth: fix data races in smp_unregister(), smp_del_chan()
    
    Previous commit e04480920d1e ("Bluetooth: defer cleanup of resources
    in hci_unregister_dev()") defers all destructive actions to
    hci_release_dev() to prevent cocurrent problems like NPD, UAF.
    
    However, there are still some exceptions that are ignored.
    
    The smp_unregister() in hci_dev_close_sync() (previously in
    hci_dev_do_close) will release resources like the sensitive channel
    and the smp_dev objects. Consider the situations the device is detaching
    or power down while the kernel is still operating on it, the following
    data race could take place.
    
    thread-A  hci_dev_close_sync  | thread-B  read_local_oob_ext_data
                                  |
    hci_dev_unlock()              |
    ...                           | hci_dev_lock()
    if (hdev-&gt;smp_data)           |
      chan = hdev-&gt;smp_data       |
                                  | chan = hdev-&gt;smp_data (3)
                                  |
      hdev-&gt;smp_data = NULL (1)   | if (!chan || !chan-&gt;data) (4)
      ...                         |
      smp = chan-&gt;data            | smp = chan-&gt;data
      if (smp)                    |
        chan-&gt;data = NULL (2)     |
        ...                       |
        kfree_sensitive(smp)      |
                                  | // dereference smp trigger UFA
    
    That is, the objects hdev-&gt;smp_data and chan-&gt;data both suffer from the
    data races. In a preempt-enable kernel, the above schedule (when (3) is
    before (1) and (4) is before (2)) leads to UAF bugs. It can be
    reproduced in the latest kernel and below is part of the report:
    
    [   49.097146] ================================================================
    [   49.097611] BUG: KASAN: use-after-free in smp_generate_oob+0x2dd/0x570
    [   49.097611] Read of size 8 at addr ffff888006528360 by task generate_oob/155
    [   49.097611]
    [   49.097611] Call Trace:
    [   49.097611]  &lt;TASK&gt;
    [   49.097611]  dump_stack_lvl+0x34/0x44
    [   49.097611]  print_address_description.constprop.0+0x1f/0x150
    [   49.097611]  ? smp_generate_oob+0x2dd/0x570
    [   49.097611]  ? smp_generate_oob+0x2dd/0x570
    [   49.097611]  kasan_report.cold+0x7f/0x11b
    [   49.097611]  ? smp_generate_oob+0x2dd/0x570
    [   49.097611]  smp_generate_oob+0x2dd/0x570
    [   49.097611]  read_local_oob_ext_data+0x689/0xc30
    [   49.097611]  ? hci_event_packet+0xc80/0xc80
    [   49.097611]  ? sysvec_apic_timer_interrupt+0x9b/0xc0
    [   49.097611]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20
    [   49.097611]  ? mgmt_init_hdev+0x1c/0x240
    [   49.097611]  ? mgmt_init_hdev+0x28/0x240
    [   49.097611]  hci_sock_sendmsg+0x1880/0x1e70
    [   49.097611]  ? create_monitor_event+0x890/0x890
    [   49.097611]  ? create_monitor_event+0x890/0x890
    [   49.097611]  sock_sendmsg+0xdf/0x110
    [   49.097611]  __sys_sendto+0x19e/0x270
    [   49.097611]  ? __ia32_sys_getpeername+0xa0/0xa0
    [   49.097611]  ? kernel_fpu_begin_mask+0x1c0/0x1c0
    [   49.097611]  __x64_sys_sendto+0xd8/0x1b0
    [   49.097611]  ? syscall_exit_to_user_mode+0x1d/0x40
    [   49.097611]  do_syscall_64+0x3b/0x90
    [   49.097611]  entry_SYSCALL_64_after_hwframe+0x44/0xae
    [   49.097611] RIP: 0033:0x7f5a59f51f64
    ...
    [   49.097611] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f5a59f51f64
    [   49.097611] RDX: 0000000000000007 RSI: 00007f5a59d6ac70 RDI: 0000000000000006
    [   49.097611] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
    [   49.097611] R10: 0000000000000040 R11: 0000000000000246 R12: 00007ffec26916ee
    [   49.097611] R13: 00007ffec26916ef R14: 00007f5a59d6afc0 R15: 00007f5a59d6b700
    
    To solve these data races, this patch places the smp_unregister()
    function in the protected area by the hci_dev_lock(). That is, the
    smp_unregister() function can not be concurrently executed when
    operating functions (most of them are mgmt operations in mgmt.c) hold
    the device lock.
    
    This patch is tested with kernel LOCK DEBUGGING enabled. The price from
    the extended holding time of the device lock is supposed to be low as the
    smp_unregister() function is fairly short and efficient.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: Marcel Holtmann &lt;marcel@holtmann.org&gt;

diff --git a/net/bluetooth/hci_sync.c b/net/bluetooth/hci_sync.c
index 0feb68f12545..e34fc15b7d2c 100644
--- a/net/bluetooth/hci_sync.c
+++ b/net/bluetooth/hci_sync.c
@@ -4106,9 +4106,9 @@ int hci_dev_close_sync(struct hci_dev *hdev)
 	hci_inquiry_cache_flush(hdev);
 	hci_pend_le_actions_clear(hdev);
 	hci_conn_hash_flush(hdev);
-	hci_dev_unlock(hdev);
-
+	/* Prevent data races on hdev-&gt;smp_data or hdev-&gt;smp_bredr_data */
 	smp_unregister(hdev);
+	hci_dev_unlock(hdev);
 
 	hci_sock_dev_event(hdev, HCI_DEV_DOWN);
 </pre><hr><pre>commit efe4186e6a1b54bf38b9e05450d43b0da1fd7739
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu Feb 17 09:43:03 2022 +0800

    drivers: hamradio: 6pack: fix UAF bug caused by mod_timer()
    
    When a 6pack device is detaching, the sixpack_close() will act to cleanup
    necessary resources. Although del_timer_sync() in sixpack_close()
    won't return if there is an active timer, one could use mod_timer() in
    sp_xmit_on_air() to wake up timer again by calling userspace syscall such
    as ax25_sendmsg(), ax25_connect() and ax25_ioctl().
    
    This unexpected waked handler, sp_xmit_on_air(), realizes nothing about
    the undergoing cleanup and may still call pty_write() to use driver layer
    resources that have already been released.
    
    One of the possible race conditions is shown below:
    
          (USE)                      |      (FREE)
    ax25_sendmsg()                   |
     ax25_queue_xmit()               |
      ...                            |
      sp_xmit()                      |
       sp_encaps()                   | sixpack_close()
        sp_xmit_on_air()             |  del_timer_sync(&amp;sp-&gt;tx_t)
         mod_timer(&amp;sp-&gt;tx_t,...)    |  ...
                                     |  unregister_netdev()
                                     |  ...
         (wait a while)              | tty_release()
                                     |  tty_release_struct()
                                     |   release_tty()
        sp_xmit_on_air()             |    tty_kref_put(tty_struct) //FREE
         pty_write(tty_struct) //USE |    ...
    
    The corresponding fail log is shown below:
    ===============================================================
    BUG: KASAN: use-after-free in __run_timers.part.0+0x170/0x470
    Write of size 8 at addr ffff88800a652ab8 by task swapper/2/0
    ...
    Call Trace:
      ...
      queue_work_on+0x3f/0x50
      pty_write+0xcd/0xe0pty_write+0xcd/0xe0
      sp_xmit_on_air+0xb2/0x1f0
      call_timer_fn+0x28/0x150
      __run_timers.part.0+0x3c2/0x470
      run_timer_softirq+0x3b/0x80
      __do_softirq+0xf1/0x380
      ...
    
    This patch reorders the del_timer_sync() after the unregister_netdev()
    to avoid UAF bugs. Because the unregister_netdev() is well synchronized,
    it flushs out any pending queues, waits the refcount of net_device
    decreases to zero and removes net_device from kernel. There is not any
    running routines after executing unregister_netdev(). Therefore, we could
    not arouse timer from userspace again.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/hamradio/6pack.c b/drivers/net/hamradio/6pack.c
index b1fc153125d9..45c3c4a1101b 100644
--- a/drivers/net/hamradio/6pack.c
+++ b/drivers/net/hamradio/6pack.c
@@ -668,11 +668,11 @@ static void sixpack_close(struct tty_struct *tty)
 	 */
 	netif_stop_queue(sp-&gt;dev);
 
+	unregister_netdev(sp-&gt;dev);
+
 	del_timer_sync(&amp;sp-&gt;tx_t);
 	del_timer_sync(&amp;sp-&gt;resync_t);
 
-	unregister_netdev(sp-&gt;dev);
-
 	/* Free all 6pack frame buffers after unreg. */
 	kfree(sp-&gt;rbuff);
 	kfree(sp-&gt;xbuff);</pre><hr><pre>commit feef318c855a361a1eccd880f33e88c460eb63b4
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Wed Feb 9 20:53:45 2022 +0800

    ax25: fix UAF bugs of net_device caused by rebinding operation
    
    The ax25_kill_by_device() will set s-&gt;ax25_dev = NULL and
    call ax25_disconnect() to change states of ax25_cb and
    sock, if we call ax25_bind() before ax25_kill_by_device().
    
    However, if we call ax25_bind() again between the window of
    ax25_kill_by_device() and ax25_dev_device_down(), the values
    and states changed by ax25_kill_by_device() will be reassigned.
    
    Finally, ax25_dev_device_down() will deallocate net_device.
    If we dereference net_device in syscall functions such as
    ax25_release(), ax25_sendmsg(), ax25_getsockopt(), ax25_getname()
    and ax25_info_show(), a UAF bug will occur.
    
    One of the possible race conditions is shown below:
    
          (USE)                   |      (FREE)
    ax25_bind()                   |
                                  |  ax25_kill_by_device()
    ax25_bind()                   |
    ax25_connect()                |    ...
                                  |  ax25_dev_device_down()
                                  |    ...
                                  |    dev_put_track(dev, ...) //FREE
    ax25_release()                |    ...
      ax25_send_control()         |
        alloc_skb()      //USE    |
    
    the corresponding fail log is shown below:
    ===============================================================
    BUG: KASAN: use-after-free in ax25_send_control+0x43/0x210
    ...
    Call Trace:
      ...
      ax25_send_control+0x43/0x210
      ax25_release+0x2db/0x3b0
      __sock_release+0x6d/0x120
      sock_close+0xf/0x20
      __fput+0x11f/0x420
      ...
    Allocated by task 1283:
      ...
      __kasan_kmalloc+0x81/0xa0
      alloc_netdev_mqs+0x5a/0x680
      mkiss_open+0x6c/0x380
      tty_ldisc_open+0x55/0x90
      ...
    Freed by task 1969:
      ...
      kfree+0xa3/0x2c0
      device_release+0x54/0xe0
      kobject_put+0xa5/0x120
      tty_ldisc_kill+0x3e/0x80
      ...
    
    In order to fix these UAF bugs caused by rebinding operation,
    this patch adds dev_hold_track() into ax25_bind() and
    corresponding dev_put_track() into ax25_kill_by_device().
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 3d87040d1bfc..d53cbb4e2503 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -91,6 +91,7 @@ static void ax25_kill_by_device(struct net_device *dev)
 			spin_unlock_bh(&amp;ax25_list_lock);
 			lock_sock(sk);
 			s-&gt;ax25_dev = NULL;
+			dev_put_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
 			ax25_dev_put(ax25_dev);
 			ax25_disconnect(s, ENETUNREACH);
 			release_sock(sk);
@@ -1116,8 +1117,10 @@ static int ax25_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 		}
 	}
 
-	if (ax25_dev != NULL)
+	if (ax25_dev) {
 		ax25_fillin_cb(ax25, ax25_dev);
+		dev_hold_track(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker, GFP_ATOMIC);
+	}
 
 done:
 	ax25_cb_add(ax25);</pre><hr><pre>commit 7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Tue Feb 8 23:40:00 2022 +0800

    ax25: fix NPD bug in ax25_disconnect
    
    The ax25_disconnect() in ax25_kill_by_device() is not
    protected by any locks, thus there is a race condition
    between ax25_disconnect() and ax25_destroy_socket().
    when ax25-&gt;sk is assigned as NULL by ax25_destroy_socket(),
    a NULL pointer dereference bug will occur if site (1) or (2)
    dereferences ax25-&gt;sk.
    
    ax25_kill_by_device()                | ax25_release()
      ax25_disconnect()                  |   ax25_destroy_socket()
        ...                              |
        if(ax25-&gt;sk != NULL)             |     ...
          ...                            |     ax25-&gt;sk = NULL;
          bh_lock_sock(ax25-&gt;sk); //(1)  |     ...
          ...                            |
          bh_unlock_sock(ax25-&gt;sk); //(2)|
    
    This patch moves ax25_disconnect() into lock_sock(), which can
    synchronize with ax25_destroy_socket() in ax25_release().
    
    Fail log:
    ===============================================================
    BUG: kernel NULL pointer dereference, address: 0000000000000088
    ...
    RIP: 0010:_raw_spin_lock+0x7e/0xd0
    ...
    Call Trace:
    ax25_disconnect+0xf6/0x220
    ax25_device_event+0x187/0x250
    raw_notifier_call_chain+0x5e/0x70
    dev_close_many+0x17d/0x230
    rollback_registered_many+0x1f1/0x950
    unregister_netdevice_queue+0x133/0x200
    unregister_netdev+0x13/0x20
    ...
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 3e49d28824ed..3d87040d1bfc 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -92,8 +92,8 @@ static void ax25_kill_by_device(struct net_device *dev)
 			lock_sock(sk);
 			s-&gt;ax25_dev = NULL;
 			ax25_dev_put(ax25_dev);
-			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
+			release_sock(sk);
 			spin_lock_bh(&amp;ax25_list_lock);
 			sock_put(sk);
 			/* The entry could have been deleted from the</pre><hr><pre>commit 87563a043cef044fed5db7967a75741cc16ad2b1
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu Feb 3 23:08:11 2022 +0800

    ax25: fix reference count leaks of ax25_dev
    
    The previous commit d01ffb9eee4a ("ax25: add refcount in ax25_dev
    to avoid UAF bugs") introduces refcount into ax25_dev, but there
    are reference leak paths in ax25_ctl_ioctl(), ax25_fwd_ioctl(),
    ax25_rt_add(), ax25_rt_del() and ax25_rt_opt().
    
    This patch uses ax25_dev_put() and adjusts the position of
    ax25_addr_ax25dev() to fix reference cout leaks of ax25_dev.
    
    Fixes: d01ffb9eee4a ("ax25: add refcount in ax25_dev to avoid UAF bugs")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Dan Carpenter &lt;dan.carpenter@oracle.com&gt;
    Link: https://lore.kernel.org/r/20220203150811.42256-1-duoming@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/include/net/ax25.h b/include/net/ax25.h
index 50b417df6221..8221af1811df 100644
--- a/include/net/ax25.h
+++ b/include/net/ax25.h
@@ -294,10 +294,12 @@ static __inline__ void ax25_cb_put(ax25_cb *ax25)
 	}
 }
 
-#define ax25_dev_hold(__ax25_dev) \
-	refcount_inc(&amp;((__ax25_dev)-&gt;refcount))
+static inline void ax25_dev_hold(ax25_dev *ax25_dev)
+{
+	refcount_inc(&amp;ax25_dev-&gt;refcount);
+}
 
-static __inline__ void ax25_dev_put(ax25_dev *ax25_dev)
+static inline void ax25_dev_put(ax25_dev *ax25_dev)
 {
 	if (refcount_dec_and_test(&amp;ax25_dev-&gt;refcount)) {
 		kfree(ax25_dev);
diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 32f61978ff29..3e49d28824ed 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -359,21 +359,25 @@ static int ax25_ctl_ioctl(const unsigned int cmd, void __user *arg)
 	if (copy_from_user(&amp;ax25_ctl, arg, sizeof(ax25_ctl)))
 		return -EFAULT;
 
-	if ((ax25_dev = ax25_addr_ax25dev(&amp;ax25_ctl.port_addr)) == NULL)
-		return -ENODEV;
-
 	if (ax25_ctl.digi_count &gt; AX25_MAX_DIGIS)
 		return -EINVAL;
 
 	if (ax25_ctl.arg &gt; ULONG_MAX / HZ &amp;&amp; ax25_ctl.cmd != AX25_KILL)
 		return -EINVAL;
 
+	ax25_dev = ax25_addr_ax25dev(&amp;ax25_ctl.port_addr);
+	if (!ax25_dev)
+		return -ENODEV;
+
 	digi.ndigi = ax25_ctl.digi_count;
 	for (k = 0; k &lt; digi.ndigi; k++)
 		digi.calls[k] = ax25_ctl.digi_addr[k];
 
-	if ((ax25 = ax25_find_cb(&amp;ax25_ctl.source_addr, &amp;ax25_ctl.dest_addr, &amp;digi, ax25_dev-&gt;dev)) == NULL)
+	ax25 = ax25_find_cb(&amp;ax25_ctl.source_addr, &amp;ax25_ctl.dest_addr, &amp;digi, ax25_dev-&gt;dev);
+	if (!ax25) {
+		ax25_dev_put(ax25_dev);
 		return -ENOTCONN;
+	}
 
 	switch (ax25_ctl.cmd) {
 	case AX25_KILL:
diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index 770b787fb7bb..d2a244e1c260 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -85,8 +85,8 @@ void ax25_dev_device_up(struct net_device *dev)
 	spin_lock_bh(&amp;ax25_dev_lock);
 	ax25_dev-&gt;next = ax25_dev_list;
 	ax25_dev_list  = ax25_dev;
-	ax25_dev_hold(ax25_dev);
 	spin_unlock_bh(&amp;ax25_dev_lock);
+	ax25_dev_hold(ax25_dev);
 
 	ax25_register_dev_sysctl(ax25_dev);
 }
@@ -115,8 +115,8 @@ void ax25_dev_device_down(struct net_device *dev)
 
 	if ((s = ax25_dev_list) == ax25_dev) {
 		ax25_dev_list = s-&gt;next;
-		ax25_dev_put(ax25_dev);
 		spin_unlock_bh(&amp;ax25_dev_lock);
+		ax25_dev_put(ax25_dev);
 		dev-&gt;ax25_ptr = NULL;
 		dev_put_track(dev, &amp;ax25_dev-&gt;dev_tracker);
 		ax25_dev_put(ax25_dev);
@@ -126,8 +126,8 @@ void ax25_dev_device_down(struct net_device *dev)
 	while (s != NULL &amp;&amp; s-&gt;next != NULL) {
 		if (s-&gt;next == ax25_dev) {
 			s-&gt;next = ax25_dev-&gt;next;
-			ax25_dev_put(ax25_dev);
 			spin_unlock_bh(&amp;ax25_dev_lock);
+			ax25_dev_put(ax25_dev);
 			dev-&gt;ax25_ptr = NULL;
 			dev_put_track(dev, &amp;ax25_dev-&gt;dev_tracker);
 			ax25_dev_put(ax25_dev);
@@ -150,25 +150,35 @@ int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
 
 	switch (cmd) {
 	case SIOCAX25ADDFWD:
-		if ((fwd_dev = ax25_addr_ax25dev(&amp;fwd-&gt;port_to)) == NULL)
+		fwd_dev = ax25_addr_ax25dev(&amp;fwd-&gt;port_to);
+		if (!fwd_dev) {
+			ax25_dev_put(ax25_dev);
 			return -EINVAL;
-		if (ax25_dev-&gt;forward != NULL)
+		}
+		if (ax25_dev-&gt;forward) {
+			ax25_dev_put(fwd_dev);
+			ax25_dev_put(ax25_dev);
 			return -EINVAL;
+		}
 		ax25_dev-&gt;forward = fwd_dev-&gt;dev;
 		ax25_dev_put(fwd_dev);
+		ax25_dev_put(ax25_dev);
 		break;
 
 	case SIOCAX25DELFWD:
-		if (ax25_dev-&gt;forward == NULL)
+		if (!ax25_dev-&gt;forward) {
+			ax25_dev_put(ax25_dev);
 			return -EINVAL;
+		}
 		ax25_dev-&gt;forward = NULL;
+		ax25_dev_put(ax25_dev);
 		break;
 
 	default:
+		ax25_dev_put(ax25_dev);
 		return -EINVAL;
 	}
 
-	ax25_dev_put(ax25_dev);
 	return 0;
 }
 
diff --git a/net/ax25/ax25_route.c b/net/ax25/ax25_route.c
index 1e32693833e5..9751207f7757 100644
--- a/net/ax25/ax25_route.c
+++ b/net/ax25/ax25_route.c
@@ -75,11 +75,13 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 	ax25_dev *ax25_dev;
 	int i;
 
-	if ((ax25_dev = ax25_addr_ax25dev(&amp;route-&gt;port_addr)) == NULL)
-		return -EINVAL;
 	if (route-&gt;digi_count &gt; AX25_MAX_DIGIS)
 		return -EINVAL;
 
+	ax25_dev = ax25_addr_ax25dev(&amp;route-&gt;port_addr);
+	if (!ax25_dev)
+		return -EINVAL;
+
 	write_lock_bh(&amp;ax25_route_lock);
 
 	ax25_rt = ax25_route_list;
@@ -91,6 +93,7 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 			if (route-&gt;digi_count != 0) {
 				if ((ax25_rt-&gt;digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
 					write_unlock_bh(&amp;ax25_route_lock);
+					ax25_dev_put(ax25_dev);
 					return -ENOMEM;
 				}
 				ax25_rt-&gt;digipeat-&gt;lastrepeat = -1;
@@ -101,6 +104,7 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 				}
 			}
 			write_unlock_bh(&amp;ax25_route_lock);
+			ax25_dev_put(ax25_dev);
 			return 0;
 		}
 		ax25_rt = ax25_rt-&gt;next;
@@ -108,6 +112,7 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 
 	if ((ax25_rt = kmalloc(sizeof(ax25_route), GFP_ATOMIC)) == NULL) {
 		write_unlock_bh(&amp;ax25_route_lock);
+		ax25_dev_put(ax25_dev);
 		return -ENOMEM;
 	}
 
@@ -116,11 +121,11 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 	ax25_rt-&gt;dev          = ax25_dev-&gt;dev;
 	ax25_rt-&gt;digipeat     = NULL;
 	ax25_rt-&gt;ip_mode      = ' ';
-	ax25_dev_put(ax25_dev);
 	if (route-&gt;digi_count != 0) {
 		if ((ax25_rt-&gt;digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
 			write_unlock_bh(&amp;ax25_route_lock);
 			kfree(ax25_rt);
+			ax25_dev_put(ax25_dev);
 			return -ENOMEM;
 		}
 		ax25_rt-&gt;digipeat-&gt;lastrepeat = -1;
@@ -133,6 +138,7 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 	ax25_rt-&gt;next   = ax25_route_list;
 	ax25_route_list = ax25_rt;
 	write_unlock_bh(&amp;ax25_route_lock);
+	ax25_dev_put(ax25_dev);
 
 	return 0;
 }
@@ -173,8 +179,8 @@ static int ax25_rt_del(struct ax25_routes_struct *route)
 			}
 		}
 	}
-	ax25_dev_put(ax25_dev);
 	write_unlock_bh(&amp;ax25_route_lock);
+	ax25_dev_put(ax25_dev);
 
 	return 0;
 }
@@ -216,8 +222,8 @@ static int ax25_rt_opt(struct ax25_route_opt_struct *rt_option)
 	}
 
 out:
-	ax25_dev_put(ax25_dev);
 	write_unlock_bh(&amp;ax25_route_lock);
+	ax25_dev_put(ax25_dev);
 	return err;
 }
 </pre><hr><pre>commit d01ffb9eee4af165d83b08dd73ebdf9fe94a519b
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Fri Jan 28 12:47:16 2022 +0800

    ax25: add refcount in ax25_dev to avoid UAF bugs
    
    If we dereference ax25_dev after we call kfree(ax25_dev) in
    ax25_dev_device_down(), it will lead to concurrency UAF bugs.
    There are eight syscall functions suffer from UAF bugs, include
    ax25_bind(), ax25_release(), ax25_connect(), ax25_ioctl(),
    ax25_getname(), ax25_sendmsg(), ax25_getsockopt() and
    ax25_info_show().
    
    One of the concurrency UAF can be shown as below:
    
      (USE)                       |    (FREE)
                                  |  ax25_device_event
                                  |    ax25_dev_device_down
    ax25_bind                     |    ...
      ...                         |      kfree(ax25_dev)
      ax25_fillin_cb()            |    ...
        ax25_fillin_cb_from_dev() |
      ...                         |
    
    The root cause of UAF bugs is that kfree(ax25_dev) in
    ax25_dev_device_down() is not protected by any locks.
    When ax25_dev, which there are still pointers point to,
    is released, the concurrency UAF bug will happen.
    
    This patch introduces refcount into ax25_dev in order to
    guarantee that there are no pointers point to it when ax25_dev
    is released.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/include/net/ax25.h b/include/net/ax25.h
index 526e49589197..50b417df6221 100644
--- a/include/net/ax25.h
+++ b/include/net/ax25.h
@@ -239,6 +239,7 @@ typedef struct ax25_dev {
 #if defined(CONFIG_AX25_DAMA_SLAVE) || defined(CONFIG_AX25_DAMA_MASTER)
 	ax25_dama_info		dama;
 #endif
+	refcount_t		refcount;
 } ax25_dev;
 
 typedef struct ax25_cb {
@@ -293,6 +294,15 @@ static __inline__ void ax25_cb_put(ax25_cb *ax25)
 	}
 }
 
+#define ax25_dev_hold(__ax25_dev) \
+	refcount_inc(&amp;((__ax25_dev)-&gt;refcount))
+
+static __inline__ void ax25_dev_put(ax25_dev *ax25_dev)
+{
+	if (refcount_dec_and_test(&amp;ax25_dev-&gt;refcount)) {
+		kfree(ax25_dev);
+	}
+}
 static inline __be16 ax25_type_trans(struct sk_buff *skb, struct net_device *dev)
 {
 	skb-&gt;dev      = dev;
diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 44a8730c26ac..32f61978ff29 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -91,6 +91,7 @@ static void ax25_kill_by_device(struct net_device *dev)
 			spin_unlock_bh(&amp;ax25_list_lock);
 			lock_sock(sk);
 			s-&gt;ax25_dev = NULL;
+			ax25_dev_put(ax25_dev);
 			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&amp;ax25_list_lock);
@@ -439,6 +440,7 @@ static int ax25_ctl_ioctl(const unsigned int cmd, void __user *arg)
 	  }
 
 out_put:
+	ax25_dev_put(ax25_dev);
 	ax25_cb_put(ax25);
 	return ret;
 
diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index 256fadb94df3..770b787fb7bb 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -37,6 +37,7 @@ ax25_dev *ax25_addr_ax25dev(ax25_address *addr)
 	for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev-&gt;next)
 		if (ax25cmp(addr, (const ax25_address *)ax25_dev-&gt;dev-&gt;dev_addr) == 0) {
 			res = ax25_dev;
+			ax25_dev_hold(ax25_dev);
 		}
 	spin_unlock_bh(&amp;ax25_dev_lock);
 
@@ -56,6 +57,7 @@ void ax25_dev_device_up(struct net_device *dev)
 		return;
 	}
 
+	refcount_set(&amp;ax25_dev-&gt;refcount, 1);
 	dev-&gt;ax25_ptr     = ax25_dev;
 	ax25_dev-&gt;dev     = dev;
 	dev_hold_track(dev, &amp;ax25_dev-&gt;dev_tracker, GFP_ATOMIC);
@@ -83,6 +85,7 @@ void ax25_dev_device_up(struct net_device *dev)
 	spin_lock_bh(&amp;ax25_dev_lock);
 	ax25_dev-&gt;next = ax25_dev_list;
 	ax25_dev_list  = ax25_dev;
+	ax25_dev_hold(ax25_dev);
 	spin_unlock_bh(&amp;ax25_dev_lock);
 
 	ax25_register_dev_sysctl(ax25_dev);
@@ -112,20 +115,22 @@ void ax25_dev_device_down(struct net_device *dev)
 
 	if ((s = ax25_dev_list) == ax25_dev) {
 		ax25_dev_list = s-&gt;next;
+		ax25_dev_put(ax25_dev);
 		spin_unlock_bh(&amp;ax25_dev_lock);
 		dev-&gt;ax25_ptr = NULL;
 		dev_put_track(dev, &amp;ax25_dev-&gt;dev_tracker);
-		kfree(ax25_dev);
+		ax25_dev_put(ax25_dev);
 		return;
 	}
 
 	while (s != NULL &amp;&amp; s-&gt;next != NULL) {
 		if (s-&gt;next == ax25_dev) {
 			s-&gt;next = ax25_dev-&gt;next;
+			ax25_dev_put(ax25_dev);
 			spin_unlock_bh(&amp;ax25_dev_lock);
 			dev-&gt;ax25_ptr = NULL;
 			dev_put_track(dev, &amp;ax25_dev-&gt;dev_tracker);
-			kfree(ax25_dev);
+			ax25_dev_put(ax25_dev);
 			return;
 		}
 
@@ -133,6 +138,7 @@ void ax25_dev_device_down(struct net_device *dev)
 	}
 	spin_unlock_bh(&amp;ax25_dev_lock);
 	dev-&gt;ax25_ptr = NULL;
+	ax25_dev_put(ax25_dev);
 }
 
 int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
@@ -149,6 +155,7 @@ int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
 		if (ax25_dev-&gt;forward != NULL)
 			return -EINVAL;
 		ax25_dev-&gt;forward = fwd_dev-&gt;dev;
+		ax25_dev_put(fwd_dev);
 		break;
 
 	case SIOCAX25DELFWD:
@@ -161,6 +168,7 @@ int ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)
 		return -EINVAL;
 	}
 
+	ax25_dev_put(ax25_dev);
 	return 0;
 }
 
diff --git a/net/ax25/ax25_route.c b/net/ax25/ax25_route.c
index d0b2e094bd55..1e32693833e5 100644
--- a/net/ax25/ax25_route.c
+++ b/net/ax25/ax25_route.c
@@ -116,6 +116,7 @@ static int __must_check ax25_rt_add(struct ax25_routes_struct *route)
 	ax25_rt-&gt;dev          = ax25_dev-&gt;dev;
 	ax25_rt-&gt;digipeat     = NULL;
 	ax25_rt-&gt;ip_mode      = ' ';
+	ax25_dev_put(ax25_dev);
 	if (route-&gt;digi_count != 0) {
 		if ((ax25_rt-&gt;digipeat = kmalloc(sizeof(ax25_digi), GFP_ATOMIC)) == NULL) {
 			write_unlock_bh(&amp;ax25_route_lock);
@@ -172,6 +173,7 @@ static int ax25_rt_del(struct ax25_routes_struct *route)
 			}
 		}
 	}
+	ax25_dev_put(ax25_dev);
 	write_unlock_bh(&amp;ax25_route_lock);
 
 	return 0;
@@ -214,6 +216,7 @@ static int ax25_rt_opt(struct ax25_route_opt_struct *rt_option)
 	}
 
 out:
+	ax25_dev_put(ax25_dev);
 	write_unlock_bh(&amp;ax25_route_lock);
 	return err;
 }</pre><hr><pre>commit 4e0f718daf97d47cf7dec122da1be970f145c809
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Fri Jan 28 12:47:15 2022 +0800

    ax25: improve the incomplete fix to avoid UAF and NPD bugs
    
    The previous commit 1ade48d0c27d ("ax25: NPD bug when detaching
    AX25 device") introduce lock_sock() into ax25_kill_by_device to
    prevent NPD bug. But the concurrency NPD or UAF bug will occur,
    when lock_sock() or release_sock() dereferences the ax25_cb-&gt;sock.
    
    The NULL pointer dereference bug can be shown as below:
    
    ax25_kill_by_device()        | ax25_release()
                                 |   ax25_destroy_socket()
                                 |     ax25_cb_del()
      ...                        |     ...
                                 |     ax25-&gt;sk=NULL;
      lock_sock(s-&gt;sk); //(1)    |
      s-&gt;ax25_dev = NULL;        |     ...
      release_sock(s-&gt;sk); //(2) |
      ...                        |
    
    The root cause is that the sock is set to null before dereference
    site (1) or (2). Therefore, this patch extracts the ax25_cb-&gt;sock
    in advance, and uses ax25_list_lock to protect it, which can synchronize
    with ax25_cb_del() and ensure the value of sock is not null before
    dereference sites.
    
    The concurrency UAF bug can be shown as below:
    
    ax25_kill_by_device()        | ax25_release()
                                 |   ax25_destroy_socket()
      ...                        |   ...
                                 |   sock_put(sk); //FREE
      lock_sock(s-&gt;sk); //(1)    |
      s-&gt;ax25_dev = NULL;        |   ...
      release_sock(s-&gt;sk); //(2) |
      ...                        |
    
    The root cause is that the sock is released before dereference
    site (1) or (2). Therefore, this patch uses sock_hold() to increase
    the refcount of sock and uses ax25_list_lock to protect it, which
    can synchronize with ax25_cb_del() in ax25_destroy_socket() and
    ensure the sock wil not be released before dereference sites.
    
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 02f43f3e2c56..44a8730c26ac 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -77,6 +77,7 @@ static void ax25_kill_by_device(struct net_device *dev)
 {
 	ax25_dev *ax25_dev;
 	ax25_cb *s;
+	struct sock *sk;
 
 	if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)
 		return;
@@ -85,13 +86,15 @@ static void ax25_kill_by_device(struct net_device *dev)
 again:
 	ax25_for_each(s, &amp;ax25_list) {
 		if (s-&gt;ax25_dev == ax25_dev) {
+			sk = s-&gt;sk;
+			sock_hold(sk);
 			spin_unlock_bh(&amp;ax25_list_lock);
-			lock_sock(s-&gt;sk);
+			lock_sock(sk);
 			s-&gt;ax25_dev = NULL;
-			release_sock(s-&gt;sk);
+			release_sock(sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&amp;ax25_list_lock);
-
+			sock_put(sk);
 			/* The entry could have been deleted from the
 			 * list meanwhile and thus the next pointer is
 			 * no longer valid.  Play it safe and restart</pre><hr><pre>commit 1ade48d0c27d5da1ccf4b583d8c5fc8b534a3ac8
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Fri Dec 17 10:29:41 2021 +0800

    ax25: NPD bug when detaching AX25 device
    
    The existing cleanup routine implementation is not well synchronized
    with the syscall routine. When a device is detaching, below race could
    occur.
    
    static int ax25_sendmsg(...) {
      ...
      lock_sock()
      ax25 = sk_to_ax25(sk);
      if (ax25-&gt;ax25_dev == NULL) // CHECK
      ...
      ax25_queue_xmit(skb, ax25-&gt;ax25_dev-&gt;dev); // USE
      ...
    }
    
    static void ax25_kill_by_device(...) {
      ...
      if (s-&gt;ax25_dev == ax25_dev) {
        s-&gt;ax25_dev = NULL;
        ...
    }
    
    Other syscall functions like ax25_getsockopt, ax25_getname,
    ax25_info_show also suffer from similar races. To fix them, this patch
    introduce lock_sock() into ax25_kill_by_device in order to guarantee
    that the nullify action in cleanup routine cannot proceed when another
    socket request is pending.
    
    Signed-off-by: Hanjie Wu &lt;nagi@zju.edu.cn&gt;
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c
index 2f34bbdde0e8..cfca99e295b8 100644
--- a/net/ax25/af_ax25.c
+++ b/net/ax25/af_ax25.c
@@ -85,8 +85,10 @@ static void ax25_kill_by_device(struct net_device *dev)
 again:
 	ax25_for_each(s, &amp;ax25_list) {
 		if (s-&gt;ax25_dev == ax25_dev) {
-			s-&gt;ax25_dev = NULL;
 			spin_unlock_bh(&amp;ax25_list_lock);
+			lock_sock(s-&gt;sk);
+			s-&gt;ax25_dev = NULL;
+			release_sock(s-&gt;sk);
 			ax25_disconnect(s, ENETUNREACH);
 			spin_lock_bh(&amp;ax25_list_lock);
 </pre><hr><pre>commit b2f37aead1b82a770c48b5d583f35ec22aabb61e
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Fri Dec 17 10:13:56 2021 +0800

    hamradio: improve the incomplete fix to avoid NPD
    
    The previous commit 3e0588c291d6 ("hamradio: defer ax25 kfree after
    unregister_netdev") reorder the kfree operations and unregister_netdev
    operation to prevent UAF.
    
    This commit improves the previous one by also deferring the nullify of
    the ax-&gt;tty pointer. Otherwise, a NULL pointer dereference bug occurs.
    Partial of the stack trace is shown below.
    
    BUG: kernel NULL pointer dereference, address: 0000000000000538
    RIP: 0010:ax_xmit+0x1f9/0x400
    ...
    Call Trace:
     dev_hard_start_xmit+0xec/0x320
     sch_direct_xmit+0xea/0x240
     __qdisc_run+0x166/0x5c0
     __dev_queue_xmit+0x2c7/0xaf0
     ax25_std_establish_data_link+0x59/0x60
     ax25_connect+0x3a0/0x500
     ? security_socket_connect+0x2b/0x40
     __sys_connect+0x96/0xc0
     ? __hrtimer_init+0xc0/0xc0
     ? common_nsleep+0x2e/0x50
     ? switch_fpu_return+0x139/0x1a0
     __x64_sys_connect+0x11/0x20
     do_syscall_64+0x33/0x40
     entry_SYSCALL_64_after_hwframe+0x44/0xa9
    
    The crash point is shown as below
    
    static void ax_encaps(...) {
      ...
      set_bit(TTY_DO_WRITE_WAKEUP, &amp;ax-&gt;tty-&gt;flags); // ax-&gt;tty = NULL!
      ...
    }
    
    By placing the nullify action after the unregister_netdev, the ax-&gt;tty
    pointer won't be assigned as NULL net_device framework layer is well
    synchronized.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/hamradio/mkiss.c b/drivers/net/hamradio/mkiss.c
index 7da2bb8a443c..edde9c3ae12b 100644
--- a/drivers/net/hamradio/mkiss.c
+++ b/drivers/net/hamradio/mkiss.c
@@ -794,14 +794,14 @@ static void mkiss_close(struct tty_struct *tty)
 	 */
 	netif_stop_queue(ax-&gt;dev);
 
-	ax-&gt;tty = NULL;
-
 	unregister_netdev(ax-&gt;dev);
 
 	/* Free all AX25 frame buffers after unreg. */
 	kfree(ax-&gt;rbuff);
 	kfree(ax-&gt;xbuff);
 
+	ax-&gt;tty = NULL;
+
 	free_netdev(ax-&gt;dev);
 }
 </pre><hr><pre>commit 48b71a9e66c2eab60564b1b1c85f4928ed04e406
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Nov 16 23:27:32 2021 +0800

    NFC: add NCI_UNREG flag to eliminate the race
    
    There are two sites that calls queue_work() after the
    destroy_workqueue() and lead to possible UAF.
    
    The first site is nci_send_cmd(), which can happen after the
    nci_close_device as below
    
    nfcmrvl_nci_unregister_dev   |  nfc_genl_dev_up
      nci_close_device           |
        flush_workqueue          |
        del_timer_sync           |
      nci_unregister_device      |    nfc_get_device
        destroy_workqueue        |    nfc_dev_up
        nfc_unregister_device    |      nci_dev_up
          device_del             |        nci_open_device
                                 |          __nci_request
                                 |            nci_send_cmd
                                 |              queue_work !!!
    
    Another site is nci_cmd_timer, awaked by the nci_cmd_work from the
    nci_send_cmd.
    
      ...                        |  ...
      nci_unregister_device      |  queue_work
        destroy_workqueue        |
        nfc_unregister_device    |  ...
          device_del             |  nci_cmd_work
                                 |  mod_timer
                                 |  ...
                                 |  nci_cmd_timer
                                 |    queue_work !!!
    
    For the above two UAF, the root cause is that the nfc_dev_up can race
    between the nci_unregister_device routine. Therefore, this patch
    introduce NCI_UNREG flag to easily eliminate the possible race. In
    addition, the mutex_lock in nci_close_device can act as a barrier.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Fixes: 6a2968aaf50c ("NFC: basic NCI protocol implementation")
    Reviewed-by: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Reviewed-by: Krzysztof Kozlowski &lt;krzysztof.kozlowski@canonical.com&gt;
    Link: https://lore.kernel.org/r/20211116152732.19238-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/include/net/nfc/nci_core.h b/include/net/nfc/nci_core.h
index a964daedc17b..ea8595651c38 100644
--- a/include/net/nfc/nci_core.h
+++ b/include/net/nfc/nci_core.h
@@ -30,6 +30,7 @@ enum nci_flag {
 	NCI_UP,
 	NCI_DATA_EXCHANGE,
 	NCI_DATA_EXCHANGE_TO,
+	NCI_UNREG,
 };
 
 /* NCI device states */
diff --git a/net/nfc/nci/core.c b/net/nfc/nci/core.c
index 1dd0269c1a72..d2537383a3e8 100644
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@ -476,6 +476,11 @@ static int nci_open_device(struct nci_dev *ndev)
 
 	mutex_lock(&amp;ndev-&gt;req_lock);
 
+	if (test_bit(NCI_UNREG, &amp;ndev-&gt;flags)) {
+		rc = -ENODEV;
+		goto done;
+	}
+
 	if (test_bit(NCI_UP, &amp;ndev-&gt;flags)) {
 		rc = -EALREADY;
 		goto done;
@@ -548,6 +553,10 @@ static int nci_open_device(struct nci_dev *ndev)
 static int nci_close_device(struct nci_dev *ndev)
 {
 	nci_req_cancel(ndev, ENODEV);
+
+	/* This mutex needs to be held as a barrier for
+	 * caller nci_unregister_device
+	 */
 	mutex_lock(&amp;ndev-&gt;req_lock);
 
 	if (!test_and_clear_bit(NCI_UP, &amp;ndev-&gt;flags)) {
@@ -585,8 +594,8 @@ static int nci_close_device(struct nci_dev *ndev)
 
 	del_timer_sync(&amp;ndev-&gt;cmd_timer);
 
-	/* Clear flags */
-	ndev-&gt;flags = 0;
+	/* Clear flags except NCI_UNREG */
+	ndev-&gt;flags &amp;= BIT(NCI_UNREG);
 
 	mutex_unlock(&amp;ndev-&gt;req_lock);
 
@@ -1269,6 +1278,12 @@ void nci_unregister_device(struct nci_dev *ndev)
 {
 	struct nci_conn_info *conn_info, *n;
 
+	/* This set_bit is not protected with specialized barrier,
+	 * However, it is fine because the mutex_lock(&amp;ndev-&gt;req_lock);
+	 * in nci_close_device() will help to emit one.
+	 */
+	set_bit(NCI_UNREG, &amp;ndev-&gt;flags);
+
 	nci_close_device(ndev);
 
 	destroy_workqueue(ndev-&gt;cmd_wq);</pre>
    <div class="pagination">
        <a href='6_19.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><span>[20]</span><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_21.html'>Next&gt;&gt;</a>
    <div>
</body>
