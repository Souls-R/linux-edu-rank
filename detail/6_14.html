<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_13.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><span>[14]</span><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_15.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0ad6bded175e829c2ca261529c9dce39a32a042d
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Nov 16 21:02:49 2022 +0800

    nfc/nci: fix race with opening and closing
    
    Previously we leverage NCI_UNREG and the lock inside nci_close_device to
    prevent the race condition between opening a device and closing a
    device. However, it still has problem because a failed opening command
    will erase the NCI_UNREG flag and allow another opening command to
    bypass the status checking.
    
    This fix corrects that by making sure the NCI_UNREG is held.
    
    Reported-by: syzbot+43475bf3cfbd6e41f5b7@syzkaller.appspotmail.com
    Fixes: 48b71a9e66c2 ("NFC: add NCI_UNREG flag to eliminate the race")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/nfc/nci/core.c b/net/nfc/nci/core.c
index 6a193cce2a75..4ffdf2f45c44 100644
--- a/net/nfc/nci/core.c
+++ b/net/nfc/nci/core.c
@@ -542,7 +542,7 @@ static int nci_open_device(struct nci_dev *ndev)
 		skb_queue_purge(&amp;ndev-&gt;tx_q);
 
 		ndev-&gt;ops-&gt;close(ndev);
-		ndev-&gt;flags = 0;
+		ndev-&gt;flags &amp;= BIT(NCI_UNREG);
 	}
 
 done:</pre><hr><pre>commit ce8cc75c7419ad54cb99437543a54c97c7446db5
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Tue Oct 18 16:34:24 2022 +0800

    drivers: staging: r8188eu: Fix sleep-in-atomic-context bug in rtw_join_timeout_handler
    
    The rtw_join_timeout_handler() is a timer handler that
    runs in atomic context, but it could call msleep().
    As a result, the sleep-in-atomic-context bug will happen.
    The process is shown below:
    
         (atomic context)
    rtw_join_timeout_handler
     _rtw_join_timeout_handler
      rtw_do_join
       rtw_select_and_join_from_scanned_queue
        rtw_indicate_disconnect
         rtw_lps_ctrl_wk_cmd
          lps_ctrl_wk_hdl
           LPS_Leave
            LPS_RF_ON_check
             msleep //sleep in atomic context
    
    Fix by removing msleep() and replacing with mdelay().
    
    Fixes: 15865124feed ("staging: r8188eu: introduce new core dir for RTL8188eu driver")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221018083424.79741-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/r8188eu/core/rtw_pwrctrl.c b/drivers/staging/r8188eu/core/rtw_pwrctrl.c
index 870d81735b8d..5290ac36f08c 100644
--- a/drivers/staging/r8188eu/core/rtw_pwrctrl.c
+++ b/drivers/staging/r8188eu/core/rtw_pwrctrl.c
@@ -273,7 +273,7 @@ static s32 LPS_RF_ON_check(struct adapter *padapter, u32 delay_ms)
 			err = -1;
 			break;
 		}
-		msleep(1);
+		mdelay(1);
 	}
 
 	return err;</pre><hr><pre>commit 7a58b8d6021426b796eebfae80983374d9a80a75
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sun Sep 18 11:33:12 2022 +0800

    usb: chipidea: fix deadlock in ci_otg_del_timer
    
    There is a deadlock in ci_otg_del_timer(), the process is
    shown below:
    
        (thread 1)                  |        (thread 2)
    ci_otg_del_timer()              | ci_otg_hrtimer_func()
      ...                           |
      spin_lock_irqsave() //(1)     |  ...
      ...                           |
      hrtimer_cancel()              |  spin_lock_irqsave() //(2)
      (block forever)
    
    We hold ci-&gt;lock in position (1) and use hrtimer_cancel() to
    wait ci_otg_hrtimer_func() to stop, but ci_otg_hrtimer_func()
    also need ci-&gt;lock in position (2). As a result, the
    hrtimer_cancel() in ci_otg_del_timer() will be blocked forever.
    
    This patch extracts hrtimer_cancel() from the protection of
    spin_lock_irqsave() in order that the ci_otg_hrtimer_func()
    could obtain the ci-&gt;lock.
    
    What`s more, there will be no race happen. Because the
    "next_timer" is always under the protection of
    spin_lock_irqsave() and we only check whether "next_timer"
    equals to NUM_OTG_FSM_TIMERS in the following code.
    
    Fixes: 3a316ec4c91c ("usb: chipidea: use hrtimer for otg fsm timers")
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20220918033312.94348-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/chipidea/otg_fsm.c b/drivers/usb/chipidea/otg_fsm.c
index ada78daba6df..c17516c29b63 100644
--- a/drivers/usb/chipidea/otg_fsm.c
+++ b/drivers/usb/chipidea/otg_fsm.c
@@ -256,8 +256,10 @@ static void ci_otg_del_timer(struct ci_hdrc *ci, enum otg_fsm_timer t)
 	ci-&gt;enabled_otg_timer_bits &amp;= ~(1 &lt;&lt; t);
 	if (ci-&gt;next_otg_timer == t) {
 		if (ci-&gt;enabled_otg_timer_bits == 0) {
+			spin_unlock_irqrestore(&amp;ci-&gt;lock, flags);
 			/* No enabled timers after delete it */
 			hrtimer_cancel(&amp;ci-&gt;otg_fsm_hrtimer);
+			spin_lock_irqsave(&amp;ci-&gt;lock, flags);
 			ci-&gt;next_otg_timer = NUM_OTG_FSM_TIMERS;
 		} else {
 			/* Find the next timer */</pre><hr><pre>commit 7b7dfe4833c70a11cdfa51b38705103bd31eddaa
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sun Oct 2 12:07:09 2022 +0800

    tty: n_gsm: fix sleep-in-atomic-context bug in gsm_control_send
    
    The function gsm_dlci_t1() is a timer handler that runs in an
    atomic context, but it calls "kzalloc(..., GFP_KERNEL)" that
    may sleep. As a result, the sleep-in-atomic-context bug will
    happen. The process is shown below:
    
    gsm_dlci_t1()
     gsm_dlci_open()
      gsm_modem_update()
       gsm_modem_upd_via_msc()
        gsm_control_send()
         kzalloc(sizeof(.., GFP_KERNEL) //may sleep
    
    This patch changes the gfp_t parameter of kzalloc() from GFP_KERNEL to
    GFP_ATOMIC in order to mitigate the bug.
    
    Fixes: e1eaea46bb40 ("tty: n_gsm line discipline")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221002040709.27849-1-duoming@zju.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c
index 5c9f76073fcd..b6e0cc4571ea 100644
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@ -1711,7 +1711,7 @@ static struct gsm_control *gsm_control_send(struct gsm_mux *gsm,
 		unsigned int command, u8 *data, int clen)
 {
 	struct gsm_control *ctrl = kzalloc(sizeof(struct gsm_control),
-						GFP_KERNEL);
+						GFP_ATOMIC);
 	unsigned long flags;
 	if (ctrl == NULL)
 		return NULL;</pre><hr><pre>commit 4046728253751adb41b05e85ebd686210efde1ad
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Wed Nov 2 10:52:30 2022 +0800

    blk-mq: use if-else instead of goto in blk_mq_alloc_cached_request()
    
    if-else is more readable than goto here.
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/d3306fa4e92dc9cc614edc8f1802686096bafef2.1667356813.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/blk-mq.c b/block/blk-mq.c
index d4824b53f6b2..fc9c400adf92 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -575,25 +575,26 @@ static struct request *blk_mq_alloc_cached_request(struct request_queue *q,
 
 	if (!plug)
 		return NULL;
+
 	if (rq_list_empty(plug-&gt;cached_rq)) {
 		if (plug-&gt;nr_ios == 1)
 			return NULL;
 		rq = blk_mq_rq_cache_fill(q, plug, opf, flags);
-		if (rq)
-			goto got_it;
-		return NULL;
-	}
-	rq = rq_list_peek(&amp;plug-&gt;cached_rq);
-	if (!rq || rq-&gt;q != q)
-		return NULL;
+		if (!rq)
+			return NULL;
+	} else {
+		rq = rq_list_peek(&amp;plug-&gt;cached_rq);
+		if (!rq || rq-&gt;q != q)
+			return NULL;
 
-	if (blk_mq_get_hctx_type(opf) != rq-&gt;mq_hctx-&gt;type)
-		return NULL;
-	if (op_is_flush(rq-&gt;cmd_flags) != op_is_flush(opf))
-		return NULL;
+		if (blk_mq_get_hctx_type(opf) != rq-&gt;mq_hctx-&gt;type)
+			return NULL;
+		if (op_is_flush(rq-&gt;cmd_flags) != op_is_flush(opf))
+			return NULL;
+
+		plug-&gt;cached_rq = rq_list_next(rq);
+	}
 
-	plug-&gt;cached_rq = rq_list_next(rq);
-got_it:
 	rq-&gt;cmd_flags = opf;
 	INIT_LIST_HEAD(&amp;rq-&gt;queuelist);
 	return rq;</pre><hr><pre>commit 7edfd68165b8dab8cde231728ff092a625469eb7
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Wed Nov 2 10:52:29 2022 +0800

    blk-mq: improve error handling in blk_mq_alloc_rq_map()
    
    Use goto-style error handling like we do elsewhere in the kernel.
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/bbbc2d9b17b137798c7fb92042141ca4cbbc58cc.1667356813.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/blk-mq.c b/block/blk-mq.c
index bae6f81c39b3..d4824b53f6b2 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -3305,21 +3305,22 @@ static struct blk_mq_tags *blk_mq_alloc_rq_map(struct blk_mq_tag_set *set,
 	tags-&gt;rqs = kcalloc_node(nr_tags, sizeof(struct request *),
 				 GFP_NOIO | __GFP_NOWARN | __GFP_NORETRY,
 				 node);
-	if (!tags-&gt;rqs) {
-		blk_mq_free_tags(tags);
-		return NULL;
-	}
+	if (!tags-&gt;rqs)
+		goto err_free_tags;
 
 	tags-&gt;static_rqs = kcalloc_node(nr_tags, sizeof(struct request *),
 					GFP_NOIO | __GFP_NOWARN | __GFP_NORETRY,
 					node);
-	if (!tags-&gt;static_rqs) {
-		kfree(tags-&gt;rqs);
-		blk_mq_free_tags(tags);
-		return NULL;
-	}
+	if (!tags-&gt;static_rqs)
+		goto err_free_rqs;
 
 	return tags;
+
+err_free_rqs:
+	kfree(tags-&gt;rqs);
+err_free_tags:
+	blk_mq_free_tags(tags);
+	return NULL;
 }
 
 static int blk_mq_init_request(struct blk_mq_tag_set *set, struct request *rq,</pre><hr><pre>commit 56c1ee92246a5099a626b955dd7f6636cdce6f93
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Sun Oct 30 16:32:12 2022 +0800

    blk-mq: remove redundant call to blk_freeze_queue_start in blk_mq_destroy_queue
    
    The calling relationship in blk_mq_destroy_queue() is as follows:
    
    blk_mq_destroy_queue()
        ...
        -&gt; blk_queue_start_drain()
            -&gt; blk_freeze_queue_start()  &lt;- called
            ...
        -&gt; blk_freeze_queue()
            -&gt; blk_freeze_queue_start()  &lt;- called again
            -&gt; blk_mq_freeze_queue_wait()
        ...
    
    So there is a redundant call to blk_freeze_queue_start().
    
    Replace blk_freeze_queue() with blk_mq_freeze_queue_wait() to avoid the
    redundant call.
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/20221030083212.1251255-1-nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/blk-mq.c b/block/blk-mq.c
index bcb402f9bff6..623e8a506539 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -4037,7 +4037,7 @@ void blk_mq_destroy_queue(struct request_queue *q)
 
 	blk_queue_flag_set(QUEUE_FLAG_DYING, q);
 	blk_queue_start_drain(q);
-	blk_freeze_queue(q);
+	blk_mq_freeze_queue_wait(q);
 
 	blk_sync_queue(q);
 	blk_mq_cancel_work_sync(q);</pre><hr><pre>commit 219cf43c552a49a7710b7b341bf616682a2643f0
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Sun Oct 30 17:47:30 2022 +0800

    blk-mq: move queue_is_mq out of blk_mq_cancel_work_sync
    
    The only caller that needs queue_is_mq check is del_gendisk, so move the
    check into it.
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/20221030094730.1275463-1-nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/blk-mq.c b/block/blk-mq.c
index 060c8cca4b24..bcb402f9bff6 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -4883,15 +4883,13 @@ EXPORT_SYMBOL(blk_mq_rq_cpu);
 
 void blk_mq_cancel_work_sync(struct request_queue *q)
 {
-	if (queue_is_mq(q)) {
-		struct blk_mq_hw_ctx *hctx;
-		unsigned long i;
+	struct blk_mq_hw_ctx *hctx;
+	unsigned long i;
 
-		cancel_delayed_work_sync(&amp;q-&gt;requeue_work);
+	cancel_delayed_work_sync(&amp;q-&gt;requeue_work);
 
-		queue_for_each_hw_ctx(q, hctx, i)
-			cancel_delayed_work_sync(&amp;hctx-&gt;run_work);
-	}
+	queue_for_each_hw_ctx(q, hctx, i)
+		cancel_delayed_work_sync(&amp;hctx-&gt;run_work);
 }
 
 static int __init blk_mq_init(void)
diff --git a/block/genhd.c b/block/genhd.c
index 17b33c62423d..493b93faee9c 100644
--- a/block/genhd.c
+++ b/block/genhd.c
@@ -638,7 +638,9 @@ void del_gendisk(struct gendisk *disk)
 
 	blk_sync_queue(q);
 	blk_flush_integrity();
-	blk_mq_cancel_work_sync(q);
+
+	if (queue_is_mq(q))
+		blk_mq_cancel_work_sync(q);
 
 	blk_mq_quiesce_queue(q);
 	if (q-&gt;elevator) {</pre><hr><pre>commit 8ed40ee35d94df2fdb56bbbc07e17dffd2383625
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Thu Oct 20 08:48:19 2022 +0200

    block: fix up elevator_type refcounting
    
    The current reference management logic of io scheduler modules contains
    refcnt problems. For example, blk_mq_init_sched may fail before or after
    the calling of e-&gt;ops.init_sched. If it fails before the calling, it does
    nothing to the reference to the io scheduler module. But if it fails after
    the calling, it releases the reference by calling kobject_put(&amp;eq-&gt;kobj).
    
    As the callers of blk_mq_init_sched can't know exactly where the failure
    happens, they can't handle the reference to the io scheduler module
    properly: releasing the reference on failure results in double-release if
    blk_mq_init_sched has released it, and not releasing the reference results
    in ghost reference if blk_mq_init_sched did not release it either.
    
    The same problem also exists in io schedulers' init_sched implementations.
    
    We can address the problem by adding releasing statements to the error
    handling procedures of blk_mq_init_sched and init_sched implementations.
    But that is counterintuitive and requires modifications to existing io
    schedulers.
    
    Instead, We make elevator_alloc get the io scheduler module references
    that will be released by elevator_release. And then, we match each
    elevator_get with an elevator_put. Therefore, each reference to an io
    scheduler module explicitly has its own getter and releaser, and we no
    longer need to worry about the refcnt problems.
    
    The bugs and the patch can be validated with tools here:
    https://github.com/nickyc975/linux_elv_refcnt_bug.git
    
    [hch: split out a few bits into separate patches, use a non-try
          module_get in elevator_alloc]
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Signed-off-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/20221020064819.1469928-5-hch@lst.de
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/blk-mq-sched.c b/block/blk-mq-sched.c
index a4f7c101b53b..68227240fdea 100644
--- a/block/blk-mq-sched.c
+++ b/block/blk-mq-sched.c
@@ -555,6 +555,7 @@ static int blk_mq_init_sched_shared_tags(struct request_queue *queue)
 	return 0;
 }
 
+/* caller must have a reference to @e, will grab another one if successful */
 int blk_mq_init_sched(struct request_queue *q, struct elevator_type *e)
 {
 	unsigned int flags = q-&gt;tag_set-&gt;flags;
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 9db8814cdd02..098432d3caf1 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -4591,6 +4591,8 @@ static void blk_mq_elv_switch_back(struct list_head *head,
 
 	mutex_lock(&amp;q-&gt;sysfs_lock);
 	elevator_switch(q, t);
+	/* drop the reference acquired in blk_mq_elv_switch_none */
+	elevator_put(t);
 	mutex_unlock(&amp;q-&gt;sysfs_lock);
 }
 
diff --git a/block/elevator.c b/block/elevator.c
index 61d5655a3819..d26aa787e29f 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -165,6 +165,7 @@ struct elevator_queue *elevator_alloc(struct request_queue *q,
 	if (unlikely(!eq))
 		return NULL;
 
+	__elevator_get(e);
 	eq-&gt;type = e;
 	kobject_init(&amp;eq-&gt;kobj, &amp;elv_ktype);
 	mutex_init(&amp;eq-&gt;sysfs_lock);
@@ -704,8 +705,9 @@ void elevator_init_mq(struct request_queue *q)
 	if (err) {
 		pr_warn("\"%s\" elevator initialization failed, "
 			"falling back to \"none\"\n", e-&gt;elevator_name);
-		elevator_put(e);
 	}
+
+	elevator_put(e);
 }
 
 /*
@@ -737,6 +739,7 @@ int elevator_switch(struct request_queue *q, struct elevator_type *new_e)
 static int elevator_change(struct request_queue *q, const char *elevator_name)
 {
 	struct elevator_type *e;
+	int ret;
 
 	/* Make sure queue is not in the middle of being removed */
 	if (!blk_queue_registered(q))
@@ -757,8 +760,9 @@ static int elevator_change(struct request_queue *q, const char *elevator_name)
 	e = elevator_get(q, elevator_name, true);
 	if (!e)
 		return -EINVAL;
-
-	return elevator_switch(q, e);
+	ret = elevator_switch(q, e);
+	elevator_put(e);
+	return ret;
 }
 
 ssize_t elv_iosched_store(struct request_queue *q, const char *buf,</pre><hr><pre>commit b54c2ad9b77de846e42104ecf94eb8329d2f03a3
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Thu Oct 20 08:48:18 2022 +0200

    block: check for an unchanged elevator earlier in __elevator_change
    
    No need to find the actual elevator_type struct for this comparism,
    the name is all that is needed.
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    [hch: split from a larger patch]
    Signed-off-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/20221020064819.1469928-4-hch@lst.de
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index 5b8fb8745e9a..61d5655a3819 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -751,16 +751,13 @@ static int elevator_change(struct request_queue *q, const char *elevator_name)
 		return elevator_switch(q, NULL);
 	}
 
+	if (q-&gt;elevator &amp;&amp; elevator_match(q-&gt;elevator-&gt;type, elevator_name, 0))
+		return 0;
+
 	e = elevator_get(q, elevator_name, true);
 	if (!e)
 		return -EINVAL;
 
-	if (q-&gt;elevator &amp;&amp;
-	    elevator_match(q-&gt;elevator-&gt;type, elevator_name, 0)) {
-		elevator_put(e);
-		return 0;
-	}
-
 	return elevator_switch(q, e);
 }
 </pre>
    <div class="pagination">
        <a href='6_13.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><span>[14]</span><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_15.html'>Next&gt;&gt;</a>
    <div>
</body>
