<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_10.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><span>[11]</span><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_12.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a5110f2983bdf931d9819f88505775b16de8b99e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 15 16:52:29 2010 -0500

    [SCSI] ibmvfc: prep for fc host dev loss tmo support
    
    This removes the driver's get_host_def_dev_loss_tmo
    callback and just has the driver set the dev loss
    using the fc class fc_host_dev_loss_tmo macro like is
    done for other fc params.
    
    This patch also removes the module dev loss param.
    To override the value the fc host sysfs value being
    added in the fc class patch can be used instead of the driver
    module param.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Acked-by: Brian King &lt;brking@linux.vnet.ibm.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.c b/drivers/scsi/ibmvscsi/ibmvfc.c
index b1512e9d1b9d..f033bf39690f 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@ -50,7 +50,6 @@ static unsigned int max_lun = IBMVFC_MAX_LUN;
 static unsigned int max_targets = IBMVFC_MAX_TARGETS;
 static unsigned int max_requests = IBMVFC_MAX_REQUESTS_DEFAULT;
 static unsigned int disc_threads = IBMVFC_MAX_DISC_THREADS;
-static unsigned int dev_loss_tmo = IBMVFC_DEV_LOSS_TMO;
 static unsigned int ibmvfc_debug = IBMVFC_DEBUG;
 static unsigned int log_level = IBMVFC_DEFAULT_LOG_LEVEL;
 static LIST_HEAD(ibmvfc_head);
@@ -84,11 +83,6 @@ MODULE_PARM_DESC(disc_threads, "Number of device discovery threads to use. "
 module_param_named(debug, ibmvfc_debug, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(debug, "Enable driver debug information. "
 		 "[Default=" __stringify(IBMVFC_DEBUG) "]");
-module_param_named(dev_loss_tmo, dev_loss_tmo, uint, S_IRUGO | S_IWUSR);
-MODULE_PARM_DESC(dev_loss_tmo, "Maximum number of seconds that the FC "
-		 "transport should insulate the loss of a remote port. Once this "
-		 "value is exceeded, the scsi target is removed. "
-		 "[Default=" __stringify(IBMVFC_DEV_LOSS_TMO) "]");
 module_param_named(log_level, log_level, uint, 0);
 MODULE_PARM_DESC(log_level, "Set to 0 - 4 for increasing verbosity of device driver. "
 		 "[Default=" __stringify(IBMVFC_DEFAULT_LOG_LEVEL) "]");
@@ -1030,11 +1024,6 @@ static void ibmvfc_get_host_port_state(struct Scsi_Host *shost)
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 }
 
-static void ibmvfc_set_host_def_dev_loss_tmo(struct Scsi_Host *shost)
-{
-	fc_host_def_dev_loss_tmo(shost) = dev_loss_tmo;
-}
-
 /**
  * ibmvfc_set_rport_dev_loss_tmo - Set rport's device loss timeout
  * @rport:		rport struct
@@ -4772,6 +4761,8 @@ static int ibmvfc_probe(struct vio_dev *vdev, const struct vio_device_id *id)
 	if ((rc = scsi_add_host(shost, dev)))
 		goto release_event_pool;
 
+	fc_host_dev_loss_tmo(shost) = IBMVFC_DEV_LOSS_TMO;
+
 	if ((rc = ibmvfc_create_trace_file(&amp;shost-&gt;shost_dev.kobj,
 					   &amp;ibmvfc_trace_attr))) {
 		dev_err(dev, "Failed to create trace file. rc=%d\n", rc);
@@ -4917,8 +4908,6 @@ static struct fc_function_template ibmvfc_transport_functions = {
 	.get_host_speed = ibmvfc_get_host_speed,
 	.show_host_speed = 1,
 
-	.get_host_def_dev_loss_tmo = ibmvfc_set_host_def_dev_loss_tmo,
-
 	.issue_fc_host_lip = ibmvfc_issue_fc_host_lip,
 	.terminate_rport_io = ibmvfc_terminate_rport_io,
 </pre><hr><pre>commit 485868208ee833628d49f81b4609001749d92d56
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 15 16:52:28 2010 -0500

    [SCSI] fnic: prep for fc host dev loss tmo support
    
    This removes the driver's get_host_def_dev_loss_tmo
    callback and just has the driver set the dev loss
    using the fc class fc_host_dev_loss_tmo macro like is
    done for other fc params.
    
    This also adds a set rport dev loss function so the
    fc class host dev loss tmp sysfs support being added
    in the fc class patch can update rports.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/fnic/fnic_main.c b/drivers/scsi/fnic/fnic_main.c
index df91a61591b2..bb63f1a1f808 100644
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@ -110,12 +110,12 @@ static struct scsi_host_template fnic_host_template = {
 };
 
 static void
-fnic_get_host_def_loss_tmo(struct Scsi_Host *shost)
+fnic_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)
 {
-	struct fc_lport *lp = shost_priv(shost);
-	struct fnic *fnic = lport_priv(lp);
-
-	fc_host_def_dev_loss_tmo(shost) = fnic-&gt;config.port_down_timeout / 1000;
+	if (timeout)
+		rport-&gt;dev_loss_tmo = timeout;
+	else
+		rport-&gt;dev_loss_tmo = 1;
 }
 
 static void fnic_get_host_speed(struct Scsi_Host *shost);
@@ -145,9 +145,9 @@ static struct fc_function_template fnic_fc_functions = {
 	.show_starget_port_name = 1,
 	.show_starget_port_id = 1,
 	.show_rport_dev_loss_tmo = 1,
+	.set_rport_dev_loss_tmo = fnic_set_rport_dev_loss_tmo,
 	.issue_fc_host_lip = fnic_reset,
 	.get_fc_host_stats = fnic_get_stats,
-	.get_host_def_dev_loss_tmo = fnic_get_host_def_loss_tmo,
 	.dd_fcrport_size = sizeof(struct fc_rport_libfc_priv),
 	.terminate_rport_io = fnic_terminate_rport_io,
 	.bsg_request = fc_lport_bsg_request,
@@ -712,6 +712,7 @@ static int __devinit fnic_probe(struct pci_dev *pdev,
 		goto err_out_free_exch_mgr;
 	}
 	fc_host_maxframe_size(lp-&gt;host) = lp-&gt;mfs;
+	fc_host_dev_loss_tmo(lp-&gt;host) = fnic-&gt;config.port_down_timeout / 1000;
 
 	sprintf(fc_host_symbolic_name(lp-&gt;host),
 		DRV_NAME " v" DRV_VERSION " over %s", fnic-&gt;name);</pre><hr><pre>commit da99e307aa508fba6fbedc3699e7df64e284d2c5
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Aug 6 03:02:41 2010 -0500

    [SCSI] ibmvfc: do not reset dev_loss_tmo in slave callout
    
    This fixes a bug where the driver was resetting the
    rport dev_loss_tmo when devices were added by adding
    support for the get_host_def_dev_loss_tmo callout.
    
    Patch has only been compile tested.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/ibmvscsi/ibmvfc.c b/drivers/scsi/ibmvscsi/ibmvfc.c
index 9f75a6d519a2..a5dd9b4a0ae8 100644
--- a/drivers/scsi/ibmvscsi/ibmvfc.c
+++ b/drivers/scsi/ibmvscsi/ibmvfc.c
@@ -1030,6 +1030,11 @@ static void ibmvfc_get_host_port_state(struct Scsi_Host *shost)
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 }
 
+static void ibmvfc_set_host_def_dev_loss_tmo(struct Scsi_Host *shost)
+{
+	fc_host_def_dev_loss_tmo(shost) = dev_loss_tmo;
+}
+
 /**
  * ibmvfc_set_rport_dev_loss_tmo - Set rport's device loss timeout
  * @rport:		rport struct
@@ -2788,7 +2793,6 @@ static int ibmvfc_target_alloc(struct scsi_target *starget)
 static int ibmvfc_slave_configure(struct scsi_device *sdev)
 {
 	struct Scsi_Host *shost = sdev-&gt;host;
-	struct fc_rport *rport = starget_to_rport(sdev-&gt;sdev_target);
 	unsigned long flags = 0;
 
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
@@ -2800,8 +2804,6 @@ static int ibmvfc_slave_configure(struct scsi_device *sdev)
 		scsi_activate_tcq(sdev, sdev-&gt;queue_depth);
 	} else
 		scsi_deactivate_tcq(sdev, sdev-&gt;queue_depth);
-
-	rport-&gt;dev_loss_tmo = dev_loss_tmo;
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 	return 0;
 }
@@ -4889,6 +4891,8 @@ static struct fc_function_template ibmvfc_transport_functions = {
 	.get_host_speed = ibmvfc_get_host_speed,
 	.show_host_speed = 1,
 
+	.get_host_def_dev_loss_tmo = ibmvfc_set_host_def_dev_loss_tmo,
+
 	.issue_fc_host_lip = ibmvfc_issue_fc_host_lip,
 	.terminate_rport_io = ibmvfc_terminate_rport_io,
 </pre><hr><pre>commit 8196a934eea3810be6243b307b336136d63bbc48
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Aug 6 03:02:40 2010 -0500

    [SCSI] fnic: do not reset dev_loss_tmo in slave callout
    
    This fixes a bug where the driver was resetting the
    rport dev_loss_tmo when devices were added by adding
    support for the get_host_def_dev_loss_tmo callout.
    
    Patch has only been compile tested.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/fnic/fnic_main.c b/drivers/scsi/fnic/fnic_main.c
index 9eb7a9ebccae..df91a61591b2 100644
--- a/drivers/scsi/fnic/fnic_main.c
+++ b/drivers/scsi/fnic/fnic_main.c
@@ -80,8 +80,6 @@ static struct libfc_function_template fnic_transport_template = {
 static int fnic_slave_alloc(struct scsi_device *sdev)
 {
 	struct fc_rport *rport = starget_to_rport(scsi_target(sdev));
-	struct fc_lport *lp = shost_priv(sdev-&gt;host);
-	struct fnic *fnic = lport_priv(lp);
 
 	sdev-&gt;tagged_supported = 1;
 
@@ -89,8 +87,6 @@ static int fnic_slave_alloc(struct scsi_device *sdev)
 		return -ENXIO;
 
 	scsi_activate_tcq(sdev, FNIC_DFLT_QUEUE_DEPTH);
-	rport-&gt;dev_loss_tmo = fnic-&gt;config.port_down_timeout / 1000;
-
 	return 0;
 }
 
@@ -113,6 +109,15 @@ static struct scsi_host_template fnic_host_template = {
 	.shost_attrs = fnic_attrs,
 };
 
+static void
+fnic_get_host_def_loss_tmo(struct Scsi_Host *shost)
+{
+	struct fc_lport *lp = shost_priv(shost);
+	struct fnic *fnic = lport_priv(lp);
+
+	fc_host_def_dev_loss_tmo(shost) = fnic-&gt;config.port_down_timeout / 1000;
+}
+
 static void fnic_get_host_speed(struct Scsi_Host *shost);
 static struct scsi_transport_template *fnic_fc_transport;
 static struct fc_host_statistics *fnic_get_stats(struct Scsi_Host *);
@@ -142,6 +147,7 @@ static struct fc_function_template fnic_fc_functions = {
 	.show_rport_dev_loss_tmo = 1,
 	.issue_fc_host_lip = fnic_reset,
 	.get_fc_host_stats = fnic_get_stats,
+	.get_host_def_dev_loss_tmo = fnic_get_host_def_loss_tmo,
 	.dd_fcrport_size = sizeof(struct fc_rport_libfc_priv),
 	.terminate_rport_io = fnic_terminate_rport_io,
 	.bsg_request = fc_lport_bsg_request,</pre><hr><pre>commit 143beaa811aa3cfc4ae8b4a2092f232ad78b33da
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Aug 6 03:02:39 2010 -0500

    [SCSI] lpfc: do not reset dev_loss_tmo in slave callout
    
    This fixes a bug where the driver was resetting the
    rport dev_loss_tmo when devices were added by adding
    support for the get_host_def_dev_loss_tmo callout.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/lpfc/lpfc_attr.c b/drivers/scsi/lpfc/lpfc_attr.c
index 23ce45708335..87c2b6b858f7 100644
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@ -4370,6 +4370,14 @@ lpfc_get_starget_port_name(struct scsi_target *starget)
 		ndlp ? wwn_to_u64(ndlp-&gt;nlp_portname.u.wwn) : 0;
 }
 
+static void
+lpfc_get_host_def_loss_tmo(struct Scsi_Host *shost)
+{
+        struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;
+
+	fc_host_def_dev_loss_tmo(shost) = vport-&gt;cfg_devloss_tmo;
+}
+
 /**
  * lpfc_set_rport_loss_tmo - Set the rport dev loss tmo
  * @rport: fc rport address.
@@ -4478,6 +4486,7 @@ struct fc_function_template lpfc_transport_functions = {
 	.get_host_fabric_name = lpfc_get_host_fabric_name,
 	.show_host_fabric_name = 1,
 
+	.get_host_def_dev_loss_tmo = lpfc_get_host_def_loss_tmo,
 	/*
 	 * The LPFC driver treats linkdown handling as target loss events
 	 * so there are no sysfs handlers for link_down_tmo.
@@ -4545,6 +4554,7 @@ struct fc_function_template lpfc_vport_transport_functions = {
 	.get_host_fabric_name = lpfc_get_host_fabric_name,
 	.show_host_fabric_name = 1,
 
+	.get_host_def_dev_loss_tmo = lpfc_get_host_def_loss_tmo,
 	/*
 	 * The LPFC driver treats linkdown handling as target loss events
 	 * so there are no sysfs handlers for link_down_tmo.
diff --git a/drivers/scsi/lpfc/lpfc_scsi.c b/drivers/scsi/lpfc/lpfc_scsi.c
index 2e51aa6b45b3..6e331c73170e 100644
--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@ -3656,7 +3656,6 @@ lpfc_slave_alloc(struct scsi_device *sdev)
  *
  * This routine configures following items
  *   - Tag command queuing support for @sdev if supported.
- *   - Dev loss time out value of fc_rport.
  *   - Enable SLI polling for fcp ring if ENABLE_FCP_RING_POLLING flag is set.
  *
  * Return codes:
@@ -3667,21 +3666,12 @@ lpfc_slave_configure(struct scsi_device *sdev)
 {
 	struct lpfc_vport *vport = (struct lpfc_vport *) sdev-&gt;host-&gt;hostdata;
 	struct lpfc_hba   *phba = vport-&gt;phba;
-	struct fc_rport   *rport = starget_to_rport(sdev-&gt;sdev_target);
 
 	if (sdev-&gt;tagged_supported)
 		scsi_activate_tcq(sdev, vport-&gt;cfg_lun_queue_depth);
 	else
 		scsi_deactivate_tcq(sdev, vport-&gt;cfg_lun_queue_depth);
 
-	/*
-	 * Initialize the fc transport attributes for the target
-	 * containing this scsi device.  Also note that the driver's
-	 * target pointer is stored in the starget_data for the
-	 * driver's sysfs entry point functions.
-	 */
-	rport-&gt;dev_loss_tmo = vport-&gt;cfg_devloss_tmo;
-
 	if (phba-&gt;cfg_poll &amp; ENABLE_FCP_RING_POLLING) {
 		lpfc_sli_handle_fast_ring_event(phba,
 			&amp;phba-&gt;sli.ring[LPFC_FCP_RING], HA_R0RE_REQ);</pre><hr><pre>commit a74bdf4661441d79a700f7ab3fc6d225ea2cf409
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Aug 6 03:02:38 2010 -0500

    [SCSI] qla2xxx: do not reset dev_loss_tmo in slave callout
    
    This fixes a bug where the driver was resetting the
    rport dev_loss_tmo when devices were added by adding
    support for the get_host_def_dev_loss_tmo callout.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index 420238cc794e..679a4326811c 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -1529,6 +1529,15 @@ qla2x00_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)
 		rport-&gt;dev_loss_tmo = 1;
 }
 
+static void
+qla2x00_get_host_def_loss_tmo(struct Scsi_Host *shost)
+{
+	scsi_qla_host_t *vha = shost_priv(shost);
+	struct qla_hw_data *ha = vha-&gt;hw;
+
+	fc_host_def_dev_loss_tmo(shost) = ha-&gt;port_down_retry_count;
+}
+
 static void
 qla2x00_dev_loss_tmo_callbk(struct fc_rport *rport)
 {
@@ -1903,6 +1912,7 @@ struct fc_function_template qla2xxx_transport_functions = {
 	.show_host_fabric_name = 1,
 	.get_host_port_state = qla2x00_get_host_port_state,
 	.show_host_port_state = 1,
+	.get_host_def_dev_loss_tmo = qla2x00_get_host_def_loss_tmo,
 
 	.dd_fcrport_size = sizeof(struct fc_port *),
 	.show_rport_supported_classes = 1,
@@ -1949,6 +1959,7 @@ struct fc_function_template qla2xxx_transport_vport_functions = {
 	.show_host_fabric_name = 1,
 	.get_host_port_state = qla2x00_get_host_port_state,
 	.show_host_port_state = 1,
+	.get_host_def_dev_loss_tmo = qla2x00_get_host_def_loss_tmo,
 
 	.dd_fcrport_size = sizeof(struct fc_port *),
 	.show_rport_supported_classes = 1,
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 8c80b49ac1c4..30b05229af26 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -1295,17 +1295,12 @@ static int
 qla2xxx_slave_configure(struct scsi_device *sdev)
 {
 	scsi_qla_host_t *vha = shost_priv(sdev-&gt;host);
-	struct qla_hw_data *ha = vha-&gt;hw;
-	struct fc_rport *rport = starget_to_rport(sdev-&gt;sdev_target);
 	struct req_que *req = vha-&gt;req;
 
 	if (sdev-&gt;tagged_supported)
 		scsi_activate_tcq(sdev, req-&gt;max_q_depth);
 	else
 		scsi_deactivate_tcq(sdev, req-&gt;max_q_depth);
-
-	rport-&gt;dev_loss_tmo = ha-&gt;port_down_retry_count;
-
 	return 0;
 }
 </pre><hr><pre>commit b8ef3204f460912a46659cdc74d237adbe705053
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Aug 6 03:02:37 2010 -0500

    [SCSI] fc class: add fc host default default dev loss setting
    
    This patch adds a fc_host setting to store the
    default dev_loss_tmo. It is used if the driver
    has a callack to get the value from the LLD. If
    the callback is not set, then we use the fc class
    module default value.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index d7e470a06180..9f0f7d9c7422 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -2525,7 +2525,11 @@ fc_rport_create(struct Scsi_Host *shost, int channel,
 
 	rport-&gt;maxframe_size = -1;
 	rport-&gt;supported_classes = FC_COS_UNSPECIFIED;
-	rport-&gt;dev_loss_tmo = fc_dev_loss_tmo;
+	if (fci-&gt;f-&gt;get_host_def_dev_loss_tmo) {
+		fci-&gt;f-&gt;get_host_def_dev_loss_tmo(shost);
+		rport-&gt;dev_loss_tmo = fc_host_def_dev_loss_tmo(shost);
+	} else
+		rport-&gt;dev_loss_tmo = fc_dev_loss_tmo;
 	memcpy(&amp;rport-&gt;node_name, &amp;ids-&gt;node_name, sizeof(rport-&gt;node_name));
 	memcpy(&amp;rport-&gt;port_name, &amp;ids-&gt;port_name, sizeof(rport-&gt;port_name));
 	rport-&gt;port_id = ids-&gt;port_id;
diff --git a/include/scsi/scsi_transport_fc.h b/include/scsi/scsi_transport_fc.h
index 87d81b3ce564..9f98fca9b763 100644
--- a/include/scsi/scsi_transport_fc.h
+++ b/include/scsi/scsi_transport_fc.h
@@ -496,6 +496,7 @@ struct fc_host_attrs {
 	u64 fabric_name;
 	char symbolic_name[FC_SYMBOLIC_NAME_SIZE];
 	char system_hostname[FC_SYMBOLIC_NAME_SIZE];
+	u32 def_dev_loss_tmo;
 
 	/* Private (Transport-managed) Attributes */
 	enum fc_tgtid_binding_type  tgtid_bind_type;
@@ -580,6 +581,8 @@ struct fc_host_attrs {
 	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;devloss_work_q_name)
 #define fc_host_devloss_work_q(x) \
 	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;devloss_work_q)
+#define fc_host_def_dev_loss_tmo(x) \
+	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;def_dev_loss_tmo)
 
 
 struct fc_bsg_buffer {
@@ -640,6 +643,7 @@ struct fc_function_template {
 	void	(*get_host_fabric_name)(struct Scsi_Host *);
 	void	(*get_host_symbolic_name)(struct Scsi_Host *);
 	void	(*set_host_system_hostname)(struct Scsi_Host *);
+	void	(*get_host_def_dev_loss_tmo)(struct Scsi_Host *);
 
 	struct fc_host_statistics * (*get_fc_host_stats)(struct Scsi_Host *);
 	void	(*reset_fc_host_stats)(struct Scsi_Host *);</pre><hr><pre>commit be948fc30dabc347e4fba4daf4da9fd83d2abf49
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Aug 2 16:02:24 2010 -0500

    [SCSI] libfc: call fc_remote_port_chkready under the host lock.
    
    The rport port state and flags are set under the host lock,
    so this patch calls fc_remote_port_chkready with the host lock
    held like is also done in the other fc drivers.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libfc/fc_fcp.c b/drivers/scsi/libfc/fc_fcp.c
index eac4d09314eb..c797f6b48f05 100644
--- a/drivers/scsi/libfc/fc_fcp.c
+++ b/drivers/scsi/libfc/fc_fcp.c
@@ -1765,14 +1765,14 @@ int fc_queuecommand(struct scsi_cmnd *sc_cmd, void (*done)(struct scsi_cmnd *))
 	struct fcoe_dev_stats *stats;
 
 	lport = shost_priv(sc_cmd-&gt;device-&gt;host);
-	spin_unlock_irq(lport-&gt;host-&gt;host_lock);
 
 	rval = fc_remote_port_chkready(rport);
 	if (rval) {
 		sc_cmd-&gt;result = rval;
 		done(sc_cmd);
-		goto out;
+		return 0;
 	}
+	spin_unlock_irq(lport-&gt;host-&gt;host_lock);
 
 	if (!*(struct fc_remote_port **)rport-&gt;dd_data) {
 		/*</pre><hr><pre>commit aab7a8fd19d0c2f7fcac4d07616899655e326dfe
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Aug 2 12:46:12 2010 -0500

    [SCSI] iscsi boot: mv iscsi_boot_sysfs to drivers/scsi
    
    iscsi_boot_sysfs does not depend on firmware. Any iscsi driver
    can use it. This patch moves iscsi_boot_sysfs to the scsi
    dir, so that it can be used on any arch with any driver.
    
    Signed-off-by: Mike Christie &lt;mchristi@redhat.com&gt;
    Acked-by: Konrad Rzeszutek Wilk &lt;konrad@kernel.org&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/firmware/Kconfig b/drivers/firmware/Kconfig
index a6c670b8ce52..f7cff381a4b8 100644
--- a/drivers/firmware/Kconfig
+++ b/drivers/firmware/Kconfig
@@ -122,14 +122,6 @@ config ISCSI_IBFT_FIND
 	  is necessary for iSCSI Boot Firmware Table Attributes module to work
 	  properly.
 
-config ISCSI_BOOT_SYSFS
-	tristate "iSCSI Boot Sysfs Interface"
-	default	n
-	help
-	  This option enables support for exposing iSCSI boot information
-	  via sysfs to userspace. If you wish to export this information,
-	  say Y. Otherwise, say N.
-
 config ISCSI_IBFT
 	tristate "iSCSI Boot Firmware Table Attributes module"
 	select ISCSI_BOOT_SYSFS
diff --git a/drivers/firmware/Makefile b/drivers/firmware/Makefile
index 5fe7e1662922..1c3c17343dbe 100644
--- a/drivers/firmware/Makefile
+++ b/drivers/firmware/Makefile
@@ -10,5 +10,4 @@ obj-$(CONFIG_DCDBAS)		+= dcdbas.o
 obj-$(CONFIG_DMIID)		+= dmi-id.o
 obj-$(CONFIG_ISCSI_IBFT_FIND)	+= iscsi_ibft_find.o
 obj-$(CONFIG_ISCSI_IBFT)	+= iscsi_ibft.o
-obj-$(CONFIG_ISCSI_BOOT_SYSFS)	+= iscsi_boot_sysfs.o
 obj-$(CONFIG_FIRMWARE_MEMMAP)	+= memmap.o
diff --git a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
index 158284f05732..a479b3b7ea90 100644
--- a/drivers/scsi/Kconfig
+++ b/drivers/scsi/Kconfig
@@ -370,6 +370,14 @@ config ISCSI_TCP
 
 	 http://open-iscsi.org
 
+config ISCSI_BOOT_SYSFS
+	tristate "iSCSI Boot Sysfs Interface"
+	default	n
+	help
+	  This option enables support for exposing iSCSI boot information
+	  via sysfs to userspace. If you wish to export this information,
+	  say Y. Otherwise, say N.
+
 source "drivers/scsi/cxgb3i/Kconfig"
 source "drivers/scsi/bnx2i/Kconfig"
 source "drivers/scsi/be2iscsi/Kconfig"
diff --git a/drivers/scsi/Makefile b/drivers/scsi/Makefile
index 2a3fca2eca6a..2703c6ec5e36 100644
--- a/drivers/scsi/Makefile
+++ b/drivers/scsi/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_FCOE)		+= fcoe/
 obj-$(CONFIG_FCOE_FNIC)		+= fnic/
 obj-$(CONFIG_ISCSI_TCP) 	+= libiscsi.o	libiscsi_tcp.o iscsi_tcp.o
 obj-$(CONFIG_INFINIBAND_ISER) 	+= libiscsi.o
+obj-$(CONFIG_ISCSI_BOOT_SYSFS)	+= iscsi_boot_sysfs.o
 obj-$(CONFIG_SCSI_A4000T)	+= 53c700.o	a4000t.o
 obj-$(CONFIG_SCSI_ZORRO7XX)	+= 53c700.o	zorro7xx.o
 obj-$(CONFIG_A3000_SCSI)	+= a3000.o	wd33c93.o
diff --git a/drivers/firmware/iscsi_boot_sysfs.c b/drivers/scsi/iscsi_boot_sysfs.c
similarity index 100%
rename from drivers/firmware/iscsi_boot_sysfs.c
rename to drivers/scsi/iscsi_boot_sysfs.c</pre><hr><pre>commit c01be6dcb2b5cce4feaf48035be6395e5cd7d47c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu Jul 22 16:59:49 2010 +0530

    [SCSI] iscsi_transport: wait on session in error handler path
    
    wait for session to come online in eh_device_reset_handler
    and eh_target_reset_handler
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Vikas Chaudhary &lt;vikas.chaudhary@qlogic.com&gt;
    Signed-off-by: Ravi Anand &lt;ravi.anand@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 821384147a41..5529b2a39741 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -2020,6 +2020,11 @@ static int qla4xxx_eh_device_reset(struct scsi_cmnd *cmd)
 	if (!ddb_entry)
 		return ret;
 
+	ret = iscsi_block_scsi_eh(cmd);
+	if (ret)
+		return ret;
+	ret = FAILED;
+
 	ql4_printk(KERN_INFO, ha,
 		   "scsi%ld:%d:%d:%d: DEVICE RESET ISSUED.\n", ha-&gt;host_no,
 		   cmd-&gt;device-&gt;channel, cmd-&gt;device-&gt;id, cmd-&gt;device-&gt;lun);
@@ -2072,11 +2077,15 @@ static int qla4xxx_eh_target_reset(struct scsi_cmnd *cmd)
 {
 	struct scsi_qla_host *ha = to_qla_host(cmd-&gt;device-&gt;host);
 	struct ddb_entry *ddb_entry = cmd-&gt;device-&gt;hostdata;
-	int stat;
+	int stat, ret;
 
 	if (!ddb_entry)
 		return FAILED;
 
+	ret = iscsi_block_scsi_eh(cmd);
+	if (ret)
+		return ret;
+
 	starget_printk(KERN_INFO, scsi_target(cmd-&gt;device),
 		       "WARM TARGET RESET ISSUED.\n");
 
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index d4b96623aa59..e84026def1f4 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -30,6 +30,7 @@
 #include &lt;scsi/scsi_transport.h&gt;
 #include &lt;scsi/scsi_transport_iscsi.h&gt;
 #include &lt;scsi/iscsi_if.h&gt;
+#include &lt;scsi/scsi_cmnd.h&gt;
 
 #define ISCSI_SESSION_ATTRS 23
 #define ISCSI_CONN_ATTRS 13
@@ -534,6 +535,37 @@ static void iscsi_scan_session(struct work_struct *work)
 	atomic_dec(&amp;ihost-&gt;nr_scans);
 }
 
+/**
+ * iscsi_block_scsi_eh - block scsi eh until session state has transistioned
+ * cmd: scsi cmd passed to scsi eh handler
+ *
+ * If the session is down this function will wait for the recovery
+ * timer to fire or for the session to be logged back in. If the
+ * recovery timer fires then FAST_IO_FAIL is returned. The caller
+ * should pass this error value to the scsi eh.
+ */
+int iscsi_block_scsi_eh(struct scsi_cmnd *cmd)
+{
+	struct iscsi_cls_session *session =
+			starget_to_session(scsi_target(cmd-&gt;device));
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	while (session-&gt;state != ISCSI_SESSION_LOGGED_IN) {
+		if (session-&gt;state == ISCSI_SESSION_FREE) {
+			ret = FAST_IO_FAIL;
+			break;
+		}
+		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+		msleep(1000);
+		spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	}
+	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iscsi_block_scsi_eh);
+
 static void session_recovery_timedout(struct work_struct *work)
 {
 	struct iscsi_cls_session *session =
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 349c7f30720d..7fff94b3b2a8 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -32,6 +32,7 @@ struct scsi_transport_template;
 struct iscsi_transport;
 struct iscsi_endpoint;
 struct Scsi_Host;
+struct scsi_cmnd;
 struct iscsi_cls_conn;
 struct iscsi_conn;
 struct iscsi_task;
@@ -255,5 +256,6 @@ extern int iscsi_scan_finished(struct Scsi_Host *shost, unsigned long time);
 extern struct iscsi_endpoint *iscsi_create_endpoint(int dd_size);
 extern void iscsi_destroy_endpoint(struct iscsi_endpoint *ep);
 extern struct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle);
+extern int iscsi_block_scsi_eh(struct scsi_cmnd *cmd);
 
 #endif</pre>
    <div class="pagination">
        <a href='5_10.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><span>[11]</span><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_12.html'>Next&gt;&gt;</a>
    <div>
</body>
