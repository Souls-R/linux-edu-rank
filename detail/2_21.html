<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_20.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><span>[21]</span><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_22.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c01b244ad848ac7f0faa141182db80650a8a761a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 5 10:28:01 2017 -0400

    USB: add usbfs ioctl to retrieve the connection speed
    
    The usbfs interface does not provide any way for the user to learn the
    speed at which a device is connected.  The current API includes a
    USBDEVFS_CONNECTINFO ioctl, but all it provides is the device's
    address and a one-bit value indicating whether the connection is low
    speed.  That may have sufficed in the era of USB-1.1, but it isn't
    good enough today.
    
    This patch introduces a new ioctl, USBDEVFS_GET_SPEED, which returns a
    numeric value indicating the speed of the connection: unknown, low,
    full, high, wireless, super, or super-plus.
    
    Similar information (not exactly the same) is available through sysfs,
    but it seems reasonable to provide the actual value in usbfs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Reinhard Huck &lt;reinhard.huck@thesycon.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 8e6ef671be9b..0e7d0e81a7cb 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -2537,6 +2537,9 @@ static long usbdev_do_ioctl(struct file *file, unsigned int cmd,
 	case USBDEVFS_DROP_PRIVILEGES:
 		ret = proc_drop_privileges(ps, p);
 		break;
+	case USBDEVFS_GET_SPEED:
+		ret = ps-&gt;dev-&gt;speed;
+		break;
 	}
 
  done:
diff --git a/include/uapi/linux/usbdevice_fs.h b/include/uapi/linux/usbdevice_fs.h
index a8653a6f40df..0bbfd4abd2e3 100644
--- a/include/uapi/linux/usbdevice_fs.h
+++ b/include/uapi/linux/usbdevice_fs.h
@@ -156,6 +156,11 @@ struct usbdevfs_streams {
 	unsigned char eps[0];
 };
 
+/*
+ * USB_SPEED_* values returned by USBDEVFS_GET_SPEED are defined in
+ * linux/usb/ch9.h
+ */
+
 #define USBDEVFS_CONTROL           _IOWR('U', 0, struct usbdevfs_ctrltransfer)
 #define USBDEVFS_CONTROL32           _IOWR('U', 0, struct usbdevfs_ctrltransfer32)
 #define USBDEVFS_BULK              _IOWR('U', 2, struct usbdevfs_bulktransfer)
@@ -190,5 +195,6 @@ struct usbdevfs_streams {
 #define USBDEVFS_ALLOC_STREAMS     _IOR('U', 28, struct usbdevfs_streams)
 #define USBDEVFS_FREE_STREAMS      _IOR('U', 29, struct usbdevfs_streams)
 #define USBDEVFS_DROP_PRIVILEGES   _IOW('U', 30, __u32)
+#define USBDEVFS_GET_SPEED         _IO('U', 31)
 
 #endif /* _UAPI_LINUX_USBDEVICE_FS_H */</pre><hr><pre>commit f50b878fed33e360d01dcdc31a8eeb1815d033d5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 8 13:55:59 2017 -0400

    USB: gadget: fix GPF in gadgetfs
    
    A NULL-pointer dereference bug in gadgetfs was uncovered by syzkaller:
    
    &gt; kasan: GPF could be caused by NULL-ptr deref or user memory access
    &gt; general protection fault: 0000 [#1] SMP KASAN
    &gt; Dumping ftrace buffer:
    &gt;    (ftrace buffer empty)
    &gt; Modules linked in:
    &gt; CPU: 2 PID: 4820 Comm: syz-executor0 Not tainted 4.12.0-rc4+ #5
    &gt; Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    &gt; task: ffff880039542dc0 task.stack: ffff88003bdd0000
    &gt; RIP: 0010:__list_del_entry_valid+0x7e/0x170 lib/list_debug.c:51
    &gt; RSP: 0018:ffff88003bdd6e50 EFLAGS: 00010246
    &gt; RAX: dffffc0000000000 RBX: 0000000000000000 RCX: 0000000000010000
    &gt; RDX: 0000000000000000 RSI: ffffffff86504948 RDI: ffffffff86504950
    &gt; RBP: ffff88003bdd6e68 R08: ffff880039542dc0 R09: ffffffff8778ce00
    &gt; R10: ffff88003bdd6e68 R11: dffffc0000000000 R12: 0000000000000000
    &gt; R13: dffffc0000000000 R14: 1ffff100077badd2 R15: ffffffff864d2e40
    &gt; FS:  0000000000000000(0000) GS:ffff88006dc00000(0000) knlGS:0000000000000000
    &gt; CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    &gt; CR2: 000000002014aff9 CR3: 0000000006022000 CR4: 00000000000006e0
    &gt; Call Trace:
    &gt;  __list_del_entry include/linux/list.h:116 [inline]
    &gt;  list_del include/linux/list.h:124 [inline]
    &gt;  usb_gadget_unregister_driver+0x166/0x4c0 drivers/usb/gadget/udc/core.c:1387
    &gt;  dev_release+0x80/0x160 drivers/usb/gadget/legacy/inode.c:1187
    &gt;  __fput+0x332/0x7f0 fs/file_table.c:209
    &gt;  ____fput+0x15/0x20 fs/file_table.c:245
    &gt;  task_work_run+0x19b/0x270 kernel/task_work.c:116
    &gt;  exit_task_work include/linux/task_work.h:21 [inline]
    &gt;  do_exit+0x18a3/0x2820 kernel/exit.c:878
    &gt;  do_group_exit+0x149/0x420 kernel/exit.c:982
    &gt;  get_signal+0x77f/0x1780 kernel/signal.c:2318
    &gt;  do_signal+0xd2/0x2130 arch/x86/kernel/signal.c:808
    &gt;  exit_to_usermode_loop+0x1a7/0x240 arch/x86/entry/common.c:157
    &gt;  prepare_exit_to_usermode arch/x86/entry/common.c:194 [inline]
    &gt;  syscall_return_slowpath+0x3ba/0x410 arch/x86/entry/common.c:263
    &gt;  entry_SYSCALL_64_fastpath+0xbc/0xbe
    &gt; RIP: 0033:0x4461f9
    &gt; RSP: 002b:00007fdac2b1ecf8 EFLAGS: 00000246 ORIG_RAX: 00000000000000ca
    &gt; RAX: fffffffffffffe00 RBX: 00000000007080c8 RCX: 00000000004461f9
    &gt; RDX: 0000000000000000 RSI: 0000000000000000 RDI: 00000000007080c8
    &gt; RBP: 00000000007080a8 R08: 0000000000000000 R09: 0000000000000000
    &gt; R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
    &gt; R13: 0000000000000000 R14: 00007fdac2b1f9c0 R15: 00007fdac2b1f700
    &gt; Code: 00 00 00 00 ad de 49 39 c4 74 6a 48 b8 00 02 00 00 00 00 ad de
    &gt; 48 89 da 48 39 c3 74 74 48 c1 ea 03 48 b8 00 00 00 00 00 fc ff df &lt;80&gt;
    &gt; 3c 02 00 0f 85 92 00 00 00 48 8b 13 48 39 f2 75 66 49 8d 7c
    &gt; RIP: __list_del_entry_valid+0x7e/0x170 lib/list_debug.c:51 RSP: ffff88003bdd6e50
    &gt; ---[ end trace 30e94b1eec4831c8 ]---
    &gt; Kernel panic - not syncing: Fatal exception
    
    The bug was caused by dev_release() failing to turn off its
    gadget_registered flag after unregistering the gadget driver.  As a
    result, when a later user closed the device file before writing a
    valid set of descriptors, dev_release() thought the gadget had been
    registered and tried to unregister it, even though it had not been.
    This led to the NULL pointer dereference.
    
    The fix is simple: turn off the flag when the gadget is unregistered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index b9ca0a26cbd9..5ffd879f7886 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1183,8 +1183,10 @@ dev_release (struct inode *inode, struct file *fd)
 
 	/* closing ep0 === shutdown all */
 
-	if (dev-&gt;gadget_registered)
+	if (dev-&gt;gadget_registered) {
 		usb_gadget_unregister_driver (&amp;gadgetfs_driver);
+		dev-&gt;gadget_registered = false;
+	}
 
 	/* at this point "good" hardware has disconnected the
 	 * device from USB; the host won't see it any more.</pre><hr><pre>commit 5fcf93795e6b72368cd98cd541b6d4bbe8804320
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:48:20 2017 -0400

    USB: ene_usb6250: turn off the Removable flag
    
    In the ene_usb6250 sub-driver for usb-storage, the INQUIRY data
    returned by the driver indicates that the device has removable media.
    While this is technically correct (memory cards can be removed from
    the reader), it is not useful because the device automatically
    disconnects itself from the USB bus when no media is present.
    
    In addition, the driver does not support the PREVENT-ALLOW MEDIUM
    REMOVAL and START STOP UNIT commands, and this can cause
    user-interface frameworks to get confused when the user asks for the
    card to be removed or ejected.
    
    This patch fixes the problem by changing the INQUIRY data to specify
    non-removable media; in practice this value works much better.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index a5ccdefed31e..22b850a1ce06 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -596,7 +596,7 @@ static int do_scsi_request_sense(struct us_data *us, struct scsi_cmnd *srb)
 static int do_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
 {
 	unsigned char data_ptr[36] = {
-		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
+		0x00, 0x00, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
 		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
 		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
 		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };</pre><hr><pre>commit f8efdabd14532c47e5420dc593c2a13028e42140
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:48:10 2017 -0400

    USB: ene_usb6250: remove subroutine duplication
    
    In the ene_usb6250 sub-driver for usb-storage, the sd_scsi_inquiry()
    and ms_scsi_inquiry() subroutines (one meant for use with SD memory
    cards and the other for use with MS memory cards) are exact
    duplicates.  This patch removes the duplication by creating a single
    do_scsi_inquiry() command and using it instead of the other two.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 44aca29ad6cc..a5ccdefed31e 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -593,6 +593,18 @@ static int do_scsi_request_sense(struct us_data *us, struct scsi_cmnd *srb)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
+static int do_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
+{
+	unsigned char data_ptr[36] = {
+		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
+		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
+		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
+		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };
+
+	usb_stor_set_xfer_buf(data_ptr, 36, srb);
+	return USB_STOR_TRANSPORT_GOOD;
+}
+
 static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -607,18 +619,6 @@ static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
-static int sd_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
-{
-	unsigned char data_ptr[36] = {
-		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
-		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
-		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
-		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };
-
-	usb_stor_set_xfer_buf(data_ptr, 36, srb);
-	return USB_STOR_TRANSPORT_GOOD;
-}
-
 static int sd_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -1462,19 +1462,6 @@ static int ms_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
-static int ms_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)
-{
-	/* pr_info("MS_SCSI_Inquiry\n"); */
-	unsigned char data_ptr[36] = {
-		0x00, 0x80, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,
-		0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,
-		0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,
-		0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30};
-
-	usb_stor_set_xfer_buf(data_ptr, 36, srb);
-	return USB_STOR_TRANSPORT_GOOD;
-}
-
 static int ms_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -2236,7 +2223,7 @@ static int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = do_scsi_request_sense(us, srb);
 		break; /* 0x03 */
 	case INQUIRY:
-		result = sd_scsi_inquiry(us, srb);
+		result = do_scsi_inquiry(us, srb);
 		break; /* 0x12 */
 	case MODE_SENSE:
 		result = sd_scsi_mode_sense(us, srb);
@@ -2281,7 +2268,7 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = do_scsi_request_sense(us, srb);
 		break; /* 0x03 */
 	case INQUIRY:
-		result = ms_scsi_inquiry(us, srb);
+		result = do_scsi_inquiry(us, srb);
 		break; /* 0x12 */
 	case MODE_SENSE:
 		result = ms_scsi_mode_sense(us, srb);</pre><hr><pre>commit ce553bd103c161df2676ff201746bff8ca512715
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:48:01 2017 -0400

    USB: ene_usb6250: implement REQUEST SENSE
    
    In the ene_usb6250 sub-driver for usb-storage, there is no support for
    the REQUEST SENSE command.  This command is issued whenever a failure
    occurs, and without it the driver has no way to tell the SCSI core
    what the reason for the failure was.
    
    This patch adds a do_scsi_request_sense() routine to the driver.  The
    new routine reports the error code stored by the previous command.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 107018447551..44aca29ad6cc 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -95,12 +95,12 @@ static struct us_unusual_dev ene_ub6250_unusual_dev_list[] = {
 #define REG_HW_TRAP1        0xFF89
 
 /* SRB Status */
-#define SS_SUCCESS                  0x00      /* No Sense */
-#define SS_NOT_READY                0x02
-#define SS_MEDIUM_ERR               0x03
-#define SS_HW_ERR                   0x04
-#define SS_ILLEGAL_REQUEST          0x05
-#define SS_UNIT_ATTENTION           0x06
+#define SS_SUCCESS		0x000000	/* No Sense */
+#define SS_NOT_READY		0x023A00	/* Medium not present */
+#define SS_MEDIUM_ERR		0x031100	/* Unrecovered read error */
+#define SS_HW_ERR		0x040800	/* Communication failure */
+#define SS_ILLEGAL_REQUEST	0x052000	/* Invalid command */
+#define SS_UNIT_ATTENTION	0x062900	/* Reset occurred */
 
 /* ENE Load FW Pattern */
 #define SD_INIT1_PATTERN   1
@@ -577,6 +577,22 @@ static int ene_send_scsi_cmd(struct us_data *us, u8 fDir, void *buf, int use_sg)
 	return USB_STOR_TRANSPORT_GOOD;
 }
 
+static int do_scsi_request_sense(struct us_data *us, struct scsi_cmnd *srb)
+{
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	unsigned char buf[18];
+
+	memset(buf, 0, 18);
+	buf[0] = 0x70;				/* Current error */
+	buf[2] = info-&gt;SrbStatus &gt;&gt; 16;		/* Sense key */
+	buf[7] = 10;				/* Additional length */
+	buf[12] = info-&gt;SrbStatus &gt;&gt; 8;		/* ASC */
+	buf[13] = info-&gt;SrbStatus;		/* ASCQ */
+
+	usb_stor_set_xfer_buf(buf, sizeof(buf), srb);
+	return USB_STOR_TRANSPORT_GOOD;
+}
+
 static int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)
 {
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
@@ -2212,11 +2228,13 @@ static int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 	int    result;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)us-&gt;extra;
 
-	info-&gt;SrbStatus = SS_SUCCESS;
 	switch (srb-&gt;cmnd[0]) {
 	case TEST_UNIT_READY:
 		result = sd_scsi_test_unit_ready(us, srb);
 		break; /* 0x00 */
+	case REQUEST_SENSE:
+		result = do_scsi_request_sense(us, srb);
+		break; /* 0x03 */
 	case INQUIRY:
 		result = sd_scsi_inquiry(us, srb);
 		break; /* 0x12 */
@@ -2242,6 +2260,8 @@ static int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = USB_STOR_TRANSPORT_FAILED;
 		break;
 	}
+	if (result == USB_STOR_TRANSPORT_GOOD)
+		info-&gt;SrbStatus = SS_SUCCESS;
 	return result;
 }
 
@@ -2252,11 +2272,14 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 {
 	int result;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)us-&gt;extra;
-	info-&gt;SrbStatus = SS_SUCCESS;
+
 	switch (srb-&gt;cmnd[0]) {
 	case TEST_UNIT_READY:
 		result = ms_scsi_test_unit_ready(us, srb);
 		break; /* 0x00 */
+	case REQUEST_SENSE:
+		result = do_scsi_request_sense(us, srb);
+		break; /* 0x03 */
 	case INQUIRY:
 		result = ms_scsi_inquiry(us, srb);
 		break; /* 0x12 */
@@ -2277,6 +2300,8 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 		result = USB_STOR_TRANSPORT_FAILED;
 		break;
 	}
+	if (result == USB_STOR_TRANSPORT_GOOD)
+		info-&gt;SrbStatus = SS_SUCCESS;
 	return result;
 }
 </pre><hr><pre>commit aa18c4b6e0e39bfb00af48734ec24bc189ac9909
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:47:52 2017 -0400

    USB: ene_usb6250: fix SCSI residue overwriting
    
    In the ene_usb6250 sub-driver for usb-storage, the SCSI residue is not
    reported correctly.  The residue is initialized to 0, but this value
    is overwritten whenever the driver sends firmware to the card reader
    before performing the current command.  As a result, a valid READ or
    WRITE operation appears to have failed, causing the SCSI core to retry
    the command multiple times and eventually fail.
    
    This patch fixes the problem by resetting the SCSI residue to 0 after
    sending firmware to the device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 80cd67841074..107018447551 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -1929,6 +1929,8 @@ static int ene_load_bincode(struct us_data *us, unsigned char flag)
 	bcb-&gt;CDB[0] = 0xEF;
 
 	result = ene_send_scsi_cmd(us, FDIR_WRITE, buf, 0);
+	if (us-&gt;srb != NULL)
+		scsi_set_resid(us-&gt;srb, 0);
 	info-&gt;BIN_FLAG = flag;
 	kfree(buf);
 </pre><hr><pre>commit 4b309f1c4972c8f09e03ac64fc63510dbf5591a4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:47:42 2017 -0400

    USB: ene_usb6250: fix first command execution
    
    In the ene_usb6250 sub-driver for usb-storage, the ene_transport()
    routine is supposed to initialize the driver before executing the
    current command, if the initialization has not already been performed.
    However, a bug in the routine causes it to skip the command after
    doing the initialization.  Also, the routine does not return an
    appropriate error code if either the initialization or the command
    fails.
    
    As a result of the first bug, the first command (a SCSI INQUIRY) is
    not carried out.  The results can be seen in the system log, in the
    form of a warning message and empty or garbage INQUIRY data:
    
    Apr 18 22:40:08 notebook2 kernel: scsi host6: scsi scan: INQUIRY result too short (5), using 36
    Apr 18 22:40:08 notebook2 kernel: scsi 6:0:0:0: Direct-Access                                    PQ: 0 ANSI: 0
    
    This patch fixes both errors.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 369f3c24815a..80cd67841074 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -2280,21 +2280,22 @@ static int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)
 
 static int ene_transport(struct scsi_cmnd *srb, struct us_data *us)
 {
-	int result = 0;
+	int result = USB_STOR_XFER_GOOD;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
 
 	/*US_DEBUG(usb_stor_show_command(us, srb)); */
 	scsi_set_resid(srb, 0);
-	if (unlikely(!(info-&gt;SD_Status.Ready || info-&gt;MS_Status.Ready))) {
+	if (unlikely(!(info-&gt;SD_Status.Ready || info-&gt;MS_Status.Ready)))
 		result = ene_init(us);
-	} else {
+	if (result == USB_STOR_XFER_GOOD) {
+		result = USB_STOR_TRANSPORT_ERROR;
 		if (info-&gt;SD_Status.Ready)
 			result = sd_scsi_irp(us, srb);
 
 		if (info-&gt;MS_Status.Ready)
 			result = ms_scsi_irp(us, srb);
 	}
-	return 0;
+	return result;
 }
 
 static struct scsi_host_template ene_ub6250_host_template;</pre><hr><pre>commit 63aea0dbab90a2461faaae357cbc8cfd6c8de9fe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 17 18:32:03 2017 +0300

    USB: xhci: fix lock-inversion problem
    
    With threaded interrupts, bottom-half handlers are called with
    interrupts enabled.  Therefore they can't safely use spin_lock(); they
    have to use spin_lock_irqsave().  Lockdep warns about a violation
    occurring in xhci_irq():
    
    =========================================================
    [ INFO: possible irq lock inversion dependency detected ]
    4.11.0-rc8-dbg+ #1 Not tainted
    ---------------------------------------------------------
    swapper/7/0 just changed the state of lock:
     (&amp;(&amp;ehci-&gt;lock)-&gt;rlock){-.-...}, at: [&lt;ffffffffa0130a69&gt;]
    ehci_hrtimer_func+0x29/0xc0 [ehci_hcd]
    but this lock took another, HARDIRQ-unsafe lock in the past:
     (hcd_urb_list_lock){+.....}
    
    and interrupts could create inverse lock ordering between them.
    
    other info that might help us debug this:
     Possible interrupt unsafe locking scenario:
    
           CPU0                    CPU1
           ----                    ----
      lock(hcd_urb_list_lock);
                                   local_irq_disable();
                                   lock(&amp;(&amp;ehci-&gt;lock)-&gt;rlock);
                                   lock(hcd_urb_list_lock);
      &lt;Interrupt&gt;
        lock(&amp;(&amp;ehci-&gt;lock)-&gt;rlock);
     *** DEADLOCK ***
    
    no locks held by swapper/7/0.
    the shortest dependencies between 2nd lock and 1st lock:
     -&gt; (hcd_urb_list_lock){+.....} ops: 252 {
        HARDIRQ-ON-W at:
                          __lock_acquire+0x602/0x1280
                          lock_acquire+0xd5/0x1c0
                          _raw_spin_lock+0x2f/0x40
                          usb_hcd_unlink_urb_from_ep+0x1b/0x60 [usbcore]
                          xhci_giveback_urb_in_irq.isra.45+0x70/0x1b0 [xhci_hcd]
                          finish_td.constprop.60+0x1d8/0x2e0 [xhci_hcd]
                          xhci_irq+0xdd6/0x1fa0 [xhci_hcd]
                          usb_hcd_irq+0x26/0x40 [usbcore]
                          irq_forced_thread_fn+0x2f/0x70
                          irq_thread+0x149/0x1d0
                          kthread+0x113/0x150
                          ret_from_fork+0x2e/0x40
    
    This patch fixes the problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Bart Van Assche &lt;bart.vanassche@sandisk.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Mathias Nyman &lt;mathias.nyman@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 0830b25f9499..6d2492c1c643 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2677,11 +2677,12 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd)
 	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
 	union xhci_trb *event_ring_deq;
 	irqreturn_t ret = IRQ_NONE;
+	unsigned long flags;
 	dma_addr_t deq;
 	u64 temp_64;
 	u32 status;
 
-	spin_lock(&amp;xhci-&gt;lock);
+	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 	/* Check if the xHC generated the interrupt, or the irq is shared */
 	status = readl(&amp;xhci-&gt;op_regs-&gt;status);
 	if (status == ~(u32)0) {
@@ -2754,7 +2755,7 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd)
 	ret = IRQ_HANDLED;
 
 out:
-	spin_unlock(&amp;xhci-&gt;lock);
+	spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
 
 	return ret;
 }</pre><hr><pre>commit 628c2893d44876ddd11602400c70606ade62e129
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 16 11:47:29 2017 -0400

    USB: ene_usb6250: fix DMA to the stack
    
    The ene_usb6250 sub-driver in usb-storage does USB I/O to buffers on
    the stack, which doesn't work with vmapped stacks.  This patch fixes
    the problem by allocating a separate 512-byte buffer at probe time and
    using it for all of the offending I/O operations.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Andreas Hartmann &lt;andihartmann@01019freenet.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/ene_ub6250.c b/drivers/usb/storage/ene_ub6250.c
index 369f3c24815a..44af719194b2 100644
--- a/drivers/usb/storage/ene_ub6250.c
+++ b/drivers/usb/storage/ene_ub6250.c
@@ -446,6 +446,10 @@ struct ms_lib_ctrl {
 #define SD_BLOCK_LEN  9
 
 struct ene_ub6250_info {
+
+	/* I/O bounce buffer */
+	u8		*bbuf;
+
 	/* for 6250 code */
 	struct SD_STATUS	SD_Status;
 	struct MS_STATUS	MS_Status;
@@ -493,8 +497,11 @@ static int ene_load_bincode(struct us_data *us, unsigned char flag);
 
 static void ene_ub6250_info_destructor(void *extra)
 {
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) extra;
+
 	if (!extra)
 		return;
+	kfree(info-&gt;bbuf);
 }
 
 static int ene_send_scsi_cmd(struct us_data *us, u8 fDir, void *buf, int use_sg)
@@ -860,8 +867,9 @@ static int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,
 		u8 PageNum, u32 *PageBuf, struct ms_lib_type_extdat *ExtraDat)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 	int result;
-	u8 ExtBuf[4];
 	u32 bn = PhyBlockAddr * 0x20 + PageNum;
 
 	result = ene_load_bincode(us, MS_RW_PATTERN);
@@ -901,7 +909,7 @@ static int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,
 	bcb-&gt;CDB[2]     = (unsigned char)(PhyBlockAddr&gt;&gt;16);
 	bcb-&gt;CDB[6]     = 0x01;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;ExtBuf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
@@ -910,9 +918,9 @@ static int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,
 	ExtraDat-&gt;status0  = 0x10;  /* Not yet,fireware support */
 
 	ExtraDat-&gt;status1  = 0x00;  /* Not yet,fireware support */
-	ExtraDat-&gt;ovrflg   = ExtBuf[0];
-	ExtraDat-&gt;mngflg   = ExtBuf[1];
-	ExtraDat-&gt;logadr   = memstick_logaddr(ExtBuf[2], ExtBuf[3]);
+	ExtraDat-&gt;ovrflg   = bbuf[0];
+	ExtraDat-&gt;mngflg   = bbuf[1];
+	ExtraDat-&gt;logadr   = memstick_logaddr(bbuf[2], bbuf[3]);
 
 	return USB_STOR_TRANSPORT_GOOD;
 }
@@ -1332,8 +1340,9 @@ static int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,
 				u8 PageNum, struct ms_lib_type_extdat *ExtraDat)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
+	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 	int result;
-	u8 ExtBuf[4];
 
 	memset(bcb, 0, sizeof(struct bulk_cb_wrap));
 	bcb-&gt;Signature = cpu_to_le32(US_BULK_CB_SIGN);
@@ -1347,7 +1356,7 @@ static int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,
 	bcb-&gt;CDB[2]     = (unsigned char)(PhyBlock&gt;&gt;16);
 	bcb-&gt;CDB[6]     = 0x01;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;ExtBuf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
@@ -1355,9 +1364,9 @@ static int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,
 	ExtraDat-&gt;intr     = 0x80;  /* Not yet, waiting for fireware support */
 	ExtraDat-&gt;status0  = 0x10;  /* Not yet, waiting for fireware support */
 	ExtraDat-&gt;status1  = 0x00;  /* Not yet, waiting for fireware support */
-	ExtraDat-&gt;ovrflg   = ExtBuf[0];
-	ExtraDat-&gt;mngflg   = ExtBuf[1];
-	ExtraDat-&gt;logadr   = memstick_logaddr(ExtBuf[2], ExtBuf[3]);
+	ExtraDat-&gt;ovrflg   = bbuf[0];
+	ExtraDat-&gt;mngflg   = bbuf[1];
+	ExtraDat-&gt;logadr   = memstick_logaddr(bbuf[2], bbuf[3]);
 
 	return USB_STOR_TRANSPORT_GOOD;
 }
@@ -1556,9 +1565,9 @@ static int ms_lib_scan_logicalblocknumber(struct us_data *us, u16 btBlk1st)
 	u16 PhyBlock, newblk, i;
 	u16 LogStart, LogEnde;
 	struct ms_lib_type_extdat extdat;
-	u8 buf[0x200];
 	u32 count = 0, index = 0;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 
 	for (PhyBlock = 0; PhyBlock &lt; info-&gt;MS_Lib.NumberOfPhyBlock;) {
 		ms_lib_phy_to_log_range(PhyBlock, &amp;LogStart, &amp;LogEnde);
@@ -1572,14 +1581,16 @@ static int ms_lib_scan_logicalblocknumber(struct us_data *us, u16 btBlk1st)
 			}
 
 			if (count == PhyBlock) {
-				ms_lib_read_extrablock(us, PhyBlock, 0, 0x80, &amp;buf);
+				ms_lib_read_extrablock(us, PhyBlock, 0, 0x80,
+						bbuf);
 				count += 0x80;
 			}
 			index = (PhyBlock % 0x80) * 4;
 
-			extdat.ovrflg = buf[index];
-			extdat.mngflg = buf[index+1];
-			extdat.logadr = memstick_logaddr(buf[index+2], buf[index+3]);
+			extdat.ovrflg = bbuf[index];
+			extdat.mngflg = bbuf[index+1];
+			extdat.logadr = memstick_logaddr(bbuf[index+2],
+					bbuf[index+3]);
 
 			if ((extdat.ovrflg &amp; MS_REG_OVR_BKST) != MS_REG_OVR_BKST_OK) {
 				ms_lib_setacquired_errorblock(us, PhyBlock);
@@ -2062,9 +2073,9 @@ static int ene_ms_init(struct us_data *us)
 {
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
 	int result;
-	u8 buf[0x200];
 	u16 MSP_BlockSize, MSP_UserAreaBlocks;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 
 	printk(KERN_INFO "transport --- ENE_MSInit\n");
 
@@ -2083,13 +2094,13 @@ static int ene_ms_init(struct us_data *us)
 	bcb-&gt;CDB[0]     = 0xF1;
 	bcb-&gt;CDB[1]     = 0x01;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;buf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD) {
 		printk(KERN_ERR "Execution MS Init Code Fail !!\n");
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 	/* the same part to test ENE */
-	info-&gt;MS_Status = *(struct MS_STATUS *)&amp;buf[0];
+	info-&gt;MS_Status = *(struct MS_STATUS *) bbuf;
 
 	if (info-&gt;MS_Status.Insert &amp;&amp; info-&gt;MS_Status.Ready) {
 		printk(KERN_INFO "Insert     = %x\n", info-&gt;MS_Status.Insert);
@@ -2098,15 +2109,15 @@ static int ene_ms_init(struct us_data *us)
 		printk(KERN_INFO "IsMSPHG    = %x\n", info-&gt;MS_Status.IsMSPHG);
 		printk(KERN_INFO "WtP= %x\n", info-&gt;MS_Status.WtP);
 		if (info-&gt;MS_Status.IsMSPro) {
-			MSP_BlockSize      = (buf[6] &lt;&lt; 8) | buf[7];
-			MSP_UserAreaBlocks = (buf[10] &lt;&lt; 8) | buf[11];
+			MSP_BlockSize      = (bbuf[6] &lt;&lt; 8) | bbuf[7];
+			MSP_UserAreaBlocks = (bbuf[10] &lt;&lt; 8) | bbuf[11];
 			info-&gt;MSP_TotalBlock = MSP_BlockSize * MSP_UserAreaBlocks;
 		} else {
 			ms_card_init(us); /* Card is MS (to ms.c)*/
 		}
 		usb_stor_dbg(us, "MS Init Code OK !!\n");
 	} else {
-		usb_stor_dbg(us, "MS Card Not Ready --- %x\n", buf[0]);
+		usb_stor_dbg(us, "MS Card Not Ready --- %x\n", bbuf[0]);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
@@ -2116,9 +2127,9 @@ static int ene_ms_init(struct us_data *us)
 static int ene_sd_init(struct us_data *us)
 {
 	int result;
-	u8  buf[0x200];
 	struct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us-&gt;iobuf;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *) us-&gt;extra;
+	u8 *bbuf = info-&gt;bbuf;
 
 	usb_stor_dbg(us, "transport --- ENE_SDInit\n");
 	/* SD Init Part-1 */
@@ -2152,17 +2163,17 @@ static int ene_sd_init(struct us_data *us)
 	bcb-&gt;Flags              = US_BULK_FLAG_IN;
 	bcb-&gt;CDB[0]             = 0xF1;
 
-	result = ene_send_scsi_cmd(us, FDIR_READ, &amp;buf, 0);
+	result = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);
 	if (result != USB_STOR_XFER_GOOD) {
 		usb_stor_dbg(us, "Execution SD Init Code Fail !!\n");
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
-	info-&gt;SD_Status =  *(struct SD_STATUS *)&amp;buf[0];
+	info-&gt;SD_Status =  *(struct SD_STATUS *) bbuf;
 	if (info-&gt;SD_Status.Insert &amp;&amp; info-&gt;SD_Status.Ready) {
 		struct SD_STATUS *s = &amp;info-&gt;SD_Status;
 
-		ene_get_card_status(us, (unsigned char *)&amp;buf);
+		ene_get_card_status(us, bbuf);
 		usb_stor_dbg(us, "Insert     = %x\n", s-&gt;Insert);
 		usb_stor_dbg(us, "Ready      = %x\n", s-&gt;Ready);
 		usb_stor_dbg(us, "IsMMC      = %x\n", s-&gt;IsMMC);
@@ -2170,7 +2181,7 @@ static int ene_sd_init(struct us_data *us)
 		usb_stor_dbg(us, "HiSpeed    = %x\n", s-&gt;HiSpeed);
 		usb_stor_dbg(us, "WtP        = %x\n", s-&gt;WtP);
 	} else {
-		usb_stor_dbg(us, "SD Card Not Ready --- %x\n", buf[0]);
+		usb_stor_dbg(us, "SD Card Not Ready --- %x\n", bbuf[0]);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 	return USB_STOR_TRANSPORT_GOOD;
@@ -2180,13 +2191,15 @@ static int ene_sd_init(struct us_data *us)
 static int ene_init(struct us_data *us)
 {
 	int result;
-	u8  misc_reg03 = 0;
+	u8  misc_reg03;
 	struct ene_ub6250_info *info = (struct ene_ub6250_info *)(us-&gt;extra);
+	u8 *bbuf = info-&gt;bbuf;
 
-	result = ene_get_card_type(us, REG_CARD_STATUS, &amp;misc_reg03);
+	result = ene_get_card_type(us, REG_CARD_STATUS, bbuf);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
+	misc_reg03 = bbuf[0];
 	if (misc_reg03 &amp; 0x01) {
 		if (!info-&gt;SD_Status.Ready) {
 			result = ene_sd_init(us);
@@ -2303,8 +2316,9 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 			 const struct usb_device_id *id)
 {
 	int result;
-	u8  misc_reg03 = 0;
+	u8  misc_reg03;
 	struct us_data *us;
+	struct ene_ub6250_info *info;
 
 	result = usb_stor_probe1(&amp;us, intf, id,
 		   (id - ene_ub6250_usb_ids) + ene_ub6250_unusual_dev_list,
@@ -2313,11 +2327,16 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 		return result;
 
 	/* FIXME: where should the code alloc extra buf ? */
-	if (!us-&gt;extra) {
-		us-&gt;extra = kzalloc(sizeof(struct ene_ub6250_info), GFP_KERNEL);
-		if (!us-&gt;extra)
-			return -ENOMEM;
-		us-&gt;extra_destructor = ene_ub6250_info_destructor;
+	us-&gt;extra = kzalloc(sizeof(struct ene_ub6250_info), GFP_KERNEL);
+	if (!us-&gt;extra)
+		return -ENOMEM;
+	us-&gt;extra_destructor = ene_ub6250_info_destructor;
+
+	info = (struct ene_ub6250_info *)(us-&gt;extra);
+	info-&gt;bbuf = kmalloc(512, GFP_KERNEL);
+	if (!info-&gt;bbuf) {
+		kfree(us-&gt;extra);
+		return -ENOMEM;
 	}
 
 	us-&gt;transport_name = "ene_ub6250";
@@ -2329,12 +2348,13 @@ static int ene_ub6250_probe(struct usb_interface *intf,
 		return result;
 
 	/* probe card type */
-	result = ene_get_card_type(us, REG_CARD_STATUS, &amp;misc_reg03);
+	result = ene_get_card_type(us, REG_CARD_STATUS, info-&gt;bbuf);
 	if (result != USB_STOR_XFER_GOOD) {
 		usb_stor_disconnect(intf);
 		return USB_STOR_TRANSPORT_ERROR;
 	}
 
+	misc_reg03 = info-&gt;bbuf[0];
 	if (!(misc_reg03 &amp; 0x01)) {
 		pr_info("ums_eneub6250: This driver only supports SD/MS cards. "
 			"It does not support SM cards.\n");</pre><hr><pre>commit 225785aec726f3edd5077be8f084b0b70ca197a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 13 16:37:01 2017 -0400

    USB: f_mass_storage: improve memory barriers and synchronization
    
    This patch reworks the way f_mass_storage.c handles memory barriers
    and synchronization:
    
            The driver now uses a wait_queue instead of doing its own
            task-state manipulations (even though only one task will ever
            use the wait_queue).
    
            The thread_wakeup_needed variable is removed.  It was only a
            source of trouble; although it was what the driver tested to
            see whether it should wake up, what we really wanted to see
            was whether a USB transfer had completed.
    
            All the explicit memory barriers scattered throughout the
            driver are replaced by a few calls to smp_load_acquire() and
            smp_store_release().
    
            The inreq_busy and outreq_busy fields are removed.  In their
            place, the driver keeps track of the current I/O direction by
            splitting BUF_STATE_BUSY into two states: BUF_STATE_SENDING
            and BUF_STATE_RECEIVING.
    
            The buffer states are no longer protected by a lock.  Mutual
            exclusion isn't needed; the state is changed only by the
            driver's main thread when it owns the buffer, and only by the
            request completion routine when the gadget core owns the buffer.
    
            The do_write() and throw_away_data() routines were reorganized
            to make efficient use of the new sleeping mechanism.  This
            resulted in the removal of one indentation level in those
            routines, making the patch appear to be more more complicated
            than it really is.
    
            In a few places, the driver allowed itself to be frozen although
            it really shouldn't have (in the middle of executing a SCSI
            command).  Those places have been fixed.
    
            The logic in the exception handler for aborting transfers and
            waiting for them to stop has been simplified.
    
    Tested-by: Thinh Nguyen &lt;thinhn@synopsys.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index a0890a058f09..e80b9c123a9d 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -260,12 +260,13 @@ struct fsg_common {
 	struct usb_gadget	*gadget;
 	struct usb_composite_dev *cdev;
 	struct fsg_dev		*fsg, *new_fsg;
+	wait_queue_head_t	io_wait;
 	wait_queue_head_t	fsg_wait;
 
 	/* filesem protects: backing files in use */
 	struct rw_semaphore	filesem;
 
-	/* lock protects: state, all the req_busy's */
+	/* lock protects: state and thread_task */
 	spinlock_t		lock;
 
 	struct usb_ep		*ep0;		/* Copy of gadget-&gt;ep0 */
@@ -303,7 +304,6 @@ struct fsg_common {
 	unsigned int		running:1;
 	unsigned int		sysfs:1;
 
-	int			thread_wakeup_needed;
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
 
@@ -393,16 +393,6 @@ static int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)
 
 /* These routines may be called in process context or in_irq */
 
-/* Caller must hold fsg-&gt;lock */
-static void wakeup_thread(struct fsg_common *common)
-{
-	smp_wmb();	/* ensure the write of bh-&gt;state is complete */
-	/* Tell the main thread that something has happened */
-	common-&gt;thread_wakeup_needed = 1;
-	if (common-&gt;thread_task)
-		wake_up_process(common-&gt;thread_task);
-}
-
 static void raise_exception(struct fsg_common *common, enum fsg_state new_state)
 {
 	unsigned long		flags;
@@ -456,13 +446,9 @@ static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
 	if (req-&gt;status == -ECONNRESET)		/* Request was cancelled */
 		usb_ep_fifo_flush(ep);
 
-	/* Hold the lock while we update the request and buffer states */
-	smp_wmb();
-	spin_lock(&amp;common-&gt;lock);
-	bh-&gt;inreq_busy = 0;
-	bh-&gt;state = BUF_STATE_EMPTY;
-	wakeup_thread(common);
-	spin_unlock(&amp;common-&gt;lock);
+	/* Synchronize with the smp_load_acquire() in sleep_thread() */
+	smp_store_release(&amp;bh-&gt;state, BUF_STATE_EMPTY);
+	wake_up(&amp;common-&gt;io_wait);
 }
 
 static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
@@ -477,13 +463,9 @@ static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
 	if (req-&gt;status == -ECONNRESET)		/* Request was cancelled */
 		usb_ep_fifo_flush(ep);
 
-	/* Hold the lock while we update the request and buffer states */
-	smp_wmb();
-	spin_lock(&amp;common-&gt;lock);
-	bh-&gt;outreq_busy = 0;
-	bh-&gt;state = BUF_STATE_FULL;
-	wakeup_thread(common);
-	spin_unlock(&amp;common-&gt;lock);
+	/* Synchronize with the smp_load_acquire() in sleep_thread() */
+	smp_store_release(&amp;bh-&gt;state, BUF_STATE_FULL);
+	wake_up(&amp;common-&gt;io_wait);
 }
 
 static int _fsg_common_get_max_lun(struct fsg_common *common)
@@ -559,43 +541,39 @@ static int fsg_setup(struct usb_function *f,
 /* All the following routines run in process context */
 
 /* Use this for bulk or interrupt transfers, not ep0 */
-static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
-			   struct usb_request *req, int *pbusy,
-			   enum fsg_buffer_state *state)
+static int start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
+			   struct usb_request *req)
 {
 	int	rc;
 
 	if (ep == fsg-&gt;bulk_in)
 		dump_msg(fsg, "bulk-in", req-&gt;buf, req-&gt;length);
 
-	spin_lock_irq(&amp;fsg-&gt;common-&gt;lock);
-	*pbusy = 1;
-	*state = BUF_STATE_BUSY;
-	spin_unlock_irq(&amp;fsg-&gt;common-&gt;lock);
-
 	rc = usb_ep_queue(ep, req, GFP_KERNEL);
-	if (rc == 0)
-		return;  /* All good, we're done */
-
-	*pbusy = 0;
-	*state = BUF_STATE_EMPTY;
+	if (rc) {
 
-	/* We can't do much more than wait for a reset */
+		/* We can't do much more than wait for a reset */
+		req-&gt;status = rc;
 
-	/*
-	 * Note: currently the net2280 driver fails zero-length
-	 * submissions if DMA is enabled.
-	 */
-	if (rc != -ESHUTDOWN &amp;&amp; !(rc == -EOPNOTSUPP &amp;&amp; req-&gt;length == 0))
-		WARNING(fsg, "error in submission: %s --&gt; %d\n", ep-&gt;name, rc);
+		/*
+		 * Note: currently the net2280 driver fails zero-length
+		 * submissions if DMA is enabled.
+		 */
+		if (rc != -ESHUTDOWN &amp;&amp;
+				!(rc == -EOPNOTSUPP &amp;&amp; req-&gt;length == 0))
+			WARNING(fsg, "error in submission: %s --&gt; %d\n",
+					ep-&gt;name, rc);
+	}
+	return rc;
 }
 
 static bool start_in_transfer(struct fsg_common *common, struct fsg_buffhd *bh)
 {
 	if (!fsg_is_set(common))
 		return false;
-	start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_in,
-		       bh-&gt;inreq, &amp;bh-&gt;inreq_busy, &amp;bh-&gt;state);
+	bh-&gt;state = BUF_STATE_SENDING;
+	if (start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_in, bh-&gt;inreq))
+		bh-&gt;state = BUF_STATE_EMPTY;
 	return true;
 }
 
@@ -603,32 +581,31 @@ static bool start_out_transfer(struct fsg_common *common, struct fsg_buffhd *bh)
 {
 	if (!fsg_is_set(common))
 		return false;
-	start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_out,
-		       bh-&gt;outreq, &amp;bh-&gt;outreq_busy, &amp;bh-&gt;state);
+	bh-&gt;state = BUF_STATE_RECEIVING;
+	if (start_transfer(common-&gt;fsg, common-&gt;fsg-&gt;bulk_out, bh-&gt;outreq))
+		bh-&gt;state = BUF_STATE_FULL;
 	return true;
 }
 
-static int sleep_thread(struct fsg_common *common, bool can_freeze)
+static int sleep_thread(struct fsg_common *common, bool can_freeze,
+		struct fsg_buffhd *bh)
 {
-	int	rc = 0;
+	int	rc;
 
-	/* Wait until a signal arrives or we are woken up */
-	for (;;) {
-		if (can_freeze)
-			try_to_freeze();
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (signal_pending(current)) {
-			rc = -EINTR;
-			break;
-		}
-		if (common-&gt;thread_wakeup_needed)
-			break;
-		schedule();
-	}
-	__set_current_state(TASK_RUNNING);
-	common-&gt;thread_wakeup_needed = 0;
-	smp_rmb();	/* ensure the latest bh-&gt;state is visible */
-	return rc;
+	/* Wait until a signal arrives or bh is no longer busy */
+	if (can_freeze)
+		/*
+		 * synchronize with the smp_store_release(&amp;bh-&gt;state) in
+		 * bulk_in_complete() or bulk_out_complete()
+		 */
+		rc = wait_event_freezable(common-&gt;io_wait,
+				bh &amp;&amp; smp_load_acquire(&amp;bh-&gt;state) &gt;=
+					BUF_STATE_EMPTY);
+	else
+		rc = wait_event_interruptible(common-&gt;io_wait,
+				bh &amp;&amp; smp_load_acquire(&amp;bh-&gt;state) &gt;=
+					BUF_STATE_EMPTY);
+	return rc ? -EINTR : 0;
 }
 
 
@@ -688,11 +665,9 @@ static int do_read(struct fsg_common *common)
 
 		/* Wait for the next buffer to become available */
 		bh = common-&gt;next_buffhd_to_fill;
-		while (bh-&gt;state != BUF_STATE_EMPTY) {
-			rc = sleep_thread(common, false);
-			if (rc)
-				return rc;
-		}
+		rc = sleep_thread(common, false, bh);
+		if (rc)
+			return rc;
 
 		/*
 		 * If we were asked to read past the end of file,
@@ -869,84 +844,80 @@ static int do_write(struct fsg_common *common)
 		bh = common-&gt;next_buffhd_to_drain;
 		if (bh-&gt;state == BUF_STATE_EMPTY &amp;&amp; !get_some_more)
 			break;			/* We stopped early */
-		if (bh-&gt;state == BUF_STATE_FULL) {
-			smp_rmb();
-			common-&gt;next_buffhd_to_drain = bh-&gt;next;
-			bh-&gt;state = BUF_STATE_EMPTY;
-
-			/* Did something go wrong with the transfer? */
-			if (bh-&gt;outreq-&gt;status != 0) {
-				curlun-&gt;sense_data = SS_COMMUNICATION_FAILURE;
-				curlun-&gt;sense_data_info =
+
+		/* Wait for the data to be received */
+		rc = sleep_thread(common, false, bh);
+		if (rc)
+			return rc;
+
+		common-&gt;next_buffhd_to_drain = bh-&gt;next;
+		bh-&gt;state = BUF_STATE_EMPTY;
+
+		/* Did something go wrong with the transfer? */
+		if (bh-&gt;outreq-&gt;status != 0) {
+			curlun-&gt;sense_data = SS_COMMUNICATION_FAILURE;
+			curlun-&gt;sense_data_info =
 					file_offset &gt;&gt; curlun-&gt;blkbits;
-				curlun-&gt;info_valid = 1;
-				break;
-			}
+			curlun-&gt;info_valid = 1;
+			break;
+		}
 
-			amount = bh-&gt;outreq-&gt;actual;
-			if (curlun-&gt;file_length - file_offset &lt; amount) {
-				LERROR(curlun,
-				       "write %u @ %llu beyond end %llu\n",
+		amount = bh-&gt;outreq-&gt;actual;
+		if (curlun-&gt;file_length - file_offset &lt; amount) {
+			LERROR(curlun, "write %u @ %llu beyond end %llu\n",
 				       amount, (unsigned long long)file_offset,
 				       (unsigned long long)curlun-&gt;file_length);
-				amount = curlun-&gt;file_length - file_offset;
-			}
+			amount = curlun-&gt;file_length - file_offset;
+		}
 
-			/* Don't accept excess data.  The spec doesn't say
-			 * what to do in this case.  We'll ignore the error.
-			 */
-			amount = min(amount, bh-&gt;bulk_out_intended_length);
-
-			/* Don't write a partial block */
-			amount = round_down(amount, curlun-&gt;blksize);
-			if (amount == 0)
-				goto empty_write;
-
-			/* Perform the write */
-			file_offset_tmp = file_offset;
-			nwritten = vfs_write(curlun-&gt;filp,
-					     (char __user *)bh-&gt;buf,
-					     amount, &amp;file_offset_tmp);
-			VLDBG(curlun, "file write %u @ %llu -&gt; %d\n", amount,
-			      (unsigned long long)file_offset, (int)nwritten);
-			if (signal_pending(current))
-				return -EINTR;		/* Interrupted! */
-
-			if (nwritten &lt; 0) {
-				LDBG(curlun, "error in file write: %d\n",
-				     (int)nwritten);
-				nwritten = 0;
-			} else if (nwritten &lt; amount) {
-				LDBG(curlun, "partial file write: %d/%u\n",
-				     (int)nwritten, amount);
-				nwritten = round_down(nwritten, curlun-&gt;blksize);
-			}
-			file_offset += nwritten;
-			amount_left_to_write -= nwritten;
-			common-&gt;residue -= nwritten;
+		/*
+		 * Don't accept excess data.  The spec doesn't say
+		 * what to do in this case.  We'll ignore the error.
+		 */
+		amount = min(amount, bh-&gt;bulk_out_intended_length);
 
-			/* If an error occurred, report it and its position */
-			if (nwritten &lt; amount) {
-				curlun-&gt;sense_data = SS_WRITE_ERROR;
-				curlun-&gt;sense_data_info =
+		/* Don't write a partial block */
+		amount = round_down(amount, curlun-&gt;blksize);
+		if (amount == 0)
+			goto empty_write;
+
+		/* Perform the write */
+		file_offset_tmp = file_offset;
+		nwritten = vfs_write(curlun-&gt;filp, (char __user *)bh-&gt;buf,
+				amount, &amp;file_offset_tmp);
+		VLDBG(curlun, "file write %u @ %llu -&gt; %d\n", amount,
+				(unsigned long long)file_offset, (int)nwritten);
+		if (signal_pending(current))
+			return -EINTR;		/* Interrupted! */
+
+		if (nwritten &lt; 0) {
+			LDBG(curlun, "error in file write: %d\n",
+					(int) nwritten);
+			nwritten = 0;
+		} else if (nwritten &lt; amount) {
+			LDBG(curlun, "partial file write: %d/%u\n",
+					(int) nwritten, amount);
+			nwritten = round_down(nwritten, curlun-&gt;blksize);
+		}
+		file_offset += nwritten;
+		amount_left_to_write -= nwritten;
+		common-&gt;residue -= nwritten;
+
+		/* If an error occurred, report it and its position */
+		if (nwritten &lt; amount) {
+			curlun-&gt;sense_data = SS_WRITE_ERROR;
+			curlun-&gt;sense_data_info =
 					file_offset &gt;&gt; curlun-&gt;blkbits;
-				curlun-&gt;info_valid = 1;
-				break;
-			}
+			curlun-&gt;info_valid = 1;
+			break;
+		}
 
  empty_write:
-			/* Did the host decide to stop early? */
-			if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length) {
-				common-&gt;short_packet_received = 1;
-				break;
-			}
-			continue;
+		/* Did the host decide to stop early? */
+		if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length) {
+			common-&gt;short_packet_received = 1;
+			break;
 		}
-
-		/* Wait for something to happen */
-		rc = sleep_thread(common, false);
-		if (rc)
-			return rc;
 	}
 
 	return -EIO;		/* No default reply */
@@ -1471,7 +1442,7 @@ static int wedge_bulk_in_endpoint(struct fsg_dev *fsg)
 
 static int throw_away_data(struct fsg_common *common)
 {
-	struct fsg_buffhd	*bh;
+	struct fsg_buffhd	*bh, *bh2;
 	u32			amount;
 	int			rc;
 
@@ -1479,26 +1450,10 @@ static int throw_away_data(struct fsg_common *common)
 	     bh-&gt;state != BUF_STATE_EMPTY || common-&gt;usb_amount_left &gt; 0;
 	     bh = common-&gt;next_buffhd_to_drain) {
 
-		/* Throw away the data in a filled buffer */
-		if (bh-&gt;state == BUF_STATE_FULL) {
-			smp_rmb();
-			bh-&gt;state = BUF_STATE_EMPTY;
-			common-&gt;next_buffhd_to_drain = bh-&gt;next;
-
-			/* A short packet or an error ends everything */
-			if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length ||
-			    bh-&gt;outreq-&gt;status != 0) {
-				raise_exception(common,
-						FSG_STATE_ABORT_BULK_OUT);
-				return -EINTR;
-			}
-			continue;
-		}
-
 		/* Try to submit another request if we need one */
-		bh = common-&gt;next_buffhd_to_fill;
-		if (bh-&gt;state == BUF_STATE_EMPTY
-		 &amp;&amp; common-&gt;usb_amount_left &gt; 0) {
+		bh2 = common-&gt;next_buffhd_to_fill;
+		if (bh2-&gt;state == BUF_STATE_EMPTY &amp;&amp;
+				common-&gt;usb_amount_left &gt; 0) {
 			amount = min(common-&gt;usb_amount_left, FSG_BUFLEN);
 
 			/*
@@ -1506,19 +1461,30 @@ static int throw_away_data(struct fsg_common *common)
 			 * equal to the buffer size, which is divisible by
 			 * the bulk-out maxpacket size.
 			 */
-			set_bulk_out_req_length(common, bh, amount);
-			if (!start_out_transfer(common, bh))
+			set_bulk_out_req_length(common, bh2, amount);
+			if (!start_out_transfer(common, bh2))
 				/* Dunno what to do if common-&gt;fsg is NULL */
 				return -EIO;
-			common-&gt;next_buffhd_to_fill = bh-&gt;next;
+			common-&gt;next_buffhd_to_fill = bh2-&gt;next;
 			common-&gt;usb_amount_left -= amount;
 			continue;
 		}
 
-		/* Otherwise wait for something to happen */
-		rc = sleep_thread(common, true);
+		/* Wait for the data to be received */
+		rc = sleep_thread(common, false, bh);
 		if (rc)
 			return rc;
+
+		/* Throw away the data in a filled buffer */
+		bh-&gt;state = BUF_STATE_EMPTY;
+		common-&gt;next_buffhd_to_drain = bh-&gt;next;
+
+		/* A short packet or an error ends everything */
+		if (bh-&gt;outreq-&gt;actual &lt; bh-&gt;bulk_out_intended_length ||
+				bh-&gt;outreq-&gt;status != 0) {
+			raise_exception(common, FSG_STATE_ABORT_BULK_OUT);
+			return -EINTR;
+		}
 	}
 	return 0;
 }
@@ -1636,11 +1602,9 @@ static void send_status(struct fsg_common *common)
 
 	/* Wait for the next buffer to become available */
 	bh = common-&gt;next_buffhd_to_fill;
-	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return;
-	}
+	rc = sleep_thread(common, false, bh);
+	if (rc)
+		return;
 
 	if (curlun) {
 		sd = curlun-&gt;sense_data;
@@ -1839,11 +1803,10 @@ static int do_scsi_command(struct fsg_common *common)
 	/* Wait for the next buffer to become available for data or status */
 	bh = common-&gt;next_buffhd_to_fill;
 	common-&gt;next_buffhd_to_drain = bh;
-	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return rc;
-	}
+	rc = sleep_thread(common, false, bh);
+	if (rc)
+		return rc;
+
 	common-&gt;phase_error = 0;
 	common-&gt;short_packet_received = 0;
 
@@ -2186,11 +2149,9 @@ static int get_next_command(struct fsg_common *common)
 
 	/* Wait for the next buffer to become available */
 	bh = common-&gt;next_buffhd_to_fill;
-	while (bh-&gt;state != BUF_STATE_EMPTY) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return rc;
-	}
+	rc = sleep_thread(common, true, bh);
+	if (rc)
+		return rc;
 
 	/* Queue a request to read a Bulk-only CBW */
 	set_bulk_out_req_length(common, bh, US_BULK_CB_WRAP_LEN);
@@ -2205,12 +2166,10 @@ static int get_next_command(struct fsg_common *common)
 	 */
 
 	/* Wait for the CBW to arrive */
-	while (bh-&gt;state != BUF_STATE_FULL) {
-		rc = sleep_thread(common, true);
-		if (rc)
-			return rc;
-	}
-	smp_rmb();
+	rc = sleep_thread(common, true, bh);
+	if (rc)
+		return rc;
+
 	rc = fsg_is_set(common) ? received_cbw(common-&gt;fsg, bh) : -EIO;
 	bh-&gt;state = BUF_STATE_EMPTY;
 
@@ -2374,23 +2333,14 @@ static void handle_exception(struct fsg_common *common)
 	if (likely(common-&gt;fsg)) {
 		for (i = 0; i &lt; common-&gt;fsg_num_buffers; ++i) {
 			bh = &amp;common-&gt;buffhds[i];
-			if (bh-&gt;inreq_busy)
+			if (bh-&gt;state == BUF_STATE_SENDING)
 				usb_ep_dequeue(common-&gt;fsg-&gt;bulk_in, bh-&gt;inreq);
-			if (bh-&gt;outreq_busy)
+			if (bh-&gt;state == BUF_STATE_RECEIVING)
 				usb_ep_dequeue(common-&gt;fsg-&gt;bulk_out,
 					       bh-&gt;outreq);
-		}
 
-		/* Wait until everything is idle */
-		for (;;) {
-			int num_active = 0;
-			for (i = 0; i &lt; common-&gt;fsg_num_buffers; ++i) {
-				bh = &amp;common-&gt;buffhds[i];
-				num_active += bh-&gt;inreq_busy + bh-&gt;outreq_busy;
-			}
-			if (num_active == 0)
-				break;
-			if (sleep_thread(common, true))
+			/* Wait for a transfer to become idle */
+			if (sleep_thread(common, false, bh))
 				return;
 		}
 
@@ -2518,7 +2468,7 @@ static int fsg_main_thread(void *common_)
 		}
 
 		if (!common-&gt;running) {
-			sleep_thread(common, true);
+			sleep_thread(common, true, NULL);
 			continue;
 		}
 
@@ -2648,6 +2598,7 @@ static struct fsg_common *fsg_common_setup(struct fsg_common *common)
 	spin_lock_init(&amp;common-&gt;lock);
 	kref_init(&amp;common-&gt;ref);
 	init_completion(&amp;common-&gt;thread_notifier);
+	init_waitqueue_head(&amp;common-&gt;io_wait);
 	init_waitqueue_head(&amp;common-&gt;fsg_wait);
 	common-&gt;state = FSG_STATE_TERMINATED;
 	memset(common-&gt;luns, 0, sizeof(common-&gt;luns));
diff --git a/drivers/usb/gadget/function/storage_common.h b/drivers/usb/gadget/function/storage_common.h
index e6095dfbf1d5..e0814a960132 100644
--- a/drivers/usb/gadget/function/storage_common.h
+++ b/drivers/usb/gadget/function/storage_common.h
@@ -133,9 +133,10 @@ static inline bool fsg_lun_is_open(struct fsg_lun *curlun)
 #define FSG_MAX_LUNS	16
 
 enum fsg_buffer_state {
+	BUF_STATE_SENDING = -2,
+	BUF_STATE_RECEIVING,
 	BUF_STATE_EMPTY = 0,
-	BUF_STATE_FULL,
-	BUF_STATE_BUSY
+	BUF_STATE_FULL
 };
 
 struct fsg_buffhd {
@@ -151,9 +152,7 @@ struct fsg_buffhd {
 	unsigned int			bulk_out_intended_length;
 
 	struct usb_request		*inreq;
-	int				inreq_busy;
 	struct usb_request		*outreq;
-	int				outreq_busy;
 };
 
 enum fsg_state {</pre>
    <div class="pagination">
        <a href='2_20.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><span>[21]</span><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_22.html'>Next&gt;&gt;</a>
    <div>
</body>
