<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Fudan University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Fudan University</h1>
    <div class="pagination">
        <a href='16_6.html'>&lt;&lt;Prev</a><a href='16.html'>1</a><a href='16_2.html'>2</a><a href='16_3.html'>3</a><a href='16_4.html'>4</a><a href='16_5.html'>5</a><a href='16_6.html'>6</a><span>[7]</span>
    </div>
    <hr>
    <pre>commit 6f91a3f7af4186099dd10fa530dd7e0d9c29747d
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Mon Apr 20 13:37:20 2020 +0800

    batman-adv: Fix refcnt leak in batadv_v_ogm_process
    
    batadv_v_ogm_process() invokes batadv_hardif_neigh_get(), which returns
    a reference of the neighbor object to "hardif_neigh" with increased
    refcount.
    
    When batadv_v_ogm_process() returns, "hardif_neigh" becomes invalid, so
    the refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one exception handling paths of
    batadv_v_ogm_process(). When batadv_v_ogm_orig_get() fails to get the
    orig node and returns NULL, the refcnt increased by
    batadv_hardif_neigh_get() is not decreased, causing a refcnt leak.
    
    Fix this issue by jumping to "out" label when batadv_v_ogm_orig_get()
    fails to get the orig node.
    
    Fixes: 9323158ef9f4 ("batman-adv: OGMv2 - implement originators logic")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: Sven Eckelmann &lt;sven@narfation.org&gt;
    Signed-off-by: Simon Wunderlich &lt;sw@simonwunderlich.de&gt;

diff --git a/net/batman-adv/bat_v_ogm.c b/net/batman-adv/bat_v_ogm.c
index 969466218999..80b87b1f4e3a 100644
--- a/net/batman-adv/bat_v_ogm.c
+++ b/net/batman-adv/bat_v_ogm.c
@@ -893,7 +893,7 @@ static void batadv_v_ogm_process(const struct sk_buff *skb, int ogm_offset,
 
 	orig_node = batadv_v_ogm_orig_get(bat_priv, ogm_packet-&gt;orig);
 	if (!orig_node)
-		return;
+		goto out;
 
 	neigh_node = batadv_neigh_node_get_or_create(orig_node, if_incoming,
 						     ethhdr-&gt;h_source);</pre><hr><pre>commit 6107c5da0fca8b50b4d3215e94d619d38cc4a18c
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Wed Apr 15 16:35:21 2020 +0800

    batman-adv: Fix refcnt leak in batadv_store_throughput_override
    
    batadv_show_throughput_override() invokes batadv_hardif_get_by_netdev(),
    which gets a batadv_hard_iface object from net_dev with increased refcnt
    and its reference is assigned to a local pointer 'hard_iface'.
    
    When batadv_store_throughput_override() returns, "hard_iface" becomes
    invalid, so the refcount should be decreased to keep refcount balanced.
    
    The issue happens in one error path of
    batadv_store_throughput_override(). When batadv_parse_throughput()
    returns NULL, the refcnt increased by batadv_hardif_get_by_netdev() is
    not decreased, causing a refcnt leak.
    
    Fix this issue by jumping to "out" label when batadv_parse_throughput()
    returns NULL.
    
    Fixes: 0b5ecc6811bd ("batman-adv: add throughput override attribute to hard_ifaces")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: Sven Eckelmann &lt;sven@narfation.org&gt;
    Signed-off-by: Simon Wunderlich &lt;sw@simonwunderlich.de&gt;

diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
index c0b00268aac4..0f962dcd239e 100644
--- a/net/batman-adv/sysfs.c
+++ b/net/batman-adv/sysfs.c
@@ -1150,7 +1150,7 @@ static ssize_t batadv_store_throughput_override(struct kobject *kobj,
 	ret = batadv_parse_throughput(net_dev, buff, "throughput_override",
 				      &amp;tp_override);
 	if (!ret)
-		return count;
+		goto out;
 
 	old_tp_override = atomic_read(&amp;hard_iface-&gt;bat_v.throughput_override);
 	if (old_tp_override == tp_override)</pre><hr><pre>commit f872de8185acf1b48b954ba5bd8f9bc0a0d14016
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Wed Apr 15 16:31:50 2020 +0800

    batman-adv: Fix refcnt leak in batadv_show_throughput_override
    
    batadv_show_throughput_override() invokes batadv_hardif_get_by_netdev(),
    which gets a batadv_hard_iface object from net_dev with increased refcnt
    and its reference is assigned to a local pointer 'hard_iface'.
    
    When batadv_show_throughput_override() returns, "hard_iface" becomes
    invalid, so the refcount should be decreased to keep refcount balanced.
    
    The issue happens in the normal path of
    batadv_show_throughput_override(), which forgets to decrease the refcnt
    increased by batadv_hardif_get_by_netdev() before the function returns,
    causing a refcnt leak.
    
    Fix this issue by calling batadv_hardif_put() before the
    batadv_show_throughput_override() returns in the normal path.
    
    Fixes: 0b5ecc6811bd ("batman-adv: add throughput override attribute to hard_ifaces")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: Sven Eckelmann &lt;sven@narfation.org&gt;
    Signed-off-by: Simon Wunderlich &lt;sw@simonwunderlich.de&gt;

diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
index c45962d8527b..c0b00268aac4 100644
--- a/net/batman-adv/sysfs.c
+++ b/net/batman-adv/sysfs.c
@@ -1190,6 +1190,7 @@ static ssize_t batadv_show_throughput_override(struct kobject *kobj,
 
 	tp_override = atomic_read(&amp;hard_iface-&gt;bat_v.throughput_override);
 
+	batadv_hardif_put(hard_iface);
 	return sprintf(buff, "%u.%u MBit\n", tp_override / 10,
 		       tp_override % 10);
 }</pre><hr><pre>commit e07c7606a00c4361bad72ff4e72ed0dfbefa23b0
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Mon Apr 20 13:41:54 2020 +0800

    drm/i915/selftests: Fix i915_address_space refcnt leak
    
    igt_ppgtt_pin_update() invokes i915_gem_context_get_vm_rcu(), which
    returns a reference of the i915_address_space object to "vm" with
    increased refcount.
    
    When igt_ppgtt_pin_update() returns, "vm" becomes invalid, so the
    refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in two exception handling paths of
    igt_ppgtt_pin_update(). When i915_gem_object_create_internal() returns
    IS_ERR, the refcnt increased by i915_gem_context_get_vm_rcu() is not
    decreased, causing a refcnt leak.
    
    Fix this issue by jumping to "out_vm" label when
    i915_gem_object_create_internal() returns IS_ERR.
    
    Fixes: a4e7ccdac38e ("drm/i915: Move context management under GEM")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Reviewed-by: Chris Wilson &lt;chris@chris-wilson.co.uk&gt;
    Signed-off-by: Chris Wilson &lt;chris@chris-wilson.co.uk&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/1587361342-83494-1-git-send-email-xiyuyang19@fudan.edu.cn

diff --git a/drivers/gpu/drm/i915/gem/selftests/huge_pages.c b/drivers/gpu/drm/i915/gem/selftests/huge_pages.c
index 2d0fd50c5312..d4f94ca9ae0d 100644
--- a/drivers/gpu/drm/i915/gem/selftests/huge_pages.c
+++ b/drivers/gpu/drm/i915/gem/selftests/huge_pages.c
@@ -1477,8 +1477,10 @@ static int igt_ppgtt_pin_update(void *arg)
 		unsigned int page_size = BIT(first);
 
 		obj = i915_gem_object_create_internal(dev_priv, page_size);
-		if (IS_ERR(obj))
-			return PTR_ERR(obj);
+		if (IS_ERR(obj)) {
+			err = PTR_ERR(obj);
+			goto out_vm;
+		}
 
 		vma = i915_vma_instance(obj, vm, NULL);
 		if (IS_ERR(vma)) {
@@ -1531,8 +1533,10 @@ static int igt_ppgtt_pin_update(void *arg)
 	}
 
 	obj = i915_gem_object_create_internal(dev_priv, PAGE_SIZE);
-	if (IS_ERR(obj))
-		return PTR_ERR(obj);
+	if (IS_ERR(obj)) {
+		err = PTR_ERR(obj);
+		goto out_vm;
+	}
 
 	vma = i915_vma_instance(obj, vm, NULL);
 	if (IS_ERR(vma)) {</pre><hr><pre>commit 7717cbec172c3554d470023b4020d5781961187e
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Wed Apr 15 16:41:20 2020 +0800

    wimax/i2400m: Fix potential urb refcnt leak
    
    i2400mu_bus_bm_wait_for_ack() invokes usb_get_urb(), which increases the
    refcount of the "notif_urb".
    
    When i2400mu_bus_bm_wait_for_ack() returns, local variable "notif_urb"
    becomes invalid, so the refcount should be decreased to keep refcount
    balanced.
    
    The issue happens in all paths of i2400mu_bus_bm_wait_for_ack(), which
    forget to decrease the refcnt increased by usb_get_urb(), causing a
    refcnt leak.
    
    Fix this issue by calling usb_put_urb() before the
    i2400mu_bus_bm_wait_for_ack() returns.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/wimax/i2400m/usb-fw.c b/drivers/net/wimax/i2400m/usb-fw.c
index 529ebca1e9e1..1f7709d24f35 100644
--- a/drivers/net/wimax/i2400m/usb-fw.c
+++ b/drivers/net/wimax/i2400m/usb-fw.c
@@ -354,6 +354,7 @@ ssize_t i2400mu_bus_bm_wait_for_ack(struct i2400m *i2400m,
 		usb_autopm_put_interface(i2400mu-&gt;usb_iface);
 	d_fnend(8, dev, "(i2400m %p ack %p size %zu) = %ld\n",
 		i2400m, ack, ack_size, (long) result);
+	usb_put_urb(&amp;notif_urb);
 	return result;
 
 error_exceeded:</pre><hr><pre>commit de058420767df21e2b6b0f3bb36d1616fb962032
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Wed Apr 15 16:40:28 2020 +0800

    tipc: Fix potential tipc_node refcnt leak in tipc_rcv
    
    tipc_rcv() invokes tipc_node_find() twice, which returns a reference of
    the specified tipc_node object to "n" with increased refcnt.
    
    When tipc_rcv() returns or a new object is assigned to "n", the original
    local reference of "n" becomes invalid, so the refcount should be
    decreased to keep refcount balanced.
    
    The issue happens in some paths of tipc_rcv(), which forget to decrease
    the refcnt increased by tipc_node_find() and will cause a refcnt leak.
    
    Fix this issue by calling tipc_node_put() before the original object
    pointed by "n" becomes invalid.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/tipc/node.c b/net/tipc/node.c
index 10292c942384..803a3a6d0f50 100644
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@ -2038,6 +2038,7 @@ void tipc_rcv(struct net *net, struct sk_buff *skb, struct tipc_bearer *b)
 		n = tipc_node_find_by_id(net, ehdr-&gt;id);
 	}
 	tipc_crypto_rcv(net, (n) ? n-&gt;crypto_rx : NULL, &amp;skb, b);
+	tipc_node_put(n);
 	if (!skb)
 		return;
 
@@ -2090,7 +2091,7 @@ void tipc_rcv(struct net *net, struct sk_buff *skb, struct tipc_bearer *b)
 	/* Check/update node state before receiving */
 	if (unlikely(skb)) {
 		if (unlikely(skb_linearize(skb)))
-			goto discard;
+			goto out_node_put;
 		tipc_node_write_lock(n);
 		if (tipc_node_check_state(n, skb, bearer_id, &amp;xmitq)) {
 			if (le-&gt;link) {
@@ -2119,6 +2120,7 @@ void tipc_rcv(struct net *net, struct sk_buff *skb, struct tipc_bearer *b)
 	if (!skb_queue_empty(&amp;xmitq))
 		tipc_bearer_xmit(net, bearer_id, &amp;xmitq, &amp;le-&gt;maddr, n);
 
+out_node_put:
 	tipc_node_put(n);
 discard:
 	kfree_skb(skb);</pre><hr><pre>commit 441870ee4240cf67b5d3ab8e16216a9ff42eb5d6
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Wed Apr 15 16:39:56 2020 +0800

    tipc: Fix potential tipc_aead refcnt leak in tipc_crypto_rcv
    
    tipc_crypto_rcv() invokes tipc_aead_get(), which returns a reference of
    the tipc_aead object to "aead" with increased refcnt.
    
    When tipc_crypto_rcv() returns, the original local reference of "aead"
    becomes invalid, so the refcount should be decreased to keep refcount
    balanced.
    
    The issue happens in one error path of tipc_crypto_rcv(). When TIPC
    message decryption status is EINPROGRESS or EBUSY, the function forgets
    to decrease the refcnt increased by tipc_aead_get() and causes a refcnt
    leak.
    
    Fix this issue by calling tipc_aead_put() on the error path when TIPC
    message decryption status is EINPROGRESS or EBUSY.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/tipc/crypto.c b/net/tipc/crypto.c
index c8c47fc72653..8c47ded2edb6 100644
--- a/net/tipc/crypto.c
+++ b/net/tipc/crypto.c
@@ -1712,6 +1712,7 @@ int tipc_crypto_rcv(struct net *net, struct tipc_crypto *rx,
 	case -EBUSY:
 		this_cpu_inc(stats-&gt;stat[STAT_ASYNC]);
 		*skb = NULL;
+		tipc_aead_put(aead);
 		return rc;
 	default:
 		this_cpu_inc(stats-&gt;stat[STAT_NOK]);</pre><hr><pre>commit d03f228470a8c0a22b774d1f8d47071e0de4f6dd
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Wed Apr 15 16:36:19 2020 +0800

    net: netrom: Fix potential nr_neigh refcnt leak in nr_add_node
    
    nr_add_node() invokes nr_neigh_get_dev(), which returns a local
    reference of the nr_neigh object to "nr_neigh" with increased refcnt.
    
    When nr_add_node() returns, "nr_neigh" becomes invalid, so the refcount
    should be decreased to keep refcount balanced.
    
    The issue happens in one normal path of nr_add_node(), which forgets to
    decrease the refcnt increased by nr_neigh_get_dev() and causes a refcnt
    leak. It should decrease the refcnt before the function returns like
    other normal paths do.
    
    Fix this issue by calling nr_neigh_put() before the nr_add_node()
    returns.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/netrom/nr_route.c b/net/netrom/nr_route.c
index 79f12d8c7b86..0891ee02ca4f 100644
--- a/net/netrom/nr_route.c
+++ b/net/netrom/nr_route.c
@@ -208,6 +208,7 @@ static int __must_check nr_add_node(ax25_address *nr, const char *mnemonic,
 		/* refcount initialized at 1 */
 		spin_unlock_bh(&amp;nr_node_list_lock);
 
+		nr_neigh_put(nr_neigh);
 		return 0;
 	}
 	nr_node_lock(nr_node);</pre><hr><pre>commit 04db1580b5e48a79e24aa51ecae0cd4b2296ec23
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Mon Dec 30 10:24:28 2019 +0800

    RDMA/i40iw: fix a potential NULL pointer dereference
    
    A NULL pointer can be returned by in_dev_get(). Thus add a corresponding
    check so that a NULL pointer dereference will be avoided at this place.
    
    Fixes: 8e06af711bf2 ("i40iw: add main, hdr, status")
    Link: https://lore.kernel.org/r/1577672668-46499-1-git-send-email-xiyuyang19@fudan.edu.cn
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@mellanox.com&gt;
    Reviewed-by: Jason Gunthorpe &lt;jgg@mellanox.com&gt;
    Signed-off-by: Jason Gunthorpe &lt;jgg@mellanox.com&gt;

diff --git a/drivers/infiniband/hw/i40iw/i40iw_main.c b/drivers/infiniband/hw/i40iw/i40iw_main.c
index d44cf33df81a..238614370927 100644
--- a/drivers/infiniband/hw/i40iw/i40iw_main.c
+++ b/drivers/infiniband/hw/i40iw/i40iw_main.c
@@ -1225,6 +1225,8 @@ static void i40iw_add_ipv4_addr(struct i40iw_device *iwdev)
 			const struct in_ifaddr *ifa;
 
 			idev = in_dev_get(dev);
+			if (!idev)
+				continue;
 			in_dev_for_each_ifa_rtnl(ifa, idev) {
 				i40iw_debug(&amp;iwdev-&gt;sc_dev, I40IW_DEBUG_CM,
 					    "IP=%pI4, vlan_id=%d, MAC=%pM\n", &amp;ifa-&gt;ifa_address,</pre>
    <div class="pagination">
        <a href='16_6.html'>&lt;&lt;Prev</a><a href='16.html'>1</a><a href='16_2.html'>2</a><a href='16_3.html'>3</a><a href='16_4.html'>4</a><a href='16_5.html'>5</a><a href='16_6.html'>6</a><span>[7]</span>
    <div>
</body>
