<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_5.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><span>[6]</span><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_7.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 309fdb1c33fe726d92d0030481346f24e1b01f07
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Thu Dec 14 21:04:04 2023 +0800

    ethernet: atheros: fix a memleak in atl1e_setup_ring_resources
    
    In the error handling of 'offset &gt; adapter-&gt;ring_size', the
    tx_ring-&gt;tx_buffer allocated by kzalloc should be freed,
    instead of 'goto failed' instantly.
    
    Fixes: a6a5325239c2 ("atl1e: Atheros L1E Gigabit Ethernet driver")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Suman Ghosh &lt;sumang@marvell.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/atheros/atl1e/atl1e_main.c b/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
index 5935be190b9e..5f2a6fcba967 100644
--- a/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
+++ b/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
@@ -866,10 +866,13 @@ static int atl1e_setup_ring_resources(struct atl1e_adapter *adapter)
 		netdev_err(adapter-&gt;netdev, "offset(%d) &gt; ring size(%d) !!\n",
 			   offset, adapter-&gt;ring_size);
 		err = -1;
-		goto failed;
+		goto free_buffer;
 	}
 
 	return 0;
+free_buffer:
+	kfree(tx_ring-&gt;tx_buffer);
+	tx_ring-&gt;tx_buffer = NULL;
 failed:
 	if (adapter-&gt;ring_vir_addr != NULL) {
 		dma_free_coherent(&amp;pdev-&gt;dev, adapter-&gt;ring_size,</pre><hr><pre>commit a6582701178a47c4d0cb2188c965c59c0c0647c8
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Fri Dec 15 00:59:38 2023 +0800

    drm/amd/pm: fix a double-free in amdgpu_parse_extended_power_table
    
    The amdgpu_free_extended_power_table is called in every error-handling
    paths of amdgpu_parse_extended_power_table. However, after the following
    call chain of returning:
    
    amdgpu_parse_extended_power_table
      |-&gt; kv_dpm_init / si_dpm_init
          (the only two caller of amdgpu_parse_extended_power_table)
            |-&gt; kv_dpm_sw_init / si_dpm_sw_init
                (the only caller of kv_dpm_init / si_dpm_init, accordingly)
                  |-&gt; kv_dpm_fini / si_dpm_fini
                      (goto dpm_failed in xx_dpm_sw_init)
                        |-&gt; amdgpu_free_extended_power_table
    
    As above, the amdgpu_free_extended_power_table is called twice in this
    returning chain and thus a double-free is triggered. Similarily, the
    last kfree in amdgpu_parse_extended_power_table also cause a double free
    with amdgpu_free_extended_power_table in kv_dpm_fini.
    
    Fixes: 84176663e70d ("drm/amd/pm: create a new holder for those APIs used only by legacy ASICs(si/kv)")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/pm/legacy-dpm/legacy_dpm.c b/drivers/gpu/drm/amd/pm/legacy-dpm/legacy_dpm.c
index 81fb4e5dd804..60377747bab4 100644
--- a/drivers/gpu/drm/amd/pm/legacy-dpm/legacy_dpm.c
+++ b/drivers/gpu/drm/amd/pm/legacy-dpm/legacy_dpm.c
@@ -272,10 +272,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				 le16_to_cpu(power_info-&gt;pplib4.usVddcDependencyOnSCLKOffset));
 			ret = amdgpu_parse_clk_voltage_dep_table(&amp;adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_sclk,
 								 dep_table);
-			if (ret) {
-				amdgpu_free_extended_power_table(adev);
+			if (ret)
 				return ret;
-			}
 		}
 		if (power_info-&gt;pplib4.usVddciDependencyOnMCLKOffset) {
 			dep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)
@@ -283,10 +281,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				 le16_to_cpu(power_info-&gt;pplib4.usVddciDependencyOnMCLKOffset));
 			ret = amdgpu_parse_clk_voltage_dep_table(&amp;adev-&gt;pm.dpm.dyn_state.vddci_dependency_on_mclk,
 								 dep_table);
-			if (ret) {
-				amdgpu_free_extended_power_table(adev);
+			if (ret)
 				return ret;
-			}
 		}
 		if (power_info-&gt;pplib4.usVddcDependencyOnMCLKOffset) {
 			dep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)
@@ -294,10 +290,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				 le16_to_cpu(power_info-&gt;pplib4.usVddcDependencyOnMCLKOffset));
 			ret = amdgpu_parse_clk_voltage_dep_table(&amp;adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_mclk,
 								 dep_table);
-			if (ret) {
-				amdgpu_free_extended_power_table(adev);
+			if (ret)
 				return ret;
-			}
 		}
 		if (power_info-&gt;pplib4.usMvddDependencyOnMCLKOffset) {
 			dep_table = (ATOM_PPLIB_Clock_Voltage_Dependency_Table *)
@@ -305,10 +299,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				 le16_to_cpu(power_info-&gt;pplib4.usMvddDependencyOnMCLKOffset));
 			ret = amdgpu_parse_clk_voltage_dep_table(&amp;adev-&gt;pm.dpm.dyn_state.mvdd_dependency_on_mclk,
 								 dep_table);
-			if (ret) {
-				amdgpu_free_extended_power_table(adev);
+			if (ret)
 				return ret;
-			}
 		}
 		if (power_info-&gt;pplib4.usMaxClockVoltageOnDCOffset) {
 			ATOM_PPLIB_Clock_Voltage_Limit_Table *clk_v =
@@ -339,10 +331,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				kcalloc(psl-&gt;ucNumEntries,
 					sizeof(struct amdgpu_phase_shedding_limits_entry),
 					GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.phase_shedding_limits_table.entries) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.phase_shedding_limits_table.entries)
 				return -ENOMEM;
-			}
 
 			entry = &amp;psl-&gt;entries[0];
 			for (i = 0; i &lt; psl-&gt;ucNumEntries; i++) {
@@ -383,10 +373,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 			ATOM_PPLIB_CAC_Leakage_Record *entry;
 			u32 size = cac_table-&gt;ucNumEntries * sizeof(struct amdgpu_cac_leakage_table);
 			adev-&gt;pm.dpm.dyn_state.cac_leakage_table.entries = kzalloc(size, GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.cac_leakage_table.entries) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.cac_leakage_table.entries)
 				return -ENOMEM;
-			}
 			entry = &amp;cac_table-&gt;entries[0];
 			for (i = 0; i &lt; cac_table-&gt;ucNumEntries; i++) {
 				if (adev-&gt;pm.dpm.platform_caps &amp; ATOM_PP_PLATFORM_CAP_EVV) {
@@ -438,10 +426,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				sizeof(struct amdgpu_vce_clock_voltage_dependency_entry);
 			adev-&gt;pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries =
 				kzalloc(size, GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.vce_clock_voltage_dependency_table.entries)
 				return -ENOMEM;
-			}
 			adev-&gt;pm.dpm.dyn_state.vce_clock_voltage_dependency_table.count =
 				limits-&gt;numEntries;
 			entry = &amp;limits-&gt;entries[0];
@@ -493,10 +479,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				sizeof(struct amdgpu_uvd_clock_voltage_dependency_entry);
 			adev-&gt;pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries =
 				kzalloc(size, GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.entries)
 				return -ENOMEM;
-			}
 			adev-&gt;pm.dpm.dyn_state.uvd_clock_voltage_dependency_table.count =
 				limits-&gt;numEntries;
 			entry = &amp;limits-&gt;entries[0];
@@ -525,10 +509,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				sizeof(struct amdgpu_clock_voltage_dependency_entry);
 			adev-&gt;pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries =
 				kzalloc(size, GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.samu_clock_voltage_dependency_table.entries)
 				return -ENOMEM;
-			}
 			adev-&gt;pm.dpm.dyn_state.samu_clock_voltage_dependency_table.count =
 				limits-&gt;numEntries;
 			entry = &amp;limits-&gt;entries[0];
@@ -548,10 +530,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				 le16_to_cpu(ext_hdr-&gt;usPPMTableOffset));
 			adev-&gt;pm.dpm.dyn_state.ppm_table =
 				kzalloc(sizeof(struct amdgpu_ppm_table), GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.ppm_table) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.ppm_table)
 				return -ENOMEM;
-			}
 			adev-&gt;pm.dpm.dyn_state.ppm_table-&gt;ppm_design = ppm-&gt;ucPpmDesign;
 			adev-&gt;pm.dpm.dyn_state.ppm_table-&gt;cpu_core_number =
 				le16_to_cpu(ppm-&gt;usCpuCoreNumber);
@@ -583,10 +563,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 				sizeof(struct amdgpu_clock_voltage_dependency_entry);
 			adev-&gt;pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries =
 				kzalloc(size, GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.acp_clock_voltage_dependency_table.entries)
 				return -ENOMEM;
-			}
 			adev-&gt;pm.dpm.dyn_state.acp_clock_voltage_dependency_table.count =
 				limits-&gt;numEntries;
 			entry = &amp;limits-&gt;entries[0];
@@ -606,10 +584,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 			ATOM_PowerTune_Table *pt;
 			adev-&gt;pm.dpm.dyn_state.cac_tdp_table =
 				kzalloc(sizeof(struct amdgpu_cac_tdp_table), GFP_KERNEL);
-			if (!adev-&gt;pm.dpm.dyn_state.cac_tdp_table) {
-				amdgpu_free_extended_power_table(adev);
+			if (!adev-&gt;pm.dpm.dyn_state.cac_tdp_table)
 				return -ENOMEM;
-			}
 			if (rev &gt; 0) {
 				ATOM_PPLIB_POWERTUNE_Table_V1 *ppt = (ATOM_PPLIB_POWERTUNE_Table_V1 *)
 					(mode_info-&gt;atom_context-&gt;bios + data_offset +
@@ -645,10 +621,8 @@ int amdgpu_parse_extended_power_table(struct amdgpu_device *adev)
 			ret = amdgpu_parse_clk_voltage_dep_table(
 					&amp;adev-&gt;pm.dpm.dyn_state.vddgfx_dependency_on_sclk,
 					dep_table);
-			if (ret) {
-				kfree(adev-&gt;pm.dpm.dyn_state.vddgfx_dependency_on_sclk.entries);
+			if (ret)
 				return ret;
-			}
 		}
 	}
 </pre><hr><pre>commit c2709b2d6a537ca0fa0f1da36fdaf07e48ef447d
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Fri Dec 15 00:58:42 2023 +0800

    gpu/drm/radeon: fix two memleaks in radeon_vm_init
    
    When radeon_bo_create and radeon_vm_clear_bo fail, the vm-&gt;page_tables
    allocated before need to be freed. However, neither radeon_vm_init
    itself nor its caller have done such deallocation.
    
    Fixes: 6d2f2944e95e ("drm/radeon: use normal BOs for the page tables v4")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/radeon/radeon_vm.c b/drivers/gpu/drm/radeon/radeon_vm.c
index 987cabbf1318..c38b4d5d6a14 100644
--- a/drivers/gpu/drm/radeon/radeon_vm.c
+++ b/drivers/gpu/drm/radeon/radeon_vm.c
@@ -1204,13 +1204,17 @@ int radeon_vm_init(struct radeon_device *rdev, struct radeon_vm *vm)
 	r = radeon_bo_create(rdev, pd_size, align, true,
 			     RADEON_GEM_DOMAIN_VRAM, 0, NULL,
 			     NULL, &amp;vm-&gt;page_directory);
-	if (r)
+	if (r) {
+		kfree(vm-&gt;page_tables);
+		vm-&gt;page_tables = NULL;
 		return r;
-
+	}
 	r = radeon_vm_clear_bo(rdev, vm-&gt;page_directory);
 	if (r) {
 		radeon_bo_unref(&amp;vm-&gt;page_directory);
 		vm-&gt;page_directory = NULL;
+		kfree(vm-&gt;page_tables);
+		vm-&gt;page_tables = NULL;
 		return r;
 	}
 </pre><hr><pre>commit 28dd788382c43b330480f57cd34cde0840896743
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Fri Dec 15 00:24:58 2023 +0800

    drivers/amd/pm: fix a use-after-free in kv_parse_power_table
    
    When ps allocated by kzalloc equals to NULL, kv_parse_power_table
    frees adev-&gt;pm.dpm.ps that allocated before. However, after the control
    flow goes through the following call chains:
    
    kv_parse_power_table
      |-&gt; kv_dpm_init
            |-&gt; kv_dpm_sw_init
                  |-&gt; kv_dpm_fini
    
    The adev-&gt;pm.dpm.ps is used in the for loop of kv_dpm_fini after its
    first free in kv_parse_power_table and causes a use-after-free bug.
    
    Fixes: a2e73f56fa62 ("drm/amdgpu: Add support for CIK parts")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c b/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
index 5d28c951a319..5cb4725c773f 100644
--- a/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
+++ b/drivers/gpu/drm/amd/pm/legacy-dpm/kv_dpm.c
@@ -2735,10 +2735,8 @@ static int kv_parse_power_table(struct amdgpu_device *adev)
 		non_clock_info = (struct _ATOM_PPLIB_NONCLOCK_INFO *)
 			&amp;non_clock_info_array-&gt;nonClockInfo[non_clock_array_index];
 		ps = kzalloc(sizeof(struct kv_ps), GFP_KERNEL);
-		if (ps == NULL) {
-			kfree(adev-&gt;pm.dpm.ps);
+		if (ps == NULL)
 			return -ENOMEM;
-		}
 		adev-&gt;pm.dpm.ps[i].ps_priv = ps;
 		k = 0;
 		idx = (u8 *)&amp;power_state-&gt;v2.clockInfoIndex[0];</pre><hr><pre>commit ac16667237a82e2597e329eb9bc520d1cf9dff30
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Thu Dec 14 23:24:11 2023 +0800

    drm/amd/pm: fix a double-free in si_dpm_init
    
    When the allocation of
    adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries fails,
    amdgpu_free_extended_power_table is called to free some fields of adev.
    However, when the control flow returns to si_dpm_sw_init, it goes to
    label dpm_failed and calls si_dpm_fini, which calls
    amdgpu_free_extended_power_table again and free those fields again. Thus
    a double-free is triggered.
    
    Fixes: 841686df9f7d ("drm/amdgpu: add SI DPM support (v4)")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c b/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
index fc8e4ac6c8e7..df4f20293c16 100644
--- a/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
+++ b/drivers/gpu/drm/amd/pm/legacy-dpm/si_dpm.c
@@ -7379,10 +7379,9 @@ static int si_dpm_init(struct amdgpu_device *adev)
 		kcalloc(4,
 			sizeof(struct amdgpu_clock_voltage_dependency_entry),
 			GFP_KERNEL);
-	if (!adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries) {
-		amdgpu_free_extended_power_table(adev);
+	if (!adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries)
 		return -ENOMEM;
-	}
+
 	adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_dispclk.count = 4;
 	adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].clk = 0;
 	adev-&gt;pm.dpm.dyn_state.vddc_dependency_on_dispclk.entries[0].v = 0;</pre><hr><pre>commit 2b8aa4c3e6a5d41b10b53da2017852f647d0345b
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Thu Dec 14 15:29:43 2023 +0800

    mtd: rawnand: diskonchip: fix a potential double free in doc_probe
    
    When nand_scan() fails, it has cleaned up related resources
    in its error paths. Therefore, the following nand_cleanup()
    may lead to a double-free. One possible trace is:
    
    doc_probe
      |-&gt; nand_scan
      |     |-&gt; nand_scan_with_ids
      |           |-&gt; nand_scan_tail
      |                 |-&gt; kfree(chip-&gt;data_buf) [First free]
      |
      |-&gt; nand_cleanup
            |-&gt; kfree(chip-&gt;data_buf) [Double free here]
    
    Fix this by removing nand_cleanup() on failure of
    nand_scan().
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Miquel Raynal &lt;miquel.raynal@bootlin.com&gt;
    Link: https://lore.kernel.org/linux-mtd/20231214072946.10285-1-dinghao.liu@zju.edu.cn

diff --git a/drivers/mtd/nand/raw/diskonchip.c b/drivers/mtd/nand/raw/diskonchip.c
index 5d2ddb037a9a..5243fab9face 100644
--- a/drivers/mtd/nand/raw/diskonchip.c
+++ b/drivers/mtd/nand/raw/diskonchip.c
@@ -1491,10 +1491,12 @@ static int __init doc_probe(unsigned long physadr)
 	else
 		numchips = doc2001_init(mtd);
 
-	if ((ret = nand_scan(nand, numchips)) || (ret = doc-&gt;late_init(mtd))) {
-		/* DBB note: i believe nand_cleanup is necessary here, as
-		   buffers may have been allocated in nand_base.  Check with
-		   Thomas. FIX ME! */
+	ret = nand_scan(nand, numchips);
+	if (ret)
+		goto fail;
+
+	ret = doc-&gt;late_init(mtd);
+	if (ret) {
 		nand_cleanup(nand);
 		goto fail;
 	}</pre><hr><pre>commit e75efc6466ae289e599fb12a5a86545dff245c65
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Tue Nov 28 17:40:53 2023 +0800

    net/mlx5e: fix a potential double-free in fs_udp_create_groups
    
    When kcalloc() for ft-&gt;g succeeds but kvzalloc() for in fails,
    fs_udp_create_groups() will free ft-&gt;g. However, its caller
    fs_udp_create_table() will free ft-&gt;g again through calling
    mlx5e_destroy_flow_table(), which will lead to a double-free.
    Fix this by setting ft-&gt;g to NULL in fs_udp_create_groups().
    
    Fixes: 1c80bd684388 ("net/mlx5e: Introduce Flow Steering UDP API")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Tariq Toukan &lt;tariqt@nvidia.com&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Signed-off-by: Saeed Mahameed &lt;saeedm@nvidia.com&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index be83ad9db82a..e1283531e0b8 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@ -154,6 +154,7 @@ static int fs_udp_create_groups(struct mlx5e_flow_table *ft, enum fs_udp_type ty
 	in = kvzalloc(inlen, GFP_KERNEL);
 	if  (!in || !ft-&gt;g) {
 		kfree(ft-&gt;g);
+		ft-&gt;g = NULL;
 		kvfree(in);
 		return -ENOMEM;
 	}</pre><hr><pre>commit b65d52ac9c085c0c52dee012a210d4e2f352611b
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sun Dec 10 12:52:55 2023 +0800

    qed: Fix a potential use-after-free in qed_cxt_tables_alloc
    
    qed_ilt_shadow_alloc() will call qed_ilt_shadow_free() to
    free p_hwfn-&gt;p_cxt_mngr-&gt;ilt_shadow on error. However,
    qed_cxt_tables_alloc() accesses the freed pointer on failure
    of qed_ilt_shadow_alloc() through calling qed_cxt_mngr_free(),
    which may lead to use-after-free. Fix this issue by setting
    p_mngr-&gt;ilt_shadow to NULL in qed_ilt_shadow_free().
    
    Fixes: fe56b9e6a8d9 ("qed: Add module with basic common support")
    Reviewed-by: Przemek Kitszel &lt;przemyslaw.kitszel@intel.com&gt;
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20231210045255.21383-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/qlogic/qed/qed_cxt.c b/drivers/net/ethernet/qlogic/qed/qed_cxt.c
index 65e20693c549..33f4f58ee51c 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_cxt.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_cxt.c
@@ -933,6 +933,7 @@ static void qed_ilt_shadow_free(struct qed_hwfn *p_hwfn)
 		p_dma-&gt;virt_addr = NULL;
 	}
 	kfree(p_mngr-&gt;ilt_shadow);
+	p_mngr-&gt;ilt_shadow = NULL;
 }
 
 static int qed_ilt_blk_alloc(struct qed_hwfn *p_hwfn,</pre><hr><pre>commit 28a7cb045ab700de5554193a1642917602787784
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Thu Dec 7 17:49:16 2023 +0800

    octeontx2-af: fix a use-after-free in rvu_nix_register_reporters
    
    The rvu_dl will be freed in rvu_nix_health_reporters_destroy(rvu_dl)
    after the create_workqueue fails, and after that free, the rvu_dl will
    be translate back through the following call chain:
    
    rvu_nix_health_reporters_destroy
      |-&gt; rvu_nix_health_reporters_create
           |-&gt; rvu_health_reporters_create
                 |-&gt; rvu_register_dl (label err_dl_health)
    
    Finally. in the err_dl_health label, rvu_dl being freed again in
    rvu_health_reporters_destroy(rvu) by rvu_nix_health_reporters_destroy.
    In the second calls of rvu_nix_health_reporters_destroy, however,
    it uses rvu_dl-&gt;rvu_nix_health_reporter, which is already freed at
    the end of rvu_nix_health_reporters_destroy in the first call.
    
    So this patch prevents the first destroy by instantly returning -ENONMEN
    when create_workqueue fails. In addition, since the failure of
    create_workqueue is the only entrence of label err, it has been
    integrated into the error-handling path of create_workqueue.
    
    Fixes: 5ed66306eab6 ("octeontx2-af: Add devlink health reporters for NIX")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/marvell/octeontx2/af/rvu_devlink.c b/drivers/net/ethernet/marvell/octeontx2/af/rvu_devlink.c
index 62780d8b4f9a..21b5d71c1e37 100644
--- a/drivers/net/ethernet/marvell/octeontx2/af/rvu_devlink.c
+++ b/drivers/net/ethernet/marvell/octeontx2/af/rvu_devlink.c
@@ -538,7 +538,7 @@ static int rvu_nix_register_reporters(struct rvu_devlink *rvu_dl)
 
 	rvu_dl-&gt;devlink_wq = create_workqueue("rvu_devlink_wq");
 	if (!rvu_dl-&gt;devlink_wq)
-		goto err;
+		return -ENOMEM;
 
 	INIT_WORK(&amp;rvu_reporters-&gt;intr_work, rvu_nix_intr_work);
 	INIT_WORK(&amp;rvu_reporters-&gt;gen_work, rvu_nix_gen_work);
@@ -546,9 +546,6 @@ static int rvu_nix_register_reporters(struct rvu_devlink *rvu_dl)
 	INIT_WORK(&amp;rvu_reporters-&gt;ras_work, rvu_nix_ras_work);
 
 	return 0;
-err:
-	rvu_nix_health_reporters_destroy(rvu_dl);
-	return -ENOMEM;
 }
 
 static int rvu_nix_health_reporters_create(struct rvu_devlink *rvu_dl)</pre><hr><pre>commit a1c95dd5bc1d6a5d7a75a376c2107421b7d6240d
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Nov 27 11:47:10 2023 +0800

    crypto: ccp - fix memleak in ccp_init_dm_workarea
    
    When dma_map_single() fails, wa-&gt;address is supposed to be freed
    by the callers of ccp_init_dm_workarea() through ccp_dm_free().
    However, many of the call spots don't expect to have to call
    ccp_dm_free() on failure of ccp_init_dm_workarea(), which may
    lead to a memleak. Let's free wa-&gt;address in ccp_init_dm_workarea()
    when dma_map_single() fails.
    
    Fixes: 63b945091a07 ("crypto: ccp - CCP device driver and interface support")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Acked-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
    Signed-off-by: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;

diff --git a/drivers/crypto/ccp/ccp-ops.c b/drivers/crypto/ccp/ccp-ops.c
index aa4e1a500691..cb8e99936abb 100644
--- a/drivers/crypto/ccp/ccp-ops.c
+++ b/drivers/crypto/ccp/ccp-ops.c
@@ -179,8 +179,11 @@ static int ccp_init_dm_workarea(struct ccp_dm_workarea *wa,
 
 		wa-&gt;dma.address = dma_map_single(wa-&gt;dev, wa-&gt;address, len,
 						 dir);
-		if (dma_mapping_error(wa-&gt;dev, wa-&gt;dma.address))
+		if (dma_mapping_error(wa-&gt;dev, wa-&gt;dma.address)) {
+			kfree(wa-&gt;address);
+			wa-&gt;address = NULL;
 			return -ENOMEM;
+		}
 
 		wa-&gt;dma.length = len;
 	}</pre>
    <div class="pagination">
        <a href='6_5.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><span>[6]</span><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_7.html'>Next&gt;&gt;</a>
    <div>
</body>
