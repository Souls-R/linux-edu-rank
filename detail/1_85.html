<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_84.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><span>[85]</span><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_86.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit cc3e1bea5d87635c519da657303690f5538bb4eb
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 23 06:52:08 2009 -0500

    ext4, jbd2: Add barriers for file systems with exernal journals
    
    This is a bit complicated because we are trying to optimize when we
    send barriers to the fs data disk.  We could just throw in an extra
    barrier to the data disk whenever we send a barrier to the journal
    disk, but that's not always strictly necessary.
    
    We only need to send a barrier during a commit when there are data
    blocks which are must be written out due to an inode written in
    ordered mode, or if fsync() depends on the commit to force data blocks
    to disk.  Finally, before we drop transactions from the beginning of
    the journal during a checkpoint operation, we need to guarantee that
    any blocks that were flushed out to the data disk are firmly on the
    rust platter before we drop the transaction from the journal.
    
    Thanks to Oleg Drokin for pointing out this flaw in ext3/ext4.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index 0b22497d92e1..98bd140aad01 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -88,9 +88,21 @@ int ext4_sync_file(struct file *file, struct dentry *dentry, int datasync)
 		return ext4_force_commit(inode-&gt;i_sb);
 
 	commit_tid = datasync ? ei-&gt;i_datasync_tid : ei-&gt;i_sync_tid;
-	if (jbd2_log_start_commit(journal, commit_tid))
+	if (jbd2_log_start_commit(journal, commit_tid)) {
+		/*
+		 * When the journal is on a different device than the
+		 * fs data disk, we need to issue the barrier in
+		 * writeback mode.  (In ordered mode, the jbd2 layer
+		 * will take care of issuing the barrier.  In
+		 * data=journal, all of the data blocks are written to
+		 * the journal device.)
+		 */
+		if (ext4_should_writeback_data(inode) &amp;&amp;
+		    (journal-&gt;j_fs_dev != journal-&gt;j_dev) &amp;&amp;
+		    (journal-&gt;j_flags &amp; JBD2_BARRIER))
+			blkdev_issue_flush(inode-&gt;i_sb-&gt;s_bdev, NULL);
 		jbd2_log_wait_commit(journal, commit_tid);
-	else if (journal-&gt;j_flags &amp; JBD2_BARRIER)
+	} else if (journal-&gt;j_flags &amp; JBD2_BARRIER)
 		blkdev_issue_flush(inode-&gt;i_sb-&gt;s_bdev, NULL);
 	return ret;
 }
diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c
index ca0f5eb62b20..886849370950 100644
--- a/fs/jbd2/checkpoint.c
+++ b/fs/jbd2/checkpoint.c
@@ -22,6 +22,7 @@
 #include &lt;linux/jbd2.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/slab.h&gt;
+#include &lt;linux/blkdev.h&gt;
 #include &lt;trace/events/jbd2.h&gt;
 
 /*
@@ -515,6 +516,20 @@ int jbd2_cleanup_journal_tail(journal_t *journal)
 	journal-&gt;j_tail_sequence = first_tid;
 	journal-&gt;j_tail = blocknr;
 	spin_unlock(&amp;journal-&gt;j_state_lock);
+
+	/*
+	 * If there is an external journal, we need to make sure that
+	 * any data blocks that were recently written out --- perhaps
+	 * by jbd2_log_do_checkpoint() --- are flushed out before we
+	 * drop the transactions from the external journal.  It's
+	 * unlikely this will be necessary, especially with a
+	 * appropriately sized journal, but we need this to guarantee
+	 * correctness.  Fortunately jbd2_cleanup_journal_tail()
+	 * doesn't get called all that often.
+	 */
+	if ((journal-&gt;j_fs_dev != journal-&gt;j_dev) &amp;&amp;
+	    (journal-&gt;j_flags &amp; JBD2_BARRIER))
+		blkdev_issue_flush(journal-&gt;j_fs_dev, NULL);
 	if (!(journal-&gt;j_flags &amp; JBD2_ABORT))
 		jbd2_journal_update_superblock(journal, 1);
 	return 0;
diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c
index 6a10238d2c63..1bc74b6f26d2 100644
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@ -259,6 +259,7 @@ static int journal_submit_data_buffers(journal_t *journal,
 			ret = err;
 		spin_lock(&amp;journal-&gt;j_list_lock);
 		J_ASSERT(jinode-&gt;i_transaction == commit_transaction);
+		commit_transaction-&gt;t_flushed_data_blocks = 1;
 		jinode-&gt;i_flags &amp;= ~JI_COMMIT_RUNNING;
 		wake_up_bit(&amp;jinode-&gt;i_flags, __JI_COMMIT_RUNNING);
 	}
@@ -708,8 +709,17 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 		}
 	}
 
-	/* Done it all: now write the commit record asynchronously. */
+	/* 
+	 * If the journal is not located on the file system device,
+	 * then we must flush the file system device before we issue
+	 * the commit record
+	 */
+	if (commit_transaction-&gt;t_flushed_data_blocks &amp;&amp;
+	    (journal-&gt;j_fs_dev != journal-&gt;j_dev) &amp;&amp;
+	    (journal-&gt;j_flags &amp; JBD2_BARRIER))
+		blkdev_issue_flush(journal-&gt;j_fs_dev, NULL);
 
+	/* Done it all: now write the commit record asynchronously. */
 	if (JBD2_HAS_INCOMPAT_FEATURE(journal,
 				      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {
 		err = journal_submit_commit_record(journal, commit_transaction,
@@ -720,13 +730,6 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 			blkdev_issue_flush(journal-&gt;j_dev, NULL);
 	}
 
-	/*
-	 * This is the right place to wait for data buffers both for ASYNC
-	 * and !ASYNC commit. If commit is ASYNC, we need to wait only after
-	 * the commit block went to disk (which happens above). If commit is
-	 * SYNC, we need to wait for data buffers before we start writing
-	 * commit block, which happens below in such setting.
-	 */
 	err = journal_finish_inode_data_buffers(journal, commit_transaction);
 	if (err) {
 		printk(KERN_WARNING
diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h
index f1011f7f3d41..638ce4554c76 100644
--- a/include/linux/jbd2.h
+++ b/include/linux/jbd2.h
@@ -653,6 +653,7 @@ struct transaction_s
 	 * waiting for it to finish.
 	 */
 	unsigned int t_synchronous_commit:1;
+	unsigned int t_flushed_data_blocks:1;
 
 	/*
 	 * For use by the filesystem to store fs-specific data</pre><hr><pre>commit 7bf0dc9b0ca9e9b6524b1f70e0898c7f11eb10be
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Dec 15 16:46:48 2009 -0800

    ext2: avoid WARN() messages when failing to write to the superblock
    
    This fixes a common warning reported by kerneloops.org
    
    [Kernel summit hacking hour]
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index 1388802b7803..f9cb54a585ce 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -1105,9 +1105,30 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 	return ret;
 }
 
+static void ext2_clear_super_error(struct super_block *sb)
+{
+	struct buffer_head *sbh = EXT2_SB(sb)-&gt;s_sbh;
+
+	if (buffer_write_io_error(sbh)) {
+		/*
+		 * Oh, dear.  A previous attempt to write the
+		 * superblock failed.  This could happen because the
+		 * USB device was yanked out.  Or it could happen to
+		 * be a transient write error and maybe the block will
+		 * be remapped.  Nothing we can do but to retry the
+		 * write and hope for the best.
+		 */
+		printk(KERN_ERR "EXT2-fs: %s previous I/O error to "
+		       "superblock detected", sb-&gt;s_id);
+		clear_buffer_write_io_error(sbh);
+		set_buffer_uptodate(sbh);
+	}
+}
+
 static void ext2_commit_super (struct super_block * sb,
 			       struct ext2_super_block * es)
 {
+	ext2_clear_super_error(sb);
 	es-&gt;s_wtime = cpu_to_le32(get_seconds());
 	mark_buffer_dirty(EXT2_SB(sb)-&gt;s_sbh);
 	sb-&gt;s_dirt = 0;
@@ -1115,6 +1136,7 @@ static void ext2_commit_super (struct super_block * sb,
 
 static void ext2_sync_super(struct super_block *sb, struct ext2_super_block *es)
 {
+	ext2_clear_super_error(sb);
 	es-&gt;s_free_blocks_count = cpu_to_le32(ext2_count_free_blocks(sb));
 	es-&gt;s_free_inodes_count = cpu_to_le32(ext2_count_free_inodes(sb));
 	es-&gt;s_wtime = cpu_to_le32(get_seconds());</pre><hr><pre>commit 51b7e3c9fbe7d22d4e355101e9a73b44fc5c9feb
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Dec 21 10:56:09 2009 -0500

    ext4: add module aliases for ext2 and ext3
    
    Add module aliases for ext2 and ext3 when CONFIG_EXT4_USE_FOR_EXT23 is
    set.  This makes the existing user-space stuff like mkinitrd working
    as is.
    
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 6ed9aa91f27d..0a06fe6f2bc2 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4005,6 +4005,7 @@ static inline void unregister_as_ext2(void)
 {
 	unregister_filesystem(&amp;ext2_fs_type);
 }
+MODULE_ALIAS("ext2");
 #else
 static inline void register_as_ext2(void) { }
 static inline void unregister_as_ext2(void) { }
@@ -4031,6 +4032,7 @@ static inline void unregister_as_ext3(void)
 {
 	unregister_filesystem(&amp;ext3_fs_type);
 }
+MODULE_ALIAS("ext3");
 #else
 static inline void register_as_ext3(void) { }
 static inline void unregister_as_ext3(void) { }</pre><hr><pre>commit fab3a549e204172236779f502eccb4f9bf0dc87d
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 9 21:30:02 2009 -0500

    ext4: Fix potential fiemap deadlock (mmap_sem vs. i_data_sem)
    
    Fix the following potential circular locking dependency between
    mm-&gt;mmap_sem and ei-&gt;i_data_sem:
    
        =======================================================
        [ INFO: possible circular locking dependency detected ]
        2.6.32-04115-gec044c5 #37
        -------------------------------------------------------
        ureadahead/1855 is trying to acquire lock:
         (&amp;mm-&gt;mmap_sem){++++++}, at: [&lt;ffffffff81107224&gt;] might_fault+0x5c/0xac
    
        but task is already holding lock:
         (&amp;ei-&gt;i_data_sem){++++..}, at: [&lt;ffffffff811be1fd&gt;] ext4_fiemap+0x11b/0x159
    
        which lock already depends on the new lock.
    
        the existing dependency chain (in reverse order) is:
    
        -&gt; #1 (&amp;ei-&gt;i_data_sem){++++..}:
               [&lt;ffffffff81099bfa&gt;] __lock_acquire+0xb67/0xd0f
               [&lt;ffffffff81099e7e&gt;] lock_acquire+0xdc/0x102
               [&lt;ffffffff81516633&gt;] down_read+0x51/0x84
               [&lt;ffffffff811a2414&gt;] ext4_get_blocks+0x50/0x2a5
               [&lt;ffffffff811a3453&gt;] ext4_get_block+0xab/0xef
               [&lt;ffffffff81154f39&gt;] do_mpage_readpage+0x198/0x48d
               [&lt;ffffffff81155360&gt;] mpage_readpages+0xd0/0x114
               [&lt;ffffffff811a104b&gt;] ext4_readpages+0x1d/0x1f
               [&lt;ffffffff810f8644&gt;] __do_page_cache_readahead+0x12f/0x1bc
               [&lt;ffffffff810f86f2&gt;] ra_submit+0x21/0x25
               [&lt;ffffffff810f0cfd&gt;] filemap_fault+0x19f/0x32c
               [&lt;ffffffff81107b97&gt;] __do_fault+0x55/0x3a2
               [&lt;ffffffff81109db0&gt;] handle_mm_fault+0x327/0x734
               [&lt;ffffffff8151aaa9&gt;] do_page_fault+0x292/0x2aa
               [&lt;ffffffff81518205&gt;] page_fault+0x25/0x30
               [&lt;ffffffff812a34d8&gt;] clear_user+0x38/0x3c
               [&lt;ffffffff81167e16&gt;] padzero+0x20/0x31
               [&lt;ffffffff81168b47&gt;] load_elf_binary+0x8bc/0x17ed
               [&lt;ffffffff81130e95&gt;] search_binary_handler+0xc2/0x259
               [&lt;ffffffff81166d64&gt;] load_script+0x1b8/0x1cc
               [&lt;ffffffff81130e95&gt;] search_binary_handler+0xc2/0x259
               [&lt;ffffffff8113255f&gt;] do_execve+0x1ce/0x2cf
               [&lt;ffffffff81027494&gt;] sys_execve+0x43/0x5a
               [&lt;ffffffff8102918a&gt;] stub_execve+0x6a/0xc0
    
        -&gt; #0 (&amp;mm-&gt;mmap_sem){++++++}:
               [&lt;ffffffff81099aa4&gt;] __lock_acquire+0xa11/0xd0f
               [&lt;ffffffff81099e7e&gt;] lock_acquire+0xdc/0x102
               [&lt;ffffffff81107251&gt;] might_fault+0x89/0xac
               [&lt;ffffffff81139382&gt;] fiemap_fill_next_extent+0x95/0xda
               [&lt;ffffffff811bcb43&gt;] ext4_ext_fiemap_cb+0x138/0x157
               [&lt;ffffffff811be069&gt;] ext4_ext_walk_space+0x178/0x1f1
               [&lt;ffffffff811be21e&gt;] ext4_fiemap+0x13c/0x159
               [&lt;ffffffff811390e6&gt;] do_vfs_ioctl+0x348/0x4d6
               [&lt;ffffffff811392ca&gt;] sys_ioctl+0x56/0x79
               [&lt;ffffffff81028cb2&gt;] system_call_fastpath+0x16/0x1b
    
        other info that might help us debug this:
    
        1 lock held by ureadahead/1855:
         #0:  (&amp;ei-&gt;i_data_sem){++++..}, at: [&lt;ffffffff811be1fd&gt;] ext4_fiemap+0x11b/0x159
    
        stack backtrace:
        Pid: 1855, comm: ureadahead Not tainted 2.6.32-04115-gec044c5 #37
        Call Trace:
         [&lt;ffffffff81098c70&gt;] print_circular_bug+0xa8/0xb7
         [&lt;ffffffff81099aa4&gt;] __lock_acquire+0xa11/0xd0f
         [&lt;ffffffff8102f229&gt;] ? sched_clock+0x9/0xd
         [&lt;ffffffff81099e7e&gt;] lock_acquire+0xdc/0x102
         [&lt;ffffffff81107224&gt;] ? might_fault+0x5c/0xac
         [&lt;ffffffff81107251&gt;] might_fault+0x89/0xac
         [&lt;ffffffff81107224&gt;] ? might_fault+0x5c/0xac
         [&lt;ffffffff81124b44&gt;] ? __kmalloc+0x13b/0x18c
         [&lt;ffffffff81139382&gt;] fiemap_fill_next_extent+0x95/0xda
         [&lt;ffffffff811bcb43&gt;] ext4_ext_fiemap_cb+0x138/0x157
         [&lt;ffffffff811bca0b&gt;] ? ext4_ext_fiemap_cb+0x0/0x157
         [&lt;ffffffff811be069&gt;] ext4_ext_walk_space+0x178/0x1f1
         [&lt;ffffffff811be21e&gt;] ext4_fiemap+0x13c/0x159
         [&lt;ffffffff81107224&gt;] ? might_fault+0x5c/0xac
         [&lt;ffffffff811390e6&gt;] do_vfs_ioctl+0x348/0x4d6
         [&lt;ffffffff8129f6d0&gt;] ? __up_read+0x8d/0x95
         [&lt;ffffffff81517fb5&gt;] ? retint_swapgs+0x13/0x1b
         [&lt;ffffffff811392ca&gt;] sys_ioctl+0x56/0x79
         [&lt;ffffffff81028cb2&gt;] system_call_fastpath+0x16/0x1b
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 700206e525da..3a7928f825e4 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1762,7 +1762,9 @@ int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
 	while (block &lt; last &amp;&amp; block != EXT_MAX_BLOCK) {
 		num = last - block;
 		/* find extent for this block */
+		down_read(&amp;EXT4_I(inode)-&gt;i_data_sem);
 		path = ext4_ext_find_extent(inode, block, path);
+		up_read(&amp;EXT4_I(inode)-&gt;i_data_sem);
 		if (IS_ERR(path)) {
 			err = PTR_ERR(path);
 			path = NULL;
@@ -3724,10 +3726,8 @@ int ext4_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 		 * Walk the extent tree gathering extent information.
 		 * ext4_ext_fiemap_cb will push extents back to user.
 		 */
-		down_read(&amp;EXT4_I(inode)-&gt;i_data_sem);
 		error = ext4_ext_walk_space(inode, start_blk, len_blks,
 					  ext4_ext_fiemap_cb, fieinfo);
-		up_read(&amp;EXT4_I(inode)-&gt;i_data_sem);
 	}
 
 	return error;</pre><hr><pre>commit a214238d3bb03723f820b0a398928d8e1637c987
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 9 21:09:58 2009 -0500

    ext4: Do not override ext2 or ext3 if built they are built as modules
    
    The CONFIG_EXT4_USE_FOR_EXT23 option must not try to take over the
    ext2 or ext3 file systems if the those file system drivers are
    configured to be built as mdoules.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/Kconfig b/fs/ext4/Kconfig
index a6b4e93833d6..9acf7e808139 100644
--- a/fs/ext4/Kconfig
+++ b/fs/ext4/Kconfig
@@ -28,7 +28,7 @@ config EXT4_FS
 
 config EXT4_USE_FOR_EXT23
 	bool "Use ext4 for ext2/ext3 file systems"
-	depends on !EXT3_FS || !EXT2_FS
+	depends on EXT3_FS=n || EXT2_FS=n
 	default y
 	help
 	  Allow the ext4 file system driver code to be used for ext2 or
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 2b13dcfcf775..8b58a144c31b 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3964,7 +3964,7 @@ static int ext4_get_sb(struct file_system_type *fs_type, int flags,
 	return get_sb_bdev(fs_type, flags, dev_name, data, ext4_fill_super,mnt);
 }
 
-#if !defined(CONTIG_EXT2_FS) &amp;&amp; defined(CONFIG_EXT4_USE_FOR_EXT23)
+#if !defined(CONTIG_EXT2_FS) &amp;&amp; !defined(CONFIG_EXT2_FS_MODULE) &amp;&amp; defined(CONFIG_EXT4_USE_FOR_EXT23)
 static struct file_system_type ext2_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "ext2",
@@ -3990,7 +3990,7 @@ static inline void register_as_ext2(void) { }
 static inline void unregister_as_ext2(void) { }
 #endif
 
-#if !defined(CONTIG_EXT3_FS) &amp;&amp; defined(CONFIG_EXT4_USE_FOR_EXT23)
+#if !defined(CONTIG_EXT3_FS) &amp;&amp; !defined(CONFIG_EXT3_FS_MODULE) &amp;&amp; defined(CONFIG_EXT4_USE_FOR_EXT23)
 static struct file_system_type ext3_fs_type = {
 	.owner		= THIS_MODULE,
 	.name		= "ext3",</pre><hr><pre>commit 3b799d15f2622c44bae93961892d90ab012ea2be
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 9 20:42:53 2009 -0500

    jbd2: Export jbd2_log_start_commit to fix ext4 build
    
        This fixes:
        ERROR: "jbd2_log_start_commit" [fs/ext4/ext4.ko] undefined!
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 3f473faa4660..b7ca3a92a4db 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -78,6 +78,7 @@ EXPORT_SYMBOL(jbd2_journal_errno);
 EXPORT_SYMBOL(jbd2_journal_ack_err);
 EXPORT_SYMBOL(jbd2_journal_clear_err);
 EXPORT_SYMBOL(jbd2_log_wait_commit);
+EXPORT_SYMBOL(jbd2_log_start_commit);
 EXPORT_SYMBOL(jbd2_journal_start_commit);
 EXPORT_SYMBOL(jbd2_journal_force_commit_nested);
 EXPORT_SYMBOL(jbd2_journal_wipe);</pre><hr><pre>commit 7e8b60faea972604c315634cff62d44803731ea9
Author: Andrew Lutomirski &lt;luto@mit.edu&gt;
Date:   Sun Nov 8 13:49:51 2009 -0500

    drm/i915: restore render clock gating on resume
    
    Rather than restoring just a few clock gating registers on resume,
    just reinitialize the whole thing.
    
    Signed-off-by: Andy Lutomirski &lt;luto@mit.edu&gt;
    [anholt: Fixed up for RC6 support landed since the patch was written]
    Signed-off-by: Eric Anholt &lt;eric@anholt.net&gt;

diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index e28d6c9a0ae9..1d6171087298 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -381,8 +381,6 @@ typedef struct drm_i915_private {
 	u32 saveFDI_RXA_IMR;
 	u32 saveFDI_RXB_IMR;
 	u32 saveCACHE_MODE_0;
-	u32 saveD_STATE;
-	u32 saveDSPCLK_GATE_D;
 	u32 saveMI_ARB_STATE;
 	u32 saveSWF0[16];
 	u32 saveSWF1[16];
diff --git a/drivers/gpu/drm/i915/i915_suspend.c b/drivers/gpu/drm/i915/i915_suspend.c
index 402a7eb2922c..00f6d97c7cc5 100644
--- a/drivers/gpu/drm/i915/i915_suspend.c
+++ b/drivers/gpu/drm/i915/i915_suspend.c
@@ -722,10 +722,6 @@ int i915_save_state(struct drm_device *dev)
 		dev_priv-&gt;saveIMR = I915_READ(IMR);
 	}
 
-	/* Clock gating state */
-	dev_priv-&gt;saveD_STATE = I915_READ(D_STATE);
-	dev_priv-&gt;saveDSPCLK_GATE_D = I915_READ(DSPCLK_GATE_D); /* Not sure about this */
-
 	/* Cache mode state */
 	dev_priv-&gt;saveCACHE_MODE_0 = I915_READ(CACHE_MODE_0);
 
@@ -800,8 +796,7 @@ int i915_restore_state(struct drm_device *dev)
 	}
 
 	/* Clock gating state */
-	I915_WRITE (D_STATE, dev_priv-&gt;saveD_STATE);
-	I915_WRITE (DSPCLK_GATE_D, dev_priv-&gt;saveDSPCLK_GATE_D);
+	intel_init_clock_gating(dev);
 
 	/* Cache mode state */
 	I915_WRITE (CACHE_MODE_0, dev_priv-&gt;saveCACHE_MODE_0 | 0xffff0000);
diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c
index 902cc5386f19..279dc96e3eb2 100644
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -4584,28 +4584,33 @@ void intel_init_clock_gating(struct drm_device *dev)
 		struct drm_i915_gem_object *obj_priv;
 		int ret;
 
-		pwrctx = drm_gem_object_alloc(dev, 4096);
-		if (!pwrctx) {
-			DRM_DEBUG("failed to alloc power context, RC6 disabled\n");
-			goto out;
-		}
+		if (dev_priv-&gt;pwrctx) {
+			obj_priv = dev_priv-&gt;pwrctx-&gt;driver_private;
+		} else {
+			pwrctx = drm_gem_object_alloc(dev, 4096);
+			if (!pwrctx) {
+				DRM_DEBUG("failed to alloc power context, "
+					  "RC6 disabled\n");
+				goto out;
+			}
 
-		ret = i915_gem_object_pin(pwrctx, 4096);
-		if (ret) {
-			DRM_ERROR("failed to pin power context: %d\n", ret);
-			drm_gem_object_unreference(pwrctx);
-			goto out;
-		}
+			ret = i915_gem_object_pin(pwrctx, 4096);
+			if (ret) {
+				DRM_ERROR("failed to pin power context: %d\n",
+					  ret);
+				drm_gem_object_unreference(pwrctx);
+				goto out;
+			}
 
-		i915_gem_object_set_to_gtt_domain(pwrctx, 1);
+			i915_gem_object_set_to_gtt_domain(pwrctx, 1);
 
-		obj_priv = pwrctx-&gt;driver_private;
+			dev_priv-&gt;pwrctx = pwrctx;
+			obj_priv = pwrctx-&gt;driver_private;
+		}
 
 		I915_WRITE(PWRCTXA, obj_priv-&gt;gtt_offset | PWRCTX_EN);
 		I915_WRITE(MCHBAR_RENDER_STANDBY,
 			   I915_READ(MCHBAR_RENDER_STANDBY) &amp; ~RCX_SW_EXIT);
-
-		dev_priv-&gt;pwrctx = pwrctx;
 	}
 
 out:
diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h
index 9ffa31e13eb3..a51573da1ff6 100644
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -208,6 +208,7 @@ extern void intel_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
 				    u16 blue, int regno);
 extern void intel_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
 				    u16 *blue, int regno);
+extern void intel_init_clock_gating(struct drm_device *dev);
 
 extern int intel_framebuffer_create(struct drm_device *dev,
 				    struct drm_mode_fb_cmd *mode_cmd,</pre><hr><pre>commit d2eecb03936878ec574ade5532fa83df7d75dde7
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Dec 7 10:36:20 2009 -0500

    ext4: Use slab allocator for sub-page sized allocations
    
    Now that the SLUB seems to be fixed so that it respects the requested
    alignment, use kmem_cache_alloc() to allocator if the block size of
    the buffer heads to be allocated is less than the page size.
    Previously, we were using 16k page on a Power system for each buffer,
    even when the file system was using 1k or 4k block size.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index ac0d027595d0..c03d4dce4d76 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -39,6 +39,8 @@
 #include &lt;linux/seq_file.h&gt;
 #include &lt;linux/math64.h&gt;
 #include &lt;linux/hash.h&gt;
+#include &lt;linux/log2.h&gt;
+#include &lt;linux/vmalloc.h&gt;
 
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/jbd2.h&gt;
@@ -93,6 +95,7 @@ EXPORT_SYMBOL(jbd2_journal_begin_ordered_truncate);
 
 static int journal_convert_superblock_v1(journal_t *, journal_superblock_t *);
 static void __journal_abort_soft (journal_t *journal, int errno);
+static int jbd2_journal_create_slab(size_t slab_size);
 
 /*
  * Helper function used to manage commit timeouts
@@ -1248,6 +1251,13 @@ int jbd2_journal_load(journal_t *journal)
 		}
 	}
 
+	/*
+	 * Create a slab for this blocksize
+	 */
+	err = jbd2_journal_create_slab(be32_to_cpu(sb-&gt;s_blocksize));
+	if (err)
+		return err;
+
 	/* Let the recovery code check whether it needs to recover any
 	 * data from the journal. */
 	if (jbd2_journal_recover(journal))
@@ -1806,6 +1816,127 @@ size_t journal_tag_bytes(journal_t *journal)
 		return JBD2_TAG_SIZE32;
 }
 
+/*
+ * JBD memory management
+ *
+ * These functions are used to allocate block-sized chunks of memory
+ * used for making copies of buffer_head data.  Very often it will be
+ * page-sized chunks of data, but sometimes it will be in
+ * sub-page-size chunks.  (For example, 16k pages on Power systems
+ * with a 4k block file system.)  For blocks smaller than a page, we
+ * use a SLAB allocator.  There are slab caches for each block size,
+ * which are allocated at mount time, if necessary, and we only free
+ * (all of) the slab caches when/if the jbd2 module is unloaded.  For
+ * this reason we don't need to a mutex to protect access to
+ * jbd2_slab[] allocating or releasing memory; only in
+ * jbd2_journal_create_slab().
+ */
+#define JBD2_MAX_SLABS 8
+static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];
+static DECLARE_MUTEX(jbd2_slab_create_sem);
+
+static const char *jbd2_slab_names[JBD2_MAX_SLABS] = {
+	"jbd2_1k", "jbd2_2k", "jbd2_4k", "jbd2_8k",
+	"jbd2_16k", "jbd2_32k", "jbd2_64k", "jbd2_128k"
+};
+
+
+static void jbd2_journal_destroy_slabs(void)
+{
+	int i;
+
+	for (i = 0; i &lt; JBD2_MAX_SLABS; i++) {
+		if (jbd2_slab[i])
+			kmem_cache_destroy(jbd2_slab[i]);
+		jbd2_slab[i] = NULL;
+	}
+}
+
+static int jbd2_journal_create_slab(size_t size)
+{
+	int i = order_base_2(size) - 10;
+	size_t slab_size;
+
+	if (size == PAGE_SIZE)
+		return 0;
+
+	if (i &gt;= JBD2_MAX_SLABS)
+		return -EINVAL;
+
+	if (unlikely(i &lt; 0))
+		i = 0;
+	down(&amp;jbd2_slab_create_sem);
+	if (jbd2_slab[i]) {
+		up(&amp;jbd2_slab_create_sem);
+		return 0;	/* Already created */
+	}
+
+	slab_size = 1 &lt;&lt; (i+10);
+	jbd2_slab[i] = kmem_cache_create(jbd2_slab_names[i], slab_size,
+					 slab_size, 0, NULL);
+	up(&amp;jbd2_slab_create_sem);
+	if (!jbd2_slab[i]) {
+		printk(KERN_EMERG "JBD2: no memory for jbd2_slab cache\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static struct kmem_cache *get_slab(size_t size)
+{
+	int i = order_base_2(size) - 10;
+
+	BUG_ON(i &gt;= JBD2_MAX_SLABS);
+	if (unlikely(i &lt; 0))
+		i = 0;
+	BUG_ON(jbd2_slab[i] == 0);
+	return jbd2_slab[i];
+}
+
+void *jbd2_alloc(size_t size, gfp_t flags)
+{
+	void *ptr;
+
+	BUG_ON(size &amp; (size-1)); /* Must be a power of 2 */
+
+	flags |= __GFP_REPEAT;
+	if (size == PAGE_SIZE)
+		ptr = (void *)__get_free_pages(flags, 0);
+	else if (size &gt; PAGE_SIZE) {
+		int order = get_order(size);
+
+		if (order &lt; 3)
+			ptr = (void *)__get_free_pages(flags, order);
+		else
+			ptr = vmalloc(size);
+	} else
+		ptr = kmem_cache_alloc(get_slab(size), flags);
+
+	/* Check alignment; SLUB has gotten this wrong in the past,
+	 * and this can lead to user data corruption! */
+	BUG_ON(((unsigned long) ptr) &amp; (size-1));
+
+	return ptr;
+}
+
+void jbd2_free(void *ptr, size_t size)
+{
+	if (size == PAGE_SIZE) {
+		free_pages((unsigned long)ptr, 0);
+		return;
+	}
+	if (size &gt; PAGE_SIZE) {
+		int order = get_order(size);
+
+		if (order &lt; 3)
+			free_pages((unsigned long)ptr, order);
+		else
+			vfree(ptr);
+		return;
+	}
+	kmem_cache_free(get_slab(size), ptr);
+};
+
 /*
  * Journal_head storage management
  */
@@ -2204,6 +2335,7 @@ static void jbd2_journal_destroy_caches(void)
 	jbd2_journal_destroy_revoke_caches();
 	jbd2_journal_destroy_jbd2_journal_head_cache();
 	jbd2_journal_destroy_handle_cache();
+	jbd2_journal_destroy_slabs();
 }
 
 static int __init journal_init(void)
diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h
index 638ce4554c76..8ada2a129d08 100644
--- a/include/linux/jbd2.h
+++ b/include/linux/jbd2.h
@@ -69,15 +69,8 @@ extern u8 jbd2_journal_enable_debug;
 #define jbd_debug(f, a...)	/**/
 #endif
 
-static inline void *jbd2_alloc(size_t size, gfp_t flags)
-{
-	return (void *)__get_free_pages(flags, get_order(size));
-}
-
-static inline void jbd2_free(void *ptr, size_t size)
-{
-	free_pages((unsigned long)ptr, get_order(size));
-};
+extern void *jbd2_alloc(size_t size, gfp_t flags);
+extern void jbd2_free(void *ptr, size_t size);
 
 #define JBD2_MIN_JOURNAL_BLOCKS 1024
 </pre><hr><pre>commit f8ec9d6837241865cf99bed97bb99f4399fd5a03
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri Jan 1 01:00:21 2010 -0500

    ext4: Add new tracepoints to debug delayed allocation space functions
    
    Add tracepoints for ext4_da_reserve_space(),
    ext4_da_update_reserve_space(), and ext4_da_release_space().
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 3e8afd969236..1a3d7b232cd7 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1061,6 +1061,7 @@ void ext4_da_update_reserve_space(struct inode *inode,
 	int mdb_free = 0, allocated_meta_blocks = 0;
 
 	spin_lock(&amp;ei-&gt;i_block_reservation_lock);
+	trace_ext4_da_update_reserve_space(inode, used);
 	if (unlikely(used &gt; ei-&gt;i_reserved_data_blocks)) {
 		ext4_msg(inode-&gt;i_sb, KERN_NOTICE, "%s: ino %lu, used %d "
 			 "with only %d reserved data blocks\n",
@@ -1846,6 +1847,7 @@ static int ext4_da_reserve_space(struct inode *inode, sector_t lblock)
 	spin_lock(&amp;ei-&gt;i_block_reservation_lock);
 	md_reserved = ei-&gt;i_reserved_meta_blocks;
 	md_needed = ext4_calc_metadata_amount(inode, lblock);
+	trace_ext4_da_reserve_space(inode, md_needed);
 	spin_unlock(&amp;ei-&gt;i_block_reservation_lock);
 
 	/*
diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index d0b6cd3afb2f..2aa6aa3e8f61 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -874,6 +874,107 @@ TRACE_EVENT(ext4_forget,
 		  __entry-&gt;mode, __entry-&gt;is_metadata, __entry-&gt;block)
 );
 
+TRACE_EVENT(ext4_da_update_reserve_space,
+	TP_PROTO(struct inode *inode, int used_blocks),
+
+	TP_ARGS(inode, used_blocks),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	ino_t,	ino			)
+		__field(	umode_t, mode			)
+		__field(	__u64,	i_blocks		)
+		__field(	int,	used_blocks		)
+		__field(	int,	reserved_data_blocks	)
+		__field(	int,	reserved_meta_blocks	)
+		__field(	int,	allocated_meta_blocks	)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;ino	= inode-&gt;i_ino;
+		__entry-&gt;mode	= inode-&gt;i_mode;
+		__entry-&gt;i_blocks = inode-&gt;i_blocks;
+		__entry-&gt;used_blocks = used_blocks;
+		__entry-&gt;reserved_data_blocks = EXT4_I(inode)-&gt;i_reserved_data_blocks;
+		__entry-&gt;reserved_meta_blocks = EXT4_I(inode)-&gt;i_reserved_meta_blocks;
+		__entry-&gt;allocated_meta_blocks = EXT4_I(inode)-&gt;i_allocated_meta_blocks;
+	),
+
+	TP_printk("dev %s ino %lu mode 0%o i_blocks %llu used_blocks %d reserved_data_blocks %d reserved_meta_blocks %d allocated_meta_blocks %d",
+		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;mode,  (unsigned long long) __entry-&gt;i_blocks,
+		  __entry-&gt;used_blocks, __entry-&gt;reserved_data_blocks,
+		  __entry-&gt;reserved_meta_blocks, __entry-&gt;allocated_meta_blocks)
+);
+
+TRACE_EVENT(ext4_da_reserve_space,
+	TP_PROTO(struct inode *inode, int md_needed),
+
+	TP_ARGS(inode, md_needed),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	ino_t,	ino			)
+		__field(	umode_t, mode			)
+		__field(	__u64,	i_blocks		)
+		__field(	int,	md_needed		)
+		__field(	int,	reserved_data_blocks	)
+		__field(	int,	reserved_meta_blocks	)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;ino	= inode-&gt;i_ino;
+		__entry-&gt;mode	= inode-&gt;i_mode;
+		__entry-&gt;i_blocks = inode-&gt;i_blocks;
+		__entry-&gt;md_needed = md_needed;
+		__entry-&gt;reserved_data_blocks = EXT4_I(inode)-&gt;i_reserved_data_blocks;
+		__entry-&gt;reserved_meta_blocks = EXT4_I(inode)-&gt;i_reserved_meta_blocks;
+	),
+
+	TP_printk("dev %s ino %lu mode 0%o i_blocks %llu md_needed %d reserved_data_blocks %d reserved_meta_blocks %d",
+		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;mode, (unsigned long long) __entry-&gt;i_blocks,
+		  __entry-&gt;md_needed, __entry-&gt;reserved_data_blocks,
+		  __entry-&gt;reserved_meta_blocks)
+);
+
+TRACE_EVENT(ext4_da_release_space,
+	TP_PROTO(struct inode *inode, int freed_blocks),
+
+	TP_ARGS(inode, freed_blocks),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	ino_t,	ino			)
+		__field(	umode_t, mode			)
+		__field(	__u64,	i_blocks		)
+		__field(	int,	freed_blocks		)
+		__field(	int,	reserved_data_blocks	)
+		__field(	int,	reserved_meta_blocks	)
+		__field(	int,	allocated_meta_blocks	)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;ino	= inode-&gt;i_ino;
+		__entry-&gt;mode	= inode-&gt;i_mode;
+		__entry-&gt;i_blocks = inode-&gt;i_blocks;
+		__entry-&gt;freed_blocks = freed_blocks;
+		__entry-&gt;reserved_data_blocks = EXT4_I(inode)-&gt;i_reserved_data_blocks;
+		__entry-&gt;reserved_meta_blocks = EXT4_I(inode)-&gt;i_reserved_meta_blocks;
+		__entry-&gt;allocated_meta_blocks = EXT4_I(inode)-&gt;i_allocated_meta_blocks;
+	),
+
+	TP_printk("dev %s ino %lu mode 0%o i_blocks %llu freed_blocks %d reserved_data_blocks %d reserved_meta_blocks %d allocated_meta_blocks %d",
+		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;mode, (unsigned long long) __entry-&gt;i_blocks,
+		  __entry-&gt;freed_blocks, __entry-&gt;reserved_data_blocks,
+		  __entry-&gt;reserved_meta_blocks, __entry-&gt;allocated_meta_blocks)
+);
+
+
 #endif /* _TRACE_EXT4_H */
 
 /* This part must be outside protection */</pre><hr><pre>commit 71f2be213a0009098819e5c04f75ff19f84f2122
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 23 07:45:44 2009 -0500

    ext4: Add new tracepoint for jbd2_cleanup_journal_tail
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c
index 886849370950..30beb11ef928 100644
--- a/fs/jbd2/checkpoint.c
+++ b/fs/jbd2/checkpoint.c
@@ -507,6 +507,7 @@ int jbd2_cleanup_journal_tail(journal_t *journal)
 	if (blocknr &lt; journal-&gt;j_tail)
 		freed = freed + journal-&gt;j_last - journal-&gt;j_first;
 
+	trace_jbd2_cleanup_journal_tail(journal, first_tid, blocknr, freed);
 	jbd_debug(1,
 		  "Cleaning journal tail from %d to %d (offset %lu), "
 		  "freeing %lu\n",
diff --git a/include/trace/events/jbd2.h b/include/trace/events/jbd2.h
index 96b370a050de..bf16545cc977 100644
--- a/include/trace/events/jbd2.h
+++ b/include/trace/events/jbd2.h
@@ -199,6 +199,34 @@ TRACE_EVENT(jbd2_checkpoint_stats,
 		  __entry-&gt;forced_to_close, __entry-&gt;written, __entry-&gt;dropped)
 );
 
+TRACE_EVENT(jbd2_cleanup_journal_tail,
+
+	TP_PROTO(journal_t *journal, tid_t first_tid,
+		 unsigned long block_nr, unsigned long freed),
+
+	TP_ARGS(journal, first_tid, block_nr, freed),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	tid_t,	tail_sequence		)
+		__field(	tid_t,	first_tid		)
+		__field(unsigned long,	block_nr		)
+		__field(unsigned long,	freed			)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= journal-&gt;j_fs_dev-&gt;bd_dev;
+		__entry-&gt;tail_sequence	= journal-&gt;j_tail_sequence;
+		__entry-&gt;first_tid	= first_tid;
+		__entry-&gt;block_nr	= block_nr;
+		__entry-&gt;freed		= freed;
+	),
+
+	TP_printk("dev %s from %u to %u offset %lu freed %lu",
+		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;tail_sequence,
+		  __entry-&gt;first_tid, __entry-&gt;block_nr, __entry-&gt;freed)
+);
+
 #endif /* _TRACE_JBD2_H */
 
 /* This part must be outside protection */</pre>
    <div class="pagination">
        <a href='1_84.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><span>[85]</span><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_86.html'>Next&gt;&gt;</a>
    <div>
</body>
