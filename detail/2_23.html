<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_22.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><span>[23]</span><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_24.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 796aa46adf1d90eab36ae06a42e6d3f10b28a75c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 26 15:45:41 2016 -0700

    memstick: rtsx_usb_ms: Runtime resume the device when polling for cards
    
    Accesses to the rtsx usb device, which is the parent of the rtsx memstick
    device, must not be done unless it's runtime resumed.
    
    Therefore when the rtsx_usb_ms driver polls for inserted memstick cards,
    let's add pm_runtime_get|put*() to make sure accesses is done when the
    rtsx usb device is runtime resumed.
    
    Reported-by: Ritesh Raj Sarraf &lt;rrs@researchut.com&gt;
    Tested-by: Ritesh Raj Sarraf &lt;rrs@researchut.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Ulf Hansson &lt;ulf.hansson@linaro.org&gt;

diff --git a/drivers/memstick/host/rtsx_usb_ms.c b/drivers/memstick/host/rtsx_usb_ms.c
index d34bc3530385..1b994897f0ff 100644
--- a/drivers/memstick/host/rtsx_usb_ms.c
+++ b/drivers/memstick/host/rtsx_usb_ms.c
@@ -681,6 +681,7 @@ static int rtsx_usb_detect_ms_card(void *__host)
 	int err;
 
 	for (;;) {
+		pm_runtime_get_sync(ms_dev(host));
 		mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 		/* Check pending MS card changes */
@@ -703,6 +704,7 @@ static int rtsx_usb_detect_ms_card(void *__host)
 		}
 
 poll_again:
+		pm_runtime_put(ms_dev(host));
 		if (host-&gt;eject)
 			break;
 </pre><hr><pre>commit 08c5cd37480f59ea39682f4585d92269be6b1424
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 16 10:24:26 2016 -0400

    USB: change bInterval default to 10 ms
    
    Some full-speed mceusb infrared transceivers contain invalid endpoint
    descriptors for their interrupt endpoints, with bInterval set to 0.
    In the past they have worked out okay with the mceusb driver, because
    the driver sets the bInterval field in the descriptor to 1,
    overwriting whatever value may have been there before.  However, this
    approach was never sanctioned by the USB core, and in fact it does not
    work with xHCI controllers, because they use the bInterval value that
    was present when the configuration was installed.
    
    Currently usbcore uses 32 ms as the default interval if the value in
    the endpoint descriptor is invalid.  It turns out that these IR
    transceivers don't work properly unless the interval is set to 10 ms
    or below.  To work around this mceusb problem, this patch changes the
    endpoint-descriptor parsing routine, making the default interval value
    be 10 ms rather than 32 ms.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Wade Berrier &lt;wberrier@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 15ce4ab11688..a2d90aca779f 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -240,8 +240,10 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	memcpy(&amp;endpoint-&gt;desc, d, n);
 	INIT_LIST_HEAD(&amp;endpoint-&gt;urb_list);
 
-	/* Fix up bInterval values outside the legal range. Use 32 ms if no
-	 * proper value can be guessed. */
+	/*
+	 * Fix up bInterval values outside the legal range.
+	 * Use 10 or 8 ms if no proper value can be guessed.
+	 */
 	i = 0;		/* i = min, j = max, n = default */
 	j = 255;
 	if (usb_endpoint_xfer_int(d)) {
@@ -250,13 +252,15 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 		case USB_SPEED_SUPER_PLUS:
 		case USB_SPEED_SUPER:
 		case USB_SPEED_HIGH:
-			/* Many device manufacturers are using full-speed
+			/*
+			 * Many device manufacturers are using full-speed
 			 * bInterval values in high-speed interrupt endpoint
-			 * descriptors. Try to fix those and fall back to a
-			 * 32 ms default value otherwise. */
+			 * descriptors. Try to fix those and fall back to an
+			 * 8-ms default value otherwise.
+			 */
 			n = fls(d-&gt;bInterval*8);
 			if (n == 0)
-				n = 9;	/* 32 ms = 2^(9-1) uframes */
+				n = 7;	/* 8 ms = 2^(7-1) uframes */
 			j = 16;
 
 			/*
@@ -271,10 +275,12 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 			}
 			break;
 		default:		/* USB_SPEED_FULL or _LOW */
-			/* For low-speed, 10 ms is the official minimum.
+			/*
+			 * For low-speed, 10 ms is the official minimum.
 			 * But some "overclocked" devices might want faster
-			 * polling so we'll allow it. */
-			n = 32;
+			 * polling so we'll allow it.
+			 */
+			n = 10;
 			break;
 		}
 	} else if (usb_endpoint_xfer_isoc(d)) {
@@ -282,10 +288,10 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 		j = 16;
 		switch (to_usb_device(ddev)-&gt;speed) {
 		case USB_SPEED_HIGH:
-			n = 9;		/* 32 ms = 2^(9-1) uframes */
+			n = 7;		/* 8 ms = 2^(7-1) uframes */
 			break;
 		default:		/* USB_SPEED_FULL */
-			n = 6;		/* 32 ms = 2^(6-1) frames */
+			n = 4;		/* 8 ms = 2^(4-1) frames */
 			break;
 		}
 	}</pre><hr><pre>commit fc8b690d5da86a4b309b74fb706cc1eb75d003e6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 25 11:30:49 2016 -0400

    usb-storage: MAINTAINERS: Alan Stern is the new maintainer
    
    At Matt Dharm's request, I am taking over maintainership of the
    usb-storage driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/MAINTAINERS b/MAINTAINERS
index 0bbe4b105c34..deff5cb58002 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -12163,7 +12163,7 @@ S:	Maintained
 F:	drivers/net/usb/lan78xx.*
 
 USB MASS STORAGE DRIVER
-M:	Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
+M:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
 L:	linux-usb@vger.kernel.org
 L:	usb-storage@lists.one-eyed-alien.net
 S:	Maintained</pre><hr><pre>commit 53e5f36fbd2453ad69a3369a1db62dc06c30a4aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 23 15:32:51 2016 -0400

    USB: avoid left shift by -1
    
    UBSAN complains about a left shift by -1 in proc_do_submiturb().  This
    can occur when an URB is submitted for a bulk or control endpoint on
    a high-speed device, since the code doesn't bother to check the
    endpoint type; normally only interrupt or isochronous endpoints have
    a nonzero bInterval value.
    
    Aside from the fact that the operation is illegal, it shouldn't matter
    because the result isn't used.  Still, in theory it could cause a
    hardware exception or other problem, so we should work around it.
    This patch avoids doing the left shift unless the shift amount is &gt;= 0.
    
    The same piece of code has another problem.  When checking the device
    speed (the exponential encoding for interrupt endpoints is used only
    by high-speed or faster devices), we need to look for speed &gt;=
    USB_SPEED_SUPER as well as speed == USB_SPEED HIGH.  The patch adds
    this check.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Vittorio Zecca &lt;zeccav@gmail.com&gt;
    Tested-by: Vittorio Zecca &lt;zeccav@gmail.com&gt;
    Suggested-by: Bjørn Mork &lt;bjorn@mork.no&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index e6a6d67c8705..09c8d9ca61ae 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1709,11 +1709,17 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = number_of_packets;
 	as-&gt;urb-&gt;stream_id = stream_id;
-	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||
-			ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)
-		as-&gt;urb-&gt;interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);
-	else
-		as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;
+
+	if (ep-&gt;desc.bInterval) {
+		if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||
+				ps-&gt;dev-&gt;speed == USB_SPEED_HIGH ||
+				ps-&gt;dev-&gt;speed &gt;= USB_SPEED_SUPER)
+			as-&gt;urb-&gt;interval = 1 &lt;&lt;
+					min(15, ep-&gt;desc.bInterval - 1);
+		else
+			as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;
+	}
+
 	as-&gt;urb-&gt;context = as;
 	as-&gt;urb-&gt;complete = async_completed;
 	for (totlen = u = 0; u &lt; number_of_packets; u++) {</pre><hr><pre>commit 6c73358c83ce870c0cf32413e5cadb3b9a39c606
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 22 16:58:53 2016 -0400

    USB: fix typo in wMaxPacketSize validation
    
    The maximum value allowed for wMaxPacketSize of a high-speed interrupt
    endpoint is 1024 bytes, not 1023.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: aed9d65ac327 ("USB: validate wMaxPacketValue entries in endpoint descriptors")
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 051163189810..15ce4ab11688 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -187,7 +187,7 @@ static const unsigned short high_speed_maxpacket_maxes[4] = {
 	[USB_ENDPOINT_XFER_CONTROL] = 64,
 	[USB_ENDPOINT_XFER_ISOC] = 1024,
 	[USB_ENDPOINT_XFER_BULK] = 512,
-	[USB_ENDPOINT_XFER_INT] = 1023,
+	[USB_ENDPOINT_XFER_INT] = 1024,
 };
 static const unsigned short super_speed_maxpacket_maxes[4] = {
 	[USB_ENDPOINT_XFER_CONTROL] = 512,</pre><hr><pre>commit 5cce438298a0d2a7a857a4a3c3e26aeb8f77b941
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 10 14:42:55 2016 -0400

    USB: remove race condition in usbfs/libusb when using reap-after-disconnect
    
    Hans de Goede has reported a difficulty in the Linux port of libusb.
    When a device is removed, the poll() system call in usbfs starts
    returning POLLERR as soon as udev-&gt;state is set to
    USB_STATE_NOTATTACHED, but the outstanding URBs are not available for
    reaping until some time later (after usbdev_remove() has been called).
    This is awkward for libusb or other usbfs clients, although not an
    insuperable problem.
    
    At any rate, it's easy to change usbfs so that it returns POLLHUP as
    soon as the state becomes USB_STATE_NOTATTACHED but it doesn't return
    POLLERR until after the outstanding URBs have completed.  That's what
    this patch does; it uses the fact that ps-&gt;list is always on the
    dev-&gt;filelist list until usbdev_remove() takes it off, which happens
    after all the outstanding URBs have been cancelled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 472cbcdf7456..e6a6d67c8705 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -2583,7 +2583,9 @@ static unsigned int usbdev_poll(struct file *file,
 	if (file-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !list_empty(&amp;ps-&gt;async_completed))
 		mask |= POLLOUT | POLLWRNORM;
 	if (!connected(ps))
-		mask |= POLLERR | POLLHUP;
+		mask |= POLLHUP;
+	if (list_empty(&amp;ps-&gt;list))
+		mask |= POLLERR;
 	return mask;
 }
 </pre><hr><pre>commit aed9d65ac3278d4febd8665bd7db59ef53e825fe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 1 15:25:56 2016 -0400

    USB: validate wMaxPacketValue entries in endpoint descriptors
    
    Erroneous or malicious endpoint descriptors may have non-zero bits in
    reserved positions, or out-of-bounds values.  This patch helps prevent
    these from causing problems by bounds-checking the wMaxPacketValue
    entries in endpoint descriptors and capping the values at the maximum
    allowed.
    
    This issue was first discovered and tests were conducted by Jake Lamberson
    &lt;jake.lamberson1@gmail.com&gt;, an intern working for Rosie Hall.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: roswest &lt;roswest@cisco.com&gt;
    Tested-by: roswest &lt;roswest@cisco.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 31ccdccd7a04..051163189810 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -171,6 +171,31 @@ static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,
 							ep, buffer, size);
 }
 
+static const unsigned short low_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 8,
+	[USB_ENDPOINT_XFER_ISOC] = 0,
+	[USB_ENDPOINT_XFER_BULK] = 0,
+	[USB_ENDPOINT_XFER_INT] = 8,
+};
+static const unsigned short full_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 64,
+	[USB_ENDPOINT_XFER_ISOC] = 1023,
+	[USB_ENDPOINT_XFER_BULK] = 64,
+	[USB_ENDPOINT_XFER_INT] = 64,
+};
+static const unsigned short high_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 64,
+	[USB_ENDPOINT_XFER_ISOC] = 1024,
+	[USB_ENDPOINT_XFER_BULK] = 512,
+	[USB_ENDPOINT_XFER_INT] = 1023,
+};
+static const unsigned short super_speed_maxpacket_maxes[4] = {
+	[USB_ENDPOINT_XFER_CONTROL] = 512,
+	[USB_ENDPOINT_XFER_ISOC] = 1024,
+	[USB_ENDPOINT_XFER_BULK] = 1024,
+	[USB_ENDPOINT_XFER_INT] = 1024,
+};
+
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
     int asnum, struct usb_host_interface *ifp, int num_ep,
     unsigned char *buffer, int size)
@@ -179,6 +204,8 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
+	unsigned int maxp;
+	const unsigned short *maxpacket_maxes;
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
@@ -286,6 +313,42 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
+	/* Validate the wMaxPacketSize field */
+	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);
+
+	/* Find the highest legal maxpacket size for this endpoint */
+	i = 0;		/* additional transactions per microframe */
+	switch (to_usb_device(ddev)-&gt;speed) {
+	case USB_SPEED_LOW:
+		maxpacket_maxes = low_speed_maxpacket_maxes;
+		break;
+	case USB_SPEED_FULL:
+		maxpacket_maxes = full_speed_maxpacket_maxes;
+		break;
+	case USB_SPEED_HIGH:
+		/* Bits 12..11 are allowed only for HS periodic endpoints */
+		if (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {
+			i = maxp &amp; (BIT(12) | BIT(11));
+			maxp &amp;= ~i;
+		}
+		/* fallthrough */
+	default:
+		maxpacket_maxes = high_speed_maxpacket_maxes;
+		break;
+	case USB_SPEED_SUPER:
+	case USB_SPEED_SUPER_PLUS:
+		maxpacket_maxes = super_speed_maxpacket_maxes;
+		break;
+	}
+	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];
+
+	if (maxp &gt; j) {
+		dev_warn(ddev, "config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n",
+		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);
+		maxp = j;
+		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);
+	}
+
 	/*
 	 * Some buggy high speed devices have bulk endpoints using
 	 * maxpacket sizes other than 512.  High speed HCDs may not
@@ -293,9 +356,6 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	 */
 	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_HIGH
 			&amp;&amp; usb_endpoint_xfer_bulk(d)) {
-		unsigned maxp;
-
-		maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc) &amp; 0x07ff;
 		if (maxp != 512)
 			dev_warn(ddev, "config %d interface %d altsetting %d "
 				"bulk endpoint 0x%X has invalid maxpacket %d\n",</pre><hr><pre>commit 07d316a22e119fa301fd7dba7f1e1adfd4f72c05
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 5 11:51:30 2016 -0400

    USB: hub: change the locking in hub_activate
    
    The locking in hub_activate() is not adequate to provide full mutual
    exclusion with hub_quiesce().  The subroutine locks the hub's
    usb_interface, but the callers of hub_quiesce() (such as
    hub_pre_reset() and hub_event()) hold the lock to the hub's
    usb_device.
    
    This patch changes hub_activate() to make it acquire the same lock as
    those other routines.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt; #4.4+
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index bb69d262b6f9..1d5fc32d06d0 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1052,7 +1052,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 
 	/* Continue a partial initialization */
 	if (type == HUB_INIT2 || type == HUB_INIT3) {
-		device_lock(hub-&gt;intfdev);
+		device_lock(&amp;hdev-&gt;dev);
 
 		/* Was the hub disconnected while we were waiting? */
 		if (hub-&gt;disconnected)
@@ -1259,7 +1259,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 			queue_delayed_work(system_power_efficient_wq,
 					&amp;hub-&gt;init_work,
 					msecs_to_jiffies(delay));
-			device_unlock(hub-&gt;intfdev);
+			device_unlock(&amp;hdev-&gt;dev);
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
@@ -1282,7 +1282,7 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 		/* Allow autosuspend if it was suppressed */
  disconnected:
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
-		device_unlock(hub-&gt;intfdev);
+		device_unlock(&amp;hdev-&gt;dev);
 	}
 
 	kref_put(&amp;hub-&gt;kref, hub_release);</pre><hr><pre>commit ca5cbc8b02f9b21cc8cd1ab36668763ec34f9ee8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 5 11:49:45 2016 -0400

    USB: hub: fix up early-exit pathway in hub_activate
    
    The early-exit pathway in hub_activate, added by commit e50293ef9775
    ("USB: fix invalid memory access in hub_activate()") needs
    improvement.  It duplicates code that is already present at the end of
    the subroutine, and it neglects to undo the effect of a
    usb_autopm_get_interface_no_resume() call.
    
    This patch fixes both problems by making the early-exit pathway jump
    directly to the end of the subroutine.  It simplifies the code at the
    end by merging two conditionals that actually test the same condition
    although they appear different: If type &lt; HUB_INIT3 then type must be
    either HUB_INIT2 or HUB_INIT, and it can't be HUB_INIT because in that
    case the subroutine would have exited earlier.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt; #4.4+
    Reviewed-by: Viresh Kumar &lt;viresh.kumar@linaro.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 3ccffac0f647..bb69d262b6f9 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1055,11 +1055,8 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 		device_lock(hub-&gt;intfdev);
 
 		/* Was the hub disconnected while we were waiting? */
-		if (hub-&gt;disconnected) {
-			device_unlock(hub-&gt;intfdev);
-			kref_put(&amp;hub-&gt;kref, hub_release);
-			return;
-		}
+		if (hub-&gt;disconnected)
+			goto disconnected;
 		if (type == HUB_INIT2)
 			goto init2;
 		goto init3;
@@ -1281,12 +1278,12 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	/* Scan all ports that need attention */
 	kick_hub_wq(hub);
 
-	/* Allow autosuspend if it was suppressed */
-	if (type &lt;= HUB_INIT3)
+	if (type == HUB_INIT2 || type == HUB_INIT3) {
+		/* Allow autosuspend if it was suppressed */
+ disconnected:
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
-
-	if (type == HUB_INIT2 || type == HUB_INIT3)
 		device_unlock(hub-&gt;intfdev);
+	}
 
 	kref_put(&amp;hub-&gt;kref, hub_release);
 }</pre><hr><pre>commit 5e7ff2ca7f2da55fe777167849d0c93403bd0dc8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 23 15:05:26 2016 -0400

    SCSI: fix new bug in scsi_dev_info_list string matching
    
    Commit b704f70ce200 ("SCSI: fix bug in scsi_dev_info_list matching")
    changed the way vendor- and model-string matching was carried out in the
    routine that looks up entries in a SCSI devinfo list.  The new matching
    code failed to take into account the case of a maximum-length string; in
    such cases it could end up testing for a terminating '\0' byte beyond
    the end of the memory allocated to the string.  This out-of-bounds bug
    was detected by UBSAN.
    
    I don't know if anybody has actually encountered this bug.  The symptom
    would be that a device entry in the blacklist might not be matched
    properly if it contained an 8-character vendor name or a 16-character
    model name.  Such entries certainly exist in scsi_static_device_list.
    
    This patch fixes the problem by adding a check for a maximum-length
    string before the '\0' test.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: b704f70ce200 ("SCSI: fix bug in scsi_dev_info_list matching")
    Tested-by: Wilfried Klaebe &lt;linux-kernel@lebenslange-mailadresse.de&gt;
    CC: &lt;stable@vger.kernel.org&gt; # v4.4+
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c
index ff41c310c900..eaccd651ccda 100644
--- a/drivers/scsi/scsi_devinfo.c
+++ b/drivers/scsi/scsi_devinfo.c
@@ -429,7 +429,7 @@ static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
 	 * here, and we don't know what device it is
 	 * trying to work with, leave it as-is.
 	 */
-	vmax = 8;	/* max length of vendor */
+	vmax = sizeof(devinfo-&gt;vendor);
 	vskip = vendor;
 	while (vmax &gt; 0 &amp;&amp; *vskip == ' ') {
 		vmax--;
@@ -439,7 +439,7 @@ static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
 	while (vmax &gt; 0 &amp;&amp; vskip[vmax - 1] == ' ')
 		--vmax;
 
-	mmax = 16;	/* max length of model */
+	mmax = sizeof(devinfo-&gt;model);
 	mskip = model;
 	while (mmax &gt; 0 &amp;&amp; *mskip == ' ') {
 		mmax--;
@@ -455,10 +455,12 @@ static struct scsi_dev_info_list *scsi_dev_info_list_find(const char *vendor,
 			 * Behave like the older version of get_device_flags.
 			 */
 			if (memcmp(devinfo-&gt;vendor, vskip, vmax) ||
-					devinfo-&gt;vendor[vmax])
+					(vmax &lt; sizeof(devinfo-&gt;vendor) &amp;&amp;
+						devinfo-&gt;vendor[vmax]))
 				continue;
 			if (memcmp(devinfo-&gt;model, mskip, mmax) ||
-					devinfo-&gt;model[mmax])
+					(mmax &lt; sizeof(devinfo-&gt;model) &amp;&amp;
+						devinfo-&gt;model[mmax]))
 				continue;
 			return devinfo;
 		} else {</pre>
    <div class="pagination">
        <a href='2_22.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><span>[23]</span><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_24.html'>Next&gt;&gt;</a>
    <div>
</body>
