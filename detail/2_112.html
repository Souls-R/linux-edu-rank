<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_111.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><span>[112]</span><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_113.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit e7b0d26a86943370c04d6833c6edba2a72a6e240
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 15 15:51:28 2007 -0400

    [PATCH] sysfs: reinstate exclusion between method calls and attribute unregistration
    
    This patch (as869) reinstates the mutual exclusion between sysfs
    attribute method calls and attribute unregistration.  The
    previously-reported deadlocks have been fixed, and this exclusion is
    by far the simplest way to avoid races during driver unbinding.
    
    The check for orphaned read-buffers has been moved down slightly, so
    that the remainder of a partially-read buffer will still be available
    to userspace even after the attribute has been unregistered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Hugh Dickins &lt;hugh@veritas.com&gt;
    Cc: Cornelia Huck &lt;cornelia.huck@de.ibm.com&gt;
    Cc: Oliver Neukum &lt;oneukum@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 1bafdf6e171c..fc4633378dc0 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -168,12 +168,12 @@ sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 	ssize_t retval = 0;
 
 	down(&amp;buffer-&gt;sem);
-	if (buffer-&gt;orphaned) {
-		retval = -ENODEV;
-		goto out;
-	}
 	if (buffer-&gt;needs_read_fill) {
-		if ((retval = fill_read_buffer(file-&gt;f_path.dentry,buffer)))
+		if (buffer-&gt;orphaned)
+			retval = -ENODEV;
+		else
+			retval = fill_read_buffer(file-&gt;f_path.dentry,buffer);
+		if (retval)
 			goto out;
 	}
 	pr_debug("%s: count = %zd, ppos = %lld, buf = %s\n",
diff --git a/fs/sysfs/inode.c b/fs/sysfs/inode.c
index ccb7d722c558..4de5c6b89918 100644
--- a/fs/sysfs/inode.c
+++ b/fs/sysfs/inode.c
@@ -222,13 +222,17 @@ const unsigned char * sysfs_get_name(struct sysfs_dirent *sd)
 
 static inline void orphan_all_buffers(struct inode *node)
 {
-	struct sysfs_buffer_collection *set = node-&gt;i_private;
+	struct sysfs_buffer_collection *set;
 	struct sysfs_buffer *buf;
 
 	mutex_lock_nested(&amp;node-&gt;i_mutex, I_MUTEX_CHILD);
-	if (node-&gt;i_private) {
-		list_for_each_entry(buf, &amp;set-&gt;associates, associates)
+	set = node-&gt;i_private;
+	if (set) {
+		list_for_each_entry(buf, &amp;set-&gt;associates, associates) {
+			down(&amp;buf-&gt;sem);
 			buf-&gt;orphaned = 1;
+			up(&amp;buf-&gt;sem);
+		}
 	}
 	mutex_unlock(&amp;node-&gt;i_mutex);
 }</pre><hr><pre>commit d9a9cdfb078d755e648d53ec25b7370f84ee5729
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 15 15:50:34 2007 -0400

    [PATCH] sysfs and driver core: add callback helper, used by SCSI and S390
    
    This patch (as868) adds a helper routine for device drivers that need
    to set up a callback to perform some action in a different process's
    context.  This is intended for use by attribute methods that want to
    unregister themselves or their parent device.  Attribute method calls
    are mutually exclusive with unregistration, so such actions cannot be
    taken directly.
    
    Two attribute methods are converted to use the new helper routine: one
    for SCSI device deletion and one for System/390 ccwgroup devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Hugh Dickins &lt;hugh@veritas.com&gt;
    Cc: Cornelia Huck &lt;cornelia.huck@de.ibm.com&gt;
    Cc: Oliver Neukum &lt;oneukum@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index f191afe62b4d..ad0f4a2f25c4 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -407,6 +407,35 @@ void device_remove_bin_file(struct device *dev, struct bin_attribute *attr)
 }
 EXPORT_SYMBOL_GPL(device_remove_bin_file);
 
+/**
+ * device_schedule_callback - helper to schedule a callback for a device
+ * @dev: device.
+ * @func: callback function to invoke later.
+ *
+ * Attribute methods must not unregister themselves or their parent device
+ * (which would amount to the same thing).  Attempts to do so will deadlock,
+ * since unregistration is mutually exclusive with driver callbacks.
+ *
+ * Instead methods can call this routine, which will attempt to allocate
+ * and schedule a workqueue request to call back @func with @dev as its
+ * argument in the workqueue's process context.  @dev will be pinned until
+ * @func returns.
+ *
+ * Returns 0 if the request was submitted, -ENOMEM if storage could not
+ * be allocated.
+ *
+ * NOTE: This routine won't work if CONFIG_SYSFS isn't set!  It uses an
+ * underlying sysfs routine (since it is intended for use by attribute
+ * methods), and if sysfs isn't available you'll get nothing but -ENOSYS.
+ */
+int device_schedule_callback(struct device *dev,
+		void (*func)(struct device *))
+{
+	return sysfs_schedule_callback(&amp;dev-&gt;kobj,
+			(void (*)(void *)) func, dev);
+}
+EXPORT_SYMBOL_GPL(device_schedule_callback);
+
 static void klist_children_get(struct klist_node *n)
 {
 	struct device *dev = container_of(n, struct device, knode_parent);
diff --git a/drivers/s390/cio/ccwgroup.c b/drivers/s390/cio/ccwgroup.c
index d48e3ca4752c..5aeb68e732b0 100644
--- a/drivers/s390/cio/ccwgroup.c
+++ b/drivers/s390/cio/ccwgroup.c
@@ -71,19 +71,31 @@ __ccwgroup_remove_symlinks(struct ccwgroup_device *gdev)
  * Provide an 'ungroup' attribute so the user can remove group devices no
  * longer needed or accidentially created. Saves memory :)
  */
+static void ccwgroup_ungroup_callback(struct device *dev)
+{
+	struct ccwgroup_device *gdev = to_ccwgroupdev(dev);
+
+	__ccwgroup_remove_symlinks(gdev);
+	device_unregister(dev);
+}
+
 static ssize_t
 ccwgroup_ungroup_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct ccwgroup_device *gdev;
+	int rc;
 
 	gdev = to_ccwgroupdev(dev);
 
 	if (gdev-&gt;state != CCWGROUP_OFFLINE)
 		return -EINVAL;
 
-	__ccwgroup_remove_symlinks(gdev);
-	device_unregister(dev);
-
+	/* Note that we cannot unregister the device from one of its
+	 * attribute methods, so we have to use this roundabout approach.
+	 */
+	rc = device_schedule_callback(dev, ccwgroup_ungroup_callback);
+	if (rc)
+		count = rc;
 	return count;
 }
 
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index c275dcac3f18..939de0de18bc 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -452,10 +452,22 @@ store_rescan_field (struct device *dev, struct device_attribute *attr, const cha
 }
 static DEVICE_ATTR(rescan, S_IWUSR, NULL, store_rescan_field);
 
+static void sdev_store_delete_callback(struct device *dev)
+{
+	scsi_remove_device(to_scsi_device(dev));
+}
+
 static ssize_t sdev_store_delete(struct device *dev, struct device_attribute *attr, const char *buf,
 				 size_t count)
 {
-	scsi_remove_device(to_scsi_device(dev));
+	int rc;
+
+	/* An attribute cannot be unregistered by one of its own methods,
+	 * so we have to use this roundabout approach.
+	 */
+	rc = device_schedule_callback(dev, sdev_store_delete_callback);
+	if (rc)
+		count = rc;
 	return count;
 };
 static DEVICE_ATTR(delete, S_IWUSR, NULL, sdev_store_delete);
diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 8d4d839a9d88..1bafdf6e171c 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -629,6 +629,60 @@ void sysfs_remove_file_from_group(struct kobject *kobj,
 }
 EXPORT_SYMBOL_GPL(sysfs_remove_file_from_group);
 
+struct sysfs_schedule_callback_struct {
+	struct kobject 		*kobj;
+	void			(*func)(void *);
+	void			*data;
+	struct work_struct	work;
+};
+
+static void sysfs_schedule_callback_work(struct work_struct *work)
+{
+	struct sysfs_schedule_callback_struct *ss = container_of(work,
+			struct sysfs_schedule_callback_struct, work);
+
+	(ss-&gt;func)(ss-&gt;data);
+	kobject_put(ss-&gt;kobj);
+	kfree(ss);
+}
+
+/**
+ * sysfs_schedule_callback - helper to schedule a callback for a kobject
+ * @kobj: object we're acting for.
+ * @func: callback function to invoke later.
+ * @data: argument to pass to @func.
+ *
+ * sysfs attribute methods must not unregister themselves or their parent
+ * kobject (which would amount to the same thing).  Attempts to do so will
+ * deadlock, since unregistration is mutually exclusive with driver
+ * callbacks.
+ *
+ * Instead methods can call this routine, which will attempt to allocate
+ * and schedule a workqueue request to call back @func with @data as its
+ * argument in the workqueue's process context.  @kobj will be pinned
+ * until @func returns.
+ *
+ * Returns 0 if the request was submitted, -ENOMEM if storage could not
+ * be allocated.
+ */
+int sysfs_schedule_callback(struct kobject *kobj, void (*func)(void *),
+		void *data)
+{
+	struct sysfs_schedule_callback_struct *ss;
+
+	ss = kmalloc(sizeof(*ss), GFP_KERNEL);
+	if (!ss)
+		return -ENOMEM;
+	kobject_get(kobj);
+	ss-&gt;kobj = kobj;
+	ss-&gt;func = func;
+	ss-&gt;data = data;
+	INIT_WORK(&amp;ss-&gt;work, sysfs_schedule_callback_work);
+	schedule_work(&amp;ss-&gt;work);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sysfs_schedule_callback);
+
 
 EXPORT_SYMBOL_GPL(sysfs_create_file);
 EXPORT_SYMBOL_GPL(sysfs_remove_file);
diff --git a/include/linux/device.h b/include/linux/device.h
index 39a3199a826d..caad9bba9652 100644
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@ -353,6 +353,8 @@ extern int __must_check device_create_bin_file(struct device *dev,
 					       struct bin_attribute *attr);
 extern void device_remove_bin_file(struct device *dev,
 				   struct bin_attribute *attr);
+extern int device_schedule_callback(struct device *dev,
+		void (*func)(struct device *));
 
 /* device resource management */
 typedef void (*dr_release_t)(struct device *dev, void *res);
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index 523405e1e1f6..0544edda7168 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -78,6 +78,9 @@ struct sysfs_ops {
 
 #ifdef CONFIG_SYSFS
 
+extern int sysfs_schedule_callback(struct kobject *kobj,
+		void (*func)(void *), void *data);
+
 extern int __must_check
 sysfs_create_dir(struct kobject *, struct dentry *);
 
@@ -132,6 +135,12 @@ extern int __must_check sysfs_init(void);
 
 #else /* CONFIG_SYSFS */
 
+static inline int sysfs_schedule_callback(struct kobject *kobj,
+		void (*func)(void *), void *data)
+{
+	return -ENOSYS;
+}
+
 static inline int sysfs_create_dir(struct kobject * k, struct dentry *shadow)
 {
 	return 0;</pre><hr><pre>commit 88018158d1253ab4868a2f9204cc390c711fd9b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 26 17:16:06 2007 -0500

    UHCI: fix port resume problem
    
    This patch (as863) fixes a problem encountered sometimes when resuming
    a port on a UHCI controller.  The hardware may turn off the
    Resume-Detect bit before turning off the Suspend bit, leading usbcore
    to think that the port is still suspended and the resume has failed.
    The patch makes uhci_finish_suspend() wait until both bits are safely
    off.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index bacc25c53ba3..8e4427aebb14 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -33,6 +33,9 @@ static __u8 root_hub_hub_des[] =
 /* status change bits:  nonzero writes will clear */
 #define RWC_BITS	(USBPORTSC_OCC | USBPORTSC_PEC | USBPORTSC_CSC)
 
+/* suspend/resume bits: port suspended or port resuming */
+#define SUSPEND_BITS	(USBPORTSC_SUSP | USBPORTSC_RD)
+
 /* A port that either is connected or has a changed-bit set will prevent
  * us from AUTO_STOPPING.
  */
@@ -96,8 +99,8 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 	int status;
 	int i;
 
-	if (inw(port_addr) &amp; (USBPORTSC_SUSP | USBPORTSC_RD)) {
-		CLR_RH_PORTSTAT(USBPORTSC_SUSP | USBPORTSC_RD);
+	if (inw(port_addr) &amp; SUSPEND_BITS) {
+		CLR_RH_PORTSTAT(SUSPEND_BITS);
 		if (test_bit(port, &amp;uhci-&gt;resuming_ports))
 			set_bit(port, &amp;uhci-&gt;port_c_suspend);
 
@@ -107,7 +110,7 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 		 * Experiments show that some controllers take longer, so
 		 * we'll poll for completion. */
 		for (i = 0; i &lt; 10; ++i) {
-			if (!(inw(port_addr) &amp; USBPORTSC_RD))
+			if (!(inw(port_addr) &amp; SUSPEND_BITS))
 				break;
 			udelay(1);
 		}
@@ -289,7 +292,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 			wPortStatus |= USB_PORT_STAT_CONNECTION;
 		if (status &amp; USBPORTSC_PE) {
 			wPortStatus |= USB_PORT_STAT_ENABLE;
-			if (status &amp; (USBPORTSC_SUSP | USBPORTSC_RD))
+			if (status &amp; SUSPEND_BITS)
 				wPortStatus |= USB_PORT_STAT_SUSPEND;
 		}
 		if (status &amp; USBPORTSC_OC)</pre><hr><pre>commit 97b9eb91dc131a10342da1f604e5bd8b1316abdb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 26 14:56:14 2007 -0500

    USB: set the correct interval for interrupt URBs
    
    This patch (as862) fixes a couple of bugs in the way usbcore handles
    intervals for interrupt URBs.  usb_interrupt_msg (and usb_bulk_msg for
    backward compatibility) don't set the interval correctly for
    high-speed devices.  proc_do_submiturb() doesn't set it correctly when
    a bulk URB is submitted to an interrupt endpoint.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 274f14f1633e..36e7a843bf91 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -912,7 +912,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	struct async *as;
 	struct usb_ctrlrequest *dr = NULL;
 	unsigned int u, totlen, isofrmlen;
-	int ret, interval = 0, ifnum = -1;
+	int ret, ifnum = -1;
 
 	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP|USBDEVFS_URB_SHORT_NOT_OK|
 			   URB_NO_FSBR|URB_ZERO_PACKET))
@@ -992,7 +992,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
 				!= USB_ENDPOINT_XFER_ISOC)
 			return -EINVAL;
-		interval = 1 &lt;&lt; min (15, ep-&gt;desc.bInterval - 1);
 		isofrmlen = sizeof(struct usbdevfs_iso_packet_desc) * uurb-&gt;number_of_packets;
 		if (!(isopkt = kmalloc(isofrmlen, GFP_KERNEL)))
 			return -ENOMEM;
@@ -1021,10 +1020,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK)
 				!= USB_ENDPOINT_XFER_INT)
 			return -EINVAL;
-		if (ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)
-			interval = 1 &lt;&lt; min (15, ep-&gt;desc.bInterval - 1);
-		else
-			interval = ep-&gt;desc.bInterval;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
 		if (!access_ok((uurb-&gt;endpoint &amp; USB_DIR_IN) ? VERIFY_WRITE : VERIFY_READ, uurb-&gt;buffer, uurb-&gt;buffer_length))
@@ -1053,7 +1048,11 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	as-&gt;urb-&gt;setup_packet = (unsigned char*)dr;
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = uurb-&gt;number_of_packets;
-	as-&gt;urb-&gt;interval = interval;
+	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||
+			ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)
+		as-&gt;urb-&gt;interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);
+	else
+		as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;
         as-&gt;urb-&gt;context = as;
         as-&gt;urb-&gt;complete = async_completed;
 	for (totlen = u = 0; u &lt; uurb-&gt;number_of_packets; u++) {
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 2f17468b5c1e..217a3d6d0a06 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -221,10 +221,15 @@ int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,
 
 	if ((ep-&gt;desc.bmAttributes &amp; USB_ENDPOINT_XFERTYPE_MASK) ==
 			USB_ENDPOINT_XFER_INT) {
+		int interval;
+
+		if (usb_dev-&gt;speed == USB_SPEED_HIGH)
+			interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);
+		else
+			interval = ep-&gt;desc.bInterval;
 		pipe = (pipe &amp; ~(3 &lt;&lt; 30)) | (PIPE_INTERRUPT &lt;&lt; 30);
 		usb_fill_int_urb(urb, usb_dev, pipe, data, len,
-				usb_api_blocking_completion, NULL,
-				ep-&gt;desc.bInterval);
+				usb_api_blocking_completion, NULL, interval);
 	} else
 		usb_fill_bulk_urb(urb, usb_dev, pipe, data, len,
 				usb_api_blocking_completion, NULL);</pre><hr><pre>commit 19c262391c4741b012a5031fc438fb694e77c385
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:03:32 2007 -0500

    USB: export autosuspend delay in sysfs
    
    This patch (as861) adds sysfs attributes to expose the autosuspend
    delay value for each USB device.  If the user changes the delay from 0
    (no autosuspend) to a positive value, an autosuspend is attempted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index a420d72a0254..9e3e943f313c 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1224,6 +1224,26 @@ void usb_autosuspend_device(struct usb_device *udev)
 	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
 
+/**
+ * usb_try_autosuspend_device - attempt an autosuspend of a USB device and its interfaces
+ * @udev: the usb_device to autosuspend
+ *
+ * This routine should be called when a core subsystem thinks @udev may
+ * be ready to autosuspend.
+ *
+ * @udev's usage counter left unchanged.  If it or any of the usage counters
+ * for an active interface is greater than 0, or autosuspend is not allowed
+ * for any other reason, no autosuspend request will be queued.
+ *
+ * This routine can run only in process context.
+ */
+void usb_try_autosuspend_device(struct usb_device *udev)
+{
+	usb_autopm_do_device(udev, 0);
+	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+	// 		__FUNCTION__, udev-&gt;pm_usage_cnt);
+}
+
 /**
  * usb_autoresume_device - immediately autoresume a USB device and its interfaces
  * @udev: the usb_device to autoresume
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index cad4fb323f6c..311d5df80386 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -158,6 +158,65 @@ show_quirks(struct device *dev, struct device_attribute *attr, char *buf)
 }
 static DEVICE_ATTR(quirks, S_IRUGO, show_quirks, NULL);
 
+#ifdef	CONFIG_USB_SUSPEND
+
+static ssize_t
+show_autosuspend(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev = to_usb_device(dev);
+
+	return sprintf(buf, "%u\n", udev-&gt;autosuspend_delay / HZ);
+}
+
+static ssize_t
+set_autosuspend(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct usb_device *udev = to_usb_device(dev);
+	unsigned value, old;
+
+	if (sscanf(buf, "%u", &amp;value) != 1 || value &gt;= INT_MAX/HZ)
+		return -EINVAL;
+	value *= HZ;
+
+	old = udev-&gt;autosuspend_delay;
+	udev-&gt;autosuspend_delay = value;
+	if (value &gt; 0 &amp;&amp; old == 0)
+		usb_try_autosuspend_device(udev);
+
+	return count;
+}
+
+static DEVICE_ATTR(autosuspend, S_IRUGO | S_IWUSR,
+		show_autosuspend, set_autosuspend);
+
+static char power_group[] = "power";
+
+static int add_power_attributes(struct device *dev)
+{
+	int rc = 0;
+
+	if (is_usb_device(dev))
+		rc = sysfs_add_file_to_group(&amp;dev-&gt;kobj,
+				&amp;dev_attr_autosuspend.attr,
+				power_group);
+	return rc;
+}
+
+static void remove_power_attributes(struct device *dev)
+{
+	sysfs_remove_file_from_group(&amp;dev-&gt;kobj,
+			&amp;dev_attr_autosuspend.attr,
+			power_group);
+}
+
+#else
+
+#define add_power_attributes(dev)	0
+#define remove_power_attributes(dev)	do {} while (0)
+
+#endif	/* CONFIG_USB_SUSPEND */
+
 /* Descriptor fields */
 #define usb_descriptor_attr_le16(field, format_string)			\
 static ssize_t								\
@@ -230,6 +289,10 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 	if (retval)
 		return retval;
 
+	retval = add_power_attributes(dev);
+	if (retval)
+		goto error;
+
 	if (udev-&gt;manufacturer) {
 		retval = device_create_file(dev, &amp;dev_attr_manufacturer);
 		if (retval)
@@ -262,6 +325,7 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	device_remove_file(dev, &amp;dev_attr_manufacturer);
 	device_remove_file(dev, &amp;dev_attr_product);
 	device_remove_file(dev, &amp;dev_attr_serial);
+	remove_power_attributes(dev);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 }
 
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index b0a35f45b099..08b5a04e3755 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -66,11 +66,13 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 #ifdef CONFIG_USB_SUSPEND
 
 extern void usb_autosuspend_device(struct usb_device *udev);
+extern void usb_try_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 
 #else
 
-#define usb_autosuspend_device(udev)	do {} while (0)
+#define usb_autosuspend_device(udev)		do {} while (0)
+#define usb_try_autosuspend_device(udev)	do {} while (0)
 static inline int usb_autoresume_device(struct usb_device *udev)
 {
 	return 0;</pre><hr><pre>commit dfa87c824a9a5430008acd1ed2e8111ed164fcbe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:02:44 2007 -0500

    sysfs: allow attributes to be added to groups
    
    This patch (as860) adds two new sysfs routines:
    sysfs_add_file_to_group() and sysfs_remove_file_from_group().
    A later patch adds code that uses the new routines.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Maneesh Soni &lt;maneesh@in.ibm.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c
index 98b0910ad80c..8d4d839a9d88 100644
--- a/fs/sysfs/file.c
+++ b/fs/sysfs/file.c
@@ -501,6 +501,30 @@ int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)
 }
 
 
+/**
+ * sysfs_add_file_to_group - add an attribute file to a pre-existing group.
+ * @kobj: object we're acting for.
+ * @attr: attribute descriptor.
+ * @group: group name.
+ */
+int sysfs_add_file_to_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group)
+{
+	struct dentry *dir;
+	int error;
+
+	dir = lookup_one_len(group, kobj-&gt;dentry, strlen(group));
+	if (IS_ERR(dir))
+		error = PTR_ERR(dir);
+	else {
+		error = sysfs_add_file(dir, attr, SYSFS_KOBJ_ATTR);
+		dput(dir);
+	}
+	return error;
+}
+EXPORT_SYMBOL_GPL(sysfs_add_file_to_group);
+
+
 /**
  * sysfs_update_file - update the modified timestamp on an object attribute.
  * @kobj: object we're acting for.
@@ -586,6 +610,26 @@ void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr)
 }
 
 
+/**
+ * sysfs_remove_file_from_group - remove an attribute file from a group.
+ * @kobj: object we're acting for.
+ * @attr: attribute descriptor.
+ * @group: group name.
+ */
+void sysfs_remove_file_from_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group)
+{
+	struct dentry *dir;
+
+	dir = lookup_one_len(group, kobj-&gt;dentry, strlen(group));
+	if (!IS_ERR(dir)) {
+		sysfs_hash_and_remove(dir, attr-&gt;name);
+		dput(dir);
+	}
+}
+EXPORT_SYMBOL_GPL(sysfs_remove_file_from_group);
+
+
 EXPORT_SYMBOL_GPL(sysfs_create_file);
 EXPORT_SYMBOL_GPL(sysfs_remove_file);
 EXPORT_SYMBOL_GPL(sysfs_update_file);
diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h
index 192de3afa96b..f45450b295c0 100644
--- a/include/linux/sysfs.h
+++ b/include/linux/sysfs.h
@@ -126,6 +126,11 @@ void sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);
 int __must_check sysfs_create_group(struct kobject *,
 					const struct attribute_group *);
 void sysfs_remove_group(struct kobject *, const struct attribute_group *);
+int sysfs_add_file_to_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group);
+void sysfs_remove_file_from_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group);
+
 void sysfs_notify(struct kobject * k, char *dir, char *attr);
 
 
@@ -210,6 +215,18 @@ static inline void sysfs_remove_group(struct kobject * k, const struct attribute
 	;
 }
 
+static inline int sysfs_add_file_to_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group)
+{
+	return 0;
+}
+
+static inline void sysfs_remove_file_from_group(struct kobject *kobj,
+		const struct attribute *attr, const char *group);
+{
+	;
+}
+
 static inline void sysfs_notify(struct kobject * k, char *dir, char *attr)
 {
 }</pre><hr><pre>commit b5e795f8df42936590ba9c606edc715fe3593284
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 15:00:53 2007 -0500

    USB: make autosuspend delay a module parameter
    
    This patch (as859) makes the default USB autosuspend delay a module
    parameter of usbcore.  By setting the delay value at boot time, users
    will be able to prevent the system from autosuspending devices which
    for some reason can't handle it.
    
    The patch also stores the autosuspend delay as a per-device value.  A
    later patch will allow the user to change the value, tailoring the
    delay for each individual device.  A delay value of 0 will prevent
    autosuspend.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index c479d30eeaa3..03eb5ed503f7 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1758,6 +1758,13 @@ and is between 256 and 4096 characters. It is defined in the file
 			Note that genuine overcurrent events won't be
 			reported either.
 
+	usbcore.autosuspend=
+			[USB] The autosuspend time delay (in seconds) used
+			for newly-detected USB devices (default 2).  This
+			is the time required before an idle device will be
+			autosuspended.  Devices for which the delay is set
+			to 0 won't be autosuspended at all.
+
 	usbhid.mousepoll=
 			[USBHID] The interval which mice are to be polled at.
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index f9196a0a9412..a420d72a0254 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -963,12 +963,16 @@ static int autosuspend_check(struct usb_device *udev)
 	int			i;
 	struct usb_interface	*intf;
 
-	/* For autosuspend, fail fast if anything is in use.
-	 * Also fail if any interfaces require remote wakeup but it
-	 * isn't available. */
+	/* For autosuspend, fail fast if anything is in use or autosuspend
+	 * is disabled.  Also fail if any interfaces require remote wakeup
+	 * but it isn't available.
+	 */
 	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 	if (udev-&gt;pm_usage_cnt &gt; 0)
 		return -EBUSY;
+	if (!udev-&gt;autosuspend_delay)
+		return -EPERM;
+
 	if (udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
 			intf = udev-&gt;actconfig-&gt;interface[i];
@@ -991,7 +995,7 @@ static int autosuspend_check(struct usb_device *udev)
 
 #define autosuspend_check(udev)		0
 
-#endif
+#endif	/* CONFIG_USB_SUSPEND */
 
 /**
  * usb_suspend_both - suspend a USB device and its interfaces
@@ -1186,7 +1190,7 @@ static int usb_autopm_do_device(struct usb_device *udev, int inc_usage_cnt)
 			udev-&gt;pm_usage_cnt -= inc_usage_cnt;
 	} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
 		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				USB_AUTOSUSPEND_DELAY);
+				udev-&gt;autosuspend_delay);
 	usb_pm_unlock(udev);
 	return status;
 }
@@ -1270,7 +1274,7 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 				intf-&gt;pm_usage_cnt -= inc_usage_cnt;
 		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
 			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-					USB_AUTOSUSPEND_DELAY);
+					udev-&gt;autosuspend_delay);
 	}
 	usb_pm_unlock(udev);
 	return status;
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index ea0e48e9f611..0e5c646cb4f6 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -39,8 +39,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 
 static void usb_autosuspend_quirk(struct usb_device *udev)
 {
-	/* unbalanced resume to prevent autosuspends */
-	usb_autoresume_device(udev);
+#ifdef	CONFIG_USB_SUSPEND
+	/* disable autosuspend, but allow the user to re-enable it via sysfs */
+	udev-&gt;autosuspend_delay = 0;
+#endif
 }
 
 static const struct usb_device_id *find_id(struct usb_device *udev)
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 3db721cd557a..54b42ce311c1 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -22,6 +22,7 @@
  */
 
 #include &lt;linux/module.h&gt;
+#include &lt;linux/moduleparam.h&gt;
 #include &lt;linux/string.h&gt;
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/slab.h&gt;
@@ -50,6 +51,16 @@ static int nousb;	/* Disable USB when built into kernel image */
 
 struct workqueue_struct *ksuspend_usb_wq;	/* For autosuspend */
 
+#ifdef	CONFIG_USB_SUSPEND
+static int usb_autosuspend_delay = 2;		/* Default delay value,
+						 * in seconds */
+module_param_named(autosuspend, usb_autosuspend_delay, uint, 0644);
+MODULE_PARM_DESC(autosuspend, "default autosuspend delay");
+
+#else
+#define usb_autosuspend_delay		0
+#endif
+
 
 /**
  * usb_ifnum_to_if - get the interface object with a given interface number
@@ -306,6 +317,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 #ifdef	CONFIG_PM
 	mutex_init(&amp;dev-&gt;pm_mutex);
 	INIT_DELAYED_WORK(&amp;dev-&gt;autosuspend, usb_autosuspend_work);
+	dev-&gt;autosuspend_delay = usb_autosuspend_delay * HZ;
 #endif
 	return dev;
 }
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 045cbd111887..b0a35f45b099 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -65,8 +65,6 @@ static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #ifdef CONFIG_USB_SUSPEND
 
-#define USB_AUTOSUSPEND_DELAY	(HZ*2)
-
 extern void usb_autosuspend_device(struct usb_device *udev);
 extern int usb_autoresume_device(struct usb_device *udev);
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 37e522eba47f..87dc75a6cee1 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -389,10 +389,13 @@ struct usb_device {
 
 	int pm_usage_cnt;		/* usage counter for autosuspend */
 	u32 quirks;			/* quirks of the whole device */
+
 #ifdef CONFIG_PM
 	struct delayed_work autosuspend; /* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
 
+	unsigned autosuspend_delay;	/* in jiffies */
+
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */
 #endif</pre><hr><pre>commit aa084f3efe5fb7e9c0d5b54ce704f0de69bbf27c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 20 14:59:59 2007 -0500

    USB: minor cleanups for sysfs.c
    
    This patch (as858) makes some minor cleanups to sysfs.c in usbcore.
    Unnecessary tests are removed and a few temp variables are added.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 8f5a764057cd..cad4fb323f6c 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -250,10 +250,7 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 		goto error;
 	return 0;
 error:
-	usb_remove_ep_files(&amp;udev-&gt;ep0);
-	device_remove_file(dev, &amp;dev_attr_manufacturer);
-	device_remove_file(dev, &amp;dev_attr_product);
-	device_remove_file(dev, &amp;dev_attr_serial);
+	usb_remove_sysfs_dev_files(udev);
 	return retval;
 }
 
@@ -262,14 +259,10 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	struct device *dev = &amp;udev-&gt;dev;
 
 	usb_remove_ep_files(&amp;udev-&gt;ep0);
+	device_remove_file(dev, &amp;dev_attr_manufacturer);
+	device_remove_file(dev, &amp;dev_attr_product);
+	device_remove_file(dev, &amp;dev_attr_serial);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
-
-	if (udev-&gt;manufacturer)
-		device_remove_file(dev, &amp;dev_attr_manufacturer);
-	if (udev-&gt;product)
-		device_remove_file(dev, &amp;dev_attr_product);
-	if (udev-&gt;serial)
-		device_remove_file(dev, &amp;dev_attr_serial);
 }
 
 /* Interface fields */
@@ -373,33 +366,28 @@ static inline void usb_remove_intf_ep_files(struct usb_interface *intf)
 
 int usb_create_sysfs_intf_files(struct usb_interface *intf)
 {
+	struct device *dev = &amp;intf-&gt;dev;
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int retval;
 
-	retval = sysfs_create_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
+	retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 	if (retval)
-		goto error;
+		return retval;
 
 	if (alt-&gt;string == NULL)
 		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
 	if (alt-&gt;string)
-		retval = device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
+		retval = device_create_file(dev, &amp;dev_attr_interface);
 	usb_create_intf_ep_files(intf, udev);
 	return 0;
-error:
-	if (alt-&gt;string)
-		device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
-	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
-	usb_remove_intf_ep_files(intf);
-	return retval;
 }
 
 void usb_remove_sysfs_intf_files(struct usb_interface *intf)
 {
-	usb_remove_intf_ep_files(intf);
-	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;intf_attr_grp);
+	struct device *dev = &amp;intf-&gt;dev;
 
-	if (intf-&gt;cur_altsetting-&gt;string)
-		device_remove_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
+	usb_remove_intf_ep_files(intf);
+	device_remove_file(dev, &amp;dev_attr_interface);
+	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 }</pre><hr><pre>commit 17230acdc71137622ca7dfd789b3944c75d39404
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 19 15:52:45 2007 -0500

    UHCI: Eliminate asynchronous skeleton Queue Headers
    
    This patch (as856) attempts to improve the performance of uhci-hcd by
    removing the asynchronous skeleton Queue Headers.  They don't contain
    any useful information but the controller has to read through them at
    least once every millisecond, incurring a non-zero DMA overhead.
    
    Now all the asynchronous queues are combined, along with the period-1
    interrupt queue, into a single list with a single skeleton QH.  The
    start of the low-speed control, full-speed control, and bulk sublists
    is determined by linear search.  Since there should rarely be more
    than a couple of QHs in the list, the searches should incur a much
    smaller total load than keeping the skeleton QHs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index a0677133577b..8d24d3dc0a61 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -220,16 +220,6 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	return out - buf;
 }
 
-static const char * const qh_names[] = {
-  "skel_unlink_qh", "skel_iso_qh",
-  "skel_int128_qh", "skel_int64_qh",
-  "skel_int32_qh", "skel_int16_qh",
-  "skel_int8_qh", "skel_int4_qh",
-  "skel_int2_qh", "skel_int1_qh",
-  "skel_ls_control_qh", "skel_fs_control_qh",
-  "skel_bulk_qh", "skel_term_qh"
-};
-
 static int uhci_show_sc(int port, unsigned short status, char *buf, int len)
 {
 	char *out = buf;
@@ -352,6 +342,12 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	struct uhci_td *td;
 	struct list_head *tmp, *head;
 	int nframes, nerrs;
+	__le32 link;
+
+	static const char * const qh_names[] = {
+		"unlink", "iso", "int128", "int64", "int32", "int16",
+		"int8", "int4", "int2", "async", "term"
+	};
 
 	out += uhci_show_root_hub_state(uhci, out, len - (out - buf));
 	out += sprintf(out, "HC status\n");
@@ -374,7 +370,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 	nframes = 10;
 	nerrs = 0;
 	for (i = 0; i &lt; UHCI_NUMFRAMES; ++i) {
-		__le32 link, qh_dma;
+		__le32 qh_dma;
 
 		j = 0;
 		td = uhci-&gt;frame_cpu[i];
@@ -430,23 +426,21 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; ++i) {
 		int cnt = 0;
+		__le32 fsbr_link = 0;
 
 		qh = uhci-&gt;skelqh[i];
-		out += sprintf(out, "- %s\n", qh_names[i]); \
+		out += sprintf(out, "- skel_%s_qh\n", qh_names[i]); \
 		out += uhci_show_qh(qh, out, len - (out - buf), 4);
 
 		/* Last QH is the Terminating QH, it's different */
-		if (i == UHCI_NUM_SKELQH - 1) {
-			if (qh-&gt;link != UHCI_PTR_TERM)
-				out += sprintf(out, "    bandwidth reclamation on!\n");
-
+		if (i == SKEL_TERM) {
 			if (qh_element(qh) != LINK_TO_TD(uhci-&gt;term_td))
 				out += sprintf(out, "    skel_term_qh element is not set to term_td!\n");
-
+			if (link == LINK_TO_QH(uhci-&gt;skel_term_qh))
+				goto check_qh_link;
 			continue;
 		}
 
-		j = (i &lt; 9) ? 9 : i+1;		/* Next skeleton */
 		head = &amp;qh-&gt;node;
 		tmp = head-&gt;next;
 
@@ -456,14 +450,26 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			if (++cnt &lt;= 10)
 				out += uhci_show_qh(qh, out,
 						len - (out - buf), 4);
+			if (!fsbr_link &amp;&amp; qh-&gt;skel &gt;= SKEL_FSBR)
+				fsbr_link = LINK_TO_QH(qh);
 		}
 		if ((cnt -= 10) &gt; 0)
 			out += sprintf(out, "    Skipped %d QHs\n", cnt);
 
-		if (i &gt; 1 &amp;&amp; i &lt; UHCI_NUM_SKELQH - 1) {
-			if (qh-&gt;link != LINK_TO_QH(uhci-&gt;skelqh[j]))
-				out += sprintf(out, "    last QH not linked to next skeleton!\n");
-		}
+		link = UHCI_PTR_TERM;
+		if (i &lt;= SKEL_ISO)
+			;
+		else if (i &lt; SKEL_ASYNC)
+			link = LINK_TO_QH(uhci-&gt;skel_async_qh);
+		else if (!uhci-&gt;fsbr_is_on)
+			;
+		else if (fsbr_link)
+			link = fsbr_link;
+		else
+			link = LINK_TO_QH(uhci-&gt;skel_term_qh);
+check_qh_link:
+		if (qh-&gt;link != link)
+			out += sprintf(out, "    last QH not linked to next skeleton!\n");
 	}
 
 	return out - buf;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 1f0833ab294a..44da4334f1d6 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu
  *
  * Intel documents this fairly well, and as far as I know there
  * are no royalties or anything like that, but even so there are
@@ -107,10 +107,10 @@ static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
 	 * interrupt QHs, which will help spread out bandwidth utilization.
 	 *
 	 * ffs (Find First bit Set) does exactly what we need:
-	 * 1,3,5,...  =&gt; ffs = 0 =&gt; use skel_int2_qh = skelqh[8],
-	 * 2,6,10,... =&gt; ffs = 1 =&gt; use skel_int4_qh = skelqh[7], etc.
+	 * 1,3,5,...  =&gt; ffs = 0 =&gt; use period-2 QH = skelqh[8],
+	 * 2,6,10,... =&gt; ffs = 1 =&gt; use period-4 QH = skelqh[7], etc.
 	 * ffs &gt;= 7 =&gt; not on any high-period queue, so use
-	 *	skel_int1_qh = skelqh[9].
+	 *	period-1 QH = skelqh[9].
 	 * Add in UHCI_NUMFRAMES to insure at least one bit is set.
 	 */
 	skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
@@ -540,16 +540,18 @@ static void uhci_shutdown(struct pci_dev *pdev)
  *
  * The hardware doesn't really know any difference
  * in the queues, but the order does matter for the
- * protocols higher up. The order is:
+ * protocols higher up.  The order in which the queues
+ * are encountered by the hardware is:
  *
- *  - any isochronous events handled before any
+ *  - All isochronous events are handled before any
  *    of the queues. We don't do that here, because
  *    we'll create the actual TD entries on demand.
- *  - The first queue is the interrupt queue.
- *  - The second queue is the control queue, split into low- and full-speed
- *  - The third queue is bulk queue.
- *  - The fourth queue is the bandwidth reclamation queue, which loops back
- *    to the full-speed control queue.
+ *  - The first queue is the high-period interrupt queue.
+ *  - The second queue is the period-1 interrupt and async
+ *    (low-speed control, full-speed control, then bulk) queue.
+ *  - The third queue is the terminating bandwidth reclamation queue,
+ *    which contains no members, loops back to itself, and is present
+ *    only when FSBR is on and there are no full-speed control or bulk QHs.
  */
 static int uhci_start(struct usb_hcd *hcd)
 {
@@ -626,30 +628,18 @@ static int uhci_start(struct usb_hcd *hcd)
 	}
 
 	/*
-	 * 8 Interrupt queues; link all higher int queues to int1,
-	 * then link int1 to control and control to bulk
+	 * 8 Interrupt queues; link all higher int queues to int1 = async
 	 */
-	uhci-&gt;skel_int128_qh-&gt;link =
-			uhci-&gt;skel_int64_qh-&gt;link =
-			uhci-&gt;skel_int32_qh-&gt;link =
-			uhci-&gt;skel_int16_qh-&gt;link =
-			uhci-&gt;skel_int8_qh-&gt;link =
-			uhci-&gt;skel_int4_qh-&gt;link =
-			uhci-&gt;skel_int2_qh-&gt;link = LINK_TO_QH(
-				uhci-&gt;skel_int1_qh);
-
-	uhci-&gt;skel_int1_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_ls_control_qh);
-	uhci-&gt;skel_ls_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
-	uhci-&gt;skel_fs_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_bulk_qh);
-	uhci-&gt;skel_bulk_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
+	for (i = SKEL_ISO + 1; i &lt; SKEL_ASYNC; ++i)
+		uhci-&gt;skelqh[i]-&gt;link = LINK_TO_QH(uhci-&gt;skel_async_qh);
+	uhci-&gt;skel_async_qh-&gt;link = uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
 	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
-		(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
-	uhci-&gt;term_td-&gt;link = LINK_TO_TD(uhci-&gt;term_td);
-
-	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	uhci-&gt;skel_term_qh-&gt;element = LINK_TO_TD(uhci-&gt;term_td);
+			(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
+	uhci-&gt;term_td-&gt;link = UHCI_PTR_TERM;
+	uhci-&gt;skel_async_qh-&gt;element = uhci-&gt;skel_term_qh-&gt;element =
+			LINK_TO_TD(uhci-&gt;term_td);
 
 	/*
 	 * Fill the frame list: make all entries point to the proper
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index a8c256b44d8e..1b3d23406ac4 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -135,7 +135,6 @@ struct uhci_qh {
 	struct usb_host_endpoint *hep;	/* Endpoint information */
 	struct usb_device *udev;
 	struct list_head queue;		/* Queue of urbps for this QH */
-	struct uhci_qh *skel;		/* Skeleton for this QH */
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
 	struct uhci_td *post_td;	/* Last TD completed */
 
@@ -151,6 +150,7 @@ struct uhci_qh {
 
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
+	int skel;			/* Skeleton queue number */
 
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
@@ -276,12 +276,13 @@ static inline u32 td_status(struct uhci_td *td) {
 /*
  * The UHCI driver uses QHs with Interrupt, Control and Bulk URBs for
  * automatic queuing. To make it easy to insert entries into the schedule,
- * we have a skeleton of QHs for each predefined Interrupt latency,
- * low-speed control, full-speed control, bulk, and terminating QH
- * (see explanation for the terminating QH below).
+ * we have a skeleton of QHs for each predefined Interrupt latency.
+ * Asynchronous QHs (low-speed control, full-speed control, and bulk)
+ * go onto the period-1 interrupt list, since they all get accessed on
+ * every frame.
  *
- * When we want to add a new QH, we add it to the end of the list for the
- * skeleton QH.  For instance, the schedule list can look like this:
+ * When we want to add a new QH, we add it to the list starting from the
+ * appropriate skeleton QH.  For instance, the schedule can look like this:
  *
  * skel int128 QH
  * dev 1 interrupt QH
@@ -289,50 +290,47 @@ static inline u32 td_status(struct uhci_td *td) {
  * skel int64 QH
  * skel int32 QH
  * ...
- * skel int1 QH
- * skel low-speed control QH
- * dev 5 control QH
- * skel full-speed control QH
- * skel bulk QH
+ * skel int1 + async QH
+ * dev 5 low-speed control QH
  * dev 1 bulk QH
  * dev 2 bulk QH
- * skel terminating QH
  *
- * The terminating QH is used for 2 reasons:
- * - To place a terminating TD which is used to workaround a PIIX bug
- *   (see Intel errata for explanation), and
- * - To loop back to the full-speed control queue for full-speed bandwidth
- *   reclamation.
+ * There is a special terminating QH used to keep full-speed bandwidth
+ * reclamation active when no full-speed control or bulk QHs are linked
+ * into the schedule.  It has an inactive TD (to work around a PIIX bug,
+ * see the Intel errata) and it points back to itself.
  *
- * There's a special skeleton QH for Isochronous QHs.  It never appears
- * on the schedule, and Isochronous TDs go on the schedule before the
+ * There's a special skeleton QH for Isochronous QHs which never appears
+ * on the schedule.  Isochronous TDs go on the schedule before the
  * the skeleton QHs.  The hardware accesses them directly rather than
  * through their QH, which is used only for bookkeeping purposes.
  * While the UHCI spec doesn't forbid the use of QHs for Isochronous,
  * it doesn't use them either.  And the spec says that queues never
  * advance on an error completion status, which makes them totally
  * unsuitable for Isochronous transfers.
+ *
+ * There's also a special skeleton QH used for QHs which are in the process
+ * of unlinking and so may still be in use by the hardware.  It too never
+ * appears on the schedule.
  */
 
-#define UHCI_NUM_SKELQH		14
-#define skel_unlink_qh		skelqh[0]
-#define skel_iso_qh		skelqh[1]
-#define skel_int128_qh		skelqh[2]
-#define skel_int64_qh		skelqh[3]
-#define skel_int32_qh		skelqh[4]
-#define skel_int16_qh		skelqh[5]
-#define skel_int8_qh		skelqh[6]
-#define skel_int4_qh		skelqh[7]
-#define skel_int2_qh		skelqh[8]
-#define skel_int1_qh		skelqh[9]
-#define skel_ls_control_qh	skelqh[10]
-#define skel_fs_control_qh	skelqh[11]
-#define skel_bulk_qh		skelqh[12]
-#define skel_term_qh		skelqh[13]
-
-/* Find the skelqh entry corresponding to an interval exponent */
-#define UHCI_SKEL_INDEX(exponent)	(9 - exponent)
-
+#define UHCI_NUM_SKELQH		11
+#define SKEL_UNLINK		0
+#define skel_unlink_qh		skelqh[SKEL_UNLINK]
+#define SKEL_ISO		1
+#define skel_iso_qh		skelqh[SKEL_ISO]
+	/* int128, int64, ..., int1 = 2, 3, ..., 9 */
+#define SKEL_INDEX(exponent)	(9 - exponent)
+#define SKEL_ASYNC		9
+#define skel_async_qh		skelqh[SKEL_ASYNC]
+#define SKEL_TERM		10
+#define skel_term_qh		skelqh[SKEL_TERM]
+
+/* The following entries refer to sublists of skel_async_qh */
+#define SKEL_LS_CONTROL		20
+#define SKEL_FS_CONTROL		21
+#define SKEL_FSBR		SKEL_FS_CONTROL
+#define SKEL_BULK		22
 
 /*
  *	The UHCI controller and root hub
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index a0c6bf6128a3..f4ebdb3e488f 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2007 Alan Stern, stern@rowland.harvard.edu
  */
 
 
@@ -45,14 +45,43 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
  */
 static void uhci_fsbr_on(struct uhci_hcd *uhci)
 {
+	struct uhci_qh *fsbr_qh, *lqh, *tqh;
+
 	uhci-&gt;fsbr_is_on = 1;
-	uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
+	lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+			struct uhci_qh, node);
+
+	/* Find the first FSBR QH.  Linear search through the list is
+	 * acceptable because normally FSBR gets turned on as soon as
+	 * one QH needs it. */
+	fsbr_qh = NULL;
+	list_for_each_entry_reverse(tqh, &amp;uhci-&gt;skel_async_qh-&gt;node, node) {
+		if (tqh-&gt;skel &lt; SKEL_FSBR)
+			break;
+		fsbr_qh = tqh;
+	}
+
+	/* No FSBR QH means we must insert the terminating skeleton QH */
+	if (!fsbr_qh) {
+		uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
+		wmb();
+		lqh-&gt;link = uhci-&gt;skel_term_qh-&gt;link;
+
+	/* Otherwise loop the last QH to the first FSBR QH */
+	} else
+		lqh-&gt;link = LINK_TO_QH(fsbr_qh);
 }
 
 static void uhci_fsbr_off(struct uhci_hcd *uhci)
 {
+	struct uhci_qh *lqh;
+
 	uhci-&gt;fsbr_is_on = 0;
-	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+	lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+			struct uhci_qh, node);
+
+	/* End the async list normally and unlink the terminating QH */
+	lqh-&gt;link = uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
 }
 
 static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
@@ -404,12 +433,81 @@ static void uhci_fixup_toggles(struct uhci_qh *qh, int skip_first)
 }
 
 /*
- * Put a QH on the schedule in both hardware and software
+ * Link an Isochronous QH into its skeleton's list
  */
-static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
+static inline void link_iso(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	list_add_tail(&amp;qh-&gt;node, &amp;uhci-&gt;skel_iso_qh-&gt;node);
+
+	/* Isochronous QHs aren't linked by the hardware */
+}
+
+/*
+ * Link a high-period interrupt QH into the schedule at the end of its
+ * skeleton's list
+ */
+static void link_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
 	struct uhci_qh *pqh;
 
+	list_add_tail(&amp;qh-&gt;node, &amp;uhci-&gt;skelqh[qh-&gt;skel]-&gt;node);
+
+	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
+	qh-&gt;link = pqh-&gt;link;
+	wmb();
+	pqh-&gt;link = LINK_TO_QH(qh);
+}
+
+/*
+ * Link a period-1 interrupt or async QH into the schedule at the
+ * correct spot in the async skeleton's list, and update the FSBR link
+ */
+static void link_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct uhci_qh *pqh, *lqh;
+	__le32 link_to_new_qh;
+	__le32 *extra_link = &amp;link_to_new_qh;
+
+	/* Find the predecessor QH for our new one and insert it in the list.
+	 * The list of QHs is expected to be short, so linear search won't
+	 * take too long. */
+	list_for_each_entry_reverse(pqh, &amp;uhci-&gt;skel_async_qh-&gt;node, node) {
+		if (pqh-&gt;skel &lt;= qh-&gt;skel)
+			break;
+	}
+	list_add(&amp;qh-&gt;node, &amp;pqh-&gt;node);
+	qh-&gt;link = pqh-&gt;link;
+
+	link_to_new_qh = LINK_TO_QH(qh);
+
+	/* If this is now the first FSBR QH, take special action */
+	if (uhci-&gt;fsbr_is_on &amp;&amp; pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp;
+			qh-&gt;skel &gt;= SKEL_FSBR) {
+		lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+				struct uhci_qh, node);
+
+		/* If the new QH is also the last one, we must unlink
+		 * the terminating skeleton QH and make the new QH point
+		 * back to itself. */
+		if (qh == lqh) {
+			qh-&gt;link = link_to_new_qh;
+			extra_link = &amp;uhci-&gt;skel_term_qh-&gt;link;
+
+		/* Otherwise the last QH must point to the new QH */
+		} else
+			extra_link = &amp;lqh-&gt;link;
+	}
+
+	/* Link it into the schedule */
+	wmb();
+	*extra_link = pqh-&gt;link = link_to_new_qh;
+}
+
+/*
+ * Put a QH on the schedule in both hardware and software
+ */
+static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
 	WARN_ON(list_empty(&amp;qh-&gt;queue));
 
 	/* Set the element pointer if it isn't set already.
@@ -431,18 +529,64 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		return;
 	qh-&gt;state = QH_STATE_ACTIVE;
 
-	/* Move the QH from its old list to the end of the appropriate
+	/* Move the QH from its old list to the correct spot in the appropriate
 	 * skeleton's list */
 	if (qh == uhci-&gt;next_qh)
 		uhci-&gt;next_qh = list_entry(qh-&gt;node.next, struct uhci_qh,
 				node);
-	list_move_tail(&amp;qh-&gt;node, &amp;qh-&gt;skel-&gt;node);
+	list_del(&amp;qh-&gt;node);
+
+	if (qh-&gt;skel == SKEL_ISO)
+		link_iso(uhci, qh);
+	else if (qh-&gt;skel &lt; SKEL_ASYNC)
+		link_interrupt(uhci, qh);
+	else
+		link_async(uhci, qh);
+}
+
+/*
+ * Unlink a high-period interrupt QH from the schedule
+ */
+static void unlink_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct uhci_qh *pqh;
 
-	/* Link it into the schedule */
 	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
-	qh-&gt;link = pqh-&gt;link;
-	wmb();
-	pqh-&gt;link = LINK_TO_QH(qh);
+	pqh-&gt;link = qh-&gt;link;
+	mb();
+}
+
+/*
+ * Unlink a period-1 interrupt or async QH from the schedule
+ */
+static void unlink_async(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct uhci_qh *pqh, *lqh;
+	__le32 link_to_next_qh = qh-&gt;link;
+
+	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
+
+	/* If this is the first FSBQ QH, take special action */
+	if (uhci-&gt;fsbr_is_on &amp;&amp; pqh-&gt;skel &lt; SKEL_FSBR &amp;&amp;
+			qh-&gt;skel &gt;= SKEL_FSBR) {
+		lqh = list_entry(uhci-&gt;skel_async_qh-&gt;node.prev,
+				struct uhci_qh, node);
+
+		/* If this QH is also the last one, we must link in
+		 * the terminating skeleton QH. */
+		if (qh == lqh) {
+			link_to_next_qh = LINK_TO_QH(uhci-&gt;skel_term_qh);
+			uhci-&gt;skel_term_qh-&gt;link = link_to_next_qh;
+			wmb();
+			qh-&gt;link = link_to_next_qh;
+
+		/* Otherwise the last QH must point to the new first FSBR QH */
+		} else
+			lqh-&gt;link = link_to_next_qh;
+	}
+
+	pqh-&gt;link = link_to_next_qh;
+	mb();
 }
 
 /*
@@ -450,17 +594,18 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
  */
 static void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
-	struct uhci_qh *pqh;
-
 	if (qh-&gt;state == QH_STATE_UNLINKING)
 		return;
 	WARN_ON(qh-&gt;state != QH_STATE_ACTIVE || !qh-&gt;udev);
 	qh-&gt;state = QH_STATE_UNLINKING;
 
 	/* Unlink the QH from the schedule and record when we did it */
-	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
-	pqh-&gt;link = qh-&gt;link;
-	mb();
+	if (qh-&gt;skel == SKEL_ISO)
+		;
+	else if (qh-&gt;skel &lt; SKEL_ASYNC)
+		unlink_interrupt(uhci, qh);
+	else
+		unlink_async(uhci, qh);
 
 	uhci_get_current_frame_number(uhci);
 	qh-&gt;unlink_frame = uhci-&gt;frame_number;
@@ -696,6 +841,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	dma_addr_t data = urb-&gt;transfer_dma;
 	__le32 *plink;
 	struct urb_priv *urbp = urb-&gt;hcpriv;
+	int skel;
 
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP;
@@ -796,11 +942,13 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * isn't in the CONFIGURED state. */
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW ||
 			urb-&gt;dev-&gt;state != USB_STATE_CONFIGURED)
-		qh-&gt;skel = uhci-&gt;skel_ls_control_qh;
+		skel = SKEL_LS_CONTROL;
 	else {
-		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
+		skel = SKEL_FS_CONTROL;
 		uhci_add_fsbr(uhci, urb);
 	}
+	if (qh-&gt;state != QH_STATE_ACTIVE)
+		qh-&gt;skel = skel;
 
 	urb-&gt;actual_length = -8;	/* Account for the SETUP packet */
 	return 0;
@@ -930,7 +1078,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	return -ENOMEM;
 }
 
-static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
+static int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
 	int ret;
@@ -939,7 +1087,8 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW)
 		return -EINVAL;
 
-	qh-&gt;skel = uhci-&gt;skel_bulk_qh;
+	if (qh-&gt;state != QH_STATE_ACTIVE)
+		qh-&gt;skel = SKEL_BULK;
 	ret = uhci_submit_common(uhci, urb, qh);
 	if (ret == 0)
 		uhci_add_fsbr(uhci, urb);
@@ -967,7 +1116,7 @@ static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 		if (exponent &lt; 0)
 			return -EINVAL;
 		qh-&gt;period = 1 &lt;&lt; exponent;
-		qh-&gt;skel = uhci-&gt;skelqh[UHCI_SKEL_INDEX(exponent)];
+		qh-&gt;skel = SKEL_INDEX(exponent);
 
 		/* For now, interrupt phase is fixed by the layout
 		 * of the QH lists. */
@@ -1215,7 +1364,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;iso_status = 0;
 	}
 
-	qh-&gt;skel = uhci-&gt;skel_iso_qh;
+	qh-&gt;skel = SKEL_ISO;
 	if (!qh-&gt;bandwidth_reserved)
 		uhci_reserve_bandwidth(uhci, qh);
 	return 0;</pre><hr><pre>commit 28b9325e6ae45ffb5e99fedcafe00f25fcaacf06
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 19 15:51:51 2007 -0500

    UHCI: Add macros for computing DMA values
    
    This patch (as855) adds some convenience macros to uhci-hcd, to help
    simplify the code for computing hardware DMA pointers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 5d6c06bc4524..a0677133577b 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -196,7 +196,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 		struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
 				struct uhci_td, list);
 
-		if (cpu_to_le32(td-&gt;dma_handle) != (element &amp; ~UHCI_PTR_BITS))
+		if (element != LINK_TO_TD(td))
 			out += sprintf(out, "%*s Element != First TD\n",
 					space, "");
 		i = nurbs = 0;
@@ -393,7 +393,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 		do {
 			td = list_entry(tmp, struct uhci_td, fl_list);
 			tmp = tmp-&gt;next;
-			if (cpu_to_le32(td-&gt;dma_handle) != link) {
+			if (link != LINK_TO_TD(td)) {
 				if (nframes &gt; 0)
 					out += sprintf(out, "    link does "
 						"not match list entry!\n");
@@ -440,7 +440,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			if (qh-&gt;link != UHCI_PTR_TERM)
 				out += sprintf(out, "    bandwidth reclamation on!\n");
 
-			if (qh_element(qh) != cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle))
+			if (qh_element(qh) != LINK_TO_TD(uhci-&gt;term_td))
 				out += sprintf(out, "    skel_term_qh element is not set to term_td!\n");
 
 			continue;
@@ -461,8 +461,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 			out += sprintf(out, "    Skipped %d QHs\n", cnt);
 
 		if (i &gt; 1 &amp;&amp; i &lt; UHCI_NUM_SKELQH - 1) {
-			if (qh-&gt;link !=
-			    (cpu_to_le32(uhci-&gt;skelqh[j]-&gt;dma_handle) | UHCI_PTR_QH))
+			if (qh-&gt;link != LINK_TO_QH(uhci-&gt;skelqh[j]))
 				out += sprintf(out, "    last QH not linked to next skeleton!\n");
 		}
 	}
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index ded4df30a631..1f0833ab294a 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -116,7 +116,7 @@ static __le32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)
 	skelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);
 	if (skelnum &lt;= 1)
 		skelnum = 9;
-	return UHCI_PTR_QH | cpu_to_le32(uhci-&gt;skelqh[skelnum]-&gt;dma_handle);
+	return LINK_TO_QH(uhci-&gt;skelqh[skelnum]);
 }
 
 #include "uhci-debug.c"
@@ -635,25 +635,21 @@ static int uhci_start(struct usb_hcd *hcd)
 			uhci-&gt;skel_int16_qh-&gt;link =
 			uhci-&gt;skel_int8_qh-&gt;link =
 			uhci-&gt;skel_int4_qh-&gt;link =
-			uhci-&gt;skel_int2_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_int1_qh-&gt;dma_handle);
-
-	uhci-&gt;skel_int1_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_ls_control_qh-&gt;dma_handle);
-	uhci-&gt;skel_ls_control_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_fs_control_qh-&gt;dma_handle);
-	uhci-&gt;skel_fs_control_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_bulk_qh-&gt;dma_handle);
-	uhci-&gt;skel_bulk_qh-&gt;link = UHCI_PTR_QH |
-			cpu_to_le32(uhci-&gt;skel_term_qh-&gt;dma_handle);
+			uhci-&gt;skel_int2_qh-&gt;link = LINK_TO_QH(
+				uhci-&gt;skel_int1_qh);
+
+	uhci-&gt;skel_int1_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_ls_control_qh);
+	uhci-&gt;skel_ls_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
+	uhci-&gt;skel_fs_control_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_bulk_qh);
+	uhci-&gt;skel_bulk_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_term_qh);
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
 	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
 		(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
-	uhci-&gt;term_td-&gt;link = cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle);
+	uhci-&gt;term_td-&gt;link = LINK_TO_TD(uhci-&gt;term_td);
 
 	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	uhci-&gt;skel_term_qh-&gt;element = cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle);
+	uhci-&gt;skel_term_qh-&gt;element = LINK_TO_TD(uhci-&gt;term_td);
 
 	/*
 	 * Fill the frame list: make all entries point to the proper
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 74469b5bcb61..a8c256b44d8e 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -129,6 +129,8 @@ struct uhci_qh {
 	__le32 element;			/* Queue element (TD) pointer */
 
 	/* Software fields */
+	dma_addr_t dma_handle;
+
 	struct list_head node;		/* Node in the list of QHs */
 	struct usb_host_endpoint *hep;	/* Endpoint information */
 	struct usb_device *udev;
@@ -150,8 +152,6 @@ struct uhci_qh {
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
 
-	dma_addr_t dma_handle;
-
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
@@ -171,6 +171,8 @@ static inline __le32 qh_element(struct uhci_qh *qh) {
 	return element;
 }
 
+#define LINK_TO_QH(qh)		(UHCI_PTR_QH | cpu_to_le32((qh)-&gt;dma_handle))
+
 
 /*
  *	Transfer Descriptors
@@ -264,6 +266,8 @@ static inline u32 td_status(struct uhci_td *td) {
 	return le32_to_cpu(status);
 }
 
+#define LINK_TO_TD(td)		(cpu_to_le32((td)-&gt;dma_handle))
+
 
 /*
  *	Skeleton Queue Headers
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 68e66b33e726..a0c6bf6128a3 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -46,8 +46,7 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
 static void uhci_fsbr_on(struct uhci_hcd *uhci)
 {
 	uhci-&gt;fsbr_is_on = 1;
-	uhci-&gt;skel_term_qh-&gt;link = cpu_to_le32(
-			uhci-&gt;skel_fs_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
+	uhci-&gt;skel_term_qh-&gt;link = LINK_TO_QH(uhci-&gt;skel_fs_control_qh);
 }
 
 static void uhci_fsbr_off(struct uhci_hcd *uhci)
@@ -158,11 +157,11 @@ static inline void uhci_insert_td_in_frame_list(struct uhci_hcd *uhci,
 
 		td-&gt;link = ltd-&gt;link;
 		wmb();
-		ltd-&gt;link = cpu_to_le32(td-&gt;dma_handle);
+		ltd-&gt;link = LINK_TO_TD(td);
 	} else {
 		td-&gt;link = uhci-&gt;frame[framenum];
 		wmb();
-		uhci-&gt;frame[framenum] = cpu_to_le32(td-&gt;dma_handle);
+		uhci-&gt;frame[framenum] = LINK_TO_TD(td);
 		uhci-&gt;frame_cpu[framenum] = td;
 	}
 }
@@ -184,7 +183,7 @@ static inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,
 			struct uhci_td *ntd;
 
 			ntd = list_entry(td-&gt;fl_list.next, struct uhci_td, fl_list);
-			uhci-&gt;frame[td-&gt;frame] = cpu_to_le32(ntd-&gt;dma_handle);
+			uhci-&gt;frame[td-&gt;frame] = LINK_TO_TD(ntd);
 			uhci-&gt;frame_cpu[td-&gt;frame] = ntd;
 		}
 	} else {
@@ -421,7 +420,7 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
 				struct uhci_td, list);
 
-		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		qh-&gt;element = LINK_TO_TD(td);
 	}
 
 	/* Treat the queue as if it has just advanced */
@@ -443,7 +442,7 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	pqh = list_entry(qh-&gt;node.prev, struct uhci_qh, node);
 	qh-&gt;link = pqh-&gt;link;
 	wmb();
-	pqh-&gt;link = UHCI_PTR_QH | cpu_to_le32(qh-&gt;dma_handle);
+	pqh-&gt;link = LINK_TO_QH(qh);
 }
 
 /*
@@ -737,7 +736,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			goto nomem;
-		*plink = cpu_to_le32(td-&gt;dma_handle);
+		*plink = LINK_TO_TD(td);
 
 		/* Alternate Data0/1 (start with Data1) */
 		destination ^= TD_TOKEN_TOGGLE;
@@ -757,7 +756,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	td = uhci_alloc_td(uhci);
 	if (!td)
 		goto nomem;
-	*plink = cpu_to_le32(td-&gt;dma_handle);
+	*plink = LINK_TO_TD(td);
 
 	/*
 	 * It's IN if the pipe is an output pipe or we're not expecting
@@ -784,7 +783,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	td = uhci_alloc_td(uhci);
 	if (!td)
 		goto nomem;
-	*plink = cpu_to_le32(td-&gt;dma_handle);
+	*plink = LINK_TO_TD(td);
 
 	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
 	wmb();
@@ -860,7 +859,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 			td = uhci_alloc_td(uhci);
 			if (!td)
 				goto nomem;
-			*plink = cpu_to_le32(td-&gt;dma_handle);
+			*plink = LINK_TO_TD(td);
 		}
 		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
@@ -888,7 +887,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			goto nomem;
-		*plink = cpu_to_le32(td-&gt;dma_handle);
+		*plink = LINK_TO_TD(td);
 
 		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
@@ -914,7 +913,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	td = uhci_alloc_td(uhci);
 	if (!td)
 		goto nomem;
-	*plink = cpu_to_le32(td-&gt;dma_handle);
+	*plink = LINK_TO_TD(td);
 
 	uhci_fill_td(td, 0, USB_PID_OUT | uhci_explen(0), 0);
 	wmb();
@@ -1005,7 +1004,7 @@ static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
 		 * the queue at the status stage transaction, which is
 		 * the last TD. */
 		WARN_ON(list_empty(&amp;urbp-&gt;td_list));
-		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		qh-&gt;element = LINK_TO_TD(td);
 		tmp = td-&gt;list.prev;
 		ret = -EINPROGRESS;
 
@@ -1566,8 +1565,7 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	if (time_after(jiffies, qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
 
 		/* Detect the Intel bug and work around it */
-		if (qh-&gt;post_td &amp;&amp; qh_element(qh) ==
-				cpu_to_le32(qh-&gt;post_td-&gt;dma_handle)) {
+		if (qh-&gt;post_td &amp;&amp; qh_element(qh) == LINK_TO_TD(qh-&gt;post_td)) {
 			qh-&gt;element = qh-&gt;post_td-&gt;link;
 			qh-&gt;advance_jiffies = jiffies;
 			ret = 1;</pre>
    <div class="pagination">
        <a href='2_111.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><span>[112]</span><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_113.html'>Next&gt;&gt;</a>
    <div>
</body>
