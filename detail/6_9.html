<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_8.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><span>[9]</span><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_10.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b3003e1b54e057f5f3124e437b80c3bef26ed3fe
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Jul 27 20:57:50 2023 +0300

    vdpa: Add queue index attr to vdpa_nl_policy for nlattr length check
    
    The vdpa_nl_policy structure is used to validate the nlattr when parsing
    the incoming nlmsg. It will ensure the attribute being described produces
    a valid nlattr pointer in info-&gt;attrs before entering into each handler
    in vdpa_nl_ops.
    
    That is to say, the missing part in vdpa_nl_policy may lead to illegal
    nlattr after parsing, which could lead to OOB read just like CVE-2023-3773.
    
    This patch adds the missing nla_policy for vdpa queue index attr to avoid
    such bugs.
    
    Fixes: 13b00b135665 ("vdpa: Add support for querying vendor statistics")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Cc: stable@vger.kernelorg
    Message-Id: &lt;20230727175757.73988-5-dtatulea@nvidia.com&gt;
    Signed-off-by: Michael S. Tsirkin &lt;mst@redhat.com&gt;

diff --git a/drivers/vdpa/vdpa.c b/drivers/vdpa/vdpa.c
index 3ad355a2208a..75f1df2b9d2a 100644
--- a/drivers/vdpa/vdpa.c
+++ b/drivers/vdpa/vdpa.c
@@ -1249,6 +1249,7 @@ static const struct nla_policy vdpa_nl_policy[VDPA_ATTR_MAX + 1] = {
 	[VDPA_ATTR_DEV_NET_CFG_MACADDR] = NLA_POLICY_ETH_ADDR,
 	/* virtio spec 1.1 section 5.1.4.1 for valid MTU range */
 	[VDPA_ATTR_DEV_NET_CFG_MTU] = NLA_POLICY_MIN(NLA_U16, 68),
+	[VDPA_ATTR_DEV_QUEUE_INDEX] = { .type = NLA_U32 },
 	[VDPA_ATTR_DEV_FEATURES] = { .type = NLA_U64 },
 };
 </pre><hr><pre>commit 79c8651587504ba263d2fd67fd4406240fb21f69
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Jul 27 20:57:48 2023 +0300

    vdpa: Add features attr to vdpa_nl_policy for nlattr length check
    
    The vdpa_nl_policy structure is used to validate the nlattr when parsing
    the incoming nlmsg. It will ensure the attribute being described produces
    a valid nlattr pointer in info-&gt;attrs before entering into each handler
    in vdpa_nl_ops.
    
    That is to say, the missing part in vdpa_nl_policy may lead to illegal
    nlattr after parsing, which could lead to OOB read just like CVE-2023-3773.
    
    This patch adds the missing nla_policy for vdpa features attr to avoid
    such bugs.
    
    Fixes: 90fea5a800c3 ("vdpa: device feature provisioning")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Cc: stable@vger.kernel.org
    Message-Id: &lt;20230727175757.73988-3-dtatulea@nvidia.com&gt;
    Signed-off-by: Michael S. Tsirkin &lt;mst@redhat.com&gt;

diff --git a/drivers/vdpa/vdpa.c b/drivers/vdpa/vdpa.c
index 965e32529eb8..3ad355a2208a 100644
--- a/drivers/vdpa/vdpa.c
+++ b/drivers/vdpa/vdpa.c
@@ -1249,6 +1249,7 @@ static const struct nla_policy vdpa_nl_policy[VDPA_ATTR_MAX + 1] = {
 	[VDPA_ATTR_DEV_NET_CFG_MACADDR] = NLA_POLICY_ETH_ADDR,
 	/* virtio spec 1.1 section 5.1.4.1 for valid MTU range */
 	[VDPA_ATTR_DEV_NET_CFG_MTU] = NLA_POLICY_MIN(NLA_U16, 68),
+	[VDPA_ATTR_DEV_FEATURES] = { .type = NLA_U64 },
 };
 
 static const struct genl_ops vdpa_nl_ops[] = {</pre><hr><pre>commit f1d152eb66a30aecd19f22ff2676a7cb2584a920
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Mon Aug 7 17:13:47 2023 +0800

    rtnetlink: remove redundant checks for nlattr IFLA_BRIDGE_MODE
    
    The commit d73ef2d69c0d ("rtnetlink: let rtnl_bridge_setlink checks
    IFLA_BRIDGE_MODE length") added the nla_len check in rtnl_bridge_setlink,
    which is the only caller for ndo_bridge_setlink handlers defined in
    low-level driver codes. Hence, this patch cleanups the redundant checks in
    each ndo_bridge_setlink handler function.
    
    Suggested-by: Hangbin Liu &lt;liuhangbin@gmail.com&gt;
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Acked-by: Pavan Chebbi &lt;pavan.chebbi@broadcom.com&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Link: https://lore.kernel.org/r/20230807091347.3804523-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index eb168ca983b7..7be917a8da48 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -13132,9 +13132,6 @@ static int bnxt_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
 			continue;
 
-		if (nla_len(attr) &lt; sizeof(mode))
-			return -EINVAL;
-
 		mode = nla_get_u16(attr);
 		if (mode == bp-&gt;br_mode)
 			break;
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 0616b5fe241c..ad862ed7888a 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -4986,9 +4986,6 @@ static int be_ndo_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
 			continue;
 
-		if (nla_len(attr) &lt; sizeof(mode))
-			return -EINVAL;
-
 		mode = nla_get_u16(attr);
 		if (BE3_chip(adapter) &amp;&amp; mode == BRIDGE_MODE_VEPA)
 			return -EOPNOTSUPP;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 8eb9839a3ca6..dd03b017dfc5 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -10042,9 +10042,6 @@ static int ixgbe_ndo_bridge_setlink(struct net_device *dev,
 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
 			continue;
 
-		if (nla_len(attr) &lt; sizeof(mode))
-			return -EINVAL;
-
 		mode = nla_get_u16(attr);
 		status = ixgbe_configure_bridge_mode(adapter, mode);
 		if (status)
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index c8ec6467d4d1..ca80c220e4b0 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -4896,9 +4896,6 @@ static int mlx5e_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
 			continue;
 
-		if (nla_len(attr) &lt; sizeof(mode))
-			return -EINVAL;
-
 		mode = nla_get_u16(attr);
 		if (mode &gt; BRIDGE_MODE_VEPA)
 			return -EINVAL;
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index f18c791cf698..de0a5d5ded30 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@ -2108,9 +2108,6 @@ static int nfp_net_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
 		if (nla_type(attr) != IFLA_BRIDGE_MODE)
 			continue;
 
-		if (nla_len(attr) &lt; sizeof(mode))
-			return -EINVAL;
-
 		new_ctrl = nn-&gt;dp.ctrl;
 		mode = nla_get_u16(attr);
 		if (mode == BRIDGE_MODE_VEPA)</pre><hr><pre>commit 31d49ba033095f6e8158c60f69714a500922e0c3
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Aug 1 09:32:48 2023 +0800

    net: dcb: choose correct policy to parse DCB_ATTR_BCN
    
    The dcbnl_bcn_setcfg uses erroneous policy to parse tb[DCB_ATTR_BCN],
    which is introduced in commit 859ee3c43812 ("DCB: Add support for DCB
    BCN"). Please see the comment in below code
    
    static int dcbnl_bcn_setcfg(...)
    {
      ...
      ret = nla_parse_nested_deprecated(..., dcbnl_pfc_up_nest, .. )
      // !!! dcbnl_pfc_up_nest for attributes
      //  DCB_PFC_UP_ATTR_0 to DCB_PFC_UP_ATTR_ALL in enum dcbnl_pfc_up_attrs
      ...
      for (i = DCB_BCN_ATTR_RP_0; i &lt;= DCB_BCN_ATTR_RP_7; i++) {
      // !!! DCB_BCN_ATTR_RP_0 to DCB_BCN_ATTR_RP_7 in enum dcbnl_bcn_attrs
        ...
        value_byte = nla_get_u8(data[i]);
        ...
      }
      ...
      for (i = DCB_BCN_ATTR_BCNA_0; i &lt;= DCB_BCN_ATTR_RI; i++) {
      // !!! DCB_BCN_ATTR_BCNA_0 to DCB_BCN_ATTR_RI in enum dcbnl_bcn_attrs
      ...
        value_int = nla_get_u32(data[i]);
      ...
      }
      ...
    }
    
    That is, the nla_parse_nested_deprecated uses dcbnl_pfc_up_nest
    attributes to parse nlattr defined in dcbnl_pfc_up_attrs. But the
    following access code fetch each nlattr as dcbnl_bcn_attrs attributes.
    By looking up the associated nla_policy for dcbnl_bcn_attrs. We can find
    the beginning part of these two policies are "same".
    
    static const struct nla_policy dcbnl_pfc_up_nest[...] = {
            [DCB_PFC_UP_ATTR_0]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_1]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_2]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_3]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_4]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_5]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_6]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_7]   = {.type = NLA_U8},
            [DCB_PFC_UP_ATTR_ALL] = {.type = NLA_FLAG},
    };
    
    static const struct nla_policy dcbnl_bcn_nest[...] = {
            [DCB_BCN_ATTR_RP_0]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_1]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_2]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_3]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_4]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_5]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_6]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_7]         = {.type = NLA_U8},
            [DCB_BCN_ATTR_RP_ALL]       = {.type = NLA_FLAG},
            // from here is somewhat different
            [DCB_BCN_ATTR_BCNA_0]       = {.type = NLA_U32},
            ...
            [DCB_BCN_ATTR_ALL]          = {.type = NLA_FLAG},
    };
    
    Therefore, the current code is buggy and this
    nla_parse_nested_deprecated could overflow the dcbnl_pfc_up_nest and use
    the adjacent nla_policy to parse attributes from DCB_BCN_ATTR_BCNA_0.
    
    Hence use the correct policy dcbnl_bcn_nest to parse the nested
    tb[DCB_ATTR_BCN] TLV.
    
    Fixes: 859ee3c43812 ("DCB: Add support for DCB BCN")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Link: https://lore.kernel.org/r/20230801013248.87240-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/dcb/dcbnl.c b/net/dcb/dcbnl.c
index c0c438128575..2e6b8c8fd2de 100644
--- a/net/dcb/dcbnl.c
+++ b/net/dcb/dcbnl.c
@@ -980,7 +980,7 @@ static int dcbnl_bcn_setcfg(struct net_device *netdev, struct nlmsghdr *nlh,
 		return -EOPNOTSUPP;
 
 	ret = nla_parse_nested_deprecated(data, DCB_BCN_ATTR_MAX,
-					  tb[DCB_ATTR_BCN], dcbnl_pfc_up_nest,
+					  tb[DCB_ATTR_BCN], dcbnl_bcn_nest,
 					  NULL);
 	if (ret)
 		return ret;</pre><hr><pre>commit 1e7417c188d0a83fb385ba2dbe35fd2563f2b6f3
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Wed Jul 26 16:14:07 2023 +0800

    net: usb: lan78xx: reorder cleanup operations to avoid UAF bugs
    
    The timer dev-&gt;stat_monitor can schedule the delayed work dev-&gt;wq and
    the delayed work dev-&gt;wq can also arm the dev-&gt;stat_monitor timer.
    
    When the device is detaching, the net_device will be deallocated. but
    the net_device private data could still be dereferenced in delayed work
    or timer handler. As a result, the UAF bugs will happen.
    
    One racy situation is shown below:
    
          (Thread 1)                 |      (Thread 2)
    lan78xx_stat_monitor()           |
     ...                             |  lan78xx_disconnect()
     lan78xx_defer_kevent()          |    ...
      ...                            |    cancel_delayed_work_sync(&amp;dev-&gt;wq);
      schedule_delayed_work()        |    ...
      (wait some time)               |    free_netdev(net); //free net_device
      lan78xx_delayedwork()          |
      //use net_device private data  |
      dev-&gt; //use                    |
    
    Although we use cancel_delayed_work_sync() to cancel the delayed work
    in lan78xx_disconnect(), it could still be scheduled in timer handler
    lan78xx_stat_monitor().
    
    Another racy situation is shown below:
    
          (Thread 1)                |      (Thread 2)
    lan78xx_delayedwork             |
     mod_timer()                    |  lan78xx_disconnect()
                                    |   cancel_delayed_work_sync()
     (wait some time)               |   if (timer_pending(&amp;dev-&gt;stat_monitor))
                                    |       del_timer_sync(&amp;dev-&gt;stat_monitor);
     lan78xx_stat_monitor()         |   ...
      lan78xx_defer_kevent()        |   free_netdev(net); //free
       //use net_device private data|
       dev-&gt; //use                  |
    
    Although we use del_timer_sync() to delete the timer, the function
    timer_pending() returns 0 when the timer is activated. As a result,
    the del_timer_sync() will not be executed and the timer could be
    re-armed.
    
    In order to mitigate this bug, We use timer_shutdown_sync() to shutdown
    the timer and then use cancel_delayed_work_sync() to cancel the delayed
    work. As a result, the net_device could be deallocated safely.
    
    What's more, the dev-&gt;flags is set to EVENT_DEV_DISCONNECT in
    lan78xx_disconnect(). But it could still be set to EVENT_STAT_UPDATE
    in lan78xx_stat_monitor(). So this patch put the set_bit() behind
    timer_shutdown_sync().
    
    Fixes: 77dfff5bb7e2 ("lan78xx: Fix race condition in disconnect handling")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/usb/lan78xx.c b/drivers/net/usb/lan78xx.c
index c458c030fadf..59cde06aa7f6 100644
--- a/drivers/net/usb/lan78xx.c
+++ b/drivers/net/usb/lan78xx.c
@@ -4224,8 +4224,6 @@ static void lan78xx_disconnect(struct usb_interface *intf)
 	if (!dev)
 		return;
 
-	set_bit(EVENT_DEV_DISCONNECT, &amp;dev-&gt;flags);
-
 	netif_napi_del(&amp;dev-&gt;napi);
 
 	udev = interface_to_usbdev(intf);
@@ -4233,6 +4231,8 @@ static void lan78xx_disconnect(struct usb_interface *intf)
 
 	unregister_netdev(net);
 
+	timer_shutdown_sync(&amp;dev-&gt;stat_monitor);
+	set_bit(EVENT_DEV_DISCONNECT, &amp;dev-&gt;flags);
 	cancel_delayed_work_sync(&amp;dev-&gt;wq);
 
 	phydev = net-&gt;phydev;
@@ -4247,9 +4247,6 @@ static void lan78xx_disconnect(struct usb_interface *intf)
 
 	usb_scuttle_anchored_urbs(&amp;dev-&gt;deferred);
 
-	if (timer_pending(&amp;dev-&gt;stat_monitor))
-		del_timer_sync(&amp;dev-&gt;stat_monitor);
-
 	lan78xx_unbind(dev, intf);
 
 	lan78xx_free_tx_resources(dev);</pre><hr><pre>commit 5e2424708da7207087934c5c75211e8584d553a0
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Sun Jul 23 15:41:10 2023 +0800

    xfrm: add forgotten nla_policy for XFRMA_MTIMER_THRESH
    
    The previous commit 4e484b3e969b ("xfrm: rate limit SA mapping change
    message to user space") added one additional attribute named
    XFRMA_MTIMER_THRESH and described its type at compat_policy
    (net/xfrm/xfrm_compat.c).
    
    However, the author forgot to also describe the nla_policy at
    xfrma_policy (net/xfrm/xfrm_user.c). Hence, this suppose NLA_U32 (4
    bytes) value can be faked as empty (0 bytes) by a malicious user, which
    leads to 4 bytes overflow read and heap information leak when parsing
    nlattrs.
    
    To exploit this, one malicious user can spray the SLUB objects and then
    leverage this 4 bytes OOB read to leak the heap data into
    x-&gt;mapping_maxage (see xfrm_update_ae_params(...)), and leak it to
    userspace via copy_to_user_state_extra(...).
    
    The above bug is assigned CVE-2023-3773. To fix it, this commit just
    completes the nla_policy description for XFRMA_MTIMER_THRESH, which
    enforces the length check and avoids such OOB read.
    
    Fixes: 4e484b3e969b ("xfrm: rate limit SA mapping change message to user space")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;simon.horman@corigine.com&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@nvidia.com&gt;
    Signed-off-by: Steffen Klassert &lt;steffen.klassert@secunet.com&gt;

diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index 8f74dde4a55f..f06d6deb58dd 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -3044,6 +3044,7 @@ const struct nla_policy xfrma_policy[XFRMA_MAX+1] = {
 	[XFRMA_SET_MARK]	= { .type = NLA_U32 },
 	[XFRMA_SET_MARK_MASK]	= { .type = NLA_U32 },
 	[XFRMA_IF_ID]		= { .type = NLA_U32 },
+	[XFRMA_MTIMER_THRESH]   = { .type = NLA_U32 },
 };
 EXPORT_SYMBOL_GPL(xfrma_policy);
 </pre><hr><pre>commit 00374d9b6d9f932802b55181be9831aa948e5b7c
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Fri Jul 21 22:51:03 2023 +0800

    xfrm: add NULL check in xfrm_update_ae_params
    
    Normally, x-&gt;replay_esn and x-&gt;preplay_esn should be allocated at
    xfrm_alloc_replay_state_esn(...) in xfrm_state_construct(...), hence the
    xfrm_update_ae_params(...) is okay to update them. However, the current
    implementation of xfrm_new_ae(...) allows a malicious user to directly
    dereference a NULL pointer and crash the kernel like below.
    
    BUG: kernel NULL pointer dereference, address: 0000000000000000
    PGD 8253067 P4D 8253067 PUD 8e0e067 PMD 0
    Oops: 0002 [#1] PREEMPT SMP KASAN NOPTI
    CPU: 0 PID: 98 Comm: poc.npd Not tainted 6.4.0-rc7-00072-gdad9774deaf1 #8
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.o4
    RIP: 0010:memcpy_orig+0xad/0x140
    Code: e8 4c 89 5f e0 48 8d 7f e0 73 d2 83 c2 20 48 29 d6 48 29 d7 83 fa 10 72 34 4c 8b 06 4c 8b 4e 08 c
    RSP: 0018:ffff888008f57658 EFLAGS: 00000202
    RAX: 0000000000000000 RBX: ffff888008bd0000 RCX: ffffffff8238e571
    RDX: 0000000000000018 RSI: ffff888007f64844 RDI: 0000000000000000
    RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff888008f57818
    R13: ffff888007f64aa4 R14: 0000000000000000 R15: 0000000000000000
    FS:  00000000014013c0(0000) GS:ffff88806d600000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000000000000000 CR3: 00000000054d8000 CR4: 00000000000006f0
    Call Trace:
     &lt;TASK&gt;
     ? __die+0x1f/0x70
     ? page_fault_oops+0x1e8/0x500
     ? __pfx_is_prefetch.constprop.0+0x10/0x10
     ? __pfx_page_fault_oops+0x10/0x10
     ? _raw_spin_unlock_irqrestore+0x11/0x40
     ? fixup_exception+0x36/0x460
     ? _raw_spin_unlock_irqrestore+0x11/0x40
     ? exc_page_fault+0x5e/0xc0
     ? asm_exc_page_fault+0x26/0x30
     ? xfrm_update_ae_params+0xd1/0x260
     ? memcpy_orig+0xad/0x140
     ? __pfx__raw_spin_lock_bh+0x10/0x10
     xfrm_update_ae_params+0xe7/0x260
     xfrm_new_ae+0x298/0x4e0
     ? __pfx_xfrm_new_ae+0x10/0x10
     ? __pfx_xfrm_new_ae+0x10/0x10
     xfrm_user_rcv_msg+0x25a/0x410
     ? __pfx_xfrm_user_rcv_msg+0x10/0x10
     ? __alloc_skb+0xcf/0x210
     ? stack_trace_save+0x90/0xd0
     ? filter_irq_stacks+0x1c/0x70
     ? __stack_depot_save+0x39/0x4e0
     ? __kasan_slab_free+0x10a/0x190
     ? kmem_cache_free+0x9c/0x340
     ? netlink_recvmsg+0x23c/0x660
     ? sock_recvmsg+0xeb/0xf0
     ? __sys_recvfrom+0x13c/0x1f0
     ? __x64_sys_recvfrom+0x71/0x90
     ? do_syscall_64+0x3f/0x90
     ? entry_SYSCALL_64_after_hwframe+0x72/0xdc
     ? copyout+0x3e/0x50
     netlink_rcv_skb+0xd6/0x210
     ? __pfx_xfrm_user_rcv_msg+0x10/0x10
     ? __pfx_netlink_rcv_skb+0x10/0x10
     ? __pfx_sock_has_perm+0x10/0x10
     ? mutex_lock+0x8d/0xe0
     ? __pfx_mutex_lock+0x10/0x10
     xfrm_netlink_rcv+0x44/0x50
     netlink_unicast+0x36f/0x4c0
     ? __pfx_netlink_unicast+0x10/0x10
     ? netlink_recvmsg+0x500/0x660
     netlink_sendmsg+0x3b7/0x700
    
    This Null-ptr-deref bug is assigned CVE-2023-3772. And this commit
    adds additional NULL check in xfrm_update_ae_params to fix the NPD.
    
    Fixes: d8647b79c3b7 ("xfrm: Add user interface for esn and big anti-replay windows")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Leon Romanovsky &lt;leonro@nvidia.com&gt;
    Signed-off-by: Steffen Klassert &lt;steffen.klassert@secunet.com&gt;

diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index fdc0c17122b6..8f74dde4a55f 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -628,7 +628,7 @@ static void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs,
 	struct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];
 	struct nlattr *mt = attrs[XFRMA_MTIMER_THRESH];
 
-	if (re) {
+	if (re &amp;&amp; x-&gt;replay_esn &amp;&amp; x-&gt;preplay_esn) {
 		struct xfrm_replay_state_esn *replay_esn;
 		replay_esn = nla_data(re);
 		memcpy(x-&gt;replay_esn, replay_esn,</pre><hr><pre>commit d73ef2d69c0dba5f5a1cb9600045c873bab1fb7f
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Jul 26 15:53:14 2023 +0800

    rtnetlink: let rtnl_bridge_setlink checks IFLA_BRIDGE_MODE length
    
    There are totally 9 ndo_bridge_setlink handlers in the current kernel,
    which are 1) bnxt_bridge_setlink, 2) be_ndo_bridge_setlink 3)
    i40e_ndo_bridge_setlink 4) ice_bridge_setlink 5)
    ixgbe_ndo_bridge_setlink 6) mlx5e_bridge_setlink 7)
    nfp_net_bridge_setlink 8) qeth_l2_bridge_setlink 9) br_setlink.
    
    By investigating the code, we find that 1-7 parse and use nlattr
    IFLA_BRIDGE_MODE but 3 and 4 forget to do the nla_len check. This can
    lead to an out-of-attribute read and allow a malformed nlattr (e.g.,
    length 0) to be viewed as a 2 byte integer.
    
    To avoid such issues, also for other ndo_bridge_setlink handlers in the
    future. This patch adds the nla_len check in rtnl_bridge_setlink and
    does an early error return if length mismatches. To make it works, the
    break is removed from the parsing for IFLA_BRIDGE_FLAGS to make sure
    this nla_for_each_nested iterates every attribute.
    
    Fixes: b1edc14a3fbf ("ice: Implement ice_bridge_getlink and ice_bridge_setlink")
    Fixes: 51616018dd1b ("i40e: Add support for getlink, setlink ndo ops")
    Suggested-by: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Acked-by: Nikolay Aleksandrov &lt;razor@blackwall.org&gt;
    Reviewed-by: Hangbin Liu &lt;liuhangbin@gmail.com&gt;
    Link: https://lore.kernel.org/r/20230726075314.1059224-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 3ad4e030846d..aef25aa5cf1d 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -5140,13 +5140,17 @@ static int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,
 	br_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
 	if (br_spec) {
 		nla_for_each_nested(attr, br_spec, rem) {
-			if (nla_type(attr) == IFLA_BRIDGE_FLAGS) {
+			if (nla_type(attr) == IFLA_BRIDGE_FLAGS &amp;&amp; !have_flags) {
 				if (nla_len(attr) &lt; sizeof(flags))
 					return -EINVAL;
 
 				have_flags = true;
 				flags = nla_get_u16(attr);
-				break;
+			}
+
+			if (nla_type(attr) == IFLA_BRIDGE_MODE) {
+				if (nla_len(attr) &lt; sizeof(u16))
+					return -EINVAL;
 			}
 		}
 	}</pre><hr><pre>commit bcc29b7f5af6797702c2306a7aacb831fc5ce9cb
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Jul 25 10:33:30 2023 +0800

    bpf: Add length check for SK_DIAG_BPF_STORAGE_REQ_MAP_FD parsing
    
    The nla_for_each_nested parsing in function bpf_sk_storage_diag_alloc
    does not check the length of the nested attribute. This can lead to an
    out-of-attribute read and allow a malformed nlattr (e.g., length 0) to
    be viewed as a 4 byte integer.
    
    This patch adds an additional check when the nlattr is getting counted.
    This makes sure the latter nla_get_u32 can access the attributes with
    the correct length.
    
    Fixes: 1ed4d92458a9 ("bpf: INET_DIAG support in bpf_sk_storage")
    Suggested-by: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Link: https://lore.kernel.org/r/20230725023330.422856-1-linma@zju.edu.cn
    Signed-off-by: Martin KaFai Lau &lt;martin.lau@kernel.org&gt;

diff --git a/net/core/bpf_sk_storage.c b/net/core/bpf_sk_storage.c
index d4172534dfa8..cca7594be92e 100644
--- a/net/core/bpf_sk_storage.c
+++ b/net/core/bpf_sk_storage.c
@@ -496,8 +496,11 @@ bpf_sk_storage_diag_alloc(const struct nlattr *nla_stgs)
 		return ERR_PTR(-EPERM);
 
 	nla_for_each_nested(nla, nla_stgs, rem) {
-		if (nla_type(nla) == SK_DIAG_BPF_STORAGE_REQ_MAP_FD)
+		if (nla_type(nla) == SK_DIAG_BPF_STORAGE_REQ_MAP_FD) {
+			if (nla_len(nla) != sizeof(u32))
+				return ERR_PTR(-EINVAL);
 			nr_maps++;
+		}
 	}
 
 	diag = kzalloc(struct_size(diag, maps, nr_maps), GFP_KERNEL);</pre><hr><pre>commit 0c805e80e35d042a41c8702fa13f453a504d2ede
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Jul 12 21:32:36 2023 +0800

    netfilter: conntrack: validate cta_ip via parsing
    
    In current ctnetlink_parse_tuple_ip() function, nested parsing and
    validation is splitting as two parts,  which could be cleanup to a
    simplified form. As the nla_parse_nested_deprecated function
    supports validation in the fly. These two finially reach same place
    __nla_validate_parse with same validate flag.
    
    nla_parse_nested_deprecated
      __nla_parse(.., NL_VALIDATE_LIBERAL, ..)
        __nla_validate_parse
    
    nla_validate_nested_deprecated
      __nla_validate_nested(.., NL_VALIDATE_LIBERAL, ..)
        __nla_validate
          __nla_validate_parse
    
    This commit removes the call to nla_validate_nested_deprecated and pass
    cta_ip_nla_policy when do parsing.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;simon.horman@corigine.com&gt;
    Signed-off-by: Florian Westphal &lt;fw@strlen.de&gt;

diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index 69c8c8c7e9b8..334db22199c1 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -1321,15 +1321,11 @@ static int ctnetlink_parse_tuple_ip(struct nlattr *attr,
 	struct nlattr *tb[CTA_IP_MAX+1];
 	int ret = 0;
 
-	ret = nla_parse_nested_deprecated(tb, CTA_IP_MAX, attr, NULL, NULL);
+	ret = nla_parse_nested_deprecated(tb, CTA_IP_MAX, attr,
+					  cta_ip_nla_policy, NULL);
 	if (ret &lt; 0)
 		return ret;
 
-	ret = nla_validate_nested_deprecated(attr, CTA_IP_MAX,
-					     cta_ip_nla_policy, NULL);
-	if (ret)
-		return ret;
-
 	switch (tuple-&gt;src.l3num) {
 	case NFPROTO_IPV4:
 		ret = ipv4_nlattr_to_tuple(tb, tuple, flags);</pre>
    <div class="pagination">
        <a href='6_8.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><span>[9]</span><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_10.html'>Next&gt;&gt;</a>
    <div>
</body>
