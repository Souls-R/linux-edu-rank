<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_122.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><span>[123]</span><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_124.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7c30fd79168aeb83d11260246d93f8a293052007
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:02 2020 -0400

    efi/printf: Merge 'p' with the integer formats
    
    Treat 'p' as a hexadecimal integer with precision equal to the number of
    digits in void *.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-11-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/vsprintf.c b/drivers/firmware/efi/libstub/vsprintf.c
index 00123d5f402f..b7316ab9f8b4 100644
--- a/drivers/firmware/efi/libstub/vsprintf.c
+++ b/drivers/firmware/efi/libstub/vsprintf.c
@@ -297,9 +297,6 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 			}
 		}
 
-		/* default base */
-		base = 10;
-
 		switch (*fmt) {
 		case 'c':
 			if (!(flags &amp; LEFT))
@@ -323,21 +320,15 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 				*str++ = ' ';
 			continue;
 
-		case 'p':
-			if (field_width == -1) {
-				field_width = 2 * sizeof(void *);
-				flags |= ZEROPAD;
-			}
-			str = number(str,
-				     (unsigned long)va_arg(args, void *), 16,
-				     field_width, precision, flags);
-			continue;
-
 			/* integer number formats - set up the flags and "break" */
 		case 'o':
 			base = 8;
 			break;
 
+		case 'p':
+			if (precision &lt; 0)
+				precision = 2 * sizeof(void *);
+			fallthrough;
 		case 'x':
 			flags |= SMALL;
 			fallthrough;
@@ -350,6 +341,7 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 			flags |= SIGN;
 			fallthrough;
 		case 'u':
+			base = 10;
 			break;
 
 		default:
@@ -360,7 +352,9 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 				--fmt;
 			continue;
 		}
-		if (flags &amp; SIGN) {
+		if (*fmt == 'p') {
+			num = (unsigned long)va_arg(args, void *);
+		} else if (flags &amp; SIGN) {
 			switch (qualifier) {
 			case 'L':
 				num = va_arg(args, long long);</pre><hr><pre>commit 77e48db04a02ebd00229281c26575979b0b465e0
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:01 2020 -0400

    efi/printf: Fix minor bug in precision handling
    
    A negative precision should be ignored completely, and the presence of a
    valid precision should turn off the 0 flag.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-10-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/vsprintf.c b/drivers/firmware/efi/libstub/vsprintf.c
index fb9eb83f1728..00123d5f402f 100644
--- a/drivers/firmware/efi/libstub/vsprintf.c
+++ b/drivers/firmware/efi/libstub/vsprintf.c
@@ -279,9 +279,11 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 				++fmt;
 				/* it's the next argument */
 				precision = va_arg(args, int);
-			}
-			if (precision &lt; 0)
+			} else {
 				precision = 0;
+			}
+			if (precision &gt;= 0)
+				flags &amp;= ~ZEROPAD;
 		}
 
 		/* get the conversion qualifier */</pre><hr><pre>commit 3b8350959cba0df4070741618e50c367319793bb
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:07:00 2020 -0400

    efi/printf: Factor out flags parsing and handle '%' earlier
    
    Move flags parsing code out into a helper function.
    
    The '%%' case can be handled up front: it is not allowed to have flags,
    width etc.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-9-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/vsprintf.c b/drivers/firmware/efi/libstub/vsprintf.c
index 8fd15e87d18c..fb9eb83f1728 100644
--- a/drivers/firmware/efi/libstub/vsprintf.c
+++ b/drivers/firmware/efi/libstub/vsprintf.c
@@ -202,6 +202,35 @@ static char *number(char *str, long long num, int base, int size, int precision,
 	return str;
 }
 
+static
+int get_flags(const char **fmt)
+{
+	int flags = 0;
+
+	do {
+		switch (**fmt) {
+		case '-':
+			flags |= LEFT;
+			break;
+		case '+':
+			flags |= PLUS;
+			break;
+		case ' ':
+			flags |= SPACE;
+			break;
+		case '#':
+			flags |= SPECIAL;
+			break;
+		case '0':
+			flags |= ZEROPAD;
+			break;
+		default:
+			return flags;
+		}
+		++(*fmt);
+	} while (1);
+}
+
 int vsprintf(char *buf, const char *fmt, va_list args)
 {
 	int len;
@@ -218,32 +247,13 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 	int qualifier;		/* 'h', 'hh', 'l' or 'll' for integer fields */
 
 	for (str = buf; *fmt; ++fmt) {
-		if (*fmt != '%') {
+		if (*fmt != '%' || *++fmt == '%') {
 			*str++ = *fmt;
 			continue;
 		}
 
 		/* process flags */
-		flags = 0;
-	      repeat:
-		++fmt;		/* this also skips first '%' */
-		switch (*fmt) {
-		case '-':
-			flags |= LEFT;
-			goto repeat;
-		case '+':
-			flags |= PLUS;
-			goto repeat;
-		case ' ':
-			flags |= SPACE;
-			goto repeat;
-		case '#':
-			flags |= SPECIAL;
-			goto repeat;
-		case '0':
-			flags |= ZEROPAD;
-			goto repeat;
-		}
+		flags = get_flags(&amp;fmt);
 
 		/* get field width */
 		field_width = -1;
@@ -321,10 +331,6 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 				     field_width, precision, flags);
 			continue;
 
-		case '%':
-			*str++ = '%';
-			continue;
-
 			/* integer number formats - set up the flags and "break" */
 		case 'o':
 			base = 8;</pre><hr><pre>commit ce5e3f909fc0ed67e58367b9c56a54c20a51080b
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:06:59 2020 -0400

    efi/printf: Add 64-bit and 8-bit integer support
    
    Support 'll' qualifier for long long by copying the decimal printing
    code from lib/vsprintf.c. For simplicity, the 32-bit code is used on
    64-bit architectures as well.
    
    Support 'hh' qualifier for signed/unsigned char type integers.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-8-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/vsprintf.c b/drivers/firmware/efi/libstub/vsprintf.c
index 52cf22d0b6e5..8fd15e87d18c 100644
--- a/drivers/firmware/efi/libstub/vsprintf.c
+++ b/drivers/firmware/efi/libstub/vsprintf.c
@@ -7,10 +7,7 @@
  * ----------------------------------------------------------------------- */
 
 /*
- * Oh, it's a waste of space, but oh-so-yummy for debugging.  This
- * version of printf() does not include 64-bit support.  "Live with
- * it."
- *
+ * Oh, it's a waste of space, but oh-so-yummy for debugging.
  */
 
 #include &lt;stdarg.h&gt;
@@ -28,6 +25,86 @@ static int skip_atoi(const char **s)
 	return i;
 }
 
+/*
+ * put_dec_full4 handles numbers in the range 0 &lt;= r &lt; 10000.
+ * The multiplier 0xccd is round(2^15/10), and the approximation
+ * r/10 == (r * 0xccd) &gt;&gt; 15 is exact for all r &lt; 16389.
+ */
+static
+void put_dec_full4(char *buf, unsigned int r)
+{
+	int i;
+
+	for (i = 0; i &lt; 3; i++) {
+		unsigned int q = (r * 0xccd) &gt;&gt; 15;
+		*buf++ = '0' + (r - q * 10);
+		r = q;
+	}
+	*buf++ = '0' + r;
+}
+
+/* put_dec is copied from lib/vsprintf.c with small modifications */
+
+/*
+ * Call put_dec_full4 on x % 10000, return x / 10000.
+ * The approximation x/10000 == (x * 0x346DC5D7) &gt;&gt; 43
+ * holds for all x &lt; 1,128,869,999.  The largest value this
+ * helper will ever be asked to convert is 1,125,520,955.
+ * (second call in the put_dec code, assuming n is all-ones).
+ */
+static
+unsigned int put_dec_helper4(char *buf, unsigned int x)
+{
+	unsigned int q = (x * 0x346DC5D7ULL) &gt;&gt; 43;
+
+	put_dec_full4(buf, x - q * 10000);
+	return q;
+}
+
+/* Based on code by Douglas W. Jones found at
+ * &lt;http://www.cs.uiowa.edu/~jones/bcd/decimal.html#sixtyfour&gt;
+ * (with permission from the author).
+ * Performs no 64-bit division and hence should be fast on 32-bit machines.
+ */
+static
+int put_dec(char *buf, unsigned long long n)
+{
+	unsigned int d3, d2, d1, q, h;
+	char *p = buf;
+
+	d1  = ((unsigned int)n &gt;&gt; 16); /* implicit "&amp; 0xffff" */
+	h   = (n &gt;&gt; 32);
+	d2  = (h      ) &amp; 0xffff;
+	d3  = (h &gt;&gt; 16); /* implicit "&amp; 0xffff" */
+
+	/* n = 2^48 d3 + 2^32 d2 + 2^16 d1 + d0
+	     = 281_4749_7671_0656 d3 + 42_9496_7296 d2 + 6_5536 d1 + d0 */
+	q = 656 * d3 + 7296 * d2 + 5536 * d1 + ((unsigned int)n &amp; 0xffff);
+	q = put_dec_helper4(p, q);
+	p += 4;
+
+	q += 7671 * d3 + 9496 * d2 + 6 * d1;
+	q = put_dec_helper4(p, q);
+	p += 4;
+
+	q += 4749 * d3 + 42 * d2;
+	q = put_dec_helper4(p, q);
+	p += 4;
+
+	q += 281 * d3;
+	q = put_dec_helper4(p, q);
+	p += 4;
+
+	put_dec_full4(p, q);
+	p += 4;
+
+	/* strip off the extra 0's we printed */
+	while (p &gt; buf &amp;&amp; p[-1] == '0')
+		--p;
+
+	return p - buf;
+}
+
 #define ZEROPAD	1		/* pad with zero */
 #define SIGN	2		/* unsigned/signed long */
 #define PLUS	4		/* show plus */
@@ -36,13 +113,7 @@ static int skip_atoi(const char **s)
 #define SMALL	32		/* Must be 32 == 0x20 */
 #define SPECIAL	64		/* 0x */
 
-#define __do_div(n, base) ({ \
-int __res; \
-__res = ((unsigned long) n) % (unsigned) base; \
-n = ((unsigned long) n) / (unsigned) base; \
-__res; })
-
-static char *number(char *str, long num, int base, int size, int precision,
+static char *number(char *str, long long num, int base, int size, int precision,
 		    int type)
 {
 	/* we are called with base 8, 10 or 16, only, thus don't need "G..."  */
@@ -57,8 +128,6 @@ static char *number(char *str, long num, int base, int size, int precision,
 	locase = (type &amp; SMALL);
 	if (type &amp; LEFT)
 		type &amp;= ~ZEROPAD;
-	if (base &lt; 2 || base &gt; 16)
-		return NULL;
 	c = (type &amp; ZEROPAD) ? '0' : ' ';
 	sign = 0;
 	if (type &amp; SIGN) {
@@ -83,9 +152,28 @@ static char *number(char *str, long num, int base, int size, int precision,
 	i = 0;
 	if (num == 0)
 		tmp[i++] = '0';
-	else
-		while (num != 0)
-			tmp[i++] = (digits[__do_div(num, base)] | locase);
+	else {
+		switch (base) {
+		case 10:
+			i += put_dec(&amp;tmp[i], num);
+			break;
+		case 8:
+			while (num != 0) {
+				tmp[i++] = '0' + (num &amp; 07);
+				num = (unsigned long long)num &gt;&gt; 3;
+			}
+			break;
+		case 16:
+			while (num != 0) {
+				tmp[i++] = digits[num &amp; 0xf] | locase;
+				num = (unsigned long long)num &gt;&gt; 4;
+			}
+			break;
+		default:
+			unreachable();
+		}
+	}
+
 	if (i &gt; precision)
 		precision = i;
 	size -= precision;
@@ -117,7 +205,7 @@ static char *number(char *str, long num, int base, int size, int precision,
 int vsprintf(char *buf, const char *fmt, va_list args)
 {
 	int len;
-	unsigned long num;
+	unsigned long long num;
 	int i, base;
 	char *str;
 	const char *s;
@@ -127,7 +215,7 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 	int field_width;	/* width of output field */
 	int precision;		/* min. # of digits for integers; max
 				   number of chars for from string */
-	int qualifier;		/* 'h' or 'l' for integer fields */
+	int qualifier;		/* 'h', 'hh', 'l' or 'll' for integer fields */
 
 	for (str = buf; *fmt; ++fmt) {
 		if (*fmt != '%') {
@@ -191,6 +279,10 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 		if (*fmt == 'h' || *fmt == 'l') {
 			qualifier = *fmt;
 			++fmt;
+			if (qualifier == *fmt) {
+				qualifier -= 'a'-'A';
+				++fmt;
+			}
 		}
 
 		/* default base */
@@ -260,16 +352,40 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 				--fmt;
 			continue;
 		}
-		if (qualifier == 'l') {
-			num = va_arg(args, unsigned long);
-		} else if (qualifier == 'h') {
-			num = (unsigned short)va_arg(args, int);
-			if (flags &amp; SIGN)
-				num = (short)num;
-		} else if (flags &amp; SIGN) {
-			num = va_arg(args, int);
+		if (flags &amp; SIGN) {
+			switch (qualifier) {
+			case 'L':
+				num = va_arg(args, long long);
+				break;
+			case 'l':
+				num = va_arg(args, long);
+				break;
+			case 'h':
+				num = (short)va_arg(args, int);
+				break;
+			case 'H':
+				num = (signed char)va_arg(args, int);
+				break;
+			default:
+				num = va_arg(args, int);
+			}
 		} else {
-			num = va_arg(args, unsigned int);
+			switch (qualifier) {
+			case 'L':
+				num = va_arg(args, unsigned long long);
+				break;
+			case 'l':
+				num = va_arg(args, unsigned long);
+				break;
+			case 'h':
+				num = (unsigned short)va_arg(args, int);
+				break;
+			case 'H':
+				num = (unsigned char)va_arg(args, int);
+				break;
+			default:
+				num = va_arg(args, unsigned int);
+			}
 		}
 		str = number(str, num, base, field_width, precision, flags);
 	}</pre><hr><pre>commit 29a2806653360f1ba0f7608ef64d65d441a575f7
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:06:58 2020 -0400

    efi/printf: Drop %n format and L qualifier
    
    %n is unused and deprecated.
    
    The L qualifer is parsed but not actually implemented.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-7-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/vsprintf.c b/drivers/firmware/efi/libstub/vsprintf.c
index bb62d3726c65..52cf22d0b6e5 100644
--- a/drivers/firmware/efi/libstub/vsprintf.c
+++ b/drivers/firmware/efi/libstub/vsprintf.c
@@ -127,7 +127,7 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 	int field_width;	/* width of output field */
 	int precision;		/* min. # of digits for integers; max
 				   number of chars for from string */
-	int qualifier;		/* 'h', 'l', or 'L' for integer fields */
+	int qualifier;		/* 'h' or 'l' for integer fields */
 
 	for (str = buf; *fmt; ++fmt) {
 		if (*fmt != '%') {
@@ -188,7 +188,7 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 
 		/* get the conversion qualifier */
 		qualifier = -1;
-		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
+		if (*fmt == 'h' || *fmt == 'l') {
 			qualifier = *fmt;
 			++fmt;
 		}
@@ -229,16 +229,6 @@ int vsprintf(char *buf, const char *fmt, va_list args)
 				     field_width, precision, flags);
 			continue;
 
-		case 'n':
-			if (qualifier == 'l') {
-				long *ip = va_arg(args, long *);
-				*ip = (str - buf);
-			} else {
-				int *ip = va_arg(args, int *);
-				*ip = (str - buf);
-			}
-			continue;
-
 		case '%':
 			*str++ = '%';
 			continue;</pre><hr><pre>commit bbf8e8b0fe0401e1952c77088692fd273a9635a1
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:06:57 2020 -0400

    efi/libstub: Optimize for size instead of speed
    
    Reclaim the bloat from the addition of printf by optimizing the stub for
    size. With gcc 9, the text size of the stub is:
    
    ARCH    before  +printf    -Os
    arm      35197    37889  34638
    arm64    34883    38159  34479
    i386     18571    21657  17025
    x86_64   25677    29328  22144
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-6-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/Makefile b/drivers/firmware/efi/libstub/Makefile
index fb34c9d14a3c..034d71663b1e 100644
--- a/drivers/firmware/efi/libstub/Makefile
+++ b/drivers/firmware/efi/libstub/Makefile
@@ -7,7 +7,7 @@
 #
 cflags-$(CONFIG_X86_32)		:= -march=i386
 cflags-$(CONFIG_X86_64)		:= -mcmodel=small
-cflags-$(CONFIG_X86)		+= -m$(BITS) -D__KERNEL__ -O2 \
+cflags-$(CONFIG_X86)		+= -m$(BITS) -D__KERNEL__ \
 				   -fPIC -fno-strict-aliasing -mno-red-zone \
 				   -mno-mmx -mno-sse -fshort-wchar \
 				   -Wno-pointer-sign \
@@ -25,7 +25,7 @@ cflags-$(CONFIG_ARM)		:= $(subst $(CC_FLAGS_FTRACE),,$(KBUILD_CFLAGS)) \
 
 cflags-$(CONFIG_EFI_GENERIC_STUB) += -I$(srctree)/scripts/dtc/libfdt
 
-KBUILD_CFLAGS			:= $(cflags-y) -DDISABLE_BRANCH_PROFILING \
+KBUILD_CFLAGS			:= $(cflags-y) -Os -DDISABLE_BRANCH_PROFILING \
 				   -include $(srctree)/drivers/firmware/efi/libstub/hidden.h \
 				   -D__NO_FORTIFY \
 				   $(call cc-option,-ffreestanding) \</pre><hr><pre>commit 2c7d1e30e5884dc6f6727ecd9417491c9f321b59
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:06:56 2020 -0400

    efi/libstub: Add a basic printf implementation
    
    Copy vsprintf from arch/x86/boot/printf.c to get a simple printf
    implementation.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-5-nivedita@alum.mit.edu
    [ardb: add some missing braces in if...else clauses]
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/Makefile b/drivers/firmware/efi/libstub/Makefile
index e5a49dc8e9bc..fb34c9d14a3c 100644
--- a/drivers/firmware/efi/libstub/Makefile
+++ b/drivers/firmware/efi/libstub/Makefile
@@ -44,7 +44,7 @@ KCOV_INSTRUMENT			:= n
 lib-y				:= efi-stub-helper.o gop.o secureboot.o tpm.o \
 				   file.o mem.o random.o randomalloc.o pci.o \
 				   skip_spaces.o lib-cmdline.o lib-ctype.o \
-				   alignedmem.o relocate.o
+				   alignedmem.o relocate.o vsprintf.o
 
 # include the stub's generic dependencies from lib/ when building for ARM/arm64
 efi-deps-y := fdt_rw.c fdt_ro.c fdt_wip.c fdt.c fdt_empty_tree.c fdt_sw.c
diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index 3cf506ab9ead..56b3b84fd3bd 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -7,6 +7,8 @@
  * Copyright 2011 Intel Corporation; author Matt Fleming
  */
 
+#include &lt;stdarg.h&gt;
+
 #include &lt;linux/efi.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;asm/efi.h&gt;
@@ -51,6 +53,21 @@ void efi_puts(const char *str)
 	}
 }
 
+int efi_printk(const char *fmt, ...)
+{
+	char printf_buf[256];
+	va_list args;
+	int printed;
+
+	va_start(args, fmt);
+	printed = vsprintf(printf_buf, fmt, args);
+	va_end(args);
+
+	efi_puts(printf_buf);
+
+	return printed;
+}
+
 /*
  * Parse the ASCII string 'cmdline' for EFI options, denoted by the efi=
  * option, e.g. efi=nochunk.
diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 4f57611a65f2..caa7dcc71c69 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -3,6 +3,7 @@
 #ifndef _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 #define _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 
+#include &lt;linux/compiler.h&gt;
 #include &lt;linux/efi.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/types.h&gt;
@@ -632,6 +633,8 @@ void *get_efi_config_table(efi_guid_t guid);
 void efi_char16_puts(efi_char16_t *);
 void efi_puts(const char *str);
 
+__printf(1, 2) int efi_printk(char const *fmt, ...);
+
 void efi_free(unsigned long size, unsigned long addr);
 
 char *efi_convert_cmdline(efi_loaded_image_t *image, int *cmd_line_len,
diff --git a/drivers/firmware/efi/libstub/vsprintf.c b/drivers/firmware/efi/libstub/vsprintf.c
new file mode 100644
index 000000000000..bb62d3726c65
--- /dev/null
+++ b/drivers/firmware/efi/libstub/vsprintf.c
@@ -0,0 +1,299 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/* -*- linux-c -*- ------------------------------------------------------- *
+ *
+ *   Copyright (C) 1991, 1992 Linus Torvalds
+ *   Copyright 2007 rPath, Inc. - All Rights Reserved
+ *
+ * ----------------------------------------------------------------------- */
+
+/*
+ * Oh, it's a waste of space, but oh-so-yummy for debugging.  This
+ * version of printf() does not include 64-bit support.  "Live with
+ * it."
+ *
+ */
+
+#include &lt;stdarg.h&gt;
+
+#include &lt;linux/compiler.h&gt;
+#include &lt;linux/ctype.h&gt;
+#include &lt;linux/string.h&gt;
+
+static int skip_atoi(const char **s)
+{
+	int i = 0;
+
+	while (isdigit(**s))
+		i = i * 10 + *((*s)++) - '0';
+	return i;
+}
+
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SMALL	32		/* Must be 32 == 0x20 */
+#define SPECIAL	64		/* 0x */
+
+#define __do_div(n, base) ({ \
+int __res; \
+__res = ((unsigned long) n) % (unsigned) base; \
+n = ((unsigned long) n) / (unsigned) base; \
+__res; })
+
+static char *number(char *str, long num, int base, int size, int precision,
+		    int type)
+{
+	/* we are called with base 8, 10 or 16, only, thus don't need "G..."  */
+	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */
+
+	char tmp[66];
+	char c, sign, locase;
+	int i;
+
+	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
+	 * produces same digits or (maybe lowercased) letters */
+	locase = (type &amp; SMALL);
+	if (type &amp; LEFT)
+		type &amp;= ~ZEROPAD;
+	if (base &lt; 2 || base &gt; 16)
+		return NULL;
+	c = (type &amp; ZEROPAD) ? '0' : ' ';
+	sign = 0;
+	if (type &amp; SIGN) {
+		if (num &lt; 0) {
+			sign = '-';
+			num = -num;
+			size--;
+		} else if (type &amp; PLUS) {
+			sign = '+';
+			size--;
+		} else if (type &amp; SPACE) {
+			sign = ' ';
+			size--;
+		}
+	}
+	if (type &amp; SPECIAL) {
+		if (base == 16)
+			size -= 2;
+		else if (base == 8)
+			size--;
+	}
+	i = 0;
+	if (num == 0)
+		tmp[i++] = '0';
+	else
+		while (num != 0)
+			tmp[i++] = (digits[__do_div(num, base)] | locase);
+	if (i &gt; precision)
+		precision = i;
+	size -= precision;
+	if (!(type &amp; (ZEROPAD + LEFT)))
+		while (size-- &gt; 0)
+			*str++ = ' ';
+	if (sign)
+		*str++ = sign;
+	if (type &amp; SPECIAL) {
+		if (base == 8) {
+			*str++ = '0';
+		} else if (base == 16) {
+			*str++ = '0';
+			*str++ = ('X' | locase);
+		}
+	}
+	if (!(type &amp; LEFT))
+		while (size-- &gt; 0)
+			*str++ = c;
+	while (i &lt; precision--)
+		*str++ = '0';
+	while (i-- &gt; 0)
+		*str++ = tmp[i];
+	while (size-- &gt; 0)
+		*str++ = ' ';
+	return str;
+}
+
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+	int len;
+	unsigned long num;
+	int i, base;
+	char *str;
+	const char *s;
+
+	int flags;		/* flags to number() */
+
+	int field_width;	/* width of output field */
+	int precision;		/* min. # of digits for integers; max
+				   number of chars for from string */
+	int qualifier;		/* 'h', 'l', or 'L' for integer fields */
+
+	for (str = buf; *fmt; ++fmt) {
+		if (*fmt != '%') {
+			*str++ = *fmt;
+			continue;
+		}
+
+		/* process flags */
+		flags = 0;
+	      repeat:
+		++fmt;		/* this also skips first '%' */
+		switch (*fmt) {
+		case '-':
+			flags |= LEFT;
+			goto repeat;
+		case '+':
+			flags |= PLUS;
+			goto repeat;
+		case ' ':
+			flags |= SPACE;
+			goto repeat;
+		case '#':
+			flags |= SPECIAL;
+			goto repeat;
+		case '0':
+			flags |= ZEROPAD;
+			goto repeat;
+		}
+
+		/* get field width */
+		field_width = -1;
+		if (isdigit(*fmt)) {
+			field_width = skip_atoi(&amp;fmt);
+		} else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			field_width = va_arg(args, int);
+			if (field_width &lt; 0) {
+				field_width = -field_width;
+				flags |= LEFT;
+			}
+		}
+
+		/* get the precision */
+		precision = -1;
+		if (*fmt == '.') {
+			++fmt;
+			if (isdigit(*fmt)) {
+				precision = skip_atoi(&amp;fmt);
+			} else if (*fmt == '*') {
+				++fmt;
+				/* it's the next argument */
+				precision = va_arg(args, int);
+			}
+			if (precision &lt; 0)
+				precision = 0;
+		}
+
+		/* get the conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') {
+			qualifier = *fmt;
+			++fmt;
+		}
+
+		/* default base */
+		base = 10;
+
+		switch (*fmt) {
+		case 'c':
+			if (!(flags &amp; LEFT))
+				while (--field_width &gt; 0)
+					*str++ = ' ';
+			*str++ = (unsigned char)va_arg(args, int);
+			while (--field_width &gt; 0)
+				*str++ = ' ';
+			continue;
+
+		case 's':
+			s = va_arg(args, char *);
+			len = strnlen(s, precision);
+
+			if (!(flags &amp; LEFT))
+				while (len &lt; field_width--)
+					*str++ = ' ';
+			for (i = 0; i &lt; len; ++i)
+				*str++ = *s++;
+			while (len &lt; field_width--)
+				*str++ = ' ';
+			continue;
+
+		case 'p':
+			if (field_width == -1) {
+				field_width = 2 * sizeof(void *);
+				flags |= ZEROPAD;
+			}
+			str = number(str,
+				     (unsigned long)va_arg(args, void *), 16,
+				     field_width, precision, flags);
+			continue;
+
+		case 'n':
+			if (qualifier == 'l') {
+				long *ip = va_arg(args, long *);
+				*ip = (str - buf);
+			} else {
+				int *ip = va_arg(args, int *);
+				*ip = (str - buf);
+			}
+			continue;
+
+		case '%':
+			*str++ = '%';
+			continue;
+
+			/* integer number formats - set up the flags and "break" */
+		case 'o':
+			base = 8;
+			break;
+
+		case 'x':
+			flags |= SMALL;
+			fallthrough;
+		case 'X':
+			base = 16;
+			break;
+
+		case 'd':
+		case 'i':
+			flags |= SIGN;
+			fallthrough;
+		case 'u':
+			break;
+
+		default:
+			*str++ = '%';
+			if (*fmt)
+				*str++ = *fmt;
+			else
+				--fmt;
+			continue;
+		}
+		if (qualifier == 'l') {
+			num = va_arg(args, unsigned long);
+		} else if (qualifier == 'h') {
+			num = (unsigned short)va_arg(args, int);
+			if (flags &amp; SIGN)
+				num = (short)num;
+		} else if (flags &amp; SIGN) {
+			num = va_arg(args, int);
+		} else {
+			num = va_arg(args, unsigned int);
+		}
+		str = number(str, num, base, field_width, precision, flags);
+	}
+	*str = '\0';
+	return str - buf;
+}
+
+int sprintf(char *buf, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = vsprintf(buf, fmt, args);
+	va_end(args);
+	return i;
+}</pre><hr><pre>commit fd0528a24958b7e8d55669cf50749776308d4c5a
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:06:55 2020 -0400

    efi/libstub: Buffer output of efi_puts
    
    Use a buffer to convert the string to UTF-16. This will reduce the
    number of firmware calls required to print the string from one per
    character to one per string in most cases.
    
    Cast the input char to unsigned char before converting to efi_char16_t
    to avoid sign-extension in case there are any non-ASCII characters in
    the input.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-4-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index c6d7ef35e9f7..3cf506ab9ead 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -8,6 +8,7 @@
  */
 
 #include &lt;linux/efi.h&gt;
+#include &lt;linux/kernel.h&gt;
 #include &lt;asm/efi.h&gt;
 
 #include "efistub.h"
@@ -34,13 +35,19 @@ void efi_char16_puts(efi_char16_t *str)
 
 void efi_puts(const char *str)
 {
-	while (*str) {
-		efi_char16_t ch[] = { *str++, L'\0' };
+	efi_char16_t buf[128];
+	size_t pos = 0, lim = ARRAY_SIZE(buf);
 
-		if (ch[0] == L'\n')
-			efi_char16_puts(L"\r\n");
-		else
-			efi_char16_puts(ch);
+	while (*str) {
+		if (*str == '\n')
+			buf[pos++] = L'\r';
+		/* Cast to unsigned char to avoid sign-extension */
+		buf[pos++] = (unsigned char)(*str++);
+		if (*str == '\0' || pos &gt;= lim - 2) {
+			buf[pos] = L'\0';
+			efi_char16_puts(buf);
+			pos = 0;
+		}
 	}
 }
 </pre><hr><pre>commit cb8c90a08c7f2f761919190093fca0611c1cece4
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:06:54 2020 -0400

    efi/libstub: Rename efi_[char16_]printk to efi_[char16_]puts
    
    These functions do not support formatting, unlike printk. Rename them to
    puts to make that clear.
    
    Move the implementations of these two functions next to each other.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-3-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/efi-stub-helper.c b/drivers/firmware/efi/libstub/efi-stub-helper.c
index 2927f3d30344..c6d7ef35e9f7 100644
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@ -26,15 +26,21 @@ bool __pure __efi_soft_reserve_enabled(void)
 	return !efi_nosoftreserve;
 }
 
-void efi_printk(const char *str)
+void efi_char16_puts(efi_char16_t *str)
+{
+	efi_call_proto(efi_table_attr(efi_system_table, con_out),
+		       output_string, str);
+}
+
+void efi_puts(const char *str)
 {
 	while (*str) {
 		efi_char16_t ch[] = { *str++, L'\0' };
 
 		if (ch[0] == L'\n')
-			efi_char16_printk(L"\r\n");
+			efi_char16_puts(L"\r\n");
 		else
-			efi_char16_printk(ch);
+			efi_char16_puts(ch);
 	}
 }
 
@@ -279,12 +285,6 @@ void *get_efi_config_table(efi_guid_t guid)
 	return NULL;
 }
 
-void efi_char16_printk(efi_char16_t *str)
-{
-	efi_call_proto(efi_table_attr(efi_system_table, con_out),
-		       output_string, str);
-}
-
 /*
  * The LINUX_EFI_INITRD_MEDIA_GUID vendor media device path below provides a way
  * for the firmware or bootloader to expose the initrd data directly to the stub
diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 998924916b03..4f57611a65f2 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -49,10 +49,10 @@ extern const efi_system_table_t *efi_system_table;
 #endif
 
 #define efi_info(msg)		do {			\
-	if (!efi_quiet) efi_printk("EFI stub: "msg);	\
+	if (!efi_quiet) efi_puts("EFI stub: "msg);	\
 } while (0)
 
-#define efi_err(msg) efi_printk("EFI stub: ERROR: "msg)
+#define efi_err(msg) efi_puts("EFI stub: ERROR: "msg)
 
 /* Helper macros for the usual case of using simple C variables: */
 #ifndef fdt_setprop_inplace_var
@@ -605,8 +605,6 @@ efi_status_t efi_exit_boot_services(void *handle,
 				    void *priv,
 				    efi_exit_boot_map_processing priv_func);
 
-void efi_char16_printk(efi_char16_t *);
-
 efi_status_t allocate_new_fdt_and_exit_boot(void *handle,
 					    unsigned long *new_fdt_addr,
 					    unsigned long max_addr,
@@ -630,7 +628,9 @@ efi_status_t check_platform_features(void);
 
 void *get_efi_config_table(efi_guid_t guid);
 
-void efi_printk(const char *str);
+/* NOTE: These functions do not print a trailing newline after the string */
+void efi_char16_puts(efi_char16_t *);
+void efi_puts(const char *str);
 
 void efi_free(unsigned long size, unsigned long addr);
 
diff --git a/drivers/firmware/efi/libstub/file.c b/drivers/firmware/efi/libstub/file.c
index cc177152d0df..933536c5236a 100644
--- a/drivers/firmware/efi/libstub/file.c
+++ b/drivers/firmware/efi/libstub/file.c
@@ -47,8 +47,8 @@ static efi_status_t efi_open_file(efi_file_protocol_t *volume,
 	status = volume-&gt;open(volume, &amp;fh, fi-&gt;filename, EFI_FILE_MODE_READ, 0);
 	if (status != EFI_SUCCESS) {
 		efi_err("Failed to open file: ");
-		efi_char16_printk(fi-&gt;filename);
-		efi_printk("\n");
+		efi_char16_puts(fi-&gt;filename);
+		efi_puts("\n");
 		return status;
 	}
 </pre><hr><pre>commit 0b76735380224497e1c78a1bed606cbda83e3427
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon May 18 15:06:53 2020 -0400

    efi/libstub: Include dependencies of efistub.h
    
    Add #include directives for include files that efistub.h depends on,
    instead of relying on them having been included by the C source files
    prior to efistub.h.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Link: https://lore.kernel.org/r/20200518190716.751506-2-nivedita@alum.mit.edu
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/efistub.h b/drivers/firmware/efi/libstub/efistub.h
index 15d0b6f3f6c6..998924916b03 100644
--- a/drivers/firmware/efi/libstub/efistub.h
+++ b/drivers/firmware/efi/libstub/efistub.h
@@ -3,6 +3,11 @@
 #ifndef _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 #define _DRIVERS_FIRMWARE_EFI_EFISTUB_H
 
+#include &lt;linux/efi.h&gt;
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/types.h&gt;
+#include &lt;asm/efi.h&gt;
+
 /* error code which can't be mistaken for valid address */
 #define EFI_ERROR	(~0UL)
 </pre>
    <div class="pagination">
        <a href='1_122.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><span>[123]</span><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_124.html'>Next&gt;&gt;</a>
    <div>
</body>
