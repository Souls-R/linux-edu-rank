<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Minnesota</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Minnesota</h1>
    <div class="pagination">
        <a href='7_25.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><span>[26]</span><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_27.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 2d822f2dbab7f4c820f72eb8570aacf3f35855bd
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Tue Dec 25 20:55:37 2018 -0600

    net: (cpts) fix a missing check of clk_prepare
    
    clk_prepare() could fail, so let's check its status, and if it fails,
    return its error code upstream.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
index 054f78295d1d..2a9ba4acd7fa 100644
--- a/drivers/net/ethernet/ti/cpts.c
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -590,7 +590,9 @@ struct cpts *cpts_create(struct device *dev, void __iomem *regs,
 		return ERR_CAST(cpts-&gt;refclk);
 	}
 
-	clk_prepare(cpts-&gt;refclk);
+	ret = clk_prepare(cpts-&gt;refclk);
+	if (ret)
+		return ERR_PTR(ret);
 
 	cpts-&gt;cc.read = cpts_systim_read;
 	cpts-&gt;cc.mask = CLOCKSOURCE_MASK(32);</pre><hr><pre>commit 26fd962bde0b15e54234fe762d86bc0349df1de4
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Tue Dec 25 01:56:14 2018 -0600

    niu: fix missing checks of niu_pci_eeprom_read
    
    niu_pci_eeprom_read() may fail, so we should check its return value
    before using the read data.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Acked-by: Shannon Nelson &lt;shannon.lee.nelson@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c
index 9319d84bf49f..d84501441edd 100644
--- a/drivers/net/ethernet/sun/niu.c
+++ b/drivers/net/ethernet/sun/niu.c
@@ -8100,6 +8100,8 @@ static int niu_pci_vpd_scan_props(struct niu *np, u32 start, u32 end)
 		start += 3;
 
 		prop_len = niu_pci_eeprom_read(np, start + 4);
+		if (prop_len &lt; 0)
+			return prop_len;
 		err = niu_pci_vpd_get_propname(np, start + 5, namebuf, 64);
 		if (err &lt; 0)
 			return err;
@@ -8144,8 +8146,12 @@ static int niu_pci_vpd_scan_props(struct niu *np, u32 start, u32 end)
 			netif_printk(np, probe, KERN_DEBUG, np-&gt;dev,
 				     "VPD_SCAN: Reading in property [%s] len[%d]\n",
 				     namebuf, prop_len);
-			for (i = 0; i &lt; prop_len; i++)
-				*prop_buf++ = niu_pci_eeprom_read(np, off + i);
+			for (i = 0; i &lt; prop_len; i++) {
+				err = niu_pci_eeprom_read(np, off + i);
+				if (err &gt;= 0)
+					*prop_buf = err;
+				++prop_buf;
+			}
 		}
 
 		start += len;</pre><hr><pre>commit ca19fcb6285bfce1601c073bf4b9d2942e2df8d9
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Mon Dec 24 15:21:21 2018 -0600

    net: chelsio: Add a missing check on cudg_get_buffer
    
    cudbg_collect_hw_sched() could fail when the function cudg_get_buffer()
    returns an error. The fix adds a check to the latter function returning
    error on failure
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
index 7c49681407ad..127b1f624413 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
@@ -1229,6 +1229,10 @@ int cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,
 
 	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_hw_sched),
 			    &amp;temp_buff);
+
+	if (rc)
+		return rc;
+
 	hw_sched_buff = (struct cudbg_hw_sched *)temp_buff.data;
 	hw_sched_buff-&gt;map = t4_read_reg(padap, TP_TX_MOD_QUEUE_REQ_MAP_A);
 	hw_sched_buff-&gt;mode = TIMERMODE_G(t4_read_reg(padap, TP_MOD_CONFIG_A));</pre><hr><pre>commit f0fb9b288d0a7e9cc324ae362e2dfd2cc2217ded
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Mon Dec 24 10:30:17 2018 -0600

    ipv6/route: Add a missing check on proc_dointvec
    
    While flushing the cache via  ipv6_sysctl_rtcache_flush(), the call
    to proc_dointvec() may fail. The fix adds a check that returns the
    error, on failure.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 194bc162866d..a94e0b02a8ac 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -5054,12 +5054,16 @@ int ipv6_sysctl_rtcache_flush(struct ctl_table *ctl, int write,
 {
 	struct net *net;
 	int delay;
+	int ret;
 	if (!write)
 		return -EINVAL;
 
 	net = (struct net *)ctl-&gt;extra1;
 	delay = net-&gt;ipv6.sysctl.flush_delay;
-	proc_dointvec(ctl, write, buffer, lenp, ppos);
+	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
+	if (ret)
+		return ret;
+
 	fib6_run_gc(delay &lt;= 0 ? 0 : (unsigned long)delay, net, delay &gt; 0);
 	return 0;
 }</pre><hr><pre>commit 0eb987c874dc93f9c9d85a6465dbde20fdd3884c
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Sun Dec 23 19:42:38 2018 -0600

    net/net_namespace: Check the return value of register_pernet_subsys()
    
    In net_ns_init(), register_pernet_subsys() could fail while registering
    network namespace subsystems. The fix checks the return value and
    sends a panic() on failure.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Reviewed-by: Kirill Tkhai &lt;ktkhai@virtuozzo.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/core/net_namespace.c b/net/core/net_namespace.c
index fefe72774aeb..af8849a7a9c3 100644
--- a/net/core/net_namespace.c
+++ b/net/core/net_namespace.c
@@ -917,7 +917,8 @@ static int __init net_ns_init(void)
 	init_net_initialized = true;
 	up_write(&amp;pernet_ops_rwsem);
 
-	register_pernet_subsys(&amp;net_ns_ops);
+	if (register_pernet_subsys(&amp;net_ns_ops))
+		panic("Could not register network namespace subsystems");
 
 	rtnl_register(PF_UNSPEC, RTM_NEWNSID, rtnl_net_newid, NULL,
 		      RTNL_FLAG_DOIT_UNLOCKED);</pre><hr><pre>commit 89dfd0083751d00d5d7ead36f6d8b045bf89c5e1
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Sun Dec 23 18:54:53 2018 -0600

    net/netlink_compat: Fix a missing check of nla_parse_nested
    
    In tipc_nl_compat_sk_dump(), if nla_parse_nested() fails, it could return
    an error. To be consistent with other invocations of the function call,
    on error, the fix passes the return value upstream.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/tipc/netlink_compat.c b/net/tipc/netlink_compat.c
index 6376467e78f8..21f6ccc89401 100644
--- a/net/tipc/netlink_compat.c
+++ b/net/tipc/netlink_compat.c
@@ -951,8 +951,11 @@ static int tipc_nl_compat_sk_dump(struct tipc_nl_compat_msg *msg,
 		u32 node;
 		struct nlattr *con[TIPC_NLA_CON_MAX + 1];
 
-		nla_parse_nested(con, TIPC_NLA_CON_MAX,
-				 sock[TIPC_NLA_SOCK_CON], NULL, NULL);
+		err = nla_parse_nested(con, TIPC_NLA_CON_MAX,
+				       sock[TIPC_NLA_SOCK_CON], NULL, NULL);
+
+		if (err)
+			return err;
 
 		node = nla_get_u32(con[TIPC_NLA_CON_NODE]);
 		tipc_tlv_sprintf(msg-&gt;rep, "  connected to &lt;%u.%u.%u:%u&gt;",</pre><hr><pre>commit 9aa3aa15f4c2f74f47afd6c5db4b420fadf3f315
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Fri Dec 21 13:10:39 2018 -0600

    hwmon: (lm80) fix a missing check of bus read in lm80 probe
    
    In lm80_probe(), if lm80_read_value() fails, it returns a negative
    error number which is stored to data-&gt;fan[f_min] and will be further
    used. We should avoid using the data if the read fails.
    
    The fix checks if lm80_read_value() fails, and if so, returns with the
    error number.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Guenter Roeck &lt;linux@roeck-us.net&gt;

diff --git a/drivers/hwmon/lm80.c b/drivers/hwmon/lm80.c
index 04f9df0d2341..0e30fa00204c 100644
--- a/drivers/hwmon/lm80.c
+++ b/drivers/hwmon/lm80.c
@@ -628,6 +628,7 @@ static int lm80_probe(struct i2c_client *client,
 	struct device *dev = &amp;client-&gt;dev;
 	struct device *hwmon_dev;
 	struct lm80_data *data;
+	int rv;
 
 	data = devm_kzalloc(dev, sizeof(struct lm80_data), GFP_KERNEL);
 	if (!data)
@@ -640,8 +641,14 @@ static int lm80_probe(struct i2c_client *client,
 	lm80_init_client(client);
 
 	/* A few vars need to be filled upon startup */
-	data-&gt;fan[f_min][0] = lm80_read_value(client, LM80_REG_FAN_MIN(1));
-	data-&gt;fan[f_min][1] = lm80_read_value(client, LM80_REG_FAN_MIN(2));
+	rv = lm80_read_value(client, LM80_REG_FAN_MIN(1));
+	if (rv &lt; 0)
+		return rv;
+	data-&gt;fan[f_min][0] = rv;
+	rv = lm80_read_value(client, LM80_REG_FAN_MIN(2));
+	if (rv &lt; 0)
+		return rv;
+	data-&gt;fan[f_min][1] = rv;
 
 	hwmon_dev = devm_hwmon_device_register_with_groups(dev, client-&gt;name,
 							   data, lm80_groups);</pre><hr><pre>commit c9c63915519b1def7043b184680f33c24cd49d7b
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Fri Dec 21 13:01:33 2018 -0600

    hwmon: (lm80) fix a missing check of the status of SMBus read
    
    If lm80_read_value() fails, it returns a negative number instead of the
    correct read data. Therefore, we should avoid using the data if it
    fails.
    
    The fix checks if lm80_read_value() fails, and if so, returns with the
    error number.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    [groeck: One variable for return values is enough]
    Signed-off-by: Guenter Roeck &lt;linux@roeck-us.net&gt;

diff --git a/drivers/hwmon/lm80.c b/drivers/hwmon/lm80.c
index 08e3945a6fbf..04f9df0d2341 100644
--- a/drivers/hwmon/lm80.c
+++ b/drivers/hwmon/lm80.c
@@ -360,9 +360,11 @@ static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
 	struct i2c_client *client = data-&gt;client;
 	unsigned long min, val;
 	u8 reg;
-	int err = kstrtoul(buf, 10, &amp;val);
-	if (err &lt; 0)
-		return err;
+	int rv;
+
+	rv = kstrtoul(buf, 10, &amp;val);
+	if (rv &lt; 0)
+		return rv;
 
 	/* Save fan_min */
 	mutex_lock(&amp;data-&gt;update_lock);
@@ -390,8 +392,11 @@ static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	reg = (lm80_read_value(client, LM80_REG_FANDIV) &amp;
-	       ~(3 &lt;&lt; (2 * (nr + 1)))) | (data-&gt;fan_div[nr] &lt;&lt; (2 * (nr + 1)));
+	rv = lm80_read_value(client, LM80_REG_FANDIV);
+	if (rv &lt; 0)
+		return rv;
+	reg = (rv &amp; ~(3 &lt;&lt; (2 * (nr + 1))))
+	    | (data-&gt;fan_div[nr] &lt;&lt; (2 * (nr + 1)));
 	lm80_write_value(client, LM80_REG_FANDIV, reg);
 
 	/* Restore fan_min */</pre><hr><pre>commit d134e486e831defd26130770181f01dfc6195f7d
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Fri Dec 21 00:22:32 2018 -0600

    net: netxen: fix a missing check and an uninitialized use
    
    When netxen_rom_fast_read() fails, "bios" is left uninitialized and may
    contain random value, thus should not be used.
    
    The fix ensures that if netxen_rom_fast_read() fails, we return "-EIO".
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c b/drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c
index 0ea141ece19e..6547a9dd5935 100644
--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c
+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_init.c
@@ -1125,7 +1125,8 @@ netxen_validate_firmware(struct netxen_adapter *adapter)
 		return -EINVAL;
 	}
 	val = nx_get_bios_version(adapter);
-	netxen_rom_fast_read(adapter, NX_BIOS_VERSION_OFFSET, (int *)&amp;bios);
+	if (netxen_rom_fast_read(adapter, NX_BIOS_VERSION_OFFSET, (int *)&amp;bios))
+		return -EIO;
 	if ((__force u32)val != bios) {
 		dev_err(&amp;pdev-&gt;dev, "%s: firmware bios is incompatible\n",
 				fw_name[fw_type]);</pre><hr><pre>commit cd07e3701fa6a4c68f8493ee1d12caa18d46ec6a
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Fri Dec 21 00:29:19 2018 -0600

    regulator: tps65910: fix a missing check of return value
    
    tps65910_reg_set_bits() may fail. The fix checks if it fails, and if so,
    returns with its error code.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/drivers/regulator/tps65910-regulator.c b/drivers/regulator/tps65910-regulator.c
index 02ccdaa226a7..5ebb6ee73f07 100644
--- a/drivers/regulator/tps65910-regulator.c
+++ b/drivers/regulator/tps65910-regulator.c
@@ -1102,8 +1102,10 @@ static int tps65910_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, pmic);
 
 	/* Give control of all register to control port */
-	tps65910_reg_set_bits(pmic-&gt;mfd, TPS65910_DEVCTRL,
+	err = tps65910_reg_set_bits(pmic-&gt;mfd, TPS65910_DEVCTRL,
 				DEVCTRL_SR_CTL_I2C_SEL_MASK);
+	if (err &lt; 0)
+		return err;
 
 	switch (tps65910_chip_id(tps65910)) {
 	case TPS65910:</pre>
    <div class="pagination">
        <a href='7_25.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><span>[26]</span><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_27.html'>Next&gt;&gt;</a>
    <div>
</body>
