<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_104.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><span>[105]</span><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_106.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 67f5dde3d4961032aeeecaf0d1c7a9232bef3f44
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 24 18:23:23 2007 -0400

    USB: Fix a bug in usb_start_wait_urb
    
    This patch (as941) fixes a bug recently added to the USB synchronous
    API.  The status of a completed URB must be preserved separately
    across a completion callback.  Also, the actual_length value isn't
    available until after the URB has fully completed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index ad4b956380d2..b6bd05e3d439 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -18,9 +18,17 @@
 #include "hcd.h"	/* for usbcore internals */
 #include "usb.h"
 
+struct api_context {
+	struct completion	done;
+	int			status;
+};
+
 static void usb_api_blocking_completion(struct urb *urb)
 {
-	complete((struct completion *)urb-&gt;context);
+	struct api_context *ctx = urb-&gt;context;
+
+	ctx-&gt;status = urb-&gt;status;
+	complete(&amp;ctx-&gt;done);
 }
 
 
@@ -32,20 +40,21 @@ static void usb_api_blocking_completion(struct urb *urb)
  */
 static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)
 { 
-	struct completion done;
+	struct api_context ctx;
 	unsigned long expire;
 	int retval;
-	int status = urb-&gt;status;
 
-	init_completion(&amp;done); 	
-	urb-&gt;context = &amp;done;
+	init_completion(&amp;ctx.done);
+	urb-&gt;context = &amp;ctx;
 	urb-&gt;actual_length = 0;
 	retval = usb_submit_urb(urb, GFP_NOIO);
 	if (unlikely(retval))
 		goto out;
 
 	expire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;
-	if (!wait_for_completion_timeout(&amp;done, expire)) {
+	if (!wait_for_completion_timeout(&amp;ctx.done, expire)) {
+		usb_kill_urb(urb);
+		retval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);
 
 		dev_dbg(&amp;urb-&gt;dev-&gt;dev,
 			"%s timed out on ep%d%s len=%d/%d\n",
@@ -54,11 +63,8 @@ static int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)
 			usb_pipein(urb-&gt;pipe) ? "in" : "out",
 			urb-&gt;actual_length,
 			urb-&gt;transfer_buffer_length);
-
-		usb_kill_urb(urb);
-		retval = status == -ENOENT ? -ETIMEDOUT : status;
 	} else
-		retval = status;
+		retval = ctx.status;
 out:
 	if (actual_length)
 		*actual_length = urb-&gt;actual_length;</pre><hr><pre>commit bb1995d52b05f7e671914454d0ae57bd4170ef47
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 21 17:10:42 2007 +0200

    x86: Make Alt-SysRq-p display the debug register contents
    
    This patch (as921) adds code to the show_regs() routine in i386 and x86_64
    to print the contents of the debug registers along with all the others.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Roland McGrath &lt;roland@redhat.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Andi Kleen &lt;ak@suse.de&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/arch/i386/kernel/process.c b/arch/i386/kernel/process.c
index 6c49acb96982..84664710b784 100644
--- a/arch/i386/kernel/process.c
+++ b/arch/i386/kernel/process.c
@@ -300,6 +300,7 @@ early_param("idle", idle_setup);
 void show_regs(struct pt_regs * regs)
 {
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L;
+	unsigned long d0, d1, d2, d3, d6, d7;
 
 	printk("\n");
 	printk("Pid: %d, comm: %20s\n", current-&gt;pid, current-&gt;comm);
@@ -324,6 +325,17 @@ void show_regs(struct pt_regs * regs)
 	cr3 = read_cr3();
 	cr4 = read_cr4_safe();
 	printk("CR0: %08lx CR2: %08lx CR3: %08lx CR4: %08lx\n", cr0, cr2, cr3, cr4);
+
+	get_debugreg(d0, 0);
+	get_debugreg(d1, 1);
+	get_debugreg(d2, 2);
+	get_debugreg(d3, 3);
+	printk("DR0: %08lx DR1: %08lx DR2: %08lx DR3: %08lx\n",
+			d0, d1, d2, d3);
+	get_debugreg(d6, 6);
+	get_debugreg(d7, 7);
+	printk("DR6: %08lx DR7: %08lx\n", d6, d7);
+
 	show_trace(NULL, regs, &amp;regs-&gt;esp);
 }
 
diff --git a/arch/x86_64/kernel/process.c b/arch/x86_64/kernel/process.c
index 180f4c0fcbc4..bbfc957f045f 100644
--- a/arch/x86_64/kernel/process.c
+++ b/arch/x86_64/kernel/process.c
@@ -306,6 +306,7 @@ early_param("idle", idle_setup);
 void __show_regs(struct pt_regs * regs)
 {
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L, fs, gs, shadowgs;
+	unsigned long d0, d1, d2, d3, d6, d7;
 	unsigned int fsindex,gsindex;
 	unsigned int ds,cs,es; 
 
@@ -350,6 +351,15 @@ void __show_regs(struct pt_regs * regs)
 	       fs,fsindex,gs,gsindex,shadowgs); 
 	printk("CS:  %04x DS: %04x ES: %04x CR0: %016lx\n", cs, ds, es, cr0); 
 	printk("CR2: %016lx CR3: %016lx CR4: %016lx\n", cr2, cr3, cr4);
+
+	get_debugreg(d0, 0);
+	get_debugreg(d1, 1);
+	get_debugreg(d2, 2);
+	printk("DR0: %016lx DR1: %016lx DR2: %016lx\n", d0, d1, d2);
+	get_debugreg(d3, 3);
+	get_debugreg(d6, 6);
+	get_debugreg(d7, 7);
+	printk("DR3: %016lx DR6: %016lx DR7: %016lx\n", d3, d6, d7);
 }
 
 void show_regs(struct pt_regs *regs)</pre><hr><pre>commit 809a58b896ba07e771adc76a47c83e4ca1969da8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 18 12:14:24 2007 -0400

    USB: change name of spinlock in hcd.c
    
    This patch (as940 renames hcd_data_lock in hcd.c to hcd_urb_list_lock,
    which is more descriptive of the lock's job.  It also introduces a
    convenient inline routine for testing whether a particular USB device
    is a root hub.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 032b118c2883..42ef1d5f6c8a 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -99,12 +99,17 @@ EXPORT_SYMBOL_GPL (usb_bus_list_lock);
 /* used for controlling access to virtual root hubs */
 static DEFINE_SPINLOCK(hcd_root_hub_lock);
 
-/* used when updating hcd data */
-static DEFINE_SPINLOCK(hcd_data_lock);
+/* used when updating an endpoint's URB list */
+static DEFINE_SPINLOCK(hcd_urb_list_lock);
 
 /* wait queue for synchronous unlinks */
 DECLARE_WAIT_QUEUE_HEAD(usb_kill_urb_queue);
 
+static inline int is_root_hub(struct usb_device *udev)
+{
+	return (udev-&gt;parent == NULL);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /*
@@ -906,14 +911,13 @@ EXPORT_SYMBOL (usb_calc_bus_time);
 static void urb_unlink(struct usb_hcd *hcd, struct urb *urb)
 {
 	unsigned long		flags;
-	int at_root_hub = (urb-&gt;dev == hcd-&gt;self.root_hub);
 
 	/* clear all state linking urb to this dev (and hcd) */
-	spin_lock_irqsave (&amp;hcd_data_lock, flags);
+	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
 	list_del_init (&amp;urb-&gt;urb_list);
-	spin_unlock_irqrestore (&amp;hcd_data_lock, flags);
+	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 
-	if (hcd-&gt;self.uses_dma &amp;&amp; !at_root_hub) {
+	if (hcd-&gt;self.uses_dma &amp;&amp; !is_root_hub(urb-&gt;dev)) {
 		if (usb_pipecontrol (urb-&gt;pipe)
 			&amp;&amp; !(urb-&gt;transfer_flags &amp; URB_NO_SETUP_DMA_MAP))
 			dma_unmap_single (hcd-&gt;self.controller, urb-&gt;setup_dma,
@@ -955,7 +959,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 
 	// FIXME:  verify that quiescing hc works right (RH cleans up)
 
-	spin_lock_irqsave (&amp;hcd_data_lock, flags);
+	spin_lock_irqsave(&amp;hcd_urb_list_lock, flags);
 	ep = (usb_pipein(urb-&gt;pipe) ? urb-&gt;dev-&gt;ep_in : urb-&gt;dev-&gt;ep_out)
 			[usb_pipeendpoint(urb-&gt;pipe)];
 	if (unlikely (!ep))
@@ -972,7 +976,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 		status = -ESHUTDOWN;
 		break;
 	}
-	spin_unlock_irqrestore (&amp;hcd_data_lock, flags);
+	spin_unlock_irqrestore(&amp;hcd_urb_list_lock, flags);
 	if (status) {
 		INIT_LIST_HEAD (&amp;urb-&gt;urb_list);
 		usbmon_urb_submit_error(&amp;hcd-&gt;self, urb, status);
@@ -986,7 +990,7 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 	urb = usb_get_urb (urb);
 	atomic_inc (&amp;urb-&gt;use_count);
 
-	if (urb-&gt;dev == hcd-&gt;self.root_hub) {
+	if (is_root_hub(urb-&gt;dev)) {
 		/* NOTE:  requirement on hub callers (usbfs and the hub
 		 * driver, for now) that URBs' urb-&gt;transfer_buffer be
 		 * valid and usb_buffer_{sync,unmap}() not be needed, since
@@ -1043,7 +1047,7 @@ unlink1 (struct usb_hcd *hcd, struct urb *urb)
 {
 	int		value;
 
-	if (urb-&gt;dev == hcd-&gt;self.root_hub)
+	if (is_root_hub(urb-&gt;dev))
 		value = usb_rh_urb_dequeue (hcd, urb);
 	else {
 
@@ -1091,11 +1095,11 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	 * that it was submitted.  But as a rule it can't know whether or
 	 * not it's already been unlinked ... so we respect the reversed
 	 * lock sequence needed for the usb_hcd_giveback_urb() code paths
-	 * (urb lock, then hcd_data_lock) in case some other CPU is now
+	 * (urb lock, then hcd_urb_list_lock) in case some other CPU is now
 	 * unlinking it.
 	 */
 	spin_lock_irqsave (&amp;urb-&gt;lock, flags);
-	spin_lock (&amp;hcd_data_lock);
+	spin_lock(&amp;hcd_urb_list_lock);
 
 	sys = &amp;urb-&gt;dev-&gt;dev;
 	hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
@@ -1127,17 +1131,16 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	 * finish unlinking the initial failed usb_set_address()
 	 * or device descriptor fetch.
 	 */
-	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags)
-	    &amp;&amp; hcd-&gt;self.root_hub != urb-&gt;dev) {
+	if (!test_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags) &amp;&amp;
+			!is_root_hub(urb-&gt;dev)) {
 		dev_warn (hcd-&gt;self.controller, "Unlink after no-IRQ?  "
-			"Controller is probably using the wrong IRQ."
-			"\n");
+			"Controller is probably using the wrong IRQ.\n");
 		set_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 	}
 
 	urb-&gt;status = status;
 
-	spin_unlock (&amp;hcd_data_lock);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
 
 	retval = unlink1 (hcd, urb);
@@ -1146,7 +1149,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	return retval;
 
 done:
-	spin_unlock (&amp;hcd_data_lock);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	spin_unlock_irqrestore (&amp;urb-&gt;lock, flags);
 	if (retval != -EIDRM &amp;&amp; sys &amp;&amp; sys-&gt;driver)
 		dev_dbg (sys, "hcd_unlink_urb %p fail %d\n", urb, retval);
@@ -1203,7 +1206,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */
 rescan:
-	spin_lock (&amp;hcd_data_lock);
+	spin_lock(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
 
@@ -1211,7 +1214,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		if (urb-&gt;status != -EINPROGRESS)
 			continue;
 		usb_get_urb (urb);
-		spin_unlock (&amp;hcd_data_lock);
+		spin_unlock(&amp;hcd_urb_list_lock);
 
 		spin_lock (&amp;urb-&gt;lock);
 		tmp = urb-&gt;status;
@@ -1240,7 +1243,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 		/* list contents may have changed */
 		goto rescan;
 	}
-	spin_unlock (&amp;hcd_data_lock);
+	spin_unlock(&amp;hcd_urb_list_lock);
 	local_irq_enable ();
 
 	/* synchronize with the hardware, so old configuration state
@@ -1257,7 +1260,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	 * endpoint_disable methods.
 	 */
 	while (!list_empty (&amp;ep-&gt;urb_list)) {
-		spin_lock_irq (&amp;hcd_data_lock);
+		spin_lock_irq(&amp;hcd_urb_list_lock);
 
 		/* The list may have changed while we acquired the spinlock */
 		urb = NULL;
@@ -1266,7 +1269,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 					urb_list);
 			usb_get_urb (urb);
 		}
-		spin_unlock_irq (&amp;hcd_data_lock);
+		spin_unlock_irq(&amp;hcd_urb_list_lock);
 
 		if (urb) {
 			usb_kill_urb (urb);</pre><hr><pre>commit 32aca5600526189dd876e6c92b64fd88cf052c8d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 18 12:08:02 2007 -0400

    USB: move routines in hcd.c
    
    This patch (as939) moves a couple of routine in hcd.c around.  The
    purpose is to put all the general URB- and endpoint-related routines
    (submit, unlink, giveback, and disable) together in one spot.
    
    There are no functional changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 963520fbef90..032b118c2883 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1033,18 +1033,6 @@ int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)
 
 /*-------------------------------------------------------------------------*/
 
-/* called in any context */
-int usb_hcd_get_frame_number (struct usb_device *udev)
-{
-	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
-
-	if (!HC_IS_RUNNING (hcd-&gt;state))
-		return -ESHUTDOWN;
-	return hcd-&gt;driver-&gt;get_frame_number (hcd);
-}
-
-/*-------------------------------------------------------------------------*/
-
 /* this makes the hcd giveback() the urb more quickly, by kicking it
  * off hardware queues (which may take a while) and returning it as
  * soon as practical.  we've already set up the urb's return status,
@@ -1167,6 +1155,35 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 
 /*-------------------------------------------------------------------------*/
 
+/**
+ * usb_hcd_giveback_urb - return URB from HCD to device driver
+ * @hcd: host controller returning the URB
+ * @urb: urb being returned to the USB device driver.
+ * Context: in_interrupt()
+ *
+ * This hands the URB from HCD to its USB device driver, using its
+ * completion function.  The HCD has freed all per-urb resources
+ * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
+ * the device driver won't cause problems if it frees, modifies,
+ * or resubmits this URB.
+ */
+void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
+{
+	urb_unlink(hcd, urb);
+	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
+	usb_unanchor_urb(urb);
+
+	/* pass ownership to the completion handler */
+	urb-&gt;complete (urb);
+	atomic_dec (&amp;urb-&gt;use_count);
+	if (unlikely (urb-&gt;reject))
+		wake_up (&amp;usb_kill_urb_queue);
+	usb_put_urb (urb);
+}
+EXPORT_SYMBOL (usb_hcd_giveback_urb);
+
+/*-------------------------------------------------------------------------*/
+
 /* disables the endpoint: cancels any pending urbs, then synchronizes with
  * the hcd to make sure all endpoint state is gone from hardware, and then
  * waits until the endpoint's queue is completely drained. use for
@@ -1260,6 +1277,18 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 /*-------------------------------------------------------------------------*/
 
+/* called in any context */
+int usb_hcd_get_frame_number (struct usb_device *udev)
+{
+	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
+
+	if (!HC_IS_RUNNING (hcd-&gt;state))
+		return -ESHUTDOWN;
+	return hcd-&gt;driver-&gt;get_frame_number (hcd);
+}
+
+/*-------------------------------------------------------------------------*/
+
 #ifdef	CONFIG_PM
 
 int hcd_bus_suspend(struct usb_device *rhdev)
@@ -1394,35 +1423,6 @@ EXPORT_SYMBOL (usb_bus_start_enum);
 
 /*-------------------------------------------------------------------------*/
 
-/**
- * usb_hcd_giveback_urb - return URB from HCD to device driver
- * @hcd: host controller returning the URB
- * @urb: urb being returned to the USB device driver.
- * Context: in_interrupt()
- *
- * This hands the URB from HCD to its USB device driver, using its
- * completion function.  The HCD has freed all per-urb resources
- * (and is done using urb-&gt;hcpriv).  It also released all HCD locks;
- * the device driver won't cause problems if it frees, modifies,
- * or resubmits this URB.
- */
-void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
-{
-	urb_unlink(hcd, urb);
-	usbmon_urb_complete (&amp;hcd-&gt;self, urb);
-	usb_unanchor_urb(urb);
-
-	/* pass ownership to the completion handler */
-	urb-&gt;complete (urb);
-	atomic_dec (&amp;urb-&gt;use_count);
-	if (unlikely (urb-&gt;reject))
-		wake_up (&amp;usb_kill_urb_queue);
-	usb_put_urb (urb);
-}
-EXPORT_SYMBOL (usb_hcd_giveback_urb);
-
-/*-------------------------------------------------------------------------*/
-
 /**
  * usb_hcd_irq - hook IRQs to HCD framework (bus glue)
  * @irq: the IRQ being raised</pre><hr><pre>commit d8fbba2f59c0c131a1babf5a66f003faee02e01a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 16 15:30:20 2007 -0400

    USB: usb-storage: unusual_devs entry for Nikon D100
    
    This patch (as938) adds an unusual_devs entry for the Nikon DSC D100.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 26fd196869b9..a624e72f81dc 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -313,6 +313,13 @@ UNUSUAL_DEV(  0x04b0, 0x0301, 0x0010, 0x0010,
 		US_SC_DEVICE, US_PR_DEVICE,NULL,
 		US_FL_NOT_LOCKABLE ),
 
+/* Reported by Stefan de Konink &lt;skinkie@xs4all.nl&gt; */
+UNUSUAL_DEV(  0x04b0, 0x0401, 0x0200, 0x0200,
+		"NIKON",
+		"NIKON DSC D100",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY),
+
 /* Reported by Andreas Bockhold &lt;andreas@bockionline.de&gt; */
 UNUSUAL_DEV(  0x04b0, 0x0405, 0x0100, 0x0100,
 		"NIKON",</pre><hr><pre>commit beafef072af10bc8497c9ee51ce2804aa7da26be
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 13 15:47:16 2007 -0400

    USB: documentation update for usb_unlink_urb
    
    This patch (as936) updates the kerneldoc for usb_unlink_urb.  The
    explanation of how endpoint queues are meant to work is now clearer
    and in better agreement with reality.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 52ec44b828f3..be630228461c 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -440,55 +440,57 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
  * @urb: pointer to urb describing a previously submitted request,
  *	may be NULL
  *
- * This routine cancels an in-progress request.  URBs complete only
- * once per submission, and may be canceled only once per submission.
- * Successful cancellation means the requests's completion handler will
- * be called with a status code indicating that the request has been
- * canceled (rather than any other code) and will quickly be removed
- * from host controller data structures.
- *
- * This request is always asynchronous.
- * Success is indicated by returning -EINPROGRESS,
- * at which time the URB will normally have been unlinked but not yet
- * given back to the device driver.  When it is called, the completion
- * function will see urb-&gt;status == -ECONNRESET.  Failure is indicated
- * by any other return value.  Unlinking will fail when the URB is not
- * currently "linked" (i.e., it was never submitted, or it was unlinked
- * before, or the hardware is already finished with it), even if the
- * completion handler has not yet run.
+ * This routine cancels an in-progress request.  URBs complete only once
+ * per submission, and may be canceled only once per submission.
+ * Successful cancellation means termination of @urb will be expedited
+ * and the completion handler will be called with a status code
+ * indicating that the request has been canceled (rather than any other
+ * code).
+ *
+ * This request is always asynchronous.  Success is indicated by
+ * returning -EINPROGRESS, at which time the URB will probably not yet
+ * have been given back to the device driver.  When it is eventually
+ * called, the completion function will see @urb-&gt;status == -ECONNRESET.
+ * Failure is indicated by usb_unlink_urb() returning any other value.
+ * Unlinking will fail when @urb is not currently "linked" (i.e., it was
+ * never submitted, or it was unlinked before, or the hardware is already
+ * finished with it), even if the completion handler has not yet run.
  *
  * Unlinking and Endpoint Queues:
  *
+ * [The behaviors and guarantees described below do not apply to virtual
+ * root hubs but only to endpoint queues for physical USB devices.]
+ *
  * Host Controller Drivers (HCDs) place all the URBs for a particular
  * endpoint in a queue.  Normally the queue advances as the controller
  * hardware processes each request.  But when an URB terminates with an
- * error its queue stops, at least until that URB's completion routine
- * returns.  It is guaranteed that the queue will not restart until all
- * its unlinked URBs have been fully retired, with their completion
- * routines run, even if that's not until some time after the original
- * completion handler returns.  Normally the same behavior and guarantees
- * apply when an URB terminates because it was unlinked; however if an
- * URB is unlinked before the hardware has started to execute it, then
- * its queue is not guaranteed to stop until all the preceding URBs have
- * completed.
- *
- * This means that USB device drivers can safely build deep queues for
- * large or complex transfers, and clean them up reliably after any sort
- * of aborted transfer by unlinking all pending URBs at the first fault.
- *
- * Note that an URB terminating early because a short packet was received
- * will count as an error if and only if the URB_SHORT_NOT_OK flag is set.
- * Also, that all unlinks performed in any URB completion handler must
- * be asynchronous.
- *
- * Queues for isochronous endpoints are treated differently, because they
- * advance at fixed rates.  Such queues do not stop when an URB is unlinked.
- * An unlinked URB may leave a gap in the stream of packets.  It is undefined
- * whether such gaps can be filled in.
- *
- * When a control URB terminates with an error, it is likely that the
- * status stage of the transfer will not take place, even if it is merely
- * a soft error resulting from a short-packet with URB_SHORT_NOT_OK set.
+ * error its queue generally stops (see below), at least until that URB's
+ * completion routine returns.  It is guaranteed that a stopped queue
+ * will not restart until all its unlinked URBs have been fully retired,
+ * with their completion routines run, even if that's not until some time
+ * after the original completion handler returns.  The same behavior and
+ * guarantee apply when an URB terminates because it was unlinked.
+ *
+ * Bulk and interrupt endpoint queues are guaranteed to stop whenever an
+ * URB terminates with any sort of error, including -ECONNRESET, -ENOENT,
+ * and -EREMOTEIO.  Control endpoint queues behave the same way except
+ * that they are not guaranteed to stop for -EREMOTEIO errors.  Queues
+ * for isochronous endpoints are treated differently, because they must
+ * advance at fixed rates.  Such queues do not stop when an URB
+ * encounters an error or is unlinked.  An unlinked isochronous URB may
+ * leave a gap in the stream of packets; it is undefined whether such
+ * gaps can be filled in.
+ *
+ * Note that early termination of an URB because a short packet was
+ * received will generate a -EREMOTEIO error if and only if the
+ * URB_SHORT_NOT_OK flag is set.  By setting this flag, USB device
+ * drivers can build deep queues for large or complex bulk transfers
+ * and clean them up reliably after any sort of aborted transfer by
+ * unlinking all pending URBs at the first fault.
+ *
+ * When a control URB terminates with an error other than -EREMOTEIO, it
+ * is quite likely that the status stage of the transfer will not take
+ * place.
  */
 int usb_unlink_urb(struct urb *urb)
 {</pre><hr><pre>commit e7e7c360fb07020b24652843aec442325baad0ce
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 13 15:46:29 2007 -0400

    UHCI: short control URBs get a status stage
    
    It has recently been pointed out that short control transfers should
    have a status stage, even if they generate an error because
    URB_SHORT_NOT_OK was set.  This patch (as935) changes uhci-hcd to
    enable the status stage when this happens.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 4aed305982ec..3bb908ca38e9 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -827,8 +827,10 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * If direction is "send", change the packet ID from SETUP (0x2D)
 	 * to OUT (0xE1).  Else change it from SETUP to IN (0x69) and
 	 * set Short Packet Detect (SPD) for all data packets.
+	 *
+	 * 0-length transfers always get treated as "send".
 	 */
-	if (usb_pipeout(urb-&gt;pipe))
+	if (usb_pipeout(urb-&gt;pipe) || len == 0)
 		destination ^= (USB_PID_SETUP ^ USB_PID_OUT);
 	else {
 		destination ^= (USB_PID_SETUP ^ USB_PID_IN);
@@ -839,7 +841,12 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * Build the DATA TDs
 	 */
 	while (len &gt; 0) {
-		int pktsze = min(len, maxsze);
+		int pktsze = maxsze;
+
+		if (len &lt;= pktsze) {		/* The last data packet */
+			pktsze = len;
+			status &amp;= ~TD_CTRL_SPD;
+		}
 
 		td = uhci_alloc_td(uhci);
 		if (!td)
@@ -866,20 +873,10 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		goto nomem;
 	*plink = LINK_TO_TD(td);
 
-	/*
-	 * It's IN if the pipe is an output pipe or we're not expecting
-	 * data back.
-	 */
-	destination &amp;= ~TD_TOKEN_PID_MASK;
-	if (usb_pipeout(urb-&gt;pipe) || !urb-&gt;transfer_buffer_length)
-		destination |= USB_PID_IN;
-	else
-		destination |= USB_PID_OUT;
-
+	/* Change direction for the status transaction */
+	destination ^= (USB_PID_IN ^ USB_PID_OUT);
 	destination |= TD_TOKEN_TOGGLE;		/* End in Data1 */
 
-	status &amp;= ~TD_CTRL_SPD;
-
 	uhci_add_td_to_urbp(td, urbp);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
 			destination | uhci_explen(0), 0);
@@ -1185,10 +1182,18 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				}
 			}
 
+		/* Did we receive a short packet? */
 		} else if (len &lt; uhci_expected_length(td_token(td))) {
 
-			/* We received a short packet */
-			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
+			/* For control transfers, go to the status TD if
+			 * this isn't already the last data TD */
+			if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+				if (td-&gt;list.next != urbp-&gt;td_list.prev)
+					ret = 1;
+			}
+
+			/* For bulk and interrupt, this may be an error */
+			else if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
 				ret = -EREMOTEIO;
 
 			/* Fixup needed only if this isn't the URB's last TD */
@@ -1208,10 +1213,6 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 
 err:
 	if (ret &lt; 0) {
-		/* In case a control transfer gets an error
-		 * during the setup stage */
-		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
-
 		/* Note that the queue has stopped and save
 		 * the next toggle value */
 		qh-&gt;element = UHCI_PTR_TERM;
@@ -1489,9 +1490,25 @@ __acquires(uhci-&gt;lock)
 {
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+
+		/* urb-&gt;actual_length &lt; 0 means the setup transaction didn't
+		 * complete successfully.  Either it failed or the URB was
+		 * unlinked first.  Regardless, don't confuse people with a
+		 * negative length. */
+		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
+
+		/* Report erroneous short transfers */
+		if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+				urb-&gt;actual_length &lt;
+					urb-&gt;transfer_buffer_length &amp;&amp;
+				urb-&gt;status == 0))
+			urb-&gt;status = -EREMOTEIO;
+	}
+
 	/* When giving back the first URB in an Isochronous queue,
 	 * reinitialize the QH's iso-related members for the next URB. */
-	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC &amp;&amp;
+	else if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC &amp;&amp;
 			urbp-&gt;node.prev == &amp;qh-&gt;queue &amp;&amp;
 			urbp-&gt;node.next != &amp;qh-&gt;queue) {
 		struct urb *nurb = list_entry(urbp-&gt;node.next,</pre><hr><pre>commit 195af2cce5ff81c4609c7ba585b6698a7771cbfc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 16 15:28:19 2007 -0400

    USB: fix warning caused by autosuspend counter going negative
    
    This patch (as937) fixes a minor bug in the autosuspend usage-counting
    code.  Each hub's usage counter keeps track of the number of
    unsuspended children.  However the current driver increments the
    counter after registering a new child, by which time the child may
    already have been suspended and caused the counter to go negative.
    The obvious solution is to increment the counter before registering
    the child.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index fd74c50b1804..e341a1da517f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1335,6 +1335,10 @@ int usb_new_device(struct usb_device *udev)
 	udev-&gt;dev.devt = MKDEV(USB_DEVICE_MAJOR,
 			(((udev-&gt;bus-&gt;busnum-1) * 128) + (udev-&gt;devnum-1)));
 
+	/* Increment the parent's count of unsuspended children */
+	if (udev-&gt;parent)
+		usb_autoresume_device(udev-&gt;parent);
+
 	/* Register the device.  The device driver is responsible
 	 * for adding the device files to sysfs and for configuring
 	 * the device.
@@ -1342,13 +1346,11 @@ int usb_new_device(struct usb_device *udev)
 	err = device_add(&amp;udev-&gt;dev);
 	if (err) {
 		dev_err(&amp;udev-&gt;dev, "can't device_add, error %d\n", err);
+		if (udev-&gt;parent)
+			usb_autosuspend_device(udev-&gt;parent);
 		goto fail;
 	}
 
-	/* Increment the parent's count of unsuspended children */
-	if (udev-&gt;parent)
-		usb_autoresume_device(udev-&gt;parent);
-
 exit:
 	return err;
 </pre><hr><pre>commit 69d42a78f935d19384d1f6e4f94b65bb162b36df
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 12 17:06:23 2007 -0400

    USB: add "descriptors" binary sysfs attribute
    
    This patch (as934) adds a new readonly binary sysfs attribute file
    called "descriptors" for each USB device.  The attribute contains the
    device descriptor followed by the raw descriptor entry (config plug
    subsidiary descriptors) for the current configuration.
    
    Having this information available in fixed-format binary makes life a
    lot easier for user programs by avoiding the need to open, read, and
    parse multiple sysfs text files.
    
    The information in this attribute file is much like that in usbfs's
    device file, but there are some significant differences:
    
            The 2-byte fields in the device descriptor are left in
            little-endian byte order, as they appear on the bus and
            in the kernel.
    
            Only one raw descriptor set is presented, that of the
            current configuration.
    
            Opening this file will not cause a suspended device to be
            autoresumed.
    
    The last item in particular should be a big selling point for libusb,
    which currently forces all USB devices to be resumed as it scans the
    device tree.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Dave Mielke &lt;dave@mielke.cc&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index d47ae89154a7..2ab222be8fd1 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -441,6 +441,54 @@ static struct attribute_group dev_attr_grp = {
 	.attrs = dev_attrs,
 };
 
+/* Binary descriptors */
+
+static ssize_t
+read_descriptors(struct kobject *kobj, struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct usb_device *udev = to_usb_device(
+			container_of(kobj, struct device, kobj));
+	size_t nleft = count;
+	size_t srclen, n;
+
+	usb_lock_device(udev);
+
+	/* The binary attribute begins with the device descriptor */
+	srclen = sizeof(struct usb_device_descriptor);
+	if (off &lt; srclen) {
+		n = min_t(size_t, nleft, srclen - off);
+		memcpy(buf, off + (char *) &amp;udev-&gt;descriptor, n);
+		nleft -= n;
+		buf += n;
+		off = 0;
+	} else {
+		off -= srclen;
+	}
+
+	/* Then follows the raw descriptor entry for the current
+	 * configuration (config plus subsidiary descriptors).
+	 */
+	if (udev-&gt;actconfig) {
+		int cfgno = udev-&gt;actconfig - udev-&gt;config;
+
+		srclen = __le16_to_cpu(udev-&gt;actconfig-&gt;desc.wTotalLength);
+		if (off &lt; srclen) {
+			n = min_t(size_t, nleft, srclen - off);
+			memcpy(buf, off + udev-&gt;rawdescriptors[cfgno], n);
+			nleft -= n;
+		}
+	}
+	usb_unlock_device(udev);
+	return count - nleft;
+}
+
+static struct bin_attribute dev_bin_attr_descriptors = {
+	.attr = {.name = "descriptors", .mode = 0444},
+	.read = read_descriptors,
+	.size = 18 + 65535,	/* dev descr + max-size raw descriptor */
+};
+
 int usb_create_sysfs_dev_files(struct usb_device *udev)
 {
 	struct device *dev = &amp;udev-&gt;dev;
@@ -450,6 +498,10 @@ int usb_create_sysfs_dev_files(struct usb_device *udev)
 	if (retval)
 		return retval;
 
+	retval = device_create_bin_file(dev, &amp;dev_bin_attr_descriptors);
+	if (retval)
+		goto error;
+
 	retval = add_persist_attributes(dev);
 	if (retval)
 		goto error;
@@ -492,6 +544,7 @@ void usb_remove_sysfs_dev_files(struct usb_device *udev)
 	device_remove_file(dev, &amp;dev_attr_serial);
 	remove_power_attributes(dev);
 	remove_persist_attributes(dev);
+	device_remove_bin_file(dev, &amp;dev_bin_attr_descriptors);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;dev_attr_grp);
 }
 </pre><hr><pre>commit 1b4cd43bd3f9aa7a794e29b80b0d984a8e144df4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 12 17:03:01 2007 -0400

    isp116x-hcd: prepare for urb-&gt;status
    
    This patch (as931b), adapted from a patch by Olav Kongas, makes a small
    set of conservative changes to the isp116x-hcd driver in preparation
    for the removal of urb-&gt;status.
    
            finish_request() is moved up in the source and is called
            as soon as the URB is known to have completed, rather than
            after all the active endpoints have been scanned.
    
            The status of a completed URB is kept in a local variable
            and copied to urb-&gt;status only when the URB is about to be
            given back.
    
            -EREMOTEIO error status for control transfers is set after
            the status stage rather than when the short packet arrives.
    
            Some unnecessary uses of urb-&gt;lock are removed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Olav Kongas &lt;ok@artecdesign.ee&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 46873f2534b5..5c851a36de72 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -228,7 +228,6 @@ static void preproc_atl_queue(struct isp116x *isp116x)
 				   struct urb, urb_list);
 		ptd = &amp;ep-&gt;ptd;
 		len = ep-&gt;length;
-		spin_lock(&amp;urb-&gt;lock);
 		ep-&gt;data = (unsigned char *)urb-&gt;transfer_buffer
 		    + urb-&gt;actual_length;
 
@@ -264,7 +263,6 @@ static void preproc_atl_queue(struct isp116x *isp116x)
 		    | PTD_EP(ep-&gt;epnum);
 		ptd-&gt;len = PTD_LEN(len) | PTD_DIR(dir);
 		ptd-&gt;faddr = PTD_FA(usb_pipedevice(urb-&gt;pipe));
-		spin_unlock(&amp;urb-&gt;lock);
 		if (!ep-&gt;active) {
 			ptd-&gt;mps |= PTD_LAST_MSK;
 			isp116x-&gt;atl_last_dir = dir;
@@ -274,6 +272,61 @@ static void preproc_atl_queue(struct isp116x *isp116x)
 	}
 }
 
+/*
+  Take done or failed requests out of schedule. Give back
+  processed urbs.
+*/
+static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
+			   struct urb *urb)
+__releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
+{
+	unsigned i;
+
+	urb-&gt;hcpriv = NULL;
+	ep-&gt;error_count = 0;
+
+	if (usb_pipecontrol(urb-&gt;pipe))
+		ep-&gt;nextpid = USB_PID_SETUP;
+
+	urb_dbg(urb, "Finish");
+
+	spin_unlock(&amp;isp116x-&gt;lock);
+	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
+	spin_lock(&amp;isp116x-&gt;lock);
+
+	/* take idle endpoints out of the schedule */
+	if (!list_empty(&amp;ep-&gt;hep-&gt;urb_list))
+		return;
+
+	/* async deschedule */
+	if (!list_empty(&amp;ep-&gt;schedule)) {
+		list_del_init(&amp;ep-&gt;schedule);
+		return;
+	}
+
+	/* periodic deschedule */
+	DBG("deschedule qh%d/%p branch %d\n", ep-&gt;period, ep, ep-&gt;branch);
+	for (i = ep-&gt;branch; i &lt; PERIODIC_SIZE; i += ep-&gt;period) {
+		struct isp116x_ep *temp;
+		struct isp116x_ep **prev = &amp;isp116x-&gt;periodic[i];
+
+		while (*prev &amp;&amp; ((temp = *prev) != ep))
+			prev = &amp;temp-&gt;next;
+		if (*prev)
+			*prev = ep-&gt;next;
+		isp116x-&gt;load[i] -= ep-&gt;load;
+	}
+	ep-&gt;branch = PERIODIC_SIZE;
+	isp116x_to_hcd(isp116x)-&gt;self.bandwidth_allocated -=
+	    ep-&gt;load / ep-&gt;period;
+
+	/* switch irq type? */
+	if (!--isp116x-&gt;periodic_count) {
+		isp116x-&gt;irqenb &amp;= ~HCuPINT_SOF;
+		isp116x-&gt;irqenb |= HCuPINT_ATL;
+	}
+}
+
 /*
   Analyze transfer results, handle partial transfers and errors
 */
@@ -284,6 +337,7 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 	struct usb_device *udev;
 	struct ptd *ptd;
 	int short_not_ok;
+	int status;
 	u8 cc;
 
 	for (ep = isp116x-&gt;atl_active; ep; ep = ep-&gt;active) {
@@ -294,7 +348,7 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 		ptd = &amp;ep-&gt;ptd;
 		cc = PTD_GET_CC(ptd);
 		short_not_ok = 1;
-		spin_lock(&amp;urb-&gt;lock);
+		status = -EINPROGRESS;
 
 		/* Data underrun is special. For allowed underrun
 		   we clear the error and continue as normal. For
@@ -302,47 +356,36 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 		   immediately while for control transfer,
 		   we do a STATUS stage. */
 		if (cc == TD_DATAUNDERRUN) {
-			if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)) {
-				DBG("Allowed data underrun\n");
+			if (!(urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) ||
+					usb_pipecontrol(urb-&gt;pipe)) {
+				DBG("Allowed or control data underrun\n");
 				cc = TD_CC_NOERROR;
 				short_not_ok = 0;
 			} else {
 				ep-&gt;error_count = 1;
-				if (usb_pipecontrol(urb-&gt;pipe))
-					ep-&gt;nextpid = USB_PID_ACK;
-				else
-					usb_settoggle(udev, ep-&gt;epnum,
-						      ep-&gt;nextpid ==
-						      USB_PID_OUT,
-						      PTD_GET_TOGGLE(ptd));
+				usb_settoggle(udev, ep-&gt;epnum,
+					      ep-&gt;nextpid == USB_PID_OUT,
+					      PTD_GET_TOGGLE(ptd));
 				urb-&gt;actual_length += PTD_GET_COUNT(ptd);
-				urb-&gt;status = cc_to_error[TD_DATAUNDERRUN];
-				spin_unlock(&amp;urb-&gt;lock);
-				continue;
+				status = cc_to_error[TD_DATAUNDERRUN];
+				goto done;
 			}
 		}
-		/* Keep underrun error through the STATUS stage */
-		if (urb-&gt;status == cc_to_error[TD_DATAUNDERRUN])
-			cc = TD_DATAUNDERRUN;
 
 		if (cc != TD_CC_NOERROR &amp;&amp; cc != TD_NOTACCESSED
 		    &amp;&amp; (++ep-&gt;error_count &gt;= 3 || cc == TD_CC_STALL
 			|| cc == TD_DATAOVERRUN)) {
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = cc_to_error[cc];
+			status = cc_to_error[cc];
 			if (ep-&gt;nextpid == USB_PID_ACK)
 				ep-&gt;nextpid = 0;
-			spin_unlock(&amp;urb-&gt;lock);
-			continue;
+			goto done;
 		}
 		/* According to usb spec, zero-length Int transfer signals
 		   finishing of the urb. Hey, does this apply only
 		   for IN endpoints? */
 		if (usb_pipeint(urb-&gt;pipe) &amp;&amp; !PTD_GET_LEN(ptd)) {
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = 0;
-			spin_unlock(&amp;urb-&gt;lock);
-			continue;
+			status = 0;
+			goto done;
 		}
 
 		/* Relax after previously failed, but later succeeded
@@ -381,8 +424,8 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 			/* All data for this URB is transferred, let's finish */
 			if (usb_pipecontrol(urb-&gt;pipe))
 				ep-&gt;nextpid = USB_PID_ACK;
-			else if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = 0;
+			else
+				status = 0;
 			break;
 		case USB_PID_SETUP:
 			if (PTD_GET_ACTIVE(ptd)
@@ -402,69 +445,27 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 			if (PTD_GET_ACTIVE(ptd)
 			    || (cc != TD_CC_NOERROR &amp;&amp; cc &lt; 0x0E))
 				break;
-			if (urb-&gt;status == -EINPROGRESS)
-				urb-&gt;status = 0;
+			if ((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
+					urb-&gt;actual_length &lt;
+						urb-&gt;transfer_buffer_length)
+				status = -EREMOTEIO;
+			else
+				status = 0;
 			ep-&gt;nextpid = 0;
 			break;
 		default:
 			BUG();
 		}
-		spin_unlock(&amp;urb-&gt;lock);
-	}
-}
-
-/*
-  Take done or failed requests out of schedule. Give back
-  processed urbs.
-*/
-static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
-			   struct urb *urb)
-__releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
-{
-	unsigned i;
-
-	urb-&gt;hcpriv = NULL;
-	ep-&gt;error_count = 0;
-
-	if (usb_pipecontrol(urb-&gt;pipe))
-		ep-&gt;nextpid = USB_PID_SETUP;
-
-	urb_dbg(urb, "Finish");
-
-	spin_unlock(&amp;isp116x-&gt;lock);
-	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
-	spin_lock(&amp;isp116x-&gt;lock);
-
-	/* take idle endpoints out of the schedule */
-	if (!list_empty(&amp;ep-&gt;hep-&gt;urb_list))
-		return;
-
-	/* async deschedule */
-	if (!list_empty(&amp;ep-&gt;schedule)) {
-		list_del_init(&amp;ep-&gt;schedule);
-		return;
-	}
 
-	/* periodic deschedule */
-	DBG("deschedule qh%d/%p branch %d\n", ep-&gt;period, ep, ep-&gt;branch);
-	for (i = ep-&gt;branch; i &lt; PERIODIC_SIZE; i += ep-&gt;period) {
-		struct isp116x_ep *temp;
-		struct isp116x_ep **prev = &amp;isp116x-&gt;periodic[i];
-
-		while (*prev &amp;&amp; ((temp = *prev) != ep))
-			prev = &amp;temp-&gt;next;
-		if (*prev)
-			*prev = ep-&gt;next;
-		isp116x-&gt;load[i] -= ep-&gt;load;
-	}
-	ep-&gt;branch = PERIODIC_SIZE;
-	isp116x_to_hcd(isp116x)-&gt;self.bandwidth_allocated -=
-	    ep-&gt;load / ep-&gt;period;
-
-	/* switch irq type? */
-	if (!--isp116x-&gt;periodic_count) {
-		isp116x-&gt;irqenb &amp;= ~HCuPINT_SOF;
-		isp116x-&gt;irqenb |= HCuPINT_ATL;
+ done:
+		if (status != -EINPROGRESS) {
+			spin_lock(&amp;urb-&gt;lock);
+			if (urb-&gt;status == -EINPROGRESS)
+				urb-&gt;status = status;
+			spin_unlock(&amp;urb-&gt;lock);
+		}
+		if (urb-&gt;status != -EINPROGRESS)
+			finish_request(isp116x, ep, urb);
 	}
 }
 
@@ -570,9 +571,6 @@ static void start_atl_transfers(struct isp116x *isp116x)
 */
 static void finish_atl_transfers(struct isp116x *isp116x)
 {
-	struct isp116x_ep *ep;
-	struct urb *urb;
-
 	if (!isp116x-&gt;atl_active)
 		return;
 	/* Fifo not ready? */
@@ -582,16 +580,6 @@ static void finish_atl_transfers(struct isp116x *isp116x)
 	atomic_inc(&amp;isp116x-&gt;atl_finishing);
 	unpack_fifo(isp116x);
 	postproc_atl_queue(isp116x);
-	for (ep = isp116x-&gt;atl_active; ep; ep = ep-&gt;active) {
-		urb =
-		    container_of(ep-&gt;hep-&gt;urb_list.next, struct urb, urb_list);
-		/* USB_PID_ACK check here avoids finishing of
-		   control transfers, for which TD_DATAUNDERRUN
-		   occured, while URB_SHORT_NOT_OK was set */
-		if (urb &amp;&amp; urb-&gt;status != -EINPROGRESS
-		    &amp;&amp; ep-&gt;nextpid != USB_PID_ACK)
-			finish_request(isp116x, ep, urb);
-	}
 	atomic_dec(&amp;isp116x-&gt;atl_finishing);
 }
 
@@ -821,15 +809,12 @@ static int isp116x_urb_enqueue(struct usb_hcd *hcd,
 	}
 
 	/* in case of unlink-during-submit */
-	spin_lock(&amp;urb-&gt;lock);
 	if (urb-&gt;status != -EINPROGRESS) {
-		spin_unlock(&amp;urb-&gt;lock);
 		finish_request(isp116x, ep, urb);
 		ret = 0;
 		goto fail;
 	}
 	urb-&gt;hcpriv = hep;
-	spin_unlock(&amp;urb-&gt;lock);
 	start_atl_transfers(isp116x);
 
       fail:</pre>
    <div class="pagination">
        <a href='2_104.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><span>[105]</span><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_106.html'>Next&gt;&gt;</a>
    <div>
</body>
