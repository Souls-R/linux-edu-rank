<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_43.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><span>[44]</span><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_45.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d8558a297878f1a7af995f6801983783e1487208
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Feb 17 20:44:36 2014 -0500

    ext4: clean up error handling in swap_inode_boot_loader()
    
    Tighten up the code to make the code easier to read and maintain.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index a2a837f00407..0f2252ec274d 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -104,21 +104,15 @@ static long swap_inode_boot_loader(struct super_block *sb,
 	struct ext4_inode_info *ei_bl;
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 
-	if (inode-&gt;i_nlink != 1 || !S_ISREG(inode-&gt;i_mode)) {
-		err = -EINVAL;
-		goto swap_boot_out;
-	}
+	if (inode-&gt;i_nlink != 1 || !S_ISREG(inode-&gt;i_mode))
+		return -EINVAL;
 
-	if (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN)) {
-		err = -EPERM;
-		goto swap_boot_out;
-	}
+	if (!inode_owner_or_capable(inode) || !capable(CAP_SYS_ADMIN))
+		return -EPERM;
 
 	inode_bl = ext4_iget(sb, EXT4_BOOT_LOADER_INO);
-	if (IS_ERR(inode_bl)) {
-		err = PTR_ERR(inode_bl);
-		goto swap_boot_out;
-	}
+	if (IS_ERR(inode_bl))
+		return PTR_ERR(inode_bl);
 	ei_bl = EXT4_I(inode_bl);
 
 	filemap_flush(inode-&gt;i_mapping);
@@ -193,20 +187,14 @@ static long swap_inode_boot_loader(struct super_block *sb,
 			ext4_mark_inode_dirty(handle, inode);
 		}
 	}
-
 	ext4_journal_stop(handle);
-
 	ext4_double_up_write_data_sem(inode, inode_bl);
 
 journal_err_out:
 	ext4_inode_resume_unlocked_dio(inode);
 	ext4_inode_resume_unlocked_dio(inode_bl);
-
 	unlock_two_nondirectories(inode, inode_bl);
-
 	iput(inode_bl);
-
-swap_boot_out:
 	return err;
 }
 </pre><hr><pre>commit 19ea80603715d473600cd993b9987bc97d042e02
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Feb 16 19:29:32 2014 -0500

    ext4: don't leave i_crtime.tv_sec uninitialized
    
    If the i_crtime field is not present in the inode, don't leave the
    field uninitialized.
    
    Fixes: ef7f38359 ("ext4: Add nanosecond timestamps")
    Reported-by: Vegard Nossum &lt;vegard.nossum@oracle.com&gt;
    Tested-by: Vegard Nossum &lt;vegard.nossum@oracle.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index ece55565b9cd..d3a534fdc5ff 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -771,6 +771,8 @@ do {									       \
 	if (EXT4_FITS_IN_INODE(raw_inode, einode, xtime))		       \
 		(einode)-&gt;xtime.tv_sec = 				       \
 			(signed)le32_to_cpu((raw_inode)-&gt;xtime);	       \
+	else								       \
+		(einode)-&gt;xtime.tv_sec = 0;				       \
 	if (EXT4_FITS_IN_INODE(raw_inode, einode, xtime ## _extra))	       \
 		ext4_decode_extra_time(&amp;(einode)-&gt;xtime,		       \
 				       raw_inode-&gt;xtime ## _extra);	       \</pre><hr><pre>commit 3d2660d0c9c2f296837078c189b68a47f6b2e3b5
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Feb 15 22:42:25 2014 -0500

    ext4: fix online resize with a non-standard blocks per group setting
    
    The set_flexbg_block_bitmap() function assumed that the number of
    blocks in a blockgroup was sb-&gt;blocksize * 8, which is normally true,
    but not always!  Use EXT4_BLOCKS_PER_GROUP(sb) instead, to fix block
    bitmap corruption after:
    
    mke2fs -t ext4 -g 3072 -i 4096 /dev/vdd 1G
    mount -t ext4 /dev/vdd /vdd
    resize2fs /dev/vdd 8G
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reported-by: Jon Bernard &lt;jbernard@tuxion.com&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index 69a62610a6ca..f3b84cd9de56 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -409,7 +409,7 @@ static int set_flexbg_block_bitmap(struct super_block *sb, handle_t *handle,
 		start = ext4_group_first_block_no(sb, group);
 		group -= flex_gd-&gt;groups[0].group;
 
-		count2 = sb-&gt;s_blocksize * 8 - (block - start);
+		count2 = EXT4_BLOCKS_PER_GROUP(sb) - (block - start);
 		if (count2 &gt; count)
 			count2 = count;
 </pre><hr><pre>commit b93c95353413041a8cebad915a8109619f66bcc6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Feb 15 21:33:13 2014 -0500

    ext4: fix online resize with very large inode tables
    
    If a file system has a large number of inodes per block group, all of
    the metadata blocks in a flex_bg may be larger than what can fit in a
    single block group.  Unfortunately, ext4_alloc_group_tables() in
    resize.c was never tested to see if it would handle this case
    correctly, and there were a large number of bugs which caused the
    following sequence to result in a BUG_ON:
    
    kernel bug at fs/ext4/resize.c:409!
       ...
    call trace:
     [&lt;ffffffff81256768&gt;] ext4_flex_group_add+0x1448/0x1830
     [&lt;ffffffff81257de2&gt;] ext4_resize_fs+0x7b2/0xe80
     [&lt;ffffffff8123ac50&gt;] ext4_ioctl+0xbf0/0xf00
     [&lt;ffffffff811c111d&gt;] do_vfs_ioctl+0x2dd/0x4b0
     [&lt;ffffffff811b9df2&gt;] ? final_putname+0x22/0x50
     [&lt;ffffffff811c1371&gt;] sys_ioctl+0x81/0xa0
     [&lt;ffffffff81676aa9&gt;] system_call_fastpath+0x16/0x1b
    code: c8 4c 89 df e8 41 96 f8 ff 44 89 e8 49 01 c4 44 29 6d d4 0
    rip  [&lt;ffffffff81254fa1&gt;] set_flexbg_block_bitmap+0x171/0x180
    
    
    This can be reproduced with the following command sequence:
    
       mke2fs -t ext4 -i 4096 /dev/vdd 1G
       mount -t ext4 /dev/vdd /vdd
       resize2fs /dev/vdd 8G
    
    To fix this, we need to make sure the right thing happens when a block
    group's inode table straddles two block groups, which means the
    following bugs had to be fixed:
    
    1) Not clearing the BLOCK_UNINIT flag in the second block group in
       ext4_alloc_group_tables --- the was proximate cause of the BUG_ON.
    
    2) Incorrectly determining how many block groups contained contiguous
       free blocks in ext4_alloc_group_tables().
    
    3) Incorrectly setting the start of the next block range to be marked
       in use after a discontinuity in setup_new_flex_group_blocks().
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index c5adbb318a90..69a62610a6ca 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -243,6 +243,7 @@ static int ext4_alloc_group_tables(struct super_block *sb,
 	ext4_group_t group;
 	ext4_group_t last_group;
 	unsigned overhead;
+	__u16 uninit_mask = (flexbg_size &gt; 1) ? ~EXT4_BG_BLOCK_UNINIT : ~0;
 
 	BUG_ON(flex_gd-&gt;count == 0 || group_data == NULL);
 
@@ -266,7 +267,7 @@ static int ext4_alloc_group_tables(struct super_block *sb,
 	src_group++;
 	for (; src_group &lt;= last_group; src_group++) {
 		overhead = ext4_group_overhead_blocks(sb, src_group);
-		if (overhead != 0)
+		if (overhead == 0)
 			last_blk += group_data[src_group - group].blocks_count;
 		else
 			break;
@@ -280,8 +281,7 @@ static int ext4_alloc_group_tables(struct super_block *sb,
 		group = ext4_get_group_number(sb, start_blk - 1);
 		group -= group_data[0].group;
 		group_data[group].free_blocks_count--;
-		if (flexbg_size &gt; 1)
-			flex_gd-&gt;bg_flags[group] &amp;= ~EXT4_BG_BLOCK_UNINIT;
+		flex_gd-&gt;bg_flags[group] &amp;= uninit_mask;
 	}
 
 	/* Allocate inode bitmaps */
@@ -292,22 +292,30 @@ static int ext4_alloc_group_tables(struct super_block *sb,
 		group = ext4_get_group_number(sb, start_blk - 1);
 		group -= group_data[0].group;
 		group_data[group].free_blocks_count--;
-		if (flexbg_size &gt; 1)
-			flex_gd-&gt;bg_flags[group] &amp;= ~EXT4_BG_BLOCK_UNINIT;
+		flex_gd-&gt;bg_flags[group] &amp;= uninit_mask;
 	}
 
 	/* Allocate inode tables */
 	for (; it_index &lt; flex_gd-&gt;count; it_index++) {
-		if (start_blk + EXT4_SB(sb)-&gt;s_itb_per_group &gt; last_blk)
+		unsigned int itb = EXT4_SB(sb)-&gt;s_itb_per_group;
+		ext4_fsblk_t next_group_start;
+
+		if (start_blk + itb &gt; last_blk)
 			goto next_group;
 		group_data[it_index].inode_table = start_blk;
-		group = ext4_get_group_number(sb, start_blk - 1);
+		group = ext4_get_group_number(sb, start_blk);
+		next_group_start = ext4_group_first_block_no(sb, group + 1);
 		group -= group_data[0].group;
-		group_data[group].free_blocks_count -=
-					EXT4_SB(sb)-&gt;s_itb_per_group;
-		if (flexbg_size &gt; 1)
-			flex_gd-&gt;bg_flags[group] &amp;= ~EXT4_BG_BLOCK_UNINIT;
 
+		if (start_blk + itb &gt; next_group_start) {
+			flex_gd-&gt;bg_flags[group + 1] &amp;= uninit_mask;
+			overhead = start_blk + itb - next_group_start;
+			group_data[group + 1].free_blocks_count -= overhead;
+			itb -= overhead;
+		}
+
+		group_data[group].free_blocks_count -= itb;
+		flex_gd-&gt;bg_flags[group] &amp;= uninit_mask;
 		start_blk += EXT4_SB(sb)-&gt;s_itb_per_group;
 	}
 
@@ -620,7 +628,7 @@ static int setup_new_flex_group_blocks(struct super_block *sb,
 			if (err)
 				goto out;
 			count = group_table_count[j];
-			start = group_data[i].block_bitmap;
+			start = (&amp;group_data[i].block_bitmap)[j];
 			block = start;
 		}
 </pre><hr><pre>commit 23301410972330c0ae9a8afc379ba2005e249cc6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Feb 12 12:16:04 2014 -0500

    ext4: don't try to modify s_flags if the the file system is read-only
    
    If an ext4 file system is created by some tool other than mke2fs
    (perhaps by someone who has a pathalogical fear of the GPL) that
    doesn't set one or the other of the EXT2_FLAGS_{UN}SIGNED_HASH flags,
    and that file system is then mounted read-only, don't try to modify
    the s_flags field.  Otherwise, if dm_verity is in use, the superblock
    will change, causing an dm_verity failure.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 1f7784de05b6..710fed2377d4 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3695,16 +3695,22 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	for (i = 0; i &lt; 4; i++)
 		sbi-&gt;s_hash_seed[i] = le32_to_cpu(es-&gt;s_hash_seed[i]);
 	sbi-&gt;s_def_hash_version = es-&gt;s_def_hash_version;
-	i = le32_to_cpu(es-&gt;s_flags);
-	if (i &amp; EXT2_FLAGS_UNSIGNED_HASH)
-		sbi-&gt;s_hash_unsigned = 3;
-	else if ((i &amp; EXT2_FLAGS_SIGNED_HASH) == 0) {
+	if (EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {
+		i = le32_to_cpu(es-&gt;s_flags);
+		if (i &amp; EXT2_FLAGS_UNSIGNED_HASH)
+			sbi-&gt;s_hash_unsigned = 3;
+		else if ((i &amp; EXT2_FLAGS_SIGNED_HASH) == 0) {
 #ifdef __CHAR_UNSIGNED__
-		es-&gt;s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);
-		sbi-&gt;s_hash_unsigned = 3;
+			if (!(sb-&gt;s_flags &amp; MS_RDONLY))
+				es-&gt;s_flags |=
+					cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);
+			sbi-&gt;s_hash_unsigned = 3;
 #else
-		es-&gt;s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);
+			if (!(sb-&gt;s_flags &amp; MS_RDONLY))
+				es-&gt;s_flags |=
+					cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);
 #endif
+		}
 	}
 
 	/* Handle clustersize */</pre><hr><pre>commit 8c9367fd9bf252b57c6d4f8e1a7f9de809d8b862
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Jan 7 13:08:03 2014 -0500

    ext4: don't pass freed handle to ext4_walk_page_buffers
    
    This is harmless, since ext4_walk_page_buffers only passes the handle
    onto the callback function, and in this call site the function in
    question, bput_one(), doesn't actually use the handle.  But there's no
    point passing in an invalid handle, and it creates a Coverity warning,
    so let's just clean it up.
    
    Addresses-Coverity-Id: #1091168
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 8454ebe238a0..f33b4eb82d80 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1772,7 +1772,7 @@ static int __ext4_journalled_writepage(struct page *page,
 		ret = err;
 
 	if (!ext4_has_inline_data(inode))
-		ext4_walk_page_buffers(handle, page_bufs, 0, len,
+		ext4_walk_page_buffers(NULL, page_bufs, 0, len,
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:</pre><hr><pre>commit 09c455aaa8f47a94d5bafaa23d58365768210507
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Jan 7 12:58:19 2014 -0500

    ext4: avoid clearing beyond i_blocks when truncating an inline data file
    
    A missing cast means that when we are truncating a file which is less
    than 60 bytes, we don't clear the correct area of memory, and in fact
    we can end up truncating the next inode in the inode table, or worse
    yet, some other kernel data structure.
    
    Addresses-Coverity-Id: #751987
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index c417e52d194e..ed29e720e880 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -1928,9 +1928,11 @@ void ext4_inline_data_truncate(struct inode *inode, int *has_inline)
 		}
 
 		/* Clear the content within i_blocks. */
-		if (i_size &lt; EXT4_MIN_INLINE_DATA_SIZE)
-			memset(ext4_raw_inode(&amp;is.iloc)-&gt;i_block + i_size, 0,
-					EXT4_MIN_INLINE_DATA_SIZE - i_size);
+		if (i_size &lt; EXT4_MIN_INLINE_DATA_SIZE) {
+			void *p = (void *) ext4_raw_inode(&amp;is.iloc)-&gt;i_block;
+			memset(p + i_size, 0,
+			       EXT4_MIN_INLINE_DATA_SIZE - i_size);
+		}
 
 		EXT4_I(inode)-&gt;i_inline_size = i_size &lt;
 					EXT4_MIN_INLINE_DATA_SIZE ?</pre><hr><pre>commit f5a44db5d2d677dfbf12deee461f85e9ec633961
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri Dec 20 09:29:35 2013 -0500

    ext4: add explicit casts when masking cluster sizes
    
    The missing casts can cause the high 64-bits of the physical blocks to
    be lost.  Set up new macros which allows us to make sure the right
    thing happen, even if at some point we end up supporting larger
    logical block numbers.
    
    Thanks to the Emese Revfy and the PaX security team for reporting this
    issue.
    
    Reported-by: PaX Team &lt;pageexec@freemail.hu&gt;
    Reported-by: Emese Revfy &lt;re.emese@gmail.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index e6185031c1cc..ece55565b9cd 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -268,6 +268,16 @@ struct ext4_io_submit {
 /* Translate # of blks to # of clusters */
 #define EXT4_NUM_B2C(sbi, blks)	(((blks) + (sbi)-&gt;s_cluster_ratio - 1) &gt;&gt; \
 				 (sbi)-&gt;s_cluster_bits)
+/* Mask out the low bits to get the starting block of the cluster */
+#define EXT4_PBLK_CMASK(s, pblk) ((pblk) &amp;				\
+				  ~((ext4_fsblk_t) (s)-&gt;s_cluster_ratio - 1))
+#define EXT4_LBLK_CMASK(s, lblk) ((lblk) &amp;				\
+				  ~((ext4_lblk_t) (s)-&gt;s_cluster_ratio - 1))
+/* Get the cluster offset */
+#define EXT4_PBLK_COFF(s, pblk) ((pblk) &amp;				\
+				 ((ext4_fsblk_t) (s)-&gt;s_cluster_ratio - 1))
+#define EXT4_LBLK_COFF(s, lblk) ((lblk) &amp;				\
+				 ((ext4_lblk_t) (s)-&gt;s_cluster_ratio - 1))
 
 /*
  * Structure of a blocks group descriptor
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 267c9fb53bf9..4410cc3d6ee2 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1851,8 +1851,7 @@ static unsigned int ext4_ext_check_overlap(struct ext4_sb_info *sbi,
 	depth = ext_depth(inode);
 	if (!path[depth].p_ext)
 		goto out;
-	b2 = le32_to_cpu(path[depth].p_ext-&gt;ee_block);
-	b2 &amp;= ~(sbi-&gt;s_cluster_ratio - 1);
+	b2 = EXT4_LBLK_CMASK(sbi, le32_to_cpu(path[depth].p_ext-&gt;ee_block));
 
 	/*
 	 * get the next allocated block if the extent in the path
@@ -1862,7 +1861,7 @@ static unsigned int ext4_ext_check_overlap(struct ext4_sb_info *sbi,
 		b2 = ext4_ext_next_allocated_block(path);
 		if (b2 == EXT_MAX_BLOCKS)
 			goto out;
-		b2 &amp;= ~(sbi-&gt;s_cluster_ratio - 1);
+		b2 = EXT4_LBLK_CMASK(sbi, b2);
 	}
 
 	/* check for wrap through zero on extent logical start block*/
@@ -2521,7 +2520,7 @@ static int ext4_remove_blocks(handle_t *handle, struct inode *inode,
 		 * extent, we have to mark the cluster as used (store negative
 		 * cluster number in partial_cluster).
 		 */
-		unaligned = pblk &amp; (sbi-&gt;s_cluster_ratio - 1);
+		unaligned = EXT4_PBLK_COFF(sbi, pblk);
 		if (unaligned &amp;&amp; (ee_len == num) &amp;&amp;
 		    (*partial_cluster != -((long long)EXT4_B2C(sbi, pblk))))
 			*partial_cluster = EXT4_B2C(sbi, pblk);
@@ -2615,7 +2614,7 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 			 * accidentally freeing it later on
 			 */
 			pblk = ext4_ext_pblock(ex);
-			if (pblk &amp; (sbi-&gt;s_cluster_ratio - 1))
+			if (EXT4_PBLK_COFF(sbi, pblk))
 				*partial_cluster =
 					-((long long)EXT4_B2C(sbi, pblk));
 			ex--;
@@ -3770,7 +3769,7 @@ int ext4_find_delalloc_cluster(struct inode *inode, ext4_lblk_t lblk)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(inode-&gt;i_sb);
 	ext4_lblk_t lblk_start, lblk_end;
-	lblk_start = lblk &amp; (~(sbi-&gt;s_cluster_ratio - 1));
+	lblk_start = EXT4_LBLK_CMASK(sbi, lblk);
 	lblk_end = lblk_start + sbi-&gt;s_cluster_ratio - 1;
 
 	return ext4_find_delalloc_range(inode, lblk_start, lblk_end);
@@ -3829,9 +3828,9 @@ get_reserved_cluster_alloc(struct inode *inode, ext4_lblk_t lblk_start,
 	trace_ext4_get_reserved_cluster_alloc(inode, lblk_start, num_blks);
 
 	/* Check towards left side */
-	c_offset = lblk_start &amp; (sbi-&gt;s_cluster_ratio - 1);
+	c_offset = EXT4_LBLK_COFF(sbi, lblk_start);
 	if (c_offset) {
-		lblk_from = lblk_start &amp; (~(sbi-&gt;s_cluster_ratio - 1));
+		lblk_from = EXT4_LBLK_CMASK(sbi, lblk_start);
 		lblk_to = lblk_from + c_offset - 1;
 
 		if (ext4_find_delalloc_range(inode, lblk_from, lblk_to))
@@ -3839,7 +3838,7 @@ get_reserved_cluster_alloc(struct inode *inode, ext4_lblk_t lblk_start,
 	}
 
 	/* Now check towards right. */
-	c_offset = (lblk_start + num_blks) &amp; (sbi-&gt;s_cluster_ratio - 1);
+	c_offset = EXT4_LBLK_COFF(sbi, lblk_start + num_blks);
 	if (allocated_clusters &amp;&amp; c_offset) {
 		lblk_from = lblk_start + num_blks;
 		lblk_to = lblk_from + (sbi-&gt;s_cluster_ratio - c_offset) - 1;
@@ -4047,7 +4046,7 @@ static int get_implied_cluster_alloc(struct super_block *sb,
 				     struct ext4_ext_path *path)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
-	ext4_lblk_t c_offset = map-&gt;m_lblk &amp; (sbi-&gt;s_cluster_ratio-1);
+	ext4_lblk_t c_offset = EXT4_LBLK_COFF(sbi, map-&gt;m_lblk);
 	ext4_lblk_t ex_cluster_start, ex_cluster_end;
 	ext4_lblk_t rr_cluster_start;
 	ext4_lblk_t ee_block = le32_to_cpu(ex-&gt;ee_block);
@@ -4065,8 +4064,7 @@ static int get_implied_cluster_alloc(struct super_block *sb,
 	    (rr_cluster_start == ex_cluster_start)) {
 		if (rr_cluster_start == ex_cluster_end)
 			ee_start += ee_len - 1;
-		map-&gt;m_pblk = (ee_start &amp; ~(sbi-&gt;s_cluster_ratio - 1)) +
-			c_offset;
+		map-&gt;m_pblk = EXT4_PBLK_CMASK(sbi, ee_start) + c_offset;
 		map-&gt;m_len = min(map-&gt;m_len,
 				 (unsigned) sbi-&gt;s_cluster_ratio - c_offset);
 		/*
@@ -4220,7 +4218,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 	 */
 	map-&gt;m_flags &amp;= ~EXT4_MAP_FROM_CLUSTER;
 	newex.ee_block = cpu_to_le32(map-&gt;m_lblk);
-	cluster_offset = map-&gt;m_lblk &amp; (sbi-&gt;s_cluster_ratio-1);
+	cluster_offset = EXT4_LBLK_CMASK(sbi, map-&gt;m_lblk);
 
 	/*
 	 * If we are doing bigalloc, check to see if the extent returned
@@ -4288,7 +4286,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 	 * needed so that future calls to get_implied_cluster_alloc()
 	 * work correctly.
 	 */
-	offset = map-&gt;m_lblk &amp; (sbi-&gt;s_cluster_ratio - 1);
+	offset = EXT4_LBLK_COFF(sbi, map-&gt;m_lblk);
 	ar.len = EXT4_NUM_B2C(sbi, offset+allocated);
 	ar.goal -= offset;
 	ar.logical -= offset;
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 04766d9a29cd..04a5c7504be9 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -4126,7 +4126,7 @@ ext4_mb_initialize_context(struct ext4_allocation_context *ac,
 	ext4_get_group_no_and_offset(sb, goal, &amp;group, &amp;block);
 
 	/* set up allocation goals */
-	ac-&gt;ac_b_ex.fe_logical = ar-&gt;logical &amp; ~(sbi-&gt;s_cluster_ratio - 1);
+	ac-&gt;ac_b_ex.fe_logical = EXT4_LBLK_CMASK(sbi, ar-&gt;logical);
 	ac-&gt;ac_status = AC_STATUS_CONTINUE;
 	ac-&gt;ac_sb = sb;
 	ac-&gt;ac_inode = ar-&gt;inode;
@@ -4668,7 +4668,7 @@ void ext4_free_blocks(handle_t *handle, struct inode *inode,
 	 * blocks at the beginning or the end unless we are explicitly
 	 * requested to avoid doing so.
 	 */
-	overflow = block &amp; (sbi-&gt;s_cluster_ratio - 1);
+	overflow = EXT4_PBLK_COFF(sbi, block);
 	if (overflow) {
 		if (flags &amp; EXT4_FREE_BLOCKS_NOFREE_FIRST_CLUSTER) {
 			overflow = sbi-&gt;s_cluster_ratio - overflow;
@@ -4682,7 +4682,7 @@ void ext4_free_blocks(handle_t *handle, struct inode *inode,
 			count += overflow;
 		}
 	}
-	overflow = count &amp; (sbi-&gt;s_cluster_ratio - 1);
+	overflow = EXT4_LBLK_COFF(sbi, count);
 	if (overflow) {
 		if (flags &amp; EXT4_FREE_BLOCKS_NOFREE_LAST_CLUSTER) {
 			if (count &gt; overflow)</pre><hr><pre>commit f6c07cad081ba222d63623d913aafba5586c1d2c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Dec 8 21:12:59 2013 -0500

    jbd2: don't BUG but return ENOSPC if a handle runs out of space
    
    If a handle runs out of space, we currently stop the kernel with a BUG
    in jbd2_journal_dirty_metadata().  This makes it hard to figure out
    what might be going on.  So return an error of ENOSPC, so we can let
    the file system layer figure out what is going on, to make it more
    likely we can get useful debugging information).  This should make it
    easier to debug problems such as the one which was reported by:
    
        https://bugzilla.kernel.org/show_bug.cgi?id=44731
    
    The only two callers of this function are ext4_handle_dirty_metadata()
    and ocfs2_journal_dirty().  The ocfs2 function will trigger a
    BUG_ON(), which means there will be no change in behavior.  The ext4
    function will call ext4_error_inode() which will print the useful
    debugging information and then handle the situation using ext4's error
    handling mechanisms (i.e., which might mean halting the kernel or
    remounting the file system read-only).
    
    Also, since both file systems already call WARN_ON(), drop the WARN_ON
    from jbd2_journal_dirty_metadata() to avoid two stack traces from
    being displayed.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: ocfs2-devel@oss.oracle.com
    Acked-by: Joel Becker &lt;jlbec@evilplan.org&gt;

diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c
index 7aa9a32573bb..b0b74e58697b 100644
--- a/fs/jbd2/transaction.c
+++ b/fs/jbd2/transaction.c
@@ -1290,7 +1290,10 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 		 * once a transaction -bzzz
 		 */
 		jh-&gt;b_modified = 1;
-		J_ASSERT_JH(jh, handle-&gt;h_buffer_credits &gt; 0);
+		if (handle-&gt;h_buffer_credits &lt;= 0) {
+			ret = -ENOSPC;
+			goto out_unlock_bh;
+		}
 		handle-&gt;h_buffer_credits--;
 	}
 
@@ -1373,7 +1376,6 @@ int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)
 	jbd2_journal_put_journal_head(jh);
 out:
 	JBUFFER_TRACE(jh, "exit");
-	WARN_ON(ret);	/* All errors are bugs, so dump the stack */
 	return ret;
 }
 </pre><hr><pre>commit ae1495b12df1897d4f42842a7aa7276d920f6290
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Dec 2 09:31:36 2013 -0500

    ext4: call ext4_error_inode() if jbd2_journal_dirty_metadata() fails
    
    While it's true that errors can only happen if there is a bug in
    jbd2_journal_dirty_metadata(), if a bug does happen, we need to halt
    the kernel or remount the file system read-only in order to avoid
    further data loss.  The ext4_journal_abort_handle() function doesn't
    do any of this, and while it's likely that this call (since it doesn't
    adjust refcounts) will likely result in the file system eventually
    deadlocking since the current transaction will never be able to close,
    it's much cleaner to call let ext4's error handling system deal with
    this situation.
    
    There's a separate bug here which is that if certain jbd2 errors
    errors occur and file system is mounted errors=continue, the file
    system will probably eventually end grind to a halt as described
    above.  But things have been this way in a long time, and usually when
    we have these sorts of errors it's pretty much a disaster --- and
    that's why the jbd2 layer aggressively retries memory allocations,
    which is the most likely cause of these jbd2 errors.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Jan Kara &lt;jack@suse.cz&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/ext4_jbd2.c b/fs/ext4/ext4_jbd2.c
index 17ac112ab101..3fe29de832c8 100644
--- a/fs/ext4/ext4_jbd2.c
+++ b/fs/ext4/ext4_jbd2.c
@@ -259,6 +259,15 @@ int __ext4_handle_dirty_metadata(const char *where, unsigned int line,
 		if (WARN_ON_ONCE(err)) {
 			ext4_journal_abort_handle(where, line, __func__, bh,
 						  handle, err);
+			ext4_error_inode(inode, where, line,
+					 bh-&gt;b_blocknr,
+					 "journal_dirty_metadata failed: "
+					 "handle type %u started at line %u, "
+					 "credits %u/%u, errcode %d",
+					 handle-&gt;h_type,
+					 handle-&gt;h_line_no,
+					 handle-&gt;h_requested_credits,
+					 handle-&gt;h_buffer_credits, err);
 		}
 	} else {
 		if (inode)</pre>
    <div class="pagination">
        <a href='1_43.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><span>[44]</span><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_45.html'>Next&gt;&gt;</a>
    <div>
</body>
