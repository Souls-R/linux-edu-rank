<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_9.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><span>[10]</span><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_11.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit bc7accec8788ada4f459461194c2b8fad94ed239
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Dec 31 02:22:19 2010 -0600

    [SCSI] be2iscsi: fix gfp use in alloc_pdu
    
    The pdu allication callout is called from a spin lock
    and in the IO path so we cannot use GFP_KERNEL. This
    has the driver use GFP_ATOMIC.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index 75a85aa9e882..be07ca06177e 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -3785,7 +3785,7 @@ static int beiscsi_alloc_pdu(struct iscsi_task *task, uint8_t opcode)
 	dma_addr_t paddr;
 
 	io_task-&gt;cmd_bhs = pci_pool_alloc(beiscsi_sess-&gt;bhs_pool,
-					  GFP_KERNEL, &amp;paddr);
+					  GFP_ATOMIC, &amp;paddr);
 	if (!io_task-&gt;cmd_bhs)
 		return -ENOMEM;
 	io_task-&gt;bhs_pa.u.a64.address = paddr;</pre><hr><pre>commit df4da5cdfca05b37b366b9c69925b68586969c1c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Dec 31 02:22:18 2010 -0600

    [SCSI] libiscsi: add more informative failure message during iscsi scsi eh
    
    This adds a more informative error code and message
    for the iscsi scsi eh session drop paths. This allows
    you to distinguish if the session was dropped due to
    a connection failure vs the iscsi layer dropping
    the session due to scsi eh failure processing.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 7551abe40900..3eddab0774e4 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1796,9 +1796,9 @@ static int iscsi_exec_task_mgmt_fn(struct iscsi_conn *conn,
 				      NULL, 0);
 	if (!task) {
 		spin_unlock_bh(&amp;session-&gt;lock);
+		iscsi_conn_printk(KERN_ERR, conn, "Could not send TMF.\n");
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 		spin_lock_bh(&amp;session-&gt;lock);
-		ISCSI_DBG_EH(session, "tmf exec failure\n");
 		return -EPERM;
 	}
 	conn-&gt;tmfcmd_pdus_cnt++;
@@ -2203,7 +2203,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 		goto success_unlocked;
 	case TMF_TIMEDOUT:
 		spin_unlock_bh(&amp;session-&gt;lock);
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		iscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);
 		goto failed_unlocked;
 	case TMF_NOT_FOUND:
 		if (!sc-&gt;SCp.ptr) {
@@ -2290,7 +2290,7 @@ int iscsi_eh_device_reset(struct scsi_cmnd *sc)
 		break;
 	case TMF_TIMEDOUT:
 		spin_unlock_bh(&amp;session-&gt;lock);
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		iscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);
 		goto done;
 	default:
 		conn-&gt;tmf_state = TMF_INITIAL;
@@ -2371,7 +2371,7 @@ int iscsi_eh_session_reset(struct scsi_cmnd *sc)
 	 * we drop the lock here but the leadconn cannot be destoyed while
 	 * we are in the scsi eh
 	 */
-	iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	iscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);
 
 	ISCSI_DBG_EH(session, "wait for relogin\n");
 	wait_event_interruptible(conn-&gt;ehwait,
@@ -2453,7 +2453,7 @@ int iscsi_eh_target_reset(struct scsi_cmnd *sc)
 		break;
 	case TMF_TIMEDOUT:
 		spin_unlock_bh(&amp;session-&gt;lock);
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+		iscsi_conn_failure(conn, ISCSI_ERR_SCSI_EH_SESSION_RST);
 		goto done;
 	default:
 		conn-&gt;tmf_state = TMF_INITIAL;
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index a8631acd37c3..c3e1cbcc2ad2 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -263,6 +263,7 @@ enum iscsi_err {
 	ISCSI_ERR_INVALID_HOST		= ISCSI_ERR_BASE + 18,
 	ISCSI_ERR_XMIT_FAILED		= ISCSI_ERR_BASE + 19,
 	ISCSI_ERR_TCP_CONN_CLOSE	= ISCSI_ERR_BASE + 20,
+	ISCSI_ERR_SCSI_EH_SESSION_RST	= ISCSI_ERR_BASE + 21,
 };
 
 /*</pre><hr><pre>commit a1e0063d0c015145946981262f8d5f9758d8a895
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Oct 26 05:45:30 2010 -0700

    [SCSI] qla4xxx: Fix cmd check in qla4xxx_cmd_wait
    
    If the command has timedout then the block layer has called
    blk_mark_rq_complete. If qla4xxx_cmd_wait is then called
    from qla4xxx_eh_host_reset, we will always fail, because if
    the driver calls scsi_done then the the block layer will fail
    at blk_complete_request's blk_mark_rq_complete call instead of
    calling the normal completion path including the function,
    blk_queue_end_tag, which releases the tag.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Vikas Chaudhary &lt;vikas.chaudhary@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index f1c58eb26ba2..f4cd846abf6d 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -881,7 +881,13 @@ static int qla4xxx_cmd_wait(struct scsi_qla_host *ha)
 		/* Find a command that hasn't completed. */
 		for (index = 0; index &lt; ha-&gt;host-&gt;can_queue; index++) {
 			cmd = scsi_host_find_tag(ha-&gt;host, index);
-			if (cmd != NULL)
+			/*
+			 * We cannot just check if the index is valid,
+			 * becase if we are run from the scsi eh, then
+			 * the scsi/block layer is going to prevent
+			 * the tag from being released.
+			 */
+			if (cmd != NULL &amp;&amp; CMD_SP(cmd))
 				break;
 		}
 		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);</pre><hr><pre>commit 170babc3721997b7808193221f94926df44f3d1e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Oct 15 11:27:47 2010 -0700

    [SCSI] qla2xxx: Drop srb reference before waiting for completion.
    
    This patch fixes a regression introduced by commit
    083a469db4ecf3b286a96b5b722c37fc1affe0be
    
    qla2xxx_eh_wait_on_command() is waiting for an srb to
    complete, which will never happen as the routine took
    a reference to the srb previously and will only drop it
    after this function. So every command abort will fail.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Giridhar Malavali &lt;giridhar.malavali@qlogic.com&gt;
    Signed-off-by: Madhuranath Iyengar &lt;Madhu.Iyengar@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 05977e736f76..02232deaf82d 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -830,62 +830,44 @@ qla2xxx_eh_abort(struct scsi_cmnd *cmd)
 {
 	scsi_qla_host_t *vha = shost_priv(cmd-&gt;device-&gt;host);
 	srb_t *sp;
-	int ret, i;
+	int ret;
 	unsigned int id, lun;
 	unsigned long flags;
 	int wait = 0;
 	struct qla_hw_data *ha = vha-&gt;hw;
-	struct req_que *req = vha-&gt;req;
-	srb_t *spt;
-	int got_ref = 0;
 
 	fc_block_scsi_eh(cmd);
 
 	if (!CMD_SP(cmd))
 		return SUCCESS;
 
-	ret = SUCCESS;
-
 	id = cmd-&gt;device-&gt;id;
 	lun = cmd-&gt;device-&gt;lun;
-	spt = (srb_t *) CMD_SP(cmd);
-	if (!spt)
-		return SUCCESS;
 
-	/* Check active list for command command. */
 	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);
-	for (i = 1; i &lt; MAX_OUTSTANDING_COMMANDS; i++) {
-		sp = req-&gt;outstanding_cmds[i];
-
-		if (sp == NULL)
-			continue;
-		if ((sp-&gt;ctx) &amp;&amp; !(sp-&gt;flags &amp; SRB_FCP_CMND_DMA_VALID) &amp;&amp;
-		    !IS_PROT_IO(sp))
-			continue;
-		if (sp-&gt;cmd != cmd)
-			continue;
+	sp = (srb_t *) CMD_SP(cmd);
+	if (!sp) {
+		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
+		return SUCCESS;
+	}
 
-		DEBUG2(printk("%s(%ld): aborting sp %p from RISC.",
-		    __func__, vha-&gt;host_no, sp));
+	DEBUG2(printk("%s(%ld): aborting sp %p from RISC.",
+	    __func__, vha-&gt;host_no, sp));
 
-		/* Get a reference to the sp and drop the lock.*/
-		sp_get(sp);
-		got_ref++;
+	/* Get a reference to the sp and drop the lock.*/
+	sp_get(sp);
 
-		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
-		if (ha-&gt;isp_ops-&gt;abort_command(sp)) {
-			DEBUG2(printk("%s(%ld): abort_command "
-			"mbx failed.\n", __func__, vha-&gt;host_no));
-			ret = FAILED;
-		} else {
-			DEBUG3(printk("%s(%ld): abort_command "
-			"mbx success.\n", __func__, vha-&gt;host_no));
-			wait = 1;
-		}
-		spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);
-		break;
-	}
 	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
+	if (ha-&gt;isp_ops-&gt;abort_command(sp)) {
+		DEBUG2(printk("%s(%ld): abort_command "
+		"mbx failed.\n", __func__, vha-&gt;host_no));
+		ret = FAILED;
+	} else {
+		DEBUG3(printk("%s(%ld): abort_command "
+		"mbx success.\n", __func__, vha-&gt;host_no));
+		wait = 1;
+	}
+	qla2x00_sp_compl(ha, sp);
 
 	/* Wait for the command to be returned. */
 	if (wait) {
@@ -897,9 +879,6 @@ qla2xxx_eh_abort(struct scsi_cmnd *cmd)
 		}
 	}
 
-	if (got_ref)
-		qla2x00_sp_compl(ha, sp);
-
 	qla_printk(KERN_INFO, ha,
 	    "scsi(%ld:%d:%d): Abort command issued -- %d %x.\n",
 	    vha-&gt;host_no, id, lun, wait, ret);</pre><hr><pre>commit 73b4376477672a4336cba5f26ede2e277511ce70
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Oct 8 17:12:10 2010 -0700

    [SCSI] libfc: fix setting of rport dev loss
    
    There does not seem to be a reason why libfc adds a 5
    second delay to the user requested value for the dev loss
    tmo. There also does not seem to be a reason to allow
    setting it to 0 (or really close).
    
    This patch removes the extra 5 sec delay, and for 0 it
    sets it to 1 like other fc drivers. We should actually
    be able to set it to 0 since the queue_delayed_work API
    will just call queue_work, but other drivers set it to 1 in
    that case.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Robert Love &lt;robert.w.love@intel.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libfc/fc_rport.c b/drivers/scsi/libfc/fc_rport.c
index b9f2286fe0cb..a84ef13ed74a 100644
--- a/drivers/scsi/libfc/fc_rport.c
+++ b/drivers/scsi/libfc/fc_rport.c
@@ -196,9 +196,9 @@ static const char *fc_rport_state(struct fc_rport_priv *rdata)
 void fc_set_rport_loss_tmo(struct fc_rport *rport, u32 timeout)
 {
 	if (timeout)
-		rport-&gt;dev_loss_tmo = timeout + 5;
+		rport-&gt;dev_loss_tmo = timeout;
 	else
-		rport-&gt;dev_loss_tmo = 30;
+		rport-&gt;dev_loss_tmo = 1;
 }
 EXPORT_SYMBOL(fc_set_rport_loss_tmo);
 </pre><hr><pre>commit 92b3e5bbbebe86dd0071ccf23c1b21031f74bf56
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Oct 6 22:51:17 2010 -0700

    [SCSI] qla4xxx: grab hardware_lock in eh_abort before accessing srb
    
    grab hardware_lock in eh_abort before accessing srb to avoid
    race between command completion and get refcount on srb.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Vikas Chaudhary &lt;vikas.chaudhary@qlogic.com&gt;
    Signed-off-by: Ravi Anand &lt;ravi.anand@qlogic.com&gt;
    Reviewed-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 4b6cdb68a52a..f1c58eb26ba2 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -2006,6 +2006,7 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 	unsigned int id = cmd-&gt;device-&gt;id;
 	unsigned int lun = cmd-&gt;device-&gt;lun;
 	unsigned long serial = cmd-&gt;serial_number;
+	unsigned long flags;
 	struct srb *srb = NULL;
 	int ret = SUCCESS;
 	int wait = 0;
@@ -2014,12 +2015,14 @@ static int qla4xxx_eh_abort(struct scsi_cmnd *cmd)
 	    "scsi%ld:%d:%d: Abort command issued cmd=%p, pid=%ld\n",
 	    ha-&gt;host_no, id, lun, cmd, serial);
 
+	spin_lock_irqsave(&amp;ha-&gt;hardware_lock, flags);
 	srb = (struct srb *) CMD_SP(cmd);
-
-	if (!srb)
+	if (!srb) {
+		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
 		return SUCCESS;
-
+	}
 	kref_get(&amp;srb-&gt;srb_ref);
+	spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
 
 	if (qla4xxx_abort_task(ha, srb) != QLA_SUCCESS) {
 		DEBUG3(printk("scsi%ld:%d:%d: Abort_task mbx failed.\n",</pre><hr><pre>commit 986fe6c7f50974e871b8ab5a800f5310ea25b361
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Oct 6 03:10:59 2010 -0500

    [SCSI] Fix regressions in scsi_internal_device_block
    
    Deleting a SCSI device on a blocked fc_remote_port (before
    fast_io_fail_tmo fires) results in a hanging thread:
    
      STACK:
      0 schedule+1108 [0x5cac48]
      1 schedule_timeout+528 [0x5cb7fc]
      2 wait_for_common+266 [0x5ca6be]
      3 blk_execute_rq+160 [0x354054]
      4 scsi_execute+324 [0x3b7ef4]
      5 scsi_execute_req+162 [0x3b80ca]
      6 sd_sync_cache+138 [0x3cf662]
      7 sd_shutdown+138 [0x3cf91a]
      8 sd_remove+112 [0x3cfe4c]
      9 __device_release_driver+124 [0x3a08b8]
    10 device_release_driver+60 [0x3a0a5c]
    11 bus_remove_device+266 [0x39fa76]
    12 device_del+340 [0x39d818]
    13 __scsi_remove_device+204 [0x3bcc48]
    14 scsi_remove_device+66 [0x3bcc8e]
    15 sysfs_schedule_callback_work+50 [0x260d66]
    16 worker_thread+622 [0x162326]
    17 kthread+160 [0x1680b0]
    18 kernel_thread_starter+6 [0x10aaea]
    
    During the delete, the SCSI device is in moved to SDEV_CANCEL.  When
    the FC transport class later calls scsi_target_unblock, this has no
    effect, since scsi_internal_device_unblock ignores SCSI devics in this
    state.
    
    It looks like all these are regressions caused by:
    5c10e63c943b4c67561ddc6bf61e01d4141f881f
    [SCSI] limit state transitions in scsi_internal_device_unblock
    
    Fix by rejecting offline and cancel in the state transition.
    
    Signed-off-by: Christof Schmitt &lt;christof.schmitt@de.ibm.com&gt;
    [jejb: Original patch by Christof Schmitt, modified by Mike Christie]
    Cc: Stable Tree &lt;stable@kernel.org&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 8041fe1ab179..eafeeda6e194 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -2438,7 +2438,8 @@ scsi_internal_device_unblock(struct scsi_device *sdev)
 		sdev-&gt;sdev_state = SDEV_RUNNING;
 	else if (sdev-&gt;sdev_state == SDEV_CREATED_BLOCK)
 		sdev-&gt;sdev_state = SDEV_CREATED;
-	else
+	else if (sdev-&gt;sdev_state != SDEV_CANCEL &amp;&amp;
+		 sdev-&gt;sdev_state != SDEV_OFFLINE)
 		return -EINVAL;
 
 	spin_lock_irqsave(q-&gt;queue_lock, flags);</pre><hr><pre>commit 43ca910a9c90566308f39f51ac03a55f94a5f83c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 15 16:52:32 2010 -0500

    [SCSI] fc class: add fc host dev loss sysfs file
    
    This adds a fc host dev loss sysfs file. Instead of
    calling into the driver using the get_host_def_dev_loss_tmo
    callback, we allow drivers to init the dev loss like is done
    for other fc host params, and then the fc class will handle
    updating the value if the user writes to the new sysfs file.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 78486d540652..998c01be3234 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -52,6 +52,25 @@ static int fc_bsg_rportadd(struct Scsi_Host *, struct fc_rport *);
 static void fc_bsg_remove(struct request_queue *);
 static void fc_bsg_goose_queue(struct fc_rport *);
 
+/*
+ * Module Parameters
+ */
+
+/*
+ * dev_loss_tmo: the default number of seconds that the FC transport
+ *   should insulate the loss of a remote port.
+ *   The maximum will be capped by the value of SCSI_DEVICE_BLOCK_MAX_TIMEOUT.
+ */
+static unsigned int fc_dev_loss_tmo = 60;		/* seconds */
+
+module_param_named(dev_loss_tmo, fc_dev_loss_tmo, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(dev_loss_tmo,
+		 "Maximum number of seconds that the FC transport should"
+		 " insulate the loss of a remote port. Once this value is"
+		 " exceeded, the scsi target is removed. Value should be"
+		 " between 1 and SCSI_DEVICE_BLOCK_MAX_TIMEOUT if"
+		 " fast_io_fail_tmo is not set.");
+
 /*
  * Redefine so that we can have same named attributes in the
  * sdev/starget/host objects.
@@ -408,6 +427,7 @@ static int fc_host_setup(struct transport_container *tc, struct device *dev,
 	if (!fc_host-&gt;work_q)
 		return -ENOMEM;
 
+	fc_host-&gt;dev_loss_tmo = fc_dev_loss_tmo;
 	snprintf(fc_host-&gt;devloss_work_q_name,
 		 sizeof(fc_host-&gt;devloss_work_q_name),
 		 "fc_dl_%d", shost-&gt;host_no);
@@ -461,25 +481,6 @@ static DECLARE_TRANSPORT_CLASS(fc_vport_class,
 			       NULL,
 			       NULL);
 
-/*
- * Module Parameters
- */
-
-/*
- * dev_loss_tmo: the default number of seconds that the FC transport
- *   should insulate the loss of a remote port.
- *   The maximum will be capped by the value of SCSI_DEVICE_BLOCK_MAX_TIMEOUT.
- */
-static unsigned int fc_dev_loss_tmo = 60;		/* seconds */
-
-module_param_named(dev_loss_tmo, fc_dev_loss_tmo, uint, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(dev_loss_tmo,
-		 "Maximum number of seconds that the FC transport should"
-		 " insulate the loss of a remote port. Once this value is"
-		 " exceeded, the scsi target is removed. Value should be"
-		 " between 1 and SCSI_DEVICE_BLOCK_MAX_TIMEOUT if"
-		 " fast_io_fail_tmo is not set.");
-
 /*
  * Netlink Infrastructure
  */
@@ -830,24 +831,32 @@ static FC_DEVICE_ATTR(rport, supported_classes, S_IRUGO,
 /*
  * dev_loss_tmo attribute
  */
-fc_rport_show_function(dev_loss_tmo, "%d\n", 20, )
-static ssize_t
-store_fc_rport_dev_loss_tmo(struct device *dev, struct device_attribute *attr,
-			    const char *buf, size_t count)
+static int fc_str_to_dev_loss(const char *buf, unsigned long *val)
+{
+	char *cp;
+
+	*val = simple_strtoul(buf, &amp;cp, 0);
+	if ((*cp &amp;&amp; (*cp != '\n')) || (*val &lt; 0))
+		return -EINVAL;
+	/*
+	 * Check for overflow; dev_loss_tmo is u32
+	 */
+	if (*val &gt; UINT_MAX)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int fc_rport_set_dev_loss_tmo(struct fc_rport *rport,
+				     unsigned long val)
 {
-	unsigned long val;
-	struct fc_rport *rport = transport_class_to_rport(dev);
 	struct Scsi_Host *shost = rport_to_shost(rport);
 	struct fc_internal *i = to_fc_internal(shost-&gt;transportt);
-	char *cp;
+
 	if ((rport-&gt;port_state == FC_PORTSTATE_BLOCKED) ||
 	    (rport-&gt;port_state == FC_PORTSTATE_DELETED) ||
 	    (rport-&gt;port_state == FC_PORTSTATE_NOTPRESENT))
 		return -EBUSY;
-	val = simple_strtoul(buf, &amp;cp, 0);
-	if ((*cp &amp;&amp; (*cp != '\n')) || (val &lt; 0))
-		return -EINVAL;
-
 	/*
 	 * Check for overflow; dev_loss_tmo is u32
 	 */
@@ -863,6 +872,25 @@ store_fc_rport_dev_loss_tmo(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 
 	i-&gt;f-&gt;set_rport_dev_loss_tmo(rport, val);
+	return 0;
+}
+
+fc_rport_show_function(dev_loss_tmo, "%d\n", 20, )
+static ssize_t
+store_fc_rport_dev_loss_tmo(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct fc_rport *rport = transport_class_to_rport(dev);
+	unsigned long val;
+	int rc;
+
+	rc = fc_str_to_dev_loss(buf, &amp;val);
+	if (rc)
+		return rc;
+
+	rc = fc_rport_set_dev_loss_tmo(rport, val);
+	if (rc)
+		return rc;
 	return count;
 }
 static FC_DEVICE_ATTR(rport, dev_loss_tmo, S_IRUGO | S_IWUSR,
@@ -1608,8 +1636,35 @@ store_fc_private_host_issue_lip(struct device *dev,
 static FC_DEVICE_ATTR(host, issue_lip, S_IWUSR, NULL,
 			store_fc_private_host_issue_lip);
 
-fc_private_host_rd_attr(npiv_vports_inuse, "%u\n", 20);
+static ssize_t
+store_fc_private_host_dev_loss_tmo(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct Scsi_Host *shost = transport_class_to_shost(dev);
+	struct fc_host_attrs *fc_host = shost_to_fc_host(shost);
+	struct fc_rport *rport;
+	unsigned long val, flags;
+	int rc;
+
+	rc = fc_str_to_dev_loss(buf, &amp;val);
+	if (rc)
+		return rc;
+
+	fc_host_dev_loss_tmo(shost) = val;
+	spin_lock_irqsave(shost-&gt;host_lock, flags);
+	list_for_each_entry(rport, &amp;fc_host-&gt;rports, peers)
+		fc_rport_set_dev_loss_tmo(rport, val);
+	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
+	return count;
+}
 
+fc_private_host_show_function(dev_loss_tmo, "%d\n", 20, );
+static FC_DEVICE_ATTR(host, dev_loss_tmo, S_IRUGO | S_IWUSR,
+		      show_fc_host_dev_loss_tmo,
+		      store_fc_private_host_dev_loss_tmo);
+
+fc_private_host_rd_attr(npiv_vports_inuse, "%u\n", 20);
 
 /*
  * Host Statistics Management
@@ -2165,6 +2220,7 @@ fc_attach_transport(struct fc_function_template *ft)
 	SETUP_HOST_ATTRIBUTE_RW(system_hostname);
 
 	/* Transport-managed attributes */
+	SETUP_PRIVATE_HOST_ATTRIBUTE_RW(dev_loss_tmo);
 	SETUP_PRIVATE_HOST_ATTRIBUTE_RW(tgtid_bind_type);
 	if (ft-&gt;issue_fc_host_lip)
 		SETUP_PRIVATE_HOST_ATTRIBUTE_RW(issue_lip);
@@ -2525,11 +2581,7 @@ fc_rport_create(struct Scsi_Host *shost, int channel,
 
 	rport-&gt;maxframe_size = -1;
 	rport-&gt;supported_classes = FC_COS_UNSPECIFIED;
-	if (fci-&gt;f-&gt;get_host_def_dev_loss_tmo) {
-		fci-&gt;f-&gt;get_host_def_dev_loss_tmo(shost);
-		rport-&gt;dev_loss_tmo = fc_host_def_dev_loss_tmo(shost);
-	} else
-		rport-&gt;dev_loss_tmo = fc_dev_loss_tmo;
+	rport-&gt;dev_loss_tmo = fc_host-&gt;dev_loss_tmo;
 	memcpy(&amp;rport-&gt;node_name, &amp;ids-&gt;node_name, sizeof(rport-&gt;node_name));
 	memcpy(&amp;rport-&gt;port_name, &amp;ids-&gt;port_name, sizeof(rport-&gt;port_name));
 	rport-&gt;port_id = ids-&gt;port_id;
diff --git a/include/scsi/scsi_transport_fc.h b/include/scsi/scsi_transport_fc.h
index 9f98fca9b763..59816fe31e68 100644
--- a/include/scsi/scsi_transport_fc.h
+++ b/include/scsi/scsi_transport_fc.h
@@ -496,7 +496,7 @@ struct fc_host_attrs {
 	u64 fabric_name;
 	char symbolic_name[FC_SYMBOLIC_NAME_SIZE];
 	char system_hostname[FC_SYMBOLIC_NAME_SIZE];
-	u32 def_dev_loss_tmo;
+	u32 dev_loss_tmo;
 
 	/* Private (Transport-managed) Attributes */
 	enum fc_tgtid_binding_type  tgtid_bind_type;
@@ -581,8 +581,8 @@ struct fc_host_attrs {
 	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;devloss_work_q_name)
 #define fc_host_devloss_work_q(x) \
 	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;devloss_work_q)
-#define fc_host_def_dev_loss_tmo(x) \
-	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;def_dev_loss_tmo)
+#define fc_host_dev_loss_tmo(x) \
+	(((struct fc_host_attrs *)(x)-&gt;shost_data)-&gt;dev_loss_tmo)
 
 
 struct fc_bsg_buffer {
@@ -643,7 +643,6 @@ struct fc_function_template {
 	void	(*get_host_fabric_name)(struct Scsi_Host *);
 	void	(*get_host_symbolic_name)(struct Scsi_Host *);
 	void	(*set_host_system_hostname)(struct Scsi_Host *);
-	void	(*get_host_def_dev_loss_tmo)(struct Scsi_Host *);
 
 	struct fc_host_statistics * (*get_fc_host_stats)(struct Scsi_Host *);
 	void	(*reset_fc_host_stats)(struct Scsi_Host *);</pre><hr><pre>commit 0af5d708aae3aef1f98a1c689007b92db2c10277
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 15 16:52:31 2010 -0500

    [SCSI] lpfc: prep for fc host dev loss tmo support
    
    This removes the driver's get_host_def_dev_loss_tmo
    callback and just has the driver set the dev loss
    using the fc class fc_host_dev_loss_tmo macro like is
    done for other fc params.
    
    It also adds compat support for the driver's existing
    dev loss and nodev sysfs and modparams.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/lpfc/lpfc_attr.c b/drivers/scsi/lpfc/lpfc_attr.c
index 87c2b6b858f7..f6efc6fe86d7 100644
--- a/drivers/scsi/lpfc/lpfc_attr.c
+++ b/drivers/scsi/lpfc/lpfc_attr.c
@@ -2159,6 +2159,11 @@ lpfc_nodev_tmo_set(struct lpfc_vport *vport, int val)
 	if (val &gt;= LPFC_MIN_DEVLOSS_TMO &amp;&amp; val &lt;= LPFC_MAX_DEVLOSS_TMO) {
 		vport-&gt;cfg_nodev_tmo = val;
 		vport-&gt;cfg_devloss_tmo = val;
+		/*
+		 * For compat: set the fc_host dev loss so new rports
+		 * will get the value.
+		 */
+		fc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;
 		lpfc_update_rport_devloss_tmo(vport);
 		return 0;
 	}
@@ -2208,6 +2213,7 @@ lpfc_devloss_tmo_set(struct lpfc_vport *vport, int val)
 		vport-&gt;cfg_nodev_tmo = val;
 		vport-&gt;cfg_devloss_tmo = val;
 		vport-&gt;dev_loss_tmo_changed = 1;
+		fc_host_dev_loss_tmo(lpfc_shost_from_vport(vport)) = val;
 		lpfc_update_rport_devloss_tmo(vport);
 		return 0;
 	}
@@ -4370,14 +4376,6 @@ lpfc_get_starget_port_name(struct scsi_target *starget)
 		ndlp ? wwn_to_u64(ndlp-&gt;nlp_portname.u.wwn) : 0;
 }
 
-static void
-lpfc_get_host_def_loss_tmo(struct Scsi_Host *shost)
-{
-        struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;
-
-	fc_host_def_dev_loss_tmo(shost) = vport-&gt;cfg_devloss_tmo;
-}
-
 /**
  * lpfc_set_rport_loss_tmo - Set the rport dev loss tmo
  * @rport: fc rport address.
@@ -4486,7 +4484,6 @@ struct fc_function_template lpfc_transport_functions = {
 	.get_host_fabric_name = lpfc_get_host_fabric_name,
 	.show_host_fabric_name = 1,
 
-	.get_host_def_dev_loss_tmo = lpfc_get_host_def_loss_tmo,
 	/*
 	 * The LPFC driver treats linkdown handling as target loss events
 	 * so there are no sysfs handlers for link_down_tmo.
@@ -4554,7 +4551,6 @@ struct fc_function_template lpfc_vport_transport_functions = {
 	.get_host_fabric_name = lpfc_get_host_fabric_name,
 	.show_host_fabric_name = 1,
 
-	.get_host_def_dev_loss_tmo = lpfc_get_host_def_loss_tmo,
 	/*
 	 * The LPFC driver treats linkdown handling as target loss events
 	 * so there are no sysfs handlers for link_down_tmo.
diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index da9ba06ad583..87a4d09a6641 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -2817,6 +2817,8 @@ void lpfc_host_attrib_init(struct Scsi_Host *shost)
 		(((uint32_t) vport-&gt;fc_sparam.cmn.bbRcvSizeMsb &amp; 0x0F) &lt;&lt; 8) |
 		(uint32_t) vport-&gt;fc_sparam.cmn.bbRcvSizeLsb;
 
+	fc_host_dev_loss_tmo(shost) = vport-&gt;cfg_devloss_tmo;
+
 	/* This value is also unchanging */
 	memset(fc_host_active_fc4s(shost), 0,
 	       sizeof(fc_host_active_fc4s(shost)));</pre><hr><pre>commit d2b5f10e5b93633a40d9263383b914f06019f00b
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Sep 15 16:52:30 2010 -0500

    [SCSI] qla2xxx: prep for fc host dev loss tmo support
    
    This removes the driver's get_host_def_dev_loss_tmo
    callback and just has the driver set the dev loss
    using the fc class fc_host_dev_loss_tmo macro like is
    done for other fc params.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Acked-by: Andrew Vasquez &lt;andrew.vasquez@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index c9781050c9ed..029fe6b9d463 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -1529,15 +1529,6 @@ qla2x00_set_rport_loss_tmo(struct fc_rport *rport, uint32_t timeout)
 		rport-&gt;dev_loss_tmo = 1;
 }
 
-static void
-qla2x00_get_host_def_loss_tmo(struct Scsi_Host *shost)
-{
-	scsi_qla_host_t *vha = shost_priv(shost);
-	struct qla_hw_data *ha = vha-&gt;hw;
-
-	fc_host_def_dev_loss_tmo(shost) = ha-&gt;port_down_retry_count;
-}
-
 static void
 qla2x00_dev_loss_tmo_callbk(struct fc_rport *rport)
 {
@@ -1785,6 +1776,7 @@ qla24xx_vport_create(struct fc_vport *fc_vport, bool disable)
 	}
 
 	/* initialize attributes */
+	fc_host_dev_loss_tmo(vha-&gt;host) = ha-&gt;port_down_retry_count;
 	fc_host_node_name(vha-&gt;host) = wwn_to_u64(vha-&gt;node_name);
 	fc_host_port_name(vha-&gt;host) = wwn_to_u64(vha-&gt;port_name);
 	fc_host_supported_classes(vha-&gt;host) =
@@ -1912,7 +1904,6 @@ struct fc_function_template qla2xxx_transport_functions = {
 	.show_host_fabric_name = 1,
 	.get_host_port_state = qla2x00_get_host_port_state,
 	.show_host_port_state = 1,
-	.get_host_def_dev_loss_tmo = qla2x00_get_host_def_loss_tmo,
 
 	.dd_fcrport_size = sizeof(struct fc_port *),
 	.show_rport_supported_classes = 1,
@@ -1959,7 +1950,6 @@ struct fc_function_template qla2xxx_transport_vport_functions = {
 	.show_host_fabric_name = 1,
 	.get_host_port_state = qla2x00_get_host_port_state,
 	.show_host_port_state = 1,
-	.get_host_def_dev_loss_tmo = qla2x00_get_host_def_loss_tmo,
 
 	.dd_fcrport_size = sizeof(struct fc_port *),
 	.show_rport_supported_classes = 1,
@@ -1988,6 +1978,7 @@ qla2x00_init_host_attr(scsi_qla_host_t *vha)
 	struct qla_hw_data *ha = vha-&gt;hw;
 	u32 speed = FC_PORTSPEED_UNKNOWN;
 
+	fc_host_dev_loss_tmo(vha-&gt;host) = ha-&gt;port_down_retry_count;
 	fc_host_node_name(vha-&gt;host) = wwn_to_u64(vha-&gt;node_name);
 	fc_host_port_name(vha-&gt;host) = wwn_to_u64(vha-&gt;port_name);
 	fc_host_supported_classes(vha-&gt;host) = FC_COS_CLASS3;</pre>
    <div class="pagination">
        <a href='5_9.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><span>[10]</span><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_11.html'>Next&gt;&gt;</a>
    <div>
</body>
