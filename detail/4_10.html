<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_9.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><span>[10]</span><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_11.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit cee277d92495a9ea49a6137fe7005d7c76b31b5b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed May 26 17:52:14 2010 -0400

    nfsd4: use generic callback code in null case
    
    This will eventually allow us, for example, to kick off null callback
    from contexts where we can't sleep.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index a037f26252ee..26fa878005cc 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -519,7 +519,7 @@ static void warn_no_callback_path(struct nfs4_client *clp, int reason)
 
 static void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)
 {
-	struct nfs4_client *clp = calldata;
+	struct nfs4_client *clp = container_of(calldata, struct nfs4_client, cl_cb_null);
 
 	if (task-&gt;tk_status)
 		warn_no_callback_path(clp, task-&gt;tk_status);
@@ -528,6 +528,8 @@ static void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)
 }
 
 static const struct rpc_call_ops nfsd4_cb_probe_ops = {
+	/* XXX: release method to ensure we set the cb channel down if
+	 * necessary on early failure? */
 	.rpc_call_done = nfsd4_cb_probe_done,
 };
 
@@ -543,21 +545,23 @@ int set_callback_cred(void)
 	return 0;
 }
 
+static struct workqueue_struct *callback_wq;
 
 void do_probe_callback(struct nfs4_client *clp)
 {
-	struct rpc_message msg = {
-		.rpc_proc       = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL],
-		.rpc_argp       = clp,
-		.rpc_cred	= callback_cred
-	};
-	int status;
+	struct nfsd4_callback *cb = &amp;clp-&gt;cl_cb_null;
 
-	status = rpc_call_async(clp-&gt;cl_cb_client, &amp;msg,
-				RPC_TASK_SOFT | RPC_TASK_SOFTCONN,
-				&amp;nfsd4_cb_probe_ops, (void *)clp);
-	if (status)
-		warn_no_callback_path(clp, status);
+	cb-&gt;cb_args.args_op = NULL;
+	cb-&gt;cb_args.args_clp = clp;
+
+	cb-&gt;cb_msg.rpc_proc = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL];
+	cb-&gt;cb_msg.rpc_argp = NULL;
+	cb-&gt;cb_msg.rpc_resp = NULL;
+	cb-&gt;cb_msg.rpc_cred = callback_cred;
+
+	cb-&gt;cb_ops = &amp;nfsd4_cb_probe_ops;
+
+	queue_work(callback_wq, &amp;cb-&gt;cb_work);
 }
 
 /*
@@ -713,8 +717,6 @@ static const struct rpc_call_ops nfsd4_cb_recall_ops = {
 	.rpc_release = nfsd4_cb_recall_release,
 };
 
-static struct workqueue_struct *callback_wq;
-
 int nfsd4_create_callback_queue(void)
 {
 	callback_wq = create_singlethread_workqueue("nfsd4_callbacks");
@@ -760,7 +762,8 @@ void nfsd4_do_callback_rpc(struct work_struct *w)
 		nfsd4_release_cb(cb);
 		return; /* Client is shutting down; give up. */
 	}
-	rpc_call_async(clnt, &amp;cb-&gt;cb_msg, RPC_TASK_SOFT, cb-&gt;cb_ops, cb);
+	rpc_call_async(clnt, &amp;cb-&gt;cb_msg, RPC_TASK_SOFT | RPC_TASK_SOFTCONN,
+			cb-&gt;cb_ops, cb);
 }
 
 void nfsd4_cb_recall(struct nfs4_delegation *dp)
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index d347180ce55a..2f464fb26afc 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -978,6 +978,7 @@ static struct nfs4_client *create_client(struct xdr_netobj name, char *recdir,
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_delegations);
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_sessions);
 	INIT_LIST_HEAD(&amp;clp-&gt;cl_lru);
+	INIT_WORK(&amp;clp-&gt;cl_cb_null.cb_work, nfsd4_do_callback_rpc);
 	clp-&gt;cl_time = get_seconds();
 	clear_bit(0, &amp;clp-&gt;cl_cb_slot_busy);
 	rpc_init_wait_queue(&amp;clp-&gt;cl_cb_waitq, "Backchannel slot table");
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index 6e592148ad80..19732d531cda 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -223,6 +223,7 @@ struct nfs4_client {
 	struct nfs4_cb_conn	cl_cb_conn;
 	struct rpc_clnt		*cl_cb_client;
 	atomic_t		cl_cb_set;
+	struct nfsd4_callback	cl_cb_null;
 
 	/* for nfs41 */
 	struct list_head	cl_sessions;</pre><hr><pre>commit 5878453dbde627a8e1b5a4693087e36cb88d45b1
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sun May 16 16:47:08 2010 -0400

    nfsd4: generic callback code
    
    Make the recall callback code more generic, so that other callbacks
    will be able to use it too.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 5508e928fd9f..a037f26252ee 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -585,7 +585,6 @@ void nfsd4_probe_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)
 static int nfsd41_cb_setup_sequence(struct nfs4_client *clp,
 		struct rpc_task *task)
 {
-	struct nfsd4_cb_args *args = task-&gt;tk_msg.rpc_argp;
 	u32 *ptr = (u32 *)clp-&gt;cl_sessionid.data;
 	int status = 0;
 
@@ -598,14 +597,6 @@ static int nfsd41_cb_setup_sequence(struct nfs4_client *clp,
 		status = -EAGAIN;
 		goto out;
 	}
-
-	/*
-	 * We'll need the clp during XDR encoding and decoding,
-	 * and the sequence during decoding to verify the reply
-	 */
-	args-&gt;args_clp = clp;
-	task-&gt;tk_msg.rpc_resp = args;
-
 out:
 	dprintk("%s status=%d\n", __func__, status);
 	return status;
@@ -617,7 +608,8 @@ static int nfsd41_cb_setup_sequence(struct nfs4_client *clp,
  */
 static void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)
 {
-	struct nfs4_delegation *dp = calldata;
+	struct nfsd4_callback *cb = calldata;
+	struct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);
 	struct nfs4_client *clp = dp-&gt;dl_client;
 	struct nfsd4_cb_args *args = task-&gt;tk_msg.rpc_argp;
 	u32 minorversion = clp-&gt;cl_cb_conn.cb_minorversion;
@@ -640,7 +632,8 @@ static void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)
 
 static void nfsd4_cb_done(struct rpc_task *task, void *calldata)
 {
-	struct nfs4_delegation *dp = calldata;
+	struct nfsd4_callback *cb = calldata;
+	struct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);
 	struct nfs4_client *clp = dp-&gt;dl_client;
 
 	dprintk("%s: minorversion=%d\n", __func__,
@@ -662,7 +655,8 @@ static void nfsd4_cb_done(struct rpc_task *task, void *calldata)
 
 static void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)
 {
-	struct nfs4_delegation *dp = calldata;
+	struct nfsd4_callback *cb = calldata;
+	struct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);
 	struct nfs4_client *clp = dp-&gt;dl_client;
 	struct rpc_clnt *current_rpc_client = clp-&gt;cl_cb_client;
 
@@ -707,7 +701,8 @@ static void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)
 
 static void nfsd4_cb_recall_release(void *calldata)
 {
-	struct nfs4_delegation *dp = calldata;
+	struct nfsd4_callback *cb = calldata;
+	struct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);
 
 	nfs4_put_delegation(dp);
 }
@@ -749,42 +744,39 @@ void nfsd4_set_callback_client(struct nfs4_client *clp, struct rpc_clnt *new)
 		rpc_shutdown_client(old);
 }
 
-/*
- * called with dp-&gt;dl_count inc'ed.
- */
-static void _nfsd4_cb_recall(struct nfs4_delegation *dp)
+void nfsd4_release_cb(struct nfsd4_callback *cb)
 {
-	struct nfs4_client *clp = dp-&gt;dl_client;
+	if (cb-&gt;cb_ops-&gt;rpc_release)
+		cb-&gt;cb_ops-&gt;rpc_release(cb);
+}
+
+void nfsd4_do_callback_rpc(struct work_struct *w)
+{
+	struct nfsd4_callback *cb = container_of(w, struct nfsd4_callback, cb_work);
+	struct nfs4_client *clp = cb-&gt;cb_args.args_clp;
 	struct rpc_clnt *clnt = clp-&gt;cl_cb_client;
-	struct nfsd4_cb_args *args = &amp;dp-&gt;dl_recall.cb_args;
-	struct rpc_message msg = {
-		.rpc_proc = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL],
-		.rpc_cred = callback_cred
-	};
 
 	if (clnt == NULL) {
-		nfs4_put_delegation(dp);
+		nfsd4_release_cb(cb);
 		return; /* Client is shutting down; give up. */
 	}
-
-	args-&gt;args_op = dp;
-	msg.rpc_argp = args;
-	dp-&gt;dl_retries = 1;
-	rpc_call_async(clnt, &amp;msg, RPC_TASK_SOFT, &amp;nfsd4_cb_recall_ops, dp);
+	rpc_call_async(clnt, &amp;cb-&gt;cb_msg, RPC_TASK_SOFT, cb-&gt;cb_ops, cb);
 }
 
-void nfsd4_do_callback_rpc(struct work_struct *w)
+void nfsd4_cb_recall(struct nfs4_delegation *dp)
 {
-	/* XXX: for now, just send off delegation recall. */
-	/* In future, generalize to handle any sort of callback. */
-	struct nfsd4_callback *c = container_of(w, struct nfsd4_callback, cb_work);
-	struct nfs4_delegation *dp = container_of(c, struct nfs4_delegation, dl_recall);
-
-	_nfsd4_cb_recall(dp);
-}
+	struct nfsd4_callback *cb = &amp;dp-&gt;dl_recall;
 
+	dp-&gt;dl_retries = 1;
+	cb-&gt;cb_args.args_op = dp;
+	cb-&gt;cb_args.args_clp = dp-&gt;dl_client;
+	cb-&gt;cb_msg.rpc_proc = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL];
+	cb-&gt;cb_msg.rpc_argp = &amp;cb-&gt;cb_args;
+	cb-&gt;cb_msg.rpc_resp = &amp;cb-&gt;cb_args;
+	cb-&gt;cb_msg.rpc_cred = callback_cred;
+
+	cb-&gt;cb_ops = &amp;nfsd4_cb_recall_ops;
+	dp-&gt;dl_retries = 1;
 
-void nfsd4_cb_recall(struct nfs4_delegation *dp)
-{
 	queue_work(callback_wq, &amp;dp-&gt;dl_recall.cb_work);
 }
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index f988b90ec213..6e592148ad80 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -72,6 +72,8 @@ struct nfsd4_cb_args {
 
 struct nfsd4_callback {
 	struct nfsd4_cb_args cb_args;
+	struct rpc_message cb_msg;
+	const struct rpc_call_ops *cb_ops;
 	struct work_struct cb_work;
 };
 </pre><hr><pre>commit 1c8556026edac60368ceef446f0febc08014ba78
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed May 26 17:46:00 2010 -0400

    nfsd4: rename nfs4_rpc_args-&gt;nfsd4_cb_args
    
    With apologies for the gratuitous rename, the new name seems more
    helpful to me.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 5687fce85641..5508e928fd9f 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -247,7 +247,7 @@ encode_cb_recall(struct xdr_stream *xdr, struct nfs4_delegation *dp,
 }
 
 static void
-encode_cb_sequence(struct xdr_stream *xdr, struct nfs4_rpc_args *args,
+encode_cb_sequence(struct xdr_stream *xdr, struct nfsd4_cb_args *args,
 		   struct nfs4_cb_compound_hdr *hdr)
 {
 	__be32 *p;
@@ -279,7 +279,7 @@ nfs4_xdr_enc_cb_null(struct rpc_rqst *req, __be32 *p)
 
 static int
 nfs4_xdr_enc_cb_recall(struct rpc_rqst *req, __be32 *p,
-		struct nfs4_rpc_args *rpc_args)
+		struct nfsd4_cb_args *rpc_args)
 {
 	struct xdr_stream xdr;
 	struct nfs4_delegation *args = rpc_args-&gt;args_op;
@@ -338,7 +338,7 @@ decode_cb_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected)
  * with a single slot.
  */
 static int
-decode_cb_sequence(struct xdr_stream *xdr, struct nfs4_rpc_args *res,
+decode_cb_sequence(struct xdr_stream *xdr, struct nfsd4_cb_args *res,
 		   struct rpc_rqst *rqstp)
 {
 	struct nfs4_sessionid id;
@@ -392,7 +392,7 @@ nfs4_xdr_dec_cb_null(struct rpc_rqst *req, __be32 *p)
 
 static int
 nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp, __be32 *p,
-		struct nfs4_rpc_args *args)
+		struct nfsd4_cb_args *args)
 {
 	struct xdr_stream xdr;
 	struct nfs4_cb_compound_hdr hdr;
@@ -585,7 +585,7 @@ void nfsd4_probe_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)
 static int nfsd41_cb_setup_sequence(struct nfs4_client *clp,
 		struct rpc_task *task)
 {
-	struct nfs4_rpc_args *args = task-&gt;tk_msg.rpc_argp;
+	struct nfsd4_cb_args *args = task-&gt;tk_msg.rpc_argp;
 	u32 *ptr = (u32 *)clp-&gt;cl_sessionid.data;
 	int status = 0;
 
@@ -619,7 +619,7 @@ static void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)
 {
 	struct nfs4_delegation *dp = calldata;
 	struct nfs4_client *clp = dp-&gt;dl_client;
-	struct nfs4_rpc_args *args = task-&gt;tk_msg.rpc_argp;
+	struct nfsd4_cb_args *args = task-&gt;tk_msg.rpc_argp;
 	u32 minorversion = clp-&gt;cl_cb_conn.cb_minorversion;
 	int status = 0;
 
@@ -756,7 +756,7 @@ static void _nfsd4_cb_recall(struct nfs4_delegation *dp)
 {
 	struct nfs4_client *clp = dp-&gt;dl_client;
 	struct rpc_clnt *clnt = clp-&gt;cl_cb_client;
-	struct nfs4_rpc_args *args = &amp;dp-&gt;dl_recall.cb_args;
+	struct nfsd4_cb_args *args = &amp;dp-&gt;dl_recall.cb_args;
 	struct rpc_message msg = {
 		.rpc_proc = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL],
 		.rpc_cred = callback_cred
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index 59313f1d8e67..f988b90ec213 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -64,14 +64,14 @@ typedef struct {
 	(s)-&gt;si_fileid, \
 	(s)-&gt;si_generation
 
-struct nfs4_rpc_args {
+struct nfsd4_cb_args {
 	void			*args_op;
 	struct nfs4_client	*args_clp;
 	u32			args_minorversion;
 };
 
 struct nfsd4_callback {
-	struct nfs4_rpc_args cb_args;
+	struct nfsd4_cb_args cb_args;
 	struct work_struct cb_work;
 };
 </pre><hr><pre>commit 586f36735e1d38c32bbfbb2716461e7178724b15
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed May 26 17:40:53 2010 -0400

    nfsd4: combine nfs4_rpc_args and nfsd4_cb_sequence
    
    These two structs don't really need to be distinct as far as I can tell.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 4566b69128a3..5687fce85641 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -247,7 +247,7 @@ encode_cb_recall(struct xdr_stream *xdr, struct nfs4_delegation *dp,
 }
 
 static void
-encode_cb_sequence(struct xdr_stream *xdr, struct nfsd4_cb_sequence *args,
+encode_cb_sequence(struct xdr_stream *xdr, struct nfs4_rpc_args *args,
 		   struct nfs4_cb_compound_hdr *hdr)
 {
 	__be32 *p;
@@ -258,8 +258,8 @@ encode_cb_sequence(struct xdr_stream *xdr, struct nfsd4_cb_sequence *args,
 	RESERVE_SPACE(1 + NFS4_MAX_SESSIONID_LEN + 20);
 
 	WRITE32(OP_CB_SEQUENCE);
-	WRITEMEM(args-&gt;cbs_clp-&gt;cl_sessionid.data, NFS4_MAX_SESSIONID_LEN);
-	WRITE32(args-&gt;cbs_clp-&gt;cl_cb_seq_nr);
+	WRITEMEM(args-&gt;args_clp-&gt;cl_sessionid.data, NFS4_MAX_SESSIONID_LEN);
+	WRITE32(args-&gt;args_clp-&gt;cl_cb_seq_nr);
 	WRITE32(0);		/* slotid, always 0 */
 	WRITE32(0);		/* highest slotid always 0 */
 	WRITE32(0);		/* cachethis always 0 */
@@ -285,12 +285,12 @@ nfs4_xdr_enc_cb_recall(struct rpc_rqst *req, __be32 *p,
 	struct nfs4_delegation *args = rpc_args-&gt;args_op;
 	struct nfs4_cb_compound_hdr hdr = {
 		.ident = args-&gt;dl_ident,
-		.minorversion = rpc_args-&gt;args_seq.cbs_minorversion,
+		.minorversion = rpc_args-&gt;args_minorversion,
 	};
 
 	xdr_init_encode(&amp;xdr, &amp;req-&gt;rq_snd_buf, p);
 	encode_cb_compound_hdr(&amp;xdr, &amp;hdr);
-	encode_cb_sequence(&amp;xdr, &amp;rpc_args-&gt;args_seq, &amp;hdr);
+	encode_cb_sequence(&amp;xdr, rpc_args, &amp;hdr);
 	encode_cb_recall(&amp;xdr, args, &amp;hdr);
 	encode_cb_nops(&amp;hdr);
 	return 0;
@@ -338,7 +338,7 @@ decode_cb_op_hdr(struct xdr_stream *xdr, enum nfs_opnum4 expected)
  * with a single slot.
  */
 static int
-decode_cb_sequence(struct xdr_stream *xdr, struct nfsd4_cb_sequence *res,
+decode_cb_sequence(struct xdr_stream *xdr, struct nfs4_rpc_args *res,
 		   struct rpc_rqst *rqstp)
 {
 	struct nfs4_sessionid id;
@@ -346,7 +346,7 @@ decode_cb_sequence(struct xdr_stream *xdr, struct nfsd4_cb_sequence *res,
 	u32 dummy;
 	__be32 *p;
 
-	if (res-&gt;cbs_minorversion == 0)
+	if (res-&gt;args_minorversion == 0)
 		return 0;
 
 	status = decode_cb_op_hdr(xdr, OP_CB_SEQUENCE);
@@ -362,13 +362,13 @@ decode_cb_sequence(struct xdr_stream *xdr, struct nfsd4_cb_sequence *res,
 	READ_BUF(NFS4_MAX_SESSIONID_LEN + 16);
 	memcpy(id.data, p, NFS4_MAX_SESSIONID_LEN);
 	p += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);
-	if (memcmp(id.data, res-&gt;cbs_clp-&gt;cl_sessionid.data,
+	if (memcmp(id.data, res-&gt;args_clp-&gt;cl_sessionid.data,
 		   NFS4_MAX_SESSIONID_LEN)) {
 		dprintk("%s Invalid session id\n", __func__);
 		goto out;
 	}
 	READ32(dummy);
-	if (dummy != res-&gt;cbs_clp-&gt;cl_cb_seq_nr) {
+	if (dummy != res-&gt;args_clp-&gt;cl_cb_seq_nr) {
 		dprintk("%s Invalid sequence number\n", __func__);
 		goto out;
 	}
@@ -392,7 +392,7 @@ nfs4_xdr_dec_cb_null(struct rpc_rqst *req, __be32 *p)
 
 static int
 nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp, __be32 *p,
-		struct nfsd4_cb_sequence *seq)
+		struct nfs4_rpc_args *args)
 {
 	struct xdr_stream xdr;
 	struct nfs4_cb_compound_hdr hdr;
@@ -402,8 +402,8 @@ nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp, __be32 *p,
 	status = decode_cb_compound_hdr(&amp;xdr, &amp;hdr);
 	if (status)
 		goto out;
-	if (seq) {
-		status = decode_cb_sequence(&amp;xdr, seq, rqstp);
+	if (args) {
+		status = decode_cb_sequence(&amp;xdr, args, rqstp);
 		if (status)
 			goto out;
 	}
@@ -603,8 +603,8 @@ static int nfsd41_cb_setup_sequence(struct nfs4_client *clp,
 	 * We'll need the clp during XDR encoding and decoding,
 	 * and the sequence during decoding to verify the reply
 	 */
-	args-&gt;args_seq.cbs_clp = clp;
-	task-&gt;tk_msg.rpc_resp = &amp;args-&gt;args_seq;
+	args-&gt;args_clp = clp;
+	task-&gt;tk_msg.rpc_resp = args;
 
 out:
 	dprintk("%s status=%d\n", __func__, status);
@@ -623,7 +623,7 @@ static void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)
 	u32 minorversion = clp-&gt;cl_cb_conn.cb_minorversion;
 	int status = 0;
 
-	args-&gt;args_seq.cbs_minorversion = minorversion;
+	args-&gt;args_minorversion = minorversion;
 	if (minorversion) {
 		status = nfsd41_cb_setup_sequence(clp, task);
 		if (status) {
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index 322518c88e4b..59313f1d8e67 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -64,15 +64,10 @@ typedef struct {
 	(s)-&gt;si_fileid, \
 	(s)-&gt;si_generation
 
-struct nfsd4_cb_sequence {
-	/* args/res */
-	u32			cbs_minorversion;
-	struct nfs4_client	*cbs_clp;
-};
-
 struct nfs4_rpc_args {
-	void				*args_op;
-	struct nfsd4_cb_sequence	args_seq;
+	void			*args_op;
+	struct nfs4_client	*args_clp;
+	u32			args_minorversion;
 };
 
 struct nfsd4_callback {</pre><hr><pre>commit 07263f1efe7d5b96e6713471abfa087f41bb2b7c
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon May 31 19:09:40 2010 -0400

    nfsd4: minor variable renaming (cb -&gt; conn)
    
    Now that we have both nfsd4_callback and nfsd4_cb_conn structures, I get
    confused if variables of both types are always named cb....
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 1112f451295a..4566b69128a3 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -472,7 +472,7 @@ static int max_cb_time(void)
 /* Reference counting, callback cleanup, etc., all look racy as heck.
  * And why is cl_cb_set an atomic? */
 
-int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *cb)
+int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn)
 {
 	struct rpc_timeout	timeparms = {
 		.to_initval	= max_cb_time(),
@@ -481,11 +481,11 @@ int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *cb)
 	struct rpc_create_args args = {
 		.net		= &amp;init_net,
 		.protocol	= XPRT_TRANSPORT_TCP,
-		.address	= (struct sockaddr *) &amp;cb-&gt;cb_addr,
-		.addrsize	= cb-&gt;cb_addrlen,
+		.address	= (struct sockaddr *) &amp;conn-&gt;cb_addr,
+		.addrsize	= conn-&gt;cb_addrlen,
 		.timeout	= &amp;timeparms,
 		.program	= &amp;cb_program,
-		.prognumber	= cb-&gt;cb_prog,
+		.prognumber	= conn-&gt;cb_prog,
 		.version	= 0,
 		.authflavor	= clp-&gt;cl_flavor,
 		.flags		= (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),
@@ -495,8 +495,8 @@ int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *cb)
 
 	if (!clp-&gt;cl_principal &amp;&amp; (clp-&gt;cl_flavor &gt;= RPC_AUTH_GSS_KRB5))
 		return -EINVAL;
-	if (cb-&gt;cb_minorversion) {
-		args.bc_xprt = cb-&gt;cb_xprt;
+	if (conn-&gt;cb_minorversion) {
+		args.bc_xprt = conn-&gt;cb_xprt;
 		args.protocol = XPRT_TRANSPORT_BC_TCP;
 	}
 	/* Create RPC client */
@@ -563,13 +563,13 @@ void do_probe_callback(struct nfs4_client *clp)
 /*
  * Set up the callback client and put a NFSPROC4_CB_NULL on the wire...
  */
-void nfsd4_probe_callback(struct nfs4_client *clp, struct nfs4_cb_conn *cb)
+void nfsd4_probe_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)
 {
 	int status;
 
 	BUG_ON(atomic_read(&amp;clp-&gt;cl_cb_set));
 
-	status = setup_callback_client(clp, cb);
+	status = setup_callback_client(clp, conn);
 	if (status) {
 		warn_no_callback_path(clp, status);
 		return;
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index cf0d2ffb3c84..d347180ce55a 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -207,7 +207,7 @@ alloc_init_deleg(struct nfs4_client *clp, struct nfs4_stateid *stp, struct svc_f
 {
 	struct nfs4_delegation *dp;
 	struct nfs4_file *fp = stp-&gt;st_file;
-	struct nfs4_cb_conn *cb = &amp;stp-&gt;st_stateowner-&gt;so_client-&gt;cl_cb_conn;
+	struct nfs4_cb_conn *conn = &amp;stp-&gt;st_stateowner-&gt;so_client-&gt;cl_cb_conn;
 
 	dprintk("NFSD alloc_init_deleg\n");
 	/*
@@ -234,7 +234,7 @@ alloc_init_deleg(struct nfs4_client *clp, struct nfs4_stateid *stp, struct svc_f
 	nfs4_file_get_access(fp, O_RDONLY);
 	dp-&gt;dl_flock = NULL;
 	dp-&gt;dl_type = type;
-	dp-&gt;dl_ident = cb-&gt;cb_ident;
+	dp-&gt;dl_ident = conn-&gt;cb_ident;
 	dp-&gt;dl_stateid.si_boot = boot_time;
 	dp-&gt;dl_stateid.si_stateownerid = current_delegid++;
 	dp-&gt;dl_stateid.si_fileid = 0;
@@ -1098,7 +1098,7 @@ find_unconfirmed_client_by_str(const char *dname, unsigned int hashval,
 static void
 gen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, u32 scopeid)
 {
-	struct nfs4_cb_conn *cb = &amp;clp-&gt;cl_cb_conn;
+	struct nfs4_cb_conn *conn = &amp;clp-&gt;cl_cb_conn;
 	unsigned short expected_family;
 
 	/* Currently, we only support tcp and tcp6 for the callback channel */
@@ -1111,24 +1111,24 @@ gen_callback(struct nfs4_client *clp, struct nfsd4_setclientid *se, u32 scopeid)
 	else
 		goto out_err;
 
-	cb-&gt;cb_addrlen = rpc_uaddr2sockaddr(se-&gt;se_callback_addr_val,
+	conn-&gt;cb_addrlen = rpc_uaddr2sockaddr(se-&gt;se_callback_addr_val,
 					    se-&gt;se_callback_addr_len,
-					    (struct sockaddr *) &amp;cb-&gt;cb_addr,
-					    sizeof(cb-&gt;cb_addr));
+					    (struct sockaddr *)&amp;conn-&gt;cb_addr,
+					    sizeof(conn-&gt;cb_addr));
 
-	if (!cb-&gt;cb_addrlen || cb-&gt;cb_addr.ss_family != expected_family)
+	if (!conn-&gt;cb_addrlen || conn-&gt;cb_addr.ss_family != expected_family)
 		goto out_err;
 
-	if (cb-&gt;cb_addr.ss_family == AF_INET6)
-		((struct sockaddr_in6 *) &amp;cb-&gt;cb_addr)-&gt;sin6_scope_id = scopeid;
+	if (conn-&gt;cb_addr.ss_family == AF_INET6)
+		((struct sockaddr_in6 *)&amp;conn-&gt;cb_addr)-&gt;sin6_scope_id = scopeid;
 
-	cb-&gt;cb_minorversion = 0;
-	cb-&gt;cb_prog = se-&gt;se_callback_prog;
-	cb-&gt;cb_ident = se-&gt;se_callback_ident;
+	conn-&gt;cb_minorversion = 0;
+	conn-&gt;cb_prog = se-&gt;se_callback_prog;
+	conn-&gt;cb_ident = se-&gt;se_callback_ident;
 	return;
 out_err:
-	cb-&gt;cb_addr.ss_family = AF_UNSPEC;
-	cb-&gt;cb_addrlen = 0;
+	conn-&gt;cb_addr.ss_family = AF_UNSPEC;
+	conn-&gt;cb_addrlen = 0;
 	dprintk(KERN_INFO "NFSD: this client (clientid %08x/%08x) "
 		"will not receive delegations\n",
 		clp-&gt;cl_clientid.cl_boot, clp-&gt;cl_clientid.cl_id);</pre><hr><pre>commit f9d7562fdb9dc0ada3a7aba5dbbe9d965e2a105d
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Jul 8 11:02:09 2010 -0400

    nfsd4: share file descriptors between stateid's
    
    The vfs doesn't really allow us to "upgrade" a file descriptor from
    read-only to read-write, and our attempt to do so in nfs4_upgrade_open
    is ugly and incomplete.
    
    Move to a different scheme where we keep multiple opens, shared between
    open stateid's, in the nfs4_file struct.  Each file will be opened at
    most 3 times (for read, write, and read-write), and those opens will be
    shared between all clients and openers.  On upgrade we will do another
    open if necessary instead of attempting to upgrade an existing open.
    We keep count of the number of readers and writers so we know when to
    close the shared files.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index b996a4badeb8..7ab572f9f388 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -162,6 +162,28 @@ static struct list_head	ownerstr_hashtbl[OWNER_HASH_SIZE];
 static struct list_head file_hashtbl[FILE_HASH_SIZE];
 static struct list_head stateid_hashtbl[STATEID_HASH_SIZE];
 
+static inline void nfs4_file_get_access(struct nfs4_file *fp, int oflag)
+{
+	BUG_ON(!(fp-&gt;fi_fds[oflag] || fp-&gt;fi_fds[O_RDWR]));
+	atomic_inc(&amp;fp-&gt;fi_access[oflag]);
+}
+
+static inline void nfs4_file_put_fd(struct nfs4_file *fp, int oflag)
+{
+	if (fp-&gt;fi_fds[oflag]) {
+		fput(fp-&gt;fi_fds[oflag]);
+		fp-&gt;fi_fds[oflag] = NULL;
+	}
+}
+
+static inline void nfs4_file_put_access(struct nfs4_file *fp, int oflag)
+{
+	if (atomic_dec_and_test(&amp;fp-&gt;fi_access[oflag])) {
+		nfs4_file_put_fd(fp, O_RDWR);
+		nfs4_file_put_fd(fp, oflag);
+	}
+}
+
 static struct nfs4_delegation *
 alloc_init_deleg(struct nfs4_client *clp, struct nfs4_stateid *stp, struct svc_fh *current_fh, u32 type)
 {
@@ -191,9 +213,8 @@ alloc_init_deleg(struct nfs4_client *clp, struct nfs4_stateid *stp, struct svc_f
 	dp-&gt;dl_client = clp;
 	get_nfs4_file(fp);
 	dp-&gt;dl_file = fp;
+	nfs4_file_get_access(fp, O_RDONLY);
 	dp-&gt;dl_flock = NULL;
-	get_file(stp-&gt;st_vfs_file);
-	dp-&gt;dl_vfs_file = stp-&gt;st_vfs_file;
 	dp-&gt;dl_type = type;
 	dp-&gt;dl_ident = cb-&gt;cb_ident;
 	dp-&gt;dl_stateid.si_boot = boot_time;
@@ -228,15 +249,12 @@ nfs4_put_delegation(struct nfs4_delegation *dp)
 static void
 nfs4_close_delegation(struct nfs4_delegation *dp)
 {
-	struct file *filp = dp-&gt;dl_vfs_file;
+	struct file *filp = find_readable_file(dp-&gt;dl_file);
 
 	dprintk("NFSD: close_delegation dp %p\n",dp);
-	dp-&gt;dl_vfs_file = NULL;
-	/* The following nfsd_close may not actually close the file,
-	 * but we want to remove the lease in any case. */
 	if (dp-&gt;dl_flock)
 		vfs_setlease(filp, F_UNLCK, &amp;dp-&gt;dl_flock);
-	nfsd_close(filp);
+	nfs4_file_put_access(dp-&gt;dl_file, O_RDONLY);
 }
 
 /* Called under the state lock. */
@@ -308,8 +326,12 @@ static void free_generic_stateid(struct nfs4_stateid *stp)
 
 static void release_lock_stateid(struct nfs4_stateid *stp)
 {
+	struct file *file;
+
 	unhash_generic_stateid(stp);
-	locks_remove_posix(stp-&gt;st_vfs_file, (fl_owner_t)stp-&gt;st_stateowner);
+	file = find_any_file(stp-&gt;st_file);
+	if (file)
+		locks_remove_posix(file, (fl_owner_t)stp-&gt;st_stateowner);
 	free_generic_stateid(stp);
 }
 
@@ -347,11 +369,85 @@ release_stateid_lockowners(struct nfs4_stateid *open_stp)
 	}
 }
 
+/*
+ * We store the NONE, READ, WRITE, and BOTH bits separately in the
+ * st_{access,deny}_bmap field of the stateid, in order to track not
+ * only what share bits are currently in force, but also what
+ * combinations of share bits previous opens have used.  This allows us
+ * to enforce the recommendation of rfc 3530 14.2.19 that the server
+ * return an error if the client attempt to downgrade to a combination
+ * of share bits not explicable by closing some of its previous opens.
+ *
+ * XXX: This enforcement is actually incomplete, since we don't keep
+ * track of access/deny bit combinations; so, e.g., we allow:
+ *
+ *	OPEN allow read, deny write
+ *	OPEN allow both, deny none
+ *	DOWNGRADE allow read, deny none
+ *
+ * which we should reject.
+ */
+static void
+set_access(unsigned int *access, unsigned long bmap) {
+	int i;
+
+	*access = 0;
+	for (i = 1; i &lt; 4; i++) {
+		if (test_bit(i, &amp;bmap))
+			*access |= i;
+	}
+}
+
+static void
+set_deny(unsigned int *deny, unsigned long bmap) {
+	int i;
+
+	*deny = 0;
+	for (i = 0; i &lt; 4; i++) {
+		if (test_bit(i, &amp;bmap))
+			*deny |= i ;
+	}
+}
+
+static int
+test_share(struct nfs4_stateid *stp, struct nfsd4_open *open) {
+	unsigned int access, deny;
+
+	set_access(&amp;access, stp-&gt;st_access_bmap);
+	set_deny(&amp;deny, stp-&gt;st_deny_bmap);
+	if ((access &amp; open-&gt;op_share_deny) || (deny &amp; open-&gt;op_share_access))
+		return 0;
+	return 1;
+}
+
+static int nfs4_access_to_omode(u32 access)
+{
+	switch (access) {
+	case NFS4_SHARE_ACCESS_READ:
+		return O_RDONLY;
+	case NFS4_SHARE_ACCESS_WRITE:
+		return O_WRONLY;
+	case NFS4_SHARE_ACCESS_BOTH:
+		return O_RDWR;
+	}
+	BUG();
+}
+
+static int nfs4_access_bmap_to_omode(struct nfs4_stateid *stp)
+{
+	unsigned int access;
+
+	set_access(&amp;access, stp-&gt;st_access_bmap);
+	return nfs4_access_to_omode(access);
+}
+
 static void release_open_stateid(struct nfs4_stateid *stp)
 {
+	int oflag = nfs4_access_bmap_to_omode(stp);
+
 	unhash_generic_stateid(stp);
 	release_stateid_lockowners(stp);
-	nfsd_close(stp-&gt;st_vfs_file);
+	nfs4_file_put_access(stp-&gt;st_file, oflag);
 	free_generic_stateid(stp);
 }
 
@@ -1763,6 +1859,8 @@ alloc_init_file(struct inode *ino)
 		fp-&gt;fi_inode = igrab(ino);
 		fp-&gt;fi_id = current_fileid++;
 		fp-&gt;fi_had_conflict = false;
+		memset(fp-&gt;fi_fds, 0, sizeof(fp-&gt;fi_fds));
+		memset(fp-&gt;fi_access, 0, sizeof(fp-&gt;fi_access));
 		spin_lock(&amp;recall_lock);
 		list_add(&amp;fp-&gt;fi_hash, &amp;file_hashtbl[hashval]);
 		spin_unlock(&amp;recall_lock);
@@ -1973,57 +2071,6 @@ static inline int deny_valid(u32 x)
 	return x &lt;= NFS4_SHARE_DENY_BOTH;
 }
 
-/*
- * We store the NONE, READ, WRITE, and BOTH bits separately in the
- * st_{access,deny}_bmap field of the stateid, in order to track not
- * only what share bits are currently in force, but also what
- * combinations of share bits previous opens have used.  This allows us
- * to enforce the recommendation of rfc 3530 14.2.19 that the server
- * return an error if the client attempt to downgrade to a combination
- * of share bits not explicable by closing some of its previous opens.
- *
- * XXX: This enforcement is actually incomplete, since we don't keep
- * track of access/deny bit combinations; so, e.g., we allow:
- *
- *	OPEN allow read, deny write
- *	OPEN allow both, deny none
- *	DOWNGRADE allow read, deny none
- *
- * which we should reject.
- */
-static void
-set_access(unsigned int *access, unsigned long bmap) {
-	int i;
-
-	*access = 0;
-	for (i = 1; i &lt; 4; i++) {
-		if (test_bit(i, &amp;bmap))
-			*access |= i;
-	}
-}
-
-static void
-set_deny(unsigned int *deny, unsigned long bmap) {
-	int i;
-
-	*deny = 0;
-	for (i = 0; i &lt; 4; i++) {
-		if (test_bit(i, &amp;bmap))
-			*deny |= i ;
-	}
-}
-
-static int
-test_share(struct nfs4_stateid *stp, struct nfsd4_open *open) {
-	unsigned int access, deny;
-
-	set_access(&amp;access, stp-&gt;st_access_bmap);
-	set_deny(&amp;deny, stp-&gt;st_deny_bmap);
-	if ((access &amp; open-&gt;op_share_deny) || (deny &amp; open-&gt;op_share_access))
-		return 0;
-	return 1;
-}
-
 /*
  * Called to check deny when READ with all zero stateid or
  * WRITE with all zero or all one stateid
@@ -2055,14 +2102,12 @@ nfs4_share_conflict(struct svc_fh *current_fh, unsigned int deny_type)
 }
 
 static inline void
-nfs4_file_downgrade(struct file *filp, unsigned int share_access)
+nfs4_file_downgrade(struct nfs4_file *fp, unsigned int share_access)
 {
-	if (share_access &amp; NFS4_SHARE_ACCESS_WRITE) {
-		drop_file_write_access(filp);
-		spin_lock(&amp;filp-&gt;f_lock);
-		filp-&gt;f_mode = (filp-&gt;f_mode | FMODE_READ) &amp; ~FMODE_WRITE;
-		spin_unlock(&amp;filp-&gt;f_lock);
-	}
+	if (share_access &amp; NFS4_SHARE_ACCESS_WRITE)
+		nfs4_file_put_access(fp, O_WRONLY);
+	if (share_access &amp; NFS4_SHARE_ACCESS_READ)
+		nfs4_file_put_access(fp, O_RDONLY);
 }
 
 /*
@@ -2328,32 +2373,42 @@ static inline int nfs4_access_to_access(u32 nfs4_access)
 	return flags;
 }
 
+static __be32 nfs4_get_vfs_file(struct svc_rqst *rqstp, struct nfs4_file
+*fp, struct svc_fh *cur_fh, u32 nfs4_access)
+{
+	__be32 status;
+	int oflag = nfs4_access_to_omode(nfs4_access);
+	int access = nfs4_access_to_access(nfs4_access);
+
+	if (!fp-&gt;fi_fds[oflag]) {
+		status = nfsd_open(rqstp, cur_fh, S_IFREG, access,
+			&amp;fp-&gt;fi_fds[oflag]);
+		if (status == nfserr_dropit)
+			status = nfserr_jukebox;
+		if (status)
+			return status;
+	}
+	nfs4_file_get_access(fp, oflag);
+
+	return nfs_ok;
+}
+
 static __be32
 nfs4_new_open(struct svc_rqst *rqstp, struct nfs4_stateid **stpp,
-		struct nfs4_delegation *dp,
-		struct svc_fh *cur_fh, struct nfsd4_open *open)
+		struct nfs4_file *fp, struct svc_fh *cur_fh,
+		struct nfsd4_open *open)
 {
 	struct nfs4_stateid *stp;
+	__be32 status;
 
 	stp = nfs4_alloc_stateid();
 	if (stp == NULL)
 		return nfserr_resource;
 
-	if (dp) {
-		get_file(dp-&gt;dl_vfs_file);
-		stp-&gt;st_vfs_file = dp-&gt;dl_vfs_file;
-	} else {
-		__be32 status;
-		int access = nfs4_access_to_access(open-&gt;op_share_access);
-
-		status = nfsd_open(rqstp, cur_fh, S_IFREG, access,
-					&amp;stp-&gt;st_vfs_file);
-		if (status) {
-			if (status == nfserr_dropit)
-				status = nfserr_jukebox;
-			kmem_cache_free(stateid_slab, stp);
-			return status;
-		}
+	status = nfs4_get_vfs_file(rqstp, fp, cur_fh, open-&gt;op_share_access);
+	if (status) {
+		kmem_cache_free(stateid_slab, stp);
+		return status;
 	}
 	*stpp = stp;
 	return 0;
@@ -2375,36 +2430,29 @@ nfsd4_truncate(struct svc_rqst *rqstp, struct svc_fh *fh,
 }
 
 static __be32
-nfs4_upgrade_open(struct svc_rqst *rqstp, struct svc_fh *cur_fh, struct nfs4_stateid *stp, struct nfsd4_open *open)
+nfs4_upgrade_open(struct svc_rqst *rqstp, struct nfs4_file *fp, struct svc_fh *cur_fh, struct nfs4_stateid *stp, struct nfsd4_open *open)
 {
-	struct file *filp = stp-&gt;st_vfs_file;
-	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
-	unsigned int share_access, new_writer;
-	u32 op_share_access;
+	u32 op_share_access, new_access;
 	__be32 status;
 
-	set_access(&amp;share_access, stp-&gt;st_access_bmap);
-	new_writer = (~share_access) &amp; open-&gt;op_share_access
-			&amp; NFS4_SHARE_ACCESS_WRITE;
-
-	if (new_writer) {
-		int err = get_write_access(inode);
-		if (err)
-			return nfserrno(err);
-		err = mnt_want_write(cur_fh-&gt;fh_export-&gt;ex_path.mnt);
-		if (err)
-			return nfserrno(err);
-		file_take_write(filp);
+	set_access(&amp;new_access, stp-&gt;st_access_bmap);
+	new_access = (~new_access) &amp; open-&gt;op_share_access &amp; ~NFS4_SHARE_WANT_MASK;
+
+	if (new_access) {
+		status = nfs4_get_vfs_file(rqstp, fp, cur_fh, new_access);
+		if (status)
+			return status;
 	}
 	status = nfsd4_truncate(rqstp, cur_fh, open);
 	if (status) {
-		if (new_writer)
-			put_write_access(inode);
+		if (new_access) {
+			int oflag = nfs4_access_to_omode(new_access);
+			nfs4_file_put_access(fp, oflag);
+		}
 		return status;
 	}
 	/* remember the open */
 	op_share_access = open-&gt;op_share_access &amp; ~NFS4_SHARE_WANT_MASK;
-	filp-&gt;f_mode |= op_share_access;
 	__set_bit(op_share_access, &amp;stp-&gt;st_access_bmap);
 	__set_bit(open-&gt;op_share_deny, &amp;stp-&gt;st_deny_bmap);
 
@@ -2468,13 +2516,14 @@ nfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open, struct nfs4_sta
 	fl.fl_type = flag == NFS4_OPEN_DELEGATE_READ? F_RDLCK: F_WRLCK;
 	fl.fl_end = OFFSET_MAX;
 	fl.fl_owner =  (fl_owner_t)dp;
-	fl.fl_file = stp-&gt;st_vfs_file;
+	fl.fl_file = find_readable_file(stp-&gt;st_file);
+	BUG_ON(!fl.fl_file);
 	fl.fl_pid = current-&gt;tgid;
 
 	/* vfs_setlease checks to see if delegation should be handed out.
 	 * the lock_manager callbacks fl_mylease and fl_change are used
 	 */
-	if ((status = vfs_setlease(stp-&gt;st_vfs_file, fl.fl_type, &amp;flp))) {
+	if ((status = vfs_setlease(fl.fl_file, fl.fl_type, &amp;flp))) {
 		dprintk("NFSD: setlease failed [%d], no delegation\n", status);
 		unhash_delegation(dp);
 		flag = NFS4_OPEN_DELEGATE_NONE;
@@ -2538,13 +2587,12 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	 */
 	if (stp) {
 		/* Stateid was found, this is an OPEN upgrade */
-		status = nfs4_upgrade_open(rqstp, current_fh, stp, open);
+		status = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);
 		if (status)
 			goto out;
 		update_stateid(&amp;stp-&gt;st_stateid);
 	} else {
-		/* Stateid was not found, this is a new OPEN */
-		status = nfs4_new_open(rqstp, &amp;stp, dp, current_fh, open);
+		status = nfs4_new_open(rqstp, &amp;stp, fp, current_fh, open);
 		if (status)
 			goto out;
 		init_stateid(stp, fp, open);
@@ -2746,7 +2794,7 @@ search_close_lru(u32 st_id, int flags)
 static inline int
 nfs4_check_fh(struct svc_fh *fhp, struct nfs4_stateid *stp)
 {
-	return fhp-&gt;fh_dentry-&gt;d_inode != stp-&gt;st_vfs_file-&gt;f_path.dentry-&gt;d_inode;
+	return fhp-&gt;fh_dentry-&gt;d_inode != stp-&gt;st_file-&gt;fi_inode;
 }
 
 static int
@@ -2894,7 +2942,8 @@ nfs4_preprocess_stateid_op(struct nfsd4_compound_state *cstate,
 			goto out;
 		renew_client(dp-&gt;dl_client);
 		if (filpp)
-			*filpp = dp-&gt;dl_vfs_file;
+			*filpp = find_readable_file(dp-&gt;dl_file);
+		BUG_ON(!*filpp);
 	} else { /* open or lock stateid */
 		stp = find_stateid(stateid, flags);
 		if (!stp)
@@ -2911,8 +2960,13 @@ nfs4_preprocess_stateid_op(struct nfsd4_compound_state *cstate,
 		if (status)
 			goto out;
 		renew_client(stp-&gt;st_stateowner-&gt;so_client);
-		if (filpp)
-			*filpp = stp-&gt;st_vfs_file;
+		if (filpp) {
+			if (flags &amp; RD_STATE)
+				*filpp = find_readable_file(stp-&gt;st_file);
+			else
+				*filpp = find_writeable_file(stp-&gt;st_file);
+			BUG_ON(!*filpp); /* assured by check_openmode */
+		}
 	}
 	status = nfs_ok;
 out:
@@ -3148,8 +3202,7 @@ nfsd4_open_downgrade(struct svc_rqst *rqstp,
 		goto out;
 	}
 	set_access(&amp;share_access, stp-&gt;st_access_bmap);
-	nfs4_file_downgrade(stp-&gt;st_vfs_file,
-	                    share_access &amp; ~od-&gt;od_share_access);
+	nfs4_file_downgrade(stp-&gt;st_file, share_access &amp; ~od-&gt;od_share_access);
 
 	reset_union_bmap_access(od-&gt;od_share_access, &amp;stp-&gt;st_access_bmap);
 	reset_union_bmap_deny(od-&gt;od_share_deny, &amp;stp-&gt;st_deny_bmap);
@@ -3468,7 +3521,6 @@ alloc_init_lock_stateid(struct nfs4_stateowner *sop, struct nfs4_file *fp, struc
 	stp-&gt;st_stateid.si_stateownerid = sop-&gt;so_id;
 	stp-&gt;st_stateid.si_fileid = fp-&gt;fi_id;
 	stp-&gt;st_stateid.si_generation = 0;
-	stp-&gt;st_vfs_file = open_stp-&gt;st_vfs_file; /* FIXME refcount?? */
 	stp-&gt;st_deny_bmap = open_stp-&gt;st_deny_bmap;
 	stp-&gt;st_openstp = open_stp;
 
@@ -3568,7 +3620,6 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		lock_sop = lock-&gt;lk_replay_owner;
 	}
 	/* lock-&gt;lk_replay_owner and lock_stp have been created or found */
-	filp = lock_stp-&gt;st_vfs_file;
 
 	status = nfserr_grace;
 	if (locks_in_grace() &amp;&amp; !lock-&gt;lk_reclaim)
@@ -3581,11 +3632,13 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	switch (lock-&gt;lk_type) {
 		case NFS4_READ_LT:
 		case NFS4_READW_LT:
+			filp = find_readable_file(lock_stp-&gt;st_file);
 			file_lock.fl_type = F_RDLCK;
 			cmd = F_SETLK;
 		break;
 		case NFS4_WRITE_LT:
 		case NFS4_WRITEW_LT:
+			filp = find_writeable_file(lock_stp-&gt;st_file);
 			file_lock.fl_type = F_WRLCK;
 			cmd = F_SETLK;
 		break;
@@ -3593,6 +3646,10 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 			status = nfserr_inval;
 		goto out;
 	}
+	if (!filp) {
+		status = nfserr_openmode;
+		goto out;
+	}
 	file_lock.fl_owner = (fl_owner_t)lock_sop;
 	file_lock.fl_pid = current-&gt;tgid;
 	file_lock.fl_file = filp;
@@ -3761,7 +3818,11 @@ nfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 					&amp;locku-&gt;lu_stateowner, &amp;stp, NULL)))
 		goto out;
 
-	filp = stp-&gt;st_vfs_file;
+	filp = find_any_file(stp-&gt;st_file);
+	if (!filp) {
+		status = nfserr_lock_range;
+		goto out;
+	}
 	BUG_ON(!filp);
 	locks_init_lock(&amp;file_lock);
 	file_lock.fl_type = F_UNLCK;
@@ -3808,10 +3869,10 @@ nfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
  * 	0: no locks held by lockowner
  */
 static int
-check_for_locks(struct file *filp, struct nfs4_stateowner *lowner)
+check_for_locks(struct nfs4_file *filp, struct nfs4_stateowner *lowner)
 {
 	struct file_lock **flpp;
-	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;fi_inode;
 	int status = 0;
 
 	lock_kernel();
@@ -3862,7 +3923,7 @@ nfsd4_release_lockowner(struct svc_rqst *rqstp,
 				continue;
 			list_for_each_entry(stp, &amp;sop-&gt;so_stateids,
 					st_perstateowner) {
-				if (check_for_locks(stp-&gt;st_vfs_file, sop))
+				if (check_for_locks(stp-&gt;st_file, sop))
 					goto out;
 				/* Note: so_perclient unused for lockowners,
 				 * so it's OK to fool with here. */
diff --git a/fs/nfsd/nfsd.h b/fs/nfsd/nfsd.h
index 72377761270e..b76ac3a82e39 100644
--- a/fs/nfsd/nfsd.h
+++ b/fs/nfsd/nfsd.h
@@ -153,6 +153,7 @@ void		nfsd_lockd_shutdown(void);
 #define nfserr_bad_seqid	cpu_to_be32(NFSERR_BAD_SEQID)
 #define	nfserr_symlink		cpu_to_be32(NFSERR_SYMLINK)
 #define	nfserr_not_same		cpu_to_be32(NFSERR_NOT_SAME)
+#define nfserr_lock_range	cpu_to_be32(NFSERR_LOCK_RANGE)
 #define	nfserr_restorefh	cpu_to_be32(NFSERR_RESTOREFH)
 #define	nfserr_attrnotsupp	cpu_to_be32(NFSERR_ATTRNOTSUPP)
 #define	nfserr_bad_xdr		cpu_to_be32(NFSERR_BAD_XDR)
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index 006c84230c7c..7731a75971dd 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -88,7 +88,6 @@ struct nfs4_delegation {
 	struct nfs4_client	*dl_client;
 	struct nfs4_file	*dl_file;
 	struct file_lock	*dl_flock;
-	struct file		*dl_vfs_file;
 	u32			dl_type;
 	time_t			dl_time;
 /* For recall: */
@@ -342,12 +341,50 @@ struct nfs4_file {
 	struct list_head        fi_hash;    /* hash by "struct inode *" */
 	struct list_head        fi_stateids;
 	struct list_head	fi_delegations;
+	/* One each for O_RDONLY, O_WRONLY, O_RDWR: */
+	struct file *		fi_fds[3];
+	/* One each for O_RDONLY, O_WRONLY: */
+	atomic_t		fi_access[2];
+	/*
+	 * Each open stateid contributes 1 to either fi_readers or
+	 * fi_writers, or both, depending on the open mode.  A
+	 * delegation also takes an fi_readers reference.  Lock
+	 * stateid's take none.
+	 */
+	atomic_t		fi_readers;
+	atomic_t		fi_writers;
 	struct inode		*fi_inode;
 	u32                     fi_id;      /* used with stateowner-&gt;so_id 
 					     * for stateid_hashtbl hash */
 	bool			fi_had_conflict;
 };
 
+/* XXX: for first cut may fall back on returning file that doesn't work
+ * at all? */
+static inline struct file *find_writeable_file(struct nfs4_file *f)
+{
+	if (f-&gt;fi_fds[O_RDWR])
+		return f-&gt;fi_fds[O_RDWR];
+	return f-&gt;fi_fds[O_WRONLY];
+}
+
+static inline struct file *find_readable_file(struct nfs4_file *f)
+{
+	if (f-&gt;fi_fds[O_RDWR])
+		return f-&gt;fi_fds[O_RDWR];
+	return f-&gt;fi_fds[O_RDONLY];
+}
+
+static inline struct file *find_any_file(struct nfs4_file *f)
+{
+	if (f-&gt;fi_fds[O_RDWR])
+		return f-&gt;fi_fds[O_RDWR];
+	else if (f-&gt;fi_fds[O_RDWR])
+		return f-&gt;fi_fds[O_WRONLY];
+	else
+		return f-&gt;fi_fds[O_RDONLY];
+}
+
 /*
 * nfs4_stateid can either be an open stateid or (eventually) a lock stateid
 *
@@ -373,7 +410,6 @@ struct nfs4_stateid {
 	struct nfs4_stateowner      * st_stateowner;
 	struct nfs4_file            * st_file;
 	stateid_t                     st_stateid;
-	struct file                 * st_vfs_file;
 	unsigned long                 st_access_bmap;
 	unsigned long                 st_deny_bmap;
 	struct nfs4_stateid         * st_openstp;</pre><hr><pre>commit 866e26115cba6b59cec669b6307599e3e4440491
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 20 15:23:15 2010 -0700

    timers: Document meaning of deferrable timer
    
    Steal some text from 6e453a67510 "Add support for deferrable timers".  A
    reader shouldn't have to dig through the git logs for the basic
    description of a deferrable timer.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: johnstul@us.ibm.com
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;

diff --git a/kernel/timer.c b/kernel/timer.c
index ee305c8d4e18..ce98685cd1cb 100644
--- a/kernel/timer.c
+++ b/kernel/timer.c
@@ -90,8 +90,13 @@ static DEFINE_PER_CPU(struct tvec_base *, tvec_bases) = &amp;boot_tvec_bases;
 
 /*
  * Note that all tvec_bases are 2 byte aligned and lower bit of
- * base in timer_list is guaranteed to be zero. Use the LSB for
- * the new flag to indicate whether the timer is deferrable
+ * base in timer_list is guaranteed to be zero. Use the LSB to
+ * indicate whether the timer is deferrable.
+ *
+ * A deferrable timer will work normally when the system is busy, but
+ * will not cause a CPU to come out of idle just to service it; instead,
+ * the timer will be serviced when the CPU eventually wakes up with a
+ * subsequent non-deferrable timer.
  */
 #define TBASE_DEFERRABLE_FLAG		(0x1)
 </pre><hr><pre>commit 6a85d6c76962db769bb2f2cb11b17b16f32c4158
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 6 12:39:12 2010 -0400

    nfsd4: comment nitpick
    
    Reported-by: "Madan, Anshul" &lt;Anshul.Madan@netapp.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index ebbf3b6b2457..e3611b55531b 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -605,7 +605,7 @@ nfsd4_get_nfs4_acl(struct svc_rqst *rqstp, struct dentry *dentry, struct nfs4_ac
 	return error;
 }
 
-#endif /* defined(CONFIG_NFS_V4) */
+#endif /* defined(CONFIG_NFSD_V4) */
 
 #ifdef CONFIG_NFSD_V3
 /*</pre><hr><pre>commit cba9ba4b902270c22f8b9c5149a284216b633fc1
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jun 1 11:21:40 2010 -0400

    nfsd4: fix delegation recall race use-after-free
    
    When the rarely-used callback-connection-changing setclientid occurs
    simultaneously with a delegation recall, we rerun the recall by
    requeueing it on a workqueue.  But we also need to take a reference on
    the delegation in that case, since the delegation held by the rpc itself
    will be released by the rpc_release callback.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index a4686326b5ae..1e6497ed3e12 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -689,6 +689,7 @@ static void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)
 		warn_no_callback_path(clp, task-&gt;tk_status);
 		if (current_rpc_client != task-&gt;tk_client) {
 			/* queue a callback on the new connection: */
+			atomic_inc(&amp;dp-&gt;dl_count);
 			nfsd4_cb_recall(dp);
 			return;
 		}</pre><hr><pre>commit ac94bf582529343bb7f354d0eef6dc4e566bbbd5
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon May 31 19:06:39 2010 -0400

    nfsd4: fix deleg leak on callback error
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 874a56a0801c..a4686326b5ae 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -761,8 +761,10 @@ static void _nfsd4_cb_recall(struct nfs4_delegation *dp)
 		.rpc_cred = callback_cred
 	};
 
-	if (clnt == NULL)
+	if (clnt == NULL) {
+		nfs4_put_delegation(dp);
 		return; /* Client is shutting down; give up. */
+	}
 
 	args-&gt;args_op = dp;
 	msg.rpc_argp = args;</pre>
    <div class="pagination">
        <a href='4_9.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><span>[10]</span><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_11.html'>Next&gt;&gt;</a>
    <div>
</body>
