<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Virginia, Charlottesville</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Virginia, Charlottesville</h1>
    <div class="pagination">
        <a href='3_56.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><span>[57]</span><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_58.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0110c4432aab7f119d38d1389964e51685721ed4
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:29:56 2009 -0400

    Staging: comedi: remove C99 comments in APCI1710_Pwm.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/APCI1710_Pwm.c b/drivers/staging/comedi/drivers/addi-data/APCI1710_Pwm.c
index 2ebb121c2d22..976fe5863e49 100644
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Pwm.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Pwm.c
@@ -79,29 +79,29 @@ int i_APCI1710_InsnConfigPWM(struct comedi_device * dev, struct comedi_subdevice
 
 	switch (b_ConfigType) {
 	case APCI1710_PWM_INIT:
-		i_ReturnValue = i_APCI1710_InitPWM(dev, (unsigned char) CR_AREF(insn-&gt;chanspec),	//  b_ModulNbr
-			(unsigned char) data[0],	//b_PWM
-			(unsigned char) data[1],	// b_ClockSelection
-			(unsigned char) data[2],	// b_TimingUnit
-			(unsigned int) data[3],	//ul_LowTiming
-			(unsigned int) data[4],	//ul_HighTiming
-			(unsigned int *) &amp; data[0],	//pul_RealLowTiming
-			(unsigned int *) &amp; data[1]	//pul_RealHighTiming
+		i_ReturnValue = i_APCI1710_InitPWM(dev, (unsigned char) CR_AREF(insn-&gt;chanspec),	/*   b_ModulNbr */
+			(unsigned char) data[0],	/* b_PWM */
+			(unsigned char) data[1],	/*  b_ClockSelection */
+			(unsigned char) data[2],	/*  b_TimingUnit */
+			(unsigned int) data[3],	/* ul_LowTiming */
+			(unsigned int) data[4],	/* ul_HighTiming */
+			(unsigned int *) &amp; data[0],	/* pul_RealLowTiming */
+			(unsigned int *) &amp; data[1]	/* pul_RealHighTiming */
 			);
 		break;
 
 	case APCI1710_PWM_GETINITDATA:
-		i_ReturnValue = i_APCI1710_GetPWMInitialisation(dev, (unsigned char) CR_AREF(insn-&gt;chanspec),	// b_ModulNbr
-			(unsigned char) data[0],	//b_PWM
-			(unsigned char *) &amp; data[0],	//pb_TimingUnit
-			(unsigned int *) &amp; data[1],	//pul_LowTiming
-			(unsigned int *) &amp; data[2],	//pul_HighTiming
-			(unsigned char *) &amp; data[3],	// pb_StartLevel
-			(unsigned char *) &amp; data[4],	// pb_StopMode
-			(unsigned char *) &amp; data[5],	// pb_StopLevel
-			(unsigned char *) &amp; data[6],	// pb_ExternGate
-			(unsigned char *) &amp; data[7],	// pb_InterruptEnable
-			(unsigned char *) &amp; data[8]	// pb_Enable
+		i_ReturnValue = i_APCI1710_GetPWMInitialisation(dev, (unsigned char) CR_AREF(insn-&gt;chanspec),	/*  b_ModulNbr */
+			(unsigned char) data[0],	/* b_PWM */
+			(unsigned char *) &amp; data[0],	/* pb_TimingUnit */
+			(unsigned int *) &amp; data[1],	/* pul_LowTiming */
+			(unsigned int *) &amp; data[2],	/* pul_HighTiming */
+			(unsigned char *) &amp; data[3],	/*  pb_StartLevel */
+			(unsigned char *) &amp; data[4],	/*  pb_StopMode */
+			(unsigned char *) &amp; data[5],	/*  pb_StopLevel */
+			(unsigned char *) &amp; data[6],	/*  pb_ExternGate */
+			(unsigned char *) &amp; data[7],	/*  pb_InterruptEnable */
+			(unsigned char *) &amp; data[8]	/*  pb_Enable */
 			);
 		break;
 
@@ -200,33 +200,33 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 	/**************************/
 
 	if (b_ModulNbr &lt; 4) {
-	   /***************/
+		/***************/
 		/* Test if PWM */
-	   /***************/
+		/***************/
 
 		if ((devpriv-&gt;s_BoardInfos.
 				dw_MolduleConfiguration[b_ModulNbr] &amp;
 				0xFFFF0000UL) == APCI1710_PWM) {
-	      /**************************/
+			/**************************/
 			/* Test the PWM selection */
-	      /**************************/
+			/**************************/
 
 			if (b_PWM &lt;= 1) {
-		 /******************/
+				/******************/
 				/* Test the clock */
-		 /******************/
+				/******************/
 
 				if ((b_ClockSelection == APCI1710_30MHZ) ||
 					(b_ClockSelection == APCI1710_33MHZ) ||
 					(b_ClockSelection == APCI1710_40MHZ)) {
-		    /************************/
+					/************************/
 					/* Test the timing unit */
-		    /************************/
+					/************************/
 
 					if (b_TimingUnit &lt;= 4) {
-		       /*********************************/
+						/*********************************/
 						/* Test the low timing selection */
-		       /*********************************/
+						/*********************************/
 
 						if (((b_ClockSelection ==
 									APCI1710_30MHZ)
@@ -361,34 +361,34 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 								&amp;&amp; (ul_LowTiming
 									&lt;=
 									7UL))) {
-			  /**********************************/
+							/**********************************/
 							/* Test the High timing selection */
-			  /**********************************/
+							/**********************************/
 
 							if (((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 0) &amp;&amp; (ul_HighTiming &gt;= 266) &amp;&amp; (ul_HighTiming &lt;= 0xFFFFFFFFUL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 1) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 571230650UL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 2) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 571230UL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 3) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 571UL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 4) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 9UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 0) &amp;&amp; (ul_HighTiming &gt;= 242) &amp;&amp; (ul_HighTiming &lt;= 0xFFFFFFFFUL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 1) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 519691043UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 2) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 519691UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 3) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 520UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 4) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 8UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 0) &amp;&amp; (ul_HighTiming &gt;= 200) &amp;&amp; (ul_HighTiming &lt;= 0xFFFFFFFFUL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 1) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 429496729UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 2) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 429496UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 3) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 429UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 4) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 7UL))) {
-			     /**************************/
+								/**************************/
 								/* Test the board version */
-			     /**************************/
+								/**************************/
 
 								if (((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (devpriv-&gt;s_BoardInfos.b_BoardVersion &gt; 0)) || (b_ClockSelection != APCI1710_40MHZ)) {
 
-				/************************************/
+									/************************************/
 									/* Calculate the low division fator */
-				/************************************/
+									/************************************/
 
 									fpu_begin
 										();
 
 									switch (b_TimingUnit) {
-				   /******/
+										/******/
 										/* ns */
-				   /******/
+										/******/
 
 									case 0:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_LowTimerValue
 											=
@@ -397,9 +397,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 											*
 											(0.00025 * b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_LowTiming * (0.00025 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 											ul_LowTimerValue
@@ -409,9 +409,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealLowTiming
 											=
@@ -461,15 +461,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /******/
+										/******/
 										/* æs */
-				   /******/
+										/******/
 
 									case 1:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_LowTimerValue
 											=
@@ -478,9 +478,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 											*
 											(0.25 * b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_LowTiming * (0.25 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 											ul_LowTimerValue
@@ -490,9 +490,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealLowTiming
 											=
@@ -544,15 +544,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /******/
+										/******/
 										/* ms */
-				   /******/
+										/******/
 
 									case 2:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_LowTimerValue
 											=
@@ -562,9 +562,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 											*
 											b_ClockSelection);
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_LowTiming * (250.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 											ul_LowTimerValue
@@ -574,9 +574,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealLowTiming
 											=
@@ -626,14 +626,14 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /*****/
+										/*****/
 										/* s */
-				   /*****/
+										/*****/
 
 									case 3:
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_LowTimerValue
 											=
@@ -644,9 +644,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												*
 												b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_LowTiming * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 											ul_LowTimerValue
@@ -656,9 +656,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealLowTiming
 											=
@@ -711,15 +711,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /******/
+										/******/
 										/* mn */
-				   /******/
+										/******/
 
 									case 4:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_LowTimerValue
 											=
@@ -733,9 +733,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												*
 												b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)(ul_LowTiming * 60.0) * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 											ul_LowTimerValue
@@ -745,9 +745,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealLowTiming
 											=
@@ -806,20 +806,20 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 										break;
 									}
 
-				/*************************************/
+									/*************************************/
 									/* Calculate the high division fator */
-				/*************************************/
+									/*************************************/
 
 									switch (b_TimingUnit) {
-				   /******/
+										/******/
 										/* ns */
-				   /******/
+										/******/
 
 									case 0:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_HighTimerValue
 											=
@@ -828,9 +828,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 											*
 											(0.00025 * b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_HighTiming * (0.00025 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 											ul_HighTimerValue
@@ -840,9 +840,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealHighTiming
 											=
@@ -892,15 +892,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /******/
+										/******/
 										/* æs */
-				   /******/
+										/******/
 
 									case 1:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_HighTimerValue
 											=
@@ -909,9 +909,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 											*
 											(0.25 * b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_HighTiming * (0.25 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 											ul_HighTimerValue
@@ -921,9 +921,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealHighTiming
 											=
@@ -975,15 +975,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /******/
+										/******/
 										/* ms */
-				   /******/
+										/******/
 
 									case 2:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_HighTimerValue
 											=
@@ -993,9 +993,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 											*
 											b_ClockSelection);
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_HighTiming * (250.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 											ul_HighTimerValue
@@ -1005,9 +1005,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealHighTiming
 											=
@@ -1057,15 +1057,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /*****/
+										/*****/
 										/* s */
-				   /*****/
+										/*****/
 
 									case 3:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_HighTimerValue
 											=
@@ -1076,9 +1076,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												*
 												b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)ul_HighTiming * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 											ul_HighTimerValue
@@ -1088,9 +1088,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealHighTiming
 											=
@@ -1143,15 +1143,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 
 										break;
 
-				   /******/
+										/******/
 										/* mn */
-				   /******/
+										/******/
 
 									case 4:
 
-					   /******************/
+										/******************/
 										/* Timer 0 factor */
-					   /******************/
+										/******************/
 
 										ul_HighTimerValue
 											=
@@ -1165,9 +1165,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												*
 												b_ClockSelection));
 
-					   /*******************/
+										/*******************/
 										/* Round the value */
-					   /*******************/
+										/*******************/
 
 										if ((double)((double)(ul_HighTiming * 60.0) * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 											ul_HighTimerValue
@@ -1177,9 +1177,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 												1;
 										}
 
-					   /*****************************/
+										/*****************************/
 										/* Calculate the real timing */
-					   /*****************************/
+										/*****************************/
 
 										*pul_RealHighTiming
 											=
@@ -1239,9 +1239,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 									}
 
 									fpu_end();
-				/****************************/
+									/****************************/
 									/* Save the clock selection */
-				/****************************/
+									/****************************/
 
 									devpriv-&gt;
 										s_ModuleInfo
@@ -1251,9 +1251,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 										=
 										b_ClockSelection;
 
-				/************************/
+									/************************/
 									/* Save the timing unit */
-				/************************/
+									/************************/
 
 									devpriv-&gt;
 										s_ModuleInfo
@@ -1265,9 +1265,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 										=
 										b_TimingUnit;
 
-				/****************************/
+									/****************************/
 									/* Save the low base timing */
-				/****************************/
+									/****************************/
 
 									devpriv-&gt;
 										s_ModuleInfo
@@ -1289,9 +1289,9 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 										=
 										*pul_RealLowTiming;
 
-				/****************************/
+									/****************************/
 									/* Save the high base timing */
-				/****************************/
+									/****************************/
 
 									devpriv-&gt;
 										s_ModuleInfo
@@ -1313,21 +1313,21 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 										=
 										*pul_RealHighTiming;
 
-				/************************/
+									/************************/
 									/* Write the low timing */
-				/************************/
+									/************************/
 
 									outl(ul_LowTimerValue, devpriv-&gt;s_BoardInfos.ui_Address + 0 + (20 * b_PWM) + (64 * b_ModulNbr));
 
-				/*************************/
+									/*************************/
 									/* Write the high timing */
-				/*************************/
+									/*************************/
 
 									outl(ul_HighTimerValue, devpriv-&gt;s_BoardInfos.ui_Address + 4 + (20 * b_PWM) + (64 * b_ModulNbr));
 
-				/***************************/
+									/***************************/
 									/* Set the clock selection */
-				/***************************/
+									/***************************/
 
 									dw_Command
 										=
@@ -1354,15 +1354,15 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 											0x80;
 									}
 
-				/***************************/
+									/***************************/
 									/* Set the clock selection */
-				/***************************/
+									/***************************/
 
 									outl(dw_Command, devpriv-&gt;s_BoardInfos.ui_Address + 8 + (20 * b_PWM) + (64 * b_ModulNbr));
 
-				/*************/
+									/*************/
 									/* PWM init. */
-				/*************/
+									/*************/
 									devpriv-&gt;
 										s_ModuleInfo
 										[b_ModulNbr].
@@ -1373,65 +1373,65 @@ int i_APCI1710_InitPWM(struct comedi_device * dev,
 										=
 										1;
 								} else {
-				/***************************************************/
+									/***************************************************/
 									/* You can not used the 40MHz clock selection with */
 									/* this board                                      */
-				/***************************************************/
+									/***************************************************/
 									DPRINTK("You can not used the 40MHz clock selection with this board\n");
 									i_ReturnValue
 										=
 										-9;
 								}
 							} else {
-			     /***************************************/
+								/***************************************/
 								/* High base timing selection is wrong */
-			     /***************************************/
+								/***************************************/
 								DPRINTK("High base timing selection is wrong\n");
 								i_ReturnValue =
 									-8;
 							}
 						} else {
-			  /**************************************/
+							/**************************************/
 							/* Low base timing selection is wrong */
-			  /**************************************/
+							/**************************************/
 							DPRINTK("Low base timing selection is wrong\n");
 							i_ReturnValue = -7;
 						}
-					}	// if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4))
+					}	/*  if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4)) */
 					else {
-		       /**********************************/
+						/**********************************/
 						/* Timing unit selection is wrong */
-		       /**********************************/
+						/**********************************/
 						DPRINTK("Timing unit selection is wrong\n");
 						i_ReturnValue = -6;
-					}	// if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4))
-				}	// if ((b_ClockSelection == APCI1710_30MHZ) || (b_ClockSelection == APCI1710_33MHZ) || (b_ClockSelection == APCI1710_40MHZ))
+					}	/*  if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4)) */
+				}	/*  if ((b_ClockSelection == APCI1710_30MHZ) || (b_ClockSelection == APCI1710_33MHZ) || (b_ClockSelection == APCI1710_40MHZ)) */
 				else {
-		    /*******************************/
+					/*******************************/
 					/* The selected clock is wrong */
-		    /*******************************/
+					/*******************************/
 					DPRINTK("The selected clock is wrong\n");
 					i_ReturnValue = -5;
-				}	// if ((b_ClockSelection == APCI1710_30MHZ) || (b_ClockSelection == APCI1710_33MHZ) || (b_ClockSelection == APCI1710_40MHZ))
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+				}	/*  if ((b_ClockSelection == APCI1710_30MHZ) || (b_ClockSelection == APCI1710_33MHZ) || (b_ClockSelection == APCI1710_40MHZ)) */
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 			else {
-		 /******************************/
+				/******************************/
 				/* Tor PWM selection is wrong */
-		 /******************************/
+				/******************************/
 				DPRINTK("Tor PWM selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 		} else {
-	      /**********************************/
+			/**********************************/
 			/* The module is not a PWM module */
-	      /**********************************/
+			/**********************************/
 			DPRINTK("The module is not a PWM module\n");
 			i_ReturnValue = -3;
 		}
 	} else {
-	   /***********************/
+		/***********************/
 		/* Module number error */
-	   /***********************/
+		/***********************/
 		DPRINTK("Module number error\n");
 		i_ReturnValue = -2;
 	}
@@ -1554,48 +1554,48 @@ int i_APCI1710_GetPWMInitialisation(struct comedi_device * dev,
 	/**************************/
 
 	if (b_ModulNbr &lt; 4) {
-	   /***************/
+		/***************/
 		/* Test if PWM */
-	   /***************/
+		/***************/
 
 		if ((devpriv-&gt;s_BoardInfos.
 				dw_MolduleConfiguration[b_ModulNbr] &amp;
 				0xFFFF0000UL) == APCI1710_PWM) {
-	      /**************************/
+			/**************************/
 			/* Test the PWM selection */
-	      /**************************/
+			/**************************/
 
 			if (b_PWM &lt;= 1) {
-		 /***************************/
+				/***************************/
 				/* Test if PWM initialised */
-		 /***************************/
+				/***************************/
 
 				dw_Status = inl(devpriv-&gt;s_BoardInfos.
 					ui_Address + 12 + (20 * b_PWM) +
 					(64 * b_ModulNbr));
 
 				if (dw_Status &amp; 0x10) {
-		    /***********************/
+					/***********************/
 					/* Read the low timing */
-		    /***********************/
+					/***********************/
 
 					*pul_LowTiming =
 						inl(devpriv-&gt;s_BoardInfos.
 						ui_Address + 0 + (20 * b_PWM) +
 						(64 * b_ModulNbr));
 
-		    /************************/
+					/************************/
 					/* Read the high timing */
-		    /************************/
+					/************************/
 
 					*pul_HighTiming =
 						inl(devpriv-&gt;s_BoardInfos.
 						ui_Address + 4 + (20 * b_PWM) +
 						(64 * b_ModulNbr));
 
-		    /********************/
+					/********************/
 					/* Read the command */
-		    /********************/
+					/********************/
 
 					dw_Command = inl(devpriv-&gt;s_BoardInfos.
 						ui_Address + 8 + (20 * b_PWM) +
@@ -1619,9 +1619,9 @@ int i_APCI1710_GetPWMInitialisation(struct comedi_device * dev,
 								2) &amp; 1);
 					}
 
-		    /********************/
+					/********************/
 					/* Read the command */
-		    /********************/
+					/********************/
 
 					dw_Command = inl(devpriv-&gt;s_BoardInfos.
 						ui_Address + 8 + (20 * b_PWM) +
@@ -1634,33 +1634,33 @@ int i_APCI1710_GetPWMInitialisation(struct comedi_device * dev,
 						s_ModuleInfo[b_ModulNbr].
 						s_PWMModuleInfo.
 						s_PWMInfo[b_PWM].b_TimingUnit;
-				}	// if (dw_Status &amp; 0x10)
+				}	/*  if (dw_Status &amp; 0x10) */
 				else {
-		    /***********************/
+					/***********************/
 					/* PWM not initialised */
-		    /***********************/
+					/***********************/
 					DPRINTK("PWM not initialised\n");
 					i_ReturnValue = -5;
-				}	// if (dw_Status &amp; 0x10)
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+				}	/*  if (dw_Status &amp; 0x10) */
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 			else {
-		 /******************************/
+				/******************************/
 				/* Tor PWM selection is wrong */
-		 /******************************/
+				/******************************/
 				DPRINTK("Tor PWM selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 		} else {
-	      /**********************************/
+			/**********************************/
 			/* The module is not a PWM module */
-	      /**********************************/
+			/**********************************/
 			DPRINTK("The module is not a PWM module\n");
 			i_ReturnValue = -3;
 		}
 	} else {
-	   /***********************/
+		/***********************/
 		/* Module number error */
-	   /***********************/
+		/***********************/
 		DPRINTK("Module number error\n");
 		i_ReturnValue = -2;
 	}
@@ -1817,66 +1817,66 @@ int i_APCI1710_EnablePWM(struct comedi_device * dev,
 	unsigned int dw_Status;
 	unsigned int dw_Command;
 
-	devpriv-&gt;tsk_Current = current;	// Save the current process task structure
+	devpriv-&gt;tsk_Current = current;	/*  Save the current process task structure */
 	/**************************/
 	/* Test the module number */
 	/**************************/
 
 	if (b_ModulNbr &lt; 4) {
-	   /***************/
+		/***************/
 		/* Test if PWM */
-	   /***************/
+		/***************/
 
 		if ((devpriv-&gt;s_BoardInfos.
 				dw_MolduleConfiguration[b_ModulNbr] &amp;
 				0xFFFF0000UL) == APCI1710_PWM) {
-	      /**************************/
+			/**************************/
 			/* Test the PWM selection */
-	      /**************************/
+			/**************************/
 
 			if (b_PWM &lt;= 1) {
-		 /***************************/
+				/***************************/
 				/* Test if PWM initialised */
-		 /***************************/
+				/***************************/
 
 				dw_Status = inl(devpriv-&gt;s_BoardInfos.
 					ui_Address + 12 + (20 * b_PWM) +
 					(64 * b_ModulNbr));
 
 				if (dw_Status &amp; 0x10) {
-		    /**********************************/
+					/**********************************/
 					/* Test the start level selection */
-		    /**********************************/
+					/**********************************/
 
 					if (b_StartLevel &lt;= 1) {
-		       /**********************/
+						/**********************/
 						/* Test the stop mode */
-		       /**********************/
+						/**********************/
 
 						if (b_StopMode &lt;= 1) {
-			  /***********************/
+							/***********************/
 							/* Test the stop level */
-			  /***********************/
+							/***********************/
 
 							if (b_StopLevel &lt;= 2) {
-			     /*****************************/
+								/*****************************/
 								/* Test the extern gate mode */
-			     /*****************************/
+								/*****************************/
 
 								if (b_ExternGate
 									&lt;= 1) {
-				/*****************************/
+									/*****************************/
 									/* Test the interrupt action */
-				/*****************************/
+									/*****************************/
 
 									if (b_InterruptEnable == APCI1710_ENABLE || b_InterruptEnable == APCI1710_DISABLE) {
-				   /******************************************/
+										/******************************************/
 										/* Test if interrupt function initialised */
-				   /******************************************/
+										/******************************************/
 
-				      /********************/
+										/********************/
 										/* Read the command */
-				      /********************/
+										/********************/
 
 										dw_Command
 											=
@@ -1895,9 +1895,9 @@ int i_APCI1710_EnablePWM(struct comedi_device * dev,
 											&amp;
 											0x80;
 
-				      /********************/
+										/********************/
 										/* Make the command */
-				      /********************/
+										/********************/
 
 										dw_Command
 											=
@@ -1943,88 +1943,88 @@ int i_APCI1710_EnablePWM(struct comedi_device * dev,
 											=
 											b_InterruptEnable;
 
-				      /*******************/
+										/*******************/
 										/* Set the command */
-				      /*******************/
+										/*******************/
 
 										outl(dw_Command, devpriv-&gt;s_BoardInfos.ui_Address + 8 + (20 * b_PWM) + (64 * b_ModulNbr));
 
-				      /******************/
+										/******************/
 										/* Enable the PWM */
-				      /******************/
+										/******************/
 										outl(1, devpriv-&gt;s_BoardInfos.ui_Address + 12 + (20 * b_PWM) + (64 * b_ModulNbr));
-									}	// if (b_InterruptEnable == APCI1710_ENABLE || b_InterruptEnable == APCI1710_DISABLE)
+									}	/*  if (b_InterruptEnable == APCI1710_ENABLE || b_InterruptEnable == APCI1710_DISABLE) */
 									else {
-				   /********************************/
+										/********************************/
 										/* Interrupt parameter is wrong */
-				   /********************************/
+										/********************************/
 										DPRINTK("Interrupt parameter is wrong\n");
 										i_ReturnValue
 											=
 											-10;
-									}	// if (b_InterruptEnable == APCI1710_ENABLE || b_InterruptEnable == APCI1710_DISABLE)
-								}	// if (b_ExternGate &gt;= 0 &amp;&amp; b_ExternGate &lt;= 1)
+									}	/*  if (b_InterruptEnable == APCI1710_ENABLE || b_InterruptEnable == APCI1710_DISABLE) */
+								}	/*  if (b_ExternGate &gt;= 0 &amp;&amp; b_ExternGate &lt;= 1) */
 								else {
-				/*****************************************/
+									/*****************************************/
 									/* Extern gate signal selection is wrong */
-				/*****************************************/
+									/*****************************************/
 									DPRINTK("Extern gate signal selection is wrong\n");
 									i_ReturnValue
 										=
 										-9;
-								}	// if (b_ExternGate &gt;= 0 &amp;&amp; b_ExternGate &lt;= 1)
-							}	// if (b_StopLevel &gt;= 0 &amp;&amp; b_StopLevel &lt;= 2)
+								}	/*  if (b_ExternGate &gt;= 0 &amp;&amp; b_ExternGate &lt;= 1) */
+							}	/*  if (b_StopLevel &gt;= 0 &amp;&amp; b_StopLevel &lt;= 2) */
 							else {
-			     /*************************************/
+								/*************************************/
 								/* PWM stop level selection is wrong */
-			     /*************************************/
+								/*************************************/
 								DPRINTK("PWM stop level selection is wrong\n");
 								i_ReturnValue =
 									-8;
-							}	// if (b_StopLevel &gt;= 0 &amp;&amp; b_StopLevel &lt;= 2)
-						}	// if (b_StopMode &gt;= 0 &amp;&amp; b_StopMode &lt;= 1)
+							}	/*  if (b_StopLevel &gt;= 0 &amp;&amp; b_StopLevel &lt;= 2) */
+						}	/*  if (b_StopMode &gt;= 0 &amp;&amp; b_StopMode &lt;= 1) */
 						else {
-			  /************************************/
+							/************************************/
 							/* PWM stop mode selection is wrong */
-			  /************************************/
+							/************************************/
 							DPRINTK("PWM stop mode selection is wrong\n");
 							i_ReturnValue = -7;
-						}	// if (b_StopMode &gt;= 0 &amp;&amp; b_StopMode &lt;= 1)
-					}	// if (b_StartLevel &gt;= 0 &amp;&amp; b_StartLevel &lt;= 1)
+						}	/*  if (b_StopMode &gt;= 0 &amp;&amp; b_StopMode &lt;= 1) */
+					}	/*  if (b_StartLevel &gt;= 0 &amp;&amp; b_StartLevel &lt;= 1) */
 					else {
-		       /**************************************/
+						/**************************************/
 						/* PWM start level selection is wrong */
-		       /**************************************/
+						/**************************************/
 						DPRINTK("PWM start level selection is wrong\n");
 						i_ReturnValue = -6;
-					}	// if (b_StartLevel &gt;= 0 &amp;&amp; b_StartLevel &lt;= 1)
-				}	// if (dw_Status &amp; 0x10)
+					}	/*  if (b_StartLevel &gt;= 0 &amp;&amp; b_StartLevel &lt;= 1) */
+				}	/*  if (dw_Status &amp; 0x10) */
 				else {
-		    /***********************/
+					/***********************/
 					/* PWM not initialised */
-		    /***********************/
+					/***********************/
 					DPRINTK("PWM not initialised\n");
 					i_ReturnValue = -5;
-				}	// if (dw_Status &amp; 0x10)
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+				}	/*  if (dw_Status &amp; 0x10) */
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 			else {
-		 /******************************/
+				/******************************/
 				/* Tor PWM selection is wrong */
-		 /******************************/
+				/******************************/
 				DPRINTK("Tor PWM selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 		} else {
-	      /**********************************/
+			/**********************************/
 			/* The module is not a PWM module */
-	      /**********************************/
+			/**********************************/
 			DPRINTK("The module is not a PWM module\n");
 			i_ReturnValue = -3;
 		}
 	} else {
-	   /***********************/
+		/***********************/
 		/* Module number error */
-	   /***********************/
+		/***********************/
 		DPRINTK("Module number error\n");
 		i_ReturnValue = -2;
 	}
@@ -2072,74 +2072,74 @@ int i_APCI1710_DisablePWM(struct comedi_device * dev, unsigned char b_ModulNbr,
 	/**************************/
 
 	if (b_ModulNbr &lt; 4) {
-	   /***************/
+		/***************/
 		/* Test if PWM */
-	   /***************/
+		/***************/
 
 		if ((devpriv-&gt;s_BoardInfos.
 				dw_MolduleConfiguration[b_ModulNbr] &amp;
 				0xFFFF0000UL) == APCI1710_PWM) {
-	      /**************************/
+			/**************************/
 			/* Test the PWM selection */
-	      /**************************/
+			/**************************/
 
 			if (b_PWM &lt;= 1) {
-		 /***************************/
+				/***************************/
 				/* Test if PWM initialised */
-		 /***************************/
+				/***************************/
 
 				dw_Status = inl(devpriv-&gt;s_BoardInfos.
 					ui_Address + 12 + (20 * b_PWM) +
 					(64 * b_ModulNbr));
 
 				if (dw_Status &amp; 0x10) {
-		    /***********************/
+					/***********************/
 					/* Test if PWM enabled */
-		    /***********************/
+					/***********************/
 
 					if (dw_Status &amp; 0x1) {
-		       /*******************/
+						/*******************/
 						/* Disable the PWM */
-		       /*******************/
+						/*******************/
 						outl(0, devpriv-&gt;s_BoardInfos.
 							ui_Address + 12 +
 							(20 * b_PWM) +
 							(64 * b_ModulNbr));
-					}	// if (dw_Status &amp; 0x1)
+					}	/*  if (dw_Status &amp; 0x1) */
 					else {
-		       /*******************/
+						/*******************/
 						/* PWM not enabled */
-		       /*******************/
+						/*******************/
 						DPRINTK("PWM not enabled\n");
 						i_ReturnValue = -6;
-					}	// if (dw_Status &amp; 0x1)
-				}	// if (dw_Status &amp; 0x10)
+					}	/*  if (dw_Status &amp; 0x1) */
+				}	/*  if (dw_Status &amp; 0x10) */
 				else {
-		    /***********************/
+					/***********************/
 					/* PWM not initialised */
-		    /***********************/
+					/***********************/
 					DPRINTK(" PWM not initialised\n");
 					i_ReturnValue = -5;
-				}	// if (dw_Status &amp; 0x10)
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+				}	/*  if (dw_Status &amp; 0x10) */
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 			else {
-		 /******************************/
+				/******************************/
 				/* Tor PWM selection is wrong */
-		 /******************************/
+				/******************************/
 				DPRINTK("Tor PWM selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 		} else {
-	      /**********************************/
+			/**********************************/
 			/* The module is not a PWM module */
-	      /**********************************/
+			/**********************************/
 			DPRINTK("The module is not a PWM module\n");
 			i_ReturnValue = -3;
 		}
 	} else {
-	   /***********************/
+		/***********************/
 		/* Module number error */
-	   /***********************/
+		/***********************/
 		DPRINTK("Module number error\n");
 		i_ReturnValue = -2;
 	}
@@ -2209,21 +2209,21 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 	/**************************/
 
 	if (b_ModulNbr &lt; 4) {
-	   /***************/
+		/***************/
 		/* Test if PWM */
-	   /***************/
+		/***************/
 
 		if ((devpriv-&gt;s_BoardInfos.
 				dw_MolduleConfiguration[b_ModulNbr] &amp;
 				0xFFFF0000UL) == APCI1710_PWM) {
-	      /**************************/
+			/**************************/
 			/* Test the PWM selection */
-	      /**************************/
+			/**************************/
 
 			if (b_PWM &lt;= 1) {
-		 /***************************/
+				/***************************/
 				/* Test if PWM initialised */
-		 /***************************/
+				/***************************/
 
 				dw_Status = inl(devpriv-&gt;s_BoardInfos.
 					ui_Address + 12 + (20 * b_PWM) +
@@ -2235,14 +2235,14 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 						s_PWMModuleInfo.
 						b_ClockSelection;
 
-		    /************************/
+					/************************/
 					/* Test the timing unit */
-		    /************************/
+					/************************/
 
 					if (b_TimingUnit &lt;= 4) {
-		       /*********************************/
+						/*********************************/
 						/* Test the low timing selection */
-		       /*********************************/
+						/*********************************/
 
 						if (((b_ClockSelection ==
 									APCI1710_30MHZ)
@@ -2377,26 +2377,26 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 								&amp;&amp; (ul_LowTiming
 									&lt;=
 									7UL))) {
-			  /**********************************/
+							/**********************************/
 							/* Test the High timing selection */
-			  /**********************************/
+							/**********************************/
 
 							if (((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 0) &amp;&amp; (ul_HighTiming &gt;= 266) &amp;&amp; (ul_HighTiming &lt;= 0xFFFFFFFFUL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 1) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 571230650UL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 2) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 571230UL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 3) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 571UL)) || ((b_ClockSelection == APCI1710_30MHZ) &amp;&amp; (b_TimingUnit == 4) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 9UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 0) &amp;&amp; (ul_HighTiming &gt;= 242) &amp;&amp; (ul_HighTiming &lt;= 0xFFFFFFFFUL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 1) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 519691043UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 2) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 519691UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 3) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 520UL)) || ((b_ClockSelection == APCI1710_33MHZ) &amp;&amp; (b_TimingUnit == 4) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 8UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 0) &amp;&amp; (ul_HighTiming &gt;= 200) &amp;&amp; (ul_HighTiming &lt;= 0xFFFFFFFFUL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 1) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 429496729UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 2) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 429496UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 3) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 429UL)) || ((b_ClockSelection == APCI1710_40MHZ) &amp;&amp; (b_TimingUnit == 4) &amp;&amp; (ul_HighTiming &gt;= 1) &amp;&amp; (ul_HighTiming &lt;= 7UL))) {
-			     /************************************/
+								/************************************/
 								/* Calculate the low division fator */
-			     /************************************/
+								/************************************/
 
 								fpu_begin();
 								switch (b_TimingUnit) {
-				/******/
+									/******/
 									/* ns */
-				/******/
+									/******/
 
 								case 0:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_LowTimerValue
 										=
@@ -2405,9 +2405,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 										*
 										(0.00025 * b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_LowTiming * (0.00025 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 										ul_LowTimerValue
@@ -2417,9 +2417,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealLowTiming
 										=
@@ -2469,15 +2469,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/******/
+									/******/
 									/* æs */
-				/******/
+									/******/
 
 								case 1:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_LowTimerValue
 										=
@@ -2486,9 +2486,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 										*
 										(0.25 * b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_LowTiming * (0.25 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 										ul_LowTimerValue
@@ -2498,9 +2498,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealLowTiming
 										=
@@ -2552,15 +2552,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/******/
+									/******/
 									/* ms */
-				/******/
+									/******/
 
 								case 2:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_LowTimerValue
 										=
@@ -2570,9 +2570,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 										*
 										b_ClockSelection);
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_LowTiming * (250.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 										ul_LowTimerValue
@@ -2582,9 +2582,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealLowTiming
 										=
@@ -2634,15 +2634,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/*****/
+									/*****/
 									/* s */
-				/*****/
+									/*****/
 
 								case 3:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_LowTimerValue
 										=
@@ -2653,9 +2653,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											*
 											b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_LowTiming * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 										ul_LowTimerValue
@@ -2665,9 +2665,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealLowTiming
 										=
@@ -2720,15 +2720,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/******/
+									/******/
 									/* mn */
-				/******/
+									/******/
 
 								case 4:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_LowTimerValue
 										=
@@ -2742,9 +2742,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											*
 											b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)(ul_LowTiming * 60.0) * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_LowTimerValue + 0.5))) {
 										ul_LowTimerValue
@@ -2754,9 +2754,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealLowTiming
 										=
@@ -2815,20 +2815,20 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 									break;
 								}
 
-			     /*************************************/
+								/*************************************/
 								/* Calculate the high division fator */
-			     /*************************************/
+								/*************************************/
 
 								switch (b_TimingUnit) {
-				/******/
+									/******/
 									/* ns */
-				/******/
+									/******/
 
 								case 0:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_HighTimerValue
 										=
@@ -2837,9 +2837,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 										*
 										(0.00025 * b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_HighTiming * (0.00025 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 										ul_HighTimerValue
@@ -2849,9 +2849,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealHighTiming
 										=
@@ -2901,15 +2901,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/******/
+									/******/
 									/* æs */
-				/******/
+									/******/
 
 								case 1:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_HighTimerValue
 										=
@@ -2918,9 +2918,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 										*
 										(0.25 * b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_HighTiming * (0.25 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 										ul_HighTimerValue
@@ -2930,9 +2930,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealHighTiming
 										=
@@ -2984,15 +2984,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/******/
+									/******/
 									/* ms */
-				/******/
+									/******/
 
 								case 2:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_HighTimerValue
 										=
@@ -3002,9 +3002,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 										*
 										b_ClockSelection);
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_HighTiming * (250.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 										ul_HighTimerValue
@@ -3014,9 +3014,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealHighTiming
 										=
@@ -3066,15 +3066,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/*****/
+									/*****/
 									/* s */
-				/*****/
+									/*****/
 
 								case 3:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_HighTimerValue
 										=
@@ -3085,9 +3085,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											*
 											b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)ul_HighTiming * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 										ul_HighTimerValue
@@ -3097,9 +3097,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealHighTiming
 										=
@@ -3152,15 +3152,15 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 									break;
 
-				/******/
+									/******/
 									/* mn */
-				/******/
+									/******/
 
 								case 4:
 
-					/******************/
+									/******************/
 									/* Timer 0 factor */
-					/******************/
+									/******************/
 
 									ul_HighTimerValue
 										=
@@ -3174,9 +3174,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											*
 											b_ClockSelection));
 
-					/*******************/
+									/*******************/
 									/* Round the value */
-					/*******************/
+									/*******************/
 
 									if ((double)((double)(ul_HighTiming * 60.0) * (250000.0 * (double)b_ClockSelection)) &gt;= ((double)((double)ul_HighTimerValue + 0.5))) {
 										ul_HighTimerValue
@@ -3186,9 +3186,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 											1;
 									}
 
-					/*****************************/
+									/*****************************/
 									/* Calculate the real timing */
-					/*****************************/
+									/*****************************/
 
 									ul_RealHighTiming
 										=
@@ -3249,9 +3249,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 
 								fpu_end();
 
-			     /************************/
+								/************************/
 								/* Save the timing unit */
-			     /************************/
+								/************************/
 
 								devpriv-&gt;
 									s_ModuleInfo
@@ -3263,9 +3263,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 									=
 									b_TimingUnit;
 
-			     /****************************/
+								/****************************/
 								/* Save the low base timing */
-			     /****************************/
+								/****************************/
 
 								devpriv-&gt;
 									s_ModuleInfo
@@ -3287,9 +3287,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 									=
 									ul_RealLowTiming;
 
-			     /****************************/
+								/****************************/
 								/* Save the high base timing */
-			     /****************************/
+								/****************************/
 
 								devpriv-&gt;
 									s_ModuleInfo
@@ -3311,21 +3311,21 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 									=
 									ul_RealHighTiming;
 
-			     /************************/
+								/************************/
 								/* Write the low timing */
-			     /************************/
+								/************************/
 
 								outl(ul_LowTimerValue, devpriv-&gt;s_BoardInfos.ui_Address + 0 + (20 * b_PWM) + (64 * b_ModulNbr));
 
-			     /*************************/
+								/*************************/
 								/* Write the high timing */
-			     /*************************/
+								/*************************/
 
 								outl(ul_HighTimerValue, devpriv-&gt;s_BoardInfos.ui_Address + 4 + (20 * b_PWM) + (64 * b_ModulNbr));
 
-			     /***************************/
+								/***************************/
 								/* Set the clock selection */
-			     /***************************/
+								/***************************/
 
 								dw_Command =
 									inl
@@ -3347,9 +3347,9 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 										0x80;
 								}
 
-			     /***************************/
+								/***************************/
 								/* Set the clock selection */
-			     /***************************/
+								/***************************/
 
 								outl(dw_Command,
 									devpriv-&gt;
@@ -3358,55 +3358,55 @@ int i_APCI1710_SetNewPWMTiming(struct comedi_device * dev,
 									+ 8 +
 									(20 * b_PWM) + (64 * b_ModulNbr));
 							} else {
-			     /***************************************/
+								/***************************************/
 								/* High base timing selection is wrong */
-			     /***************************************/
+								/***************************************/
 								DPRINTK("High base timing selection is wrong\n");
 								i_ReturnValue =
 									-8;
 							}
 						} else {
-			  /**************************************/
+							/**************************************/
 							/* Low base timing selection is wrong */
-			  /**************************************/
+							/**************************************/
 							DPRINTK("Low base timing selection is wrong\n");
 							i_ReturnValue = -7;
 						}
-					}	// if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4))
+					}	/*  if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4)) */
 					else {
-		       /**********************************/
+						/**********************************/
 						/* Timing unit selection is wrong */
-		       /**********************************/
+						/**********************************/
 						DPRINTK("Timing unit selection is wrong\n");
 						i_ReturnValue = -6;
-					}	// if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4))
-				}	// if (dw_Status &amp; 0x10)
+					}	/*  if ((b_TimingUnit &gt;= 0) &amp;&amp; (b_TimingUnit &lt;= 4)) */
+				}	/*  if (dw_Status &amp; 0x10) */
 				else {
-		    /***********************/
+					/***********************/
 					/* PWM not initialised */
-		    /***********************/
+					/***********************/
 					DPRINTK("PWM not initialised\n");
 					i_ReturnValue = -5;
-				}	// if (dw_Status &amp; 0x10)
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+				}	/*  if (dw_Status &amp; 0x10) */
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 			else {
-		 /******************************/
+				/******************************/
 				/* Tor PWM selection is wrong */
-		 /******************************/
+				/******************************/
 				DPRINTK("Tor PWM selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 		} else {
-	      /**********************************/
+			/**********************************/
 			/* The module is not a PWM module */
-	      /**********************************/
+			/**********************************/
 			DPRINTK("The module is not a PWM module\n");
 			i_ReturnValue = -3;
 		}
 	} else {
-	   /***********************/
+		/***********************/
 		/* Module number error */
-	   /***********************/
+		/***********************/
 		DPRINTK("Module number error\n");
 		i_ReturnValue = -2;
 	}
@@ -3482,30 +3482,30 @@ int i_APCI1710_InsnReadGetPWMStatus(struct comedi_device * dev, struct comedi_su
 	/**************************/
 
 	if (b_ModulNbr &lt; 4) {
-	   /***************/
+		/***************/
 		/* Test if PWM */
-	   /***************/
+		/***************/
 
 		if ((devpriv-&gt;s_BoardInfos.
 				dw_MolduleConfiguration[b_ModulNbr] &amp;
 				0xFFFF0000UL) == APCI1710_PWM) {
-	      /**************************/
+			/**************************/
 			/* Test the PWM selection */
-	      /**************************/
+			/**************************/
 
 			if (b_PWM &lt;= 1) {
-		 /***************************/
+				/***************************/
 				/* Test if PWM initialised */
-		 /***************************/
+				/***************************/
 
 				dw_Status = inl(devpriv-&gt;s_BoardInfos.
 					ui_Address + 12 + (20 * b_PWM) +
 					(64 * b_ModulNbr));
 
 				if (dw_Status &amp; 0x10) {
-		    /***********************/
+					/***********************/
 					/* Test if PWM enabled */
-		    /***********************/
+					/***********************/
 
 					if (dw_Status &amp; 0x1) {
 						*pb_PWMOutputStatus =
@@ -3514,45 +3514,45 @@ int i_APCI1710_InsnReadGetPWMStatus(struct comedi_device * dev, struct comedi_su
 						*pb_ExternGateStatus =
 							(unsigned char) ((dw_Status &gt;&gt; 6)
 							&amp; 1);
-					}	// if (dw_Status &amp; 0x1)
+					}	/*  if (dw_Status &amp; 0x1) */
 					else {
-		       /*******************/
+						/*******************/
 						/* PWM not enabled */
-		       /*******************/
+						/*******************/
 
 						DPRINTK("PWM not enabled \n");
 						i_ReturnValue = -6;
-					}	// if (dw_Status &amp; 0x1)
-				}	// if (dw_Status &amp; 0x10)
+					}	/*  if (dw_Status &amp; 0x1) */
+				}	/*  if (dw_Status &amp; 0x10) */
 				else {
-		    /***********************/
+					/***********************/
 					/* PWM not initialised */
-		    /***********************/
+					/***********************/
 
 					DPRINTK("PWM not initialised\n");
 					i_ReturnValue = -5;
-				}	// if (dw_Status &amp; 0x10)
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+				}	/*  if (dw_Status &amp; 0x10) */
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 			else {
-		 /******************************/
+				/******************************/
 				/* Tor PWM selection is wrong */
-		 /******************************/
+				/******************************/
 
 				DPRINTK("Tor PWM selection is wrong\n");
 				i_ReturnValue = -4;
-			}	// if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1)
+			}	/*  if (b_PWM &gt;= 0 &amp;&amp; b_PWM &lt;= 1) */
 		} else {
-	      /**********************************/
+			/**********************************/
 			/* The module is not a PWM module */
-	      /**********************************/
+			/**********************************/
 
 			DPRINTK("The module is not a PWM module\n");
 			i_ReturnValue = -3;
 		}
 	} else {
-	   /***********************/
+		/***********************/
 		/* Module number error */
-	   /***********************/
+		/***********************/
 
 		DPRINTK("Module number error\n");
 		i_ReturnValue = -2;
@@ -3574,9 +3574,9 @@ int i_APCI1710_InsnBitsReadPWMInterrupt(struct comedi_device * dev,
 		s_FIFOInterruptParameters[devpriv-&gt;
 		s_InterruptParameters.ui_Read].ul_OldCounterLatchValue;
 
-			     /**************************/
+	/**************************/
 	/* Increment the read FIFO */
-			     /***************************/
+	/***************************/
 
 	devpriv-&gt;
 		s_InterruptParameters.</pre><hr><pre>commit c47375f3de0f478d8c2c0ce210cb2c5aeb1b411f
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:29:51 2009 -0400

    Staging: comedi: remove C99 comments in hwdrv_apci1500.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
index 3c97ed7ee9fe..8f2cae90be79 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
@@ -157,16 +157,16 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 
 	if (data[0] == 1) {
 		i_MaxChannel = 8;
-	}			// if (data[0] == 1)
+	}			/*  if (data[0] == 1) */
 	else {
 		if (data[0] == 2) {
 			i_MaxChannel = 6;
-		}		// if(data[0]==2)
+		}		/*  if(data[0]==2) */
 		else {
 			printk("\nThe specified port event  does not exist\n");
 			return -EINVAL;
-		}		//else if(data[0]==2)
-	}			//else  if (data[0] == 1)
+		}		/* else if(data[0]==2) */
+	}			/* else  if (data[0] == 1) */
 	switch (data[1]) {
 	case 0:
 		data[1] = APCI1500_AND;
@@ -180,7 +180,7 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 	default:
 		printk("\nThe specified interrupt logic does not exist\n");
 		return -EINVAL;
-	}			//switch(data[1]);
+	}			/* switch(data[1]); */
 
 	i_Logic = data[1];
 	for (i_Count = i_MaxChannel, i = 0; i_Count &gt; 0; i_Count--, i++) {
@@ -224,8 +224,8 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 		default:
 			printk("\nThe option indicated in the event mask does not exist\n");
 			return -EINVAL;
-		}		// switch(i_EventMask)
-	}			//for (i_Count = i_MaxChannel; i_Count &gt;0;i_Count --)
+		}		/*  switch(i_EventMask) */
+	}			/* for (i_Count = i_MaxChannel; i_Count &gt;0;i_Count --) */
 
 	if (data[0] == 1) {
 		    /****************************/
@@ -247,7 +247,7 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 			      /********************************************/
 				printk("\nTransition error on an OR PRIORITY logic\n");
 				return -EINVAL;
-			}	// if (data[1]== APCI1500_OR_PRIORITY &amp;&amp; i_PatternTransition != 0)
+			}	/*  if (data[1]== APCI1500_OR_PRIORITY &amp;&amp; i_PatternTransition != 0) */
 
 		       /*************************************/
 			/* Tests if more than one transition */
@@ -261,7 +261,7 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 						((i_PatternTransition &gt;&gt;
 							i_Count) &amp; 0x1);
 
-				}	//for (i_Count = 0; i_Count &lt; 8; i_Count++)
+				}	/* for (i_Count = 0; i_Count &lt; 8; i_Count++) */
 
 				if (i_PatternTransitionCount &gt; 1) {
 				  /****************************************/
@@ -269,8 +269,8 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 				  /****************************************/
 					printk("\n Transition error on an AND logic\n");
 					return -EINVAL;
-				}	// if (i_PatternTransitionCount &gt; 1)
-			}	// if (data[1]== APCI1500_AND)
+				}	/*  if (i_PatternTransitionCount &gt; 1) */
+			}	/*  if (data[1]== APCI1500_AND) */
 
 			    /*****************************************************************/
 			/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
@@ -359,12 +359,12 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		}		// if(data[1]==APCI1500_AND||data[1]==APCI1500_OR||data[1]==APCI1500_OR_PRIORITY)
+		}		/*  if(data[1]==APCI1500_AND||data[1]==APCI1500_OR||data[1]==APCI1500_OR_PRIORITY) */
 		else {
 			printk("\nThe choice for interrupt logic does not exist\n");
 			return -EINVAL;
-		}		// else }// if(data[1]==APCI1500_AND||data[1]==APCI1500_OR||data[1]==APCI1500_OR_PRIORITY)
-	}			//   if (data[0]== 1)
+		}		/*  else }// if(data[1]==APCI1500_AND||data[1]==APCI1500_OR||data[1]==APCI1500_OR_PRIORITY) */
+	}			/*    if (data[0]== 1) */
 
 		 /************************************/
 	/* Test if event setting for port 2 */
@@ -487,12 +487,12 @@ int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device * dev,
 			outb(0xF4,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		}		//  if (data[1] == APCI1500_OR)
+		}		/*   if (data[1] == APCI1500_OR) */
 		else {
 			printk("\nThe choice for interrupt logic does not exist\n");
 			return -EINVAL;
-		}		//elseif (data[1] == APCI1500_OR)
-	}			//if(data[0]==2)
+		}		/* elseif (data[1] == APCI1500_OR) */
+	}			/* if(data[0]==2) */
 
 	return insn-&gt;n;
 }
@@ -589,12 +589,12 @@ int i_APCI1500_StartStopInputEvent(struct comedi_device * dev, struct comedi_sub
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
 
-				}	// if(i_Event1Status==1)
+				}	/*  if(i_Event1Status==1) */
 				else {
 					printk("\nEvent 1 not initialised\n");
 					return -EINVAL;
-				}	//else if(i_Event1Status==1)
-			}	//if (data[1]==1)
+				}	/* else if(i_Event1Status==1) */
+			}	/* if (data[1]==1) */
 			if (data[1] == 2) {
 
 				if (i_Event2Status == 1) {
@@ -640,17 +640,17 @@ int i_APCI1500_StartStopInputEvent(struct comedi_device * dev, struct comedi_sub
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
 					i_Event2InterruptStatus = 1;
-				}	// if(i_Event2Status==1)
+				}	/*  if(i_Event2Status==1) */
 				else {
 					printk("\nEvent 2 not initialised\n");
 					return -EINVAL;
-				}	//else if(i_Event2Status==1)
-			}	// if(data[1]==2)
-		}		// if (data[1] == 1 || data[0] == 2)
+				}	/* else if(i_Event2Status==1) */
+			}	/*  if(data[1]==2) */
+		}		/*  if (data[1] == 1 || data[0] == 2) */
 		else {
 			printk("\nThe port parameter is in error\n");
 			return -EINVAL;
-		}		//else if (data[1] == 1 || data[0] == 2)
+		}		/* else if (data[1] == 1 || data[0] == 2) */
 
 		break;
 
@@ -701,12 +701,12 @@ int i_APCI1500_StartStopInputEvent(struct comedi_device * dev, struct comedi_sub
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
 					i_Event1InterruptStatus = 0;
-				}	// if(i_Event1Status==1)
+				}	/*  if(i_Event1Status==1) */
 				else {
 					printk("\nEvent 1 not initialised\n");
 					return -EINVAL;
-				}	//else if(i_Event1Status==1)
-			}	//if (data[1]==1)
+				}	/* else if(i_Event1Status==1) */
+			}	/* if (data[1]==1) */
 			if (data[1] == 2) {
 			 /*****************************/
 				/* Test if event initialised */
@@ -744,23 +744,23 @@ int i_APCI1500_StartStopInputEvent(struct comedi_device * dev, struct comedi_sub
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
 					i_Event2InterruptStatus = 0;
-				}	// if(i_Event2Status==1)
+				}	/*  if(i_Event2Status==1) */
 				else {
 					printk("\nEvent 2 not initialised\n");
 					return -EINVAL;
-				}	//else if(i_Event2Status==1)
-			}	//if(data[1]==2)
+				}	/* else if(i_Event2Status==1) */
+			}	/* if(data[1]==2) */
 
-		}		// if (data[1] == 1 || data[1] == 2)
+		}		/*  if (data[1] == 1 || data[1] == 2) */
 		else {
 			printk("\nThe port parameter is in error\n");
 			return -EINVAL;
-		}		//else if (data[1] == 1 || data[1] == 2)
+		}		/* else if (data[1] == 1 || data[1] == 2) */
 		break;
 	default:
 		printk("\nThe option of START/STOP logic does not exist\n");
 		return -EINVAL;
-	}			//switch(data[0])
+	}			/* switch(data[0]) */
 
 	return insn-&gt;n;
 }
@@ -973,11 +973,11 @@ int i_APCI1500_ReadMoreDigitalInput(struct comedi_device * dev, struct comedi_su
 				(unsigned int) inw(devpriv-&gt;i_IobaseAddon +
 				APCI1500_DIGITAL_IP);
 			*data = (ui_TmpValue &gt;&gt; ui_Channel) &amp; 0x1;
-		}		//if(ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=15)
+		}		/* if(ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=15) */
 		else {
 			printk("\nThe channel specification are in error\n");
-			return -EINVAL;	// "sorry channel spec wrong "
-		}		//else if(ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=15)
+			return -EINVAL;	/*  "sorry channel spec wrong " */
+		}		/* else if(ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=15) */
 		break;
 	case 1:
 
@@ -1001,14 +1001,14 @@ int i_APCI1500_ReadMoreDigitalInput(struct comedi_device * dev, struct comedi_su
 
 		default:
 			printk("\nSpecified channel cannot be read \n");
-			return -EINVAL;	// "sorry channel spec wrong "
+			return -EINVAL;	/*  "sorry channel spec wrong " */
 			break;
-		}		//switch(ui_Channel)
+		}		/* switch(ui_Channel) */
 		break;
 	default:
 		printk("\nThe specified functionality does not exist\n");
 		return -EINVAL;
-	}			//switch(data[0])
+	}			/* switch(data[0]) */
 	return insn-&gt;n;
 }
 
@@ -1073,18 +1073,18 @@ int i_APCI1500_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 	static unsigned int ui_Temp = 0;
 	unsigned int ui_Temp1;
 
-	unsigned int ui_NoOfChannel = CR_CHAN(insn-&gt;chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn-&gt;chanspec);	/*  get the channel */
 
 	if (!devpriv-&gt;b_OutputMemoryStatus) {
 		ui_Temp = 0;
 
-	}			//if(!devpriv-&gt;b_OutputMemoryStatus )
+	}			/* if(!devpriv-&gt;b_OutputMemoryStatus ) */
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] &lt;&lt; ui_NoOfChannel) | ui_Temp;
 			outw(data[0],
 				devpriv-&gt;i_IobaseAddon + APCI1500_DIGITAL_OP);
-		}		//if(data[1]==0)
+		}		/* if(data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				switch (ui_NoOfChannel) {
@@ -1113,19 +1113,19 @@ int i_APCI1500_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 
 				default:
 					comedi_error(dev, " chan spec wrong");
-					return -EINVAL;	// "sorry channel spec wrong "
+					return -EINVAL;	/*  "sorry channel spec wrong " */
 
-				}	//switch(ui_NoOfChannels)
+				}	/* switch(ui_NoOfChannels) */
 
 				outw(data[0],
 					devpriv-&gt;i_IobaseAddon +
 					APCI1500_DIGITAL_OP);
-			}	// if(data[1]==1)
+			}	/*  if(data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	//else if(data[1]==1)
-		}		//elseif(data[1]==0)
-	}			//if(data[3]==0)
+			}	/* else if(data[1]==1) */
+		}		/* elseif(data[1]==0) */
+	}			/* if(data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -1140,7 +1140,7 @@ int i_APCI1500_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 				outw(data[0],
 					devpriv-&gt;i_IobaseAddon +
 					APCI1500_DIGITAL_OP);
-			}	//if(data[1]==0)
+			}	/* if(data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					switch (ui_NoOfChannel) {
@@ -1190,24 +1190,24 @@ int i_APCI1500_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 					default:
 						comedi_error(dev,
 							" chan spec wrong");
-						return -EINVAL;	// "sorry channel spec wrong "
+						return -EINVAL;	/*  "sorry channel spec wrong " */
 
-					}	//switch(ui_NoOfChannels)
+					}	/* switch(ui_NoOfChannels) */
 
 					outw(data[0],
 						devpriv-&gt;i_IobaseAddon +
 						APCI1500_DIGITAL_OP);
-				}	// if(data[1]==1)
+				}	/*  if(data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	//else if(data[1]==1)
-			}	//elseif(data[1]==0)
-		}		//if(data[3]==1);
+				}	/* else if(data[1]==1) */
+			}	/* elseif(data[1]==0) */
+		}		/* if(data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		//if else data[3]==1)
-	}			//if else data[3]==0)
+		}		/* if else data[3]==1) */
+	}			/* if else data[3]==0) */
 	ui_Temp = data[0];
 	return (insn-&gt;n);;
 }
@@ -1268,20 +1268,20 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 
 	devpriv-&gt;tsk_Current = current;
 
-//Selection of the input clock
+/* Selection of the input clock */
 	if (data[0] == 0 || data[0] == 1 || data[0] == 2) {
 		outw(data[0], devpriv-&gt;i_IobaseAddon + APCI1500_CLK_SELECT);
-	}			// if(data[0]==0||data[0]==1||data[0]==2)
+	}			/*  if(data[0]==0||data[0]==1||data[0]==2) */
 	else {
 		if (data[0] != 3) {
 			printk("\nThe option for input clock selection does not exist\n");
 			return -EINVAL;
-		}		// if(data[0]!=3)
-	}			//elseif(data[0]==0||data[0]==1||data[0]==2)
-	//Select the counter/timer
+		}		/*  if(data[0]!=3) */
+	}			/* elseif(data[0]==0||data[0]==1||data[0]==2) */
+	/* Select the counter/timer */
 	switch (data[1]) {
 	case COUNTER1:
-		//selecting counter or timer
+		/* selecting counter or timer */
 		switch (data[2]) {
 		case 0:
 			data[2] = APCI1500_COUNTER;
@@ -1292,9 +1292,9 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis choice is not a timer nor a counter\n");
 			return -EINVAL;
-		}		// switch(data[2])
+		}		/*  switch(data[2]) */
 
-		//Selecting  single or continuous mode
+		/* Selecting  single or continuous mode */
 		switch (data[4]) {
 		case 0:
 			data[4] = APCI1500_CONTINUOUS;
@@ -1305,7 +1305,7 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis option for single/continuous mode does not exist\n");
 			return -EINVAL;
-		}		// switch(data[4])
+		}		/*  switch(data[4]) */
 
 		i_TimerCounterMode = data[2] | data[4] | 7;
 			 /*************************/
@@ -1428,21 +1428,21 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 				outb(0x2,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-			}	//if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE)
+			}	/* if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 			else {
 				printk("\nError in selection of interrupt enable or disable\n");
 				return -EINVAL;
-			}	//elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE)
-		}		// if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535))
+			}	/* elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
+		}		/*  if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		else {
 			printk("\nError in selection of reload value\n");
 			return -EINVAL;
-		}		//else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535))
+		}		/* else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		i_TimerCounterWatchdogInterrupt = data[7];
 		i_TimerCounter1Init = 1;
 		break;
 
-	case COUNTER2:		//selecting counter or timer
+	case COUNTER2:		/* selecting counter or timer */
 		switch (data[2]) {
 		case 0:
 			data[2] = APCI1500_COUNTER;
@@ -1453,9 +1453,9 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis choice is not a timer nor a counter\n");
 			return -EINVAL;
-		}		// switch(data[2])
+		}		/*  switch(data[2]) */
 
-		//Selecting  single or continuous mode
+		/* Selecting  single or continuous mode */
 		switch (data[4]) {
 		case 0:
 			data[4] = APCI1500_CONTINUOUS;
@@ -1466,9 +1466,9 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis option for single/continuous mode does not exist\n");
 			return -EINVAL;
-		}		// switch(data[4])
+		}		/*  switch(data[4]) */
 
-		//Selecting  software or hardware trigger
+		/* Selecting  software or hardware trigger */
 		switch (data[5]) {
 		case 0:
 			data[5] = APCI1500_SOFTWARE_TRIGGER;
@@ -1479,9 +1479,9 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis choice for software or hardware trigger does not exist\n");
 			return -EINVAL;
-		}		// switch(data[5])
+		}		/*  switch(data[5]) */
 
-		//Selecting  software or hardware gate
+		/* Selecting  software or hardware gate */
 		switch (data[6]) {
 		case 0:
 			data[6] = APCI1500_SOFTWARE_GATE;
@@ -1492,7 +1492,7 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis choice for software or hardware gate does not exist\n");
 			return -EINVAL;
-		}		// switch(data[6])
+		}		/*  switch(data[6]) */
 
 		i_TimerCounterMode = data[2] | data[4] | data[5] | data[6] | 7;
 
@@ -1616,21 +1616,21 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 				outb(0x2,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-			}	//if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE)
+			}	/* if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 			else {
 				printk("\nError in selection of interrupt enable or disable\n");
 				return -EINVAL;
-			}	//elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE)
-		}		// if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535))
+			}	/* elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
+		}		/*  if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		else {
 			printk("\nError in selection of reload value\n");
 			return -EINVAL;
-		}		//else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535))
+		}		/* else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		i_TimerCounterWatchdogInterrupt = data[7];
 		i_TimerCounter2Init = 1;
 		break;
 
-	case COUNTER3:		//selecting counter or watchdog
+	case COUNTER3:		/* selecting counter or watchdog */
 		switch (data[2]) {
 		case 0:
 			data[2] = APCI1500_COUNTER;
@@ -1641,9 +1641,9 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis choice is not a watchdog nor a counter\n");
 			return -EINVAL;
-		}		// switch(data[2])
+		}		/*  switch(data[2]) */
 
-		//Selecting  single or continuous mode
+		/* Selecting  single or continuous mode */
 		switch (data[4]) {
 		case 0:
 			data[4] = APCI1500_CONTINUOUS;
@@ -1654,9 +1654,9 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis option for single/continuous mode does not exist\n");
 			return -EINVAL;
-		}		// switch(data[4])
+		}		/*  switch(data[4]) */
 
-		//Selecting  software or hardware gate
+		/* Selecting  software or hardware gate */
 		switch (data[6]) {
 		case 0:
 			data[6] = APCI1500_SOFTWARE_GATE;
@@ -1667,7 +1667,7 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThis choice for software or hardware gate does not exist\n");
 			return -EINVAL;
-		}		// switch(data[6])
+		}		/*  switch(data[6]) */
 
 		      /*****************************/
 		/* Test if used for watchdog */
@@ -1680,10 +1680,10 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 			/* - Pulses output           */
 			     /*****************************/
 			i_TimerCounterMode = data[2] | data[4] | 0x54;
-		}		//if (data[2] == APCI1500_WATCHDOG)
+		}		/* if (data[2] == APCI1500_WATCHDOG) */
 		else {
 			i_TimerCounterMode = data[2] | data[4] | data[6] | 7;
-		}		//elseif (data[2] == APCI1500_WATCHDOG)
+		}		/* elseif (data[2] == APCI1500_WATCHDOG) */
 				 /*************************/
 		/* Test the reload value */
 			     /*************************/
@@ -1809,25 +1809,25 @@ int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device * dev,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
 
-				}	//elseif(data[2]==APCI1500_COUNTER)
+				}	/* elseif(data[2]==APCI1500_COUNTER) */
 
-			}	//if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE)
+			}	/* if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 			else {
 				printk("\nError in selection of interrupt enable or disable\n");
 				return -EINVAL;
-			}	//elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE)
-		}		// if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535))
+			}	/* elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
+		}		/*  if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		else {
 			printk("\nError in selection of reload value\n");
 			return -EINVAL;
-		}		//else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535))
+		}		/* else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		i_TimerCounterWatchdogInterrupt = data[7];
 		i_WatchdogCounter3Init = 1;
 		break;
 
 	default:
 		printk("\nThe specified counter\timer option does not exist\n");
-	}			//switch(data[1])
+	}			/* switch(data[1]) */
 	i_CounterLogic = data[2];
 	return insn-&gt;n;
 }
@@ -1871,11 +1871,11 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 		case START:
 			if (i_TimerCounter1Init == 1) {
 				if (i_TimerCounterWatchdogInterrupt == 1) {
-					i_CommandAndStatusValue = 0xC4;	//Enable the interrupt
-				}	// if(i_TimerCounterWatchdogInterrupt==1)
+					i_CommandAndStatusValue = 0xC4;	/* Enable the interrupt */
+				}	/*  if(i_TimerCounterWatchdogInterrupt==1) */
 				else {
-					i_CommandAndStatusValue = 0xE4;	//disable the interrupt
-				}	//elseif(i_TimerCounterWatchdogInterrupt==1)
+					i_CommandAndStatusValue = 0xE4;	/* disable the interrupt */
+				}	/* elseif(i_TimerCounterWatchdogInterrupt==1) */
 					      /**************************/
 				/* Starts timer/counter 1 */
 					      /**************************/
@@ -1889,7 +1889,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 				outb(i_CommandAndStatusValue,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-			}	//if( i_TimerCounter1Init==1)
+			}	/* if( i_TimerCounter1Init==1) */
 			else {
 				printk("\nCounter/Timer1 not configured\n");
 				return -EINVAL;
@@ -1922,14 +1922,14 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 						 /************************/
 
 					i_CommandAndStatusValue = 0x6;
-				}	//if( i_TimerCounter1Enabled==1)
+				}	/* if( i_TimerCounter1Enabled==1) */
 				else {
 						   /***************/
 					/* Set Trigger */
 						   /***************/
 
 					i_CommandAndStatusValue = 0x2;
-				}	//elseif(i_TimerCounter1Enabled==1)
+				}	/* elseif(i_TimerCounter1Enabled==1) */
 
 						/********************************************/
 				/* Selects the commands and status register */
@@ -1940,7 +1940,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 				outb(i_CommandAndStatusValue,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-			}	//if( i_TimerCounter1Init==1)
+			}	/* if( i_TimerCounter1Init==1) */
 			else {
 				printk("\nCounter/Timer1 not configured\n");
 				return -EINVAL;
@@ -1950,7 +1950,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThe specified option for start/stop/trigger does not exist\n");
 			return -EINVAL;
-		}		//switch(data[1])
+		}		/* switch(data[1]) */
 		break;
 
 	case COUNTER2:
@@ -1958,11 +1958,11 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 		case START:
 			if (i_TimerCounter2Init == 1) {
 				if (i_TimerCounterWatchdogInterrupt == 1) {
-					i_CommandAndStatusValue = 0xC4;	//Enable the interrupt
-				}	// if(i_TimerCounterWatchdogInterrupt==1)
+					i_CommandAndStatusValue = 0xC4;	/* Enable the interrupt */
+				}	/*  if(i_TimerCounterWatchdogInterrupt==1) */
 				else {
-					i_CommandAndStatusValue = 0xE4;	//disable the interrupt
-				}	//elseif(i_TimerCounterWatchdogInterrupt==1)
+					i_CommandAndStatusValue = 0xE4;	/* disable the interrupt */
+				}	/* elseif(i_TimerCounterWatchdogInterrupt==1) */
 					      /**************************/
 				/* Starts timer/counter 2 */
 					      /**************************/
@@ -1976,7 +1976,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 				outb(i_CommandAndStatusValue,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-			}	//if( i_TimerCounter2Init==1)
+			}	/* if( i_TimerCounter2Init==1) */
 			else {
 				printk("\nCounter/Timer2 not configured\n");
 				return -EINVAL;
@@ -2008,14 +2008,14 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 						 /************************/
 
 					i_CommandAndStatusValue = 0x6;
-				}	//if( i_TimerCounter2Enabled==1)
+				}	/* if( i_TimerCounter2Enabled==1) */
 				else {
 						   /***************/
 					/* Set Trigger */
 						   /***************/
 
 					i_CommandAndStatusValue = 0x2;
-				}	//elseif(i_TimerCounter2Enabled==1)
+				}	/* elseif(i_TimerCounter2Enabled==1) */
 
 						/********************************************/
 				/* Selects the commands and status register */
@@ -2026,7 +2026,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 				outb(i_CommandAndStatusValue,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-			}	//if( i_TimerCounter2Init==1)
+			}	/* if( i_TimerCounter2Init==1) */
 			else {
 				printk("\nCounter/Timer2 not configured\n");
 				return -EINVAL;
@@ -2035,7 +2035,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nThe specified option for start/stop/trigger does not exist\n");
 			return -EINVAL;
-		}		//switch(data[1])
+		}		/* switch(data[1]) */
 		break;
 	case COUNTER3:
 		switch (data[1]) {
@@ -2043,11 +2043,11 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 			if (i_WatchdogCounter3Init == 1) {
 
 				if (i_TimerCounterWatchdogInterrupt == 1) {
-					i_CommandAndStatusValue = 0xC4;	//Enable the interrupt
-				}	// if(i_TimerCounterWatchdogInterrupt==1)
+					i_CommandAndStatusValue = 0xC4;	/* Enable the interrupt */
+				}	/*  if(i_TimerCounterWatchdogInterrupt==1) */
 				else {
-					i_CommandAndStatusValue = 0xE4;	//disable the interrupt
-				}	//elseif(i_TimerCounterWatchdogInterrupt==1)
+					i_CommandAndStatusValue = 0xE4;	/* disable the interrupt */
+				}	/* elseif(i_TimerCounterWatchdogInterrupt==1) */
 					      /**************************/
 				/* Starts Watchdog/counter 3 */
 					      /**************************/
@@ -2062,7 +2062,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-			}	// if( i_WatchdogCounter3init==1)
+			}	/*  if( i_WatchdogCounter3init==1) */
 			else {
 				printk("\nWatchdog/Counter3 not configured\n");
 				return -EINVAL;
@@ -2089,7 +2089,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 
 		case TRIGGER:
 			switch (data[2]) {
-			case 0:	//triggering counter 3
+			case 0:	/* triggering counter 3 */
 				if (i_WatchdogCounter3Init == 1) {
 					if (i_WatchdogCounter3Enabled == 1) {
 							       /************************/
@@ -2097,14 +2097,14 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 							       /************************/
 
 						i_CommandAndStatusValue = 0x6;
-					}	//if( i_WatchdogCounter3Enabled==1)
+					}	/* if( i_WatchdogCounter3Enabled==1) */
 					else {
 							   /***************/
 						/* Set Trigger */
 							   /***************/
 
 						i_CommandAndStatusValue = 0x2;
-					}	//elseif(i_WatchdogCounter3Enabled==1)
+					}	/* elseif(i_WatchdogCounter3Enabled==1) */
 
 						/********************************************/
 					/* Selects the commands and status register */
@@ -2115,14 +2115,14 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 					outb(i_CommandAndStatusValue,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-				}	//if( i_WatchdogCounter3Init==1)
+				}	/* if( i_WatchdogCounter3Init==1) */
 				else {
 					printk("\nCounter3 not configured\n");
 					return -EINVAL;
 				}
 				break;
 			case 1:
-				//triggering Watchdog 3
+				/* triggering Watchdog 3 */
 				if (i_WatchdogCounter3Init == 1) {
 
 						/********************************************/
@@ -2134,7 +2134,7 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 					outb(0x6,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-				}	//if( i_WatchdogCounter3Init==1)
+				}	/* if( i_WatchdogCounter3Init==1) */
 				else {
 					printk("\nWatchdog 3 not configured\n");
 					return -EINVAL;
@@ -2143,17 +2143,17 @@ int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device * dev,
 			default:
 				printk("\nWrong choice of watchdog/counter3\n");
 				return -EINVAL;
-			}	//switch(data[2])
+			}	/* switch(data[2]) */
 			break;
 		default:
 			printk("\nThe specified option for start/stop/trigger does not exist\n");
 			return -EINVAL;
-		}		//switch(data[1])
+		}		/* switch(data[1]) */
 		break;
 	default:
 		printk("\nThe specified choice for counter/watchdog/timer does not exist\n");
 		return -EINVAL;
-	}			//switch(data[0])
+	}			/* switch(data[0]) */
 	return insn-&gt;n;
 }
 
@@ -2188,7 +2188,7 @@ int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device * dev,
 	int i_CommandAndStatusValue;
 	switch (data[0]) {
 	case COUNTER1:
-		//Read counter/timer1
+		/* Read counter/timer1 */
 		if (i_TimerCounter1Init == 1) {
 			if (i_TimerCounter1Enabled == 1) {
 		  /************************/
@@ -2196,14 +2196,14 @@ int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device * dev,
 		  /************************/
 
 				i_CommandAndStatusValue = 0xC;
-			}	//if( i_TimerCounter1Init==1)
+			}	/* if( i_TimerCounter1Init==1) */
 			else {
 		    /***************/
 				/* Set RCC */
 		    /***************/
 
 				i_CommandAndStatusValue = 0x8;
-			}	//elseif(i_TimerCounter1Init==1)
+			}	/* elseif(i_TimerCounter1Init==1) */
 
 		/********************************************/
 			/* Selects the commands and status register */
@@ -2232,14 +2232,14 @@ int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device * dev,
 			data[0] =
 				data[0] | inb(devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		}		//if( i_TimerCounter1Init==1)
+		}		/* if( i_TimerCounter1Init==1) */
 		else {
 			printk("\nTimer/Counter1 not configured\n");
 			return -EINVAL;
-		}		//elseif( i_TimerCounter1Init==1)
+		}		/* elseif( i_TimerCounter1Init==1) */
 		break;
 	case COUNTER2:
-		//Read counter/timer2
+		/* Read counter/timer2 */
 		if (i_TimerCounter2Init == 1) {
 			if (i_TimerCounter2Enabled == 1) {
 		  /************************/
@@ -2247,14 +2247,14 @@ int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device * dev,
 		  /************************/
 
 				i_CommandAndStatusValue = 0xC;
-			}	//if( i_TimerCounter2Init==1)
+			}	/* if( i_TimerCounter2Init==1) */
 			else {
 		    /***************/
 				/* Set RCC */
 		    /***************/
 
 				i_CommandAndStatusValue = 0x8;
-			}	//elseif(i_TimerCounter2Init==1)
+			}	/* elseif(i_TimerCounter2Init==1) */
 
 		/********************************************/
 			/* Selects the commands and status register */
@@ -2283,14 +2283,14 @@ int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device * dev,
 			data[0] =
 				data[0] | inb(devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		}		//if( i_TimerCounter2Init==1)
+		}		/* if( i_TimerCounter2Init==1) */
 		else {
 			printk("\nTimer/Counter2 not configured\n");
 			return -EINVAL;
-		}		//elseif( i_TimerCounter2Init==1)
+		}		/* elseif( i_TimerCounter2Init==1) */
 		break;
 	case COUNTER3:
-		//Read counter/watchdog2
+		/* Read counter/watchdog2 */
 		if (i_WatchdogCounter3Init == 1) {
 			if (i_WatchdogCounter3Enabled == 1) {
 		  /************************/
@@ -2298,14 +2298,14 @@ int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device * dev,
 		  /************************/
 
 				i_CommandAndStatusValue = 0xC;
-			}	//if( i_TimerCounter2Init==1)
+			}	/* if( i_TimerCounter2Init==1) */
 			else {
 		    /***************/
 				/* Set RCC */
 		    /***************/
 
 				i_CommandAndStatusValue = 0x8;
-			}	//elseif(i_WatchdogCounter3Init==1)
+			}	/* elseif(i_WatchdogCounter3Init==1) */
 
 		/********************************************/
 			/* Selects the commands and status register */
@@ -2334,16 +2334,16 @@ int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device * dev,
 			data[0] =
 				data[0] | inb(devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		}		//if( i_WatchdogCounter3Init==1)
+		}		/* if( i_WatchdogCounter3Init==1) */
 		else {
 			printk("\nWatchdogCounter3 not configured\n");
 			return -EINVAL;
-		}		//elseif( i_WatchdogCounter3Init==1)
+		}		/* elseif( i_WatchdogCounter3Init==1) */
 		break;
 	default:
 		printk("\nThe choice of timer/counter/watchdog does not exist\n");
 		return -EINVAL;
-	}			//switch(data[0])
+	}			/* switch(data[0]) */
 
 	return insn-&gt;n;
 }
@@ -2411,16 +2411,16 @@ int i_APCI1500_ConfigureInterrupt(struct comedi_device * dev, struct comedi_subd
 	outl(0x0, devpriv-&gt;i_IobaseAmcc + 0x38);
 	if (data[0] == 1) {
 		i_Constant = 0xC0;
-	}			//if(data[0]==1)
+	}			/* if(data[0]==1) */
 	else {
 		if (data[0] == 0) {
 			i_Constant = 0x00;
-		}		//if{data[0]==0)
+		}		/* if{data[0]==0) */
 		else {
 			printk("\nThe parameter passed to driver is in error for enabling the voltage interrupt\n");
 			return -EINVAL;
-		}		//else if(data[0]==0)
-	}			//elseif(data[0]==1)
+		}		/* else if(data[0]==0) */
+	}			/* elseif(data[0]==1) */
 
 	 /*****************************************************/
 	/* Selects the mode specification register of port B */
@@ -2599,11 +2599,11 @@ static void v_APCI1500_Interrupt(int irq, void *d)
       /*************************************************/
 		/* Selects the master interrupt control register */
       /*************************************************/
-		//outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,devpriv-&gt;iobase+APCI1500_Z8536_CONTROL_REGISTER);
+		/* outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,devpriv-&gt;iobase+APCI1500_Z8536_CONTROL_REGISTER); */
 	/**********************************************/
 		/* Disables  the main interrupt on the board */
 	/**********************************************/
-		//outb(0x00,devpriv-&gt;iobase+APCI1500_Z8536_CONTROL_REGISTER);
+		/* outb(0x00,devpriv-&gt;iobase+APCI1500_Z8536_CONTROL_REGISTER); */
 
    /*****************************************************/
 		/* Selects the command and status register of port A */
@@ -2647,11 +2647,11 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 
 				i_InputChannel = 1 + (i_RegValue &gt;&gt; 1);
 
-			}	// if(i_Logic==APCI1500_OR_PRIORITY)
+			}	/*  if(i_Logic==APCI1500_OR_PRIORITY) */
 			else {
 				i_InputChannel = 0;
-			}	//elseif(i_Logic==APCI1500_OR_PRIORITY)
-		}		// if ((i_RegValue &amp; 0x60) == 0x60)
+			}	/* elseif(i_Logic==APCI1500_OR_PRIORITY) */
+		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
 
 	   /*****************************************************/
 		/* Selects the command and status register of port B */
@@ -2688,7 +2688,7 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 	      /**************************************/
 
 			if (i_RegValue) {
-				//Disable the interrupt
+				/* Disable the interrupt */
 		     /*****************************************************/
 				/* Selects the command and status register of port B */
 		     /*****************************************************/
@@ -2697,17 +2697,17 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 				if (i_RegValue &amp; 0x80) {
 					i_InterruptMask =
 						i_InterruptMask | 0x40;
-				}	//if (i_RegValue &amp; 0x80)
+				}	/* if (i_RegValue &amp; 0x80) */
 
 				if (i_RegValue &amp; 0x40) {
 					i_InterruptMask =
 						i_InterruptMask | 0x80;
-				}	//if (i_RegValue &amp; 0x40)
-			}	// if (i_RegValue)
+				}	/* if (i_RegValue &amp; 0x40) */
+			}	/*  if (i_RegValue) */
 			else {
 				i_InterruptMask = i_InterruptMask | 2;
-			}	// if (i_RegValue)
-		}		//if ((i_RegValue &amp; 0x60) == 0x60)
+			}	/*  if (i_RegValue) */
+		}		/* if ((i_RegValue &amp; 0x60) == 0x60) */
 
 		/*****************************************************/
 		/* Selects the command and status register of timer 1 */
@@ -2731,7 +2731,7 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 			i_InterruptMask = i_InterruptMask | 4;
-		}		// if ((i_RegValue &amp; 0x60) == 0x60)
+		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
 		/*****************************************************/
 		/* Selects the command and status register of timer 2 */
 		/*****************************************************/
@@ -2754,7 +2754,7 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 			i_InterruptMask = i_InterruptMask | 8;
-		}		// if ((i_RegValue &amp; 0x60) == 0x60)
+		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
 
 		/*****************************************************/
 		/* Selects the command and status register of timer 3 */
@@ -2779,13 +2779,13 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 				APCI1500_Z8536_CONTROL_REGISTER);
 			if (i_CounterLogic == APCI1500_COUNTER) {
 				i_InterruptMask = i_InterruptMask | 0x10;
-			}	//if(i_CounterLogic==APCI1500_COUNTER)
+			}	/* if(i_CounterLogic==APCI1500_COUNTER) */
 			else {
 				i_InterruptMask = i_InterruptMask | 0x20;
 			}
-		}		// if ((i_RegValue &amp; 0x60) == 0x60)
+		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
 
-		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
+		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
 	       /***********************/
 		/* Enable all Interrupts */
 	       /***********************/
@@ -2799,11 +2799,11 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 		/* Authorizes the main interrupt on the board */
 	       /**********************************************/
 		outb(0xD0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	}			//  if ((ui_InterruptStatus &amp; 0x800000) == 0x800000)
+	}			/*   if ((ui_InterruptStatus &amp; 0x800000) == 0x800000) */
 	else {
 		printk("\nInterrupt from unknown source\n");
 
-	}			//else if ((ui_InterruptStatus &amp; 0x800000) == 0x800000)
+	}			/* else if ((ui_InterruptStatus &amp; 0x800000) == 0x800000) */
 	return;
 }
 
@@ -2982,7 +2982,7 @@ int i_APCI1500_Reset(struct comedi_device * dev)
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes all interrupts */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	//reset all the digital outputs
+	/* reset all the digital outputs */
 	outw(0x0, devpriv-&gt;i_IobaseAddon + APCI1500_DIGITAL_OP);
 /*******************************/
 /* Disable the board interrupt */</pre><hr><pre>commit 0109253dee3d211619876d3345ecc4c312d1b153
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:29:45 2009 -0400

    Staging: comedi: remove C99 comments in pcl818.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/pcl818.c b/drivers/staging/comedi/drivers/pcl818.c
index 43a9d56c6a43..b65a44bfdde9 100644
--- a/drivers/staging/comedi/drivers/pcl818.c
+++ b/drivers/staging/comedi/drivers/pcl818.c
@@ -107,9 +107,9 @@ A word or two about DMA. Driver support DMA operations at two ways:
 
 #include "8253.h"
 
-// #define PCL818_MODE13_AO 1
+/* #define PCL818_MODE13_AO 1 */
 
-// boards constants
+/* boards constants */
 
 #define boardPCL818L 0
 #define boardPCL818H 1
@@ -118,60 +118,60 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #define boardPCL818 4
 #define boardPCL718 5
 
-// IO space len
+/* IO space len */
 #define PCLx1x_RANGE 16
-// IO space len if we use FIFO
+/* IO space len if we use FIFO */
 #define PCLx1xFIFO_RANGE 32
 
-// W: clear INT request
+/* W: clear INT request */
 #define PCL818_CLRINT 8
-// R: return status byte
+/* R: return status byte */
 #define PCL818_STATUS 8
-// R: A/D high byte W: A/D range control
+/* R: A/D high byte W: A/D range control */
 #define PCL818_RANGE 1
-// R: next mux scan channel W: mux scan channel &amp; range control pointer
+/* R: next mux scan channel W: mux scan channel &amp; range control pointer */
 #define PCL818_MUX 2
-// R/W: operation control register
+/* R/W: operation control register */
 #define PCL818_CONTROL 9
-// W: counter enable
+/* W: counter enable */
 #define PCL818_CNTENABLE 10
 
-// R: low byte of A/D W: soft A/D trigger
+/* R: low byte of A/D W: soft A/D trigger */
 #define PCL818_AD_LO 0
-// R: high byte of A/D W: A/D range control
+/* R: high byte of A/D W: A/D range control */
 #define PCL818_AD_HI 1
-// W: D/A low&amp;high byte
+/* W: D/A low&amp;high byte */
 #define PCL818_DA_LO 4
 #define PCL818_DA_HI 5
-// R: low&amp;high byte of DI
+/* R: low&amp;high byte of DI */
 #define PCL818_DI_LO 3
 #define PCL818_DI_HI 11
-// W: low&amp;high byte of DO
+/* W: low&amp;high byte of DO */
 #define PCL818_DO_LO 3
 #define PCL818_DO_HI 11
-// W: PCL718 second D/A
+/* W: PCL718 second D/A */
 #define PCL718_DA2_LO 6
 #define PCL718_DA2_HI 7
-// counters
+/* counters */
 #define PCL818_CTR0 12
 #define PCL818_CTR1 13
 #define PCL818_CTR2 14
-// W: counter control
+/* W: counter control */
 #define PCL818_CTRCTL 15
 
-// W: fifo enable/disable
+/* W: fifo enable/disable */
 #define PCL818_FI_ENABLE 6
-// W: fifo interrupt clear
+/* W: fifo interrupt clear */
 #define PCL818_FI_INTCLR 20
-// W: fifo interrupt clear
+/* W: fifo interrupt clear */
 #define PCL818_FI_FLUSH 25
-// R: fifo status
+/* R: fifo status */
 #define PCL818_FI_STATUS 25
-// R: one record from FIFO
+/* R: one record from FIFO */
 #define PCL818_FI_DATALO 23
 #define PCL818_FI_DATAHI 23
 
-// type of interrupt handler
+/* type of interrupt handler */
 #define INT_TYPE_AI1_INT 1
 #define INT_TYPE_AI1_DMA 2
 #define INT_TYPE_AI1_FIFO 3
@@ -184,7 +184,7 @@ A word or two about DMA. Driver support DMA operations at two ways:
 #endif
 
 #ifdef unused
-// RTC stuff...
+/* RTC stuff... */
 #define INT_TYPE_AI1_DMA_RTC 9
 #define INT_TYPE_AI3_DMA_RTC 10
 
@@ -254,22 +254,22 @@ static int RTC_timer_lock = 0;	/* RTC int lock */
 
 struct pcl818_board {
 
-	const char *name;	// driver name
-	int n_ranges;		// len of range list
-	int n_aichan_se;	// num of A/D chans in single ended  mode
-	int n_aichan_diff;	// num of A/D chans in diferencial mode
-	unsigned int ns_min;	// minimal alllowed delay between samples (in ns)
-	int n_aochan;		// num of D/A chans
-	int n_dichan;		// num of DI chans
-	int n_dochan;		// num of DO chans
-	const struct comedi_lrange *ai_range_type;	// default A/D rangelist
-	const struct comedi_lrange *ao_range_type;	// default D/A rangelist
-	unsigned int io_range;	// len of IO space
-	unsigned int IRQbits;	// allowed interrupts
-	unsigned int DMAbits;	// allowed DMA chans
-	int ai_maxdata;		// maxdata for A/D
-	int ao_maxdata;		// maxdata for D/A
-	unsigned char fifo;	// 1=board has FIFO
+	const char *name;	/*  driver name */
+	int n_ranges;		/*  len of range list */
+	int n_aichan_se;	/*  num of A/D chans in single ended  mode */
+	int n_aichan_diff;	/*  num of A/D chans in diferencial mode */
+	unsigned int ns_min;	/*  minimal alllowed delay between samples (in ns) */
+	int n_aochan;		/*  num of D/A chans */
+	int n_dichan;		/*  num of DI chans */
+	int n_dochan;		/*  num of DO chans */
+	const struct comedi_lrange *ai_range_type;	/*  default A/D rangelist */
+	const struct comedi_lrange *ao_range_type;	/*  default D/A rangelist */
+	unsigned int io_range;	/*  len of IO space */
+	unsigned int IRQbits;	/*  allowed interrupts */
+	unsigned int DMAbits;	/*  allowed DMA chans */
+	int ai_maxdata;		/*  maxdata for A/D */
+	int ao_maxdata;		/*  maxdata for D/A */
+	unsigned char fifo;	/*  1=board has FIFO */
 	int is_818;
 };
 
@@ -315,54 +315,54 @@ COMEDI_INITCLEANUP(driver_pcl818);
 
 struct pcl818_private {
 
-	unsigned int dma;	// used DMA, 0=don't use DMA
-	int dma_rtc;		// 1=RTC used with DMA, 0=no RTC alloc
+	unsigned int dma;	/*  used DMA, 0=don't use DMA */
+	int dma_rtc;		/*  1=RTC used with DMA, 0=no RTC alloc */
 	unsigned int io_range;
 #ifdef unused
-	unsigned long rtc_iobase;	// RTC port region
+	unsigned long rtc_iobase;	/*  RTC port region */
 	unsigned int rtc_iosize;
 	unsigned int rtc_irq;
-	struct timer_list rtc_irq_timer;	// timer for RTC sanity check
-	unsigned long rtc_freq;	// RTC int freq
-	int rtc_irq_blocked;	// 1=we now do AI with DMA&amp;RTC
+	struct timer_list rtc_irq_timer;	/*  timer for RTC sanity check */
+	unsigned long rtc_freq;	/*  RTC int freq */
+	int rtc_irq_blocked;	/*  1=we now do AI with DMA&amp;RTC */
 #endif
-	unsigned long dmabuf[2];	// pointers to begin of DMA buffers
-	unsigned int dmapages[2];	// len of DMA buffers in PAGE_SIZEs
-	unsigned int hwdmaptr[2];	// hardware address of DMA buffers
-	unsigned int hwdmasize[2];	// len of DMA buffers in Bytes
-	unsigned int dmasamplsize;	// size in samples hwdmasize[0]/2
-	unsigned int last_top_dma;	// DMA pointer in last RTC int
-	int next_dma_buf;	// which DMA buffer will be used next round
-	long dma_runs_to_end;	// how many we must permorm DMA transfer to end of record
-	unsigned long last_dma_run;	// how many bytes we must transfer on last DMA page
-	unsigned char neverending_ai;	// if=1, then we do neverending record (you must use cancel())
-	unsigned int ns_min;	// manimal alllowed delay between samples (in us) for actual card
-	int i8253_osc_base;	// 1/frequency of on board oscilator in ns
-	int irq_free;		// 1=have allocated IRQ
-	int irq_blocked;	// 1=IRQ now uses any subdev
-	int irq_was_now_closed;	// when IRQ finish, there's stored int818_mode for last interrupt
-	int ai_mode;		// who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma
-	struct comedi_subdevice *last_int_sub;	// ptr to subdevice which now finish
-	int ai_act_scan;	// how many scans we finished
-	int ai_act_chan;	// actual position in actual scan
-	unsigned int act_chanlist[16];	// MUX setting for actual AI operations
-	unsigned int act_chanlist_len;	// how long is actual MUX list
-	unsigned int act_chanlist_pos;	// actual position in MUX list
-	unsigned int ai_scans;	// len of scanlist
-	unsigned int ai_n_chan;	// how many channels is measured
-	unsigned int *ai_chanlist;	// actaul chanlist
-	unsigned int ai_flags;	// flaglist
-	unsigned int ai_data_len;	// len of data buffer
-	short *ai_data;	// data buffer
-	unsigned int ai_timer1;	// timers
+	unsigned long dmabuf[2];	/*  pointers to begin of DMA buffers */
+	unsigned int dmapages[2];	/*  len of DMA buffers in PAGE_SIZEs */
+	unsigned int hwdmaptr[2];	/*  hardware address of DMA buffers */
+	unsigned int hwdmasize[2];	/*  len of DMA buffers in Bytes */
+	unsigned int dmasamplsize;	/*  size in samples hwdmasize[0]/2 */
+	unsigned int last_top_dma;	/*  DMA pointer in last RTC int */
+	int next_dma_buf;	/*  which DMA buffer will be used next round */
+	long dma_runs_to_end;	/*  how many we must permorm DMA transfer to end of record */
+	unsigned long last_dma_run;	/*  how many bytes we must transfer on last DMA page */
+	unsigned char neverending_ai;	/*  if=1, then we do neverending record (you must use cancel()) */
+	unsigned int ns_min;	/*  manimal alllowed delay between samples (in us) for actual card */
+	int i8253_osc_base;	/*  1/frequency of on board oscilator in ns */
+	int irq_free;		/*  1=have allocated IRQ */
+	int irq_blocked;	/*  1=IRQ now uses any subdev */
+	int irq_was_now_closed;	/*  when IRQ finish, there's stored int818_mode for last interrupt */
+	int ai_mode;		/*  who now uses IRQ - 1=AI1 int, 2=AI1 dma, 3=AI3 int, 4AI3 dma */
+	struct comedi_subdevice *last_int_sub;	/*  ptr to subdevice which now finish */
+	int ai_act_scan;	/*  how many scans we finished */
+	int ai_act_chan;	/*  actual position in actual scan */
+	unsigned int act_chanlist[16];	/*  MUX setting for actual AI operations */
+	unsigned int act_chanlist_len;	/*  how long is actual MUX list */
+	unsigned int act_chanlist_pos;	/*  actual position in MUX list */
+	unsigned int ai_scans;	/*  len of scanlist */
+	unsigned int ai_n_chan;	/*  how many channels is measured */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
+	unsigned int ai_flags;	/*  flaglist */
+	unsigned int ai_data_len;	/*  len of data buffer */
+	short *ai_data;	/*  data buffer */
+	unsigned int ai_timer1;	/*  timers */
 	unsigned int ai_timer2;
-	struct comedi_subdevice *sub_ai;	// ptr to AI subdevice
-	unsigned char usefifo;	// 1=use fifo
+	struct comedi_subdevice *sub_ai;	/*  ptr to AI subdevice */
+	unsigned char usefifo;	/*  1=use fifo */
 	unsigned int ao_readback[2];
 };
 
 
-static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	// used for gain list programming
+static const unsigned int muxonechan[] = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,	/*  used for gain list programming */
 	0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff
 };
 
@@ -535,10 +535,10 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 
       conv_finish:
 	low = inb(dev-&gt;iobase + PCL818_AD_LO);
-	comedi_buf_put(s-&gt;async, ((inb(dev-&gt;iobase + PCL818_AD_HI) &lt;&lt; 4) | (low &gt;&gt; 4)));	// get one sample
+	comedi_buf_put(s-&gt;async, ((inb(dev-&gt;iobase + PCL818_AD_HI) &lt;&lt; 4) | (low &gt;&gt; 4)));	/*  get one sample */
 	outb(0, dev-&gt;iobase + PCL818_CLRINT);	/* clear INT request */
 
-	if ((low &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	// dropout!
+	if ((low &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	/*  dropout! */
 		rt_printk
 			("comedi: A/D mode1/3 IRQ - channel dropout %x!=%x !\n",
 			(low &amp; 0xf),
@@ -549,7 +549,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_int(int irq, void *d)
 		return IRQ_HANDLED;
 	}
 	if (s-&gt;async-&gt;cur_chan == 0) {
-		// rt_printk("E");
+		/*  rt_printk("E"); */
 		devpriv-&gt;ai_act_scan--;
 	}
 
@@ -577,7 +577,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 
 	disable_dma(devpriv-&gt;dma);
 	devpriv-&gt;next_dma_buf = 1 - devpriv-&gt;next_dma_buf;
-	if ((devpriv-&gt;dma_runs_to_end) &gt; -1 || devpriv-&gt;neverending_ai) {	// switch dma bufs
+	if ((devpriv-&gt;dma_runs_to_end) &gt; -1 || devpriv-&gt;neverending_ai) {	/*  switch dma bufs */
 		set_dma_mode(devpriv-&gt;dma, DMA_MODE_READ);
 		flags = claim_dma_lock();
 		set_dma_addr(devpriv-&gt;dma,
@@ -601,7 +601,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 	bufptr = 0;
 
 	for (i = 0; i &lt; len; i++) {
-		if ((ptr[bufptr] &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	// dropout!
+		if ((ptr[bufptr] &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	/*  dropout! */
 			rt_printk
 				("comedi: A/D mode1/3 DMA - channel dropout %d(card)!=%d(chanlist) at %d !\n",
 				(ptr[bufptr] &amp; 0xf),
@@ -614,7 +614,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 			return IRQ_HANDLED;
 		}
 
-		comedi_buf_put(s-&gt;async, ptr[bufptr++] &gt;&gt; 4);	// get one sample
+		comedi_buf_put(s-&gt;async, ptr[bufptr++] &gt;&gt; 4);	/*  get one sample */
 
 		devpriv-&gt;act_chanlist_pos++;
 		if (devpriv-&gt;act_chanlist_pos &gt;= devpriv-&gt;act_chanlist_len) {
@@ -627,7 +627,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma(int irq, void *d)
 				pcl818_ai_cancel(dev, s);
 				s-&gt;async-&gt;events |= COMEDI_CB_EOA;
 				comedi_event(dev, s);
-				// printk("done int ai13 dma\n");
+				/*  printk("done int ai13 dma\n"); */
 				return IRQ_HANDLED;
 			}
 	}
@@ -651,7 +651,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 	long ofs_dats;
 	short *dmabuf = (short *) devpriv-&gt;dmabuf[0];
 
-	//outb(2,0x378);
+	/* outb(2,0x378); */
 	switch (devpriv-&gt;ai_mode) {
 	case INT_TYPE_AI1_DMA_RTC:
 	case INT_TYPE_AI3_DMA_RTC:
@@ -668,31 +668,31 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 
 		if (top1 != top2)
 			return IRQ_HANDLED;
-		top1 = devpriv-&gt;hwdmasize[0] - top1;	// where is now DMA in buffer
+		top1 = devpriv-&gt;hwdmasize[0] - top1;	/*  where is now DMA in buffer */
 		top1 &gt;&gt;= 1;
-		ofs_dats = top1 - devpriv-&gt;last_top_dma;	// new samples from last call
+		ofs_dats = top1 - devpriv-&gt;last_top_dma;	/*  new samples from last call */
 		if (ofs_dats &lt; 0)
 			ofs_dats = (devpriv-&gt;dmasamplsize) + ofs_dats;
 		if (!ofs_dats)
-			return IRQ_HANDLED;	// exit=no new samples from last call
-		// obsluz data
+			return IRQ_HANDLED;	/*  exit=no new samples from last call */
+		/*  obsluz data */
 		i = devpriv-&gt;last_top_dma - 1;
 		i &amp;= (devpriv-&gt;dmasamplsize - 1);
 
-		if (dmabuf[i] != MAGIC_DMA_WORD) {	// DMA overflow!
+		if (dmabuf[i] != MAGIC_DMA_WORD) {	/*  DMA overflow! */
 			comedi_error(dev, "A/D mode1/3 DMA buffer overflow!");
-			//rt_printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv-&gt;dmasamplsize);
+			/* rt_printk("I %d dmabuf[i] %d %d\n",i,dmabuf[i],devpriv-&gt;dmasamplsize); */
 			pcl818_ai_cancel(dev, s);
 			s-&gt;async-&gt;events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 			comedi_event(dev, s);
 			return IRQ_HANDLED;
 		}
-		//rt_printk("r %ld ",ofs_dats);
+		/* rt_printk("r %ld ",ofs_dats); */
 
 		bufptr = devpriv-&gt;last_top_dma;
 
 		for (i = 0; i &lt; ofs_dats; i++) {
-			if ((dmabuf[bufptr] &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	// dropout!
+			if ((dmabuf[bufptr] &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	/*  dropout! */
 				rt_printk
 					("comedi: A/D mode1/3 DMA - channel dropout %d!=%d !\n",
 					(dmabuf[bufptr] &amp; 0xf),
@@ -705,7 +705,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 				return IRQ_HANDLED;
 			}
 
-			comedi_buf_put(s-&gt;async, dmabuf[bufptr++] &gt;&gt; 4);	// get one sample
+			comedi_buf_put(s-&gt;async, dmabuf[bufptr++] &gt;&gt; 4);	/*  get one sample */
 			bufptr &amp;= (devpriv-&gt;dmasamplsize - 1);
 
 			if (s-&gt;async-&gt;cur_chan == 0) {
@@ -717,7 +717,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 					pcl818_ai_cancel(dev, s);
 					s-&gt;async-&gt;events |= COMEDI_CB_EOA;
 					comedi_event(dev, s);
-					//printk("done int ai13 dma\n");
+					/* printk("done int ai13 dma\n"); */
 					return IRQ_HANDLED;
 				}
 		}
@@ -727,11 +727,11 @@ static irqreturn_t interrupt_pcl818_ai_mode13_dma_rtc(int irq, void *d)
 		bufptr &amp;= (devpriv-&gt;dmasamplsize - 1);
 		dmabuf[bufptr] = MAGIC_DMA_WORD;
 		comedi_event(dev, s);
-		//outb(0,0x378);
+		/* outb(0,0x378); */
 		return IRQ_HANDLED;
 	}
 
-	//outb(0,0x378);
+	/* outb(0,0x378); */
 	return IRQ_HANDLED;
 }
 #endif
@@ -746,7 +746,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 	struct comedi_subdevice *s = dev-&gt;subdevices + 0;
 	int i, len, lo;
 
-	outb(0, dev-&gt;iobase + PCL818_FI_INTCLR);	// clear fifo int request
+	outb(0, dev-&gt;iobase + PCL818_FI_INTCLR);	/*  clear fifo int request */
 
 	lo = inb(dev-&gt;iobase + PCL818_FI_STATUS);
 
@@ -774,7 +774,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 
 	for (i = 0; i &lt; len; i++) {
 		lo = inb(dev-&gt;iobase + PCL818_FI_DATALO);
-		if ((lo &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	// dropout!
+		if ((lo &amp; 0xf) != devpriv-&gt;act_chanlist[devpriv-&gt;act_chanlist_pos]) {	/*  dropout! */
 			rt_printk
 				("comedi: A/D mode1/3 FIFO - channel dropout %d!=%d !\n",
 				(lo &amp; 0xf),
@@ -786,7 +786,7 @@ static irqreturn_t interrupt_pcl818_ai_mode13_fifo(int irq, void *d)
 			return IRQ_HANDLED;
 		}
 
-		comedi_buf_put(s-&gt;async, (lo &gt;&gt; 4) | (inb(dev-&gt;iobase + PCL818_FI_DATAHI) &lt;&lt; 4));	// get one sample
+		comedi_buf_put(s-&gt;async, (lo &gt;&gt; 4) | (inb(dev-&gt;iobase + PCL818_FI_DATAHI) &lt;&lt; 4));	/*  get one sample */
 
 		if (s-&gt;async-&gt;cur_chan == 0) {
 			devpriv-&gt;ai_act_scan--;
@@ -818,7 +818,7 @@ static irqreturn_t interrupt_pcl818(int irq, void *d PT_REGS_ARG)
 		comedi_error(dev, "premature interrupt");
 		return IRQ_HANDLED;
 	}
-	//rt_printk("I\n");
+	/* rt_printk("I\n"); */
 
 	switch (devpriv-&gt;ai_mode) {
 	case INT_TYPE_AI1_DMA:
@@ -881,12 +881,12 @@ static void pcl818_ai_mode13dma_int(int mode, struct comedi_device * dev,
 	unsigned int bytes;
 
 	rt_printk("mode13dma_int, mode: %d\n", mode);
-	disable_dma(devpriv-&gt;dma);	// disable dma
+	disable_dma(devpriv-&gt;dma);	/*  disable dma */
 	bytes = devpriv-&gt;hwdmasize[0];
 	if (!devpriv-&gt;neverending_ai) {
-		bytes = devpriv-&gt;ai_n_chan * devpriv-&gt;ai_scans * sizeof(short);	// how many
-		devpriv-&gt;dma_runs_to_end = bytes / devpriv-&gt;hwdmasize[0];	// how many DMA pages we must fiil
-		devpriv-&gt;last_dma_run = bytes % devpriv-&gt;hwdmasize[0];	//on last dma transfer must be moved
+		bytes = devpriv-&gt;ai_n_chan * devpriv-&gt;ai_scans * sizeof(short);	/*  how many */
+		devpriv-&gt;dma_runs_to_end = bytes / devpriv-&gt;hwdmasize[0];	/*  how many DMA pages we must fiil */
+		devpriv-&gt;last_dma_run = bytes % devpriv-&gt;hwdmasize[0];	/* on last dma transfer must be moved */
 		devpriv-&gt;dma_runs_to_end--;
 		if (devpriv-&gt;dma_runs_to_end &gt;= 0)
 			bytes = devpriv-&gt;hwdmasize[0];
@@ -928,7 +928,7 @@ static void pcl818_ai_mode13dma_rtc(int mode, struct comedi_device * dev,
 	set_dma_count(devpriv-&gt;dma, devpriv-&gt;hwdmasize[0]);
 	release_dma_lock(flags);
 	enable_dma(devpriv-&gt;dma);
-	devpriv-&gt;last_top_dma = 0;	//devpriv-&gt;hwdmasize[0];
+	devpriv-&gt;last_top_dma = 0;	/* devpriv-&gt;hwdmasize[0]; */
 	pole = (short *) devpriv-&gt;dmabuf[0];
 	devpriv-&gt;dmasamplsize = devpriv-&gt;hwdmasize[0] / 2;
 	pole[devpriv-&gt;dmasamplsize - 1] = MAGIC_DMA_WORD;
@@ -972,7 +972,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	if (devpriv-&gt;irq_blocked)
 		return -EBUSY;
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	seglen = check_channel_list(dev, s, devpriv-&gt;ai_chanlist,
 		devpriv-&gt;ai_n_chan);
@@ -992,7 +992,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	devpriv-&gt;dma_runs_to_end = 0;
 
 	if ((devpriv-&gt;ai_scans == 0) || (devpriv-&gt;ai_scans == -1))
-		devpriv-&gt;neverending_ai = 1;	//well, user want neverending
+		devpriv-&gt;neverending_ai = 1;	/* well, user want neverending */
 
 	if (mode == 1) {
 		i8253_cascade_ns_to_timer(devpriv-&gt;i8253_osc_base, &amp;divisor1,
@@ -1010,7 +1010,7 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 	outb(0, dev-&gt;iobase + PCL818_CNTENABLE);	/* enable pacer */
 
 	switch (devpriv-&gt;dma) {
-	case 1:		// DMA
+	case 1:		/*  DMA */
 	case 3:
 		if (devpriv-&gt;dma_rtc == 0) {
 			pcl818_ai_mode13dma_int(mode, dev, s);
@@ -1025,8 +1025,8 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 		}
 #endif
 		break;
-	case 0:		// IRQ
-		// rt_printk("IRQ\n");
+	case 0:		/*  IRQ */
+		/*  rt_printk("IRQ\n"); */
 		if (mode == 1) {
 			devpriv-&gt;ai_mode = INT_TYPE_AI1_INT;
 			outb(0x83 | (dev-&gt;irq &lt;&lt; 4), dev-&gt;iobase + PCL818_CONTROL);	/* Pacer+IRQ */
@@ -1035,8 +1035,8 @@ static int pcl818_ai_cmd_mode(int mode, struct comedi_device * dev,
 			outb(0x82 | (dev-&gt;irq &lt;&lt; 4), dev-&gt;iobase + PCL818_CONTROL);	/* Ext trig+IRQ */
 		};
 		break;
-	case -1:		// FIFO
-		outb(1, dev-&gt;iobase + PCL818_FI_ENABLE);	// enable FIFO
+	case -1:		/*  FIFO */
+		outb(1, dev-&gt;iobase + PCL818_FI_ENABLE);	/*  enable FIFO */
 		if (mode == 1) {
 			devpriv-&gt;ai_mode = INT_TYPE_AI1_FIFO;
 			outb(0x03, dev-&gt;iobase + PCL818_CONTROL);	/* Pacer */
@@ -1080,7 +1080,7 @@ static int pcl818_ao_mode13(int mode, struct comedi_device * dev, struct comedi_
 	if (devpriv-&gt;irq_blocked)
 		return -EBUSY;
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
 	devpriv-&gt;int13_act_scan = it-&gt;n;
 	devpriv-&gt;int13_act_chan = 0;
@@ -1175,30 +1175,34 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	if (n_chan &gt; 1) {
-		// first channel is everytime ok
+		/*  first channel is everytime ok */
 		chansegment[0] = chanlist[0];
-		// build part of chanlist
+		/*  build part of chanlist */
 		for (i = 1, seglen = 1; i &lt; n_chan; i++, seglen++) {
-			// rt_printk("%d. %d %d\n",i,CR_CHAN(it-&gt;chanlist[i]),CR_RANGE(it-&gt;chanlist[i]));
-			// we detect loop, this must by finish
+
+			/* rt_printk("%d. %d * %d\n",i,
+			 * CR_CHAN(it-&gt;chanlist[i]),CR_RANGE(it-&gt;chanlist[i]));*/
+
+			/* we detect loop, this must by finish */
+
 			if (chanlist[0] == chanlist[i])
 				break;
 			nowmustbechan =
 				(CR_CHAN(chansegment[i - 1]) + 1) % s-&gt;n_chan;
-			if (nowmustbechan != CR_CHAN(chanlist[i])) {	// channel list isn't continous :-(
+			if (nowmustbechan != CR_CHAN(chanlist[i])) {	/*  channel list isn't continous :-( */
 				rt_printk
 					("comedi%d: pcl818: channel list must be continous! chanlist[%i]=%d but must be %d or %d!\n",
 					dev-&gt;minor, i, CR_CHAN(chanlist[i]),
 					nowmustbechan, CR_CHAN(chanlist[0]));
 				return 0;
 			}
-			// well, this is next correct channel in list
+			/*  well, this is next correct channel in list */
 			chansegment[i] = chanlist[i];
 		}
 
-		// check whole chanlist
+		/*  check whole chanlist */
 		for (i = 0, segpos = 0; i &lt; n_chan; i++) {
-			//rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it-&gt;chanlist[i]),CR_RANGE(it-&gt;chanlist[i]));
+			/* rt_printk("%d %d=%d %d\n",CR_CHAN(chansegment[i%seglen]),CR_RANGE(chansegment[i%seglen]),CR_CHAN(it-&gt;chanlist[i]),CR_RANGE(it-&gt;chanlist[i])); */
 			if (chanlist[i] != chansegment[i % seglen]) {
 				rt_printk
 					("comedi%d: pcl818: bad channel or range number! chanlist[%i]=%d,%d,%d and not %d,%d,%d!\n",
@@ -1208,7 +1212,7 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 					CR_CHAN(chanlist[i % seglen]),
 					CR_RANGE(chanlist[i % seglen]),
 					CR_AREF(chansegment[i % seglen]));
-				return 0;	// chan/gain list is strange
+				return 0;	/*  chan/gain list is strange */
 			}
 		}
 	} else {
@@ -1226,7 +1230,7 @@ static void setup_channel_list(struct comedi_device * dev, struct comedi_subdevi
 	devpriv-&gt;act_chanlist_len = seglen;
 	devpriv-&gt;act_chanlist_pos = 0;
 
-	for (i = 0; i &lt; seglen; i++) {	// store range list to card
+	for (i = 0; i &lt; seglen; i++) {	/*  store range list to card */
 		devpriv-&gt;act_chanlist[i] = CR_CHAN(chanlist[i]);
 		outb(muxonechan[CR_CHAN(chanlist[i])], dev-&gt;iobase + PCL818_MUX);	/* select channel */
 		outb(CR_RANGE(chanlist[i]), dev-&gt;iobase + PCL818_RANGE);	/* select gain */
@@ -1391,7 +1395,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	if (cmd-&gt;chanlist) {
 		if (!check_channel_list(dev, s, cmd-&gt;chanlist,
 				cmd-&gt;chanlist_len))
-			return 5;	// incorrect channels list
+			return 5;	/*  incorrect channels list */
 	}
 
 	return 0;
@@ -1420,14 +1424,14 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 		devpriv-&gt;ai_scans = 0;
 	}
 
-	if (cmd-&gt;scan_begin_src == TRIG_FOLLOW) {	// mode 1, 3
-		if (cmd-&gt;convert_src == TRIG_TIMER) {	// mode 1
+	if (cmd-&gt;scan_begin_src == TRIG_FOLLOW) {	/*  mode 1, 3 */
+		if (cmd-&gt;convert_src == TRIG_TIMER) {	/*  mode 1 */
 			devpriv-&gt;ai_timer1 = cmd-&gt;convert_arg;
 			retval = pcl818_ai_cmd_mode(1, dev, s);
 			rt_printk("pcl818_ai_cmd() end\n");
 			return retval;
 		}
-		if (cmd-&gt;convert_src == TRIG_EXT) {	// mode 3
+		if (cmd-&gt;convert_src == TRIG_EXT) {	/*  mode 3 */
 			return pcl818_ai_cmd_mode(3, dev, s);
 		}
 	}
@@ -1450,7 +1454,7 @@ static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 #ifdef unused
 		case INT_TYPE_AI1_DMA_RTC:
 		case INT_TYPE_AI3_DMA_RTC:
-			set_rtc_irq_bit(0);	// stop RTC
+			set_rtc_irq_bit(0);	/*  stop RTC */
 			del_timer(&amp;devpriv-&gt;rtc_irq_timer);
 #endif
 		case INT_TYPE_AI1_DMA:
@@ -1476,7 +1480,7 @@ static int pcl818_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 			inb(dev-&gt;iobase + PCL818_AD_HI);
 			outb(0, dev-&gt;iobase + PCL818_CLRINT);	/* clear INT request */
 			outb(0, dev-&gt;iobase + PCL818_CONTROL);	/* Stop A/D */
-			if (devpriv-&gt;usefifo) {	// FIFO shutdown
+			if (devpriv-&gt;usefifo) {	/*  FIFO shutdown */
 				outb(0, dev-&gt;iobase + PCL818_FI_INTCLR);
 				outb(0, dev-&gt;iobase + PCL818_FI_FLUSH);
 				outb(0, dev-&gt;iobase + PCL818_FI_ENABLE);
@@ -1502,18 +1506,18 @@ static int pcl818_check(unsigned long iobase)
 	outb(0x00, iobase + PCL818_MUX);
 	comedi_udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x00)
-		return 1;	//there isn't card
+		return 1;	/* there isn't card */
 	outb(0x55, iobase + PCL818_MUX);
 	comedi_udelay(1);
 	if (inb(iobase + PCL818_MUX) != 0x55)
-		return 1;	//there isn't card
+		return 1;	/* there isn't card */
 	outb(0x00, iobase + PCL818_MUX);
 	comedi_udelay(1);
 	outb(0x18, iobase + PCL818_CONTROL);
 	comedi_udelay(1);
 	if (inb(iobase + PCL818_CONTROL) != 0x18)
-		return 1;	//there isn't card
-	return 0;		// ok, card exist
+		return 1;	/* there isn't card */
+	return 0;		/*  ok, card exist */
 }
 
 /*
@@ -1522,15 +1526,15 @@ static int pcl818_check(unsigned long iobase)
 */
 static void pcl818_reset(struct comedi_device * dev)
 {
-	if (devpriv-&gt;usefifo) {	// FIFO shutdown
+	if (devpriv-&gt;usefifo) {	/*  FIFO shutdown */
 		outb(0, dev-&gt;iobase + PCL818_FI_INTCLR);
 		outb(0, dev-&gt;iobase + PCL818_FI_FLUSH);
 		outb(0, dev-&gt;iobase + PCL818_FI_ENABLE);
 	}
-	outb(0, dev-&gt;iobase + PCL818_DA_LO);	// DAC=0V
+	outb(0, dev-&gt;iobase + PCL818_DA_LO);	/*  DAC=0V */
 	outb(0, dev-&gt;iobase + PCL818_DA_HI);
 	comedi_udelay(1);
-	outb(0, dev-&gt;iobase + PCL818_DO_HI);	// DO=$0000
+	outb(0, dev-&gt;iobase + PCL818_DO_HI);	/*  DO=$0000 */
 	outb(0, dev-&gt;iobase + PCL818_DO_LO);
 	comedi_udelay(1);
 	outb(0, dev-&gt;iobase + PCL818_CONTROL);
@@ -1643,7 +1647,7 @@ static int rtc_setfreq_irq(int freq)
 */
 static void free_resources(struct comedi_device * dev)
 {
-	//rt_printk("free_resource()\n");
+	/* rt_printk("free_resource()\n"); */
 	if (dev-&gt;private) {
 		pcl818_ai_cancel(dev, devpriv-&gt;sub_ai);
 		pcl818_reset(dev);
@@ -1670,7 +1674,7 @@ static void free_resources(struct comedi_device * dev)
 		free_irq(dev-&gt;irq, dev);
 	if (dev-&gt;iobase)
 		release_region(dev-&gt;iobase, devpriv-&gt;io_range);
-	//rt_printk("free_resource() end\n");
+	/* rt_printk("free_resource() end\n"); */
 }
 
 /*
@@ -1695,7 +1699,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 	printk("comedi%d: pcl818:  board=%s, ioport=0x%03lx",
 		dev-&gt;minor, this_board-&gt;name, iobase);
 	devpriv-&gt;io_range = this_board-&gt;io_range;
-	if ((this_board-&gt;fifo) &amp;&amp; (it-&gt;options[2] == -1)) {	// we've board with FIFO and we want to use FIFO
+	if ((this_board-&gt;fifo) &amp;&amp; (it-&gt;options[2] == -1)) {	/*  we've board with FIFO and we want to use FIFO */
 		devpriv-&gt;io_range = PCLx1xFIFO_RANGE;
 		devpriv-&gt;usefifo = 1;
 	}
@@ -1750,7 +1754,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 #ifdef unused
 	/* grab RTC for DMA operations */
 	devpriv-&gt;dma_rtc = 0;
-	if (it-&gt;options[2] &gt; 0) {	// we want to use DMA
+	if (it-&gt;options[2] &gt; 0) {	/*  we want to use DMA */
 		if (RTC_lock == 0) {
 			if (!request_region(RTC_PORT(0), RTC_IO_EXTENT,
 					"pcl818 (RTC)"))
@@ -1809,8 +1813,8 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 		devpriv-&gt;dmapages[0] = pages;
 		devpriv-&gt;hwdmaptr[0] = virt_to_bus((void *)devpriv-&gt;dmabuf[0]);
 		devpriv-&gt;hwdmasize[0] = (1 &lt;&lt; pages) * PAGE_SIZE;
-		//rt_printk("%d %d %ld, ",devpriv-&gt;dmapages[0],devpriv-&gt;hwdmasize[0],PAGE_SIZE);
-		if (devpriv-&gt;dma_rtc == 0) {	// we must do duble buff :-(
+		/* rt_printk("%d %d %ld, ",devpriv-&gt;dmapages[0],devpriv-&gt;hwdmasize[0],PAGE_SIZE); */
+		if (devpriv-&gt;dma_rtc == 0) {	/*  we must do duble buff :-( */
 			devpriv-&gt;dmabuf[1] = __get_dma_pages(GFP_KERNEL, pages);
 			if (!devpriv-&gt;dmabuf[1]) {
 				rt_printk
@@ -1858,7 +1862,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
 		}
 		if (this_board-&gt;is_818) {
 			if ((it-&gt;options[4] == 1) || (it-&gt;options[4] == 10))
-				s-&gt;range_table = &amp;range_pcl818l_h_ai;	// secondary range list jumper selectable
+				s-&gt;range_table = &amp;range_pcl818l_h_ai;	/*  secondary range list jumper selectable */
 		} else {
 			switch (it-&gt;options[4]) {
 			case 0:
@@ -1982,7 +1986,7 @@ static int pcl818_attach(struct comedi_device * dev, struct comedi_devconfig * i
  */
 static int pcl818_detach(struct comedi_device * dev)
 {
-	//  rt_printk("comedi%d: pcl818: remove\n", dev-&gt;minor);
+	/*   rt_printk("comedi%d: pcl818: remove\n", dev-&gt;minor); */
 	free_resources(dev);
 	return 0;
 }</pre><hr><pre>commit a351ecf3081f94796cf915dba820f9f5e62c43cf
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:29:40 2009 -0400

    Staging: comedi: remove C99 comments in das1800.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/das1800.c b/drivers/staging/comedi/drivers/das1800.c
index cd4cd4e6a79b..60724600607c 100644
--- a/drivers/staging/comedi/drivers/das1800.c
+++ b/drivers/staging/comedi/drivers/das1800.c
@@ -108,12 +108,12 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #include "8253.h"
 #include "comedi_fc.h"
 
-// misc. defines
-#define DAS1800_SIZE           16	//uses 16 io addresses
-#define FIFO_SIZE              1024	// 1024 sample fifo
-#define TIMER_BASE             200	// 5 Mhz master clock
-#define UNIPOLAR               0x4	// bit that determines whether input range is uni/bipolar
-#define DMA_BUF_SIZE           0x1ff00	// size in bytes of dma buffers
+/* misc. defines */
+#define DAS1800_SIZE           16	/* uses 16 io addresses */
+#define FIFO_SIZE              1024	/*  1024 sample fifo */
+#define TIMER_BASE             200	/*  5 Mhz master clock */
+#define UNIPOLAR               0x4	/*  bit that determines whether input range is uni/bipolar */
+#define DMA_BUF_SIZE           0x1ff00	/*  size in bytes of dma buffers */
 
 /* Registers for the das1800 */
 #define DAS1800_FIFO            0x0
@@ -138,7 +138,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #define   DMA_CH5_CH6             0x5
 #define   DMA_CH6_CH7             0x6
 #define   DMA_CH7_CH5             0x7
-#define   DMA_ENABLED             0x3	//mask used to determine if dma is enabled
+#define   DMA_ENABLED             0x3	/* mask used to determine if dma is enabled */
 #define   DMA_DUAL                0x4
 #define   IRQ3                    0x8
 #define   IRQ5                    0x10
@@ -156,7 +156,7 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #define   SD                      0x40
 #define   UB                      0x80
 #define DAS1800_STATUS          0x7
-// bits that prevent interrupt status bits (and CVEN) from being cleared on write
+/* bits that prevent interrupt status bits (and CVEN) from being cleared on write */
 #define   CLEAR_INTR_MASK         (CVEN_MASK | 0x1f)
 #define   INT                     0x1
 #define   DMATC                   0x2
@@ -164,14 +164,14 @@ Unipolar and bipolar ranges cannot be mixed in the channel/gain list.
 #define   OVF                     0x10
 #define   FHF                     0x20
 #define   FNE                     0x40
-#define   CVEN_MASK               0x40	// masks CVEN on write
+#define   CVEN_MASK               0x40	/*  masks CVEN on write */
 #define   CVEN                    0x80
 #define DAS1800_BURST_LENGTH    0x8
 #define DAS1800_BURST_RATE      0x9
 #define DAS1800_QRAM_ADDRESS    0xa
 #define DAS1800_COUNTER         0xc
 
-#define IOBASE2                   0x400	//offset of additional ioports used on 'ao' cards
+#define IOBASE2                   0x400	/* offset of additional ioports used on 'ao' cards */
 
 enum {
 	das1701st, das1701st_da, das1702st, das1702st_da, das1702hr,
@@ -212,7 +212,7 @@ static int das1800_set_frequency(struct comedi_device * dev);
 static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode);
 static unsigned int suggest_transfer_size(struct comedi_cmd * cmd);
 
-// analog input ranges
+/* analog input ranges */
 static const struct comedi_lrange range_ai_das1801 = {
 	8,
 	{
@@ -485,7 +485,7 @@ struct das1800_private {
 
 #define devpriv ((struct das1800_private *)dev-&gt;private)
 
-// analog out range for boards with basic analog out
+/* analog out range for boards with basic analog out */
 static const struct comedi_lrange range_ao_1 = {
 	1,
 	{
@@ -493,7 +493,7 @@ static const struct comedi_lrange range_ao_1 = {
 		}
 };
 
-// analog out range for 'ao' boards
+/* analog out range for 'ao' boards */
 /*
 static const struct comedi_lrange range_ao_2 = {
 	2,
@@ -525,26 +525,26 @@ static int das1800_init_dma(struct comedi_device * dev, unsigned int dma0,
 {
 	unsigned long flags;
 
-	// need an irq to do dma
+	/*  need an irq to do dma */
 	if (dev-&gt;irq &amp;&amp; dma0) {
-		//encode dma0 and dma1 into 2 digit hexadecimal for switch
+		/* encode dma0 and dma1 into 2 digit hexadecimal for switch */
 		switch ((dma0 &amp; 0x7) | (dma1 &lt;&lt; 4)) {
-		case 0x5:	// dma0 == 5
+		case 0x5:	/*  dma0 == 5 */
 			devpriv-&gt;dma_bits |= DMA_CH5;
 			break;
-		case 0x6:	// dma0 == 6
+		case 0x6:	/*  dma0 == 6 */
 			devpriv-&gt;dma_bits |= DMA_CH6;
 			break;
-		case 0x7:	// dma0 == 7
+		case 0x7:	/*  dma0 == 7 */
 			devpriv-&gt;dma_bits |= DMA_CH7;
 			break;
-		case 0x65:	// dma0 == 5, dma1 == 6
+		case 0x65:	/*  dma0 == 5, dma1 == 6 */
 			devpriv-&gt;dma_bits |= DMA_CH5_CH6;
 			break;
-		case 0x76:	// dma0 == 6, dma1 == 7
+		case 0x76:	/*  dma0 == 6, dma1 == 7 */
 			devpriv-&gt;dma_bits |= DMA_CH6_CH7;
 			break;
-		case 0x57:	// dma0 == 7, dma1 == 5
+		case 0x57:	/*  dma0 == 7, dma1 == 5 */
 			devpriv-&gt;dma_bits |= DMA_CH7_CH5;
 			break;
 		default:
@@ -638,7 +638,7 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 	dev-&gt;board_ptr = das1800_boards + board;
 	dev-&gt;board_name = thisboard-&gt;name;
 
-	// if it is an 'ao' board with fancy analog out then we need extra io ports
+	/*  if it is an 'ao' board with fancy analog out then we need extra io ports */
 	if (thisboard-&gt;ao_ability == 2) {
 		iobase2 = iobase + IOBASE2;
 		if (!request_region(iobase2, DAS1800_SIZE,
@@ -659,7 +659,7 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 	}
 	dev-&gt;irq = irq;
 
-	// set bits that tell card which irq to use
+	/*  set bits that tell card which irq to use */
 	switch (irq) {
 	case 0:
 		break;
@@ -751,12 +751,12 @@ static int das1800_attach(struct comedi_device * dev, struct comedi_devconfig *
 
 	das1800_cancel(dev, dev-&gt;read_subdev);
 
-	// initialize digital out channels
+	/*  initialize digital out channels */
 	outb(devpriv-&gt;do_bits, dev-&gt;iobase + DAS1800_DIGITAL);
 
-	// initialize analog out channels
+	/*  initialize analog out channels */
 	if (thisboard-&gt;ao_ability == 1) {
-		// select 'update' dac channel for baseAddress + 0x0
+		/*  select 'update' dac channel for baseAddress + 0x0 */
 		outb(DAC(thisboard-&gt;ao_n_chan - 1),
 			dev-&gt;iobase + DAS1800_SELECT);
 		outw(devpriv-&gt;ao_update_bits, dev-&gt;iobase + DAS1800_DAC);
@@ -871,7 +871,7 @@ static int das1800_ai_poll(struct comedi_device * dev, struct comedi_subdevice *
 {
 	unsigned long flags;
 
-	// prevent race with interrupt handler
+	/*  prevent race with interrupt handler */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	das1800_ai_handler(dev);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
@@ -901,14 +901,14 @@ static irqreturn_t das1800_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 	/* clear the interrupt status bit INT */
 	outb(CLEAR_INTR_MASK &amp; ~INT, dev-&gt;iobase + DAS1800_STATUS);
-	// handle interrupt
+	/*  handle interrupt */
 	das1800_ai_handler(dev);
 
 	spin_unlock(&amp;dev-&gt;spinlock);
 	return IRQ_HANDLED;
 }
 
-// the guts of the interrupt handler, that is shared with das1800_ai_poll
+/* the guts of the interrupt handler, that is shared with das1800_ai_poll */
 static void das1800_ai_handler(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev-&gt;subdevices + 0;	/* analog input subdevice */
@@ -917,22 +917,22 @@ static void das1800_ai_handler(struct comedi_device * dev)
 	unsigned int status = inb(dev-&gt;iobase + DAS1800_STATUS);
 
 	async-&gt;events = 0;
-	// select adc for base address + 0
+	/*  select adc for base address + 0 */
 	outb(ADC, dev-&gt;iobase + DAS1800_SELECT);
-	// dma buffer full
+	/*  dma buffer full */
 	if (devpriv-&gt;irq_dma_bits &amp; DMA_ENABLED) {
-		// look for data from dma transfer even if dma terminal count hasn't happened yet
+		/*  look for data from dma transfer even if dma terminal count hasn't happened yet */
 		das1800_handle_dma(dev, s, status);
-	} else if (status &amp; FHF) {	// if fifo half full
+	} else if (status &amp; FHF) {	/*  if fifo half full */
 		das1800_handle_fifo_half_full(dev, s);
-	} else if (status &amp; FNE) {	// if fifo not empty
+	} else if (status &amp; FNE) {	/*  if fifo not empty */
 		das1800_handle_fifo_not_empty(dev, s);
 	}
 
 	async-&gt;events |= COMEDI_CB_BLOCK;
 	/* if the card's fifo has overflowed */
 	if (status &amp; OVF) {
-		// clear OVF interrupt bit
+		/*  clear OVF interrupt bit */
 		outb(CLEAR_INTR_MASK &amp; ~OVF, dev-&gt;iobase + DAS1800_STATUS);
 		comedi_error(dev, "DAS1800 FIFO overflow");
 		das1800_cancel(dev, s);
@@ -940,19 +940,19 @@ static void das1800_ai_handler(struct comedi_device * dev)
 		comedi_event(dev, s);
 		return;
 	}
-	// stop taking data if appropriate
+	/*  stop taking data if appropriate */
 	/* stop_src TRIG_EXT */
 	if (status &amp; CT0TC) {
-		// clear CT0TC interrupt bit
+		/*  clear CT0TC interrupt bit */
 		outb(CLEAR_INTR_MASK &amp; ~CT0TC, dev-&gt;iobase + DAS1800_STATUS);
-		// make sure we get all remaining data from board before quitting
+		/*  make sure we get all remaining data from board before quitting */
 		if (devpriv-&gt;irq_dma_bits &amp; DMA_ENABLED)
 			das1800_flush_dma(dev, s);
 		else
 			das1800_handle_fifo_not_empty(dev, s);
 		das1800_cancel(dev, s);	/* disable hardware conversions */
 		async-&gt;events |= COMEDI_CB_EOA;
-	} else if (cmd-&gt;stop_src == TRIG_COUNT &amp;&amp; devpriv-&gt;count == 0) {	// stop_src TRIG_COUNT
+	} else if (cmd-&gt;stop_src == TRIG_COUNT &amp;&amp; devpriv-&gt;count == 0) {	/*  stop_src TRIG_COUNT */
 		das1800_cancel(dev, s);	/* disable hardware conversions */
 		async-&gt;events |= COMEDI_CB_EOA;
 	}
@@ -971,7 +971,7 @@ static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevi
 	flags = claim_dma_lock();
 	das1800_flush_dma_channel(dev, s, devpriv-&gt;dma_current,
 		devpriv-&gt;dma_current_buf);
-	// re-enable  dma channel
+	/*  re-enable  dma channel */
 	set_dma_addr(devpriv-&gt;dma_current,
 		virt_to_bus(devpriv-&gt;dma_current_buf));
 	set_dma_count(devpriv-&gt;dma_current, devpriv-&gt;dma_transfer_size);
@@ -979,11 +979,11 @@ static void das1800_handle_dma(struct comedi_device * dev, struct comedi_subdevi
 	release_dma_lock(flags);
 
 	if (status &amp; DMATC) {
-		// clear DMATC interrupt bit
+		/*  clear DMATC interrupt bit */
 		outb(CLEAR_INTR_MASK &amp; ~DMATC, dev-&gt;iobase + DAS1800_STATUS);
-		// switch dma channels for next time, if appropriate
+		/*  switch dma channels for next time, if appropriate */
 		if (dual_dma) {
-			// read data from the other channel next time
+			/*  read data from the other channel next time */
 			if (devpriv-&gt;dma_current == devpriv-&gt;dma0) {
 				devpriv-&gt;dma_current = devpriv-&gt;dma1;
 				devpriv-&gt;dma_current_buf = devpriv-&gt;ai_buf1;
@@ -1035,7 +1035,7 @@ static void das1800_flush_dma_channel(struct comedi_device * dev, struct comedi_
 	 * get set correctly */
 	clear_dma_ff(channel);
 
-	// figure out how many points to read
+	/*  figure out how many points to read */
 	num_bytes = devpriv-&gt;dma_transfer_size - get_dma_residue(channel);
 	num_samples = num_bytes / sizeof(short);
 
@@ -1063,7 +1063,7 @@ static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevic
 		devpriv-&gt;dma_current_buf);
 
 	if (dual_dma) {
-		// switch to other channel and flush it
+		/*  switch to other channel and flush it */
 		if (devpriv-&gt;dma_current == devpriv-&gt;dma0) {
 			devpriv-&gt;dma_current = devpriv-&gt;dma1;
 			devpriv-&gt;dma_current_buf = devpriv-&gt;ai_buf1;
@@ -1077,7 +1077,7 @@ static void das1800_flush_dma(struct comedi_device * dev, struct comedi_subdevic
 
 	release_dma_lock(flags);
 
-	// get any remaining samples in fifo
+	/*  get any remaining samples in fifo */
 	das1800_handle_fifo_not_empty(dev, s);
 
 	return;
@@ -1180,7 +1180,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	// uniqueness check
+	/*  uniqueness check */
 	if (cmd-&gt;start_src != TRIG_NOW &amp;&amp; cmd-&gt;start_src != TRIG_EXT)
 		err++;
 	if (cmd-&gt;scan_begin_src != TRIG_FOLLOW &amp;&amp;
@@ -1192,7 +1192,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 	if (cmd-&gt;stop_src != TRIG_COUNT &amp;&amp;
 		cmd-&gt;stop_src != TRIG_NONE &amp;&amp; cmd-&gt;stop_src != TRIG_EXT)
 		err++;
-	//compatibility check
+	/* compatibility check */
 	if (cmd-&gt;scan_begin_src != TRIG_FOLLOW &amp;&amp;
 		cmd-&gt;convert_src != TRIG_TIMER)
 		err++;
@@ -1244,7 +1244,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 	/* step 4: fix up any arguments */
 
 	if (cmd-&gt;convert_src == TRIG_TIMER) {
-		// if we are not in burst mode
+		/*  if we are not in burst mode */
 		if (cmd-&gt;scan_begin_src == TRIG_FOLLOW) {
 			tmp_arg = cmd-&gt;convert_arg;
 			/* calculate counter values that give desired timing */
@@ -1255,9 +1255,9 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 			if (tmp_arg != cmd-&gt;convert_arg)
 				err++;
 		}
-		// if we are in burst mode
+		/*  if we are in burst mode */
 		else {
-			// check that convert_arg is compatible
+			/*  check that convert_arg is compatible */
 			tmp_arg = cmd-&gt;convert_arg;
 			cmd-&gt;convert_arg =
 				burst_convert_arg(cmd-&gt;convert_arg,
@@ -1266,7 +1266,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 				err++;
 
 			if (cmd-&gt;scan_begin_src == TRIG_TIMER) {
-				// if scans are timed faster than conversion rate allows
+				/*  if scans are timed faster than conversion rate allows */
 				if (cmd-&gt;convert_arg * cmd-&gt;chanlist_len &gt;
 					cmd-&gt;scan_begin_arg) {
 					cmd-&gt;scan_begin_arg =
@@ -1290,7 +1290,7 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 	if (err)
 		return 4;
 
-	// make sure user is not trying to mix unipolar and bipolar ranges
+	/*  make sure user is not trying to mix unipolar and bipolar ranges */
 	if (cmd-&gt;chanlist) {
 		unipolar = CR_RANGE(cmd-&gt;chanlist[0]) &amp; UNIPOLAR;
 		for (i = 1; i &lt; cmd-&gt;chanlist_len; i++) {
@@ -1311,14 +1311,14 @@ static int das1800_ai_do_cmdtest(struct comedi_device * dev, struct comedi_subde
 
 /* analog input cmd interface */
 
-// first, some utility functions used in the main ai_do_cmd()
+/* first, some utility functions used in the main ai_do_cmd() */
 
-// returns appropriate bits for control register a, depending on command
+/* returns appropriate bits for control register a, depending on command */
 static int control_a_bits(struct comedi_cmd cmd)
 {
 	int control_a;
 
-	control_a = FFEN;	//enable fifo
+	control_a = FFEN;	/* enable fifo */
 	if (cmd.stop_src == TRIG_EXT) {
 		control_a |= ATEN;
 	}
@@ -1336,7 +1336,7 @@ static int control_a_bits(struct comedi_cmd cmd)
 	return control_a;
 }
 
-// returns appropriate bits for control register c, depending on command
+/* returns appropriate bits for control register c, depending on command */
 static int control_c_bits(struct comedi_cmd cmd)
 {
 	int control_c;
@@ -1346,7 +1346,7 @@ static int control_c_bits(struct comedi_cmd cmd)
 	 * select unipolar / bipolar
 	 */
 	aref = CR_AREF(cmd.chanlist[0]);
-	control_c = UQEN;	//enable upper qram addresses
+	control_c = UQEN;	/* enable upper qram addresses */
 	if (aref != AREF_DIFF)
 		control_c |= SD;
 	if (aref == AREF_COMMON)
@@ -1355,7 +1355,7 @@ static int control_c_bits(struct comedi_cmd cmd)
 	if (CR_RANGE(cmd.chanlist[0]) &amp; UNIPOLAR)
 		control_c |= UB;
 	switch (cmd.scan_begin_src) {
-	case TRIG_FOLLOW:	// not in burst mode
+	case TRIG_FOLLOW:	/*  not in burst mode */
 		switch (cmd.convert_src) {
 		case TRIG_TIMER:
 			/* trig on cascaded counters */
@@ -1370,11 +1370,11 @@ static int control_c_bits(struct comedi_cmd cmd)
 		}
 		break;
 	case TRIG_TIMER:
-		// burst mode with internal pacer clock
+		/*  burst mode with internal pacer clock */
 		control_c |= BMDE | IPCLK;
 		break;
 	case TRIG_EXT:
-		// burst mode with external trigger
+		/*  burst mode with external trigger */
 		control_c |= BMDE | XPCLK;
 		break;
 	default:
@@ -1384,12 +1384,12 @@ static int control_c_bits(struct comedi_cmd cmd)
 	return control_c;
 }
 
-// sets up counters
+/* sets up counters */
 static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 {
-	// setup cascaded counters for conversion/scan frequency
+	/*  setup cascaded counters for conversion/scan frequency */
 	switch (cmd.scan_begin_src) {
-	case TRIG_FOLLOW:	// not in burst mode
+	case TRIG_FOLLOW:	/*  not in burst mode */
 		if (cmd.convert_src == TRIG_TIMER) {
 			/* set conversion frequency */
 			i8253_cascade_ns_to_timer_2div(TIMER_BASE,
@@ -1401,7 +1401,7 @@ static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 			}
 		}
 		break;
-	case TRIG_TIMER:	// in burst mode
+	case TRIG_TIMER:	/*  in burst mode */
 		/* set scan frequency */
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE, &amp;(devpriv-&gt;divisor1),
 			&amp;(devpriv-&gt;divisor2), &amp;(cmd.scan_begin_arg),
@@ -1414,16 +1414,16 @@ static int setup_counters(struct comedi_device * dev, struct comedi_cmd cmd)
 		break;
 	}
 
-	// setup counter 0 for 'about triggering'
+	/*  setup counter 0 for 'about triggering' */
 	if (cmd.stop_src == TRIG_EXT) {
-		// load counter 0 in mode 0
+		/*  load counter 0 in mode 0 */
 		i8254_load(dev-&gt;iobase + DAS1800_COUNTER, 0, 0, 1, 0);
 	}
 
 	return 0;
 }
 
-// sets up dma
+/* sets up dma */
 static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 {
 	unsigned long lock_flags;
@@ -1440,19 +1440,19 @@ static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 	 * count and address get set correctly */
 	clear_dma_ff(devpriv-&gt;dma0);
 	set_dma_addr(devpriv-&gt;dma0, virt_to_bus(devpriv-&gt;ai_buf0));
-	// set appropriate size of transfer
+	/*  set appropriate size of transfer */
 	set_dma_count(devpriv-&gt;dma0, devpriv-&gt;dma_transfer_size);
 	devpriv-&gt;dma_current = devpriv-&gt;dma0;
 	devpriv-&gt;dma_current_buf = devpriv-&gt;ai_buf0;
 	enable_dma(devpriv-&gt;dma0);
-	// set up dual dma if appropriate
+	/*  set up dual dma if appropriate */
 	if (dual_dma) {
 		disable_dma(devpriv-&gt;dma1);
 		/* clear flip-flop to make sure 2-byte registers for
 		 * count and address get set correctly */
 		clear_dma_ff(devpriv-&gt;dma1);
 		set_dma_addr(devpriv-&gt;dma1, virt_to_bus(devpriv-&gt;ai_buf1));
-		// set appropriate size of transfer
+		/*  set appropriate size of transfer */
 		set_dma_count(devpriv-&gt;dma1, devpriv-&gt;dma_transfer_size);
 		enable_dma(devpriv-&gt;dma1);
 	}
@@ -1461,16 +1461,16 @@ static void setup_dma(struct comedi_device * dev, struct comedi_cmd cmd)
 	return;
 }
 
-// programs channel/gain list into card
+/* programs channel/gain list into card */
 static void program_chanlist(struct comedi_device * dev, struct comedi_cmd cmd)
 {
 	int i, n, chan_range;
 	unsigned long irq_flags;
-	const int range_mask = 0x3;	//masks unipolar/bipolar bit off range
+	const int range_mask = 0x3;	/* masks unipolar/bipolar bit off range */
 	const int range_bitshift = 8;
 
 	n = cmd.chanlist_len;
-	// spinlock protects indirect addressing
+	/*  spinlock protects indirect addressing */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, irq_flags);
 	outb(QRAM, dev-&gt;iobase + DAS1800_SELECT);	/* select QRAM for baseAddress + 0x0 */
 	outb(n - 1, dev-&gt;iobase + DAS1800_QRAM_ADDRESS);	/*set QRAM address start */
@@ -1488,7 +1488,7 @@ static void program_chanlist(struct comedi_device * dev, struct comedi_cmd cmd)
 	return;
 }
 
-// analog input do_cmd
+/* analog input do_cmd */
 static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	int ret;
@@ -1509,22 +1509,22 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 	} else {
 		devpriv-&gt;irq_dma_bits |= devpriv-&gt;dma_bits;
 	}
-	// interrupt on end of conversion for TRIG_WAKE_EOS
+	/*  interrupt on end of conversion for TRIG_WAKE_EOS */
 	if (cmd.flags &amp; TRIG_WAKE_EOS) {
-		// interrupt fifo not empty
+		/*  interrupt fifo not empty */
 		devpriv-&gt;irq_dma_bits &amp;= ~FIMD;
 	} else {
-		// interrupt fifo half full
+		/*  interrupt fifo half full */
 		devpriv-&gt;irq_dma_bits |= FIMD;
 	}
-	// determine how many conversions we need
+	/*  determine how many conversions we need */
 	if (cmd.stop_src == TRIG_COUNT) {
 		devpriv-&gt;count = cmd.stop_arg * cmd.chanlist_len;
 	}
 
 	das1800_cancel(dev, s);
 
-	// determine proper bits for control registers
+	/*  determine proper bits for control registers */
 	control_a = control_a_bits(cmd);
 	control_c = control_c_bits(cmd);
 
@@ -1537,14 +1537,14 @@ static int das1800_ai_do_cmd(struct comedi_device * dev, struct comedi_subdevice
 	}
 	setup_dma(dev, cmd);
 	outb(control_c, dev-&gt;iobase + DAS1800_CONTROL_C);
-	// set conversion rate and length for burst mode
+	/*  set conversion rate and length for burst mode */
 	if (control_c &amp; BMDE) {
-		// program conversion period with number of microseconds minus 1
+		/*  program conversion period with number of microseconds minus 1 */
 		outb(cmd.convert_arg / 1000 - 1,
 			dev-&gt;iobase + DAS1800_BURST_RATE);
 		outb(cmd.chanlist_len - 1, dev-&gt;iobase + DAS1800_BURST_LENGTH);
 	}
-	outb(devpriv-&gt;irq_dma_bits, dev-&gt;iobase + DAS1800_CONTROL_B);	// enable irq/dma
+	outb(devpriv-&gt;irq_dma_bits, dev-&gt;iobase + DAS1800_CONTROL_B);	/*  enable irq/dma */
 	outb(control_a, dev-&gt;iobase + DAS1800_CONTROL_A);	/* enable fifo and triggering */
 	outb(CVEN, dev-&gt;iobase + DAS1800_STATUS);	/* enable conversions */
 
@@ -1616,21 +1616,21 @@ static int das1800_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 	struct comedi_insn * insn, unsigned int * data)
 {
 	int chan = CR_CHAN(insn-&gt;chanspec);
-//      int range = CR_RANGE(insn-&gt;chanspec);
+/* int range = CR_RANGE(insn-&gt;chanspec); */
 	int update_chan = thisboard-&gt;ao_n_chan - 1;
 	short output;
 	unsigned long irq_flags;
 
-	//  card expects two's complement data
+	/*   card expects two's complement data */
 	output = data[0] - (1 &lt;&lt; (thisboard-&gt;resolution - 1));
-	// if the write is to the 'update' channel, we need to remember its value
+	/*  if the write is to the 'update' channel, we need to remember its value */
 	if (chan == update_chan)
 		devpriv-&gt;ao_update_bits = output;
-	// write to channel
+	/*  write to channel */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, irq_flags);
 	outb(DAC(chan), dev-&gt;iobase + DAS1800_SELECT);	/* select dac channel for baseAddress + 0x0 */
 	outw(output, dev-&gt;iobase + DAS1800_DAC);
-	// now we need to write to 'update' channel to update all dac channels
+	/*  now we need to write to 'update' channel to update all dac channels */
 	if (chan != update_chan) {
 		outb(DAC(update_chan), dev-&gt;iobase + DAS1800_SELECT);	/* select 'update' channel for baseAddress + 0x0 */
 		outw(devpriv-&gt;ao_update_bits, dev-&gt;iobase + DAS1800_DAC);
@@ -1657,7 +1657,7 @@ static int das1800_do_wbits(struct comedi_device * dev, struct comedi_subdevice
 {
 	unsigned int wbits;
 
-	// only set bits that have been masked
+	/*  only set bits that have been masked */
 	data[0] &amp;= (1 &lt;&lt; s-&gt;n_chan) - 1;
 	wbits = devpriv-&gt;do_bits;
 	wbits &amp;= ~data[0];
@@ -1676,11 +1676,11 @@ static int das1800_set_frequency(struct comedi_device * dev)
 {
 	int err = 0;
 
-	// counter 1, mode 2
+	/*  counter 1, mode 2 */
 	if (i8254_load(dev-&gt;iobase + DAS1800_COUNTER, 0, 1, devpriv-&gt;divisor1,
 			2))
 		err++;
-	// counter 2, mode 2
+	/*  counter 2, mode 2 */
 	if (i8254_load(dev-&gt;iobase + DAS1800_COUNTER, 0, 2, devpriv-&gt;divisor2,
 			2))
 		err++;
@@ -1697,11 +1697,11 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 {
 	unsigned int micro_sec;
 
-	// in burst mode, the maximum conversion time is 64 microseconds
+	/*  in burst mode, the maximum conversion time is 64 microseconds */
 	if (convert_arg &gt; 64000)
 		convert_arg = 64000;
 
-	// the conversion time must be an integral number of microseconds
+	/*  the conversion time must be an integral number of microseconds */
 	switch (round_mode) {
 	case TRIG_ROUND_NEAREST:
 	default:
@@ -1715,21 +1715,21 @@ static unsigned int burst_convert_arg(unsigned int convert_arg, int round_mode)
 		break;
 	}
 
-	// return number of nanoseconds
+	/*  return number of nanoseconds */
 	return micro_sec * 1000;
 }
 
-// utility function that suggests a dma transfer size based on the conversion period 'ns'
+/* utility function that suggests a dma transfer size based on the conversion period 'ns' */
 static unsigned int suggest_transfer_size(struct comedi_cmd * cmd)
 {
 	unsigned int size = DMA_BUF_SIZE;
-	static const int sample_size = 2;	// size in bytes of one sample from board
-	unsigned int fill_time = 300000000;	// target time in nanoseconds for filling dma buffer
-	unsigned int max_size;	// maximum size we will allow for a transfer
+	static const int sample_size = 2;	/*  size in bytes of one sample from board */
+	unsigned int fill_time = 300000000;	/*  target time in nanoseconds for filling dma buffer */
+	unsigned int max_size;	/*  maximum size we will allow for a transfer */
 
-	// make dma buffer fill in 0.3 seconds for timed modes
+	/*  make dma buffer fill in 0.3 seconds for timed modes */
 	switch (cmd-&gt;scan_begin_src) {
-	case TRIG_FOLLOW:	// not in burst mode
+	case TRIG_FOLLOW:	/*  not in burst mode */
 		if (cmd-&gt;convert_src == TRIG_TIMER)
 			size = (fill_time / cmd-&gt;convert_arg) * sample_size;
 		break;
@@ -1742,9 +1742,9 @@ static unsigned int suggest_transfer_size(struct comedi_cmd * cmd)
 		break;
 	}
 
-	// set a minimum and maximum size allowed
+	/*  set a minimum and maximum size allowed */
 	max_size = DMA_BUF_SIZE;
-	// if we are taking limited number of conversions, limit transfer size to that
+	/*  if we are taking limited number of conversions, limit transfer size to that */
 	if (cmd-&gt;stop_src == TRIG_COUNT &amp;&amp;
 		cmd-&gt;stop_arg * cmd-&gt;chanlist_len * sample_size &lt; max_size)
 		max_size = cmd-&gt;stop_arg * cmd-&gt;chanlist_len * sample_size;</pre><hr><pre>commit cf0fd1086cbb55fb5c0ecbd652fec34335fb7657
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:29:29 2009 -0400

    Staging: comedi: remove C99 comments in APCI1710_82x54.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/APCI1710_82x54.c b/drivers/staging/comedi/drivers/addi-data/APCI1710_82x54.c
index 3f8ffa2c3e87..b3ee729c50ca 100644
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_82x54.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_82x54.c
@@ -233,9 +233,9 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 	unsigned char b_OutputLevel;
 	unsigned char b_HardwareGateLevel;
 
-	//BEGIN JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz
+	/* BEGIN JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz */
 	unsigned int dw_Test = 0;
-	//END JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz
+	/* END JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz */
 
 	i_ReturnValue = insn-&gt;n;
 	b_ModulNbr = (unsigned char) CR_AREF(insn-&gt;chanspec);
@@ -256,7 +256,7 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 			if (b_TimerNbr &lt;= 2) {
 				/* Test the timer mode */
 				if (b_TimerMode &lt;= 5) {
-					//BEGIN JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz
+					/* BEGIN JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz */
 					/* Test te imput clock selection */
 					/*
 					   if (((b_TimerNbr == 0) &amp;&amp; (b_InputClockSelection == 0)) ||
@@ -271,11 +271,11 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 					     ((b_InputClockSelection == APCI1710_PCI_BUS_CLOCK) ||
 					      (b_InputClockSelection == APCI1710_FRONT_CONNECTOR_INPUT) ||
 					      (b_InputClockSelection == APCI1710_10MHZ)))) {
-						//BEGIN JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz
+						/* BEGIN JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz */
 						if (((b_InputClockSelection == APCI1710_10MHZ) &amp;&amp;
 						     ((devpriv-&gt;s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] &amp; 0x0000FFFFUL) &gt;= 0x3131)) ||
 						     (b_InputClockSelection != APCI1710_10MHZ)) {
-							//END JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz
+							/* END JK 27.10.2003 : Add the possibility to use a 40 Mhz quartz */
 							/* Test the input clock level selection */
 
 							if ((b_InputClockLevel == 0) ||
@@ -284,7 +284,7 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 								if ((b_OutputLevel == 0) || (b_OutputLevel == 1)) {
 									/* Test the hardware gate level selection */
 									if ((b_HardwareGateLevel == 0) || (b_HardwareGateLevel == 1)) {
-										//BEGIN JK 27.10.03 : Add the possibility to use a 40 Mhz quartz
+										/* BEGIN JK 27.10.03 : Add the possibility to use a 40 Mhz quartz */
 										/* Test if version &gt; 1.1 and clock selection = 10MHz */
 										if ((b_InputClockSelection == APCI1710_10MHZ) &amp;&amp; ((devpriv-&gt;s_BoardInfos.dw_MolduleConfiguration[b_ModulNbr] &amp; 0x0000FFFFUL) &gt; 0x3131)) {
 											/* Test if 40MHz quartz on board */
@@ -297,7 +297,7 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 
 										/* Test if detection OK */
 										if (dw_Test == 1) {
-											//END JK 27.10.03 : Add the possibility to use a 40 Mhz quartz
+											/* END JK 27.10.03 : Add the possibility to use a 40 Mhz quartz */
 											/* Initialisation OK */
 											devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].b_82X54Init = 1;
 
@@ -314,7 +314,7 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 											devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].b_HardwareGateLevel = b_HardwareGateLevel;
 
 											/* Set the configuration word and disable the timer */
-											//BEGIN JK 27.10.03 : Add the possibility to use a 40 Mhz quartz
+											/* BEGIN JK 27.10.03 : Add the possibility to use a 40 Mhz quartz */
 											/*
 											   devpriv-&gt;s_ModuleInfo [b_ModulNbr].
 											   s_82X54ModuleInfo.
@@ -330,7 +330,7 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 											}
 
 											devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].dw_ConfigurationWord = (unsigned int)(((b_HardwareGateLevel &lt;&lt; 0) &amp; 0x1) | ((b_InputClockLevel &lt;&lt; 1) &amp; 0x2) | (((~b_OutputLevel &amp; 1) &lt;&lt; 2) &amp; 0x4) | ((b_InputClockSelection &lt;&lt; 4) &amp; 0x30));
-											//END JK 27.10.03 : Add the possibility to use a 40 Mhz quartz
+											/* END JK 27.10.03 : Add the possibility to use a 40 Mhz quartz */
 											outl(devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].dw_ConfigurationWord, devpriv-&gt;s_BoardInfos.ui_Address + 32 + (b_TimerNbr * 4) + (64 * b_ModulNbr));
 
 											/* Initialise the 82X54 Timer */
@@ -338,31 +338,31 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 
 											/* Write the reload value */
 											outl(ul_ReloadValue, devpriv-&gt;s_BoardInfos.ui_Address + 0 + (b_TimerNbr * 4) + (64 * b_ModulNbr));
-											//BEGIN JK 27.10.03 : Add the possibility to use a 40 Mhz quartz
-										}	// if (dw_Test == 1)
+											/* BEGIN JK 27.10.03 : Add the possibility to use a 40 Mhz quartz */
+										}	/*  if (dw_Test == 1) */
 										else {
 											/* Input timer clock selection is wrong */
 											i_ReturnValue = -6;
-										}	// if (dw_Test == 1)
-										//END JK 27.10.03 : Add the possibility to use a 40 Mhz quartz
-									}	// if ((b_HardwareGateLevel == 0) || (b_HardwareGateLevel == 1))
+										}	/*  if (dw_Test == 1) */
+										/* END JK 27.10.03 : Add the possibility to use a 40 Mhz quartz */
+									}	/*  if ((b_HardwareGateLevel == 0) || (b_HardwareGateLevel == 1)) */
 									else {
 										/* Selection from hardware gate level is wrong */
 										DPRINTK("Selection from hardware gate level is wrong\n");
 										i_ReturnValue = -9;
-									}	// if ((b_HardwareGateLevel == 0) || (b_HardwareGateLevel == 1))
-								}	// if ((b_OutputLevel == 0) || (b_OutputLevel == 1))
+									}	/*  if ((b_HardwareGateLevel == 0) || (b_HardwareGateLevel == 1)) */
+								}	/*  if ((b_OutputLevel == 0) || (b_OutputLevel == 1)) */
 								else {
 									/* Selection from output clock level is wrong */
 									DPRINTK("Selection from output clock level is wrong\n");
 									i_ReturnValue = -8;
-								}	// if ((b_OutputLevel == 0) || (b_OutputLevel == 1))
-							}	// if ((b_InputClockLevel == 0) || (b_InputClockLevel == 1))
+								}	/*  if ((b_OutputLevel == 0) || (b_OutputLevel == 1)) */
+							}	/*  if ((b_InputClockLevel == 0) || (b_InputClockLevel == 1)) */
 							else {
 								/* Selection from input clock level is wrong */
 								DPRINTK("Selection from input clock level is wrong\n");
 								i_ReturnValue = -7;
-							}	// if ((b_InputClockLevel == 0) || (b_InputClockLevel == 1))
+							}	/*  if ((b_InputClockLevel == 0) || (b_InputClockLevel == 1)) */
 						} else {
 							/* Input timer clock selection is wrong */
 							DPRINTK("Input timer clock selection is wrong\n");
@@ -373,18 +373,18 @@ int i_APCI1710_InsnConfigInitTimer(struct comedi_device * dev, struct comedi_sub
 						DPRINTK("Input timer clock selection is wrong\n");
 						i_ReturnValue = -6;
 					}
-				}	// if ((b_TimerMode &gt;= 0) &amp;&amp; (b_TimerMode &lt;= 5))
+				}	/*  if ((b_TimerMode &gt;= 0) &amp;&amp; (b_TimerMode &lt;= 5)) */
 				else {
 					/* Timer mode selection is wrong */
 					DPRINTK("Timer mode selection is wrong\n");
 					i_ReturnValue = -5;
-				}	// if ((b_TimerMode &gt;= 0) &amp;&amp; (b_TimerMode &lt;= 5))
-			}	// if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2))
+				}	/*  if ((b_TimerMode &gt;= 0) &amp;&amp; (b_TimerMode &lt;= 5)) */
+			}	/*  if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2)) */
 			else {
 				/* Timer selection wrong */
 				DPRINTK("Timer selection wrong\n");
 				i_ReturnValue = -3;
-			}	// if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2))
+			}	/*  if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2)) */
 		} else {
 			/* The module is not a TIMER module */
 			DPRINTK("The module is not a TIMER module\n");
@@ -431,7 +431,7 @@ int i_APCI1710_InsnWriteEnableDisableTimer(struct comedi_device *dev,struct come
 i_ReturnValue=insn-&gt;n;
 	b_ModulNbr        = (unsigned char) CR_AREF(insn-&gt;chanspec);
 	b_TimerNbr		  = (unsigned char) CR_CHAN(insn-&gt;chanspec);
-	b_ActionType      = (unsigned char) data[0]; // enable disable
+	b_ActionType      = (unsigned char) data[0]; /*  enable disable */
 +----------------------------------------------------------------------------+
 | Output Parameters : -                                                      |
 +----------------------------------------------------------------------------+
@@ -462,7 +462,7 @@ int i_APCI1710_InsnWriteEnableDisableTimer(struct comedi_device * dev,
 	i_ReturnValue = insn-&gt;n;
 	b_ModulNbr = (unsigned char) CR_AREF(insn-&gt;chanspec);
 	b_TimerNbr = (unsigned char) CR_CHAN(insn-&gt;chanspec);
-	b_ActionType = (unsigned char) data[0];	// enable disable
+	b_ActionType = (unsigned char) data[0];	/*  enable disable */
 
 	/* Test the module number */
 	if (b_ModulNbr &lt; 4) {
@@ -487,9 +487,9 @@ int i_APCI1710_InsnWriteEnableDisableTimer(struct comedi_device * dev,
 								devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].dw_ConfigurationWord = devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].dw_ConfigurationWord | 0x8;
 
 								outl(devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].dw_ConfigurationWord, devpriv-&gt;s_BoardInfos.ui_Address + 32 + (b_TimerNbr * 4) + (64 * b_ModulNbr));
-								devpriv-&gt;tsk_Current = current;	// Save the current process task structure
+								devpriv-&gt;tsk_Current = current;	/*  Save the current process task structure */
 
-							}	// if (b_InterruptEnable == APCI1710_ENABLE)
+							}	/*  if (b_InterruptEnable == APCI1710_ENABLE) */
 							else {
 								/* Disable the interrupt */
 								devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].dw_ConfigurationWord = devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.s_82X54TimerInfo[b_TimerNbr].dw_ConfigurationWord &amp; 0xF7;
@@ -498,7 +498,7 @@ int i_APCI1710_InsnWriteEnableDisableTimer(struct comedi_device * dev,
 
 								/* Save the interrupt flag */
 								devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.b_InterruptMask = devpriv-&gt;s_ModuleInfo[b_ModulNbr].s_82X54ModuleInfo.b_InterruptMask &amp; (0xFF - (1 &lt;&lt; b_TimerNbr));
-							}	// if (b_InterruptEnable == APCI1710_ENABLE)
+							}	/*  if (b_InterruptEnable == APCI1710_ENABLE) */
 
 							/* Test if error occur */
 							if (i_ReturnValue &gt;= 0) {
@@ -530,7 +530,7 @@ int i_APCI1710_InsnWriteEnableDisableTimer(struct comedi_device * dev,
 						/* Disable the timer */
 						outl(0, devpriv-&gt;s_BoardInfos.ui_Address + 44 + (b_TimerNbr * 4) + (64 * b_ModulNbr));
 						break;
-					}	// Switch end
+					}	/*  Switch end */
 				} else {
 					/* Timer not initialised see function */
 					DPRINTK ("Timer not initialised see function\n");
@@ -540,7 +540,7 @@ int i_APCI1710_InsnWriteEnableDisableTimer(struct comedi_device * dev,
 				/* Timer selection wrong */
 				DPRINTK("Timer selection wrong\n");
 				i_ReturnValue = -3;
-			}	// if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2))
+			}	/*  if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2)) */
 		} else {
 			/* The module is not a TIMER module */
 			DPRINTK("The module is not a TIMER module\n");
@@ -662,7 +662,7 @@ int i_APCI1710_InsnReadAllTimerValue(struct comedi_device *dev, struct comedi_su
 			i_ReturnValue = -2;
 		}
 
-	}			// End of Switch
+	}			/*  End of Switch */
 	return (i_ReturnValue);
 }
 
@@ -800,7 +800,7 @@ int i_APCI1710_ReadTimerValue(struct comedi_device * dev,
 				/* Timer selection wrong */
 				DPRINTK("Timer selection wrong\n");
 				i_ReturnValue = -3;
-			}	// if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2))
+			}	/*  if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2)) */
 		} else {
 			/* The module is not a TIMER module */
 			DPRINTK("The module is not a TIMER module\n");
@@ -879,7 +879,7 @@ int i_APCI1710_GetTimerOutputLevel(struct comedi_device * dev,
 				/* Timer selection wrong */
 				DPRINTK("Timer selection wrong\n");
 				i_ReturnValue = -3;
-			}	// if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2))
+			}	/*  if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2)) */
 		} else {
 			/* The module is not a TIMER module */
 			DPRINTK("The module is not a TIMER module\n");
@@ -958,7 +958,7 @@ int i_APCI1710_GetTimerProgressStatus(struct comedi_device *dev,
 			} else {
 				/* Timer selection wrong */
 				i_ReturnValue = -3;
-			}	// if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2))
+			}	/*  if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2)) */
 		} else {
 			/* The module is not a TIMER module */
 
@@ -1031,7 +1031,7 @@ int i_APCI1710_WriteTimerValue(struct comedi_device * dev,
 				/* Timer selection wrong */
 				DPRINTK("Timer selection wrong\n");
 				i_ReturnValue = -3;
-			}	// if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2))
+			}	/*  if ((b_TimerNbr &gt;= 0) &amp;&amp; (b_TimerNbr &lt;= 2)) */
 		} else {
 			/* The module is not a TIMER module */
 			DPRINTK("The module is not a TIMER module\n");</pre><hr><pre>commit ed27614451c3f35412b83aabdcd4af6d76be7cd7
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:29:23 2009 -0400

    Staging: comedi: remove C99 comments in acl7225b.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/acl7225b.c b/drivers/staging/comedi/drivers/acl7225b.c
index b21320f0959f..057753991323 100644
--- a/drivers/staging/comedi/drivers/acl7225b.c
+++ b/drivers/staging/comedi/drivers/acl7225b.c
@@ -26,8 +26,8 @@ static int acl7225b_attach(struct comedi_device *dev, struct comedi_devconfig *
 static int acl7225b_detach(struct comedi_device *dev);
 
 struct boardtype {
-	const char *name;	// driver name
-	int io_range;		// len of I/O space
+	const char *name;	/*  driver name */
+	int io_range;		/*  len of I/O space */
 };
 
 static const struct boardtype boardtypes[] = {</pre><hr><pre>commit 67d83b4fb96ab304a47ba5af9a99818b38c9fd3e
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:29:18 2009 -0400

    Staging: comedi: remove C99 comments in 8253.h
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/8253.h b/drivers/staging/comedi/drivers/8253.h
index 08a11a5a16e6..bcf0170e93d7 100644
--- a/drivers/staging/comedi/drivers/8253.h
+++ b/drivers/staging/comedi/drivers/8253.h
@@ -205,7 +205,7 @@ static inline void i8253_cascade_ns_to_timer_2div(int i8253_osc_base,
 	}
 
 	*nanosec = div1 * div2 * i8253_osc_base;
-	*d1 = div1 &amp; 0xffff;	// masking is done since counter maps zero to 0x10000
+	*d1 = div1 &amp; 0xffff;	/*  masking is done since counter maps zero to 0x10000 */
 	*d2 = div2 &amp; 0xffff;
 	return;
 }
@@ -247,12 +247,12 @@ static inline int i8254_load(unsigned long base_address, unsigned int regshift,
 		return -1;
 
 	byte = counter_number &lt;&lt; 6;
-	byte |= 0x30;		// load low then high byte
-	byte |= (mode &lt;&lt; 1);	// set counter mode
+	byte |= 0x30;		/*  load low then high byte */
+	byte |= (mode &lt;&lt; 1);	/*  set counter mode */
 	outb(byte, base_address + (i8254_control_reg &lt;&lt; regshift));
-	byte = count &amp; 0xff;	// lsb of counter value
+	byte = count &amp; 0xff;	/*  lsb of counter value */
 	outb(byte, base_address + (counter_number &lt;&lt; regshift));
-	byte = (count &gt;&gt; 8) &amp; 0xff;	// msb of counter value
+	byte = (count &gt;&gt; 8) &amp; 0xff;	/*  msb of counter value */
 	outb(byte, base_address + (counter_number &lt;&lt; regshift));
 
 	return 0;
@@ -273,12 +273,12 @@ static inline int i8254_mm_load(void *base_address, unsigned int regshift,
 		return -1;
 
 	byte = counter_number &lt;&lt; 6;
-	byte |= 0x30;		// load low then high byte
-	byte |= (mode &lt;&lt; 1);	// set counter mode
+	byte |= 0x30;		/*  load low then high byte */
+	byte |= (mode &lt;&lt; 1);	/*  set counter mode */
 	writeb(byte, base_address + (i8254_control_reg &lt;&lt; regshift));
-	byte = count &amp; 0xff;	// lsb of counter value
+	byte = count &amp; 0xff;	/*  lsb of counter value */
 	writeb(byte, base_address + (counter_number &lt;&lt; regshift));
-	byte = (count &gt;&gt; 8) &amp; 0xff;	// msb of counter value
+	byte = (count &gt;&gt; 8) &amp; 0xff;	/*  msb of counter value */
 	writeb(byte, base_address + (counter_number &lt;&lt; regshift));
 
 	return 0;
@@ -294,13 +294,13 @@ static inline int i8254_read(unsigned long base_address, unsigned int regshift,
 	if (counter_number &gt; 2)
 		return -1;
 
-	// latch counter
+	/*  latch counter */
 	byte = counter_number &lt;&lt; 6;
 	outb(byte, base_address + (i8254_control_reg &lt;&lt; regshift));
 
-	// read lsb
+	/*  read lsb */
 	ret = inb(base_address + (counter_number &lt;&lt; regshift));
-	// read msb
+	/*  read msb */
 	ret += inb(base_address + (counter_number &lt;&lt; regshift)) &lt;&lt; 8;
 
 	return ret;
@@ -315,13 +315,13 @@ static inline int i8254_mm_read(void *base_address, unsigned int regshift,
 	if (counter_number &gt; 2)
 		return -1;
 
-	// latch counter
+	/*  latch counter */
 	byte = counter_number &lt;&lt; 6;
 	writeb(byte, base_address + (i8254_control_reg &lt;&lt; regshift));
 
-	// read lsb
+	/*  read lsb */
 	ret = readb(base_address + (counter_number &lt;&lt; regshift));
-	// read msb
+	/*  read msb */
 	ret += readb(base_address + (counter_number &lt;&lt; regshift)) &lt;&lt; 8;
 
 	return ret;
@@ -336,9 +336,9 @@ static inline void i8254_write(unsigned long base_address,
 	if (counter_number &gt; 2)
 		return;
 
-	byte = count &amp; 0xff;	// lsb of counter value
+	byte = count &amp; 0xff;	/*  lsb of counter value */
 	outb(byte, base_address + (counter_number &lt;&lt; regshift));
-	byte = (count &gt;&gt; 8) &amp; 0xff;	// msb of counter value
+	byte = (count &gt;&gt; 8) &amp; 0xff;	/*  msb of counter value */
 	outb(byte, base_address + (counter_number &lt;&lt; regshift));
 }
 
@@ -350,9 +350,9 @@ static inline void i8254_mm_write(void *base_address,
 	if (counter_number &gt; 2)
 		return;
 
-	byte = count &amp; 0xff;	// lsb of counter value
+	byte = count &amp; 0xff;	/*  lsb of counter value */
 	writeb(byte, base_address + (counter_number &lt;&lt; regshift));
-	byte = (count &gt;&gt; 8) &amp; 0xff;	// msb of counter value
+	byte = (count &gt;&gt; 8) &amp; 0xff;	/*  msb of counter value */
 	writeb(byte, base_address + (counter_number &lt;&lt; regshift));
 }
 
@@ -374,8 +374,8 @@ static inline int i8254_set_mode(unsigned long base_address,
 		return -1;
 
 	byte = counter_number &lt;&lt; 6;
-	byte |= 0x30;		// load low then high byte
-	byte |= mode;		// set counter mode and BCD|binary
+	byte |= 0x30;		/*  load low then high byte */
+	byte |= mode;		/*  set counter mode and BCD|binary */
 	outb(byte, base_address + (i8254_control_reg &lt;&lt; regshift));
 
 	return 0;
@@ -392,8 +392,8 @@ static inline int i8254_mm_set_mode(void *base_address,
 		return -1;
 
 	byte = counter_number &lt;&lt; 6;
-	byte |= 0x30;		// load low then high byte
-	byte |= mode;		// set counter mode and BCD|binary
+	byte |= 0x30;		/*  load low then high byte */
+	byte |= mode;		/*  set counter mode and BCD|binary */
 	writeb(byte, base_address + (i8254_control_reg &lt;&lt; regshift));
 
 	return 0;</pre><hr><pre>commit 6a037d5f655fbf1853d28cd8a02ffe5c466d81a5
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Mar 25 11:06:30 2009 -0400

    Staging: comedi: Remove str_AnalogInputHeader typedef in addi-data/addi_eeprom.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c b/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
index 2e9c15debdb4..e57692dc9e83 100644
--- a/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
@@ -106,13 +106,14 @@ typedef struct {
 	unsigned char b_Resolution;
 } str_AnalogOutputHeader;
 
-typedef struct {
+struct str_AnalogInputHeader {
 	unsigned short w_Nchannel;
 	unsigned short w_MinConvertTiming;
 	unsigned short w_MinDelayTiming;
 	unsigned char b_HasDma;
 	unsigned char b_Resolution;
-} str_AnalogInputHeader;
+};
+
 
 		/*****************************************/
 		/*            Read Header Functions              */
@@ -139,7 +140,7 @@ int i_EepromReadAnlogOutputHeader(unsigned short w_PCIBoardEepromAddress,
 
 int i_EepromReadAnlogInputHeader(unsigned short w_PCIBoardEepromAddress,
 	char *pc_PCIChipInformation, unsigned short w_Address,
-	str_AnalogInputHeader * s_Header);
+	struct str_AnalogInputHeader * s_Header);
 
 		/******************************************/
 		/*      Eeprom Specific Functions                         */
@@ -812,7 +813,7 @@ int i_EepromReadMainHeader(unsigned short w_PCIBoardEepromAddress,
 	struct str_DigitalOutputHeader s_DigitalOutputHeader;
 	//struct str_TimerMainHeader     s_TimerMainHeader,s_WatchdogMainHeader;
 	str_AnalogOutputHeader s_AnalogOutputHeader;
-	str_AnalogInputHeader s_AnalogInputHeader;
+	struct str_AnalogInputHeader s_AnalogInputHeader;
 
 	// Read size
 	s_MainHeader.w_HeaderSize =
@@ -1099,7 +1100,7 @@ int i_EepromReadAnlogOutputHeader(unsigned short w_PCIBoardEepromAddress,
 +----------------------------------------------------------------------------+
 | Function Name  : int i_EepromReadAnlogInputHeader(unsigned short 					 |
 |			w_PCIBoardEepromAddress,char *pc_PCIChipInformation,     |
-|			unsigned short w_Address,str_AnalogInputHeader *s_Header)          |
+|			unsigned short w_Address,struct str_AnalogInputHeader *s_Header)          |
 +----------------------------------------------------------------------------+
 | Task              : Read Nalog Output  Header                              |
 +----------------------------------------------------------------------------+
@@ -1107,7 +1108,7 @@ int i_EepromReadAnlogOutputHeader(unsigned short w_PCIBoardEepromAddress,
 |																	 |
 |		      char *pc_PCIChipInformation  : PCI Chip Type.          |
 |																	 |
-|			 str_AnalogInputHeader *s_Header:Anlog Input Header      |
+|			 struct str_AnalogInputHeader *s_Header:Anlog Input Header      |
 |											   Pointer				 |
 +----------------------------------------------------------------------------+
 | Output Parameters : -                                                      |
@@ -1119,7 +1120,7 @@ int i_EepromReadAnlogOutputHeader(unsigned short w_PCIBoardEepromAddress,
 // Reads only for ONE  hardware component
 int i_EepromReadAnlogInputHeader(unsigned short w_PCIBoardEepromAddress,
 	char *pc_PCIChipInformation, unsigned short w_Address,
-	str_AnalogInputHeader * s_Header)
+	struct str_AnalogInputHeader * s_Header)
 {
 	unsigned short w_Temp, w_Offset;
 	w_Temp = w_EepromReadWord(w_PCIBoardEepromAddress,</pre><hr><pre>commit 0a4eb4b6c7c12730254be53d93a67ed2955d5c66
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Mar 25 11:07:01 2009 -0400

    Staging: comedi: Remove labpc_private typedef
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index d7641cd920be..c0da5c75b4bb 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -427,7 +427,7 @@ static const struct labpc_board_struct labpc_boards[] = {
 static const int dma_buffer_size = 0xff00;	// size in bytes of dma buffer
 static const int sample_size = 2;	// 2 bytes per sample
 
-#define devpriv ((labpc_private *)dev-&gt;private)
+#define devpriv ((struct labpc_private *)dev-&gt;private)
 
 static struct comedi_driver driver_labpc = {
 	.driver_name = DRV_NAME,
@@ -653,7 +653,7 @@ static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it
 #endif
 
 	/* allocate and initialize dev-&gt;private */
-	if (alloc_private(dev, sizeof(labpc_private)) &lt; 0)
+	if (alloc_private(dev, sizeof(struct labpc_private)) &lt; 0)
 		return -ENOMEM;
 
 	// get base address, irq etc. based on bustype
diff --git a/drivers/staging/comedi/drivers/ni_labpc.h b/drivers/staging/comedi/drivers/ni_labpc.h
index cf53a94a51a2..6f76db026b9b 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.h
+++ b/drivers/staging/comedi/drivers/ni_labpc.h
@@ -46,7 +46,7 @@ struct labpc_board_struct {
 	unsigned memory_mapped_io:1;	/* uses memory mapped io instead of ioports */
 };
 
-typedef struct {
+struct labpc_private {
 	struct mite_struct *mite;	// for mite chip on pci-1200
 	volatile unsigned long long count;	/* number of data points left to be taken */
 	unsigned int ao_value[NUM_AO_CHAN];	// software copy of analog output values
@@ -72,7 +72,7 @@ typedef struct {
 	// function pointers so we can use inb/outb or readb/writeb as appropriate
 	unsigned int (*read_byte) (unsigned long address);
 	void (*write_byte) (unsigned int byte, unsigned long address);
-} labpc_private;
+};
 
 int labpc_common_attach(struct comedi_device * dev, unsigned long iobase,
 	unsigned int irq, unsigned int dma);
diff --git a/drivers/staging/comedi/drivers/ni_labpc_cs.c b/drivers/staging/comedi/drivers/ni_labpc_cs.c
index 1e58d2e40ab8..884074ddaac8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc_cs.c
+++ b/drivers/staging/comedi/drivers/ni_labpc_cs.c
@@ -133,7 +133,7 @@ static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it
 	struct pcmcia_device *link;
 
 	/* allocate and initialize dev-&gt;private */
-	if (alloc_private(dev, sizeof(labpc_private)) &lt; 0)
+	if (alloc_private(dev, sizeof(struct labpc_private)) &lt; 0)
 		return -ENOMEM;
 
 	// get base address, irq etc. based on bustype</pre><hr><pre>commit 9ad007403fa4326586060e443ee344697daa60ec
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Mar 25 11:06:56 2009 -0400

    Staging: comedi: Remove labpc_board_struct typedef
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/ni_labpc.c b/drivers/staging/comedi/drivers/ni_labpc.c
index 37898d8474cd..d7641cd920be 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.c
+++ b/drivers/staging/comedi/drivers/ni_labpc.c
@@ -360,7 +360,7 @@ static inline void labpc_writeb(unsigned int byte, unsigned long address)
 	writeb(byte, (void *)address);
 }
 
-static const labpc_board labpc_boards[] = {
+static const struct labpc_board_struct labpc_boards[] = {
 	{
 	      name:	"lab-pc-1200",
 	      ai_speed:10000,
@@ -422,7 +422,7 @@ static const labpc_board labpc_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((labpc_board *)dev-&gt;board_ptr)
+#define thisboard ((struct labpc_board_struct *)dev-&gt;board_ptr)
 
 static const int dma_buffer_size = 0xff00;	// size in bytes of dma buffer
 static const int sample_size = 2;	// 2 bytes per sample
@@ -434,9 +434,9 @@ static struct comedi_driver driver_labpc = {
 	.module = THIS_MODULE,
 	.attach = labpc_attach,
 	.detach = labpc_common_detach,
-	.num_names = sizeof(labpc_boards) / sizeof(labpc_board),
+	.num_names = sizeof(labpc_boards) / sizeof(struct labpc_board_struct),
 	.board_name = &amp;labpc_boards[0].name,
-	.offset = sizeof(labpc_board),
+	.offset = sizeof(struct labpc_board_struct),
 };
 
 #ifdef CONFIG_COMEDI_PCI
diff --git a/drivers/staging/comedi/drivers/ni_labpc.h b/drivers/staging/comedi/drivers/ni_labpc.h
index b44b0d3d02f1..cf53a94a51a2 100644
--- a/drivers/staging/comedi/drivers/ni_labpc.h
+++ b/drivers/staging/comedi/drivers/ni_labpc.h
@@ -32,7 +32,7 @@ enum labpc_register_layout { labpc_plus_layout, labpc_1200_layout };
 enum transfer_type { fifo_not_empty_transfer, fifo_half_full_transfer,
 		isa_dma_transfer };
 
-typedef struct labpc_board_struct {
+struct labpc_board_struct {
 	const char *name;
 	int device_id;		// device id for pci and pcmcia boards
 	int ai_speed;		// maximum input speed in nanoseconds
@@ -44,7 +44,7 @@ typedef struct labpc_board_struct {
 	const int *ai_range_is_unipolar;
 	unsigned ai_scan_up:1;	// board can auto scan up in ai channels, not just down
 	unsigned memory_mapped_io:1;	/* uses memory mapped io instead of ioports */
-} labpc_board;
+};
 
 typedef struct {
 	struct mite_struct *mite;	// for mite chip on pci-1200
diff --git a/drivers/staging/comedi/drivers/ni_labpc_cs.c b/drivers/staging/comedi/drivers/ni_labpc_cs.c
index 0c2a196adaff..1e58d2e40ab8 100644
--- a/drivers/staging/comedi/drivers/ni_labpc_cs.c
+++ b/drivers/staging/comedi/drivers/ni_labpc_cs.c
@@ -81,7 +81,7 @@ static struct pcmcia_device *pcmcia_cur_dev = NULL;
 
 static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it);
 
-static const labpc_board labpc_cs_boards[] = {
+static const struct labpc_board_struct labpc_cs_boards[] = {
 	{
 	      name:	"daqcard-1200",
 	      device_id:0x103,	// 0x10b is manufacturer id, 0x103 is device id
@@ -114,16 +114,16 @@ static const labpc_board labpc_cs_boards[] = {
 /*
  * Useful for shorthand access to the particular board structure
  */
-#define thisboard ((const labpc_board *)dev-&gt;board_ptr)
+#define thisboard ((const struct labpc_board_struct *)dev-&gt;board_ptr)
 
 static struct comedi_driver driver_labpc_cs = {
 	.driver_name = "ni_labpc_cs",
 	.module = THIS_MODULE,
 	.attach = &amp;labpc_attach,
 	.detach = &amp;labpc_common_detach,
-	.num_names = sizeof(labpc_cs_boards) / sizeof(labpc_board),
+	.num_names = sizeof(labpc_cs_boards) / sizeof(struct labpc_board_struct),
 	.board_name = &amp;labpc_cs_boards[0].name,
-	.offset = sizeof(labpc_board),
+	.offset = sizeof(struct labpc_board_struct),
 };
 
 static int labpc_attach(struct comedi_device * dev, struct comedi_devconfig * it)</pre>
    <div class="pagination">
        <a href='3_56.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><span>[57]</span><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_58.html'>Next&gt;&gt;</a>
    <div>
</body>
