<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_115.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><span>[116]</span><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_117.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 40f122f343797d02390c5a157372cac0c5b50bb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 9 14:44:33 2006 -0500

    USB: Add autosuspend support to the hub driver
    
    This patch (as742b) adds autosuspend/autoresume support to the USB hub
    driver.  The largest aspect of the change is that we no longer need a
    special flag for root hubs that want to be resumed.  Now every hub is
    autoresumed whenever khubd needs to access it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f6e692180587..55812a5ac661 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -65,7 +65,6 @@ struct usb_hub {
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		activating:1;
-	unsigned		resume_root_hub:1;
 
 	unsigned		has_indicators:1;
 	u8			indicator[USB_MAXCHILDREN];
@@ -328,6 +327,9 @@ static void kick_khubd(struct usb_hub *hub)
 {
 	unsigned long	flags;
 
+	/* Suppress autosuspend until khubd runs */
+	to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt = 1;
+
 	spin_lock_irqsave(&amp;hub_event_lock, flags);
 	if (list_empty(&amp;hub-&gt;event_list)) {
 		list_add_tail(&amp;hub-&gt;event_list, &amp;hub_event_list);
@@ -509,7 +511,6 @@ static void hub_quiesce(struct usb_hub *hub)
 	/* (nonblocking) khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
 	hub-&gt;activating = 0;
-	hub-&gt;resume_root_hub = 0;
 
 	/* (blocking) stop khubd and related activity */
 	usb_kill_urb(hub-&gt;urb);
@@ -525,7 +526,7 @@ static void hub_activate(struct usb_hub *hub)
 
 	hub-&gt;quiescing = 0;
 	hub-&gt;activating = 1;
-	hub-&gt;resume_root_hub = 0;
+
 	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
 	if (status &lt; 0)
 		dev_err(hub-&gt;intfdev, "activate --&gt; %d\n", status);
@@ -940,6 +941,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	INIT_WORK(&amp;hub-&gt;leds, led_work, hub);
 
 	usb_set_intfdata (intf, hub);
+	intf-&gt;needs_remote_wakeup = 1;
 
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs++;
@@ -1938,6 +1940,8 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 		}
 	}
 
+	dev_dbg(&amp;intf-&gt;dev, "%s\n", __FUNCTION__);
+
 	/* "global suspend" of the downstream HC-to-USB interface */
 	if (!hdev-&gt;parent) {
 		struct usb_bus	*bus = hdev-&gt;bus;
@@ -1960,10 +1964,12 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 
 static int hub_resume(struct usb_interface *intf)
 {
-	struct usb_device	*hdev = interface_to_usbdev(intf);
 	struct usb_hub		*hub = usb_get_intfdata (intf);
+	struct usb_device	*hdev = hub-&gt;hdev;
 	int			status;
 
+	dev_dbg(&amp;intf-&gt;dev, "%s\n", __FUNCTION__);
+
 	/* "global resume" of the downstream HC-to-USB interface */
 	if (!hdev-&gt;parent) {
 		struct usb_bus	*bus = hdev-&gt;bus;
@@ -2002,7 +2008,6 @@ void usb_resume_root_hub(struct usb_device *hdev)
 {
 	struct usb_hub *hub = hdev_to_hub(hdev);
 
-	hub-&gt;resume_root_hub = 1;
 	kick_khubd(hub);
 }
 
@@ -2639,16 +2644,13 @@ static void hub_events(void)
 		intf = to_usb_interface(hub-&gt;intfdev);
 		hub_dev = &amp;intf-&gt;dev;
 
-		i = hub-&gt;resume_root_hub;
-
-		dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x%s\n",
+		dev_dbg(hub_dev, "state %d ports %d chg %04x evt %04x\n",
 				hdev-&gt;state, hub-&gt;descriptor
 					? hub-&gt;descriptor-&gt;bNbrPorts
 					: 0,
 				/* NOTE: expects max 15 ports... */
 				(u16) hub-&gt;change_bits[0],
-				(u16) hub-&gt;event_bits[0],
-				i ? ", resume root" : "");
+				(u16) hub-&gt;event_bits[0]);
 
 		usb_get_intf(intf);
 		spin_unlock_irq(&amp;hub_event_lock);
@@ -2669,16 +2671,16 @@ static void hub_events(void)
 			goto loop;
 		}
 
-		/* Is this is a root hub wanting to reactivate the downstream
-		 * ports?  If so, be sure the interface resumes even if its
-		 * stub "device" node was never suspended.
-		 */
-		if (i)
-			usb_autoresume_device(hdev, 0);
+		/* Autoresume */
+		ret = usb_autopm_get_interface(intf);
+		if (ret) {
+			dev_dbg(hub_dev, "Can't autoresume: %d\n", ret);
+			goto loop;
+		}
 
-		/* If this is an inactive or suspended hub, do nothing */
+		/* If this is an inactive hub, do nothing */
 		if (hub-&gt;quiescing)
-			goto loop;
+			goto loop_autopm;
 
 		if (hub-&gt;error) {
 			dev_dbg (hub_dev, "resetting for error %d\n",
@@ -2688,7 +2690,7 @@ static void hub_events(void)
 			if (ret) {
 				dev_dbg (hub_dev,
 					"error resetting hub: %d\n", ret);
-				goto loop;
+				goto loop_autopm;
 			}
 
 			hub-&gt;nerrors = 0;
@@ -2816,6 +2818,10 @@ static void hub_events(void)
 		if (!hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 			usb_enable_root_hub_irq(hdev-&gt;bus);
 
+loop_autopm:
+		/* Allow autosuspend if we're not going to run again */
+		if (list_empty(&amp;hub-&gt;event_list))
+			usb_autopm_enable(intf);
 loop:
 		usb_unlock_device(hdev);
 		usb_put_intf(intf);
@@ -2857,6 +2863,7 @@ static struct usb_driver hub_driver = {
 	.post_reset =	hub_post_reset,
 	.ioctl =	hub_ioctl,
 	.id_table =	hub_id_table,
+	.supports_autosuspend =	1,
 };
 
 int usb_hub_init(void)</pre><hr><pre>commit 8c03356a559ced6fa78931f498193f776d67e445
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 9 14:42:16 2006 -0500

    EHCI: Fix root-hub and port suspend/resume problems
    
    This patch (as738b) fixes numerous problems in the controller/root-hub
    suspend/resume/remote-wakeup support in ehci-hcd:
    
            The bus_resume() routine should wake up only the ports that
            were suspended by bus_suspend().  Ports that were already
            suspended should remain that way.
    
            The interrupt mask is used to detect loss of power in the
            bus_resume() routine (if the mask is 0 then power was lost).
            However bus_suspend() always sets the mask to 0.  Instead the
            mask should retain its normal value, with port-change-detect
            interrupts disabled if remote wakeup is turned off.
    
            The interrupt mask should be reset to its correct value at the
            end of bus_resume() regardless of whether power was lost.
    
            bus_resume() reinitializes the operational registers if power
            was lost.  However those registers are not in the aux power
            well, hence they can lose their values whenever the controller
            is put into D3.  They should always be reinitialized.
    
            When a port-change interrupt occurs and the root hub is
            suspended, the interrupt handler should request a root-hub
            resume instead of starting up the controller all by itself.
    
            There's no need for the interrupt handler to request a
            root-hub resume every time a suspended port sends a
            remote-wakeup request.
    
            The pci_resume() method doesn't need to check for connected
            ports when deciding whether or not to reset the controller.
            It can make that decision based on whether Vaux power was
            maintained.
    
            Even when the controller does not need to be reset,
            pci_resume() must undo the effect of pci_suspend() by
            re-enabling the interrupt mask.
    
            If power was lost, pci_resume() must not call ehci_run().
            At this point the root hub is still supposed to be suspended,
            not running.  It's enough to rewrite the command register and
            set the configured_flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f2ceb5fdbeb7..025d33313681 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -619,9 +619,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		unsigned	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 
 		/* resume root hub? */
-		status = readl (&amp;ehci-&gt;regs-&gt;command);
-		if (!(status &amp; CMD_RUN))
-			writel (status | CMD_RUN, &amp;ehci-&gt;regs-&gt;command);
+		if (!(readl(&amp;ehci-&gt;regs-&gt;command) &amp; CMD_RUN))
+			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
 			int pstatus = readl (&amp;ehci-&gt;regs-&gt;port_status [i]);
@@ -638,7 +637,6 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			 */
 			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
-			usb_hcd_resume_root_hub(hcd);
 		}
 	}
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 0a56dfa2745d..bfe5f307cba6 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -34,6 +34,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	int			port;
+	int			mask;
 
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
@@ -51,14 +52,25 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		ehci-&gt;reclaim_ready = 1;
 	ehci_work(ehci);
 
-	/* suspend any active/unsuspended ports, maybe allow wakeup */
+	/* Unlike other USB host controller types, EHCI doesn't have
+	 * any notion of "global" or bus-wide suspend.  The driver has
+	 * to manually suspend all the active unsuspended ports, and
+	 * then manually resume them in the bus_resume() routine.
+	 */
+	ehci-&gt;bus_suspended = 0;
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
 		u32		t1 = readl (reg) &amp; ~PORT_RWC_BITS;
 		u32		t2 = t1;
 
-		if ((t1 &amp; PORT_PE) &amp;&amp; !(t1 &amp; PORT_OWNER))
+		/* keep track of which ports we suspend */
+		if ((t1 &amp; PORT_PE) &amp;&amp; !(t1 &amp; PORT_OWNER) &amp;&amp;
+				!(t1 &amp; PORT_SUSPEND)) {
 			t2 |= PORT_SUSPEND;
+			set_bit(port, &amp;ehci-&gt;bus_suspended);
+		}
+
+		/* enable remote wakeup on all ports */
 		if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
 			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
 		else
@@ -76,6 +88,13 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_halt (ehci);
 	hcd-&gt;state = HC_STATE_SUSPENDED;
 
+	/* allow remote wakeup */
+	mask = INTR_MASK;
+	if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+		mask &amp;= ~STS_PCD;
+	writel(mask, &amp;ehci-&gt;regs-&gt;intr_enable);
+	readl(&amp;ehci-&gt;regs-&gt;intr_enable);
+
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(10);
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	return 0;
@@ -88,7 +107,6 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
 	int			i;
-	int			intr_enable;
 
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
@@ -100,31 +118,30 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	 * the last user of the controller, not reset/pm hardware keeping
 	 * state we gave to it.
 	 */
+	temp = readl(&amp;ehci-&gt;regs-&gt;intr_enable);
+	ehci_dbg(ehci, "resume root hub%s\n", temp ? "" : " after power loss");
 
-	/* re-init operational registers in case we lost power */
-	if (readl (&amp;ehci-&gt;regs-&gt;intr_enable) == 0) {
-		/* at least some APM implementations will try to deliver
-		 * IRQs right away, so delay them until we're ready.
-		 */
-		intr_enable = 1;
-		writel (0, &amp;ehci-&gt;regs-&gt;segment);
-		writel (ehci-&gt;periodic_dma, &amp;ehci-&gt;regs-&gt;frame_list);
-		writel ((u32)ehci-&gt;async-&gt;qh_dma, &amp;ehci-&gt;regs-&gt;async_next);
-	} else
-		intr_enable = 0;
-	ehci_dbg(ehci, "resume root hub%s\n",
-			intr_enable ? " after power loss" : "");
+	/* at least some APM implementations will try to deliver
+	 * IRQs right away, so delay them until we're ready.
+	 */
+	writel(0, &amp;ehci-&gt;regs-&gt;intr_enable);
+
+	/* re-init operational registers */
+	writel(0, &amp;ehci-&gt;regs-&gt;segment);
+	writel(ehci-&gt;periodic_dma, &amp;ehci-&gt;regs-&gt;frame_list);
+	writel((u32) ehci-&gt;async-&gt;qh_dma, &amp;ehci-&gt;regs-&gt;async_next);
 
 	/* restore CMD_RUN, framelist size, and irq threshold */
 	writel (ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 
-	/* take ports out of suspend */
+	/* manually resume the ports we suspended during bus_suspend() */
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 	while (i--) {
 		temp = readl (&amp;ehci-&gt;regs-&gt;port_status [i]);
 		temp &amp;= ~(PORT_RWC_BITS
 			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
-		if (temp &amp; PORT_SUSPEND) {
+		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
+				(temp &amp; PORT_SUSPEND)) {
 			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
 			temp |= PORT_RESUME;
 		}
@@ -134,11 +151,12 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	mdelay (20);
 	while (i--) {
 		temp = readl (&amp;ehci-&gt;regs-&gt;port_status [i]);
-		if ((temp &amp; PORT_SUSPEND) == 0)
-			continue;
-		temp &amp;= ~(PORT_RWC_BITS | PORT_RESUME);
-		writel (temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
-		ehci_vdbg (ehci, "resumed port %d\n", i + 1);
+		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
+				(temp &amp; PORT_SUSPEND)) {
+			temp &amp;= ~(PORT_RWC_BITS | PORT_RESUME);
+			writel (temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
+			ehci_vdbg (ehci, "resumed port %d\n", i + 1);
+		}
 	}
 	(void) readl (&amp;ehci-&gt;regs-&gt;command);
 
@@ -157,8 +175,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	hcd-&gt;state = HC_STATE_RUNNING;
 
 	/* Now we can safely re-enable irqs */
-	if (intr_enable)
-		writel (INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
+	writel(INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	return 0;
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index e51c1ed81ac4..4bc7970ba3ef 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -257,9 +257,7 @@ static int ehci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 static int ehci_pci_resume(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
-	unsigned		port;
 	struct pci_dev		*pdev = to_pci_dev(hcd-&gt;self.controller);
-	int			retval = -EINVAL;
 
 	// maybe restore FLADJ
 
@@ -269,27 +267,19 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	/* Mark hardware accessible again as we are out of D3 state by now */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
-	/* If CF is clear, we lost PCI Vaux power and need to restart.  */
-	if (readl(&amp;ehci-&gt;regs-&gt;configured_flag) != FLAG_CF)
-		goto restart;
-
-	/* If any port is suspended (or owned by the companion),
-	 * we know we can/must resume the HC (and mustn't reset it).
-	 * We just defer that to the root hub code.
+	/* If CF is still set, we maintained PCI Vaux power.
+	 * Just undo the effect of ehci_pci_suspend().
 	 */
-	for (port = HCS_N_PORTS(ehci-&gt;hcs_params); port &gt; 0; ) {
-		u32	status;
-		port--;
-		status = readl(&amp;ehci-&gt;regs-&gt;port_status [port]);
-		if (!(status &amp; PORT_POWER))
-			continue;
-		if (status &amp; (PORT_SUSPEND | PORT_RESUME | PORT_OWNER)) {
-			usb_hcd_resume_root_hub(hcd);
-			return 0;
-		}
+	if (readl(&amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
+		int	mask = INTR_MASK;
+
+		if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+			mask &amp;= ~STS_PCD;
+		writel(mask, &amp;ehci-&gt;regs-&gt;intr_enable);
+		readl(&amp;ehci-&gt;regs-&gt;intr_enable);
+		return 0;
 	}
 
-restart:
 	ehci_dbg(ehci, "lost power, restarting\n");
 	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 
@@ -307,13 +297,15 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	ehci_work(ehci);
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
-	/* restart; khubd will disconnect devices */
-	retval = ehci_run(hcd);
-
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	return retval;
+	writel(ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+	writel(FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
+	readl(&amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
+
+	hcd-&gt;state = HC_STATE_SUSPENDED;
+	return 0;
 }
 #endif
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bbc3082a73d7..74dbc6c8228f 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -74,6 +74,7 @@ struct ehci_hcd {			/* one per controller */
 
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];
+	unsigned long		bus_suspended;
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 1f26e28d3e32339ca683f087cd55a70e2befc333
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 16 10:16:00 2006 -0500

    USB: net2280: don't send unwanted zero-length packets
    
    The net2280 driver is too eager to send zero-length packets when
    IN tokens are received on ep0.  No such packet should be sent (the
    driver should NAK) before the gadget driver has queued the proper
    response.  Otherwise deferred responses are impossible.
    
    This patch (as823) makes net2280 avoid sending ZLPs for IN transfers
    on ep0 until a response has been submitted, and avoids stalling when an
    OUT packet is received before a request has been submitted for an OUT
    transfer on ep0.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/net2280.c b/drivers/usb/gadget/net2280.c
index 3acc896a5d4c..0b590831582c 100644
--- a/drivers/usb/gadget/net2280.c
+++ b/drivers/usb/gadget/net2280.c
@@ -1040,6 +1040,7 @@ net2280_queue (struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 
 	} /* else the irq handler advances the queue. */
 
+	ep-&gt;responded = 1;
 	if (req)
 		list_add_tail (&amp;req-&gt;queue, &amp;ep-&gt;queue);
 done:
@@ -2188,7 +2189,8 @@ static void handle_ep_small (struct net2280_ep *ep)
 					ep-&gt;stopped = 1;
 					set_halt (ep);
 					mode = 2;
-				} else if (!req &amp;&amp; !ep-&gt;stopped)
+				} else if (ep-&gt;responded &amp;&amp;
+						!req &amp;&amp; !ep-&gt;stopped)
 					write_fifo (ep, NULL);
 			}
 		} else {
@@ -2203,7 +2205,7 @@ static void handle_ep_small (struct net2280_ep *ep)
 			} else if (((t &amp; (1 &lt;&lt; DATA_OUT_PING_TOKEN_INTERRUPT))
 					&amp;&amp; req
 					&amp;&amp; req-&gt;req.actual == req-&gt;req.length)
-					|| !req) {
+					|| (ep-&gt;responded &amp;&amp; !req)) {
 				ep-&gt;dev-&gt;protocol_stall = 1;
 				set_halt (ep);
 				ep-&gt;stopped = 1;
@@ -2469,6 +2471,7 @@ static void handle_stat0_irqs (struct net2280 *dev, u32 stat)
 		/* we made the hardware handle most lowlevel requests;
 		 * everything else goes uplevel to the gadget code.
 		 */
+		ep-&gt;responded = 1;
 		switch (u.r.bRequest) {
 		case USB_REQ_GET_STATUS: {
 			struct net2280_ep	*e;
@@ -2537,6 +2540,7 @@ static void handle_stat0_irqs (struct net2280 *dev, u32 stat)
 				u.r.bRequestType, u.r.bRequest,
 				w_value, w_index, w_length,
 				readl (&amp;ep-&gt;regs-&gt;ep_cfg));
+			ep-&gt;responded = 0;
 			spin_unlock (&amp;dev-&gt;lock);
 			tmp = dev-&gt;driver-&gt;setup (&amp;dev-&gt;gadget, &amp;u.r);
 			spin_lock (&amp;dev-&gt;lock);
diff --git a/drivers/usb/gadget/net2280.h b/drivers/usb/gadget/net2280.h
index 957d6df34015..44ca139983d8 100644
--- a/drivers/usb/gadget/net2280.h
+++ b/drivers/usb/gadget/net2280.h
@@ -110,7 +110,8 @@ struct net2280_ep {
 						out_overflow : 1,
 						stopped : 1,
 						is_in : 1,
-						is_iso : 1;
+						is_iso : 1,
+						responded : 1;
 };
 
 static inline void allow_status (struct net2280_ep *ep)</pre><hr><pre>commit db063507b40664de33a61161c90358fe6fc9565a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 13 15:02:04 2006 -0500

    USB core: fix compiler warning about usb_autosuspend_work
    
    This patch (as821) fixes a compiler warning when CONFIG_PM isn't on
    ("usb_autosuspend_work" defined but not used).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index a83c2d5065c1..81cb52564e68 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -200,13 +200,6 @@ static void ksuspend_usb_cleanup(void)
 	destroy_workqueue(ksuspend_usb_wq);
 }
 
-#else
-
-#define ksuspend_usb_init()	0
-#define ksuspend_usb_cleanup()	do {} while (0)
-
-#endif
-
 #ifdef	CONFIG_USB_SUSPEND
 
 /* usb_autosuspend_work - callback routine to autosuspend a USB device */
@@ -225,7 +218,14 @@ static void usb_autosuspend_work(void *_udev)
 static void usb_autosuspend_work(void *_udev)
 {}
 
-#endif
+#endif	/* CONFIG_USB_SUSPEND */
+
+#else
+
+#define ksuspend_usb_init()	0
+#define ksuspend_usb_cleanup()	do {} while (0)
+
+#endif	/* CONFIG_PM */
 
 /**
  * usb_alloc_dev - usb device constructor (usbcore-internal)</pre><hr><pre>commit 1b7be3c066ae9238996a7a861b39b0bfd5860735
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 6 12:05:00 2006 -0500

    OHCI: change priority level of resume log message
    
    All the other root-hub suspend or resume log messages, in ohci-hcd or
    any of the other host controller drivers, use the debug priority
    level.  This patch (as815) makes the one single exception behave like
    all the rest.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index dcf9eb601328..4c9492779ede 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -175,7 +175,7 @@ __acquires(ohci-&gt;lock)
 		break;
 	case OHCI_USB_RESUME:
 		/* HCFS changes sometime after INTR_RD */
-		ohci_info(ohci, "%swakeup\n",
+		ohci_dbg(ohci, "%swakeup root hub\n",
 				autostopped ? "auto-" : "");
 		break;
 	case OHCI_USB_OPER:</pre><hr><pre>commit 1bb5f66bb3b6c2fd7eec1cdfee9cf3f68ef83487
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 6 11:56:13 2006 -0500

    USB: Move private hub declarations out of public header file
    
    This patch (as809b) moves the declaration of the hub driver's private
    data structure from hub.h into the hub.c source file.  Lots of other
    files import hub.h; they have no need to know about the details of the
    hub driver's private data.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c91745def9e7..c961a32f3176 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -31,6 +31,48 @@
 #include "hcd.h"
 #include "hub.h"
 
+struct usb_hub {
+	struct device		*intfdev;	/* the "interface" device */
+	struct usb_device	*hdev;
+	struct urb		*urb;		/* for interrupt polling pipe */
+
+	/* buffer for urb ... with extra space in case of babble */
+	char			(*buffer)[8];
+	dma_addr_t		buffer_dma;	/* DMA address for buffer */
+	union {
+		struct usb_hub_status	hub;
+		struct usb_port_status	port;
+	}			*status;	/* buffer for status reports */
+
+	int			error;		/* last reported error */
+	int			nerrors;	/* track consecutive errors */
+
+	struct list_head	event_list;	/* hubs w/data or errs ready */
+	unsigned long		event_bits[1];	/* status change bitmask */
+	unsigned long		change_bits[1];	/* ports with logical connect
+							status change */
+	unsigned long		busy_bits[1];	/* ports being reset or
+							resumed */
+#if USB_MAXCHILDREN &gt; 31 /* 8*sizeof(unsigned long) - 1 */
+#error event_bits[] is too short!
+#endif
+
+	struct usb_hub_descriptor *descriptor;	/* class descriptor */
+	struct usb_tt		tt;		/* Transaction Translator */
+
+	unsigned		mA_per_port;	/* current for each child */
+
+	unsigned		limited_power:1;
+	unsigned		quiescing:1;
+	unsigned		activating:1;
+	unsigned		resume_root_hub:1;
+
+	unsigned		has_indicators:1;
+	u8			indicator[USB_MAXCHILDREN];
+	struct work_struct	leds;
+};
+
+
 /* Protect struct usb_device-&gt;state and -&gt;children members
  * Note: Both are also protected by -&gt;dev.sem, except that -&gt;state can
  * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 1b05994de4dc..cf9559c6c9b6 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -192,45 +192,4 @@ struct usb_tt_clear {
 
 extern void usb_hub_tt_clear_buffer (struct usb_device *dev, int pipe);
 
-struct usb_hub {
-	struct device		*intfdev;	/* the "interface" device */
-	struct usb_device	*hdev;
-	struct urb		*urb;		/* for interrupt polling pipe */
-
-	/* buffer for urb ... with extra space in case of babble */
-	char			(*buffer)[8];
-	dma_addr_t		buffer_dma;	/* DMA address for buffer */
-	union {
-		struct usb_hub_status	hub;
-		struct usb_port_status	port;
-	}			*status;	/* buffer for status reports */
-
-	int			error;		/* last reported error */
-	int			nerrors;	/* track consecutive errors */
-
-	struct list_head	event_list;	/* hubs w/data or errs ready */
-	unsigned long		event_bits[1];	/* status change bitmask */
-	unsigned long		change_bits[1];	/* ports with logical connect
-							status change */
-	unsigned long		busy_bits[1];	/* ports being reset or
-							resumed */
-#if USB_MAXCHILDREN &gt; 31 /* 8*sizeof(unsigned long) - 1 */
-#error event_bits[] is too short!
-#endif
-
-	struct usb_hub_descriptor *descriptor;	/* class descriptor */
-	struct usb_tt		tt;		/* Transaction Translator */
-
-	unsigned		mA_per_port;	/* current for each child */
-
-	unsigned		limited_power:1;
-	unsigned		quiescing:1;
-	unsigned		activating:1;
-	unsigned		resume_root_hub:1;
-
-	unsigned		has_indicators:1;
-	u8			indicator[USB_MAXCHILDREN];
-	struct work_struct	leds;
-};
-
 #endif /* __LINUX_HUB_H */</pre><hr><pre>commit 692a186c9d5f12d43cef28d40c25247dc4f302f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 30 17:07:51 2006 -0500

    USB: expand autosuspend/autoresume API
    
    This patch (as814) adds usb_autopm_set_interface() to the autosuspend
    API.  It also provides convenient wrapper routines,
    usb_autopm_enable() and usb_autopm_disable(), for drivers that want
    to specify directly whether autosuspend should be allowed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ca0e40ed2b72..204495fa6b3d 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1322,6 +1322,28 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
 
+/**
+ * usb_autopm_set_interface - set a USB interface's autosuspend state
+ * @intf: the usb_interface whose state should be set
+ *
+ * This routine sets the autosuspend state of @intf's device according
+ * to @intf's usage counter, which the caller must have set previously.
+ * If the counter is &lt;= 0, the device is autosuspended (if it isn't
+ * already suspended and if nothing else prevents the autosuspend).  If
+ * the counter is &gt; 0, the device is autoresumed (if it isn't already
+ * awake).
+ */
+int usb_autopm_set_interface(struct usb_interface *intf)
+{
+	int	status;
+
+	status = usb_autopm_do_interface(intf, 0);
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
+	return status;
+}
+EXPORT_SYMBOL_GPL(usb_autopm_set_interface);
+
 #endif /* CONFIG_USB_SUSPEND */
 
 static int usb_suspend(struct device *dev, pm_message_t message)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index e732e024a141..864c6c21c21e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -415,14 +415,37 @@ extern struct usb_device *usb_find_device(u16 vendor_id, u16 product_id);
 
 /* USB autosuspend and autoresume */
 #ifdef CONFIG_USB_SUSPEND
+extern int usb_autopm_set_interface(struct usb_interface *intf);
 extern int usb_autopm_get_interface(struct usb_interface *intf);
 extern void usb_autopm_put_interface(struct usb_interface *intf);
 
+static inline void usb_autopm_enable(struct usb_interface *intf)
+{
+	intf-&gt;pm_usage_cnt = 0;
+	usb_autopm_set_interface(intf);
+}
+
+static inline void usb_autopm_disable(struct usb_interface *intf)
+{
+	intf-&gt;pm_usage_cnt = 1;
+	usb_autopm_set_interface(intf);
+}
+
 #else
-#define usb_autopm_get_interface(intf)		0
-#define usb_autopm_put_interface(intf)		do {} while (0)
-#endif
 
+static inline int usb_autopm_set_interface(struct usb_interface *intf)
+{ return 0; }
+
+static inline int usb_autopm_get_interface(struct usb_interface *intf)
+{ return 0; }
+
+static inline void usb_autopm_put_interface(struct usb_interface *intf)
+{ }
+static inline void usb_autopm_enable(struct usb_interface *intf)
+{ }
+static inline void usb_autopm_disable(struct usb_interface *intf)
+{ }
+#endif
 
 /*-------------------------------------------------------------------------*/
 </pre><hr><pre>commit af4f76066d0fcb215ae389b8839d7ae37ce0e28b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 30 17:06:45 2006 -0500

    USB: autosuspend code consolidation
    
    This patch (as813) gathers together common code for USB interface
    autosuspend/autoresume.
    
    It also adds some simple checking at the time an autosuspend request
    is made, to see whether the request will fail.  This way we don't
    add a workqueue entry when it would end up doing nothing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 401d76f13419..ca0e40ed2b72 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -940,6 +940,36 @@ static int resume_interface(struct usb_interface *intf)
 	return status;
 }
 
+/* Internal routine to check whether we may autosuspend a device. */
+static int autosuspend_check(struct usb_device *udev)
+{
+	int			i;
+	struct usb_interface	*intf;
+
+	/* For autosuspend, fail fast if anything is in use.
+	 * Also fail if any interfaces require remote wakeup but it
+	 * isn't available. */
+	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
+	if (udev-&gt;pm_usage_cnt &gt; 0)
+		return -EBUSY;
+	if (udev-&gt;actconfig) {
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			if (!is_active(intf))
+				continue;
+			if (intf-&gt;pm_usage_cnt &gt; 0)
+				return -EBUSY;
+			if (intf-&gt;needs_remote_wakeup &amp;&amp;
+					!udev-&gt;do_remote_wakeup) {
+				dev_dbg(&amp;udev-&gt;dev, "remote wakeup needed "
+						"for autosuspend\n");
+				return -EOPNOTSUPP;
+			}
+		}
+	}
+	return 0;
+}
+
 /**
  * usb_suspend_both - suspend a USB device and its interfaces
  * @udev: the usb_device to suspend
@@ -991,28 +1021,10 @@ int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 
 	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 
-	/* For autosuspend, fail fast if anything is in use.
-	 * Also fail if any interfaces require remote wakeup but it
-	 * isn't available. */
 	if (udev-&gt;auto_pm) {
-		if (udev-&gt;pm_usage_cnt &gt; 0)
-			return -EBUSY;
-		if (udev-&gt;actconfig) {
-			for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-				intf = udev-&gt;actconfig-&gt;interface[i];
-				if (!is_active(intf))
-					continue;
-				if (intf-&gt;pm_usage_cnt &gt; 0)
-					return -EBUSY;
-				if (intf-&gt;needs_remote_wakeup &amp;&amp;
-						!udev-&gt;do_remote_wakeup) {
-					dev_dbg(&amp;udev-&gt;dev,
-	"remote wakeup needed for autosuspend\n");
-					return -EOPNOTSUPP;
-				}
-			}
-			i = 0;
-		}
+		status = autosuspend_check(udev);
+		if (status &lt; 0)
+			return status;
 	}
 
 	/* Suspend all the interfaces and then udev itself */
@@ -1151,7 +1163,7 @@ void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 {
 	usb_pm_lock(udev);
 	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
-	if (udev-&gt;pm_usage_cnt &lt;= 0)
+	if (autosuspend_check(udev) == 0)
 		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 				USB_AUTOSUSPEND_DELAY);
 	usb_pm_unlock(udev);
@@ -1200,6 +1212,33 @@ int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
 	return status;
 }
 
+/* Internal routine to adjust an interface's usage counter and change
+ * its device's autosuspend state.
+ */
+static int usb_autopm_do_interface(struct usb_interface *intf,
+		int inc_usage_cnt)
+{
+	struct usb_device	*udev = interface_to_usbdev(intf);
+	int			status = 0;
+
+	usb_pm_lock(udev);
+	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
+		status = -ENODEV;
+	else {
+		intf-&gt;pm_usage_cnt += inc_usage_cnt;
+		if (inc_usage_cnt &gt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &gt; 0) {
+			udev-&gt;auto_pm = 1;
+			status = usb_resume_both(udev);
+			if (status != 0)
+				intf-&gt;pm_usage_cnt -= inc_usage_cnt;
+		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; autosuspend_check(udev) == 0)
+			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
+					USB_AUTOSUSPEND_DELAY);
+	}
+	usb_pm_unlock(udev);
+	return status;
+}
+
 /**
  * usb_autopm_put_interface - decrement a USB interface's PM-usage counter
  * @intf: the usb_interface whose counter should be decremented
@@ -1233,17 +1272,11 @@ int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
  */
 void usb_autopm_put_interface(struct usb_interface *intf)
 {
-	struct usb_device	*udev = interface_to_usbdev(intf);
+	int	status;
 
-	usb_pm_lock(udev);
-	if (intf-&gt;condition != USB_INTERFACE_UNBOUND &amp;&amp;
-			--intf-&gt;pm_usage_cnt &lt;= 0) {
-		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
-				USB_AUTOSUSPEND_DELAY);
-	}
-	usb_pm_unlock(udev);
-	// dev_dbg(&amp;intf-&gt;dev, "%s: cnt %d\n",
-	//		__FUNCTION__, intf-&gt;pm_usage_cnt);
+	status = usb_autopm_do_interface(intf, -1);
+	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
 
@@ -1280,20 +1313,9 @@ EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
  */
 int usb_autopm_get_interface(struct usb_interface *intf)
 {
-	struct usb_device	*udev = interface_to_usbdev(intf);
-	int			status;
+	int	status;
 
-	usb_pm_lock(udev);
-	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
-		status = -ENODEV;
-	else {
-		++intf-&gt;pm_usage_cnt;
-		udev-&gt;auto_pm = 1;
-		status = usb_resume_both(udev);
-		if (status != 0)
-			--intf-&gt;pm_usage_cnt;
-	}
-	usb_pm_unlock(udev);
+	status = usb_autopm_do_interface(intf, 1);
 	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;</pre><hr><pre>commit 565402baee99096da4d79209e450fe42d379a0ca
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 27 10:35:01 2006 -0400

    USB: OHCI: remove stale testing code from root-hub resume
    
    This patch (as811) removes some stale testing code from the root-hub
    resume routine in ohci-hcd.  It also adds a spin_lock_irq() call that
    inadvertently got left out of an error pathway.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 1e5ed3bb1a93..dcf9eb601328 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -204,18 +204,6 @@ __acquires(ohci-&gt;lock)
 		goto skip_resume;
 	spin_unlock_irq (&amp;ohci-&gt;lock);
 
-	temp = ohci-&gt;num_ports;
-	while (temp--) {
-		u32 stat = ohci_readl (ohci,
-				       &amp;ohci-&gt;regs-&gt;roothub.portstatus [temp]);
-
-		/* force global, not selective, resume */
-		if (!(stat &amp; RH_PS_PSS))
-			continue;
-		ohci_writel (ohci, RH_PS_POCI,
-				&amp;ohci-&gt;regs-&gt;roothub.portstatus [temp]);
-	}
-
 	/* Some controllers (lucent erratum) need extra-long delays */
 	msleep (20 /* usb 11.5.1.10 */ + 12 /* 32 msec counter */ + 1);
 
@@ -223,6 +211,7 @@ __acquires(ohci-&gt;lock)
 	temp &amp;= OHCI_CTRL_HCFS;
 	if (temp != OHCI_USB_RESUME) {
 		ohci_err (ohci, "controller won't resume\n");
+		spin_lock_irq(&amp;ohci-&gt;lock);
 		return -EBUSY;
 	}
 </pre><hr><pre>commit 052ac01aeb84d8427ba8ac3d70991ac01b009b59
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 27 10:33:11 2006 -0400

    USB: OHCI: disable RHSC inside interrupt handler
    
    This patch (as808b) moves the Root Hub Status Change interrupt-disable
    code in ohci-hcd back into the interrupt handler proper, to avoid the
    chance of adverse interactions with mediocre hardware implementations.
    
    It also deletes the root-hub status timer from within the interrupt-enable
    routine.  There's no need to poll for status any more once interrupts are
    re-enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index ea4714e557e4..a95275a401b1 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -729,6 +729,16 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		ohci-&gt;next_statechange = jiffies + STATECHANGE_DELAY;
 		ohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,
 				&amp;regs-&gt;intrstatus);
+
+		/* NOTE: Vendors didn't always make the same implementation
+		 * choices for RHSC.  Many followed the spec; RHSC triggers
+		 * on an edge, like setting and maybe clearing a port status
+		 * change bit.  With others it's level-triggered, active
+		 * until khubd clears all the port status change bits.  We'll
+		 * always disable it here and rely on polling until khubd
+		 * re-enables it.
+		 */
+		ohci_writel(ohci, OHCI_INTR_RHSC, &amp;regs-&gt;intrdisable);
 		usb_hcd_poll_rh_status(hcd);
 	}
 
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 99357b99d133..1e5ed3bb1a93 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -41,7 +41,11 @@ static void ohci_rhsc_enable (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 
-	ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
+	spin_lock_irq(&amp;ohci-&gt;lock);
+	if (!ohci-&gt;autostop)
+		del_timer(&amp;hcd-&gt;rh_timer);	/* Prevent next poll */
+	ohci_writel(ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
+	spin_unlock_irq(&amp;ohci-&gt;lock);
 }
 
 #define OHCI_SCHED_ENABLES \
@@ -348,7 +352,7 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 {
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		i, changed = 0, length = 1;
-	int		any_connected = 0, rhsc_enabled = 1;
+	int		any_connected = 0;
 	unsigned long	flags;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
@@ -389,19 +393,6 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		}
 	}
 
-	/* NOTE:  vendors didn't always make the same implementation
-	 * choices for RHSC.  Sometimes it triggers on an edge (like
-	 * setting and maybe clearing a port status change bit); and
-	 * it's level-triggered on other silicon, active until khubd
-	 * clears all active port status change bits.  If it's still
-	 * set (level-triggered) we must disable it and rely on
-	 * polling until khubd re-enables it.
-	 */
-	if (ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp; OHCI_INTR_RHSC) {
-		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
-		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;intrdisable);
-		rhsc_enabled = 0;
-	}
 	hcd-&gt;poll_rh = 1;
 
 	/* carry out appropriate state changes */
@@ -412,7 +403,8 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		 * and RHSC is enabled */
 		if (!ohci-&gt;autostop) {
 			if (any_connected) {
-				if (rhsc_enabled)
+				if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
+						OHCI_INTR_RHSC)
 					hcd-&gt;poll_rh = 0;
 			} else {
 				ohci-&gt;autostop = 1;</pre>
    <div class="pagination">
        <a href='2_115.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><span>[116]</span><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_117.html'>Next&gt;&gt;</a>
    <div>
</body>
