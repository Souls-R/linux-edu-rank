<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_87.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><span>[88]</span><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_89.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 503358ae01b70ce6909d19dd01287093f6b6271c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Nov 23 07:24:46 2009 -0500

    ext4: avoid divide by zero when trying to mount a corrupted file system
    
    If s_log_groups_per_flex is greater than 31, then groups_per_flex will
    will overflow and cause a divide by zero error.  This can cause kernel
    BUG if such a file system is mounted.
    
    Thanks to Nageswara R Sastry for analyzing the failure and providing
    an initial patch.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=14287
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@kernel.org

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index d4ca92aab514..8662b2e6e9f9 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1673,14 +1673,14 @@ static int ext4_fill_flex_info(struct super_block *sb)
 	size_t size;
 	int i;
 
-	if (!sbi-&gt;s_es-&gt;s_log_groups_per_flex) {
+	sbi-&gt;s_log_groups_per_flex = sbi-&gt;s_es-&gt;s_log_groups_per_flex;
+	groups_per_flex = 1 &lt;&lt; sbi-&gt;s_log_groups_per_flex;
+
+	if (groups_per_flex &lt; 2) {
 		sbi-&gt;s_log_groups_per_flex = 0;
 		return 1;
 	}
 
-	sbi-&gt;s_log_groups_per_flex = sbi-&gt;s_es-&gt;s_log_groups_per_flex;
-	groups_per_flex = 1 &lt;&lt; sbi-&gt;s_log_groups_per_flex;
-
 	/* We allocate both existing and potentially added groups */
 	flex_group_count = ((sbi-&gt;s_groups_count + groups_per_flex - 1) +
 			((le16_to_cpu(sbi-&gt;s_es-&gt;s_reserved_gdt_blocks) + 1) &lt;&lt;</pre><hr><pre>commit 2de770a406b06dfc619faabbf5d85c835ed3f2e1
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Nov 23 07:25:49 2009 -0500

    ext4: fix potential buffer head leak when add_dirent_to_buf() returns ENOSPC
    
    Previously add_dirent_to_buf() did not free its passed-in buffer head
    in the case of ENOSPC, since in some cases the caller still needed it.
    However, this led to potential buffer head leaks since not all callers
    dealt with this correctly.  Fix this by making simplifying the freeing
    convention; now add_dirent_to_buf() *never* frees the passed-in buffer
    head, and leaves that to the responsibility of its caller.  This makes
    things cleaner and easier to prove that the code is neither leaking
    buffer heads or calling brelse() one time too many.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Curt Wohlgemuth &lt;curtw@google.com&gt;
    Cc: stable@kernel.org

diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 6d2c1b897fc7..fde08c919d12 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -1292,9 +1292,6 @@ static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,
  * add_dirent_to_buf will attempt search the directory block for
  * space.  It will return -ENOSPC if no space is available, and -EIO
  * and -EEXIST if directory entry already exists.
- *
- * NOTE!  bh is NOT released in the case where ENOSPC is returned.  In
- * all other cases bh is released.
  */
 static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 			     struct inode *inode, struct ext4_dir_entry_2 *de,
@@ -1315,14 +1312,10 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 		top = bh-&gt;b_data + blocksize - reclen;
 		while ((char *) de &lt;= top) {
 			if (!ext4_check_dir_entry("ext4_add_entry", dir, de,
-						  bh, offset)) {
-				brelse(bh);
+						  bh, offset))
 				return -EIO;
-			}
-			if (ext4_match(namelen, name, de)) {
-				brelse(bh);
+			if (ext4_match(namelen, name, de))
 				return -EEXIST;
-			}
 			nlen = EXT4_DIR_REC_LEN(de-&gt;name_len);
 			rlen = ext4_rec_len_from_disk(de-&gt;rec_len, blocksize);
 			if ((de-&gt;inode? rlen - nlen: rlen) &gt;= reclen)
@@ -1337,7 +1330,6 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 	err = ext4_journal_get_write_access(handle, bh);
 	if (err) {
 		ext4_std_error(dir-&gt;i_sb, err);
-		brelse(bh);
 		return err;
 	}
 
@@ -1377,7 +1369,6 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 	err = ext4_handle_dirty_metadata(handle, dir, bh);
 	if (err)
 		ext4_std_error(dir-&gt;i_sb, err);
-	brelse(bh);
 	return 0;
 }
 
@@ -1471,7 +1462,9 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	if (!(de))
 		return retval;
 
-	return add_dirent_to_buf(handle, dentry, inode, de, bh);
+	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	brelse(bh);
+	return retval;
 }
 
 /*
@@ -1514,8 +1507,10 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 		if(!bh)
 			return retval;
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
-		if (retval != -ENOSPC)
+		if (retval != -ENOSPC) {
+			brelse(bh);
 			return retval;
+		}
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
 		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))
@@ -1528,7 +1523,9 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 	de = (struct ext4_dir_entry_2 *) bh-&gt;b_data;
 	de-&gt;inode = 0;
 	de-&gt;rec_len = ext4_rec_len_to_disk(blocksize, blocksize);
-	return add_dirent_to_buf(handle, dentry, inode, de, bh);
+	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	brelse(bh);
+	return retval;
 }
 
 /*
@@ -1561,10 +1558,8 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 		goto journal_error;
 
 	err = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
-	if (err != -ENOSPC) {
-		bh = NULL;
+	if (err != -ENOSPC)
 		goto cleanup;
-	}
 
 	/* Block full, should compress but for now just split */
 	dxtrace(printk(KERN_DEBUG "using %u of %u node entries\n",
@@ -1657,7 +1652,6 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	if (!de)
 		goto cleanup;
 	err = add_dirent_to_buf(handle, dentry, inode, de, bh);
-	bh = NULL;
 	goto cleanup;
 
 journal_error:</pre><hr><pre>commit 1e424a348303694fabdf8b1efbfcb1a892dfa63a
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Nov 8 15:45:44 2009 -0500

    ext4: partial revert to fix double brelse WARNING()
    
    This is a partial revert of commit 6487a9d (only the changes made to
    fs/ext4/namei.c), since it is causing the following brelse()
    double-free warning when running fsstress on a file system with 1k
    blocksize and we run into a block allocation failure while converting
    a single-block directory to a multi-block hash-tree indexed directory.
    
    WARNING: at fs/buffer.c:1197 __brelse+0x2e/0x33()
    Hardware name:
    VFS: brelse: Trying to free free buffer
    Modules linked in:
    Pid: 2226, comm: jbd2/sdd-8 Not tainted 2.6.32-rc6-00577-g0003f55 #101
    Call Trace:
     [&lt;c01587fb&gt;] warn_slowpath_common+0x65/0x95
     [&lt;c0158869&gt;] warn_slowpath_fmt+0x29/0x2c
     [&lt;c021168e&gt;] __brelse+0x2e/0x33
     [&lt;c0288a9f&gt;] jbd2_journal_refile_buffer+0x67/0x6c
     [&lt;c028a9ed&gt;] jbd2_journal_commit_transaction+0x319/0x14d8
     [&lt;c0164d73&gt;] ? try_to_del_timer_sync+0x58/0x60
     [&lt;c0175bcc&gt;] ? sched_clock_cpu+0x12a/0x13e
     [&lt;c017f6b4&gt;] ? trace_hardirqs_off+0xb/0xd
     [&lt;c0175c1f&gt;] ? cpu_clock+0x3f/0x5b
     [&lt;c017f6ec&gt;] ? lock_release_holdtime+0x36/0x137
     [&lt;c0664ad0&gt;] ? _spin_unlock_irqrestore+0x44/0x51
     [&lt;c0180af3&gt;] ? trace_hardirqs_on_caller+0x103/0x124
     [&lt;c0180b1f&gt;] ? trace_hardirqs_on+0xb/0xd
     [&lt;c0164d73&gt;] ? try_to_del_timer_sync+0x58/0x60
     [&lt;c0290d1c&gt;] kjournald2+0x11a/0x310
     [&lt;c017118e&gt;] ? autoremove_wake_function+0x0/0x38
     [&lt;c0290c02&gt;] ? kjournald2+0x0/0x310
     [&lt;c0170ee6&gt;] kthread+0x66/0x6b
     [&lt;c0170e80&gt;] ? kthread+0x0/0x6b
     [&lt;c01251b3&gt;] kernel_thread_helper+0x7/0x10
    ---[ end trace 5579351b86af61e3 ]---
    
    Commit 6487a9d was an attempt some buffer head leaks in an ENOSPC
    error path, but in some cases it actually results in an excess ENOSPC,
    as shown above.  Fixing this means cleaning up who is responsible for
    releasing the buffer heads from the callee to the caller of
    add_dirent_to_buf().
    
    Since that's a relatively complex change, and we're late in the rcX
    development cycle, I'm reverting this now, and holding back a more
    complete fix until after 2.6.32 ships.  We've lived with this
    buffer_head leak on ENOSPC in ext3 and ext4 for a very long time; a
    few more months won't kill us.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Curt Wohlgemuth &lt;curtw@google.com&gt;

diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 7c8fe80bacdd..6d2c1b897fc7 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -1518,12 +1518,8 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 			return retval;
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {
-			retval = make_indexed_dir(handle, dentry, inode, bh);
-			if (retval == -ENOSPC)
-				brelse(bh);
-			return retval;
-		}
+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))
+			return make_indexed_dir(handle, dentry, inode, bh);
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block, &amp;retval);
@@ -1532,10 +1528,7 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 	de = (struct ext4_dir_entry_2 *) bh-&gt;b_data;
 	de-&gt;inode = 0;
 	de-&gt;rec_len = ext4_rec_len_to_disk(blocksize, blocksize);
-	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
-	if (retval == -ENOSPC)
-		brelse(bh);
-	return retval;
+	return add_dirent_to_buf(handle, dentry, inode, de, bh);
 }
 
 /*
@@ -1664,8 +1657,7 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	if (!de)
 		goto cleanup;
 	err = add_dirent_to_buf(handle, dentry, inode, de, bh);
-	if (err != -ENOSPC)
-		bh = NULL;
+	bh = NULL;
 	goto cleanup;
 
 journal_error:</pre><hr><pre>commit 181a5336d6cc836f05507410d66988c483ad0154
Author: Andy Lutomirski &lt;luto@mit.edu&gt;
Date:   Tue Oct 13 10:40:52 2009 -0700

    drm/i915: Fix render reclock availability detection.
    
    If the device didn't support EDP, we would bail out too soon.
    
    Signed-off-by: Andy Lutomirski &lt;luto@mit.edu&gt;
    [anholt: Pulled this patch out of the patch for adding quirks to
    enable reclocking.]
    Signed-off-by: Eric Anholt &lt;eric@anholt.net&gt;

diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c
index 4337414846b6..96cd256e60e6 100644
--- a/drivers/gpu/drm/i915/intel_bios.c
+++ b/drivers/gpu/drm/i915/intel_bios.c
@@ -351,20 +351,18 @@ parse_driver_features(struct drm_i915_private *dev_priv,
 	struct drm_device *dev = dev_priv-&gt;dev;
 	struct bdb_driver_features *driver;
 
-	/* set default for chips without eDP */
-	if (!SUPPORTS_EDP(dev)) {
-		dev_priv-&gt;edp_support = 0;
-		return;
-	}
-
 	driver = find_section(bdb, BDB_DRIVER_FEATURES);
 	if (!driver)
 		return;
 
-	if (driver-&gt;lvds_config == BDB_DRIVER_FEATURE_EDP)
+	if (driver &amp;&amp; SUPPORTS_EDP(dev) &amp;&amp;
+	    driver-&gt;lvds_config == BDB_DRIVER_FEATURE_EDP) {
 		dev_priv-&gt;edp_support = 1;
+	} else {
+		dev_priv-&gt;edp_support = 0;
+	}
 
-	if (driver-&gt;dual_frequency)
+	if (driver &amp;&amp; driver-&gt;dual_frequency)
 		dev_priv-&gt;render_reclock_avail = true;
 }
 </pre><hr><pre>commit 96ec2e0a719fd61791dd2b0dd01325c5d20e1233
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Sep 16 11:21:13 2009 -0400

    ext3: Don't update superblock write time when filesystem is read-only
    
    This avoids updating the superblock write time when we are mounting
    the root file system read/only but we need to replay the journal; at
    that point, for people who are east of GMT and who make their clock
    tick in localtime for Windows bug-for-bug compatibility, and this will
    cause e2fsck to complain and force a full file system check.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Signed-off-by: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index 72743d360509..7a520a862f49 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -2321,7 +2321,18 @@ static int ext3_commit_super(struct super_block *sb,
 
 	if (!sbh)
 		return error;
-	es-&gt;s_wtime = cpu_to_le32(get_seconds());
+	/*
+	 * If the file system is mounted read-only, don't update the
+	 * superblock write time.  This avoids updating the superblock
+	 * write time when we are mounting the root file system
+	 * read/only but we need to replay the journal; at that point,
+	 * for people who are east of GMT and who make their clock
+	 * tick in localtime for Windows bug-for-bug compatibility,
+	 * the clock is set in the future, and this will cause e2fsck
+	 * to complain and force a full file system check.
+	 */
+	if (!(sb-&gt;s_flags &amp; MS_RDONLY))
+		es-&gt;s_wtime = cpu_to_le32(get_seconds());
 	es-&gt;s_free_blocks_count = cpu_to_le32(ext3_count_free_blocks(sb));
 	es-&gt;s_free_inodes_count = cpu_to_le32(ext3_count_free_inodes(sb));
 	BUFFER_TRACE(sbh, "marking dirty");</pre><hr><pre>commit 1f94533d9cd75f6d2826018d54a971b9cc085992
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Sep 30 22:57:41 2009 -0400

    ext4: fix a BUG_ON crash by checking that page has buffers attached to it
    
    In ext4_num_dirty_pages() we were calling page_buffers() before
    checking to see if the page actually had pages attached to it; this
    would cause a BUG check crash in the inline function page_buffers().
    
    Thanks to Markus Trippelsdorf for reporting this bug.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index ec367bce7215..6e65d0e25ed3 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1146,8 +1146,8 @@ static int check_block_validity(struct inode *inode, const char *msg,
 }
 
 /*
- * Return the number of dirty pages in the given inode starting at
- * page frame idx.
+ * Return the number of contiguous dirty pages in a given inode
+ * starting at page frame idx.
  */
 static pgoff_t ext4_num_dirty_pages(struct inode *inode, pgoff_t idx,
 				    unsigned int max_pages)
@@ -1181,15 +1181,15 @@ static pgoff_t ext4_num_dirty_pages(struct inode *inode, pgoff_t idx,
 				unlock_page(page);
 				break;
 			}
-			head = page_buffers(page);
-			bh = head;
-			do {
-				if (!buffer_delay(bh) &amp;&amp;
-				    !buffer_unwritten(bh)) {
-					done = 1;
-					break;
-				}
-			} while ((bh = bh-&gt;b_this_page) != head);
+			if (page_has_buffers(page)) {
+				bh = head = page_buffers(page);
+				do {
+					if (!buffer_delay(bh) &amp;&amp;
+					    !buffer_unwritten(bh))
+						done = 1;
+					bh = bh-&gt;b_this_page;
+				} while (!done &amp;&amp; (bh != head));
+			}
 			unlock_page(page);
 			if (done)
 				break;</pre><hr><pre>commit c1fccc0696bcaff6008c11865091f5ec4b0937ab
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Sep 30 01:13:55 2009 -0400

    ext4: Fix time encoding with extra epoch bits
    
    "Looking at ext4.h, I think the setting of extra time fields forgets to
    mask the epoch bits so the epoch part overwrites nsec part. The second
    change is only for coherency (2 -&gt; EXT4_EPOCH_BITS)."
    
    Thanks to Damien Guibouret for pointing out this problem.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index c508cf7be75c..984ca0cb38c3 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -525,8 +525,8 @@ struct move_extent {
 static inline __le32 ext4_encode_extra_time(struct timespec *time)
 {
        return cpu_to_le32((sizeof(time-&gt;tv_sec) &gt; 4 ?
-			   time-&gt;tv_sec &gt;&gt; 32 : 0) |
-			   ((time-&gt;tv_nsec &lt;&lt; 2) &amp; EXT4_NSEC_MASK));
+			   (time-&gt;tv_sec &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0) |
+                          ((time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS) &amp; EXT4_NSEC_MASK));
 }
 
 static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)
@@ -534,7 +534,7 @@ static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)
        if (sizeof(time-&gt;tv_sec) &gt; 4)
 	       time-&gt;tv_sec |= (__u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK)
 			       &lt;&lt; 32;
-       time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; 2;
+       time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;
 }
 
 #define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)			       \</pre><hr><pre>commit bf6993276f74d46776f35c45ddef29b981b1d1c6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Sep 30 00:32:06 2009 -0400

    jbd2: Use tracepoints for history file
    
    The /proc/fs/jbd2/&lt;dev&gt;/history was maintained manually; by using
    tracepoints, we can get all of the existing functionality of the /proc
    file plus extra capabilities thanks to the ftrace infrastructure.  We
    save memory as a bonus.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c
index 5d70b3e6d49b..ca0f5eb62b20 100644
--- a/fs/jbd2/checkpoint.c
+++ b/fs/jbd2/checkpoint.c
@@ -643,6 +643,7 @@ int __jbd2_journal_clean_checkpoint_list(journal_t *journal)
 
 int __jbd2_journal_remove_checkpoint(struct journal_head *jh)
 {
+	struct transaction_chp_stats_s *stats;
 	transaction_t *transaction;
 	journal_t *journal;
 	int ret = 0;
@@ -679,6 +680,12 @@ int __jbd2_journal_remove_checkpoint(struct journal_head *jh)
 
 	/* OK, that was the last buffer for the transaction: we can now
 	   safely remove this transaction from the log */
+	stats = &amp;transaction-&gt;t_chp_stats;
+	if (stats-&gt;cs_chp_time)
+		stats-&gt;cs_chp_time = jbd2_time_diff(stats-&gt;cs_chp_time,
+						    jiffies);
+	trace_jbd2_checkpoint_stats(journal-&gt;j_fs_dev-&gt;bd_dev,
+				    transaction-&gt;t_tid, stats);
 
 	__jbd2_journal_drop_transaction(journal, transaction);
 	kfree(transaction);
diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c
index 26d991ddc1e6..d4cfd6d2779e 100644
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@ -410,10 +410,10 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 	if (commit_transaction-&gt;t_synchronous_commit)
 		write_op = WRITE_SYNC_PLUG;
 	trace_jbd2_commit_locking(journal, commit_transaction);
-	stats.u.run.rs_wait = commit_transaction-&gt;t_max_wait;
-	stats.u.run.rs_locked = jiffies;
-	stats.u.run.rs_running = jbd2_time_diff(commit_transaction-&gt;t_start,
-						stats.u.run.rs_locked);
+	stats.run.rs_wait = commit_transaction-&gt;t_max_wait;
+	stats.run.rs_locked = jiffies;
+	stats.run.rs_running = jbd2_time_diff(commit_transaction-&gt;t_start,
+					      stats.run.rs_locked);
 
 	spin_lock(&amp;commit_transaction-&gt;t_handle_lock);
 	while (commit_transaction-&gt;t_updates) {
@@ -486,9 +486,9 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 	jbd2_journal_switch_revoke_table(journal);
 
 	trace_jbd2_commit_flushing(journal, commit_transaction);
-	stats.u.run.rs_flushing = jiffies;
-	stats.u.run.rs_locked = jbd2_time_diff(stats.u.run.rs_locked,
-					       stats.u.run.rs_flushing);
+	stats.run.rs_flushing = jiffies;
+	stats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,
+					     stats.run.rs_flushing);
 
 	commit_transaction-&gt;t_state = T_FLUSH;
 	journal-&gt;j_committing_transaction = commit_transaction;
@@ -523,11 +523,11 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 	spin_unlock(&amp;journal-&gt;j_state_lock);
 
 	trace_jbd2_commit_logging(journal, commit_transaction);
-	stats.u.run.rs_logging = jiffies;
-	stats.u.run.rs_flushing = jbd2_time_diff(stats.u.run.rs_flushing,
-						 stats.u.run.rs_logging);
-	stats.u.run.rs_blocks = commit_transaction-&gt;t_outstanding_credits;
-	stats.u.run.rs_blocks_logged = 0;
+	stats.run.rs_logging = jiffies;
+	stats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,
+					       stats.run.rs_logging);
+	stats.run.rs_blocks = commit_transaction-&gt;t_outstanding_credits;
+	stats.run.rs_blocks_logged = 0;
 
 	J_ASSERT(commit_transaction-&gt;t_nr_buffers &lt;=
 		 commit_transaction-&gt;t_outstanding_credits);
@@ -695,7 +695,7 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 				submit_bh(write_op, bh);
 			}
 			cond_resched();
-			stats.u.run.rs_blocks_logged += bufs;
+			stats.run.rs_blocks_logged += bufs;
 
 			/* Force a new descriptor to be generated next
                            time round the loop. */
@@ -988,33 +988,30 @@ void jbd2_journal_commit_transaction(journal_t *journal)
 	J_ASSERT(commit_transaction-&gt;t_state == T_COMMIT);
 
 	commit_transaction-&gt;t_start = jiffies;
-	stats.u.run.rs_logging = jbd2_time_diff(stats.u.run.rs_logging,
-						commit_transaction-&gt;t_start);
+	stats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,
+					      commit_transaction-&gt;t_start);
 
 	/*
-	 * File the transaction for history
+	 * File the transaction statistics
 	 */
-	stats.ts_type = JBD2_STATS_RUN;
 	stats.ts_tid = commit_transaction-&gt;t_tid;
-	stats.u.run.rs_handle_count = commit_transaction-&gt;t_handle_count;
-	spin_lock(&amp;journal-&gt;j_history_lock);
-	memcpy(journal-&gt;j_history + journal-&gt;j_history_cur, &amp;stats,
-			sizeof(stats));
-	if (++journal-&gt;j_history_cur == journal-&gt;j_history_max)
-		journal-&gt;j_history_cur = 0;
+	stats.run.rs_handle_count = commit_transaction-&gt;t_handle_count;
+	trace_jbd2_run_stats(journal-&gt;j_fs_dev-&gt;bd_dev,
+			     commit_transaction-&gt;t_tid, &amp;stats.run);
 
 	/*
 	 * Calculate overall stats
 	 */
+	spin_lock(&amp;journal-&gt;j_history_lock);
 	journal-&gt;j_stats.ts_tid++;
-	journal-&gt;j_stats.u.run.rs_wait += stats.u.run.rs_wait;
-	journal-&gt;j_stats.u.run.rs_running += stats.u.run.rs_running;
-	journal-&gt;j_stats.u.run.rs_locked += stats.u.run.rs_locked;
-	journal-&gt;j_stats.u.run.rs_flushing += stats.u.run.rs_flushing;
-	journal-&gt;j_stats.u.run.rs_logging += stats.u.run.rs_logging;
-	journal-&gt;j_stats.u.run.rs_handle_count += stats.u.run.rs_handle_count;
-	journal-&gt;j_stats.u.run.rs_blocks += stats.u.run.rs_blocks;
-	journal-&gt;j_stats.u.run.rs_blocks_logged += stats.u.run.rs_blocks_logged;
+	journal-&gt;j_stats.run.rs_wait += stats.run.rs_wait;
+	journal-&gt;j_stats.run.rs_running += stats.run.rs_running;
+	journal-&gt;j_stats.run.rs_locked += stats.run.rs_locked;
+	journal-&gt;j_stats.run.rs_flushing += stats.run.rs_flushing;
+	journal-&gt;j_stats.run.rs_logging += stats.run.rs_logging;
+	journal-&gt;j_stats.run.rs_handle_count += stats.run.rs_handle_count;
+	journal-&gt;j_stats.run.rs_blocks += stats.run.rs_blocks;
+	journal-&gt;j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;
 	spin_unlock(&amp;journal-&gt;j_history_lock);
 
 	commit_transaction-&gt;t_state = T_FINISHED;
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 977a8dafb76d..761af77491f5 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -676,153 +676,6 @@ struct jbd2_stats_proc_session {
 	int max;
 };
 
-static void *jbd2_history_skip_empty(struct jbd2_stats_proc_session *s,
-					struct transaction_stats_s *ts,
-					int first)
-{
-	if (ts == s-&gt;stats + s-&gt;max)
-		ts = s-&gt;stats;
-	if (!first &amp;&amp; ts == s-&gt;stats + s-&gt;start)
-		return NULL;
-	while (ts-&gt;ts_type == 0) {
-		ts++;
-		if (ts == s-&gt;stats + s-&gt;max)
-			ts = s-&gt;stats;
-		if (ts == s-&gt;stats + s-&gt;start)
-			return NULL;
-	}
-	return ts;
-
-}
-
-static void *jbd2_seq_history_start(struct seq_file *seq, loff_t *pos)
-{
-	struct jbd2_stats_proc_session *s = seq-&gt;private;
-	struct transaction_stats_s *ts;
-	int l = *pos;
-
-	if (l == 0)
-		return SEQ_START_TOKEN;
-	ts = jbd2_history_skip_empty(s, s-&gt;stats + s-&gt;start, 1);
-	if (!ts)
-		return NULL;
-	l--;
-	while (l) {
-		ts = jbd2_history_skip_empty(s, ++ts, 0);
-		if (!ts)
-			break;
-		l--;
-	}
-	return ts;
-}
-
-static void *jbd2_seq_history_next(struct seq_file *seq, void *v, loff_t *pos)
-{
-	struct jbd2_stats_proc_session *s = seq-&gt;private;
-	struct transaction_stats_s *ts = v;
-
-	++*pos;
-	if (v == SEQ_START_TOKEN)
-		return jbd2_history_skip_empty(s, s-&gt;stats + s-&gt;start, 1);
-	else
-		return jbd2_history_skip_empty(s, ++ts, 0);
-}
-
-static int jbd2_seq_history_show(struct seq_file *seq, void *v)
-{
-	struct transaction_stats_s *ts = v;
-	if (v == SEQ_START_TOKEN) {
-		seq_printf(seq, "%-4s %-5s %-5s %-5s %-5s %-5s %-5s %-6s %-5s "
-				"%-5s %-5s %-5s %-5s %-5s\n", "R/C", "tid",
-				"wait", "run", "lock", "flush", "log", "hndls",
-				"block", "inlog", "ctime", "write", "drop",
-				"close");
-		return 0;
-	}
-	if (ts-&gt;ts_type == JBD2_STATS_RUN)
-		seq_printf(seq, "%-4s %-5lu %-5u %-5u %-5u %-5u %-5u "
-				"%-6lu %-5lu %-5lu\n", "R", ts-&gt;ts_tid,
-				jiffies_to_msecs(ts-&gt;u.run.rs_wait),
-				jiffies_to_msecs(ts-&gt;u.run.rs_running),
-				jiffies_to_msecs(ts-&gt;u.run.rs_locked),
-				jiffies_to_msecs(ts-&gt;u.run.rs_flushing),
-				jiffies_to_msecs(ts-&gt;u.run.rs_logging),
-				ts-&gt;u.run.rs_handle_count,
-				ts-&gt;u.run.rs_blocks,
-				ts-&gt;u.run.rs_blocks_logged);
-	else if (ts-&gt;ts_type == JBD2_STATS_CHECKPOINT)
-		seq_printf(seq, "%-4s %-5lu %48s %-5u %-5lu %-5lu %-5lu\n",
-				"C", ts-&gt;ts_tid, " ",
-				jiffies_to_msecs(ts-&gt;u.chp.cs_chp_time),
-				ts-&gt;u.chp.cs_written, ts-&gt;u.chp.cs_dropped,
-				ts-&gt;u.chp.cs_forced_to_close);
-	else
-		J_ASSERT(0);
-	return 0;
-}
-
-static void jbd2_seq_history_stop(struct seq_file *seq, void *v)
-{
-}
-
-static const struct seq_operations jbd2_seq_history_ops = {
-	.start  = jbd2_seq_history_start,
-	.next   = jbd2_seq_history_next,
-	.stop   = jbd2_seq_history_stop,
-	.show   = jbd2_seq_history_show,
-};
-
-static int jbd2_seq_history_open(struct inode *inode, struct file *file)
-{
-	journal_t *journal = PDE(inode)-&gt;data;
-	struct jbd2_stats_proc_session *s;
-	int rc, size;
-
-	s = kmalloc(sizeof(*s), GFP_KERNEL);
-	if (s == NULL)
-		return -ENOMEM;
-	size = sizeof(struct transaction_stats_s) * journal-&gt;j_history_max;
-	s-&gt;stats = kmalloc(size, GFP_KERNEL);
-	if (s-&gt;stats == NULL) {
-		kfree(s);
-		return -ENOMEM;
-	}
-	spin_lock(&amp;journal-&gt;j_history_lock);
-	memcpy(s-&gt;stats, journal-&gt;j_history, size);
-	s-&gt;max = journal-&gt;j_history_max;
-	s-&gt;start = journal-&gt;j_history_cur % s-&gt;max;
-	spin_unlock(&amp;journal-&gt;j_history_lock);
-
-	rc = seq_open(file, &amp;jbd2_seq_history_ops);
-	if (rc == 0) {
-		struct seq_file *m = file-&gt;private_data;
-		m-&gt;private = s;
-	} else {
-		kfree(s-&gt;stats);
-		kfree(s);
-	}
-	return rc;
-
-}
-
-static int jbd2_seq_history_release(struct inode *inode, struct file *file)
-{
-	struct seq_file *seq = file-&gt;private_data;
-	struct jbd2_stats_proc_session *s = seq-&gt;private;
-
-	kfree(s-&gt;stats);
-	kfree(s);
-	return seq_release(inode, file);
-}
-
-static struct file_operations jbd2_seq_history_fops = {
-	.owner		= THIS_MODULE,
-	.open           = jbd2_seq_history_open,
-	.read           = seq_read,
-	.llseek         = seq_lseek,
-	.release        = jbd2_seq_history_release,
-};
-
 static void *jbd2_seq_info_start(struct seq_file *seq, loff_t *pos)
 {
 	return *pos ? NULL : SEQ_START_TOKEN;
@@ -839,29 +692,29 @@ static int jbd2_seq_info_show(struct seq_file *seq, void *v)
 
 	if (v != SEQ_START_TOKEN)
 		return 0;
-	seq_printf(seq, "%lu transaction, each upto %u blocks\n",
+	seq_printf(seq, "%lu transaction, each up to %u blocks\n",
 			s-&gt;stats-&gt;ts_tid,
 			s-&gt;journal-&gt;j_max_transaction_buffers);
 	if (s-&gt;stats-&gt;ts_tid == 0)
 		return 0;
 	seq_printf(seq, "average: \n  %ums waiting for transaction\n",
-	    jiffies_to_msecs(s-&gt;stats-&gt;u.run.rs_wait / s-&gt;stats-&gt;ts_tid));
+	    jiffies_to_msecs(s-&gt;stats-&gt;run.rs_wait / s-&gt;stats-&gt;ts_tid));
 	seq_printf(seq, "  %ums running transaction\n",
-	    jiffies_to_msecs(s-&gt;stats-&gt;u.run.rs_running / s-&gt;stats-&gt;ts_tid));
+	    jiffies_to_msecs(s-&gt;stats-&gt;run.rs_running / s-&gt;stats-&gt;ts_tid));
 	seq_printf(seq, "  %ums transaction was being locked\n",
-	    jiffies_to_msecs(s-&gt;stats-&gt;u.run.rs_locked / s-&gt;stats-&gt;ts_tid));
+	    jiffies_to_msecs(s-&gt;stats-&gt;run.rs_locked / s-&gt;stats-&gt;ts_tid));
 	seq_printf(seq, "  %ums flushing data (in ordered mode)\n",
-	    jiffies_to_msecs(s-&gt;stats-&gt;u.run.rs_flushing / s-&gt;stats-&gt;ts_tid));
+	    jiffies_to_msecs(s-&gt;stats-&gt;run.rs_flushing / s-&gt;stats-&gt;ts_tid));
 	seq_printf(seq, "  %ums logging transaction\n",
-	    jiffies_to_msecs(s-&gt;stats-&gt;u.run.rs_logging / s-&gt;stats-&gt;ts_tid));
+	    jiffies_to_msecs(s-&gt;stats-&gt;run.rs_logging / s-&gt;stats-&gt;ts_tid));
 	seq_printf(seq, "  %lluus average transaction commit time\n",
 		   div_u64(s-&gt;journal-&gt;j_average_commit_time, 1000));
 	seq_printf(seq, "  %lu handles per transaction\n",
-	    s-&gt;stats-&gt;u.run.rs_handle_count / s-&gt;stats-&gt;ts_tid);
+	    s-&gt;stats-&gt;run.rs_handle_count / s-&gt;stats-&gt;ts_tid);
 	seq_printf(seq, "  %lu blocks per transaction\n",
-	    s-&gt;stats-&gt;u.run.rs_blocks / s-&gt;stats-&gt;ts_tid);
+	    s-&gt;stats-&gt;run.rs_blocks / s-&gt;stats-&gt;ts_tid);
 	seq_printf(seq, "  %lu logged blocks per transaction\n",
-	    s-&gt;stats-&gt;u.run.rs_blocks_logged / s-&gt;stats-&gt;ts_tid);
+	    s-&gt;stats-&gt;run.rs_blocks_logged / s-&gt;stats-&gt;ts_tid);
 	return 0;
 }
 
@@ -931,8 +784,6 @@ static void jbd2_stats_proc_init(journal_t *journal)
 {
 	journal-&gt;j_proc_entry = proc_mkdir(journal-&gt;j_devname, proc_jbd2_stats);
 	if (journal-&gt;j_proc_entry) {
-		proc_create_data("history", S_IRUGO, journal-&gt;j_proc_entry,
-				 &amp;jbd2_seq_history_fops, journal);
 		proc_create_data("info", S_IRUGO, journal-&gt;j_proc_entry,
 				 &amp;jbd2_seq_info_fops, journal);
 	}
@@ -941,27 +792,9 @@ static void jbd2_stats_proc_init(journal_t *journal)
 static void jbd2_stats_proc_exit(journal_t *journal)
 {
 	remove_proc_entry("info", journal-&gt;j_proc_entry);
-	remove_proc_entry("history", journal-&gt;j_proc_entry);
 	remove_proc_entry(journal-&gt;j_devname, proc_jbd2_stats);
 }
 
-static void journal_init_stats(journal_t *journal)
-{
-	int size;
-
-	if (!proc_jbd2_stats)
-		return;
-
-	journal-&gt;j_history_max = 100;
-	size = sizeof(struct transaction_stats_s) * journal-&gt;j_history_max;
-	journal-&gt;j_history = kzalloc(size, GFP_KERNEL);
-	if (!journal-&gt;j_history) {
-		journal-&gt;j_history_max = 0;
-		return;
-	}
-	spin_lock_init(&amp;journal-&gt;j_history_lock);
-}
-
 /*
  * Management for journal control blocks: functions to create and
  * destroy journal_t structures, and to initialise and read existing
@@ -1006,7 +839,7 @@ static journal_t * journal_init_common (void)
 		goto fail;
 	}
 
-	journal_init_stats(journal);
+	spin_lock_init(&amp;journal-&gt;j_history_lock);
 
 	return journal;
 fail:
diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h
index 52695d3dfd0b..f1011f7f3d41 100644
--- a/include/linux/jbd2.h
+++ b/include/linux/jbd2.h
@@ -464,9 +464,9 @@ struct handle_s
  */
 struct transaction_chp_stats_s {
 	unsigned long		cs_chp_time;
-	unsigned long		cs_forced_to_close;
-	unsigned long		cs_written;
-	unsigned long		cs_dropped;
+	__u32			cs_forced_to_close;
+	__u32			cs_written;
+	__u32			cs_dropped;
 };
 
 /* The transaction_t type is the guts of the journaling mechanism.  It
@@ -668,23 +668,16 @@ struct transaction_run_stats_s {
 	unsigned long		rs_flushing;
 	unsigned long		rs_logging;
 
-	unsigned long		rs_handle_count;
-	unsigned long		rs_blocks;
-	unsigned long		rs_blocks_logged;
+	__u32			rs_handle_count;
+	__u32			rs_blocks;
+	__u32			rs_blocks_logged;
 };
 
 struct transaction_stats_s {
-	int 			ts_type;
 	unsigned long		ts_tid;
-	union {
-		struct transaction_run_stats_s run;
-		struct transaction_chp_stats_s chp;
-	} u;
+	struct transaction_run_stats_s run;
 };
 
-#define JBD2_STATS_RUN		1
-#define JBD2_STATS_CHECKPOINT	2
-
 static inline unsigned long
 jbd2_time_diff(unsigned long start, unsigned long end)
 {
@@ -988,12 +981,6 @@ struct journal_s
 	/*
 	 * Journal statistics
 	 */
-	struct transaction_stats_s *j_history;
-	int			j_history_max;
-	int			j_history_cur;
-	/*
-	 * Protect the transactions statistics history
-	 */
 	spinlock_t		j_history_lock;
 	struct proc_dir_entry	*j_proc_entry;
 	struct transaction_stats_s j_stats;
diff --git a/include/trace/events/jbd2.h b/include/trace/events/jbd2.h
index b851f0b4701c..3c60b75adb9e 100644
--- a/include/trace/events/jbd2.h
+++ b/include/trace/events/jbd2.h
@@ -7,6 +7,9 @@
 #include &lt;linux/jbd2.h&gt;
 #include &lt;linux/tracepoint.h&gt;
 
+struct transaction_chp_stats_s;
+struct transaction_run_stats_s;
+
 TRACE_EVENT(jbd2_checkpoint,
 
 	TP_PROTO(journal_t *journal, int result),
@@ -162,6 +165,81 @@ TRACE_EVENT(jbd2_submit_inode_data,
 		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino)
 );
 
+TRACE_EVENT(jbd2_run_stats,
+	TP_PROTO(dev_t dev, unsigned long tid,
+		 struct transaction_run_stats_s *stats),
+
+	TP_ARGS(dev, tid, stats),
+
+	TP_STRUCT__entry(
+		__field(		dev_t,	dev		)
+		__field(	unsigned long,	tid		)
+		__field(	unsigned long,	wait		)
+		__field(	unsigned long,	running		)
+		__field(	unsigned long,	locked		)
+		__field(	unsigned long,	flushing	)
+		__field(	unsigned long,	logging		)
+		__field(		__u32,	handle_count	)
+		__field(		__u32,	blocks		)
+		__field(		__u32,	blocks_logged	)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= dev;
+		__entry-&gt;tid		= tid;
+		__entry-&gt;wait		= stats-&gt;rs_wait;
+		__entry-&gt;running	= stats-&gt;rs_running;
+		__entry-&gt;locked		= stats-&gt;rs_locked;
+		__entry-&gt;flushing	= stats-&gt;rs_flushing;
+		__entry-&gt;logging	= stats-&gt;rs_logging;
+		__entry-&gt;handle_count	= stats-&gt;rs_handle_count;
+		__entry-&gt;blocks		= stats-&gt;rs_blocks;
+		__entry-&gt;blocks_logged	= stats-&gt;rs_blocks_logged;
+	),
+
+	TP_printk("dev %s tid %lu wait %u running %u locked %u flushing %u "
+		  "logging %u handle_count %u blocks %u blocks_logged %u",
+		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;tid,
+		  jiffies_to_msecs(__entry-&gt;wait),
+		  jiffies_to_msecs(__entry-&gt;running),
+		  jiffies_to_msecs(__entry-&gt;locked),
+		  jiffies_to_msecs(__entry-&gt;flushing),
+		  jiffies_to_msecs(__entry-&gt;logging),
+		  __entry-&gt;handle_count, __entry-&gt;blocks,
+		  __entry-&gt;blocks_logged)
+);
+
+TRACE_EVENT(jbd2_checkpoint_stats,
+	TP_PROTO(dev_t dev, unsigned long tid,
+		 struct transaction_chp_stats_s *stats),
+
+	TP_ARGS(dev, tid, stats),
+
+	TP_STRUCT__entry(
+		__field(		dev_t,	dev		)
+		__field(	unsigned long,	tid		)
+		__field(	unsigned long,	chp_time	)
+		__field(		__u32,	forced_to_close	)
+		__field(		__u32,	written		)
+		__field(		__u32,	dropped		)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= dev;
+		__entry-&gt;tid		= tid;
+		__entry-&gt;chp_time	= stats-&gt;cs_chp_time;
+		__entry-&gt;forced_to_close= stats-&gt;cs_forced_to_close;
+		__entry-&gt;written	= stats-&gt;cs_written;
+		__entry-&gt;dropped	= stats-&gt;cs_dropped;
+	),
+
+	TP_printk("dev %s tid %lu chp_time %u forced_to_close %u "
+		  "written %u dropped %u",
+		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;tid,
+		  jiffies_to_msecs(__entry-&gt;chp_time),
+		  __entry-&gt;forced_to_close, __entry-&gt;written, __entry-&gt;dropped)
+);
+
 #endif /* _TRACE_JBD2_H */
 
 /* This part must be outside protection */</pre><hr><pre>commit 296c355cd6443d89fa251885a8d78778fe111dc4
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Sep 30 00:32:42 2009 -0400

    ext4: Use tracepoints for mb_history trace file
    
    The /proc/fs/ext4/&lt;dev&gt;/mb_history was maintained manually, and had a
    number of problems: it required a largish amount of memory to be
    allocated for each ext4 filesystem, and the s_mb_history_lock
    introduced a CPU contention problem.
    
    By ripping out the mb_history code and replacing it with ftrace
    tracepoints, and we get more functionality: timestamps, event
    filtering, the ability to correlate mballoc history with other ext4
    tracepoints, etc.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/Documentation/filesystems/proc.txt b/Documentation/filesystems/proc.txt
index b5aee7838a00..2c48f945546b 100644
--- a/Documentation/filesystems/proc.txt
+++ b/Documentation/filesystems/proc.txt
@@ -1113,7 +1113,6 @@ Table 1-12: Files in /proc/fs/ext4/&lt;devname&gt;
 ..............................................................................
  File            Content                                        
  mb_groups       details of multiblock allocator buddy cache of free blocks
- mb_history      multiblock allocation history
 ..............................................................................
 
 
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index b491576e11c3..c508cf7be75c 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -65,6 +65,12 @@ typedef __u32 ext4_lblk_t;
 /* data type for block group number */
 typedef unsigned int ext4_group_t;
 
+/*
+ * Flags used in mballoc's allocation_context flags field.  
+ *
+ * Also used to show what's going on for debugging purposes when the
+ * flag field is exported via the traceport interface
+ */
 
 /* prefer goal again. length */
 #define EXT4_MB_HINT_MERGE		0x0001
@@ -971,14 +977,6 @@ struct ext4_sb_info {
 	unsigned long s_mb_last_group;
 	unsigned long s_mb_last_start;
 
-	/* history to debug policy */
-	struct ext4_mb_history *s_mb_history;
-	int s_mb_history_cur;
-	int s_mb_history_max;
-	int s_mb_history_num;
-	spinlock_t s_mb_history_lock;
-	int s_mb_history_filter;
-
 	/* stats for buddy allocator */
 	spinlock_t s_mb_pa_lock;
 	atomic_t s_bal_reqs;	/* number of reqs with len &gt; 1 */
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 3e2320e66721..bba12824defa 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -2096,207 +2096,6 @@ ext4_mb_regular_allocator(struct ext4_allocation_context *ac)
 	return err;
 }
 
-#ifdef EXT4_MB_HISTORY
-struct ext4_mb_proc_session {
-	struct ext4_mb_history *history;
-	struct super_block *sb;
-	int start;
-	int max;
-};
-
-static void *ext4_mb_history_skip_empty(struct ext4_mb_proc_session *s,
-					struct ext4_mb_history *hs,
-					int first)
-{
-	if (hs == s-&gt;history + s-&gt;max)
-		hs = s-&gt;history;
-	if (!first &amp;&amp; hs == s-&gt;history + s-&gt;start)
-		return NULL;
-	while (hs-&gt;orig.fe_len == 0) {
-		hs++;
-		if (hs == s-&gt;history + s-&gt;max)
-			hs = s-&gt;history;
-		if (hs == s-&gt;history + s-&gt;start)
-			return NULL;
-	}
-	return hs;
-}
-
-static void *ext4_mb_seq_history_start(struct seq_file *seq, loff_t *pos)
-{
-	struct ext4_mb_proc_session *s = seq-&gt;private;
-	struct ext4_mb_history *hs;
-	int l = *pos;
-
-	if (l == 0)
-		return SEQ_START_TOKEN;
-	hs = ext4_mb_history_skip_empty(s, s-&gt;history + s-&gt;start, 1);
-	if (!hs)
-		return NULL;
-	while (--l &amp;&amp; (hs = ext4_mb_history_skip_empty(s, ++hs, 0)) != NULL);
-	return hs;
-}
-
-static void *ext4_mb_seq_history_next(struct seq_file *seq, void *v,
-				      loff_t *pos)
-{
-	struct ext4_mb_proc_session *s = seq-&gt;private;
-	struct ext4_mb_history *hs = v;
-
-	++*pos;
-	if (v == SEQ_START_TOKEN)
-		return ext4_mb_history_skip_empty(s, s-&gt;history + s-&gt;start, 1);
-	else
-		return ext4_mb_history_skip_empty(s, ++hs, 0);
-}
-
-static int ext4_mb_seq_history_show(struct seq_file *seq, void *v)
-{
-	char buf[25], buf2[25], buf3[25], *fmt;
-	struct ext4_mb_history *hs = v;
-
-	if (v == SEQ_START_TOKEN) {
-		seq_printf(seq, "%-5s %-8s %-23s %-23s %-23s %-5s "
-				"%-5s %-2s %-6s %-5s %-5s %-6s\n",
-			  "pid", "inode", "original", "goal", "result", "found",
-			   "grps", "cr", "flags", "merge", "tail", "broken");
-		return 0;
-	}
-
-	if (hs-&gt;op == EXT4_MB_HISTORY_ALLOC) {
-		fmt = "%-5u %-8u %-23s %-23s %-23s %-5u %-5u %-2u "
-			"0x%04x %-5s %-5u %-6u\n";
-		sprintf(buf2, "%u/%d/%u@%u", hs-&gt;result.fe_group,
-			hs-&gt;result.fe_start, hs-&gt;result.fe_len,
-			hs-&gt;result.fe_logical);
-		sprintf(buf, "%u/%d/%u@%u", hs-&gt;orig.fe_group,
-			hs-&gt;orig.fe_start, hs-&gt;orig.fe_len,
-			hs-&gt;orig.fe_logical);
-		sprintf(buf3, "%u/%d/%u@%u", hs-&gt;goal.fe_group,
-			hs-&gt;goal.fe_start, hs-&gt;goal.fe_len,
-			hs-&gt;goal.fe_logical);
-		seq_printf(seq, fmt, hs-&gt;pid, hs-&gt;ino, buf, buf3, buf2,
-				hs-&gt;found, hs-&gt;groups, hs-&gt;cr, hs-&gt;flags,
-				hs-&gt;merged ? "M" : "", hs-&gt;tail,
-				hs-&gt;buddy ? 1 &lt;&lt; hs-&gt;buddy : 0);
-	} else if (hs-&gt;op == EXT4_MB_HISTORY_PREALLOC) {
-		fmt = "%-5u %-8u %-23s %-23s %-23s\n";
-		sprintf(buf2, "%u/%d/%u@%u", hs-&gt;result.fe_group,
-			hs-&gt;result.fe_start, hs-&gt;result.fe_len,
-			hs-&gt;result.fe_logical);
-		sprintf(buf, "%u/%d/%u@%u", hs-&gt;orig.fe_group,
-			hs-&gt;orig.fe_start, hs-&gt;orig.fe_len,
-			hs-&gt;orig.fe_logical);
-		seq_printf(seq, fmt, hs-&gt;pid, hs-&gt;ino, buf, "", buf2);
-	} else if (hs-&gt;op == EXT4_MB_HISTORY_DISCARD) {
-		sprintf(buf2, "%u/%d/%u", hs-&gt;result.fe_group,
-			hs-&gt;result.fe_start, hs-&gt;result.fe_len);
-		seq_printf(seq, "%-5u %-8u %-23s discard\n",
-				hs-&gt;pid, hs-&gt;ino, buf2);
-	} else if (hs-&gt;op == EXT4_MB_HISTORY_FREE) {
-		sprintf(buf2, "%u/%d/%u", hs-&gt;result.fe_group,
-			hs-&gt;result.fe_start, hs-&gt;result.fe_len);
-		seq_printf(seq, "%-5u %-8u %-23s free\n",
-				hs-&gt;pid, hs-&gt;ino, buf2);
-	}
-	return 0;
-}
-
-static void ext4_mb_seq_history_stop(struct seq_file *seq, void *v)
-{
-}
-
-static const struct seq_operations ext4_mb_seq_history_ops = {
-	.start  = ext4_mb_seq_history_start,
-	.next   = ext4_mb_seq_history_next,
-	.stop   = ext4_mb_seq_history_stop,
-	.show   = ext4_mb_seq_history_show,
-};
-
-static int ext4_mb_seq_history_open(struct inode *inode, struct file *file)
-{
-	struct super_block *sb = PDE(inode)-&gt;data;
-	struct ext4_sb_info *sbi = EXT4_SB(sb);
-	struct ext4_mb_proc_session *s;
-	int rc;
-	int size;
-
-	if (unlikely(sbi-&gt;s_mb_history == NULL))
-		return -ENOMEM;
-	s = kmalloc(sizeof(*s), GFP_KERNEL);
-	if (s == NULL)
-		return -ENOMEM;
-	s-&gt;sb = sb;
-	size = sizeof(struct ext4_mb_history) * sbi-&gt;s_mb_history_max;
-	s-&gt;history = kmalloc(size, GFP_KERNEL);
-	if (s-&gt;history == NULL) {
-		kfree(s);
-		return -ENOMEM;
-	}
-
-	spin_lock(&amp;sbi-&gt;s_mb_history_lock);
-	memcpy(s-&gt;history, sbi-&gt;s_mb_history, size);
-	s-&gt;max = sbi-&gt;s_mb_history_max;
-	s-&gt;start = sbi-&gt;s_mb_history_cur % s-&gt;max;
-	spin_unlock(&amp;sbi-&gt;s_mb_history_lock);
-
-	rc = seq_open(file, &amp;ext4_mb_seq_history_ops);
-	if (rc == 0) {
-		struct seq_file *m = (struct seq_file *)file-&gt;private_data;
-		m-&gt;private = s;
-	} else {
-		kfree(s-&gt;history);
-		kfree(s);
-	}
-	return rc;
-
-}
-
-static int ext4_mb_seq_history_release(struct inode *inode, struct file *file)
-{
-	struct seq_file *seq = (struct seq_file *)file-&gt;private_data;
-	struct ext4_mb_proc_session *s = seq-&gt;private;
-	kfree(s-&gt;history);
-	kfree(s);
-	return seq_release(inode, file);
-}
-
-static ssize_t ext4_mb_seq_history_write(struct file *file,
-				const char __user *buffer,
-				size_t count, loff_t *ppos)
-{
-	struct seq_file *seq = (struct seq_file *)file-&gt;private_data;
-	struct ext4_mb_proc_session *s = seq-&gt;private;
-	struct super_block *sb = s-&gt;sb;
-	char str[32];
-	int value;
-
-	if (count &gt;= sizeof(str)) {
-		printk(KERN_ERR "EXT4-fs: %s string too long, max %u bytes\n",
-				"mb_history", (int)sizeof(str));
-		return -EOVERFLOW;
-	}
-
-	if (copy_from_user(str, buffer, count))
-		return -EFAULT;
-
-	value = simple_strtol(str, NULL, 0);
-	if (value &lt; 0)
-		return -ERANGE;
-	EXT4_SB(sb)-&gt;s_mb_history_filter = value;
-
-	return count;
-}
-
-static const struct file_operations ext4_mb_seq_history_fops = {
-	.owner		= THIS_MODULE,
-	.open		= ext4_mb_seq_history_open,
-	.read		= seq_read,
-	.write		= ext4_mb_seq_history_write,
-	.llseek		= seq_lseek,
-	.release	= ext4_mb_seq_history_release,
-};
-
 static void *ext4_mb_seq_groups_start(struct seq_file *seq, loff_t *pos)
 {
 	struct super_block *sb = seq-&gt;private;
@@ -2396,82 +2195,6 @@ static const struct file_operations ext4_mb_seq_groups_fops = {
 	.release	= seq_release,
 };
 
-static void ext4_mb_history_release(struct super_block *sb)
-{
-	struct ext4_sb_info *sbi = EXT4_SB(sb);
-
-	if (sbi-&gt;s_proc != NULL) {
-		remove_proc_entry("mb_groups", sbi-&gt;s_proc);
-		if (sbi-&gt;s_mb_history_max)
-			remove_proc_entry("mb_history", sbi-&gt;s_proc);
-	}
-	kfree(sbi-&gt;s_mb_history);
-}
-
-static void ext4_mb_history_init(struct super_block *sb)
-{
-	struct ext4_sb_info *sbi = EXT4_SB(sb);
-	int i;
-
-	if (sbi-&gt;s_proc != NULL) {
-		if (sbi-&gt;s_mb_history_max)
-			proc_create_data("mb_history", S_IRUGO, sbi-&gt;s_proc,
-					 &amp;ext4_mb_seq_history_fops, sb);
-		proc_create_data("mb_groups", S_IRUGO, sbi-&gt;s_proc,
-				 &amp;ext4_mb_seq_groups_fops, sb);
-	}
-
-	sbi-&gt;s_mb_history_cur = 0;
-	spin_lock_init(&amp;sbi-&gt;s_mb_history_lock);
-	i = sbi-&gt;s_mb_history_max * sizeof(struct ext4_mb_history);
-	sbi-&gt;s_mb_history = i ? kzalloc(i, GFP_KERNEL) : NULL;
-	/* if we can't allocate history, then we simple won't use it */
-}
-
-static noinline_for_stack void
-ext4_mb_store_history(struct ext4_allocation_context *ac)
-{
-	struct ext4_sb_info *sbi = EXT4_SB(ac-&gt;ac_sb);
-	struct ext4_mb_history h;
-
-	if (sbi-&gt;s_mb_history == NULL)
-		return;
-
-	if (!(ac-&gt;ac_op &amp; sbi-&gt;s_mb_history_filter))
-		return;
-
-	h.op = ac-&gt;ac_op;
-	h.pid = current-&gt;pid;
-	h.ino = ac-&gt;ac_inode ? ac-&gt;ac_inode-&gt;i_ino : 0;
-	h.orig = ac-&gt;ac_o_ex;
-	h.result = ac-&gt;ac_b_ex;
-	h.flags = ac-&gt;ac_flags;
-	h.found = ac-&gt;ac_found;
-	h.groups = ac-&gt;ac_groups_scanned;
-	h.cr = ac-&gt;ac_criteria;
-	h.tail = ac-&gt;ac_tail;
-	h.buddy = ac-&gt;ac_buddy;
-	h.merged = 0;
-	if (ac-&gt;ac_op == EXT4_MB_HISTORY_ALLOC) {
-		if (ac-&gt;ac_g_ex.fe_start == ac-&gt;ac_b_ex.fe_start &amp;&amp;
-				ac-&gt;ac_g_ex.fe_group == ac-&gt;ac_b_ex.fe_group)
-			h.merged = 1;
-		h.goal = ac-&gt;ac_g_ex;
-		h.result = ac-&gt;ac_f_ex;
-	}
-
-	spin_lock(&amp;sbi-&gt;s_mb_history_lock);
-	memcpy(sbi-&gt;s_mb_history + sbi-&gt;s_mb_history_cur, &amp;h, sizeof(h));
-	if (++sbi-&gt;s_mb_history_cur &gt;= sbi-&gt;s_mb_history_max)
-		sbi-&gt;s_mb_history_cur = 0;
-	spin_unlock(&amp;sbi-&gt;s_mb_history_lock);
-}
-
-#else
-#define ext4_mb_history_release(sb)
-#define ext4_mb_history_init(sb)
-#endif
-
 
 /* Create and initialize ext4_group_info data for the given group. */
 int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group,
@@ -2690,7 +2413,6 @@ int ext4_mb_init(struct super_block *sb, int needs_recovery)
 	sbi-&gt;s_mb_stats = MB_DEFAULT_STATS;
 	sbi-&gt;s_mb_stream_request = MB_DEFAULT_STREAM_THRESHOLD;
 	sbi-&gt;s_mb_order2_reqs = MB_DEFAULT_ORDER2_REQS;
-	sbi-&gt;s_mb_history_filter = EXT4_MB_HISTORY_DEFAULT;
 	sbi-&gt;s_mb_group_prealloc = MB_DEFAULT_GROUP_PREALLOC;
 
 	sbi-&gt;s_locality_groups = alloc_percpu(struct ext4_locality_group);
@@ -2708,7 +2430,9 @@ int ext4_mb_init(struct super_block *sb, int needs_recovery)
 		spin_lock_init(&amp;lg-&gt;lg_prealloc_lock);
 	}
 
-	ext4_mb_history_init(sb);
+	if (sbi-&gt;s_proc)
+		proc_create_data("mb_groups", S_IRUGO, sbi-&gt;s_proc,
+				 &amp;ext4_mb_seq_groups_fops, sb);
 
 	if (sbi-&gt;s_journal)
 		sbi-&gt;s_journal-&gt;j_commit_callback = release_blocks_on_commit;
@@ -2788,7 +2512,8 @@ int ext4_mb_release(struct super_block *sb)
 	}
 
 	free_percpu(sbi-&gt;s_locality_groups);
-	ext4_mb_history_release(sb);
+	if (sbi-&gt;s_proc)
+		remove_proc_entry("mb_groups", sbi-&gt;s_proc);
 
 	return 0;
 }
@@ -3274,7 +2999,10 @@ static void ext4_mb_collect_stats(struct ext4_allocation_context *ac)
 			atomic_inc(&amp;sbi-&gt;s_bal_breaks);
 	}
 
-	ext4_mb_store_history(ac);
+	if (ac-&gt;ac_op == EXT4_MB_HISTORY_ALLOC)
+		trace_ext4_mballoc_alloc(ac);
+	else
+		trace_ext4_mballoc_prealloc(ac);
 }
 
 /*
@@ -3774,7 +3502,6 @@ ext4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,
 	if (ac) {
 		ac-&gt;ac_sb = sb;
 		ac-&gt;ac_inode = pa-&gt;pa_inode;
-		ac-&gt;ac_op = EXT4_MB_HISTORY_DISCARD;
 	}
 
 	while (bit &lt; end) {
@@ -3794,7 +3521,7 @@ ext4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,
 			ac-&gt;ac_b_ex.fe_start = bit;
 			ac-&gt;ac_b_ex.fe_len = next - bit;
 			ac-&gt;ac_b_ex.fe_logical = 0;
-			ext4_mb_store_history(ac);
+			trace_ext4_mballoc_discard(ac);
 		}
 
 		trace_ext4_mb_release_inode_pa(ac, pa, grp_blk_start + bit,
@@ -3829,9 +3556,6 @@ ext4_mb_release_group_pa(struct ext4_buddy *e4b,
 	ext4_group_t group;
 	ext4_grpblk_t bit;
 
-	if (ac)
-		ac-&gt;ac_op = EXT4_MB_HISTORY_DISCARD;
-
 	trace_ext4_mb_release_group_pa(ac, pa);
 	BUG_ON(pa-&gt;pa_deleted == 0);
 	ext4_get_group_no_and_offset(sb, pa-&gt;pa_pstart, &amp;group, &amp;bit);
@@ -3846,7 +3570,7 @@ ext4_mb_release_group_pa(struct ext4_buddy *e4b,
 		ac-&gt;ac_b_ex.fe_start = bit;
 		ac-&gt;ac_b_ex.fe_len = pa-&gt;pa_len;
 		ac-&gt;ac_b_ex.fe_logical = 0;
-		ext4_mb_store_history(ac);
+		trace_ext4_mballoc_discard(ac);
 	}
 
 	return 0;
@@ -4737,7 +4461,6 @@ void ext4_mb_free_blocks(handle_t *handle, struct inode *inode,
 
 	ac = kmem_cache_alloc(ext4_ac_cachep, GFP_NOFS);
 	if (ac) {
-		ac-&gt;ac_op = EXT4_MB_HISTORY_FREE;
 		ac-&gt;ac_inode = inode;
 		ac-&gt;ac_sb = sb;
 	}
@@ -4804,7 +4527,7 @@ void ext4_mb_free_blocks(handle_t *handle, struct inode *inode,
 		ac-&gt;ac_b_ex.fe_group = block_group;
 		ac-&gt;ac_b_ex.fe_start = bit;
 		ac-&gt;ac_b_ex.fe_len = count;
-		ext4_mb_store_history(ac);
+		trace_ext4_mballoc_free(ac);
 	}
 
 	err = ext4_mb_load_buddy(sb, block_group, &amp;e4b);
diff --git a/fs/ext4/mballoc.h b/fs/ext4/mballoc.h
index 14f25f253112..0ca811061bc7 100644
--- a/fs/ext4/mballoc.h
+++ b/fs/ext4/mballoc.h
@@ -52,18 +52,8 @@ extern u8 mb_enable_debug;
 #define mb_debug(n, fmt, a...)
 #endif
 
-/*
- * with EXT4_MB_HISTORY mballoc stores last N allocations in memory
- * and you can monitor it in /proc/fs/ext4/&lt;dev&gt;/mb_history
- */
-#define EXT4_MB_HISTORY
 #define EXT4_MB_HISTORY_ALLOC		1	/* allocation */
 #define EXT4_MB_HISTORY_PREALLOC	2	/* preallocated blocks used */
-#define EXT4_MB_HISTORY_DISCARD		4	/* preallocation discarded */
-#define EXT4_MB_HISTORY_FREE		8	/* free */
-
-#define EXT4_MB_HISTORY_DEFAULT		(EXT4_MB_HISTORY_ALLOC | \
-					 EXT4_MB_HISTORY_PREALLOC)
 
 /*
  * How long mballoc can look for a best extent (in found extents)
@@ -217,22 +207,6 @@ struct ext4_allocation_context {
 #define AC_STATUS_FOUND		2
 #define AC_STATUS_BREAK		3
 
-struct ext4_mb_history {
-	struct ext4_free_extent orig;	/* orig allocation */
-	struct ext4_free_extent goal;	/* goal allocation */
-	struct ext4_free_extent result;	/* result allocation */
-	unsigned pid;
-	unsigned ino;
-	__u16 found;	/* how many extents have been found */
-	__u16 groups;	/* how many groups have been scanned */
-	__u16 tail;	/* what tail broke some buddy */
-	__u16 buddy;	/* buddy the tail ^^^ broke */
-	__u16 flags;
-	__u8 cr:3;	/* which phase the result extent was found at */
-	__u8 op:4;
-	__u8 merged:1;
-};
-
 struct ext4_buddy {
 	struct page *bd_buddy_page;
 	void *bd_buddy;
@@ -247,13 +221,6 @@ struct ext4_buddy {
 #define EXT4_MB_BITMAP(e4b)	((e4b)-&gt;bd_bitmap)
 #define EXT4_MB_BUDDY(e4b)	((e4b)-&gt;bd_buddy)
 
-#ifndef EXT4_MB_HISTORY
-static inline void ext4_mb_store_history(struct ext4_allocation_context *ac)
-{
-	return;
-}
-#endif
-
 #define in_range(b, first, len)	((b) &gt;= (first) &amp;&amp; (b) &lt;= (first) + (len) - 1)
 
 static inline ext4_fsblk_t ext4_grp_offs_to_block(struct super_block *sb,
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index e5b206a043a5..12e726a7073f 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -50,13 +50,6 @@
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/ext4.h&gt;
 
-static int default_mb_history_length = 1000;
-
-module_param_named(default_mb_history_length, default_mb_history_length,
-		   int, 0644);
-MODULE_PARM_DESC(default_mb_history_length,
-		 "Default number of entries saved for mb_history");
-
 struct proc_dir_entry *ext4_proc_root;
 static struct kset *ext4_kset;
 
@@ -1079,7 +1072,7 @@ enum {
 	Opt_journal_update, Opt_journal_dev,
 	Opt_journal_checksum, Opt_journal_async_commit,
 	Opt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,
-	Opt_data_err_abort, Opt_data_err_ignore, Opt_mb_history_length,
+	Opt_data_err_abort, Opt_data_err_ignore,
 	Opt_usrjquota, Opt_grpjquota, Opt_offusrjquota, Opt_offgrpjquota,
 	Opt_jqfmt_vfsold, Opt_jqfmt_vfsv0, Opt_quota, Opt_noquota,
 	Opt_ignore, Opt_barrier, Opt_nobarrier, Opt_err, Opt_resize,
@@ -1126,7 +1119,6 @@ static const match_table_t tokens = {
 	{Opt_data_writeback, "data=writeback"},
 	{Opt_data_err_abort, "data_err=abort"},
 	{Opt_data_err_ignore, "data_err=ignore"},
-	{Opt_mb_history_length, "mb_history_length=%u"},
 	{Opt_offusrjquota, "usrjquota="},
 	{Opt_usrjquota, "usrjquota=%s"},
 	{Opt_offgrpjquota, "grpjquota="},
@@ -1367,13 +1359,6 @@ static int parse_options(char *options, struct super_block *sb,
 		case Opt_data_err_ignore:
 			clear_opt(sbi-&gt;s_mount_opt, DATA_ERR_ABORT);
 			break;
-		case Opt_mb_history_length:
-			if (match_int(&amp;args[0], &amp;option))
-				return 0;
-			if (option &lt; 0)
-				return 0;
-			sbi-&gt;s_mb_history_max = option;
-			break;
 #ifdef CONFIG_QUOTA
 		case Opt_usrjquota:
 			qtype = USRQUOTA;
@@ -2435,7 +2420,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	sbi-&gt;s_commit_interval = JBD2_DEFAULT_MAX_COMMIT_AGE * HZ;
 	sbi-&gt;s_min_batch_time = EXT4_DEF_MIN_BATCH_TIME;
 	sbi-&gt;s_max_batch_time = EXT4_DEF_MAX_BATCH_TIME;
-	sbi-&gt;s_mb_history_max = default_mb_history_length;
 
 	set_opt(sbi-&gt;s_mount_opt, BARRIER);
 
diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index 7c6bbb7198a3..b8320256dc5d 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -743,6 +743,169 @@ TRACE_EVENT(ext4_alloc_da_blocks,
 		  __entry-&gt;data_blocks, __entry-&gt;meta_blocks)
 );
 
+TRACE_EVENT(ext4_mballoc_alloc,
+	TP_PROTO(struct ext4_allocation_context *ac),
+
+	TP_ARGS(ac),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	ino_t,	ino			)
+		__field(	__u16,	found			)
+		__field(	__u16,	groups			)
+		__field(	__u16,	buddy			)
+		__field(	__u16,	flags			)
+		__field(	__u16,	tail			)
+		__field(	__u8,	cr			)
+		__field(	__u32, 	orig_logical		)
+		__field(	  int,	orig_start		)
+		__field(	__u32, 	orig_group		)
+		__field(	  int,	orig_len		)
+		__field(	__u32, 	goal_logical		)
+		__field(	  int,	goal_start		)
+		__field(	__u32, 	goal_group		)
+		__field(	  int,	goal_len		)
+		__field(	__u32, 	result_logical		)
+		__field(	  int,	result_start		)
+		__field(	__u32, 	result_group		)
+		__field(	  int,	result_len		)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;ino		= ac-&gt;ac_inode-&gt;i_ino;
+		__entry-&gt;found		= ac-&gt;ac_found;
+		__entry-&gt;flags		= ac-&gt;ac_flags;
+		__entry-&gt;groups		= ac-&gt;ac_groups_scanned;
+		__entry-&gt;buddy		= ac-&gt;ac_buddy;
+		__entry-&gt;tail		= ac-&gt;ac_tail;
+		__entry-&gt;cr		= ac-&gt;ac_criteria;
+		__entry-&gt;orig_logical	= ac-&gt;ac_o_ex.fe_logical;
+		__entry-&gt;orig_start	= ac-&gt;ac_o_ex.fe_start;
+		__entry-&gt;orig_group	= ac-&gt;ac_o_ex.fe_group;
+		__entry-&gt;orig_len	= ac-&gt;ac_o_ex.fe_len;
+		__entry-&gt;goal_logical	= ac-&gt;ac_g_ex.fe_logical;
+		__entry-&gt;goal_start	= ac-&gt;ac_g_ex.fe_start;
+		__entry-&gt;goal_group	= ac-&gt;ac_g_ex.fe_group;
+		__entry-&gt;goal_len	= ac-&gt;ac_g_ex.fe_len;
+		__entry-&gt;result_logical	= ac-&gt;ac_f_ex.fe_logical;
+		__entry-&gt;result_start	= ac-&gt;ac_f_ex.fe_start;
+		__entry-&gt;result_group	= ac-&gt;ac_f_ex.fe_group;
+		__entry-&gt;result_len	= ac-&gt;ac_f_ex.fe_len;
+	),
+
+	TP_printk("dev %s inode %lu orig %u/%d/%u@%u goal %u/%d/%u@%u "
+		  "result %u/%d/%u@%u blks %u grps %u cr %u flags 0x%04x "
+		  "tail %u broken %u",
+		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;orig_group, __entry-&gt;orig_start,
+		  __entry-&gt;orig_len, __entry-&gt;orig_logical,
+		  __entry-&gt;goal_group, __entry-&gt;goal_start,
+		  __entry-&gt;goal_len, __entry-&gt;goal_logical,
+		  __entry-&gt;result_group, __entry-&gt;result_start,
+		  __entry-&gt;result_len, __entry-&gt;result_logical,
+		  __entry-&gt;found, __entry-&gt;groups, __entry-&gt;cr,
+		  __entry-&gt;flags, __entry-&gt;tail,
+		  __entry-&gt;buddy ? 1 &lt;&lt; __entry-&gt;buddy : 0)
+);
+
+TRACE_EVENT(ext4_mballoc_prealloc,
+	TP_PROTO(struct ext4_allocation_context *ac),
+
+	TP_ARGS(ac),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	ino_t,	ino			)
+		__field(	__u32, 	orig_logical		)
+		__field(	  int,	orig_start		)
+		__field(	__u32, 	orig_group		)
+		__field(	  int,	orig_len		)
+		__field(	__u32, 	result_logical		)
+		__field(	  int,	result_start		)
+		__field(	__u32, 	result_group		)
+		__field(	  int,	result_len		)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;ino		= ac-&gt;ac_inode-&gt;i_ino;
+		__entry-&gt;orig_logical	= ac-&gt;ac_o_ex.fe_logical;
+		__entry-&gt;orig_start	= ac-&gt;ac_o_ex.fe_start;
+		__entry-&gt;orig_group	= ac-&gt;ac_o_ex.fe_group;
+		__entry-&gt;orig_len	= ac-&gt;ac_o_ex.fe_len;
+		__entry-&gt;result_logical	= ac-&gt;ac_b_ex.fe_logical;
+		__entry-&gt;result_start	= ac-&gt;ac_b_ex.fe_start;
+		__entry-&gt;result_group	= ac-&gt;ac_b_ex.fe_group;
+		__entry-&gt;result_len	= ac-&gt;ac_b_ex.fe_len;
+	),
+
+	TP_printk("dev %s inode %lu orig %u/%d/%u@%u result %u/%d/%u@%u",
+		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;orig_group, __entry-&gt;orig_start,
+		  __entry-&gt;orig_len, __entry-&gt;orig_logical,
+		  __entry-&gt;result_group, __entry-&gt;result_start,
+		  __entry-&gt;result_len, __entry-&gt;result_logical)
+);
+
+TRACE_EVENT(ext4_mballoc_discard,
+	TP_PROTO(struct ext4_allocation_context *ac),
+
+	TP_ARGS(ac),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	ino_t,	ino			)
+		__field(	__u32, 	result_logical		)
+		__field(	  int,	result_start		)
+		__field(	__u32, 	result_group		)
+		__field(	  int,	result_len		)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;ino		= ac-&gt;ac_inode-&gt;i_ino;
+		__entry-&gt;result_logical	= ac-&gt;ac_b_ex.fe_logical;
+		__entry-&gt;result_start	= ac-&gt;ac_b_ex.fe_start;
+		__entry-&gt;result_group	= ac-&gt;ac_b_ex.fe_group;
+		__entry-&gt;result_len	= ac-&gt;ac_b_ex.fe_len;
+	),
+
+	TP_printk("dev %s inode %lu extent %u/%d/%u@%u ",
+		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;result_group, __entry-&gt;result_start,
+		  __entry-&gt;result_len, __entry-&gt;result_logical)
+);
+
+TRACE_EVENT(ext4_mballoc_free,
+	TP_PROTO(struct ext4_allocation_context *ac),
+
+	TP_ARGS(ac),
+
+	TP_STRUCT__entry(
+		__field(	dev_t,	dev			)
+		__field(	ino_t,	ino			)
+		__field(	__u32, 	result_logical		)
+		__field(	  int,	result_start		)
+		__field(	__u32, 	result_group		)
+		__field(	  int,	result_len		)
+	),
+
+	TP_fast_assign(
+		__entry-&gt;dev		= ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;ino		= ac-&gt;ac_inode-&gt;i_ino;
+		__entry-&gt;result_logical	= ac-&gt;ac_b_ex.fe_logical;
+		__entry-&gt;result_start	= ac-&gt;ac_b_ex.fe_start;
+		__entry-&gt;result_group	= ac-&gt;ac_b_ex.fe_group;
+		__entry-&gt;result_len	= ac-&gt;ac_b_ex.fe_len;
+	),
+
+	TP_printk("dev %s inode %lu extent %u/%d/%u@%u ",
+		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;result_group, __entry-&gt;result_start,
+		  __entry-&gt;result_len, __entry-&gt;result_logical)
+);
+
 #endif /* _TRACE_EXT4_H */
 
 /* This part must be outside protection */</pre><hr><pre>commit 90576c0b9a0b5323fc4bd7f23f49be0d234f36d1
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Sep 29 15:51:30 2009 -0400

    ext4, jbd2: Drop unneeded printks at mount and unmount time
    
    There are a number of kernel printk's which are printed when an ext4
    filesystem is mounted and unmounted.  Disable them to economize space
    in the system logs.  In addition, disabling the mballoc stats by
    default saves a number of unneeded atomic operations for every block
    allocation or deallocation.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 10a63096a95a..10539e364283 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -2380,6 +2380,7 @@ void ext4_ext_init(struct super_block *sb)
 	 */
 
 	if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_EXTENTS)) {
+#if defined(AGGRESSIVE_TEST) || defined(CHECK_BINSEARCH) || defined(EXTENTS_STATS)
 		printk(KERN_INFO "EXT4-fs: file extents enabled");
 #ifdef AGGRESSIVE_TEST
 		printk(", aggressive tests");
@@ -2391,6 +2392,7 @@ void ext4_ext_init(struct super_block *sb)
 		printk(", stats");
 #endif
 		printk("\n");
+#endif
 #ifdef EXTENTS_STATS
 		spin_lock_init(&amp;EXT4_SB(sb)-&gt;s_ext_stats_lock);
 		EXT4_SB(sb)-&gt;s_ext_min = 1 &lt;&lt; 30;
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index c73d43995b13..3e2320e66721 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -2712,8 +2712,6 @@ int ext4_mb_init(struct super_block *sb, int needs_recovery)
 
 	if (sbi-&gt;s_journal)
 		sbi-&gt;s_journal-&gt;j_commit_callback = release_blocks_on_commit;
-
-	printk(KERN_INFO "EXT4-fs: mballoc enabled\n");
 	return 0;
 }
 
diff --git a/fs/ext4/mballoc.h b/fs/ext4/mballoc.h
index 188d3d709b24..14f25f253112 100644
--- a/fs/ext4/mballoc.h
+++ b/fs/ext4/mballoc.h
@@ -84,7 +84,7 @@ extern u8 mb_enable_debug;
  * with 'ext4_mb_stats' allocator will collect stats that will be
  * shown at umount. The collecting costs though!
  */
-#define MB_DEFAULT_STATS		1
+#define MB_DEFAULT_STATS		0
 
 /*
  * files smaller than MB_DEFAULT_STREAM_THRESHOLD are served
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 3f7e7010c098..e5b206a043a5 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1673,13 +1673,6 @@ static int ext4_setup_super(struct super_block *sb, struct ext4_super_block *es,
 			EXT4_INODES_PER_GROUP(sb),
 			sbi-&gt;s_mount_opt);
 
-	if (EXT4_SB(sb)-&gt;s_journal) {
-		ext4_msg(sb, KERN_INFO, "%s journal on %s",
-		       EXT4_SB(sb)-&gt;s_journal-&gt;j_inode ? "internal" :
-		       "external", EXT4_SB(sb)-&gt;s_journal-&gt;j_devname);
-	} else {
-		ext4_msg(sb, KERN_INFO, "no journal");
-	}
 	return res;
 }
 
@@ -2885,12 +2878,12 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 			 "available");
 	}
 
-	if (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA) {
+	if (test_opt(sb, DELALLOC) &amp;&amp;
+	    (test_opt(sb, DATA_FLAGS) == EXT4_MOUNT_JOURNAL_DATA)) {
 		ext4_msg(sb, KERN_WARNING, "Ignoring delalloc option - "
 			 "requested data journaling mode");
 		clear_opt(sbi-&gt;s_mount_opt, DELALLOC);
-	} else if (test_opt(sb, DELALLOC))
-		ext4_msg(sb, KERN_INFO, "delayed allocation enabled");
+	}
 
 	err = ext4_setup_system_zone(sb);
 	if (err) {
@@ -3202,9 +3195,7 @@ static int ext4_load_journal(struct super_block *sb,
 			return -EINVAL;
 	}
 
-	if (journal-&gt;j_flags &amp; JBD2_BARRIER)
-		ext4_msg(sb, KERN_INFO, "barriers enabled");
-	else
+	if (!(journal-&gt;j_flags &amp; JBD2_BARRIER))
 		ext4_msg(sb, KERN_INFO, "barriers disabled");
 
 	if (!really_read_only &amp;&amp; test_opt(sb, UPDATE_JOURNAL)) {
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 53b86e16e5fe..977a8dafb76d 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -136,10 +136,6 @@ static int kjournald2(void *arg)
 	journal-&gt;j_task = current;
 	wake_up(&amp;journal-&gt;j_wait_done_commit);
 
-	printk(KERN_INFO "kjournald2 starting: pid %d, dev %s, "
-	       "commit interval %ld seconds\n", current-&gt;pid,
-	       journal-&gt;j_devname, journal-&gt;j_commit_interval / HZ);
-
 	/*
 	 * And now, wait forever for commit wakeup events.
 	 */
@@ -223,7 +219,8 @@ static int jbd2_journal_start_thread(journal_t *journal)
 {
 	struct task_struct *t;
 
-	t = kthread_run(kjournald2, journal, "kjournald2");
+	t = kthread_run(kjournald2, journal, "jbd2/%s",
+			journal-&gt;j_devname);
 	if (IS_ERR(t))
 		return PTR_ERR(t);
 
@@ -1115,7 +1112,7 @@ journal_t * jbd2_journal_init_inode (struct inode *inode)
 	while ((p = strchr(p, '/')))
 		*p = '!';
 	p = journal-&gt;j_devname + strlen(journal-&gt;j_devname);
-	sprintf(p, ":%lu", journal-&gt;j_inode-&gt;i_ino);
+	sprintf(p, "-%lu", journal-&gt;j_inode-&gt;i_ino);
 	jbd_debug(1,
 		  "journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\n",
 		  journal, inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,</pre>
    <div class="pagination">
        <a href='1_87.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><span>[88]</span><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_89.html'>Next&gt;&gt;</a>
    <div>
</body>
