<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_39.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><span>[40]</span><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_41.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ee74290b7853db9d5fd64db70e5c175241c59fba
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:17:43 2013 -0500

    USB: EHCI: fix timer bug affecting port resume
    
    This patch (as1652) fixes a long-standing bug in ehci-hcd.  The driver
    relies on status polls to know when to stop port-resume signalling.
    It uses the root-hub status timer to schedule these status polls.  But
    when the driver for the root hub is resumed, the timer is rescheduled
    to go off immediately -- before the port is ready.  When this happens
    the timer does not get re-enabled, which prevents the port resume from
    finishing until some other event occurs.
    
    The symptom is that when a new device is plugged in, it doesn't get
    recognized or enumerated until lsusb is run or something else happens.
    
    The solution is to re-enable the root-hub status timer after every
    status poll while a port resume is in progress.
    
    This bug hasn't surfaced before now because we never used to try to
    suspend the root hub in the middle of a port resume (except by
    coincidence).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Norbert Preining &lt;preining@logic.at&gt;
    Tested-by: Ming Lei &lt;ming.lei@canonical.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index f88be801d60c..4d3b294f203e 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -649,7 +649,11 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 			status = STS_PCD;
 		}
 	}
-	/* FIXME autosuspend idle root hubs */
+
+	/* If a resume is in progress, make sure it can finish */
+	if (ehci-&gt;resuming_ports)
+		mod_timer(&amp;hcd-&gt;rh_timer, jiffies + msecs_to_jiffies(25));
+
 	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
 	return status ? retval : 0;
 }</pre><hr><pre>commit 840008bb5162f029d5bc05959c7f51a3e8f9e0ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:09:55 2013 -0500

    USB: UHCI: notify usbcore about port resumes
    
    This patch (as1651) adds calls to the new
    usb_hcd_{start,end}_port_resume() functions to uhci-hcd.  Now UHCI
    root hubs won't be runtime suspended while they are sending a resume
    signal to one of their ports.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 768d54295a20..15d13229ddbb 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -116,6 +116,7 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 		}
 	}
 	clear_bit(port, &amp;uhci-&gt;resuming_ports);
+	usb_hcd_end_port_resume(&amp;uhci_to_hcd(uhci)-&gt;self, port);
 }
 
 /* Wait for the UHCI controller in HP's iLO2 server management chip.
@@ -167,6 +168,8 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
 						msecs_to_jiffies(25);
+				usb_hcd_start_port_resume(
+						&amp;uhci_to_hcd(uhci)-&gt;self, port);
 
 				/* Make sure we see the port again
 				 * after the resuming period is over. */</pre><hr><pre>commit f292e7f9fb0e4bec68bbd83443407d6bb7922d36
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:09:49 2013 -0500

    USB: EHCI: notify usbcore about port resumes
    
    This patch (as1650) adds calls to the new
    usb_hcd_{start,end}_port_resume() functions to ehci-hcd.  Now EHCI
    root hubs won't be runtime suspended while they are sending a resume
    signal to one of their ports.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Ming Lei &lt;ming.lei@canonical.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 09537b2f1002..b416a3fc9959 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -797,6 +797,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);
 			set_bit(i, &amp;ehci-&gt;resuming_ports);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
+			usb_hcd_start_port_resume(&amp;hcd-&gt;self, i);
 			mod_timer(&amp;hcd-&gt;rh_timer, ehci-&gt;reset_done[i]);
 		}
 	}
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 4ccb97c0678f..f88be801d60c 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -851,6 +851,7 @@ static int ehci_hub_control (
 				/* resume signaling for 20 msec */
 				ehci-&gt;reset_done[wIndex] = jiffies
 						+ msecs_to_jiffies(20);
+				usb_hcd_start_port_resume(&amp;hcd-&gt;self, wIndex);
 				/* check the port again */
 				mod_timer(&amp;ehci_to_hcd(ehci)-&gt;rh_timer,
 						ehci-&gt;reset_done[wIndex]);
@@ -862,6 +863,7 @@ static int ehci_hub_control (
 				clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
 				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
 				ehci-&gt;reset_done[wIndex] = 0;
+				usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
 
 				/* stop resume signaling */
 				temp = ehci_readl(ehci, status_reg);
@@ -950,6 +952,7 @@ static int ehci_hub_control (
 			ehci-&gt;reset_done[wIndex] = 0;
 			if (temp &amp; PORT_PE)
 				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
+			usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
 		}
 
 		if (temp &amp; PORT_OC)</pre><hr><pre>commit da0aa7169b97d90f4af39a9dc84d58bbe19d7e78
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 17:09:42 2013 -0500

    USB: add usb_hcd_{start,end}_port_resume
    
    This patch (as1649) adds a mechanism for host controller drivers to
    inform usbcore when they have begun or ended resume signalling on a
    particular root-hub port.  The core will then make sure that the root
    hub does not get runtime-suspended while the port resume is going on.
    
    Since commit 596d789a211d134dc5f94d1e5957248c204ef850 (USB: set hub's
    default autosuspend delay as 0), the system tries to suspend hubs
    whenever they aren't in use.  While a root-hub port is being resumed,
    the root hub does not appear to be in use.  Attempted runtime suspends
    fail because of the ongoing port resume, but the PM core just keeps on
    trying over and over again.  We want to prevent this wasteful effort.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Ming Lei &lt;ming.lei@canonical.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 4225d5e72131..8e64adf8e4d5 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -39,6 +39,7 @@
 #include &lt;asm/unaligned.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/workqueue.h&gt;
+#include &lt;linux/pm_runtime.h&gt;
 
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/hcd.h&gt;
@@ -1025,6 +1026,49 @@ static int register_root_hub(struct usb_hcd *hcd)
 	return retval;
 }
 
+/*
+ * usb_hcd_start_port_resume - a root-hub port is sending a resume signal
+ * @bus: the bus which the root hub belongs to
+ * @portnum: the port which is being resumed
+ *
+ * HCDs should call this function when they know that a resume signal is
+ * being sent to a root-hub port.  The root hub will be prevented from
+ * going into autosuspend until usb_hcd_end_port_resume() is called.
+ *
+ * The bus's private lock must be held by the caller.
+ */
+void usb_hcd_start_port_resume(struct usb_bus *bus, int portnum)
+{
+	unsigned bit = 1 &lt;&lt; portnum;
+
+	if (!(bus-&gt;resuming_ports &amp; bit)) {
+		bus-&gt;resuming_ports |= bit;
+		pm_runtime_get_noresume(&amp;bus-&gt;root_hub-&gt;dev);
+	}
+}
+EXPORT_SYMBOL_GPL(usb_hcd_start_port_resume);
+
+/*
+ * usb_hcd_end_port_resume - a root-hub port has stopped sending a resume signal
+ * @bus: the bus which the root hub belongs to
+ * @portnum: the port which is being resumed
+ *
+ * HCDs should call this function when they know that a resume signal has
+ * stopped being sent to a root-hub port.  The root hub will be allowed to
+ * autosuspend again.
+ *
+ * The bus's private lock must be held by the caller.
+ */
+void usb_hcd_end_port_resume(struct usb_bus *bus, int portnum)
+{
+	unsigned bit = 1 &lt;&lt; portnum;
+
+	if (bus-&gt;resuming_ports &amp; bit) {
+		bus-&gt;resuming_ports &amp;= ~bit;
+		pm_runtime_put_noidle(&amp;bus-&gt;root_hub-&gt;dev);
+	}
+}
+EXPORT_SYMBOL_GPL(usb_hcd_end_port_resume);
 
 /*-------------------------------------------------------------------------*/
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 689b14b26c8d..4d22d0f6167a 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -357,6 +357,8 @@ struct usb_bus {
 	int bandwidth_int_reqs;		/* number of Interrupt requests */
 	int bandwidth_isoc_reqs;	/* number of Isoc. requests */
 
+	unsigned resuming_ports;	/* bit array: resuming root-hub ports */
+
 #if defined(CONFIG_USB_MON) || defined(CONFIG_USB_MON_MODULE)
 	struct mon_bus *mon_bus;	/* non-null when associated */
 	int monitored;			/* non-zero when monitored */
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 608050b2545f..0a78df5f6cfd 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -430,6 +430,9 @@ extern void usb_hcd_poll_rh_status(struct usb_hcd *hcd);
 extern void usb_wakeup_notification(struct usb_device *hdev,
 		unsigned int portnum);
 
+extern void usb_hcd_start_port_resume(struct usb_bus *bus, int portnum);
+extern void usb_hcd_end_port_resume(struct usb_bus *bus, int portnum);
+
 /* The D0/D1 toggle bits ... USE WITH CAUTION (they're almost hcd-internal) */
 #define usb_gettoggle(dev, ep, out) (((dev)-&gt;toggle[out] &gt;&gt; (ep)) &amp; 1)
 #define	usb_dotoggle(dev, ep, out)  ((dev)-&gt;toggle[out] ^= (1 &lt;&lt; (ep)))</pre><hr><pre>commit 6e0c3339a6f19d748f16091d0a05adeb1e1f822b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 16:54:22 2013 -0500

    USB: EHCI: unlink one async QH at a time
    
    This patch (as1648) fixes a regression affecting nVidia EHCI
    controllers.  Evidently they don't like to have more than one async QH
    unlinked at a time.  I can't imagine how they manage to mess it up,
    but at least one of them does.
    
    The patch changes the async unlink logic in two ways:
    
            Each time an IAA cycle is started, only the first QH on the
            async unlink list is handled (rather than all of them).
    
            Async QHs do not all get unlinked as soon as they have been
            empty for long enough.  Instead, only the last one (i.e., the
            one that has been on the schedule the longest) is unlinked,
            and then only if no other unlinks are in progress at the time.
    
    This means that when multiple QHs are empty, they won't be unlinked as
    quickly as before.  That's okay; it won't affect correct operation of
    the driver or add an excessive load.  Multiple unlinks tend to be
    relatively rare in any case.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Piergiorgio Sartor &lt;piergiorgio.sartor@nexgo.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt; # 3.6
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 3d989028c836..fd252f0cfb3a 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1197,17 +1197,26 @@ static void start_iaa_cycle(struct ehci_hcd *ehci, bool nested)
 	if (ehci-&gt;async_iaa || ehci-&gt;async_unlinking)
 		return;
 
-	/* Do all the waiting QHs at once */
-	ehci-&gt;async_iaa = ehci-&gt;async_unlink;
-	ehci-&gt;async_unlink = NULL;
-
 	/* If the controller isn't running, we don't have to wait for it */
 	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
+
+		/* Do all the waiting QHs */
+		ehci-&gt;async_iaa = ehci-&gt;async_unlink;
+		ehci-&gt;async_unlink = NULL;
+
 		if (!nested)		/* Avoid recursion */
 			end_unlink_async(ehci);
 
 	/* Otherwise start a new IAA cycle */
 	} else if (likely(ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
+		struct ehci_qh		*qh;
+
+		/* Do only the first waiting QH (nVidia bug?) */
+		qh = ehci-&gt;async_unlink;
+		ehci-&gt;async_iaa = qh;
+		ehci-&gt;async_unlink = qh-&gt;unlink_next;
+		qh-&gt;unlink_next = NULL;
+
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();
 
@@ -1255,34 +1264,35 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	}
 }
 
+static void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh);
+
 static void unlink_empty_async(struct ehci_hcd *ehci)
 {
-	struct ehci_qh		*qh, *next;
-	bool			stopped = (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING);
+	struct ehci_qh		*qh;
+	struct ehci_qh		*qh_to_unlink = NULL;
 	bool			check_unlinks_later = false;
+	int			count = 0;
 
-	/* Unlink all the async QHs that have been empty for a timer cycle */
-	next = ehci-&gt;async-&gt;qh_next.qh;
-	while (next) {
-		qh = next;
-		next = qh-&gt;qh_next.qh;
-
+	/* Find the last async QH which has been empty for a timer cycle */
+	for (qh = ehci-&gt;async-&gt;qh_next.qh; qh; qh = qh-&gt;qh_next.qh) {
 		if (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
 				qh-&gt;qh_state == QH_STATE_LINKED) {
-			if (!stopped &amp;&amp; qh-&gt;unlink_cycle ==
-					ehci-&gt;async_unlink_cycle)
+			++count;
+			if (qh-&gt;unlink_cycle == ehci-&gt;async_unlink_cycle)
 				check_unlinks_later = true;
 			else
-				single_unlink_async(ehci, qh);
+				qh_to_unlink = qh;
 		}
 	}
 
-	/* Start a new IAA cycle if any QHs are waiting for it */
-	if (ehci-&gt;async_unlink)
-		start_iaa_cycle(ehci, false);
+	/* If nothing else is being unlinked, unlink the last empty QH */
+	if (!ehci-&gt;async_iaa &amp;&amp; !ehci-&gt;async_unlink &amp;&amp; qh_to_unlink) {
+		start_unlink_async(ehci, qh_to_unlink);
+		--count;
+	}
 
-	/* QHs that haven't been empty for long enough will be handled later */
-	if (check_unlinks_later) {
+	/* Other QHs will be handled later */
+	if (count &gt; 0) {
 		ehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);
 		++ehci-&gt;async_unlink_cycle;
 	}</pre><hr><pre>commit 55bcdce8a8228223ec4d17d8ded8134ed265d2c5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 25 16:52:45 2013 -0500

    USB: EHCI: remove ASS/PSS polling timeout
    
    This patch (as1647) attempts to work around a problem that seems to
    affect some nVidia EHCI controllers.  They sometimes take a very long
    time to turn off their async or periodic schedules.  I don't know if
    this is a result of other problems, but in any case it seems wise not
    to depend on schedule enables or disables taking effect in any
    specific length of time.
    
    The patch removes the existing 20-ms timeout for enabling and
    disabling the schedules.  The driver will now continue to poll the
    schedule state at 1-ms intervals until the controller finally decides
    to obey the most recent command issued by the driver.  Just in case
    this hides a problem, a debugging message will be logged if the
    controller takes longer than 20 polls.
    
    I don't know if this will actually fix anything, but it can't hurt.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Piergiorgio Sartor &lt;piergiorgio.sartor@nexgo.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 20dbdcbe9b0f..f904071d70df 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -113,14 +113,15 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;ASS_poll_count++ &lt; 20) {
-			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
-			return;
-		}
-		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
-				want, actual);
+		/* Poll again later */
+		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
+		++ehci-&gt;ASS_poll_count;
+		return;
 	}
+
+	if (ehci-&gt;ASS_poll_count &gt; 20)
+		ehci_dbg(ehci, "ASS poll count reached %d\n",
+				ehci-&gt;ASS_poll_count);
 	ehci-&gt;ASS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
@@ -159,14 +160,14 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	if (want != actual) {
 
-		/* Poll again later, but give up after about 20 ms */
-		if (ehci-&gt;PSS_poll_count++ &lt; 20) {
-			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
-			return;
-		}
-		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
-				want, actual);
+		/* Poll again later */
+		ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
+		return;
 	}
+
+	if (ehci-&gt;PSS_poll_count &gt; 20)
+		ehci_dbg(ehci, "PSS poll count reached %d\n",
+				ehci-&gt;PSS_poll_count);
 	ehci-&gt;PSS_poll_count = 0;
 
 	/* The status is up-to-date; restart or stop the schedule as needed */</pre><hr><pre>commit bdb6bc06f7d694652c12fb8779bb031c2f220823
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 24 15:04:13 2013 -0500

    USB: fix sign-extension bug in the hub driver
    
    This patch (as1646) fixes a long-standing bug in the USB hub driver.
    Upon conversion from char to unsigned long, the bytes in the status
    buffer are subject to unwanted sign extension.  The bytes should be
    declared as u8 rather than char, to prevent this.
    
    This effects of this bug are minimal.  The hub driver may end up doing
    a little unnecessary extra work because it thinks events have occurred
    on some ports when they really haven't.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index d16a7c98aea9..c472058f8f27 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -31,7 +31,7 @@ struct usb_hub {
 	struct urb		*urb;		/* for interrupt polling pipe */
 
 	/* buffer for urb ... with extra space in case of babble */
-	char			(*buffer)[8];
+	u8			(*buffer)[8];
 	union {
 		struct usb_hub_status	hub;
 		struct usb_port_status	port;</pre><hr><pre>commit 48c3375c5f69b1c2ef3d1051a0009cb9bce0ce24
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 17 10:32:16 2013 -0500

    USB: XHCI: fix memory leak of URB-private data
    
    This patch (as1640) fixes a memory leak in xhci-hcd.  The urb_priv
    data structure isn't always deallocated in the handle_tx_event()
    routine for non-control transfers.  The patch adds a kfree() call so
    that all paths end up freeing the memory properly.
    
    This patch should be backported to kernels as old as 2.6.36, that
    contain the commit 8e51adccd4c4b9ffcd509d7f2afce0a906139f75 "USB: xHCI:
    Introduce urb_priv structure"
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Reported-and-tested-by: Martin Mokrejs &lt;mmokrejs@fold.natur.cuni.cz&gt;
    CC: &lt;stable@vger.kernel.org&gt;

diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index 151204642a6e..7f76a49e90d3 100644
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -2589,6 +2589,8 @@ static int handle_tx_event(struct xhci_hcd *xhci,
 				(trb_comp_code != COMP_STALL &amp;&amp;
 					trb_comp_code != COMP_BABBLE))
 				xhci_urb_free_priv(xhci, urb_priv);
+			else
+				kfree(urb_priv);
 
 			usb_hcd_unlink_urb_from_ep(bus_to_hcd(urb-&gt;dev-&gt;bus), urb);
 			if ((urb-&gt;actual_length != urb-&gt;transfer_buffer_length &amp;&amp;</pre><hr><pre>commit dba63b2f733ebfd89bbb15e8fe8ca10fd3871a7f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jan 23 13:26:15 2013 -0500

    USB: EHCI: fix build error in ehci-mxc
    
    This patch (as1643b) fixes a build error in ehci-hcd when compiling for
    ARM with allmodconfig:
    
    drivers/usb/host/ehci-hcd.c:1285:0: warning: "PLATFORM_DRIVER" redefined [enabled by default]
    drivers/usb/host/ehci-hcd.c:1255:0: note: this is the location of the previous definition
    drivers/usb/host/ehci-mxc.c:280:31: warning: 'ehci_mxc_driver' defined but not used [-Wunused-variable]
    drivers/usb/host/ehci-hcd.c:1285:0: warning: "PLATFORM_DRIVER" redefined [enabled by default]
    drivers/usb/host/ehci-hcd.c:1255:0: note: this is the location of the previous definition
    
    The fix is to convert ehci-mxc over to the new "ehci-hcd is a library"
    scheme so that it can coexist peacefully with the ehci-platform
    driver.  As part of the conversion the ehci_mxc_priv data structure,
    which was allocated dynamically, is now placed where it belongs: in
    the private area at the end of struct ehci_hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Shawn Guo &lt;shawn.guo@linaro.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index d6bb128ce21e..3a21c5d683c0 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -148,7 +148,7 @@ config USB_EHCI_FSL
 	  Variation of ARC USB block used in some Freescale chips.
 
 config USB_EHCI_MXC
-	bool "Support for Freescale i.MX on-chip EHCI USB controller"
+	tristate "Support for Freescale i.MX on-chip EHCI USB controller"
 	depends on USB_EHCI_HCD &amp;&amp; ARCH_MXC
 	select USB_EHCI_ROOT_HUB_TT
 	---help---
diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 1eb4c3006e9e..001fbff2fdef 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_PCI)		+= pci-quirks.o
 obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
 obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
 obj-$(CONFIG_USB_EHCI_HCD_PLATFORM)	+= ehci-platform.o
+obj-$(CONFIG_USB_EHCI_MXC)	+= ehci-mxc.o
 
 obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
 obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d09ff8f294fe..09537b2f1002 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1246,11 +1246,6 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_fsl_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_MXC
-#include "ehci-mxc.c"
-#define PLATFORM_DRIVER		ehci_mxc_driver
-#endif
-
 #ifdef CONFIG_USB_EHCI_SH
 #include "ehci-sh.c"
 #define PLATFORM_DRIVER		ehci_hcd_sh_driver
@@ -1349,6 +1344,7 @@ MODULE_LICENSE ("GPL");
 #if !IS_ENABLED(CONFIG_USB_EHCI_PCI) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_EHCI_HCD_PLATFORM) &amp;&amp; \
 	!IS_ENABLED(CONFIG_USB_CHIPIDEA_HOST) &amp;&amp; \
+	!IS_ENABLED(CONFIG_USB_EHCI_MXC) &amp;&amp; \
 	!defined(PLATFORM_DRIVER) &amp;&amp; \
 	!defined(PS3_SYSTEM_BUS_DRIVER) &amp;&amp; \
 	!defined(OF_PLATFORM_DRIVER) &amp;&amp; \
diff --git a/drivers/usb/host/ehci-mxc.c b/drivers/usb/host/ehci-mxc.c
index ec7f5d2c90de..dedb80bb8d40 100644
--- a/drivers/usb/host/ehci-mxc.c
+++ b/drivers/usb/host/ehci-mxc.c
@@ -17,75 +17,38 @@
  * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/io.h&gt;
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/clk.h&gt;
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/usb/otg.h&gt;
 #include &lt;linux/usb/ulpi.h&gt;
 #include &lt;linux/slab.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/hcd.h&gt;
 
 #include &lt;linux/platform_data/usb-ehci-mxc.h&gt;
 
 #include &lt;asm/mach-types.h&gt;
 
+#include "ehci.h"
+
+#define DRIVER_DESC "Freescale On-Chip EHCI Host driver"
+
+static const char hcd_name[] = "ehci-mxc";
+
 #define ULPI_VIEWPORT_OFFSET	0x170
 
 struct ehci_mxc_priv {
 	struct clk *usbclk, *ahbclk, *phyclk;
-	struct usb_hcd *hcd;
 };
 
-/* called during probe() after chip reset completes */
-static int ehci_mxc_setup(struct usb_hcd *hcd)
-{
-	hcd-&gt;has_tt = 1;
-
-	return ehci_setup(hcd);
-}
+static struct hc_driver __read_mostly ehci_mxc_hc_driver;
 
-static const struct hc_driver ehci_mxc_hc_driver = {
-	.description = hcd_name,
-	.product_desc = "Freescale On-Chip EHCI Host Controller",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_USB2 | HCD_MEMORY,
-
-	/*
-	 * basic lifecycle operations
-	 */
-	.reset = ehci_mxc_setup,
-	.start = ehci_run,
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-	.endpoint_reset = ehci_endpoint_reset,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-	.bus_suspend = ehci_bus_suspend,
-	.bus_resume = ehci_bus_resume,
-	.relinquish_port = ehci_relinquish_port,
-	.port_handed_over = ehci_port_handed_over,
-
-	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+static const struct ehci_driver_overrides ehci_mxc_overrides __initdata = {
+	.extra_priv_size =	sizeof(struct ehci_mxc_priv),
 };
 
 static int ehci_mxc_drv_probe(struct platform_device *pdev)
@@ -112,12 +75,6 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 	if (!hcd)
 		return -ENOMEM;
 
-	priv = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		ret = -ENOMEM;
-		goto err_alloc;
-	}
-
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(dev, "Found HC with no register addr. Check setup!\n");
@@ -135,6 +92,10 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 		goto err_alloc;
 	}
 
+	hcd-&gt;has_tt = 1;
+	ehci = hcd_to_ehci(hcd);
+	priv = (struct ehci_mxc_priv *) ehci-&gt;priv;
+
 	/* enable clocks */
 	priv-&gt;usbclk = devm_clk_get(&amp;pdev-&gt;dev, "ipg");
 	if (IS_ERR(priv-&gt;usbclk)) {
@@ -169,8 +130,6 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 		mdelay(10);
 	}
 
-	ehci = hcd_to_ehci(hcd);
-
 	/* EHCI registers start at offset 0x100 */
 	ehci-&gt;caps = hcd-&gt;regs + 0x100;
 	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
@@ -198,8 +157,7 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 		}
 	}
 
-	priv-&gt;hcd = hcd;
-	platform_set_drvdata(pdev, priv);
+	platform_set_drvdata(pdev, hcd);
 
 	ret = usb_add_hcd(hcd, irq, IRQF_SHARED);
 	if (ret)
@@ -244,8 +202,11 @@ static int ehci_mxc_drv_probe(struct platform_device *pdev)
 static int __exit ehci_mxc_drv_remove(struct platform_device *pdev)
 {
 	struct mxc_usbh_platform_data *pdata = pdev-&gt;dev.platform_data;
-	struct ehci_mxc_priv *priv = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = priv-&gt;hcd;
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	struct ehci_mxc_priv *priv = (struct ehci_mxc_priv *) ehci-&gt;priv;
+
+	usb_remove_hcd(hcd);
 
 	if (pdata &amp;&amp; pdata-&gt;exit)
 		pdata-&gt;exit(pdev);
@@ -253,23 +214,20 @@ static int __exit ehci_mxc_drv_remove(struct platform_device *pdev)
 	if (pdata-&gt;otg)
 		usb_phy_shutdown(pdata-&gt;otg);
 
-	usb_remove_hcd(hcd);
-	usb_put_hcd(hcd);
-	platform_set_drvdata(pdev, NULL);
-
 	clk_disable_unprepare(priv-&gt;usbclk);
 	clk_disable_unprepare(priv-&gt;ahbclk);
 
 	if (priv-&gt;phyclk)
 		clk_disable_unprepare(priv-&gt;phyclk);
 
+	usb_put_hcd(hcd);
+	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
 
 static void ehci_mxc_drv_shutdown(struct platform_device *pdev)
 {
-	struct ehci_mxc_priv *priv = platform_get_drvdata(pdev);
-	struct usb_hcd *hcd = priv-&gt;hcd;
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
 
 	if (hcd-&gt;driver-&gt;shutdown)
 		hcd-&gt;driver-&gt;shutdown(hcd);
@@ -279,9 +237,31 @@ MODULE_ALIAS("platform:mxc-ehci");
 
 static struct platform_driver ehci_mxc_driver = {
 	.probe = ehci_mxc_drv_probe,
-	.remove = __exit_p(ehci_mxc_drv_remove),
+	.remove = ehci_mxc_drv_remove,
 	.shutdown = ehci_mxc_drv_shutdown,
 	.driver = {
 		   .name = "mxc-ehci",
 	},
 };
+
+static int __init ehci_mxc_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
+
+	ehci_init_driver(&amp;ehci_mxc_hc_driver, &amp;ehci_mxc_overrides);
+	return platform_driver_register(&amp;ehci_mxc_driver);
+}
+module_init(ehci_mxc_init);
+
+static void __exit ehci_mxc_cleanup(void)
+{
+	platform_driver_unregister(&amp;ehci_mxc_driver);
+}
+module_exit(ehci_mxc_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Sascha Hauer");
+MODULE_LICENSE("GPL");</pre><hr><pre>commit 9debc1793b36124b9304255d2e8b5b6d8b491793
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 22 12:00:26 2013 -0500

    USB: EHCI: add a name for the platform-private field
    
    This patch (as1642) adds an ehci-&gt;priv field for private use by EHCI
    platform drivers.  The space was provided some time ago, but it didn't
    have a name.
    
    Until now none of the platform drivers has used this private space,
    but that's about to change in the next patch of this series.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 88f0142aea0c..36c3a8210595 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -225,6 +225,9 @@ struct ehci_hcd {			/* one per controller */
 #ifdef DEBUG
 	struct dentry		*debug_dir;
 #endif
+
+	/* platform-specific data -- must come last */
+	unsigned long		priv[0] __aligned(sizeof(s64));
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */</pre>
    <div class="pagination">
        <a href='2_39.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><span>[40]</span><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_41.html'>Next&gt;&gt;</a>
    <div>
</body>
