<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Wuhan University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Wuhan University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit 2fd60da46da76948b8cc561ae8cc902209686253
Author: Peng Wang &lt;rocking@whu.edu.cn&gt;
Date:   Mon Jul 8 23:16:11 2019 +0800

    kernfs: fix potential null pointer dereference
    
    Get root safely after kn is ensureed to be not null.
    
    Signed-off-by: Peng Wang &lt;rocking@whu.edu.cn&gt;
    Acked-by: Tejun Heo &lt;tj@kernel.org&gt;
    Link: https://lore.kernel.org/r/20190708151611.13242-1-rocking@whu.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c
index a387534c9577..ddf537923a0a 100644
--- a/fs/kernfs/dir.c
+++ b/fs/kernfs/dir.c
@@ -430,7 +430,6 @@ struct kernfs_node *kernfs_get_active(struct kernfs_node *kn)
  */
 void kernfs_put_active(struct kernfs_node *kn)
 {
-	struct kernfs_root *root = kernfs_root(kn);
 	int v;
 
 	if (unlikely(!kn))
@@ -442,7 +441,7 @@ void kernfs_put_active(struct kernfs_node *kn)
 	if (likely(v != KN_DEACTIVATED_BIAS))
 		return;
 
-	wake_up_all(&amp;root-&gt;deactivate_waitq);
+	wake_up_all(&amp;kernfs_root(kn)-&gt;deactivate_waitq);
 }
 
 /**</pre><hr><pre>commit a581563f1bef035e4c8d634a1df26dae9140b115
Author: Peng Wang &lt;rocking@whu.edu.cn&gt;
Date:   Wed Jul 3 10:07:49 2019 +0800

    cgroup: minor tweak for logic to get cgroup css
    
    We could only handle the case that css exists
    and css_try_get_online() fails.
    
    Signed-off-by: Peng Wang &lt;rocking@whu.edu.cn&gt;
    Signed-off-by: Tejun Heo &lt;tj@kernel.org&gt;

diff --git a/kernel/cgroup/cgroup.c b/kernel/cgroup/cgroup.c
index 3c3d92d993e8..21ddf3053235 100644
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@ -488,7 +488,7 @@ static struct cgroup_subsys_state *cgroup_tryget_css(struct cgroup *cgrp,
 
 	rcu_read_lock();
 	css = cgroup_css(cgrp, ss);
-	if (!css || !css_tryget_online(css))
+	if (css &amp;&amp; !css_tryget_online(css))
 		css = NULL;
 	rcu_read_unlock();
 </pre><hr><pre>commit 514cf4f881dc82507d87d2ccd5e7478fd36632fa
Author: Peng Wang &lt;rocking@whu.edu.cn&gt;
Date:   Thu Apr 18 21:59:19 2019 +0800

    dm: only initialize md-&gt;dax_dev if CONFIG_DAX_DRIVER is enabled
    
    md-&gt;dax_dev defaults to NULL and there is no need to initialize it
    if CONFIG_DAX_DRIVER is disabled.
    
    Signed-off-by: Peng Wang &lt;rocking@whu.edu.cn&gt;
    Signed-off-by: Mike Snitzer &lt;snitzer@redhat.com&gt;

diff --git a/drivers/md/dm.c b/drivers/md/dm.c
index 043f0761e4a0..56c34a0a9cd9 100644
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@ -1906,7 +1906,6 @@ static void cleanup_mapped_device(struct mapped_device *md)
 static struct mapped_device *alloc_dev(int minor)
 {
 	int r, numa_node_id = dm_get_numa_node();
-	struct dax_device *dax_dev = NULL;
 	struct mapped_device *md;
 	void *old_md;
 
@@ -1969,11 +1968,10 @@ static struct mapped_device *alloc_dev(int minor)
 	sprintf(md-&gt;disk-&gt;disk_name, "dm-%d", minor);
 
 	if (IS_ENABLED(CONFIG_DAX_DRIVER)) {
-		dax_dev = alloc_dax(md, md-&gt;disk-&gt;disk_name, &amp;dm_dax_ops);
-		if (!dax_dev)
+		md-&gt;dax_dev = alloc_dax(md, md-&gt;disk-&gt;disk_name, &amp;dm_dax_ops);
+		if (!md-&gt;dax_dev)
 			goto bad;
 	}
-	md-&gt;dax_dev = dax_dev;
 
 	add_disk_no_queue_reg(md-&gt;disk);
 	format_dev_t(md-&gt;name, MKDEV(_major, minor));</pre><hr><pre>commit edde82b6df70cf10486d7f1e1611151218e6c316
Author: Peng Wang &lt;rocking@whu.edu.cn&gt;
Date:   Tue Mar 5 15:42:00 2019 -0800

    mm/slub.c: freelist is ensured to be NULL when new_slab() fails
    
    new_slab_objects() will return immediately if freelist is not NULL.
    
             if (freelist)
                     return freelist;
    
    One more assignment operation could be avoided.
    
    Link: http://lkml.kernel.org/r/20181229062512.30469-1-rocking@whu.edu.cn
    Signed-off-by: Peng Wang &lt;rocking@whu.edu.cn&gt;
    Reviewed-by: Pekka Enberg &lt;penberg@kernel.org&gt;
    Reviewed-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Acked-by: David Rientjes &lt;rientjes@google.com&gt;
    Cc: Christoph Lameter &lt;cl@linux.com&gt;
    Cc: Joonsoo Kim &lt;iamjoonsoo.kim@lge.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/mm/slub.c b/mm/slub.c
index dc777761b6b7..a561f909446d 100644
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -2482,8 +2482,7 @@ static inline void *new_slab_objects(struct kmem_cache *s, gfp_t flags,
 		stat(s, ALLOC_SLAB);
 		c-&gt;page = page;
 		*pc = c;
-	} else
-		freelist = NULL;
+	}
 
 	return freelist;
 }</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
