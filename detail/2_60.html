<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_59.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><span>[60]</span><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_61.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d5aa475180d03d45c5dc6134aa833f1b3e89c45e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 10 11:23:05 2011 -0500

    USB: g_printer: fix bug in unregistration
    
    This patch (as1441) fixes a bug in g_printer.  The gadget driver, char
    device number, and class device should be unregistered in reverse
    order of registration.  As it is now, when the module is unloaded the
    class device gets unregistered first, causing a crash when the unbind
    method tries to access it.
    
    This fixes Bugzilla #25882.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Roland Kletzing &lt;devzero@web.de&gt;
    CC: Craig W. Nadler &lt;craig@nadler.us&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/printer.c b/drivers/usb/gadget/printer.c
index 2fc8636316c5..dacc67724fe1 100644
--- a/drivers/usb/gadget/printer.c
+++ b/drivers/usb/gadget/printer.c
@@ -1596,13 +1596,12 @@ cleanup(void)
 	int status;
 
 	mutex_lock(&amp;usb_printer_gadget.lock_printer_io);
-	class_destroy(usb_gadget_class);
-	unregister_chrdev_region(g_printer_devno, 2);
-
 	status = usb_gadget_unregister_driver(&amp;printer_driver);
 	if (status)
 		ERROR(dev, "usb_gadget_unregister_driver %x\n", status);
 
+	unregister_chrdev_region(g_printer_devno, 2);
+	class_destroy(usb_gadget_class);
 	mutex_unlock(&amp;usb_printer_gadget.lock_printer_io);
 }
 module_exit(cleanup);</pre><hr><pre>commit f75593ceaa08e6d27aec1a5de31cded19e850dd1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jan 6 10:17:09 2011 -0500

    USB: EHCI: fix DMA deallocation bug
    
    This patch (as1440) fixes a bug in ehci-hcd.  ehci-&gt;periodic_size is
    used to compute the size in a dma_alloc_coherent() call, but then it
    gets changed later on.  As a result, the corresponding call to
    dma_free_coherent() passes a different size from the original
    allocation.  Fix the problem by adjusting ehci-&gt;periodic_size before
    carrying out any of the memory allocations.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Larry Finger &lt;Larry.Finger@lwfinger.net&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6fee3cd58efe..74dcf49bd015 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -572,6 +572,8 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci-&gt;iaa_watchdog.function = ehci_iaa_watchdog;
 	ehci-&gt;iaa_watchdog.data = (unsigned long) ehci;
 
+	hcc_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcc_params);
+
 	/*
 	 * hw default: 1K periodic list heads, one per frame.
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
@@ -579,11 +581,20 @@ static int ehci_init(struct usb_hcd *hcd)
 	ehci-&gt;periodic_size = DEFAULT_I_TDPS;
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
+
+	if (HCC_PGM_FRAMELISTLEN(hcc_params)) {
+		/* periodic schedule size can be smaller than default */
+		switch (EHCI_TUNE_FLS) {
+		case 0: ehci-&gt;periodic_size = 1024; break;
+		case 1: ehci-&gt;periodic_size = 512; break;
+		case 2: ehci-&gt;periodic_size = 256; break;
+		default:	BUG();
+		}
+	}
 	if ((retval = ehci_mem_init(ehci, GFP_KERNEL)) &lt; 0)
 		return retval;
 
 	/* controllers may cache some of the periodic schedule ... */
-	hcc_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcc_params);
 	if (HCC_ISOC_CACHE(hcc_params))		// full frame cache
 		ehci-&gt;i_thresh = 2 + 8;
 	else					// N microframes cached
@@ -637,12 +648,6 @@ static int ehci_init(struct usb_hcd *hcd)
 		/* periodic schedule size can be smaller than default */
 		temp &amp;= ~(3 &lt;&lt; 2);
 		temp |= (EHCI_TUNE_FLS &lt;&lt; 2);
-		switch (EHCI_TUNE_FLS) {
-		case 0: ehci-&gt;periodic_size = 1024; break;
-		case 1: ehci-&gt;periodic_size = 512; break;
-		case 2: ehci-&gt;periodic_size = 256; break;
-		default:	BUG();
-		}
 	}
 	if (HCC_LPM(hcc_params)) {
 		/* support link power management EHCI 1.1 addendum */</pre><hr><pre>commit 12f68c480c7155a66bd2a76ab2fef28dd5f93fa2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 3 16:47:49 2011 -0500

    USB: usb-storage: unusual_devs entry for CamSport Evo
    
    This patch (as1438) adds an unusual_devs entry for the MagicPixel
    FW_Omega2 chip, used in the CamSport Evo camera.  The firmware
    incorrectly reports a vendor-specific bDeviceClass.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: &lt;ttkspam@free.fr&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 2e630e6fadad..24bd5d7c3deb 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1044,6 +1044,15 @@ UNUSUAL_DEV(  0x084d, 0x0011, 0x0110, 0x0110,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_BULK32),
 
+/* Reported by &lt;ttkspam@free.fr&gt;
+ * The device reports a vendor-specific device class, requiring an
+ * explicit vendor/product match.
+ */
+UNUSUAL_DEV(  0x0851, 0x1542, 0x0002, 0x0002,
+		"MagicPixel",
+		"FW_Omega2",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL, 0),
+
 /* Andrew Lunn &lt;andrew@lunn.ch&gt;
  * PanDigital Digital Picture Frame. Does not like ALLOW_MEDIUM_REMOVAL
  * on LUN 4.</pre><hr><pre>commit 41511704b678f7b101a76e58d6c6b7bbe2a9ad70
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 15 16:04:56 2010 -0500

    [SCSI] eliminate an unnecessary local variable from scsi_remove_target()
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 76ee2e784f75..4c68d36f9ac2 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -993,16 +993,14 @@ static int __remove_child (struct device * dev, void * data)
  */
 void scsi_remove_target(struct device *dev)
 {
-	struct device *rdev;
-
 	if (scsi_is_target_device(dev)) {
 		__scsi_remove_target(to_scsi_target(dev));
 		return;
 	}
 
-	rdev = get_device(dev);
+	get_device(dev);
 	device_for_each_child(dev, NULL, __remove_child);
-	put_device(rdev);
+	put_device(dev);
 }
 EXPORT_SYMBOL(scsi_remove_target);
 </pre><hr><pre>commit c7b61de5b7b17f0df34dc7d2f8b9576f8bd36fce
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 1 00:14:42 2010 +0100

    PM / Runtime: Add synchronous runtime interface for interrupt handlers (v3)
    
    This patch (as1431c) makes the synchronous runtime-PM interface
    suitable for use in interrupt handlers.  Subsystems can call the new
    pm_runtime_irq_safe() function to tell the PM core that a device's
    runtime_suspend and runtime_resume callbacks should be invoked with
    interrupts disabled and the spinlock held.  This permits the
    pm_runtime_get_sync() and the new pm_runtime_put_sync_suspend()
    routines to be called from within interrupt handlers.
    
    When a device is declared irq-safe in this way, the PM core increments
    the parent's usage count, so the parent will never be runtime
    suspended.  This prevents difficult situations in which an irq-safe
    device can't resume because it is forced to wait for its non-irq-safe
    parent.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/power/runtime_pm.txt b/Documentation/power/runtime_pm.txt
index 41cc7b30d7dd..ffe55ffa540a 100644
--- a/Documentation/power/runtime_pm.txt
+++ b/Documentation/power/runtime_pm.txt
@@ -50,6 +50,15 @@ type's callbacks are not defined) of given device.  The bus type, device type
 and device class callbacks are referred to as subsystem-level callbacks in what
 follows.
 
+By default, the callbacks are always invoked in process context with interrupts
+enabled.  However, subsystems can use the pm_runtime_irq_safe() helper function
+to tell the PM core that a device's -&gt;runtime_suspend() and -&gt;runtime_resume()
+callbacks should be invoked in atomic context with interrupts disabled
+(-&gt;runtime_idle() is still invoked the default way).  This implies that these
+callback routines must not block or sleep, but it also means that the
+synchronous helper functions listed at the end of Section 4 can be used within
+an interrupt handler or in an atomic context.
+
 The subsystem-level suspend callback is _entirely_ _responsible_ for handling
 the suspend of the device as appropriate, which may, but need not include
 executing the device driver's own -&gt;runtime_suspend() callback (from the
@@ -237,6 +246,10 @@ defined in include/linux/pm.h:
       Section 8); it may be modified only by the pm_runtime_no_callbacks()
       helper function
 
+  unsigned int irq_safe;
+    - indicates that the -&gt;runtime_suspend() and -&gt;runtime_resume() callbacks
+      will be invoked with the spinlock held and interrupts disabled
+
   unsigned int use_autosuspend;
     - indicates that the device's driver supports delayed autosuspend (see
       Section 9); it may be modified only by the
@@ -344,6 +357,10 @@ drivers/base/power/runtime.c and include/linux/pm_runtime.h:
     - decrement the device's usage counter; if the result is 0 then run
       pm_runtime_idle(dev) and return its result
 
+  int pm_runtime_put_sync_suspend(struct device *dev);
+    - decrement the device's usage counter; if the result is 0 then run
+      pm_runtime_suspend(dev) and return its result
+
   int pm_runtime_put_sync_autosuspend(struct device *dev);
     - decrement the device's usage counter; if the result is 0 then run
       pm_runtime_autosuspend(dev) and return its result
@@ -397,6 +414,11 @@ drivers/base/power/runtime.c and include/linux/pm_runtime.h:
       PM attributes from /sys/devices/.../power (or prevent them from being
       added when the device is registered)
 
+  void pm_runtime_irq_safe(struct device *dev);
+    - set the power.irq_safe flag for the device, causing the runtime-PM
+      suspend and resume callbacks (but not the idle callback) to be invoked
+      with interrupts disabled
+
   void pm_runtime_mark_last_busy(struct device *dev);
     - set the power.last_busy field to the current time
 
@@ -438,6 +460,15 @@ pm_runtime_suspended()
 pm_runtime_mark_last_busy()
 pm_runtime_autosuspend_expiration()
 
+If pm_runtime_irq_safe() has been called for a device then the following helper
+functions may also be used in interrupt context:
+
+pm_runtime_suspend()
+pm_runtime_autosuspend()
+pm_runtime_resume()
+pm_runtime_get_sync()
+pm_runtime_put_sync_suspend()
+
 5. Run-time PM Initialization, Device Probing and Removal
 
 Initially, the run-time PM is disabled for all devices, which means that the
diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 02c652be83e7..656493a5e073 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -250,13 +250,16 @@ static int rpm_callback(int (*cb)(struct device *), struct device *dev)
 	if (!cb)
 		return -ENOSYS;
 
-	spin_unlock_irq(&amp;dev-&gt;power.lock);
+	if (dev-&gt;power.irq_safe) {
+		retval = cb(dev);
+	} else {
+		spin_unlock_irq(&amp;dev-&gt;power.lock);
 
-	retval = cb(dev);
+		retval = cb(dev);
 
-	spin_lock_irq(&amp;dev-&gt;power.lock);
+		spin_lock_irq(&amp;dev-&gt;power.lock);
+	}
 	dev-&gt;power.runtime_error = retval;
-
 	return retval;
 }
 
@@ -404,7 +407,7 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 		goto out;
 	}
 
-	if (parent &amp;&amp; !parent-&gt;power.ignore_children) {
+	if (parent &amp;&amp; !parent-&gt;power.ignore_children &amp;&amp; !dev-&gt;power.irq_safe) {
 		spin_unlock_irq(&amp;dev-&gt;power.lock);
 
 		pm_request_idle(parent);
@@ -527,10 +530,13 @@ static int rpm_resume(struct device *dev, int rpmflags)
 
 	if (!parent &amp;&amp; dev-&gt;parent) {
 		/*
-		 * Increment the parent's resume counter and resume it if
-		 * necessary.
+		 * Increment the parent's usage counter and resume it if
+		 * necessary.  Not needed if dev is irq-safe; then the
+		 * parent is permanently resumed.
 		 */
 		parent = dev-&gt;parent;
+		if (dev-&gt;power.irq_safe)
+			goto skip_parent;
 		spin_unlock(&amp;dev-&gt;power.lock);
 
 		pm_runtime_get_noresume(parent);
@@ -553,6 +559,7 @@ static int rpm_resume(struct device *dev, int rpmflags)
 			goto out;
 		goto repeat;
 	}
+ skip_parent:
 
 	if (dev-&gt;power.no_callbacks)
 		goto no_callback;	/* Assume success. */
@@ -584,7 +591,7 @@ static int rpm_resume(struct device *dev, int rpmflags)
 		rpm_idle(dev, RPM_ASYNC);
 
  out:
-	if (parent) {
+	if (parent &amp;&amp; !dev-&gt;power.irq_safe) {
 		spin_unlock_irq(&amp;dev-&gt;power.lock);
 
 		pm_runtime_put(parent);
@@ -1065,7 +1072,6 @@ EXPORT_SYMBOL_GPL(pm_runtime_allow);
  * Set the power.no_callbacks flag, which tells the PM core that this
  * device is power-managed through its parent and has no run-time PM
  * callbacks of its own.  The run-time sysfs attributes will be removed.
- *
  */
 void pm_runtime_no_callbacks(struct device *dev)
 {
@@ -1077,6 +1083,27 @@ void pm_runtime_no_callbacks(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(pm_runtime_no_callbacks);
 
+/**
+ * pm_runtime_irq_safe - Leave interrupts disabled during callbacks.
+ * @dev: Device to handle
+ *
+ * Set the power.irq_safe flag, which tells the PM core that the
+ * -&gt;runtime_suspend() and -&gt;runtime_resume() callbacks for this device should
+ * always be invoked with the spinlock held and interrupts disabled.  It also
+ * causes the parent's usage counter to be permanently incremented, preventing
+ * the parent from runtime suspending -- otherwise an irq-safe child might have
+ * to wait for a non-irq-safe parent.
+ */
+void pm_runtime_irq_safe(struct device *dev)
+{
+	if (dev-&gt;parent)
+		pm_runtime_get_sync(dev-&gt;parent);
+	spin_lock_irq(&amp;dev-&gt;power.lock);
+	dev-&gt;power.irq_safe = 1;
+	spin_unlock_irq(&amp;dev-&gt;power.lock);
+}
+EXPORT_SYMBOL_GPL(pm_runtime_irq_safe);
+
 /**
  * update_autosuspend - Handle a change to a device's autosuspend settings.
  * @dev: Device to handle.
@@ -1199,4 +1226,6 @@ void pm_runtime_remove(struct device *dev)
 	/* Change the status back to 'suspended' to match the initial status. */
 	if (dev-&gt;power.runtime_status == RPM_ACTIVE)
 		pm_runtime_set_suspended(dev);
+	if (dev-&gt;power.irq_safe &amp;&amp; dev-&gt;parent)
+		pm_runtime_put_sync(dev-&gt;parent);
 }
diff --git a/include/linux/pm.h b/include/linux/pm.h
index 40f3f45702ba..61f2066e6852 100644
--- a/include/linux/pm.h
+++ b/include/linux/pm.h
@@ -486,6 +486,7 @@ struct dev_pm_info {
 	unsigned int		run_wake:1;
 	unsigned int		runtime_auto:1;
 	unsigned int		no_callbacks:1;
+	unsigned int		irq_safe:1;
 	unsigned int		use_autosuspend:1;
 	unsigned int		timer_autosuspends:1;
 	enum rpm_request	request;
diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index d19f1cca7f74..e9cc049ccb62 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -40,6 +40,7 @@ extern int pm_generic_runtime_idle(struct device *dev);
 extern int pm_generic_runtime_suspend(struct device *dev);
 extern int pm_generic_runtime_resume(struct device *dev);
 extern void pm_runtime_no_callbacks(struct device *dev);
+extern void pm_runtime_irq_safe(struct device *dev);
 extern void __pm_runtime_use_autosuspend(struct device *dev, bool use);
 extern void pm_runtime_set_autosuspend_delay(struct device *dev, int delay);
 extern unsigned long pm_runtime_autosuspend_expiration(struct device *dev);
@@ -124,6 +125,7 @@ static inline int pm_generic_runtime_idle(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_suspend(struct device *dev) { return 0; }
 static inline int pm_generic_runtime_resume(struct device *dev) { return 0; }
 static inline void pm_runtime_no_callbacks(struct device *dev) {}
+static inline void pm_runtime_irq_safe(struct device *dev) {}
 
 static inline void pm_runtime_mark_last_busy(struct device *dev) {}
 static inline void __pm_runtime_use_autosuspend(struct device *dev,
@@ -196,6 +198,11 @@ static inline int pm_runtime_put_sync(struct device *dev)
 	return __pm_runtime_idle(dev, RPM_GET_PUT);
 }
 
+static inline int pm_runtime_put_sync_suspend(struct device *dev)
+{
+	return __pm_runtime_suspend(dev, RPM_GET_PUT);
+}
+
 static inline int pm_runtime_put_sync_autosuspend(struct device *dev)
 {
 	return __pm_runtime_suspend(dev, RPM_GET_PUT | RPM_AUTO);</pre><hr><pre>commit 3ff5588d3f8afad65ded52ac0e4191462fe034cb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 7 11:44:01 2010 -0400

    [SCSI] sd: improve logic and efficiecy of media-change detection
    
    This patch (as1415) improves the formerly incomprehensible logic in
    sd_media_changed() (the current code refers to "changed" as a state,
    whereas in fact it is a relation between two states).  It also adds a
    big comment so that everyone can understand what is really going on.
    
    The patch also improves efficiency by not reporting a media change
    when no medium was ever present.  If no medium was present the last
    time we checked and there's still no medium, it's not necessary to
    tell the caller that a change occurred.  Doing so merely causes the
    caller to attempt to revalidate a non-existent disk, which is a waste
    of time.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 956496182c80..26f9d54a9c92 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -583,7 +583,7 @@ static int sd_prep_fn(struct request_queue *q, struct request *rq)
 		 * quietly refuse to do anything to a changed disc until 
 		 * the changed bit has been reset
 		 */
-		/* printk("SCSI disk has been changed. Prohibiting further I/O.\n"); */
+		/* printk("SCSI disk has been changed or is not present. Prohibiting further I/O.\n"); */
 		goto out;
 	}
 
@@ -1023,7 +1023,6 @@ static int sd_media_changed(struct gendisk *disk)
 	 */
 	if (!scsi_device_online(sdp)) {
 		set_media_not_present(sdkp);
-		retval = 1;
 		goto out;
 	}
 
@@ -1054,7 +1053,6 @@ static int sd_media_changed(struct gendisk *disk)
 		       /* 0x3a is medium not present */
 		       sshdr-&gt;asc == 0x3a)) {
 		set_media_not_present(sdkp);
-		retval = 1;
 		goto out;
 	}
 
@@ -1065,12 +1063,27 @@ static int sd_media_changed(struct gendisk *disk)
 	 */
 	sdkp-&gt;media_present = 1;
 
-	retval = sdp-&gt;changed;
-	sdp-&gt;changed = 0;
 out:
-	if (retval != sdkp-&gt;previous_state)
+	/*
+	 * Report a media change under the following conditions:
+	 *
+	 *	Medium is present now and wasn't present before.
+	 *	Medium wasn't present before and is present now.
+	 *	Medium was present at all times, but it changed while
+	 *		we weren't looking (sdp-&gt;changed is set).
+	 *
+	 * If there was no medium before and there is no medium now then
+	 * don't report a change, even if a medium was inserted and removed
+	 * while we weren't looking.
+	 */
+	retval = (sdkp-&gt;media_present != sdkp-&gt;previous_state ||
+			(sdkp-&gt;media_present &amp;&amp; sdp-&gt;changed));
+	if (retval)
 		sdev_evt_send_simple(sdp, SDEV_EVT_MEDIA_CHANGE, GFP_KERNEL);
-	sdkp-&gt;previous_state = retval;
+	sdkp-&gt;previous_state = sdkp-&gt;media_present;
+
+	/* sdp-&gt;changed indicates medium was changed or is not present */
+	sdp-&gt;changed = !sdkp-&gt;media_present;
 	kfree(sshdr);
 	return retval;
 }</pre><hr><pre>commit abf03184a31a3286fc0ab30f838ddee8ba9f9b7b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 29 10:17:22 2010 -0500

    USB: fix autosuspend bug in usb-serial
    
    This patch (as1437) fixes a bug in the usb-serial autosuspend
    handling.  Since the usb-serial core now has autosuspend support, it
    must set the .supports_autosuspend member in every serial driver it
    registers.  Otherwise the usb_autopm_get_interface() call won't work.
    
    This fixes Bugzilla #23012.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: stable@kernel.org
    Reported-by: Kevin Smith &lt;thirdwiggin@gmail.com&gt;
    Reported-and-tested-by: Simon Gerber &lt;gesimu@gmail.com&gt;
    Reported-and-tested-by: Matteo Croce &lt;matteo@openwrt.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 861223f2af6e..6954de50c0ff 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -51,6 +51,7 @@ static struct usb_driver usb_serial_driver = {
 	.suspend =	usb_serial_suspend,
 	.resume =	usb_serial_resume,
 	.no_dynamic_id = 	1,
+	.supports_autosuspend =	1,
 };
 
 /* There is no MODULE_DEVICE_TABLE for usbserial.c.  Instead
@@ -1343,6 +1344,8 @@ int usb_serial_register(struct usb_serial_driver *driver)
 		return -ENODEV;
 
 	fixup_generic(driver);
+	if (driver-&gt;usb_driver)
+		driver-&gt;usb_driver-&gt;supports_autosuspend = 1;
 
 	if (!driver-&gt;description)
 		driver-&gt;description = driver-&gt;driver.name;</pre><hr><pre>commit e030d58e8860f1c87b17631dbdd70747cbe1fb5b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 15 15:46:07 2010 -0500

    sysfs: remove useless test from sysfs_merge_group
    
    Dan Carpenter pointed out that the new sysfs_merge_group() and
    sysfs_unmerge_group() routines requires their grp argument to be
    non-NULL, because they dereference grp to obtain the list of
    attributes.  Hence it's pointless for the routines to include a test
    and special-case handling for when grp is NULL.  This patch (as1433)
    removes the unneeded tests.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Dan Carpenter &lt;error27@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/fs/sysfs/group.c b/fs/sysfs/group.c
index 442f34ff1af8..c8769dc222d8 100644
--- a/fs/sysfs/group.c
+++ b/fs/sysfs/group.c
@@ -165,10 +165,7 @@ int sysfs_merge_group(struct kobject *kobj,
 	struct attribute *const *attr;
 	int i;
 
-	if (grp)
-		dir_sd = sysfs_get_dirent(kobj-&gt;sd, NULL, grp-&gt;name);
-	else
-		dir_sd = sysfs_get(kobj-&gt;sd);
+	dir_sd = sysfs_get_dirent(kobj-&gt;sd, NULL, grp-&gt;name);
 	if (!dir_sd)
 		return -ENOENT;
 
@@ -195,10 +192,7 @@ void sysfs_unmerge_group(struct kobject *kobj,
 	struct sysfs_dirent *dir_sd;
 	struct attribute *const *attr;
 
-	if (grp)
-		dir_sd = sysfs_get_dirent(kobj-&gt;sd, NULL, grp-&gt;name);
-	else
-		dir_sd = sysfs_get(kobj-&gt;sd);
+	dir_sd = sysfs_get_dirent(kobj-&gt;sd, NULL, grp-&gt;name);
 	if (dir_sd) {
 		for (attr = grp-&gt;attrs; *attr; ++attr)
 			sysfs_hash_and_remove(dir_sd, NULL, (*attr)-&gt;name);</pre><hr><pre>commit 73d8c34f3d78ccf90a431c221df10377affce650
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 15 16:03:04 2010 -0500

    SCSI: improve two error messages
    
    This trivial patch (as1338) makes two uninformative error messages in
    scsi_sysfs_add_sdev() more explicit.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 20ad59dff730..9c52ce4f7129 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -864,13 +864,15 @@ int scsi_sysfs_add_sdev(struct scsi_device *sdev)
 
 	error = device_add(&amp;sdev-&gt;sdev_gendev);
 	if (error) {
-		printk(KERN_INFO "error 1\n");
+		sdev_printk(KERN_INFO, sdev,
+				"failed to add device: %d\n", error);
 		return error;
 	}
 	device_enable_async_suspend(&amp;sdev-&gt;sdev_dev);
 	error = device_add(&amp;sdev-&gt;sdev_dev);
 	if (error) {
-		printk(KERN_INFO "error 2\n");
+		sdev_printk(KERN_INFO, sdev,
+				"failed to add class device: %d\n", error);
 		device_del(&amp;sdev-&gt;sdev_gendev);
 		return error;
 	}</pre><hr><pre>commit 2f15744c1d90ee2e82f8ae5724b44b1cdf31715c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 17 10:56:01 2010 -0500

    USB: fix leftover references to udev-&gt;autosuspend_delay
    
    This patch (as1436) takes care of leftover references to
    udev-&gt;autosuspend_delay that didn't get removed during the earlier
    conversion to the runtime-PM autosuspend API.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/media/video/tlg2300/pd-main.c b/drivers/media/video/tlg2300/pd-main.c
index 4555f4a5f4c8..e33b428a8015 100644
--- a/drivers/media/video/tlg2300/pd-main.c
+++ b/drivers/media/video/tlg2300/pd-main.c
@@ -453,7 +453,8 @@ static int poseidon_probe(struct usb_interface *interface,
 
 	device_init_wakeup(&amp;udev-&gt;dev, 1);
 #ifdef CONFIG_PM
-	pd-&gt;udev-&gt;autosuspend_delay = HZ * PM_SUSPEND_DELAY;
+	pm_runtime_set_autosuspend_delay(&amp;pd-&gt;udev-&gt;dev,
+			1000 * PM_SUSPEND_DELAY);
 	usb_enable_autosuspend(pd-&gt;udev);
 
 	if (in_hibernation(pd)) {
diff --git a/drivers/net/wimax/i2400m/usb.c b/drivers/net/wimax/i2400m/usb.c
index d3365ac85dde..7cb375515e1e 100644
--- a/drivers/net/wimax/i2400m/usb.c
+++ b/drivers/net/wimax/i2400m/usb.c
@@ -514,7 +514,7 @@ int i2400mu_probe(struct usb_interface *iface,
 #ifdef CONFIG_PM
 	iface-&gt;needs_remote_wakeup = 1;		/* autosuspend (15s delay) */
 	device_init_wakeup(dev, 1);
-	usb_dev-&gt;autosuspend_delay = 15 * HZ;
+	pm_runtime_set_autosuspend_delay(&amp;usb_dev-&gt;dev, 15000);
 	usb_enable_autosuspend(usb_dev);
 #endif
 
diff --git a/drivers/staging/bcm/InterfaceInit.c b/drivers/staging/bcm/InterfaceInit.c
index 824f9a45007a..e97ad99b1bb4 100644
--- a/drivers/staging/bcm/InterfaceInit.c
+++ b/drivers/staging/bcm/InterfaceInit.c
@@ -277,7 +277,7 @@ usbbcm_device_probe(struct usb_interface *intf, const struct usb_device_id *id)
 		if(psAdapter-&gt;bDoSuspend)
 		{
 #ifdef CONFIG_PM
-			udev-&gt;autosuspend_delay = 0;
+			pm_runtime_set_autosuspend_delay(&amp;udev-&gt;dev, 0);
 			intf-&gt;needs_remote_wakeup = 1;
 #if LINUX_VERSION_CODE &lt; KERNEL_VERSION(2, 6, 35)
  			udev-&gt;autosuspend_disabled = 0;</pre>
    <div class="pagination">
        <a href='2_59.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><span>[60]</span><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_61.html'>Next&gt;&gt;</a>
    <div>
</body>
