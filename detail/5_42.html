<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_41.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><span>[42]</span><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_43.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 142e301fc818de9b116706835cd9fc864e73f203
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 1 21:06:58 2006 -0600

    [SCSI] iscsi update: setup pool before using
    
    &gt;From andmike@us.ibm.com:
    
     Ensure that pool data is setup prior to calling mempool_create as it will
     call the the alloc function during create.
    
    Signed-off-by: Mike Anderson &lt;andmike@us.ibm.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Alex Aizman &lt;itn780@yahoo.com&gt;
    Signed-off-by: Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 79ca29ee1aee..448fd78777f9 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -530,6 +530,12 @@ mempool_zone_init(unsigned max, unsigned size, unsigned hiwat)
 	if (!zp)
 		return NULL;
 
+	zp-&gt;size = size;
+	zp-&gt;hiwat = hiwat;
+	INIT_LIST_HEAD(&amp;zp-&gt;freequeue);
+	spin_lock_init(&amp;zp-&gt;freelock);
+	atomic_set(&amp;zp-&gt;allocated, 0);
+
 	zp-&gt;pool = mempool_create(max, mempool_zone_alloc_skb,
 				  mempool_zone_free_skb, zp);
 	if (!zp-&gt;pool) {
@@ -537,13 +543,6 @@ mempool_zone_init(unsigned max, unsigned size, unsigned hiwat)
 		return NULL;
 	}
 
-	zp-&gt;size = size;
-	zp-&gt;hiwat = hiwat;
-
-	INIT_LIST_HEAD(&amp;zp-&gt;freequeue);
-	spin_lock_init(&amp;zp-&gt;freelock);
-	atomic_set(&amp;zp-&gt;allocated, 0);
-
 	return zp;
 }
 </pre><hr><pre>commit 5b940adf5b341b12dbb94e7cbdb416b35f52017b
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 1 21:06:56 2006 -0600

    [SCSI] iscsi update: pass correct skb to skb_trim
    
    &gt;From da-x@monatomic.org:
    
    Wrong skb is passed to skb_trim in iscsi_if_get_stats.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Alex Aizman &lt;itn780@yahoo.com&gt;
    Signed-off-by: Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index b61868587dca..79ca29ee1aee 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -680,8 +680,7 @@ iscsi_if_send_reply(int pid, int seq, int type, int done, int multi,
 }
 
 static int
-iscsi_if_get_stats(struct iscsi_transport *transport, struct sk_buff *skb,
-		   struct nlmsghdr *nlh)
+iscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
 {
 	struct iscsi_uevent *ev = NLMSG_DATA(nlh);
 	struct iscsi_stats *stats;
@@ -732,7 +731,7 @@ iscsi_if_get_stats(struct iscsi_transport *transport, struct sk_buff *skb,
 					  stats-&gt;custom_length);
 		actual_size -= sizeof(*nlhstat);
 		actual_size = NLMSG_LENGTH(actual_size);
-		skb_trim(skb, NLMSG_ALIGN(actual_size));
+		skb_trim(skbstat, NLMSG_ALIGN(actual_size));
 		nlhstat-&gt;nlmsg_len = actual_size;
 
 		err = iscsi_unicast_skb(conn-&gt;z_pdu, skbstat);
@@ -923,7 +922,7 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_GET_STATS:
-		err = iscsi_if_get_stats(transport, skb, nlh);
+		err = iscsi_if_get_stats(transport, nlh);
 		break;
 	default:
 		err = -EINVAL;</pre><hr><pre>commit 7b7232f3fb5ecd7c30cb52df368070cc5f5ca614
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 1 21:06:49 2006 -0600

    [SCSI] iscsi update: cleanup iscsi class interface
    
    From:
    michaelc@cs.wisc.edu
    fujita.tomonori@lab.ntt.co.jp
    da-x@monatomic.org
    
    and err path fixup from:
    ogerlitz@voltaire.com
    
    This patch cleans up that interface by having the lld and class
    pass a iscsi_cls_session or iscsi_cls_conn between each other when
    the function is used by HW and SW iscsi llds. This way the lld
    does not have to remember if it has to send a handle or pointer
    and a handle or pointer to connection, session or host.
    
    This also has the class verify the session handle that gets passed from
    userspace instead of using the pointer passed into the kernel directly.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: Alex Aizman &lt;itn780@yahoo.com&gt;
    Signed-off-by: Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 780bfcc67096..d07d309ac026 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -146,7 +146,7 @@ iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	set_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
-	iscsi_conn_error(iscsi_handle(conn), err);
+	iscsi_conn_error(conn-&gt;cls_conn, err);
 }
 
 static inline int
@@ -689,7 +689,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 				break;
 
 			if (!conn-&gt;in.datalen) {
-				rc = iscsi_recv_pdu(iscsi_handle(conn), hdr,
+				rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr,
 						    NULL, 0);
 				if (conn-&gt;login_mtask != mtask) {
 					spin_lock(&amp;session-&gt;lock);
@@ -737,7 +737,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 			if (!conn-&gt;in.datalen) {
 				struct iscsi_mgmt_task *mtask;
 
-				rc = iscsi_recv_pdu(iscsi_handle(conn), hdr,
+				rc = iscsi_recv_pdu(conn-&gt;cls_conn, hdr,
 						    NULL, 0);
 				mtask = (struct iscsi_mgmt_task *)
 					session-&gt;mgmt_cmds[conn-&gt;in.itt -
@@ -761,7 +761,7 @@ iscsi_hdr_recv(struct iscsi_conn *conn)
 				rc = iscsi_check_assign_cmdsn(session,
 						 (struct iscsi_nopin*)hdr);
 				if (!rc &amp;&amp; hdr-&gt;ttt != ISCSI_RESERVED_TAG)
-					rc = iscsi_recv_pdu(iscsi_handle(conn),
+					rc = iscsi_recv_pdu(conn-&gt;cls_conn,
 							    hdr, NULL, 0);
 			} else
 				rc = ISCSI_ERR_PROTO;
@@ -1044,7 +1044,7 @@ iscsi_data_recv(struct iscsi_conn *conn)
 			goto exit;
 		}
 
-		rc = iscsi_recv_pdu(iscsi_handle(conn), conn-&gt;in.hdr,
+		rc = iscsi_recv_pdu(conn-&gt;cls_conn, conn-&gt;in.hdr,
 				    conn-&gt;data, conn-&gt;in.datalen);
 
 		if (!rc &amp;&amp; conn-&gt;datadgst_en &amp;&amp;
@@ -2428,19 +2428,20 @@ iscsi_pool_free(struct iscsi_queue *q, void **items)
 }
 
 static struct iscsi_cls_conn *
-iscsi_conn_create(struct Scsi_Host *shost, uint32_t conn_idx)
+iscsi_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 {
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
 	struct iscsi_conn *conn;
 	struct iscsi_cls_conn *cls_conn;
 
-	cls_conn = iscsi_create_conn(hostdata_session(shost-&gt;hostdata),
-				     conn_idx);
+	cls_conn = iscsi_create_conn(cls_session, conn_idx);
 	if (!cls_conn)
 		return NULL;
 	conn = cls_conn-&gt;dd_data;
+	memset(conn, 0, sizeof(*conn));
 
-	memset(conn, 0, sizeof(struct iscsi_conn));
+	conn-&gt;cls_conn = cls_conn;
 	conn-&gt;c_stage = ISCSI_CONN_INITIAL_STAGE;
 	conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
 	conn-&gt;id = conn_idx;
@@ -2625,11 +2626,13 @@ iscsi_conn_destroy(struct iscsi_cls_conn *cls_conn)
 }
 
 static int
-iscsi_conn_bind(iscsi_sessionh_t sessionh, iscsi_connh_t connh,
-		uint32_t transport_fd, int is_leading)
+iscsi_conn_bind(struct iscsi_cls_session *cls_session,
+		struct iscsi_cls_conn *cls_conn, uint32_t transport_fd,
+		int is_leading)
 {
-	struct iscsi_session *session = iscsi_ptr(sessionh);
-	struct iscsi_conn *tmp = ERR_PTR(-EEXIST), *conn = iscsi_ptr(connh);
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	struct iscsi_conn *tmp = ERR_PTR(-EEXIST), *conn = cls_conn-&gt;dd_data;
 	struct sock *sk;
 	struct socket *sock;
 	int err;
@@ -2703,9 +2706,9 @@ iscsi_conn_bind(iscsi_sessionh_t sessionh, iscsi_connh_t connh,
 }
 
 static int
-iscsi_conn_start(iscsi_connh_t connh)
+iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 {
-	struct iscsi_conn *conn = iscsi_ptr(connh);
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
 	struct sock *sk;
 
@@ -2754,9 +2757,9 @@ iscsi_conn_start(iscsi_connh_t connh)
 }
 
 static void
-iscsi_conn_stop(iscsi_connh_t connh, int flag)
+iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 {
-	struct iscsi_conn *conn = iscsi_ptr(connh);
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
 	struct sock *sk;
 	unsigned long flags;
@@ -3253,9 +3256,9 @@ static struct scsi_host_template iscsi_sht = {
 
 static struct iscsi_transport iscsi_tcp_transport;
 
-static struct Scsi_Host *
+static struct iscsi_cls_session *
 iscsi_session_create(struct scsi_transport_template *scsit,
-		     uint32_t initial_cmdsn)
+		     uint32_t initial_cmdsn, uint32_t *sid)
 {
 	struct Scsi_Host *shost;
 	struct iscsi_session *session;
@@ -3275,6 +3278,7 @@ iscsi_session_create(struct scsi_transport_template *scsit,
 	session-&gt;exp_cmdsn = initial_cmdsn + 1;
 	session-&gt;max_cmdsn = initial_cmdsn + 1;
 	session-&gt;max_r2t = 1;
+	*sid = shost-&gt;host_no;
 
 	/* initialize SCSI PDU commands pool */
 	if (iscsi_pool_init(&amp;session-&gt;cmdpool, session-&gt;cmds_max,
@@ -3311,7 +3315,7 @@ iscsi_session_create(struct scsi_transport_template *scsit,
 	if (iscsi_r2tpool_alloc(session))
 		goto r2tpool_alloc_fail;
 
-	return shost;
+	return hostdata_session(shost-&gt;hostdata);
 
 r2tpool_alloc_fail:
 	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
@@ -3321,12 +3325,14 @@ iscsi_session_create(struct scsi_transport_template *scsit,
 mgmtpool_alloc_fail:
 	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
 cmdpool_alloc_fail:
+	iscsi_transport_destroy_session(shost);
 	return NULL;
 }
 
 static void
-iscsi_session_destroy(struct Scsi_Host *shost)
+iscsi_session_destroy(struct iscsi_cls_session *cls_session)
 {
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
 	int cmd_i;
 	struct iscsi_data_task *dtask, *n;
@@ -3350,10 +3356,10 @@ iscsi_session_destroy(struct Scsi_Host *shost)
 }
 
 static int
-iscsi_conn_set_param(iscsi_connh_t connh, enum iscsi_param param,
+iscsi_conn_set_param(struct iscsi_cls_conn *cls_conn, enum iscsi_param param,
 		     uint32_t value)
 {
-	struct iscsi_conn *conn = iscsi_ptr(connh);
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
 
 	spin_lock_bh(&amp;session-&gt;lock);
@@ -3495,9 +3501,10 @@ iscsi_conn_set_param(iscsi_connh_t connh, enum iscsi_param param,
 }
 
 static int
-iscsi_session_get_param(struct Scsi_Host *shost,
+iscsi_session_get_param(struct iscsi_cls_session *cls_session,
 			enum iscsi_param param, uint32_t *value)
 {
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
 	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
 
 	switch(param) {
@@ -3539,9 +3546,10 @@ iscsi_session_get_param(struct Scsi_Host *shost,
 }
 
 static int
-iscsi_conn_get_param(void *data, enum iscsi_param param, uint32_t *value)
+iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
+		     enum iscsi_param param, uint32_t *value)
 {
-	struct iscsi_conn *conn = data;
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 
 	switch(param) {
 	case ISCSI_PARAM_MAX_RECV_DLENGTH:
@@ -3564,9 +3572,9 @@ iscsi_conn_get_param(void *data, enum iscsi_param param, uint32_t *value)
 }
 
 static void
-iscsi_conn_get_stats(iscsi_connh_t connh, struct iscsi_stats *stats)
+iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
 {
-	struct iscsi_conn *conn = iscsi_ptr(connh);
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 
 	stats-&gt;txdata_octets = conn-&gt;txdata_octets;
 	stats-&gt;rxdata_octets = conn-&gt;rxdata_octets;
@@ -3587,10 +3595,10 @@ iscsi_conn_get_stats(iscsi_connh_t connh, struct iscsi_stats *stats)
 }
 
 static int
-iscsi_conn_send_pdu(iscsi_connh_t connh, struct iscsi_hdr *hdr, char *data,
-		    uint32_t data_size)
+iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,
+		    char *data, uint32_t data_size)
 {
-	struct iscsi_conn *conn = iscsi_ptr(connh);
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	int rc;
 
 	mutex_lock(&amp;conn-&gt;xmitmutex);
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index f95e61b76f70..6766b817db2d 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -113,7 +113,10 @@ struct iscsi_tcp_recv {
 	int			datadgst;
 };
 
+struct iscsi_cls_conn;
+
 struct iscsi_conn {
+	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
 	struct iscsi_hdr	hdr;		/* header placeholder */
 	char			hdrext[4*sizeof(__u16) +
 				    sizeof(__u32)];
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 59a1c9d9d3bd..b61868587dca 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -164,9 +164,43 @@ static struct mempool_zone *z_reply;
 #define Z_MAX_ERROR	16
 #define Z_HIWAT_ERROR	12
 
+static LIST_HEAD(sesslist);
+static DEFINE_SPINLOCK(sesslock);
 static LIST_HEAD(connlist);
 static DEFINE_SPINLOCK(connlock);
 
+static struct iscsi_cls_session *iscsi_session_lookup(uint64_t handle)
+{
+	unsigned long flags;
+	struct iscsi_cls_session *sess;
+
+	spin_lock_irqsave(&amp;sesslock, flags);
+	list_for_each_entry(sess, &amp;sesslist, sess_list) {
+		if (sess == iscsi_ptr(handle)) {
+			spin_unlock_irqrestore(&amp;sesslock, flags);
+			return sess;
+		}
+	}
+	spin_unlock_irqrestore(&amp;sesslock, flags);
+	return NULL;
+}
+
+static struct iscsi_cls_conn *iscsi_conn_lookup(uint64_t handle)
+{
+	unsigned long flags;
+	struct iscsi_cls_conn *conn;
+
+	spin_lock_irqsave(&amp;connlock, flags);
+	list_for_each_entry(conn, &amp;connlist, conn_list) {
+		if (conn == iscsi_ptr(handle)) {
+			spin_unlock_irqrestore(&amp;connlock, flags);
+			return conn;
+		}
+	}
+	spin_unlock_irqrestore(&amp;connlock, flags);
+	return NULL;
+}
+
 /*
  * The following functions can be used by LLDs that allocate
  * their own scsi_hosts or by software iscsi LLDs
@@ -365,6 +399,7 @@ iscsi_transport_create_session(struct scsi_transport_template *scsit,
 {
 	struct iscsi_cls_session *session;
 	struct Scsi_Host *shost;
+	unsigned long flags;
 
 	shost = scsi_host_alloc(transport-&gt;host_template,
 				hostdata_privsize(transport));
@@ -389,6 +424,9 @@ iscsi_transport_create_session(struct scsi_transport_template *scsit,
 		goto remove_host;
 
 	*(unsigned long*)shost-&gt;hostdata = (unsigned long)session;
+	spin_lock_irqsave(&amp;sesslock, flags);
+	list_add(&amp;session-&gt;sess_list, &amp;sesslist);
+	spin_unlock_irqrestore(&amp;sesslock, flags);
 	return shost;
 
 remove_host:
@@ -410,9 +448,13 @@ EXPORT_SYMBOL_GPL(iscsi_transport_create_session);
 int iscsi_transport_destroy_session(struct Scsi_Host *shost)
 {
 	struct iscsi_cls_session *session;
+	unsigned long flags;
 
 	scsi_remove_host(shost);
 	session = hostdata_session(shost-&gt;hostdata);
+	spin_lock_irqsave(&amp;sesslock, flags);
+	list_del(&amp;session-&gt;sess_list);
+	spin_unlock_irqrestore(&amp;sesslock, flags);
 	iscsi_destroy_session(session);
 	/* ref from host alloc */
 	scsi_host_put(shost);
@@ -424,22 +466,6 @@ EXPORT_SYMBOL_GPL(iscsi_transport_destroy_session);
 /*
  * iscsi interface functions
  */
-static struct iscsi_cls_conn*
-iscsi_if_find_conn(uint64_t key)
-{
-	unsigned long flags;
-	struct iscsi_cls_conn *conn;
-
-	spin_lock_irqsave(&amp;connlock, flags);
-	list_for_each_entry(conn, &amp;connlist, conn_list)
-		if (conn-&gt;connh == key) {
-			spin_unlock_irqrestore(&amp;connlock, flags);
-			return conn;
-		}
-	spin_unlock_irqrestore(&amp;connlock, flags);
-	return NULL;
-}
-
 static struct iscsi_internal *
 iscsi_if_transport_lookup(struct iscsi_transport *tt)
 {
@@ -559,25 +585,21 @@ iscsi_unicast_skb(struct mempool_zone *zone, struct sk_buff *skb)
 	return 0;
 }
 
-int iscsi_recv_pdu(iscsi_connh_t connh, struct iscsi_hdr *hdr,
+int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 		   char *data, uint32_t data_size)
 {
 	struct nlmsghdr	*nlh;
 	struct sk_buff *skb;
 	struct iscsi_uevent *ev;
-	struct iscsi_cls_conn *conn;
 	char *pdu;
 	int len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iscsi_hdr) +
 			      data_size);
 
-	conn = iscsi_if_find_conn(connh);
-	BUG_ON(!conn);
-
 	mempool_zone_complete(conn-&gt;z_pdu);
 
 	skb = mempool_zone_get_skb(conn-&gt;z_pdu);
 	if (!skb) {
-		iscsi_conn_error(connh, ISCSI_ERR_CONN_FAILED);
+		iscsi_conn_error(conn, ISCSI_ERR_CONN_FAILED);
 		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: can not deliver "
 			   "control PDU: OOM\n");
 		return -ENOMEM;
@@ -590,7 +612,7 @@ int iscsi_recv_pdu(iscsi_connh_t connh, struct iscsi_hdr *hdr,
 	ev-&gt;type = ISCSI_KEVENT_RECV_PDU;
 	if (atomic_read(&amp;conn-&gt;z_pdu-&gt;allocated) &gt;= conn-&gt;z_pdu-&gt;hiwat)
 		ev-&gt;iferror = -ENOMEM;
-	ev-&gt;r.recv_req.conn_handle = connh;
+	ev-&gt;r.recv_req.conn_handle = iscsi_handle(conn);
 	pdu = (char*)ev + sizeof(*ev);
 	memcpy(pdu, hdr, sizeof(struct iscsi_hdr));
 	memcpy(pdu + sizeof(struct iscsi_hdr), data, data_size);
@@ -599,17 +621,13 @@ int iscsi_recv_pdu(iscsi_connh_t connh, struct iscsi_hdr *hdr,
 }
 EXPORT_SYMBOL_GPL(iscsi_recv_pdu);
 
-void iscsi_conn_error(iscsi_connh_t connh, enum iscsi_err error)
+void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error)
 {
 	struct nlmsghdr	*nlh;
 	struct sk_buff	*skb;
 	struct iscsi_uevent *ev;
-	struct iscsi_cls_conn *conn;
 	int len = NLMSG_SPACE(sizeof(*ev));
 
-	conn = iscsi_if_find_conn(connh);
-	BUG_ON(!conn);
-
 	mempool_zone_complete(conn-&gt;z_error);
 
 	skb = mempool_zone_get_skb(conn-&gt;z_error);
@@ -626,7 +644,7 @@ void iscsi_conn_error(iscsi_connh_t connh, enum iscsi_err error)
 	if (atomic_read(&amp;conn-&gt;z_error-&gt;allocated) &gt;= conn-&gt;z_error-&gt;hiwat)
 		ev-&gt;iferror = -ENOMEM;
 	ev-&gt;r.connerror.error = error;
-	ev-&gt;r.connerror.conn_handle = connh;
+	ev-&gt;r.connerror.conn_handle = iscsi_handle(conn);
 
 	iscsi_unicast_skb(conn-&gt;z_error, skb);
 
@@ -677,7 +695,7 @@ iscsi_if_get_stats(struct iscsi_transport *transport, struct sk_buff *skb,
 			      ISCSI_STATS_CUSTOM_MAX);
 	int err = 0;
 
-	conn = iscsi_if_find_conn(ev-&gt;u.get_stats.conn_handle);
+	conn = iscsi_conn_lookup(ev-&gt;u.get_stats.conn_handle);
 	if (!conn)
 		return -EEXIST;
 
@@ -707,7 +725,7 @@ iscsi_if_get_stats(struct iscsi_transport *transport, struct sk_buff *skb,
 			((char*)evstat + sizeof(*evstat));
 		memset(stats, 0, sizeof(*stats));
 
-		transport-&gt;get_stats(ev-&gt;u.get_stats.conn_handle, stats);
+		transport-&gt;get_stats(conn, stats);
 		actual_size = NLMSG_SPACE(sizeof(struct iscsi_uevent) +
 					  sizeof(struct iscsi_stats) +
 					  sizeof(struct iscsi_stats_custom) *
@@ -727,58 +745,34 @@ static int
 iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_uevent *ev)
 {
 	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
-	struct Scsi_Host *shost;
-
-	if (!transport-&gt;create_session)
-		return -EINVAL;
+	struct iscsi_cls_session *session;
+	uint32_t sid;
 
-	shost = transport-&gt;create_session(&amp;priv-&gt;t,
-					  ev-&gt;u.c_session.initial_cmdsn);
-	if (!shost)
+	session = transport-&gt;create_session(&amp;priv-&gt;t,
+					    ev-&gt;u.c_session.initial_cmdsn,
+					    &amp;sid);
+	if (!session)
 		return -ENOMEM;
 
-	ev-&gt;r.c_session_ret.session_handle = iscsi_handle(iscsi_hostdata(shost-&gt;hostdata));
-	ev-&gt;r.c_session_ret.sid = shost-&gt;host_no;
+	ev-&gt;r.c_session_ret.session_handle = iscsi_handle(session);
+	ev-&gt;r.c_session_ret.sid = sid;
 	return 0;
 }
 
 static int
-iscsi_if_destroy_session(struct iscsi_internal *priv, struct iscsi_uevent *ev)
+iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 {
-	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
-
-	struct Scsi_Host *shost;
-
-	if (!transport-&gt;destroy_session)
-		return -EINVAL;
-
-	shost = scsi_host_lookup(ev-&gt;u.d_session.sid);
-	if (shost == ERR_PTR(-ENXIO))
-		return -EEXIST;
-
-	if (transport-&gt;destroy_session)
-		transport-&gt;destroy_session(shost);
-        /* ref from host lookup */
-        scsi_host_put(shost);
-	return 0;
-}
-
-static int
-iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev){
-	struct Scsi_Host *shost;
 	struct iscsi_cls_conn *conn;
+	struct iscsi_cls_session *session;
 	unsigned long flags;
 
-	if (!transport-&gt;create_conn)
+	session = iscsi_session_lookup(ev-&gt;u.c_conn.session_handle);
+	if (!session)
 		return -EINVAL;
 
-	shost = scsi_host_lookup(ev-&gt;u.c_conn.sid);
-	if (shost == ERR_PTR(-ENXIO))
-		return -EEXIST;
-
-	conn = transport-&gt;create_conn(shost, ev-&gt;u.c_conn.cid);
+	conn = transport-&gt;create_conn(session, ev-&gt;u.c_conn.cid);
 	if (!conn)
-		goto release_ref;
+		return -ENOMEM;
 
 	conn-&gt;z_pdu = mempool_zone_init(Z_MAX_PDU,
 			NLMSG_SPACE(sizeof(struct iscsi_uevent) +
@@ -800,14 +794,13 @@ iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 		goto free_pdu_pool;
 	}
 
-	ev-&gt;r.handle = conn-&gt;connh = iscsi_handle(conn-&gt;dd_data);
+	ev-&gt;r.handle = iscsi_handle(conn);
 
 	spin_lock_irqsave(&amp;connlock, flags);
 	list_add(&amp;conn-&gt;conn_list, &amp;connlist);
 	conn-&gt;active = 1;
 	spin_unlock_irqrestore(&amp;connlock, flags);
 
-	scsi_host_put(shost);
 	return 0;
 
 free_pdu_pool:
@@ -815,8 +808,6 @@ iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 destroy_conn:
 	if (transport-&gt;destroy_conn)
 		transport-&gt;destroy_conn(conn-&gt;dd_data);
-release_ref:
-	scsi_host_put(shost);
 	return -ENOMEM;
 }
 
@@ -827,13 +818,9 @@ iscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev
 	struct iscsi_cls_conn *conn;
 	struct mempool_zone *z_error, *z_pdu;
 
-	conn = iscsi_if_find_conn(ev-&gt;u.d_conn.conn_handle);
+	conn = iscsi_conn_lookup(ev-&gt;u.d_conn.conn_handle);
 	if (!conn)
-		return -EEXIST;
-
-	if (!transport-&gt;destroy_conn)
 		return -EINVAL;
-
 	spin_lock_irqsave(&amp;connlock, flags);
 	conn-&gt;active = 0;
 	list_del(&amp;conn-&gt;conn_list);
@@ -858,6 +845,8 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	struct iscsi_uevent *ev = NLMSG_DATA(nlh);
 	struct iscsi_transport *transport = NULL;
 	struct iscsi_internal *priv;
+	struct iscsi_cls_session *session;
+	struct iscsi_cls_conn *conn;
 
 	if (NETLINK_CREDS(skb)-&gt;uid)
 		return -EPERM;
@@ -867,6 +856,9 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		return -EINVAL;
 	transport = priv-&gt;iscsi_transport;
 
+	if (!try_module_get(transport-&gt;owner))
+		return -EINVAL;
+
 	daemon_pid = NETLINK_CREDS(skb)-&gt;pid;
 
 	switch (nlh-&gt;nlmsg_type) {
@@ -874,7 +866,11 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		err = iscsi_if_create_session(priv, ev);
 		break;
 	case ISCSI_UEVENT_DESTROY_SESSION:
-		err = iscsi_if_destroy_session(priv, ev);
+		session = iscsi_session_lookup(ev-&gt;u.d_session.session_handle);
+		if (session)
+			transport-&gt;destroy_session(session);
+		else
+			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_CREATE_CONN:
 		err = iscsi_if_create_conn(transport, ev);
@@ -883,41 +879,48 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		err = iscsi_if_destroy_conn(transport, ev);
 		break;
 	case ISCSI_UEVENT_BIND_CONN:
-		if (!iscsi_if_find_conn(ev-&gt;u.b_conn.conn_handle))
-			return -EEXIST;
-		ev-&gt;r.retcode = transport-&gt;bind_conn(
-			ev-&gt;u.b_conn.session_handle,
-			ev-&gt;u.b_conn.conn_handle,
-			ev-&gt;u.b_conn.transport_fd,
-			ev-&gt;u.b_conn.is_leading);
+		session = iscsi_session_lookup(ev-&gt;u.b_conn.session_handle);
+		conn = iscsi_conn_lookup(ev-&gt;u.b_conn.conn_handle);
+
+		if (session &amp;&amp; conn)
+			ev-&gt;r.retcode =	transport-&gt;bind_conn(session, conn,
+					ev-&gt;u.b_conn.transport_fd,
+					ev-&gt;u.b_conn.is_leading);
+		else
+			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_SET_PARAM:
-		if (!iscsi_if_find_conn(ev-&gt;u.set_param.conn_handle))
-			return -EEXIST;
-		ev-&gt;r.retcode = transport-&gt;set_param(
-			ev-&gt;u.set_param.conn_handle,
-			ev-&gt;u.set_param.param, ev-&gt;u.set_param.value);
+		conn = iscsi_conn_lookup(ev-&gt;u.set_param.conn_handle);
+		if (conn)
+			ev-&gt;r.retcode =	transport-&gt;set_param(conn,
+				ev-&gt;u.set_param.param, ev-&gt;u.set_param.value);
+		else
+			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_START_CONN:
-		if (!iscsi_if_find_conn(ev-&gt;u.start_conn.conn_handle))
-			return -EEXIST;
-		ev-&gt;r.retcode = transport-&gt;start_conn(
-			ev-&gt;u.start_conn.conn_handle);
+		conn = iscsi_conn_lookup(ev-&gt;u.start_conn.conn_handle);
+		if (conn)
+			ev-&gt;r.retcode = transport-&gt;start_conn(conn);
+		else
+			err = -EINVAL;
+
 		break;
 	case ISCSI_UEVENT_STOP_CONN:
-		if (!iscsi_if_find_conn(ev-&gt;u.stop_conn.conn_handle))
-			return -EEXIST;
-		transport-&gt;stop_conn(ev-&gt;u.stop_conn.conn_handle,
-			ev-&gt;u.stop_conn.flag);
+		conn = iscsi_conn_lookup(ev-&gt;u.stop_conn.conn_handle);
+		if (conn)
+			transport-&gt;stop_conn(conn, ev-&gt;u.stop_conn.flag);
+		else
+			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_SEND_PDU:
-		if (!iscsi_if_find_conn(ev-&gt;u.send_pdu.conn_handle))
-			return -EEXIST;
-		ev-&gt;r.retcode = transport-&gt;send_pdu(
-		       ev-&gt;u.send_pdu.conn_handle,
-		       (struct iscsi_hdr*)((char*)ev + sizeof(*ev)),
-		       (char*)ev + sizeof(*ev) + ev-&gt;u.send_pdu.hdr_size,
-			ev-&gt;u.send_pdu.data_size);
+		conn = iscsi_conn_lookup(ev-&gt;u.send_pdu.conn_handle);
+		if (conn)
+			ev-&gt;r.retcode =	transport-&gt;send_pdu(conn,
+				(struct iscsi_hdr*)((char*)ev + sizeof(*ev)),
+				(char*)ev + sizeof(*ev) + ev-&gt;u.send_pdu.hdr_size,
+				ev-&gt;u.send_pdu.data_size);
+		else
+			err = -EINVAL;
 		break;
 	case ISCSI_UEVENT_GET_STATS:
 		err = iscsi_if_get_stats(transport, skb, nlh);
@@ -927,6 +930,7 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		break;
 	}
 
+	module_put(transport-&gt;owner);
 	return err;
 }
 
@@ -997,7 +1001,7 @@ show_conn_int_param_##param(struct class_device *cdev, char *buf)	\
 	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
 	struct iscsi_transport *t = conn-&gt;transport;			\
 									\
-	t-&gt;get_conn_param(conn-&gt;dd_data, param, &amp;value);		\
+	t-&gt;get_conn_param(conn, param, &amp;value);				\
 	return snprintf(buf, 20, format"\n", value);			\
 }
 
@@ -1024,10 +1028,9 @@ show_session_int_param_##param(struct class_device *cdev, char *buf)	\
 {									\
 	uint32_t value = 0;						\
 	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev);	\
-	struct Scsi_Host *shost = iscsi_session_to_shost(session);	\
 	struct iscsi_transport *t = session-&gt;transport;			\
 									\
-	t-&gt;get_session_param(shost, param, &amp;value);			\
+	t-&gt;get_session_param(session, param, &amp;value);			\
 	return snprintf(buf, 20, format"\n", value);			\
 }
 
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 3e5cb5ab2d34..e5618b90996e 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -163,9 +163,6 @@ enum iscsi_param {
 };
 #define ISCSI_PARAM_MAX			14
 
-typedef uint64_t iscsi_sessionh_t;	/* iSCSI Data-Path session handle */
-typedef uint64_t iscsi_connh_t;		/* iSCSI Data-Path connection handle */
-
 #define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
 #define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
 #define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 16602a547a63..b41cf077e54b 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -63,25 +63,28 @@ struct iscsi_transport {
 	int max_lun;
 	unsigned int max_conn;
 	unsigned int max_cmd_len;
-	struct Scsi_Host *(*create_session) (struct scsi_transport_template *t,
-					     uint32_t initial_cmdsn);
-	void (*destroy_session) (struct Scsi_Host *shost);
-	struct iscsi_cls_conn *(*create_conn) (struct Scsi_Host *shost,
+	struct iscsi_cls_session *(*create_session)
+		(struct scsi_transport_template *t, uint32_t sn, uint32_t *sid);
+	void (*destroy_session) (struct iscsi_cls_session *session);
+	struct iscsi_cls_conn *(*create_conn) (struct iscsi_cls_session *sess,
 				uint32_t cid);
-	int (*bind_conn) (iscsi_sessionh_t session, iscsi_connh_t conn,
+	int (*bind_conn) (struct iscsi_cls_session *session,
+			  struct iscsi_cls_conn *cls_conn,
 			  uint32_t transport_fd, int is_leading);
-	int (*start_conn) (iscsi_connh_t conn);
-	void (*stop_conn) (iscsi_connh_t conn, int flag);
+	int (*start_conn) (struct iscsi_cls_conn *conn);
+	void (*stop_conn) (struct iscsi_cls_conn *conn, int flag);
 	void (*destroy_conn) (struct iscsi_cls_conn *conn);
-	int (*set_param) (iscsi_connh_t conn, enum iscsi_param param,
+	int (*set_param) (struct iscsi_cls_conn *conn, enum iscsi_param param,
 			  uint32_t value);
-	int (*get_conn_param) (void *conndata, enum iscsi_param param,
+	int (*get_conn_param) (struct iscsi_cls_conn *conn,
+			       enum iscsi_param param,
 			       uint32_t *value);
-	int (*get_session_param) (struct Scsi_Host *shost,
+	int (*get_session_param) (struct iscsi_cls_session *session,
 				  enum iscsi_param param, uint32_t *value);
-	int (*send_pdu) (iscsi_connh_t conn, struct iscsi_hdr *hdr,
+	int (*send_pdu) (struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 			 char *data, uint32_t data_size);
-	void (*get_stats) (iscsi_connh_t conn, struct iscsi_stats *stats);
+	void (*get_stats) (struct iscsi_cls_conn *conn,
+			   struct iscsi_stats *stats);
 };
 
 /*
@@ -93,15 +96,14 @@ extern int iscsi_unregister_transport(struct iscsi_transport *tt);
 /*
  * control plane upcalls
  */
-extern void iscsi_conn_error(iscsi_connh_t conn, enum iscsi_err error);
-extern int iscsi_recv_pdu(iscsi_connh_t conn, struct iscsi_hdr *hdr,
+extern void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error);
+extern int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 			  char *data, uint32_t data_size);
 
 struct iscsi_cls_conn {
 	struct list_head conn_list;	/* item in connlist */
 	void *dd_data;			/* LLD private data */
 	struct iscsi_transport *transport;
-	iscsi_connh_t connh;
 	int active;			/* must be accessed with the connlock */
 	struct device dev;		/* sysfs transport/container device */
 	struct mempool_zone *z_error;
@@ -113,7 +115,7 @@ struct iscsi_cls_conn {
 	container_of(_dev, struct iscsi_cls_conn, dev)
 
 struct iscsi_cls_session {
-	struct list_head list;	/* item in session_list */
+	struct list_head sess_list;		/* item in session_list */
 	struct iscsi_transport *transport;
 	struct device dev;	/* sysfs transport/container device */
 };</pre><hr><pre>commit a1e80c20e1ac751dbdd88dee989e9a19c22c4a84
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Jan 13 18:05:56 2006 -0600

    [SCSI] iscsi: use pageslab
    
    From: FUJITA Tomonori &lt;tomof@acm.org&gt; and zhenyu.z.wang@intel.com:
    
    We cannot handle filesystems like XFS becuase of the pages they
    are sending us. We had thought page_count could be used to
    work around this, but the correct test is for PageSlab.
    
    The proper solution is to figure out what type of pages
    filesystems can use so we do not have to add tests like
    this or handle it in the block layer for all network block drivers
    but the issue still has not been resolved on fs-devel
    so we are sending this patch as a temporary fix.
    
    This is last patch just in case it is Nakd with the explanation
    that we need to push the correct fix through fs-devel, mm
    or the block layer. The rest of the patchset can live without
    the patch, but the driver will not work with filesystems like
    XFS.
    
    Signed-off-by: Alex Aizman &lt;itn780@yahoo.com&gt;
    Signed-off-by: Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 4e4b1061a5e9..1b495afe6d17 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -109,7 +109,7 @@ iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg)
 	/*
 	 * Fastpath: sg element fits into single page
 	 */
-	if (sg-&gt;length + sg-&gt;offset &lt;= PAGE_SIZE &amp;&amp; page_count(sg-&gt;page) &gt;= 2)
+	if (sg-&gt;length + sg-&gt;offset &lt;= PAGE_SIZE &amp;&amp; !PageSlab(sg-&gt;page))
 		ibuf-&gt;use_sendmsg = 0;
 	else
 		ibuf-&gt;use_sendmsg = 1;</pre><hr><pre>commit 55e3299d9eca01fb2351c5d37e222872b7c6e0af
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Jan 13 18:05:53 2006 -0600

    [SCSI] iscsi: fix 4k stack iscsi setups
    
    When we run the xmit code from queuecomand the stack trace
    gets too deep. The patch runs the xmit code from the scsi_host
    work queue. This fixes 4k stack and xfs support and should
    fix the st and sg stack usage bugs.
    
    Signed-off-by: Alex Aizman &lt;itn780@yahoo.com&gt;
    Signed-off-by: Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index e31d350e6b67..4e4b1061a5e9 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -525,7 +525,7 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	__kfifo_put(ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*));
 	__kfifo_put(conn-&gt;writequeue, (void*)&amp;ctask, sizeof(void*));
 
-	schedule_work(&amp;conn-&gt;xmitwork);
+	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
 	conn-&gt;r2t_pdus_cnt++;
 	spin_unlock(&amp;session-&gt;lock);
 
@@ -1267,7 +1267,7 @@ iscsi_write_space(struct sock *sk)
 	conn-&gt;old_write_space(sk);
 	debug_tcp("iscsi_write_space: cid %d\n", conn-&gt;id);
 	clear_bit(SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-	schedule_work(&amp;conn-&gt;xmitwork);
+	scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 }
 
 static void
@@ -2275,7 +2275,7 @@ iscsi_xmitworker(void *data)
 	 */
 	mutex_lock(&amp;conn-&gt;xmitmutex);
 	if (iscsi_data_xmit(conn))
-		schedule_work(&amp;conn-&gt;xmitwork);
+		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 	mutex_unlock(&amp;conn-&gt;xmitmutex);
 }
 
@@ -2340,15 +2340,7 @@ iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 		session-&gt;cmdsn, session-&gt;max_cmdsn - session-&gt;exp_cmdsn + 1);
 	spin_unlock(&amp;session-&gt;lock);
 
-        if (!in_interrupt() &amp;&amp; mutex_trylock(&amp;conn-&gt;xmitmutex)) {
-		spin_unlock_irq(host-&gt;host_lock);
-		if (iscsi_data_xmit(conn))
-			schedule_work(&amp;conn-&gt;xmitwork);
-		mutex_unlock(&amp;conn-&gt;xmitmutex);
-		spin_lock_irq(host-&gt;host_lock);
-	} else
-		schedule_work(&amp;conn-&gt;xmitwork);
-
+	scsi_queue_work(host, &amp;conn-&gt;xmitwork);
 	return 0;
 
 reject:
@@ -2942,8 +2934,7 @@ iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	else
 	        __kfifo_put(conn-&gt;mgmtqueue, (void*)&amp;mtask, sizeof(void*));
 
-	schedule_work(&amp;conn-&gt;xmitwork);
-
+	scsi_queue_work(session-&gt;host, &amp;conn-&gt;xmitwork);
 	return 0;
 }
 
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 45e31635a595..59a1c9d9d3bd 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -379,6 +379,7 @@ iscsi_transport_create_session(struct scsi_transport_template *scsit,
 	shost-&gt;max_lun = transport-&gt;max_lun;
 	shost-&gt;max_cmd_len = transport-&gt;max_cmd_len;
 	shost-&gt;transportt = scsit;
+	shost-&gt;transportt-&gt;create_work_queue = 1;
 
 	if (scsi_add_host(shost, NULL))
 		goto free_host;</pre><hr><pre>commit 7b8631b53bea286b68847a939b87135198335b66
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Jan 13 18:05:50 2006 -0600

    [SCSI] iscsi: seperate iscsi interface from setup functions
    
    This is the second version of the patch to address Christoph's comments.
    Instead of doing the lib, I just kept everything in scsi_trnapsort_iscsi.c
    like the FC and SPI class. This was becuase the driver model and sysfs
    class is tied to the session and connection setup so separating did not
    buy very much at this time.
    
    The reason for this patch was becuase HW iscsi LLDs like qla4xxx cannot
    use the iscsi class becuase the scsi_host was tied to the interface and
    class code. This patch just seperates the session from scsi host so
    that LLDs that allocate the host per some resource like pci device
    can still use the class.
    
    This is also fixes a couple refcount bugs that can be triggered
    when users have a sysfs file open, close the session, then
    read or write to the file.
    
    Signed-off-by: Alex Aizman &lt;itn780@yahoo.com&gt;
    Signed-off-by: Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 0acc4b235d9b..e31d350e6b67 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -2435,17 +2435,20 @@ iscsi_pool_free(struct iscsi_queue *q, void **items)
 	kfree(items);
 }
 
-static iscsi_connh_t
-iscsi_conn_create(iscsi_sessionh_t sessionh, uint32_t conn_idx)
+static struct iscsi_cls_conn *
+iscsi_conn_create(struct Scsi_Host *shost, uint32_t conn_idx)
 {
-	struct iscsi_session *session = iscsi_ptr(sessionh);
-	struct iscsi_conn *conn = NULL;
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	struct iscsi_conn *conn;
+	struct iscsi_cls_conn *cls_conn;
 
-	conn = kmalloc(sizeof(struct iscsi_conn), GFP_KERNEL);
-	if (conn == NULL)
-		goto conn_alloc_fail;
-	memset(conn, 0, sizeof(struct iscsi_conn));
+	cls_conn = iscsi_create_conn(hostdata_session(shost-&gt;hostdata),
+				     conn_idx);
+	if (!cls_conn)
+		return NULL;
+	conn = cls_conn-&gt;dd_data;
 
+	memset(conn, 0, sizeof(struct iscsi_conn));
 	conn-&gt;c_stage = ISCSI_CONN_INITIAL_STAGE;
 	conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
 	conn-&gt;id = conn_idx;
@@ -2507,7 +2510,7 @@ iscsi_conn_create(iscsi_sessionh_t sessionh, uint32_t conn_idx)
 	mutex_init(&amp;conn-&gt;xmitmutex);
 	init_waitqueue_head(&amp;conn-&gt;ehwait);
 
-	return iscsi_handle(conn);
+	return cls_conn;
 
 max_recv_dlenght_alloc_fail:
 	spin_lock_bh(&amp;session-&gt;lock);
@@ -2523,15 +2526,14 @@ iscsi_conn_create(iscsi_sessionh_t sessionh, uint32_t conn_idx)
 writequeue_alloc_fail:
 	kfifo_free(conn-&gt;xmitqueue);
 xmitqueue_alloc_fail:
-	kfree(conn);
-conn_alloc_fail:
-	return iscsi_handle(NULL);
+	iscsi_destroy_conn(cls_conn);
+	return NULL;
 }
 
 static void
-iscsi_conn_destroy(iscsi_connh_t connh)
+iscsi_conn_destroy(struct iscsi_cls_conn *cls_conn)
 {
-	struct iscsi_conn *conn = iscsi_ptr(connh);
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
 	unsigned long flags;
 
@@ -2626,7 +2628,8 @@ iscsi_conn_destroy(iscsi_connh_t connh)
 	kfifo_free(conn-&gt;writequeue);
 	kfifo_free(conn-&gt;immqueue);
 	kfifo_free(conn-&gt;mgmtqueue);
-	kfree(conn);
+
+	iscsi_destroy_conn(cls_conn);
 }
 
 static int
@@ -3257,17 +3260,23 @@ static struct scsi_host_template iscsi_sht = {
 	.this_id		= -1,
 };
 
-static iscsi_sessionh_t
-iscsi_session_create(uint32_t initial_cmdsn, struct Scsi_Host *host)
+static struct iscsi_transport iscsi_tcp_transport;
+
+static struct Scsi_Host *
+iscsi_session_create(struct scsi_transport_template *scsit,
+		     uint32_t initial_cmdsn)
 {
-	int cmd_i;
+	struct Scsi_Host *shost;
 	struct iscsi_session *session;
+	int cmd_i;
 
-	session = iscsi_hostdata(host-&gt;hostdata);
-	memset(session, 0, sizeof(struct iscsi_session));
+	shost = iscsi_transport_create_session(scsit, &amp;iscsi_tcp_transport);
+	if (!shost)
+		return NULL; 
 
-	session-&gt;host = host;
-	session-&gt;id = host-&gt;host_no;
+	session = iscsi_hostdata(shost-&gt;hostdata);
+	memset(session, 0, sizeof(struct iscsi_session));
+	session-&gt;host = shost;
 	session-&gt;state = ISCSI_STATE_LOGGED_IN;
 	session-&gt;mgmtpool_max = ISCSI_MGMT_CMDS_MAX;
 	session-&gt;cmds_max = ISCSI_XMIT_CMDS_MAX;
@@ -3311,7 +3320,7 @@ iscsi_session_create(uint32_t initial_cmdsn, struct Scsi_Host *host)
 	if (iscsi_r2tpool_alloc(session))
 		goto r2tpool_alloc_fail;
 
-	return iscsi_handle(session);
+	return shost;
 
 r2tpool_alloc_fail:
 	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++)
@@ -3321,15 +3330,15 @@ iscsi_session_create(uint32_t initial_cmdsn, struct Scsi_Host *host)
 mgmtpool_alloc_fail:
 	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
 cmdpool_alloc_fail:
-	return iscsi_handle(NULL);
+	return NULL;
 }
 
 static void
-iscsi_session_destroy(iscsi_sessionh_t sessionh)
+iscsi_session_destroy(struct Scsi_Host *shost)
 {
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
 	int cmd_i;
 	struct iscsi_data_task *dtask, *n;
-	struct iscsi_session *session = iscsi_ptr(sessionh);
 
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
 		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
@@ -3345,6 +3354,8 @@ iscsi_session_destroy(iscsi_sessionh_t sessionh)
 	iscsi_r2tpool_free(session);
 	iscsi_pool_free(&amp;session-&gt;mgmtpool, (void**)session-&gt;mgmt_cmds);
 	iscsi_pool_free(&amp;session-&gt;cmdpool, (void**)session-&gt;cmds);
+
+	iscsi_transport_destroy_session(shost);
 }
 
 static int
@@ -3493,25 +3504,12 @@ iscsi_conn_set_param(iscsi_connh_t connh, enum iscsi_param param,
 }
 
 static int
-iscsi_conn_get_param(iscsi_connh_t connh, enum iscsi_param param,
-		     uint32_t *value)
+iscsi_session_get_param(struct Scsi_Host *shost,
+			enum iscsi_param param, uint32_t *value)
 {
-	struct iscsi_conn *conn = iscsi_ptr(connh);
-	struct iscsi_session *session = conn-&gt;session;
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
 
 	switch(param) {
-	case ISCSI_PARAM_MAX_RECV_DLENGTH:
-		*value = conn-&gt;max_recv_dlength;
-		break;
-	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
-		*value = conn-&gt;max_xmit_dlength;
-		break;
-	case ISCSI_PARAM_HDRDGST_EN:
-		*value = conn-&gt;hdrdgst_en;
-		break;
-	case ISCSI_PARAM_DATADGST_EN:
-		*value = conn-&gt;datadgst_en;
-		break;
 	case ISCSI_PARAM_INITIAL_R2T_EN:
 		*value = session-&gt;initial_r2t_en;
 		break;
@@ -3549,6 +3547,31 @@ iscsi_conn_get_param(iscsi_connh_t connh, enum iscsi_param param,
 	return 0;
 }
 
+static int
+iscsi_conn_get_param(void *data, enum iscsi_param param, uint32_t *value)
+{
+	struct iscsi_conn *conn = data;
+
+	switch(param) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		*value = conn-&gt;max_recv_dlength;
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		*value = conn-&gt;max_xmit_dlength;
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		*value = conn-&gt;hdrdgst_en;
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		*value = conn-&gt;datadgst_en;
+		break;
+	default:
+		return ISCSI_ERR_PARAM_NOT_FOUND;
+	}
+
+	return 0;
+}
+
 static void
 iscsi_conn_get_stats(iscsi_connh_t connh, struct iscsi_stats *stats)
 {
@@ -3593,6 +3616,7 @@ static struct iscsi_transport iscsi_tcp_transport = {
 				  | CAP_DATADGST,
 	.host_template		= &amp;iscsi_sht,
 	.hostdata_size		= sizeof(struct iscsi_session),
+	.conndata_size		= sizeof(struct iscsi_conn),
 	.max_conn		= 1,
 	.max_cmd_len		= ISCSI_TCP_MAX_CMD_LEN,
 	.create_session		= iscsi_session_create,
@@ -3601,7 +3625,8 @@ static struct iscsi_transport iscsi_tcp_transport = {
 	.bind_conn		= iscsi_conn_bind,
 	.destroy_conn		= iscsi_conn_destroy,
 	.set_param		= iscsi_conn_set_param,
-	.get_param		= iscsi_conn_get_param,
+	.get_conn_param		= iscsi_conn_get_param,
+	.get_session_param	= iscsi_session_get_param,
 	.start_conn		= iscsi_conn_start,
 	.stop_conn		= iscsi_conn_stop,
 	.send_pdu		= iscsi_conn_send_pdu,
@@ -3611,8 +3636,6 @@ static struct iscsi_transport iscsi_tcp_transport = {
 static int __init
 iscsi_tcp_init(void)
 {
-	int error;
-
 	if (iscsi_max_lun &lt; 1) {
 		printk(KERN_ERR "Invalid max_lun value of %u\n", iscsi_max_lun);
 		return -EINVAL;
@@ -3625,11 +3648,10 @@ iscsi_tcp_init(void)
 	if (!taskcache)
 		return -ENOMEM;
 
-	error = iscsi_register_transport(&amp;iscsi_tcp_transport);
-	if (error)
+	if (!iscsi_register_transport(&amp;iscsi_tcp_transport))
 		kmem_cache_destroy(taskcache);
 
-	return error;
+	return 0;
 }
 
 static void __exit
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 50ed88f98f46..45e31635a595 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -21,12 +21,9 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 #include &lt;linux/module.h&gt;
-#include &lt;linux/string.h&gt;
-#include &lt;linux/slab.h&gt;
 #include &lt;linux/mempool.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;net/tcp.h&gt;
-
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
 #include &lt;scsi/scsi_device.h&gt;
@@ -45,11 +42,6 @@ struct iscsi_internal {
 	 * List of sessions for this transport
 	 */
 	struct list_head sessions;
-	/*
-	 * lock to serialize access to the sessions list which must
-	 * be taken after the rx_queue_mutex
-	 */
-	spinlock_t session_lock;
 	/*
 	 * based on transport capabilities, at register time we set these
 	 * bits to tell the transport class it wants attributes displayed
@@ -157,7 +149,7 @@ struct mempool_zone {
 	spinlock_t freelock;
 };
 
-static struct mempool_zone z_reply;
+static struct mempool_zone *z_reply;
 
 /*
  * Z_MAX_* - actual mempool size allocated at the mempool_zone_init() time
@@ -172,50 +164,270 @@ static struct mempool_zone z_reply;
 #define Z_MAX_ERROR	16
 #define Z_HIWAT_ERROR	12
 
-struct iscsi_if_conn {
-	struct list_head conn_list;	/* item in connlist */
-	struct list_head session_list;	/* item in session-&gt;connections */
-	iscsi_connh_t connh;
-	int active;			/* must be accessed with the connlock */
-	struct Scsi_Host *host;		/* originated shost */
-	struct device dev;		/* sysfs transport/container device */
-	struct iscsi_transport *transport;
-	struct mempool_zone z_error;
-	struct mempool_zone z_pdu;
-	struct list_head freequeue;
-};
+static LIST_HEAD(connlist);
+static DEFINE_SPINLOCK(connlock);
 
-#define iscsi_dev_to_if_conn(_dev) \
-	container_of(_dev, struct iscsi_if_conn, dev)
+/*
+ * The following functions can be used by LLDs that allocate
+ * their own scsi_hosts or by software iscsi LLDs
+ */
+static void iscsi_session_release(struct device *dev)
+{
+	struct iscsi_cls_session *session = iscsi_dev_to_session(dev);
+	struct iscsi_transport *transport = session-&gt;transport;
+	struct Scsi_Host *shost;
 
-#define iscsi_cdev_to_if_conn(_cdev) \
-	iscsi_dev_to_if_conn(_cdev-&gt;dev)
+	shost = iscsi_session_to_shost(session);
+	scsi_host_put(shost);
+	kfree(session);
+	module_put(transport-&gt;owner);
+}
 
-static LIST_HEAD(connlist);
-static DEFINE_SPINLOCK(connlock);
+static int iscsi_is_session_dev(const struct device *dev)
+{
+	return dev-&gt;release == iscsi_session_release;
+}
 
-struct iscsi_if_session {
-	struct list_head list;	/* item in session_list */
-	struct list_head connections;
-	iscsi_sessionh_t sessionh;
-	struct iscsi_transport *transport;
-	struct device dev;	/* sysfs transport/container device */
-};
+/**
+ * iscsi_create_session - create iscsi class session
+ * @shost: scsi host
+ * @transport: iscsi transport
+ *
+ * This can be called from a LLD or iscsi_transport
+ **/
+struct iscsi_cls_session *
+iscsi_create_session(struct Scsi_Host *shost, struct iscsi_transport *transport)
+{
+	struct iscsi_cls_session *session;
+	int err;
+
+	if (!try_module_get(transport-&gt;owner))
+		return NULL;
+
+	session = kzalloc(sizeof(*session), GFP_KERNEL);
+	if (!session)
+		goto module_put;
+	session-&gt;transport = transport;
+
+	/* this is released in the dev's release function */
+	scsi_host_get(shost);
+	snprintf(session-&gt;dev.bus_id, BUS_ID_SIZE, "session%u", shost-&gt;host_no);
+	session-&gt;dev.parent = &amp;shost-&gt;shost_gendev;
+	session-&gt;dev.release = iscsi_session_release;
+	err = device_register(&amp;session-&gt;dev);
+	if (err) {
+		dev_printk(KERN_ERR, &amp;session-&gt;dev, "iscsi: could not "
+			   "register session's dev\n");
+		goto free_session;
+	}
+	transport_register_device(&amp;session-&gt;dev);
+
+	return session;
+
+free_session:
+	kfree(session);
+module_put:
+	module_put(transport-&gt;owner);
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_create_session);
+
+/**
+ * iscsi_destroy_session - destroy iscsi session
+ * @session: iscsi_session
+ *
+ * Can be called by a LLD or iscsi_transport. There must not be
+ * any running connections.
+ **/
+int iscsi_destroy_session(struct iscsi_cls_session *session)
+{
+	transport_unregister_device(&amp;session-&gt;dev);
+	device_unregister(&amp;session-&gt;dev);
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_destroy_session);
+
+static void iscsi_conn_release(struct device *dev)
+{
+	struct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev);
+	struct device *parent = conn-&gt;dev.parent;
+
+	kfree(conn);
+	put_device(parent);
+}
+
+static int iscsi_is_conn_dev(const struct device *dev)
+{
+	return dev-&gt;release == iscsi_conn_release;
+}
+
+/**
+ * iscsi_create_conn - create iscsi class connection
+ * @session: iscsi cls session
+ * @cid: connection id
+ *
+ * This can be called from a LLD or iscsi_transport. The connection
+ * is child of the session so cid must be unique for all connections
+ * on the session.
+ **/
+struct iscsi_cls_conn *
+iscsi_create_conn(struct iscsi_cls_session *session, uint32_t cid)
+{
+	struct iscsi_transport *transport = session-&gt;transport;
+	struct Scsi_Host *shost = iscsi_session_to_shost(session);
+	struct iscsi_cls_conn *conn;
+	int err;
+
+	conn = kzalloc(sizeof(*conn) + transport-&gt;conndata_size, GFP_KERNEL);
+	if (!conn)
+		return NULL;
+
+	if (transport-&gt;conndata_size)
+		conn-&gt;dd_data = &amp;conn[1];
+
+	INIT_LIST_HEAD(&amp;conn-&gt;conn_list);
+	conn-&gt;transport = transport;
+
+	/* this is released in the dev's release function */
+	if (!get_device(&amp;session-&gt;dev))
+		goto free_conn;
+	snprintf(conn-&gt;dev.bus_id, BUS_ID_SIZE, "connection%d:%u",
+		 shost-&gt;host_no, cid);
+	conn-&gt;dev.parent = &amp;session-&gt;dev;
+	conn-&gt;dev.release = iscsi_conn_release;
+	err = device_register(&amp;conn-&gt;dev);
+	if (err) {
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: could not register "
+			   "connection's dev\n");
+		goto release_parent_ref;
+	}
+	transport_register_device(&amp;conn-&gt;dev);
+	return conn;
+
+release_parent_ref:
+	put_device(&amp;session-&gt;dev);
+free_conn:
+	kfree(conn);
+	return NULL;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_create_conn);
+
+/**
+ * iscsi_destroy_conn - destroy iscsi class connection
+ * @session: iscsi cls session
+ *
+ * This can be called from a LLD or iscsi_transport.
+ **/
+int iscsi_destroy_conn(struct iscsi_cls_conn *conn)
+{
+	transport_unregister_device(&amp;conn-&gt;dev);
+	device_unregister(&amp;conn-&gt;dev);
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_destroy_conn);
+
+/*
+ * These functions are used only by software iscsi_transports
+ * which do not allocate and more their scsi_hosts since this
+ * is initiated from userspace.
+ */
+
+/*
+ * iSCSI Session's hostdata organization:
+ *
+ *    *------------------* &lt;== hostdata_session(host-&gt;hostdata)
+ *    | ptr to class sess|
+ *    |------------------| &lt;== iscsi_hostdata(host-&gt;hostdata)
+ *    | transport's data |
+ *    *------------------*
+ */
+
+#define hostdata_privsize(_t)	(sizeof(unsigned long) + _t-&gt;hostdata_size + \
+				 _t-&gt;hostdata_size % sizeof(unsigned long))
+
+#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
+
+/**
+ * iscsi_transport_create_session - create iscsi cls session and host
+ * scsit: scsi transport template
+ * transport: iscsi transport template
+ *
+ * This can be used by software iscsi_transports that allocate
+ * a session per scsi host.
+ **/
+struct Scsi_Host *
+iscsi_transport_create_session(struct scsi_transport_template *scsit,
+			       struct iscsi_transport *transport)
+{
+	struct iscsi_cls_session *session;
+	struct Scsi_Host *shost;
+
+	shost = scsi_host_alloc(transport-&gt;host_template,
+				hostdata_privsize(transport));
+	if (!shost) {
+		printk(KERN_ERR "iscsi: can not allocate SCSI host for "
+			"session\n");
+		return NULL;
+	}
+
+	shost-&gt;max_id = 1;
+	shost-&gt;max_channel = 0;
+	shost-&gt;max_lun = transport-&gt;max_lun;
+	shost-&gt;max_cmd_len = transport-&gt;max_cmd_len;
+	shost-&gt;transportt = scsit;
+
+	if (scsi_add_host(shost, NULL))
+		goto free_host;
+
+	session = iscsi_create_session(shost, transport);
+	if (!session)
+		goto remove_host;
 
-#define iscsi_dev_to_if_session(_dev) \
-	container_of(_dev, struct iscsi_if_session, dev)
+	*(unsigned long*)shost-&gt;hostdata = (unsigned long)session;
+	return shost;
+
+remove_host:
+	scsi_remove_host(shost);
+free_host:
+	scsi_host_put(shost);
+	return NULL;
+}
 
-#define iscsi_cdev_to_if_session(_cdev) \
-	iscsi_dev_to_if_session(_cdev-&gt;dev)
+EXPORT_SYMBOL_GPL(iscsi_transport_create_session);
 
-#define iscsi_if_session_to_shost(_session) \
-	dev_to_shost(_session-&gt;dev.parent)
+/**
+ * iscsi_transport_destroy_session - destroy session and scsi host
+ * shost: scsi host
+ *
+ * This can be used by software iscsi_transports that allocate
+ * a session per scsi host.
+ **/
+int iscsi_transport_destroy_session(struct Scsi_Host *shost)
+{
+	struct iscsi_cls_session *session;
 
-static struct iscsi_if_conn*
+	scsi_remove_host(shost);
+	session = hostdata_session(shost-&gt;hostdata);
+	iscsi_destroy_session(session);
+	/* ref from host alloc */
+	scsi_host_put(shost);
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(iscsi_transport_destroy_session);
+
+/*
+ * iscsi interface functions
+ */
+static struct iscsi_cls_conn*
 iscsi_if_find_conn(uint64_t key)
 {
 	unsigned long flags;
-	struct iscsi_if_conn *conn;
+	struct iscsi_cls_conn *conn;
 
 	spin_lock_irqsave(&amp;connlock, flags);
 	list_for_each_entry(conn, &amp;connlist, conn_list)
@@ -250,7 +462,7 @@ static inline struct list_head *skb_to_lh(struct sk_buff *skb)
 }
 
 static void*
-mempool_zone_alloc_skb(gfp_t gfp_mask, void *pool_data)
+mempool_zone_alloc_skb(unsigned int gfp_mask, void *pool_data)
 {
 	struct mempool_zone *zone = pool_data;
 
@@ -282,14 +494,21 @@ mempool_zone_complete(struct mempool_zone *zone)
 	spin_unlock_irqrestore(&amp;zone-&gt;freelock, flags);
 }
 
-static int
-mempool_zone_init(struct mempool_zone *zp, unsigned max, unsigned size,
-		unsigned hiwat)
+static struct mempool_zone *
+mempool_zone_init(unsigned max, unsigned size, unsigned hiwat)
 {
+	struct mempool_zone *zp;
+
+	zp = kzalloc(sizeof(*zp), GFP_KERNEL);
+	if (!zp)
+		return NULL;
+
 	zp-&gt;pool = mempool_create(max, mempool_zone_alloc_skb,
 				  mempool_zone_free_skb, zp);
-	if (!zp-&gt;pool)
-		return -ENOMEM;
+	if (!zp-&gt;pool) {
+		kfree(zp);
+		return NULL;
+	}
 
 	zp-&gt;size = size;
 	zp-&gt;hiwat = hiwat;
@@ -298,9 +517,14 @@ mempool_zone_init(struct mempool_zone *zp, unsigned max, unsigned size,
 	spin_lock_init(&amp;zp-&gt;freelock);
 	atomic_set(&amp;zp-&gt;allocated, 0);
 
-	return 0;
+	return zp;
 }
 
+static void mempool_zone_destroy(struct mempool_zone *zp)
+{
+	mempool_destroy(zp-&gt;pool);
+	kfree(zp);
+}
 
 static struct sk_buff*
 mempool_zone_get_skb(struct mempool_zone *zone)
@@ -340,7 +564,7 @@ int iscsi_recv_pdu(iscsi_connh_t connh, struct iscsi_hdr *hdr,
 	struct nlmsghdr	*nlh;
 	struct sk_buff *skb;
 	struct iscsi_uevent *ev;
-	struct iscsi_if_conn *conn;
+	struct iscsi_cls_conn *conn;
 	char *pdu;
 	int len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iscsi_hdr) +
 			      data_size);
@@ -348,13 +572,13 @@ int iscsi_recv_pdu(iscsi_connh_t connh, struct iscsi_hdr *hdr,
 	conn = iscsi_if_find_conn(connh);
 	BUG_ON(!conn);
 
-	mempool_zone_complete(&amp;conn-&gt;z_pdu);
+	mempool_zone_complete(conn-&gt;z_pdu);
 
-	skb = mempool_zone_get_skb(&amp;conn-&gt;z_pdu);
+	skb = mempool_zone_get_skb(conn-&gt;z_pdu);
 	if (!skb) {
 		iscsi_conn_error(connh, ISCSI_ERR_CONN_FAILED);
-		printk(KERN_ERR "iscsi%d: can not deliver control PDU: OOM\n",
-		       conn-&gt;host-&gt;host_no);
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: can not deliver "
+			   "control PDU: OOM\n");
 		return -ENOMEM;
 	}
 
@@ -363,14 +587,14 @@ int iscsi_recv_pdu(iscsi_connh_t connh, struct iscsi_hdr *hdr,
 	memset(ev, 0, sizeof(*ev));
 	ev-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
 	ev-&gt;type = ISCSI_KEVENT_RECV_PDU;
-	if (atomic_read(&amp;conn-&gt;z_pdu.allocated) &gt;= conn-&gt;z_pdu.hiwat)
+	if (atomic_read(&amp;conn-&gt;z_pdu-&gt;allocated) &gt;= conn-&gt;z_pdu-&gt;hiwat)
 		ev-&gt;iferror = -ENOMEM;
 	ev-&gt;r.recv_req.conn_handle = connh;
 	pdu = (char*)ev + sizeof(*ev);
 	memcpy(pdu, hdr, sizeof(struct iscsi_hdr));
 	memcpy(pdu + sizeof(struct iscsi_hdr), data, data_size);
 
-	return iscsi_unicast_skb(&amp;conn-&gt;z_pdu, skb);
+	return iscsi_unicast_skb(conn-&gt;z_pdu, skb);
 }
 EXPORT_SYMBOL_GPL(iscsi_recv_pdu);
 
@@ -379,18 +603,18 @@ void iscsi_conn_error(iscsi_connh_t connh, enum iscsi_err error)
 	struct nlmsghdr	*nlh;
 	struct sk_buff	*skb;
 	struct iscsi_uevent *ev;
-	struct iscsi_if_conn *conn;
+	struct iscsi_cls_conn *conn;
 	int len = NLMSG_SPACE(sizeof(*ev));
 
 	conn = iscsi_if_find_conn(connh);
 	BUG_ON(!conn);
 
-	mempool_zone_complete(&amp;conn-&gt;z_error);
+	mempool_zone_complete(conn-&gt;z_error);
 
-	skb = mempool_zone_get_skb(&amp;conn-&gt;z_error);
+	skb = mempool_zone_get_skb(conn-&gt;z_error);
 	if (!skb) {
-		printk(KERN_ERR "iscsi%d: gracefully ignored conn error (%d)\n",
-		       conn-&gt;host-&gt;host_no, error);
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: gracefully ignored "
+			  "conn error (%d)\n", error);
 		return;
 	}
 
@@ -398,15 +622,15 @@ void iscsi_conn_error(iscsi_connh_t connh, enum iscsi_err error)
 	ev = NLMSG_DATA(nlh);
 	ev-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
 	ev-&gt;type = ISCSI_KEVENT_CONN_ERROR;
-	if (atomic_read(&amp;conn-&gt;z_error.allocated) &gt;= conn-&gt;z_error.hiwat)
+	if (atomic_read(&amp;conn-&gt;z_error-&gt;allocated) &gt;= conn-&gt;z_error-&gt;hiwat)
 		ev-&gt;iferror = -ENOMEM;
 	ev-&gt;r.connerror.error = error;
 	ev-&gt;r.connerror.conn_handle = connh;
 
-	iscsi_unicast_skb(&amp;conn-&gt;z_error, skb);
+	iscsi_unicast_skb(conn-&gt;z_error, skb);
 
-	printk(KERN_INFO "iscsi%d: detected conn error (%d)\n",
-	       conn-&gt;host-&gt;host_no, error);
+	dev_printk(KERN_INFO, &amp;conn-&gt;dev, "iscsi: detected conn error (%d)\n",
+		   error);
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_error);
 
@@ -420,9 +644,9 @@ iscsi_if_send_reply(int pid, int seq, int type, int done, int multi,
 	int flags = multi ? NLM_F_MULTI : 0;
 	int t = done ? NLMSG_DONE : type;
 
-	mempool_zone_complete(&amp;z_reply);
+	mempool_zone_complete(z_reply);
 
-	skb = mempool_zone_get_skb(&amp;z_reply);
+	skb = mempool_zone_get_skb(z_reply);
 	/*
 	 * FIXME:
 	 * user is supposed to react on iferror == -ENOMEM;
@@ -433,366 +657,197 @@ iscsi_if_send_reply(int pid, int seq, int type, int done, int multi,
 	nlh = __nlmsg_put(skb, pid, seq, t, (len - sizeof(*nlh)), 0);
 	nlh-&gt;nlmsg_flags = flags;
 	memcpy(NLMSG_DATA(nlh), payload, size);
-	return iscsi_unicast_skb(&amp;z_reply, skb);
+	return iscsi_unicast_skb(z_reply, skb);
 }
 
-/*
- * iSCSI Session's hostdata organization:
- *
- *    *------------------* &lt;== host-&gt;hostdata
- *    | transport        |
- *    |------------------| &lt;== iscsi_hostdata(host-&gt;hostdata)
- *    | transport's data |
- *    |------------------| &lt;== hostdata_session(host-&gt;hostdata)
- *    | interface's data |
- *    *------------------*
- */
+static int
+iscsi_if_get_stats(struct iscsi_transport *transport, struct sk_buff *skb,
+		   struct nlmsghdr *nlh)
+{
+	struct iscsi_uevent *ev = NLMSG_DATA(nlh);
+	struct iscsi_stats *stats;
+	struct sk_buff *skbstat;
+	struct iscsi_cls_conn *conn;
+	struct nlmsghdr	*nlhstat;
+	struct iscsi_uevent *evstat;
+	int len = NLMSG_SPACE(sizeof(*ev) +
+			      sizeof(struct iscsi_stats) +
+			      sizeof(struct iscsi_stats_custom) *
+			      ISCSI_STATS_CUSTOM_MAX);
+	int err = 0;
 
-#define hostdata_privsize(_t)	(sizeof(unsigned long) + _t-&gt;hostdata_size + \
-				 _t-&gt;hostdata_size % sizeof(unsigned long) + \
-				 sizeof(struct iscsi_if_session))
+	conn = iscsi_if_find_conn(ev-&gt;u.get_stats.conn_handle);
+	if (!conn)
+		return -EEXIST;
 
-#define hostdata_session(_hostdata) ((void*)_hostdata + sizeof(unsigned long) + \
-			((struct iscsi_transport *) \
-			 iscsi_ptr(*(uint64_t *)_hostdata))-&gt;hostdata_size)
+	do {
+		int actual_size;
 
-static void iscsi_if_session_dev_release(struct device *dev)
-{
-	struct iscsi_if_session *session = iscsi_dev_to_if_session(dev);
-	struct iscsi_transport *transport = session-&gt;transport;
-	struct Scsi_Host *shost = iscsi_if_session_to_shost(session);
-	struct iscsi_if_conn *conn, *tmp;
-	unsigned long flags;
+		mempool_zone_complete(conn-&gt;z_pdu);
 
-	/* now free connections */
-	spin_lock_irqsave(&amp;connlock, flags);
-	list_for_each_entry_safe(conn, tmp, &amp;session-&gt;connections,
-				 session_list) {
-		list_del(&amp;conn-&gt;session_list);
-		mempool_destroy(conn-&gt;z_pdu.pool);
-		mempool_destroy(conn-&gt;z_error.pool);
-		kfree(conn);
-	}
-	spin_unlock_irqrestore(&amp;connlock, flags);
-	scsi_host_put(shost);
-	module_put(transport-&gt;owner);
+		skbstat = mempool_zone_get_skb(conn-&gt;z_pdu);
+		if (!skbstat) {
+			dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: can not "
+				   "deliver stats: OOM\n");
+			return -ENOMEM;
+		}
+
+		nlhstat = __nlmsg_put(skbstat, daemon_pid, 0, 0,
+				      (len - sizeof(*nlhstat)), 0);
+		evstat = NLMSG_DATA(nlhstat);
+		memset(evstat, 0, sizeof(*evstat));
+		evstat-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
+		evstat-&gt;type = nlh-&gt;nlmsg_type;
+		if (atomic_read(&amp;conn-&gt;z_pdu-&gt;allocated) &gt;= conn-&gt;z_pdu-&gt;hiwat)
+			evstat-&gt;iferror = -ENOMEM;
+		evstat-&gt;u.get_stats.conn_handle =
+			ev-&gt;u.get_stats.conn_handle;
+		stats = (struct iscsi_stats *)
+			((char*)evstat + sizeof(*evstat));
+		memset(stats, 0, sizeof(*stats));
+
+		transport-&gt;get_stats(ev-&gt;u.get_stats.conn_handle, stats);
+		actual_size = NLMSG_SPACE(sizeof(struct iscsi_uevent) +
+					  sizeof(struct iscsi_stats) +
+					  sizeof(struct iscsi_stats_custom) *
+					  stats-&gt;custom_length);
+		actual_size -= sizeof(*nlhstat);
+		actual_size = NLMSG_LENGTH(actual_size);
+		skb_trim(skb, NLMSG_ALIGN(actual_size));
+		nlhstat-&gt;nlmsg_len = actual_size;
+
+		err = iscsi_unicast_skb(conn-&gt;z_pdu, skbstat);
+	} while (err &lt; 0 &amp;&amp; err != -ECONNREFUSED);
+
+	return err;
 }
 
 static int
 iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_uevent *ev)
 {
 	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
-	struct iscsi_if_session *session;
 	struct Scsi_Host *shost;
-	unsigned long flags;
-	int error;
-
-	if (!try_module_get(transport-&gt;owner))
-		return -EPERM;
 
-	shost = scsi_host_alloc(transport-&gt;host_template,
-				hostdata_privsize(transport));
-	if (!shost) {
-		ev-&gt;r.c_session_ret.session_handle = iscsi_handle(NULL);
-		printk(KERN_ERR "iscsi: can not allocate SCSI host for "
-		       "session\n");
-		error = -ENOMEM;
-		goto out_module_put;
-	}
-	shost-&gt;max_id = 1;
-	shost-&gt;max_channel = 0;
-	shost-&gt;max_lun = transport-&gt;max_lun;
-	shost-&gt;max_cmd_len = transport-&gt;max_cmd_len;
-	shost-&gt;transportt = &amp;priv-&gt;t;
-
-	/* store struct iscsi_transport in hostdata */
-	*(uint64_t*)shost-&gt;hostdata = ev-&gt;transport_handle;
+	if (!transport-&gt;create_session)
+		return -EINVAL;
 
-	ev-&gt;r.c_session_ret.session_handle = transport-&gt;create_session(
-					ev-&gt;u.c_session.initial_cmdsn, shost);
-	if (ev-&gt;r.c_session_ret.session_handle == iscsi_handle(NULL)) {
-		error = 0;
-		goto out_host_put;
-	}
+	shost = transport-&gt;create_session(&amp;priv-&gt;t,
+					  ev-&gt;u.c_session.initial_cmdsn);
+	if (!shost)
+		return -ENOMEM;
 
-	/* host_no becomes assigned SID */
+	ev-&gt;r.c_session_ret.session_handle = iscsi_handle(iscsi_hostdata(shost-&gt;hostdata));
 	ev-&gt;r.c_session_ret.sid = shost-&gt;host_no;
-	/* initialize session */
-	session = hostdata_session(shost-&gt;hostdata);
-	INIT_LIST_HEAD(&amp;session-&gt;connections);
-	INIT_LIST_HEAD(&amp;session-&gt;list);
-	session-&gt;sessionh = ev-&gt;r.c_session_ret.session_handle;
-	session-&gt;transport = transport;
-
-	error = scsi_add_host(shost, NULL);
-	if (error)
-		goto out_destroy_session;
-
-	/*
-	 * this is released in the dev's release function)
-	 */
-	scsi_host_get(shost);
-	snprintf(session-&gt;dev.bus_id, BUS_ID_SIZE, "session%u", shost-&gt;host_no);
-	session-&gt;dev.parent = &amp;shost-&gt;shost_gendev;
-	session-&gt;dev.release = iscsi_if_session_dev_release;
-	error = device_register(&amp;session-&gt;dev);
-	if (error) {
-		printk(KERN_ERR "iscsi: could not register session%d's dev\n",
-		       shost-&gt;host_no);
-		goto out_remove_host;
-	}
-	transport_register_device(&amp;session-&gt;dev);
-
-	/* add this session to the list of active sessions */
-	spin_lock_irqsave(&amp;priv-&gt;session_lock, flags);
-	list_add(&amp;session-&gt;list, &amp;priv-&gt;sessions);
-	spin_unlock_irqrestore(&amp;priv-&gt;session_lock, flags);
-
 	return 0;
-
-out_remove_host:
-	scsi_remove_host(shost);
-out_destroy_session:
-	transport-&gt;destroy_session(ev-&gt;r.c_session_ret.session_handle);
-	ev-&gt;r.c_session_ret.session_handle = iscsi_handle(NULL);
-out_host_put:
-	scsi_host_put(shost);
-out_module_put:
-	module_put(transport-&gt;owner);
-	return error;
 }
 
 static int
 iscsi_if_destroy_session(struct iscsi_internal *priv, struct iscsi_uevent *ev)
 {
 	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
+
 	struct Scsi_Host *shost;
-	struct iscsi_if_session *session;
-	unsigned long flags;
-	struct iscsi_if_conn *conn;
-	int error = 0;
+
+	if (!transport-&gt;destroy_session)
+		return -EINVAL;
 
 	shost = scsi_host_lookup(ev-&gt;u.d_session.sid);
 	if (shost == ERR_PTR(-ENXIO))
 		return -EEXIST;
-	session = hostdata_session(shost-&gt;hostdata);
 
-	/* check if we have active connections */
-	spin_lock_irqsave(&amp;connlock, flags);
-	list_for_each_entry(conn, &amp;session-&gt;connections, session_list) {
-		if (conn-&gt;active) {
-			printk(KERN_ERR "iscsi%d: can not destroy session: "
-			       "has active connection (%p)\n",
-			       shost-&gt;host_no, iscsi_ptr(conn-&gt;connh));
-			spin_unlock_irqrestore(&amp;connlock, flags);
-			error = EIO;
-			goto out_release_ref;
-		}
-	}
-	spin_unlock_irqrestore(&amp;connlock, flags);
-
-	scsi_remove_host(shost);
-	transport-&gt;destroy_session(ev-&gt;u.d_session.session_handle);
-	transport_unregister_device(&amp;session-&gt;dev);
-	device_unregister(&amp;session-&gt;dev);
-
-	/* remove this session from the list of active sessions */
-	spin_lock_irqsave(&amp;priv-&gt;session_lock, flags);
-	list_del(&amp;session-&gt;list);
-	spin_unlock_irqrestore(&amp;priv-&gt;session_lock, flags);
-
-	/* ref from host alloc */
-	scsi_host_put(shost);
-out_release_ref:
-	/* ref from host lookup */
-	scsi_host_put(shost);
-	return error;
-}
-
-static void iscsi_if_conn_dev_release(struct device *dev)
-{
-	struct iscsi_if_conn *conn = iscsi_dev_to_if_conn(dev);
-	struct Scsi_Host *shost = conn-&gt;host;
-
-	scsi_host_put(shost);
+	if (transport-&gt;destroy_session)
+		transport-&gt;destroy_session(shost);
+        /* ref from host lookup */
+        scsi_host_put(shost);
+	return 0;
 }
 
 static int
-iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
-{
-	struct iscsi_if_session *session;
+iscsi_if_create_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev){
 	struct Scsi_Host *shost;
-	struct iscsi_if_conn *conn;
+	struct iscsi_cls_conn *conn;
 	unsigned long flags;
-	int error;
+
+	if (!transport-&gt;create_conn)
+		return -EINVAL;
 
 	shost = scsi_host_lookup(ev-&gt;u.c_conn.sid);
 	if (shost == ERR_PTR(-ENXIO))
 		return -EEXIST;
-	session = hostdata_session(shost-&gt;hostdata);
 
-	conn = kmalloc(sizeof(struct iscsi_if_conn), GFP_KERNEL);
-	if (!conn) {
-		error = -ENOMEM;
-		goto out_release_ref;
-	}
-	memset(conn, 0, sizeof(struct iscsi_if_conn));
-	INIT_LIST_HEAD(&amp;conn-&gt;session_list);
-	INIT_LIST_HEAD(&amp;conn-&gt;conn_list);
-	conn-&gt;host = shost;
-	conn-&gt;transport = transport;
+	conn = transport-&gt;create_conn(shost, ev-&gt;u.c_conn.cid);
+	if (!conn)
+		goto release_ref;
 
-	error = mempool_zone_init(&amp;conn-&gt;z_pdu, Z_MAX_PDU,
+	conn-&gt;z_pdu = mempool_zone_init(Z_MAX_PDU,
 			NLMSG_SPACE(sizeof(struct iscsi_uevent) +
 				    sizeof(struct iscsi_hdr) +
 				    DEFAULT_MAX_RECV_DATA_SEGMENT_LENGTH),
 			Z_HIWAT_PDU);
-	if (error) {
-		printk(KERN_ERR "iscsi%d: can not allocate pdu zone for new "
-		       "conn\n", shost-&gt;host_no);
-		goto out_free_conn;
+	if (!conn-&gt;z_pdu) {
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: can not allocate "
+			   "pdu zone for new conn\n");
+		goto destroy_conn;
 	}
-	error = mempool_zone_init(&amp;conn-&gt;z_error, Z_MAX_ERROR,
+
+	conn-&gt;z_error = mempool_zone_init(Z_MAX_ERROR,
 			NLMSG_SPACE(sizeof(struct iscsi_uevent)),
 			Z_HIWAT_ERROR);
-	if (error) {
-		printk(KERN_ERR "iscsi%d: can not allocate error zone for "
-		       "new conn\n", shost-&gt;host_no);
-		goto out_free_pdu_pool;
-	}
-
-	ev-&gt;r.handle = transport-&gt;create_conn(ev-&gt;u.c_conn.session_handle,
-					ev-&gt;u.c_conn.cid);
-	if (!ev-&gt;r.handle) {
-		error = -ENODEV;
-		goto out_free_error_pool;
+	if (!conn-&gt;z_error) {
+		dev_printk(KERN_ERR, &amp;conn-&gt;dev, "iscsi: can not allocate "
+			   "error zone for new conn\n");
+		goto free_pdu_pool;
 	}
 
-	conn-&gt;connh = ev-&gt;r.handle;
-
-	/*
-	 * this is released in the dev's release function
-	 */
-	if (!scsi_host_get(shost))
-		goto out_destroy_conn;
-	snprintf(conn-&gt;dev.bus_id, BUS_ID_SIZE, "connection%d:%u",
-		 shost-&gt;host_no, ev-&gt;u.c_conn.cid);
-	conn-&gt;dev.parent = &amp;session-&gt;dev;
-	conn-&gt;dev.release = iscsi_if_conn_dev_release;
-	error = device_register(&amp;conn-&gt;dev);
-	if (error) {
-		printk(KERN_ERR "iscsi%d: could not register connections%u "
-		       "dev\n", shost-&gt;host_no, ev-&gt;u.c_conn.cid);
-		goto out_release_parent_ref;
-	}
-	transport_register_device(&amp;conn-&gt;dev);
+	ev-&gt;r.handle = conn-&gt;connh = iscsi_handle(conn-&gt;dd_data);
 
 	spin_lock_irqsave(&amp;connlock, flags);
 	list_add(&amp;conn-&gt;conn_list, &amp;connlist);
-	list_add(&amp;conn-&gt;session_list, &amp;session-&gt;connections);
 	conn-&gt;active = 1;
 	spin_unlock_irqrestore(&amp;connlock, flags);
 
 	scsi_host_put(shost);
 	return 0;
 
-out_release_parent_ref:
+free_pdu_pool:
+	mempool_zone_destroy(conn-&gt;z_pdu);
+destroy_conn:
+	if (transport-&gt;destroy_conn)
+		transport-&gt;destroy_conn(conn-&gt;dd_data);
+release_ref:
 	scsi_host_put(shost);
-out_destroy_conn:
-	transport-&gt;destroy_conn(ev-&gt;r.handle);
-out_free_error_pool:
-	mempool_destroy(conn-&gt;z_error.pool);
-out_free_pdu_pool:
-	mempool_destroy(conn-&gt;z_pdu.pool);
-out_free_conn:
-	kfree(conn);
-out_release_ref:
-	scsi_host_put(shost);
-	return error;
+	return -ENOMEM;
 }
 
 static int
 iscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 {
 	unsigned long flags;
-	struct iscsi_if_conn *conn;
+	struct iscsi_cls_conn *conn;
+	struct mempool_zone *z_error, *z_pdu;
 
 	conn = iscsi_if_find_conn(ev-&gt;u.d_conn.conn_handle);
 	if (!conn)
 		return -EEXIST;
 
-	transport-&gt;destroy_conn(ev-&gt;u.d_conn.conn_handle);
+	if (!transport-&gt;destroy_conn)
+		return -EINVAL;
 
 	spin_lock_irqsave(&amp;connlock, flags);
 	conn-&gt;active = 0;
 	list_del(&amp;conn-&gt;conn_list);
 	spin_unlock_irqrestore(&amp;connlock, flags);
 
-	transport_unregister_device(&amp;conn-&gt;dev);
-	device_unregister(&amp;conn-&gt;dev);
-	return 0;
-}
-
-static int
-iscsi_if_get_stats(struct iscsi_transport *transport, struct sk_buff *skb,
-		   struct nlmsghdr *nlh)
-{
-	struct iscsi_uevent *ev = NLMSG_DATA(nlh);
-	struct iscsi_stats *stats;
-	struct sk_buff *skbstat;
-	struct iscsi_if_conn *conn;
-	struct nlmsghdr	*nlhstat;
-	struct iscsi_uevent *evstat;
-	int len = NLMSG_SPACE(sizeof(*ev) +
-			      sizeof(struct iscsi_stats) +
-			      sizeof(struct iscsi_stats_custom) *
-			      ISCSI_STATS_CUSTOM_MAX);
-	int err = 0;
-
-	conn = iscsi_if_find_conn(ev-&gt;u.get_stats.conn_handle);
-	if (!conn)
-		return -EEXIST;
-
-	do {
-		int actual_size;
-
-		mempool_zone_complete(&amp;conn-&gt;z_pdu);
-
-		skbstat = mempool_zone_get_skb(&amp;conn-&gt;z_pdu);
-		if (!skbstat) {
-			printk(KERN_ERR "iscsi%d: can not deliver stats: OOM\n",
-			       conn-&gt;host-&gt;host_no);
-			return -ENOMEM;
-		}
-
-		nlhstat = __nlmsg_put(skbstat, daemon_pid, 0, 0,
-				      (len - sizeof(*nlhstat)), 0);
-		evstat = NLMSG_DATA(nlhstat);
-		memset(evstat, 0, sizeof(*evstat));
-		evstat-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
-		evstat-&gt;type = nlh-&gt;nlmsg_type;
-		if (atomic_read(&amp;conn-&gt;z_pdu.allocated) &gt;= conn-&gt;z_pdu.hiwat)
-			evstat-&gt;iferror = -ENOMEM;
-		evstat-&gt;u.get_stats.conn_handle =
-			ev-&gt;u.get_stats.conn_handle;
-		stats = (struct iscsi_stats *)
-			((char*)evstat + sizeof(*evstat));
-		memset(stats, 0, sizeof(*stats));
+	z_pdu = conn-&gt;z_pdu;
+	z_error = conn-&gt;z_error;
 
-		transport-&gt;get_stats(ev-&gt;u.get_stats.conn_handle, stats);
-		actual_size = NLMSG_SPACE(sizeof(struct iscsi_uevent) +
-					  sizeof(struct iscsi_stats) +
-					  sizeof(struct iscsi_stats_custom) *
-					  stats-&gt;custom_length);
-		actual_size -= sizeof(*nlhstat);
-		actual_size = NLMSG_LENGTH(actual_size);
-		skb_trim(skb, NLMSG_ALIGN(actual_size));
-		nlhstat-&gt;nlmsg_len = actual_size;
+	if (transport-&gt;destroy_conn)
+		transport-&gt;destroy_conn(conn);
 
-		err = iscsi_unicast_skb(&amp;conn-&gt;z_pdu, skbstat);
-	} while (err &lt; 0 &amp;&amp; err != -ECONNREFUSED);
+	mempool_zone_destroy(z_pdu);
+	mempool_zone_destroy(z_error);
 
-	return err;
+	return 0;
 }
 
 static int
@@ -916,8 +971,8 @@ iscsi_if_rx(struct sock *sk, int len)
 				err = iscsi_if_send_reply(
 					NETLINK_CREDS(skb)-&gt;pid, nlh-&gt;nlmsg_seq,
 					nlh-&gt;nlmsg_type, 0, 0, ev, sizeof(*ev));
-				if (atomic_read(&amp;z_reply.allocated) &gt;=
-						z_reply.hiwat)
+				if (atomic_read(&amp;z_reply-&gt;allocated) &gt;=
+						z_reply-&gt;hiwat)
 					ev-&gt;iferror = -ENOMEM;
 			} while (err &lt; 0 &amp;&amp; err != -ECONNREFUSED);
 			skb_pull(skb, rlen);
@@ -927,6 +982,9 @@ iscsi_if_rx(struct sock *sk, int len)
 	mutex_unlock(&amp;rx_queue_mutex);
 }
 
+#define iscsi_cdev_to_conn(_cdev) \
+	iscsi_dev_to_conn(_cdev-&gt;dev)
+
 /*
  * iSCSI connection attrs
  */
@@ -935,12 +993,10 @@ static ssize_t								\
 show_conn_int_param_##param(struct class_device *cdev, char *buf)	\
 {									\
 	uint32_t value = 0;						\
-	struct iscsi_if_conn *conn = iscsi_cdev_to_if_conn(cdev);	\
-	struct iscsi_internal *priv;					\
+	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
+	struct iscsi_transport *t = conn-&gt;transport;			\
 									\
-	priv = to_iscsi_internal(conn-&gt;host-&gt;transportt);		\
-	if (priv-&gt;param_mask &amp; (1 &lt;&lt; param))				\
-		priv-&gt;iscsi_transport-&gt;get_param(conn-&gt;connh, param, &amp;value); \
+	t-&gt;get_conn_param(conn-&gt;dd_data, param, &amp;value);		\
 	return snprintf(buf, 20, format"\n", value);			\
 }
 
@@ -955,6 +1011,9 @@ iscsi_conn_int_attr(data_digest, ISCSI_PARAM_DATADGST_EN, "%d");
 iscsi_conn_int_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN, "%d");
 iscsi_conn_int_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN, "%d");
 
+#define iscsi_cdev_to_session(_cdev) \
+	iscsi_dev_to_session(_cdev-&gt;dev)
+
 /*
  * iSCSI session attrs
  */
@@ -963,20 +1022,11 @@ static ssize_t								\
 show_session_int_param_##param(struct class_device *cdev, char *buf)	\
 {									\
 	uint32_t value = 0;						\
-	struct iscsi_if_session *session = iscsi_cdev_to_if_session(cdev); \
-	struct Scsi_Host *shost = iscsi_if_session_to_shost(session);	\
-	struct iscsi_internal *priv = to_iscsi_internal(shost-&gt;transportt); \
-	struct iscsi_if_conn *conn = NULL;				\
-	unsigned long  flags;						\
-									\
-	spin_lock_irqsave(&amp;connlock, flags);				\
-	if (!list_empty(&amp;session-&gt;connections))				\
-		conn = list_entry(session-&gt;connections.next,		\
-				  struct iscsi_if_conn, session_list);	\
-	spin_unlock_irqrestore(&amp;connlock, flags);			\
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev);	\
+	struct Scsi_Host *shost = iscsi_session_to_shost(session);	\
+	struct iscsi_transport *t = session-&gt;transport;			\
 									\
-	if (conn &amp;&amp; (priv-&gt;param_mask &amp; (1 &lt;&lt; param)))			\
-		priv-&gt;iscsi_transport-&gt;get_param(conn-&gt;connh, param, &amp;value);\
+	t-&gt;get_session_param(shost, param, &amp;value);			\
 	return snprintf(buf, 20, format"\n", value);			\
 }
 
@@ -1005,23 +1055,18 @@ iscsi_session_int_attr(erl, ISCSI_PARAM_ERL, "%d");
 		count++;						\
 	}
 
-static int iscsi_is_session_dev(const struct device *dev)
-{
-	return dev-&gt;release == iscsi_if_session_dev_release;
-}
-
 static int iscsi_session_match(struct attribute_container *cont,
 			   struct device *dev)
 {
-	struct iscsi_if_session *session;
+	struct iscsi_cls_session *session;
 	struct Scsi_Host *shost;
 	struct iscsi_internal *priv;
 
 	if (!iscsi_is_session_dev(dev))
 		return 0;
 
-	session = iscsi_dev_to_if_session(dev);
-	shost = iscsi_if_session_to_shost(session);
+	session = iscsi_dev_to_session(dev);
+	shost = iscsi_session_to_shost(session);
 	if (!shost-&gt;transportt)
 		return 0;
 
@@ -1032,23 +1077,21 @@ static int iscsi_session_match(struct attribute_container *cont,
 	return &amp;priv-&gt;session_cont.ac == cont;
 }
 
-static int iscsi_is_conn_dev(const struct device *dev)
-{
-	return dev-&gt;release == iscsi_if_conn_dev_release;
-}
-
 static int iscsi_conn_match(struct attribute_container *cont,
 			   struct device *dev)
 {
-	struct iscsi_if_conn *conn;
+	struct iscsi_cls_session *session;
+	struct iscsi_cls_conn *conn;
 	struct Scsi_Host *shost;
 	struct iscsi_internal *priv;
 
 	if (!iscsi_is_conn_dev(dev))
 		return 0;
 
-	conn = iscsi_dev_to_if_conn(dev);
-	shost = conn-&gt;host;
+	conn = iscsi_dev_to_conn(dev);
+	session = iscsi_dev_to_session(conn-&gt;dev.parent);
+	shost = iscsi_session_to_shost(session);
+
 	if (!shost-&gt;transportt)
 		return 0;
 
@@ -1059,7 +1102,8 @@ static int iscsi_conn_match(struct attribute_container *cont,
 	return &amp;priv-&gt;conn_cont.ac == cont;
 }
 
-int iscsi_register_transport(struct iscsi_transport *tt)
+struct scsi_transport_template *
+iscsi_register_transport(struct iscsi_transport *tt)
 {
 	struct iscsi_internal *priv;
 	unsigned long flags;
@@ -1069,15 +1113,14 @@ int iscsi_register_transport(struct iscsi_transport *tt)
 
 	priv = iscsi_if_transport_lookup(tt);
 	if (priv)
-		return -EEXIST;
+		return NULL;
 
 	priv = kmalloc(sizeof(*priv), GFP_KERNEL);
 	if (!priv)
-		return -ENOMEM;
+		return NULL;
 	memset(priv, 0, sizeof(*priv));
 	INIT_LIST_HEAD(&amp;priv-&gt;list);
 	INIT_LIST_HEAD(&amp;priv-&gt;sessions);
-	spin_lock_init(&amp;priv-&gt;session_lock);
 	priv-&gt;iscsi_transport = tt;
 
 	priv-&gt;cdev.class = &amp;iscsi_transport_class;
@@ -1143,13 +1186,13 @@ int iscsi_register_transport(struct iscsi_transport *tt)
 	spin_unlock_irqrestore(&amp;iscsi_transport_lock, flags);
 
 	printk(KERN_NOTICE "iscsi: registered transport (%s)\n", tt-&gt;name);
-	return 0;
+	return &amp;priv-&gt;t;
 
 unregister_cdev:
 	class_device_unregister(&amp;priv-&gt;cdev);
 free_priv:
 	kfree(priv);
-	return err;
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(iscsi_register_transport);
 
@@ -1165,14 +1208,6 @@ int iscsi_unregister_transport(struct iscsi_transport *tt)
 	priv = iscsi_if_transport_lookup(tt);
 	BUG_ON (!priv);
 
-	spin_lock_irqsave(&amp;priv-&gt;session_lock, flags);
-	if (!list_empty(&amp;priv-&gt;sessions)) {
-		spin_unlock_irqrestore(&amp;priv-&gt;session_lock, flags);
-		mutex_unlock(&amp;rx_queue_mutex);
-		return -EPERM;
-	}
-	spin_unlock_irqrestore(&amp;priv-&gt;session_lock, flags);
-
 	spin_lock_irqsave(&amp;iscsi_transport_lock, flags);
 	list_del(&amp;priv-&gt;list);
 	spin_unlock_irqrestore(&amp;iscsi_transport_lock, flags);
@@ -1195,14 +1230,14 @@ iscsi_rcv_nl_event(struct notifier_block *this, unsigned long event, void *ptr)
 
 	if (event == NETLINK_URELEASE &amp;&amp;
 	    n-&gt;protocol == NETLINK_ISCSI &amp;&amp; n-&gt;pid) {
-		struct iscsi_if_conn *conn;
+		struct iscsi_cls_conn *conn;
 		unsigned long flags;
 
-		mempool_zone_complete(&amp;z_reply);
+		mempool_zone_complete(z_reply);
 		spin_lock_irqsave(&amp;connlock, flags);
 		list_for_each_entry(conn, &amp;connlist, conn_list) {
-			mempool_zone_complete(&amp;conn-&gt;z_error);
-			mempool_zone_complete(&amp;conn-&gt;z_pdu);
+			mempool_zone_complete(conn-&gt;z_error);
+			mempool_zone_complete(conn-&gt;z_pdu);
 		}
 		spin_unlock_irqrestore(&amp;connlock, flags);
 	}
@@ -1235,15 +1270,15 @@ static __init int iscsi_transport_init(void)
 		goto unregister_session_class;
 
 	nls = netlink_kernel_create(NETLINK_ISCSI, 1, iscsi_if_rx,
-				    THIS_MODULE);
+			THIS_MODULE);
 	if (!nls) {
 		err = -ENOBUFS;
 		goto unregister_notifier;
 	}
 
-	err = mempool_zone_init(&amp;z_reply, Z_MAX_REPLY,
+	z_reply = mempool_zone_init(Z_MAX_REPLY,
 		NLMSG_SPACE(sizeof(struct iscsi_uevent)), Z_HIWAT_REPLY);
-	if (!err)
+	if (z_reply)
 		return 0;
 
 	sock_release(nls-&gt;sk_socket);
@@ -1260,7 +1295,7 @@ static __init int iscsi_transport_init(void)
 
 static void __exit iscsi_transport_exit(void)
 {
-	mempool_destroy(z_reply.pool);
+	mempool_zone_destroy(z_reply);
 	sock_release(nls-&gt;sk_socket);
 	netlink_unregister_notifier(&amp;iscsi_nl_notifier);
 	transport_class_unregister(&amp;iscsi_connection_class);
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index be1bc792ab18..3e5cb5ab2d34 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -168,6 +168,12 @@ typedef uint64_t iscsi_connh_t;		/* iSCSI Data-Path connection handle */
 
 #define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
 #define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
+#define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
+
+/**
+ * iscsi_hostdata - get LLD hostdata from scsi_host
+ * @_hostdata: pointer to scsi host's hostdata
+ **/
 #define iscsi_hostdata(_hostdata) ((void*)_hostdata + sizeof(unsigned long))
 
 /*
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index f25041c386ec..16602a547a63 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -23,8 +23,14 @@
 #ifndef SCSI_TRANSPORT_ISCSI_H
 #define SCSI_TRANSPORT_ISCSI_H
 
+#include &lt;linux/device.h&gt;
 #include &lt;scsi/iscsi_if.h&gt;
 
+struct scsi_transport_template;
+struct Scsi_Host;
+struct mempool_zone;
+struct iscsi_cls_conn;
+
 /**
  * struct iscsi_transport - iSCSI Transport template
  *
@@ -48,23 +54,31 @@ struct iscsi_transport {
 	char *name;
 	unsigned int caps;
 	struct scsi_host_template *host_template;
+	/* LLD session/scsi_host data size */
 	int hostdata_size;
+	/* LLD iscsi_host data size */
+	int ihostdata_size;
+	/* LLD connection data size */
+	int conndata_size;
 	int max_lun;
 	unsigned int max_conn;
 	unsigned int max_cmd_len;
-	iscsi_sessionh_t (*create_session) (uint32_t initial_cmdsn,
-					    struct Scsi_Host *shost);
-	void (*destroy_session) (iscsi_sessionh_t session);
-	iscsi_connh_t (*create_conn) (iscsi_sessionh_t session, uint32_t cid);
+	struct Scsi_Host *(*create_session) (struct scsi_transport_template *t,
+					     uint32_t initial_cmdsn);
+	void (*destroy_session) (struct Scsi_Host *shost);
+	struct iscsi_cls_conn *(*create_conn) (struct Scsi_Host *shost,
+				uint32_t cid);
 	int (*bind_conn) (iscsi_sessionh_t session, iscsi_connh_t conn,
 			  uint32_t transport_fd, int is_leading);
 	int (*start_conn) (iscsi_connh_t conn);
 	void (*stop_conn) (iscsi_connh_t conn, int flag);
-	void (*destroy_conn) (iscsi_connh_t conn);
+	void (*destroy_conn) (struct iscsi_cls_conn *conn);
 	int (*set_param) (iscsi_connh_t conn, enum iscsi_param param,
 			  uint32_t value);
-	int (*get_param) (iscsi_connh_t conn, enum iscsi_param param,
-			  uint32_t *value);
+	int (*get_conn_param) (void *conndata, enum iscsi_param param,
+			       uint32_t *value);
+	int (*get_session_param) (struct Scsi_Host *shost,
+				  enum iscsi_param param, uint32_t *value);
 	int (*send_pdu) (iscsi_connh_t conn, struct iscsi_hdr *hdr,
 			 char *data, uint32_t data_size);
 	void (*get_stats) (iscsi_connh_t conn, struct iscsi_stats *stats);
@@ -73,7 +87,7 @@ struct iscsi_transport {
 /*
  * transport registration upcalls
  */
-extern int iscsi_register_transport(struct iscsi_transport *tt);
+extern struct scsi_transport_template *iscsi_register_transport(struct iscsi_transport *tt);
 extern int iscsi_unregister_transport(struct iscsi_transport *tt);
 
 /*
@@ -83,4 +97,49 @@ extern void iscsi_conn_error(iscsi_connh_t conn, enum iscsi_err error);
 extern int iscsi_recv_pdu(iscsi_connh_t conn, struct iscsi_hdr *hdr,
 			  char *data, uint32_t data_size);
 
+struct iscsi_cls_conn {
+	struct list_head conn_list;	/* item in connlist */
+	void *dd_data;			/* LLD private data */
+	struct iscsi_transport *transport;
+	iscsi_connh_t connh;
+	int active;			/* must be accessed with the connlock */
+	struct device dev;		/* sysfs transport/container device */
+	struct mempool_zone *z_error;
+	struct mempool_zone *z_pdu;
+	struct list_head freequeue;
+};
+
+#define iscsi_dev_to_conn(_dev) \
+	container_of(_dev, struct iscsi_cls_conn, dev)
+
+struct iscsi_cls_session {
+	struct list_head list;	/* item in session_list */
+	struct iscsi_transport *transport;
+	struct device dev;	/* sysfs transport/container device */
+};
+
+#define iscsi_dev_to_session(_dev) \
+	container_of(_dev, struct iscsi_cls_session, dev)
+
+#define iscsi_session_to_shost(_session) \
+	dev_to_shost(_session-&gt;dev.parent)
+
+/*
+ * session and connection functions that can be used by HW iSCSI LLDs
+ */
+extern struct iscsi_cls_session *iscsi_create_session(struct Scsi_Host *shost,
+				struct iscsi_transport *t);
+extern int iscsi_destroy_session(struct iscsi_cls_session *session);
+extern struct iscsi_cls_conn *iscsi_create_conn(struct iscsi_cls_session *sess,
+					    uint32_t cid);
+extern int iscsi_destroy_conn(struct iscsi_cls_conn *conn);
+
+/*
+ * session functions used by software iscsi
+ */
+extern struct Scsi_Host *
+iscsi_transport_create_session(struct scsi_transport_template *scsit,
+                               struct iscsi_transport *transport);
+extern int iscsi_transport_destroy_session(struct Scsi_Host *shost);
+
 #endif</pre><hr><pre>commit 7cae5159dd2623300cf9820865bfbf6dcdb7c1b9
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Jan 13 18:05:47 2006 -0600

    [SCSI] iscsi: add high mem support
    
    From Mike Christie &lt;michaelc@cs.wisc.edu&gt; and FUJITA Tomonori &lt;tomof@acm.org&gt;:
    
    We cannot use page_address becuase some pages could be highmem.
    Instead, we can use sock_no_sendpage which does kmap for us.
    
    Signed-off-by: Alex Aizman &lt;itn780@yahoo.com&gt;
    Signed-off-by: Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 5e8b3135574c..0acc4b235d9b 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -87,35 +87,32 @@ iscsi_buf_init_virt(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
 	sg_init_one(&amp;ibuf-&gt;sg, (u8 *)vbuf, size);
 	ibuf-&gt;sent = 0;
+	ibuf-&gt;use_sendmsg = 0;
 }
 
 static inline void
 iscsi_buf_init_iov(struct iscsi_buf *ibuf, char *vbuf, int size)
 {
-	ibuf-&gt;sg.page = (void*)vbuf;
-	ibuf-&gt;sg.offset = (unsigned int)-1;
+	ibuf-&gt;sg.page = virt_to_page(vbuf);
+	ibuf-&gt;sg.offset = offset_in_page(vbuf);
 	ibuf-&gt;sg.length = size;
 	ibuf-&gt;sent = 0;
-}
-
-static inline void*
-iscsi_buf_iov_base(struct iscsi_buf *ibuf)
-{
-	return (char*)ibuf-&gt;sg.page + ibuf-&gt;sent;
+	ibuf-&gt;use_sendmsg = 1;
 }
 
 static inline void
 iscsi_buf_init_sg(struct iscsi_buf *ibuf, struct scatterlist *sg)
 {
+	ibuf-&gt;sg.page = sg-&gt;page;
+	ibuf-&gt;sg.offset = sg-&gt;offset;
+	ibuf-&gt;sg.length = sg-&gt;length;
 	/*
 	 * Fastpath: sg element fits into single page
 	 */
-	if (sg-&gt;length + sg-&gt;offset &lt;= PAGE_SIZE &amp;&amp; page_count(sg-&gt;page) &gt;= 2) {
-		ibuf-&gt;sg.page = sg-&gt;page;
-		ibuf-&gt;sg.offset = sg-&gt;offset;
-		ibuf-&gt;sg.length = sg-&gt;length;
-	} else
-		iscsi_buf_init_iov(ibuf, page_address(sg-&gt;page), sg-&gt;length);
+	if (sg-&gt;length + sg-&gt;offset &lt;= PAGE_SIZE &amp;&amp; page_count(sg-&gt;page) &gt;= 2)
+		ibuf-&gt;use_sendmsg = 0;
+	else
+		ibuf-&gt;use_sendmsg = 1;
 	ibuf-&gt;sent = 0;
 }
 
@@ -1311,35 +1308,25 @@ iscsi_conn_restore_callbacks(struct iscsi_conn *conn)
  * @buf: buffer to write from
  * @size: actual size to write
  * @flags: socket's flags
- *
- * Notes:
- *	depending on buffer will use tcp_sendpage() or tcp_sendmsg().
- *	buf-&gt;sg.offset == -1 tells us that buffer is non S/G and forces
- *	to use tcp_sendmsg().
  */
 static inline int
 iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
 {
 	struct socket *sk = conn-&gt;sock;
-	int res;
-
-	if ((int)buf-&gt;sg.offset &gt;= 0) {
-		int offset = buf-&gt;sg.offset + buf-&gt;sent;
-
-		res = conn-&gt;sendpage(sk, buf-&gt;sg.page, offset, size, flags);
-	} else {
-		struct msghdr msg;
-
-		buf-&gt;iov.iov_base = iscsi_buf_iov_base(buf);
-		buf-&gt;iov.iov_len = size;
-
-		memset(&amp;msg, 0, sizeof(struct msghdr));
-
-		/* tcp_sendmsg */
-		res = kernel_sendmsg(sk, &amp;msg, &amp;buf-&gt;iov, 1, size);
-	}
+	int offset = buf-&gt;sg.offset + buf-&gt;sent;
 
-	return res;
+	/*
+	 * if we got use_sg=0 or are sending something we kmallocd
+	 * then we did not have to do kmap (kmap returns page_address)
+	 *
+	 * if we got use_sg &gt; 0, but had to drop down, we do not
+	 * set clustering so this should only happen for that
+	 * slab case.
+	 */
+	if (buf-&gt;use_sendmsg)
+		return sock_no_sendpage(sk, buf-&gt;sg.page, offset, size, flags);
+	else
+		return conn-&gt;sendpage(sk, buf-&gt;sg.page, offset, size, flags);
 }
 
 /**
@@ -1431,19 +1418,6 @@ iscsi_data_digest_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	ctask-&gt;digest_count = 4;
 }
 
-static inline void
-iscsi_buf_data_digest_update(struct iscsi_conn *conn, struct iscsi_buf *buf)
-{
-	struct scatterlist sg;
-
-	if (buf-&gt;sg.offset != -1)
-		crypto_digest_update(conn-&gt;data_tx_tfm, &amp;buf-&gt;sg, 1);
-	else {
-		sg_init_one(&amp;sg, (char *)buf-&gt;sg.page, buf-&gt;sg.length);
-		crypto_digest_update(conn-&gt;data_tx_tfm, &amp;sg, 1);
-	}
-}
-
 static inline int
 iscsi_digest_final_send(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 			struct iscsi_buf *buf, uint32_t *digest, int final)
@@ -1806,7 +1780,8 @@ handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 			return -EAGAIN;
 		}
 		if (conn-&gt;datadgst_en)
-			iscsi_buf_data_digest_update(conn, &amp;ctask-&gt;sendbuf);
+			crypto_digest_update(conn-&gt;data_tx_tfm,
+					     &amp;ctask-&gt;sendbuf.sg, 1);
 
 		if (!ctask-&gt;imm_count)
 			break;
@@ -1891,7 +1866,8 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		 * so pass it
 		 */
 		if (conn-&gt;datadgst_en &amp;&amp; ctask-&gt;sent - start &gt; 0)
-			iscsi_buf_data_digest_update(conn, &amp;ctask-&gt;sendbuf);
+			crypto_digest_update(conn-&gt;data_tx_tfm,
+					     &amp;ctask-&gt;sendbuf.sg, 1);
 
 		if (!ctask-&gt;data_count)
 			break;
@@ -1969,7 +1945,7 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 	BUG_ON(r2t-&gt;data_count &lt; 0);
 	if (conn-&gt;datadgst_en)
-		iscsi_buf_data_digest_update(conn, &amp;r2t-&gt;sendbuf);
+		crypto_digest_update(conn-&gt;data_tx_tfm, &amp;r2t-&gt;sendbuf.sg, 1);
 
 	if (r2t-&gt;data_count) {
 		BUG_ON(ctask-&gt;sc-&gt;use_sg == 0);
@@ -2051,7 +2027,7 @@ handle_xmstate_w_pad(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	}
 
 	if (conn-&gt;datadgst_en) {
-		iscsi_buf_data_digest_update(conn, &amp;ctask-&gt;sendbuf);
+		crypto_digest_update(conn-&gt;data_tx_tfm, &amp;ctask-&gt;sendbuf.sg, 1);
 		/* imm data? */
 		if (!dtask) {
 			if (iscsi_digest_final_send(conn, ctask, &amp;ctask-&gt;immbuf,
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index c8bb5b0bcb4b..f95e61b76f70 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -242,8 +242,8 @@ struct iscsi_session {
 
 struct iscsi_buf {
 	struct scatterlist	sg;
-	struct kvec		iov;
 	unsigned int		sent;
+	char			use_sendmsg;
 };
 
 struct iscsi_data_task {</pre><hr><pre>commit defd94b75409b983f94548ea2f52ff5787ddb848
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Dec 5 02:37:06 2005 -0600

    [SCSI] seperate max_sectors from max_hw_sectors
    
    - export __blk_put_request and blk_execute_rq_nowait
    needed for async REQ_BLOCK_PC requests
    - seperate max_hw_sectors and max_sectors for block/scsi_ioctl.c and
    SG_IO bio.c helpers per Jens's last comments. Since block/scsi_ioctl.c SG_IO was
    already testing against max_sectors and SCSI-ml was setting max_sectors and
    max_hw_sectors to the same value this does not change any scsi SG_IO behavior. It only
    prepares ll_rw_blk.c, scsi_ioctl.c and bio.c for when SCSI-ml begins to set
    a valid max_hw_sectors for all LLDs. Today if a LLD does not set it
    SCSI-ml sets it to a safe default and some LLDs set it to a artificial low
    value to overcome memory and feedback issues.
    
    Note: Since we now cap max_sectors to BLK_DEF_MAX_SECTORS, which is 1024,
    drivers that used to call blk_queue_max_sectors with a large value of
    max_sectors will now see the fs requests capped to BLK_DEF_MAX_SECTORS.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/block/ll_rw_blk.c b/block/ll_rw_blk.c
index c525b5a2b598..d4beb9a89ee0 100644
--- a/block/ll_rw_blk.c
+++ b/block/ll_rw_blk.c
@@ -239,7 +239,7 @@ void blk_queue_make_request(request_queue_t * q, make_request_fn * mfn)
 	q-&gt;backing_dev_info.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;
 	q-&gt;backing_dev_info.state = 0;
 	q-&gt;backing_dev_info.capabilities = BDI_CAP_MAP_COPY;
-	blk_queue_max_sectors(q, MAX_SECTORS);
+	blk_queue_max_sectors(q, SAFE_MAX_SECTORS);
 	blk_queue_hardsect_size(q, 512);
 	blk_queue_dma_alignment(q, 511);
 	blk_queue_congestion_threshold(q);
@@ -555,7 +555,12 @@ void blk_queue_max_sectors(request_queue_t *q, unsigned short max_sectors)
 		printk("%s: set to minimum %d\n", __FUNCTION__, max_sectors);
 	}
 
-	q-&gt;max_sectors = q-&gt;max_hw_sectors = max_sectors;
+	if (BLK_DEF_MAX_SECTORS &gt; max_sectors)
+		q-&gt;max_hw_sectors = q-&gt;max_sectors = max_sectors;
+ 	else {
+		q-&gt;max_sectors = BLK_DEF_MAX_SECTORS;
+		q-&gt;max_hw_sectors = max_sectors;
+	}
 }
 
 EXPORT_SYMBOL(blk_queue_max_sectors);
@@ -657,8 +662,8 @@ EXPORT_SYMBOL(blk_queue_hardsect_size);
 void blk_queue_stack_limits(request_queue_t *t, request_queue_t *b)
 {
 	/* zero is "infinity" */
-	t-&gt;max_sectors = t-&gt;max_hw_sectors =
-		min_not_zero(t-&gt;max_sectors,b-&gt;max_sectors);
+	t-&gt;max_sectors = min_not_zero(t-&gt;max_sectors,b-&gt;max_sectors);
+	t-&gt;max_hw_sectors = min_not_zero(t-&gt;max_hw_sectors,b-&gt;max_hw_sectors);
 
 	t-&gt;max_phys_segments = min(t-&gt;max_phys_segments,b-&gt;max_phys_segments);
 	t-&gt;max_hw_segments = min(t-&gt;max_hw_segments,b-&gt;max_hw_segments);
@@ -1293,9 +1298,15 @@ static inline int ll_new_hw_segment(request_queue_t *q,
 static int ll_back_merge_fn(request_queue_t *q, struct request *req, 
 			    struct bio *bio)
 {
+	unsigned short max_sectors;
 	int len;
 
-	if (req-&gt;nr_sectors + bio_sectors(bio) &gt; q-&gt;max_sectors) {
+	if (unlikely(blk_pc_request(req)))
+		max_sectors = q-&gt;max_hw_sectors;
+	else
+		max_sectors = q-&gt;max_sectors;
+
+	if (req-&gt;nr_sectors + bio_sectors(bio) &gt; max_sectors) {
 		req-&gt;flags |= REQ_NOMERGE;
 		if (req == q-&gt;last_merge)
 			q-&gt;last_merge = NULL;
@@ -1325,9 +1336,16 @@ static int ll_back_merge_fn(request_queue_t *q, struct request *req,
 static int ll_front_merge_fn(request_queue_t *q, struct request *req, 
 			     struct bio *bio)
 {
+	unsigned short max_sectors;
 	int len;
 
-	if (req-&gt;nr_sectors + bio_sectors(bio) &gt; q-&gt;max_sectors) {
+	if (unlikely(blk_pc_request(req)))
+		max_sectors = q-&gt;max_hw_sectors;
+	else
+		max_sectors = q-&gt;max_sectors;
+
+
+	if (req-&gt;nr_sectors + bio_sectors(bio) &gt; max_sectors) {
 		req-&gt;flags |= REQ_NOMERGE;
 		if (req == q-&gt;last_merge)
 			q-&gt;last_merge = NULL;
@@ -2144,7 +2162,7 @@ int blk_rq_map_user(request_queue_t *q, struct request *rq, void __user *ubuf,
 	struct bio *bio;
 	int reading;
 
-	if (len &gt; (q-&gt;max_sectors &lt;&lt; 9))
+	if (len &gt; (q-&gt;max_hw_sectors &lt;&lt; 9))
 		return -EINVAL;
 	if (!len || !ubuf)
 		return -EINVAL;
@@ -2259,7 +2277,7 @@ int blk_rq_map_kern(request_queue_t *q, struct request *rq, void *kbuf,
 {
 	struct bio *bio;
 
-	if (len &gt; (q-&gt;max_sectors &lt;&lt; 9))
+	if (len &gt; (q-&gt;max_hw_sectors &lt;&lt; 9))
 		return -EINVAL;
 	if (!len || !kbuf)
 		return -EINVAL;
diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
index 382dea7b224c..4e390dfd3157 100644
--- a/block/scsi_ioctl.c
+++ b/block/scsi_ioctl.c
@@ -233,7 +233,7 @@ static int sg_io(struct file *file, request_queue_t *q,
 	if (verify_command(file, cmd))
 		return -EPERM;
 
-	if (hdr-&gt;dxfer_len &gt; (q-&gt;max_sectors &lt;&lt; 9))
+	if (hdr-&gt;dxfer_len &gt; (q-&gt;max_hw_sectors &lt;&lt; 9))
 		return -EIO;
 
 	if (hdr-&gt;dxfer_len)
diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c
index a6d3baa46f61..a6f2dc66c3db 100644
--- a/drivers/md/dm-table.c
+++ b/drivers/md/dm-table.c
@@ -638,7 +638,7 @@ int dm_split_args(int *argc, char ***argvp, char *input)
 static void check_for_valid_limits(struct io_restrictions *rs)
 {
 	if (!rs-&gt;max_sectors)
-		rs-&gt;max_sectors = MAX_SECTORS;
+		rs-&gt;max_sectors = SAFE_MAX_SECTORS;
 	if (!rs-&gt;max_phys_segments)
 		rs-&gt;max_phys_segments = MAX_PHYS_SEGMENTS;
 	if (!rs-&gt;max_hw_segments)
diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 54a72f197487..14ad2a785a34 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -462,6 +462,7 @@ int scsi_execute_async(struct scsi_device *sdev, const unsigned char *cmd,
 	req = blk_get_request(sdev-&gt;request_queue, write, gfp);
 	if (!req)
 		goto free_sense;
+	req-&gt;flags |= REQ_BLOCK_PC | REQ_QUIET;
 
 	if (use_sg)
 		err = scsi_req_map_sg(req, buffer, use_sg, bufflen, gfp);
@@ -477,7 +478,6 @@ int scsi_execute_async(struct scsi_device *sdev, const unsigned char *cmd,
 	req-&gt;sense_len = 0;
 	req-&gt;timeout = timeout;
 	req-&gt;retries = retries;
-	req-&gt;flags |= REQ_BLOCK_PC | REQ_QUIET;
 	req-&gt;end_io_data = sioc;
 
 	sioc-&gt;data = privdata;
diff --git a/fs/bio.c b/fs/bio.c
index 4d21ee3873ec..38d3e8023a07 100644
--- a/fs/bio.c
+++ b/fs/bio.c
@@ -313,7 +313,8 @@ int bio_get_nr_vecs(struct block_device *bdev)
 }
 
 static int __bio_add_page(request_queue_t *q, struct bio *bio, struct page
-			  *page, unsigned int len, unsigned int offset)
+			  *page, unsigned int len, unsigned int offset,
+			  unsigned short max_sectors)
 {
 	int retried_segments = 0;
 	struct bio_vec *bvec;
@@ -327,7 +328,7 @@ static int __bio_add_page(request_queue_t *q, struct bio *bio, struct page
 	if (bio-&gt;bi_vcnt &gt;= bio-&gt;bi_max_vecs)
 		return 0;
 
-	if (((bio-&gt;bi_size + len) &gt;&gt; 9) &gt; q-&gt;max_sectors)
+	if (((bio-&gt;bi_size + len) &gt;&gt; 9) &gt; max_sectors)
 		return 0;
 
 	/*
@@ -401,7 +402,7 @@ static int __bio_add_page(request_queue_t *q, struct bio *bio, struct page
 int bio_add_pc_page(request_queue_t *q, struct bio *bio, struct page *page,
 		    unsigned int len, unsigned int offset)
 {
-	return __bio_add_page(q, bio, page, len, offset);
+	return __bio_add_page(q, bio, page, len, offset, q-&gt;max_hw_sectors);
 }
 
 /**
@@ -420,8 +421,8 @@ int bio_add_pc_page(request_queue_t *q, struct bio *bio, struct page *page,
 int bio_add_page(struct bio *bio, struct page *page, unsigned int len,
 		 unsigned int offset)
 {
-	return __bio_add_page(bdev_get_queue(bio-&gt;bi_bdev), bio, page,
-			      len, offset);
+	struct request_queue *q = bdev_get_queue(bio-&gt;bi_bdev);
+	return __bio_add_page(q, bio, page, len, offset, q-&gt;max_sectors);
 }
 
 struct bio_map_data {
@@ -533,7 +534,7 @@ struct bio *bio_copy_user(request_queue_t *q, unsigned long uaddr,
 			break;
 		}
 
-		if (__bio_add_page(q, bio, page, bytes, 0) &lt; bytes) {
+		if (bio_add_pc_page(q, bio, page, bytes, 0) &lt; bytes) {
 			ret = -EINVAL;
 			break;
 		}
@@ -647,7 +648,8 @@ static struct bio *__bio_map_user_iov(request_queue_t *q,
 			/*
 			 * sorry...
 			 */
-			if (__bio_add_page(q, bio, pages[j], bytes, offset) &lt; bytes)
+			if (bio_add_pc_page(q, bio, pages[j], bytes, offset) &lt;
+					    bytes)
 				break;
 
 			len -= bytes;
@@ -820,8 +822,8 @@ static struct bio *__bio_map_kern(request_queue_t *q, void *data,
 		if (bytes &gt; len)
 			bytes = len;
 
-		if (__bio_add_page(q, bio, virt_to_page(data), bytes,
-				   offset) &lt; bytes)
+		if (bio_add_pc_page(q, bio, virt_to_page(data), bytes,
+				    offset) &lt; bytes)
 			break;
 
 		data += bytes;
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 509e9a03a328..a18500d196e1 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -702,7 +702,8 @@ extern int blkdev_issue_flush(struct block_device *, sector_t *);
 
 #define MAX_PHYS_SEGMENTS 128
 #define MAX_HW_SEGMENTS 128
-#define MAX_SECTORS 255
+#define SAFE_MAX_SECTORS 255
+#define BLK_DEF_MAX_SECTORS 1024
 
 #define MAX_SEGMENT_SIZE	65536
 </pre><hr><pre>commit 8b05b773b6030de5b1bab1cbb0bf1ff8c34cdbe0
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Nov 8 04:06:44 2005 -0600

    [SCSI] convert st to use scsi_execute_async
    
    convert st to always send scatterlists and kill scsi_request
    usage.
    
    This is the same as last time as it was posted, but with Kai's patches
    merged and we now pass the bytes value to scsi_execute_async.
    
    TODO:
    
    - move DIO code to common place or make block layers usable for ULDs.
    - move buffer allocation code to common place for all ULDs to use. And
    make buffer allocation code handle all queue limits so we can find
    out about problems before calling scsi_execute_async.
    - move indirect (copy_to/from_user) paths commone place or make block
    layers usable for ULDs.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c
index 053444b027d4..26e13dc7bcdb 100644
--- a/drivers/scsi/st.c
+++ b/drivers/scsi/st.c
@@ -50,7 +50,6 @@ static const char *verstr = "20050830";
 #include &lt;scsi/scsi_eh.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
 #include &lt;scsi/scsi_ioctl.h&gt;
-#include &lt;scsi/scsi_request.h&gt;
 #include &lt;scsi/sg.h&gt;
 
 
@@ -188,8 +187,6 @@ static int from_buffer(struct st_buffer *, char __user *, int);
 static void move_buffer_data(struct st_buffer *, int);
 static void buf_to_sg(struct st_buffer *, unsigned int);
 
-static int st_map_user_pages(struct scatterlist *, const unsigned int, 
-			     unsigned long, size_t, int, unsigned long);
 static int sgl_map_user_pages(struct scatterlist *, const unsigned int, 
 			      unsigned long, size_t, int);
 static int sgl_unmap_user_pages(struct scatterlist *, const unsigned int, int);
@@ -313,12 +310,13 @@ static inline char *tape_name(struct scsi_tape *tape)
 }
 
 
-static void st_analyze_sense(struct scsi_request *SRpnt, struct st_cmdstatus *s)
+static void st_analyze_sense(struct st_request *SRpnt, struct st_cmdstatus *s)
 {
 	const u8 *ucp;
-	const u8 *sense = SRpnt-&gt;sr_sense_buffer;
+	const u8 *sense = SRpnt-&gt;sense;
 
-	s-&gt;have_sense = scsi_request_normalize_sense(SRpnt, &amp;s-&gt;sense_hdr);
+	s-&gt;have_sense = scsi_normalize_sense(SRpnt-&gt;sense,
+				SCSI_SENSE_BUFFERSIZE, &amp;s-&gt;sense_hdr);
 	s-&gt;flags = 0;
 
 	if (s-&gt;have_sense) {
@@ -345,9 +343,9 @@ static void st_analyze_sense(struct scsi_request *SRpnt, struct st_cmdstatus *s)
 
 
 /* Convert the result to success code */
-static int st_chk_result(struct scsi_tape *STp, struct scsi_request * SRpnt)
+static int st_chk_result(struct scsi_tape *STp, struct st_request * SRpnt)
 {
-	int result = SRpnt-&gt;sr_result;
+	int result = SRpnt-&gt;result;
 	u8 scode;
 	DEB(const char *stp;)
 	char *name = tape_name(STp);
@@ -366,13 +364,12 @@ static int st_chk_result(struct scsi_tape *STp, struct scsi_request * SRpnt)
 
         DEB(
         if (debugging) {
-                printk(ST_DEB_MSG "%s: Error: %x, cmd: %x %x %x %x %x %x Len: %d\n",
+                printk(ST_DEB_MSG "%s: Error: %x, cmd: %x %x %x %x %x %x\n",
 		       name, result,
-		       SRpnt-&gt;sr_cmnd[0], SRpnt-&gt;sr_cmnd[1], SRpnt-&gt;sr_cmnd[2],
-		       SRpnt-&gt;sr_cmnd[3], SRpnt-&gt;sr_cmnd[4], SRpnt-&gt;sr_cmnd[5],
-		       SRpnt-&gt;sr_bufflen);
+		       SRpnt-&gt;cmd[0], SRpnt-&gt;cmd[1], SRpnt-&gt;cmd[2],
+		       SRpnt-&gt;cmd[3], SRpnt-&gt;cmd[4], SRpnt-&gt;cmd[5]);
 		if (cmdstatp-&gt;have_sense)
-			scsi_print_req_sense("st", SRpnt);
+			 __scsi_print_sense("st", SRpnt-&gt;sense, SCSI_SENSE_BUFFERSIZE);
 	} ) /* end DEB */
 	if (!debugging) { /* Abnormal conditions for tape */
 		if (!cmdstatp-&gt;have_sense)
@@ -386,20 +383,21 @@ static int st_chk_result(struct scsi_tape *STp, struct scsi_request * SRpnt)
 			 /* scode != UNIT_ATTENTION &amp;&amp; */
 			 scode != BLANK_CHECK &amp;&amp;
 			 scode != VOLUME_OVERFLOW &amp;&amp;
-			 SRpnt-&gt;sr_cmnd[0] != MODE_SENSE &amp;&amp;
-			 SRpnt-&gt;sr_cmnd[0] != TEST_UNIT_READY) {
+			 SRpnt-&gt;cmd[0] != MODE_SENSE &amp;&amp;
+			 SRpnt-&gt;cmd[0] != TEST_UNIT_READY) {
 				printk(KERN_WARNING "%s: Error with sense data: ", name);
-				scsi_print_req_sense("st", SRpnt);
+				__scsi_print_sense("st", SRpnt-&gt;sense,
+						   SCSI_SENSE_BUFFERSIZE);
 		}
 	}
 
 	if (cmdstatp-&gt;fixed_format &amp;&amp;
 	    STp-&gt;cln_mode &gt;= EXTENDED_SENSE_START) {  /* Only fixed format sense */
 		if (STp-&gt;cln_sense_value)
-			STp-&gt;cleaning_req |= ((SRpnt-&gt;sr_sense_buffer[STp-&gt;cln_mode] &amp;
+			STp-&gt;cleaning_req |= ((SRpnt-&gt;sense[STp-&gt;cln_mode] &amp;
 					       STp-&gt;cln_sense_mask) == STp-&gt;cln_sense_value);
 		else
-			STp-&gt;cleaning_req |= ((SRpnt-&gt;sr_sense_buffer[STp-&gt;cln_mode] &amp;
+			STp-&gt;cleaning_req |= ((SRpnt-&gt;sense[STp-&gt;cln_mode] &amp;
 					       STp-&gt;cln_sense_mask) != 0);
 	}
 	if (cmdstatp-&gt;have_sense &amp;&amp;
@@ -411,8 +409,8 @@ static int st_chk_result(struct scsi_tape *STp, struct scsi_request * SRpnt)
 	if (cmdstatp-&gt;have_sense &amp;&amp;
 	    scode == RECOVERED_ERROR
 #if ST_RECOVERED_WRITE_FATAL
-	    &amp;&amp; SRpnt-&gt;sr_cmnd[0] != WRITE_6
-	    &amp;&amp; SRpnt-&gt;sr_cmnd[0] != WRITE_FILEMARKS
+	    &amp;&amp; SRpnt-&gt;cmd[0] != WRITE_6
+	    &amp;&amp; SRpnt-&gt;cmd[0] != WRITE_FILEMARKS
 #endif
 	    ) {
 		STp-&gt;recover_count++;
@@ -420,9 +418,9 @@ static int st_chk_result(struct scsi_tape *STp, struct scsi_request * SRpnt)
 
                 DEB(
 		if (debugging) {
-			if (SRpnt-&gt;sr_cmnd[0] == READ_6)
+			if (SRpnt-&gt;cmd[0] == READ_6)
 				stp = "read";
-			else if (SRpnt-&gt;sr_cmnd[0] == WRITE_6)
+			else if (SRpnt-&gt;cmd[0] == WRITE_6)
 				stp = "write";
 			else
 				stp = "ioctl";
@@ -438,28 +436,37 @@ static int st_chk_result(struct scsi_tape *STp, struct scsi_request * SRpnt)
 
 
 /* Wakeup from interrupt */
-static void st_sleep_done(struct scsi_cmnd * SCpnt)
+static void st_sleep_done(void *data, char *sense, int result, int resid)
 {
-	struct scsi_tape *STp = container_of(SCpnt-&gt;request-&gt;rq_disk-&gt;private_data,
-					     struct scsi_tape, driver);
+	struct st_request *SRpnt = data;
+	struct scsi_tape *STp = SRpnt-&gt;stp;
 
-	(STp-&gt;buffer)-&gt;cmdstat.midlevel_result = SCpnt-&gt;result;
-	SCpnt-&gt;request-&gt;rq_status = RQ_SCSI_DONE;
+	memcpy(SRpnt-&gt;sense, sense, SCSI_SENSE_BUFFERSIZE);
+	(STp-&gt;buffer)-&gt;cmdstat.midlevel_result = SRpnt-&gt;result = result;
 	DEB( STp-&gt;write_pending = 0; )
 
-	if (SCpnt-&gt;request-&gt;waiting)
-		complete(SCpnt-&gt;request-&gt;waiting);
+	if (SRpnt-&gt;waiting)
+		complete(SRpnt-&gt;waiting);
+}
+
+static struct st_request *st_allocate_request(void)
+{
+	return kzalloc(sizeof(struct st_request), GFP_KERNEL);
+}
+
+static void st_release_request(struct st_request *streq)
+{
+	kfree(streq);
 }
 
 /* Do the scsi command. Waits until command performed if do_wait is true.
    Otherwise write_behind_check() is used to check that the command
    has finished. */
-static struct scsi_request *
-st_do_scsi(struct scsi_request * SRpnt, struct scsi_tape * STp, unsigned char *cmd,
+static struct st_request *
+st_do_scsi(struct st_request * SRpnt, struct scsi_tape * STp, unsigned char *cmd,
 	   int bytes, int direction, int timeout, int retries, int do_wait)
 {
 	struct completion *waiting;
-	unsigned char *bp;
 
 	/* if async, make sure there's no command outstanding */
 	if (!do_wait &amp;&amp; ((STp-&gt;buffer)-&gt;last_SRpnt)) {
@@ -473,7 +480,7 @@ st_do_scsi(struct scsi_request * SRpnt, struct scsi_tape * STp, unsigned char *c
 	}
 
 	if (SRpnt == NULL) {
-		SRpnt = scsi_allocate_request(STp-&gt;device, GFP_ATOMIC);
+		SRpnt = st_allocate_request();
 		if (SRpnt == NULL) {
 			DEBC( printk(KERN_ERR "%s: Can't get SCSI request.\n",
 				     tape_name(STp)); );
@@ -483,6 +490,7 @@ st_do_scsi(struct scsi_request * SRpnt, struct scsi_tape * STp, unsigned char *c
 				(STp-&gt;buffer)-&gt;syscall_result = (-EBUSY);
 			return NULL;
 		}
+		SRpnt-&gt;stp = STp;
 	}
 
 	/* If async IO, set last_SRpnt. This ptr tells write_behind_check
@@ -492,32 +500,26 @@ st_do_scsi(struct scsi_request * SRpnt, struct scsi_tape * STp, unsigned char *c
 
 	waiting = &amp;STp-&gt;wait;
 	init_completion(waiting);
-	SRpnt-&gt;sr_use_sg = STp-&gt;buffer-&gt;do_dio || (bytes &gt; (STp-&gt;buffer)-&gt;frp[0].length);
-	if (SRpnt-&gt;sr_use_sg) {
-		if (!STp-&gt;buffer-&gt;do_dio)
-			buf_to_sg(STp-&gt;buffer, bytes);
-		SRpnt-&gt;sr_use_sg = (STp-&gt;buffer)-&gt;sg_segs;
-		bp = (char *) &amp;((STp-&gt;buffer)-&gt;sg[0]);
-	} else
-		bp = (STp-&gt;buffer)-&gt;b_data;
-	SRpnt-&gt;sr_data_direction = direction;
-	SRpnt-&gt;sr_cmd_len = 0;
-	SRpnt-&gt;sr_request-&gt;waiting = waiting;
-	SRpnt-&gt;sr_request-&gt;rq_status = RQ_SCSI_BUSY;
-	SRpnt-&gt;sr_request-&gt;rq_disk = STp-&gt;disk;
-	SRpnt-&gt;sr_request-&gt;end_io = blk_end_sync_rq;
-	STp-&gt;buffer-&gt;cmdstat.have_sense = 0;
+	SRpnt-&gt;waiting = waiting;
 
-	scsi_do_req(SRpnt, (void *) cmd, bp, bytes,
-		    st_sleep_done, timeout, retries);
+	if (!STp-&gt;buffer-&gt;do_dio)
+		buf_to_sg(STp-&gt;buffer, bytes);
 
-	if (do_wait) {
+	memcpy(SRpnt-&gt;cmd, cmd, sizeof(SRpnt-&gt;cmd));
+	STp-&gt;buffer-&gt;cmdstat.have_sense = 0;
+	STp-&gt;buffer-&gt;syscall_result = 0;
+
+	if (scsi_execute_async(STp-&gt;device, cmd, direction,
+			&amp;((STp-&gt;buffer)-&gt;sg[0]), bytes, (STp-&gt;buffer)-&gt;sg_segs,
+			timeout, retries, SRpnt, st_sleep_done, GFP_KERNEL))
+		/* could not allocate the buffer or request was too large */
+		(STp-&gt;buffer)-&gt;syscall_result = (-EBUSY);
+	else if (do_wait) {
 		wait_for_completion(waiting);
-		SRpnt-&gt;sr_request-&gt;waiting = NULL;
-		if (SRpnt-&gt;sr_request-&gt;rq_status != RQ_SCSI_DONE)
-			SRpnt-&gt;sr_result |= (DRIVER_ERROR &lt;&lt; 24);
+		SRpnt-&gt;waiting = NULL;
 		(STp-&gt;buffer)-&gt;syscall_result = st_chk_result(STp, SRpnt);
 	}
+
 	return SRpnt;
 }
 
@@ -532,7 +534,7 @@ static int write_behind_check(struct scsi_tape * STp)
 	struct st_buffer *STbuffer;
 	struct st_partstat *STps;
 	struct st_cmdstatus *cmdstatp;
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 
 	STbuffer = STp-&gt;buffer;
 	if (!STbuffer-&gt;writing)
@@ -548,12 +550,10 @@ static int write_behind_check(struct scsi_tape * STp)
 	wait_for_completion(&amp;(STp-&gt;wait));
 	SRpnt = STbuffer-&gt;last_SRpnt;
 	STbuffer-&gt;last_SRpnt = NULL;
-	SRpnt-&gt;sr_request-&gt;waiting = NULL;
-	if (SRpnt-&gt;sr_request-&gt;rq_status != RQ_SCSI_DONE)
-		SRpnt-&gt;sr_result |= (DRIVER_ERROR &lt;&lt; 24);
+	SRpnt-&gt;waiting = NULL;
 
 	(STp-&gt;buffer)-&gt;syscall_result = st_chk_result(STp, SRpnt);
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 
 	STbuffer-&gt;buffer_bytes -= STbuffer-&gt;writing;
 	STps = &amp;(STp-&gt;ps[STp-&gt;partition]);
@@ -593,7 +593,7 @@ static int write_behind_check(struct scsi_tape * STp)
    it messes up the block number). */
 static int cross_eof(struct scsi_tape * STp, int forward)
 {
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 	unsigned char cmd[MAX_COMMAND_SIZE];
 
 	cmd[0] = SPACE;
@@ -613,7 +613,7 @@ static int cross_eof(struct scsi_tape * STp, int forward)
 	if (!SRpnt)
 		return (STp-&gt;buffer)-&gt;syscall_result;
 
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 	SRpnt = NULL;
 
 	if ((STp-&gt;buffer)-&gt;cmdstat.midlevel_result != 0)
@@ -630,7 +630,7 @@ static int flush_write_buffer(struct scsi_tape * STp)
 	int offset, transfer, blks;
 	int result;
 	unsigned char cmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 	struct st_partstat *STps;
 
 	result = write_behind_check(STp);
@@ -688,7 +688,7 @@ static int flush_write_buffer(struct scsi_tape * STp)
 			STp-&gt;dirty = 0;
 			(STp-&gt;buffer)-&gt;buffer_bytes = 0;
 		}
-		scsi_release_request(SRpnt);
+		st_release_request(SRpnt);
 		SRpnt = NULL;
 	}
 	return result;
@@ -785,7 +785,7 @@ static int set_mode_densblk(struct scsi_tape * STp, struct st_modedef * STm)
 }
 
 
-/* Lock or unlock the drive door. Don't use when scsi_request allocated. */
+/* Lock or unlock the drive door. Don't use when st_request allocated. */
 static int do_door_lock(struct scsi_tape * STp, int do_lock)
 {
 	int retval, cmd;
@@ -844,7 +844,7 @@ static int test_ready(struct scsi_tape *STp, int do_wait)
 	int attentions, waits, max_wait, scode;
 	int retval = CHKRES_READY, new_session = 0;
 	unsigned char cmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt = NULL;
+	struct st_request *SRpnt = NULL;
 	struct st_cmdstatus *cmdstatp = &amp;STp-&gt;buffer-&gt;cmdstat;
 
 	max_wait = do_wait ? ST_BLOCK_SECONDS : 0;
@@ -903,7 +903,7 @@ static int test_ready(struct scsi_tape *STp, int do_wait)
 	}
 
 	if (SRpnt != NULL)
-		scsi_release_request(SRpnt);
+		st_release_request(SRpnt);
 	return retval;
 }
 
@@ -918,7 +918,7 @@ static int check_tape(struct scsi_tape *STp, struct file *filp)
 	int i, retval, new_session = 0, do_wait;
 	unsigned char cmd[MAX_COMMAND_SIZE], saved_cleaning;
 	unsigned short st_flags = filp-&gt;f_flags;
-	struct scsi_request *SRpnt = NULL;
+	struct st_request *SRpnt = NULL;
 	struct st_modedef *STm;
 	struct st_partstat *STps;
 	char *name = tape_name(STp);
@@ -993,7 +993,7 @@ static int check_tape(struct scsi_tape *STp, struct file *filp)
 			goto err_out;
 		}
 
-		if (!SRpnt-&gt;sr_result &amp;&amp; !STp-&gt;buffer-&gt;cmdstat.have_sense) {
+		if (!SRpnt-&gt;result &amp;&amp; !STp-&gt;buffer-&gt;cmdstat.have_sense) {
 			STp-&gt;max_block = ((STp-&gt;buffer)-&gt;b_data[1] &lt;&lt; 16) |
 			    ((STp-&gt;buffer)-&gt;b_data[2] &lt;&lt; 8) | (STp-&gt;buffer)-&gt;b_data[3];
 			STp-&gt;min_block = ((STp-&gt;buffer)-&gt;b_data[4] &lt;&lt; 8) |
@@ -1045,7 +1045,7 @@ static int check_tape(struct scsi_tape *STp, struct file *filp)
 		}
 		STp-&gt;drv_write_prot = ((STp-&gt;buffer)-&gt;b_data[2] &amp; 0x80) != 0;
 	}
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 	SRpnt = NULL;
         STp-&gt;inited = 1;
 
@@ -1196,7 +1196,7 @@ static int st_flush(struct file *filp)
 {
 	int result = 0, result2;
 	unsigned char cmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 	struct scsi_tape *STp = filp-&gt;private_data;
 	struct st_modedef *STm = &amp;(STp-&gt;modes[STp-&gt;current_mode]);
 	struct st_partstat *STps = &amp;(STp-&gt;ps[STp-&gt;partition]);
@@ -1249,7 +1249,7 @@ static int st_flush(struct file *filp)
 		      cmdstatp-&gt;sense_hdr.sense_key == RECOVERED_ERROR) &amp;&amp;
 		     (!cmdstatp-&gt;remainder_valid || cmdstatp-&gt;uremainder64 == 0))) {
 			/* Write successful at EOM */
-			scsi_release_request(SRpnt);
+			st_release_request(SRpnt);
 			SRpnt = NULL;
 			if (STps-&gt;drv_file &gt;= 0)
 				STps-&gt;drv_file++;
@@ -1259,7 +1259,7 @@ static int st_flush(struct file *filp)
 			STps-&gt;eof = ST_FM;
 		}
 		else { /* Write error */
-			scsi_release_request(SRpnt);
+			st_release_request(SRpnt);
 			SRpnt = NULL;
 			printk(KERN_ERR "%s: Error on write filemark.\n", name);
 			if (result == 0)
@@ -1400,11 +1400,11 @@ static int setup_buffering(struct scsi_tape *STp, const char __user *buf,
 		i = STp-&gt;try_dio &amp;&amp; try_rdio;
 	else
 		i = STp-&gt;try_dio &amp;&amp; try_wdio;
+
 	if (i &amp;&amp; ((unsigned long)buf &amp; queue_dma_alignment(
 					STp-&gt;device-&gt;request_queue)) == 0) {
-		i = st_map_user_pages(&amp;(STbp-&gt;sg[0]), STbp-&gt;use_sg,
-				      (unsigned long)buf, count, (is_read ? READ : WRITE),
-				      STp-&gt;max_pfn);
+		i = sgl_map_user_pages(&amp;(STbp-&gt;sg[0]), STbp-&gt;use_sg,
+				      (unsigned long)buf, count, (is_read ? READ : WRITE));
 		if (i &gt; 0) {
 			STbp-&gt;do_dio = i;
 			STbp-&gt;buffer_bytes = 0;   /* can be used as transfer counter */
@@ -1472,7 +1472,7 @@ st_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 	int async_write;
 	unsigned char cmd[MAX_COMMAND_SIZE];
 	const char __user *b_point;
-	struct scsi_request *SRpnt = NULL;
+	struct st_request *SRpnt = NULL;
 	struct scsi_tape *STp = filp-&gt;private_data;
 	struct st_modedef *STm;
 	struct st_partstat *STps;
@@ -1624,7 +1624,7 @@ st_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 			retval = STbp-&gt;syscall_result;
 			goto out;
 		}
-		if (async_write) {
+		if (async_write &amp;&amp; !STbp-&gt;syscall_result) {
 			STbp-&gt;writing = transfer;
 			STp-&gt;dirty = !(STbp-&gt;writing ==
 				       STbp-&gt;buffer_bytes);
@@ -1698,7 +1698,7 @@ st_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 			} else {
 				count += do_count;
 				STps-&gt;drv_block = (-1);		/* Too cautious? */
-				retval = (-EIO);
+				retval = STbp-&gt;syscall_result;
 			}
 
 		}
@@ -1728,7 +1728,7 @@ st_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 
  out:
 	if (SRpnt != NULL)
-		scsi_release_request(SRpnt);
+		st_release_request(SRpnt);
 	release_buffering(STp);
 	up(&amp;STp-&gt;lock);
 
@@ -1742,11 +1742,11 @@ st_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
    Does release user buffer mapping if it is set.
 */
 static long read_tape(struct scsi_tape *STp, long count,
-		      struct scsi_request ** aSRpnt)
+		      struct st_request ** aSRpnt)
 {
 	int transfer, blks, bytes;
 	unsigned char cmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 	struct st_modedef *STm;
 	struct st_partstat *STps;
 	struct st_buffer *STbp;
@@ -1802,10 +1802,10 @@ static long read_tape(struct scsi_tape *STp, long count,
 		retval = 1;
 		DEBC(printk(ST_DEB_MSG "%s: Sense: %2x %2x %2x %2x %2x %2x %2x %2x\n",
                             name,
-                            SRpnt-&gt;sr_sense_buffer[0], SRpnt-&gt;sr_sense_buffer[1],
-                            SRpnt-&gt;sr_sense_buffer[2], SRpnt-&gt;sr_sense_buffer[3],
-                            SRpnt-&gt;sr_sense_buffer[4], SRpnt-&gt;sr_sense_buffer[5],
-                            SRpnt-&gt;sr_sense_buffer[6], SRpnt-&gt;sr_sense_buffer[7]));
+                            SRpnt-&gt;sense[0], SRpnt-&gt;sense[1],
+                            SRpnt-&gt;sense[2], SRpnt-&gt;sense[3],
+                            SRpnt-&gt;sense[4], SRpnt-&gt;sense[5],
+                            SRpnt-&gt;sense[6], SRpnt-&gt;sense[7]));
 		if (cmdstatp-&gt;have_sense) {
 
 			if (cmdstatp-&gt;sense_hdr.sense_key == BLANK_CHECK)
@@ -1835,7 +1835,7 @@ static long read_tape(struct scsi_tape *STp, long count,
 						}
 						STbp-&gt;buffer_bytes = bytes - transfer;
 					} else {
-						scsi_release_request(SRpnt);
+						st_release_request(SRpnt);
 						SRpnt = *aSRpnt = NULL;
 						if (transfer == blks) {	/* We did not get anything, error */
 							printk(KERN_NOTICE "%s: Incorrect block size.\n", name);
@@ -1929,7 +1929,7 @@ st_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)
 	ssize_t retval = 0;
 	ssize_t i, transfer;
 	int special, do_dio = 0;
-	struct scsi_request *SRpnt = NULL;
+	struct st_request *SRpnt = NULL;
 	struct scsi_tape *STp = filp-&gt;private_data;
 	struct st_modedef *STm;
 	struct st_partstat *STps;
@@ -2054,7 +2054,7 @@ st_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)
 
  out:
 	if (SRpnt != NULL) {
-		scsi_release_request(SRpnt);
+		st_release_request(SRpnt);
 		SRpnt = NULL;
 	}
 	if (do_dio) {
@@ -2284,7 +2284,7 @@ static int st_set_options(struct scsi_tape *STp, long options)
 static int read_mode_page(struct scsi_tape *STp, int page, int omit_block_descs)
 {
 	unsigned char cmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt = NULL;
+	struct st_request *SRpnt = NULL;
 
 	memset(cmd, 0, MAX_COMMAND_SIZE);
 	cmd[0] = MODE_SENSE;
@@ -2298,7 +2298,7 @@ static int read_mode_page(struct scsi_tape *STp, int page, int omit_block_descs)
 	if (SRpnt == NULL)
 		return (STp-&gt;buffer)-&gt;syscall_result;
 
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 
 	return (STp-&gt;buffer)-&gt;syscall_result;
 }
@@ -2310,7 +2310,7 @@ static int write_mode_page(struct scsi_tape *STp, int page, int slow)
 {
 	int pgo;
 	unsigned char cmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt = NULL;
+	struct st_request *SRpnt = NULL;
 
 	memset(cmd, 0, MAX_COMMAND_SIZE);
 	cmd[0] = MODE_SELECT;
@@ -2329,7 +2329,7 @@ static int write_mode_page(struct scsi_tape *STp, int page, int slow)
 	if (SRpnt == NULL)
 		return (STp-&gt;buffer)-&gt;syscall_result;
 
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 
 	return (STp-&gt;buffer)-&gt;syscall_result;
 }
@@ -2412,7 +2412,7 @@ static int do_load_unload(struct scsi_tape *STp, struct file *filp, int load_cod
 	DEB( char *name = tape_name(STp); )
 	unsigned char cmd[MAX_COMMAND_SIZE];
 	struct st_partstat *STps;
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 
 	if (STp-&gt;ready != ST_READY &amp;&amp; !load_code) {
 		if (STp-&gt;ready == ST_NO_TAPE)
@@ -2455,7 +2455,7 @@ static int do_load_unload(struct scsi_tape *STp, struct file *filp, int load_cod
 		return (STp-&gt;buffer)-&gt;syscall_result;
 
 	retval = (STp-&gt;buffer)-&gt;syscall_result;
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 
 	if (!retval) {	/* SCSI command successful */
 
@@ -2503,7 +2503,7 @@ static int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned lon
 	int ioctl_result;
 	int chg_eof = 1;
 	unsigned char cmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 	struct st_partstat *STps;
 	int fileno, blkno, at_sm, undone;
 	int datalen = 0, direction = DMA_NONE;
@@ -2757,7 +2757,7 @@ static int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned lon
 	ioctl_result = (STp-&gt;buffer)-&gt;syscall_result;
 
 	if (!ioctl_result) {	/* SCSI command successful */
-		scsi_release_request(SRpnt);
+		st_release_request(SRpnt);
 		SRpnt = NULL;
 		STps-&gt;drv_block = blkno;
 		STps-&gt;drv_file = fileno;
@@ -2872,7 +2872,7 @@ static int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned lon
 				/* Try the other possible state of Page Format if not
 				   already tried */
 				STp-&gt;use_pf = !STp-&gt;use_pf | PF_TESTED;
-				scsi_release_request(SRpnt);
+				st_release_request(SRpnt);
 				SRpnt = NULL;
 				return st_int_ioctl(STp, cmd_in, arg);
 			}
@@ -2882,7 +2882,7 @@ static int st_int_ioctl(struct scsi_tape *STp, unsigned int cmd_in, unsigned lon
 		if (cmdstatp-&gt;sense_hdr.sense_key == BLANK_CHECK)
 			STps-&gt;eof = ST_EOD;
 
-		scsi_release_request(SRpnt);
+		st_release_request(SRpnt);
 		SRpnt = NULL;
 	}
 
@@ -2898,7 +2898,7 @@ static int get_location(struct scsi_tape *STp, unsigned int *block, int *partiti
 {
 	int result;
 	unsigned char scmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 	DEB( char *name = tape_name(STp); )
 
 	if (STp-&gt;ready != ST_READY)
@@ -2944,7 +2944,7 @@ static int get_location(struct scsi_tape *STp, unsigned int *block, int *partiti
                 DEBC(printk(ST_DEB_MSG "%s: Got tape pos. blk %d part %d.\n", name,
                             *block, *partition));
 	}
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 	SRpnt = NULL;
 
 	return result;
@@ -2961,7 +2961,7 @@ static int set_location(struct scsi_tape *STp, unsigned int block, int partition
 	unsigned int blk;
 	int timeout;
 	unsigned char scmd[MAX_COMMAND_SIZE];
-	struct scsi_request *SRpnt;
+	struct st_request *SRpnt;
 	DEB( char *name = tape_name(STp); )
 
 	if (STp-&gt;ready != ST_READY)
@@ -3047,7 +3047,7 @@ static int set_location(struct scsi_tape *STp, unsigned int block, int partition
 		result = 0;
 	}
 
-	scsi_release_request(SRpnt);
+	st_release_request(SRpnt);
 	SRpnt = NULL;
 
 	return result;
@@ -3577,7 +3577,7 @@ static long st_compat_ioctl(struct file *file, unsigned int cmd, unsigned long a
 static struct st_buffer *
  new_tape_buffer(int from_initialization, int need_dma, int max_sg)
 {
-	int i, got = 0, segs = 0;
+	int i, got = 0;
 	gfp_t priority;
 	struct st_buffer *tb;
 
@@ -3594,10 +3594,8 @@ static struct st_buffer *
 		return NULL;
 	}
 	memset(tb, 0, i);
-	tb-&gt;frp_segs = tb-&gt;orig_frp_segs = segs;
+	tb-&gt;frp_segs = tb-&gt;orig_frp_segs = 0;
 	tb-&gt;use_sg = max_sg;
-	if (segs &gt; 0)
-		tb-&gt;b_data = page_address(tb-&gt;sg[0].page);
 	tb-&gt;frp = (struct st_buf_fragment *)(&amp;(tb-&gt;sg[0]) + max_sg);
 
 	tb-&gt;in_use = 1;
@@ -3628,7 +3626,7 @@ static int enlarge_buffer(struct st_buffer * STbuffer, int new_size, int need_dm
 	priority = GFP_KERNEL | __GFP_NOWARN;
 	if (need_dma)
 		priority |= GFP_DMA;
-	for (b_size = PAGE_SIZE, order=0;
+	for (b_size = PAGE_SIZE, order=0; order &lt;= 6 &amp;&amp;
 	     b_size &lt; new_size - STbuffer-&gt;buffer_size;
 	     order++, b_size *= 2)
 		;  /* empty */
@@ -3670,6 +3668,7 @@ static void normalize_buffer(struct st_buffer * STbuffer)
 	}
 	STbuffer-&gt;frp_segs = STbuffer-&gt;orig_frp_segs;
 	STbuffer-&gt;frp_sg_current = 0;
+	STbuffer-&gt;sg_segs = 0;
 }
 
 
@@ -3882,7 +3881,6 @@ static int st_probe(struct device *dev)
 	struct st_buffer *buffer;
 	int i, j, mode, dev_num, error;
 	char *stp;
-	u64 bounce_limit;
 
 	if (SDp-&gt;type != TYPE_TAPE)
 		return -ENODEV;
@@ -3892,7 +3890,8 @@ static int st_probe(struct device *dev)
 		return -ENODEV;
 	}
 
-	i = SDp-&gt;host-&gt;sg_tablesize;
+	i = min(SDp-&gt;request_queue-&gt;max_hw_segments,
+		SDp-&gt;request_queue-&gt;max_phys_segments);
 	if (st_max_sg_segs &lt; i)
 		i = st_max_sg_segs;
 	buffer = new_tape_buffer(1, (SDp-&gt;host)-&gt;unchecked_isa_dma, i);
@@ -3994,11 +3993,6 @@ static int st_probe(struct device *dev)
 	tpnt-&gt;long_timeout = ST_LONG_TIMEOUT;
 	tpnt-&gt;try_dio = try_direct_io &amp;&amp; !SDp-&gt;host-&gt;unchecked_isa_dma;
 
-	bounce_limit = scsi_calculate_bounce_limit(SDp-&gt;host) &gt;&gt; PAGE_SHIFT;
-	if (bounce_limit &gt; ULONG_MAX)
-		bounce_limit = ULONG_MAX;
-	tpnt-&gt;max_pfn = bounce_limit;
-
 	for (i = 0; i &lt; ST_NBR_MODES; i++) {
 		STm = &amp;(tpnt-&gt;modes[i]);
 		STm-&gt;defined = 0;
@@ -4077,9 +4071,9 @@ static int st_probe(struct device *dev)
 
 	sdev_printk(KERN_WARNING, SDp,
 		    "Attached scsi tape %s", tape_name(tpnt));
-	printk(KERN_WARNING "%s: try direct i/o: %s (alignment %d B), max page reachable by HBA %lu\n",
+	printk(KERN_WARNING "%s: try direct i/o: %s (alignment %d B)\n",
 	       tape_name(tpnt), tpnt-&gt;try_dio ? "yes" : "no",
-	       queue_dma_alignment(SDp-&gt;request_queue) + 1, tpnt-&gt;max_pfn);
+	       queue_dma_alignment(SDp-&gt;request_queue) + 1);
 
 	return 0;
 
@@ -4411,34 +4405,6 @@ static void do_create_class_files(struct scsi_tape *STp, int dev_num, int mode)
 	return;
 }
 
-
-/* Pin down user pages and put them into a scatter gather list. Returns &lt;= 0 if
-   - mapping of all pages not successful
-   - any page is above max_pfn
-   (i.e., either completely successful or fails)
-*/
-static int st_map_user_pages(struct scatterlist *sgl, const unsigned int max_pages, 
-			     unsigned long uaddr, size_t count, int rw,
-			     unsigned long max_pfn)
-{
-	int i, nr_pages;
-
-	nr_pages = sgl_map_user_pages(sgl, max_pages, uaddr, count, rw);
-	if (nr_pages &lt;= 0)
-		return nr_pages;
-
-	for (i=0; i &lt; nr_pages; i++) {
-		if (page_to_pfn(sgl[i].page) &gt; max_pfn)
-			goto out_unmap;
-	}
-	return nr_pages;
-
- out_unmap:
-	sgl_unmap_user_pages(sgl, nr_pages, 0);
-	return 0;
-}
-
-
 /* The following functions may be useful for a larger audience. */
 static int sgl_map_user_pages(struct scatterlist *sgl, const unsigned int max_pages, 
 			      unsigned long uaddr, size_t count, int rw)
diff --git a/drivers/scsi/st.h b/drivers/scsi/st.h
index 790acac160bc..411209048d74 100644
--- a/drivers/scsi/st.h
+++ b/drivers/scsi/st.h
@@ -4,6 +4,7 @@
 
 #include &lt;linux/completion.h&gt;
 #include &lt;linux/kref.h&gt;
+#include &lt;scsi/scsi_cmnd.h&gt;
 
 /* Descriptor for analyzed sense data */
 struct st_cmdstatus {
@@ -17,6 +18,17 @@ struct st_cmdstatus {
 	u8 deferred;
 };
 
+struct scsi_tape;
+
+/* scsi tape command */
+struct st_request {
+	unsigned char cmd[MAX_COMMAND_SIZE];
+	unsigned char sense[SCSI_SENSE_BUFFERSIZE];
+	int result;
+	struct scsi_tape *stp;
+	struct completion *waiting;
+};
+
 /* The tape buffer descriptor. */
 struct st_buffer {
 	unsigned char in_use;
@@ -28,7 +40,7 @@ struct st_buffer {
 	int read_pointer;
 	int writing;
 	int syscall_result;
-	struct scsi_request *last_SRpnt;
+	struct st_request *last_SRpnt;
 	struct st_cmdstatus cmdstat;
 	unsigned char *b_data;
 	unsigned short use_sg;	/* zero or max number of s/g segments for this adapter */</pre><hr><pre>commit d6b10348f9397943eb968419a2b7f08895e38472
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Nov 8 04:06:41 2005 -0600

    [SCSI] convert sg to scsi_execute_async
    
    Convert sg to always send scatterlists, and kill scsi_request usage.
    
    TODO:
    
    - move DIO code to common place or make block layers usable for ULDs.
    - move buffer allocation code to common place for all ULDs to use. And
    make buffer allocation code obey all queue limits so we can find
    out about problems before calling scsi_execute_async. Currently, sg.c
    could allocate a buffer that is too large, and send the request
    to scsi_execute_async. scsi_execute_async will then check it against
    all the queue limits and return a failure in this case. It would nicer
    to know about the queue limit violation right away.
    - move indirect (copy_to/from_user) paths commone place or make block
    layers usable for ULDs.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index b55c2a8a547c..221e96e2620a 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -104,8 +104,6 @@ static int sg_allow_dio = SG_ALLOW_DIO_DEF;
 static int sg_add(struct class_device *, struct class_interface *);
 static void sg_remove(struct class_device *, struct class_interface *);
 
-static Scsi_Request *dummy_cmdp;	/* only used for sizeof */
-
 static DEFINE_RWLOCK(sg_dev_arr_lock);	/* Also used to lock
 							   file descriptor list for device */
 
@@ -119,7 +117,7 @@ typedef struct sg_scatter_hold { /* holding area for scsi scatter gather info */
 	unsigned short sglist_len; /* size of malloc'd scatter-gather list ++ */
 	unsigned bufflen;	/* Size of (aggregate) data buffer */
 	unsigned b_malloc_len;	/* actual len malloc'ed in buffer */
-	void *buffer;		/* Data buffer or scatter list (k_use_sg&gt;0) */
+	struct scatterlist *buffer;/* scatter list */
 	char dio_in_use;	/* 0-&gt;indirect IO (or mmap), 1-&gt;dio */
 	unsigned char cmd_opcode; /* first byte of command */
 } Sg_scatter_hold;
@@ -128,12 +126,11 @@ struct sg_device;		/* forward declarations */
 struct sg_fd;
 
 typedef struct sg_request {	/* SG_MAX_QUEUE requests outstanding per file */
-	Scsi_Request *my_cmdp;	/* != 0  when request with lower levels */
 	struct sg_request *nextrp;	/* NULL -&gt; tail request (slist) */
 	struct sg_fd *parentfp;	/* NULL -&gt; not in use */
 	Sg_scatter_hold data;	/* hold buffer, perhaps scatter list */
 	sg_io_hdr_t header;	/* scsi command+info, see &lt;scsi/sg.h&gt; */
-	unsigned char sense_b[sizeof (dummy_cmdp-&gt;sr_sense_buffer)];
+	unsigned char sense_b[SCSI_SENSE_BUFFERSIZE];
 	char res_used;		/* 1 -&gt; using reserve buffer, 0 -&gt; not ... */
 	char orphan;		/* 1 -&gt; drop on sight, 0 -&gt; normal */
 	char sg_io_owned;	/* 1 -&gt; packet belongs to SG_IO */
@@ -174,7 +171,8 @@ typedef struct sg_device { /* holds the state of each scsi generic device */
 } Sg_device;
 
 static int sg_fasync(int fd, struct file *filp, int mode);
-static void sg_cmd_done(Scsi_Cmnd * SCpnt);	/* tasklet or soft irq callback */
+/* tasklet or soft irq callback */
+static void sg_cmd_done(void *data, char *sense, int result, int resid);
 static int sg_start_req(Sg_request * srp);
 static void sg_finish_rem_req(Sg_request * srp);
 static int sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size);
@@ -195,8 +193,8 @@ static void sg_remove_scat(Sg_scatter_hold * schp);
 static void sg_build_reserve(Sg_fd * sfp, int req_size);
 static void sg_link_reserve(Sg_fd * sfp, Sg_request * srp, int size);
 static void sg_unlink_reserve(Sg_fd * sfp, Sg_request * srp);
-static char *sg_page_malloc(int rqSz, int lowDma, int *retSzp);
-static void sg_page_free(char *buff, int size);
+static struct page *sg_page_malloc(int rqSz, int lowDma, int *retSzp);
+static void sg_page_free(struct page *page, int size);
 static Sg_fd *sg_add_sfp(Sg_device * sdp, int dev);
 static int sg_remove_sfp(Sg_device * sdp, Sg_fd * sfp);
 static void __sg_remove_sfp(Sg_device * sdp, Sg_fd * sfp);
@@ -207,7 +205,6 @@ static int sg_res_in_use(Sg_fd * sfp);
 static int sg_allow_access(unsigned char opcode, char dev_type);
 static int sg_build_direct(Sg_request * srp, Sg_fd * sfp, int dxfer_len);
 static Sg_device *sg_get_dev(int dev);
-static inline unsigned char *sg_scatg2virt(const struct scatterlist *sclp);
 #ifdef CONFIG_SCSI_PROC_FS
 static int sg_last_dev(void);
 #endif
@@ -226,6 +223,7 @@ sg_open(struct inode *inode, struct file *filp)
 {
 	int dev = iminor(inode);
 	int flags = filp-&gt;f_flags;
+	struct request_queue *q;
 	Sg_device *sdp;
 	Sg_fd *sfp;
 	int res;
@@ -287,7 +285,9 @@ sg_open(struct inode *inode, struct file *filp)
 	}
 	if (!sdp-&gt;headfp) {	/* no existing opens on this device */
 		sdp-&gt;sgdebug = 0;
-		sdp-&gt;sg_tablesize = sdp-&gt;device-&gt;host-&gt;sg_tablesize;
+		q = sdp-&gt;device-&gt;request_queue;
+		sdp-&gt;sg_tablesize = min(q-&gt;max_hw_segments,
+					q-&gt;max_phys_segments);
 	}
 	if ((sfp = sg_add_sfp(sdp, dev)))
 		filp-&gt;private_data = sfp;
@@ -340,6 +340,7 @@ sg_read(struct file *filp, char __user *buf, size_t count, loff_t * ppos)
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, printk("sg_read: %s, count=%d\n",
 				   sdp-&gt;disk-&gt;disk_name, (int) count));
+
 	if (!access_ok(VERIFY_WRITE, buf, count))
 		return -EFAULT;
 	if (sfp-&gt;force_packid &amp;&amp; (count &gt;= SZ_SG_HEADER)) {
@@ -491,7 +492,7 @@ sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)
 	if ((hp-&gt;mx_sb_len &gt; 0) &amp;&amp; hp-&gt;sbp) {
 		if ((CHECK_CONDITION &amp; hp-&gt;masked_status) ||
 		    (DRIVER_SENSE &amp; hp-&gt;driver_status)) {
-			int sb_len = sizeof (dummy_cmdp-&gt;sr_sense_buffer);
+			int sb_len = SCSI_SENSE_BUFFERSIZE;
 			sb_len = (hp-&gt;mx_sb_len &gt; sb_len) ? sb_len : hp-&gt;mx_sb_len;
 			len = 8 + (int) srp-&gt;sense_b[7];	/* Additional sense length field */
 			len = (len &gt; sb_len) ? sb_len : len;
@@ -525,7 +526,7 @@ sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
 	Sg_request *srp;
 	struct sg_header old_hdr;
 	sg_io_hdr_t *hp;
-	unsigned char cmnd[sizeof (dummy_cmdp-&gt;sr_cmnd)];
+	unsigned char cmnd[MAX_COMMAND_SIZE];
 
 	if ((!(sfp = (Sg_fd *) filp-&gt;private_data)) || (!(sdp = sfp-&gt;parentdp)))
 		return -ENXIO;
@@ -624,7 +625,7 @@ sg_new_write(Sg_fd * sfp, const char __user *buf, size_t count,
 	int k;
 	Sg_request *srp;
 	sg_io_hdr_t *hp;
-	unsigned char cmnd[sizeof (dummy_cmdp-&gt;sr_cmnd)];
+	unsigned char cmnd[MAX_COMMAND_SIZE];
 	int timeout;
 	unsigned long ul_timeout;
 
@@ -692,11 +693,9 @@ static int
 sg_common_write(Sg_fd * sfp, Sg_request * srp,
 		unsigned char *cmnd, int timeout, int blocking)
 {
-	int k;
-	Scsi_Request *SRpnt;
+	int k, data_dir;
 	Sg_device *sdp = sfp-&gt;parentdp;
 	sg_io_hdr_t *hp = &amp;srp-&gt;header;
-	request_queue_t *q;
 
 	srp-&gt;data.cmd_opcode = cmnd[0];	/* hold opcode of command */
 	hp-&gt;status = 0;
@@ -723,51 +722,36 @@ sg_common_write(Sg_fd * sfp, Sg_request * srp,
 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}
-	SRpnt = scsi_allocate_request(sdp-&gt;device, GFP_ATOMIC);
-	if (SRpnt == NULL) {
-		SCSI_LOG_TIMEOUT(1, printk("sg_write: no mem\n"));
-		sg_finish_rem_req(srp);
-		return -ENOMEM;
-	}
 
-	srp-&gt;my_cmdp = SRpnt;
-	q = SRpnt-&gt;sr_device-&gt;request_queue;
-	SRpnt-&gt;sr_request-&gt;rq_disk = sdp-&gt;disk;
-	SRpnt-&gt;sr_sense_buffer[0] = 0;
-	SRpnt-&gt;sr_cmd_len = hp-&gt;cmd_len;
-	SRpnt-&gt;sr_use_sg = srp-&gt;data.k_use_sg;
-	SRpnt-&gt;sr_sglist_len = srp-&gt;data.sglist_len;
-	SRpnt-&gt;sr_bufflen = srp-&gt;data.bufflen;
-	SRpnt-&gt;sr_underflow = 0;
-	SRpnt-&gt;sr_buffer = srp-&gt;data.buffer;
 	switch (hp-&gt;dxfer_direction) {
 	case SG_DXFER_TO_FROM_DEV:
 	case SG_DXFER_FROM_DEV:
-		SRpnt-&gt;sr_data_direction = DMA_FROM_DEVICE;
+		data_dir = DMA_FROM_DEVICE;
 		break;
 	case SG_DXFER_TO_DEV:
-		SRpnt-&gt;sr_data_direction = DMA_TO_DEVICE;
+		data_dir = DMA_TO_DEVICE;
 		break;
 	case SG_DXFER_UNKNOWN:
-		SRpnt-&gt;sr_data_direction = DMA_BIDIRECTIONAL;
+		data_dir = DMA_BIDIRECTIONAL;
 		break;
 	default:
-		SRpnt-&gt;sr_data_direction = DMA_NONE;
+		data_dir = DMA_NONE;
 		break;
 	}
-	SRpnt-&gt;upper_private_data = srp;
-	srp-&gt;data.k_use_sg = 0;
-	srp-&gt;data.sglist_len = 0;
-	srp-&gt;data.bufflen = 0;
-	srp-&gt;data.buffer = NULL;
 	hp-&gt;duration = jiffies_to_msecs(jiffies);
 /* Now send everything of to mid-level. The next time we hear about this
    packet is when sg_cmd_done() is called (i.e. a callback). */
-	scsi_do_req(SRpnt, (void *) cmnd,
-		    (void *) SRpnt-&gt;sr_buffer, hp-&gt;dxfer_len,
-		    sg_cmd_done, timeout, SG_DEFAULT_RETRIES);
-	/* dxfer_len overwrites SRpnt-&gt;sr_bufflen, hence need for b_malloc_len */
-	return 0;
+	if (scsi_execute_async(sdp-&gt;device, cmnd, data_dir, srp-&gt;data.buffer,
+				hp-&gt;dxfer_len, srp-&gt;data.k_use_sg, timeout,
+				SG_DEFAULT_RETRIES, srp, sg_cmd_done,
+				GFP_ATOMIC)) {
+		SCSI_LOG_TIMEOUT(1, printk("sg_write: scsi_execute_async failed\n"));
+		/*
+		 * most likely out of mem, but could also be a bad map
+		 */
+		return -ENOMEM;
+	} else
+		return 0;
 }
 
 static int
@@ -1156,45 +1140,22 @@ sg_fasync(int fd, struct file *filp, int mode)
 	return (retval &lt; 0) ? retval : 0;
 }
 
-static inline unsigned char *
-sg_scatg2virt(const struct scatterlist *sclp)
-{
-	return (sclp &amp;&amp; sclp-&gt;page) ?
-	    (unsigned char *) page_address(sclp-&gt;page) + sclp-&gt;offset : NULL;
-}
-
 /* When startFinish==1 increments page counts for pages other than the 
-   first of scatter gather elements obtained from __get_free_pages().
+   first of scatter gather elements obtained from alloc_pages().
    When startFinish==0 decrements ... */
 static void
 sg_rb_correct4mmap(Sg_scatter_hold * rsv_schp, int startFinish)
 {
-	void *page_ptr;
+	struct scatterlist *sg = rsv_schp-&gt;buffer;
 	struct page *page;
 	int k, m;
 
 	SCSI_LOG_TIMEOUT(3, printk("sg_rb_correct4mmap: startFinish=%d, scatg=%d\n", 
 				   startFinish, rsv_schp-&gt;k_use_sg));
 	/* N.B. correction _not_ applied to base page of each allocation */
-	if (rsv_schp-&gt;k_use_sg) {	/* reserve buffer is a scatter gather list */
-		struct scatterlist *sclp = rsv_schp-&gt;buffer;
-
-		for (k = 0; k &lt; rsv_schp-&gt;k_use_sg; ++k, ++sclp) {
-			for (m = PAGE_SIZE; m &lt; sclp-&gt;length; m += PAGE_SIZE) {
-				page_ptr = sg_scatg2virt(sclp) + m;
-				page = virt_to_page(page_ptr);
-				if (startFinish)
-					get_page(page);
-				else {
-					if (page_count(page) &gt; 0)
-						__put_page(page);
-				}
-			}
-		}
-	} else {		/* reserve buffer is just a single allocation */
-		for (m = PAGE_SIZE; m &lt; rsv_schp-&gt;bufflen; m += PAGE_SIZE) {
-			page_ptr = (unsigned char *) rsv_schp-&gt;buffer + m;
-			page = virt_to_page(page_ptr);
+	for (k = 0; k &lt; rsv_schp-&gt;k_use_sg; ++k, ++sg) {
+		for (m = PAGE_SIZE; m &lt; sg-&gt;length; m += PAGE_SIZE) {
+			page = sg-&gt;page;
 			if (startFinish)
 				get_page(page);
 			else {
@@ -1210,9 +1171,10 @@ sg_vma_nopage(struct vm_area_struct *vma, unsigned long addr, int *type)
 {
 	Sg_fd *sfp;
 	struct page *page = NOPAGE_SIGBUS;
-	void *page_ptr = NULL;
-	unsigned long offset;
+	unsigned long offset, len, sa;
 	Sg_scatter_hold *rsv_schp;
+	struct scatterlist *sg;
+	int k;
 
 	if ((NULL == vma) || (!(sfp = (Sg_fd *) vma-&gt;vm_private_data)))
 		return page;
@@ -1222,30 +1184,21 @@ sg_vma_nopage(struct vm_area_struct *vma, unsigned long addr, int *type)
 		return page;
 	SCSI_LOG_TIMEOUT(3, printk("sg_vma_nopage: offset=%lu, scatg=%d\n",
 				   offset, rsv_schp-&gt;k_use_sg));
-	if (rsv_schp-&gt;k_use_sg) {	/* reserve buffer is a scatter gather list */
-		int k;
-		unsigned long sa = vma-&gt;vm_start;
-		unsigned long len;
-		struct scatterlist *sclp = rsv_schp-&gt;buffer;
-
-		for (k = 0; (k &lt; rsv_schp-&gt;k_use_sg) &amp;&amp; (sa &lt; vma-&gt;vm_end);
-		     ++k, ++sclp) {
-			len = vma-&gt;vm_end - sa;
-			len = (len &lt; sclp-&gt;length) ? len : sclp-&gt;length;
-			if (offset &lt; len) {
-				page_ptr = sg_scatg2virt(sclp) + offset;
-				page = virt_to_page(page_ptr);
-				get_page(page);	/* increment page count */
-				break;
-			}
-			sa += len;
-			offset -= len;
+	sg = rsv_schp-&gt;buffer;
+	sa = vma-&gt;vm_start;
+	for (k = 0; (k &lt; rsv_schp-&gt;k_use_sg) &amp;&amp; (sa &lt; vma-&gt;vm_end);
+	     ++k, ++sg) {
+		len = vma-&gt;vm_end - sa;
+		len = (len &lt; sg-&gt;length) ? len : sg-&gt;length;
+		if (offset &lt; len) {
+			page = sg-&gt;page;
+			get_page(page);	/* increment page count */
+			break;
 		}
-	} else {		/* reserve buffer is just a single allocation */
-		page_ptr = (unsigned char *) rsv_schp-&gt;buffer + offset;
-		page = virt_to_page(page_ptr);
-		get_page(page);	/* increment page count */
+		sa += len;
+		offset -= len;
 	}
+
 	if (type)
 		*type = VM_FAULT_MINOR;
 	return page;
@@ -1259,8 +1212,10 @@ static int
 sg_mmap(struct file *filp, struct vm_area_struct *vma)
 {
 	Sg_fd *sfp;
-	unsigned long req_sz;
+	unsigned long req_sz, len, sa;
 	Sg_scatter_hold *rsv_schp;
+	int k;
+	struct scatterlist *sg;
 
 	if ((!filp) || (!vma) || (!(sfp = (Sg_fd *) filp-&gt;private_data)))
 		return -ENXIO;
@@ -1273,24 +1228,15 @@ sg_mmap(struct file *filp, struct vm_area_struct *vma)
 	if (req_sz &gt; rsv_schp-&gt;bufflen)
 		return -ENOMEM;	/* cannot map more than reserved buffer */
 
-	if (rsv_schp-&gt;k_use_sg) { /* reserve buffer is a scatter gather list */
-		int k;
-		unsigned long sa = vma-&gt;vm_start;
-		unsigned long len;
-		struct scatterlist *sclp = rsv_schp-&gt;buffer;
-
-		for (k = 0; (k &lt; rsv_schp-&gt;k_use_sg) &amp;&amp; (sa &lt; vma-&gt;vm_end);
-		     ++k, ++sclp) {
-			if (0 != sclp-&gt;offset)
-				return -EFAULT;	/* non page aligned memory ?? */
-			len = vma-&gt;vm_end - sa;
-			len = (len &lt; sclp-&gt;length) ? len : sclp-&gt;length;
-			sa += len;
-		}
-	} else {	/* reserve buffer is just a single allocation */
-		if ((unsigned long) rsv_schp-&gt;buffer &amp; (PAGE_SIZE - 1))
-			return -EFAULT;	/* non page aligned memory ?? */
+	sa = vma-&gt;vm_start;
+	sg = rsv_schp-&gt;buffer;
+	for (k = 0; (k &lt; rsv_schp-&gt;k_use_sg) &amp;&amp; (sa &lt; vma-&gt;vm_end);
+	     ++k, ++sg) {
+		len = vma-&gt;vm_end - sa;
+		len = (len &lt; sg-&gt;length) ? len : sg-&gt;length;
+		sa += len;
 	}
+
 	if (0 == sfp-&gt;mmap_called) {
 		sg_rb_correct4mmap(rsv_schp, 1);	/* do only once per fd lifetime */
 		sfp-&gt;mmap_called = 1;
@@ -1304,21 +1250,16 @@ sg_mmap(struct file *filp, struct vm_area_struct *vma)
 /* This function is a "bottom half" handler that is called by the
  * mid level when a command is completed (or has failed). */
 static void
-sg_cmd_done(Scsi_Cmnd * SCpnt)
+sg_cmd_done(void *data, char *sense, int result, int resid)
 {
-	Scsi_Request *SRpnt = NULL;
+	Sg_request *srp = data;
 	Sg_device *sdp = NULL;
 	Sg_fd *sfp;
-	Sg_request *srp = NULL;
 	unsigned long iflags;
 	unsigned int ms;
 
-	if (SCpnt &amp;&amp; (SRpnt = SCpnt-&gt;sc_request))
-		srp = (Sg_request *) SRpnt-&gt;upper_private_data;
 	if (NULL == srp) {
 		printk(KERN_ERR "sg_cmd_done: NULL request\n");
-		if (SRpnt)
-			scsi_release_request(SRpnt);
 		return;
 	}
 	sfp = srp-&gt;parentfp;
@@ -1326,49 +1267,34 @@ sg_cmd_done(Scsi_Cmnd * SCpnt)
 		sdp = sfp-&gt;parentdp;
 	if ((NULL == sdp) || sdp-&gt;detached) {
 		printk(KERN_INFO "sg_cmd_done: device detached\n");
-		scsi_release_request(SRpnt);
 		return;
 	}
 
-	/* First transfer ownership of data buffers to sg_device object. */
-	srp-&gt;data.k_use_sg = SRpnt-&gt;sr_use_sg;
-	srp-&gt;data.sglist_len = SRpnt-&gt;sr_sglist_len;
-	srp-&gt;data.bufflen = SRpnt-&gt;sr_bufflen;
-	srp-&gt;data.buffer = SRpnt-&gt;sr_buffer;
-	/* now clear out request structure */
-	SRpnt-&gt;sr_use_sg = 0;
-	SRpnt-&gt;sr_sglist_len = 0;
-	SRpnt-&gt;sr_bufflen = 0;
-	SRpnt-&gt;sr_buffer = NULL;
-	SRpnt-&gt;sr_underflow = 0;
-	SRpnt-&gt;sr_request-&gt;rq_disk = NULL; /* "sg" _disowns_ request blk */
-
-	srp-&gt;my_cmdp = NULL;
 
 	SCSI_LOG_TIMEOUT(4, printk("sg_cmd_done: %s, pack_id=%d, res=0x%x\n",
-		sdp-&gt;disk-&gt;disk_name, srp-&gt;header.pack_id, (int) SRpnt-&gt;sr_result));
-	srp-&gt;header.resid = SCpnt-&gt;resid;
+		sdp-&gt;disk-&gt;disk_name, srp-&gt;header.pack_id, result));
+	srp-&gt;header.resid = resid;
 	ms = jiffies_to_msecs(jiffies);
 	srp-&gt;header.duration = (ms &gt; srp-&gt;header.duration) ?
 				(ms - srp-&gt;header.duration) : 0;
-	if (0 != SRpnt-&gt;sr_result) {
+	if (0 != result) {
 		struct scsi_sense_hdr sshdr;
 
-		memcpy(srp-&gt;sense_b, SRpnt-&gt;sr_sense_buffer,
-		       sizeof (srp-&gt;sense_b));
-		srp-&gt;header.status = 0xff &amp; SRpnt-&gt;sr_result;
-		srp-&gt;header.masked_status = status_byte(SRpnt-&gt;sr_result);
-		srp-&gt;header.msg_status = msg_byte(SRpnt-&gt;sr_result);
-		srp-&gt;header.host_status = host_byte(SRpnt-&gt;sr_result);
-		srp-&gt;header.driver_status = driver_byte(SRpnt-&gt;sr_result);
+		memcpy(srp-&gt;sense_b, sense, sizeof (srp-&gt;sense_b));
+		srp-&gt;header.status = 0xff &amp; result;
+		srp-&gt;header.masked_status = status_byte(result);
+		srp-&gt;header.msg_status = msg_byte(result);
+		srp-&gt;header.host_status = host_byte(result);
+		srp-&gt;header.driver_status = driver_byte(result);
 		if ((sdp-&gt;sgdebug &gt; 0) &amp;&amp;
 		    ((CHECK_CONDITION == srp-&gt;header.masked_status) ||
 		     (COMMAND_TERMINATED == srp-&gt;header.masked_status)))
-			scsi_print_req_sense("sg_cmd_done", SRpnt);
+			__scsi_print_sense("sg_cmd_done", sense,
+					   SCSI_SENSE_BUFFERSIZE);
 
 		/* Following if statement is a patch supplied by Eric Youngdale */
-		if (driver_byte(SRpnt-&gt;sr_result) != 0
-		    &amp;&amp; scsi_command_normalize_sense(SCpnt, &amp;sshdr)
+		if (driver_byte(result) != 0
+		    &amp;&amp; scsi_normalize_sense(sense, SCSI_SENSE_BUFFERSIZE, &amp;sshdr)
 		    &amp;&amp; !scsi_sense_is_deferred(&amp;sshdr)
 		    &amp;&amp; sshdr.sense_key == UNIT_ATTENTION
 		    &amp;&amp; sdp-&gt;device-&gt;removable) {
@@ -1379,8 +1305,6 @@ sg_cmd_done(Scsi_Cmnd * SCpnt)
 	}
 	/* Rely on write phase to clean out srp status values, so no "else" */
 
-	scsi_release_request(SRpnt);
-	SRpnt = NULL;
 	if (sfp-&gt;closed) {	/* whoops this fd already released, cleanup */
 		SCSI_LOG_TIMEOUT(1, printk("sg_cmd_done: already closed, freeing ...\n"));
 		sg_finish_rem_req(srp);
@@ -1431,6 +1355,7 @@ static int sg_sysfs_valid = 0;
 
 static int sg_alloc(struct gendisk *disk, struct scsi_device *scsidp)
 {
+	struct request_queue *q = scsidp-&gt;request_queue;
 	Sg_device *sdp;
 	unsigned long iflags;
 	void *old_sg_dev_arr = NULL;
@@ -1473,7 +1398,7 @@ static int sg_alloc(struct gendisk *disk, struct scsi_device *scsidp)
 	sdp-&gt;disk = disk;
 	sdp-&gt;device = scsidp;
 	init_waitqueue_head(&amp;sdp-&gt;o_excl_wait);
-	sdp-&gt;sg_tablesize = scsidp-&gt;host ? scsidp-&gt;host-&gt;sg_tablesize : 0;
+	sdp-&gt;sg_tablesize = min(q-&gt;max_hw_segments, q-&gt;max_phys_segments);
 
 	sg_nr_dev++;
 	sg_dev_arr[k] = sdp;
@@ -1753,36 +1678,35 @@ sg_finish_rem_req(Sg_request * srp)
 static int
 sg_build_sgat(Sg_scatter_hold * schp, const Sg_fd * sfp, int tablesize)
 {
-	int ret_sz;
-	int elem_sz = sizeof (struct scatterlist);
-	int sg_bufflen = tablesize * elem_sz;
-	int mx_sc_elems = tablesize;
+	int sg_bufflen = tablesize * sizeof(struct scatterlist);
+	unsigned int gfp_flags = GFP_ATOMIC | __GFP_NOWARN;
 
-	schp-&gt;buffer = sg_page_malloc(sg_bufflen, sfp-&gt;low_dma, &amp;ret_sz);
+	/*
+	 * TODO: test without low_dma, we should not need it since
+	 * the block layer will bounce the buffer for us
+	 *
+	 * XXX(hch): we shouldn't need GFP_DMA for the actual S/G list.
+	 */
+	if (sfp-&gt;low_dma)
+		 gfp_flags |= GFP_DMA;
+	schp-&gt;buffer = kzalloc(sg_bufflen, gfp_flags);
 	if (!schp-&gt;buffer)
 		return -ENOMEM;
-	else if (ret_sz != sg_bufflen) {
-		sg_bufflen = ret_sz;
-		mx_sc_elems = sg_bufflen / elem_sz;
-	}
 	schp-&gt;sglist_len = sg_bufflen;
-	memset(schp-&gt;buffer, 0, sg_bufflen);
-	return mx_sc_elems;	/* number of scat_gath elements allocated */
+	return tablesize;	/* number of scat_gath elements allocated */
 }
 
 #ifdef SG_ALLOW_DIO_CODE
 /* vvvvvvvv  following code borrowed from st driver's direct IO vvvvvvvvv */
-	/* hopefully this generic code will moved to a library */
+	/* TODO: hopefully we can use the generic block layer code */
 
 /* Pin down user pages and put them into a scatter gather list. Returns &lt;= 0 if
    - mapping of all pages not successful
-   - any page is above max_pfn
    (i.e., either completely successful or fails)
 */
 static int 
 st_map_user_pages(struct scatterlist *sgl, const unsigned int max_pages, 
-	          unsigned long uaddr, size_t count, int rw,
-	          unsigned long max_pfn)
+	          unsigned long uaddr, size_t count, int rw)
 {
 	unsigned long end = (uaddr + count + PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;
 	unsigned long start = uaddr &gt;&gt; PAGE_SHIFT;
@@ -1828,21 +1752,17 @@ st_map_user_pages(struct scatterlist *sgl, const unsigned int max_pages,
                  * probably wrong function for rw==WRITE
                  */
 		flush_dcache_page(pages[i]);
-		if (page_to_pfn(pages[i]) &gt; max_pfn)
-			goto out_unlock;
 		/* ?? Is locking needed? I don't think so */
 		/* if (TestSetPageLocked(pages[i]))
 		   goto out_unlock; */
         }
 
-	/* Populate the scatter/gather list */
-	sgl[0].page = pages[0]; 
+	sgl[0].page = pages[0];
 	sgl[0].offset = uaddr &amp; ~PAGE_MASK;
 	if (nr_pages &gt; 1) {
 		sgl[0].length = PAGE_SIZE - sgl[0].offset;
 		count -= sgl[0].length;
 		for (i=1; i &lt; nr_pages ; i++) {
-			sgl[i].offset = 0;
 			sgl[i].page = pages[i]; 
 			sgl[i].length = count &lt; PAGE_SIZE ? count : PAGE_SIZE;
 			count -= PAGE_SIZE;
@@ -1855,10 +1775,6 @@ st_map_user_pages(struct scatterlist *sgl, const unsigned int max_pages,
 	kfree(pages);
 	return nr_pages;
 
- out_unlock:
-	/* for (j=0; j &lt; i; j++)
-	   unlock_page(pages[j]); */
-	res = 0;
  out_unmap:
 	if (res &gt; 0) {
 		for (j=0; j &lt; res; j++)
@@ -1904,20 +1820,20 @@ sg_build_direct(Sg_request * srp, Sg_fd * sfp, int dxfer_len)
 	sg_io_hdr_t *hp = &amp;srp-&gt;header;
 	Sg_scatter_hold *schp = &amp;srp-&gt;data;
 	int sg_tablesize = sfp-&gt;parentdp-&gt;sg_tablesize;
-	struct scatterlist *sgl;
 	int mx_sc_elems, res;
 	struct scsi_device *sdev = sfp-&gt;parentdp-&gt;device;
 
 	if (((unsigned long)hp-&gt;dxferp &amp;
 			queue_dma_alignment(sdev-&gt;request_queue)) != 0)
 		return 1;
+
 	mx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);
         if (mx_sc_elems &lt;= 0) {
                 return 1;
         }
-	sgl = (struct scatterlist *)schp-&gt;buffer;
-	res = st_map_user_pages(sgl, mx_sc_elems, (unsigned long)hp-&gt;dxferp, dxfer_len, 
-				(SG_DXFER_TO_DEV == hp-&gt;dxfer_direction) ? 1 : 0, ULONG_MAX);
+	res = st_map_user_pages(schp-&gt;buffer, mx_sc_elems,
+				(unsigned long)hp-&gt;dxferp, dxfer_len, 
+				(SG_DXFER_TO_DEV == hp-&gt;dxfer_direction) ? 1 : 0);
 	if (res &lt;= 0)
 		return 1;
 	schp-&gt;k_use_sg = res;
@@ -1932,9 +1848,11 @@ sg_build_direct(Sg_request * srp, Sg_fd * sfp, int dxfer_len)
 static int
 sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)
 {
-	int ret_sz;
+	struct scatterlist *sg;
+	int ret_sz = 0, k, rem_sz, num, mx_sc_elems;
+	int sg_tablesize = sfp-&gt;parentdp-&gt;sg_tablesize;
 	int blk_size = buff_size;
-	unsigned char *p = NULL;
+	struct page *p = NULL;
 
 	if ((blk_size &lt; 0) || (!sfp))
 		return -EFAULT;
@@ -1944,59 +1862,35 @@ sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)
 	blk_size = (blk_size + SG_SECTOR_MSK) &amp; (~SG_SECTOR_MSK);
 	SCSI_LOG_TIMEOUT(4, printk("sg_build_indirect: buff_size=%d, blk_size=%d\n",
 				   buff_size, blk_size));
-	if (blk_size &lt;= SG_SCATTER_SZ) {
-		p = sg_page_malloc(blk_size, sfp-&gt;low_dma, &amp;ret_sz);
-		if (!p)
-			return -ENOMEM;
-		if (blk_size == ret_sz) {	/* got it on the first attempt */
-			schp-&gt;k_use_sg = 0;
-			schp-&gt;buffer = p;
-			schp-&gt;bufflen = blk_size;
-			schp-&gt;b_malloc_len = blk_size;
-			return 0;
-		}
-	} else {
-		p = sg_page_malloc(SG_SCATTER_SZ, sfp-&gt;low_dma, &amp;ret_sz);
+
+	/* N.B. ret_sz carried into this block ... */
+	mx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);
+	if (mx_sc_elems &lt; 0)
+		return mx_sc_elems;	/* most likely -ENOMEM */
+
+	for (k = 0, sg = schp-&gt;buffer, rem_sz = blk_size;
+	     (rem_sz &gt; 0) &amp;&amp; (k &lt; mx_sc_elems);
+	     ++k, rem_sz -= ret_sz, ++sg) {
+		
+		num = (rem_sz &gt; SG_SCATTER_SZ) ? SG_SCATTER_SZ : rem_sz;
+		p = sg_page_malloc(num, sfp-&gt;low_dma, &amp;ret_sz);
 		if (!p)
 			return -ENOMEM;
-	}
-/* Want some local declarations, so start new block ... */
-	{			/* lets try and build a scatter gather list */
-		struct scatterlist *sclp;
-		int k, rem_sz, num;
-		int mx_sc_elems;
-		int sg_tablesize = sfp-&gt;parentdp-&gt;sg_tablesize;
-		int first = 1;
-
-		/* N.B. ret_sz carried into this block ... */
-		mx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);
-		if (mx_sc_elems &lt; 0)
-			return mx_sc_elems;	/* most likely -ENOMEM */
-
-		for (k = 0, sclp = schp-&gt;buffer, rem_sz = blk_size;
-		     (rem_sz &gt; 0) &amp;&amp; (k &lt; mx_sc_elems);
-		     ++k, rem_sz -= ret_sz, ++sclp) {
-			if (first)
-				first = 0;
-			else {
-				num =
-				    (rem_sz &gt;
-				     SG_SCATTER_SZ) ? SG_SCATTER_SZ : rem_sz;
-				p = sg_page_malloc(num, sfp-&gt;low_dma, &amp;ret_sz);
-				if (!p)
-					break;
-			}
-			sg_set_buf(sclp, p, ret_sz);
-
-			SCSI_LOG_TIMEOUT(5, printk("sg_build_build: k=%d, a=0x%p, len=%d\n",
-					  k, sg_scatg2virt(sclp), ret_sz));
-		}		/* end of for loop */
-		schp-&gt;k_use_sg = k;
-		SCSI_LOG_TIMEOUT(5, printk("sg_build_indirect: k_use_sg=%d, rem_sz=%d\n", k, rem_sz));
-		schp-&gt;bufflen = blk_size;
-		if (rem_sz &gt; 0)	/* must have failed */
-			return -ENOMEM;
-	}
+
+		sg-&gt;page = p;
+		sg-&gt;length = ret_sz;
+
+		SCSI_LOG_TIMEOUT(5, printk("sg_build_build: k=%d, a=0x%p, len=%d\n",
+				  k, p, ret_sz));
+	}		/* end of for loop */
+
+	schp-&gt;k_use_sg = k;
+	SCSI_LOG_TIMEOUT(5, printk("sg_build_indirect: k_use_sg=%d, rem_sz=%d\n", k, rem_sz));
+
+	schp-&gt;bufflen = blk_size;
+	if (rem_sz &gt; 0)	/* must have failed */
+		return -ENOMEM;
+
 	return 0;
 }
 
@@ -2005,6 +1899,7 @@ sg_write_xfer(Sg_request * srp)
 {
 	sg_io_hdr_t *hp = &amp;srp-&gt;header;
 	Sg_scatter_hold *schp = &amp;srp-&gt;data;
+	struct scatterlist *sg = schp-&gt;buffer;
 	int num_xfer = 0;
 	int j, k, onum, usglen, ksglen, res;
 	int iovec_count = (int) hp-&gt;iovec_count;
@@ -2033,63 +1928,45 @@ sg_write_xfer(Sg_request * srp)
 	} else
 		onum = 1;
 
-	if (0 == schp-&gt;k_use_sg) {	/* kernel has single buffer */
-		for (j = 0, p = schp-&gt;buffer; j &lt; onum; ++j) {
-			res = sg_u_iovec(hp, iovec_count, j, 1, &amp;usglen, &amp;up);
-			if (res)
-				return res;
-			usglen = (num_xfer &gt; usglen) ? usglen : num_xfer;
-			if (__copy_from_user(p, up, usglen))
-				return -EFAULT;
-			p += usglen;
-			num_xfer -= usglen;
-			if (num_xfer &lt;= 0)
-				return 0;
-		}
-	} else {		/* kernel using scatter gather list */
-		struct scatterlist *sclp = (struct scatterlist *) schp-&gt;buffer;
-
-		ksglen = (int) sclp-&gt;length;
-		p = sg_scatg2virt(sclp);
-		for (j = 0, k = 0; j &lt; onum; ++j) {
-			res = sg_u_iovec(hp, iovec_count, j, 1, &amp;usglen, &amp;up);
-			if (res)
-				return res;
-
-			for (; p; ++sclp, ksglen = (int) sclp-&gt;length,
-				  p = sg_scatg2virt(sclp)) {
-				if (usglen &lt;= 0)
-					break;
-				if (ksglen &gt; usglen) {
-					if (usglen &gt;= num_xfer) {
-						if (__copy_from_user
-						    (p, up, num_xfer))
-							return -EFAULT;
-						return 0;
-					}
-					if (__copy_from_user(p, up, usglen))
-						return -EFAULT;
-					p += usglen;
-					ksglen -= usglen;
-					break;
-				} else {
-					if (ksglen &gt;= num_xfer) {
-						if (__copy_from_user
-						    (p, up, num_xfer))
-							return -EFAULT;
-						return 0;
-					}
-					if (__copy_from_user(p, up, ksglen))
+	ksglen = sg-&gt;length;
+	p = page_address(sg-&gt;page);
+	for (j = 0, k = 0; j &lt; onum; ++j) {
+		res = sg_u_iovec(hp, iovec_count, j, 1, &amp;usglen, &amp;up);
+		if (res)
+			return res;
+
+		for (; p; ++sg, ksglen = sg-&gt;length,
+		     p = page_address(sg-&gt;page)) {
+			if (usglen &lt;= 0)
+				break;
+			if (ksglen &gt; usglen) {
+				if (usglen &gt;= num_xfer) {
+					if (__copy_from_user(p, up, num_xfer))
 						return -EFAULT;
-					up += ksglen;
-					usglen -= ksglen;
+					return 0;
 				}
-				++k;
-				if (k &gt;= schp-&gt;k_use_sg)
+				if (__copy_from_user(p, up, usglen))
+					return -EFAULT;
+				p += usglen;
+				ksglen -= usglen;
+				break;
+			} else {
+				if (ksglen &gt;= num_xfer) {
+					if (__copy_from_user(p, up, num_xfer))
+						return -EFAULT;
 					return 0;
+				}
+				if (__copy_from_user(p, up, ksglen))
+					return -EFAULT;
+				up += ksglen;
+				usglen -= ksglen;
 			}
+			++k;
+			if (k &gt;= schp-&gt;k_use_sg)
+				return 0;
 		}
 	}
+
 	return 0;
 }
 
@@ -2127,29 +2004,25 @@ sg_remove_scat(Sg_scatter_hold * schp)
 {
 	SCSI_LOG_TIMEOUT(4, printk("sg_remove_scat: k_use_sg=%d\n", schp-&gt;k_use_sg));
 	if (schp-&gt;buffer &amp;&amp; (schp-&gt;sglist_len &gt; 0)) {
-		struct scatterlist *sclp = (struct scatterlist *) schp-&gt;buffer;
+		struct scatterlist *sg = schp-&gt;buffer;
 
 		if (schp-&gt;dio_in_use) {
 #ifdef SG_ALLOW_DIO_CODE
-			st_unmap_user_pages(sclp, schp-&gt;k_use_sg, TRUE);
+			st_unmap_user_pages(sg, schp-&gt;k_use_sg, TRUE);
 #endif
 		} else {
 			int k;
 
-			for (k = 0; (k &lt; schp-&gt;k_use_sg) &amp;&amp; sg_scatg2virt(sclp);
-			     ++k, ++sclp) {
+			for (k = 0; (k &lt; schp-&gt;k_use_sg) &amp;&amp; sg-&gt;page;
+			     ++k, ++sg) {
 				SCSI_LOG_TIMEOUT(5, printk(
 				    "sg_remove_scat: k=%d, a=0x%p, len=%d\n",
-				    k, sg_scatg2virt(sclp), sclp-&gt;length));
-				sg_page_free(sg_scatg2virt(sclp), sclp-&gt;length);
-				sclp-&gt;page = NULL;
-				sclp-&gt;offset = 0;
-				sclp-&gt;length = 0;
+				    k, sg-&gt;page, sg-&gt;length));
+				sg_page_free(sg-&gt;page, sg-&gt;length);
 			}
 		}
-		sg_page_free(schp-&gt;buffer, schp-&gt;sglist_len);
-	} else if (schp-&gt;buffer)
-		sg_page_free(schp-&gt;buffer, schp-&gt;b_malloc_len);
+		kfree(schp-&gt;buffer);
+	}
 	memset(schp, 0, sizeof (*schp));
 }
 
@@ -2158,6 +2031,7 @@ sg_read_xfer(Sg_request * srp)
 {
 	sg_io_hdr_t *hp = &amp;srp-&gt;header;
 	Sg_scatter_hold *schp = &amp;srp-&gt;data;
+	struct scatterlist *sg = schp-&gt;buffer;
 	int num_xfer = 0;
 	int j, k, onum, usglen, ksglen, res;
 	int iovec_count = (int) hp-&gt;iovec_count;
@@ -2186,63 +2060,45 @@ sg_read_xfer(Sg_request * srp)
 	} else
 		onum = 1;
 
-	if (0 == schp-&gt;k_use_sg) {	/* kernel has single buffer */
-		for (j = 0, p = schp-&gt;buffer; j &lt; onum; ++j) {
-			res = sg_u_iovec(hp, iovec_count, j, 0, &amp;usglen, &amp;up);
-			if (res)
-				return res;
-			usglen = (num_xfer &gt; usglen) ? usglen : num_xfer;
-			if (__copy_to_user(up, p, usglen))
-				return -EFAULT;
-			p += usglen;
-			num_xfer -= usglen;
-			if (num_xfer &lt;= 0)
-				return 0;
-		}
-	} else {		/* kernel using scatter gather list */
-		struct scatterlist *sclp = (struct scatterlist *) schp-&gt;buffer;
-
-		ksglen = (int) sclp-&gt;length;
-		p = sg_scatg2virt(sclp);
-		for (j = 0, k = 0; j &lt; onum; ++j) {
-			res = sg_u_iovec(hp, iovec_count, j, 0, &amp;usglen, &amp;up);
-			if (res)
-				return res;
-
-			for (; p; ++sclp, ksglen = (int) sclp-&gt;length,
-				  p = sg_scatg2virt(sclp)) {
-				if (usglen &lt;= 0)
-					break;
-				if (ksglen &gt; usglen) {
-					if (usglen &gt;= num_xfer) {
-						if (__copy_to_user
-						    (up, p, num_xfer))
-							return -EFAULT;
-						return 0;
-					}
-					if (__copy_to_user(up, p, usglen))
-						return -EFAULT;
-					p += usglen;
-					ksglen -= usglen;
-					break;
-				} else {
-					if (ksglen &gt;= num_xfer) {
-						if (__copy_to_user
-						    (up, p, num_xfer))
-							return -EFAULT;
-						return 0;
-					}
-					if (__copy_to_user(up, p, ksglen))
+	p = page_address(sg-&gt;page);
+	ksglen = sg-&gt;length;
+	for (j = 0, k = 0; j &lt; onum; ++j) {
+		res = sg_u_iovec(hp, iovec_count, j, 0, &amp;usglen, &amp;up);
+		if (res)
+			return res;
+
+		for (; p; ++sg, ksglen = sg-&gt;length,
+		     p = page_address(sg-&gt;page)) {
+			if (usglen &lt;= 0)
+				break;
+			if (ksglen &gt; usglen) {
+				if (usglen &gt;= num_xfer) {
+					if (__copy_to_user(up, p, num_xfer))
 						return -EFAULT;
-					up += ksglen;
-					usglen -= ksglen;
+					return 0;
 				}
-				++k;
-				if (k &gt;= schp-&gt;k_use_sg)
+				if (__copy_to_user(up, p, usglen))
+					return -EFAULT;
+				p += usglen;
+				ksglen -= usglen;
+				break;
+			} else {
+				if (ksglen &gt;= num_xfer) {
+					if (__copy_to_user(up, p, num_xfer))
+						return -EFAULT;
 					return 0;
+				}
+				if (__copy_to_user(up, p, ksglen))
+					return -EFAULT;
+				up += ksglen;
+				usglen -= ksglen;
 			}
+			++k;
+			if (k &gt;= schp-&gt;k_use_sg)
+				return 0;
 		}
 	}
+
 	return 0;
 }
 
@@ -2250,37 +2106,32 @@ static int
 sg_read_oxfer(Sg_request * srp, char __user *outp, int num_read_xfer)
 {
 	Sg_scatter_hold *schp = &amp;srp-&gt;data;
+	struct scatterlist *sg = schp-&gt;buffer;
+	int k, num;
 
 	SCSI_LOG_TIMEOUT(4, printk("sg_read_oxfer: num_read_xfer=%d\n",
 				   num_read_xfer));
 	if ((!outp) || (num_read_xfer &lt;= 0))
 		return 0;
-	if (schp-&gt;k_use_sg &gt; 0) {
-		int k, num;
-		struct scatterlist *sclp = (struct scatterlist *) schp-&gt;buffer;
-
-		for (k = 0; (k &lt; schp-&gt;k_use_sg) &amp;&amp; sg_scatg2virt(sclp);
-		     ++k, ++sclp) {
-			num = (int) sclp-&gt;length;
-			if (num &gt; num_read_xfer) {
-				if (__copy_to_user
-				    (outp, sg_scatg2virt(sclp), num_read_xfer))
-					return -EFAULT;
+
+	for (k = 0; (k &lt; schp-&gt;k_use_sg) &amp;&amp; sg-&gt;page; ++k, ++sg) {
+		num = sg-&gt;length;
+		if (num &gt; num_read_xfer) {
+			if (__copy_to_user(outp, page_address(sg-&gt;page),
+					   num_read_xfer))
+				return -EFAULT;
+			break;
+		} else {
+			if (__copy_to_user(outp, page_address(sg-&gt;page),
+					   num))
+				return -EFAULT;
+			num_read_xfer -= num;
+			if (num_read_xfer &lt;= 0)
 				break;
-			} else {
-				if (__copy_to_user
-				    (outp, sg_scatg2virt(sclp), num))
-					return -EFAULT;
-				num_read_xfer -= num;
-				if (num_read_xfer &lt;= 0)
-					break;
-				outp += num;
-			}
+			outp += num;
 		}
-	} else {
-		if (__copy_to_user(outp, schp-&gt;buffer, num_read_xfer))
-			return -EFAULT;
 	}
+
 	return 0;
 }
 
@@ -2306,44 +2157,31 @@ sg_link_reserve(Sg_fd * sfp, Sg_request * srp, int size)
 {
 	Sg_scatter_hold *req_schp = &amp;srp-&gt;data;
 	Sg_scatter_hold *rsv_schp = &amp;sfp-&gt;reserve;
+	struct scatterlist *sg = rsv_schp-&gt;buffer;
+	int k, num, rem;
 
 	srp-&gt;res_used = 1;
 	SCSI_LOG_TIMEOUT(4, printk("sg_link_reserve: size=%d\n", size));
-	size = (size + 1) &amp; (~1);	/* round to even for aha1542 */
-	if (rsv_schp-&gt;k_use_sg &gt; 0) {
-		int k, num;
-		int rem = size;
-		struct scatterlist *sclp =
-		    (struct scatterlist *) rsv_schp-&gt;buffer;
-
-		for (k = 0; k &lt; rsv_schp-&gt;k_use_sg; ++k, ++sclp) {
-			num = (int) sclp-&gt;length;
-			if (rem &lt;= num) {
-				if (0 == k) {
-					req_schp-&gt;k_use_sg = 0;
-					req_schp-&gt;buffer = sg_scatg2virt(sclp);
-				} else {
-					sfp-&gt;save_scat_len = num;
-					sclp-&gt;length = (unsigned) rem;
-					req_schp-&gt;k_use_sg = k + 1;
-					req_schp-&gt;sglist_len =
-					    rsv_schp-&gt;sglist_len;
-					req_schp-&gt;buffer = rsv_schp-&gt;buffer;
-				}
-				req_schp-&gt;bufflen = size;
-				req_schp-&gt;b_malloc_len = rsv_schp-&gt;b_malloc_len;
-				break;
-			} else
-				rem -= num;
-		}
-		if (k &gt;= rsv_schp-&gt;k_use_sg)
-			SCSI_LOG_TIMEOUT(1, printk("sg_link_reserve: BAD size\n"));
-	} else {
-		req_schp-&gt;k_use_sg = 0;
-		req_schp-&gt;bufflen = size;
-		req_schp-&gt;buffer = rsv_schp-&gt;buffer;
-		req_schp-&gt;b_malloc_len = rsv_schp-&gt;b_malloc_len;
+	rem = size = (size + 1) &amp; (~1);	/* round to even for aha1542 */
+
+	for (k = 0; k &lt; rsv_schp-&gt;k_use_sg; ++k, ++sg) {
+		num = sg-&gt;length;
+		if (rem &lt;= num) {
+			sfp-&gt;save_scat_len = num;
+			sg-&gt;length = rem;
+			req_schp-&gt;k_use_sg = k + 1;
+			req_schp-&gt;sglist_len = rsv_schp-&gt;sglist_len;
+			req_schp-&gt;buffer = rsv_schp-&gt;buffer;
+
+			req_schp-&gt;bufflen = size;
+			req_schp-&gt;b_malloc_len = rsv_schp-&gt;b_malloc_len;
+			break;
+		} else
+			rem -= num;
 	}
+
+	if (k &gt;= rsv_schp-&gt;k_use_sg)
+		SCSI_LOG_TIMEOUT(1, printk("sg_link_reserve: BAD size\n"));
 }
 
 static void
@@ -2355,11 +2193,10 @@ sg_unlink_reserve(Sg_fd * sfp, Sg_request * srp)
 	SCSI_LOG_TIMEOUT(4, printk("sg_unlink_reserve: req-&gt;k_use_sg=%d\n",
 				   (int) req_schp-&gt;k_use_sg));
 	if ((rsv_schp-&gt;k_use_sg &gt; 0) &amp;&amp; (req_schp-&gt;k_use_sg &gt; 0)) {
-		struct scatterlist *sclp =
-		    (struct scatterlist *) rsv_schp-&gt;buffer;
+		struct scatterlist *sg = rsv_schp-&gt;buffer;
 
 		if (sfp-&gt;save_scat_len &gt; 0)
-			(sclp + (req_schp-&gt;k_use_sg - 1))-&gt;length =
+			(sg + (req_schp-&gt;k_use_sg - 1))-&gt;length =
 			    (unsigned) sfp-&gt;save_scat_len;
 		else
 			SCSI_LOG_TIMEOUT(1, printk ("sg_unlink_reserve: BAD save_scat_len\n"));
@@ -2445,7 +2282,6 @@ sg_add_request(Sg_fd * sfp)
 	if (resp) {
 		resp-&gt;nextrp = NULL;
 		resp-&gt;header.duration = jiffies_to_msecs(jiffies);
-		resp-&gt;my_cmdp = NULL;
 	}
 	write_unlock_irqrestore(&amp;sfp-&gt;rq_list_lock, iflags);
 	return resp;
@@ -2463,8 +2299,6 @@ sg_remove_request(Sg_fd * sfp, Sg_request * srp)
 	if ((!sfp) || (!srp) || (!sfp-&gt;headrp))
 		return res;
 	write_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
-	if (srp-&gt;my_cmdp)
-		srp-&gt;my_cmdp-&gt;upper_private_data = NULL;
 	prev_rp = sfp-&gt;headrp;
 	if (srp == prev_rp) {
 		sfp-&gt;headrp = prev_rp-&gt;nextrp;
@@ -2507,10 +2341,10 @@ sg_add_sfp(Sg_device * sdp, int dev)
 	Sg_fd *sfp;
 	unsigned long iflags;
 
-	sfp = (Sg_fd *) sg_page_malloc(sizeof (Sg_fd), 0, NULL);
+	sfp = kzalloc(sizeof(*sfp), GFP_ATOMIC | __GFP_NOWARN);
 	if (!sfp)
 		return NULL;
-	memset(sfp, 0, sizeof (Sg_fd));
+
 	init_waitqueue_head(&amp;sfp-&gt;read_wait);
 	rwlock_init(&amp;sfp-&gt;rq_list_lock);
 
@@ -2567,7 +2401,7 @@ __sg_remove_sfp(Sg_device * sdp, Sg_fd * sfp)
 	}
 	sfp-&gt;parentdp = NULL;
 	SCSI_LOG_TIMEOUT(6, printk("__sg_remove_sfp:    sfp=0x%p\n", sfp));
-	sg_page_free((char *) sfp, sizeof (Sg_fd));
+	kfree(sfp);
 }
 
 /* Returns 0 in normal case, 1 when detached and sdp object removed */
@@ -2632,10 +2466,10 @@ sg_res_in_use(Sg_fd * sfp)
 }
 
 /* If retSzp==NULL want exact size or fail */
-static char *
+static struct page *
 sg_page_malloc(int rqSz, int lowDma, int *retSzp)
 {
-	char *resp = NULL;
+	struct page *resp = NULL;
 	gfp_t page_mask;
 	int order, a_size;
 	int resSz = rqSz;
@@ -2650,11 +2484,11 @@ sg_page_malloc(int rqSz, int lowDma, int *retSzp)
 
 	for (order = 0, a_size = PAGE_SIZE; a_size &lt; rqSz;
 	     order++, a_size &lt;&lt;= 1) ;
-	resp = (char *) __get_free_pages(page_mask, order);
+	resp = alloc_pages(page_mask, order);
 	while ((!resp) &amp;&amp; order &amp;&amp; retSzp) {
 		--order;
 		a_size &gt;&gt;= 1;	/* divide by 2, until PAGE_SIZE */
-		resp = (char *) __get_free_pages(page_mask, order);	/* try half */
+		resp =  alloc_pages(page_mask, order);	/* try half */
 		resSz = a_size;
 	}
 	if (resp) {
@@ -2667,15 +2501,15 @@ sg_page_malloc(int rqSz, int lowDma, int *retSzp)
 }
 
 static void
-sg_page_free(char *buff, int size)
+sg_page_free(struct page *page, int size)
 {
 	int order, a_size;
 
-	if (!buff)
+	if (!page)
 		return;
 	for (order = 0, a_size = PAGE_SIZE; a_size &lt; size;
 	     order++, a_size &lt;&lt;= 1) ;
-	free_pages((unsigned long) buff, order);
+	__free_pages(page, order);
 }
 
 #ifndef MAINTENANCE_IN_CMD
@@ -3067,13 +2901,11 @@ static void sg_proc_debug_helper(struct seq_file *s, Sg_device * sdp)
 					cp = "     ";
 			}
 			seq_printf(s, cp);
-			blen = srp-&gt;my_cmdp ? 
-				srp-&gt;my_cmdp-&gt;sr_bufflen : srp-&gt;data.bufflen;
-			usg = srp-&gt;my_cmdp ? 
-				srp-&gt;my_cmdp-&gt;sr_use_sg : srp-&gt;data.k_use_sg;
+			blen = srp-&gt;data.bufflen;
+			usg = srp-&gt;data.k_use_sg;
 			seq_printf(s, srp-&gt;done ? 
 				   ((1 == srp-&gt;done) ?  "rcv:" : "fin:")
-				   : (srp-&gt;my_cmdp ? "act:" : "prior:"));
+				   : "act:");
 			seq_printf(s, " id=%d blen=%d",
 				   srp-&gt;header.pack_id, blen);
 			if (srp-&gt;done)</pre>
    <div class="pagination">
        <a href='5_41.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><span>[42]</span><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_43.html'>Next&gt;&gt;</a>
    <div>
</body>
