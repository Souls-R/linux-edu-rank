<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_130.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><span>[131]</span><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_132.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fa3465689f93331834a831bbe98e3863701e1068
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 30 11:57:51 2005 -0500

    [PATCH] USB: UHCI: change uhci_explen macro
    
    This patch (as616) changed the uhci_explen macro in uhci-hcd.h so that
    it now accepts the desired length, rather than length - 1 with special
    handling for 0.  This also fixes a minor bug that would show up only
    when a driver submits a 0-length bulk URB.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 071fab6b6475..120ca64fe3f7 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -566,7 +566,7 @@ static int uhci_start(struct usb_hcd *hcd)
 	uhci-&gt;skel_bulk_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_term_qh-&gt;dma_handle) | UHCI_PTR_QH;
 
 	/* This dummy TD is to work around a bug in Intel PIIX controllers */
-	uhci_fill_td(uhci-&gt;term_td, 0, (UHCI_NULL_DATA_SIZE &lt;&lt; 21) |
+	uhci_fill_td(uhci-&gt;term_td, 0, uhci_explen(0) |
 		(0x7f &lt;&lt; TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);
 	uhci-&gt;term_td-&gt;link = cpu_to_le32(uhci-&gt;term_td-&gt;dma_handle);
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index e576db57a926..e43282e4e806 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -71,8 +71,6 @@
 #define   USBLEGSUP_RWC		0x8f00	/* the R/WC bits */
 #define   USBLEGSUP_RO		0x5040	/* R/O and reserved bits */
 
-#define UHCI_NULL_DATA_SIZE	0x7FF	/* for UHCI controller TD */
-
 #define UHCI_PTR_BITS		cpu_to_le32(0x000F)
 #define UHCI_PTR_TERM		cpu_to_le32(0x0001)
 #define UHCI_PTR_QH		cpu_to_le32(0x0002)
@@ -168,9 +166,11 @@ static __le32 inline qh_element(struct uhci_qh *qh) {
 #define TD_TOKEN_EXPLEN_MASK	0x7FF		/* expected length, encoded as n - 1 */
 #define TD_TOKEN_PID_MASK	0xFF
 
-#define uhci_explen(len)	((len) &lt;&lt; TD_TOKEN_EXPLEN_SHIFT)
+#define uhci_explen(len)	((((len) - 1) &amp; TD_TOKEN_EXPLEN_MASK) &lt;&lt; \
+					TD_TOKEN_EXPLEN_SHIFT)
 
-#define uhci_expected_length(token) ((((token) &gt;&gt; 21) + 1) &amp; TD_TOKEN_EXPLEN_MASK)
+#define uhci_expected_length(token) ((((token) &gt;&gt; TD_TOKEN_EXPLEN_SHIFT) + \
+					1) &amp; TD_TOKEN_EXPLEN_MASK)
 #define uhci_toggle(token)	(((token) &gt;&gt; TD_TOKEN_TOGGLE_SHIFT) &amp; 1)
 #define uhci_endpoint(token)	(((token) &gt;&gt; 15) &amp; 0xf)
 #define uhci_devaddr(token)	(((token) &gt;&gt; TD_TOKEN_DEVADDR_SHIFT) &amp; 0x7f)
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 7e46887d9e12..ace9d15f85d2 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -596,7 +596,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 		return -ENOMEM;
 
 	uhci_add_td_to_urb(urb, td);
-	uhci_fill_td(td, status, destination | uhci_explen(7),
+	uhci_fill_td(td, status, destination | uhci_explen(8),
 		urb-&gt;setup_dma);
 
 	/*
@@ -628,7 +628,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 		destination ^= TD_TOKEN_TOGGLE;
 	
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(pktsze - 1),
+		uhci_fill_td(td, status, destination | uhci_explen(pktsze),
 			data);
 
 		data += pktsze;
@@ -658,7 +658,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 
 	uhci_add_td_to_urb(urb, td);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
-		destination | uhci_explen(UHCI_NULL_DATA_SIZE), 0);
+		destination | uhci_explen(0), 0);
 
 	qh = uhci_alloc_qh(uhci);
 	if (!qh)
@@ -864,7 +864,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 			return -ENOMEM;
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(pktsze - 1) |
+		uhci_fill_td(td, status, destination | uhci_explen(pktsze) |
 			(usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			 usb_pipeout(urb-&gt;pipe)) &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
 			data);
@@ -890,7 +890,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 			return -ENOMEM;
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(UHCI_NULL_DATA_SIZE) |
+		uhci_fill_td(td, status, destination | uhci_explen(0) |
 			(usb_gettoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			 usb_pipeout(urb-&gt;pipe)) &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
 			data);
@@ -1092,7 +1092,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 			return -ENOMEM;
 
 		uhci_add_td_to_urb(urb, td);
-		uhci_fill_td(td, status, destination | uhci_explen(urb-&gt;iso_frame_desc[i].length - 1),
+		uhci_fill_td(td, status, destination | uhci_explen(urb-&gt;iso_frame_desc[i].length),
 			urb-&gt;transfer_dma + urb-&gt;iso_frame_desc[i].offset);
 
 		if (i + 1 &gt;= urb-&gt;number_of_packets)</pre><hr><pre>commit 2425e9fe67cb5e66c173c4f604ddd8a5970d89e9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 29 12:13:31 2005 -0500

    [PATCH] USB: Don't assume root-hub resume succeeds
    
    This patch (as614) makes a small change to the part of the hub driver
    responsible for remote wakeup of root hubs.  When these wakeups occur
    the driver is suspended, and in case the resume fails the driver should
    remain suspended -- it shouldn't try to proceed with its normal
    processing.
    
    This will hardly ever matter in normal use, but it did crop up while I
    was debugging a different problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a523c8f20b5d..650d5ee5871b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2697,6 +2697,8 @@ static void hub_events(void)
 		if (i) {
 			dpm_runtime_resume(&amp;hdev-&gt;dev);
 			dpm_runtime_resume(&amp;intf-&gt;dev);
+			usb_put_intf(intf);
+			continue;
 		}
 
 		/* Lock the device, then check to see if we were</pre><hr><pre>commit 3cf0a22e8b1b3f44288db773d315e72e89d51c4c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 29 12:08:15 2005 -0500

    [PATCH] USB Gadget: dummy_hcd: updates to hcd-&gt;state
    
    This patch (as613) moves the updates to hcd-&gt;state in the dummy_hcd
    driver to where they now belong.  It also uses the new
    HC_FLAG_HW_ACCESSIBLE flag in a way that simulates a real PCI
    controller, and it adds checks for attempts to resume the bus while the
    controller is suspended or to suspend the controller while the bus is
    active.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 4932b07b316d..ce0d4b412dfe 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1576,7 +1576,7 @@ static int dummy_hub_status (struct usb_hcd *hcd, char *buf)
 	dum = hcd_to_dummy (hcd);
 
 	spin_lock_irqsave (&amp;dum-&gt;lock, flags);
-	if (hcd-&gt;state != HC_STATE_RUNNING)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		goto done;
 
 	if (dum-&gt;resuming &amp;&amp; time_after_eq (jiffies, dum-&gt;re_timeout)) {
@@ -1623,7 +1623,7 @@ static int dummy_hub_control (
 	int		retval = 0;
 	unsigned long	flags;
 
-	if (hcd-&gt;state != HC_STATE_RUNNING)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		return -ETIMEDOUT;
 
 	dum = hcd_to_dummy (hcd);
@@ -1756,9 +1756,12 @@ static int dummy_bus_suspend (struct usb_hcd *hcd)
 {
 	struct dummy *dum = hcd_to_dummy (hcd);
 
+	dev_dbg (&amp;hcd-&gt;self.root_hub-&gt;dev, "%s\n", __FUNCTION__);
+
 	spin_lock_irq (&amp;dum-&gt;lock);
 	dum-&gt;rh_state = DUMMY_RH_SUSPENDED;
 	set_link_state (dum);
+	hcd-&gt;state = HC_STATE_SUSPENDED;
 	spin_unlock_irq (&amp;dum-&gt;lock);
 	return 0;
 }
@@ -1766,14 +1769,23 @@ static int dummy_bus_suspend (struct usb_hcd *hcd)
 static int dummy_bus_resume (struct usb_hcd *hcd)
 {
 	struct dummy *dum = hcd_to_dummy (hcd);
+	int rc = 0;
+
+	dev_dbg (&amp;hcd-&gt;self.root_hub-&gt;dev, "%s\n", __FUNCTION__);
 
 	spin_lock_irq (&amp;dum-&gt;lock);
-	dum-&gt;rh_state = DUMMY_RH_RUNNING;
-	set_link_state (dum);
-	if (!list_empty(&amp;dum-&gt;urbp_list))
-		mod_timer (&amp;dum-&gt;timer, jiffies);
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
+		dev_warn (&amp;hcd-&gt;self.root_hub-&gt;dev, "HC isn't running!\n");
+		rc = -ENODEV;
+	} else {
+		dum-&gt;rh_state = DUMMY_RH_RUNNING;
+		set_link_state (dum);
+		if (!list_empty(&amp;dum-&gt;urbp_list))
+			mod_timer (&amp;dum-&gt;timer, jiffies);
+		hcd-&gt;state = HC_STATE_RUNNING;
+	}
 	spin_unlock_irq (&amp;dum-&gt;lock);
-	return 0;
+	return rc;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -1933,12 +1945,19 @@ static int dummy_hcd_remove (struct platform_device *pdev)
 static int dummy_hcd_suspend (struct platform_device *pdev, pm_message_t state)
 {
 	struct usb_hcd		*hcd;
+	struct dummy		*dum;
+	int			rc = 0;
 
 	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
-	hcd = platform_get_drvdata (pdev);
 
-	hcd-&gt;state = HC_STATE_SUSPENDED;
-	return 0;
+	hcd = platform_get_drvdata (pdev);
+	dum = hcd_to_dummy (hcd);
+	if (dum-&gt;rh_state == DUMMY_RH_RUNNING) {
+		dev_warn(&amp;pdev-&gt;dev, "Root hub isn't suspended!\n");
+		rc = -EBUSY;
+	} else
+		clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
+	return rc;
 }
 
 static int dummy_hcd_resume (struct platform_device *pdev)
@@ -1946,9 +1965,9 @@ static int dummy_hcd_resume (struct platform_device *pdev)
 	struct usb_hcd		*hcd;
 
 	dev_dbg (&amp;pdev-&gt;dev, "%s\n", __FUNCTION__);
-	hcd = platform_get_drvdata (pdev);
-	hcd-&gt;state = HC_STATE_RUNNING;
 
+	hcd = platform_get_drvdata (pdev);
+	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	usb_hcd_poll_rh_status (hcd);
 	return 0;
 }</pre><hr><pre>commit a21d4fed4b00eaf7e7c3b2e2b25de24f540bfa66
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 29 12:04:24 2005 -0500

    [PATCH] USB Gadget: file_storage: remove "volatile" declarations
    
    This patch (as612) removes the "volatile" declarations from the
    file-storage gadget.  It turns out that they aren't needed for anything
    much; adding a few memory barriers does a sufficient job.
    
    The patch also removes a wait_queue.  Not much point having a queue when
    only one task is ever going to be on it!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index f6c49b717d3f..0cea9782d7d4 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -239,7 +239,6 @@
 #include &lt;linux/string.h&gt;
 #include &lt;linux/suspend.h&gt;
 #include &lt;linux/utsname.h&gt;
-#include &lt;linux/wait.h&gt;
 
 #include &lt;linux/usb_ch9.h&gt;
 #include &lt;linux/usb_gadget.h&gt;
@@ -251,7 +250,7 @@
 
 #define DRIVER_DESC		"File-backed Storage Gadget"
 #define DRIVER_NAME		"g_file_storage"
-#define DRIVER_VERSION		"20 October 2004"
+#define DRIVER_VERSION		"28 November 2005"
 
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
@@ -588,7 +587,7 @@ enum fsg_buffer_state {
 struct fsg_buffhd {
 	void				*buf;
 	dma_addr_t			dma;
-	volatile enum fsg_buffer_state	state;
+	enum fsg_buffer_state		state;
 	struct fsg_buffhd		*next;
 
 	/* The NetChip 2280 is faster, and handles some protocol faults
@@ -597,9 +596,9 @@ struct fsg_buffhd {
 	unsigned int			bulk_out_intended_length;
 
 	struct usb_request		*inreq;
-	volatile int			inreq_busy;
+	int				inreq_busy;
 	struct usb_request		*outreq;
-	volatile int			outreq_busy;
+	int				outreq_busy;
 };
 
 enum fsg_state {
@@ -637,11 +636,11 @@ struct fsg_dev {
 
 	struct usb_ep		*ep0;		// Handy copy of gadget-&gt;ep0
 	struct usb_request	*ep0req;	// For control responses
-	volatile unsigned int	ep0_req_tag;
+	unsigned int		ep0_req_tag;
 	const char		*ep0req_name;
 
 	struct usb_request	*intreq;	// For interrupt responses
-	volatile int		intreq_busy;
+	int			intreq_busy;
 	struct fsg_buffhd	*intr_buffhd;
 
  	unsigned int		bulk_out_maxpacket;
@@ -671,7 +670,6 @@ struct fsg_dev {
 	struct fsg_buffhd	*next_buffhd_to_drain;
 	struct fsg_buffhd	buffhds[NUM_BUFFERS];
 
-	wait_queue_head_t	thread_wqh;
 	int			thread_wakeup_needed;
 	struct completion	thread_notifier;
 	struct task_struct	*thread_task;
@@ -1076,11 +1074,13 @@ static int populate_config_buf(struct usb_gadget *gadget,
 
 /* These routines may be called in process context or in_irq */
 
+/* Caller must hold fsg-&gt;lock */
 static void wakeup_thread(struct fsg_dev *fsg)
 {
 	/* Tell the main thread that something has happened */
 	fsg-&gt;thread_wakeup_needed = 1;
-	wake_up_all(&amp;fsg-&gt;thread_wqh);
+	if (fsg-&gt;thread_task)
+		wake_up_process(fsg-&gt;thread_task);
 }
 
 
@@ -1167,11 +1167,12 @@ static void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
 	spin_lock(&amp;fsg-&gt;lock);
 	bh-&gt;inreq_busy = 0;
 	bh-&gt;state = BUF_STATE_EMPTY;
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
@@ -1188,11 +1189,12 @@ static void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
 	spin_lock(&amp;fsg-&gt;lock);
 	bh-&gt;outreq_busy = 0;
 	bh-&gt;state = BUF_STATE_FULL;
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 
@@ -1209,11 +1211,12 @@ static void intr_in_complete(struct usb_ep *ep, struct usb_request *req)
 		usb_ep_fifo_flush(ep);
 
 	/* Hold the lock while we update the request and buffer states */
+	smp_wmb();
 	spin_lock(&amp;fsg-&gt;lock);
 	fsg-&gt;intreq_busy = 0;
 	bh-&gt;state = BUF_STATE_EMPTY;
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 #else
@@ -1264,8 +1267,8 @@ static void received_cbi_adsc(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	fsg-&gt;cbbuf_cmnd_size = req-&gt;actual;
 	memcpy(fsg-&gt;cbbuf_cmnd, req-&gt;buf, fsg-&gt;cbbuf_cmnd_size);
 
-	spin_unlock(&amp;fsg-&gt;lock);
 	wakeup_thread(fsg);
+	spin_unlock(&amp;fsg-&gt;lock);
 }
 
 #else
@@ -1517,8 +1520,8 @@ static int fsg_setup(struct usb_gadget *gadget,
 
 /* Use this for bulk or interrupt transfers, not ep0 */
 static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
-		struct usb_request *req, volatile int *pbusy,
-		volatile enum fsg_buffer_state *state)
+		struct usb_request *req, int *pbusy,
+		enum fsg_buffer_state *state)
 {
 	int	rc;
 
@@ -1526,8 +1529,11 @@ static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
 		dump_msg(fsg, "bulk-in", req-&gt;buf, req-&gt;length);
 	else if (ep == fsg-&gt;intr_in)
 		dump_msg(fsg, "intr-in", req-&gt;buf, req-&gt;length);
+
+	spin_lock_irq(&amp;fsg-&gt;lock);
 	*pbusy = 1;
 	*state = BUF_STATE_BUSY;
+	spin_unlock_irq(&amp;fsg-&gt;lock);
 	rc = usb_ep_queue(ep, req, GFP_KERNEL);
 	if (rc != 0) {
 		*pbusy = 0;
@@ -1547,14 +1553,23 @@ static void start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,
 
 static int sleep_thread(struct fsg_dev *fsg)
 {
-	int	rc;
+	int	rc = 0;
 
 	/* Wait until a signal arrives or we are woken up */
-	rc = wait_event_interruptible(fsg-&gt;thread_wqh,
-			fsg-&gt;thread_wakeup_needed);
+	for (;;) {
+		try_to_freeze();
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (signal_pending(current)) {
+			rc = -EINTR;
+			break;
+		}
+		if (fsg-&gt;thread_wakeup_needed)
+			break;
+		schedule();
+	}
+	__set_current_state(TASK_RUNNING);
 	fsg-&gt;thread_wakeup_needed = 0;
-	try_to_freeze();
-	return (rc ? -EINTR : 0);
+	return rc;
 }
 
 
@@ -1791,6 +1806,7 @@ static int do_write(struct fsg_dev *fsg)
 		if (bh-&gt;state == BUF_STATE_EMPTY &amp;&amp; !get_some_more)
 			break;			// We stopped early
 		if (bh-&gt;state == BUF_STATE_FULL) {
+			smp_rmb();
 			fsg-&gt;next_buffhd_to_drain = bh-&gt;next;
 			bh-&gt;state = BUF_STATE_EMPTY;
 
@@ -2359,6 +2375,7 @@ static int throw_away_data(struct fsg_dev *fsg)
 
 		/* Throw away the data in a filled buffer */
 		if (bh-&gt;state == BUF_STATE_FULL) {
+			smp_rmb();
 			bh-&gt;state = BUF_STATE_EMPTY;
 			fsg-&gt;next_buffhd_to_drain = bh-&gt;next;
 
@@ -3024,6 +3041,7 @@ static int get_next_command(struct fsg_dev *fsg)
 			if ((rc = sleep_thread(fsg)) != 0)
 				return rc;
 			}
+		smp_rmb();
 		rc = received_cbw(fsg, bh);
 		bh-&gt;state = BUF_STATE_EMPTY;
 
@@ -4072,7 +4090,6 @@ static int __init fsg_alloc(void)
 	spin_lock_init(&amp;fsg-&gt;lock);
 	init_rwsem(&amp;fsg-&gt;filesem);
 	kref_init(&amp;fsg-&gt;ref);
-	init_waitqueue_head(&amp;fsg-&gt;thread_wqh);
 	init_completion(&amp;fsg-&gt;thread_notifier);
 
 	the_fsg = fsg;</pre><hr><pre>commit 12c3da346eb81b6a281031f62eda3bca993dff5a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 23 12:09:52 2005 -0500

    [PATCH] USB: Store port number in usb_device
    
    This patch (as610) adds a field to struct usb_device to store the device's
    port number.  This allows us to remove several loops in the hub driver
    (searching for a particular device among all the entries in the parent's
    array of children).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index b311005ff1a6..a523c8f20b5d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -946,24 +946,21 @@ static int locktree(struct usb_device *udev)
 	t = locktree(hdev);
 	if (t &lt; 0)
 		return t;
-	for (t = 0; t &lt; hdev-&gt;maxchild; t++) {
-		if (hdev-&gt;children[t] == udev) {
-			/* everything is fail-fast once disconnect
-			 * processing starts
-			 */
-			if (udev-&gt;state == USB_STATE_NOTATTACHED)
-				break;
 
-			/* when everyone grabs locks top-&gt;bottom,
-			 * non-overlapping work may be concurrent
-			 */
-			usb_lock_device(udev);
-			usb_unlock_device(hdev);
-			return t + 1;
-		}
+	/* everything is fail-fast once disconnect
+	 * processing starts
+	 */
+	if (udev-&gt;state == USB_STATE_NOTATTACHED) {
+		usb_unlock_device(hdev);
+		return -ENODEV;
 	}
+
+	/* when everyone grabs locks top-&gt;bottom,
+	 * non-overlapping work may be concurrent
+	 */
+	usb_lock_device(udev);
 	usb_unlock_device(hdev);
-	return -ENODEV;
+	return udev-&gt;portnum;
 }
 
 static void recursively_mark_NOTATTACHED(struct usb_device *udev)
@@ -1335,15 +1332,9 @@ int usb_new_device(struct usb_device *udev)
 					le16_to_cpu(udev-&gt;config[0].desc.wTotalLength),
 					USB_DT_OTG, (void **) &amp;desc) == 0) {
 			if (desc-&gt;bmAttributes &amp; USB_OTG_HNP) {
-				unsigned		port1;
+				unsigned		port1 = udev-&gt;portnum;
 				struct usb_device	*root = udev-&gt;parent;
 				
-				for (port1 = 1; port1 &lt;= root-&gt;maxchild;
-						port1++) {
-					if (root-&gt;children[port1-1] == udev)
-						break;
-				}
-
 				dev_info(&amp;udev-&gt;dev,
 					"Dual-Role OTG device on %sHNP port\n",
 					(port1 == bus-&gt;otg_port)
@@ -1720,22 +1711,9 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 int usb_suspend_device(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
-	int	port1;
-
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
-	if (!udev-&gt;parent)
-		port1 = 0;
-	else {
-		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
-			if (udev-&gt;parent-&gt;children[port1-1] == udev)
-				break;
-		}
-		if (port1 == 0)
-			return -ENODEV;
-	}
-
-	return __usb_suspend_device(udev, port1);
+	return __usb_suspend_device(udev, udev-&gt;portnum);
 #else
 	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
 	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
@@ -1893,20 +1871,10 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  */
 int usb_resume_device(struct usb_device *udev)
 {
-	int	port1, status;
+	int	status;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
-	if (!udev-&gt;parent)
-		port1 = 0;
-	else {
-		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
-			if (udev-&gt;parent-&gt;children[port1-1] == udev)
-				break;
-		}
-		if (port1 == 0)
-			return -ENODEV;
-	}
 
 #ifdef	CONFIG_USB_SUSPEND
 	/* selective resume of one downstream hub-to-device port */
@@ -1915,7 +1883,7 @@ int usb_resume_device(struct usb_device *udev)
 			// NOTE swsusp may bork us, device state being wrong...
 			// NOTE this fails if parent is also suspended...
 			status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-					port1, udev);
+					udev-&gt;portnum, udev);
 		} else
 			status = 0;
 	} else
@@ -3029,7 +2997,8 @@ int usb_reset_device(struct usb_device *udev)
 	struct usb_hub			*parent_hub;
 	struct usb_device_descriptor	descriptor = udev-&gt;descriptor;
 	struct usb_hub			*hub = NULL;
-	int 				i, ret = 0, port1 = -1;
+	int 				i, ret = 0;
+	int				port1 = udev-&gt;portnum;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
 			udev-&gt;state == USB_STATE_SUSPENDED) {
@@ -3043,18 +3012,6 @@ int usb_reset_device(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "%s for root hub!\n", __FUNCTION__);
 		return -EISDIR;
 	}
-
-	for (i = 0; i &lt; parent_hdev-&gt;maxchild; i++)
-		if (parent_hdev-&gt;children[i] == udev) {
-			port1 = i + 1;
-			break;
-		}
-
-	if (port1 &lt; 0) {
-		/* If this ever happens, it's very bad */
-		dev_err(&amp;udev-&gt;dev, "Can't locate device's port!\n");
-		return -ENOENT;
-	}
 	parent_hub = hdev_to_hub(parent_hdev);
 
 	/* If we're resetting an active hub, take some special actions */
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index fcfda21be499..39e6b61b898a 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -439,6 +439,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 		/* hub driver sets up TT records */
 	}
 
+	dev-&gt;portnum = port1;
 	dev-&gt;bus = bus;
 	dev-&gt;parent = parent;
 	INIT_LIST_HEAD(&amp;dev-&gt;filelist);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 27575e678a7c..e59d1bd52d4f 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -348,6 +348,7 @@ struct usb_device {
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
 	unsigned short bus_mA;		/* Current available from the bus */
+	u8 portnum;			/* Parent port number (origin 1) */
 
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */</pre><hr><pre>commit 55c527187c9d78f840b284d596a0b298bc1493af
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 23 12:03:12 2005 -0500

    [PATCH] USB: Consider power budget when choosing configuration
    
    This patch (as609) changes the way we keep track of power budgeting for
    USB hubs and devices, and it updates the choose_configuration routine to
    take this information into account.  (This is something we should have
    been doing all along.)  A new field in struct usb_device holds the amount
    of bus current available from the upstream port, and the usb_hub structure
    keeps track of the current available for each downstream port.
    
    Two new rules for configuration selection are added:
    
            Don't select a self-powered configuration when only bus power
            is available.
    
            Don't select a configuration requiring more bus power than is
            available.
    
    However the first rule is #if-ed out, because I found that the internal
    hub in my HP USB keyboard claims that its only configuration is
    self-powered.  The rule would prevent the configuration from being chosen,
    leaving the hub &amp; keyboard unconfigured.  Since similar descriptor errors
    may turn out to be fairly common, it seemed wise not to include a rule
    that would break automatic configuration unnecessarily for such devices.
    
    The second rule may also trigger unnecessarily, although this should be
    less common.  More likely it will annoy people by sometimes failing to
    accept configurations that should never have been chosen in the first
    place.
    
    The patch also changes usbcore's reaction when no configuration is
    suitable.  Instead of raising an error and rejecting the device, now
    the core will simply leave the device unconfigured.  People can always
    work around such problems by installing configurations manually through
    sysfs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index d16a0e8a7d72..0018bbc4de34 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1825,8 +1825,6 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		retval = -ENOMEM;
 		goto err_allocate_root_hub;
 	}
-	rhdev-&gt;speed = (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) ? USB_SPEED_HIGH :
-			USB_SPEED_FULL;
 
 	/* Although in principle hcd-&gt;driver-&gt;start() might need to use rhdev,
 	 * none of the current drivers do.
@@ -1844,6 +1842,9 @@ int usb_add_hcd(struct usb_hcd *hcd,
 		dev_dbg(hcd-&gt;self.controller, "supports USB remote wakeup\n");
 	hcd-&gt;remote_wakeup = hcd-&gt;can_wakeup;
 
+	rhdev-&gt;speed = (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) ? USB_SPEED_HIGH :
+			USB_SPEED_FULL;
+	rhdev-&gt;bus_mA = min(500u, hcd-&gt;power_budget);
 	if ((retval = register_root_hub(rhdev, hcd)) != 0)
 		goto err_register_root_hub;
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 895ac829b9cf..b311005ff1a6 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -702,26 +702,40 @@ static int hub_configure(struct usb_hub *hub,
 	 * and battery-powered root hubs (may provide just 8 mA).
 	 */
 	ret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &amp;hubstatus);
-	if (ret &lt; 0) {
+	if (ret &lt; 2) {
 		message = "can't get hub status";
 		goto fail;
 	}
 	le16_to_cpus(&amp;hubstatus);
 	if (hdev == hdev-&gt;bus-&gt;root_hub) {
-		struct usb_hcd *hcd =
-				container_of(hdev-&gt;bus, struct usb_hcd, self);
-
-		hub-&gt;power_budget = min(500u, hcd-&gt;power_budget) / 2;
+		if (hdev-&gt;bus_mA == 0 || hdev-&gt;bus_mA &gt;= 500)
+			hub-&gt;mA_per_port = 500;
+		else {
+			hub-&gt;mA_per_port = hdev-&gt;bus_mA;
+			hub-&gt;limited_power = 1;
+		}
 	} else if ((hubstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 		dev_dbg(hub_dev, "hub controller current requirement: %dmA\n",
 			hub-&gt;descriptor-&gt;bHubContrCurrent);
-		hub-&gt;power_budget = (501 - hub-&gt;descriptor-&gt;bHubContrCurrent)
-					/ 2;
+		hub-&gt;limited_power = 1;
+		if (hdev-&gt;maxchild &gt; 0) {
+			int remaining = hdev-&gt;bus_mA -
+					hub-&gt;descriptor-&gt;bHubContrCurrent;
+
+			if (remaining &lt; hdev-&gt;maxchild * 100)
+				dev_warn(hub_dev,
+					"insufficient power available "
+					"to use all downstream ports\n");
+			hub-&gt;mA_per_port = 100;		/* 7.2.1.1 */
+		}
+	} else {	/* Self-powered external hub */
+		/* FIXME: What about battery-powered external hubs that
+		 * provide less current per port? */
+		hub-&gt;mA_per_port = 500;
 	}
-	if (hub-&gt;power_budget)
-		dev_dbg(hub_dev, "%dmA bus power budget for children\n",
-			hub-&gt;power_budget * 2);
-
+	if (hub-&gt;mA_per_port &lt; 500)
+		dev_dbg(hub_dev, "%umA bus power budget for each child\n",
+				hub-&gt;mA_per_port);
 
 	ret = hub_hub_status(hub, &amp;hubstatus, &amp;hubchange);
 	if (ret &lt; 0) {
@@ -1136,45 +1150,107 @@ void usb_disconnect(struct usb_device **pdev)
 	device_unregister(&amp;udev-&gt;dev);
 }
 
+static inline const char *plural(int n)
+{
+	return (n == 1 ? "" : "s");
+}
+
 static int choose_configuration(struct usb_device *udev)
 {
-	int c, i;
+	int i;
+	u16 devstatus;
+	int bus_powered;
+	int num_configs;
+	struct usb_host_config *c, *best;
+
+	/* If this fails, assume the device is bus-powered */
+	devstatus = 0;
+	usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
+	le16_to_cpus(&amp;devstatus);
+	bus_powered = ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0);
+	dev_dbg(&amp;udev-&gt;dev, "device is %s-powered\n",
+			bus_powered ? "bus" : "self");
+
+	best = NULL;
+	c = udev-&gt;config;
+	num_configs = udev-&gt;descriptor.bNumConfigurations;
+	for (i = 0; i &lt; num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc =
+				&amp;c-&gt;intf_cache[0]-&gt;altsetting-&gt;desc;
+
+		/*
+		 * HP's USB bus-powered keyboard has only one configuration
+		 * and it claims to be self-powered; other devices may have
+		 * similar errors in their descriptors.  If the next test
+		 * were allowed to execute, such configurations would always
+		 * be rejected and the devices would not work as expected.
+		 */
+#if 0
+		/* Rule out self-powered configs for a bus-powered device */
+		if (bus_powered &amp;&amp; (c-&gt;desc.bmAttributes &amp;
+					USB_CONFIG_ATT_SELFPOWER))
+			continue;
+#endif
 
-	/* NOTE: this should interact with hub power budgeting */
+		/*
+		 * The next test may not be as effective as it should be.
+		 * Some hubs have errors in their descriptor, claiming
+		 * to be self-powered when they are really bus-powered.
+		 * We will overestimate the amount of current such hubs
+		 * make available for each port.
+		 *
+		 * This is a fairly benign sort of failure.  It won't
+		 * cause us to reject configurations that we should have
+		 * accepted.
+		 */
 
-	c = udev-&gt;config[0].desc.bConfigurationValue;
-	if (udev-&gt;descriptor.bNumConfigurations != 1) {
-		for (i = 0; i &lt; udev-&gt;descriptor.bNumConfigurations; i++) {
-			struct usb_interface_descriptor	*desc;
+		/* Rule out configs that draw too much bus current */
+		if (c-&gt;desc.bMaxPower * 2 &gt; udev-&gt;bus_mA)
+			continue;
 
-			/* heuristic:  Linux is more likely to have class
-			 * drivers, so avoid vendor-specific interfaces.
-			 */
-			desc = &amp;udev-&gt;config[i].intf_cache[0]
-					-&gt;altsetting-&gt;desc;
-			if (desc-&gt;bInterfaceClass == USB_CLASS_VENDOR_SPEC)
-				continue;
-			/* COMM/2/all is CDC ACM, except 0xff is MSFT RNDIS.
-			 * MSFT needs this to be the first config; never use
-			 * it as the default unless Linux has host-side RNDIS.
-			 * A second config would ideally be CDC-Ethernet, but
-			 * may instead be the "vendor specific" CDC subset
-			 * long used by ARM Linux for sa1100 or pxa255.
-			 */
-			if (desc-&gt;bInterfaceClass == USB_CLASS_COMM
-					&amp;&amp; desc-&gt;bInterfaceSubClass == 2
-					&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
-				c = udev-&gt;config[1].desc.bConfigurationValue;
-				continue;
-			}
-			c = udev-&gt;config[i].desc.bConfigurationValue;
+		/* If the first config's first interface is COMM/2/0xff
+		 * (MSFT RNDIS), rule it out unless Linux has host-side
+		 * RNDIS support. */
+		if (i == 0 &amp;&amp; desc-&gt;bInterfaceClass == USB_CLASS_COMM
+				&amp;&amp; desc-&gt;bInterfaceSubClass == 2
+				&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
+#ifndef CONFIG_USB_NET_RNDIS
+			continue;
+#else
+			best = c;
+#endif
+		}
+
+		/* From the remaining configs, choose the first one whose
+		 * first interface is for a non-vendor-specific class.
+		 * Reason: Linux is more likely to have a class driver
+		 * than a vendor-specific driver. */
+		else if (udev-&gt;descriptor.bDeviceClass !=
+						USB_CLASS_VENDOR_SPEC &amp;&amp;
+				desc-&gt;bInterfaceClass !=
+						USB_CLASS_VENDOR_SPEC) {
+			best = c;
 			break;
 		}
+
+		/* If all the remaining configs are vendor-specific,
+		 * choose the first one. */
+		else if (!best)
+			best = c;
+	}
+
+	if (best) {
+		i = best-&gt;desc.bConfigurationValue;
 		dev_info(&amp;udev-&gt;dev,
-			"configuration #%d chosen from %d choices\n",
-			c, udev-&gt;descriptor.bNumConfigurations);
+			"configuration #%d chosen from %d choice%s\n",
+			i, num_configs, plural(num_configs));
+	} else {
+		i = -1;
+		dev_warn(&amp;udev-&gt;dev,
+			"no configuration chosen from %d choice%s\n",
+			num_configs, plural(num_configs));
 	}
-	return c;
+	return i;
 }
 
 #ifdef DEBUG
@@ -1327,17 +1403,13 @@ int usb_new_device(struct usb_device *udev)
 	 * with the driver core, and lets usb device drivers bind to them.
 	 */
 	c = choose_configuration(udev);
-	if (c &lt; 0)
-		dev_warn(&amp;udev-&gt;dev,
-				"can't choose an initial configuration\n");
-	else {
+	if (c &gt;= 0) {
 		err = usb_set_configuration(udev, c);
 		if (err) {
 			dev_err(&amp;udev-&gt;dev, "can't set config #%d, error %d\n",
 					c, err);
-			usb_remove_sysfs_dev_files(udev);
-			device_del(&amp;udev-&gt;dev);
-			goto fail;
+			/* This need not be fatal.  The user can try to
+			 * set other configurations. */
 		}
 	}
 
@@ -1702,7 +1774,7 @@ static int finish_device_resume(struct usb_device *udev)
 	 * and device drivers will know about any resume quirks.
 	 */
 	status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-	if (status &lt; 0)
+	if (status &lt; 2)
 		dev_dbg(&amp;udev-&gt;dev,
 			"gone after usb resume? status %d\n",
 			status);
@@ -1711,7 +1783,7 @@ static int finish_device_resume(struct usb_device *udev)
 		int		(*resume)(struct device *);
 
 		le16_to_cpus(&amp;devstatus);
-		if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)
+		if ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
 				&amp;&amp; udev-&gt;parent) {
 			status = usb_control_msg(udev,
 					usb_sndctrlpipe(udev, 0),
@@ -2374,39 +2446,36 @@ hub_power_remaining (struct usb_hub *hub)
 {
 	struct usb_device *hdev = hub-&gt;hdev;
 	int remaining;
-	unsigned i;
+	int port1;
 
-	remaining = hub-&gt;power_budget;
-	if (!remaining)		/* self-powered */
+	if (!hub-&gt;limited_power)
 		return 0;
 
-	for (i = 0; i &lt; hdev-&gt;maxchild; i++) {
-		struct usb_device	*udev = hdev-&gt;children[i];
-		int			delta, ceiling;
+	remaining = hdev-&gt;bus_mA - hub-&gt;descriptor-&gt;bHubContrCurrent;
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		struct usb_device	*udev = hdev-&gt;children[port1 - 1];
+		int			delta;
 
 		if (!udev)
 			continue;
 
-		/* 100mA per-port ceiling, or 8mA for OTG ports */
-		if (i != (udev-&gt;bus-&gt;otg_port - 1) || hdev-&gt;parent)
-			ceiling = 50;
-		else
-			ceiling = 4;
-
+		/* Unconfigured devices may not use more than 100mA,
+		 * or 8mA for OTG ports */
 		if (udev-&gt;actconfig)
-			delta = udev-&gt;actconfig-&gt;desc.bMaxPower;
+			delta = udev-&gt;actconfig-&gt;desc.bMaxPower * 2;
+		else if (port1 != udev-&gt;bus-&gt;otg_port || hdev-&gt;parent)
+			delta = 100;
 		else
-			delta = ceiling;
-		// dev_dbg(&amp;udev-&gt;dev, "budgeted %dmA\n", 2 * delta);
-		if (delta &gt; ceiling)
-			dev_warn(&amp;udev-&gt;dev, "%dmA over %dmA budget!\n",
-				2 * (delta - ceiling), 2 * ceiling);
+			delta = 8;
+		if (delta &gt; hub-&gt;mA_per_port)
+			dev_warn(&amp;udev-&gt;dev, "%dmA is over %umA budget "
+					"for port %d!\n",
+					delta, hub-&gt;mA_per_port, port1);
 		remaining -= delta;
 	}
 	if (remaining &lt; 0) {
-		dev_warn(hub-&gt;intfdev,
-			"%dmA over power budget!\n",
-			-2 * remaining);
+		dev_warn(hub-&gt;intfdev, "%dmA over power budget!\n",
+			- remaining);
 		remaining = 0;
 	}
 	return remaining;
@@ -2501,7 +2570,8 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 		usb_set_device_state(udev, USB_STATE_POWERED);
 		udev-&gt;speed = USB_SPEED_UNKNOWN;
- 
+ 		udev-&gt;bus_mA = hub-&gt;mA_per_port;
+
 		/* set the address */
 		choose_address(udev);
 		if (udev-&gt;devnum &lt;= 0) {
@@ -2521,16 +2591,16 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		 * on the parent.
 		 */
 		if (udev-&gt;descriptor.bDeviceClass == USB_CLASS_HUB
-				&amp;&amp; hub-&gt;power_budget) {
+				&amp;&amp; udev-&gt;bus_mA &lt;= 100) {
 			u16	devstat;
 
 			status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
 					&amp;devstat);
-			if (status &lt; 0) {
+			if (status &lt; 2) {
 				dev_dbg(&amp;udev-&gt;dev, "get status %d ?\n", status);
 				goto loop_disable;
 			}
-			cpu_to_le16s(&amp;devstat);
+			le16_to_cpus(&amp;devstat);
 			if ((devstat &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 				dev_err(&amp;udev-&gt;dev,
 					"can't connect bus-powered hub "
@@ -2583,9 +2653,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 		status = hub_power_remaining(hub);
 		if (status)
-			dev_dbg(hub_dev,
-				"%dmA power budget left\n",
-				2 * status);
+			dev_dbg(hub_dev, "%dmA power budget left\n", status);
 
 		return;
 
@@ -2797,6 +2865,11 @@ static void hub_events(void)
 			if (hubchange &amp; HUB_CHANGE_LOCAL_POWER) {
 				dev_dbg (hub_dev, "power change\n");
 				clear_hub_feature(hdev, C_HUB_LOCAL_POWER);
+				if (hubstatus &amp; HUB_STATUS_LOCAL_POWER)
+					/* FIXME: Is this always true? */
+					hub-&gt;limited_power = 0;
+				else
+					hub-&gt;limited_power = 1;
 			}
 			if (hubchange &amp; HUB_CHANGE_OVERCURRENT) {
 				dev_dbg (hub_dev, "overcurrent change\n");
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index bf23f8978024..29d5f45a8456 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -220,8 +220,9 @@ struct usb_hub {
 	struct usb_hub_descriptor *descriptor;	/* class descriptor */
 	struct usb_tt		tt;		/* Transaction Translator */
 
-	u8			power_budget;	/* in 2mA units; or zero */
+	unsigned		mA_per_port;	/* current for each child */
 
+	unsigned		limited_power:1;
 	unsigned		quiescing:1;
 	unsigned		activating:1;
 	unsigned		resume_root_hub:1;
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index fe74f99ca5f4..99ab774d4fdb 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1387,6 +1387,12 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (dev-&gt;state != USB_STATE_ADDRESS)
 		usb_disable_device (dev, 1);	// Skip ep0
 
+	n = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
+	if (n &lt; 0)
+		dev_warn(&amp;dev-&gt;dev, "new config #%d exceeds power "
+				"limit by %dmA\n",
+				configuration, -n);
+
 	if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
 			NULL, 0, USB_CTRL_SET_TIMEOUT)) &lt; 0)
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 46dc0421d19e..27575e678a7c 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -347,6 +347,8 @@ struct usb_device {
 
 	char **rawdescriptors;		/* Raw descriptors for each config */
 
+	unsigned short bus_mA;		/* Current available from the bus */
+
 	int have_langid;		/* whether string_langid is valid */
 	int string_langid;		/* language ID for strings */
 </pre><hr><pre>commit 4bf0ba861442d289eebfad8ea9ce365ab04fd582
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 21 11:58:07 2005 -0500

    [PATCH] USB: Fix locking for USB suspend/resume
    
    The earlier USB locking updates didn't touch the suspend/resume
    routines.  They need updating as well, since now the caller holds the
    device semaphore.  This patch (as608) makes the necessary changes.  It
    also adds a line to store the correct power state when a device is
    resumed, something which was unaccountably missing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 02601f412f9d..895ac829b9cf 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1648,15 +1648,22 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 int usb_suspend_device(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
-	int	port1, status;
+	int	port1;
 
-	port1 = locktree(udev);
-	if (port1 &lt; 0)
-		return port1;
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
+	if (!udev-&gt;parent)
+		port1 = 0;
+	else {
+		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
+			if (udev-&gt;parent-&gt;children[port1-1] == udev)
+				break;
+		}
+		if (port1 == 0)
+			return -ENODEV;
+	}
 
-	status = __usb_suspend_device(udev, port1);
-	usb_unlock_device(udev);
-	return status;
+	return __usb_suspend_device(udev, port1);
 #else
 	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
 	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
@@ -1688,6 +1695,7 @@ static int finish_device_resume(struct usb_device *udev)
 	usb_set_device_state(udev, udev-&gt;actconfig
 			? USB_STATE_CONFIGURED
 			: USB_STATE_ADDRESS);
+	udev-&gt;dev.power.power_state = PMSG_ON;
 
  	/* 10.5.4.5 says be sure devices in the tree are still there.
  	 * For now let's assume the device didn't go crazy on resume,
@@ -1723,8 +1731,14 @@ static int finish_device_resume(struct usb_device *udev)
 		 * may have a child resume event to deal with soon
 		 */
 		resume = udev-&gt;dev.bus-&gt;resume;
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++)
-			(void) resume(&amp;udev-&gt;actconfig-&gt;interface[i]-&gt;dev);
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			struct device *dev =
+					&amp;udev-&gt;actconfig-&gt;interface[i]-&gt;dev;
+
+			down(&amp;dev-&gt;sem);
+			(void) resume(dev);
+			up(&amp;dev-&gt;sem);
+		}
 		status = 0;
 
 	} else if (udev-&gt;devnum &lt;= 0) {
@@ -1809,9 +1823,18 @@ int usb_resume_device(struct usb_device *udev)
 {
 	int	port1, status;
 
-	port1 = locktree(udev);
-	if (port1 &lt; 0)
-		return port1;
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
+	if (!udev-&gt;parent)
+		port1 = 0;
+	else {
+		for (port1 = udev-&gt;parent-&gt;maxchild; port1 &gt; 0; --port1) {
+			if (udev-&gt;parent-&gt;children[port1-1] == udev)
+				break;
+		}
+		if (port1 == 0)
+			return -ENODEV;
+	}
 
 #ifdef	CONFIG_USB_SUSPEND
 	/* selective resume of one downstream hub-to-device port */
@@ -1830,11 +1853,12 @@ int usb_resume_device(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n",
 			status);
 
-	usb_unlock_device(udev);
-
 	/* rebind drivers that had no suspend() */
-	if (status == 0)
+	if (status == 0) {
+		usb_unlock_device(udev);
 		bus_rescan_devices(&amp;usb_bus_type);
+		usb_lock_device(udev);
+	}
 	return status;
 }
 </pre><hr><pre>commit 7d069b7d80933004282c48edbe62526e4cb0aecc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 18 12:06:34 2005 -0500

    [PATCH] USB: Disconnect children during hub unbind
    
    This patch (as606b) is an updated version of my earlier patch to
    disconnect children from a hub device when the hub driver is unbound.
    Thanks to the changes in the driver core locking, we now know that the
    entire hub device (and not just the interface) is locked whenever the
    hub driver's disconnect method runs.  Hence it is safe to disconnect the
    child device structures immediately instead of deferring the job.
    
    The earlier version of the patch neglected to disable the hub's ports.
    We don't want to forget that; otherwise we'd end up with live devices
    using addresses that have been recycled.  This update adds the necessary
    code.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index dd3bcfb2bcb6..02601f412f9d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -515,6 +515,31 @@ static int hub_port_disable(struct usb_hub *hub, int port1, int set_state)
 	return ret;
 }
 
+
+/* caller has locked the hub device */
+static void hub_pre_reset(struct usb_hub *hub, int disable_ports)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int port1;
+
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		if (hdev-&gt;children[port1 - 1]) {
+			usb_disconnect(&amp;hdev-&gt;children[port1 - 1]);
+			if (disable_ports)
+				hub_port_disable(hub, port1, 0);
+		}
+	}
+	hub_quiesce(hub);
+}
+
+/* caller has locked the hub device */
+static void hub_post_reset(struct usb_hub *hub)
+{
+	hub_activate(hub);
+	hub_power_on(hub);
+}
+
+
 static int hub_configure(struct usb_hub *hub,
 	struct usb_endpoint_descriptor *endpoint)
 {
@@ -750,29 +775,10 @@ static int hub_configure(struct usb_hub *hub,
 
 static unsigned highspeed_hubs;
 
-/* Called after the hub driver is unbound from a hub with children */
-static void hub_remove_children_work(void *__hub)
-{
-	struct usb_hub		*hub = __hub;
-	struct usb_device	*hdev = hub-&gt;hdev;
-	int			i;
-
-	kfree(hub);
-
-	usb_lock_device(hdev);
-	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
-		if (hdev-&gt;children[i])
-			usb_disconnect(&amp;hdev-&gt;children[i]);
-	}
-	usb_unlock_device(hdev);
-	usb_put_dev(hdev);
-}
-
 static void hub_disconnect(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata (intf);
 	struct usb_device *hdev;
-	int n, port1;
 
 	usb_set_intfdata (intf, NULL);
 	hdev = hub-&gt;hdev;
@@ -780,7 +786,9 @@ static void hub_disconnect(struct usb_interface *intf)
 	if (hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
-	hub_quiesce(hub);
+	/* Disconnect all children and quiesce the hub */
+	hub_pre_reset(hub, 1);
+
 	usb_free_urb(hub-&gt;urb);
 	hub-&gt;urb = NULL;
 
@@ -800,27 +808,7 @@ static void hub_disconnect(struct usb_interface *intf)
 		hub-&gt;buffer = NULL;
 	}
 
-	/* If there are any children then this is an unbind only, not a
-	 * physical disconnection.  The active ports must be disabled
-	 * and later on we must call usb_disconnect().  We can't call
-	 * it now because we may not hold the hub's device lock.
-	 */
-	n = 0;
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
-		if (hdev-&gt;children[port1 - 1]) {
-			++n;
-			hub_port_disable(hub, port1, 1);
-		}
-	}
-
-	if (n == 0)
-		kfree(hub);
-	else {
-		/* Reuse the hub-&gt;leds work_struct for our own purposes */
-		INIT_WORK(&amp;hub-&gt;leds, hub_remove_children_work, hub);
-		schedule_work(&amp;hub-&gt;leds);
-		usb_get_dev(hdev);
-	}
+	kfree(hub);
 }
 
 static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
@@ -917,26 +905,6 @@ hub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)
 	}
 }
 
-/* caller has locked the hub device */
-static void hub_pre_reset(struct usb_hub *hub)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int i;
-
-	for (i = 0; i &lt; hdev-&gt;maxchild; ++i) {
-		if (hdev-&gt;children[i])
-			usb_disconnect(&amp;hdev-&gt;children[i]);
-	}
-	hub_quiesce(hub);
-}
-
-/* caller has locked the hub device */
-static void hub_post_reset(struct usb_hub *hub)
-{
-	hub_activate(hub);
-	hub_power_on(hub);
-}
-
 
 /* grab device/port lock, returning index of that port (zero based).
  * protects the upstream link used by this device from concurrent
@@ -2682,7 +2650,7 @@ static void hub_events(void)
 
 		/* If the hub has died, clean up after it */
 		if (hdev-&gt;state == USB_STATE_NOTATTACHED) {
-			hub_pre_reset(hub);
+			hub_pre_reset(hub, 0);
 			goto loop;
 		}
 
@@ -2997,7 +2965,7 @@ int usb_reset_device(struct usb_device *udev)
 			udev-&gt;actconfig-&gt;interface[0]-&gt;dev.driver ==
 				&amp;hub_driver.driver &amp;&amp;
 			(hub = hdev_to_hub(udev)) != NULL) {
-		hub_pre_reset(hub);
+		hub_pre_reset(hub, 0);
 	}
 
 	set_bit(port1, parent_hub-&gt;busy_bits);</pre><hr><pre>commit 9ad3d6ccf5eee285e233dbaf186369b8d477a666
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 17:10:32 2005 -0500

    [PATCH] USB: Remove USB private semaphore
    
    This patch (as605) removes the private udev-&gt;serialize semaphore,
    relying instead on the locking provided by the embedded struct device's
    semaphore.  The changes are confined to the core, except that the
    usb_trylock_device routine now uses the return convention of
    down_trylock rather than down_read_trylock (they return opposite values
    for no good reason).
    
    A couple of other associated changes are included as well:
    
            Now that we aren't concerned about HCDs that avoid using the
            hcd glue layer, usb_disconnect no longer needs to acquire the
            usb_bus_lock -- that can be done by usb_remove_hcd where it
            belongs.
    
            Devices aren't locked over the same scope of code in
            usb_new_device and hub_port_connect_change as they used to be.
            This shouldn't cause any trouble.
    
    Along with the preceding driver core patch, this needs a lot of testing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c
index 83e815d3cd52..55bc563a3256 100644
--- a/drivers/usb/core/devices.c
+++ b/drivers/usb/core/devices.c
@@ -545,10 +545,10 @@ static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes, loff_t *ski
 		struct usb_device *childdev = usbdev-&gt;children[chix];
 
 		if (childdev) {
-			down(&amp;childdev-&gt;serialize);
+			usb_lock_device(childdev);
 			ret = usb_device_dump(buffer, nbytes, skip_bytes, file_offset, childdev,
 					bus, level + 1, chix, ++cnt);
-			up(&amp;childdev-&gt;serialize);
+			usb_unlock_device(childdev);
 			if (ret == -EFAULT)
 				return total_written;
 			total_written += ret;
diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 3a73170e95dd..2b68998fe4b3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1349,9 +1349,7 @@ static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
 	/* let kernel drivers try to (re)bind to the interface */
 	case USBDEVFS_CONNECT:
 		usb_unlock_device(ps-&gt;dev);
-		usb_lock_all_devices();
 		bus_rescan_devices(intf-&gt;dev.bus);
-		usb_unlock_all_devices();
 		usb_lock_device(ps-&gt;dev);
 		break;
 
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index bb139f06bcd6..076462c8ba2a 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -432,9 +432,7 @@ int usb_register_driver(struct usb_driver *new_driver, struct module *owner)
 	spin_lock_init(&amp;new_driver-&gt;dynids.lock);
 	INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.list);
 
-	usb_lock_all_devices();
 	retval = driver_register(&amp;new_driver-&gt;driver);
-	usb_unlock_all_devices();
 
 	if (!retval) {
 		pr_info("%s: registered new driver %s\n",
@@ -465,11 +463,9 @@ void usb_deregister(struct usb_driver *driver)
 {
 	pr_info("%s: deregistering driver %s\n", usbcore_name, driver-&gt;name);
 
-	usb_lock_all_devices();
 	usb_remove_newid_file(driver);
 	usb_free_dynids(driver);
 	driver_unregister(&amp;driver-&gt;driver);
-	usb_unlock_all_devices();
 
 	usbfs_update_special();
 }
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index da24c31ee00d..d16a0e8a7d72 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -857,9 +857,7 @@ static int register_root_hub (struct usb_device *usb_dev,
 		return (retval &lt; 0) ? retval : -EMSGSIZE;
 	}
 
-	usb_lock_device (usb_dev);
 	retval = usb_new_device (usb_dev);
-	usb_unlock_device (usb_dev);
 	if (retval) {
 		usb_dev-&gt;bus-&gt;root_hub = NULL;
 		dev_err (parent_dev, "can't register root hub for %s, %d\n",
@@ -1891,7 +1889,10 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	spin_lock_irq (&amp;hcd_root_hub_lock);
 	hcd-&gt;rh_registered = 0;
 	spin_unlock_irq (&amp;hcd_root_hub_lock);
+
+	down(&amp;usb_bus_list_lock);
 	usb_disconnect(&amp;hcd-&gt;self.root_hub);
+	up(&amp;usb_bus_list_lock);
 
 	hcd-&gt;poll_rh = 0;
 	del_timer_sync(&amp;hcd-&gt;rh_timer);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 40c6c50c6bd9..dd3bcfb2bcb6 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -32,7 +32,7 @@
 #include "hub.h"
 
 /* Protect struct usb_device-&gt;state and -&gt;children members
- * Note: Both are also protected by -&gt;serialize, except that -&gt;state can
+ * Note: Both are also protected by -&gt;dev.sem, except that -&gt;state can
  * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */
 static DEFINE_SPINLOCK(device_state_lock);
 
@@ -975,8 +975,8 @@ static int locktree(struct usb_device *udev)
 			/* when everyone grabs locks top-&gt;bottom,
 			 * non-overlapping work may be concurrent
 			 */
-			down(&amp;udev-&gt;serialize);
-			up(&amp;hdev-&gt;serialize);
+			usb_lock_device(udev);
+			usb_unlock_device(hdev);
 			return t + 1;
 		}
 	}
@@ -1132,16 +1132,10 @@ void usb_disconnect(struct usb_device **pdev)
 	 * this quiesces everyting except pending urbs.
 	 */
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-
-	/* lock the bus list on behalf of HCDs unregistering their root hubs */
-	if (!udev-&gt;parent) {
-		down(&amp;usb_bus_list_lock);
-		usb_lock_device(udev);
-	} else
-		down(&amp;udev-&gt;serialize);
-
 	dev_info (&amp;udev-&gt;dev, "USB disconnect, address %d\n", udev-&gt;devnum);
 
+	usb_lock_device(udev);
+
 	/* Free up all the children before we remove this device */
 	for (i = 0; i &lt; USB_MAXCHILDREN; i++) {
 		if (udev-&gt;children[i])
@@ -1169,11 +1163,7 @@ void usb_disconnect(struct usb_device **pdev)
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
-	if (!udev-&gt;parent) {
-		usb_unlock_device(udev);
-		up(&amp;usb_bus_list_lock);
-	} else
-		up(&amp;udev-&gt;serialize);
+	usb_unlock_device(udev);
 
 	device_unregister(&amp;udev-&gt;dev);
 }
@@ -1243,8 +1233,8 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
  *
  * This is called with devices which have been enumerated, but not yet
  * configured.  The device descriptor is available, but not descriptors
- * for any device configuration.  The caller must have locked udev and
- * either the parent hub (if udev is a normal device) or else the
+ * for any device configuration.  The caller must have locked either
+ * the parent hub (if udev is a normal device) or else the
  * usb_bus_list_lock (if udev is a root hub).  The parent's pointer to
  * udev has already been installed, but udev is not yet visible through
  * sysfs or other filesystem code.
@@ -1254,8 +1244,7 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
  *
  * This call is synchronous, and may not be used in an interrupt context.
  *
- * Only the hub driver should ever call this; root hub registration
- * uses it indirectly.
+ * Only the hub driver or root-hub registrar should ever call this.
  */
 int usb_new_device(struct usb_device *udev)
 {
@@ -1364,6 +1353,8 @@ int usb_new_device(struct usb_device *udev)
 	}
 	usb_create_sysfs_dev_files (udev);
 
+	usb_lock_device(udev);
+
 	/* choose and set the configuration. that registers the interfaces
 	 * with the driver core, and lets usb device drivers bind to them.
 	 */
@@ -1385,6 +1376,8 @@ int usb_new_device(struct usb_device *udev)
 	/* USB device state == configured ... usable */
 	usb_notify_add_device(udev);
 
+	usb_unlock_device(udev);
+
 	return 0;
 
 fail:
@@ -1872,11 +1865,8 @@ int usb_resume_device(struct usb_device *udev)
 	usb_unlock_device(udev);
 
 	/* rebind drivers that had no suspend() */
-	if (status == 0) {
-		usb_lock_all_devices();
+	if (status == 0)
 		bus_rescan_devices(&amp;usb_bus_type);
-		usb_unlock_all_devices();
-	}
 	return status;
 }
 
@@ -1889,14 +1879,14 @@ static int remote_wakeup(struct usb_device *udev)
 	/* don't repeat RESUME sequence if this device
 	 * was already woken up by some other task
 	 */
-	down(&amp;udev-&gt;serialize);
+	usb_lock_device(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "RESUME (wakeup)\n");
 		/* TRSMRCY = 10 msec */
 		msleep(10);
 		status = finish_device_resume(udev);
 	}
-	up(&amp;udev-&gt;serialize);
+	usb_unlock_device(udev);
 #endif
 	return status;
 }
@@ -1997,7 +1987,7 @@ static int hub_resume(struct usb_interface *intf)
 
 		if (!udev || status &lt; 0)
 			continue;
-		down (&amp;udev-&gt;serialize);
+		usb_lock_device(udev);
 		if (portstat &amp; USB_PORT_STAT_SUSPEND)
 			status = hub_port_resume(hub, port1, udev);
 		else {
@@ -2008,7 +1998,7 @@ static int hub_resume(struct usb_interface *intf)
 				hub_port_logical_disconnect(hub, port1);
 			}
 		}
-		up(&amp;udev-&gt;serialize);
+		usb_unlock_device(udev);
 	}
 	}
 #endif
@@ -2573,7 +2563,6 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		 * udev becomes globally accessible, although presumably
 		 * no one will look at it until hdev is unlocked.
 		 */
-		down (&amp;udev-&gt;serialize);
 		status = 0;
 
 		/* We mustn't add new devices if the parent hub has
@@ -2597,7 +2586,6 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 			}
 		}
 
-		up (&amp;udev-&gt;serialize);
 		if (status)
 			goto loop_disable;
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 294e9f127477..fcfda21be499 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -32,7 +32,6 @@
 #include &lt;linux/spinlock.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/smp_lock.h&gt;
-#include &lt;linux/rwsem.h&gt;
 #include &lt;linux/usb.h&gt;
 
 #include &lt;asm/io.h&gt;
@@ -49,8 +48,6 @@ const char *usbcore_name = "usbcore";
 static int nousb;	/* Disable USB when built into kernel image */
 			/* Not honored on modular build */
 
-static DECLARE_RWSEM(usb_all_devices_rwsem);
-
 
 /**
  * usb_ifnum_to_if - get the interface object with a given interface number
@@ -446,8 +443,6 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	dev-&gt;parent = parent;
 	INIT_LIST_HEAD(&amp;dev-&gt;filelist);
 
-	init_MUTEX(&amp;dev-&gt;serialize);
-
 	return dev;
 }
 
@@ -520,75 +515,20 @@ void usb_put_intf(struct usb_interface *intf)
 
 /*			USB device locking
  *
- * Although locking USB devices should be straightforward, it is
- * complicated by the way the driver-model core works.  When a new USB
- * driver is registered or unregistered, the core will automatically
- * probe or disconnect all matching interfaces on all USB devices while
- * holding the USB subsystem writelock.  There's no good way for us to
- * tell which devices will be used or to lock them beforehand; our only
- * option is to effectively lock all the USB devices.
- *
- * We do that by using a private rw-semaphore, usb_all_devices_rwsem.
- * When locking an individual device you must first acquire the rwsem's
- * readlock.  When a driver is registered or unregistered the writelock
- * must be held.  These actions are encapsulated in the subroutines
- * below, so all a driver needs to do is call usb_lock_device() and
- * usb_unlock_device().
+ * USB devices and interfaces are locked using the semaphore in their
+ * embedded struct device.  The hub driver guarantees that whenever a
+ * device is connected or disconnected, drivers are called with the
+ * USB device locked as well as their particular interface.
  *
  * Complications arise when several devices are to be locked at the same
  * time.  Only hub-aware drivers that are part of usbcore ever have to
- * do this; nobody else needs to worry about it.  The problem is that
- * usb_lock_device() must not be called to lock a second device since it
- * would acquire the rwsem's readlock reentrantly, leading to deadlock if
- * another thread was waiting for the writelock.  The solution is simple:
- *
- *	When locking more than one device, call usb_lock_device()
- *	to lock the first one.  Lock the others by calling
- *	down(&amp;udev-&gt;serialize) directly.
- *
- *	When unlocking multiple devices, use up(&amp;udev-&gt;serialize)
- *	to unlock all but the last one.  Unlock the last one by
- *	calling usb_unlock_device().
+ * do this; nobody else needs to worry about it.  The rule for locking
+ * is simple:
  *
  *	When locking both a device and its parent, always lock the
  *	the parent first.
  */
 
-/**
- * usb_lock_device - acquire the lock for a usb device structure
- * @udev: device that's being locked
- *
- * Use this routine when you don't hold any other device locks;
- * to acquire nested inner locks call down(&amp;udev-&gt;serialize) directly.
- * This is necessary for proper interaction with usb_lock_all_devices().
- */
-void usb_lock_device(struct usb_device *udev)
-{
-	down_read(&amp;usb_all_devices_rwsem);
-	down(&amp;udev-&gt;serialize);
-}
-
-/**
- * usb_trylock_device - attempt to acquire the lock for a usb device structure
- * @udev: device that's being locked
- *
- * Don't use this routine if you already hold a device lock;
- * use down_trylock(&amp;udev-&gt;serialize) instead.
- * This is necessary for proper interaction with usb_lock_all_devices().
- *
- * Returns 1 if successful, 0 if contention.
- */
-int usb_trylock_device(struct usb_device *udev)
-{
-	if (!down_read_trylock(&amp;usb_all_devices_rwsem))
-		return 0;
-	if (down_trylock(&amp;udev-&gt;serialize)) {
-		up_read(&amp;usb_all_devices_rwsem);
-		return 0;
-	}
-	return 1;
-}
-
 /**
  * usb_lock_device_for_reset - cautiously acquire the lock for a
  *	usb device structure
@@ -627,7 +567,7 @@ int usb_lock_device_for_reset(struct usb_device *udev,
 		}
 	}
 
-	while (!usb_trylock_device(udev)) {
+	while (usb_trylock_device(udev) != 0) {
 
 		/* If we can't acquire the lock after waiting one second,
 		 * we're probably deadlocked */
@@ -645,39 +585,6 @@ int usb_lock_device_for_reset(struct usb_device *udev,
 	return 1;
 }
 
-/**
- * usb_unlock_device - release the lock for a usb device structure
- * @udev: device that's being unlocked
- *
- * Use this routine when releasing the only device lock you hold;
- * to release inner nested locks call up(&amp;udev-&gt;serialize) directly.
- * This is necessary for proper interaction with usb_lock_all_devices().
- */
-void usb_unlock_device(struct usb_device *udev)
-{
-	up(&amp;udev-&gt;serialize);
-	up_read(&amp;usb_all_devices_rwsem);
-}
-
-/**
- * usb_lock_all_devices - acquire the lock for all usb device structures
- *
- * This is necessary when registering a new driver or probing a bus,
- * since the driver-model core may try to use any usb_device.
- */
-void usb_lock_all_devices(void)
-{
-	down_write(&amp;usb_all_devices_rwsem);
-}
-
-/**
- * usb_unlock_all_devices - release the lock for all usb device structures
- */
-void usb_unlock_all_devices(void)
-{
-	up_write(&amp;usb_all_devices_rwsem);
-}
-
 
 static struct usb_device *match_device(struct usb_device *dev,
 				       u16 vendor_id, u16 product_id)
@@ -700,10 +607,10 @@ static struct usb_device *match_device(struct usb_device *dev,
 	/* look through all of the children of this device */
 	for (child = 0; child &lt; dev-&gt;maxchild; ++child) {
 		if (dev-&gt;children[child]) {
-			down(&amp;dev-&gt;children[child]-&gt;serialize);
+			usb_lock_device(dev-&gt;children[child]);
 			ret_dev = match_device(dev-&gt;children[child],
 					       vendor_id, product_id);
-			up(&amp;dev-&gt;children[child]-&gt;serialize);
+			usb_unlock_device(dev-&gt;children[child]);
 			if (ret_dev)
 				goto exit;
 		}
@@ -1300,10 +1207,7 @@ EXPORT_SYMBOL(usb_put_dev);
 EXPORT_SYMBOL(usb_get_dev);
 EXPORT_SYMBOL(usb_hub_tt_clear_buffer);
 
-EXPORT_SYMBOL(usb_lock_device);
-EXPORT_SYMBOL(usb_trylock_device);
 EXPORT_SYMBOL(usb_lock_device_for_reset);
-EXPORT_SYMBOL(usb_unlock_device);
 
 EXPORT_SYMBOL(usb_driver_claim_interface);
 EXPORT_SYMBOL(usb_driver_release_interface);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 98e85fb4d3b7..4647e1ebc68d 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -16,9 +16,6 @@ extern int usb_get_device_descriptor(struct usb_device *dev,
 extern char *usb_cache_string(struct usb_device *udev, int index);
 extern int usb_set_configuration(struct usb_device *dev, int configuration);
 
-extern void usb_lock_all_devices(void);
-extern void usb_unlock_all_devices(void);
-
 extern void usb_kick_khubd(struct usb_device *dev);
 extern void usb_suspend_root_hub(struct usb_device *hdev);
 extern void usb_resume_root_hub(struct usb_device *dev);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 72e3b12a1926..4b2226d77b34 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -372,7 +372,7 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 					&amp; ohci-&gt;hc_control)
 				== OHCI_USB_OPER
 			&amp;&amp; time_after (jiffies, ohci-&gt;next_statechange)
-			&amp;&amp; usb_trylock_device (hcd-&gt;self.root_hub)
+			&amp;&amp; usb_trylock_device (hcd-&gt;self.root_hub) == 0
 			) {
 		ohci_vdbg (ohci, "autosuspend\n");
 		(void) ohci_bus_suspend (hcd);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 2714814ab66c..46dc0421d19e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -329,8 +329,6 @@ struct usb_device {
 	struct usb_tt	*tt; 		/* low/full speed dev, highspeed hub */
 	int		ttport;		/* device port on that tt hub */
 
-	struct semaphore serialize;
-
 	unsigned int toggle[2];		/* one bit for each endpoint
 					 * ([0] = IN, [1] = OUT) */
 
@@ -377,11 +375,12 @@ struct usb_device {
 extern struct usb_device *usb_get_dev(struct usb_device *dev);
 extern void usb_put_dev(struct usb_device *dev);
 
-extern void usb_lock_device(struct usb_device *udev);
-extern int usb_trylock_device(struct usb_device *udev);
+/* USB device locking */
+#define usb_lock_device(udev)		down(&amp;(udev)-&gt;dev.sem)
+#define usb_unlock_device(udev)		up(&amp;(udev)-&gt;dev.sem)
+#define usb_trylock_device(udev)	down_trylock(&amp;(udev)-&gt;dev.sem)
 extern int usb_lock_device_for_reset(struct usb_device *udev,
 		struct usb_interface *iface);
-extern void usb_unlock_device(struct usb_device *udev);
 
 /* USB port reset for device reinitialization */
 extern int usb_reset_device(struct usb_device *dev);</pre><hr><pre>commit 1c50c317e2e7f15427149cbc216a63366468710e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 14 11:45:38 2005 -0500

    [PATCH] USB: central handling for host controllers that were reset during suspend/resume
    
    This patch (as515b) adds a routine to usbcore to simplify handling of
    host controllers that lost power or were reset during suspend/resume.
    The new core routine marks all the child devices of the root hub as
    NOTATTACHED and tells khubd to disconnect the device structures as soon
    as possible.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index c8a1b350e2cf..591b5aad1a18 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -380,6 +380,7 @@ extern int usb_find_interface_driver (struct usb_device *dev,
 #ifdef CONFIG_PM
 extern void usb_hcd_suspend_root_hub (struct usb_hcd *hcd);
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
+extern void usb_root_hub_lost_power (struct usb_device *rhdev);
 extern int hcd_bus_suspend (struct usb_bus *bus);
 extern int hcd_bus_resume (struct usb_bus *bus);
 #else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index f78bd124d290..5faf7edd73cb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1039,6 +1039,39 @@ void usb_set_device_state(struct usb_device *udev,
 EXPORT_SYMBOL(usb_set_device_state);
 
 
+#ifdef CONFIG_PM
+
+/**
+ * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
+ * @rhdev: struct usb_device for the root hub
+ *
+ * The USB host controller driver calls this function when its root hub
+ * is resumed and Vbus power has been interrupted or the controller
+ * has been reset.  The routine marks all the children of the root hub
+ * as NOTATTACHED and marks logical connect-change events on their ports.
+ */
+void usb_root_hub_lost_power(struct usb_device *rhdev)
+{
+	struct usb_hub *hub;
+	int port1;
+	unsigned long flags;
+
+	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
+	spin_lock_irqsave(&amp;device_state_lock, flags);
+	hub = hdev_to_hub(rhdev);
+	for (port1 = 1; port1 &lt;= rhdev-&gt;maxchild; ++port1) {
+		if (rhdev-&gt;children[port1 - 1]) {
+			recursively_mark_NOTATTACHED(
+					rhdev-&gt;children[port1 - 1]);
+			set_bit(port1, hub-&gt;change_bits);
+		}
+	}
+	spin_unlock_irqrestore(&amp;device_state_lock, flags);
+}
+EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
+
+#endif
+
 static void choose_address(struct usb_device *udev)
 {
 	int		devnum;
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index ac088bc72f1c..08ca0f849dab 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -278,7 +278,6 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
 	unsigned		port;
-	struct usb_device	*root = hcd-&gt;self.root_hub;
 	struct pci_dev		*pdev = to_pci_dev(hcd-&gt;self.controller);
 	int			retval = -EINVAL;
 
@@ -312,13 +311,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 
 restart:
 	ehci_dbg(ehci, "lost power, restarting\n");
-	for (port = HCS_N_PORTS(ehci-&gt;hcs_params); port &gt; 0; ) {
-		port--;
-		if (!root-&gt;children [port])
-			continue;
-		usb_set_device_state(root-&gt;children[port],
-					USB_STATE_NOTATTACHED);
-	}
+	usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 
 	/* Else reset, to cope with power loss or flush-to-storage
 	 * style "resume" having let BIOS kick in during reboot.
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index e3af3ac4416a..a4b12404ae08 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -795,7 +795,6 @@ static int ohci_restart (struct ohci_hcd *ohci)
 	int temp;
 	int i;
 	struct urb_priv *priv;
-	struct usb_device *root = ohci_to_hcd(ohci)-&gt;self.root_hub;
 
 	/* mark any devices gone, so they do nothing till khubd disconnects.
 	 * recycle any "live" eds/tds (and urbs) right away.
@@ -804,11 +803,7 @@ static int ohci_restart (struct ohci_hcd *ohci)
 	 */ 
 	spin_lock_irq(&amp;ohci-&gt;lock);
 	disable (ohci);
-	for (i = 0; i &lt; root-&gt;maxchild; i++) {
-		if (root-&gt;children [i])
-			usb_set_device_state (root-&gt;children[i],
-				USB_STATE_NOTATTACHED);
-	}
+	usb_root_hub_lost_power(ohci_to_hcd(ohci)-&gt;self.root_hub);
 	if (!list_empty (&amp;ohci-&gt;pending))
 		ohci_dbg(ohci, "abort schedule...\n");
 	list_for_each_entry (priv, &amp;ohci-&gt;pending, pending) {
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 3a9cd4607962..517360b77d8e 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1803,6 +1803,7 @@ sl811h_resume(struct platform_device *dev)
 			|| !device_can_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev)) {
 		sl811-&gt;port1 = 0;
 		port_power(sl811, 1);
+		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 		return 0;
 	}
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 1c0394cb3c89..071fab6b6475 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -748,8 +748,12 @@ static int uhci_resume(struct usb_hcd *hcd)
 	check_and_reset_hc(uhci);
 	configure_hc(uhci);
 
-	if (uhci-&gt;rh_state == UHCI_RH_RESET)
+	if (uhci-&gt;rh_state == UHCI_RH_RESET) {
+
+		/* The controller had to be reset */
+		usb_root_hub_lost_power(hcd-&gt;self.root_hub);
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
+	}
 
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 </pre>
    <div class="pagination">
        <a href='2_130.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><span>[131]</span><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_132.html'>Next&gt;&gt;</a>
    <div>
</body>
