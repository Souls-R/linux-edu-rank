<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of New South Wales</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of New South Wales</h1>
    <div class="pagination">
        <a href='8_3.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><span>[4]</span><a href='8_5.html'>5</a><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 72008652dae7d10fa668d7b2ada3bddff7403d86
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Fri Aug 26 18:34:15 2005 -0700

    [PATCH] md: create a MODULE_ALIAS for md corresponding to its block major number.
    
    I just discovered this is needed for module auto-loading.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/md.c b/drivers/md/md.c
index 486ee50cfdda..deccd560c0de 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -4011,3 +4011,4 @@ EXPORT_SYMBOL(md_print_devices);
 EXPORT_SYMBOL(md_check_recovery);
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("md");
+MODULE_ALIAS_BLOCKDEV_MAJOR(MD_MAJOR);</pre><hr><pre>commit 005eca5e74b222db4360f8938140eb843d283325
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Mon Aug 22 13:11:08 2005 -0700

    [PATCH] md: make sure resync gets started when array starts.
    
    We weren't actually waking up the md thread after setting
    MD_RECOVERY_NEEDED when assembling an array, so it is possible to lose a
    race and not actually start resync.
    
    So add a call to md_wakeup_thread, and while we are at it, remove all the
    "if (mddev-&gt;thread)" guards as md_wake_thread does its own checking.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/md.c b/drivers/md/md.c
index d4c275604a3e..486ee50cfdda 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -256,8 +256,7 @@ static inline void mddev_unlock(mddev_t * mddev)
 {
 	up(&amp;mddev-&gt;reconfig_sem);
 
-	if (mddev-&gt;thread)
-		md_wakeup_thread(mddev-&gt;thread);
+	md_wakeup_thread(mddev-&gt;thread);
 }
 
 mdk_rdev_t * find_rdev_nr(mddev_t *mddev, int nr)
@@ -1714,6 +1713,7 @@ static int do_md_run(mddev_t * mddev)
 	mddev-&gt;in_sync = 1;
 	
 	set_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery);
+	md_wakeup_thread(mddev-&gt;thread);
 	
 	if (mddev-&gt;sb_dirty)
 		md_update_sb(mddev);
@@ -2236,8 +2236,7 @@ static int add_new_disk(mddev_t * mddev, mdu_disk_info_t *info)
 			export_rdev(rdev);
 
 		set_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery);
-		if (mddev-&gt;thread)
-			md_wakeup_thread(mddev-&gt;thread);
+		md_wakeup_thread(mddev-&gt;thread);
 		return err;
 	}
 </pre><hr><pre>commit 9223214e8d757663f366133ba5f9b58aa6b28efb
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Aug 18 11:24:16 2005 -0700

    [PATCH] md: make sure mddev-&gt;bitmap_offset gets cleared between array instantiations.
    
    ... otherwise we might try to load a bitmap from an array which hasn't one.
    
    The bug is that if you create an array with an internal bitmap, shut it down,
    and then create an array with the same md device, the md drive will assume it
    should have a bitmap too.  As the array can be created with a different md
    device, it is mostly an inconvenience.  I'm pretty sure there is no risk of
    data corruption.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/md.c b/drivers/md/md.c
index 480f658db6f2..d4c275604a3e 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -623,6 +623,7 @@ static int super_90_validate(mddev_t *mddev, mdk_rdev_t *rdev)
 		mddev-&gt;raid_disks = sb-&gt;raid_disks;
 		mddev-&gt;size = sb-&gt;size;
 		mddev-&gt;events = md_event(sb);
+		mddev-&gt;bitmap_offset = 0;
 
 		if (sb-&gt;state &amp; (1&lt;&lt;MD_SB_CLEAN))
 			mddev-&gt;recovery_cp = MaxSector;
@@ -938,6 +939,7 @@ static int super_1_validate(mddev_t *mddev, mdk_rdev_t *rdev)
 		mddev-&gt;raid_disks = le32_to_cpu(sb-&gt;raid_disks);
 		mddev-&gt;size = le64_to_cpu(sb-&gt;size)/2;
 		mddev-&gt;events = le64_to_cpu(sb-&gt;events);
+		mddev-&gt;bitmap_offset = 0;
 		
 		mddev-&gt;recovery_cp = le64_to_cpu(sb-&gt;resync_offset);
 		memcpy(mddev-&gt;uuid, sb-&gt;set_uuid, 16);
@@ -1824,6 +1826,7 @@ static int do_md_stop(mddev_t * mddev, int ro)
 		fput(mddev-&gt;bitmap_file);
 		mddev-&gt;bitmap_file = NULL;
 	}
+	mddev-&gt;bitmap_offset = 0;
 
 	/*
 	 * Free resources if final stop</pre><hr><pre>commit 6b8b3e8a8b3e62b4209eaa36697e3c9df457e196
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Aug 4 12:53:35 2005 -0700

    [PATCH] md: make sure md bitmap updates are flushed when array is stopped.
    
    The recent change to never ignore the bitmap, revealed that the bitmap isn't
    begin flushed properly when an array is stopped.
    
    We call bitmap_daemon_work three times as there is a three-stage pipeline for
    flushing updates to the bitmap file.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c
index 09d32db06d20..41df4cda66e2 100644
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@ -1450,6 +1450,29 @@ static void bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset)
 
 }
 
+/*
+ * flush out any pending updates
+ */
+void bitmap_flush(mddev_t *mddev)
+{
+	struct bitmap *bitmap = mddev-&gt;bitmap;
+	int sleep;
+
+	if (!bitmap) /* there was no bitmap */
+		return;
+
+	/* run the daemon_work three time to ensure everything is flushed
+	 * that can be
+	 */
+	sleep = bitmap-&gt;daemon_sleep;
+	bitmap-&gt;daemon_sleep = 0;
+	bitmap_daemon_work(bitmap);
+	bitmap_daemon_work(bitmap);
+	bitmap_daemon_work(bitmap);
+	bitmap-&gt;daemon_sleep = sleep;
+	bitmap_update_sb(bitmap);
+}
+
 /*
  * free memory that was allocated
  */
diff --git a/drivers/md/md.c b/drivers/md/md.c
index 9fd4dbea0d0d..480f658db6f2 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -1798,6 +1798,8 @@ static int do_md_stop(mddev_t * mddev, int ro)
 				goto out;
 			mddev-&gt;ro = 1;
 		} else {
+			bitmap_flush(mddev);
+			wait_event(mddev-&gt;sb_wait, atomic_read(&amp;mddev-&gt;pending_writes)==0);
 			if (mddev-&gt;ro)
 				set_disk_ro(disk, 0);
 			blk_queue_make_request(mddev-&gt;queue, md_fail_request);
diff --git a/include/linux/raid/bitmap.h b/include/linux/raid/bitmap.h
index 6213e976eade..4bf1659f8aa8 100644
--- a/include/linux/raid/bitmap.h
+++ b/include/linux/raid/bitmap.h
@@ -248,6 +248,7 @@ struct bitmap {
 
 /* these are used only by md/bitmap */
 int  bitmap_create(mddev_t *mddev);
+void bitmap_flush(mddev_t *mddev);
 void bitmap_destroy(mddev_t *mddev);
 int  bitmap_active(struct bitmap *bitmap);
 </pre><hr><pre>commit e3b9703e27aab3839dcdb76b00d98428b67d25b0
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Aug 4 12:53:34 2005 -0700

    [PATCH] md: yet another attempt to get bitmap-based resync to do the right thing in all cases...
    
    Firstly, R1BIO_Degraded was being set in a number of places in the resync
    code, but is never used there, so get rid of those settings.
    
    Then: When doing a resync, we want to clear the bit in the bitmap iff the
    array will be non-degraded when the sync has completed.  However the current
    code would clear the bitmap if the array was non-degraded when the resync
    *started*, which obviously isn't right (it is for 'resync' but not for
    'recovery' - i.e.  rebuilding a failed drive).
    
    This patch calculated 'still_degraded' and uses the to tell bitmap_start_sync
    whether this sync should clear the corresponding bit.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index d3a64a04a6d8..51d9645ed09c 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -893,7 +893,6 @@ static int end_sync_read(struct bio *bio, unsigned int bytes_done, int error)
 	if (!uptodate) {
 		md_error(r1_bio-&gt;mddev,
 			 conf-&gt;mirrors[r1_bio-&gt;read_disk].rdev);
-		set_bit(R1BIO_Degraded, &amp;r1_bio-&gt;state);
 	} else
 		set_bit(R1BIO_Uptodate, &amp;r1_bio-&gt;state);
 	rdev_dec_pending(conf-&gt;mirrors[r1_bio-&gt;read_disk].rdev, conf-&gt;mddev);
@@ -918,10 +917,9 @@ static int end_sync_write(struct bio *bio, unsigned int bytes_done, int error)
 			mirror = i;
 			break;
 		}
-	if (!uptodate) {
+	if (!uptodate)
 		md_error(mddev, conf-&gt;mirrors[mirror].rdev);
-		set_bit(R1BIO_Degraded, &amp;r1_bio-&gt;state);
-	}
+
 	update_head_pos(mirror, r1_bio);
 
 	if (atomic_dec_and_test(&amp;r1_bio-&gt;remaining)) {
@@ -1109,6 +1107,7 @@ static sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, i
 	int i;
 	int write_targets = 0;
 	int sync_blocks;
+	int still_degraded = 0;
 
 	if (!conf-&gt;r1buf_pool)
 	{
@@ -1137,7 +1136,10 @@ static sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, i
 		return 0;
 	}
 
-	if (!bitmap_start_sync(mddev-&gt;bitmap, sector_nr, &amp;sync_blocks, mddev-&gt;degraded) &amp;&amp;
+	/* before building a request, check if we can skip these blocks..
+	 * This call the bitmap_start_sync doesn't actually record anything
+	 */
+	if (!bitmap_start_sync(mddev-&gt;bitmap, sector_nr, &amp;sync_blocks, 1) &amp;&amp;
 	    !conf-&gt;fullsync) {
 		/* We can skip this block, and probably several more */
 		*skipped = 1;
@@ -1203,24 +1205,23 @@ static sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, i
 		if (i == disk) {
 			bio-&gt;bi_rw = READ;
 			bio-&gt;bi_end_io = end_sync_read;
-		} else if (conf-&gt;mirrors[i].rdev &amp;&amp;
-			   !conf-&gt;mirrors[i].rdev-&gt;faulty &amp;&amp;
-			   (!conf-&gt;mirrors[i].rdev-&gt;in_sync ||
-			    sector_nr + RESYNC_SECTORS &gt; mddev-&gt;recovery_cp)) {
+		} else if (conf-&gt;mirrors[i].rdev == NULL ||
+			   conf-&gt;mirrors[i].rdev-&gt;faulty) {
+			still_degraded = 1;
+			continue;
+		} else if (!conf-&gt;mirrors[i].rdev-&gt;in_sync ||
+			   sector_nr + RESYNC_SECTORS &gt; mddev-&gt;recovery_cp) {
 			bio-&gt;bi_rw = WRITE;
 			bio-&gt;bi_end_io = end_sync_write;
 			write_targets ++;
 		} else
+			/* no need to read or write here */
 			continue;
 		bio-&gt;bi_sector = sector_nr + conf-&gt;mirrors[i].rdev-&gt;data_offset;
 		bio-&gt;bi_bdev = conf-&gt;mirrors[i].rdev-&gt;bdev;
 		bio-&gt;bi_private = r1_bio;
 	}
 
-	if (write_targets + 1 &lt; conf-&gt;raid_disks)
-		/* array degraded, can't clear bitmap */
-		set_bit(R1BIO_Degraded, &amp;r1_bio-&gt;state);
-
 	if (write_targets == 0) {
 		/* There is nowhere to write, so all non-sync
 		 * drives must be failed - so we are finished
@@ -1243,7 +1244,7 @@ static sector_t sync_request(mddev_t *mddev, sector_t sector_nr, int *skipped, i
 			break;
 		if (sync_blocks == 0) {
 			if (!bitmap_start_sync(mddev-&gt;bitmap, sector_nr,
-					&amp;sync_blocks, mddev-&gt;degraded) &amp;&amp;
+					&amp;sync_blocks, still_degraded) &amp;&amp;
 					!conf-&gt;fullsync)
 				break;
 			if (sync_blocks &lt; (PAGE_SIZE&gt;&gt;9))</pre><hr><pre>commit 193f1c931517592ec4188d15bf261e4bff368207
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Aug 4 12:53:33 2005 -0700

    [PATCH] md: always honour md bitmap being read from disk
    
    The code currently will ignore the bitmap if the array seem to be in-sync.
    This is wrong if the array is degraded, and probably wrong anyway.  If the
    bitmap says some chunks are not in in-sync, and the superblock says everything
    IS in sync, then something is clearly wrong, and it is safer to trust the
    bitmap.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c
index 70bca955e0de..09d32db06d20 100644
--- a/drivers/md/bitmap.c
+++ b/drivers/md/bitmap.c
@@ -818,8 +818,7 @@ int bitmap_unplug(struct bitmap *bitmap)
 	return 0;
 }
 
-static void bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset,
-	unsigned long sectors, int in_sync);
+static void bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset);
 /* * bitmap_init_from_disk -- called at bitmap_create time to initialize
  * the in-memory bitmap from the on-disk bitmap -- also, sets up the
  * memory mapping of the bitmap file
@@ -828,7 +827,7 @@ static void bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset,
  *   previously kicked from the array, we mark all the bits as
  *   1's in order to cause a full resync.
  */
-static int bitmap_init_from_disk(struct bitmap *bitmap, int in_sync)
+static int bitmap_init_from_disk(struct bitmap *bitmap)
 {
 	unsigned long i, chunks, index, oldindex, bit;
 	struct page *page = NULL, *oldpage = NULL;
@@ -929,8 +928,7 @@ static int bitmap_init_from_disk(struct bitmap *bitmap, int in_sync)
 		}
 		if (test_bit(bit, page_address(page))) {
 			/* if the disk bit is set, set the memory bit */
-			bitmap_set_memory_bits(bitmap,
-					i &lt;&lt; CHUNK_BLOCK_SHIFT(bitmap), 1, in_sync);
+			bitmap_set_memory_bits(bitmap, i &lt;&lt; CHUNK_BLOCK_SHIFT(bitmap));
 			bit_cnt++;
 		}
 	}
@@ -1426,35 +1424,30 @@ void bitmap_close_sync(struct bitmap *bitmap)
 	}
 }
 
-static void bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset,
-				   unsigned long sectors, int in_sync)
+static void bitmap_set_memory_bits(struct bitmap *bitmap, sector_t offset)
 {
 	/* For each chunk covered by any of these sectors, set the
-	 * counter to 1 and set resync_needed unless in_sync.  They should all
+	 * counter to 1 and set resync_needed.  They should all
 	 * be 0 at this point
 	 */
-	while (sectors) {
-		int secs;
-		bitmap_counter_t *bmc;
-		spin_lock_irq(&amp;bitmap-&gt;lock);
-		bmc = bitmap_get_counter(bitmap, offset, &amp;secs, 1);
-		if (!bmc) {
-			spin_unlock_irq(&amp;bitmap-&gt;lock);
-			return;
-		}
-		if (! *bmc) {
-			struct page *page;
-			*bmc = 1 | (in_sync? 0 : NEEDED_MASK);
-			bitmap_count_page(bitmap, offset, 1);
-			page = filemap_get_page(bitmap, offset &gt;&gt; CHUNK_BLOCK_SHIFT(bitmap));
-			set_page_attr(bitmap, page, BITMAP_PAGE_CLEAN);
-		}
+
+	int secs;
+	bitmap_counter_t *bmc;
+	spin_lock_irq(&amp;bitmap-&gt;lock);
+	bmc = bitmap_get_counter(bitmap, offset, &amp;secs, 1);
+	if (!bmc) {
 		spin_unlock_irq(&amp;bitmap-&gt;lock);
-		if (sectors &gt; secs)
-			sectors -= secs;
-		else
-			sectors = 0;
+		return;
 	}
+	if (! *bmc) {
+		struct page *page;
+		*bmc = 1 | NEEDED_MASK;
+		bitmap_count_page(bitmap, offset, 1);
+		page = filemap_get_page(bitmap, offset &gt;&gt; CHUNK_BLOCK_SHIFT(bitmap));
+		set_page_attr(bitmap, page, BITMAP_PAGE_CLEAN);
+	}
+	spin_unlock_irq(&amp;bitmap-&gt;lock);
+
 }
 
 /*
@@ -1565,7 +1558,8 @@ int bitmap_create(mddev_t *mddev)
 
 	/* now that we have some pages available, initialize the in-memory
 	 * bitmap from the on-disk bitmap */
-	err = bitmap_init_from_disk(bitmap, mddev-&gt;recovery_cp == MaxSector);
+	err = bitmap_init_from_disk(bitmap);
+
 	if (err)
 		return err;
 </pre><hr><pre>commit aa1595e9f3d0d731bcfc6c2680d5483b78f663dc
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Aug 4 12:53:32 2005 -0700

    [PATCH] md: make 'md' and alias for 'md-mod'
    
    Until the bitmap code was added,
    
       modprobe md
    
    would load the md module.  But now the md module is called 'md-mod', so we
    really need an alias for backwards comparability.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/md.c b/drivers/md/md.c
index 08f003aa6cd7..9fd4dbea0d0d 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -4006,3 +4006,4 @@ EXPORT_SYMBOL(md_wakeup_thread);
 EXPORT_SYMBOL(md_print_devices);
 EXPORT_SYMBOL(md_check_recovery);
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("md");</pre><hr><pre>commit efd8be2a4280f334be9309fa4ca1fb8f4e29475d
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Thu Aug 4 12:53:32 2005 -0700

    [PATCH] md: remove a stray debugging printk.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/md.c b/drivers/md/md.c
index 6580e0fa4a47..08f003aa6cd7 100644
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@ -3484,7 +3484,6 @@ static void md_do_sync(mddev_t *mddev)
 			goto skip;
 		}
 		ITERATE_MDDEV(mddev2,tmp) {
-			printk(".");
 			if (mddev2 == mddev)
 				continue;
 			if (mddev2-&gt;curr_resync &amp;&amp; </pre><hr><pre>commit b1581566183f310abbd2d384a9079d4039faca05
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Sun Jul 31 22:34:50 2005 -0700

    [PATCH] md: make sure raid5/raid6 resync uses correct 'max_sectors'
    
    The default resync_max_sector is set to "mddev-&gt;size &lt;&lt; 1".  If the
    raid-personality-module updates mddev-&gt;size, it must update
    resync_max_sectors too.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 4698d5f79575..43f231a467d5 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -1653,6 +1653,7 @@ static int run (mddev_t *mddev)
 
 	/* device size must be a multiple of chunk size */
 	mddev-&gt;size &amp;= ~(mddev-&gt;chunk_size/1024 -1);
+	mddev-&gt;resync_max_sectors = mddev-&gt;size &lt;&lt; 1;
 
 	if (!conf-&gt;chunk_size || conf-&gt;chunk_size % 4) {
 		printk(KERN_ERR "raid5: invalid chunk size %d for %s\n",
diff --git a/drivers/md/raid6main.c b/drivers/md/raid6main.c
index f5ee16805111..495dee1d1e83 100644
--- a/drivers/md/raid6main.c
+++ b/drivers/md/raid6main.c
@@ -1813,6 +1813,7 @@ static int run (mddev_t *mddev)
 
 	/* device size must be a multiple of chunk size */
 	mddev-&gt;size &amp;= ~(mddev-&gt;chunk_size/1024 -1);
+	mddev-&gt;resync_max_sectors = mddev-&gt;size &lt;&lt; 1;
 
 	if (conf-&gt;raid_disks &lt; 4) {
 		printk(KERN_ERR "raid6: not enough configured devices for %s (%d, minimum 4)\n",</pre><hr><pre>commit 4b5c7ae83704320e2afb0912f4c42eadabc7535b
Author: NeilBrown &lt;neilb@cse.unsw.edu.au&gt;
Date:   Wed Jul 27 11:43:28 2005 -0700

    [PATCH] md: when resizing an array, we need to update resync_max_sectors as well as size
    
    Without this, and attempt to 'grow' an array will claim to have synced the
    extra part without actually having done anything.
    
    Signed-off-by: Neil Brown &lt;neilb@cse.unsw.edu.au&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c
index 5f253ee536bb..d3a64a04a6d8 100644
--- a/drivers/md/raid1.c
+++ b/drivers/md/raid1.c
@@ -1468,6 +1468,7 @@ static int raid1_resize(mddev_t *mddev, sector_t sectors)
 		set_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery);
 	}
 	mddev-&gt;size = mddev-&gt;array_size;
+	mddev-&gt;resync_max_sectors = sectors;
 	return 0;
 }
 
diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c
index 93a9726cc2d6..4698d5f79575 100644
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@ -1931,6 +1931,7 @@ static int raid5_resize(mddev_t *mddev, sector_t sectors)
 		set_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery);
 	}
 	mddev-&gt;size = sectors /2;
+	mddev-&gt;resync_max_sectors = sectors;
 	return 0;
 }
 
diff --git a/drivers/md/raid6main.c b/drivers/md/raid6main.c
index f62ea1a73d0d..f5ee16805111 100644
--- a/drivers/md/raid6main.c
+++ b/drivers/md/raid6main.c
@@ -2095,6 +2095,7 @@ static int raid6_resize(mddev_t *mddev, sector_t sectors)
 		set_bit(MD_RECOVERY_NEEDED, &amp;mddev-&gt;recovery);
 	}
 	mddev-&gt;size = sectors /2;
+	mddev-&gt;resync_max_sectors = sectors;
 	return 0;
 }
 </pre>
    <div class="pagination">
        <a href='8_3.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><span>[4]</span><a href='8_5.html'>5</a><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_5.html'>Next&gt;&gt;</a>
    <div>
</body>
