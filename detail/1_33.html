<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_32.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><span>[33]</span><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_34.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8ee0371470038371729a39ee6669a2132ac47649
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 18 13:19:47 2015 -0400

    ext4 crypto: use slab caches
    
    Use slab caches the ext4_crypto_ctx and ext4_crypt_info structures for
    slighly better memory efficiency and debuggability.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index 3a25aa4f3d94..1c34f0eb125b 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -55,6 +55,9 @@ static mempool_t *ext4_bounce_page_pool;
 static LIST_HEAD(ext4_free_crypto_ctxs);
 static DEFINE_SPINLOCK(ext4_crypto_ctx_lock);
 
+static struct kmem_cache *ext4_crypto_ctx_cachep;
+struct kmem_cache *ext4_crypt_info_cachep;
+
 /**
  * ext4_release_crypto_ctx() - Releases an encryption context
  * @ctx: The encryption context to release.
@@ -79,7 +82,7 @@ void ext4_release_crypto_ctx(struct ext4_crypto_ctx *ctx)
 	if (ctx-&gt;flags &amp; EXT4_CTX_REQUIRES_FREE_ENCRYPT_FL) {
 		if (ctx-&gt;tfm)
 			crypto_free_tfm(ctx-&gt;tfm);
-		kfree(ctx);
+		kmem_cache_free(ext4_crypto_ctx_cachep, ctx);
 	} else {
 		spin_lock_irqsave(&amp;ext4_crypto_ctx_lock, flags);
 		list_add(&amp;ctx-&gt;free_list, &amp;ext4_free_crypto_ctxs);
@@ -87,23 +90,6 @@ void ext4_release_crypto_ctx(struct ext4_crypto_ctx *ctx)
 	}
 }
 
-/**
- * ext4_alloc_and_init_crypto_ctx() - Allocates and inits an encryption context
- * @mask: The allocation mask.
- *
- * Return: An allocated and initialized encryption context on success. An error
- * value or NULL otherwise.
- */
-static struct ext4_crypto_ctx *ext4_alloc_and_init_crypto_ctx(gfp_t mask)
-{
-	struct ext4_crypto_ctx *ctx = kzalloc(sizeof(struct ext4_crypto_ctx),
-					      mask);
-
-	if (!ctx)
-		return ERR_PTR(-ENOMEM);
-	return ctx;
-}
-
 /**
  * ext4_get_crypto_ctx() - Gets an encryption context
  * @inode:       The inode for which we are doing the crypto
@@ -121,8 +107,6 @@ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode)
 	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
 
 	BUG_ON(ci == NULL);
-	if (!ext4_read_workqueue)
-		ext4_init_crypto();
 
 	/*
 	 * We first try getting the ctx from a free list because in
@@ -141,9 +125,9 @@ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode)
 		list_del(&amp;ctx-&gt;free_list);
 	spin_unlock_irqrestore(&amp;ext4_crypto_ctx_lock, flags);
 	if (!ctx) {
-		ctx = ext4_alloc_and_init_crypto_ctx(GFP_NOFS);
-		if (IS_ERR(ctx)) {
-			res = PTR_ERR(ctx);
+		ctx = kmem_cache_zalloc(ext4_crypto_ctx_cachep, GFP_NOFS);
+		if (!ctx) {
+			res = -ENOMEM;
 			goto out;
 		}
 		ctx-&gt;flags |= EXT4_CTX_REQUIRES_FREE_ENCRYPT_FL;
@@ -217,7 +201,7 @@ void ext4_exit_crypto(void)
 		}
 		if (pos-&gt;tfm)
 			crypto_free_tfm(pos-&gt;tfm);
-		kfree(pos);
+		kmem_cache_free(ext4_crypto_ctx_cachep, pos);
 	}
 	INIT_LIST_HEAD(&amp;ext4_free_crypto_ctxs);
 	if (ext4_bounce_page_pool)
@@ -226,6 +210,12 @@ void ext4_exit_crypto(void)
 	if (ext4_read_workqueue)
 		destroy_workqueue(ext4_read_workqueue);
 	ext4_read_workqueue = NULL;
+	if (ext4_crypto_ctx_cachep)
+		kmem_cache_destroy(ext4_crypto_ctx_cachep);
+	ext4_crypto_ctx_cachep = NULL;
+	if (ext4_crypt_info_cachep)
+		kmem_cache_destroy(ext4_crypt_info_cachep);
+	ext4_crypt_info_cachep = NULL;
 }
 
 /**
@@ -238,23 +228,31 @@ void ext4_exit_crypto(void)
  */
 int ext4_init_crypto(void)
 {
-	int i, res;
+	int i, res = -ENOMEM;
 
 	mutex_lock(&amp;crypto_init);
 	if (ext4_read_workqueue)
 		goto already_initialized;
 	ext4_read_workqueue = alloc_workqueue("ext4_crypto", WQ_HIGHPRI, 0);
-	if (!ext4_read_workqueue) {
-		res = -ENOMEM;
+	if (!ext4_read_workqueue)
+		goto fail;
+
+	ext4_crypto_ctx_cachep = KMEM_CACHE(ext4_crypto_ctx,
+					    SLAB_RECLAIM_ACCOUNT);
+	if (!ext4_crypto_ctx_cachep)
+		goto fail;
+
+	ext4_crypt_info_cachep = KMEM_CACHE(ext4_crypt_info,
+					    SLAB_RECLAIM_ACCOUNT);
+	if (!ext4_crypt_info_cachep)
 		goto fail;
-	}
 
 	for (i = 0; i &lt; num_prealloc_crypto_ctxs; i++) {
 		struct ext4_crypto_ctx *ctx;
 
-		ctx = ext4_alloc_and_init_crypto_ctx(GFP_KERNEL);
-		if (IS_ERR(ctx)) {
-			res = PTR_ERR(ctx);
+		ctx = kmem_cache_zalloc(ext4_crypto_ctx_cachep, GFP_NOFS);
+		if (!ctx) {
+			res = -ENOMEM;
 			goto fail;
 		}
 		list_add(&amp;ctx-&gt;free_list, &amp;ext4_free_crypto_ctxs);
diff --git a/fs/ext4/crypto_key.c b/fs/ext4/crypto_key.c
index 0075e43ffea6..d6abe4687cd5 100644
--- a/fs/ext4/crypto_key.c
+++ b/fs/ext4/crypto_key.c
@@ -96,7 +96,7 @@ void ext4_free_encryption_info(struct inode *inode)
 		key_put(ci-&gt;ci_keyring_key);
 	crypto_free_ablkcipher(ci-&gt;ci_ctfm);
 	memzero_explicit(&amp;ci-&gt;ci_raw, sizeof(ci-&gt;ci_raw));
-	kfree(ci);
+	kmem_cache_free(ext4_crypt_info_cachep, ci);
 	ei-&gt;i_crypt_info = NULL;
 }
 
@@ -113,6 +113,12 @@ int _ext4_get_encryption_info(struct inode *inode)
 	struct ext4_sb_info *sbi = EXT4_SB(inode-&gt;i_sb);
 	int res;
 
+	if (!ext4_read_workqueue) {
+		res = ext4_init_crypto();
+		if (res)
+			return res;
+	}
+
 	if (ei-&gt;i_crypt_info) {
 		if (!ei-&gt;i_crypt_info-&gt;ci_keyring_key ||
 		    key_validate(ei-&gt;i_crypt_info-&gt;ci_keyring_key) == 0)
@@ -134,7 +140,7 @@ int _ext4_get_encryption_info(struct inode *inode)
 		return -EINVAL;
 	res = 0;
 
-	crypt_info = kmalloc(sizeof(struct ext4_crypt_info), GFP_KERNEL);
+	crypt_info = kmem_cache_alloc(ext4_crypt_info_cachep, GFP_KERNEL);
 	if (!crypt_info)
 		return -ENOMEM;
 
@@ -188,7 +194,7 @@ int _ext4_get_encryption_info(struct inode *inode)
 	if (res &lt; 0) {
 		if (res == -ENOKEY)
 			res = 0;
-		kfree(crypt_info);
+		kmem_cache_free(ext4_crypt_info_cachep, crypt_info);
 	} else {
 		ei-&gt;i_crypt_info = crypt_info;
 		crypt_info-&gt;ci_keyring_key = keyring_key;
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 213536fdab9f..23e33fb3202e 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2059,6 +2059,7 @@ int ext4_get_policy(struct inode *inode,
 		    struct ext4_encryption_policy *policy);
 
 /* crypto.c */
+extern struct kmem_cache *ext4_crypt_info_cachep;
 bool ext4_valid_contents_enc_mode(uint32_t mode);
 uint32_t ext4_validate_encryption_key_size(uint32_t mode, uint32_t size);
 extern struct workqueue_struct *ext4_read_workqueue;</pre><hr><pre>commit f5aed2c2a825618553b20e8a67109570489b40d7
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 18 13:18:47 2015 -0400

    ext4: clean up superblock encryption mode fields
    
    The superblock fields s_file_encryption_mode and s_dir_encryption_mode
    are vestigal, so remove them as a cleanup.  While we're at it, allow
    file systems with both encryption and inline_data enabled at the same
    time to work correctly.  We can't have encrypted inodes with inline
    data, but there's no reason to prohibit unencrypted inodes from using
    the inline data feature.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto_policy.c b/fs/ext4/crypto_policy.c
index 370d3aa0a9cf..683391f790d6 100644
--- a/fs/ext4/crypto_policy.c
+++ b/fs/ext4/crypto_policy.c
@@ -51,6 +51,10 @@ static int ext4_create_encryption_context_from_policy(
 	struct ext4_encryption_context ctx;
 	int res = 0;
 
+	res = ext4_convert_inline_data(inode);
+	if (res)
+		return res;
+
 	ctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;
 	memcpy(ctx.master_key_descriptor, policy-&gt;master_key_descriptor,
 	       EXT4_KEY_DESCRIPTOR_SIZE);
@@ -199,8 +203,9 @@ int ext4_inherit_context(struct inode *parent, struct inode *child)
 	res = ext4_xattr_set(child, EXT4_XATTR_INDEX_ENCRYPTION,
 			     EXT4_XATTR_NAME_ENCRYPTION_CONTEXT, &amp;ctx,
 			     sizeof(ctx), 0);
-	if (!res)
+	if (!res) {
 		ext4_set_inode_flag(child, EXT4_INODE_ENCRYPT);
+		ext4_clear_inode_state(child, EXT4_STATE_MAY_INLINE_DATA);
+	}
 	return res;
-
 }
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index cac1968e63cb..213536fdab9f 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1374,12 +1374,6 @@ struct ext4_sb_info {
 	struct ratelimit_state s_err_ratelimit_state;
 	struct ratelimit_state s_warning_ratelimit_state;
 	struct ratelimit_state s_msg_ratelimit_state;
-
-#ifdef CONFIG_EXT4_FS_ENCRYPTION
-	/* Encryption */
-	uint32_t s_file_encryption_mode;
-	uint32_t s_dir_encryption_mode;
-#endif
 };
 
 static inline struct ext4_sb_info *EXT4_SB(struct super_block *sb)
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 1eaa6cb96cd0..ddca1697ad86 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -1034,28 +1034,9 @@ struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,
 	ext4_set_inode_state(inode, EXT4_STATE_NEW);
 
 	ei-&gt;i_extra_isize = EXT4_SB(sb)-&gt;s_want_extra_isize;
-#ifdef CONFIG_EXT4_FS_ENCRYPTION
-	if ((sbi-&gt;s_file_encryption_mode == EXT4_ENCRYPTION_MODE_INVALID) &amp;&amp;
-	    (sbi-&gt;s_dir_encryption_mode == EXT4_ENCRYPTION_MODE_INVALID)) {
-		ei-&gt;i_inline_off = 0;
-		if (EXT4_HAS_INCOMPAT_FEATURE(sb,
-			EXT4_FEATURE_INCOMPAT_INLINE_DATA))
-			ext4_set_inode_state(inode,
-			EXT4_STATE_MAY_INLINE_DATA);
-	} else {
-		/* Inline data and encryption are incompatible
-		 * We turn off inline data since encryption is enabled */
-		ei-&gt;i_inline_off = 1;
-		if (EXT4_HAS_INCOMPAT_FEATURE(sb,
-			EXT4_FEATURE_INCOMPAT_INLINE_DATA))
-			ext4_clear_inode_state(inode,
-			EXT4_STATE_MAY_INLINE_DATA);
-	}
-#else
 	ei-&gt;i_inline_off = 0;
 	if (EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_INLINE_DATA))
 		ext4_set_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);
-#endif
 	ret = inode;
 	err = dquot_alloc_inode(inode);
 	if (err)
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index e0dac100fbe6..b0bd1c1061b3 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3452,11 +3452,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	if (sb-&gt;s_bdev-&gt;bd_part)
 		sbi-&gt;s_sectors_written_start =
 			part_stat_read(sb-&gt;s_bdev-&gt;bd_part, sectors[1]);
-#ifdef CONFIG_EXT4_FS_ENCRYPTION
-	/* Modes of operations for file and directory encryption. */
-	sbi-&gt;s_file_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;
-	sbi-&gt;s_dir_encryption_mode = EXT4_ENCRYPTION_MODE_INVALID;
-#endif
 
 	/* Cleanup superblock name */
 	for (cp = sb-&gt;s_id; (cp = strchr(cp, '/'));)</pre><hr><pre>commit b7236e21d55ff9008737621c84dd8ee6c37c7c6d
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 18 13:17:47 2015 -0400

    ext4 crypto: reorganize how we store keys in the inode
    
    This is a pretty massive patch which does a number of different things:
    
    1) The per-inode encryption information is now stored in an allocated
       data structure, ext4_crypt_info, instead of directly in the node.
       This reduces the size usage of an in-memory inode when it is not
       using encryption.
    
    2) We drop the ext4_fname_crypto_ctx entirely, and use the per-inode
       encryption structure instead.  This remove an unnecessary memory
       allocation and free for the fname_crypto_ctx as well as allowing us
       to reuse the ctfm in a directory for multiple lookups and file
       creations.
    
    3) We also cache the inode's policy information in the ext4_crypt_info
       structure so we don't have to continually read it out of the
       extended attributes.
    
    4) We now keep the keyring key in the inode's encryption structure
       instead of releasing it after we are done using it to derive the
       per-inode key.  This allows us to test to see if the key has been
       revoked; if it has, we prevent the use of the derived key and free
       it.
    
    5) When an inode is released (or when the derived key is freed), we
       will use memset_explicit() to zero out the derived key, so it's not
       left hanging around in memory.  This implies that when a user logs
       out, it is important to first revoke the key, and then unlink it,
       and then finally, to use "echo 3 &gt; /proc/sys/vm/drop_caches" to
       release any decrypted pages and dcache entries from the system
       caches.
    
    6) All this, and we also shrink the number of lines of code by around
       100.  :-)
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index 918200ed9bf8..3a25aa4f3d94 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -118,8 +118,9 @@ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode)
 	struct ext4_crypto_ctx *ctx = NULL;
 	int res = 0;
 	unsigned long flags;
-	struct ext4_crypt_info *ci = &amp;EXT4_I(inode)-&gt;i_crypt_info;
+	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
 
+	BUG_ON(ci == NULL);
 	if (!ext4_read_workqueue)
 		ext4_init_crypto();
 
@@ -322,7 +323,7 @@ static int ext4_page_crypto(struct ext4_crypto_ctx *ctx,
 	int res = 0;
 
 	BUG_ON(!ctx-&gt;tfm);
-	BUG_ON(ctx-&gt;mode != ei-&gt;i_crypt_info.ci_mode);
+	BUG_ON(ctx-&gt;mode != ei-&gt;i_crypt_info-&gt;ci_mode);
 
 	if (ctx-&gt;mode != EXT4_ENCRYPTION_MODE_AES_256_XTS) {
 		printk_ratelimited(KERN_ERR
@@ -334,8 +335,8 @@ static int ext4_page_crypto(struct ext4_crypto_ctx *ctx,
 	crypto_ablkcipher_clear_flags(atfm, ~0);
 	crypto_tfm_set_flags(ctx-&gt;tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 
-	res = crypto_ablkcipher_setkey(atfm, ei-&gt;i_crypt_info.ci_raw,
-				       ei-&gt;i_crypt_info.ci_size);
+	res = crypto_ablkcipher_setkey(atfm, ei-&gt;i_crypt_info-&gt;ci_raw,
+				       ei-&gt;i_crypt_info-&gt;ci_size);
 	if (res) {
 		printk_ratelimited(KERN_ERR
 				   "%s: crypto_ablkcipher_setkey() failed\n",
diff --git a/fs/ext4/crypto_fname.c b/fs/ext4/crypto_fname.c
index d9f08ddbfda2..374d0e790315 100644
--- a/fs/ext4/crypto_fname.c
+++ b/fs/ext4/crypto_fname.c
@@ -48,6 +48,12 @@ bool ext4_valid_filenames_enc_mode(uint32_t mode)
 	return (mode == EXT4_ENCRYPTION_MODE_AES_256_CTS);
 }
 
+static unsigned max_name_len(struct inode *inode)
+{
+	return S_ISLNK(inode-&gt;i_mode) ? inode-&gt;i_sb-&gt;s_blocksize :
+		EXT4_NAME_LEN;
+}
+
 /**
  * ext4_fname_encrypt() -
  *
@@ -55,28 +61,30 @@ bool ext4_valid_filenames_enc_mode(uint32_t mode)
  * ciphertext. Errors are returned as negative numbers.  We trust the caller to
  * allocate sufficient memory to oname string.
  */
-static int ext4_fname_encrypt(struct ext4_fname_crypto_ctx *ctx,
+static int ext4_fname_encrypt(struct inode *inode,
 			      const struct qstr *iname,
 			      struct ext4_str *oname)
 {
 	u32 ciphertext_len;
 	struct ablkcipher_request *req = NULL;
 	DECLARE_EXT4_COMPLETION_RESULT(ecr);
-	struct crypto_ablkcipher *tfm = ctx-&gt;ctfm;
+	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
+	struct crypto_ablkcipher *tfm = ci-&gt;ci_ctfm;
 	int res = 0;
 	char iv[EXT4_CRYPTO_BLOCK_SIZE];
 	struct scatterlist src_sg, dst_sg;
-	int padding = 4 &lt;&lt; (ctx-&gt;flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
+	int padding = 4 &lt;&lt; (ci-&gt;ci_flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
 	char *workbuf, buf[32], *alloc_buf = NULL;
+	unsigned lim = max_name_len(inode);
 
-	if (iname-&gt;len &lt;= 0 || iname-&gt;len &gt; ctx-&gt;lim)
+	if (iname-&gt;len &lt;= 0 || iname-&gt;len &gt; lim)
 		return -EIO;
 
 	ciphertext_len = (iname-&gt;len &lt; EXT4_CRYPTO_BLOCK_SIZE) ?
 		EXT4_CRYPTO_BLOCK_SIZE : iname-&gt;len;
 	ciphertext_len = ext4_fname_crypto_round_up(ciphertext_len, padding);
-	ciphertext_len = (ciphertext_len &gt; ctx-&gt;lim)
-			? ctx-&gt;lim : ciphertext_len;
+	ciphertext_len = (ciphertext_len &gt; lim)
+			? lim : ciphertext_len;
 
 	if (ciphertext_len &lt;= sizeof(buf)) {
 		workbuf = buf;
@@ -134,7 +142,7 @@ static int ext4_fname_encrypt(struct ext4_fname_crypto_ctx *ctx,
  *	Errors are returned as negative numbers.
  *	We trust the caller to allocate sufficient memory to oname string.
  */
-static int ext4_fname_decrypt(struct ext4_fname_crypto_ctx *ctx,
+static int ext4_fname_decrypt(struct inode *inode,
 			      const struct ext4_str *iname,
 			      struct ext4_str *oname)
 {
@@ -142,11 +150,13 @@ static int ext4_fname_decrypt(struct ext4_fname_crypto_ctx *ctx,
 	struct ablkcipher_request *req = NULL;
 	DECLARE_EXT4_COMPLETION_RESULT(ecr);
 	struct scatterlist src_sg, dst_sg;
-	struct crypto_ablkcipher *tfm = ctx-&gt;ctfm;
+	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
+	struct crypto_ablkcipher *tfm = ci-&gt;ci_ctfm;
 	int res = 0;
 	char iv[EXT4_CRYPTO_BLOCK_SIZE];
+	unsigned lim = max_name_len(inode);
 
-	if (iname-&gt;len &lt;= 0 || iname-&gt;len &gt; ctx-&gt;lim)
+	if (iname-&gt;len &lt;= 0 || iname-&gt;len &gt; lim)
 		return -EIO;
 
 	tmp_in[0].name = iname-&gt;name;
@@ -242,171 +252,50 @@ static int digest_decode(const char *src, int len, char *dst)
 	return cp - dst;
 }
 
-/**
- * ext4_free_fname_crypto_ctx() -
- *
- * Frees up a crypto context.
- */
-void ext4_free_fname_crypto_ctx(struct ext4_fname_crypto_ctx *ctx)
-{
-	if (ctx == NULL || IS_ERR(ctx))
-		return;
-
-	if (ctx-&gt;ctfm &amp;&amp; !IS_ERR(ctx-&gt;ctfm))
-		crypto_free_ablkcipher(ctx-&gt;ctfm);
-	if (ctx-&gt;htfm &amp;&amp; !IS_ERR(ctx-&gt;htfm))
-		crypto_free_hash(ctx-&gt;htfm);
-	kfree(ctx);
-}
-
-/**
- * ext4_put_fname_crypto_ctx() -
- *
- * Return: The crypto context onto free list. If the free list is above a
- * threshold, completely frees up the context, and returns the memory.
- *
- * TODO: Currently we directly free the crypto context. Eventually we should
- * add code it to return to free list. Such an approach will increase
- * efficiency of directory lookup.
- */
-void ext4_put_fname_crypto_ctx(struct ext4_fname_crypto_ctx **ctx)
+int ext4_setup_fname_crypto(struct inode *inode)
 {
-	if (*ctx == NULL || IS_ERR(*ctx))
-		return;
-	ext4_free_fname_crypto_ctx(*ctx);
-	*ctx = NULL;
-}
-
-/**
- * ext4_alloc_fname_crypto_ctx() -
- */
-struct ext4_fname_crypto_ctx *ext4_alloc_fname_crypto_ctx(
-	const struct ext4_crypt_info *ci)
-{
-	struct ext4_fname_crypto_ctx *ctx;
-
-	ctx = kmalloc(sizeof(struct ext4_fname_crypto_ctx), GFP_NOFS);
-	if (ctx == NULL)
-		return ERR_PTR(-ENOMEM);
-	if (ci-&gt;ci_mode == EXT4_ENCRYPTION_MODE_INVALID) {
-		/* This will automatically set key mode to invalid
-		 * As enum for ENCRYPTION_MODE_INVALID is zero */
-		memset(&amp;ctx-&gt;ci, 0, sizeof(ctx-&gt;ci));
-	} else {
-		memcpy(&amp;ctx-&gt;ci, ci, sizeof(struct ext4_crypt_info));
-	}
-	ctx-&gt;has_valid_key = (EXT4_ENCRYPTION_MODE_INVALID == ci-&gt;ci_mode)
-		? 0 : 1;
-	ctx-&gt;ctfm_key_is_ready = 0;
-	ctx-&gt;ctfm = NULL;
-	ctx-&gt;htfm = NULL;
-	return ctx;
-}
-
-/**
- * ext4_get_fname_crypto_ctx() -
- *
- * Allocates a free crypto context and initializes it to hold
- * the crypto material for the inode.
- *
- * Return: NULL if not encrypted. Error value on error. Valid pointer otherwise.
- */
-struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(
-	struct inode *inode, u32 max_ciphertext_len)
-{
-	struct ext4_fname_crypto_ctx *ctx;
 	struct ext4_inode_info *ei = EXT4_I(inode);
+	struct ext4_crypt_info *ci = ei-&gt;i_crypt_info;
+	struct crypto_ablkcipher *ctfm;
 	int res;
 
 	/* Check if the crypto policy is set on the inode */
 	res = ext4_encrypted_inode(inode);
 	if (res == 0)
-		return NULL;
-
-	if (!ext4_has_encryption_key(inode))
-		ext4_generate_encryption_key(inode);
-
-	/* Get a crypto context based on the key. */
-	ctx = ext4_alloc_fname_crypto_ctx(&amp;(ei-&gt;i_crypt_info));
-	if (IS_ERR(ctx))
-		return ctx;
-
-	ctx-&gt;flags = ei-&gt;i_crypt_policy_flags;
-	if (ctx-&gt;has_valid_key) {
-		if (ctx-&gt;ci.ci_mode != EXT4_ENCRYPTION_MODE_AES_256_CTS) {
-			printk_once(KERN_WARNING
-				    "ext4: unsupported key mode %d\n",
-				    ctx-&gt;ci.ci_mode);
-			return ERR_PTR(-ENOKEY);
-		}
+		return 0;
 
-		/* As a first cut, we will allocate new tfm in every call.
-		 * later, we will keep the tfm around, in case the key gets
-		 * re-used */
-		if (ctx-&gt;ctfm == NULL) {
-			ctx-&gt;ctfm = crypto_alloc_ablkcipher("cts(cbc(aes))",
-					0, 0);
-		}
-		if (IS_ERR(ctx-&gt;ctfm)) {
-			res = PTR_ERR(ctx-&gt;ctfm);
-			printk(
-			    KERN_DEBUG "%s: error (%d) allocating crypto tfm\n",
-			    __func__, res);
-			ctx-&gt;ctfm = NULL;
-			ext4_put_fname_crypto_ctx(&amp;ctx);
-			return ERR_PTR(res);
-		}
-		if (ctx-&gt;ctfm == NULL) {
-			printk(
-			    KERN_DEBUG "%s: could not allocate crypto tfm\n",
-			    __func__);
-			ext4_put_fname_crypto_ctx(&amp;ctx);
-			return ERR_PTR(-ENOMEM);
-		}
-		ctx-&gt;lim = max_ciphertext_len;
-		crypto_ablkcipher_clear_flags(ctx-&gt;ctfm, ~0);
-		crypto_tfm_set_flags(crypto_ablkcipher_tfm(ctx-&gt;ctfm),
-			CRYPTO_TFM_REQ_WEAK_KEY);
-
-		/* If we are lucky, we will get a context that is already
-		 * set up with the right key. Else, we will have to
-		 * set the key */
-		if (!ctx-&gt;ctfm_key_is_ready) {
-			/* Since our crypto objectives for filename encryption
-			 * are pretty weak,
-			 * we directly use the inode master key */
-			res = crypto_ablkcipher_setkey(ctx-&gt;ctfm,
-					ctx-&gt;ci.ci_raw, ctx-&gt;ci.ci_size);
-			if (res) {
-				ext4_put_fname_crypto_ctx(&amp;ctx);
-				return ERR_PTR(-EIO);
-			}
-			ctx-&gt;ctfm_key_is_ready = 1;
-		} else {
-			/* In the current implementation, key should never be
-			 * marked "ready" for a context that has just been
-			 * allocated. So we should never reach here */
-			 BUG();
-		}
-	}
-	if (ctx-&gt;htfm == NULL)
-		ctx-&gt;htfm = crypto_alloc_hash("sha256", 0, CRYPTO_ALG_ASYNC);
-	if (IS_ERR(ctx-&gt;htfm)) {
-		res = PTR_ERR(ctx-&gt;htfm);
-		printk(KERN_DEBUG "%s: error (%d) allocating hash tfm\n",
-			__func__, res);
-		ctx-&gt;htfm = NULL;
-		ext4_put_fname_crypto_ctx(&amp;ctx);
-		return ERR_PTR(res);
+	res = ext4_get_encryption_info(inode);
+	if (res &lt; 0)
+		return res;
+	ci = ei-&gt;i_crypt_info;
+
+	if (!ci || ci-&gt;ci_ctfm)
+		return 0;
+
+	if (ci-&gt;ci_mode != EXT4_ENCRYPTION_MODE_AES_256_CTS) {
+		printk_once(KERN_WARNING "ext4: unsupported key mode %d\n",
+			    ci-&gt;ci_mode);
+		return -ENOKEY;
 	}
-	if (ctx-&gt;htfm == NULL) {
-		printk(KERN_DEBUG "%s: could not allocate hash tfm\n",
-				__func__);
-		ext4_put_fname_crypto_ctx(&amp;ctx);
-		return ERR_PTR(-ENOMEM);
+
+	ctfm = crypto_alloc_ablkcipher("cts(cbc(aes))", 0, 0);
+	if (!ctfm || IS_ERR(ctfm)) {
+		res = ctfm ? PTR_ERR(ctfm) : -ENOMEM;
+		printk(KERN_DEBUG "%s: error (%d) allocating crypto tfm\n",
+		       __func__, res);
+		return res;
 	}
+	crypto_ablkcipher_clear_flags(ctfm, ~0);
+	crypto_tfm_set_flags(crypto_ablkcipher_tfm(ctfm),
+			     CRYPTO_TFM_REQ_WEAK_KEY);
 
-	return ctx;
+	res = crypto_ablkcipher_setkey(ctfm, ci-&gt;ci_raw, ci-&gt;ci_size);
+	if (res) {
+		crypto_free_ablkcipher(ctfm);
+		return -EIO;
+	}
+	ci-&gt;ci_ctfm = ctfm;
+	return 0;
 }
 
 /**
@@ -419,41 +308,21 @@ u32 ext4_fname_crypto_round_up(u32 size, u32 blksize)
 	return ((size+blksize-1)/blksize)*blksize;
 }
 
-/**
- * ext4_fname_crypto_namelen_on_disk() -
- */
-int ext4_fname_crypto_namelen_on_disk(struct ext4_fname_crypto_ctx *ctx,
-				      u32 namelen)
-{
-	u32 ciphertext_len;
-	int padding = 4 &lt;&lt; (ctx-&gt;flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
-
-	if (ctx == NULL)
-		return -EIO;
-	if (!(ctx-&gt;has_valid_key))
-		return -EACCES;
-	ciphertext_len = (namelen &lt; EXT4_CRYPTO_BLOCK_SIZE) ?
-		EXT4_CRYPTO_BLOCK_SIZE : namelen;
-	ciphertext_len = ext4_fname_crypto_round_up(ciphertext_len, padding);
-	ciphertext_len = (ciphertext_len &gt; ctx-&gt;lim)
-			? ctx-&gt;lim : ciphertext_len;
-	return (int) ciphertext_len;
-}
-
 /**
  * ext4_fname_crypto_alloc_obuff() -
  *
  * Allocates an output buffer that is sufficient for the crypto operation
  * specified by the context and the direction.
  */
-int ext4_fname_crypto_alloc_buffer(struct ext4_fname_crypto_ctx *ctx,
+int ext4_fname_crypto_alloc_buffer(struct inode *inode,
 				   u32 ilen, struct ext4_str *crypto_str)
 {
 	unsigned int olen;
-	int padding = 4 &lt;&lt; (ctx-&gt;flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
+	int padding = 16;
+	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
 
-	if (!ctx)
-		return -EIO;
+	if (ci)
+		padding = 4 &lt;&lt; (ci-&gt;ci_flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
 	if (padding &lt; EXT4_CRYPTO_BLOCK_SIZE)
 		padding = EXT4_CRYPTO_BLOCK_SIZE;
 	olen = ext4_fname_crypto_round_up(ilen, padding);
@@ -484,7 +353,7 @@ void ext4_fname_crypto_free_buffer(struct ext4_str *crypto_str)
 /**
  * ext4_fname_disk_to_usr() - converts a filename from disk space to user space
  */
-int _ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
+int _ext4_fname_disk_to_usr(struct inode *inode,
 			    struct dx_hash_info *hinfo,
 			    const struct ext4_str *iname,
 			    struct ext4_str *oname)
@@ -492,8 +361,6 @@ int _ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
 	char buf[24];
 	int ret;
 
-	if (ctx == NULL)
-		return -EIO;
 	if (iname-&gt;len &lt; 3) {
 		/*Check for . and .. */
 		if (iname-&gt;name[0] == '.' &amp;&amp; iname-&gt;name[iname-&gt;len-1] == '.') {
@@ -503,8 +370,8 @@ int _ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
 			return oname-&gt;len;
 		}
 	}
-	if (ctx-&gt;has_valid_key)
-		return ext4_fname_decrypt(ctx, iname, oname);
+	if (EXT4_I(inode)-&gt;i_crypt_info)
+		return ext4_fname_decrypt(inode, iname, oname);
 
 	if (iname-&gt;len &lt;= EXT4_FNAME_CRYPTO_DIGEST_SIZE) {
 		ret = digest_encode(iname-&gt;name, iname-&gt;len, oname-&gt;name);
@@ -523,7 +390,7 @@ int _ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
 	return ret + 1;
 }
 
-int ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
+int ext4_fname_disk_to_usr(struct inode *inode,
 			   struct dx_hash_info *hinfo,
 			   const struct ext4_dir_entry_2 *de,
 			   struct ext4_str *oname)
@@ -531,21 +398,20 @@ int ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
 	struct ext4_str iname = {.name = (unsigned char *) de-&gt;name,
 				 .len = de-&gt;name_len };
 
-	return _ext4_fname_disk_to_usr(ctx, hinfo, &amp;iname, oname);
+	return _ext4_fname_disk_to_usr(inode, hinfo, &amp;iname, oname);
 }
 
 
 /**
  * ext4_fname_usr_to_disk() - converts a filename from user space to disk space
  */
-int ext4_fname_usr_to_disk(struct ext4_fname_crypto_ctx *ctx,
+int ext4_fname_usr_to_disk(struct inode *inode,
 			   const struct qstr *iname,
 			   struct ext4_str *oname)
 {
 	int res;
+	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
 
-	if (ctx == NULL)
-		return -EIO;
 	if (iname-&gt;len &lt; 3) {
 		/*Check for . and .. */
 		if (iname-&gt;name[0] == '.' &amp;&amp;
@@ -556,8 +422,8 @@ int ext4_fname_usr_to_disk(struct ext4_fname_crypto_ctx *ctx,
 			return oname-&gt;len;
 		}
 	}
-	if (ctx-&gt;has_valid_key) {
-		res = ext4_fname_encrypt(ctx, iname, oname);
+	if (ci) {
+		res = ext4_fname_encrypt(inode, iname, oname);
 		return res;
 	}
 	/* Without a proper key, a user is not allowed to modify the filenames
@@ -569,16 +435,13 @@ int ext4_fname_usr_to_disk(struct ext4_fname_crypto_ctx *ctx,
 int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 			      int lookup, struct ext4_filename *fname)
 {
-	struct ext4_fname_crypto_ctx *ctx;
+	struct ext4_crypt_info *ci;
 	int ret = 0, bigname = 0;
 
 	memset(fname, 0, sizeof(struct ext4_filename));
 	fname-&gt;usr_fname = iname;
 
-	ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
-	if (IS_ERR(ctx))
-		return PTR_ERR(ctx);
-	if ((ctx == NULL) ||
+	if (!ext4_encrypted_inode(dir) ||
 	    ((iname-&gt;name[0] == '.') &amp;&amp;
 	     ((iname-&gt;len == 1) ||
 	      ((iname-&gt;name[1] == '.') &amp;&amp; (iname-&gt;len == 2))))) {
@@ -586,12 +449,16 @@ int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 		fname-&gt;disk_name.len = iname-&gt;len;
 		goto out;
 	}
-	if (ctx-&gt;has_valid_key) {
-		ret = ext4_fname_crypto_alloc_buffer(ctx, iname-&gt;len,
+	ret = ext4_setup_fname_crypto(dir);
+	if (ret)
+		return ret;
+	ci = EXT4_I(dir)-&gt;i_crypt_info;
+	if (ci) {
+		ret = ext4_fname_crypto_alloc_buffer(dir, iname-&gt;len,
 						     &amp;fname-&gt;crypto_buf);
 		if (ret &lt; 0)
 			goto out;
-		ret = ext4_fname_encrypt(ctx, iname, &amp;fname-&gt;crypto_buf);
+		ret = ext4_fname_encrypt(dir, iname, &amp;fname-&gt;crypto_buf);
 		if (ret &lt; 0)
 			goto out;
 		fname-&gt;disk_name.name = fname-&gt;crypto_buf.name;
@@ -634,7 +501,6 @@ int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 	}
 	ret = 0;
 out:
-	ext4_put_fname_crypto_ctx(&amp;ctx);
 	return ret;
 }
 
diff --git a/fs/ext4/crypto_key.c b/fs/ext4/crypto_key.c
index ec6635dc50f9..0075e43ffea6 100644
--- a/fs/ext4/crypto_key.c
+++ b/fs/ext4/crypto_key.c
@@ -84,14 +84,26 @@ static int ext4_derive_key_aes(char deriving_key[EXT4_AES_128_ECB_KEY_SIZE],
 	return res;
 }
 
-/**
- * ext4_generate_encryption_key() - generates an encryption key
- * @inode: The inode to generate the encryption key for.
- */
-int ext4_generate_encryption_key(struct inode *inode)
+void ext4_free_encryption_info(struct inode *inode)
+{
+	struct ext4_inode_info *ei = EXT4_I(inode);
+	struct ext4_crypt_info *ci = ei-&gt;i_crypt_info;
+
+	if (!ci)
+		return;
+
+	if (ci-&gt;ci_keyring_key)
+		key_put(ci-&gt;ci_keyring_key);
+	crypto_free_ablkcipher(ci-&gt;ci_ctfm);
+	memzero_explicit(&amp;ci-&gt;ci_raw, sizeof(ci-&gt;ci_raw));
+	kfree(ci);
+	ei-&gt;i_crypt_info = NULL;
+}
+
+int _ext4_get_encryption_info(struct inode *inode)
 {
 	struct ext4_inode_info *ei = EXT4_I(inode);
-	struct ext4_crypt_info *crypt_info = &amp;ei-&gt;i_crypt_info;
+	struct ext4_crypt_info *crypt_info;
 	char full_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +
 				 (EXT4_KEY_DESCRIPTOR_SIZE * 2) + 1];
 	struct key *keyring_key = NULL;
@@ -99,18 +111,40 @@ int ext4_generate_encryption_key(struct inode *inode)
 	struct ext4_encryption_context ctx;
 	struct user_key_payload *ukp;
 	struct ext4_sb_info *sbi = EXT4_SB(inode-&gt;i_sb);
-	int res = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,
-				 EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,
-				 &amp;ctx, sizeof(ctx));
+	int res;
 
-	if (res != sizeof(ctx)) {
-		if (res &gt; 0)
-			res = -EINVAL;
-		goto out;
+	if (ei-&gt;i_crypt_info) {
+		if (!ei-&gt;i_crypt_info-&gt;ci_keyring_key ||
+		    key_validate(ei-&gt;i_crypt_info-&gt;ci_keyring_key) == 0)
+			return 0;
+		ext4_free_encryption_info(inode);
 	}
+
+	res = ext4_xattr_get(inode, EXT4_XATTR_INDEX_ENCRYPTION,
+				 EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,
+				 &amp;ctx, sizeof(ctx));
+	if (res &lt; 0) {
+		if (!DUMMY_ENCRYPTION_ENABLED(sbi))
+			return res;
+		ctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;
+		ctx.filenames_encryption_mode =
+			EXT4_ENCRYPTION_MODE_AES_256_CTS;
+		ctx.flags = 0;
+	} else if (res != sizeof(ctx))
+		return -EINVAL;
 	res = 0;
 
+	crypt_info = kmalloc(sizeof(struct ext4_crypt_info), GFP_KERNEL);
+	if (!crypt_info)
+		return -ENOMEM;
+
 	ei-&gt;i_crypt_policy_flags = ctx.flags;
+	crypt_info-&gt;ci_flags = ctx.flags;
+	crypt_info-&gt;ci_data_mode = ctx.contents_encryption_mode;
+	crypt_info-&gt;ci_filename_mode = ctx.filenames_encryption_mode;
+	crypt_info-&gt;ci_ctfm = NULL;
+	memcpy(crypt_info-&gt;ci_master_key, ctx.master_key_descriptor,
+	       sizeof(crypt_info-&gt;ci_master_key));
 	if (S_ISREG(inode-&gt;i_mode))
 		crypt_info-&gt;ci_mode = ctx.contents_encryption_mode;
 	else if (S_ISDIR(inode-&gt;i_mode) || S_ISLNK(inode-&gt;i_mode))
@@ -151,17 +185,23 @@ int ext4_generate_encryption_key(struct inode *inode)
 	res = ext4_derive_key_aes(ctx.nonce, master_key-&gt;raw,
 				  crypt_info-&gt;ci_raw);
 out:
+	if (res &lt; 0) {
+		if (res == -ENOKEY)
+			res = 0;
+		kfree(crypt_info);
+	} else {
+		ei-&gt;i_crypt_info = crypt_info;
+		crypt_info-&gt;ci_keyring_key = keyring_key;
+		keyring_key = NULL;
+	}
 	if (keyring_key)
 		key_put(keyring_key);
-	if (res &lt; 0)
-		crypt_info-&gt;ci_mode = EXT4_ENCRYPTION_MODE_INVALID;
 	return res;
 }
 
 int ext4_has_encryption_key(struct inode *inode)
 {
 	struct ext4_inode_info *ei = EXT4_I(inode);
-	struct ext4_crypt_info *crypt_info = &amp;ei-&gt;i_crypt_info;
 
-	return (crypt_info-&gt;ci_mode != EXT4_ENCRYPTION_MODE_INVALID);
+	return (ei-&gt;i_crypt_info != NULL);
 }
diff --git a/fs/ext4/crypto_policy.c b/fs/ext4/crypto_policy.c
index a6d6291aea16..370d3aa0a9cf 100644
--- a/fs/ext4/crypto_policy.c
+++ b/fs/ext4/crypto_policy.c
@@ -126,7 +126,7 @@ int ext4_get_policy(struct inode *inode, struct ext4_encryption_policy *policy)
 int ext4_is_child_context_consistent_with_parent(struct inode *parent,
 						 struct inode *child)
 {
-	struct ext4_encryption_context parent_ctx, child_ctx;
+	struct ext4_crypt_info *parent_ci, *child_ci;
 	int res;
 
 	if ((parent == NULL) || (child == NULL)) {
@@ -136,26 +136,28 @@ int ext4_is_child_context_consistent_with_parent(struct inode *parent,
 	/* no restrictions if the parent directory is not encrypted */
 	if (!ext4_encrypted_inode(parent))
 		return 1;
-	res = ext4_xattr_get(parent, EXT4_XATTR_INDEX_ENCRYPTION,
-			     EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,
-			     &amp;parent_ctx, sizeof(parent_ctx));
-	if (res != sizeof(parent_ctx))
-		return 0;
 	/* if the child directory is not encrypted, this is always a problem */
 	if (!ext4_encrypted_inode(child))
 		return 0;
-	res = ext4_xattr_get(child, EXT4_XATTR_INDEX_ENCRYPTION,
-			     EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,
-			     &amp;child_ctx, sizeof(child_ctx));
-	if (res != sizeof(child_ctx))
+	res = ext4_get_encryption_info(parent);
+	if (res)
+		return 0;
+	res = ext4_get_encryption_info(child);
+	if (res)
+		return 0;
+	parent_ci = EXT4_I(parent)-&gt;i_crypt_info;
+	child_ci = EXT4_I(child)-&gt;i_crypt_info;
+	if (!parent_ci &amp;&amp; !child_ci)
+		return 1;
+	if (!parent_ci || !child_ci)
 		return 0;
-	return (memcmp(parent_ctx.master_key_descriptor,
-		       child_ctx.master_key_descriptor,
+
+	return (memcmp(parent_ci-&gt;ci_master_key,
+		       child_ci-&gt;ci_master_key,
 		       EXT4_KEY_DESCRIPTOR_SIZE) == 0 &amp;&amp;
-		(parent_ctx.contents_encryption_mode ==
-		 child_ctx.contents_encryption_mode) &amp;&amp;
-		(parent_ctx.filenames_encryption_mode ==
-		 child_ctx.filenames_encryption_mode));
+		(parent_ci-&gt;ci_data_mode == child_ci-&gt;ci_data_mode) &amp;&amp;
+		(parent_ci-&gt;ci_filename_mode == child_ci-&gt;ci_filename_mode) &amp;&amp;
+		(parent_ci-&gt;ci_flags == child_ci-&gt;ci_flags));
 }
 
 /**
@@ -168,31 +170,37 @@ int ext4_is_child_context_consistent_with_parent(struct inode *parent,
 int ext4_inherit_context(struct inode *parent, struct inode *child)
 {
 	struct ext4_encryption_context ctx;
-	int res = ext4_xattr_get(parent, EXT4_XATTR_INDEX_ENCRYPTION,
-				 EXT4_XATTR_NAME_ENCRYPTION_CONTEXT,
-				 &amp;ctx, sizeof(ctx));
+	struct ext4_crypt_info *ci;
+	int res;
+
+	res = ext4_get_encryption_info(parent);
+	if (res &lt; 0)
+		return res;
+	ci = EXT4_I(parent)-&gt;i_crypt_info;
+	BUG_ON(ci == NULL);
 
-	if (res != sizeof(ctx)) {
-		if (DUMMY_ENCRYPTION_ENABLED(EXT4_SB(parent-&gt;i_sb))) {
-			ctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;
-			ctx.contents_encryption_mode =
-				EXT4_ENCRYPTION_MODE_AES_256_XTS;
-			ctx.filenames_encryption_mode =
-				EXT4_ENCRYPTION_MODE_AES_256_CTS;
-			ctx.flags = 0;
-			memset(ctx.master_key_descriptor, 0x42,
-			       EXT4_KEY_DESCRIPTOR_SIZE);
-			res = 0;
-		} else {
-			goto out;
-		}
+	ctx.format = EXT4_ENCRYPTION_CONTEXT_FORMAT_V1;
+	if (DUMMY_ENCRYPTION_ENABLED(EXT4_SB(parent-&gt;i_sb))) {
+		ctx.contents_encryption_mode = EXT4_ENCRYPTION_MODE_AES_256_XTS;
+		ctx.filenames_encryption_mode =
+			EXT4_ENCRYPTION_MODE_AES_256_CTS;
+		ctx.flags = 0;
+		memset(ctx.master_key_descriptor, 0x42,
+		       EXT4_KEY_DESCRIPTOR_SIZE);
+		res = 0;
+	} else {
+		ctx.contents_encryption_mode = ci-&gt;ci_data_mode;
+		ctx.filenames_encryption_mode = ci-&gt;ci_filename_mode;
+		ctx.flags = ci-&gt;ci_flags;
+		memcpy(ctx.master_key_descriptor, ci-&gt;ci_master_key,
+		       EXT4_KEY_DESCRIPTOR_SIZE);
 	}
 	get_random_bytes(ctx.nonce, EXT4_KEY_DERIVATION_NONCE_SIZE);
 	res = ext4_xattr_set(child, EXT4_XATTR_INDEX_ENCRYPTION,
 			     EXT4_XATTR_NAME_ENCRYPTION_CONTEXT, &amp;ctx,
 			     sizeof(ctx), 0);
-out:
 	if (!res)
 		ext4_set_inode_flag(child, EXT4_INODE_ENCRYPT);
 	return res;
+
 }
diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index d799d5d571e9..28cb94fbb1c9 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -110,7 +110,6 @@ static int ext4_readdir(struct file *file, struct dir_context *ctx)
 	struct super_block *sb = inode-&gt;i_sb;
 	struct buffer_head *bh = NULL;
 	int dir_has_error = 0;
-	struct ext4_fname_crypto_ctx *enc_ctx = NULL;
 	struct ext4_str fname_crypto_str = {.name = NULL, .len = 0};
 
 	if (is_dx_dir(inode)) {
@@ -134,16 +133,14 @@ static int ext4_readdir(struct file *file, struct dir_context *ctx)
 			return err;
 	}
 
-	enc_ctx = ext4_get_fname_crypto_ctx(inode, EXT4_NAME_LEN);
-	if (IS_ERR(enc_ctx))
-		return PTR_ERR(enc_ctx);
-	if (enc_ctx) {
-		err = ext4_fname_crypto_alloc_buffer(enc_ctx, EXT4_NAME_LEN,
+	err = ext4_setup_fname_crypto(inode);
+	if (err)
+		return err;
+	if (ext4_encrypted_inode(inode)) {
+		err = ext4_fname_crypto_alloc_buffer(inode, EXT4_NAME_LEN,
 						     &amp;fname_crypto_str);
-		if (err &lt; 0) {
-			ext4_put_fname_crypto_ctx(&amp;enc_ctx);
+		if (err &lt; 0)
 			return err;
-		}
 	}
 
 	offset = ctx-&gt;pos &amp; (sb-&gt;s_blocksize - 1);
@@ -239,8 +236,7 @@ static int ext4_readdir(struct file *file, struct dir_context *ctx)
 			offset += ext4_rec_len_from_disk(de-&gt;rec_len,
 					sb-&gt;s_blocksize);
 			if (le32_to_cpu(de-&gt;inode)) {
-				if (enc_ctx == NULL) {
-					/* Directory is not encrypted */
+				if (!ext4_encrypted_inode(inode)) {
 					if (!dir_emit(ctx, de-&gt;name,
 					    de-&gt;name_len,
 					    le32_to_cpu(de-&gt;inode),
@@ -250,7 +246,7 @@ static int ext4_readdir(struct file *file, struct dir_context *ctx)
 					int save_len = fname_crypto_str.len;
 
 					/* Directory is encrypted */
-					err = ext4_fname_disk_to_usr(enc_ctx,
+					err = ext4_fname_disk_to_usr(inode,
 						NULL, de, &amp;fname_crypto_str);
 					fname_crypto_str.len = save_len;
 					if (err &lt; 0)
@@ -275,7 +271,6 @@ static int ext4_readdir(struct file *file, struct dir_context *ctx)
 	err = 0;
 errout:
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
-	ext4_put_fname_crypto_ctx(&amp;enc_ctx);
 	ext4_fname_crypto_free_buffer(&amp;fname_crypto_str);
 #endif
 	brelse(bh);
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 3cf3bcb6b239..cac1968e63cb 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -955,7 +955,7 @@ struct ext4_inode_info {
 
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
 	/* Encryption params */
-	struct ext4_crypt_info i_crypt_info;
+	struct ext4_crypt_info *i_crypt_info;
 #endif
 };
 
@@ -2096,37 +2096,30 @@ static inline int ext4_sb_has_crypto(struct super_block *sb)
 /* crypto_fname.c */
 bool ext4_valid_filenames_enc_mode(uint32_t mode);
 u32 ext4_fname_crypto_round_up(u32 size, u32 blksize);
-int ext4_fname_crypto_alloc_buffer(struct ext4_fname_crypto_ctx *ctx,
+int ext4_fname_crypto_alloc_buffer(struct inode *inode,
 				   u32 ilen, struct ext4_str *crypto_str);
-int _ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
+int _ext4_fname_disk_to_usr(struct inode *inode,
 			    struct dx_hash_info *hinfo,
 			    const struct ext4_str *iname,
 			    struct ext4_str *oname);
-int ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
+int ext4_fname_disk_to_usr(struct inode *inode,
 			   struct dx_hash_info *hinfo,
 			   const struct ext4_dir_entry_2 *de,
 			   struct ext4_str *oname);
-int ext4_fname_usr_to_disk(struct ext4_fname_crypto_ctx *ctx,
+int ext4_fname_usr_to_disk(struct inode *inode,
 			   const struct qstr *iname,
 			   struct ext4_str *oname);
-int ext4_fname_crypto_namelen_on_disk(struct ext4_fname_crypto_ctx *ctx,
-				      u32 namelen);
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
-void ext4_put_fname_crypto_ctx(struct ext4_fname_crypto_ctx **ctx);
-struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(struct inode *inode,
-							u32 max_len);
+int ext4_setup_fname_crypto(struct inode *inode);
 void ext4_fname_crypto_free_buffer(struct ext4_str *crypto_str);
 int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
 			      int lookup, struct ext4_filename *fname);
 void ext4_fname_free_filename(struct ext4_filename *fname);
 #else
 static inline
-void ext4_put_fname_crypto_ctx(struct ext4_fname_crypto_ctx **ctx) { }
-static inline
-struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(struct inode *inode,
-							u32 max_len)
+int ext4_setup_fname_crypto(struct inode *inode)
 {
-	return NULL;
+	return 0;
 }
 static inline void ext4_fname_crypto_free_buffer(struct ext4_str *p) { }
 static inline int ext4_fname_setup_filename(struct inode *dir,
@@ -2143,15 +2136,34 @@ static inline void ext4_fname_free_filename(struct ext4_filename *fname) { }
 
 
 /* crypto_key.c */
-int ext4_generate_encryption_key(struct inode *inode);
+void ext4_free_encryption_info(struct inode *inode);
+int _ext4_get_encryption_info(struct inode *inode);
 
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
 int ext4_has_encryption_key(struct inode *inode);
+
+static inline int ext4_get_encryption_info(struct inode *inode)
+{
+	struct ext4_crypt_info *ci = EXT4_I(inode)-&gt;i_crypt_info;
+
+	if (!ci ||
+	    (ci-&gt;ci_keyring_key &amp;&amp;
+	     (ci-&gt;ci_keyring_key-&gt;flags &amp; ((1 &lt;&lt; KEY_FLAG_INVALIDATED) |
+					   (1 &lt;&lt; KEY_FLAG_REVOKED) |
+					   (1 &lt;&lt; KEY_FLAG_DEAD)))))
+		return _ext4_get_encryption_info(inode);
+	return 0;
+}
+
 #else
 static inline int ext4_has_encryption_key(struct inode *inode)
 {
 	return 0;
 }
+static inline int ext4_get_encryption_info(struct inode *inode)
+{
+	return 0;
+}
 #endif
 
 
diff --git a/fs/ext4/ext4_crypto.h b/fs/ext4/ext4_crypto.h
index deecbe8968d1..d29687c232bd 100644
--- a/fs/ext4/ext4_crypto.h
+++ b/fs/ext4/ext4_crypto.h
@@ -76,7 +76,13 @@ struct ext4_encryption_key {
 struct ext4_crypt_info {
 	unsigned char	ci_mode;
 	unsigned char	ci_size;
+	char		ci_data_mode;
+	char		ci_filename_mode;
+	char		ci_flags;
+	struct crypto_ablkcipher *ci_ctfm;
+	struct key	*ci_keyring_key;
 	char		ci_raw[EXT4_MAX_KEY_SIZE];
+	char		ci_master_key[EXT4_KEY_DESCRIPTOR_SIZE];
 };
 
 #define EXT4_CTX_REQUIRES_FREE_ENCRYPT_FL             0x00000001
@@ -128,16 +134,6 @@ struct ext4_str {
 	u32 len;
 };
 
-struct ext4_fname_crypto_ctx {
-	u32 lim;
-	struct crypto_ablkcipher *ctfm;
-	struct crypto_hash *htfm;
-	struct ext4_crypt_info ci;
-	unsigned flags : 8;
-	unsigned has_valid_key : 1;
-	unsigned ctfm_key_is_ready : 1;
-};
-
 /**
  * For encrypted symlinks, the ciphertext length is stored at the beginning
  * of the string in little-endian format.
diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 0613c256c344..875ca6b95a4b 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -223,7 +223,7 @@ static int ext4_file_mmap(struct file *file, struct vm_area_struct *vma)
 	struct inode *inode = file-&gt;f_mapping-&gt;host;
 
 	if (ext4_encrypted_inode(inode)) {
-		int err = ext4_generate_encryption_key(inode);
+		int err = ext4_get_encryption_info(inode);
 		if (err)
 			return 0;
 	}
@@ -289,7 +289,7 @@ static int ext4_file_open(struct inode * inode, struct file * filp)
 	}
 	ret = dquot_file_open(inode, filp);
 	if (!ret &amp;&amp; ext4_encrypted_inode(inode)) {
-		ret = ext4_generate_encryption_key(inode);
+		ret = ext4_get_encryption_info(inode);
 		if (ret)
 			ret = -EACCES;
 	}
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index b3406434c267..9bed99fdd81a 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -607,17 +607,14 @@ static struct stats dx_show_leaf(struct inode *dir,
 				char *name;
 				struct ext4_str fname_crypto_str
 					= {.name = NULL, .len = 0};
-				struct ext4_fname_crypto_ctx *ctx = NULL;
 				int res;
 
 				name  = de-&gt;name;
 				len = de-&gt;name_len;
-				ctx = ext4_get_fname_crypto_ctx(dir,
-								EXT4_NAME_LEN);
-				if (IS_ERR(ctx)) {
-					printk(KERN_WARNING "Error acquiring"
-					" crypto ctxt--skipping crypto\n");
-					ctx = NULL;
+				res = ext4_setup_fname_crypto(dir);
+				if (res) {
+					printk(KERN_WARNING "Error setting up"
+					       " fname crypto: %d\n", res);
 				}
 				if (ctx == NULL) {
 					/* Directory is not encrypted */
@@ -637,7 +634,6 @@ static struct stats dx_show_leaf(struct inode *dir,
 							"allocating crypto "
 							"buffer--skipping "
 							"crypto\n");
-						ext4_put_fname_crypto_ctx(&amp;ctx);
 						ctx = NULL;
 					}
 					res = ext4_fname_disk_to_usr(ctx, NULL, de,
@@ -658,7 +654,6 @@ static struct stats dx_show_leaf(struct inode *dir,
 					printk("%*.s:(E)%x.%u ", len, name,
 					       h.hash, (unsigned) ((char *) de
 								   - base));
-					ext4_put_fname_crypto_ctx(&amp;ctx);
 					ext4_fname_crypto_free_buffer(
 						&amp;fname_crypto_str);
 				}
@@ -944,7 +939,6 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 	struct buffer_head *bh;
 	struct ext4_dir_entry_2 *de, *top;
 	int err = 0, count = 0;
-	struct ext4_fname_crypto_ctx *ctx = NULL;
 	struct ext4_str fname_crypto_str = {.name = NULL, .len = 0}, tmp_str;
 
 	dxtrace(printk(KERN_INFO "In htree dirblock_to_tree: block %lu\n",
@@ -959,17 +953,15 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 					   EXT4_DIR_REC_LEN(0));
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
 	/* Check if the directory is encrypted */
-	ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
-	if (IS_ERR(ctx)) {
-		err = PTR_ERR(ctx);
+	err = ext4_setup_fname_crypto(dir);
+	if (err) {
 		brelse(bh);
 		return err;
 	}
-	if (ctx != NULL) {
-		err = ext4_fname_crypto_alloc_buffer(ctx, EXT4_NAME_LEN,
+	if (ext4_encrypted_inode(dir)) {
+		err = ext4_fname_crypto_alloc_buffer(dir, EXT4_NAME_LEN,
 						     &amp;fname_crypto_str);
 		if (err &lt; 0) {
-			ext4_put_fname_crypto_ctx(&amp;ctx);
 			brelse(bh);
 			return err;
 		}
@@ -990,8 +982,7 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 			continue;
 		if (de-&gt;inode == 0)
 			continue;
-		if (ctx == NULL) {
-			/* Directory is not encrypted */
+		if (!ext4_encrypted_inode(dir)) {
 			tmp_str.name = de-&gt;name;
 			tmp_str.len = de-&gt;name_len;
 			err = ext4_htree_store_dirent(dir_file,
@@ -1001,7 +992,7 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 			int save_len = fname_crypto_str.len;
 
 			/* Directory is encrypted */
-			err = ext4_fname_disk_to_usr(ctx, hinfo, de,
+			err = ext4_fname_disk_to_usr(dir, hinfo, de,
 						     &amp;fname_crypto_str);
 			if (err &lt; 0) {
 				count = err;
@@ -1021,7 +1012,6 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 errout:
 	brelse(bh);
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
-	ext4_put_fname_crypto_ctx(&amp;ctx);
 	ext4_fname_crypto_free_buffer(&amp;fname_crypto_str);
 #endif
 	return count;
@@ -3107,7 +3097,6 @@ static int ext4_symlink(struct inode *dir,
 	}
 
 	if (encryption_required) {
-		struct ext4_fname_crypto_ctx *ctx = NULL;
 		struct qstr istr;
 		struct ext4_str ostr;
 
@@ -3119,19 +3108,14 @@ static int ext4_symlink(struct inode *dir,
 		err = ext4_inherit_context(dir, inode);
 		if (err)
 			goto err_drop_inode;
-		ctx = ext4_get_fname_crypto_ctx(inode,
-						inode-&gt;i_sb-&gt;s_blocksize);
-		if (IS_ERR_OR_NULL(ctx)) {
-			/* We just set the policy, so ctx should not be NULL */
-			err = (ctx == NULL) ? -EIO : PTR_ERR(ctx);
+		err = ext4_setup_fname_crypto(inode);
+		if (err)
 			goto err_drop_inode;
-		}
 		istr.name = (const unsigned char *) symname;
 		istr.len = len;
 		ostr.name = sd-&gt;encrypted_path;
 		ostr.len = disk_link.len;
-		err = ext4_fname_usr_to_disk(ctx, &amp;istr, &amp;ostr);
-		ext4_put_fname_crypto_ctx(&amp;ctx);
+		err = ext4_fname_usr_to_disk(inode, &amp;istr, &amp;ostr);
 		if (err &lt; 0)
 			goto err_drop_inode;
 		sd-&gt;len = cpu_to_le16(ostr.len);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index bcd7a4bc9036..e0dac100fbe6 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -879,9 +879,8 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 	atomic_set(&amp;ei-&gt;i_unwritten, 0);
 	INIT_WORK(&amp;ei-&gt;i_rsv_conversion_work, ext4_end_io_rsv_work);
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
-	ei-&gt;i_crypt_info.ci_mode = EXT4_ENCRYPTION_MODE_INVALID;
+	ei-&gt;i_crypt_info = NULL;
 #endif
-
 	return &amp;ei-&gt;vfs_inode;
 }
 
@@ -958,6 +957,10 @@ void ext4_clear_inode(struct inode *inode)
 		jbd2_free_inode(EXT4_I(inode)-&gt;jinode);
 		EXT4_I(inode)-&gt;jinode = NULL;
 	}
+#ifdef CONFIG_EXT4_FS_ENCRYPTION
+	if (EXT4_I(inode)-&gt;i_crypt_info)
+		ext4_free_encryption_info(inode);
+#endif
 }
 
 static struct inode *ext4_nfs_get_inode(struct super_block *sb,
diff --git a/fs/ext4/symlink.c b/fs/ext4/symlink.c
index ca65d45c7f8d..32870881188e 100644
--- a/fs/ext4/symlink.c
+++ b/fs/ext4/symlink.c
@@ -29,7 +29,6 @@ static void *ext4_follow_link(struct dentry *dentry, struct nameidata *nd)
 	char *caddr, *paddr = NULL;
 	struct ext4_str cstr, pstr;
 	struct inode *inode = d_inode(dentry);
-	struct ext4_fname_crypto_ctx *ctx = NULL;
 	struct ext4_encrypted_symlink_data *sd;
 	loff_t size = min_t(loff_t, i_size_read(inode), PAGE_SIZE - 1);
 	int res;
@@ -38,19 +37,17 @@ static void *ext4_follow_link(struct dentry *dentry, struct nameidata *nd)
 	if (!ext4_encrypted_inode(inode))
 		return page_follow_link_light(dentry, nd);
 
-	ctx = ext4_get_fname_crypto_ctx(inode, inode-&gt;i_sb-&gt;s_blocksize);
-	if (IS_ERR(ctx))
-		return ctx;
+	res = ext4_setup_fname_crypto(inode);
+	if (res)
+		return ERR_PTR(res);
 
 	if (ext4_inode_is_fast_symlink(inode)) {
 		caddr = (char *) EXT4_I(inode)-&gt;i_data;
 		max_size = sizeof(EXT4_I(inode)-&gt;i_data);
 	} else {
 		cpage = read_mapping_page(inode-&gt;i_mapping, 0, NULL);
-		if (IS_ERR(cpage)) {
-			ext4_put_fname_crypto_ctx(&amp;ctx);
+		if (IS_ERR(cpage))
 			return cpage;
-		}
 		caddr = kmap(cpage);
 		caddr[size] = 0;
 	}
@@ -75,21 +72,19 @@ static void *ext4_follow_link(struct dentry *dentry, struct nameidata *nd)
 	}
 	pstr.name = paddr;
 	pstr.len = plen;
-	res = _ext4_fname_disk_to_usr(ctx, NULL, &amp;cstr, &amp;pstr);
+	res = _ext4_fname_disk_to_usr(inode, NULL, &amp;cstr, &amp;pstr);
 	if (res &lt; 0)
 		goto errout;
 	/* Null-terminate the name */
 	if (res &lt;= plen)
 		paddr[res] = '\0';
 	nd_set_link(nd, paddr);
-	ext4_put_fname_crypto_ctx(&amp;ctx);
 	if (cpage) {
 		kunmap(cpage);
 		page_cache_release(cpage);
 	}
 	return NULL;
 errout:
-	ext4_put_fname_crypto_ctx(&amp;ctx);
 	if (cpage) {
 		kunmap(cpage);
 		page_cache_release(cpage);</pre><hr><pre>commit e2881b1b51d871a72911faf2fc7e090655940506
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 18 13:16:47 2015 -0400

    ext4 crypto: separate kernel and userspace structure for the key
    
    Use struct ext4_encryption_key only for the master key passed via the
    kernel keyring.
    
    For internal kernel space users, we now use struct ext4_crypt_info.
    This will allow us to put information from the policy structure so we
    can cache it and avoid needing to constantly looking up the extended
    attribute.  We will do this in a spearate patch.  This patch is mostly
    mechnical to make it easier for patch review.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c
index 8ff15273ab0c..918200ed9bf8 100644
--- a/fs/ext4/crypto.c
+++ b/fs/ext4/crypto.c
@@ -118,7 +118,7 @@ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode)
 	struct ext4_crypto_ctx *ctx = NULL;
 	int res = 0;
 	unsigned long flags;
-	struct ext4_encryption_key *key = &amp;EXT4_I(inode)-&gt;i_encryption_key;
+	struct ext4_crypt_info *ci = &amp;EXT4_I(inode)-&gt;i_crypt_info;
 
 	if (!ext4_read_workqueue)
 		ext4_init_crypto();
@@ -152,14 +152,14 @@ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode)
 
 	/* Allocate a new Crypto API context if we don't already have
 	 * one or if it isn't the right mode. */
-	BUG_ON(key-&gt;mode == EXT4_ENCRYPTION_MODE_INVALID);
-	if (ctx-&gt;tfm &amp;&amp; (ctx-&gt;mode != key-&gt;mode)) {
+	BUG_ON(ci-&gt;ci_mode == EXT4_ENCRYPTION_MODE_INVALID);
+	if (ctx-&gt;tfm &amp;&amp; (ctx-&gt;mode != ci-&gt;ci_mode)) {
 		crypto_free_tfm(ctx-&gt;tfm);
 		ctx-&gt;tfm = NULL;
 		ctx-&gt;mode = EXT4_ENCRYPTION_MODE_INVALID;
 	}
 	if (!ctx-&gt;tfm) {
-		switch (key-&gt;mode) {
+		switch (ci-&gt;ci_mode) {
 		case EXT4_ENCRYPTION_MODE_AES_256_XTS:
 			ctx-&gt;tfm = crypto_ablkcipher_tfm(
 				crypto_alloc_ablkcipher("xts(aes)", 0, 0));
@@ -177,9 +177,9 @@ struct ext4_crypto_ctx *ext4_get_crypto_ctx(struct inode *inode)
 			ctx-&gt;tfm = NULL;
 			goto out;
 		}
-		ctx-&gt;mode = key-&gt;mode;
+		ctx-&gt;mode = ci-&gt;ci_mode;
 	}
-	BUG_ON(key-&gt;size != ext4_encryption_key_size(key-&gt;mode));
+	BUG_ON(ci-&gt;ci_size != ext4_encryption_key_size(ci-&gt;ci_mode));
 
 	/* There shouldn't be a bounce page attached to the crypto
 	 * context at this point. */
@@ -322,7 +322,7 @@ static int ext4_page_crypto(struct ext4_crypto_ctx *ctx,
 	int res = 0;
 
 	BUG_ON(!ctx-&gt;tfm);
-	BUG_ON(ctx-&gt;mode != ei-&gt;i_encryption_key.mode);
+	BUG_ON(ctx-&gt;mode != ei-&gt;i_crypt_info.ci_mode);
 
 	if (ctx-&gt;mode != EXT4_ENCRYPTION_MODE_AES_256_XTS) {
 		printk_ratelimited(KERN_ERR
@@ -334,8 +334,8 @@ static int ext4_page_crypto(struct ext4_crypto_ctx *ctx,
 	crypto_ablkcipher_clear_flags(atfm, ~0);
 	crypto_tfm_set_flags(ctx-&gt;tfm, CRYPTO_TFM_REQ_WEAK_KEY);
 
-	res = crypto_ablkcipher_setkey(atfm, ei-&gt;i_encryption_key.raw,
-				       ei-&gt;i_encryption_key.size);
+	res = crypto_ablkcipher_setkey(atfm, ei-&gt;i_crypt_info.ci_raw,
+				       ei-&gt;i_crypt_info.ci_size);
 	if (res) {
 		printk_ratelimited(KERN_ERR
 				   "%s: crypto_ablkcipher_setkey() failed\n",
diff --git a/fs/ext4/crypto_fname.c b/fs/ext4/crypto_fname.c
index 23d7f1d56b00..d9f08ddbfda2 100644
--- a/fs/ext4/crypto_fname.c
+++ b/fs/ext4/crypto_fname.c
@@ -277,34 +277,25 @@ void ext4_put_fname_crypto_ctx(struct ext4_fname_crypto_ctx **ctx)
 	*ctx = NULL;
 }
 
-/**
- * ext4_search_fname_crypto_ctx() -
- */
-static struct ext4_fname_crypto_ctx *ext4_search_fname_crypto_ctx(
-		const struct ext4_encryption_key *key)
-{
-	return NULL;
-}
-
 /**
  * ext4_alloc_fname_crypto_ctx() -
  */
 struct ext4_fname_crypto_ctx *ext4_alloc_fname_crypto_ctx(
-	const struct ext4_encryption_key *key)
+	const struct ext4_crypt_info *ci)
 {
 	struct ext4_fname_crypto_ctx *ctx;
 
 	ctx = kmalloc(sizeof(struct ext4_fname_crypto_ctx), GFP_NOFS);
 	if (ctx == NULL)
 		return ERR_PTR(-ENOMEM);
-	if (key-&gt;mode == EXT4_ENCRYPTION_MODE_INVALID) {
+	if (ci-&gt;ci_mode == EXT4_ENCRYPTION_MODE_INVALID) {
 		/* This will automatically set key mode to invalid
 		 * As enum for ENCRYPTION_MODE_INVALID is zero */
-		memset(&amp;ctx-&gt;key, 0, sizeof(ctx-&gt;key));
+		memset(&amp;ctx-&gt;ci, 0, sizeof(ctx-&gt;ci));
 	} else {
-		memcpy(&amp;ctx-&gt;key, key, sizeof(struct ext4_encryption_key));
+		memcpy(&amp;ctx-&gt;ci, ci, sizeof(struct ext4_crypt_info));
 	}
-	ctx-&gt;has_valid_key = (EXT4_ENCRYPTION_MODE_INVALID == key-&gt;mode)
+	ctx-&gt;has_valid_key = (EXT4_ENCRYPTION_MODE_INVALID == ci-&gt;ci_mode)
 		? 0 : 1;
 	ctx-&gt;ctfm_key_is_ready = 0;
 	ctx-&gt;ctfm = NULL;
@@ -335,21 +326,17 @@ struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(
 	if (!ext4_has_encryption_key(inode))
 		ext4_generate_encryption_key(inode);
 
-	/* Get a crypto context based on the key.
-	 * A new context is allocated if no context matches the requested key.
-	 */
-	ctx = ext4_search_fname_crypto_ctx(&amp;(ei-&gt;i_encryption_key));
-	if (ctx == NULL)
-		ctx = ext4_alloc_fname_crypto_ctx(&amp;(ei-&gt;i_encryption_key));
+	/* Get a crypto context based on the key. */
+	ctx = ext4_alloc_fname_crypto_ctx(&amp;(ei-&gt;i_crypt_info));
 	if (IS_ERR(ctx))
 		return ctx;
 
 	ctx-&gt;flags = ei-&gt;i_crypt_policy_flags;
 	if (ctx-&gt;has_valid_key) {
-		if (ctx-&gt;key.mode != EXT4_ENCRYPTION_MODE_AES_256_CTS) {
+		if (ctx-&gt;ci.ci_mode != EXT4_ENCRYPTION_MODE_AES_256_CTS) {
 			printk_once(KERN_WARNING
 				    "ext4: unsupported key mode %d\n",
-				    ctx-&gt;key.mode);
+				    ctx-&gt;ci.ci_mode);
 			return ERR_PTR(-ENOKEY);
 		}
 
@@ -389,7 +376,7 @@ struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(
 			 * are pretty weak,
 			 * we directly use the inode master key */
 			res = crypto_ablkcipher_setkey(ctx-&gt;ctfm,
-					ctx-&gt;key.raw, ctx-&gt;key.size);
+					ctx-&gt;ci.ci_raw, ctx-&gt;ci.ci_size);
 			if (res) {
 				ext4_put_fname_crypto_ctx(&amp;ctx);
 				return ERR_PTR(-EIO);
diff --git a/fs/ext4/crypto_key.c b/fs/ext4/crypto_key.c
index 52170d0b7c40..ec6635dc50f9 100644
--- a/fs/ext4/crypto_key.c
+++ b/fs/ext4/crypto_key.c
@@ -91,7 +91,7 @@ static int ext4_derive_key_aes(char deriving_key[EXT4_AES_128_ECB_KEY_SIZE],
 int ext4_generate_encryption_key(struct inode *inode)
 {
 	struct ext4_inode_info *ei = EXT4_I(inode);
-	struct ext4_encryption_key *crypt_key = &amp;ei-&gt;i_encryption_key;
+	struct ext4_crypt_info *crypt_info = &amp;ei-&gt;i_crypt_info;
 	char full_key_descriptor[EXT4_KEY_DESC_PREFIX_SIZE +
 				 (EXT4_KEY_DESCRIPTOR_SIZE * 2) + 1];
 	struct key *keyring_key = NULL;
@@ -112,17 +112,17 @@ int ext4_generate_encryption_key(struct inode *inode)
 
 	ei-&gt;i_crypt_policy_flags = ctx.flags;
 	if (S_ISREG(inode-&gt;i_mode))
-		crypt_key-&gt;mode = ctx.contents_encryption_mode;
+		crypt_info-&gt;ci_mode = ctx.contents_encryption_mode;
 	else if (S_ISDIR(inode-&gt;i_mode) || S_ISLNK(inode-&gt;i_mode))
-		crypt_key-&gt;mode = ctx.filenames_encryption_mode;
+		crypt_info-&gt;ci_mode = ctx.filenames_encryption_mode;
 	else {
 		printk(KERN_ERR "ext4 crypto: Unsupported inode type.\n");
 		BUG();
 	}
-	crypt_key-&gt;size = ext4_encryption_key_size(crypt_key-&gt;mode);
-	BUG_ON(!crypt_key-&gt;size);
+	crypt_info-&gt;ci_size = ext4_encryption_key_size(crypt_info-&gt;ci_mode);
+	BUG_ON(!crypt_info-&gt;ci_size);
 	if (DUMMY_ENCRYPTION_ENABLED(sbi)) {
-		memset(crypt_key-&gt;raw, 0x42, EXT4_AES_256_XTS_KEY_SIZE);
+		memset(crypt_info-&gt;ci_raw, 0x42, EXT4_AES_256_XTS_KEY_SIZE);
 		goto out;
 	}
 	memcpy(full_key_descriptor, EXT4_KEY_DESC_PREFIX,
@@ -148,19 +148,20 @@ int ext4_generate_encryption_key(struct inode *inode)
 	BUILD_BUG_ON(EXT4_AES_128_ECB_KEY_SIZE !=
 		     EXT4_KEY_DERIVATION_NONCE_SIZE);
 	BUG_ON(master_key-&gt;size != EXT4_AES_256_XTS_KEY_SIZE);
-	res = ext4_derive_key_aes(ctx.nonce, master_key-&gt;raw, crypt_key-&gt;raw);
+	res = ext4_derive_key_aes(ctx.nonce, master_key-&gt;raw,
+				  crypt_info-&gt;ci_raw);
 out:
 	if (keyring_key)
 		key_put(keyring_key);
 	if (res &lt; 0)
-		crypt_key-&gt;mode = EXT4_ENCRYPTION_MODE_INVALID;
+		crypt_info-&gt;ci_mode = EXT4_ENCRYPTION_MODE_INVALID;
 	return res;
 }
 
 int ext4_has_encryption_key(struct inode *inode)
 {
 	struct ext4_inode_info *ei = EXT4_I(inode);
-	struct ext4_encryption_key *crypt_key = &amp;ei-&gt;i_encryption_key;
+	struct ext4_crypt_info *crypt_info = &amp;ei-&gt;i_crypt_info;
 
-	return (crypt_key-&gt;mode != EXT4_ENCRYPTION_MODE_INVALID);
+	return (crypt_info-&gt;ci_mode != EXT4_ENCRYPTION_MODE_INVALID);
 }
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 866831e7c136..3cf3bcb6b239 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -955,7 +955,7 @@ struct ext4_inode_info {
 
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
 	/* Encryption params */
-	struct ext4_encryption_key i_encryption_key;
+	struct ext4_crypt_info i_crypt_info;
 #endif
 };
 
diff --git a/fs/ext4/ext4_crypto.h b/fs/ext4/ext4_crypto.h
index 552424ae3ab3..deecbe8968d1 100644
--- a/fs/ext4/ext4_crypto.h
+++ b/fs/ext4/ext4_crypto.h
@@ -66,10 +66,17 @@ struct ext4_encryption_context {
 #define EXT4_KEY_DESC_PREFIX "ext4:"
 #define EXT4_KEY_DESC_PREFIX_SIZE 5
 
+/* This is passed in from userspace into the kernel keyring */
 struct ext4_encryption_key {
-	uint32_t mode;
-	char raw[EXT4_MAX_KEY_SIZE];
-	uint32_t size;
+        __u32 mode;
+        char raw[EXT4_MAX_KEY_SIZE];
+        __u32 size;
+} __attribute__((__packed__));
+
+struct ext4_crypt_info {
+	unsigned char	ci_mode;
+	unsigned char	ci_size;
+	char		ci_raw[EXT4_MAX_KEY_SIZE];
 };
 
 #define EXT4_CTX_REQUIRES_FREE_ENCRYPT_FL             0x00000001
@@ -125,7 +132,7 @@ struct ext4_fname_crypto_ctx {
 	u32 lim;
 	struct crypto_ablkcipher *ctfm;
 	struct crypto_hash *htfm;
-	struct ext4_encryption_key key;
+	struct ext4_crypt_info ci;
 	unsigned flags : 8;
 	unsigned has_valid_key : 1;
 	unsigned ctfm_key_is_ready : 1;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index ca9d4a2fed41..bcd7a4bc9036 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -879,7 +879,7 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 	atomic_set(&amp;ei-&gt;i_unwritten, 0);
 	INIT_WORK(&amp;ei-&gt;i_rsv_conversion_work, ext4_end_io_rsv_work);
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
-	ei-&gt;i_encryption_key.mode = EXT4_ENCRYPTION_MODE_INVALID;
+	ei-&gt;i_crypt_info.ci_mode = EXT4_ENCRYPTION_MODE_INVALID;
 #endif
 
 	return &amp;ei-&gt;vfs_inode;</pre><hr><pre>commit d229959072eba40e1c2a4f53f8af17f1e770eb66
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 18 13:15:47 2015 -0400

    ext4 crypto: don't allocate a page when encrypting/decrypting file names
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto_fname.c b/fs/ext4/crypto_fname.c
index ad5e32867de0..23d7f1d56b00 100644
--- a/fs/ext4/crypto_fname.c
+++ b/fs/ext4/crypto_fname.c
@@ -65,9 +65,9 @@ static int ext4_fname_encrypt(struct ext4_fname_crypto_ctx *ctx,
 	struct crypto_ablkcipher *tfm = ctx-&gt;ctfm;
 	int res = 0;
 	char iv[EXT4_CRYPTO_BLOCK_SIZE];
-	struct scatterlist sg[1];
+	struct scatterlist src_sg, dst_sg;
 	int padding = 4 &lt;&lt; (ctx-&gt;flags &amp; EXT4_POLICY_FLAGS_PAD_MASK);
-	char *workbuf;
+	char *workbuf, buf[32], *alloc_buf = NULL;
 
 	if (iname-&gt;len &lt;= 0 || iname-&gt;len &gt; ctx-&gt;lim)
 		return -EIO;
@@ -78,20 +78,27 @@ static int ext4_fname_encrypt(struct ext4_fname_crypto_ctx *ctx,
 	ciphertext_len = (ciphertext_len &gt; ctx-&gt;lim)
 			? ctx-&gt;lim : ciphertext_len;
 
+	if (ciphertext_len &lt;= sizeof(buf)) {
+		workbuf = buf;
+	} else {
+		alloc_buf = kmalloc(ciphertext_len, GFP_NOFS);
+		if (!alloc_buf)
+			return -ENOMEM;
+		workbuf = alloc_buf;
+	}
+
 	/* Allocate request */
 	req = ablkcipher_request_alloc(tfm, GFP_NOFS);
 	if (!req) {
 		printk_ratelimited(
 		    KERN_ERR "%s: crypto_request_alloc() failed\n", __func__);
+		kfree(alloc_buf);
 		return -ENOMEM;
 	}
 	ablkcipher_request_set_callback(req,
 		CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,
 		ext4_dir_crypt_complete, &amp;ecr);
 
-	/* Map the workpage */
-	workbuf = kmap(ctx-&gt;workpage);
-
 	/* Copy the input */
 	memcpy(workbuf, iname-&gt;name, iname-&gt;len);
 	if (iname-&gt;len &lt; ciphertext_len)
@@ -101,21 +108,16 @@ static int ext4_fname_encrypt(struct ext4_fname_crypto_ctx *ctx,
 	memset(iv, 0, EXT4_CRYPTO_BLOCK_SIZE);
 
 	/* Create encryption request */
-	sg_init_table(sg, 1);
-	sg_set_page(sg, ctx-&gt;workpage, PAGE_SIZE, 0);
-	ablkcipher_request_set_crypt(req, sg, sg, ciphertext_len, iv);
+	sg_init_one(&amp;src_sg, workbuf, ciphertext_len);
+	sg_init_one(&amp;dst_sg, oname-&gt;name, ciphertext_len);
+	ablkcipher_request_set_crypt(req, &amp;src_sg, &amp;dst_sg, ciphertext_len, iv);
 	res = crypto_ablkcipher_encrypt(req);
 	if (res == -EINPROGRESS || res == -EBUSY) {
 		BUG_ON(req-&gt;base.data != &amp;ecr);
 		wait_for_completion(&amp;ecr.completion);
 		res = ecr.res;
 	}
-	if (res &gt;= 0) {
-		/* Copy the result to output */
-		memcpy(oname-&gt;name, workbuf, ciphertext_len);
-		res = ciphertext_len;
-	}
-	kunmap(ctx-&gt;workpage);
+	kfree(alloc_buf);
 	ablkcipher_request_free(req);
 	if (res &lt; 0) {
 		printk_ratelimited(
@@ -139,11 +141,10 @@ static int ext4_fname_decrypt(struct ext4_fname_crypto_ctx *ctx,
 	struct ext4_str tmp_in[2], tmp_out[1];
 	struct ablkcipher_request *req = NULL;
 	DECLARE_EXT4_COMPLETION_RESULT(ecr);
-	struct scatterlist sg[1];
+	struct scatterlist src_sg, dst_sg;
 	struct crypto_ablkcipher *tfm = ctx-&gt;ctfm;
 	int res = 0;
 	char iv[EXT4_CRYPTO_BLOCK_SIZE];
-	char *workbuf;
 
 	if (iname-&gt;len &lt;= 0 || iname-&gt;len &gt; ctx-&gt;lim)
 		return -EIO;
@@ -163,31 +164,19 @@ static int ext4_fname_decrypt(struct ext4_fname_crypto_ctx *ctx,
 		CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,
 		ext4_dir_crypt_complete, &amp;ecr);
 
-	/* Map the workpage */
-	workbuf = kmap(ctx-&gt;workpage);
-
-	/* Copy the input */
-	memcpy(workbuf, iname-&gt;name, iname-&gt;len);
-
 	/* Initialize IV */
 	memset(iv, 0, EXT4_CRYPTO_BLOCK_SIZE);
 
 	/* Create encryption request */
-	sg_init_table(sg, 1);
-	sg_set_page(sg, ctx-&gt;workpage, PAGE_SIZE, 0);
-	ablkcipher_request_set_crypt(req, sg, sg, iname-&gt;len, iv);
+	sg_init_one(&amp;src_sg, iname-&gt;name, iname-&gt;len);
+	sg_init_one(&amp;dst_sg, oname-&gt;name, oname-&gt;len);
+	ablkcipher_request_set_crypt(req, &amp;src_sg, &amp;dst_sg, iname-&gt;len, iv);
 	res = crypto_ablkcipher_decrypt(req);
 	if (res == -EINPROGRESS || res == -EBUSY) {
 		BUG_ON(req-&gt;base.data != &amp;ecr);
 		wait_for_completion(&amp;ecr.completion);
 		res = ecr.res;
 	}
-	if (res &gt;= 0) {
-		/* Copy the result to output */
-		memcpy(oname-&gt;name, workbuf, iname-&gt;len);
-		res = iname-&gt;len;
-	}
-	kunmap(ctx-&gt;workpage);
 	ablkcipher_request_free(req);
 	if (res &lt; 0) {
 		printk_ratelimited(
@@ -267,8 +256,6 @@ void ext4_free_fname_crypto_ctx(struct ext4_fname_crypto_ctx *ctx)
 		crypto_free_ablkcipher(ctx-&gt;ctfm);
 	if (ctx-&gt;htfm &amp;&amp; !IS_ERR(ctx-&gt;htfm))
 		crypto_free_hash(ctx-&gt;htfm);
-	if (ctx-&gt;workpage &amp;&amp; !IS_ERR(ctx-&gt;workpage))
-		__free_page(ctx-&gt;workpage);
 	kfree(ctx);
 }
 
@@ -322,7 +309,6 @@ struct ext4_fname_crypto_ctx *ext4_alloc_fname_crypto_ctx(
 	ctx-&gt;ctfm_key_is_ready = 0;
 	ctx-&gt;ctfm = NULL;
 	ctx-&gt;htfm = NULL;
-	ctx-&gt;workpage = NULL;
 	return ctx;
 }
 
@@ -390,24 +376,6 @@ struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(
 			ext4_put_fname_crypto_ctx(&amp;ctx);
 			return ERR_PTR(-ENOMEM);
 		}
-		if (ctx-&gt;workpage == NULL)
-			ctx-&gt;workpage = alloc_page(GFP_NOFS);
-		if (IS_ERR(ctx-&gt;workpage)) {
-			res = PTR_ERR(ctx-&gt;workpage);
-			printk(
-			    KERN_DEBUG "%s: error (%d) allocating work page\n",
-			    __func__, res);
-			ctx-&gt;workpage = NULL;
-			ext4_put_fname_crypto_ctx(&amp;ctx);
-			return ERR_PTR(res);
-		}
-		if (ctx-&gt;workpage == NULL) {
-			printk(
-			    KERN_DEBUG "%s: could not allocate work page\n",
-			    __func__);
-			ext4_put_fname_crypto_ctx(&amp;ctx);
-			return ERR_PTR(-ENOMEM);
-		}
 		ctx-&gt;lim = max_ciphertext_len;
 		crypto_ablkcipher_clear_flags(ctx-&gt;ctfm, ~0);
 		crypto_tfm_set_flags(crypto_ablkcipher_tfm(ctx-&gt;ctfm),
diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index 5665d82d2332..d799d5d571e9 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -247,9 +247,12 @@ static int ext4_readdir(struct file *file, struct dir_context *ctx)
 					    get_dtype(sb, de-&gt;file_type)))
 						goto done;
 				} else {
+					int save_len = fname_crypto_str.len;
+
 					/* Directory is encrypted */
 					err = ext4_fname_disk_to_usr(enc_ctx,
 						NULL, de, &amp;fname_crypto_str);
+					fname_crypto_str.len = save_len;
 					if (err &lt; 0)
 						goto errout;
 					if (!dir_emit(ctx,
diff --git a/fs/ext4/ext4_crypto.h b/fs/ext4/ext4_crypto.h
index d75159c101ce..552424ae3ab3 100644
--- a/fs/ext4/ext4_crypto.h
+++ b/fs/ext4/ext4_crypto.h
@@ -123,10 +123,8 @@ struct ext4_str {
 
 struct ext4_fname_crypto_ctx {
 	u32 lim;
-	char tmp_buf[EXT4_CRYPTO_BLOCK_SIZE];
 	struct crypto_ablkcipher *ctfm;
 	struct crypto_hash *htfm;
-	struct page *workpage;
 	struct ext4_encryption_key key;
 	unsigned flags : 8;
 	unsigned has_valid_key : 1;
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 56c60cb2d3fe..b3406434c267 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -998,6 +998,8 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 				   hinfo-&gt;hash, hinfo-&gt;minor_hash, de,
 				   &amp;tmp_str);
 		} else {
+			int save_len = fname_crypto_str.len;
+
 			/* Directory is encrypted */
 			err = ext4_fname_disk_to_usr(ctx, hinfo, de,
 						     &amp;fname_crypto_str);
@@ -1008,6 +1010,7 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 			err = ext4_htree_store_dirent(dir_file,
 				   hinfo-&gt;hash, hinfo-&gt;minor_hash, de,
 					&amp;fname_crypto_str);
+			fname_crypto_str.len = save_len;
 		}
 		if (err != 0) {
 			count = err;
@@ -3126,6 +3129,7 @@ static int ext4_symlink(struct inode *dir,
 		istr.name = (const unsigned char *) symname;
 		istr.len = len;
 		ostr.name = sd-&gt;encrypted_path;
+		ostr.len = disk_link.len;
 		err = ext4_fname_usr_to_disk(ctx, &amp;istr, &amp;ostr);
 		ext4_put_fname_crypto_ctx(&amp;ctx);
 		if (err &lt; 0)
diff --git a/fs/ext4/symlink.c b/fs/ext4/symlink.c
index 187b78920314..ca65d45c7f8d 100644
--- a/fs/ext4/symlink.c
+++ b/fs/ext4/symlink.c
@@ -74,6 +74,7 @@ static void *ext4_follow_link(struct dentry *dentry, struct nameidata *nd)
 		goto errout;
 	}
 	pstr.name = paddr;
+	pstr.len = plen;
 	res = _ext4_fname_disk_to_usr(ctx, NULL, &amp;cstr, &amp;pstr);
 	if (res &lt; 0)
 		goto errout;</pre><hr><pre>commit 5b643f9ce34df945e58c7176275d406aa0db704f
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon May 18 13:14:47 2015 -0400

    ext4 crypto: optimize filename encryption
    
    Encrypt the filename as soon it is passed in by the user.  This avoids
    our needing to encrypt the filename 2 or 3 times while in the process
    of creating a filename.
    
    Similarly, when looking up a directory entry, encrypt the filename
    early, or if the encryption key is not available, base-64 decode the
    file syystem so that the hash value and the last 16 bytes of the
    encrypted filename is available in the new struct ext4_filename data
    structure.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/crypto_fname.c b/fs/ext4/crypto_fname.c
index fded02f72299..ad5e32867de0 100644
--- a/fs/ext4/crypto_fname.c
+++ b/fs/ext4/crypto_fname.c
@@ -611,109 +611,82 @@ int ext4_fname_usr_to_disk(struct ext4_fname_crypto_ctx *ctx,
 	return -EACCES;
 }
 
-/*
- * Calculate the htree hash from a filename from user space
- */
-int ext4_fname_usr_to_hash(struct ext4_fname_crypto_ctx *ctx,
-			    const struct qstr *iname,
-			    struct dx_hash_info *hinfo)
+int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
+			      int lookup, struct ext4_filename *fname)
 {
-	struct ext4_str tmp;
-	int ret = 0;
-	char buf[EXT4_FNAME_CRYPTO_DIGEST_SIZE+1];
+	struct ext4_fname_crypto_ctx *ctx;
+	int ret = 0, bigname = 0;
+
+	memset(fname, 0, sizeof(struct ext4_filename));
+	fname-&gt;usr_fname = iname;
 
-	if (!ctx ||
+	ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
+	if (IS_ERR(ctx))
+		return PTR_ERR(ctx);
+	if ((ctx == NULL) ||
 	    ((iname-&gt;name[0] == '.') &amp;&amp;
 	     ((iname-&gt;len == 1) ||
 	      ((iname-&gt;name[1] == '.') &amp;&amp; (iname-&gt;len == 2))))) {
-		ext4fs_dirhash(iname-&gt;name, iname-&gt;len, hinfo);
-		return 0;
+		fname-&gt;disk_name.name = (unsigned char *) iname-&gt;name;
+		fname-&gt;disk_name.len = iname-&gt;len;
+		goto out;
 	}
-
-	if (!ctx-&gt;has_valid_key &amp;&amp; iname-&gt;name[0] == '_') {
-		if (iname-&gt;len != 33)
-			return -ENOENT;
-		ret = digest_decode(iname-&gt;name+1, iname-&gt;len, buf);
-		if (ret != 24)
-			return -ENOENT;
-		memcpy(&amp;hinfo-&gt;hash, buf, 4);
-		memcpy(&amp;hinfo-&gt;minor_hash, buf + 4, 4);
-		return 0;
+	if (ctx-&gt;has_valid_key) {
+		ret = ext4_fname_crypto_alloc_buffer(ctx, iname-&gt;len,
+						     &amp;fname-&gt;crypto_buf);
+		if (ret &lt; 0)
+			goto out;
+		ret = ext4_fname_encrypt(ctx, iname, &amp;fname-&gt;crypto_buf);
+		if (ret &lt; 0)
+			goto out;
+		fname-&gt;disk_name.name = fname-&gt;crypto_buf.name;
+		fname-&gt;disk_name.len = fname-&gt;crypto_buf.len;
+		ret = 0;
+		goto out;
 	}
-
-	if (!ctx-&gt;has_valid_key &amp;&amp; iname-&gt;name[0] != '_') {
-		if (iname-&gt;len &gt; 43)
-			return -ENOENT;
-		ret = digest_decode(iname-&gt;name, iname-&gt;len, buf);
-		ext4fs_dirhash(buf, ret, hinfo);
-		return 0;
+	if (!lookup) {
+		ret = -EACCES;
+		goto out;
 	}
 
-	/* First encrypt the plaintext name */
-	ret = ext4_fname_crypto_alloc_buffer(ctx, iname-&gt;len, &amp;tmp);
-	if (ret &lt; 0)
-		return ret;
-
-	ret = ext4_fname_encrypt(ctx, iname, &amp;tmp);
-	if (ret &gt;= 0) {
-		ext4fs_dirhash(tmp.name, tmp.len, hinfo);
-		ret = 0;
+	/* We don't have the key and we are doing a lookup; decode the
+	 * user-supplied name
+	 */
+	if (iname-&gt;name[0] == '_')
+		bigname = 1;
+	if ((bigname &amp;&amp; (iname-&gt;len != 33)) ||
+	    (!bigname &amp;&amp; (iname-&gt;len &gt; 43))) {
+		ret = -ENOENT;
 	}
-
-	ext4_fname_crypto_free_buffer(&amp;tmp);
+	fname-&gt;crypto_buf.name = kmalloc(32, GFP_KERNEL);
+	if (fname-&gt;crypto_buf.name == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ret = digest_decode(iname-&gt;name + bigname, iname-&gt;len - bigname,
+			    fname-&gt;crypto_buf.name);
+	if (ret &lt; 0) {
+		ret = -ENOENT;
+		goto out;
+	}
+	fname-&gt;crypto_buf.len = ret;
+	if (bigname) {
+		memcpy(&amp;fname-&gt;hinfo.hash, fname-&gt;crypto_buf.name, 4);
+		memcpy(&amp;fname-&gt;hinfo.minor_hash, fname-&gt;crypto_buf.name + 4, 4);
+	} else {
+		fname-&gt;disk_name.name = fname-&gt;crypto_buf.name;
+		fname-&gt;disk_name.len = fname-&gt;crypto_buf.len;
+	}
+	ret = 0;
+out:
+	ext4_put_fname_crypto_ctx(&amp;ctx);
 	return ret;
 }
 
-int ext4_fname_match(struct ext4_fname_crypto_ctx *ctx, struct ext4_str *cstr,
-		     int len, const char * const name,
-		     struct ext4_dir_entry_2 *de)
+void ext4_fname_free_filename(struct ext4_filename *fname)
 {
-	int ret = -ENOENT;
-	int bigname = (*name == '_');
-
-	if (ctx-&gt;has_valid_key) {
-		if (cstr-&gt;name == NULL) {
-			struct qstr istr;
-
-			ret = ext4_fname_crypto_alloc_buffer(ctx, len, cstr);
-			if (ret &lt; 0)
-				goto errout;
-			istr.name = name;
-			istr.len = len;
-			ret = ext4_fname_encrypt(ctx, &amp;istr, cstr);
-			if (ret &lt; 0)
-				goto errout;
-		}
-	} else {
-		if (cstr-&gt;name == NULL) {
-			cstr-&gt;name = kmalloc(32, GFP_KERNEL);
-			if (cstr-&gt;name == NULL)
-				return -ENOMEM;
-			if ((bigname &amp;&amp; (len != 33)) ||
-			    (!bigname &amp;&amp; (len &gt; 43)))
-				goto errout;
-			ret = digest_decode(name+bigname, len-bigname,
-					    cstr-&gt;name);
-			if (ret &lt; 0) {
-				ret = -ENOENT;
-				goto errout;
-			}
-			cstr-&gt;len = ret;
-		}
-		if (bigname) {
-			if (de-&gt;name_len &lt; 16)
-				return 0;
-			ret = memcmp(de-&gt;name + de-&gt;name_len - 16,
-				     cstr-&gt;name + 8, 16);
-			return (ret == 0) ? 1 : 0;
-		}
-	}
-	if (de-&gt;name_len != cstr-&gt;len)
-		return 0;
-	ret = memcmp(de-&gt;name, cstr-&gt;name, cstr-&gt;len);
-	return (ret == 0) ? 1 : 0;
-errout:
-	kfree(cstr-&gt;name);
-	cstr-&gt;name = NULL;
-	return ret;
+	kfree(fname-&gt;crypto_buf.name);
+	fname-&gt;crypto_buf.name = NULL;
+	fname-&gt;usr_fname = NULL;
+	fname-&gt;disk_name.name = NULL;
 }
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 9a83f149ac85..866831e7c136 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1838,6 +1838,17 @@ struct dx_hash_info
  */
 #define HASH_NB_ALWAYS		1
 
+struct ext4_filename {
+	const struct qstr *usr_fname;
+	struct ext4_str disk_name;
+	struct dx_hash_info hinfo;
+#ifdef CONFIG_EXT4_FS_ENCRYPTION
+	struct ext4_str crypto_buf;
+#endif
+};
+
+#define fname_name(p) ((p)-&gt;disk_name.name)
+#define fname_len(p)  ((p)-&gt;disk_name.len)
 
 /*
  * Describe an inode's exact location on disk and in memory
@@ -2098,21 +2109,16 @@ int ext4_fname_disk_to_usr(struct ext4_fname_crypto_ctx *ctx,
 int ext4_fname_usr_to_disk(struct ext4_fname_crypto_ctx *ctx,
 			   const struct qstr *iname,
 			   struct ext4_str *oname);
-int ext4_fname_usr_to_hash(struct ext4_fname_crypto_ctx *ctx,
-			   const struct qstr *iname,
-			   struct dx_hash_info *hinfo);
 int ext4_fname_crypto_namelen_on_disk(struct ext4_fname_crypto_ctx *ctx,
 				      u32 namelen);
-int ext4_fname_match(struct ext4_fname_crypto_ctx *ctx, struct ext4_str *cstr,
-		     int len, const char * const name,
-		     struct ext4_dir_entry_2 *de);
-
-
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
 void ext4_put_fname_crypto_ctx(struct ext4_fname_crypto_ctx **ctx);
 struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(struct inode *inode,
 							u32 max_len);
 void ext4_fname_crypto_free_buffer(struct ext4_str *crypto_str);
+int ext4_fname_setup_filename(struct inode *dir, const struct qstr *iname,
+			      int lookup, struct ext4_filename *fname);
+void ext4_fname_free_filename(struct ext4_filename *fname);
 #else
 static inline
 void ext4_put_fname_crypto_ctx(struct ext4_fname_crypto_ctx **ctx) { }
@@ -2123,6 +2129,16 @@ struct ext4_fname_crypto_ctx *ext4_get_fname_crypto_ctx(struct inode *inode,
 	return NULL;
 }
 static inline void ext4_fname_crypto_free_buffer(struct ext4_str *p) { }
+static inline int ext4_fname_setup_filename(struct inode *dir,
+				     const struct qstr *iname,
+				     int lookup, struct ext4_filename *fname)
+{
+	fname-&gt;usr_fname = iname;
+	fname-&gt;disk_name.name = (unsigned char *) iname-&gt;name;
+	fname-&gt;disk_name.len = iname-&gt;len;
+	return 0;
+}
+static inline void ext4_fname_free_filename(struct ext4_filename *fname) { }
 #endif
 
 
@@ -2156,14 +2172,13 @@ extern void ext4_htree_free_dir_info(struct dir_private_info *p);
 extern int ext4_find_dest_de(struct inode *dir, struct inode *inode,
 			     struct buffer_head *bh,
 			     void *buf, int buf_size,
-			     const char *name, int namelen,
+			     struct ext4_filename *fname,
 			     struct ext4_dir_entry_2 **dest_de);
 int ext4_insert_dentry(struct inode *dir,
-			struct inode *inode,
-			struct ext4_dir_entry_2 *de,
-			int buf_size,
-		       const struct qstr *iname,
-			const char *name, int namelen);
+		       struct inode *inode,
+		       struct ext4_dir_entry_2 *de,
+		       int buf_size,
+		       struct ext4_filename *fname);
 static inline void ext4_update_dx_flag(struct inode *inode)
 {
 	if (!EXT4_HAS_COMPAT_FEATURE(inode-&gt;i_sb,
@@ -2317,13 +2332,14 @@ extern int ext4_orphan_add(handle_t *, struct inode *);
 extern int ext4_orphan_del(handle_t *, struct inode *);
 extern int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 				__u32 start_minor_hash, __u32 *next_hash);
-extern int search_dir(struct buffer_head *bh,
-		      char *search_buf,
-		      int buf_size,
-		      struct inode *dir,
-		      const struct qstr *d_name,
-		      unsigned int offset,
-		      struct ext4_dir_entry_2 **res_dir);
+extern int ext4_search_dir(struct buffer_head *bh,
+			   char *search_buf,
+			   int buf_size,
+			   struct inode *dir,
+			   struct ext4_filename *fname,
+			   const struct qstr *d_name,
+			   unsigned int offset,
+			   struct ext4_dir_entry_2 **res_dir);
 extern int ext4_generic_delete_entry(handle_t *handle,
 				     struct inode *dir,
 				     struct ext4_dir_entry_2 *de_del,
@@ -2768,7 +2784,9 @@ extern int ext4_da_write_inline_data_begin(struct address_space *mapping,
 extern int ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,
 					 unsigned len, unsigned copied,
 					 struct page *page);
-extern int ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,
+extern int ext4_try_add_inline_entry(handle_t *handle,
+				     struct ext4_filename *fname,
+				     struct dentry *dentry,
 				     struct inode *inode);
 extern int ext4_try_create_inline_dir(handle_t *handle,
 				      struct inode *parent,
@@ -2782,6 +2800,7 @@ extern int htree_inlinedir_to_tree(struct file *dir_file,
 				   __u32 start_hash, __u32 start_minor_hash,
 				   int *has_inline_data);
 extern struct buffer_head *ext4_find_inline_entry(struct inode *dir,
+					struct ext4_filename *fname,
 					const struct qstr *d_name,
 					struct ext4_dir_entry_2 **res_dir,
 					int *has_inline_data);
diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index 095c7a258d97..cd944a7a99cd 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -995,20 +995,18 @@ void ext4_show_inline_dir(struct inode *dir, struct buffer_head *bh,
  * and -EEXIST if directory entry already exists.
  */
 static int ext4_add_dirent_to_inline(handle_t *handle,
+				     struct ext4_filename *fname,
 				     struct dentry *dentry,
 				     struct inode *inode,
 				     struct ext4_iloc *iloc,
 				     void *inline_start, int inline_size)
 {
 	struct inode	*dir = d_inode(dentry-&gt;d_parent);
-	const char	*name = dentry-&gt;d_name.name;
-	int		namelen = dentry-&gt;d_name.len;
 	int		err;
 	struct ext4_dir_entry_2 *de;
 
-	err = ext4_find_dest_de(dir, inode, iloc-&gt;bh,
-				inline_start, inline_size,
-				name, namelen, &amp;de);
+	err = ext4_find_dest_de(dir, inode, iloc-&gt;bh, inline_start,
+				inline_size, fname, &amp;de);
 	if (err)
 		return err;
 
@@ -1016,8 +1014,7 @@ static int ext4_add_dirent_to_inline(handle_t *handle,
 	err = ext4_journal_get_write_access(handle, iloc-&gt;bh);
 	if (err)
 		return err;
-	ext4_insert_dentry(dir, inode, de, inline_size, &amp;dentry-&gt;d_name,
-			   name, namelen);
+	ext4_insert_dentry(dir, inode, de, inline_size, fname);
 
 	ext4_show_inline_dir(dir, iloc-&gt;bh, inline_start, inline_size);
 
@@ -1248,8 +1245,8 @@ static int ext4_convert_inline_data_nolock(handle_t *handle,
  * If succeeds, return 0. If not, extended the inline dir and copied data to
  * the new created block.
  */
-int ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,
-			      struct inode *inode)
+int ext4_try_add_inline_entry(handle_t *handle, struct ext4_filename *fname,
+			      struct dentry *dentry, struct inode *inode)
 {
 	int ret, inline_size;
 	void *inline_start;
@@ -1268,7 +1265,7 @@ int ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,
 						 EXT4_INLINE_DOTDOT_SIZE;
 	inline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;
 
-	ret = ext4_add_dirent_to_inline(handle, dentry, inode, &amp;iloc,
+	ret = ext4_add_dirent_to_inline(handle, fname, dentry, inode, &amp;iloc,
 					inline_start, inline_size);
 	if (ret != -ENOSPC)
 		goto out;
@@ -1289,8 +1286,9 @@ int ext4_try_add_inline_entry(handle_t *handle, struct dentry *dentry,
 	if (inline_size) {
 		inline_start = ext4_get_inline_xattr_pos(dir, &amp;iloc);
 
-		ret = ext4_add_dirent_to_inline(handle, dentry, inode, &amp;iloc,
-						inline_start, inline_size);
+		ret = ext4_add_dirent_to_inline(handle, fname, dentry,
+						inode, &amp;iloc, inline_start,
+						inline_size);
 
 		if (ret != -ENOSPC)
 			goto out;
@@ -1611,6 +1609,7 @@ int ext4_try_create_inline_dir(handle_t *handle, struct inode *parent,
 }
 
 struct buffer_head *ext4_find_inline_entry(struct inode *dir,
+					struct ext4_filename *fname,
 					const struct qstr *d_name,
 					struct ext4_dir_entry_2 **res_dir,
 					int *has_inline_data)
@@ -1632,8 +1631,8 @@ struct buffer_head *ext4_find_inline_entry(struct inode *dir,
 	inline_start = (void *)ext4_raw_inode(&amp;iloc)-&gt;i_block +
 						EXT4_INLINE_DOTDOT_SIZE;
 	inline_size = EXT4_MIN_INLINE_DATA_SIZE - EXT4_INLINE_DOTDOT_SIZE;
-	ret = search_dir(iloc.bh, inline_start, inline_size,
-			 dir, d_name, 0, res_dir);
+	ret = ext4_search_dir(iloc.bh, inline_start, inline_size,
+			      dir, fname, d_name, 0, res_dir);
 	if (ret == 1)
 		goto out_find;
 	if (ret &lt; 0)
@@ -1645,8 +1644,8 @@ struct buffer_head *ext4_find_inline_entry(struct inode *dir,
 	inline_start = ext4_get_inline_xattr_pos(dir, &amp;iloc);
 	inline_size = ext4_get_inline_size(dir) - EXT4_MIN_INLINE_DATA_SIZE;
 
-	ret = search_dir(iloc.bh, inline_start, inline_size,
-			 dir, d_name, 0, res_dir);
+	ret = ext4_search_dir(iloc.bh, inline_start, inline_size,
+			      dir, fname, d_name, 0, res_dir);
 	if (ret == 1)
 		goto out_find;
 
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 814f3beb4369..56c60cb2d3fe 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -248,7 +248,7 @@ static void dx_set_count(struct dx_entry *entries, unsigned value);
 static void dx_set_limit(struct dx_entry *entries, unsigned value);
 static unsigned dx_root_limit(struct inode *dir, unsigned infosize);
 static unsigned dx_node_limit(struct inode *dir);
-static struct dx_frame *dx_probe(const struct qstr *d_name,
+static struct dx_frame *dx_probe(struct ext4_filename *fname,
 				 struct inode *dir,
 				 struct dx_hash_info *hinfo,
 				 struct dx_frame *frame);
@@ -267,10 +267,10 @@ static int ext4_htree_next_block(struct inode *dir, __u32 hash,
 				 struct dx_frame *frames,
 				 __u32 *start_hash);
 static struct buffer_head * ext4_dx_find_entry(struct inode *dir,
-		const struct qstr *d_name,
+		struct ext4_filename *fname,
 		struct ext4_dir_entry_2 **res_dir);
-static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
-			     struct inode *inode);
+static int ext4_dx_add_entry(handle_t *handle, struct ext4_filename *fname,
+			     struct dentry *dentry, struct inode *inode);
 
 /* checksumming functions */
 void initialize_dirent_tail(struct ext4_dir_entry_tail *t,
@@ -724,7 +724,7 @@ struct stats dx_show_entries(struct dx_hash_info *hinfo, struct inode *dir,
  * back to userspace.
  */
 static struct dx_frame *
-dx_probe(const struct qstr *d_name, struct inode *dir,
+dx_probe(struct ext4_filename *fname, struct inode *dir,
 	 struct dx_hash_info *hinfo, struct dx_frame *frame_in)
 {
 	unsigned count, indirect;
@@ -746,32 +746,14 @@ dx_probe(const struct qstr *d_name, struct inode *dir,
 			     root-&gt;info.hash_version);
 		goto fail;
 	}
+	if (fname)
+		hinfo = &amp;fname-&gt;hinfo;
 	hinfo-&gt;hash_version = root-&gt;info.hash_version;
 	if (hinfo-&gt;hash_version &lt;= DX_HASH_TEA)
 		hinfo-&gt;hash_version += EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_unsigned;
 	hinfo-&gt;seed = EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_seed;
-#ifdef CONFIG_EXT4_FS_ENCRYPTION
-	if (d_name) {
-		struct ext4_fname_crypto_ctx *ctx = NULL;
-		int res;
-
-		/* Check if the directory is encrypted */
-		ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
-		if (IS_ERR(ctx)) {
-			ret_err = ERR_PTR(PTR_ERR(ctx));
-			goto fail;
-		}
-		res = ext4_fname_usr_to_hash(ctx, d_name, hinfo);
-		if (res &lt; 0) {
-			ret_err = ERR_PTR(res);
-			goto fail;
-		}
-		ext4_put_fname_crypto_ctx(&amp;ctx);
-	}
-#else
-	if (d_name)
-		ext4fs_dirhash(d_name-&gt;name, d_name-&gt;len, hinfo);
-#endif
+	if (fname &amp;&amp; fname_name(fname))
+		ext4fs_dirhash(fname_name(fname), fname_len(fname), hinfo);
 	hash = hinfo-&gt;hash;
 
 	if (root-&gt;info.unused_flags &amp; 1) {
@@ -1155,12 +1137,13 @@ int ext4_htree_fill_tree(struct file *dir_file, __u32 start_hash,
 
 static inline int search_dirblock(struct buffer_head *bh,
 				  struct inode *dir,
+				  struct ext4_filename *fname,
 				  const struct qstr *d_name,
 				  unsigned int offset,
 				  struct ext4_dir_entry_2 **res_dir)
 {
-	return search_dir(bh, bh-&gt;b_data, dir-&gt;i_sb-&gt;s_blocksize, dir,
-			  d_name, offset, res_dir);
+	return ext4_search_dir(bh, bh-&gt;b_data, dir-&gt;i_sb-&gt;s_blocksize, dir,
+			       fname, d_name, offset, res_dir);
 }
 
 /*
@@ -1242,54 +1225,54 @@ static void dx_insert_block(struct dx_frame *frame, u32 hash, ext4_lblk_t block)
  * `len &lt;= EXT4_NAME_LEN' is guaranteed by caller.
  * `de != NULL' is guaranteed by caller.
  */
-static inline int ext4_match(struct ext4_fname_crypto_ctx *ctx,
-			     struct ext4_str *fname_crypto_str,
-			     int len, const char * const name,
+static inline int ext4_match(struct ext4_filename *fname,
 			     struct ext4_dir_entry_2 *de)
 {
-	int res;
+	const void *name = fname_name(fname);
+	u32 len = fname_len(fname);
 
 	if (!de-&gt;inode)
 		return 0;
 
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
-	if (ctx)
-		return ext4_fname_match(ctx, fname_crypto_str, len, name, de);
+	if (unlikely(!name)) {
+		if (fname-&gt;usr_fname-&gt;name[0] == '_') {
+			int ret;
+			if (de-&gt;name_len &lt; 16)
+				return 0;
+			ret = memcmp(de-&gt;name + de-&gt;name_len - 16,
+				     fname-&gt;crypto_buf.name + 8, 16);
+			return (ret == 0) ? 1 : 0;
+		}
+		name = fname-&gt;crypto_buf.name;
+		len = fname-&gt;crypto_buf.len;
+	}
 #endif
-	if (len != de-&gt;name_len)
+	if (de-&gt;name_len != len)
 		return 0;
-	res = memcmp(name, de-&gt;name, len);
-	return (res == 0) ? 1 : 0;
+	return (memcmp(de-&gt;name, name, len) == 0) ? 1 : 0;
 }
 
 /*
  * Returns 0 if not found, -1 on failure, and 1 on success
  */
-int search_dir(struct buffer_head *bh, char *search_buf, int buf_size,
-	       struct inode *dir, const struct qstr *d_name,
-	       unsigned int offset, struct ext4_dir_entry_2 **res_dir)
+int ext4_search_dir(struct buffer_head *bh, char *search_buf, int buf_size,
+		    struct inode *dir, struct ext4_filename *fname,
+		    const struct qstr *d_name,
+		    unsigned int offset, struct ext4_dir_entry_2 **res_dir)
 {
 	struct ext4_dir_entry_2 * de;
 	char * dlimit;
 	int de_len;
-	const char *name = d_name-&gt;name;
-	int namelen = d_name-&gt;len;
-	struct ext4_fname_crypto_ctx *ctx = NULL;
-	struct ext4_str fname_crypto_str = {.name = NULL, .len = 0};
 	int res;
 
-	ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
-	if (IS_ERR(ctx))
-		return -1;
-
 	de = (struct ext4_dir_entry_2 *)search_buf;
 	dlimit = search_buf + buf_size;
 	while ((char *) de &lt; dlimit) {
 		/* this code is executed quadratically often */
 		/* do minimal checking `by hand' */
 		if ((char *) de + de-&gt;name_len &lt;= dlimit) {
-			res = ext4_match(ctx, &amp;fname_crypto_str, namelen,
-					 name, de);
+			res = ext4_match(fname, de);
 			if (res &lt; 0) {
 				res = -1;
 				goto return_result;
@@ -1322,8 +1305,6 @@ int search_dir(struct buffer_head *bh, char *search_buf, int buf_size,
 
 	res = 0;
 return_result:
-	ext4_put_fname_crypto_ctx(&amp;ctx);
-	ext4_fname_crypto_free_buffer(&amp;fname_crypto_str);
 	return res;
 }
 
@@ -1370,7 +1351,8 @@ static struct buffer_head * ext4_find_entry (struct inode *dir,
 				   buffer */
 	int num = 0;
 	ext4_lblk_t  nblocks;
-	int i, namelen;
+	int i, namelen, retval;
+	struct ext4_filename fname;
 
 	*res_dir = NULL;
 	sb = dir-&gt;i_sb;
@@ -1378,14 +1360,18 @@ static struct buffer_head * ext4_find_entry (struct inode *dir,
 	if (namelen &gt; EXT4_NAME_LEN)
 		return NULL;
 
+	retval = ext4_fname_setup_filename(dir, d_name, 1, &amp;fname);
+	if (retval)
+		return ERR_PTR(retval);
+
 	if (ext4_has_inline_data(dir)) {
 		int has_inline_data = 1;
-		ret = ext4_find_inline_entry(dir, d_name, res_dir,
+		ret = ext4_find_inline_entry(dir, &amp;fname, d_name, res_dir,
 					     &amp;has_inline_data);
 		if (has_inline_data) {
 			if (inlined)
 				*inlined = 1;
-			return ret;
+			goto cleanup_and_exit;
 		}
 	}
 
@@ -1400,14 +1386,14 @@ static struct buffer_head * ext4_find_entry (struct inode *dir,
 		goto restart;
 	}
 	if (is_dx(dir)) {
-		bh = ext4_dx_find_entry(dir, d_name, res_dir);
+		ret = ext4_dx_find_entry(dir, &amp;fname, res_dir);
 		/*
 		 * On success, or if the error was file not found,
 		 * return.  Otherwise, fall back to doing a search the
 		 * old fashioned way.
 		 */
-		if (!IS_ERR(bh) || PTR_ERR(bh) != ERR_BAD_DX_DIR)
-			return bh;
+		if (!IS_ERR(ret) || PTR_ERR(ret) != ERR_BAD_DX_DIR)
+			goto cleanup_and_exit;
 		dxtrace(printk(KERN_DEBUG "ext4_find_entry: dx failed, "
 			       "falling back\n"));
 	}
@@ -1438,8 +1424,10 @@ static struct buffer_head * ext4_find_entry (struct inode *dir,
 				num++;
 				bh = ext4_getblk(NULL, dir, b++, 0);
 				if (unlikely(IS_ERR(bh))) {
-					if (ra_max == 0)
-						return bh;
+					if (ra_max == 0) {
+						ret = bh;
+						goto cleanup_and_exit;
+					}
 					break;
 				}
 				bh_use[ra_max] = bh;
@@ -1469,7 +1457,7 @@ static struct buffer_head * ext4_find_entry (struct inode *dir,
 			goto next;
 		}
 		set_buffer_verified(bh);
-		i = search_dirblock(bh, dir, d_name,
+		i = search_dirblock(bh, dir, &amp;fname, d_name,
 			    block &lt;&lt; EXT4_BLOCK_SIZE_BITS(sb), res_dir);
 		if (i == 1) {
 			EXT4_I(dir)-&gt;i_dir_start_lookup = block;
@@ -1500,15 +1488,17 @@ static struct buffer_head * ext4_find_entry (struct inode *dir,
 	/* Clean up the read-ahead blocks */
 	for (; ra_ptr &lt; ra_max; ra_ptr++)
 		brelse(bh_use[ra_ptr]);
+	ext4_fname_free_filename(&amp;fname);
 	return ret;
 }
 
-static struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct qstr *d_name,
-		       struct ext4_dir_entry_2 **res_dir)
+static struct buffer_head * ext4_dx_find_entry(struct inode *dir,
+			struct ext4_filename *fname,
+			struct ext4_dir_entry_2 **res_dir)
 {
 	struct super_block * sb = dir-&gt;i_sb;
-	struct dx_hash_info	hinfo;
 	struct dx_frame frames[2], *frame;
+	const struct qstr *d_name = fname-&gt;usr_fname;
 	struct buffer_head *bh;
 	ext4_lblk_t block;
 	int retval;
@@ -1516,7 +1506,7 @@ static struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct q
 #ifdef CONFIG_EXT4_FS_ENCRYPTION
 	*res_dir = NULL;
 #endif
-	frame = dx_probe(d_name, dir, &amp;hinfo, frames);
+	frame = dx_probe(fname, dir, NULL, frames);
 	if (IS_ERR(frame))
 		return (struct buffer_head *) frame;
 	do {
@@ -1525,7 +1515,7 @@ static struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct q
 		if (IS_ERR(bh))
 			goto errout;
 
-		retval = search_dirblock(bh, dir, d_name,
+		retval = search_dirblock(bh, dir, fname, d_name,
 					 block &lt;&lt; EXT4_BLOCK_SIZE_BITS(sb),
 					 res_dir);
 		if (retval == 1)
@@ -1537,7 +1527,7 @@ static struct buffer_head * ext4_dx_find_entry(struct inode *dir, const struct q
 		}
 
 		/* Check to see if we should continue to search */
-		retval = ext4_htree_next_block(dir, hinfo.hash, frame,
+		retval = ext4_htree_next_block(dir, fname-&gt;hinfo.hash, frame,
 					       frames, NULL);
 		if (retval &lt; 0) {
 			ext4_warning(sb,
@@ -1796,32 +1786,16 @@ static struct ext4_dir_entry_2 *do_split(handle_t *handle, struct inode *dir,
 int ext4_find_dest_de(struct inode *dir, struct inode *inode,
 		      struct buffer_head *bh,
 		      void *buf, int buf_size,
-		      const char *name, int namelen,
+		      struct ext4_filename *fname,
 		      struct ext4_dir_entry_2 **dest_de)
 {
 	struct ext4_dir_entry_2 *de;
-	unsigned short reclen = EXT4_DIR_REC_LEN(namelen);
+	unsigned short reclen = EXT4_DIR_REC_LEN(fname_len(fname));
 	int nlen, rlen;
 	unsigned int offset = 0;
 	char *top;
-	struct ext4_fname_crypto_ctx *ctx = NULL;
-	struct ext4_str fname_crypto_str = {.name = NULL, .len = 0};
 	int res;
 
-	ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
-	if (IS_ERR(ctx))
-		return -1;
-
-	if (ctx != NULL) {
-		/* Calculate record length needed to store the entry */
-		res = ext4_fname_crypto_namelen_on_disk(ctx, namelen);
-		if (res &lt; 0) {
-			ext4_put_fname_crypto_ctx(&amp;ctx);
-			return res;
-		}
-		reclen = EXT4_DIR_REC_LEN(res);
-	}
-
 	de = (struct ext4_dir_entry_2 *)buf;
 	top = buf + buf_size - reclen;
 	while ((char *) de &lt;= top) {
@@ -1831,7 +1805,7 @@ int ext4_find_dest_de(struct inode *dir, struct inode *inode,
 			goto return_result;
 		}
 		/* Provide crypto context and crypto buffer to ext4 match */
-		res = ext4_match(ctx, &amp;fname_crypto_str, namelen, name, de);
+		res = ext4_match(fname, de);
 		if (res &lt; 0)
 			goto return_result;
 		if (res &gt; 0) {
@@ -1853,8 +1827,6 @@ int ext4_find_dest_de(struct inode *dir, struct inode *inode,
 		res = 0;
 	}
 return_result:
-	ext4_put_fname_crypto_ctx(&amp;ctx);
-	ext4_fname_crypto_free_buffer(&amp;fname_crypto_str);
 	return res;
 }
 
@@ -1862,39 +1834,10 @@ int ext4_insert_dentry(struct inode *dir,
 		       struct inode *inode,
 		       struct ext4_dir_entry_2 *de,
 		       int buf_size,
-		       const struct qstr *iname,
-		       const char *name, int namelen)
+		       struct ext4_filename *fname)
 {
 
 	int nlen, rlen;
-	struct ext4_fname_crypto_ctx *ctx = NULL;
-	struct ext4_str fname_crypto_str = {.name = NULL, .len = 0};
-	struct ext4_str tmp_str;
-	int res;
-
-	ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
-	if (IS_ERR(ctx))
-		return -EIO;
-	/* By default, the input name would be written to the disk */
-	tmp_str.name = (unsigned char *)name;
-	tmp_str.len = namelen;
-	if (ctx != NULL) {
-		/* Directory is encrypted */
-		res = ext4_fname_crypto_alloc_buffer(ctx, EXT4_NAME_LEN,
-						     &amp;fname_crypto_str);
-		if (res &lt; 0) {
-			ext4_put_fname_crypto_ctx(&amp;ctx);
-			return -ENOMEM;
-		}
-		res = ext4_fname_usr_to_disk(ctx, iname, &amp;fname_crypto_str);
-		if (res &lt; 0) {
-			ext4_put_fname_crypto_ctx(&amp;ctx);
-			ext4_fname_crypto_free_buffer(&amp;fname_crypto_str);
-			return res;
-		}
-		tmp_str.name = fname_crypto_str.name;
-		tmp_str.len = fname_crypto_str.len;
-	}
 
 	nlen = EXT4_DIR_REC_LEN(de-&gt;name_len);
 	rlen = ext4_rec_len_from_disk(de-&gt;rec_len, buf_size);
@@ -1908,11 +1851,8 @@ int ext4_insert_dentry(struct inode *dir,
 	de-&gt;file_type = EXT4_FT_UNKNOWN;
 	de-&gt;inode = cpu_to_le32(inode-&gt;i_ino);
 	ext4_set_de_type(inode-&gt;i_sb, de, inode-&gt;i_mode);
-	de-&gt;name_len = tmp_str.len;
-
-	memcpy(de-&gt;name, tmp_str.name, tmp_str.len);
-	ext4_put_fname_crypto_ctx(&amp;ctx);
-	ext4_fname_crypto_free_buffer(&amp;fname_crypto_str);
+	de-&gt;name_len = fname_len(fname);
+	memcpy(de-&gt;name, fname_name(fname), fname_len(fname));
 	return 0;
 }
 
@@ -1924,13 +1864,11 @@ int ext4_insert_dentry(struct inode *dir,
  * space.  It will return -ENOSPC if no space is available, and -EIO
  * and -EEXIST if directory entry already exists.
  */
-static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
+static int add_dirent_to_buf(handle_t *handle, struct ext4_filename *fname,
+			     struct inode *dir,
 			     struct inode *inode, struct ext4_dir_entry_2 *de,
 			     struct buffer_head *bh)
 {
-	struct inode	*dir = d_inode(dentry-&gt;d_parent);
-	const char	*name = dentry-&gt;d_name.name;
-	int		namelen = dentry-&gt;d_name.len;
 	unsigned int	blocksize = dir-&gt;i_sb-&gt;s_blocksize;
 	int		csum_size = 0;
 	int		err;
@@ -1939,9 +1877,8 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 		csum_size = sizeof(struct ext4_dir_entry_tail);
 
 	if (!de) {
-		err = ext4_find_dest_de(dir, inode,
-					bh, bh-&gt;b_data, blocksize - csum_size,
-					name, namelen, &amp;de);
+		err = ext4_find_dest_de(dir, inode, bh, bh-&gt;b_data,
+					blocksize - csum_size, fname, &amp;de);
 		if (err)
 			return err;
 	}
@@ -1954,8 +1891,7 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 
 	/* By now the buffer is marked for journaling. Due to crypto operations,
 	 * the following function call may fail */
-	err = ext4_insert_dentry(dir, inode, de, blocksize, &amp;dentry-&gt;d_name,
-				 name, namelen);
+	err = ext4_insert_dentry(dir, inode, de, blocksize, fname);
 	if (err &lt; 0)
 		return err;
 
@@ -1985,17 +1921,11 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
  * This converts a one block unindexed directory to a 3 block indexed
  * directory, and adds the dentry to the indexed directory.
  */
-static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
+static int make_indexed_dir(handle_t *handle, struct ext4_filename *fname,
+			    struct dentry *dentry,
 			    struct inode *inode, struct buffer_head *bh)
 {
 	struct inode	*dir = d_inode(dentry-&gt;d_parent);
-#ifdef CONFIG_EXT4_FS_ENCRYPTION
-	struct ext4_fname_crypto_ctx *ctx = NULL;
-	int res;
-#else
-	const char	*name = dentry-&gt;d_name.name;
-	int		namelen = dentry-&gt;d_name.len;
-#endif
 	struct buffer_head *bh2;
 	struct dx_root	*root;
 	struct dx_frame	frames[2], *frame;
@@ -2006,17 +1936,10 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	unsigned	len;
 	int		retval;
 	unsigned	blocksize;
-	struct dx_hash_info hinfo;
 	ext4_lblk_t  block;
 	struct fake_dirent *fde;
 	int csum_size = 0;
 
-#ifdef CONFIG_EXT4_FS_ENCRYPTION
-	ctx = ext4_get_fname_crypto_ctx(dir, EXT4_NAME_LEN);
-	if (IS_ERR(ctx))
-		return PTR_ERR(ctx);
-#endif
-
 	if (ext4_has_metadata_csum(inode-&gt;i_sb))
 		csum_size = sizeof(struct ext4_dir_entry_tail);
 
@@ -2078,22 +2001,12 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	dx_set_limit(entries, dx_root_limit(dir, sizeof(root-&gt;info)));
 
 	/* Initialize as for dx_probe */
-	hinfo.hash_version = root-&gt;info.hash_version;
-	if (hinfo.hash_version &lt;= DX_HASH_TEA)
-		hinfo.hash_version += EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_unsigned;
-	hinfo.seed = EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_seed;
-#ifdef CONFIG_EXT4_FS_ENCRYPTION
-	res = ext4_fname_usr_to_hash(ctx, &amp;dentry-&gt;d_name, &amp;hinfo);
-	if (res &lt; 0) {
-		ext4_put_fname_crypto_ctx(&amp;ctx);
-		ext4_mark_inode_dirty(handle, dir);
-		brelse(bh);
-		return res;
-	}
-	ext4_put_fname_crypto_ctx(&amp;ctx);
-#else
-	ext4fs_dirhash(name, namelen, &amp;hinfo);
-#endif
+	fname-&gt;hinfo.hash_version = root-&gt;info.hash_version;
+	if (fname-&gt;hinfo.hash_version &lt;= DX_HASH_TEA)
+		fname-&gt;hinfo.hash_version += EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_unsigned;
+	fname-&gt;hinfo.seed = EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_seed;
+	ext4fs_dirhash(fname_name(fname), fname_len(fname), &amp;fname-&gt;hinfo);
+
 	memset(frames, 0, sizeof(frames));
 	frame = frames;
 	frame-&gt;entries = entries;
@@ -2108,14 +2021,14 @@ static int make_indexed_dir(handle_t *handle, struct dentry *dentry,
 	if (retval)
 		goto out_frames;	
 
-	de = do_split(handle,dir, &amp;bh, frame, &amp;hinfo);
+	de = do_split(handle,dir, &amp;bh, frame, &amp;fname-&gt;hinfo);
 	if (IS_ERR(de)) {
 		retval = PTR_ERR(de);
 		goto out_frames;
 	}
 	dx_release(frames);
 
-	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	retval = add_dirent_to_buf(handle, fname, dir, inode, de, bh);
 	brelse(bh);
 	return retval;
 out_frames:
@@ -2147,6 +2060,7 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 	struct ext4_dir_entry_2 *de;
 	struct ext4_dir_entry_tail *t;
 	struct super_block *sb;
+	struct ext4_filename fname;
 	int	retval;
 	int	dx_fallback=0;
 	unsigned blocksize;
@@ -2161,10 +2075,15 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 	if (!dentry-&gt;d_name.len)
 		return -EINVAL;
 
+	retval = ext4_fname_setup_filename(dir, &amp;dentry-&gt;d_name, 0, &amp;fname);
+	if (retval)
+		return retval;
+
 	if (ext4_has_inline_data(dir)) {
-		retval = ext4_try_add_inline_entry(handle, dentry, inode);
+		retval = ext4_try_add_inline_entry(handle, &amp;fname,
+						   dentry, inode);
 		if (retval &lt; 0)
-			return retval;
+			goto out;
 		if (retval == 1) {
 			retval = 0;
 			goto out;
@@ -2172,7 +2091,7 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 	}
 
 	if (is_dx(dir)) {
-		retval = ext4_dx_add_entry(handle, dentry, inode);
+		retval = ext4_dx_add_entry(handle, &amp;fname, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
 			goto out;
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
@@ -2182,24 +2101,31 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 	blocks = dir-&gt;i_size &gt;&gt; sb-&gt;s_blocksize_bits;
 	for (block = 0; block &lt; blocks; block++) {
 		bh = ext4_read_dirblock(dir, block, DIRENT);
-		if (IS_ERR(bh))
-			return PTR_ERR(bh);
-
-		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
+		if (IS_ERR(bh)) {
+			retval = PTR_ERR(bh);
+			bh = NULL;
+			goto out;
+		}
+		retval = add_dirent_to_buf(handle, &amp;fname, dir, inode,
+					   NULL, bh);
 		if (retval != -ENOSPC)
 			goto out;
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
 		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {
-			retval = make_indexed_dir(handle, dentry, inode, bh);
+			retval = make_indexed_dir(handle, &amp;fname, dentry,
+						  inode, bh);
 			bh = NULL; /* make_indexed_dir releases bh */
 			goto out;
 		}
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block);
-	if (IS_ERR(bh))
-		return PTR_ERR(bh);
+	if (IS_ERR(bh)) {
+		retval = PTR_ERR(bh);
+		bh = NULL;
+		goto out;
+	}
 	de = (struct ext4_dir_entry_2 *) bh-&gt;b_data;
 	de-&gt;inode = 0;
 	de-&gt;rec_len = ext4_rec_len_to_disk(blocksize - csum_size, blocksize);
@@ -2209,8 +2135,9 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 		initialize_dirent_tail(t, blocksize);
 	}
 
-	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	retval = add_dirent_to_buf(handle, &amp;fname, dir, inode, de, bh);
 out:
+	ext4_fname_free_filename(&amp;fname);
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
@@ -2220,19 +2147,18 @@ static int ext4_add_entry(handle_t *handle, struct dentry *dentry,
 /*
  * Returns 0 for success, or a negative error value
  */
-static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
-			     struct inode *inode)
+static int ext4_dx_add_entry(handle_t *handle, struct ext4_filename *fname,
+			     struct dentry *dentry, struct inode *inode)
 {
 	struct dx_frame frames[2], *frame;
 	struct dx_entry *entries, *at;
-	struct dx_hash_info hinfo;
 	struct buffer_head *bh;
 	struct inode *dir = d_inode(dentry-&gt;d_parent);
 	struct super_block *sb = dir-&gt;i_sb;
 	struct ext4_dir_entry_2 *de;
 	int err;
 
-	frame = dx_probe(&amp;dentry-&gt;d_name, dir, &amp;hinfo, frames);
+	frame = dx_probe(fname, dir, NULL, frames);
 	if (IS_ERR(frame))
 		return PTR_ERR(frame);
 	entries = frame-&gt;entries;
@@ -2249,7 +2175,7 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 	if (err)
 		goto journal_error;
 
-	err = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
+	err = add_dirent_to_buf(handle, fname, dir, inode, NULL, bh);
 	if (err != -ENOSPC)
 		goto cleanup;
 
@@ -2345,12 +2271,12 @@ static int ext4_dx_add_entry(handle_t *handle, struct dentry *dentry,
 			goto cleanup;
 		}
 	}
-	de = do_split(handle, dir, &amp;bh, frame, &amp;hinfo);
+	de = do_split(handle, dir, &amp;bh, frame, &amp;fname-&gt;hinfo);
 	if (IS_ERR(de)) {
 		err = PTR_ERR(de);
 		goto cleanup;
 	}
-	err = add_dirent_to_buf(handle, dentry, inode, de, bh);
+	err = add_dirent_to_buf(handle, fname, dir, inode, de, bh);
 	goto cleanup;
 
 journal_error:</pre><hr><pre>commit b9576fc3624eb9fc88bec0d0ae883fd78be86239
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri May 15 00:24:10 2015 -0400

    ext4: fix an ext3 collapse range regression in xfstests
    
    The xfstests test suite assumes that an attempt to collapse range on
    the range (0, 1) will return EOPNOTSUPP if the file system does not
    support collapse range.  Commit 280227a75b56: "ext4: move check under
    lock scope to close a race" broke this, and this caused xfstests to
    fail when run when testing file systems that did not have the extents
    feature enabled.
    
    Reported-by: Eric Whitney &lt;enwlinux@gmail.com&gt;
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 451b92a9958a..e003a1e81dc3 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -5396,6 +5396,14 @@ int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)
 	loff_t new_size, ioffset;
 	int ret;
 
+	/*
+	 * We need to test this early because xfstests assumes that a
+	 * collapse range of (0, 1) will return EOPNOTSUPP if the file
+	 * system does not support collapse range.
+	 */
+	if (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))
+		return -EOPNOTSUPP;
+
 	/* Collapse range works only on fs block size aligned offsets. */
 	if (offset &amp; (EXT4_CLUSTER_SIZE(sb) - 1) ||
 	    len &amp; (EXT4_CLUSTER_SIZE(sb) - 1))</pre><hr><pre>commit 92c82639106214a9d34daa2bc791605eb1faab07
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu May 14 18:43:36 2015 -0400

    ext4: remove unused function prototype from ext4.h
    
    The ext4_extent_tree_init() function hasn't been in the ext4 code for
    a long time ago, except in an unused function prototype in ext4.h
    
    Google-Bug-Id: 4530137
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 009a0590b20f..9a83f149ac85 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2889,7 +2889,6 @@ extern int ext4_map_blocks(handle_t *handle, struct inode *inode,
 			   struct ext4_map_blocks *map, int flags);
 extern int ext4_ext_calc_metadata_amount(struct inode *inode,
 					 ext4_lblk_t lblocks);
-extern int ext4_extent_tree_init(handle_t *, struct inode *);
 extern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,
 						   int num,
 						   struct ext4_ext_path *path);</pre><hr><pre>commit 1b46617b8d0851c78b6440701d78fffbd9170741
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu May 14 18:37:30 2015 -0400

    ext4: don't save the error information if the block device is read-only
    
    Google-Bug-Id: 20939131
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index f06d0589ddba..ca9d4a2fed41 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -294,6 +294,8 @@ static void __save_error_info(struct super_block *sb, const char *func,
 	struct ext4_super_block *es = EXT4_SB(sb)-&gt;s_es;
 
 	EXT4_SB(sb)-&gt;s_mount_state |= EXT4_ERROR_FS;
+	if (bdev_read_only(sb-&gt;s_bdev))
+		return;
 	es-&gt;s_state |= cpu_to_le16(EXT4_ERROR_FS);
 	es-&gt;s_last_error_time = cpu_to_le32(get_seconds());
 	strncpy(es-&gt;s_last_error_func, func, sizeof(es-&gt;s_last_error_func));</pre><hr><pre>commit 8f4d855839179f410fa910a26eb81d646d628f26
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu May 14 18:19:01 2015 -0400

    ext4: fix lazytime optimization
    
    We had a fencepost error in the lazytime optimization which means that
    timestamp would get written to the wrong inode.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 55b187c3bac1..0554b0b5957b 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4345,7 +4345,7 @@ static void ext4_update_other_inodes_time(struct super_block *sb,
 	int inode_size = EXT4_INODE_SIZE(sb);
 
 	oi.orig_ino = orig_ino;
-	ino = orig_ino &amp; ~(inodes_per_block - 1);
+	ino = (orig_ino &amp; ~(inodes_per_block - 1)) + 1;
 	for (i = 0; i &lt; inodes_per_block; i++, ino++, buf += inode_size) {
 		if (ino == orig_ino)
 			continue;</pre>
    <div class="pagination">
        <a href='1_32.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><span>[33]</span><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_34.html'>Next&gt;&gt;</a>
    <div>
</body>
