<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Virginia, Charlottesville</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Virginia, Charlottesville</h1>
    <div class="pagination">
        <a href='3_55.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><span>[56]</span><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_57.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6eef3af5ddb1fa9c05c2f6457c23c4cfe9d83470
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:50 2009 -0400

    Staging: comedi: remove C99 comments in cb_pcimdas.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/cb_pcimdas.c b/drivers/staging/comedi/drivers/cb_pcimdas.c
index af705fa092c0..49d32fb4a4b4 100644
--- a/drivers/staging/comedi/drivers/cb_pcimdas.c
+++ b/drivers/staging/comedi/drivers/cb_pcimdas.c
@@ -48,24 +48,24 @@ See http://www.measurementcomputing.com/PDFManuals/pcim-das1602_16.pdf for more
 #include "plx9052.h"
 #include "8255.h"
 
-//#define CBPCIMDAS_DEBUG
+/* #define CBPCIMDAS_DEBUG */
 #undef CBPCIMDAS_DEBUG
 
 /* Registers for the PCIM-DAS1602/16 */
 
-// sizes of io regions (bytes)
-#define BADR0_SIZE 2		//??
+/* sizes of io regions (bytes) */
+#define BADR0_SIZE 2		/* ?? */
 #define BADR1_SIZE 4
 #define BADR2_SIZE 6
 #define BADR3_SIZE 16
 #define BADR4_SIZE 4
 
-//DAC Offsets
+/* DAC Offsets */
 #define ADC_TRIG 0
 #define DAC0_OFFSET 2
 #define DAC1_OFFSET 4
 
-//AI and Counter Constants
+/* AI and Counter Constants */
 #define MUX_LIMITS 0
 #define MAIN_CONN_DIO 1
 #define ADC_STAT 2
@@ -86,17 +86,17 @@ See http://www.measurementcomputing.com/PDFManuals/pcim-das1602_16.pdf for more
 struct cb_pcimdas_board {
 	const char *name;
 	unsigned short device_id;
-	int ai_se_chans;	// Inputs in single-ended mode
-	int ai_diff_chans;	// Inputs in differential mode
-	int ai_bits;		// analog input resolution
-	int ai_speed;		// fastest conversion period in ns
-	int ao_nchan;		// number of analog out channels
-	int ao_bits;		// analogue output resolution
-	int has_ao_fifo;	// analog output has fifo
-	int ao_scan_speed;	// analog output speed for 1602 series (for a scan, not conversion)
-	int fifo_size;		// number of samples fifo can hold
-	int dio_bits;		// number of dio bits
-	int has_dio;		// has DIO
+	int ai_se_chans;	/*  Inputs in single-ended mode */
+	int ai_diff_chans;	/*  Inputs in differential mode */
+	int ai_bits;		/*  analog input resolution */
+	int ai_speed;		/*  fastest conversion period in ns */
+	int ao_nchan;		/*  number of analog out channels */
+	int ao_bits;		/*  analogue output resolution */
+	int has_ao_fifo;	/*  analog output has fifo */
+	int ao_scan_speed;	/*  analog output speed for 1602 series (for a scan, not conversion) */
+	int fifo_size;		/*  number of samples fifo can hold */
+	int dio_bits;		/*  number of dio bits */
+	int has_dio;		/*  has DIO */
 	const struct comedi_lrange *ranges;
 };
 
@@ -107,16 +107,16 @@ static const struct cb_pcimdas_board cb_pcimdas_boards[] = {
 	      ai_se_chans:16,
 	      ai_diff_chans:8,
 	      ai_bits:	16,
-	      ai_speed:10000,	//??
+	      ai_speed:10000,	/* ?? */
 	      ao_nchan:2,
 	      ao_bits:	12,
-	      has_ao_fifo:0,	//??
+	      has_ao_fifo:0,	/* ?? */
 	      ao_scan_speed:10000,
-			//??
+			/* ?? */
 	      fifo_size:1024,
 	      dio_bits:24,
 	      has_dio:	1,
-//              ranges:         &amp;cb_pcimdas_ranges,
+/* ranges:         &amp;cb_pcimdas_ranges, */
 		},
 };
 
@@ -129,7 +129,7 @@ static DEFINE_PCI_DEVICE_TABLE(cb_pcimdas_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, cb_pcimdas_pci_table);
 
-#define N_BOARDS 1		// Max number of boards supported
+#define N_BOARDS 1		/*  Max number of boards supported */
 
 /*
  * Useful for shorthand access to the particular board structure
@@ -142,10 +142,10 @@ MODULE_DEVICE_TABLE(pci, cb_pcimdas_pci_table);
 struct cb_pcimdas_private {
 	int data;
 
-	// would be useful for a PCI device
+	/*  would be useful for a PCI device */
 	struct pci_dev *pci_dev;
 
-	//base addresses
+	/* base addresses */
 	unsigned long BADR0;
 	unsigned long BADR1;
 	unsigned long BADR2;
@@ -155,11 +155,11 @@ struct cb_pcimdas_private {
 	/* Used for AO readback */
 	unsigned int ao_readback[2];
 
-	// Used for DIO
-	unsigned short int port_a;	// copy of BADR4+0
-	unsigned short int port_b;	// copy of BADR4+1
-	unsigned short int port_c;	// copy of BADR4+2
-	unsigned short int dio_mode;	// copy of BADR4+3
+	/*  Used for DIO */
+	unsigned short int port_a;	/*  copy of BADR4+0 */
+	unsigned short int port_b;	/*  copy of BADR4+1 */
+	unsigned short int port_c;	/*  copy of BADR4+2 */
+	unsigned short int dio_mode;	/*  copy of BADR4+3 */
 
 };
 
@@ -202,7 +202,7 @@ static int cb_pcimdas_attach(struct comedi_device * dev, struct comedi_devconfig
 	struct comedi_subdevice *s;
 	struct pci_dev *pcidev;
 	int index;
-	//int i;
+	/* int i; */
 
 	printk("comedi%d: cb_pcimdas: ", dev-&gt;minor);
 
@@ -220,17 +220,17 @@ static int cb_pcimdas_attach(struct comedi_device * dev, struct comedi_devconfig
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev-&gt;vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0; index &lt; N_BOARDS; index++) {
 			if (cb_pcimdas_boards[index].device_id !=
 				pcidev-&gt;device)
 				continue;
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it-&gt;options[0] || it-&gt;options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev-&gt;bus-&gt;number != it-&gt;options[0] ||
 					PCI_SLOT(pcidev-&gt;devfn) !=
 					it-&gt;options[1]) {
@@ -252,7 +252,7 @@ static int cb_pcimdas_attach(struct comedi_device * dev, struct comedi_devconfig
 	printk("Found %s on bus %i, slot %i\n", cb_pcimdas_boards[index].name,
 		pcidev-&gt;bus-&gt;number, PCI_SLOT(pcidev-&gt;devfn));
 
-	// Warn about non-tested features
+	/*  Warn about non-tested features */
 	switch (thisboard-&gt;device_id) {
 	case 0x56:
 		break;
@@ -280,16 +280,16 @@ static int cb_pcimdas_attach(struct comedi_device * dev, struct comedi_devconfig
 	printk("devpriv-&gt;BADR4 = 0x%lx\n", devpriv-&gt;BADR4);
 #endif
 
-// Dont support IRQ yet
-//      // get irq
-//      if(comedi_request_irq(devpriv-&gt;pci_dev-&gt;irq, cb_pcimdas_interrupt, IRQF_SHARED, "cb_pcimdas", dev ))
-//      {
-//              printk(" unable to allocate irq %u\n", devpriv-&gt;pci_dev-&gt;irq);
-//              return -EINVAL;
-//      }
-//      dev-&gt;irq = devpriv-&gt;pci_dev-&gt;irq;
+/* Dont support IRQ yet */
+/*  get irq */
+/* if(comedi_request_irq(devpriv-&gt;pci_dev-&gt;irq, cb_pcimdas_interrupt, IRQF_SHARED, "cb_pcimdas", dev )) */
+/* { */
+/* printk(" unable to allocate irq %u\n", devpriv-&gt;pci_dev-&gt;irq); */
+/* return -EINVAL; */
+/* } */
+/* dev-&gt;irq = devpriv-&gt;pci_dev-&gt;irq; */
 
-	//Initialize dev-&gt;board_name
+	/* Initialize dev-&gt;board_name */
 	dev-&gt;board_name = thisboard-&gt;name;
 
 /*
@@ -300,24 +300,24 @@ static int cb_pcimdas_attach(struct comedi_device * dev, struct comedi_devconfig
 		return -ENOMEM;
 
 	s = dev-&gt;subdevices + 0;
-	//dev-&gt;read_subdev=s;
-	// analog input subdevice
+	/* dev-&gt;read_subdev=s; */
+	/*  analog input subdevice */
 	s-&gt;type = COMEDI_SUBD_AI;
 	s-&gt;subdev_flags = SDF_READABLE | SDF_GROUND;
 	s-&gt;n_chan = thisboard-&gt;ai_se_chans;
 	s-&gt;maxdata = (1 &lt;&lt; thisboard-&gt;ai_bits) - 1;
 	s-&gt;range_table = &amp;range_unknown;
-	s-&gt;len_chanlist = 1;	// This is the maximum chanlist length that
-	// the board can handle
+	s-&gt;len_chanlist = 1;	/*  This is the maximum chanlist length that */
+	/*  the board can handle */
 	s-&gt;insn_read = cb_pcimdas_ai_rinsn;
 
 	s = dev-&gt;subdevices + 1;
-	// analog output subdevice
+	/*  analog output subdevice */
 	s-&gt;type = COMEDI_SUBD_AO;
 	s-&gt;subdev_flags = SDF_WRITABLE;
 	s-&gt;n_chan = thisboard-&gt;ao_nchan;
 	s-&gt;maxdata = 1 &lt;&lt; thisboard-&gt;ao_bits;
-	s-&gt;range_table = &amp;range_unknown;	//ranges are hardware settable, but not software readable.
+	s-&gt;range_table = &amp;range_unknown;	/* ranges are hardware settable, but not software readable. */
 	s-&gt;insn_write = &amp;cb_pcimdas_ao_winsn;
 	s-&gt;insn_read = &amp;cb_pcimdas_ao_rinsn;
 
@@ -382,27 +382,27 @@ static int cb_pcimdas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevi
 	unsigned short chanlims;
 	int maxchans;
 
-	// only support sw initiated reads from a single channel
+	/*  only support sw initiated reads from a single channel */
 
-	//check channel number
-	if ((inb(devpriv-&gt;BADR3 + 2) &amp; 0x20) == 0)	//differential mode
+	/* check channel number */
+	if ((inb(devpriv-&gt;BADR3 + 2) &amp; 0x20) == 0)	/* differential mode */
 		maxchans = thisboard-&gt;ai_diff_chans;
 	else
 		maxchans = thisboard-&gt;ai_se_chans;
 
 	if (chan &gt; (maxchans - 1))
-		return -ETIMEDOUT;	//*** Wrong error code. Fixme.
+		return -ETIMEDOUT;	/* *** Wrong error code. Fixme. */
 
-	//configure for sw initiated read
+	/* configure for sw initiated read */
 	d = inb(devpriv-&gt;BADR3 + 5);
-	if ((d &amp; 0x03) &gt; 0) {	//only reset if needed.
+	if ((d &amp; 0x03) &gt; 0) {	/* only reset if needed. */
 		d = d &amp; 0xfd;
 		outb(d, devpriv-&gt;BADR3 + 5);
 	}
-	outb(0x01, devpriv-&gt;BADR3 + 6);	//set bursting off, conversions on
-	outb(0x00, devpriv-&gt;BADR3 + 7);	//set range to 10V. UP/BP is controlled by a switch on the board
+	outb(0x01, devpriv-&gt;BADR3 + 6);	/* set bursting off, conversions on */
+	outb(0x00, devpriv-&gt;BADR3 + 7);	/* set range to 10V. UP/BP is controlled by a switch on the board */
 
-	// write channel limits to multiplexer, set Low (bits 0-3) and High (bits 4-7) channels to chan.
+	/*  write channel limits to multiplexer, set Low (bits 0-3) and High (bits 4-7) channels to chan. */
 	chanlims = chan | (chan &lt;&lt; 4);
 	outb(chanlims, devpriv-&gt;BADR3 + 0);
 
@@ -411,8 +411,8 @@ static int cb_pcimdas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevi
 		/* trigger conversion */
 		outw(0, devpriv-&gt;BADR2 + 0);
 
-#define TIMEOUT 1000		//typically takes 5 loops on a lightly loaded Pentium 100MHz,
-		//this is likely to be 100 loops on a 2GHz machine, so set 1000 as the limit.
+#define TIMEOUT 1000		/* typically takes 5 loops on a lightly loaded Pentium 100MHz, */
+		/* this is likely to be 100 loops on a 2GHz machine, so set 1000 as the limit. */
 
 		/* wait for conversion to end */
 		for (i = 0; i &lt; TIMEOUT; i++) {
@@ -428,7 +428,7 @@ static int cb_pcimdas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevi
 		d = inw(devpriv-&gt;BADR2 + 0);
 
 		/* mangle the data as necessary */
-		//d ^= 1&lt;&lt;(thisboard-&gt;ai_bits-1); // 16 bit data from ADC, so no mangle needed.
+		/* d ^= 1&lt;&lt;(thisboard-&gt;ai_bits-1); // 16 bit data from ADC, so no mangle needed. */
 
 		data[n] = d;
 	}</pre><hr><pre>commit cf530aa4385c97f668d76c8268d509ef9edebb70
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:44 2009 -0400

    Staging: comedi: remove C99 comments in cb_pcidas.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/cb_pcidas.c b/drivers/staging/comedi/drivers/cb_pcidas.c
index fcc551651367..93dac5110149 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas.c
@@ -70,14 +70,14 @@ analog triggering on 1602 series
 #include "comedi_pci.h"
 #include "comedi_fc.h"
 
-#undef CB_PCIDAS_DEBUG		// disable debugging code
-//#define CB_PCIDAS_DEBUG       // enable debugging code
+#undef CB_PCIDAS_DEBUG		/*  disable debugging code */
+/* #define CB_PCIDAS_DEBUG         enable debugging code */
 
-// PCI vendor number of ComputerBoards/MeasurementComputing
+/* PCI vendor number of ComputerBoards/MeasurementComputing */
 #define PCI_VENDOR_ID_CB	0x1307
-#define TIMER_BASE 100		// 10MHz master clock
-#define AI_BUFFER_SIZE 1024	// maximum fifo size of any supported board
-#define AO_BUFFER_SIZE 1024	// maximum fifo size of any supported board
+#define TIMER_BASE 100		/*  10MHz master clock */
+#define AI_BUFFER_SIZE 1024	/*  maximum fifo size of any supported board */
+#define AO_BUFFER_SIZE 1024	/*  maximum fifo size of any supported board */
 #define NUM_CHANNELS_8800 8
 #define NUM_CHANNELS_7376 1
 #define NUM_CHANNELS_8402 2
@@ -85,71 +85,71 @@ analog triggering on 1602 series
 
 /* PCI-DAS base addresses */
 
-// indices of base address regions
+/* indices of base address regions */
 #define S5933_BADRINDEX 0
 #define CONT_STAT_BADRINDEX 1
 #define ADC_FIFO_BADRINDEX 2
 #define PACER_BADRINDEX 3
 #define AO_BADRINDEX 4
-// sizes of io regions
+/* sizes of io regions */
 #define CONT_STAT_SIZE 10
 #define ADC_FIFO_SIZE 4
 #define PACER_SIZE 12
 #define AO_SIZE 4
 
 /* Control/Status registers */
-#define INT_ADCFIFO	0	// INTERRUPT / ADC FIFO register
-#define   INT_EOS 0x1		// interrupt end of scan
-#define   INT_FHF 0x2		// interrupt fifo half full
-#define   INT_FNE 0x3		// interrupt fifo not empty
-#define   INT_MASK 0x3		// mask of interrupt select bits
-#define   INTE 0x4		// interrupt enable
-#define   DAHFIE 0x8		// dac half full interrupt enable
-#define   EOAIE	0x10		// end of aquisition interrupt enable
-#define   DAHFI	0x20		// dac half full read status / write interrupt clear
-#define   EOAI 0x40		// read end of acq. interrupt status / write clear
-#define   INT 0x80		// read interrupt status / write clear
-#define   EOBI 0x200		// read end of burst interrupt status
-#define   ADHFI 0x400		// read half-full interrupt status
-#define   ADNEI 0x800		// read fifo not empty interrupt latch status
-#define   ADNE 0x1000		// read, fifo not empty (realtime, not latched) status
-#define   DAEMIE	0x1000	// write, dac empty interrupt enable
-#define   LADFUL 0x2000		// read fifo overflow / write clear
-#define   DAEMI 0x4000		// dac fifo empty interrupt status / write clear
-
-#define ADCMUX_CONT	2	// ADC CHANNEL MUX AND CONTROL register
+#define INT_ADCFIFO	0	/*  INTERRUPT / ADC FIFO register */
+#define   INT_EOS 0x1		/*  interrupt end of scan */
+#define   INT_FHF 0x2		/*  interrupt fifo half full */
+#define   INT_FNE 0x3		/*  interrupt fifo not empty */
+#define   INT_MASK 0x3		/*  mask of interrupt select bits */
+#define   INTE 0x4		/*  interrupt enable */
+#define   DAHFIE 0x8		/*  dac half full interrupt enable */
+#define   EOAIE	0x10		/*  end of aquisition interrupt enable */
+#define   DAHFI	0x20		/*  dac half full read status / write interrupt clear */
+#define   EOAI 0x40		/*  read end of acq. interrupt status / write clear */
+#define   INT 0x80		/*  read interrupt status / write clear */
+#define   EOBI 0x200		/*  read end of burst interrupt status */
+#define   ADHFI 0x400		/*  read half-full interrupt status */
+#define   ADNEI 0x800		/*  read fifo not empty interrupt latch status */
+#define   ADNE 0x1000		/*  read, fifo not empty (realtime, not latched) status */
+#define   DAEMIE	0x1000	/*  write, dac empty interrupt enable */
+#define   LADFUL 0x2000		/*  read fifo overflow / write clear */
+#define   DAEMI 0x4000		/*  dac fifo empty interrupt status / write clear */
+
+#define ADCMUX_CONT	2	/*  ADC CHANNEL MUX AND CONTROL register */
 #define   BEGIN_SCAN(x)	((x) &amp; 0xf)
 #define   END_SCAN(x)	(((x) &amp; 0xf) &lt;&lt; 4)
 #define   GAIN_BITS(x)	(((x) &amp; 0x3) &lt;&lt; 8)
-#define   UNIP	0x800		// Analog front-end unipolar for range
-#define   SE	0x400		// Inputs in single-ended mode
-#define   PACER_MASK	0x3000	// pacer source bits
-#define   PACER_INT 0x1000	// internal pacer
-#define   PACER_EXT_FALL	0x2000	// external falling edge
-#define   PACER_EXT_RISE	0x3000	// external rising edge
-#define   EOC	0x4000		// adc not busy
-
-#define TRIG_CONTSTAT 4		// TRIGGER CONTROL/STATUS register
-#define   SW_TRIGGER 0x1	// software start trigger
-#define   EXT_TRIGGER 0x2	// external start trigger
-#define   ANALOG_TRIGGER 0x3	// external analog trigger
-#define   TRIGGER_MASK	0x3	// mask of bits that determine start trigger
-#define   TGEN	0x10		// enable external start trigger
-#define   BURSTE 0x20		// burst mode enable
-#define   XTRCL	0x80		// clear external trigger
-
-#define CALIBRATION_REG	6	// CALIBRATION register
-#define   SELECT_8800_BIT	0x100	// select 8800 caldac
-#define   SELECT_TRIMPOT_BIT	0x200	// select ad7376 trim pot
-#define   SELECT_DAC08_BIT	0x400	// select dac08 caldac
+#define   UNIP	0x800		/*  Analog front-end unipolar for range */
+#define   SE	0x400		/*  Inputs in single-ended mode */
+#define   PACER_MASK	0x3000	/*  pacer source bits */
+#define   PACER_INT 0x1000	/*  internal pacer */
+#define   PACER_EXT_FALL	0x2000	/*  external falling edge */
+#define   PACER_EXT_RISE	0x3000	/*  external rising edge */
+#define   EOC	0x4000		/*  adc not busy */
+
+#define TRIG_CONTSTAT 4		/*  TRIGGER CONTROL/STATUS register */
+#define   SW_TRIGGER 0x1	/*  software start trigger */
+#define   EXT_TRIGGER 0x2	/*  external start trigger */
+#define   ANALOG_TRIGGER 0x3	/*  external analog trigger */
+#define   TRIGGER_MASK	0x3	/*  mask of bits that determine start trigger */
+#define   TGEN	0x10		/*  enable external start trigger */
+#define   BURSTE 0x20		/*  burst mode enable */
+#define   XTRCL	0x80		/*  clear external trigger */
+
+#define CALIBRATION_REG	6	/*  CALIBRATION register */
+#define   SELECT_8800_BIT	0x100	/*  select 8800 caldac */
+#define   SELECT_TRIMPOT_BIT	0x200	/*  select ad7376 trim pot */
+#define   SELECT_DAC08_BIT	0x400	/*  select dac08 caldac */
 #define   CAL_SRC_BITS(x)	(((x) &amp; 0x7) &lt;&lt; 11)
-#define   CAL_EN_BIT	0x4000	// read calibration source instead of analog input channel 0
-#define   SERIAL_DATA_IN_BIT	0x8000	// serial data stream going to 8800 and 7376
+#define   CAL_EN_BIT	0x4000	/*  read calibration source instead of analog input channel 0 */
+#define   SERIAL_DATA_IN_BIT	0x8000	/*  serial data stream going to 8800 and 7376 */
 
-#define DAC_CSR	0x8		// dac control and status register
+#define DAC_CSR	0x8		/*  dac control and status register */
 enum dac_csr_bits {
-	DACEN = 0x2,		// dac enable
-	DAC_MODE_UPDATE_BOTH = 0x80,	// update both dacs when dac0 is written
+	DACEN = 0x2,		/*  dac enable */
+	DAC_MODE_UPDATE_BOTH = 0x80,	/*  update both dacs when dac0 is written */
 };
 static inline unsigned int DAC_RANGE(unsigned int channel, unsigned int range)
 {
@@ -160,42 +160,42 @@ static inline unsigned int DAC_RANGE_MASK(unsigned int channel)
 	return 0x3 &lt;&lt; (8 + 2 * (channel &amp; 0x1));
 };
 
-// bits for 1602 series only
+/* bits for 1602 series only */
 enum dac_csr_bits_1602 {
-	DAC_EMPTY = 0x1,	// dac fifo empty, read, write clear
-	DAC_START = 0x4,	// start/arm dac fifo operations
-	DAC_PACER_MASK = 0x18,	// bits that set dac pacer source
-	DAC_PACER_INT = 0x8,	// dac internal pacing
-	DAC_PACER_EXT_FALL = 0x10,	// dac external pacing, falling edge
-	DAC_PACER_EXT_RISE = 0x18,	// dac external pacing, rising edge
+	DAC_EMPTY = 0x1,	/*  dac fifo empty, read, write clear */
+	DAC_START = 0x4,	/*  start/arm dac fifo operations */
+	DAC_PACER_MASK = 0x18,	/*  bits that set dac pacer source */
+	DAC_PACER_INT = 0x8,	/*  dac internal pacing */
+	DAC_PACER_EXT_FALL = 0x10,	/*  dac external pacing, falling edge */
+	DAC_PACER_EXT_RISE = 0x18,	/*  dac external pacing, rising edge */
 };
 static inline unsigned int DAC_CHAN_EN(unsigned int channel)
 {
-	return 1 &lt;&lt; (5 + (channel &amp; 0x1));	// enable channel 0 or 1
+	return 1 &lt;&lt; (5 + (channel &amp; 0x1));	/*  enable channel 0 or 1 */
 };
 
 /* analog input fifo */
-#define ADCDATA	0		// ADC DATA register
-#define ADCFIFOCLR	2	// ADC FIFO CLEAR
+#define ADCDATA	0		/*  ADC DATA register */
+#define ADCFIFOCLR	2	/*  ADC FIFO CLEAR */
 
-// pacer, counter, dio registers
+/* pacer, counter, dio registers */
 #define ADC8254 0
 #define DIO_8255 4
 #define DAC8254 8
 
-// analog output registers for 100x, 1200 series
+/* analog output registers for 100x, 1200 series */
 static inline unsigned int DAC_DATA_REG(unsigned int channel)
 {
 	return 2 * (channel &amp; 0x1);
 }
 
 /* analog output registers for 1602 series*/
-#define DACDATA	0		// DAC DATA register
-#define DACFIFOCLR	2	// DAC FIFO CLEAR
+#define DACDATA	0		/*  DAC DATA register */
+#define DACFIFOCLR	2	/*  DAC FIFO CLEAR */
 
-// bit in hexadecimal representation of range index that indicates unipolar input range
+/* bit in hexadecimal representation of range index that indicates unipolar input range */
 #define IS_UNIPOLAR 0x4
-// analog input ranges for most boards
+/* analog input ranges for most boards */
 static const struct comedi_lrange cb_pcidas_ranges = {
 	8,
 	{
@@ -210,7 +210,7 @@ static const struct comedi_lrange cb_pcidas_ranges = {
 		}
 };
 
-// pci-das1001 input ranges
+/* pci-das1001 input ranges */
 static const struct comedi_lrange cb_pcidas_alt_ranges = {
 	8,
 	{
@@ -225,7 +225,7 @@ static const struct comedi_lrange cb_pcidas_alt_ranges = {
 		}
 };
 
-// analog output ranges
+/* analog output ranges */
 static const struct comedi_lrange cb_pcidas_ao_ranges = {
 	4,
 	{
@@ -244,14 +244,14 @@ enum trimpot_model {
 struct cb_pcidas_board {
 	const char *name;
 	unsigned short device_id;
-	int ai_se_chans;	// Inputs in single-ended mode
-	int ai_diff_chans;	// Inputs in differential mode
-	int ai_bits;		// analog input resolution
-	int ai_speed;		// fastest conversion period in ns
-	int ao_nchan;		// number of analog out channels
-	int has_ao_fifo;	// analog output has fifo
-	int ao_scan_speed;	// analog output speed for 1602 series (for a scan, not conversion)
-	int fifo_size;		// number of samples fifo can hold
+	int ai_se_chans;	/*  Inputs in single-ended mode */
+	int ai_diff_chans;	/*  Inputs in differential mode */
+	int ai_bits;		/*  analog input resolution */
+	int ai_speed;		/*  fastest conversion period in ns */
+	int ao_nchan;		/*  number of analog out channels */
+	int has_ao_fifo;	/*  analog output has fifo */
+	int ao_scan_speed;	/*  analog output speed for 1602 series (for a scan, not conversion) */
+	int fifo_size;		/*  number of samples fifo can hold */
 	const struct comedi_lrange *ranges;
 	enum trimpot_model trimpot;
 	unsigned has_dac08:1;
@@ -374,7 +374,7 @@ static const struct cb_pcidas_board cb_pcidas_boards[] = {
 		},
 };
 
-// Number of boards in cb_pcidas_boards
+/* Number of boards in cb_pcidas_boards */
 #define N_BOARDS	(sizeof(cb_pcidas_boards) / sizeof(struct cb_pcidas_board))
 
 static DEFINE_PCI_DEVICE_TABLE(cb_pcidas_pci_table) = {
@@ -402,28 +402,28 @@ MODULE_DEVICE_TABLE(pci, cb_pcidas_pci_table);
 struct cb_pcidas_private {
 	/* would be useful for a PCI device */
 	struct pci_dev *pci_dev;
-	// base addresses
+	/*  base addresses */
 	unsigned long s5933_config;
 	unsigned long control_status;
 	unsigned long adc_fifo;
 	unsigned long pacer_counter_dio;
 	unsigned long ao_registers;
-	// divisors of master clock for analog input pacing
+	/*  divisors of master clock for analog input pacing */
 	unsigned int divisor1;
 	unsigned int divisor2;
-	volatile unsigned int count;	// number of analog input samples remaining
-	volatile unsigned int adc_fifo_bits;	// bits to write to interupt/adcfifo register
-	volatile unsigned int s5933_intcsr_bits;	// bits to write to amcc s5933 interrupt control/status register
-	volatile unsigned int ao_control_bits;	// bits to write to ao control and status register
+	volatile unsigned int count;	/*  number of analog input samples remaining */
+	volatile unsigned int adc_fifo_bits;	/*  bits to write to interupt/adcfifo register */
+	volatile unsigned int s5933_intcsr_bits;	/*  bits to write to amcc s5933 interrupt control/status register */
+	volatile unsigned int ao_control_bits;	/*  bits to write to ao control and status register */
 	short ai_buffer[AI_BUFFER_SIZE];
 	short ao_buffer[AO_BUFFER_SIZE];
-	// divisors of master clock for analog output pacing
+	/*  divisors of master clock for analog output pacing */
 	unsigned int ao_divisor1;
 	unsigned int ao_divisor2;
-	volatile unsigned int ao_count;	// number of analog output samples remaining
-	int ao_value[2];	// remember what the analog outputs are set to, to allow readback
-	unsigned int caldac_value[NUM_CHANNELS_8800];	// for readback of caldac
-	unsigned int trimpot_value[NUM_CHANNELS_8402];	// for readback of trimpot
+	volatile unsigned int ao_count;	/*  number of analog output samples remaining */
+	int ao_value[2];	/*  remember what the analog outputs are set to, to allow readback */
+	unsigned int caldac_value[NUM_CHANNELS_8800];	/*  for readback of caldac */
+	unsigned int trimpot_value[NUM_CHANNELS_8402];	/*  for readback of trimpot */
 	unsigned int dac08_value;
 	unsigned int calibration_source;
 };
@@ -531,16 +531,16 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev-&gt;vendor != PCI_VENDOR_ID_CB)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0; index &lt; N_BOARDS; index++) {
 			if (cb_pcidas_boards[index].device_id != pcidev-&gt;device)
 				continue;
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it-&gt;options[0] || it-&gt;options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev-&gt;bus-&gt;number != it-&gt;options[0] ||
 					PCI_SLOT(pcidev-&gt;devfn) !=
 					it-&gt;options[1]) {
@@ -585,11 +585,11 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 		devpriv-&gt;ao_registers =
 			pci_resource_start(devpriv-&gt;pci_dev, AO_BADRINDEX);
 	}
-	// disable and clear interrupts on amcc s5933
+	/*  disable and clear interrupts on amcc s5933 */
 	outl(INTCSR_INBOX_INTR_STATUS,
 		devpriv-&gt;s5933_config + AMCC_OP_REG_INTCSR);
 
-	// get irq
+	/*  get irq */
 	if (comedi_request_irq(devpriv-&gt;pci_dev-&gt;irq, cb_pcidas_interrupt,
 			IRQF_SHARED, "cb_pcidas", dev)) {
 		printk(" unable to allocate irq %d\n", devpriv-&gt;pci_dev-&gt;irq);
@@ -597,7 +597,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	}
 	dev-&gt;irq = devpriv-&gt;pci_dev-&gt;irq;
 
-	//Initialize dev-&gt;board_name
+	/* Initialize dev-&gt;board_name */
 	dev-&gt;board_name = thisboard-&gt;name;
 
 /*
@@ -628,7 +628,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 		s-&gt;type = COMEDI_SUBD_AO;
 		s-&gt;subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_GROUND;
 		s-&gt;n_chan = thisboard-&gt;ao_nchan;
-		// analog out resolution is the same as analog input resolution, so use ai_bits
+		/*  analog out resolution is the same as analog input resolution, so use ai_bits */
 		s-&gt;maxdata = (1 &lt;&lt; thisboard-&gt;ai_bits) - 1;
 		s-&gt;range_table = &amp;cb_pcidas_ao_ranges;
 		s-&gt;insn_read = cb_pcidas_ao_readback_insn;
@@ -650,7 +650,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	s = dev-&gt;subdevices + 2;
 	subdev_8255_init(dev, s, NULL, devpriv-&gt;pacer_counter_dio + DIO_8255);
 
-	// serial EEPROM,
+	/*  serial EEPROM, */
 	s = dev-&gt;subdevices + 3;
 	s-&gt;type = COMEDI_SUBD_MEMORY;
 	s-&gt;subdev_flags = SDF_READABLE | SDF_INTERNAL;
@@ -658,7 +658,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	s-&gt;maxdata = 0xff;
 	s-&gt;insn_read = eeprom_read_insn;
 
-	// 8800 caldac
+	/*  8800 caldac */
 	s = dev-&gt;subdevices + 4;
 	s-&gt;type = COMEDI_SUBD_CALIB;
 	s-&gt;subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -669,7 +669,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	for (i = 0; i &lt; s-&gt;n_chan; i++)
 		caldac_8800_write(dev, i, s-&gt;maxdata / 2);
 
-	// trim potentiometer
+	/*  trim potentiometer */
 	s = dev-&gt;subdevices + 5;
 	s-&gt;type = COMEDI_SUBD_CALIB;
 	s-&gt;subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -685,7 +685,7 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	for (i = 0; i &lt; s-&gt;n_chan; i++)
 		cb_pcidas_trimpot_write(dev, i, s-&gt;maxdata / 2);
 
-	// dac08 caldac
+	/*  dac08 caldac */
 	s = dev-&gt;subdevices + 6;
 	if (thisboard-&gt;has_dac08) {
 		s-&gt;type = COMEDI_SUBD_CALIB;
@@ -698,13 +698,13 @@ static int cb_pcidas_attach(struct comedi_device * dev, struct comedi_devconfig
 	} else
 		s-&gt;type = COMEDI_SUBD_UNUSED;
 
-	// make sure mailbox 4 is empty
+	/*  make sure mailbox 4 is empty */
 	inl(devpriv-&gt;s5933_config + AMCC_OP_REG_IMB4);
 	/* Set bits to enable incoming mailbox interrupts on amcc s5933. */
 	devpriv-&gt;s5933_intcsr_bits =
 		INTCSR_INBOX_BYTE(3) | INTCSR_INBOX_SELECT(3) |
 		INTCSR_INBOX_FULL_INT;
-	// clear and enable interrupt on amcc s5933
+	/*  clear and enable interrupt on amcc s5933 */
 	outl(devpriv-&gt;s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 		devpriv-&gt;s5933_config + AMCC_OP_REG_INTCSR);
 
@@ -725,7 +725,7 @@ static int cb_pcidas_detach(struct comedi_device * dev)
 
 	if (devpriv) {
 		if (devpriv-&gt;s5933_config) {
-			// disable and clear interrupts on amcc s5933
+			/*  disable and clear interrupts on amcc s5933 */
 			outl(INTCSR_INBOX_INTR_STATUS,
 				devpriv-&gt;s5933_config + AMCC_OP_REG_INTCSR);
 #ifdef CB_PCIDAS_DEBUG
@@ -760,7 +760,7 @@ static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevic
 	unsigned int bits;
 	static const int timeout = 10000;
 	int channel;
-	// enable calibration input if appropriate
+	/*  enable calibration input if appropriate */
 	if (insn-&gt;chanspec &amp; CR_ALT_SOURCE) {
 		outw(cal_enable_bits(dev),
 			devpriv-&gt;control_status + CALIBRATION_REG);
@@ -769,13 +769,13 @@ static int cb_pcidas_ai_rinsn(struct comedi_device * dev, struct comedi_subdevic
 		outw(0, devpriv-&gt;control_status + CALIBRATION_REG);
 		channel = CR_CHAN(insn-&gt;chanspec);
 	}
-	// set mux limits and gain
+	/*  set mux limits and gain */
 	bits = BEGIN_SCAN(channel) |
 		END_SCAN(channel) | GAIN_BITS(CR_RANGE(insn-&gt;chanspec));
-	// set unipolar/bipolar
+	/*  set unipolar/bipolar */
 	if (CR_RANGE(insn-&gt;chanspec) &amp; IS_UNIPOLAR)
 		bits |= UNIP;
-	// set singleended/differential
+	/*  set singleended/differential */
 	if (CR_AREF(insn-&gt;chanspec) != AREF_DIFF)
 		bits |= SE;
 	outw(bits, devpriv-&gt;control_status + ADCMUX_CONT);
@@ -836,14 +836,14 @@ static int ai_config_insn(struct comedi_device * dev, struct comedi_subdevice *
 	return -EINVAL;
 }
 
-// analog output insn for pcidas-1000 and 1200 series
+/* analog output insn for pcidas-1000 and 1200 series */
 static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
 
-	// set channel and range
+	/*  set channel and range */
 	channel = CR_CHAN(insn-&gt;chanspec);
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	devpriv-&gt;ao_control_bits &amp;=
@@ -853,25 +853,25 @@ static int cb_pcidas_ao_nofifo_winsn(struct comedi_device * dev, struct comedi_s
 	outw(devpriv-&gt;ao_control_bits, devpriv-&gt;control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// remember value for readback
+	/*  remember value for readback */
 	devpriv-&gt;ao_value[channel] = data[0];
-	// send data
+	/*  send data */
 	outw(data[0], devpriv-&gt;ao_registers + DAC_DATA_REG(channel));
 
 	return 1;
 }
 
-// analog output insn for pcidas-1602 series
+/* analog output insn for pcidas-1602 series */
 static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
 	int channel;
 	unsigned long flags;
 
-	// clear dac fifo
+	/*  clear dac fifo */
 	outw(0, devpriv-&gt;ao_registers + DACFIFOCLR);
 
-	// set channel and range
+	/*  set channel and range */
 	channel = CR_CHAN(insn-&gt;chanspec);
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	devpriv-&gt;ao_control_bits &amp;=
@@ -883,16 +883,16 @@ static int cb_pcidas_ao_fifo_winsn(struct comedi_device * dev, struct comedi_sub
 	outw(devpriv-&gt;ao_control_bits, devpriv-&gt;control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// remember value for readback
+	/*  remember value for readback */
 	devpriv-&gt;ao_value[channel] = data[0];
-	// send data
+	/*  send data */
 	outw(data[0], devpriv-&gt;ao_registers + DACDATA);
 
 	return 1;
 }
 
-// analog output readback insn
-// XXX loses track of analog output value back after an analog ouput command is executed
+/* analog output readback insn */
+/* XXX loses track of analog output value back after an analog ouput command is executed */
 static int cb_pcidas_ao_readback_insn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
@@ -1066,7 +1066,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	if (cmd-&gt;stop_src != TRIG_COUNT &amp;&amp; cmd-&gt;stop_src != TRIG_NONE)
 		err++;
 
-	// make sure trigger sources are compatible with each other
+	/*  make sure trigger sources are compatible with each other */
 	if (cmd-&gt;scan_begin_src == TRIG_FOLLOW &amp;&amp; cmd-&gt;convert_src == TRIG_NOW)
 		err++;
 	if (cmd-&gt;scan_begin_src != TRIG_FOLLOW &amp;&amp; cmd-&gt;convert_src != TRIG_NOW)
@@ -1138,7 +1138,7 @@ static int cb_pcidas_ai_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd-&gt;chanlist) {
 		gain = CR_RANGE(cmd-&gt;chanlist[0]);
 		start_chan = CR_CHAN(cmd-&gt;chanlist[0]);
@@ -1170,24 +1170,24 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 	unsigned int bits;
 	unsigned long flags;
 
-	// make sure CAL_EN_BIT is disabled
+	/*  make sure CAL_EN_BIT is disabled */
 	outw(0, devpriv-&gt;control_status + CALIBRATION_REG);
-	// initialize before settings pacer source and count values
+	/*  initialize before settings pacer source and count values */
 	outw(0, devpriv-&gt;control_status + TRIG_CONTSTAT);
-	// clear fifo
+	/*  clear fifo */
 	outw(0, devpriv-&gt;adc_fifo + ADCFIFOCLR);
 
-	// set mux limits, gain and pacer source
+	/*  set mux limits, gain and pacer source */
 	bits = BEGIN_SCAN(CR_CHAN(cmd-&gt;chanlist[0])) |
 		END_SCAN(CR_CHAN(cmd-&gt;chanlist[cmd-&gt;chanlist_len - 1])) |
 		GAIN_BITS(CR_RANGE(cmd-&gt;chanlist[0]));
-	// set unipolar/bipolar
+	/*  set unipolar/bipolar */
 	if (CR_RANGE(cmd-&gt;chanlist[0]) &amp; IS_UNIPOLAR)
 		bits |= UNIP;
-	// set singleended/differential
+	/*  set singleended/differential */
 	if (CR_AREF(cmd-&gt;chanlist[0]) != AREF_DIFF)
 		bits |= SE;
-	// set pacer source
+	/*  set pacer source */
 	if (cmd-&gt;convert_src == TRIG_EXT || cmd-&gt;scan_begin_src == TRIG_EXT)
 		bits |= PACER_EXT_RISE;
 	else
@@ -1198,7 +1198,7 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 	rt_printk("comedi: sent 0x%x to adcmux control\n", bits);
 #endif
 
-	// load counters
+	/*  load counters */
 	if (cmd-&gt;convert_src == TRIG_TIMER)
 		cb_pcidas_load_counters(dev, &amp;cmd-&gt;convert_arg,
 			cmd-&gt;flags &amp; TRIG_ROUND_MASK);
@@ -1206,31 +1206,31 @@ static int cb_pcidas_ai_cmd(struct comedi_device * dev, struct comedi_subdevice
 		cb_pcidas_load_counters(dev, &amp;cmd-&gt;scan_begin_arg,
 			cmd-&gt;flags &amp; TRIG_ROUND_MASK);
 
-	// set number of conversions
+	/*  set number of conversions */
 	if (cmd-&gt;stop_src == TRIG_COUNT) {
 		devpriv-&gt;count = cmd-&gt;chanlist_len * cmd-&gt;stop_arg;
 	}
-	// enable interrupts
+	/*  enable interrupts */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	devpriv-&gt;adc_fifo_bits |= INTE;
 	devpriv-&gt;adc_fifo_bits &amp;= ~INT_MASK;
 	if (cmd-&gt;flags &amp; TRIG_WAKE_EOS) {
 		if (cmd-&gt;convert_src == TRIG_NOW &amp;&amp; cmd-&gt;chanlist_len &gt; 1)
-			devpriv-&gt;adc_fifo_bits |= INT_EOS;	// interrupt end of burst
+			devpriv-&gt;adc_fifo_bits |= INT_EOS;	/*  interrupt end of burst */
 		else
-			devpriv-&gt;adc_fifo_bits |= INT_FNE;	// interrupt fifo not empty
+			devpriv-&gt;adc_fifo_bits |= INT_FNE;	/*  interrupt fifo not empty */
 	} else {
-		devpriv-&gt;adc_fifo_bits |= INT_FHF;	//interrupt fifo half full
+		devpriv-&gt;adc_fifo_bits |= INT_FHF;	/* interrupt fifo half full */
 	}
 #ifdef CB_PCIDAS_DEBUG
 	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv-&gt;adc_fifo_bits);
 #endif
-	// enable (and clear) interrupts
+	/*  enable (and clear) interrupts */
 	outw(devpriv-&gt;adc_fifo_bits | EOAI | INT | LADFUL,
 		devpriv-&gt;control_status + INT_ADCFIFO);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// set start trigger and burst mode
+	/*  set start trigger and burst mode */
 	bits = 0;
 	if (cmd-&gt;start_src == TRIG_NOW)
 		bits |= SW_TRIGGER;
@@ -1347,7 +1347,7 @@ static int cb_pcidas_ao_cmdtest(struct comedi_device * dev, struct comedi_subdev
 	if (err)
 		return 4;
 
-	// check channel/gain list against card's limitations
+	/*  check channel/gain list against card's limitations */
 	if (cmd-&gt;chanlist &amp;&amp; cmd-&gt;chanlist_len &gt; 1) {
 		if (CR_CHAN(cmd-&gt;chanlist[0]) != 0 ||
 			CR_CHAN(cmd-&gt;chanlist[1]) != 1) {
@@ -1370,25 +1370,25 @@ static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice
 	unsigned int i;
 	unsigned long flags;
 
-	// set channel limits, gain
+	/*  set channel limits, gain */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	for (i = 0; i &lt; cmd-&gt;chanlist_len; i++) {
-		// enable channel
+		/*  enable channel */
 		devpriv-&gt;ao_control_bits |=
 			DAC_CHAN_EN(CR_CHAN(cmd-&gt;chanlist[i]));
-		// set range
+		/*  set range */
 		devpriv-&gt;ao_control_bits |= DAC_RANGE(CR_CHAN(cmd-&gt;chanlist[i]),
 			CR_RANGE(cmd-&gt;chanlist[i]));
 	}
 
-	// disable analog out before settings pacer source and count values
+	/*  disable analog out before settings pacer source and count values */
 	outw(devpriv-&gt;ao_control_bits, devpriv-&gt;control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// clear fifo
+	/*  clear fifo */
 	outw(0, devpriv-&gt;ao_registers + DACFIFOCLR);
 
-	// load counters
+	/*  load counters */
 	if (cmd-&gt;scan_begin_src == TRIG_TIMER) {
 		i8253_cascade_ns_to_timer_2div(TIMER_BASE,
 			&amp;(devpriv-&gt;ao_divisor1), &amp;(devpriv-&gt;ao_divisor2),
@@ -1400,11 +1400,11 @@ static int cb_pcidas_ao_cmd(struct comedi_device * dev, struct comedi_subdevice
 		i8254_load(devpriv-&gt;pacer_counter_dio + DAC8254, 0, 2,
 			devpriv-&gt;ao_divisor2, 2);
 	}
-	// set number of conversions
+	/*  set number of conversions */
 	if (cmd-&gt;stop_src == TRIG_COUNT) {
 		devpriv-&gt;ao_count = cmd-&gt;chanlist_len * cmd-&gt;stop_arg;
 	}
-	// set pacer source
+	/*  set pacer source */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	switch (cmd-&gt;scan_begin_src) {
 	case TRIG_TIMER:
@@ -1438,7 +1438,7 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	if (trig_num != 0)
 		return -EINVAL;
 
-	// load up fifo
+	/*  load up fifo */
 	if (cmd-&gt;stop_src == TRIG_COUNT &amp;&amp; devpriv-&gt;ao_count &lt; num_points)
 		num_points = devpriv-&gt;ao_count;
 
@@ -1449,20 +1449,20 @@ static int cb_pcidas_ao_inttrig(struct comedi_device *dev,
 	if (cmd-&gt;stop_src == TRIG_COUNT) {
 		devpriv-&gt;ao_count -= num_points;
 	}
-	// write data to board's fifo
+	/*  write data to board's fifo */
 	outsw(devpriv-&gt;ao_registers + DACDATA, devpriv-&gt;ao_buffer, num_bytes);
 
-	// enable dac half-full and empty interrupts
+	/*  enable dac half-full and empty interrupts */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	devpriv-&gt;adc_fifo_bits |= DAEMIE | DAHFIE;
 #ifdef CB_PCIDAS_DEBUG
 	rt_printk("comedi: adc_fifo_bits are 0x%x\n", devpriv-&gt;adc_fifo_bits);
 #endif
-	// enable and clear interrupts
+	/*  enable and clear interrupts */
 	outw(devpriv-&gt;adc_fifo_bits | DAEMI | DAHFI,
 		devpriv-&gt;control_status + INT_ADCFIFO);
 
-	// start dac
+	/*  start dac */
 	devpriv-&gt;ao_control_bits |= DAC_START | DACEN | DAC_EMPTY;
 	outw(devpriv-&gt;ao_control_bits, devpriv-&gt;control_status + DAC_CSR);
 #ifdef CB_PCIDAS_DEBUG
@@ -1503,9 +1503,9 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 	if ((INTCSR_INTR_ASSERTED &amp; s5933_status) == 0)
 		return IRQ_NONE;
 
-	// make sure mailbox 4 is empty
+	/*  make sure mailbox 4 is empty */
 	inl_p(devpriv-&gt;s5933_config + AMCC_OP_REG_IMB4);
-	// clear interrupt on amcc s5933
+	/*  clear interrupt on amcc s5933 */
 	outl(devpriv-&gt;s5933_intcsr_bits | INTCSR_INBOX_INTR_STATUS,
 		devpriv-&gt;s5933_config + AMCC_OP_REG_INTCSR);
 
@@ -1516,14 +1516,14 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 	}
 #endif
 
-	// check for analog output interrupt
+	/*  check for analog output interrupt */
 	if (status &amp; (DAHFI | DAEMI)) {
 		handle_ao_interrupt(dev, status);
 	}
-	// check for analog input interrupts
-	// if fifo half-full
+	/*  check for analog input interrupts */
+	/*  if fifo half-full */
 	if (status &amp; ADHFI) {
-		// read data
+		/*  read data */
 		num_samples = half_fifo;
 		if (async-&gt;cmd.stop_src == TRIG_COUNT &amp;&amp;
 			num_samples &gt; devpriv-&gt;count) {
@@ -1538,15 +1538,15 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 			async-&gt;events |= COMEDI_CB_EOA;
 			cb_pcidas_cancel(dev, s);
 		}
-		// clear half-full interrupt latch
+		/*  clear half-full interrupt latch */
 		comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 		outw(devpriv-&gt;adc_fifo_bits | INT,
 			devpriv-&gt;control_status + INT_ADCFIFO);
 		comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
-		// else if fifo not empty
+		/*  else if fifo not empty */
 	} else if (status &amp; (ADNEI | EOBI)) {
 		for (i = 0; i &lt; timeout; i++) {
-			// break if fifo is empty
+			/*  break if fifo is empty */
 			if ((ADNE &amp; inw(devpriv-&gt;control_status +
 						INT_ADCFIFO)) == 0)
 				break;
@@ -1557,7 +1557,7 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 				break;
 			}
 		}
-		// clear not-empty interrupt latch
+		/*  clear not-empty interrupt latch */
 		comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 		outw(devpriv-&gt;adc_fifo_bits | INT,
 			devpriv-&gt;control_status + INT_ADCFIFO);
@@ -1565,16 +1565,16 @@ static irqreturn_t cb_pcidas_interrupt(int irq, void *d PT_REGS_ARG)
 	} else if (status &amp; EOAI) {
 		comedi_error(dev,
 			"bug! encountered end of aquisition interrupt?");
-		// clear EOA interrupt latch
+		/*  clear EOA interrupt latch */
 		comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 		outw(devpriv-&gt;adc_fifo_bits | EOAI,
 			devpriv-&gt;control_status + INT_ADCFIFO);
 		comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 	}
-	//check for fifo overflow
+	/* check for fifo overflow */
 	if (status &amp; LADFUL) {
 		comedi_error(dev, "fifo overflow");
-		// clear overflow interrupt latch
+		/*  clear overflow interrupt latch */
 		comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 		outw(devpriv-&gt;adc_fifo_bits | LADFUL,
 			devpriv-&gt;control_status + INT_ADCFIFO);
@@ -1600,7 +1600,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 	async-&gt;events = 0;
 
 	if (status &amp; DAEMI) {
-		// clear dac empty interrupt latch
+		/*  clear dac empty interrupt latch */
 		comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 		outw(devpriv-&gt;adc_fifo_bits | DAEMI,
 			devpriv-&gt;control_status + INT_ADCFIFO);
@@ -1618,7 +1618,7 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 	} else if (status &amp; DAHFI) {
 		unsigned int num_bytes;
 
-		// figure out how many points we are writing to fifo
+		/*  figure out how many points we are writing to fifo */
 		num_points = half_fifo;
 		if (cmd-&gt;stop_src == TRIG_COUNT &amp;&amp;
 			devpriv-&gt;ao_count &lt; num_points)
@@ -1631,10 +1631,10 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned int status)
 		if (async-&gt;cmd.stop_src == TRIG_COUNT) {
 			devpriv-&gt;ao_count -= num_points;
 		}
-		// write data to board's fifo
+		/*  write data to board's fifo */
 		outsw(devpriv-&gt;ao_registers + DACDATA, devpriv-&gt;ao_buffer,
 			num_points);
-		// clear half-full interrupt latch
+		/*  clear half-full interrupt latch */
 		comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 		outw(devpriv-&gt;adc_fifo_bits | DAHFI,
 			devpriv-&gt;control_status + INT_ADCFIFO);
@@ -1650,14 +1650,14 @@ static int cb_pcidas_cancel(struct comedi_device * dev, struct comedi_subdevice
 	unsigned long flags;
 
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
-	// disable interrupts
+	/*  disable interrupts */
 	devpriv-&gt;adc_fifo_bits &amp;= ~INTE &amp; ~EOAIE;
 	outw(devpriv-&gt;adc_fifo_bits, devpriv-&gt;control_status + INT_ADCFIFO);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// disable start trigger source and burst mode
+	/*  disable start trigger source and burst mode */
 	outw(0, devpriv-&gt;control_status + TRIG_CONTSTAT);
-	// software pacer source
+	/*  software pacer source */
 	outw(0, devpriv-&gt;control_status + ADCMUX_CONT);
 
 	return 0;
@@ -1670,11 +1670,11 @@ static int cb_pcidas_ao_cancel(struct comedi_device *dev,
 	unsigned long flags;
 
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
-	// disable interrupts
+	/*  disable interrupts */
 	devpriv-&gt;adc_fifo_bits &amp;= ~DAHFIE &amp; ~DAEMIE;
 	outw(devpriv-&gt;adc_fifo_bits, devpriv-&gt;control_status + INT_ADCFIFO);
 
-	// disable output
+	/*  disable output */
 	devpriv-&gt;ao_control_bits &amp;= ~DACEN &amp; ~DAC_PACER_MASK;
 	outw(devpriv-&gt;ao_control_bits, devpriv-&gt;control_status + DAC_CSR);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);</pre><hr><pre>commit 9ef4dea6eb9ff671ffd62f5304c7d8de716807a2
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:39 2009 -0400

    Staging: comedi: remove C99 comments in cb_pcidas64.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/cb_pcidas64.c b/drivers/staging/comedi/drivers/cb_pcidas64.c
index 1a580bd2247a..7b57e3ab79c2 100644
--- a/drivers/staging/comedi/drivers/cb_pcidas64.c
+++ b/drivers/staging/comedi/drivers/cb_pcidas64.c
@@ -93,8 +93,8 @@ known. If you have such a board, please file a bug report at
 #include "plx9080.h"
 #include "comedi_fc.h"
 
-#undef PCIDAS64_DEBUG		// disable debugging code
-//#define PCIDAS64_DEBUG        // enable debugging code
+#undef PCIDAS64_DEBUG		/*  disable debugging code */
+/* #define PCIDAS64_DEBUG         enable debugging code */
 
 #ifdef PCIDAS64_DEBUG
 #define DEBUG_PRINT(format, args...)  rt_printk(format , ## args )
@@ -102,8 +102,8 @@ known. If you have such a board, please file a bug report at
 #define DEBUG_PRINT(format, args...)
 #endif
 
-#define TIMER_BASE 25		// 40MHz master clock
-#define PRESCALED_TIMER_BASE	10000	// 100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday
+#define TIMER_BASE 25		/*  40MHz master clock */
+#define PRESCALED_TIMER_BASE	10000	/*  100kHz 'prescaled' clock for slow aquisition, maybe I'll support this someday */
 #define DMA_BUFFER_SIZE 0x1000
 
 /* maximum value that can be loaded into board's 24-bit counters*/
@@ -111,41 +111,41 @@ static const int max_counter_value = 0xffffff;
 
 /* PCI-DAS64xxx base addresses */
 
-// indices of base address regions
+/* indices of base address regions */
 enum base_address_regions {
 	PLX9080_BADDRINDEX = 0,
 	MAIN_BADDRINDEX = 2,
 	DIO_COUNTER_BADDRINDEX = 3,
 };
 
-// priv(dev)-&gt;main_iobase registers
+/* priv(dev)-&gt;main_iobase registers */
 enum write_only_registers {
-	INTR_ENABLE_REG = 0x0,	// interrupt enable register
-	HW_CONFIG_REG = 0x2,	// hardware config register
+	INTR_ENABLE_REG = 0x0,	/*  interrupt enable register */
+	HW_CONFIG_REG = 0x2,	/*  hardware config register */
 	DAQ_SYNC_REG = 0xc,
 	DAQ_ATRIG_LOW_4020_REG = 0xc,
-	ADC_CONTROL0_REG = 0x10,	// adc control register 0
-	ADC_CONTROL1_REG = 0x12,	// adc control register 1
+	ADC_CONTROL0_REG = 0x10,	/*  adc control register 0 */
+	ADC_CONTROL1_REG = 0x12,	/*  adc control register 1 */
 	CALIBRATION_REG = 0x14,
-	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,	// lower 16 bits of adc sample interval counter
-	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,	// upper 8 bits of adc sample interval counter
-	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,	// lower 16 bits of delay interval counter
-	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	// upper 8 bits of delay interval counter
-	ADC_COUNT_LOWER_REG = 0x1e,	// lower 16 bits of hardware conversion/scan counter
-	ADC_COUNT_UPPER_REG = 0x20,	// upper 8 bits of hardware conversion/scan counter
-	ADC_START_REG = 0x22,	// software trigger to start aquisition
-	ADC_CONVERT_REG = 0x24,	// initiates single conversion
-	ADC_QUEUE_CLEAR_REG = 0x26,	// clears adc queue
-	ADC_QUEUE_LOAD_REG = 0x28,	// loads adc queue
+	ADC_SAMPLE_INTERVAL_LOWER_REG = 0x16,	/*  lower 16 bits of adc sample interval counter */
+	ADC_SAMPLE_INTERVAL_UPPER_REG = 0x18,	/*  upper 8 bits of adc sample interval counter */
+	ADC_DELAY_INTERVAL_LOWER_REG = 0x1a,	/*  lower 16 bits of delay interval counter */
+	ADC_DELAY_INTERVAL_UPPER_REG = 0x1c,	/*  upper 8 bits of delay interval counter */
+	ADC_COUNT_LOWER_REG = 0x1e,	/*  lower 16 bits of hardware conversion/scan counter */
+	ADC_COUNT_UPPER_REG = 0x20,	/*  upper 8 bits of hardware conversion/scan counter */
+	ADC_START_REG = 0x22,	/*  software trigger to start aquisition */
+	ADC_CONVERT_REG = 0x24,	/*  initiates single conversion */
+	ADC_QUEUE_CLEAR_REG = 0x26,	/*  clears adc queue */
+	ADC_QUEUE_LOAD_REG = 0x28,	/*  loads adc queue */
 	ADC_BUFFER_CLEAR_REG = 0x2a,
-	ADC_QUEUE_HIGH_REG = 0x2c,	// high channel for internal queue, use adc_chan_bits() inline above
-	DAC_CONTROL0_REG = 0x50,	// dac control register 0
-	DAC_CONTROL1_REG = 0x52,	// dac control register 0
-	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,	// lower 16 bits of dac sample interval counter
-	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,	// upper 8 bits of dac sample interval counter
+	ADC_QUEUE_HIGH_REG = 0x2c,	/*  high channel for internal queue, use adc_chan_bits() inline above */
+	DAC_CONTROL0_REG = 0x50,	/*  dac control register 0 */
+	DAC_CONTROL1_REG = 0x52,	/*  dac control register 0 */
+	DAC_SAMPLE_INTERVAL_LOWER_REG = 0x54,	/*  lower 16 bits of dac sample interval counter */
+	DAC_SAMPLE_INTERVAL_UPPER_REG = 0x56,	/*  upper 8 bits of dac sample interval counter */
 	DAC_SELECT_REG = 0x60,
 	DAC_START_REG = 0x64,
-	DAC_BUFFER_CLEAR_REG = 0x66,	// clear dac buffer
+	DAC_BUFFER_CLEAR_REG = 0x66,	/*  clear dac buffer */
 };
 static inline unsigned int dac_convert_reg(unsigned int channel)
 {
@@ -161,7 +161,7 @@ static inline unsigned int dac_msb_4020_reg(unsigned int channel)
 }
 
 enum read_only_registers {
-	HW_STATUS_REG = 0x0,	// hardware status register, reading this apparently clears pending interrupts as well
+	HW_STATUS_REG = 0x0,	/*  hardware status register, reading this apparently clears pending interrupts as well */
 	PIPE1_READ_REG = 0x4,
 	ADC_READ_PNTR_REG = 0x8,
 	LOWER_XFER_REG = 0x10,
@@ -170,13 +170,13 @@ enum read_only_registers {
 };
 
 enum read_write_registers {
-	I8255_4020_REG = 0x48,	// 8255 offset, for 4020 only
-	ADC_QUEUE_FIFO_REG = 0x100,	// external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG
+	I8255_4020_REG = 0x48,	/*  8255 offset, for 4020 only */
+	ADC_QUEUE_FIFO_REG = 0x100,	/*  external channel/gain queue, uses same bits as ADC_QUEUE_LOAD_REG */
 	ADC_FIFO_REG = 0x200,	/* adc data fifo */
 	DAC_FIFO_REG = 0x300,	/* dac data fifo, has weird interactions with external channel queue */
 };
 
-// priv(dev)-&gt;dio_counter_iobase registers
+/* priv(dev)-&gt;dio_counter_iobase registers */
 enum dio_counter_registers {
 	DIO_8255_OFFSET = 0x0,
 	DO_REG = 0x20,
@@ -185,47 +185,47 @@ enum dio_counter_registers {
 	DIO_DATA_60XX_REG = 0x48,
 };
 
-// bit definitions for write-only registers
+/* bit definitions for write-only registers */
 
 enum intr_enable_contents {
-	ADC_INTR_SRC_MASK = 0x3,	// bits that set adc interrupt source
-	ADC_INTR_QFULL_BITS = 0x0,	// interrupt fifo quater full
-	ADC_INTR_EOC_BITS = 0x1,	// interrupt end of conversion
-	ADC_INTR_EOSCAN_BITS = 0x2,	// interrupt end of scan
-	ADC_INTR_EOSEQ_BITS = 0x3,	// interrupt end of sequence (probably wont use this it's pretty fancy)
-	EN_ADC_INTR_SRC_BIT = 0x4,	// enable adc interrupt source
-	EN_ADC_DONE_INTR_BIT = 0x8,	// enable adc aquisition done interrupt
+	ADC_INTR_SRC_MASK = 0x3,	/*  bits that set adc interrupt source */
+	ADC_INTR_QFULL_BITS = 0x0,	/*  interrupt fifo quater full */
+	ADC_INTR_EOC_BITS = 0x1,	/*  interrupt end of conversion */
+	ADC_INTR_EOSCAN_BITS = 0x2,	/*  interrupt end of scan */
+	ADC_INTR_EOSEQ_BITS = 0x3,	/*  interrupt end of sequence (probably wont use this it's pretty fancy) */
+	EN_ADC_INTR_SRC_BIT = 0x4,	/*  enable adc interrupt source */
+	EN_ADC_DONE_INTR_BIT = 0x8,	/*  enable adc aquisition done interrupt */
 	DAC_INTR_SRC_MASK = 0x30,
 	DAC_INTR_QEMPTY_BITS = 0x0,
 	DAC_INTR_HIGH_CHAN_BITS = 0x10,
-	EN_DAC_INTR_SRC_BIT = 0x40,	// enable dac interrupt source
+	EN_DAC_INTR_SRC_BIT = 0x40,	/*  enable dac interrupt source */
 	EN_DAC_DONE_INTR_BIT = 0x80,
-	EN_ADC_ACTIVE_INTR_BIT = 0x200,	// enable adc active interrupt
-	EN_ADC_STOP_INTR_BIT = 0x400,	// enable adc stop trigger interrupt
-	EN_DAC_ACTIVE_INTR_BIT = 0x800,	// enable dac active interrupt
-	EN_DAC_UNDERRUN_BIT = 0x4000,	// enable dac underrun status bit
-	EN_ADC_OVERRUN_BIT = 0x8000,	// enable adc overrun status bit
+	EN_ADC_ACTIVE_INTR_BIT = 0x200,	/*  enable adc active interrupt */
+	EN_ADC_STOP_INTR_BIT = 0x400,	/*  enable adc stop trigger interrupt */
+	EN_DAC_ACTIVE_INTR_BIT = 0x800,	/*  enable dac active interrupt */
+	EN_DAC_UNDERRUN_BIT = 0x4000,	/*  enable dac underrun status bit */
+	EN_ADC_OVERRUN_BIT = 0x8000,	/*  enable adc overrun status bit */
 };
 
 enum hw_config_contents {
-	MASTER_CLOCK_4020_MASK = 0x3,	// bits that specify master clock source for 4020
-	INTERNAL_CLOCK_4020_BITS = 0x1,	// use 40 MHz internal master clock for 4020
-	BNC_CLOCK_4020_BITS = 0x2,	// use BNC input for master clock
-	EXT_CLOCK_4020_BITS = 0x3,	// use dio input for master clock
-	EXT_QUEUE_BIT = 0x200,	// use external channel/gain queue (more versatile than internal queue)
-	SLOW_DAC_BIT = 0x400,	// use 225 nanosec strobe when loading dac instead of 50 nanosec
-	HW_CONFIG_DUMMY_BITS = 0x2000,	// bit with unknown function yet given as default value in pci-das64 manual
-	DMA_CH_SELECT_BIT = 0x8000,	// bit selects channels 1/0 for analog input/output, otherwise 0/1
-	FIFO_SIZE_REG = 0x4,	// allows adjustment of fifo sizes
-	DAC_FIFO_SIZE_MASK = 0xff00,	// bits that set dac fifo size
+	MASTER_CLOCK_4020_MASK = 0x3,	/*  bits that specify master clock source for 4020 */
+	INTERNAL_CLOCK_4020_BITS = 0x1,	/*  use 40 MHz internal master clock for 4020 */
+	BNC_CLOCK_4020_BITS = 0x2,	/*  use BNC input for master clock */
+	EXT_CLOCK_4020_BITS = 0x3,	/*  use dio input for master clock */
+	EXT_QUEUE_BIT = 0x200,	/*  use external channel/gain queue (more versatile than internal queue) */
+	SLOW_DAC_BIT = 0x400,	/*  use 225 nanosec strobe when loading dac instead of 50 nanosec */
+	HW_CONFIG_DUMMY_BITS = 0x2000,	/*  bit with unknown function yet given as default value in pci-das64 manual */
+	DMA_CH_SELECT_BIT = 0x8000,	/*  bit selects channels 1/0 for analog input/output, otherwise 0/1 */
+	FIFO_SIZE_REG = 0x4,	/*  allows adjustment of fifo sizes */
+	DAC_FIFO_SIZE_MASK = 0xff00,	/*  bits that set dac fifo size */
 	DAC_FIFO_BITS = 0xf800,	/* 8k sample ao fifo */
 };
 #define DAC_FIFO_SIZE 0x2000
 
 enum daq_atrig_low_4020_contents {
-	EXT_AGATE_BNC_BIT = 0x8000,	// use trig/ext clk bnc input for analog gate signal
-	EXT_STOP_TRIG_BNC_BIT = 0x4000,	// use trig/ext clk bnc input for external stop trigger signal
-	EXT_START_TRIG_BNC_BIT = 0x2000,	// use trig/ext clk bnc input for external start trigger signal
+	EXT_AGATE_BNC_BIT = 0x8000,	/*  use trig/ext clk bnc input for analog gate signal */
+	EXT_STOP_TRIG_BNC_BIT = 0x4000,	/*  use trig/ext clk bnc input for external stop trigger signal */
+	EXT_START_TRIG_BNC_BIT = 0x2000,	/*  use trig/ext clk bnc input for external start trigger signal */
 };
 static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
 {
@@ -233,34 +233,34 @@ static inline uint16_t analog_trig_low_threshold_bits(uint16_t threshold)
 }
 
 enum adc_control0_contents {
-	ADC_GATE_SRC_MASK = 0x3,	// bits that select gate
-	ADC_SOFT_GATE_BITS = 0x1,	// software gate
-	ADC_EXT_GATE_BITS = 0x2,	// external digital gate
-	ADC_ANALOG_GATE_BITS = 0x3,	// analog level gate
-	ADC_GATE_LEVEL_BIT = 0x4,	// level-sensitive gate (for digital)
-	ADC_GATE_POLARITY_BIT = 0x8,	// gate active low
+	ADC_GATE_SRC_MASK = 0x3,	/*  bits that select gate */
+	ADC_SOFT_GATE_BITS = 0x1,	/*  software gate */
+	ADC_EXT_GATE_BITS = 0x2,	/*  external digital gate */
+	ADC_ANALOG_GATE_BITS = 0x3,	/*  analog level gate */
+	ADC_GATE_LEVEL_BIT = 0x4,	/*  level-sensitive gate (for digital) */
+	ADC_GATE_POLARITY_BIT = 0x8,	/*  gate active low */
 	ADC_START_TRIG_SOFT_BITS = 0x10,
 	ADC_START_TRIG_EXT_BITS = 0x20,
 	ADC_START_TRIG_ANALOG_BITS = 0x30,
 	ADC_START_TRIG_MASK = 0x30,
-	ADC_START_TRIG_FALLING_BIT = 0x40,	// trig 1 uses falling edge
-	ADC_EXT_CONV_FALLING_BIT = 0x800,	// external pacing uses falling edge
-	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,	// enable hardware scan counter
-	ADC_DMA_DISABLE_BIT = 0x4000,	// disables dma
-	ADC_ENABLE_BIT = 0x8000,	// master adc enable
+	ADC_START_TRIG_FALLING_BIT = 0x40,	/*  trig 1 uses falling edge */
+	ADC_EXT_CONV_FALLING_BIT = 0x800,	/*  external pacing uses falling edge */
+	ADC_SAMPLE_COUNTER_EN_BIT = 0x1000,	/*  enable hardware scan counter */
+	ADC_DMA_DISABLE_BIT = 0x4000,	/*  disables dma */
+	ADC_ENABLE_BIT = 0x8000,	/*  master adc enable */
 };
 
 enum adc_control1_contents {
-	ADC_QUEUE_CONFIG_BIT = 0x1,	// should be set for boards with &gt; 16 channels
+	ADC_QUEUE_CONFIG_BIT = 0x1,	/*  should be set for boards with &gt; 16 channels */
 	CONVERT_POLARITY_BIT = 0x10,
 	EOC_POLARITY_BIT = 0x20,
-	ADC_SW_GATE_BIT = 0x40,	// software gate of adc
-	ADC_DITHER_BIT = 0x200,	// turn on extra noise for dithering
+	ADC_SW_GATE_BIT = 0x40,	/*  software gate of adc */
+	ADC_DITHER_BIT = 0x200,	/*  turn on extra noise for dithering */
 	RETRIGGER_BIT = 0x800,
 	ADC_LO_CHANNEL_4020_MASK = 0x300,
 	ADC_HI_CHANNEL_4020_MASK = 0xc00,
-	TWO_CHANNEL_4020_BITS = 0x1000,	// two channel mode for 4020
-	FOUR_CHANNEL_4020_BITS = 0x2000,	// four channel mode for 4020
+	TWO_CHANNEL_4020_BITS = 0x1000,	/*  two channel mode for 4020 */
+	FOUR_CHANNEL_4020_BITS = 0x2000,	/*  four channel mode for 4020 */
 	CHANNEL_MODE_4020_MASK = 0x3000,
 	ADC_MODE_MASK = 0xf000,
 };
@@ -281,10 +281,10 @@ enum calibration_contents {
 	SELECT_8800_BIT = 0x1,
 	SELECT_8402_64XX_BIT = 0x2,
 	SELECT_1590_60XX_BIT = 0x2,
-	CAL_EN_64XX_BIT = 0x40,	// calibration enable for 64xx series
+	CAL_EN_64XX_BIT = 0x40,	/*  calibration enable for 64xx series */
 	SERIAL_DATA_IN_BIT = 0x80,
 	SERIAL_CLOCK_BIT = 0x100,
-	CAL_EN_60XX_BIT = 0x200,	// calibration enable for 60xx series
+	CAL_EN_60XX_BIT = 0x200,	/*  calibration enable for 60xx series */
 	CAL_GAIN_BIT = 0x800,
 };
 /* calibration sources for 6025 are:
@@ -308,11 +308,11 @@ static inline uint16_t adc_convert_chan_4020_bits(unsigned int channel)
 };
 
 enum adc_queue_load_contents {
-	UNIP_BIT = 0x800,	// unipolar/bipolar bit
-	ADC_SE_DIFF_BIT = 0x1000,	// single-ended/ differential bit
-	ADC_COMMON_BIT = 0x2000,	// non-referenced single-ended (common-mode input)
-	QUEUE_EOSEQ_BIT = 0x4000,	// queue end of sequence
-	QUEUE_EOSCAN_BIT = 0x8000,	// queue end of scan
+	UNIP_BIT = 0x800,	/*  unipolar/bipolar bit */
+	ADC_SE_DIFF_BIT = 0x1000,	/*  single-ended/ differential bit */
+	ADC_COMMON_BIT = 0x2000,	/*  non-referenced single-ended (common-mode input) */
+	QUEUE_EOSEQ_BIT = 0x4000,	/*  queue end of sequence */
+	QUEUE_EOSCAN_BIT = 0x8000,	/*  queue end of scan */
 };
 static inline uint16_t adc_chan_bits(unsigned int channel)
 {
@@ -320,7 +320,7 @@ static inline uint16_t adc_chan_bits(unsigned int channel)
 };
 
 enum dac_control0_contents {
-	DAC_ENABLE_BIT = 0x8000,	// dac controller enable bit
+	DAC_ENABLE_BIT = 0x8000,	/*  dac controller enable bit */
 	DAC_CYCLIC_STOP_BIT = 0x4000,
 	DAC_WAVEFORM_MODE_BIT = 0x100,
 	DAC_EXT_UPDATE_FALLING_BIT = 0x80,
@@ -340,14 +340,14 @@ enum dac_control1_contents {
 	DAC_WRITE_POLARITY_BIT = 0x800,	/* board-dependent setting */
 	DAC1_EXT_REF_BIT = 0x200,
 	DAC0_EXT_REF_BIT = 0x100,
-	DAC_OUTPUT_ENABLE_BIT = 0x80,	// dac output enable bit
+	DAC_OUTPUT_ENABLE_BIT = 0x80,	/*  dac output enable bit */
 	DAC_UPDATE_POLARITY_BIT = 0x40,	/* board-dependent setting */
 	DAC_SW_GATE_BIT = 0x20,
 	DAC1_UNIPOLAR_BIT = 0x8,
 	DAC0_UNIPOLAR_BIT = 0x2,
 };
 
-// bit definitions for read-only registers
+/* bit definitions for read-only registers */
 enum hw_status_contents {
 	DAC_UNDERRUN_BIT = 0x1,
 	ADC_OVERRUN_BIT = 0x2,
@@ -378,7 +378,7 @@ static inline unsigned int adc_upper_write_ptr_code(uint16_t prepost_bits)
 	return (prepost_bits &gt;&gt; 14) &amp; 0x3;
 }
 
-// I2C addresses for 4020
+/* I2C addresses for 4020 */
 enum i2c_addresses {
 	RANGE_CAL_I2C_ADDR = 0x20,
 	CALDAC0_I2C_ADDR = 0xc,
@@ -386,8 +386,8 @@ enum i2c_addresses {
 };
 
 enum range_cal_i2c_contents {
-	ADC_SRC_4020_MASK = 0x70,	// bits that set what source the adc converter measures
-	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,	// make bnc trig/ext clock threshold 0V instead of 2.5V
+	ADC_SRC_4020_MASK = 0x70,	/*  bits that set what source the adc converter measures */
+	BNC_TRIG_THRESHOLD_0V_BIT = 0x80,	/*  make bnc trig/ext clock threshold 0V instead of 2.5V */
 };
 static inline uint8_t adc_src_4020_bits(unsigned int source)
 {
@@ -395,11 +395,11 @@ static inline uint8_t adc_src_4020_bits(unsigned int source)
 };
 static inline uint8_t attenuate_bit(unsigned int channel)
 {
-	// attenuate channel (+-5V input range)
+	/*  attenuate channel (+-5V input range) */
 	return 1 &lt;&lt; (channel &amp; 0x3);
 };
 
-// analog input ranges for 64xx boards
+/* analog input ranges for 64xx boards */
 static const struct comedi_lrange ai_ranges_64xx = {
 	8,
 	{
@@ -468,7 +468,7 @@ static const struct comedi_lrange ai_ranges_6052 = {
 		}
 };
 
-// analog input ranges for 4020 board
+/* analog input ranges for 4020 board */
 static const struct comedi_lrange ai_ranges_4020 = {
 	2,
 	{
@@ -477,7 +477,7 @@ static const struct comedi_lrange ai_ranges_4020 = {
 		}
 };
 
-// analog output ranges
+/* analog output ranges */
 static const struct comedi_lrange ao_ranges_64xx = {
 	4,
 	{
@@ -543,18 +543,18 @@ struct hw_fifo_info {
 
 struct pcidas64_board {
 	const char *name;
-	int device_id;		// pci device id
-	int ai_se_chans;	// number of ai inputs in single-ended mode
-	int ai_bits;		// analog input resolution
-	int ai_speed;		// fastest conversion period in ns
+	int device_id;		/*  pci device id */
+	int ai_se_chans;	/*  number of ai inputs in single-ended mode */
+	int ai_bits;		/*  analog input resolution */
+	int ai_speed;		/*  fastest conversion period in ns */
 	const struct comedi_lrange *ai_range_table;
-	int ao_nchan;		// number of analog out channels
-	int ao_bits;		// analog output resolution
-	int ao_scan_speed;	// analog output speed (for a scan, not conversion)
+	int ao_nchan;		/*  number of analog out channels */
+	int ao_bits;		/*  analog output resolution */
+	int ao_scan_speed;	/*  analog output speed (for a scan, not conversion) */
 	const struct comedi_lrange *ao_range_table;
 	const int *ao_range_code;
 	const struct hw_fifo_info *const ai_fifo;
-	enum register_layout layout;	// different board families have slightly different registers
+	enum register_layout layout;	/*  different board families have slightly different registers */
 	unsigned has_8255:1;
 };
 
@@ -612,7 +612,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	      has_8255:1,
 		},
 	{
-	      name:	"pci-das6402/12",	// XXX check
+	      name:	"pci-das6402/12",	/*  XXX check */
 	      device_id:0x1e,
 	      ai_se_chans:64,
 	      ai_bits:	12,
@@ -910,7 +910,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 	      ai_speed:50,
 	      ao_bits:	12,
 	      ao_nchan:2,
-	      ao_scan_speed:0,	// no hardware pacing on ao
+	      ao_scan_speed:0,	/*  no hardware pacing on ao */
 	      layout:	LAYOUT_4020,
 	      ai_range_table:&amp;ai_ranges_4020,
 	      ao_range_table:&amp;ao_ranges_4020,
@@ -921,7 +921,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 #if 0
 	{
 	      name:	"pci-das6402/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:5000,
@@ -934,7 +934,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m1/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:1000,
@@ -947,7 +947,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m2/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:500,
@@ -960,7 +960,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m3/16/jr",
-	      device_id:0	// XXX,
+	      device_id:0	/*  XXX, */
 	      ai_se_chans:64,
 	      ai_bits:	16,
 	      ai_speed:333,
@@ -973,7 +973,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m1/14",
-	      device_id:0,	// XXX
+	      device_id:0,	/*  XXX */
 	      ai_se_chans:64,
 	      ai_bits:	14,
 	      ai_speed:1000,
@@ -986,7 +986,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m2/14",
-	      device_id:0,	// XXX
+	      device_id:0,	/*  XXX */
 	      ai_se_chans:64,
 	      ai_bits:	14,
 	      ai_speed:500,
@@ -999,7 +999,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 		},
 	{
 	      name:	"pci-das64/m3/14",
-	      device_id:0,	// XXX
+	      device_id:0,	/*  XXX */
 	      ai_se_chans:64,
 	      ai_bits:	14,
 	      ai_speed:333,
@@ -1013,7 +1013,7 @@ static const struct pcidas64_board pcidas64_boards[] = {
 #endif
 };
 
-// Number of boards in cb_pcidas_boards
+/* Number of boards in cb_pcidas_boards */
 static inline unsigned int num_boards(void)
 {
 	return sizeof(pcidas64_boards) / sizeof(struct pcidas64_board);
@@ -1060,50 +1060,50 @@ static inline unsigned short se_diff_bit_6xxx(struct comedi_device * dev,
 };
 
 struct ext_clock_info {
-	unsigned int divisor;	// master clock divisor to use for scans with external master clock
-	unsigned int chanspec;	// chanspec for master clock input when used as scan begin src
+	unsigned int divisor;	/*  master clock divisor to use for scans with external master clock */
+	unsigned int chanspec;	/*  chanspec for master clock input when used as scan begin src */
 };
 
 /* this structure is for data unique to this hardware driver. */
 struct pcidas64_private {
 
-	struct pci_dev *hw_dev;	// pointer to board's pci_dev struct
-	// base addresses (physical)
+	struct pci_dev *hw_dev;	/*  pointer to board's pci_dev struct */
+	/*  base addresses (physical) */
 	resource_size_t plx9080_phys_iobase;
 	resource_size_t main_phys_iobase;
 	resource_size_t dio_counter_phys_iobase;
-	// base addresses (ioremapped)
+	/*  base addresses (ioremapped) */
 	void *plx9080_iobase;
 	void *main_iobase;
 	void *dio_counter_iobase;
-	// local address (used by dma controller)
+	/*  local address (used by dma controller) */
 	uint32_t local0_iobase;
 	uint32_t local1_iobase;
-	volatile unsigned int ai_count;	// number of analog input samples remaining
-	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];	// dma buffers for analog input
-	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];	// physical addresses of ai dma buffers
-	struct plx_dma_desc *ai_dma_desc;	// array of ai dma descriptors read by plx9080, allocated to get proper alignment
-	dma_addr_t ai_dma_desc_bus_addr;	// physical address of ai dma descriptor array
-	volatile unsigned int ai_dma_index;	// index of the ai dma descriptor/buffer that is currently being used
-	uint16_t *ao_buffer[AO_DMA_RING_COUNT];	// dma buffers for analog output
-	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];	// physical addresses of ao dma buffers
+	volatile unsigned int ai_count;	/*  number of analog input samples remaining */
+	uint16_t *ai_buffer[MAX_AI_DMA_RING_COUNT];	/*  dma buffers for analog input */
+	dma_addr_t ai_buffer_bus_addr[MAX_AI_DMA_RING_COUNT];	/*  physical addresses of ai dma buffers */
+	struct plx_dma_desc *ai_dma_desc;	/*  array of ai dma descriptors read by plx9080, allocated to get proper alignment */
+	dma_addr_t ai_dma_desc_bus_addr;	/*  physical address of ai dma descriptor array */
+	volatile unsigned int ai_dma_index;	/*  index of the ai dma descriptor/buffer that is currently being used */
+	uint16_t *ao_buffer[AO_DMA_RING_COUNT];	/*  dma buffers for analog output */
+	dma_addr_t ao_buffer_bus_addr[AO_DMA_RING_COUNT];	/*  physical addresses of ao dma buffers */
 	struct plx_dma_desc *ao_dma_desc;
 	dma_addr_t ao_dma_desc_bus_addr;
-	volatile unsigned int ao_dma_index;	// keeps track of buffer where the next ao sample should go
-	volatile unsigned long ao_count;	// number of analog output samples remaining
-	volatile unsigned int ao_value[2];	// remember what the analog outputs are set to, to allow readback
-	unsigned int hw_revision;	// stc chip hardware revision number
-	volatile unsigned int intr_enable_bits;	// last bits sent to INTR_ENABLE_REG register
-	volatile uint16_t adc_control1_bits;	// last bits sent to ADC_CONTROL1_REG register
-	volatile uint16_t fifo_size_bits;	// last bits sent to FIFO_SIZE_REG register
-	volatile uint16_t hw_config_bits;	// last bits sent to HW_CONFIG_REG register
+	volatile unsigned int ao_dma_index;	/*  keeps track of buffer where the next ao sample should go */
+	volatile unsigned long ao_count;	/*  number of analog output samples remaining */
+	volatile unsigned int ao_value[2];	/*  remember what the analog outputs are set to, to allow readback */
+	unsigned int hw_revision;	/*  stc chip hardware revision number */
+	volatile unsigned int intr_enable_bits;	/*  last bits sent to INTR_ENABLE_REG register */
+	volatile uint16_t adc_control1_bits;	/*  last bits sent to ADC_CONTROL1_REG register */
+	volatile uint16_t fifo_size_bits;	/*  last bits sent to FIFO_SIZE_REG register */
+	volatile uint16_t hw_config_bits;	/*  last bits sent to HW_CONFIG_REG register */
 	volatile uint16_t dac_control1_bits;
-	volatile uint32_t plx_control_bits;	// last bits written to plx9080 control register
-	volatile uint32_t plx_intcsr_bits;	// last bits written to plx interrupt control and status register
-	volatile int calibration_source;	// index of calibration source readable through ai ch0
-	volatile uint8_t i2c_cal_range_bits;	// bits written to i2c calibration/range register
-	volatile unsigned int ext_trig_falling;	// configure digital triggers to trigger on falling edge
-	// states of various devices stored to enable read-back
+	volatile uint32_t plx_control_bits;	/*  last bits written to plx9080 control register */
+	volatile uint32_t plx_intcsr_bits;	/*  last bits written to plx interrupt control and status register */
+	volatile int calibration_source;	/*  index of calibration source readable through ai ch0 */
+	volatile uint8_t i2c_cal_range_bits;	/*  bits written to i2c calibration/range register */
+	volatile unsigned int ext_trig_falling;	/*  configure digital triggers to trigger on falling edge */
+	/*  states of various devices stored to enable read-back */
 	unsigned int ad8402_state[2];
 	unsigned int caldac_state[8];
 	volatile short ai_cmd_running;
@@ -1185,7 +1185,7 @@ static void caldac_write(struct comedi_device * dev, unsigned int channel,
 	unsigned int value);
 static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	uint8_t value);
-//static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b);
+/* static int dac_1590_write(struct comedi_device *dev, unsigned int dac_a, unsigned int dac_b); */
 static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
 	unsigned int value);
 static void abort_dma(struct comedi_device * dev, unsigned int channel);
@@ -1274,7 +1274,7 @@ static inline int ao_cmd_is_supported(const struct pcidas64_board * board)
 	return board-&gt;ao_nchan &amp;&amp; board-&gt;layout != LAYOUT_4020;
 }
 
-// initialize plx9080 chip
+/* initialize plx9080 chip */
 static void init_plx9080(struct comedi_device * dev)
 {
 	uint32_t bits;
@@ -1283,7 +1283,7 @@ static void init_plx9080(struct comedi_device * dev)
 	priv(dev)-&gt;plx_control_bits =
 		readl(priv(dev)-&gt;plx9080_iobase + PLX_CONTROL_REG);
 
-	// plx9080 dump
+	/*  plx9080 dump */
 	DEBUG_PRINT(" plx interrupt status 0x%x\n",
 		readl(plx_iobase + PLX_INTRCS_REG));
 	DEBUG_PRINT(" plx id bits 0x%x\n", readl(plx_iobase + PLX_ID_REG));
@@ -1327,35 +1327,35 @@ static void init_plx9080(struct comedi_device * dev)
 	abort_dma(dev, 0);
 	abort_dma(dev, 1);
 
-	// configure dma0 mode
+	/*  configure dma0 mode */
 	bits = 0;
-	// enable ready input, not sure if this is necessary
+	/*  enable ready input, not sure if this is necessary */
 	bits |= PLX_DMA_EN_READYIN_BIT;
-	// enable bterm, not sure if this is necessary
+	/*  enable bterm, not sure if this is necessary */
 	bits |= PLX_EN_BTERM_BIT;
-	// enable dma chaining
+	/*  enable dma chaining */
 	bits |= PLX_EN_CHAIN_BIT;
-	// enable interrupt on dma done (probably don't need this, since chain never finishes)
+	/*  enable interrupt on dma done (probably don't need this, since chain never finishes) */
 	bits |= PLX_EN_DMA_DONE_INTR_BIT;
-	// don't increment local address during transfers (we are transferring from a fixed fifo register)
+	/*  don't increment local address during transfers (we are transferring from a fixed fifo register) */
 	bits |= PLX_LOCAL_ADDR_CONST_BIT;
-	// route dma interrupt to pci bus
+	/*  route dma interrupt to pci bus */
 	bits |= PLX_DMA_INTR_PCI_BIT;
-	// enable demand mode
+	/*  enable demand mode */
 	bits |= PLX_DEMAND_MODE_BIT;
-	// enable local burst mode
+	/*  enable local burst mode */
 	bits |= PLX_DMA_LOCAL_BURST_EN_BIT;
-	// 4020 uses 32 bit dma
+	/*  4020 uses 32 bit dma */
 	if (board(dev)-&gt;layout == LAYOUT_4020) {
 		bits |= PLX_LOCAL_BUS_32_WIDE_BITS;
-	} else {		// localspace0 bus is 16 bits wide
+	} else {		/*  localspace0 bus is 16 bits wide */
 		bits |= PLX_LOCAL_BUS_16_WIDE_BITS;
 	}
 	writel(bits, plx_iobase + PLX_DMA1_MODE_REG);
 	if (ao_cmd_is_supported(board(dev)))
 		writel(bits, plx_iobase + PLX_DMA0_MODE_REG);
 
-	// enable interrupts on plx 9080
+	/*  enable interrupts on plx 9080 */
 	priv(dev)-&gt;plx_intcsr_bits |=
 		ICS_AERR | ICS_PERR | ICS_PIE | ICS_PLIE | ICS_PAIE | ICS_LIE |
 		ICS_DMA0_E | ICS_DMA1_E;
@@ -1396,9 +1396,9 @@ static int setup_subdevices(struct comedi_device * dev)
 	if (board(dev)-&gt;layout == LAYOUT_4020) {
 		unsigned int i;
 		uint8_t data;
-		// set adc to read from inputs (not internal calibration sources)
+		/*  set adc to read from inputs (not internal calibration sources) */
 		priv(dev)-&gt;i2c_cal_range_bits = adc_src_4020_bits(4);
-		// set channels to +-5 volt input ranges
+		/*  set channels to +-5 volt input ranges */
 		for (i = 0; i &lt; s-&gt;n_chan; i++)
 			priv(dev)-&gt;i2c_cal_range_bits |= attenuate_bit(i);
 		data = priv(dev)-&gt;i2c_cal_range_bits;
@@ -1428,7 +1428,7 @@ static int setup_subdevices(struct comedi_device * dev)
 		s-&gt;type = COMEDI_SUBD_UNUSED;
 	}
 
-	// digital input
+	/*  digital input */
 	s = dev-&gt;subdevices + 2;
 	if (board(dev)-&gt;layout == LAYOUT_64XX) {
 		s-&gt;type = COMEDI_SUBD_DI;
@@ -1440,7 +1440,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s-&gt;type = COMEDI_SUBD_UNUSED;
 
-	// digital output
+	/*  digital output */
 	if (board(dev)-&gt;layout == LAYOUT_64XX) {
 		s = dev-&gt;subdevices + 3;
 		s-&gt;type = COMEDI_SUBD_DO;
@@ -1469,7 +1469,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s-&gt;type = COMEDI_SUBD_UNUSED;
 
-	// 8 channel dio for 60xx
+	/*  8 channel dio for 60xx */
 	s = dev-&gt;subdevices + 5;
 	if (board(dev)-&gt;layout == LAYOUT_60XX) {
 		s-&gt;type = COMEDI_SUBD_DIO;
@@ -1482,7 +1482,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s-&gt;type = COMEDI_SUBD_UNUSED;
 
-	// caldac
+	/*  caldac */
 	s = dev-&gt;subdevices + 6;
 	s-&gt;type = COMEDI_SUBD_CALIB;
 	s-&gt;subdev_flags = SDF_READABLE | SDF_WRITABLE | SDF_INTERNAL;
@@ -1496,7 +1496,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	for (i = 0; i &lt; s-&gt;n_chan; i++)
 		caldac_write(dev, i, s-&gt;maxdata / 2);
 
-	// 2 channel ad8402 potentiometer
+	/*  2 channel ad8402 potentiometer */
 	s = dev-&gt;subdevices + 7;
 	if (board(dev)-&gt;layout == LAYOUT_64XX) {
 		s-&gt;type = COMEDI_SUBD_CALIB;
@@ -1510,7 +1510,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s-&gt;type = COMEDI_SUBD_UNUSED;
 
-	//serial EEPROM, if present
+	/* serial EEPROM, if present */
 	s = dev-&gt;subdevices + 8;
 	if (readl(priv(dev)-&gt;plx9080_iobase + PLX_CONTROL_REG) &amp; CTL_EECHK) {
 		s-&gt;type = COMEDI_SUBD_MEMORY;
@@ -1521,7 +1521,7 @@ static int setup_subdevices(struct comedi_device * dev)
 	} else
 		s-&gt;type = COMEDI_SUBD_UNUSED;
 
-	// user counter subd XXX
+	/*  user counter subd XXX */
 	s = dev-&gt;subdevices + 9;
 	s-&gt;type = COMEDI_SUBD_UNUSED;
 
@@ -1542,13 +1542,13 @@ static void init_stc_registers(struct comedi_device * dev)
 
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 
-	// bit should be set for 6025, although docs say boards with &lt;= 16 chans should be cleared XXX
+	/*  bit should be set for 6025, although docs say boards with &lt;= 16 chans should be cleared XXX */
 	if (1)
 		priv(dev)-&gt;adc_control1_bits |= ADC_QUEUE_CONFIG_BIT;
 	writew(priv(dev)-&gt;adc_control1_bits,
 		priv(dev)-&gt;main_iobase + ADC_CONTROL1_REG);
 
-	// 6402/16 manual says this register must be initialized to 0xff?
+	/*  6402/16 manual says this register must be initialized to 0xff? */
 	writew(0xff, priv(dev)-&gt;main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
 
 	bits = SLOW_DAC_BIT | DMA_CH_SELECT_BIT;
@@ -1563,7 +1563,7 @@ static void init_stc_registers(struct comedi_device * dev)
 
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// set fifos to maximum size
+	/*  set fifos to maximum size */
 	priv(dev)-&gt;fifo_size_bits |= DAC_FIFO_BITS;
 	set_ai_fifo_segment_length(dev,
 		board(dev)-&gt;ai_fifo-&gt;max_segment_length);
@@ -1581,7 +1581,7 @@ int alloc_and_init_dma_members(struct comedi_device * dev)
 {
 	int i;
 
-	// alocate pci dma buffers
+	/*  alocate pci dma buffers */
 	for (i = 0; i &lt; ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)-&gt;ai_buffer[i] =
 			pci_alloc_consistent(priv(dev)-&gt;hw_dev, DMA_BUFFER_SIZE,
@@ -1601,7 +1601,7 @@ int alloc_and_init_dma_members(struct comedi_device * dev)
 			}
 		}
 	}
-	// allocate dma descriptors
+	/*  allocate dma descriptors */
 	priv(dev)-&gt;ai_dma_desc =
 		pci_alloc_consistent(priv(dev)-&gt;hw_dev,
 		sizeof(struct plx_dma_desc) * ai_dma_ring_count(board(dev)),
@@ -1622,7 +1622,7 @@ int alloc_and_init_dma_members(struct comedi_device * dev)
 		DEBUG_PRINT("ao dma descriptors start at bus addr 0x%x\n",
 			priv(dev)-&gt;ao_dma_desc_bus_addr);
 	}
-	// initialize dma descriptors
+	/*  initialize dma descriptors */
 	for (i = 0; i &lt; ai_dma_ring_count(board(dev)); i++) {
 		priv(dev)-&gt;ai_dma_desc[i].pci_start_addr =
 			cpu_to_le32(priv(dev)-&gt;ai_buffer_bus_addr[i]);
@@ -1697,16 +1697,16 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	for (pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, NULL);
 		pcidev != NULL;
 		pcidev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pcidev)) {
-		// is it not a computer boards card?
+		/*  is it not a computer boards card? */
 		if (pcidev-&gt;vendor != PCI_VENDOR_ID_COMPUTERBOARDS)
 			continue;
-		// loop through cards supported by this driver
+		/*  loop through cards supported by this driver */
 		for (index = 0; index &lt; num_boards(); index++) {
 			if (pcidas64_boards[index].device_id != pcidev-&gt;device)
 				continue;
-			// was a particular bus/slot requested?
+			/*  was a particular bus/slot requested? */
 			if (it-&gt;options[0] || it-&gt;options[1]) {
-				// are we on the wrong bus/slot?
+				/*  are we on the wrong bus/slot? */
 				if (pcidev-&gt;bus-&gt;number != it-&gt;options[0] ||
 					PCI_SLOT(pcidev-&gt;devfn) !=
 					it-&gt;options[1]) {
@@ -1736,7 +1736,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	}
 	pci_set_master(pcidev);
 
-	//Initialize dev-&gt;board_name
+	/* Initialize dev-&gt;board_name */
 	dev-&gt;board_name = board(dev)-&gt;name;
 
 	priv(dev)-&gt;plx9080_phys_iobase =
@@ -1746,7 +1746,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	priv(dev)-&gt;dio_counter_phys_iobase =
 		pci_resource_start(pcidev, DIO_COUNTER_BADDRINDEX);
 
-	// remap, won't work with 2.0 kernels but who cares
+	/*  remap, won't work with 2.0 kernels but who cares */
 	priv(dev)-&gt;plx9080_iobase = ioremap(priv(dev)-&gt;plx9080_phys_iobase,
 		pci_resource_len(pcidev, PLX9080_BADDRINDEX));
 	priv(dev)-&gt;main_iobase = ioremap(priv(dev)-&gt;main_phys_iobase,
@@ -1766,7 +1766,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	DEBUG_PRINT(" diocounter remapped to 0x%p\n",
 		priv(dev)-&gt;dio_counter_iobase);
 
-	// figure out what local addresses are
+	/*  figure out what local addresses are */
 	local_range =
 		readl(priv(dev)-&gt;plx9080_iobase +
 		PLX_LAS0RNG_REG) &amp; LRNG_MEM_MASK;
@@ -1798,7 +1798,7 @@ static int attach(struct comedi_device *dev, struct comedi_devconfig *it)
 	printk(" stc hardware revision %i\n", priv(dev)-&gt;hw_revision);
 	init_plx9080(dev);
 	init_stc_registers(dev);
-	// get irq
+	/*  get irq */
 	if (comedi_request_irq(pcidev-&gt;irq, handle_interrupt, IRQF_SHARED,
 			"cb_pcidas64", dev)) {
 		printk(" unable to allocate irq %u\n", pcidev-&gt;irq);
@@ -1841,7 +1841,7 @@ static int detach(struct comedi_device * dev)
 				iounmap((void *)priv(dev)-&gt;main_iobase);
 			if (priv(dev)-&gt;dio_counter_iobase)
 				iounmap((void *)priv(dev)-&gt;dio_counter_iobase);
-			// free pci dma buffers
+			/*  free pci dma buffers */
 			for (i = 0; i &lt; ai_dma_ring_count(board(dev)); i++) {
 				if (priv(dev)-&gt;ai_buffer[i])
 					pci_free_consistent(priv(dev)-&gt;hw_dev,
@@ -1858,7 +1858,7 @@ static int detach(struct comedi_device * dev)
 						priv(dev)-&gt;
 						ao_buffer_bus_addr[i]);
 			}
-			// free dma descriptors
+			/*  free dma descriptors */
 			if (priv(dev)-&gt;ai_dma_desc)
 				pci_free_consistent(priv(dev)-&gt;hw_dev,
 					sizeof(struct plx_dma_desc) *
@@ -1896,8 +1896,8 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	range = CR_RANGE(insn-&gt;chanspec);
 	aref = CR_AREF(insn-&gt;chanspec);
 
-	// disable card's analog input interrupt sources and pacing
-	// 4020 generates dac done interrupts even though they are disabled
+	/*  disable card's analog input interrupt sources and pacing */
+	/*  4020 generates dac done interrupts even though they are disabled */
 	disable_ai_pacing(dev);
 
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
@@ -1910,12 +1910,12 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
 	if (board(dev)-&gt;layout != LAYOUT_4020) {
-		// use internal queue
+		/*  use internal queue */
 		priv(dev)-&gt;hw_config_bits &amp;= ~EXT_QUEUE_BIT;
 		writew(priv(dev)-&gt;hw_config_bits,
 			priv(dev)-&gt;main_iobase + HW_CONFIG_REG);
 
-		// ALT_SOURCE is internal calibration reference
+		/*  ALT_SOURCE is internal calibration reference */
 		if (insn-&gt;chanspec &amp; CR_ALT_SOURCE) {
 			unsigned int cal_en_bit;
 
@@ -1924,27 +1924,27 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 				cal_en_bit = CAL_EN_60XX_BIT;
 			else
 				cal_en_bit = CAL_EN_64XX_BIT;
-			// select internal reference source to connect to channel 0
+			/*  select internal reference source to connect to channel 0 */
 			writew(cal_en_bit | adc_src_bits(priv(dev)-&gt;
 					calibration_source),
 				priv(dev)-&gt;main_iobase + CALIBRATION_REG);
 		} else {
-			// make sure internal calibration source is turned off
+			/*  make sure internal calibration source is turned off */
 			writew(0, priv(dev)-&gt;main_iobase + CALIBRATION_REG);
 		}
-		// load internal queue
+		/*  load internal queue */
 		bits = 0;
-		// set gain
+		/*  set gain */
 		bits |= ai_range_bits_6xxx(dev, CR_RANGE(insn-&gt;chanspec));
-		// set single-ended / differential
+		/*  set single-ended / differential */
 		bits |= se_diff_bit_6xxx(dev, aref == AREF_DIFF);
 		if (aref == AREF_COMMON)
 			bits |= ADC_COMMON_BIT;
 		bits |= adc_chan_bits(channel);
-		// set stop channel
+		/*  set stop channel */
 		writew(adc_chan_bits(channel),
 			priv(dev)-&gt;main_iobase + ADC_QUEUE_HIGH_REG);
-		// set start channel, and rest of settings
+		/*  set start channel, and rest of settings */
 		writew(bits, priv(dev)-&gt;main_iobase + ADC_QUEUE_LOAD_REG);
 	} else {
 		uint8_t old_cal_range_bits = priv(dev)-&gt;i2c_cal_range_bits;
@@ -1955,16 +1955,16 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 			priv(dev)-&gt;i2c_cal_range_bits |=
 				adc_src_4020_bits(priv(dev)-&gt;
 				calibration_source);
-		} else {	//select BNC inputs
+		} else {	/* select BNC inputs */
 			priv(dev)-&gt;i2c_cal_range_bits |= adc_src_4020_bits(4);
 		}
-		// select range
+		/*  select range */
 		if (range == 0)
 			priv(dev)-&gt;i2c_cal_range_bits |= attenuate_bit(channel);
 		else
 			priv(dev)-&gt;i2c_cal_range_bits &amp;=
 				~attenuate_bit(channel);
-		// update calibration/range i2c register only if necessary, as it is very slow
+		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)-&gt;i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)-&gt;i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &amp;i2c_data,
@@ -1981,14 +1981,14 @@ static int ai_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 
 	for (n = 0; n &lt; insn-&gt;n; n++) {
 
-		// clear adc buffer (inside loop for 4020 sake)
+		/*  clear adc buffer (inside loop for 4020 sake) */
 		writew(0, priv(dev)-&gt;main_iobase + ADC_BUFFER_CLEAR_REG);
 
 		/* trigger conversion, bits sent only matter for 4020 */
 		writew(adc_convert_chan_4020_bits(CR_CHAN(insn-&gt;chanspec)),
 			priv(dev)-&gt;main_iobase + ADC_CONVERT_REG);
 
-		// wait for data
+		/*  wait for data */
 		for (i = 0; i &lt; timeout; i++) {
 			bits = readw(priv(dev)-&gt;main_iobase + HW_STATUS_REG);
 			DEBUG_PRINT(" pipe bits 0x%x\n", pipe_full_bits(bits));
@@ -2092,7 +2092,7 @@ static int ai_config_master_clock_4020(struct comedi_device * dev, unsigned int
 	return retval ? retval : 5;
 }
 
-// XXX could add support for 60xx series
+/* XXX could add support for 60xx series */
 static int ai_config_master_clock(struct comedi_device * dev, unsigned int * data)
 {
 
@@ -2182,7 +2182,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	// uniqueness check
+	/*  uniqueness check */
 	if (cmd-&gt;start_src != TRIG_NOW &amp;&amp; cmd-&gt;start_src != TRIG_EXT)
 		err++;
 	if (cmd-&gt;scan_begin_src != TRIG_TIMER &amp;&amp;
@@ -2196,7 +2196,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 		cmd-&gt;stop_src != TRIG_NONE &amp;&amp; cmd-&gt;stop_src != TRIG_EXT)
 		err++;
 
-	// compatibility check
+	/*  compatibility check */
 	if (cmd-&gt;convert_src == TRIG_EXT &amp;&amp; cmd-&gt;scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd-&gt;stop_src != TRIG_COUNT &amp;&amp;
@@ -2220,7 +2220,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 				err++;
 			}
 			if (cmd-&gt;scan_begin_src == TRIG_TIMER) {
-				// if scans are timed faster than conversion rate allows
+				/*  if scans are timed faster than conversion rate allows */
 				if (cmd-&gt;convert_arg * cmd-&gt;chanlist_len &gt;
 					cmd-&gt;scan_begin_arg) {
 					cmd-&gt;scan_begin_arg =
@@ -2278,7 +2278,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 	if (err)
 		return 4;
 
-	// make sure user is doesn't change analog reference mid chanlist
+	/*  make sure user is doesn't change analog reference mid chanlist */
 	if (cmd-&gt;chanlist) {
 		aref = CR_AREF(cmd-&gt;chanlist[0]);
 		for (i = 1; i &lt; cmd-&gt;chanlist_len; i++) {
@@ -2289,7 +2289,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 				break;
 			}
 		}
-		// check 4020 chanlist
+		/*  check 4020 chanlist */
 		if (board(dev)-&gt;layout == LAYOUT_4020) {
 			unsigned int first_channel = CR_CHAN(cmd-&gt;chanlist[0]);
 			for (i = 1; i &lt; cmd-&gt;chanlist_len; i++) {
@@ -2317,7 +2317,7 @@ static int ai_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 
 static int use_hw_sample_counter(struct comedi_cmd * cmd)
 {
-// disable for now until I work out a race
+/* disable for now until I work out a race */
 	return 0;
 
 	if (cmd-&gt;stop_src == TRIG_COUNT &amp;&amp; cmd-&gt;stop_arg &lt;= max_counter_value)
@@ -2329,10 +2329,10 @@ static int use_hw_sample_counter(struct comedi_cmd * cmd)
 static void setup_sample_counters(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	if (cmd-&gt;stop_src == TRIG_COUNT) {
-		// set software count
+		/*  set software count */
 		priv(dev)-&gt;ai_count = cmd-&gt;stop_arg * cmd-&gt;chanlist_len;
 	}
-	// load hardware conversion counter
+	/*  load hardware conversion counter */
 	if (use_hw_sample_counter(cmd)) {
 		writew(cmd-&gt;stop_arg &amp; 0xffff,
 			priv(dev)-&gt;main_iobase + ADC_COUNT_LOWER_REG);
@@ -2396,9 +2396,9 @@ static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi
 
 	bits = EN_ADC_OVERRUN_BIT | EN_ADC_DONE_INTR_BIT |
 		EN_ADC_ACTIVE_INTR_BIT | EN_ADC_STOP_INTR_BIT;
-	// Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set.
+	/*  Use pio transfer and interrupt on end of conversion if TRIG_WAKE_EOS flag is set. */
 	if (cmd-&gt;flags &amp; TRIG_WAKE_EOS) {
-		// 4020 doesn't support pio transfers except for fifo dregs
+		/*  4020 doesn't support pio transfers except for fifo dregs */
 		if (board(dev)-&gt;layout != LAYOUT_4020)
 			bits |= ADC_INTR_EOSCAN_BITS | EN_ADC_INTR_SRC_BIT;
 	}
@@ -2413,14 +2413,14 @@ static void enable_ai_interrupts(struct comedi_device * dev, const struct comedi
 static uint32_t ai_convert_counter_6xxx(const struct comedi_device * dev,
 	const struct comedi_cmd * cmd)
 {
-	// supposed to load counter with desired divisor minus 3
+	/*  supposed to load counter with desired divisor minus 3 */
 	return cmd-&gt;convert_arg / TIMER_BASE - 3;
 }
 
 static uint32_t ai_scan_counter_6xxx(struct comedi_device * dev, struct comedi_cmd * cmd)
 {
 	uint32_t count;
-	// figure out how long we need to delay at end of scan
+	/*  figure out how long we need to delay at end of scan */
 	switch (cmd-&gt;scan_begin_src) {
 	case TRIG_TIMER:
 		count = (cmd-&gt;scan_begin_arg -
@@ -2448,20 +2448,20 @@ static uint32_t ai_convert_counter_4020(struct comedi_device * dev, struct comed
 	case TRIG_OTHER:
 		divisor = priv(dev)-&gt;ext_clock.divisor;
 		break;
-	default:		// should never happen
+	default:		/*  should never happen */
 		comedi_error(dev, "bug! failed to set ai pacing!");
 		divisor = 1000;
 		break;
 	}
 
-	// supposed to load counter with desired divisor minus 2 for 4020
+	/*  supposed to load counter with desired divisor minus 2 for 4020 */
 	return divisor - 2;
 }
 
 static void select_master_clock_4020(struct comedi_device * dev,
 	const struct comedi_cmd * cmd)
 {
-	// select internal/external master clock
+	/*  select internal/external master clock */
 	priv(dev)-&gt;hw_config_bits &amp;= ~MASTER_CLOCK_4020_MASK;
 	if (cmd-&gt;scan_begin_src == TRIG_OTHER) {
 		int chanspec = priv(dev)-&gt;ext_clock.chanspec;
@@ -2492,7 +2492,7 @@ static inline void dma_start_sync(struct comedi_device * dev, unsigned int chann
 {
 	unsigned long flags;
 
-	// spinlock for plx dma control/status reg
+	/*  spinlock for plx dma control/status reg */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	if (channel)
 		writeb(PLX_DMA_EN_BIT | PLX_DMA_START_BIT |
@@ -2520,17 +2520,17 @@ static void set_ai_pacing(struct comedi_device * dev, struct comedi_cmd * cmd)
 		scan_counter = ai_scan_counter_6xxx(dev, cmd);
 	}
 
-	// load lower 16 bits of convert interval
+	/*  load lower 16 bits of convert interval */
 	writew(convert_counter &amp; 0xffff,
 		priv(dev)-&gt;main_iobase + ADC_SAMPLE_INTERVAL_LOWER_REG);
 	DEBUG_PRINT("convert counter 0x%x\n", convert_counter);
-	// load upper 8 bits of convert interval
+	/*  load upper 8 bits of convert interval */
 	writew((convert_counter &gt;&gt; 16) &amp; 0xff,
 		priv(dev)-&gt;main_iobase + ADC_SAMPLE_INTERVAL_UPPER_REG);
-	// load lower 16 bits of scan delay
+	/*  load lower 16 bits of scan delay */
 	writew(scan_counter &amp; 0xffff,
 		priv(dev)-&gt;main_iobase + ADC_DELAY_INTERVAL_LOWER_REG);
-	// load upper 8 bits of scan delay
+	/*  load upper 8 bits of scan delay */
 	writew((scan_counter &gt;&gt; 16) &amp; 0xff,
 		priv(dev)-&gt;main_iobase + ADC_DELAY_INTERVAL_UPPER_REG);
 	DEBUG_PRINT("scan counter 0x%x\n", scan_counter);
@@ -2563,25 +2563,25 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			writew(priv(dev)-&gt;hw_config_bits,
 				priv(dev)-&gt;main_iobase + HW_CONFIG_REG);
 			bits = 0;
-			// set channel
+			/*  set channel */
 			bits |= adc_chan_bits(CR_CHAN(cmd-&gt;chanlist[0]));
-			// set gain
+			/*  set gain */
 			bits |= ai_range_bits_6xxx(dev,
 				CR_RANGE(cmd-&gt;chanlist[0]));
-			// set single-ended / differential
+			/*  set single-ended / differential */
 			bits |= se_diff_bit_6xxx(dev,
 				CR_AREF(cmd-&gt;chanlist[0]) == AREF_DIFF);
 			if (CR_AREF(cmd-&gt;chanlist[0]) == AREF_COMMON)
 				bits |= ADC_COMMON_BIT;
-			// set stop channel
+			/*  set stop channel */
 			writew(adc_chan_bits(CR_CHAN(cmd-&gt;chanlist[cmd-&gt;
 							chanlist_len - 1])),
 				priv(dev)-&gt;main_iobase + ADC_QUEUE_HIGH_REG);
-			// set start channel, and rest of settings
+			/*  set start channel, and rest of settings */
 			writew(bits,
 				priv(dev)-&gt;main_iobase + ADC_QUEUE_LOAD_REG);
 		} else {
-			// use external queue
+			/*  use external queue */
 			if (dev-&gt;write_subdev &amp;&amp; dev-&gt;write_subdev-&gt;busy) {
 				warn_external_queue(dev);
 				return -EBUSY;
@@ -2589,26 +2589,26 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			priv(dev)-&gt;hw_config_bits |= EXT_QUEUE_BIT;
 			writew(priv(dev)-&gt;hw_config_bits,
 				priv(dev)-&gt;main_iobase + HW_CONFIG_REG);
-			// clear DAC buffer to prevent weird interactions
+			/*  clear DAC buffer to prevent weird interactions */
 			writew(0,
 				priv(dev)-&gt;main_iobase + DAC_BUFFER_CLEAR_REG);
-			// clear queue pointer
+			/*  clear queue pointer */
 			writew(0, priv(dev)-&gt;main_iobase + ADC_QUEUE_CLEAR_REG);
-			// load external queue
+			/*  load external queue */
 			for (i = 0; i &lt; cmd-&gt;chanlist_len; i++) {
 				bits = 0;
-				// set channel
+				/*  set channel */
 				bits |= adc_chan_bits(CR_CHAN(cmd-&gt;
 						chanlist[i]));
-				// set gain
+				/*  set gain */
 				bits |= ai_range_bits_6xxx(dev,
 					CR_RANGE(cmd-&gt;chanlist[i]));
-				// set single-ended / differential
+				/*  set single-ended / differential */
 				bits |= se_diff_bit_6xxx(dev,
 					CR_AREF(cmd-&gt;chanlist[i]) == AREF_DIFF);
 				if (CR_AREF(cmd-&gt;chanlist[i]) == AREF_COMMON)
 					bits |= ADC_COMMON_BIT;
-				// mark end of queue
+				/*  mark end of queue */
 				if (i == cmd-&gt;chanlist_len - 1)
 					bits |= QUEUE_EOSCAN_BIT |
 						QUEUE_EOSEQ_BIT;
@@ -2622,7 +2622,7 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			/* doing a queue clear is not specified in board docs,
 			 * but required for reliable operation */
 			writew(0, priv(dev)-&gt;main_iobase + ADC_QUEUE_CLEAR_REG);
-			// prime queue holding register
+			/*  prime queue holding register */
 			writew(0, priv(dev)-&gt;main_iobase + ADC_QUEUE_LOAD_REG);
 		}
 	} else {
@@ -2630,9 +2630,9 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 			priv(dev)-&gt;i2c_cal_range_bits;
 
 		priv(dev)-&gt;i2c_cal_range_bits &amp;= ~ADC_SRC_4020_MASK;
-		//select BNC inputs
+		/* select BNC inputs */
 		priv(dev)-&gt;i2c_cal_range_bits |= adc_src_4020_bits(4);
-		// select ranges
+		/*  select ranges */
 		for (i = 0; i &lt; cmd-&gt;chanlist_len; i++) {
 			unsigned int channel = CR_CHAN(cmd-&gt;chanlist[i]);
 			unsigned int range = CR_RANGE(cmd-&gt;chanlist[i]);
@@ -2644,7 +2644,7 @@ static int setup_channel_queue(struct comedi_device * dev, const struct comedi_c
 				priv(dev)-&gt;i2c_cal_range_bits &amp;=
 					~attenuate_bit(channel);
 		}
-		// update calibration/range i2c register only if necessary, as it is very slow
+		/*  update calibration/range i2c register only if necessary, as it is very slow */
 		if (old_cal_range_bits != priv(dev)-&gt;i2c_cal_range_bits) {
 			uint8_t i2c_data = priv(dev)-&gt;i2c_cal_range_bits;
 			i2c_write(dev, RANGE_CAL_I2C_ADDR, &amp;i2c_data,
@@ -2697,7 +2697,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	if (retval &lt; 0)
 		return retval;
 
-	// make sure internal calibration source is turned off
+	/*  make sure internal calibration source is turned off */
 	writew(0, priv(dev)-&gt;main_iobase + CALIBRATION_REG);
 
 	set_ai_pacing(dev, cmd);
@@ -2713,9 +2713,9 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	if (board(dev)-&gt;layout != LAYOUT_4020) {
 		priv(dev)-&gt;adc_control1_bits &amp;= ~ADC_MODE_MASK;
 		if (cmd-&gt;convert_src == TRIG_EXT)
-			priv(dev)-&gt;adc_control1_bits |= adc_mode_bits(13);	// good old mode 13
+			priv(dev)-&gt;adc_control1_bits |= adc_mode_bits(13);	/*  good old mode 13 */
 		else
-			priv(dev)-&gt;adc_control1_bits |= adc_mode_bits(8);	// mode 8.  What else could you need?
+			priv(dev)-&gt;adc_control1_bits |= adc_mode_bits(8);	/*  mode 8.  What else could you need? */
 	} else {
 		priv(dev)-&gt;adc_control1_bits &amp;= ~CHANNEL_MODE_4020_MASK;
 		if (cmd-&gt;chanlist_len == 4)
@@ -2735,20 +2735,20 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	DEBUG_PRINT("control1 bits 0x%x\n", priv(dev)-&gt;adc_control1_bits);
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// clear adc buffer
+	/*  clear adc buffer */
 	writew(0, priv(dev)-&gt;main_iobase + ADC_BUFFER_CLEAR_REG);
 
 	if ((cmd-&gt;flags &amp; TRIG_WAKE_EOS) == 0 ||
 		board(dev)-&gt;layout == LAYOUT_4020) {
 		priv(dev)-&gt;ai_dma_index = 0;
 
-		// set dma transfer size
+		/*  set dma transfer size */
 		for (i = 0; i &lt; ai_dma_ring_count(board(dev)); i++)
 			priv(dev)-&gt;ai_dma_desc[i].transfer_size =
 				cpu_to_le32(dma_transfer_size(dev) *
 				sizeof(uint16_t));
 
-		// give location of first dma descriptor
+		/*  give location of first dma descriptor */
 		load_first_dma_descriptor(dev, 1,
 			priv(dev)-&gt;
 			ai_dma_desc_bus_addr | PLX_DESC_IN_PCI_BIT |
@@ -2773,7 +2773,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	bits = ADC_ENABLE_BIT | ADC_SOFT_GATE_BITS | ADC_GATE_LEVEL_BIT;
 	if (cmd-&gt;flags &amp; TRIG_WAKE_EOS)
 		bits |= ADC_DMA_DISABLE_BIT;
-	// set start trigger
+	/*  set start trigger */
 	if (cmd-&gt;start_src == TRIG_EXT) {
 		bits |= ADC_START_TRIG_EXT_BITS;
 		if (cmd-&gt;start_arg &amp; CR_INVERT)
@@ -2789,7 +2789,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 
 	comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 
-	// start aquisition
+	/*  start aquisition */
 	if (cmd-&gt;start_src == TRIG_NOW) {
 		writew(0, priv(dev)-&gt;main_iobase + ADC_START_REG);
 		DEBUG_PRINT("soft trig\n");
@@ -2798,7 +2798,7 @@ static int ai_cmd(struct comedi_device * dev, struct comedi_subdevice * s)
 	return 0;
 }
 
-// read num_samples from 16 bit wide ai fifo
+/* read num_samples from 16 bit wide ai fifo */
 static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 {
 	struct comedi_subdevice *s = dev-&gt;read_subdev;
@@ -2810,7 +2810,7 @@ static void pio_drain_ai_fifo_16(struct comedi_device * dev)
 	int num_samples;
 
 	do {
-		// get least significant 15 bits
+		/*  get least significant 15 bits */
 		read_index =
 			readw(priv(dev)-&gt;main_iobase +
 			ADC_READ_PNTR_REG) &amp; 0x7fff;
@@ -2899,7 +2899,7 @@ static void pio_drain_ai_fifo_32(struct comedi_device * dev)
 	priv(dev)-&gt;ai_count -= i;
 }
 
-// empty fifo
+/* empty fifo */
 static void pio_drain_ai_fifo(struct comedi_device * dev)
 {
 	if (board(dev)-&gt;layout == LAYOUT_4020) {
@@ -2923,7 +2923,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 		pci_addr_reg =
 			priv(dev)-&gt;plx9080_iobase + PLX_DMA0_PCI_ADDRESS_REG;
 
-	// loop until we have read all the full buffers
+	/*  loop until we have read all the full buffers */
 	for (j = 0, next_transfer_addr = readl(pci_addr_reg);
 		(next_transfer_addr &lt;
 			priv(dev)-&gt;ai_buffer_bus_addr[priv(dev)-&gt;ai_dma_index]
@@ -2931,7 +2931,7 @@ static void drain_dma_buffers(struct comedi_device * dev, unsigned int channel)
 			priv(dev)-&gt;ai_buffer_bus_addr[priv(dev)-&gt;ai_dma_index] +
 			DMA_BUFFER_SIZE) &amp;&amp; j &lt; ai_dma_ring_count(board(dev));
 		j++) {
-		// transfer data from dma buffer to comedi buffer
+		/*  transfer data from dma buffer to comedi buffer */
 		num_samples = dma_transfer_size(dev);
 		if (async-&gt;cmd.stop_src == TRIG_COUNT) {
 			if (num_samples &gt; priv(dev)-&gt;ai_count)
@@ -2963,15 +2963,15 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	uint8_t dma1_status;
 	unsigned long flags;
 
-	// check for fifo overrun
+	/*  check for fifo overrun */
 	if (status &amp; ADC_OVERRUN_BIT) {
 		comedi_error(dev, "fifo overrun");
 		async-&gt;events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;
 	}
-	// spin lock makes sure noone else changes plx dma control reg
+	/*  spin lock makes sure noone else changes plx dma control reg */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	dma1_status = readb(priv(dev)-&gt;plx9080_iobase + PLX_DMA1_CS_REG);
-	if (plx_status &amp; ICS_DMA1_A) {	// dma chan 1 interrupt
+	if (plx_status &amp; ICS_DMA1_A) {	/*  dma chan 1 interrupt */
 		writeb((dma1_status &amp; PLX_DMA_EN_BIT) | PLX_CLEAR_DMA_INTR_BIT,
 			priv(dev)-&gt;plx9080_iobase + PLX_DMA1_CS_REG);
 		DEBUG_PRINT("dma1 status 0x%x\n", dma1_status);
@@ -2986,7 +2986,7 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 	if (status &amp; ADC_DONE_BIT)
 		DEBUG_PRINT("adc done interrupt\n");
 
-	// drain fifo with pio
+	/*  drain fifo with pio */
 	if ((status &amp; ADC_DONE_BIT) ||
 		((cmd-&gt;flags &amp; TRIG_WAKE_EOS) &amp;&amp;
 			(status &amp; ADC_INTR_PENDING_BIT) &amp;&amp;
@@ -2999,7 +2999,7 @@ void handle_ai_interrupt(struct comedi_device * dev, unsigned short status,
 		} else
 			comedi_spin_unlock_irqrestore(&amp;dev-&gt;spinlock, flags);
 	}
-	// if we are have all the data, then quit
+	/*  if we are have all the data, then quit */
 	if ((cmd-&gt;stop_src == TRIG_COUNT &amp;&amp; priv(dev)-&gt;ai_count &lt;= 0) ||
 		(cmd-&gt;stop_src == TRIG_EXT &amp;&amp; (status &amp; ADC_STOP_BIT))) {
 		async-&gt;events |= COMEDI_CB_EOA;
@@ -3091,10 +3091,10 @@ static void handle_ao_interrupt(struct comedi_device * dev, unsigned short statu
 	async = s-&gt;async;
 	cmd = &amp;async-&gt;cmd;
 
-	// spin lock makes sure noone else changes plx dma control reg
+	/*  spin lock makes sure noone else changes plx dma control reg */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 	dma0_status = readb(priv(dev)-&gt;plx9080_iobase + PLX_DMA0_CS_REG);
-	if (plx_status &amp; ICS_DMA0_A) {	// dma chan 0 interrupt
+	if (plx_status &amp; ICS_DMA0_A) {	/*  dma chan 0 interrupt */
 		if ((dma0_status &amp; PLX_DMA_EN_BIT)
 			&amp;&amp; !(dma0_status &amp; PLX_DMA_DONE_BIT))
 			writeb(PLX_DMA_EN_BIT | PLX_CLEAR_DMA_INTR_BIT,
@@ -3152,8 +3152,8 @@ static irqreturn_t handle_interrupt(int irq, void *d PT_REGS_ARG)
 	handle_ai_interrupt(dev, status, plx_status);
 	handle_ao_interrupt(dev, status, plx_status);
 
-	// clear possible plx9080 interrupt sources
-	if (plx_status &amp; ICS_LDIA) {	// clear local doorbell interrupt
+	/*  clear possible plx9080 interrupt sources */
+	if (plx_status &amp; ICS_LDIA) {	/*  clear local doorbell interrupt */
 		plx_bits = readl(priv(dev)-&gt;plx9080_iobase + PLX_DBR_OUT_REG);
 		writel(plx_bits, priv(dev)-&gt;plx9080_iobase + PLX_DBR_OUT_REG);
 		DEBUG_PRINT(" cleared local doorbell bits 0x%x\n", plx_bits);
@@ -3168,7 +3168,7 @@ void abort_dma(struct comedi_device * dev, unsigned int channel)
 {
 	unsigned long flags;
 
-	// spinlock for plx dma control/status reg
+	/*  spinlock for plx dma control/status reg */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 
 	plx9080_abort_dma(priv(dev)-&gt;plx9080_iobase, channel);
@@ -3202,15 +3202,15 @@ static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	int chan = CR_CHAN(insn-&gt;chanspec);
 	int range = CR_RANGE(insn-&gt;chanspec);
 
-	// do some initializing
+	/*  do some initializing */
 	writew(0, priv(dev)-&gt;main_iobase + DAC_CONTROL0_REG);
 
-	// set range
+	/*  set range */
 	set_dac_range_bits(dev, &amp;priv(dev)-&gt;dac_control1_bits, chan, range);
 	writew(priv(dev)-&gt;dac_control1_bits,
 		priv(dev)-&gt;main_iobase + DAC_CONTROL1_REG);
 
-	// write to channel
+	/*  write to channel */
 	if (board(dev)-&gt;layout == LAYOUT_4020) {
 		writew(data[0] &amp; 0xff,
 			priv(dev)-&gt;main_iobase + dac_lsb_4020_reg(chan));
@@ -3220,7 +3220,7 @@ static int ao_winsn(struct comedi_device * dev, struct comedi_subdevice * s,
 		writew(data[0], priv(dev)-&gt;main_iobase + dac_convert_reg(chan));
 	}
 
-	// remember output value
+	/*  remember output value */
 	priv(dev)-&gt;ao_value[chan] = data[0];
 
 	return 1;
@@ -3503,14 +3503,14 @@ static int ao_cmdtest(struct comedi_device * dev, struct comedi_subdevice * s,
 
 	/* step 2: make sure trigger sources are unique and mutually compatible */
 
-	// uniqueness check
+	/*  uniqueness check */
 	if (cmd-&gt;start_src != TRIG_INT &amp;&amp; cmd-&gt;start_src != TRIG_EXT)
 		err++;
 	if (cmd-&gt;scan_begin_src != TRIG_TIMER &amp;&amp;
 		cmd-&gt;scan_begin_src != TRIG_EXT)
 		err++;
 
-	// compatibility check
+	/*  compatibility check */
 	if (cmd-&gt;convert_src == TRIG_EXT &amp;&amp; cmd-&gt;scan_begin_src == TRIG_TIMER)
 		err++;
 	if (cmd-&gt;stop_src != TRIG_COUNT &amp;&amp;
@@ -3624,9 +3624,9 @@ static int do_wbits(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data)
 {
 	data[0] &amp;= 0xf;
-	// zero bits we are going to change
+	/*  zero bits we are going to change */
 	s-&gt;state &amp;= ~data[0];
-	// set new bits
+	/*  set new bits */
 	s-&gt;state |= data[0] &amp; data[1];
 
 	writeb(s-&gt;state, priv(dev)-&gt;dio_counter_iobase + DO_REG);
@@ -3793,24 +3793,24 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 
 	comedi_udelay(eeprom_comedi_udelay);
 	priv(dev)-&gt;plx_control_bits &amp;= ~CTL_EE_CLK &amp; ~CTL_EE_CS;
-	// make sure we don't send anything to the i2c bus on 4020
+	/*  make sure we don't send anything to the i2c bus on 4020 */
 	priv(dev)-&gt;plx_control_bits |= CTL_USERO;
 	writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
-	// activate serial eeprom
+	/*  activate serial eeprom */
 	comedi_udelay(eeprom_comedi_udelay);
 	priv(dev)-&gt;plx_control_bits |= CTL_EE_CS;
 	writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
 
-	// write read command and desired memory address
+	/*  write read command and desired memory address */
 	for (bit = 1 &lt;&lt; (bitstream_length - 1); bit; bit &gt;&gt;= 1) {
-		// set bit to be written
+		/*  set bit to be written */
 		comedi_udelay(eeprom_comedi_udelay);
 		if (bitstream &amp; bit)
 			priv(dev)-&gt;plx_control_bits |= CTL_EE_W;
 		else
 			priv(dev)-&gt;plx_control_bits &amp;= ~CTL_EE_W;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
-		// clock in bit
+		/*  clock in bit */
 		comedi_udelay(eeprom_comedi_udelay);
 		priv(dev)-&gt;plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
@@ -3818,10 +3818,10 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 		priv(dev)-&gt;plx_control_bits &amp;= ~CTL_EE_CLK;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
 	}
-	// read back value from eeprom memory location
+	/*  read back value from eeprom memory location */
 	value = 0;
 	for (bit = 1 &lt;&lt; (value_length - 1); bit; bit &gt;&gt;= 1) {
-		// clock out bit
+		/*  clock out bit */
 		comedi_udelay(eeprom_comedi_udelay);
 		priv(dev)-&gt;plx_control_bits |= CTL_EE_CLK;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
@@ -3833,7 +3833,7 @@ static uint16_t read_eeprom(struct comedi_device * dev, uint8_t address)
 			value |= bit;
 	}
 
-	// deactivate eeprom serial input
+	/*  deactivate eeprom serial input */
 	comedi_udelay(eeprom_comedi_udelay);
 	priv(dev)-&gt;plx_control_bits &amp;= ~CTL_EE_CS;
 	writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
@@ -3880,7 +3880,7 @@ static void check_adc_timing(struct comedi_device *dev, struct comedi_cmd *cmd)
 	if (cmd-&gt;scan_begin_src == TRIG_TIMER) {
 		scan_divisor = get_divisor(cmd-&gt;scan_begin_arg, cmd-&gt;flags);
 		if (cmd-&gt;convert_src == TRIG_TIMER) {
-			// XXX check for integer overflows
+			/*  XXX check for integer overflows */
 			min_scan_divisor = convert_divisor * cmd-&gt;chanlist_len;
 			max_scan_divisor =
 				(convert_divisor * cmd-&gt;chanlist_len - 1) +
@@ -3926,7 +3926,7 @@ static unsigned int get_ao_divisor(unsigned int ns, unsigned int flags)
 	return get_divisor(ns, flags) - 2;
 }
 
-// adjusts the size of hardware fifo (which determines block size for dma xfers)
+/* adjusts the size of hardware fifo (which determines block size for dma xfers) */
 static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples)
 {
 	unsigned int num_fifo_entries;
@@ -3947,7 +3947,7 @@ static int set_ai_fifo_size(struct comedi_device * dev, unsigned int num_samples
 	return num_samples;
 }
 
-// query length of fifo
+/* query length of fifo */
 static unsigned int ai_fifo_size(struct comedi_device * dev)
 {
 	return priv(dev)-&gt;ai_fifo_segment_length *
@@ -3968,7 +3968,7 @@ static int set_ai_fifo_segment_length(struct comedi_device * dev,
 	if (num_entries &gt; fifo-&gt;max_segment_length)
 		num_entries = fifo-&gt;max_segment_length;
 
-	// 1 == 256 entries, 2 == 512 entries, etc
+	/*  1 == 256 entries, 2 == 512 entries, etc */
 	num_increments = (num_entries + increment_size / 2) / increment_size;
 
 	bits = (~(num_increments - 1)) &amp; fifo-&gt;fifo_size_reg_mask;
@@ -4037,14 +4037,14 @@ static int caldac_8800_write(struct comedi_device * dev, unsigned int address,
 	return 0;
 }
 
-// 4020 caldacs
+/* 4020 caldacs */
 static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_channel,
 	unsigned int value)
 {
 	uint8_t serial_bytes[3];
 	uint8_t i2c_addr;
 	enum pointer_bits {
-		// manual has gain and offset bits switched
+		/*  manual has gain and offset bits switched */
 		OFFSET_0_2 = 0x1,
 		GAIN_0_2 = 0x2,
 		OFFSET_1_3 = 0x4,
@@ -4055,35 +4055,35 @@ static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_chan
 	};
 
 	switch (caldac_channel) {
-	case 0:		// chan 0 offset
+	case 0:		/*  chan 0 offset */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = OFFSET_0_2;
 		break;
-	case 1:		// chan 1 offset
+	case 1:		/*  chan 1 offset */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = OFFSET_1_3;
 		break;
-	case 2:		// chan 2 offset
+	case 2:		/*  chan 2 offset */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = OFFSET_0_2;
 		break;
-	case 3:		// chan 3 offset
+	case 3:		/*  chan 3 offset */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = OFFSET_1_3;
 		break;
-	case 4:		// chan 0 gain
+	case 4:		/*  chan 0 gain */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = GAIN_0_2;
 		break;
-	case 5:		// chan 1 gain
+	case 5:		/*  chan 1 gain */
 		i2c_addr = CALDAC0_I2C_ADDR;
 		serial_bytes[0] = GAIN_1_3;
 		break;
-	case 6:		// chan 2 gain
+	case 6:		/*  chan 2 gain */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = GAIN_0_2;
 		break;
-	case 7:		// chan 3 gain
+	case 7:		/*  chan 3 gain */
 		i2c_addr = CALDAC1_I2C_ADDR;
 		serial_bytes[0] = GAIN_1_3;
 		break;
@@ -4098,22 +4098,22 @@ static int caldac_i2c_write(struct comedi_device * dev, unsigned int caldac_chan
 	return 0;
 }
 
-// Their i2c requires a huge delay on setting clock or data high for some reason
+/* Their i2c requires a huge delay on setting clock or data high for some reason */
 static const int i2c_high_comedi_udelay = 1000;
 static const int i2c_low_comedi_udelay = 10;
 
-// set i2c data line high or low
+/* set i2c data line high or low */
 static void i2c_set_sda(struct comedi_device * dev, int state)
 {
 	static const int data_bit = CTL_EE_W;
 	void *plx_control_addr = priv(dev)-&gt;plx9080_iobase + PLX_CONTROL_REG;
 
 	if (state) {
-		// set data line high
+		/*  set data line high */
 		priv(dev)-&gt;plx_control_bits &amp;= ~data_bit;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
 		comedi_udelay(i2c_high_comedi_udelay);
-	} else			// set data line low
+	} else			/*  set data line low */
 	{
 		priv(dev)-&gt;plx_control_bits |= data_bit;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
@@ -4121,18 +4121,18 @@ static void i2c_set_sda(struct comedi_device * dev, int state)
 	}
 }
 
-// set i2c clock line high or low
+/* set i2c clock line high or low */
 static void i2c_set_scl(struct comedi_device * dev, int state)
 {
 	static const int clock_bit = CTL_USERO;
 	void *plx_control_addr = priv(dev)-&gt;plx9080_iobase + PLX_CONTROL_REG;
 
 	if (state) {
-		// set clock line high
+		/*  set clock line high */
 		priv(dev)-&gt;plx_control_bits &amp;= ~clock_bit;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
 		comedi_udelay(i2c_high_comedi_udelay);
-	} else			// set clock line low
+	} else			/*  set clock line low */
 	{
 		priv(dev)-&gt;plx_control_bits |= clock_bit;
 		writel(priv(dev)-&gt;plx_control_bits, plx_control_addr);
@@ -4157,17 +4157,17 @@ static void i2c_write_byte(struct comedi_device * dev, uint8_t byte)
 	}
 }
 
-// we can't really read the lines, so fake it
+/* we can't really read the lines, so fake it */
 static int i2c_read_ack(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 0);
 	i2c_set_sda(dev, 1);
 	i2c_set_scl(dev, 1);
 
-	return 0;		// return fake acknowledge bit
+	return 0;		/*  return fake acknowledge bit */
 }
 
-// send start bit
+/* send start bit */
 static void i2c_start(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 1);
@@ -4175,7 +4175,7 @@ static void i2c_start(struct comedi_device * dev)
 	i2c_set_sda(dev, 0);
 }
 
-// send stop bit
+/* send stop bit */
 static void i2c_stop(struct comedi_device * dev)
 {
 	i2c_set_scl(dev, 0);
@@ -4191,25 +4191,25 @@ static void i2c_write(struct comedi_device * dev, unsigned int address,
 	uint8_t bitstream;
 	static const int read_bit = 0x1;
 
-//XXX need mutex to prevent simultaneous attempts to access eeprom and i2c bus
+/* XXX need mutex to prevent simultaneous attempts to access eeprom and i2c bus */
 
-	// make sure we dont send anything to eeprom
+	/*  make sure we dont send anything to eeprom */
 	priv(dev)-&gt;plx_control_bits &amp;= ~CTL_EE_CS;
 
 	i2c_stop(dev);
 	i2c_start(dev);
 
-	// send address and write bit
+	/*  send address and write bit */
 	bitstream = (address &lt;&lt; 1) &amp; ~read_bit;
 	i2c_write_byte(dev, bitstream);
 
-	// get acknowledge
+	/*  get acknowledge */
 	if (i2c_read_ack(dev) != 0) {
 		comedi_error(dev, "i2c write failed: no acknowledge");
 		i2c_stop(dev);
 		return;
 	}
-	// write data bytes
+	/*  write data bytes */
 	for (i = 0; i &lt; length; i++) {
 		i2c_write_byte(dev, data[i]);
 		if (i2c_read_ack(dev) != 0) {</pre><hr><pre>commit 6a438139a8963839a9b14709286075b2e38cf9e0
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:34 2009 -0400

    Staging: comedi: remove C99 comments in c6xdigio.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/c6xdigio.c b/drivers/staging/comedi/drivers/c6xdigio.c
index 2efffb14610d..c8ffddf4add4 100644
--- a/drivers/staging/comedi/drivers/c6xdigio.c
+++ b/drivers/staging/comedi/drivers/c6xdigio.c
@@ -77,7 +77,7 @@ struct pwmbitstype {
 	unsigned sb4:2;
 };
 union pwmcmdtype {
-	unsigned cmd;		// assuming here that int is 32bit
+	unsigned cmd;		/*  assuming here that int is 32bit */
 	struct pwmbitstype bits;
 };
 struct encbitstype {
@@ -110,7 +110,7 @@ static void C6X_pwmInit(unsigned long baseAddr)
 {
 	int timeout = 0;
 
-//printk("Inside C6X_pwmInit\n");
+/* printk("Inside C6X_pwmInit\n"); */
 
 	WriteByteToHwPort(baseAddr, 0x70);
 	while (((ReadByteFromHwPort(baseAddr + 1) &amp; 0x80) == 0)
@@ -148,7 +148,7 @@ static void C6X_pwmOutput(unsigned long baseAddr, unsigned channel, int value)
 	int timeout = 0;
 	unsigned tmp;
 
-	//printk("Inside C6X_pwmOutput\n");
+	/* printk("Inside C6X_pwmOutput\n"); */
 
 	pwm.cmd = value;
 	if (pwm.cmd &gt; 498)
@@ -158,7 +158,7 @@ static void C6X_pwmOutput(unsigned long baseAddr, unsigned channel, int value)
 
 	if (channel == 0) {
 		ppcmd = 0x28;
-	} else {		// if channel == 1
+	} else {		/*  if channel == 1 */
 		ppcmd = 0x30;
 	}			/* endif */
 
@@ -216,7 +216,7 @@ static int C6X_encInput(unsigned long baseAddr, unsigned channel)
 	int timeout = 0;
 	int tmp;
 
-	//printk("Inside C6X_encInput\n");
+	/* printk("Inside C6X_encInput\n"); */
 
 	enc.value = 0;
 	if (channel == 0) {
@@ -311,7 +311,7 @@ static void C6X_encResetAll(unsigned long baseAddr)
 {
 	unsigned timeout = 0;
 
-//printk("Inside C6X_encResetAll\n");
+/* printk("Inside C6X_encResetAll\n"); */
 
 	WriteByteToHwPort(baseAddr, 0x68);
 	while (((ReadByteFromHwPort(baseAddr + 1) &amp; 0x80) == 0)
@@ -351,7 +351,7 @@ static int c6xdigio_pwmo_insn_write(struct comedi_device * dev,
 	int i;
 	int chan = CR_CHAN(insn-&gt;chanspec);
 
-	//  printk("c6xdigio_pwmo_insn_write %x\n", insn-&gt;n);
+	/*   printk("c6xdigio_pwmo_insn_write %x\n", insn-&gt;n); */
 	for (i = 0; i &lt; insn-&gt;n; i++) {
 		C6X_pwmOutput(dev-&gt;iobase, chan, data[i]);
 		/*    devpriv-&gt;ao_readback[chan] = data[i]; */
@@ -359,32 +359,30 @@ static int c6xdigio_pwmo_insn_write(struct comedi_device * dev,
 	return i;
 }
 
-//static int c6xdigio_ei_init_insn_read(struct comedi_device *dev,
-//                                 struct comedi_subdevice *s,
-//                                 struct comedi_insn *insn,
-//                                 unsigned int *data)
-//{
-//  printk("c6xdigio_ei_init_insn_read %x\n", insn-&gt;n);
-//  return insn-&gt;n;
-//}
-
-//static int c6xdigio_ei_init_insn_write(struct comedi_device *dev,
-//                                 struct comedi_subdevice *s,
-//                                 struct comedi_insn *insn,
-//                                 unsigned int *data)
-//{
-//  int i;
-//  int chan = CR_CHAN(insn-&gt;chanspec);
-//
-//  C6X_encResetAll( dev-&gt;iobase );
-//
-//  return insn-&gt;n;
-//}
+/* static int c6xdigio_ei_init_insn_read(struct comedi_device *dev, */
+/* struct comedi_subdevice *s, */
+/* struct comedi_insn *insn, */
+/* unsigned int *data) */
+/* { */
+/* printk("c6xdigio_ei_init_insn_read %x\n", insn-&gt;n); */
+/* return insn-&gt;n; */
+/* } */
+
+/* static int c6xdigio_ei_init_insn_write(struct comedi_device *dev, */
+/* struct comedi_subdevice *s, */
+/* struct comedi_insn *insn, */
+/* unsigned int *data) */
+/* { */
+/* int i; */
+/* int chan = CR_CHAN(insn-&gt;chanspec); */
+/*  *//* C6X_encResetAll( dev-&gt;iobase ); */
+/*  *//* return insn-&gt;n; */
+/* } */
 
 static int c6xdigio_ei_insn_read(struct comedi_device * dev,
 	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
-	//  printk("c6xdigio_ei__insn_read %x\n", insn-&gt;n);
+	/*   printk("c6xdigio_ei__insn_read %x\n", insn-&gt;n); */
 	int n;
 	int chan = CR_CHAN(insn-&gt;chanspec);
 
@@ -398,16 +396,16 @@ static int c6xdigio_ei_insn_read(struct comedi_device * dev,
 static void board_init(struct comedi_device * dev)
 {
 
-	//printk("Inside board_init\n");
+	/* printk("Inside board_init\n"); */
 
 	C6X_pwmInit(dev-&gt;iobase);
 	C6X_encResetAll(dev-&gt;iobase);
 
 }
 
-//static void board_halt(struct comedi_device *dev) {
-//  C6X_pwmInit(dev-&gt;iobase);
-//}
+/* static void board_halt(struct comedi_device *dev) { */
+/* C6X_pwmInit(dev-&gt;iobase); */
+/* } */
 
 /*
    options[0] - I/O port
@@ -444,11 +442,11 @@ static int c6xdigio_attach(struct comedi_device * dev, struct comedi_devconfig *
 	dev-&gt;iobase = iobase;
 	dev-&gt;board_name = "c6xdigio";
 
-	result = alloc_subdevices(dev, 2);	// 3 with encoder_init write
+	result = alloc_subdevices(dev, 2);	/*  3 with encoder_init write */
 	if (result &lt; 0)
 		return result;
 
-	// Make sure that PnP ports gets activated
+	/*  Make sure that PnP ports gets activated */
 	pnp_register_driver(&amp;c6xdigio_pnp_driver);
 
 	irq = it-&gt;options[1];
@@ -460,14 +458,14 @@ static int c6xdigio_attach(struct comedi_device * dev, struct comedi_devconfig *
 
 	s = dev-&gt;subdevices + 0;
 	/* pwm output subdevice */
-	s-&gt;type = COMEDI_SUBD_AO;	// Not sure what to put here
+	s-&gt;type = COMEDI_SUBD_AO;	/*  Not sure what to put here */
 	s-&gt;subdev_flags = SDF_WRITEABLE;
 	s-&gt;n_chan = 2;
 	/*      s-&gt;trig[0] = c6xdigio_pwmo; */
 	s-&gt;insn_read = c6xdigio_pwmo_insn_read;
 	s-&gt;insn_write = c6xdigio_pwmo_insn_write;
 	s-&gt;maxdata = 500;
-	s-&gt;range_table = &amp;range_bipolar10;	// A suitable lie
+	s-&gt;range_table = &amp;range_bipolar10;	/*  A suitable lie */
 
 	s = dev-&gt;subdevices + 1;
 	/* encoder (counter) subdevice */
@@ -479,19 +477,19 @@ static int c6xdigio_attach(struct comedi_device * dev, struct comedi_devconfig *
 	s-&gt;maxdata = 0xffffff;
 	s-&gt;range_table = &amp;range_unknown;
 
-	//          s = dev-&gt;subdevices + 2;
-	//      /* pwm output subdevice */
-	//      s-&gt;type = COMEDI_SUBD_COUNTER;  // Not sure what to put here
-	//      s-&gt;subdev_flags = SDF_WRITEABLE;
-	//      s-&gt;n_chan = 1;
-	//      /* s-&gt;trig[0] = c6xdigio_ei_init; */
-	//      s-&gt;insn_read = c6xdigio_ei_init_insn_read;
-	//      s-&gt;insn_write = c6xdigio_ei_init_insn_write;
-	//      s-&gt;maxdata = 0xFFFF;  // Really just a don't care
-	//      s-&gt;range_table = &amp;range_unknown; // Not sure what to put here
-
-	// I will call this init anyway but more than likely the DSP board will not be connect
-	// when device driver is loaded.
+	/*           s = dev-&gt;subdevices + 2; */
+	      /* pwm output subdevice */
+	/*       s-&gt;type = COMEDI_SUBD_COUNTER;  // Not sure what to put here */
+	/*       s-&gt;subdev_flags = SDF_WRITEABLE; */
+	/*       s-&gt;n_chan = 1; */
+	/*       s-&gt;trig[0] = c6xdigio_ei_init; */
+	/*       s-&gt;insn_read = c6xdigio_ei_init_insn_read; */
+	/*       s-&gt;insn_write = c6xdigio_ei_init_insn_write; */
+	/*       s-&gt;maxdata = 0xFFFF;  // Really just a don't care */
+	/*       s-&gt;range_table = &amp;range_unknown; // Not sure what to put here */
+
+	/*  I will call this init anyway but more than likely the DSP board will not be connect */
+	/*  when device driver is loaded. */
 	board_init(dev);
 
 	return 0;
@@ -499,7 +497,7 @@ static int c6xdigio_attach(struct comedi_device * dev, struct comedi_devconfig *
 
 static int c6xdigio_detach(struct comedi_device * dev)
 {
-//  board_halt(dev);  // may not need this
+/* board_halt(dev);  may not need this */
 
 	printk("comedi%d: c6xdigio: remove\n", dev-&gt;minor);
 
@@ -508,7 +506,7 @@ static int c6xdigio_detach(struct comedi_device * dev)
 	}
 	if (dev-&gt;irq) {
 		free_irq(dev-&gt;irq, dev);
-	}			// Not using IRQ so I am not sure if I need this
+	}			/*  Not using IRQ so I am not sure if I need this */
 	pnp_unregister_driver(&amp;c6xdigio_pnp_driver);
 
 	return 0;</pre><hr><pre>commit d6d9bd32a02bd6da4ea3412f0b5131cc5a442399
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:28 2009 -0400

    Staging: comedi: remove C99 comments in adv_pci1723.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/adv_pci1723.c b/drivers/staging/comedi/drivers/adv_pci1723.c
index 81f7ee18c150..eb4bf1f47b30 100644
--- a/drivers/staging/comedi/drivers/adv_pci1723.c
+++ b/drivers/staging/comedi/drivers/adv_pci1723.c
@@ -54,7 +54,7 @@ configures all channels in the same group.
 
 #define ADVANTECH_VENDOR        0x13fe	/* Advantech PCI vendor ID */
 
-// hardware types of the cards
+/* hardware types of the cards */
 #define TYPE_PCI1723 0
 
 #define IORANGE_1723  0x2A
@@ -92,7 +92,7 @@ configures all channels in the same group.
 
 #define PCI1723_SELECT_CALIBRATION 0x28	/* Select the calibration Ref_V */
 
-//static unsigned short pci_list_builded=0;     /*=1 list of card is know */
+/* static unsigned short pci_list_builded=0;      =1 list of card is know */
 
 static const struct comedi_lrange range_pci1723 = { 1, {
 			BIP_RANGE(10)
@@ -104,14 +104,14 @@ static const struct comedi_lrange range_pci1723 = { 1, {
  */
 struct pci1723_board {
 	const char *name;
-	int vendor_id;		// PCI vendor a device ID of card
+	int vendor_id;		/*  PCI vendor a device ID of card */
 	int device_id;
 	int iorange;
 	char cardtype;
-	int n_aochan;		// num of D/A chans
-	int n_diochan;		// num of DIO chans
-	int ao_maxdata;		// resolution of D/A
-	const struct comedi_lrange *rangelist_ao;	// rangelist for D/A
+	int n_aochan;		/*  num of D/A chans */
+	int n_diochan;		/*  num of DIO chans */
+	int ao_maxdata;		/*  resolution of D/A */
+	const struct comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
 };
 
 static const struct pci1723_board boardtypes[] = {
@@ -157,12 +157,12 @@ static struct comedi_driver driver_pci1723 = {
 
 /* this structure is for data unique to this hardware driver. */
 struct pci1723_private {
-	int valid;		//card is usable;
+	int valid;		/* card is usable; */
 
 	struct pci_dev *pcidev;
-	unsigned char da_range[8];	// D/A output range for each channel
+	unsigned char da_range[8];	/*  D/A output range for each channel */
 
-	short ao_data[8];	// data output buffer
+	short ao_data[8];	/*  data output buffer */
 };
 
 /*the following macro to make it easy to
@@ -180,22 +180,22 @@ static int pci1723_reset(struct comedi_device * dev)
 	int i;
 	DPRINTK("adv_pci1723 EDBG: BGN: pci1723_reset(...)\n");
 
-	outw(0x01, dev-&gt;iobase + PCI1723_SYN_SET);	// set synchronous output mode
+	outw(0x01, dev-&gt;iobase + PCI1723_SYN_SET);	/*  set synchronous output mode */
 
 	for (i = 0; i &lt; 8; i++) {
-		// set all outputs to 0V
+		/*  set all outputs to 0V */
 		devpriv-&gt;ao_data[i] = 0x8000;
 		outw(devpriv-&gt;ao_data[i], dev-&gt;iobase + PCI1723_DA(i));
-		// set all ranges to +/- 10V
+		/*  set all ranges to +/- 10V */
 		devpriv-&gt;da_range[i] = 0;
 		outw(((devpriv-&gt;da_range[i] &lt;&lt; 4) | i),
 			PCI1723_RANGE_CALIBRATION_MODE);
 	}
 
-	outw(0, dev-&gt;iobase + PCI1723_CHANGE_CHA_OUTPUT_TYPE_STROBE);	// update ranges
-	outw(0, dev-&gt;iobase + PCI1723_SYN_STROBE);	// update outputs
+	outw(0, dev-&gt;iobase + PCI1723_CHANGE_CHA_OUTPUT_TYPE_STROBE);	/*  update ranges */
+	outw(0, dev-&gt;iobase + PCI1723_SYN_STROBE);	/*  update outputs */
 
-	// set asynchronous output mode
+	/*  set asynchronous output mode */
 	outw(0, dev-&gt;iobase + PCI1723_SYN_SET);
 
 	DPRINTK("adv_pci1723 EDBG: END: pci1723_reset(...)\n");
@@ -265,12 +265,12 @@ static int pci1723_dio_insn_config(struct comedi_device * dev, struct comedi_sub
 		return -EINVAL;
 	}
 
-	// update hardware DIO mode
-	dio_mode = 0x0000;	// low byte output, high byte output
+	/*  update hardware DIO mode */
+	dio_mode = 0x0000;	/*  low byte output, high byte output */
 	if ((s-&gt;io_bits &amp; 0x00FF) == 0)
-		dio_mode |= 0x0001;	// low byte input
+		dio_mode |= 0x0001;	/*  low byte input */
 	if ((s-&gt;io_bits &amp; 0xFF00) == 0)
-		dio_mode |= 0x0002;	// high byte input
+		dio_mode |= 0x0002;	/*  high byte input */
 	outw(dio_mode, dev-&gt;iobase + PCI1723_DIGITAL_IO_PORT_SET);
 	return 1;
 }
@@ -389,22 +389,22 @@ static int pci1723_attach(struct comedi_device * dev, struct comedi_devconfig *
 		s-&gt;insn_write = pci1723_ao_write_winsn;
 		s-&gt;insn_read = pci1723_insn_read_ao;
 
-		// read DIO config
+		/*  read DIO config */
 		switch (inw(dev-&gt;iobase + PCI1723_DIGITAL_IO_PORT_MODE) &amp; 0x03) {
-		case 0x00:	// low byte output, high byte output
+		case 0x00:	/*  low byte output, high byte output */
 			s-&gt;io_bits = 0xFFFF;
 			break;
-		case 0x01:	// low byte input, high byte output
+		case 0x01:	/*  low byte input, high byte output */
 			s-&gt;io_bits = 0xFF00;
 			break;
-		case 0x02:	// low byte output, high byte input
+		case 0x02:	/*  low byte output, high byte input */
 			s-&gt;io_bits = 0x00FF;
 			break;
-		case 0x03:	// low byte input, high byte input
+		case 0x03:	/*  low byte input, high byte input */
 			s-&gt;io_bits = 0x0000;
 			break;
 		}
-		// read DIO port state
+		/*  read DIO port state */
 		s-&gt;state = inw(dev-&gt;iobase + PCI1723_READ_DIGITAL_INPUT_DATA);
 
 		subdev++;</pre><hr><pre>commit 0f04c356551f9ae55d9a0c5ea211699903cf1f93
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:23 2009 -0400

    Staging: comedi: remove C99 comments in adl_pci9118.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/adl_pci9118.c b/drivers/staging/comedi/drivers/adl_pci9118.c
index 278cf30cc4a3..9f0f9deafc3d 100644
--- a/drivers/staging/comedi/drivers/adl_pci9118.c
+++ b/drivers/staging/comedi/drivers/adl_pci9118.c
@@ -107,7 +107,7 @@ Configuration options:
 #define PCI9118_INTSRC	0x38	/* R:   interrupt reason register */
 #define PCI9118_INTCTRL	0x38	/* W:   interrupt control register */
 
-// bits from A/D control register (PCI9118_ADCNTRL)
+/* bits from A/D control register (PCI9118_ADCNTRL) */
 #define AdControl_UniP	0x80	/* 1=bipolar, 0=unipolar */
 #define AdControl_Diff	0x40	/* 1=differential, 0= single end inputs */
 #define AdControl_SoftG	0x20	/* 1=8254 counter works, 0=counter stops */
@@ -117,7 +117,7 @@ Configuration options:
 #define AdControl_Int	0x02	/* 1=enable INT, 0=disable */
 #define AdControl_Dma	0x01	/* 1=enable DMA, 0=disable */
 
-// bits from A/D function register (PCI9118_ADFUNC)
+/* bits from A/D function register (PCI9118_ADFUNC) */
 #define AdFunction_PDTrg	0x80	/* 1=positive, 0=negative digital trigger (only positive is correct) */
 #define AdFunction_PETrg	0x40	/* 1=positive, 0=negative external trigger (only positive is correct) */
 #define AdFunction_BSSH		0x20	/* 1=with sample&amp;hold, 0=without */
@@ -127,7 +127,7 @@ Configuration options:
 #define AdFunction_AM		0x02	/* 1=about trigger mode, 0=not about trigger */
 #define AdFunction_Start	0x01	/* 1=trigger start, 0=trigger stop */
 
-// bits from A/D status register (PCI9118_ADSTAT)
+/* bits from A/D status register (PCI9118_ADSTAT) */
 #define AdStatus_nFull	0x100	/* 0=FIFO full (fatal), 1=not full */
 #define AdStatus_nHfull	0x080	/* 0=FIFO half full, 1=FIFO not half full */
 #define AdStatus_nEpty	0x040	/* 0=FIFO empty, 1=FIFO not empty */
@@ -138,8 +138,8 @@ Configuration options:
 #define AdStatus_ADOR	0x002	/* 1=A/D overrun (fatal) */
 #define AdStatus_ADrdy	0x001	/* 1=A/D already ready, 0=not ready */
 
-// bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL)
-// 1=interrupt occur, enable source,  0=interrupt not occur, disable source
+/* bits for interrupt reason and control (PCI9118_INTSRC, PCI9118_INTCTRL) */
+/* 1=interrupt occur, enable source,  0=interrupt not occur, disable source */
 #define Int_Timer	0x08	/* timer interrupt */
 #define Int_About	0x04	/* about trigger complete */
 #define Int_Hfull	0x02	/* A/D FIFO hlaf full */
@@ -182,23 +182,23 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 static int pci9118_detach(struct comedi_device * dev);
 
 struct boardtype {
-	const char *name;	// board name
-	int vendor_id;		// PCI vendor a device ID of card
+	const char *name;	/*  board name */
+	int vendor_id;		/*  PCI vendor a device ID of card */
 	int device_id;
-	int iorange_amcc;	// iorange for own S5933 region
-	int iorange_9118;	// pass thru card region size
-	int n_aichan;		// num of A/D chans
-	int n_aichand;		// num of A/D chans in diff mode
-	int mux_aichan;		// num of A/D chans with external multiplexor
-	int n_aichanlist;	// len of chanlist
-	int n_aochan;		// num of D/A chans
-	int ai_maxdata;		// resolution of A/D
-	int ao_maxdata;		// resolution of D/A
-	const struct comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const struct comedi_lrange *rangelist_ao;	// rangelist for D/A
-	unsigned int ai_ns_min;	// max sample speed of card v ns
-	unsigned int ai_pacer_min;	// minimal pacer value (c1*c2 or c1 in burst)
-	int half_fifo_size;	// size of FIFO/2
+	int iorange_amcc;	/*  iorange for own S5933 region */
+	int iorange_9118;	/*  pass thru card region size */
+	int n_aichan;		/*  num of A/D chans */
+	int n_aichand;		/*  num of A/D chans in diff mode */
+	int mux_aichan;		/*  num of A/D chans with external multiplexor */
+	int n_aichanlist;	/*  len of chanlist */
+	int n_aochan;		/*  num of D/A chans */
+	int ai_maxdata;		/*  resolution of A/D */
+	int ao_maxdata;		/*  resolution of D/A */
+	const struct comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
+	const struct comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
+	unsigned int ai_ns_min;	/*  max sample speed of card v ns */
+	unsigned int ai_pacer_min;	/*  minimal pacer value (c1*c2 or c1 in burst) */
+	int half_fifo_size;	/*  size of FIFO/2 */
 
 };
 
@@ -242,63 +242,63 @@ static struct comedi_driver driver_pci9118 = {
 COMEDI_PCI_INITCLEANUP(driver_pci9118, pci9118_pci_table);
 
 struct pci9118_private {
-	unsigned long iobase_a;	// base+size for AMCC chip
-	unsigned int master;	// master capable
-	struct pci_dev *pcidev;	// ptr to actual pcidev
-	unsigned int usemux;	// we want to use external multiplexor!
+	unsigned long iobase_a;	/*  base+size for AMCC chip */
+	unsigned int master;	/*  master capable */
+	struct pci_dev *pcidev;	/*  ptr to actual pcidev */
+	unsigned int usemux;	/*  we want to use external multiplexor! */
 #ifdef PCI9118_PARANOIDCHECK
-	unsigned short chanlist[PCI9118_CHANLEN + 1];	// list of scaned channel
-	unsigned char chanlistlen;	// number of scanlist
+	unsigned short chanlist[PCI9118_CHANLEN + 1];	/*  list of scaned channel */
+	unsigned char chanlistlen;	/*  number of scanlist */
 #endif
-	unsigned char AdControlReg;	// A/D control register
-	unsigned char IntControlReg;	// Interrupt control register
-	unsigned char AdFunctionReg;	// A/D function register
-	char valid;		// driver is ok
-	char ai_neverending;	// we do unlimited AI
-	unsigned int i8254_osc_base;	// frequence of onboard oscilator
-	unsigned int ai_do;	// what do AI? 0=nothing, 1 to 4 mode
-	unsigned int ai_act_scan;	// how many scans we finished
-	unsigned int ai_buf_ptr;	// data buffer ptr in samples
-	unsigned int ai_n_chan;	// how many channels is measured
-	unsigned int ai_n_scanlen;	// len of actual scanlist
-	unsigned int ai_n_realscanlen;	// what we must transfer for one outgoing scan include front/back adds
-	unsigned int ai_act_dmapos;	// position in actual real stream
-	unsigned int ai_add_front;	// how many channels we must add before scan to satisfy S&amp;H?
-	unsigned int ai_add_back;	// how many channels we must add before scan to satisfy DMA?
-	unsigned int *ai_chanlist;	// actaul chanlist
+	unsigned char AdControlReg;	/*  A/D control register */
+	unsigned char IntControlReg;	/*  Interrupt control register */
+	unsigned char AdFunctionReg;	/*  A/D function register */
+	char valid;		/*  driver is ok */
+	char ai_neverending;	/*  we do unlimited AI */
+	unsigned int i8254_osc_base;	/*  frequence of onboard oscilator */
+	unsigned int ai_do;	/*  what do AI? 0=nothing, 1 to 4 mode */
+	unsigned int ai_act_scan;	/*  how many scans we finished */
+	unsigned int ai_buf_ptr;	/*  data buffer ptr in samples */
+	unsigned int ai_n_chan;	/*  how many channels is measured */
+	unsigned int ai_n_scanlen;	/*  len of actual scanlist */
+	unsigned int ai_n_realscanlen;	/*  what we must transfer for one outgoing scan include front/back adds */
+	unsigned int ai_act_dmapos;	/*  position in actual real stream */
+	unsigned int ai_add_front;	/*  how many channels we must add before scan to satisfy S&amp;H? */
+	unsigned int ai_add_back;	/*  how many channels we must add before scan to satisfy DMA? */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
 	unsigned int ai_timer1;
 	unsigned int ai_timer2;
 	unsigned int ai_flags;
-	char ai12_startstop;	// measure can start/stop on external trigger
-	unsigned int ai_divisor1, ai_divisor2;	// divisors for start of measure on external start
+	char ai12_startstop;	/*  measure can start/stop on external trigger */
+	unsigned int ai_divisor1, ai_divisor2;	/*  divisors for start of measure on external start */
 	unsigned int ai_data_len;
 	short *ai_data;
-	short ao_data[2];	// data output buffer
-	unsigned int ai_scans;	// number of scans to do
-	char dma_doublebuf;	// we can use double buffring
-	unsigned int dma_actbuf;	// which buffer is used now
-	short *dmabuf_virt[2];	// pointers to begin of DMA buffer
-	unsigned long dmabuf_hw[2];	// hw address of DMA buff
-	unsigned int dmabuf_size[2];	// size of dma buffer in bytes
-	unsigned int dmabuf_use_size[2];	// which size we may now used for transfer
-	unsigned int dmabuf_used_size[2];	// which size was trully used
+	short ao_data[2];	/*  data output buffer */
+	unsigned int ai_scans;	/*  number of scans to do */
+	char dma_doublebuf;	/*  we can use double buffring */
+	unsigned int dma_actbuf;	/*  which buffer is used now */
+	short *dmabuf_virt[2];	/*  pointers to begin of DMA buffer */
+	unsigned long dmabuf_hw[2];	/*  hw address of DMA buff */
+	unsigned int dmabuf_size[2];	/*  size of dma buffer in bytes */
+	unsigned int dmabuf_use_size[2];	/*  which size we may now used for transfer */
+	unsigned int dmabuf_used_size[2];	/*  which size was trully used */
 	unsigned int dmabuf_panic_size[2];
-	unsigned int dmabuf_samples[2];	// size in samples
-	int dmabuf_pages[2];	// number of pages in buffer
-	unsigned char cnt0_users;	// bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO)
-	unsigned char exttrg_users;	// bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO)
-	unsigned int cnt0_divisor;	// actual CNT0 divisor
-	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	// ptr to actual interrupt AI function
-	unsigned char ai16bits;	// =1 16 bit card
-	unsigned char usedma;	// =1 use DMA transfer and not INT
-	unsigned char useeoshandle;	// =1 change WAKE_EOS DMA transfer to fit on every second
-	unsigned char usessh;	// =1 turn on S&amp;H support
-	int softsshdelay;	// &gt;0 use software S&amp;H, numer is requested delay in ns
-	unsigned char softsshsample;	// polarity of S&amp;H signal in sample state
-	unsigned char softsshhold;	// polarity of S&amp;H signal in hold state
-	unsigned int ai_maskerr;	// which warning was printed
-	unsigned int ai_maskharderr;	// on which error bits stops
-	unsigned int ai_inttrig_start;	// TRIG_INT for start
+	unsigned int dmabuf_samples[2];	/*  size in samples */
+	int dmabuf_pages[2];	/*  number of pages in buffer */
+	unsigned char cnt0_users;	/*  bit field of 8254 CNT0 users (0-unused, 1-AO, 2-DI, 3-DO) */
+	unsigned char exttrg_users;	/*  bit field of external trigger users (0-AI, 1-AO, 2-DI, 3-DO) */
+	unsigned int cnt0_divisor;	/*  actual CNT0 divisor */
+	void (*int_ai_func) (struct comedi_device *, struct comedi_subdevice *, unsigned short, unsigned int, unsigned short);	/*  ptr to actual interrupt AI function */
+	unsigned char ai16bits;	/*  =1 16 bit card */
+	unsigned char usedma;	/*  =1 use DMA transfer and not INT */
+	unsigned char useeoshandle;	/*  =1 change WAKE_EOS DMA transfer to fit on every second */
+	unsigned char usessh;	/*  =1 turn on S&amp;H support */
+	int softsshdelay;	/*  &gt;0 use software S&amp;H, numer is requested delay in ns */
+	unsigned char softsshsample;	/*  polarity of S&amp;H signal in sample state */
+	unsigned char softsshhold;	/*  polarity of S&amp;H signal in hold state */
+	unsigned int ai_maskerr;	/*  which warning was printed */
+	unsigned int ai_maskharderr;	/*  on which error bits stops */
+	unsigned int ai_inttrig_start;	/*  TRIG_INT for start */
 };
 
 #define devpriv ((struct pci9118_private *)dev-&gt;private)
@@ -335,12 +335,12 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 
 	devpriv-&gt;AdControlReg = AdControl_Int &amp; 0xff;
 	devpriv-&gt;AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv-&gt;AdFunctionReg, dev-&gt;iobase + PCI9118_ADFUNC);	// positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv-&gt;AdFunctionReg, dev-&gt;iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 
 	if (!setup_channel_list(dev, s, 1, &amp;insn-&gt;chanspec, 0, 0, 0, 0, 0))
 		return -EINVAL;
 
-	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 
 	for (n = 0; n &lt; insn-&gt;n; n++) {
 		outw(0, dev-&gt;iobase + PCI9118_SOFTTRG);	/* start conversion */
@@ -354,7 +354,7 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 
 		comedi_error(dev, "A/D insn timeout");
 		data[n] = 0;
-		outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	// flush FIFO
+		outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 		return -ETIME;
 
 	      conv_finish:
@@ -369,7 +369,7 @@ static int pci9118_insn_read_ai(struct comedi_device * dev, struct comedi_subdev
 		}
 	}
 
-	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 	return n;
 
 }
@@ -567,7 +567,7 @@ static void interrupt_pci9118_ai_onesample(struct comedi_device * dev,
 
 #ifdef PCI9118_PARANOIDCHECK
 	if (devpriv-&gt;ai16bits == 0) {
-		if ((sampl &amp; 0x000f) != devpriv-&gt;chanlist[s-&gt;async-&gt;cur_chan]) {	// data dropout!
+		if ((sampl &amp; 0x000f) != devpriv-&gt;chanlist[s-&gt;async-&gt;cur_chan]) {	/*  data dropout! */
 			rt_printk
 				("comedi: A/D  SAMPL - data dropout: received channel %d, expected %d!\n",
 				sampl &amp; 0x000f,
@@ -621,14 +621,14 @@ static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_s
 	}
 
 	if (int_adstat &amp; devpriv-&gt;ai_maskerr)
-//      if (int_adstat &amp; 0x106)
+/* if (int_adstat &amp; 0x106) */
 		if (pci9118_decode_error_status(dev, s, int_adstat))
 			return;
 
-	samplesinbuf = devpriv-&gt;dmabuf_use_size[devpriv-&gt;dma_actbuf] &gt;&gt; 1;	// number of received real samples
-//      DPRINTK("dma_actbuf=%d\n",devpriv-&gt;dma_actbuf);
+	samplesinbuf = devpriv-&gt;dmabuf_use_size[devpriv-&gt;dma_actbuf] &gt;&gt; 1;	/*  number of received real samples */
+/* DPRINTK("dma_actbuf=%d\n",devpriv-&gt;dma_actbuf); */
 
-	if (devpriv-&gt;dma_doublebuf) {	// switch DMA buffers if is used double buffering
+	if (devpriv-&gt;dma_doublebuf) {	/*  switch DMA buffers if is used double buffering */
 		next_dma_buf = 1 - devpriv-&gt;dma_actbuf;
 		outl(devpriv-&gt;dmabuf_hw[next_dma_buf],
 			devpriv-&gt;iobase_a + AMCC_OP_REG_MWAR);
@@ -641,15 +641,15 @@ static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_s
 	}
 
 	if (samplesinbuf) {
-		m = devpriv-&gt;ai_data_len &gt;&gt; 1;	// how many samples is to end of buffer
-//              DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s-&gt;async-&gt;buf_int_count,s-&gt;async-&gt;buf_int_ptr);
+		m = devpriv-&gt;ai_data_len &gt;&gt; 1;	/*  how many samples is to end of buffer */
+/* DPRINTK("samps=%d m=%d %d %d\n",samplesinbuf,m,s-&gt;async-&gt;buf_int_count,s-&gt;async-&gt;buf_int_ptr); */
 		sampls = m;
 		move_block_from_dma(dev, s,
 			devpriv-&gt;dmabuf_virt[devpriv-&gt;dma_actbuf],
 			samplesinbuf);
-		m = m - sampls;	// m= how many samples was transfered
+		m = m - sampls;	/*  m= how many samples was transfered */
 	}
-//      DPRINTK("YYY\n");
+/* DPRINTK("YYY\n"); */
 
 	if (!devpriv-&gt;ai_neverending)
 		if (devpriv-&gt;ai_act_scan &gt;= devpriv-&gt;ai_scans) {	/* all data sampled */
@@ -657,9 +657,9 @@ static void interrupt_pci9118_ai_dma(struct comedi_device * dev, struct comedi_s
 			s-&gt;async-&gt;events |= COMEDI_CB_EOA;
 		}
 
-	if (devpriv-&gt;dma_doublebuf) {	// switch dma buffers
+	if (devpriv-&gt;dma_doublebuf) {	/*  switch dma buffers */
 		devpriv-&gt;dma_actbuf = 1 - devpriv-&gt;dma_actbuf;
-	} else {		// restart DMA if is not used double buffering
+	} else {		/*  restart DMA if is not used double buffering */
 		outl(devpriv-&gt;dmabuf_hw[0],
 			devpriv-&gt;iobase_a + AMCC_OP_REG_MWAR);
 		outl(devpriv-&gt;dmabuf_use_size[0],
@@ -680,30 +680,30 @@ static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
 	unsigned int int_daq = 0, int_amcc, int_adstat;
 
 	if (!dev-&gt;attached)
-		return IRQ_NONE;	// not fully initialized
+		return IRQ_NONE;	/*  not fully initialized */
 
-	int_daq = inl(dev-&gt;iobase + PCI9118_INTSRC) &amp; 0xf;	// get IRQ reasons from card
-	int_amcc = inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	// get INT register from AMCC chip
+	int_daq = inl(dev-&gt;iobase + PCI9118_INTSRC) &amp; 0xf;	/*  get IRQ reasons from card */
+	int_amcc = inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	/*  get INT register from AMCC chip */
 
-//      DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv-&gt;iobase_a+AMCC_OP_REG_MWAR), inl(devpriv-&gt;iobase_a+AMCC_OP_REG_MWTC), inw(dev-&gt;iobase+PCI9118_ADSTAT)&amp;0x1ff,devpriv-&gt;ai_do);
+/* DPRINTK("INT daq=0x%01x amcc=0x%08x MWAR=0x%08x MWTC=0x%08x ADSTAT=0x%02x ai_do=%d\n", int_daq, int_amcc, inl(devpriv-&gt;iobase_a+AMCC_OP_REG_MWAR), inl(devpriv-&gt;iobase_a+AMCC_OP_REG_MWTC), inw(dev-&gt;iobase+PCI9118_ADSTAT)&amp;0x1ff,devpriv-&gt;ai_do); */
 
 	if ((!int_daq) &amp;&amp; (!(int_amcc &amp; ANY_S593X_INT)))
-		return IRQ_NONE;	// interrupt from other source
+		return IRQ_NONE;	/*  interrupt from other source */
 
-	outl(int_amcc | 0x00ff0000, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	// shutdown IRQ reasons in AMCC
+	outl(int_amcc | 0x00ff0000, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	/*  shutdown IRQ reasons in AMCC */
 
-	int_adstat = inw(dev-&gt;iobase + PCI9118_ADSTAT) &amp; 0x1ff;	// get STATUS register
+	int_adstat = inw(dev-&gt;iobase + PCI9118_ADSTAT) &amp; 0x1ff;	/*  get STATUS register */
 
 	if (devpriv-&gt;ai_do) {
 		if (devpriv-&gt;ai12_startstop)
-			if ((int_adstat &amp; AdStatus_DTH) &amp;&amp; (int_daq &amp; Int_DTrg)) {	// start stop of measure
+			if ((int_adstat &amp; AdStatus_DTH) &amp;&amp; (int_daq &amp; Int_DTrg)) {	/*  start stop of measure */
 				if (devpriv-&gt;ai12_startstop &amp; START_AI_EXT) {
 					devpriv-&gt;ai12_startstop &amp;=
 						~START_AI_EXT;
 					if (!(devpriv-&gt;ai12_startstop &amp;
 							STOP_AI_EXT))
-						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
-					start_pacer(dev, devpriv-&gt;ai_do, devpriv-&gt;ai_divisor1, devpriv-&gt;ai_divisor2);	// start pacer
+						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
+					start_pacer(dev, devpriv-&gt;ai_do, devpriv-&gt;ai_divisor1, devpriv-&gt;ai_divisor2);	/*  start pacer */
 					outl(devpriv-&gt;AdControlReg,
 						dev-&gt;iobase + PCI9118_ADCNTRL);
 				} else {
@@ -711,8 +711,8 @@ static irqreturn_t interrupt_pci9118(int irq, void *d PT_REGS_ARG)
 						ai12_startstop &amp; STOP_AI_EXT) {
 						devpriv-&gt;ai12_startstop &amp;=
 							~STOP_AI_EXT;
-						pci9118_exttrg_del(dev, EXTTRG_AI);	// deactivate EXT trigger
-						devpriv-&gt;ai_neverending = 0;	//well, on next interrupt from DMA/EOC measure will stop
+						pci9118_exttrg_del(dev, EXTTRG_AI);	/*  deactivate EXT trigger */
+						devpriv-&gt;ai_neverending = 0;	/* well, on next interrupt from DMA/EOC measure will stop */
 					}
 				}
 			}
@@ -949,11 +949,11 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 
 	if (cmd-&gt;scan_begin_src == TRIG_TIMER) {
 		tmp = cmd-&gt;scan_begin_arg;
-//              rt_printk("S1 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg);
+/* rt_printk("S1 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg); */
 		i8253_cascade_ns_to_timer(devpriv-&gt;i8254_osc_base, &amp;divisor1,
 			&amp;divisor2, &amp;cmd-&gt;scan_begin_arg,
 			cmd-&gt;flags &amp; TRIG_ROUND_MASK);
-//              rt_printk("S2 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg);
+/* rt_printk("S2 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg); */
 		if (cmd-&gt;scan_begin_arg &lt; this_board-&gt;ai_ns_min)
 			cmd-&gt;scan_begin_arg = this_board-&gt;ai_ns_min;
 		if (tmp != cmd-&gt;scan_begin_arg)
@@ -965,7 +965,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 		i8253_cascade_ns_to_timer(devpriv-&gt;i8254_osc_base, &amp;divisor1,
 			&amp;divisor2, &amp;cmd-&gt;convert_arg,
 			cmd-&gt;flags &amp; TRIG_ROUND_MASK);
-//              rt_printk("s1 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg);
+/* rt_printk("s1 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg); */
 		if (cmd-&gt;convert_arg &lt; this_board-&gt;ai_ns_min)
 			cmd-&gt;convert_arg = this_board-&gt;ai_ns_min;
 		if (tmp != cmd-&gt;convert_arg)
@@ -979,7 +979,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 					cmd-&gt;scan_begin_arg =
 						this_board-&gt;ai_ns_min *
 						(cmd-&gt;scan_end_arg + 2);
-//              rt_printk("s2 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg);
+/* rt_printk("s2 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg); */
 					err++;
 				}
 			} else {
@@ -988,7 +988,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 					cmd-&gt;scan_begin_arg =
 						cmd-&gt;convert_arg *
 						cmd-&gt;chanlist_len;
-//              rt_printk("s3 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg);
+/* rt_printk("s3 timer1=%u timer2=%u\n",cmd-&gt;scan_begin_arg,cmd-&gt;convert_arg); */
 					err++;
 				}
 			}
@@ -1001,7 +1001,7 @@ static int pci9118_ai_cmdtest(struct comedi_device * dev, struct comedi_subdevic
 	if (cmd-&gt;chanlist)
 		if (!check_channel_list(dev, s, cmd-&gt;chanlist_len,
 				cmd-&gt;chanlist, 0, 0))
-			return 5;	// incorrect channels list
+			return 5;	/*  incorrect channels list */
 
 	return 0;
 }
@@ -1018,26 +1018,26 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	dmalen1 = devpriv-&gt;dmabuf_size[1];
 	DPRINTK("1 dmalen0=%d dmalen1=%d ai_data_len=%d\n", dmalen0, dmalen1,
 		devpriv-&gt;ai_data_len);
-	// isn't output buff smaller that our DMA buff?
+	/*  isn't output buff smaller that our DMA buff? */
 	if (dmalen0 &gt; (devpriv-&gt;ai_data_len)) {
-		dmalen0 = devpriv-&gt;ai_data_len &amp; ~3L;	// allign to 32bit down
+		dmalen0 = devpriv-&gt;ai_data_len &amp; ~3L;	/*  allign to 32bit down */
 	}
 	if (dmalen1 &gt; (devpriv-&gt;ai_data_len)) {
-		dmalen1 = devpriv-&gt;ai_data_len &amp; ~3L;	// allign to 32bit down
+		dmalen1 = devpriv-&gt;ai_data_len &amp; ~3L;	/*  allign to 32bit down */
 	}
 	DPRINTK("2 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	// we want wake up every scan?
+	/*  we want wake up every scan? */
 	if (devpriv-&gt;ai_flags &amp; TRIG_WAKE_EOS) {
 		if (dmalen0 &lt; (devpriv-&gt;ai_n_realscanlen &lt;&lt; 1)) {
-			// uff, too short DMA buffer, disable EOS support!
+			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv-&gt;ai_flags &amp;= (~TRIG_WAKE_EOS);
 			rt_printk
 				("comedi%d: WAR: DMA0 buf too short, cann't support TRIG_WAKE_EOS (%d&lt;%d)\n",
 				dev-&gt;minor, dmalen0,
 				devpriv-&gt;ai_n_realscanlen &lt;&lt; 1);
 		} else {
-			// short first DMA buffer to one scan
+			/*  short first DMA buffer to one scan */
 			dmalen0 = devpriv-&gt;ai_n_realscanlen &lt;&lt; 1;
 			DPRINTK("21 dmalen0=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen0, devpriv-&gt;ai_n_realscanlen, devpriv-&gt;useeoshandle);
 			if (devpriv-&gt;useeoshandle)
@@ -1052,14 +1052,14 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	}
 	if (devpriv-&gt;ai_flags &amp; TRIG_WAKE_EOS) {
 		if (dmalen1 &lt; (devpriv-&gt;ai_n_realscanlen &lt;&lt; 1)) {
-			// uff, too short DMA buffer, disable EOS support!
+			/*  uff, too short DMA buffer, disable EOS support! */
 			devpriv-&gt;ai_flags &amp;= (~TRIG_WAKE_EOS);
 			rt_printk
 				("comedi%d: WAR: DMA1 buf too short, cann't support TRIG_WAKE_EOS (%d&lt;%d)\n",
 				dev-&gt;minor, dmalen1,
 				devpriv-&gt;ai_n_realscanlen &lt;&lt; 1);
 		} else {
-			// short second DMA buffer to one scan
+			/*  short second DMA buffer to one scan */
 			dmalen1 = devpriv-&gt;ai_n_realscanlen &lt;&lt; 1;
 			DPRINTK("22 dmalen1=%d ai_n_realscanlen=%d useeoshandle=%d\n", dmalen1, devpriv-&gt;ai_n_realscanlen, devpriv-&gt;useeoshandle);
 			if (devpriv-&gt;useeoshandle)
@@ -1074,26 +1074,26 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	}
 
 	DPRINTK("3 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
-	// transfer without TRIG_WAKE_EOS
+	/*  transfer without TRIG_WAKE_EOS */
 	if (!(devpriv-&gt;ai_flags &amp; TRIG_WAKE_EOS)) {
-		// if it's possible then allign DMA buffers to length of scan
+		/*  if it's possible then allign DMA buffers to length of scan */
 		i = dmalen0;
 		dmalen0 =
 			(dmalen0 / (devpriv-&gt;ai_n_realscanlen &lt;&lt; 1)) *
 			(devpriv-&gt;ai_n_realscanlen &lt;&lt; 1);
 		dmalen0 &amp;= ~3L;
 		if (!dmalen0)
-			dmalen0 = i;	// uff. very long scan?
+			dmalen0 = i;	/*  uff. very long scan? */
 		i = dmalen1;
 		dmalen1 =
 			(dmalen1 / (devpriv-&gt;ai_n_realscanlen &lt;&lt; 1)) *
 			(devpriv-&gt;ai_n_realscanlen &lt;&lt; 1);
 		dmalen1 &amp;= ~3L;
 		if (!dmalen1)
-			dmalen1 = i;	// uff. very long scan?
-		// if measure isn't neverending then test, if it whole fits into one or two DMA buffers
+			dmalen1 = i;	/*  uff. very long scan? */
+		/*  if measure isn't neverending then test, if it whole fits into one or two DMA buffers */
 		if (!devpriv-&gt;ai_neverending) {
-			// fits whole measure into one DMA buffer?
+			/*  fits whole measure into one DMA buffer? */
 			if (dmalen0 &gt;
 				((devpriv-&gt;ai_n_realscanlen &lt;&lt; 1) *
 					devpriv-&gt;ai_scans)) {
@@ -1104,7 +1104,7 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 				DPRINTK("3.1 dmalen0=%d dmalen1=%d \n", dmalen0,
 					dmalen1);
 				dmalen0 &amp;= ~3L;
-			} else {	// fits whole measure into two DMA buffer?
+			} else {	/*  fits whole measure into two DMA buffer? */
 				if (dmalen1 &gt;
 					((devpriv-&gt;ai_n_realscanlen &lt;&lt; 1) *
 						devpriv-&gt;ai_scans - dmalen0))
@@ -1121,7 +1121,7 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 
 	DPRINTK("4 dmalen0=%d dmalen1=%d \n", dmalen0, dmalen1);
 
-	// these DMA buffer size we'll be used
+	/*  these DMA buffer size we'll be used */
 	devpriv-&gt;dma_actbuf = 0;
 	devpriv-&gt;dmabuf_use_size[0] = dmalen0;
 	devpriv-&gt;dmabuf_use_size[1] = dmalen1;
@@ -1143,18 +1143,18 @@ static int Compute_and_setup_dma(struct comedi_device * dev)
 	}
 #endif
 
-	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR) &amp; (~EN_A2P_TRANSFERS), devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR) &amp; (~EN_A2P_TRANSFERS), devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
 	outl(devpriv-&gt;dmabuf_hw[0], devpriv-&gt;iobase_a + AMCC_OP_REG_MWAR);
 	outl(devpriv-&gt;dmabuf_use_size[0], devpriv-&gt;iobase_a + AMCC_OP_REG_MWTC);
-	// init DMA transfer
+	/*  init DMA transfer */
 	outl(0x00000000 | AINT_WRITE_COMPL,
 		devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);
-//      outl(0x02000000|AINT_WRITE_COMPL, devpriv-&gt;iobase_a+AMCC_OP_REG_INTCSR);
+/* outl(0x02000000|AINT_WRITE_COMPL, devpriv-&gt;iobase_a+AMCC_OP_REG_INTCSR); */
 
 	outl(inl(devpriv-&gt;iobase_a +
 			AMCC_OP_REG_MCSR) | RESET_A2P_FLAGS | A2P_HI_PRIORITY |
 		EN_A2P_TRANSFERS, devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR);
-	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	// allow bus mastering
+	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	/*  allow bus mastering */
 
 	DPRINTK("adl_pci9118 EDBG: END: Compute_and_setup_dma()\n");
 	return 0;
@@ -1186,17 +1186,17 @@ static int pci9118_ai_docmd_sampl(struct comedi_device * dev, struct comedi_subd
 		return -EIO;
 	};
 
-	devpriv-&gt;int_ai_func = interrupt_pci9118_ai_onesample;	//transfer function
+	devpriv-&gt;int_ai_func = interrupt_pci9118_ai_onesample;	/* transfer function */
 
 	if (devpriv-&gt;ai12_startstop)
-		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
 
 	if ((devpriv-&gt;ai_do == 1) || (devpriv-&gt;ai_do == 2))
 		devpriv-&gt;IntControlReg |= Int_Timer;
 
 	devpriv-&gt;AdControlReg |= AdControl_Int;
 
-	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 
 	if (!(devpriv-&gt;ai12_startstop &amp; (START_AI_EXT | START_AI_INT))) {
 		outl(devpriv-&gt;IntControlReg, dev-&gt;iobase + PCI9118_INTCTRL);
@@ -1261,10 +1261,10 @@ static int pci9118_ai_docmd_dma(struct comedi_device * dev, struct comedi_subdev
 	};
 
 	if (devpriv-&gt;ai12_startstop) {
-		pci9118_exttrg_add(dev, EXTTRG_AI);	// activate EXT trigger
+		pci9118_exttrg_add(dev, EXTTRG_AI);	/*  activate EXT trigger */
 	}
 
-	devpriv-&gt;int_ai_func = interrupt_pci9118_ai_dma;	//transfer function
+	devpriv-&gt;int_ai_func = interrupt_pci9118_ai_dma;	/* transfer function */
 
 	outl(0x02000000 | AINT_WRITE_COMPL,
 		devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);
@@ -1307,7 +1307,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 	devpriv-&gt;ai_add_back = 0;
 	devpriv-&gt;ai_maskerr = 0x10e;
 
-	// prepare for start/stop conditions
+	/*  prepare for start/stop conditions */
 	if (cmd-&gt;start_src == TRIG_EXT)
 		devpriv-&gt;ai12_startstop |= START_AI_EXT;
 	if (cmd-&gt;stop_src == TRIG_EXT) {
@@ -1334,19 +1334,19 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv-&gt;ai_scans = 0;
 	}
 
-	// use sample&amp;hold signal?
+	/*  use sample&amp;hold signal? */
 	if (cmd-&gt;convert_src == TRIG_NOW) {
 		devpriv-&gt;usessh = 1;
-	}			// yes
+	}			/*  yes */
 	else {
 		devpriv-&gt;usessh = 0;
-	}			// no
+	}			/*  no */
 
 	DPRINTK("1 neverending=%d scans=%u usessh=%d ai_startstop=0x%2x\n",
 		devpriv-&gt;ai_neverending, devpriv-&gt;ai_scans, devpriv-&gt;usessh,
 		devpriv-&gt;ai12_startstop);
 
-	// use additional sample at end of every scan to satisty DMA 32 bit transfer?
+	/*  use additional sample at end of every scan to satisty DMA 32 bit transfer? */
 	devpriv-&gt;ai_add_front = 0;
 	devpriv-&gt;ai_add_back = 0;
 	devpriv-&gt;useeoshandle = 0;
@@ -1358,27 +1358,27 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 				devpriv-&gt;ai_add_back = 1;
 			}
 			if (cmd-&gt;convert_src == TRIG_TIMER) {
-				devpriv-&gt;usedma = 0;	// use INT transfer if scanlist have only one channel
+				devpriv-&gt;usedma = 0;	/*  use INT transfer if scanlist have only one channel */
 			}
 		}
 		if ((cmd-&gt;flags &amp; TRIG_WAKE_EOS) &amp;&amp;
 			(devpriv-&gt;ai_n_scanlen &amp; 1) &amp;&amp;
 			(devpriv-&gt;ai_n_scanlen &gt; 1)) {
 			if (cmd-&gt;scan_begin_src == TRIG_FOLLOW) {
-				//vpriv-&gt;useeoshandle=1; // change DMA transfer block to fit EOS on every second call
-				devpriv-&gt;usedma = 0;	// XXX maybe can be corrected to use 16 bit DMA
-			} else {	// well, we must insert one sample to end of EOS to meet 32 bit transfer
+				/* vpriv-&gt;useeoshandle=1; // change DMA transfer block to fit EOS on every second call */
+				devpriv-&gt;usedma = 0;	/*  XXX maybe can be corrected to use 16 bit DMA */
+			} else {	/*  well, we must insert one sample to end of EOS to meet 32 bit transfer */
 				devpriv-&gt;ai_add_back = 1;
 			}
 		}
-	} else {		// interrupt transfer don't need any correction
+	} else {		/*  interrupt transfer don't need any correction */
 		devpriv-&gt;usedma = 0;
 	}
 
-	// we need software S&amp;H signal? It add  two samples before every scan as minimum
+	/*  we need software S&amp;H signal? It add  two samples before every scan as minimum */
 	if (devpriv-&gt;usessh &amp;&amp; devpriv-&gt;softsshdelay) {
 		devpriv-&gt;ai_add_front = 2;
-		if ((devpriv-&gt;usedma == 1) &amp;&amp; (devpriv-&gt;ai_add_back == 1)) {	// move it to front
+		if ((devpriv-&gt;usedma == 1) &amp;&amp; (devpriv-&gt;ai_add_back == 1)) {	/*  move it to front */
 			devpriv-&gt;ai_add_front++;
 			devpriv-&gt;ai_add_back = 0;
 		}
@@ -1387,17 +1387,17 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		addchans = devpriv-&gt;softsshdelay / cmd-&gt;convert_arg;
 		if (devpriv-&gt;softsshdelay % cmd-&gt;convert_arg)
 			addchans++;
-		if (addchans &gt; (devpriv-&gt;ai_add_front - 1)) {	// uff, still short :-(
+		if (addchans &gt; (devpriv-&gt;ai_add_front - 1)) {	/*  uff, still short :-( */
 			devpriv-&gt;ai_add_front = addchans + 1;
 			if (devpriv-&gt;usedma == 1)
 				if ((devpriv-&gt;ai_add_front +
 						devpriv-&gt;ai_n_chan +
 						devpriv-&gt;ai_add_back) &amp; 1)
-					devpriv-&gt;ai_add_front++;	// round up to 32 bit
+					devpriv-&gt;ai_add_front++;	/*  round up to 32 bit */
 		}
-	}			// well, we now know what must be all added
+	}			/*  well, we now know what must be all added */
 
-	devpriv-&gt;ai_n_realscanlen =	// what we must take from card in real to have ai_n_scanlen on output?
+	devpriv-&gt;ai_n_realscanlen =	/*  what we must take from card in real to have ai_n_scanlen on output? */
 		(devpriv-&gt;ai_add_front + devpriv-&gt;ai_n_chan +
 		devpriv-&gt;ai_add_back) * (devpriv-&gt;ai_n_scanlen /
 		devpriv-&gt;ai_n_chan);
@@ -1408,7 +1408,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv-&gt;ai_n_chan, devpriv-&gt;ai_add_back,
 		devpriv-&gt;ai_n_scanlen);
 
-	// check and setup channel list
+	/*  check and setup channel list */
 	if (!check_channel_list(dev, s, devpriv-&gt;ai_n_chan,
 			devpriv-&gt;ai_chanlist, devpriv-&gt;ai_add_front,
 			devpriv-&gt;ai_add_back))
@@ -1419,9 +1419,9 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 			devpriv-&gt;useeoshandle))
 		return -EINVAL;
 
-	// compute timers settings
-	// simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect
-	if (((cmd-&gt;scan_begin_src == TRIG_FOLLOW) || (cmd-&gt;scan_begin_src == TRIG_EXT) || (cmd-&gt;scan_begin_src == TRIG_INT)) &amp;&amp; (cmd-&gt;convert_src == TRIG_TIMER)) {	// both timer is used for one time
+	/*  compute timers settings */
+	/*  simplest way, fr=4Mhz/(tim1*tim2), channel manipulation without timers effect */
+	if (((cmd-&gt;scan_begin_src == TRIG_FOLLOW) || (cmd-&gt;scan_begin_src == TRIG_EXT) || (cmd-&gt;scan_begin_src == TRIG_INT)) &amp;&amp; (cmd-&gt;convert_src == TRIG_TIMER)) {	/*  both timer is used for one time */
 		if (cmd-&gt;scan_begin_src == TRIG_EXT) {
 			devpriv-&gt;ai_do = 4;
 		} else {
@@ -1435,7 +1435,7 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv-&gt;ai_timer2 = cmd-&gt;convert_arg;
 	}
 
-	if ((cmd-&gt;scan_begin_src == TRIG_TIMER) &amp;&amp; ((cmd-&gt;convert_src == TRIG_TIMER) || (cmd-&gt;convert_src == TRIG_NOW))) {	// double timed action
+	if ((cmd-&gt;scan_begin_src == TRIG_TIMER) &amp;&amp; ((cmd-&gt;convert_src == TRIG_TIMER) || (cmd-&gt;convert_src == TRIG_NOW))) {	/*  double timed action */
 		if (!devpriv-&gt;usedma) {
 			comedi_error(dev,
 				"cmd-&gt;scan_begin_src=TRIG_TIMER works only with bus mastering!");
@@ -1457,15 +1457,15 @@ static int pci9118_ai_cmd(struct comedi_device * dev, struct comedi_subdevice *
 		devpriv-&gt;ai_do = 3;
 	}
 
-	start_pacer(dev, -1, 0, 0);	// stop pacer
+	start_pacer(dev, -1, 0, 0);	/*  stop pacer */
 
-	devpriv-&gt;AdControlReg = 0;	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA
+	devpriv-&gt;AdControlReg = 0;	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable DMA */
 	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);
-	devpriv-&gt;AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	// positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	devpriv-&gt;AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;	/*  positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	outl(devpriv-&gt;AdFunctionReg, dev-&gt;iobase + PCI9118_ADFUNC);
 	comedi_udelay(1);
-	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	// flush FIFO
-	inl(dev-&gt;iobase + PCI9118_ADSTAT);	// flush A/D and INT status register
+	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	inl(dev-&gt;iobase + PCI9118_ADSTAT);	/*  flush A/D and INT status register */
 	inl(dev-&gt;iobase + PCI9118_INTSRC);
 
 	devpriv-&gt;ai_act_scan = 0;
@@ -1505,11 +1505,11 @@ static int check_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	// all input must be diff
+		differencial = 1;	/*  all input must be diff */
 	if (CR_RANGE(chanlist[0]) &lt; PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	// all input must be bipolar
+		bipolar = 1;	/*  all input must be bipolar */
 	if (n_chan &gt; 1)
-		for (i = 1; i &lt; n_chan; i++) {	// check S.E/diff
+		for (i = 1; i &lt; n_chan; i++) {	/*  check S.E/diff */
 			if ((CR_AREF(chanlist[i]) == AREF_DIFF) !=
 				(differencial)) {
 				comedi_error(dev,
@@ -1552,27 +1552,27 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	if (CR_AREF(chanlist[0]) == AREF_DIFF)
-		differencial = 1;	// all input must be diff
+		differencial = 1;	/*  all input must be diff */
 	if (CR_RANGE(chanlist[0]) &lt; PCI9118_BIPOLAR_RANGES)
-		bipolar = 1;	// all input must be bipolar
+		bipolar = 1;	/*  all input must be bipolar */
 
-	// All is ok, so we can setup channel/range list
+	/*  All is ok, so we can setup channel/range list */
 
 	if (!bipolar) {
-		devpriv-&gt;AdControlReg |= AdControl_UniP;	// set unibipolar
+		devpriv-&gt;AdControlReg |= AdControl_UniP;	/*  set unibipolar */
 	} else {
-		devpriv-&gt;AdControlReg &amp;= ((~AdControl_UniP) &amp; 0xff);	// enable bipolar
+		devpriv-&gt;AdControlReg &amp;= ((~AdControl_UniP) &amp; 0xff);	/*  enable bipolar */
 	}
 
 	if (differencial) {
-		devpriv-&gt;AdControlReg |= AdControl_Diff;	// enable diff inputs
+		devpriv-&gt;AdControlReg |= AdControl_Diff;	/*  enable diff inputs */
 	} else {
-		devpriv-&gt;AdControlReg &amp;= ((~AdControl_Diff) &amp; 0xff);	// set single ended inputs
+		devpriv-&gt;AdControlReg &amp;= ((~AdControl_Diff) &amp; 0xff);	/*  set single ended inputs */
 	}
 
-	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	// setup mode
+	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	/*  setup mode */
 
-	outl(2, dev-&gt;iobase + PCI9118_SCANMOD);	// gods know why this sequence!
+	outl(2, dev-&gt;iobase + PCI9118_SCANMOD);	/*  gods know why this sequence! */
 	outl(0, dev-&gt;iobase + PCI9118_SCANMOD);
 	outl(1, dev-&gt;iobase + PCI9118_SCANMOD);
 
@@ -1582,12 +1582,12 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 		devpriv-&gt;chanlist[i] = 0x55aa;
 #endif
 
-	if (frontadd) {		// insert channels for S&amp;H
+	if (frontadd) {		/*  insert channels for S&amp;H */
 		ssh = devpriv-&gt;softsshsample;
 		DPRINTK("FA: %04x: ", ssh);
-		for (i = 0; i &lt; frontadd; i++) {	// store range list to card
-			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
-			gain = CR_RANGE(chanlist[0]);	// get gain number
+		for (i = 0; i &lt; frontadd; i++) {	/*  store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
+			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
 			scanquad |= ((gain &amp; 0x03) &lt;&lt; 8);
 			outl(scanquad | ssh, dev-&gt;iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1597,23 +1597,23 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	}
 
 	DPRINTK("SL: ", ssh);
-	for (i = 0; i &lt; n_chan; i++) {	// store range list to card
-		scanquad = CR_CHAN(chanlist[i]);	// get channel number;
+	for (i = 0; i &lt; n_chan; i++) {	/*  store range list to card */
+		scanquad = CR_CHAN(chanlist[i]);	/*  get channel number; */
 #ifdef PCI9118_PARANOIDCHECK
 		devpriv-&gt;chanlist[i ^ usedma] = (scanquad &amp; 0xf) &lt;&lt; rot;
 #endif
-		gain = CR_RANGE(chanlist[i]);	// get gain number
+		gain = CR_RANGE(chanlist[i]);	/*  get gain number */
 		scanquad |= ((gain &amp; 0x03) &lt;&lt; 8);
 		outl(scanquad | ssh, dev-&gt;iobase + PCI9118_GAIN);
 		DPRINTK("%02x ", scanquad | ssh);
 	}
 	DPRINTK("\n ");
 
-	if (backadd) {		// insert channels for fit onto 32bit DMA
+	if (backadd) {		/*  insert channels for fit onto 32bit DMA */
 		DPRINTK("BA: %04x: ", ssh);
-		for (i = 0; i &lt; backadd; i++) {	// store range list to card
-			scanquad = CR_CHAN(chanlist[0]);	// get channel number;
-			gain = CR_RANGE(chanlist[0]);	// get gain number
+		for (i = 0; i &lt; backadd; i++) {	/*  store range list to card */
+			scanquad = CR_CHAN(chanlist[0]);	/*  get channel number; */
+			gain = CR_RANGE(chanlist[0]);	/*  get gain number */
 			scanquad |= ((gain &amp; 0x03) &lt;&lt; 8);
 			outl(scanquad | ssh, dev-&gt;iobase + PCI9118_GAIN);
 			DPRINTK("%02x ", scanquad | ssh);
@@ -1621,13 +1621,13 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 		DPRINTK("\n ");
 	}
 #ifdef PCI9118_PARANOIDCHECK
-	devpriv-&gt;chanlist[n_chan ^ usedma] = devpriv-&gt;chanlist[0 ^ usedma];	// for 32bit oerations
+	devpriv-&gt;chanlist[n_chan ^ usedma] = devpriv-&gt;chanlist[0 ^ usedma];	/*  for 32bit oerations */
 	if (useeos) {
-		for (i = 1; i &lt; n_chan; i++) {	// store range list to card
+		for (i = 1; i &lt; n_chan; i++) {	/*  store range list to card */
 			devpriv-&gt;chanlist[(n_chan + i) ^ usedma] =
 				(CR_CHAN(chanlist[i]) &amp; 0xf) &lt;&lt; rot;
 		}
-		devpriv-&gt;chanlist[(2 * n_chan) ^ usedma] = devpriv-&gt;chanlist[0 ^ usedma];	// for 32bit oerations
+		devpriv-&gt;chanlist[(2 * n_chan) ^ usedma] = devpriv-&gt;chanlist[0 ^ usedma];	/*  for 32bit oerations */
 		useeos = 2;
 	} else {
 		useeos = 1;
@@ -1640,11 +1640,11 @@ static int setup_channel_list(struct comedi_device * dev, struct comedi_subdevic
 	DPRINTK("\n ");
 #endif
 #endif
-	outl(0, dev-&gt;iobase + PCI9118_SCANMOD);	// close scan queue
-//      comedi_udelay(100);                             // important delay, or first sample will be cripled
+	outl(0, dev-&gt;iobase + PCI9118_SCANMOD);	/*  close scan queue */
+/* comedi_udelay(100);                               important delay, or first sample will be cripled */
 
 	DPRINTK("adl_pci9118 EDBG: END: setup_channel_list()\n");
-	return 1;		// we can serve this with scan logic
+	return 1;		/*  we can serve this with scan logic */
 }
 
 /*
@@ -1672,17 +1672,17 @@ static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 			*tim2 = this_board-&gt;ai_ns_min;
 		DPRINTK("1 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div1 = *tim2 / devpriv-&gt;i8254_osc_base;	// convert timer (burst)
+		*div1 = *tim2 / devpriv-&gt;i8254_osc_base;	/*  convert timer (burst) */
 		DPRINTK("2 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div1 &lt; this_board-&gt;ai_pacer_min)
 			*div1 = this_board-&gt;ai_pacer_min;
 		DPRINTK("3 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *tim1 / devpriv-&gt;i8254_osc_base;	// scan timer
+		*div2 = *tim1 / devpriv-&gt;i8254_osc_base;	/*  scan timer */
 		DPRINTK("4 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
-		*div2 = *div2 / *div1;	// major timer is c1*c2
+		*div2 = *div2 / *div1;	/*  major timer is c1*c2 */
 		DPRINTK("5 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 		if (*div2 &lt; chans)
@@ -1690,9 +1690,9 @@ static void pci9118_calc_divisors(char mode, struct comedi_device * dev,
 		DPRINTK("6 div1=%u div2=%u timer1=%u timer2=%u\n", *div1, *div2,
 			*tim1, *tim2);
 
-		*tim2 = *div1 * devpriv-&gt;i8254_osc_base;	// real convert timer
+		*tim2 = *div1 * devpriv-&gt;i8254_osc_base;	/*  real convert timer */
 
-		if (usessh &amp; (chnsshfront == 0))	// use BSSH signal
+		if (usessh &amp; (chnsshfront == 0))	/*  use BSSH signal */
 			if (*div2 &lt; (chans + 2))
 				*div2 = chans + 2;
 
@@ -1715,7 +1715,7 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
 {
 	outl(0x74, dev-&gt;iobase + PCI9118_CNTCTRL);
 	outl(0xb4, dev-&gt;iobase + PCI9118_CNTCTRL);
-//      outl(0x30, dev-&gt;iobase + PCI9118_CNTCTRL);
+/* outl(0x30, dev-&gt;iobase + PCI9118_CNTCTRL); */
 	comedi_udelay(1);
 
 	if ((mode == 1) || (mode == 2) || (mode == 4)) {
@@ -1732,11 +1732,11 @@ static void start_pacer(struct comedi_device * dev, int mode, unsigned int divis
 static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
 {
 	if (source &gt; 3)
-		return -1;	// incorrect source
+		return -1;	/*  incorrect source */
 	devpriv-&gt;exttrg_users |= (1 &lt;&lt; source);
 	devpriv-&gt;IntControlReg |= Int_DTrg;
 	outl(devpriv-&gt;IntControlReg, dev-&gt;iobase + PCI9118_INTCTRL);
-	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+	outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 	return 0;
 }
 
@@ -1746,12 +1746,12 @@ static int pci9118_exttrg_add(struct comedi_device * dev, unsigned char source)
 static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 {
 	if (source &gt; 3)
-		return -1;	// incorrect source
+		return -1;	/*  incorrect source */
 	devpriv-&gt;exttrg_users &amp;= ~(1 &lt;&lt; source);
-	if (!devpriv-&gt;exttrg_users) {	// shutdown ext trg intterrupts
+	if (!devpriv-&gt;exttrg_users) {	/*  shutdown ext trg intterrupts */
 		devpriv-&gt;IntControlReg &amp;= ~Int_DTrg;
-		if (!devpriv-&gt;IntControlReg)	// all IRQ disabled
-			outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) &amp; (~0x00001f00), devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	// disable int in AMCC
+		if (!devpriv-&gt;IntControlReg)	/*  all IRQ disabled */
+			outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) &amp; (~0x00001f00), devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	/*  disable int in AMCC */
 		outl(devpriv-&gt;IntControlReg, dev-&gt;iobase + PCI9118_INTCTRL);
 	}
 	return 0;
@@ -1763,17 +1763,17 @@ static int pci9118_exttrg_del(struct comedi_device * dev, unsigned char source)
 static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	if (devpriv-&gt;usedma)
-		outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR) &amp; (~EN_A2P_TRANSFERS), devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR);	// stop DMA
+		outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR) &amp; (~EN_A2P_TRANSFERS), devpriv-&gt;iobase_a + AMCC_OP_REG_MCSR);	/*  stop DMA */
 	pci9118_exttrg_del(dev, EXTTRG_AI);
-	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
 	devpriv-&gt;AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv-&gt;AdFunctionReg, dev-&gt;iobase + PCI9118_ADFUNC);	// positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv-&gt;AdFunctionReg, dev-&gt;iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 	devpriv-&gt;AdControlReg = 0x00;
-	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 	outl(0, dev-&gt;iobase + PCI9118_BURST);
 	outl(1, dev-&gt;iobase + PCI9118_SCANMOD);
-	outl(2, dev-&gt;iobase + PCI9118_SCANMOD);	// reset scan queue
-	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	// flush FIFO
+	outl(2, dev-&gt;iobase + PCI9118_SCANMOD);	/*  reset scan queue */
+	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	/*  flush FIFO */
 
 	devpriv-&gt;ai_do = 0;
 	devpriv-&gt;usedma = 0;
@@ -1787,7 +1787,7 @@ static int pci9118_ai_cancel(struct comedi_device * dev, struct comedi_subdevice
 	devpriv-&gt;dma_actbuf = 0;
 
 	if (!devpriv-&gt;IntControlReg)
-		outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	// allow INT in AMCC
+		outl(inl(devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR) | 0x1f00, devpriv-&gt;iobase_a + AMCC_OP_REG_INTCSR);	/*  allow INT in AMCC */
 
 	return 0;
 }
@@ -1800,31 +1800,31 @@ static int pci9118_reset(struct comedi_device * dev)
 	devpriv-&gt;IntControlReg = 0;
 	devpriv-&gt;exttrg_users = 0;
 	inl(dev-&gt;iobase + PCI9118_INTCTRL);
-	outl(devpriv-&gt;IntControlReg, dev-&gt;iobase + PCI9118_INTCTRL);	// disable interrupts source
+	outl(devpriv-&gt;IntControlReg, dev-&gt;iobase + PCI9118_INTCTRL);	/*  disable interrupts source */
 	outl(0x30, dev-&gt;iobase + PCI9118_CNTCTRL);
-//        outl(0xb4, dev-&gt;iobase + PCI9118_CNTCTRL);
-	start_pacer(dev, 0, 0, 0);	// stop 8254 counters
+/* outl(0xb4, dev-&gt;iobase + PCI9118_CNTCTRL); */
+	start_pacer(dev, 0, 0, 0);	/*  stop 8254 counters */
 	devpriv-&gt;AdControlReg = 0;
-	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 	outl(0, dev-&gt;iobase + PCI9118_BURST);
 	outl(1, dev-&gt;iobase + PCI9118_SCANMOD);
-	outl(2, dev-&gt;iobase + PCI9118_SCANMOD);	// reset scan queue
+	outl(2, dev-&gt;iobase + PCI9118_SCANMOD);	/*  reset scan queue */
 	devpriv-&gt;AdFunctionReg = AdFunction_PDTrg | AdFunction_PETrg;
-	outl(devpriv-&gt;AdFunctionReg, dev-&gt;iobase + PCI9118_ADFUNC);	// positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop
+	outl(devpriv-&gt;AdFunctionReg, dev-&gt;iobase + PCI9118_ADFUNC);	/*  positive triggers, no S&amp;H, no burst, burst stop, no post trigger, no about trigger, trigger stop */
 
 	devpriv-&gt;ao_data[0] = 2047;
 	devpriv-&gt;ao_data[1] = 2047;
-	outl(devpriv-&gt;ao_data[0], dev-&gt;iobase + PCI9118_DA1);	// reset A/D outs to 0V
+	outl(devpriv-&gt;ao_data[0], dev-&gt;iobase + PCI9118_DA1);	/*  reset A/D outs to 0V */
 	outl(devpriv-&gt;ao_data[1], dev-&gt;iobase + PCI9118_DA2);
-	outl(0, dev-&gt;iobase + PCI9118_DO);	// reset digi outs to L
+	outl(0, dev-&gt;iobase + PCI9118_DO);	/*  reset digi outs to L */
 	comedi_udelay(10);
 	inl(dev-&gt;iobase + PCI9118_AD_DATA);
-	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	// flush FIFO
-	outl(0, dev-&gt;iobase + PCI9118_INTSRC);	// remove INT requests
-	inl(dev-&gt;iobase + PCI9118_ADSTAT);	// flush A/D status register
-	inl(dev-&gt;iobase + PCI9118_INTSRC);	// flush INT requests
+	outl(0, dev-&gt;iobase + PCI9118_DELFIFO);	/*  flush FIFO */
+	outl(0, dev-&gt;iobase + PCI9118_INTSRC);	/*  remove INT requests */
+	inl(dev-&gt;iobase + PCI9118_ADSTAT);	/*  flush A/D status register */
+	inl(dev-&gt;iobase + PCI9118_INTSRC);	/*  flush INT requests */
 	devpriv-&gt;AdControlReg = 0;
-	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	// bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA
+	outl(devpriv-&gt;AdControlReg, dev-&gt;iobase + PCI9118_ADCNTRL);	/*  bipolar, S.E., use 8254, stop 8354, internal trigger, soft trigger, disable INT and DMA */
 
 	devpriv-&gt;cnt0_users = 0;
 	devpriv-&gt;exttrg_users = 0;
@@ -1854,7 +1854,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	opt_bus = it-&gt;options[0];
 	opt_slot = it-&gt;options[1];
 	if (it-&gt;options[3] &amp; 1) {
-		master = 0;	// user don't want use bus master
+		master = 0;	/*  user don't want use bus master */
 	} else {
 		master = 1;
 	}
@@ -1920,7 +1920,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	pci9118_reset(dev);
 
 	if (it-&gt;options[3] &amp; 2)
-		irq = 0;	// user don't want use IRQ
+		irq = 0;	/*  user don't want use IRQ */
 	if (irq &gt; 0) {
 		if (comedi_request_irq(irq, interrupt_pci9118, IRQF_SHARED,
 				"ADLink PCI-9118", dev)) {
@@ -1936,7 +1936,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 
 	dev-&gt;irq = irq;
 
-	if (master) {		// alloc DMA buffers
+	if (master) {		/*  alloc DMA buffers */
 		devpriv-&gt;dma_doublebuf = 0;
 		for (i = 0; i &lt; 2; i++) {
 			for (pages = 4; pages &gt;= 0; pages--)
@@ -1974,16 +1974,16 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	if (it-&gt;options[2] &gt; 0) {
 		devpriv-&gt;usemux = it-&gt;options[2];
 		if (devpriv-&gt;usemux &gt; 256)
-			devpriv-&gt;usemux = 256;	// max 256 channels!
+			devpriv-&gt;usemux = 256;	/*  max 256 channels! */
 		if (it-&gt;options[4] &gt; 0)
 			if (devpriv-&gt;usemux &gt; 128) {
-				devpriv-&gt;usemux = 128;	// max 128 channels with softare S&amp;H!
+				devpriv-&gt;usemux = 128;	/*  max 128 channels with softare S&amp;H! */
 			}
 		rt_printk(", ext. mux %d channels", devpriv-&gt;usemux);
 	}
 
 	devpriv-&gt;softsshdelay = it-&gt;options[4];
-	if (devpriv-&gt;softsshdelay &lt; 0) {	// select sample&amp;hold signal polarity
+	if (devpriv-&gt;softsshdelay &lt; 0) {	/*  select sample&amp;hold signal polarity */
 		devpriv-&gt;softsshdelay = -devpriv-&gt;softsshdelay;
 		devpriv-&gt;softsshsample = 0x80;
 		devpriv-&gt;softsshhold = 0x00;
@@ -1995,7 +1995,7 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	rt_printk(".\n");
 
 	pci_read_config_word(devpriv-&gt;pcidev, PCI_COMMAND, &amp;u16w);
-	pci_write_config_word(devpriv-&gt;pcidev, PCI_COMMAND, u16w | 64);	// Enable parity check for parity error
+	pci_write_config_word(devpriv-&gt;pcidev, PCI_COMMAND, u16w | 64);	/*  Enable parity check for parity error */
 
 	if ((ret = alloc_subdevices(dev, 4)) &lt; 0)
 		return ret;
@@ -2052,9 +2052,9 @@ static int pci9118_attach(struct comedi_device * dev, struct comedi_devconfig *
 	s-&gt;insn_bits = pci9118_insn_bits_do;
 
 	devpriv-&gt;valid = 1;
-	devpriv-&gt;i8254_osc_base = 250;	// 250ns=4MHz
-	devpriv-&gt;ai_maskharderr = 0x10a;	// default measure crash condition
-	if (it-&gt;options[5])	// disable some requested
+	devpriv-&gt;i8254_osc_base = 250;	/*  250ns=4MHz */
+	devpriv-&gt;ai_maskharderr = 0x10a;	/*  default measure crash condition */
+	if (it-&gt;options[5])	/*  disable some requested */
 		devpriv-&gt;ai_maskharderr &amp;= ~it-&gt;options[5];
 
 	switch (this_board-&gt;ai_maxdata) {</pre><hr><pre>commit 14458b19e51d434990d9a8c110ddeefd09678e64
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:18 2009 -0400

    Staging: comedi: remove C99 comments in adl_pci6208.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/adl_pci6208.c b/drivers/staging/comedi/drivers/adl_pci6208.c
index f710f551820d..7e27f92a9e6d 100644
--- a/drivers/staging/comedi/drivers/adl_pci6208.c
+++ b/drivers/staging/comedi/drivers/adl_pci6208.c
@@ -61,35 +61,35 @@ struct pci6208_board {
 	const char *name;
 	unsigned short dev_id;	/* `lspci` will show you this */
 	int ao_chans;
-	//int ao_bits;
+	/* int ao_bits; */
 };
 
 static const struct pci6208_board pci6208_boards[] = {
 	/*{
 	   name :  "pci6208v",
-	   dev_id       :  0x6208,      //not sure
+	   dev_id       :  0x6208,      // not sure
 	   ao_chans:  8
-	   //,  ao_bits :  16
+	   // ,  ao_bits :  16
 	   },
 	   {
 	   name :  "pci6216v",
-	   dev_id       :  0x6208,      //not sure
+	   dev_id       :  0x6208,      // not sure
 	   ao_chans:  16
-	   //,  ao_bits :  16
+	   // ,  ao_bits :  16
 	   }, */
 	{
 	      name:	"pci6208a",
 	      dev_id:	0x6208,
 	      ao_chans:8
-			//,     ao_bits :  16
+			/* ,     ao_bits :  16 */
 		}
 };
 
 /* This is used by modprobe to translate PCI IDs to drivers.  Should
  * only be used for PCI and ISA-PnP devices */
 static DEFINE_PCI_DEVICE_TABLE(pci6208_pci_table) = {
-	//{ PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	//{ PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	/* { PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
+	/* { PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 }, */
 	{PCI_VENDOR_ID_ADLINK, 0x6208, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0}
 };
@@ -132,10 +132,10 @@ static int pci6208_ao_winsn(struct comedi_device * dev, struct comedi_subdevice
 	struct comedi_insn * insn, unsigned int * data);
 static int pci6208_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice * s,
 	struct comedi_insn * insn, unsigned int * data);
-//static int pci6208_dio_insn_bits(struct comedi_device *dev,struct comedi_subdevice *s,
-//      struct comedi_insn *insn,unsigned int *data);
-//static int pci6208_dio_insn_config(struct comedi_device *dev,struct comedi_subdevice *s,
-//      struct comedi_insn *insn,unsigned int *data);
+/* static int pci6208_dio_insn_bits(struct comedi_device *dev,struct comedi_subdevice *s, */
+/* struct comedi_insn *insn,unsigned int *data); */
+/* static int pci6208_dio_insn_config(struct comedi_device *dev,struct comedi_subdevice *s, */
+/* struct comedi_insn *insn,unsigned int *data); */
 
 /*
  * Attach is called by the Comedi core to configure the driver
@@ -176,22 +176,22 @@ static int pci6208_attach(struct comedi_device * dev, struct comedi_devconfig *
 	s = dev-&gt;subdevices + 0;
 	/* analog output subdevice */
 	s-&gt;type = COMEDI_SUBD_AO;
-	s-&gt;subdev_flags = SDF_WRITABLE;	//anything else to add here??
+	s-&gt;subdev_flags = SDF_WRITABLE;	/* anything else to add here?? */
 	s-&gt;n_chan = thisboard-&gt;ao_chans;
-	s-&gt;maxdata = 0xffff;	//16-bit DAC
-	s-&gt;range_table = &amp;range_bipolar10;	//this needs to be checked.
+	s-&gt;maxdata = 0xffff;	/* 16-bit DAC */
+	s-&gt;range_table = &amp;range_bipolar10;	/* this needs to be checked. */
 	s-&gt;insn_write = pci6208_ao_winsn;
 	s-&gt;insn_read = pci6208_ao_rinsn;
 
-	//s=dev-&gt;subdevices+1;
+	/* s=dev-&gt;subdevices+1; */
 	/* digital i/o subdevice */
-	//s-&gt;type=COMEDI_SUBD_DIO;
-	//s-&gt;subdev_flags=SDF_READABLE|SDF_WRITABLE;
-	//s-&gt;n_chan=16;
-	//s-&gt;maxdata=1;
-	//s-&gt;range_table=&amp;range_digital;
-	//s-&gt;insn_bits = pci6208_dio_insn_bits;
-	//s-&gt;insn_config = pci6208_dio_insn_config;
+	/* s-&gt;type=COMEDI_SUBD_DIO; */
+	/* s-&gt;subdev_flags=SDF_READABLE|SDF_WRITABLE; */
+	/* s-&gt;n_chan=16; */
+	/* s-&gt;maxdata=1; */
+	/* s-&gt;range_table=&amp;range_digital; */
+	/* s-&gt;insn_bits = pci6208_dio_insn_bits; */
+	/* s-&gt;insn_config = pci6208_dio_insn_config; */
 
 	printk("attached\n");
 
@@ -262,49 +262,49 @@ static int pci6208_ao_rinsn(struct comedi_device * dev, struct comedi_subdevice
  * useful to applications if you implement the insn_bits interface.
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write */
-//static int pci6208_dio_insn_bits(struct comedi_device *dev,struct comedi_subdevice *s,
-//      struct comedi_insn *insn,unsigned int *data)
-//{
-//      if(insn-&gt;n!=2)return -EINVAL;
+/* static int pci6208_dio_insn_bits(struct comedi_device *dev,struct comedi_subdevice *s, */
+/* struct comedi_insn *insn,unsigned int *data) */
+/* { */
+/* if(insn-&gt;n!=2)return -EINVAL; */
 
 	/* The insn data is a mask in data[0] and the new data
 	 * in data[1], each channel cooresponding to a bit. */
-//      if(data[0]){
-//              s-&gt;state &amp;= ~data[0];
-//              s-&gt;state |= data[0]&amp;data[1];
+/* if(data[0]){ */
+/* s-&gt;state &amp;= ~data[0]; */
+/* s-&gt;state |= data[0]&amp;data[1]; */
 		/* Write out the new digital output lines */
-		//outw(s-&gt;state,dev-&gt;iobase + SKEL_DIO);
-//      }
+		/* outw(s-&gt;state,dev-&gt;iobase + SKEL_DIO); */
+/* } */
 
 	/* on return, data[1] contains the value of the digital
 	 * input and output lines. */
-	//data[1]=inw(dev-&gt;iobase + SKEL_DIO);
+	/* data[1]=inw(dev-&gt;iobase + SKEL_DIO); */
 	/* or we could just return the software copy of the output values if
 	 * it was a purely digital output subdevice */
-	//data[1]=s-&gt;state;
+	/* data[1]=s-&gt;state; */
 
-//      return 2;
-//}
+/* return 2; */
+/* } */
 
-//static int pci6208_dio_insn_config(struct comedi_device *dev,struct comedi_subdevice *s,
-//      struct comedi_insn *insn,unsigned int *data)
-//{
-//      int chan=CR_CHAN(insn-&gt;chanspec);
+/* static int pci6208_dio_insn_config(struct comedi_device *dev,struct comedi_subdevice *s, */
+/* struct comedi_insn *insn,unsigned int *data) */
+/* { */
+/* int chan=CR_CHAN(insn-&gt;chanspec); */
 
 	/* The input or output configuration of each digital line is
 	 * configured by a special insn_config instruction.  chanspec
 	 * contains the channel to be changed, and data[0] contains the
 	 * value COMEDI_INPUT or COMEDI_OUTPUT. */
 
-//      if(data[0]==COMEDI_OUTPUT){
-//              s-&gt;io_bits |= 1&lt;&lt;chan;
-//      }else{
-//              s-&gt;io_bits &amp;= ~(1&lt;&lt;chan);
-//      }
-	//outw(s-&gt;io_bits,dev-&gt;iobase + SKEL_DIO_CONFIG);
+/* if(data[0]==COMEDI_OUTPUT){ */
+/* s-&gt;io_bits |= 1&lt;&lt;chan; */
+/* }else{ */
+/* s-&gt;io_bits &amp;= ~(1&lt;&lt;chan); */
+/* } */
+	/* outw(s-&gt;io_bits,dev-&gt;iobase + SKEL_DIO_CONFIG); */
 
-//      return 1;
-//}
+/* return 1; */
+/* } */
 
 static int pci6208_find_device(struct comedi_device * dev, int bus, int slot)
 {
@@ -317,9 +317,9 @@ static int pci6208_find_device(struct comedi_device * dev, int bus, int slot)
 		if (pci_dev-&gt;vendor == PCI_VENDOR_ID_ADLINK) {
 			for (i = 0; i &lt; pci6208_board_nbr; i++) {
 				if (pci6208_boards[i].dev_id == pci_dev-&gt;device) {
-					// was a particular bus/slot requested?
+					/*  was a particular bus/slot requested? */
 					if ((bus != 0) || (slot != 0)) {
-						// are we on the wrong bus/slot?
+						/*  are we on the wrong bus/slot? */
 						if (pci_dev-&gt;bus-&gt;number
 							!= bus ||
 							PCI_SLOT(pci_dev-&gt;devfn)
@@ -346,10 +346,10 @@ static int pci6208_find_device(struct comedi_device * dev, int bus, int slot)
 		PCI_SLOT(pci_dev-&gt;devfn),
 		PCI_FUNC(pci_dev-&gt;devfn), pci_dev-&gt;irq);
 
-	// TODO: Warn about non-tested boards.
-	//switch(board-&gt;device_id)
-	//{
-	//};
+	/*  TODO: Warn about non-tested boards. */
+	/* switch(board-&gt;device_id) */
+	/* { */
+	/* }; */
 
 	devpriv-&gt;pci_dev = pci_dev;
 
@@ -362,19 +362,19 @@ pci6208_pci_setup(struct pci_dev *pci_dev, unsigned long *io_base_ptr,
 {
 	unsigned long io_base, io_range, lcr_io_base, lcr_io_range;
 
-	// Enable PCI device and request regions
+	/*  Enable PCI device and request regions */
 	if (comedi_pci_enable(pci_dev, PCI6208_DRIVER_NAME) &lt; 0) {
 		printk("comedi%d: Failed to enable PCI device and request regions\n", dev_minor);
 		return -EIO;
 	}
-	// Read local configuration register base address [PCI_BASE_ADDRESS #1].
+	/*  Read local configuration register base address [PCI_BASE_ADDRESS #1]. */
 	lcr_io_base = pci_resource_start(pci_dev, 1);
 	lcr_io_range = pci_resource_len(pci_dev, 1);
 
 	printk("comedi%d: local config registers at address 0x%4lx [0x%4lx]\n",
 		dev_minor, lcr_io_base, lcr_io_range);
 
-	// Read PCI6208 register base address [PCI_BASE_ADDRESS #2].
+	/*  Read PCI6208 register base address [PCI_BASE_ADDRESS #2]. */
 	io_base = pci_resource_start(pci_dev, 2);
 	io_range = pci_resource_end(pci_dev, 2) - io_base + 1;
 
@@ -382,10 +382,10 @@ pci6208_pci_setup(struct pci_dev *pci_dev, unsigned long *io_base_ptr,
 		dev_minor, io_base, io_range);
 
 	*io_base_ptr = io_base;
-	//devpriv-&gt;io_range = io_range;
-	//devpriv-&gt;is_valid=0;
-	//devpriv-&gt;lcr_io_base=lcr_io_base;
-	//devpriv-&gt;lcr_io_range=lcr_io_range;
+	/* devpriv-&gt;io_range = io_range; */
+	/* devpriv-&gt;is_valid=0; */
+	/* devpriv-&gt;lcr_io_base=lcr_io_base; */
+	/* devpriv-&gt;lcr_io_range=lcr_io_range; */
 
 	return 0;
 }</pre><hr><pre>commit 1efd18f0cca7251a283625e07dbb4ec8e95a4b6b
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:12 2009 -0400

    Staging: comedi: remove C99 comments in hwdrv_apci3120.c
    
    This replaces C99 comments with traditional C comments.  This
    also removes 3 blocks of code that were already commented out.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
index f3556e0d52cb..4808acbebd8c 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
@@ -47,7 +47,7 @@ You shoud also find the complete GPL in the COPYING file accompanying this sourc
 #include "hwdrv_apci3120.h"
 static unsigned int ui_Temp = 0;
 
-// FUNCTION DEFINITIONS
+/* FUNCTION DEFINITIONS */
 
 /*
 +----------------------------------------------------------------------------+
@@ -82,12 +82,12 @@ int i_APCI3120_InsnConfigAnalogInput(struct comedi_device * dev, struct comedi_s
 	if ((data[0] != APCI3120_EOC_MODE) &amp;&amp; (data[0] != APCI3120_EOS_MODE))
 		return -1;
 
-	// Check for Conversion time to be added ??
+	/*  Check for Conversion time to be added ?? */
 	devpriv-&gt;ui_EocEosConversionTime = data[2];
 
 	if (data[0] == APCI3120_EOS_MODE) {
 
-		//Test the number of the channel
+		/* Test the number of the channel */
 		for (i = 0; i &lt; data[3]; i++) {
 
 			if (CR_CHAN(data[4 + i]) &gt;= this_board-&gt;i_NbrAiChannel) {
@@ -102,14 +102,14 @@ int i_APCI3120_InsnConfigAnalogInput(struct comedi_device * dev, struct comedi_s
 			devpriv-&gt;b_EocEosInterrupt = APCI3120_ENABLE;
 		} else
 			devpriv-&gt;b_EocEosInterrupt = APCI3120_DISABLE;
-		// Copy channel list and Range List to devpriv
+		/*  Copy channel list and Range List to devpriv */
 
 		devpriv-&gt;ui_AiNbrofChannels = data[3];
 		for (i = 0; i &lt; devpriv-&gt;ui_AiNbrofChannels; i++) {
 			devpriv-&gt;ui_AiChannelList[i] = data[4 + i];
 		}
 
-	} else			// EOC
+	} else			/*  EOC */
 	{
 		devpriv-&gt;b_InterruptMode = APCI3120_EOC_MODE;
 		if (data[1]) {
@@ -151,22 +151,22 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 	unsigned short us_ConvertTiming, us_TmpValue, i;
 	unsigned char b_Tmp;
 
-	// fix convertion time to 10 us
+	/*  fix convertion time to 10 us */
 	if (!devpriv-&gt;ui_EocEosConversionTime) {
 		printk("No timer0 Value using 10 us\n");
 		us_ConvertTiming = 10;
 	} else
-		us_ConvertTiming = (unsigned short) (devpriv-&gt;ui_EocEosConversionTime / 1000);	// nano to useconds
+		us_ConvertTiming = (unsigned short) (devpriv-&gt;ui_EocEosConversionTime / 1000);	/*  nano to useconds */
 
-	// this_board-&gt;i_hwdrv_InsnReadAnalogInput(dev,us_ConvertTiming,insn-&gt;n,&amp;insn-&gt;chanspec,data,insn-&gt;unused[0]);
+	/*  this_board-&gt;i_hwdrv_InsnReadAnalogInput(dev,us_ConvertTiming,insn-&gt;n,&amp;insn-&gt;chanspec,data,insn-&gt;unused[0]); */
 
-	// Clear software registers
+	/*  Clear software registers */
 	devpriv-&gt;b_TimerSelectMode = 0;
 	devpriv-&gt;b_ModeSelectRegister = 0;
 	devpriv-&gt;us_OutputRegister = 0;
-//        devpriv-&gt;b_DigitalOutputRegister=0;
+/* devpriv-&gt;b_DigitalOutputRegister=0; */
 
-	if (insn-&gt;unused[0] == 222)	// second insn read
+	if (insn-&gt;unused[0] == 222)	/*  second insn read */
 	{
 
 		for (i = 0; i &lt; insn-&gt;n; i++) {
@@ -174,14 +174,16 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 		}
 
 	} else {
-		devpriv-&gt;tsk_Current = current;	// Save the current process task structure
-		//Testing if board have the new Quartz and calculate the time value
-		//to set in the timer
+		devpriv-&gt;tsk_Current = current;	/*  Save the current process task structure */
+/*
+ * Testing if board have the new Quartz and calculate the time value
+ * to set in the timer
+ */
 
 		us_TmpValue =
 			(unsigned short) inw(devpriv-&gt;iobase + APCI3120_RD_STATUS);
 
-		//EL250804: Testing if board APCI3120 have the new Quartz or if it is an APCI3001
+		/* EL250804: Testing if board APCI3120 have the new Quartz or if it is an APCI3001 */
 		if ((us_TmpValue &amp; 0x00B0) == 0x00B0
 			|| !strcmp(this_board-&gt;pc_DriverName, "apci3001")) {
 			us_ConvertTiming = (us_ConvertTiming * 2) - 2;
@@ -196,19 +198,20 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 
 		case APCI3120_EOC_MODE:
 
-			// Testing the interrupt flag and set the EOC bit
-			// Clears the FIFO
+/*
+ * Testing the interrupt flag and set the EOC bit Clears the FIFO
+ */
 			inw(devpriv-&gt;iobase + APCI3120_RESET_FIFO);
 
-			// Initialize the sequence array
+			/*  Initialize the sequence array */
 
-			//if (!i_APCI3120_SetupChannelList(dev,s,1,chanlist,0))  return -EINVAL;
+			/* if (!i_APCI3120_SetupChannelList(dev,s,1,chanlist,0))  return -EINVAL; */
 
 			if (!i_APCI3120_SetupChannelList(dev, s, 1,
 					&amp;insn-&gt;chanspec, 0))
 				return -EINVAL;
 
-			//Initialize Timer 0 mode 4
+			/* Initialize Timer 0 mode 4 */
 			devpriv-&gt;b_TimerSelectMode =
 				(devpriv-&gt;
 				b_TimerSelectMode &amp; 0xFC) |
@@ -216,14 +219,14 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 			outb(devpriv-&gt;b_TimerSelectMode,
 				devpriv-&gt;iobase + APCI3120_TIMER_CRT1);
 
-			// Reset the scan bit and Disables the  EOS, DMA, EOC interrupt
+			/*  Reset the scan bit and Disables the  EOS, DMA, EOC interrupt */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister &amp; APCI3120_DISABLE_SCAN;
 
 			if (devpriv-&gt;b_EocEosInterrupt == APCI3120_ENABLE) {
 
-				//Disables the EOS,DMA and enables the EOC interrupt
+				/* Disables the EOS,DMA and enables the EOC interrupt */
 				devpriv-&gt;b_ModeSelectRegister =
 					(devpriv-&gt;
 					b_ModeSelectRegister &amp;
@@ -241,7 +244,7 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 			outb(devpriv-&gt;b_ModeSelectRegister,
 				devpriv-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-			// Sets gate 0
+			/*  Sets gate 0 */
 			devpriv-&gt;us_OutputRegister =
 				(devpriv-&gt;
 				us_OutputRegister &amp; APCI3120_CLEAR_PA_PR) |
@@ -249,13 +252,13 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 			outw(devpriv-&gt;us_OutputRegister,
 				devpriv-&gt;iobase + APCI3120_WR_ADDRESS);
 
-			// Select Timer 0
+			/*  Select Timer 0 */
 			b_Tmp = ((devpriv-&gt;
 					b_DigitalOutputRegister) &amp; 0xF0) |
 				APCI3120_SELECT_TIMER_0_WORD;
 			outb(b_Tmp, devpriv-&gt;iobase + APCI3120_TIMER_CRT0);
 
-			//Set the convertion time
+			/* Set the convertion time */
 			outw(us_ConvertTiming,
 				devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
 
@@ -265,14 +268,14 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 			if (devpriv-&gt;b_EocEosInterrupt == APCI3120_DISABLE) {
 
 				do {
-					// Waiting for the end of conversion
+					/*  Waiting for the end of conversion */
 					us_TmpValue =
 						inw(devpriv-&gt;iobase +
 						APCI3120_RD_STATUS);
 				} while ((us_TmpValue &amp; APCI3120_EOC) ==
 					APCI3120_EOC);
 
-				//Read the result in FIFO  and put it in insn data pointer
+				/* Read the result in FIFO  and put it in insn data pointer */
 				us_TmpValue = inw(devpriv-&gt;iobase + 0);
 				*data = us_TmpValue;
 
@@ -284,9 +287,9 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 		case APCI3120_EOS_MODE:
 
 			inw(devpriv-&gt;iobase);
-			// Clears the FIFO
+			/*  Clears the FIFO */
 			inw(devpriv-&gt;iobase + APCI3120_RESET_FIFO);
-			// clear PA PR  and disable timer 0
+			/*  clear PA PR  and disable timer 0 */
 
 			devpriv-&gt;us_OutputRegister =
 				(devpriv-&gt;
@@ -301,7 +304,7 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 					devpriv-&gt;ui_AiChannelList, 0))
 				return -EINVAL;
 
-			//Initialize Timer 0 mode 2
+			/* Initialize Timer 0 mode 2 */
 			devpriv-&gt;b_TimerSelectMode =
 				(devpriv-&gt;
 				b_TimerSelectMode &amp; 0xFC) |
@@ -309,26 +312,26 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 			outb(devpriv-&gt;b_TimerSelectMode,
 				devpriv-&gt;iobase + APCI3120_TIMER_CRT1);
 
-			//Select Timer 0
+			/* Select Timer 0 */
 			b_Tmp = ((devpriv-&gt;
 					b_DigitalOutputRegister) &amp; 0xF0) |
 				APCI3120_SELECT_TIMER_0_WORD;
 			outb(b_Tmp, devpriv-&gt;iobase + APCI3120_TIMER_CRT0);
 
-			//Set the convertion time
+			/* Set the convertion time */
 			outw(us_ConvertTiming,
 				devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
 
-			//Set the scan bit
+			/* Set the scan bit */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister | APCI3120_ENABLE_SCAN;
 			outb(devpriv-&gt;b_ModeSelectRegister,
 				devpriv-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-			//If Interrupt function is loaded
+			/* If Interrupt function is loaded */
 			if (devpriv-&gt;b_EocEosInterrupt == APCI3120_ENABLE) {
-				//Disables the EOC,DMA and enables the EOS interrupt
+				/* Disables the EOC,DMA and enables the EOS interrupt */
 				devpriv-&gt;b_ModeSelectRegister =
 					(devpriv-&gt;
 					b_ModeSelectRegister &amp;
@@ -347,7 +350,7 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 
 			inw(devpriv-&gt;iobase + APCI3120_RD_STATUS);
 
-			//Sets gate 0
+			/* Sets gate 0 */
 
 			devpriv-&gt;us_OutputRegister =
 				devpriv-&gt;
@@ -355,12 +358,12 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 			outw(devpriv-&gt;us_OutputRegister,
 				devpriv-&gt;iobase + APCI3120_WR_ADDRESS);
 
-			//Start conversion
+			/* Start conversion */
 			outw(0, devpriv-&gt;iobase + APCI3120_START_CONVERSION);
 
-			//Waiting of end of convertion if interrupt is not installed
+			/* Waiting of end of convertion if interrupt is not installed */
 			if (devpriv-&gt;b_EocEosInterrupt == APCI3120_DISABLE) {
-				//Waiting the end of convertion
+				/* Waiting the end of convertion */
 				do {
 					us_TmpValue =
 						inw(devpriv-&gt;iobase +
@@ -371,12 +374,12 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 
 				for (i = 0; i &lt; devpriv-&gt;ui_AiNbrofChannels;
 					i++) {
-					//Read the result in FIFO and write them in shared memory
+					/* Read the result in FIFO and write them in shared memory */
 					us_TmpValue = inw(devpriv-&gt;iobase);
 					data[i] = (unsigned int) us_TmpValue;
 				}
 
-				devpriv-&gt;b_InterruptMode = APCI3120_EOC_MODE;	// Restore defaults.
+				devpriv-&gt;b_InterruptMode = APCI3120_EOC_MODE;	/*  Restore defaults. */
 			}
 			break;
 
@@ -384,7 +387,7 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 			printk("inputs wrong\n");
 
 		}
-		devpriv-&gt;ui_EocEosConversionTime = 0;	// re initializing the variable;
+		devpriv-&gt;ui_EocEosConversionTime = 0;	/*  re initializing the variable; */
 	}
 
 	return insn-&gt;n;
@@ -411,36 +414,39 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device * dev, struct comedi_sub
 
 int i_APCI3120_StopCyclicAcquisition(struct comedi_device * dev, struct comedi_subdevice * s)
 {
-	// Disable A2P Fifo write and AMWEN signal
+	/*  Disable A2P Fifo write and AMWEN signal */
 	outw(0, devpriv-&gt;i_IobaseAddon + 4);
 
-	//Disable Bus Master ADD ON
+	/* Disable Bus Master ADD ON */
 	outw(APCI3120_ADD_ON_AGCSTS_LOW, devpriv-&gt;i_IobaseAddon + 0);
 	outw(0, devpriv-&gt;i_IobaseAddon + 2);
 	outw(APCI3120_ADD_ON_AGCSTS_HIGH, devpriv-&gt;i_IobaseAddon + 0);
 	outw(0, devpriv-&gt;i_IobaseAddon + 2);
 
-	//Disable BUS Master PCI
+	/* Disable BUS Master PCI */
 	outl(0, devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_MCSR);
 
-	//outl(inl(devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_INTCSR)&amp;(~AINT_WRITE_COMPL), devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_INTCSR);    // stop amcc irqs
-	//outl(inl(devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_MCSR)&amp;(~EN_A2P_TRANSFERS), devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_MCSR); // stop DMA
+	/* outl(inl(devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_INTCSR)&amp;(~AINT_WRITE_COMPL),
+	 * devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_INTCSR);  stop amcc irqs */
+
+	/* outl(inl(devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_MCSR)&amp;(~EN_A2P_TRANSFERS),
+	 * devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_MCSR);  stop DMA */
 
-	//Disable ext trigger
+	/* Disable ext trigger */
 	i_APCI3120_ExttrigDisable(dev);
 
 	devpriv-&gt;us_OutputRegister = 0;
-	//stop  counters
+	/* stop  counters */
 	outw(devpriv-&gt;
 		us_OutputRegister &amp; APCI3120_DISABLE_TIMER0 &amp;
 		APCI3120_DISABLE_TIMER1, dev-&gt;iobase + APCI3120_WR_ADDRESS);
 
 	outw(APCI3120_DISABLE_ALL_TIMER, dev-&gt;iobase + APCI3120_WR_ADDRESS);
 
-	//DISABLE_ALL_INTERRUPT
+	/* DISABLE_ALL_INTERRUPT */
 	outb(APCI3120_DISABLE_ALL_INTERRUPT,
 		dev-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
-	//Flush FIFO
+	/* Flush FIFO */
 	inb(dev-&gt;iobase + APCI3120_RESET_FIFO);
 	inw(dev-&gt;iobase + APCI3120_RD_STATUS);
 	devpriv-&gt;ui_AiActualScan = 0;
@@ -480,9 +486,9 @@ int i_APCI3120_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 	struct comedi_cmd * cmd)
 {
 	int err = 0;
-	int tmp;		// divisor1,divisor2;
+	int tmp;		/*  divisor1,divisor2; */
 
-	// step 1: make sure trigger sources are trivially valid
+	/*  step 1: make sure trigger sources are trivially valid */
 
 	tmp = cmd-&gt;start_src;
 	cmd-&gt;start_src &amp;= TRIG_NOW | TRIG_EXT;
@@ -512,7 +518,7 @@ int i_APCI3120_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 	if (err)
 		return 1;
 
-	//step 2: make sure trigger sources are unique and mutually compatible
+	/* step 2: make sure trigger sources are unique and mutually compatible */
 
 	if (cmd-&gt;start_src != TRIG_NOW &amp;&amp; cmd-&gt;start_src != TRIG_EXT) {
 		err++;
@@ -536,14 +542,14 @@ int i_APCI3120_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 	if (err)
 		return 2;
 
-	// step 3: make sure arguments are trivially compatible
+	/*  step 3: make sure arguments are trivially compatible */
 
 	if (cmd-&gt;start_arg != 0) {
 		cmd-&gt;start_arg = 0;
 		err++;
 	}
 
-	if (cmd-&gt;scan_begin_src == TRIG_TIMER)	// Test Delay timing
+	if (cmd-&gt;scan_begin_src == TRIG_TIMER)	/*  Test Delay timing */
 	{
 		if (cmd-&gt;scan_begin_arg &lt; this_board-&gt;ui_MinDelaytimeNs) {
 			cmd-&gt;scan_begin_arg = this_board-&gt;ui_MinDelaytimeNs;
@@ -551,7 +557,7 @@ int i_APCI3120_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 		}
 	}
 
-	if (cmd-&gt;convert_src == TRIG_TIMER)	// Test Acquisition timing
+	if (cmd-&gt;convert_src == TRIG_TIMER)	/*  Test Acquisition timing */
 	{
 		if (cmd-&gt;scan_begin_src == TRIG_TIMER) {
 			if ((cmd-&gt;convert_arg)
@@ -585,7 +591,7 @@ int i_APCI3120_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 			cmd-&gt;stop_arg = 1;
 			err++;
 		}
-	} else {		// TRIG_NONE
+	} else {		/*  TRIG_NONE */
 		if (cmd-&gt;stop_arg != 0) {
 			cmd-&gt;stop_arg = 0;
 			err++;
@@ -595,7 +601,7 @@ int i_APCI3120_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 	if (err)
 		return 3;
 
-	// step 4: fix up any arguments
+	/*  step 4: fix up any arguments */
 
 	if (cmd-&gt;convert_src == TRIG_TIMER) {
 
@@ -637,15 +643,15 @@ int i_APCI3120_CommandAnalogInput(struct comedi_device * dev, struct comedi_subd
 {
 	struct comedi_cmd *cmd = &amp;s-&gt;async-&gt;cmd;
 
-	//loading private structure with cmd structure inputs
+	/* loading private structure with cmd structure inputs */
 	devpriv-&gt;ui_AiFlags = cmd-&gt;flags;
 	devpriv-&gt;ui_AiNbrofChannels = cmd-&gt;chanlist_len;
 	devpriv-&gt;ui_AiScanLength = cmd-&gt;scan_end_arg;
 	devpriv-&gt;pui_AiChannelList = cmd-&gt;chanlist;
 
-	//UPDATE-0.7.57-&gt;0.7.68devpriv-&gt;AiData=s-&gt;async-&gt;data;
+	/* UPDATE-0.7.57-&gt;0.7.68devpriv-&gt;AiData=s-&gt;async-&gt;data; */
 	devpriv-&gt;AiData = s-&gt;async-&gt;prealloc_buf;
-	//UPDATE-0.7.57-&gt;0.7.68devpriv-&gt;ui_AiDataLength=s-&gt;async-&gt;data_len;
+	/* UPDATE-0.7.57-&gt;0.7.68devpriv-&gt;ui_AiDataLength=s-&gt;async-&gt;data_len; */
 	devpriv-&gt;ui_AiDataLength = s-&gt;async-&gt;prealloc_bufsz;
 
 	if (cmd-&gt;stop_src == TRIG_COUNT) {
@@ -654,11 +660,11 @@ int i_APCI3120_CommandAnalogInput(struct comedi_device * dev, struct comedi_subd
 		devpriv-&gt;ui_AiNbrofScans = 0;
 	}
 
-	devpriv-&gt;ui_AiTimer0 = 0;	// variables changed to timer0,timer1
+	devpriv-&gt;ui_AiTimer0 = 0;	/*  variables changed to timer0,timer1 */
 	devpriv-&gt;ui_AiTimer1 = 0;
 	if ((devpriv-&gt;ui_AiNbrofScans == 0) || (devpriv-&gt;ui_AiNbrofScans == -1))
-		devpriv-&gt;b_AiContinuous = 1;	// user want neverending analog acquisition
-	// stopped using cancel
+		devpriv-&gt;b_AiContinuous = 1;	/*  user want neverending analog acquisition */
+	/*  stopped using cancel */
 
 	if (cmd-&gt;start_src == TRIG_EXT)
 		devpriv-&gt;b_ExttrigEnable = APCI3120_ENABLE;
@@ -666,22 +672,22 @@ int i_APCI3120_CommandAnalogInput(struct comedi_device * dev, struct comedi_subd
 		devpriv-&gt;b_ExttrigEnable = APCI3120_DISABLE;
 
 	if (cmd-&gt;scan_begin_src == TRIG_FOLLOW) {
-		// mode 1 or 3
+		/*  mode 1 or 3 */
 		if (cmd-&gt;convert_src == TRIG_TIMER) {
-			// mode 1
+			/*  mode 1 */
 
-			devpriv-&gt;ui_AiTimer0 = cmd-&gt;convert_arg;	// timer constant in nano seconds
-			//return this_board-&gt;i_hwdrv_CommandAnalogInput(1,dev,s);
+			devpriv-&gt;ui_AiTimer0 = cmd-&gt;convert_arg;	/*  timer constant in nano seconds */
+			/* return this_board-&gt;i_hwdrv_CommandAnalogInput(1,dev,s); */
 			return i_APCI3120_CyclicAnalogInput(1, dev, s);
 		}
 
 	}
 	if ((cmd-&gt;scan_begin_src == TRIG_TIMER)
 		&amp;&amp; (cmd-&gt;convert_src == TRIG_TIMER)) {
-		// mode 2
+		/*  mode 2 */
 		devpriv-&gt;ui_AiTimer1 = cmd-&gt;scan_begin_arg;
-		devpriv-&gt;ui_AiTimer0 = cmd-&gt;convert_arg;	// variable changed timer2 to timer0
-		//return this_board-&gt;i_hwdrv_CommandAnalogInput(2,dev,s);
+		devpriv-&gt;ui_AiTimer0 = cmd-&gt;convert_arg;	/*  variable changed timer2 to timer0 */
+		/* return this_board-&gt;i_hwdrv_CommandAnalogInput(2,dev,s); */
 		return i_APCI3120_CyclicAnalogInput(2, dev, s);
 	}
 	return -1;
@@ -716,64 +722,65 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 		0, ui_TimerValue0, ui_ConvertTiming;
 	unsigned short us_TmpValue;
 
-	//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
-	//devpriv-&gt;b_AiCyclicAcquisition=APCI3120_ENABLE;
-	//END JK 07.05.04: Comparison between WIN32 and Linux driver
+	/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
+	/* devpriv-&gt;b_AiCyclicAcquisition=APCI3120_ENABLE; */
+	/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 
 	/*******************/
 	/* Resets the FIFO */
 	/*******************/
 	inb(dev-&gt;iobase + APCI3120_RESET_FIFO);
 
-	//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
-	//inw(dev-&gt;iobase+APCI3120_RD_STATUS);
-	//END JK 07.05.04: Comparison between WIN32 and Linux driver
+	/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
+	/* inw(dev-&gt;iobase+APCI3120_RD_STATUS); */
+	/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 
 	/***************************/
 	/* Acquisition initialized */
 	/***************************/
-	//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
+	/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
 	devpriv-&gt;b_AiCyclicAcquisition = APCI3120_ENABLE;
-	//END JK 07.05.04: Comparison between WIN32 and Linux driver
+	/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 
-	// clear software  registers
+	/*  clear software  registers */
 	devpriv-&gt;b_TimerSelectMode = 0;
 	devpriv-&gt;us_OutputRegister = 0;
 	devpriv-&gt;b_ModeSelectRegister = 0;
-	//devpriv-&gt;b_DigitalOutputRegister=0;
+	/* devpriv-&gt;b_DigitalOutputRegister=0; */
 
-	//COMMENT JK 07.05.04: Followings calls are in i_APCI3120_StartAnalogInputAcquisition
+	/* COMMENT JK 07.05.04: Followings calls are in i_APCI3120_StartAnalogInputAcquisition */
 
-   /****************************/
+	/****************************/
 	/* Clear Timer Write TC int */
-   /****************************/
+	/****************************/
 	outl(APCI3120_CLEAR_WRITE_TC_INT,
 		devpriv-&gt;i_IobaseAmcc + APCI3120_AMCC_OP_REG_INTCSR);
 
-   /************************************/
+	/************************************/
 	/* Clears the timer status register */
-   /************************************/
-	//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
-	//inw(dev-&gt;iobase+APCI3120_TIMER_STATUS_REGISTER);
-	inb(dev-&gt;iobase + APCI3120_TIMER_STATUS_REGISTER);
-	//END JK 07.05.04: Comparison between WIN32 and Linux driver
+	/************************************/
 
-   /**************************/
+	/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
+	/* inw(dev-&gt;iobase+APCI3120_TIMER_STATUS_REGISTER); */
+	/* inb(dev-&gt;iobase + APCI3120_TIMER_STATUS_REGISTER); */
+	/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
+
+	/**************************/
 	/* Disables All Timer     */
 	/* Sets PR and PA to 0    */
-   /**************************/
+	/**************************/
 	devpriv-&gt;us_OutputRegister = devpriv-&gt;us_OutputRegister &amp;
 		APCI3120_DISABLE_TIMER0 &amp;
 		APCI3120_DISABLE_TIMER1 &amp; APCI3120_CLEAR_PA_PR;
 
 	outw(devpriv-&gt;us_OutputRegister, dev-&gt;iobase + APCI3120_WR_ADDRESS);
 
-   /*******************/
+	/*******************/
 	/* Resets the FIFO */
-   /*******************/
-	//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
+	/*******************/
+	/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
 	inb(devpriv-&gt;iobase + APCI3120_RESET_FIFO);
-	//END JK 07.05.04: Comparison between WIN32 and Linux driver
+	/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 
 	devpriv-&gt;ui_AiActualScan = 0;
 	devpriv-&gt;ui_AiActualScanPosition = 0;
@@ -781,7 +788,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 	devpriv-&gt;ui_AiBufferPtr = 0;
 	devpriv-&gt;ui_DmaActualBuffer = 0;
 
-	// value for timer2  minus -2 has to be done .....dunno y??
+	/*  value for timer2  minus -2 has to be done .....dunno y?? */
 	ui_TimerValue2 = devpriv-&gt;ui_AiNbrofScans - 2;
 	ui_ConvertTiming = devpriv-&gt;ui_AiTimer0;
 
@@ -819,7 +826,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 	}
 ***********************************************************************************************/
 /*** EL241003 Begin : add this section to replace floats calculation by integer calculations **/
-	//EL250804: Testing if board APCI3120 have the new Quartz or if it is an APCI3001
+	/* EL250804: Testing if board APCI3120 have the new Quartz or if it is an APCI3001 */
 	if ((us_TmpValue &amp; 0x00B0) == 0x00B0
 		|| !strcmp(this_board-&gt;pc_DriverName, "apci3001")) {
 		ui_TimerValue0 = ui_ConvertTiming * 2 - 2000;
@@ -844,79 +851,82 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 /*** EL241003 End ******************************************************************************/
 
 	if (devpriv-&gt;b_ExttrigEnable == APCI3120_ENABLE) {
-		i_APCI3120_ExttrigEnable(dev);	// activate EXT trigger
+		i_APCI3120_ExttrigEnable(dev);	/*  activate EXT trigger */
 	}
 	switch (mode) {
 	case 1:
-		// init timer0 in mode 2
+		/*  init timer0 in mode 2 */
 		devpriv-&gt;b_TimerSelectMode =
 			(devpriv-&gt;
 			b_TimerSelectMode &amp; 0xFC) | APCI3120_TIMER_0_MODE_2;
 		outb(devpriv-&gt;b_TimerSelectMode,
 			dev-&gt;iobase + APCI3120_TIMER_CRT1);
 
-		//Select Timer 0
+		/* Select Timer 0 */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_0_WORD;
 		outb(b_Tmp, dev-&gt;iobase + APCI3120_TIMER_CRT0);
-		//Set the convertion time
+		/* Set the convertion time */
 		outw(((unsigned short) ui_TimerValue0),
 			dev-&gt;iobase + APCI3120_TIMER_VALUE);
 		break;
 
 	case 2:
-		// init timer1 in mode 2
+		/*  init timer1 in mode 2 */
 		devpriv-&gt;b_TimerSelectMode =
 			(devpriv-&gt;
 			b_TimerSelectMode &amp; 0xF3) | APCI3120_TIMER_1_MODE_2;
 		outb(devpriv-&gt;b_TimerSelectMode,
 			dev-&gt;iobase + APCI3120_TIMER_CRT1);
 
-		//Select Timer 1
+		/* Select Timer 1 */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_1_WORD;
 		outb(b_Tmp, dev-&gt;iobase + APCI3120_TIMER_CRT0);
-		//Set the convertion time
+		/* Set the convertion time */
 		outw(((unsigned short) ui_TimerValue1),
 			dev-&gt;iobase + APCI3120_TIMER_VALUE);
 
-		// init timer0 in mode 2
+		/*  init timer0 in mode 2 */
 		devpriv-&gt;b_TimerSelectMode =
 			(devpriv-&gt;
 			b_TimerSelectMode &amp; 0xFC) | APCI3120_TIMER_0_MODE_2;
 		outb(devpriv-&gt;b_TimerSelectMode,
 			dev-&gt;iobase + APCI3120_TIMER_CRT1);
 
-		//Select Timer 0
+		/* Select Timer 0 */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_0_WORD;
 		outb(b_Tmp, dev-&gt;iobase + APCI3120_TIMER_CRT0);
 
-		//Set the convertion time
+		/* Set the convertion time */
 		outw(((unsigned short) ui_TimerValue0),
 			dev-&gt;iobase + APCI3120_TIMER_VALUE);
 		break;
 
 	}
-	//   ##########common for all modes#################
+	/*    ##########common for all modes################# */
 
 	/***********************/
 	/* Clears the SCAN bit */
 	/***********************/
-	//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
-	//devpriv-&gt;b_ModeSelectRegister=devpriv-&gt;b_ModeSelectRegister | APCI3120_DISABLE_SCAN;
+
+	/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
+	/* devpriv-&gt;b_ModeSelectRegister=devpriv-&gt;b_ModeSelectRegister | APCI3120_DISABLE_SCAN; */
+
 	devpriv-&gt;b_ModeSelectRegister = devpriv-&gt;b_ModeSelectRegister &amp;
 		APCI3120_DISABLE_SCAN;
-	//END JK 07.05.04: Comparison between WIN32 and Linux driver
+	/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
+
 	outb(devpriv-&gt;b_ModeSelectRegister,
 		dev-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-	// If DMA is disabled
+	/*  If DMA is disabled */
 	if (devpriv-&gt;us_UseDma == APCI3120_DISABLE) {
-		// disable EOC and enable EOS
+		/*  disable EOC and enable EOS */
 		devpriv-&gt;b_InterruptMode = APCI3120_EOS_MODE;
 		devpriv-&gt;b_EocEosInterrupt = APCI3120_ENABLE;
 
@@ -928,15 +938,17 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 			dev-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
 		if (!devpriv-&gt;b_AiContinuous) {
-			// configure Timer2 For counting  EOS
-			//Reset gate 2 of Timer 2 to disable it (Set Bit D14 to 0)
+/*
+ * configure Timer2 For counting EOS Reset gate 2 of Timer 2 to
+ * disable it (Set Bit D14 to 0)
+ */
 			devpriv-&gt;us_OutputRegister =
 				devpriv-&gt;
 				us_OutputRegister &amp; APCI3120_DISABLE_TIMER2;
 			outw(devpriv-&gt;us_OutputRegister,
 				dev-&gt;iobase + APCI3120_WR_ADDRESS);
 
-			// DISABLE TIMER intERRUPT
+			/*  DISABLE TIMER intERRUPT */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister &amp;
@@ -944,7 +956,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 			outb(devpriv-&gt;b_ModeSelectRegister,
 				dev-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-			//(1) Init timer 2 in mode 0 and write timer value
+			/* (1) Init timer 2 in mode 0 and write timer value */
 			devpriv-&gt;b_TimerSelectMode =
 				(devpriv-&gt;
 				b_TimerSelectMode &amp; 0x0F) |
@@ -952,7 +964,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 			outb(devpriv-&gt;b_TimerSelectMode,
 				dev-&gt;iobase + APCI3120_TIMER_CRT1);
 
-			//Writing LOW unsigned short
+			/* Writing LOW unsigned short */
 			b_Tmp = ((devpriv-&gt;
 					b_DigitalOutputRegister) &amp; 0xF0) |
 				APCI3120_SELECT_TIMER_2_LOW_WORD;
@@ -960,7 +972,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 			outw(LOWORD(ui_TimerValue2),
 				dev-&gt;iobase + APCI3120_TIMER_VALUE);
 
-			//Writing HIGH unsigned short
+			/* Writing HIGH unsigned short */
 			b_Tmp = ((devpriv-&gt;
 					b_DigitalOutputRegister) &amp; 0xF0) |
 				APCI3120_SELECT_TIMER_2_HIGH_WORD;
@@ -968,20 +980,20 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 			outw(HIWORD(ui_TimerValue2),
 				dev-&gt;iobase + APCI3120_TIMER_VALUE);
 
-			//(2) Reset FC_TIMER BIT  Clearing timer status register
+			/* (2) Reset FC_TIMER BIT  Clearing timer status register */
 			inb(dev-&gt;iobase + APCI3120_TIMER_STATUS_REGISTER);
-			// enable timer counter and disable watch dog
+			/*  enable timer counter and disable watch dog */
 			devpriv-&gt;b_ModeSelectRegister =
 				(devpriv-&gt;
 				b_ModeSelectRegister |
 				APCI3120_ENABLE_TIMER_COUNTER) &amp;
 				APCI3120_DISABLE_WATCHDOG;
-			// select EOS clock input for timer 2
+			/*  select EOS clock input for timer 2 */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister |
 				APCI3120_TIMER2_SELECT_EOS;
-			// Enable timer2  interrupt
+			/*  Enable timer2  interrupt */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister |
@@ -992,15 +1004,16 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 			devpriv-&gt;b_Timer2Interrupt = APCI3120_ENABLE;
 		}
 	} else {
-		// If DMA Enabled
-		//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
-		//inw(dev-&gt;iobase+0);// reset EOC bit
-		//END JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* If DMA Enabled */
+
+		/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
+		/* inw(dev-&gt;iobase+0); reset EOC bit */
+		/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 		devpriv-&gt;b_InterruptMode = APCI3120_DMA_MODE;
 
-      /************************************/
+		/************************************/
 		/* Disables the EOC, EOS interrupt  */
-	  /************************************/
+		/************************************/
 		devpriv-&gt;b_ModeSelectRegister = devpriv-&gt;b_ModeSelectRegister &amp;
 			APCI3120_DISABLE_EOC_INT &amp; APCI3120_DISABLE_EOS_INT;
 
@@ -1012,18 +1025,18 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 
 		if (!devpriv-&gt;b_AiContinuous) {
 
-			if (dmalen0 &gt; (devpriv-&gt;ui_AiNbrofScans * devpriv-&gt;ui_AiScanLength * 2)) {	// must we fill full first buffer?
+			if (dmalen0 &gt; (devpriv-&gt;ui_AiNbrofScans * devpriv-&gt;ui_AiScanLength * 2)) {	/*  must we fill full first buffer? */
 				dmalen0 =
 					devpriv-&gt;ui_AiNbrofScans *
 					devpriv-&gt;ui_AiScanLength * 2;
-			} else if (dmalen1 &gt; (devpriv-&gt;ui_AiNbrofScans * devpriv-&gt;ui_AiScanLength * 2 - dmalen0))	// and must we fill full second buffer when first is once filled?
+			} else if (dmalen1 &gt; (devpriv-&gt;ui_AiNbrofScans * devpriv-&gt;ui_AiScanLength * 2 - dmalen0))	/*  and must we fill full second buffer when first is once filled? */
 				dmalen1 =
 					devpriv-&gt;ui_AiNbrofScans *
 					devpriv-&gt;ui_AiScanLength * 2 - dmalen0;
 		}
 
 		if (devpriv-&gt;ui_AiFlags &amp; TRIG_WAKE_EOS) {
-			// don't we want wake up every scan?
+			/*  don't we want wake up every scan? */
 			if (dmalen0 &gt; (devpriv-&gt;ui_AiScanLength * 2)) {
 				dmalen0 = devpriv-&gt;ui_AiScanLength * 2;
 				if (devpriv-&gt;ui_AiScanLength &amp; 1)
@@ -1036,7 +1049,7 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 				if (dmalen1 &lt; 4)
 					dmalen1 = 4;
 			}
-		} else {	// isn't output buff smaller that our DMA buff?
+		} else {	/*  isn't output buff smaller that our DMA buff? */
 			if (dmalen0 &gt; (devpriv-&gt;ui_AiDataLength)) {
 				dmalen0 = devpriv-&gt;ui_AiDataLength;
 			}
@@ -1047,14 +1060,16 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 		devpriv-&gt;ui_DmaBufferUsesize[0] = dmalen0;
 		devpriv-&gt;ui_DmaBufferUsesize[1] = dmalen1;
 
-		//Initialize DMA
+		/* Initialize DMA */
 
-		// Set Transfer count enable bit and A2P_fifo reset bit in AGCSTS register
-		//1
+/*
+ * Set Transfer count enable bit and A2P_fifo reset bit in AGCSTS
+ * register 1
+ */
 		ui_Tmp = AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO;
 		outl(ui_Tmp, devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_AGCSTS);
 
-		// changed  since 16 bit interface for add on
+		/*  changed  since 16 bit interface for add on */
 		/*********************/
 		/* ENABLE BUS MASTER */
 		/*********************/
@@ -1066,78 +1081,95 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 		outw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH,
 			devpriv-&gt;i_IobaseAddon + 2);
 
-		// TO VERIFIED
-		//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
+/*
+ * TO VERIFIED BEGIN JK 07.05.04: Comparison between WIN32 and Linux
+ * driver
+ */
 		outw(0x1000, devpriv-&gt;i_IobaseAddon + 2);
-		//END JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 
-		//2  No change
-		// A2P FIFO MANAGEMENT
-		// A2P fifo reset  &amp; transfer control enable
-		 /***********************/
+		/* 2 No change */
 		/* A2P FIFO MANAGEMENT */
-		 /***********************/
+		/* A2P fifo reset &amp; transfer control enable */
+
+		/***********************/
+		/* A2P FIFO MANAGEMENT */
+		/***********************/
 		outl(APCI3120_A2P_FIFO_MANAGEMENT, devpriv-&gt;i_IobaseAmcc +
 			APCI3120_AMCC_OP_MCSR);
 
-		//3
-		//beginning address of dma buf
-		//The 32 bit address of dma buffer is converted into two 16 bit addresses
-		// Can done by using _attach and put into into an array
-		// array used may be for differnet pages
+/*
+ * 3
+ * beginning address of dma buf The 32 bit address of dma buffer
+ * is converted into two 16 bit addresses Can done by using _attach
+ * and put into into an array array used may be for differnet pages
+ */
 
-		// DMA Start Adress Low
+		/*  DMA Start Adress Low */
 		outw(APCI3120_ADD_ON_MWAR_LOW, devpriv-&gt;i_IobaseAddon + 0);
 		outw((devpriv-&gt;ul_DmaBufferHw[0] &amp; 0xFFFF),
 			devpriv-&gt;i_IobaseAddon + 2);
 
-		 /*************************/
+		/*************************/
 		/* DMA Start Adress High */
-		 /*************************/
+		/*************************/
 		outw(APCI3120_ADD_ON_MWAR_HIGH, devpriv-&gt;i_IobaseAddon + 0);
 		outw((devpriv-&gt;ul_DmaBufferHw[0] / 65536),
 			devpriv-&gt;i_IobaseAddon + 2);
 
-		//4
-		// amount of bytes to be transfered  set transfer count
-		// used ADDON MWTC register
-		//commented testing             outl(devpriv-&gt;ui_DmaBufferUsesize[0], devpriv-&gt;i_IobaseAddon+AMCC_OP_REG_AMWTC);
-
-		 /**************************/
+/*
+ * 4
+ * amount of bytes to be transfered set transfer count used ADDON
+ * MWTC register commented testing
+ * outl(devpriv-&gt;ui_DmaBufferUsesize[0],
+ * devpriv-&gt;i_IobaseAddon+AMCC_OP_REG_AMWTC);
+ */
+
+		/**************************/
 		/* Nbr of acquisition LOW */
-		 /**************************/
+		/**************************/
 		outw(APCI3120_ADD_ON_MWTC_LOW, devpriv-&gt;i_IobaseAddon + 0);
 		outw((devpriv-&gt;ui_DmaBufferUsesize[0] &amp; 0xFFFF),
 			devpriv-&gt;i_IobaseAddon + 2);
 
-		 /***************************/
+		/***************************/
 		/* Nbr of acquisition HIGH */
-		 /***************************/
+		/***************************/
 		outw(APCI3120_ADD_ON_MWTC_HIGH, devpriv-&gt;i_IobaseAddon + 0);
 		outw((devpriv-&gt;ui_DmaBufferUsesize[0] / 65536),
 			devpriv-&gt;i_IobaseAddon + 2);
 
-		//5
-		// To configure A2P FIFO
-		// testing outl( FIFO_ADVANCE_ON_BYTE_2,devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_INTCSR);
+/*
+ * 5
+ * To configure A2P FIFO testing outl(
+ * FIFO_ADVANCE_ON_BYTE_2,devpriv-&gt;i_IobaseAmcc+AMCC_OP_REG_INTCSR);
+ */
 
 		/******************/
 		/* A2P FIFO RESET */
 		/******************/
-		// TO VERIFY
-		//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
+/*
+ * TO VERIFY BEGIN JK 07.05.04: Comparison between WIN32 and Linux
+ * driver
+ */
 		outl(0x04000000UL, devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_MCSR);
-		//END JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
+
+/*
+ * 6
+ * ENABLE A2P FIFO WRITE AND ENABLE AMWEN AMWEN_ENABLE |
+ * A2P_FIFO_WRITE_ENABLE (0x01|0x02)=0x03
+ */
 
-		//6
-		//ENABLE A2P FIFO WRITE AND ENABLE AMWEN
-		// AMWEN_ENABLE | A2P_FIFO_WRITE_ENABLE (0x01|0x02)=0x03
-		//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
-		//outw(3,devpriv-&gt;i_IobaseAddon + 4);
-		//END JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
+		/* outw(3,devpriv-&gt;i_IobaseAddon + 4); */
+		/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 
-		//7
-		//initialise end of dma interrupt  AINT_WRITE_COMPL = ENABLE_WRITE_TC_INT(ADDI)
+/*
+ * 7
+ * initialise end of dma interrupt AINT_WRITE_COMPL =
+ * ENABLE_WRITE_TC_INT(ADDI)
+ */
 		/***************************************************/
 		/* A2P FIFO CONFIGURATE, END OF DMA intERRUPT INIT */
 		/***************************************************/
@@ -1145,25 +1177,25 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 				APCI3120_ENABLE_WRITE_TC_INT),
 			devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_INTCSR);
 
-		//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
 		/******************************************/
 		/* ENABLE A2P FIFO WRITE AND ENABLE AMWEN */
 		/******************************************/
 		outw(3, devpriv-&gt;i_IobaseAddon + 4);
-		//END JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 
 		/******************/
 		/* A2P FIFO RESET */
 		/******************/
-		//BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* BEGIN JK 07.05.04: Comparison between WIN32 and Linux driver */
 		outl(0x04000000UL,
 			devpriv-&gt;i_IobaseAmcc + APCI3120_AMCC_OP_MCSR);
-		//END JK 07.05.04: Comparison between WIN32 and Linux driver
+		/* END JK 07.05.04: Comparison between WIN32 and Linux driver */
 	}
 
 	if ((devpriv-&gt;us_UseDma == APCI3120_DISABLE)
 		&amp;&amp; !devpriv-&gt;b_AiContinuous) {
-		// set gate 2   to start conversion
+		/*  set gate 2   to start conversion */
 		devpriv-&gt;us_OutputRegister =
 			devpriv-&gt;us_OutputRegister | APCI3120_ENABLE_TIMER2;
 		outw(devpriv-&gt;us_OutputRegister,
@@ -1172,14 +1204,14 @@ int i_APCI3120_CyclicAnalogInput(int mode, struct comedi_device * dev,
 
 	switch (mode) {
 	case 1:
-		// set gate 0   to start conversion
+		/*  set gate 0   to start conversion */
 		devpriv-&gt;us_OutputRegister =
 			devpriv-&gt;us_OutputRegister | APCI3120_ENABLE_TIMER0;
 		outw(devpriv-&gt;us_OutputRegister,
 			dev-&gt;iobase + APCI3120_WR_ADDRESS);
 		break;
 	case 2:
-		// set  gate 0 and gate 1
+		/*  set  gate 0 and gate 1 */
 		devpriv-&gt;us_OutputRegister =
 			devpriv-&gt;us_OutputRegister | APCI3120_ENABLE_TIMER1;
 		devpriv-&gt;us_OutputRegister =
@@ -1226,47 +1258,49 @@ int i_APCI3120_Reset(struct comedi_device * dev)
 	devpriv-&gt;b_AiCyclicAcquisition = APCI3120_DISABLE;
 	devpriv-&gt;b_EocEosInterrupt = APCI3120_DISABLE;
 	devpriv-&gt;b_InterruptMode = APCI3120_EOC_MODE;
-	devpriv-&gt;ui_EocEosConversionTime = 0;	// set eoc eos conv time to 0
+	devpriv-&gt;ui_EocEosConversionTime = 0;	/*  set eoc eos conv time to 0 */
 	devpriv-&gt;b_OutputMemoryStatus = 0;
 
-	// variables used in timer subdevice
+	/*  variables used in timer subdevice */
 	devpriv-&gt;b_Timer2Mode = 0;
 	devpriv-&gt;b_Timer2Interrupt = 0;
-	devpriv-&gt;b_ExttrigEnable = 0;	// Disable ext trigger
+	devpriv-&gt;b_ExttrigEnable = 0;	/*  Disable ext trigger */
 
 	/* Disable all interrupts, watchdog for the anolog output */
 	devpriv-&gt;b_ModeSelectRegister = 0;
 	outb(devpriv-&gt;b_ModeSelectRegister,
 		dev-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-	// Disables all counters, ext trigger and clears PA, PR
+	/*  Disables all counters, ext trigger and clears PA, PR */
 	devpriv-&gt;us_OutputRegister = 0;
 	outw(devpriv-&gt;us_OutputRegister, dev-&gt;iobase + APCI3120_WR_ADDRESS);
 
-	//Code to set the all anolog o/p channel to 0v
-	//8191 is decimal value for zero(0 v)volt in bipolar mode(default)
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_1, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	//channel 1
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_2, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	//channel 2
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_3, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	//channel 3
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_4, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	//channel 4
-
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_5, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	//channel 5
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_6, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	//channel 6
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_7, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	//channel 7
-	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_8, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	//channel 8
-
-	//  Reset digital output to L0W
-
-//ES05  outb(0x0,dev-&gt;iobase+APCI3120_DIGITAL_OUTPUT);
+/*
+ * Code to set the all anolog o/p channel to 0v 8191 is decimal
+ * value for zero(0 v)volt in bipolar mode(default)
+ */
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_1, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	/* channel 1 */
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_2, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	/* channel 2 */
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_3, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	/* channel 3 */
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_4, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);	/* channel 4 */
+
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_5, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	/* channel 5 */
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_6, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	/* channel 6 */
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_7, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	/* channel 7 */
+	outw(8191 | APCI3120_ANALOG_OP_CHANNEL_8, dev-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);	/* channel 8 */
+
+	/*   Reset digital output to L0W */
+
+/* ES05  outb(0x0,dev-&gt;iobase+APCI3120_DIGITAL_OUTPUT); */
 	udelay(10);
 
-	inw(dev-&gt;iobase + 0);	//make a dummy read
-	inb(dev-&gt;iobase + APCI3120_RESET_FIFO);	// flush FIFO
-	inw(dev-&gt;iobase + APCI3120_RD_STATUS);	// flush A/D status register
+	inw(dev-&gt;iobase + 0);	/* make a dummy read */
+	inb(dev-&gt;iobase + APCI3120_RESET_FIFO);	/*  flush FIFO */
+	inw(dev-&gt;iobase + APCI3120_RD_STATUS);	/*  flush A/D status register */
 
-	//code to reset the RAM sequence
+	/* code to reset the RAM sequence */
 	for (i = 0; i &lt; 16; i++) {
-		us_TmpValue = i &lt;&lt; 8;	//select the location
+		us_TmpValue = i &lt;&lt; 8;	/* select the location */
 		outw(us_TmpValue, dev-&gt;iobase + APCI3120_SEQ_RAM_ADDRESS);
 	}
 	return 0;
@@ -1299,7 +1333,7 @@ int i_APCI3120_Reset(struct comedi_device * dev)
 int i_APCI3120_SetupChannelList(struct comedi_device * dev, struct comedi_subdevice * s,
 	int n_chan, unsigned int *chanlist, char check)
 {
-	unsigned int i;		//, differencial=0, bipolar=0;
+	unsigned int i;		/* , differencial=0, bipolar=0; */
 	unsigned int gain;
 	unsigned short us_TmpValue;
 
@@ -1309,29 +1343,29 @@ int i_APCI3120_SetupChannelList(struct comedi_device * dev, struct comedi_subdev
 			comedi_error(dev, "range/channel list is empty!");
 		return 0;
 	}
-	// All is ok, so we can setup channel/range list
+	/*  All is ok, so we can setup channel/range list */
 	if (check)
 		return 1;
 
-	//Code  to set the PA and PR...Here it set PA to 0..
+	/* Code  to set the PA and PR...Here it set PA to 0.. */
 	devpriv-&gt;us_OutputRegister =
 		devpriv-&gt;us_OutputRegister &amp; APCI3120_CLEAR_PA_PR;
 	devpriv-&gt;us_OutputRegister = ((n_chan - 1) &amp; 0xf) &lt;&lt; 8;
 	outw(devpriv-&gt;us_OutputRegister, dev-&gt;iobase + APCI3120_WR_ADDRESS);
 
 	for (i = 0; i &lt; n_chan; i++) {
-		// store range list to card
-		us_TmpValue = CR_CHAN(chanlist[i]);	// get channel number;
+		/*  store range list to card */
+		us_TmpValue = CR_CHAN(chanlist[i]);	/*  get channel number; */
 
 		if (CR_RANGE(chanlist[i]) &lt; APCI3120_BIPOLAR_RANGES) {
-			us_TmpValue &amp;= ((~APCI3120_UNIPOLAR) &amp; 0xff);	// set bipolar
+			us_TmpValue &amp;= ((~APCI3120_UNIPOLAR) &amp; 0xff);	/*  set bipolar */
 		} else {
-			us_TmpValue |= APCI3120_UNIPOLAR;	// enable unipolar......
+			us_TmpValue |= APCI3120_UNIPOLAR;	/*  enable unipolar...... */
 		}
 
-		gain = CR_RANGE(chanlist[i]);	// get gain number
-		us_TmpValue |= ((gain &amp; 0x03) &lt;&lt; 4);	//&lt;&lt;4 for G0 and G1 bit in RAM
-		us_TmpValue |= i &lt;&lt; 8;	//To select the RAM LOCATION....
+		gain = CR_RANGE(chanlist[i]);	/*  get gain number */
+		us_TmpValue |= ((gain &amp; 0x03) &lt;&lt; 4);	/* &lt;&lt;4 for G0 and G1 bit in RAM */
+		us_TmpValue |= i &lt;&lt; 8;	/* To select the RAM LOCATION.... */
 		outw(us_TmpValue, dev-&gt;iobase + APCI3120_SEQ_RAM_ADDRESS);
 
 		printk("\n Gain = %i",
@@ -1339,7 +1373,7 @@ int i_APCI3120_SetupChannelList(struct comedi_device * dev, struct comedi_subdev
 		printk("\n Channel = %i", CR_CHAN(chanlist[i]));
 		printk("\n Polarity = %i", us_TmpValue &amp; APCI3120_UNIPOLAR);
 	}
-	return 1;		// we can serve this with scan logic
+	return 1;		/*  we can serve this with scan logic */
 }
 
 /*
@@ -1431,24 +1465,24 @@ void v_APCI3120_Interrupt(int irq, void *d)
 	struct comedi_subdevice *s = dev-&gt;subdevices + 0;
 	ui_Check = 1;
 
-	int_daq = inw(dev-&gt;iobase + APCI3120_RD_STATUS) &amp; 0xf000;	// get IRQ reasons
-	int_amcc = inl(devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_INTCSR);	// get AMCC int register
+	int_daq = inw(dev-&gt;iobase + APCI3120_RD_STATUS) &amp; 0xf000;	/*  get IRQ reasons */
+	int_amcc = inl(devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_INTCSR);	/*  get AMCC int register */
 
 	if ((!int_daq) &amp;&amp; (!(int_amcc &amp; ANY_S593X_INT))) {
 		comedi_error(dev, "IRQ from unknow source");
 		return;
 	}
 
-	outl(int_amcc | 0x00ff0000, devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_INTCSR);	// shutdown IRQ reasons in AMCC
+	outl(int_amcc | 0x00ff0000, devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_INTCSR);	/*  shutdown IRQ reasons in AMCC */
 
 	int_daq = (int_daq &gt;&gt; 12) &amp; 0xF;
 
 	if (devpriv-&gt;b_ExttrigEnable == APCI3120_ENABLE) {
-		//Disable ext trigger
+		/* Disable ext trigger */
 		i_APCI3120_ExttrigDisable(dev);
 		devpriv-&gt;b_ExttrigEnable = APCI3120_DISABLE;
 	}
-	//clear the timer 2 interrupt
+	/* clear the timer 2 interrupt */
 	inb(devpriv-&gt;i_IobaseAmcc + APCI3120_TIMER_STATUS_REGISTER);
 
 	if (int_amcc &amp; MASTER_ABORT_INT)
@@ -1456,19 +1490,19 @@ void v_APCI3120_Interrupt(int irq, void *d)
 	if (int_amcc &amp; TARGET_ABORT_INT)
 		comedi_error(dev, "AMCC IRQ - TARGET DMA ABORT!");
 
-	// Ckeck if EOC interrupt
+	/*  Ckeck if EOC interrupt */
 	if (((int_daq &amp; 0x8) == 0)
 		&amp;&amp; (devpriv-&gt;b_InterruptMode == APCI3120_EOC_MODE)) {
 		if (devpriv-&gt;b_EocEosInterrupt == APCI3120_ENABLE) {
 
-			// Read the AI Value
+			/*  Read the AI Value */
 
 			devpriv-&gt;ui_AiReadData[0] =
 				(unsigned int) inw(devpriv-&gt;iobase + 0);
 			devpriv-&gt;b_EocEosInterrupt = APCI3120_DISABLE;
-			send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
+			send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
 		} else {
-			//Disable EOC Interrupt
+			/* Disable EOC Interrupt */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister &amp; APCI3120_DISABLE_EOC_INT;
@@ -1478,10 +1512,10 @@ void v_APCI3120_Interrupt(int irq, void *d)
 		}
 	}
 
-	// Check If EOS interrupt
+	/*  Check If EOS interrupt */
 	if ((int_daq &amp; 0x2) &amp;&amp; (devpriv-&gt;b_InterruptMode == APCI3120_EOS_MODE)) {
 
-		if (devpriv-&gt;b_EocEosInterrupt == APCI3120_ENABLE)	// enable this in without DMA ???
+		if (devpriv-&gt;b_EocEosInterrupt == APCI3120_ENABLE)	/*  enable this in without DMA ??? */
 		{
 
 			if (devpriv-&gt;b_AiCyclicAcquisition == APCI3120_ENABLE) {
@@ -1506,7 +1540,7 @@ void v_APCI3120_Interrupt(int irq, void *d)
 				devpriv-&gt;b_EocEosInterrupt = APCI3120_DISABLE;
 				devpriv-&gt;b_InterruptMode = APCI3120_EOC_MODE;
 
-				send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
+				send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
 
 			}
 
@@ -1516,12 +1550,12 @@ void v_APCI3120_Interrupt(int irq, void *d)
 				b_ModeSelectRegister &amp; APCI3120_DISABLE_EOS_INT;
 			outb(devpriv-&gt;b_ModeSelectRegister,
 				dev-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
-			devpriv-&gt;b_EocEosInterrupt = APCI3120_DISABLE;	//Default settings
+			devpriv-&gt;b_EocEosInterrupt = APCI3120_DISABLE;	/* Default settings */
 			devpriv-&gt;b_InterruptMode = APCI3120_EOC_MODE;
 		}
 
 	}
-	//Timer2 interrupt
+	/* Timer2 interrupt */
 	if (int_daq &amp; 0x1) {
 
 		switch (devpriv-&gt;b_Timer2Mode) {
@@ -1534,18 +1568,18 @@ void v_APCI3120_Interrupt(int irq, void *d)
 			outb(devpriv-&gt;b_ModeSelectRegister,
 				dev-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-			// stop timer 2
+			/*  stop timer 2 */
 			devpriv-&gt;us_OutputRegister =
 				devpriv-&gt;
 				us_OutputRegister &amp; APCI3120_DISABLE_ALL_TIMER;
 			outw(devpriv-&gt;us_OutputRegister,
 				dev-&gt;iobase + APCI3120_WR_ADDRESS);
 
-			//stop timer 0 and timer 1
+			/* stop timer 0 and timer 1 */
 			i_APCI3120_StopCyclicAcquisition(dev, s);
 			devpriv-&gt;b_AiCyclicAcquisition = APCI3120_DISABLE;
 
-			//UPDATE-0.7.57-&gt;0.7.68comedi_done(dev,s);
+			/* UPDATE-0.7.57-&gt;0.7.68comedi_done(dev,s); */
 			s-&gt;async-&gt;events |= COMEDI_CB_EOA;
 			comedi_event(dev, s);
 
@@ -1553,19 +1587,19 @@ void v_APCI3120_Interrupt(int irq, void *d)
 
 		case APCI3120_TIMER:
 
-			//Send a signal to from kernel to user space
+			/* Send a signal to from kernel to user space */
 			send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 			break;
 
 		case APCI3120_WATCHDOG:
 
-			//Send a signal to from kernel to user space
+			/* Send a signal to from kernel to user space */
 			send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 			break;
 
 		default:
 
-			// disable Timer Interrupt
+			/*  disable Timer Interrupt */
 
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
@@ -1596,7 +1630,7 @@ void v_APCI3120_Interrupt(int irq, void *d)
 			/* Clears the timer status register */
 			/************************************/
 			inw(dev-&gt;iobase + APCI3120_TIMER_STATUS_REGISTER);
-			v_APCI3120_InterruptDma(irq, d);	// do some data transfer
+			v_APCI3120_InterruptDma(irq, d);	/*  do some data transfer */
 		} else {
 			/* Stops the Timer */
 			outw(devpriv-&gt;
@@ -1630,31 +1664,7 @@ void v_APCI3120_Interrupt(int irq, void *d)
 +----------------------------------------------------------------------------+
 */
 
-/*
- * int i_APCI3120_InterruptHandleEos(struct comedi_device *dev)
-{
-       int n_chan,i;
-       short *data;
-       struct comedi_subdevice *s=dev-&gt;subdevices+0;
-       struct comedi_async *async = s-&gt;async;
-       data=async-&gt;data+async-&gt;buf_int_ptr;
-        n_chan=devpriv-&gt;ui_AiNbrofChannels;
-
-       for(i=0;i&lt;n_chan;i++)
-         {
-           data[i]=inw(dev-&gt;iobase+0);
-         }
-       async-&gt;buf_int_count+=n_chan*sizeof(short);
-       async-&gt;buf_int_ptr+=n_chan*sizeof(short);
-       comedi_eos(dev,s);
-       if (s-&gt;async-&gt;buf_int_ptr&gt;=s-&gt;async-&gt;data_len) //  for buffer rool over
-		         {
-*//* buffer rollover */
-/*	        s-&gt;async-&gt;buf_int_ptr=0;
-		comedi_eobuf(dev,s);
-         }
- 	return 0;
-}*/
+
 int i_APCI3120_InterruptHandleEos(struct comedi_device * dev)
 {
 	int n_chan, i;
@@ -1720,20 +1730,20 @@ void v_APCI3120_InterruptDma(int irq, void *d)
 
 		return;
 	}
-	samplesinbuf = samplesinbuf &gt;&gt; 1;	// number of received samples
+	samplesinbuf = samplesinbuf &gt;&gt; 1;	/*  number of received samples */
 	if (devpriv-&gt;b_DmaDoubleBuffer) {
-		// switch DMA buffers if is used double buffering
+		/*  switch DMA buffers if is used double buffering */
 		next_dma_buf = 1 - devpriv-&gt;ui_DmaActualBuffer;
 
 		ui_Tmp = AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO;
 		outl(ui_Tmp, devpriv-&gt;i_IobaseAddon + AMCC_OP_REG_AGCSTS);
 
-		// changed  since 16 bit interface for add on
+		/*  changed  since 16 bit interface for add on */
 		outw(APCI3120_ADD_ON_AGCSTS_LOW, devpriv-&gt;i_IobaseAddon + 0);
 		outw(APCI3120_ENABLE_TRANSFER_ADD_ON_LOW,
 			devpriv-&gt;i_IobaseAddon + 2);
 		outw(APCI3120_ADD_ON_AGCSTS_HIGH, devpriv-&gt;i_IobaseAddon + 0);
-		outw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH, devpriv-&gt;i_IobaseAddon + 2);	// 0x1000 is out putted in windows driver
+		outw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH, devpriv-&gt;i_IobaseAddon + 2);	/*  0x1000 is out putted in windows driver */
 
 		var = devpriv-&gt;ul_DmaBufferHw[next_dma_buf];
 		low_word = var &amp; 0xffff;
@@ -1761,54 +1771,18 @@ void v_APCI3120_InterruptDma(int irq, void *d)
 		outw(APCI3120_ADD_ON_MWTC_HIGH, devpriv-&gt;i_IobaseAddon + 0);
 		outw(high_word, devpriv-&gt;i_IobaseAddon + 2);
 
-		// To configure A2P FIFO
-		// ENABLE A2P FIFO WRITE AND ENABLE AMWEN
-		// AMWEN_ENABLE | A2P_FIFO_WRITE_ENABLE (0x01|0x02)=0x03
+/*
+ * To configure A2P FIFO
+ * ENABLE A2P FIFO WRITE AND ENABLE AMWEN
+ * AMWEN_ENABLE | A2P_FIFO_WRITE_ENABLE (0x01|0x02)=0x03
+ */
 		outw(3, devpriv-&gt;i_IobaseAddon + 4);
-		//initialise end of dma interrupt  AINT_WRITE_COMPL = ENABLE_WRITE_TC_INT(ADDI)
+		/* initialise end of dma interrupt  AINT_WRITE_COMPL = ENABLE_WRITE_TC_INT(ADDI) */
 		outl((APCI3120_FIFO_ADVANCE_ON_BYTE_2 |
 				APCI3120_ENABLE_WRITE_TC_INT),
 			devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_INTCSR);
 
 	}
-/*UPDATE-0.7.57-&gt;0.7.68
-	ptr=(short *)devpriv-&gt;ul_DmaBufferVirtual[devpriv-&gt;ui_DmaActualBuffer];
-
-
-	// if there is not enough space left in the buffer to copy all data contained in the DMABufferVirtual
-	if(s-&gt;async-&gt;buf_int_ptr+samplesinbuf*sizeof(short)&gt;=devpriv-&gt;ui_AiDataLength)
-	{
-		m=(devpriv-&gt;ui_AiDataLength-s-&gt;async-&gt;buf_int_ptr)/sizeof(short);
-		v_APCI3120_InterruptDmaMoveBlock16bit(dev,s,(void *)ptr,((void *)(devpriv-&gt;AiData))+s-&gt;async-&gt;buf_int_ptr,m);
-		s-&gt;async-&gt;buf_int_count+=m*sizeof(short);
-		ptr+=m*sizeof(short);
-                samplesinbuf-=m;
-		s-&gt;async-&gt;buf_int_ptr=0;
-		comedi_eobuf(dev,s);
-	}
-
-	if (samplesinbuf)
-	{
-	        v_APCI3120_InterruptDmaMoveBlock16bit(dev,s,(void *)ptr,((void *)(devpriv-&gt;AiData))+s-&gt;async-&gt;buf_int_ptr,samplesinbuf);
-
-		s-&gt;async-&gt;buf_int_count+=samplesinbuf*sizeof(short);
-		s-&gt;async-&gt;buf_int_ptr+=samplesinbuf*sizeof(short);
-		if (!(devpriv-&gt;ui_AiFlags &amp; TRIG_WAKE_EOS))
-		{
-			comedi_bufcheck(dev,s);
-                }
-	}
-	if (!devpriv-&gt;b_AiContinuous)
-	if ( devpriv-&gt;ui_AiActualScan&gt;=devpriv-&gt;ui_AiNbrofScans )
-	{
-	    // all data sampled
-	    i_APCI3120_StopCyclicAcquisition(dev,s);
-            devpriv-&gt;b_AiCyclicAcquisition=APCI3120_DISABLE;
-	    //DPRINTK("\n Single DMA completed..\n");
-		comedi_done(dev,s);
-            	return;
-	}
-*/
 	if (samplesinbuf) {
 		v_APCI3120_InterruptDmaMoveBlock16bit(dev, s,
 			devpriv-&gt;ul_DmaBufferVirtual[devpriv-&gt;
@@ -1821,7 +1795,7 @@ void v_APCI3120_InterruptDma(int irq, void *d)
 	}
 	if (!devpriv-&gt;b_AiContinuous)
 		if (devpriv-&gt;ui_AiActualScan &gt;= devpriv-&gt;ui_AiNbrofScans) {
-			// all data sampled
+			/*  all data sampled */
 			i_APCI3120_StopCyclicAcquisition(dev, s);
 			devpriv-&gt;b_AiCyclicAcquisition = APCI3120_DISABLE;
 			s-&gt;async-&gt;events |= COMEDI_CB_EOA;
@@ -1829,22 +1803,26 @@ void v_APCI3120_InterruptDma(int irq, void *d)
 			return;
 		}
 
-	if (devpriv-&gt;b_DmaDoubleBuffer) {	// switch dma buffers
+	if (devpriv-&gt;b_DmaDoubleBuffer) {	/*  switch dma buffers */
 		devpriv-&gt;ui_DmaActualBuffer = 1 - devpriv-&gt;ui_DmaActualBuffer;
 	} else {
-		// restart DMA if is not used double buffering
-		//ADDED REINITIALISE THE DMA
+/*
+ * restart DMA if is not used double buffering
+ * ADDED REINITIALISE THE DMA
+ */
 		ui_Tmp = AGCSTS_TC_ENABLE | AGCSTS_RESET_A2P_FIFO;
 		outl(ui_Tmp, devpriv-&gt;i_IobaseAddon + AMCC_OP_REG_AGCSTS);
 
-		// changed  since 16 bit interface for add on
+		/*  changed  since 16 bit interface for add on */
 		outw(APCI3120_ADD_ON_AGCSTS_LOW, devpriv-&gt;i_IobaseAddon + 0);
 		outw(APCI3120_ENABLE_TRANSFER_ADD_ON_LOW,
 			devpriv-&gt;i_IobaseAddon + 2);
 		outw(APCI3120_ADD_ON_AGCSTS_HIGH, devpriv-&gt;i_IobaseAddon + 0);
-		outw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH, devpriv-&gt;i_IobaseAddon + 2);	//
-		// A2P FIFO MANAGEMENT
-		// A2P fifo reset  &amp; transfer control enable
+		outw(APCI3120_ENABLE_TRANSFER_ADD_ON_HIGH, devpriv-&gt;i_IobaseAddon + 2);	/*  */
+/*
+ * A2P FIFO MANAGEMENT
+ * A2P fifo reset &amp; transfer control enable
+ */
 		outl(APCI3120_A2P_FIFO_MANAGEMENT,
 			devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_MCSR);
 
@@ -1858,7 +1836,7 @@ void v_APCI3120_InterruptDma(int irq, void *d)
 		outw(high_word, devpriv-&gt;i_IobaseAddon + 2);
 
 		var = devpriv-&gt;ui_DmaBufferUsesize[0];
-		low_word = var &amp; 0xffff;	//changed
+		low_word = var &amp; 0xffff;	/* changed */
 		var = devpriv-&gt;ui_DmaBufferUsesize[0];
 		high_word = var / 65536;
 		outw(APCI3120_ADD_ON_MWTC_LOW, devpriv-&gt;i_IobaseAddon + 0);
@@ -1866,11 +1844,13 @@ void v_APCI3120_InterruptDma(int irq, void *d)
 		outw(APCI3120_ADD_ON_MWTC_HIGH, devpriv-&gt;i_IobaseAddon + 0);
 		outw(high_word, devpriv-&gt;i_IobaseAddon + 2);
 
-		// To configure A2P FIFO
-		//ENABLE A2P FIFO WRITE AND ENABLE AMWEN
-		// AMWEN_ENABLE | A2P_FIFO_WRITE_ENABLE (0x01|0x02)=0x03
+/*
+ * To configure A2P FIFO
+ * ENABLE A2P FIFO WRITE AND ENABLE AMWEN
+ * AMWEN_ENABLE | A2P_FIFO_WRITE_ENABLE (0x01|0x02)=0x03
+ */
 		outw(3, devpriv-&gt;i_IobaseAddon + 4);
-		//initialise end of dma interrupt  AINT_WRITE_COMPL = ENABLE_WRITE_TC_INT(ADDI)
+		/* initialise end of dma interrupt  AINT_WRITE_COMPL = ENABLE_WRITE_TC_INT(ADDI) */
 		outl((APCI3120_FIFO_ADVANCE_ON_BYTE_2 |
 				APCI3120_ENABLE_WRITE_TC_INT),
 			devpriv-&gt;i_IobaseAmcc + AMCC_OP_REG_INTCSR);
@@ -1897,35 +1877,6 @@ void v_APCI3120_InterruptDma(int irq, void *d)
 +----------------------------------------------------------------------------+
 */
 
-/*void v_APCI3120_InterruptDmaMoveBlock16bit(struct comedi_device *dev,struct comedi_subdevice *s,short *dma,short *data,int n)
-{
-	int i,j,m;
-
-	j=s-&gt;async-&gt;cur_chan;
-	m=devpriv-&gt;ui_AiActualScanPosition;
-        for(i=0;i&lt;n;i++)
-	{
-		*data=*dma;
-   		data++; dma++;
-		j++;
-		if(j&gt;=devpriv-&gt;ui_AiNbrofChannels)
-		{
-			m+=j;
-			j=0;
-			if(m&gt;=devpriv-&gt;ui_AiScanLength)
-			{
-				m=0;
-			        devpriv-&gt;ui_AiActualScan++;
-				if (devpriv-&gt;ui_AiFlags &amp; TRIG_WAKE_EOS)
-;//UPDATE-0.7.57-&gt;0.7.68					comedi_eos(dev,s);
-			}
-		}
-	}
-        devpriv-&gt;ui_AiActualScanPosition=m;
-	s-&gt;async-&gt;cur_chan=j;
-
-}
-*/
 void v_APCI3120_InterruptDmaMoveBlock16bit(struct comedi_device * dev,
 	struct comedi_subdevice * s, short * dma_buffer, unsigned int num_samples)
 {
@@ -1979,60 +1930,66 @@ int i_APCI3120_InsnConfigTimer(struct comedi_device * dev, struct comedi_subdevi
 	if (!data[1])
 		comedi_error(dev, "config:No timer constant !");
 
-	devpriv-&gt;b_Timer2Interrupt = (unsigned char) data[2];	// save info whether to enable or disable interrupt
+	devpriv-&gt;b_Timer2Interrupt = (unsigned char) data[2];	/*  save info whether to enable or disable interrupt */
 
-	ui_Timervalue2 = data[1] / 1000;	// convert nano seconds  to u seconds
+	ui_Timervalue2 = data[1] / 1000;	/*  convert nano seconds  to u seconds */
 
-	//this_board-&gt;i_hwdrv_InsnConfigTimer(dev, ui_Timervalue2,(unsigned char)data[0]);
+	/* this_board-&gt;i_hwdrv_InsnConfigTimer(dev, ui_Timervalue2,(unsigned char)data[0]); */
 	us_TmpValue = (unsigned short) inw(devpriv-&gt;iobase + APCI3120_RD_STATUS);
 
-	//EL250804: Testing if board APCI3120 have the new Quartz or if it is an APCI3001
-	// and calculate the time value to set in the timer
+/*
+ * EL250804: Testing if board APCI3120 have the new Quartz or if it
+ * is an APCI3001 and calculate the time value to set in the timer
+ */
 	if ((us_TmpValue &amp; 0x00B0) == 0x00B0
 		|| !strcmp(this_board-&gt;pc_DriverName, "apci3001")) {
-		//Calculate the time value to set in the timer
+		/* Calculate the time value to set in the timer */
 		ui_Timervalue2 = ui_Timervalue2 / 50;
 	} else {
-		//Calculate the time value to set in the timer
+		/* Calculate the time value to set in the timer */
 		ui_Timervalue2 = ui_Timervalue2 / 70;
 	}
 
-	//Reset gate 2 of Timer 2 to disable it (Set Bit D14 to 0)
+	/* Reset gate 2 of Timer 2 to disable it (Set Bit D14 to 0) */
 	devpriv-&gt;us_OutputRegister =
 		devpriv-&gt;us_OutputRegister &amp; APCI3120_DISABLE_TIMER2;
 	outw(devpriv-&gt;us_OutputRegister, devpriv-&gt;iobase + APCI3120_WR_ADDRESS);
 
-	// Disable TIMER Interrupt
+	/*  Disable TIMER Interrupt */
 	devpriv-&gt;b_ModeSelectRegister =
 		devpriv-&gt;
 		b_ModeSelectRegister &amp; APCI3120_DISABLE_TIMER_INT &amp; 0xEF;
 
-	// Disable Eoc and Eos Interrupts
+	/*  Disable Eoc and Eos Interrupts */
 	devpriv-&gt;b_ModeSelectRegister =
 		devpriv-&gt;
 		b_ModeSelectRegister &amp; APCI3120_DISABLE_EOC_INT &amp;
 		APCI3120_DISABLE_EOS_INT;
 	outb(devpriv-&gt;b_ModeSelectRegister,
 		devpriv-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
-	if (data[0] == APCI3120_TIMER)	//initialize timer
+	if (data[0] == APCI3120_TIMER)	/* initialize timer */
 	{
+		/* devpriv-&gt;b_ModeSelectRegister=devpriv-&gt;b_ModeSelectRegister |
+		 * APCI3120_ENABLE_TIMER_INT; */
 
-		//devpriv-&gt;b_ModeSelectRegister=devpriv-&gt;b_ModeSelectRegister| APCI3120_ENABLE_TIMER_INT ;
-		//outb(devpriv-&gt;b_ModeSelectRegister,devpriv-&gt;iobase+APCI3120_WRITE_MODE_SELECT);
+		/* outb(devpriv-&gt;b_ModeSelectRegister,devpriv-&gt;iobase+APCI3120_WRITE_MODE_SELECT); */
 
-		//Set the Timer 2 in mode 2(Timer)
+		/* Set the Timer 2 in mode 2(Timer) */
 		devpriv-&gt;b_TimerSelectMode =
 			(devpriv-&gt;
 			b_TimerSelectMode &amp; 0x0F) | APCI3120_TIMER_2_MODE_2;
 		outb(devpriv-&gt;b_TimerSelectMode,
 			devpriv-&gt;iobase + APCI3120_TIMER_CRT1);
 
-		//Configure the timer 2 for writing the LOW unsigned short of timer is Delay value
-		//You must make a b_tmp variable with DigitalOutPutRegister because at Address_1+APCI3120_TIMER_CRT0
-		//you can set the digital output and configure the timer 2,and if you don't make this, digital output
-		//are erase (Set to 0)
-
-		//Writing LOW unsigned short
+/*
+ * Configure the timer 2 for writing the LOW unsigned short of timer
+ * is Delay value You must make a b_tmp variable with
+ * DigitalOutPutRegister because at Address_1+APCI3120_TIMER_CRT0
+ * you can set the digital output and configure the timer 2,and if
+ * you don't make this, digital output are erase (Set to 0)
+ */
+
+		/* Writing LOW unsigned short */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_LOW_WORD;
@@ -2040,20 +1997,20 @@ int i_APCI3120_InsnConfigTimer(struct comedi_device * dev, struct comedi_subdevi
 		outw(LOWORD(ui_Timervalue2),
 			devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
 
-		//Writing HIGH unsigned short
+		/* Writing HIGH unsigned short */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_HIGH_WORD;
 		outb(b_Tmp, devpriv-&gt;iobase + APCI3120_TIMER_CRT0);
 		outw(HIWORD(ui_Timervalue2),
 			devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
-		// timer2 in Timer mode enabled
+		/*  timer2 in Timer mode enabled */
 		devpriv-&gt;b_Timer2Mode = APCI3120_TIMER;
 
-	} else			// Initialize Watch dog
+	} else			/*  Initialize Watch dog */
 	{
 
-		//Set the Timer 2 in mode 5(Watchdog)
+		/* Set the Timer 2 in mode 5(Watchdog) */
 
 		devpriv-&gt;b_TimerSelectMode =
 			(devpriv-&gt;
@@ -2061,12 +2018,15 @@ int i_APCI3120_InsnConfigTimer(struct comedi_device * dev, struct comedi_subdevi
 		outb(devpriv-&gt;b_TimerSelectMode,
 			devpriv-&gt;iobase + APCI3120_TIMER_CRT1);
 
-		//Configure the timer 2 for writing the LOW unsigned short of timer is Delay value
-		//You must make a b_tmp variable with DigitalOutPutRegister because at Address_1+APCI3120_TIMER_CRT0
-		//you can set the digital output and configure the timer 2,and if you don't make this, digital output
-		//are erase (Set to 0)
-
-		//Writing LOW unsigned short
+/*
+ * Configure the timer 2 for writing the LOW unsigned short of timer
+ * is Delay value You must make a b_tmp variable with
+ * DigitalOutPutRegister because at Address_1+APCI3120_TIMER_CRT0
+ * you can set the digital output and configure the timer 2,and if
+ * you don't make this, digital output are erase (Set to 0)
+ */
+
+		/* Writing LOW unsigned short */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_LOW_WORD;
@@ -2074,7 +2034,7 @@ int i_APCI3120_InsnConfigTimer(struct comedi_device * dev, struct comedi_subdevi
 		outw(LOWORD(ui_Timervalue2),
 			devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
 
-		//Writing HIGH unsigned short
+		/* Writing HIGH unsigned short */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_HIGH_WORD;
@@ -2082,7 +2042,7 @@ int i_APCI3120_InsnConfigTimer(struct comedi_device * dev, struct comedi_subdevi
 
 		outw(HIWORD(ui_Timervalue2),
 			devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
-		//watchdog enabled
+		/* watchdog enabled */
 		devpriv-&gt;b_Timer2Mode = APCI3120_WATCHDOG;
 
 	}
@@ -2133,7 +2093,7 @@ int i_APCI3120_InsnWriteTimer(struct comedi_device * dev, struct comedi_subdevic
 		return -EINVAL;
 	}
 
-	if (data[0] == 2)	// write new value
+	if (data[0] == 2)	/*  write new value */
 	{
 		if (devpriv-&gt;b_Timer2Mode != APCI3120_TIMER) {
 			comedi_error(dev,
@@ -2147,35 +2107,35 @@ int i_APCI3120_InsnWriteTimer(struct comedi_device * dev, struct comedi_subdevic
 			ui_Timervalue2 = 0;
 	}
 
-	//this_board-&gt;i_hwdrv_InsnWriteTimer(dev,data[0],ui_Timervalue2);
+	/* this_board-&gt;i_hwdrv_InsnWriteTimer(dev,data[0],ui_Timervalue2); */
 
 	switch (data[0]) {
 	case APCI3120_START:
 
-		// Reset FC_TIMER BIT
+		/*  Reset FC_TIMER BIT */
 		inb(devpriv-&gt;iobase + APCI3120_TIMER_STATUS_REGISTER);
-		if (devpriv-&gt;b_Timer2Mode == APCI3120_TIMER)	//start timer
+		if (devpriv-&gt;b_Timer2Mode == APCI3120_TIMER)	/* start timer */
 		{
-			//Enable Timer
+			/* Enable Timer */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;b_ModeSelectRegister &amp; 0x0B;
-		} else		//start watch dog
+		} else		/* start watch dog */
 		{
-			//Enable WatchDog
+			/* Enable WatchDog */
 			devpriv-&gt;b_ModeSelectRegister =
 				(devpriv-&gt;
 				b_ModeSelectRegister &amp; 0x0B) |
 				APCI3120_ENABLE_WATCHDOG;
 		}
 
-		//enable disable interrupt
+		/* enable disable interrupt */
 		if ((devpriv-&gt;b_Timer2Interrupt) == APCI3120_ENABLE) {
 
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister |
 				APCI3120_ENABLE_TIMER_INT;
-			// save the task structure to pass info to user
+			/*  save the task structure to pass info to user */
 			devpriv-&gt;tsk_Current = current;
 		} else {
 
@@ -2187,9 +2147,9 @@ int i_APCI3120_InsnWriteTimer(struct comedi_device * dev, struct comedi_subdevic
 		outb(devpriv-&gt;b_ModeSelectRegister,
 			devpriv-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-		if (devpriv-&gt;b_Timer2Mode == APCI3120_TIMER)	//start timer
+		if (devpriv-&gt;b_Timer2Mode == APCI3120_TIMER)	/* start timer */
 		{
-			//For Timer mode is  Gate2 must be activated   **timer started
+			/* For Timer mode is  Gate2 must be activated   **timer started */
 			devpriv-&gt;us_OutputRegister =
 				devpriv-&gt;
 				us_OutputRegister | APCI3120_ENABLE_TIMER2;
@@ -2201,62 +2161,64 @@ int i_APCI3120_InsnWriteTimer(struct comedi_device * dev, struct comedi_subdevic
 
 	case APCI3120_STOP:
 		if (devpriv-&gt;b_Timer2Mode == APCI3120_TIMER) {
-			//Disable timer
+			/* Disable timer */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister &amp;
 				APCI3120_DISABLE_TIMER_COUNTER;
 		} else {
-			//Disable WatchDog
+			/* Disable WatchDog */
 			devpriv-&gt;b_ModeSelectRegister =
 				devpriv-&gt;
 				b_ModeSelectRegister &amp;
 				APCI3120_DISABLE_WATCHDOG;
 		}
-		// Disable timer interrupt
+		/*  Disable timer interrupt */
 		devpriv-&gt;b_ModeSelectRegister =
 			devpriv-&gt;
 			b_ModeSelectRegister &amp; APCI3120_DISABLE_TIMER_INT;
 
-		// Write above states  to register
+		/*  Write above states  to register */
 		outb(devpriv-&gt;b_ModeSelectRegister,
 			devpriv-&gt;iobase + APCI3120_WRITE_MODE_SELECT);
 
-		// Reset Gate 2
+		/*  Reset Gate 2 */
 		devpriv-&gt;us_OutputRegister =
 			devpriv-&gt;us_OutputRegister &amp; APCI3120_DISABLE_TIMER_INT;
 		outw(devpriv-&gt;us_OutputRegister,
 			devpriv-&gt;iobase + APCI3120_WR_ADDRESS);
 
-		// Reset FC_TIMER BIT
+		/*  Reset FC_TIMER BIT */
 		inb(devpriv-&gt;iobase + APCI3120_TIMER_STATUS_REGISTER);
 
-		// Disable timer
-		//devpriv-&gt;b_Timer2Mode=APCI3120_DISABLE;
+		/* Disable timer */
+		/* devpriv-&gt;b_Timer2Mode=APCI3120_DISABLE;  */
 
 		break;
 
-	case 2:		//write new value to Timer
+	case 2:		/* write new value to Timer */
 		if (devpriv-&gt;b_Timer2Mode != APCI3120_TIMER) {
 			comedi_error(dev,
 				"write :timer2  not configured  in TIMER MODE");
 			return -EINVAL;
 		}
-		// ui_Timervalue2=data[1]; // passed as argument
+		/*  ui_Timervalue2=data[1]; // passed as argument */
 		us_TmpValue =
 			(unsigned short) inw(devpriv-&gt;iobase + APCI3120_RD_STATUS);
 
-		//EL250804: Testing if board APCI3120 have the new Quartz or if it is an APCI3001
-		// and calculate the time value to set in the timer
+/*
+ * EL250804: Testing if board APCI3120 have the new Quartz or if it
+ * is an APCI3001 and calculate the time value to set in the timer
+ */
 		if ((us_TmpValue &amp; 0x00B0) == 0x00B0
 			|| !strcmp(this_board-&gt;pc_DriverName, "apci3001")) {
-			//Calculate the time value to set in the timer
+			/* Calculate the time value to set in the timer */
 			ui_Timervalue2 = ui_Timervalue2 / 50;
 		} else {
-			//Calculate the time value to set in the timer
+			/* Calculate the time value to set in the timer */
 			ui_Timervalue2 = ui_Timervalue2 / 70;
 		}
-		//Writing LOW unsigned short
+		/* Writing LOW unsigned short */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_LOW_WORD;
@@ -2265,7 +2227,7 @@ int i_APCI3120_InsnWriteTimer(struct comedi_device * dev, struct comedi_subdevic
 		outw(LOWORD(ui_Timervalue2),
 			devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
 
-		//Writing HIGH unsigned short
+		/* Writing HIGH unsigned short */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_HIGH_WORD;
@@ -2276,7 +2238,7 @@ int i_APCI3120_InsnWriteTimer(struct comedi_device * dev, struct comedi_subdevic
 
 		break;
 	default:
-		return -EINVAL;	// Not a valid input
+		return -EINVAL;	/*  Not a valid input */
 	}
 
 	return insn-&gt;n;
@@ -2316,10 +2278,10 @@ int i_APCI3120_InsnReadTimer(struct comedi_device * dev, struct comedi_subdevice
 		comedi_error(dev, "\nread:timer2  not configured ");
 	}
 
-	//this_board-&gt;i_hwdrv_InsnReadTimer(dev,data);
+	/* this_board-&gt;i_hwdrv_InsnReadTimer(dev,data); */
 	if (devpriv-&gt;b_Timer2Mode == APCI3120_TIMER) {
 
-		//Read the LOW unsigned short of Timer 2 register
+		/* Read the LOW unsigned short of Timer 2 register */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_LOW_WORD;
@@ -2327,7 +2289,7 @@ int i_APCI3120_InsnReadTimer(struct comedi_device * dev, struct comedi_subdevice
 
 		us_TmpValue = inw(devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
 
-		//Read the HIGH unsigned short of Timer 2 register
+		/* Read the HIGH unsigned short of Timer 2 register */
 		b_Tmp = ((devpriv-&gt;
 				b_DigitalOutputRegister) &amp; 0xF0) |
 			APCI3120_SELECT_TIMER_2_HIGH_WORD;
@@ -2335,20 +2297,20 @@ int i_APCI3120_InsnReadTimer(struct comedi_device * dev, struct comedi_subdevice
 
 		us_TmpValue_2 = inw(devpriv-&gt;iobase + APCI3120_TIMER_VALUE);
 
-		// combining both words
+		/*  combining both words */
 		data[0] = (unsigned int) ((us_TmpValue) | ((us_TmpValue_2) &lt;&lt; 16));
 
-	} else			// Read watch dog status
+	} else			/*  Read watch dog status */
 	{
 
 		us_StatusValue = inw(devpriv-&gt;iobase + APCI3120_RD_STATUS);
 		us_StatusValue =
 			((us_StatusValue &amp; APCI3120_FC_TIMER) &gt;&gt; 12) &amp; 1;
 		if (us_StatusValue == 1) {
-			// RESET FC_TIMER BIT
+			/*  RESET FC_TIMER BIT */
 			inb(devpriv-&gt;iobase + APCI3120_TIMER_STATUS_REGISTER);
 		}
-		data[0] = us_StatusValue;	// when data[0] = 1 then the watch dog has rundown
+		data[0] = us_StatusValue;	/*  when data[0] = 1 then the watch dog has rundown */
 	}
 	return insn-&gt;n;
 }
@@ -2386,19 +2348,21 @@ int i_APCI3120_InsnReadDigitalInput(struct comedi_device *dev,
 {
 	unsigned int ui_Chan, ui_TmpValue;
 
-	ui_Chan = CR_CHAN(insn-&gt;chanspec);	// channel specified
+	ui_Chan = CR_CHAN(insn-&gt;chanspec);	/*  channel specified */
 
-	//this_board-&gt;i_hwdrv_InsnReadDigitalInput(dev,ui_Chan,data);
+	/* this_board-&gt;i_hwdrv_InsnReadDigitalInput(dev,ui_Chan,data); */
 	if (ui_Chan &gt;= 0 &amp;&amp; ui_Chan &lt;= 3) {
 		ui_TmpValue = (unsigned int) inw(devpriv-&gt;iobase + APCI3120_RD_STATUS);
 
-		//      since only 1 channel reqd  to bring it to last bit it is rotated
-		//  8 +(chan - 1) times then ANDed with 1 for last bit.
+/*
+ * since only 1 channel reqd to bring it to last bit it is rotated 8
+ * +(chan - 1) times then ANDed with 1 for last bit.
+ */
 		*data = (ui_TmpValue &gt;&gt; (ui_Chan + 8)) &amp; 1;
-		//return 0;
+		/* return 0; */
 	} else {
-		//      comedi_error(dev," chan spec wrong");
-		return -EINVAL;	// "sorry channel spec wrong "
+		/*       comedi_error(dev," chan spec wrong"); */
+		return -EINVAL;	/*  "sorry channel spec wrong " */
 	}
 	return insn-&gt;n;
 
@@ -2434,7 +2398,7 @@ int i_APCI3120_InsnBitsDigitalInput(struct comedi_device * dev, struct comedi_su
 	*****/
 
 	*data = (ui_TmpValue &gt;&gt; 8) &amp; 0xf;
-	//this_board-&gt;i_hwdrv_InsnBitsDigitalInput(dev,data);
+	/* this_board-&gt;i_hwdrv_InsnBitsDigitalInput(dev,data); */
 	return insn-&gt;n;
 }
 
@@ -2481,7 +2445,7 @@ int i_APCI3120_InsnConfigDigitalOutput(struct comedi_device * dev,
 	if (!devpriv-&gt;b_OutputMemoryStatus) {
 		ui_Temp = 0;
 
-	}			//if(!devpriv-&gt;b_OutputMemoryStatus )
+	}			/* if(!devpriv-&gt;b_OutputMemoryStatus ) */
 
 	return insn-&gt;n;
 }
@@ -2530,7 +2494,7 @@ int i_APCI3120_InsnBitsDigitalOutput(struct comedi_device * dev,
 	default:
 		printk("\nThe parameter passed is in error \n");
 		return -EINVAL;
-	}			// switch(data[1])
+	}			/*  switch(data[1]) */
 	outb(data[0], devpriv-&gt;iobase + APCI3120_DIGITAL_OUTPUT);
 
 	devpriv-&gt;b_DigitalOutputRegister = data[0] &amp; 0xF0;
@@ -2569,7 +2533,7 @@ int i_APCI3120_InsnWriteDigitalOutput(struct comedi_device *dev,
 
 	unsigned int ui_Temp1;
 
-	unsigned int ui_NoOfChannel = CR_CHAN(insn-&gt;chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn-&gt;chanspec);	/*  get the channel */
 
 	if ((data[0] != 0) &amp;&amp; (data[0] != 1)) {
 		comedi_error(dev,
@@ -2586,7 +2550,7 @@ int i_APCI3120_InsnWriteDigitalOutput(struct comedi_device *dev,
 	switch (data[1]) {
 	case 1:
 		data[0] = (data[0] &lt;&lt; ui_NoOfChannel);
-//ES05                   data[0]=(data[0]&lt;&lt;4)|ui_Temp;
+/* ES05                   data[0]=(data[0]&lt;&lt;4)|ui_Temp; */
 		data[0] = (data[0] &lt;&lt; 4) | devpriv-&gt;b_DigitalOutputRegister;
 		break;
 
@@ -2595,22 +2559,22 @@ int i_APCI3120_InsnWriteDigitalOutput(struct comedi_device *dev,
 		ui_Temp1 = 1;
 		ui_Temp1 = ui_Temp1 &lt;&lt; ui_NoOfChannel;
 		ui_Temp1 = ui_Temp1 &lt;&lt; 4;
-//ES05                   ui_Temp=ui_Temp|ui_Temp1;
+/* ES05                   ui_Temp=ui_Temp|ui_Temp1; */
 		devpriv-&gt;b_DigitalOutputRegister =
 			devpriv-&gt;b_DigitalOutputRegister | ui_Temp1;
 
 		data[0] = (data[0] &lt;&lt; ui_NoOfChannel) ^ 0xf;
 		data[0] = data[0] &lt;&lt; 4;
-//ES05                   data[0]=data[0]&amp; ui_Temp;
+/* ES05                   data[0]=data[0]&amp; ui_Temp; */
 		data[0] = data[0] &amp; devpriv-&gt;b_DigitalOutputRegister;
 		break;
 	default:
 		printk("\nThe parameter passed is in error \n");
 		return -EINVAL;
-	}			// switch(data[1])
+	}			/*  switch(data[1]) */
 	outb(data[0], devpriv-&gt;iobase + APCI3120_DIGITAL_OUTPUT);
 
-//ES05        ui_Temp=data[0] &amp; 0xf0;
+/* ES05        ui_Temp=data[0] &amp; 0xf0; */
 	devpriv-&gt;b_DigitalOutputRegister = data[0] &amp; 0xf0;
 	return (insn-&gt;n);
 
@@ -2652,8 +2616,8 @@ int i_APCI3120_InsnWriteAnalogOutput(struct comedi_device *dev,
 	ui_Range = CR_RANGE(insn-&gt;chanspec);
 	ui_Channel = CR_CHAN(insn-&gt;chanspec);
 
-	//this_board-&gt;i_hwdrv_InsnWriteAnalogOutput(dev, ui_Range, ui_Channel,data[0]);
-	if (ui_Range)		// if 1 then unipolar
+	/* this_board-&gt;i_hwdrv_InsnWriteAnalogOutput(dev, ui_Range, ui_Channel,data[0]); */
+	if (ui_Range)		/*  if 1 then unipolar */
 	{
 
 		if (data[0] != 0)
@@ -2665,7 +2629,7 @@ int i_APCI3120_InsnWriteAnalogOutput(struct comedi_device *dev,
 				((((ui_Channel &amp; 0x03) &lt;&lt; 14) &amp; 0xC000) | (1 &lt;&lt;
 					13) | 8192);
 
-	} else			// if 0 then   bipolar
+	} else			/*  if 0 then   bipolar */
 	{
 		data[0] =
 			((((ui_Channel &amp; 0x03) &lt;&lt; 14) &amp; 0xC000) | (0 &lt;&lt; 13) |
@@ -2673,9 +2637,11 @@ int i_APCI3120_InsnWriteAnalogOutput(struct comedi_device *dev,
 
 	}
 
-	//out put n values at the given channel.
-	// rt_printk("\nwaiting for DA_READY BIT");
-	do			//Waiting of DA_READY BIT
+/*
+ * out put n values at the given channel. rt_printk("\nwaiting for
+ * DA_READY BIT");
+ */
+	do			/* Waiting of DA_READY BIT */
 	{
 		us_TmpValue =
 			((unsigned short) inw(devpriv-&gt;iobase +
@@ -2683,13 +2649,17 @@ int i_APCI3120_InsnWriteAnalogOutput(struct comedi_device *dev,
 	} while (us_TmpValue != 0x0001);
 
 	if (ui_Channel &lt;= 3)
-		// for channel 0-3 out at  the register 1 (wrDac1-8)
-		// data[i] typecasted to ushort since  word write is to be done
+/*
+ * for channel 0-3 out at the register 1 (wrDac1-8) data[i]
+ * typecasted to ushort since word write is to be done
+ */
 		outw((unsigned short) data[0],
 			devpriv-&gt;iobase + APCI3120_ANALOG_OUTPUT_1);
 	else
-		// for channel 4-7 out at the register 2 (wrDac5-8)
-		//data[i] typecasted to ushort since  word write is to be done
+/*
+ * for channel 4-7 out at the register 2 (wrDac5-8) data[i]
+ * typecasted to ushort since word write is to be done
+ */
 		outw((unsigned short) data[0],
 			devpriv-&gt;iobase + APCI3120_ANALOG_OUTPUT_2);
 </pre><hr><pre>commit f147598bc19efbb6ef1f34ae022b2d29d3ca3837
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:07 2009 -0400

    Staging: comedi: remove C99 comments in hwdrv_apci3200.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
index 64dc68c112dd..8981b0feaba7 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
@@ -57,21 +57,21 @@ You shoud also find the complete GPL in the COPYING file accompanying this sourc
   +----------------------------------------------------------------------------+
 */
 #include "hwdrv_apci3200.h"
-//Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 #include "addi_amcc_S5920.h"
-//#define PRINT_INFO
+/* #define PRINT_INFO */
 
-//End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
-//BEGIN JK 06.07.04: Management of sevrals boards
+/* BEGIN JK 06.07.04: Management of sevrals boards */
 /*
   int i_CJCAvailable=1;
   int i_CJCPolarity=0;
-  int i_CJCGain=2;//changed from 0 to 2
+  int i_CJCGain=2;/* changed from 0 to 2 */
   int i_InterruptFlag=0;
   int i_ADDIDATAPolarity;
   int i_ADDIDATAGain;
-  int i_AutoCalibration=0;   //: auto calibration
+  int i_AutoCalibration=0;   /* : auto calibration */
   int i_ADDIDATAConversionTime;
   int i_ADDIDATAConversionTimeUnit;
   int i_ADDIDATAType;
@@ -85,12 +85,12 @@ You shoud also find the complete GPL in the COPYING file accompanying this sourc
   unsigned int ui_Channel_num=0;
   static int i_Count=0;
   int i_Initialised=0;
-  unsigned int ui_InterruptChannelValue[96]; //Buffer
+  unsigned int ui_InterruptChannelValue[96]; /* Buffer */
 */
-struct str_BoardInfos s_BoardInfos[100];	// 100 will be the max number of boards to be used
-//END JK 06.07.04: Management of sevrals boards
+struct str_BoardInfos s_BoardInfos[100];	/*  100 will be the max number of boards to be used */
+/* END JK 06.07.04: Management of sevrals boards */
 
-//Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
 /*+----------------------------------------------------------------------------+*/
 /*| Function   Name   : int i_AddiHeaderRW_ReadEeprom                          |*/
@@ -136,15 +136,15 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 		while (dw_eeprom_busy == EEPROM_BUSY);
 
 		for (i_Counter = 0; i_Counter &lt; 2; i_Counter++) {
-			b_SelectedAddressLow = (w_EepromStartAddress + i_Counter) % 256;	//Read the low 8 bit part
-			b_SelectedAddressHigh = (w_EepromStartAddress + i_Counter) / 256;	//Read the high 8 bit part
+			b_SelectedAddressLow = (w_EepromStartAddress + i_Counter) % 256;	/* Read the low 8 bit part */
+			b_SelectedAddressHigh = (w_EepromStartAddress + i_Counter) / 256;	/* Read the high 8 bit part */
 
-			//Select the load low address mode
+			/* Select the load low address mode */
 			outb(NVCMD_LOAD_LOW,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				3);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -153,12 +153,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Load the low address
+			/* Load the low address */
 			outb(b_SelectedAddressLow,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				2);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -167,12 +167,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Select the load high address mode
+			/* Select the load high address mode */
 			outb(NVCMD_LOAD_HIGH,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				3);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -181,12 +181,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Load the high address
+			/* Load the high address */
 			outb(b_SelectedAddressHigh,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				2);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -195,12 +195,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Select the READ mode
+			/* Select the READ mode */
 			outb(NVCMD_BEGIN_READ,
 				dw_PCIBoardEepromAddress + AMCC_OP_REG_MCSR +
 				3);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -209,12 +209,12 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Read data into the EEPROM
+			/* Read data into the EEPROM */
 			*pb_ReadByte =
 				inb(dw_PCIBoardEepromAddress +
 				AMCC_OP_REG_MCSR + 2);
 
-			//Wait on busy
+			/* Wait on busy */
 			do {
 				dw_eeprom_busy =
 					inl(dw_PCIBoardEepromAddress +
@@ -223,14 +223,14 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 			}
 			while (dw_eeprom_busy == EEPROM_BUSY);
 
-			//Select the upper address part
+			/* Select the upper address part */
 			if (i_Counter == 0) {
 				b_ReadLowByte = pb_ReadByte[0];
 			} else {
 				b_ReadHighByte = pb_ReadByte[0];
 			}
 
-			//Sleep
+			/* Sleep */
 			for (i = 0; i &lt; 10000; i++) ;
 
 		}
@@ -240,9 +240,9 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 
 		pw_DataRead[i_WordCounter] = w_ReadWord;
 
-		w_EepromStartAddress += 2;	// to read the next word
+		w_EepromStartAddress += 2;	/*  to read the next word */
 
-	}			// for (...) i_NbOfWordsToRead
+	}			/*  for (...) i_NbOfWordsToRead */
 	return (0);
 }
 
@@ -281,8 +281,8 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
   /*****************************************/
   /** Get the Analog input header address **/
   /*****************************************/
-	i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-		dw_PCIBoardEepromAddress, 0x116,	//w_EepromStartAddress: Analog input header address
+	i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+		dw_PCIBoardEepromAddress, 0x116,	/* w_EepromStartAddress: Analog input header address */
 		&amp;w_AnalogInputMainHeaderAddress);
 
   /*******************************************/
@@ -293,8 +293,8 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
   /******************************/
   /** Get the number of moduls **/
   /******************************/
-	i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-		dw_PCIBoardEepromAddress, w_AnalogInputMainHeaderAddress + 0x02,	//w_EepromStartAddress: Number of conponment
+	i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+		dw_PCIBoardEepromAddress, w_AnalogInputMainHeaderAddress + 0x02,	/* w_EepromStartAddress: Number of conponment */
 		&amp;w_NumberOfModuls);
 
 	for (w_ModulCounter = 0; w_ModulCounter &lt; w_NumberOfModuls;
@@ -309,8 +309,8 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
       /****************************/
       /** Read first header size **/
       /****************************/
-		i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress,	// Address of the first header
+		i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress,	/*  Address of the first header */
 			&amp;w_FirstHeaderSize);
 
 		w_FirstHeaderSize = w_FirstHeaderSize &gt;&gt; 4;
@@ -318,8 +318,8 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
       /***************************/
       /** Read number of inputs **/
       /***************************/
-		i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x06,	// Number of inputs for the first modul
+		i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x06,	/*  Number of inputs for the first modul */
 			&amp;w_NumberOfInputs);
 
 		w_NumberOfInputs = w_NumberOfInputs &gt;&gt; 4;
@@ -327,17 +327,17 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
       /***********************/
       /** Read the CJC flag **/
       /***********************/
-		i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x08,	// CJC flag
+		i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x08,	/*  CJC flag */
 			&amp;w_CJCFlag);
 
-		w_CJCFlag = (w_CJCFlag &gt;&gt; 3) &amp; 0x1;	// Get only the CJC flag
+		w_CJCFlag = (w_CJCFlag &gt;&gt; 3) &amp; 0x1;	/*  Get only the CJC flag */
 
       /*******************************/
       /** Read number of gain value **/
       /*******************************/
-		i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x44,	// Number of gain value
+		i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+			dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 0x44,	/*  Number of gain value */
 			&amp;w_NumberOfGainValue);
 
 		w_NumberOfGainValue = w_NumberOfGainValue &amp; 0xFF;
@@ -354,8 +354,8 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
       /********************************************/
       /** Read current sources value for input 1 **/
       /********************************************/
-		i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-			dw_PCIBoardEepromAddress, w_SingleHeaderAddress,	//w_EepromStartAddress: Single header address
+		i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+			dw_PCIBoardEepromAddress, w_SingleHeaderAddress,	/* w_EepromStartAddress: Single header address */
 			&amp;w_SingleHeaderSize);
 
 		w_SingleHeaderSize = w_SingleHeaderSize &gt;&gt; 4;
@@ -370,8 +370,8 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
 	  /************************************/
 	  /** Read gain value for the module **/
 	  /************************************/
-			i_AddiHeaderRW_ReadEeprom(1,	//i_NbOfWordsToRead
-				dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 70 + (2 * (1 + (w_NumberOfGainValue / 16))) + (0x02 * w_GainIndex),	// Gain value
+			i_AddiHeaderRW_ReadEeprom(1,	/* i_NbOfWordsToRead */
+				dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 70 + (2 * (1 + (w_NumberOfGainValue / 16))) + (0x02 * w_GainIndex),	/*  Gain value */
 				&amp;w_GainValue);
 
 			BoardInformations-&gt;s_Module[w_ModulCounter].
@@ -386,8 +386,8 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
 	  /*************************************/
 	  /** Read gain factor for the module **/
 	  /*************************************/
-			i_AddiHeaderRW_ReadEeprom(2,	//i_NbOfWordsToRead
-				dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 70 + ((2 * w_NumberOfGainValue) + (2 * (1 + (w_NumberOfGainValue / 16)))) + (0x04 * w_GainIndex),	// Gain factor
+			i_AddiHeaderRW_ReadEeprom(2,	/* i_NbOfWordsToRead */
+				dw_PCIBoardEepromAddress, w_AnalogInputComponentAddress + 70 + ((2 * w_NumberOfGainValue) + (2 * (1 + (w_NumberOfGainValue / 16)))) + (0x04 * w_GainIndex),	/*  Gain factor */
 				w_GainFactorValue);
 
 			BoardInformations-&gt;s_Module[w_ModulCounter].
@@ -409,7 +409,7 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
 	  /********************************************/
 	  /** Read current sources value for input 1 **/
 	  /********************************************/
-			i_AddiHeaderRW_ReadEeprom(2,	//i_NbOfWordsToRead
+			i_AddiHeaderRW_ReadEeprom(2,	/* i_NbOfWordsToRead */
 				dw_PCIBoardEepromAddress,
 				(w_Input * w_SingleHeaderSize) +
 				w_SingleHeaderAddress + 0x0C, w_CurrentSources);
@@ -432,7 +432,7 @@ void v_GetAPCI3200EepromCalibrationValue(unsigned int dw_PCIBoardEepromAddress,
       /***************************************/
       /** Read the CJC current source value **/
       /***************************************/
-		i_AddiHeaderRW_ReadEeprom(2,	//i_NbOfWordsToRead
+		i_AddiHeaderRW_ReadEeprom(2,	/* i_NbOfWordsToRead */
 			dw_PCIBoardEepromAddress,
 			(w_Input * w_SingleHeaderSize) + w_SingleHeaderAddress +
 			0x0C, w_CurrentSources);
@@ -464,9 +464,9 @@ int i_APCI3200_GetChannelCalibrationValue(struct comedi_device * dev,
 	printk("\n Channel = %u", ui_Channel_num);
 #endif
 
-	//Test if single or differential mode
+	/* Test if single or differential mode */
 	if (s_BoardInfos[dev-&gt;minor].i_ConnectionType == 1) {
-		//if diff
+		/* if diff */
 
 		if ((ui_Channel_num &gt;= 0) &amp;&amp; (ui_Channel_num &lt;= 1))
 			i_DiffChannel = ui_Channel_num, i_Module = 0;
@@ -478,7 +478,7 @@ int i_APCI3200_GetChannelCalibrationValue(struct comedi_device * dev,
 			i_DiffChannel = ui_Channel_num - 6, i_Module = 3;
 
 	} else {
-		// if single
+		/*  if single */
 		if ((ui_Channel_num == 0) || (ui_Channel_num == 1))
 			i_DiffChannel = 0, i_Module = 0;
 		else if ((ui_Channel_num == 2) || (ui_Channel_num == 3))
@@ -497,7 +497,7 @@ int i_APCI3200_GetChannelCalibrationValue(struct comedi_device * dev,
 			i_DiffChannel = 1, i_Module = 3;
 	}
 
-	//Test if thermocouple or RTD mode
+	/* Test if thermocouple or RTD mode */
 	*CJCCurrentSource =
 		s_BoardInfos[dev-&gt;minor].s_Module[i_Module].ul_CurrentSourceCJC;
 #ifdef PRINT_INFO
@@ -510,22 +510,22 @@ int i_APCI3200_GetChannelCalibrationValue(struct comedi_device * dev,
 #ifdef PRINT_INFO
 	printk("\n ChannelCurrentSource = %lu", *ChannelCurrentSource);
 #endif
-	//      }
-	//   }
+	/*       } */
+	/*    } */
 
-	//Channle gain factor
+	/* Channle gain factor */
 	*ChannelGainFactor =
 		s_BoardInfos[dev-&gt;minor].s_Module[i_Module].
 		ul_GainFactor[s_BoardInfos[dev-&gt;minor].i_ADDIDATAGain];
 #ifdef PRINT_INFO
 	printk("\n ChannelGainFactor = %lu", *ChannelGainFactor);
 #endif
-	//End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+	/* End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
 	return (0);
 }
 
-//End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+/* End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
 /*
   +----------------------------------------------------------------------------+
@@ -561,13 +561,13 @@ int i_APCI3200_ReadDigitalInput(struct comedi_device * dev, struct comedi_subdev
 
 	if (ui_Temp == 0) {
 		*data = (*data &gt;&gt; ui_NoOfChannel) &amp; 0x1;
-	}			//if  (ui_Temp==0)
+	}			/* if  (ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			if (data[1] &lt; 0 || data[1] &gt; 1) {
 				printk("\nThe port number is in error\n");
 				return -EINVAL;
-			}	//if(data[1] &lt; 0 || data[1] &gt;1)
+			}	/* if(data[1] &lt; 0 || data[1] &gt;1) */
 			switch (ui_NoOfChannel) {
 
 			case 2:
@@ -578,13 +578,13 @@ int i_APCI3200_ReadDigitalInput(struct comedi_device * dev, struct comedi_subdev
 				break;
 			default:
 				comedi_error(dev, " chan spec wrong");
-				return -EINVAL;	// "sorry channel spec wrong "
+				return -EINVAL;	/*  "sorry channel spec wrong " */
 
-			}	//switch(ui_NoOfChannels)
-		}		//if  (ui_Temp==1)
+			}	/* switch(ui_NoOfChannels) */
+		}		/* if  (ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		//elseif  (ui_Temp==1)
+		}		/* elseif  (ui_Temp==1) */
 	}
 	return insn-&gt;n;
 }
@@ -616,13 +616,13 @@ int i_APCI3200_ConfigDigitalOutput(struct comedi_device * dev, struct comedi_sub
 		comedi_error(dev,
 			"Not a valid Data !!! ,Data should be 1 or 0\n");
 		return -EINVAL;
-	}			//if  ( (data[0]!=0) &amp;&amp; (data[0]!=1) )
+	}			/* if  ( (data[0]!=0) &amp;&amp; (data[0]!=1) ) */
 	if (data[0]) {
 		devpriv-&gt;b_OutputMemoryStatus = ADDIDATA_ENABLE;
-	}			// if  (data[0])
+	}			/*  if  (data[0]) */
 	else {
 		devpriv-&gt;b_OutputMemoryStatus = ADDIDATA_DISABLE;
-	}			//else if  (data[0])
+	}			/* else if  (data[0]) */
 	return insn-&gt;n;
 }
 
@@ -657,19 +657,19 @@ int i_APCI3200_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 	struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int ui_Temp = 0, ui_Temp1 = 0;
-	unsigned int ui_NoOfChannel = CR_CHAN(insn-&gt;chanspec);	// get the channel
+	unsigned int ui_NoOfChannel = CR_CHAN(insn-&gt;chanspec);	/*  get the channel */
 	if (devpriv-&gt;b_OutputMemoryStatus) {
 		ui_Temp = inl(devpriv-&gt;i_IobaseAddon);
 
-	}			//if(devpriv-&gt;b_OutputMemoryStatus )
+	}			/* if(devpriv-&gt;b_OutputMemoryStatus ) */
 	else {
 		ui_Temp = 0;
-	}			//if(devpriv-&gt;b_OutputMemoryStatus )
+	}			/* if(devpriv-&gt;b_OutputMemoryStatus ) */
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] &lt;&lt; ui_NoOfChannel) | ui_Temp;
 			outl(data[0], devpriv-&gt;i_IobaseAddon);
-		}		//if(data[1]==0)
+		}		/* if(data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				switch (ui_NoOfChannel) {
@@ -682,15 +682,15 @@ int i_APCI3200_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 				case 3:
 					data[0] = (data[0] | ui_Temp);
 					break;
-				}	//switch(ui_NoOfChannels)
+				}	/* switch(ui_NoOfChannels) */
 
 				outl(data[0], devpriv-&gt;i_IobaseAddon);
-			}	// if(data[1]==1)
+			}	/*  if(data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	//else if(data[1]==1)
-		}		//elseif(data[1]==0)
-	}			//if(data[3]==0)
+			}	/* else if(data[1]==1) */
+		}		/* elseif(data[1]==0) */
+	}			/* if(data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -701,7 +701,7 @@ int i_APCI3200_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 				data[0] = (data[0] &lt;&lt; ui_NoOfChannel) ^ 0xf;
 				data[0] = data[0] &amp; ui_Temp;
 				outl(data[0], devpriv-&gt;i_IobaseAddon);
-			}	//if(data[1]==0)
+			}	/* if(data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					switch (ui_NoOfChannel) {
@@ -725,21 +725,21 @@ int i_APCI3200_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 					default:
 						comedi_error(dev,
 							" chan spec wrong");
-						return -EINVAL;	// "sorry channel spec wrong "
-					}	//switch(ui_NoOfChannels)
+						return -EINVAL;	/*  "sorry channel spec wrong " */
+					}	/* switch(ui_NoOfChannels) */
 
 					outl(data[0], devpriv-&gt;i_IobaseAddon);
-				}	// if(data[1]==1)
+				}	/*  if(data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	//else if(data[1]==1)
-			}	//elseif(data[1]==0)
-		}		//if(data[3]==1);
+				}	/* else if(data[1]==1) */
+			}	/* elseif(data[1]==0) */
+		}		/* if(data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		//if else data[3]==1)
-	}			//if else data[3]==0)
+		}		/* if else data[3]==1) */
+	}			/* if else data[3]==0) */
 	return insn-&gt;n;
 }
 
@@ -776,13 +776,13 @@ int i_APCI3200_ReadDigitalOutput(struct comedi_device * dev, struct comedi_subde
 	*data = inl(devpriv-&gt;i_IobaseAddon);
 	if (ui_Temp == 0) {
 		*data = (*data &gt;&gt; ui_NoOfChannel) &amp; 0x1;
-	}			// if  (ui_Temp==0)
+	}			/*  if  (ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			if (data[1] &lt; 0 || data[1] &gt; 1) {
 				printk("\nThe port selection is in error\n");
 				return -EINVAL;
-			}	//if(data[1] &lt;0 ||data[1] &gt;1)
+			}	/* if(data[1] &lt;0 ||data[1] &gt;1) */
 			switch (ui_NoOfChannel) {
 			case 2:
 				*data = (*data &gt;&gt; (2 * data[1])) &amp; 3;
@@ -793,14 +793,14 @@ int i_APCI3200_ReadDigitalOutput(struct comedi_device * dev, struct comedi_subde
 
 			default:
 				comedi_error(dev, " chan spec wrong");
-				return -EINVAL;	// "sorry channel spec wrong "
+				return -EINVAL;	/*  "sorry channel spec wrong " */
 				break;
-			}	// switch(ui_NoOfChannels)
-		}		// if  (ui_Temp==1)
+			}	/*  switch(ui_NoOfChannels) */
+		}		/*  if  (ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		// else if (ui_Temp==1)
-	}			// else if  (ui_Temp==0)
+		}		/*  else if (ui_Temp==1) */
+	}			/*  else if  (ui_Temp==0) */
 	return insn-&gt;n;
 }
 
@@ -883,21 +883,21 @@ int i_APCI3200_ConfigAnalogInput(struct comedi_device * dev, struct comedi_subde
 	unsigned int ui_Dummy = 0;
 	int i_err = 0;
 
-	//Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+	/* Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
 #ifdef PRINT_INFO
 	int i = 0, i2 = 0;
 #endif
-	//End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+	/* End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	// Initialize the structure
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/*  Initialize the structure */
 	if (s_BoardInfos[dev-&gt;minor].b_StructInitialized != 1) {
 		s_BoardInfos[dev-&gt;minor].i_CJCAvailable = 1;
 		s_BoardInfos[dev-&gt;minor].i_CJCPolarity = 0;
-		s_BoardInfos[dev-&gt;minor].i_CJCGain = 2;	//changed from 0 to 2
+		s_BoardInfos[dev-&gt;minor].i_CJCGain = 2;	/* changed from 0 to 2 */
 		s_BoardInfos[dev-&gt;minor].i_InterruptFlag = 0;
-		s_BoardInfos[dev-&gt;minor].i_AutoCalibration = 0;	//: auto calibration
+		s_BoardInfos[dev-&gt;minor].i_AutoCalibration = 0;	/* : auto calibration */
 		s_BoardInfos[dev-&gt;minor].i_ChannelCount = 0;
 		s_BoardInfos[dev-&gt;minor].i_Sum = 0;
 		s_BoardInfos[dev-&gt;minor].ui_Channel_num = 0;
@@ -905,11 +905,11 @@ int i_APCI3200_ConfigAnalogInput(struct comedi_device * dev, struct comedi_subde
 		s_BoardInfos[dev-&gt;minor].i_Initialised = 0;
 		s_BoardInfos[dev-&gt;minor].b_StructInitialized = 1;
 
-		//Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+		/* Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 		s_BoardInfos[dev-&gt;minor].i_ConnectionType = 0;
-		//End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+		/* End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
-		//Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+		/* Begin JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 		memset(s_BoardInfos[dev-&gt;minor].s_Module, 0,
 			sizeof(s_BoardInfos[dev-&gt;minor].s_Module[MAX_MODULE]));
 
@@ -938,72 +938,72 @@ int i_APCI3200_ConfigAnalogInput(struct comedi_device * dev, struct comedi_subde
 			}
 		}
 #endif
-		//End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+		/* End JK 21.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 	}
 
 	if (data[0] != 0 &amp;&amp; data[0] != 1 &amp;&amp; data[0] != 2) {
 		printk("\nThe selection of acquisition type is in error\n");
 		i_err++;
-	}			//if(data[0]!=0 &amp;&amp; data[0]!=1 &amp;&amp; data[0]!=2)
+	}			/* if(data[0]!=0 &amp;&amp; data[0]!=1 &amp;&amp; data[0]!=2) */
 	if (data[0] == 1) {
 		if (data[14] != 0 &amp;&amp; data[14] != 1 &amp;&amp; data[14] != 2
 			&amp;&amp; data[14] != 4) {
 			printk("\n Error in selection of RTD connection type\n");
 			i_err++;
-		}		//if(data[14]!=0 &amp;&amp; data[14]!=1 &amp;&amp; data[14]!=2 &amp;&amp; data[14]!=4)
-	}			//if(data[0]==1 )
+		}		/* if(data[14]!=0 &amp;&amp; data[14]!=1 &amp;&amp; data[14]!=2 &amp;&amp; data[14]!=4) */
+	}			/* if(data[0]==1 ) */
 	if (data[1] &lt; 0 || data[1] &gt; 7) {
 		printk("\nThe selection of gain is in error\n");
 		i_err++;
-	}			// if(data[1]&lt;0 || data[1]&gt;7)
+	}			/*  if(data[1]&lt;0 || data[1]&gt;7) */
 	if (data[2] != 0 &amp;&amp; data[2] != 1) {
 		printk("\nThe selection of polarity is in error\n");
 		i_err++;
-	}			//if(data[2]!=0 &amp;&amp;  data[2]!=1)
+	}			/* if(data[2]!=0 &amp;&amp;  data[2]!=1) */
 	if (data[3] != 0) {
 		printk("\nThe selection of offset range  is in error\n");
 		i_err++;
-	}			// if(data[3]!=0)
+	}			/*  if(data[3]!=0) */
 	if (data[4] != 0 &amp;&amp; data[4] != 1) {
 		printk("\nThe selection of coupling is in error\n");
 		i_err++;
-	}			//if(data[4]!=0 &amp;&amp;  data[4]!=1)
+	}			/* if(data[4]!=0 &amp;&amp;  data[4]!=1) */
 	if (data[5] != 0 &amp;&amp; data[5] != 1) {
 		printk("\nThe selection of single/differential mode is in error\n");
 		i_err++;
-	}			//if(data[5]!=0 &amp;&amp;  data[5]!=1)
+	}			/* if(data[5]!=0 &amp;&amp;  data[5]!=1) */
 	if (data[8] != 0 &amp;&amp; data[8] != 1 &amp;&amp; data[2] != 2) {
 		printk("\nError in selection of functionality\n");
-	}			//if(data[8]!=0 &amp;&amp; data[8]!=1 &amp;&amp; data[2]!=2)
+	}			/* if(data[8]!=0 &amp;&amp; data[8]!=1 &amp;&amp; data[2]!=2) */
 	if (data[12] == 0 || data[12] == 1) {
 		if (data[6] != 20 &amp;&amp; data[6] != 40 &amp;&amp; data[6] != 80
 			&amp;&amp; data[6] != 160) {
 			printk("\nThe selection of conversion time reload value is in error\n");
 			i_err++;
-		}		// if (data[6]!=20 &amp;&amp; data[6]!=40 &amp;&amp; data[6]!=80 &amp;&amp; data[6]!=160 )
+		}		/*  if (data[6]!=20 &amp;&amp; data[6]!=40 &amp;&amp; data[6]!=80 &amp;&amp; data[6]!=160 ) */
 		if (data[7] != 2) {
 			printk("\nThe selection of conversion time unit  is in error\n");
 			i_err++;
-		}		// if(data[7]!=2)
+		}		/*  if(data[7]!=2) */
 	}
 	if (data[9] != 0 &amp;&amp; data[9] != 1) {
 		printk("\nThe selection of interrupt enable is in error\n");
 		i_err++;
-	}			//if(data[9]!=0 &amp;&amp;  data[9]!=1)
+	}			/* if(data[9]!=0 &amp;&amp;  data[9]!=1) */
 	if (data[11] &lt; 0 || data[11] &gt; 4) {
 		printk("\nThe selection of module is in error\n");
 		i_err++;
-	}			//if(data[11] &lt;0 ||  data[11]&gt;1)
+	}			/* if(data[11] &lt;0 ||  data[11]&gt;1) */
 	if (data[12] &lt; 0 || data[12] &gt; 3) {
 		printk("\nThe selection of singlechannel/scan selection is in error\n");
 		i_err++;
-	}			//if(data[12] &lt; 0 ||  data[12]&gt; 3)
+	}			/* if(data[12] &lt; 0 ||  data[12]&gt; 3) */
 	if (data[13] &lt; 0 || data[13] &gt; 16) {
 		printk("\nThe selection of number of channels is in error\n");
 		i_err++;
-	}			// if(data[13] &lt;0 ||data[13] &gt;15)
+	}			/*  if(data[13] &lt;0 ||data[13] &gt;15) */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
 	/*
 	   i_ChannelCount=data[13];
 	   i_ScanType=data[12];
@@ -1014,7 +1014,7 @@ int i_APCI3200_ConfigAnalogInput(struct comedi_device * dev, struct comedi_subde
 	   i_ADDIDATAType=data[0];
 	 */
 
-	// Save acquisition configuration for the actual board
+	/*  Save acquisition configuration for the actual board */
 	s_BoardInfos[dev-&gt;minor].i_ChannelCount = data[13];
 	s_BoardInfos[dev-&gt;minor].i_ScanType = data[12];
 	s_BoardInfos[dev-&gt;minor].i_ADDIDATAPolarity = data[2];
@@ -1022,307 +1022,307 @@ int i_APCI3200_ConfigAnalogInput(struct comedi_device * dev, struct comedi_subde
 	s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTime = data[6];
 	s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTimeUnit = data[7];
 	s_BoardInfos[dev-&gt;minor].i_ADDIDATAType = data[0];
-	//Begin JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
+	/* Begin JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
 	s_BoardInfos[dev-&gt;minor].i_ConnectionType = data[5];
-	//End JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-	//END JK 06.07.04: Management of sevrals boards
+	/* End JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+	/* END JK 06.07.04: Management of sevrals boards */
 
-	//Begin JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-	memset(s_BoardInfos[dev-&gt;minor].ui_ScanValueArray, 0, (7 + 12) * sizeof(unsigned int));	// 7 is the maximal number of channels
-	//End JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
+	/* Begin JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+	memset(s_BoardInfos[dev-&gt;minor].ui_ScanValueArray, 0, (7 + 12) * sizeof(unsigned int));	/*  7 is the maximal number of channels */
+	/* End JK 19.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
 
-	//BEGIN JK 02.07.04 : This while can't be do, it block the process when using severals boards
-	//while(i_InterruptFlag==1)
+	/* BEGIN JK 02.07.04 : This while can't be do, it block the process when using severals boards */
+	/* while(i_InterruptFlag==1) */
 	while (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == 1) {
 #ifndef MSXBOX
 		udelay(1);
 #else
-		// In the case where the driver is compiled for the MSX-Box
-		// we used a printk to have a little delay because udelay
-		// seems to be broken under the MSX-Box.
-		// This solution hat to be studied.
+		/*  In the case where the driver is compiled for the MSX-Box */
+		/*  we used a printk to have a little delay because udelay */
+		/*  seems to be broken under the MSX-Box. */
+		/*  This solution hat to be studied. */
 		printk("");
 #endif
 	}
-	//END JK 02.07.04 : This while can't be do, it block the process when using severals boards
+	/* END JK 02.07.04 : This while can't be do, it block the process when using severals boards */
 
-	ui_ChannelNo = CR_CHAN(insn-&gt;chanspec);	// get the channel
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//i_ChannelNo=ui_ChannelNo;
-	//ui_Channel_num =ui_ChannelNo;
+	ui_ChannelNo = CR_CHAN(insn-&gt;chanspec);	/*  get the channel */
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* i_ChannelNo=ui_ChannelNo; */
+	/* ui_Channel_num =ui_ChannelNo; */
 
 	s_BoardInfos[dev-&gt;minor].i_ChannelNo = ui_ChannelNo;
 	s_BoardInfos[dev-&gt;minor].ui_Channel_num = ui_ChannelNo;
 
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
 	if (data[5] == 0) {
 		if (ui_ChannelNo &lt; 0 || ui_ChannelNo &gt; 15) {
 			printk("\nThe Selection of the channel is in error\n");
 			i_err++;
-		}		// if(ui_ChannelNo&lt;0 || ui_ChannelNo&gt;15)
-	}			//if(data[5]==0)
+		}		/*  if(ui_ChannelNo&lt;0 || ui_ChannelNo&gt;15) */
+	}			/* if(data[5]==0) */
 	else {
 		if (data[14] == 2) {
 			if (ui_ChannelNo &lt; 0 || ui_ChannelNo &gt; 3) {
 				printk("\nThe Selection of the channel is in error\n");
 				i_err++;
-			}	// if(ui_ChannelNo&lt;0 || ui_ChannelNo&gt;3)
-		}		//if(data[14]==2)
+			}	/*  if(ui_ChannelNo&lt;0 || ui_ChannelNo&gt;3) */
+		}		/* if(data[14]==2) */
 		else {
 			if (ui_ChannelNo &lt; 0 || ui_ChannelNo &gt; 7) {
 				printk("\nThe Selection of the channel is in error\n");
 				i_err++;
-			}	// if(ui_ChannelNo&lt;0 || ui_ChannelNo&gt;7)
-		}		//elseif(data[14]==2)
-	}			//elseif(data[5]==0)
+			}	/*  if(ui_ChannelNo&lt;0 || ui_ChannelNo&gt;7) */
+		}		/* elseif(data[14]==2) */
+	}			/* elseif(data[5]==0) */
 	if (data[12] == 0 || data[12] == 1) {
 		switch (data[5]) {
 		case 0:
 			if (ui_ChannelNo &gt;= 0 &amp;&amp; ui_ChannelNo &lt;= 3) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_Offset=0;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_Offset=0; */
 				s_BoardInfos[dev-&gt;minor].i_Offset = 0;
-				//END JK 06.07.04: Management of sevrals boards
-			}	//if(ui_ChannelNo &gt;=0 &amp;&amp; ui_ChannelNo &lt;=3)
+				/* END JK 06.07.04: Management of sevrals boards */
+			}	/* if(ui_ChannelNo &gt;=0 &amp;&amp; ui_ChannelNo &lt;=3) */
 			if (ui_ChannelNo &gt;= 4 &amp;&amp; ui_ChannelNo &lt;= 7) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_Offset=64;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_Offset=64; */
 				s_BoardInfos[dev-&gt;minor].i_Offset = 64;
-				//END JK 06.07.04: Management of sevrals boards
-			}	//if(ui_ChannelNo &gt;=4 &amp;&amp; ui_ChannelNo &lt;=7)
+				/* END JK 06.07.04: Management of sevrals boards */
+			}	/* if(ui_ChannelNo &gt;=4 &amp;&amp; ui_ChannelNo &lt;=7) */
 			if (ui_ChannelNo &gt;= 8 &amp;&amp; ui_ChannelNo &lt;= 11) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_Offset=128;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_Offset=128; */
 				s_BoardInfos[dev-&gt;minor].i_Offset = 128;
-				//END JK 06.07.04: Management of sevrals boards
-			}	//if(ui_ChannelNo &gt;=8 &amp;&amp; ui_ChannelNo &lt;=11)
+				/* END JK 06.07.04: Management of sevrals boards */
+			}	/* if(ui_ChannelNo &gt;=8 &amp;&amp; ui_ChannelNo &lt;=11) */
 			if (ui_ChannelNo &gt;= 12 &amp;&amp; ui_ChannelNo &lt;= 15) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_Offset=192;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_Offset=192; */
 				s_BoardInfos[dev-&gt;minor].i_Offset = 192;
-				//END JK 06.07.04: Management of sevrals boards
-			}	//if(ui_ChannelNo &gt;=12 &amp;&amp; ui_ChannelNo &lt;=15)
+				/* END JK 06.07.04: Management of sevrals boards */
+			}	/* if(ui_ChannelNo &gt;=12 &amp;&amp; ui_ChannelNo &lt;=15) */
 			break;
 		case 1:
 			if (data[14] == 2) {
 				if (ui_ChannelNo == 0) {
-					//BEGIN JK 06.07.04: Management of sevrals boards
-					//i_Offset=0;
+					/* BEGIN JK 06.07.04: Management of sevrals boards */
+					/* i_Offset=0; */
 					s_BoardInfos[dev-&gt;minor].i_Offset = 0;
-					//END JK 06.07.04: Management of sevrals boards
-				}	//if(ui_ChannelNo ==0 )
+					/* END JK 06.07.04: Management of sevrals boards */
+				}	/* if(ui_ChannelNo ==0 ) */
 				if (ui_ChannelNo == 1) {
-					//BEGIN JK 06.07.04: Management of sevrals boards
-					//i_Offset=0;
+					/* BEGIN JK 06.07.04: Management of sevrals boards */
+					/* i_Offset=0; */
 					s_BoardInfos[dev-&gt;minor].i_Offset = 64;
-					//END JK 06.07.04: Management of sevrals boards
-				}	// if(ui_ChannelNo ==1)
+					/* END JK 06.07.04: Management of sevrals boards */
+				}	/*  if(ui_ChannelNo ==1) */
 				if (ui_ChannelNo == 2) {
-					//BEGIN JK 06.07.04: Management of sevrals boards
-					//i_Offset=128;
+					/* BEGIN JK 06.07.04: Management of sevrals boards */
+					/* i_Offset=128; */
 					s_BoardInfos[dev-&gt;minor].i_Offset = 128;
-					//END JK 06.07.04: Management of sevrals boards
-				}	//if(ui_ChannelNo ==2 )
+					/* END JK 06.07.04: Management of sevrals boards */
+				}	/* if(ui_ChannelNo ==2 ) */
 				if (ui_ChannelNo == 3) {
-					//BEGIN JK 06.07.04: Management of sevrals boards
-					//i_Offset=192;
+					/* BEGIN JK 06.07.04: Management of sevrals boards */
+					/* i_Offset=192; */
 					s_BoardInfos[dev-&gt;minor].i_Offset = 192;
-					//END JK 06.07.04: Management of sevrals boards
-				}	//if(ui_ChannelNo ==3)
+					/* END JK 06.07.04: Management of sevrals boards */
+				}	/* if(ui_ChannelNo ==3) */
 
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_ChannelNo=0;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_ChannelNo=0; */
 				s_BoardInfos[dev-&gt;minor].i_ChannelNo = 0;
-				//END JK 06.07.04: Management of sevrals boards
+				/* END JK 06.07.04: Management of sevrals boards */
 				ui_ChannelNo = 0;
 				break;
-			}	//if(data[14]==2)
+			}	/* if(data[14]==2) */
 			if (ui_ChannelNo &gt;= 0 &amp;&amp; ui_ChannelNo &lt;= 1) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_Offset=0;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_Offset=0; */
 				s_BoardInfos[dev-&gt;minor].i_Offset = 0;
-				//END JK 06.07.04: Management of sevrals boards
-			}	//if(ui_ChannelNo &gt;=0 &amp;&amp; ui_ChannelNo &lt;=1)
+				/* END JK 06.07.04: Management of sevrals boards */
+			}	/* if(ui_ChannelNo &gt;=0 &amp;&amp; ui_ChannelNo &lt;=1) */
 			if (ui_ChannelNo &gt;= 2 &amp;&amp; ui_ChannelNo &lt;= 3) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_ChannelNo=i_ChannelNo-2;
-				//i_Offset=64;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_ChannelNo=i_ChannelNo-2; */
+				/* i_Offset=64; */
 				s_BoardInfos[dev-&gt;minor].i_ChannelNo =
 					s_BoardInfos[dev-&gt;minor].i_ChannelNo -
 					2;
 				s_BoardInfos[dev-&gt;minor].i_Offset = 64;
-				//END JK 06.07.04: Management of sevrals boards
+				/* END JK 06.07.04: Management of sevrals boards */
 				ui_ChannelNo = ui_ChannelNo - 2;
-			}	//if(ui_ChannelNo &gt;=2 &amp;&amp; ui_ChannelNo &lt;=3)
+			}	/* if(ui_ChannelNo &gt;=2 &amp;&amp; ui_ChannelNo &lt;=3) */
 			if (ui_ChannelNo &gt;= 4 &amp;&amp; ui_ChannelNo &lt;= 5) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_ChannelNo=i_ChannelNo-4;
-				//i_Offset=128;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_ChannelNo=i_ChannelNo-4; */
+				/* i_Offset=128; */
 				s_BoardInfos[dev-&gt;minor].i_ChannelNo =
 					s_BoardInfos[dev-&gt;minor].i_ChannelNo -
 					4;
 				s_BoardInfos[dev-&gt;minor].i_Offset = 128;
-				//END JK 06.07.04: Management of sevrals boards
+				/* END JK 06.07.04: Management of sevrals boards */
 				ui_ChannelNo = ui_ChannelNo - 4;
-			}	//if(ui_ChannelNo &gt;=4 &amp;&amp; ui_ChannelNo &lt;=5)
+			}	/* if(ui_ChannelNo &gt;=4 &amp;&amp; ui_ChannelNo &lt;=5) */
 			if (ui_ChannelNo &gt;= 6 &amp;&amp; ui_ChannelNo &lt;= 7) {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//i_ChannelNo=i_ChannelNo-6;
-				//i_Offset=192;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* i_ChannelNo=i_ChannelNo-6; */
+				/* i_Offset=192; */
 				s_BoardInfos[dev-&gt;minor].i_ChannelNo =
 					s_BoardInfos[dev-&gt;minor].i_ChannelNo -
 					6;
 				s_BoardInfos[dev-&gt;minor].i_Offset = 192;
-				//END JK 06.07.04: Management of sevrals boards
+				/* END JK 06.07.04: Management of sevrals boards */
 				ui_ChannelNo = ui_ChannelNo - 6;
-			}	//if(ui_ChannelNo &gt;=6 &amp;&amp; ui_ChannelNo &lt;=7)
+			}	/* if(ui_ChannelNo &gt;=6 &amp;&amp; ui_ChannelNo &lt;=7) */
 			break;
 
 		default:
 			printk("\n This selection of polarity does not exist\n");
 			i_err++;
-		}		//switch(data[2])
-	}			//if(data[12]==0 || data[12]==1)
+		}		/* switch(data[2]) */
+	}			/* if(data[12]==0 || data[12]==1) */
 	else {
 		switch (data[11]) {
 		case 1:
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//i_Offset=0;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* i_Offset=0; */
 			s_BoardInfos[dev-&gt;minor].i_Offset = 0;
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 			break;
 		case 2:
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//i_Offset=64;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* i_Offset=64; */
 			s_BoardInfos[dev-&gt;minor].i_Offset = 64;
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 			break;
 		case 3:
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//i_Offset=128;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* i_Offset=128; */
 			s_BoardInfos[dev-&gt;minor].i_Offset = 128;
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 			break;
 		case 4:
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//i_Offset=192;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* i_Offset=192; */
 			s_BoardInfos[dev-&gt;minor].i_Offset = 192;
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 			break;
 		default:
 			printk("\nError in module selection\n");
 			i_err++;
-		}		// switch(data[11])
-	}			// elseif(data[12]==0 || data[12]==1)
+		}		/*  switch(data[11]) */
+	}			/*  elseif(data[12]==0 || data[12]==1) */
 	if (i_err) {
 		i_APCI3200_Reset(dev);
 		return -EINVAL;
 	}
-	//if(i_ScanType!=1)
+	/* if(i_ScanType!=1) */
 	if (s_BoardInfos[dev-&gt;minor].i_ScanType != 1) {
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//i_Count=0;
-		//i_Sum=0;
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* i_Count=0; */
+		/* i_Sum=0; */
 		s_BoardInfos[dev-&gt;minor].i_Count = 0;
 		s_BoardInfos[dev-&gt;minor].i_Sum = 0;
-		//END JK 06.07.04: Management of sevrals boards
-	}			//if(i_ScanType!=1)
+		/* END JK 06.07.04: Management of sevrals boards */
+	}			/* if(i_ScanType!=1) */
 
 	ul_Config =
 		data[1] | (data[2] &lt;&lt; 6) | (data[5] &lt;&lt; 7) | (data[3] &lt;&lt; 8) |
 		(data[4] &lt;&lt; 9);
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
   /*********************************/
 	/* Write the channel to configure */
   /*********************************/
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//outl(0 | ui_ChannelNo , devpriv-&gt;iobase+i_Offset + 0x4);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* outl(0 | ui_ChannelNo , devpriv-&gt;iobase+i_Offset + 0x4); */
 	outl(0 | ui_ChannelNo,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 0x4);
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
   /**************************/
 	/* Reset the configuration */
   /**************************/
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//outl(0 , devpriv-&gt;iobase+i_Offset + 0x0);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* outl(0 , devpriv-&gt;iobase+i_Offset + 0x0); */
 	outl(0, devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 0x0);
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
   /***************************/
 	/* Write the configuration */
   /***************************/
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//outl(ul_Config , devpriv-&gt;iobase+i_Offset + 0x0);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* outl(ul_Config , devpriv-&gt;iobase+i_Offset + 0x0); */
 	outl(ul_Config,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 0x0);
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
   /***************************/
 	/*Reset the calibration bit */
   /***************************/
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//ul_Temp = inl(devpriv-&gt;iobase+i_Offset + 12);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* ul_Temp = inl(devpriv-&gt;iobase+i_Offset + 12); */
 	ul_Temp = inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//outl((ul_Temp &amp; 0xFFF9FFFF) , devpriv-&gt;iobase+.i_Offset + 12);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* outl((ul_Temp &amp; 0xFFF9FFFF) , devpriv-&gt;iobase+.i_Offset + 12); */
 	outl((ul_Temp &amp; 0xFFF9FFFF),
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
 	if (data[9] == 1) {
 		devpriv-&gt;tsk_Current = current;
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//i_InterruptFlag=1;
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* i_InterruptFlag=1; */
 		s_BoardInfos[dev-&gt;minor].i_InterruptFlag = 1;
-		//END JK 06.07.04: Management of sevrals boards
-	}			// if(data[9]==1)
+		/* END JK 06.07.04: Management of sevrals boards */
+	}			/*  if(data[9]==1) */
 	else {
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//i_InterruptFlag=0;
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* i_InterruptFlag=0; */
 		s_BoardInfos[dev-&gt;minor].i_InterruptFlag = 0;
-		//END JK 06.07.04: Management of sevrals boards
-	}			//else  if(data[9]==1)
+		/* END JK 06.07.04: Management of sevrals boards */
+	}			/* else  if(data[9]==1) */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//i_Initialised=1;
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* i_Initialised=1; */
 	s_BoardInfos[dev-&gt;minor].i_Initialised = 1;
-	//END JK 06.07.04: Management of sevrals boards
+	/* END JK 06.07.04: Management of sevrals boards */
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//if(i_ScanType==1)
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* if(i_ScanType==1) */
 	if (s_BoardInfos[dev-&gt;minor].i_ScanType == 1)
-		//END JK 06.07.04: Management of sevrals boards
+		/* END JK 06.07.04: Management of sevrals boards */
 	{
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//i_Sum=i_Sum+1;
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* i_Sum=i_Sum+1; */
 		s_BoardInfos[dev-&gt;minor].i_Sum =
 			s_BoardInfos[dev-&gt;minor].i_Sum + 1;
-		//END JK 06.07.04: Management of sevrals boards
+		/* END JK 06.07.04: Management of sevrals boards */
 
 		insn-&gt;unused[0] = 0;
 		i_APCI3200_ReadAnalogInput(dev, s, insn, &amp;ui_Dummy);
@@ -1368,14 +1368,14 @@ int i_APCI3200_ReadAnalogInput(struct comedi_device * dev, struct comedi_subdevi
 	int i_ConvertCJCCalibration;
 	int i = 0;
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//if(i_Initialised==0)
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* if(i_Initialised==0) */
 	if (s_BoardInfos[dev-&gt;minor].i_Initialised == 0)
-		//END JK 06.07.04: Management of sevrals boards
+		/* END JK 06.07.04: Management of sevrals boards */
 	{
 		i_APCI3200_Reset(dev);
 		return -EINVAL;
-	}			//if(i_Initialised==0);
+	}			/* if(i_Initialised==0); */
 
 #ifdef PRINT_INFO
 	printk("\n insn-&gt;unused[0] = %i", insn-&gt;unused[0]);
@@ -1386,14 +1386,14 @@ int i_APCI3200_ReadAnalogInput(struct comedi_device * dev, struct comedi_subdevi
 
 		i_APCI3200_Read1AnalogInputChannel(dev, s, insn,
 			&amp;ui_DummyValue);
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//ui_InterruptChannelValue[i_Count+0]=ui_DummyValue;
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* ui_InterruptChannelValue[i_Count+0]=ui_DummyValue; */
 		s_BoardInfos[dev-&gt;minor].
 			ui_InterruptChannelValue[s_BoardInfos[dev-&gt;minor].
 			i_Count + 0] = ui_DummyValue;
-		//END JK 06.07.04: Management of sevrals boards
+		/* END JK 06.07.04: Management of sevrals boards */
 
-		//Begin JK 25.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+		/* Begin JK 25.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 		i_APCI3200_GetChannelCalibrationValue(dev,
 			s_BoardInfos[dev-&gt;minor].ui_Channel_num,
 			&amp;s_BoardInfos[dev-&gt;minor].
@@ -1414,62 +1414,62 @@ int i_APCI3200_ReadAnalogInput(struct comedi_device * dev, struct comedi_subdevi
 		printk("\n s_BoardInfos [dev-&gt;minor].ui_InterruptChannelValue[s_BoardInfos [dev-&gt;minor].i_Count+8] = %lu", s_BoardInfos[dev-&gt;minor].ui_InterruptChannelValue[s_BoardInfos[dev-&gt;minor].i_Count + 8]);
 #endif
 
-		//End JK 25.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+		/* End JK 25.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE) &amp;&amp; (i_CJCAvailable==1))
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE) &amp;&amp; (i_CJCAvailable==1)) */
 		if ((s_BoardInfos[dev-&gt;minor].i_ADDIDATAType == 2)
 			&amp;&amp; (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == FALSE)
 			&amp;&amp; (s_BoardInfos[dev-&gt;minor].i_CJCAvailable == 1))
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 		{
 			i_APCI3200_ReadCJCValue(dev, &amp;ui_DummyValue);
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//ui_InterruptChannelValue[i_Count + 3]=ui_DummyValue;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* ui_InterruptChannelValue[i_Count + 3]=ui_DummyValue; */
 			s_BoardInfos[dev-&gt;minor].
 				ui_InterruptChannelValue[s_BoardInfos[dev-&gt;
 					minor].i_Count + 3] = ui_DummyValue;
-			//END JK 06.07.04: Management of sevrals boards
-		}		//if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE))
+			/* END JK 06.07.04: Management of sevrals boards */
+		}		/* if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE)) */
 		else {
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//ui_InterruptChannelValue[i_Count + 3]=0;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* ui_InterruptChannelValue[i_Count + 3]=0; */
 			s_BoardInfos[dev-&gt;minor].
 				ui_InterruptChannelValue[s_BoardInfos[dev-&gt;
 					minor].i_Count + 3] = 0;
-			//END JK 06.07.04: Management of sevrals boards
-		}		//elseif((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE) &amp;&amp; (i_CJCAvailable==1))
+			/* END JK 06.07.04: Management of sevrals boards */
+		}		/* elseif((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE) &amp;&amp; (i_CJCAvailable==1)) */
 
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//if (( i_AutoCalibration == FALSE) &amp;&amp; (i_InterruptFlag == FALSE))
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* if (( i_AutoCalibration == FALSE) &amp;&amp; (i_InterruptFlag == FALSE)) */
 		if ((s_BoardInfos[dev-&gt;minor].i_AutoCalibration == FALSE)
 			&amp;&amp; (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == FALSE))
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 		{
 			i_APCI3200_ReadCalibrationOffsetValue(dev,
 				&amp;ui_DummyValue);
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//ui_InterruptChannelValue[i_Count + 1]=ui_DummyValue;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* ui_InterruptChannelValue[i_Count + 1]=ui_DummyValue; */
 			s_BoardInfos[dev-&gt;minor].
 				ui_InterruptChannelValue[s_BoardInfos[dev-&gt;
 					minor].i_Count + 1] = ui_DummyValue;
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 			i_APCI3200_ReadCalibrationGainValue(dev,
 				&amp;ui_DummyValue);
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//ui_InterruptChannelValue[i_Count + 2]=ui_DummyValue;
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* ui_InterruptChannelValue[i_Count + 2]=ui_DummyValue; */
 			s_BoardInfos[dev-&gt;minor].
 				ui_InterruptChannelValue[s_BoardInfos[dev-&gt;
 					minor].i_Count + 2] = ui_DummyValue;
-			//END JK 06.07.04: Management of sevrals boards
-		}		//if (( i_AutoCalibration == FALSE) &amp;&amp; (i_InterruptFlag == FALSE))
+			/* END JK 06.07.04: Management of sevrals boards */
+		}		/* if (( i_AutoCalibration == FALSE) &amp;&amp; (i_InterruptFlag == FALSE)) */
 
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE)&amp;&amp; (i_CJCAvailable==1))
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE)&amp;&amp; (i_CJCAvailable==1)) */
 		if ((s_BoardInfos[dev-&gt;minor].i_ADDIDATAType == 2)
 			&amp;&amp; (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == FALSE)
 			&amp;&amp; (s_BoardInfos[dev-&gt;minor].i_CJCAvailable == 1))
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 		{
 	  /**********************************************************/
 			/*Test if the Calibration channel must be read for the CJC */
@@ -1477,52 +1477,52 @@ int i_APCI3200_ReadAnalogInput(struct comedi_device * dev, struct comedi_subdevi
 	  /**********************************/
 			/*Test if the polarity is the same */
 	  /**********************************/
-			//BEGIN JK 06.07.04: Management of sevrals boards
-			//if(i_CJCPolarity!=i_ADDIDATAPolarity)
+			/* BEGIN JK 06.07.04: Management of sevrals boards */
+			/* if(i_CJCPolarity!=i_ADDIDATAPolarity) */
 			if (s_BoardInfos[dev-&gt;minor].i_CJCPolarity !=
 				s_BoardInfos[dev-&gt;minor].i_ADDIDATAPolarity)
-				//END JK 06.07.04: Management of sevrals boards
+				/* END JK 06.07.04: Management of sevrals boards */
 			{
 				i_ConvertCJCCalibration = 1;
-			}	//if(i_CJCPolarity!=i_ADDIDATAPolarity)
+			}	/* if(i_CJCPolarity!=i_ADDIDATAPolarity) */
 			else {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//if(i_CJCGain==i_ADDIDATAGain)
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* if(i_CJCGain==i_ADDIDATAGain) */
 				if (s_BoardInfos[dev-&gt;minor].i_CJCGain ==
 					s_BoardInfos[dev-&gt;minor].i_ADDIDATAGain)
-					//END JK 06.07.04: Management of sevrals boards
+					/* END JK 06.07.04: Management of sevrals boards */
 				{
 					i_ConvertCJCCalibration = 0;
-				}	//if(i_CJCGain==i_ADDIDATAGain)
+				}	/* if(i_CJCGain==i_ADDIDATAGain) */
 				else {
 					i_ConvertCJCCalibration = 1;
-				}	//elseif(i_CJCGain==i_ADDIDATAGain)
-			}	//elseif(i_CJCPolarity!=i_ADDIDATAPolarity)
+				}	/* elseif(i_CJCGain==i_ADDIDATAGain) */
+			}	/* elseif(i_CJCPolarity!=i_ADDIDATAPolarity) */
 			if (i_ConvertCJCCalibration == 1) {
 				i_APCI3200_ReadCJCCalOffset(dev,
 					&amp;ui_DummyValue);
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//ui_InterruptChannelValue[i_Count+4]=ui_DummyValue;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* ui_InterruptChannelValue[i_Count+4]=ui_DummyValue; */
 				s_BoardInfos[dev-&gt;minor].
 					ui_InterruptChannelValue[s_BoardInfos
 					[dev-&gt;minor].i_Count + 4] =
 					ui_DummyValue;
-				//END JK 06.07.04: Management of sevrals boards
+				/* END JK 06.07.04: Management of sevrals boards */
 
 				i_APCI3200_ReadCJCCalGain(dev, &amp;ui_DummyValue);
 
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//ui_InterruptChannelValue[i_Count+5]=ui_DummyValue;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* ui_InterruptChannelValue[i_Count+5]=ui_DummyValue; */
 				s_BoardInfos[dev-&gt;minor].
 					ui_InterruptChannelValue[s_BoardInfos
 					[dev-&gt;minor].i_Count + 5] =
 					ui_DummyValue;
-				//END JK 06.07.04: Management of sevrals boards
-			}	//if(i_ConvertCJCCalibration==1)
+				/* END JK 06.07.04: Management of sevrals boards */
+			}	/* if(i_ConvertCJCCalibration==1) */
 			else {
-				//BEGIN JK 06.07.04: Management of sevrals boards
-				//ui_InterruptChannelValue[i_Count+4]=0;
-				//ui_InterruptChannelValue[i_Count+5]=0;
+				/* BEGIN JK 06.07.04: Management of sevrals boards */
+				/* ui_InterruptChannelValue[i_Count+4]=0; */
+				/* ui_InterruptChannelValue[i_Count+5]=0; */
 
 				s_BoardInfos[dev-&gt;minor].
 					ui_InterruptChannelValue[s_BoardInfos
@@ -1530,36 +1530,36 @@ int i_APCI3200_ReadAnalogInput(struct comedi_device * dev, struct comedi_subdevi
 				s_BoardInfos[dev-&gt;minor].
 					ui_InterruptChannelValue[s_BoardInfos
 					[dev-&gt;minor].i_Count + 5] = 0;
-				//END JK 06.07.04: Management of sevrals boards
-			}	//elseif(i_ConvertCJCCalibration==1)
-		}		//if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE))
+				/* END JK 06.07.04: Management of sevrals boards */
+			}	/* elseif(i_ConvertCJCCalibration==1) */
+		}		/* if((i_ADDIDATAType==2) &amp;&amp; (i_InterruptFlag == FALSE)) */
 
-		//BEGIN JK 06.07.04: Management of sevrals boards
-		//if(i_ScanType!=1)
+		/* BEGIN JK 06.07.04: Management of sevrals boards */
+		/* if(i_ScanType!=1) */
 		if (s_BoardInfos[dev-&gt;minor].i_ScanType != 1) {
-			//i_Count=0;
+			/* i_Count=0; */
 			s_BoardInfos[dev-&gt;minor].i_Count = 0;
-		}		//if(i_ScanType!=1)
+		}		/* if(i_ScanType!=1) */
 		else {
-			//i_Count=i_Count +6;
-			//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-			//s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count +6;
+			/* i_Count=i_Count +6; */
+			/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+			/* s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count +6; */
 			s_BoardInfos[dev-&gt;minor].i_Count =
 				s_BoardInfos[dev-&gt;minor].i_Count + 9;
-			//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-		}		//else if(i_ScanType!=1)
+			/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+		}		/* else if(i_ScanType!=1) */
 
-		//if((i_ScanType==1) &amp;&amp;(i_InterruptFlag==1))
+		/* if((i_ScanType==1) &amp;&amp;(i_InterruptFlag==1)) */
 		if ((s_BoardInfos[dev-&gt;minor].i_ScanType == 1)
 			&amp;&amp; (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == 1)) {
-			//i_Count=i_Count-6;
-			//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-			//s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count-6;
+			/* i_Count=i_Count-6; */
+			/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+			/* s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count-6; */
 			s_BoardInfos[dev-&gt;minor].i_Count =
 				s_BoardInfos[dev-&gt;minor].i_Count - 9;
-			//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+			/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 		}
-		//if(i_ScanType==0)
+		/* if(i_ScanType==0) */
 		if (s_BoardInfos[dev-&gt;minor].i_ScanType == 0) {
 			/*
 			   data[0]= ui_InterruptChannelValue[0];
@@ -1591,41 +1591,41 @@ int i_APCI3200_ReadAnalogInput(struct comedi_device * dev, struct comedi_subdevi
 				s_BoardInfos[dev-&gt;minor].
 				ui_InterruptChannelValue[5];
 
-			//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-			//printk("\n 0 - i_APCI3200_GetChannelCalibrationValue data [6] = %lu, data [7] = %lu, data [8] = %lu", data [6], data [7], data [8]);
+			/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+			/* printk("\n 0 - i_APCI3200_GetChannelCalibrationValue data [6] = %lu, data [7] = %lu, data [8] = %lu", data [6], data [7], data [8]); */
 			i_APCI3200_GetChannelCalibrationValue(dev,
 				s_BoardInfos[dev-&gt;minor].ui_Channel_num,
 				&amp;data[6], &amp;data[7], &amp;data[8]);
-			//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+			/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 		}
 		break;
 	case 1:
 
 		for (i = 0; i &lt; insn-&gt;n; i++) {
-			//data[i]=ui_InterruptChannelValue[i];
+			/* data[i]=ui_InterruptChannelValue[i]; */
 			data[i] =
 				s_BoardInfos[dev-&gt;minor].
 				ui_InterruptChannelValue[i];
 		}
 
-		//i_Count=0;
-		//i_Sum=0;
-		//if(i_ScanType==1)
+		/* i_Count=0; */
+		/* i_Sum=0; */
+		/* if(i_ScanType==1) */
 		s_BoardInfos[dev-&gt;minor].i_Count = 0;
 		s_BoardInfos[dev-&gt;minor].i_Sum = 0;
 		if (s_BoardInfos[dev-&gt;minor].i_ScanType == 1) {
-			//i_Initialised=0;
-			//i_InterruptFlag=0;
+			/* i_Initialised=0; */
+			/* i_InterruptFlag=0; */
 			s_BoardInfos[dev-&gt;minor].i_Initialised = 0;
 			s_BoardInfos[dev-&gt;minor].i_InterruptFlag = 0;
-			//END JK 06.07.04: Management of sevrals boards
+			/* END JK 06.07.04: Management of sevrals boards */
 		}
 		break;
 	default:
 		printk("\nThe parameters passed are in error\n");
 		i_APCI3200_Reset(dev);
 		return -EINVAL;
-	}			//switch(insn-&gt;unused[0])
+	}			/* switch(insn-&gt;unused[0]) */
 
 	return insn-&gt;n;
 }
@@ -1658,42 +1658,42 @@ int i_APCI3200_Read1AnalogInputChannel(struct comedi_device * dev,
 	unsigned int ui_ChannelNo = 0;
 	unsigned int ui_CommandRegister = 0;
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//ui_ChannelNo=i_ChannelNo;
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* ui_ChannelNo=i_ChannelNo; */
 	ui_ChannelNo = s_BoardInfos[dev-&gt;minor].i_ChannelNo;
 
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
   /*********************************/
 	/* Write the channel to configure */
   /*********************************/
-	//Begin JK 20.10.2004: Bad channel value is used when using differential mode
-	//outl(0 | ui_Channel_num , devpriv-&gt;iobase+i_Offset + 0x4);
-	//outl(0 | s_BoardInfos [dev-&gt;minor].ui_Channel_num , devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 0x4);
+	/* Begin JK 20.10.2004: Bad channel value is used when using differential mode */
+	/* outl(0 | ui_Channel_num , devpriv-&gt;iobase+i_Offset + 0x4); */
+	/* outl(0 | s_BoardInfos [dev-&gt;minor].ui_Channel_num , devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 0x4); */
 	outl(0 | s_BoardInfos[dev-&gt;minor].i_ChannelNo,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 0x4);
-	//End JK 20.10.2004: Bad channel value is used when using differential mode
+	/* End JK 20.10.2004: Bad channel value is used when using differential mode */
 
   /*******************************/
 	/* Set the convert timing unit */
   /*******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-	//outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36);
+	/* outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTimeUnit,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 36);
 
   /**************************/
 	/* Set the convert timing */
   /**************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-	//outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32);
+	/* outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 32);
 
@@ -1707,36 +1707,36 @@ int i_APCI3200_Read1AnalogInputChannel(struct comedi_device * dev,
 	/*Test if the interrupt is enable */
   /*********************************/
 
-	//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_ENABLE) {
       /************************/
 		/* Enable the interrupt */
       /************************/
 		ui_CommandRegister = ui_CommandRegister | 0x00100000;
-	}			//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 
   /******************************/
 	/* Write the command register */
   /******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-	//outl(ui_CommandRegister, devpriv-&gt;iobase+i_Offset + 8);
+	/* outl(ui_CommandRegister, devpriv-&gt;iobase+i_Offset + 8); */
 	outl(ui_CommandRegister,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
 
   /*****************************/
 	/*Test if interrupt is enable */
   /*****************************/
-	//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_DISABLE) {
 		do {
 	  /*************************/
 			/*Read the EOC Status bit */
 	  /*************************/
 
-			//ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1;
+			/* ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1; */
 			ui_EOC = inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 20) &amp; 1;
 
@@ -1746,13 +1746,13 @@ int i_APCI3200_Read1AnalogInputChannel(struct comedi_device * dev,
 		/* Read the digital value of the input */
       /***************************************/
 
-		//data[0] = inl (devpriv-&gt;iobase+i_Offset + 28);
+		/* data[0] = inl (devpriv-&gt;iobase+i_Offset + 28); */
 		data[0] =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 28);
-		//END JK 06.07.04: Management of sevrals boards
+		/* END JK 06.07.04: Management of sevrals boards */
 
-	}			// if (i_InterruptFlag == ADDIDATA_DISABLE)
+	}			/*  if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	return 0;
 }
 
@@ -1781,49 +1781,49 @@ int i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device * dev, unsigned i
 	unsigned int ui_Temp = 0, ui_EOC = 0;
 	unsigned int ui_CommandRegister = 0;
 
-	//BEGIN JK 06.07.04: Management of sevrals boards
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* BEGIN JK 06.07.04: Management of sevrals boards */
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
   /*********************************/
 	/* Write the channel to configure */
   /*********************************/
-	//Begin JK 20.10.2004: This seems not necessary !
-	//outl(0 | ui_Channel_num , devpriv-&gt;iobase+i_Offset + 0x4);
-	//outl(0 | s_BoardInfos [dev-&gt;minor].ui_Channel_num , devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 0x4);
-	//End JK 20.10.2004: This seems not necessary !
+	/* Begin JK 20.10.2004: This seems not necessary ! */
+	/* outl(0 | ui_Channel_num , devpriv-&gt;iobase+i_Offset + 0x4); */
+	/* outl(0 | s_BoardInfos [dev-&gt;minor].ui_Channel_num , devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 0x4); */
+	/* End JK 20.10.2004: This seems not necessary ! */
 
   /*******************************/
 	/* Set the convert timing unit */
   /*******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36);
+	/* outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTimeUnit,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 36);
   /**************************/
 	/* Set the convert timing */
   /**************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32);
+	/* outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 32);
   /*****************************/
 	/*Read the calibration offset */
   /*****************************/
-	//ui_Temp = inl(devpriv-&gt;iobase+i_Offset + 12);
+	/* ui_Temp = inl(devpriv-&gt;iobase+i_Offset + 12); */
 	ui_Temp = inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
 
   /*********************************/
 	/*Configure the Offset Conversion */
   /*********************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl((ui_Temp | 0x00020000), devpriv-&gt;iobase+i_Offset + 12);
+	/* outl((ui_Temp | 0x00020000), devpriv-&gt;iobase+i_Offset + 12); */
 	outl((ui_Temp | 0x00020000),
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
   /*******************************/
@@ -1836,7 +1836,7 @@ int i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device * dev, unsigned i
 	/*Test if the interrupt is enable */
   /*********************************/
 
-	//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_ENABLE) {
 
       /**********************/
@@ -1845,7 +1845,7 @@ int i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device * dev, unsigned i
 
 		ui_CommandRegister = ui_CommandRegister | 0x00100000;
 
-	}			//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 
   /**********************/
 	/*Start the conversion */
@@ -1855,10 +1855,10 @@ int i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device * dev, unsigned i
   /***************************/
 	/*Write the command regiter */
   /***************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_CommandRegister, devpriv-&gt;iobase+i_Offset + 8);
+	/* outl(ui_CommandRegister, devpriv-&gt;iobase+i_Offset + 8); */
 	outl(ui_CommandRegister,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
 
@@ -1866,7 +1866,7 @@ int i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device * dev, unsigned i
 	/*Test if interrupt is enable */
   /*****************************/
 
-	//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_DISABLE) {
 
 		do {
@@ -1874,7 +1874,7 @@ int i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device * dev, unsigned i
 			/*Read the EOC flag */
 	  /*******************/
 
-			//ui_EOC = inl (devpriv-&gt;iobase+i_Offset + 20) &amp; 1;
+			/* ui_EOC = inl (devpriv-&gt;iobase+i_Offset + 20) &amp; 1; */
 			ui_EOC = inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 20) &amp; 1;
 
@@ -1884,11 +1884,11 @@ int i_APCI3200_ReadCalibrationOffsetValue(struct comedi_device * dev, unsigned i
 		/*Read the digital value of the calibration Offset */
       /**************************************************/
 
-		//data[0] = inl(devpriv-&gt;iobase+i_Offset+ 28);
+		/* data[0] = inl(devpriv-&gt;iobase+i_Offset+ 28); */
 		data[0] =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 28);
-	}			//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	return 0;
 }
 
@@ -1917,16 +1917,16 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
 	unsigned int ui_EOC = 0;
 	int ui_CommandRegister = 0;
 
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
   /*********************************/
 	/* Write the channel to configure */
   /*********************************/
-	//Begin JK 20.10.2004: This seems not necessary !
-	//outl(0 | ui_Channel_num , devpriv-&gt;iobase+i_Offset + 0x4);
-	//outl(0 | s_BoardInfos [dev-&gt;minor].ui_Channel_num , devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 0x4);
-	//End JK 20.10.2004: This seems not necessary !
+	/* Begin JK 20.10.2004: This seems not necessary ! */
+	/* outl(0 | ui_Channel_num , devpriv-&gt;iobase+i_Offset + 0x4); */
+	/* outl(0 | s_BoardInfos [dev-&gt;minor].ui_Channel_num , devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 0x4); */
+	/* End JK 20.10.2004: This seems not necessary ! */
 
   /***************************/
 	/*Read the calibration gain */
@@ -1934,28 +1934,28 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
   /*******************************/
 	/* Set the convert timing unit */
   /*******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36);
+	/* outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTimeUnit,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 36);
   /**************************/
 	/* Set the convert timing */
   /**************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32);
+	/* outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 32);
   /*******************************/
 	/*Configure the Gain Conversion */
   /*******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(0x00040000 , devpriv-&gt;iobase+i_Offset + 12);
+	/* outl(0x00040000 , devpriv-&gt;iobase+i_Offset + 12); */
 	outl(0x00040000,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
 
@@ -1969,7 +1969,7 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
 	/*Test if the interrupt is enable */
   /*********************************/
 
-	//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_ENABLE) {
 
       /**********************/
@@ -1978,7 +1978,7 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
 
 		ui_CommandRegister = ui_CommandRegister | 0x00100000;
 
-	}			//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 
   /**********************/
 	/*Start the conversion */
@@ -1988,10 +1988,10 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
   /***************************/
 	/*Write the command regiter */
   /***************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_CommandRegister , devpriv-&gt;iobase+i_Offset + 8);
+	/* outl(ui_CommandRegister , devpriv-&gt;iobase+i_Offset + 8); */
 	outl(ui_CommandRegister,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
 
@@ -1999,7 +1999,7 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
 	/*Test if interrupt is enable */
   /*****************************/
 
-	//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_DISABLE) {
 
 		do {
@@ -2008,7 +2008,7 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
 			/*Read the EOC flag */
 	  /*******************/
 
-			//ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1;
+			/* ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1; */
 			ui_EOC = inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 20) &amp; 1;
 
@@ -2018,12 +2018,12 @@ int i_APCI3200_ReadCalibrationGainValue(struct comedi_device * dev, unsigned int
 		/*Read the digital value of the calibration Gain */
       /************************************************/
 
-		//data[0] = inl(devpriv-&gt;iobase+i_Offset + 28);
+		/* data[0] = inl(devpriv-&gt;iobase+i_Offset + 28); */
 		data[0] =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 28);
 
-	}			//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	return 0;
 }
 
@@ -2057,32 +2057,32 @@ int i_APCI3200_ReadCJCValue(struct comedi_device * dev, unsigned int * data)
 	/*Set the converting time unit */
   /******************************/
 
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-	//outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36);
+	/* outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTimeUnit,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 36);
   /**************************/
 	/* Set the convert timing */
   /**************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-	//outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32);
+	/* outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 32);
 
   /******************************/
 	/*Configure the CJC Conversion */
   /******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-	//outl( 0x00000400 , devpriv-&gt;iobase+i_Offset + 4);
+	/* outl( 0x00000400 , devpriv-&gt;iobase+i_Offset + 4); */
 	outl(0x00000400,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 4);
   /*******************************/
@@ -2092,7 +2092,7 @@ int i_APCI3200_ReadCJCValue(struct comedi_device * dev, unsigned int * data)
   /*********************************/
 	/*Test if the interrupt is enable */
   /*********************************/
-	//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_ENABLE) {
       /**********************/
 		/*Enable the interrupt */
@@ -2109,10 +2109,10 @@ int i_APCI3200_ReadCJCValue(struct comedi_device * dev, unsigned int * data)
   /***************************/
 	/*Write the command regiter */
   /***************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_CommandRegister , devpriv-&gt;iobase+i_Offset + 8);
+	/* outl(ui_CommandRegister , devpriv-&gt;iobase+i_Offset + 8); */
 	outl(ui_CommandRegister,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
 
@@ -2120,7 +2120,7 @@ int i_APCI3200_ReadCJCValue(struct comedi_device * dev, unsigned int * data)
 	/*Test if interrupt is enable */
   /*****************************/
 
-	//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_DISABLE) {
 		do {
 
@@ -2128,7 +2128,7 @@ int i_APCI3200_ReadCJCValue(struct comedi_device * dev, unsigned int * data)
 			/*Read the EOC flag */
 	  /*******************/
 
-			//ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1;
+			/* ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1; */
 			ui_EOC = inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 20) &amp; 1;
 
@@ -2138,12 +2138,12 @@ int i_APCI3200_ReadCJCValue(struct comedi_device * dev, unsigned int * data)
 		/*Read the digital value of the CJC */
       /***********************************/
 
-		//data[0] = inl(devpriv-&gt;iobase+i_Offset + 28);
+		/* data[0] = inl(devpriv-&gt;iobase+i_Offset + 28); */
 		data[0] =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 28);
 
-	}			//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	return 0;
 }
 
@@ -2177,37 +2177,37 @@ int i_APCI3200_ReadCJCCalOffset(struct comedi_device * dev, unsigned int * data)
   /*******************************/
 	/* Set the convert timing unit */
   /*******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36);
+	/* outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTimeUnit,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 36);
   /**************************/
 	/* Set the convert timing */
   /**************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32);
+	/* outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 32);
   /******************************/
 	/*Configure the CJC Conversion */
   /******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(0x00000400 , devpriv-&gt;iobase+i_Offset + 4);
+	/* outl(0x00000400 , devpriv-&gt;iobase+i_Offset + 4); */
 	outl(0x00000400,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 4);
   /*********************************/
 	/*Configure the Offset Conversion */
   /*********************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(0x00020000, devpriv-&gt;iobase+i_Offset + 12);
+	/* outl(0x00020000, devpriv-&gt;iobase+i_Offset + 12); */
 	outl(0x00020000,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
   /*******************************/
@@ -2218,7 +2218,7 @@ int i_APCI3200_ReadCJCCalOffset(struct comedi_device * dev, unsigned int * data)
 	/*Test if the interrupt is enable */
   /*********************************/
 
-	//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_ENABLE) {
       /**********************/
 		/*Enable the interrupt */
@@ -2234,19 +2234,19 @@ int i_APCI3200_ReadCJCCalOffset(struct comedi_device * dev, unsigned int * data)
   /***************************/
 	/*Write the command regiter */
   /***************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_CommandRegister,devpriv-&gt;iobase+i_Offset + 8);
+	/* outl(ui_CommandRegister,devpriv-&gt;iobase+i_Offset + 8); */
 	outl(ui_CommandRegister,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
-	//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_DISABLE) {
 		do {
 	  /*******************/
 			/*Read the EOC flag */
 	  /*******************/
-			//ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1;
+			/* ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1; */
 			ui_EOC = inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 20) &amp; 1;
 		} while (ui_EOC != 1);
@@ -2254,11 +2254,11 @@ int i_APCI3200_ReadCJCCalOffset(struct comedi_device * dev, unsigned int * data)
       /**************************************************/
 		/*Read the digital value of the calibration Offset */
       /**************************************************/
-		//data[0] = inl(devpriv-&gt;iobase+i_Offset + 28);
+		/* data[0] = inl(devpriv-&gt;iobase+i_Offset + 28); */
 		data[0] =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 28);
-	}			//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	return 0;
 }
 
@@ -2290,37 +2290,37 @@ int i_APCI3200_ReadCJCCalGain(struct comedi_device * dev, unsigned int * data)
   /*******************************/
 	/* Set the convert timing unit */
   /*******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36);
+	/* outl(i_ADDIDATAConversionTimeUnit , devpriv-&gt;iobase+i_Offset + 36); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTimeUnit,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 36);
   /**************************/
 	/* Set the convert timing */
   /**************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32);
+	/* outl(i_ADDIDATAConversionTime , devpriv-&gt;iobase+i_Offset + 32); */
 	outl(s_BoardInfos[dev-&gt;minor].i_ADDIDATAConversionTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 32);
   /******************************/
 	/*Configure the CJC Conversion */
   /******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(0x00000400,devpriv-&gt;iobase+i_Offset + 4);
+	/* outl(0x00000400,devpriv-&gt;iobase+i_Offset + 4); */
 	outl(0x00000400,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 4);
   /*******************************/
 	/*Configure the Gain Conversion */
   /*******************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(0x00040000,devpriv-&gt;iobase+i_Offset + 12);
+	/* outl(0x00040000,devpriv-&gt;iobase+i_Offset + 12); */
 	outl(0x00040000,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
 
@@ -2331,7 +2331,7 @@ int i_APCI3200_ReadCJCCalGain(struct comedi_device * dev, unsigned int * data)
   /*********************************/
 	/*Test if the interrupt is enable */
   /*********************************/
-	//if (i_InterruptFlag == ADDIDATA_ENABLE)
+	/* if (i_InterruptFlag == ADDIDATA_ENABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_ENABLE) {
       /**********************/
 		/*Enable the interrupt */
@@ -2345,30 +2345,30 @@ int i_APCI3200_ReadCJCCalGain(struct comedi_device * dev, unsigned int * data)
   /***************************/
 	/*Write the command regiter */
   /***************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_CommandRegister ,devpriv-&gt;iobase+i_Offset + 8);
+	/* outl(ui_CommandRegister ,devpriv-&gt;iobase+i_Offset + 8); */
 	outl(ui_CommandRegister,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
-	//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == ADDIDATA_DISABLE) {
 		do {
 	  /*******************/
 			/*Read the EOC flag */
 	  /*******************/
-			//ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1;
+			/* ui_EOC = inl(devpriv-&gt;iobase+i_Offset + 20) &amp; 1; */
 			ui_EOC = inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 20) &amp; 1;
 		} while (ui_EOC != 1);
       /************************************************/
 		/*Read the digital value of the calibration Gain */
       /************************************************/
-		//data[0] = inl (devpriv-&gt;iobase+i_Offset + 28);
+		/* data[0] = inl (devpriv-&gt;iobase+i_Offset + 28); */
 		data[0] =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 28);
-	}			//if (i_InterruptFlag == ADDIDATA_DISABLE)
+	}			/* if (i_InterruptFlag == ADDIDATA_DISABLE) */
 	return 0;
 }
 
@@ -2408,29 +2408,29 @@ int i_APCI3200_InsnBits_AnalogInput_Test(struct comedi_device * dev,
 	struct comedi_subdevice * s, struct comedi_insn * insn, unsigned int * data)
 {
 	unsigned int ui_Configuration = 0;
-	int i_Temp;		//,i_TimeUnit;
-	//if(i_Initialised==0)
+	int i_Temp;		/* ,i_TimeUnit; */
+	/* if(i_Initialised==0) */
 
 	if (s_BoardInfos[dev-&gt;minor].i_Initialised == 0) {
 		i_APCI3200_Reset(dev);
 		return -EINVAL;
-	}			//if(i_Initialised==0);
+	}			/* if(i_Initialised==0); */
 	if (data[0] != 0 &amp;&amp; data[0] != 1) {
 		printk("\nError in selection of functionality\n");
 		i_APCI3200_Reset(dev);
 		return -EINVAL;
-	}			//if(data[0]!=0 &amp;&amp; data[0]!=1)
+	}			/* if(data[0]!=0 &amp;&amp; data[0]!=1) */
 
-	if (data[0] == 1)	//Perform Short Circuit TEST
+	if (data[0] == 1)	/* Perform Short Circuit TEST */
 	{
       /**************************/
 		/*Set the short-cicuit bit */
       /**************************/
-		//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+		/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 		while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].
 						i_Offset + 12) &gt;&gt; 19) &amp; 1) !=
 			1) ;
-		//outl((0x00001000 |i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4);
+		/* outl((0x00001000 |i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4); */
 		outl((0x00001000 | s_BoardInfos[dev-&gt;minor].i_ChannelNo),
 			devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 			4);
@@ -2439,19 +2439,19 @@ int i_APCI3200_InsnBits_AnalogInput_Test(struct comedi_device * dev,
       /*************************/
 		/* i_TimeUnit= i_ADDIDATAConversionTimeUnit;
 		   i_ADDIDATAConversionTimeUnit= 1; */
-		//i_Temp= i_InterruptFlag ;
+		/* i_Temp= i_InterruptFlag ; */
 		i_Temp = s_BoardInfos[dev-&gt;minor].i_InterruptFlag;
-		//i_InterruptFlag = ADDIDATA_DISABLE;
+		/* i_InterruptFlag = ADDIDATA_DISABLE; */
 		s_BoardInfos[dev-&gt;minor].i_InterruptFlag = ADDIDATA_DISABLE;
 		i_APCI3200_Read1AnalogInputChannel(dev, s, insn, data);
-		//if(i_AutoCalibration == FALSE)
+		/* if(i_AutoCalibration == FALSE) */
 		if (s_BoardInfos[dev-&gt;minor].i_AutoCalibration == FALSE) {
-			//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+			/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 			while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].
 							i_Offset +
 							12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-			//outl((0x00001000 |i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4);
+			/* outl((0x00001000 |i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4); */
 			outl((0x00001000 | s_BoardInfos[dev-&gt;minor].
 					i_ChannelNo),
 				devpriv-&gt;iobase +
@@ -2462,15 +2462,15 @@ int i_APCI3200_InsnBits_AnalogInput_Test(struct comedi_device * dev,
 			i_APCI3200_ReadCalibrationGainValue(dev, data);
 		}
 	} else {
-		//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+		/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 		while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].
 						i_Offset + 12) &gt;&gt; 19) &amp; 1) !=
 			1) ;
-		//outl((0x00000800|i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4);
+		/* outl((0x00000800|i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4); */
 		outl((0x00000800 | s_BoardInfos[dev-&gt;minor].i_ChannelNo),
 			devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 			4);
-		//ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 0);
+		/* ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 0); */
 		ui_Configuration =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 0);
@@ -2479,18 +2479,18 @@ int i_APCI3200_InsnBits_AnalogInput_Test(struct comedi_device * dev,
       /*************************/
 		/* i_TimeUnit= i_ADDIDATAConversionTimeUnit;
 		   i_ADDIDATAConversionTimeUnit= 1; */
-		//i_Temp= i_InterruptFlag ;
+		/* i_Temp= i_InterruptFlag ; */
 		i_Temp = s_BoardInfos[dev-&gt;minor].i_InterruptFlag;
-		//i_InterruptFlag = ADDIDATA_DISABLE;
+		/* i_InterruptFlag = ADDIDATA_DISABLE; */
 		s_BoardInfos[dev-&gt;minor].i_InterruptFlag = ADDIDATA_DISABLE;
 		i_APCI3200_Read1AnalogInputChannel(dev, s, insn, data);
-		//if(i_AutoCalibration == FALSE)
+		/* if(i_AutoCalibration == FALSE) */
 		if (s_BoardInfos[dev-&gt;minor].i_AutoCalibration == FALSE) {
-			//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+			/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 			while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].
 							i_Offset +
 							12) &gt;&gt; 19) &amp; 1) != 1) ;
-			//outl((0x00000800|i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4);
+			/* outl((0x00000800|i_ChannelNo) , devpriv-&gt;iobase+i_Offset + 4); */
 			outl((0x00000800 | s_BoardInfos[dev-&gt;minor].
 					i_ChannelNo),
 				devpriv-&gt;iobase +
@@ -2501,9 +2501,9 @@ int i_APCI3200_InsnBits_AnalogInput_Test(struct comedi_device * dev,
 			i_APCI3200_ReadCalibrationGainValue(dev, data);
 		}
 	}
-	//i_InterruptFlag=i_Temp ;
+	/* i_InterruptFlag=i_Temp ; */
 	s_BoardInfos[dev-&gt;minor].i_InterruptFlag = i_Temp;
-	//printk("\ni_InterruptFlag=%d\n",i_InterruptFlag);
+	/* printk("\ni_InterruptFlag=%d\n",i_InterruptFlag); */
 	return insn-&gt;n;
 }
 
@@ -2565,7 +2565,7 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 {
 
 	int err = 0;
-	int tmp;		// divisor1,divisor2;
+	int tmp;		/*  divisor1,divisor2; */
 	unsigned int ui_ConvertTime = 0;
 	unsigned int ui_ConvertTimeBase = 0;
 	unsigned int ui_DelayTime = 0;
@@ -2576,7 +2576,7 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 	int i_Cpt = 0;
 	double d_ConversionTimeForAllChannels = 0.0;
 	double d_SCANTimeNewUnit = 0.0;
-	// step 1: make sure trigger sources are trivially valid
+	/*  step 1: make sure trigger sources are trivially valid */
 
 	tmp = cmd-&gt;start_src;
 	cmd-&gt;start_src &amp;= TRIG_NOW | TRIG_EXT;
@@ -2598,10 +2598,10 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 	cmd-&gt;stop_src &amp;= TRIG_COUNT | TRIG_NONE;
 	if (!cmd-&gt;stop_src || tmp != cmd-&gt;stop_src)
 		err++;
-	//if(i_InterruptFlag==0)
+	/* if(i_InterruptFlag==0) */
 	if (s_BoardInfos[dev-&gt;minor].i_InterruptFlag == 0) {
 		err++;
-		//          printk("\nThe interrupt should be enabled\n");
+		/*           printk("\nThe interrupt should be enabled\n"); */
 	}
 	if (err) {
 		i_APCI3200_Reset(dev);
@@ -2643,9 +2643,9 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 		i_APCI3200_Reset(dev);
 		return 2;
 	}
-	//i_FirstChannel=cmd-&gt;chanlist[0];
+	/* i_FirstChannel=cmd-&gt;chanlist[0]; */
 	s_BoardInfos[dev-&gt;minor].i_FirstChannel = cmd-&gt;chanlist[0];
-	//i_LastChannel=cmd-&gt;chanlist[1];
+	/* i_LastChannel=cmd-&gt;chanlist[1]; */
 	s_BoardInfos[dev-&gt;minor].i_LastChannel = cmd-&gt;chanlist[1];
 
 	if (cmd-&gt;convert_src == TRIG_TIMER) {
@@ -2656,11 +2656,11 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 		{
 			printk("\nThe selection of conversion time reload value is in error\n");
 			err++;
-		}		// if (ui_ConvertTime!=20 &amp;&amp; ui_ConvertTime!=40 &amp;&amp; ui_ConvertTime!=80 &amp;&amp; ui_ConvertTime!=160 )
+		}		/*  if (ui_ConvertTime!=20 &amp;&amp; ui_ConvertTime!=40 &amp;&amp; ui_ConvertTime!=80 &amp;&amp; ui_ConvertTime!=160 ) */
 		if (ui_ConvertTimeBase != 2) {
 			printk("\nThe selection of conversion time unit  is in error\n");
 			err++;
-		}		//if(ui_ConvertTimeBase!=2)
+		}		/* if(ui_ConvertTimeBase!=2) */
 	} else {
 		ui_ConvertTime = 0;
 		ui_ConvertTimeBase = 0;
@@ -2668,7 +2668,7 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 	if (cmd-&gt;scan_begin_src == TRIG_FOLLOW) {
 		ui_DelayTime = 0;
 		ui_DelayTimeBase = 0;
-	}			//if(cmd-&gt;scan_begin_src==TRIG_FOLLOW)
+	}			/* if(cmd-&gt;scan_begin_src==TRIG_FOLLOW) */
 	else {
 		ui_DelayTime = cmd-&gt;scan_begin_arg &amp; 0xFFFF;
 		ui_DelayTimeBase = cmd-&gt;scan_begin_arg &gt;&gt; 16;
@@ -2686,7 +2686,7 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 		}
 		fpu_begin();
 		d_SCANTimeNewUnit = (double)ui_DelayTime;
-		//i_NbrOfChannel= i_LastChannel-i_FirstChannel + 4;
+		/* i_NbrOfChannel= i_LastChannel-i_FirstChannel + 4; */
 		i_NbrOfChannel =
 			s_BoardInfos[dev-&gt;minor].i_LastChannel -
 			s_BoardInfos[dev-&gt;minor].i_FirstChannel + 4;
@@ -2736,7 +2736,7 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 			err++;
 		}
 		fpu_end();
-	}			//else if(cmd-&gt;scan_begin_src==TRIG_FOLLOW)
+	}			/* else if(cmd-&gt;scan_begin_src==TRIG_FOLLOW) */
 
 	if (err) {
 		i_APCI3200_Reset(dev);
@@ -2767,10 +2767,10 @@ int i_APCI3200_CommandTestAnalogInput(struct comedi_device * dev, struct comedi_
 int i_APCI3200_StopCyclicAcquisition(struct comedi_device * dev, struct comedi_subdevice * s)
 {
 	unsigned int ui_Configuration = 0;
-	//i_InterruptFlag=0;
-	//i_Initialised=0;
-	//i_Count=0;
-	//i_Sum=0;
+	/* i_InterruptFlag=0; */
+	/* i_Initialised=0; */
+	/* i_Count=0; */
+	/* i_Sum=0; */
 	s_BoardInfos[dev-&gt;minor].i_InterruptFlag = 0;
 	s_BoardInfos[dev-&gt;minor].i_Initialised = 0;
 	s_BoardInfos[dev-&gt;minor].i_Count = 0;
@@ -2779,16 +2779,16 @@ int i_APCI3200_StopCyclicAcquisition(struct comedi_device * dev, struct comedi_s
   /*******************/
 	/*Read the register */
   /*******************/
-	//ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 8);
+	/* ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 8); */
 	ui_Configuration =
 		inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
   /*****************************/
 	/*Reset the START and IRQ bit */
   /*****************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl((ui_Configuration &amp; 0xFFE7FFFF),devpriv-&gt;iobase+i_Offset + 8);
+	/* outl((ui_Configuration &amp; 0xFFE7FFFF),devpriv-&gt;iobase+i_Offset + 8); */
 	outl((ui_Configuration &amp; 0xFFE7FFFF),
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
 	return 0;
@@ -2818,7 +2818,7 @@ int i_APCI3200_CommandAnalogInput(struct comedi_device * dev, struct comedi_subd
 {
 	struct comedi_cmd *cmd = &amp;s-&gt;async-&gt;cmd;
 	unsigned int ui_Configuration = 0;
-	//INT  i_CurrentSource = 0;
+	/* INT  i_CurrentSource = 0; */
 	unsigned int ui_Trigger = 0;
 	unsigned int ui_TriggerEdge = 0;
 	unsigned int ui_Triggermode = 0;
@@ -2828,38 +2828,38 @@ int i_APCI3200_CommandAnalogInput(struct comedi_device * dev, struct comedi_subd
 	unsigned int ui_DelayTime = 0;
 	unsigned int ui_DelayTimeBase = 0;
 	unsigned int ui_DelayMode = 0;
-	//i_FirstChannel=cmd-&gt;chanlist[0];
-	//i_LastChannel=cmd-&gt;chanlist[1];
+	/* i_FirstChannel=cmd-&gt;chanlist[0]; */
+	/* i_LastChannel=cmd-&gt;chanlist[1]; */
 	s_BoardInfos[dev-&gt;minor].i_FirstChannel = cmd-&gt;chanlist[0];
 	s_BoardInfos[dev-&gt;minor].i_LastChannel = cmd-&gt;chanlist[1];
 	if (cmd-&gt;start_src == TRIG_EXT) {
 		ui_Trigger = 1;
 		ui_TriggerEdge = cmd-&gt;start_arg &amp; 0xFFFF;
 		ui_Triggermode = cmd-&gt;start_arg &gt;&gt; 16;
-	}			//if(cmd-&gt;start_src==TRIG_EXT)
+	}			/* if(cmd-&gt;start_src==TRIG_EXT) */
 	else {
 		ui_Trigger = 0;
-	}			//elseif(cmd-&gt;start_src==TRIG_EXT)
+	}			/* elseif(cmd-&gt;start_src==TRIG_EXT) */
 
 	if (cmd-&gt;stop_src == TRIG_COUNT) {
 		ui_ScanMode = 0;
-	}			// if (cmd-&gt;stop_src==TRIG_COUNT)
+	}			/*  if (cmd-&gt;stop_src==TRIG_COUNT) */
 	else {
 		ui_ScanMode = 2;
-	}			//else if (cmd-&gt;stop_src==TRIG_COUNT)
+	}			/* else if (cmd-&gt;stop_src==TRIG_COUNT) */
 
 	if (cmd-&gt;scan_begin_src == TRIG_FOLLOW) {
 		ui_DelayTime = 0;
 		ui_DelayTimeBase = 0;
 		ui_DelayMode = 0;
-	}			//if(cmd-&gt;scan_begin_src==TRIG_FOLLOW)
+	}			/* if(cmd-&gt;scan_begin_src==TRIG_FOLLOW) */
 	else {
 		ui_DelayTime = cmd-&gt;scan_begin_arg &amp; 0xFFFF;
 		ui_DelayTimeBase = cmd-&gt;scan_begin_arg &gt;&gt; 16;
 		ui_DelayMode = 1;
-	}			//else if(cmd-&gt;scan_begin_src==TRIG_FOLLOW)
-	//        printk("\nui_DelayTime=%u\n",ui_DelayTime);
-	//        printk("\nui_DelayTimeBase=%u\n",ui_DelayTimeBase);
+	}			/* else if(cmd-&gt;scan_begin_src==TRIG_FOLLOW) */
+	/*         printk("\nui_DelayTime=%u\n",ui_DelayTime); */
+	/*         printk("\nui_DelayTimeBase=%u\n",ui_DelayTimeBase); */
 	if (cmd-&gt;convert_src == TRIG_TIMER) {
 		ui_ConvertTime = cmd-&gt;convert_arg &amp; 0xFFFF;
 		ui_ConvertTimeBase = cmd-&gt;convert_arg &gt;&gt; 16;
@@ -2868,34 +2868,34 @@ int i_APCI3200_CommandAnalogInput(struct comedi_device * dev, struct comedi_subd
 		ui_ConvertTimeBase = 0;
 	}
 
-	// if(i_ADDIDATAType ==1 || ((i_ADDIDATAType==2)))
-	//   {
+	/*  if(i_ADDIDATAType ==1 || ((i_ADDIDATAType==2))) */
+	/*    { */
   /**************************************************/
 	/*Read the old configuration of the current source */
   /**************************************************/
-	//ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 12);
+	/* ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 12); */
 	ui_Configuration =
 		inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
   /***********************************************/
 	/*Write the configuration of the current source */
   /***********************************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl((ui_Configuration &amp; 0xFFC00000 ), devpriv-&gt;iobase+i_Offset +12);
+	/* outl((ui_Configuration &amp; 0xFFC00000 ), devpriv-&gt;iobase+i_Offset +12); */
 	outl((ui_Configuration &amp; 0xFFC00000),
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 12);
-	// }
+	/*  } */
 	ui_Configuration = 0;
-	//     printk("\nfirstchannel=%u\n",i_FirstChannel);
-	//     printk("\nlastchannel=%u\n",i_LastChannel);
-	//     printk("\nui_Trigger=%u\n",ui_Trigger);
-	//     printk("\nui_TriggerEdge=%u\n",ui_TriggerEdge);
-	//     printk("\nui_Triggermode=%u\n",ui_Triggermode);
-	//      printk("\nui_DelayMode=%u\n",ui_DelayMode);
-	//     printk("\nui_ScanMode=%u\n",ui_ScanMode);
-
-	//ui_Configuration = i_FirstChannel |(i_LastChannel &lt;&lt; 8)| 0x00100000 |
+	/*      printk("\nfirstchannel=%u\n",i_FirstChannel); */
+	/*      printk("\nlastchannel=%u\n",i_LastChannel); */
+	/*      printk("\nui_Trigger=%u\n",ui_Trigger); */
+	/*      printk("\nui_TriggerEdge=%u\n",ui_TriggerEdge); */
+	/*      printk("\nui_Triggermode=%u\n",ui_Triggermode); */
+	/*       printk("\nui_DelayMode=%u\n",ui_DelayMode); */
+	/*      printk("\nui_ScanMode=%u\n",ui_ScanMode); */
+
+	/* ui_Configuration = i_FirstChannel |(i_LastChannel &lt;&lt; 8)| 0x00100000 | */
 	ui_Configuration =
 		s_BoardInfos[dev-&gt;minor].i_FirstChannel | (s_BoardInfos[dev-&gt;
 			minor].
@@ -2906,80 +2906,80 @@ int i_APCI3200_CommandAnalogInput(struct comedi_device * dev, struct comedi_subd
   /*************************/
 	/*Write the Configuration */
   /*************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl( ui_Configuration, devpriv-&gt;iobase+i_Offset + 0x8);
+	/* outl( ui_Configuration, devpriv-&gt;iobase+i_Offset + 0x8); */
 	outl(ui_Configuration,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 0x8);
   /***********************/
 	/*Write the Delay Value */
   /***********************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_DelayTime,devpriv-&gt;iobase+i_Offset + 40);
+	/* outl(ui_DelayTime,devpriv-&gt;iobase+i_Offset + 40); */
 	outl(ui_DelayTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 40);
   /***************************/
 	/*Write the Delay time base */
   /***************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_DelayTimeBase,devpriv-&gt;iobase+i_Offset + 44);
+	/* outl(ui_DelayTimeBase,devpriv-&gt;iobase+i_Offset + 44); */
 	outl(ui_DelayTimeBase,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 44);
   /*********************************/
 	/*Write the conversion time value */
   /*********************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_ConvertTime,devpriv-&gt;iobase+i_Offset + 32);
+	/* outl(ui_ConvertTime,devpriv-&gt;iobase+i_Offset + 32); */
 	outl(ui_ConvertTime,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 32);
 
   /********************************/
 	/*Write the conversion time base */
   /********************************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl(ui_ConvertTimeBase,devpriv-&gt;iobase+i_Offset + 36);
+	/* outl(ui_ConvertTimeBase,devpriv-&gt;iobase+i_Offset + 36); */
 	outl(ui_ConvertTimeBase,
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 36);
   /*******************/
 	/*Read the register */
   /*******************/
-	//ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 4);
+	/* ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 4); */
 	ui_Configuration =
 		inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 4);
   /******************/
 	/*Set the SCAN bit */
   /******************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
 
-	//outl(((ui_Configuration &amp; 0x1E0FF) | 0x00002000),devpriv-&gt;iobase+i_Offset + 4);
+	/* outl(((ui_Configuration &amp; 0x1E0FF) | 0x00002000),devpriv-&gt;iobase+i_Offset + 4); */
 	outl(((ui_Configuration &amp; 0x1E0FF) | 0x00002000),
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 4);
   /*******************/
 	/*Read the register */
   /*******************/
 	ui_Configuration = 0;
-	//ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 8);
+	/* ui_Configuration = inl(devpriv-&gt;iobase+i_Offset + 8); */
 	ui_Configuration =
 		inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
 
   /*******************/
 	/*Set the START bit */
   /*******************/
-	//while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1);
+	/* while (((inl(devpriv-&gt;iobase+i_Offset+12)&gt;&gt;19) &amp; 1) != 1); */
 	while (((inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset +
 					12) &gt;&gt; 19) &amp; 1) != 1) ;
-	//outl((ui_Configuration | 0x00080000),devpriv-&gt;iobase+i_Offset + 8);
+	/* outl((ui_Configuration | 0x00080000),devpriv-&gt;iobase+i_Offset + 8); */
 	outl((ui_Configuration | 0x00080000),
 		devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 8);
 	return 0;
@@ -3005,10 +3005,10 @@ int i_APCI3200_Reset(struct comedi_device * dev)
 {
 	int i_Temp;
 	unsigned int dw_Dummy;
-	//i_InterruptFlag=0;
-	//i_Initialised==0;
-	//i_Count=0;
-	//i_Sum=0;
+	/* i_InterruptFlag=0; */
+	/* i_Initialised==0; */
+	/* i_Count=0; */
+	/* i_Sum=0; */
 
 	s_BoardInfos[dev-&gt;minor].i_InterruptFlag = 0;
 	s_BoardInfos[dev-&gt;minor].i_Initialised = 0;
@@ -3018,17 +3018,17 @@ int i_APCI3200_Reset(struct comedi_device * dev)
 
 	outl(0x83838383, devpriv-&gt;i_IobaseAmcc + 0x60);
 
-	// Enable the interrupt for the controler
+	/*  Enable the interrupt for the controler */
 	dw_Dummy = inl(devpriv-&gt;i_IobaseAmcc + 0x38);
 	outl(dw_Dummy | 0x2000, devpriv-&gt;i_IobaseAmcc + 0x38);
-	outl(0, devpriv-&gt;i_IobaseAddon);	//Resets the output
+	outl(0, devpriv-&gt;i_IobaseAddon);	/* Resets the output */
   /***************/
 	/*Empty the buffer */
   /**************/
 	for (i_Temp = 0; i_Temp &lt;= 95; i_Temp++) {
-		//ui_InterruptChannelValue[i_Temp]=0;
+		/* ui_InterruptChannelValue[i_Temp]=0; */
 		s_BoardInfos[dev-&gt;minor].ui_InterruptChannelValue[i_Temp] = 0;
-	}			//for(i_Temp=0;i_Temp&lt;=95;i_Temp++)
+	}			/* for(i_Temp=0;i_Temp&lt;=95;i_Temp++) */
   /*****************************/
 	/*Reset the START and IRQ bit */
   /*****************************/
@@ -3036,7 +3036,7 @@ int i_APCI3200_Reset(struct comedi_device * dev)
 		while (((inl(devpriv-&gt;iobase + i_Temp + 12) &gt;&gt; 19) &amp; 1) != 1) ;
 		outl(0, devpriv-&gt;iobase + i_Temp + 8);
 		i_Temp = i_Temp + 64;
-	}			//for(i_Temp=0;i_Temp&lt;=192;i_Temp+64)
+	}			/* for(i_Temp=0;i_Temp&lt;=192;i_Temp+64) */
 	return 0;
 }
 
@@ -3069,17 +3069,17 @@ void v_APCI3200_Interrupt(int irq, void *d)
 	unsigned int ui_DigitalInput = 0;
 	int i_ConvertCJCCalibration;
 
-	//BEGIN JK TEST
+	/* BEGIN JK TEST */
 	int i_ReturnValue = 0;
-	//END JK TEST
+	/* END JK TEST */
 
-	//printk ("\n i_ScanType = %i i_ADDIDATAType = %i", s_BoardInfos [dev-&gt;minor].i_ScanType, s_BoardInfos [dev-&gt;minor].i_ADDIDATAType);
+	/* printk ("\n i_ScanType = %i i_ADDIDATAType = %i", s_BoardInfos [dev-&gt;minor].i_ScanType, s_BoardInfos [dev-&gt;minor].i_ADDIDATAType); */
 
-	//switch(i_ScanType)
+	/* switch(i_ScanType) */
 	switch (s_BoardInfos[dev-&gt;minor].i_ScanType) {
 	case 0:
 	case 1:
-		//switch(i_ADDIDATAType)
+		/* switch(i_ADDIDATAType) */
 		switch (s_BoardInfos[dev-&gt;minor].i_ADDIDATAType) {
 		case 0:
 		case 1:
@@ -3087,12 +3087,12 @@ void v_APCI3200_Interrupt(int irq, void *d)
 	  /************************************/
 			/*Read the interrupt status register */
 	  /************************************/
-			//ui_StatusRegister = inl(devpriv-&gt;iobase+i_Offset + 16);
+			/* ui_StatusRegister = inl(devpriv-&gt;iobase+i_Offset + 16); */
 			ui_StatusRegister =
 				inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 16);
 			if ((ui_StatusRegister &amp; 0x2) == 0x2) {
-				//i_CalibrationFlag = ((inl(devpriv-&gt;iobase+i_Offset + 12) &amp; 0x00060000) &gt;&gt; 17);
+				/* i_CalibrationFlag = ((inl(devpriv-&gt;iobase+i_Offset + 12) &amp; 0x00060000) &gt;&gt; 17); */
 				i_CalibrationFlag =
 					((inl(devpriv-&gt;iobase +
 							s_BoardInfos[dev-&gt;
@@ -3103,12 +3103,12 @@ void v_APCI3200_Interrupt(int irq, void *d)
 	      /*************************/
 				/*Read the channel number */
 	      /*************************/
-				//ui_ChannelNumber = inl(devpriv-&gt;iobase+i_Offset + 24);
+				/* ui_ChannelNumber = inl(devpriv-&gt;iobase+i_Offset + 24); */
 
 	      /*************************************/
 				/*Read the digital analog input value */
 	      /*************************************/
-				//ui_DigitalInput = inl(devpriv-&gt;iobase+i_Offset + 28);
+				/* ui_DigitalInput = inl(devpriv-&gt;iobase+i_Offset + 28); */
 				ui_DigitalInput =
 					inl(devpriv-&gt;iobase +
 					s_BoardInfos[dev-&gt;minor].i_Offset + 28);
@@ -3117,13 +3117,13 @@ void v_APCI3200_Interrupt(int irq, void *d)
 				/* Test if the value read is the channel value */
 	      /***********************************************/
 				if (i_CalibrationFlag == 0) {
-					//ui_InterruptChannelValue[i_Count + 0] = ui_DigitalInput;
+					/* ui_InterruptChannelValue[i_Count + 0] = ui_DigitalInput; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
 						i_Count + 0] = ui_DigitalInput;
 
-					//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+					/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 					/*
 					   printk("\n 1 - i_APCI3200_GetChannelCalibrationValue (dev, s_BoardInfos %i", ui_ChannelNumber);
 					   i_APCI3200_GetChannelCalibrationValue (dev, s_BoardInfos [dev-&gt;minor].ui_Channel_num,
@@ -3131,14 +3131,14 @@ void v_APCI3200_Interrupt(int irq, void *d)
 					   &amp;s_BoardInfos [dev-&gt;minor].ui_InterruptChannelValue[s_BoardInfos [dev-&gt;minor].i_Count + 7],
 					   &amp;s_BoardInfos [dev-&gt;minor].ui_InterruptChannelValue[s_BoardInfos [dev-&gt;minor].i_Count + 8]);
 					 */
-					//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+					/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
 		  /******************************************************/
 					/*Start the conversion of the calibration offset value */
 		  /******************************************************/
 					i_APCI3200_ReadCalibrationOffsetValue
 						(dev, &amp;ui_DummyValue);
-				}	//if (i_CalibrationFlag == 0)
+				}	/* if (i_CalibrationFlag == 0) */
 	      /**********************************************************/
 				/* Test if the value read is the calibration offset value */
 	      /**********************************************************/
@@ -3149,7 +3149,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 					/* Save the value */
 		  /******************/
 
-					//ui_InterruptChannelValue[i_Count + 1] = ui_DigitalInput;
+					/* ui_InterruptChannelValue[i_Count + 1] = ui_DigitalInput; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
@@ -3160,7 +3160,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 		  /******************************************************/
 					i_APCI3200_ReadCalibrationGainValue(dev,
 						&amp;ui_DummyValue);
-				}	//if (i_CalibrationFlag == 1)
+				}	/* if (i_CalibrationFlag == 1) */
 	      /******************************************************/
 				/*Test if the value read is the calibration gain value */
 	      /******************************************************/
@@ -3170,48 +3170,48 @@ void v_APCI3200_Interrupt(int irq, void *d)
 		  /****************/
 					/*Save the value */
 		  /****************/
-					//ui_InterruptChannelValue[i_Count + 2] = ui_DigitalInput;
+					/* ui_InterruptChannelValue[i_Count + 2] = ui_DigitalInput; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
 						i_Count + 2] = ui_DigitalInput;
-					//if(i_ScanType==1)
+					/* if(i_ScanType==1) */
 					if (s_BoardInfos[dev-&gt;minor].
 						i_ScanType == 1) {
 
-						//i_InterruptFlag=0;
+						/* i_InterruptFlag=0; */
 						s_BoardInfos[dev-&gt;minor].
 							i_InterruptFlag = 0;
-						//i_Count=i_Count + 6;
-						//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-						//s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count + 6;
+						/* i_Count=i_Count + 6; */
+						/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+						/* s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count + 6; */
 						s_BoardInfos[dev-&gt;minor].
 							i_Count =
 							s_BoardInfos[dev-&gt;
 							minor].i_Count + 9;
-						//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-					}	//if(i_ScanType==1)
+						/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+					}	/* if(i_ScanType==1) */
 					else {
-						//i_Count=0;
+						/* i_Count=0; */
 						s_BoardInfos[dev-&gt;minor].
 							i_Count = 0;
-					}	//elseif(i_ScanType==1)
-					//if(i_ScanType!=1)
+					}	/* elseif(i_ScanType==1) */
+					/* if(i_ScanType!=1) */
 					if (s_BoardInfos[dev-&gt;minor].
 						i_ScanType != 1) {
-						i_ReturnValue = send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
-					}	//if(i_ScanType!=1)
+						i_ReturnValue = send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
+					}	/* if(i_ScanType!=1) */
 					else {
-						//if(i_ChannelCount==i_Sum)
+						/* if(i_ChannelCount==i_Sum) */
 						if (s_BoardInfos[dev-&gt;minor].
 							i_ChannelCount ==
 							s_BoardInfos[dev-&gt;
 								minor].i_Sum) {
-							send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
+							send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
 						}
-					}	//if(i_ScanType!=1)
-				}	//if (i_CalibrationFlag == 2)
-			}	// if ((ui_StatusRegister &amp; 0x2) == 0x2)
+					}	/* if(i_ScanType!=1) */
+				}	/* if (i_CalibrationFlag == 2) */
+			}	/*  if ((ui_StatusRegister &amp; 0x2) == 0x2) */
 
 			break;
 
@@ -3220,7 +3220,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 			/*Read the interrupt status register */
 	  /************************************/
 
-			//ui_StatusRegister = inl(devpriv-&gt;iobase+i_Offset + 16);
+			/* ui_StatusRegister = inl(devpriv-&gt;iobase+i_Offset + 16); */
 			ui_StatusRegister =
 				inl(devpriv-&gt;iobase +
 				s_BoardInfos[dev-&gt;minor].i_Offset + 16);
@@ -3230,7 +3230,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 			if ((ui_StatusRegister &amp; 0x2) == 0x2) {
 
-				//i_CJCFlag = ((inl(devpriv-&gt;iobase+i_Offset + 4) &amp; 0x00000400) &gt;&gt; 10);
+				/* i_CJCFlag = ((inl(devpriv-&gt;iobase+i_Offset + 4) &amp; 0x00000400) &gt;&gt; 10); */
 				i_CJCFlag =
 					((inl(devpriv-&gt;iobase +
 							s_BoardInfos[dev-&gt;
@@ -3238,7 +3238,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 							i_Offset +
 							4) &amp; 0x00000400) &gt;&gt; 10);
 
-				//i_CalibrationFlag = ((inl(devpriv-&gt;iobase+i_Offset + 12) &amp; 0x00060000) &gt;&gt; 17);
+				/* i_CalibrationFlag = ((inl(devpriv-&gt;iobase+i_Offset + 12) &amp; 0x00060000) &gt;&gt; 17); */
 				i_CalibrationFlag =
 					((inl(devpriv-&gt;iobase +
 							s_BoardInfos[dev-&gt;
@@ -3251,19 +3251,19 @@ void v_APCI3200_Interrupt(int irq, void *d)
 				/*Read the channel number */
 	      /*************************/
 
-				//ui_ChannelNumber = inl(devpriv-&gt;iobase+i_Offset + 24);
+				/* ui_ChannelNumber = inl(devpriv-&gt;iobase+i_Offset + 24); */
 				ui_ChannelNumber =
 					inl(devpriv-&gt;iobase +
 					s_BoardInfos[dev-&gt;minor].i_Offset + 24);
-				//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+				/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 				s_BoardInfos[dev-&gt;minor].ui_Channel_num =
 					ui_ChannelNumber;
-				//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+				/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
 	      /************************************/
 				/*Read the digital temperature value */
 	      /************************************/
-				//ui_DigitalTemperature = inl(devpriv-&gt;iobase+i_Offset + 28);
+				/* ui_DigitalTemperature = inl(devpriv-&gt;iobase+i_Offset + 28); */
 				ui_DigitalTemperature =
 					inl(devpriv-&gt;iobase +
 					s_BoardInfos[dev-&gt;minor].i_Offset + 28);
@@ -3274,7 +3274,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 				if ((i_CalibrationFlag == 0)
 					&amp;&amp; (i_CJCFlag == 0)) {
-					//ui_InterruptChannelValue[i_Count + 0]=ui_DigitalTemperature;
+					/* ui_InterruptChannelValue[i_Count + 0]=ui_DigitalTemperature; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
@@ -3287,7 +3287,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 					i_APCI3200_ReadCJCValue(dev,
 						&amp;ui_DummyValue);
 
-				}	//if ((i_CalibrationFlag == 0) &amp;&amp; (i_CJCFlag == 0))
+				}	/* if ((i_CalibrationFlag == 0) &amp;&amp; (i_CJCFlag == 0)) */
 
 		 /*****************************************/
 				/*Test if the value read is the CJC value */
@@ -3295,7 +3295,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 				if ((i_CJCFlag == 1)
 					&amp;&amp; (i_CalibrationFlag == 0)) {
-					//ui_InterruptChannelValue[i_Count + 3]=ui_DigitalTemperature;
+					/* ui_InterruptChannelValue[i_Count + 3]=ui_DigitalTemperature; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
@@ -3307,7 +3307,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 		  /******************************************************/
 					i_APCI3200_ReadCalibrationOffsetValue
 						(dev, &amp;ui_DummyValue);
-				}	// if ((i_CJCFlag == 1) &amp;&amp; (i_CalibrationFlag == 0))
+				}	/*  if ((i_CJCFlag == 1) &amp;&amp; (i_CalibrationFlag == 0)) */
 
 		 /********************************************************/
 				/*Test if the value read is the calibration offset value */
@@ -3315,7 +3315,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 				if ((i_CalibrationFlag == 1)
 					&amp;&amp; (i_CJCFlag == 0)) {
-					//ui_InterruptChannelValue[i_Count + 1]=ui_DigitalTemperature;
+					/* ui_InterruptChannelValue[i_Count + 1]=ui_DigitalTemperature; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
@@ -3328,7 +3328,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 					i_APCI3200_ReadCalibrationGainValue(dev,
 						&amp;ui_DummyValue);
 
-				}	//if ((i_CalibrationFlag == 1) &amp;&amp; (i_CJCFlag == 0))
+				}	/* if ((i_CalibrationFlag == 1) &amp;&amp; (i_CJCFlag == 0)) */
 
 	      /******************************************************/
 				/*Test if the value read is the calibration gain value */
@@ -3336,7 +3336,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 				if ((i_CalibrationFlag == 2)
 					&amp;&amp; (i_CJCFlag == 0)) {
-					//ui_InterruptChannelValue[i_Count + 2]=ui_DigitalTemperature;
+					/* ui_InterruptChannelValue[i_Count + 2]=ui_DigitalTemperature; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
@@ -3349,15 +3349,15 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 					/*Test if the polarity is the same */
 		  /**********************************/
-					//if(i_CJCPolarity!=i_ADDIDATAPolarity)
+					/* if(i_CJCPolarity!=i_ADDIDATAPolarity) */
 					if (s_BoardInfos[dev-&gt;minor].
 						i_CJCPolarity !=
 						s_BoardInfos[dev-&gt;minor].
 						i_ADDIDATAPolarity) {
 						i_ConvertCJCCalibration = 1;
-					}	//if(i_CJCPolarity!=i_ADDIDATAPolarity)
+					}	/* if(i_CJCPolarity!=i_ADDIDATAPolarity) */
 					else {
-						//if(i_CJCGain==i_ADDIDATAGain)
+						/* if(i_CJCGain==i_ADDIDATAGain) */
 						if (s_BoardInfos[dev-&gt;minor].
 							i_CJCGain ==
 							s_BoardInfos[dev-&gt;
@@ -3365,12 +3365,12 @@ void v_APCI3200_Interrupt(int irq, void *d)
 							i_ADDIDATAGain) {
 							i_ConvertCJCCalibration
 								= 0;
-						}	//if(i_CJCGain==i_ADDIDATAGain)
+						}	/* if(i_CJCGain==i_ADDIDATAGain) */
 						else {
 							i_ConvertCJCCalibration
 								= 1;
-						}	//elseif(i_CJCGain==i_ADDIDATAGain)
-					}	//elseif(i_CJCPolarity!=i_ADDIDATAPolarity)
+						}	/* elseif(i_CJCGain==i_ADDIDATAGain) */
+					}	/* elseif(i_CJCPolarity!=i_ADDIDATAPolarity) */
 					if (i_ConvertCJCCalibration == 1) {
 		      /****************************************************************/
 						/*Start the conversion of the calibration gain value for the CJC */
@@ -3378,10 +3378,10 @@ void v_APCI3200_Interrupt(int irq, void *d)
 						i_APCI3200_ReadCJCCalOffset(dev,
 							&amp;ui_DummyValue);
 
-					}	//if(i_ConvertCJCCalibration==1)
+					}	/* if(i_ConvertCJCCalibration==1) */
 					else {
-						//ui_InterruptChannelValue[i_Count + 4]=0;
-						//ui_InterruptChannelValue[i_Count + 5]=0;
+						/* ui_InterruptChannelValue[i_Count + 4]=0; */
+						/* ui_InterruptChannelValue[i_Count + 5]=0; */
 						s_BoardInfos[dev-&gt;minor].
 							ui_InterruptChannelValue
 							[s_BoardInfos[dev-&gt;
@@ -3392,8 +3392,8 @@ void v_APCI3200_Interrupt(int irq, void *d)
 							[s_BoardInfos[dev-&gt;
 								minor].i_Count +
 							5] = 0;
-					}	//elseif(i_ConvertCJCCalibration==1)
-				}	//else if ((i_CalibrationFlag == 2) &amp;&amp; (i_CJCFlag == 0))
+					}	/* elseif(i_ConvertCJCCalibration==1) */
+				}	/* else if ((i_CalibrationFlag == 2) &amp;&amp; (i_CJCFlag == 0)) */
 
 		 /********************************************************************/
 				/*Test if the value read is the calibration offset value for the CJC */
@@ -3401,7 +3401,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 				if ((i_CalibrationFlag == 1)
 					&amp;&amp; (i_CJCFlag == 1)) {
-					//ui_InterruptChannelValue[i_Count + 4]=ui_DigitalTemperature;
+					/* ui_InterruptChannelValue[i_Count + 4]=ui_DigitalTemperature; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
@@ -3414,7 +3414,7 @@ void v_APCI3200_Interrupt(int irq, void *d)
 					i_APCI3200_ReadCJCCalGain(dev,
 						&amp;ui_DummyValue);
 
-				}	//if ((i_CalibrationFlag == 1) &amp;&amp; (i_CJCFlag == 1))
+				}	/* if ((i_CalibrationFlag == 1) &amp;&amp; (i_CJCFlag == 1)) */
 
 	      /******************************************************************/
 				/*Test if the value read is the calibration gain value for the CJC */
@@ -3422,61 +3422,61 @@ void v_APCI3200_Interrupt(int irq, void *d)
 
 				if ((i_CalibrationFlag == 2)
 					&amp;&amp; (i_CJCFlag == 1)) {
-					//ui_InterruptChannelValue[i_Count + 5]=ui_DigitalTemperature;
+					/* ui_InterruptChannelValue[i_Count + 5]=ui_DigitalTemperature; */
 					s_BoardInfos[dev-&gt;minor].
 						ui_InterruptChannelValue
 						[s_BoardInfos[dev-&gt;minor].
 						i_Count + 5] =
 						ui_DigitalTemperature;
 
-					//if(i_ScanType==1)
+					/* if(i_ScanType==1) */
 					if (s_BoardInfos[dev-&gt;minor].
 						i_ScanType == 1) {
 
-						//i_InterruptFlag=0;
+						/* i_InterruptFlag=0; */
 						s_BoardInfos[dev-&gt;minor].
 							i_InterruptFlag = 0;
-						//i_Count=i_Count + 6;
-						//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-						//s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count + 6;
+						/* i_Count=i_Count + 6; */
+						/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+						/* s_BoardInfos [dev-&gt;minor].i_Count=s_BoardInfos [dev-&gt;minor].i_Count + 6; */
 						s_BoardInfos[dev-&gt;minor].
 							i_Count =
 							s_BoardInfos[dev-&gt;
 							minor].i_Count + 9;
-						//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
-					}	//if(i_ScanType==1)
+						/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
+					}	/* if(i_ScanType==1) */
 					else {
-						//i_Count=0;
+						/* i_Count=0; */
 						s_BoardInfos[dev-&gt;minor].
 							i_Count = 0;
-					}	//elseif(i_ScanType==1)
+					}	/* elseif(i_ScanType==1) */
 
-					//if(i_ScanType!=1)
+					/* if(i_ScanType!=1) */
 					if (s_BoardInfos[dev-&gt;minor].
 						i_ScanType != 1) {
-						send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
-					}	//if(i_ScanType!=1)
+						send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
+					}	/* if(i_ScanType!=1) */
 					else {
-						//if(i_ChannelCount==i_Sum)
+						/* if(i_ChannelCount==i_Sum) */
 						if (s_BoardInfos[dev-&gt;minor].
 							i_ChannelCount ==
 							s_BoardInfos[dev-&gt;
 								minor].i_Sum) {
-							send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
+							send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
 
-						}	//if(i_ChannelCount==i_Sum)
-					}	//else if(i_ScanType!=1)
-				}	//if ((i_CalibrationFlag == 2) &amp;&amp; (i_CJCFlag == 1))
+						}	/* if(i_ChannelCount==i_Sum) */
+					}	/* else if(i_ScanType!=1) */
+				}	/* if ((i_CalibrationFlag == 2) &amp;&amp; (i_CJCFlag == 1)) */
 
-			}	//else if ((ui_StatusRegister &amp; 0x2) == 0x2)
+			}	/* else if ((ui_StatusRegister &amp; 0x2) == 0x2) */
 			break;
-		}		//switch(i_ADDIDATAType)
+		}		/* switch(i_ADDIDATAType) */
 		break;
 	case 2:
 	case 3:
 		i_APCI3200_InterruptHandleEos(dev);
 		break;
-	}			//switch(i_ScanType)
+	}			/* switch(i_ScanType) */
 	return;
 }
 
@@ -3504,17 +3504,17 @@ int i_APCI3200_InterruptHandleEos(struct comedi_device * dev)
 	unsigned int ui_StatusRegister = 0;
 	struct comedi_subdevice *s = dev-&gt;subdevices + 0;
 
-	//BEGIN JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-	//comedi_async *async = s-&gt;async;
-	//UINT *data;
-	//data=async-&gt;data+async-&gt;buf_int_ptr;//new samples added from here onwards
+	/* BEGIN JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+	/* comedi_async *async = s-&gt;async; */
+	/* UINT *data; */
+	/* data=async-&gt;data+async-&gt;buf_int_ptr;//new samples added from here onwards */
 	int n = 0, i = 0;
-	//END JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
+	/* END JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
 
   /************************************/
 	/*Read the interrupt status register */
   /************************************/
-	//ui_StatusRegister = inl(devpriv-&gt;iobase+i_Offset + 16);
+	/* ui_StatusRegister = inl(devpriv-&gt;iobase+i_Offset + 16); */
 	ui_StatusRegister =
 		inl(devpriv-&gt;iobase + s_BoardInfos[dev-&gt;minor].i_Offset + 16);
 
@@ -3526,33 +3526,33 @@ int i_APCI3200_InterruptHandleEos(struct comedi_device * dev)
       /*************************/
 		/*Read the channel number */
       /*************************/
-		//ui_ChannelNumber = inl(devpriv-&gt;iobase+i_Offset + 24);
-		//BEGIN JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-		//This value is not used
-		//ui_ChannelNumber = inl(devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 24);
+		/* ui_ChannelNumber = inl(devpriv-&gt;iobase+i_Offset + 24); */
+		/* BEGIN JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+		/* This value is not used */
+		/* ui_ChannelNumber = inl(devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 24); */
 		s-&gt;async-&gt;events = 0;
-		//END JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
+		/* END JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
 
       /*************************************/
 		/*Read the digital Analog Input value */
       /*************************************/
 
-		//data[i_Count] = inl(devpriv-&gt;iobase+i_Offset + 28);
-		//Begin JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-		//data[s_BoardInfos [dev-&gt;minor].i_Count] = inl(devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 28);
+		/* data[i_Count] = inl(devpriv-&gt;iobase+i_Offset + 28); */
+		/* Begin JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+		/* data[s_BoardInfos [dev-&gt;minor].i_Count] = inl(devpriv-&gt;iobase+s_BoardInfos [dev-&gt;minor].i_Offset + 28); */
 		s_BoardInfos[dev-&gt;minor].ui_ScanValueArray[s_BoardInfos[dev-&gt;
 				minor].i_Count] =
 			inl(devpriv-&gt;iobase +
 			s_BoardInfos[dev-&gt;minor].i_Offset + 28);
-		//End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
+		/* End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
 
-		//if((i_Count == (i_LastChannel-i_FirstChannel+3)))
+		/* if((i_Count == (i_LastChannel-i_FirstChannel+3))) */
 		if ((s_BoardInfos[dev-&gt;minor].i_Count ==
 				(s_BoardInfos[dev-&gt;minor].i_LastChannel -
 					s_BoardInfos[dev-&gt;minor].
 					i_FirstChannel + 3))) {
 
-			//Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+			/* Begin JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 			s_BoardInfos[dev-&gt;minor].i_Count++;
 
 			for (i = s_BoardInfos[dev-&gt;minor].i_FirstChannel;
@@ -3582,61 +3582,61 @@ int i_APCI3200_InterruptHandleEos(struct comedi_device * dev)
 							* 3) + 2]);
 			}
 
-			//End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values
+			/* End JK 22.10.2004: APCI-3200 / APCI-3300 Reading of EEPROM values */
 
-			//i_Count=-1;
+			/* i_Count=-1; */
 
 			s_BoardInfos[dev-&gt;minor].i_Count = -1;
 
-			//async-&gt;buf_int_count+=(i_LastChannel-i_FirstChannel+4)*sizeof(unsigned int);
-			//Begin JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-			//async-&gt;buf_int_count+=(s_BoardInfos [dev-&gt;minor].i_LastChannel-s_BoardInfos [dev-&gt;minor].i_FirstChannel+4)*sizeof(unsigned int);
-			//End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-			//async-&gt;buf_int_ptr+=(i_LastChannel-i_FirstChannel+4)*sizeof(unsigned int);
-			//Begin JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-			//async-&gt;buf_int_ptr+=(s_BoardInfos [dev-&gt;minor].i_LastChannel-s_BoardInfos [dev-&gt;minor].i_FirstChannel+4)*sizeof(unsigned int);
-			//comedi_eos(dev,s);
+			/* async-&gt;buf_int_count+=(i_LastChannel-i_FirstChannel+4)*sizeof(unsigned int); */
+			/* Begin JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+			/* async-&gt;buf_int_count+=(s_BoardInfos [dev-&gt;minor].i_LastChannel-s_BoardInfos [dev-&gt;minor].i_FirstChannel+4)*sizeof(unsigned int); */
+			/* End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+			/* async-&gt;buf_int_ptr+=(i_LastChannel-i_FirstChannel+4)*sizeof(unsigned int); */
+			/* Begin JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+			/* async-&gt;buf_int_ptr+=(s_BoardInfos [dev-&gt;minor].i_LastChannel-s_BoardInfos [dev-&gt;minor].i_FirstChannel+4)*sizeof(unsigned int); */
+			/* comedi_eos(dev,s); */
 
-			// Set the event type (Comedi Buffer End Of Scan)
+			/*  Set the event type (Comedi Buffer End Of Scan) */
 			s-&gt;async-&gt;events |= COMEDI_CB_EOS;
 
-			// Test if enougth memory is available and allocate it for 7 values
-			//n = comedi_buf_write_alloc(s-&gt;async, 7*sizeof(unsigned int));
+			/*  Test if enougth memory is available and allocate it for 7 values */
+			/* n = comedi_buf_write_alloc(s-&gt;async, 7*sizeof(unsigned int)); */
 			n = comedi_buf_write_alloc(s-&gt;async,
 				(7 + 12) * sizeof(unsigned int));
 
-			// If not enougth memory available, event is set to Comedi Buffer Errror
+			/*  If not enougth memory available, event is set to Comedi Buffer Errror */
 			if (n &gt; ((7 + 12) * sizeof(unsigned int))) {
 				printk("\ncomedi_buf_write_alloc n = %i", n);
 				s-&gt;async-&gt;events |= COMEDI_CB_ERROR;
 			}
-			// Write all 7 scan values in the comedi buffer
+			/*  Write all 7 scan values in the comedi buffer */
 			comedi_buf_memcpy_to(s-&gt;async, 0,
 				(unsigned int *) s_BoardInfos[dev-&gt;minor].
 				ui_ScanValueArray, (7 + 12) * sizeof(unsigned int));
 
-			// Update comedi buffer pinters indexes
+			/*  Update comedi buffer pinters indexes */
 			comedi_buf_write_free(s-&gt;async,
 				(7 + 12) * sizeof(unsigned int));
 
-			// Send events
+			/*  Send events */
 			comedi_event(dev, s);
-			//End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-
-			//BEGIN JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
-			//
-			//if (s-&gt;async-&gt;buf_int_ptr&gt;=s-&gt;async-&gt;data_len) //  for buffer rool over
-			//  {
-			//    /* buffer rollover */
-			//    s-&gt;async-&gt;buf_int_ptr=0;
-			//    comedi_eobuf(dev,s);
-			//  }
-			//End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68
+			/* End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+
+			/* BEGIN JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
+			/*  */
+			/* if (s-&gt;async-&gt;buf_int_ptr&gt;=s-&gt;async-&gt;data_len) //  for buffer rool over */
+			/*   { */
+			/*     /* buffer rollover */ */
+			/*     s-&gt;async-&gt;buf_int_ptr=0; */
+			/*     comedi_eobuf(dev,s); */
+			/*   } */
+			/* End JK 18.10.2004: APCI-3200 Driver update 0.7.57 -&gt; 0.7.68 */
 		}
-		//i_Count++;
+		/* i_Count++; */
 		s_BoardInfos[dev-&gt;minor].i_Count++;
 	}
-	//i_InterruptFlag=0;
+	/* i_InterruptFlag=0; */
 	s_BoardInfos[dev-&gt;minor].i_InterruptFlag = 0;
 	return 0;
 }</pre><hr><pre>commit b58d9b17db71e5d6f7531e9a922f37aa9aae5bdb
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Fri Mar 27 11:30:01 2009 -0400

    Staging: comedi: remove C99 comments in hwdrv_apci1564.c
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.c
index 13c5c6faf127..304079bbb80a 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1564.c
@@ -55,7 +55,7 @@ You shoud also find the complete GPL in the COPYING file accompanying this sourc
 #include &lt;linux/delay.h&gt;
 #include "hwdrv_apci1564.h"
 
-//Global variables
+/* Global variables */
 unsigned int ui_InterruptStatus_1564 = 0;
 unsigned int ui_InterruptData, ui_Type;
 
@@ -106,13 +106,13 @@ int i_APCI1564_ConfigDigitalInput(struct comedi_device * dev, struct comedi_subd
 			outl(0x4,
 				devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP +
 				APCI1564_DIGITAL_IP_IRQ);
-		}		// if  (data[1] == ADDIDATA_OR)
+		}		/*  if  (data[1] == ADDIDATA_OR) */
 		else {
 			outl(0x6,
 				devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP +
 				APCI1564_DIGITAL_IP_IRQ);
-		}		// else if  (data[1] == ADDIDATA_OR)
-	}			// if  (data[0] == ADDIDATA_ENABLE)
+		}		/*  else if  (data[1] == ADDIDATA_OR) */
+	}			/*  if  (data[0] == ADDIDATA_ENABLE) */
 	else {
 		outl(0x0,
 			devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP +
@@ -123,7 +123,7 @@ int i_APCI1564_ConfigDigitalInput(struct comedi_device * dev, struct comedi_subd
 		outl(0x0,
 			devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP +
 			APCI1564_DIGITAL_IP_IRQ);
-	}			// else if  (data[0] == ADDIDATA_ENABLE)
+	}			/*  else if  (data[0] == ADDIDATA_ENABLE) */
 
 	return insn-&gt;n;
 }
@@ -157,14 +157,16 @@ int i_APCI1564_Read1DigitalInput(struct comedi_device * dev, struct comedi_subde
 	if (ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;= 31) {
 		ui_TmpValue =
 			(unsigned int) inl(devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP);
-		//  since only 1 channel reqd  to bring it to last bit it is rotated
-		//  8 +(chan - 1) times then ANDed with 1 for last bit.
+/*
+* since only 1 channel reqd to bring it to last bit it is rotated 8
+* +(chan - 1) times then ANDed with 1 for last bit.
+*/
 		*data = (ui_TmpValue &gt;&gt; ui_Channel) &amp; 0x1;
-	}			// if  (ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=31)
+	}			/*  if  (ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=31) */
 	else {
 		comedi_error(dev, "Not a valid channel number !!! \n");
-		return -EINVAL;	// "sorry channel spec wrong "
-	}			//else if  (ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=31)
+		return -EINVAL;	/*  "sorry channel spec wrong " */
+	}			/* else if  (ui_Channel &gt;= 0 &amp;&amp; ui_Channel &lt;=31) */
 	return insn-&gt;n;
 }
 
@@ -218,15 +220,15 @@ int i_APCI1564_ReadMoreDigitalInput(struct comedi_device * dev, struct comedi_su
 			break;
 		default:
 			comedi_error(dev, "Not a valid Channel number !!!\n");
-			return -EINVAL;	// "sorry channel spec wrong "
+			return -EINVAL;	/*  "sorry channel spec wrong " */
 			break;
-		}		// switch  (ui_NoOfChannels)
-	}			// if  (data[1]==0)
+		}		/*  switch  (ui_NoOfChannels) */
+	}			/*  if  (data[1]==0) */
 	else {
 		if (data[1] == 1) {
 			*data = ui_InterruptStatus_1564;
-		}		// if  (data[1]==1)
-	}			// else if  (data[1]==0)
+		}		/*  if  (data[1]==1) */
+	}			/*  else if  (data[1]==0) */
 	return insn-&gt;n;
 }
 
@@ -264,25 +266,25 @@ int i_APCI1564_ConfigDigitalOutput(struct comedi_device * dev, struct comedi_sub
 		comedi_error(dev,
 			"Not a valid Data !!! ,Data should be 1 or 0\n");
 		return -EINVAL;
-	}			// if  ((data[0]!=0) &amp;&amp; (data[0]!=1))
+	}			/*  if  ((data[0]!=0) &amp;&amp; (data[0]!=1)) */
 	if (data[0]) {
 		devpriv-&gt;b_OutputMemoryStatus = ADDIDATA_ENABLE;
-	}			// if  (data[0])
+	}			/*  if  (data[0]) */
 	else {
 		devpriv-&gt;b_OutputMemoryStatus = ADDIDATA_DISABLE;
-	}			// else if  (data[0])
+	}			/*  else if  (data[0]) */
 	if (data[1] == ADDIDATA_ENABLE) {
 		ul_Command = ul_Command | 0x1;
-	}			// if  (data[1] == ADDIDATA_ENABLE)
+	}			/*  if  (data[1] == ADDIDATA_ENABLE) */
 	else {
 		ul_Command = ul_Command &amp; 0xFFFFFFFE;
-	}			// else if  (data[1] == ADDIDATA_ENABLE)
+	}			/*  else if  (data[1] == ADDIDATA_ENABLE) */
 	if (data[2] == ADDIDATA_ENABLE) {
 		ul_Command = ul_Command | 0x2;
-	}			// if  (data[2] == ADDIDATA_ENABLE)
+	}			/*  if  (data[2] == ADDIDATA_ENABLE) */
 	else {
 		ul_Command = ul_Command &amp; 0xFFFFFFFD;
-	}			// else if  (data[2] == ADDIDATA_ENABLE)
+	}			/*  else if  (data[2] == ADDIDATA_ENABLE) */
 	outl(ul_Command,
 		devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP +
 		APCI1564_DIGITAL_OP_INTERRUPT);
@@ -323,17 +325,17 @@ int i_APCI1564_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 		ui_Temp =
 			inl(devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP +
 			APCI1564_DIGITAL_OP_RW);
-	}			// if  (devpriv-&gt;b_OutputMemoryStatus )
+	}			/*  if  (devpriv-&gt;b_OutputMemoryStatus ) */
 	else {
 		ui_Temp = 0;
-	}			// else if  (devpriv-&gt;b_OutputMemoryStatus )
+	}			/*  else if  (devpriv-&gt;b_OutputMemoryStatus ) */
 	if (data[3] == 0) {
 		if (data[1] == 0) {
 			data[0] = (data[0] &lt;&lt; ui_NoOfChannel) | ui_Temp;
 			outl(data[0],
 				devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP +
 				APCI1564_DIGITAL_OP_RW);
-		}		// if  (data[1]==0)
+		}		/*  if  (data[1]==0) */
 		else {
 			if (data[1] == 1) {
 				switch (ui_NoOfChannel) {
@@ -362,18 +364,18 @@ int i_APCI1564_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 					break;
 				default:
 					comedi_error(dev, " chan spec wrong");
-					return -EINVAL;	// "sorry channel spec wrong "
-				}	// switch (ui_NoOfChannels)
+					return -EINVAL;	/*  "sorry channel spec wrong " */
+				}	/*  switch (ui_NoOfChannels) */
 				outl(data[0],
 					devpriv-&gt;i_IobaseAmcc +
 					APCI1564_DIGITAL_OP +
 					APCI1564_DIGITAL_OP_RW);
-			}	// if  (data[1]==1)
+			}	/*  if  (data[1]==1) */
 			else {
 				printk("\nSpecified channel not supported\n");
-			}	// else if  (data[1]==1)
-		}		// else if (data[1]==0)
-	}			//if(data[3]==0)
+			}	/*  else if  (data[1]==1) */
+		}		/*  else if (data[1]==0) */
+	}			/* if(data[3]==0) */
 	else {
 		if (data[3] == 1) {
 			if (data[1] == 0) {
@@ -389,7 +391,7 @@ int i_APCI1564_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 					devpriv-&gt;i_IobaseAmcc +
 					APCI1564_DIGITAL_OP +
 					APCI1564_DIGITAL_OP_RW);
-			}	// if  (data[1]==0)
+			}	/*  if  (data[1]==0) */
 			else {
 				if (data[1] == 1) {
 					switch (ui_NoOfChannel) {
@@ -447,23 +449,23 @@ int i_APCI1564_WriteDigitalOutput(struct comedi_device * dev, struct comedi_subd
 					default:
 						comedi_error(dev,
 							" chan spec wrong");
-						return -EINVAL;	// "sorry channel spec wrong "
-					}	//switch(ui_NoOfChannels)
+						return -EINVAL;	/*  "sorry channel spec wrong " */
+					}	/* switch(ui_NoOfChannels) */
 					outl(data[0],
 						devpriv-&gt;i_IobaseAmcc +
 						APCI1564_DIGITAL_OP +
 						APCI1564_DIGITAL_OP_RW);
-				}	// if  (data[1]==1)
+				}	/*  if  (data[1]==1) */
 				else {
 					printk("\nSpecified channel not supported\n");
-				}	// else if  (data[1]==1)
-			}	// else if  (data[1]==0)
-		}		// if  (data[3]==1);
+				}	/*  else if  (data[1]==1) */
+			}	/*  else if  (data[1]==0) */
+		}		/*  if  (data[3]==1); */
 		else {
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		// else if (data[3]==1)
-	}			// else if (data[3]==0)
+		}		/*  else if (data[3]==1) */
+	}			/*  else if (data[3]==0) */
 	return insn-&gt;n;
 }
 
@@ -498,7 +500,7 @@ int i_APCI1564_ReadDigitalOutput(struct comedi_device * dev, struct comedi_subde
 		APCI1564_DIGITAL_OP_RW);
 	if (ui_Temp == 0) {
 		*data = (*data &gt;&gt; ui_NoOfChannel) &amp; 0x1;
-	}			// if  (ui_Temp==0)
+	}			/*  if  (ui_Temp==0) */
 	else {
 		if (ui_Temp == 1) {
 			switch (ui_NoOfChannel) {
@@ -523,14 +525,14 @@ int i_APCI1564_ReadDigitalOutput(struct comedi_device * dev, struct comedi_subde
 
 			default:
 				comedi_error(dev, " chan spec wrong");
-				return -EINVAL;	// "sorry channel spec wrong "
+				return -EINVAL;	/*  "sorry channel spec wrong " */
 				break;
-			}	// switch(ui_NoOfChannels)
-		}		// if  (ui_Temp==1)
+			}	/*  switch(ui_NoOfChannels) */
+		}		/*  if  (ui_Temp==1) */
 		else {
 			printk("\nSpecified channel not supported \n");
-		}		// else if (ui_Temp==1)
-	}			// else if  (ui_Temp==0)
+		}		/*  else if (ui_Temp==1) */
+	}			/*  else if  (ui_Temp==0) */
 	return insn-&gt;n;
 }
 
@@ -572,26 +574,26 @@ int i_APCI1564_ConfigTimerCounterWatchdog(struct comedi_device * dev,
 	if (data[0] == ADDIDATA_WATCHDOG) {
 		devpriv-&gt;b_TimerSelectMode = ADDIDATA_WATCHDOG;
 
-		//Disable the watchdog
+		/* Disable the watchdog */
 		outl(0x0,
 			devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP_WATCHDOG +
 			APCI1564_TCW_PROG);
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outl(data[3],
 			devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP_WATCHDOG +
 			APCI1564_TCW_RELOAD_VALUE);
-	}			// if  (data[0]==ADDIDATA_WATCHDOG)
+	}			/*  if  (data[0]==ADDIDATA_WATCHDOG) */
 	else if (data[0] == ADDIDATA_TIMER) {
-		//First Stop The Timer
+		/* First Stop The Timer */
 		ul_Command1 =
 			inl(devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 			APCI1564_TCW_PROG);
 		ul_Command1 = ul_Command1 &amp; 0xFFFFF9FEUL;
-		outl(ul_Command1, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	//Stop The Timer
+		outl(ul_Command1, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	/* Stop The Timer */
 
 		devpriv-&gt;b_TimerSelectMode = ADDIDATA_TIMER;
 		if (data[1] == 1) {
-			outl(0x02, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	//Enable TIMER int &amp; DISABLE ALL THE OTHER int SOURCES
+			outl(0x02, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	/* Enable TIMER int &amp; DISABLE ALL THE OTHER int SOURCES */
 			outl(0x0,
 				devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP +
 				APCI1564_DIGITAL_IP_IRQ);
@@ -614,18 +616,18 @@ int i_APCI1564_ConfigTimerCounterWatchdog(struct comedi_device * dev,
 			outl(0x0,
 				devpriv-&gt;iobase + APCI1564_COUNTER4 +
 				APCI1564_TCW_IRQ);
-		}		// if  (data[1]==1)
+		}		/*  if  (data[1]==1) */
 		else {
-			outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	//disable Timer interrupt
-		}		// else if  (data[1]==1)
+			outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	/* disable Timer interrupt */
+		}		/*  else if  (data[1]==1) */
 
-		// Loading Timebase
+		/*  Loading Timebase */
 
 		outl(data[2],
 			devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 			APCI1564_TCW_TIMEBASE);
 
-		//Loading the Reload value
+		/* Loading the Reload value */
 		outl(data[3],
 			devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 			APCI1564_TCW_RELOAD_VALUE);
@@ -635,18 +637,18 @@ int i_APCI1564_ConfigTimerCounterWatchdog(struct comedi_device * dev,
 			APCI1564_TCW_PROG);
 		ul_Command1 =
 			(ul_Command1 &amp; 0xFFF719E2UL) | 2UL &lt;&lt; 13UL | 0x10UL;
-		outl(ul_Command1, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	//mode 2
-	}			// else if  (data[0]==ADDIDATA_TIMER)
+		outl(ul_Command1, devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER + APCI1564_TCW_PROG);	/* mode 2 */
+	}			/*  else if  (data[0]==ADDIDATA_TIMER) */
 	else if (data[0] == ADDIDATA_COUNTER) {
 		devpriv-&gt;b_TimerSelectMode = ADDIDATA_COUNTER;
 		devpriv-&gt;b_ModeSelectRegister = data[5];
 
-		//First Stop The Counter
+		/* First Stop The Counter */
 		ul_Command1 =
 			inl(devpriv-&gt;iobase + ((data[5] - 1) * 0x20) +
 			APCI1564_TCW_PROG);
 		ul_Command1 = ul_Command1 &amp; 0xFFFFF9FEUL;
-		outl(ul_Command1, devpriv-&gt;iobase + ((data[5] - 1) * 0x20) + APCI1564_TCW_PROG);	//Stop The Timer
+		outl(ul_Command1, devpriv-&gt;iobase + ((data[5] - 1) * 0x20) + APCI1564_TCW_PROG);	/* Stop The Timer */
 
       /************************/
 		/* Set the reload value */
@@ -671,7 +673,7 @@ int i_APCI1564_ConfigTimerCounterWatchdog(struct comedi_device * dev,
 			devpriv-&gt;iobase + ((data[5] - 1) * 0x20) +
 			APCI1564_TCW_PROG);
 
-		// Enable or Disable Interrupt
+		/*  Enable or Disable Interrupt */
 		ul_Command1 = (ul_Command1 &amp; 0xFFFFF9FD) | (data[1] &lt;&lt; 1);
 		outl(ul_Command1,
 			devpriv-&gt;iobase + ((data[5] - 1) * 0x20) +
@@ -684,10 +686,10 @@ int i_APCI1564_ConfigTimerCounterWatchdog(struct comedi_device * dev,
 		outl(ul_Command1,
 			devpriv-&gt;iobase + ((data[5] - 1) * 0x20) +
 			APCI1564_TCW_PROG);
-	}			// else if  (data[0]==ADDIDATA_COUNTER)
+	}			/*  else if  (data[0]==ADDIDATA_COUNTER) */
 	else {
 		printk(" Invalid subdevice.");
-	}			// else if  (data[0]==ADDIDATA_WATCHDOG)
+	}			/*  else if  (data[0]==ADDIDATA_WATCHDOG) */
 
 	return insn-&gt;n;
 }
@@ -724,16 +726,16 @@ int i_APCI1564_StartStopWriteTimerCounterWatchdog(struct comedi_device * dev,
 	unsigned int ul_Command1 = 0;
 	if (devpriv-&gt;b_TimerSelectMode == ADDIDATA_WATCHDOG) {
 		switch (data[1]) {
-		case 0:	//stop the watchdog
-			outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP_WATCHDOG + APCI1564_TCW_PROG);	//disable the watchdog
+		case 0:	/* stop the watchdog */
+			outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP_WATCHDOG + APCI1564_TCW_PROG);	/* disable the watchdog */
 			break;
-		case 1:	//start the watchdog
+		case 1:	/* start the watchdog */
 			outl(0x0001,
 				devpriv-&gt;i_IobaseAmcc +
 				APCI1564_DIGITAL_OP_WATCHDOG +
 				APCI1564_TCW_PROG);
 			break;
-		case 2:	//Software trigger
+		case 2:	/* Software trigger */
 			outl(0x0201,
 				devpriv-&gt;i_IobaseAmcc +
 				APCI1564_DIGITAL_OP_WATCHDOG +
@@ -742,8 +744,8 @@ int i_APCI1564_StartStopWriteTimerCounterWatchdog(struct comedi_device * dev,
 		default:
 			printk("\nSpecified functionality does not exist\n");
 			return -EINVAL;
-		}		// switch (data[1])
-	}			// if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_WATCHDOG)
+		}		/*  switch (data[1]) */
+	}			/*  if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_WATCHDOG) */
 	if (devpriv-&gt;b_TimerSelectMode == ADDIDATA_TIMER) {
 		if (data[1] == 1) {
 			ul_Command1 =
@@ -751,13 +753,13 @@ int i_APCI1564_StartStopWriteTimerCounterWatchdog(struct comedi_device * dev,
 				APCI1564_TCW_PROG);
 			ul_Command1 = (ul_Command1 &amp; 0xFFFFF9FFUL) | 0x1UL;
 
-			//Enable the Timer
+			/* Enable the Timer */
 			outl(ul_Command1,
 				devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 				APCI1564_TCW_PROG);
-		}		// if  (data[1]==1)
+		}		/*  if  (data[1]==1) */
 		else if (data[1] == 0) {
-			//Stop The Timer
+			/* Stop The Timer */
 
 			ul_Command1 =
 				inl(devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
@@ -766,29 +768,29 @@ int i_APCI1564_StartStopWriteTimerCounterWatchdog(struct comedi_device * dev,
 			outl(ul_Command1,
 				devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 				APCI1564_TCW_PROG);
-		}		// else if(data[1]==0)
-	}			// if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_TIMER)
+		}		/*  else if(data[1]==0) */
+	}			/*  if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_TIMER) */
 	if (devpriv-&gt;b_TimerSelectMode == ADDIDATA_COUNTER) {
 		ul_Command1 =
 			inl(devpriv-&gt;iobase + ((devpriv-&gt;b_ModeSelectRegister -
 					1) * 0x20) + APCI1564_TCW_PROG);
 		if (data[1] == 1) {
-			//Start the Counter subdevice
+			/* Start the Counter subdevice */
 			ul_Command1 = (ul_Command1 &amp; 0xFFFFF9FFUL) | 0x1UL;
-		}		// if  (data[1] == 1)
+		}		/*  if  (data[1] == 1) */
 		else if (data[1] == 0) {
-			// Stops the Counter subdevice
+			/*  Stops the Counter subdevice */
 			ul_Command1 = 0;
 
-		}		// else if  (data[1] == 0)
+		}		/*  else if  (data[1] == 0) */
 		else if (data[1] == 2) {
-			// Clears the Counter subdevice
+			/*  Clears the Counter subdevice */
 			ul_Command1 = (ul_Command1 &amp; 0xFFFFF9FFUL) | 0x400;
-		}		// else if  (data[1] == 3)
+		}		/*  else if  (data[1] == 3) */
 		outl(ul_Command1,
 			devpriv-&gt;iobase + ((devpriv-&gt;b_ModeSelectRegister -
 					1) * 0x20) + APCI1564_TCW_PROG);
-	}			// if (devpriv-&gt;b_TimerSelectMode==ADDIDATA_COUNTER)
+	}			/*  if (devpriv-&gt;b_TimerSelectMode==ADDIDATA_COUNTER) */
 	return insn-&gt;n;
 }
 
@@ -819,7 +821,7 @@ int i_APCI1564_ReadTimerCounterWatchdog(struct comedi_device * dev,
 	unsigned int ul_Command1 = 0;
 
 	if (devpriv-&gt;b_TimerSelectMode == ADDIDATA_WATCHDOG) {
-		// Stores the status of the Watchdog
+		/*  Stores the status of the Watchdog */
 		data[0] =
 			inl(devpriv-&gt;i_IobaseAmcc +
 			APCI1564_DIGITAL_OP_WATCHDOG +
@@ -827,18 +829,18 @@ int i_APCI1564_ReadTimerCounterWatchdog(struct comedi_device * dev,
 		data[1] =
 			inl(devpriv-&gt;i_IobaseAmcc +
 			APCI1564_DIGITAL_OP_WATCHDOG);
-	}			// if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_WATCHDOG)
+	}			/*  if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_WATCHDOG) */
 	else if (devpriv-&gt;b_TimerSelectMode == ADDIDATA_TIMER) {
-		// Stores the status of the Timer
+		/*  Stores the status of the Timer */
 		data[0] =
 			inl(devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 			APCI1564_TCW_TRIG_STATUS) &amp; 0x1;
 
-		// Stores the Actual value of the Timer
+		/*  Stores the Actual value of the Timer */
 		data[1] = inl(devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER);
-	}			// else if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_TIMER)
+	}			/*  else if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_TIMER) */
 	else if (devpriv-&gt;b_TimerSelectMode == ADDIDATA_COUNTER) {
-		// Read the Counter Actual Value.
+		/*  Read the Counter Actual Value. */
 		data[0] =
 			inl(devpriv-&gt;iobase + ((devpriv-&gt;b_ModeSelectRegister -
 					1) * 0x20) +
@@ -866,12 +868,12 @@ int i_APCI1564_ReadTimerCounterWatchdog(struct comedi_device * dev,
 		/* Get the overflow status */
       /***************************/
 		data[4] = (unsigned char) ((ul_Command1 &gt;&gt; 0) &amp; 1);
-	}			// else  if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_COUNTER)
+	}			/*  else  if  (devpriv-&gt;b_TimerSelectMode==ADDIDATA_COUNTER) */
 	else if ((devpriv-&gt;b_TimerSelectMode != ADDIDATA_TIMER)
 		&amp;&amp; (devpriv-&gt;b_TimerSelectMode != ADDIDATA_WATCHDOG)
 		&amp;&amp; (devpriv-&gt;b_TimerSelectMode != ADDIDATA_COUNTER)) {
 		printk("\n Invalid Subdevice !!!\n");
-	}			// else if ((devpriv-&gt;b_TimerSelectMode!=ADDIDATA_TIMER) &amp;&amp; (devpriv-&gt;b_TimerSelectMode!=ADDIDATA_WATCHDOG)&amp;&amp; (devpriv-&gt;b_TimerSelectMode!=ADDIDATA_COUNTER))
+	}			/*  else if ((devpriv-&gt;b_TimerSelectMode!=ADDIDATA_TIMER) &amp;&amp; (devpriv-&gt;b_TimerSelectMode!=ADDIDATA_WATCHDOG)&amp;&amp; (devpriv-&gt;b_TimerSelectMode!=ADDIDATA_COUNTER)) */
 	return insn-&gt;n;
 }
 
@@ -941,7 +943,7 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 	if (ui_DI == 0 &amp;&amp; ui_DO == 0 &amp;&amp; ui_Timer == 0 &amp;&amp; ui_C1 == 0
 		&amp;&amp; ui_C2 == 0 &amp;&amp; ui_C3 == 0 &amp;&amp; ui_C4 == 0) {
 		printk("\nInterrupt from unknown source\n");
-	}			// if(ui_DI==0 &amp;&amp; ui_DO==0 &amp;&amp; ui_Timer==0 &amp;&amp; ui_C1==0 &amp;&amp; ui_C2==0 &amp;&amp; ui_C3==0 &amp;&amp; ui_C4==0)
+	}			/*  if(ui_DI==0 &amp;&amp; ui_DO==0 &amp;&amp; ui_Timer==0 &amp;&amp; ui_C1==0 &amp;&amp; ui_C2==0 &amp;&amp; ui_C3==0 &amp;&amp; ui_C4==0) */
 
 	if (ui_DI == 1) {
 		ui_DI = inl(devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP +
@@ -953,28 +955,28 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 			inl(devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP +
 			APCI1564_DIGITAL_IP_INTERRUPT_STATUS);
 		ui_InterruptStatus_1564 = ui_InterruptStatus_1564 &amp; 0X000FFFF0;
-		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	// send signal to the sample
-		outl(ui_DI, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP + APCI1564_DIGITAL_IP_IRQ);	//enable the interrupt
+		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
+		outl(ui_DI, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP + APCI1564_DIGITAL_IP_IRQ);	/* enable the interrupt */
 		return;
 	}
 
 	if (ui_DO == 1) {
-		// Check for Digital Output interrupt Type - 1: Vcc interrupt 2: CC interrupt.
+		/*  Check for Digital Output interrupt Type - 1: Vcc interrupt 2: CC interrupt. */
 		ui_Type =
 			inl(devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP +
 			APCI1564_DIGITAL_OP_INTERRUPT_STATUS) &amp; 0x3;
-		//Disable the  Interrupt
+		/* Disable the  Interrupt */
 		outl(0x0,
 			devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP +
 			APCI1564_DIGITAL_OP_INTERRUPT);
 
-		//Sends signal to user space
+		/* Sends signal to user space */
 		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 
-	}			// if  (ui_DO)
+	}			/*  if  (ui_DO) */
 
 	if ((ui_Timer == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode = ADDIDATA_TIMER)) {
-		// Disable Timer Interrupt
+		/*  Disable Timer Interrupt */
 		ul_Command2 =
 			inl(devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 			APCI1564_TCW_PROG);
@@ -982,18 +984,18 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 			devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 			APCI1564_TCW_PROG);
 
-		//Send a signal to from kernel to user space
+		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 
-		// Enable Timer Interrupt
+		/*  Enable Timer Interrupt */
 
 		outl(ul_Command2,
 			devpriv-&gt;i_IobaseAmcc + APCI1564_TIMER +
 			APCI1564_TCW_PROG);
-	}			// if  ((ui_Timer == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_TIMER))
+	}			/*  if  ((ui_Timer == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_TIMER)) */
 
 	if ((ui_C1 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		// Disable Counter Interrupt
+		/*  Disable Counter Interrupt */
 		ul_Command2 =
 			inl(devpriv-&gt;iobase + APCI1564_COUNTER1 +
 			APCI1564_TCW_PROG);
@@ -1001,17 +1003,17 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 			devpriv-&gt;iobase + APCI1564_COUNTER1 +
 			APCI1564_TCW_PROG);
 
-		//Send a signal to from kernel to user space
+		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 
-		// Enable Counter Interrupt
+		/*  Enable Counter Interrupt */
 		outl(ul_Command2,
 			devpriv-&gt;iobase + APCI1564_COUNTER1 +
 			APCI1564_TCW_PROG);
-	}			// if  ((ui_C1 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode = ADDIDATA_COUNTER))
+	}			/*  if  ((ui_C1 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode = ADDIDATA_COUNTER)) */
 
 	if ((ui_C2 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		// Disable Counter Interrupt
+		/*  Disable Counter Interrupt */
 		ul_Command2 =
 			inl(devpriv-&gt;iobase + APCI1564_COUNTER2 +
 			APCI1564_TCW_PROG);
@@ -1019,17 +1021,17 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 			devpriv-&gt;iobase + APCI1564_COUNTER2 +
 			APCI1564_TCW_PROG);
 
-		//Send a signal to from kernel to user space
+		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 
-		// Enable Counter Interrupt
+		/*  Enable Counter Interrupt */
 		outl(ul_Command2,
 			devpriv-&gt;iobase + APCI1564_COUNTER2 +
 			APCI1564_TCW_PROG);
-	}			// if  ((ui_C2 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_COUNTER))
+	}			/*  if  ((ui_C2 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_COUNTER)) */
 
 	if ((ui_C3 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		// Disable Counter Interrupt
+		/*  Disable Counter Interrupt */
 		ul_Command2 =
 			inl(devpriv-&gt;iobase + APCI1564_COUNTER3 +
 			APCI1564_TCW_PROG);
@@ -1037,17 +1039,17 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 			devpriv-&gt;iobase + APCI1564_COUNTER3 +
 			APCI1564_TCW_PROG);
 
-		//Send a signal to from kernel to user space
+		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 
-		// Enable Counter Interrupt
+		/*  Enable Counter Interrupt */
 		outl(ul_Command2,
 			devpriv-&gt;iobase + APCI1564_COUNTER3 +
 			APCI1564_TCW_PROG);
-	}			// if ((ui_C3 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_COUNTER))
+	}			/*  if ((ui_C3 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_COUNTER)) */
 
 	if ((ui_C4 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode = ADDIDATA_COUNTER)) {
-		// Disable Counter Interrupt
+		/*  Disable Counter Interrupt */
 		ul_Command2 =
 			inl(devpriv-&gt;iobase + APCI1564_COUNTER4 +
 			APCI1564_TCW_PROG);
@@ -1055,14 +1057,14 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 			devpriv-&gt;iobase + APCI1564_COUNTER4 +
 			APCI1564_TCW_PROG);
 
-		//Send a signal to from kernel to user space
+		/* Send a signal to from kernel to user space */
 		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);
 
-		// Enable Counter Interrupt
+		/*  Enable Counter Interrupt */
 		outl(ul_Command2,
 			devpriv-&gt;iobase + APCI1564_COUNTER4 +
 			APCI1564_TCW_PROG);
-	}			// if ((ui_C4 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_COUNTER))
+	}			/*  if ((ui_C4 == 1) &amp;&amp; (devpriv-&gt;b_TimerSelectMode =ADDIDATA_COUNTER)) */
 	return;
 }
 
@@ -1083,14 +1085,14 @@ static void v_APCI1564_Interrupt(int irq, void *d)
 
 int i_APCI1564_Reset(struct comedi_device * dev)
 {
-	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP_IRQ);	//disable the interrupts
-	inl(devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP_INTERRUPT_STATUS);	//Reset the interrupt status register
-	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP_INTERRUPT_MODE1);	//Disable the and/or interrupt
+	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP_IRQ);	/* disable the interrupts */
+	inl(devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP_INTERRUPT_STATUS);	/* Reset the interrupt status register */
+	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP_INTERRUPT_MODE1);	/* Disable the and/or interrupt */
 	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_IP_INTERRUPT_MODE2);
 	devpriv-&gt;b_DigitalOutputRegister = 0;
 	ui_Type = 0;
-	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP);	//Resets the output channels
-	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP_INTERRUPT);	//Disables the interrupt.
+	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP);	/* Resets the output channels */
+	outl(0x0, devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP_INTERRUPT);	/* Disables the interrupt. */
 	outl(0x0,
 		devpriv-&gt;i_IobaseAmcc + APCI1564_DIGITAL_OP_WATCHDOG +
 		APCI1564_TCW_RELOAD_VALUE);</pre>
    <div class="pagination">
        <a href='3_55.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><span>[56]</span><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_57.html'>Next&gt;&gt;</a>
    <div>
</body>
