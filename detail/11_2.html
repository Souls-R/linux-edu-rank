<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Peking University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Peking University</h1>
    <div class="pagination">
        <a href='11.html'>&lt;&lt;Prev</a><a href='11.html'>1</a><span>[2]</span><a href='11_3.html'>3</a><a href='11_4.html'>4</a><a href='11_5.html'>5</a><a href='11_6.html'>6</a><a href='11_7.html'>7</a><a href='11_8.html'>8</a><a href='11_9.html'>9</a><a href='11_10.html'>10</a><a href='11_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 000c2fa2c144c499c881a101819cf1936a1f7cf2
Author: Ruihan Li &lt;lrh2000@pku.edu.cn&gt;
Date:   Sun Apr 16 16:02:51 2023 +0800

    bluetooth: Add cmd validity checks at the start of hci_sock_ioctl()
    
    Previously, channel open messages were always sent to monitors on the first
    ioctl() call for unbound HCI sockets, even if the command and arguments
    were completely invalid. This can leave an exploitable hole with the abuse
    of invalid ioctl calls.
    
    This commit hardens the ioctl processing logic by first checking if the
    command is valid, and immediately returning with an ENOIOCTLCMD error code
    if it is not. This ensures that ioctl calls with invalid commands are free
    of side effects, and increases the difficulty of further exploitation by
    forcing exploitation to find a way to pass a valid command first.
    
    Signed-off-by: Ruihan Li &lt;lrh2000@pku.edu.cn&gt;
    Co-developed-by: Marcel Holtmann &lt;marcel@holtmann.org&gt;
    Signed-off-by: Marcel Holtmann &lt;marcel@holtmann.org&gt;
    Signed-off-by: Luiz Augusto von Dentz &lt;luiz.von.dentz@intel.com&gt;

diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 06581223238c..8d8950101cee 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -987,6 +987,34 @@ static int hci_sock_ioctl(struct socket *sock, unsigned int cmd,
 
 	BT_DBG("cmd %x arg %lx", cmd, arg);
 
+	/* Make sure the cmd is valid before doing anything */
+	switch (cmd) {
+	case HCIGETDEVLIST:
+	case HCIGETDEVINFO:
+	case HCIGETCONNLIST:
+	case HCIDEVUP:
+	case HCIDEVDOWN:
+	case HCIDEVRESET:
+	case HCIDEVRESTAT:
+	case HCISETSCAN:
+	case HCISETAUTH:
+	case HCISETENCRYPT:
+	case HCISETPTYPE:
+	case HCISETLINKPOL:
+	case HCISETLINKMODE:
+	case HCISETACLMTU:
+	case HCISETSCOMTU:
+	case HCIINQUIRY:
+	case HCISETRAW:
+	case HCIGETCONNINFO:
+	case HCIGETAUTHINFO:
+	case HCIBLOCKADDR:
+	case HCIUNBLOCKADDR:
+		break;
+	default:
+		return -ENOIOCTLCMD;
+	}
+
 	lock_sock(sk);
 
 	if (hci_pi(sk)-&gt;channel != HCI_CHANNEL_RAW) {</pre><hr><pre>commit eb4c0788964730d12e8dd520bd8f5217ca48321c
Author: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
Date:   Thu May 19 05:09:48 2022 -0700

    hv_netvsc: Fix potential dereference of NULL pointer
    
    The return value of netvsc_devinfo_get()
    needs to be checked to avoid use of NULL
    pointer in case of an allocation failure.
    
    Fixes: 0efeea5fb153 ("hv_netvsc: Add the support of hibernation")
    Signed-off-by: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
    Reviewed-by: Haiyang Zhang &lt;haiyangz@microsoft.com&gt;
    Link: https://lore.kernel.org/r/1652962188-129281-1-git-send-email-lyz_cs@pku.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index fde1c492ca02..b1dece6b9698 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -2671,7 +2671,10 @@ static int netvsc_suspend(struct hv_device *dev)
 
 	/* Save the current config info */
 	ndev_ctx-&gt;saved_netvsc_dev_info = netvsc_devinfo_get(nvdev);
-
+	if (!ndev_ctx-&gt;saved_netvsc_dev_info) {
+		ret = -ENOMEM;
+		goto out;
+	}
 	ret = netvsc_detach(net, nvdev);
 out:
 	rtnl_unlock();</pre><hr><pre>commit 087f9c3f2309ed183f7e4b85ae57121d8663224d
Author: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
Date:   Fri Mar 11 09:06:01 2022 -0800

    RDMA/mlx5: Fix memory leak in error flow for subscribe event routine
    
    In case the second xa_insert() fails, the obj_event is not released.  Fix
    the error unwind flow to free that memory to avoid a memory leak.
    
    Fixes: 759738537142 ("IB/mlx5: Enable subscription for device events over DEVX")
    Link: https://lore.kernel.org/r/1647018361-18266-1-git-send-email-lyz_cs@pku.edu.cn
    Signed-off-by: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
    Signed-off-by: Jason Gunthorpe &lt;jgg@nvidia.com&gt;

diff --git a/drivers/infiniband/hw/mlx5/devx.c b/drivers/infiniband/hw/mlx5/devx.c
index 08b7f6bc56c3..15c0884d1f49 100644
--- a/drivers/infiniband/hw/mlx5/devx.c
+++ b/drivers/infiniband/hw/mlx5/devx.c
@@ -1886,8 +1886,10 @@ subscribe_event_xa_alloc(struct mlx5_devx_event_table *devx_event_table,
 				key_level2,
 				obj_event,
 				GFP_KERNEL);
-		if (err)
+		if (err) {
+			kfree(obj_event);
 			return err;
+		}
 		INIT_LIST_HEAD(&amp;obj_event-&gt;obj_sub_list);
 	}
 </pre><hr><pre>commit 455896c53d5b803733ddd84e1bf8a430644439b6
Author: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
Date:   Sat Jan 15 21:34:56 2022 -0800

    dmaengine: shdma: Fix runtime PM imbalance on error
    
    pm_runtime_get_() increments the runtime PM usage counter even
    when it returns an error code, thus a matching decrement is needed on
    the error handling path to keep the counter balanced.
    
    Signed-off-by: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
    Link: https://lore.kernel.org/r/1642311296-87020-1-git-send-email-lyz_cs@pku.edu.cn
    Signed-off-by: Vinod Koul &lt;vkoul@kernel.org&gt;

diff --git a/drivers/dma/sh/shdma-base.c b/drivers/dma/sh/shdma-base.c
index 158e5e7defae..b26ed690f03c 100644
--- a/drivers/dma/sh/shdma-base.c
+++ b/drivers/dma/sh/shdma-base.c
@@ -115,8 +115,10 @@ static dma_cookie_t shdma_tx_submit(struct dma_async_tx_descriptor *tx)
 		ret = pm_runtime_get(schan-&gt;dev);
 
 		spin_unlock_irq(&amp;schan-&gt;chan_lock);
-		if (ret &lt; 0)
+		if (ret &lt; 0) {
 			dev_err(schan-&gt;dev, "%s(): GET = %d\n", __func__, ret);
+			pm_runtime_put(schan-&gt;dev);
+		}
 
 		pm_runtime_barrier(schan-&gt;dev);
 </pre><hr><pre>commit e57c1a3bd5e8e0c7181f65ae55581f0236a8f284
Author: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
Date:   Fri Jan 28 05:41:02 2022 -0800

    drm/v3d: fix missing unlock
    
    [why]
    Unlock is needed on the error handling path to prevent dead lock.
    v3d_submit_cl_ioctl and v3d_submit_csd_ioctl is missing unlock.
    
    [how]
    Fix this by changing goto target on the error handling path. So
    changing the goto to target an error handling path
    that includes drm_gem_unlock reservations.
    
    Signed-off-by: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
    Reviewed-by: Melissa Wen &lt;mwen@igalia.com&gt;
    Signed-off-by: Melissa Wen &lt;melissa.srw@gmail.com&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/1643377262-109975-1-git-send-email-lyz_cs@pku.edu.cn

diff --git a/drivers/gpu/drm/v3d/v3d_gem.c b/drivers/gpu/drm/v3d/v3d_gem.c
index c7ed2e1cbab6..92bc0faee84f 100644
--- a/drivers/gpu/drm/v3d/v3d_gem.c
+++ b/drivers/gpu/drm/v3d/v3d_gem.c
@@ -798,7 +798,7 @@ v3d_submit_cl_ioctl(struct drm_device *dev, void *data,
 
 		if (!render-&gt;base.perfmon) {
 			ret = -ENOENT;
-			goto fail;
+			goto fail_perfmon;
 		}
 	}
 
@@ -847,6 +847,7 @@ v3d_submit_cl_ioctl(struct drm_device *dev, void *data,
 
 fail_unreserve:
 	mutex_unlock(&amp;v3d-&gt;sched_lock);
+fail_perfmon:
 	drm_gem_unlock_reservations(last_job-&gt;bo,
 				    last_job-&gt;bo_count, &amp;acquire_ctx);
 fail:
@@ -1027,7 +1028,7 @@ v3d_submit_csd_ioctl(struct drm_device *dev, void *data,
 						     args-&gt;perfmon_id);
 		if (!job-&gt;base.perfmon) {
 			ret = -ENOENT;
-			goto fail;
+			goto fail_perfmon;
 		}
 	}
 
@@ -1056,6 +1057,7 @@ v3d_submit_csd_ioctl(struct drm_device *dev, void *data,
 
 fail_unreserve:
 	mutex_unlock(&amp;v3d-&gt;sched_lock);
+fail_perfmon:
 	drm_gem_unlock_reservations(clean_job-&gt;bo, clean_job-&gt;bo_count,
 				    &amp;acquire_ctx);
 fail:</pre><hr><pre>commit 46f47807738441e354873546dde0b000106c068a
Author: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
Date:   Sun Jan 23 23:20:35 2022 -0800

    drm/bridge: Add missing pm_runtime_put_sync
    
    pm_runtime_get_sync() will increase the rumtime PM counter
    even when it returns an error. Thus a pairing decrement is needed
    to prevent refcount leak. Fix this by replacing this API with
    pm_runtime_resume_and_get(), which will not change the runtime
    PM counter on error. Besides, a matching decrement is needed
    on the error handling path to keep the counter balanced.
    
    Signed-off-by: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
    Reviewed-by: Laurent Pinchart &lt;laurent.pinchart@ideasonboard.com&gt;
    Signed-off-by: Robert Foss &lt;robert.foss@linaro.org&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/1643008835-73961-1-git-send-email-lyz_cs@pku.edu.cn

diff --git a/drivers/gpu/drm/bridge/nwl-dsi.c b/drivers/gpu/drm/bridge/nwl-dsi.c
index 9282e61dfbf0..30aacd939dc3 100644
--- a/drivers/gpu/drm/bridge/nwl-dsi.c
+++ b/drivers/gpu/drm/bridge/nwl-dsi.c
@@ -862,18 +862,19 @@ nwl_dsi_bridge_mode_set(struct drm_bridge *bridge,
 	memcpy(&amp;dsi-&gt;mode, adjusted_mode, sizeof(dsi-&gt;mode));
 	drm_mode_debug_printmodeline(adjusted_mode);
 
-	pm_runtime_get_sync(dev);
+	if (pm_runtime_resume_and_get(dev) &lt; 0)
+		return;
 
 	if (clk_prepare_enable(dsi-&gt;lcdif_clk) &lt; 0)
-		return;
+		goto runtime_put;
 	if (clk_prepare_enable(dsi-&gt;core_clk) &lt; 0)
-		return;
+		goto runtime_put;
 
 	/* Step 1 from DSI reset-out instructions */
 	ret = reset_control_deassert(dsi-&gt;rst_pclk);
 	if (ret &lt; 0) {
 		DRM_DEV_ERROR(dev, "Failed to deassert PCLK: %d\n", ret);
-		return;
+		goto runtime_put;
 	}
 
 	/* Step 2 from DSI reset-out instructions */
@@ -883,13 +884,18 @@ nwl_dsi_bridge_mode_set(struct drm_bridge *bridge,
 	ret = reset_control_deassert(dsi-&gt;rst_esc);
 	if (ret &lt; 0) {
 		DRM_DEV_ERROR(dev, "Failed to deassert ESC: %d\n", ret);
-		return;
+		goto runtime_put;
 	}
 	ret = reset_control_deassert(dsi-&gt;rst_byte);
 	if (ret &lt; 0) {
 		DRM_DEV_ERROR(dev, "Failed to deassert BYTE: %d\n", ret);
-		return;
+		goto runtime_put;
 	}
+
+	return;
+
+runtime_put:
+	pm_runtime_put_sync(dev);
 }
 
 static void</pre><hr><pre>commit 5d5c6dba2b43e28845d7d7ed32a36802329a5f52
Author: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
Date:   Fri Jan 21 11:26:13 2022 +0000

    drm/amd/display: Fix memory leak
    
    [why]
    Resource release is needed on the error handling path
    to prevent memory leak.
    
    [how]
    Fix this by adding kfree on the error handling path.
    
    Reviewed-by: Harry Wentland &lt;harry.wentland@amd.com&gt;
    Signed-off-by: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
index 26719efa5396..12d437d9a0e4 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c
@@ -227,8 +227,10 @@ static ssize_t dp_link_settings_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -389,8 +391,10 @@ static ssize_t dp_phy_settings_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user((*(rd_buf + result)), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -1359,8 +1363,10 @@ static ssize_t dp_dsc_clock_en_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -1376,8 +1382,10 @@ static ssize_t dp_dsc_clock_en_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -1546,8 +1554,10 @@ static ssize_t dp_dsc_slice_width_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -1563,8 +1573,10 @@ static ssize_t dp_dsc_slice_width_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -1731,8 +1743,10 @@ static ssize_t dp_dsc_slice_height_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -1748,8 +1762,10 @@ static ssize_t dp_dsc_slice_height_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -1912,8 +1928,10 @@ static ssize_t dp_dsc_bits_per_pixel_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -1929,8 +1947,10 @@ static ssize_t dp_dsc_bits_per_pixel_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -2088,8 +2108,10 @@ static ssize_t dp_dsc_pic_width_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -2105,8 +2127,10 @@ static ssize_t dp_dsc_pic_width_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -2145,8 +2169,10 @@ static ssize_t dp_dsc_pic_height_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -2162,8 +2188,10 @@ static ssize_t dp_dsc_pic_height_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -2217,8 +2245,10 @@ static ssize_t dp_dsc_chunk_size_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -2234,8 +2264,10 @@ static ssize_t dp_dsc_chunk_size_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -2289,8 +2321,10 @@ static ssize_t dp_dsc_slice_bpg_offset_read(struct file *f, char __user *buf,
 				break;
 	}
 
-	if (!pipe_ctx)
+	if (!pipe_ctx) {
+		kfree(rd_buf);
 		return -ENXIO;
+	}
 
 	dsc = pipe_ctx-&gt;stream_res.dsc;
 	if (dsc)
@@ -2306,8 +2340,10 @@ static ssize_t dp_dsc_slice_bpg_offset_read(struct file *f, char __user *buf,
 			break;
 
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 
 		buf += 1;
 		size -= 1;
@@ -3459,8 +3495,10 @@ static ssize_t dcc_en_bits_read(
 	dc-&gt;hwss.get_dcc_en_bits(dc, dcc_en_bits);
 
 	rd_buf = kcalloc(rd_buf_size, sizeof(char), GFP_KERNEL);
-	if (!rd_buf)
+	if (!rd_buf) {
+		kfree(dcc_en_bits);
 		return -ENOMEM;
+	}
 
 	for (i = 0; i &lt; num_pipes; i++)
 		offset += snprintf(rd_buf + offset, rd_buf_size - offset,
@@ -3473,8 +3511,10 @@ static ssize_t dcc_en_bits_read(
 		if (*pos &gt;= rd_buf_size)
 			break;
 		r = put_user(*(rd_buf + result), buf);
-		if (r)
+		if (r) {
+			kfree(rd_buf);
 			return r; /* r = -EFAULT */
+		}
 		buf += 1;
 		size -= 1;
 		*pos += 1;</pre><hr><pre>commit 4bd8dd0d61f961e6c13cc118d4ebbdba57f8561f
Author: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
Date:   Tue Jan 18 15:11:51 2022 -0500

    drm/amdgpu: Add missing pm_runtime_put_autosuspend
    
    pm_runtime_get_sync() increments the runtime PM usage counter even
    when it returns an error code, thus a matching decrement is needed
    on the error handling path to keep the counter balanced.
    
    Signed-off-by: Yongzhi Liu &lt;lyz_cs@pku.edu.cn&gt;
    Reviewed-by: Lijo Lazar &lt;lijo.lazar@amd.com&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c
index 9aea1cc5b27e..4b950de9bf66 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_debugfs.c
@@ -1120,8 +1120,10 @@ static ssize_t amdgpu_debugfs_gfxoff_read(struct file *f, char __user *buf,
 		return -EINVAL;
 
 	r = pm_runtime_get_sync(adev_to_drm(adev)-&gt;dev);
-	if (r &lt; 0)
+	if (r &lt; 0) {
+		pm_runtime_put_autosuspend(adev_to_drm(adev)-&gt;dev);
 		return r;
+	}
 
 	while (size) {
 		uint32_t value;</pre><hr><pre>commit 5cf069f910c5c87055fb970a8103f0ad38ba7143
Author: Liu Junqi &lt;liujunqi@pku.edu.cn&gt;
Date:   Thu Nov 25 12:47:29 2021 +0800

    staging: unisys: visornic: removed a blank line at the end of function
    
    Removed a blank line at the end of function to clear checkpatch warning
    and make it more like typical coding style.
    
    Signed-off-by: Liu Junqi &lt;liujunqi@pku.edu.cn&gt;
    Link: https://lore.kernel.org/r/20211125044729.594727-3-liujunqi@pku.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/unisys/visornic/visornic_main.c b/drivers/staging/unisys/visornic/visornic_main.c
index aec0db28126d..643432458105 100644
--- a/drivers/staging/unisys/visornic/visornic_main.c
+++ b/drivers/staging/unisys/visornic/visornic_main.c
@@ -1764,7 +1764,6 @@ static void visornic_channel_interrupt(struct visor_device *dev)
 		napi_schedule(&amp;devdata-&gt;napi);
 
 	atomic_set(&amp;devdata-&gt;interrupt_rcvd, 0);
-
 }
 
 /* visornic_probe - probe function for visornic devices</pre><hr><pre>commit 4e4437d09cbeb1babbf7986414ff9f23679c76a6
Author: Liu Junqi &lt;liujunqi@pku.edu.cn&gt;
Date:   Thu Nov 25 12:47:28 2021 +0800

    staging: unisys: visornic: reindent to avoid '(' at the end of line
    
    A change to make the code more like typical coding style.
    
    Signed-off-by: Liu Junqi &lt;liujunqi@pku.edu.cn&gt;
    Link: https://lore.kernel.org/r/20211125044729.594727-2-liujunqi@pku.edu.cn
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/unisys/visornic/visornic_main.c b/drivers/staging/unisys/visornic/visornic_main.c
index 18be80648825..aec0db28126d 100644
--- a/drivers/staging/unisys/visornic/visornic_main.c
+++ b/drivers/staging/unisys/visornic/visornic_main.c
@@ -1759,9 +1759,8 @@ static void visornic_channel_interrupt(struct visor_device *dev)
 	if (!devdata)
 		return;
 
-	if (!visorchannel_signalempty(
-				   devdata-&gt;dev-&gt;visorchannel,
-				   IOCHAN_FROM_IOPART))
+	if (!visorchannel_signalempty(devdata-&gt;dev-&gt;visorchannel,
+				      IOCHAN_FROM_IOPART))
 		napi_schedule(&amp;devdata-&gt;napi);
 
 	atomic_set(&amp;devdata-&gt;interrupt_rcvd, 0);</pre>
    <div class="pagination">
        <a href='11.html'>&lt;&lt;Prev</a><a href='11.html'>1</a><span>[2]</span><a href='11_3.html'>3</a><a href='11_4.html'>4</a><a href='11_5.html'>5</a><a href='11_6.html'>6</a><a href='11_7.html'>7</a><a href='11_8.html'>8</a><a href='11_9.html'>9</a><a href='11_10.html'>10</a><a href='11_3.html'>Next&gt;&gt;</a>
    <div>
</body>
