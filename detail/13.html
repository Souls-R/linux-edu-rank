<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Washington</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Washington</h1>
    <div class="pagination">
        <span>[1]</span><a href='13_2.html'>2</a><a href='13_3.html'>3</a><a href='13_4.html'>4</a><a href='13_5.html'>5</a><a href='13_6.html'>6</a><a href='13_7.html'>7</a><a href='13_8.html'>8</a><a href='13_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 19050da1d1057a7bc73fd9039f94b7f63a00e54e
Author: Kenneth Lee &lt;klee33@uw.edu&gt;
Date:   Tue Aug 9 00:20:50 2022 -0700

    ARM: OMAP2+: hwmod: Use kzalloc for allocating only one element
    
    Use kzalloc(...) rather than kcalloc(1, ...) because the number of
    elements we are specifying in this case is 1, so kzalloc would
    accomplish the same thing and we can simplify.
    
    Signed-off-by: Kenneth Lee &lt;klee33@uw.edu&gt;
    Message-Id: &lt;20220809072050.1733996-1-klee33@uw.edu&gt;
    Signed-off-by: Tony Lindgren &lt;tony@atomide.com&gt;

diff --git a/arch/arm/mach-omap2/omap_hwmod.c b/arch/arm/mach-omap2/omap_hwmod.c
index de3fd0bc862d..aac4c4ee2528 100644
--- a/arch/arm/mach-omap2/omap_hwmod.c
+++ b/arch/arm/mach-omap2/omap_hwmod.c
@@ -3454,7 +3454,7 @@ static int omap_hwmod_allocate_module(struct device *dev, struct omap_hwmod *oh,
 	}
 
 	if (list_empty(&amp;oh-&gt;slave_ports)) {
-		oi = kcalloc(1, sizeof(*oi), GFP_KERNEL);
+		oi = kzalloc(sizeof(*oi), GFP_KERNEL);
 		if (!oi)
 			goto out_free_class;
 </pre><hr><pre>commit aa1d627207cace003163dee24d1c06fa4e910c6b
Author: Kenneth Lee &lt;klee33@uw.edu&gt;
Date:   Thu Aug 18 22:42:55 2022 -0700

    ceph: Use kcalloc for allocating multiple elements
    
    Prefer using kcalloc(a, b) over kzalloc(a * b) as this improves
    semantics since kcalloc is intended for allocating an array of memory.
    
    Signed-off-by: Kenneth Lee &lt;klee33@uw.edu&gt;
    Reviewed-by: Xiubo Li &lt;xiubli@redhat.com&gt;
    Signed-off-by: Ilya Dryomov &lt;idryomov@gmail.com&gt;

diff --git a/fs/ceph/caps.c b/fs/ceph/caps.c
index 0dc1251c3c6d..fb023f9fafcb 100644
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@ -2286,7 +2286,7 @@ static int flush_mdlog_and_wait_inode_unsafe_requests(struct inode *inode)
 		struct ceph_mds_request *req;
 		int i;
 
-		sessions = kzalloc(max_sessions * sizeof(s), GFP_KERNEL);
+		sessions = kcalloc(max_sessions, sizeof(s), GFP_KERNEL);
 		if (!sessions) {
 			err = -ENOMEM;
 			goto out;</pre><hr><pre>commit 92f017c4aee6e2bb79593adeacccbea3afe62223
Author: Kenneth Lee &lt;klee33@uw.edu&gt;
Date:   Thu Aug 18 22:51:17 2022 -0700

    fs/ntfs3: Use kmalloc_array for allocating multiple elements
    
    Prefer using kmalloc_array(a, b) over kmalloc(a * b) as this
    improves semantics since kmalloc is intended for allocating an
    array of memory.
    
    Signed-off-by: Kenneth Lee &lt;klee33@uw.edu&gt;
    Signed-off-by: Konstantin Komarov &lt;almaz.alexandrovich@paragon-software.com&gt;

diff --git a/fs/ntfs3/bitmap.c b/fs/ntfs3/bitmap.c
index 5d44ceac855b..1675c9a69788 100644
--- a/fs/ntfs3/bitmap.c
+++ b/fs/ntfs3/bitmap.c
@@ -1324,7 +1324,7 @@ int wnd_extend(struct wnd_bitmap *wnd, size_t new_bits)
 		new_last = wbits;
 
 	if (new_wnd != wnd-&gt;nwnd) {
-		new_free = kmalloc(new_wnd * sizeof(u16), GFP_NOFS);
+		new_free = kmalloc_array(new_wnd, sizeof(u16), GFP_NOFS);
 		if (!new_free)
 			return -ENOMEM;
 </pre><hr><pre>commit d3524bb5b9a0c567b853a0024526afe87dde01ed
Author: Kenneth Lee &lt;klee33@uw.edu&gt;
Date:   Fri Sep 16 13:20:52 2022 +0100

    nvmem: brcm_nvram: Use kzalloc for allocating only one element
    
    Use kzalloc(...) rather than kcalloc(1, ...) because the number of
    elements we are specifying in this case is 1, so kzalloc would
    accomplish the same thing and we can simplify.
    
    Signed-off-by: Kenneth Lee &lt;klee33@uw.edu&gt;
    Signed-off-by: Srinivas Kandagatla &lt;srinivas.kandagatla@linaro.org&gt;
    Link: https://lore.kernel.org/r/20220916122100.170016-6-srinivas.kandagatla@linaro.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/nvmem/brcm_nvram.c b/drivers/nvmem/brcm_nvram.c
index 450b927691c3..4441daa20965 100644
--- a/drivers/nvmem/brcm_nvram.c
+++ b/drivers/nvmem/brcm_nvram.c
@@ -96,7 +96,7 @@ static int brcm_nvram_parse(struct brcm_nvram *priv)
 
 	len = le32_to_cpu(header.len);
 
-	data = kcalloc(1, len, GFP_KERNEL);
+	data = kzalloc(len, GFP_KERNEL);
 	memcpy_fromio(data, priv-&gt;base, len);
 	data[len - 1] = '\0';
 </pre><hr><pre>commit b2d4c646d5a15c1854e09898a374983167e53e0e
Author: Kenneth Lee &lt;klee33@uw.edu&gt;
Date:   Mon Aug 8 15:00:19 2022 -0700

    mm/damon/dbgfs: use kmalloc for allocating only one element
    
    Use kmalloc(...) rather than kmalloc_array(1, ...) because the number of
    elements we are specifying in this case is 1, kmalloc would accomplish the
    same thing and we can simplify.
    
    Link: https://lkml.kernel.org/r/20220808220019.1680469-1-klee33@uw.edu
    Signed-off-by: Kenneth Lee &lt;klee33@uw.edu&gt;
    Reviewed-by: SeongJae Park &lt;sj@kernel.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/mm/damon/dbgfs.c b/mm/damon/dbgfs.c
index cfdf63132d5a..3b55a1b219b5 100644
--- a/mm/damon/dbgfs.c
+++ b/mm/damon/dbgfs.c
@@ -1044,7 +1044,7 @@ static int __init __damon_dbgfs_init(void)
 				fops[i]);
 	dbgfs_fill_ctx_dir(dbgfs_root, dbgfs_ctxs[0]);
 
-	dbgfs_dirs = kmalloc_array(1, sizeof(dbgfs_root), GFP_KERNEL);
+	dbgfs_dirs = kmalloc(sizeof(dbgfs_root), GFP_KERNEL);
 	if (!dbgfs_dirs) {
 		debugfs_remove(dbgfs_root);
 		return -ENOMEM;</pre><hr><pre>commit 00784da3e6b8c1f0e58d813272503d014de8f64b
Author: Kenneth Lee &lt;klee33@uw.edu&gt;
Date:   Sat Aug 6 22:16:56 2022 -0700

    can: kvaser_usb: kvaser_usb_hydra: Use kzalloc for allocating only one element
    
    Use kzalloc(...) rather than kcalloc(1, ...) since because the number of
    elements we are specifying in this case is 1, kzalloc would accomplish the
    same thing and we can simplify. Also refactor how we calculate the sizeof()
    as checkstyle for kzalloc() prefers using the variable we are assigning
    to versus the type of that variable for calculating the size to allocate.
    
    Signed-off-by: Kenneth Lee &lt;klee33@uw.edu&gt;
    Link: https://lore.kernel.org/all/20220807051656.1991446-1-klee33@uw.edu
    Signed-off-by: Marc Kleine-Budde &lt;mkl@pengutronix.de&gt;

diff --git a/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c b/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c
index dd65c101bfb8..6871d474dabf 100644
--- a/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c
+++ b/drivers/net/can/usb/kvaser_usb/kvaser_usb_hydra.c
@@ -534,7 +534,7 @@ static int kvaser_usb_hydra_send_simple_cmd(struct kvaser_usb *dev,
 	struct kvaser_cmd *cmd;
 	int err;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -573,7 +573,7 @@ kvaser_usb_hydra_send_simple_cmd_async(struct kvaser_usb_net_priv *priv,
 	struct kvaser_usb *dev = priv-&gt;dev;
 	int err;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_ATOMIC);
+	cmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -694,7 +694,7 @@ static int kvaser_usb_hydra_map_channel(struct kvaser_usb *dev, u16 transid,
 	struct kvaser_cmd *cmd;
 	int err;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -735,7 +735,7 @@ static int kvaser_usb_hydra_get_single_capability(struct kvaser_usb *dev,
 	int err;
 	int i;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -1394,7 +1394,7 @@ kvaser_usb_hydra_frame_to_cmd_ext(const struct kvaser_usb_net_priv *priv,
 	u32 kcan_id;
 	u32 kcan_header;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd_ext), GFP_ATOMIC);
+	cmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);
 	if (!cmd)
 		return NULL;
 
@@ -1468,7 +1468,7 @@ kvaser_usb_hydra_frame_to_cmd_std(const struct kvaser_usb_net_priv *priv,
 	u32 flags;
 	u32 id;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_ATOMIC);
+	cmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);
 	if (!cmd)
 		return NULL;
 
@@ -1533,7 +1533,7 @@ static int kvaser_usb_hydra_set_bittiming(struct net_device *netdev)
 	int sjw = bt-&gt;sjw;
 	int err;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -1567,7 +1567,7 @@ static int kvaser_usb_hydra_set_data_bittiming(struct net_device *netdev)
 	int sjw = dbt-&gt;sjw;
 	int err;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -1711,7 +1711,7 @@ static int kvaser_usb_hydra_get_software_details(struct kvaser_usb *dev)
 	u32 flags;
 	struct kvaser_usb_dev_card_data *card_data = &amp;dev-&gt;card_data;
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -1851,7 +1851,7 @@ static int kvaser_usb_hydra_set_opt_mode(const struct kvaser_usb_net_priv *priv)
 		return -EINVAL;
 	}
 
-	cmd = kcalloc(1, sizeof(struct kvaser_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 </pre><hr><pre>commit d2ff1d2067ac382f189eadc1a400b948fd398658
Author: Conrad Meyer &lt;cemeyer@uw.edu&gt;
Date:   Sat Mar 8 21:42:58 2014 -0500

    Staging: comedi: do not initialize statics to 0 (apci1500)
    
    Minor style cleanup per checkpatch.pl.
    
    Signed-off-by: Conrad Meyer &lt;cse.cem@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
index 4f5ce6af59dc..1f7adc5a97f2 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
@@ -141,16 +141,16 @@ enum {
 	APCI1500_RW_PORT_B_PATTERN_MASK
 };
 
-static int i_TimerCounter1Init = 0;
-static int i_TimerCounter2Init = 0;
-static int i_WatchdogCounter3Init = 0;
-static int i_Event1Status = 0, i_Event2Status = 0;
-static int i_TimerCounterWatchdogInterrupt = 0;
-static int i_Logic = 0, i_CounterLogic = 0;
-static int i_InterruptMask = 0;
-static int i_InputChannel = 0;
-static int i_TimerCounter1Enabled = 0, i_TimerCounter2Enabled = 0,
-	   i_WatchdogCounter3Enabled = 0;
+static int i_TimerCounter1Init;
+static int i_TimerCounter2Init;
+static int i_WatchdogCounter3Init;
+static int i_Event1Status, i_Event2Status;
+static int i_TimerCounterWatchdogInterrupt;
+static int i_Logic, i_CounterLogic;
+static int i_InterruptMask;
+static int i_InputChannel;
+static int i_TimerCounter1Enabled, i_TimerCounter2Enabled,
+	   i_WatchdogCounter3Enabled;
 
 /*
   +----------------------------------------------------------------------------+
@@ -977,7 +977,7 @@ static int i_APCI1500_WriteDigitalOutput(struct comedi_device *dev,
 					 unsigned int *data)
 {
 	struct addi_private *devpriv = dev-&gt;private;
-	static unsigned int ui_Temp = 0;
+	static unsigned int ui_Temp;
 	unsigned int ui_Temp1;
 	unsigned int ui_NoOfChannel = CR_CHAN(insn-&gt;chanspec);	/*  get the channel */
 </pre><hr><pre>commit c9847a6eeb8906d9026848dc442ae1bf7c5de7a9
Author: Conrad Meyer &lt;cemeyer@uw.edu&gt;
Date:   Sat Mar 8 21:42:49 2014 -0500

    Staging: comedi: Kill comment art in hwdrv_apci1500.c
    
    Nudge the commenting in this mess a little further from 'bad.' Much of
    it was incorrectly indented.
    
    Another sed cleanup:
      $ sed -i -e '/\/\*\*\*\*\*\*\*\*\**\//,1d' addi-data/hwdrv_apci1500.c
    
    Signed-off-by: Conrad Meyer &lt;cse.cem@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
index 0ccf784b81a4..4f5ce6af59dc 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
@@ -241,14 +241,10 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 	int i_PatternTransitionCount = 0, i_RegValue;
 	int i;
 
-      /*************************************************/
 	/* Selects the master interrupt control register */
-      /*************************************************/
 	outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-      /**********************************************/
 	/* Disables  the main interrupt on the board */
-      /**********************************************/
 	outb(0x00, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
 	if (data[0] == 1) {
@@ -327,17 +323,13 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 	}			/* for (i_Count = i_MaxChannel; i_Count &gt;0;i_Count --) */
 
 	if (data[0] == 1) {
-		    /****************************/
 		/* Test the interrupt logic */
-		    /****************************/
 
 		if (data[1] == APCI1500_AND ||
 			data[1] == APCI1500_OR ||
 			data[1] == APCI1500_OR_PRIORITY) {
-		       /**************************************/
 			/* Tests if a transition was declared */
 			/* for a OR PRIORITY logic            */
-		       /**************************************/
 
 			if (data[1] == APCI1500_OR_PRIORITY
 				&amp;&amp; i_PatternTransition != 0) {
@@ -346,10 +338,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				return -EINVAL;
 			}	/*  if (data[1]== APCI1500_OR_PRIORITY &amp;&amp; i_PatternTransition != 0) */
 
-		       /*************************************/
 			/* Tests if more than one transition */
 			/* was declared for an AND logic     */
-		       /*************************************/
 
 			if (data[1] == APCI1500_AND) {
 				for (i_Count = 0; i_Count &lt; 8; i_Count++) {
@@ -367,21 +357,15 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				}	/*  if (i_PatternTransitionCount &gt; 1) */
 			}	/*  if (data[1]== APCI1500_AND) */
 
-			    /*****************************************************************/
 			/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-			    /*****************************************************************/
 			outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-			/******************/
 			/* Disable Port A */
-			    /******************/
 			outb(0xF0,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-			/**********************************************/
 			/* Selects the polarity register of port 1    */
-			    /**********************************************/
 			outb(APCI1500_RW_PORT_A_PATTERN_POLARITY,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -389,20 +373,16 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-			/*********************************************/
 			/* Selects the pattern mask register of      */
 			/* port 1                                    */
-			    /*********************************************/
 			outb(APCI1500_RW_PORT_A_PATTERN_MASK,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 			outb(i_PatternMask,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-			/********************************************/
 			/* Selects the pattern transition register  */
 			/* of port 1                                */
-			    /********************************************/
 			outb(APCI1500_RW_PORT_A_PATTERN_TRANSITION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -410,10 +390,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		      /******************************************/
 			/* Selects the mode specification mask    */
 			/* register of port 1                     */
-			  /******************************************/
 			outb(APCI1500_RW_PORT_A_SPECIFICATION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -421,17 +399,13 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				inb(devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		      /******************************************/
 			/* Selects the mode specification mask    */
 			/* register of port 1                     */
-			  /******************************************/
 			outb(APCI1500_RW_PORT_A_SPECIFICATION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		      /**********************/
 			/* Port A new mode    */
-			  /**********************/
 
 			i_RegValue = (i_RegValue &amp; 0xF9) | data[1] | 0x9;
 			outb(i_RegValue,
@@ -440,16 +414,12 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 
 			i_Event1Status = 1;
 
-		      /*****************************************************************/
 			/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-			  /*****************************************************************/
 
 			outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		      /*****************/
 			/* Enable Port A */
-			  /*****************/
 			outb(0xF4,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -462,32 +432,22 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 		}		/*  else }// if(data[1]==APCI1500_AND||data[1]==APCI1500_OR||data[1]==APCI1500_OR_PRIORITY) */
 	}			/*    if (data[0]== 1) */
 
-		 /************************************/
 	/* Test if event setting for port 2 */
-		 /************************************/
 
 	if (data[0] == 2) {
-		    /************************/
 		/* Test the event logic */
-		    /************************/
 
 		if (data[1] == APCI1500_OR) {
-		       /*****************************************************************/
 			/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 			outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		       /******************/
 			/* Disable Port B */
-		       /******************/
 			outb(0x74,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		       /****************************************/
 			/* Selects the mode specification mask  */
 			/* register of port B                   */
-		       /****************************************/
 			outb(APCI1500_RW_PORT_B_SPECIFICATION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -495,10 +455,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				inb(devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		       /******************************************/
 			/* Selects the mode specification mask    */
 			/* register of port B                     */
-		       /******************************************/
 			outb(APCI1500_RW_PORT_B_SPECIFICATION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -507,37 +465,29 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		       /**********************************/
 			/* Selects error channels 1 and 2 */
-		       /**********************************/
 
 			i_PatternMask = (i_PatternMask | 0xC0);
 			i_PatternPolarity = (i_PatternPolarity | 0xC0);
 			i_PatternTransition = (i_PatternTransition | 0xC0);
 
-		       /**********************************************/
 			/* Selects the polarity register of port 2    */
-		       /**********************************************/
 			outb(APCI1500_RW_PORT_B_PATTERN_POLARITY,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 			outb(i_PatternPolarity,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		       /**********************************************/
 			/* Selects the pattern transition register    */
 			/* of port 2                                  */
-		       /**********************************************/
 			outb(APCI1500_RW_PORT_B_PATTERN_TRANSITION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 			outb(i_PatternTransition,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		       /**********************************************/
 			/* Selects the pattern Mask register    */
 			/* of port 2                                  */
-		       /**********************************************/
 
 			outb(APCI1500_RW_PORT_B_PATTERN_MASK,
 				devpriv-&gt;iobase +
@@ -546,20 +496,16 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		       /******************************************/
 			/* Selects the mode specification mask    */
 			/* register of port 2                     */
-		       /******************************************/
 			outb(APCI1500_RW_PORT_B_SPECIFICATION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 			i_RegValue =
 				inb(devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		       /******************************************/
 			/* Selects the mode specification mask    */
 			/* register of port 2                     */
-		       /******************************************/
 			outb(APCI1500_RW_PORT_B_SPECIFICATION,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -569,16 +515,12 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				APCI1500_Z8536_CONTROL_REGISTER);
 
 			i_Event2Status = 1;
-		       /*****************************************************************/
 			/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 
 			outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************/
 			/* Enable Port B */
-		       /*****************/
 
 			outb(0xF4,
 				devpriv-&gt;iobase +
@@ -627,48 +569,30 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 
 	switch (data[0]) {
 	case START:
-	      /*************************/
 		/* Tests the port number */
-	      /*************************/
 
 		if (data[1] == 1 || data[1] == 2) {
-		  /***************************/
 			/* Test if port 1 selected */
-		  /***************************/
 
 			if (data[1] == 1) {
-		    /*****************************/
 				/* Test if event initialised */
-		    /*****************************/
 				if (i_Event1Status == 1) {
-		       /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /******************/
 					/* Disable Port A */
-		       /******************/
 					outb(0xF0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-		       /***************************************************/
 					/* Selects the command and status register of      */
 					/* port 1                                          */
-		       /***************************************************/
 					outb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*************************************/
 					/* Allows the pattern interrupt      */
-		       /*************************************/
 					outb(0xC0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************/
 					/* Enable Port A */
-		       /*****************/
 					outb(0xF4,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -681,11 +605,8 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 						APCI1500_Z8536_CONTROL_REGISTER);
 
 					/* Selects the master interrupt control register */
-		       /*************************************************/
 					outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /**********************************************/
 					/* Authorizes the main interrupt on the board */
-		       /**********************************************/
 					outb(0xD0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -700,44 +621,29 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 			if (data[1] == 2) {
 
 				if (i_Event2Status == 1) {
-			    /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-			    /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /******************/
 					/* Disable Port B */
-		       /******************/
 					outb(0x74,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-		       /***************************************************/
 					/* Selects the command and status register of      */
 					/* port 2                                          */
-		       /***************************************************/
 					outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*************************************/
 					/* Allows the pattern interrupt      */
-		       /*************************************/
 					outb(0xC0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************/
 					/* Enable Port B */
-		       /*****************/
 					outb(0xF4,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
 
 					/* Selects the master interrupt control register */
-		       /*************************************************/
 					outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /**********************************************/
 					/* Authorizes the main interrupt on the board */
-		       /**********************************************/
 					outb(0xD0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -759,48 +665,30 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 		break;
 
 	case STOP:
-		  /*************************/
 		/* Tests the port number */
-		  /*************************/
 
 		if (data[1] == 1 || data[1] == 2) {
-		  /***************************/
 			/* Test if port 1 selected */
-		  /***************************/
 
 			if (data[1] == 1) {
-		    /*****************************/
 				/* Test if event initialised */
-		    /*****************************/
 				if (i_Event1Status == 1) {
-		       /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /******************/
 					/* Disable Port A */
-		       /******************/
 					outb(0xF0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-		       /***************************************************/
 					/* Selects the command and status register of      */
 					/* port 1                                          */
-		       /***************************************************/
 					outb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*************************************/
 					/* Inhibits the pattern interrupt      */
-		       /*************************************/
 					outb(0xE0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************/
 					/* Enable Port A */
-		       /*****************/
 					outb(0xF4,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -813,38 +701,24 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 				}	/* else if(i_Event1Status==1) */
 			}	/* if (data[1]==1) */
 			if (data[1] == 2) {
-			 /*****************************/
 				/* Test if event initialised */
-			 /*****************************/
 				if (i_Event2Status == 1) {
-			  /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-			  /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-			  /******************/
 					/* Disable Port B */
-			  /******************/
 					outb(0x74,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-			  /***************************************************/
 					/* Selects the command and status register of      */
 					/* port 2                                         */
-			  /***************************************************/
 					outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*************************************/
 					/* Inhibits the pattern interrupt      */
-		       /*************************************/
 					outb(0xE0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************************************************************/
 					/* Selects the APCI1500_RW_MASTER_CONFIGURATION_CONTROL register */
-		       /*****************************************************************/
 					outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-		       /*****************/
 					/* Enable Port B */
-		       /*****************/
 					outb(0xF4,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -900,9 +774,7 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 	struct addi_private *devpriv = dev-&gt;private;
 	int i_DummyRead = 0;
 
-    /******************/
 	/* Software reset */
-    /******************/
 	i_DummyRead = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_DummyRead = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
@@ -910,16 +782,12 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 	outb(1, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
- /*****************************************************/
 	/* Selects the master configuration control register */
- /*****************************************************/
 	outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0xF4, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	/*****************************************************/
 	/* Selects the mode specification register of port A */
-	/*****************************************************/
 	outb(APCI1500_RW_PORT_A_SPECIFICATION,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0x10, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
@@ -951,9 +819,7 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 	/* Deletes the register */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	 /*****************************************************/
 	/* Selects the mode specification register of port B */
-	 /*****************************************************/
 	outb(APCI1500_RW_PORT_B_SPECIFICATION,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0x10, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
@@ -983,9 +849,7 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 	/* Deletes the register */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	   /*****************************************************/
 	/* Selects the data path polarity register of port C */
-	   /*****************************************************/
 	outb(APCI1500_RW_PORT_C_DATA_PCITCH_POLARITY,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* High level of port C means 1 */
@@ -1000,9 +864,7 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes it */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	   /******************************************************/
 	/* Selects the command and status register of timer 1 */
-	   /******************************************************/
 	outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes IP and IUS */
@@ -1012,9 +874,7 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deactivates the interrupt management of timer 1         */
 	outb(0xE0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	   /******************************************************/
 	/* Selects the command and status register of timer 2 */
-	   /******************************************************/
 	outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes IP and IUS */
@@ -1024,9 +884,7 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deactivates Timer 2 interrupt management:               */
 	outb(0xE0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	  /******************************************************/
 	/* Selects the command and status register of timer 3 */
-	  /******************************************************/
 	outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes IP and IUS */
@@ -1036,9 +894,7 @@ static int i_APCI1500_Initialisation(struct comedi_device *dev,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deactivates interrupt management of timer 3:            */
 	outb(0xE0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	 /*************************************************/
 	/* Selects the master interrupt control register */
-	 /*************************************************/
 	outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes all interrupts */
@@ -1368,123 +1224,91 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 		}		/*  switch(data[4]) */
 
 		i_TimerCounterMode = data[2] | data[4] | 7;
-			 /*************************/
 		/* Test the reload value */
-			 /*************************/
 
 		if ((data[3] &gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) {
 			if (data[7] == APCI1500_ENABLE
 				|| data[7] == APCI1500_DISABLE) {
 
-				/************************************************/
 				/* Selects the mode register of timer/counter 1 */
-				/************************************************/
 				outb(APCI1500_RW_CPT_TMR1_MODE_SPECIFICATION,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-				/***********************/
 				/* Writes the new mode */
-				/***********************/
 				outb(i_TimerCounterMode,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				/****************************************************/
 				/* Selects the constant register of timer/counter 1 */
-				/****************************************************/
 
 				outb(APCI1500_RW_CPT_TMR1_TIME_CST_LOW,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				  /*************************/
 				/* Writes the low value  */
-				  /*************************/
 
 				outb(data[3],
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				   /****************************************************/
 				/* Selects the constant register of timer/counter 1 */
-				   /****************************************************/
 
 				outb(APCI1500_RW_CPT_TMR1_TIME_CST_HIGH,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				  /**************************/
 				/* Writes the high value  */
-				  /**************************/
 
 				data[3] = data[3] &gt;&gt; 8;
 				outb(data[3],
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				     /*********************************************/
 				/* Selects the master configuration register */
-				     /*********************************************/
 
 				outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				     /**********************/
 				/* Reads the register */
-				     /**********************/
 
 				i_MasterConfiguration =
 					inb(devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				       /********************************************************/
 				/* Enables timer/counter 1 and triggers timer/counter 1 */
-				       /********************************************************/
 
 				i_MasterConfiguration =
 					i_MasterConfiguration | 0x40;
 
-				    /*********************************************/
 				/* Selects the master configuration register */
-				    /*********************************************/
 				outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				      /********************************/
 				/* Writes the new configuration */
-				      /********************************/
 				outb(i_MasterConfiguration,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-					 /****************************************/
 				/* Selects the commands register of     */
 				/* timer/counter 1                      */
-					 /****************************************/
 
 				outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				       /***************************/
 				/* Disable timer/counter 1 */
-				       /***************************/
 
 				outb(0x0,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-					  /****************************************/
 				/* Selects the commands register of     */
 				/* timer/counter 1                      */
-					  /****************************************/
 				outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				      /***************************/
 				/* Trigger timer/counter 1 */
-				      /***************************/
 				outb(0x2,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -1562,123 +1386,91 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 
 		i_TimerCounterMode = data[2] | data[4] | data[5] | data[6] | 7;
 
-			     /*************************/
 		/* Test the reload value */
-			     /*************************/
 
 		if ((data[3] &gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) {
 			if (data[7] == APCI1500_ENABLE
 				|| data[7] == APCI1500_DISABLE) {
 
-				/************************************************/
 				/* Selects the mode register of timer/counter 2 */
-				/************************************************/
 				outb(APCI1500_RW_CPT_TMR2_MODE_SPECIFICATION,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-				/***********************/
 				/* Writes the new mode */
-				/***********************/
 				outb(i_TimerCounterMode,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				/****************************************************/
 				/* Selects the constant register of timer/counter 2 */
-				/****************************************************/
 
 				outb(APCI1500_RW_CPT_TMR2_TIME_CST_LOW,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				  /*************************/
 				/* Writes the low value  */
-				  /*************************/
 
 				outb(data[3],
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				   /****************************************************/
 				/* Selects the constant register of timer/counter 2 */
-				   /****************************************************/
 
 				outb(APCI1500_RW_CPT_TMR2_TIME_CST_HIGH,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				  /**************************/
 				/* Writes the high value  */
-				  /**************************/
 
 				data[3] = data[3] &gt;&gt; 8;
 				outb(data[3],
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				     /*********************************************/
 				/* Selects the master configuration register */
-				     /*********************************************/
 
 				outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				     /**********************/
 				/* Reads the register */
-				     /**********************/
 
 				i_MasterConfiguration =
 					inb(devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				       /********************************************************/
 				/* Enables timer/counter 2 and triggers timer/counter 2 */
-				       /********************************************************/
 
 				i_MasterConfiguration =
 					i_MasterConfiguration | 0x20;
 
-				    /*********************************************/
 				/* Selects the master configuration register */
-				    /*********************************************/
 				outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				      /********************************/
 				/* Writes the new configuration */
-				      /********************************/
 				outb(i_MasterConfiguration,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-					 /****************************************/
 				/* Selects the commands register of     */
 				/* timer/counter 2                      */
-					 /****************************************/
 
 				outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				       /***************************/
 				/* Disable timer/counter 2 */
-				       /***************************/
 
 				outb(0x0,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-					  /****************************************/
 				/* Selects the commands register of     */
 				/* timer/counter 2                      */
-					  /****************************************/
 				outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				      /***************************/
 				/* Trigger timer/counter 1 */
-				      /***************************/
 				outb(0x2,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -1740,142 +1532,104 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			return -EINVAL;
 		}		/*  switch(data[6]) */
 
-		      /*****************************/
 		/* Test if used for watchdog */
-			  /*****************************/
 
 		if (data[2] == APCI1500_WATCHDOG) {
-			     /*****************************/
 			/* - Enables the output line */
 			/* - Enables retrigger       */
 			/* - Pulses output           */
-			     /*****************************/
 			i_TimerCounterMode = data[2] | data[4] | 0x54;
 		}		/* if (data[2] == APCI1500_WATCHDOG) */
 		else {
 			i_TimerCounterMode = data[2] | data[4] | data[6] | 7;
 		}		/* elseif (data[2] == APCI1500_WATCHDOG) */
-				 /*************************/
 		/* Test the reload value */
-			     /*************************/
 
 		if ((data[3] &gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) {
 			if (data[7] == APCI1500_ENABLE
 				|| data[7] == APCI1500_DISABLE) {
 
-				/************************************************/
 				/* Selects the mode register of watchdog/counter 3 */
-				/************************************************/
 				outb(APCI1500_RW_CPT_TMR3_MODE_SPECIFICATION,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
-				/***********************/
 				/* Writes the new mode */
-				/***********************/
 				outb(i_TimerCounterMode,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				/****************************************************/
 				/* Selects the constant register of watchdog/counter 3 */
-				/****************************************************/
 
 				outb(APCI1500_RW_CPT_TMR3_TIME_CST_LOW,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				  /*************************/
 				/* Writes the low value  */
-				  /*************************/
 
 				outb(data[3],
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				   /****************************************************/
 				/* Selects the constant register of watchdog/counter 3 */
-				   /****************************************************/
 
 				outb(APCI1500_RW_CPT_TMR3_TIME_CST_HIGH,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				  /**************************/
 				/* Writes the high value  */
-				  /**************************/
 
 				data[3] = data[3] &gt;&gt; 8;
 				outb(data[3],
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				     /*********************************************/
 				/* Selects the master configuration register */
-				     /*********************************************/
 
 				outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				     /**********************/
 				/* Reads the register */
-				     /**********************/
 
 				i_MasterConfiguration =
 					inb(devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				       /********************************************************/
 				/* Enables watchdog/counter 3 and triggers watchdog/counter 3 */
-				       /********************************************************/
 
 				i_MasterConfiguration =
 					i_MasterConfiguration | 0x10;
 
-				    /*********************************************/
 				/* Selects the master configuration register */
-				    /*********************************************/
 				outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				      /********************************/
 				/* Writes the new configuration */
-				      /********************************/
 				outb(i_MasterConfiguration,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-				      /********************/
 				/* Test if COUNTER */
-					  /********************/
 				if (data[2] == APCI1500_COUNTER) {
 
-					    /*************************************/
 					/* Selects the command register of   */
 					/* watchdog/counter 3                */
-						 /*************************************/
 					outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-					      /*************************************************/
 					/* Disable the  watchdog/counter 3 and starts it */
-						  /*************************************************/
 					outb(0x0,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
 
-					      /*************************************/
 					/* Selects the command register of   */
 					/* watchdog/counter 3                */
-						  /*************************************/
 
 					outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
-					     /*************************************************/
 					/* Trigger the  watchdog/counter 3 and starts it */
-						 /*************************************************/
 					outb(0x2,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -1953,13 +1707,9 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 				else {
 					i_CommandAndStatusValue = 0xE4;	/* disable the interrupt */
 				}	/* elseif(i_TimerCounterWatchdogInterrupt==1) */
-					      /**************************/
 				/* Starts timer/counter 1 */
-					      /**************************/
 				i_TimerCounter1Enabled = 1;
-						/********************************************/
 				/* Selects the commands and status register */
-						/********************************************/
 				outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -1976,13 +1726,9 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 
 		case STOP:
 
-					      /**************************/
 			/* Stop timer/counter 1 */
-					      /**************************/
 
-						/********************************************/
 			/* Selects the commands and status register */
-						/********************************************/
 			outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -1995,23 +1741,17 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 		case TRIGGER:
 			if (i_TimerCounter1Init == 1) {
 				if (i_TimerCounter1Enabled == 1) {
-						 /************************/
 					/* Set Trigger and gate */
-						 /************************/
 
 					i_CommandAndStatusValue = 0x6;
 				}	/* if( i_TimerCounter1Enabled==1) */
 				else {
-						   /***************/
 					/* Set Trigger */
-						   /***************/
 
 					i_CommandAndStatusValue = 0x2;
 				}	/* elseif(i_TimerCounter1Enabled==1) */
 
-						/********************************************/
 				/* Selects the commands and status register */
-						/********************************************/
 				outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -2043,13 +1783,9 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 				else {
 					i_CommandAndStatusValue = 0xE4;	/* disable the interrupt */
 				}	/* elseif(i_TimerCounterWatchdogInterrupt==1) */
-					      /**************************/
 				/* Starts timer/counter 2 */
-					      /**************************/
 				i_TimerCounter2Enabled = 1;
-						/********************************************/
 				/* Selects the commands and status register */
-						/********************************************/
 				outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -2066,13 +1802,9 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 
 		case STOP:
 
-					      /**************************/
 			/* Stop timer/counter 2 */
-					      /**************************/
 
-						/********************************************/
 			/* Selects the commands and status register */
-						/********************************************/
 			outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2084,23 +1816,17 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 		case TRIGGER:
 			if (i_TimerCounter2Init == 1) {
 				if (i_TimerCounter2Enabled == 1) {
-						 /************************/
 					/* Set Trigger and gate */
-						 /************************/
 
 					i_CommandAndStatusValue = 0x6;
 				}	/* if( i_TimerCounter2Enabled==1) */
 				else {
-						   /***************/
 					/* Set Trigger */
-						   /***************/
 
 					i_CommandAndStatusValue = 0x2;
 				}	/* elseif(i_TimerCounter2Enabled==1) */
 
-						/********************************************/
 				/* Selects the commands and status register */
-						/********************************************/
 				outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -2131,13 +1857,9 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 				else {
 					i_CommandAndStatusValue = 0xE4;	/* disable the interrupt */
 				}	/* elseif(i_TimerCounterWatchdogInterrupt==1) */
-					      /**************************/
 				/* Starts Watchdog/counter 3 */
-					      /**************************/
 				i_WatchdogCounter3Enabled = 1;
-						/********************************************/
 				/* Selects the commands and status register */
-						/********************************************/
 				outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -2155,13 +1877,9 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 
 		case STOP:
 
-					      /**************************/
 			/* Stop Watchdog/counter 3 */
-					      /**************************/
 
-						/********************************************/
 			/* Selects the commands and status register */
-						/********************************************/
 			outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2176,23 +1894,17 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 			case 0:	/* triggering counter 3 */
 				if (i_WatchdogCounter3Init == 1) {
 					if (i_WatchdogCounter3Enabled == 1) {
-							       /************************/
 						/* Set Trigger and gate */
-							       /************************/
 
 						i_CommandAndStatusValue = 0x6;
 					}	/* if( i_WatchdogCounter3Enabled==1) */
 					else {
-							   /***************/
 						/* Set Trigger */
-							   /***************/
 
 						i_CommandAndStatusValue = 0x2;
 					}	/* elseif(i_WatchdogCounter3Enabled==1) */
 
-						/********************************************/
 					/* Selects the commands and status register */
-						/********************************************/
 					outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -2210,9 +1922,7 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 				/* triggering Watchdog 3 */
 				if (i_WatchdogCounter3Init == 1) {
 
-						/********************************************/
 					/* Selects the commands and status register */
-						/********************************************/
 					outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 						devpriv-&gt;iobase +
 						APCI1500_Z8536_CONTROL_REGISTER);
@@ -2283,23 +1993,17 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 		/* Read counter/timer1 */
 		if (i_TimerCounter1Init == 1) {
 			if (i_TimerCounter1Enabled == 1) {
-		  /************************/
 				/* Set RCC and gate */
-		  /************************/
 
 				i_CommandAndStatusValue = 0xC;
 			}	/* if( i_TimerCounter1Init==1) */
 			else {
-		    /***************/
 				/* Set RCC */
-		    /***************/
 
 				i_CommandAndStatusValue = 0x8;
 			}	/* elseif(i_TimerCounter1Init==1) */
 
-		/********************************************/
 			/* Selects the commands and status register */
-		/********************************************/
 			outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2307,9 +2011,7 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		 /***************************************/
 			/* Selects the counter register (high) */
-		 /***************************************/
 			outb(APCI1500_R_CPT_TMR1_VALUE_HIGH,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2335,23 +2037,17 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 		/* Read counter/timer2 */
 		if (i_TimerCounter2Init == 1) {
 			if (i_TimerCounter2Enabled == 1) {
-		  /************************/
 				/* Set RCC and gate */
-		  /************************/
 
 				i_CommandAndStatusValue = 0xC;
 			}	/* if( i_TimerCounter2Init==1) */
 			else {
-		    /***************/
 				/* Set RCC */
-		    /***************/
 
 				i_CommandAndStatusValue = 0x8;
 			}	/* elseif(i_TimerCounter2Init==1) */
 
-		/********************************************/
 			/* Selects the commands and status register */
-		/********************************************/
 			outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2359,9 +2055,7 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		 /***************************************/
 			/* Selects the counter register (high) */
-		 /***************************************/
 			outb(APCI1500_R_CPT_TMR2_VALUE_HIGH,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2387,23 +2081,17 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 		/* Read counter/watchdog2 */
 		if (i_WatchdogCounter3Init == 1) {
 			if (i_WatchdogCounter3Enabled == 1) {
-		  /************************/
 				/* Set RCC and gate */
-		  /************************/
 
 				i_CommandAndStatusValue = 0xC;
 			}	/* if( i_TimerCounter2Init==1) */
 			else {
-		    /***************/
 				/* Set RCC */
-		    /***************/
 
 				i_CommandAndStatusValue = 0x8;
 			}	/* elseif(i_WatchdogCounter3Init==1) */
 
-		/********************************************/
 			/* Selects the commands and status register */
-		/********************************************/
 			outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2411,9 +2099,7 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 
-		 /***************************************/
 			/* Selects the counter register (high) */
-		 /***************************************/
 			outb(APCI1500_R_CPT_TMR3_VALUE_HIGH,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
@@ -2525,135 +2211,95 @@ static int i_APCI1500_ConfigureInterrupt(struct comedi_device *dev,
 		}		/* else if(data[0]==0) */
 	}			/* elseif(data[0]==1) */
 
-	 /*****************************************************/
 	/* Selects the mode specification register of port B */
-	 /*****************************************************/
 	outb(APCI1500_RW_PORT_B_SPECIFICATION,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_RegValue = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(APCI1500_RW_PORT_B_SPECIFICATION,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-      /*********************************************/
 	/* Writes the new configuration (APCI1500_OR) */
-      /*********************************************/
 	i_RegValue = (i_RegValue &amp; 0xF9) | APCI1500_OR;
 
 	outb(i_RegValue, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-       /*****************************************************/
 	/* Selects the command and status register of port B */
-       /*****************************************************/
 	outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	/*****************************************/
 	/* Authorises the interrupt on the board */
-	/*****************************************/
 	outb(0xC0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	/***************************************************/
 	/* Selects the pattern polarity register of port B */
-	/***************************************************/
 	outb(APCI1500_RW_PORT_B_PATTERN_POLARITY,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(i_Constant, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	/*****************************************************/
 	/* Selects the pattern transition register of port B */
-	/*****************************************************/
 	outb(APCI1500_RW_PORT_B_PATTERN_TRANSITION,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(i_Constant, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	/***********************************************/
 	/* Selects the pattern mask register of port B */
-	/***********************************************/
 	outb(APCI1500_RW_PORT_B_PATTERN_MASK,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(i_Constant, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	/*****************************************************/
 	/* Selects the command and status register of port A */
-	/*****************************************************/
 	outb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_RegValue = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	 /***********************************/
 	/* Deletes the interrupt of port A */
-	 /***********************************/
 
 	i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 	outb(i_RegValue, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	/*****************************************************/
 	/* Selects the command and status register of port  B */
-	/*****************************************************/
 	outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_RegValue = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	 /***********************************/
 	/* Deletes the interrupt of port B */
-	 /***********************************/
 
 	i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 	outb(i_RegValue, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	/*****************************************************/
 	/* Selects the command and status register of timer 1 */
-	/*****************************************************/
 	outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_RegValue = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	 /***********************************/
 	/* Deletes the interrupt of timer 1 */
-	 /***********************************/
 
 	i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 	outb(i_RegValue, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	 /*****************************************************/
 	/* Selects the command and status register of timer 2 */
-	/*****************************************************/
 	outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_RegValue = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	 /***********************************/
 	/* Deletes the interrupt of timer 2 */
-	 /***********************************/
 
 	i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 	outb(i_RegValue, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	/*****************************************************/
 	/* Selects the command and status register of timer 3 */
-	/*****************************************************/
 	outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_RegValue = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	 /***********************************/
 	/* Deletes the interrupt of timer 3 */
-	 /***********************************/
 
 	i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 	outb(i_RegValue, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	 /*************************************************/
 	/* Selects the master interrupt control register */
-	 /*************************************************/
 	outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	/**********************************************/
 	/* Authorizes the main interrupt on the board */
-	/**********************************************/
 	outb(0xD0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-      /***************************/
 	/* Enables the PCI interrupt */
-      /*****************************/
 	outl(0x3000, devpriv-&gt;i_IobaseAmcc + 0x38);
 	ui_Status = inl(devpriv-&gt;i_IobaseAmcc + 0x10);
 	ui_Status = inl(devpriv-&gt;i_IobaseAmcc + 0x38);
@@ -2688,44 +2334,28 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 	int i_RegValue = 0;
 	i_InterruptMask = 0;
 
- /***********************************/
 	/* Read the board interrupt status */
- /***********************************/
 	ui_InterruptStatus = inl(devpriv-&gt;i_IobaseAmcc + 0x38);
 
-  /***************************************/
 	/* Test if board generated a interrupt */
-  /***************************************/
 	if ((ui_InterruptStatus &amp; 0x800000) == 0x800000) {
-      /************************/
 		/* Disable all Interrupt */
-      /************************/
-      /*************************************************/
 		/* Selects the master interrupt control register */
-      /*************************************************/
 		/* outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,devpriv-&gt;iobase+APCI1500_Z8536_CONTROL_REGISTER); */
-	/**********************************************/
 		/* Disables  the main interrupt on the board */
-	/**********************************************/
 		/* outb(0x00,devpriv-&gt;iobase+APCI1500_Z8536_CONTROL_REGISTER); */
 
-   /*****************************************************/
 		/* Selects the command and status register of port A */
-   /*****************************************************/
 		outb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,
 			devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		i_RegValue =
 			inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		if ((i_RegValue &amp; 0x60) == 0x60) {
-	   /*****************************************************/
 			/* Selects the command and status register of port A */
-	   /*****************************************************/
 			outb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-	    /***********************************/
 			/* Deletes the interrupt of port A */
-	    /***********************************/
 			i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 			outb(i_RegValue,
 				devpriv-&gt;iobase +
@@ -2739,9 +2369,7 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 					inb(devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
 
-	      /***************************************************/
 				/* Selects the interrupt vector register of port A */
-	      /***************************************************/
 				outb(APCI1500_RW_PORT_A_INTERRUPT_CONTROL,
 					devpriv-&gt;iobase +
 					APCI1500_Z8536_CONTROL_REGISTER);
@@ -2757,44 +2385,32 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 			}	/* elseif(i_Logic==APCI1500_OR_PRIORITY) */
 		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
 
-	   /*****************************************************/
 		/* Selects the command and status register of port B */
-	   /*****************************************************/
 		outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,
 			devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		i_RegValue =
 			inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		if ((i_RegValue &amp; 0x60) == 0x60) {
-	     /*****************************************************/
 			/* Selects the command and status register of port B */
-	     /*****************************************************/
 			outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-	     /***********************************/
 			/* Deletes the interrupt of port B */
-	     /***********************************/
 			i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 			outb(i_RegValue,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-	     /****************/
 			/* Reads port B */
-	     /****************/
 			i_RegValue =
 				inb((unsigned int) devpriv-&gt;iobase +
 				APCI1500_Z8536_PORT_B);
 
 			i_RegValue = i_RegValue &amp; 0xC0;
-	      /**************************************/
 			/* Tests if this is an external error */
-	      /**************************************/
 
 			if (i_RegValue) {
 				/* Disable the interrupt */
-		     /*****************************************************/
 				/* Selects the command and status register of port B */
-		     /*****************************************************/
 				outl(0x0, devpriv-&gt;i_IobaseAmcc + 0x38);
 
 				if (i_RegValue &amp; 0x80) {
@@ -2812,46 +2428,34 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 			}	/*  if (i_RegValue) */
 		}		/* if ((i_RegValue &amp; 0x60) == 0x60) */
 
-		/*****************************************************/
 		/* Selects the command and status register of timer 1 */
-		/*****************************************************/
 		outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 			devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		i_RegValue =
 			inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		if ((i_RegValue &amp; 0x60) == 0x60) {
-		   /*****************************************************/
 			/* Selects the command and status register of timer 1 */
-		   /*****************************************************/
 			outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		   /***********************************/
 			/* Deletes the interrupt of timer 1 */
-		   /***********************************/
 			i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 			outb(i_RegValue,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
 			i_InterruptMask = i_InterruptMask | 4;
 		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
-		/*****************************************************/
 		/* Selects the command and status register of timer 2 */
-		/*****************************************************/
 		outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 			devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		i_RegValue =
 			inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		if ((i_RegValue &amp; 0x60) == 0x60) {
-		   /*****************************************************/
 			/* Selects the command and status register of timer 2 */
-		   /*****************************************************/
 			outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		   /***********************************/
 			/* Deletes the interrupt of timer 2 */
-		   /***********************************/
 			i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 			outb(i_RegValue,
 				devpriv-&gt;iobase +
@@ -2859,23 +2463,17 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 			i_InterruptMask = i_InterruptMask | 8;
 		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
 
-		/*****************************************************/
 		/* Selects the command and status register of timer 3 */
-		/*****************************************************/
 		outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 			devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		i_RegValue =
 			inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 		if ((i_RegValue &amp; 0x60) == 0x60) {
-		   /*****************************************************/
 			/* Selects the command and status register of timer 3 */
-		   /*****************************************************/
 			outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-		   /***********************************/
 			/* Deletes the interrupt of timer 3 */
-		   /***********************************/
 			i_RegValue = (i_RegValue &amp; 0x0F) | 0x20;
 			outb(i_RegValue,
 				devpriv-&gt;iobase +
@@ -2889,18 +2487,12 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 		}		/*  if ((i_RegValue &amp; 0x60) == 0x60) */
 
 		send_sig(SIGIO, devpriv-&gt;tsk_Current, 0);	/*  send signal to the sample */
-	       /***********************/
 		/* Enable all Interrupts */
-	       /***********************/
 
-	       /*************************************************/
 		/* Selects the master interrupt control register */
-	       /*************************************************/
 		outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,
 			devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	       /**********************************************/
 		/* Authorizes the main interrupt on the board */
-	       /**********************************************/
 		outb(0xD0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	}			/*   if ((ui_InterruptStatus &amp; 0x800000) == 0x800000) */
 	else {
@@ -2944,9 +2536,7 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 	i_TimerCounter2Enabled = 0;
 	i_WatchdogCounter3Enabled = 0;
 
-    /******************/
 	/* Software reset */
-    /******************/
 	i_DummyRead = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	i_DummyRead = inb(devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
@@ -2954,16 +2544,12 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 	outb(1, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
- /*****************************************************/
 	/* Selects the master configuration control register */
- /*****************************************************/
 	outb(APCI1500_RW_MASTER_CONFIGURATION_CONTROL,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0xF4, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	/*****************************************************/
 	/* Selects the mode specification register of port A */
-	/*****************************************************/
 	outb(APCI1500_RW_PORT_A_SPECIFICATION,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0x10, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
@@ -2995,9 +2581,7 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 	/* Deletes the register */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	 /*****************************************************/
 	/* Selects the mode specification register of port B */
-	 /*****************************************************/
 	outb(APCI1500_RW_PORT_B_SPECIFICATION,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	outb(0x10, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
@@ -3027,9 +2611,7 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 	/* Deletes the register */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 
-	   /*****************************************************/
 	/* Selects the data path polarity register of port C */
-	   /*****************************************************/
 	outb(APCI1500_RW_PORT_C_DATA_PCITCH_POLARITY,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* High level of port C means 1 */
@@ -3044,9 +2626,7 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes it */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	   /******************************************************/
 	/* Selects the command and status register of timer 1 */
-	   /******************************************************/
 	outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes IP and IUS */
@@ -3056,9 +2636,7 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deactivates the interrupt management of timer 1         */
 	outb(0xE0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	   /******************************************************/
 	/* Selects the command and status register of timer 2 */
-	   /******************************************************/
 	outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes IP and IUS */
@@ -3068,9 +2646,7 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deactivates Timer 2 interrupt management:               */
 	outb(0xE0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	  /******************************************************/
 	/* Selects the command and status register of timer 3 */
-	  /******************************************************/
 	outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes IP and IUS */
@@ -3080,71 +2656,43 @@ static int i_APCI1500_Reset(struct comedi_device *dev)
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deactivates interrupt management of timer 3:            */
 	outb(0xE0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-	 /*************************************************/
 	/* Selects the master interrupt control register */
-	 /*************************************************/
 	outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* Deletes all interrupts */
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	/* reset all the digital outputs */
 	outw(0x0, devpriv-&gt;i_IobaseAddon + APCI1500_DIGITAL_OP);
-/*******************************/
 /* Disable the board interrupt */
-/*******************************/
- /*************************************************/
 	/* Selects the master interrupt control register */
- /*************************************************/
 	outb(APCI1500_RW_MASTER_INTERRUPT_CONTROL,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/****************************/
 /* Deactivates all interrupts */
-/******************************/
 	outb(0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
- /*****************************************************/
 	/* Selects the command and status register of port A */
- /*****************************************************/
 	outb(APCI1500_RW_PORT_A_COMMAND_AND_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/****************************/
 /* Deactivates all interrupts */
-/******************************/
 	outb(0x00, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/*****************************************************/
 	/* Selects the command and status register of port B */
- /*****************************************************/
 	outb(APCI1500_RW_PORT_B_COMMAND_AND_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/****************************/
 /* Deactivates all interrupts */
-/******************************/
 	outb(0x00, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/*****************************************************/
 	/* Selects the command and status register of timer 1 */
- /*****************************************************/
 	outb(APCI1500_RW_CPT_TMR1_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/****************************/
 /* Deactivates all interrupts */
-/******************************/
 	outb(0x00, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/*****************************************************/
 	/* Selects the command and status register of timer 2 */
- /*****************************************************/
 	outb(APCI1500_RW_CPT_TMR2_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/****************************/
 /* Deactivates all interrupts */
-/******************************/
 	outb(0x00, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/*****************************************************/
 /* Selects the command and status register of timer 3*/
-/*****************************************************/
 	outb(APCI1500_RW_CPT_TMR3_CMD_STATUS,
 		devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
-/****************************/
 /* Deactivates all interrupts */
-/******************************/
 	outb(0x00, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	return 0;
 }</pre><hr><pre>commit d0ba1e38e05212037b5107522f12537f8168c463
Author: Conrad Meyer &lt;cemeyer@uw.edu&gt;
Date:   Sat Mar 8 21:42:39 2014 -0500

    Staging: comedi: Fix some raw printks with dev_warn()
    
    Brought to you with the help of sed and manual clean-up after.
    
      $ sed -i -e 's|printk("\\n|dev_warn(dev-&gt;hw_dev,\n\t"|' \
        addi-data/hwdrv_apci1500.c
    
    Since all of these printk()s were for invalid API inputs and most of
    them returned -EINVAL, I fixed the rest of them to return -EINVAL as
    well.
    
    Signed-off-by: Conrad Meyer &lt;cse.cem@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
index 2628ac44f109..0ccf784b81a4 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
@@ -259,7 +259,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 			i_MaxChannel = 6;
 		}		/*  if(data[0]==2) */
 		else {
-			printk("\nThe specified port event  does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The specified port event does not exist\n");
 			return -EINVAL;
 		}		/* else if(data[0]==2) */
 	}			/* else  if (data[0] == 1) */
@@ -274,7 +275,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 		data[1] = APCI1500_OR_PRIORITY;
 		break;
 	default:
-		printk("\nThe specified interrupt logic does not exist\n");
+		dev_warn(dev-&gt;hw_dev,
+			"The specified interrupt logic does not exist\n");
 		return -EINVAL;
 	}			/* switch(data[1]); */
 
@@ -318,7 +320,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 		case 5:
 			break;
 		default:
-			printk("\nThe option indicated in the event mask does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The option indicated in the event mask does not exist\n");
 			return -EINVAL;
 		}		/*  switch(i_EventMask) */
 	}			/* for (i_Count = i_MaxChannel; i_Count &gt;0;i_Count --) */
@@ -338,10 +341,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 
 			if (data[1] == APCI1500_OR_PRIORITY
 				&amp;&amp; i_PatternTransition != 0) {
-			      /********************************************/
-				/* Transition error on an OR PRIORITY logic */
-			      /********************************************/
-				printk("\nTransition error on an OR PRIORITY logic\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Transition error on an OR PRIORITY logic\n");
 				return -EINVAL;
 			}	/*  if (data[1]== APCI1500_OR_PRIORITY &amp;&amp; i_PatternTransition != 0) */
 
@@ -360,10 +361,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				}	/* for (i_Count = 0; i_Count &lt; 8; i_Count++) */
 
 				if (i_PatternTransitionCount &gt; 1) {
-				  /****************************************/
-					/* Transition error on an AND logic     */
-				  /****************************************/
-					printk("\n Transition error on an AND logic\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Transition error on an AND logic\n");
 					return -EINVAL;
 				}	/*  if (i_PatternTransitionCount &gt; 1) */
 			}	/*  if (data[1]== APCI1500_AND) */
@@ -457,7 +456,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 
 		}		/*  if(data[1]==APCI1500_AND||data[1]==APCI1500_OR||data[1]==APCI1500_OR_PRIORITY) */
 		else {
-			printk("\nThe choice for interrupt logic does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The choice for interrupt logic does not exist\n");
 			return -EINVAL;
 		}		/*  else }// if(data[1]==APCI1500_AND||data[1]==APCI1500_OR||data[1]==APCI1500_OR_PRIORITY) */
 	}			/*    if (data[0]== 1) */
@@ -585,7 +585,8 @@ static int i_APCI1500_ConfigDigitalInputEvent(struct comedi_device *dev,
 				APCI1500_Z8536_CONTROL_REGISTER);
 		}		/*   if (data[1] == APCI1500_OR) */
 		else {
-			printk("\nThe choice for interrupt logic does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The choice for interrupt logic does not exist\n");
 			return -EINVAL;
 		}		/* elseif (data[1] == APCI1500_OR) */
 	}			/* if(data[0]==2) */
@@ -691,7 +692,8 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 
 				}	/*  if(i_Event1Status==1) */
 				else {
-					printk("\nEvent 1 not initialised\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Event 1 not initialised\n");
 					return -EINVAL;
 				}	/* else if(i_Event1Status==1) */
 			}	/* if (data[1]==1) */
@@ -742,13 +744,15 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 					i_Event2InterruptStatus = 1;
 				}	/*  if(i_Event2Status==1) */
 				else {
-					printk("\nEvent 2 not initialised\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Event 2 not initialised\n");
 					return -EINVAL;
 				}	/* else if(i_Event2Status==1) */
 			}	/*  if(data[1]==2) */
 		}		/*  if (data[1] == 1 || data[0] == 2) */
 		else {
-			printk("\nThe port parameter is in error\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The port parameter is in error\n");
 			return -EINVAL;
 		}		/* else if (data[1] == 1 || data[0] == 2) */
 
@@ -803,7 +807,8 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 					i_Event1InterruptStatus = 0;
 				}	/*  if(i_Event1Status==1) */
 				else {
-					printk("\nEvent 1 not initialised\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Event 1 not initialised\n");
 					return -EINVAL;
 				}	/* else if(i_Event1Status==1) */
 			}	/* if (data[1]==1) */
@@ -846,19 +851,22 @@ static int i_APCI1500_StartStopInputEvent(struct comedi_device *dev,
 					i_Event2InterruptStatus = 0;
 				}	/*  if(i_Event2Status==1) */
 				else {
-					printk("\nEvent 2 not initialised\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Event 2 not initialised\n");
 					return -EINVAL;
 				}	/* else if(i_Event2Status==1) */
 			}	/* if(data[1]==2) */
 
 		}		/*  if (data[1] == 1 || data[1] == 2) */
 		else {
-			printk("\nThe port parameter is in error\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The port parameter is in error\n");
 			return -EINVAL;
 		}		/* else if (data[1] == 1 || data[1] == 2) */
 		break;
 	default:
-		printk("\nThe option of START/STOP logic does not exist\n");
+		dev_warn(dev-&gt;hw_dev,
+			"The option of START/STOP logic does not exist\n");
 		return -EINVAL;
 	}			/* switch(data[0]) */
 
@@ -1164,7 +1172,9 @@ static int i_APCI1500_WriteDigitalOutput(struct comedi_device *dev,
 					APCI1500_DIGITAL_OP);
 			}	/*  if(data[1]==1) */
 			else {
-				printk("\nSpecified channel not supported\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Specified channel not supported\n");
+				return -EINVAL;
 			}	/* else if(data[1]==1) */
 		}		/* elseif(data[1]==0) */
 	}			/* if(data[3]==0) */
@@ -1241,12 +1251,15 @@ static int i_APCI1500_WriteDigitalOutput(struct comedi_device *dev,
 						APCI1500_DIGITAL_OP);
 				}	/*  if(data[1]==1) */
 				else {
-					printk("\nSpecified channel not supported\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Specified channel not supported\n");
+					return -EINVAL;
 				}	/* else if(data[1]==1) */
 			}	/* elseif(data[1]==0) */
 		}		/* if(data[3]==1); */
 		else {
-			printk("\nSpecified functionality does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"Specified functionality does not exist\n");
 			return -EINVAL;
 		}		/* if else data[3]==1) */
 	}			/* if else data[3]==0) */
@@ -1318,7 +1331,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 	}			/*  if(data[0]==0||data[0]==1||data[0]==2) */
 	else {
 		if (data[0] != 3) {
-			printk("\nThe option for input clock selection does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The option for input clock selection does not exist\n");
 			return -EINVAL;
 		}		/*  if(data[0]!=3) */
 	}			/* elseif(data[0]==0||data[0]==1||data[0]==2) */
@@ -1334,7 +1348,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[2] = APCI1500_TIMER;
 			break;
 		default:
-			printk("\nThis choice is not a timer nor a counter\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This choice is not a timer nor a counter\n");
 			return -EINVAL;
 		}		/*  switch(data[2]) */
 
@@ -1347,7 +1362,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[4] = APCI1500_SINGLE;
 			break;
 		default:
-			printk("\nThis option for single/continuous mode does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This option for single/continuous mode does not exist\n");
 			return -EINVAL;
 		}		/*  switch(data[4]) */
 
@@ -1474,12 +1490,14 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 					APCI1500_Z8536_CONTROL_REGISTER);
 			}	/* if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 			else {
-				printk("\nError in selection of interrupt enable or disable\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Error in selection of interrupt enable or disable\n");
 				return -EINVAL;
 			}	/* elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 		}		/*  if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		else {
-			printk("\nError in selection of reload value\n");
+			dev_warn(dev-&gt;hw_dev,
+				"Error in selection of reload value\n");
 			return -EINVAL;
 		}		/* else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		i_TimerCounterWatchdogInterrupt = data[7];
@@ -1495,7 +1513,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[2] = APCI1500_TIMER;
 			break;
 		default:
-			printk("\nThis choice is not a timer nor a counter\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This choice is not a timer nor a counter\n");
 			return -EINVAL;
 		}		/*  switch(data[2]) */
 
@@ -1508,7 +1527,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[4] = APCI1500_SINGLE;
 			break;
 		default:
-			printk("\nThis option for single/continuous mode does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This option for single/continuous mode does not exist\n");
 			return -EINVAL;
 		}		/*  switch(data[4]) */
 
@@ -1521,7 +1541,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[5] = APCI1500_HARDWARE_TRIGGER;
 			break;
 		default:
-			printk("\nThis choice for software or hardware trigger does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This choice for software or hardware trigger does not exist\n");
 			return -EINVAL;
 		}		/*  switch(data[5]) */
 
@@ -1534,7 +1555,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[6] = APCI1500_HARDWARE_GATE;
 			break;
 		default:
-			printk("\nThis choice for software or hardware gate does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This choice for software or hardware gate does not exist\n");
 			return -EINVAL;
 		}		/*  switch(data[6]) */
 
@@ -1662,12 +1684,14 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 					APCI1500_Z8536_CONTROL_REGISTER);
 			}	/* if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 			else {
-				printk("\nError in selection of interrupt enable or disable\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Error in selection of interrupt enable or disable\n");
 				return -EINVAL;
 			}	/* elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 		}		/*  if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		else {
-			printk("\nError in selection of reload value\n");
+			dev_warn(dev-&gt;hw_dev,
+				"Error in selection of reload value\n");
 			return -EINVAL;
 		}		/* else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		i_TimerCounterWatchdogInterrupt = data[7];
@@ -1683,7 +1707,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[2] = APCI1500_WATCHDOG;
 			break;
 		default:
-			printk("\nThis choice is not a watchdog nor a counter\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This choice is not a watchdog nor a counter\n");
 			return -EINVAL;
 		}		/*  switch(data[2]) */
 
@@ -1696,7 +1721,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[4] = APCI1500_SINGLE;
 			break;
 		default:
-			printk("\nThis option for single/continuous mode does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This option for single/continuous mode does not exist\n");
 			return -EINVAL;
 		}		/*  switch(data[4]) */
 
@@ -1709,7 +1735,8 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 			data[6] = APCI1500_HARDWARE_GATE;
 			break;
 		default:
-			printk("\nThis choice for software or hardware gate does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"This choice for software or hardware gate does not exist\n");
 			return -EINVAL;
 		}		/*  switch(data[6]) */
 
@@ -1857,12 +1884,14 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 
 			}	/* if(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 			else {
-				printk("\nError in selection of interrupt enable or disable\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Error in selection of interrupt enable or disable\n");
 				return -EINVAL;
 			}	/* elseif(data[7]== APCI1500_ENABLE ||data[7]== APCI1500_DISABLE) */
 		}		/*  if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		else {
-			printk("\nError in selection of reload value\n");
+			dev_warn(dev-&gt;hw_dev,
+				"Error in selection of reload value\n");
 			return -EINVAL;
 		}		/* else if ((data[3]&gt;= 0) &amp;&amp; (data[3] &lt;= 65535)) */
 		i_TimerCounterWatchdogInterrupt = data[7];
@@ -1870,7 +1899,9 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 		break;
 
 	default:
-		printk("\nThe specified counter\timer option does not exist\n");
+		dev_warn(dev-&gt;hw_dev,
+			"The specified counter/timer option does not exist\n");
+		return -EINVAL;
 	}			/* switch(data[1]) */
 	i_CounterLogic = data[2];
 	return insn-&gt;n;
@@ -1937,7 +1968,8 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 					APCI1500_Z8536_CONTROL_REGISTER);
 			}	/* if( i_TimerCounter1Init==1) */
 			else {
-				printk("\nCounter/Timer1 not configured\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Counter/Timer1 not configured\n");
 				return -EINVAL;
 			}
 			break;
@@ -1988,13 +2020,15 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 					APCI1500_Z8536_CONTROL_REGISTER);
 			}	/* if( i_TimerCounter1Init==1) */
 			else {
-				printk("\nCounter/Timer1 not configured\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Counter/Timer1 not configured\n");
 				return -EINVAL;
 			}
 			break;
 
 		default:
-			printk("\nThe specified option for start/stop/trigger does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The specified option for start/stop/trigger does not exist\n");
 			return -EINVAL;
 		}		/* switch(data[1]) */
 		break;
@@ -2024,7 +2058,8 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 					APCI1500_Z8536_CONTROL_REGISTER);
 			}	/* if( i_TimerCounter2Init==1) */
 			else {
-				printk("\nCounter/Timer2 not configured\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Counter/Timer2 not configured\n");
 				return -EINVAL;
 			}
 			break;
@@ -2074,12 +2109,14 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 					APCI1500_Z8536_CONTROL_REGISTER);
 			}	/* if( i_TimerCounter2Init==1) */
 			else {
-				printk("\nCounter/Timer2 not configured\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Counter/Timer2 not configured\n");
 				return -EINVAL;
 			}
 			break;
 		default:
-			printk("\nThe specified option for start/stop/trigger does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The specified option for start/stop/trigger does not exist\n");
 			return -EINVAL;
 		}		/* switch(data[1]) */
 		break;
@@ -2110,7 +2147,8 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 
 			}	/*  if( i_WatchdogCounter3init==1) */
 			else {
-				printk("\nWatchdog/Counter3 not configured\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Watchdog/Counter3 not configured\n");
 				return -EINVAL;
 			}
 			break;
@@ -2163,7 +2201,8 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 						APCI1500_Z8536_CONTROL_REGISTER);
 				}	/* if( i_WatchdogCounter3Init==1) */
 				else {
-					printk("\nCounter3 not configured\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Counter3 not configured\n");
 					return -EINVAL;
 				}
 				break;
@@ -2182,22 +2221,26 @@ static int i_apci1500_timer_watchdog(struct comedi_device *dev,
 						APCI1500_Z8536_CONTROL_REGISTER);
 				}	/* if( i_WatchdogCounter3Init==1) */
 				else {
-					printk("\nWatchdog 3 not configured\n");
+					dev_warn(dev-&gt;hw_dev,
+						"Watchdog 3 not configured\n");
 					return -EINVAL;
 				}
 				break;
 			default:
-				printk("\nWrong choice of watchdog/counter3\n");
+				dev_warn(dev-&gt;hw_dev,
+					"Wrong choice of watchdog/counter3\n");
 				return -EINVAL;
 			}	/* switch(data[2]) */
 			break;
 		default:
-			printk("\nThe specified option for start/stop/trigger does not exist\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The specified option for start/stop/trigger does not exist\n");
 			return -EINVAL;
 		}		/* switch(data[1]) */
 		break;
 	default:
-		printk("\nThe specified choice for counter/watchdog/timer does not exist\n");
+		dev_warn(dev-&gt;hw_dev,
+			"The specified choice for counter/watchdog/timer does not exist\n");
 		return -EINVAL;
 	}			/* switch(data[0]) */
 	return insn-&gt;n;
@@ -2283,7 +2326,8 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 				APCI1500_Z8536_CONTROL_REGISTER);
 		}		/* if( i_TimerCounter1Init==1) */
 		else {
-			printk("\nTimer/Counter1 not configured\n");
+			dev_warn(dev-&gt;hw_dev,
+				"Timer/Counter1 not configured\n");
 			return -EINVAL;
 		}		/* elseif( i_TimerCounter1Init==1) */
 		break;
@@ -2334,7 +2378,8 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 				APCI1500_Z8536_CONTROL_REGISTER);
 		}		/* if( i_TimerCounter2Init==1) */
 		else {
-			printk("\nTimer/Counter2 not configured\n");
+			dev_warn(dev-&gt;hw_dev,
+				"Timer/Counter2 not configured\n");
 			return -EINVAL;
 		}		/* elseif( i_TimerCounter2Init==1) */
 		break;
@@ -2385,12 +2430,14 @@ static int i_APCI1500_ReadCounterTimerWatchdog(struct comedi_device *dev,
 				APCI1500_Z8536_CONTROL_REGISTER);
 		}		/* if( i_WatchdogCounter3Init==1) */
 		else {
-			printk("\nWatchdogCounter3 not configured\n");
+			dev_warn(dev-&gt;hw_dev,
+				"WatchdogCounter3 not configured\n");
 			return -EINVAL;
 		}		/* elseif( i_WatchdogCounter3Init==1) */
 		break;
 	default:
-		printk("\nThe choice of timer/counter/watchdog does not exist\n");
+		dev_warn(dev-&gt;hw_dev,
+			"The choice of timer/counter/watchdog does not exist\n");
 		return -EINVAL;
 	}			/* switch(data[0]) */
 
@@ -2472,7 +2519,8 @@ static int i_APCI1500_ConfigureInterrupt(struct comedi_device *dev,
 			i_Constant = 0x00;
 		}		/* if{data[0]==0) */
 		else {
-			printk("\nThe parameter passed to driver is in error for enabling the voltage interrupt\n");
+			dev_warn(dev-&gt;hw_dev,
+				"The parameter passed to driver is in error for enabling the voltage interrupt\n");
 			return -EINVAL;
 		}		/* else if(data[0]==0) */
 	}			/* elseif(data[0]==1) */
@@ -2730,7 +2778,6 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 			outb(i_RegValue,
 				devpriv-&gt;iobase +
 				APCI1500_Z8536_CONTROL_REGISTER);
-			printk("\n\n\n");
 	     /****************/
 			/* Reads port B */
 	     /****************/
@@ -2857,7 +2904,8 @@ static void v_APCI1500_Interrupt(int irq, void *d)
 		outb(0xD0, devpriv-&gt;iobase + APCI1500_Z8536_CONTROL_REGISTER);
 	}			/*   if ((ui_InterruptStatus &amp; 0x800000) == 0x800000) */
 	else {
-		printk("\nInterrupt from unknown source\n");
+		dev_warn(dev-&gt;hw_dev,
+			"Interrupt from unknown source\n");
 
 	}			/* else if ((ui_InterruptStatus &amp; 0x800000) == 0x800000) */
 	return;</pre><hr><pre>commit f3c25d569045c8e0f274956291b51641241da174
Author: Conrad Meyer &lt;cemeyer@uw.edu&gt;
Date:   Sat Mar 8 15:47:24 2014 -0500

    Staging: comedi: Fix 80-char line limit style issue in addi_apci_1500.c
    
    Rename some very long functions in addi-data/hwdrv_apci1500.c.
    
    Signed-off-by: Conrad Meyer &lt;cse.cem@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
index 054910511e9e..2628ac44f109 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci1500.c
@@ -1052,7 +1052,7 @@ static int apci1500_di_insn_bits(struct comedi_device *dev,
 
 /*
 +----------------------------------------------------------------------------+
-| Function   Name   : int i_APCI1500_ConfigDigitalOutputErrorInterrupt
+| Function   Name   : int i_apci1500_config_output
 |                      (struct comedi_device *dev,struct comedi_subdevice *s struct comedi_insn
 |                      *insn,unsigned int *data)                                  |
 |				                                                     |
@@ -1078,10 +1078,9 @@ static int apci1500_di_insn_bits(struct comedi_device *dev,
 |			                                                         |
 +----------------------------------------------------------------------------+
 */
-static int i_APCI1500_ConfigDigitalOutputErrorInterrupt(struct comedi_device *dev,
-							struct comedi_subdevice *s,
-							struct comedi_insn *insn,
-							unsigned int *data)
+static int i_acpi1500_config_output(struct comedi_device *dev,
+	struct comedi_subdevice *s, struct comedi_insn *insn,
+	unsigned int *data)
 {
 	struct addi_private *devpriv = dev-&gt;private;
 
@@ -1879,7 +1878,7 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 
 /*
 +----------------------------------------------------------------------------+
-| Function   Name   : int i_APCI1500_StartStopTriggerTimerCounterWatchdog      |
+| Function   Name   : int i_apci1500_timer_watchdog
 |				(struct comedi_device *dev,struct comedi_subdevice *s,
 |                         struct comedi_insn *insn,unsigned int *data);                  |
 +----------------------------------------------------------------------------+
@@ -1905,10 +1904,9 @@ static int i_APCI1500_ConfigCounterTimerWatchdog(struct comedi_device *dev,
 |			                                                         |
 +----------------------------------------------------------------------------+
 */
-static int i_APCI1500_StartStopTriggerTimerCounterWatchdog(struct comedi_device *dev,
-							   struct comedi_subdevice *s,
-							   struct comedi_insn *insn,
-							   unsigned int *data)
+static int i_apci1500_timer_watchdog(struct comedi_device *dev,
+	struct comedi_subdevice *s, struct comedi_insn *insn,
+	unsigned int *data)
 {
 	struct addi_private *devpriv = dev-&gt;private;
 	int i_CommandAndStatusValue;
diff --git a/drivers/staging/comedi/drivers/addi_apci_1500.c b/drivers/staging/comedi/drivers/addi_apci_1500.c
index 74f7ace8adbc..afa7d6e97a5b 100644
--- a/drivers/staging/comedi/drivers/addi_apci_1500.c
+++ b/drivers/staging/comedi/drivers/addi_apci_1500.c
@@ -26,11 +26,11 @@ static const struct addi_board apci1500_boardtypes[] = {
 		.di_read		= i_APCI1500_Initialisation,
 		.di_write		= i_APCI1500_StartStopInputEvent,
 		.di_bits		= apci1500_di_insn_bits,
-		.do_config		= i_APCI1500_ConfigDigitalOutputErrorInterrupt,
+		.do_config		= i_acpi1500_config_output,
 		.do_write		= i_APCI1500_WriteDigitalOutput,
 		.do_bits		= i_APCI1500_ConfigureInterrupt,
 		.timer_config		= i_APCI1500_ConfigCounterTimerWatchdog,
-		.timer_write		= i_APCI1500_StartStopTriggerTimerCounterWatchdog,
+		.timer_write		= i_apci1500_timer_watchdog,
 		.timer_read		= i_APCI1500_ReadInterruptMask,
 		.timer_bits		= i_APCI1500_ReadCounterTimerWatchdog,
 	},</pre>
    <div class="pagination">
        <span>[1]</span><a href='13_2.html'>2</a><a href='13_3.html'>3</a><a href='13_4.html'>4</a><a href='13_5.html'>5</a><a href='13_6.html'>6</a><a href='13_7.html'>7</a><a href='13_8.html'>8</a><a href='13_2.html'>Next&gt;&gt;</a>
    <div>
</body>
