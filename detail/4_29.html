<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_28.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><span>[29]</span><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_30.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 456018d791ff4ef03d610f72486c637056bcd749
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Oct 8 15:31:14 2008 -0400

    NFS: Cleanup nfs_set_port
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 5d2a5d3c4241..d212ee41caf2 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -285,16 +285,15 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
  */
 static inline void nfs_set_port(struct sockaddr *sap, unsigned short port)
 {
+	struct sockaddr_in *ap = (struct sockaddr_in *)sap;
+	struct sockaddr_in6 *ap6 = (struct sockaddr_in6 *)sap;
+
 	switch (sap-&gt;sa_family) {
-	case AF_INET: {
-	      struct sockaddr_in *ap = (struct sockaddr_in *)sap;
-	      ap-&gt;sin_port = htons(port);
-	      break;
-	}
-	case AF_INET6: {
-	       struct sockaddr_in6 *ap = (struct sockaddr_in6 *)sap;
-	       ap-&gt;sin6_port = htons(port);
-	       break;
-	}
+	case AF_INET:
+		ap-&gt;sin_port = htons(port);
+		break;
+	case AF_INET6:
+		ap6-&gt;sin6_port = htons(port);
+		break;
 	}
 }</pre><hr><pre>commit 107e0008dfb8bd6366bc8827f5bbbc0c1f795d2d
Merge: 293739138580 67080c82361b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Oct 8 18:22:18 2008 -0400

    Merge branch 'from-tomtucker' into for-2.6.28
</pre><hr><pre>commit ea31a4437c59219bf3ea946d58984b01a45a289c
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Aug 20 16:10:23 2008 -0400

    nfs: Fix misparsing of nfsv4 fs_locations attribute
    
    The code incorrectly assumes here that the server name (or ip address)
    is null-terminated.  This can cause referrals to fail in some cases.
    
    Also support ipv6 addresses.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 8d91bd88e310..5d2a5d3c4241 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -153,6 +153,7 @@ extern void nfs4_clear_inode(struct inode *);
 void nfs_zap_acl_cache(struct inode *inode);
 
 /* super.c */
+void nfs_parse_ip_address(char *, size_t, struct sockaddr *, size_t *);
 extern struct file_system_type nfs_xdev_fs_type;
 #ifdef CONFIG_NFS_V4
 extern struct file_system_type nfs4_xdev_fs_type;
@@ -276,6 +277,7 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 		PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;
 }
 
+#define IPV6_SCOPE_DELIMITER	'%'
 
 /*
  * Set the port number in an address.  Be agnostic about the address
diff --git a/fs/nfs/nfs4namespace.c b/fs/nfs/nfs4namespace.c
index 6bcc5696f911..30befc39b3c6 100644
--- a/fs/nfs/nfs4namespace.c
+++ b/fs/nfs/nfs4namespace.c
@@ -93,50 +93,42 @@ static int nfs4_validate_fspath(const struct vfsmount *mnt_parent,
 	return 0;
 }
 
-/*
- * Check if the string represents a "valid" IPv4 address
- */
-static inline int valid_ipaddr4(const char *buf)
-{
-	int rc, count, in[4];
-
-	rc = sscanf(buf, "%d.%d.%d.%d", &amp;in[0], &amp;in[1], &amp;in[2], &amp;in[3]);
-	if (rc != 4)
-		return -EINVAL;
-	for (count = 0; count &lt; 4; count++) {
-		if (in[count] &gt; 255)
-			return -EINVAL;
-	}
-	return 0;
-}
-
 static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
 				     char *page, char *page2,
 				     const struct nfs4_fs_location *location)
 {
 	struct vfsmount *mnt = ERR_PTR(-ENOENT);
 	char *mnt_path;
+	int page2len;
 	unsigned int s;
 
 	mnt_path = nfs4_pathname_string(&amp;location-&gt;rootpath, page2, PAGE_SIZE);
 	if (IS_ERR(mnt_path))
 		return mnt;
 	mountdata-&gt;mnt_path = mnt_path;
+	page2 += strlen(mnt_path) + 1;
+	page2len = PAGE_SIZE - strlen(mnt_path) - 1;
 
 	for (s = 0; s &lt; location-&gt;nservers; s++) {
-		struct sockaddr_in addr = {
-			.sin_family	= AF_INET,
-			.sin_port	= htons(NFS_PORT),
-		};
+		const struct nfs4_string *buf = &amp;location-&gt;servers[s];
+		struct sockaddr_storage addr;
 
-		if (location-&gt;servers[s].len &lt;= 0 ||
-		    valid_ipaddr4(location-&gt;servers[s].data) &lt; 0)
+		if (buf-&gt;len &lt;= 0 || buf-&gt;len &gt;= PAGE_SIZE)
 			continue;
 
-		mountdata-&gt;hostname = location-&gt;servers[s].data;
-		addr.sin_addr.s_addr = in_aton(mountdata-&gt;hostname),
 		mountdata-&gt;addr = (struct sockaddr *)&amp;addr;
-		mountdata-&gt;addrlen = sizeof(addr);
+
+		if (memchr(buf-&gt;data, IPV6_SCOPE_DELIMITER, buf-&gt;len))
+			continue;
+		nfs_parse_ip_address(buf-&gt;data, buf-&gt;len,
+				mountdata-&gt;addr, &amp;mountdata-&gt;addrlen);
+		if (mountdata-&gt;addr-&gt;sa_family == AF_UNSPEC)
+			continue;
+		nfs_set_port(mountdata-&gt;addr, NFS_PORT);
+
+		strncpy(page2, buf-&gt;data, page2len);
+		page2[page2len] = '\0';
+		mountdata-&gt;hostname = page2;
 
 		snprintf(page, PAGE_SIZE, "%s:%s",
 				mountdata-&gt;hostname,
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index b99096b8e827..20dc4ccdff56 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -716,8 +716,6 @@ static void nfs_parse_ipv4_address(char *string, size_t str_len,
 	*addr_len = 0;
 }
 
-#define IPV6_SCOPE_DELIMITER	'%'
-
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 static void nfs_parse_ipv6_scope_id(const char *string, const size_t str_len,
 				    const char *delim,
@@ -790,7 +788,7 @@ static void nfs_parse_ipv6_address(char *string, size_t str_len,
  * If there is a problem constructing the new sockaddr, set the address
  * family to AF_UNSPEC.
  */
-static void nfs_parse_ip_address(char *string, size_t str_len,
+void nfs_parse_ip_address(char *string, size_t str_len,
 				 struct sockaddr *sap, size_t *addr_len)
 {
 	unsigned int i, colons;</pre><hr><pre>commit f0c929251e01a7a86b6254c775cb6b65c6457f10
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Aug 20 16:10:22 2008 -0400

    nfs: prepare to share nfs_set_port
    
    We plan to use this function elsewhere.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h
index 7bcf6ec2d458..8d91bd88e310 100644
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@ -276,3 +276,23 @@ unsigned int nfs_page_array_len(unsigned int base, size_t len)
 		PAGE_SIZE - 1) &gt;&gt; PAGE_SHIFT;
 }
 
+
+/*
+ * Set the port number in an address.  Be agnostic about the address
+ * family.
+ */
+static inline void nfs_set_port(struct sockaddr *sap, unsigned short port)
+{
+	switch (sap-&gt;sa_family) {
+	case AF_INET: {
+	      struct sockaddr_in *ap = (struct sockaddr_in *)sap;
+	      ap-&gt;sin_port = htons(port);
+	      break;
+	}
+	case AF_INET6: {
+	       struct sockaddr_in6 *ap = (struct sockaddr_in6 *)sap;
+	       ap-&gt;sin6_port = htons(port);
+	       break;
+	}
+	}
+}
diff --git a/fs/nfs/super.c b/fs/nfs/super.c
index 1e3558697219..b99096b8e827 100644
--- a/fs/nfs/super.c
+++ b/fs/nfs/super.c
@@ -674,25 +674,6 @@ static void nfs_umount_begin(struct super_block *sb)
 		rpc_killall_tasks(rpc);
 }
 
-/*
- * Set the port number in an address.  Be agnostic about the address family.
- */
-static void nfs_set_port(struct sockaddr *sap, unsigned short port)
-{
-	switch (sap-&gt;sa_family) {
-	case AF_INET: {
-		struct sockaddr_in *ap = (struct sockaddr_in *)sap;
-		ap-&gt;sin_port = htons(port);
-		break;
-	}
-	case AF_INET6: {
-		struct sockaddr_in6 *ap = (struct sockaddr_in6 *)sap;
-		ap-&gt;sin6_port = htons(port);
-		break;
-	}
-	}
-}
-
 /*
  * Sanity-check a server address provided by the mount command.
  *</pre><hr><pre>commit 460cdbc83268dd9641b57d893b03ef52fcc3f96d
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Aug 20 16:10:21 2008 -0400

    nfs: replace while loop by for loops in nfs_follow_referral
    
    Whoever wrote this had a bizarre allergy to for loops.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/nfs4namespace.c b/fs/nfs/nfs4namespace.c
index 956cbbc2ae9f..6bcc5696f911 100644
--- a/fs/nfs/nfs4namespace.c
+++ b/fs/nfs/nfs4namespace.c
@@ -116,24 +116,22 @@ static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
 {
 	struct vfsmount *mnt = ERR_PTR(-ENOENT);
 	char *mnt_path;
-	unsigned int s = 0;
+	unsigned int s;
 
 	mnt_path = nfs4_pathname_string(&amp;location-&gt;rootpath, page2, PAGE_SIZE);
 	if (IS_ERR(mnt_path))
 		return mnt;
 	mountdata-&gt;mnt_path = mnt_path;
 
-	while (s &lt; location-&gt;nservers) {
+	for (s = 0; s &lt; location-&gt;nservers; s++) {
 		struct sockaddr_in addr = {
 			.sin_family	= AF_INET,
 			.sin_port	= htons(NFS_PORT),
 		};
 
 		if (location-&gt;servers[s].len &lt;= 0 ||
-		    valid_ipaddr4(location-&gt;servers[s].data) &lt; 0) {
-			s++;
+		    valid_ipaddr4(location-&gt;servers[s].data) &lt; 0)
 			continue;
-		}
 
 		mountdata-&gt;hostname = location-&gt;servers[s].data;
 		addr.sin_addr.s_addr = in_aton(mountdata-&gt;hostname),
@@ -147,7 +145,6 @@ static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
 		mnt = vfs_kern_mount(&amp;nfs4_referral_fs_type, 0, page, mountdata);
 		if (!IS_ERR(mnt))
 			break;
-		s++;
 	}
 	return mnt;
 }
@@ -193,20 +190,16 @@ static struct vfsmount *nfs_follow_referral(const struct vfsmount *mnt_parent,
 		goto out;
 	}
 
-	loc = 0;
-	while (loc &lt; locations-&gt;nlocations) {
+	for (loc = 0; loc &lt; locations-&gt;nlocations; loc++) {
 		const struct nfs4_fs_location *location = &amp;locations-&gt;locations[loc];
 
 		if (location == NULL || location-&gt;nservers &lt;= 0 ||
-		    location-&gt;rootpath.ncomponents == 0) {
-			loc++;
+		    location-&gt;rootpath.ncomponents == 0)
 			continue;
-		}
 
 		mnt = try_location(&amp;mountdata, page, page2, location);
 		if (!IS_ERR(mnt))
 			break;
-		loc++;
 	}
 
 out:</pre><hr><pre>commit 4ada29d5c4dd2d3ba89510bdbc64be22961fd1cb
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Aug 20 16:10:20 2008 -0400

    nfs: break up nfs_follow_referral
    
    This function is a little longer and more deeply nested than necessary.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/nfs4namespace.c b/fs/nfs/nfs4namespace.c
index b112857301f7..956cbbc2ae9f 100644
--- a/fs/nfs/nfs4namespace.c
+++ b/fs/nfs/nfs4namespace.c
@@ -110,6 +110,48 @@ static inline int valid_ipaddr4(const char *buf)
 	return 0;
 }
 
+static struct vfsmount *try_location(struct nfs_clone_mount *mountdata,
+				     char *page, char *page2,
+				     const struct nfs4_fs_location *location)
+{
+	struct vfsmount *mnt = ERR_PTR(-ENOENT);
+	char *mnt_path;
+	unsigned int s = 0;
+
+	mnt_path = nfs4_pathname_string(&amp;location-&gt;rootpath, page2, PAGE_SIZE);
+	if (IS_ERR(mnt_path))
+		return mnt;
+	mountdata-&gt;mnt_path = mnt_path;
+
+	while (s &lt; location-&gt;nservers) {
+		struct sockaddr_in addr = {
+			.sin_family	= AF_INET,
+			.sin_port	= htons(NFS_PORT),
+		};
+
+		if (location-&gt;servers[s].len &lt;= 0 ||
+		    valid_ipaddr4(location-&gt;servers[s].data) &lt; 0) {
+			s++;
+			continue;
+		}
+
+		mountdata-&gt;hostname = location-&gt;servers[s].data;
+		addr.sin_addr.s_addr = in_aton(mountdata-&gt;hostname),
+		mountdata-&gt;addr = (struct sockaddr *)&amp;addr;
+		mountdata-&gt;addrlen = sizeof(addr);
+
+		snprintf(page, PAGE_SIZE, "%s:%s",
+				mountdata-&gt;hostname,
+				mountdata-&gt;mnt_path);
+
+		mnt = vfs_kern_mount(&amp;nfs4_referral_fs_type, 0, page, mountdata);
+		if (!IS_ERR(mnt))
+			break;
+		s++;
+	}
+	return mnt;
+}
+
 /**
  * nfs_follow_referral - set up mountpoint when hitting a referral on moved error
  * @mnt_parent - mountpoint of parent directory
@@ -128,7 +170,6 @@ static struct vfsmount *nfs_follow_referral(const struct vfsmount *mnt_parent,
 		.authflavor = NFS_SB(mnt_parent-&gt;mnt_sb)-&gt;client-&gt;cl_auth-&gt;au_flavor,
 	};
 	char *page = NULL, *page2 = NULL;
-	unsigned int s;
 	int loc, error;
 
 	if (locations == NULL || locations-&gt;nlocations &lt;= 0)
@@ -153,9 +194,8 @@ static struct vfsmount *nfs_follow_referral(const struct vfsmount *mnt_parent,
 	}
 
 	loc = 0;
-	while (loc &lt; locations-&gt;nlocations &amp;&amp; IS_ERR(mnt)) {
+	while (loc &lt; locations-&gt;nlocations) {
 		const struct nfs4_fs_location *location = &amp;locations-&gt;locations[loc];
-		char *mnt_path;
 
 		if (location == NULL || location-&gt;nservers &lt;= 0 ||
 		    location-&gt;rootpath.ncomponents == 0) {
@@ -163,41 +203,9 @@ static struct vfsmount *nfs_follow_referral(const struct vfsmount *mnt_parent,
 			continue;
 		}
 
-		mnt_path = nfs4_pathname_string(&amp;location-&gt;rootpath, page2, PAGE_SIZE);
-		if (IS_ERR(mnt_path)) {
-			loc++;
-			continue;
-		}
-		mountdata.mnt_path = mnt_path;
-
-		s = 0;
-		while (s &lt; location-&gt;nservers) {
-			struct sockaddr_in addr = {
-				.sin_family	= AF_INET,
-				.sin_port	= htons(NFS_PORT),
-			};
-
-			if (location-&gt;servers[s].len &lt;= 0 ||
-			    valid_ipaddr4(location-&gt;servers[s].data) &lt; 0) {
-				s++;
-				continue;
-			}
-
-			mountdata.hostname = location-&gt;servers[s].data;
-			addr.sin_addr.s_addr = in_aton(mountdata.hostname),
-			mountdata.addr = (struct sockaddr *)&amp;addr;
-			mountdata.addrlen = sizeof(addr);
-
-			snprintf(page, PAGE_SIZE, "%s:%s",
-					mountdata.hostname,
-					mountdata.mnt_path);
-
-			mnt = vfs_kern_mount(&amp;nfs4_referral_fs_type, 0, page, &amp;mountdata);
-			if (!IS_ERR(mnt)) {
-				break;
-			}
-			s++;
-		}
+		mnt = try_location(&amp;mountdata, page, page2, location);
+		if (!IS_ERR(mnt))
+			break;
 		loc++;
 	}
 </pre><hr><pre>commit f200c11c257b8db5c49dfc0b7f84bceae3109779
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Aug 14 18:32:55 2008 -0400

    nfs: remove an obsolete nfs_flock comment
    
    We *do* now allow bsd flocks over nfs.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/file.c b/fs/nfs/file.c
index 3ddb00433f4f..d319b49f8f06 100644
--- a/fs/nfs/file.c
+++ b/fs/nfs/file.c
@@ -702,13 +702,6 @@ static int nfs_flock(struct file *filp, int cmd, struct file_lock *fl)
 			filp-&gt;f_path.dentry-&gt;d_name.name,
 			fl-&gt;fl_type, fl-&gt;fl_flags);
 
-	/*
-	 * No BSD flocks over NFS allowed.
-	 * Note: we could try to fake a POSIX lock request here by
-	 * using ((u32) filp | 0x80000000) or some such as the pid.
-	 * Not sure whether that would be unique, though, or whether
-	 * that would break in other places.
-	 */
 	if (!(fl-&gt;fl_flags &amp; FL_FLOCK))
 		return -ENOLCK;
 </pre><hr><pre>commit d22b1cff099737f74f3ac5950094508b4cddec1e
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Feb 6 15:05:12 2008 -0500

    lockd: reject reclaims outside the grace period
    
    The current lockd does not reject reclaims that arrive outside of the
    grace period.
    
    Accepting a reclaim means promising to the client that no conflicting
    locks were granted since last it held the lock.  We can meet that
    promise if we assume the only lockers are nfs clients, and that they are
    sufficiently well-behaved to reclaim only locks that they held before,
    and that only reclaim locks have been permitted so far.  Once we leave
    the grace period (and start permitting non-reclaims), we can no longer
    keep that promise.  So we must start rejecting reclaims at that point.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.c
index 808d246ada4d..6063a8e4b9f3 100644
--- a/fs/lockd/svclock.c
+++ b/fs/lockd/svclock.c
@@ -410,6 +410,10 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 		ret = nlm_lck_denied_grace_period;
 		goto out;
 	}
+	if (reclaim &amp;&amp; !locks_in_grace()) {
+		ret = nlm_lck_denied_grace_period;
+		goto out;
+	}
 
 	if (!wait)
 		lock-&gt;fl.fl_flags &amp;= ~FL_SLEEP;</pre><hr><pre>commit b2b5028905226f85075a408b1118857c9aa48bb3
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Feb 6 13:59:23 2008 -0500

    lockd: move grace period checks to common code
    
    Do all the grace period checks in svclock.c.  This simplifies the code a
    bit, and will ease some later changes.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/lockd/svc4proc.c b/fs/lockd/svc4proc.c
index 7ca617367b3e..f6f18fa5cf8b 100644
--- a/fs/lockd/svc4proc.c
+++ b/fs/lockd/svc4proc.c
@@ -88,12 +88,6 @@ nlm4svc_proc_test(struct svc_rqst *rqstp, struct nlm_args *argp,
 	dprintk("lockd: TEST4        called\n");
 	resp-&gt;cookie = argp-&gt;cookie;
 
-	/* Don't accept test requests during grace period */
-	if (locks_in_grace()) {
-		resp-&gt;status = nlm_lck_denied_grace_period;
-		return rc;
-	}
-
 	/* Obtain client and file */
 	if ((resp-&gt;status = nlm4svc_retrieve_args(rqstp, argp, &amp;host, &amp;file)))
 		return resp-&gt;status == nlm_drop_reply ? rpc_drop_reply :rpc_success;
@@ -122,12 +116,6 @@ nlm4svc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,
 
 	resp-&gt;cookie = argp-&gt;cookie;
 
-	/* Don't accept new lock requests during grace period */
-	if (locks_in_grace() &amp;&amp; !argp-&gt;reclaim) {
-		resp-&gt;status = nlm_lck_denied_grace_period;
-		return rc;
-	}
-
 	/* Obtain client and file */
 	if ((resp-&gt;status = nlm4svc_retrieve_args(rqstp, argp, &amp;host, &amp;file)))
 		return resp-&gt;status == nlm_drop_reply ? rpc_drop_reply :rpc_success;
@@ -146,7 +134,8 @@ nlm4svc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,
 
 	/* Now try to lock the file */
 	resp-&gt;status = nlmsvc_lock(rqstp, file, host, &amp;argp-&gt;lock,
-					argp-&gt;block, &amp;argp-&gt;cookie);
+					argp-&gt;block, &amp;argp-&gt;cookie,
+					argp-&gt;reclaim);
 	if (resp-&gt;status == nlm_drop_reply)
 		rc = rpc_drop_reply;
 	else
diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.c
index cf0d5c2c318d..808d246ada4d 100644
--- a/fs/lockd/svclock.c
+++ b/fs/lockd/svclock.c
@@ -360,7 +360,7 @@ nlmsvc_defer_lock_rqst(struct svc_rqst *rqstp, struct nlm_block *block)
 __be32
 nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 	    struct nlm_host *host, struct nlm_lock *lock, int wait,
-	    struct nlm_cookie *cookie)
+	    struct nlm_cookie *cookie, int reclaim)
 {
 	struct nlm_block	*block = NULL;
 	int			error;
@@ -406,6 +406,11 @@ nlmsvc_lock(struct svc_rqst *rqstp, struct nlm_file *file,
 		goto out;
 	}
 
+	if (locks_in_grace() &amp;&amp; !reclaim) {
+		ret = nlm_lck_denied_grace_period;
+		goto out;
+	}
+
 	if (!wait)
 		lock-&gt;fl.fl_flags &amp;= ~FL_SLEEP;
 	error = vfs_lock_file(file-&gt;f_file, F_SETLK, &amp;lock-&gt;fl, NULL);
@@ -502,6 +507,10 @@ nlmsvc_testlock(struct svc_rqst *rqstp, struct nlm_file *file,
 		goto out;
 	}
 
+	if (locks_in_grace()) {
+		ret = nlm_lck_denied_grace_period;
+		goto out;
+	}
 	error = vfs_test_lock(file-&gt;f_file, &amp;lock-&gt;fl);
 	if (error == FILE_LOCK_DEFERRED) {
 		ret = nlmsvc_defer_lock_rqst(rqstp, block);
@@ -582,6 +591,9 @@ nlmsvc_cancel_blocked(struct nlm_file *file, struct nlm_lock *lock)
 				(long long)lock-&gt;fl.fl_start,
 				(long long)lock-&gt;fl.fl_end);
 
+	if (locks_in_grace())
+		return nlm_lck_denied_grace_period;
+
 	mutex_lock(&amp;file-&gt;f_mutex);
 	block = nlmsvc_lookup_block(file, lock);
 	mutex_unlock(&amp;file-&gt;f_mutex);
diff --git a/fs/lockd/svcproc.c b/fs/lockd/svcproc.c
index 1b013e198804..a587b81338b1 100644
--- a/fs/lockd/svcproc.c
+++ b/fs/lockd/svcproc.c
@@ -117,12 +117,6 @@ nlmsvc_proc_test(struct svc_rqst *rqstp, struct nlm_args *argp,
 	dprintk("lockd: TEST          called\n");
 	resp-&gt;cookie = argp-&gt;cookie;
 
-	/* Don't accept test requests during grace period */
-	if (locks_in_grace()) {
-		resp-&gt;status = nlm_lck_denied_grace_period;
-		return rc;
-	}
-
 	/* Obtain client and file */
 	if ((resp-&gt;status = nlmsvc_retrieve_args(rqstp, argp, &amp;host, &amp;file)))
 		return resp-&gt;status == nlm_drop_reply ? rpc_drop_reply :rpc_success;
@@ -152,12 +146,6 @@ nlmsvc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,
 
 	resp-&gt;cookie = argp-&gt;cookie;
 
-	/* Don't accept new lock requests during grace period */
-	if (locks_in_grace() &amp;&amp; !argp-&gt;reclaim) {
-		resp-&gt;status = nlm_lck_denied_grace_period;
-		return rc;
-	}
-
 	/* Obtain client and file */
 	if ((resp-&gt;status = nlmsvc_retrieve_args(rqstp, argp, &amp;host, &amp;file)))
 		return resp-&gt;status == nlm_drop_reply ? rpc_drop_reply :rpc_success;
@@ -176,7 +164,8 @@ nlmsvc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,
 
 	/* Now try to lock the file */
 	resp-&gt;status = cast_status(nlmsvc_lock(rqstp, file, host, &amp;argp-&gt;lock,
-					       argp-&gt;block, &amp;argp-&gt;cookie));
+					       argp-&gt;block, &amp;argp-&gt;cookie,
+					       argp-&gt;reclaim));
 	if (resp-&gt;status == nlm_drop_reply)
 		rc = rpc_drop_reply;
 	else
diff --git a/include/linux/lockd/lockd.h b/include/linux/lockd/lockd.h
index ec8af115843d..973ab1d6e862 100644
--- a/include/linux/lockd/lockd.h
+++ b/include/linux/lockd/lockd.h
@@ -242,7 +242,7 @@ typedef int	  (*nlm_host_match_fn_t)(void *cur, struct nlm_host *ref);
  */
 __be32		  nlmsvc_lock(struct svc_rqst *, struct nlm_file *,
 			      struct nlm_host *, struct nlm_lock *, int,
-			      struct nlm_cookie *);
+			      struct nlm_cookie *, int);
 __be32		  nlmsvc_unlock(struct nlm_file *, struct nlm_lock *);
 __be32		  nlmsvc_testlock(struct svc_rqst *, struct nlm_file *,
 			struct nlm_host *, struct nlm_lock *,</pre><hr><pre>commit af558e33bedab672f5cfd3260bce7445e353fe21
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Sep 6 12:34:25 2007 -0400

    nfsd: common grace period control
    
    Rewrite grace period code to unify management of grace period across
    lockd and nfsd.  The current code has lockd and nfsd cooperate to
    compute a grace period which is satisfactory to them both, and then
    individually enforce it.  This creates a slight race condition, since
    the enforcement is not coordinated.  It's also more complicated than
    necessary.
    
    Here instead we have lockd and nfsd each inform common code when they
    enter the grace period, and when they're ready to leave the grace
    period, and allow normal locking only after both of them are ready to
    leave.
    
    We also expect the locks_start_grace()/locks_end_grace() interface here
    to be simpler to build on for future cluster/high-availability work,
    which may require (for example) putting individual filesystems into
    grace, or enforcing grace periods across multiple cluster nodes.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/lockd/Makefile b/fs/lockd/Makefile
index 7725a0a9a555..97f6073ab339 100644
--- a/fs/lockd/Makefile
+++ b/fs/lockd/Makefile
@@ -5,6 +5,6 @@
 obj-$(CONFIG_LOCKD) += lockd.o
 
 lockd-objs-y := clntlock.o clntproc.o host.o svc.o svclock.o svcshare.o \
-	        svcproc.o svcsubs.o mon.o xdr.o
+	        svcproc.o svcsubs.o mon.o xdr.o grace.o
 lockd-objs-$(CONFIG_LOCKD_V4) += xdr4.o svc4proc.o
 lockd-objs		      := $(lockd-objs-y)
diff --git a/fs/lockd/grace.c b/fs/lockd/grace.c
new file mode 100644
index 000000000000..183cc1f0af1c
--- /dev/null
+++ b/fs/lockd/grace.c
@@ -0,0 +1,59 @@
+/*
+ * Common code for control of lockd and nfsv4 grace periods.
+ */
+
+#include &lt;linux/module.h&gt;
+#include &lt;linux/lockd/bind.h&gt;
+
+static LIST_HEAD(grace_list);
+static DEFINE_SPINLOCK(grace_lock);
+
+/**
+ * locks_start_grace
+ * @lm: who this grace period is for
+ *
+ * A grace period is a period during which locks should not be given
+ * out.  Currently grace periods are only enforced by the two lock
+ * managers (lockd and nfsd), using the locks_in_grace() function to
+ * check when they are in a grace period.
+ *
+ * This function is called to start a grace period.
+ */
+void locks_start_grace(struct lock_manager *lm)
+{
+	spin_lock(&amp;grace_lock);
+	list_add(&amp;lm-&gt;list, &amp;grace_list);
+	spin_unlock(&amp;grace_lock);
+}
+EXPORT_SYMBOL_GPL(locks_start_grace);
+
+/**
+ * locks_end_grace
+ * @lm: who this grace period is for
+ *
+ * Call this function to state that the given lock manager is ready to
+ * resume regular locking.  The grace period will not end until all lock
+ * managers that called locks_start_grace() also call locks_end_grace().
+ * Note that callers count on it being safe to call this more than once,
+ * and the second call should be a no-op.
+ */
+void locks_end_grace(struct lock_manager *lm)
+{
+	spin_lock(&amp;grace_lock);
+	list_del_init(&amp;lm-&gt;list);
+	spin_unlock(&amp;grace_lock);
+}
+EXPORT_SYMBOL_GPL(locks_end_grace);
+
+/**
+ * locks_in_grace
+ *
+ * Lock managers call this function to determine when it is OK for them
+ * to answer ordinary lock requests, and when they should accept only
+ * lock reclaims.
+ */
+int locks_in_grace(void)
+{
+	return !list_empty(&amp;grace_list);
+}
+EXPORT_SYMBOL_GPL(locks_in_grace);
diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c
index f345ef7fb8ae..f013aed11533 100644
--- a/fs/lockd/svc.c
+++ b/fs/lockd/svc.c
@@ -51,7 +51,6 @@ static DEFINE_MUTEX(nlmsvc_mutex);
 static unsigned int		nlmsvc_users;
 static struct task_struct	*nlmsvc_task;
 static struct svc_rqst		*nlmsvc_rqst;
-int				nlmsvc_grace_period;
 unsigned long			nlmsvc_timeout;
 
 /*
@@ -85,30 +84,21 @@ static unsigned long get_lockd_grace_period(void)
 		return nlm_timeout * 5 * HZ;
 }
 
-unsigned long get_nfs_grace_period(void)
-{
-	unsigned long lockdgrace = get_lockd_grace_period();
-	unsigned long nfsdgrace = 0;
-
-	if (nlmsvc_ops)
-		nfsdgrace = nlmsvc_ops-&gt;get_grace_period();
-
-	return max(lockdgrace, nfsdgrace);
-}
-EXPORT_SYMBOL(get_nfs_grace_period);
+static struct lock_manager lockd_manager = {
+};
 
 static void grace_ender(struct work_struct *not_used)
 {
-	nlmsvc_grace_period = 0;
+	locks_end_grace(&amp;lockd_manager);
 }
 
 static DECLARE_DELAYED_WORK(grace_period_end, grace_ender);
 
 static void set_grace_period(void)
 {
-	unsigned long grace_period = get_nfs_grace_period() + jiffies;
+	unsigned long grace_period = get_lockd_grace_period();
 
-	nlmsvc_grace_period = 1;
+	locks_start_grace(&amp;lockd_manager);
 	cancel_delayed_work_sync(&amp;grace_period_end);
 	schedule_delayed_work(&amp;grace_period_end, grace_period);
 }
diff --git a/fs/lockd/svc4proc.c b/fs/lockd/svc4proc.c
index 4a714f64515b..7ca617367b3e 100644
--- a/fs/lockd/svc4proc.c
+++ b/fs/lockd/svc4proc.c
@@ -89,7 +89,7 @@ nlm4svc_proc_test(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept test requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rc;
 	}
@@ -123,7 +123,7 @@ nlm4svc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept new lock requests during grace period */
-	if (nlmsvc_grace_period &amp;&amp; !argp-&gt;reclaim) {
+	if (locks_in_grace() &amp;&amp; !argp-&gt;reclaim) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rc;
 	}
@@ -169,7 +169,7 @@ nlm4svc_proc_cancel(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
@@ -202,7 +202,7 @@ nlm4svc_proc_unlock(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept new lock requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
@@ -341,7 +341,7 @@ nlm4svc_proc_share(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept new lock requests during grace period */
-	if (nlmsvc_grace_period &amp;&amp; !argp-&gt;reclaim) {
+	if (locks_in_grace() &amp;&amp; !argp-&gt;reclaim) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
@@ -374,7 +374,7 @@ nlm4svc_proc_unshare(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
diff --git a/fs/lockd/svcproc.c b/fs/lockd/svcproc.c
index 76262c1986f2..1b013e198804 100644
--- a/fs/lockd/svcproc.c
+++ b/fs/lockd/svcproc.c
@@ -118,7 +118,7 @@ nlmsvc_proc_test(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept test requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rc;
 	}
@@ -153,7 +153,7 @@ nlmsvc_proc_lock(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept new lock requests during grace period */
-	if (nlmsvc_grace_period &amp;&amp; !argp-&gt;reclaim) {
+	if (locks_in_grace() &amp;&amp; !argp-&gt;reclaim) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rc;
 	}
@@ -199,7 +199,7 @@ nlmsvc_proc_cancel(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
@@ -232,7 +232,7 @@ nlmsvc_proc_unlock(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept new lock requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
@@ -373,7 +373,7 @@ nlmsvc_proc_share(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept new lock requests during grace period */
-	if (nlmsvc_grace_period &amp;&amp; !argp-&gt;reclaim) {
+	if (locks_in_grace() &amp;&amp; !argp-&gt;reclaim) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
@@ -406,7 +406,7 @@ nlmsvc_proc_unshare(struct svc_rqst *rqstp, struct nlm_args *argp,
 	resp-&gt;cookie = argp-&gt;cookie;
 
 	/* Don't accept requests during grace period */
-	if (nlmsvc_grace_period) {
+	if (locks_in_grace()) {
 		resp-&gt;status = nlm_lck_denied_grace_period;
 		return rpc_success;
 	}
diff --git a/fs/nfsd/lockd.c b/fs/nfsd/lockd.c
index 15c6faeec77c..b2786a5f9afe 100644
--- a/fs/nfsd/lockd.c
+++ b/fs/nfsd/lockd.c
@@ -70,7 +70,6 @@ nlm_fclose(struct file *filp)
 static struct nlmsvc_binding	nfsd_nlm_ops = {
 	.fopen		= nlm_fopen,		/* open file for locking */
 	.fclose		= nlm_fclose,		/* close file */
-	.get_grace_period = get_nfs4_grace_period,
 };
 
 void
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index e5b51ffafc6c..669461e291ae 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -201,10 +201,10 @@ nfsd4_open(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	/* Openowner is now set, so sequence id will get bumped.  Now we need
 	 * these checks before we do any creates: */
 	status = nfserr_grace;
-	if (nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)
+	if (locks_in_grace() &amp;&amp; open-&gt;op_claim_type != NFS4_OPEN_CLAIM_PREVIOUS)
 		goto out;
 	status = nfserr_no_grace;
-	if (!nfs4_in_grace() &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
+	if (!locks_in_grace() &amp;&amp; open-&gt;op_claim_type == NFS4_OPEN_CLAIM_PREVIOUS)
 		goto out;
 
 	switch (open-&gt;op_claim_type) {
@@ -575,7 +575,7 @@ nfsd4_remove(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 {
 	__be32 status;
 
-	if (nfs4_in_grace())
+	if (locks_in_grace())
 		return nfserr_grace;
 	status = nfsd_unlink(rqstp, &amp;cstate-&gt;current_fh, 0,
 			     remove-&gt;rm_name, remove-&gt;rm_namelen);
@@ -596,7 +596,7 @@ nfsd4_rename(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 
 	if (!cstate-&gt;save_fh.fh_dentry)
 		return status;
-	if (nfs4_in_grace() &amp;&amp; !(cstate-&gt;save_fh.fh_export-&gt;ex_flags
+	if (locks_in_grace() &amp;&amp; !(cstate-&gt;save_fh.fh_export-&gt;ex_flags
 					&amp; NFSEXP_NOSUBTREECHECK))
 		return nfserr_grace;
 	status = nfsd_rename(rqstp, &amp;cstate-&gt;save_fh, rename-&gt;rn_sname,
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 1578d7a2667e..0cc7ff5d5ab5 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -61,7 +61,6 @@
 static time_t lease_time = 90;     /* default lease time */
 static time_t user_lease_time = 90;
 static time_t boot_time;
-static int in_grace = 1;
 static u32 current_ownerid = 1;
 static u32 current_fileid = 1;
 static u32 current_delegid = 1;
@@ -1640,7 +1639,7 @@ nfs4_open_delegation(struct svc_fh *fh, struct nfsd4_open *open, struct nfs4_sta
 		case NFS4_OPEN_CLAIM_NULL:
 			/* Let's not give out any delegations till everyone's
 			 * had the chance to reclaim theirs.... */
-			if (nfs4_in_grace())
+			if (locks_in_grace())
 				goto out;
 			if (!atomic_read(&amp;cb-&gt;cb_set) || !sop-&gt;so_confirmed)
 				goto out;
@@ -1816,12 +1815,15 @@ nfsd4_renew(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	return status;
 }
 
+struct lock_manager nfsd4_manager = {
+};
+
 static void
-end_grace(void)
+nfsd4_end_grace(void)
 {
 	dprintk("NFSD: end of grace period\n");
 	nfsd4_recdir_purge_old();
-	in_grace = 0;
+	locks_end_grace(&amp;nfsd4_manager);
 }
 
 static time_t
@@ -1838,8 +1840,8 @@ nfs4_laundromat(void)
 	nfs4_lock_state();
 
 	dprintk("NFSD: laundromat service - starting\n");
-	if (in_grace)
-		end_grace();
+	if (locks_in_grace())
+		nfsd4_end_grace();
 	list_for_each_safe(pos, next, &amp;client_lru) {
 		clp = list_entry(pos, struct nfs4_client, cl_lru);
 		if (time_after((unsigned long)clp-&gt;cl_time, (unsigned long)cutoff)) {
@@ -1974,7 +1976,7 @@ check_special_stateids(svc_fh *current_fh, stateid_t *stateid, int flags)
 		return nfserr_bad_stateid;
 	else if (ONE_STATEID(stateid) &amp;&amp; (flags &amp; RD_STATE))
 		return nfs_ok;
-	else if (nfs4_in_grace()) {
+	else if (locks_in_grace()) {
 		/* Answer in remaining cases depends on existance of
 		 * conflicting state; so we must wait out the grace period. */
 		return nfserr_grace;
@@ -1993,7 +1995,7 @@ check_special_stateids(svc_fh *current_fh, stateid_t *stateid, int flags)
 static inline int
 io_during_grace_disallowed(struct inode *inode, int flags)
 {
-	return nfs4_in_grace() &amp;&amp; (flags &amp; (RD_STATE | WR_STATE))
+	return locks_in_grace() &amp;&amp; (flags &amp; (RD_STATE | WR_STATE))
 		&amp;&amp; mandatory_lock(inode);
 }
 
@@ -2693,10 +2695,10 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	filp = lock_stp-&gt;st_vfs_file;
 
 	status = nfserr_grace;
-	if (nfs4_in_grace() &amp;&amp; !lock-&gt;lk_reclaim)
+	if (locks_in_grace() &amp;&amp; !lock-&gt;lk_reclaim)
 		goto out;
 	status = nfserr_no_grace;
-	if (!nfs4_in_grace() &amp;&amp; lock-&gt;lk_reclaim)
+	if (!locks_in_grace() &amp;&amp; lock-&gt;lk_reclaim)
 		goto out;
 
 	locks_init_lock(&amp;file_lock);
@@ -2779,7 +2781,7 @@ nfsd4_lockt(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	int error;
 	__be32 status;
 
-	if (nfs4_in_grace())
+	if (locks_in_grace())
 		return nfserr_grace;
 
 	if (check_lock_length(lockt-&gt;lt_offset, lockt-&gt;lt_length))
@@ -3192,9 +3194,9 @@ __nfs4_state_start(void)
 	unsigned long grace_time;
 
 	boot_time = get_seconds();
-	grace_time = get_nfs_grace_period();
+	grace_time = get_nfs4_grace_period();
 	lease_time = user_lease_time;
-	in_grace = 1;
+	locks_start_grace(&amp;nfsd4_manager);
 	printk(KERN_INFO "NFSD: starting %ld-second grace period\n",
 	       grace_time/HZ);
 	laundry_wq = create_singlethread_workqueue("nfsd4");
@@ -3213,12 +3215,6 @@ nfs4_state_start(void)
 	return;
 }
 
-int
-nfs4_in_grace(void)
-{
-	return in_grace;
-}
-
 time_t
 nfs4_lease_time(void)
 {
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9f540165a078..27cfa723b92a 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -942,6 +942,14 @@ struct lock_manager_operations {
 	int (*fl_change)(struct file_lock **, int);
 };
 
+struct lock_manager {
+	struct list_head list;
+};
+
+void locks_start_grace(struct lock_manager *);
+void locks_end_grace(struct lock_manager *);
+int locks_in_grace(void);
+
 /* that will die - we need it for nfs_lock_info */
 #include &lt;linux/nfs_fs_i.h&gt;
 
diff --git a/include/linux/lockd/bind.h b/include/linux/lockd/bind.h
index 3d25bcd139d1..1f0465c374dc 100644
--- a/include/linux/lockd/bind.h
+++ b/include/linux/lockd/bind.h
@@ -27,7 +27,6 @@ struct nlmsvc_binding {
 						struct nfs_fh *,
 						struct file **);
 	void			(*fclose)(struct file *);
-	unsigned long		(*get_grace_period)(void);
 };
 
 extern struct nlmsvc_binding *	nlmsvc_ops;
@@ -56,12 +55,4 @@ extern int	nlmclnt_proc(struct nlm_host *host, int cmd,
 extern int	lockd_up(int proto);
 extern void	lockd_down(void);
 
-unsigned long get_nfs_grace_period(void);
-
-#ifdef CONFIG_NFSD_V4
-unsigned long get_nfs4_grace_period(void);
-#else
-static inline unsigned long get_nfs4_grace_period(void) {return 0;}
-#endif
-
 #endif /* LINUX_LOCKD_BIND_H */</pre>
    <div class="pagination">
        <a href='4_28.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><span>[29]</span><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_30.html'>Next&gt;&gt;</a>
    <div>
</body>
