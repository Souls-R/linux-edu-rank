<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_106.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><span>[107]</span><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_108.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 54515fe528d8c6f9bfaf7d0b9fffb908deecad78
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:38:58 2007 -0400

    USB: unify reset_resume and normal resume
    
    This patch (as919) unifies the code paths used for normal resume and
    for reset-resume.  Earlier I had failed to note a section in the USB
    spec which requires the host to resume a suspended port before
    resetting it if the attached device is enabled for remote wakeup.
    Since the port has to be resumed anyway, we might as well reuse the
    existing code.
    
    The main changes are:
    
            usb_reset_suspended_device() is eliminated.
    
            usb_root_hub_lost_power() is moved down next to the
            hub_reset_resume() routine, to which it is logically
            related.
    
            finish_port_resume() does a port reset() if the device's
            reset_resume flag is set.
    
            usb_port_resume() doesn't check whether the port is initially
            enabled if this is a USB-Persist sort of resume.
    
            Code to perform the port reset is added to the resume pathway
            for the non-CONFIG_USB_SUSPEND case.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 4cbe7b339513..b2fc2b115256 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -219,8 +219,6 @@ static int generic_resume(struct usb_device *udev)
 	 */
 	if (!udev-&gt;parent)
 		rc = hcd_bus_resume(udev);
-	else if (udev-&gt;reset_resume)
-		rc = usb_reset_suspended_device(udev);
 	else
 		rc = usb_port_resume(udev);
 	return rc;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0b8ed414d5cf..c4cdb69a6e9e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -31,6 +31,12 @@
 #include "hcd.h"
 #include "hub.h"
 
+#ifdef	CONFIG_USB_PERSIST
+#define	USB_PERSIST	1
+#else
+#define	USB_PERSIST	0
+#endif
+
 struct usb_hub {
 	struct device		*intfdev;	/* the "interface" device */
 	struct usb_device	*hdev;
@@ -1080,72 +1086,6 @@ void usb_set_device_state(struct usb_device *udev,
 	spin_unlock_irqrestore(&amp;device_state_lock, flags);
 }
 
-
-#ifdef	CONFIG_PM
-
-/**
- * usb_reset_suspended_device - reset a suspended device instead of resuming it
- * @udev: device to be reset instead of resumed
- *
- * If a host controller doesn't maintain VBUS suspend current during a
- * system sleep or is reset when the system wakes up, all the USB
- * power sessions below it will be broken.  This is especially troublesome
- * for mass-storage devices containing mounted filesystems, since the
- * device will appear to have disconnected and all the memory mappings
- * to it will be lost.
- *
- * As an alternative, this routine attempts to recover power sessions for
- * devices that are still present by resetting them instead of resuming
- * them.  If all goes well, the devices will appear to persist across the
- * the interruption of the power sessions.
- *
- * This facility is inherently dangerous.  Although usb_reset_device()
- * makes every effort to insure that the same device is present after the
- * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
- * quite possible for a device to remain unaltered but its media to be
- * changed.  If the user replaces a flash memory card while the system is
- * asleep, he will have only himself to blame when the filesystem on the
- * new card is corrupted and the system crashes.
- */
-int usb_reset_suspended_device(struct usb_device *udev)
-{
-	int rc = 0;
-
-	dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "reset-");
-
-	/* After we're done the device won't be suspended any more.
-	 * In addition, the reset won't work if udev-&gt;state is SUSPENDED.
-	 */
-	usb_set_device_state(udev, udev-&gt;actconfig
-			? USB_STATE_CONFIGURED
-			: USB_STATE_ADDRESS);
-
-	/* Root hubs don't need to be (and can't be) reset */
-	if (udev-&gt;parent)
-		rc = usb_reset_device(udev);
-	return rc;
-}
-
-/**
- * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
- * @rhdev: struct usb_device for the root hub
- *
- * The USB host controller driver calls this function when its root hub
- * is resumed and Vbus power has been interrupted or the controller
- * has been reset.  The routine marks @rhdev as having lost power.  When
- * the hub driver is resumed it will take notice; if CONFIG_USB_PERSIST
- * is enabled then it will carry out power-session recovery, otherwise
- * it will disconnect all the child devices.
- */
-void usb_root_hub_lost_power(struct usb_device *rhdev)
-{
-	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
-	rhdev-&gt;reset_resume = 1;
-}
-EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
-
-#endif	/* CONFIG_PM */
-
 static void choose_address(struct usb_device *udev)
 {
 	int		devnum;
@@ -1672,18 +1612,22 @@ int usb_port_suspend(struct usb_device *udev)
 /*
  * If the USB "suspend" state is in use (rather than "global suspend"),
  * many devices will be individually taken out of suspend state using
- * special" resume" signaling.  These routines kick in shortly after
+ * special "resume" signaling.  This routine kicks in shortly after
  * hardware resume signaling is finished, either because of selective
  * resume (by host) or remote wakeup (by device) ... now see what changed
  * in the tree that's rooted at this device.
+ *
+ * If @udev-&gt;reset_resume is set then the device is reset before the
+ * status check is done.
  */
 static int finish_port_resume(struct usb_device *udev)
 {
-	int	status;
+	int	status = 0;
 	u16	devstatus;
 
 	/* caller owns the udev device lock */
-	dev_dbg(&amp;udev-&gt;dev, "finish resume\n");
+	dev_dbg(&amp;udev-&gt;dev, "finish %sresume\n",
+			udev-&gt;reset_resume ? "reset-" : "");
 
 	/* usb ch9 identifies four variants of SUSPENDED, based on what
 	 * state the device resumes to.  Linux currently won't see the
@@ -1694,13 +1638,23 @@ static int finish_port_resume(struct usb_device *udev)
 			? USB_STATE_CONFIGURED
 			: USB_STATE_ADDRESS);
 
+	/* 10.5.4.5 says not to reset a suspended port if the attached
+	 * device is enabled for remote wakeup.  Hence the reset
+	 * operation is carried out here, after the port has been
+	 * resumed.
+	 */
+	if (udev-&gt;reset_resume)
+		status = usb_reset_device(udev);
+
  	/* 10.5.4.5 says be sure devices in the tree are still there.
  	 * For now let's assume the device didn't go crazy on resume,
 	 * and device drivers will know about any resume quirks.
 	 */
-	status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-	if (status &gt;= 0)
-		status = (status == 2 ? 0 : -ENODEV);
+	if (status == 0) {
+		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
+		if (status &gt;= 0)
+			status = (status == 2 ? 0 : -ENODEV);
+	}
 
 	if (status) {
 		dev_dbg(&amp;udev-&gt;dev, "gone after usb resume? status %d\n",
@@ -1735,6 +1689,28 @@ static int finish_port_resume(struct usb_device *udev)
  * the host and the device is the same as it was when the device
  * suspended.
  *
+ * If CONFIG_USB_PERSIST and @udev-&gt;reset_resume are both set then this
+ * routine won't check that the port is still enabled.  Furthermore,
+ * if @udev-&gt;reset_resume is set then finish_port_resume() above will
+ * reset @udev.  The end result is that a broken power session can be
+ * recovered and @udev will appear to persist across a loss of VBUS power.
+ *
+ * For example, if a host controller doesn't maintain VBUS suspend current
+ * during a system sleep or is reset when the system wakes up, all the USB
+ * power sessions below it will be broken.  This is especially troublesome
+ * for mass-storage devices containing mounted filesystems, since the
+ * device will appear to have disconnected and all the memory mappings
+ * to it will be lost.  Using the USB_PERSIST facility, the device can be
+ * made to appear as if it had not disconnected.
+ *
+ * This facility is inherently dangerous.  Although usb_reset_device()
+ * makes every effort to insure that the same device is present after the
+ * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
+ * quite possible for a device to remain unaltered but its media to be
+ * changed.  If the user replaces a flash memory card while the system is
+ * asleep, he will have only himself to blame when the filesystem on the
+ * new card is corrupted and the system crashes.
+ *
  * Returns 0 on success, else negative errno.
  */
 int usb_port_resume(struct usb_device *udev)
@@ -1743,6 +1719,7 @@ int usb_port_resume(struct usb_device *udev)
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	u16		portchange, portstatus;
+	unsigned	mask_flags, want_flags;
 
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
@@ -1765,20 +1742,23 @@ int usb_port_resume(struct usb_device *udev)
 				udev-&gt;auto_pm ? "auto-" : "");
 		msleep(25);
 
-#define LIVE_FLAGS	( USB_PORT_STAT_POWER \
-			| USB_PORT_STAT_ENABLE \
-			| USB_PORT_STAT_CONNECTION)
-
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
 		 * sequence.
 		 */
 		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
-SuspendCleared:
-		if (status &lt; 0
-				|| (portstatus &amp; LIVE_FLAGS) != LIVE_FLAGS
-				|| (portstatus &amp; USB_PORT_STAT_SUSPEND) != 0
-				) {
+
+ SuspendCleared:
+		if (USB_PERSIST &amp;&amp; udev-&gt;reset_resume)
+			want_flags = USB_PORT_STAT_POWER
+					| USB_PORT_STAT_CONNECTION;
+		else
+			want_flags = USB_PORT_STAT_POWER
+					| USB_PORT_STAT_CONNECTION
+					| USB_PORT_STAT_ENABLE;
+		mask_flags = want_flags | USB_PORT_STAT_SUSPEND;
+
+		if (status &lt; 0 || (portstatus &amp; mask_flags) != want_flags) {
 			dev_dbg(hub-&gt;intfdev,
 				"port %d status %04x.%04x after resume, %d\n",
 				port1, portchange, portstatus, status);
@@ -1790,18 +1770,19 @@ int usb_port_resume(struct usb_device *udev)
 						USB_PORT_FEAT_C_SUSPEND);
 			/* TRSMRCY = 10 msec */
 			msleep(10);
-			status = finish_port_resume(udev);
 		}
 	}
-	if (status &lt; 0) {
-		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
-		hub_port_logical_disconnect(hub, port1);
-	}
 
 	clear_bit(port1, hub-&gt;busy_bits);
 	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 		usb_enable_root_hub_irq(hub-&gt;hdev-&gt;bus);
 
+	if (status == 0)
+		status = finish_port_resume(udev);
+	if (status &lt; 0) {
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
+		hub_port_logical_disconnect(hub, port1);
+	}
 	return status;
 }
 
@@ -1830,7 +1811,14 @@ int usb_port_suspend(struct usb_device *udev)
 
 int usb_port_resume(struct usb_device *udev)
 {
-	return 0;
+	int status = 0;
+
+	/* However we may need to do a reset-resume */
+	if (udev-&gt;reset_resume) {
+		dev_dbg(&amp;udev-&gt;dev, "reset-resume\n");
+		status = usb_reset_device(udev);
+	}
+	return status;
 }
 
 static inline int remote_wakeup(struct usb_device *udev)
@@ -1886,8 +1874,6 @@ static int hub_resume(struct usb_interface *intf)
 
 #ifdef	CONFIG_USB_PERSIST
 
-#define USB_PERSIST	1
-
 /* For "persistent-device" resets we must mark the child devices for reset
  * and turn off a possible connect-change status (so khubd won't disconnect
  * them later).
@@ -1910,8 +1896,6 @@ static void mark_children_for_reset_resume(struct usb_hub *hub)
 
 #else
 
-#define USB_PERSIST	0
-
 static inline void mark_children_for_reset_resume(struct usb_hub *hub)
 { }
 
@@ -1936,6 +1920,24 @@ static int hub_reset_resume(struct usb_interface *intf)
 	return 0;
 }
 
+/**
+ * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
+ * @rhdev: struct usb_device for the root hub
+ *
+ * The USB host controller driver calls this function when its root hub
+ * is resumed and Vbus power has been interrupted or the controller
+ * has been reset.  The routine marks @rhdev as having lost power.  When
+ * the hub driver is resumed it will take notice; if CONFIG_USB_PERSIST
+ * is enabled then it will carry out power-session recovery, otherwise
+ * it will disconnect all the child devices.
+ */
+void usb_root_hub_lost_power(struct usb_device *rhdev)
+{
+	dev_warn(&amp;rhdev-&gt;dev, "root hub lost power or was reset\n");
+	rhdev-&gt;reset_resume = 1;
+}
+EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
+
 #else	/* CONFIG_PM */
 
 static inline int remote_wakeup(struct usb_device *udev)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index a547499c45f4..ad5fa0338f49 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,7 +36,6 @@ extern void usb_host_cleanup(void);
 extern void usb_autosuspend_work(struct work_struct *work);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
-extern int usb_reset_suspended_device(struct usb_device *udev);
 extern int usb_external_suspend_device(struct usb_device *udev,
 		pm_message_t msg);
 extern int usb_external_resume_device(struct usb_device *udev);</pre><hr><pre>commit f07600cf9eb3ee92777b2001e564faa413144a99
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:38:16 2007 -0400

    USB: add reset_resume method
    
    This patch (as918) introduces a new USB driver method: reset_resume.
    It is called when a device needs to be reset as part of a resume
    procedure (whether because of a device quirk or because of the
    USB-Persist facility), thereby taking over a role formerly assigned to
    the post_reset method.  As a consequence, post_reset no longer needs
    an argument indicating whether it is being called as part of a
    reset-resume.  This separation of functions makes the code clearer.
    
    In addition, the pre_reset and post_reset method return types are
    changed; they now must return an error code.  The return value is
    unused at present, but at some later time we may unbind drivers and
    re-probe if they encounter an error during reset handling.
    
    The existing pre_reset and post_reset methods in the usbhid,
    usb-storage, and hub drivers are updated to match the new
    requirements.  For usbhid the post_reset routine is also used for
    reset_resume (duplicate method pointers); for the other drivers a new
    reset_resume routine is added.  The change to hub.c looks bigger than
    it really is, because mark_children_for_reset_resume() gets moved down
    next to the new hub_reset_resume() routine.
    
    A minor change to usb-storage makes the usb_stor_report_bus_reset()
    routine acquire the host lock instead of requiring the caller to hold
    it already.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index e221b0d1f667..b2baeaeba9be 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -1009,20 +1009,22 @@ static int hid_resume(struct usb_interface *intf)
 }
 
 /* Treat USB reset pretty much the same as suspend/resume */
-static void hid_pre_reset(struct usb_interface *intf)
+static int hid_pre_reset(struct usb_interface *intf)
 {
 	/* FIXME: What if the interface is already suspended? */
 	hid_suspend(intf, PMSG_ON);
+	return 0;
 }
 
-static void hid_post_reset(struct usb_interface *intf, int reset_resume)
+/* Same routine used for post_reset and reset_resume */
+static int hid_post_reset(struct usb_interface *intf)
 {
 	struct usb_device *dev = interface_to_usbdev (intf);
 
 	hid_set_idle(dev, intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, 0, 0);
 	/* FIXME: Any more reinitialization needed? */
 
-	hid_resume(intf);
+	return hid_resume(intf);
 }
 
 static struct usb_device_id hid_usb_ids [] = {
@@ -1039,6 +1041,7 @@ static struct usb_driver hid_driver = {
 	.disconnect =	hid_disconnect,
 	.suspend =	hid_suspend,
 	.resume =	hid_resume,
+	.reset_resume =	hid_post_reset,
 	.pre_reset =	hid_pre_reset,
 	.post_reset =	hid_post_reset,
 	.id_table =	hid_usb_ids,
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 6c62a6d91484..3cd9af2638fc 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -915,21 +915,37 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 	}
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
-	if (reset_resume &amp;&amp; driver-&gt;post_reset)
-		driver-&gt;post_reset(intf, reset_resume);
-	else if (driver-&gt;resume) {
-		status = driver-&gt;resume(intf);
-		if (status)
-			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
-					"resume", status);
-	} else
-		dev_warn(&amp;intf-&gt;dev, "no resume for driver %s?\n",
-				driver-&gt;name);
+	if (reset_resume) {
+		if (driver-&gt;reset_resume) {
+			status = driver-&gt;reset_resume(intf);
+			if (status)
+				dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+						"reset_resume", status);
+		} else {
+			// status = -EOPNOTSUPP;
+			dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
+					"reset_resume", driver-&gt;name);
+		}
+	} else {
+		if (driver-&gt;resume) {
+			status = driver-&gt;resume(intf);
+			if (status)
+				dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+						"resume", status);
+		} else {
+			// status = -EOPNOTSUPP;
+			dev_warn(&amp;intf-&gt;dev, "no %s for driver %s?\n",
+					"resume", driver-&gt;name);
+		}
+	}
 
 done:
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		mark_active(intf);
+
+	/* FIXME: Unbind the driver and reprobe if the resume failed
+	 * (not possible if auto_pm is set) */
 	return status;
 }
 
@@ -966,6 +982,18 @@ static int autosuspend_check(struct usb_device *udev)
 						"for autosuspend\n");
 				return -EOPNOTSUPP;
 			}
+
+			/* Don't allow autosuspend if the device will need
+			 * a reset-resume and any of its interface drivers
+			 * doesn't include support.
+			 */
+			if (udev-&gt;quirks &amp; USB_QUIRK_RESET_RESUME) {
+				struct usb_driver *driver;
+
+				driver = to_usb_driver(intf-&gt;dev.driver);
+				if (!driver-&gt;reset_resume)
+					return -EOPNOTSUPP;
+			}
 		}
 	}
 
@@ -1146,7 +1174,8 @@ static int usb_resume_both(struct usb_device *udev)
 			status = usb_autoresume_device(parent);
 			if (status == 0) {
 				status = usb_resume_device(udev);
-				if (status) {
+				if (status || udev-&gt;state ==
+						USB_STATE_NOTATTACHED) {
 					usb_autosuspend_device(parent);
 
 					/* It's possible usb_resume_device()
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index ca3dbf84e800..0b8ed414d5cf 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -605,73 +605,26 @@ static void disconnect_all_children(struct usb_hub *hub, int logical)
 	}
 }
 
-#ifdef	CONFIG_USB_PERSIST
-
-#define USB_PERSIST	1
-
-/* For "persistent-device" resets we must mark the child devices for reset
- * and turn off a possible connect-change status (so khubd won't disconnect
- * them later).
- */
-static void mark_children_for_reset_resume(struct usb_hub *hub)
-{
-	struct usb_device *hdev = hub-&gt;hdev;
-	int port1;
-
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
-		struct usb_device *child = hdev-&gt;children[port1-1];
-
-		if (child) {
-			child-&gt;reset_resume = 1;
-			clear_port_feature(hdev, port1,
-					USB_PORT_FEAT_C_CONNECTION);
-		}
-	}
-}
-
-#else
-
-#define USB_PERSIST	0
-
-static inline void mark_children_for_reset_resume(struct usb_hub *hub)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST */
-
 /* caller has locked the hub device */
-static void hub_pre_reset(struct usb_interface *intf)
+static int hub_pre_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
-	/* This routine doesn't run as part of a reset-resume, so it's safe
-	 * to disconnect all the drivers below the hub.
-	 */
 	disconnect_all_children(hub, 0);
 	hub_quiesce(hub);
+	return 0;
 }
 
 /* caller has locked the hub device */
-static void hub_post_reset(struct usb_interface *intf, int reset_resume)
+static int hub_post_reset(struct usb_interface *intf)
 {
 	struct usb_hub *hub = usb_get_intfdata(intf);
 
 	hub_power_on(hub);
-	if (reset_resume) {
-		if (USB_PERSIST)
-			mark_children_for_reset_resume(hub);
-		else {
-			/* Reset-resume doesn't call pre_reset, so we have to
-			 * disconnect the children here.  But we may not lock
-			 * the child devices, so we have to do a "logical"
-			 * disconnect.
-			 */
-			disconnect_all_children(hub, 1);
-		}
-	}
 	hub_activate(hub);
+	return 0;
 }
 
-
 static int hub_configure(struct usb_hub *hub,
 	struct usb_endpoint_descriptor *endpoint)
 {
@@ -1931,6 +1884,58 @@ static int hub_resume(struct usb_interface *intf)
 	return 0;
 }
 
+#ifdef	CONFIG_USB_PERSIST
+
+#define USB_PERSIST	1
+
+/* For "persistent-device" resets we must mark the child devices for reset
+ * and turn off a possible connect-change status (so khubd won't disconnect
+ * them later).
+ */
+static void mark_children_for_reset_resume(struct usb_hub *hub)
+{
+	struct usb_device *hdev = hub-&gt;hdev;
+	int port1;
+
+	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; ++port1) {
+		struct usb_device *child = hdev-&gt;children[port1-1];
+
+		if (child) {
+			child-&gt;reset_resume = 1;
+			clear_port_feature(hdev, port1,
+					USB_PORT_FEAT_C_CONNECTION);
+		}
+	}
+}
+
+#else
+
+#define USB_PERSIST	0
+
+static inline void mark_children_for_reset_resume(struct usb_hub *hub)
+{ }
+
+#endif	/* CONFIG_USB_PERSIST */
+
+static int hub_reset_resume(struct usb_interface *intf)
+{
+	struct usb_hub *hub = usb_get_intfdata(intf);
+
+	hub_power_on(hub);
+	if (USB_PERSIST)
+		mark_children_for_reset_resume(hub);
+	else {
+		/* Reset-resume doesn't call pre_reset, so we have to
+		 * disconnect the children here.  But we may not lock
+		 * the child devices, so we have to do a "logical"
+		 * disconnect.
+		 */
+		disconnect_all_children(hub, 1);
+	}
+	hub_activate(hub);
+	return 0;
+}
+
 #else	/* CONFIG_PM */
 
 static inline int remote_wakeup(struct usb_device *udev)
@@ -1938,8 +1943,9 @@ static inline int remote_wakeup(struct usb_device *udev)
 	return 0;
 }
 
-#define hub_suspend NULL
-#define hub_resume NULL
+#define hub_suspend		NULL
+#define hub_resume		NULL
+#define hub_reset_resume	NULL
 #endif
 
 
@@ -2768,6 +2774,7 @@ static struct usb_driver hub_driver = {
 	.disconnect =	hub_disconnect,
 	.suspend =	hub_suspend,
 	.resume =	hub_resume,
+	.reset_resume =	hub_reset_resume,
 	.pre_reset =	hub_pre_reset,
 	.post_reset =	hub_post_reset,
 	.ioctl =	hub_ioctl,
@@ -3021,6 +3028,7 @@ int usb_reset_composite_device(struct usb_device *udev,
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;pre_reset)
 					(drv-&gt;pre_reset)(cintf);
+	/* FIXME: Unbind if pre_reset returns an error or isn't defined */
 			}
 		}
 	}
@@ -3038,7 +3046,8 @@ int usb_reset_composite_device(struct usb_device *udev,
 					cintf-&gt;dev.driver) {
 				drv = to_usb_driver(cintf-&gt;dev.driver);
 				if (drv-&gt;post_reset)
-					(drv-&gt;post_reset)(cintf, 0);
+					(drv-&gt;post_reset)(cintf);
+	/* FIXME: Unbind if post_reset returns an error or isn't defined */
 			}
 			if (cintf != iface)
 				up(&amp;cintf-&gt;dev.sem);
diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index e227f64d5641..1ba19eaa1970 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -321,10 +321,14 @@ void usb_stor_report_device_reset(struct us_data *us)
 
 /* Report a driver-initiated bus reset to the SCSI layer.
  * Calling this for a SCSI-initiated reset is unnecessary but harmless.
- * The caller must own the SCSI host lock. */
+ * The caller must not own the SCSI host lock. */
 void usb_stor_report_bus_reset(struct us_data *us)
 {
-	scsi_report_bus_reset(us_to_host(us), 0);
+	struct Scsi_Host *host = us_to_host(us);
+
+	scsi_lock(host);
+	scsi_report_bus_reset(host, 0);
+	scsi_unlock(host);
 }
 
 /***********************************************************************
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index be4cd8fe4ce6..00521f1d6a6b 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -219,6 +219,20 @@ static int storage_resume(struct usb_interface *iface)
 	return 0;
 }
 
+static int storage_reset_resume(struct usb_interface *iface)
+{
+	struct us_data *us = usb_get_intfdata(iface);
+
+	US_DEBUGP("%s\n", __FUNCTION__);
+
+	/* Report the reset to the SCSI core */
+	usb_stor_report_bus_reset(us);
+
+	/* FIXME: Notify the subdrivers that they need to reinitialize
+	 * the device */
+	return 0;
+}
+
 #endif /* CONFIG_PM */
 
 /*
@@ -226,7 +240,7 @@ static int storage_resume(struct usb_interface *iface)
  * a USB port reset, whether from this driver or a different one.
  */
 
-static void storage_pre_reset(struct usb_interface *iface)
+static int storage_pre_reset(struct usb_interface *iface)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
@@ -234,26 +248,23 @@ static void storage_pre_reset(struct usb_interface *iface)
 
 	/* Make sure no command runs during the reset */
 	mutex_lock(&amp;us-&gt;dev_mutex);
+	return 0;
 }
 
-static void storage_post_reset(struct usb_interface *iface, int reset_resume)
+static int storage_post_reset(struct usb_interface *iface)
 {
 	struct us_data *us = usb_get_intfdata(iface);
 
 	US_DEBUGP("%s\n", __FUNCTION__);
 
 	/* Report the reset to the SCSI core */
-	scsi_lock(us_to_host(us));
 	usb_stor_report_bus_reset(us);
-	scsi_unlock(us_to_host(us));
 
 	/* FIXME: Notify the subdrivers that they need to reinitialize
 	 * the device */
 
-	/* If this is a reset-resume then the pre_reset routine wasn't
-	 * called, so we don't need to unlock the mutex. */
-	if (!reset_resume)
-		mutex_unlock(&amp;us-&gt;dev_mutex);
+	mutex_unlock(&amp;us-&gt;dev_mutex);
+	return 0;
 }
 
 /*
@@ -1061,6 +1072,7 @@ static struct usb_driver usb_storage_driver = {
 #ifdef CONFIG_PM
 	.suspend =	storage_suspend,
 	.resume =	storage_resume,
+	.reset_resume =	storage_reset_resume,
 #endif
 	.pre_reset =	storage_pre_reset,
 	.post_reset =	storage_post_reset,
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0873c6219efc..bde8c65e2bfc 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -839,6 +839,8 @@ struct usbdrv_wrap {
  *	do (or don't) show up otherwise in the filesystem.
  * @suspend: Called when the device is going to be suspended by the system.
  * @resume: Called when the device is being resumed by the system.
+ * @reset_resume: Called when the suspended device has been reset instead
+ *	of being resumed.
  * @pre_reset: Called by usb_reset_composite_device() when the device
  *	is about to be reset.
  * @post_reset: Called by usb_reset_composite_device() after the device
@@ -885,9 +887,10 @@ struct usb_driver {
 
 	int (*suspend) (struct usb_interface *intf, pm_message_t message);
 	int (*resume) (struct usb_interface *intf);
+	int (*reset_resume)(struct usb_interface *intf);
 
-	void (*pre_reset) (struct usb_interface *intf);
-	void (*post_reset) (struct usb_interface *intf, int reset_resume);
+	int (*pre_reset)(struct usb_interface *intf);
+	int (*post_reset)(struct usb_interface *intf);
 
 	const struct usb_device_id *id_table;
 </pre><hr><pre>commit 624d6c0732d2c4ac00945ad79dbb6ff39ba90ee3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:35:16 2007 -0400

    USB: remove excess code from hub.c
    
    This patch (as917) removes a now-unnecessary level of subroutine
    nesting from hub.c.  Since usb_port_suspend() does nothing but call
    hub_port_suspend(), and usb_port_resume() does nothing but call
    hub_port_resume(), there's no reason to keep the routines separate.
    
    Also included in the patch are a few cosmetic changes involving
    whitespace and use of braces.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index ac1ef1527dd2..ca3dbf84e800 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1625,6 +1625,19 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 #ifdef	CONFIG_USB_SUSPEND
 
 /*
+ * usb_port_suspend - suspend a usb device's upstream port
+ * @udev: device that's no longer in active use, not a root hub
+ * Context: must be able to sleep; device not locked; pm locks held
+ *
+ * Suspends a USB device that isn't in active use, conserving power.
+ * Devices may wake out of a suspend, if anything important happens,
+ * using the remote wakeup mechanism.  They may also be taken out of
+ * suspend by the host, using usb_port_resume().  It's also routine
+ * to disconnect devices while they are suspended.
+ *
+ * This only affects the USB hardware for a device; its interfaces
+ * (and, for hubs, child devices) must already have been suspended.
+ *
  * Selective port suspend reduces power; most suspended devices draw
  * less than 500 uA.  It's also used in OTG, along with remote wakeup.
  * All devices below the suspended port are also suspended.
@@ -1633,11 +1646,35 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
  * also support "remote wakeup", where the device can activate the USB
  * tree above them to deliver data, such as a keypress or packet.  In
  * some cases, this wakes the USB host.
+ *
+ * Suspending OTG devices may trigger HNP, if that's been enabled
+ * between a pair of dual-role devices.  That will change roles, such
+ * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
+ *
+ * Devices on USB hub ports have only one "suspend" state, corresponding
+ * to ACPI D2, "may cause the device to lose some context".
+ * State transitions include:
+ *
+ *   - suspend, resume ... when the VBUS power link stays live
+ *   - suspend, disconnect ... VBUS lost
+ *
+ * Once VBUS drop breaks the circuit, the port it's using has to go through
+ * normal re-enumeration procedures, starting with enabling VBUS power.
+ * Other than re-initializing the hub (plug/unplug, except for root hubs),
+ * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
+ * timer, no SRP, no requests through sysfs.
+ *
+ * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
+ * the root hub for their bus goes into global suspend ... so we don't
+ * (falsely) update the device power state to say it suspended.
+ *
+ * Returns 0 on success, else negative errno.
  */
-static int hub_port_suspend(struct usb_hub *hub, int port1,
-		struct usb_device *udev)
+int usb_port_suspend(struct usb_device *udev)
 {
-	int	status;
+	struct usb_hub	*hub = hdev_to_hub(udev-&gt;parent);
+	int		port1 = udev-&gt;portnum;
+	int		status;
 
 	// dev_dbg(hub-&gt;intfdev, "suspend port %d\n", port1);
 
@@ -1654,17 +1691,15 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 				NULL, 0,
 				USB_CTRL_SET_TIMEOUT);
 		if (status)
-			dev_dbg(&amp;udev-&gt;dev,
-				"won't remote wakeup, status %d\n",
-				status);
+			dev_dbg(&amp;udev-&gt;dev, "won't remote wakeup, status %d\n",
+					status);
 	}
 
 	/* see 7.1.7.6 */
 	status = set_port_feature(hub-&gt;hdev, port1, USB_PORT_FEAT_SUSPEND);
 	if (status) {
-		dev_dbg(hub-&gt;intfdev,
-			"can't suspend port %d, status %d\n",
-			port1, status);
+		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
+				port1, status);
 		/* paranoia:  "should not happen" */
 		(void) usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
@@ -1681,52 +1716,6 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 	return status;
 }
 
-/*
- * usb_port_suspend - suspend a usb device's upstream port
- * @udev: device that's no longer in active use
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * Suspends a USB device that isn't in active use, conserving power.
- * Devices may wake out of a suspend, if anything important happens,
- * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_port_resume().  It's also routine
- * to disconnect devices while they are suspended.
- *
- * This only affects the USB hardware for a device; its interfaces
- * (and, for hubs, child devices) must already have been suspended.
- *
- * Suspending OTG devices may trigger HNP, if that's been enabled
- * between a pair of dual-role devices.  That will change roles, such
- * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
- *
- * Devices on USB hub ports have only one "suspend" state, corresponding
- * to ACPI D2, "may cause the device to lose some context".
- * State transitions include:
- *
- *   - suspend, resume ... when the VBUS power link stays live
- *   - suspend, disconnect ... VBUS lost
- *
- * Once VBUS drop breaks the circuit, the port it's using has to go through
- * normal re-enumeration procedures, starting with enabling VBUS power.
- * Other than re-initializing the hub (plug/unplug, except for root hubs),
- * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
- * timer, no SRP, no requests through sysfs.
- *
- * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
- * the root hub for their bus goes into global suspend ... so we don't
- * (falsely) update the device power state to say it suspended.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_port_suspend(struct usb_device *udev)
-{
-	int	status = 0;
-
-	status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
-			udev-&gt;portnum, udev);
-	return status;
-}
-
 /*
  * If the USB "suspend" state is in use (rather than "global suspend"),
  * many devices will be individually taken out of suspend state using
@@ -1760,11 +1749,10 @@ static int finish_port_resume(struct usb_device *udev)
 	if (status &gt;= 0)
 		status = (status == 2 ? 0 : -ENODEV);
 
-	if (status)
-		dev_dbg(&amp;udev-&gt;dev,
-			"gone after usb resume? status %d\n",
-			status);
-	else if (udev-&gt;actconfig) {
+	if (status) {
+		dev_dbg(&amp;udev-&gt;dev, "gone after usb resume? status %d\n",
+				status);
+	} else if (udev-&gt;actconfig) {
 		le16_to_cpus(&amp;devstatus);
 		if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)) {
 			status = usb_control_msg(udev,
@@ -1783,11 +1771,25 @@ static int finish_port_resume(struct usb_device *udev)
 	return status;
 }
 
-static int
-hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
+/*
+ * usb_port_resume - re-activate a suspended usb device's upstream port
+ * @udev: device to re-activate, not a root hub
+ * Context: must be able to sleep; device not locked; pm locks held
+ *
+ * This will re-activate the suspended device, increasing power usage
+ * while letting drivers communicate again with its endpoints.
+ * USB resume explicitly guarantees that the power session between
+ * the host and the device is the same as it was when the device
+ * suspended.
+ *
+ * Returns 0 on success, else negative errno.
+ */
+int usb_port_resume(struct usb_device *udev)
 {
-	int	status;
-	u16	portchange, portstatus;
+	struct usb_hub	*hub = hdev_to_hub(udev-&gt;parent);
+	int		port1 = udev-&gt;portnum;
+	int		status;
+	u16		portchange, portstatus;
 
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
@@ -1802,9 +1804,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	status = clear_port_feature(hub-&gt;hdev,
 			port1, USB_PORT_FEAT_SUSPEND);
 	if (status) {
-		dev_dbg(hub-&gt;intfdev,
-			"can't resume port %d, status %d\n",
-			port1, status);
+		dev_dbg(hub-&gt;intfdev, "can't resume port %d, status %d\n",
+				port1, status);
 	} else {
 		/* drive resume for at least 20 msec */
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
@@ -1839,8 +1840,10 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			status = finish_port_resume(udev);
 		}
 	}
-	if (status &lt; 0)
+	if (status &lt; 0) {
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 		hub_port_logical_disconnect(hub, port1);
+	}
 
 	clear_bit(port1, hub-&gt;busy_bits);
 	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
@@ -1849,30 +1852,6 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	return status;
 }
 
-/*
- * usb_port_resume - re-activate a suspended usb device's upstream port
- * @udev: device to re-activate
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * This will re-activate the suspended device, increasing power usage
- * while letting drivers communicate again with its endpoints.
- * USB resume explicitly guarantees that the power session between
- * the host and the device is the same as it was when the device
- * suspended.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_port_resume(struct usb_device *udev)
-{
-	int	status;
-
-	status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-			udev-&gt;portnum, udev);
-	if (status &lt; 0)
-		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
-	return status;
-}
-
 static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
@@ -1896,18 +1875,6 @@ int usb_port_suspend(struct usb_device *udev)
 	return 0;
 }
 
-static inline int
-finish_port_resume(struct usb_device *udev)
-{
-	return 0;
-}
-
-static inline int
-hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
-{
-	return 0;
-}
-
 int usb_port_resume(struct usb_device *udev)
 {
 	return 0;</pre><hr><pre>commit 686314cfbdac21c9019c0e04487b5d940db62406
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 15:34:36 2007 -0400

    USB: separate root and non-root suspend/resume
    
    This patch (as916) completes the separation of code paths for suspend
    and resume of root hubs as opposed to non-root devices.  Root hubs
    will be power-managed through their bus_suspend and bus_resume
    methods, whereas normal devices will use usb_port_suspend() and
    usb_port_resume().
    
    Changes to the hcd_bus_{suspend,resume} routines mostly represent
    motion of code that was already present elsewhere.  They include:
    
            Adding debugging log messages,
    
            Setting the device state appropriately, and
    
            Adding a resume recovery time delay.
    
    Changes to the port-suspend and port-resume routines in hub.c include:
    
            Removal of checks for root devices (since they will never
            be triggered), and
    
            Removal of checks for NULL or invalid device pointers (these
            were left over from earlier kernel versions and aren't needed
            at all).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index d363b0ea7345..4cbe7b339513 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -196,20 +196,15 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	int rc;
 
-	rc = usb_port_suspend(udev);
-
-	/* Root hubs don't have upstream ports to suspend,
-	 * so the line above won't do much for them.  We have to
-	 * shut down their downstream HC-to-USB interfaces manually,
-	 * by doing a bus (or "global") suspend.
+	/* Normal USB devices suspend through their upstream port.
+	 * Root hubs don't have upstream ports to suspend,
+	 * so we have to shut down their downstream HC-to-USB
+	 * interfaces manually by doing a bus (or "global") suspend.
 	 */
-	if (rc == 0 &amp;&amp; !udev-&gt;parent) {
-		rc = hcd_bus_suspend(udev-&gt;bus);
-		if (rc) {
-			dev_dbg(&amp;udev-&gt;dev, "'global' suspend %d\n", rc);
-			usb_port_resume(udev);
-		}
-	}
+	if (!udev-&gt;parent)
+		rc = hcd_bus_suspend(udev);
+	else
+		rc = usb_port_suspend(udev);
 	return rc;
 }
 
@@ -217,25 +212,17 @@ static int generic_resume(struct usb_device *udev)
 {
 	int rc;
 
-	if (udev-&gt;reset_resume)
+	/* Normal USB devices resume/reset through their upstream port.
+	 * Root hubs don't have upstream ports to resume or reset,
+	 * so we have to start up their downstream HC-to-USB
+	 * interfaces manually by doing a bus (or "global") resume.
+	 */
+	if (!udev-&gt;parent)
+		rc = hcd_bus_resume(udev);
+	else if (udev-&gt;reset_resume)
 		rc = usb_reset_suspended_device(udev);
 	else
 		rc = usb_port_resume(udev);
-
-	/* Root hubs don't have upstream ports to resume or reset,
-	 * so the line above won't do much for them.  We have to
-	 * start up their downstream HC-to-USB interfaces manually,
-	 * by doing a bus (or "global") resume.
-	 */
-	if (rc == 0 &amp;&amp; !udev-&gt;parent) {
-		rc = hcd_bus_resume(udev-&gt;bus);
-		if (rc)
-			dev_dbg(&amp;udev-&gt;dev, "'global' resume %d\n", rc);
-		else {
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-		}
-	}
 	return rc;
 }
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 87d6edf11f92..e5058fb26a7e 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1257,40 +1257,54 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 
 #ifdef	CONFIG_PM
 
-int hcd_bus_suspend (struct usb_bus *bus)
+int hcd_bus_suspend(struct usb_device *rhdev)
 {
-	struct usb_hcd		*hcd;
-	int			status;
+	struct usb_hcd	*hcd = container_of(rhdev-&gt;bus, struct usb_hcd, self);
+	int		status;
+	int		old_state = hcd-&gt;state;
 
-	hcd = container_of (bus, struct usb_hcd, self);
-	if (!hcd-&gt;driver-&gt;bus_suspend)
-		return -ENOENT;
-	hcd-&gt;state = HC_STATE_QUIESCING;
-	status = hcd-&gt;driver-&gt;bus_suspend (hcd);
-	if (status == 0)
+	dev_dbg(&amp;rhdev-&gt;dev, "bus %s%s\n",
+			rhdev-&gt;auto_pm ? "auto-" : "", "suspend");
+	if (!hcd-&gt;driver-&gt;bus_suspend) {
+		status = -ENOENT;
+	} else {
+		hcd-&gt;state = HC_STATE_QUIESCING;
+		status = hcd-&gt;driver-&gt;bus_suspend(hcd);
+	}
+	if (status == 0) {
+		usb_set_device_state(rhdev, USB_STATE_SUSPENDED);
 		hcd-&gt;state = HC_STATE_SUSPENDED;
-	else
-		dev_dbg(&amp;bus-&gt;root_hub-&gt;dev, "%s fail, err %d\n",
+	} else {
+		hcd-&gt;state = old_state;
+		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
 				"suspend", status);
+	}
 	return status;
 }
 
-int hcd_bus_resume (struct usb_bus *bus)
+int hcd_bus_resume(struct usb_device *rhdev)
 {
-	struct usb_hcd		*hcd;
-	int			status;
+	struct usb_hcd	*hcd = container_of(rhdev-&gt;bus, struct usb_hcd, self);
+	int		status;
 
-	hcd = container_of (bus, struct usb_hcd, self);
+	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
+			rhdev-&gt;auto_pm ? "auto-" : "", "resume");
 	if (!hcd-&gt;driver-&gt;bus_resume)
 		return -ENOENT;
 	if (hcd-&gt;state == HC_STATE_RUNNING)
 		return 0;
+
 	hcd-&gt;state = HC_STATE_RESUMING;
-	status = hcd-&gt;driver-&gt;bus_resume (hcd);
-	if (status == 0)
+	status = hcd-&gt;driver-&gt;bus_resume(hcd);
+	if (status == 0) {
+		/* TRSMRCY = 10 msec */
+		msleep(10);
+		usb_set_device_state(rhdev, rhdev-&gt;actconfig
+				? USB_STATE_CONFIGURED
+				: USB_STATE_ADDRESS);
 		hcd-&gt;state = HC_STATE_RUNNING;
-	else {
-		dev_dbg(&amp;bus-&gt;root_hub-&gt;dev, "%s fail, err %d\n",
+	} else {
+		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
 				"resume", status);
 		usb_hc_died(hcd);
 	}
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index ef50fa494e47..b5ebb73c2332 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -364,23 +364,13 @@ extern int usb_find_interface_driver (struct usb_device *dev,
 #ifdef CONFIG_PM
 extern void usb_hcd_resume_root_hub (struct usb_hcd *hcd);
 extern void usb_root_hub_lost_power (struct usb_device *rhdev);
-extern int hcd_bus_suspend (struct usb_bus *bus);
-extern int hcd_bus_resume (struct usb_bus *bus);
+extern int hcd_bus_suspend(struct usb_device *rhdev);
+extern int hcd_bus_resume(struct usb_device *rhdev);
 #else
 static inline void usb_hcd_resume_root_hub(struct usb_hcd *hcd)
 {
 	return;
 }
-
-static inline int hcd_bus_suspend(struct usb_bus *bus)
-{
-	return 0;
-}
-
-static inline int hcd_bus_resume (struct usb_bus *bus)
-{
-	return 0;
-}
 #endif /* CONFIG_PM */
 
 /*
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 04d6fde57d88..ac1ef1527dd2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1722,17 +1722,8 @@ int usb_port_suspend(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* we change the device's upstream USB link,
-	 * but root hubs have no upstream USB link.
-	 */
-	if (udev-&gt;parent)
-		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
-				udev-&gt;portnum, udev);
-	else {
-		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
-				udev-&gt;auto_pm ? "auto-" : "");
-		usb_set_device_state(udev, USB_STATE_SUSPENDED);
-	}
+	status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
+			udev-&gt;portnum, udev);
 	return status;
 }
 
@@ -1775,8 +1766,7 @@ static int finish_port_resume(struct usb_device *udev)
 			status);
 	else if (udev-&gt;actconfig) {
 		le16_to_cpus(&amp;devstatus);
-		if ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
-				&amp;&amp; udev-&gt;parent) {
+		if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP)) {
 			status = usb_control_msg(udev,
 					usb_sndctrlpipe(udev, 0),
 					USB_REQ_CLEAR_FEATURE,
@@ -1789,10 +1779,6 @@ static int finish_port_resume(struct usb_device *udev)
 					"wakeup, status %d\n", status);
 		}
 		status = 0;
-
-	} else if (udev-&gt;devnum &lt;= 0) {
-		dev_dbg(&amp;udev-&gt;dev, "bogus resume!\n");
-		status = -EINVAL;
 	}
 	return status;
 }
@@ -1821,9 +1807,8 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			port1, status);
 	} else {
 		/* drive resume for at least 20 msec */
-		if (udev)
-			dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
-					udev-&gt;auto_pm ? "auto-" : "");
+		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
+				udev-&gt;auto_pm ? "auto-" : "");
 		msleep(25);
 
 #define LIVE_FLAGS	( USB_PORT_STAT_POWER \
@@ -1851,8 +1836,7 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 						USB_PORT_FEAT_C_SUSPEND);
 			/* TRSMRCY = 10 msec */
 			msleep(10);
-			if (udev)
-				status = finish_port_resume(udev);
+			status = finish_port_resume(udev);
 		}
 	}
 	if (status &lt; 0)
@@ -1882,18 +1866,8 @@ int usb_port_resume(struct usb_device *udev)
 {
 	int	status;
 
-	/* we change the device's upstream USB link,
-	 * but root hubs have no upstream USB link.
-	 */
-	if (udev-&gt;parent) {
-		// NOTE this fails if parent is also suspended...
-		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-				udev-&gt;portnum, udev);
-	} else {
-		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n",
-				udev-&gt;auto_pm ? "auto-" : "");
-		status = finish_port_resume(udev);
-	}
+	status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
+			udev-&gt;portnum, udev);
 	if (status &lt; 0)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 	return status;</pre><hr><pre>commit 4956eccdd6101c5abb71966079e8183d12796d6c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 30 16:51:28 2007 -0400

    USB: remove __usb_port_suspend
    
    This patch (as915b) combines the public routine usb_port_suspend() and
    the private routine __usb_port_suspend() into a single function.
    
    By removing the explicit mention of otg_port in the call to
    __usb_port_suspend(), we prevent a possible error in which the system
    tries to perform HNP on the wrong port when a non-targeted device is
    plugged into a non-OTG port.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 7946d7b6c71a..04d6fde57d88 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1333,7 +1333,6 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
 
 #ifdef	CONFIG_USB_OTG
 #include "otg_whitelist.h"
-static int __usb_port_suspend(struct usb_device *, int port1);
 #endif
 
 /**
@@ -1439,7 +1438,7 @@ int usb_new_device(struct usb_device *udev)
 		 * (Includes HNP test device.)
 		 */
 		if (udev-&gt;bus-&gt;b_hnp_enable || udev-&gt;bus-&gt;is_b_host) {
-			err = __usb_port_suspend(udev, udev-&gt;bus-&gt;otg_port);
+			err = usb_port_suspend(udev);
 			if (err &lt; 0)
 				dev_dbg(&amp;udev-&gt;dev, "HNP fail, %d\n", err);
 		}
@@ -1683,6 +1682,23 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
 }
 
 /*
+ * usb_port_suspend - suspend a usb device's upstream port
+ * @udev: device that's no longer in active use
+ * Context: must be able to sleep; device not locked; pm locks held
+ *
+ * Suspends a USB device that isn't in active use, conserving power.
+ * Devices may wake out of a suspend, if anything important happens,
+ * using the remote wakeup mechanism.  They may also be taken out of
+ * suspend by the host, using usb_port_resume().  It's also routine
+ * to disconnect devices while they are suspended.
+ *
+ * This only affects the USB hardware for a device; its interfaces
+ * (and, for hubs, child devices) must already have been suspended.
+ *
+ * Suspending OTG devices may trigger HNP, if that's been enabled
+ * between a pair of dual-role devices.  That will change roles, such
+ * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
+ *
  * Devices on USB hub ports have only one "suspend" state, corresponding
  * to ACPI D2, "may cause the device to lose some context".
  * State transitions include:
@@ -1699,21 +1715,19 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
  * If CONFIG_USB_SUSPEND isn't enabled, devices only really suspend when
  * the root hub for their bus goes into global suspend ... so we don't
  * (falsely) update the device power state to say it suspended.
+ *
+ * Returns 0 on success, else negative errno.
  */
-static int __usb_port_suspend (struct usb_device *udev, int port1)
+int usb_port_suspend(struct usb_device *udev)
 {
 	int	status = 0;
 
-	/* caller owns the udev device lock */
-	if (port1 &lt; 0)
-		return port1;
-
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent)
-		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
-				udev);
+		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent),
+				udev-&gt;portnum, udev);
 	else {
 		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend\n",
 				udev-&gt;auto_pm ? "auto-" : "");
@@ -1722,31 +1736,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	return status;
 }
 
-/*
- * usb_port_suspend - suspend a usb device's upstream port
- * @udev: device that's no longer in active use
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * Suspends a USB device that isn't in active use, conserving power.
- * Devices may wake out of a suspend, if anything important happens,
- * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_port_resume().  It's also routine
- * to disconnect devices while they are suspended.
- *
- * This only affects the USB hardware for a device; its interfaces
- * (and, for hubs, child devices) must already have been suspended.
- *
- * Suspending OTG devices may trigger HNP, if that's been enabled
- * between a pair of dual-role devices.  That will change roles, such
- * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.
- *
- * Returns 0 on success, else negative errno.
- */
-int usb_port_suspend(struct usb_device *udev)
-{
-	return __usb_port_suspend(udev, udev-&gt;portnum);
-}
-
 /*
  * If the USB "suspend" state is in use (rather than "global suspend"),
  * many devices will be individually taken out of suspend state using
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1a4862886733..a547499c45f4 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -53,8 +53,16 @@ static inline void usb_pm_unlock(struct usb_device *udev)
 
 #else
 
-#define usb_port_suspend(dev)		0
-#define usb_port_resume(dev)		0
+static inline int usb_port_suspend(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int usb_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
 static inline void usb_pm_lock(struct usb_device *udev) {}
 static inline void usb_pm_unlock(struct usb_device *udev) {}
 </pre><hr><pre>commit 20dfdad74a2baabeecc2896c770efcbf698b9b8d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 22 11:50:17 2007 -0400

    USB: rework C++-style comments
    
    This patch (as911) replaces some C++-style commented-out debugging
    lines in driver.c with a new "verbose debugging" macro.  It makes the
    code look cleaner, and it's easier to turn the debugging on or off.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 02d6db61c940..6c62a6d91484 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -29,6 +29,14 @@
 #include "hcd.h"
 #include "usb.h"
 
+#define VERBOSE_DEBUG	0
+
+#if VERBOSE_DEBUG
+#define dev_vdbg	dev_dbg
+#else
+#define dev_vdbg(dev, fmt, args...)	do { } while (0)
+#endif
+
 #ifdef CONFIG_HOTPLUG
 
 /*
@@ -812,8 +820,8 @@ static int usb_suspend_device(struct usb_device *udev, pm_message_t msg)
 	}
 	status = udriver-&gt;suspend(udev, msg);
 
-done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+ done:
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		udev-&gt;dev.power.power_state.event = msg.event;
 	return status;
@@ -842,8 +850,8 @@ static int usb_resume_device(struct usb_device *udev)
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;resume(udev);
 
-done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+ done:
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0) {
 		udev-&gt;autoresume_disabled = 0;
 		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
@@ -881,8 +889,8 @@ static int usb_suspend_interface(struct usb_interface *intf, pm_message_t msg)
 		mark_quiesced(intf);
 	}
 
-done:
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+ done:
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
 
@@ -919,7 +927,7 @@ static int usb_resume_interface(struct usb_interface *intf, int reset_resume)
 				driver-&gt;name);
 
 done:
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	if (status == 0)
 		mark_active(intf);
 	return status;
@@ -1083,7 +1091,7 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 	}
 
  done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	return status;
 }
 
@@ -1180,7 +1188,7 @@ static int usb_resume_both(struct usb_device *udev)
 	}
 
  done:
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d\n", __FUNCTION__, status);
 	udev-&gt;reset_resume = 0;
 	return status;
 }
@@ -1248,8 +1256,8 @@ void usb_autosuspend_device(struct usb_device *udev)
 	int	status;
 
 	status = usb_autopm_do_device(udev, -1);
-	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
-	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+			__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
 
 /**
@@ -1268,8 +1276,8 @@ void usb_autosuspend_device(struct usb_device *udev)
 void usb_try_autosuspend_device(struct usb_device *udev)
 {
 	usb_autopm_do_device(udev, 0);
-	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
-	// 		__FUNCTION__, udev-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
+			__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
 
 /**
@@ -1296,8 +1304,8 @@ int usb_autoresume_device(struct usb_device *udev)
 	int	status;
 
 	status = usb_autopm_do_device(udev, 1);
-	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, udev-&gt;pm_usage_cnt);
 	return status;
 }
 
@@ -1369,8 +1377,8 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 	int	status;
 
 	status = usb_autopm_do_interface(intf, -1);
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
 
@@ -1413,8 +1421,8 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 	int	status;
 
 	status = usb_autopm_do_interface(intf, 1);
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
@@ -1435,8 +1443,8 @@ int usb_autopm_set_interface(struct usb_interface *intf)
 	int	status;
 
 	status = usb_autopm_do_interface(intf, 0);
-	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
+	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
+			__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_set_interface);</pre><hr><pre>commit d4ead16f50f9ad30bdc7276ec8fee7a24c72f294
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 22 11:46:41 2007 -0400

    USB: prevent char device open/deregister race
    
    This patch (as908) adds central protection in usbcore for the
    prototypical race between opening and unregistering a char device.
    The spinlock used to protect the minor-numbers array is replaced with
    an rwsem, which can remain locked across a call to a driver's open()
    method.  This guarantees that open() and deregister() will be mutually
    exclusive.
    
    The private locks currently used in several individual drivers for
    this purpose are no longer necessary, and the patch removes them.  The
    following USB drivers are affected: usblcd, idmouse, auerswald,
    legousbtower, sisusbvga/sisusb, ldusb, adutux, iowarrior, and
    usb-skeleton.
    
    As a side effect of this change, usb_deregister_dev() must not be
    called while holding a lock that is acquired by open().  Unfortunately
    a number of drivers do this, but luckily the solution is simple: call
    usb_deregister_dev() before acquiring the lock.
    
    In addition to these changes (and their consequent code
    simplifications), the patch fixes a use-after-free bug in adutux and a
    race between open() and release() in iowarrior.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/file.c b/drivers/usb/core/file.c
index 01c857ac27af..5d860bc9b421 100644
--- a/drivers/usb/core/file.c
+++ b/drivers/usb/core/file.c
@@ -16,15 +16,15 @@
  */
 
 #include &lt;linux/module.h&gt;
-#include &lt;linux/spinlock.h&gt;
 #include &lt;linux/errno.h&gt;
+#include &lt;linux/rwsem.h&gt;
 #include &lt;linux/usb.h&gt;
 
 #include "usb.h"
 
 #define MAX_USB_MINORS	256
 static const struct file_operations *usb_minors[MAX_USB_MINORS];
-static DEFINE_SPINLOCK(minor_lock);
+static DECLARE_RWSEM(minor_rwsem);
 
 static int usb_open(struct inode * inode, struct file * file)
 {
@@ -33,14 +33,11 @@ static int usb_open(struct inode * inode, struct file * file)
 	int err = -ENODEV;
 	const struct file_operations *old_fops, *new_fops = NULL;
 
-	spin_lock (&amp;minor_lock);
+	down_read(&amp;minor_rwsem);
 	c = usb_minors[minor];
 
-	if (!c || !(new_fops = fops_get(c))) {
-		spin_unlock(&amp;minor_lock);
-		return err;
-	}
-	spin_unlock(&amp;minor_lock);
+	if (!c || !(new_fops = fops_get(c)))
+		goto done;
 
 	old_fops = file-&gt;f_op;
 	file-&gt;f_op = new_fops;
@@ -52,6 +49,8 @@ static int usb_open(struct inode * inode, struct file * file)
 		file-&gt;f_op = fops_get(old_fops);
 	}
 	fops_put(old_fops);
+ done:
+	up_read(&amp;minor_rwsem);
 	return err;
 }
 
@@ -166,7 +165,7 @@ int usb_register_dev(struct usb_interface *intf,
 	if (class_driver-&gt;fops == NULL)
 		goto exit;
 
-	spin_lock (&amp;minor_lock);
+	down_write(&amp;minor_rwsem);
 	for (minor = minor_base; minor &lt; MAX_USB_MINORS; ++minor) {
 		if (usb_minors[minor])
 			continue;
@@ -176,7 +175,7 @@ int usb_register_dev(struct usb_interface *intf,
 		retval = 0;
 		break;
 	}
-	spin_unlock (&amp;minor_lock);
+	up_write(&amp;minor_rwsem);
 
 	if (retval)
 		goto exit;
@@ -197,9 +196,9 @@ int usb_register_dev(struct usb_interface *intf,
 	intf-&gt;usb_dev = device_create(usb_class-&gt;class, &amp;intf-&gt;dev,
 				      MKDEV(USB_MAJOR, minor), "%s", temp);
 	if (IS_ERR(intf-&gt;usb_dev)) {
-		spin_lock (&amp;minor_lock);
+		down_write(&amp;minor_rwsem);
 		usb_minors[intf-&gt;minor] = NULL;
-		spin_unlock (&amp;minor_lock);
+		up_write(&amp;minor_rwsem);
 		retval = PTR_ERR(intf-&gt;usb_dev);
 	}
 exit:
@@ -236,9 +235,9 @@ void usb_deregister_dev(struct usb_interface *intf,
 
 	dbg ("removing %d minor", intf-&gt;minor);
 
-	spin_lock (&amp;minor_lock);
+	down_write(&amp;minor_rwsem);
 	usb_minors[intf-&gt;minor] = NULL;
-	spin_unlock (&amp;minor_lock);
+	up_write(&amp;minor_rwsem);
 
 	snprintf(name, BUS_ID_SIZE, class_driver-&gt;name, intf-&gt;minor - minor_base);
 	device_destroy(usb_class-&gt;class, MKDEV(USB_MAJOR, intf-&gt;minor));
@@ -247,5 +246,3 @@ void usb_deregister_dev(struct usb_interface *intf,
 	destroy_usb_class();
 }
 EXPORT_SYMBOL(usb_deregister_dev);
-
-
diff --git a/drivers/usb/misc/adutux.c b/drivers/usb/misc/adutux.c
index 77145f9db043..d72c42e5f22d 100644
--- a/drivers/usb/misc/adutux.c
+++ b/drivers/usb/misc/adutux.c
@@ -108,8 +108,6 @@ struct adu_device {
 	struct urb*		interrupt_out_urb;
 };
 
-/* prevent races between open() and disconnect */
-static DEFINE_MUTEX(disconnect_mutex);
 static struct usb_driver adu_driver;
 
 static void adu_debug_data(int level, const char *function, int size,
@@ -256,8 +254,6 @@ static int adu_open(struct inode *inode, struct file *file)
 
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	interface = usb_find_interface(&amp;adu_driver, subminor);
 	if (!interface) {
 		err("%s - error, can't find device for minor %d",
@@ -306,7 +302,6 @@ static int adu_open(struct inode *inode, struct file *file)
 	up(&amp;dev-&gt;sem);
 
 exit_no_device:
-	mutex_unlock(&amp;disconnect_mutex);
 	dbg(2,"%s : leave, return value %d ", __FUNCTION__, retval);
 
 	return retval;
@@ -318,12 +313,6 @@ static int adu_release_internal(struct adu_device *dev)
 
 	dbg(2," %s : enter", __FUNCTION__);
 
-	if (dev-&gt;udev == NULL) {
-		/* the device was unplugged before the file was released */
-		adu_delete(dev);
-		goto exit;
-	}
-
 	/* decrement our usage count for the device */
 	--dev-&gt;open_count;
 	dbg(2," %s : open count %d", __FUNCTION__, dev-&gt;open_count);
@@ -332,7 +321,6 @@ static int adu_release_internal(struct adu_device *dev)
 		dev-&gt;open_count = 0;
 	}
 
-exit:
 	dbg(2," %s : leave", __FUNCTION__);
 	return retval;
 }
@@ -367,8 +355,15 @@ static int adu_release(struct inode *inode, struct file *file)
 		goto exit;
 	}
 
-	/* do the work */
-	retval = adu_release_internal(dev);
+	if (dev-&gt;udev == NULL) {
+		/* the device was unplugged before the file was released */
+		up(&amp;dev-&gt;sem);
+		adu_delete(dev);
+		dev = NULL;
+	} else {
+		/* do the work */
+		retval = adu_release_internal(dev);
+	}
 
 exit:
 	if (dev)
@@ -831,19 +826,17 @@ static void adu_disconnect(struct usb_interface *interface)
 
 	dbg(2," %s : enter", __FUNCTION__);
 
-	mutex_lock(&amp;disconnect_mutex); /* not interruptible */
-
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
-	down(&amp;dev-&gt;sem); /* not interruptible */
-
 	minor = dev-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;adu_class);
 	dev-&gt;minor = 0;
 
+	down(&amp;dev-&gt;sem); /* not interruptible */
+
 	/* if the device is not opened, then we clean up right now */
 	dbg(2," %s : open count %d", __FUNCTION__, dev-&gt;open_count);
 	if (!dev-&gt;open_count) {
@@ -854,8 +847,6 @@ static void adu_disconnect(struct usb_interface *interface)
 		up(&amp;dev-&gt;sem);
 	}
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	dev_info(&amp;interface-&gt;dev, "ADU device adutux%d now disconnected",
 		 (minor - ADU_MINOR_BASE));
 
diff --git a/drivers/usb/misc/auerswald.c b/drivers/usb/misc/auerswald.c
index cac1500cba62..1fd5fc220cd7 100644
--- a/drivers/usb/misc/auerswald.c
+++ b/drivers/usb/misc/auerswald.c
@@ -2034,12 +2034,12 @@ static void auerswald_disconnect (struct usb_interface *intf)
 	if (!cp)
 		return;
 
-	down (&amp;cp-&gt;mutex);
-	info ("device /dev/%s now disconnecting", cp-&gt;name);
-
 	/* give back our USB minor number */
 	usb_deregister_dev(intf, &amp;auerswald_class);
 
+	down (&amp;cp-&gt;mutex);
+	info ("device /dev/%s now disconnecting", cp-&gt;name);
+
 	/* Stop the interrupt endpoint */
 	auerswald_int_release (cp);
 
diff --git a/drivers/usb/misc/idmouse.c b/drivers/usb/misc/idmouse.c
index 8d0e360636e6..e6fd024024f5 100644
--- a/drivers/usb/misc/idmouse.c
+++ b/drivers/usb/misc/idmouse.c
@@ -119,9 +119,6 @@ static struct usb_driver idmouse_driver = {
 	.id_table = idmouse_table,
 };
 
-/* prevent races between open() and disconnect() */
-static DEFINE_MUTEX(disconnect_mutex);
-
 static int idmouse_create_image(struct usb_idmouse *dev)
 {
 	int bytes_read;
@@ -211,21 +208,15 @@ static int idmouse_open(struct inode *inode, struct file *file)
 	struct usb_interface *interface;
 	int result;
 
-	/* prevent disconnects */
-	mutex_lock(&amp;disconnect_mutex);
-
 	/* get the interface from minor number and driver information */
 	interface = usb_find_interface (&amp;idmouse_driver, iminor (inode));
-	if (!interface) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!interface)
 		return -ENODEV;
-	}
+
 	/* get the device information block from the interface */
 	dev = usb_get_intfdata(interface);
-	if (!dev) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!dev)
 		return -ENODEV;
-	}
 
 	/* lock this device */
 	down(&amp;dev-&gt;sem);
@@ -255,9 +246,6 @@ static int idmouse_open(struct inode *inode, struct file *file)
 
 	/* unlock this device */
 	up(&amp;dev-&gt;sem);
-
-	/* unlock the disconnect semaphore */
-	mutex_unlock(&amp;disconnect_mutex);
 	return result;
 }
 
@@ -265,15 +253,10 @@ static int idmouse_release(struct inode *inode, struct file *file)
 {
 	struct usb_idmouse *dev;
 
-	/* prevent a race condition with open() */
-	mutex_lock(&amp;disconnect_mutex);
-
 	dev = file-&gt;private_data;
 
-	if (dev == NULL) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (dev == NULL)
 		return -ENODEV;
-	}
 
 	/* lock our device */
 	down(&amp;dev-&gt;sem);
@@ -281,7 +264,6 @@ static int idmouse_release(struct inode *inode, struct file *file)
 	/* are we really open? */
 	if (dev-&gt;open &lt;= 0) {
 		up(&amp;dev-&gt;sem);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -ENODEV;
 	}
 
@@ -291,12 +273,9 @@ static int idmouse_release(struct inode *inode, struct file *file)
 		/* the device was unplugged before the file was released */
 		up(&amp;dev-&gt;sem);
 		idmouse_delete(dev);
-		mutex_unlock(&amp;disconnect_mutex);
-		return 0;
+	} else {
+		up(&amp;dev-&gt;sem);
 	}
-
-	up(&amp;dev-&gt;sem);
-	mutex_unlock(&amp;disconnect_mutex);
 	return 0;
 }
 
@@ -391,30 +370,27 @@ static void idmouse_disconnect(struct usb_interface *interface)
 {
 	struct usb_idmouse *dev;
 
-	/* prevent races with open() */
-	mutex_lock(&amp;disconnect_mutex);
-
 	/* get device structure */
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
-	/* lock it */
-	down(&amp;dev-&gt;sem);
-
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;idmouse_class);
 
+	/* lock it */
+	down(&amp;dev-&gt;sem);
+
 	/* prevent device read, write and ioctl */
 	dev-&gt;present = 0;
 
-	/* unlock */
-	up(&amp;dev-&gt;sem);
-
 	/* if the device is opened, idmouse_release will clean this up */
-	if (!dev-&gt;open)
+	if (!dev-&gt;open) {
+		up(&amp;dev-&gt;sem);
 		idmouse_delete(dev);
-
-	mutex_unlock(&amp;disconnect_mutex);
+	} else {
+		/* unlock */
+		up(&amp;dev-&gt;sem);
+	}
 
 	info("%s disconnected", DRIVER_DESC);
 }
diff --git a/drivers/usb/misc/iowarrior.c b/drivers/usb/misc/iowarrior.c
index 3bb33f7bfa36..28548d186712 100644
--- a/drivers/usb/misc/iowarrior.c
+++ b/drivers/usb/misc/iowarrior.c
@@ -100,8 +100,6 @@ struct iowarrior {
 /*--------------*/
 /*    globals   */
 /*--------------*/
-/* prevent races between open() and disconnect() */
-static DECLARE_MUTEX(disconnect_sem);
 
 /*
  *  USB spec identifies 5 second timeouts.
@@ -600,22 +598,18 @@ static int iowarrior_open(struct inode *inode, struct file *file)
 
 	subminor = iminor(inode);
 
-	/* prevent disconnects */
-	down(&amp;disconnect_sem);
-
 	interface = usb_find_interface(&amp;iowarrior_driver, subminor);
 	if (!interface) {
 		err("%s - error, can't find device for minor %d", __FUNCTION__,
 		    subminor);
-		retval = -ENODEV;
-		goto out;
+		return -ENODEV;
 	}
 
 	dev = usb_get_intfdata(interface);
-	if (!dev) {
-		retval = -ENODEV;
-		goto out;
-	}
+	if (!dev)
+		return -ENODEV;
+
+	mutex_lock(&amp;dev-&gt;mutex);
 
 	/* Only one process can open each device, no sharing. */
 	if (dev-&gt;opened) {
@@ -636,7 +630,7 @@ static int iowarrior_open(struct inode *inode, struct file *file)
 	retval = 0;
 
 out:
-	up(&amp;disconnect_sem);
+	mutex_unlock(&amp;dev-&gt;mutex);
 	return retval;
 }
 
@@ -868,19 +862,16 @@ static void iowarrior_disconnect(struct usb_interface *interface)
 	struct iowarrior *dev;
 	int minor;
 
-	/* prevent races with open() */
-	down(&amp;disconnect_sem);
-
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
-	mutex_lock(&amp;dev-&gt;mutex);
-
 	minor = dev-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;iowarrior_class);
 
+	mutex_lock(&amp;dev-&gt;mutex);
+
 	/* prevent device read, write and ioctl */
 	dev-&gt;present = 0;
 
@@ -898,7 +889,6 @@ static void iowarrior_disconnect(struct usb_interface *interface)
 		/* no process is using the device, cleanup now */
 		iowarrior_delete(dev);
 	}
-	up(&amp;disconnect_sem);
 
 	dev_info(&amp;interface-&gt;dev, "I/O-Warror #%d now disconnected\n",
 		 minor - IOWARRIOR_MINOR_BASE);
diff --git a/drivers/usb/misc/ldusb.c b/drivers/usb/misc/ldusb.c
index 7bad49404762..5e950b90c541 100644
--- a/drivers/usb/misc/ldusb.c
+++ b/drivers/usb/misc/ldusb.c
@@ -176,9 +176,6 @@ struct ld_usb {
 	int			interrupt_out_busy;
 };
 
-/* prevent races between open() and disconnect() */
-static DEFINE_MUTEX(disconnect_mutex);
-
 static struct usb_driver ld_usb_driver;
 
 /**
@@ -298,35 +295,28 @@ static int ld_usb_open(struct inode *inode, struct file *file)
 {
 	struct ld_usb *dev;
 	int subminor;
-	int retval = 0;
+	int retval;
 	struct usb_interface *interface;
 
 	nonseekable_open(inode, file);
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	interface = usb_find_interface(&amp;ld_usb_driver, subminor);
 
 	if (!interface) {
 		err("%s - error, can't find device for minor %d\n",
 		     __FUNCTION__, subminor);
-		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		return -ENODEV;
 	}
 
 	dev = usb_get_intfdata(interface);
 
-	if (!dev) {
-		retval = -ENODEV;
-		goto unlock_disconnect_exit;
-	}
+	if (!dev)
+		return -ENODEV;
 
 	/* lock this device */
-	if (down_interruptible(&amp;dev-&gt;sem)) {
-		retval = -ERESTARTSYS;
-		goto unlock_disconnect_exit;
-	}
+	if (down_interruptible(&amp;dev-&gt;sem))
+		return -ERESTARTSYS;
 
 	/* allow opening only once */
 	if (dev-&gt;open_count) {
@@ -366,9 +356,6 @@ static int ld_usb_open(struct inode *inode, struct file *file)
 unlock_exit:
 	up(&amp;dev-&gt;sem);
 
-unlock_disconnect_exit:
-	mutex_unlock(&amp;disconnect_mutex);
-
 	return retval;
 }
 
@@ -766,18 +753,16 @@ static void ld_usb_disconnect(struct usb_interface *intf)
 	struct ld_usb *dev;
 	int minor;
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	dev = usb_get_intfdata(intf);
 	usb_set_intfdata(intf, NULL);
 
-	down(&amp;dev-&gt;sem);
-
 	minor = intf-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev(intf, &amp;ld_usb_class);
 
+	down(&amp;dev-&gt;sem);
+
 	/* if the device is not opened, then we clean up right now */
 	if (!dev-&gt;open_count) {
 		up(&amp;dev-&gt;sem);
@@ -787,8 +772,6 @@ static void ld_usb_disconnect(struct usb_interface *intf)
 		up(&amp;dev-&gt;sem);
 	}
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	dev_info(&amp;intf-&gt;dev, "LD USB Device #%d now disconnected\n",
 		 (minor - USB_LD_MINOR_BASE));
 }
diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c
index 1713e19a7899..2ed0daea894c 100644
--- a/drivers/usb/misc/legousbtower.c
+++ b/drivers/usb/misc/legousbtower.c
@@ -254,9 +254,6 @@ static int  tower_probe	(struct usb_interface *interface, const struct usb_devic
 static void tower_disconnect	(struct usb_interface *interface);
 
 
-/* prevent races between open() and disconnect */
-static DEFINE_MUTEX (disconnect_mutex);
-
 /* file operations needed when we register this driver */
 static const struct file_operations tower_fops = {
 	.owner =	THIS_MODULE,
@@ -344,28 +341,26 @@ static int tower_open (struct inode *inode, struct file *file)
 	nonseekable_open(inode, file);
 	subminor = iminor(inode);
 
-	mutex_lock (&amp;disconnect_mutex);
-
 	interface = usb_find_interface (&amp;tower_driver, subminor);
 
 	if (!interface) {
 		err ("%s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
 		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		goto exit;
 	}
 
 	dev = usb_get_intfdata(interface);
 
 	if (!dev) {
 		retval = -ENODEV;
-		goto unlock_disconnect_exit;
+		goto exit;
 	}
 
 	/* lock this device */
 	if (down_interruptible (&amp;dev-&gt;sem)) {
 	        retval = -ERESTARTSYS;
-		goto unlock_disconnect_exit;
+		goto exit;
 	}
 
 	/* allow opening only once */
@@ -421,9 +416,7 @@ static int tower_open (struct inode *inode, struct file *file)
 unlock_exit:
 	up (&amp;dev-&gt;sem);
 
-unlock_disconnect_exit:
-	mutex_unlock (&amp;disconnect_mutex);
-
+exit:
 	dbg(2, "%s: leave, return value %d ", __FUNCTION__, retval);
 
 	return retval;
@@ -993,19 +986,16 @@ static void tower_disconnect (struct usb_interface *interface)
 
 	dbg(2, "%s: enter", __FUNCTION__);
 
-	mutex_lock (&amp;disconnect_mutex);
-
 	dev = usb_get_intfdata (interface);
 	usb_set_intfdata (interface, NULL);
 
-
-	down (&amp;dev-&gt;sem);
-
 	minor = dev-&gt;minor;
 
 	/* give back our minor */
 	usb_deregister_dev (interface, &amp;tower_class);
 
+	down (&amp;dev-&gt;sem);
+
 	/* if the device is not opened, then we clean up right now */
 	if (!dev-&gt;open_count) {
 		up (&amp;dev-&gt;sem);
@@ -1015,8 +1005,6 @@ static void tower_disconnect (struct usb_interface *interface)
 		up (&amp;dev-&gt;sem);
 	}
 
-	mutex_unlock (&amp;disconnect_mutex);
-
 	info("LEGO USB Tower #%d now disconnected", (minor - LEGO_USB_TOWER_MINOR_BASE));
 
 	dbg(2, "%s: leave", __FUNCTION__);
diff --git a/drivers/usb/misc/sisusbvga/sisusb.c b/drivers/usb/misc/sisusbvga/sisusb.c
index 6f8b134a79cb..9f37ba44c132 100644
--- a/drivers/usb/misc/sisusbvga/sisusb.c
+++ b/drivers/usb/misc/sisusbvga/sisusb.c
@@ -72,8 +72,6 @@ MODULE_PARM_DESC(last, "Number of last console to take over (1 - MAX_NR_CONSOLES
 
 static struct usb_driver sisusb_driver;
 
-DEFINE_MUTEX(disconnect_mutex);
-
 static void
 sisusb_free_buffers(struct sisusb_usb_data *sisusb)
 {
@@ -2511,31 +2509,24 @@ sisusb_open(struct inode *inode, struct file *file)
 	struct usb_interface *interface;
 	int subminor = iminor(inode);
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	if (!(interface = usb_find_interface(&amp;sisusb_driver, subminor))) {
 		printk(KERN_ERR "sisusb[%d]: Failed to find interface\n",
 				subminor);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -ENODEV;
 	}
 
-	if (!(sisusb = usb_get_intfdata(interface))) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = usb_get_intfdata(interface)))
 		return -ENODEV;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
 	if (!sisusb-&gt;present || !sisusb-&gt;ready) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -ENODEV;
 	}
 
 	if (sisusb-&gt;isopen) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return -EBUSY;
 	}
 
@@ -2543,7 +2534,6 @@ sisusb_open(struct inode *inode, struct file *file)
 		if (sisusb-&gt;sisusb_dev-&gt;speed == USB_SPEED_HIGH) {
 			if (sisusb_init_gfxdevice(sisusb, 0)) {
 				mutex_unlock(&amp;sisusb-&gt;lock);
-				mutex_unlock(&amp;disconnect_mutex);
 				printk(KERN_ERR
 					"sisusbvga[%d]: Failed to initialize "
 					"device\n",
@@ -2552,7 +2542,6 @@ sisusb_open(struct inode *inode, struct file *file)
 			}
 		} else {
 			mutex_unlock(&amp;sisusb-&gt;lock);
-			mutex_unlock(&amp;disconnect_mutex);
 			printk(KERN_ERR
 				"sisusbvga[%d]: Device not attached to "
 				"USB 2.0 hub\n",
@@ -2570,8 +2559,6 @@ sisusb_open(struct inode *inode, struct file *file)
 
 	mutex_unlock(&amp;sisusb-&gt;lock);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	return 0;
 }
 
@@ -2601,12 +2588,8 @@ sisusb_release(struct inode *inode, struct file *file)
 	struct sisusb_usb_data *sisusb;
 	int myminor;
 
-	mutex_lock(&amp;disconnect_mutex);
-
-	if (!(sisusb = (struct sisusb_usb_data *)file-&gt;private_data)) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = (struct sisusb_usb_data *)file-&gt;private_data))
 		return -ENODEV;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
@@ -2626,8 +2609,6 @@ sisusb_release(struct inode *inode, struct file *file)
 	/* decrement the usage count on our device */
 	kref_put(&amp;sisusb-&gt;kref, sisusb_delete);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	return 0;
 }
 
@@ -3383,12 +3364,9 @@ static void sisusb_disconnect(struct usb_interface *intf)
 	sisusb_console_exit(sisusb);
 #endif
 
-	/* The above code doesn't need the disconnect
-	 * semaphore to be down; its meaning is to
-	 * protect all other routines from the disconnect
-	 * case, not the other way round.
-	 */
-	mutex_lock(&amp;disconnect_mutex);
+	minor = sisusb-&gt;minor;
+
+	usb_deregister_dev(intf, &amp;usb_sisusb_class);
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
@@ -3396,12 +3374,8 @@ static void sisusb_disconnect(struct usb_interface *intf)
 	if (!sisusb_wait_all_out_complete(sisusb))
 		sisusb_kill_all_busy(sisusb);
 
-	minor = sisusb-&gt;minor;
-
 	usb_set_intfdata(intf, NULL);
 
-	usb_deregister_dev(intf, &amp;usb_sisusb_class);
-
 #ifdef SISUSB_OLD_CONFIG_COMPAT
 	if (sisusb-&gt;ioctl32registered) {
 		int ret;
@@ -3426,8 +3400,6 @@ static void sisusb_disconnect(struct usb_interface *intf)
 	/* decrement our usage count */
 	kref_put(&amp;sisusb-&gt;kref, sisusb_delete);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	printk(KERN_INFO "sisusbvga[%d]: Disconnected\n", minor);
 }
 
diff --git a/drivers/usb/misc/sisusbvga/sisusb_con.c b/drivers/usb/misc/sisusbvga/sisusb_con.c
index 5947afb0017e..8d0edc867f33 100644
--- a/drivers/usb/misc/sisusbvga/sisusb_con.c
+++ b/drivers/usb/misc/sisusbvga/sisusb_con.c
@@ -214,18 +214,13 @@ sisusbcon_init(struct vc_data *c, int init)
 	 * are set up/restored.
 	 */
 
-	mutex_lock(&amp;disconnect_mutex);
-
-	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num))) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num)))
 		return;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
 	if (!sisusb_sisusb_valid(sisusb)) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return;
 	}
 
@@ -264,8 +259,6 @@ sisusbcon_init(struct vc_data *c, int init)
 
 	mutex_unlock(&amp;sisusb-&gt;lock);
 
-	mutex_unlock(&amp;disconnect_mutex);
-
 	if (init) {
 		c-&gt;vc_cols = cols;
 		c-&gt;vc_rows = rows;
@@ -284,12 +277,8 @@ sisusbcon_deinit(struct vc_data *c)
 	 * and others, ie not under our control.
 	 */
 
-	mutex_lock(&amp;disconnect_mutex);
-
-	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num))) {
-		mutex_unlock(&amp;disconnect_mutex);
+	if (!(sisusb = sisusb_get_sisusb(c-&gt;vc_num)))
 		return;
-	}
 
 	mutex_lock(&amp;sisusb-&gt;lock);
 
@@ -314,8 +303,6 @@ sisusbcon_deinit(struct vc_data *c)
 
 	/* decrement the usage count on our sisusb */
 	kref_put(&amp;sisusb-&gt;kref, sisusb_delete);
-
-	mutex_unlock(&amp;disconnect_mutex);
 }
 
 /* interface routine */
@@ -1490,14 +1477,11 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 {
 	int i, ret, minor = sisusb-&gt;minor;
 
-	mutex_lock(&amp;disconnect_mutex);
-
 	mutex_lock(&amp;sisusb-&gt;lock);
 
 	/* Erm.. that should not happen */
 	if (sisusb-&gt;haveconsole || !sisusb-&gt;SiS_Pr) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return 1;
 	}
 
@@ -1508,14 +1492,12 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	    first &gt; MAX_NR_CONSOLES ||
 	    last &gt; MAX_NR_CONSOLES) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return 1;
 	}
 
 	/* If gfxcore not initialized or no consoles given, quit graciously */
 	if (!sisusb-&gt;gfxinit || first &lt; 1 || last &lt; 1) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		return 0;
 	}
 
@@ -1526,7 +1508,6 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	/* Set up text mode (and upload  default font) */
 	if (sisusb_reset_text_mode(sisusb, 1)) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		printk(KERN_ERR
 			"sisusbvga[%d]: Failed to set up text mode\n",
 			minor);
@@ -1550,7 +1531,6 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	/* Allocate screen buffer */
 	if (!(sisusb-&gt;scrbuf = (unsigned long)vmalloc(sisusb-&gt;scrbuf_size))) {
 		mutex_unlock(&amp;sisusb-&gt;lock);
-		mutex_unlock(&amp;disconnect_mutex);
 		printk(KERN_ERR
 			"sisusbvga[%d]: Failed to allocate screen buffer\n",
 			minor);
@@ -1558,7 +1538,6 @@ sisusb_console_init(struct sisusb_usb_data *sisusb, int first, int last)
 	}
 
 	mutex_unlock(&amp;sisusb-&gt;lock);
-	mutex_unlock(&amp;disconnect_mutex);
 
 	/* Now grab the desired console(s) */
 	ret = take_over_console(&amp;sisusb_con, first - 1, last - 1, 0);
diff --git a/drivers/usb/misc/sisusbvga/sisusb_init.h b/drivers/usb/misc/sisusbvga/sisusb_init.h
index f05f83268af4..864bc0e96591 100644
--- a/drivers/usb/misc/sisusbvga/sisusb_init.h
+++ b/drivers/usb/misc/sisusbvga/sisusb_init.h
@@ -808,8 +808,6 @@ static const struct SiS_VCLKData SiSUSB_VCLKData[] =
 	{ 0x2b,0xc2, 35}  /* 0x71 768@576@60 */
 };
 
-extern struct mutex disconnect_mutex;
-
 int		SiSUSBSetMode(struct SiS_Private *SiS_Pr, unsigned short ModeNo);
 int		SiSUSBSetVESAMode(struct SiS_Private *SiS_Pr, unsigned short VModeNo);
 
diff --git a/drivers/usb/misc/usblcd.c b/drivers/usb/misc/usblcd.c
index 12bad8a205a7..6e093c2aac2c 100644
--- a/drivers/usb/misc/usblcd.c
+++ b/drivers/usb/misc/usblcd.c
@@ -51,7 +51,6 @@ struct usb_lcd {
 #define USB_LCD_CONCURRENT_WRITES	5
 
 static struct usb_driver lcd_driver;
-static DEFINE_MUTEX(usb_lcd_open_mutex);
 
 
 static void lcd_delete(struct kref *kref)
@@ -69,24 +68,19 @@ static int lcd_open(struct inode *inode, struct file *file)
 	struct usb_lcd *dev;
 	struct usb_interface *interface;
 	int subminor;
-	int retval = 0;
 
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;usb_lcd_open_mutex);
 	interface = usb_find_interface(&amp;lcd_driver, subminor);
 	if (!interface) {
 		err ("USBLCD: %s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
-		retval = -ENODEV;
-		goto exit;
+		return -ENODEV;
 	}
 
 	dev = usb_get_intfdata(interface);
-	if (!dev) {
-		retval = -ENODEV;
-		goto exit;
-	}
+	if (!dev)
+		return -ENODEV;
 
 	/* increment our usage count for the device */
 	kref_get(&amp;dev-&gt;kref);
@@ -94,9 +88,7 @@ static int lcd_open(struct inode *inode, struct file *file)
 	/* save our object in the file's private structure */
 	file-&gt;private_data = dev;
 
-exit:
-	mutex_unlock(&amp;usb_lcd_open_mutex);
-	return retval;
+	return 0;
 }
 
 static int lcd_release(struct inode *inode, struct file *file)
@@ -363,17 +355,12 @@ static void lcd_disconnect(struct usb_interface *interface)
 	struct usb_lcd *dev;
         int minor = interface-&gt;minor;
 
-        /* prevent skel_open() from racing skel_disconnect() */
-        mutex_lock(&amp;usb_lcd_open_mutex);
-
         dev = usb_get_intfdata(interface);
         usb_set_intfdata(interface, NULL);
 
         /* give back our minor */
         usb_deregister_dev(interface, &amp;lcd_class);
  
-	mutex_unlock(&amp;usb_lcd_open_mutex);
-
 	/* decrement our usage count */
 	kref_put(&amp;dev-&gt;kref, lcd_delete);
 
diff --git a/drivers/usb/usb-skeleton.c b/drivers/usb/usb-skeleton.c
index 8432bf171d2e..38f8e4df9dd6 100644
--- a/drivers/usb/usb-skeleton.c
+++ b/drivers/usb/usb-skeleton.c
@@ -34,9 +34,6 @@ static struct usb_device_id skel_table [] = {
 };
 MODULE_DEVICE_TABLE(usb, skel_table);
 
-/* to prevent a race between open and disconnect */
-static DEFINE_MUTEX(skel_open_lock);
-
 
 /* Get a minor range for your devices from the usb maintainer */
 #define USB_SKEL_MINOR_BASE	192
@@ -83,10 +80,8 @@ static int skel_open(struct inode *inode, struct file *file)
 
 	subminor = iminor(inode);
 
-	mutex_lock(&amp;skel_open_lock);
 	interface = usb_find_interface(&amp;skel_driver, subminor);
 	if (!interface) {
-		mutex_unlock(&amp;skel_open_lock);
 		err ("%s - error, can't find device for minor %d",
 		     __FUNCTION__, subminor);
 		retval = -ENODEV;
@@ -95,15 +90,12 @@ static int skel_open(struct inode *inode, struct file *file)
 
 	dev = usb_get_intfdata(interface);
 	if (!dev) {
-		mutex_unlock(&amp;skel_open_lock);
 		retval = -ENODEV;
 		goto exit;
 	}
 
 	/* increment our usage count for the device */
 	kref_get(&amp;dev-&gt;kref);
-	/* now we can drop the lock */
-	mutex_unlock(&amp;skel_open_lock);
 
 	/* prevent the device from being autosuspended */
 	retval = usb_autopm_get_interface(interface);
@@ -368,23 +360,17 @@ static void skel_disconnect(struct usb_interface *interface)
 	struct usb_skel *dev;
 	int minor = interface-&gt;minor;
 
-	/* prevent skel_open() from racing skel_disconnect() */
-	mutex_lock(&amp;skel_open_lock);
-
 	dev = usb_get_intfdata(interface);
 	usb_set_intfdata(interface, NULL);
 
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;skel_class);
-	mutex_unlock(&amp;skel_open_lock);
 
 	/* prevent more I/O from starting */
 	mutex_lock(&amp;dev-&gt;io_mutex);
 	dev-&gt;interface = NULL;
 	mutex_unlock(&amp;dev-&gt;io_mutex);
 
-
-
 	/* decrement our usage count */
 	kref_put(&amp;dev-&gt;kref, skel_delete);
 </pre><hr><pre>commit dd4dd19e8d13e1e9bf8295bf71f132b511b130bf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:55:54 2007 -0400

    USB: Make device reset stop retrying after disconnect
    
    This patch (as898) changes the port reset code in the hub driver.  If
    a connect change occurs, it is reported the same way as a disconnect
    (which of course is what it really is).
    
    It also changes usb_reset_device(), to prevent the routine from futilely
    retrying the reset after a disconnect has occurred.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d37ad083d5ef..f4ef7c25096e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1539,9 +1539,9 @@ static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 		if (!(portstatus &amp; USB_PORT_STAT_CONNECTION))
 			return -ENOTCONN;
 
-		/* bomb out completely if something weird happened */
+		/* bomb out completely if the connection bounced */
 		if ((portchange &amp; USB_PORT_STAT_C_CONNECTION))
-			return -EINVAL;
+			return -ENOTCONN;
 
 		/* if we`ve finished resetting, then break out of the loop */
 		if (!(portstatus &amp; USB_PORT_STAT_RESET) &amp;&amp;
@@ -2974,7 +2974,7 @@ int usb_reset_device(struct usb_device *udev)
 		 * Other endpoints will be handled by re-enumeration. */
 		ep0_reinit(udev);
 		ret = hub_port_init(parent_hub, udev, port1, i);
-		if (ret &gt;= 0)
+		if (ret &gt;= 0 || ret == -ENOTCONN || ret == -ENODEV)
 			break;
 	}
 	clear_bit(port1, parent_hub-&gt;busy_bits);</pre><hr><pre>commit 3c519b846c4d5edf7c94d1eede42445a815bf65c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:55:31 2007 -0400

    USB: EHCI: fix handover for designated full-speed ports
    
    This patch (as895) fixes up a loose end in the port-handover code for
    the USB-Persist facility.  A special case occurs when a high-speed
    device is attached to a port which the user has designated to run at
    full-speed only; the port must be disabled before the handover can
    take place.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 3e80de7c7f5b..27291f502651 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -60,11 +60,13 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	while (port--) {
 		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
 			reg = &amp;ehci-&gt;regs-&gt;port_status[port];
-			status = ehci_readl(ehci, reg);
+			status = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
 
 			/* Port already owned by companion? */
 			if (status &amp; PORT_OWNER)
 				clear_bit(port, &amp;ehci-&gt;owned_ports);
+			else if (test_bit(port, &amp;ehci-&gt;companion_ports))
+				ehci_writel(ehci, status &amp; ~PORT_PE, reg);
 			else
 				ehci_hub_control(hcd, SetPortFeature,
 						USB_PORT_FEAT_RESET, port + 1,</pre><hr><pre>commit 6bc6cff52e0c4c4c876b1b8a5750041da61ad42b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 4 11:53:03 2007 -0400

    USB: add RESET_RESUME device quirk
    
    This patch (as888) adds a new USB device quirk for devices which are
    unable to resume correctly.  By using the new code added for the
    USB-persist facility, it is a simple matter to reset these devices
    instead of resuming them.  To get things kicked off, a quirk entry is
    added for the Philips PSC805.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 12dd986bdffd..02d6db61c940 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -24,6 +24,7 @@
 
 #include &lt;linux/device.h&gt;
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/quirks.h&gt;
 #include &lt;linux/workqueue.h&gt;
 #include "hcd.h"
 #include "usb.h"
@@ -835,6 +836,9 @@ static int usb_resume_device(struct usb_device *udev)
 		goto done;
 	}
 
+	if (udev-&gt;quirks &amp; USB_QUIRK_RESET_RESUME)
+		udev-&gt;reset_resume = 1;
+
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;resume(udev);
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 51d2d304568b..d37ad083d5ef 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2939,6 +2939,11 @@ static int config_descriptors_changed(struct usb_device *udev)
  * this from a driver probe() routine after downloading new firmware.
  * For calls that might not occur during probe(), drivers should lock
  * the device using usb_lock_device_for_reset().
+ *
+ * Locking exception: This routine may also be called from within an
+ * autoresume handler.  Such usage won't conflict with other tasks
+ * holding the device lock because these tasks should always call
+ * usb_autopm_resume_device(), thereby preventing any unwanted autoresume.
  */
 int usb_reset_device(struct usb_device *udev)
 {
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 739f520908aa..f37fa012f329 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -35,6 +35,9 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* Elsa MicroLink 56k (V.250) */
 	{ USB_DEVICE(0x05cc, 0x2267), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 
+	/* Philips PSC805 audio device */
+	{ USB_DEVICE(0x0471, 0x0155), .driver_info = USB_QUIRK_RESET_RESUME },
+
 	{ }  /* terminating entry must be last */
 };
 
diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h
index 6bac8faacbc6..8da374caf582 100644
--- a/include/linux/usb/quirks.h
+++ b/include/linux/usb/quirks.h
@@ -9,3 +9,6 @@
 
 /* string descriptors must not be fetched using a 255-byte read */
 #define USB_QUIRK_STRING_FETCH_255	0x00000002
+
+/* device can't resume correctly so reset it instead */
+#define USB_QUIRK_RESET_RESUME		0x00000004</pre>
    <div class="pagination">
        <a href='2_106.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><span>[107]</span><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_108.html'>Next&gt;&gt;</a>
    <div>
</body>
