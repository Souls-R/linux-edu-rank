<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_101.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><span>[102]</span><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_103.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit abda14189251563a50f56da5ea2e37e904ac4cba
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Jan 6 00:20:32 2009 -0500

    ext4: Make printk's consistently prefixed with "EXT4-fs: "
    
    Previously, some were "ext4: ", and some were "EXT4: "; change them to
    be consistent with most ext4 printk's, which is to use "EXT4-fs: ".
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index cf3ccf4a94b0..2df2e40b01af 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -405,7 +405,7 @@ static int call_filldir(struct file *filp, void *dirent,
 	sb = inode-&gt;i_sb;
 
 	if (!fname) {
-		printk(KERN_ERR "ext4: call_filldir: called with "
+		printk(KERN_ERR "EXT4-fs: call_filldir: called with "
 		       "null fname?!?\n");
 		return 0;
 	}
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 517c90ad25bd..b69d09203865 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -505,7 +505,7 @@ static struct block_device *ext4_blkdev_get(dev_t dev)
 	return bdev;
 
 fail:
-	printk(KERN_ERR "EXT4: failed to open journal device %s: %ld\n",
+	printk(KERN_ERR "EXT4-fs: failed to open journal device %s: %ld\n",
 			__bdevname(dev, b), PTR_ERR(bdev));
 	return NULL;
 }
@@ -2485,7 +2485,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	if (ext4_blocks_count(es) &gt; 0xffffffffULL &amp;&amp;
 	    !jbd2_journal_set_features(EXT4_SB(sb)-&gt;s_journal, 0, 0,
 				       JBD2_FEATURE_INCOMPAT_64BIT)) {
-		printk(KERN_ERR "ext4: Failed to set 64-bit journal feature\n");
+		printk(KERN_ERR "EXT4-fs: Failed to set 64-bit journal feature\n");
 		goto failed_mount4;
 	}
 
@@ -2766,7 +2766,7 @@ static journal_t *ext4_get_dev_journal(struct super_block *sb,
 
 	if (bd_claim(bdev, sb)) {
 		printk(KERN_ERR
-			"EXT4: failed to claim external journal device.\n");
+			"EXT4-fs: failed to claim external journal device.\n");
 		blkdev_put(bdev, FMODE_READ|FMODE_WRITE);
 		return NULL;
 	}
@@ -2949,7 +2949,7 @@ static void ext4_commit_super(struct super_block *sb,
 		 * be remapped.  Nothing we can do but to retry the
 		 * write and hope for the best.
 		 */
-		printk(KERN_ERR "ext4: previous I/O error to "
+		printk(KERN_ERR "EXT4-fs: previous I/O error to "
 		       "superblock detected for %s.\n", sb-&gt;s_id);
 		clear_buffer_write_io_error(sbh);
 		set_buffer_uptodate(sbh);
@@ -2965,7 +2965,7 @@ static void ext4_commit_super(struct super_block *sb,
 	if (sync) {
 		sync_dirty_buffer(sbh);
 		if (buffer_write_io_error(sbh)) {
-			printk(KERN_ERR "ext4: I/O error while writing "
+			printk(KERN_ERR "EXT4-fs: I/O error while writing "
 			       "superblock for %s.\n", sb-&gt;s_id);
 			clear_buffer_write_io_error(sbh);
 			set_buffer_uptodate(sbh);</pre><hr><pre>commit 4ec110281379826c5cf6ed14735e47027c3c5765
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Jan 6 14:53:26 2009 -0500

    ext4: Add sanity checks for the superblock before mounting the filesystem
    
    This avoids insane superblock configurations that could lead to kernel
    oops due to null pointer derefences.
    
    http://bugzilla.kernel.org/show_bug.cgi?id=12371
    
    Thanks to David Maciejak at Fortinet's FortiGuard Global Security
    Research Team who discovered this bug independently (but at
    approximately the same time) as Thiemo Nagel, who submitted the patch.
    
    Signed-off-by: Thiemo Nagel &lt;thiemo.nagel@ph.tum.de&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@kernel.org

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 8ff8709828fd..517c90ad25bd 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -2041,8 +2041,8 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	const char *descr;
 	int ret = -EINVAL;
 	int blocksize;
-	int db_count;
-	int i;
+	unsigned int db_count;
+	unsigned int i;
 	int needs_recovery, has_huge_files;
 	int features;
 	__u64 blocks_count;
@@ -2331,20 +2331,30 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	if (EXT4_BLOCKS_PER_GROUP(sb) == 0)
 		goto cantfind_ext4;
 
-	/* ensure blocks_count calculation below doesn't sign-extend */
-	if (ext4_blocks_count(es) + EXT4_BLOCKS_PER_GROUP(sb) &lt;
-	    le32_to_cpu(es-&gt;s_first_data_block) + 1) {
-		printk(KERN_WARNING "EXT4-fs: bad geometry: block count %llu, "
-		       "first data block %u, blocks per group %lu\n",
-			ext4_blocks_count(es),
-			le32_to_cpu(es-&gt;s_first_data_block),
-			EXT4_BLOCKS_PER_GROUP(sb));
+        /*
+         * It makes no sense for the first data block to be beyond the end
+         * of the filesystem.
+         */
+        if (le32_to_cpu(es-&gt;s_first_data_block) &gt;= ext4_blocks_count(es)) {
+                printk(KERN_WARNING "EXT4-fs: bad geometry: first data"
+		       "block %u is beyond end of filesystem (%llu)\n",
+		       le32_to_cpu(es-&gt;s_first_data_block),
+		       ext4_blocks_count(es));
 		goto failed_mount;
 	}
 	blocks_count = (ext4_blocks_count(es) -
 			le32_to_cpu(es-&gt;s_first_data_block) +
 			EXT4_BLOCKS_PER_GROUP(sb) - 1);
 	do_div(blocks_count, EXT4_BLOCKS_PER_GROUP(sb));
+	if (blocks_count &gt; ((uint64_t)1&lt;&lt;32) - EXT4_DESC_PER_BLOCK(sb)) {
+		printk(KERN_WARNING "EXT4-fs: groups count too large: %u "
+		       "(block count %llu, first data block %u, "
+		       "blocks per group %lu)\n", sbi-&gt;s_groups_count,
+		       ext4_blocks_count(es),
+		       le32_to_cpu(es-&gt;s_first_data_block),
+		       EXT4_BLOCKS_PER_GROUP(sb));
+		goto failed_mount;
+	}
 	sbi-&gt;s_groups_count = blocks_count;
 	db_count = (sbi-&gt;s_groups_count + EXT4_DESC_PER_BLOCK(sb) - 1) /
 		   EXT4_DESC_PER_BLOCK(sb);</pre><hr><pre>commit b3881f74b31b7d47d0f1c4d89ac3e7f0b9c05e3e
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Jan 5 22:46:26 2009 -0500

    ext4: Add mount option to set kjournald's I/O priority
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Jens Axboe &lt;jens.axboe@oracle.com&gt;

diff --git a/Documentation/filesystems/ext4.txt b/Documentation/filesystems/ext4.txt
index 9ec29d86ff8b..8938949b201e 100644
--- a/Documentation/filesystems/ext4.txt
+++ b/Documentation/filesystems/ext4.txt
@@ -308,6 +308,13 @@ min_batch_time=usec	This parameter sets the commit time (as
 			multi-threaded, synchronous workloads on very
 			fast disks, at the cost of increasing latency.
 
+journal_ioprio=prio	The I/O priority (from 0 to 7, where 0 is the
+			highest priorty) which should be used for I/O
+			operations submitted by kjournald2 during a
+			commit operation.  This defaults to 3, which is
+			a slightly higher priority than the default I/O
+			priority.
+
 Data Mode
 =========
 There are 3 different data modes:
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 8036392b2121..8ff8709828fd 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -1013,7 +1013,7 @@ enum {
 	Opt_ignore, Opt_barrier, Opt_err, Opt_resize, Opt_usrquota,
 	Opt_grpquota, Opt_extents, Opt_noextents, Opt_i_version,
 	Opt_stripe, Opt_delalloc, Opt_nodelalloc,
-	Opt_inode_readahead_blks
+	Opt_inode_readahead_blks, Opt_journal_ioprio
 };
 
 static const match_table_t tokens = {
@@ -1074,6 +1074,7 @@ static const match_table_t tokens = {
 	{Opt_delalloc, "delalloc"},
 	{Opt_nodelalloc, "nodelalloc"},
 	{Opt_inode_readahead_blks, "inode_readahead_blks=%u"},
+	{Opt_journal_ioprio, "journal_ioprio=%u"},
 	{Opt_err, NULL},
 };
 
@@ -1098,8 +1099,11 @@ static ext4_fsblk_t get_sb_block(void **data)
 	return sb_block;
 }
 
+#define DEFAULT_JOURNAL_IOPRIO (IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE, 3))
+
 static int parse_options(char *options, struct super_block *sb,
 			 unsigned long *journal_devnum,
+			 unsigned int *journal_ioprio,
 			 ext4_fsblk_t *n_blocks_count, int is_remount)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
@@ -1492,6 +1496,14 @@ static int parse_options(char *options, struct super_block *sb,
 				return 0;
 			sbi-&gt;s_inode_readahead_blks = option;
 			break;
+		case Opt_journal_ioprio:
+			if (match_int(&amp;args[0], &amp;option))
+				return 0;
+			if (option &lt; 0 || option &gt; 7)
+				break;
+			*journal_ioprio = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_BE,
+							    option);
+			break;
 		default:
 			printk(KERN_ERR
 			       "EXT4-fs: Unrecognized mount option \"%s\" "
@@ -2035,6 +2047,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	int features;
 	__u64 blocks_count;
 	int err;
+	unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;
 
 	sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);
 	if (!sbi)
@@ -2141,7 +2154,8 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	set_opt(sbi-&gt;s_mount_opt, DELALLOC);
 
 
-	if (!parse_options((char *) data, sb, &amp;journal_devnum, NULL, 0))
+	if (!parse_options((char *) data, sb, &amp;journal_devnum,
+			   &amp;journal_ioprio, NULL, 0))
 		goto failed_mount;
 
 	sb-&gt;s_flags = (sb-&gt;s_flags &amp; ~MS_POSIXACL) |
@@ -2506,6 +2520,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	default:
 		break;
 	}
+	set_task_ioprio(sbi-&gt;s_journal-&gt;j_task, journal_ioprio);
 
 no_journal:
 
@@ -3127,6 +3142,7 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 	unsigned long old_sb_flags;
 	struct ext4_mount_options old_opts;
 	ext4_group_t g;
+	unsigned int journal_ioprio = DEFAULT_JOURNAL_IOPRIO;
 	int err;
 #ifdef CONFIG_QUOTA
 	int i;
@@ -3145,11 +3161,14 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 	for (i = 0; i &lt; MAXQUOTAS; i++)
 		old_opts.s_qf_names[i] = sbi-&gt;s_qf_names[i];
 #endif
+	if (sbi-&gt;s_journal &amp;&amp; sbi-&gt;s_journal-&gt;j_task-&gt;io_context)
+		journal_ioprio = sbi-&gt;s_journal-&gt;j_task-&gt;io_context-&gt;ioprio;
 
 	/*
 	 * Allow the "check" option to be passed as a remount option.
 	 */
-	if (!parse_options(data, sb, NULL, &amp;n_blocks_count, 1)) {
+	if (!parse_options(data, sb, NULL, &amp;journal_ioprio,
+			   &amp;n_blocks_count, 1)) {
 		err = -EINVAL;
 		goto restore_opts;
 	}
@@ -3162,8 +3181,10 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 
 	es = sbi-&gt;s_es;
 
-	if (sbi-&gt;s_journal)
+	if (sbi-&gt;s_journal) {
 		ext4_init_journal_params(sb, sbi-&gt;s_journal);
+		set_task_ioprio(sbi-&gt;s_journal-&gt;j_task, journal_ioprio);
+	}
 
 	if ((*flags &amp; MS_RDONLY) != (sb-&gt;s_flags &amp; MS_RDONLY) ||
 		n_blocks_count &gt; ext4_blocks_count(es)) {
diff --git a/fs/ioprio.c b/fs/ioprio.c
index 3569e0ad86a2..1a39ac370942 100644
--- a/fs/ioprio.c
+++ b/fs/ioprio.c
@@ -27,7 +27,7 @@
 #include &lt;linux/security.h&gt;
 #include &lt;linux/pid_namespace.h&gt;
 
-static int set_task_ioprio(struct task_struct *task, int ioprio)
+int set_task_ioprio(struct task_struct *task, int ioprio)
 {
 	int err;
 	struct io_context *ioc;
@@ -70,6 +70,7 @@ static int set_task_ioprio(struct task_struct *task, int ioprio)
 	task_unlock(task);
 	return err;
 }
+EXPORT_SYMBOL_GPL(set_task_ioprio);
 
 asmlinkage long sys_ioprio_set(int which, int who, int ioprio)
 {
diff --git a/include/linux/ioprio.h b/include/linux/ioprio.h
index f98a656b17e5..76dad4808847 100644
--- a/include/linux/ioprio.h
+++ b/include/linux/ioprio.h
@@ -86,4 +86,6 @@ static inline int task_nice_ioclass(struct task_struct *task)
  */
 extern int ioprio_best(unsigned short aprio, unsigned short bprio);
 
+extern int set_task_ioprio(struct task_struct *task, int ioprio);
+
 #endif</pre><hr><pre>commit 40a1984d22294ab202f616e432bb8d3481897675
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Jan 4 19:55:57 2009 -0500

    jbd2: Submit writes to the journal using WRITE_SYNC
    
    Since we will be waiting the write of the commit record to the journal
    to complete in journal_submit_commit_record(), submit it using
    WRITE_SYNC.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c
index 0ad84162c425..073124a29b8c 100644
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@ -138,7 +138,7 @@ static int journal_submit_commit_record(journal_t *journal,
 		set_buffer_ordered(bh);
 		barrier_done = 1;
 	}
-	ret = submit_bh(WRITE, bh);
+	ret = submit_bh(WRITE_SYNC, bh);
 	if (barrier_done)
 		clear_buffer_ordered(bh);
 
@@ -159,7 +159,7 @@ static int journal_submit_commit_record(journal_t *journal,
 		lock_buffer(bh);
 		set_buffer_uptodate(bh);
 		clear_buffer_dirty(bh);
-		ret = submit_bh(WRITE, bh);
+		ret = submit_bh(WRITE_SYNC, bh);
 	}
 	*cbh = bh;
 	return ret;</pre><hr><pre>commit 4a9bf99b205448ec1f0cbdee1776a29f9c503ce4
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Jan 3 22:56:44 2009 -0500

    jbd2: Add pid and journal device name to the "kjournald2 starting" message
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index b10d7283ba5b..fe20e40ee7c3 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -131,8 +131,9 @@ static int kjournald2(void *arg)
 	journal-&gt;j_task = current;
 	wake_up(&amp;journal-&gt;j_wait_done_commit);
 
-	printk(KERN_INFO "kjournald2 starting.  Commit interval %ld seconds\n",
-			journal-&gt;j_commit_interval / HZ);
+	printk(KERN_INFO "kjournald2 starting: pid %d, dev %s, "
+	       "commit interval %ld seconds\n", current-&gt;pid,
+	       journal-&gt;j_devname, journal-&gt;j_commit_interval / HZ);
 
 	/*
 	 * And now, wait forever for commit wakeup events.</pre><hr><pre>commit ba80b1019aa722b24506db1ee755e0bb2f513022
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Jan 3 20:03:21 2009 -0500

    ext4: Add markers for better debuggability
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index e3aa3fa38608..369c34c64292 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -210,6 +210,11 @@ void ext4_free_inode(handle_t *handle, struct inode *inode)
 
 	ino = inode-&gt;i_ino;
 	ext4_debug("freeing inode %lu\n", ino);
+	trace_mark(ext4_free_inode,
+		   "dev %s ino %lu mode %d uid %lu gid %lu bocks %llu",
+		   sb-&gt;s_id, inode-&gt;i_ino, inode-&gt;i_mode,
+		   (unsigned long) inode-&gt;i_uid, (unsigned long) inode-&gt;i_gid,
+		   (unsigned long long) inode-&gt;i_blocks);
 
 	/*
 	 * Note: we must free any quota before locking the superblock,
@@ -698,6 +703,8 @@ struct inode *ext4_new_inode(handle_t *handle, struct inode *dir, int mode)
 		return ERR_PTR(-EPERM);
 
 	sb = dir-&gt;i_sb;
+	trace_mark(ext4_request_inode, "dev %s dir %lu mode %d", sb-&gt;s_id,
+		   dir-&gt;i_ino, mode);
 	inode = new_inode(sb);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
@@ -925,6 +932,8 @@ struct inode *ext4_new_inode(handle_t *handle, struct inode *dir, int mode)
 	}
 
 	ext4_debug("allocating inode %lu\n", inode-&gt;i_ino);
+	trace_mark(ext4_allocate_inode, "dev %s ino %lu dir %lu mode %d",
+		   sb-&gt;s_id, inode-&gt;i_ino, dir-&gt;i_ino, mode);
 	goto really_out;
 fail:
 	ext4_std_error(sb, err);
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 56142accf5cd..4cac8da4e0c1 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1351,6 +1351,10 @@ static int ext4_write_begin(struct file *file, struct address_space *mapping,
  	pgoff_t index;
 	unsigned from, to;
 
+	trace_mark(ext4_write_begin,
+		   "dev %s ino %lu pos %llu len %u flags %u",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
+		   (unsigned long long) pos, len, flags);
  	index = pos &gt;&gt; PAGE_CACHE_SHIFT;
 	from = pos &amp; (PAGE_CACHE_SIZE - 1);
 	to = from + len;
@@ -1422,6 +1426,10 @@ static int ext4_ordered_write_end(struct file *file,
 	struct inode *inode = mapping-&gt;host;
 	int ret = 0, ret2;
 
+	trace_mark(ext4_ordered_write_end,
+		   "dev %s ino %lu pos %llu len %u copied %u",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
+		   (unsigned long long) pos, len, copied);
 	ret = ext4_jbd2_file_inode(handle, inode);
 
 	if (ret == 0) {
@@ -1460,6 +1468,10 @@ static int ext4_writeback_write_end(struct file *file,
 	int ret = 0, ret2;
 	loff_t new_i_size;
 
+	trace_mark(ext4_writeback_write_end,
+		   "dev %s ino %lu pos %llu len %u copied %u",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
+		   (unsigned long long) pos, len, copied);
 	new_i_size = pos + copied;
 	if (new_i_size &gt; EXT4_I(inode)-&gt;i_disksize) {
 		ext4_update_i_disksize(inode, new_i_size);
@@ -1495,6 +1507,10 @@ static int ext4_journalled_write_end(struct file *file,
 	unsigned from, to;
 	loff_t new_i_size;
 
+	trace_mark(ext4_journalled_write_end,
+		   "dev %s ino %lu pos %llu len %u copied %u",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
+		   (unsigned long long) pos, len, copied);
 	from = pos &amp; (PAGE_CACHE_SIZE - 1);
 	to = from + len;
 
@@ -2311,6 +2327,9 @@ static int ext4_da_writepage(struct page *page,
 	struct buffer_head *page_bufs;
 	struct inode *inode = page-&gt;mapping-&gt;host;
 
+	trace_mark(ext4_da_writepage,
+		   "dev %s ino %lu page_index %lu",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino, page-&gt;index);
 	size = i_size_read(inode);
 	if (page-&gt;index == size &gt;&gt; PAGE_CACHE_SHIFT)
 		len = size &amp; ~PAGE_CACHE_MASK;
@@ -2421,6 +2440,20 @@ static int ext4_da_writepages(struct address_space *mapping,
 	int needed_blocks, ret = 0, nr_to_writebump = 0;
 	struct ext4_sb_info *sbi = EXT4_SB(mapping-&gt;host-&gt;i_sb);
 
+	trace_mark(ext4_da_writepages,
+		   "dev %s ino %lu nr_t_write %ld "
+		   "pages_skipped %ld range_start %llu "
+		   "range_end %llu nonblocking %d "
+		   "for_kupdate %d for_reclaim %d "
+		   "for_writepages %d range_cyclic %d",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
+		   wbc-&gt;nr_to_write, wbc-&gt;pages_skipped,
+		   (unsigned long long) wbc-&gt;range_start,
+		   (unsigned long long) wbc-&gt;range_end,
+		   wbc-&gt;nonblocking, wbc-&gt;for_kupdate,
+		   wbc-&gt;for_reclaim, wbc-&gt;for_writepages,
+		   wbc-&gt;range_cyclic);
+
 	/*
 	 * No pages to write? This is mainly a kludge to avoid starting
 	 * a transaction for special inodes like journal inode on last iput()
@@ -2539,6 +2572,14 @@ static int ext4_da_writepages(struct address_space *mapping,
 	if (!no_nrwrite_index_update)
 		wbc-&gt;no_nrwrite_index_update = 0;
 	wbc-&gt;nr_to_write -= nr_to_writebump;
+	trace_mark(ext4_da_writepage_result,
+		   "dev %s ino %lu ret %d pages_written %d "
+		   "pages_skipped %ld congestion %d "
+		   "more_io %d no_nrwrite_index_update %d",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino, ret,
+		   pages_written, wbc-&gt;pages_skipped,
+		   wbc-&gt;encountered_congestion, wbc-&gt;more_io,
+		   wbc-&gt;no_nrwrite_index_update);
 	return ret;
 }
 
@@ -2590,6 +2631,11 @@ static int ext4_da_write_begin(struct file *file, struct address_space *mapping,
 					len, flags, pagep, fsdata);
 	}
 	*fsdata = (void *)0;
+
+	trace_mark(ext4_da_write_begin,
+		   "dev %s ino %lu pos %llu len %u flags %u",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
+		   (unsigned long long) pos, len, flags);
 retry:
 	/*
 	 * With delayed allocation, we don't log the i_disksize update
@@ -2679,6 +2725,10 @@ static int ext4_da_write_end(struct file *file,
 		}
 	}
 
+	trace_mark(ext4_da_write_end,
+		   "dev %s ino %lu pos %llu len %u copied %u",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
+		   (unsigned long long) pos, len, copied);
 	start = pos &amp; (PAGE_CACHE_SIZE - 1);
 	end = start + copied - 1;
 
@@ -2892,6 +2942,9 @@ static int ext4_normal_writepage(struct page *page,
 	loff_t size = i_size_read(inode);
 	loff_t len;
 
+	trace_mark(ext4_normal_writepage,
+		   "dev %s ino %lu page_index %lu",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino, page-&gt;index);
 	J_ASSERT(PageLocked(page));
 	if (page-&gt;index == size &gt;&gt; PAGE_CACHE_SHIFT)
 		len = size &amp; ~PAGE_CACHE_MASK;
@@ -2977,6 +3030,9 @@ static int ext4_journalled_writepage(struct page *page,
 	loff_t size = i_size_read(inode);
 	loff_t len;
 
+	trace_mark(ext4_journalled_writepage,
+		   "dev %s ino %lu page_index %lu",
+		   inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino, page-&gt;index);
 	J_ASSERT(PageLocked(page));
 	if (page-&gt;index == size &gt;&gt; PAGE_CACHE_SHIFT)
 		len = size &amp; ~PAGE_CACHE_MASK;
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 05d9f81956c6..918aec0c8a11 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -2878,8 +2878,9 @@ static void release_blocks_on_commit(journal_t *journal, transaction_t *txn)
 		discard_block = (ext4_fsblk_t) entry-&gt;group * EXT4_BLOCKS_PER_GROUP(sb)
 			+ entry-&gt;start_blk
 			+ le32_to_cpu(EXT4_SB(sb)-&gt;s_es-&gt;s_first_data_block);
-		trace_mark(ext4_discard_blocks, "dev %s blk %llu count %u", sb-&gt;s_id,
-			   (unsigned long long) discard_block, entry-&gt;count);
+		trace_mark(ext4_discard_blocks, "dev %s blk %llu count %u",
+			   sb-&gt;s_id, (unsigned long long) discard_block,
+			   entry-&gt;count);
 		sb_issue_discard(sb, discard_block, entry-&gt;count);
 
 		kmem_cache_free(ext4_free_ext_cachep, entry);
@@ -3697,6 +3698,10 @@ ext4_mb_new_inode_pa(struct ext4_allocation_context *ac)
 
 	mb_debug("new inode pa %p: %llu/%u for %u\n", pa,
 			pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);
+	trace_mark(ext4_mb_new_inode_pa,
+		   "dev %s ino %lu pstart %llu len %u lstart %u",
+		   sb-&gt;s_id, ac-&gt;ac_inode-&gt;i_ino,
+		   pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);
 
 	ext4_mb_use_inode_pa(ac, pa);
 	atomic_add(pa-&gt;pa_free, &amp;EXT4_SB(sb)-&gt;s_mb_preallocated);
@@ -3754,7 +3759,9 @@ ext4_mb_new_group_pa(struct ext4_allocation_context *ac)
 	pa-&gt;pa_linear = 1;
 
 	mb_debug("new group pa %p: %llu/%u for %u\n", pa,
-			pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);
+		 pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);
+	trace_mark(ext4_mb_new_group_pa, "dev %s pstart %llu len %u lstart %u",
+		   sb-&gt;s_id, pa-&gt;pa_pstart, pa-&gt;pa_len, pa-&gt;pa_lstart);
 
 	ext4_mb_use_group_pa(ac, pa);
 	atomic_add(pa-&gt;pa_free, &amp;EXT4_SB(sb)-&gt;s_mb_preallocated);
@@ -3807,12 +3814,14 @@ ext4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,
 	unsigned int next;
 	ext4_group_t group;
 	ext4_grpblk_t bit;
+	unsigned long long grp_blk_start;
 	sector_t start;
 	int err = 0;
 	int free = 0;
 
 	BUG_ON(pa-&gt;pa_deleted == 0);
 	ext4_get_group_no_and_offset(sb, pa-&gt;pa_pstart, &amp;group, &amp;bit);
+	grp_blk_start = pa-&gt;pa_pstart - bit;
 	BUG_ON(group != e4b-&gt;bd_group &amp;&amp; pa-&gt;pa_len != 0);
 	end = bit + pa-&gt;pa_len;
 
@@ -3842,6 +3851,10 @@ ext4_mb_release_inode_pa(struct ext4_buddy *e4b, struct buffer_head *bitmap_bh,
 			ext4_mb_store_history(ac);
 		}
 
+		trace_mark(ext4_mb_release_inode_pa,
+			   "dev %s ino %lu block %llu count %u",
+			   sb-&gt;s_id, pa-&gt;pa_inode-&gt;i_ino, grp_blk_start + bit,
+			   next - bit);
 		mb_free_blocks(pa-&gt;pa_inode, e4b, bit, next - bit);
 		bit = next + 1;
 	}
@@ -3875,6 +3888,8 @@ ext4_mb_release_group_pa(struct ext4_buddy *e4b,
 	if (ac)
 		ac-&gt;ac_op = EXT4_MB_HISTORY_DISCARD;
 
+	trace_mark(ext4_mb_release_group_pa, "dev %s pstart %llu len %d",
+		   sb-&gt;s_id, pa-&gt;pa_pstart, pa-&gt;pa_len);
 	BUG_ON(pa-&gt;pa_deleted == 0);
 	ext4_get_group_no_and_offset(sb, pa-&gt;pa_pstart, &amp;group, &amp;bit);
 	BUG_ON(group != e4b-&gt;bd_group &amp;&amp; pa-&gt;pa_len != 0);
@@ -4040,6 +4055,8 @@ void ext4_discard_preallocations(struct inode *inode)
 	}
 
 	mb_debug("discard preallocation for inode %lu\n", inode-&gt;i_ino);
+	trace_mark(ext4_discard_preallocations, "dev %s ino %lu", sb-&gt;s_id,
+		   inode-&gt;i_ino);
 
 	INIT_LIST_HEAD(&amp;list);
 
@@ -4492,6 +4509,8 @@ static int ext4_mb_discard_preallocations(struct super_block *sb, int needed)
 	int ret;
 	int freed = 0;
 
+	trace_mark(ext4_mb_discard_preallocations, "dev %s needed %d",
+		   sb-&gt;s_id, needed);
 	for (i = 0; i &lt; EXT4_SB(sb)-&gt;s_groups_count &amp;&amp; needed &gt; 0; i++) {
 		ret = ext4_mb_discard_group_preallocations(sb, i, needed);
 		freed += ret;
@@ -4520,6 +4539,18 @@ ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,
 	sb = ar-&gt;inode-&gt;i_sb;
 	sbi = EXT4_SB(sb);
 
+	trace_mark(ext4_request_blocks, "dev %s flags %u len %u ino %lu "
+		   "lblk %llu goal %llu lleft %llu lright %llu "
+		   "pleft %llu pright %llu ",
+		   sb-&gt;s_id, ar-&gt;flags, ar-&gt;len,
+		   ar-&gt;inode ? ar-&gt;inode-&gt;i_ino : 0,
+		   (unsigned long long) ar-&gt;logical,
+		   (unsigned long long) ar-&gt;goal,
+		   (unsigned long long) ar-&gt;lleft,
+		   (unsigned long long) ar-&gt;lright,
+		   (unsigned long long) ar-&gt;pleft,
+		   (unsigned long long) ar-&gt;pright);
+
 	if (!EXT4_I(ar-&gt;inode)-&gt;i_delalloc_reserved_flag) {
 		/*
 		 * With delalloc we already reserved the blocks
@@ -4622,6 +4653,19 @@ ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,
 						reserv_blks);
 	}
 
+	trace_mark(ext4_allocate_blocks,
+		   "dev %s block %llu flags %u len %u ino %lu "
+		   "logical %llu goal %llu lleft %llu lright %llu "
+		   "pleft %llu pright %llu ",
+		   sb-&gt;s_id, (unsigned long long) block,
+		   ar-&gt;flags, ar-&gt;len, ar-&gt;inode ? ar-&gt;inode-&gt;i_ino : 0,
+		   (unsigned long long) ar-&gt;logical,
+		   (unsigned long long) ar-&gt;goal,
+		   (unsigned long long) ar-&gt;lleft,
+		   (unsigned long long) ar-&gt;lright,
+		   (unsigned long long) ar-&gt;pleft,
+		   (unsigned long long) ar-&gt;pright);
+
 	return block;
 }
 
@@ -4755,6 +4799,10 @@ void ext4_mb_free_blocks(handle_t *handle, struct inode *inode,
 	}
 
 	ext4_debug("freeing block %lu\n", block);
+	trace_mark(ext4_free_blocks,
+		   "dev %s block %llu count %lu metadata %d ino %lu",
+		   sb-&gt;s_id, (unsigned long long) block, count, metadata,
+		   inode ? inode-&gt;i_ino : 0);
 
 	ac = kmem_cache_alloc(ext4_ac_cachep, GFP_NOFS);
 	if (ac) {</pre><hr><pre>commit c31910672376dfb8d020e32afa7249763bcd924a
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Jan 6 11:14:25 2009 -0500

    ext4: Remove code to create the journal inode
    
    This code has been obsolete in quite some time, since the supported
    method for adding a journal inode is to use tune2fs (or to creating
    new filesystem with a journal via mke2fs or mkfs.ext4).
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/Documentation/filesystems/ext4.txt b/Documentation/filesystems/ext4.txt
index e3fcbea3ec8c..9ec29d86ff8b 100644
--- a/Documentation/filesystems/ext4.txt
+++ b/Documentation/filesystems/ext4.txt
@@ -149,10 +149,6 @@ journal_async_commit	Commit block can be written to disk without waiting
 journal=update		Update the ext4 file system's journal to the current
 			format.
 
-journal=inum		When a journal already exists, this option is ignored.
-			Otherwise, it specifies the number of the inode which
-			will represent the ext4 file system's journal file.
-
 journal_dev=devnum	When the external journal device's major/minor numbers
 			have changed, this option allows the user to specify
 			the new journal location.  The journal device is
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index e5ab520724da..8036392b2121 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -51,8 +51,6 @@ struct proc_dir_entry *ext4_proc_root;
 
 static int ext4_load_journal(struct super_block *, struct ext4_super_block *,
 			     unsigned long journal_devnum);
-static int ext4_create_journal(struct super_block *, struct ext4_super_block *,
-			       unsigned int);
 static void ext4_commit_super(struct super_block *sb,
 			      struct ext4_super_block *es, int sync);
 static void ext4_mark_recovery_complete(struct super_block *sb,
@@ -1006,7 +1004,7 @@ enum {
 	Opt_user_xattr, Opt_nouser_xattr, Opt_acl, Opt_noacl,
 	Opt_reservation, Opt_noreservation, Opt_noload, Opt_nobh, Opt_bh,
 	Opt_commit, Opt_min_batch_time, Opt_max_batch_time,
-	Opt_journal_update, Opt_journal_inum, Opt_journal_dev,
+	Opt_journal_update, Opt_journal_dev,
 	Opt_journal_checksum, Opt_journal_async_commit,
 	Opt_abort, Opt_data_journal, Opt_data_ordered, Opt_data_writeback,
 	Opt_data_err_abort, Opt_data_err_ignore,
@@ -1048,7 +1046,6 @@ static const match_table_t tokens = {
 	{Opt_min_batch_time, "min_batch_time=%u"},
 	{Opt_max_batch_time, "max_batch_time=%u"},
 	{Opt_journal_update, "journal=update"},
-	{Opt_journal_inum, "journal=%u"},
 	{Opt_journal_dev, "journal_dev=%u"},
 	{Opt_journal_checksum, "journal_checksum"},
 	{Opt_journal_async_commit, "journal_async_commit"},
@@ -1102,7 +1099,7 @@ static ext4_fsblk_t get_sb_block(void **data)
 }
 
 static int parse_options(char *options, struct super_block *sb,
-			 unsigned int *inum, unsigned long *journal_devnum,
+			 unsigned long *journal_devnum,
 			 ext4_fsblk_t *n_blocks_count, int is_remount)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
@@ -1226,16 +1223,6 @@ static int parse_options(char *options, struct super_block *sb,
 			}
 			set_opt(sbi-&gt;s_mount_opt, UPDATE_JOURNAL);
 			break;
-		case Opt_journal_inum:
-			if (is_remount) {
-				printk(KERN_ERR "EXT4-fs: cannot specify "
-				       "journal on remount\n");
-				return 0;
-			}
-			if (match_int(&amp;args[0], &amp;option))
-				return 0;
-			*inum = option;
-			break;
 		case Opt_journal_dev:
 			if (is_remount) {
 				printk(KERN_ERR "EXT4-fs: cannot specify "
@@ -2035,7 +2022,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	ext4_fsblk_t sb_block = get_sb_block(&amp;data);
 	ext4_fsblk_t logical_sb_block;
 	unsigned long offset = 0;
-	unsigned int journal_inum = 0;
 	unsigned long journal_devnum = 0;
 	unsigned long def_mount_opts;
 	struct inode *root;
@@ -2155,8 +2141,7 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 	set_opt(sbi-&gt;s_mount_opt, DELALLOC);
 
 
-	if (!parse_options((char *) data, sb, &amp;journal_inum, &amp;journal_devnum,
-			   NULL, 0))
+	if (!parse_options((char *) data, sb, &amp;journal_devnum, NULL, 0))
 		goto failed_mount;
 
 	sb-&gt;s_flags = (sb-&gt;s_flags &amp; ~MS_POSIXACL) |
@@ -2460,9 +2445,6 @@ static int ext4_fill_super(struct super_block *sb, void *data, int silent)
 				goto failed_mount4;
 			}
 		}
-	} else if (journal_inum) {
-		if (ext4_create_journal(sb, es, journal_inum))
-			goto failed_mount3;
 	} else if (test_opt(sb, NOLOAD) &amp;&amp; !(sb-&gt;s_flags &amp; MS_RDONLY) &amp;&amp;
 	      EXT4_HAS_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER)) {
 		printk(KERN_ERR "EXT4-fs: required journal recovery "
@@ -2926,48 +2908,6 @@ static int ext4_load_journal(struct super_block *sb,
 	return 0;
 }
 
-static int ext4_create_journal(struct super_block *sb,
-			       struct ext4_super_block *es,
-			       unsigned int journal_inum)
-{
-	journal_t *journal;
-	int err;
-
-	if (sb-&gt;s_flags &amp; MS_RDONLY) {
-		printk(KERN_ERR "EXT4-fs: readonly filesystem when trying to "
-				"create journal.\n");
-		return -EROFS;
-	}
-
-	journal = ext4_get_journal(sb, journal_inum);
-	if (!journal)
-		return -EINVAL;
-
-	printk(KERN_INFO "EXT4-fs: creating new journal on inode %u\n",
-	       journal_inum);
-
-	err = jbd2_journal_create(journal);
-	if (err) {
-		printk(KERN_ERR "EXT4-fs: error creating journal.\n");
-		jbd2_journal_destroy(journal);
-		return -EIO;
-	}
-
-	EXT4_SB(sb)-&gt;s_journal = journal;
-
-	ext4_update_dynamic_rev(sb);
-	EXT4_SET_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);
-	EXT4_SET_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_HAS_JOURNAL);
-
-	es-&gt;s_journal_inum = cpu_to_le32(journal_inum);
-	sb-&gt;s_dirt = 1;
-
-	/* Make sure we flush the recovery flag to disk. */
-	ext4_commit_super(sb, es, 1);
-
-	return 0;
-}
-
 static void ext4_commit_super(struct super_block *sb,
 			      struct ext4_super_block *es, int sync)
 {
@@ -3209,7 +3149,7 @@ static int ext4_remount(struct super_block *sb, int *flags, char *data)
 	/*
 	 * Allow the "check" option to be passed as a remount option.
 	 */
-	if (!parse_options(data, sb, NULL, NULL, &amp;n_blocks_count, 1)) {
+	if (!parse_options(data, sb, NULL, &amp;n_blocks_count, 1)) {
 		err = -EINVAL;
 		goto restore_opts;
 	}
diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c
index 34ef98057202..b10d7283ba5b 100644
--- a/fs/jbd2/journal.c
+++ b/fs/jbd2/journal.c
@@ -66,7 +66,6 @@ EXPORT_SYMBOL(jbd2_journal_update_format);
 EXPORT_SYMBOL(jbd2_journal_check_used_features);
 EXPORT_SYMBOL(jbd2_journal_check_available_features);
 EXPORT_SYMBOL(jbd2_journal_set_features);
-EXPORT_SYMBOL(jbd2_journal_create);
 EXPORT_SYMBOL(jbd2_journal_load);
 EXPORT_SYMBOL(jbd2_journal_destroy);
 EXPORT_SYMBOL(jbd2_journal_abort);
@@ -1162,77 +1161,6 @@ static int journal_reset(journal_t *journal)
 	return jbd2_journal_start_thread(journal);
 }
 
-/**
- * int jbd2_journal_create() - Initialise the new journal file
- * @journal: Journal to create. This structure must have been initialised
- *
- * Given a journal_t structure which tells us which disk blocks we can
- * use, create a new journal superblock and initialise all of the
- * journal fields from scratch.
- **/
-int jbd2_journal_create(journal_t *journal)
-{
-	unsigned long long blocknr;
-	struct buffer_head *bh;
-	journal_superblock_t *sb;
-	int i, err;
-
-	if (journal-&gt;j_maxlen &lt; JBD2_MIN_JOURNAL_BLOCKS) {
-		printk (KERN_ERR "Journal length (%d blocks) too short.\n",
-			journal-&gt;j_maxlen);
-		journal_fail_superblock(journal);
-		return -EINVAL;
-	}
-
-	if (journal-&gt;j_inode == NULL) {
-		/*
-		 * We don't know what block to start at!
-		 */
-		printk(KERN_EMERG
-		       "%s: creation of journal on external device!\n",
-		       __func__);
-		BUG();
-	}
-
-	/* Zero out the entire journal on disk.  We cannot afford to
-	   have any blocks on disk beginning with JBD2_MAGIC_NUMBER. */
-	jbd_debug(1, "JBD: Zeroing out journal blocks...\n");
-	for (i = 0; i &lt; journal-&gt;j_maxlen; i++) {
-		err = jbd2_journal_bmap(journal, i, &amp;blocknr);
-		if (err)
-			return err;
-		bh = __getblk(journal-&gt;j_dev, blocknr, journal-&gt;j_blocksize);
-		lock_buffer(bh);
-		memset (bh-&gt;b_data, 0, journal-&gt;j_blocksize);
-		BUFFER_TRACE(bh, "marking dirty");
-		mark_buffer_dirty(bh);
-		BUFFER_TRACE(bh, "marking uptodate");
-		set_buffer_uptodate(bh);
-		unlock_buffer(bh);
-		__brelse(bh);
-	}
-
-	sync_blockdev(journal-&gt;j_dev);
-	jbd_debug(1, "JBD: journal cleared.\n");
-
-	/* OK, fill in the initial static fields in the new superblock */
-	sb = journal-&gt;j_superblock;
-
-	sb-&gt;s_header.h_magic	 = cpu_to_be32(JBD2_MAGIC_NUMBER);
-	sb-&gt;s_header.h_blocktype = cpu_to_be32(JBD2_SUPERBLOCK_V2);
-
-	sb-&gt;s_blocksize	= cpu_to_be32(journal-&gt;j_blocksize);
-	sb-&gt;s_maxlen	= cpu_to_be32(journal-&gt;j_maxlen);
-	sb-&gt;s_first	= cpu_to_be32(1);
-
-	journal-&gt;j_transaction_sequence = 1;
-
-	journal-&gt;j_flags &amp;= ~JBD2_ABORT;
-	journal-&gt;j_format_version = 2;
-
-	return journal_reset(journal);
-}
-
 /**
  * void jbd2_journal_update_superblock() - Update journal sb on disk.
  * @journal: The journal to update.
diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h
index 9d82084a1605..adef1c9940d3 100644
--- a/include/linux/jbd2.h
+++ b/include/linux/jbd2.h
@@ -1104,7 +1104,6 @@ extern int	   jbd2_journal_set_features
 		   (journal_t *, unsigned long, unsigned long, unsigned long);
 extern void	   jbd2_journal_clear_features
 		   (journal_t *, unsigned long, unsigned long, unsigned long);
-extern int	   jbd2_journal_create     (journal_t *);
 extern int	   jbd2_journal_load       (journal_t *journal);
 extern int	   jbd2_journal_destroy    (journal_t *);
 extern int	   jbd2_journal_recover    (journal_t *journal);</pre><hr><pre>commit 87d8fe1ee6b8d2f95076142d58c440dba4e7bdc2
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Jan 3 09:47:09 2009 -0500

    add releasepage hooks to block devices which can be used by file systems
    
    Implement blkdev_releasepage() to release the buffer_heads and pages
    after we release private data belonging to a mounted filesystem.
    
    Cc: Toshiyuki Okajima &lt;toshi.okajima@jp.fujitsu.com&gt;
    Cc: linux-fsdevel@vger.kernel.org
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/block_dev.c b/fs/block_dev.c
index 349a26c10001..1dd07e66e98a 100644
--- a/fs/block_dev.c
+++ b/fs/block_dev.c
@@ -1220,6 +1220,20 @@ static long block_ioctl(struct file *file, unsigned cmd, unsigned long arg)
 	return blkdev_ioctl(bdev, mode, cmd, arg);
 }
 
+/*
+ * Try to release a page associated with block device when the system
+ * is under memory pressure.
+ */
+static int blkdev_releasepage(struct page *page, gfp_t wait)
+{
+	struct super_block *super = BDEV_I(page-&gt;mapping-&gt;host)-&gt;bdev.bd_super;
+
+	if (super &amp;&amp; super-&gt;s_op-&gt;bdev_try_to_free_page)
+		return super-&gt;s_op-&gt;bdev_try_to_free_page(super, page, wait);
+
+	return try_to_free_buffers(page);
+}
+
 static const struct address_space_operations def_blk_aops = {
 	.readpage	= blkdev_readpage,
 	.writepage	= blkdev_writepage,
@@ -1227,6 +1241,7 @@ static const struct address_space_operations def_blk_aops = {
 	.write_begin	= blkdev_write_begin,
 	.write_end	= blkdev_write_end,
 	.writepages	= generic_writepages,
+	.releasepage	= blkdev_releasepage,
 	.direct_IO	= blkdev_direct_IO,
 };
 
diff --git a/fs/super.c b/fs/super.c
index ddba069d7a99..d5fd4498548a 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -800,6 +800,7 @@ int get_sb_bdev(struct file_system_type *fs_type,
 		}
 
 		s-&gt;s_flags |= MS_ACTIVE;
+		bdev-&gt;bd_super = s;
 	}
 
 	return simple_set_mnt(mnt, s);
@@ -819,6 +820,7 @@ void kill_block_super(struct super_block *sb)
 	struct block_device *bdev = sb-&gt;s_bdev;
 	fmode_t mode = sb-&gt;s_mode;
 
+	bdev-&gt;bd_super = 0;
 	generic_shutdown_super(sb);
 	sync_blockdev(bdev);
 	close_bdev_exclusive(bdev, mode);
diff --git a/include/linux/fs.h b/include/linux/fs.h
index f2a3010140e3..0f54ae0f0ccd 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -565,6 +565,7 @@ struct address_space {
 struct block_device {
 	dev_t			bd_dev;  /* not a kdev_t - it's a search key */
 	struct inode *		bd_inode;	/* will die */
+	struct super_block *	bd_super;
 	int			bd_openers;
 	struct mutex		bd_mutex;	/* open/close mutex */
 	struct semaphore	bd_mount_sem;
@@ -1385,6 +1386,7 @@ struct super_operations {
 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
+	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
 };
 
 /*</pre><hr><pre>commit 6cdfcc275e40b89fb020da1088ead86a61d33115
Author: Theodore Tso &lt;tytso@mit.edu&gt;
Date:   Wed Nov 12 13:27:01 2008 -0800

    ext3: Clean up outdated and incorrect comment for ext3_write_super()
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: &lt;linux-ext4@vger.kernel.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/ext3/super.c b/fs/ext3/super.c
index 5dec6d1356c4..f6c94f232ec1 100644
--- a/fs/ext3/super.c
+++ b/fs/ext3/super.c
@@ -2375,12 +2375,9 @@ int ext3_force_commit(struct super_block *sb)
 /*
  * Ext3 always journals updates to the superblock itself, so we don't
  * have to propagate any other updates to the superblock on disk at this
- * point.  Just start an async writeback to get the buffers on their way
- * to the disk.
- *
- * This implicitly triggers the writebehind on sync().
+ * point.  (We can probably nuke this function altogether, and remove
+ * any mention to sb-&gt;s_dirt in all of fs/ext3; eventual cleanup...)
  */
-
 static void ext3_write_super (struct super_block * sb)
 {
 	if (mutex_trylock(&amp;sb-&gt;s_lock) != 0)</pre><hr><pre>commit ac51d83705c2a38c71f39cde99708b14e6212a60
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Nov 6 16:49:36 2008 -0500

    ext4: calculate journal credits correctly
    
    This fixes a 2.6.27 regression which was introduced in commit a02908f1.
    
    We weren't passing the chunk parameter down to the two subections,
    ext4_indirect_trans_blocks() and ext4_ext_index_trans_blocks(), with
    the result that massively overestimate the amount of credits needed by
    ext4_da_writepages, especially in the non-extents case.  This causes
    failures especially on /boot partitions, which tend to be small and
    non-extent using since GRUB doesn't handle extents.
    
    This patch fixes the bug reported by Joseph Fannin at:
    http://bugzilla.kernel.org/show_bug.cgi?id=11964
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 8dbf6953845b..5a130b56f1cf 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4580,9 +4580,10 @@ static int ext4_indirect_trans_blocks(struct inode *inode, int nrblocks,
 static int ext4_index_trans_blocks(struct inode *inode, int nrblocks, int chunk)
 {
 	if (!(EXT4_I(inode)-&gt;i_flags &amp; EXT4_EXTENTS_FL))
-		return ext4_indirect_trans_blocks(inode, nrblocks, 0);
-	return ext4_ext_index_trans_blocks(inode, nrblocks, 0);
+		return ext4_indirect_trans_blocks(inode, nrblocks, chunk);
+	return ext4_ext_index_trans_blocks(inode, nrblocks, chunk);
 }
+
 /*
  * Account for index blocks, block groups bitmaps and block group
  * descriptor blocks if modify datablocks and index blocks</pre>
    <div class="pagination">
        <a href='1_101.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><span>[102]</span><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_103.html'>Next&gt;&gt;</a>
    <div>
</body>
