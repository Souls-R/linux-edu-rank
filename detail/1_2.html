<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><span>[2]</span><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b3e6bcb94590dea45396b9481e47b809b1be4afa
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue May 23 23:49:48 2023 -0400

    ext4: add EA_INODE checking to ext4_iget()
    
    Add a new flag, EXT4_IGET_EA_INODE which indicates whether the inode
    is expected to have the EA_INODE flag or not.  If the flag is not
    set/clear as expected, then fail the iget() operation and mark the
    file system as corrupted.
    
    This commit also makes the ext4_iget() always perform the
    is_bad_inode() check even when the inode is already inode cache.  This
    allows us to remove the is_bad_inode() check from the callers of
    ext4_iget() in the ea_inode code.
    
    Reported-by: syzbot+cbb68193bdb95af4340a@syzkaller.appspotmail.com
    Reported-by: syzbot+62120febbd1ee3c3c860@syzkaller.appspotmail.com
    Reported-by: syzbot+edce54daffee36421b4c@syzkaller.appspotmail.com
    Cc: stable@kernel.org
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Link: https://lore.kernel.org/r/20230524034951.779531-2-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 6948d673bba2..9525c52b78dc 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2901,7 +2901,8 @@ typedef enum {
 	EXT4_IGET_NORMAL =	0,
 	EXT4_IGET_SPECIAL =	0x0001, /* OK to iget a system inode */
 	EXT4_IGET_HANDLE = 	0x0002,	/* Inode # is from a handle */
-	EXT4_IGET_BAD =		0x0004  /* Allow to iget a bad inode */
+	EXT4_IGET_BAD =		0x0004, /* Allow to iget a bad inode */
+	EXT4_IGET_EA_INODE =	0x0008	/* Inode should contain an EA value */
 } ext4_iget_flags;
 
 extern struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index ce5f21b6c2b3..258f3cbed347 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4641,6 +4641,21 @@ static inline void ext4_inode_set_iversion_queried(struct inode *inode, u64 val)
 		inode_set_iversion_queried(inode, val);
 }
 
+static const char *check_igot_inode(struct inode *inode, ext4_iget_flags flags)
+
+{
+	if (flags &amp; EXT4_IGET_EA_INODE) {
+		if (!(EXT4_I(inode)-&gt;i_flags &amp; EXT4_EA_INODE_FL))
+			return "missing EA_INODE flag";
+	} else {
+		if ((EXT4_I(inode)-&gt;i_flags &amp; EXT4_EA_INODE_FL))
+			return "unexpected EA_INODE flag";
+	}
+	if (is_bad_inode(inode) &amp;&amp; !(flags &amp; EXT4_IGET_BAD))
+		return "unexpected bad inode w/o EXT4_IGET_BAD";
+	return NULL;
+}
+
 struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
 			  ext4_iget_flags flags, const char *function,
 			  unsigned int line)
@@ -4650,6 +4665,7 @@ struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
 	struct ext4_inode_info *ei;
 	struct ext4_super_block *es = EXT4_SB(sb)-&gt;s_es;
 	struct inode *inode;
+	const char *err_str;
 	journal_t *journal = EXT4_SB(sb)-&gt;s_journal;
 	long ret;
 	loff_t size;
@@ -4677,8 +4693,14 @@ struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
 	inode = iget_locked(sb, ino);
 	if (!inode)
 		return ERR_PTR(-ENOMEM);
-	if (!(inode-&gt;i_state &amp; I_NEW))
+	if (!(inode-&gt;i_state &amp; I_NEW)) {
+		if ((err_str = check_igot_inode(inode, flags)) != NULL) {
+			ext4_error_inode(inode, function, line, 0, err_str);
+			iput(inode);
+			return ERR_PTR(-EFSCORRUPTED);
+		}
 		return inode;
+	}
 
 	ei = EXT4_I(inode);
 	iloc.bh = NULL;
@@ -4944,10 +4966,9 @@ struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
 	if (IS_CASEFOLDED(inode) &amp;&amp; !ext4_has_feature_casefold(inode-&gt;i_sb))
 		ext4_error_inode(inode, function, line, 0,
 				 "casefold flag without casefold feature");
-	if (is_bad_inode(inode) &amp;&amp; !(flags &amp; EXT4_IGET_BAD)) {
-		ext4_error_inode(inode, function, line, 0,
-				 "bad inode without EXT4_IGET_BAD flag");
-		ret = -EUCLEAN;
+	if ((err_str = check_igot_inode(inode, flags)) != NULL) {
+		ext4_error_inode(inode, function, line, 0, err_str);
+		ret = -EFSCORRUPTED;
 		goto bad_inode;
 	}
 
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index dfc2e223bd10..a27208129a80 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -433,7 +433,7 @@ static int ext4_xattr_inode_iget(struct inode *parent, unsigned long ea_ino,
 		return -EFSCORRUPTED;
 	}
 
-	inode = ext4_iget(parent-&gt;i_sb, ea_ino, EXT4_IGET_NORMAL);
+	inode = ext4_iget(parent-&gt;i_sb, ea_ino, EXT4_IGET_EA_INODE);
 	if (IS_ERR(inode)) {
 		err = PTR_ERR(inode);
 		ext4_error(parent-&gt;i_sb,
@@ -441,23 +441,6 @@ static int ext4_xattr_inode_iget(struct inode *parent, unsigned long ea_ino,
 			   err);
 		return err;
 	}
-
-	if (is_bad_inode(inode)) {
-		ext4_error(parent-&gt;i_sb,
-			   "error while reading EA inode %lu is_bad_inode",
-			   ea_ino);
-		err = -EIO;
-		goto error;
-	}
-
-	if (!(EXT4_I(inode)-&gt;i_flags &amp; EXT4_EA_INODE_FL)) {
-		ext4_error(parent-&gt;i_sb,
-			   "EA inode %lu does not have EXT4_EA_INODE_FL flag",
-			    ea_ino);
-		err = -EINVAL;
-		goto error;
-	}
-
 	ext4_xattr_inode_set_class(inode);
 
 	/*
@@ -478,9 +461,6 @@ static int ext4_xattr_inode_iget(struct inode *parent, unsigned long ea_ino,
 
 	*ea_inode = inode;
 	return 0;
-error:
-	iput(inode);
-	return err;
 }
 
 /* Remove entry from mbcache when EA inode is getting evicted */
@@ -1556,11 +1536,10 @@ ext4_xattr_inode_cache_find(struct inode *inode, const void *value,
 
 	while (ce) {
 		ea_inode = ext4_iget(inode-&gt;i_sb, ce-&gt;e_value,
-				     EXT4_IGET_NORMAL);
-		if (!IS_ERR(ea_inode) &amp;&amp;
-		    !is_bad_inode(ea_inode) &amp;&amp;
-		    (EXT4_I(ea_inode)-&gt;i_flags &amp; EXT4_EA_INODE_FL) &amp;&amp;
-		    i_size_read(ea_inode) == value_len &amp;&amp;
+				     EXT4_IGET_EA_INODE);
+		if (IS_ERR(ea_inode))
+			goto next_entry;
+		if (i_size_read(ea_inode) == value_len &amp;&amp;
 		    !ext4_xattr_inode_read(ea_inode, ea_data, value_len) &amp;&amp;
 		    !ext4_xattr_inode_verify_hashes(ea_inode, NULL, ea_data,
 						    value_len) &amp;&amp;
@@ -1570,9 +1549,8 @@ ext4_xattr_inode_cache_find(struct inode *inode, const void *value,
 			kvfree(ea_data);
 			return ea_inode;
 		}
-
-		if (!IS_ERR(ea_inode))
-			iput(ea_inode);
+		iput(ea_inode);
+	next_entry:
 		ce = mb_cache_entry_find_next(ea_inode_cache, ce);
 	}
 	kvfree(ea_data);</pre><hr><pre>commit 2a534e1d0d1591e951f9ece2fb460b2ff92edabd
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri May 12 15:16:27 2023 -0400

    ext4: bail out of ext4_xattr_ibody_get() fails for any reason
    
    In ext4_update_inline_data(), if ext4_xattr_ibody_get() fails for any
    reason, it's best if we just fail as opposed to stumbling on,
    especially if the failure is EFSCORRUPTED.
    
    Cc: stable@kernel.org
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index f47adb284e90..5854bd5a3352 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -360,7 +360,7 @@ static int ext4_update_inline_data(handle_t *handle, struct inode *inode,
 
 	error = ext4_xattr_ibody_get(inode, i.name_index, i.name,
 				     value, len);
-	if (error == -ENODATA)
+	if (error &lt; 0)
 		goto out;
 
 	BUFFER_TRACE(is.iloc.bh, "get_write_access");</pre><hr><pre>commit 2220eaf90992c11d888fe771055d4de330385f01
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri May 12 15:11:02 2023 -0400

    ext4: add bounds checking in get_max_inline_xattr_value_size()
    
    Normally the extended attributes in the inode body would have been
    checked when the inode is first opened, but if someone is writing to
    the block device while the file system is mounted, it's possible for
    the inode table to get corrupted.  Add bounds checking to avoid
    reading beyond the end of allocated memory if this happens.
    
    Reported-by: syzbot+1966db24521e5f6e23f7@syzkaller.appspotmail.com
    Link: https://syzkaller.appspot.com/bug?extid=1966db24521e5f6e23f7
    Cc: stable@kernel.org
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index d3dfc51a43c5..f47adb284e90 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -34,6 +34,7 @@ static int get_max_inline_xattr_value_size(struct inode *inode,
 	struct ext4_xattr_ibody_header *header;
 	struct ext4_xattr_entry *entry;
 	struct ext4_inode *raw_inode;
+	void *end;
 	int free, min_offs;
 
 	if (!EXT4_INODE_HAS_XATTR_SPACE(inode))
@@ -57,14 +58,23 @@ static int get_max_inline_xattr_value_size(struct inode *inode,
 	raw_inode = ext4_raw_inode(iloc);
 	header = IHDR(inode, raw_inode);
 	entry = IFIRST(header);
+	end = (void *)raw_inode + EXT4_SB(inode-&gt;i_sb)-&gt;s_inode_size;
 
 	/* Compute min_offs. */
-	for (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) {
+	while (!IS_LAST_ENTRY(entry)) {
+		void *next = EXT4_XATTR_NEXT(entry);
+
+		if (next &gt;= end) {
+			EXT4_ERROR_INODE(inode,
+					 "corrupt xattr in inline inode");
+			return 0;
+		}
 		if (!entry-&gt;e_value_inum &amp;&amp; entry-&gt;e_value_size) {
 			size_t offs = le16_to_cpu(entry-&gt;e_value_offs);
 			if (offs &lt; min_offs)
 				min_offs = offs;
 		}
+		entry = next;
 	}
 	free = min_offs -
 		((void *)entry - (void *)IFIRST(header)) - sizeof(__u32);</pre><hr><pre>commit 6dcc98fbc46511f7a6650946f198df6951a5a88c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri May 12 14:49:57 2023 -0400

    ext4: add indication of ro vs r/w mounts in the mount message
    
    Whether the file system is mounted read-only or read/write is more
    important than the quota mode, which we are already printing.  Add the
    ro vs r/w indication since this can be helpful in debugging problems
    from the console log.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index bc0b4a98b337..9680fe753e59 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -5684,8 +5684,9 @@ static int ext4_fill_super(struct super_block *sb, struct fs_context *fc)
 		descr = "out journal";
 
 	if (___ratelimit(&amp;ext4_mount_msg_ratelimit, "EXT4-fs mount"))
-		ext4_msg(sb, KERN_INFO, "mounted filesystem %pU with%s. "
-			 "Quota mode: %s.", &amp;sb-&gt;s_uuid, descr,
+		ext4_msg(sb, KERN_INFO, "mounted filesystem %pU %s with%s. "
+			 "Quota mode: %s.", &amp;sb-&gt;s_uuid,
+			 sb_rdonly(sb) ? "ro" : "r/w", descr,
 			 ext4_quota_mode(sb));
 
 	/* Update the s_overhead_clusters if necessary */
@@ -6689,8 +6690,9 @@ static int ext4_reconfigure(struct fs_context *fc)
 	if (ret &lt; 0)
 		return ret;
 
-	ext4_msg(sb, KERN_INFO, "re-mounted %pU. Quota mode: %s.",
-		 &amp;sb-&gt;s_uuid, ext4_quota_mode(sb));
+	ext4_msg(sb, KERN_INFO, "re-mounted %pU %s. Quota mode: %s.",
+		 &amp;sb-&gt;s_uuid, sb_rdonly(sb) ? "ro" : "r/w",
+		 ext4_quota_mode(sb));
 
 	return 0;
 }</pre><hr><pre>commit f4ce24f54d9cca4f09a395f3eecce20d6bec4663
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat May 6 21:04:01 2023 -0400

    ext4: fix deadlock when converting an inline directory in nojournal mode
    
    In no journal mode, ext4_finish_convert_inline_dir() can self-deadlock
    by calling ext4_handle_dirty_dirblock() when it already has taken the
    directory lock.  There is a similar self-deadlock in
    ext4_incvert_inline_data_nolock() for data files which we'll fix at
    the same time.
    
    A simple reproducer demonstrating the problem:
    
        mke2fs -Fq -t ext2 -O inline_data -b 4k /dev/vdc 64
        mount -t ext4 -o dirsync /dev/vdc /vdc
        cd /vdc
        mkdir file0
        cd file0
        touch file0
        touch file1
        attr -s BurnSpaceInEA -V abcde .
        touch supercalifragilisticexpialidocious
    
    Cc: stable@kernel.org
    Link: https://lore.kernel.org/r/20230507021608.1290720-1-tytso@mit.edu
    Reported-by: syzbot+91dccab7c64e2850a4e5@syzkaller.appspotmail.com
    Link: https://syzkaller.appspot.com/bug?id=ba84cc80a9491d65416bc7877e1650c87530fe8a
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c
index 859bc4e2c9b0..d3dfc51a43c5 100644
--- a/fs/ext4/inline.c
+++ b/fs/ext4/inline.c
@@ -1175,6 +1175,7 @@ static int ext4_finish_convert_inline_dir(handle_t *handle,
 		ext4_initialize_dirent_tail(dir_block,
 					    inode-&gt;i_sb-&gt;s_blocksize);
 	set_buffer_uptodate(dir_block);
+	unlock_buffer(dir_block);
 	err = ext4_handle_dirty_dirblock(handle, inode, dir_block);
 	if (err)
 		return err;
@@ -1249,6 +1250,7 @@ static int ext4_convert_inline_data_nolock(handle_t *handle,
 	if (!S_ISDIR(inode-&gt;i_mode)) {
 		memcpy(data_bh-&gt;b_data, buf, inline_size);
 		set_buffer_uptodate(data_bh);
+		unlock_buffer(data_bh);
 		error = ext4_handle_dirty_metadata(handle,
 						   inode, data_bh);
 	} else {
@@ -1256,7 +1258,6 @@ static int ext4_convert_inline_data_nolock(handle_t *handle,
 						       buf, inline_size);
 	}
 
-	unlock_buffer(data_bh);
 out_restore:
 	if (error)
 		ext4_restore_inline_data(handle, inode, iloc, buf, inline_size);</pre><hr><pre>commit 4c0b4818b1f636bc96359f7817a2d8bab6370162
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri May 5 22:20:29 2023 -0400

    ext4: improve error recovery code paths in __ext4_remount()
    
    If there are failures while changing the mount options in
    __ext4_remount(), we need to restore the old mount options.
    
    This commit fixes two problem.  The first is there is a chance that we
    will free the old quota file names before a potential failure leading
    to a use-after-free.  The second problem addressed in this commit is
    if there is a failed read/write to read-only transition, if the quota
    has already been suspended, we need to renable quota handling.
    
    Cc: stable@kernel.org
    Link: https://lore.kernel.org/r/20230506142419.984260-2-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index c7bc4a2709cc..bc0b4a98b337 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -6617,9 +6617,6 @@ static int __ext4_remount(struct fs_context *fc, struct super_block *sb)
 	}
 
 #ifdef CONFIG_QUOTA
-	/* Release old quota file names */
-	for (i = 0; i &lt; EXT4_MAXQUOTAS; i++)
-		kfree(old_opts.s_qf_names[i]);
 	if (enable_quota) {
 		if (sb_any_quota_suspended(sb))
 			dquot_resume(sb, -1);
@@ -6629,6 +6626,9 @@ static int __ext4_remount(struct fs_context *fc, struct super_block *sb)
 				goto restore_opts;
 		}
 	}
+	/* Release old quota file names */
+	for (i = 0; i &lt; EXT4_MAXQUOTAS; i++)
+		kfree(old_opts.s_qf_names[i]);
 #endif
 	if (!test_opt(sb, BLOCK_VALIDITY) &amp;&amp; sbi-&gt;s_system_blks)
 		ext4_release_system_zone(sb);
@@ -6642,6 +6642,13 @@ static int __ext4_remount(struct fs_context *fc, struct super_block *sb)
 	return 0;
 
 restore_opts:
+	/*
+	 * If there was a failing r/w to ro transition, we may need to
+	 * re-enable quota
+	 */
+	if ((sb-&gt;s_flags &amp; SB_RDONLY) &amp;&amp; !(old_sb_flags &amp; SB_RDONLY) &amp;&amp;
+	    sb_any_quota_suspended(sb))
+		dquot_resume(sb, -1);
 	sb-&gt;s_flags = old_sb_flags;
 	sbi-&gt;s_mount_opt = old_opts.s_mount_opt;
 	sbi-&gt;s_mount_opt2 = old_opts.s_mount_opt2;</pre><hr><pre>commit 4b3cb1d108bfc2aebb0d7c8a52261a53cf7f5786
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat May 6 11:59:13 2023 -0400

    ext4: improve error handling from ext4_dirhash()
    
    The ext4_dirhash() will *almost* never fail, especially when the hash
    tree feature was first introduced.  However, with the addition of
    support of encrypted, casefolded file names, that function can most
    certainly fail today.
    
    So make sure the callers of ext4_dirhash() properly check for
    failures, and reflect the errors back up to their callers.
    
    Cc: stable@kernel.org
    Link: https://lore.kernel.org/r/20230506142419.984260-1-tytso@mit.edu
    Reported-by: syzbot+394aa8a792cb99dbc837@syzkaller.appspotmail.com
    Reported-by: syzbot+344aaa8697ebd232bfc8@syzkaller.appspotmail.com
    Link: https://syzkaller.appspot.com/bug?id=db56459ea4ac4a676ae4b4678f633e55da005a9b
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/hash.c b/fs/ext4/hash.c
index 147b5241dd94..46c3423ddfa1 100644
--- a/fs/ext4/hash.c
+++ b/fs/ext4/hash.c
@@ -277,7 +277,11 @@ static int __ext4fs_dirhash(const struct inode *dir, const char *name, int len,
 	}
 	default:
 		hinfo-&gt;hash = 0;
-		return -1;
+		hinfo-&gt;minor_hash = 0;
+		ext4_warning(dir-&gt;i_sb,
+			     "invalid/unsupported hash tree version %u",
+			     hinfo-&gt;hash_version);
+		return -EINVAL;
 	}
 	hash = hash &amp; ~1;
 	if (hash == (EXT4_HTREE_EOF_32BIT &lt;&lt; 1))
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index a5010b5b8a8c..45b579805c95 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -674,7 +674,7 @@ static struct stats dx_show_leaf(struct inode *dir,
 				len = de-&gt;name_len;
 				if (!IS_ENCRYPTED(dir)) {
 					/* Directory is not encrypted */
-					ext4fs_dirhash(dir, de-&gt;name,
+					(void) ext4fs_dirhash(dir, de-&gt;name,
 						de-&gt;name_len, &amp;h);
 					printk("%*.s:(U)%x.%u ", len,
 					       name, h.hash,
@@ -709,8 +709,9 @@ static struct stats dx_show_leaf(struct inode *dir,
 					if (IS_CASEFOLDED(dir))
 						h.hash = EXT4_DIRENT_HASH(de);
 					else
-						ext4fs_dirhash(dir, de-&gt;name,
-						       de-&gt;name_len, &amp;h);
+						(void) ext4fs_dirhash(dir,
+							de-&gt;name,
+							de-&gt;name_len, &amp;h);
 					printk("%*.s:(E)%x.%u ", len, name,
 					       h.hash, (unsigned) ((char *) de
 								   - base));
@@ -720,7 +721,8 @@ static struct stats dx_show_leaf(struct inode *dir,
 #else
 				int len = de-&gt;name_len;
 				char *name = de-&gt;name;
-				ext4fs_dirhash(dir, de-&gt;name, de-&gt;name_len, &amp;h);
+				(void) ext4fs_dirhash(dir, de-&gt;name,
+						      de-&gt;name_len, &amp;h);
 				printk("%*.s:%x.%u ", len, name, h.hash,
 				       (unsigned) ((char *) de - base));
 #endif
@@ -849,8 +851,14 @@ dx_probe(struct ext4_filename *fname, struct inode *dir,
 	hinfo-&gt;seed = EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_seed;
 	/* hash is already computed for encrypted casefolded directory */
 	if (fname &amp;&amp; fname_name(fname) &amp;&amp;
-				!(IS_ENCRYPTED(dir) &amp;&amp; IS_CASEFOLDED(dir)))
-		ext4fs_dirhash(dir, fname_name(fname), fname_len(fname), hinfo);
+	    !(IS_ENCRYPTED(dir) &amp;&amp; IS_CASEFOLDED(dir))) {
+		int ret = ext4fs_dirhash(dir, fname_name(fname),
+					 fname_len(fname), hinfo);
+		if (ret &lt; 0) {
+			ret_err = ERR_PTR(ret);
+			goto fail;
+		}
+	}
 	hash = hinfo-&gt;hash;
 
 	if (root-&gt;info.unused_flags &amp; 1) {
@@ -1111,7 +1119,12 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 				hinfo-&gt;minor_hash = 0;
 			}
 		} else {
-			ext4fs_dirhash(dir, de-&gt;name, de-&gt;name_len, hinfo);
+			err = ext4fs_dirhash(dir, de-&gt;name,
+					     de-&gt;name_len, hinfo);
+			if (err &lt; 0) {
+				count = err;
+				goto errout;
+			}
 		}
 		if ((hinfo-&gt;hash &lt; start_hash) ||
 		    ((hinfo-&gt;hash == start_hash) &amp;&amp;
@@ -1313,8 +1326,12 @@ static int dx_make_map(struct inode *dir, struct buffer_head *bh,
 		if (de-&gt;name_len &amp;&amp; de-&gt;inode) {
 			if (ext4_hash_in_dirent(dir))
 				h.hash = EXT4_DIRENT_HASH(de);
-			else
-				ext4fs_dirhash(dir, de-&gt;name, de-&gt;name_len, &amp;h);
+			else {
+				int err = ext4fs_dirhash(dir, de-&gt;name,
+						     de-&gt;name_len, &amp;h);
+				if (err &lt; 0)
+					return err;
+			}
 			map_tail--;
 			map_tail-&gt;hash = h.hash;
 			map_tail-&gt;offs = ((char *) de - base)&gt;&gt;2;
@@ -1452,10 +1469,9 @@ int ext4_fname_setup_ci_filename(struct inode *dir, const struct qstr *iname,
 	hinfo-&gt;hash_version = DX_HASH_SIPHASH;
 	hinfo-&gt;seed = NULL;
 	if (cf_name-&gt;name)
-		ext4fs_dirhash(dir, cf_name-&gt;name, cf_name-&gt;len, hinfo);
+		return ext4fs_dirhash(dir, cf_name-&gt;name, cf_name-&gt;len, hinfo);
 	else
-		ext4fs_dirhash(dir, iname-&gt;name, iname-&gt;len, hinfo);
-	return 0;
+		return ext4fs_dirhash(dir, iname-&gt;name, iname-&gt;len, hinfo);
 }
 #endif
 
@@ -2298,10 +2314,15 @@ static int make_indexed_dir(handle_t *handle, struct ext4_filename *fname,
 	fname-&gt;hinfo.seed = EXT4_SB(dir-&gt;i_sb)-&gt;s_hash_seed;
 
 	/* casefolded encrypted hashes are computed on fname setup */
-	if (!ext4_hash_in_dirent(dir))
-		ext4fs_dirhash(dir, fname_name(fname),
-				fname_len(fname), &amp;fname-&gt;hinfo);
-
+	if (!ext4_hash_in_dirent(dir)) {
+		int err = ext4fs_dirhash(dir, fname_name(fname),
+					 fname_len(fname), &amp;fname-&gt;hinfo);
+		if (err &lt; 0) {
+			brelse(bh2);
+			brelse(bh);
+			return err;
+		}
+	}
 	memset(frames, 0, sizeof(frames));
 	frame = frames;
 	frame-&gt;entries = entries;</pre><hr><pre>commit a44be64bbecb15a452496f60db6eacfee2b59c79
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri May 5 21:02:30 2023 -0400

    ext4: don't clear SB_RDONLY when remounting r/w until quota is re-enabled
    
    When a file system currently mounted read/only is remounted
    read/write, if we clear the SB_RDONLY flag too early, before the quota
    is initialized, and there is another process/thread constantly
    attempting to create a directory, it's possible to trigger the
    
            WARN_ON_ONCE(dquot_initialize_needed(inode));
    
    in ext4_xattr_block_set(), with the following stack trace:
    
       WARNING: CPU: 0 PID: 5338 at fs/ext4/xattr.c:2141 ext4_xattr_block_set+0x2ef2/0x3680
       RIP: 0010:ext4_xattr_block_set+0x2ef2/0x3680 fs/ext4/xattr.c:2141
       Call Trace:
        ext4_xattr_set_handle+0xcd4/0x15c0 fs/ext4/xattr.c:2458
        ext4_initxattrs+0xa3/0x110 fs/ext4/xattr_security.c:44
        security_inode_init_security+0x2df/0x3f0 security/security.c:1147
        __ext4_new_inode+0x347e/0x43d0 fs/ext4/ialloc.c:1324
        ext4_mkdir+0x425/0xce0 fs/ext4/namei.c:2992
        vfs_mkdir+0x29d/0x450 fs/namei.c:4038
        do_mkdirat+0x264/0x520 fs/namei.c:4061
        __do_sys_mkdirat fs/namei.c:4076 [inline]
        __se_sys_mkdirat fs/namei.c:4074 [inline]
        __x64_sys_mkdirat+0x89/0xa0 fs/namei.c:4074
    
    Cc: stable@kernel.org
    Link: https://lore.kernel.org/r/20230506142419.984260-1-tytso@mit.edu
    Reported-by: syzbot+6385d7d3065524c5ca6d@syzkaller.appspotmail.com
    Link: https://syzkaller.appspot.com/bug?id=6513f6cb5cd6b5fc9f37e3bb70d273b94be9c34c
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 425b95a7a0ab..c7bc4a2709cc 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -6387,6 +6387,7 @@ static int __ext4_remount(struct fs_context *fc, struct super_block *sb)
 	struct ext4_mount_options old_opts;
 	ext4_group_t g;
 	int err = 0;
+	int enable_rw = 0;
 #ifdef CONFIG_QUOTA
 	int enable_quota = 0;
 	int i, j;
@@ -6573,7 +6574,7 @@ static int __ext4_remount(struct fs_context *fc, struct super_block *sb)
 			if (err)
 				goto restore_opts;
 
-			sb-&gt;s_flags &amp;= ~SB_RDONLY;
+			enable_rw = 1;
 			if (ext4_has_feature_mmp(sb)) {
 				err = ext4_multi_mount_protect(sb,
 						le64_to_cpu(es-&gt;s_mmp_block));
@@ -6632,6 +6633,9 @@ static int __ext4_remount(struct fs_context *fc, struct super_block *sb)
 	if (!test_opt(sb, BLOCK_VALIDITY) &amp;&amp; sbi-&gt;s_system_blks)
 		ext4_release_system_zone(sb);
 
+	if (enable_rw)
+		sb-&gt;s_flags &amp;= ~SB_RDONLY;
+
 	if (!ext4_has_feature_mmp(sb) || sb_rdonly(sb))
 		ext4_stop_mmpd(sbi);
 </pre><hr><pre>commit b87c7cdf2bed4928b899e1ce91ef0d147017ba45
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sun Apr 30 03:04:13 2023 -0400

    ext4: fix invalid free tracking in ext4_xattr_move_to_block()
    
    In ext4_xattr_move_to_block(), the value of the extended attribute
    which we need to move to an external block may be allocated by
    kvmalloc() if the value is stored in an external inode.  So at the end
    of the function the code tried to check if this was the case by
    testing entry-&gt;e_value_inum.
    
    However, at this point, the pointer to the xattr entry is no longer
    valid, because it was removed from the original location where it had
    been stored.  So we could end up calling kvfree() on a pointer which
    was not allocated by kvmalloc(); or we could also potentially leak
    memory by not freeing the buffer when it should be freed.  Fix this by
    storing whether it should be freed in a separate variable.
    
    Cc: stable@kernel.org
    Link: https://lore.kernel.org/r/20230430160426.581366-1-tytso@mit.edu
    Link: https://syzkaller.appspot.com/bug?id=5c2aee8256e30b55ccf57312c16d88417adbd5e1
    Link: https://syzkaller.appspot.com/bug?id=41a6b5d4917c0412eb3b3c3c604965bed7d7420b
    Reported-by: syzbot+64b645917ce07d89bde5@syzkaller.appspotmail.com
    Reported-by: syzbot+0d042627c4f2ad332195@syzkaller.appspotmail.com
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index dadad29bd81b..dfc2e223bd10 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -2614,6 +2614,7 @@ static int ext4_xattr_move_to_block(handle_t *handle, struct inode *inode,
 		.in_inode = !!entry-&gt;e_value_inum,
 	};
 	struct ext4_xattr_ibody_header *header = IHDR(inode, raw_inode);
+	int needs_kvfree = 0;
 	int error;
 
 	is = kzalloc(sizeof(struct ext4_xattr_ibody_find), GFP_NOFS);
@@ -2636,7 +2637,7 @@ static int ext4_xattr_move_to_block(handle_t *handle, struct inode *inode,
 			error = -ENOMEM;
 			goto out;
 		}
-
+		needs_kvfree = 1;
 		error = ext4_xattr_inode_get(inode, entry, buffer, value_size);
 		if (error)
 			goto out;
@@ -2675,7 +2676,7 @@ static int ext4_xattr_move_to_block(handle_t *handle, struct inode *inode,
 
 out:
 	kfree(b_entry_name);
-	if (entry-&gt;e_value_inum &amp;&amp; buffer)
+	if (needs_kvfree &amp;&amp; buffer)
 		kvfree(buffer);
 	if (is)
 		brelse(is-&gt;iloc.bh);</pre><hr><pre>commit 463808f237cf73e98a1a45ff7460c2406a150a0b
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Apr 29 16:14:46 2023 -0400

    ext4: remove a BUG_ON in ext4_mb_release_group_pa()
    
    If a malicious fuzzer overwrites the ext4 superblock while it is
    mounted such that the s_first_data_block is set to a very large
    number, the calculation of the block group can underflow, and trigger
    a BUG_ON check.  Change this to be an ext4_warning so that we don't
    crash the kernel.
    
    Cc: stable@kernel.org
    Link: https://lore.kernel.org/r/20230430154311.579720-3-tytso@mit.edu
    Reported-by: syzbot+e2efa3efc15a1c9e95c3@syzkaller.appspotmail.com
    Link: https://syzkaller.appspot.com/bug?id=69b28112e098b070f639efb356393af3ffec4220
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index a857db48b383..7b2e36d103cb 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -5047,7 +5047,11 @@ ext4_mb_release_group_pa(struct ext4_buddy *e4b,
 	trace_ext4_mb_release_group_pa(sb, pa);
 	BUG_ON(pa-&gt;pa_deleted == 0);
 	ext4_get_group_no_and_offset(sb, pa-&gt;pa_pstart, &amp;group, &amp;bit);
-	BUG_ON(group != e4b-&gt;bd_group &amp;&amp; pa-&gt;pa_len != 0);
+	if (unlikely(group != e4b-&gt;bd_group &amp;&amp; pa-&gt;pa_len != 0)) {
+		ext4_warning(sb, "bad group: expected %u, group %u, pa_start %llu",
+			     e4b-&gt;bd_group, group, pa-&gt;pa_pstart);
+		return 0;
+	}
 	mb_free_blocks(pa-&gt;pa_inode, e4b, bit, pa-&gt;pa_len);
 	atomic_add(pa-&gt;pa_len, &amp;EXT4_SB(sb)-&gt;s_mb_discarded);
 	trace_ext4_mballoc_discard(sb, NULL, group, bit, pa-&gt;pa_len);</pre>
    <div class="pagination">
        <a href='1.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><span>[2]</span><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_3.html'>Next&gt;&gt;</a>
    <div>
</body>
