<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Fudan University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Fudan University</h1>
    <div class="pagination">
        <a href='16_4.html'>&lt;&lt;Prev</a><a href='16.html'>1</a><a href='16_2.html'>2</a><a href='16_3.html'>3</a><a href='16_4.html'>4</a><span>[5]</span><a href='16_6.html'>6</a><a href='16_7.html'>7</a><a href='16_6.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a4abc6b12eb1f7a533c2e7484cfa555454ff0977
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Mon May 25 22:15:41 2020 +0800

    nfsd: Fix svc_xprt refcnt leak when setup callback client failed
    
    nfsd4_process_cb_update() invokes svc_xprt_get(), which increases the
    refcount of the "c-&gt;cn_xprt".
    
    The reference counting issue happens in one exception handling path of
    nfsd4_process_cb_update(). When setup callback client failed, the
    function forgets to decrease the refcnt increased by svc_xprt_get(),
    causing a refcnt leak.
    
    Fix this issue by calling svc_xprt_put() when setup callback client
    failed.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 966ca75418c8..7fbe9840a03e 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -1306,6 +1306,8 @@ static void nfsd4_process_cb_update(struct nfsd4_callback *cb)
 	err = setup_callback_client(clp, &amp;conn, ses);
 	if (err) {
 		nfsd4_mark_cb_down(clp, err);
+		if (c)
+			svc_xprt_put(c-&gt;cn_xprt);
 		return;
 	}
 }</pre><hr><pre>commit 7217e6e694da3aae6d17db8a7f7460c8d4817ebf
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Mon May 25 22:16:24 2020 +0800

    scsi: lpfc: Fix lpfc_nodelist leak when processing unsolicited event
    
    In order to create or activate a new node, lpfc_els_unsol_buffer() invokes
    lpfc_nlp_init() or lpfc_enable_node() or lpfc_nlp_get(), all of them will
    return a reference of the specified lpfc_nodelist object to "ndlp" with
    increased refcnt.
    
    When lpfc_els_unsol_buffer() returns, local variable "ndlp" becomes
    invalid, so the refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one exception handling path of
    lpfc_els_unsol_buffer(). When "ndlp" in DEV_LOSS, the function forgets to
    decrease the refcnt increased by lpfc_nlp_init() or lpfc_enable_node() or
    lpfc_nlp_get(), causing a refcnt leak.
    
    Fix this issue by calling lpfc_nlp_put() when "ndlp" in DEV_LOSS.
    
    Link: https://lore.kernel.org/r/1590416184-52592-1-git-send-email-xiyuyang19@fudan.edu.cn
    Reviewed-by: Daniel Wagner &lt;dwagner@suse.de&gt;
    Reviewed-by: James Smart &lt;james.smart@broadcom.com&gt;
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c
index 565a21401660..3d670568a276 100644
--- a/drivers/scsi/lpfc/lpfc_els.c
+++ b/drivers/scsi/lpfc/lpfc_els.c
@@ -8508,6 +8508,8 @@ lpfc_els_unsol_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,
 	spin_lock_irq(shost-&gt;host_lock);
 	if (ndlp-&gt;nlp_flag &amp; NLP_IN_DEV_LOSS) {
 		spin_unlock_irq(shost-&gt;host_lock);
+		if (newnode)
+			lpfc_nlp_put(ndlp);
 		goto dropit;
 	}
 	spin_unlock_irq(shost-&gt;host_lock);</pre><hr><pre>commit c6b39f070722ea9963ffe756bfe94e89218c5e63
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Mon Apr 20 13:35:28 2020 +0800

    apparmor: Fix aa_label refcnt leak in policy_update
    
    policy_update() invokes begin_current_label_crit_section(), which
    returns a reference of the updated aa_label object to "label" with
    increased refcount.
    
    When policy_update() returns, "label" becomes invalid, so the refcount
    should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one exception handling path of
    policy_update(). When aa_may_manage_policy() returns not NULL, the
    refcnt increased by begin_current_label_crit_section() is not decreased,
    causing a refcnt leak.
    
    Fix this issue by jumping to "end_section" label when
    aa_may_manage_policy() returns not NULL.
    
    Fixes: 5ac8c355ae00 ("apparmor: allow introspecting the loaded policy pre internal transform")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: John Johansen &lt;john.johansen@canonical.com&gt;

diff --git a/security/apparmor/apparmorfs.c b/security/apparmor/apparmorfs.c
index 280741fc0f5f..f6a3ecfadf80 100644
--- a/security/apparmor/apparmorfs.c
+++ b/security/apparmor/apparmorfs.c
@@ -454,7 +454,7 @@ static ssize_t policy_update(u32 mask, const char __user *buf, size_t size,
 	 */
 	error = aa_may_manage_policy(label, ns, mask);
 	if (error)
-		return error;
+		goto end_section;
 
 	data = aa_simple_write_to_buffer(buf, size, size, pos);
 	error = PTR_ERR(data);
@@ -462,6 +462,7 @@ static ssize_t policy_update(u32 mask, const char __user *buf, size_t size,
 		error = aa_replace_profiles(ns, label, mask, data);
 		aa_put_loaddata(data);
 	}
+end_section:
 	end_current_label_crit_section(label);
 
 	return error;</pre><hr><pre>commit a0b845ffa0d91855532b50fc040aeb2d8338dca4
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Sun Apr 5 13:11:55 2020 +0800

    apparmor: fix potential label refcnt leak in aa_change_profile
    
    aa_change_profile() invokes aa_get_current_label(), which returns
    a reference of the current task's label.
    
    According to the comment of aa_get_current_label(), the returned
    reference must be put with aa_put_label().
    However, when the original object pointed by "label" becomes
    unreachable because aa_change_profile() returns or a new object
    is assigned to "label", reference count increased by
    aa_get_current_label() is not decreased, causing a refcnt leak.
    
    Fix this by calling aa_put_label() before aa_change_profile() return
    and dropping unnecessary aa_get_current_label().
    
    Fixes: 9fcf78cca198 ("apparmor: update domain transitions that are subsets of confinement at nnp")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: John Johansen &lt;john.johansen@canonical.com&gt;

diff --git a/security/apparmor/domain.c b/security/apparmor/domain.c
index 6ceb74e0f789..a84ef030fbd7 100644
--- a/security/apparmor/domain.c
+++ b/security/apparmor/domain.c
@@ -1328,6 +1328,7 @@ int aa_change_profile(const char *fqname, int flags)
 		ctx-&gt;nnp = aa_get_label(label);
 
 	if (!fqname || !*fqname) {
+		aa_put_label(label);
 		AA_DEBUG("no profile name");
 		return -EINVAL;
 	}
@@ -1346,8 +1347,6 @@ int aa_change_profile(const char *fqname, int flags)
 			op = OP_CHANGE_PROFILE;
 	}
 
-	label = aa_get_current_label();
-
 	if (*fqname == '&amp;') {
 		stack = true;
 		/* don't have label_parse() do stacking */</pre><hr><pre>commit a697ae6ea56e23397341b027098c1b11d9ab13da
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Sat Apr 25 20:48:35 2020 +0800

    ASoC: davinci-mcasp: Fix dma_chan refcnt leak when getting dma type
    
    davinci_mcasp_get_dma_type() invokes dma_request_chan(), which returns a
    reference of the specified dma_chan object to "chan" with increased
    refcnt.
    
    When davinci_mcasp_get_dma_type() returns, local variable "chan" becomes
    invalid, so the refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one exception handling path of
    davinci_mcasp_get_dma_type(). When chan device is NULL, the function
    forgets to decrease the refcnt increased by dma_request_chan(), causing
    a refcnt leak.
    
    Fix this issue by calling dma_release_channel() when chan device is
    NULL.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Acked-by: Peter Ujfalusi &lt;peter.ujfalusi@ti.com&gt;
    Link: https://lore.kernel.org/r/1587818916-38730-1-git-send-email-xiyuyang19@fudan.edu.cn
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/ti/davinci-mcasp.c b/sound/soc/ti/davinci-mcasp.c
index 734ffe925c4d..7a7db743dc5b 100644
--- a/sound/soc/ti/davinci-mcasp.c
+++ b/sound/soc/ti/davinci-mcasp.c
@@ -1896,8 +1896,10 @@ static int davinci_mcasp_get_dma_type(struct davinci_mcasp *mcasp)
 				PTR_ERR(chan));
 		return PTR_ERR(chan);
 	}
-	if (WARN_ON(!chan-&gt;device || !chan-&gt;device-&gt;dev))
+	if (WARN_ON(!chan-&gt;device || !chan-&gt;device-&gt;dev)) {
+		dma_release_channel(chan);
 		return -EINVAL;
+	}
 
 	if (chan-&gt;device-&gt;dev-&gt;of_node)
 		ret = of_property_read_string(chan-&gt;device-&gt;dev-&gt;of_node,</pre><hr><pre>commit 18f02ad19e2c2a1d9e1d55a4e1c0cbf51419151c
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Sun Apr 26 11:35:15 2020 +0800

    bpf: Fix sk_psock refcnt leak when receiving message
    
    tcp_bpf_recvmsg() invokes sk_psock_get(), which returns a reference of
    the specified sk_psock object to "psock" with increased refcnt.
    
    When tcp_bpf_recvmsg() returns, local variable "psock" becomes invalid,
    so the refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in several exception handling paths
    of tcp_bpf_recvmsg(). When those error scenarios occur such as "flags"
    includes MSG_ERRQUEUE, the function forgets to decrease the refcnt
    increased by sk_psock_get(), causing a refcnt leak.
    
    Fix this issue by calling sk_psock_put() or pulling up the error queue
    read handling when those error scenarios occur.
    
    Fixes: e7a5f1f1cd000 ("bpf/sockmap: Read psock ingress_msg before sk_receive_queue")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: Daniel Borkmann &lt;daniel@iogearbox.net&gt;
    Reviewed-by: Jakub Sitnicki &lt;jakub@cloudflare.com&gt;
    Link: https://lore.kernel.org/bpf/1587872115-42805-1-git-send-email-xiyuyang19@fudan.edu.cn

diff --git a/net/ipv4/tcp_bpf.c b/net/ipv4/tcp_bpf.c
index 5a05327f97c1..ff96466ea6da 100644
--- a/net/ipv4/tcp_bpf.c
+++ b/net/ipv4/tcp_bpf.c
@@ -262,14 +262,17 @@ static int tcp_bpf_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,
 	struct sk_psock *psock;
 	int copied, ret;
 
+	if (unlikely(flags &amp; MSG_ERRQUEUE))
+		return inet_recv_error(sk, msg, len, addr_len);
+
 	psock = sk_psock_get(sk);
 	if (unlikely(!psock))
 		return tcp_recvmsg(sk, msg, len, nonblock, flags, addr_len);
-	if (unlikely(flags &amp; MSG_ERRQUEUE))
-		return inet_recv_error(sk, msg, len, addr_len);
 	if (!skb_queue_empty(&amp;sk-&gt;sk_receive_queue) &amp;&amp;
-	    sk_psock_queue_empty(psock))
+	    sk_psock_queue_empty(psock)) {
+		sk_psock_put(sk, psock);
 		return tcp_recvmsg(sk, msg, len, nonblock, flags, addr_len);
+	}
 	lock_sock(sk);
 msg_bytes_ready:
 	copied = __tcp_bpf_recvmsg(sk, psock, msg, len, flags);</pre><hr><pre>commit 62b4011fa7bef9fa00a6aeec26e69685dc1cc21e
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Sat Apr 25 21:10:23 2020 +0800

    net/tls: Fix sk_psock refcnt leak when in tls_data_ready()
    
    tls_data_ready() invokes sk_psock_get(), which returns a reference of
    the specified sk_psock object to "psock" with increased refcnt.
    
    When tls_data_ready() returns, local variable "psock" becomes invalid,
    so the refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one exception handling path of
    tls_data_ready(). When "psock-&gt;ingress_msg" is empty but "psock" is not
    NULL, the function forgets to decrease the refcnt increased by
    sk_psock_get(), causing a refcnt leak.
    
    Fix this issue by calling sk_psock_put() on all paths when "psock" is
    not NULL.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/tls/tls_sw.c b/net/tls/tls_sw.c
index 704313dd082f..e23f94a5549b 100644
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@ -2083,8 +2083,9 @@ static void tls_data_ready(struct sock *sk)
 	strp_data_ready(&amp;ctx-&gt;strp);
 
 	psock = sk_psock_get(sk);
-	if (psock &amp;&amp; !list_empty(&amp;psock-&gt;ingress_msg)) {
-		ctx-&gt;saved_data_ready(sk);
+	if (psock) {
+		if (!list_empty(&amp;psock-&gt;ingress_msg))
+			ctx-&gt;saved_data_ready(sk);
 		sk_psock_put(sk, psock);
 	}
 }</pre><hr><pre>commit 4becb7ee5b3d2829ed7b9261a245a77d5b7de902
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Sat Apr 25 21:06:25 2020 +0800

    net/x25: Fix x25_neigh refcnt leak when x25 disconnect
    
    x25_connect() invokes x25_get_neigh(), which returns a reference of the
    specified x25_neigh object to "x25-&gt;neighbour" with increased refcnt.
    
    When x25 connect success and returns, the reference still be hold by
    "x25-&gt;neighbour", so the refcount should be decreased in
    x25_disconnect() to keep refcount balanced.
    
    The reference counting issue happens in x25_disconnect(), which forgets
    to decrease the refcnt increased by x25_get_neigh() in x25_connect(),
    causing a refcnt leak.
    
    Fix this issue by calling x25_neigh_put() before x25_disconnect()
    returns.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/x25/x25_subr.c b/net/x25/x25_subr.c
index 8aa415a38814..8b1b06cabcbf 100644
--- a/net/x25/x25_subr.c
+++ b/net/x25/x25_subr.c
@@ -357,6 +357,10 @@ void x25_disconnect(struct sock *sk, int reason, unsigned char cause,
 		sk-&gt;sk_state_change(sk);
 		sock_set_flag(sk, SOCK_DEAD);
 	}
+	read_lock_bh(&amp;x25_list_lock);
+	x25_neigh_put(x25-&gt;neighbour);
+	x25-&gt;neighbour = NULL;
+	read_unlock_bh(&amp;x25_list_lock);
 }
 
 /*</pre><hr><pre>commit 095f5614bfe16e5b3e191b34ea41b10d6fdd4ced
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Sat Apr 25 20:54:37 2020 +0800

    net/tls: Fix sk_psock refcnt leak in bpf_exec_tx_verdict()
    
    bpf_exec_tx_verdict() invokes sk_psock_get(), which returns a reference
    of the specified sk_psock object to "psock" with increased refcnt.
    
    When bpf_exec_tx_verdict() returns, local variable "psock" becomes
    invalid, so the refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in one exception handling path of
    bpf_exec_tx_verdict(). When "policy" equals to NULL but "psock" is not
    NULL, the function forgets to decrease the refcnt increased by
    sk_psock_get(), causing a refcnt leak.
    
    Fix this issue by calling sk_psock_put() on this error path before
    bpf_exec_tx_verdict() returns.
    
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/tls/tls_sw.c b/net/tls/tls_sw.c
index c98e602a1a2d..704313dd082f 100644
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@ -800,6 +800,8 @@ static int bpf_exec_tx_verdict(struct sk_msg *msg, struct sock *sk,
 			*copied -= sk_msg_free(sk, msg);
 			tls_free_open_rec(sk);
 		}
+		if (psock)
+			sk_psock_put(sk, psock);
 		return err;
 	}
 more_data:</pre><hr><pre>commit 5d5e100a20348c336e56df604b353b978f8adbb9
Author: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
Date:   Mon Apr 20 13:41:54 2020 +0800

    drm/i915/selftests: Fix i915_address_space refcnt leak
    
    igt_ppgtt_pin_update() invokes i915_gem_context_get_vm_rcu(), which
    returns a reference of the i915_address_space object to "vm" with
    increased refcount.
    
    When igt_ppgtt_pin_update() returns, "vm" becomes invalid, so the
    refcount should be decreased to keep refcount balanced.
    
    The reference counting issue happens in two exception handling paths of
    igt_ppgtt_pin_update(). When i915_gem_object_create_internal() returns
    IS_ERR, the refcnt increased by i915_gem_context_get_vm_rcu() is not
    decreased, causing a refcnt leak.
    
    Fix this issue by jumping to "out_vm" label when
    i915_gem_object_create_internal() returns IS_ERR.
    
    Fixes: a4e7ccdac38e ("drm/i915: Move context management under GEM")
    Signed-off-by: Xiyu Yang &lt;xiyuyang19@fudan.edu.cn&gt;
    Signed-off-by: Xin Tan &lt;tanxin.ctf@gmail.com&gt;
    Reviewed-by: Chris Wilson &lt;chris@chris-wilson.co.uk&gt;
    Signed-off-by: Chris Wilson &lt;chris@chris-wilson.co.uk&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/1587361342-83494-1-git-send-email-xiyuyang19@fudan.edu.cn
    (cherry picked from commit e07c7606a00c4361bad72ff4e72ed0dfbefa23b0)
    Signed-off-by: Rodrigo Vivi &lt;rodrigo.vivi@intel.com&gt;

diff --git a/drivers/gpu/drm/i915/gem/selftests/huge_pages.c b/drivers/gpu/drm/i915/gem/selftests/huge_pages.c
index 2d0fd50c5312..d4f94ca9ae0d 100644
--- a/drivers/gpu/drm/i915/gem/selftests/huge_pages.c
+++ b/drivers/gpu/drm/i915/gem/selftests/huge_pages.c
@@ -1477,8 +1477,10 @@ static int igt_ppgtt_pin_update(void *arg)
 		unsigned int page_size = BIT(first);
 
 		obj = i915_gem_object_create_internal(dev_priv, page_size);
-		if (IS_ERR(obj))
-			return PTR_ERR(obj);
+		if (IS_ERR(obj)) {
+			err = PTR_ERR(obj);
+			goto out_vm;
+		}
 
 		vma = i915_vma_instance(obj, vm, NULL);
 		if (IS_ERR(vma)) {
@@ -1531,8 +1533,10 @@ static int igt_ppgtt_pin_update(void *arg)
 	}
 
 	obj = i915_gem_object_create_internal(dev_priv, PAGE_SIZE);
-	if (IS_ERR(obj))
-		return PTR_ERR(obj);
+	if (IS_ERR(obj)) {
+		err = PTR_ERR(obj);
+		goto out_vm;
+	}
 
 	vma = i915_vma_instance(obj, vm, NULL);
 	if (IS_ERR(vma)) {</pre>
    <div class="pagination">
        <a href='16_4.html'>&lt;&lt;Prev</a><a href='16.html'>1</a><a href='16_2.html'>2</a><a href='16_3.html'>3</a><a href='16_4.html'>4</a><span>[5]</span><a href='16_6.html'>6</a><a href='16_7.html'>7</a><a href='16_6.html'>Next&gt;&gt;</a>
    <div>
</body>
