<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_133.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><span>[134]</span><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_135.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ff397be685e410a59c34b21ce0c55d4daa466bb7
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Fri Dec 6 16:55:40 2019 +0000

    efi/gop: Fix memory leak in __gop_query32/64()
    
    efi_graphics_output_protocol::query_mode() returns info in
    callee-allocated memory which must be freed by the caller, which
    we aren't doing.
    
    We don't actually need to call query_mode() in order to obtain the
    info for the current graphics mode, which is already there in
    gop-&gt;mode-&gt;info, so just access it directly in the setup_gop32/64()
    functions.
    
    Also nothing uses the size of the info structure, so don't update the
    passed-in size (which is the size of the gop_handle table in bytes)
    unnecessarily.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;
    Cc: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;
    Cc: Bhupesh Sharma &lt;bhsharma@redhat.com&gt;
    Cc: Masayoshi Mizuma &lt;m.mizuma@jp.fujitsu.com&gt;
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191206165542.31469-5-ardb@kernel.org
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/gop.c b/drivers/firmware/efi/libstub/gop.c
index 69b2b019a1d0..b7bf1e993b8b 100644
--- a/drivers/firmware/efi/libstub/gop.c
+++ b/drivers/firmware/efi/libstub/gop.c
@@ -83,30 +83,6 @@ setup_pixel_info(struct screen_info *si, u32 pixels_per_scan_line,
 	}
 }
 
-static efi_status_t
-__gop_query32(efi_system_table_t *sys_table_arg,
-	      struct efi_graphics_output_protocol_32 *gop32,
-	      struct efi_graphics_output_mode_info **info,
-	      unsigned long *size, u64 *fb_base)
-{
-	struct efi_graphics_output_protocol_mode_32 *mode;
-	efi_graphics_output_protocol_query_mode query_mode;
-	efi_status_t status;
-	unsigned long m;
-
-	m = gop32-&gt;mode;
-	mode = (struct efi_graphics_output_protocol_mode_32 *)m;
-	query_mode = (void *)(unsigned long)gop32-&gt;query_mode;
-
-	status = __efi_call_early(query_mode, (void *)gop32, mode-&gt;mode, size,
-				  info);
-	if (status != EFI_SUCCESS)
-		return status;
-
-	*fb_base = mode-&gt;frame_buffer_base;
-	return status;
-}
-
 static efi_status_t
 setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
             efi_guid_t *proto, unsigned long size, void **gop_handle)
@@ -128,6 +104,7 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 
 	nr_gops = size / sizeof(u32);
 	for (i = 0; i &lt; nr_gops; i++) {
+		struct efi_graphics_output_protocol_mode_32 *mode;
 		struct efi_graphics_output_mode_info *info = NULL;
 		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;
 		bool conout_found = false;
@@ -145,9 +122,11 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 		if (status == EFI_SUCCESS)
 			conout_found = true;
 
-		status = __gop_query32(sys_table_arg, gop32, &amp;info, &amp;size,
-				       &amp;current_fb_base);
-		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found) &amp;&amp;
+		mode = (void *)(unsigned long)gop32-&gt;mode;
+		info = (void *)(unsigned long)mode-&gt;info;
+		current_fb_base = mode-&gt;frame_buffer_base;
+
+		if ((!first_gop || conout_found) &amp;&amp;
 		    info-&gt;pixel_format != PIXEL_BLT_ONLY) {
 			/*
 			 * Systems that use the UEFI Console Splitter may
@@ -201,30 +180,6 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	return EFI_SUCCESS;
 }
 
-static efi_status_t
-__gop_query64(efi_system_table_t *sys_table_arg,
-	      struct efi_graphics_output_protocol_64 *gop64,
-	      struct efi_graphics_output_mode_info **info,
-	      unsigned long *size, u64 *fb_base)
-{
-	struct efi_graphics_output_protocol_mode_64 *mode;
-	efi_graphics_output_protocol_query_mode query_mode;
-	efi_status_t status;
-	unsigned long m;
-
-	m = gop64-&gt;mode;
-	mode = (struct efi_graphics_output_protocol_mode_64 *)m;
-	query_mode = (void *)(unsigned long)gop64-&gt;query_mode;
-
-	status = __efi_call_early(query_mode, (void *)gop64, mode-&gt;mode, size,
-				  info);
-	if (status != EFI_SUCCESS)
-		return status;
-
-	*fb_base = mode-&gt;frame_buffer_base;
-	return status;
-}
-
 static efi_status_t
 setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	    efi_guid_t *proto, unsigned long size, void **gop_handle)
@@ -246,6 +201,7 @@ setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 
 	nr_gops = size / sizeof(u64);
 	for (i = 0; i &lt; nr_gops; i++) {
+		struct efi_graphics_output_protocol_mode_64 *mode;
 		struct efi_graphics_output_mode_info *info = NULL;
 		efi_guid_t conout_proto = EFI_CONSOLE_OUT_DEVICE_GUID;
 		bool conout_found = false;
@@ -263,9 +219,11 @@ setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 		if (status == EFI_SUCCESS)
 			conout_found = true;
 
-		status = __gop_query64(sys_table_arg, gop64, &amp;info, &amp;size,
-				       &amp;current_fb_base);
-		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found) &amp;&amp;
+		mode = (void *)(unsigned long)gop64-&gt;mode;
+		info = (void *)(unsigned long)mode-&gt;info;
+		current_fb_base = mode-&gt;frame_buffer_base;
+
+		if ((!first_gop || conout_found) &amp;&amp;
 		    info-&gt;pixel_format != PIXEL_BLT_ONLY) {
 			/*
 			 * Systems that use the UEFI Console Splitter may</pre><hr><pre>commit dbd89c303b4420f6cdb689fd398349fc83b059dd
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Fri Dec 6 16:55:39 2019 +0000

    efi/gop: Return EFI_SUCCESS if a usable GOP was found
    
    If we've found a usable instance of the Graphics Output Protocol
    (GOP) with a framebuffer, it is possible that one of the later EFI
    calls fails while checking if any support console output. In this
    case status may be an EFI error code even though we found a usable
    GOP.
    
    Fix this by explicitly return EFI_SUCCESS if a usable GOP has been
    located.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;
    Cc: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;
    Cc: Bhupesh Sharma &lt;bhsharma@redhat.com&gt;
    Cc: Masayoshi Mizuma &lt;m.mizuma@jp.fujitsu.com&gt;
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191206165542.31469-4-ardb@kernel.org
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/gop.c b/drivers/firmware/efi/libstub/gop.c
index 08f3c1a2fb48..69b2b019a1d0 100644
--- a/drivers/firmware/efi/libstub/gop.c
+++ b/drivers/firmware/efi/libstub/gop.c
@@ -198,7 +198,7 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 
 	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;
 
-	return status;
+	return EFI_SUCCESS;
 }
 
 static efi_status_t
@@ -316,7 +316,7 @@ setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 
 	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;
 
-	return status;
+	return EFI_SUCCESS;
 }
 
 /*</pre><hr><pre>commit 6fc3cec30dfeee7d3c5db8154016aff9d65503c5
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Fri Dec 6 16:55:38 2019 +0000

    efi/gop: Return EFI_NOT_FOUND if there are no usable GOPs
    
    If we don't find a usable instance of the Graphics Output Protocol
    (GOP) because none of them have a framebuffer (i.e. they were all
    PIXEL_BLT_ONLY), but all the EFI calls succeeded, we will return
    EFI_SUCCESS even though we didn't find a usable GOP.
    
    Fix this by explicitly returning EFI_NOT_FOUND if no usable GOPs are
    found, allowing the caller to probe for UGA instead.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Signed-off-by: Ard Biesheuvel &lt;ardb@kernel.org&gt;
    Cc: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;
    Cc: Bhupesh Sharma &lt;bhsharma@redhat.com&gt;
    Cc: Masayoshi Mizuma &lt;m.mizuma@jp.fujitsu.com&gt;
    Cc: linux-efi@vger.kernel.org
    Link: https://lkml.kernel.org/r/20191206165542.31469-3-ardb@kernel.org
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/drivers/firmware/efi/libstub/gop.c b/drivers/firmware/efi/libstub/gop.c
index 0101ca4c13b1..08f3c1a2fb48 100644
--- a/drivers/firmware/efi/libstub/gop.c
+++ b/drivers/firmware/efi/libstub/gop.c
@@ -119,7 +119,7 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	u64 fb_base;
 	struct efi_pixel_bitmask pixel_info;
 	int pixel_format;
-	efi_status_t status = EFI_NOT_FOUND;
+	efi_status_t status;
 	u32 *handles = (u32 *)(unsigned long)gop_handle;
 	int i;
 
@@ -175,7 +175,7 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 
 	/* Did we find any GOPs? */
 	if (!first_gop)
-		goto out;
+		return EFI_NOT_FOUND;
 
 	/* EFI framebuffer */
 	si-&gt;orig_video_isVGA = VIDEO_TYPE_EFI;
@@ -197,7 +197,7 @@ setup_gop32(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	si-&gt;lfb_size = si-&gt;lfb_linelength * si-&gt;lfb_height;
 
 	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;
-out:
+
 	return status;
 }
 
@@ -237,7 +237,7 @@ setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	u64 fb_base;
 	struct efi_pixel_bitmask pixel_info;
 	int pixel_format;
-	efi_status_t status = EFI_NOT_FOUND;
+	efi_status_t status;
 	u64 *handles = (u64 *)(unsigned long)gop_handle;
 	int i;
 
@@ -293,7 +293,7 @@ setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 
 	/* Did we find any GOPs? */
 	if (!first_gop)
-		goto out;
+		return EFI_NOT_FOUND;
 
 	/* EFI framebuffer */
 	si-&gt;orig_video_isVGA = VIDEO_TYPE_EFI;
@@ -315,7 +315,7 @@ setup_gop64(efi_system_table_t *sys_table_arg, struct screen_info *si,
 	si-&gt;lfb_size = si-&gt;lfb_linelength * si-&gt;lfb_height;
 
 	si-&gt;capabilities |= VIDEO_CAPABILITY_SKIP_QUIRKS;
-out:
+
 	return status;
 }
 </pre><hr><pre>commit 9c24eaf81cc44d4bb38081c99eafd72ed85cf7f3
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Tue Oct 8 10:33:57 2019 -0400

    iommu/vt-d: Return the correct dma mask when we are bypassing the IOMMU
    
    We must return a mask covering the full physical RAM when bypassing the
    IOMMU mapping. Also, in iommu_need_mapping, we need to check using
    dma_direct_get_required_mask to ensure that the device's dma_mask can
    cover physical RAM before deciding to bypass IOMMU mapping.
    
    Based on an earlier patch from Christoph Hellwig.
    
    Fixes: 249baa547901 ("dma-mapping: provide a better default -&gt;get_required_mask")
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Reviewed-by: Lu Baolu &lt;baolu.lu@linux.intel.com&gt;
    Acked-by: Joerg Roedel &lt;jroedel@suse.de&gt;
    Signed-off-by: Christoph Hellwig &lt;hch@lst.de&gt;

diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c
index 3f974919d3bd..79e35b3180ac 100644
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@ -3471,7 +3471,7 @@ static bool iommu_need_mapping(struct device *dev)
 		if (dev-&gt;coherent_dma_mask &amp;&amp; dev-&gt;coherent_dma_mask &lt; dma_mask)
 			dma_mask = dev-&gt;coherent_dma_mask;
 
-		if (dma_mask &gt;= dma_get_required_mask(dev))
+		if (dma_mask &gt;= dma_direct_get_required_mask(dev))
 			return false;
 
 		/*
@@ -3775,6 +3775,13 @@ static int intel_map_sg(struct device *dev, struct scatterlist *sglist, int nele
 	return nelems;
 }
 
+static u64 intel_get_required_mask(struct device *dev)
+{
+	if (!iommu_need_mapping(dev))
+		return dma_direct_get_required_mask(dev);
+	return DMA_BIT_MASK(32);
+}
+
 static const struct dma_map_ops intel_dma_ops = {
 	.alloc = intel_alloc_coherent,
 	.free = intel_free_coherent,
@@ -3787,6 +3794,7 @@ static const struct dma_map_ops intel_dma_ops = {
 	.dma_supported = dma_direct_supported,
 	.mmap = dma_common_mmap,
 	.get_sgtable = dma_common_get_sgtable,
+	.get_required_mask = intel_get_required_mask,
 };
 
 static void</pre><hr><pre>commit bec500777089b3c96c53681fc0aa6fee59711d4a
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon Oct 7 18:00:02 2019 -0400

    lib/string: Make memzero_explicit() inline instead of external
    
    With the use of the barrier implied by barrier_data(), there is no need
    for memzero_explicit() to be extern. Making it inline saves the overhead
    of a function call, and allows the code to be reused in arch/*/purgatory
    without having to duplicate the implementation.
    
    Tested-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Reviewed-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;
    Cc: Borislav Petkov &lt;bp@alien8.de&gt;
    Cc: H . Peter Anvin &lt;hpa@zytor.com&gt;
    Cc: Herbert Xu &lt;herbert@gondor.apana.org.au&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Stephan Mueller &lt;smueller@chronox.de&gt;
    Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Cc: linux-crypto@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Fixes: 906a4bb97f5d ("crypto: sha256 - Use get/put_unaligned_be32 to get input, memzero_explicit")
    Link: https://lkml.kernel.org/r/20191007220000.GA408752@rani.riverdale.lan
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/include/linux/string.h b/include/linux/string.h
index b2f9df7f0761..b6ccdc2c7f02 100644
--- a/include/linux/string.h
+++ b/include/linux/string.h
@@ -227,7 +227,26 @@ static inline bool strstarts(const char *str, const char *prefix)
 }
 
 size_t memweight(const void *ptr, size_t bytes);
-void memzero_explicit(void *s, size_t count);
+
+/**
+ * memzero_explicit - Fill a region of memory (e.g. sensitive
+ *		      keying data) with 0s.
+ * @s: Pointer to the start of the area.
+ * @count: The size of the area.
+ *
+ * Note: usually using memset() is just fine (!), but in cases
+ * where clearing out _local_ data at the end of a scope is
+ * necessary, memzero_explicit() should be used instead in
+ * order to prevent the compiler from optimising away zeroing.
+ *
+ * memzero_explicit() doesn't need an arch-specific version as
+ * it just invokes the one of memset() implicitly.
+ */
+static inline void memzero_explicit(void *s, size_t count)
+{
+	memset(s, 0, count);
+	barrier_data(s);
+}
 
 /**
  * kbasename - return the last part of a pathname.
diff --git a/lib/string.c b/lib/string.c
index cd7a10c19210..08ec58cc673b 100644
--- a/lib/string.c
+++ b/lib/string.c
@@ -748,27 +748,6 @@ void *memset(void *s, int c, size_t count)
 EXPORT_SYMBOL(memset);
 #endif
 
-/**
- * memzero_explicit - Fill a region of memory (e.g. sensitive
- *		      keying data) with 0s.
- * @s: Pointer to the start of the area.
- * @count: The size of the area.
- *
- * Note: usually using memset() is just fine (!), but in cases
- * where clearing out _local_ data at the end of a scope is
- * necessary, memzero_explicit() should be used instead in
- * order to prevent the compiler from optimising away zeroing.
- *
- * memzero_explicit() doesn't need an arch-specific version as
- * it just invokes the one of memset() implicitly.
- */
-void memzero_explicit(void *s, size_t count)
-{
-	memset(s, 0, count);
-	barrier_data(s);
-}
-EXPORT_SYMBOL(memzero_explicit);
-
 #ifndef __HAVE_ARCH_MEMSET16
 /**
  * memset16() - Fill a memory area with a uint16_t</pre><hr><pre>commit ca14c996afe7228ff9b480cf225211cc17212688
Author: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
Date:   Mon Sep 23 13:17:54 2019 -0400

    x86/purgatory: Disable the stackleak GCC plugin for the purgatory
    
    Since commit:
    
      b059f801a937 ("x86/purgatory: Use CFLAGS_REMOVE rather than reset KBUILD_CFLAGS")
    
    kexec breaks if GCC_PLUGIN_STACKLEAK=y is enabled, as the purgatory
    contains undefined references to stackleak_track_stack.
    
    Attempting to load a kexec kernel results in this failure:
    
      kexec: Undefined symbol: stackleak_track_stack
      kexec-bzImage64: Loading purgatory failed
    
    Fix this by disabling the stackleak plugin for the purgatory.
    
    Signed-off-by: Arvind Sankar &lt;nivedita@alum.mit.edu&gt;
    Reviewed-by: Nick Desaulniers &lt;ndesaulniers@google.com&gt;
    Cc: Borislav Petkov &lt;bp@alien8.de&gt;
    Cc: H. Peter Anvin &lt;hpa@zytor.com&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Fixes: b059f801a937 ("x86/purgatory: Use CFLAGS_REMOVE rather than reset KBUILD_CFLAGS")
    Link: https://lkml.kernel.org/r/20190923171753.GA2252517@rani.riverdale.lan
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/arch/x86/purgatory/Makefile b/arch/x86/purgatory/Makefile
index 10fb42da0007..b81b5172cf99 100644
--- a/arch/x86/purgatory/Makefile
+++ b/arch/x86/purgatory/Makefile
@@ -23,6 +23,7 @@ KCOV_INSTRUMENT := n
 
 PURGATORY_CFLAGS_REMOVE := -mcmodel=kernel
 PURGATORY_CFLAGS := -mcmodel=large -ffreestanding -fno-zero-initialized-in-bss
+PURGATORY_CFLAGS += $(DISABLE_STACKLEAK_PLUGIN)
 
 # Default KBUILD_CFLAGS can have -pg option set when FTRACE is enabled. That
 # in turn leaves some undefined symbols like __fentry__ in purgatory and not</pre><hr><pre>commit af364a447b4ac34c719751fdec5dbdd74d888c3b
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Mon Jun 10 22:32:45 2019 -0400

    drm/nouveau/kms/nv50-: enable modern color management properties
    
    For GF119:GV100, we can enable DEGAMMA/CTM/GAMMA. For earlier GPUs, as
    there is no CTM, having both degamma and gamma is a bit pointless. Later
    GPUs currently lack an implementation.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv50/head.c b/drivers/gpu/drm/nouveau/dispnv50/head.c
index 929d93b1677e..46e7f4c51f10 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/head.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/head.c
@@ -512,6 +512,11 @@ nv50_head_create(struct drm_device *dev, int index)
 				  &amp;nv50_head_func, "head-%d", head-&gt;base.index);
 	drm_crtc_helper_add(crtc, &amp;nv50_head_help);
 	drm_mode_crtc_set_gamma_size(crtc, 256);
+	if (disp-&gt;disp-&gt;object.oclass &gt;= GF110_DISP &amp;&amp;
+	    disp-&gt;disp-&gt;object.oclass &lt; GV100_DISP)
+		drm_crtc_enable_color_mgmt(crtc, 256, true, 256);
+	else
+		drm_crtc_enable_color_mgmt(crtc, 0, false, 256);
 
 	if (head-&gt;func-&gt;olut_set) {
 		ret = nv50_lut_init(disp, &amp;drm-&gt;client.mmu, &amp;head-&gt;olut);</pre><hr><pre>commit 88b703527ba70659365d989f29579f1292ebf9c3
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Tue Jun 11 22:40:36 2019 -0400

    drm/nouveau/kms/gf119-: add ctm property support
    
    This adds support on GF119:GV100 (exclusive) for CTM (aka CSC).
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv50/atom.h b/drivers/gpu/drm/nouveau/dispnv50/atom.h
index b5fae5ab3fa8..75bda111da10 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/atom.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/atom.h
@@ -184,6 +184,11 @@ struct nv50_wndw_atom {
 		} i;
 	} xlut;
 
+	struct {
+		u32 matrix[12];
+		bool valid;
+	} csc;
+
 	struct {
 		u8  mode:2;
 		u8  interval:4;
@@ -221,6 +226,7 @@ struct nv50_wndw_atom {
 			bool ntfy:1;
 			bool sema:1;
 			bool xlut:1;
+			bool csc:1;
 			bool image:1;
 			bool scale:1;
 			bool point:1;
diff --git a/drivers/gpu/drm/nouveau/dispnv50/base907c.c b/drivers/gpu/drm/nouveau/dispnv50/base907c.c
index 049ce6da321c..fd0c1d84730b 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/base907c.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/base907c.c
@@ -83,6 +83,68 @@ base907c_ilut(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)
 	asyw-&gt;xlut.i.load = head907d_olut_load;
 }
 
+static inline u32
+csc_drm_to_base(u64 in)
+{
+	/* base takes a 19-bit 2's complement value in S3.16 format */
+	bool sign = in &amp; BIT_ULL(63);
+	u32 integer = (in &gt;&gt; 32) &amp; 0x7fffffff;
+	u32 fraction = in &amp; 0xffffffff;
+
+	if (integer &gt;= 4) {
+		return (1 &lt;&lt; 18) - (sign ? 0 : 1);
+	} else {
+		u32 ret = (integer &lt;&lt; 16) | (fraction &gt;&gt; 16);
+		if (sign)
+			ret = -ret;
+		return ret &amp; GENMASK(18, 0);
+	}
+}
+
+static void
+base907c_csc(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,
+	     const struct drm_color_ctm *ctm)
+{
+	int i, j;
+
+	for (j = 0; j &lt; 3; j++) {
+		for (i = 0; i &lt; 4; i++) {
+			u32 *val = &amp;asyw-&gt;csc.matrix[j * 4 + i];
+			/* DRM does not support constant offset, while
+			 * HW CSC does. Skip it. */
+			if (i == 3) {
+				*val = 0;
+			} else {
+				*val = csc_drm_to_base(ctm-&gt;matrix[j * 3 + i]);
+			}
+		}
+	}
+}
+
+static void
+base907c_csc_clr(struct nv50_wndw *wndw)
+{
+	u32 *push;
+	if ((push = evo_wait(&amp;wndw-&gt;wndw, 2))) {
+		evo_mthd(push, 0x0140, 1);
+		evo_data(push, 0x00000000);
+		evo_kick(push, &amp;wndw-&gt;wndw);
+	}
+}
+
+static void
+base907c_csc_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)
+{
+	u32 *push, i;
+	if ((push = evo_wait(&amp;wndw-&gt;wndw, 13))) {
+		evo_mthd(push, 0x0140, 12);
+		evo_data(push, asyw-&gt;csc.matrix[0] | 0x80000000);
+		for (i = 1; i &lt; 12; i++)
+			evo_data(push, asyw-&gt;csc.matrix[i]);
+		evo_kick(push, &amp;wndw-&gt;wndw);
+	}
+}
+
 const struct nv50_wndw_func
 base907c = {
 	.acquire = base507c_acquire,
@@ -94,6 +156,9 @@ base907c = {
 	.ntfy_clr = base507c_ntfy_clr,
 	.ntfy_wait_begun = base507c_ntfy_wait_begun,
 	.ilut = base907c_ilut,
+	.csc = base907c_csc,
+	.csc_set = base907c_csc_set,
+	.csc_clr = base907c_csc_clr,
 	.olut_core = true,
 	.xlut_set = base907c_xlut_set,
 	.xlut_clr = base907c_xlut_clr,
diff --git a/drivers/gpu/drm/nouveau/dispnv50/wndw.c b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
index dd01ea21da97..c8d078629722 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/wndw.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
@@ -120,6 +120,7 @@ nv50_wndw_flush_clr(struct nv50_wndw *wndw, u32 *interlock, bool flush,
 	if (clr.sema ) wndw-&gt;func-&gt; sema_clr(wndw);
 	if (clr.ntfy ) wndw-&gt;func-&gt; ntfy_clr(wndw);
 	if (clr.xlut ) wndw-&gt;func-&gt; xlut_clr(wndw);
+	if (clr.csc  ) wndw-&gt;func-&gt;  csc_clr(wndw);
 	if (clr.image) wndw-&gt;func-&gt;image_clr(wndw);
 
 	interlock[wndw-&gt;interlock.type] |= wndw-&gt;interlock.data;
@@ -147,6 +148,7 @@ nv50_wndw_flush_set(struct nv50_wndw *wndw, u32 *interlock,
 		wndw-&gt;func-&gt;xlut_set(wndw, asyw);
 	}
 
+	if (asyw-&gt;set.csc  ) wndw-&gt;func-&gt;csc_set  (wndw, asyw);
 	if (asyw-&gt;set.scale) wndw-&gt;func-&gt;scale_set(wndw, asyw);
 	if (asyw-&gt;set.point) {
 		if (asyw-&gt;set.point = false, asyw-&gt;set.mask)
@@ -347,6 +349,16 @@ nv50_wndw_atomic_check_lut(struct nv50_wndw *wndw,
 	    (!armw-&gt;visible || (armw-&gt;xlut.handle &amp;&amp; !asyw-&gt;xlut.handle)))
 		asyw-&gt;set.xlut = true;
 
+	if (wndw-&gt;func-&gt;csc &amp;&amp; asyh-&gt;state.ctm) {
+		const struct drm_color_ctm *ctm = asyh-&gt;state.ctm-&gt;data;
+		wndw-&gt;func-&gt;csc(wndw, asyw, ctm);
+		asyw-&gt;csc.valid = true;
+		asyw-&gt;set.csc = true;
+	} else {
+		asyw-&gt;csc.valid = false;
+		asyw-&gt;clr.csc = armw-&gt;csc.valid;
+	}
+
 	/* Can't do an immediate flip while changing the LUT. */
 	asyh-&gt;state.pageflip_flags &amp;= ~DRM_MODE_PAGE_FLIP_ASYNC;
 }
@@ -416,6 +428,7 @@ nv50_wndw_atomic_check(struct drm_plane *plane, struct drm_plane_state *state)
 		asyw-&gt;clr.ntfy = armw-&gt;ntfy.handle != 0;
 		asyw-&gt;clr.sema = armw-&gt;sema.handle != 0;
 		asyw-&gt;clr.xlut = armw-&gt;xlut.handle != 0;
+		asyw-&gt;clr.csc  = armw-&gt;csc.valid;
 		if (wndw-&gt;func-&gt;image_clr)
 			asyw-&gt;clr.image = armw-&gt;image.handle[0] != 0;
 	}
@@ -507,6 +520,7 @@ nv50_wndw_atomic_duplicate_state(struct drm_plane *plane)
 	asyw-&gt;ntfy = armw-&gt;ntfy;
 	asyw-&gt;ilut = NULL;
 	asyw-&gt;xlut = armw-&gt;xlut;
+	asyw-&gt;csc  = armw-&gt;csc;
 	asyw-&gt;image = armw-&gt;image;
 	asyw-&gt;point = armw-&gt;point;
 	asyw-&gt;clr.mask = 0;
diff --git a/drivers/gpu/drm/nouveau/dispnv50/wndw.h b/drivers/gpu/drm/nouveau/dispnv50/wndw.h
index 03f3d8dc235a..1e781d80c990 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/wndw.h
+++ b/drivers/gpu/drm/nouveau/dispnv50/wndw.h
@@ -65,6 +65,10 @@ struct nv50_wndw_func {
 	int (*ntfy_wait_begun)(struct nouveau_bo *, u32 offset,
 			       struct nvif_device *);
 	void (*ilut)(struct nv50_wndw *, struct nv50_wndw_atom *);
+	void (*csc)(struct nv50_wndw *, struct nv50_wndw_atom *,
+		    const struct drm_color_ctm *);
+	void (*csc_set)(struct nv50_wndw *, struct nv50_wndw_atom *);
+	void (*csc_clr)(struct nv50_wndw *);
 	bool ilut_identity;
 	bool olut_core;
 	void (*xlut_set)(struct nv50_wndw *, struct nv50_wndw_atom *);</pre><hr><pre>commit 7c844e9d95fb210b40398516d3d7525e8fa38a5f
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Mon Jun 3 01:59:42 2019 -0400

    drm/nouveau/kms/nv50-: remove overlay alpha formats
    
    The overlay logic can only do colorkey-based selection, not
    alpha-blending.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly507e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly507e.c
index 7354aaf79158..8ccd96113bad 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/ovly507e.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly507e.c
@@ -161,9 +161,7 @@ ovly507e_format[] = {
 	DRM_FORMAT_YUYV,
 	DRM_FORMAT_UYVY,
 	DRM_FORMAT_XRGB8888,
-	DRM_FORMAT_ARGB8888,
 	DRM_FORMAT_XRGB1555,
-	DRM_FORMAT_ARGB1555,
 	0
 };
 
diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly827e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly827e.c
index aaa9fe5a4fc8..2e68fc736fe1 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/ovly827e.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly827e.c
@@ -90,11 +90,8 @@ ovly827e_format[] = {
 	DRM_FORMAT_YUYV,
 	DRM_FORMAT_UYVY,
 	DRM_FORMAT_XRGB8888,
-	DRM_FORMAT_ARGB8888,
 	DRM_FORMAT_XRGB1555,
-	DRM_FORMAT_ARGB1555,
 	DRM_FORMAT_XBGR2101010,
-	DRM_FORMAT_ABGR2101010,
 	0
 };
 
diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
index f947117d62b1..9efe5e9d5ce4 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
@@ -66,13 +66,9 @@ ovly907e_format[] = {
 	DRM_FORMAT_YUYV,
 	DRM_FORMAT_UYVY,
 	DRM_FORMAT_XRGB8888,
-	DRM_FORMAT_ARGB8888,
 	DRM_FORMAT_XRGB1555,
-	DRM_FORMAT_ARGB1555,
 	DRM_FORMAT_XBGR2101010,
-	DRM_FORMAT_ABGR2101010,
 	DRM_FORMAT_XBGR16161616F,
-	DRM_FORMAT_ABGR16161616F,
 	0
 };
 
diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c
index fab567e258f9..e24d6fd23450 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c
@@ -26,15 +26,10 @@ ovly917e_format[] = {
 	DRM_FORMAT_YUYV,
 	DRM_FORMAT_UYVY,
 	DRM_FORMAT_XRGB8888,
-	DRM_FORMAT_ARGB8888,
 	DRM_FORMAT_XRGB1555,
-	DRM_FORMAT_ARGB1555,
 	DRM_FORMAT_XBGR2101010,
-	DRM_FORMAT_ABGR2101010,
 	DRM_FORMAT_XRGB2101010,
-	DRM_FORMAT_ARGB2101010,
 	DRM_FORMAT_XBGR16161616F,
-	DRM_FORMAT_ABGR16161616F,
 	0
 };
 </pre><hr><pre>commit 38a72243235ecf2c1359ce66ebed29a7dfb680f7
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Mon May 27 22:58:37 2019 -0400

    drm/nouveau/kms/nv50-: add fp16 scanout support
    
    Older hardware seems to want 0..1024 values, while new hardware takes
    0..1 values. We set the gain to 1024 for the earlier display classes.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv50/base507c.c b/drivers/gpu/drm/nouveau/dispnv50/base507c.c
index 80e020611bcb..00a85f1e1a4a 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/base507c.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/base507c.c
@@ -58,12 +58,21 @@ static void
 base507c_image_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)
 {
 	u32 *push;
-	if ((push = evo_wait(&amp;wndw-&gt;wndw, 10))) {
+	if ((push = evo_wait(&amp;wndw-&gt;wndw, 13))) {
 		evo_mthd(push, 0x0084, 1);
 		evo_data(push, asyw-&gt;image.mode &lt;&lt; 8 |
 			       asyw-&gt;image.interval &lt;&lt; 4);
 		evo_mthd(push, 0x00c0, 1);
 		evo_data(push, asyw-&gt;image.handle[0]);
+		if (asyw-&gt;image.format == 0xca) {
+			evo_mthd(push, 0x0110, 2);
+			evo_data(push, 1);
+			evo_data(push, 0x6400);
+		} else {
+			evo_mthd(push, 0x0110, 2);
+			evo_data(push, 0);
+			evo_data(push, 0);
+		}
 		evo_mthd(push, 0x0800, 5);
 		evo_data(push, asyw-&gt;image.offset[0] &gt;&gt; 8);
 		evo_data(push, 0x00000000);
@@ -181,9 +190,6 @@ base507c_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,
 	const struct drm_framebuffer *fb = asyw-&gt;state.fb;
 	int ret;
 
-	if (!fb-&gt;format-&gt;depth)
-		return -EINVAL;
-
 	ret = drm_atomic_helper_check_plane_state(&amp;asyw-&gt;state, &amp;asyh-&gt;state,
 						  DRM_PLANE_HELPER_NO_SCALING,
 						  DRM_PLANE_HELPER_NO_SCALING,
@@ -202,6 +208,14 @@ base507c_acquire(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw,
 	asyh-&gt;base.y = asyw-&gt;state.src.y1 &gt;&gt; 16;
 	asyh-&gt;base.w = asyw-&gt;state.fb-&gt;width;
 	asyh-&gt;base.h = asyw-&gt;state.fb-&gt;height;
+
+	/* Some newer formats, esp FP16 ones, don't have a
+	 * "depth". There's nothing that really makes sense there
+	 * either, so just set it to the implicit bit count.
+	 */
+	if (!asyh-&gt;base.depth)
+		asyh-&gt;base.depth = asyh-&gt;base.cpp * 8;
+
 	return 0;
 }
 
@@ -217,6 +231,8 @@ base507c_format[] = {
 	DRM_FORMAT_ABGR2101010,
 	DRM_FORMAT_XBGR8888,
 	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_XBGR16161616F,
+	DRM_FORMAT_ABGR16161616F,
 	0
 };
 
diff --git a/drivers/gpu/drm/nouveau/dispnv50/base827c.c b/drivers/gpu/drm/nouveau/dispnv50/base827c.c
index 73646819a0d6..f4c05949dd62 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/base827c.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/base827c.c
@@ -25,12 +25,21 @@ static void
 base827c_image_set(struct nv50_wndw *wndw, struct nv50_wndw_atom *asyw)
 {
 	u32 *push;
-	if ((push = evo_wait(&amp;wndw-&gt;wndw, 10))) {
+	if ((push = evo_wait(&amp;wndw-&gt;wndw, 13))) {
 		evo_mthd(push, 0x0084, 1);
 		evo_data(push, asyw-&gt;image.mode &lt;&lt; 8 |
 			       asyw-&gt;image.interval &lt;&lt; 4);
 		evo_mthd(push, 0x00c0, 1);
 		evo_data(push, asyw-&gt;image.handle[0]);
+		if (asyw-&gt;image.format == 0xca) {
+			evo_mthd(push, 0x0110, 2);
+			evo_data(push, 1);
+			evo_data(push, 0x6400);
+		} else {
+			evo_mthd(push, 0x0110, 2);
+			evo_data(push, 0);
+			evo_data(push, 0);
+		}
 		evo_mthd(push, 0x0800, 5);
 		evo_data(push, asyw-&gt;image.offset[0] &gt;&gt; 8);
 		evo_data(push, 0x00000000);
diff --git a/drivers/gpu/drm/nouveau/dispnv50/base917c.c b/drivers/gpu/drm/nouveau/dispnv50/base917c.c
index 54d705bb81a5..a1baed4fe0e9 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/base917c.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/base917c.c
@@ -36,6 +36,8 @@ base917c_format[] = {
 	DRM_FORMAT_ABGR8888,
 	DRM_FORMAT_XRGB2101010,
 	DRM_FORMAT_ARGB2101010,
+	DRM_FORMAT_XBGR16161616F,
+	DRM_FORMAT_ABGR16161616F,
 	0
 };
 
diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
index a3ce53046015..f947117d62b1 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly907e.c
@@ -61,10 +61,25 @@ ovly907e = {
 	.update = ovly507e_update,
 };
 
+static const u32
+ovly907e_format[] = {
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_UYVY,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_XRGB1555,
+	DRM_FORMAT_ARGB1555,
+	DRM_FORMAT_XBGR2101010,
+	DRM_FORMAT_ABGR2101010,
+	DRM_FORMAT_XBGR16161616F,
+	DRM_FORMAT_ABGR16161616F,
+	0
+};
+
 int
 ovly907e_new(struct nouveau_drm *drm, int head, s32 oclass,
 	     struct nv50_wndw **pwndw)
 {
-	return ovly507e_new_(&amp;ovly907e, ovly827e_format, drm, head, oclass,
+	return ovly507e_new_(&amp;ovly907e, ovly907e_format, drm, head, oclass,
 			     0x00000004 &lt;&lt; (head * 4), pwndw);
 }
diff --git a/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c b/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c
index 505fa7e78523..fab567e258f9 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/ovly917e.c
@@ -33,6 +33,8 @@ ovly917e_format[] = {
 	DRM_FORMAT_ABGR2101010,
 	DRM_FORMAT_XRGB2101010,
 	DRM_FORMAT_ARGB2101010,
+	DRM_FORMAT_XBGR16161616F,
+	DRM_FORMAT_ABGR16161616F,
 	0
 };
 
diff --git a/drivers/gpu/drm/nouveau/dispnv50/wndw.c b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
index 0aaa7e0013f6..dd01ea21da97 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/wndw.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/wndw.c
@@ -204,18 +204,20 @@ static int
 nv50_wndw_atomic_check_acquire_rgb(struct nv50_wndw_atom *asyw)
 {
 	switch (asyw-&gt;state.fb-&gt;format-&gt;format) {
-	case DRM_FORMAT_C8         : asyw-&gt;image.format = 0x1e; break;
-	case DRM_FORMAT_XRGB8888   :
-	case DRM_FORMAT_ARGB8888   : asyw-&gt;image.format = 0xcf; break;
-	case DRM_FORMAT_RGB565     : asyw-&gt;image.format = 0xe8; break;
-	case DRM_FORMAT_XRGB1555   :
-	case DRM_FORMAT_ARGB1555   : asyw-&gt;image.format = 0xe9; break;
-	case DRM_FORMAT_XBGR2101010:
-	case DRM_FORMAT_ABGR2101010: asyw-&gt;image.format = 0xd1; break;
-	case DRM_FORMAT_XBGR8888   :
-	case DRM_FORMAT_ABGR8888   : asyw-&gt;image.format = 0xd5; break;
-	case DRM_FORMAT_XRGB2101010:
-	case DRM_FORMAT_ARGB2101010: asyw-&gt;image.format = 0xdf; break;
+	case DRM_FORMAT_C8           : asyw-&gt;image.format = 0x1e; break;
+	case DRM_FORMAT_XRGB8888     :
+	case DRM_FORMAT_ARGB8888     : asyw-&gt;image.format = 0xcf; break;
+	case DRM_FORMAT_RGB565       : asyw-&gt;image.format = 0xe8; break;
+	case DRM_FORMAT_XRGB1555     :
+	case DRM_FORMAT_ARGB1555     : asyw-&gt;image.format = 0xe9; break;
+	case DRM_FORMAT_XBGR2101010  :
+	case DRM_FORMAT_ABGR2101010  : asyw-&gt;image.format = 0xd1; break;
+	case DRM_FORMAT_XBGR8888     :
+	case DRM_FORMAT_ABGR8888     : asyw-&gt;image.format = 0xd5; break;
+	case DRM_FORMAT_XRGB2101010  :
+	case DRM_FORMAT_ARGB2101010  : asyw-&gt;image.format = 0xdf; break;
+	case DRM_FORMAT_XBGR16161616F:
+	case DRM_FORMAT_ABGR16161616F: asyw-&gt;image.format = 0xca; break;
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/gpu/drm/nouveau/dispnv50/wndwc37e.c b/drivers/gpu/drm/nouveau/dispnv50/wndwc37e.c
index e52a85c83f7a..826d1d760d3a 100644
--- a/drivers/gpu/drm/nouveau/dispnv50/wndwc37e.c
+++ b/drivers/gpu/drm/nouveau/dispnv50/wndwc37e.c
@@ -216,6 +216,8 @@ wndwc37e_format[] = {
 	DRM_FORMAT_ABGR8888,
 	DRM_FORMAT_XRGB2101010,
 	DRM_FORMAT_ARGB2101010,
+	DRM_FORMAT_XBGR16161616F,
+	DRM_FORMAT_ABGR16161616F,
 	0
 };
 </pre>
    <div class="pagination">
        <a href='1_133.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><span>[134]</span><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_135.html'>Next&gt;&gt;</a>
    <div>
</body>
