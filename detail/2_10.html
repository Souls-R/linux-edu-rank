<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_9.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><span>[10]</span><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_11.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8f38f8e0a30e1c33cdfc48eba2bd63ac2eae373a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 6 11:14:36 2020 -0400

    scsi: block: pm: Simplify resume handling
    
    Commit 05d18ae1cc8a ("scsi: pm: Balance pm_only counter of request queue
    during system resume") fixed a problem in the block layer's runtime-PM
    code: blk_set_runtime_active() failed to call blk_clear_pm_only().
    However, the commit's implementation was awkward; it forced the SCSI
    system-resume handler to choose whether to call blk_post_runtime_resume()
    or blk_set_runtime_active(), depending on whether or not the SCSI device
    had previously been runtime suspended.
    
    This patch simplifies the situation considerably by adding the missing
    function call directly into blk_set_runtime_active() (under the condition
    that the queue is not already in the RPM_ACTIVE state).  This allows the
    SCSI routine to revert back to its original form.  Furthermore, making this
    change reveals that blk_post_runtime_resume() (in its success pathway) does
    exactly the same thing as blk_set_runtime_active().  The duplicate code is
    easily removed by making one routine call the other.
    
    No functional changes are intended.
    
    Link: https://lore.kernel.org/r/20200706151436.GA702867@rowland.harvard.edu
    CC: Can Guo &lt;cang@codeaurora.org&gt;
    CC: Bart Van Assche &lt;bvanassche@acm.org&gt;
    Reviewed-by: Bart Van Assche &lt;bvanassche@acm.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/block/blk-pm.c b/block/blk-pm.c
index 1adc1cd748b4..b85234d758f7 100644
--- a/block/blk-pm.c
+++ b/block/blk-pm.c
@@ -164,9 +164,8 @@ EXPORT_SYMBOL(blk_pre_runtime_resume);
  *
  * Description:
  *    Update the queue's runtime status according to the return value of the
- *    device's runtime_resume function. If it is successfully resumed, process
- *    the requests that are queued into the device's queue when it is resuming
- *    and then mark last busy and initiate autosuspend for it.
+ *    device's runtime_resume function. If the resume was successful, call
+ *    blk_set_runtime_active() to do the real work of restarting the queue.
  *
  *    This function should be called near the end of the device's
  *    runtime_resume callback.
@@ -175,19 +174,13 @@ void blk_post_runtime_resume(struct request_queue *q, int err)
 {
 	if (!q-&gt;dev)
 		return;
-
-	spin_lock_irq(&amp;q-&gt;queue_lock);
 	if (!err) {
-		q-&gt;rpm_status = RPM_ACTIVE;
-		pm_runtime_mark_last_busy(q-&gt;dev);
-		pm_request_autosuspend(q-&gt;dev);
+		blk_set_runtime_active(q);
 	} else {
+		spin_lock_irq(&amp;q-&gt;queue_lock);
 		q-&gt;rpm_status = RPM_SUSPENDED;
+		spin_unlock_irq(&amp;q-&gt;queue_lock);
 	}
-	spin_unlock_irq(&amp;q-&gt;queue_lock);
-
-	if (!err)
-		blk_clear_pm_only(q);
 }
 EXPORT_SYMBOL(blk_post_runtime_resume);
 
@@ -204,15 +197,25 @@ EXPORT_SYMBOL(blk_post_runtime_resume);
  * This function can be used in driver's resume hook to correct queue
  * runtime PM status and re-enable peeking requests from the queue. It
  * should be called before first request is added to the queue.
+ *
+ * This function is also called by blk_post_runtime_resume() for successful
+ * runtime resumes.  It does everything necessary to restart the queue.
  */
 void blk_set_runtime_active(struct request_queue *q)
 {
-	if (q-&gt;dev) {
-		spin_lock_irq(&amp;q-&gt;queue_lock);
-		q-&gt;rpm_status = RPM_ACTIVE;
-		pm_runtime_mark_last_busy(q-&gt;dev);
-		pm_request_autosuspend(q-&gt;dev);
-		spin_unlock_irq(&amp;q-&gt;queue_lock);
-	}
+	int old_status;
+
+	if (!q-&gt;dev)
+		return;
+
+	spin_lock_irq(&amp;q-&gt;queue_lock);
+	old_status = q-&gt;rpm_status;
+	q-&gt;rpm_status = RPM_ACTIVE;
+	pm_runtime_mark_last_busy(q-&gt;dev);
+	pm_request_autosuspend(q-&gt;dev);
+	spin_unlock_irq(&amp;q-&gt;queue_lock);
+
+	if (old_status != RPM_ACTIVE)
+		blk_clear_pm_only(q);
 }
 EXPORT_SYMBOL(blk_set_runtime_active);
diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index 5f0ad8b32e3a..3717eea37ecb 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -80,10 +80,6 @@ static int scsi_dev_type_resume(struct device *dev,
 	dev_dbg(dev, "scsi resume: %d\n", err);
 
 	if (err == 0) {
-		bool was_runtime_suspended;
-
-		was_runtime_suspended = pm_runtime_suspended(dev);
-
 		pm_runtime_disable(dev);
 		err = pm_runtime_set_active(dev);
 		pm_runtime_enable(dev);
@@ -97,10 +93,8 @@ static int scsi_dev_type_resume(struct device *dev,
 		 */
 		if (!err &amp;&amp; scsi_is_sdev_device(dev)) {
 			struct scsi_device *sdev = to_scsi_device(dev);
-			if (was_runtime_suspended)
-				blk_post_runtime_resume(sdev-&gt;request_queue, 0);
-			else
-				blk_set_runtime_active(sdev-&gt;request_queue);
+
+			blk_set_runtime_active(sdev-&gt;request_queue);
 		}
 	}
 </pre><hr><pre>commit ac854131d9844f79e2fdcef67a7707227538d78a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 1 16:07:28 2020 -0400

    USB: core: Fix misleading driver bug report
    
    The syzbot fuzzer found a race between URB submission to endpoint 0
    and device reset.  Namely, during the reset we call usb_ep0_reinit()
    because the characteristics of ep0 may have changed (if the reset
    follows a firmware update, for example).  While usb_ep0_reinit() is
    running there is a brief period during which the pointers stored in
    udev-&gt;ep_in[0] and udev-&gt;ep_out[0] are set to NULL, and if an URB is
    submitted to ep0 during that period, usb_urb_ep_type_check() will
    report it as a driver bug.  In the absence of those pointers, the
    routine thinks that the endpoint doesn't exist.  The log message looks
    like this:
    
    ------------[ cut here ]------------
    usb 2-1: BOGUS urb xfer, pipe 2 != type 2
    WARNING: CPU: 0 PID: 9241 at drivers/usb/core/urb.c:478
    usb_submit_urb+0x1188/0x1460 drivers/usb/core/urb.c:478
    
    Now, although submitting an URB while the device is being reset is a
    questionable thing to do, it shouldn't count as a driver bug as severe
    as submitting an URB for an endpoint that doesn't exist.  Indeed,
    endpoint 0 always exists, even while the device is in its unconfigured
    state.
    
    To prevent these misleading driver bug reports, this patch updates
    usb_disable_endpoint() to avoid clearing the ep_in[] and ep_out[]
    pointers when the endpoint being disabled is ep0.  There's no danger
    of leaving a stale pointer in place, because the usb_host_endpoint
    structure being pointed to is stored permanently in udev-&gt;ep0; it
    doesn't get deallocated until the entire usb_device structure does.
    
    Reported-and-tested-by: syzbot+db339689b2101f6f6071@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2005011558590.903-100000@netrider.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a48678a0c83a..6197938dcc2d 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1144,11 +1144,11 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,
 
 	if (usb_endpoint_out(epaddr)) {
 		ep = dev-&gt;ep_out[epnum];
-		if (reset_hardware)
+		if (reset_hardware &amp;&amp; epnum != 0)
 			dev-&gt;ep_out[epnum] = NULL;
 	} else {
 		ep = dev-&gt;ep_in[epnum];
-		if (reset_hardware)
+		if (reset_hardware &amp;&amp; epnum != 0)
 			dev-&gt;ep_in[epnum] = NULL;
 	}
 	if (ep) {</pre><hr><pre>commit 0ed08faded1da03eb3def61502b27f81aef2e615
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:18:48 2020 -0400

    HID: usbhid: Fix race between usbhid_close() and usbhid_stop()
    
    The syzbot fuzzer discovered a bad race between in the usbhid driver
    between usbhid_stop() and usbhid_close().  In particular,
    usbhid_stop() does:
    
            usb_free_urb(usbhid-&gt;urbin);
            ...
            usbhid-&gt;urbin = NULL; /* don't mess up next start */
    
    and usbhid_close() does:
    
            usb_kill_urb(usbhid-&gt;urbin);
    
    with no mutual exclusion.  If the two routines happen to run
    concurrently so that usb_kill_urb() is called in between the
    usb_free_urb() and the NULL assignment, it will access the
    deallocated urb structure -- a use-after-free bug.
    
    This patch adds a mutex to the usbhid private structure and uses it to
    enforce mutual exclusion of the usbhid_start(), usbhid_stop(),
    usbhid_open() and usbhid_close() callbacks.
    
    Reported-and-tested-by: syzbot+7bf5a7b0f0a1f9446f4c@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index c7bc9db5b192..17a638f15082 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -682,16 +682,21 @@ static int usbhid_open(struct hid_device *hid)
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int res;
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	set_bit(HID_OPENED, &amp;usbhid-&gt;iofl);
 
-	if (hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL)
-		return 0;
+	if (hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL) {
+		res = 0;
+		goto Done;
+	}
 
 	res = usb_autopm_get_interface(usbhid-&gt;intf);
 	/* the device must be awake to reliably request remote wakeup */
 	if (res &lt; 0) {
 		clear_bit(HID_OPENED, &amp;usbhid-&gt;iofl);
-		return -EIO;
+		res = -EIO;
+		goto Done;
 	}
 
 	usbhid-&gt;intf-&gt;needs_remote_wakeup = 1;
@@ -725,6 +730,9 @@ static int usbhid_open(struct hid_device *hid)
 		msleep(50);
 
 	clear_bit(HID_RESUME_RUNNING, &amp;usbhid-&gt;iofl);
+
+ Done:
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 	return res;
 }
 
@@ -732,6 +740,8 @@ static void usbhid_close(struct hid_device *hid)
 {
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	/*
 	 * Make sure we don't restart data acquisition due to
 	 * a resumption we no longer care about by avoiding racing
@@ -743,12 +753,13 @@ static void usbhid_close(struct hid_device *hid)
 		clear_bit(HID_IN_POLLING, &amp;usbhid-&gt;iofl);
 	spin_unlock_irq(&amp;usbhid-&gt;lock);
 
-	if (hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL)
-		return;
+	if (!(hid-&gt;quirks &amp; HID_QUIRK_ALWAYS_POLL)) {
+		hid_cancel_delayed_stuff(usbhid);
+		usb_kill_urb(usbhid-&gt;urbin);
+		usbhid-&gt;intf-&gt;needs_remote_wakeup = 0;
+	}
 
-	hid_cancel_delayed_stuff(usbhid);
-	usb_kill_urb(usbhid-&gt;urbin);
-	usbhid-&gt;intf-&gt;needs_remote_wakeup = 0;
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 }
 
 /*
@@ -1057,6 +1068,8 @@ static int usbhid_start(struct hid_device *hid)
 	unsigned int n, insize = 0;
 	int ret;
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	clear_bit(HID_DISCONNECTED, &amp;usbhid-&gt;iofl);
 
 	usbhid-&gt;bufsize = HID_MIN_BUFFER_SIZE;
@@ -1177,6 +1190,8 @@ static int usbhid_start(struct hid_device *hid)
 		usbhid_set_leds(hid);
 		device_set_wakeup_enable(&amp;dev-&gt;dev, 1);
 	}
+
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 	return 0;
 
 fail:
@@ -1187,6 +1202,7 @@ static int usbhid_start(struct hid_device *hid)
 	usbhid-&gt;urbout = NULL;
 	usbhid-&gt;urbctrl = NULL;
 	hid_free_buffers(dev, hid);
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 	return ret;
 }
 
@@ -1202,6 +1218,8 @@ static void usbhid_stop(struct hid_device *hid)
 		usbhid-&gt;intf-&gt;needs_remote_wakeup = 0;
 	}
 
+	mutex_lock(&amp;usbhid-&gt;mutex);
+
 	clear_bit(HID_STARTED, &amp;usbhid-&gt;iofl);
 	spin_lock_irq(&amp;usbhid-&gt;lock);	/* Sync with error and led handlers */
 	set_bit(HID_DISCONNECTED, &amp;usbhid-&gt;iofl);
@@ -1222,6 +1240,8 @@ static void usbhid_stop(struct hid_device *hid)
 	usbhid-&gt;urbout = NULL;
 
 	hid_free_buffers(hid_to_usb_dev(hid), hid);
+
+	mutex_unlock(&amp;usbhid-&gt;mutex);
 }
 
 static int usbhid_power(struct hid_device *hid, int lvl)
@@ -1382,6 +1402,7 @@ static int usbhid_probe(struct usb_interface *intf, const struct usb_device_id *
 	INIT_WORK(&amp;usbhid-&gt;reset_work, hid_reset);
 	timer_setup(&amp;usbhid-&gt;io_retry, hid_retry_timeout, 0);
 	spin_lock_init(&amp;usbhid-&gt;lock);
+	mutex_init(&amp;usbhid-&gt;mutex);
 
 	ret = hid_add_device(hid);
 	if (ret) {
diff --git a/drivers/hid/usbhid/usbhid.h b/drivers/hid/usbhid/usbhid.h
index 8620408bd7af..75fe85d3d27a 100644
--- a/drivers/hid/usbhid/usbhid.h
+++ b/drivers/hid/usbhid/usbhid.h
@@ -80,6 +80,7 @@ struct usbhid_device {
 	dma_addr_t outbuf_dma;                                          /* Output buffer dma */
 	unsigned long last_out;							/* record of last output for timeouts */
 
+	struct mutex mutex;						/* start/stop/open/close */
 	spinlock_t lock;						/* fifo spinlock */
 	unsigned long iofl;                                             /* I/O flags (CTRL_RUNNING, OUT_RUNNING) */
 	struct timer_list io_retry;                                     /* Retry timer */</pre><hr><pre>commit 598cc93005636e32a98ed003b0158329827c0ccb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Apr 25 16:35:40 2020 -0400

    PM: sleep: Helpful edits for devices.rst documentation
    
    Here are some minor edits of the devices.rst documentation file,
    intended to improve the clarity and add a couple of missing details.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;

diff --git a/Documentation/driver-api/pm/devices.rst b/Documentation/driver-api/pm/devices.rst
index 782cb37073a3..946ad0b94e31 100644
--- a/Documentation/driver-api/pm/devices.rst
+++ b/Documentation/driver-api/pm/devices.rst
@@ -349,7 +349,7 @@ the phases are: ``prepare``, ``suspend``, ``suspend_late``, ``suspend_noirq``.
 	PM core will skip the ``suspend``, ``suspend_late`` and
 	``suspend_noirq`` phases as well as all of the corresponding phases of
 	the subsequent device resume for all of these devices.	In that case,
-	the ``-&gt;complete`` callback will be invoked directly after the
+	the ``-&gt;complete`` callback will be the next one invoked after the
 	``-&gt;prepare`` callback and is entirely responsible for putting the
 	device into a consistent state as appropriate.
 
@@ -383,11 +383,15 @@ the phases are: ``prepare``, ``suspend``, ``suspend_late``, ``suspend_noirq``.
 	``-&gt;suspend`` methods provided by subsystems (bus types and PM domains
 	in particular) must follow an additional rule regarding what can be done
 	to the devices before their drivers' ``-&gt;suspend`` methods are called.
-	Namely, they can only resume the devices from runtime suspend by
-	calling :c:func:`pm_runtime_resume` for them, if that is necessary, and
+	Namely, they may resume the devices from runtime suspend by
+	calling :c:func:`pm_runtime_resume` for them, if that is necessary, but
 	they must not update the state of the devices in any other way at that
 	time (in case the drivers need to resume the devices from runtime
-	suspend in their ``-&gt;suspend`` methods).
+	suspend in their ``-&gt;suspend`` methods).  In fact, the PM core prevents
+	subsystems or drivers from putting devices into runtime suspend at
+	these times by calling :c:func:`pm_runtime_get_noresume` before issuing
+	the ``-&gt;prepare`` callback (and calling :c:func:`pm_runtime_put` after
+	issuing the ``-&gt;complete`` callback).
 
     3.	For a number of devices it is convenient to split suspend into the
 	"quiesce device" and "save device state" phases, in which cases
@@ -459,22 +463,22 @@ When resuming from freeze, standby or memory sleep, the phases are:
 
 	Note, however, that new children may be registered below the device as
 	soon as the ``-&gt;resume`` callbacks occur; it's not necessary to wait
-	until the ``complete`` phase with that.
+	until the ``complete`` phase runs.
 
 	Moreover, if the preceding ``-&gt;prepare`` callback returned a positive
 	number, the device may have been left in runtime suspend throughout the
-	whole system suspend and resume (the ``suspend``, ``suspend_late``,
-	``suspend_noirq`` phases of system suspend and the ``resume_noirq``,
-	``resume_early``, ``resume`` phases of system resume may have been
-	skipped for it).  In that case, the ``-&gt;complete`` callback is entirely
+	whole system suspend and resume (its ``-&gt;suspend``, ``-&gt;suspend_late``,
+	``-&gt;suspend_noirq``, ``-&gt;resume_noirq``,
+	``-&gt;resume_early``, and ``-&gt;resume`` callbacks may have been
+	skipped).  In that case, the ``-&gt;complete`` callback is entirely
 	responsible for putting the device into a consistent state after system
 	suspend if necessary.  [For example, it may need to queue up a runtime
 	resume request for the device for this purpose.]  To check if that is
 	the case, the ``-&gt;complete`` callback can consult the device's
-	``power.direct_complete`` flag.  Namely, if that flag is set when the
-	``-&gt;complete`` callback is being run, it has been called directly after
-	the preceding ``-&gt;prepare`` and special actions may be required
-	to make the device work correctly afterward.
+	``power.direct_complete`` flag.  If that flag is set when the
+	``-&gt;complete`` callback is being run then the direct-complete mechanism
+	was used, and special actions may be required to make the device work
+	correctly afterward.
 
 At the end of these phases, drivers should be as functional as they were before
 suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
@@ -575,10 +579,12 @@ and the phases are similar.
 
 The ``-&gt;poweroff``, ``-&gt;poweroff_late`` and ``-&gt;poweroff_noirq`` callbacks
 should do essentially the same things as the ``-&gt;suspend``, ``-&gt;suspend_late``
-and ``-&gt;suspend_noirq`` callbacks, respectively.  The only notable difference is
+and ``-&gt;suspend_noirq`` callbacks, respectively.  A notable difference is
 that they need not store the device register values, because the registers
 should already have been stored during the ``freeze``, ``freeze_late`` or
-``freeze_noirq`` phases.
+``freeze_noirq`` phases.  Also, on many machines the firmware will power-down
+the entire system, so it is not necessary for the callback to put the device in
+a low-power state.
 
 
 Leaving Hibernation
@@ -764,11 +770,10 @@ device driver in question.
 
 If it is necessary to resume a device from runtime suspend during a system-wide
 transition into a sleep state, that can be done by calling
-:c:func:`pm_runtime_resume` for it from the ``-&gt;suspend`` callback (or its
-couterpart for transitions related to hibernation) of either the device's driver
-or a subsystem responsible for it (for example, a bus type or a PM domain).
-That is guaranteed to work by the requirement that subsystems must not change
-the state of devices (possibly except for resuming them from runtime suspend)
+:c:func:`pm_runtime_resume` from the ``-&gt;suspend`` callback (or the ``-&gt;freeze``
+or ``-&gt;poweroff`` callback for transitions related to hibernation) of either the
+device's driver or its subsystem (for example, a bus type or a PM domain).
+However, subsystems must not otherwise change the runtime status of devices
 from their ``-&gt;prepare`` and ``-&gt;suspend`` callbacks (or equivalent) *before*
 invoking device drivers' ``-&gt;suspend`` callbacks (or equivalent).
 
@@ -779,27 +784,29 @@ The ``DPM_FLAG_SMART_SUSPEND`` Driver Flag
 
 Some bus types and PM domains have a policy to resume all devices from runtime
 suspend upfront in their ``-&gt;suspend`` callbacks, but that may not be really
-necessary if the driver of the device can cope with runtime-suspended devices.
-The driver can indicate that by setting ``DPM_FLAG_SMART_SUSPEND`` in
-:c:member:`power.driver_flags` at the probe time with the help of the
+necessary if the device's driver can cope with runtime-suspended devices.
+The driver can indicate this by setting ``DPM_FLAG_SMART_SUSPEND`` in
+:c:member:`power.driver_flags` at probe time, with the assistance of the
 :c:func:`dev_pm_set_driver_flags` helper routine.
 
-However, setting that flag also causes the PM core and middle-layer code
+Setting that flag causes the PM core and middle-layer code
 (bus types, PM domains etc.) to skip the ``-&gt;suspend_late`` and
 ``-&gt;suspend_noirq`` callbacks provided by the driver if the device remains in
-runtime suspend during the ``suspend_late`` phase of system-wide suspend (or
-during the ``poweroff_late`` or ``freeze_late`` phase of hibernation),
-after runtime PM was disabled for it.  [Without doing that, the same driver
+runtime suspend throughout those phases of the system-wide suspend (and
+similarly for the "freeze" and "poweroff" parts of system hibernation).
+[Otherwise the same driver
 callback might be executed twice in a row for the same device, which would not
 be valid in general.]  If the middle-layer system-wide PM callbacks are present
-for the device, they are responsible for doing the above, and the PM core takes
-care of it otherwise.
+for the device then they are responsible for skipping these driver callbacks;
+if not then the PM core skips them.  The subsystem callback routines can
+determine whether they need to skip the driver callbacks by testing the return
+value from the :c:func:`dev_pm_skip_suspend` helper function.
 
-In addition, with ``DPM_FLAG_SMART_SUSPEND`` set, the driver's ``-&gt;thaw_late``
-and ``-&gt;thaw_noirq`` callbacks are skipped if the device remained in runtime
-suspend during the preceding "freeze" transition related to hibernation.
-Again, if the middle-layer callbacks are present for the device, they are
-responsible for doing that, or the PM core takes care of it otherwise.
+In addition, with ``DPM_FLAG_SMART_SUSPEND`` set, the driver's ``-&gt;thaw_noirq``
+and ``-&gt;thaw_early`` callbacks are skipped in hibernation if the device remained
+in runtime suspend throughout the preceding "freeze" transition.  Again, if the
+middle-layer callbacks are present for the device, they are responsible for
+doing this, otherwise the PM core takes care of it.
 
 
 The ``DPM_FLAG_MAY_SKIP_RESUME`` Driver Flag
@@ -820,17 +827,20 @@ indicate to the PM core and middle-layer code that they allow their "noirq" and
 after system-wide PM transitions to the working state.  Whether or not that is
 the case generally depends on the state of the device before the given system
 suspend-resume cycle and on the type of the system transition under way.
-In particular, the "restore" and "thaw" transitions related to hibernation are
-not affected by ``DPM_FLAG_MAY_SKIP_RESUME`` at all.  [All devices are always
-resumed during the "restore" transition and whether or not any driver callbacks
-are skipped during the "freeze" transition depends whether or not the
-``DPM_FLAG_SMART_SUSPEND`` flag is set (see `above &lt;smart_suspend_flag_&gt;`_).]
+In particular, the "thaw" and "restore" transitions related to hibernation are
+not affected by ``DPM_FLAG_MAY_SKIP_RESUME`` at all.  [All callbacks are
+issued during the "restore" transition regardless of the flag settings,
+and whether or not any driver callbacks
+are skipped during the "thaw" transition depends whether or not the
+``DPM_FLAG_SMART_SUSPEND`` flag is set (see `above &lt;smart_suspend_flag_&gt;`_).
+In addition, a device is not allowed to remain in runtime suspend if any of its
+children will be returned to full power.]
 
 The ``DPM_FLAG_MAY_SKIP_RESUME`` flag is taken into account in combination with
 the :c:member:`power.may_skip_resume` status bit set by the PM core during the
 "suspend" phase of suspend-type transitions.  If the driver or the middle layer
 has a reason to prevent the driver's "noirq" and "early" resume callbacks from
-being skipped during the subsequent resume transition of the system, it should
+being skipped during the subsequent system resume transition, it should
 clear :c:member:`power.may_skip_resume` in its ``-&gt;suspend``, ``-&gt;suspend_late``
 or ``-&gt;suspend_noirq`` callback.  [Note that the drivers setting
 ``DPM_FLAG_SMART_SUSPEND`` need to clear :c:member:`power.may_skip_resume` in
@@ -845,8 +855,8 @@ not they should be skipped can be determined by evaluating the
 If that function returns ``true``, the driver's "noirq" and "early" resume
 callbacks should be skipped and the device's runtime PM status will be set to
 "suspended" by the PM core.  Otherwise, if the device was runtime-suspended
-during the preceding system-wide suspend transition and
-``DPM_FLAG_SMART_SUSPEND`` is set for it, its runtime PM status will be set to
+during the preceding system-wide suspend transition and its
+``DPM_FLAG_SMART_SUSPEND`` is set, its runtime PM status will be set to
 "active" by the PM core.  [Hence, the drivers that do not set
 ``DPM_FLAG_SMART_SUSPEND`` should not expect the runtime PM status of their
 devices to be changed from "suspended" to "active" by the PM core during</pre><hr><pre>commit a6cd27e9b594ccf4bf525969c1077f2dbe515476
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:20:19 2020 -0400

    USB: core: Replace an empty statement with a debug message
    
    This patch adds a dev_dbg() message to usb_create_sysfs_intf_files().
    The message is not expected ever to appear; it's real purpose is to
    satisfy the __must_check attribute on device_create_file() without
    triggering a compiler warning about an empty statement.
    
    In fact we don't really care if the sysfs attribute file doesn't get
    created.  The interface string descriptor is purely informational and
    hardly ever present.
    
    Suggested-by: NeilBrown &lt;neilb@suse.de&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221618500.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 9f4320b9d7fc..a2ca38e25e0c 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -1262,8 +1262,10 @@ void usb_create_sysfs_intf_files(struct usb_interface *intf)
 
 	if (!alt-&gt;string &amp;&amp; !(udev-&gt;quirks &amp; USB_QUIRK_CONFIG_INTF_STRINGS))
 		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
-	if (alt-&gt;string &amp;&amp; device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface))
-		;	/* We don't actually care if the function fails. */
+	if (alt-&gt;string &amp;&amp; device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface)) {
+		/* This is not a serious error */
+		dev_dbg(&amp;intf-&gt;dev, "interface string descriptor file not created\n");
+	}
 	intf-&gt;sysfs_files_created = 1;
 }
 </pre><hr><pre>commit 94f9c8c3c404ee1f7aaff81ad4f24aec4e34a78b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:14:57 2020 -0400

    usb-storage: Add unusual_devs entry for JMicron JMS566
    
    Cyril Roelandt reports that his JMicron JMS566 USB-SATA bridge fails
    to handle WRITE commands with the FUA bit set, even though it claims
    to support FUA.  (Oddly enough, a later version of the same bridge,
    version 2.03 as opposed to 1.14, doesn't claim to support FUA.  Also
    oddly, the bridge _does_ support FUA when using the UAS transport
    instead of the Bulk-Only transport -- but this device was blacklisted
    for uas in commit bc3bdb12bbb3 ("usb-storage: Disable UAS on JMicron
    SATA enclosure") for apparently unrelated reasons.)
    
    This patch adds a usb-storage unusual_devs entry with the BROKEN_FUA
    flag.  This allows the bridge to work properly with usb-storage.
    
    Reported-and-tested-by: Cyril Roelandt &lt;tipecaml@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221613110.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1880f3e13f57..f6c3681fa2e9 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -2323,6 +2323,13 @@ UNUSUAL_DEV(  0x3340, 0xffff, 0x0000, 0x0000,
 		USB_SC_DEVICE,USB_PR_DEVICE,NULL,
 		US_FL_MAX_SECTORS_64 ),
 
+/* Reported by Cyril Roelandt &lt;tipecaml@gmail.com&gt; */
+UNUSUAL_DEV(  0x357d, 0x7788, 0x0114, 0x0114,
+		"JMicron",
+		"USB to ATA/ATAPI Bridge",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_BROKEN_FUA ),
+
 /* Reported by Andrey Rahmatullin &lt;wrar@altlinux.org&gt; */
 UNUSUAL_DEV(  0x4102, 0x1020, 0x0100,  0x0100,
 		"iRiver",</pre><hr><pre>commit 3155f4f40811c5d7e3c686215051acf504e05565
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:13:08 2020 -0400

    USB: hub: Revert commit bd0e6c9614b9 ("usb: hub: try old enumeration scheme first for high speed devices")
    
    Commit bd0e6c9614b9 ("usb: hub: try old enumeration scheme first for
    high speed devices") changed the way the hub driver enumerates
    high-speed devices.  Instead of using the "new" enumeration scheme
    first and switching to the "old" scheme if that doesn't work, we start
    with the "old" scheme.  In theory this is better because the "old"
    scheme is slightly faster -- it involves resetting the device only
    once instead of twice.
    
    However, for a long time Windows used only the "new" scheme.  Zeng Tao
    said that Windows 8 and later use the "old" scheme for high-speed
    devices, but apparently there are some devices that don't like it.
    William Bader reports that the Ricoh webcam built into his Sony Vaio
    laptop not only doesn't enumerate under the "old" scheme, it gets hung
    up so badly that it won't then enumerate under the "new" scheme!  Only
    a cold reset will fix it.
    
    Therefore we will revert the commit and go back to trying the "new"
    scheme first for high-speed devices.
    
    Reported-and-tested-by: William Bader &lt;williambader@hotmail.com&gt;
    Ref: https://bugzilla.kernel.org/show_bug.cgi?id=207219
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: bd0e6c9614b9 ("usb: hub: try old enumeration scheme first for high speed devices")
    CC: Zeng Tao &lt;prime.zeng@hisilicon.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221611230.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index f2a93c8679e8..7bc83f3d9bdf 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -5187,8 +5187,7 @@
 
 	usbcore.old_scheme_first=
 			[USB] Start with the old device initialization
-			scheme,  applies only to low and full-speed devices
-			 (default 0 = off).
+			scheme (default 0 = off).
 
 	usbcore.usbfs_memory_mb=
 			[USB] Memory limit (in MB) for buffers allocated by
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 83549f009ced..2b6565c06c23 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2728,13 +2728,11 @@ static bool use_new_scheme(struct usb_device *udev, int retry,
 {
 	int old_scheme_first_port =
 		port_dev-&gt;quirks &amp; USB_PORT_QUIRK_OLD_SCHEME;
-	int quick_enumeration = (udev-&gt;speed == USB_SPEED_HIGH);
 
 	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)
 		return false;
 
-	return USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first
-			      || quick_enumeration);
+	return USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first);
 }
 
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?</pre><hr><pre>commit 9f952e26295d977dbfc6fedeaf8c4f112c818d37
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 16:09:51 2020 -0400

    USB: hub: Fix handling of connect changes during sleep
    
    Commit 8099f58f1ecd ("USB: hub: Don't record a connect-change event
    during reset-resume") wasn't very well conceived.  The problem it
    tried to fix was that if a connect-change event occurred while the
    system was asleep (such as a device disconnecting itself from the bus
    when it is suspended and then reconnecting when it resumes)
    requiring a reset-resume during the system wakeup transition, the hub
    port's change_bit entry would remain set afterward.  This would cause
    the hub driver to believe another connect-change event had occurred
    after the reset-resume, which was wrong and would lead the driver to
    send unnecessary requests to the device (which could interfere with a
    firmware update).
    
    The commit tried to fix this by not setting the change_bit during the
    wakeup.  But this was the wrong thing to do; it means that when a
    device is unplugged while the system is asleep, the hub driver doesn't
    realize anything has happened: The change_bit flag which would tell it
    to handle the disconnect event is clear.
    
    The commit needs to be reverted and the problem fixed in a different
    way.  Fortunately an alternative solution was noted in the commit's
    Changelog: We can continue to set the change_bit entry in
    hub_activate() but then clear it when a reset-resume occurs.  That way
    the the hub driver will see the change_bit when a device is
    disconnected but won't see it when the device is still present.
    
    That's what this patch does.
    
    Reported-and-tested-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: 8099f58f1ecd ("USB: hub: Don't record a connect-change event during reset-resume")
    Tested-by: Paul Zimmerman &lt;pauldzim@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2004221602480.11262-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 54cd8ef795ec..83549f009ced 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1223,6 +1223,11 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 #ifdef CONFIG_PM
 			udev-&gt;reset_resume = 1;
 #endif
+			/* Don't set the change_bits when the device
+			 * was powered off.
+			 */
+			if (test_bit(port1, hub-&gt;power_bits))
+				set_bit(port1, hub-&gt;change_bits);
 
 		} else {
 			/* The power session is gone; tell hub_wq */
@@ -3088,6 +3093,15 @@ static int check_port_resume_type(struct usb_device *udev,
 		if (portchange &amp; USB_PORT_STAT_C_ENABLE)
 			usb_clear_port_feature(hub-&gt;hdev, port1,
 					USB_PORT_FEAT_C_ENABLE);
+
+		/*
+		 * Whatever made this reset-resume necessary may have
+		 * turned on the port1 bit in hub-&gt;change_bits.  But after
+		 * a successful reset-resume we want the bit to be clear;
+		 * if it was on it would indicate that something happened
+		 * following the reset-resume.
+		 */
+		clear_bit(port1, hub-&gt;change_bits);
 	}
 
 	return status;</pre><hr><pre>commit 056ad39ee9253873522f6469c3364964a322912b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Mar 28 16:18:11 2020 -0400

    USB: core: Fix free-while-in-use bug in the USB S-Glibrary
    
    FuzzUSB (a variant of syzkaller) found a free-while-still-in-use bug
    in the USB scatter-gather library:
    
    BUG: KASAN: use-after-free in atomic_read
    include/asm-generic/atomic-instrumented.h:26 [inline]
    BUG: KASAN: use-after-free in usb_hcd_unlink_urb+0x5f/0x170
    drivers/usb/core/hcd.c:1607
    Read of size 4 at addr ffff888065379610 by task kworker/u4:1/27
    
    CPU: 1 PID: 27 Comm: kworker/u4:1 Not tainted 5.5.11 #2
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.10.2-1ubuntu1 04/01/2014
    Workqueue: scsi_tmf_2 scmd_eh_abort_handler
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0xce/0x128 lib/dump_stack.c:118
     print_address_description.constprop.4+0x21/0x3c0 mm/kasan/report.c:374
     __kasan_report+0x153/0x1cb mm/kasan/report.c:506
     kasan_report+0x12/0x20 mm/kasan/common.c:639
     check_memory_region_inline mm/kasan/generic.c:185 [inline]
     check_memory_region+0x152/0x1b0 mm/kasan/generic.c:192
     __kasan_check_read+0x11/0x20 mm/kasan/common.c:95
     atomic_read include/asm-generic/atomic-instrumented.h:26 [inline]
     usb_hcd_unlink_urb+0x5f/0x170 drivers/usb/core/hcd.c:1607
     usb_unlink_urb+0x72/0xb0 drivers/usb/core/urb.c:657
     usb_sg_cancel+0x14e/0x290 drivers/usb/core/message.c:602
     usb_stor_stop_transport+0x5e/0xa0 drivers/usb/storage/transport.c:937
    
    This bug occurs when cancellation of the S-G transfer races with
    transfer completion.  When that happens, usb_sg_cancel() may continue
    to access the transfer's URBs after usb_sg_wait() has freed them.
    
    The bug is caused by the fact that usb_sg_cancel() does not take any
    sort of reference to the transfer, and so there is nothing to prevent
    the URBs from being deallocated while the routine is trying to use
    them.  The fix is to take such a reference by incrementing the
    transfer's io-&gt;count field while the cancellation is in progres and
    decrementing it afterward.  The transfer's URBs are not deallocated
    until io-&gt;complete is triggered, which happens when io-&gt;count reaches
    zero.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Kyungtae Kim &lt;kt0755@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2003281615140.14837-100000@netrider.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index d5f834f16993..a48678a0c83a 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -589,12 +589,13 @@ void usb_sg_cancel(struct usb_sg_request *io)
 	int i, retval;
 
 	spin_lock_irqsave(&amp;io-&gt;lock, flags);
-	if (io-&gt;status) {
+	if (io-&gt;status || io-&gt;count == 0) {
 		spin_unlock_irqrestore(&amp;io-&gt;lock, flags);
 		return;
 	}
 	/* shut everything down */
 	io-&gt;status = -ECONNRESET;
+	io-&gt;count++;		/* Keep the request alive until we're done */
 	spin_unlock_irqrestore(&amp;io-&gt;lock, flags);
 
 	for (i = io-&gt;entries - 1; i &gt;= 0; --i) {
@@ -608,6 +609,12 @@ void usb_sg_cancel(struct usb_sg_request *io)
 			dev_warn(&amp;io-&gt;dev-&gt;dev, "%s, unlink --&gt; %d\n",
 				 __func__, retval);
 	}
+
+	spin_lock_irqsave(&amp;io-&gt;lock, flags);
+	io-&gt;count--;
+	if (!io-&gt;count)
+		complete(&amp;io-&gt;complete);
+	spin_unlock_irqrestore(&amp;io-&gt;lock, flags);
 }
 EXPORT_SYMBOL_GPL(usb_sg_cancel);
 </pre><hr><pre>commit 8099f58f1ecddf4f374f4828a3dff8397c7cbd74
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 31 10:39:26 2020 -0500

    USB: hub: Don't record a connect-change event during reset-resume
    
    Paul Zimmerman reports that his USB Bluetooth adapter sometimes
    crashes following system resume, when it receives a
    Get-Device-Descriptor request while it is busy doing something else.
    
    Such a request was added by commit a4f55d8b8c14 ("usb: hub: Check
    device descriptor before resusciation").  It gets sent when the hub
    driver's work thread checks whether a connect-change event on an
    enabled port really indicates a new device has been connected, as
    opposed to an old device momentarily disconnecting and then
    reconnecting (which can happen with xHCI host controllers, since they
    automatically enable connected ports).
    
    The same kind of thing occurs when a port's power session is lost
    during system suspend.  When the system wakes up it sees a
    connect-change event on the port, and if the child device's
    persist_enabled flag was set then hub_activate() sets the device's
    reset_resume flag as well as the port's bit in hub-&gt;change_bits.  The
    reset-resume code then takes responsibility for checking that the same
    device is still attached to the port, and it does this as part of the
    device's resume pathway.  By the time the hub driver's work thread
    starts up again, the device has already been fully reinitialized and
    is busy doing its own thing.  There's no need for the work thread to
    do the same check a second time, and in fact this unnecessary check is
    what caused the problem that Paul observed.
    
    Note that performing the unnecessary check is not actually a bug.
    Devices are supposed to be able to send descriptors back to the host
    even when they are busy doing something else.  The underlying cause of
    Paul's problem lies in his Bluetooth adapter.  Nevertheless, we
    shouldn't perform the same check twice in a row -- and as a nice side
    benefit, removing the extra check allows the Bluetooth adapter to work
    more reliably.
    
    The work thread performs its check when it sees that the port's bit is
    set in hub-&gt;change_bits.  In this situation that bit is interpreted as
    though a connect-change event had occurred on the port _after_ the
    reset-resume, which is not what actually happened.
    
    One possible fix would be to make the reset-resume code clear the
    port's bit in hub-&gt;change_bits.  But it seems simpler to just avoid
    setting the bit during hub_activate() in the first place.  That's what
    this patch does.
    
    (Proving that the patch is correct when CONFIG_PM is disabled requires
    a little thought.  In that setting hub_activate() will be called only
    for initialization and resets, since there won't be any resumes or
    reset-resumes.  During initialization and hub resets the hub doesn't
    have any child devices, and so this code path never gets executed.)
    
    Reported-and-tested-by: Paul Zimmerman &lt;pauldzim@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://marc.info/?t=157949360700001&amp;r=1&amp;w=2
    CC: David Heinzelmann &lt;heinzelmann.david@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.2001311037460.1577-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index de94fa4a4ca7..1d212f82c69b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1219,11 +1219,6 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 #ifdef CONFIG_PM
 			udev-&gt;reset_resume = 1;
 #endif
-			/* Don't set the change_bits when the device
-			 * was powered off.
-			 */
-			if (test_bit(port1, hub-&gt;power_bits))
-				set_bit(port1, hub-&gt;change_bits);
 
 		} else {
 			/* The power session is gone; tell hub_wq */</pre>
    <div class="pagination">
        <a href='2_9.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><span>[10]</span><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_11.html'>Next&gt;&gt;</a>
    <div>
</body>
