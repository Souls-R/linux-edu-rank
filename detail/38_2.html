<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Rutgers University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Rutgers University</h1>
    <div class="pagination">
        <a href='38.html'>&lt;&lt;Prev</a><a href='38.html'>1</a><span>[2]</span>
    </div>
    <hr>
    <pre>commit b446197cc14ef060baeed5acbcddf148c04d03f8
Author: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
Date:   Mon Feb 4 10:03:54 2008 -0500

    ath5k: Port debug.c over to the new band API and enable as build option
    
    This patch finishes the port and enables debug as an build option.
    This was tested on:
    
    Atheros AR5213A chip found (MAC: 0x59, PHY: 0x43)
    RF5112A multiband radio found (0x36)
    
    Note:
    
    For 2 GHz band on the above card I noticed we get negative channel
    numbers. Will look into this unless someone beats me to it.
    
    Example out put when loading using:
    
    sudo modprobe ath5k debug=0x00000400
    
     Band 2 GHz: channels 26, rates 12
      channels:
         1 2412 00c0 0000
         2 2417 00c0 0000
         3 2422 00c0 0000
         4 2427 00c0 0000
         5 2432 00c0 0000
         6 2437 00c0 0000
         7 2442 00c0 0000
         8 2447 00c0 0000
         9 2452 00c0 0000
        10 2457 00c0 0000
        11 2462 00c0 0000
        12 2467 00c0 0000
        13 2472 00c0 0000
        14 2484 00c0 0000
       -498 2512 00c0 0000
       -494 2532 00c0 0000
       -490 2552 00c0 0000
       -486 2572 00c0 0000
       -482 2592 00c0 0000
       -478 2612 00c0 0000
       -474 2632 00c0 0000
       -470 2652 00c0 0000
       -466 2672 00c0 0000
       -462 2692 00c0 0000
       -458 2712 00c0 0000
       -454 2732 00c0 0000
     Band 5 GHz: channels 194, rates 8
      channels:
        27 5135 0140 0000
        28 5140 0140 0000
    [... etc ]
       219 6095 0140 0000
       220 6100 0140 0000
      rates:
         60 000b 0000 0000
         90 000f 0000 0000
        120 000a 0000 0000
        180 000e 0000 0000
        240 0009 0000 0000
        360 000d 0000 0000
        480 0008 0000 0000
        540 000c 0000 0000
    
    Changes to base.c, base.h
    Changes-licensed-under: 3-Clause-BSD
    
    Changes to debug.c, debug.h
    Changes-licensed-under: GPL
    
    Signed-off-by: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/ath5k/Kconfig b/drivers/net/wireless/ath5k/Kconfig
index af1b6b8c991a..f1f2aea2eab4 100644
--- a/drivers/net/wireless/ath5k/Kconfig
+++ b/drivers/net/wireless/ath5k/Kconfig
@@ -14,3 +14,24 @@ config ATH5K
 
 	  If you choose to build a module, it'll be called ath5k. Say M if
 	  unsure.
+
+config ATH5K_DEBUG
+	bool "Atheros 5xxx debugging"
+	depends on ATH5K
+	---help---
+	  Atheros 5xxx debugging messages.
+
+	  Say Y, if and you will get debug options for ath5k.
+	  To use this, you need to mount debugfs:
+
+	  mkdir /debug/
+	  mount -t debugfs debug /debug/
+
+	  You will get access to files under:
+	  /debug/ath5k/phy0/
+
+	  To enable debug, pass the debug level to the debug module
+	  parameter. For example:
+
+	  modprobe ath5k debug=0x00000400
+
diff --git a/drivers/net/wireless/ath5k/Makefile b/drivers/net/wireless/ath5k/Makefile
index 0f14b00f648e..564ecd0c5d4b 100644
--- a/drivers/net/wireless/ath5k/Makefile
+++ b/drivers/net/wireless/ath5k/Makefile
@@ -2,5 +2,5 @@ ath5k-y				+= base.o
 ath5k-y				+= hw.o
 ath5k-y				+= initvals.o
 ath5k-y				+= phy.o
-ath5k-y				+= debug.o
+ath5k-$(CONFIG_ATH5K_DEBUG)	+= debug.o
 obj-$(CONFIG_ATH5K)		+= ath5k.o
diff --git a/drivers/net/wireless/ath5k/base.c b/drivers/net/wireless/ath5k/base.c
index 44c0133e844f..5ca441d7a6c1 100644
--- a/drivers/net/wireless/ath5k/base.c
+++ b/drivers/net/wireless/ath5k/base.c
@@ -994,7 +994,7 @@ ath5k_getchannels(struct ieee80211_hw *hw)
 		hw-&gt;wiphy-&gt;bands[IEEE80211_BAND_5GHZ] = sband;
 	}
 
-/* FIXME:	ath5k_debug_dump_modes(sc, modes); */
+	ath5k_debug_dump_bands(sc);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath5k/base.h b/drivers/net/wireless/ath5k/base.h
index bbe7a5438154..3a9755893018 100644
--- a/drivers/net/wireless/ath5k/base.h
+++ b/drivers/net/wireless/ath5k/base.h
@@ -108,9 +108,9 @@ struct ath5k_softc {
 	u8			g_rates;
 	u8			xr_rates;
 
-#if ATH5K_DEBUG
+#ifdef CONFIG_ATH5K_DEBUG
 	struct ath5k_dbg_info	debug;		/* debug info */
-#endif
+#endif /* CONFIG_ATH5K_DEBUG */
 
 	struct ath5k_buf	*bufptr;	/* allocated buffer ptr */
 	struct ath5k_desc	*desc;		/* TX/RX descriptors */
diff --git a/drivers/net/wireless/ath5k/debug.c b/drivers/net/wireless/ath5k/debug.c
index bb581ef6d1ef..05bf4fb8f907 100644
--- a/drivers/net/wireless/ath5k/debug.c
+++ b/drivers/net/wireless/ath5k/debug.c
@@ -65,7 +65,7 @@ static unsigned int ath5k_debug;
 module_param_named(debug, ath5k_debug, uint, 0);
 
 
-#if ATH5K_DEBUG
+#ifdef CONFIG_ATH5K_DEBUG
 
 #include &lt;linux/seq_file.h&gt;
 #include "reg.h"
@@ -340,7 +340,7 @@ static struct {
 	{ ATH5K_DEBUG_LED,	"led",		"LED mamagement" },
 	{ ATH5K_DEBUG_DUMP_RX,	"dumprx",	"print received skb content" },
 	{ ATH5K_DEBUG_DUMP_TX,	"dumptx",	"print transmit skb content" },
-	{ ATH5K_DEBUG_DUMPMODES, "dumpmodes",	"dump modes" },
+	{ ATH5K_DEBUG_DUMPBANDS, "dumpbands",	"dump bands" },
 	{ ATH5K_DEBUG_TRACE,	"trace",	"trace function calls" },
 	{ ATH5K_DEBUG_ANY,	"all",		"show all debug levels" },
 };
@@ -452,30 +452,47 @@ ath5k_debug_finish_device(struct ath5k_softc *sc)
 /* functions used in other places */
 
 void
-ath5k_debug_dump_modes(struct ath5k_softc *sc, struct ieee80211_hw_mode *modes)
+ath5k_debug_dump_bands(struct ath5k_softc *sc)
 {
-	unsigned int m, i;
+	unsigned int b, i;
 
-	if (likely(!(sc-&gt;debug.level &amp; ATH5K_DEBUG_DUMPMODES)))
+	if (likely(!(sc-&gt;debug.level &amp; ATH5K_DEBUG_DUMPBANDS)))
 		return;
 
-	for (m = 0; m &lt; NUM_DRIVER_MODES; m++) {
-		printk(KERN_DEBUG "Mode %u: channels %d, rates %d\n", m,
-				modes[m].num_channels, modes[m].num_rates);
+	BUG_ON(!sc-&gt;sbands);
+
+	for (b = 0; b &lt; IEEE80211_NUM_BANDS; b++) {
+		struct ieee80211_supported_band *band = &amp;sc-&gt;sbands[b];
+		char bname[5];
+		switch (band-&gt;band) {
+		case IEEE80211_BAND_2GHZ:
+			strcpy(bname, "2 GHz");
+			break;
+		case IEEE80211_BAND_5GHZ:
+			strcpy(bname, "5 GHz");
+			break;
+		default:
+			printk(KERN_DEBUG "Band not supported: %d\n",
+				band-&gt;band);
+			return;
+		}
+		printk(KERN_DEBUG "Band %s: channels %d, rates %d\n", bname,
+				band-&gt;n_channels, band-&gt;n_bitrates);
 		printk(KERN_DEBUG " channels:\n");
-		for (i = 0; i &lt; modes[m].num_channels; i++)
+		for (i = 0; i &lt; band-&gt;n_channels; i++)
 			printk(KERN_DEBUG "  %3d %d %.4x %.4x\n",
-					modes[m].channels[i].chan,
-					modes[m].channels[i].freq,
-					modes[m].channels[i].val,
-					modes[m].channels[i].flag);
+					ieee80211_frequency_to_channel(
+						band-&gt;channels[i].center_freq),
+					band-&gt;channels[i].center_freq,
+					band-&gt;channels[i].hw_value,
+					band-&gt;channels[i].flags);
 		printk(KERN_DEBUG " rates:\n");
-		for (i = 0; i &lt; modes[m].num_rates; i++)
+		for (i = 0; i &lt; band-&gt;n_bitrates; i++)
 			printk(KERN_DEBUG "  %4d %.4x %.4x %.4x\n",
-					modes[m].rates[i].rate,
-					modes[m].rates[i].val,
-					modes[m].rates[i].flags,
-					modes[m].rates[i].val2);
+					band-&gt;bitrates[i].bitrate,
+					band-&gt;bitrates[i].hw_value,
+					band-&gt;bitrates[i].flags,
+					band-&gt;bitrates[i].hw_value_short);
 	}
 }
 
@@ -548,4 +565,4 @@ ath5k_debug_printtxbuf(struct ath5k_softc *sc,
 		!done ? ' ' : (ds-&gt;ds_txstat.ts_status == 0) ? '*' : '!');
 }
 
-#endif /* if ATH5K_DEBUG */
+#endif /* ifdef CONFIG_ATH5K_DEBUG */
diff --git a/drivers/net/wireless/ath5k/debug.h b/drivers/net/wireless/ath5k/debug.h
index c4fd8c43df0c..16fbb6fbab35 100644
--- a/drivers/net/wireless/ath5k/debug.h
+++ b/drivers/net/wireless/ath5k/debug.h
@@ -61,11 +61,6 @@
 #ifndef _ATH5K_DEBUG_H
 #define _ATH5K_DEBUG_H
 
-/* set this to 1 for debugging output */
-#ifndef ATH5K_DEBUG
-#define ATH5K_DEBUG	0
-#endif
-
 struct ath5k_softc;
 struct ath5k_hw;
 struct ieee80211_hw_mode;
@@ -96,7 +91,7 @@ struct ath5k_dbg_info {
  * @ATH5K_DEBUG_LED: led management
  * @ATH5K_DEBUG_DUMP_RX: print received skb content
  * @ATH5K_DEBUG_DUMP_TX: print transmit skb content
- * @ATH5K_DEBUG_DUMPMODES: dump modes
+ * @ATH5K_DEBUG_DUMPBANDS: dump bands
  * @ATH5K_DEBUG_TRACE: trace function calls
  * @ATH5K_DEBUG_ANY: show at any debug level
  *
@@ -118,12 +113,12 @@ enum ath5k_debug_level {
 	ATH5K_DEBUG_LED		= 0x00000080,
 	ATH5K_DEBUG_DUMP_RX	= 0x00000100,
 	ATH5K_DEBUG_DUMP_TX	= 0x00000200,
-	ATH5K_DEBUG_DUMPMODES	= 0x00000400,
+	ATH5K_DEBUG_DUMPBANDS	= 0x00000400,
 	ATH5K_DEBUG_TRACE	= 0x00001000,
 	ATH5K_DEBUG_ANY		= 0xffffffff
 };
 
-#if ATH5K_DEBUG
+#ifdef CONFIG_ATH5K_DEBUG
 
 #define ATH5K_TRACE(_sc) do { \
 	if (unlikely((_sc)-&gt;debug.level &amp; ATH5K_DEBUG_TRACE)) \
@@ -158,8 +153,7 @@ void
 ath5k_debug_printrxbuffs(struct ath5k_softc *sc, struct ath5k_hw *ah);
 
 void
-ath5k_debug_dump_modes(struct ath5k_softc *sc,
-			struct ieee80211_hw_mode *modes);
+ath5k_debug_dump_bands(struct ath5k_softc *sc);
 
 void
 ath5k_debug_dump_skb(struct ath5k_softc *sc,
@@ -196,8 +190,7 @@ static inline void
 ath5k_debug_printrxbuffs(struct ath5k_softc *sc, struct ath5k_hw *ah) {}
 
 static inline void
-ath5k_debug_dump_modes(struct ath5k_softc *sc,
-			struct ieee80211_hw_mode *modes) {}
+ath5k_debug_dump_bands(struct ath5k_softc *sc) {}
 
 static inline void
 ath5k_debug_dump_skb(struct ath5k_softc *sc,
@@ -207,6 +200,6 @@ static inline void
 ath5k_debug_printtxbuf(struct ath5k_softc *sc,
 			struct ath5k_buf *bf, int done) {}
 
-#endif /* if ATH5K_DEBUG */
+#endif /* ifdef CONFIG_ATH5K_DEBUG */
 
 #endif /* ifndef _ATH5K_DEBUG_H */</pre><hr><pre>commit e9ddc0f25ce524d257e6cf779e495f567ed7678f
Author: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
Date:   Mon Feb 4 09:56:32 2008 -0500

    ath5k: Use our own Kconfig file, we'll be expanding this shortly
    
    Apologoes, this is a re-post of patch-04, forgot to git-add
    our Kconfig... New series (only 2 patches needed fixing, which
    I am reposting) can be found here:
    
    http://kernel.org/pub/linux/kernel/people/mcgrof/patches/ath5k/2008-02-04.v2/
    
    Use our own Kconfig file, we'll be expanding this shortly.
    
    Signed-off-by: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 714a6ca30ad2..cfedbda81e3f 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -732,23 +732,7 @@ config P54_PCI
 
 	  If you choose to build a module, it'll be called p54pci.
 
-config ATH5K
-	tristate "Atheros 5xxx wireless cards support"
-	depends on PCI &amp;&amp; MAC80211 &amp;&amp; WLAN_80211 &amp;&amp; EXPERIMENTAL
-	---help---
-	  This module adds support for wireless adapters based on
-	  Atheros 5xxx chipset.
-
-	  Currently the following chip versions are supported:
-
-	  MAC: AR5211 AR5212
-	  PHY: RF5111/2111 RF5112/2112 RF5413/2413
-
-	  This driver uses the kernel's mac80211 subsystem.
-
-	  If you choose to build a module, it'll be called ath5k. Say M if
-	  unsure.
-
+source "drivers/net/wireless/ath5k/Kconfig"
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/hostap/Kconfig"
 source "drivers/net/wireless/bcm43xx/Kconfig"
diff --git a/drivers/net/wireless/ath5k/Kconfig b/drivers/net/wireless/ath5k/Kconfig
new file mode 100644
index 000000000000..af1b6b8c991a
--- /dev/null
+++ b/drivers/net/wireless/ath5k/Kconfig
@@ -0,0 +1,16 @@
+config ATH5K
+	tristate "Atheros 5xxx wireless cards support"
+	depends on PCI &amp;&amp; MAC80211 &amp;&amp; WLAN_80211 &amp;&amp; EXPERIMENTAL
+	---help---
+	  This module adds support for wireless adapters based on
+	  Atheros 5xxx chipset.
+
+	  Currently the following chip versions are supported:
+
+	  MAC: AR5211 AR5212
+	  PHY: RF5111/2111 RF5112/2112 RF5413/2413
+
+	  This driver uses the kernel's mac80211 subsystem.
+
+	  If you choose to build a module, it'll be called ath5k. Say M if
+	  unsure.
diff --git a/drivers/net/wireless/ath5k/Makefile b/drivers/net/wireless/ath5k/Makefile
index ada1095d4ef1..0f14b00f648e 100644
--- a/drivers/net/wireless/ath5k/Makefile
+++ b/drivers/net/wireless/ath5k/Makefile
@@ -1,2 +1,6 @@
-ath5k-objs		= base.o hw.o initvals.o phy.o debug.o
-obj-$(CONFIG_ATH5K)	+= ath5k.o
+ath5k-y				+= base.o
+ath5k-y				+= hw.o
+ath5k-y				+= initvals.o
+ath5k-y				+= phy.o
+ath5k-y				+= debug.o
+obj-$(CONFIG_ATH5K)		+= ath5k.o</pre><hr><pre>commit a3f4b914a03a11f3ccc98243b20a647bb8f31691
Author: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
Date:   Sun Feb 3 21:52:10 2008 -0500

    ath5k: ath5k_copy_channels() was not setting the channel band
    
    ath5k_copy_channels() wasn't setting the channel's band so all
    driver channels had a 2GHz band set. Lets set this.
    
    Changes-licensed-under: 3-Clause-BSD
    
    Signed-off-by: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/ath5k/base.c b/drivers/net/wireless/ath5k/base.c
index e3efd869922f..44c0133e844f 100644
--- a/drivers/net/wireless/ath5k/base.c
+++ b/drivers/net/wireless/ath5k/base.c
@@ -902,6 +902,8 @@ ath5k_copy_channels(struct ath5k_hw *ah,
 
 		/* Write channel info and increment counter */
 		channels[count].center_freq = freq;
+		channels[count].band = (chfreq == CHANNEL_2GHZ) ?
+			IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ;
 		switch (mode) {
 		case AR5K_MODE_11A:
 		case AR5K_MODE_11G:</pre><hr><pre>commit 400ec45a02b2a9ef75c26c490ba80801d19b7e7b
Author: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
Date:   Sun Feb 3 21:51:49 2008 -0500

    ath5k: Cleanup after API changes
    
    Cleanup after API changes patch (checkpatch.pl stuff) and on
    ath5k_hw_channel() make use of the existing ath5k_channel_ok()
    instead of re-implementing the checks again. This was necessary
    to make the code cleaner and fit the 80-chars wide limit so
    sending it within the same patch.
    
    Finally make a note that we *may* eventually move cap_range stuff
    to struct wiphy (band frequency range capabilities). This
    information can later be exported to userspace, for example,
    and giving it access to mac80211 and drivers in general can come
    in handy.
    
    Changes to initvals.c, phy.c
    Changes-licensed-under: ISC
    
    Changes to ath5k.h, base.c
    Changes-licensed-under: 3-Clause-BSD
    
    Signed-off-by: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/ath5k/ath5k.h b/drivers/net/wireless/ath5k/ath5k.h
index 9ea8c549b781..18223d9833f1 100644
--- a/drivers/net/wireless/ath5k/ath5k.h
+++ b/drivers/net/wireless/ath5k/ath5k.h
@@ -263,8 +263,10 @@ enum ath5k_driver_mode {
 /* adding this flag to rate_code enables short preamble, see ar5212_reg.h */
 #define AR5K_SET_SHORT_PREAMBLE 0x04
 
-#define HAS_SHPREAMBLE(_ix) (rt-&gt;rates[_ix].modulation == IEEE80211_RATE_SHORT_PREAMBLE)
-#define SHPREAMBLE_FLAG(_ix) (HAS_SHPREAMBLE(_ix) ? AR5K_SET_SHORT_PREAMBLE : 0)
+#define HAS_SHPREAMBLE(_ix) \
+	(rt-&gt;rates[_ix].modulation == IEEE80211_RATE_SHORT_PREAMBLE)
+#define SHPREAMBLE_FLAG(_ix) \
+	(HAS_SHPREAMBLE(_ix) ? AR5K_SET_SHORT_PREAMBLE : 0)
 
 /****************\
   TX DEFINITIONS
@@ -892,6 +894,8 @@ enum ath5k_capability_type {
 	AR5K_CAP_RFSILENT		= 20,	/* Supports RFsilent */
 };
 
+
+/* XXX: we *may* move cap_range stuff to struct wiphy */
 struct ath5k_capabilities {
 	/*
 	 * Supported PHY modes
diff --git a/drivers/net/wireless/ath5k/base.c b/drivers/net/wireless/ath5k/base.c
index 52e55f67b735..e3efd869922f 100644
--- a/drivers/net/wireless/ath5k/base.c
+++ b/drivers/net/wireless/ath5k/base.c
@@ -80,7 +80,7 @@ MODULE_AUTHOR("Nick Kossifidis");
 MODULE_DESCRIPTION("Support for 5xxx series of Atheros 802.11 wireless LAN cards.");
 MODULE_SUPPORTED_DEVICE("Atheros 5xxx WLAN cards");
 MODULE_LICENSE("Dual BSD/GPL");
-MODULE_VERSION("0.1.1 (EXPERIMENTAL)");
+MODULE_VERSION("0.5.0 (EXPERIMENTAL)");
 
 
 /* Known PCI ids */
@@ -513,35 +513,46 @@ ath5k_pci_probe(struct pci_dev *pdev,
 					sc-&gt;ah-&gt;ah_mac_srev,
 					sc-&gt;ah-&gt;ah_phy_revision);
 
-	if(!sc-&gt;ah-&gt;ah_single_chip){
+	if (!sc-&gt;ah-&gt;ah_single_chip) {
 		/* Single chip radio (!RF5111) */
-		if(sc-&gt;ah-&gt;ah_radio_5ghz_revision &amp;&amp; !sc-&gt;ah-&gt;ah_radio_2ghz_revision) {
+		if (sc-&gt;ah-&gt;ah_radio_5ghz_revision &amp;&amp;
+			!sc-&gt;ah-&gt;ah_radio_2ghz_revision) {
 			/* No 5GHz support -&gt; report 2GHz radio */
-			if(!test_bit(AR5K_MODE_11A, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+			if (!test_bit(AR5K_MODE_11A,
+				sc-&gt;ah-&gt;ah_capabilities.cap_mode)) {
 				ATH5K_INFO(sc, "RF%s 2GHz radio found (0x%x)\n",
-					ath5k_chip_name(AR5K_VERSION_RAD,sc-&gt;ah-&gt;ah_radio_5ghz_revision),
-							sc-&gt;ah-&gt;ah_radio_5ghz_revision);
-			/* No 2GHz support (5110 and some 5Ghz only cards) -&gt; report 5Ghz radio */
-			} else if(!test_bit(AR5K_MODE_11B, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+					ath5k_chip_name(AR5K_VERSION_RAD,
+						sc-&gt;ah-&gt;ah_radio_5ghz_revision),
+						sc-&gt;ah-&gt;ah_radio_5ghz_revision);
+			/* No 2GHz support (5110 and some
+			 * 5Ghz only cards) -&gt; report 5Ghz radio */
+			} else if (!test_bit(AR5K_MODE_11B,
+				sc-&gt;ah-&gt;ah_capabilities.cap_mode)) {
 				ATH5K_INFO(sc, "RF%s 5GHz radio found (0x%x)\n",
-					ath5k_chip_name(AR5K_VERSION_RAD,sc-&gt;ah-&gt;ah_radio_5ghz_revision),
-							sc-&gt;ah-&gt;ah_radio_5ghz_revision);
+					ath5k_chip_name(AR5K_VERSION_RAD,
+						sc-&gt;ah-&gt;ah_radio_5ghz_revision),
+						sc-&gt;ah-&gt;ah_radio_5ghz_revision);
 			/* Multiband radio */
 			} else {
 				ATH5K_INFO(sc, "RF%s multiband radio found"
 					" (0x%x)\n",
-					ath5k_chip_name(AR5K_VERSION_RAD,sc-&gt;ah-&gt;ah_radio_5ghz_revision),
-							sc-&gt;ah-&gt;ah_radio_5ghz_revision);
+					ath5k_chip_name(AR5K_VERSION_RAD,
+						sc-&gt;ah-&gt;ah_radio_5ghz_revision),
+						sc-&gt;ah-&gt;ah_radio_5ghz_revision);
 			}
 		}
-		/* Multi chip radio (RF5111 - RF2111) -&gt; report both 2GHz/5GHz radios */
-		else if(sc-&gt;ah-&gt;ah_radio_5ghz_revision &amp;&amp; sc-&gt;ah-&gt;ah_radio_2ghz_revision){
+		/* Multi chip radio (RF5111 - RF2111) -&gt;
+		 * report both 2GHz/5GHz radios */
+		else if (sc-&gt;ah-&gt;ah_radio_5ghz_revision &amp;&amp;
+				sc-&gt;ah-&gt;ah_radio_2ghz_revision){
 			ATH5K_INFO(sc, "RF%s 5GHz radio found (0x%x)\n",
-				ath5k_chip_name(AR5K_VERSION_RAD,sc-&gt;ah-&gt;ah_radio_5ghz_revision),
-						sc-&gt;ah-&gt;ah_radio_5ghz_revision);
+				ath5k_chip_name(AR5K_VERSION_RAD,
+					sc-&gt;ah-&gt;ah_radio_5ghz_revision),
+					sc-&gt;ah-&gt;ah_radio_5ghz_revision);
 			ATH5K_INFO(sc, "RF%s 2GHz radio found (0x%x)\n",
-				ath5k_chip_name(AR5K_VERSION_RAD,sc-&gt;ah-&gt;ah_radio_2ghz_revision),
-						sc-&gt;ah-&gt;ah_radio_2ghz_revision);
+				ath5k_chip_name(AR5K_VERSION_RAD,
+					sc-&gt;ah-&gt;ah_radio_2ghz_revision),
+					sc-&gt;ah-&gt;ah_radio_2ghz_revision);
 		}
 	}
 
@@ -891,14 +902,17 @@ ath5k_copy_channels(struct ath5k_hw *ah,
 
 		/* Write channel info and increment counter */
 		channels[count].center_freq = freq;
-
-		if((mode == AR5K_MODE_11A) ||
-		(mode == AR5K_MODE_11G)){
-			channels[count].hw_value = chfreq|CHANNEL_OFDM;
-		} else if((mode == AR5K_MODE_11A_TURBO) ||
-		(mode == AR5K_MODE_11G_TURBO)){
-			channels[count].hw_value = chfreq|CHANNEL_OFDM|CHANNEL_TURBO;
-		}if(mode == AR5K_MODE_11B) {
+		switch (mode) {
+		case AR5K_MODE_11A:
+		case AR5K_MODE_11G:
+			channels[count].hw_value = chfreq | CHANNEL_OFDM;
+			break;
+		case AR5K_MODE_11A_TURBO:
+		case AR5K_MODE_11G_TURBO:
+			channels[count].hw_value = chfreq |
+				CHANNEL_OFDM | CHANNEL_TURBO;
+			break;
+		case AR5K_MODE_11B:
 			channels[count].hw_value = CHANNEL_B;
 		}
 
@@ -926,15 +940,16 @@ ath5k_getchannels(struct ieee80211_hw *hw)
 	count_r = count_c = 0;
 
 	/* 2GHz band */
-	if(!test_bit(AR5K_MODE_11G, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+	if (!test_bit(AR5K_MODE_11G, sc-&gt;ah-&gt;ah_capabilities.cap_mode)) {
 		mode2g = AR5K_MODE_11B;
-		if(!test_bit(AR5K_MODE_11B, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+		if (!test_bit(AR5K_MODE_11B,
+			sc-&gt;ah-&gt;ah_capabilities.cap_mode))
 			mode2g = -1;
-		}
 	}
 
-	if(mode2g &gt; 0){
-		struct ieee80211_supported_band *sband = &amp;sbands[IEEE80211_BAND_2GHZ];
+	if (mode2g &gt; 0) {
+		struct ieee80211_supported_band *sband =
+			&amp;sbands[IEEE80211_BAND_2GHZ];
 
 		sband-&gt;bitrates = sc-&gt;rates;
 		sband-&gt;channels = sc-&gt;channels;
@@ -945,7 +960,7 @@ ath5k_getchannels(struct ieee80211_hw *hw)
 
 		hw_rates = ath5k_hw_get_rate_table(ah, mode2g);
 		sband-&gt;n_bitrates = ath5k_copy_rates(sband-&gt;bitrates,
-					hw_rates,max_r);
+					hw_rates, max_r);
 
 		count_c = sband-&gt;n_channels;
 		count_r = sband-&gt;n_bitrates;
@@ -959,8 +974,9 @@ ath5k_getchannels(struct ieee80211_hw *hw)
 
 	/* 5GHz band */
 
-	if(test_bit(AR5K_MODE_11A, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
-		struct ieee80211_supported_band *sband = &amp;sbands[IEEE80211_BAND_5GHZ];
+	if (test_bit(AR5K_MODE_11A, sc-&gt;ah-&gt;ah_capabilities.cap_mode)) {
+		struct ieee80211_supported_band *sband =
+			&amp;sbands[IEEE80211_BAND_5GHZ];
 
 		sband-&gt;bitrates = &amp;sc-&gt;rates[count_r];
 		sband-&gt;channels = &amp;sc-&gt;channels[count_c];
@@ -971,7 +987,7 @@ ath5k_getchannels(struct ieee80211_hw *hw)
 
 		hw_rates = ath5k_hw_get_rate_table(ah, AR5K_MODE_11A);
 		sband-&gt;n_bitrates = ath5k_copy_rates(sband-&gt;bitrates,
-					hw_rates,max_r);
+					hw_rates, max_r);
 
 		hw-&gt;wiphy-&gt;bands[IEEE80211_BAND_5GHZ] = sband;
 	}
@@ -1109,7 +1125,7 @@ ath5k_setcurmode(struct ath5k_softc *sc, unsigned int mode)
 
 	sc-&gt;curmode = mode;
 
-	if(mode == AR5K_MODE_11A){
+	if (mode == AR5K_MODE_11A) {
 		sc-&gt;curband = &amp;sc-&gt;sbands[IEEE80211_BAND_5GHZ];
 	} else {
 		sc-&gt;curband = &amp;sc-&gt;sbands[IEEE80211_BAND_2GHZ];
@@ -1161,43 +1177,43 @@ ath5k_mode_setup(struct ath5k_softc *sc)
  * When hw returns eg. 27 it points to the last 802.11g rate (54Mbits) etc
  */
 static void
-ath5k_set_total_hw_rates(struct ath5k_softc *sc){
+ath5k_set_total_hw_rates(struct ath5k_softc *sc) {
 
 	struct ath5k_hw *ah = sc-&gt;ah;
 
-	if(test_bit(AR5K_MODE_11A, ah-&gt;ah_modes))
+	if (test_bit(AR5K_MODE_11A, ah-&gt;ah_modes))
 		sc-&gt;a_rates = 8;
 
-	if(test_bit(AR5K_MODE_11B, ah-&gt;ah_modes))
+	if (test_bit(AR5K_MODE_11B, ah-&gt;ah_modes))
 		sc-&gt;b_rates = 4;
 
-	if(test_bit(AR5K_MODE_11G, ah-&gt;ah_modes))
+	if (test_bit(AR5K_MODE_11G, ah-&gt;ah_modes))
 		sc-&gt;g_rates = 12;
 
 	/* XXX: Need to see what what happens when
 		xr disable bits in eeprom are set */
-	if(ah-&gt;ah_version &gt;= AR5K_AR5212)
+	if (ah-&gt;ah_version &gt;= AR5K_AR5212)
 		sc-&gt;xr_rates = 4;
 
 }
 
 static inline int
-ath5k_hw_to_driver_rix(struct ath5k_softc *sc, int hw_rix){
+ath5k_hw_to_driver_rix(struct ath5k_softc *sc, int hw_rix) {
 
 	int mac80211_rix;
 
-	if(sc-&gt;curband-&gt;band == IEEE80211_BAND_2GHZ){
+	if(sc-&gt;curband-&gt;band == IEEE80211_BAND_2GHZ) {
 		/* We setup a g ratetable for both b/g modes */
-		mac80211_rix = hw_rix - sc-&gt;b_rates - sc-&gt;a_rates - sc-&gt;xr_rates;
+		mac80211_rix =
+			hw_rix - sc-&gt;b_rates - sc-&gt;a_rates - sc-&gt;xr_rates;
 	} else {
 		mac80211_rix = hw_rix - sc-&gt;xr_rates;
 	}
 
 	/* Something went wrong, fallback to basic rate for this band */
-	if((mac80211_rix &gt;= sc-&gt;curband-&gt;n_bitrates) ||
-	(mac80211_rix &lt;= 0 )){
+	if ((mac80211_rix &gt;= sc-&gt;curband-&gt;n_bitrates) ||
+		(mac80211_rix &lt;= 0 ))
 		mac80211_rix = 1;
-	}
 
 	return mac80211_rix;
 }
@@ -1306,7 +1322,8 @@ ath5k_txbuf_setup(struct ath5k_softc *sc, struct ath5k_buf *bf,
 
 	ret = ah-&gt;ah_setup_tx_desc(ah, ds, pktlen,
 		ieee80211_get_hdrlen_from_skb(skb), AR5K_PKT_TYPE_NORMAL,
-		(sc-&gt;power_level * 2), ctl-&gt;tx_rate-&gt;hw_value, ctl-&gt;retry_limit, keyidx, 0, flags, 0, 0);
+		(sc-&gt;power_level * 2), ctl-&gt;tx_rate-&gt;hw_value,
+		ctl-&gt;retry_limit, keyidx, 0, flags, 0, 0);
 	if (ret)
 		goto err_unmap;
 
@@ -1848,7 +1865,8 @@ ath5k_tasklet_rx(unsigned long data)
 		rxs.signal = ds-&gt;ds_rxstat.rs_rssi * 100 / 64;
 
 		rxs.antenna = ds-&gt;ds_rxstat.rs_antenna;
-		rxs.rate_idx = ath5k_hw_to_driver_rix(sc,ds-&gt;ds_rxstat.rs_rate);
+		rxs.rate_idx = ath5k_hw_to_driver_rix(sc,
+			ds-&gt;ds_rxstat.rs_rate);
 		rxs.flag |= ath5k_rx_decrypted(sc, ds, skb);
 
 		ath5k_debug_dump_skb(sc, skb, "RX  ", 0);
@@ -1995,8 +2013,9 @@ ath5k_beacon_setup(struct ath5k_softc *sc, struct ath5k_buf *bf,
 	ds-&gt;ds_data = bf-&gt;skbaddr;
 	ret = ah-&gt;ah_setup_tx_desc(ah, ds, skb-&gt;len,
 			ieee80211_get_hdrlen_from_skb(skb),
-			AR5K_PKT_TYPE_BEACON, (sc-&gt;power_level * 2), ctl-&gt;tx_rate-&gt;hw_value, 1,
-			AR5K_TXKEYIX_INVALID, antenna, flags, 0, 0);
+			AR5K_PKT_TYPE_BEACON, (sc-&gt;power_level * 2),
+			ctl-&gt;tx_rate-&gt;hw_value, 1, AR5K_TXKEYIX_INVALID,
+			antenna, flags, 0, 0);
 	if (ret)
 		goto err_unmap;
 
@@ -2486,7 +2505,8 @@ ath5k_calibrate(unsigned long data)
 	struct ath5k_hw *ah = sc-&gt;ah;
 
 	ATH5K_DBG(sc, ATH5K_DEBUG_CALIBRATE, "channel %u/%x\n",
-		ieee80211_frequency_to_channel(sc-&gt;curchan-&gt;center_freq), sc-&gt;curchan-&gt;hw_value);
+		ieee80211_frequency_to_channel(sc-&gt;curchan-&gt;center_freq),
+		sc-&gt;curchan-&gt;hw_value);
 
 	if (ath5k_hw_get_rf_gain(ah) == AR5K_RFGAIN_NEED_CHANGE) {
 		/*
@@ -2498,7 +2518,8 @@ ath5k_calibrate(unsigned long data)
 	}
 	if (ath5k_hw_phy_calibrate(ah, sc-&gt;curchan))
 		ATH5K_ERR(sc, "calibration of channel %u failed\n",
-				ieee80211_frequency_to_channel(sc-&gt;curchan-&gt;center_freq));
+			ieee80211_frequency_to_channel(
+				sc-&gt;curchan-&gt;center_freq));
 
 	mod_timer(&amp;sc-&gt;calib_tim, round_jiffies(jiffies +
 			msecs_to_jiffies(ath5k_calinterval * 1000)));
diff --git a/drivers/net/wireless/ath5k/initvals.c b/drivers/net/wireless/ath5k/initvals.c
index a255d8bfa949..cfcb1fe7bd34 100644
--- a/drivers/net/wireless/ath5k/initvals.c
+++ b/drivers/net/wireless/ath5k/initvals.c
@@ -1317,8 +1317,10 @@ int ath5k_hw_write_initvals(struct ath5k_hw *ah, u8 mode, bool change_channel)
 	/* For AR5211 */
 	} else if (ah-&gt;ah_version == AR5K_AR5211) {
 
-		if(mode &gt; 2){ /* AR5K_MODE_11B */
-			ATH5K_ERR(ah-&gt;ah_sc,"unsupported channel mode: %d\n", mode);
+		/* AR5K_MODE_11B */
+		if (mode &gt; 2) {
+			ATH5K_ERR(ah-&gt;ah_sc,
+				"unsupported channel mode: %d\n", mode);
 			return -EINVAL;
 		}
 
diff --git a/drivers/net/wireless/ath5k/phy.c b/drivers/net/wireless/ath5k/phy.c
index 8b576b314cf5..248c0f545f24 100644
--- a/drivers/net/wireless/ath5k/phy.c
+++ b/drivers/net/wireless/ath5k/phy.c
@@ -1124,7 +1124,7 @@ static int ath5k_hw_rf5112_rfregs(struct ath5k_hw *ah,
 	rf = ah-&gt;ah_rf_banks;
 
 	if (ah-&gt;ah_radio_5ghz_revision &gt;= AR5K_SREV_RAD_2112A
-		&amp;&amp; !test_bit(AR5K_MODE_11A, ah-&gt;ah_capabilities.cap_mode)){
+		&amp;&amp; !test_bit(AR5K_MODE_11A, ah-&gt;ah_capabilities.cap_mode)) {
 		rf_ini = rfregs_2112a;
 		rf_size = ARRAY_SIZE(rfregs_5112a);
 		if (mode &lt; 2) {
@@ -1445,9 +1445,10 @@ static u32 ath5k_hw_rf5110_chan2athchan(struct ieee80211_channel *channel)
 	 * newer chipsets like the AR5212A who have a completely
 	 * different RF/PHY part.
 	 */
-	athchan = (ath5k_hw_bitswap((ieee80211_frequency_to_channel(channel-&gt;center_freq) - 24) / 2, 5) &lt;&lt; 1) |
-		(1 &lt;&lt; 6) | 0x1;
-
+	athchan = (ath5k_hw_bitswap(
+			(ieee80211_frequency_to_channel(
+				channel-&gt;center_freq) - 24) / 2, 5)
+				&lt;&lt; 1) | (1 &lt;&lt; 6) | 0x1;
 	return athchan;
 }
 
@@ -1506,7 +1507,8 @@ static int ath5k_hw_rf5111_channel(struct ath5k_hw *ah,
 		struct ieee80211_channel *channel)
 {
 	struct ath5k_athchan_2ghz ath5k_channel_2ghz;
-	unsigned int ath5k_channel = ieee80211_frequency_to_channel(channel-&gt;center_freq);
+	unsigned int ath5k_channel =
+		ieee80211_frequency_to_channel(channel-&gt;center_freq);
 	u32 data0, data1, clock;
 	int ret;
 
@@ -1517,8 +1519,9 @@ static int ath5k_hw_rf5111_channel(struct ath5k_hw *ah,
 
 	if (channel-&gt;hw_value &amp; CHANNEL_2GHZ) {
 		/* Map 2GHz channel to 5GHz Atheros channel ID */
-		ret = ath5k_hw_rf5111_chan2athchan(ieee80211_frequency_to_channel(channel-&gt;center_freq),
-				&amp;ath5k_channel_2ghz);
+		ret = ath5k_hw_rf5111_chan2athchan(
+			ieee80211_frequency_to_channel(channel-&gt;center_freq),
+			&amp;ath5k_channel_2ghz);
 		if (ret)
 			return ret;
 
@@ -1599,19 +1602,17 @@ static int ath5k_hw_rf5112_channel(struct ath5k_hw *ah,
 int ath5k_hw_channel(struct ath5k_hw *ah, struct ieee80211_channel *channel)
 {
 	int ret;
-
 	/*
-	 * Check bounds supported by the PHY
-	 * (don't care about regulation restrictions at this point)
-	 */
-	if ((channel-&gt;center_freq &lt; ah-&gt;ah_capabilities.cap_range.range_2ghz_min ||
-	    channel-&gt;center_freq &gt; ah-&gt;ah_capabilities.cap_range.range_2ghz_max) &amp;&amp;
-	    (channel-&gt;center_freq &lt; ah-&gt;ah_capabilities.cap_range.range_5ghz_min ||
-	    channel-&gt;center_freq &gt; ah-&gt;ah_capabilities.cap_range.range_5ghz_max)) {
+	 * Check bounds supported by the PHY (we don't care about regultory
+	 * restrictions at this point). Note: hw_value already has the band
+	 * (CHANNEL_2GHZ, or CHANNEL_5GHZ) so we inform ath5k_channel_ok()
+	 * of the band by that */
+	if (!ath5k_channel_ok(ah, channel-&gt;center_freq, channel-&gt;hw_value)) {
 		ATH5K_ERR(ah-&gt;ah_sc,
-			"channel out of supported range (%u MHz)\n",
+			"channel frequency (%u MHz) out of supported "
+			"band range\n",
 			channel-&gt;center_freq);
-		return -EINVAL;
+			return -EINVAL;
 	}
 
 	/*</pre><hr><pre>commit d8ee398d183df36083e41e9162b0cf014f38f482
Author: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
Date:   Sun Feb 3 21:51:04 2008 -0500

    ath5k: Port to new bitrate/channel API
    
    Author: Nick Kossifidis &lt;mickflemm@gmail.com&gt;
    
    Tested on 5211, 5213+5112, 5213A+2112A and it wors fine.
    
    Also i figured out a way to process rate vallue found
    on status descriptors, it's still buggy but we are getting
    closer (i think it improved stability a little).
    
    Changes to hw.c, initvals.c, phy.c
    Changes-licensed-under: ISC
    
    Changes to ath5k.h, base.c, base.h
    Changes-licensed-under: 3-Clause-BSD
    
    Acked-by: Jiri Slaby &lt;jirislaby@gmail.com&gt;
    Signed-off-by: Nick Kossifidis &lt;mickflemm@gmail.com&gt;
    Signed-off-by: Luis R. Rodriguez &lt;mcgrof@winlab.rutgers.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index cd5fcc67e954..714a6ca30ad2 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -735,7 +735,6 @@ config P54_PCI
 config ATH5K
 	tristate "Atheros 5xxx wireless cards support"
 	depends on PCI &amp;&amp; MAC80211 &amp;&amp; WLAN_80211 &amp;&amp; EXPERIMENTAL
-	depends on BROKEN
 	---help---
 	  This module adds support for wireless adapters based on
 	  Atheros 5xxx chipset.
diff --git a/drivers/net/wireless/ath5k/Makefile b/drivers/net/wireless/ath5k/Makefile
index 321641f99e13..ada1095d4ef1 100644
--- a/drivers/net/wireless/ath5k/Makefile
+++ b/drivers/net/wireless/ath5k/Makefile
@@ -1,2 +1,2 @@
-ath5k-objs		= base.o hw.o regdom.o initvals.o phy.o debug.o
+ath5k-objs		= base.o hw.o initvals.o phy.o debug.o
 obj-$(CONFIG_ATH5K)	+= ath5k.o
diff --git a/drivers/net/wireless/ath5k/ath5k.h b/drivers/net/wireless/ath5k/ath5k.h
index 69dea3392612..9ea8c549b781 100644
--- a/drivers/net/wireless/ath5k/ath5k.h
+++ b/drivers/net/wireless/ath5k/ath5k.h
@@ -30,7 +30,6 @@
 #include &lt;net/mac80211.h&gt;
 
 #include "hw.h"
-#include "regdom.h"
 
 /* PCI IDs */
 #define PCI_DEVICE_ID_ATHEROS_AR5210 		0x0007 /* AR5210 */
@@ -251,18 +250,20 @@ struct ath5k_srev_name {
  */
 #define MODULATION_TURBO	0x00000080
 
-enum ath5k_vendor_mode {
-	MODE_ATHEROS_TURBO = NUM_IEEE80211_MODES+1,
-	MODE_ATHEROS_TURBOG
+enum ath5k_driver_mode {
+	AR5K_MODE_11A		=	0,
+	AR5K_MODE_11A_TURBO	=	1,
+	AR5K_MODE_11B		=	2,
+	AR5K_MODE_11G		=	3,
+	AR5K_MODE_11G_TURBO	=	4,
+	AR5K_MODE_XR		=	0,
+	AR5K_MODE_MAX		=	5
 };
 
-/* Number of supported mac80211 enum ieee80211_phymode modes by this driver */
-#define NUM_DRIVER_MODES	3
-
 /* adding this flag to rate_code enables short preamble, see ar5212_reg.h */
 #define AR5K_SET_SHORT_PREAMBLE 0x04
 
-#define HAS_SHPREAMBLE(_ix) (rt-&gt;rates[_ix].modulation == IEEE80211_RATE_CCK_2)
+#define HAS_SHPREAMBLE(_ix) (rt-&gt;rates[_ix].modulation == IEEE80211_RATE_SHORT_PREAMBLE)
 #define SHPREAMBLE_FLAG(_ix) (HAS_SHPREAMBLE(_ix) ? AR5K_SET_SHORT_PREAMBLE : 0)
 
 /****************\
@@ -560,8 +561,8 @@ struct ath5k_desc {
  * Used internaly in OpenHAL (ar5211.c/ar5212.c
  * for reset_tx_queue). Also see struct struct ieee80211_channel.
  */
-#define IS_CHAN_XR(_c)	((_c.val &amp; CHANNEL_XR) != 0)
-#define IS_CHAN_B(_c)	((_c.val &amp; CHANNEL_B) != 0)
+#define IS_CHAN_XR(_c)	((_c.hw_value &amp; CHANNEL_XR) != 0)
+#define IS_CHAN_B(_c)	((_c.hw_value &amp; CHANNEL_B) != 0)
 
 /*
  * The following structure will be used to map 2GHz channels to
@@ -584,7 +585,7 @@ struct ath5k_athchan_2ghz {
 
 /**
  * struct ath5k_rate - rate structure
- * @valid: is this a valid rate for the current mode
+ * @valid: is this a valid rate for rate control (remove)
  * @modulation: respective mac80211 modulation
  * @rate_kbps: rate in kbit/s
  * @rate_code: hardware rate value, used in &amp;struct ath5k_desc, on RX on
@@ -643,47 +644,48 @@ struct ath5k_rate_table {
 
 /*
  * Rate tables...
+ * TODO: CLEAN THIS !!!
  */
 #define AR5K_RATES_11A { 8, {					\
 	255, 255, 255, 255, 255, 255, 255, 255, 6, 4, 2, 0,	\
 	7, 5, 3, 1, 255, 255, 255, 255, 255, 255, 255, 255,	\
 	255, 255, 255, 255, 255, 255, 255, 255 }, {		\
-	{ 1, IEEE80211_RATE_OFDM, 6000, 11, 140, 0 },		\
-	{ 1, IEEE80211_RATE_OFDM, 9000, 15, 18, 0 },		\
-	{ 1, IEEE80211_RATE_OFDM, 12000, 10, 152, 2 },		\
-	{ 1, IEEE80211_RATE_OFDM, 18000, 14, 36, 2 },		\
-	{ 1, IEEE80211_RATE_OFDM, 24000, 9, 176, 4 },		\
-	{ 1, IEEE80211_RATE_OFDM, 36000, 13, 72, 4 },		\
-	{ 1, IEEE80211_RATE_OFDM, 48000, 8, 96, 4 },		\
-	{ 1, IEEE80211_RATE_OFDM, 54000, 12, 108, 4 } }		\
+	{ 1, 0, 6000, 11, 140, 0 },		\
+	{ 1, 0, 9000, 15, 18, 0 },		\
+	{ 1, 0, 12000, 10, 152, 2 },		\
+	{ 1, 0, 18000, 14, 36, 2 },		\
+	{ 1, 0, 24000, 9, 176, 4 },		\
+	{ 1, 0, 36000, 13, 72, 4 },		\
+	{ 1, 0, 48000, 8, 96, 4 },		\
+	{ 1, 0, 54000, 12, 108, 4 } }		\
 }
 
 #define AR5K_RATES_11B { 4, {						\
 	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,	\
 	255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,	\
 	3, 2, 1, 0, 255, 255, 255, 255 }, {				\
-	{ 1, IEEE80211_RATE_CCK, 1000, 27, 130, 0 },	\
-	{ 1, IEEE80211_RATE_CCK_2, 2000, 26, 132, 1 },	\
-	{ 1, IEEE80211_RATE_CCK_2, 5500, 25, 139, 1 },	\
-	{ 1, IEEE80211_RATE_CCK_2, 11000, 24, 150, 1 } }	\
+	{ 1, 0, 1000, 27, 130, 0 },	\
+	{ 1, IEEE80211_RATE_SHORT_PREAMBLE, 2000, 26, 132, 1 },	\
+	{ 1, IEEE80211_RATE_SHORT_PREAMBLE, 5500, 25, 139, 1 },	\
+	{ 1, IEEE80211_RATE_SHORT_PREAMBLE, 11000, 24, 150, 1 } }	\
 }
 
 #define AR5K_RATES_11G { 12, {					\
 	255, 255, 255, 255, 255, 255, 255, 255, 10, 8, 6, 4,	\
 	11, 9, 7, 5, 255, 255, 255, 255, 255, 255, 255, 255,	\
 	3, 2, 1, 0, 255, 255, 255, 255 }, {			\
-	{ 1, IEEE80211_RATE_CCK, 1000, 27, 2, 0 },		\
-	{ 1, IEEE80211_RATE_CCK_2, 2000, 26, 4, 1 },		\
-	{ 1, IEEE80211_RATE_CCK_2, 5500, 25, 11, 1 },		\
-	{ 1, IEEE80211_RATE_CCK_2, 11000, 24, 22, 1 },	\
-	{ 0, IEEE80211_RATE_OFDM, 6000, 11, 12, 4 },	\
-	{ 0, IEEE80211_RATE_OFDM, 9000, 15, 18, 4 },	\
-	{ 1, IEEE80211_RATE_OFDM, 12000, 10, 24, 6 },	\
-	{ 1, IEEE80211_RATE_OFDM, 18000, 14, 36, 6 },	\
-	{ 1, IEEE80211_RATE_OFDM, 24000, 9, 48, 8 },	\
-	{ 1, IEEE80211_RATE_OFDM, 36000, 13, 72, 8 },	\
-	{ 1, IEEE80211_RATE_OFDM, 48000, 8, 96, 8 },	\
-	{ 1, IEEE80211_RATE_OFDM, 54000, 12, 108, 8 } }	\
+	{ 1, 0, 1000, 27, 2, 0 },		\
+	{ 1, IEEE80211_RATE_SHORT_PREAMBLE, 2000, 26, 4, 1 },		\
+	{ 1, IEEE80211_RATE_SHORT_PREAMBLE, 5500, 25, 11, 1 },		\
+	{ 1, IEEE80211_RATE_SHORT_PREAMBLE, 11000, 24, 22, 1 },	\
+	{ 0, 0, 6000, 11, 12, 4 },	\
+	{ 0, 0, 9000, 15, 18, 4 },	\
+	{ 1, 0, 12000, 10, 24, 6 },	\
+	{ 1, 0, 18000, 14, 36, 6 },	\
+	{ 1, 0, 24000, 9, 48, 8 },	\
+	{ 1, 0, 36000, 13, 72, 8 },	\
+	{ 1, 0, 48000, 8, 96, 8 },	\
+	{ 1, 0, 54000, 12, 108, 8 } }	\
 }
 
 #define AR5K_RATES_TURBO { 8, {					\
@@ -708,14 +710,14 @@ struct ath5k_rate_table {
 	{ 1, MODULATION_XR, 1000, 2, 139, 1 },		\
 	{ 1, MODULATION_XR, 2000, 6, 150, 2 },		\
 	{ 1, MODULATION_XR, 3000, 1, 150, 3 },		\
-	{ 1, IEEE80211_RATE_OFDM, 6000, 11, 140, 4 },	\
-	{ 1, IEEE80211_RATE_OFDM, 9000, 15, 18, 4 },	\
-	{ 1, IEEE80211_RATE_OFDM, 12000, 10, 152, 6 },	\
-	{ 1, IEEE80211_RATE_OFDM, 18000, 14, 36, 6 },	\
-	{ 1, IEEE80211_RATE_OFDM, 24000, 9, 176, 8 },	\
-	{ 1, IEEE80211_RATE_OFDM, 36000, 13, 72, 8 },	\
-	{ 1, IEEE80211_RATE_OFDM, 48000, 8, 96, 8 },	\
-	{ 1, IEEE80211_RATE_OFDM, 54000, 12, 108, 8 } }	\
+	{ 1, 0, 6000, 11, 140, 4 },	\
+	{ 1, 0, 9000, 15, 18, 4 },	\
+	{ 1, 0, 12000, 10, 152, 6 },	\
+	{ 1, 0, 18000, 14, 36, 6 },	\
+	{ 1, 0, 24000, 9, 176, 8 },	\
+	{ 1, 0, 36000, 13, 72, 8 },	\
+	{ 1, 0, 48000, 8, 96, 8 },	\
+	{ 1, 0, 54000, 12, 108, 8 } }	\
 }
 
 /*
@@ -895,7 +897,7 @@ struct ath5k_capabilities {
 	 * Supported PHY modes
 	 * (ie. CHANNEL_A, CHANNEL_B, ...)
 	 */
-	DECLARE_BITMAP(cap_mode, NUM_DRIVER_MODES);
+	DECLARE_BITMAP(cap_mode, AR5K_MODE_MAX);
 
 	/*
 	 * Frequency range (without regulation restrictions)
@@ -907,14 +909,6 @@ struct ath5k_capabilities {
 		u16	range_5ghz_max;
 	} cap_range;
 
-	/*
-	 * Active regulation domain settings
-	 */
-	struct {
-		enum ath5k_regdom reg_current;
-		enum ath5k_regdom reg_hw;
-	} cap_regdomain;
-
 	/*
 	 * Values stored in the EEPROM (some of them...)
 	 */
@@ -1129,8 +1123,6 @@ extern int ath5k_hw_set_gpio_input(struct ath5k_hw *ah, u32 gpio);
 extern u32 ath5k_hw_get_gpio(struct ath5k_hw *ah, u32 gpio);
 extern int ath5k_hw_set_gpio(struct ath5k_hw *ah, u32 gpio, u32 val);
 extern void ath5k_hw_set_gpio_intr(struct ath5k_hw *ah, unsigned int gpio, u32 interrupt_level);
-/* Regulatory Domain/Channels Setup */
-extern u16 ath5k_get_regdomain(struct ath5k_hw *ah);
 /* Misc functions */
 extern int ath5k_hw_get_capability(struct ath5k_hw *ah, enum ath5k_capability_type cap_type, u32 capability, u32 *result);
 
diff --git a/drivers/net/wireless/ath5k/base.c b/drivers/net/wireless/ath5k/base.c
index bef967ce34a6..52e55f67b735 100644
--- a/drivers/net/wireless/ath5k/base.c
+++ b/drivers/net/wireless/ath5k/base.c
@@ -240,6 +240,8 @@ static int 	ath5k_chan_set(struct ath5k_softc *sc,
 static void	ath5k_setcurmode(struct ath5k_softc *sc,
 				unsigned int mode);
 static void	ath5k_mode_setup(struct ath5k_softc *sc);
+static void	ath5k_set_total_hw_rates(struct ath5k_softc *sc);
+
 /* Descriptor setup */
 static int	ath5k_desc_alloc(struct ath5k_softc *sc,
 				struct pci_dev *pdev);
@@ -515,12 +517,12 @@ ath5k_pci_probe(struct pci_dev *pdev,
 		/* Single chip radio (!RF5111) */
 		if(sc-&gt;ah-&gt;ah_radio_5ghz_revision &amp;&amp; !sc-&gt;ah-&gt;ah_radio_2ghz_revision) {
 			/* No 5GHz support -&gt; report 2GHz radio */
-			if(!test_bit(MODE_IEEE80211A, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+			if(!test_bit(AR5K_MODE_11A, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
 				ATH5K_INFO(sc, "RF%s 2GHz radio found (0x%x)\n",
 					ath5k_chip_name(AR5K_VERSION_RAD,sc-&gt;ah-&gt;ah_radio_5ghz_revision),
 							sc-&gt;ah-&gt;ah_radio_5ghz_revision);
 			/* No 2GHz support (5110 and some 5Ghz only cards) -&gt; report 5Ghz radio */
-			} else if(!test_bit(MODE_IEEE80211B, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+			} else if(!test_bit(AR5K_MODE_11B, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
 				ATH5K_INFO(sc, "RF%s 5GHz radio found (0x%x)\n",
 					ath5k_chip_name(AR5K_VERSION_RAD,sc-&gt;ah-&gt;ah_radio_5ghz_revision),
 							sc-&gt;ah-&gt;ah_radio_5ghz_revision);
@@ -693,11 +695,14 @@ ath5k_attach(struct pci_dev *pdev, struct ieee80211_hw *hw)
 		goto err;
 	}
 
+	/* Set *_rates so we can map hw rate index */
+	ath5k_set_total_hw_rates(sc);
+
 	/* NB: setup here so ath5k_rate_update is happy */
-	if (test_bit(MODE_IEEE80211A, ah-&gt;ah_modes))
-		ath5k_setcurmode(sc, MODE_IEEE80211A);
+	if (test_bit(AR5K_MODE_11A, ah-&gt;ah_modes))
+		ath5k_setcurmode(sc, AR5K_MODE_11A);
 	else
-		ath5k_setcurmode(sc, MODE_IEEE80211B);
+		ath5k_setcurmode(sc, AR5K_MODE_11B);
 
 	/*
 	 * Allocate tx+rx descriptors and populate the lists.
@@ -837,12 +842,9 @@ ath5k_copy_rates(struct ieee80211_rate *rates,
 		return 0;
 
 	for (i = 0, count = 0; i &lt; rt-&gt;rate_count &amp;&amp; max &gt; 0; i++) {
-		if (!rt-&gt;rates[i].valid)
-			continue;
-		rates-&gt;rate = rt-&gt;rates[i].rate_kbps / 100;
-		rates-&gt;val = rt-&gt;rates[i].rate_code;
-		rates-&gt;flags = rt-&gt;rates[i].modulation;
-		rates++;
+		rates[count].bitrate = rt-&gt;rates[i].rate_kbps / 100;
+		rates[count].hw_value = rt-&gt;rates[i].rate_code;
+		rates[count].flags = rt-&gt;rates[i].modulation;
 		count++;
 		max--;
 	}
@@ -856,43 +858,22 @@ ath5k_copy_channels(struct ath5k_hw *ah,
 		unsigned int mode,
 		unsigned int max)
 {
-	static const struct { unsigned int mode, mask, chan; } map[] = {
-		[MODE_IEEE80211A] = { CHANNEL_OFDM, CHANNEL_OFDM | CHANNEL_TURBO, CHANNEL_A },
-		[MODE_ATHEROS_TURBO] = { CHANNEL_OFDM|CHANNEL_TURBO, CHANNEL_OFDM | CHANNEL_TURBO, CHANNEL_T },
-		[MODE_IEEE80211B] = { CHANNEL_CCK, CHANNEL_CCK, CHANNEL_B },
-		[MODE_IEEE80211G] = { CHANNEL_OFDM, CHANNEL_OFDM, CHANNEL_G },
-		[MODE_ATHEROS_TURBOG] = { CHANNEL_OFDM | CHANNEL_TURBO, CHANNEL_OFDM | CHANNEL_TURBO, CHANNEL_TG },
-	};
-	static const struct ath5k_regchannel chans_2ghz[] =
-		IEEE80211_CHANNELS_2GHZ;
-	static const struct ath5k_regchannel chans_5ghz[] =
-		IEEE80211_CHANNELS_5GHZ;
-	const struct ath5k_regchannel *chans;
-	enum ath5k_regdom dmn;
-	unsigned int i, count, size, chfreq, all, f, ch;
+	unsigned int i, count, size, chfreq, freq, ch;
 
 	if (!test_bit(mode, ah-&gt;ah_modes))
 		return 0;
 
-	all = ah-&gt;ah_regdomain == DMN_DEFAULT || CHAN_DEBUG == 1;
-
 	switch (mode) {
-	case MODE_IEEE80211A:
-	case MODE_ATHEROS_TURBO:
+	case AR5K_MODE_11A:
+	case AR5K_MODE_11A_TURBO:
 		/* 1..220, but 2GHz frequencies are filtered by check_channel */
-		size = all ? 220 : ARRAY_SIZE(chans_5ghz);
-		chans = chans_5ghz;
-		dmn = ath5k_regdom2flag(ah-&gt;ah_regdomain,
-				IEEE80211_CHANNELS_5GHZ_MIN);
+		size = 220 ;
 		chfreq = CHANNEL_5GHZ;
 		break;
-	case MODE_IEEE80211B:
-	case MODE_IEEE80211G:
-	case MODE_ATHEROS_TURBOG:
-		size = all ? 26 : ARRAY_SIZE(chans_2ghz);
-		chans = chans_2ghz;
-		dmn = ath5k_regdom2flag(ah-&gt;ah_regdomain,
-				IEEE80211_CHANNELS_2GHZ_MIN);
+	case AR5K_MODE_11B:
+	case AR5K_MODE_11G:
+	case AR5K_MODE_11G_TURBO:
+		size = 26;
 		chfreq = CHANNEL_2GHZ;
 		break;
 	default:
@@ -901,25 +882,26 @@ ath5k_copy_channels(struct ath5k_hw *ah,
 	}
 
 	for (i = 0, count = 0; i &lt; size &amp;&amp; max &gt; 0; i++) {
-		ch = all ? i + 1 : chans[i].chan;
-		f = ath5k_ieee2mhz(ch);
-		/* Check if channel is supported by the chipset */
-		if (!ath5k_channel_ok(ah, f, chfreq))
-			continue;
+		ch = i + 1 ;
+		freq = ath5k_ieee2mhz(ch);
 
-		/* Match regulation domain */
-		if (!all &amp;&amp; !(IEEE80211_DMN(chans[i].domain) &amp;
-							IEEE80211_DMN(dmn)))
+		/* Check if channel is supported by the chipset */
+		if (!ath5k_channel_ok(ah, freq, chfreq))
 			continue;
 
-		if (!all &amp;&amp; (chans[i].mode &amp; map[mode].mask) != map[mode].mode)
-			continue;
+		/* Write channel info and increment counter */
+		channels[count].center_freq = freq;
+
+		if((mode == AR5K_MODE_11A) ||
+		(mode == AR5K_MODE_11G)){
+			channels[count].hw_value = chfreq|CHANNEL_OFDM;
+		} else if((mode == AR5K_MODE_11A_TURBO) ||
+		(mode == AR5K_MODE_11G_TURBO)){
+			channels[count].hw_value = chfreq|CHANNEL_OFDM|CHANNEL_TURBO;
+		}if(mode == AR5K_MODE_11B) {
+			channels[count].hw_value = CHANNEL_B;
+		}
 
-		/* Write channel and increment counter */
-		channels-&gt;chan = ch;
-		channels-&gt;freq = f;
-		channels-&gt;val = map[mode].chan;
-		channels++;
 		count++;
 		max--;
 	}
@@ -927,95 +909,76 @@ ath5k_copy_channels(struct ath5k_hw *ah,
 	return count;
 }
 
-/* Only tries to register modes our EEPROM says it can support */
-#define REGISTER_MODE(m) do { \
-	ret = ath5k_register_mode(hw, m); \
-	if (ret) \
-		return ret; \
-} while (0) \
-
-static inline int
-ath5k_register_mode(struct ieee80211_hw *hw, u8 m)
+static int
+ath5k_getchannels(struct ieee80211_hw *hw)
 {
 	struct ath5k_softc *sc = hw-&gt;priv;
-	struct ieee80211_hw_mode *modes = sc-&gt;modes;
-	unsigned int i;
-	int ret;
+	struct ath5k_hw *ah = sc-&gt;ah;
+	struct ieee80211_supported_band *sbands = sc-&gt;sbands;
+	const struct ath5k_rate_table *hw_rates;
+	unsigned int max_r, max_c, count_r, count_c;
+	int mode2g = AR5K_MODE_11G;
 
-	if (!test_bit(m, sc-&gt;ah-&gt;ah_capabilities.cap_mode))
-		return 0;
+	BUILD_BUG_ON(ARRAY_SIZE(sc-&gt;sbands) &lt; IEEE80211_NUM_BANDS);
 
-	for (i = 0; i &lt; NUM_DRIVER_MODES; i++) {
-		if (modes[i].mode != m || !modes[i].num_channels)
-			continue;
-		ret = ieee80211_register_hwmode(hw, &amp;modes[i]);
-		if (ret) {
-			ATH5K_ERR(sc, "can't register hwmode %u\n", m);
-			return ret;
+	max_r = ARRAY_SIZE(sc-&gt;rates);
+	max_c = ARRAY_SIZE(sc-&gt;channels);
+	count_r = count_c = 0;
+
+	/* 2GHz band */
+	if(!test_bit(AR5K_MODE_11G, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+		mode2g = AR5K_MODE_11B;
+		if(!test_bit(AR5K_MODE_11B, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+			mode2g = -1;
 		}
-		return 0;
 	}
-	BUG();
-}
 
-static int
-ath5k_getchannels(struct ieee80211_hw *hw)
-{
-	struct ath5k_softc *sc = hw-&gt;priv;
-	struct ath5k_hw *ah = sc-&gt;ah;
-	struct ieee80211_hw_mode *modes = sc-&gt;modes;
-	unsigned int i, max_r, max_c;
-	int ret;
+	if(mode2g &gt; 0){
+		struct ieee80211_supported_band *sband = &amp;sbands[IEEE80211_BAND_2GHZ];
 
-	BUILD_BUG_ON(ARRAY_SIZE(sc-&gt;modes) &lt; 3);
+		sband-&gt;bitrates = sc-&gt;rates;
+		sband-&gt;channels = sc-&gt;channels;
 
-	/* The order here does not matter */
-	modes[0].mode = MODE_IEEE80211G;
-	modes[1].mode = MODE_IEEE80211B;
-	modes[2].mode = MODE_IEEE80211A;
+		sband-&gt;band = IEEE80211_BAND_2GHZ;
+		sband-&gt;n_channels = ath5k_copy_channels(ah, sband-&gt;channels,
+					mode2g, max_c);
 
-	max_r = ARRAY_SIZE(sc-&gt;rates);
-	max_c = ARRAY_SIZE(sc-&gt;channels);
+		hw_rates = ath5k_hw_get_rate_table(ah, mode2g);
+		sband-&gt;n_bitrates = ath5k_copy_rates(sband-&gt;bitrates,
+					hw_rates,max_r);
 
-	for (i = 0; i &lt; NUM_DRIVER_MODES; i++) {
-		struct ieee80211_hw_mode *mode = &amp;modes[i];
-		const struct ath5k_rate_table *hw_rates;
+		count_c = sband-&gt;n_channels;
+		count_r = sband-&gt;n_bitrates;
 
-		if (i == 0) {
-			modes[0].rates	= sc-&gt;rates;
-			modes-&gt;channels	= sc-&gt;channels;
-		} else {
-			struct ieee80211_hw_mode *prev_mode = &amp;modes[i-1];
-			int prev_num_r	= prev_mode-&gt;num_rates;
-			int prev_num_c	= prev_mode-&gt;num_channels;
-			mode-&gt;rates	= &amp;prev_mode-&gt;rates[prev_num_r];
-			mode-&gt;channels	= &amp;prev_mode-&gt;channels[prev_num_c];
-		}
+		hw-&gt;wiphy-&gt;bands[IEEE80211_BAND_2GHZ] = sband;
+
+		max_r -= count_r;
+		max_c -= count_c;
 
-		hw_rates = ath5k_hw_get_rate_table(ah, mode-&gt;mode);
-		mode-&gt;num_rates    = ath5k_copy_rates(mode-&gt;rates, hw_rates,
-			max_r);
-		mode-&gt;num_channels = ath5k_copy_channels(ah, mode-&gt;channels,
-			mode-&gt;mode, max_c);
-		max_r -= mode-&gt;num_rates;
-		max_c -= mode-&gt;num_channels;
 	}
 
-	/* We try to register all modes this driver supports. We don't bother
-	 * with MODE_IEEE80211B for AR5212 as MODE_IEEE80211G already accounts
-	 * for that as per mac80211. Then, REGISTER_MODE() will will actually
-	 * check the eeprom reading for more reliable capability information.
-	 * Order matters here as per mac80211's latest preference. This will
-	 * all hopefullly soon go away. */
+	/* 5GHz band */
 
-	REGISTER_MODE(MODE_IEEE80211G);
-	if (ah-&gt;ah_version != AR5K_AR5212)
-		REGISTER_MODE(MODE_IEEE80211B);
-	REGISTER_MODE(MODE_IEEE80211A);
+	if(test_bit(AR5K_MODE_11A, sc-&gt;ah-&gt;ah_capabilities.cap_mode)){
+		struct ieee80211_supported_band *sband = &amp;sbands[IEEE80211_BAND_5GHZ];
 
-	ath5k_debug_dump_modes(sc, modes);
+		sband-&gt;bitrates = &amp;sc-&gt;rates[count_r];
+		sband-&gt;channels = &amp;sc-&gt;channels[count_c];
 
-	return ret;
+		sband-&gt;band = IEEE80211_BAND_5GHZ;
+		sband-&gt;n_channels = ath5k_copy_channels(ah, sband-&gt;channels,
+					AR5K_MODE_11A, max_c);
+
+		hw_rates = ath5k_hw_get_rate_table(ah, AR5K_MODE_11A);
+		sband-&gt;n_bitrates = ath5k_copy_rates(sband-&gt;bitrates,
+					hw_rates,max_r);
+
+		hw-&gt;wiphy-&gt;bands[IEEE80211_BAND_5GHZ] = sband;
+	}
+
+/* FIXME:	ath5k_debug_dump_modes(sc, modes); */
+
+	return 0;
 }
 
 /*
@@ -1030,11 +993,15 @@ ath5k_chan_set(struct ath5k_softc *sc, struct ieee80211_channel *chan)
 	struct ath5k_hw *ah = sc-&gt;ah;
 	int ret;
 
-	ATH5K_DBG(sc, ATH5K_DEBUG_RESET, "%u (%u MHz) -&gt; %u (%u MHz)\n",
-		sc-&gt;curchan-&gt;chan, sc-&gt;curchan-&gt;freq,
-		chan-&gt;chan, chan-&gt;freq);
+	ATH5K_DBG(sc, ATH5K_DEBUG_RESET, "(%u MHz) -&gt; (%u MHz)\n",
+		sc-&gt;curchan-&gt;center_freq, chan-&gt;center_freq);
+
+	if (chan-&gt;center_freq != sc-&gt;curchan-&gt;center_freq ||
+		chan-&gt;hw_value != sc-&gt;curchan-&gt;hw_value) {
+
+		sc-&gt;curchan = chan;
+		sc-&gt;curband = &amp;sc-&gt;sbands[chan-&gt;band];
 
-	if (chan-&gt;freq != sc-&gt;curchan-&gt;freq || chan-&gt;val != sc-&gt;curchan-&gt;val) {
 		/*
 		 * To switch channels clear any pending DMA operations;
 		 * wait long enough for the RX fifo to drain, reset the
@@ -1044,13 +1011,13 @@ ath5k_chan_set(struct ath5k_softc *sc, struct ieee80211_channel *chan)
 		ath5k_hw_set_intr(ah, 0);	/* disable interrupts */
 		ath5k_txq_cleanup(sc);		/* clear pending tx frames */
 		ath5k_rx_stop(sc);		/* turn off frame recv */
-		ret = ath5k_hw_reset(ah, sc-&gt;opmode, chan, true);
+		ret = ath5k_hw_reset(ah, sc-&gt;opmode, sc-&gt;curchan, true);
 		if (ret) {
-			ATH5K_ERR(sc, "%s: unable to reset channel %u "
-				"(%u Mhz)\n", __func__, chan-&gt;chan, chan-&gt;freq);
+			ATH5K_ERR(sc, "%s: unable to reset channel "
+				"(%u Mhz)\n", __func__, chan-&gt;center_freq);
 			return ret;
 		}
-		sc-&gt;curchan = chan;
+
 		ath5k_hw_set_txpower_limit(sc-&gt;ah, 0);
 
 		/*
@@ -1081,6 +1048,9 @@ ath5k_chan_set(struct ath5k_softc *sc, struct ieee80211_channel *chan)
 	return 0;
 }
 
+/*
+ * TODO: CLEAN THIS !!!
+ */
 static void
 ath5k_setcurmode(struct ath5k_softc *sc, unsigned int mode)
 {
@@ -1121,10 +1091,6 @@ ath5k_setcurmode(struct ath5k_softc *sc, unsigned int mode)
 				continue;
 			}
 			sc-&gt;hwmap[i].txflags = IEEE80211_RADIOTAP_F_DATAPAD;
-			if (SHPREAMBLE_FLAG(ix) || rt-&gt;rates[ix].modulation ==
-					IEEE80211_RATE_OFDM)
-				sc-&gt;hwmap[i].txflags |=
-						IEEE80211_RADIOTAP_F_SHORTPRE;
 			/* receive frames include FCS */
 			sc-&gt;hwmap[i].rxflags = sc-&gt;hwmap[i].txflags |
 					IEEE80211_RADIOTAP_F_FCS;
@@ -1142,6 +1108,12 @@ ath5k_setcurmode(struct ath5k_softc *sc, unsigned int mode)
 	}
 
 	sc-&gt;curmode = mode;
+
+	if(mode == AR5K_MODE_11A){
+		sc-&gt;curband = &amp;sc-&gt;sbands[IEEE80211_BAND_5GHZ];
+	} else {
+		sc-&gt;curband = &amp;sc-&gt;sbands[IEEE80211_BAND_2GHZ];
+	}
 }
 
 static void
@@ -1164,6 +1136,72 @@ ath5k_mode_setup(struct ath5k_softc *sc)
 	ATH5K_DBG(sc, ATH5K_DEBUG_MODE, "RX filter 0x%x\n", rfilt);
 }
 
+/*
+ * Match the hw provided rate index (through descriptors)
+ * to an index for sc-&gt;curband-&gt;bitrates, so it can be used
+ * by the stack.
+ *
+ * This one is a little bit tricky but i think i'm right
+ * about this...
+ *
+ * We have 4 rate tables in the following order:
+ * XR (4 rates)
+ * 802.11a (8 rates)
+ * 802.11b (4 rates)
+ * 802.11g (12 rates)
+ * that make the hw rate table.
+ *
+ * Lets take a 5211 for example that supports a and b modes only.
+ * First comes the 802.11a table and then 802.11b (total 12 rates).
+ * When hw returns eg. 11 it points to the last 802.11b rate (11Mbit),
+ * if it returns 2 it points to the second 802.11a rate etc.
+ *
+ * Same goes for 5212 who has xr/a/b/g support (total 28 rates).
+ * First comes the XR table, then 802.11a, 802.11b and 802.11g.
+ * When hw returns eg. 27 it points to the last 802.11g rate (54Mbits) etc
+ */
+static void
+ath5k_set_total_hw_rates(struct ath5k_softc *sc){
+
+	struct ath5k_hw *ah = sc-&gt;ah;
+
+	if(test_bit(AR5K_MODE_11A, ah-&gt;ah_modes))
+		sc-&gt;a_rates = 8;
+
+	if(test_bit(AR5K_MODE_11B, ah-&gt;ah_modes))
+		sc-&gt;b_rates = 4;
+
+	if(test_bit(AR5K_MODE_11G, ah-&gt;ah_modes))
+		sc-&gt;g_rates = 12;
+
+	/* XXX: Need to see what what happens when
+		xr disable bits in eeprom are set */
+	if(ah-&gt;ah_version &gt;= AR5K_AR5212)
+		sc-&gt;xr_rates = 4;
+
+}
+
+static inline int
+ath5k_hw_to_driver_rix(struct ath5k_softc *sc, int hw_rix){
+
+	int mac80211_rix;
+
+	if(sc-&gt;curband-&gt;band == IEEE80211_BAND_2GHZ){
+		/* We setup a g ratetable for both b/g modes */
+		mac80211_rix = hw_rix - sc-&gt;b_rates - sc-&gt;a_rates - sc-&gt;xr_rates;
+	} else {
+		mac80211_rix = hw_rix - sc-&gt;xr_rates;
+	}
+
+	/* Something went wrong, fallback to basic rate for this band */
+	if((mac80211_rix &gt;= sc-&gt;curband-&gt;n_bitrates) ||
+	(mac80211_rix &lt;= 0 )){
+		mac80211_rix = 1;
+	}
+
+	return mac80211_rix;
+}
+
 
 
 
@@ -1268,7 +1306,7 @@ ath5k_txbuf_setup(struct ath5k_softc *sc, struct ath5k_buf *bf,
 
 	ret = ah-&gt;ah_setup_tx_desc(ah, ds, pktlen,
 		ieee80211_get_hdrlen_from_skb(skb), AR5K_PKT_TYPE_NORMAL,
-		(ctl-&gt;power_level * 2), ctl-&gt;tx_rate, ctl-&gt;retry_limit, keyidx, 0, flags, 0, 0);
+		(sc-&gt;power_level * 2), ctl-&gt;tx_rate-&gt;hw_value, ctl-&gt;retry_limit, keyidx, 0, flags, 0, 0);
 	if (ret)
 		goto err_unmap;
 
@@ -1791,9 +1829,8 @@ ath5k_tasklet_rx(unsigned long data)
 		rxs.mactime = ath5k_extend_tsf(sc-&gt;ah, ds-&gt;ds_rxstat.rs_tstamp);
 		rxs.flag |= RX_FLAG_TSFT;
 
-		rxs.freq = sc-&gt;curchan-&gt;freq;
-		rxs.channel = sc-&gt;curchan-&gt;chan;
-		rxs.phymode = sc-&gt;curmode;
+		rxs.freq = sc-&gt;curchan-&gt;center_freq;
+		rxs.band = sc-&gt;curband-&gt;band;
 
 		/*
 		 * signal quality:
@@ -1811,7 +1848,7 @@ ath5k_tasklet_rx(unsigned long data)
 		rxs.signal = ds-&gt;ds_rxstat.rs_rssi * 100 / 64;
 
 		rxs.antenna = ds-&gt;ds_rxstat.rs_antenna;
-		rxs.rate = ds-&gt;ds_rxstat.rs_rate;
+		rxs.rate_idx = ath5k_hw_to_driver_rix(sc,ds-&gt;ds_rxstat.rs_rate);
 		rxs.flag |= ath5k_rx_decrypted(sc, ds, skb);
 
 		ath5k_debug_dump_skb(sc, skb, "RX  ", 0);
@@ -1958,7 +1995,7 @@ ath5k_beacon_setup(struct ath5k_softc *sc, struct ath5k_buf *bf,
 	ds-&gt;ds_data = bf-&gt;skbaddr;
 	ret = ah-&gt;ah_setup_tx_desc(ah, ds, skb-&gt;len,
 			ieee80211_get_hdrlen_from_skb(skb),
-			AR5K_PKT_TYPE_BEACON, (ctl-&gt;power_level * 2), ctl-&gt;tx_rate, 1,
+			AR5K_PKT_TYPE_BEACON, (sc-&gt;power_level * 2), ctl-&gt;tx_rate-&gt;hw_value, 1,
 			AR5K_TXKEYIX_INVALID, antenna, flags, 0, 0);
 	if (ret)
 		goto err_unmap;
@@ -2211,7 +2248,8 @@ ath5k_init(struct ath5k_softc *sc)
 	 * be followed by initialization of the appropriate bits
 	 * and then setup of the interrupt mask.
 	 */
-	sc-&gt;curchan = sc-&gt;hw-&gt;conf.chan;
+	sc-&gt;curchan = sc-&gt;hw-&gt;conf.channel;
+	sc-&gt;curband = &amp;sc-&gt;sbands[sc-&gt;curchan-&gt;band];
 	ret = ath5k_hw_reset(sc-&gt;ah, sc-&gt;opmode, sc-&gt;curchan, false);
 	if (ret) {
 		ATH5K_ERR(sc, "unable to reset hardware: %d\n", ret);
@@ -2448,7 +2486,7 @@ ath5k_calibrate(unsigned long data)
 	struct ath5k_hw *ah = sc-&gt;ah;
 
 	ATH5K_DBG(sc, ATH5K_DEBUG_CALIBRATE, "channel %u/%x\n",
-		sc-&gt;curchan-&gt;chan, sc-&gt;curchan-&gt;val);
+		ieee80211_frequency_to_channel(sc-&gt;curchan-&gt;center_freq), sc-&gt;curchan-&gt;hw_value);
 
 	if (ath5k_hw_get_rf_gain(ah) == AR5K_RFGAIN_NEED_CHANGE) {
 		/*
@@ -2460,7 +2498,7 @@ ath5k_calibrate(unsigned long data)
 	}
 	if (ath5k_hw_phy_calibrate(ah, sc-&gt;curchan))
 		ATH5K_ERR(sc, "calibration of channel %u failed\n",
-				sc-&gt;curchan-&gt;chan);
+				ieee80211_frequency_to_channel(sc-&gt;curchan-&gt;center_freq));
 
 	mod_timer(&amp;sc-&gt;calib_tim, round_jiffies(jiffies +
 			msecs_to_jiffies(ath5k_calinterval * 1000)));
@@ -2558,7 +2596,7 @@ ath5k_tx(struct ieee80211_hw *hw, struct sk_buff *skb,
 		memmove(skb-&gt;data, skb-&gt;data+pad, hdrlen);
 	}
 
-	sc-&gt;led_txrate = ctl-&gt;tx_rate;
+	sc-&gt;led_txrate = ctl-&gt;tx_rate-&gt;hw_value;
 
 	spin_lock_irqsave(&amp;sc-&gt;txbuflock, flags);
 	if (list_empty(&amp;sc-&gt;txbuf)) {
@@ -2597,11 +2635,6 @@ ath5k_reset(struct ieee80211_hw *hw)
 	int ret;
 
 	ATH5K_DBG(sc, ATH5K_DEBUG_RESET, "resetting\n");
-	/*
-	 * Convert to a hw channel description with the flags
-	 * constrained to reflect the current operating mode.
-	 */
-	sc-&gt;curchan = hw-&gt;conf.chan;
 
 	ath5k_hw_set_intr(ah, 0);
 	ath5k_txq_cleanup(sc);
@@ -2692,6 +2725,9 @@ ath5k_remove_interface(struct ieee80211_hw *hw,
 	mutex_unlock(&amp;sc-&gt;lock);
 }
 
+/*
+ * TODO: Phy disable/diversity etc
+ */
 static int
 ath5k_config(struct ieee80211_hw *hw,
 			struct ieee80211_conf *conf)
@@ -2699,9 +2735,9 @@ ath5k_config(struct ieee80211_hw *hw,
 	struct ath5k_softc *sc = hw-&gt;priv;
 
 	sc-&gt;bintval = conf-&gt;beacon_int;
-	ath5k_setcurmode(sc, conf-&gt;phymode);
+	sc-&gt;power_level = conf-&gt;power_level;
 
-	return ath5k_chan_set(sc, conf-&gt;chan);
+	return ath5k_chan_set(sc, conf-&gt;channel);
 }
 
 static int
diff --git a/drivers/net/wireless/ath5k/base.h b/drivers/net/wireless/ath5k/base.h
index 8287ae787f12..bbe7a5438154 100644
--- a/drivers/net/wireless/ath5k/base.h
+++ b/drivers/net/wireless/ath5k/base.h
@@ -83,7 +83,7 @@ struct ath5k_txq {
 #if CHAN_DEBUG
 #define ATH_CHAN_MAX	(26+26+26+200+200)
 #else
-#define ATH_CHAN_MAX	(14+14+14+252+20)	/* XXX what's the max? */
+#define ATH_CHAN_MAX	(14+14+14+252+20)
 #endif
 
 /* Software Carrier, keeps track of the driver state
@@ -95,12 +95,19 @@ struct ath5k_softc {
 	struct ieee80211_tx_queue_stats tx_stats;
 	struct ieee80211_low_level_stats ll_stats;
 	struct ieee80211_hw	*hw;		/* IEEE 802.11 common */
-	struct ieee80211_hw_mode modes[NUM_DRIVER_MODES];
+	struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
 	struct ieee80211_channel channels[ATH_CHAN_MAX];
-	struct ieee80211_rate	rates[AR5K_MAX_RATES * NUM_DRIVER_MODES];
+	struct ieee80211_rate	rates[AR5K_MAX_RATES * IEEE80211_NUM_BANDS];
 	enum ieee80211_if_types	opmode;
 	struct ath5k_hw		*ah;		/* Atheros HW */
 
+	struct ieee80211_supported_band		*curband;
+
+	u8			a_rates;
+	u8			b_rates;
+	u8			g_rates;
+	u8			xr_rates;
+
 #if ATH5K_DEBUG
 	struct ath5k_dbg_info	debug;		/* debug info */
 #endif
@@ -169,6 +176,7 @@ struct ath5k_softc {
 	unsigned int		nexttbtt;	/* next beacon time in TU */
 
 	struct timer_list	calib_tim;	/* calibration timer */
+	int 			power_level;	/* Requested tx power in dbm */
 };
 
 #define ath5k_hw_hasbssidmask(_ah) \
diff --git a/drivers/net/wireless/ath5k/hw.c b/drivers/net/wireless/ath5k/hw.c
index c2de2d958e8e..998da6be2be3 100644
--- a/drivers/net/wireless/ath5k/hw.c
+++ b/drivers/net/wireless/ath5k/hw.c
@@ -140,9 +140,6 @@ struct ath5k_hw *ath5k_hw_attach(struct ath5k_softc *sc, u8 mac_version)
 	 * HW information
 	 */
 
-	/* Get reg domain from eeprom */
-	ath5k_get_regdomain(ah);
-
 	ah-&gt;ah_op_mode = IEEE80211_IF_TYPE_STA;
 	ah-&gt;ah_radar.r_enabled = AR5K_TUNE_RADAR_ALERT;
 	ah-&gt;ah_turbo = false;
@@ -405,15 +402,15 @@ const struct ath5k_rate_table *ath5k_hw_get_rate_table(struct ath5k_hw *ah,
 
 	/* Get rate tables */
 	switch (mode) {
-	case MODE_IEEE80211A:
+	case AR5K_MODE_11A:
 		return &amp;ath5k_rt_11a;
-	case MODE_ATHEROS_TURBO:
+	case AR5K_MODE_11A_TURBO:
 		return &amp;ath5k_rt_turbo;
-	case MODE_IEEE80211B:
+	case AR5K_MODE_11B:
 		return &amp;ath5k_rt_11b;
-	case MODE_IEEE80211G:
+	case AR5K_MODE_11G:
 		return &amp;ath5k_rt_11g;
-	case MODE_ATHEROS_TURBOG:
+	case AR5K_MODE_11G_TURBO:
 		return &amp;ath5k_rt_xr;
 	}
 
@@ -457,15 +454,15 @@ static inline int ath5k_hw_write_ofdm_timings(struct ath5k_hw *ah,
 		ds_coef_exp, ds_coef_man, clock;
 
 	if (!(ah-&gt;ah_version == AR5K_AR5212) ||
-		!(channel-&gt;val &amp; CHANNEL_OFDM))
+		!(channel-&gt;hw_value &amp; CHANNEL_OFDM))
 		BUG();
 
 	/* Seems there are two PLLs, one for baseband sampling and one
 	 * for tuning. Tuning basebands are 40 MHz or 80MHz when in
 	 * turbo. */
-	clock = channel-&gt;val &amp; CHANNEL_TURBO ? 80 : 40;
+	clock = channel-&gt;hw_value &amp; CHANNEL_TURBO ? 80 : 40;
 	coef_scaled = ((5 * (clock &lt;&lt; 24)) / 2) /
-	channel-&gt;freq;
+	channel-&gt;center_freq;
 
 	for (coef_exp = 31; coef_exp &gt; 0; coef_exp--)
 		if ((coef_scaled &gt;&gt; coef_exp) &amp; 0x1)
@@ -492,8 +489,7 @@ static inline int ath5k_hw_write_ofdm_timings(struct ath5k_hw *ah,
  * ath5k_hw_write_rate_duration - set rate duration during hw resets
  *
  * @ah: the &amp;struct ath5k_hw
- * @driver_mode: one of enum ieee80211_phymode or our one of our own
- *     vendor modes
+ * @mode: one of enum ath5k_driver_mode
  *
  * Write the rate duration table for the current mode upon hw reset. This
  * is a helper for ath5k_hw_reset(). It seems all this is doing is setting
@@ -504,19 +500,20 @@ static inline int ath5k_hw_write_ofdm_timings(struct ath5k_hw *ah,
  *
  */
 static inline void ath5k_hw_write_rate_duration(struct ath5k_hw *ah,
-       unsigned int driver_mode)
+       unsigned int mode)
 {
 	struct ath5k_softc *sc = ah-&gt;ah_sc;
 	const struct ath5k_rate_table *rt;
+	struct ieee80211_rate srate = {};
 	unsigned int i;
 
 	/* Get rate table for the current operating mode */
-	rt = ath5k_hw_get_rate_table(ah,
-		driver_mode);
+	rt = ath5k_hw_get_rate_table(ah, mode);
 
 	/* Write rate duration table */
 	for (i = 0; i &lt; rt-&gt;rate_count; i++) {
 		const struct ath5k_rate *rate, *control_rate;
+
 		u32 reg;
 		u16 tx_time;
 
@@ -526,6 +523,8 @@ static inline void ath5k_hw_write_rate_duration(struct ath5k_hw *ah,
 		/* Set ACK timeout */
 		reg = AR5K_RATE_DUR(rate-&gt;rate_code);
 
+		srate.bitrate = control_rate-&gt;rate_kbps/100;
+
 		/* An ACK frame consists of 10 bytes. If you add the FCS,
 		 * which ieee80211_generic_frame_duration() adds,
 		 * its 14 bytes. Note we use the control rate and not the
@@ -533,7 +532,7 @@ static inline void ath5k_hw_write_rate_duration(struct ath5k_hw *ah,
 		 * ieee80211_duration() for a brief description of
 		 * what rate we should choose to TX ACKs. */
 		tx_time = ieee80211_generic_frame_duration(sc-&gt;hw,
-			sc-&gt;vif, 10, control_rate-&gt;rate_kbps/100);
+			sc-&gt;vif, 10, &amp;srate);
 
 		ath5k_hw_reg_write(ah, tx_time, reg);
 
@@ -567,7 +566,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 {
 	struct ath5k_eeprom_info *ee = &amp;ah-&gt;ah_capabilities.cap_eeprom;
 	u32 data, s_seq, s_ant, s_led[3];
-	unsigned int i, mode, freq, ee_mode, ant[2], driver_mode = -1;
+	unsigned int i, mode, freq, ee_mode, ant[2];
 	int ret;
 
 	ATH5K_TRACE(ah-&gt;ah_sc);
@@ -602,7 +601,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 
 
 	/*Wakeup the device*/
-	ret = ath5k_hw_nic_wakeup(ah, channel-&gt;val, false);
+	ret = ath5k_hw_nic_wakeup(ah, channel-&gt;hw_value, false);
 	if (ret)
 		return ret;
 
@@ -624,37 +623,32 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 			return -EINVAL;
 		}
 
-		switch (channel-&gt;val &amp; CHANNEL_MODES) {
+		switch (channel-&gt;hw_value &amp; CHANNEL_MODES) {
 		case CHANNEL_A:
-			mode = AR5K_INI_VAL_11A;
+			mode = AR5K_MODE_11A;
 			freq = AR5K_INI_RFGAIN_5GHZ;
 			ee_mode = AR5K_EEPROM_MODE_11A;
-			driver_mode = MODE_IEEE80211A;
 			break;
 		case CHANNEL_G:
-			mode = AR5K_INI_VAL_11G;
+			mode = AR5K_MODE_11G;
 			freq = AR5K_INI_RFGAIN_2GHZ;
 			ee_mode = AR5K_EEPROM_MODE_11G;
-			driver_mode = MODE_IEEE80211G;
 			break;
 		case CHANNEL_B:
-			mode = AR5K_INI_VAL_11B;
+			mode = AR5K_MODE_11B;
 			freq = AR5K_INI_RFGAIN_2GHZ;
 			ee_mode = AR5K_EEPROM_MODE_11B;
-			driver_mode = MODE_IEEE80211B;
 			break;
 		case CHANNEL_T:
-			mode = AR5K_INI_VAL_11A_TURBO;
+			mode = AR5K_MODE_11A_TURBO;
 			freq = AR5K_INI_RFGAIN_5GHZ;
 			ee_mode = AR5K_EEPROM_MODE_11A;
-			driver_mode = MODE_ATHEROS_TURBO;
 			break;
 		/*Is this ok on 5211 too ?*/
 		case CHANNEL_TG:
-			mode = AR5K_INI_VAL_11G_TURBO;
+			mode = AR5K_MODE_11G_TURBO;
 			freq = AR5K_INI_RFGAIN_2GHZ;
 			ee_mode = AR5K_EEPROM_MODE_11G;
-			driver_mode = MODE_ATHEROS_TURBOG;
 			break;
 		case CHANNEL_XR:
 			if (ah-&gt;ah_version == AR5K_AR5211) {
@@ -662,14 +656,13 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 					"XR mode not available on 5211");
 				return -EINVAL;
 			}
-			mode = AR5K_INI_VAL_XR;
+			mode = AR5K_MODE_XR;
 			freq = AR5K_INI_RFGAIN_5GHZ;
 			ee_mode = AR5K_EEPROM_MODE_11A;
-			driver_mode = MODE_IEEE80211A;
 			break;
 		default:
 			ATH5K_ERR(ah-&gt;ah_sc,
-				"invalid channel: %d\n", channel-&gt;freq);
+				"invalid channel: %d\n", channel-&gt;center_freq);
 			return -EINVAL;
 		}
 
@@ -702,7 +695,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 		if (ah-&gt;ah_version &gt; AR5K_AR5211){ /* found on 5213+ */
 			ath5k_hw_reg_write(ah, 0x0002a002, AR5K_PHY(11));
 
-			if (channel-&gt;val == CHANNEL_G)
+			if (channel-&gt;hw_value == CHANNEL_G)
 				ath5k_hw_reg_write(ah, 0x00f80d80, AR5K_PHY(83)); /* 0x00fc0ec0 */
 			else
 				ath5k_hw_reg_write(ah, 0x00000000, AR5K_PHY(83));
@@ -720,7 +713,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 				AR5K_SREV_RAD_5112A) {
 			ath5k_hw_reg_write(ah, AR5K_PHY_CCKTXCTL_WORLD,
 					AR5K_PHY_CCKTXCTL);
-			if (channel-&gt;val &amp; CHANNEL_5GHZ)
+			if (channel-&gt;hw_value &amp; CHANNEL_5GHZ)
 				data = 0xffb81020;
 			else
 				data = 0xffb80d20;
@@ -740,7 +733,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 		 * mac80211 are integrated */
 		if (ah-&gt;ah_version == AR5K_AR5212 &amp;&amp;
 			ah-&gt;ah_sc-&gt;vif != NULL)
-			ath5k_hw_write_rate_duration(ah, driver_mode);
+			ath5k_hw_write_rate_duration(ah, mode);
 
 		/*
 		 * Write RF registers
@@ -756,7 +749,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 
 		/* Write OFDM timings on 5212*/
 		if (ah-&gt;ah_version == AR5K_AR5212 &amp;&amp;
-			channel-&gt;val &amp; CHANNEL_OFDM) {
+			channel-&gt;hw_value &amp; CHANNEL_OFDM) {
 			ret = ath5k_hw_write_ofdm_timings(ah, channel);
 			if (ret)
 				return ret;
@@ -765,7 +758,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 		/*Enable/disable 802.11b mode on 5111
 		(enable 2111 frequency converter + CCK)*/
 		if (ah-&gt;ah_radio == AR5K_RF5111) {
-			if (driver_mode == MODE_IEEE80211B)
+			if (mode == AR5K_MODE_11B)
 				AR5K_REG_ENABLE_BITS(ah, AR5K_TXCFG,
 				    AR5K_TXCFG_B_MODE);
 			else
@@ -903,7 +896,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 	if (ah-&gt;ah_version != AR5K_AR5210) {
 		data = ath5k_hw_reg_read(ah, AR5K_PHY_RX_DELAY) &amp;
 			AR5K_PHY_RX_DELAY_M;
-		data = (channel-&gt;val &amp; CHANNEL_CCK) ?
+		data = (channel-&gt;hw_value &amp; CHANNEL_CCK) ?
 			((data &lt;&lt; 2) / 22) : (data / 10);
 
 		udelay(100 + data);
@@ -920,11 +913,11 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 	if (ath5k_hw_register_timeout(ah, AR5K_PHY_AGCCTL,
 			AR5K_PHY_AGCCTL_CAL, 0, false)) {
 		ATH5K_ERR(ah-&gt;ah_sc, "calibration timeout (%uMHz)\n",
-			channel-&gt;freq);
+			channel-&gt;center_freq);
 		return -EAGAIN;
 	}
 
-	ret = ath5k_hw_noise_floor_calibration(ah, channel-&gt;freq);
+	ret = ath5k_hw_noise_floor_calibration(ah, channel-&gt;center_freq);
 	if (ret)
 		return ret;
 
@@ -932,7 +925,7 @@ int ath5k_hw_reset(struct ath5k_hw *ah, enum ieee80211_if_types op_mode,
 
 	/* A and G modes can use QAM modulation which requires enabling
 	 * I and Q calibration. Don't bother in B mode. */
-	if (!(driver_mode == MODE_IEEE80211B)) {
+	if (!(mode == AR5K_MODE_11B)) {
 		ah-&gt;ah_calibration = true;
 		AR5K_REG_WRITE_BITS(ah, AR5K_PHY_IQ,
 				AR5K_PHY_IQ_CAL_NUM_LOG_MAX, 15);
@@ -1590,9 +1583,10 @@ static int ath5k_hw_eeprom_read(struct ath5k_hw *ah, u32 offset, u16 *data)
 /*
  * Write to eeprom - currently disabled, use at your own risk
  */
+#if 0
 static int ath5k_hw_eeprom_write(struct ath5k_hw *ah, u32 offset, u16 data)
 {
-#if 0
+
 	u32 status, timeout;
 
 	ATH5K_TRACE(ah-&gt;ah_sc);
@@ -1634,10 +1628,11 @@ static int ath5k_hw_eeprom_write(struct ath5k_hw *ah, u32 offset, u16 data)
 		}
 		udelay(15);
 	}
-#endif
+
 	ATH5K_ERR(ah-&gt;ah_sc, "EEPROM Write is disabled!");
 	return -EIO;
 }
+#endif
 
 /*
  * Translate binary channel representation in EEPROM to frequency
@@ -2042,50 +2037,6 @@ static int ath5k_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)
 	return 0;
 }
 
-/*
- * Read/Write regulatory domain
- */
-static bool ath5k_eeprom_regulation_domain(struct ath5k_hw *ah, bool write,
-	enum ath5k_regdom *regdomain)
-{
-	u16 ee_regdomain;
-
-	/* Read current value */
-	if (write != true) {
-		ee_regdomain = ah-&gt;ah_capabilities.cap_eeprom.ee_regdomain;
-		*regdomain = ath5k_regdom_to_ieee(ee_regdomain);
-		return true;
-	}
-
-	ee_regdomain = ath5k_regdom_from_ieee(*regdomain);
-
-	/* Try to write a new value */
-	if (ah-&gt;ah_capabilities.cap_eeprom.ee_protect &amp;
-			AR5K_EEPROM_PROTECT_WR_128_191)
-		return false;
-	if (ath5k_hw_eeprom_write(ah, AR5K_EEPROM_REG_DOMAIN, ee_regdomain)!=0)
-		return false;
-
-	ah-&gt;ah_capabilities.cap_eeprom.ee_regdomain = ee_regdomain;
-
-	return true;
-}
-
-/*
- * Use the above to write a new regulatory domain
- */
-int ath5k_hw_set_regdomain(struct ath5k_hw *ah, u16 regdomain)
-{
-	enum ath5k_regdom ieee_regdomain;
-
-	ieee_regdomain = ath5k_regdom_to_ieee(regdomain);
-
-	if (ath5k_eeprom_regulation_domain(ah, true, &amp;ieee_regdomain) == true)
-		return 0;
-
-	return -EIO;
-}
-
 /*
  * Fill the capabilities struct
  */
@@ -2108,8 +2059,8 @@ static int ath5k_hw_get_capabilities(struct ath5k_hw *ah)
 		ah-&gt;ah_capabilities.cap_range.range_2ghz_max = 0;
 
 		/* Set supported modes */
-		__set_bit(MODE_IEEE80211A, ah-&gt;ah_capabilities.cap_mode);
-		__set_bit(MODE_ATHEROS_TURBO, ah-&gt;ah_capabilities.cap_mode);
+		__set_bit(AR5K_MODE_11A, ah-&gt;ah_capabilities.cap_mode);
+		__set_bit(AR5K_MODE_11A_TURBO, ah-&gt;ah_capabilities.cap_mode);
 	} else {
 		/*
 		 * XXX The tranceiver supports frequencies from 4920 to 6100GHz
@@ -2131,12 +2082,12 @@ static int ath5k_hw_get_capabilities(struct ath5k_hw *ah)
 			ah-&gt;ah_capabilities.cap_range.range_5ghz_max = 6100;
 
 			/* Set supported modes */
-			__set_bit(MODE_IEEE80211A,
+			__set_bit(AR5K_MODE_11A,
 					ah-&gt;ah_capabilities.cap_mode);
-			__set_bit(MODE_ATHEROS_TURBO,
+			__set_bit(AR5K_MODE_11A_TURBO,
 					ah-&gt;ah_capabilities.cap_mode);
 			if (ah-&gt;ah_version == AR5K_AR5212)
-				__set_bit(MODE_ATHEROS_TURBOG,
+				__set_bit(AR5K_MODE_11G_TURBO,
 						ah-&gt;ah_capabilities.cap_mode);
 		}
 
@@ -2148,11 +2099,11 @@ static int ath5k_hw_get_capabilities(struct ath5k_hw *ah)
 			ah-&gt;ah_capabilities.cap_range.range_2ghz_max = 2732;
 
 			if (AR5K_EEPROM_HDR_11B(ee_header))
-				__set_bit(MODE_IEEE80211B,
+				__set_bit(AR5K_MODE_11B,
 						ah-&gt;ah_capabilities.cap_mode);
 
 			if (AR5K_EEPROM_HDR_11G(ee_header))
-				__set_bit(MODE_IEEE80211G,
+				__set_bit(AR5K_MODE_11G,
 						ah-&gt;ah_capabilities.cap_mode);
 		}
 	}
@@ -4248,35 +4199,6 @@ void ath5k_hw_set_gpio_intr(struct ath5k_hw *ah, unsigned int gpio,
 }
 
 
-/*********************************\
- Regulatory Domain/Channels Setup
-\*********************************/
-
-u16 ath5k_get_regdomain(struct ath5k_hw *ah)
-{
-	u16 regdomain;
-	enum ath5k_regdom ieee_regdomain;
-#ifdef COUNTRYCODE
-	u16 code;
-#endif
-
-	ath5k_eeprom_regulation_domain(ah, false, &amp;ieee_regdomain);
-	ah-&gt;ah_capabilities.cap_regdomain.reg_hw = ieee_regdomain;
-
-#ifdef COUNTRYCODE
-	/*
-	 * Get the regulation domain by country code. This will ignore
-	 * the settings found in the EEPROM.
-	 */
-	code = ieee80211_name2countrycode(COUNTRYCODE);
-	ieee_regdomain = ieee80211_countrycode2regdomain(code);
-#endif
-
-	regdomain = ath5k_regdom_from_ieee(ieee_regdomain);
-	ah-&gt;ah_capabilities.cap_regdomain.reg_current = regdomain;
-
-	return regdomain;
-}
 
 
 /****************\
diff --git a/drivers/net/wireless/ath5k/initvals.c b/drivers/net/wireless/ath5k/initvals.c
index 2c22f1d4ee64..a255d8bfa949 100644
--- a/drivers/net/wireless/ath5k/initvals.c
+++ b/drivers/net/wireless/ath5k/initvals.c
@@ -1317,7 +1317,7 @@ int ath5k_hw_write_initvals(struct ath5k_hw *ah, u8 mode, bool change_channel)
 	/* For AR5211 */
 	} else if (ah-&gt;ah_version == AR5K_AR5211) {
 
-		if(mode &gt; 2){ /* AR5K_INI_VAL_11B */
+		if(mode &gt; 2){ /* AR5K_MODE_11B */
 			ATH5K_ERR(ah-&gt;ah_sc,"unsupported channel mode: %d\n", mode);
 			return -EINVAL;
 		}
diff --git a/drivers/net/wireless/ath5k/phy.c b/drivers/net/wireless/ath5k/phy.c
index b95941797141..8b576b314cf5 100644
--- a/drivers/net/wireless/ath5k/phy.c
+++ b/drivers/net/wireless/ath5k/phy.c
@@ -1018,7 +1018,7 @@ static int ath5k_hw_rf5111_rfregs(struct ath5k_hw *ah,
 	int obdb = -1, bank = -1;
 	u32 ee_mode;
 
-	AR5K_ASSERT_ENTRY(mode, AR5K_INI_VAL_MAX);
+	AR5K_ASSERT_ENTRY(mode, AR5K_MODE_MAX);
 
 	rf = ah-&gt;ah_rf_banks;
 
@@ -1038,8 +1038,8 @@ static int ath5k_hw_rf5111_rfregs(struct ath5k_hw *ah,
 	}
 
 	/* Modify bank 0 */
-	if (channel-&gt;val &amp; CHANNEL_2GHZ) {
-		if (channel-&gt;val &amp; CHANNEL_CCK)
+	if (channel-&gt;hw_value &amp; CHANNEL_2GHZ) {
+		if (channel-&gt;hw_value &amp; CHANNEL_CCK)
 			ee_mode = AR5K_EEPROM_MODE_11B;
 		else
 			ee_mode = AR5K_EEPROM_MODE_11G;
@@ -1058,10 +1058,10 @@ static int ath5k_hw_rf5111_rfregs(struct ath5k_hw *ah,
 	} else {
 		/* For 11a, Turbo and XR */
 		ee_mode = AR5K_EEPROM_MODE_11A;
-		obdb =	 channel-&gt;freq &gt;= 5725 ? 3 :
-			(channel-&gt;freq &gt;= 5500 ? 2 :
-			(channel-&gt;freq &gt;= 5260 ? 1 :
-			 (channel-&gt;freq &gt; 4000 ? 0 : -1)));
+		obdb =	 channel-&gt;center_freq &gt;= 5725 ? 3 :
+			(channel-&gt;center_freq &gt;= 5500 ? 2 :
+			(channel-&gt;center_freq &gt;= 5260 ? 1 :
+			 (channel-&gt;center_freq &gt; 4000 ? 0 : -1)));
 
 		if (!ath5k_hw_rfregs_op(rf, ah-&gt;ah_offset[6],
 				ee-&gt;ee_pwd_84, 1, 51, 3, true))
@@ -1119,12 +1119,12 @@ static int ath5k_hw_rf5112_rfregs(struct ath5k_hw *ah,
 	int obdb = -1, bank = -1;
 	u32 ee_mode;
 
-	AR5K_ASSERT_ENTRY(mode, AR5K_INI_VAL_MAX);
+	AR5K_ASSERT_ENTRY(mode, AR5K_MODE_MAX);
 
 	rf = ah-&gt;ah_rf_banks;
 
 	if (ah-&gt;ah_radio_5ghz_revision &gt;= AR5K_SREV_RAD_2112A
-		&amp;&amp; !test_bit(MODE_IEEE80211A, ah-&gt;ah_capabilities.cap_mode)){
+		&amp;&amp; !test_bit(AR5K_MODE_11A, ah-&gt;ah_capabilities.cap_mode)){
 		rf_ini = rfregs_2112a;
 		rf_size = ARRAY_SIZE(rfregs_5112a);
 		if (mode &lt; 2) {
@@ -1156,8 +1156,8 @@ static int ath5k_hw_rf5112_rfregs(struct ath5k_hw *ah,
 	}
 
 	/* Modify bank 6 */
-	if (channel-&gt;val &amp; CHANNEL_2GHZ) {
-		if (channel-&gt;val &amp; CHANNEL_OFDM)
+	if (channel-&gt;hw_value &amp; CHANNEL_2GHZ) {
+		if (channel-&gt;hw_value &amp; CHANNEL_OFDM)
 			ee_mode = AR5K_EEPROM_MODE_11G;
 		else
 			ee_mode = AR5K_EEPROM_MODE_11B;
@@ -1173,10 +1173,10 @@ static int ath5k_hw_rf5112_rfregs(struct ath5k_hw *ah,
 	} else {
 		/* For 11a, Turbo and XR */
 		ee_mode = AR5K_EEPROM_MODE_11A;
-		obdb = channel-&gt;freq &gt;= 5725 ? 3 :
-		    (channel-&gt;freq &gt;= 5500 ? 2 :
-			(channel-&gt;freq &gt;= 5260 ? 1 :
-			    (channel-&gt;freq &gt; 4000 ? 0 : -1)));
+		obdb = channel-&gt;center_freq &gt;= 5725 ? 3 :
+		    (channel-&gt;center_freq &gt;= 5500 ? 2 :
+			(channel-&gt;center_freq &gt;= 5260 ? 1 :
+			    (channel-&gt;center_freq &gt; 4000 ? 0 : -1)));
 
 		if (!ath5k_hw_rfregs_op(rf, ah-&gt;ah_offset[6],
 				ee-&gt;ee_ob[ee_mode][obdb], 3, 279, 0, true))
@@ -1219,7 +1219,7 @@ static int ath5k_hw_rf5413_rfregs(struct ath5k_hw *ah,
 	unsigned int rf_size, i;
 	int bank = -1;
 
-	AR5K_ASSERT_ENTRY(mode, AR5K_INI_VAL_MAX);
+	AR5K_ASSERT_ENTRY(mode, AR5K_MODE_MAX);
 
 	rf = ah-&gt;ah_rf_banks;
 
@@ -1445,7 +1445,7 @@ static u32 ath5k_hw_rf5110_chan2athchan(struct ieee80211_channel *channel)
 	 * newer chipsets like the AR5212A who have a completely
 	 * different RF/PHY part.
 	 */
-	athchan = (ath5k_hw_bitswap((channel-&gt;chan - 24) / 2, 5) &lt;&lt; 1) |
+	athchan = (ath5k_hw_bitswap((ieee80211_frequency_to_channel(channel-&gt;center_freq) - 24) / 2, 5) &lt;&lt; 1) |
 		(1 &lt;&lt; 6) | 0x1;
 
 	return athchan;
@@ -1506,7 +1506,7 @@ static int ath5k_hw_rf5111_channel(struct ath5k_hw *ah,
 		struct ieee80211_channel *channel)
 {
 	struct ath5k_athchan_2ghz ath5k_channel_2ghz;
-	unsigned int ath5k_channel = channel-&gt;chan;
+	unsigned int ath5k_channel = ieee80211_frequency_to_channel(channel-&gt;center_freq);
 	u32 data0, data1, clock;
 	int ret;
 
@@ -1515,9 +1515,9 @@ static int ath5k_hw_rf5111_channel(struct ath5k_hw *ah,
 	 */
 	data0 = data1 = 0;
 
-	if (channel-&gt;val &amp; CHANNEL_2GHZ) {
+	if (channel-&gt;hw_value &amp; CHANNEL_2GHZ) {
 		/* Map 2GHz channel to 5GHz Atheros channel ID */
-		ret = ath5k_hw_rf5111_chan2athchan(channel-&gt;chan,
+		ret = ath5k_hw_rf5111_chan2athchan(ieee80211_frequency_to_channel(channel-&gt;center_freq),
 				&amp;ath5k_channel_2ghz);
 		if (ret)
 			return ret;
@@ -1555,7 +1555,7 @@ static int ath5k_hw_rf5112_channel(struct ath5k_hw *ah,
 	u16 c;
 
 	data = data0 = data1 = data2 = 0;
-	c = channel-&gt;freq;
+	c = channel-&gt;center_freq;
 
 	/*
 	 * Set the channel on the RF5112 or newer
@@ -1604,13 +1604,13 @@ int ath5k_hw_channel(struct ath5k_hw *ah, struct ieee80211_channel *channel)
 	 * Check bounds supported by the PHY
 	 * (don't care about regulation restrictions at this point)
 	 */
-	if ((channel-&gt;freq &lt; ah-&gt;ah_capabilities.cap_range.range_2ghz_min ||
-	    channel-&gt;freq &gt; ah-&gt;ah_capabilities.cap_range.range_2ghz_max) &amp;&amp;
-	    (channel-&gt;freq &lt; ah-&gt;ah_capabilities.cap_range.range_5ghz_min ||
-	    channel-&gt;freq &gt; ah-&gt;ah_capabilities.cap_range.range_5ghz_max)) {
+	if ((channel-&gt;center_freq &lt; ah-&gt;ah_capabilities.cap_range.range_2ghz_min ||
+	    channel-&gt;center_freq &gt; ah-&gt;ah_capabilities.cap_range.range_2ghz_max) &amp;&amp;
+	    (channel-&gt;center_freq &lt; ah-&gt;ah_capabilities.cap_range.range_5ghz_min ||
+	    channel-&gt;center_freq &gt; ah-&gt;ah_capabilities.cap_range.range_5ghz_max)) {
 		ATH5K_ERR(ah-&gt;ah_sc,
 			"channel out of supported range (%u MHz)\n",
-			channel-&gt;freq);
+			channel-&gt;center_freq);
 		return -EINVAL;
 	}
 
@@ -1632,9 +1632,9 @@ int ath5k_hw_channel(struct ath5k_hw *ah, struct ieee80211_channel *channel)
 	if (ret)
 		return ret;
 
-	ah-&gt;ah_current_channel.freq = channel-&gt;freq;
-	ah-&gt;ah_current_channel.val = channel-&gt;val;
-	ah-&gt;ah_turbo = channel-&gt;val == CHANNEL_T ? true : false;
+	ah-&gt;ah_current_channel.center_freq = channel-&gt;center_freq;
+	ah-&gt;ah_current_channel.hw_value = channel-&gt;hw_value;
+	ah-&gt;ah_turbo = channel-&gt;hw_value == CHANNEL_T ? true : false;
 
 	return 0;
 }
@@ -1797,11 +1797,11 @@ static int ath5k_hw_rf5110_calibrate(struct ath5k_hw *ah,
 
 	if (ret) {
 		ATH5K_ERR(ah-&gt;ah_sc, "calibration timeout (%uMHz)\n",
-				channel-&gt;freq);
+				channel-&gt;center_freq);
 		return ret;
 	}
 
-	ret = ath5k_hw_noise_floor_calibration(ah, channel-&gt;freq);
+	ret = ath5k_hw_noise_floor_calibration(ah, channel-&gt;center_freq);
 	if (ret)
 		return ret;
 
@@ -1848,10 +1848,10 @@ static int ath5k_hw_rf511x_calibrate(struct ath5k_hw *ah,
 		((u32)q_coff) | ((u32)i_coff &lt;&lt; AR5K_PHY_IQ_CORR_Q_I_COFF_S));
 
 done:
-	ath5k_hw_noise_floor_calibration(ah, channel-&gt;freq);
+	ath5k_hw_noise_floor_calibration(ah, channel-&gt;center_freq);
 
 	/* Request RF gain */
-	if (channel-&gt;val &amp; CHANNEL_5GHZ) {
+	if (channel-&gt;hw_value &amp; CHANNEL_5GHZ) {
 		ath5k_hw_reg_write(ah, AR5K_REG_SM(ah-&gt;ah_txpower.txp_max,
 			AR5K_PHY_PAPD_PROBE_TXPOWER) |
 			AR5K_PHY_PAPD_PROBE_TX_NEXT, AR5K_PHY_PAPD_PROBE);</pre>
    <div class="pagination">
        <a href='38.html'>&lt;&lt;Prev</a><a href='38.html'>1</a><span>[2]</span>
    <div>
</body>
