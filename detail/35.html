<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Rochester Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Rochester Institute of Technology</h1>
    <div class="pagination">
        <span>[1]</span><a href='35_2.html'>2</a><a href='35_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit bd8d725078867cda250fe94b9c5a067b4a64ca74
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Fri Oct 5 09:32:08 2018 -0400

    nfsd: correctly decrement odstate refcount in error path
    
    alloc_init_deleg() both allocates an nfs4_delegation, and
    bumps the refcount on odstate. So after this point, we need to
    put_clnt_odstate() and nfs4_put_stid() to not leave the odstate
    refcount inappropriately bumped.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Reviewed-by: Jeff Layton &lt;jlayton@kernel.org&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 07a57d024f95..f093fbe47133 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -4398,7 +4398,7 @@ nfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,
 
 	fl = nfs4_alloc_init_lease(dp, NFS4_OPEN_DELEGATE_READ);
 	if (!fl)
-		goto out_stid;
+		goto out_clnt_odstate;
 
 	status = vfs_setlease(fp-&gt;fi_deleg_file, fl-&gt;fl_type, &amp;fl, NULL);
 	if (fl)
@@ -4423,7 +4423,6 @@ nfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,
 	vfs_setlease(fp-&gt;fi_deleg_file, F_UNLCK, NULL, (void **)&amp;dp);
 out_clnt_odstate:
 	put_clnt_odstate(dp-&gt;dl_clnt_odstate);
-out_stid:
 	nfs4_put_stid(&amp;dp-&gt;dl_stid);
 out_delegees:
 	put_deleg_file(fp);</pre><hr><pre>commit 692ad280bff3e81721ab138b9455948ab5289acf
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Apr 18 17:04:37 2018 -0400

    nfsd: fix error handling in nfs4_set_delegation()
    
    I noticed a memory corruption crash in nfsd in
    4.17-rc1. This patch corrects the issue.
    
    Fix to return error if the delegation couldn't be hashed or there was
    a recall in progress. Use the existing error path instead of
    destroy_delegation() for readability.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Fixes: 353601e7d323c ("nfsd: create a separate lease for each delegation")
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index fc74d6f46bd5..3b40d1b57613 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -4378,8 +4378,11 @@ nfs4_set_delegation(struct nfs4_client *clp, struct svc_fh *fh,
 	spin_unlock(&amp;state_lock);
 
 	if (status)
-		destroy_unhashed_deleg(dp);
+		goto out_unlock;
+
 	return dp;
+out_unlock:
+	vfs_setlease(fp-&gt;fi_deleg_file, F_UNLCK, NULL, (void **)&amp;dp);
 out_clnt_odstate:
 	put_clnt_odstate(dp-&gt;dl_clnt_odstate);
 out_stid:</pre><hr><pre>commit ae254dac721d44c0bfebe2795df87459e2e88219
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Thu Nov 9 13:41:10 2017 -0500

    nfsd: check for use of the closed special stateid
    
    Prevent the use of the closed (invalid) special stateid by clients.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index d0992d59f4e1..73451436c1c2 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -72,6 +72,7 @@ static u64 current_sessionid = 1;
 #define ZERO_STATEID(stateid) (!memcmp((stateid), &amp;zero_stateid, sizeof(stateid_t)))
 #define ONE_STATEID(stateid)  (!memcmp((stateid), &amp;one_stateid, sizeof(stateid_t)))
 #define CURRENT_STATEID(stateid) (!memcmp((stateid), &amp;currentstateid, sizeof(stateid_t)))
+#define CLOSE_STATEID(stateid)  (!memcmp((stateid), &amp;close_stateid, sizeof(stateid_t)))
 
 /* forward declarations */
 static bool check_for_locks(struct nfs4_file *fp, struct nfs4_lockowner *lowner);
@@ -4936,7 +4937,8 @@ static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)
 	struct nfs4_stid *s;
 	__be32 status = nfserr_bad_stateid;
 
-	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
+	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid) ||
+		CLOSE_STATEID(stateid))
 		return status;
 	/* Client debugging aid. */
 	if (!same_clid(&amp;stateid-&gt;si_opaque.so_clid, &amp;cl-&gt;cl_clientid)) {
@@ -4994,7 +4996,8 @@ nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,
 	else if (typemask &amp; NFS4_DELEG_STID)
 		typemask |= NFS4_REVOKED_DELEG_STID;
 
-	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
+	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid) ||
+		CLOSE_STATEID(stateid))
 		return nfserr_bad_stateid;
 	status = lookup_clientid(&amp;stateid-&gt;si_opaque.so_clid, cstate, nn);
 	if (status == nfserr_stale_clientid) {</pre><hr><pre>commit 4f34bd0540d290d1fe1bc699550025623b2761ef
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Nov 8 17:29:51 2017 -0500

    nfsd: fix locking validator warning on nfs4_ol_stateid-&gt;st_mutex class
    
    The use of the st_mutex has been confusing the validator. Use the
    proper nested notation so as to not produce warnings.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index ecb803d7c966..98342d262771 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -86,6 +86,11 @@ static void nfs4_free_ol_stateid(struct nfs4_stid *stid);
  */
 static DEFINE_SPINLOCK(state_lock);
 
+enum nfsd4_st_mutex_lock_subclass {
+	OPEN_STATEID_MUTEX = 0,
+	LOCK_STATEID_MUTEX = 1,
+};
+
 /*
  * A waitqueue for all in-progress 4.0 CLOSE operations that are waiting for
  * the refcount on the open stateid to drop.
@@ -3600,7 +3605,7 @@ nfsd4_lock_ol_stateid(struct nfs4_ol_stateid *stp)
 {
 	__be32 ret;
 
-	mutex_lock(&amp;stp-&gt;st_mutex);
+	mutex_lock_nested(&amp;stp-&gt;st_mutex, LOCK_STATEID_MUTEX);
 	ret = nfsd4_verify_open_stid(&amp;stp-&gt;st_stid);
 	if (ret != nfs_ok)
 		mutex_unlock(&amp;stp-&gt;st_mutex);
@@ -3664,7 +3669,7 @@ init_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)
 	stp = open-&gt;op_stp;
 	/* We are moving these outside of the spinlocks to avoid the warnings */
 	mutex_init(&amp;stp-&gt;st_mutex);
-	mutex_lock(&amp;stp-&gt;st_mutex);
+	mutex_lock_nested(&amp;stp-&gt;st_mutex, OPEN_STATEID_MUTEX);
 
 retry:
 	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
@@ -5741,7 +5746,7 @@ init_lock_stateid(struct nfs4_ol_stateid *stp, struct nfs4_lockowner *lo,
 	struct nfs4_ol_stateid *retstp;
 
 	mutex_init(&amp;stp-&gt;st_mutex);
-	mutex_lock(&amp;stp-&gt;st_mutex);
+	mutex_lock_nested(&amp;stp-&gt;st_mutex, OPEN_STATEID_MUTEX);
 retry:
 	spin_lock(&amp;clp-&gt;cl_lock);
 	spin_lock(&amp;fp-&gt;fi_lock);</pre><hr><pre>commit 95da1b3a5aded124dd1bda1e3cdb876184813140
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Fri Nov 3 14:06:31 2017 -0400

    nfsd: deal with revoked delegations appropriately
    
    If a delegation has been revoked by the server, operations using that
    delegation should error out with NFS4ERR_DELEG_REVOKED in the &gt;4.1
    case, and NFS4ERR_BAD_STATEID otherwise.
    
    The server needs NFSv4.1 clients to explicitly free revoked delegations.
    If the server returns NFS4ERR_DELEG_REVOKED, the client will do that;
    otherwise it may just forget about the delegation and be unable to
    recover when it later sees SEQ4_STATUS_RECALLABLE_STATE_REVOKED set on a
    SEQUENCE reply.  That can cause the Linux 4.1 client to loop in its
    stage manager.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Reviewed-by: Trond Myklebust &lt;trond.myklebust@primarydata.com&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index ecbc7b0dfa4d..b82817767b9d 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -4016,7 +4016,8 @@ static struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, statei
 {
 	struct nfs4_stid *ret;
 
-	ret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);
+	ret = find_stateid_by_type(cl, s,
+				NFS4_DELEG_STID|NFS4_REVOKED_DELEG_STID);
 	if (!ret)
 		return NULL;
 	return delegstateid(ret);
@@ -4039,6 +4040,12 @@ nfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,
 	deleg = find_deleg_stateid(cl, &amp;open-&gt;op_delegate_stateid);
 	if (deleg == NULL)
 		goto out;
+	if (deleg-&gt;dl_stid.sc_type == NFS4_REVOKED_DELEG_STID) {
+		nfs4_put_stid(&amp;deleg-&gt;dl_stid);
+		if (cl-&gt;cl_minorversion)
+			status = nfserr_deleg_revoked;
+		goto out;
+	}
 	flags = share_access_to_flags(open-&gt;op_share_access);
 	status = nfs4_check_delegmode(deleg, flags);
 	if (status) {
@@ -4908,6 +4915,16 @@ nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,
 		     struct nfs4_stid **s, struct nfsd_net *nn)
 {
 	__be32 status;
+	bool return_revoked = false;
+
+	/*
+	 *  only return revoked delegations if explicitly asked.
+	 *  otherwise we report revoked or bad_stateid status.
+	 */
+	if (typemask &amp; NFS4_REVOKED_DELEG_STID)
+		return_revoked = true;
+	else if (typemask &amp; NFS4_DELEG_STID)
+		typemask |= NFS4_REVOKED_DELEG_STID;
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
 		return nfserr_bad_stateid;
@@ -4922,6 +4939,12 @@ nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,
 	*s = find_stateid_by_type(cstate-&gt;clp, stateid, typemask);
 	if (!*s)
 		return nfserr_bad_stateid;
+	if (((*s)-&gt;sc_type == NFS4_REVOKED_DELEG_STID) &amp;&amp; !return_revoked) {
+		nfs4_put_stid(*s);
+		if (cstate-&gt;minorversion)
+			return nfserr_deleg_revoked;
+		return nfserr_bad_stateid;
+	}
 	return nfs_ok;
 }
 </pre><hr><pre>commit ed94164398c935a42be7b129a478eb19c598b68a
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Jun 15 12:52:09 2016 -0400

    nfsd: implement machine credential support for some operations
    
    This addresses the conundrum referenced in RFC5661 18.35.3,
    and will allow clients to return state to the server using the
    machine credentials.
    
    The biggest part of the problem is that we need to allow the client
    to send a compound op with integrity/privacy on mounts that don't
    have it enabled.
    
    Add server support for properly decoding and using spo_must_enforce
    and spo_must_allow bits. Add support for machine credentials to be
    used for CLOSE, OPEN_DOWNGRADE, LOCKU, DELEGRETURN,
    and TEST/FREE STATEID.
    Implement a check so as to not throw WRONGSEC errors when these
    operations are used if integrity/privacy isn't turned on.
    
    Without this, Linux clients with credentials that expired while holding
    delegations were getting stuck in an endless loop.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Reviewed-by: Jeff Layton &lt;jlayton@redhat.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index b4d84b579f20..79de2f38dd63 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -954,6 +954,16 @@ __be32 check_nfsd_access(struct svc_export *exp, struct svc_rqst *rqstp)
 		    rqstp-&gt;rq_cred.cr_flavor == RPC_AUTH_UNIX)
 			return 0;
 	}
+
+	/* If the compound op contains a spo_must_allowed op,
+	 * it will be sent with integrity/protection which
+	 * will have to be expressly allowed on mounts that
+	 * don't support it
+	 */
+
+	if (nfsd4_spo_must_allow(rqstp))
+		return 0;
+
 	return nfserr_wrongsec;
 }
 
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index de1ff1d98bb1..b1159b3e9816 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -2335,6 +2335,45 @@ static struct nfsd4_operation nfsd4_ops[] = {
 	},
 };
 
+/**
+ * nfsd4_spo_must_allow - Determine if the compound op contains an
+ * operation that is allowed to be sent with machine credentials
+ *
+ * @rqstp: a pointer to the struct svc_rqst
+ *
+ * Checks to see if the compound contains a spo_must_allow op
+ * and confirms that it was sent with the proper machine creds.
+ */
+
+bool nfsd4_spo_must_allow(struct svc_rqst *rqstp)
+{
+	struct nfsd4_compoundres *resp = rqstp-&gt;rq_resp;
+	struct nfsd4_compoundargs *argp = rqstp-&gt;rq_argp;
+	struct nfsd4_op *this = &amp;argp-&gt;ops[resp-&gt;opcnt - 1];
+	struct nfsd4_compound_state *cstate = &amp;resp-&gt;cstate;
+	struct nfs4_op_map *allow = &amp;cstate-&gt;clp-&gt;cl_spo_must_allow;
+	u32 opiter;
+
+	if (!cstate-&gt;minorversion)
+		return false;
+
+	if (cstate-&gt;spo_must_allowed == true)
+		return true;
+
+	opiter = resp-&gt;opcnt;
+	while (opiter &lt; argp-&gt;opcnt) {
+		this = &amp;argp-&gt;ops[opiter++];
+		if (test_bit(this-&gt;opnum, allow-&gt;u.longs) &amp;&amp;
+			cstate-&gt;clp-&gt;cl_mach_cred &amp;&amp;
+			nfsd4_mach_creds_match(cstate-&gt;clp, rqstp)) {
+			cstate-&gt;spo_must_allowed = true;
+			return true;
+		}
+	}
+	cstate-&gt;spo_must_allowed = false;
+	return false;
+}
+
 int nfsd4_max_reply(struct svc_rqst *rqstp, struct nfsd4_op *op)
 {
 	struct nfsd4_operation *opdesc;
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index ef583507d276..ebfcebd5eab1 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2388,6 +2388,22 @@ nfsd4_exchange_id(struct svc_rqst *rqstp,
 
 	switch (exid-&gt;spa_how) {
 	case SP4_MACH_CRED:
+		exid-&gt;spo_must_enforce[0] = 0;
+		exid-&gt;spo_must_enforce[1] = (
+			1 &lt;&lt; (OP_BIND_CONN_TO_SESSION - 32) |
+			1 &lt;&lt; (OP_EXCHANGE_ID - 32) |
+			1 &lt;&lt; (OP_CREATE_SESSION - 32) |
+			1 &lt;&lt; (OP_DESTROY_SESSION - 32) |
+			1 &lt;&lt; (OP_DESTROY_CLIENTID - 32));
+
+		exid-&gt;spo_must_allow[0] &amp;= (1 &lt;&lt; (OP_CLOSE) |
+					1 &lt;&lt; (OP_OPEN_DOWNGRADE) |
+					1 &lt;&lt; (OP_LOCKU) |
+					1 &lt;&lt; (OP_DELEGRETURN));
+
+		exid-&gt;spo_must_allow[1] &amp;= (
+					1 &lt;&lt; (OP_TEST_STATEID - 32) |
+					1 &lt;&lt; (OP_FREE_STATEID - 32));
 		if (!svc_rqst_integrity_protected(rqstp)) {
 			status = nfserr_inval;
 			goto out_nolock;
@@ -2473,6 +2489,8 @@ nfsd4_exchange_id(struct svc_rqst *rqstp,
 			goto out;
 	}
 	new-&gt;cl_minorversion = cstate-&gt;minorversion;
+	new-&gt;cl_spo_must_allow.u.words[0] = exid-&gt;spo_must_allow[0];
+	new-&gt;cl_spo_must_allow.u.words[1] = exid-&gt;spo_must_allow[1];
 
 	gen_clid(new, nn);
 	add_to_unconfirmed(new);
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 9df898ba648f..84ef94794496 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1299,16 +1299,14 @@ nfsd4_decode_exchange_id(struct nfsd4_compoundargs *argp,
 		break;
 	case SP4_MACH_CRED:
 		/* spo_must_enforce */
-		READ_BUF(4);
-		dummy = be32_to_cpup(p++);
-		READ_BUF(dummy * 4);
-		p += dummy;
-
+		status = nfsd4_decode_bitmap(argp,
+					exid-&gt;spo_must_enforce);
+		if (status)
+			goto out;
 		/* spo_must_allow */
-		READ_BUF(4);
-		dummy = be32_to_cpup(p++);
-		READ_BUF(dummy * 4);
-		p += dummy;
+		status = nfsd4_decode_bitmap(argp, exid-&gt;spo_must_allow);
+		if (status)
+			goto out;
 		break;
 	case SP4_SSV:
 		/* ssp_ops */
@@ -3867,14 +3865,6 @@ nfsd4_encode_write(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_w
 	return nfserr;
 }
 
-static const u32 nfs4_minimal_spo_must_enforce[2] = {
-	[1] = 1 &lt;&lt; (OP_BIND_CONN_TO_SESSION - 32) |
-	      1 &lt;&lt; (OP_EXCHANGE_ID - 32) |
-	      1 &lt;&lt; (OP_CREATE_SESSION - 32) |
-	      1 &lt;&lt; (OP_DESTROY_SESSION - 32) |
-	      1 &lt;&lt; (OP_DESTROY_CLIENTID - 32)
-};
-
 static __be32
 nfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,
 			 struct nfsd4_exchange_id *exid)
@@ -3885,6 +3875,7 @@ nfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,
 	char *server_scope;
 	int major_id_sz;
 	int server_scope_sz;
+	int status = 0;
 	uint64_t minor_id = 0;
 
 	if (nfserr)
@@ -3913,18 +3904,20 @@ nfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,
 	case SP4_NONE:
 		break;
 	case SP4_MACH_CRED:
-		/* spo_must_enforce, spo_must_allow */
-		p = xdr_reserve_space(xdr, 16);
-		if (!p)
-			return nfserr_resource;
-
 		/* spo_must_enforce bitmap: */
-		*p++ = cpu_to_be32(2);
-		*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[0]);
-		*p++ = cpu_to_be32(nfs4_minimal_spo_must_enforce[1]);
-		/* empty spo_must_allow bitmap: */
-		*p++ = cpu_to_be32(0);
-
+		status = nfsd4_encode_bitmap(xdr,
+					exid-&gt;spo_must_enforce[0],
+					exid-&gt;spo_must_enforce[1],
+					exid-&gt;spo_must_enforce[2]);
+		if (status)
+			goto out;
+		/* spo_must_allow bitmap: */
+		status = nfsd4_encode_bitmap(xdr,
+					exid-&gt;spo_must_allow[0],
+					exid-&gt;spo_must_allow[1],
+					exid-&gt;spo_must_allow[2]);
+		if (status)
+			goto out;
 		break;
 	default:
 		WARN_ON_ONCE(1);
@@ -3951,6 +3944,8 @@ nfsd4_encode_exchange_id(struct nfsd4_compoundres *resp, __be32 nfserr,
 	/* Implementation id */
 	*p++ = cpu_to_be32(0);	/* zero length nfs_impl_id4 array */
 	return 0;
+out:
+	return status;
 }
 
 static __be32
diff --git a/fs/nfsd/nfsd.h b/fs/nfsd/nfsd.h
index cf980523898b..9446849888d5 100644
--- a/fs/nfsd/nfsd.h
+++ b/fs/nfsd/nfsd.h
@@ -124,6 +124,7 @@ void nfs4_state_shutdown_net(struct net *net);
 void nfs4_reset_lease(time_t leasetime);
 int nfs4_reset_recoverydir(char *recdir);
 char * nfs4_recoverydir(void);
+bool nfsd4_spo_must_allow(struct svc_rqst *rqstp);
 #else
 static inline int nfsd4_init_slabs(void) { return 0; }
 static inline void nfsd4_free_slabs(void) { }
@@ -134,6 +135,10 @@ static inline void nfs4_state_shutdown_net(struct net *net) { }
 static inline void nfs4_reset_lease(time_t leasetime) { }
 static inline int nfs4_reset_recoverydir(char *recdir) { return 0; }
 static inline char * nfs4_recoverydir(void) {return NULL; }
+static inline bool nfsd4_spo_must_allow(struct svc_rqst *rqstp)
+{
+	return false;
+}
 #endif
 
 /*
diff --git a/fs/nfsd/state.h b/fs/nfsd/state.h
index 64053eadeb81..b95adf9a1595 100644
--- a/fs/nfsd/state.h
+++ b/fs/nfsd/state.h
@@ -345,6 +345,7 @@ struct nfs4_client {
 	u32			cl_exchange_flags;
 	/* number of rpc's in progress over an associated session: */
 	atomic_t		cl_refcount;
+	struct nfs4_op_map      cl_spo_must_allow;
 
 	/* for nfs41 callbacks */
 	/* We currently support a single back channel with a single slot */
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index 74342a7c208a..beea0c5edc51 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -59,6 +59,7 @@ struct nfsd4_compound_state {
 	struct nfsd4_session	*session;
 	struct nfsd4_slot	*slot;
 	int			data_offset;
+	bool                    spo_must_allowed;
 	size_t			iovlen;
 	u32			minorversion;
 	__be32			status;
@@ -403,6 +404,8 @@ struct nfsd4_exchange_id {
 	clientid_t	clientid;
 	u32		seqid;
 	int		spa_how;
+	u32             spo_must_enforce[3];
+	u32             spo_must_allow[3];
 };
 
 struct nfsd4_sequence {</pre><hr><pre>commit dedeb13f9efb4439a37cf56317c8f25860dd667b
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Jun 15 12:52:08 2016 -0400

    nfsd: allow mach_creds_match to be used more broadly
    
    Rename mach_creds_match() to nfsd4_mach_creds_match() and un-staticify
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Reviewed-by: Jeff Layton &lt;jlayton@redhat.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 70d0b9b33031..ef583507d276 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1972,7 +1972,7 @@ static bool svc_rqst_integrity_protected(struct svc_rqst *rqstp)
 	       service == RPC_GSS_SVC_PRIVACY;
 }
 
-static bool mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)
+bool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp)
 {
 	struct svc_cred *cr = &amp;rqstp-&gt;rq_cred;
 
@@ -2424,7 +2424,7 @@ nfsd4_exchange_id(struct svc_rqst *rqstp,
 				status = nfserr_inval;
 				goto out;
 			}
-			if (!mach_creds_match(conf, rqstp)) {
+			if (!nfsd4_mach_creds_match(conf, rqstp)) {
 				status = nfserr_wrong_cred;
 				goto out;
 			}
@@ -2676,7 +2676,7 @@ nfsd4_create_session(struct svc_rqst *rqstp,
 
 	if (conf) {
 		status = nfserr_wrong_cred;
-		if (!mach_creds_match(conf, rqstp))
+		if (!nfsd4_mach_creds_match(conf, rqstp))
 			goto out_free_conn;
 		cs_slot = &amp;conf-&gt;cl_cs_slot;
 		status = check_slot_seqid(cr_ses-&gt;seqid, cs_slot-&gt;sl_seqid, 0);
@@ -2692,7 +2692,7 @@ nfsd4_create_session(struct svc_rqst *rqstp,
 			goto out_free_conn;
 		}
 		status = nfserr_wrong_cred;
-		if (!mach_creds_match(unconf, rqstp))
+		if (!nfsd4_mach_creds_match(unconf, rqstp))
 			goto out_free_conn;
 		cs_slot = &amp;unconf-&gt;cl_cs_slot;
 		status = check_slot_seqid(cr_ses-&gt;seqid, cs_slot-&gt;sl_seqid, 0);
@@ -2801,7 +2801,7 @@ __be32 nfsd4_bind_conn_to_session(struct svc_rqst *rqstp,
 	if (!session)
 		goto out_no_session;
 	status = nfserr_wrong_cred;
-	if (!mach_creds_match(session-&gt;se_client, rqstp))
+	if (!nfsd4_mach_creds_match(session-&gt;se_client, rqstp))
 		goto out;
 	status = nfsd4_map_bcts_dir(&amp;bcts-&gt;dir);
 	if (status)
@@ -2848,7 +2848,7 @@ nfsd4_destroy_session(struct svc_rqst *r,
 	if (!ses)
 		goto out_client_lock;
 	status = nfserr_wrong_cred;
-	if (!mach_creds_match(ses-&gt;se_client, r))
+	if (!nfsd4_mach_creds_match(ses-&gt;se_client, r))
 		goto out_put_session;
 	status = mark_session_dead_locked(ses, 1 + ref_held_by_me);
 	if (status)
@@ -3087,7 +3087,7 @@ nfsd4_destroy_clientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *csta
 		status = nfserr_stale_clientid;
 		goto out;
 	}
-	if (!mach_creds_match(clp, rqstp)) {
+	if (!nfsd4_mach_creds_match(clp, rqstp)) {
 		clp = NULL;
 		status = nfserr_wrong_cred;
 		goto out;
diff --git a/fs/nfsd/xdr4.h b/fs/nfsd/xdr4.h
index d9554813e58a..74342a7c208a 100644
--- a/fs/nfsd/xdr4.h
+++ b/fs/nfsd/xdr4.h
@@ -654,6 +654,8 @@ set_change_info(struct nfsd4_change_info *cinfo, struct svc_fh *fhp)
 
 }
 
+
+bool nfsd4_mach_creds_match(struct nfs4_client *cl, struct svc_rqst *rqstp);
 int nfs4svc_encode_voidres(struct svc_rqst *, __be32 *, void *);
 int nfs4svc_decode_compoundargs(struct svc_rqst *, __be32 *,
 		struct nfsd4_compoundargs *);</pre><hr><pre>commit 1adf0c5a4451a100cd9253c1d6e3ca77f4a5a98b
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Jun 15 12:52:07 2016 -0400

    nfs/nfsd: Move useful bitfield ops to a commonly accessible place
    
    So these may be used in nfsd as well
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Reviewed-by: Jeff Layton &lt;jlayton@redhat.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/include/linux/nfs4.h b/include/linux/nfs4.h
index bfed6b367350..c6564ada9beb 100644
--- a/include/linux/nfs4.h
+++ b/include/linux/nfs4.h
@@ -643,4 +643,15 @@ enum pnfs_update_layout_reason {
 	PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET,
 };
 
+#define NFS4_OP_MAP_NUM_LONGS					\
+	DIV_ROUND_UP(LAST_NFS4_OP, 8 * sizeof(unsigned long))
+#define NFS4_OP_MAP_NUM_WORDS \
+	(NFS4_OP_MAP_NUM_LONGS * sizeof(unsigned long) / sizeof(u32))
+struct nfs4_op_map {
+	union {
+		unsigned long longs[NFS4_OP_MAP_NUM_LONGS];
+		u32 words[NFS4_OP_MAP_NUM_WORDS];
+	} u;
+};
+
 #endif
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index c304a11b5b1a..e66abc2d1f88 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1185,17 +1185,6 @@ struct pnfs_ds_commit_info {
 	struct pnfs_commit_bucket *buckets;
 };
 
-#define NFS4_OP_MAP_NUM_LONGS \
-	DIV_ROUND_UP(LAST_NFS4_OP, 8 * sizeof(unsigned long))
-#define NFS4_OP_MAP_NUM_WORDS \
-	(NFS4_OP_MAP_NUM_LONGS * sizeof(unsigned long) / sizeof(u32))
-struct nfs4_op_map {
-	union {
-		unsigned long longs[NFS4_OP_MAP_NUM_LONGS];
-		u32 words[NFS4_OP_MAP_NUM_WORDS];
-	} u;
-};
-
 struct nfs41_state_protection {
 	u32 how;
 	struct nfs4_op_map enforce;</pre><hr><pre>commit 99ade3c71b1e40e7174d6527709399a87f3d05e0
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Dec 2 09:39:51 2015 -0500

    nfs: machine credential support for additional operations
    
    Allow LAYOUTRETURN and DELEGRETURN to use machine credentials if the
    server supports it. Add request for OPEN_DOWNGRADE as the close path
    also uses that.
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Signed-off-by: Trond Myklebust &lt;trond.myklebust@primarydata.com&gt;

diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 18d862db15b6..a7d564a83665 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -5383,6 +5383,11 @@ static int _nfs4_proc_delegreturn(struct inode *inode, struct rpc_cred *cred, co
 	if (data == NULL)
 		return -ENOMEM;
 	nfs4_init_sequence(&amp;data-&gt;args.seq_args, &amp;data-&gt;res.seq_res, 1);
+
+	nfs4_state_protect(server-&gt;nfs_client,
+			NFS_SP4_MACH_CRED_CLEANUP,
+			&amp;task_setup_data.rpc_client, &amp;msg);
+
 	data-&gt;args.fhandle = &amp;data-&gt;fh;
 	data-&gt;args.stateid = &amp;data-&gt;stateid;
 	data-&gt;args.bitmask = server-&gt;cache_consistency_bitmask;
@@ -6859,10 +6864,13 @@ static const struct nfs41_state_protection nfs4_sp4_mach_cred_request = {
 	},
 	.allow.u.words = {
 		[0] = 1 &lt;&lt; (OP_CLOSE) |
+		      1 &lt;&lt; (OP_OPEN_DOWNGRADE) |
 		      1 &lt;&lt; (OP_LOCKU) |
+		      1 &lt;&lt; (OP_DELEGRETURN) |
 		      1 &lt;&lt; (OP_COMMIT),
 		[1] = 1 &lt;&lt; (OP_SECINFO - 32) |
 		      1 &lt;&lt; (OP_SECINFO_NO_NAME - 32) |
+		      1 &lt;&lt; (OP_LAYOUTRETURN - 32) |
 		      1 &lt;&lt; (OP_TEST_STATEID - 32) |
 		      1 &lt;&lt; (OP_FREE_STATEID - 32) |
 		      1 &lt;&lt; (OP_WRITE - 32)
@@ -6927,11 +6935,19 @@ static int nfs4_sp4_select_mode(struct nfs_client *clp,
 		}
 
 		if (test_bit(OP_CLOSE, sp-&gt;allow.u.longs) &amp;&amp;
+		    test_bit(OP_OPEN_DOWNGRADE, sp-&gt;allow.u.longs) &amp;&amp;
+		    test_bit(OP_DELEGRETURN, sp-&gt;allow.u.longs) &amp;&amp;
 		    test_bit(OP_LOCKU, sp-&gt;allow.u.longs)) {
 			dfprintk(MOUNT, "  cleanup mode enabled\n");
 			set_bit(NFS_SP4_MACH_CRED_CLEANUP, &amp;clp-&gt;cl_sp4_flags);
 		}
 
+		if (test_bit(OP_LAYOUTRETURN, sp-&gt;allow.u.longs)) {
+			dfprintk(MOUNT, "  pnfs cleanup mode enabled\n");
+			set_bit(NFS_SP4_MACH_CRED_PNFS_CLEANUP,
+				&amp;clp-&gt;cl_sp4_flags);
+		}
+
 		if (test_bit(OP_SECINFO, sp-&gt;allow.u.longs) &amp;&amp;
 		    test_bit(OP_SECINFO_NO_NAME, sp-&gt;allow.u.longs)) {
 			dfprintk(MOUNT, "  secinfo mode enabled\n");
@@ -8084,6 +8100,10 @@ int nfs4_proc_layoutreturn(struct nfs4_layoutreturn *lrp, bool sync)
 	};
 	int status = 0;
 
+	nfs4_state_protect(NFS_SERVER(lrp-&gt;args.inode)-&gt;nfs_client,
+			NFS_SP4_MACH_CRED_PNFS_CLEANUP,
+			&amp;task_setup_data.rpc_client, &amp;msg);
+
 	dprintk("--&gt; %s\n", __func__);
 	if (!sync) {
 		lrp-&gt;inode = nfs_igrab_and_active(lrp-&gt;args.inode);
diff --git a/include/linux/nfs_fs_sb.h b/include/linux/nfs_fs_sb.h
index 2469ab0bb3a1..7fcc13c8cf1f 100644
--- a/include/linux/nfs_fs_sb.h
+++ b/include/linux/nfs_fs_sb.h
@@ -102,6 +102,7 @@ struct nfs_client {
 #define NFS_SP4_MACH_CRED_STATEID  4	/* TEST_STATEID and FREE_STATEID */
 #define NFS_SP4_MACH_CRED_WRITE    5	/* WRITE */
 #define NFS_SP4_MACH_CRED_COMMIT   6	/* COMMIT */
+#define NFS_SP4_MACH_CRED_PNFS_CLEANUP  7 /* LAYOUTRETURN */
 #endif /* CONFIG_NFS_V4 */
 
 	/* Our own IP address, as a null-terminated string.</pre><hr><pre>commit 361cad3c89070aeb37560860ea8bfc092d545adc
Author: Andrew Elble &lt;aweits@rit.edu&gt;
Date:   Wed Dec 2 09:20:57 2015 -0500

    nfs: Fix race in __update_open_stateid()
    
    We've seen this in a packet capture - I've intermixed what I
    think was going on. The fix here is to grab the so_lock sooner.
    
    1964379 -&gt; #1 open (for write) reply seqid=1
    1964393 -&gt; #2 open (for read) reply seqid=2
    
      __nfs4_close(), state-&gt;n_wronly--
      nfs4_state_set_mode_locked(), changes state-&gt;state = [R]
      state-&gt;flags is [RW]
      state-&gt;state is [R], state-&gt;n_wronly == 0, state-&gt;n_rdonly == 1
    
    1964398 -&gt; #3 open (for write) call -&gt; because close is already running
    1964399 -&gt; downgrade (to read) call seqid=2 (close of #1)
    1964402 -&gt; #3 open (for write) reply seqid=3
    
     __update_open_stateid()
       nfs_set_open_stateid_locked(), changes state-&gt;flags
       state-&gt;flags is [RW]
       state-&gt;state is [R], state-&gt;n_wronly == 0, state-&gt;n_rdonly == 1
       new sequence number is exposed now via nfs4_stateid_copy()
    
       next step would be update_open_stateflags(), pending so_lock
    
    1964403 -&gt; downgrade reply seqid=2, fails with OLD_STATEID (close of #1)
    
       nfs4_close_prepare() gets so_lock and recalcs flags -&gt; send close
    
    1964405 -&gt; downgrade (to read) call seqid=3 (close of #1 retry)
    
       __update_open_stateid() gets so_lock
     * update_open_stateflags() updates state-&gt;n_wronly.
       nfs4_state_set_mode_locked() updates state-&gt;state
    
       state-&gt;flags is [RW]
       state-&gt;state is [RW], state-&gt;n_wronly == 1, state-&gt;n_rdonly == 1
    
     * should have suppressed the preceding nfs4_close_prepare() from
       sending open_downgrade
    
    1964406 -&gt; write call
    1964408 -&gt; downgrade (to read) reply seqid=4 (close of #1 retry)
    
       nfs_clear_open_stateid_locked()
       state-&gt;flags is [R]
       state-&gt;state is [RW], state-&gt;n_wronly == 1, state-&gt;n_rdonly == 1
    
    1964409 -&gt; write reply (fails, openmode)
    
    Signed-off-by: Andrew Elble &lt;aweits@rit.edu&gt;
    Cc: stable@vger,kernel.org
    Signed-off-by: Trond Myklebust &lt;trond.myklebust@primarydata.com&gt;

diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 89818036f035..2f1714fda666 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -1385,6 +1385,7 @@ static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s
 	 * Protect the call to nfs4_state_set_mode_locked and
 	 * serialise the stateid update
 	 */
+	spin_lock(&amp;state-&gt;owner-&gt;so_lock);
 	write_seqlock(&amp;state-&gt;seqlock);
 	if (deleg_stateid != NULL) {
 		nfs4_stateid_copy(&amp;state-&gt;stateid, deleg_stateid);
@@ -1393,7 +1394,6 @@ static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s
 	if (open_stateid != NULL)
 		nfs_set_open_stateid_locked(state, open_stateid, fmode);
 	write_sequnlock(&amp;state-&gt;seqlock);
-	spin_lock(&amp;state-&gt;owner-&gt;so_lock);
 	update_open_stateflags(state, fmode);
 	spin_unlock(&amp;state-&gt;owner-&gt;so_lock);
 }</pre>
    <div class="pagination">
        <span>[1]</span><a href='35_2.html'>2</a><a href='35_2.html'>Next&gt;&gt;</a>
    <div>
</body>
