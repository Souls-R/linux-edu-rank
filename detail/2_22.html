<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_21.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><span>[22]</span><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_23.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 78db441d2ea0c804bc43a2bf3f894c4f7a6c7788
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 13 16:36:50 2017 -0400

    USB: f_mass_storage: improve async notification handling
    
    This patch makes several adjustments to the way f_mass_storage.c
    handles its internal state and asynchronous notifications (AKA
    exceptions):
    
            A number of states weren't being used for anything.
            They are removed.
    
            The FSG_STATE_IDLE state was renamed to FSG_STATE_NORMAL,
            because it now applies whenever the gadget is operating
            normally, not just when the gadget is idle.
    
            The FSG_STATE_RESET state was renamed to
            FSG_STATE_PROTOCOL_RESET, indicating that it represents a
            Bulk-Only Transport protocol reset and not a general USB
            reset.
    
            When a signal arrives, it's silly for the signal handler to
            send itself another signal!  Now it takes care of everything
            inline.
    
    Along with an assortment of other minor changes in the same category.
    
    Tested-by: Thinh Nguyen &lt;thinhn@synopsys.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c
index 4c8aacc232c0..a0890a058f09 100644
--- a/drivers/usb/gadget/function/f_mass_storage.c
+++ b/drivers/usb/gadget/function/f_mass_storage.c
@@ -355,7 +355,7 @@ typedef void (*fsg_routine_t)(struct fsg_dev *);
 
 static int exception_in_progress(struct fsg_common *common)
 {
-	return common-&gt;state &gt; FSG_STATE_IDLE;
+	return common-&gt;state &gt; FSG_STATE_NORMAL;
 }
 
 /* Make bulk-out requests be divisible by the maxpacket size */
@@ -528,7 +528,7 @@ static int fsg_setup(struct usb_function *f,
 		 * and reinitialize our state.
 		 */
 		DBG(fsg, "bulk reset request\n");
-		raise_exception(fsg-&gt;common, FSG_STATE_RESET);
+		raise_exception(fsg-&gt;common, FSG_STATE_PROTOCOL_RESET);
 		return USB_GADGET_DELAYED_STATUS;
 
 	case US_BULK_GET_MAX_LUN:
@@ -1625,7 +1625,7 @@ static int finish_reply(struct fsg_common *common)
 	return rc;
 }
 
-static int send_status(struct fsg_common *common)
+static void send_status(struct fsg_common *common)
 {
 	struct fsg_lun		*curlun = common-&gt;curlun;
 	struct fsg_buffhd	*bh;
@@ -1639,7 +1639,7 @@ static int send_status(struct fsg_common *common)
 	while (bh-&gt;state != BUF_STATE_EMPTY) {
 		rc = sleep_thread(common, true);
 		if (rc)
-			return rc;
+			return;
 	}
 
 	if (curlun) {
@@ -1674,10 +1674,10 @@ static int send_status(struct fsg_common *common)
 	bh-&gt;inreq-&gt;zero = 0;
 	if (!start_in_transfer(common, bh))
 		/* Don't know what to do if common-&gt;fsg is NULL */
-		return -EIO;
+		return;
 
 	common-&gt;next_buffhd_to_fill = bh-&gt;next;
-	return 0;
+	return;
 }
 
 
@@ -2362,9 +2362,11 @@ static void handle_exception(struct fsg_common *common)
 		if (!sig)
 			break;
 		if (sig != SIGUSR1) {
+			spin_lock_irq(&amp;common-&gt;lock);
 			if (common-&gt;state &lt; FSG_STATE_EXIT)
 				DBG(common, "Main thread exiting on signal\n");
-			raise_exception(common, FSG_STATE_EXIT);
+			common-&gt;state = FSG_STATE_EXIT;
+			spin_unlock_irq(&amp;common-&gt;lock);
 		}
 	}
 
@@ -2413,10 +2415,9 @@ static void handle_exception(struct fsg_common *common)
 	common-&gt;next_buffhd_to_drain = &amp;common-&gt;buffhds[0];
 	exception_req_tag = common-&gt;exception_req_tag;
 	old_state = common-&gt;state;
+	common-&gt;state = FSG_STATE_NORMAL;
 
-	if (old_state == FSG_STATE_ABORT_BULK_OUT)
-		common-&gt;state = FSG_STATE_STATUS_PHASE;
-	else {
+	if (old_state != FSG_STATE_ABORT_BULK_OUT) {
 		for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); ++i) {
 			curlun = common-&gt;luns[i];
 			if (!curlun)
@@ -2427,21 +2428,19 @@ static void handle_exception(struct fsg_common *common)
 			curlun-&gt;sense_data_info = 0;
 			curlun-&gt;info_valid = 0;
 		}
-		common-&gt;state = FSG_STATE_IDLE;
 	}
 	spin_unlock_irq(&amp;common-&gt;lock);
 
 	/* Carry out any extra actions required for the exception */
 	switch (old_state) {
+	case FSG_STATE_NORMAL:
+		break;
+
 	case FSG_STATE_ABORT_BULK_OUT:
 		send_status(common);
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (common-&gt;state == FSG_STATE_STATUS_PHASE)
-			common-&gt;state = FSG_STATE_IDLE;
-		spin_unlock_irq(&amp;common-&gt;lock);
 		break;
 
-	case FSG_STATE_RESET:
+	case FSG_STATE_PROTOCOL_RESET:
 		/*
 		 * In case we were forced against our will to halt a
 		 * bulk endpoint, clear the halt now.  (The SuperH UDC
@@ -2474,19 +2473,13 @@ static void handle_exception(struct fsg_common *common)
 		break;
 
 	case FSG_STATE_EXIT:
-	case FSG_STATE_TERMINATED:
 		do_set_interface(common, NULL);		/* Free resources */
 		spin_lock_irq(&amp;common-&gt;lock);
 		common-&gt;state = FSG_STATE_TERMINATED;	/* Stop the thread */
 		spin_unlock_irq(&amp;common-&gt;lock);
 		break;
 
-	case FSG_STATE_INTERFACE_CHANGE:
-	case FSG_STATE_DISCONNECT:
-	case FSG_STATE_COMMAND_PHASE:
-	case FSG_STATE_DATA_PHASE:
-	case FSG_STATE_STATUS_PHASE:
-	case FSG_STATE_IDLE:
+	case FSG_STATE_TERMINATED:
 		break;
 	}
 }
@@ -2529,29 +2522,13 @@ static int fsg_main_thread(void *common_)
 			continue;
 		}
 
-		if (get_next_command(common))
+		if (get_next_command(common) || exception_in_progress(common))
 			continue;
-
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (!exception_in_progress(common))
-			common-&gt;state = FSG_STATE_DATA_PHASE;
-		spin_unlock_irq(&amp;common-&gt;lock);
-
-		if (do_scsi_command(common) || finish_reply(common))
+		if (do_scsi_command(common) || exception_in_progress(common))
 			continue;
-
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (!exception_in_progress(common))
-			common-&gt;state = FSG_STATE_STATUS_PHASE;
-		spin_unlock_irq(&amp;common-&gt;lock);
-
-		if (send_status(common))
+		if (finish_reply(common) || exception_in_progress(common))
 			continue;
-
-		spin_lock_irq(&amp;common-&gt;lock);
-		if (!exception_in_progress(common))
-			common-&gt;state = FSG_STATE_IDLE;
-		spin_unlock_irq(&amp;common-&gt;lock);
+		send_status(common);
 	}
 
 	spin_lock_irq(&amp;common-&gt;lock);
@@ -2972,7 +2949,6 @@ static void fsg_common_release(struct kref *ref)
 	if (common-&gt;state != FSG_STATE_TERMINATED) {
 		raise_exception(common, FSG_STATE_EXIT);
 		wait_for_completion(&amp;common-&gt;thread_notifier);
-		common-&gt;thread_task = NULL;
 	}
 
 	for (i = 0; i &lt; ARRAY_SIZE(common-&gt;luns); ++i) {
@@ -3021,11 +2997,11 @@ static int fsg_bind(struct usb_configuration *c, struct usb_function *f)
 	}
 
 	if (!common-&gt;thread_task) {
-		common-&gt;state = FSG_STATE_IDLE;
+		common-&gt;state = FSG_STATE_NORMAL;
 		common-&gt;thread_task =
 			kthread_create(fsg_main_thread, common, "file-storage");
 		if (IS_ERR(common-&gt;thread_task)) {
-			int ret = PTR_ERR(common-&gt;thread_task);
+			ret = PTR_ERR(common-&gt;thread_task);
 			common-&gt;thread_task = NULL;
 			common-&gt;state = FSG_STATE_TERMINATED;
 			return ret;
diff --git a/drivers/usb/gadget/function/storage_common.h b/drivers/usb/gadget/function/storage_common.h
index e69848994cb4..e6095dfbf1d5 100644
--- a/drivers/usb/gadget/function/storage_common.h
+++ b/drivers/usb/gadget/function/storage_common.h
@@ -157,17 +157,10 @@ struct fsg_buffhd {
 };
 
 enum fsg_state {
-	/* This one isn't used anywhere */
-	FSG_STATE_COMMAND_PHASE = -10,
-	FSG_STATE_DATA_PHASE,
-	FSG_STATE_STATUS_PHASE,
-
-	FSG_STATE_IDLE = 0,
+	FSG_STATE_NORMAL,
 	FSG_STATE_ABORT_BULK_OUT,
-	FSG_STATE_RESET,
-	FSG_STATE_INTERFACE_CHANGE,
+	FSG_STATE_PROTOCOL_RESET,
 	FSG_STATE_CONFIG_CHANGE,
-	FSG_STATE_DISCONNECT,
 	FSG_STATE_EXIT,
 	FSG_STATE_TERMINATED
 };</pre><hr><pre>commit 1633682053a7ee8058e10c76722b9b28e97fb73f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 24 13:38:28 2017 -0400

    USB: fix linked-list corruption in rh_call_control()
    
    Using KASAN, Dmitry found a bug in the rh_call_control() routine: If
    buffer allocation fails, the routine returns immediately without
    unlinking its URB from the control endpoint, eventually leading to
    linked-list corruption.
    
    This patch fixes the problem by jumping to the end of the routine
    (where the URB is unlinked) when an allocation failure occurs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Dmitry Vyukov &lt;dvyukov@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 612fab6e54fb..79bdca5cb9c7 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -520,8 +520,10 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	 */
 	tbuf_size =  max_t(u16, sizeof(struct usb_hub_descriptor), wLength);
 	tbuf = kzalloc(tbuf_size, GFP_KERNEL);
-	if (!tbuf)
-		return -ENOMEM;
+	if (!tbuf) {
+		status = -ENOMEM;
+		goto err_alloc;
+	}
 
 	bufp = tbuf;
 
@@ -734,6 +736,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	}
 
 	kfree(tbuf);
+ err_alloc:
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);</pre><hr><pre>commit 0a8fd1346254974c3a852338508e4a4cddbb35f1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Dec 19 12:03:41 2016 -0500

    USB: fix problems with duplicate endpoint addresses
    
    When checking a new device's descriptors, the USB core does not check
    for duplicate endpoint addresses.  This can cause a problem when the
    sysfs files for those endpoints are created; trying to create multiple
    files with the same name will provoke a WARNING:
    
    WARNING: CPU: 2 PID: 865 at fs/sysfs/dir.c:31 sysfs_warn_dup+0x8a/0xa0
    sysfs: cannot create duplicate filename
    '/devices/platform/dummy_hcd.0/usb2/2-1/2-1:64.0/ep_05'
    Kernel panic - not syncing: panic_on_warn set ...
    
    CPU: 2 PID: 865 Comm: kworker/2:1 Not tainted 4.9.0-rc7+ #34
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
    Workqueue: usb_hub_wq hub_event
     ffff88006bee64c8 ffffffff81f96b8a ffffffff00000001 1ffff1000d7dcc2c
     ffffed000d7dcc24 0000000000000001 0000000041b58ab3 ffffffff8598b510
     ffffffff81f968f8 ffffffff850fee20 ffffffff85cff020 dffffc0000000000
    Call Trace:
     [&lt;     inline     &gt;] __dump_stack lib/dump_stack.c:15
     [&lt;ffffffff81f96b8a&gt;] dump_stack+0x292/0x398 lib/dump_stack.c:51
     [&lt;ffffffff8168c88e&gt;] panic+0x1cb/0x3a9 kernel/panic.c:179
     [&lt;ffffffff812b80b4&gt;] __warn+0x1c4/0x1e0 kernel/panic.c:542
     [&lt;ffffffff812b8195&gt;] warn_slowpath_fmt+0xc5/0x110 kernel/panic.c:565
     [&lt;ffffffff819e70ca&gt;] sysfs_warn_dup+0x8a/0xa0 fs/sysfs/dir.c:30
     [&lt;ffffffff819e7308&gt;] sysfs_create_dir_ns+0x178/0x1d0 fs/sysfs/dir.c:59
     [&lt;     inline     &gt;] create_dir lib/kobject.c:71
     [&lt;ffffffff81fa1b07&gt;] kobject_add_internal+0x227/0xa60 lib/kobject.c:229
     [&lt;     inline     &gt;] kobject_add_varg lib/kobject.c:366
     [&lt;ffffffff81fa2479&gt;] kobject_add+0x139/0x220 lib/kobject.c:411
     [&lt;ffffffff82737a63&gt;] device_add+0x353/0x1660 drivers/base/core.c:1088
     [&lt;ffffffff82738d8d&gt;] device_register+0x1d/0x20 drivers/base/core.c:1206
     [&lt;ffffffff82cb77d3&gt;] usb_create_ep_devs+0x163/0x260 drivers/usb/core/endpoint.c:195
     [&lt;ffffffff82c9f27b&gt;] create_intf_ep_devs+0x13b/0x200 drivers/usb/core/message.c:1030
     [&lt;ffffffff82ca39d3&gt;] usb_set_configuration+0x1083/0x18d0 drivers/usb/core/message.c:1937
     [&lt;ffffffff82cc9e2e&gt;] generic_probe+0x6e/0xe0 drivers/usb/core/generic.c:172
     [&lt;ffffffff82caa7fa&gt;] usb_probe_device+0xaa/0xe0 drivers/usb/core/driver.c:263
    
    This patch prevents the problem by checking for duplicate endpoint
    addresses during enumeration and skipping any duplicates.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 0aa9e7d697a5..25dbd8c7aec7 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -239,6 +239,16 @@ static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
 	if (ifp-&gt;desc.bNumEndpoints &gt;= num_ep)
 		goto skip_to_next_endpoint_or_interface_descriptor;
 
+	/* Check for duplicate endpoint addresses */
+	for (i = 0; i &lt; ifp-&gt;desc.bNumEndpoints; ++i) {
+		if (ifp-&gt;endpoint[i].desc.bEndpointAddress ==
+		    d-&gt;bEndpointAddress) {
+			dev_warn(ddev, "config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\n",
+			    cfgno, inum, asnum, d-&gt;bEndpointAddress);
+			goto skip_to_next_endpoint_or_interface_descriptor;
+		}
+	}
+
 	endpoint = &amp;ifp-&gt;endpoint[ifp-&gt;desc.bNumEndpoints];
 	++ifp-&gt;desc.bNumEndpoints;
 </pre><hr><pre>commit 890e6c236dcda6d45c5f0bdd23665636376f6831
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 9 15:25:15 2016 -0500

    USB: gadgetfs: remove unnecessary assignment
    
    The dev_config() routine in gadgetfs has a check that
    dev-&gt;dev-&gt;bNumConfigurations is equal to 1, and then contains a
    redundant line of code setting the value to 1.  This patch removes the
    unnecessary assignment.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 08e5ecc05079..6bde4396927c 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1818,7 +1818,6 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 			|| dev-&gt;dev-&gt;bDescriptorType != USB_DT_DEVICE
 			|| dev-&gt;dev-&gt;bNumConfigurations != 1)
 		goto fail;
-	dev-&gt;dev-&gt;bNumConfigurations = 1;
 	dev-&gt;dev-&gt;bcdUSB = cpu_to_le16 (0x0200);
 
 	/* triggers gadgetfs_bind(); then we can enumerate. */</pre><hr><pre>commit 1c069b057dcf64fada952eaa868d35f02bb0cfc2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 9 15:24:24 2016 -0500

    USB: gadgetfs: fix checks of wTotalLength in config descriptors
    
    Andrey Konovalov's fuzz testing of gadgetfs showed that we should
    improve the driver's checks for valid configuration descriptors passed
    in by the user.  In particular, the driver needs to verify that the
    wTotalLength value in the descriptor is not too short (smaller
    than USB_DT_CONFIG_SIZE).  And the check for whether wTotalLength is
    too large has to be changed, because the driver assumes there is
    always enough room remaining in the buffer to hold a device descriptor
    (at least USB_DT_DEVICE_SIZE bytes).
    
    This patch adds the additional check and fixes the existing check.  It
    may do a little more than strictly necessary, but one extra check
    won't hurt.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index f1ca33942607..08e5ecc05079 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1734,10 +1734,12 @@ static struct usb_gadget_driver gadgetfs_driver = {
  * such as configuration notifications.
  */
 
-static int is_valid_config (struct usb_config_descriptor *config)
+static int is_valid_config(struct usb_config_descriptor *config,
+		unsigned int total)
 {
 	return config-&gt;bDescriptorType == USB_DT_CONFIG
 		&amp;&amp; config-&gt;bLength == USB_DT_CONFIG_SIZE
+		&amp;&amp; total &gt;= USB_DT_CONFIG_SIZE
 		&amp;&amp; config-&gt;bConfigurationValue != 0
 		&amp;&amp; (config-&gt;bmAttributes &amp; USB_CONFIG_ATT_ONE) != 0
 		&amp;&amp; (config-&gt;bmAttributes &amp; USB_CONFIG_ATT_WAKEUP) == 0;
@@ -1787,7 +1789,8 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	/* full or low speed config */
 	dev-&gt;config = (void *) kbuf;
 	total = le16_to_cpu(dev-&gt;config-&gt;wTotalLength);
-	if (!is_valid_config (dev-&gt;config) || total &gt;= length)
+	if (!is_valid_config(dev-&gt;config, total) ||
+			total &gt; length - USB_DT_DEVICE_SIZE)
 		goto fail;
 	kbuf += total;
 	length -= total;
@@ -1796,7 +1799,8 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	if (kbuf [1] == USB_DT_CONFIG) {
 		dev-&gt;hs_config = (void *) kbuf;
 		total = le16_to_cpu(dev-&gt;hs_config-&gt;wTotalLength);
-		if (!is_valid_config (dev-&gt;hs_config) || total &gt;= length)
+		if (!is_valid_config(dev-&gt;hs_config, total) ||
+				total &gt; length - USB_DT_DEVICE_SIZE)
 			goto fail;
 		kbuf += total;
 		length -= total;</pre><hr><pre>commit add333a81a16abbd4f106266a2553677a165725f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 9 15:18:43 2016 -0500

    USB: gadgetfs: fix use-after-free bug
    
    Andrey Konovalov reports that fuzz testing with syzkaller causes a
    KASAN use-after-free bug report in gadgetfs:
    
    BUG: KASAN: use-after-free in gadgetfs_setup+0x208a/0x20e0 at addr ffff88003dfe5bf2
    Read of size 2 by task syz-executor0/22994
    CPU: 3 PID: 22994 Comm: syz-executor0 Not tainted 4.9.0-rc7+ #16
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
     ffff88006df06a18 ffffffff81f96aba ffffffffe0528500 1ffff1000dbe0cd6
     ffffed000dbe0cce ffff88006df068f0 0000000041b58ab3 ffffffff8598b4c8
     ffffffff81f96828 1ffff1000dbe0ccd ffff88006df06708 ffff88006df06748
    Call Trace:
     &lt;IRQ&gt; [  201.343209]  [&lt;     inline     &gt;] __dump_stack lib/dump_stack.c:15
     &lt;IRQ&gt; [  201.343209]  [&lt;ffffffff81f96aba&gt;] dump_stack+0x292/0x398 lib/dump_stack.c:51
     [&lt;ffffffff817e4dec&gt;] kasan_object_err+0x1c/0x70 mm/kasan/report.c:159
     [&lt;     inline     &gt;] print_address_description mm/kasan/report.c:197
     [&lt;ffffffff817e5080&gt;] kasan_report_error+0x1f0/0x4e0 mm/kasan/report.c:286
     [&lt;     inline     &gt;] kasan_report mm/kasan/report.c:306
     [&lt;ffffffff817e562a&gt;] __asan_report_load_n_noabort+0x3a/0x40 mm/kasan/report.c:337
     [&lt;     inline     &gt;] config_buf drivers/usb/gadget/legacy/inode.c:1298
     [&lt;ffffffff8322c8fa&gt;] gadgetfs_setup+0x208a/0x20e0 drivers/usb/gadget/legacy/inode.c:1368
     [&lt;ffffffff830fdcd0&gt;] dummy_timer+0x11f0/0x36d0 drivers/usb/gadget/udc/dummy_hcd.c:1858
     [&lt;ffffffff814807c1&gt;] call_timer_fn+0x241/0x800 kernel/time/timer.c:1308
     [&lt;     inline     &gt;] expire_timers kernel/time/timer.c:1348
     [&lt;ffffffff81482de6&gt;] __run_timers+0xa06/0xec0 kernel/time/timer.c:1641
     [&lt;ffffffff814832c1&gt;] run_timer_softirq+0x21/0x80 kernel/time/timer.c:1654
     [&lt;ffffffff84f4af8b&gt;] __do_softirq+0x2fb/0xb63 kernel/softirq.c:284
    
    The cause of the bug is subtle.  The dev_config() routine gets called
    twice by the fuzzer.  The first time, the user data contains both a
    full-speed configuration descriptor and a high-speed config
    descriptor, causing dev-&gt;hs_config to be set.  But it also contains an
    invalid device descriptor, so the buffer containing the descriptors is
    deallocated and dev_config() returns an error.
    
    The second time dev_config() is called, the user data contains only a
    full-speed config descriptor.  But dev-&gt;hs_config still has the stale
    pointer remaining from the first call, causing the routine to think
    that there is a valid high-speed config.  Later on, when the driver
    dereferences the stale pointer to copy that descriptor, we get a
    use-after-free access.
    
    The fix is simple: Clear dev-&gt;hs_config if the passed-in data does not
    contain a high-speed config descriptor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 01ed3bc0c3c8..f1ca33942607 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1800,6 +1800,8 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 			goto fail;
 		kbuf += total;
 		length -= total;
+	} else {
+		dev-&gt;hs_config = NULL;
 	}
 
 	/* could support multiple configs, using another encoding! */</pre><hr><pre>commit faab50984fe6636e616c7cc3d30308ba391d36fd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 9 15:17:46 2016 -0500

    USB: gadgetfs: fix unbounded memory allocation bug
    
    Andrey Konovalov reports that fuzz testing with syzkaller causes a
    KASAN warning in gadgetfs:
    
    BUG: KASAN: slab-out-of-bounds in dev_config+0x86f/0x1190 at addr ffff88003c47e160
    Write of size 65537 by task syz-executor0/6356
    CPU: 3 PID: 6356 Comm: syz-executor0 Not tainted 4.9.0-rc7+ #19
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
     ffff88003c107ad8 ffffffff81f96aba ffffffff3dc11ef0 1ffff10007820eee
     ffffed0007820ee6 ffff88003dc11f00 0000000041b58ab3 ffffffff8598b4c8
     ffffffff81f96828 ffffffff813fb4a0 ffff88003b6eadc0 ffff88003c107738
    Call Trace:
     [&lt;     inline     &gt;] __dump_stack lib/dump_stack.c:15
     [&lt;ffffffff81f96aba&gt;] dump_stack+0x292/0x398 lib/dump_stack.c:51
     [&lt;ffffffff817e4dec&gt;] kasan_object_err+0x1c/0x70 mm/kasan/report.c:159
     [&lt;     inline     &gt;] print_address_description mm/kasan/report.c:197
     [&lt;ffffffff817e5080&gt;] kasan_report_error+0x1f0/0x4e0 mm/kasan/report.c:286
     [&lt;ffffffff817e5705&gt;] kasan_report+0x35/0x40 mm/kasan/report.c:306
     [&lt;     inline     &gt;] check_memory_region_inline mm/kasan/kasan.c:308
     [&lt;ffffffff817e3fb9&gt;] check_memory_region+0x139/0x190 mm/kasan/kasan.c:315
     [&lt;ffffffff817e4044&gt;] kasan_check_write+0x14/0x20 mm/kasan/kasan.c:326
     [&lt;     inline     &gt;] copy_from_user arch/x86/include/asm/uaccess.h:689
     [&lt;     inline     &gt;] ep0_write drivers/usb/gadget/legacy/inode.c:1135
     [&lt;ffffffff83228caf&gt;] dev_config+0x86f/0x1190 drivers/usb/gadget/legacy/inode.c:1759
     [&lt;ffffffff817fdd55&gt;] __vfs_write+0x5d5/0x760 fs/read_write.c:510
     [&lt;ffffffff817ff650&gt;] vfs_write+0x170/0x4e0 fs/read_write.c:560
     [&lt;     inline     &gt;] SYSC_write fs/read_write.c:607
     [&lt;ffffffff81803a5b&gt;] SyS_write+0xfb/0x230 fs/read_write.c:599
     [&lt;ffffffff84f47ec1&gt;] entry_SYSCALL_64_fastpath+0x1f/0xc2
    
    Indeed, there is a comment saying that the value of len is restricted
    to a 16-bit integer, but the code doesn't actually do this.
    
    This patch fixes the warning.  It replaces the comment with a
    computation that forces the amount of data copied from the user in
    ep0_write() to be no larger than the wLength size for the control
    transfer, which is a 16-bit quantity.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index 48f1409b438a..01ed3bc0c3c8 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -1126,7 +1126,7 @@ ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	/* data and/or status stage for control request */
 	} else if (dev-&gt;state == STATE_DEV_SETUP) {
 
-		/* IN DATA+STATUS caller makes len &lt;= wLength */
+		len = min_t(size_t, len, dev-&gt;setup_wLength);
 		if (dev-&gt;setup_in) {
 			retval = setup_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req, len);
 			if (retval == 0) {</pre><hr><pre>commit bcdbeb844773333d2d1c08004f3b3e25921040e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Dec 14 14:55:56 2016 -0500

    USB: dummy-hcd: fix bug in stop_activity (handle ep0)
    
    The stop_activity() routine in dummy-hcd is supposed to unlink all
    active requests for every endpoint, among other things.  But it
    doesn't handle ep0.  As a result, fuzz testing can generate a WARNING
    like the following:
    
    WARNING: CPU: 0 PID: 4410 at drivers/usb/gadget/udc/dummy_hcd.c:672 dummy_free_request+0x153/0x170
    Modules linked in:
    CPU: 0 PID: 4410 Comm: syz-executor Not tainted 4.9.0-rc7+ #32
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011
     ffff88006a64ed10 ffffffff81f96b8a ffffffff41b58ab3 1ffff1000d4c9d35
     ffffed000d4c9d2d ffff880065f8ac00 0000000041b58ab3 ffffffff8598b510
     ffffffff81f968f8 0000000041b58ab3 ffffffff859410e0 ffffffff813f0590
    Call Trace:
     [&lt;     inline     &gt;] __dump_stack lib/dump_stack.c:15
     [&lt;ffffffff81f96b8a&gt;] dump_stack+0x292/0x398 lib/dump_stack.c:51
     [&lt;ffffffff812b808f&gt;] __warn+0x19f/0x1e0 kernel/panic.c:550
     [&lt;ffffffff812b831c&gt;] warn_slowpath_null+0x2c/0x40 kernel/panic.c:585
     [&lt;ffffffff830fcb13&gt;] dummy_free_request+0x153/0x170 drivers/usb/gadget/udc/dummy_hcd.c:672
     [&lt;ffffffff830ed1b0&gt;] usb_ep_free_request+0xc0/0x420 drivers/usb/gadget/udc/core.c:195
     [&lt;ffffffff83225031&gt;] gadgetfs_unbind+0x131/0x190 drivers/usb/gadget/legacy/inode.c:1612
     [&lt;ffffffff830ebd8f&gt;] usb_gadget_remove_driver+0x10f/0x2b0 drivers/usb/gadget/udc/core.c:1228
     [&lt;ffffffff830ec084&gt;] usb_gadget_unregister_driver+0x154/0x240 drivers/usb/gadget/udc/core.c:1357
    
    This patch fixes the problem by iterating over all the endpoints in
    the driver's ep array instead of iterating over the gadget's ep_list,
    which explicitly leaves out ep0.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index 02b14e91ae6c..c60abe3a68f9 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -330,7 +330,7 @@ static void nuke(struct dummy *dum, struct dummy_ep *ep)
 /* caller must hold lock */
 static void stop_activity(struct dummy *dum)
 {
-	struct dummy_ep	*ep;
+	int i;
 
 	/* prevent any more requests */
 	dum-&gt;address = 0;
@@ -338,8 +338,8 @@ static void stop_activity(struct dummy *dum)
 	/* The timer is left running so that outstanding URBs can fail */
 
 	/* nuke any pending requests first, so driver i/o is quiesced */
-	list_for_each_entry(ep, &amp;dum-&gt;gadget.ep_list, ep.ep_list)
-		nuke(dum, ep);
+	for (i = 0; i &lt; DUMMY_ENDPOINTS; ++i)
+		nuke(dum, &amp;dum-&gt;ep[i]);
 
 	/* driver now does any non-usb quiescing necessary */
 }</pre><hr><pre>commit ccdb6be9ec6580ef69f68949ebe26e0fb58a6fb0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 21 16:49:07 2016 -0400

    USB: UHCI: report non-PME wakeup signalling for Intel hardware
    
    The UHCI controllers in Intel chipsets rely on a platform-specific non-PME
    mechanism for wakeup signalling.  They can generate wakeup signals even
    though they don't support PME.
    
    We need to let the USB core know this so that it will enable runtime
    suspend for UHCI controllers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Bjorn Helgaas &lt;bhelgaas@google.com&gt;
    Acked-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    CC: stable@vger.kernel.org

diff --git a/drivers/usb/host/uhci-pci.c b/drivers/usb/host/uhci-pci.c
index 940304c33224..02260cfdedb1 100644
--- a/drivers/usb/host/uhci-pci.c
+++ b/drivers/usb/host/uhci-pci.c
@@ -129,6 +129,10 @@ static int uhci_pci_init(struct usb_hcd *hcd)
 	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor == PCI_VENDOR_ID_HP)
 		uhci-&gt;wait_for_hp = 1;
 
+	/* Intel controllers use non-PME wakeup signalling */
+	if (to_pci_dev(uhci_dev(uhci))-&gt;vendor == PCI_VENDOR_ID_INTEL)
+		device_set_run_wake(uhci_dev(uhci), 1);
+
 	/* Set up pointers to PCI-specific functions */
 	uhci-&gt;reset_hc = uhci_pci_reset_hc;
 	uhci-&gt;check_and_reset_hc = uhci_pci_check_and_reset_hc;</pre><hr><pre>commit 6496ebd7edf446fccf8266a1a70ffcb64252593e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 21 16:45:38 2016 -0400

    PCI: Check for PME in targeted sleep state
    
    One some systems, the firmware does not allow certain PCI devices to be put
    in deep D-states.  This can cause problems for wakeup signalling, if the
    device does not support PME# in the deepest allowed suspend state.  For
    example, Pierre reports that on his system, ACPI does not permit his xHCI
    host controller to go into D3 during runtime suspend -- but D3 is the only
    state in which the controller can generate PME# signals.  As a result, the
    controller goes into runtime suspend but never wakes up, so it doesn't work
    properly.  USB devices plugged into the controller are never detected.
    
    If the device relies on PME# for wakeup signals but is not capable of
    generating PME# in the target state, the PCI core should accurately report
    that it cannot do wakeup from runtime suspend.  This patch modifies the
    pci_dev_run_wake() routine to add this check.
    
    Reported-by: Pierre de Villemereuil &lt;flyos@mailoo.org&gt;
    Tested-by: Pierre de Villemereuil &lt;flyos@mailoo.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Bjorn Helgaas &lt;bhelgaas@google.com&gt;
    Acked-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;
    CC: stable@vger.kernel.org
    CC: Lukas Wunner &lt;lukas@wunner.de&gt;

diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index ba34907538f6..eda6a7cf0e54 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -2106,6 +2106,10 @@ bool pci_dev_run_wake(struct pci_dev *dev)
 	if (!dev-&gt;pme_support)
 		return false;
 
+	/* PME-capable in principle, but not from the intended sleep state */
+	if (!pci_pme_capable(dev, pci_target_state(dev)))
+		return false;
+
 	while (bus-&gt;parent) {
 		struct pci_dev *bridge = bus-&gt;self;
 </pre>
    <div class="pagination">
        <a href='2_21.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><span>[22]</span><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_23.html'>Next&gt;&gt;</a>
    <div>
</body>
