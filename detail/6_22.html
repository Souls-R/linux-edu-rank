<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_21.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><span>[22]</span><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_23.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0a298d133893c72c96e2156ed7cb0f0c4a306a3e
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Aug 16 21:14:04 2021 +0800

    net: qlcnic: add missed unlock in qlcnic_83xx_flash_read32
    
    qlcnic_83xx_unlock_flash() is called on all paths after we call
    qlcnic_83xx_lock_flash(), except for one error path on failure
    of QLCRD32(), which may cause a deadlock. This bug is suggested
    by a static analysis tool, please advise.
    
    Fixes: 81d0aeb0a4fff ("qlcnic: flash template based firmware reset recovery")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20210816131405.24024-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index d8882d0b6b49..d51bac7ba5af 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@ -3156,8 +3156,10 @@ int qlcnic_83xx_flash_read32(struct qlcnic_adapter *adapter, u32 flash_addr,
 
 		indirect_addr = QLC_83XX_FLASH_DIRECT_DATA(addr);
 		ret = QLCRD32(adapter, indirect_addr, &amp;err);
-		if (err == -EIO)
+		if (err == -EIO) {
+			qlcnic_83xx_unlock_flash(adapter);
 			return err;
+		}
 
 		word = ret;
 		*(u32 *)p_data  = word;</pre><hr><pre>commit 1e29cd9983eba1b596bc07f94d81d728007f8a25
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Thu Apr 8 15:24:02 2021 +0800

    PCI: rcar: Fix runtime PM imbalance in rcar_pcie_ep_probe()
    
    pm_runtime_get_sync() will increase the runtime PM counter
    even it returns an error. Thus a pairing decrement is needed
    to prevent refcount leak. Fix this by replacing this API with
    pm_runtime_resume_and_get(), which will not change the runtime
    PM counter on error.
    
    Link: https://lore.kernel.org/r/20210408072402.15069-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Lorenzo Pieralisi &lt;lorenzo.pieralisi@arm.com&gt;
    Reviewed-by: Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;

diff --git a/drivers/pci/controller/pcie-rcar-ep.c b/drivers/pci/controller/pcie-rcar-ep.c
index b4a288e24aaf..c91d85b15129 100644
--- a/drivers/pci/controller/pcie-rcar-ep.c
+++ b/drivers/pci/controller/pcie-rcar-ep.c
@@ -492,9 +492,9 @@ static int rcar_pcie_ep_probe(struct platform_device *pdev)
 	pcie-&gt;dev = dev;
 
 	pm_runtime_enable(dev);
-	err = pm_runtime_get_sync(dev);
+	err = pm_runtime_resume_and_get(dev);
 	if (err &lt; 0) {
-		dev_err(dev, "pm_runtime_get_sync failed\n");
+		dev_err(dev, "pm_runtime_resume_and_get failed\n");
 		goto err_pm_disable;
 	}
 </pre><hr><pre>commit 672fe1cf145ab9978c62eb827d6a16aa6b63994b
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Thu Apr 8 10:18:43 2021 +0200

    media: atomisp: Fix runtime PM imbalance in atomisp_pci_probe
    
    When hmm_pool_register() fails, a pairing PM usage counter
    increment is needed to keep the counter balanced. It's the
    same for the following error paths.
    
    Link: https://lore.kernel.org/linux-media/20210408081850.24278-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Acked-by: Andy Shevchenko &lt;andy.shevchenko@gmail.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+huawei@kernel.org&gt;

diff --git a/drivers/staging/media/atomisp/pci/atomisp_v4l2.c b/drivers/staging/media/atomisp/pci/atomisp_v4l2.c
index 948769ca6539..af0d83eaa68c 100644
--- a/drivers/staging/media/atomisp/pci/atomisp_v4l2.c
+++ b/drivers/staging/media/atomisp/pci/atomisp_v4l2.c
@@ -1815,6 +1815,7 @@ static int atomisp_pci_probe(struct pci_dev *pdev, const struct pci_device_id *i
 	hmm_cleanup();
 	hmm_pool_unregister(HMM_POOL_TYPE_RESERVED);
 hmm_pool_fail:
+	pm_runtime_get_noresume(&amp;pdev-&gt;dev);
 	destroy_workqueue(isp-&gt;wdt_work_queue);
 wdt_work_queue_fail:
 	atomisp_acc_cleanup(isp);</pre><hr><pre>commit 9c04cfcd4aad232e36306cdc5c74cd9fc9148a7e
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sun Feb 28 19:50:58 2021 +0800

    i40e: Fix error handling in i40e_vsi_open
    
    When vsi-&gt;type == I40E_VSI_FDIR, we have caught the return value of
    i40e_vsi_request_irq() but without further handling. Check and execute
    memory clean on failure just like the other i40e_vsi_request_irq().
    
    Fixes: 8a9eb7d3cbcab ("i40e: rework fdir setup and teardown")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Tested-by: Tony Brelinski &lt;tonyx.brelinski@intel.com&gt;
    Signed-off-by: Tony Nguyen &lt;anthony.l.nguyen@intel.com&gt;

diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 704e474879c5..526fa0a791ea 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -8703,6 +8703,8 @@ int i40e_vsi_open(struct i40e_vsi *vsi)
 			 dev_driver_string(&amp;pf-&gt;pdev-&gt;dev),
 			 dev_name(&amp;pf-&gt;pdev-&gt;dev));
 		err = i40e_vsi_request_irq(vsi, int_name);
+		if (err)
+			goto err_setup_rx;
 
 	} else {
 		err = -EINVAL;</pre><hr><pre>commit e305509e678b3a4af2b3cfd410f409f7cdaabb52
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Sun May 30 21:37:43 2021 +0800

    Bluetooth: use correct lock to prevent UAF of hdev object
    
    The hci_sock_dev_event() function will cleanup the hdev object for
    sockets even if this object may still be in used within the
    hci_sock_bound_ioctl() function, result in UAF vulnerability.
    
    This patch replace the BH context lock to serialize these affairs
    and prevent the race condition.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: Marcel Holtmann &lt;marcel@holtmann.org&gt;

diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c
index 251b9128f530..eed0dd066e12 100644
--- a/net/bluetooth/hci_sock.c
+++ b/net/bluetooth/hci_sock.c
@@ -762,7 +762,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event)
 		/* Detach sockets from device */
 		read_lock(&amp;hci_sk_list.lock);
 		sk_for_each(sk, &amp;hci_sk_list.head) {
-			bh_lock_sock_nested(sk);
+			lock_sock(sk);
 			if (hci_pi(sk)-&gt;hdev == hdev) {
 				hci_pi(sk)-&gt;hdev = NULL;
 				sk-&gt;sk_err = EPIPE;
@@ -771,7 +771,7 @@ void hci_sock_dev_event(struct hci_dev *hdev, int event)
 
 				hci_dev_put(hdev);
 			}
-			bh_unlock_sock(sk);
+			release_sock(sk);
 		}
 		read_unlock(&amp;hci_sk_list.lock);
 	}</pre><hr><pre>commit 6a137caec23aeb9e036cdfd8a46dd8a366460e5d
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue May 25 14:39:02 2021 +0200

    Bluetooth: fix the erroneous flush_work() order
    
    In the cleanup routine for failed initialization of HCI device,
    the flush_work(&amp;hdev-&gt;rx_work) need to be finished before the
    flush_work(&amp;hdev-&gt;cmd_work). Otherwise, the hci_rx_work() can
    possibly invoke new cmd_work and cause a bug, like double free,
    in late processings.
    
    This was assigned CVE-2021-3564.
    
    This patch reorder the flush_work() to fix this bug.
    
    Cc: Marcel Holtmann &lt;marcel@holtmann.org&gt;
    Cc: Johan Hedberg &lt;johan.hedberg@gmail.com&gt;
    Cc: Luiz Augusto von Dentz &lt;luiz.dentz@gmail.com&gt;
    Cc: "David S. Miller" &lt;davem@davemloft.net&gt;
    Cc: Jakub Kicinski &lt;kuba@kernel.org&gt;
    Cc: linux-bluetooth@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Signed-off-by: Hao Xiong &lt;mart1n@zju.edu.cn&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    Signed-off-by: Marcel Holtmann &lt;marcel@holtmann.org&gt;

diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index fd12f1652bdf..7d71d104fdfd 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -1610,8 +1610,13 @@ static int hci_dev_do_open(struct hci_dev *hdev)
 	} else {
 		/* Init failed, cleanup */
 		flush_work(&amp;hdev-&gt;tx_work);
-		flush_work(&amp;hdev-&gt;cmd_work);
+
+		/* Since hci_rx_work() is possible to awake new cmd_work
+		 * it should be flushed first to avoid unexpected call of
+		 * hci_cmd_work()
+		 */
 		flush_work(&amp;hdev-&gt;rx_work);
+		flush_work(&amp;hdev-&gt;cmd_work);
 
 		skb_queue_purge(&amp;hdev-&gt;cmd_q);
 		skb_queue_purge(&amp;hdev-&gt;rx_q);</pre><hr><pre>commit a20a40a8bbc2cf4b29d7248ea31e974e9103dd7f
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Thu Apr 15 15:33:38 2021 +0800

    clk: renesas: rcar-usb2-clock-sel: Fix error handling in .probe()
    
    The error handling paths after pm_runtime_get_sync() have no refcount
    decrement, which leads to refcount leak.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20210415073338.22287-1-dinghao.liu@zju.edu.cn
    [geert: Remove now unused variable priv]
    Signed-off-by: Geert Uytterhoeven &lt;geert+renesas@glider.be&gt;

diff --git a/drivers/clk/renesas/rcar-usb2-clock-sel.c b/drivers/clk/renesas/rcar-usb2-clock-sel.c
index 34a85dc95beb..9fb79bd79435 100644
--- a/drivers/clk/renesas/rcar-usb2-clock-sel.c
+++ b/drivers/clk/renesas/rcar-usb2-clock-sel.c
@@ -128,10 +128,8 @@ static int rcar_usb2_clock_sel_resume(struct device *dev)
 static int rcar_usb2_clock_sel_remove(struct platform_device *pdev)
 {
 	struct device *dev = &amp;pdev-&gt;dev;
-	struct usb2_clock_sel_priv *priv = platform_get_drvdata(pdev);
 
 	of_clk_del_provider(dev-&gt;of_node);
-	clk_hw_unregister(&amp;priv-&gt;hw);
 	pm_runtime_put(dev);
 	pm_runtime_disable(dev);
 
@@ -164,9 +162,6 @@ static int rcar_usb2_clock_sel_probe(struct platform_device *pdev)
 	if (IS_ERR(priv-&gt;rsts))
 		return PTR_ERR(priv-&gt;rsts);
 
-	pm_runtime_enable(dev);
-	pm_runtime_get_sync(dev);
-
 	clk = devm_clk_get(dev, "usb_extal");
 	if (!IS_ERR(clk) &amp;&amp; !clk_prepare_enable(clk)) {
 		priv-&gt;extal = !!clk_get_rate(clk);
@@ -183,6 +178,8 @@ static int rcar_usb2_clock_sel_probe(struct platform_device *pdev)
 		return -ENOENT;
 	}
 
+	pm_runtime_enable(dev);
+	pm_runtime_get_sync(dev);
 	platform_set_drvdata(pdev, priv);
 	dev_set_drvdata(dev, priv);
 
@@ -190,11 +187,20 @@ static int rcar_usb2_clock_sel_probe(struct platform_device *pdev)
 	init.ops = &amp;usb2_clock_sel_clock_ops;
 	priv-&gt;hw.init = &amp;init;
 
-	clk = clk_register(NULL, &amp;priv-&gt;hw);
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
+	ret = devm_clk_hw_register(NULL, &amp;priv-&gt;hw);
+	if (ret)
+		goto pm_put;
+
+	ret = of_clk_add_hw_provider(np, of_clk_hw_simple_get, &amp;priv-&gt;hw);
+	if (ret)
+		goto pm_put;
+
+	return 0;
 
-	return of_clk_add_hw_provider(np, of_clk_hw_simple_get, &amp;priv-&gt;hw);
+pm_put:
+	pm_runtime_put(dev);
+	pm_runtime_disable(dev);
+	return ret;
 }
 
 static const struct dev_pm_ops rcar_usb2_clock_sel_pm_ops = {</pre><hr><pre>commit 07adc0225484fc199e3dc15ec889f75f498c4fca
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Apr 12 13:49:07 2021 +0800

    usb: cdns3: Fix runtime PM imbalance on error
    
    When cdns3_gadget_start() fails, a pairing PM usage counter
    decrement is needed to keep the counter balanced.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20210412054908.7975-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Peter Chen &lt;peter.chen@kernel.org&gt;

diff --git a/drivers/usb/cdns3/cdns3-gadget.c b/drivers/usb/cdns3/cdns3-gadget.c
index 9b1bd417cec0..a8b7b50abf64 100644
--- a/drivers/usb/cdns3/cdns3-gadget.c
+++ b/drivers/usb/cdns3/cdns3-gadget.c
@@ -3268,8 +3268,10 @@ static int __cdns3_gadget_init(struct cdns *cdns)
 	pm_runtime_get_sync(cdns-&gt;dev);
 
 	ret = cdns3_gadget_start(cdns);
-	if (ret)
+	if (ret) {
+		pm_runtime_put_sync(cdns-&gt;dev);
 		return ret;
+	}
 
 	/*
 	 * Because interrupt line can be shared with other components in</pre><hr><pre>commit a2fa9242e89f27696515699fe0f0296bf1ac1815
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Apr 12 13:32:02 2021 +0800

    iio: proximity: pulsedlight: Fix rumtime PM imbalance on error
    
    When lidar_write_control() fails, a pairing PM usage counter
    decrement is needed to keep the counter balanced.
    
    Fixes: 4ac4e086fd8c5 ("iio: pulsedlight-lidar-lite: add runtime PM")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Andy Shevchenko &lt;andy.shevchenko@gmail.com&gt;
    Link: https://lore.kernel.org/r/20210412053204.4889-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Jonathan Cameron &lt;Jonathan.Cameron@huawei.com&gt;

diff --git a/drivers/iio/proximity/pulsedlight-lidar-lite-v2.c b/drivers/iio/proximity/pulsedlight-lidar-lite-v2.c
index c685f10b5ae4..cc206bfa09c7 100644
--- a/drivers/iio/proximity/pulsedlight-lidar-lite-v2.c
+++ b/drivers/iio/proximity/pulsedlight-lidar-lite-v2.c
@@ -160,6 +160,7 @@ static int lidar_get_measurement(struct lidar_data *data, u16 *reg)
 	ret = lidar_write_control(data, LIDAR_REG_CONTROL_ACQUIRE);
 	if (ret &lt; 0) {
 		dev_err(&amp;client-&gt;dev, "cannot send start measurement command");
+		pm_runtime_put_noidle(&amp;client-&gt;dev);
 		return ret;
 	}
 </pre><hr><pre>commit 8edb79af88efc6e49e735f9baf61d9f0748b881f
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Wed Apr 7 11:49:27 2021 +0800

    iio: light: gp2ap002: Fix rumtime PM imbalance on error
    
    When devm_request_threaded_irq() fails, we should decrease the
    runtime PM counter to keep the counter balanced. But when
    iio_device_register() fails, we need not to decrease it because
    we have already decreased it before.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Linus Walleij &lt;linus.walleij@linaro.org&gt;
    Fixes: 97d642e23037 ("iio: light: Add a driver for Sharp GP2AP002x00F")
    Link: https://lore.kernel.org/r/20210407034927.16882-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Jonathan Cameron &lt;Jonathan.Cameron@huawei.com&gt;

diff --git a/drivers/iio/light/gp2ap002.c b/drivers/iio/light/gp2ap002.c
index d048ae257c51..f960be7d4001 100644
--- a/drivers/iio/light/gp2ap002.c
+++ b/drivers/iio/light/gp2ap002.c
@@ -582,7 +582,7 @@ static int gp2ap002_probe(struct i2c_client *client,
 					"gp2ap002", indio_dev);
 	if (ret) {
 		dev_err(dev, "unable to request IRQ\n");
-		goto out_disable_vio;
+		goto out_put_pm;
 	}
 	gp2ap002-&gt;irq = client-&gt;irq;
 
@@ -612,8 +612,9 @@ static int gp2ap002_probe(struct i2c_client *client,
 
 	return 0;
 
-out_disable_pm:
+out_put_pm:
 	pm_runtime_put_noidle(dev);
+out_disable_pm:
 	pm_runtime_disable(dev);
 out_disable_vio:
 	regulator_disable(gp2ap002-&gt;vio);</pre>
    <div class="pagination">
        <a href='6_21.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><span>[22]</span><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_23.html'>Next&gt;&gt;</a>
    <div>
</body>
