<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Nanyang Technological University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Nanyang Technological University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit 76f1017757aa0c308a0b83ca611c9a89ee9a79a4
Author: Bin Zhou &lt;zhou0022@ntu.edu.sg&gt;
Date:   Mon Jun 5 17:28:30 2006 -0700

    [TCP]: TCP Veno congestion control
    
    TCP Veno module is a new congestion control module to improve TCP
    performance over wireless networks. The key innovation in TCP Veno is
    the enhancement of TCP Reno/Sack congestion control algorithm by using
    the estimated state of a connection based on TCP Vegas. This scheme
    significantly reduces "blind" reduction of TCP window regardless of
    the cause of packet loss.
    
    This work is based on the research paper "TCP Veno: TCP Enhancement
    for Transmission over Wireless Access Networks." C. P. Fu, S. C. Liew,
    IEEE Journal on Selected Areas in Communication, Feb. 2003.
    
    Original paper and many latest research works on veno:
     http://www.ntu.edu.sg/home/ascpfu/veno/veno.html
    
    Signed-off-by: Bin Zhou &lt;zhou0022@ntu.edu.sg&gt;
                   Cheng Peng Fu &lt;ascpfu@ntu.edu.sg&gt;
    Signed-off-by: Stephen Hemminger &lt;shemminger@osdl.org&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv4/Kconfig b/net/ipv4/Kconfig
index ae85149a0434..8514106761b0 100644
--- a/net/ipv4/Kconfig
+++ b/net/ipv4/Kconfig
@@ -560,6 +560,18 @@ config TCP_CONG_LP
 	``fair share`` of bandwidth as targeted by TCP.
 	See http://www-ece.rice.edu/networks/TCP-LP/
 
+config TCP_CONG_VENO
+	tristate "TCP Veno"
+	depends on EXPERIMENTAL
+	default n
+	---help---
+	TCP Veno is a sender-side only enhancement of TCP to obtain better
+	throughput over wireless networks. TCP Veno makes use of state
+	distinguishing to circumvent the difficult judgment of the packet loss
+	type. TCP Veno cuts down less congestion window in response to random
+	loss packets.
+	See http://www.ntu.edu.sg/home5/ZHOU0022/papers/CPFu03a.pdf
+
 endmenu
 
 config TCP_CONG_BIC
diff --git a/net/ipv4/Makefile b/net/ipv4/Makefile
index 58a7a4634f70..00fcd2c1ba78 100644
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -43,6 +43,7 @@ obj-$(CONFIG_TCP_CONG_HSTCP) += tcp_highspeed.o
 obj-$(CONFIG_TCP_CONG_HYBLA) += tcp_hybla.o
 obj-$(CONFIG_TCP_CONG_HTCP) += tcp_htcp.o
 obj-$(CONFIG_TCP_CONG_VEGAS) += tcp_vegas.o
+obj-$(CONFIG_TCP_CONG_VENO) += tcp_veno.o
 obj-$(CONFIG_TCP_CONG_SCALABLE) += tcp_scalable.o
 obj-$(CONFIG_TCP_CONG_LP) += tcp_lp.o
 
diff --git a/net/ipv4/tcp_veno.c b/net/ipv4/tcp_veno.c
new file mode 100644
index 000000000000..1091671751c4
--- /dev/null
+++ b/net/ipv4/tcp_veno.c
@@ -0,0 +1,238 @@
+/*
+ * TCP Veno congestion control
+ *
+ * This is based on the congestion detection/avoidance scheme described in
+ *    C. P. Fu, S. C. Liew.
+ *    "TCP Veno: TCP Enhancement for Transmission over Wireless Access Networks."
+ *    IEEE Journal on Selected Areas in Communication,
+ *    Feb. 2003.
+ * 	See http://www.ntu.edu.sg/home5/ZHOU0022/papers/CPFu03a.pdf
+ */
+
+#include &lt;linux/config.h&gt;
+#include &lt;linux/mm.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/skbuff.h&gt;
+#include &lt;linux/inet_diag.h&gt;
+
+#include &lt;net/tcp.h&gt;
+
+/* Default values of the Veno variables, in fixed-point representation
+ * with V_PARAM_SHIFT bits to the right of the binary point.
+ */
+#define V_PARAM_SHIFT 1
+static const int beta = 3 &lt;&lt; V_PARAM_SHIFT;
+
+/* Veno variables */
+struct veno {
+	u8 doing_veno_now;	/* if true, do veno for this rtt */
+	u16 cntrtt;		/* # of rtts measured within last rtt */
+	u32 minrtt;		/* min of rtts measured within last rtt (in usec) */
+	u32 basertt;		/* the min of all Veno rtt measurements seen (in usec) */
+	u32 inc;		/* decide whether to increase cwnd */
+	u32 diff;		/* calculate the diff rate */
+};
+
+/* There are several situations when we must "re-start" Veno:
+ *
+ *  o when a connection is established
+ *  o after an RTO
+ *  o after fast recovery
+ *  o when we send a packet and there is no outstanding
+ *    unacknowledged data (restarting an idle connection)
+ *
+ */
+static inline void veno_enable(struct sock *sk)
+{
+	struct veno *veno = inet_csk_ca(sk);
+
+	/* turn on Veno */
+	veno-&gt;doing_veno_now = 1;
+
+	veno-&gt;minrtt = 0x7fffffff;
+}
+
+static inline void veno_disable(struct sock *sk)
+{
+	struct veno *veno = inet_csk_ca(sk);
+
+	/* turn off Veno */
+	veno-&gt;doing_veno_now = 0;
+}
+
+static void tcp_veno_init(struct sock *sk)
+{
+	struct veno *veno = inet_csk_ca(sk);
+
+	veno-&gt;basertt = 0x7fffffff;
+	veno-&gt;inc = 1;
+	veno_enable(sk);
+}
+
+/* Do rtt sampling needed for Veno. */
+static void tcp_veno_rtt_calc(struct sock *sk, u32 usrtt)
+{
+	struct veno *veno = inet_csk_ca(sk);
+	u32 vrtt = usrtt + 1;	/* Never allow zero rtt or basertt */
+
+	/* Filter to find propagation delay: */
+	if (vrtt &lt; veno-&gt;basertt)
+		veno-&gt;basertt = vrtt;
+
+	/* Find the min rtt during the last rtt to find
+	 * the current prop. delay + queuing delay:
+	 */
+	veno-&gt;minrtt = min(veno-&gt;minrtt, vrtt);
+	veno-&gt;cntrtt++;
+}
+
+static void tcp_veno_state(struct sock *sk, u8 ca_state)
+{
+	if (ca_state == TCP_CA_Open)
+		veno_enable(sk);
+	else
+		veno_disable(sk);
+}
+
+/*
+ * If the connection is idle and we are restarting,
+ * then we don't want to do any Veno calculations
+ * until we get fresh rtt samples.  So when we
+ * restart, we reset our Veno state to a clean
+ * state. After we get acks for this flight of
+ * packets, _then_ we can make Veno calculations
+ * again.
+ */
+static void tcp_veno_cwnd_event(struct sock *sk, enum tcp_ca_event event)
+{
+	if (event == CA_EVENT_CWND_RESTART || event == CA_EVENT_TX_START)
+		tcp_veno_init(sk);
+}
+
+static void tcp_veno_cong_avoid(struct sock *sk, u32 ack,
+				u32 seq_rtt, u32 in_flight, int flag)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+	struct veno *veno = inet_csk_ca(sk);
+
+	if (!veno-&gt;doing_veno_now)
+		return tcp_reno_cong_avoid(sk, ack, seq_rtt, in_flight, flag);
+
+	/* limited by applications */
+	if (!tcp_is_cwnd_limited(sk, in_flight))
+		return;
+
+	/* We do the Veno calculations only if we got enough rtt samples */
+	if (veno-&gt;cntrtt &lt;= 2) {
+		/* We don't have enough rtt samples to do the Veno
+		 * calculation, so we'll behave like Reno.
+		 */
+		tcp_reno_cong_avoid(sk, ack, seq_rtt, in_flight, flag);
+	} else {
+		u32 rtt, target_cwnd;
+
+		/* We have enough rtt samples, so, using the Veno
+		 * algorithm, we determine the state of the network.
+		 */
+
+		rtt = veno-&gt;minrtt;
+
+		target_cwnd = ((tp-&gt;snd_cwnd * veno-&gt;basertt)
+			       &lt;&lt; V_PARAM_SHIFT) / rtt;
+
+		veno-&gt;diff = (tp-&gt;snd_cwnd &lt;&lt; V_PARAM_SHIFT) - target_cwnd;
+
+		if (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh) {
+			/* Slow start.  */
+			tcp_slow_start(tp);
+		} else {
+			/* Congestion avoidance. */
+			if (veno-&gt;diff &lt; beta) {
+				/* In the "non-congestive state", increase cwnd
+				 *  every rtt.
+				 */
+				if (tp-&gt;snd_cwnd_cnt &gt;= tp-&gt;snd_cwnd) {
+					if (tp-&gt;snd_cwnd &lt; tp-&gt;snd_cwnd_clamp)
+						tp-&gt;snd_cwnd++;
+					tp-&gt;snd_cwnd_cnt = 0;
+				} else
+					tp-&gt;snd_cwnd_cnt++;
+			} else {
+				/* In the "congestive state", increase cwnd
+				 * every other rtt.
+				 */
+				if (tp-&gt;snd_cwnd_cnt &gt;= tp-&gt;snd_cwnd) {
+					if (veno-&gt;inc
+					    &amp;&amp; tp-&gt;snd_cwnd &lt;
+					    tp-&gt;snd_cwnd_clamp) {
+						tp-&gt;snd_cwnd++;
+						veno-&gt;inc = 0;
+					} else
+						veno-&gt;inc = 1;
+					tp-&gt;snd_cwnd_cnt = 0;
+				} else
+					tp-&gt;snd_cwnd_cnt++;
+			}
+
+		}
+		if (tp-&gt;snd_cwnd &lt; 2)
+			tp-&gt;snd_cwnd = 2;
+		else if (tp-&gt;snd_cwnd &gt; tp-&gt;snd_cwnd_clamp)
+			tp-&gt;snd_cwnd = tp-&gt;snd_cwnd_clamp;
+	}
+	/* Wipe the slate clean for the next rtt. */
+	/* veno-&gt;cntrtt = 0; */
+	veno-&gt;minrtt = 0x7fffffff;
+}
+
+/* Veno MD phase */
+static u32 tcp_veno_ssthresh(struct sock *sk)
+{
+	const struct tcp_sock *tp = tcp_sk(sk);
+	struct veno *veno = inet_csk_ca(sk);
+
+	if (veno-&gt;diff &lt; beta)
+		/* in "non-congestive state", cut cwnd by 1/5 */
+		return max(tp-&gt;snd_cwnd * 4 / 5, 2U);
+	else
+		/* in "congestive state", cut cwnd by 1/2 */
+		return max(tp-&gt;snd_cwnd &gt;&gt; 1U, 2U);
+}
+
+static u32 tcp_veno_min_cwnd(struct sock * sk)
+{
+	const struct tcp_sock *tp = tcp_sk(sk);
+	return tp-&gt;snd_ssthresh;
+}
+
+static struct tcp_congestion_ops tcp_veno = {
+	.init		= tcp_veno_init,
+	.ssthresh	= tcp_veno_ssthresh,
+	.cong_avoid	= tcp_veno_cong_avoid,
+	.min_cwnd 	= tcp_veno_min_cwnd,
+	.rtt_sample	= tcp_veno_rtt_calc,
+	.set_state	= tcp_veno_state,
+	.cwnd_event	= tcp_veno_cwnd_event,
+
+	.owner		= THIS_MODULE,
+	.name		= "veno",
+};
+
+static int __init tcp_veno_register(void)
+{
+	BUG_ON(sizeof(struct veno) &gt; ICSK_CA_PRIV_SIZE);
+	tcp_register_congestion_control(&amp;tcp_veno);
+	return 0;
+}
+
+static void __exit tcp_veno_unregister(void)
+{
+	tcp_unregister_congestion_control(&amp;tcp_veno);
+}
+
+module_init(tcp_veno_register);
+module_exit(tcp_veno_unregister);
+
+MODULE_AUTHOR("Bin Zhou, Cheng Peng Fu");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("TCP Veno");</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
