<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_150.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><span>[151]</span><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_152.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fbbf9fd2f1b8b4490ff777df2af5543608dde6f1
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Wed Sep 16 12:28:00 2015 -0400

    Revert "USB: qcserial/option: make AT URCs work for Sierra Wireless MC73xx"
    
    This reverts commit d80c0d14183516f184a5ac88e11008ee4c7d2a2e
    (excluding the change to MAX_BL_NUM, which has since been removed).
    
    The qcserial driver now enables the SET_CONTROL_LINE_STATE request
    so that AT URCs will work. Move these devices back to the qcserial
    driver, which is used for other devices in this series that follow
    the same layout.
    
    Cc: Bjørn Mork &lt;bjorn@mork.no&gt;
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: Johan Hovold &lt;johan@kernel.org&gt;

diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index af4f3def3673..685fef71d3d1 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -233,8 +233,6 @@ static void option_instat_callback(struct urb *urb);
 
 #define QUALCOMM_VENDOR_ID			0x05C6
 
-#define SIERRA_VENDOR_ID			0x1199
-
 #define CMOTECH_VENDOR_ID			0x16d8
 #define CMOTECH_PRODUCT_6001			0x6001
 #define CMOTECH_PRODUCT_CMU_300			0x6002
@@ -610,11 +608,6 @@ static const struct option_blacklist_info telit_le920_blacklist = {
 	.reserved = BIT(1) | BIT(5),
 };
 
-static const struct option_blacklist_info sierra_mc73xx_blacklist = {
-	.sendsetup = BIT(0) | BIT(2),
-	.reserved = BIT(8) | BIT(10) | BIT(11),
-};
-
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
@@ -1112,8 +1105,6 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6613)}, /* Onda H600/ZTE MF330 */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0023)}, /* ONYX 3G device */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
-	{ USB_DEVICE_INTERFACE_CLASS(SIERRA_VENDOR_ID, 0x68c0, 0xff),
-	  .driver_info = (kernel_ulong_t)&amp;sierra_mc73xx_blacklist }, /* MC73xx */
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6003),
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index 9bb42cff143a..8ad342dddca3 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -143,6 +143,7 @@ static const struct usb_device_id id_table[] = {
 	{DEVICE_SWI(0x0f3d, 0x68a2)},	/* Sierra Wireless MC7700 */
 	{DEVICE_SWI(0x114f, 0x68a2)},	/* Sierra Wireless MC7750 */
 	{DEVICE_SWI(0x1199, 0x68a2)},	/* Sierra Wireless MC7710 */
+	{DEVICE_SWI(0x1199, 0x68c0)},	/* Sierra Wireless MC73xx */
 	{DEVICE_SWI(0x1199, 0x901c)},	/* Sierra Wireless EM7700 */
 	{DEVICE_SWI(0x1199, 0x901f)},	/* Sierra Wireless EM7355 */
 	{DEVICE_SWI(0x1199, 0x9040)},	/* Sierra Wireless Modem */</pre><hr><pre>commit 3d07984b4fe76000f5210630c19ab34aa9d3c5a4
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Wed Sep 16 12:27:59 2015 -0400

    Revert "USB: qcserial/option: make AT URCs work for Sierra Wireless MC7305/MC7355"
    
    This reverts commit 653cdc13a340ad1cef29f1bab0d05d0771fa1d57.
    
    The qcserial driver now enables the SET_CONTROL_LINE_STATE request
    so that AT URCs will work. Move these devices back to the qcserial
    driver, which is used for other devices in this series that follow
    the same layout.
    
    Cc: Bjørn Mork &lt;bjorn@mork.no&gt;
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: Johan Hovold &lt;johan@kernel.org&gt;

diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index edfaec19e1ae..af4f3def3673 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -1114,8 +1114,6 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
 	{ USB_DEVICE_INTERFACE_CLASS(SIERRA_VENDOR_ID, 0x68c0, 0xff),
 	  .driver_info = (kernel_ulong_t)&amp;sierra_mc73xx_blacklist }, /* MC73xx */
-	{ USB_DEVICE_INTERFACE_CLASS(SIERRA_VENDOR_ID, 0x9041, 0xff),
-	  .driver_info = (kernel_ulong_t)&amp;sierra_mc73xx_blacklist }, /* MC7305/MC7355 */
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6003),
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index c2d0e5cfd2c3..9bb42cff143a 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -146,6 +146,7 @@ static const struct usb_device_id id_table[] = {
 	{DEVICE_SWI(0x1199, 0x901c)},	/* Sierra Wireless EM7700 */
 	{DEVICE_SWI(0x1199, 0x901f)},	/* Sierra Wireless EM7355 */
 	{DEVICE_SWI(0x1199, 0x9040)},	/* Sierra Wireless Modem */
+	{DEVICE_SWI(0x1199, 0x9041)},	/* Sierra Wireless MC7305/MC7355 */
 	{DEVICE_SWI(0x1199, 0x9051)},	/* Netgear AirCard 340U */
 	{DEVICE_SWI(0x1199, 0x9053)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9054)},	/* Sierra Wireless Modem */</pre><hr><pre>commit efd3e9151fea1b1140d39dc58ec7099a07f0bdff
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Wed Sep 16 12:27:58 2015 -0400

    USB: qcserial: make AT URCs work for Sierra Wireless devices
    
    Three Sierra Wireless modems have been found to require the CDC ACM
    SET_CONTROL_LINE_STATE request on the AT port in order to receive
    unsolicited response codes, most recently the Dell Wireless 5808e
    (which is a re-branded Sierra Wireless EM7355). On the other hand,
    the Sierra Wireless MC7710 does not seem to need this request, but
    it was found to work either way.
    
    Use this request on the AT port of devices with the Sierra Wireless
    layout in the qcserial driver. The other modems that were moved to
    the option driver to work around this can now be moved back.
    
    Cc: Bjørn Mork &lt;bjorn@mork.no&gt;
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: Johan Hovold &lt;johan@kernel.org&gt;

diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index ebcec8cda858..c2d0e5cfd2c3 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -175,6 +175,7 @@ static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
 	__u8 nintf;
 	__u8 ifnum;
 	int altsetting = -1;
+	bool sendsetup = false;
 
 	nintf = serial-&gt;dev-&gt;actconfig-&gt;desc.bNumInterfaces;
 	dev_dbg(dev, "Num Interfaces = %d\n", nintf);
@@ -286,6 +287,7 @@ static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
 			break;
 		case 3:
 			dev_dbg(dev, "Modem port found\n");
+			sendsetup = true;
 			break;
 		default:
 			/* don't claim any unsupported interface */
@@ -337,17 +339,25 @@ static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)
 		}
 	}
 
+	if (!retval)
+		usb_set_serial_data(serial, (void *)(unsigned long)sendsetup);
+
 	return retval;
 }
 
 static int qc_attach(struct usb_serial *serial)
 {
 	struct usb_wwan_intf_private *data;
+	bool sendsetup;
 
 	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
+	sendsetup = !!(unsigned long)(usb_get_serial_data(serial));
+	if (sendsetup)
+		data-&gt;use_send_setup = 1;
+
 	spin_lock_init(&amp;data-&gt;susp_lock);
 
 	usb_set_serial_data(serial, data);
@@ -374,6 +384,7 @@ static struct usb_serial_driver qcdevice = {
 	.probe               = qcprobe,
 	.open		     = usb_wwan_open,
 	.close		     = usb_wwan_close,
+	.dtr_rts	     = usb_wwan_dtr_rts,
 	.write		     = usb_wwan_write,
 	.write_room	     = usb_wwan_write_room,
 	.chars_in_buffer     = usb_wwan_chars_in_buffer,</pre><hr><pre>commit 669e729f9fb4e05ff02dfa01cbb8606549c6cb7c
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Wed Sep 16 12:27:57 2015 -0400

    USB: usb_wwan/option: generalize option_send_setup for other drivers
    
    Only the option driver implements the send_setup callback; it uses the
    SET_CONTROL_LINE_STATE request in CDC ACM to generate DTR/RTS signals
    on the port. This is not driver-specific though and is needed by other
    drivers, so move the function to the usb_wwan driver (with formatting
    tweaks), and replace the callback pointer with a flag that enables the
    request.
    
    Suggested-by: Bjørn Mork &lt;bjorn@mork.no&gt;
    Suggested-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: Johan Hovold &lt;johan@kernel.org&gt;

diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 4d16c9744f54..edfaec19e1ae 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -48,7 +48,6 @@ static int  option_probe(struct usb_serial *serial,
 			const struct usb_device_id *id);
 static int option_attach(struct usb_serial *serial);
 static void option_release(struct usb_serial *serial);
-static int option_send_setup(struct usb_serial_port *port);
 static void option_instat_callback(struct urb *urb);
 
 /* Vendor and product IDs */
@@ -1890,7 +1889,7 @@ static int option_attach(struct usb_serial *serial)
 
 	if (!blacklist || !test_bit(iface_desc-&gt;bInterfaceNumber,
 						&amp;blacklist-&gt;sendsetup)) {
-		data-&gt;send_setup = option_send_setup;
+		data-&gt;use_send_setup = 1;
 	}
 	spin_lock_init(&amp;data-&gt;susp_lock);
 
@@ -1961,39 +1960,6 @@ static void option_instat_callback(struct urb *urb)
 	}
 }
 
-/** send RTS/DTR state to the port.
- *
- * This is exactly the same as SET_CONTROL_LINE_STATE from the PSTN
- * CDC.
-*/
-static int option_send_setup(struct usb_serial_port *port)
-{
-	struct usb_serial *serial = port-&gt;serial;
-	struct usb_wwan_port_private *portdata;
-	int ifNum = serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber;
-	int val = 0;
-	int res;
-
-	portdata = usb_get_serial_port_data(port);
-
-	if (portdata-&gt;dtr_state)
-		val |= 0x01;
-	if (portdata-&gt;rts_state)
-		val |= 0x02;
-
-	res = usb_autopm_get_interface(serial-&gt;interface);
-	if (res)
-		return res;
-
-	res = usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
-				0x22, 0x21, val, ifNum, NULL,
-				0, USB_CTRL_SET_TIMEOUT);
-
-	usb_autopm_put_interface(serial-&gt;interface);
-
-	return res;
-}
-
 MODULE_AUTHOR(DRIVER_AUTHOR);
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
diff --git a/drivers/usb/serial/usb-wwan.h b/drivers/usb/serial/usb-wwan.h
index f22dff58b587..44b25c08c68a 100644
--- a/drivers/usb/serial/usb-wwan.h
+++ b/drivers/usb/serial/usb-wwan.h
@@ -34,9 +34,9 @@ extern int usb_wwan_resume(struct usb_serial *serial);
 struct usb_wwan_intf_private {
 	spinlock_t susp_lock;
 	unsigned int suspended:1;
+	unsigned int use_send_setup:1;
 	int in_flight;
 	unsigned int open_ports;
-	int (*send_setup) (struct usb_serial_port *port);
 	void *private;
 };
 
diff --git a/drivers/usb/serial/usb_wwan.c b/drivers/usb/serial/usb_wwan.c
index 825305cb71d9..be9cb61b4d19 100644
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@ -36,6 +36,40 @@
 #include &lt;linux/serial.h&gt;
 #include "usb-wwan.h"
 
+/*
+ * Generate DTR/RTS signals on the port using the SET_CONTROL_LINE_STATE request
+ * in CDC ACM.
+ */
+static int usb_wwan_send_setup(struct usb_serial_port *port)
+{
+	struct usb_serial *serial = port-&gt;serial;
+	struct usb_wwan_port_private *portdata;
+	int val = 0;
+	int ifnum;
+	int res;
+
+	portdata = usb_get_serial_port_data(port);
+
+	if (portdata-&gt;dtr_state)
+		val |= 0x01;
+	if (portdata-&gt;rts_state)
+		val |= 0x02;
+
+	ifnum = serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber;
+
+	res = usb_autopm_get_interface(serial-&gt;interface);
+	if (res)
+		return res;
+
+	res = usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+				0x22, 0x21, val, ifnum, NULL, 0,
+				USB_CTRL_SET_TIMEOUT);
+
+	usb_autopm_put_interface(port-&gt;serial-&gt;interface);
+
+	return res;
+}
+
 void usb_wwan_dtr_rts(struct usb_serial_port *port, int on)
 {
 	struct usb_wwan_port_private *portdata;
@@ -43,7 +77,7 @@ void usb_wwan_dtr_rts(struct usb_serial_port *port, int on)
 
 	intfdata = usb_get_serial_data(port-&gt;serial);
 
-	if (!intfdata-&gt;send_setup)
+	if (!intfdata-&gt;use_send_setup)
 		return;
 
 	portdata = usb_get_serial_port_data(port);
@@ -51,7 +85,7 @@ void usb_wwan_dtr_rts(struct usb_serial_port *port, int on)
 	portdata-&gt;rts_state = on;
 	portdata-&gt;dtr_state = on;
 
-	intfdata-&gt;send_setup(port);
+	usb_wwan_send_setup(port);
 }
 EXPORT_SYMBOL(usb_wwan_dtr_rts);
 
@@ -84,7 +118,7 @@ int usb_wwan_tiocmset(struct tty_struct *tty,
 	portdata = usb_get_serial_port_data(port);
 	intfdata = usb_get_serial_data(port-&gt;serial);
 
-	if (!intfdata-&gt;send_setup)
+	if (!intfdata-&gt;use_send_setup)
 		return -EINVAL;
 
 	/* FIXME: what locks portdata fields ? */
@@ -97,7 +131,7 @@ int usb_wwan_tiocmset(struct tty_struct *tty,
 		portdata-&gt;rts_state = 0;
 	if (clear &amp; TIOCM_DTR)
 		portdata-&gt;dtr_state = 0;
-	return intfdata-&gt;send_setup(port);
+	return usb_wwan_send_setup(port);
 }
 EXPORT_SYMBOL(usb_wwan_tiocmset);
 </pre><hr><pre>commit bd8869e86b8a1e5e5b29fad766b2676bb74e5395
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Wed Sep 16 12:27:56 2015 -0400

    USB: option: revert introduction of struct option_private
    
    This is a partial, context modified revert of commit e463c6dda8f5
    ("USB: option: handle send_setup blacklisting at probe"), which
    introduced an unnecessary struct option_private for storing the
    interface number used in option_send_setup. Removing this struct
    will allow option_send_setup to be generalized for other drivers.
    
    Suggested-by: Bjørn Mork &lt;bjorn@mork.no&gt;
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: Johan Hovold &lt;johan@kernel.org&gt;

diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index 6956c4f62216..4d16c9744f54 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -1835,10 +1835,6 @@ static struct usb_serial_driver * const serial_drivers[] = {
 	&amp;option_1port_device, NULL
 };
 
-struct option_private {
-	u8 bInterfaceNumber;
-};
-
 module_usb_serial_driver(serial_drivers, option_ids);
 
 static int option_probe(struct usb_serial *serial,
@@ -1882,26 +1878,16 @@ static int option_attach(struct usb_serial *serial)
 	struct usb_interface_descriptor *iface_desc;
 	const struct option_blacklist_info *blacklist;
 	struct usb_wwan_intf_private *data;
-	struct option_private *priv;
 
 	data = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-	if (!priv) {
-		kfree(data);
-		return -ENOMEM;
-	}
-
 	/* Retrieve blacklist info stored at probe. */
 	blacklist = usb_get_serial_data(serial);
 
 	iface_desc = &amp;serial-&gt;interface-&gt;cur_altsetting-&gt;desc;
 
-	priv-&gt;bInterfaceNumber = iface_desc-&gt;bInterfaceNumber;
-	data-&gt;private = priv;
-
 	if (!blacklist || !test_bit(iface_desc-&gt;bInterfaceNumber,
 						&amp;blacklist-&gt;sendsetup)) {
 		data-&gt;send_setup = option_send_setup;
@@ -1916,9 +1902,7 @@ static int option_attach(struct usb_serial *serial)
 static void option_release(struct usb_serial *serial)
 {
 	struct usb_wwan_intf_private *intfdata = usb_get_serial_data(serial);
-	struct option_private *priv = intfdata-&gt;private;
 
-	kfree(priv);
 	kfree(intfdata);
 }
 
@@ -1985,9 +1969,8 @@ static void option_instat_callback(struct urb *urb)
 static int option_send_setup(struct usb_serial_port *port)
 {
 	struct usb_serial *serial = port-&gt;serial;
-	struct usb_wwan_intf_private *intfdata = usb_get_serial_data(serial);
-	struct option_private *priv = intfdata-&gt;private;
 	struct usb_wwan_port_private *portdata;
+	int ifNum = serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber;
 	int val = 0;
 	int res;
 
@@ -2003,7 +1986,7 @@ static int option_send_setup(struct usb_serial_port *port)
 		return res;
 
 	res = usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
-				0x22, 0x21, val, priv-&gt;bInterfaceNumber, NULL,
+				0x22, 0x21, val, ifNum, NULL,
 				0, USB_CTRL_SET_TIMEOUT);
 
 	usb_autopm_put_interface(serial-&gt;interface);</pre><hr><pre>commit e704059272aae2aaa5e5ce7a76e4c27c492e947e
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Mon Aug 31 14:15:14 2015 -0400

    net: qmi_wwan: Sierra Wireless MC73xx -&gt; Sierra Wireless MC7304/MC7354
    
    Other Sierra Wireless MC73xx devices exist, with different USB IDs.
    
    Cc: Bjørn Mork &lt;bjorn@mork.no&gt;
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
index 6392ae3c4ab8..355842b85ee9 100644
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -752,8 +752,8 @@ static const struct usb_device_id products[] = {
 	{QMI_FIXED_INTF(0x114f, 0x68a2, 8)},    /* Sierra Wireless MC7750 */
 	{QMI_FIXED_INTF(0x1199, 0x68a2, 8)},	/* Sierra Wireless MC7710 in QMI mode */
 	{QMI_FIXED_INTF(0x1199, 0x68a2, 19)},	/* Sierra Wireless MC7710 in QMI mode */
-	{QMI_FIXED_INTF(0x1199, 0x68c0, 8)},	/* Sierra Wireless MC73xx */
-	{QMI_FIXED_INTF(0x1199, 0x68c0, 10)},	/* Sierra Wireless MC73xx */
+	{QMI_FIXED_INTF(0x1199, 0x68c0, 8)},	/* Sierra Wireless MC7304/MC7354 */
+	{QMI_FIXED_INTF(0x1199, 0x68c0, 10)},	/* Sierra Wireless MC7304/MC7354 */
 	{QMI_FIXED_INTF(0x1199, 0x901c, 8)},    /* Sierra Wireless EM7700 */
 	{QMI_FIXED_INTF(0x1199, 0x901f, 8)},    /* Sierra Wireless EM7355 */
 	{QMI_FIXED_INTF(0x1199, 0x9041, 8)},	/* Sierra Wireless MC7305/MC7355 */</pre><hr><pre>commit 44840dec6127e4d7c5074f75d2dd96bc4ab85fe3
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Tue Aug 18 10:36:23 2015 +0200

    USB: qcserial: add HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module
    
    This is an HP-branded Sierra Wireless EM7355:
    https://bugzilla.redhat.com/show_bug.cgi?id=1223646#c2
    
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Johan Hovold &lt;johan@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index d156545728c2..ebcec8cda858 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -139,6 +139,7 @@ static const struct usb_device_id id_table[] = {
 	{USB_DEVICE(0x0AF0, 0x8120)},	/* Option GTM681W */
 
 	/* non-Gobi Sierra Wireless devices */
+	{DEVICE_SWI(0x03f0, 0x4e1d)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */
 	{DEVICE_SWI(0x0f3d, 0x68a2)},	/* Sierra Wireless MC7700 */
 	{DEVICE_SWI(0x114f, 0x68a2)},	/* Sierra Wireless MC7750 */
 	{DEVICE_SWI(0x1199, 0x68a2)},	/* Sierra Wireless MC7710 */</pre><hr><pre>commit a8079092c1bbf9aec3756b35256c7816b8845af7
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Sat Aug 15 20:12:30 2015 -0400

    net: qmi_wwan: add HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module
    
    This is an HP-branded Sierra Wireless EM7355:
    https://bugzilla.redhat.com/show_bug.cgi?id=1223646#c2
    
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
index 9d43460ce3c7..64a60afbe50c 100644
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -785,6 +785,7 @@ static const struct usb_device_id products[] = {
 	{QMI_FIXED_INTF(0x413c, 0x81a4, 8)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
 	{QMI_FIXED_INTF(0x413c, 0x81a8, 8)},	/* Dell Wireless 5808 Gobi(TM) 4G LTE Mobile Broadband Card */
 	{QMI_FIXED_INTF(0x413c, 0x81a9, 8)},	/* Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */
+	{QMI_FIXED_INTF(0x03f0, 0x4e1d, 8)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */
 	{QMI_FIXED_INTF(0x03f0, 0x581d, 4)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Module (Huawei me906e) */
 
 	/* 4. Gobi 1000 devices */</pre><hr><pre>commit 865b804244f228e80fb62abe464296399253cce8
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Sun Jul 26 12:18:58 2015 -0400

    net/ipv4: suppress NETDEV_UP notification on address lifetime update
    
    This notification causes the FIB to be updated, which is not needed
    because the address already exists, and more importantly it may undo
    intentional changes that were made to the FIB after the address was
    originally added. (As a point of comparison, when an address becomes
    deprecated because its preferred lifetime expired, a notification on
    this chain is not generated.)
    
    The motivation for this commit is fixing an incompatibility between
    DHCP clients which set and update the address lifetime according to
    the lease, and a commercial VPN client which replaces kernel routes
    in a way that outbound traffic is sent only through the tunnel (and
    disconnects if any further route changes are detected via netlink).
    
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c
index e813196c91c7..2d9cb1748f81 100644
--- a/net/ipv4/devinet.c
+++ b/net/ipv4/devinet.c
@@ -882,7 +882,6 @@ static int inet_rtm_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh)
 		queue_delayed_work(system_power_efficient_wq,
 				&amp;check_lifetime_work, 0);
 		rtmsg_ifa(RTM_NEWADDR, ifa, nlh, NETLINK_CB(skb).portid);
-		blocking_notifier_call_chain(&amp;inetaddr_chain, NETDEV_UP, ifa);
 	}
 	return 0;
 }</pre><hr><pre>commit a3eb95f891d6130b1fc03dd07a8b54cf0a5c8ab8
Author: David Ward &lt;david.ward@ll.mit.edu&gt;
Date:   Sat May 9 22:01:46 2015 -0400

    net_sched: gred: add TCA_GRED_LIMIT attribute
    
    In a GRED qdisc, if the default "virtual queue" (VQ) does not have drop
    parameters configured, then packets for the default VQ are not subjected
    to RED and are only dropped if the queue is larger than the net_device's
    tx_queue_len. This behavior is useful for WRED mode, since these packets
    will still influence the calculated average queue length and (therefore)
    the drop probability for all of the other VQs. However, for some drivers
    tx_queue_len is zero. In other cases the user may wish to make the limit
    the same for all VQs (including the default VQ with no drop parameters).
    
    This change adds a TCA_GRED_LIMIT attribute to set the GRED queue limit,
    in bytes, during qdisc setup. (This limit is in bytes to be consistent
    with the drop parameters.) The default limit is the same as for a bfifo
    queue (tx_queue_len * psched_mtu). If the drop parameters of any VQ are
    configured with a smaller limit than the GRED queue limit, that VQ will
    still observe the smaller limit instead.
    
    Signed-off-by: David Ward &lt;david.ward@ll.mit.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/include/uapi/linux/pkt_sched.h b/include/uapi/linux/pkt_sched.h
index 69d88b309cc7..8d2530daca9f 100644
--- a/include/uapi/linux/pkt_sched.h
+++ b/include/uapi/linux/pkt_sched.h
@@ -268,7 +268,8 @@ enum {
        TCA_GRED_STAB,
        TCA_GRED_DPS,
        TCA_GRED_MAX_P,
-	   __TCA_GRED_MAX,
+       TCA_GRED_LIMIT,
+       __TCA_GRED_MAX,
 };
 
 #define TCA_GRED_MAX (__TCA_GRED_MAX - 1)
diff --git a/net/sched/sch_gred.c b/net/sched/sch_gred.c
index a4ca4517cdc8..826e2994152b 100644
--- a/net/sched/sch_gred.c
+++ b/net/sched/sch_gred.c
@@ -165,7 +165,8 @@ static int gred_enqueue(struct sk_buff *skb, struct Qdisc *sch)
 			 * if no default DP has been configured. This
 			 * allows for DP flows to be left untouched.
 			 */
-			if (skb_queue_len(&amp;sch-&gt;q) &lt; qdisc_dev(sch)-&gt;tx_queue_len)
+			if (likely(sch-&gt;qstats.backlog + qdisc_pkt_len(skb) &lt;=
+					sch-&gt;limit))
 				return qdisc_enqueue_tail(skb, sch);
 			else
 				goto drop;
@@ -397,7 +398,10 @@ static inline int gred_change_vq(struct Qdisc *sch, int dp,
 
 	q-&gt;DP = dp;
 	q-&gt;prio = prio;
-	q-&gt;limit = ctl-&gt;limit;
+	if (ctl-&gt;limit &gt; sch-&gt;limit)
+		q-&gt;limit = sch-&gt;limit;
+	else
+		q-&gt;limit = ctl-&gt;limit;
 
 	if (q-&gt;backlog == 0)
 		red_end_of_idle_period(&amp;q-&gt;vars);
@@ -414,6 +418,7 @@ static const struct nla_policy gred_policy[TCA_GRED_MAX + 1] = {
 	[TCA_GRED_STAB]		= { .len = 256 },
 	[TCA_GRED_DPS]		= { .len = sizeof(struct tc_gred_sopt) },
 	[TCA_GRED_MAX_P]	= { .type = NLA_U32 },
+	[TCA_GRED_LIMIT]	= { .type = NLA_U32 },
 };
 
 static int gred_change(struct Qdisc *sch, struct nlattr *opt)
@@ -433,11 +438,15 @@ static int gred_change(struct Qdisc *sch, struct nlattr *opt)
 	if (err &lt; 0)
 		return err;
 
-	if (tb[TCA_GRED_PARMS] == NULL &amp;&amp; tb[TCA_GRED_STAB] == NULL)
+	if (tb[TCA_GRED_PARMS] == NULL &amp;&amp; tb[TCA_GRED_STAB] == NULL) {
+		if (tb[TCA_GRED_LIMIT] != NULL)
+			sch-&gt;limit = nla_get_u32(tb[TCA_GRED_LIMIT]);
 		return gred_change_table_def(sch, opt);
+	}
 
 	if (tb[TCA_GRED_PARMS] == NULL ||
-	    tb[TCA_GRED_STAB] == NULL)
+	    tb[TCA_GRED_STAB] == NULL ||
+	    tb[TCA_GRED_LIMIT] != NULL)
 		return -EINVAL;
 
 	max_P = tb[TCA_GRED_MAX_P] ? nla_get_u32(tb[TCA_GRED_MAX_P]) : 0;
@@ -501,6 +510,14 @@ static int gred_init(struct Qdisc *sch, struct nlattr *opt)
 	if (tb[TCA_GRED_PARMS] || tb[TCA_GRED_STAB])
 		return -EINVAL;
 
+	if (tb[TCA_GRED_LIMIT])
+		sch-&gt;limit = nla_get_u32(tb[TCA_GRED_LIMIT]);
+	else {
+		u32 qlen = qdisc_dev(sch)-&gt;tx_queue_len ? : 1;
+
+		sch-&gt;limit = qlen * psched_mtu(qdisc_dev(sch));
+	}
+
 	return gred_change_table_def(sch, tb[TCA_GRED_DPS]);
 }
 
@@ -531,6 +548,9 @@ static int gred_dump(struct Qdisc *sch, struct sk_buff *skb)
 	if (nla_put(skb, TCA_GRED_MAX_P, sizeof(max_p), max_p))
 		goto nla_put_failure;
 
+	if (nla_put_u32(skb, TCA_GRED_LIMIT, sch-&gt;limit))
+		goto nla_put_failure;
+
 	parms = nla_nest_start(skb, TCA_GRED_PARMS);
 	if (parms == NULL)
 		goto nla_put_failure;</pre>
    <div class="pagination">
        <a href='1_150.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><span>[151]</span><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_152.html'>Next&gt;&gt;</a>
    <div>
</body>
