<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_58.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><span>[59]</span><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_60.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 9b37596a2e860404503a3f2a6513db60c296bfdc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 7 11:11:52 2011 -0500

    USB: move usbcore away from hcd-&gt;state
    
    The hcd-&gt;state variable is a disaster.  It's not clearly owned by
    either usbcore or the host controller drivers, and they both change it
    from time to time, potentially stepping on each other's toes.  It's
    not protected by any locks.  And there's no mechanism to prevent it
    from going through an invalid transition.
    
    This patch (as1451) takes a first step toward fixing these problems.
    As it turns out, usbcore uses hcd-&gt;state for essentially only two
    things: checking whether the controller's root hub is running and
    checking whether the controller has died.  Therefore the patch adds
    two new atomic bitflags to the hcd structure, to store these pieces of
    information.  The new flags are used only by usbcore, and a private
    spinlock prevents invalid combinations (a dead controller's root hub
    cannot be running).
    
    The patch does not change the places where usbcore sets hcd-&gt;state,
    since HCDs may depend on them.  Furthermore, there is one place in
    usb_hcd_irq() where usbcore still must use hcd-&gt;state: An HCD's
    interrupt handler can implicitly indicate that the controller died by
    setting hcd-&gt;state to HC_STATE_HALT.  Nevertheless, the new code is a
    big improvement over the current code.
    
    The patch makes one other change.  The hcd_bus_suspend() and
    hcd_bus_resume() routines now check first whether the host controller
    has died; if it has then they return immediately without calling the
    HCD's bus_suspend or bus_resume methods.
    
    This fixes the major problem reported in Bugzilla #29902: The system
    fails to suspend after a host controller dies during system resume.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Alex Terekhov &lt;a.terekhov@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index f71e8e307e0f..d37088591d9a 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -363,8 +363,7 @@ static int check_root_hub_suspended(struct device *dev)
 	struct pci_dev		*pci_dev = to_pci_dev(dev);
 	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
 
-	if (!(hcd-&gt;state == HC_STATE_SUSPENDED ||
-			hcd-&gt;state == HC_STATE_HALT)) {
+	if (HCD_RH_RUNNING(hcd)) {
 		dev_warn(dev, "Root hub is not suspended\n");
 		return -EBUSY;
 	}
@@ -386,7 +385,7 @@ static int suspend_common(struct device *dev, bool do_wakeup)
 	if (retval)
 		return retval;
 
-	if (hcd-&gt;driver-&gt;pci_suspend) {
+	if (hcd-&gt;driver-&gt;pci_suspend &amp;&amp; !HCD_DEAD(hcd)) {
 		/* Optimization: Don't suspend if a root-hub wakeup is
 		 * pending and it would cause the HCD to wake up anyway.
 		 */
@@ -427,7 +426,7 @@ static int resume_common(struct device *dev, int event)
 	struct usb_hcd		*hcd = pci_get_drvdata(pci_dev);
 	int			retval;
 
-	if (hcd-&gt;state != HC_STATE_SUSPENDED) {
+	if (HCD_RH_RUNNING(hcd)) {
 		dev_dbg(dev, "can't resume, not suspended!\n");
 		return 0;
 	}
@@ -442,7 +441,7 @@ static int resume_common(struct device *dev, int event)
 
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
-	if (hcd-&gt;driver-&gt;pci_resume) {
+	if (hcd-&gt;driver-&gt;pci_resume &amp;&amp; !HCD_DEAD(hcd)) {
 		if (event != PM_EVENT_AUTO_RESUME)
 			wait_for_companions(pci_dev, hcd);
 
@@ -475,10 +474,10 @@ static int hcd_pci_suspend_noirq(struct device *dev)
 
 	pci_save_state(pci_dev);
 
-	/* If the root hub is HALTed rather than SUSPENDed,
+	/* If the root hub is dead rather than suspended,
 	 * disallow remote wakeup.
 	 */
-	if (hcd-&gt;state == HC_STATE_HALT)
+	if (HCD_DEAD(hcd))
 		device_set_wakeup_enable(dev, 0);
 	dev_dbg(dev, "wakeup: %d\n", device_may_wakeup(dev));
 
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 24765fd6cf12..e7d0c4571bbe 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -983,7 +983,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 		spin_unlock_irq (&amp;hcd_root_hub_lock);
 
 		/* Did the HC die before the root hub was registered? */
-		if (hcd-&gt;state == HC_STATE_HALT)
+		if (HCD_DEAD(hcd) || hcd-&gt;state == HC_STATE_HALT)
 			usb_hc_died (hcd);	/* This time clean up */
 	}
 
@@ -1089,13 +1089,10 @@ int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 	 * Check the host controller's state and add the URB to the
 	 * endpoint's queue.
 	 */
-	switch (hcd-&gt;state) {
-	case HC_STATE_RUNNING:
-	case HC_STATE_RESUMING:
+	if (HCD_RH_RUNNING(hcd)) {
 		urb-&gt;unlinked = 0;
 		list_add_tail(&amp;urb-&gt;urb_list, &amp;urb-&gt;ep-&gt;urb_list);
-		break;
-	default:
+	} else {
 		rc = -ESHUTDOWN;
 		goto done;
 	}
@@ -1931,7 +1928,7 @@ int usb_hcd_get_frame_number (struct usb_device *udev)
 {
 	struct usb_hcd	*hcd = bus_to_hcd(udev-&gt;bus);
 
-	if (!HC_IS_RUNNING (hcd-&gt;state))
+	if (!HCD_RH_RUNNING(hcd))
 		return -ESHUTDOWN;
 	return hcd-&gt;driver-&gt;get_frame_number (hcd);
 }
@@ -1948,9 +1945,15 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 
 	dev_dbg(&amp;rhdev-&gt;dev, "bus %s%s\n",
 			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "suspend");
+	if (HCD_DEAD(hcd)) {
+		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "suspend");
+		return 0;
+	}
+
 	if (!hcd-&gt;driver-&gt;bus_suspend) {
 		status = -ENOENT;
 	} else {
+		clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
 		hcd-&gt;state = HC_STATE_QUIESCING;
 		status = hcd-&gt;driver-&gt;bus_suspend(hcd);
 	}
@@ -1958,7 +1961,12 @@ int hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)
 		usb_set_device_state(rhdev, USB_STATE_SUSPENDED);
 		hcd-&gt;state = HC_STATE_SUSPENDED;
 	} else {
-		hcd-&gt;state = old_state;
+		spin_lock_irq(&amp;hcd_root_hub_lock);
+		if (!HCD_DEAD(hcd)) {
+			set_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+			hcd-&gt;state = old_state;
+		}
+		spin_unlock_irq(&amp;hcd_root_hub_lock);
 		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
 				"suspend", status);
 	}
@@ -1973,9 +1981,13 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 
 	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
 			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "resume");
+	if (HCD_DEAD(hcd)) {
+		dev_dbg(&amp;rhdev-&gt;dev, "skipped %s of dead bus\n", "resume");
+		return 0;
+	}
 	if (!hcd-&gt;driver-&gt;bus_resume)
 		return -ENOENT;
-	if (hcd-&gt;state == HC_STATE_RUNNING)
+	if (HCD_RH_RUNNING(hcd))
 		return 0;
 
 	hcd-&gt;state = HC_STATE_RESUMING;
@@ -1984,10 +1996,15 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 	if (status == 0) {
 		/* TRSMRCY = 10 msec */
 		msleep(10);
-		usb_set_device_state(rhdev, rhdev-&gt;actconfig
-				? USB_STATE_CONFIGURED
-				: USB_STATE_ADDRESS);
-		hcd-&gt;state = HC_STATE_RUNNING;
+		spin_lock_irq(&amp;hcd_root_hub_lock);
+		if (!HCD_DEAD(hcd)) {
+			usb_set_device_state(rhdev, rhdev-&gt;actconfig
+					? USB_STATE_CONFIGURED
+					: USB_STATE_ADDRESS);
+			set_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+			hcd-&gt;state = HC_STATE_RUNNING;
+		}
+		spin_unlock_irq(&amp;hcd_root_hub_lock);
 	} else {
 		hcd-&gt;state = old_state;
 		dev_dbg(&amp;rhdev-&gt;dev, "bus %s fail, err %d\n",
@@ -2098,7 +2115,7 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	 */
 	local_irq_save(flags);
 
-	if (unlikely(hcd-&gt;state == HC_STATE_HALT || !HCD_HW_ACCESSIBLE(hcd))) {
+	if (unlikely(HCD_DEAD(hcd) || !HCD_HW_ACCESSIBLE(hcd))) {
 		rc = IRQ_NONE;
 	} else if (hcd-&gt;driver-&gt;irq(hcd) == IRQ_NONE) {
 		rc = IRQ_NONE;
@@ -2132,6 +2149,8 @@ void usb_hc_died (struct usb_hcd *hcd)
 	dev_err (hcd-&gt;self.controller, "HC died; cleaning up\n");
 
 	spin_lock_irqsave (&amp;hcd_root_hub_lock, flags);
+	clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+	set_bit(HCD_FLAG_DEAD, &amp;hcd-&gt;flags);
 	if (hcd-&gt;rh_registered) {
 		clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
@@ -2274,6 +2293,12 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	 */
 	device_init_wakeup(&amp;rhdev-&gt;dev, 1);
 
+	/* HCD_FLAG_RH_RUNNING doesn't matter until the root hub is
+	 * registered.  But since the controller can die at any time,
+	 * let's initialize the flag before touching the hardware.
+	 */
+	set_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
+
 	/* "reset" is misnamed; its role is now one-time init. the controller
 	 * should already have been reset (and boot firmware kicked off etc).
 	 */
@@ -2341,6 +2366,7 @@ int usb_add_hcd(struct usb_hcd *hcd,
 	return retval;
 
 error_create_attr_group:
+	clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
 	if (HC_IS_RUNNING(hcd-&gt;state))
 		hcd-&gt;state = HC_STATE_QUIESCING;
 	spin_lock_irq(&amp;hcd_root_hub_lock);
@@ -2393,6 +2419,7 @@ void usb_remove_hcd(struct usb_hcd *hcd)
 	usb_get_dev(rhdev);
 	sysfs_remove_group(&amp;rhdev-&gt;dev.kobj, &amp;usb_bus_attr_group);
 
+	clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);
 	if (HC_IS_RUNNING (hcd-&gt;state))
 		hcd-&gt;state = HC_STATE_QUIESCING;
 
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index 9cfba4f2457b..8b65068c6af9 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -99,6 +99,8 @@ struct usb_hcd {
 #define HCD_FLAG_POLL_RH		2	/* poll for rh status? */
 #define HCD_FLAG_POLL_PENDING		3	/* status has changed? */
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
+#define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
+#define HCD_FLAG_DEAD			6	/* controller has died? */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -108,6 +110,8 @@ struct usb_hcd {
 #define HCD_POLL_RH(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_RH))
 #define HCD_POLL_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_POLL_PENDING))
 #define HCD_WAKEUP_PENDING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_WAKEUP_PENDING))
+#define HCD_RH_RUNNING(hcd)	((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_RH_RUNNING))
+#define HCD_DEAD(hcd)		((hcd)-&gt;flags &amp; (1U &lt;&lt; HCD_FLAG_DEAD))
 
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */</pre><hr><pre>commit 969e3033ae7733a0af8f7742ca74cd16c0857e71
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Feb 23 15:28:18 2011 -0500

    USB: serial drivers need to use larger bulk-in buffers
    
    When a driver doesn't know how much data a device is going to send,
    the buffer size should be at least as big as the endpoint's maxpacket
    value.  The serial drivers don't follow this rule; many of them
    request only 256-byte bulk-in buffers.  As a result, they suffer
    overflow errors if a high-speed device wants to send a lot of data,
    because high-speed bulk endpoints are required to have a maxpacket
    size of 512.
    
    This patch (as1450) fixes the problem by using the driver's
    bulk_in_size value as a minimum, always allocating buffers no smaller
    than the endpoint's maxpacket size.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Flynn Marquardt &lt;flynn@flynnux.de&gt;
    CC: &lt;stable@kernel.org&gt; [after .39-rc1 is out]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 546a52179bec..2ff90a9c8f47 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -911,9 +911,8 @@ int usb_serial_probe(struct usb_interface *interface,
 			dev_err(&amp;interface-&gt;dev, "No free urbs available\n");
 			goto probe_error;
 		}
-		buffer_size = serial-&gt;type-&gt;bulk_in_size;
-		if (!buffer_size)
-			buffer_size = le16_to_cpu(endpoint-&gt;wMaxPacketSize);
+		buffer_size = max_t(int, serial-&gt;type-&gt;bulk_in_size,
+				le16_to_cpu(endpoint-&gt;wMaxPacketSize));
 		port-&gt;bulk_in_size = buffer_size;
 		port-&gt;bulk_in_endpointAddress = endpoint-&gt;bEndpointAddress;
 		port-&gt;bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c9049139a7a5..45f3b9db4258 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -191,7 +191,8 @@ static inline void usb_set_serial_data(struct usb_serial *serial, void *data)
  * @id_table: pointer to a list of usb_device_id structures that define all
  *	of the devices this structure can support.
  * @num_ports: the number of different ports this device will have.
- * @bulk_in_size: bytes to allocate for bulk-in buffer (0 = end-point size)
+ * @bulk_in_size: minimum number of bytes to allocate for bulk-in buffer
+ *	(0 = end-point size)
  * @bulk_out_size: bytes to allocate for bulk-out buffer (0 = end-point size)
  * @calc_num_ports: pointer to a function to determine how many ports this
  *	device has dynamically.  It will be called after the probe()</pre><hr><pre>commit 3b29b68b1627781b5eecb581d3b9d5f0043a72f2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 22 09:53:41 2011 -0500

    USB: use "device number" instead of "address"
    
    The USB stack historically has conflated device numbers (i.e., the
    value of udev-&gt;devnum) with device addresses.  This is understandable,
    because until recently the two values were always the same.
    
    But with USB-3.0 they aren't the same, so we should start calling
    these things by their correct names.  This patch (as1449b) changes many
    of the references to "address" in the hub driver to "device number"
    or "devnum".
    
    The patch also removes some unnecessary or misleading comments.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Luben Tuikov &lt;ltuikov@yahoo.com&gt;
    Reviewed-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d041c6826e43..c168121f9f97 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1499,6 +1499,13 @@ void usb_set_device_state(struct usb_device *udev,
 EXPORT_SYMBOL_GPL(usb_set_device_state);
 
 /*
+ * Choose a device number.
+ *
+ * Device numbers are used as filenames in usbfs.  On USB-1.1 and
+ * USB-2.0 buses they are also used as device addresses, however on
+ * USB-3.0 buses the address is assigned by the controller hardware
+ * and it usually is not the same as the device number.
+ *
  * WUSB devices are simple: they have no hubs behind, so the mapping
  * device &lt;-&gt; virtual port number becomes 1:1. Why? to simplify the
  * life of the device connection logic in
@@ -1520,7 +1527,7 @@ EXPORT_SYMBOL_GPL(usb_set_device_state);
  * the HCD must setup data structures before issuing a set address
  * command to the hardware.
  */
-static void choose_address(struct usb_device *udev)
+static void choose_devnum(struct usb_device *udev)
 {
 	int		devnum;
 	struct usb_bus	*bus = udev-&gt;bus;
@@ -1545,7 +1552,7 @@ static void choose_address(struct usb_device *udev)
 	}
 }
 
-static void release_address(struct usb_device *udev)
+static void release_devnum(struct usb_device *udev)
 {
 	if (udev-&gt;devnum &gt; 0) {
 		clear_bit(udev-&gt;devnum, udev-&gt;bus-&gt;devmap.devicemap);
@@ -1553,7 +1560,7 @@ static void release_address(struct usb_device *udev)
 	}
 }
 
-static void update_address(struct usb_device *udev, int devnum)
+static void update_devnum(struct usb_device *udev, int devnum)
 {
 	/* The address for a WUSB device is managed by wusbcore. */
 	if (!udev-&gt;wusb)
@@ -1600,7 +1607,8 @@ void usb_disconnect(struct usb_device **pdev)
 	 * this quiesces everyting except pending urbs.
 	 */
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
-	dev_info (&amp;udev-&gt;dev, "USB disconnect, address %d\n", udev-&gt;devnum);
+	dev_info(&amp;udev-&gt;dev, "USB disconnect, device number %d\n",
+			udev-&gt;devnum);
 
 	usb_lock_device(udev);
 
@@ -1630,7 +1638,7 @@ void usb_disconnect(struct usb_device **pdev)
 	/* Free the device number and delete the parent's children[]
 	 * (or root_hub) pointer.
 	 */
-	release_address(udev);
+	release_devnum(udev);
 
 	/* Avoid races with recursively_mark_NOTATTACHED() */
 	spin_lock_irq(&amp;device_state_lock);
@@ -2071,7 +2079,7 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 		case 0:
 			/* TRSTRCY = 10 ms; plus some extra */
 			msleep(10 + 40);
-			update_address(udev, 0);
+			update_devnum(udev, 0);
 			if (hcd-&gt;driver-&gt;reset_device) {
 				status = hcd-&gt;driver-&gt;reset_device(hcd, udev);
 				if (status &lt; 0) {
@@ -2634,7 +2642,7 @@ static int hub_set_address(struct usb_device *udev, int devnum)
 				USB_REQ_SET_ADDRESS, 0, devnum, 0,
 				NULL, 0, USB_CTRL_SET_TIMEOUT);
 	if (retval == 0) {
-		update_address(udev, devnum);
+		update_devnum(udev, devnum);
 		/* Device now using proper address. */
 		usb_set_device_state(udev, USB_STATE_ADDRESS);
 		usb_ep0_reinit(udev);
@@ -2743,9 +2751,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	}
 	if (udev-&gt;speed != USB_SPEED_SUPER)
 		dev_info(&amp;udev-&gt;dev,
-				"%s %s speed %sUSB device using %s and address %d\n",
+				"%s %s speed %sUSB device number %d using %s\n",
 				(udev-&gt;config) ? "reset" : "new", speed, type,
-				udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, devnum);
+				devnum, udev-&gt;bus-&gt;controller-&gt;driver-&gt;name);
 
 	/* Set up TT records, if needed  */
 	if (hdev-&gt;tt) {
@@ -2775,10 +2783,6 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 	 * value.
 	 */
 	for (i = 0; i &lt; GET_DESCRIPTOR_TRIES; (++i, msleep(100))) {
-		/*
-		 * An xHCI controller cannot send any packets to a device until
-		 * a set address command successfully completes.
-		 */
 		if (USE_NEW_SCHEME(retry_counter) &amp;&amp; !(hcd-&gt;driver-&gt;flags &amp; HCD_USB3)) {
 			struct usb_device_descriptor *buf;
 			int r = 0;
@@ -2861,9 +2865,9 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 			if (udev-&gt;speed == USB_SPEED_SUPER) {
 				devnum = udev-&gt;devnum;
 				dev_info(&amp;udev-&gt;dev,
-						"%s SuperSpeed USB device using %s and address %d\n",
+						"%s SuperSpeed USB device number %d using %s\n",
 						(udev-&gt;config) ? "reset" : "new",
-						udev-&gt;bus-&gt;controller-&gt;driver-&gt;name, devnum);
+						devnum, udev-&gt;bus-&gt;controller-&gt;driver-&gt;name);
 			}
 
 			/* cope with hardware quirkiness:
@@ -2926,7 +2930,7 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 fail:
 	if (retval) {
 		hub_port_disable(hub, port1, 0);
-		update_address(udev, devnum);	/* for disconnect processing */
+		update_devnum(udev, devnum);	/* for disconnect processing */
 	}
 	mutex_unlock(&amp;usb_address0_mutex);
 	return retval;
@@ -3135,15 +3139,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		else
 			udev-&gt;speed = USB_SPEED_UNKNOWN;
 
-		/*
-		 * Set the address.
-		 * Note xHCI needs to issue an address device command later
-		 * in the hub_port_init sequence for SS/HS/FS/LS devices,
-		 * and xHC will assign an address to the device. But use
-		 * kernel assigned address here, to avoid any address conflict
-		 * issue.
-		 */
-		choose_address(udev);
+		choose_devnum(udev);
 		if (udev-&gt;devnum &lt;= 0) {
 			status = -ENOTCONN;	/* Don't retry */
 			goto loop;
@@ -3235,7 +3231,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		hub_port_disable(hub, port1, 1);
 loop:
 		usb_ep0_reinit(udev);
-		release_address(udev);
+		release_devnum(udev);
 		hub_free_dev(udev);
 		usb_put_dev(udev);
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))</pre><hr><pre>commit 3c18e30f87ac5466bddbb05cf955605efd7db025
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 17 10:26:38 2011 -0500

    USB: add quirks entry for Keytouch QWERTY Panel
    
    This patch (as1448) adds a quirks entry for the Keytouch QWERTY Panel
    firmware, used in the IEC 60945 keyboard.  This device crashes during
    enumeration when the computer asks for its configuration string
    descriptor.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: kholis &lt;nur.kholis.majid@gmail.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 44c595432d6f..92ce90b83126 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -68,6 +68,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	/* M-Systems Flash Disk Pioneers */
 	{ USB_DEVICE(0x08ec, 0x1000), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	/* Keytouch QWERTY Panel keyboard */
+	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
+			USB_QUIRK_CONFIG_INTF_STRINGS },
+
 	/* X-Rite/Gretag-Macbeth Eye-One Pro display colorimeter */
 	{ USB_DEVICE(0x0971, 0x2000), .driver_info = USB_QUIRK_NO_SET_INTF },
 </pre><hr><pre>commit 3ea3c9b5a8464ec8223125f95e5dddb3bfd02a39
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 25 13:07:04 2011 -0500

    USB: usb-storage: unusual_devs entry for Coby MP3 player
    
    This patch (as1444) adds an unusual_devs entry for an MP3 player from
    Coby electronics.  The device has two nasty bugs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Jasper Mackenzie &lt;scarletpimpernal@hotmail.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 79d76da91da0..c1602b8c5594 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1897,6 +1897,13 @@ UNUSUAL_DEV(  0x1e68, 0x001b, 0x0000, 0x0000,
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE | US_FL_SANE_SENSE ),
 
+/* Reported by Jasper Mackenzie &lt;scarletpimpernal@hotmail.com&gt; */
+UNUSUAL_DEV( 0x1e74, 0x4621, 0x0000, 0x0000,
+		"Coby Electronics",
+		"MP3 Player",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_BULK_IGNORE_TAG | US_FL_MAX_SECTORS_64 ),
+
 UNUSUAL_DEV( 0x2116, 0x0320, 0x0001, 0x0001,
 		"ST",
 		"2A",</pre><hr><pre>commit bf3d7d40e42a85ca73a34e1385ff34f092a384eb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Feb 2 13:59:33 2011 -0500

    USB: fix race between root-hub resume and wakeup requests
    
    The USB core keeps track of pending resume requests for root hubs, in
    order to resolve races between wakeup requests and suspends.  However
    the code that does this is subject to another race (between wakeup
    requests and resumes) because the WAKEUP_PENDING flag is cleared
    before the resume occurs, leaving a window in which another wakeup
    request might arrive.
    
    This patch (as1447) fixes the problem by clearing the WAKEUP_PENDING
    flag after the resume instead of before it.
    
    This fixes Bugzilla #24952.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Paul Bender &lt;pebender@san.rr.com&gt;
    Tested-by: warpme &lt;warpme@o2.pl&gt;
    Cc: stable &lt;stable@kernel.org&gt; [.36+]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 6a95017fa62b..e935f71d7a34 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1955,7 +1955,6 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 
 	dev_dbg(&amp;rhdev-&gt;dev, "usb %s%s\n",
 			(msg.event &amp; PM_EVENT_AUTO ? "auto-" : ""), "resume");
-	clear_bit(HCD_FLAG_WAKEUP_PENDING, &amp;hcd-&gt;flags);
 	if (!hcd-&gt;driver-&gt;bus_resume)
 		return -ENOENT;
 	if (hcd-&gt;state == HC_STATE_RUNNING)
@@ -1963,6 +1962,7 @@ int hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)
 
 	hcd-&gt;state = HC_STATE_RESUMING;
 	status = hcd-&gt;driver-&gt;bus_resume(hcd);
+	clear_bit(HCD_FLAG_WAKEUP_PENDING, &amp;hcd-&gt;flags);
 	if (status == 0) {
 		/* TRSMRCY = 10 msec */
 		msleep(10);</pre><hr><pre>commit d199c96d41d80a567493e12b8e96ea056a1350c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 31 10:56:37 2011 -0500

    USB: prevent buggy hubs from crashing the USB stack
    
    If anyone comes across a high-speed hub that (by mistake or by design)
    claims to have no Transaction Translators, plugging a full- or
    low-speed device into it will cause the USB stack to crash.  This
    patch (as1446) prevents the problem by ignoring such devices, since
    the kernel has no way to communicate with them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Perry Neben &lt;neben@vmware.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4310cc4b1cb5..d041c6826e43 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2753,6 +2753,11 @@ hub_port_init (struct usb_hub *hub, struct usb_device *udev, int port1,
 		udev-&gt;ttport = hdev-&gt;ttport;
 	} else if (udev-&gt;speed != USB_SPEED_HIGH
 			&amp;&amp; hdev-&gt;speed == USB_SPEED_HIGH) {
+		if (!hub-&gt;tt.hub) {
+			dev_err(&amp;udev-&gt;dev, "parent hub has no TT\n");
+			retval = -EINVAL;
+			goto fail;
+		}
 		udev-&gt;tt = &amp;hub-&gt;tt;
 		udev-&gt;ttport = port1;
 	}</pre><hr><pre>commit c3810c88788d505d4ffd786addd111b745e42161
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 25 20:50:07 2011 +0100

    PM / Runtime: Don't enable interrupts while running in_interrupt
    
    This patch (as1445) fixes a bug in the runtime PM core left over from
    the addition of the no_callbacks flag.  If this flag is set then it is
    possible for rpm_suspend() to be called in_interrupt, so when
    releasing spinlocks it's important not to re-enable interrupts.
    
    To avoid an unnecessary save-and-restore of the interrupt flag, the
    patch also inlines a pm_request_idle() call.
    
    This fixes Bugzilla #27482.
    
    (The offending code was added in 2.6.37, so it's not necessary to apply
    this to any earlier stable kernels.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: tim blechmann &lt;tim@klingt.org&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 656493a5e073..42615b419dfb 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -407,12 +407,15 @@ static int rpm_suspend(struct device *dev, int rpmflags)
 		goto out;
 	}
 
+	/* Maybe the parent is now able to suspend. */
 	if (parent &amp;&amp; !parent-&gt;power.ignore_children &amp;&amp; !dev-&gt;power.irq_safe) {
-		spin_unlock_irq(&amp;dev-&gt;power.lock);
+		spin_unlock(&amp;dev-&gt;power.lock);
 
-		pm_request_idle(parent);
+		spin_lock(&amp;parent-&gt;power.lock);
+		rpm_idle(parent, RPM_ASYNC);
+		spin_unlock(&amp;parent-&gt;power.lock);
 
-		spin_lock_irq(&amp;dev-&gt;power.lock);
+		spin_lock(&amp;dev-&gt;power.lock);
 	}
 
  out:</pre><hr><pre>commit 5620b5f7f19e9ee3fcf6ecf493fed7821b7b495b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 11 14:16:50 2011 -0500

    USB serial: add missing .usb_driver field in serial drivers
    
    This patch (as1443) fixes a bug found in many of the USB serial
    drivers: They don't set the .usb_driver field in their
    usb_serial_driver structure.  This field is needed for assigning
    dynamic IDs for device matching.
    
    In addition, starting with the 2.6.37 kernel, the .usb_driver field is
    needed for proper autosuspend operation.  Without it, attempts to open
    the device file will fail.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Dan Williams &lt;dcbw@redhat.com&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/io_tables.h b/drivers/usb/serial/io_tables.h
index 6ab2a3f97fe8..178b22eb32b1 100644
--- a/drivers/usb/serial/io_tables.h
+++ b/drivers/usb/serial/io_tables.h
@@ -199,6 +199,7 @@ static struct usb_serial_driver epic_device = {
 		.name		= "epic",
 	},
 	.description		= "EPiC device",
+	.usb_driver		= &amp;io_driver,
 	.id_table		= Epic_port_id_table,
 	.num_ports		= 1,
 	.open			= edge_open,
diff --git a/drivers/usb/serial/iuu_phoenix.c b/drivers/usb/serial/iuu_phoenix.c
index 12ed594f5f80..99b97c04896f 100644
--- a/drivers/usb/serial/iuu_phoenix.c
+++ b/drivers/usb/serial/iuu_phoenix.c
@@ -1275,6 +1275,7 @@ static struct usb_serial_driver iuu_device = {
 		   .name = "iuu_phoenix",
 		   },
 	.id_table = id_table,
+	.usb_driver = &amp;iuu_driver,
 	.num_ports = 1,
 	.bulk_in_size = 512,
 	.bulk_out_size = 512,
diff --git a/drivers/usb/serial/keyspan.h b/drivers/usb/serial/keyspan.h
index 2d8baf6ac472..ce134dc28ddf 100644
--- a/drivers/usb/serial/keyspan.h
+++ b/drivers/usb/serial/keyspan.h
@@ -546,6 +546,7 @@ static struct usb_serial_driver keyspan_pre_device = {
 		.name		= "keyspan_no_firm",
 	},
 	.description		= "Keyspan - (without firmware)",
+	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_pre_ids,
 	.num_ports		= 1,
 	.attach			= keyspan_fake_startup,
@@ -557,6 +558,7 @@ static struct usb_serial_driver keyspan_1port_device = {
 		.name		= "keyspan_1",
 	},
 	.description		= "Keyspan 1 port adapter",
+	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_1port_ids,
 	.num_ports		= 1,
 	.open			= keyspan_open,
@@ -579,6 +581,7 @@ static struct usb_serial_driver keyspan_2port_device = {
 		.name		= "keyspan_2",
 	},
 	.description		= "Keyspan 2 port adapter",
+	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_2port_ids,
 	.num_ports		= 2,
 	.open			= keyspan_open,
@@ -601,6 +604,7 @@ static struct usb_serial_driver keyspan_4port_device = {
 		.name		= "keyspan_4",
 	},
 	.description		= "Keyspan 4 port adapter",
+	.usb_driver		= &amp;keyspan_driver,
 	.id_table		= keyspan_4port_ids,
 	.num_ports		= 4,
 	.open			= keyspan_open,
diff --git a/drivers/usb/serial/moto_modem.c b/drivers/usb/serial/moto_modem.c
index cf1718394e18..653465f61d4a 100644
--- a/drivers/usb/serial/moto_modem.c
+++ b/drivers/usb/serial/moto_modem.c
@@ -44,6 +44,7 @@ static struct usb_serial_driver moto_device = {
 		.name =		"moto-modem",
 	},
 	.id_table =		id_table,
+	.usb_driver =		&amp;moto_driver,
 	.num_ports =		1,
 };
 
diff --git a/drivers/usb/serial/oti6858.c b/drivers/usb/serial/oti6858.c
index 5be866bb7a41..73613205be7a 100644
--- a/drivers/usb/serial/oti6858.c
+++ b/drivers/usb/serial/oti6858.c
@@ -157,6 +157,7 @@ static struct usb_serial_driver oti6858_device = {
 		.name =		"oti6858",
 	},
 	.id_table =		id_table,
+	.usb_driver =		&amp;oti6858_driver,
 	.num_ports =		1,
 	.open =			oti6858_open,
 	.close =		oti6858_close,
diff --git a/drivers/usb/serial/qcaux.c b/drivers/usb/serial/qcaux.c
index b53865b8cd9c..30b73e68a904 100644
--- a/drivers/usb/serial/qcaux.c
+++ b/drivers/usb/serial/qcaux.c
@@ -86,6 +86,7 @@ static struct usb_serial_driver qcaux_device = {
 		.name =		"qcaux",
 	},
 	.id_table =		id_table,
+	.usb_driver =		&amp;qcaux_driver,
 	.num_ports =		1,
 };
 
diff --git a/drivers/usb/serial/siemens_mpi.c b/drivers/usb/serial/siemens_mpi.c
index cb8195cabfde..74cd4ccdb3fc 100644
--- a/drivers/usb/serial/siemens_mpi.c
+++ b/drivers/usb/serial/siemens_mpi.c
@@ -42,6 +42,7 @@ static struct usb_serial_driver siemens_usb_mpi_device = {
 		.name =		"siemens_mpi",
 	},
 	.id_table =		id_table,
+	.usb_driver =		&amp;siemens_usb_mpi_driver,
 	.num_ports =		1,
 };
 
diff --git a/drivers/usb/serial/spcp8x5.c b/drivers/usb/serial/spcp8x5.c
index 765aa983bf58..c7665d39d192 100644
--- a/drivers/usb/serial/spcp8x5.c
+++ b/drivers/usb/serial/spcp8x5.c
@@ -645,6 +645,7 @@ static struct usb_serial_driver spcp8x5_device = {
 		.name =		"SPCP8x5",
 	},
 	.id_table		= id_table,
+	.usb_driver		= &amp;spcp8x5_driver,
 	.num_ports		= 1,
 	.open 			= spcp8x5_open,
 	.dtr_rts		= spcp8x5_dtr_rts,
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 6954de50c0ff..546a52179bec 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -1344,11 +1344,15 @@ int usb_serial_register(struct usb_serial_driver *driver)
 		return -ENODEV;
 
 	fixup_generic(driver);
-	if (driver-&gt;usb_driver)
-		driver-&gt;usb_driver-&gt;supports_autosuspend = 1;
 
 	if (!driver-&gt;description)
 		driver-&gt;description = driver-&gt;driver.name;
+	if (!driver-&gt;usb_driver) {
+		WARN(1, "Serial driver %s has no usb_driver\n",
+				driver-&gt;description);
+		return -EINVAL;
+	}
+	driver-&gt;usb_driver-&gt;supports_autosuspend = 1;
 
 	/* Add this device to our list of devices */
 	mutex_lock(&amp;table_lock);
diff --git a/drivers/usb/serial/usb_debug.c b/drivers/usb/serial/usb_debug.c
index f2ed6a31be77..95a82148ee81 100644
--- a/drivers/usb/serial/usb_debug.c
+++ b/drivers/usb/serial/usb_debug.c
@@ -75,6 +75,7 @@ static struct usb_serial_driver debug_device = {
 		.name =		"debug",
 	},
 	.id_table =		id_table,
+	.usb_driver =		&amp;debug_driver,
 	.num_ports =		1,
 	.bulk_out_size =	USB_DEBUG_MAX_PACKET_SIZE,
 	.break_ctl =		usb_debug_break_ctl,</pre><hr><pre>commit ad84e4a9efb7c8ed322bafb6ebdb9c3a49a3d3a8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 10 11:24:14 2011 -0500

    USB: g_printer: fix bug in module parameter definitions
    
    This patch (as1442) fixes a bug in g_printer: Module parameters should
    not be marked "__initdata" if they are accessible in sysfs (i.e., if
    the mode value in the module_param() macro is nonzero).  Otherwise
    attempts to access the parameters will cause addressing violations.
    
    Character-string module parameters must not be marked "__initdata"
    if the module can be unloaded, because the kernel needs to access the
    parameter variable at unload time in order to free the
    dynamically-allocated string.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Roland Kletzing &lt;devzero@web.de&gt;
    CC: Craig W. Nadler &lt;craig@nadler.us&gt;
    CC: &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/printer.c b/drivers/usb/gadget/printer.c
index dacc67724fe1..12ff6cffedc9 100644
--- a/drivers/usb/gadget/printer.c
+++ b/drivers/usb/gadget/printer.c
@@ -131,31 +131,31 @@ static struct printer_dev usb_printer_gadget;
  * parameters are in UTF-8 (superset of ASCII's 7 bit characters).
  */
 
-static ushort __initdata idVendor;
+static ushort idVendor;
 module_param(idVendor, ushort, S_IRUGO);
 MODULE_PARM_DESC(idVendor, "USB Vendor ID");
 
-static ushort __initdata idProduct;
+static ushort idProduct;
 module_param(idProduct, ushort, S_IRUGO);
 MODULE_PARM_DESC(idProduct, "USB Product ID");
 
-static ushort __initdata bcdDevice;
+static ushort bcdDevice;
 module_param(bcdDevice, ushort, S_IRUGO);
 MODULE_PARM_DESC(bcdDevice, "USB Device version (BCD)");
 
-static char *__initdata iManufacturer;
+static char *iManufacturer;
 module_param(iManufacturer, charp, S_IRUGO);
 MODULE_PARM_DESC(iManufacturer, "USB Manufacturer string");
 
-static char *__initdata iProduct;
+static char *iProduct;
 module_param(iProduct, charp, S_IRUGO);
 MODULE_PARM_DESC(iProduct, "USB Product string");
 
-static char *__initdata iSerialNum;
+static char *iSerialNum;
 module_param(iSerialNum, charp, S_IRUGO);
 MODULE_PARM_DESC(iSerialNum, "1");
 
-static char *__initdata iPNPstring;
+static char *iPNPstring;
 module_param(iPNPstring, charp, S_IRUGO);
 MODULE_PARM_DESC(iPNPstring, "MFG:linux;MDL:g_printer;CLS:PRINTER;SN:1;");
 </pre>
    <div class="pagination">
        <a href='2_58.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><span>[59]</span><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_60.html'>Next&gt;&gt;</a>
    <div>
</body>
