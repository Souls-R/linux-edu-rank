<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_18.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><span>[19]</span><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_20.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 32bf9fd50ff439184ddcf925cfb3c6bc0138f7c5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 25 10:40:05 2017 -0400

    usb-storage: make use of srb local variable
    
    Commit 8b52291a0743 ("usb-storage: fix deadlock involving host lock
    and scsi_done") added a local variable to usb_stor_control_thread() in
    the usb-storage driver.  This local variable holds the value of
    us-&gt;srb, for use after the host lock has been released.
    
    But as long as we have the value in a local variable, we may as well
    use it instead of dereferencing the us pointer all over the place.
    This patch makes no functional change; it just makes the code a little
    shorter and a little neater.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 0dceb9fa3a06..1ae2b8554a88 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -332,7 +332,7 @@ static int usb_stor_control_thread(void * __us)
 
 		/* When we are called with no command pending, we're done */
 		srb = us-&gt;srb;
-		if (us-&gt;srb == NULL) {
+		if (srb == NULL) {
 			scsi_unlock(host);
 			mutex_unlock(&amp;us-&gt;dev_mutex);
 			usb_stor_dbg(us, "-- exiting\n");
@@ -341,7 +341,7 @@ static int usb_stor_control_thread(void * __us)
 
 		/* has the command timed out *already* ? */
 		if (test_bit(US_FLIDX_TIMED_OUT, &amp;us-&gt;dflags)) {
-			us-&gt;srb-&gt;result = DID_ABORT &lt;&lt; 16;
+			srb-&gt;result = DID_ABORT &lt;&lt; 16;
 			goto SkipForAbort;
 		}
 
@@ -351,35 +351,35 @@ static int usb_stor_control_thread(void * __us)
 		 * reject the command if the direction indicator
 		 * is UNKNOWN
 		 */
-		if (us-&gt;srb-&gt;sc_data_direction == DMA_BIDIRECTIONAL) {
+		if (srb-&gt;sc_data_direction == DMA_BIDIRECTIONAL) {
 			usb_stor_dbg(us, "UNKNOWN data direction\n");
-			us-&gt;srb-&gt;result = DID_ERROR &lt;&lt; 16;
+			srb-&gt;result = DID_ERROR &lt;&lt; 16;
 		}
 
 		/*
 		 * reject if target != 0 or if LUN is higher than
 		 * the maximum known LUN
 		 */
-		else if (us-&gt;srb-&gt;device-&gt;id &amp;&amp;
+		else if (srb-&gt;device-&gt;id &amp;&amp;
 				!(us-&gt;fflags &amp; US_FL_SCM_MULT_TARG)) {
 			usb_stor_dbg(us, "Bad target number (%d:%llu)\n",
-				     us-&gt;srb-&gt;device-&gt;id,
-				     us-&gt;srb-&gt;device-&gt;lun);
-			us-&gt;srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
+				     srb-&gt;device-&gt;id,
+				     srb-&gt;device-&gt;lun);
+			srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
 		}
 
-		else if (us-&gt;srb-&gt;device-&gt;lun &gt; us-&gt;max_lun) {
+		else if (srb-&gt;device-&gt;lun &gt; us-&gt;max_lun) {
 			usb_stor_dbg(us, "Bad LUN (%d:%llu)\n",
-				     us-&gt;srb-&gt;device-&gt;id,
-				     us-&gt;srb-&gt;device-&gt;lun);
-			us-&gt;srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
+				     srb-&gt;device-&gt;id,
+				     srb-&gt;device-&gt;lun);
+			srb-&gt;result = DID_BAD_TARGET &lt;&lt; 16;
 		}
 
 		/*
 		 * Handle those devices which need us to fake
 		 * their inquiry data
 		 */
-		else if ((us-&gt;srb-&gt;cmnd[0] == INQUIRY) &amp;&amp;
+		else if ((srb-&gt;cmnd[0] == INQUIRY) &amp;&amp;
 			    (us-&gt;fflags &amp; US_FL_FIX_INQUIRY)) {
 			unsigned char data_ptr[36] = {
 			    0x00, 0x80, 0x02, 0x02,
@@ -387,13 +387,13 @@ static int usb_stor_control_thread(void * __us)
 
 			usb_stor_dbg(us, "Faking INQUIRY command\n");
 			fill_inquiry_response(us, data_ptr, 36);
-			us-&gt;srb-&gt;result = SAM_STAT_GOOD;
+			srb-&gt;result = SAM_STAT_GOOD;
 		}
 
 		/* we've got a command, let's do it! */
 		else {
-			US_DEBUG(usb_stor_show_command(us, us-&gt;srb));
-			us-&gt;proto_handler(us-&gt;srb, us);
+			US_DEBUG(usb_stor_show_command(us, srb));
+			us-&gt;proto_handler(srb, us);
 			usb_mark_last_busy(us-&gt;pusb_dev);
 		}
 
@@ -401,7 +401,7 @@ static int usb_stor_control_thread(void * __us)
 		scsi_lock(host);
 
 		/* was the command aborted? */
-		if (us-&gt;srb-&gt;result == DID_ABORT &lt;&lt; 16) {
+		if (srb-&gt;result == DID_ABORT &lt;&lt; 16) {
 SkipForAbort:
 			usb_stor_dbg(us, "scsi command aborted\n");
 			srb = NULL;	/* Don't call srb-&gt;scsi_done() */</pre><hr><pre>commit 1c0edc3633b56000e18d82fc241e3995ca18a69e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 18 12:49:38 2017 -0400

    USB: core: fix out-of-bounds access bug in usb_get_bos_descriptor()
    
    Andrey used the syzkaller fuzzer to find an out-of-bounds memory
    access in usb_get_bos_descriptor().  The code wasn't checking that the
    next usb_dev_cap_header structure could fit into the remaining buffer
    space.
    
    This patch fixes the error and also reduces the bNumDeviceCaps field
    in the header to match the actual number of capabilities found, in
    cases where there are fewer than expected.
    
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 68b54bd88d1e..883549ee946c 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -960,10 +960,12 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 	for (i = 0; i &lt; num; i++) {
 		buffer += length;
 		cap = (struct usb_dev_cap_header *)buffer;
-		length = cap-&gt;bLength;
 
-		if (total_len &lt; length)
+		if (total_len &lt; sizeof(*cap) || total_len &lt; cap-&gt;bLength) {
+			dev-&gt;bos-&gt;desc-&gt;bNumDeviceCaps = i;
 			break;
+		}
+		length = cap-&gt;bLength;
 		total_len -= length;
 
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {</pre><hr><pre>commit 7c80f9e4a588f1925b07134bb2e3689335f6c6d8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 29 10:54:24 2017 -0400

    usb: usbtest: fix NULL pointer dereference
    
    If the usbtest driver encounters a device with an IN bulk endpoint but
    no OUT bulk endpoint, it will try to dereference a NULL pointer
    (out-&gt;desc.bEndpointAddress).  The problem can be solved by adding a
    missing test.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 113e38bfe0ef..b3fc602b2e24 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -202,12 +202,13 @@ get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
 			return tmp;
 	}
 
-	if (in) {
+	if (in)
 		dev-&gt;in_pipe = usb_rcvbulkpipe(udev,
 			in-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
+	if (out)
 		dev-&gt;out_pipe = usb_sndbulkpipe(udev,
 			out-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
-	}
+
 	if (iso_in) {
 		dev-&gt;iso_in = &amp;iso_in-&gt;desc;
 		dev-&gt;in_iso_pipe = usb_rcvisocpipe(udev,</pre><hr><pre>commit ab219221a5064abfff9f78c323c4a257b16cdb81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 6 10:27:44 2017 -0400

    USB: dummy-hcd: Fix deadlock caused by disconnect detection
    
    The dummy-hcd driver calls the gadget driver's disconnect callback
    under the wrong conditions.  It should invoke the callback when Vbus
    power is turned off, but instead it does so when the D+ pullup is
    turned off.
    
    This can cause a deadlock in the composite core when a gadget driver
    is unregistered:
    
    [   88.361471] ============================================
    [   88.362014] WARNING: possible recursive locking detected
    [   88.362580] 4.14.0-rc2+ #9 Not tainted
    [   88.363010] --------------------------------------------
    [   88.363561] v4l_id/526 is trying to acquire lock:
    [   88.364062]  (&amp;(&amp;cdev-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa0547e03&gt;] composite_disconnect+0x43/0x100 [libcomposite]
    [   88.365051]
    [   88.365051] but task is already holding lock:
    [   88.365826]  (&amp;(&amp;cdev-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa0547b09&gt;] usb_function_deactivate+0x29/0x80 [libcomposite]
    [   88.366858]
    [   88.366858] other info that might help us debug this:
    [   88.368301]  Possible unsafe locking scenario:
    [   88.368301]
    [   88.369304]        CPU0
    [   88.369701]        ----
    [   88.370101]   lock(&amp;(&amp;cdev-&gt;lock)-&gt;rlock);
    [   88.370623]   lock(&amp;(&amp;cdev-&gt;lock)-&gt;rlock);
    [   88.371145]
    [   88.371145]  *** DEADLOCK ***
    [   88.371145]
    [   88.372211]  May be due to missing lock nesting notation
    [   88.372211]
    [   88.373191] 2 locks held by v4l_id/526:
    [   88.373715]  #0:  (&amp;(&amp;cdev-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa0547b09&gt;] usb_function_deactivate+0x29/0x80 [libcomposite]
    [   88.374814]  #1:  (&amp;(&amp;dum_hcd-&gt;dum-&gt;lock)-&gt;rlock){....}, at: [&lt;ffffffffa05bd48d&gt;] dummy_pullup+0x7d/0xf0 [dummy_hcd]
    [   88.376289]
    [   88.376289] stack backtrace:
    [   88.377726] CPU: 0 PID: 526 Comm: v4l_id Not tainted 4.14.0-rc2+ #9
    [   88.378557] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014
    [   88.379504] Call Trace:
    [   88.380019]  dump_stack+0x86/0xc7
    [   88.380605]  __lock_acquire+0x841/0x1120
    [   88.381252]  lock_acquire+0xd5/0x1c0
    [   88.381865]  ? composite_disconnect+0x43/0x100 [libcomposite]
    [   88.382668]  _raw_spin_lock_irqsave+0x40/0x54
    [   88.383357]  ? composite_disconnect+0x43/0x100 [libcomposite]
    [   88.384290]  composite_disconnect+0x43/0x100 [libcomposite]
    [   88.385490]  set_link_state+0x2d4/0x3c0 [dummy_hcd]
    [   88.386436]  dummy_pullup+0xa7/0xf0 [dummy_hcd]
    [   88.387195]  usb_gadget_disconnect+0xd8/0x160 [udc_core]
    [   88.387990]  usb_gadget_deactivate+0xd3/0x160 [udc_core]
    [   88.388793]  usb_function_deactivate+0x64/0x80 [libcomposite]
    [   88.389628]  uvc_function_disconnect+0x1e/0x40 [usb_f_uvc]
    
    This patch changes the code to test the port-power status bit rather
    than the port-connect status bit when deciding whether to isue the
    callback.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: David Tulloh &lt;david@tulloh.id.au&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index b17618a55f1b..f04e91ef9e7c 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -419,6 +419,7 @@ static void set_link_state_by_speed(struct dummy_hcd *dum_hcd)
 static void set_link_state(struct dummy_hcd *dum_hcd)
 {
 	struct dummy *dum = dum_hcd-&gt;dum;
+	unsigned int power_bit;
 
 	dum_hcd-&gt;active = 0;
 	if (dum-&gt;pullup)
@@ -429,17 +430,19 @@ static void set_link_state(struct dummy_hcd *dum_hcd)
 			return;
 
 	set_link_state_by_speed(dum_hcd);
+	power_bit = (dummy_hcd_to_hcd(dum_hcd)-&gt;speed == HCD_USB3 ?
+			USB_SS_PORT_STAT_POWER : USB_PORT_STAT_POWER);
 
 	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 ||
 	     dum_hcd-&gt;active)
 		dum_hcd-&gt;resuming = 0;
 
 	/* Currently !connected or in reset */
-	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||
+	if ((dum_hcd-&gt;port_status &amp; power_bit) == 0 ||
 			(dum_hcd-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
-		unsigned disconnect = USB_PORT_STAT_CONNECTION &amp;
+		unsigned int disconnect = power_bit &amp;
 				dum_hcd-&gt;old_status &amp; (~dum_hcd-&gt;port_status);
-		unsigned reset = USB_PORT_STAT_RESET &amp;
+		unsigned int reset = USB_PORT_STAT_RESET &amp;
 				(~dum_hcd-&gt;old_status) &amp; dum_hcd-&gt;port_status;
 
 		/* Report reset and disconnect events to the driver */</pre><hr><pre>commit c9f20aafc939cc4091757c4d033feb010445f15d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 15:15:58 2017 -0400

    USB: dummy-hcd: remove unsupported isochronous endpoints
    
    The dummy-hcd driver doesn't support emulation of isochronous
    transfers.  Therefore it doesn't need to export isochronous endpoint
    descriptors; they can be commented out.
    
    Also, the comments in the source code don't express clearly enough the
    fact that isochronous isn't supported.  They need to be more explicit.
    
    Finally, change the error status value we use (in theory) for
    isochronous URBs.  checkpatch complains about ENOSYS; EINVAL is more
    appropriate (it is documented to mean "ISO madness").
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index d177d63e16d7..671338827951 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -23,6 +23,8 @@
  *
  * Having this all in one kernel can help some stages of development,
  * bypassing some hardware (and driver) issues.  UML could help too.
+ *
+ * Note: The emulation does not include isochronous transfers!
  */
 
 #include &lt;linux/module.h&gt;
@@ -137,6 +139,9 @@ static const struct {
 		.caps = _caps, \
 	}
 
+/* we don't provide isochronous endpoints since we don't support them */
+#define TYPE_BULK_OR_INT	(USB_EP_CAPS_TYPE_BULK | USB_EP_CAPS_TYPE_INT)
+
 	/* everyone has ep0 */
 	EP_INFO(ep0name,
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_ALL)),
@@ -145,64 +150,72 @@ static const struct {
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep2out-bulk",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),
+/*
 	EP_INFO("ep3in-iso",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep4out-iso",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_OUT)),
+*/
 	EP_INFO("ep5in-int",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep6in-bulk",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep7out-bulk",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),
+/*
 	EP_INFO("ep8in-iso",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep9out-iso",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_OUT)),
+*/
 	EP_INFO("ep10in-int",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep11in-bulk",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep12out-bulk",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),
+/*
 	EP_INFO("ep13in-iso",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep14out-iso",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO, USB_EP_CAPS_DIR_OUT)),
+*/
 	EP_INFO("ep15in-int",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),
+
 	/* or like sa1100: two fixed function endpoints */
 	EP_INFO("ep1out-bulk",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep2in-bulk",
 		USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),
+
 	/* and now some generic EPs so we have enough in multi config */
 	EP_INFO("ep3out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep4in",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep5out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep6out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep7in",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep8out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep9in",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep10out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep11out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep12in",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep13out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 	EP_INFO("ep14in",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),
 	EP_INFO("ep15out",
-		USB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),
+		USB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),
 
 #undef EP_INFO
 };
@@ -1923,13 +1936,17 @@ static void dummy_timer(unsigned long _dum_hcd)
 		limit = total;
 		switch (usb_pipetype(urb-&gt;pipe)) {
 		case PIPE_ISOCHRONOUS:
-			/* FIXME is it urb-&gt;interval since the last xfer?
-			 * use urb-&gt;iso_frame_desc[i].
-			 * complete whether or not ep has requests queued.
-			 * report random errors, to debug drivers.
+			/*
+			 * We don't support isochronous.  But if we did,
+			 * here are some of the issues we'd have to face:
+			 *
+			 * Is it urb-&gt;interval since the last xfer?
+			 * Use urb-&gt;iso_frame_desc[i].
+			 * Complete whether or not ep has requests queued.
+			 * Report random errors, to debug drivers.
 			 */
 			limit = max(limit, periodic_bytes(dum, ep));
-			status = -ENOSYS;
+			status = -EINVAL;	/* fail all xfers */
 			break;
 
 		case PIPE_INTERRUPT:</pre><hr><pre>commit ffc4ea79bc06f42283da10ea06bb17b9a3e2b2b4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 15:16:05 2017 -0400

    USB: dummy-hcd: bandwidth limits for non-bulk transfers
    
    Part of the emulation performed by dummy-hcd is accounting for
    bandwidth utilization.  The total amount of data transferred in a
    single frame is supposed to be no larger than an actual USB connection
    could accommodate.
    
    Currently the driver performs bandwidth limiting only for bulk
    transfers; control and periodic transfers are effectively unlimited.
    (Presumably drivers were not expected to request extremely large
    control or interrupt transfers.)  This patch improves the situation
    somewhat by restricting them as well.
    
    The emulation still isn't perfect.  On a real system, even 0-length
    transfers use some bandwidth because of transaction overhead
    (IN, OUT, ACK, NACK packets) and packet overhead (SYNC, PID, bit
    stuffing, CRC, EOP).  Adding in those factors is left as an exercise
    for a later patch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index b17618a55f1b..d177d63e16d7 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -1766,6 +1766,7 @@ static void dummy_timer(unsigned long _dum_hcd)
 	int			i;
 
 	/* simplistic model for one frame's bandwidth */
+	/* FIXME: account for transaction and packet overhead */
 	switch (dum-&gt;gadget.speed) {
 	case USB_SPEED_LOW:
 		total = 8/*bytes*/ * 12/*packets*/;
@@ -1810,7 +1811,6 @@ static void dummy_timer(unsigned long _dum_hcd)
 		struct dummy_request	*req;
 		u8			address;
 		struct dummy_ep		*ep = NULL;
-		int			type;
 		int			status = -EINPROGRESS;
 
 		/* stop when we reach URBs queued after the timer interrupt */
@@ -1822,14 +1822,10 @@ static void dummy_timer(unsigned long _dum_hcd)
 			goto return_urb;
 		else if (dum_hcd-&gt;rh_state != DUMMY_RH_RUNNING)
 			continue;
-		type = usb_pipetype(urb-&gt;pipe);
 
-		/* used up this frame's non-periodic bandwidth?
-		 * FIXME there's infinite bandwidth for control and
-		 * periodic transfers ... unrealistic.
-		 */
-		if (total &lt;= 0 &amp;&amp; type == PIPE_BULK)
-			continue;
+		/* Used up this frame's bandwidth? */
+		if (total &lt;= 0)
+			break;
 
 		/* find the gadget's ep for this request (if configured) */
 		address = usb_pipeendpoint (urb-&gt;pipe);</pre><hr><pre>commit 0902b1f44a72558aece92f074154044861681f84
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 1 07:53:34 2017 -0700

    memory-barriers: Rework multicopy-atomicity section
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;

diff --git a/Documentation/memory-barriers.txt b/Documentation/memory-barriers.txt
index b6882680247e..7deee1441640 100644
--- a/Documentation/memory-barriers.txt
+++ b/Documentation/memory-barriers.txt
@@ -1343,13 +1343,13 @@ MULTICOPY ATOMICITY
 
 Multicopy atomicity is a deeply intuitive notion about ordering that is
 not always provided by real computer systems, namely that a given store
-is visible at the same time to all CPUs, or, alternatively, that all
-CPUs agree on the order in which all stores took place.  However, use of
-full multicopy atomicity would rule out valuable hardware optimizations,
-so a weaker form called ``other multicopy atomicity'' instead guarantees
-that a given store is observed at the same time by all -other- CPUs.  The
-remainder of this document discusses this weaker form, but for brevity
-will call it simply ``multicopy atomicity''.
+becomes visible at the same time to all CPUs, or, alternatively, that all
+CPUs agree on the order in which all stores become visible.  However,
+support of full multicopy atomicity would rule out valuable hardware
+optimizations, so a weaker form called ``other multicopy atomicity''
+instead guarantees only that a given store becomes visible at the same
+time to all -other- CPUs.  The remainder of this document discusses this
+weaker form, but for brevity will call it simply ``multicopy atomicity''.
 
 The following example demonstrates multicopy atomicity:
 
@@ -1360,24 +1360,26 @@ The following example demonstrates multicopy atomicity:
 				&lt;general barrier&gt;	&lt;read barrier&gt;
 				STORE Y=r1		LOAD X
 
-Suppose that CPU 2's load from X returns 1 which it then stores to Y and
-that CPU 3's load from Y returns 1.  This indicates that CPU 2's load
-from X in some sense follows CPU 1's store to X and that CPU 2's store
-to Y in some sense preceded CPU 3's load from Y.  The question is then
-"Can CPU 3's load from X return 0?"
+Suppose that CPU 2's load from X returns 1, which it then stores to Y,
+and CPU 3's load from Y returns 1.  This indicates that CPU 1's store
+to X precedes CPU 2's load from X and that CPU 2's store to Y precedes
+CPU 3's load from Y.  In addition, the memory barriers guarantee that
+CPU 2 executes its load before its store, and CPU 3 loads from Y before
+it loads from X.  The question is then "Can CPU 3's load from X return 0?"
 
-Because CPU 3's load from X in some sense came after CPU 2's load, it
+Because CPU 3's load from X in some sense comes after CPU 2's load, it
 is natural to expect that CPU 3's load from X must therefore return 1.
-This expectation is an example of multicopy atomicity: if a load executing
-on CPU A follows a load from the same variable executing on CPU B, then
-an understandable but incorrect expectation is that CPU A's load must
-either return the same value that CPU B's load did, or must return some
-later value.
-
-In the Linux kernel, the above use of a general memory barrier compensates
-for any lack of multicopy atomicity.  Therefore, in the above example,
-if CPU 2's load from X returns 1 and its load from Y returns 0, and CPU 3's
-load from Y returns 1, then CPU 3's load from X must also return 1.
+This expectation follows from multicopy atomicity: if a load executing
+on CPU B follows a load from the same variable executing on CPU A (and
+CPU A did not originally store the value which it read), then on
+multicopy-atomic systems, CPU B's load must return either the same value
+that CPU A's load did or some later value.  However, the Linux kernel
+does not require systems to be multicopy atomic.
+
+The use of a general memory barrier in the example above compensates
+for any lack of multicopy atomicity.  In the example, if CPU 2's load
+from X returns 1 and CPU 3's load from Y returns 1, then CPU 3's load
+from X must indeed also return 1.
 
 However, dependencies, read barriers, and write barriers are not always
 able to compensate for non-multicopy atomicity.  For example, suppose
@@ -1396,11 +1398,11 @@ this example, it is perfectly legal for CPU 2's load from X to return 1,
 CPU 3's load from Y to return 1, and its load from X to return 0.
 
 The key point is that although CPU 2's data dependency orders its load
-and store, it does not guarantee to order CPU 1's store.  Therefore,
-if this example runs on a non-multicopy-atomic system where CPUs 1 and 2
-share a store buffer or a level of cache, CPU 2 might have early access
-to CPU 1's writes.  A general barrier is therefore required to ensure
-that all CPUs agree on the combined order of CPU 1's and CPU 2's accesses.
+and store, it does not guarantee to order CPU 1's store.  Thus, if this
+example runs on a non-multicopy-atomic system where CPUs 1 and 2 share a
+store buffer or a level of cache, CPU 2 might have early access to CPU 1's
+writes.  General barriers are therefore required to ensure that all CPUs
+agree on the combined order of multiple accesses.
 
 General barriers can compensate not only for non-multicopy atomicity,
 but can also generate additional ordering that can ensure that -all-</pre><hr><pre>commit 7dbd8f4cabd96db5a50513de9d83a8105a5ffc81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 15:15:49 2017 -0400

    USB: dummy-hcd: Fix erroneous synchronization change
    
    A recent change to the synchronization in dummy-hcd was incorrect.
    The issue was that dummy_udc_stop() contained no locking and therefore
    could race with various gadget driver callbacks, and the fix was to
    add locking and issue the callbacks with the private spinlock held.
    
    UDC drivers aren't supposed to do this.  Gadget driver callback
    routines are allowed to invoke functions in the UDC driver, and these
    functions will generally try to acquire the private spinlock.  This
    would deadlock the driver.
    
    The correct solution is to drop the spinlock before issuing callbacks,
    and avoid races by emulating the synchronize_irq() call that all real
    UDC drivers must perform in their -&gt;udc_stop() routines after
    disabling interrupts.  This involves adding a flag to dummy-hcd's
    private structure to keep track of whether interrupts are supposed to
    be enabled, and adding a counter to keep track of ongoing callbacks so
    that dummy_udc_stop() can wait for them all to finish.
    
    A real UDC driver won't receive disconnect, reset, suspend, resume, or
    setup events once it has disabled interrupts.  dummy-hcd will receive
    them but won't try to issue any gadget driver callbacks, which should
    be just as good.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: f16443a034c7 ("USB: gadgetfs, dummy-hcd, net2280: fix locking for callbacks")
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index b2ab9cc33fec..b17618a55f1b 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -255,11 +255,13 @@ struct dummy {
 	 */
 	struct dummy_ep			ep[DUMMY_ENDPOINTS];
 	int				address;
+	int				callback_usage;
 	struct usb_gadget		gadget;
 	struct usb_gadget_driver	*driver;
 	struct dummy_request		fifo_req;
 	u8				fifo_buf[FIFO_SIZE];
 	u16				devstatus;
+	unsigned			ints_enabled:1;
 	unsigned			udc_suspended:1;
 	unsigned			pullup:1;
 
@@ -441,18 +443,27 @@ static void set_link_state(struct dummy_hcd *dum_hcd)
 				(~dum_hcd-&gt;old_status) &amp; dum_hcd-&gt;port_status;
 
 		/* Report reset and disconnect events to the driver */
-		if (dum-&gt;driver &amp;&amp; (disconnect || reset)) {
+		if (dum-&gt;ints_enabled &amp;&amp; (disconnect || reset)) {
 			stop_activity(dum);
+			++dum-&gt;callback_usage;
+			spin_unlock(&amp;dum-&gt;lock);
 			if (reset)
 				usb_gadget_udc_reset(&amp;dum-&gt;gadget, dum-&gt;driver);
 			else
 				dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
+			spin_lock(&amp;dum-&gt;lock);
+			--dum-&gt;callback_usage;
 		}
-	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {
+	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active &amp;&amp;
+			dum-&gt;ints_enabled) {
+		++dum-&gt;callback_usage;
+		spin_unlock(&amp;dum-&gt;lock);
 		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
 		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
+		spin_lock(&amp;dum-&gt;lock);
+		--dum-&gt;callback_usage;
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
@@ -973,8 +984,11 @@ static int dummy_udc_start(struct usb_gadget *g,
 	 * can't enumerate without help from the driver we're binding.
 	 */
 
+	spin_lock_irq(&amp;dum-&gt;lock);
 	dum-&gt;devstatus = 0;
 	dum-&gt;driver = driver;
+	dum-&gt;ints_enabled = 1;
+	spin_unlock_irq(&amp;dum-&gt;lock);
 
 	return 0;
 }
@@ -985,6 +999,16 @@ static int dummy_udc_stop(struct usb_gadget *g)
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
 	spin_lock_irq(&amp;dum-&gt;lock);
+	dum-&gt;ints_enabled = 0;
+	stop_activity(dum);
+
+	/* emulate synchronize_irq(): wait for callbacks to finish */
+	while (dum-&gt;callback_usage &gt; 0) {
+		spin_unlock_irq(&amp;dum-&gt;lock);
+		usleep_range(1000, 2000);
+		spin_lock_irq(&amp;dum-&gt;lock);
+	}
+
 	dum-&gt;driver = NULL;
 	spin_unlock_irq(&amp;dum-&gt;lock);
 
@@ -1529,6 +1553,8 @@ static struct dummy_ep *find_endpoint(struct dummy *dum, u8 address)
 	if (!is_active((dum-&gt;gadget.speed == USB_SPEED_SUPER ?
 			dum-&gt;ss_hcd : dum-&gt;hs_hcd)))
 		return NULL;
+	if (!dum-&gt;ints_enabled)
+		return NULL;
 	if ((address &amp; ~USB_DIR_IN) == 0)
 		return &amp;dum-&gt;ep[0];
 	for (i = 1; i &lt; DUMMY_ENDPOINTS; i++) {
@@ -1870,10 +1896,12 @@ static void dummy_timer(unsigned long _dum_hcd)
 			 * until setup() returns; no reentrancy issues etc.
 			 */
 			if (value &gt; 0) {
+				++dum-&gt;callback_usage;
 				spin_unlock(&amp;dum-&gt;lock);
 				value = dum-&gt;driver-&gt;setup(&amp;dum-&gt;gadget,
 						&amp;setup);
 				spin_lock(&amp;dum-&gt;lock);
+				--dum-&gt;callback_usage;
 
 				if (value &gt;= 0) {
 					/* no delays (max 64KB data stage) */</pre><hr><pre>commit 0173a68bfb0ad1c72a6ee39cc485aa2c97540b98
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 15:15:40 2017 -0400

    USB: dummy-hcd: fix infinite-loop resubmission bug
    
    The dummy-hcd HCD/UDC emulator tries not to do too much work during
    each timer interrupt.  But it doesn't try very hard; currently all
    it does is limit the total amount of bulk data transferred.  Other
    transfer types aren't limited, and URBs that transfer no data (because
    of an error, perhaps) don't count toward the limit, even though on a
    real USB bus they would consume at least a minimum overhead.
    
    This means it's possible to get the driver stuck in an infinite loop,
    for example, if the host class driver resubmits an URB every time it
    completes (which is common for interrupt URBs).  Each time the URB is
    resubmitted it gets added to the end of the pending-URBs list, and
    dummy-hcd doesn't stop until that list is empty.  Andrey Konovalov was
    able to trigger this failure mode using the syzkaller fuzzer.
    
    This patch fixes the infinite-loop problem by restricting the URBs
    handled during each timer interrupt to those that were already on the
    pending list when the interrupt routine started.  Newly added URBs
    won't be processed until the next timer interrupt.  The problem of
    properly accounting for non-bulk bandwidth (as well as packet and
    transaction overhead) is not addressed here.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    Tested-by: Andrey Konovalov &lt;andreyknvl@google.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index d515ec31afe4..b2ab9cc33fec 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -237,6 +237,8 @@ struct dummy_hcd {
 
 	struct usb_device		*udev;
 	struct list_head		urbp_list;
+	struct urbp			*next_frame_urbp;
+
 	u32				stream_en_ep;
 	u8				num_stream[30 / 2];
 
@@ -1250,6 +1252,8 @@ static int dummy_urb_enqueue(
 
 	list_add_tail(&amp;urbp-&gt;urbp_list, &amp;dum_hcd-&gt;urbp_list);
 	urb-&gt;hcpriv = urbp;
+	if (!dum_hcd-&gt;next_frame_urbp)
+		dum_hcd-&gt;next_frame_urbp = urbp;
 	if (usb_pipetype(urb-&gt;pipe) == PIPE_CONTROL)
 		urb-&gt;error_count = 1;		/* mark as a new urb */
 
@@ -1766,6 +1770,7 @@ static void dummy_timer(unsigned long _dum_hcd)
 		spin_unlock_irqrestore(&amp;dum-&gt;lock, flags);
 		return;
 	}
+	dum_hcd-&gt;next_frame_urbp = NULL;
 
 	for (i = 0; i &lt; DUMMY_ENDPOINTS; i++) {
 		if (!ep_info[i].name)
@@ -1782,6 +1787,10 @@ static void dummy_timer(unsigned long _dum_hcd)
 		int			type;
 		int			status = -EINPROGRESS;
 
+		/* stop when we reach URBs queued after the timer interrupt */
+		if (urbp == dum_hcd-&gt;next_frame_urbp)
+			break;
+
 		urb = urbp-&gt;urb;
 		if (urb-&gt;unlinked)
 			goto return_urb;</pre><hr><pre>commit fe659bcc9b173bcfdd958ce2aec75e47651e74e1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 15:15:22 2017 -0400

    USB: dummy-hcd: fix connection failures (wrong speed)
    
    The dummy-hcd UDC driver is not careful about the way it handles
    connection speeds.  It ignores the module parameter that is supposed
    to govern the maximum connection speed and it doesn't set the HCD
    flags properly for the case where it ends up running at full speed.
    
    The result is that in many cases, gadget enumeration over dummy-hcd
    fails because the bMaxPacketSize byte in the device descriptor is set
    incorrectly.  For example, the default settings call for a high-speed
    connection, but the maxpacket value for ep0 ends up being set for a
    Super-Speed connection.
    
    This patch fixes the problem by initializing the gadget's max_speed
    and the HCD flags correctly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c
index b1e21b3be6e1..d515ec31afe4 100644
--- a/drivers/usb/gadget/udc/dummy_hcd.c
+++ b/drivers/usb/gadget/udc/dummy_hcd.c
@@ -1036,7 +1036,12 @@ static int dummy_udc_probe(struct platform_device *pdev)
 	memzero_explicit(&amp;dum-&gt;gadget, sizeof(struct usb_gadget));
 	dum-&gt;gadget.name = gadget_name;
 	dum-&gt;gadget.ops = &amp;dummy_ops;
-	dum-&gt;gadget.max_speed = USB_SPEED_SUPER;
+	if (mod_data.is_super_speed)
+		dum-&gt;gadget.max_speed = USB_SPEED_SUPER;
+	else if (mod_data.is_high_speed)
+		dum-&gt;gadget.max_speed = USB_SPEED_HIGH;
+	else
+		dum-&gt;gadget.max_speed = USB_SPEED_FULL;
 
 	dum-&gt;gadget.dev.parent = &amp;pdev-&gt;dev;
 	init_dummy_udc_hw(dum);
@@ -2560,8 +2565,6 @@ static struct hc_driver dummy_hcd = {
 	.product_desc =		"Dummy host controller",
 	.hcd_priv_size =	sizeof(struct dummy_hcd),
 
-	.flags =		HCD_USB3 | HCD_SHARED,
-
 	.reset =		dummy_setup,
 	.start =		dummy_start,
 	.stop =			dummy_stop,
@@ -2590,8 +2593,12 @@ static int dummy_hcd_probe(struct platform_device *pdev)
 	dev_info(&amp;pdev-&gt;dev, "%s, driver " DRIVER_VERSION "\n", driver_desc);
 	dum = *((void **)dev_get_platdata(&amp;pdev-&gt;dev));
 
-	if (!mod_data.is_super_speed)
+	if (mod_data.is_super_speed)
+		dummy_hcd.flags = HCD_USB3 | HCD_SHARED;
+	else if (mod_data.is_high_speed)
 		dummy_hcd.flags = HCD_USB2;
+	else
+		dummy_hcd.flags = HCD_USB11;
 	hs_hcd = usb_create_hcd(&amp;dummy_hcd, &amp;pdev-&gt;dev, dev_name(&amp;pdev-&gt;dev));
 	if (!hs_hcd)
 		return -ENOMEM;</pre>
    <div class="pagination">
        <a href='2_18.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><span>[19]</span><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_20.html'>Next&gt;&gt;</a>
    <div>
</body>
