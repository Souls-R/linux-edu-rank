<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_12.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><span>[13]</span><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_14.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b3925514f6f6878e3f671fb6990874e731a26d02
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 10 16:51:48 2010 -0600

    [SCSI] qla4xxx: fix compile warning due to invalid extHwConfig
    
    If the nvram is invalid qla4xxx tries to set Asuint32_t
    based on the card type. If the card type is not listed
    then Asuint32_t is going to be gargabe. This just fixes
    that if/elseif by adding a else to catch the case for
    new hardware that might not be listed yet.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_init.c b/drivers/scsi/qla4xxx/ql4_init.c
index af8c3233e8ae..92329a461c68 100644
--- a/drivers/scsi/qla4xxx/ql4_init.c
+++ b/drivers/scsi/qla4xxx/ql4_init.c
@@ -844,10 +844,10 @@ static int qla4xxx_config_nvram(struct scsi_qla_host *ha)
 	DEBUG2(printk("scsi%ld: %s: Get EEProm parameters \n", ha-&gt;host_no,
 		      __func__));
 	if (ql4xxx_lock_flash(ha) != QLA_SUCCESS)
-		return (QLA_ERROR);
+		return QLA_ERROR;
 	if (ql4xxx_lock_nvram(ha) != QLA_SUCCESS) {
 		ql4xxx_unlock_flash(ha);
-		return (QLA_ERROR);
+		return QLA_ERROR;
 	}
 
 	/* Get EEPRom Parameters from NVRAM and validate */
@@ -858,20 +858,18 @@ static int qla4xxx_config_nvram(struct scsi_qla_host *ha)
 			rd_nvram_word(ha, eeprom_ext_hw_conf_offset(ha));
 		spin_unlock_irqrestore(&amp;ha-&gt;hardware_lock, flags);
 	} else {
-		/*
-		 * QLogic adapters should always have a valid NVRAM.
-		 * If not valid, do not load.
-		 */
 		dev_warn(&amp;ha-&gt;pdev-&gt;dev,
 			   "scsi%ld: %s: EEProm checksum invalid.  "
 			   "Please update your EEPROM\n", ha-&gt;host_no,
 			   __func__);
 
-		/* set defaults */
+		/* Attempt to set defaults */
 		if (is_qla4010(ha))
 			extHwConfig.Asuint32_t = 0x1912;
 		else if (is_qla4022(ha) | is_qla4032(ha))
 			extHwConfig.Asuint32_t = 0x0023;
+		else
+			return QLA_ERROR;
 	}
 	DEBUG(printk("scsi%ld: %s: Setting extHwConfig to 0xFFFF%04x\n",
 		     ha-&gt;host_no, __func__, extHwConfig.Asuint32_t));
@@ -884,7 +882,7 @@ static int qla4xxx_config_nvram(struct scsi_qla_host *ha)
 	ql4xxx_unlock_nvram(ha);
 	ql4xxx_unlock_flash(ha);
 
-	return (QLA_SUCCESS);
+	return QLA_SUCCESS;
 }
 
 static void qla4x00_pci_config(struct scsi_qla_host *ha)</pre><hr><pre>commit b64e77f70b8c11766e967e3485331a9e6ef01390
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 10 16:51:47 2010 -0600

    [SCSI] iscsi_tcp: wake xmit thread when killing session
    
    If the connection is bad, then the xmit thread could
    end up waiting a long time (up to sendtmeo seconds) in
    tcp_sendpage. This patch has us set the sk_error and
    wake up the xmit thread so we can quickly fail.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 517da3fd89d3..8a89ba900588 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -584,9 +584,10 @@ static void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn-&gt;dd_data;
+	struct socket *sock = tcp_sw_conn-&gt;sock;
 
 	/* userspace may have goofed up and not bound us */
-	if (!tcp_sw_conn-&gt;sock)
+	if (!sock)
 		return;
 	/*
 	 * Make sure our recv side is stopped.
@@ -597,6 +598,11 @@ static void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
 	write_unlock_bh(&amp;tcp_sw_conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
 
+	if (sock-&gt;sk-&gt;sk_sleep &amp;&amp; waitqueue_active(sock-&gt;sk-&gt;sk_sleep)) {
+		sock-&gt;sk-&gt;sk_err = EIO;
+		wake_up_interruptible(sock-&gt;sk-&gt;sk_sleep);
+	}
+
 	iscsi_conn_stop(cls_conn, flag);
 	iscsi_sw_tcp_release_conn(conn);
 }</pre><hr><pre>commit 9f9127fd0cfac1ccbcf4a9456b3d36bc6971355e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 10 16:51:46 2010 -0600

    [SCSI] bnx2i: set change_queue_depth function
    
    No reason that we cannot set the change_queue_depth
    function for bnx2i. We just forgot to when the
    driver was created.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/bnx2i/bnx2i_iscsi.c b/drivers/scsi/bnx2i/bnx2i_iscsi.c
index 51709cb9a93e..1c4d1215769d 100644
--- a/drivers/scsi/bnx2i/bnx2i_iscsi.c
+++ b/drivers/scsi/bnx2i/bnx2i_iscsi.c
@@ -1990,6 +1990,7 @@ static struct scsi_host_template bnx2i_host_template = {
 	.eh_abort_handler	= iscsi_eh_abort,
 	.eh_device_reset_handler = iscsi_eh_device_reset,
 	.eh_target_reset_handler = iscsi_eh_target_reset,
+	.change_queue_depth	= iscsi_change_queue_depth,
 	.can_queue		= 1024,
 	.max_sectors		= 127,
 	.cmd_per_lun		= 32,</pre><hr><pre>commit 92ed4d69934a1281abcc10c6a82274a04651a260
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 10 16:51:45 2010 -0600

    [SCSI] libiscsi: reset cmd timer if cmds are making progress
    
    This patch resets the cmd timer if cmds started before
    the timedout command are making progress. The idea is
    that the cmd probably timed out because we are trying
    to exeucte too many commands. If it turns out that the
    device the IO timedout on was bad or the cmd just got
    screwed up but other IO/devs were ok then we will
    will figure this out when the cmds ahead of the timed
    out one complete ok.
    
    This also fixes a bug where we were sort of detecting
    this by setting the last_timeout and last_xfer to the
    same value when the task was allocated. That caught
    the case where we never got to send any IO for it. However,
    if the problem had started right before we started the
    new task, then we were forced to wait an extra cmd
    timeout seconds to start the scsi eh.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index c28a712fd4db..703eb6a88790 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1919,10 +1919,11 @@ static int iscsi_has_ping_timed_out(struct iscsi_conn *conn)
 static enum blk_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc)
 {
 	enum blk_eh_timer_return rc = BLK_EH_NOT_HANDLED;
-	struct iscsi_task *task = NULL;
+	struct iscsi_task *task = NULL, *running_task;
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
 	struct iscsi_conn *conn;
+	int i;
 
 	cls_session = starget_to_session(scsi_target(sc-&gt;device));
 	session = cls_session-&gt;dd_data;
@@ -1947,8 +1948,15 @@ static enum blk_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc)
 	}
 
 	task = (struct iscsi_task *)sc-&gt;SCp.ptr;
-	if (!task)
+	if (!task) {
+		/*
+		 * Raced with completion. Just reset timer, and let it
+		 * complete normally
+		 */
+		rc = BLK_EH_RESET_TIMER;
 		goto done;
+	}
+
 	/*
 	 * If we have sent (at least queued to the network layer) a pdu or
 	 * recvd one for the task since the last timeout ask for
@@ -1956,10 +1964,10 @@ static enum blk_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc)
 	 * we can check if it is the task or connection when we send the
 	 * nop as a ping.
 	 */
-	if (time_after_eq(task-&gt;last_xfer, task-&gt;last_timeout)) {
+	if (time_after(task-&gt;last_xfer, task-&gt;last_timeout)) {
 		ISCSI_DBG_EH(session, "Command making progress. Asking "
 			     "scsi-ml for more time to complete. "
-			     "Last data recv at %lu. Last timeout was at "
+			     "Last data xfer at %lu. Last timeout was at "
 			     "%lu\n.", task-&gt;last_xfer, task-&gt;last_timeout);
 		task-&gt;have_checked_conn = false;
 		rc = BLK_EH_RESET_TIMER;
@@ -1977,6 +1985,43 @@ static enum blk_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *sc)
 		goto done;
 	}
 
+	for (i = 0; i &lt; conn-&gt;session-&gt;cmds_max; i++) {
+		running_task = conn-&gt;session-&gt;cmds[i];
+		if (!running_task-&gt;sc || running_task == task ||
+		     running_task-&gt;state != ISCSI_TASK_RUNNING)
+			continue;
+
+		/*
+		 * Only check if cmds started before this one have made
+		 * progress, or this could never fail
+		 */
+		if (time_after(running_task-&gt;sc-&gt;jiffies_at_alloc,
+			       task-&gt;sc-&gt;jiffies_at_alloc))
+			continue;
+
+		if (time_after(running_task-&gt;last_xfer, task-&gt;last_timeout)) {
+			/*
+			 * This task has not made progress, but a task
+			 * started before us has transferred data since
+			 * we started/last-checked. We could be queueing
+			 * too many tasks or the LU is bad.
+			 *
+			 * If the device is bad the cmds ahead of us on
+			 * other devs will complete, and this loop will
+			 * eventually fail starting the scsi eh.
+			 */
+			ISCSI_DBG_EH(session, "Command has not made progress "
+				     "but commands ahead of it have. "
+				     "Asking scsi-ml for more time to "
+				     "complete. Our last xfer vs running task "
+				     "last xfer %lu/%lu. Last check %lu.\n",
+				     task-&gt;last_xfer, running_task-&gt;last_xfer,
+				     task-&gt;last_timeout);
+			rc = BLK_EH_RESET_TIMER;
+			goto done;
+		}
+	}
+
 	/* Assumes nop timeout is shorter than scsi cmd timeout */
 	if (task-&gt;have_checked_conn)
 		goto done;</pre><hr><pre>commit 9010b94636312c7fb12b591ef09e915f8f80bbd5
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 10 16:51:44 2010 -0600

    [SCSI] cxgb3i: check for setup netdev
    
    If the netdev has not been setup when the host is, we will oops when
    the iscsi layer calls into the driver and a it tries to reference the
    netdev in hba-&gt;ndev.
    
    This can happen if the iscsi driver is loaded before ifup is
    done. This patch just adds a check, so we can gracefully fail the
    operation.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
index 1fd89b229c87..412853c65372 100644
--- a/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
+++ b/drivers/scsi/cxgb3i/cxgb3i_iscsi.c
@@ -708,6 +708,12 @@ static int cxgb3i_host_set_param(struct Scsi_Host *shost,
 {
 	struct cxgb3i_hba *hba = iscsi_host_priv(shost);
 
+	if (!hba-&gt;ndev) {
+		shost_printk(KERN_ERR, shost, "Could not set host param. "
+			     "Netdev for host not set.\n");
+		return -ENODEV;
+	}
+
 	cxgb3i_api_debug("param %d, buf %s.\n", param, buf);
 
 	switch (param) {
@@ -738,6 +744,12 @@ static int cxgb3i_host_get_param(struct Scsi_Host *shost,
 	struct cxgb3i_hba *hba = iscsi_host_priv(shost);
 	int len = 0;
 
+	if (!hba-&gt;ndev) {
+		shost_printk(KERN_ERR, shost, "Could not set host param. "
+			     "Netdev for host not set.\n");
+		return -ENODEV;
+	}
+
 	cxgb3i_api_debug("hba %s, param %d.\n", hba-&gt;ndev-&gt;name, param);
 
 	switch (param) {</pre><hr><pre>commit fee099b278894a1c7383a08cb3c62a5b62a134e8
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Jan 12 22:48:00 2010 -0600

    [SCSI] iscsi_tcp regression: remove bogus warn on in write path
    
    An empty r2tqueue is a valid state. It just means that we have
    processed all that there was to do. This patch removes the WARN_ON
    that was added when the kfifo changes were merged.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi_tcp.c b/drivers/scsi/libiscsi_tcp.c
index db6856c138fc..4ad87fd74ddd 100644
--- a/drivers/scsi/libiscsi_tcp.c
+++ b/drivers/scsi/libiscsi_tcp.c
@@ -992,12 +992,10 @@ static struct iscsi_r2t_info *iscsi_tcp_get_curr_r2t(struct iscsi_task *task)
 		if (r2t == NULL) {
 			if (kfifo_out(&amp;tcp_task-&gt;r2tqueue,
 			    (void *)&amp;tcp_task-&gt;r2t, sizeof(void *)) !=
-			    sizeof(void *)) {
-				WARN_ONCE(1, "unexpected fifo state");
+			    sizeof(void *))
 				r2t = NULL;
-			}
-
-			r2t = tcp_task-&gt;r2t;
+			else
+				r2t = tcp_task-&gt;r2t;
 		}
 		spin_unlock_bh(&amp;session-&gt;lock);
 	}</pre><hr><pre>commit 48de68a40aef032a2e198437f4781a83bfb938db
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue Nov 17 21:25:16 2009 -0600

    [SCSI] fc class: fix fc_transport_init error handling
    
    If transport_class_register fails we should unregister any
    registered classes, or we will leak memory or other
    resources.
    
    I did a quick modprobe of scsi_transport_fc to test the
    patch.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: Stable Tree &lt;stable@kernel.org&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_fc.c b/drivers/scsi/scsi_transport_fc.c
index 6531c91501be..ddfcecd5099f 100644
--- a/drivers/scsi/scsi_transport_fc.c
+++ b/drivers/scsi/scsi_transport_fc.c
@@ -649,11 +649,22 @@ static __init int fc_transport_init(void)
 		return error;
 	error = transport_class_register(&amp;fc_vport_class);
 	if (error)
-		return error;
+		goto unreg_host_class;
 	error = transport_class_register(&amp;fc_rport_class);
 	if (error)
-		return error;
-	return transport_class_register(&amp;fc_transport_class);
+		goto unreg_vport_class;
+	error = transport_class_register(&amp;fc_transport_class);
+	if (error)
+		goto unreg_rport_class;
+	return 0;
+
+unreg_rport_class:
+	transport_class_unregister(&amp;fc_rport_class);
+unreg_vport_class:
+	transport_class_unregister(&amp;fc_vport_class);
+unreg_host_class:
+	transport_class_unregister(&amp;fc_host_class);
+	return error;
 }
 
 static void __exit fc_transport_exit(void)</pre><hr><pre>commit 1796e72291b2b6aafaec5954e666d0b5a95da935
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Nov 11 16:34:36 2009 -0600

    [SCSI] libiscsi: hook into ramp up/down handling
    
    It is rare to get a queue full with iscsi, because targets seem to
    just reduce the iscsi cmd window. However, there is at least
    one iscsi target that will throw a queue full when overloaded.
    This hooks the iscsi code in to the ramp up/down code, so we
    can handle it.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 07ec997c5d4f..b7689f3d05f5 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1739,10 +1739,19 @@ EXPORT_SYMBOL_GPL(iscsi_queuecommand);
 
 int iscsi_change_queue_depth(struct scsi_device *sdev, int depth, int reason)
 {
-	if (reason != SCSI_QDEPTH_DEFAULT)
+	switch (reason) {
+	case SCSI_QDEPTH_DEFAULT:
+		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+		break;
+	case SCSI_QDEPTH_QFULL:
+		scsi_track_queue_full(sdev, depth);
+		break;
+	case SCSI_QDEPTH_RAMP_UP:
+		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+		break;
+	default:
 		return -EOPNOTSUPP;
-
-	scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);
+	}
 	return sdev-&gt;queue_depth;
 }
 EXPORT_SYMBOL_GPL(iscsi_change_queue_depth);</pre><hr><pre>commit b20d038dff877566694181578c49c31616d622cd
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Nov 11 16:34:35 2009 -0600

    [SCSI] iser: set tgt and lu reset timeout
    
    When iser enabled lu reset support it did not set the
    bit to allow userspace to get/set the timeout. This
    sets the tgt and lu reset timeout bits.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index add9188663ff..5f7a6fca0a4d 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -625,6 +625,7 @@ static struct iscsi_transport iscsi_iser_transport = {
 				  ISCSI_USERNAME | ISCSI_PASSWORD |
 				  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN |
 				  ISCSI_FAST_ABORT | ISCSI_ABORT_TMO |
+				  ISCSI_LU_RESET_TMO | ISCSI_TGT_RESET_TMO |
 				  ISCSI_PING_TMO | ISCSI_RECV_TMO |
 				  ISCSI_IFACE_NAME | ISCSI_INITIATOR_NAME,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS |</pre><hr><pre>commit fdd46dcbe4468a1f47a2cc9be442d11c3d21dd68
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Nov 11 16:34:34 2009 -0600

    [SCSI] iscsi class: modify handling of replacement timeout
    
    This patch modifies the replacement/recovery_timeout so it works
    more like the fc fast io fail tmo.
    
    If userspace tries to set the replacement/recovery_timeout to less than
    zero, we will turn off the forced recovery cleanup.
    
    If userspace sets the value to 0 then we will force the recovery
    cleanup immediately.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index dc04ca124a69..ea3892e7e0f7 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -627,8 +627,10 @@ static void __iscsi_block_session(struct work_struct *work)
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	scsi_target_block(&amp;session-&gt;dev);
 	ISCSI_DBG_TRANS_SESSION(session, "Completed SCSI target blocking\n");
-	queue_delayed_work(iscsi_eh_timer_workq, &amp;session-&gt;recovery_work,
-			   session-&gt;recovery_tmo * HZ);
+	if (session-&gt;recovery_tmo &gt;= 0)
+		queue_delayed_work(iscsi_eh_timer_workq,
+				   &amp;session-&gt;recovery_work,
+				   session-&gt;recovery_tmo * HZ);
 }
 
 void iscsi_block_session(struct iscsi_cls_session *session)
@@ -1348,8 +1350,7 @@ iscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 	switch (ev-&gt;u.set_param.param) {
 	case ISCSI_PARAM_SESS_RECOVERY_TMO:
 		sscanf(data, "%d", &amp;value);
-		if (value != 0)
-			session-&gt;recovery_tmo = value;
+		session-&gt;recovery_tmo = value;
 		break;
 	default:
 		err = transport-&gt;set_param(conn, ev-&gt;u.set_param.param,</pre>
    <div class="pagination">
        <a href='5_12.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><span>[13]</span><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_14.html'>Next&gt;&gt;</a>
    <div>
</body>
