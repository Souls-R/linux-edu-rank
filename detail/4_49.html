<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_48.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><span>[49]</span><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_50.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit adeb8133dd57f380e70a389a89a2ea3ae227f9e2
Author: Olga Kornievskaia &lt;aglo@citi.umich.edu&gt;
Date:   Mon Dec 4 20:22:34 2006 -0500

    rpc: spkm3 update
    
    This updates the spkm3 code to bring it up to date with our current
    understanding of the spkm3 spec.
    
    In doing so, we're changing the downcall format used by gssd in the spkm3 case,
    which will cause an incompatilibity with old userland spkm3 support.  Since the
    old code a) didn't implement the protocol correctly, and b) was never
    distributed except in the form of some experimental patches from the citi web
    site, we're assuming this is OK.
    
    We do detect the old downcall format and print warning (and fail).  We also
    include a version number in the new downcall format, to be used in the
    future in case any further change is required.
    
    In some more detail:
    
            - fix integrity support
            - removed dependency on NIDs. instead OIDs are used
            - known OID values for algorithms added.
            - fixed some context fields and types
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/include/linux/sunrpc/gss_spkm3.h b/include/linux/sunrpc/gss_spkm3.h
index 2cf3fbb40b4f..e3e6a3437f8b 100644
--- a/include/linux/sunrpc/gss_spkm3.h
+++ b/include/linux/sunrpc/gss_spkm3.h
@@ -12,27 +12,19 @@
 #include &lt;linux/sunrpc/gss_asn1.h&gt;
 
 struct spkm3_ctx {
-	struct xdr_netobj	ctx_id; /* per message context id */
-	int			qop;         /* negotiated qop */
+	struct xdr_netobj	ctx_id;  /* per message context id */
+	int			endtime; /* endtime of the context */
 	struct xdr_netobj	mech_used;
 	unsigned int		ret_flags ;
-	unsigned int		req_flags ;
-	struct xdr_netobj	share_key;
-	int			conf_alg;
-	struct crypto_blkcipher	*derived_conf_key;
-	int			intg_alg;
-	struct crypto_blkcipher	*derived_integ_key;
-	int			keyestb_alg;   /* alg used to get share_key */
-	int			owf_alg;   /* one way function */
+	struct xdr_netobj	conf_alg;
+	struct xdr_netobj	derived_conf_key;
+	struct xdr_netobj	intg_alg;
+	struct xdr_netobj 	derived_integ_key;
 };
 
-/* from openssl/objects.h */
-/* XXX need SEAL_ALG_NONE */
-#define NID_md5		4
-#define NID_dhKeyAgreement	28 
-#define NID_des_cbc		31 
-#define NID_sha1		64
-#define NID_cast5_cbc		108
+/* OIDs declarations for K-ALG, I-ALG, C-ALG, and OWF-ALG */
+extern const struct xdr_netobj hmac_md5_oid;
+extern const struct xdr_netobj cast5_cbc_oid;
 
 /* SPKM InnerContext Token types */
 
@@ -46,11 +38,13 @@ u32 spkm3_make_token(struct spkm3_ctx *ctx, struct xdr_buf * text, struct xdr_ne
 u32 spkm3_read_token(struct spkm3_ctx *ctx, struct xdr_netobj *read_token, struct xdr_buf *message_buffer, int toktype);
 
 #define CKSUMTYPE_RSA_MD5            0x0007
+#define CKSUMTYPE_HMAC_MD5           0x0008
 
-s32 make_checksum(s32 cksumtype, char *header, int hdrlen, struct xdr_buf *body,
-                   int body_offset, struct xdr_netobj *cksum);
+s32 make_spkm3_checksum(s32 cksumtype, struct xdr_netobj *key, char *header,
+		unsigned int hdrlen, struct xdr_buf *body,
+		unsigned int body_offset, struct xdr_netobj *cksum);
 void asn1_bitstring_len(struct xdr_netobj *in, int *enclen, int *zerobits);
-int decode_asn1_bitstring(struct xdr_netobj *out, char *in, int enclen, 
+int decode_asn1_bitstring(struct xdr_netobj *out, char *in, int enclen,
                    int explen);
 void spkm3_mic_header(unsigned char **hdrbuf, unsigned int *hdrlen, 
                    unsigned char *ctxhdr, int elen, int zbit);
diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index d12ee5f54c0c..a02ecc1f230d 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -68,7 +68,7 @@ static struct rpc_credops gss_credops;
 #define GSS_CRED_SLACK		1024		/* XXX: unused */
 /* length of a krb5 verifier (48), plus data added before arguments when
  * using integrity (two 4-byte integers): */
-#define GSS_VERF_SLACK		56
+#define GSS_VERF_SLACK		100
 
 /* XXX this define must match the gssd define
 * as it is passed to gssd to signal the use of
diff --git a/net/sunrpc/auth_gss/gss_spkm3_mech.c b/net/sunrpc/auth_gss/gss_spkm3_mech.c
index d57f60838895..41465072d0b5 100644
--- a/net/sunrpc/auth_gss/gss_spkm3_mech.c
+++ b/net/sunrpc/auth_gss/gss_spkm3_mech.c
@@ -82,133 +82,73 @@ simple_get_netobj(const void *p, const void *end, struct xdr_netobj *res)
 	return q;
 }
 
-static inline const void *
-get_key(const void *p, const void *end, struct crypto_blkcipher **res,
-	int *resalg)
-{
-	struct xdr_netobj	key = { 0 };
-	int			setkey = 0;
-	char			*alg_name;
-
-	p = simple_get_bytes(p, end, resalg, sizeof(*resalg));
-	if (IS_ERR(p))
-		goto out_err;
-	p = simple_get_netobj(p, end, &amp;key);
-	if (IS_ERR(p))
-		goto out_err;
-
-	switch (*resalg) {
-		case NID_des_cbc:
-			alg_name = "cbc(des)";
-			setkey = 1;
-			break;
-		case NID_cast5_cbc:
-			/* XXXX here in name only, not used */
-			alg_name = "cbc(cast5)";
-			setkey = 0; /* XXX will need to set to 1 */
-			break;
-		case NID_md5:
-			if (key.len == 0) {
-				dprintk("RPC: SPKM3 get_key: NID_md5 zero Key length\n");
-			}
-			alg_name = "md5";
-			setkey = 0;
-			break;
-		default:
-			dprintk("gss_spkm3_mech: unsupported algorithm %d\n", *resalg);
-			goto out_err_free_key;
-	}
-	*res = crypto_alloc_blkcipher(alg_name, 0, CRYPTO_ALG_ASYNC);
-	if (IS_ERR(*res)) {
-		printk("gss_spkm3_mech: unable to initialize crypto algorthm %s\n", alg_name);
-		*res = NULL;
-		goto out_err_free_key;
-	}
-	if (setkey) {
-		if (crypto_blkcipher_setkey(*res, key.data, key.len)) {
-			printk("gss_spkm3_mech: error setting key for crypto algorthm %s\n", alg_name);
-			goto out_err_free_tfm;
-		}
-	}
-
-	if(key.len &gt; 0)
-		kfree(key.data);
-	return p;
-
-out_err_free_tfm:
-	crypto_free_blkcipher(*res);
-out_err_free_key:
-	if(key.len &gt; 0)
-		kfree(key.data);
-	p = ERR_PTR(-EINVAL);
-out_err:
-	return p;
-}
-
 static int
 gss_import_sec_context_spkm3(const void *p, size_t len,
 				struct gss_ctx *ctx_id)
 {
 	const void *end = (const void *)((const char *)p + len);
 	struct	spkm3_ctx *ctx;
+	int	version;
 
 	if (!(ctx = kzalloc(sizeof(*ctx), GFP_KERNEL)))
 		goto out_err;
 
+	p = simple_get_bytes(p, end, &amp;version, sizeof(version));
+	if (IS_ERR(p))
+		goto out_err_free_ctx;
+	if (version != 1) {
+		dprintk("RPC: unknown spkm3 token format: obsolete nfs-utils?\n");
+		goto out_err_free_ctx;
+	}
+
 	p = simple_get_netobj(p, end, &amp;ctx-&gt;ctx_id);
 	if (IS_ERR(p))
 		goto out_err_free_ctx;
 
-	p = simple_get_bytes(p, end, &amp;ctx-&gt;qop, sizeof(ctx-&gt;qop));
+	p = simple_get_bytes(p, end, &amp;ctx-&gt;endtime, sizeof(ctx-&gt;endtime));
 	if (IS_ERR(p))
 		goto out_err_free_ctx_id;
 
 	p = simple_get_netobj(p, end, &amp;ctx-&gt;mech_used);
 	if (IS_ERR(p))
-		goto out_err_free_mech;
+		goto out_err_free_ctx_id;
 
 	p = simple_get_bytes(p, end, &amp;ctx-&gt;ret_flags, sizeof(ctx-&gt;ret_flags));
 	if (IS_ERR(p))
 		goto out_err_free_mech;
 
-	p = simple_get_bytes(p, end, &amp;ctx-&gt;req_flags, sizeof(ctx-&gt;req_flags));
+	p = simple_get_netobj(p, end, &amp;ctx-&gt;conf_alg);
 	if (IS_ERR(p))
 		goto out_err_free_mech;
 
-	p = simple_get_netobj(p, end, &amp;ctx-&gt;share_key);
-	if (IS_ERR(p))
-		goto out_err_free_s_key;
-
-	p = get_key(p, end, &amp;ctx-&gt;derived_conf_key, &amp;ctx-&gt;conf_alg);
+	p = simple_get_netobj(p, end, &amp;ctx-&gt;derived_conf_key);
 	if (IS_ERR(p))
-		goto out_err_free_s_key;
+		goto out_err_free_conf_alg;
 
-	p = get_key(p, end, &amp;ctx-&gt;derived_integ_key, &amp;ctx-&gt;intg_alg);
+	p = simple_get_netobj(p, end, &amp;ctx-&gt;intg_alg);
 	if (IS_ERR(p))
-		goto out_err_free_key1;
+		goto out_err_free_conf_key;
 
-	p = simple_get_bytes(p, end, &amp;ctx-&gt;keyestb_alg, sizeof(ctx-&gt;keyestb_alg));
+	p = simple_get_netobj(p, end, &amp;ctx-&gt;derived_integ_key);
 	if (IS_ERR(p))
-		goto out_err_free_key2;
-
-	p = simple_get_bytes(p, end, &amp;ctx-&gt;owf_alg, sizeof(ctx-&gt;owf_alg));
-	if (IS_ERR(p))
-		goto out_err_free_key2;
+		goto out_err_free_intg_alg;
 
 	if (p != end)
-		goto out_err_free_key2;
+		goto out_err_free_intg_key;
 
 	ctx_id-&gt;internal_ctx_id = ctx;
 
 	dprintk("Successfully imported new spkm context.\n");
 	return 0;
 
-out_err_free_key2:
-	crypto_free_blkcipher(ctx-&gt;derived_integ_key);
-out_err_free_key1:
-	crypto_free_blkcipher(ctx-&gt;derived_conf_key);
-out_err_free_s_key:
-	kfree(ctx-&gt;share_key.data);
+out_err_free_intg_key:
+	kfree(ctx-&gt;derived_integ_key.data);
+out_err_free_intg_alg:
+	kfree(ctx-&gt;intg_alg.data);
+out_err_free_conf_key:
+	kfree(ctx-&gt;derived_conf_key.data);
+out_err_free_conf_alg:
+	kfree(ctx-&gt;conf_alg.data);
 out_err_free_mech:
 	kfree(ctx-&gt;mech_used.data);
 out_err_free_ctx_id:
@@ -220,13 +160,16 @@ gss_import_sec_context_spkm3(const void *p, size_t len,
 }
 
 static void
-gss_delete_sec_context_spkm3(void *internal_ctx) {
+gss_delete_sec_context_spkm3(void *internal_ctx)
+{
 	struct spkm3_ctx *sctx = internal_ctx;
 
-	crypto_free_blkcipher(sctx-&gt;derived_integ_key);
-	crypto_free_blkcipher(sctx-&gt;derived_conf_key);
-	kfree(sctx-&gt;share_key.data);
+	kfree(sctx-&gt;derived_integ_key.data);
+	kfree(sctx-&gt;intg_alg.data);
+	kfree(sctx-&gt;derived_conf_key.data);
+	kfree(sctx-&gt;conf_alg.data);
 	kfree(sctx-&gt;mech_used.data);
+	kfree(sctx-&gt;ctx_id.data);
 	kfree(sctx);
 }
 
@@ -238,7 +181,6 @@ gss_verify_mic_spkm3(struct gss_ctx		*ctx,
 	u32 maj_stat = 0;
 	struct spkm3_ctx *sctx = ctx-&gt;internal_ctx_id;
 
-	dprintk("RPC: gss_verify_mic_spkm3 calling spkm3_read_token\n");
 	maj_stat = spkm3_read_token(sctx, checksum, signbuf, SPKM_MIC_TOK);
 
 	dprintk("RPC: gss_verify_mic_spkm3 returning %d\n", maj_stat);
@@ -253,10 +195,9 @@ gss_get_mic_spkm3(struct gss_ctx	*ctx,
 	u32 err = 0;
 	struct spkm3_ctx *sctx = ctx-&gt;internal_ctx_id;
 
-	dprintk("RPC: gss_get_mic_spkm3\n");
-
 	err = spkm3_make_token(sctx, message_buffer,
-			      message_token, SPKM_MIC_TOK);
+				message_token, SPKM_MIC_TOK);
+	dprintk("RPC: gss_get_mic_spkm3 returning %d\n", err);
 	return err;
 }
 
diff --git a/net/sunrpc/auth_gss/gss_spkm3_seal.c b/net/sunrpc/auth_gss/gss_spkm3_seal.c
index 18c7862bc234..b179d58c6249 100644
--- a/net/sunrpc/auth_gss/gss_spkm3_seal.c
+++ b/net/sunrpc/auth_gss/gss_spkm3_seal.c
@@ -39,11 +39,17 @@
 #include &lt;linux/sunrpc/gss_spkm3.h&gt;
 #include &lt;linux/random.h&gt;
 #include &lt;linux/crypto.h&gt;
+#include &lt;linux/pagemap.h&gt;
+#include &lt;linux/scatterlist.h&gt;
+#include &lt;linux/sunrpc/xdr.h&gt;
 
 #ifdef RPC_DEBUG
 # define RPCDBG_FACILITY        RPCDBG_AUTH
 #endif
 
+const struct xdr_netobj hmac_md5_oid = { 8, "\x2B\x06\x01\x05\x05\x08\x01\x01"};
+const struct xdr_netobj cast5_cbc_oid = {9, "\x2A\x86\x48\x86\xF6\x7D\x07\x42\x0A"};
+
 /*
  * spkm3_make_token()
  *
@@ -66,29 +72,23 @@ spkm3_make_token(struct spkm3_ctx *ctx,
 	int			ctxelen = 0, ctxzbit = 0;
 	int			md5elen = 0, md5zbit = 0;
 
-	dprintk("RPC: spkm3_make_token\n");
-
 	now = jiffies;
 
 	if (ctx-&gt;ctx_id.len != 16) {
 		dprintk("RPC: spkm3_make_token BAD ctx_id.len %d\n",
-			ctx-&gt;ctx_id.len);
+				ctx-&gt;ctx_id.len);
 		goto out_err;
 	}
-		
-	switch (ctx-&gt;intg_alg) {
-		case NID_md5:
-			checksum_type = CKSUMTYPE_RSA_MD5;
-			break;
-		default:
-			dprintk("RPC: gss_spkm3_seal: ctx-&gt;signalg %d not"
-				" supported\n", ctx-&gt;intg_alg);
-			goto out_err;
-	}
-	/* XXX since we don't support WRAP, perhaps we don't care... */
-	if (ctx-&gt;conf_alg != NID_cast5_cbc) {
-		dprintk("RPC: gss_spkm3_seal: ctx-&gt;sealalg %d not supported\n",
-			ctx-&gt;conf_alg);
+
+	if (!g_OID_equal(&amp;ctx-&gt;intg_alg, &amp;hmac_md5_oid)) {
+		dprintk("RPC: gss_spkm3_seal: unsupported I-ALG algorithm."
+				"only support hmac-md5 I-ALG.\n");
+		goto out_err;
+	} else
+		checksum_type = CKSUMTYPE_HMAC_MD5;
+
+	if (!g_OID_equal(&amp;ctx-&gt;conf_alg, &amp;cast5_cbc_oid)) {
+		dprintk("RPC: gss_spkm3_seal: unsupported C-ALG algorithm\n");
 		goto out_err;
 	}
 
@@ -96,10 +96,10 @@ spkm3_make_token(struct spkm3_ctx *ctx,
 		/* Calculate checksum over the mic-header */
 		asn1_bitstring_len(&amp;ctx-&gt;ctx_id, &amp;ctxelen, &amp;ctxzbit);
 		spkm3_mic_header(&amp;mic_hdr.data, &amp;mic_hdr.len, ctx-&gt;ctx_id.data,
-		                         ctxelen, ctxzbit);
-
-		if (make_checksum(checksum_type, mic_hdr.data, mic_hdr.len, 
-		                             text, 0, &amp;md5cksum))
+				ctxelen, ctxzbit);
+		if (make_spkm3_checksum(checksum_type, &amp;ctx-&gt;derived_integ_key,
+					(char *)mic_hdr.data, mic_hdr.len,
+					text, 0, &amp;md5cksum))
 			goto out_err;
 
 		asn1_bitstring_len(&amp;md5cksum, &amp;md5elen, &amp;md5zbit);
@@ -121,7 +121,66 @@ spkm3_make_token(struct spkm3_ctx *ctx,
 
 	return  GSS_S_COMPLETE;
 out_err:
+	if (md5cksum.data)
+		kfree(md5cksum.data);
+
 	token-&gt;data = NULL;
 	token-&gt;len = 0;
 	return GSS_S_FAILURE;
 }
+
+static int
+spkm3_checksummer(struct scatterlist *sg, void *data)
+{
+	struct hash_desc *desc = data;
+
+	return crypto_hash_update(desc, sg, sg-&gt;length);
+}
+
+/* checksum the plaintext data and hdrlen bytes of the token header */
+s32
+make_spkm3_checksum(s32 cksumtype, struct xdr_netobj *key, char *header,
+		    unsigned int hdrlen, struct xdr_buf *body,
+		    unsigned int body_offset, struct xdr_netobj *cksum)
+{
+	char				*cksumname;
+	struct hash_desc		desc; /* XXX add to ctx? */
+	struct scatterlist		sg[1];
+	int err;
+
+	switch (cksumtype) {
+		case CKSUMTYPE_HMAC_MD5:
+			cksumname = "md5";
+			break;
+		default:
+			dprintk("RPC:      spkm3_make_checksum:"
+					" unsupported checksum %d", cksumtype);
+			return GSS_S_FAILURE;
+	}
+
+	if (key-&gt;data == NULL || key-&gt;len &lt;= 0) return GSS_S_FAILURE;
+
+	desc.tfm = crypto_alloc_hash(cksumname, 0, CRYPTO_ALG_ASYNC);
+	if (IS_ERR(desc.tfm))
+		return GSS_S_FAILURE;
+	cksum-&gt;len = crypto_hash_digestsize(desc.tfm);
+	desc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;
+
+	err = crypto_hash_setkey(desc.tfm, key-&gt;data, key-&gt;len);
+	if (err)
+		goto out;
+
+	sg_set_buf(sg, header, hdrlen);
+	crypto_hash_update(&amp;desc, sg, 1);
+
+	xdr_process_buf(body, body_offset, body-&gt;len - body_offset,
+			spkm3_checksummer, &amp;desc);
+	crypto_hash_final(&amp;desc, cksum-&gt;data);
+
+out:
+	crypto_free_hash(desc.tfm);
+
+	return err ? GSS_S_FAILURE : 0;
+}
+
+EXPORT_SYMBOL(make_spkm3_checksum);
diff --git a/net/sunrpc/auth_gss/gss_spkm3_token.c b/net/sunrpc/auth_gss/gss_spkm3_token.c
index 854a983ccf26..35188b6ea8f7 100644
--- a/net/sunrpc/auth_gss/gss_spkm3_token.c
+++ b/net/sunrpc/auth_gss/gss_spkm3_token.c
@@ -172,10 +172,10 @@ spkm3_mic_header(unsigned char **hdrbuf, unsigned int *hdrlen, unsigned char *ct
 	*(u8 *)hptr++ = zbit;
 	memcpy(hptr, ctxdata, elen);
 	hptr += elen;
-	*hdrlen = hptr - top; 
+	*hdrlen = hptr - top;
 }
-		
-/* 
+
+/*
  * spkm3_mic_innercontext_token()
  *
  * *tokp points to the beginning of the SPKM_MIC token  described 
diff --git a/net/sunrpc/auth_gss/gss_spkm3_unseal.c b/net/sunrpc/auth_gss/gss_spkm3_unseal.c
index 544eb6fd9094..e54581ca7570 100644
--- a/net/sunrpc/auth_gss/gss_spkm3_unseal.c
+++ b/net/sunrpc/auth_gss/gss_spkm3_unseal.c
@@ -54,66 +54,70 @@ spkm3_read_token(struct spkm3_ctx *ctx,
 		struct xdr_buf *message_buffer, /* signbuf */
 		int toktype)
 {
+	s32			checksum_type;
 	s32			code;
 	struct xdr_netobj	wire_cksum = {.len =0, .data = NULL};
 	char			cksumdata[16];
 	struct xdr_netobj	md5cksum = {.len = 0, .data = cksumdata};
 	unsigned char		*ptr = (unsigned char *)read_token-&gt;data;
-	unsigned char           *cksum;
+	unsigned char		*cksum;
 	int			bodysize, md5elen;
 	int			mic_hdrlen;
 	u32			ret = GSS_S_DEFECTIVE_TOKEN;
 
-	dprintk("RPC: spkm3_read_token read_token-&gt;len %d\n", read_token-&gt;len);
-
 	if (g_verify_token_header((struct xdr_netobj *) &amp;ctx-&gt;mech_used,
 					&amp;bodysize, &amp;ptr, read_token-&gt;len))
 		goto out;
 
 	/* decode the token */
 
-	if (toktype == SPKM_MIC_TOK) {
-
-		if ((ret = spkm3_verify_mic_token(&amp;ptr, &amp;mic_hdrlen, &amp;cksum))) 
-			goto out;
-
-		if (*cksum++ != 0x03) {
-			dprintk("RPC: spkm3_read_token BAD checksum type\n");
-			goto out;
-		}
-		md5elen = *cksum++; 
-		cksum++; 	/* move past the zbit */
-	
-		if(!decode_asn1_bitstring(&amp;wire_cksum, cksum, md5elen - 1, 16))
-			goto out;
-
-		/* HARD CODED FOR MD5 */
-
-		/* compute the checksum of the message.
-		*  ptr + 2 = start of header piece of checksum
-		*  mic_hdrlen + 2 = length of header piece of checksum
-		*/
-		ret = GSS_S_DEFECTIVE_TOKEN;
-		code = make_checksum(CKSUMTYPE_RSA_MD5, ptr + 2, 
-					mic_hdrlen + 2, 
-		                        message_buffer, 0, &amp;md5cksum);
-
-		if (code)
-			goto out;
-
-		dprintk("RPC: spkm3_read_token: digest wire_cksum.len %d:\n", 
-			wire_cksum.len);
-
-		ret = GSS_S_BAD_SIG;
-		code = memcmp(md5cksum.data, wire_cksum.data, wire_cksum.len);
-		if (code)
-			goto out;
-
-	} else { 
-		dprintk("RPC: BAD or UNSUPPORTED SPKM3 token type: %d\n",toktype);
+	if (toktype != SPKM_MIC_TOK) {
+		dprintk("RPC: BAD SPKM3 token type: %d\n", toktype);
+		goto out;
+	}
+
+	if ((ret = spkm3_verify_mic_token(&amp;ptr, &amp;mic_hdrlen, &amp;cksum)))
+		goto out;
+
+	if (*cksum++ != 0x03) {
+		dprintk("RPC: spkm3_read_token BAD checksum type\n");
+		goto out;
+	}
+	md5elen = *cksum++;
+	cksum++; 	/* move past the zbit */
+
+	if (!decode_asn1_bitstring(&amp;wire_cksum, cksum, md5elen - 1, 16))
+		goto out;
+
+	/* HARD CODED FOR MD5 */
+
+	/* compute the checksum of the message.
+	 * ptr + 2 = start of header piece of checksum
+	 * mic_hdrlen + 2 = length of header piece of checksum
+	 */
+	ret = GSS_S_DEFECTIVE_TOKEN;
+	if (!g_OID_equal(&amp;ctx-&gt;intg_alg, &amp;hmac_md5_oid)) {
+		dprintk("RPC: gss_spkm3_seal: unsupported I-ALG algorithm\n");
+		goto out;
+	}
+
+	checksum_type = CKSUMTYPE_HMAC_MD5;
+
+	code = make_spkm3_checksum(checksum_type,
+		&amp;ctx-&gt;derived_integ_key, ptr + 2, mic_hdrlen + 2,
+		message_buffer, 0, &amp;md5cksum);
+
+	if (code)
+		goto out;
+
+	ret = GSS_S_BAD_SIG;
+	code = memcmp(md5cksum.data, wire_cksum.data, wire_cksum.len);
+	if (code) {
+		dprintk("RPC: bad MIC checksum\n");
 		goto out;
 	}
 
+
 	/* XXX: need to add expiration and sequencing */
 	ret = GSS_S_COMPLETE;
 out:</pre><hr><pre>commit 37a4e6cb0391f2293ba3d59e3a63ec0e56ed720d
Author: Olga Kornievskaia &lt;aglo@citi.umich.edu&gt;
Date:   Mon Dec 4 20:22:33 2006 -0500

    rpc: move process_xdr_buf
    
    Since process_xdr_buf() is useful outside of the kerberos-specific code, we
    move it to net/sunrpc/xdr.c, export it, and rename it in keeping with xdr_*
    naming convention of xdr.c.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/include/linux/sunrpc/xdr.h b/include/linux/sunrpc/xdr.h
index 441b91dbafe5..4d17846cd78a 100644
--- a/include/linux/sunrpc/xdr.h
+++ b/include/linux/sunrpc/xdr.h
@@ -11,6 +11,7 @@
 
 #include &lt;linux/uio.h&gt;
 #include &lt;asm/byteorder.h&gt;
+#include &lt;linux/scatterlist.h&gt;
 
 /*
  * Buffer adjustment
@@ -196,6 +197,7 @@ extern void xdr_init_decode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32
 extern __be32 *xdr_inline_decode(struct xdr_stream *xdr, size_t nbytes);
 extern void xdr_read_pages(struct xdr_stream *xdr, unsigned int len);
 extern void xdr_enter_page(struct xdr_stream *xdr, unsigned int len);
+extern int xdr_process_buf(struct xdr_buf *buf, unsigned int offset, unsigned int len, int (*actor)(struct scatterlist *, void *), void *data);
 
 #endif /* __KERNEL__ */
 
diff --git a/net/sunrpc/auth_gss/gss_krb5_crypto.c b/net/sunrpc/auth_gss/gss_krb5_crypto.c
index 4c53896f1b08..10d05ea37213 100644
--- a/net/sunrpc/auth_gss/gss_krb5_crypto.c
+++ b/net/sunrpc/auth_gss/gss_krb5_crypto.c
@@ -43,6 +43,7 @@
 #include &lt;linux/highmem.h&gt;
 #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/sunrpc/gss_krb5.h&gt;
+#include &lt;linux/sunrpc/xdr.h&gt;
 
 #ifdef RPC_DEBUG
 # define RPCDBG_FACILITY        RPCDBG_AUTH
@@ -119,72 +120,6 @@ krb5_decrypt(
 
 EXPORT_SYMBOL(krb5_decrypt);
 
-static int
-process_xdr_buf(struct xdr_buf *buf, int offset, int len,
-		int (*actor)(struct scatterlist *, void *), void *data)
-{
-	int i, page_len, thislen, page_offset, ret = 0;
-	struct scatterlist	sg[1];
-
-	if (offset &gt;= buf-&gt;head[0].iov_len) {
-		offset -= buf-&gt;head[0].iov_len;
-	} else {
-		thislen = buf-&gt;head[0].iov_len - offset;
-		if (thislen &gt; len)
-			thislen = len;
-		sg_set_buf(sg, buf-&gt;head[0].iov_base + offset, thislen);
-		ret = actor(sg, data);
-		if (ret)
-			goto out;
-		offset = 0;
-		len -= thislen;
-	}
-	if (len == 0)
-		goto out;
-
-	if (offset &gt;= buf-&gt;page_len) {
-		offset -= buf-&gt;page_len;
-	} else {
-		page_len = buf-&gt;page_len - offset;
-		if (page_len &gt; len)
-			page_len = len;
-		len -= page_len;
-		page_offset = (offset + buf-&gt;page_base) &amp; (PAGE_CACHE_SIZE - 1);
-		i = (offset + buf-&gt;page_base) &gt;&gt; PAGE_CACHE_SHIFT;
-		thislen = PAGE_CACHE_SIZE - page_offset;
-		do {
-			if (thislen &gt; page_len)
-				thislen = page_len;
-			sg-&gt;page = buf-&gt;pages[i];
-			sg-&gt;offset = page_offset;
-			sg-&gt;length = thislen;
-			ret = actor(sg, data);
-			if (ret)
-				goto out;
-			page_len -= thislen;
-			i++;
-			page_offset = 0;
-			thislen = PAGE_CACHE_SIZE;
-		} while (page_len != 0);
-		offset = 0;
-	}
-	if (len == 0)
-		goto out;
-
-	if (offset &lt; buf-&gt;tail[0].iov_len) {
-		thislen = buf-&gt;tail[0].iov_len - offset;
-		if (thislen &gt; len)
-			thislen = len;
-		sg_set_buf(sg, buf-&gt;tail[0].iov_base + offset, thislen);
-		ret = actor(sg, data);
-		len -= thislen;
-	}
-	if (len != 0)
-		ret = -EINVAL;
-out:
-	return ret;
-}
-
 static int
 checksummer(struct scatterlist *sg, void *data)
 {
@@ -225,7 +160,7 @@ make_checksum(s32 cksumtype, char *header, int hdrlen, struct xdr_buf *body,
 	err = crypto_hash_update(&amp;desc, sg, hdrlen);
 	if (err)
 		goto out;
-	err = process_xdr_buf(body, body_offset, body-&gt;len - body_offset,
+	err = xdr_process_buf(body, body_offset, body-&gt;len - body_offset,
 			      checksummer, &amp;desc);
 	if (err)
 		goto out;
@@ -323,7 +258,7 @@ gss_encrypt_xdr_buf(struct crypto_blkcipher *tfm, struct xdr_buf *buf,
 	desc.fragno = 0;
 	desc.fraglen = 0;
 
-	ret = process_xdr_buf(buf, offset, buf-&gt;len - offset, encryptor, &amp;desc);
+	ret = xdr_process_buf(buf, offset, buf-&gt;len - offset, encryptor, &amp;desc);
 	return ret;
 }
 
@@ -389,7 +324,7 @@ gss_decrypt_xdr_buf(struct crypto_blkcipher *tfm, struct xdr_buf *buf,
 	desc.desc.flags = 0;
 	desc.fragno = 0;
 	desc.fraglen = 0;
-	return process_xdr_buf(buf, offset, buf-&gt;len - offset, decryptor, &amp;desc);
+	return xdr_process_buf(buf, offset, buf-&gt;len - offset, decryptor, &amp;desc);
 }
 
 EXPORT_SYMBOL(gss_decrypt_xdr_buf);
diff --git a/net/sunrpc/xdr.c b/net/sunrpc/xdr.c
index 5a6485946f3c..a0af250ca319 100644
--- a/net/sunrpc/xdr.c
+++ b/net/sunrpc/xdr.c
@@ -1021,3 +1021,71 @@ xdr_encode_array2(struct xdr_buf *buf, unsigned int base,
 
 	return xdr_xcode_array2(buf, base, desc, 1);
 }
+
+int
+xdr_process_buf(struct xdr_buf *buf, unsigned int offset, unsigned int len,
+                int (*actor)(struct scatterlist *, void *), void *data)
+{
+	int i, ret = 0;
+	unsigned page_len, thislen, page_offset;
+	struct scatterlist      sg[1];
+
+	if (offset &gt;= buf-&gt;head[0].iov_len) {
+		offset -= buf-&gt;head[0].iov_len;
+	} else {
+		thislen = buf-&gt;head[0].iov_len - offset;
+		if (thislen &gt; len)
+			thislen = len;
+		sg_set_buf(sg, buf-&gt;head[0].iov_base + offset, thislen);
+		ret = actor(sg, data);
+		if (ret)
+			goto out;
+		offset = 0;
+		len -= thislen;
+	}
+	if (len == 0)
+		goto out;
+
+	if (offset &gt;= buf-&gt;page_len) {
+		offset -= buf-&gt;page_len;
+	} else {
+		page_len = buf-&gt;page_len - offset;
+		if (page_len &gt; len)
+			page_len = len;
+		len -= page_len;
+		page_offset = (offset + buf-&gt;page_base) &amp; (PAGE_CACHE_SIZE - 1);
+		i = (offset + buf-&gt;page_base) &gt;&gt; PAGE_CACHE_SHIFT;
+		thislen = PAGE_CACHE_SIZE - page_offset;
+		do {
+			if (thislen &gt; page_len)
+				thislen = page_len;
+			sg-&gt;page = buf-&gt;pages[i];
+			sg-&gt;offset = page_offset;
+			sg-&gt;length = thislen;
+			ret = actor(sg, data);
+			if (ret)
+				goto out;
+			page_len -= thislen;
+			i++;
+			page_offset = 0;
+			thislen = PAGE_CACHE_SIZE;
+		} while (page_len != 0);
+		offset = 0;
+	}
+	if (len == 0)
+		goto out;
+	if (offset &lt; buf-&gt;tail[0].iov_len) {
+		thislen = buf-&gt;tail[0].iov_len - offset;
+		if (thislen &gt; len)
+			thislen = len;
+		sg_set_buf(sg, buf-&gt;tail[0].iov_base + offset, thislen);
+		ret = actor(sg, data);
+		len -= thislen;
+	}
+	if (len != 0)
+		ret = -EINVAL;
+out:
+	return ret;
+}
+EXPORT_SYMBOL(xdr_process_buf);
+</pre><hr><pre>commit 8fc7500bb8ea3b5c909869d00628635e964ae882
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Dec 4 20:22:31 2006 -0500

    rpc: gss: eliminate print_hexl()'s
    
    Dumping all this data to the logs is wasteful (even when debugging is turned
    off), and creates too much output to be useful when it's turned on.
    
    Fix a minor style bug or two while we're at it.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/include/linux/sunrpc/auth_gss.h b/include/linux/sunrpc/auth_gss.h
index 97b62e97dd8d..2db2fbf34947 100644
--- a/include/linux/sunrpc/auth_gss.h
+++ b/include/linux/sunrpc/auth_gss.h
@@ -90,8 +90,6 @@ struct gss_cred {
 #define gc_flags		gc_base.cr_flags
 #define gc_expire		gc_base.cr_expire
 
-void print_hexl(u32 *p, u_int length, u_int offset);
-
 #endif /* __KERNEL__ */
 #endif /* _LINUX_SUNRPC_AUTH_GSS_H */
 
diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c
index e5a84a482e57..d12ee5f54c0c 100644
--- a/net/sunrpc/auth_gss/auth_gss.c
+++ b/net/sunrpc/auth_gss/auth_gss.c
@@ -94,46 +94,6 @@ struct gss_auth {
 static void gss_destroy_ctx(struct gss_cl_ctx *);
 static struct rpc_pipe_ops gss_upcall_ops;
 
-void
-print_hexl(u32 *p, u_int length, u_int offset)
-{
-	u_int i, j, jm;
-	u8 c, *cp;
-	
-	dprintk("RPC: print_hexl: length %d\n",length);
-	dprintk("\n");
-	cp = (u8 *) p;
-	
-	for (i = 0; i &lt; length; i += 0x10) {
-		dprintk("  %04x: ", (u_int)(i + offset));
-		jm = length - i;
-		jm = jm &gt; 16 ? 16 : jm;
-		
-		for (j = 0; j &lt; jm; j++) {
-			if ((j % 2) == 1)
-				dprintk("%02x ", (u_int)cp[i+j]);
-			else
-				dprintk("%02x", (u_int)cp[i+j]);
-		}
-		for (; j &lt; 16; j++) {
-			if ((j % 2) == 1)
-				dprintk("   ");
-			else
-				dprintk("  ");
-		}
-		dprintk(" ");
-		
-		for (j = 0; j &lt; jm; j++) {
-			c = cp[i+j];
-			c = isprint(c) ? c : '.';
-			dprintk("%c", c);
-		}
-		dprintk("\n");
-	}
-}
-
-EXPORT_SYMBOL(print_hexl);
-
 static inline struct gss_cl_ctx *
 gss_get_ctx(struct gss_cl_ctx *ctx)
 {
diff --git a/net/sunrpc/auth_gss/gss_krb5_crypto.c b/net/sunrpc/auth_gss/gss_krb5_crypto.c
index e11a40b25cce..4c53896f1b08 100644
--- a/net/sunrpc/auth_gss/gss_krb5_crypto.c
+++ b/net/sunrpc/auth_gss/gss_krb5_crypto.c
@@ -61,9 +61,6 @@ krb5_encrypt(
 	u8 local_iv[16] = {0};
 	struct blkcipher_desc desc = { .tfm = tfm, .info = local_iv };
 
-	dprintk("RPC:      krb5_encrypt: input data:\n");
-	print_hexl((u32 *)in, length, 0);
-
 	if (length % crypto_blkcipher_blocksize(tfm) != 0)
 		goto out;
 
@@ -80,12 +77,9 @@ krb5_encrypt(
 	sg_set_buf(sg, out, length);
 
 	ret = crypto_blkcipher_encrypt_iv(&amp;desc, sg, sg, length);
-
-	dprintk("RPC:      krb5_encrypt: output data:\n");
-	print_hexl((u32 *)out, length, 0);
 out:
 	dprintk("RPC:      krb5_encrypt returns %d\n",ret);
-	return(ret);
+	return ret;
 }
 
 EXPORT_SYMBOL(krb5_encrypt);
@@ -103,9 +97,6 @@ krb5_decrypt(
 	u8 local_iv[16] = {0};
 	struct blkcipher_desc desc = { .tfm = tfm, .info = local_iv };
 
-	dprintk("RPC:      krb5_decrypt: input data:\n");
-	print_hexl((u32 *)in, length, 0);
-
 	if (length % crypto_blkcipher_blocksize(tfm) != 0)
 		goto out;
 
@@ -121,12 +112,9 @@ krb5_decrypt(
 	sg_set_buf(sg, out, length);
 
 	ret = crypto_blkcipher_decrypt_iv(&amp;desc, sg, sg, length);
-
-	dprintk("RPC:      krb5_decrypt: output_data:\n");
-	print_hexl((u32 *)out, length, 0);
 out:
 	dprintk("RPC:      gss_k5decrypt returns %d\n",ret);
-	return(ret);
+	return ret;
 }
 
 EXPORT_SYMBOL(krb5_decrypt);
diff --git a/net/sunrpc/auth_gss/gss_krb5_seal.c b/net/sunrpc/auth_gss/gss_krb5_seal.c
index 08601ee4cd73..dc58af0b8b4c 100644
--- a/net/sunrpc/auth_gss/gss_krb5_seal.c
+++ b/net/sunrpc/auth_gss/gss_krb5_seal.c
@@ -129,9 +129,6 @@ gss_get_mic_kerberos(struct gss_ctx *gss_ctx, struct xdr_buf *text,
 		memcpy(krb5_hdr + 16,
 		       md5cksum.data + md5cksum.len - KRB5_CKSUM_LENGTH,
 		       KRB5_CKSUM_LENGTH);
-
-		dprintk("RPC:      make_seal_token: cksum data: \n");
-		print_hexl((u32 *) (krb5_hdr + 16), KRB5_CKSUM_LENGTH, 0);
 		break;
 	default:
 		BUG();
diff --git a/net/sunrpc/auth_gss/gss_krb5_wrap.c b/net/sunrpc/auth_gss/gss_krb5_wrap.c
index cc45c1605f80..0f512e8e0d19 100644
--- a/net/sunrpc/auth_gss/gss_krb5_wrap.c
+++ b/net/sunrpc/auth_gss/gss_krb5_wrap.c
@@ -199,9 +199,6 @@ gss_wrap_kerberos(struct gss_ctx *ctx, int offset,
 		memcpy(krb5_hdr + 16,
 		       md5cksum.data + md5cksum.len - KRB5_CKSUM_LENGTH,
 		       KRB5_CKSUM_LENGTH);
-
-		dprintk("RPC:      make_seal_token: cksum data: \n");
-		print_hexl((u32 *) (krb5_hdr + 16), KRB5_CKSUM_LENGTH, 0);
 		break;
 	default:
 		BUG();
diff --git a/net/sunrpc/auth_gss/gss_spkm3_unseal.c b/net/sunrpc/auth_gss/gss_spkm3_unseal.c
index 8537f581ef9b..544eb6fd9094 100644
--- a/net/sunrpc/auth_gss/gss_spkm3_unseal.c
+++ b/net/sunrpc/auth_gss/gss_spkm3_unseal.c
@@ -103,10 +103,6 @@ spkm3_read_token(struct spkm3_ctx *ctx,
 
 		dprintk("RPC: spkm3_read_token: digest wire_cksum.len %d:\n", 
 			wire_cksum.len);
-		dprintk("          md5cksum.data\n");
-		print_hexl((u32 *) md5cksum.data, 16, 0);
-		dprintk("          cksum.data:\n");
-		print_hexl((u32 *) wire_cksum.data, wire_cksum.len, 0);
 
 		ret = GSS_S_BAD_SIG;
 		code = memcmp(md5cksum.data, wire_cksum.data, wire_cksum.len);</pre><hr><pre>commit 2dec51466a08ac1c67da41bfd0518d43d983a2eb
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Sep 12 11:53:23 2006 -0400

    NFSv4: It's perfectly legal for clp to be NULL here....
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index 110f80e7bd4c..ec1938d4b814 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -269,7 +269,7 @@ struct nfs_client *nfs_find_client(const struct sockaddr_in *addr, int nfsversio
 	clp = __nfs_find_client(addr, nfsversion);
 	spin_unlock(&amp;nfs_client_lock);
 
-	BUG_ON(clp-&gt;cl_cons_state == 0);
+	BUG_ON(clp &amp;&amp; clp-&gt;cl_cons_state == 0);
 
 	return clp;
 }</pre><hr><pre>commit 297de4f65698ee1e1c75e27d57933b5fa8227e72
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Tue Aug 29 12:19:41 2006 -0400

    Fix a referral error Oops
    
    Fix an oops when the referral server is not responding.
    Check the error return from nfs4_set_client() in nfs4_create_referral_server.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/client.c b/fs/nfs/client.c
index a4aa47913a5c..110f80e7bd4c 100644
--- a/fs/nfs/client.c
+++ b/fs/nfs/client.c
@@ -1059,6 +1059,8 @@ struct nfs_server *nfs4_create_referral_server(struct nfs_clone_mount *data,
 			parent_server-&gt;client-&gt;cl_xprt-&gt;prot,
 			parent_client-&gt;retrans_timeo,
 			parent_client-&gt;retrans_count);
+	if (error &lt; 0)
+		goto error;
 
 	/* Initialise the client representation from the parent server */
 	nfs_server_copy_userdata(server, parent_server);</pre><hr><pre>commit 7c9fdcfb1b64c47ed618c103b617af3f86e1239c
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jun 30 01:56:19 2006 -0700

    [PATCH] knfsd: svcrpc: gss: server-side implementation of rpcsec_gss privacy
    
    Server-side implementation of rpcsec_gss privacy, which enables encryption of
    the payload of every rpc request and response.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index ce8dc0db214e..94217ec9e2dd 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -832,6 +832,74 @@ unwrap_integ_data(struct xdr_buf *buf, u32 seq, struct gss_ctx *ctx)
 	return stat;
 }
 
+static inline int
+total_buf_len(struct xdr_buf *buf)
+{
+	return buf-&gt;head[0].iov_len + buf-&gt;page_len + buf-&gt;tail[0].iov_len;
+}
+
+static void
+fix_priv_head(struct xdr_buf *buf, int pad)
+{
+	if (buf-&gt;page_len == 0) {
+		/* We need to adjust head and buf-&gt;len in tandem in this
+		 * case to make svc_defer() work--it finds the original
+		 * buffer start using buf-&gt;len - buf-&gt;head[0].iov_len. */
+		buf-&gt;head[0].iov_len -= pad;
+	}
+}
+
+static int
+unwrap_priv_data(struct svc_rqst *rqstp, struct xdr_buf *buf, u32 seq, struct gss_ctx *ctx)
+{
+	u32 priv_len, maj_stat;
+	int pad, saved_len, remaining_len, offset;
+
+	rqstp-&gt;rq_sendfile_ok = 0;
+
+	priv_len = ntohl(svc_getu32(&amp;buf-&gt;head[0]));
+	if (rqstp-&gt;rq_deferred) {
+		/* Already decrypted last time through! The sequence number
+		 * check at out_seq is unnecessary but harmless: */
+		goto out_seq;
+	}
+	/* buf-&gt;len is the number of bytes from the original start of the
+	 * request to the end, where head[0].iov_len is just the bytes
+	 * not yet read from the head, so these two values are different: */
+	remaining_len = total_buf_len(buf);
+	if (priv_len &gt; remaining_len)
+		return -EINVAL;
+	pad = remaining_len - priv_len;
+	buf-&gt;len -= pad;
+	fix_priv_head(buf, pad);
+
+	/* Maybe it would be better to give gss_unwrap a length parameter: */
+	saved_len = buf-&gt;len;
+	buf-&gt;len = priv_len;
+	maj_stat = gss_unwrap(ctx, 0, buf);
+	pad = priv_len - buf-&gt;len;
+	buf-&gt;len = saved_len;
+	buf-&gt;len -= pad;
+	/* The upper layers assume the buffer is aligned on 4-byte boundaries.
+	 * In the krb5p case, at least, the data ends up offset, so we need to
+	 * move it around. */
+	/* XXX: This is very inefficient.  It would be better to either do
+	 * this while we encrypt, or maybe in the receive code, if we can peak
+	 * ahead and work out the service and mechanism there. */
+	offset = buf-&gt;head[0].iov_len % 4;
+	if (offset) {
+		buf-&gt;buflen = RPCSVC_MAXPAYLOAD;
+		xdr_shift_buf(buf, offset);
+		fix_priv_head(buf, pad);
+	}
+	if (maj_stat != GSS_S_COMPLETE)
+		return -EINVAL;
+out_seq:
+	if (ntohl(svc_getu32(&amp;buf-&gt;head[0])) != seq)
+		return -EINVAL;
+	return 0;
+}
+
 struct gss_svc_data {
 	/* decoded gss client cred: */
 	struct rpc_gss_wire_cred	clcred;
@@ -1047,7 +1115,14 @@ svcauth_gss_accept(struct svc_rqst *rqstp, u32 *authp)
 			svc_putu32(resv, 0);
 			break;
 		case RPC_GSS_SVC_PRIVACY:
-			/* currently unsupported */
+			if (unwrap_priv_data(rqstp, &amp;rqstp-&gt;rq_arg,
+					gc-&gt;gc_seq, rsci-&gt;mechctx))
+				goto auth_err;
+			/* placeholders for length and seq. number: */
+			svcdata-&gt;body_start = resv-&gt;iov_base + resv-&gt;iov_len;
+			svc_putu32(resv, 0);
+			svc_putu32(resv, 0);
+			break;
 		default:
 			goto auth_err;
 		}
@@ -1089,9 +1164,8 @@ svcauth_gss_wrap_resp_integ(struct svc_rqst *rqstp)
 	gsd-&gt;body_start = NULL;
 	/* move accept_stat to right place: */
 	memcpy(p, p + 2, 4);
-	/* don't wrap in failure case: */
-	/* Note: counting on not getting here if call was not even
-	 * accepted! */
+	/* Don't wrap in failure case: */
+	/* Counting on not getting here if call was not even accepted! */
 	if (*p != rpc_success) {
 		resbuf-&gt;head[0].iov_len -= 2 * 4;
 		goto out;
@@ -1138,6 +1212,65 @@ svcauth_gss_wrap_resp_integ(struct svc_rqst *rqstp)
 	return stat;
 }
 
+static inline int
+svcauth_gss_wrap_resp_priv(struct svc_rqst *rqstp)
+{
+	struct gss_svc_data *gsd = (struct gss_svc_data *)rqstp-&gt;rq_auth_data;
+	struct rpc_gss_wire_cred *gc = &amp;gsd-&gt;clcred;
+	struct xdr_buf *resbuf = &amp;rqstp-&gt;rq_res;
+	struct page **inpages = NULL;
+	u32 *p;
+	int offset, *len;
+	int pad;
+
+	p = gsd-&gt;body_start;
+	gsd-&gt;body_start = NULL;
+	/* move accept_stat to right place: */
+	memcpy(p, p + 2, 4);
+	/* Don't wrap in failure case: */
+	/* Counting on not getting here if call was not even accepted! */
+	if (*p != rpc_success) {
+		resbuf-&gt;head[0].iov_len -= 2 * 4;
+		return 0;
+	}
+	p++;
+	len = p++;
+	offset = (u8 *)p - (u8 *)resbuf-&gt;head[0].iov_base;
+	*p++ = htonl(gc-&gt;gc_seq);
+	inpages = resbuf-&gt;pages;
+	/* XXX: Would be better to write some xdr helper functions for
+	 * nfs{2,3,4}xdr.c that place the data right, instead of copying: */
+	if (resbuf-&gt;tail[0].iov_base &amp;&amp; rqstp-&gt;rq_restailpage == 0) {
+		BUG_ON(resbuf-&gt;tail[0].iov_base &gt;= resbuf-&gt;head[0].iov_base
+							+ PAGE_SIZE);
+		BUG_ON(resbuf-&gt;tail[0].iov_base &lt; resbuf-&gt;head[0].iov_base);
+		if (resbuf-&gt;tail[0].iov_len + resbuf-&gt;head[0].iov_len
+				+ 2 * RPC_MAX_AUTH_SIZE &gt; PAGE_SIZE)
+			return -ENOMEM;
+		memmove(resbuf-&gt;tail[0].iov_base + RPC_MAX_AUTH_SIZE,
+			resbuf-&gt;tail[0].iov_base,
+			resbuf-&gt;tail[0].iov_len);
+		resbuf-&gt;tail[0].iov_base += RPC_MAX_AUTH_SIZE;
+	}
+	if (resbuf-&gt;tail[0].iov_base == NULL) {
+		if (resbuf-&gt;head[0].iov_len + 2*RPC_MAX_AUTH_SIZE &gt; PAGE_SIZE)
+			return -ENOMEM;
+		resbuf-&gt;tail[0].iov_base = resbuf-&gt;head[0].iov_base
+			+ resbuf-&gt;head[0].iov_len + RPC_MAX_AUTH_SIZE;
+		resbuf-&gt;tail[0].iov_len = 0;
+		rqstp-&gt;rq_restailpage = 0;
+	}
+	if (gss_wrap(gsd-&gt;rsci-&gt;mechctx, offset, resbuf, inpages))
+		return -ENOMEM;
+	*len = htonl(resbuf-&gt;len - offset);
+	pad = 3 - ((resbuf-&gt;len - offset - 1)&amp;3);
+	p = (u32 *)(resbuf-&gt;tail[0].iov_base + resbuf-&gt;tail[0].iov_len);
+	memset(p, 0, pad);
+	resbuf-&gt;tail[0].iov_len += pad;
+	resbuf-&gt;len += pad;
+	return 0;
+}
+
 static int
 svcauth_gss_release(struct svc_rqst *rqstp)
 {
@@ -1152,15 +1285,22 @@ svcauth_gss_release(struct svc_rqst *rqstp)
 	if (gsd-&gt;body_start == NULL)
 		goto out;
 	/* normally not set till svc_send, but we need it here: */
-	resbuf-&gt;len = resbuf-&gt;head[0].iov_len
-		+ resbuf-&gt;page_len + resbuf-&gt;tail[0].iov_len;
+	/* XXX: what for?  Do we mess it up the moment we call svc_putu32
+	 * or whatever? */
+	resbuf-&gt;len = total_buf_len(resbuf);
 	switch (gc-&gt;gc_svc) {
 	case RPC_GSS_SVC_NONE:
 		break;
 	case RPC_GSS_SVC_INTEGRITY:
-		svcauth_gss_wrap_resp_integ(rqstp);
+		stat = svcauth_gss_wrap_resp_integ(rqstp);
+		if (stat)
+			goto out_err;
 		break;
 	case RPC_GSS_SVC_PRIVACY:
+		stat = svcauth_gss_wrap_resp_priv(rqstp);
+		if (stat)
+			goto out_err;
+		break;
 	default:
 		goto out_err;
 	}
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index fb168a30fd3f..01ba60a49572 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -280,6 +280,7 @@ svc_process(struct svc_serv *serv, struct svc_rqst *rqstp)
 	rqstp-&gt;rq_res.page_base = 0;
 	rqstp-&gt;rq_res.page_len = 0;
 	rqstp-&gt;rq_res.buflen = PAGE_SIZE;
+	rqstp-&gt;rq_res.tail[0].iov_base = NULL;
 	rqstp-&gt;rq_res.tail[0].iov_len = 0;
 	/* Will be turned off only in gss privacy case: */
 	rqstp-&gt;rq_sendfile_ok = 1;</pre><hr><pre>commit 5c04c46aec16b3267d8fe03af886f2d41e448cd0
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jun 30 01:56:19 2006 -0700

    [PATCH] knfsd: nfsd: mark rqstp to prevent use of sendfile in privacy case
    
    Add a rq_sendfile_ok flag to svc_rqst which will be cleared in the privacy
    case so that the wrapping code will get copies of the read data instead of
    real page cache pages.  This makes life simpler when we encrypt the response.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 423e1ba07044..e170030d45da 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -837,7 +837,7 @@ nfsd_vfs_read(struct svc_rqst *rqstp, struct svc_fh *fhp, struct file *file,
 	if (ra &amp;&amp; ra-&gt;p_set)
 		file-&gt;f_ra = ra-&gt;p_ra;
 
-	if (file-&gt;f_op-&gt;sendfile) {
+	if (file-&gt;f_op-&gt;sendfile &amp;&amp; rqstp-&gt;rq_sendfile_ok) {
 		svc_pushback_unused_pages(rqstp);
 		err = file-&gt;f_op-&gt;sendfile(file, &amp;offset, *count,
 						 nfsd_read_actor, rqstp);
diff --git a/include/linux/sunrpc/svc.h b/include/linux/sunrpc/svc.h
index 503564384545..7b27c09b5604 100644
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@ -159,7 +159,9 @@ struct svc_rqst {
 						 * determine what device number
 						 * to report (real or virtual)
 						 */
-
+	int			rq_sendfile_ok; /* turned off in gss privacy
+						 * to prevent encrypting page
+						 * cache pages */
 	wait_queue_head_t	rq_wait;	/* synchronization */
 };
 
diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c
index b08419e1fc68..fb168a30fd3f 100644
--- a/net/sunrpc/svc.c
+++ b/net/sunrpc/svc.c
@@ -281,6 +281,8 @@ svc_process(struct svc_serv *serv, struct svc_rqst *rqstp)
 	rqstp-&gt;rq_res.page_len = 0;
 	rqstp-&gt;rq_res.buflen = PAGE_SIZE;
 	rqstp-&gt;rq_res.tail[0].iov_len = 0;
+	/* Will be turned off only in gss privacy case: */
+	rqstp-&gt;rq_sendfile_ok = 1;
 	/* tcp needs a space for the record length... */
 	if (rqstp-&gt;rq_prot == IPPROTO_TCP)
 		svc_putu32(resv, 0);</pre><hr><pre>commit e142ede8e064cb1ae9c2bfb17f36ab145b95ccd2
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jun 30 01:56:18 2006 -0700

    [PATCH] knfsd: svcrpc: Simplify nfsd rpcsec_gss integrity code
    
    Pull out some of the integrity code into its own function, otherwise
    svcauth_gss_release() is going to become very ungainly after the addition of
    privacy code.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index 71f57a5d800d..ce8dc0db214e 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -1072,8 +1072,8 @@ svcauth_gss_accept(struct svc_rqst *rqstp, u32 *authp)
 	return ret;
 }
 
-static int
-svcauth_gss_release(struct svc_rqst *rqstp)
+static inline int
+svcauth_gss_wrap_resp_integ(struct svc_rqst *rqstp)
 {
 	struct gss_svc_data *gsd = (struct gss_svc_data *)rqstp-&gt;rq_auth_data;
 	struct rpc_gss_wire_cred *gc = &amp;gsd-&gt;clcred;
@@ -1085,6 +1085,67 @@ svcauth_gss_release(struct svc_rqst *rqstp)
 	int integ_offset, integ_len;
 	int stat = -EINVAL;
 
+	p = gsd-&gt;body_start;
+	gsd-&gt;body_start = NULL;
+	/* move accept_stat to right place: */
+	memcpy(p, p + 2, 4);
+	/* don't wrap in failure case: */
+	/* Note: counting on not getting here if call was not even
+	 * accepted! */
+	if (*p != rpc_success) {
+		resbuf-&gt;head[0].iov_len -= 2 * 4;
+		goto out;
+	}
+	p++;
+	integ_offset = (u8 *)(p + 1) - (u8 *)resbuf-&gt;head[0].iov_base;
+	integ_len = resbuf-&gt;len - integ_offset;
+	BUG_ON(integ_len % 4);
+	*p++ = htonl(integ_len);
+	*p++ = htonl(gc-&gt;gc_seq);
+	if (xdr_buf_subsegment(resbuf, &amp;integ_buf, integ_offset,
+				integ_len))
+		BUG();
+	if (resbuf-&gt;page_len == 0
+			&amp;&amp; resbuf-&gt;head[0].iov_len + RPC_MAX_AUTH_SIZE
+			&lt; PAGE_SIZE) {
+		BUG_ON(resbuf-&gt;tail[0].iov_len);
+		/* Use head for everything */
+		resv = &amp;resbuf-&gt;head[0];
+	} else if (resbuf-&gt;tail[0].iov_base == NULL) {
+		if (resbuf-&gt;head[0].iov_len + RPC_MAX_AUTH_SIZE &gt; PAGE_SIZE)
+			goto out_err;
+		resbuf-&gt;tail[0].iov_base = resbuf-&gt;head[0].iov_base
+						+ resbuf-&gt;head[0].iov_len;
+		resbuf-&gt;tail[0].iov_len = 0;
+		rqstp-&gt;rq_restailpage = 0;
+		resv = &amp;resbuf-&gt;tail[0];
+	} else {
+		resv = &amp;resbuf-&gt;tail[0];
+	}
+	mic.data = (u8 *)resv-&gt;iov_base + resv-&gt;iov_len + 4;
+	if (gss_get_mic(gsd-&gt;rsci-&gt;mechctx, &amp;integ_buf, &amp;mic))
+		goto out_err;
+	svc_putu32(resv, htonl(mic.len));
+	memset(mic.data + mic.len, 0,
+			round_up_to_quad(mic.len) - mic.len);
+	resv-&gt;iov_len += XDR_QUADLEN(mic.len) &lt;&lt; 2;
+	/* not strictly required: */
+	resbuf-&gt;len += XDR_QUADLEN(mic.len) &lt;&lt; 2;
+	BUG_ON(resv-&gt;iov_len &gt; PAGE_SIZE);
+out:
+	stat = 0;
+out_err:
+	return stat;
+}
+
+static int
+svcauth_gss_release(struct svc_rqst *rqstp)
+{
+	struct gss_svc_data *gsd = (struct gss_svc_data *)rqstp-&gt;rq_auth_data;
+	struct rpc_gss_wire_cred *gc = &amp;gsd-&gt;clcred;
+	struct xdr_buf *resbuf = &amp;rqstp-&gt;rq_res;
+	int stat = -EINVAL;
+
 	if (gc-&gt;gc_proc != RPC_GSS_PROC_DATA)
 		goto out;
 	/* Release can be called twice, but we only wrap once. */
@@ -1097,55 +1158,7 @@ svcauth_gss_release(struct svc_rqst *rqstp)
 	case RPC_GSS_SVC_NONE:
 		break;
 	case RPC_GSS_SVC_INTEGRITY:
-		p = gsd-&gt;body_start;
-		gsd-&gt;body_start = NULL;
-		/* move accept_stat to right place: */
-		memcpy(p, p + 2, 4);
-		/* don't wrap in failure case: */
-		/* Note: counting on not getting here if call was not even
-		 * accepted! */
-		if (*p != rpc_success) {
-			resbuf-&gt;head[0].iov_len -= 2 * 4;
-			goto out;
-		}
-		p++;
-		integ_offset = (u8 *)(p + 1) - (u8 *)resbuf-&gt;head[0].iov_base;
-		integ_len = resbuf-&gt;len - integ_offset;
-		BUG_ON(integ_len % 4);
-		*p++ = htonl(integ_len);
-		*p++ = htonl(gc-&gt;gc_seq);
-		if (xdr_buf_subsegment(resbuf, &amp;integ_buf, integ_offset,
-					integ_len))
-			BUG();
-		if (resbuf-&gt;page_len == 0
-			&amp;&amp; resbuf-&gt;head[0].iov_len + RPC_MAX_AUTH_SIZE
-				&lt; PAGE_SIZE) {
-			BUG_ON(resbuf-&gt;tail[0].iov_len);
-			/* Use head for everything */
-			resv = &amp;resbuf-&gt;head[0];
-		} else if (resbuf-&gt;tail[0].iov_base == NULL) {
-			if (resbuf-&gt;head[0].iov_len + RPC_MAX_AUTH_SIZE
-					&gt; PAGE_SIZE)
-				goto out_err;
-			resbuf-&gt;tail[0].iov_base =
-				resbuf-&gt;head[0].iov_base
-				+ resbuf-&gt;head[0].iov_len;
-			resbuf-&gt;tail[0].iov_len = 0;
-			rqstp-&gt;rq_restailpage = 0;
-			resv = &amp;resbuf-&gt;tail[0];
-		} else {
-			resv = &amp;resbuf-&gt;tail[0];
-		}
-		mic.data = (u8 *)resv-&gt;iov_base + resv-&gt;iov_len + 4;
-		if (gss_get_mic(gsd-&gt;rsci-&gt;mechctx, &amp;integ_buf, &amp;mic))
-			goto out_err;
-		svc_putu32(resv, htonl(mic.len));
-		memset(mic.data + mic.len, 0,
-				round_up_to_quad(mic.len) - mic.len);
-		resv-&gt;iov_len += XDR_QUADLEN(mic.len) &lt;&lt; 2;
-		/* not strictly required: */
-		resbuf-&gt;len += XDR_QUADLEN(mic.len) &lt;&lt; 2;
-		BUG_ON(resv-&gt;iov_len &gt; PAGE_SIZE);
+		svcauth_gss_wrap_resp_integ(rqstp);
 		break;
 	case RPC_GSS_SVC_PRIVACY:
 	default:</pre><hr><pre>commit 9ecb6a08d84d0e795648d5add64f154bc406914b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jun 30 01:56:17 2006 -0700

    [PATCH] knfsd: nfsd4: fix open flag passing
    
    Since nfsv4 actually keeps around the file descriptors it gets from open
    (instead of just using them for a single read or write operation), we need to
    make sure that we can do RDWR opens and not just RDONLY/WRONLY.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 591dc6ba6e19..9daa0b9feb8d 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1790,10 +1790,10 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	} else {
 		/* Stateid was not found, this is a new OPEN */
 		int flags = 0;
+		if (open-&gt;op_share_access &amp; NFS4_SHARE_ACCESS_READ)
+			flags |= MAY_READ;
 		if (open-&gt;op_share_access &amp; NFS4_SHARE_ACCESS_WRITE)
-			flags = MAY_WRITE;
-		else
-			flags = MAY_READ;
+			flags |= MAY_WRITE;
 		status = nfs4_new_open(rqstp, &amp;stp, dp, current_fh, flags);
 		if (status)
 			goto out;
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index f916b170e136..423e1ba07044 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -673,7 +673,10 @@ nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, int type,
 		goto out_nfserr;
 
 	if (access &amp; MAY_WRITE) {
-		flags = O_WRONLY|O_LARGEFILE;
+		if (access &amp; MAY_READ)
+			flags = O_RDWR|O_LARGEFILE;
+		else
+			flags = O_WRONLY|O_LARGEFILE;
 
 		DQUOT_INIT(inode);
 	}</pre><hr><pre>commit ba5a6a19d83babe00be3711db3deee5c57587b8f
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jun 30 01:56:16 2006 -0700

    [PATCH] knfsd: nfsd4: fix some open argument tests
    
    These tests always returned true; clearly that wasn't what was intended.
    
    In keeping with kernel style, make them functions instead of macros while
    we're at it.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 4810577347cf..591dc6ba6e19 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1237,8 +1237,15 @@ find_file(struct inode *ino)
 	return NULL;
 }
 
-#define TEST_ACCESS(x) ((x &gt; 0 || x &lt; 4)?1:0)
-#define TEST_DENY(x) ((x &gt;= 0 || x &lt; 5)?1:0)
+static int access_valid(u32 x)
+{
+	return (x &gt; 0 &amp;&amp; x &lt; 4);
+}
+
+static int deny_valid(u32 x)
+{
+	return (x &gt;= 0 &amp;&amp; x &lt; 5);
+}
 
 static void
 set_access(unsigned int *access, unsigned long bmap) {
@@ -1745,7 +1752,8 @@ nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf
 	int status;
 
 	status = nfserr_inval;
-	if (!TEST_ACCESS(open-&gt;op_share_access) || !TEST_DENY(open-&gt;op_share_deny))
+	if (!access_valid(open-&gt;op_share_access)
+			|| !deny_valid(open-&gt;op_share_deny))
 		goto out;
 	/*
 	 * Lookup file; if found, lookup stateid and check open request,
@@ -2317,7 +2325,8 @@ nfsd4_open_downgrade(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct n
 			(int)current_fh-&gt;fh_dentry-&gt;d_name.len,
 			current_fh-&gt;fh_dentry-&gt;d_name.name);
 
-	if (!TEST_ACCESS(od-&gt;od_share_access) || !TEST_DENY(od-&gt;od_share_deny))
+	if (!access_valid(od-&gt;od_share_access)
+			|| !deny_valid(od-&gt;od_share_deny))
 		return nfserr_inval;
 
 	nfs4_lock_state();</pre>
    <div class="pagination">
        <a href='4_48.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><span>[49]</span><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_50.html'>Next&gt;&gt;</a>
    <div>
</body>
