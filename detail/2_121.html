<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_120.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><span>[121]</span><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_122.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 455b25fb209c8241e2163b491228b28667d82c1c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 11 16:01:45 2006 -0400

    usbcore: make hcd_endpoint_disable wait for queue to drain
    
    The inconsistent lock state problem in usbcore (the one that shows up
    when an HCD is unloaded) comes down to two inter-related problems:
    
            usb_rh_urb_dequeue() isn't set up to be called with interrupts
            disabled.
    
            hcd_endpoint_disable() doesn't wait for all URBs on the
            endpoint's queue to complete.
    
    The two problems are related because the one type of URB that isn't
    likely to be complete when hcd_endpoint_disable() returns is a root-hub
    URB.  Right now usb_rh_urb_dequeue() waits for them to complete, and it
    assumes interrupts are enabled so it can wait.  But
    hcd_endpoint_disable() calls it with interrupts disabled.
    
    Now, it should be legal to unlink root-hub URBs with interrupts
    disabled.  The solution is to move the waiting into
    hcd_endpoint_disable(), where it belongs.  This patch (as754) does that.
    
    It turns out to be completely safe to replace the del_timer_sync() with
    a simple del_timer().  It doesn't matter if the timer routine is
    running; hcd_root_hub_lock will synchronize the two threads and the
    status URB will complete with an unlink error, as it should.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index dc9628c58933..ea20a3a5a9b9 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -633,31 +633,20 @@ static int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)
 
 /*-------------------------------------------------------------------------*/
 
-/* Asynchronous unlinks of root-hub control URBs are legal, but they
- * don't do anything.  Status URB unlinks must be made in process context
- * with interrupts enabled.
+/* Unlinks of root-hub control URBs are legal, but they don't do anything
+ * since these URBs always execute synchronously.
  */
 static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 {
-	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
-		if (in_interrupt())
-			return 0;		/* nothing to do */
-
-		spin_lock_irq(&amp;urb-&gt;lock);	/* from usb_kill_urb */
-		++urb-&gt;reject;
-		spin_unlock_irq(&amp;urb-&gt;lock);
-
-		wait_event(usb_kill_urb_queue,
-				atomic_read(&amp;urb-&gt;use_count) == 0);
+	unsigned long	flags;
 
-		spin_lock_irq(&amp;urb-&gt;lock);
-		--urb-&gt;reject;
-		spin_unlock_irq(&amp;urb-&gt;lock);
+	if (usb_pipeendpoint(urb-&gt;pipe) == 0) {	/* Control URB */
+		;	/* Do nothing */
 
 	} else {				/* Status URB */
 		if (!hcd-&gt;uses_new_polling)
-			del_timer_sync (&amp;hcd-&gt;rh_timer);
-		local_irq_disable ();
+			del_timer (&amp;hcd-&gt;rh_timer);
+		local_irq_save (flags);
 		spin_lock (&amp;hcd_root_hub_lock);
 		if (urb == hcd-&gt;status_urb) {
 			hcd-&gt;status_urb = NULL;
@@ -667,7 +656,7 @@ static int usb_rh_urb_dequeue (struct usb_hcd *hcd, struct urb *urb)
 		spin_unlock (&amp;hcd_root_hub_lock);
 		if (urb)
 			usb_hcd_giveback_urb (hcd, urb, NULL);
-		local_irq_enable ();
+		local_irq_restore (flags);
 	}
 
 	return 0;
@@ -1355,7 +1344,8 @@ static int hcd_unlink_urb (struct urb *urb, int status)
 /*-------------------------------------------------------------------------*/
 
 /* disables the endpoint: cancels any pending urbs, then synchronizes with
- * the hcd to make sure all endpoint state is gone from hardware. use for
+ * the hcd to make sure all endpoint state is gone from hardware, and then
+ * waits until the endpoint's queue is completely drained. use for
  * set_configuration, set_interface, driver removal, physical disconnect.
  *
  * example:  a qh stored in ep-&gt;hcpriv, holding state related to endpoint
@@ -1374,22 +1364,13 @@ hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
 
 	local_irq_disable ();
 
-	/* FIXME move most of this into message.c as part of its
-	 * endpoint disable logic
-	 */
-
 	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */
 rescan:
 	spin_lock (&amp;hcd_data_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	tmp;
 
-		/* another cpu may be in hcd, spinning on hcd_data_lock
-		 * to giveback() this urb.  the races here should be
-		 * small, but a full fix needs a new "can't submit"
-		 * urb state.
-		 * FIXME urb-&gt;reject should allow that...
-		 */
+		/* the urb may already have been unlinked */
 		if (urb-&gt;status != -EINPROGRESS)
 			continue;
 		usb_get_urb (urb);
@@ -1431,6 +1412,30 @@ hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
 	might_sleep ();
 	if (hcd-&gt;driver-&gt;endpoint_disable)
 		hcd-&gt;driver-&gt;endpoint_disable (hcd, ep);
+
+	/* Wait until the endpoint queue is completely empty.  Most HCDs
+	 * will have done this already in their endpoint_disable method,
+	 * but some might not.  And there could be root-hub control URBs
+	 * still pending since they aren't affected by the HCDs'
+	 * endpoint_disable methods.
+	 */
+	while (!list_empty (&amp;ep-&gt;urb_list)) {
+		spin_lock_irq (&amp;hcd_data_lock);
+
+		/* The list may have changed while we acquired the spinlock */
+		urb = NULL;
+		if (!list_empty (&amp;ep-&gt;urb_list)) {
+			urb = list_entry (ep-&gt;urb_list.prev, struct urb,
+					urb_list);
+			usb_get_urb (urb);
+		}
+		spin_unlock_irq (&amp;hcd_data_lock);
+
+		if (urb) {
+			usb_kill_urb (urb);
+			usb_put_urb (urb);
+		}
+	}
 }
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit de06a3b842b31b31220637c869f112cfbc1a5ef6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 11 11:33:58 2006 -0400

    UHCI: increase Resume-Detect-off delay
    
    The UHCI controller in my laptop takes longer to turn off the
    Resume-Detect bit than the 4 us allowed by uhci-hcd.  Presumably other
    computers will have the same problem.
    
    This patch (as752) increases the maximum delay to 10 us, which should be
    plenty, and uses polling to avoid penalizing systems which can turn the
    bit off more quickly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index c545ef92fe29..16fb72eb6fc9 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -84,6 +84,7 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 		unsigned long port_addr)
 {
 	int status;
+	int i;
 
 	if (inw(port_addr) &amp; (USBPORTSC_SUSP | USBPORTSC_RD)) {
 		CLR_RH_PORTSTAT(USBPORTSC_SUSP | USBPORTSC_RD);
@@ -92,9 +93,14 @@ static void uhci_finish_suspend(struct uhci_hcd *uhci, int port,
 
 		/* The controller won't actually turn off the RD bit until
 		 * it has had a chance to send a low-speed EOP sequence,
-		 * which takes 3 bit times (= 2 microseconds).  We'll delay
-		 * slightly longer for good luck. */
-		udelay(4);
+		 * which is supposed to take 3 bit times (= 2 microseconds).
+		 * Experiments show that some controllers take longer, so
+		 * we'll poll for completion. */
+		for (i = 0; i &lt; 10; ++i) {
+			if (!(inw(port_addr) &amp; USBPORTSC_RD))
+				break;
+			udelay(1);
+		}
 	}
 	clear_bit(port, &amp;uhci-&gt;resuming_ports);
 }</pre><hr><pre>commit d388dab7b562b76525761f89702246686747ba30
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:14:24 2006 -0400

    hub driver: improve use of #ifdef
    
    This patch (as736) makes the hub driver more readable by improving the
    usage of "#ifdef CONFIG_PM" and "#ifdef CONFIG_USB_SUSPEND".
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a310c7cede99..64e80b964b87 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1041,7 +1041,7 @@ void usb_set_device_state(struct usb_device *udev,
 }
 
 
-#ifdef CONFIG_PM
+#ifdef	CONFIG_PM
 
 /**
  * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power
@@ -1072,7 +1072,7 @@ void usb_root_hub_lost_power(struct usb_device *rhdev)
 }
 EXPORT_SYMBOL_GPL(usb_root_hub_lost_power);
 
-#endif
+#endif	/* CONFIG_PM */
 
 static void choose_address(struct usb_device *udev)
 {
@@ -1471,6 +1471,7 @@ static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
  	kick_khubd(hub);
 }
 
+#ifdef	CONFIG_PM
 
 #ifdef	CONFIG_USB_SUSPEND
 
@@ -1569,8 +1570,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	return status;
 }
 
-#endif
-
 /*
  * usb_port_suspend - suspend a usb device's upstream port
  * @udev: device that's no longer in active use
@@ -1593,11 +1592,7 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
  */
 int usb_port_suspend(struct usb_device *udev)
 {
-#ifdef	CONFIG_USB_SUSPEND
 	return __usb_port_suspend(udev, udev-&gt;portnum);
-#else
-	return 0;
-#endif
 }
 
 /*
@@ -1661,8 +1656,6 @@ static int finish_port_resume(struct usb_device *udev)
 	return status;
 }
 
-#ifdef	CONFIG_USB_SUSPEND
-
 static int
 hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 {
@@ -1722,8 +1715,6 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 	return status;
 }
 
-#endif
-
 /*
  * usb_port_resume - re-activate a suspended usb device's upstream port
  * @udev: device to re-activate
@@ -1739,17 +1730,15 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  */
 int usb_port_resume(struct usb_device *udev)
 {
-	int	status = 0;
+	int	status;
 
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent) {
-#ifdef	CONFIG_USB_SUSPEND
 		// NOTE this fails if parent is also suspended...
 		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
 				udev-&gt;portnum, udev);
-#endif
 	} else
 		status = finish_port_resume(udev);
 	if (status &lt; 0)
@@ -1761,8 +1750,6 @@ static int remote_wakeup(struct usb_device *udev)
 {
 	int	status = 0;
 
-#ifdef	CONFIG_USB_SUSPEND
-
 	/* don't repeat RESUME sequence if this device
 	 * was already woken up by some other task
 	 */
@@ -1777,10 +1764,42 @@ static int remote_wakeup(struct usb_device *udev)
 	if (status == 0)
 		usb_resume_both(udev);
 	usb_unlock_device(udev);
-#endif
 	return status;
 }
 
+#else	/* CONFIG_USB_SUSPEND */
+
+/* When CONFIG_USB_SUSPEND isn't set, we never suspend or resume any ports. */
+
+int usb_port_suspend(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int
+finish_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int
+hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
+{
+	return 0;
+}
+
+int usb_port_resume(struct usb_device *udev)
+{
+	return 0;
+}
+
+static inline int remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
+#endif
+
 static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_hub		*hub = usb_get_intfdata (intf);
@@ -1854,6 +1873,15 @@ static int hub_resume(struct usb_interface *intf)
 	return 0;
 }
 
+#else	/* CONFIG_PM */
+
+static inline int remote_wakeup(struct usb_device *udev)
+{
+	return 0;
+}
+
+#endif
+
 void usb_suspend_root_hub(struct usb_device *hdev)
 {
 	struct usb_hub *hub = hdev_to_hub(hdev);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 74df0db954c9..98675fb1bc4c 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,11 +30,22 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+#ifdef	CONFIG_PM
+
 extern int usb_suspend_both(struct usb_device *udev, pm_message_t msg);
 extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+#else
+
+#define usb_suspend_both(udev, msg)	0
+#define usb_resume_both(udev)		0
+#define usb_port_suspend(dev)		0
+#define usb_port_resume(dev)		0
+
+#endif
+
 extern struct bus_type usb_bus_type;
 extern struct usb_device_driver usb_generic_driver;
 </pre><hr><pre>commit 1c5df7e705671f11a71112eb3a1f9765cd1719f9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:13:50 2006 -0400

    usbcore: suspending devices with no driver
    
    Since usb_generic can be unbound from a USB device, we need to be able
    to handle the possibility that a suspend or resume request arrives for a
    device with no driver.  This patch (as735) arranges things so that
    resume requests will fail and suspend requests will use the standard USB
    port-suspend code.  Attempts to suspend or resume an unbound interface
    are handled similarly (although the error caused by trying to resume an
    unbound interface is dropped by the calling routine).
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index affbfb53eb5e..a5d11461f5a9 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -761,8 +761,12 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 			udev-&gt;state == USB_STATE_SUSPENDED)
 		goto done;
 
-	if (udev-&gt;dev.driver == NULL)
+	/* For devices that don't have a driver, we do a standard suspend. */
+	if (udev-&gt;dev.driver == NULL) {
+		status = usb_port_suspend(udev);
 		goto done;
+	}
+
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;suspend(udev, msg);
 
@@ -782,8 +786,12 @@ static int resume_device(struct usb_device *udev)
 			udev-&gt;state != USB_STATE_SUSPENDED)
 		goto done;
 
-	if (udev-&gt;dev.driver == NULL)
+	/* Can't resume it if it doesn't have a driver. */
+	if (udev-&gt;dev.driver == NULL) {
+		status = -ENOTCONN;
 		goto done;
+	}
+
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	status = udriver-&gt;resume(udev);
 
@@ -804,7 +812,7 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 			!is_active(intf))
 		goto done;
 
-	if (intf-&gt;dev.driver == NULL)
+	if (intf-&gt;dev.driver == NULL)		/* This can't happen */
 		goto done;
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
@@ -838,8 +846,11 @@ static int resume_interface(struct usb_interface *intf)
 			is_active(intf))
 		goto done;
 
-	if (intf-&gt;dev.driver == NULL)
+	/* Can't resume it if it doesn't have a driver. */
+	if (intf-&gt;dev.driver == NULL) {
+		status = -ENOTCONN;
 		goto done;
+	}
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (driver-&gt;resume) {</pre><hr><pre>commit 114b368c07964caa3f4e1fa575b16e87fa11936c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:13:04 2006 -0400

    usbcore: fix up device and power state tests
    
    This patch (as734) rationalizes the various tests of device state and
    power states.  There are duplications and mistaken tests in several
    places.
    
    Perhaps the most interesting challenge is where the hub driver tests to
    see that all the child devices are suspended before allowing itself to
    be suspended.  When CONFIG_USB_SUSPEND is set the test is
    straightforward, since we expect that the children _will_ be suspended.
    But when CONFIG_USB_SUSPEND isn't set, it's not so clear what should be
    done.  The code compromises by checking the child's
    power.power_state.event field.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 92ecc4eb1e88..affbfb53eb5e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -757,11 +757,13 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 	struct usb_device_driver	*udriver;
 	int				status = 0;
 
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			udev-&gt;state == USB_STATE_SUSPENDED)
+		goto done;
+
 	if (udev-&gt;dev.driver == NULL)
 		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
-	if (udev-&gt;dev.power.power_state.event == msg.event)
-		goto done;
 	status = udriver-&gt;suspend(udev, msg);
 
 done:
@@ -776,14 +778,13 @@ static int resume_device(struct usb_device *udev)
 	struct usb_device_driver	*udriver;
 	int				status = 0;
 
-	if (udev-&gt;dev.power.power_state.event == PM_EVENT_ON)
+	if (udev-&gt;state == USB_STATE_NOTATTACHED ||
+			udev-&gt;state != USB_STATE_SUSPENDED)
 		goto done;
 
 	if (udev-&gt;dev.driver == NULL)
 		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		goto done;
 	status = udriver-&gt;resume(udev);
 
 done:
@@ -798,14 +799,14 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 	struct usb_driver	*driver;
 	int			status = 0;
 
-	if (intf-&gt;dev.driver == NULL)
+	/* with no hardware, USB interfaces only use FREEZE and ON states */
+	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_NOTATTACHED ||
+			!is_active(intf))
 		goto done;
 
-	driver = to_usb_driver(intf-&gt;dev.driver);
-
-	/* with no hardware, USB interfaces only use FREEZE and ON states */
-	if (!is_active(intf))
+	if (intf-&gt;dev.driver == NULL)
 		goto done;
+	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
 		status = driver-&gt;suspend(intf, msg);
@@ -831,25 +832,16 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
-	struct usb_device	*udev;
 	int			status = 0;
 
-	if (intf-&gt;dev.power.power_state.event == PM_EVENT_ON)
+	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_NOTATTACHED ||
+			is_active(intf))
 		goto done;
 
 	if (intf-&gt;dev.driver == NULL)
 		goto done;
-
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
-	udev = interface_to_usbdev(intf);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		goto done;
-
-	/* if driver was suspended, it has a resume method;
-	 * however, sysfs can wrongly mark things as suspended
-	 * (on the "no suspend method" FIXME path above)
-	 */
 	if (driver-&gt;resume) {
 		status = driver-&gt;resume(intf);
 		if (status)
@@ -904,6 +896,12 @@ int usb_resume_both(struct usb_device *udev)
 	int			i;
 	struct usb_interface	*intf;
 
+	/* Can't resume if the parent is suspended */
+	if (udev-&gt;parent &amp;&amp; udev-&gt;parent-&gt;state == USB_STATE_SUSPENDED) {
+		dev_warn(&amp;udev-&gt;dev, "can't resume; parent is suspended\n");
+		return -EHOSTUNREACH;
+	}
+
 	status = resume_device(udev);
 	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
 		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index b6dacd7551d2..5358e656477c 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -195,9 +195,6 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 
 static int generic_resume(struct usb_device *udev)
 {
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
-
 	return usb_port_resume(udev);
 }
 
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 7af53db4d76f..a310c7cede99 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1556,26 +1556,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	if (port1 &lt; 0)
 		return port1;
 
-	if (udev-&gt;state == USB_STATE_SUSPENDED
-			|| udev-&gt;state == USB_STATE_NOTATTACHED) {
-		return 0;
-	}
-
-	/* all interfaces must already be suspended */
-	if (udev-&gt;actconfig) {
-		int	i;
-
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-			struct usb_interface	*intf;
-
-			intf = udev-&gt;actconfig-&gt;interface[i];
-			if (is_active(intf)) {
-				dev_dbg(&amp;intf-&gt;dev, "nyet suspended\n");
-				return -EBUSY;
-			}
-		}
-	}
-
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
@@ -1614,8 +1594,6 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 int usb_port_suspend(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return -ENODEV;
 	return __usb_port_suspend(udev, udev-&gt;portnum);
 #else
 	return 0;
@@ -1761,24 +1739,17 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  */
 int usb_port_resume(struct usb_device *udev)
 {
-	int	status;
-
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return -ENODEV;
+	int	status = 0;
 
 	/* we change the device's upstream USB link,
 	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent) {
 #ifdef	CONFIG_USB_SUSPEND
-		if (udev-&gt;state == USB_STATE_SUSPENDED) {
-			// NOTE swsusp may bork us, device state being wrong...
-			// NOTE this fails if parent is also suspended...
-			status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
-					udev-&gt;portnum, udev);
-		} else
+		// NOTE this fails if parent is also suspended...
+		status = hub_port_resume(hdev_to_hub(udev-&gt;parent),
+				udev-&gt;portnum, udev);
 #endif
-			status = 0;
 	} else
 		status = finish_port_resume(udev);
 	if (status &lt; 0)
@@ -1821,12 +1792,14 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 		struct usb_device	*udev;
 
 		udev = hdev-&gt;children [port1-1];
-		if (udev &amp;&amp; (udev-&gt;dev.power.power_state.event
-					== PM_EVENT_ON
+		if (udev &amp;&amp; msg.event == PM_EVENT_SUSPEND &amp;&amp;
 #ifdef	CONFIG_USB_SUSPEND
-				|| udev-&gt;state != USB_STATE_SUSPENDED
+				udev-&gt;state != USB_STATE_SUSPENDED
+#else
+				udev-&gt;dev.power.power_state.event
+					== PM_EVENT_ON
 #endif
-				)) {
+				) {
 			dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n", port1);
 			return -EBUSY;
 		}</pre><hr><pre>commit 2bf4086d7a7722b470aa24e1be725cc58619c6fe
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:12:19 2006 -0400

    usbcore: set device and power states properly
    
    This patch (as733) fixes up the places where device states and power
    states are set in usbcore.  Right now things are duplicated or missing;
    this should straighten things out.
    
    The idea is that udev-&gt;state is USB_STATE_SUSPENDED exactly when the
    device's upstream port has been suspended, whereas
    udev-&gt;dev.power.power_state.event reflects the result of the last call
    to the suspend/resume routines (which might not actually change the
    device state, especially if CONFIG_USB_SUSPEND isn't set).
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index eefc98584eac..92ecc4eb1e88 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -755,48 +755,57 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
+	int				status = 0;
 
 	if (udev-&gt;dev.driver == NULL)
-		return 0;
+		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	if (udev-&gt;dev.power.power_state.event == msg.event)
-		return 0;
-	return udriver-&gt;suspend(udev, msg);
+		goto done;
+	status = udriver-&gt;suspend(udev, msg);
+
+done:
+	if (status == 0)
+		udev-&gt;dev.power.power_state.event = msg.event;
+	return status;
 }
 
 /* Caller has locked udev */
 static int resume_device(struct usb_device *udev)
 {
 	struct usb_device_driver	*udriver;
+	int				status = 0;
 
 	if (udev-&gt;dev.power.power_state.event == PM_EVENT_ON)
-		return 0;
-
-	/* mark things as "on" immediately, no matter what errors crop up */
-	udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+		goto done;
 
 	if (udev-&gt;dev.driver == NULL)
-		return 0;
+		goto done;
 	udriver = to_usb_device_driver(udev-&gt;dev.driver);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
-	return udriver-&gt;resume(udev);
+		goto done;
+	status = udriver-&gt;resume(udev);
+
+done:
+	if (status == 0)
+		udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+	return status;
 }
 
 /* Caller has locked intf's usb_device */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
-	int			status;
+	int			status = 0;
 
 	if (intf-&gt;dev.driver == NULL)
-		return 0;
+		goto done;
 
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	/* with no hardware, USB interfaces only use FREEZE and ON states */
 	if (!is_active(intf))
-		return 0;
+		goto done;
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
 		status = driver-&gt;suspend(intf, msg);
@@ -810,8 +819,11 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 		dev_warn(&amp;intf-&gt;dev, "no suspend for driver %s?\n",
 				driver-&gt;name);
 		mark_quiesced(intf);
-		status = 0;
 	}
+
+done:
+	if (status == 0)
+		intf-&gt;dev.power.power_state.event = msg.event;
 	return status;
 }
 
@@ -820,24 +832,19 @@ static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
 	struct usb_device	*udev;
-	int			status;
+	int			status = 0;
 
 	if (intf-&gt;dev.power.power_state.event == PM_EVENT_ON)
-		return 0;
-
-	/* mark things as "on" immediately, no matter what errors crop up */
-	intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
+		goto done;
 
-	if (intf-&gt;dev.driver == NULL) {
-		intf-&gt;dev.power.power_state.event = PM_EVENT_FREEZE;
-		return 0;
-	}
+	if (intf-&gt;dev.driver == NULL)
+		goto done;
 
 	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	udev = interface_to_usbdev(intf);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
+		goto done;
 
 	/* if driver was suspended, it has a resume method;
 	 * however, sysfs can wrongly mark things as suspended
@@ -845,15 +852,21 @@ static int resume_interface(struct usb_interface *intf)
 	 */
 	if (driver-&gt;resume) {
 		status = driver-&gt;resume(intf);
-		if (status) {
+		if (status)
 			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
 					"resume", status);
-			mark_quiesced(intf);
-		}
-	} else
+		else
+			mark_active(intf);
+	} else {
 		dev_warn(&amp;intf-&gt;dev, "no resume for driver %s?\n",
 				driver-&gt;name);
-	return 0;
+		mark_active(intf);
+	}
+
+done:
+	if (status == 0)
+		intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
+	return status;
 }
 
 /* Caller has locked udev */
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a39112041e69..7af53db4d76f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1582,9 +1582,10 @@ static int __usb_port_suspend (struct usb_device *udev, int port1)
 	if (udev-&gt;parent)
 		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
 				udev);
-
-	if (status == 0)
-		udev-&gt;dev.power.power_state = PMSG_SUSPEND;
+	else {
+		dev_dbg(&amp;udev-&gt;dev, "usb suspend\n");
+		usb_set_device_state(udev, USB_STATE_SUSPENDED);
+	}
 	return status;
 }
 
@@ -1617,8 +1618,6 @@ int usb_port_suspend(struct usb_device *udev)
 		return -ENODEV;
 	return __usb_port_suspend(udev, udev-&gt;portnum);
 #else
-	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
-	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
 	return 0;
 #endif
 }
@@ -1647,7 +1646,6 @@ static int finish_port_resume(struct usb_device *udev)
 	usb_set_device_state(udev, udev-&gt;actconfig
 			? USB_STATE_CONFIGURED
 			: USB_STATE_ADDRESS);
-	udev-&gt;dev.power.power_state = PMSG_ON;
 
  	/* 10.5.4.5 says be sure devices in the tree are still there.
  	 * For now let's assume the device didn't go crazy on resume,</pre><hr><pre>commit 4d064c080265a41324d108fccc26b72106d43db3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:11:44 2006 -0400

    usbcore: track whether interfaces are suspended
    
    Currently we rely on intf-&gt;dev.power.power_state.event for tracking
    whether intf is suspended.  This is not a reliable technique because
    that value is owned by the PM core, not by usbcore.  This patch (as718b)
    adds a new flag so that we can accurately tell which interfaces are
    suspended and which aren't.
    
    At first one might think these flags aren't needed, since interfaces
    will be suspended along with their devices.  It turns out there are a
    couple of intermediate situations where that's not quite true, such as
    while processing a remote-wakeup request.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index cc42972b6bb0..74df0db954c9 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -59,17 +59,17 @@ static inline int is_usb_device_driver(struct device_driver *drv)
 
 static inline void mark_active(struct usb_interface *f)
 {
-	f-&gt;dev.power.power_state.event = PM_EVENT_ON;
+	f-&gt;is_active = 1;
 }
 
 static inline void mark_quiesced(struct usb_interface *f)
 {
-	f-&gt;dev.power.power_state.event = PM_EVENT_FREEZE;
+	f-&gt;is_active = 0;
 }
 
 static inline int is_active(struct usb_interface *f)
 {
-	return f-&gt;dev.power.power_state.event == PM_EVENT_ON;
+	return f-&gt;is_active;
 }
 
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index b4ccce6d0982..e22f4b386605 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -102,6 +102,7 @@ enum usb_interface_condition {
  *	number from the USB core by calling usb_register_dev().
  * @condition: binding state of the interface: not bound, binding
  *	(in probe()), bound to a driver, or unbinding (in disconnect())
+ * @is_active: flag set when the interface is bound and not suspended.
  * @dev: driver model's view of this device
  * @class_dev: driver model's class view of this device.
  *
@@ -142,6 +143,8 @@ struct usb_interface {
 	int minor;			/* minor number this interface is
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
+	unsigned is_active:1;		/* the interface is not suspended */
+
 	struct device dev;		/* interface specific device info */
 	struct class_device *class_dev;
 };</pre><hr><pre>commit a8e7c5653562f88c0f5f53eac0a890c012655789
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:11:02 2006 -0400

    usbcore: resume device resume recursion
    
    This patch (as717b) removes the existing recursion in hub resume code:
    Resuming a hub will no longer automatically resume the devices attached
    to the hub.
    
    At the same time, it adds one level of recursion: Suspending a USB
    device will automatically suspend all the device's interfaces.  Failure
    at an intermediate stage will cause all the already-suspended interfaces
    to be resumed. Attempts to suspend or resume an interface by itself will
    do nothing, although they won't return an error.  Thus the regular
    system-suspend and system-resume procedures should continue to work as
    before; only runtime PM will be affected.
    
    The patch also removes the code that tests state of the interfaces
    before suspending a device.  It's no longer needed, since everything
    gets suspended together.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index b0db1583c522..eefc98584eac 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -783,7 +783,7 @@ static int resume_device(struct usb_device *udev)
 	return udriver-&gt;resume(udev);
 }
 
-/* Caller has locked intf */
+/* Caller has locked intf's usb_device */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
@@ -815,7 +815,7 @@ static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 	return status;
 }
 
-/* Caller has locked intf */
+/* Caller has locked intf's usb_device */
 static int resume_interface(struct usb_interface *intf)
 {
 	struct usb_driver	*driver;
@@ -856,14 +856,59 @@ static int resume_interface(struct usb_interface *intf)
 	return 0;
 }
 
+/* Caller has locked udev */
+int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
+{
+	int			status = 0;
+	int			i = 0;
+	struct usb_interface	*intf;
+
+	if (udev-&gt;actconfig) {
+		for (; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			status = suspend_interface(intf, msg);
+			if (status != 0)
+				break;
+		}
+	}
+	if (status == 0)
+		status = suspend_device(udev, msg);
+
+	/* If the suspend failed, resume interfaces that did get suspended */
+	if (status != 0) {
+		while (--i &gt;= 0) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			resume_interface(intf);
+		}
+	}
+	return status;
+}
+
+/* Caller has locked udev */
+int usb_resume_both(struct usb_device *udev)
+{
+	int			status;
+	int			i;
+	struct usb_interface	*intf;
+
+	status = resume_device(udev);
+	if (status == 0 &amp;&amp; udev-&gt;actconfig) {
+		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
+			intf = udev-&gt;actconfig-&gt;interface[i];
+			resume_interface(intf);
+		}
+	}
+	return status;
+}
+
 static int usb_suspend(struct device *dev, pm_message_t message)
 {
 	int	status;
 
 	if (is_usb_device(dev))
-		status = suspend_device(to_usb_device(dev), message);
+		status = usb_suspend_both(to_usb_device(dev), message);
 	else
-		status = suspend_interface(to_usb_interface(dev), message);
+		status = 0;
 	return status;
 }
 
@@ -871,10 +916,12 @@ static int usb_resume(struct device *dev)
 {
 	int	status;
 
-	if (is_usb_device(dev))
-		status = resume_device(to_usb_device(dev));
-	else
-		status = resume_interface(to_usb_interface(dev));
+	if (is_usb_device(dev)) {
+		status = usb_resume_both(to_usb_device(dev));
+
+		/* Rebind drivers that had no suspend method? */
+	} else
+		status = 0;
 	return status;
 }
 
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 1522195de715..b6dacd7551d2 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -184,22 +184,8 @@ static void generic_disconnect(struct usb_device *udev)
 
 #ifdef	CONFIG_PM
 
-static int verify_suspended(struct device *dev, void *unused)
-{
-	if (dev-&gt;driver == NULL)
-		return 0;
-	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
-}
-
 static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 {
-	int	status;
-
-	/* rule out bogus requests through sysfs */
-	status = device_for_each_child(&amp;udev-&gt;dev, NULL, verify_suspended);
-	if (status)
-		return status;
-
 	/* USB devices enter SUSPEND state through their hubs, but can be
 	 * marked for FREEZE as soon as their children are already idled.
 	 * But those semantics are useless, so we equate the two (sigh).
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index a372332440b2..a39112041e69 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1662,9 +1662,6 @@ static int finish_port_resume(struct usb_device *udev)
 			"gone after usb resume? status %d\n",
 			status);
 	else if (udev-&gt;actconfig) {
-		unsigned	i;
-		int		(*resume)(struct device *);
-
 		le16_to_cpus(&amp;devstatus);
 		if ((devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
 				&amp;&amp; udev-&gt;parent) {
@@ -1675,24 +1672,9 @@ static int finish_port_resume(struct usb_device *udev)
 					USB_DEVICE_REMOTE_WAKEUP, 0,
 					NULL, 0,
 					USB_CTRL_SET_TIMEOUT);
-			if (status) {
+			if (status)
 				dev_dbg(&amp;udev-&gt;dev, "disable remote "
 					"wakeup, status %d\n", status);
-				status = 0;
-			}
-		}
-
-		/* resume interface drivers; if this is a hub, it
-		 * may have a child resume event to deal with soon
-		 */
-		resume = udev-&gt;dev.bus-&gt;resume;
-		for (i = 0; i &lt; udev-&gt;actconfig-&gt;desc.bNumInterfaces; i++) {
-			struct device *dev =
-					&amp;udev-&gt;actconfig-&gt;interface[i]-&gt;dev;
-
-			down(&amp;dev-&gt;sem);
-			(void) resume(dev);
-			up(&amp;dev-&gt;sem);
 		}
 		status = 0;
 
@@ -1802,15 +1784,7 @@ int usb_port_resume(struct usb_device *udev)
 	} else
 		status = finish_port_resume(udev);
 	if (status &lt; 0)
-		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n",
-			status);
-
-	/* rebind drivers that had no suspend() */
-	if (status == 0) {
-		usb_unlock_device(udev);
-		bus_rescan_devices(&amp;usb_bus_type);
-		usb_lock_device(udev);
-	}
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
 	return status;
 }
 
@@ -1830,6 +1804,9 @@ static int remote_wakeup(struct usb_device *udev)
 		msleep(10);
 		status = finish_port_resume(udev);
 	}
+
+	if (status == 0)
+		usb_resume_both(udev);
 	usb_unlock_device(udev);
 #endif
 	return status;
@@ -1901,51 +1878,8 @@ static int hub_resume(struct usb_interface *intf)
 		}
 	}
 
+	/* tell khubd to look for changes on this hub */
 	hub_activate(hub);
-
-	/* REVISIT:  this recursion probably shouldn't exist.  Remove
-	 * this code sometime, after retesting with different root and
-	 * external hubs.
-	 */
-#ifdef	CONFIG_USB_SUSPEND
-	{
-	unsigned		port1;
-
-	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; port1++) {
-		struct usb_device	*udev;
-		u16			portstat, portchange;
-
-		udev = hdev-&gt;children [port1-1];
-		status = hub_port_status(hub, port1, &amp;portstat, &amp;portchange);
-		if (status == 0) {
-			if (portchange &amp; USB_PORT_STAT_C_SUSPEND) {
-				clear_port_feature(hdev, port1,
-					USB_PORT_FEAT_C_SUSPEND);
-				portchange &amp;= ~USB_PORT_STAT_C_SUSPEND;
-			}
-
-			/* let khubd handle disconnects etc */
-			if (portchange)
-				continue;
-		}
-
-		if (!udev || status &lt; 0)
-			continue;
-		usb_lock_device(udev);
-		if (portstat &amp; USB_PORT_STAT_SUSPEND)
-			status = hub_port_resume(hub, port1, udev);
-		else {
-			status = finish_port_resume(udev);
-			if (status &lt; 0) {
-				dev_dbg(&amp;intf-&gt;dev, "resume port %d --&gt; %d\n",
-					port1, status);
-				hub_port_logical_disconnect(hub, port1);
-			}
-		}
-		usb_unlock_device(udev);
-	}
-	}
-#endif
 	return 0;
 }
 
@@ -2602,17 +2536,6 @@ static void hub_events(void)
 		usb_get_intf(intf);
 		spin_unlock_irq(&amp;hub_event_lock);
 
-		/* Is this is a root hub wanting to reactivate the downstream
-		 * ports?  If so, be sure the interface resumes even if its
-		 * stub "device" node was never suspended.
-		 */
-		if (i) {
-			dpm_runtime_resume(&amp;hdev-&gt;dev);
-			dpm_runtime_resume(&amp;intf-&gt;dev);
-			usb_put_intf(intf);
-			continue;
-		}
-
 		/* Lock the device, then check to see if we were
 		 * disconnected while waiting for the lock to succeed. */
 		if (locktree(hdev) &lt; 0) {
@@ -2629,6 +2552,13 @@ static void hub_events(void)
 			goto loop;
 		}
 
+		/* Is this is a root hub wanting to reactivate the downstream
+		 * ports?  If so, be sure the interface resumes even if its
+		 * stub "device" node was never suspended.
+		 */
+		if (i)
+			usb_resume_both(hdev);
+
 		/* If this is an inactive or suspended hub, do nothing */
 		if (hub-&gt;quiescing)
 			goto loop;
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1d25ccac7832..cc42972b6bb0 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,6 +30,8 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
+extern int usb_suspend_both(struct usb_device *udev, pm_message_t msg);
+extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 </pre><hr><pre>commit 1cc8a25d5b680ff656927ffa9b66fae6b415b1d3
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:10:15 2006 -0400

    usbcore: split suspend/resume for device and interfaces
    
    This patch (as716b) splits up the core suspend and resume routines into
    two parts each: one for handling devices and one for handling
    interfaces.  The behavior of the parts should be the same as in the old
    unified code.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index a62de0a85406..b0db1583c522 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -751,81 +751,89 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-static int usb_suspend(struct device *dev, pm_message_t message)
+/* Caller has locked udev */
+static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
-	struct usb_device		*udev;
 	struct usb_device_driver	*udriver;
-	struct usb_interface		*intf;
-	struct usb_driver		*driver;
-	int				status;
 
-	if (is_usb_device(dev)) {
-		if (dev-&gt;driver == NULL)
-			return 0;
-		udev = to_usb_device(dev);
-		udriver = to_usb_device_driver(dev-&gt;driver);
-		if (dev-&gt;power.power_state.event == message.event)
-			return 0;
-		return udriver-&gt;suspend(udev, message);
-	}
+	if (udev-&gt;dev.driver == NULL)
+		return 0;
+	udriver = to_usb_device_driver(udev-&gt;dev.driver);
+	if (udev-&gt;dev.power.power_state.event == msg.event)
+		return 0;
+	return udriver-&gt;suspend(udev, msg);
+}
+
+/* Caller has locked udev */
+static int resume_device(struct usb_device *udev)
+{
+	struct usb_device_driver	*udriver;
 
-	if (dev-&gt;driver == NULL)
+	if (udev-&gt;dev.power.power_state.event == PM_EVENT_ON)
 		return 0;
 
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
+	/* mark things as "on" immediately, no matter what errors crop up */
+	udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
+
+	if (udev-&gt;dev.driver == NULL)
+		return 0;
+	udriver = to_usb_device_driver(udev-&gt;dev.driver);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+	return udriver-&gt;resume(udev);
+}
+
+/* Caller has locked intf */
+static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
+{
+	struct usb_driver	*driver;
+	int			status;
+
+	if (intf-&gt;dev.driver == NULL)
+		return 0;
+
+	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	/* with no hardware, USB interfaces only use FREEZE and ON states */
 	if (!is_active(intf))
 		return 0;
 
 	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
-		status = driver-&gt;suspend(intf, message);
+		status = driver-&gt;suspend(intf, msg);
 		if (status)
-			dev_err(dev, "%s error %d\n", "suspend", status);
+			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+					"suspend", status);
 		else
 			mark_quiesced(intf);
 	} else {
 		// FIXME else if there's no suspend method, disconnect...
-		dev_warn(dev, "no suspend for driver %s?\n", driver-&gt;name);
+		dev_warn(&amp;intf-&gt;dev, "no suspend for driver %s?\n",
+				driver-&gt;name);
 		mark_quiesced(intf);
 		status = 0;
 	}
 	return status;
 }
 
-static int usb_resume(struct device *dev)
+/* Caller has locked intf */
+static int resume_interface(struct usb_interface *intf)
 {
-	struct usb_device		*udev;
-	struct usb_device_driver	*udriver;
-	struct usb_interface		*intf;
-	struct usb_driver		*driver;
-	int				status;
+	struct usb_driver	*driver;
+	struct usb_device	*udev;
+	int			status;
 
-	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
+	if (intf-&gt;dev.power.power_state.event == PM_EVENT_ON)
 		return 0;
 
 	/* mark things as "on" immediately, no matter what errors crop up */
-	dev-&gt;power.power_state.event = PM_EVENT_ON;
+	intf-&gt;dev.power.power_state.event = PM_EVENT_ON;
 
-	/* devices resume through their hubs */
-	if (is_usb_device(dev)) {
-		if (dev-&gt;driver == NULL)
-			return 0;
-		udev = to_usb_device(dev);
-		udriver = to_usb_device_driver(dev-&gt;driver);
-		if (udev-&gt;state == USB_STATE_NOTATTACHED)
-			return 0;
-		return udriver-&gt;resume(udev);
-	}
-
-	if (dev-&gt;driver == NULL) {
-		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
+	if (intf-&gt;dev.driver == NULL) {
+		intf-&gt;dev.power.power_state.event = PM_EVENT_FREEZE;
 		return 0;
 	}
 
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
+	driver = to_usb_driver(intf-&gt;dev.driver);
 
 	udev = interface_to_usbdev(intf);
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
@@ -838,14 +846,38 @@ static int usb_resume(struct device *dev)
 	if (driver-&gt;resume) {
 		status = driver-&gt;resume(intf);
 		if (status) {
-			dev_err(dev, "%s error %d\n", "resume", status);
+			dev_err(&amp;intf-&gt;dev, "%s error %d\n",
+					"resume", status);
 			mark_quiesced(intf);
 		}
 	} else
-		dev_warn(dev, "no resume for driver %s?\n", driver-&gt;name);
+		dev_warn(&amp;intf-&gt;dev, "no resume for driver %s?\n",
+				driver-&gt;name);
 	return 0;
 }
 
+static int usb_suspend(struct device *dev, pm_message_t message)
+{
+	int	status;
+
+	if (is_usb_device(dev))
+		status = suspend_device(to_usb_device(dev), message);
+	else
+		status = suspend_interface(to_usb_interface(dev), message);
+	return status;
+}
+
+static int usb_resume(struct device *dev)
+{
+	int	status;
+
+	if (is_usb_device(dev))
+		status = resume_device(to_usb_device(dev));
+	else
+		status = resume_interface(to_usb_interface(dev));
+	return status;
+}
+
 #endif /* CONFIG_PM */
 
 struct bus_type usb_bus_type = {</pre><hr><pre>commit 782da727b0d59e93c84a627948b1535a3db90392
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:09:35 2006 -0400

    usbcore: make usb_generic a usb_device_driver
    
    This patch (as714b) makes usb_generic into a usb_device_driver capable
    of being probed and unbound, just like other drivers.  A fair amount of
    the work that used to get done during discovery or removal of a USB
    device have been moved to the probe and disconnect methods of
    usb_generic: creating the sysfs attributes and selecting an initial
    configuration.  However the normal behavior should continue to be the
    same as before.
    
    We will now have the possibility of creating other USB device drivers,
    They will assist with exporting devices to remote systems
    (USB-over-TCPIP) or to paravirtual guest operating systems.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 0d4b5dcee3ab..a62de0a85406 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -530,9 +530,10 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 	/* driver is often null here; dev_dbg() would oops */
 	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
 
-	if (is_usb_device(dev))
-		return 0;
-	else {
+	if (is_usb_device(dev)) {
+		usb_dev = to_usb_device(dev);
+		alt = NULL;
+	} else {
 		intf = to_usb_interface(dev);
 		usb_dev = interface_to_usbdev(intf);
 		alt = intf-&gt;cur_altsetting;
@@ -579,15 +580,17 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 			   usb_dev-&gt;descriptor.bDeviceProtocol))
 		return -ENOMEM;
 
-	if (add_uevent_var(envp, num_envp, &amp;i,
+	if (!is_usb_device(dev)) {
+
+		if (add_uevent_var(envp, num_envp, &amp;i,
 			   buffer, buffer_size, &amp;length,
 			   "INTERFACE=%d/%d/%d",
 			   alt-&gt;desc.bInterfaceClass,
 			   alt-&gt;desc.bInterfaceSubClass,
 			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
+			return -ENOMEM;
 
-	if (add_uevent_var(envp, num_envp, &amp;i,
+		if (add_uevent_var(envp, num_envp, &amp;i,
 			   buffer, buffer_size, &amp;length,
 			   "MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
 			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
@@ -599,7 +602,8 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 			   alt-&gt;desc.bInterfaceClass,
 			   alt-&gt;desc.bInterfaceSubClass,
 			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
+			return -ENOMEM;
+	}
 
 	envp[i] = NULL;
 
@@ -747,31 +751,22 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-static int verify_suspended(struct device *dev, void *unused)
+static int usb_suspend(struct device *dev, pm_message_t message)
 {
-	if (dev-&gt;driver == NULL)
-		return 0;
-	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
-}
+	struct usb_device		*udev;
+	struct usb_device_driver	*udriver;
+	struct usb_interface		*intf;
+	struct usb_driver		*driver;
+	int				status;
 
-static int usb_generic_suspend(struct device *dev, pm_message_t message)
-{
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	int			status;
-
-	/* USB devices enter SUSPEND state through their hubs, but can be
-	 * marked for FREEZE as soon as their children are already idled.
-	 * But those semantics are useless, so we equate the two (sigh).
-	 */
 	if (is_usb_device(dev)) {
+		if (dev-&gt;driver == NULL)
+			return 0;
+		udev = to_usb_device(dev);
+		udriver = to_usb_device_driver(dev-&gt;driver);
 		if (dev-&gt;power.power_state.event == message.event)
 			return 0;
-		/* we need to rule out bogus requests through sysfs */
-		status = device_for_each_child(dev, NULL, verify_suspended);
-		if (status)
-			return status;
- 		return usb_port_suspend(to_usb_device(dev));
+		return udriver-&gt;suspend(udev, message);
 	}
 
 	if (dev-&gt;driver == NULL)
@@ -799,12 +794,13 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
 	return status;
 }
 
-static int usb_generic_resume(struct device *dev)
+static int usb_resume(struct device *dev)
 {
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	struct usb_device	*udev;
-	int			status;
+	struct usb_device		*udev;
+	struct usb_device_driver	*udriver;
+	struct usb_interface		*intf;
+	struct usb_driver		*driver;
+	int				status;
 
 	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
 		return 0;
@@ -814,10 +810,13 @@ static int usb_generic_resume(struct device *dev)
 
 	/* devices resume through their hubs */
 	if (is_usb_device(dev)) {
+		if (dev-&gt;driver == NULL)
+			return 0;
 		udev = to_usb_device(dev);
+		udriver = to_usb_device_driver(dev-&gt;driver);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return 0;
-		return usb_port_resume(udev);
+		return udriver-&gt;resume(udev);
 	}
 
 	if (dev-&gt;driver == NULL) {
@@ -854,7 +853,7 @@ struct bus_type usb_bus_type = {
 	.match =	usb_device_match,
 	.uevent =	usb_uevent,
 #ifdef CONFIG_PM
-	.suspend =	usb_generic_suspend,
-	.resume =	usb_generic_resume,
+	.suspend =	usb_suspend,
+	.resume =	usb_resume,
 #endif
 };
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index fa6f34a12b4b..1522195de715 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -21,24 +21,208 @@
 #include &lt;linux/usb.h&gt;
 #include "usb.h"
 
+static inline const char *plural(int n)
+{
+	return (n == 1 ? "" : "s");
+}
+
+static int choose_configuration(struct usb_device *udev)
+{
+	int i;
+	int num_configs;
+	int insufficient_power = 0;
+	struct usb_host_config *c, *best;
+
+	best = NULL;
+	c = udev-&gt;config;
+	num_configs = udev-&gt;descriptor.bNumConfigurations;
+	for (i = 0; i &lt; num_configs; (i++, c++)) {
+		struct usb_interface_descriptor	*desc = NULL;
+
+		/* It's possible that a config has no interfaces! */
+		if (c-&gt;desc.bNumInterfaces &gt; 0)
+			desc = &amp;c-&gt;intf_cache[0]-&gt;altsetting-&gt;desc;
+
+		/*
+		 * HP's USB bus-powered keyboard has only one configuration
+		 * and it claims to be self-powered; other devices may have
+		 * similar errors in their descriptors.  If the next test
+		 * were allowed to execute, such configurations would always
+		 * be rejected and the devices would not work as expected.
+		 * In the meantime, we run the risk of selecting a config
+		 * that requires external power at a time when that power
+		 * isn't available.  It seems to be the lesser of two evils.
+		 *
+		 * Bugzilla #6448 reports a device that appears to crash
+		 * when it receives a GET_DEVICE_STATUS request!  We don't
+		 * have any other way to tell whether a device is self-powered,
+		 * but since we don't use that information anywhere but here,
+		 * the call has been removed.
+		 *
+		 * Maybe the GET_DEVICE_STATUS call and the test below can
+		 * be reinstated when device firmwares become more reliable.
+		 * Don't hold your breath.
+		 */
+#if 0
+		/* Rule out self-powered configs for a bus-powered device */
+		if (bus_powered &amp;&amp; (c-&gt;desc.bmAttributes &amp;
+					USB_CONFIG_ATT_SELFPOWER))
+			continue;
+#endif
+
+		/*
+		 * The next test may not be as effective as it should be.
+		 * Some hubs have errors in their descriptor, claiming
+		 * to be self-powered when they are really bus-powered.
+		 * We will overestimate the amount of current such hubs
+		 * make available for each port.
+		 *
+		 * This is a fairly benign sort of failure.  It won't
+		 * cause us to reject configurations that we should have
+		 * accepted.
+		 */
+
+		/* Rule out configs that draw too much bus current */
+		if (c-&gt;desc.bMaxPower * 2 &gt; udev-&gt;bus_mA) {
+			insufficient_power++;
+			continue;
+		}
+
+		/* If the first config's first interface is COMM/2/0xff
+		 * (MSFT RNDIS), rule it out unless Linux has host-side
+		 * RNDIS support. */
+		if (i == 0 &amp;&amp; desc
+				&amp;&amp; desc-&gt;bInterfaceClass == USB_CLASS_COMM
+				&amp;&amp; desc-&gt;bInterfaceSubClass == 2
+				&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
+#ifndef CONFIG_USB_NET_RNDIS_HOST
+			continue;
+#else
+			best = c;
+#endif
+		}
+
+		/* From the remaining configs, choose the first one whose
+		 * first interface is for a non-vendor-specific class.
+		 * Reason: Linux is more likely to have a class driver
+		 * than a vendor-specific driver. */
+		else if (udev-&gt;descriptor.bDeviceClass !=
+						USB_CLASS_VENDOR_SPEC &amp;&amp;
+				(!desc || desc-&gt;bInterfaceClass !=
+						USB_CLASS_VENDOR_SPEC)) {
+			best = c;
+			break;
+		}
+
+		/* If all the remaining configs are vendor-specific,
+		 * choose the first one. */
+		else if (!best)
+			best = c;
+	}
+
+	if (insufficient_power &gt; 0)
+		dev_info(&amp;udev-&gt;dev, "rejected %d configuration%s "
+			"due to insufficient available bus power\n",
+			insufficient_power, plural(insufficient_power));
+
+	if (best) {
+		i = best-&gt;desc.bConfigurationValue;
+		dev_info(&amp;udev-&gt;dev,
+			"configuration #%d chosen from %d choice%s\n",
+			i, num_configs, plural(num_configs));
+	} else {
+		i = -1;
+		dev_warn(&amp;udev-&gt;dev,
+			"no configuration chosen from %d choice%s\n",
+			num_configs, plural(num_configs));
+	}
+	return i;
+}
+
 static int generic_probe(struct usb_device *udev)
 {
+	int err, c;
+
+	/* put device-specific files into sysfs */
+	usb_create_sysfs_dev_files(udev);
+
+	/* Choose and set the configuration.  This registers the interfaces
+	 * with the driver core and lets interface drivers bind to them.
+	 */
+	c = choose_configuration(udev);
+	if (c &gt;= 0) {
+		err = usb_set_configuration(udev, c);
+		if (err) {
+			dev_err(&amp;udev-&gt;dev, "can't set config #%d, error %d\n",
+					c, err);
+			/* This need not be fatal.  The user can try to
+			 * set other configurations. */
+		}
+	}
+
+	/* USB device state == configured ... usable */
+	usb_notify_add_device(udev);
+
 	return 0;
 }
+
 static void generic_disconnect(struct usb_device *udev)
 {
+	usb_notify_remove_device(udev);
+
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev-&gt;state == USB_STATE_CONFIGURED)
 		usb_set_configuration(udev, 0);
 
+	usb_remove_sysfs_dev_files(udev);
+
 	/* in case the call failed or the device was suspended */
 	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
 		usb_disable_device(udev, 0);
 }
 
+#ifdef	CONFIG_PM
+
+static int verify_suspended(struct device *dev, void *unused)
+{
+	if (dev-&gt;driver == NULL)
+		return 0;
+	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
+}
+
+static int generic_suspend(struct usb_device *udev, pm_message_t msg)
+{
+	int	status;
+
+	/* rule out bogus requests through sysfs */
+	status = device_for_each_child(&amp;udev-&gt;dev, NULL, verify_suspended);
+	if (status)
+		return status;
+
+	/* USB devices enter SUSPEND state through their hubs, but can be
+	 * marked for FREEZE as soon as their children are already idled.
+	 * But those semantics are useless, so we equate the two (sigh).
+	 */
+	return usb_port_suspend(udev);
+}
+
+static int generic_resume(struct usb_device *udev)
+{
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+
+	return usb_port_resume(udev);
+}
+
+#endif	/* CONFIG_PM */
+
 struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
 	.probe = generic_probe,
 	.disconnect = generic_disconnect,
+#ifdef	CONFIG_PM
+	.suspend = generic_suspend,
+	.resume = generic_resume,
+#endif
 };
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index b00514d9a605..a372332440b2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1148,144 +1148,28 @@ void usb_disconnect(struct usb_device **pdev)
 	 * cleaning up all state associated with the current configuration
 	 * so that the hardware is now fully quiesced.
 	 */
+	dev_dbg (&amp;udev-&gt;dev, "unregistering device\n");
 	usb_disable_device(udev, 0);
 
-	usb_notify_remove_device(udev);
+	usb_unlock_device(udev);
+
+	/* Unregister the device.  The device driver is responsible
+	 * for removing the device files from usbfs and sysfs and for
+	 * de-configuring the device.
+	 */
+	device_del(&amp;udev-&gt;dev);
 
-	/* Free the device number, remove the /proc/bus/usb entry and
-	 * the sysfs attributes, and delete the parent's children[]
+	/* Free the device number and delete the parent's children[]
 	 * (or root_hub) pointer.
 	 */
-	dev_dbg (&amp;udev-&gt;dev, "unregistering device\n");
 	release_address(udev);
-	usb_remove_sysfs_dev_files(udev);
 
 	/* Avoid races with recursively_mark_NOTATTACHED() */
 	spin_lock_irq(&amp;device_state_lock);
 	*pdev = NULL;
 	spin_unlock_irq(&amp;device_state_lock);
 
-	usb_unlock_device(udev);
-
-	device_unregister(&amp;udev-&gt;dev);
-}
-
-static inline const char *plural(int n)
-{
-	return (n == 1 ? "" : "s");
-}
-
-static int choose_configuration(struct usb_device *udev)
-{
-	int i;
-	int num_configs;
-	int insufficient_power = 0;
-	struct usb_host_config *c, *best;
-
-	best = NULL;
-	c = udev-&gt;config;
-	num_configs = udev-&gt;descriptor.bNumConfigurations;
-	for (i = 0; i &lt; num_configs; (i++, c++)) {
-		struct usb_interface_descriptor	*desc = NULL;
-
-		/* It's possible that a config has no interfaces! */
-		if (c-&gt;desc.bNumInterfaces &gt; 0)
-			desc = &amp;c-&gt;intf_cache[0]-&gt;altsetting-&gt;desc;
-
-		/*
-		 * HP's USB bus-powered keyboard has only one configuration
-		 * and it claims to be self-powered; other devices may have
-		 * similar errors in their descriptors.  If the next test
-		 * were allowed to execute, such configurations would always
-		 * be rejected and the devices would not work as expected.
-		 * In the meantime, we run the risk of selecting a config
-		 * that requires external power at a time when that power
-		 * isn't available.  It seems to be the lesser of two evils.
-		 *
-		 * Bugzilla #6448 reports a device that appears to crash
-		 * when it receives a GET_DEVICE_STATUS request!  We don't
-		 * have any other way to tell whether a device is self-powered,
-		 * but since we don't use that information anywhere but here,
-		 * the call has been removed.
-		 *
-		 * Maybe the GET_DEVICE_STATUS call and the test below can
-		 * be reinstated when device firmwares become more reliable.
-		 * Don't hold your breath.
-		 */
-#if 0
-		/* Rule out self-powered configs for a bus-powered device */
-		if (bus_powered &amp;&amp; (c-&gt;desc.bmAttributes &amp;
-					USB_CONFIG_ATT_SELFPOWER))
-			continue;
-#endif
-
-		/*
-		 * The next test may not be as effective as it should be.
-		 * Some hubs have errors in their descriptor, claiming
-		 * to be self-powered when they are really bus-powered.
-		 * We will overestimate the amount of current such hubs
-		 * make available for each port.
-		 *
-		 * This is a fairly benign sort of failure.  It won't
-		 * cause us to reject configurations that we should have
-		 * accepted.
-		 */
-
-		/* Rule out configs that draw too much bus current */
-		if (c-&gt;desc.bMaxPower * 2 &gt; udev-&gt;bus_mA) {
-			insufficient_power++;
-			continue;
-		}
-
-		/* If the first config's first interface is COMM/2/0xff
-		 * (MSFT RNDIS), rule it out unless Linux has host-side
-		 * RNDIS support. */
-		if (i == 0 &amp;&amp; desc
-				&amp;&amp; desc-&gt;bInterfaceClass == USB_CLASS_COMM
-				&amp;&amp; desc-&gt;bInterfaceSubClass == 2
-				&amp;&amp; desc-&gt;bInterfaceProtocol == 0xff) {
-#ifndef CONFIG_USB_NET_RNDIS_HOST
-			continue;
-#else
-			best = c;
-#endif
-		}
-
-		/* From the remaining configs, choose the first one whose
-		 * first interface is for a non-vendor-specific class.
-		 * Reason: Linux is more likely to have a class driver
-		 * than a vendor-specific driver. */
-		else if (udev-&gt;descriptor.bDeviceClass !=
-						USB_CLASS_VENDOR_SPEC &amp;&amp;
-				(!desc || desc-&gt;bInterfaceClass !=
-						USB_CLASS_VENDOR_SPEC)) {
-			best = c;
-			break;
-		}
-
-		/* If all the remaining configs are vendor-specific,
-		 * choose the first one. */
-		else if (!best)
-			best = c;
-	}
-
-	if (insufficient_power &gt; 0)
-		dev_info(&amp;udev-&gt;dev, "rejected %d configuration%s "
-			"due to insufficient available bus power\n",
-			insufficient_power, plural(insufficient_power));
-
-	if (best) {
-		i = best-&gt;desc.bConfigurationValue;
-		dev_info(&amp;udev-&gt;dev,
-			"configuration #%d chosen from %d choice%s\n",
-			i, num_configs, plural(num_configs));
-	} else {
-		i = -1;
-		dev_warn(&amp;udev-&gt;dev,
-			"no configuration chosen from %d choice%s\n",
-			num_configs, plural(num_configs));
-	}
-	return i;
+	put_device(&amp;udev-&gt;dev);
 }
 
 #ifdef DEBUG
@@ -1328,7 +1212,6 @@ static inline void show_string(struct usb_device *udev, char *id, char *string)
 int usb_new_device(struct usb_device *udev)
 {
 	int err;
-	int c;
 
 	err = usb_get_configuration(udev);
 	if (err &lt; 0) {
@@ -1418,34 +1301,15 @@ int usb_new_device(struct usb_device *udev)
 	}
 #endif
 
-	/* put device-specific files into sysfs */
+	/* Register the device.  The device driver is responsible
+	 * for adding the device files to usbfs and sysfs and for
+	 * configuring the device.
+	 */
 	err = device_add (&amp;udev-&gt;dev);
 	if (err) {
 		dev_err(&amp;udev-&gt;dev, "can't device_add, error %d\n", err);
 		goto fail;
 	}
-	usb_create_sysfs_dev_files (udev);
-
-	usb_lock_device(udev);
-
-	/* choose and set the configuration. that registers the interfaces
-	 * with the driver core, and lets usb device drivers bind to them.
-	 */
-	c = choose_configuration(udev);
-	if (c &gt;= 0) {
-		err = usb_set_configuration(udev, c);
-		if (err) {
-			dev_err(&amp;udev-&gt;dev, "can't set config #%d, error %d\n",
-					c, err);
-			/* This need not be fatal.  The user can try to
-			 * set other configurations. */
-		}
-	}
-
-	/* USB device state == configured ... usable */
-	usb_notify_add_device(udev);
-
-	usb_unlock_device(udev);
 
 	return 0;
 
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 6dfbc284369b..9ebfc0fe819d 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -205,7 +205,6 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	device_initialize(&amp;dev-&gt;dev);
 	dev-&gt;dev.bus = &amp;usb_bus_type;
 	dev-&gt;dev.dma_mask = bus-&gt;controller-&gt;dma_mask;
-	dev-&gt;dev.driver = &amp;usb_generic_driver.drvwrap.driver;
 	dev-&gt;dev.release = usb_release_dev;
 	dev-&gt;state = USB_STATE_ATTACHED;
 </pre>
    <div class="pagination">
        <a href='2_120.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><span>[121]</span><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_122.html'>Next&gt;&gt;</a>
    <div>
</body>
