<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_97.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><span>[98]</span><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_99.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4145ed6dc597a9bea5f6ae8c574653b2de10620f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 19 10:15:02 2007 -0500

    USB: make ksuspend_usbd thread non-freezable
    
    This patch (as1012b) makes the ksuspend_usbd kernel thread
    non-freezable.  Since the PM core has been changed to lock all devices
    during a system sleep, the thread no longer needs to be frozen.  It
    won't interfere with a system sleep because before trying to resume a
    root hub device, it acquires the device's lock.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 8f142370103d..bc5edacb0c34 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -230,7 +230,7 @@ static int ksuspend_usb_init(void)
 	 * singlethreaded.  Its job doesn't justify running on more
 	 * than one CPU.
 	 */
-	ksuspend_usb_wq = create_freezeable_workqueue("ksuspend_usbd");
+	ksuspend_usb_wq = create_singlethread_workqueue("ksuspend_usbd");
 	if (!ksuspend_usb_wq)
 		return -ENOMEM;
 	return 0;</pre><hr><pre>commit 676d3aa16f66d94bf5654781b77d1e070c8b0514
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 8 15:15:28 2007 -0500

    USB: usb-storage: new "lockable" subclass 0x07
    
    This patch (as1011) adds a #define for the newly-created Lockable
    (i.e., password-protected) subclass 0x07 for USB mass-storage devices.
    The private ISD200 entry (which had been mapped to subclass 0x07) is
    moved to 0xf0, which is unlikely to conflict with any official
    subclass designation.
    
    The US_SC_MIN and US_SC_MAX constants aren't used anywhere, so the
    patch removes them.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h
index a417b09b8b3d..cee0623b3c7b 100644
--- a/include/linux/usb_usual.h
+++ b/include/linux/usb_usual.h
@@ -80,10 +80,9 @@ enum { US_DO_ALL_FLAGS };
 #define US_SC_UFI	0x04		/* Floppy */
 #define US_SC_8070	0x05		/* Removable media */
 #define US_SC_SCSI	0x06		/* Transparent */
-#define US_SC_ISD200    0x07		/* ISD200 ATA */
-#define US_SC_MIN	US_SC_RBC
-#define US_SC_MAX	US_SC_ISD200
+#define US_SC_LOCKABLE	0x07		/* Password-protected */
 
+#define US_SC_ISD200    0xf0		/* ISD200 ATA */
 #define US_SC_DEVICE	0xff		/* Use device's value */
 
 /* Protocols */</pre><hr><pre>commit 09f82ea92822a7bbb7e816508abbda47ed54a77f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 19 10:53:40 2007 -0500

    Kobject: drop child-&gt;parent ref at unregistration
    
    This patch (as1015) reverts changes that were made to the driver core
    about four years ago.  The intent back then was to avoid certain kinds
    of invalid memory accesses by leaving kernel objects allocated as long
    as any of their children were still allocated.  The original and
    correct approach was to wait only as long as any children were still
    _registered_; that's what this patch reinstates.
    
    This fixes a problem in the SCSI core made visible by the class_device
    to regular device conversion: A reference loop (scsi_device holds
    reference to request_queue, which is the child of a gendisk, which is
    the child of the scsi_device) prevents the data structures from being
    released, even though they are deregistered okay.
    
    It's possible that this change will cause a few bugs to surface,
    things that have been hidden for several years.  They can be fixed
    easily enough by having the child device take an explicit reference to
    the parent whenever needed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/lib/kobject.c b/lib/kobject.c
index 1015f74212d0..493e991abb1b 100644
--- a/lib/kobject.c
+++ b/lib/kobject.c
@@ -149,12 +149,16 @@ void kobject_init(struct kobject * kobj)
 
 static void unlink(struct kobject * kobj)
 {
+	struct kobject *parent = kobj-&gt;parent;
+
 	if (kobj-&gt;kset) {
 		spin_lock(&amp;kobj-&gt;kset-&gt;list_lock);
 		list_del_init(&amp;kobj-&gt;entry);
 		spin_unlock(&amp;kobj-&gt;kset-&gt;list_lock);
 	}
+	kobj-&gt;parent = NULL;
 	kobject_put(kobj);
+	kobject_put(parent);
 }
 
 /**
@@ -208,7 +212,6 @@ int kobject_add(struct kobject * kobj)
 	if (error) {
 		/* unlink does the kobject_put() for us */
 		unlink(kobj);
-		kobject_put(parent);
 
 		/* be noisy on error issues */
 		if (error == -EEXIST)
@@ -590,7 +593,6 @@ static void kobject_cleanup(struct kobject *kobj)
 {
 	struct kobj_type * t = get_ktype(kobj);
 	struct kset * s = kobj-&gt;kset;
-	struct kobject * parent = kobj-&gt;parent;
 	const char *name = kobj-&gt;k_name;
 
 	pr_debug("kobject: '%s' (%p): %s\n",
@@ -604,7 +606,6 @@ static void kobject_cleanup(struct kobject *kobj)
 	}
 	if (s)
 		kset_put(s);
-	kobject_put(parent);
 }
 
 static void kobject_release(struct kref *kref)</pre><hr><pre>commit ef2c51746dc89c2326ce522f8fb8a57695780e75
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Nov 16 11:57:28 2007 -0500

    Driver core: fix race in __device_release_driver
    
    This patch (as1013) was suggested by David Woodhouse; it fixes a race
    in the driver core.  If a device is unregistered at the same time as
    its driver is unloaded, the driver's code pages may be unmapped while
    the remove method is still running.  The calls to get_driver() and
    put_driver() were intended to prevent this, but they don't work if the
    driver's module count has already dropped to 0.
    
    Instead, the patch keeps the device on the driver's list until after
    the remove method has returned.  This forces the necessary
    synchronization to occur.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: David Woodhouse &lt;dwmw2@infradead.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 54922647522d..b0726eb6405e 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -289,11 +289,10 @@ static void __device_release_driver(struct device * dev)
 {
 	struct device_driver * drv;
 
-	drv = get_driver(dev-&gt;driver);
+	drv = dev-&gt;driver;
 	if (drv) {
 		driver_sysfs_remove(dev);
 		sysfs_remove_link(&amp;dev-&gt;kobj, "driver");
-		klist_remove(&amp;dev-&gt;knode_driver);
 
 		if (dev-&gt;bus)
 			blocking_notifier_call_chain(&amp;dev-&gt;bus-&gt;p-&gt;bus_notifier,
@@ -306,7 +305,7 @@ static void __device_release_driver(struct device * dev)
 			drv-&gt;remove(dev);
 		devres_release_all(dev);
 		dev-&gt;driver = NULL;
-		put_driver(drv);
+		klist_remove(&amp;dev-&gt;knode_driver);
 	}
 }
 </pre><hr><pre>commit 442258e2ff69276ff767f3703b30ce6a31fdd181
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Dec 6 14:47:08 2007 -0500

    USB: use IRQF_DISABLED for HCD interrupt handlers
    
    Host controller IRQs are supposed to be serviced with interrupts
    disabled.  This patch (as1026) adds an IRQF_DISABLED flag to all the
    controller drivers that lack it.  It also replaces the
    spin_lock_irqsave() and spin_unlock_irqrestore() calls in uhci_irq()
    with simple spin_lock() and spin_unlock().
    
    This fixes Bugzilla #9335.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 5cf6d5f9acbd..3fb9af80cbf4 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -125,7 +125,7 @@ int usb_hcd_pci_probe (struct pci_dev *dev, const struct pci_device_id *id)
 
 	pci_set_master (dev);
 
-	retval = usb_add_hcd (hcd, dev-&gt;irq, IRQF_SHARED);
+	retval = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
 	return retval;
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index b7b7bfbce527..430821cb95c8 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -122,7 +122,7 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	temp = in_le32(hcd-&gt;regs + 0x1a8);
 	out_le32(hcd-&gt;regs + 0x1a8, temp | 0x3);
 
-	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
 	return retval;
diff --git a/drivers/usb/host/ohci-ppc-of.c b/drivers/usb/host/ohci-ppc-of.c
index 0a7426920150..0c3e6b790b7b 100644
--- a/drivers/usb/host/ohci-ppc-of.c
+++ b/drivers/usb/host/ohci-ppc-of.c
@@ -142,7 +142,7 @@ ohci_hcd_ppc_of_probe(struct of_device *op, const struct of_device_id *match)
 
 	ohci_hcd_init(ohci);
 
-	rv = usb_add_hcd(hcd, irq, 0);
+	rv = usb_add_hcd(hcd, irq, IRQF_DISABLED);
 	if (rv == 0)
 		return 0;
 
diff --git a/drivers/usb/host/ohci-ssb.c b/drivers/usb/host/ohci-ssb.c
index fe70e72340de..6e9c2d6db887 100644
--- a/drivers/usb/host/ohci-ssb.c
+++ b/drivers/usb/host/ohci-ssb.c
@@ -160,7 +160,7 @@ static int ssb_ohci_attach(struct ssb_device *dev)
 	hcd-&gt;regs = ioremap_nocache(hcd-&gt;rsrc_start, hcd-&gt;rsrc_len);
 	if (!hcd-&gt;regs)
 		goto err_put_hcd;
-	err = usb_add_hcd(hcd, dev-&gt;irq, IRQF_SHARED);
+	err = usb_add_hcd(hcd, dev-&gt;irq, IRQF_DISABLED | IRQF_SHARED);
 	if (err)
 		goto err_iounmap;
 
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index ae8ec4474eb8..0ce2fc5e396b 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -2197,7 +2197,7 @@ static int __init r8a66597_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&amp;r8a66597-&gt;child_device);
 
 	hcd-&gt;rsrc_start = res-&gt;start;
-	ret = usb_add_hcd(hcd, irq, 0);
+	ret = usb_add_hcd(hcd, irq, IRQF_DISABLED);
 	if (ret != 0) {
 		err("Failed to add hcd");
 		goto clean_up;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 4db17f75f4f1..ec987897b8ed 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -378,7 +378,6 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned short status;
-	unsigned long flags;
 
 	/*
 	 * Read the interrupt status, and write it back to clear the
@@ -398,7 +397,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 			dev_err(uhci_dev(uhci), "host controller process "
 					"error, something bad happened!\n");
 		if (status &amp; USBSTS_HCH) {
-			spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+			spin_lock(&amp;uhci-&gt;lock);
 			if (uhci-&gt;rh_state &gt;= UHCI_RH_RUNNING) {
 				dev_err(uhci_dev(uhci),
 					"host controller halted, "
@@ -415,16 +414,16 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd)
 				 * pending unlinks */
 				mod_timer(&amp;hcd-&gt;rh_timer, jiffies);
 			}
-			spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+			spin_unlock(&amp;uhci-&gt;lock);
 		}
 	}
 
 	if (status &amp; USBSTS_RD)
 		usb_hcd_poll_rh_status(hcd);
 	else {
-		spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+		spin_lock(&amp;uhci-&gt;lock);
 		uhci_scan_schedule(uhci);
-		spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
+		spin_unlock(&amp;uhci-&gt;lock);
 	}
 
 	return IRQ_HANDLED;</pre><hr><pre>commit d48bd977e0dd8c17081d12242bfc09d743ea0d26
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 11 16:02:23 2007 -0500

    USB: fix locking loop by avoiding flush_scheduled_work
    
    This patch (as1027) replaces a call to flush_scheduled_work() -- a
    dangerous routine to invoke, especially while holding any sort of lock
    -- with calls to cancel_work_sync() and cancel_delayed_work_sync().
    
    This fixes Bugzilla #9532.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 13b326a13377..b04d232d4c65 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -522,9 +522,9 @@ static void hub_quiesce(struct usb_hub *hub)
 	/* (blocking) stop khubd and related activity */
 	usb_kill_urb(hub-&gt;urb);
 	if (hub-&gt;has_indicators)
-		cancel_delayed_work(&amp;hub-&gt;leds);
-	if (hub-&gt;has_indicators || hub-&gt;tt.hub)
-		flush_scheduled_work();
+		cancel_delayed_work_sync(&amp;hub-&gt;leds);
+	if (hub-&gt;tt.hub)
+		cancel_work_sync(&amp;hub-&gt;tt.kevent);
 }
 
 static void hub_activate(struct usb_hub *hub)</pre><hr><pre>commit f1e8de0dbb9ee30cd6eb9c510249847d28443cb1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 26 10:23:05 2007 -0500

    USB: usb-storage: unusual_devs entry for JetFlash TS1GJF2A
    
    This patch (as1018) adds an unusual_devs entry for the JetFlash
    TS1GJF2A.  This device doesn't like read requests for more than 188
    sectors.  Setting max_sectors down to 64 is overkill, but at least
    it will work without errors.
    
    For the torturous debugging history, see this thread:
    
            http://marc.info/?t=118745764700005&amp;r=1&amp;w=2
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 7398229c5255..2c27721bd259 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -731,6 +731,13 @@ UNUSUAL_DEV(  0x0584, 0x0008, 0x0102, 0x0102,
  		US_SC_SCSI, US_PR_ALAUDA, init_alauda, 0 ),
 #endif
 
+/* Reported by RTE &lt;raszilki@yandex.ru&gt; */
+UNUSUAL_DEV(  0x058f, 0x6387, 0x0141, 0x0141,
+		"JetFlash",
+		"TS1GJF2A/120",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_MAX_SECTORS_64 ),
+
 /* Fabrizio Fellini &lt;fello@libero.it&gt; */
 UNUSUAL_DEV(  0x0595, 0x4343, 0x0000, 0x2210,
 		"Fujifilm",</pre><hr><pre>commit 4a9bee8256a2dec26290a3bfff86ab86b8992547
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 6 15:01:52 2007 -0500

    USB: uevent environment key fix
    
    This patch (as1010) was written by both Kay Sievers and me.  It solves
    the problem of duplicated keys in USB uevent structures by refactoring
    the uevent subroutines, taking advantage of the way the hotplug core
    calls uevent handlers for the device's bus and for the device's type.
    Keys needed for both USB-device and USB-interface events are added in
    usb_uevent(), which is the bus handler.  Keys appropriate only for
    USB-device or USB-interface events are added in usb_dev_uevent() or
    usb_if_uevent() respectively, the type handlers.
    
    In addition, unnecessary tests for NULL pointers are removed as are
    duplicated debugging log statements.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Kay Sievers &lt;kay.sievers@vrfy.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8586817698ad..c51f8e9312e0 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -585,9 +585,6 @@ static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
 {
 	struct usb_device *usb_dev;
 
-	if (!dev)
-		return -ENODEV;
-
 	/* driver is often null here; dev_dbg() would oops */
 	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
 
@@ -631,14 +628,6 @@ static int usb_uevent(struct device *dev, struct kobj_uevent_env *env)
 			   usb_dev-&gt;descriptor.bDeviceProtocol))
 		return -ENOMEM;
 
-	if (add_uevent_var(env, "BUSNUM=%03d",
-			   usb_dev-&gt;bus-&gt;busnum))
-		return -ENOMEM;
-
-	if (add_uevent_var(env, "DEVNUM=%03d",
-			   usb_dev-&gt;devnum))
-		return -ENOMEM;
-
 	return 0;
 }
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 40fd39de5bf9..fcd40ecbeecc 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1346,34 +1346,10 @@ static int usb_if_uevent(struct device *dev, struct kobj_uevent_env *env)
 	struct usb_interface *intf;
 	struct usb_host_interface *alt;
 
-	if (!dev)
-		return -ENODEV;
-
-	/* driver is often null here; dev_dbg() would oops */
-	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
-
 	intf = to_usb_interface(dev);
 	usb_dev = interface_to_usbdev(intf);
 	alt = intf-&gt;cur_altsetting;
 
-#ifdef CONFIG_USB_DEVICEFS
-	if (add_uevent_var(env, "DEVICE=/proc/bus/usb/%03d/%03d",
-			   usb_dev-&gt;bus-&gt;busnum, usb_dev-&gt;devnum))
-		return -ENOMEM;
-#endif
-
-	if (add_uevent_var(env, "PRODUCT=%x/%x/%x",
-			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
-			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
-			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice)))
-		return -ENOMEM;
-
-	if (add_uevent_var(env, "TYPE=%d/%d/%d",
-			   usb_dev-&gt;descriptor.bDeviceClass,
-			   usb_dev-&gt;descriptor.bDeviceSubClass,
-			   usb_dev-&gt;descriptor.bDeviceProtocol))
-		return -ENOMEM;
-
 	if (add_uevent_var(env, "INTERFACE=%d/%d/%d",
 		   alt-&gt;desc.bInterfaceClass,
 		   alt-&gt;desc.bInterfaceSubClass,
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index c4a6f1095b8b..8f142370103d 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -192,9 +192,34 @@ static void usb_release_dev(struct device *dev)
 	kfree(udev);
 }
 
+#ifdef	CONFIG_HOTPLUG
+static int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	struct usb_device *usb_dev;
+
+	usb_dev = to_usb_device(dev);
+
+	if (add_uevent_var(env, "BUSNUM=%03d", usb_dev-&gt;bus-&gt;busnum))
+		return -ENOMEM;
+
+	if (add_uevent_var(env, "DEVNUM=%03d", usb_dev-&gt;devnum))
+		return -ENOMEM;
+
+	return 0;
+}
+
+#else
+
+static int usb_dev_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	return -ENODEV;
+}
+#endif	/* CONFIG_HOTPLUG */
+
 struct device_type usb_device_type = {
 	.name =		"usb_device",
 	.release =	usb_release_dev,
+	.uevent =	usb_dev_uevent,
 };
 
 #ifdef	CONFIG_PM</pre><hr><pre>commit 7e61559f6199bb387037abfc7d10a893973561fc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Nov 6 11:43:42 2007 -0500

    USB: keep track of whether interface sysfs files exist
    
    This patch (as1009) solves the problem of multiple registrations for
    USB sysfs files in a more satisfying way than the existing code.  It
    simply adds a flag to keep track of whether or not the files have been
    created; that way the files can be created or removed as needed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 316a746e0080..40fd39de5bf9 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1172,7 +1172,6 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	struct usb_host_interface *alt;
 	int ret;
 	int manual = 0;
-	int changed;
 
 	if (dev-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
@@ -1212,8 +1211,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
-	changed = (iface-&gt;cur_altsetting != alt);
-	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
+	if (iface-&gt;cur_altsetting != alt &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
 		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
@@ -1250,7 +1248,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 * (Likewise, EP0 never "halts" on well designed devices.)
 	 */
 	usb_enable_interface(dev, iface);
-	if (changed &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
+	if (device_is_registered(&amp;iface-&gt;dev))
 		usb_create_sysfs_intf_files(iface);
 
 	return 0;
@@ -1641,12 +1639,6 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 				intf-&gt;dev.bus_id, ret);
 			continue;
 		}
-
-		/* The driver's probe method can call usb_set_interface(),
-		 * which would mean the interface's sysfs files are already
-		 * created.  Just in case, we'll remove them first.
-		 */
-		usb_remove_sysfs_intf_files(intf);
 		usb_create_sysfs_intf_files(intf);
 	}
 
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index b04afd06e502..32bd130b1eed 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -735,6 +735,8 @@ int usb_create_sysfs_intf_files(struct usb_interface *intf)
 	struct usb_host_interface *alt = intf-&gt;cur_altsetting;
 	int retval;
 
+	if (intf-&gt;sysfs_files_created)
+		return 0;
 	retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 	if (retval)
 		return retval;
@@ -746,6 +748,7 @@ int usb_create_sysfs_intf_files(struct usb_interface *intf)
 	if (intf-&gt;intf_assoc)
 		retval = sysfs_create_group(&amp;dev-&gt;kobj, &amp;intf_assoc_attr_grp);
 	usb_create_intf_ep_files(intf, udev);
+	intf-&gt;sysfs_files_created = 1;
 	return 0;
 }
 
@@ -753,8 +756,11 @@ void usb_remove_sysfs_intf_files(struct usb_interface *intf)
 {
 	struct device *dev = &amp;intf-&gt;dev;
 
+	if (!intf-&gt;sysfs_files_created)
+		return;
 	usb_remove_intf_ep_files(intf);
 	device_remove_file(dev, &amp;dev_attr_interface);
 	sysfs_remove_group(&amp;dev-&gt;kobj, &amp;intf_attr_grp);
 	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;intf_assoc_attr_grp);
+	intf-&gt;sysfs_files_created = 0;
 }
diff --git a/include/linux/usb.h b/include/linux/usb.h
index c5c8f169d3cf..416ee7617d9e 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -157,6 +157,7 @@ struct usb_interface {
 					 * bound to */
 	enum usb_interface_condition condition;		/* state of binding */
 	unsigned is_active:1;		/* the interface is not suspended */
+	unsigned sysfs_files_created:1;	/* the sysfs attributes exist */
 	unsigned needs_remote_wakeup:1;	/* driver requires remote wakeup */
 
 	struct device dev;		/* interface specific device info */</pre><hr><pre>commit ddc1fd6ac1f3ad3275e19451fb07d2eff249161c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 21 15:13:10 2007 -0800

    USB HCD: avoid duplicate local_irq_disable()
    
    Arnd Bergmann wrote:
    
    usb_hcd_flush_endpoint() has a retry loop that starts with a spin_lock_irq(),
    but only gives up the spinlock, not the irq_disable before jumping to the
    rescan label.
    
    Alan Stern:
    
    I agree with your sentiment, but it would be better to solve this
    problem without using local_irq_disable().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index fea8256a18d6..d5ed3fa9e304 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1311,8 +1311,8 @@ void usb_hcd_flush_endpoint(struct usb_device *udev,
 	hcd = bus_to_hcd(udev-&gt;bus);
 
 	/* No more submits can occur */
-rescan:
 	spin_lock_irq(&amp;hcd_urb_list_lock);
+rescan:
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
 		int	is_in;
 
@@ -1345,6 +1345,7 @@ void usb_hcd_flush_endpoint(struct usb_device *udev,
 		usb_put_urb (urb);
 
 		/* list contents may have changed */
+		spin_lock(&amp;hcd_urb_list_lock);
 		goto rescan;
 	}
 	spin_unlock_irq(&amp;hcd_urb_list_lock);</pre>
    <div class="pagination">
        <a href='2_97.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><span>[98]</span><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_99.html'>Next&gt;&gt;</a>
    <div>
</body>
