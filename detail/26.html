<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Adelaide</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Adelaide</h1>
    <div class="pagination">
        <span>[1]</span><a href='26_2.html'>2</a><a href='26_3.html'>3</a><a href='26_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 53bacfbbb2ddd981287b58a511c8b8f5df179886
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Sun Aug 8 00:17:05 2010 +0930

    ALSA: hda - Fix missing stream for second ADC on Realtek ALC260 HDA codec
    
    I discovered tonight that ALSA no longer sets up a stream for the second ADC
    provided by the Realtek ALC260 HDA codec.  At some point alc_build_pcms()
    started using stream_analog_alt_capture when constructing the second ADC
    stream, but patch_alc260() was never updated accordingly.  I have no idea
    when this regression occurred.  The trivial patch to patch_alc260() given
    below fixes the problem as far as I can tell.  The patch is against 2.6.35.
    
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Cc: &lt;stable@kernel.org&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index 2891571e7647..6b00a2369e97 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -7042,6 +7042,7 @@ static int patch_alc260(struct hda_codec *codec)
 
 	spec-&gt;stream_analog_playback = &amp;alc260_pcm_analog_playback;
 	spec-&gt;stream_analog_capture = &amp;alc260_pcm_analog_capture;
+	spec-&gt;stream_analog_alt_capture = &amp;alc260_pcm_analog_capture;
 
 	spec-&gt;stream_digital_playback = &amp;alc260_pcm_digital_playback;
 	spec-&gt;stream_digital_capture = &amp;alc260_pcm_digital_capture;</pre><hr><pre>commit 3b1c37cab3765b87efbd4ed40301ceaf72b9f5c2
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Wed Dec 23 09:19:42 2009 +1030

    fujitu-laptop: fix tests of acpi_evaluate_integer() return value
    
    Fix tests on return value from acpi_evaluate_integer().  Based on a patch by
    Roel Kluin &lt;roel.kluin@gmail.com&gt; and incorporating suggestions from Len
    Brown &lt;lenb@kernel.org&gt;.
    
    Signed-off-by: Roel Kluin &lt;roel.kluin@gmail.com&gt;
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Len Brown &lt;len.brown@intel.com&gt;

diff --git a/drivers/platform/x86/fujitsu-laptop.c b/drivers/platform/x86/fujitsu-laptop.c
index bcd4ba8be7db..3c2d0384b43b 100644
--- a/drivers/platform/x86/fujitsu-laptop.c
+++ b/drivers/platform/x86/fujitsu-laptop.c
@@ -376,8 +376,8 @@ static int get_lcd_level(void)
 
 	status =
 	    acpi_evaluate_integer(fujitsu-&gt;acpi_handle, "GBLL", NULL, &amp;state);
-	if (status &lt; 0)
-		return status;
+	if (ACPI_FAILURE(status))
+		return 0;
 
 	fujitsu-&gt;brightness_level = state &amp; 0x0fffffff;
 
@@ -398,8 +398,8 @@ static int get_max_brightness(void)
 
 	status =
 	    acpi_evaluate_integer(fujitsu-&gt;acpi_handle, "RBLL", NULL, &amp;state);
-	if (status &lt; 0)
-		return status;
+	if (ACPI_FAILURE(status))
+		return -1;
 
 	fujitsu-&gt;max_brightness = state;
 </pre><hr><pre>commit 2906206350b7e13e2047467cc29a0a2d78d71cb2
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Thu Oct 8 13:19:12 2009 +0930

    fujitsu-laptop: address missed led-class ifdef fixup
    
    A follow-up 2.6.32-rc1's
    
    1e384cb0f9a940f2a431d1708f963987e61d71e3
    "fujitsu-laptop: support led-class as module"
    
    It's a trivial fix for one of the CONFIG_LEDS_CLASS ifdefs
    which was somehow missed in the original patch.
    
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Len Brown &lt;len.brown@intel.com&gt;

diff --git a/drivers/platform/x86/fujitsu-laptop.c b/drivers/platform/x86/fujitsu-laptop.c
index f35aee5c2149..bcd4ba8be7db 100644
--- a/drivers/platform/x86/fujitsu-laptop.c
+++ b/drivers/platform/x86/fujitsu-laptop.c
@@ -944,7 +944,7 @@ static int acpi_fujitsu_hotkey_remove(struct acpi_device *device, int type)
 	struct fujitsu_hotkey_t *fujitsu_hotkey = acpi_driver_data(device);
 	struct input_dev *input = fujitsu_hotkey-&gt;input;
 
-#ifdef CONFIG_LEDS_CLASS
+#if defined(CONFIG_LEDS_CLASS) || defined(CONFIG_LEDS_CLASS_MODULE)
 	if (fujitsu_hotkey-&gt;logolamp_registered)
 		led_classdev_unregister(&amp;logolamp_led);
 </pre><hr><pre>commit 84a6ce267296dabdf427ea4aff73dc58164863bb
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Fri Jul 31 18:16:59 2009 +0930

    fujitsu-laptop: increment driver version
    
    Increment driver version to reflect the changes from this patch series.
    
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Len Brown &lt;len.brown@intel.com&gt;

diff --git a/drivers/platform/x86/fujitsu-laptop.c b/drivers/platform/x86/fujitsu-laptop.c
index b87a5a2084a9..1ed3513a62a2 100644
--- a/drivers/platform/x86/fujitsu-laptop.c
+++ b/drivers/platform/x86/fujitsu-laptop.c
@@ -70,7 +70,7 @@
 #include &lt;linux/leds.h&gt;
 #endif
 
-#define FUJITSU_DRIVER_VERSION "0.5.0"
+#define FUJITSU_DRIVER_VERSION "0.6.0"
 
 #define FUJITSU_LCD_N_LEVELS 8
 </pre><hr><pre>commit c1b5310a957c47d1c66bb53035c6ba6aa20a150f
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Thu Aug 27 18:45:33 2009 -0400

    fujitsu-laptop: fix config corner case
    
    This patch is a trivial fix for a config corner case, ensuring that
    fujitsu-laptop doesn't get compiled into the kernel when the led class
    is a module.
    
    Signed-off-by: Alan Jenkins &lt;alan-jenkins@tuffmail.co.uk&gt;
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Len Brown &lt;len.brown@intel.com&gt;

diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 77c6097ced80..0b5a85b8048f 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -99,6 +99,7 @@ config FUJITSU_LAPTOP
 	depends on ACPI
 	depends on INPUT
 	depends on BACKLIGHT_CLASS_DEVICE
+	depends on LEDS_CLASS || LEDS_CLASS=n
 	---help---
 	  This is a driver for laptops built by Fujitsu:
 </pre><hr><pre>commit 0e6a66e9cf231140d2e49064d48162728edb7746
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Thu Oct 9 13:44:40 2008 +0930

    fujitsu-laptop: better handling of P8010 hotkey
    
    This patch (mostly from Peter Gruber) improves the handling of the hotkeys
    for P8010 laptops by passing more accurate input events back to userspace.
    This is needed because the P8010 labels these buttons quite differently to
    earlier laptops.  As part of this, a P8010-specific DMI callback check has
    been implemented.  Finally there's some minor whitespace cleanups from
    running the source through Lindent.
    
    Signed-off-by: Peter Gruber &lt;nokos@gmx.net&gt;
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Len Brown &lt;len.brown@intel.com&gt;

diff --git a/drivers/misc/fujitsu-laptop.c b/drivers/misc/fujitsu-laptop.c
index 3e56203e4947..f861db072777 100644
--- a/drivers/misc/fujitsu-laptop.c
+++ b/drivers/misc/fujitsu-laptop.c
@@ -44,8 +44,9 @@
  * Hotkeys present on certain Fujitsu laptops (eg: the S6xxx series) are
  * also supported by this driver.
  *
- * This driver has been tested on a Fujitsu Lifebook S6410 and S7020.  It
- * should work on most P-series and S-series Lifebooks, but YMMV.
+ * This driver has been tested on a Fujitsu Lifebook S6410, S7020 and
+ * P8010.  It should work on most P-series and S-series Lifebooks, but
+ * YMMV.
  *
  * The module parameter use_alt_lcd_levels switches between different ACPI
  * brightness controls which are used by different Fujitsu laptops.  In most
@@ -65,7 +66,7 @@
 #include &lt;linux/video_output.h&gt;
 #include &lt;linux/platform_device.h&gt;
 
-#define FUJITSU_DRIVER_VERSION "0.4.2"
+#define FUJITSU_DRIVER_VERSION "0.4.3"
 
 #define FUJITSU_LCD_N_LEVELS 8
 
@@ -83,10 +84,10 @@
 #define ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS     0x87
 
 /* Hotkey details */
-#define LOCK_KEY	0x410	/* codes for the keys in the GIRB register */
-#define DISPLAY_KEY	0x411	/* keys are mapped to KEY_SCREENLOCK (the key with the key symbol) */
-#define ENERGY_KEY	0x412	/* KEY_MEDIA (the key with the laptop symbol, KEY_EMAIL (E key)) */
-#define REST_KEY	0x413	/* KEY_SUSPEND (R key) */
+#define KEY1_CODE	0x410	/* codes for the keys in the GIRB register */
+#define KEY2_CODE	0x411
+#define KEY3_CODE	0x412
+#define KEY4_CODE	0x413
 
 #define MAX_HOTKEY_RINGBUFFER_SIZE 100
 #define RINGBUFFERSIZE 40
@@ -123,6 +124,7 @@ struct fujitsu_t {
 	char phys[32];
 	struct backlight_device *bl_device;
 	struct platform_device *pf_device;
+	int keycode1, keycode2, keycode3, keycode4;
 
 	unsigned int max_brightness;
 	unsigned int brightness_changed;
@@ -430,7 +432,7 @@ static struct platform_driver fujitsupf_driver = {
 		   }
 };
 
-static int dmi_check_cb_s6410(const struct dmi_system_id *id)
+static void dmi_check_cb_common(const struct dmi_system_id *id)
 {
 	acpi_handle handle;
 	int have_blnf;
@@ -452,24 +454,40 @@ static int dmi_check_cb_s6410(const struct dmi_system_id *id)
 			    "auto-detecting disable_adjust\n");
 		disable_brightness_adjust = have_blnf ? 0 : 1;
 	}
+}
+
+static int dmi_check_cb_s6410(const struct dmi_system_id *id)
+{
+	dmi_check_cb_common(id);
+	fujitsu-&gt;keycode1 = KEY_SCREENLOCK;	/* "Lock" */
+	fujitsu-&gt;keycode2 = KEY_HELP;	/* "Mobility Center" */
+	return 0;
+}
+
+static int dmi_check_cb_p8010(const struct dmi_system_id *id)
+{
+	dmi_check_cb_common(id);
+	fujitsu-&gt;keycode1 = KEY_HELP;	/* "Support" */
+	fujitsu-&gt;keycode3 = KEY_SWITCHVIDEOMODE;	/* "Presentation" */
+	fujitsu-&gt;keycode4 = KEY_WWW;	/* "Internet" */
 	return 0;
 }
 
 static struct dmi_system_id __initdata fujitsu_dmi_table[] = {
 	{
-	 .ident = "Fujitsu Siemens",
+	 .ident = "Fujitsu Siemens S6410",
 	 .matches = {
 		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
 		     DMI_MATCH(DMI_PRODUCT_NAME, "LIFEBOOK S6410"),
 		     },
 	 .callback = dmi_check_cb_s6410},
 	{
-	 .ident = "FUJITSU LifeBook P8010",
+	 .ident = "Fujitsu LifeBook P8010",
 	 .matches = {
 		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
 		     DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook P8010"),
-		    },
-	 .callback = dmi_check_cb_s6410},
+		     },
+	 .callback = dmi_check_cb_p8010},
 	{}
 };
 
@@ -547,7 +565,6 @@ static int acpi_fujitsu_add(struct acpi_device *device)
 	}
 
 	/* do config (detect defaults) */
-	dmi_check_system(fujitsu_dmi_table);
 	use_alt_lcd_levels = use_alt_lcd_levels == 1 ? 1 : 0;
 	disable_brightness_keys = disable_brightness_keys == 1 ? 1 : 0;
 	disable_brightness_adjust = disable_brightness_adjust == 1 ? 1 : 0;
@@ -623,17 +640,17 @@ static void acpi_fujitsu_notify(acpi_handle handle, u32 event, void *data)
 			keycode = 0;
 			if (disable_brightness_keys != 1) {
 				if (oldb == 0) {
-					acpi_bus_generate_proc_event(fujitsu-&gt;
-						dev,
-						ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS,
-						0);
+					acpi_bus_generate_proc_event
+					    (fujitsu-&gt;dev,
+					     ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS,
+					     0);
 					keycode = KEY_BRIGHTNESSDOWN;
 				} else if (oldb ==
 					   (fujitsu-&gt;max_brightness) - 1) {
-					acpi_bus_generate_proc_event(fujitsu-&gt;
-						dev,
-						ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS,
-						0);
+					acpi_bus_generate_proc_event
+					    (fujitsu-&gt;dev,
+					     ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS,
+					     0);
 					keycode = KEY_BRIGHTNESSUP;
 				}
 			}
@@ -646,8 +663,7 @@ static void acpi_fujitsu_notify(acpi_handle handle, u32 event, void *data)
 			}
 			if (disable_brightness_keys != 1) {
 				acpi_bus_generate_proc_event(fujitsu-&gt;dev,
-					ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS,
-					0);
+					ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS, 0);
 				keycode = KEY_BRIGHTNESSUP;
 			}
 		} else if (oldb &gt; newb) {
@@ -659,8 +675,7 @@ static void acpi_fujitsu_notify(acpi_handle handle, u32 event, void *data)
 			}
 			if (disable_brightness_keys != 1) {
 				acpi_bus_generate_proc_event(fujitsu-&gt;dev,
-					ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS,
-					0);
+					ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS, 0);
 				keycode = KEY_BRIGHTNESSDOWN;
 			}
 		} else {
@@ -742,10 +757,10 @@ static int acpi_fujitsu_hotkey_add(struct acpi_device *device)
 	input-&gt;id.product = 0x06;
 	input-&gt;dev.parent = &amp;device-&gt;dev;
 	input-&gt;evbit[0] = BIT(EV_KEY);
-	set_bit(KEY_SCREENLOCK, input-&gt;keybit);
-	set_bit(KEY_MEDIA, input-&gt;keybit);
-	set_bit(KEY_EMAIL, input-&gt;keybit);
-	set_bit(KEY_SUSPEND, input-&gt;keybit);
+	set_bit(fujitsu-&gt;keycode1, input-&gt;keybit);
+	set_bit(fujitsu-&gt;keycode2, input-&gt;keybit);
+	set_bit(fujitsu-&gt;keycode3, input-&gt;keybit);
+	set_bit(fujitsu-&gt;keycode4, input-&gt;keybit);
 	set_bit(KEY_UNKNOWN, input-&gt;keybit);
 
 	error = input_register_device(input);
@@ -833,24 +848,24 @@ static void acpi_fujitsu_hotkey_notify(acpi_handle handle, u32 event,
 				    irb);
 
 			switch (irb &amp; 0x4ff) {
-			case LOCK_KEY:
-				keycode = KEY_SCREENLOCK;
+			case KEY1_CODE:
+				keycode = fujitsu-&gt;keycode1;
 				break;
-			case DISPLAY_KEY:
-				keycode = KEY_MEDIA;
+			case KEY2_CODE:
+				keycode = fujitsu-&gt;keycode2;
 				break;
-			case ENERGY_KEY:
-				keycode = KEY_EMAIL;
+			case KEY3_CODE:
+				keycode = fujitsu-&gt;keycode3;
 				break;
-			case REST_KEY:
-				keycode = KEY_SUSPEND;
+			case KEY4_CODE:
+				keycode = fujitsu-&gt;keycode4;
 				break;
 			case 0:
 				keycode = 0;
 				break;
 			default:
 				vdbg_printk(FUJLAPTOP_DBG_WARN,
-					"Unknown GIRB result [%x]\n", irb);
+					    "Unknown GIRB result [%x]\n", irb);
 				keycode = -1;
 				break;
 			}
@@ -859,12 +874,12 @@ static void acpi_fujitsu_hotkey_notify(acpi_handle handle, u32 event,
 					"Push keycode into ringbuffer [%d]\n",
 					keycode);
 				status = kfifo_put(fujitsu_hotkey-&gt;fifo,
-						(unsigned char *)&amp;keycode,
-						sizeof(keycode));
+						   (unsigned char *)&amp;keycode,
+						   sizeof(keycode));
 				if (status != sizeof(keycode)) {
 					vdbg_printk(FUJLAPTOP_DBG_WARN,
-						"Could not push keycode [0x%x]\n",
-						keycode);
+					    "Could not push keycode [0x%x]\n",
+					    keycode);
 				} else {
 					input_report_key(input, keycode, 1);
 					input_sync(input);
@@ -879,8 +894,8 @@ static void acpi_fujitsu_hotkey_notify(acpi_handle handle, u32 event,
 					input_report_key(input, keycode_r, 0);
 					input_sync(input);
 					vdbg_printk(FUJLAPTOP_DBG_TRACE,
-						    "Pop keycode from ringbuffer [%d]\n",
-						    keycode_r);
+					  "Pop keycode from ringbuffer [%d]\n",
+					  keycode_r);
 				}
 			}
 		}
@@ -943,6 +958,11 @@ static int __init fujitsu_init(void)
 	if (!fujitsu)
 		return -ENOMEM;
 	memset(fujitsu, 0, sizeof(struct fujitsu_t));
+	fujitsu-&gt;keycode1 = KEY_PROG1;
+	fujitsu-&gt;keycode2 = KEY_PROG2;
+	fujitsu-&gt;keycode3 = KEY_PROG3;
+	fujitsu-&gt;keycode4 = KEY_PROG4;
+	dmi_check_system(fujitsu_dmi_table);
 
 	result = acpi_bus_register_driver(&amp;acpi_fujitsu_driver);
 	if (result &lt; 0) {
@@ -1076,15 +1096,14 @@ MODULE_DESCRIPTION("Fujitsu laptop extras support");
 MODULE_VERSION(FUJITSU_DRIVER_VERSION);
 MODULE_LICENSE("GPL");
 
-MODULE_ALIAS
-    ("dmi:*:svnFUJITSUSIEMENS:*:pvr:rvnFUJITSU:rnFJNB1D3:*:cvrS6410:*");
-MODULE_ALIAS
-    ("dmi:*:svnFUJITSU:*:pvr:rvnFUJITSU:rnFJNB19C:*:cvrS7020:*");
+MODULE_ALIAS("dmi:*:svnFUJITSUSIEMENS:*:pvr:rvnFUJITSU:rnFJNB1D3:*:cvrS6410:*");
+MODULE_ALIAS("dmi:*:svnFUJITSU:*:pvr:rvnFUJITSU:rnFJNB19C:*:cvrS7020:*");
 
 static struct pnp_device_id pnp_ids[] = {
-	{ .id = "FUJ02bf" },
-	{ .id = "FUJ02B1" },
-	{ .id = "FUJ02E3" },
-	{ .id = "" }
+	{.id = "FUJ02bf"},
+	{.id = "FUJ02B1"},
+	{.id = "FUJ02E3"},
+	{.id = ""}
 };
+
 MODULE_DEVICE_TABLE(pnp, pnp_ids);</pre><hr><pre>commit d8196a93b1ce9a5abb410f39f9375912c9e53675
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Fri Aug 29 11:06:21 2008 +0930

    fujitsu-laptop: fix regression for P8010 in 2.6.27-rc
    
    The following patch (based on a patch from Stephen Gildea) fixes a
    regression with the LCD brightness keys on Fujitsu P8010 laptops which was
    observed with the 2.6.27-rc series (basically they stopped working due to
    changes within the fujitsu-laptop and video modules).  Please apply to
    2.6.27-rc and acpi git.
    
    A more complete solution for this laptop will be included in an upcoming
    patch, hopefully for 2.6.28.  In the meantime this restores most
    functionality for P8010 users.
    
    Signed-off-by: Stephen Gildea &lt;stepheng+fujitsu-laptop@gildea.com&gt;
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Andi Kleen &lt;ak@linux.intel.com&gt;

diff --git a/drivers/misc/fujitsu-laptop.c b/drivers/misc/fujitsu-laptop.c
index 7a1ef6c262de..3e56203e4947 100644
--- a/drivers/misc/fujitsu-laptop.c
+++ b/drivers/misc/fujitsu-laptop.c
@@ -463,6 +463,13 @@ static struct dmi_system_id __initdata fujitsu_dmi_table[] = {
 		     DMI_MATCH(DMI_PRODUCT_NAME, "LIFEBOOK S6410"),
 		     },
 	 .callback = dmi_check_cb_s6410},
+	{
+	 .ident = "FUJITSU LifeBook P8010",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "LifeBook P8010"),
+		    },
+	 .callback = dmi_check_cb_s6410},
 	{}
 };
 </pre><hr><pre>commit 20b937343e55c16e37b1a4ad2176760b4a11002c
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Wed Jun 11 10:14:56 2008 +0930

    Fujitsu-laptop update
    
    Add additional capabilities to the Fujitsu-laptop driver.
    
     * Brightness hotkey actions are sent to userspace. This can be disabled
       using a module parameter if it causes issues with models which handle
       these keys transparently in the BIOS.
    
     * Actions of additional hotkeys found on some Fujitsu models (eg: the
       suspend key and the dedicated "power on passphrase" keys) are broadcast
       to userspace.
    
     * An alternative brightness control method used by some Fujitsu models
       (for example, the S6410) is now supported, enabling software brightness
       controls on models using this method.
    
     * DMI-based module aliases are configured for the S6410 and S7020.
    
     * The current LCD brightness after booting should now be reflected in the
       standard backlight interface sysfs file (previously it was always set to
       0).  The platform brightness sysfs interface has always been fine.
    
    Thanks go to Peter Gruber who provided a significant portion of this code
    and tested various iterations of the patch on his S6410.
    
    Signed-off-by: Peter Gruber &lt;nokos@gmx.net&gt;
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Len Brown &lt;len.brown@intel.com&gt;
    Signed-off-by: Andi Kleen &lt;ak@linux.intel.com&gt;

diff --git a/MAINTAINERS b/MAINTAINERS
index 2bfde0326300..ec5c8ee30907 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1792,6 +1792,12 @@ P:	David Howells
 M:	dhowells@redhat.com
 S:	Maintained
 
+FUJITSU LAPTOP EXTRAS
+P:	Jonathan Woithe
+M:	jwoithe@physics.adelaide.edu.au
+L:	linux-acpi@vger.kernel.org
+S:	Maintained
+
 FUSE: FILESYSTEM IN USERSPACE
 P:	Miklos Szeredi
 M:	miklos@szeredi.hu
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 7fce0da86548..0551d95a749a 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -185,11 +185,22 @@ config FUJITSU_LAPTOP
 
 	    * P2xxx/P5xxx/S6xxx/S7xxx series Lifebooks
 	    * Possibly other Fujitsu laptop models
+	    * Tested with S6410 and S7020
 
-	  It adds support for LCD brightness control.
+	  It adds support for LCD brightness control and some hotkeys.
 
 	  If you have a Fujitsu laptop, say Y or M here.
 
+config FUJITSU_LAPTOP_DEBUG
+	bool "Verbose debug mode for Fujitsu Laptop Extras"
+	depends on FUJITSU_LAPTOP
+	default n
+	---help---
+	  Enables extra debug output from the fujitsu extras driver, at the
+	  expense of a slight increase in driver size.
+
+	  If you are not sure, say N here.
+
 config TC1100_WMI
 	tristate "HP Compaq TC1100 Tablet WMI Extras (EXPERIMENTAL)"
 	depends on X86 &amp;&amp; !X86_64
diff --git a/drivers/misc/fujitsu-laptop.c b/drivers/misc/fujitsu-laptop.c
index 6d14e8fe1537..7a1ef6c262de 100644
--- a/drivers/misc/fujitsu-laptop.c
+++ b/drivers/misc/fujitsu-laptop.c
@@ -1,12 +1,14 @@
 /*-*-linux-c-*-*/
 
 /*
-  Copyright (C) 2007 Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
+  Copyright (C) 2007,2008 Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
+  Copyright (C) 2008 Peter Gruber &lt;nokos@gmx.net&gt;
   Based on earlier work:
     Copyright (C) 2003 Shane Spencer &lt;shane@bogomip.com&gt;
     Adrian Yee &lt;brewt-fujitsu@brewt.org&gt;
 
-  Templated from msi-laptop.c which is copyright by its respective authors.
+  Templated from msi-laptop.c and thinkpad_acpi.c which is copyright
+  by its respective authors.
 
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
@@ -39,8 +41,17 @@
  * registers itself in the Linux backlight control subsystem and is
  * available to userspace under /sys/class/backlight/fujitsu-laptop/.
  *
- * This driver has been tested on a Fujitsu Lifebook S7020.  It should
- * work on most P-series and S-series Lifebooks, but YMMV.
+ * Hotkeys present on certain Fujitsu laptops (eg: the S6xxx series) are
+ * also supported by this driver.
+ *
+ * This driver has been tested on a Fujitsu Lifebook S6410 and S7020.  It
+ * should work on most P-series and S-series Lifebooks, but YMMV.
+ *
+ * The module parameter use_alt_lcd_levels switches between different ACPI
+ * brightness controls which are used by different Fujitsu laptops.  In most
+ * cases the correct method is automatically detected. "use_alt_lcd_levels=1"
+ * is applicable for a Fujitsu Lifebook S6410 if autodetection fails.
+ *
  */
 
 #include &lt;linux/module.h&gt;
@@ -49,30 +60,105 @@
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/dmi.h&gt;
 #include &lt;linux/backlight.h&gt;
+#include &lt;linux/input.h&gt;
+#include &lt;linux/kfifo.h&gt;
+#include &lt;linux/video_output.h&gt;
 #include &lt;linux/platform_device.h&gt;
 
-#define FUJITSU_DRIVER_VERSION "0.3"
+#define FUJITSU_DRIVER_VERSION "0.4.2"
 
 #define FUJITSU_LCD_N_LEVELS 8
 
 #define ACPI_FUJITSU_CLASS              "fujitsu"
 #define ACPI_FUJITSU_HID                "FUJ02B1"
-#define ACPI_FUJITSU_DRIVER_NAME        "Fujitsu laptop FUJ02B1 ACPI extras driver"
+#define ACPI_FUJITSU_DRIVER_NAME	"Fujitsu laptop FUJ02B1 ACPI brightness driver"
 #define ACPI_FUJITSU_DEVICE_NAME        "Fujitsu FUJ02B1"
-
+#define ACPI_FUJITSU_HOTKEY_HID 	"FUJ02E3"
+#define ACPI_FUJITSU_HOTKEY_DRIVER_NAME "Fujitsu laptop FUJ02E3 ACPI hotkeys driver"
+#define ACPI_FUJITSU_HOTKEY_DEVICE_NAME "Fujitsu FUJ02E3"
+
+#define ACPI_FUJITSU_NOTIFY_CODE1     0x80
+
+#define ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS     0x86
+#define ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS     0x87
+
+/* Hotkey details */
+#define LOCK_KEY	0x410	/* codes for the keys in the GIRB register */
+#define DISPLAY_KEY	0x411	/* keys are mapped to KEY_SCREENLOCK (the key with the key symbol) */
+#define ENERGY_KEY	0x412	/* KEY_MEDIA (the key with the laptop symbol, KEY_EMAIL (E key)) */
+#define REST_KEY	0x413	/* KEY_SUSPEND (R key) */
+
+#define MAX_HOTKEY_RINGBUFFER_SIZE 100
+#define RINGBUFFERSIZE 40
+
+/* Debugging */
+#define FUJLAPTOP_LOG	   ACPI_FUJITSU_HID ": "
+#define FUJLAPTOP_ERR	   KERN_ERR FUJLAPTOP_LOG
+#define FUJLAPTOP_NOTICE   KERN_NOTICE FUJLAPTOP_LOG
+#define FUJLAPTOP_INFO	   KERN_INFO FUJLAPTOP_LOG
+#define FUJLAPTOP_DEBUG    KERN_DEBUG FUJLAPTOP_LOG
+
+#define FUJLAPTOP_DBG_ALL	  0xffff
+#define FUJLAPTOP_DBG_ERROR	  0x0001
+#define FUJLAPTOP_DBG_WARN	  0x0002
+#define FUJLAPTOP_DBG_INFO	  0x0004
+#define FUJLAPTOP_DBG_TRACE	  0x0008
+
+#define dbg_printk(a_dbg_level, format, arg...) \
+	do { if (dbg_level &amp; a_dbg_level) \
+		printk(FUJLAPTOP_DEBUG "%s: " format, __func__ , ## arg); \
+	} while (0)
+#ifdef CONFIG_FUJITSU_LAPTOP_DEBUG
+#define vdbg_printk(a_dbg_level, format, arg...) \
+	dbg_printk(a_dbg_level, format, ## arg)
+#else
+#define vdbg_printk(a_dbg_level, format, arg...)
+#endif
+
+/* Device controlling the backlight and associated keys */
 struct fujitsu_t {
 	acpi_handle acpi_handle;
+	struct acpi_device *dev;
+	struct input_dev *input;
+	char phys[32];
 	struct backlight_device *bl_device;
 	struct platform_device *pf_device;
 
-	unsigned long fuj02b1_state;
+	unsigned int max_brightness;
 	unsigned int brightness_changed;
 	unsigned int brightness_level;
 };
 
 static struct fujitsu_t *fujitsu;
+static int use_alt_lcd_levels = -1;
+static int disable_brightness_keys = -1;
+static int disable_brightness_adjust = -1;
+
+/* Device used to access other hotkeys on the laptop */
+struct fujitsu_hotkey_t {
+	acpi_handle acpi_handle;
+	struct acpi_device *dev;
+	struct input_dev *input;
+	char phys[32];
+	struct platform_device *pf_device;
+	struct kfifo *fifo;
+	spinlock_t fifo_lock;
+
+	unsigned int irb;	/* info about the pressed buttons */
+};
 
-/* Hardware access */
+static struct fujitsu_hotkey_t *fujitsu_hotkey;
+
+static void acpi_fujitsu_hotkey_notify(acpi_handle handle, u32 event,
+				       void *data);
+
+#ifdef CONFIG_FUJITSU_LAPTOP_DEBUG
+static u32 dbg_level = 0x03;
+#endif
+
+static void acpi_fujitsu_notify(acpi_handle handle, u32 event, void *data);
+
+/* Hardware access for LCD brightness control */
 
 static int set_lcd_level(int level)
 {
@@ -81,7 +167,10 @@ static int set_lcd_level(int level)
 	struct acpi_object_list arg_list = { 1, &amp;arg0 };
 	acpi_handle handle = NULL;
 
-	if (level &lt; 0 || level &gt;= FUJITSU_LCD_N_LEVELS)
+	vdbg_printk(FUJLAPTOP_DBG_TRACE, "set lcd level via SBLL [%d]\n",
+		    level);
+
+	if (level &lt; 0 || level &gt;= fujitsu-&gt;max_brightness)
 		return -EINVAL;
 
 	if (!fujitsu)
@@ -89,7 +178,38 @@ static int set_lcd_level(int level)
 
 	status = acpi_get_handle(fujitsu-&gt;acpi_handle, "SBLL", &amp;handle);
 	if (ACPI_FAILURE(status)) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "SBLL not present\n"));
+		vdbg_printk(FUJLAPTOP_DBG_ERROR, "SBLL not present\n");
+		return -ENODEV;
+	}
+
+	arg0.integer.value = level;
+
+	status = acpi_evaluate_object(handle, NULL, &amp;arg_list, NULL);
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	return 0;
+}
+
+static int set_lcd_level_alt(int level)
+{
+	acpi_status status = AE_OK;
+	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &amp;arg0 };
+	acpi_handle handle = NULL;
+
+	vdbg_printk(FUJLAPTOP_DBG_TRACE, "set lcd level via SBL2 [%d]\n",
+		    level);
+
+	if (level &lt; 0 || level &gt;= fujitsu-&gt;max_brightness)
+		return -EINVAL;
+
+	if (!fujitsu)
+		return -EINVAL;
+
+	status = acpi_get_handle(fujitsu-&gt;acpi_handle, "SBL2", &amp;handle);
+	if (ACPI_FAILURE(status)) {
+		vdbg_printk(FUJLAPTOP_DBG_ERROR, "SBL2 not present\n");
 		return -ENODEV;
 	}
 
@@ -107,13 +227,52 @@ static int get_lcd_level(void)
 	unsigned long state = 0;
 	acpi_status status = AE_OK;
 
-	// Get the Brightness
+	vdbg_printk(FUJLAPTOP_DBG_TRACE, "get lcd level via GBLL\n");
+
 	status =
 	    acpi_evaluate_integer(fujitsu-&gt;acpi_handle, "GBLL", NULL, &amp;state);
 	if (status &lt; 0)
 		return status;
 
-	fujitsu-&gt;fuj02b1_state = state;
+	fujitsu-&gt;brightness_level = state &amp; 0x0fffffff;
+
+	if (state &amp; 0x80000000)
+		fujitsu-&gt;brightness_changed = 1;
+	else
+		fujitsu-&gt;brightness_changed = 0;
+
+	return fujitsu-&gt;brightness_level;
+}
+
+static int get_max_brightness(void)
+{
+	unsigned long state = 0;
+	acpi_status status = AE_OK;
+
+	vdbg_printk(FUJLAPTOP_DBG_TRACE, "get max lcd level via RBLL\n");
+
+	status =
+	    acpi_evaluate_integer(fujitsu-&gt;acpi_handle, "RBLL", NULL, &amp;state);
+	if (status &lt; 0)
+		return status;
+
+	fujitsu-&gt;max_brightness = state;
+
+	return fujitsu-&gt;max_brightness;
+}
+
+static int get_lcd_level_alt(void)
+{
+	unsigned long state = 0;
+	acpi_status status = AE_OK;
+
+	vdbg_printk(FUJLAPTOP_DBG_TRACE, "get lcd level via GBLS\n");
+
+	status =
+	    acpi_evaluate_integer(fujitsu-&gt;acpi_handle, "GBLS", NULL, &amp;state);
+	if (status &lt; 0)
+		return status;
+
 	fujitsu-&gt;brightness_level = state &amp; 0x0fffffff;
 
 	if (state &amp; 0x80000000)
@@ -128,12 +287,18 @@ static int get_lcd_level(void)
 
 static int bl_get_brightness(struct backlight_device *b)
 {
-	return get_lcd_level();
+	if (use_alt_lcd_levels)
+		return get_lcd_level_alt();
+	else
+		return get_lcd_level();
 }
 
 static int bl_update_status(struct backlight_device *b)
 {
-	return set_lcd_level(b-&gt;props.brightness);
+	if (use_alt_lcd_levels)
+		return set_lcd_level_alt(b-&gt;props.brightness);
+	else
+		return set_lcd_level(b-&gt;props.brightness);
 }
 
 static struct backlight_ops fujitsubl_ops = {
@@ -141,7 +306,35 @@ static struct backlight_ops fujitsubl_ops = {
 	.update_status = bl_update_status,
 };
 
-/* Platform device */
+/* Platform LCD brightness device */
+
+static ssize_t
+show_max_brightness(struct device *dev,
+		    struct device_attribute *attr, char *buf)
+{
+
+	int ret;
+
+	ret = get_max_brightness();
+	if (ret &lt; 0)
+		return ret;
+
+	return sprintf(buf, "%i\n", ret);
+}
+
+static ssize_t
+show_brightness_changed(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+
+	int ret;
+
+	ret = fujitsu-&gt;brightness_changed;
+	if (ret &lt; 0)
+		return ret;
+
+	return sprintf(buf, "%i\n", ret);
+}
 
 static ssize_t show_lcd_level(struct device *dev,
 			      struct device_attribute *attr, char *buf)
@@ -149,7 +342,10 @@ static ssize_t show_lcd_level(struct device *dev,
 
 	int ret;
 
-	ret = get_lcd_level();
+	if (use_alt_lcd_levels)
+		ret = get_lcd_level_alt();
+	else
+		ret = get_lcd_level();
 	if (ret &lt; 0)
 		return ret;
 
@@ -164,19 +360,61 @@ static ssize_t store_lcd_level(struct device *dev,
 	int level, ret;
 
 	if (sscanf(buf, "%i", &amp;level) != 1
-	    || (level &lt; 0 || level &gt;= FUJITSU_LCD_N_LEVELS))
+	    || (level &lt; 0 || level &gt;= fujitsu-&gt;max_brightness))
 		return -EINVAL;
 
-	ret = set_lcd_level(level);
+	if (use_alt_lcd_levels)
+		ret = set_lcd_level_alt(level);
+	else
+		ret = set_lcd_level(level);
+	if (ret &lt; 0)
+		return ret;
+
+	if (use_alt_lcd_levels)
+		ret = get_lcd_level_alt();
+	else
+		ret = get_lcd_level();
 	if (ret &lt; 0)
 		return ret;
 
 	return count;
 }
 
+/* Hardware access for hotkey device */
+
+static int get_irb(void)
+{
+	unsigned long state = 0;
+	acpi_status status = AE_OK;
+
+	vdbg_printk(FUJLAPTOP_DBG_TRACE, "Get irb\n");
+
+	status =
+	    acpi_evaluate_integer(fujitsu_hotkey-&gt;acpi_handle, "GIRB", NULL,
+				  &amp;state);
+	if (status &lt; 0)
+		return status;
+
+	fujitsu_hotkey-&gt;irb = state;
+
+	return fujitsu_hotkey-&gt;irb;
+}
+
+static ssize_t
+ignore_store(struct device *dev,
+	     struct device_attribute *attr, const char *buf, size_t count)
+{
+	return count;
+}
+
+static DEVICE_ATTR(max_brightness, 0444, show_max_brightness, ignore_store);
+static DEVICE_ATTR(brightness_changed, 0444, show_brightness_changed,
+		   ignore_store);
 static DEVICE_ATTR(lcd_level, 0644, show_lcd_level, store_lcd_level);
 
 static struct attribute *fujitsupf_attributes[] = {
+	&amp;dev_attr_brightness_changed.attr,
+	&amp;dev_attr_max_brightness.attr,
 	&amp;dev_attr_lcd_level.attr,
 	NULL
 };
@@ -192,14 +430,52 @@ static struct platform_driver fujitsupf_driver = {
 		   }
 };
 
-/* ACPI device */
+static int dmi_check_cb_s6410(const struct dmi_system_id *id)
+{
+	acpi_handle handle;
+	int have_blnf;
+	printk(KERN_INFO "fujitsu-laptop: Identified laptop model '%s'.\n",
+	       id-&gt;ident);
+	have_blnf = ACPI_SUCCESS
+	    (acpi_get_handle(NULL, "\\_SB.PCI0.GFX0.LCD.BLNF", &amp;handle));
+	if (use_alt_lcd_levels == -1) {
+		vdbg_printk(FUJLAPTOP_DBG_TRACE, "auto-detecting usealt\n");
+		use_alt_lcd_levels = 1;
+	}
+	if (disable_brightness_keys == -1) {
+		vdbg_printk(FUJLAPTOP_DBG_TRACE,
+			    "auto-detecting disable_keys\n");
+		disable_brightness_keys = have_blnf ? 1 : 0;
+	}
+	if (disable_brightness_adjust == -1) {
+		vdbg_printk(FUJLAPTOP_DBG_TRACE,
+			    "auto-detecting disable_adjust\n");
+		disable_brightness_adjust = have_blnf ? 0 : 1;
+	}
+	return 0;
+}
+
+static struct dmi_system_id __initdata fujitsu_dmi_table[] = {
+	{
+	 .ident = "Fujitsu Siemens",
+	 .matches = {
+		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
+		     DMI_MATCH(DMI_PRODUCT_NAME, "LIFEBOOK S6410"),
+		     },
+	 .callback = dmi_check_cb_s6410},
+	{}
+};
+
+/* ACPI device for LCD brightness control */
 
 static int acpi_fujitsu_add(struct acpi_device *device)
 {
+	acpi_status status;
+	acpi_handle handle;
 	int result = 0;
 	int state = 0;
-
-	ACPI_FUNCTION_TRACE("acpi_fujitsu_add");
+	struct input_dev *input;
+	int error;
 
 	if (!device)
 		return -EINVAL;
@@ -209,10 +485,42 @@ static int acpi_fujitsu_add(struct acpi_device *device)
 	sprintf(acpi_device_class(device), "%s", ACPI_FUJITSU_CLASS);
 	acpi_driver_data(device) = fujitsu;
 
+	status = acpi_install_notify_handler(device-&gt;handle,
+					     ACPI_DEVICE_NOTIFY,
+					     acpi_fujitsu_notify, fujitsu);
+
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR "Error installing notify handler\n");
+		error = -ENODEV;
+		goto err_stop;
+	}
+
+	fujitsu-&gt;input = input = input_allocate_device();
+	if (!input) {
+		error = -ENOMEM;
+		goto err_uninstall_notify;
+	}
+
+	snprintf(fujitsu-&gt;phys, sizeof(fujitsu-&gt;phys),
+		 "%s/video/input0", acpi_device_hid(device));
+
+	input-&gt;name = acpi_device_name(device);
+	input-&gt;phys = fujitsu-&gt;phys;
+	input-&gt;id.bustype = BUS_HOST;
+	input-&gt;id.product = 0x06;
+	input-&gt;dev.parent = &amp;device-&gt;dev;
+	input-&gt;evbit[0] = BIT(EV_KEY);
+	set_bit(KEY_BRIGHTNESSUP, input-&gt;keybit);
+	set_bit(KEY_BRIGHTNESSDOWN, input-&gt;keybit);
+	set_bit(KEY_UNKNOWN, input-&gt;keybit);
+
+	error = input_register_device(input);
+	if (error)
+		goto err_free_input_dev;
+
 	result = acpi_bus_get_power(fujitsu-&gt;acpi_handle, &amp;state);
 	if (result) {
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR,
-				  "Error reading power state\n"));
+		printk(KERN_ERR "Error reading power state\n");
 		goto end;
 	}
 
@@ -220,22 +528,373 @@ static int acpi_fujitsu_add(struct acpi_device *device)
 	       acpi_device_name(device), acpi_device_bid(device),
 	       !device-&gt;power.state ? "on" : "off");
 
-      end:
+	fujitsu-&gt;dev = device;
+
+	if (ACPI_SUCCESS
+	    (acpi_get_handle(device-&gt;handle, METHOD_NAME__INI, &amp;handle))) {
+		vdbg_printk(FUJLAPTOP_DBG_INFO, "Invoking _INI\n");
+		if (ACPI_FAILURE
+		    (acpi_evaluate_object
+		     (device-&gt;handle, METHOD_NAME__INI, NULL, NULL)))
+			printk(KERN_ERR "_INI Method failed\n");
+	}
+
+	/* do config (detect defaults) */
+	dmi_check_system(fujitsu_dmi_table);
+	use_alt_lcd_levels = use_alt_lcd_levels == 1 ? 1 : 0;
+	disable_brightness_keys = disable_brightness_keys == 1 ? 1 : 0;
+	disable_brightness_adjust = disable_brightness_adjust == 1 ? 1 : 0;
+	vdbg_printk(FUJLAPTOP_DBG_INFO,
+		    "config: [alt interface: %d], [key disable: %d], [adjust disable: %d]\n",
+		    use_alt_lcd_levels, disable_brightness_keys,
+		    disable_brightness_adjust);
+
+	if (get_max_brightness() &lt;= 0)
+		fujitsu-&gt;max_brightness = FUJITSU_LCD_N_LEVELS;
+	if (use_alt_lcd_levels)
+		get_lcd_level_alt();
+	else
+		get_lcd_level();
+
+	return result;
+
+end:
+err_free_input_dev:
+	input_free_device(input);
+err_uninstall_notify:
+	acpi_remove_notify_handler(device-&gt;handle, ACPI_DEVICE_NOTIFY,
+				   acpi_fujitsu_notify);
+err_stop:
 
 	return result;
 }
 
 static int acpi_fujitsu_remove(struct acpi_device *device, int type)
 {
-	ACPI_FUNCTION_TRACE("acpi_fujitsu_remove");
+	acpi_status status;
+	struct fujitsu_t *fujitsu = NULL;
 
 	if (!device || !acpi_driver_data(device))
 		return -EINVAL;
+
+	fujitsu = acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(fujitsu-&gt;acpi_handle,
+					    ACPI_DEVICE_NOTIFY,
+					    acpi_fujitsu_notify);
+
+	if (!device || !acpi_driver_data(device))
+		return -EINVAL;
+
 	fujitsu-&gt;acpi_handle = NULL;
 
 	return 0;
 }
 
+/* Brightness notify */
+
+static void acpi_fujitsu_notify(acpi_handle handle, u32 event, void *data)
+{
+	struct input_dev *input;
+	int keycode;
+	int oldb, newb;
+
+	input = fujitsu-&gt;input;
+
+	switch (event) {
+	case ACPI_FUJITSU_NOTIFY_CODE1:
+		keycode = 0;
+		oldb = fujitsu-&gt;brightness_level;
+		get_lcd_level();  /* the alt version always yields changed */
+		newb = fujitsu-&gt;brightness_level;
+
+		vdbg_printk(FUJLAPTOP_DBG_TRACE,
+			    "brightness button event [%i -&gt; %i (%i)]\n",
+			    oldb, newb, fujitsu-&gt;brightness_changed);
+
+		if (oldb == newb &amp;&amp; fujitsu-&gt;brightness_changed) {
+			keycode = 0;
+			if (disable_brightness_keys != 1) {
+				if (oldb == 0) {
+					acpi_bus_generate_proc_event(fujitsu-&gt;
+						dev,
+						ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS,
+						0);
+					keycode = KEY_BRIGHTNESSDOWN;
+				} else if (oldb ==
+					   (fujitsu-&gt;max_brightness) - 1) {
+					acpi_bus_generate_proc_event(fujitsu-&gt;
+						dev,
+						ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS,
+						0);
+					keycode = KEY_BRIGHTNESSUP;
+				}
+			}
+		} else if (oldb &lt; newb) {
+			if (disable_brightness_adjust != 1) {
+				if (use_alt_lcd_levels)
+					set_lcd_level_alt(newb);
+				else
+					set_lcd_level(newb);
+			}
+			if (disable_brightness_keys != 1) {
+				acpi_bus_generate_proc_event(fujitsu-&gt;dev,
+					ACPI_VIDEO_NOTIFY_INC_BRIGHTNESS,
+					0);
+				keycode = KEY_BRIGHTNESSUP;
+			}
+		} else if (oldb &gt; newb) {
+			if (disable_brightness_adjust != 1) {
+				if (use_alt_lcd_levels)
+					set_lcd_level_alt(newb);
+				else
+					set_lcd_level(newb);
+			}
+			if (disable_brightness_keys != 1) {
+				acpi_bus_generate_proc_event(fujitsu-&gt;dev,
+					ACPI_VIDEO_NOTIFY_DEC_BRIGHTNESS,
+					0);
+				keycode = KEY_BRIGHTNESSDOWN;
+			}
+		} else {
+			keycode = KEY_UNKNOWN;
+		}
+		break;
+	default:
+		keycode = KEY_UNKNOWN;
+		vdbg_printk(FUJLAPTOP_DBG_WARN,
+			    "unsupported event [0x%x]\n", event);
+		break;
+	}
+
+	if (keycode != 0) {
+		input_report_key(input, keycode, 1);
+		input_sync(input);
+		input_report_key(input, keycode, 0);
+		input_sync(input);
+	}
+
+	return;
+}
+
+/* ACPI device for hotkey handling */
+
+static int acpi_fujitsu_hotkey_add(struct acpi_device *device)
+{
+	acpi_status status;
+	acpi_handle handle;
+	int result = 0;
+	int state = 0;
+	struct input_dev *input;
+	int error;
+	int i;
+
+	if (!device)
+		return -EINVAL;
+
+	fujitsu_hotkey-&gt;acpi_handle = device-&gt;handle;
+	sprintf(acpi_device_name(device), "%s",
+		ACPI_FUJITSU_HOTKEY_DEVICE_NAME);
+	sprintf(acpi_device_class(device), "%s", ACPI_FUJITSU_CLASS);
+	acpi_driver_data(device) = fujitsu_hotkey;
+
+	status = acpi_install_notify_handler(device-&gt;handle,
+					     ACPI_DEVICE_NOTIFY,
+					     acpi_fujitsu_hotkey_notify,
+					     fujitsu_hotkey);
+
+	if (ACPI_FAILURE(status)) {
+		printk(KERN_ERR "Error installing notify handler\n");
+		error = -ENODEV;
+		goto err_stop;
+	}
+
+	/* kfifo */
+	spin_lock_init(&amp;fujitsu_hotkey-&gt;fifo_lock);
+	fujitsu_hotkey-&gt;fifo =
+	    kfifo_alloc(RINGBUFFERSIZE * sizeof(int), GFP_KERNEL,
+			&amp;fujitsu_hotkey-&gt;fifo_lock);
+	if (IS_ERR(fujitsu_hotkey-&gt;fifo)) {
+		printk(KERN_ERR "kfifo_alloc failed\n");
+		error = PTR_ERR(fujitsu_hotkey-&gt;fifo);
+		goto err_stop;
+	}
+
+	fujitsu_hotkey-&gt;input = input = input_allocate_device();
+	if (!input) {
+		error = -ENOMEM;
+		goto err_uninstall_notify;
+	}
+
+	snprintf(fujitsu_hotkey-&gt;phys, sizeof(fujitsu_hotkey-&gt;phys),
+		 "%s/video/input0", acpi_device_hid(device));
+
+	input-&gt;name = acpi_device_name(device);
+	input-&gt;phys = fujitsu_hotkey-&gt;phys;
+	input-&gt;id.bustype = BUS_HOST;
+	input-&gt;id.product = 0x06;
+	input-&gt;dev.parent = &amp;device-&gt;dev;
+	input-&gt;evbit[0] = BIT(EV_KEY);
+	set_bit(KEY_SCREENLOCK, input-&gt;keybit);
+	set_bit(KEY_MEDIA, input-&gt;keybit);
+	set_bit(KEY_EMAIL, input-&gt;keybit);
+	set_bit(KEY_SUSPEND, input-&gt;keybit);
+	set_bit(KEY_UNKNOWN, input-&gt;keybit);
+
+	error = input_register_device(input);
+	if (error)
+		goto err_free_input_dev;
+
+	result = acpi_bus_get_power(fujitsu_hotkey-&gt;acpi_handle, &amp;state);
+	if (result) {
+		printk(KERN_ERR "Error reading power state\n");
+		goto end;
+	}
+
+	printk(KERN_INFO PREFIX "%s [%s] (%s)\n",
+	       acpi_device_name(device), acpi_device_bid(device),
+	       !device-&gt;power.state ? "on" : "off");
+
+	fujitsu_hotkey-&gt;dev = device;
+
+	if (ACPI_SUCCESS
+	    (acpi_get_handle(device-&gt;handle, METHOD_NAME__INI, &amp;handle))) {
+		vdbg_printk(FUJLAPTOP_DBG_INFO, "Invoking _INI\n");
+		if (ACPI_FAILURE
+		    (acpi_evaluate_object
+		     (device-&gt;handle, METHOD_NAME__INI, NULL, NULL)))
+			printk(KERN_ERR "_INI Method failed\n");
+	}
+
+	i = 0;			/* Discard hotkey ringbuffer */
+	while (get_irb() != 0 &amp;&amp; (i++) &lt; MAX_HOTKEY_RINGBUFFER_SIZE) ;
+	vdbg_printk(FUJLAPTOP_DBG_INFO, "Discarded %i ringbuffer entries\n", i);
+
+	return result;
+
+end:
+err_free_input_dev:
+	input_free_device(input);
+err_uninstall_notify:
+	acpi_remove_notify_handler(device-&gt;handle, ACPI_DEVICE_NOTIFY,
+				   acpi_fujitsu_hotkey_notify);
+	kfifo_free(fujitsu_hotkey-&gt;fifo);
+err_stop:
+
+	return result;
+}
+
+static int acpi_fujitsu_hotkey_remove(struct acpi_device *device, int type)
+{
+	acpi_status status;
+	struct fujitsu_hotkey_t *fujitsu_hotkey = NULL;
+
+	if (!device || !acpi_driver_data(device))
+		return -EINVAL;
+
+	fujitsu_hotkey = acpi_driver_data(device);
+
+	status = acpi_remove_notify_handler(fujitsu_hotkey-&gt;acpi_handle,
+					    ACPI_DEVICE_NOTIFY,
+					    acpi_fujitsu_hotkey_notify);
+
+	fujitsu_hotkey-&gt;acpi_handle = NULL;
+
+	kfifo_free(fujitsu_hotkey-&gt;fifo);
+
+	return 0;
+}
+
+static void acpi_fujitsu_hotkey_notify(acpi_handle handle, u32 event,
+				       void *data)
+{
+	struct input_dev *input;
+	int keycode, keycode_r;
+	unsigned int irb = 1;
+	int i, status;
+
+	input = fujitsu_hotkey-&gt;input;
+
+	vdbg_printk(FUJLAPTOP_DBG_TRACE, "Hotkey event\n");
+
+	switch (event) {
+	case ACPI_FUJITSU_NOTIFY_CODE1:
+		i = 0;
+		while ((irb = get_irb()) != 0
+		       &amp;&amp; (i++) &lt; MAX_HOTKEY_RINGBUFFER_SIZE) {
+			vdbg_printk(FUJLAPTOP_DBG_TRACE, "GIRB result [%x]\n",
+				    irb);
+
+			switch (irb &amp; 0x4ff) {
+			case LOCK_KEY:
+				keycode = KEY_SCREENLOCK;
+				break;
+			case DISPLAY_KEY:
+				keycode = KEY_MEDIA;
+				break;
+			case ENERGY_KEY:
+				keycode = KEY_EMAIL;
+				break;
+			case REST_KEY:
+				keycode = KEY_SUSPEND;
+				break;
+			case 0:
+				keycode = 0;
+				break;
+			default:
+				vdbg_printk(FUJLAPTOP_DBG_WARN,
+					"Unknown GIRB result [%x]\n", irb);
+				keycode = -1;
+				break;
+			}
+			if (keycode &gt; 0) {
+				vdbg_printk(FUJLAPTOP_DBG_TRACE,
+					"Push keycode into ringbuffer [%d]\n",
+					keycode);
+				status = kfifo_put(fujitsu_hotkey-&gt;fifo,
+						(unsigned char *)&amp;keycode,
+						sizeof(keycode));
+				if (status != sizeof(keycode)) {
+					vdbg_printk(FUJLAPTOP_DBG_WARN,
+						"Could not push keycode [0x%x]\n",
+						keycode);
+				} else {
+					input_report_key(input, keycode, 1);
+					input_sync(input);
+				}
+			} else if (keycode == 0) {
+				while ((status =
+					kfifo_get
+					(fujitsu_hotkey-&gt;fifo, (unsigned char *)
+					 &amp;keycode_r,
+					 sizeof
+					 (keycode_r))) == sizeof(keycode_r)) {
+					input_report_key(input, keycode_r, 0);
+					input_sync(input);
+					vdbg_printk(FUJLAPTOP_DBG_TRACE,
+						    "Pop keycode from ringbuffer [%d]\n",
+						    keycode_r);
+				}
+			}
+		}
+
+		break;
+	default:
+		keycode = KEY_UNKNOWN;
+		vdbg_printk(FUJLAPTOP_DBG_WARN,
+			    "Unsupported event [0x%x]\n", event);
+		input_report_key(input, keycode, 1);
+		input_sync(input);
+		input_report_key(input, keycode, 0);
+		input_sync(input);
+		break;
+	}
+
+	return;
+}
+
+/* Initialization */
+
 static const struct acpi_device_id fujitsu_device_ids[] = {
 	{ACPI_FUJITSU_HID, 0},
 	{"", 0},
@@ -251,11 +910,24 @@ static struct acpi_driver acpi_fujitsu_driver = {
 		},
 };
 
-/* Initialization */
+static const struct acpi_device_id fujitsu_hotkey_device_ids[] = {
+	{ACPI_FUJITSU_HOTKEY_HID, 0},
+	{"", 0},
+};
+
+static struct acpi_driver acpi_fujitsu_hotkey_driver = {
+	.name = ACPI_FUJITSU_HOTKEY_DRIVER_NAME,
+	.class = ACPI_FUJITSU_CLASS,
+	.ids = fujitsu_hotkey_device_ids,
+	.ops = {
+		.add = acpi_fujitsu_hotkey_add,
+		.remove = acpi_fujitsu_hotkey_remove,
+		},
+};
 
 static int __init fujitsu_init(void)
 {
-	int ret, result;
+	int ret, result, max_brightness;
 
 	if (acpi_disabled)
 		return -ENODEV;
@@ -271,19 +943,6 @@ static int __init fujitsu_init(void)
 		goto fail_acpi;
 	}
 
-	/* Register backlight stuff */
-
-	fujitsu-&gt;bl_device =
-	    backlight_device_register("fujitsu-laptop", NULL, NULL,
-				      &amp;fujitsubl_ops);
-	if (IS_ERR(fujitsu-&gt;bl_device))
-		return PTR_ERR(fujitsu-&gt;bl_device);
-
-	fujitsu-&gt;bl_device-&gt;props.max_brightness = FUJITSU_LCD_N_LEVELS - 1;
-	ret = platform_driver_register(&amp;fujitsupf_driver);
-	if (ret)
-		goto fail_backlight;
-
 	/* Register platform stuff */
 
 	fujitsu-&gt;pf_device = platform_device_alloc("fujitsu-laptop", -1);
@@ -302,28 +961,68 @@ static int __init fujitsu_init(void)
 	if (ret)
 		goto fail_platform_device2;
 
+	/* Register backlight stuff */
+
+	fujitsu-&gt;bl_device =
+	    backlight_device_register("fujitsu-laptop", NULL, NULL,
+				      &amp;fujitsubl_ops);
+	if (IS_ERR(fujitsu-&gt;bl_device))
+		return PTR_ERR(fujitsu-&gt;bl_device);
+
+	max_brightness = fujitsu-&gt;max_brightness;
+
+	fujitsu-&gt;bl_device-&gt;props.max_brightness = max_brightness - 1;
+	fujitsu-&gt;bl_device-&gt;props.brightness = fujitsu-&gt;brightness_level;
+
+	ret = platform_driver_register(&amp;fujitsupf_driver);
+	if (ret)
+		goto fail_backlight;
+
+	/* Register hotkey driver */
+
+	fujitsu_hotkey = kmalloc(sizeof(struct fujitsu_hotkey_t), GFP_KERNEL);
+	if (!fujitsu_hotkey) {
+		ret = -ENOMEM;
+		goto fail_hotkey;
+	}
+	memset(fujitsu_hotkey, 0, sizeof(struct fujitsu_hotkey_t));
+
+	result = acpi_bus_register_driver(&amp;acpi_fujitsu_hotkey_driver);
+	if (result &lt; 0) {
+		ret = -ENODEV;
+		goto fail_hotkey1;
+	}
+
 	printk(KERN_INFO "fujitsu-laptop: driver " FUJITSU_DRIVER_VERSION
 	       " successfully loaded.\n");
 
 	return 0;
 
-      fail_platform_device2:
+fail_hotkey1:
 
-	platform_device_del(fujitsu-&gt;pf_device);
-
-      fail_platform_device1:
-
-	platform_device_put(fujitsu-&gt;pf_device);
+	kfree(fujitsu_hotkey);
 
-      fail_platform_driver:
+fail_hotkey:
 
 	platform_driver_unregister(&amp;fujitsupf_driver);
 
-      fail_backlight:
+fail_backlight:
 
 	backlight_device_unregister(fujitsu-&gt;bl_device);
 
-      fail_acpi:
+fail_platform_device2:
+
+	platform_device_del(fujitsu-&gt;pf_device);
+
+fail_platform_device1:
+
+	platform_device_put(fujitsu-&gt;pf_device);
+
+fail_platform_driver:
+
+	acpi_bus_unregister_driver(&amp;acpi_fujitsu_driver);
+
+fail_acpi:
 
 	kfree(fujitsu);
 
@@ -342,19 +1041,43 @@ static void __exit fujitsu_cleanup(void)
 
 	kfree(fujitsu);
 
+	acpi_bus_unregister_driver(&amp;acpi_fujitsu_hotkey_driver);
+
+	kfree(fujitsu_hotkey);
+
 	printk(KERN_INFO "fujitsu-laptop: driver unloaded.\n");
 }
 
 module_init(fujitsu_init);
 module_exit(fujitsu_cleanup);
 
-MODULE_AUTHOR("Jonathan Woithe");
+module_param(use_alt_lcd_levels, uint, 0644);
+MODULE_PARM_DESC(use_alt_lcd_levels,
+		 "Use alternative interface for lcd_levels (needed for Lifebook s6410).");
+module_param(disable_brightness_keys, uint, 0644);
+MODULE_PARM_DESC(disable_brightness_keys,
+		 "Disable brightness keys (eg. if they are already handled by the generic ACPI_VIDEO device).");
+module_param(disable_brightness_adjust, uint, 0644);
+MODULE_PARM_DESC(disable_brightness_adjust, "Disable brightness adjustment .");
+#ifdef CONFIG_FUJITSU_LAPTOP_DEBUG
+module_param_named(debug, dbg_level, uint, 0644);
+MODULE_PARM_DESC(debug, "Sets debug level bit-mask");
+#endif
+
+MODULE_AUTHOR("Jonathan Woithe, Peter Gruber");
 MODULE_DESCRIPTION("Fujitsu laptop extras support");
 MODULE_VERSION(FUJITSU_DRIVER_VERSION);
 MODULE_LICENSE("GPL");
 
+MODULE_ALIAS
+    ("dmi:*:svnFUJITSUSIEMENS:*:pvr:rvnFUJITSU:rnFJNB1D3:*:cvrS6410:*");
+MODULE_ALIAS
+    ("dmi:*:svnFUJITSU:*:pvr:rvnFUJITSU:rnFJNB19C:*:cvrS7020:*");
+
 static struct pnp_device_id pnp_ids[] = {
 	{ .id = "FUJ02bf" },
+	{ .id = "FUJ02B1" },
+	{ .id = "FUJ02E3" },
 	{ .id = "" }
 };
 MODULE_DEVICE_TABLE(pnp, pnp_ids);</pre><hr><pre>commit aa27a44395c3d35bc16e52f1e709e0fb2a3709e4
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Fri Feb 8 12:44:17 2008 +0100

    [ALSA] hda-codec - remove duplicate controls in alc268 test mixer
    
    I've just noticed that there are a handful of duplicate controls in the
    ALC268 test model mixer.  This patch (against alsa-driver 1.0.16) removes
    them.
    
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index 85ea3f82de19..e4a7c50e9f73 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -9840,11 +9840,6 @@ static struct hda_input_mux alc268_capture_source = {
 
 #ifdef CONFIG_SND_DEBUG
 static struct snd_kcontrol_new alc268_test_mixer[] = {
-	HDA_CODEC_VOLUME("Front Playback Volume", 0x2, 0x0, HDA_OUTPUT),
-	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
-	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x3, 0x0, HDA_OUTPUT),
-	HDA_CODEC_MUTE("Headphone Playback Switch", 0x15, 0x0, HDA_OUTPUT),
-
 	/* Volume widgets */
 	HDA_CODEC_VOLUME("LOUT1 Playback Volume", 0x02, 0x0, HDA_OUTPUT),
 	HDA_CODEC_VOLUME("LOUT2 Playback Volume", 0x03, 0x0, HDA_OUTPUT),</pre><hr><pre>commit 86c53bd26b431767438c65f89863471be177f0f7
Author: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
Date:   Tue Jan 8 12:33:19 2008 +0100

    [ALSA] hda-codec - Add test model for ALC268
    
    This implements a test model for the ALC268.  It depends on the feature
    added by alc260-test-eapd-0.2.diff.  This patch also adds a mention of
    the ALC260 test model to ALSA-Configuration.txt since this seems to have
    been missed.
    
    Signed-off-by: Jonathan Woithe &lt;jwoithe@physics.adelaide.edu.au&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;
    Signed-off-by: Jaroslav Kysela &lt;perex@perex.cz&gt;

diff --git a/Documentation/sound/alsa/ALSA-Configuration.txt b/Documentation/sound/alsa/ALSA-Configuration.txt
index afdb6ffeae55..22aee1a5dd6e 100644
--- a/Documentation/sound/alsa/ALSA-Configuration.txt
+++ b/Documentation/sound/alsa/ALSA-Configuration.txt
@@ -801,6 +801,9 @@ Prior to version 0.9.0rc4 options had a 'snd_' prefix. This was removed.
 	  will		Will laptops (PB V7900)
 	  replacer	Replacer 672V
 	  basic		fixed pin assignment (old default model)
+	  test		for testing/debugging purpose, almost all controls can
+			adjusted.  Appearing only when compiled with
+			$CONFIG_SND_DEBUG=y
 	  auto		auto-config reading BIOS (default)
 
 	ALC262
@@ -821,6 +824,9 @@ Prior to version 0.9.0rc4 options had a 'snd_' prefix. This was removed.
 	  3stack	3-stack model
 	  toshiba	Toshiba A205
 	  acer		Acer laptops
+	  test		for testing/debugging purpose, almost all controls can
+			adjusted.  Appearing only when compiled with
+			$CONFIG_SND_DEBUG=y
 	  auto		auto-config reading BIOS (default)
 
 	ALC662
diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c
index 0a64d24e7fda..1b2ad52bc908 100644
--- a/sound/pci/hda/patch_realtek.c
+++ b/sound/pci/hda/patch_realtek.c
@@ -106,6 +106,9 @@ enum {
 	ALC268_3ST,
 	ALC268_TOSHIBA,
 	ALC268_ACER,
+#ifdef CONFIG_SND_DEBUG
+	ALC268_TEST,
+#endif
 	ALC268_AUTO,
 	ALC268_MODEL_LAST /* last tag */
 };
@@ -9366,6 +9369,60 @@ static struct hda_input_mux alc268_capture_source = {
 	},
 };
 
+#ifdef CONFIG_SND_DEBUG
+static struct snd_kcontrol_new alc268_test_mixer[] = {
+	HDA_CODEC_VOLUME("Front Playback Volume", 0x2, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Front Playback Switch", 0x14, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("Headphone Playback Volume", 0x3, 0x0, HDA_OUTPUT),
+	HDA_CODEC_MUTE("Headphone Playback Switch", 0x15, 0x0, HDA_OUTPUT),
+
+	/* Volume widgets */
+	HDA_CODEC_VOLUME("LOUT1 Playback Volume", 0x02, 0x0, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("LOUT2 Playback Volume", 0x03, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE_MONO("Mono sum Playback Switch", 0x0e, 1, 2, HDA_INPUT),
+	HDA_BIND_MUTE("LINE-OUT sum Playback Switch", 0x0f, 2, HDA_INPUT),
+	HDA_BIND_MUTE("HP-OUT sum Playback Switch", 0x10, 2, HDA_INPUT),
+	HDA_BIND_MUTE("LINE-OUT Playback Switch", 0x14, 2, HDA_OUTPUT),
+	HDA_BIND_MUTE("HP-OUT Playback Switch", 0x15, 2, HDA_OUTPUT),
+	HDA_BIND_MUTE("Mono Playback Switch", 0x16, 2, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("MIC1 Capture Volume", 0x18, 0x0, HDA_INPUT),
+	HDA_BIND_MUTE("MIC1 Capture Switch", 0x18, 2, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("MIC2 Capture Volume", 0x19, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("LINE1 Capture Volume", 0x1a, 0x0, HDA_INPUT),
+	HDA_BIND_MUTE("LINE1 Capture Switch", 0x1a, 2, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("PCBEEP Playback Volume", 0x1d, 0x0, HDA_INPUT),
+	HDA_CODEC_VOLUME("PCM-IN1 Capture Volume", 0x23, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("PCM-IN1 Capture Switch", 0x23, 2, HDA_OUTPUT),
+	HDA_CODEC_VOLUME("PCM-IN2 Capture Volume", 0x24, 0x0, HDA_OUTPUT),
+	HDA_BIND_MUTE("PCM-IN2 Capture Switch", 0x24, 2, HDA_OUTPUT),
+
+	/* Modes for retasking pin widgets */
+	ALC_PIN_MODE("LINE-OUT pin mode", 0x14, ALC_PIN_DIR_INOUT),
+	ALC_PIN_MODE("HP-OUT pin mode", 0x15, ALC_PIN_DIR_INOUT),
+	ALC_PIN_MODE("MIC1 pin mode", 0x18, ALC_PIN_DIR_INOUT),
+	ALC_PIN_MODE("LINE1 pin mode", 0x1a, ALC_PIN_DIR_INOUT),
+
+	/* Controls for GPIO pins, assuming they are configured as outputs */
+	ALC_GPIO_DATA_SWITCH("GPIO pin 0", 0x01, 0x01),
+	ALC_GPIO_DATA_SWITCH("GPIO pin 1", 0x01, 0x02),
+	ALC_GPIO_DATA_SWITCH("GPIO pin 2", 0x01, 0x04),
+	ALC_GPIO_DATA_SWITCH("GPIO pin 3", 0x01, 0x08),
+
+	/* Switches to allow the digital SPDIF output pin to be enabled.
+	 * The ALC268 does not have an SPDIF input.
+	 */
+	ALC_SPDIF_CTRL_SWITCH("SPDIF Playback Switch", 0x06, 0x01),
+
+	/* A switch allowing EAPD to be enabled.  Some laptops seem to use
+	 * this output to turn on an external amplifier.
+	 */
+	ALC_EAPD_CTRL_SWITCH("LINE-OUT EAPD Enable Switch", 0x0f, 0x02),
+	ALC_EAPD_CTRL_SWITCH("HP-OUT EAPD Enable Switch", 0x10, 0x02),
+
+	{ } /* end */
+};
+#endif
+
 /* create input playback/capture controls for the given pin */
 static int alc268_new_analog_output(struct alc_spec *spec, hda_nid_t nid,
 				    const char *ctlname, int idx)
@@ -9578,6 +9635,9 @@ static const char *alc268_models[ALC268_MODEL_LAST] = {
 	[ALC268_3ST]		= "3stack",
 	[ALC268_TOSHIBA]	= "toshiba",
 	[ALC268_ACER]		= "acer",
+#ifdef CONFIG_SND_DEBUG
+	[ALC268_TEST]		= "test",
+#endif
 	[ALC268_AUTO]		= "auto",
 };
 
@@ -9636,6 +9696,22 @@ static struct alc_config_preset alc268_presets[] = {
 		.unsol_event = alc268_acer_unsol_event,
 		.init_hook = alc268_acer_init_hook,
 	},
+#ifdef CONFIG_SND_DEBUG
+	[ALC268_TEST] = {
+		.mixers = { alc268_test_mixer, alc268_capture_mixer },
+		.init_verbs = { alc268_base_init_verbs, alc268_eapd_verbs,
+				alc268_volume_init_verbs },
+		.num_dacs = ARRAY_SIZE(alc268_dac_nids),
+		.dac_nids = alc268_dac_nids,
+		.num_adc_nids = ARRAY_SIZE(alc268_adc_nids_alt),
+		.adc_nids = alc268_adc_nids_alt,
+		.hp_nid = 0x03,
+		.dig_out_nid = ALC268_DIGOUT_NID,
+		.num_channel_mode = ARRAY_SIZE(alc268_modes),
+		.channel_mode = alc268_modes,
+		.input_mux = &amp;alc268_capture_source,
+	},
+#endif
 };
 
 static int patch_alc268(struct hda_codec *codec)</pre>
    <div class="pagination">
        <span>[1]</span><a href='26_2.html'>2</a><a href='26_3.html'>3</a><a href='26_2.html'>Next&gt;&gt;</a>
    <div>
</body>
