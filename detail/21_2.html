<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Shenzhen University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Shenzhen University</h1>
    <div class="pagination">
        <a href='21.html'>&lt;&lt;Prev</a><a href='21.html'>1</a><span>[2]</span><a href='21_3.html'>3</a><a href='21_4.html'>4</a><a href='21_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 75382a2dca0e9e9e57e88b479cf537549461a934
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Apr 28 23:15:56 2022 -0700

    tools/vm/page_owner_sort.c: support for multi-value selection in single argument
    
    When viewing page owner information, we may want to select blocks whose
    PID/TGID/TASK_COMM_NAME appears in a user-specified list for data analysis
    and aggregation.  But currently page_owner_sort only supports selecting
    blocks associated with only one specified PID/TGID/TASK_COMM_NAME.
    
    Therefore, following adjustments are made to fix the problem:
    
    1. Enhance selecting function to support the selection of multiple
       PIDs/TGIDs/TASK_COMM_NAMEs.
    
    The enhanced usages are as follows:
    
    --pid &lt;pidlist&gt;         Select by pid. This selects the blocks whose PID
                            numbers appear in &lt;pidlist&gt;.
    --tgid &lt;tgidlist&gt;       Select by tgid. This selects the blocks whose
                            TGID numbers appear in &lt;tgidlist&gt;.
    --name &lt;cmdlist&gt;        Select by task command name. This selects the
                            blocks whose task command name appear in &lt;cmdlist&gt;.
    
    Where &lt;pidlist&gt;, &lt;tgidlist&gt;, &lt;cmdlist&gt; are single arguments in the form of
    a comma-separated list,which offers a way to specify individual selecting
    rules.
    
    For example, if you want to select blocks whose tgids are 1, 2 or 3, you
    have to use 4 commands as follows:
    
            ./page_owner_sort &lt;input&gt; &lt;output1&gt; --tgid=1
            ./page_owner_sort &lt;input&gt; &lt;output2&gt; --tgid=2
            ./page_owner_sort &lt;input&gt; &lt;output3&gt; --tgid=3
            cat &lt;output1&gt; &lt;output2&gt; &lt;output3&gt; &gt; &lt;output&gt;
    
    With this patch, you can use only 1 command to obtain the same result as
    above:
    
            ./page_owner_sort &lt;input&gt; &lt;output1&gt; --tgid=1,2,3
    
    2. Update explanations of --pid, --tgid and --name in the function
       usage() and the document(Documents/vm/page_owner.rst).
    
    This work is coauthored by
            Yixuan Cao
            Shenghong Han
            Yinan Zhang
            Chongxi Zhao
            Yuhong Feng
            Yongqiang Liu
    
    Link: https://lkml.kernel.org/r/20220401024856.767-2-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Shenghong Han &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Yongqiang Liu &lt;liuyongqiang13@huawei.com&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Cc: Haowen Bai &lt;baihaowen@meizu.com&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index 7e0c3f574e78..3102f91d635c 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -129,7 +129,6 @@ Usage
 				Specify culling rules.Culling syntax is key[,key[,...]].Choose a
 				multi-letter key from the **STANDARD FORMAT SPECIFIERS** section.
 
-
 		&lt;rules&gt; is a single argument in the form of a comma-separated list,
 		which offers a way to specify individual culling rules.  The recognized
 		keywords are described in the **STANDARD FORMAT SPECIFIERS** section below.
@@ -137,7 +136,6 @@ Usage
 		the STANDARD SORT KEYS section below. Mixed use of abbreviated and
 		complete-form of keys is allowed.
 
-
 		Examples:
 				./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=stacktrace
 				./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=st,pid,name
@@ -147,9 +145,21 @@ Usage
 		-f		Filter out the information of blocks whose memory has been released.
 
 	Select:
-		--pid &lt;PID&gt;		Select by pid.
-		--tgid &lt;TGID&gt;		Select by tgid.
-		--name &lt;command&gt;	Select by task command name.
+		--pid &lt;pidlist&gt;		Select by pid. This selects the blocks whose process ID
+					numbers appear in &lt;pidlist&gt;.
+		--tgid &lt;tgidlist&gt;	Select by tgid. This selects the blocks whose thread
+					group ID numbers appear in &lt;tgidlist&gt;.
+		--name &lt;cmdlist&gt;	Select by task command name. This selects the blocks whose
+					task command name appear in &lt;cmdlist&gt;.
+
+		&lt;pidlist&gt;, &lt;tgidlist&gt;, &lt;cmdlist&gt; are single arguments in the form of a comma-separated list,
+		which offers a way to specify individual selecting rules.
+
+
+		Examples:
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --pid=1
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --tgid=1,2,3
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --name name1,name2
 
 STANDARD FORMAT SPECIFIERS
 ==========================
diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index 6771003ed5f1..16fb034c6a4e 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -54,9 +54,12 @@ enum CULL_BIT {
 	CULL_STACKTRACE = 1&lt;&lt;5
 };
 struct filter_condition {
-	pid_t tgid;
-	pid_t pid;
-	char comm[TASK_COMM_LEN];
+	pid_t *tgids;
+	int tgids_size;
+	pid_t *pids;
+	int pids_size;
+	char **comms;
+	int comms_size;
 };
 static struct filter_condition fc;
 static regex_t order_pattern;
@@ -149,7 +152,6 @@ static int compare_free_ts(const void *p1, const void *p2)
 	return l1-&gt;free_ts_nsec &lt; l2-&gt;free_ts_nsec ? -1 : 1;
 }
 
-
 static int compare_release(const void *p1, const void *p2)
 {
 	const struct block_list *l1 = p1, *l2 = p2;
@@ -161,7 +163,6 @@ static int compare_release(const void *p1, const void *p2)
 	return l1-&gt;free_ts_nsec ? 1 : -1;
 }
 
-
 static int compare_cull_condition(const void *p1, const void *p2)
 {
 	if (cull == 0)
@@ -344,22 +345,40 @@ static char *get_comm(char *buf)
 	return comm_str;
 }
 
+static bool match_num_list(int num, int *list, int list_size)
+{
+	for (int i = 0; i &lt; list_size; ++i)
+		if (list[i] == num)
+			return true;
+	return false;
+}
+
+static bool match_str_list(const char *str, char **list, int list_size)
+{
+	for (int i = 0; i &lt; list_size; ++i)
+		if (!strcmp(list[i], str))
+			return true;
+	return false;
+}
+
 static bool is_need(char *buf)
 {
 		if ((filter &amp; FILTER_UNRELEASE) &amp;&amp; get_free_ts_nsec(buf) != 0)
 			return false;
-		if ((filter &amp; FILTER_PID) &amp;&amp; get_pid(buf) != fc.pid)
+		if ((filter &amp; FILTER_PID) &amp;&amp; !match_num_list(get_pid(buf), fc.pids, fc.pids_size))
 			return false;
-		if ((filter &amp; FILTER_TGID) &amp;&amp; get_tgid(buf) != fc.tgid)
+		if ((filter &amp; FILTER_TGID) &amp;&amp;
+			!match_num_list(get_tgid(buf), fc.tgids, fc.tgids_size))
 			return false;
 
 		char *comm = get_comm(buf);
 
 		if ((filter &amp; FILTER_COMM) &amp;&amp;
-		strncmp(comm, fc.comm, TASK_COMM_LEN) != 0) {
+		!match_str_list(comm, fc.comms, fc.comms_size)) {
 			free(comm);
 			return false;
 		}
+		free(comm);
 		return true;
 }
 
@@ -428,6 +447,27 @@ static bool parse_cull_args(const char *arg_str)
 	return true;
 }
 
+static int *parse_nums_list(char *arg_str, int *list_size)
+{
+	int size = 0;
+	char **args = explode(',', arg_str, &amp;size);
+	int *list = calloc(size, sizeof(int));
+
+	errno = 0;
+	for (int i = 0; i &lt; size; ++i) {
+		char *endptr = NULL;
+
+		list[i] = strtol(args[i], &amp;endptr, 10);
+		if (errno != 0 || endptr == args[i] || *endptr != '\0') {
+			free(list);
+			return NULL;
+		}
+	}
+	*list_size = size;
+	free_explode(args, size);
+	return list;
+}
+
 #define BUF_SIZE	(128 * 1024)
 
 static void usage(void)
@@ -442,9 +482,9 @@ static void usage(void)
 		"-a\t\tSort by memory allocate time.\n"
 		"-r\t\tSort by memory release time.\n"
 		"-f\t\tFilter out the information of blocks whose memory has been released.\n"
-		"--pid &lt;PID&gt;\tSelect by pid. This selects the information of blocks whose process ID number equals to &lt;PID&gt;.\n"
-		"--tgid &lt;TGID&gt;\tSelect by tgid. This selects the information of blocks whose Thread Group ID number equals to &lt;TGID&gt;.\n"
-		"--name &lt;command&gt;\n\t\tSelect by command name. This selects the information of blocks whose command name identical to &lt;command&gt;.\n"
+		"--pid &lt;pidlist&gt;\tSelect by pid. This selects the information of blocks whose process ID numbers appear in &lt;pidlist&gt;.\n"
+		"--tgid &lt;tgidlist&gt;\tSelect by tgid. This selects the information of blocks whose Thread Group ID numbers appear in &lt;tgidlist&gt;.\n"
+		"--name &lt;cmdlist&gt;\n\t\tSelect by command name. This selects the information of blocks whose command name appears in &lt;cmdlist&gt;.\n"
 		"--cull &lt;rules&gt;\tCull by user-defined rules. &lt;rules&gt; is a single argument in the form of a comma-separated list with some common fields predefined\n"
 	);
 }
@@ -453,7 +493,7 @@ int main(int argc, char **argv)
 {
 	int (*cmp)(const void *, const void *) = compare_num;
 	FILE *fin, *fout;
-	char *buf, *endptr;
+	char *buf;
 	int ret, i, count;
 	struct stat st;
 	int opt;
@@ -496,9 +536,8 @@ int main(int argc, char **argv)
 			break;
 		case 1:
 			filter = filter | FILTER_PID;
-			errno = 0;
-			fc.pid = strtol(optarg, &amp;endptr, 10);
-			if (errno != 0 || endptr == optarg || *endptr != '\0') {
+			fc.pids = parse_nums_list(optarg, &amp;fc.pids_size);
+			if (fc.pids == NULL) {
 				fprintf(stderr, "wrong/invalid pid in from the command line:%s\n",
 						optarg);
 				exit(1);
@@ -506,9 +545,8 @@ int main(int argc, char **argv)
 			break;
 		case 2:
 			filter = filter | FILTER_TGID;
-			errno = 0;
-			fc.tgid = strtol(optarg, &amp;endptr, 10);
-			if (errno != 0 || endptr == optarg || *endptr != '\0') {
+			fc.tgids = parse_nums_list(optarg, &amp;fc.tgids_size);
+			if (fc.tgids == NULL) {
 				fprintf(stderr, "wrong/invalid tgid in from the command line:%s\n",
 						optarg);
 				exit(1);
@@ -516,8 +554,7 @@ int main(int argc, char **argv)
 			break;
 		case 3:
 			filter = filter | FILTER_COMM;
-			strncpy(fc.comm, optarg, TASK_COMM_LEN);
-			fc.comm[TASK_COMM_LEN-1] = '\0';
+			fc.comms = explode(',', optarg, &amp;fc.comms_size);
 			break;
 		case 4:
 			if (!parse_cull_args(optarg)) {
@@ -564,7 +601,6 @@ int main(int argc, char **argv)
 		ret = read_block(buf, BUF_SIZE, fin);
 		if (ret &lt; 0)
 			break;
-
 		add_list(buf, ret);
 	}
 </pre><hr><pre>commit 329687a03d18143f491b535d22be1cccc291bb58
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Apr 28 23:15:56 2022 -0700

    tools/vm/page_owner_sort.c: use fprintf() to send error messages to stderr
    
    Error messages should be send to stderr using fprintf() instead of
    printf().
    
    This work is coauthored by
            Yixuan Cao
            Shenghong Han
            Yinan Zhang
            Chongxi Zhao
            Yuhong Feng
            Yongqiang Liu
    
    Link: https://lkml.kernel.org/r/20220401024856.767-1-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Shenghong Han &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Cc: Yongqiang Liu &lt;liuyongqiang13@huawei.com&gt;
    Cc: Haowen Bai &lt;baihaowen@meizu.com&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index 7d98e76c2291..6771003ed5f1 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -186,7 +186,7 @@ static int search_pattern(regex_t *pattern, char *pattern_str, char *buf)
 
 	err = regexec(pattern, buf, 2, pmatch, REG_NOTBOL);
 	if (err != 0 || pmatch[1].rm_so == -1) {
-		printf("no matching pattern in %s\n", buf);
+		fprintf(stderr, "no matching pattern in %s\n", buf);
 		return -1;
 	}
 	val_len = pmatch[1].rm_eo - pmatch[1].rm_so;
@@ -202,7 +202,7 @@ static void check_regcomp(regex_t *pattern, const char *regex)
 
 	err = regcomp(pattern, regex, REG_EXTENDED | REG_NEWLINE);
 	if (err != 0 || pattern-&gt;re_nsub != 1) {
-		printf("Invalid pattern %s code %d\n", regex, err);
+		fprintf(stderr, "Invalid pattern %s code %d\n", regex, err);
 		exit(1);
 	}
 }
@@ -251,7 +251,7 @@ static int get_page_num(char *buf)
 	errno = 0;
 	order_val = strtol(order_str, &amp;endptr, 10);
 	if (order_val &gt; 64 || errno != 0 || endptr == order_str || *endptr != '\0') {
-		printf("wrong order in follow buf:\n%s\n", buf);
+		fprintf(stderr, "wrong order in follow buf:\n%s\n", buf);
 		return 0;
 	}
 
@@ -268,7 +268,7 @@ static pid_t get_pid(char *buf)
 	errno = 0;
 	pid = strtol(pid_str, &amp;endptr, 10);
 	if (errno != 0 || endptr == pid_str || *endptr != '\0') {
-		printf("wrong/invalid pid in follow buf:\n%s\n", buf);
+		fprintf(stderr, "wrong/invalid pid in follow buf:\n%s\n", buf);
 		return -1;
 	}
 
@@ -286,7 +286,7 @@ static pid_t get_tgid(char *buf)
 	errno = 0;
 	tgid = strtol(tgid_str, &amp;endptr, 10);
 	if (errno != 0 || endptr == tgid_str || *endptr != '\0') {
-		printf("wrong/invalid tgid in follow buf:\n%s\n", buf);
+		fprintf(stderr, "wrong/invalid tgid in follow buf:\n%s\n", buf);
 		return -1;
 	}
 
@@ -304,7 +304,7 @@ static __u64 get_ts_nsec(char *buf)
 	errno = 0;
 	ts_nsec = strtoull(ts_nsec_str, &amp;endptr, 10);
 	if (errno != 0 || endptr == ts_nsec_str || *endptr != '\0') {
-		printf("wrong ts_nsec in follow buf:\n%s\n", buf);
+		fprintf(stderr, "wrong ts_nsec in follow buf:\n%s\n", buf);
 		return -1;
 	}
 
@@ -321,7 +321,7 @@ static __u64 get_free_ts_nsec(char *buf)
 	errno = 0;
 	free_ts_nsec = strtoull(free_ts_nsec_str, &amp;endptr, 10);
 	if (errno != 0 || endptr == free_ts_nsec_str || *endptr != '\0') {
-		printf("wrong free_ts_nsec in follow buf:\n%s\n", buf);
+		fprintf(stderr, "wrong free_ts_nsec in follow buf:\n%s\n", buf);
 		return -1;
 	}
 
@@ -337,7 +337,7 @@ static char *get_comm(char *buf)
 	search_pattern(&amp;comm_pattern, comm_str, buf);
 	errno = 0;
 	if (errno != 0) {
-		printf("wrong comm in follow buf:\n%s\n", buf);
+		fprintf(stderr, "wrong comm in follow buf:\n%s\n", buf);
 		return NULL;
 	}
 
@@ -373,7 +373,7 @@ static void add_list(char *buf, int len)
 		return;
 	}
 	if (list_size == max_size) {
-		printf("max_size too small??\n");
+		fprintf(stderr, "max_size too small??\n");
 		exit(1);
 	}
 	if (!is_need(buf))
@@ -383,7 +383,7 @@ static void add_list(char *buf, int len)
 	list[list_size].comm = get_comm(buf);
 	list[list_size].txt = malloc(len+1);
 	if (!list[list_size].txt) {
-		printf("Out of memory\n");
+		fprintf(stderr, "Out of memory\n");
 		exit(1);
 	}
 	memcpy(list[list_size].txt, buf, len);
@@ -499,7 +499,8 @@ int main(int argc, char **argv)
 			errno = 0;
 			fc.pid = strtol(optarg, &amp;endptr, 10);
 			if (errno != 0 || endptr == optarg || *endptr != '\0') {
-				printf("wrong/invalid pid in from the command line:%s\n", optarg);
+				fprintf(stderr, "wrong/invalid pid in from the command line:%s\n",
+						optarg);
 				exit(1);
 			}
 			break;
@@ -508,7 +509,8 @@ int main(int argc, char **argv)
 			errno = 0;
 			fc.tgid = strtol(optarg, &amp;endptr, 10);
 			if (errno != 0 || endptr == optarg || *endptr != '\0') {
-				printf("wrong/invalid tgid in from the command line:%s\n", optarg);
+				fprintf(stderr, "wrong/invalid tgid in from the command line:%s\n",
+						optarg);
 				exit(1);
 			}
 			break;
@@ -519,7 +521,7 @@ int main(int argc, char **argv)
 			break;
 		case 4:
 			if (!parse_cull_args(optarg)) {
-				printf("wrong argument after --cull in from the command line:%s\n",
+				fprintf(stderr, "wrong argument after --cull option:%s\n",
 						optarg);
 				exit(1);
 			}
@@ -554,7 +556,7 @@ int main(int argc, char **argv)
 	list = malloc(max_size * sizeof(*list));
 	buf = malloc(BUF_SIZE);
 	if (!list || !buf) {
-		printf("Out of memory\n");
+		fprintf(stderr, "Out of memory\n");
 		exit(1);
 	}
 </pre><hr><pre>commit a8f23dd166651dcda2c02f16e524f56a4bd49084
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Thu Apr 7 16:09:58 2022 +0800

    mm/slab.c: fix comments
    
    While reading the source code,
    I noticed some language errors in the comments, so I fixed them.
    
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Acked-by: Hyeonggon Yoo &lt;42.hyeyoo@gmail.com&gt;
    Signed-off-by: Vlastimil Babka &lt;vbabka@suse.cz&gt;
    Link: https://lore.kernel.org/r/20220407080958.3667-1-caoyixuan2019@email.szu.edu.cn

diff --git a/mm/slab.c b/mm/slab.c
index 90b16c7ae01a..e882657c1494 100644
--- a/mm/slab.c
+++ b/mm/slab.c
@@ -781,7 +781,7 @@ static inline int cache_free_alien(struct kmem_cache *cachep, void *objp)
 	int slab_node = slab_nid(virt_to_slab(objp));
 	int node = numa_mem_id();
 	/*
-	 * Make sure we are not freeing a object from another node to the array
+	 * Make sure we are not freeing an object from another node to the array
 	 * cache on this cpu.
 	 */
 	if (likely(node == slab_node))
@@ -832,7 +832,7 @@ static int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)
 
 	/*
 	 * The kmem_cache_nodes don't come and go as CPUs
-	 * come and go.  slab_mutex is sufficient
+	 * come and go.  slab_mutex provides sufficient
 	 * protection here.
 	 */
 	cachep-&gt;node[node] = n;
@@ -845,7 +845,7 @@ static int init_cache_node(struct kmem_cache *cachep, int node, gfp_t gfp)
  * Allocates and initializes node for a node on each slab cache, used for
  * either memory or cpu hotplug.  If memory is being hot-added, the kmem_cache_node
  * will be allocated off-node since memory is not yet online for the new node.
- * When hotplugging memory or a cpu, existing node are not replaced if
+ * When hotplugging memory or a cpu, existing nodes are not replaced if
  * already in use.
  *
  * Must hold slab_mutex.
@@ -1046,7 +1046,7 @@ int slab_prepare_cpu(unsigned int cpu)
  * offline.
  *
  * Even if all the cpus of a node are down, we don't free the
- * kmem_cache_node of any cache. This to avoid a race between cpu_down, and
+ * kmem_cache_node of any cache. This is to avoid a race between cpu_down, and
  * a kmalloc allocation from another cpu for memory from the node of
  * the cpu going down.  The kmem_cache_node structure is usually allocated from
  * kmem_cache_create() and gets destroyed at kmem_cache_destroy().
@@ -1890,7 +1890,7 @@ static bool set_on_slab_cache(struct kmem_cache *cachep,
  * @flags: SLAB flags
  *
  * Returns a ptr to the cache on success, NULL on failure.
- * Cannot be called within a int, but can be interrupted.
+ * Cannot be called within an int, but can be interrupted.
  * The @ctor is run when new pages are allocated by the cache.
  *
  * The flags are
@@ -3138,7 +3138,7 @@ static void *fallback_alloc(struct kmem_cache *cache, gfp_t flags)
 }
 
 /*
- * A interface to enable slab creation on nodeid
+ * An interface to enable slab creation on nodeid
  */
 static void *____cache_alloc_node(struct kmem_cache *cachep, gfp_t flags,
 				int nodeid)</pre><hr><pre>commit c89b3ad2dea254ad17ae2585b17c2cf9f78e64d9
Author: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
Date:   Fri Apr 1 11:28:51 2022 -0700

    doc/vm/page_owner.rst: remove content related to -c option
    
    -c option has been removed from page_owner_sort.c.
    
    Remove the usage of -c option from Documentation.
    
    This work is coauthored by
            Shenghong Han
            Yixuan Cao
            Chongxi Zhao
            Jiajian Ye
            Yuhong Feng
            Yongqiang Liu
    
    Link: https://lkml.kernel.org/r/20220326085920.1470081-2-zhangyinan2019@email.szu.edu.cn
    Signed-off-by: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Jonathan Corbet &lt;corbet@lwn.net&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Cc: Tang Bin &lt;tangbin@cmss.chinamobile.com&gt;
    Cc: Zhenliang Wei &lt;weizhenliang@huawei.com&gt;
    Cc: Georgi Djakov &lt;georgi.djakov@linaro.org&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Cc: Yongqiang Liu &lt;liuyongqiang13@huawei.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index c4de6f8dabe9..65204d7f004f 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -125,7 +125,6 @@ Usage
    additional function:
 
 	Cull:
-		-c		Cull by comparing stacktrace instead of total block.
 		--cull &lt;rules&gt;
 				Specify culling rules.Culling syntax is key[,key[,...]].Choose a
 				multi-letter key from the **STANDARD FORMAT SPECIFIERS** section.</pre><hr><pre>commit d8b7b3fa9f9b2dc67fa1df29c4ce98eb10d62824
Author: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
Date:   Fri Apr 1 11:28:48 2022 -0700

    tools/vm/page_owner_sort.c: remove -c option
    
    The -c option is used to cull by stacktrace.  Now, --cull option has
    been Added in page_owner_sort.c.  Culling by stacktrace is one of the
    function of "--cull".  No need to set an extra parameter.  So remove -c
    option.
    
    Remove parsing of -c when parse parameter and remove "-c" from usage.
    
    This work is coauthored by
            Shenghong Han
            Yixuan Cao
            Chongxi Zhao
            Jiajian Ye
            Yuhong Feng
            Yongqiang Liu
    
    Link: https://lkml.kernel.org/r/20220326085920.1470081-1-zhangyinan2019@email.szu.edu.cn
    Signed-off-by: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Georgi Djakov &lt;georgi.djakov@linaro.org&gt;
    Cc: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Jonathan Corbet &lt;corbet@lwn.net&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Cc: Tang Bin &lt;tangbin@cmss.chinamobile.com&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Yongqiang Liu &lt;liuyongqiang13@huawei.com&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Cc: Zhenliang Wei &lt;weizhenliang@huawei.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index 7679335fce5b..7d98e76c2291 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -441,7 +441,6 @@ static void usage(void)
 		"-n\t\tSort by task command name.\n"
 		"-a\t\tSort by memory allocate time.\n"
 		"-r\t\tSort by memory release time.\n"
-		"-c\t\tCull by comparing stacktrace instead of total block.\n"
 		"-f\t\tFilter out the information of blocks whose memory has been released.\n"
 		"--pid &lt;PID&gt;\tSelect by pid. This selects the information of blocks whose process ID number equals to &lt;PID&gt;.\n"
 		"--tgid &lt;TGID&gt;\tSelect by tgid. This selects the information of blocks whose Thread Group ID number equals to &lt;TGID&gt;.\n"
@@ -466,14 +465,11 @@ int main(int argc, char **argv)
 		{ 0, 0, 0, 0},
 	};
 
-	while ((opt = getopt_long(argc, argv, "acfmnprstP", longopts, NULL)) != -1)
+	while ((opt = getopt_long(argc, argv, "afmnprstP", longopts, NULL)) != -1)
 		switch (opt) {
 		case 'a':
 			cmp = compare_ts;
 			break;
-		case 'c':
-			cull = cull | CULL_STACKTRACE;
-			break;
 		case 'f':
 			filter = filter | FILTER_UNRELEASE;
 			break;</pre><hr><pre>commit 9c8a0a8e599f4a949ef18207ba495fb557dd1016
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Mar 24 18:09:38 2022 -0700

    tools/vm/page_owner_sort.c: support for user-defined culling rules
    
    When viewing page owner information, we may want to cull blocks of
    information with our own rules.  So it is important to enhance culling
    function to provide the support for customizing culling rules.
    Therefore, following adjustments are made:
    
    1. Add --cull option to support the culling of blocks of information
       with user-defined culling rules.
    
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=&lt;rules&gt;
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --cull &lt;rules&gt;
    
      &lt;rules&gt; is a single argument in the form of a comma-separated list to
      specify individual culling rules, by the sequence of keys k1,k2, ....
      Mixed use of abbreviated and complete-form of keys is allowed.
    
      For reference, please see the document(Documentation/vm/page_owner.rst).
    
    Now, assuming two blocks in the input file are as follows:
    
            Page allocated via order 0, mask xxxx, pid 1, tgid 1 (task_name_demo)
            PFN xxxx
             prep_new_page+0xd0/0xf8
             get_page_from_freelist+0x4a0/0x1290
             __alloc_pages+0x168/0x340
             alloc_pages+0xb0/0x158
    
            Page allocated via order 0, mask xxxx, pid 32, tgid 32 (task_name_demo)
            PFN xxxx
             prep_new_page+0xd0/0xf8
             get_page_from_freelist+0x4a0/0x1290
             __alloc_pages+0x168/0x340
             alloc_pages+0xb0/0x158
    
    If we want to cull the blocks by stacktrace and task command name, we can
    use this command:
    
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=stacktrace,name
    
    The output would be like:
    
            2 times, 2 pages, task_comm_name: task_name_demo
             prep_new_page+0xd0/0xf8
             get_page_from_freelist+0x4a0/0x1290
             __alloc_pages+0x168/0x340
             alloc_pages+0xb0/0x158
    
    As we can see, these two blocks are culled successfully, for they share
    the same pid and task command name.
    
    However, if we want to cull the blocks by pid, stacktrace and task command
    name, we can this command:
    
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=stacktrace,name,pid
    
    The output would be like:
    
            1 times, 1 pages, PID 1, task_comm_name: task_name_demo
             prep_new_page+0xd0/0xf8
             get_page_from_freelist+0x4a0/0x1290
             __alloc_pages+0x168/0x340
             alloc_pages+0xb0/0x158
    
            1 times, 1 pages, PID 32, task_comm_name: task_name_demo
             prep_new_page+0xd0/0xf8
             get_page_from_freelist+0x4a0/0x1290
             __alloc_pages+0x168/0x340
             alloc_pages+0xb0/0x158
    
    As we can see, these two blocks are failed to cull, for their PIDs are
    different.
    
    2. Add explanations of --cull options to the document.
    
    This work is coauthored by
            Yixuan Cao
            Shenghong Han
            Yinan Zhang
            Chongxi Zhao
            Yuhong Feng
    
    Link: https://lkml.kernel.org/r/20220312145834.624-1-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Shenghong Han &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index 3dd31fe06c05..c4de6f8dabe9 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -126,11 +126,38 @@ Usage
 
 	Cull:
 		-c		Cull by comparing stacktrace instead of total block.
+		--cull &lt;rules&gt;
+				Specify culling rules.Culling syntax is key[,key[,...]].Choose a
+				multi-letter key from the **STANDARD FORMAT SPECIFIERS** section.
+
+
+		&lt;rules&gt; is a single argument in the form of a comma-separated list,
+		which offers a way to specify individual culling rules.  The recognized
+		keywords are described in the **STANDARD FORMAT SPECIFIERS** section below.
+		&lt;rules&gt; can be specified by the sequence of keys k1,k2, ..., as described in
+		the STANDARD SORT KEYS section below. Mixed use of abbreviated and
+		complete-form of keys is allowed.
+
+
+		Examples:
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=stacktrace
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=st,pid,name
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=n,f
 
 	Filter:
 		-f		Filter out the information of blocks whose memory has been released.
 
 	Select:
-		--pid &lt;PID&gt;			Select by pid.
+		--pid &lt;PID&gt;		Select by pid.
 		--tgid &lt;TGID&gt;		Select by tgid.
 		--name &lt;command&gt;	Select by task command name.
+
+STANDARD FORMAT SPECIFIERS
+==========================
+
+	KEY		LONG		DESCRIPTION
+	p		pid		process ID
+	tg		tgid		thread group ID
+	n		name		task command name
+	f		free		whether the page has been released or not
+	st		stacktrace	stace trace of the page allocation
diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index e873eff84462..7679335fce5b 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -44,7 +44,14 @@ enum FILTER_BIT {
 	FILTER_UNRELEASE = 1&lt;&lt;1,
 	FILTER_PID = 1&lt;&lt;2,
 	FILTER_TGID = 1&lt;&lt;3,
-	FILTER_TASK_COMM_NAME = 1&lt;&lt;4
+	FILTER_COMM = 1&lt;&lt;4
+};
+enum CULL_BIT {
+	CULL_UNRELEASE = 1&lt;&lt;1,
+	CULL_PID = 1&lt;&lt;2,
+	CULL_TGID = 1&lt;&lt;3,
+	CULL_COMM = 1&lt;&lt;4,
+	CULL_STACKTRACE = 1&lt;&lt;5
 };
 struct filter_condition {
 	pid_t tgid;
@@ -61,7 +68,7 @@ static regex_t free_ts_nsec_pattern;
 static struct block_list *list;
 static int list_size;
 static int max_size;
-static int cull_st;
+static int cull;
 static int filter;
 
 int read_block(char *buf, int buf_size, FILE *fin)
@@ -142,6 +149,36 @@ static int compare_free_ts(const void *p1, const void *p2)
 	return l1-&gt;free_ts_nsec &lt; l2-&gt;free_ts_nsec ? -1 : 1;
 }
 
+
+static int compare_release(const void *p1, const void *p2)
+{
+	const struct block_list *l1 = p1, *l2 = p2;
+
+	if (!l1-&gt;free_ts_nsec &amp;&amp; !l2-&gt;free_ts_nsec)
+		return 0;
+	if (l1-&gt;free_ts_nsec &amp;&amp; l2-&gt;free_ts_nsec)
+		return 0;
+	return l1-&gt;free_ts_nsec ? 1 : -1;
+}
+
+
+static int compare_cull_condition(const void *p1, const void *p2)
+{
+	if (cull == 0)
+		return compare_txt(p1, p2);
+	if ((cull &amp; CULL_STACKTRACE) &amp;&amp; compare_stacktrace(p1, p2))
+		return compare_stacktrace(p1, p2);
+	if ((cull &amp; CULL_PID) &amp;&amp; compare_pid(p1, p2))
+		return compare_pid(p1, p2);
+	if ((cull &amp; CULL_TGID) &amp;&amp; compare_tgid(p1, p2))
+		return compare_tgid(p1, p2);
+	if ((cull &amp; CULL_COMM) &amp;&amp; compare_comm(p1, p2))
+		return compare_comm(p1, p2);
+	if ((cull &amp; CULL_UNRELEASE) &amp;&amp; compare_release(p1, p2))
+		return compare_release(p1, p2);
+	return 0;
+}
+
 static int search_pattern(regex_t *pattern, char *pattern_str, char *buf)
 {
 	int err, val_len;
@@ -170,6 +207,38 @@ static void check_regcomp(regex_t *pattern, const char *regex)
 	}
 }
 
+static char **explode(char sep, const char *str, int *size)
+{
+	int count = 0, len = strlen(str);
+	int lastindex = -1, j = 0;
+
+	for (int i = 0; i &lt; len; i++)
+		if (str[i] == sep)
+			count++;
+	char **ret = calloc(++count, sizeof(char *));
+
+	for (int i = 0; i &lt; len; i++) {
+		if (str[i] == sep) {
+			ret[j] = calloc(i - lastindex, sizeof(char));
+			memcpy(ret[j++], str + lastindex + 1, i - lastindex - 1);
+			lastindex = i;
+		}
+	}
+	if (lastindex &lt;= len - 1) {
+		ret[j] = calloc(len - lastindex, sizeof(char));
+		memcpy(ret[j++], str + lastindex + 1, strlen(str) - 1 - lastindex);
+	}
+	*size = j;
+	return ret;
+}
+
+static void free_explode(char **arr, int size)
+{
+	for (int i = 0; i &lt; size; i++)
+		free(arr[i]);
+	free(arr);
+}
+
 # define FIELD_BUFF 25
 
 static int get_page_num(char *buf)
@@ -277,16 +346,16 @@ static char *get_comm(char *buf)
 
 static bool is_need(char *buf)
 {
-		if ((filter &amp; FILTER_UNRELEASE) != 0 &amp;&amp; get_free_ts_nsec(buf) != 0)
+		if ((filter &amp; FILTER_UNRELEASE) &amp;&amp; get_free_ts_nsec(buf) != 0)
 			return false;
-		if ((filter &amp; FILTER_PID) != 0 &amp;&amp; get_pid(buf) != fc.pid)
+		if ((filter &amp; FILTER_PID) &amp;&amp; get_pid(buf) != fc.pid)
 			return false;
-		if ((filter &amp; FILTER_TGID) != 0 &amp;&amp; get_tgid(buf) != fc.tgid)
+		if ((filter &amp; FILTER_TGID) &amp;&amp; get_tgid(buf) != fc.tgid)
 			return false;
 
 		char *comm = get_comm(buf);
 
-		if ((filter &amp; FILTER_TASK_COMM_NAME) != 0  &amp;&amp;
+		if ((filter &amp; FILTER_COMM) &amp;&amp;
 		strncmp(comm, fc.comm, TASK_COMM_LEN) != 0) {
 			free(comm);
 			return false;
@@ -335,6 +404,30 @@ static void add_list(char *buf, int len)
 	}
 }
 
+static bool parse_cull_args(const char *arg_str)
+{
+	int size = 0;
+	char **args = explode(',', arg_str, &amp;size);
+
+	for (int i = 0; i &lt; size; ++i)
+		if (!strcmp(args[i], "pid") || !strcmp(args[i], "p"))
+			cull |= CULL_PID;
+		else if (!strcmp(args[i], "tgid") || !strcmp(args[i], "tg"))
+			cull |= CULL_TGID;
+		else if (!strcmp(args[i], "name") || !strcmp(args[i], "n"))
+			cull |= CULL_COMM;
+		else if (!strcmp(args[i], "stacktrace") || !strcmp(args[i], "st"))
+			cull |= CULL_STACKTRACE;
+		else if (!strcmp(args[i], "free") || !strcmp(args[i], "f"))
+			cull |= CULL_UNRELEASE;
+		else {
+			free_explode(args, size);
+			return false;
+		}
+	free_explode(args, size);
+	return true;
+}
+
 #define BUF_SIZE	(128 * 1024)
 
 static void usage(void)
@@ -353,6 +446,7 @@ static void usage(void)
 		"--pid &lt;PID&gt;\tSelect by pid. This selects the information of blocks whose process ID number equals to &lt;PID&gt;.\n"
 		"--tgid &lt;TGID&gt;\tSelect by tgid. This selects the information of blocks whose Thread Group ID number equals to &lt;TGID&gt;.\n"
 		"--name &lt;command&gt;\n\t\tSelect by command name. This selects the information of blocks whose command name identical to &lt;command&gt;.\n"
+		"--cull &lt;rules&gt;\tCull by user-defined rules. &lt;rules&gt; is a single argument in the form of a comma-separated list with some common fields predefined\n"
 	);
 }
 
@@ -368,6 +462,7 @@ int main(int argc, char **argv)
 		{ "pid", required_argument, NULL, 1 },
 		{ "tgid", required_argument, NULL, 2 },
 		{ "name", required_argument, NULL, 3 },
+		{ "cull",  required_argument, NULL, 4 },
 		{ 0, 0, 0, 0},
 	};
 
@@ -377,7 +472,7 @@ int main(int argc, char **argv)
 			cmp = compare_ts;
 			break;
 		case 'c':
-			cull_st = 1;
+			cull = cull | CULL_STACKTRACE;
 			break;
 		case 'f':
 			filter = filter | FILTER_UNRELEASE;
@@ -422,10 +517,17 @@ int main(int argc, char **argv)
 			}
 			break;
 		case 3:
-			filter = filter | FILTER_TASK_COMM_NAME;
+			filter = filter | FILTER_COMM;
 			strncpy(fc.comm, optarg, TASK_COMM_LEN);
 			fc.comm[TASK_COMM_LEN-1] = '\0';
 			break;
+		case 4:
+			if (!parse_cull_args(optarg)) {
+				printf("wrong argument after --cull in from the command line:%s\n",
+						optarg);
+				exit(1);
+			}
+			break;
 		default:
 			usage();
 			exit(1);
@@ -472,20 +574,13 @@ int main(int argc, char **argv)
 
 	printf("sorting ....\n");
 
-	if (cull_st == 1)
-		qsort(list, list_size, sizeof(list[0]), compare_stacktrace);
-	else
-		qsort(list, list_size, sizeof(list[0]), compare_txt);
-
-
+	qsort(list, list_size, sizeof(list[0]), compare_cull_condition);
 
 	printf("culling\n");
 
-	long offset = cull_st ? &amp;list[0].stacktrace - &amp;list[0].txt : 0;
-
 	for (i = count = 0; i &lt; list_size; i++) {
 		if (count == 0 ||
-		    strcmp(*(&amp;list[count-1].txt+offset), *(&amp;list[i].txt+offset)) != 0) {
+		    compare_cull_condition((void *)(&amp;list[count-1]), (void *)(&amp;list[i])) != 0) {
 			list[count++] = list[i];
 		} else {
 			list[count-1].num += list[i].num;
@@ -496,12 +591,25 @@ int main(int argc, char **argv)
 	qsort(list, count, sizeof(list[0]), cmp);
 
 	for (i = 0; i &lt; count; i++) {
-		if (cull_st == 0)
+		if (cull == 0)
 			fprintf(fout, "%d times, %d pages:\n%s\n",
 					list[i].num, list[i].page_num, list[i].txt);
-		else
-			fprintf(fout, "%d times, %d pages:\n%s\n",
-					list[i].num, list[i].page_num, list[i].stacktrace);
+		else {
+			fprintf(fout, "%d times, %d pages",
+					list[i].num, list[i].page_num);
+			if (cull &amp; CULL_PID || filter &amp; FILTER_PID)
+				fprintf(fout, ", PID %d", list[i].pid);
+			if (cull &amp; CULL_TGID || filter &amp; FILTER_TGID)
+				fprintf(fout, ", TGID %d", list[i].pid);
+			if (cull &amp; CULL_COMM || filter &amp; FILTER_COMM)
+				fprintf(fout, ", task_comm_name: %s", list[i].comm);
+			if (cull &amp; CULL_UNRELEASE)
+				fprintf(fout, " (%s)",
+						list[i].free_ts_nsec ? "UNRELEASED" : "RELEASED");
+			if (cull &amp; CULL_STACKTRACE)
+				fprintf(fout, ":\n%s", list[i].stacktrace);
+			fprintf(fout, "\n");
+		}
 	}
 	regfree(&amp;order_pattern);
 	regfree(&amp;pid_pattern);</pre><hr><pre>commit 8ea8613a616aff184df9e3ea2d3ec39d90832867
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Mar 24 18:09:34 2022 -0700

    tools/vm/page_owner_sort.c: support for selecting by PID, TGID or task command name
    
    When viewing page owner information, we may also need to select the blocks
    by PID, TGID or task command name, which helps to get more accurate page
    allocation information as needed.
    
    Therefore, following adjustments are made:
    
    1. Add three new options, including --pid, --tgid and --name, to support
       the selection of information blocks by a specific pid, tgid and task
       command name. In addtion, multiple options are allowed to be used at
       the same time.
    
            ./page_owner_sort [input] [output] --pid &lt;PID&gt;
            ./page_owner_sort [input] [output] --tgid &lt;TGID&gt;
            ./page_owner_sort [input] [output] --name &lt;TASK_COMMAND_NAME&gt;
    
       Assuming a scenario when a multi-threaded program, ./demo (PID =
       5280), is running, and ./demo creates a child process (PID = 5281).
    
            $ps
            PID   TTY        TIME   CMD
            5215  pts/0    00:00:00  bash
            5280  pts/0    00:00:00  ./demo
            5281  pts/0    00:00:00  ./demo
            5282  pts/0    00:00:00  ps
    
       It would be better to filter out the records with tgid=5280 and the
       task name "demo" when debugging the parent process, and the specific
       usage is
    
            ./page_owner_sort [input] [output] --tgid 5280 --name demo
    
    2. Add explanations of three new options, including --pid, --tgid and
       --name, to the document.
    
    This work is coauthored by
            Shenghong Han &lt;hanshenghong2019@email.szu.edu.cn&gt;,
            Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;,
            Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;,
            Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;,
            Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;.
    
    Link: https://lkml.kernel.org/r/1646835223-7584-1-git-send-email-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Cc: Zhenliang Wei &lt;weizhenliang@huawei.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index d658436a5e09..3dd31fe06c05 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -129,3 +129,8 @@ Usage
 
 	Filter:
 		-f		Filter out the information of blocks whose memory has been released.
+
+	Select:
+		--pid &lt;PID&gt;			Select by pid.
+		--tgid &lt;TGID&gt;		Select by tgid.
+		--name &lt;command&gt;	Select by task command name.
diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index e508abd8f665..e873eff84462 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -21,6 +21,12 @@
 #include &lt;regex.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;linux/types.h&gt;
+#include &lt;getopt.h&gt;
+
+#define bool int
+#define true 1
+#define false 0
+#define TASK_COMM_LEN 16
 
 struct block_list {
 	char *txt;
@@ -34,7 +40,18 @@ struct block_list {
 	pid_t pid;
 	pid_t tgid;
 };
-
+enum FILTER_BIT {
+	FILTER_UNRELEASE = 1&lt;&lt;1,
+	FILTER_PID = 1&lt;&lt;2,
+	FILTER_TGID = 1&lt;&lt;3,
+	FILTER_TASK_COMM_NAME = 1&lt;&lt;4
+};
+struct filter_condition {
+	pid_t tgid;
+	pid_t pid;
+	char comm[TASK_COMM_LEN];
+};
+static struct filter_condition fc;
 static regex_t order_pattern;
 static regex_t pid_pattern;
 static regex_t tgid_pattern;
@@ -154,7 +171,6 @@ static void check_regcomp(regex_t *pattern, const char *regex)
 }
 
 # define FIELD_BUFF 25
-# define TASK_COMM_LEN 16
 
 static int get_page_num(char *buf)
 {
@@ -259,11 +275,30 @@ static char *get_comm(char *buf)
 	return comm_str;
 }
 
+static bool is_need(char *buf)
+{
+		if ((filter &amp; FILTER_UNRELEASE) != 0 &amp;&amp; get_free_ts_nsec(buf) != 0)
+			return false;
+		if ((filter &amp; FILTER_PID) != 0 &amp;&amp; get_pid(buf) != fc.pid)
+			return false;
+		if ((filter &amp; FILTER_TGID) != 0 &amp;&amp; get_tgid(buf) != fc.tgid)
+			return false;
+
+		char *comm = get_comm(buf);
+
+		if ((filter &amp; FILTER_TASK_COMM_NAME) != 0  &amp;&amp;
+		strncmp(comm, fc.comm, TASK_COMM_LEN) != 0) {
+			free(comm);
+			return false;
+		}
+		return true;
+}
+
 static void add_list(char *buf, int len)
 {
 	if (list_size != 0 &amp;&amp;
-	    len == list[list_size-1].len &amp;&amp;
-	    memcmp(buf, list[list_size-1].txt, len) == 0) {
+		len == list[list_size-1].len &amp;&amp;
+		memcmp(buf, list[list_size-1].txt, len) == 0) {
 		list[list_size-1].num++;
 		list[list_size-1].page_num += get_page_num(buf);
 		return;
@@ -272,28 +307,27 @@ static void add_list(char *buf, int len)
 		printf("max_size too small??\n");
 		exit(1);
 	}
-
-	list[list_size].free_ts_nsec = get_free_ts_nsec(buf);
-	if (filter == 1 &amp;&amp; list[list_size].free_ts_nsec != 0)
+	if (!is_need(buf))
 		return;
+	list[list_size].pid = get_pid(buf);
+	list[list_size].tgid = get_tgid(buf);
+	list[list_size].comm = get_comm(buf);
 	list[list_size].txt = malloc(len+1);
 	if (!list[list_size].txt) {
 		printf("Out of memory\n");
 		exit(1);
 	}
-
+	memcpy(list[list_size].txt, buf, len);
+	list[list_size].txt[len] = 0;
 	list[list_size].len = len;
 	list[list_size].num = 1;
 	list[list_size].page_num = get_page_num(buf);
-	memcpy(list[list_size].txt, buf, len);
-	list[list_size].txt[len] = 0;
+
 	list[list_size].stacktrace = strchr(list[list_size].txt, '\n') ?: "";
 	if (*list[list_size].stacktrace == '\n')
 		list[list_size].stacktrace++;
-	list[list_size].pid = get_pid(buf);
-	list[list_size].tgid = get_tgid(buf);
-	list[list_size].comm = get_comm(buf);
 	list[list_size].ts_nsec = get_ts_nsec(buf);
+	list[list_size].free_ts_nsec = get_free_ts_nsec(buf);
 	list_size++;
 	if (list_size % 1000 == 0) {
 		printf("loaded %d\r", list_size);
@@ -306,16 +340,19 @@ static void add_list(char *buf, int len)
 static void usage(void)
 {
 	printf("Usage: ./page_owner_sort [OPTIONS] &lt;input&gt; &lt;output&gt;\n"
-		"-m	Sort by total memory.\n"
-		"-s	Sort by the stack trace.\n"
-		"-t	Sort by times (default).\n"
-		"-p	Sort by pid.\n"
-		"-P	Sort by tgid.\n"
-		"-n	Sort by task command name.\n"
-		"-a	Sort by memory allocate time.\n"
-		"-r	Sort by memory release time.\n"
-		"-c	Cull by comparing stacktrace instead of total block.\n"
-		"-f	Filter out the information of blocks whose memory has been released.\n"
+		"-m\t\tSort by total memory.\n"
+		"-s\t\tSort by the stack trace.\n"
+		"-t\t\tSort by times (default).\n"
+		"-p\t\tSort by pid.\n"
+		"-P\t\tSort by tgid.\n"
+		"-n\t\tSort by task command name.\n"
+		"-a\t\tSort by memory allocate time.\n"
+		"-r\t\tSort by memory release time.\n"
+		"-c\t\tCull by comparing stacktrace instead of total block.\n"
+		"-f\t\tFilter out the information of blocks whose memory has been released.\n"
+		"--pid &lt;PID&gt;\tSelect by pid. This selects the information of blocks whose process ID number equals to &lt;PID&gt;.\n"
+		"--tgid &lt;TGID&gt;\tSelect by tgid. This selects the information of blocks whose Thread Group ID number equals to &lt;TGID&gt;.\n"
+		"--name &lt;command&gt;\n\t\tSelect by command name. This selects the information of blocks whose command name identical to &lt;command&gt;.\n"
 	);
 }
 
@@ -323,12 +360,18 @@ int main(int argc, char **argv)
 {
 	int (*cmp)(const void *, const void *) = compare_num;
 	FILE *fin, *fout;
-	char *buf;
+	char *buf, *endptr;
 	int ret, i, count;
 	struct stat st;
 	int opt;
-
-	while ((opt = getopt(argc, argv, "acfmnprstP")) != -1)
+	struct option longopts[] = {
+		{ "pid", required_argument, NULL, 1 },
+		{ "tgid", required_argument, NULL, 2 },
+		{ "name", required_argument, NULL, 3 },
+		{ 0, 0, 0, 0},
+	};
+
+	while ((opt = getopt_long(argc, argv, "acfmnprstP", longopts, NULL)) != -1)
 		switch (opt) {
 		case 'a':
 			cmp = compare_ts;
@@ -337,7 +380,7 @@ int main(int argc, char **argv)
 			cull_st = 1;
 			break;
 		case 'f':
-			filter = 1;
+			filter = filter | FILTER_UNRELEASE;
 			break;
 		case 'm':
 			cmp = compare_page_num;
@@ -360,6 +403,29 @@ int main(int argc, char **argv)
 		case 'n':
 			cmp = compare_comm;
 			break;
+		case 1:
+			filter = filter | FILTER_PID;
+			errno = 0;
+			fc.pid = strtol(optarg, &amp;endptr, 10);
+			if (errno != 0 || endptr == optarg || *endptr != '\0') {
+				printf("wrong/invalid pid in from the command line:%s\n", optarg);
+				exit(1);
+			}
+			break;
+		case 2:
+			filter = filter | FILTER_TGID;
+			errno = 0;
+			fc.tgid = strtol(optarg, &amp;endptr, 10);
+			if (errno != 0 || endptr == optarg || *endptr != '\0') {
+				printf("wrong/invalid tgid in from the command line:%s\n", optarg);
+				exit(1);
+			}
+			break;
+		case 3:
+			filter = filter | FILTER_TASK_COMM_NAME;
+			strncpy(fc.comm, optarg, TASK_COMM_LEN);
+			fc.comm[TASK_COMM_LEN-1] = '\0';
+			break;
 		default:
 			usage();
 			exit(1);</pre><hr><pre>commit 194d52d771b8f7cf5bcf0f81f87dd76e492c355c
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Mar 24 18:09:31 2022 -0700

    tools/vm/page_owner_sort: support for sorting by task command name
    
    When viewing page owner information, we may also need to the block to be
    sorted by task command name.  Therefore, the following adjustments are
    made:
    
    1. Add a member variable to record task command name of block.
    
    2. Add a new -n option to sort the information of blocks by task command
       name.
    
    3. Add -n option explanation in the document.
    
    Link: https://lkml.kernel.org/r/20220306030640.43054-2-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Zhenliang Wei &lt;weizhenliang@huawei.com&gt;
    Cc: &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index 941543a797fe..d658436a5e09 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -117,6 +117,7 @@ Usage
 		-m		Sort by total memory.
 		-p		Sort by pid.
 		-P		Sort by tgid.
+		-n		Sort by task command name.
 		-r		Sort by memory release time.
 		-s		Sort by stack trace.
 		-t		Sort by times (default).
diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index b8d2867b5b18..e508abd8f665 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -24,6 +24,7 @@
 
 struct block_list {
 	char *txt;
+	char *comm; // task command name
 	char *stacktrace;
 	__u64 ts_nsec;
 	__u64 free_ts_nsec;
@@ -37,6 +38,7 @@ struct block_list {
 static regex_t order_pattern;
 static regex_t pid_pattern;
 static regex_t tgid_pattern;
+static regex_t comm_pattern;
 static regex_t ts_nsec_pattern;
 static regex_t free_ts_nsec_pattern;
 static struct block_list *list;
@@ -102,6 +104,13 @@ static int compare_tgid(const void *p1, const void *p2)
 	return l1-&gt;tgid - l2-&gt;tgid;
 }
 
+static int compare_comm(const void *p1, const void *p2)
+{
+	const struct block_list *l1 = p1, *l2 = p2;
+
+	return strcmp(l1-&gt;comm, l2-&gt;comm);
+}
+
 static int compare_ts(const void *p1, const void *p2)
 {
 	const struct block_list *l1 = p1, *l2 = p2;
@@ -145,6 +154,7 @@ static void check_regcomp(regex_t *pattern, const char *regex)
 }
 
 # define FIELD_BUFF 25
+# define TASK_COMM_LEN 16
 
 static int get_page_num(char *buf)
 {
@@ -233,6 +243,22 @@ static __u64 get_free_ts_nsec(char *buf)
 	return free_ts_nsec;
 }
 
+static char *get_comm(char *buf)
+{
+	char *comm_str = malloc(TASK_COMM_LEN);
+
+	memset(comm_str, 0, TASK_COMM_LEN);
+
+	search_pattern(&amp;comm_pattern, comm_str, buf);
+	errno = 0;
+	if (errno != 0) {
+		printf("wrong comm in follow buf:\n%s\n", buf);
+		return NULL;
+	}
+
+	return comm_str;
+}
+
 static void add_list(char *buf, int len)
 {
 	if (list_size != 0 &amp;&amp;
@@ -266,6 +292,7 @@ static void add_list(char *buf, int len)
 		list[list_size].stacktrace++;
 	list[list_size].pid = get_pid(buf);
 	list[list_size].tgid = get_tgid(buf);
+	list[list_size].comm = get_comm(buf);
 	list[list_size].ts_nsec = get_ts_nsec(buf);
 	list_size++;
 	if (list_size % 1000 == 0) {
@@ -284,6 +311,7 @@ static void usage(void)
 		"-t	Sort by times (default).\n"
 		"-p	Sort by pid.\n"
 		"-P	Sort by tgid.\n"
+		"-n	Sort by task command name.\n"
 		"-a	Sort by memory allocate time.\n"
 		"-r	Sort by memory release time.\n"
 		"-c	Cull by comparing stacktrace instead of total block.\n"
@@ -300,7 +328,7 @@ int main(int argc, char **argv)
 	struct stat st;
 	int opt;
 
-	while ((opt = getopt(argc, argv, "acfmprstP")) != -1)
+	while ((opt = getopt(argc, argv, "acfmnprstP")) != -1)
 		switch (opt) {
 		case 'a':
 			cmp = compare_ts;
@@ -329,6 +357,9 @@ int main(int argc, char **argv)
 		case 'P':
 			cmp = compare_tgid;
 			break;
+		case 'n':
+			cmp = compare_comm;
+			break;
 		default:
 			usage();
 			exit(1);
@@ -350,6 +381,7 @@ int main(int argc, char **argv)
 	check_regcomp(&amp;order_pattern, "order\\s*([0-9]*),");
 	check_regcomp(&amp;pid_pattern, "pid\\s*([0-9]*),");
 	check_regcomp(&amp;tgid_pattern, "tgid\\s*([0-9]*) ");
+	check_regcomp(&amp;comm_pattern, "tgid\\s*[0-9]*\\s*\\((.*)\\),\\s*ts");
 	check_regcomp(&amp;ts_nsec_pattern, "ts\\s*([0-9]*)\\s*ns,");
 	check_regcomp(&amp;free_ts_nsec_pattern, "free_ts\\s*([0-9]*)\\s*ns");
 	fstat(fileno(fin), &amp;st);
@@ -408,6 +440,7 @@ int main(int argc, char **argv)
 	regfree(&amp;order_pattern);
 	regfree(&amp;pid_pattern);
 	regfree(&amp;tgid_pattern);
+	regfree(&amp;comm_pattern);
 	regfree(&amp;ts_nsec_pattern);
 	regfree(&amp;free_ts_nsec_pattern);
 	return 0;</pre><hr><pre>commit 578d8f2761a828f6c3409d0931b036bf3a999246
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Mar 24 18:09:29 2022 -0700

    tools/vm/page_owner_sort: fix three trivival places
    
    The following adjustments are made:
    
    1. Instead of using another array to cull the blocks after sorting,
       reuse the old array.  So there is no need to malloc a new array.
    
    2. When enabling '-f' option to filter out the blocks which have been
       released, only add those have not been released in the list, rather
       than add all of blocks in the list and then do the filtering when
       printing the result.
    
    3. When enabling '-c' option to cull the blocks by comparing
       stacktrace, print the stacetrace rather than the total block.
    
    Link: https://lkml.kernel.org/r/20220306030640.43054-1-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Zhenliang Wei &lt;weizhenliang@huawei.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index d166f2f900eb..b8d2867b5b18 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -42,6 +42,8 @@ static regex_t free_ts_nsec_pattern;
 static struct block_list *list;
 static int list_size;
 static int max_size;
+static int cull_st;
+static int filter;
 
 int read_block(char *buf, int buf_size, FILE *fin)
 {
@@ -245,6 +247,9 @@ static void add_list(char *buf, int len)
 		exit(1);
 	}
 
+	list[list_size].free_ts_nsec = get_free_ts_nsec(buf);
+	if (filter == 1 &amp;&amp; list[list_size].free_ts_nsec != 0)
+		return;
 	list[list_size].txt = malloc(len+1);
 	if (!list[list_size].txt) {
 		printf("Out of memory\n");
@@ -257,10 +262,11 @@ static void add_list(char *buf, int len)
 	memcpy(list[list_size].txt, buf, len);
 	list[list_size].txt[len] = 0;
 	list[list_size].stacktrace = strchr(list[list_size].txt, '\n') ?: "";
+	if (*list[list_size].stacktrace == '\n')
+		list[list_size].stacktrace++;
 	list[list_size].pid = get_pid(buf);
 	list[list_size].tgid = get_tgid(buf);
 	list[list_size].ts_nsec = get_ts_nsec(buf);
-	list[list_size].free_ts_nsec = get_free_ts_nsec(buf);
 	list_size++;
 	if (list_size % 1000 == 0) {
 		printf("loaded %d\r", list_size);
@@ -288,12 +294,9 @@ static void usage(void)
 int main(int argc, char **argv)
 {
 	int (*cmp)(const void *, const void *) = compare_num;
-	int cull_st = 0;
-	int filter = 0;
 	FILE *fin, *fout;
 	char *buf;
 	int ret, i, count;
-	struct block_list *list2;
 	struct stat st;
 	int opt;
 
@@ -376,11 +379,7 @@ int main(int argc, char **argv)
 	else
 		qsort(list, list_size, sizeof(list[0]), compare_txt);
 
-	list2 = malloc(sizeof(*list) * list_size);
-	if (!list2) {
-		printf("Out of memory\n");
-		exit(1);
-	}
+
 
 	printf("culling\n");
 
@@ -388,21 +387,23 @@ int main(int argc, char **argv)
 
 	for (i = count = 0; i &lt; list_size; i++) {
 		if (count == 0 ||
-		    strcmp(*(&amp;list2[count-1].txt+offset), *(&amp;list[i].txt+offset)) != 0) {
-			list2[count++] = list[i];
+		    strcmp(*(&amp;list[count-1].txt+offset), *(&amp;list[i].txt+offset)) != 0) {
+			list[count++] = list[i];
 		} else {
-			list2[count-1].num += list[i].num;
-			list2[count-1].page_num += list[i].page_num;
+			list[count-1].num += list[i].num;
+			list[count-1].page_num += list[i].page_num;
 		}
 	}
 
-	qsort(list2, count, sizeof(list[0]), cmp);
+	qsort(list, count, sizeof(list[0]), cmp);
 
 	for (i = 0; i &lt; count; i++) {
-		if (filter == 1 &amp;&amp; list2[i].free_ts_nsec != 0)
-			continue;
-		fprintf(fout, "%d times, %d pages:\n%s\n",
-				list2[i].num, list2[i].page_num, list2[i].txt);
+		if (cull_st == 0)
+			fprintf(fout, "%d times, %d pages:\n%s\n",
+					list[i].num, list[i].page_num, list[i].txt);
+		else
+			fprintf(fout, "%d times, %d pages:\n%s\n",
+					list[i].num, list[i].page_num, list[i].stacktrace);
 	}
 	regfree(&amp;order_pattern);
 	regfree(&amp;pid_pattern);</pre><hr><pre>commit cf3c2c8678a0b21052d00b64d7a5903f3b1d1197
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Mar 24 18:09:26 2022 -0700

    tools/vm/page_owner_sort.c: support sorting by tgid and update documentation
    
    When the "page owner" information is read, the information sorted
    by TGID is expected.
    
    As a result, the following adjustments have been made:
    
    1. Add a new -P option to sort the information of blocks by TGID in
       ascending order.
    
    2. Adjust the order of member variables in block_list strust to avoid
       one 4 byte hole.
    
    3. Add -P option explanation in the document.
    
    Link: https://lkml.kernel.org/r/20220301151438.166118-3-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Zhenliang Wei &lt;weizhenliang@huawei.com&gt;
    Cc: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index 2ddb632d847b..941543a797fe 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -116,6 +116,7 @@ Usage
 		-a		Sort by memory allocation time.
 		-m		Sort by total memory.
 		-p		Sort by pid.
+		-P		Sort by tgid.
 		-r		Sort by memory release time.
 		-s		Sort by stack trace.
 		-t		Sort by times (default).
diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index 69fb6ca7c0b7..d166f2f900eb 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -25,16 +25,18 @@
 struct block_list {
 	char *txt;
 	char *stacktrace;
+	__u64 ts_nsec;
+	__u64 free_ts_nsec;
 	int len;
 	int num;
 	int page_num;
 	pid_t pid;
-	__u64 ts_nsec;
-	__u64 free_ts_nsec;
+	pid_t tgid;
 };
 
 static regex_t order_pattern;
 static regex_t pid_pattern;
+static regex_t tgid_pattern;
 static regex_t ts_nsec_pattern;
 static regex_t free_ts_nsec_pattern;
 static struct block_list *list;
@@ -91,6 +93,13 @@ static int compare_pid(const void *p1, const void *p2)
 	return l1-&gt;pid - l2-&gt;pid;
 }
 
+static int compare_tgid(const void *p1, const void *p2)
+{
+	const struct block_list *l1 = p1, *l2 = p2;
+
+	return l1-&gt;tgid - l2-&gt;tgid;
+}
+
 static int compare_ts(const void *p1, const void *p2)
 {
 	const struct block_list *l1 = p1, *l2 = p2;
@@ -170,6 +179,24 @@ static pid_t get_pid(char *buf)
 
 }
 
+static pid_t get_tgid(char *buf)
+{
+	pid_t tgid;
+	char tgid_str[FIELD_BUFF] = {0};
+	char *endptr;
+
+	search_pattern(&amp;tgid_pattern, tgid_str, buf);
+	errno = 0;
+	tgid = strtol(tgid_str, &amp;endptr, 10);
+	if (errno != 0 || endptr == tgid_str || *endptr != '\0') {
+		printf("wrong/invalid tgid in follow buf:\n%s\n", buf);
+		return -1;
+	}
+
+	return tgid;
+
+}
+
 static __u64 get_ts_nsec(char *buf)
 {
 	__u64 ts_nsec;
@@ -231,6 +258,7 @@ static void add_list(char *buf, int len)
 	list[list_size].txt[len] = 0;
 	list[list_size].stacktrace = strchr(list[list_size].txt, '\n') ?: "";
 	list[list_size].pid = get_pid(buf);
+	list[list_size].tgid = get_tgid(buf);
 	list[list_size].ts_nsec = get_ts_nsec(buf);
 	list[list_size].free_ts_nsec = get_free_ts_nsec(buf);
 	list_size++;
@@ -249,6 +277,7 @@ static void usage(void)
 		"-s	Sort by the stack trace.\n"
 		"-t	Sort by times (default).\n"
 		"-p	Sort by pid.\n"
+		"-P	Sort by tgid.\n"
 		"-a	Sort by memory allocate time.\n"
 		"-r	Sort by memory release time.\n"
 		"-c	Cull by comparing stacktrace instead of total block.\n"
@@ -268,7 +297,7 @@ int main(int argc, char **argv)
 	struct stat st;
 	int opt;
 
-	while ((opt = getopt(argc, argv, "acfmprst")) != -1)
+	while ((opt = getopt(argc, argv, "acfmprstP")) != -1)
 		switch (opt) {
 		case 'a':
 			cmp = compare_ts;
@@ -294,6 +323,9 @@ int main(int argc, char **argv)
 		case 't':
 			cmp = compare_num;
 			break;
+		case 'P':
+			cmp = compare_tgid;
+			break;
 		default:
 			usage();
 			exit(1);
@@ -314,6 +346,7 @@ int main(int argc, char **argv)
 
 	check_regcomp(&amp;order_pattern, "order\\s*([0-9]*),");
 	check_regcomp(&amp;pid_pattern, "pid\\s*([0-9]*),");
+	check_regcomp(&amp;tgid_pattern, "tgid\\s*([0-9]*) ");
 	check_regcomp(&amp;ts_nsec_pattern, "ts\\s*([0-9]*)\\s*ns,");
 	check_regcomp(&amp;free_ts_nsec_pattern, "free_ts\\s*([0-9]*)\\s*ns");
 	fstat(fileno(fin), &amp;st);
@@ -373,6 +406,7 @@ int main(int argc, char **argv)
 	}
 	regfree(&amp;order_pattern);
 	regfree(&amp;pid_pattern);
+	regfree(&amp;tgid_pattern);
 	regfree(&amp;ts_nsec_pattern);
 	regfree(&amp;free_ts_nsec_pattern);
 	return 0;</pre>
    <div class="pagination">
        <a href='21.html'>&lt;&lt;Prev</a><a href='21.html'>1</a><span>[2]</span><a href='21_3.html'>3</a><a href='21_4.html'>4</a><a href='21_3.html'>Next&gt;&gt;</a>
    <div>
</body>
