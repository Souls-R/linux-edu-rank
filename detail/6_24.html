<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_23.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><span>[24]</span><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_25.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d3bdd1c3140724967ca4136755538fa7c05c2b4e
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Tue Jan 19 16:10:55 2021 +0800

    extcon: Fix error handling in extcon_dev_register
    
    When devm_kcalloc() fails, we should execute device_unregister()
    to unregister edev-&gt;dev from system.
    
    Fixes: 046050f6e623e ("extcon: Update the prototype of extcon_register_notifier() with enum extcon")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Chanwoo Choi &lt;cw00.choi@samsung.com&gt;

diff --git a/drivers/extcon/extcon.c b/drivers/extcon/extcon.c
index 0a6438cbb3f3..e7a9561a826d 100644
--- a/drivers/extcon/extcon.c
+++ b/drivers/extcon/extcon.c
@@ -1241,6 +1241,7 @@ int extcon_dev_register(struct extcon_dev *edev)
 				sizeof(*edev-&gt;nh), GFP_KERNEL);
 	if (!edev-&gt;nh) {
 		ret = -ENOMEM;
+		device_unregister(&amp;edev-&gt;dev);
 		goto err_dev;
 	}
 </pre><hr><pre>commit 17e499a7d6b52ff3be565a2f6184883dd1fdd9af
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Wed Mar 3 20:12:36 2021 +0800

    power: supply: axp20x_usb_power: Add missing check in axp20x_usb_power_probe
    
    There are two regmap_update_bits() calls but only one of them has
    return value check, which is odd. Add a return value check and
    terminate the execution flow on failure just like the other call.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Sebastian Reichel &lt;sebastian.reichel@collabora.com&gt;

diff --git a/drivers/power/supply/axp20x_usb_power.c b/drivers/power/supply/axp20x_usb_power.c
index 8933ae26c3d6..7ed76eef8417 100644
--- a/drivers/power/supply/axp20x_usb_power.c
+++ b/drivers/power/supply/axp20x_usb_power.c
@@ -614,8 +614,10 @@ static int axp20x_usb_power_probe(struct platform_device *pdev)
 
 	if (power-&gt;axp20x_id == AXP813_ID) {
 		/* Enable USB Battery Charging specification detection */
-		regmap_update_bits(axp20x-&gt;regmap, AXP288_BC_GLOBAL,
+		ret = regmap_update_bits(axp20x-&gt;regmap, AXP288_BC_GLOBAL,
 				   AXP813_BC_EN, AXP813_BC_EN);
+		if (ret)
+			return ret;
 	}
 
 	psy_cfg.of_node = pdev-&gt;dev.of_node;</pre><hr><pre>commit 0ed0283f0297d0bb6b34a831a4989dd58f4c8368
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Wed Mar 3 15:34:08 2021 +0800

    sata_dwc_460ex: Fix missing check in sata_dwc_isr
    
    The return value of ata_qc_from_tag() is checked in the whole
    kernel except for two calls in sata_dwc_isr(), which may lead
    to null-pointer-dereference. Add return value checks to avoid
    such case.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/drivers/ata/sata_dwc_460ex.c b/drivers/ata/sata_dwc_460ex.c
index 9dcef6ac643b..f0ef844428bb 100644
--- a/drivers/ata/sata_dwc_460ex.c
+++ b/drivers/ata/sata_dwc_460ex.c
@@ -543,6 +543,11 @@ static irqreturn_t sata_dwc_isr(int irq, void *dev_instance)
 		hsdev-&gt;sactive_issued |= qcmd_tag_to_mask(tag);
 
 		qc = ata_qc_from_tag(ap, tag);
+		if (unlikely(!qc)) {
+			dev_err(ap-&gt;dev, "failed to get qc");
+			handled = 1;
+			goto DONE;
+		}
 		/*
 		 * Start FP DMA for NCQ command.  At this point the tag is the
 		 * active tag.  It is the tag that matches the command about to
@@ -658,6 +663,11 @@ static irqreturn_t sata_dwc_isr(int irq, void *dev_instance)
 
 		tag_mask &amp;= (~0x00000001);
 		qc = ata_qc_from_tag(ap, tag);
+		if (unlikely(!qc)) {
+			dev_err(ap-&gt;dev, "failed to get qc");
+			handled = 1;
+			goto DONE;
+		}
 
 		/* To be picked up by completion functions */
 		qc-&gt;ap-&gt;link.active_tag = tag;</pre><hr><pre>commit b52912b8293f2c496f42583e65599aee606a0c18
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sun Feb 28 17:44:23 2021 +0800

    e1000e: Fix error handling in e1000_set_d0_lplu_state_82571
    
    There is one e1e_wphy() call in e1000_set_d0_lplu_state_82571
    that we have caught its return value but lack further handling.
    Check and terminate the execution flow just like other e1e_wphy()
    in this function.
    
    Fixes: bc7f75fa9788 ("[E1000E]: New pci-express e1000 driver (currently for ICH9 devices only)")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Acked-by: Sasha Neftin &lt;sasha.neftin@intel.com&gt;
    Tested-by: Dvora Fuxbrumer &lt;dvorax.fuxbrumer@linux.intel.com&gt;
    Signed-off-by: Tony Nguyen &lt;anthony.l.nguyen@intel.com&gt;

diff --git a/drivers/net/ethernet/intel/e1000e/82571.c b/drivers/net/ethernet/intel/e1000e/82571.c
index 88faf05e23ba..0b1e890dd583 100644
--- a/drivers/net/ethernet/intel/e1000e/82571.c
+++ b/drivers/net/ethernet/intel/e1000e/82571.c
@@ -899,6 +899,8 @@ static s32 e1000_set_d0_lplu_state_82571(struct e1000_hw *hw, bool active)
 	} else {
 		data &amp;= ~IGP02E1000_PM_D0_LPLU;
 		ret_val = e1e_wphy(hw, IGP02E1000_PHY_POWER_MGMT, data);
+		if (ret_val)
+			return ret_val;
 		/* LPLU and SmartSpeed are mutually exclusive.  LPLU is used
 		 * during Dx states where the power conservation is most
 		 * important.  During driver activity we should enable</pre><hr><pre>commit f8096ff38d5f62d8a2c473e1bec0163a1b2b86d8
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Mar 1 20:50:57 2021 +0800

    drivers: misc: ad525x_dpot: Add missing check in dpot_read_spi
    
    The use of dpot_read_r8d8() after checking dpot-&gt;uid is similar.
    However, we check the return value and return an error code only
    in one path, which is odd.
    
    Link: https://lore.kernel.org/r/20210301125057.28819-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/misc/ad525x_dpot.c b/drivers/misc/ad525x_dpot.c
index 6f164522b028..5d8f3f6a95f2 100644
--- a/drivers/misc/ad525x_dpot.c
+++ b/drivers/misc/ad525x_dpot.c
@@ -139,6 +139,9 @@ static s32 dpot_read_spi(struct dpot_data *dpot, u8 reg)
 			value = dpot_read_r8d8(dpot,
 				DPOT_AD5291_READ_RDAC &lt;&lt; 2);
 
+			if (value &lt; 0)
+				return value;
+
 			if (dpot-&gt;uid == DPOT_UID(AD5291_ID))
 				value = value &gt;&gt; 2;
 </pre><hr><pre>commit 6dbbbe4cfd398704b72b21c1d4a5d3807e909d60
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Mon Mar 1 16:04:21 2021 +0800

    iio: gyro: mpu3050: Fix error handling in mpu3050_trigger_handler
    
    There is one regmap_bulk_read() call in mpu3050_trigger_handler
    that we have caught its return value bug lack further handling.
    Check and terminate the execution flow just like the other three
    regmap_bulk_read() calls in this function.
    
    Fixes: 3904b28efb2c7 ("iio: gyro: Add driver for the MPU-3050 gyroscope")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Linus Walleij &lt;linus.walleij@linaro.org&gt;
    Link: https://lore.kernel.org/r/20210301080421.13436-1-dinghao.liu@zju.edu.cn
    Cc: &lt;Stable@vger.kernel.org&gt;
    Signed-off-by: Jonathan Cameron &lt;Jonathan.Cameron@huawei.com&gt;

diff --git a/drivers/iio/gyro/mpu3050-core.c b/drivers/iio/gyro/mpu3050-core.c
index dfa31a23500f..ac90be03332a 100644
--- a/drivers/iio/gyro/mpu3050-core.c
+++ b/drivers/iio/gyro/mpu3050-core.c
@@ -551,6 +551,8 @@ static irqreturn_t mpu3050_trigger_handler(int irq, void *p)
 					       MPU3050_FIFO_R,
 					       &amp;fifo_values[offset],
 					       toread);
+			if (ret)
+				goto out_trigger_unlock;
 
 			dev_dbg(mpu3050-&gt;dev,
 				"%04x %04x %04x %04x %04x\n",</pre><hr><pre>commit 7a766381634da19fc837619b0a34590498d9d29a
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sun Jan 3 16:08:42 2021 +0800

    ixgbe: Fix memleak in ixgbe_configure_clsu32
    
    When ixgbe_fdir_write_perfect_filter_82599() fails,
    input allocated by kzalloc() has not been freed,
    which leads to memleak.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Paul Menzel &lt;pmenzel@molgen.mpg.de&gt;
    Tested-by: Tony Brelinski &lt;tonyx.brelinski@intel.com&gt;
    Signed-off-by: Tony Nguyen &lt;anthony.l.nguyen@intel.com&gt;

diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index fae84202d870..9f3f12e2ccf2 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -9565,8 +9565,10 @@ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
 	ixgbe_atr_compute_perfect_hash_82599(&amp;input-&gt;filter, mask);
 	err = ixgbe_fdir_write_perfect_filter_82599(hw, &amp;input-&gt;filter,
 						    input-&gt;sw_idx, queue);
-	if (!err)
-		ixgbe_update_ethtool_fdir_entry(adapter, input, input-&gt;sw_idx);
+	if (err)
+		goto err_out_w_lock;
+
+	ixgbe_update_ethtool_fdir_entry(adapter, input, input-&gt;sw_idx);
 	spin_unlock(&amp;adapter-&gt;fdir_perfect_lock);
 
 	if ((uhtid != 0x800) &amp;&amp; (adapter-&gt;jump_tables[uhtid]))</pre><hr><pre>commit 11b8ab3836454a2600e396f34731e491b661f9d5
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Tue Jan 5 14:03:40 2021 +0800

    ubifs: Fix memleak in ubifs_init_authentication
    
    When crypto_shash_digestsize() fails, c-&gt;hmac_tfm
    has not been freed before returning, which leads
    to memleak.
    
    Fixes: 49525e5eecca5 ("ubifs: Add helper functions for authentication support")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Zhihao Cheng &lt;chengzhihao1@huawei.com&gt;
    Signed-off-by: Richard Weinberger &lt;richard@nod.at&gt;

diff --git a/fs/ubifs/auth.c b/fs/ubifs/auth.c
index 51a7c8c2c3f0..e564d5ff8781 100644
--- a/fs/ubifs/auth.c
+++ b/fs/ubifs/auth.c
@@ -327,7 +327,7 @@ int ubifs_init_authentication(struct ubifs_info *c)
 		ubifs_err(c, "hmac %s is bigger than maximum allowed hmac size (%d &gt; %d)",
 			  hmac_name, c-&gt;hmac_desc_len, UBIFS_HMAC_ARR_SZ);
 		err = -EINVAL;
-		goto out_free_hash;
+		goto out_free_hmac;
 	}
 
 	err = crypto_shash_setkey(c-&gt;hmac_tfm, ukp-&gt;data, ukp-&gt;datalen);</pre><hr><pre>commit 0074946932cbd42647da947408a9d620746a4e0e
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sun Jan 31 18:09:14 2021 +0800

    ALSA: intel8x0: Fix missing check in snd_intel8x0m_create
    
    When device_type == DEVICE_ALI, we should also check the return
    value of pci_iomap() to avoid potential null pointer dereference.
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20210131100916.7915-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/pci/intel8x0m.c b/sound/pci/intel8x0m.c
index 1b7df0c4e57c..19872cecc9d2 100644
--- a/sound/pci/intel8x0m.c
+++ b/sound/pci/intel8x0m.c
@@ -1129,13 +1129,14 @@ static int snd_intel8x0m_create(struct snd_card *card,
 		chip-&gt;bmaddr = pci_iomap(pci, 3, 0);
 	else
 		chip-&gt;bmaddr = pci_iomap(pci, 1, 0);
+
+port_inited:
 	if (!chip-&gt;bmaddr) {
 		dev_err(card-&gt;dev, "Controller space ioremap problem\n");
 		snd_intel8x0m_free(chip);
 		return -EIO;
 	}
 
- port_inited:
 	/* initialize offsets */
 	chip-&gt;bdbars_count = 2;
 	tbl = intel_regs;</pre><hr><pre>commit ef49d40b61a3e18a11edd5eb1c30b0183af9e850
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Sun Jan 17 16:50:17 2021 +0800

    block: Fix an error handling in add_partition
    
    Once we have called device_initialize(), we should use put_device() to
    give up the reference on error, just like what we have done on failure
    of device_add().
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/partitions/core.c b/block/partitions/core.c
index e7d776db803b..23460cee9de5 100644
--- a/block/partitions/core.c
+++ b/block/partitions/core.c
@@ -384,7 +384,7 @@ static struct block_device *add_partition(struct gendisk *disk, int partno,
 
 	err = blk_alloc_devt(bdev, &amp;devt);
 	if (err)
-		goto out_bdput;
+		goto out_put;
 	pdev-&gt;devt = devt;
 
 	/* delay uevent until 'holders' subdir is created */</pre>
    <div class="pagination">
        <a href='6_23.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><span>[24]</span><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_25.html'>Next&gt;&gt;</a>
    <div>
</body>
