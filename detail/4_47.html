<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_46.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><span>[47]</span><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_48.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 87548c37c8bdbf98aea002c9c04e4dc8aa27fe1b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 17 04:04:44 2007 -0700

    knfsd: nfsd: remove superfluous assignment from nfsd_lookup
    
    The "err" variable will only be used in the final return, which always happens
    after either the preceding
    
            err = fh_compose(...);
    
    or after the following
    
            err = nfserrno(host_err);
    
    So the earlier assignment to err is ignored.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 0a18149ce963..ec6aaf8b0e36 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -168,8 +168,6 @@ nfsd_lookup(struct svc_rqst *rqstp, struct svc_fh *fhp, const char *name,
 	exp  = fhp-&gt;fh_export;
 	exp_get(exp);
 
-	err = nfserr_acces;
-
 	/* Lookup the name, but don't follow links */
 	if (isdotent(name, len)) {
 		if (len==1)</pre><hr><pre>commit df547efb03e3e8f9ea726e1d07fbbd6fd0706cd7
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 17 04:04:43 2007 -0700

    knfsd: nfsd4: simplify exp_pseudoroot arguments
    
    We're passing three arguments to exp_pseudoroot, two of which are just fields
    of the svc_rqst.  Soon we'll want to pass in a third field as well.  So let's
    just give up and pass in the whole struct svc_rqst.
    
    Also sneak in some minor style cleanups while we're at it.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index fbbbcc5a2fa3..af6abb2529c9 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -1235,8 +1235,7 @@ exp_find(struct auth_domain *clp, int fsid_type, u32 *fsidv,
  * export point with fsid==0
  */
 __be32
-exp_pseudoroot(struct auth_domain *clp, struct svc_fh *fhp,
-	       struct cache_req *creq)
+exp_pseudoroot(struct svc_rqst *rqstp, struct svc_fh *fhp)
 {
 	struct svc_export *exp;
 	__be32 rv;
@@ -1244,7 +1243,7 @@ exp_pseudoroot(struct auth_domain *clp, struct svc_fh *fhp,
 
 	mk_fsid(FSID_NUM, fsidv, 0, 0, 0, NULL);
 
-	exp = exp_find(clp, FSID_NUM, fsidv, creq);
+	exp = exp_find(rqstp-&gt;rq_client, FSID_NUM, fsidv, rqstp-&gt;rq_chandle);
 	if (PTR_ERR(exp) == -ENOENT)
 		return nfserr_perm;
 	if (IS_ERR(exp))
diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 8522729830db..a106e3be7c13 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -286,8 +286,7 @@ nfsd4_putrootfh(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	__be32 status;
 
 	fh_put(&amp;cstate-&gt;current_fh);
-	status = exp_pseudoroot(rqstp-&gt;rq_client, &amp;cstate-&gt;current_fh,
-			      &amp;rqstp-&gt;rq_chandle);
+	status = exp_pseudoroot(rqstp, &amp;cstate-&gt;current_fh);
 	return status;
 }
 
@@ -474,8 +473,8 @@ nfsd4_lookupp(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	__be32 ret;
 
 	fh_init(&amp;tmp_fh, NFS4_FHSIZE);
-	if((ret = exp_pseudoroot(rqstp-&gt;rq_client, &amp;tmp_fh,
-			      &amp;rqstp-&gt;rq_chandle)) != 0)
+	ret = exp_pseudoroot(rqstp, &amp;tmp_fh);
+	if (ret)
 		return ret;
 	if (tmp_fh.fh_dentry == cstate-&gt;current_fh.fh_dentry) {
 		fh_put(&amp;tmp_fh);
diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 15809dfd88a5..b0bfbda375e1 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1296,7 +1296,7 @@ static char *nfsd4_path(struct svc_rqst *rqstp, struct svc_export *exp, __be32 *
 	char *path, *rootpath;
 
 	fh_init(&amp;tmp_fh, NFS4_FHSIZE);
-	*stat = exp_pseudoroot(rqstp-&gt;rq_client, &amp;tmp_fh, &amp;rqstp-&gt;rq_chandle);
+	*stat = exp_pseudoroot(rqstp, &amp;tmp_fh);
 	if (*stat)
 		return NULL;
 	rootpath = tmp_fh.fh_export-&gt;ex_path;
diff --git a/include/linux/nfsd/export.h b/include/linux/nfsd/export.h
index 736f0eafcedf..5ed4f277eeac 100644
--- a/include/linux/nfsd/export.h
+++ b/include/linux/nfsd/export.h
@@ -135,7 +135,7 @@ struct svc_export *	exp_parent(struct auth_domain *clp,
 				   struct cache_req *reqp);
 int			exp_rootfh(struct auth_domain *, 
 					char *path, struct knfsd_fh *, int maxsize);
-__be32			exp_pseudoroot(struct auth_domain *, struct svc_fh *fhp, struct cache_req *creq);
+__be32			exp_pseudoroot(struct svc_rqst *, struct svc_fh *);
 __be32			nfserrno(int errno);
 
 extern struct cache_detail svc_export_cache;</pre><hr><pre>commit e677bfe4d451f8271986a229270c6eecd1f62b3f
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Tue Jul 17 04:04:42 2007 -0700

    knfsd: nfsd4: parse secinfo information in exports downcall
    
    We add a list of pseudoflavors to each export downcall, which will be used
    both as a list of security flavors allowed on that export, and (in the order
    given) as the list of pseudoflavors to return on secinfo calls.
    
    This patch parses the new downcall information and adds it to the export
    structure, but doesn't use it for anything yet.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index d4accdcb53a2..fbbbcc5a2fa3 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -33,6 +33,8 @@
 #include &lt;linux/nfsd/nfsfh.h&gt;
 #include &lt;linux/nfsd/syscall.h&gt;
 #include &lt;linux/lockd/bind.h&gt;
+#include &lt;linux/sunrpc/msg_prot.h&gt;
+#include &lt;linux/sunrpc/gss_api.h&gt;
 
 #define NFSDDBG_FACILITY	NFSDDBG_EXPORT
 
@@ -452,8 +454,48 @@ fsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc)
 	return err;
 }
 
+static int secinfo_parse(char **mesg, char *buf, struct svc_export *exp)
+{
+	int listsize, err;
+	struct exp_flavor_info *f;
+
+	err = get_int(mesg, &amp;listsize);
+	if (err)
+		return err;
+	if (listsize &lt; 0 || listsize &gt; MAX_SECINFO_LIST)
+		return -EINVAL;
+
+	for (f = exp-&gt;ex_flavors; f &lt; exp-&gt;ex_flavors + listsize; f++) {
+		err = get_int(mesg, &amp;f-&gt;pseudoflavor);
+		if (err)
+			return err;
+		/*
+		 * Just a quick sanity check; we could also try to check
+		 * whether this pseudoflavor is supported, but at worst
+		 * an unsupported pseudoflavor on the export would just
+		 * be a pseudoflavor that won't match the flavor of any
+		 * authenticated request.  The administrator will
+		 * probably discover the problem when someone fails to
+		 * authenticate.
+		 */
+		if (f-&gt;pseudoflavor &lt; 0)
+			return -EINVAL;
+		err = get_int(mesg, &amp;f-&gt;flags);
+		if (err)
+			return err;
+		/* Only some flags are allowed to differ between flavors: */
+		if (~NFSEXP_SECINFO_FLAGS &amp; (f-&gt;flags ^ exp-&gt;ex_flags))
+			return -EINVAL;
+	}
+	exp-&gt;ex_nflavors = listsize;
+	return 0;
+}
+
 #else /* CONFIG_NFSD_V4 */
-static inline int fsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc) { return 0; }
+static inline int
+fsloc_parse(char **mesg, char *buf, struct nfsd4_fs_locations *fsloc){return 0;}
+static inline int
+secinfo_parse(char **mesg, char *buf, struct svc_export *exp) { return 0; }
 #endif
 
 static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)
@@ -477,6 +519,9 @@ static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)
 
 	exp.ex_uuid = NULL;
 
+	/* secinfo */
+	exp.ex_nflavors = 0;
+
 	if (mesg[mlen-1] != '\n')
 		return -EINVAL;
 	mesg[mlen-1] = 0;
@@ -554,7 +599,9 @@ static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)
 					if (exp.ex_uuid == NULL)
 						err = -ENOMEM;
 				}
-			} else
+			} else if (strcmp(buf, "secinfo") == 0)
+				err = secinfo_parse(&amp;mesg, buf, &amp;exp);
+			else
 				/* quietly ignore unknown words and anything
 				 * following. Newer user-space can try to set
 				 * new values, then see what the result was.
@@ -655,6 +702,7 @@ static void export_update(struct cache_head *cnew, struct cache_head *citem)
 {
 	struct svc_export *new = container_of(cnew, struct svc_export, h);
 	struct svc_export *item = container_of(citem, struct svc_export, h);
+	int i;
 
 	new-&gt;ex_flags = item-&gt;ex_flags;
 	new-&gt;ex_anon_uid = item-&gt;ex_anon_uid;
@@ -670,6 +718,10 @@ static void export_update(struct cache_head *cnew, struct cache_head *citem)
 	item-&gt;ex_fslocs.locations_count = 0;
 	new-&gt;ex_fslocs.migrated = item-&gt;ex_fslocs.migrated;
 	item-&gt;ex_fslocs.migrated = 0;
+	new-&gt;ex_nflavors = item-&gt;ex_nflavors;
+	for (i = 0; i &lt; MAX_SECINFO_LIST; i++) {
+		new-&gt;ex_flavors[i] = item-&gt;ex_flavors[i];
+	}
 }
 
 static struct cache_head *svc_export_alloc(void)
diff --git a/include/linux/nfsd/export.h b/include/linux/nfsd/export.h
index 9f62d6182d32..736f0eafcedf 100644
--- a/include/linux/nfsd/export.h
+++ b/include/linux/nfsd/export.h
@@ -42,6 +42,8 @@
 #define	NFSEXP_NOACL		0x8000	/* reserved for possible ACL related use */
 #define NFSEXP_ALLFLAGS		0xFE3F
 
+/* The flags that may vary depending on security flavor: */
+#define NFSEXP_SECINFO_FLAGS	0
 
 #ifdef __KERNEL__
 
@@ -64,6 +66,19 @@ struct nfsd4_fs_locations {
 	int migrated;
 };
 
+/*
+ * We keep an array of pseudoflavors with the export, in order from most
+ * to least preferred.  For the forseeable future, we don't expect more
+ * than the eight pseudoflavors null, unix, krb5, krb5i, krb5p, skpm3,
+ * spkm3i, and spkm3p (and using all 8 at once should be rare).
+ */
+#define MAX_SECINFO_LIST	8
+
+struct exp_flavor_info {
+	u32	pseudoflavor;
+	u32	flags;
+};
+
 struct svc_export {
 	struct cache_head	h;
 	struct auth_domain *	ex_client;
@@ -76,6 +91,8 @@ struct svc_export {
 	int			ex_fsid;
 	unsigned char *		ex_uuid; /* 16 byte fsid */
 	struct nfsd4_fs_locations ex_fslocs;
+	int			ex_nflavors;
+	struct exp_flavor_info	ex_flavors[MAX_SECINFO_LIST];
 };
 
 /* an "export key" (expkey) maps a filehandlefragement to an</pre><hr><pre>commit c4170583f655dca5da32bd14173d6a93805fc48b
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Tue Jul 17 04:04:42 2007 -0700

    knfsd: nfsd4: store pseudoflavor in request
    
    Add a new field to the svc_rqst structure to record the pseudoflavor that the
    request was made with.  For now we record the pseudoflavor but don't use it
    for anything.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/include/linux/sunrpc/gss_api.h b/include/linux/sunrpc/gss_api.h
index bbac101ac372..459c5fc11d51 100644
--- a/include/linux/sunrpc/gss_api.h
+++ b/include/linux/sunrpc/gss_api.h
@@ -58,6 +58,7 @@ u32 gss_unwrap(
 u32 gss_delete_sec_context(
 		struct gss_ctx		**ctx_id);
 
+u32 gss_svc_to_pseudoflavor(struct gss_api_mech *, u32 service);
 u32 gss_pseudoflavor_to_service(struct gss_api_mech *, u32 pseudoflavor);
 char *gss_service_to_auth_domain_name(struct gss_api_mech *, u32 service);
 
diff --git a/include/linux/sunrpc/svc.h b/include/linux/sunrpc/svc.h
index 129d50f2225c..705a90aa345e 100644
--- a/include/linux/sunrpc/svc.h
+++ b/include/linux/sunrpc/svc.h
@@ -212,6 +212,7 @@ struct svc_rqst {
 	struct svc_pool *	rq_pool;	/* thread pool */
 	struct svc_procedure *	rq_procinfo;	/* procedure info */
 	struct auth_ops *	rq_authop;	/* authentication flavour */
+	u32			rq_flavor;	/* pseudoflavor */
 	struct svc_cred		rq_cred;	/* auth info */
 	struct sk_buff *	rq_skbuff;	/* fast recv inet buffer */
 	struct svc_deferred_req*rq_deferred;	/* deferred request we are replaying */
diff --git a/net/sunrpc/auth_gss/gss_mech_switch.c b/net/sunrpc/auth_gss/gss_mech_switch.c
index 26872517ccf3..61801a069ff0 100644
--- a/net/sunrpc/auth_gss/gss_mech_switch.c
+++ b/net/sunrpc/auth_gss/gss_mech_switch.c
@@ -193,6 +193,20 @@ gss_mech_get_by_pseudoflavor(u32 pseudoflavor)
 
 EXPORT_SYMBOL(gss_mech_get_by_pseudoflavor);
 
+u32
+gss_svc_to_pseudoflavor(struct gss_api_mech *gm, u32 service)
+{
+	int i;
+
+	for (i = 0; i &lt; gm-&gt;gm_pf_num; i++) {
+		if (gm-&gt;gm_pfs[i].service == service) {
+			return gm-&gt;gm_pfs[i].pseudoflavor;
+		}
+	}
+	return RPC_AUTH_MAXFLAVOR; /* illegal value */
+}
+EXPORT_SYMBOL(gss_svc_to_pseudoflavor);
+
 u32
 gss_pseudoflavor_to_service(struct gss_api_mech *gm, u32 pseudoflavor)
 {
diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index c094583386fd..7a3e1758bea1 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -1131,6 +1131,8 @@ svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)
 		}
 		svcdata-&gt;rsci = rsci;
 		cache_get(&amp;rsci-&gt;h);
+		rqstp-&gt;rq_flavor = gss_svc_to_pseudoflavor(
+					rsci-&gt;mechctx-&gt;mech_type, gc-&gt;gc_svc);
 		ret = SVC_OK;
 		goto out;
 	}
diff --git a/net/sunrpc/svcauth_unix.c b/net/sunrpc/svcauth_unix.c
index 07dcd20cbee4..d9fdf2e4d242 100644
--- a/net/sunrpc/svcauth_unix.c
+++ b/net/sunrpc/svcauth_unix.c
@@ -5,6 +5,7 @@
 #include &lt;linux/sunrpc/xdr.h&gt;
 #include &lt;linux/sunrpc/svcsock.h&gt;
 #include &lt;linux/sunrpc/svcauth.h&gt;
+#include &lt;linux/sunrpc/gss_api.h&gt;
 #include &lt;linux/err.h&gt;
 #include &lt;linux/seq_file.h&gt;
 #include &lt;linux/hash.h&gt;
@@ -707,6 +708,7 @@ svcauth_null_accept(struct svc_rqst *rqstp, __be32 *authp)
 	svc_putnl(resv, RPC_AUTH_NULL);
 	svc_putnl(resv, 0);
 
+	rqstp-&gt;rq_flavor = RPC_AUTH_NULL;
 	return SVC_OK;
 }
 
@@ -784,6 +786,7 @@ svcauth_unix_accept(struct svc_rqst *rqstp, __be32 *authp)
 	svc_putnl(resv, RPC_AUTH_NULL);
 	svc_putnl(resv, 0);
 
+	rqstp-&gt;rq_flavor = RPC_AUTH_UNIX;
 	return SVC_OK;
 
 badcred:</pre><hr><pre>commit 42ed95c4e7415714aaab604ae7b1602b87b27b73
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Jul 17 04:04:41 2007 -0700

    knfsd: nfsd4: build rpcsec_gss whenever nfsd4 is built
    
    Select rpcsec_gss support whenever asked for NFSv4 support.  The rfc actually
    requires gss, and gss is also the main reason to migrate to v4.  We already do
    this on the client side.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/Kconfig b/fs/Kconfig
index ee11f8d94085..613df554728d 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -1675,6 +1675,7 @@ config NFSD_V3_ACL
 config NFSD_V4
 	bool "Provide NFSv4 server support (EXPERIMENTAL)"
 	depends on NFSD_V3 &amp;&amp; EXPERIMENTAL
+	select RPCSEC_GSS_KRB5
 	help
 	  If you would like to include the NFSv4 server as well as the NFSv2
 	  and NFSv3 servers, say Y here.  This feature is experimental, and</pre><hr><pre>commit 4b4e5a1411c8b970983fb6022db1da31c4f5c301
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sun Jul 15 23:41:53 2007 -0700

    Fix trivial typos in anon_inodes.c comments
    
    Trivial typo and grammar fixes.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Cc: Davide Libenzi &lt;davidel@xmailserver.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/anon_inodes.c b/fs/anon_inodes.c
index 40fe3a3222e4..a260198306c2 100644
--- a/fs/anon_inodes.c
+++ b/fs/anon_inodes.c
@@ -53,7 +53,7 @@ static struct dentry_operations anon_inodefs_dentry_operations = {
 };
 
 /**
- * anon_inode_getfd - creates a new file instance by hooking it up to and
+ * anon_inode_getfd - creates a new file instance by hooking it up to an
  *                    anonymous inode, and a dentry that describe the "class"
  *                    of the file
  *
@@ -66,7 +66,7 @@ static struct dentry_operations anon_inodefs_dentry_operations = {
  *
  * Creates a new file by hooking it on a single inode. This is useful for files
  * that do not need to have a full-fledged inode in order to operate correctly.
- * All the files created with anon_inode_getfd() will share a single inode, by
+ * All the files created with anon_inode_getfd() will share a single inode,
  * hence saving memory and avoiding code duplication for the file/inode/dentry
  * setup.
  */
@@ -141,9 +141,9 @@ int anon_inode_getfd(int *pfd, struct inode **pinode, struct file **pfile,
 }
 
 /*
- * A single inode exist for all anon_inode files. Contrary to pipes,
- * anon_inode inodes has no per-instance data associated, so we can avoid
- * the allocation of multiple of them.
+ * A single inode exists for all anon_inode files. Contrary to pipes,
+ * anon_inode inodes have no associated per-instance data, so we need
+ * only allocate one of them.
  */
 static struct inode *anon_inode_mkinode(void)
 {</pre><hr><pre>commit 3ee17abd14c728d4e0ca7a991c58f2250cb091af
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Feb 21 00:58:50 2007 -0500

    locks: factor out generic/filesystem switch from test_lock
    
    Factor out the code that switches between generic and filesystem-specific lock
    methods; eventually we want to call this from lock managers (lockd and nfsd)
    too; currently they only call the generic methods.
    
    This patch does that for test_lock.
    
    Note that this hasn't been necessary until recently, because the few
    filesystems that define -&gt;lock() (nfs, cifs...) aren't exportable via NFS.
    However GFS (and, in the future, other cluster filesystems) need to implement
    their own locking to get cluster-coherent locking, and also want to be able to
    export locking to NFS (lockd and NFSv4).
    
    So we accomplish this by factoring out code such as this and exporting it for
    the use of lockd and nfsd.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 749a0dc7cd4b..a31648e3ec1b 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1611,6 +1611,24 @@ asmlinkage long sys_flock(unsigned int fd, unsigned int cmd)
 	return error;
 }
 
+/**
+ * vfs_test_lock - test file byte range lock
+ * @filp: The file to test lock for
+ * @fl: The lock to test
+ * @conf: Place to return a copy of the conflicting lock, if found
+ *
+ * Returns -ERRNO on failure.  Indicates presence of conflicting lock by
+ * setting conf-&gt;fl_type to something other than F_UNLCK.
+ */
+int vfs_test_lock(struct file *filp, struct file_lock *fl)
+{
+	if (filp-&gt;f_op &amp;&amp; filp-&gt;f_op-&gt;lock)
+		return filp-&gt;f_op-&gt;lock(filp, F_GETLK, fl);
+	posix_test_lock(filp, fl);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(vfs_test_lock);
+
 static int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)
 {
 	flock-&gt;l_pid = fl-&gt;fl_pid;
@@ -1663,12 +1681,9 @@ int fcntl_getlk(struct file *filp, struct flock __user *l)
 	if (error)
 		goto out;
 
-	if (filp-&gt;f_op &amp;&amp; filp-&gt;f_op-&gt;lock) {
-		error = filp-&gt;f_op-&gt;lock(filp, F_GETLK, &amp;file_lock);
-		if (error &lt; 0)
-			goto out;
-	} else
-		posix_test_lock(filp, &amp;file_lock);
+	error = vfs_test_lock(filp, &amp;file_lock);
+	if (error)
+		goto out;
  
 	flock.l_type = file_lock.fl_type;
 	if (file_lock.fl_type != F_UNLCK) {
@@ -1797,13 +1812,10 @@ int fcntl_getlk64(struct file *filp, struct flock64 __user *l)
 	if (error)
 		goto out;
 
-	if (filp-&gt;f_op &amp;&amp; filp-&gt;f_op-&gt;lock) {
-		error = filp-&gt;f_op-&gt;lock(filp, F_GETLK, &amp;file_lock);
-		if (error &lt; 0)
-			goto out;
-	} else
-		posix_test_lock(filp, &amp;file_lock);
- 
+	error = vfs_test_lock(filp, &amp;file_lock);
+	if (error)
+		goto out;
+
 	flock.l_type = file_lock.fl_type;
 	if (file_lock.fl_type != F_UNLCK)
 		posix_lock_to_flock64(&amp;flock, &amp;file_lock);
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 9e1ddffe3884..2a2a43988f50 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -856,6 +856,7 @@ extern int posix_lock_file_conf(struct file *, struct file_lock *, struct file_l
 extern int posix_lock_file(struct file *, struct file_lock *);
 extern int posix_lock_file_wait(struct file *, struct file_lock *);
 extern int posix_unblock_lock(struct file *, struct file_lock *);
+extern int vfs_test_lock(struct file *, struct file_lock *);
 extern int flock_lock_file_wait(struct file *filp, struct file_lock *fl);
 extern int __break_lease(struct inode *inode, unsigned int flags);
 extern void lease_get_mtime(struct inode *, struct timespec *time);</pre><hr><pre>commit 70cc6487a4e08b8698c0e2ec935fb48d10490162
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Feb 22 18:48:53 2007 -0500

    locks: make -&gt;lock release private data before returning in GETLK case
    
    The file_lock argument to -&gt;lock is used to return the conflicting lock
    when found.  There's no reason for the filesystem to return any private
    information with this conflicting lock, but nfsv4 is.
    
    Fix nfsv4 client, and modify locks.c to stop calling fl_release_private
    for it in this case.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Cc: "Trond Myklebust" &lt;Trond.Myklebust@netapp.com&gt;"

diff --git a/fs/locks.c b/fs/locks.c
index 957775ba6468..b07e6e6f819b 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1665,8 +1665,6 @@ int fcntl_getlk(struct file *filp, struct flock __user *l)
 
 	if (filp-&gt;f_op &amp;&amp; filp-&gt;f_op-&gt;lock) {
 		error = filp-&gt;f_op-&gt;lock(filp, F_GETLK, &amp;file_lock);
-		if (file_lock.fl_ops &amp;&amp; file_lock.fl_ops-&gt;fl_release_private)
-			file_lock.fl_ops-&gt;fl_release_private(&amp;file_lock);
 		if (error &lt; 0)
 			goto out;
 		else
@@ -1804,8 +1802,6 @@ int fcntl_getlk64(struct file *filp, struct flock64 __user *l)
 
 	if (filp-&gt;f_op &amp;&amp; filp-&gt;f_op-&gt;lock) {
 		error = filp-&gt;f_op-&gt;lock(filp, F_GETLK, &amp;file_lock);
-		if (file_lock.fl_ops &amp;&amp; file_lock.fl_ops-&gt;fl_release_private)
-			file_lock.fl_ops-&gt;fl_release_private(&amp;file_lock);
 		if (error &lt; 0)
 			goto out;
 		else
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index f52cf5c33c6c..d9000ec52f72 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -3018,6 +3018,7 @@ static int _nfs4_proc_getlk(struct nfs4_state *state, int cmd, struct file_lock
 		case -NFS4ERR_DENIED:
 			status = 0;
 	}
+	request-&gt;fl_ops-&gt;fl_release_private(request);
 out:
 	up_read(&amp;clp-&gt;cl_sem);
 	return status;</pre><hr><pre>commit 08efa202eb398ce7939885a4a01df370fd392068
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue May 1 10:56:25 2007 -0400

    NFS4: invalidate cached acl on setacl
    
    The ACL that the server sets may not be exactly the one we set--for
    example, it may silently turn off bits that it does not support.  So we
    should remove any cached ACL so that any subsequent request for the ACL
    will go to the server.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index f52cf5c33c6c..3b5ca1b15fe9 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -2647,8 +2647,7 @@ static int __nfs4_proc_set_acl(struct inode *inode, const void *buf, size_t bufl
 	nfs_inode_return_delegation(inode);
 	buf_to_pages(buf, buflen, arg.acl_pages, &amp;arg.acl_pgbase);
 	ret = rpc_call_sync(NFS_CLIENT(inode), &amp;msg, 0);
-	if (ret == 0)
-		nfs4_write_cached_acl(inode, buf, buflen);
+	nfs_zap_caches(inode);
 	return ret;
 }
 </pre><hr><pre>commit c2fa1b8a6c059dd08a802545fed3badc8df2adc1
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue Feb 20 16:10:11 2007 -0500

    locks: create posix-to-flock helper functions
    
    Factor out a bit of messy code by creating posix-to-flock counterparts
    to the existing flock-to-posix helper functions.
    
    Cc: Christoph Hellwig &lt;hch@infradead.org&gt;
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 1a00b8bc65ed..957775ba6468 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1611,6 +1611,38 @@ asmlinkage long sys_flock(unsigned int fd, unsigned int cmd)
 	return error;
 }
 
+static int posix_lock_to_flock(struct flock *flock, struct file_lock *fl)
+{
+	flock-&gt;l_pid = fl-&gt;fl_pid;
+#if BITS_PER_LONG == 32
+	/*
+	 * Make sure we can represent the posix lock via
+	 * legacy 32bit flock.
+	 */
+	if (fl-&gt;fl_start &gt; OFFT_OFFSET_MAX)
+		return -EOVERFLOW;
+	if (fl-&gt;fl_end != OFFSET_MAX &amp;&amp; fl-&gt;fl_end &gt; OFFT_OFFSET_MAX)
+		return -EOVERFLOW;
+#endif
+	flock-&gt;l_start = fl-&gt;fl_start;
+	flock-&gt;l_len = fl-&gt;fl_end == OFFSET_MAX ? 0 :
+		fl-&gt;fl_end - fl-&gt;fl_start + 1;
+	flock-&gt;l_whence = 0;
+	return 0;
+}
+
+#if BITS_PER_LONG == 32
+static void posix_lock_to_flock64(struct flock64 *flock, struct file_lock *fl)
+{
+	flock-&gt;l_pid = fl-&gt;fl_pid;
+	flock-&gt;l_start = fl-&gt;fl_start;
+	flock-&gt;l_len = fl-&gt;fl_end == OFFSET_MAX ? 0 :
+		fl-&gt;fl_end - fl-&gt;fl_start + 1;
+	flock-&gt;l_whence = 0;
+	flock-&gt;l_type = fl-&gt;fl_type;
+}
+#endif
+
 /* Report the first existing lock that would conflict with l.
  * This implements the F_GETLK command of fcntl().
  */
@@ -1645,24 +1677,9 @@ int fcntl_getlk(struct file *filp, struct flock __user *l)
  
 	flock.l_type = F_UNLCK;
 	if (fl != NULL) {
-		flock.l_pid = fl-&gt;fl_pid;
-#if BITS_PER_LONG == 32
-		/*
-		 * Make sure we can represent the posix lock via
-		 * legacy 32bit flock.
-		 */
-		error = -EOVERFLOW;
-		if (fl-&gt;fl_start &gt; OFFT_OFFSET_MAX)
-			goto out;
-		if ((fl-&gt;fl_end != OFFSET_MAX)
-		    &amp;&amp; (fl-&gt;fl_end &gt; OFFT_OFFSET_MAX))
+		error = posix_lock_to_flock(&amp;flock, fl);
+		if (error)
 			goto out;
-#endif
-		flock.l_start = fl-&gt;fl_start;
-		flock.l_len = fl-&gt;fl_end == OFFSET_MAX ? 0 :
-			fl-&gt;fl_end - fl-&gt;fl_start + 1;
-		flock.l_whence = 0;
-		flock.l_type = fl-&gt;fl_type;
 	}
 	error = -EFAULT;
 	if (!copy_to_user(l, &amp;flock, sizeof(flock)))
@@ -1798,14 +1815,8 @@ int fcntl_getlk64(struct file *filp, struct flock64 __user *l)
 	}
  
 	flock.l_type = F_UNLCK;
-	if (fl != NULL) {
-		flock.l_pid = fl-&gt;fl_pid;
-		flock.l_start = fl-&gt;fl_start;
-		flock.l_len = fl-&gt;fl_end == OFFSET_MAX ? 0 :
-			fl-&gt;fl_end - fl-&gt;fl_start + 1;
-		flock.l_whence = 0;
-		flock.l_type = fl-&gt;fl_type;
-	}
+	if (fl != NULL)
+		posix_lock_to_flock64(&amp;flock, fl);
 	error = -EFAULT;
 	if (!copy_to_user(l, &amp;flock, sizeof(flock)))
 		error = 0;</pre>
    <div class="pagination">
        <a href='4_46.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><span>[47]</span><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_48.html'>Next&gt;&gt;</a>
    <div>
</body>
