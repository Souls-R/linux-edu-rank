<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_4.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><span>[5]</span><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_6.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6c21660fe221a15c789dee2bc2fd95516bc5aeaf
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Jan 18 21:03:06 2024 +0800

    vlan: skip nested type that is not IFLA_VLAN_QOS_MAPPING
    
    In the vlan_changelink function, a loop is used to parse the nested
    attributes IFLA_VLAN_EGRESS_QOS and IFLA_VLAN_INGRESS_QOS in order to
    obtain the struct ifla_vlan_qos_mapping. These two nested attributes are
    checked in the vlan_validate_qos_map function, which calls
    nla_validate_nested_deprecated with the vlan_map_policy.
    
    However, this deprecated validator applies a LIBERAL strictness, allowing
    the presence of an attribute with the type IFLA_VLAN_QOS_UNSPEC.
    Consequently, the loop in vlan_changelink may parse an attribute of type
    IFLA_VLAN_QOS_UNSPEC and believe it carries a payload of
    struct ifla_vlan_qos_mapping, which is not necessarily true.
    
    To address this issue and ensure compatibility, this patch introduces two
    type checks that skip attributes whose type is not IFLA_VLAN_QOS_MAPPING.
    
    Fixes: 07b5b17e157b ("[VLAN]: Use rtnl_link API")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Link: https://lore.kernel.org/r/20240118130306.1644001-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/8021q/vlan_netlink.c b/net/8021q/vlan_netlink.c
index 214532173536..a3b68243fd4b 100644
--- a/net/8021q/vlan_netlink.c
+++ b/net/8021q/vlan_netlink.c
@@ -118,12 +118,16 @@ static int vlan_changelink(struct net_device *dev, struct nlattr *tb[],
 	}
 	if (data[IFLA_VLAN_INGRESS_QOS]) {
 		nla_for_each_nested(attr, data[IFLA_VLAN_INGRESS_QOS], rem) {
+			if (nla_type(attr) != IFLA_VLAN_QOS_MAPPING)
+				continue;
 			m = nla_data(attr);
 			vlan_dev_set_ingress_priority(dev, m-&gt;to, m-&gt;from);
 		}
 	}
 	if (data[IFLA_VLAN_EGRESS_QOS]) {
 		nla_for_each_nested(attr, data[IFLA_VLAN_EGRESS_QOS], rem) {
+			if (nla_type(attr) != IFLA_VLAN_QOS_MAPPING)
+				continue;
 			m = nla_data(attr);
 			err = vlan_dev_set_egress_priority(dev, m-&gt;from, m-&gt;to);
 			if (err)</pre><hr><pre>commit 04ae3eb470e52a3c41babe85ff8cee195e4dcbea
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Wed Jan 17 15:13:28 2024 +0800

    drm/lima: fix a memleak in lima_heap_alloc
    
    When lima_vm_map_bo fails, the resources need to be deallocated, or
    there will be memleaks.
    
    Fixes: 6aebc51d7aef ("drm/lima: support heap buffer creation")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Qiang Yu &lt;yuq825@gmail.com&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/20240117071328.3811480-1-alexious@zju.edu.cn

diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index 4f9736e5f929..7ea244d876ca 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -75,29 +75,34 @@ int lima_heap_alloc(struct lima_bo *bo, struct lima_vm *vm)
 	} else {
 		bo-&gt;base.sgt = kmalloc(sizeof(*bo-&gt;base.sgt), GFP_KERNEL);
 		if (!bo-&gt;base.sgt) {
-			sg_free_table(&amp;sgt);
-			return -ENOMEM;
+			ret = -ENOMEM;
+			goto err_out0;
 		}
 	}
 
 	ret = dma_map_sgtable(dev, &amp;sgt, DMA_BIDIRECTIONAL, 0);
-	if (ret) {
-		sg_free_table(&amp;sgt);
-		kfree(bo-&gt;base.sgt);
-		bo-&gt;base.sgt = NULL;
-		return ret;
-	}
+	if (ret)
+		goto err_out1;
 
 	*bo-&gt;base.sgt = sgt;
 
 	if (vm) {
 		ret = lima_vm_map_bo(vm, bo, old_size &gt;&gt; PAGE_SHIFT);
 		if (ret)
-			return ret;
+			goto err_out2;
 	}
 
 	bo-&gt;heap_size = new_size;
 	return 0;
+
+err_out2:
+	dma_unmap_sgtable(dev, &amp;sgt, DMA_BIDIRECTIONAL, 0);
+err_out1:
+	kfree(bo-&gt;base.sgt);
+	bo-&gt;base.sgt = NULL;
+err_out0:
+	sg_free_table(&amp;sgt);
+	return ret;
 }
 
 int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,</pre><hr><pre>commit b33fb5b801c6db408b774a68e7c8722796b59ecc
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Jan 10 14:14:00 2024 +0800

    net: qualcomm: rmnet: fix global oob in rmnet_policy
    
    The variable rmnet_link_ops assign a *bigger* maxtype which leads to a
    global out-of-bounds read when parsing the netlink attributes. See bug
    trace below:
    
    ==================================================================
    BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline]
    BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
    Read of size 1 at addr ffffffff92c438d0 by task syz-executor.6/84207
    
    CPU: 0 PID: 84207 Comm: syz-executor.6 Tainted: G                 N 6.1.0 #3
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106
     print_address_description mm/kasan/report.c:284 [inline]
     print_report+0x172/0x475 mm/kasan/report.c:395
     kasan_report+0xbb/0x1c0 mm/kasan/report.c:495
     validate_nla lib/nlattr.c:386 [inline]
     __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
     __nla_parse+0x3e/0x50 lib/nlattr.c:697
     nla_parse_nested_deprecated include/net/netlink.h:1248 [inline]
     __rtnl_newlink+0x50a/0x1880 net/core/rtnetlink.c:3485
     rtnl_newlink+0x64/0xa0 net/core/rtnetlink.c:3594
     rtnetlink_rcv_msg+0x43c/0xd70 net/core/rtnetlink.c:6091
     netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540
     netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
     netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345
     netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921
     sock_sendmsg_nosec net/socket.c:714 [inline]
     sock_sendmsg+0x154/0x190 net/socket.c:734
     ____sys_sendmsg+0x6df/0x840 net/socket.c:2482
     ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536
     __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    RIP: 0033:0x7fdcf2072359
    Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48
    RSP: 002b:00007fdcf13e3168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
    RAX: ffffffffffffffda RBX: 00007fdcf219ff80 RCX: 00007fdcf2072359
    RDX: 0000000000000000 RSI: 0000000020000200 RDI: 0000000000000003
    RBP: 00007fdcf20bd493 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
    R13: 00007fffbb8d7bdf R14: 00007fdcf13e3300 R15: 0000000000022000
     &lt;/TASK&gt;
    
    The buggy address belongs to the variable:
     rmnet_policy+0x30/0xe0
    
    The buggy address belongs to the physical page:
    page:0000000065bdeb3c refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x155243
    flags: 0x200000000001000(reserved|node=0|zone=2)
    raw: 0200000000001000 ffffea00055490c8 ffffea00055490c8 0000000000000000
    raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffffffff92c43780: f9 f9 f9 f9 00 00 00 02 f9 f9 f9 f9 00 00 00 07
     ffffffff92c43800: f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9 06 f9 f9 f9
    &gt;ffffffff92c43880: f9 f9 f9 f9 00 00 00 00 00 00 f9 f9 f9 f9 f9 f9
                                                     ^
     ffffffff92c43900: 00 00 00 00 00 00 00 00 07 f9 f9 f9 f9 f9 f9 f9
     ffffffff92c43980: 00 00 00 07 f9 f9 f9 f9 00 00 00 05 f9 f9 f9 f9
    
    According to the comment of `nla_parse_nested_deprecated`, the maxtype
    should be len(destination array) - 1. Hence use `IFLA_RMNET_MAX` here.
    
    Fixes: 14452ca3b5ce ("net: qualcomm: rmnet: Export mux_id and flags to netlink")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Subash Abhinov Kasiviswanathan &lt;quic_subashab@quicinc.com&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Reviewed-by: Jiri Pirko &lt;jiri@nvidia.com&gt;
    Link: https://lore.kernel.org/r/20240110061400.3356108-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
index 39d24e07f306..5b69b9268c75 100644
--- a/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
+++ b/drivers/net/ethernet/qualcomm/rmnet/rmnet_config.c
@@ -396,7 +396,7 @@ static int rmnet_fill_info(struct sk_buff *skb, const struct net_device *dev)
 
 struct rtnl_link_ops rmnet_link_ops __read_mostly = {
 	.kind		= "rmnet",
-	.maxtype	= __IFLA_RMNET_MAX,
+	.maxtype	= IFLA_RMNET_MAX,
 	.priv_size	= sizeof(struct rmnet_priv),
 	.setup		= rmnet_vnd_setup,
 	.validate	= rmnet_rtnl_validate,</pre><hr><pre>commit 2f3be3ca779b11c332441b10e00443a2510f4d7b
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Sun Dec 24 16:22:47 2023 +0800

    drm/amd/pm/smu7: fix a memleak in smu7_hwmgr_backend_init
    
    The hwmgr-&gt;backend, (i.e. data) allocated by kzalloc is not freed in
    the error-handling paths of smu7_get_evv_voltages and
    smu7_update_edc_leakage_table. However, it did be freed in the
    error-handling of phm_initializa_dynamic_state_adjustment_rule_settings,
    by smu7_hwmgr_backend_fini. So the lack of free in smu7_get_evv_voltages
    and smu7_update_edc_leakage_table is considered a memleak in this patch.
    
    Fixes: 599a7e9fe1b6 ("drm/amd/powerplay: implement smu7 hwmgr to manager asics with smu ip version 7.")
    Fixes: 8f0804c6b7d0 ("drm/amd/pm: add edc leakage controller setting")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
index 11372fcc59c8..b1a8799e2dee 100644
--- a/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
+++ b/drivers/gpu/drm/amd/pm/powerplay/hwmgr/smu7_hwmgr.c
@@ -2974,6 +2974,8 @@ static int smu7_hwmgr_backend_init(struct pp_hwmgr *hwmgr)
 		result = smu7_get_evv_voltages(hwmgr);
 		if (result) {
 			pr_info("Get EVV Voltage Failed.  Abort Driver loading!\n");
+			kfree(hwmgr-&gt;backend);
+			hwmgr-&gt;backend = NULL;
 			return -EINVAL;
 		}
 	} else {
@@ -3019,8 +3021,10 @@ static int smu7_hwmgr_backend_init(struct pp_hwmgr *hwmgr)
 	}
 
 	result = smu7_update_edc_leakage_table(hwmgr);
-	if (result)
+	if (result) {
+		smu7_hwmgr_backend_fini(hwmgr);
 		return result;
+	}
 
 	return 0;
 }</pre><hr><pre>commit 89709105a6091948ffb6ec2427954cbfe45358ce
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Mon Dec 4 17:14:16 2023 +0800

    drm/vmwgfx: fix a memleak in vmw_gmrid_man_get_node
    
    When ida_alloc_max fails, resources allocated before should be freed,
    including *res allocated by kmalloc and ttm_resource_init.
    
    Fixes: d3bcb4b02fe9 ("drm/vmwgfx: switch the TTM backends to self alloc")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Zack Rusin &lt;zack.rusin@broadcom.com&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/20231204091416.3308430-1-alexious@zju.edu.cn

diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c b/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c
index ceb4d3d3b965..a0b47c9b33f5 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_gmrid_manager.c
@@ -64,8 +64,11 @@ static int vmw_gmrid_man_get_node(struct ttm_resource_manager *man,
 	ttm_resource_init(bo, place, *res);
 
 	id = ida_alloc_max(&amp;gman-&gt;gmr_ida, gman-&gt;max_gmr_ids - 1, GFP_KERNEL);
-	if (id &lt; 0)
+	if (id &lt; 0) {
+		ttm_resource_fini(man, *res);
+		kfree(*res);
 		return id;
+	}
 
 	spin_lock(&amp;gman-&gt;lock);
 </pre><hr><pre>commit 89f45c30172c80e55c887f32f1af8e184124577b
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Wed Dec 27 15:02:27 2023 +0800

    net/qla3xxx: fix potential memleak in ql_alloc_buffer_queues
    
    When dma_alloc_coherent() fails, we should free qdev-&gt;lrg_buf
    to prevent potential memleak.
    
    Fixes: 1357bfcf7106 ("qla3xxx: Dynamically size the rx buffer queue based on the MTU.")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20231227070227.10527-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/qlogic/qla3xxx.c b/drivers/net/ethernet/qlogic/qla3xxx.c
index 0d57ffcedf0c..fc78bc959ded 100644
--- a/drivers/net/ethernet/qlogic/qla3xxx.c
+++ b/drivers/net/ethernet/qlogic/qla3xxx.c
@@ -2591,6 +2591,7 @@ static int ql_alloc_buffer_queues(struct ql3_adapter *qdev)
 
 	if (qdev-&gt;lrg_buf_q_alloc_virt_addr == NULL) {
 		netdev_err(qdev-&gt;ndev, "lBufQ failed\n");
+		kfree(qdev-&gt;lrg_buf);
 		return -ENOMEM;
 	}
 	qdev-&gt;lrg_buf_q_virt_addr = qdev-&gt;lrg_buf_q_alloc_virt_addr;
@@ -2615,6 +2616,7 @@ static int ql_alloc_buffer_queues(struct ql3_adapter *qdev)
 				  qdev-&gt;lrg_buf_q_alloc_size,
 				  qdev-&gt;lrg_buf_q_alloc_virt_addr,
 				  qdev-&gt;lrg_buf_q_alloc_phy_addr);
+		kfree(qdev-&gt;lrg_buf);
 		return -ENOMEM;
 	}
 </pre><hr><pre>commit 9aa6543ee6d3a717268f210b263b0f1286a0bf1e
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Thu Dec 14 16:39:19 2023 +0800

    nvdimm-btt: simplify code with the scope based resource management
    
    Use the scope based resource management (defined in
    linux/cleanup.h) to automate resource lifetime
    control on struct btt_sb *super in discover_arenas().
    
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Dave Jiang &lt;dave.jiang@intel.com&gt;
    Link: https://lore.kernel.org/r/20231214083919.22218-1-dinghao.liu@zju.edu.cn
    Signed-off-by: Ira Weiny &lt;ira.weiny@intel.com&gt;

diff --git a/drivers/nvdimm/btt.c b/drivers/nvdimm/btt.c
index d5593b0dc700..32a9e2f543c5 100644
--- a/drivers/nvdimm/btt.c
+++ b/drivers/nvdimm/btt.c
@@ -16,6 +16,7 @@
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/nd.h&gt;
 #include &lt;linux/backing-dev.h&gt;
+#include &lt;linux/cleanup.h&gt;
 #include "btt.h"
 #include "nd.h"
 
@@ -847,23 +848,20 @@ static int discover_arenas(struct btt *btt)
 {
 	int ret = 0;
 	struct arena_info *arena;
-	struct btt_sb *super;
 	size_t remaining = btt-&gt;rawsize;
 	u64 cur_nlba = 0;
 	size_t cur_off = 0;
 	int num_arenas = 0;
 
-	super = kzalloc(sizeof(*super), GFP_KERNEL);
+	struct btt_sb *super __free(kfree) = kzalloc(sizeof(*super), GFP_KERNEL);
 	if (!super)
 		return -ENOMEM;
 
 	while (remaining) {
 		/* Alloc memory for arena */
 		arena = alloc_arena(btt, 0, 0, 0);
-		if (!arena) {
-			ret = -ENOMEM;
-			goto out_super;
-		}
+		if (!arena)
+			return -ENOMEM;
 
 		arena-&gt;infooff = cur_off;
 		ret = btt_info_read(arena, super);
@@ -919,14 +917,11 @@ static int discover_arenas(struct btt *btt)
 	btt-&gt;nlba = cur_nlba;
 	btt-&gt;init_state = INIT_READY;
 
-	kfree(super);
 	return ret;
 
  out:
 	kfree(arena);
 	free_arenas(btt);
- out_super:
-	kfree(super);
 	return ret;
 }
 </pre><hr><pre>commit 2ab1efad60ad119b616722b81eeb73060728028c
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Dec 28 14:43:58 2023 +0800

    net/sched: cls_api: complement tcf_tfilter_dump_policy
    
    In function `tc_dump_tfilter`, the attributes array is parsed via
    tcf_tfilter_dump_policy which only describes TCA_DUMP_FLAGS. However,
    the NLA TCA_CHAIN is also accessed with `nla_get_u32`.
    
    The access to TCA_CHAIN is introduced in commit 5bc1701881e3 ("net:
    sched: introduce multichain support for filters") and no nla_policy is
    provided for parsing at that point. Later on, tcf_tfilter_dump_policy is
    introduced in commit f8ab1807a9c9 ("net: sched: introduce terse dump
    flag") while still ignoring the fact that TCA_CHAIN needs a check. This
    patch does that by complementing the policy to allow the access
    discussed here can be safe as other cases just choose rtm_tca_policy as
    the parsing policy.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Acked-by: Jamal Hadi Salim &lt;jhs@mojatatu.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c
index 3c50b4037755..adf5de1ff773 100644
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@ -2735,6 +2735,7 @@ static bool tcf_chain_dump(struct tcf_chain *chain, struct Qdisc *q, u32 parent,
 }
 
 static const struct nla_policy tcf_tfilter_dump_policy[TCA_MAX + 1] = {
+	[TCA_CHAIN]      = { .type = NLA_U32 },
 	[TCA_DUMP_FLAGS] = NLA_POLICY_BITFIELD32(TCA_DUMP_FLAGS_TERSE),
 };
 </pre><hr><pre>commit d5a306aedba34e640b11d7026dbbafb78ee3a5f6
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Mon Dec 25 19:29:14 2023 +0800

    sfc: fix a double-free bug in efx_probe_filters
    
    In efx_probe_filters, the channel-&gt;rps_flow_id is freed in a
    efx_for_each_channel marco  when success equals to 0.
    However, after the following call chain:
    
    ef100_net_open
      |-&gt; efx_probe_filters
      |-&gt; ef100_net_stop
            |-&gt; efx_remove_filters
    
    The channel-&gt;rps_flow_id is freed again in the efx_for_each_channel of
    efx_remove_filters, triggering a double-free bug.
    
    Fixes: a9dc3d5612ce ("sfc_ef100: RX filter table management and related gubbins")
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Reviewed-by: Edward Cree &lt;ecree.xilinx@gmail.com&gt;
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20231225112915.3544581-1-alexious@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/ethernet/sfc/rx_common.c b/drivers/net/ethernet/sfc/rx_common.c
index d2f35ee15eff..fac227d372db 100644
--- a/drivers/net/ethernet/sfc/rx_common.c
+++ b/drivers/net/ethernet/sfc/rx_common.c
@@ -823,8 +823,10 @@ int efx_probe_filters(struct efx_nic *efx)
 		}
 
 		if (!success) {
-			efx_for_each_channel(channel, efx)
+			efx_for_each_channel(channel, efx) {
 				kfree(channel-&gt;rps_flow_id);
+				channel-&gt;rps_flow_id = NULL;
+			}
 			efx-&gt;type-&gt;filter_table_remove(efx);
 			rc = -ENOMEM;
 			goto out_unlock;</pre><hr><pre>commit c2b2ee36250d967c21890cb801e24af4b6a9eaa5
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Dec 21 00:34:51 2023 +0800

    bridge: cfm: fix enum typo in br_cc_ccm_tx_parse
    
    It appears that there is a typo in the code where the nlattr array is
    being parsed with policy br_cfm_cc_ccm_tx_policy, but the instance is
    being accessed via IFLA_BRIDGE_CFM_CC_RDI_INSTANCE, which is associated
    with the policy br_cfm_cc_rdi_policy.
    
    This problem was introduced by commit 2be665c3940d ("bridge: cfm: Netlink
    SET configuration Interface.").
    
    Though it seems like a harmless typo since these two enum owns the exact
    same value (1 here), it is quite misleading hence fix it by using the
    correct enum IFLA_BRIDGE_CFM_CC_CCM_TX_INSTANCE here.
    
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Acked-by: Nikolay Aleksandrov &lt;razor@blackwall.org&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/bridge/br_cfm_netlink.c b/net/bridge/br_cfm_netlink.c
index 5c4c369f8536..2faab44652e7 100644
--- a/net/bridge/br_cfm_netlink.c
+++ b/net/bridge/br_cfm_netlink.c
@@ -362,7 +362,7 @@ static int br_cc_ccm_tx_parse(struct net_bridge *br, struct nlattr *attr,
 
 	memset(&amp;tx_info, 0, sizeof(tx_info));
 
-	instance = nla_get_u32(tb[IFLA_BRIDGE_CFM_CC_RDI_INSTANCE]);
+	instance = nla_get_u32(tb[IFLA_BRIDGE_CFM_CC_CCM_TX_INSTANCE]);
 	nla_memcpy(&amp;tx_info.dmac.addr,
 		   tb[IFLA_BRIDGE_CFM_CC_CCM_TX_DMAC],
 		   sizeof(tx_info.dmac.addr));</pre>
    <div class="pagination">
        <a href='6_4.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><span>[5]</span><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_6.html'>Next&gt;&gt;</a>
    <div>
</body>
