<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Queensland</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Queensland</h1>
    <div class="pagination">
        <a href='18_5.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><a href='18_3.html'>3</a><a href='18_4.html'>4</a><a href='18_5.html'>5</a><span>[6]</span><a href='18_7.html'>7</a><a href='18_7.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d536e9c41f78c9959c585181f8a1e7fe8b157197
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Thu Aug 10 03:22:21 2006 -0300

    V4L/DVB (4497): Reset USB part of DViCO Dual Digital during PCI driver attach
    
    If the FX2 does not reset properly during reboot, it can present an
    invalid USB device ID and fail to attach.  Prevent this situation
    from occuring by resetting the USB part of the card when the PCI part
    probes.
    Also fix the GPIO configurations so that analog capture will not
    inadvertantly reset the USB part.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/cx88/cx88-cards.c b/drivers/media/video/cx88/cx88-cards.c
index ba3ff57bba75..29ba5d53ce34 100644
--- a/drivers/media/video/cx88/cx88-cards.c
+++ b/drivers/media/video/cx88/cx88-cards.c
@@ -1041,11 +1041,11 @@ struct cx88_board cx88_boards[] = {
 		.input          = {{
 			.type   = CX88_VMUX_COMPOSITE1,
 			.vmux   = 1,
-			.gpio0  = 0x000027df,
+			.gpio0  = 0x000067df,
 		 },{
 			.type   = CX88_VMUX_SVIDEO,
 			.vmux   = 2,
-			.gpio0  = 0x000027df,
+			.gpio0  = 0x000067df,
 		}},
 		.dvb            = 1,
 	},
@@ -1759,9 +1759,15 @@ void cx88_card_setup(struct cx88_core *core)
 		cx_write(MO_GP0_IO, 0x000007f8);
 		cx_write(MO_GP1_IO, 0x00000001);
 		break;
+	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL:
+		/* GPIO0:6 is hooked to FX2 reset pin */
+		cx_set(MO_GP0_IO, 0x00004040);
+		cx_clear(MO_GP0_IO, 0x00000040);
+		msleep(1000);
+		cx_set(MO_GP0_IO, 0x00004040);
+		/* FALLTHROUGH */
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PLUS:
-	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL:
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID:
 		/* GPIO0:0 is hooked to mt352 reset pin */
 		cx_set(MO_GP0_IO, 0x00000101);</pre><hr><pre>commit fc3398d8b317bebe542f57c65572d9b9f52112f7
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Thu Aug 10 03:17:42 2006 -0300

    V4L/DVB (4496): Tuning tweaks for ZL10353
    
    More register setup which improves the ZL10353's tuning characteristics.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/dvb/frontends/zl10353.c b/drivers/media/dvb/frontends/zl10353.c
index 84abbaf362fb..0e9b59af271e 100644
--- a/drivers/media/dvb/frontends/zl10353.c
+++ b/drivers/media/dvb/frontends/zl10353.c
@@ -140,6 +140,8 @@ static int zl10353_set_parameters(struct dvb_frontend *fe,
 	zl10353_single_write(fe, 0x5E, 0x00);
 	zl10353_single_write(fe, 0x65, 0x5A);
 	zl10353_single_write(fe, 0x66, 0xE9);
+	zl10353_single_write(fe, 0x6C, 0xCD);
+	zl10353_single_write(fe, 0x6D, 0x7E);
 	zl10353_single_write(fe, 0x62, 0x0A);
 
 	// if there is no attached secondary tuner, we call set_params to program
@@ -168,6 +170,7 @@ static int zl10353_set_parameters(struct dvb_frontend *fe,
 	// even if there isn't a PLL attached to the secondary bus
 	zl10353_write(fe, pllbuf, sizeof(pllbuf));
 
+	zl10353_single_write(fe, 0x5F, 0x13);
 	zl10353_single_write(fe, 0x70, 0x01);
 	udelay(250);
 	zl10353_single_write(fe, 0xE4, 0x00);</pre><hr><pre>commit 8fb957841b2f4311e6418dcbef24564e4cebb87d
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Thu Aug 10 03:17:16 2006 -0300

    V4L/DVB (4495): Fix "no data from ZL10353 based USB tuner" problem
    
    Force parallel transport stream output on the ZL10353 attached to a
    bluebird device.
    Addresses the problem where a frontend lock was observed, but no MPEG
    transport data was received.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/dvb/dvb-usb/cxusb.c b/drivers/media/dvb/dvb-usb/cxusb.c
index ac72e7ed9fcc..c710c0176e07 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.c
+++ b/drivers/media/dvb/dvb-usb/cxusb.c
@@ -349,6 +349,7 @@ static struct mt352_config cxusb_dee1601_config = {
 
 static struct zl10353_config cxusb_zl10353_dee1601_config = {
 	.demod_address = 0x0f,
+	.parallel_ts = 1,
 };
 
 static struct mt352_config cxusb_mt352_config = {
diff --git a/drivers/media/dvb/frontends/zl10353.c b/drivers/media/dvb/frontends/zl10353.c
index 953fb55d87b6..84abbaf362fb 100644
--- a/drivers/media/dvb/frontends/zl10353.c
+++ b/drivers/media/dvb/frontends/zl10353.c
@@ -243,9 +243,12 @@ static int zl10353_init(struct dvb_frontend *fe)
 
 	if (debug_regs)
 		zl10353_dump_regs(fe);
+	if (state-&gt;config.parallel_ts)
+		zl10353_reset_attach[2] &amp;= ~0x20;
 
 	/* Do a "hard" reset if not already done */
-	if (zl10353_read_register(state, 0x50) != 0x03) {
+	if (zl10353_read_register(state, 0x50) != zl10353_reset_attach[1] ||
+	    zl10353_read_register(state, 0x51) != zl10353_reset_attach[2]) {
 		rc = zl10353_write(fe, zl10353_reset_attach,
 				   sizeof(zl10353_reset_attach));
 		if (debug_regs)
diff --git a/drivers/media/dvb/frontends/zl10353.h b/drivers/media/dvb/frontends/zl10353.h
index 6aec655d8814..79a947215c4d 100644
--- a/drivers/media/dvb/frontends/zl10353.h
+++ b/drivers/media/dvb/frontends/zl10353.h
@@ -31,6 +31,9 @@ struct zl10353_config
 
 	/* set if no pll is connected to the secondary i2c bus */
 	int no_tuner;
+
+	/* set if parallel ts output is required */
+	int parallel_ts;
 };
 
 #if defined(CONFIG_DVB_ZL10353) || defined(CONFIG_DVB_ZL10353_MODULE)</pre><hr><pre>commit 47922e9c3f583adf05a23842ff98f3b0bf7eec6d
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Sat Aug 5 23:47:16 2006 -0300

    V4L/DVB (4441): Flexcop/nxt200x attach fix
    
    Address another case where the test in dvb-pll to see if a tuner's
    PLL responds when attaching may fail.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/dvb/b2c2/flexcop-fe-tuner.c b/drivers/media/dvb/b2c2/flexcop-fe-tuner.c
index 0c3bab37d8df..b8ba87863457 100644
--- a/drivers/media/dvb/b2c2/flexcop-fe-tuner.c
+++ b/drivers/media/dvb/b2c2/flexcop-fe-tuner.c
@@ -527,7 +527,7 @@ int flexcop_frontend_init(struct flexcop_device *fc)
 	/* try the air atsc 2nd generation (nxt2002) */
 	if ((fc-&gt;fe = dvb_attach(nxt200x_attach, &amp;samsung_tbmv_config, &amp;fc-&gt;i2c_adap)) != NULL) {
 		fc-&gt;dev_type          = FC_AIR_ATSC2;
-		dvb_attach(dvb_pll_attach, fc-&gt;fe, 0x61, &amp;fc-&gt;i2c_adap, &amp;dvb_pll_samsung_tbmv);
+		dvb_attach(dvb_pll_attach, fc-&gt;fe, 0x61, NULL, &amp;dvb_pll_samsung_tbmv);
 		info("found the nxt2002 at i2c address: 0x%02x",samsung_tbmv_config.demod_address);
 	} else
 	/* try the air atsc 3nd generation (lgdt3303) */</pre><hr><pre>commit c162dff6437d5f66c272b1811074ee32c53d17b9
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Tue Aug 8 15:48:08 2006 -0300

    V4L/DVB (4436): Dvb-pll support for MT352/ZL10353 based tuners.
    
    Typical wiring of MT352 and ZL10353 based tuners differs from dvb-pll's
    expectation that the PLL is directly accessible.  On these boards, the
    PLL is actually hidden behind the demodulator, and as such can only be
    accessed via the demodulator's interface.  It was failing to communicate
    with the PLL during an attach test and subsequently not connecting the
    tuner ops.
    By passing a NULL I2C bus handle to dvb_pll_attach, this accessibility
    check can be bypassed.  Do this for the affected boards.  Also fix a
    possible NULL dereference at sleep time, which would otherwise be
    exposed by this change.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Acked-by: Andrew de Quincey &lt;adq_dvb@lidskialf.net&gt;
    Acked-by: Manu Abraham &lt;manu@linuxtv.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/dvb/frontends/dvb-pll.c b/drivers/media/dvb/frontends/dvb-pll.c
index c92877baada2..b7e7108ee5b3 100644
--- a/drivers/media/dvb/frontends/dvb-pll.c
+++ b/drivers/media/dvb/frontends/dvb-pll.c
@@ -493,6 +493,9 @@ static int dvb_pll_sleep(struct dvb_frontend *fe)
 	int i;
 	int result;
 
+	if (priv-&gt;i2c == NULL)
+		return -EINVAL;
+
 	for (i = 0; i &lt; priv-&gt;pll_desc-&gt;count; i++) {
 		if (priv-&gt;pll_desc-&gt;entries[i].limit == 0)
 			break;
diff --git a/drivers/media/video/cx88/cx88-dvb.c b/drivers/media/video/cx88/cx88-dvb.c
index 81654954c338..b39b3629f1d0 100644
--- a/drivers/media/video/cx88/cx88-dvb.c
+++ b/drivers/media/video/cx88/cx88-dvb.c
@@ -543,8 +543,7 @@ static int dvb_register(struct cx8802_dev *dev)
 						 &amp;dev-&gt;core-&gt;i2c_adap);
 		if (dev-&gt;dvb.frontend != NULL) {
 			dvb_attach(dvb_pll_attach, dev-&gt;dvb.frontend, 0x60,
-				       &amp;dev-&gt;core-&gt;i2c_adap,
-				       &amp;dvb_pll_thomson_dtt7579);
+				   NULL, &amp;dvb_pll_thomson_dtt7579);
 			break;
 		}
 		/* ZL10353 replaces MT352 on later cards */
@@ -552,8 +551,7 @@ static int dvb_register(struct cx8802_dev *dev)
 						   &amp;dev-&gt;core-&gt;i2c_adap);
 		if (dev-&gt;dvb.frontend != NULL) {
 			dvb_attach(dvb_pll_attach, dev-&gt;dvb.frontend, 0x60,
-				       &amp;dev-&gt;core-&gt;i2c_adap,
-				       &amp;dvb_pll_thomson_dtt7579);
+				   NULL, &amp;dvb_pll_thomson_dtt7579);
 		}
 		break;
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL:
@@ -563,8 +561,7 @@ static int dvb_register(struct cx8802_dev *dev)
 						 &amp;dev-&gt;core-&gt;i2c_adap);
 		if (dev-&gt;dvb.frontend != NULL) {
 			dvb_attach(dvb_pll_attach, dev-&gt;dvb.frontend, 0x61,
-				       &amp;dev-&gt;core-&gt;i2c_adap,
-				       &amp;dvb_pll_thomson_dtt7579);
+				   NULL, &amp;dvb_pll_thomson_dtt7579);
 			break;
 		}
 		/* ZL10353 replaces MT352 on later cards */
@@ -572,8 +569,7 @@ static int dvb_register(struct cx8802_dev *dev)
 						   &amp;dev-&gt;core-&gt;i2c_adap);
 		if (dev-&gt;dvb.frontend != NULL) {
 			dvb_attach(dvb_pll_attach, dev-&gt;dvb.frontend, 0x61,
-				       &amp;dev-&gt;core-&gt;i2c_adap,
-				       &amp;dvb_pll_thomson_dtt7579);
+				   NULL, &amp;dvb_pll_thomson_dtt7579);
 		}
 		break;
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:
@@ -581,8 +577,7 @@ static int dvb_register(struct cx8802_dev *dev)
 						 &amp;dev-&gt;core-&gt;i2c_adap);
 		if (dev-&gt;dvb.frontend != NULL) {
 			dvb_attach(dvb_pll_attach, dev-&gt;dvb.frontend, 0x61,
-				       &amp;dev-&gt;core-&gt;i2c_adap,
-				       &amp;dvb_pll_lg_z201);
+				   NULL, &amp;dvb_pll_lg_z201);
 		}
 		break;
 	case CX88_BOARD_KWORLD_DVB_T:
@@ -592,8 +587,7 @@ static int dvb_register(struct cx8802_dev *dev)
 						 &amp;dev-&gt;core-&gt;i2c_adap);
 		if (dev-&gt;dvb.frontend != NULL) {
 			dvb_attach(dvb_pll_attach, dev-&gt;dvb.frontend, 0x61,
-				       &amp;dev-&gt;core-&gt;i2c_adap,
-				       &amp;dvb_pll_unknown_1);
+				   NULL, &amp;dvb_pll_unknown_1);
 		}
 		break;
 	case CX88_BOARD_DNTV_LIVE_DVB_T_PRO:</pre><hr><pre>commit 69b27e3dfebff8f59e979d57263e1cd83c4d8370
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Tue Feb 28 20:23:11 2006 -0300

    V4L/DVB (3410): Move DViCO hybrid initialisation data from stack.
    
    The init_data array is never changed and need not be on the stack.
    Turn it into a static variable.
    
    Signed-off-by: Michael Krufky &lt;mkrufky@linuxtv.org&gt;
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/cx88/cx88-cards.c b/drivers/media/video/cx88/cx88-cards.c
index d91e5b3a64ef..f655567a8ecd 100644
--- a/drivers/media/video/cx88/cx88-cards.c
+++ b/drivers/media/video/cx88/cx88-cards.c
@@ -1435,7 +1435,7 @@ static void dvico_fusionhdtv_hybrid_init(struct cx88_core *core)
 {
 	struct i2c_msg msg = { .addr = 0x45, .flags = 0 };
 	int i, err;
-	u8 init_bufs[13][5] = {
+	static u8 init_bufs[13][5] = {
 		{ 0x10, 0x00, 0x20, 0x01, 0x03 },
 		{ 0x10, 0x10, 0x01, 0x00, 0x21 },
 		{ 0x10, 0x10, 0x10, 0x00, 0xCA },</pre><hr><pre>commit 780dfef37e2c941985b708f67aa0074edc922bea
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Tue Feb 28 08:34:59 2006 -0300

    V4L/DVB (3408): DViCO FusionHDTV DVB-T Hybrid and ZL10353-based FusionHDTV DVB-T Plus support
    
    Add support for the FE6600 tuner used on the DVB-T Hybrid board.
    Add support for the Zarlink ZL10353 DVB-T demodulator, which supersedes the
    MT352, used on the DViCO FusionHDTV DVB-T Hybrid and later model Plus boards.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/Documentation/video4linux/CARDLIST.cx88 b/Documentation/video4linux/CARDLIST.cx88
index d852ad4f93a2..3b39a91b24bd 100644
--- a/Documentation/video4linux/CARDLIST.cx88
+++ b/Documentation/video4linux/CARDLIST.cx88
@@ -44,3 +44,4 @@
  43 -&gt; KWorld/VStream XPert DVB-T with cx22702             [17de:08a1]
  44 -&gt; DViCO FusionHDTV DVB-T Dual Digital                 [18ac:db50,18ac:db54]
  45 -&gt; KWorld HardwareMpegTV XPert                         [17de:0840]
+ 46 -&gt; DViCO FusionHDTV DVB-T Hybrid                       [18ac:db40,18ac:db44]
diff --git a/Documentation/video4linux/CARDLIST.tuner b/Documentation/video4linux/CARDLIST.tuner
index de48438d5115..ab344c94c0a2 100644
--- a/Documentation/video4linux/CARDLIST.tuner
+++ b/Documentation/video4linux/CARDLIST.tuner
@@ -70,3 +70,4 @@ tuner=68 - Philips TUV1236D ATSC/NTSC dual in
 tuner=69 - Tena TNF 5335 MF
 tuner=70 - Samsung TCPN 2121P30A
 tuner=71 - Xceive xc3028
+tuner=72 - FE6600
diff --git a/drivers/media/dvb/frontends/Kconfig b/drivers/media/dvb/frontends/Kconfig
index c676b1e23ab0..a1a894d81040 100644
--- a/drivers/media/dvb/frontends/Kconfig
+++ b/drivers/media/dvb/frontends/Kconfig
@@ -116,6 +116,12 @@ config DVB_MT352
 	help
 	  A DVB-T tuner module. Say Y when you want to support this frontend.
 
+config DVB_ZL10353
+	tristate "Zarlink ZL10353 based"
+	depends on DVB_CORE
+	help
+	  A DVB-T tuner module. Say Y when you want to support this frontend.
+
 config DVB_DIB3000MB
 	tristate "DiBcom 3000M-B"
 	depends on DVB_CORE
diff --git a/drivers/media/dvb/frontends/Makefile b/drivers/media/dvb/frontends/Makefile
index 1af769cd90c0..d09b6071fbaf 100644
--- a/drivers/media/dvb/frontends/Makefile
+++ b/drivers/media/dvb/frontends/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_DVB_TDA1004X) += tda1004x.o
 obj-$(CONFIG_DVB_SP887X) += sp887x.o
 obj-$(CONFIG_DVB_NXT6000) += nxt6000.o
 obj-$(CONFIG_DVB_MT352) += mt352.o
+obj-$(CONFIG_DVB_ZL10353) += zl10353.o
 obj-$(CONFIG_DVB_CX22702) += cx22702.o
 obj-$(CONFIG_DVB_TDA10021) += tda10021.o
 obj-$(CONFIG_DVB_STV0297) += stv0297.o
diff --git a/drivers/media/dvb/frontends/dvb-pll.c b/drivers/media/dvb/frontends/dvb-pll.c
index 4f682534df42..8a4c904d3a27 100644
--- a/drivers/media/dvb/frontends/dvb-pll.c
+++ b/drivers/media/dvb/frontends/dvb-pll.c
@@ -404,6 +404,21 @@ struct dvb_pll_desc dvb_pll_philips_td1316 = {
 };
 EXPORT_SYMBOL(dvb_pll_philips_td1316);
 
+/* FE6600 used on DViCO Hybrid */
+struct dvb_pll_desc dvb_pll_unknown_fe6600 = {
+	.name = "FE6600",
+	.min =  44250000,
+	.max = 858000000,
+	.count = 4,
+	.entries = {
+		{ 250000000, 36213333, 166667, 0xb4, 0x12 },
+		{ 455000000, 36213333, 166667, 0xfe, 0x11 },
+		{ 775500000, 36213333, 166667, 0xbc, 0x18 },
+		{ 999999999, 36213333, 166667, 0xf4, 0x18 },
+	}
+};
+EXPORT_SYMBOL(dvb_pll_unknown_fe6600);
+
 /* ----------------------------------------------------------- */
 /* code                                                        */
 
diff --git a/drivers/media/dvb/frontends/dvb-pll.h b/drivers/media/dvb/frontends/dvb-pll.h
index 56c3cd76a7fa..8a7f0b941c38 100644
--- a/drivers/media/dvb/frontends/dvb-pll.h
+++ b/drivers/media/dvb/frontends/dvb-pll.h
@@ -42,6 +42,8 @@ extern struct dvb_pll_desc dvb_pll_samsung_tbmv;
 extern struct dvb_pll_desc dvb_pll_philips_sd1878_tda8261;
 extern struct dvb_pll_desc dvb_pll_philips_td1316;
 
+extern struct dvb_pll_desc dvb_pll_unknown_fe6600;
+
 int dvb_pll_configure(struct dvb_pll_desc *desc, u8 *buf,
 		      u32 freq, int bandwidth);
 
diff --git a/drivers/media/dvb/frontends/zl10353.c b/drivers/media/dvb/frontends/zl10353.c
new file mode 100644
index 000000000000..23846c4452ad
--- /dev/null
+++ b/drivers/media/dvb/frontends/zl10353.c
@@ -0,0 +1,311 @@
+/*
+ * Driver for Zarlink DVB-T ZL10353 demodulator
+ *
+ * Copyright (C) 2006 Christopher Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
+ */
+
+#include &lt;linux/kernel.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/moduleparam.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/delay.h&gt;
+#include &lt;linux/string.h&gt;
+#include &lt;linux/slab.h&gt;
+
+#include "dvb_frontend.h"
+#include "zl10353_priv.h"
+#include "zl10353.h"
+
+struct zl10353_state {
+	struct i2c_adapter *i2c;
+	struct dvb_frontend frontend;
+	struct dvb_frontend_ops ops;
+
+	struct zl10353_config config;
+};
+
+static int debug_regs = 0;
+
+static int zl10353_single_write(struct dvb_frontend *fe, u8 reg, u8 val)
+{
+	struct zl10353_state *state = fe-&gt;demodulator_priv;
+	u8 buf[2] = { reg, val };
+	struct i2c_msg msg = { .addr = state-&gt;config.demod_address, .flags = 0,
+			       .buf = buf, .len = 2 };
+	int err = i2c_transfer(state-&gt;i2c, &amp;msg, 1);
+	if (err != 1) {
+		printk("zl10353: write to reg %x failed (err = %d)!\n", reg, err);
+		return err;
+	}
+	return 0;
+}
+
+int zl10353_write(struct dvb_frontend *fe, u8 *ibuf, int ilen)
+{
+	int err, i;
+	for (i = 0; i &lt; ilen - 1; i++)
+		if ((err = zl10353_single_write(fe, ibuf[0] + i, ibuf[i + 1])))
+			return err;
+
+	return 0;
+}
+
+static int zl10353_read_register(struct zl10353_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[1] = { reg };
+	u8 b1[1] = { 0 };
+	struct i2c_msg msg[2] = { { .addr = state-&gt;config.demod_address,
+				    .flags = 0,
+				    .buf = b0, .len = 1 },
+				  { .addr = state-&gt;config.demod_address,
+				    .flags = I2C_M_RD,
+				    .buf = b1, .len = 1 } };
+
+	ret = i2c_transfer(state-&gt;i2c, msg, 2);
+
+	if (ret != 2) {
+		printk("%s: readreg error (reg=%d, ret==%i)\n",
+		       __FUNCTION__, reg, ret);
+		return ret;
+	}
+
+	return b1[0];
+}
+
+void zl10353_dump_regs(struct dvb_frontend *fe)
+{
+	struct zl10353_state *state = fe-&gt;demodulator_priv;
+	char buf[52], buf2[4];
+	int ret;
+	u8 reg;
+
+	/* Dump all registers. */
+	for (reg = 0; ; reg++) {
+		if (reg % 16 == 0) {
+			if (reg)
+				printk(KERN_DEBUG "%s\n", buf);
+			sprintf(buf, "%02x: ", reg);
+		}
+		ret = zl10353_read_register(state, reg);
+		if (ret &gt;= 0)
+			sprintf(buf2, "%02x ", (u8)ret);
+		else
+			strcpy(buf2, "-- ");
+		strcat(buf, buf2);
+		if (reg == 0xff)
+			break;
+	}
+	printk(KERN_DEBUG "%s\n", buf);
+}
+
+static int zl10353_sleep(struct dvb_frontend *fe)
+{
+	static u8 zl10353_softdown[] = { 0x50, 0x0C, 0x44 };
+
+	zl10353_write(fe, zl10353_softdown, sizeof(zl10353_softdown));
+	return 0;
+}
+
+static int zl10353_set_parameters(struct dvb_frontend *fe,
+				  struct dvb_frontend_parameters *param)
+{
+	struct zl10353_state *state = fe-&gt;demodulator_priv;
+	u8 pllbuf[6] = { 0x67 };
+
+	/* These settings set "auto-everything" and start the FSM. */
+	zl10353_single_write(fe, 0x55, 0x80);
+	udelay(200);
+	zl10353_single_write(fe, 0xEA, 0x01);
+	udelay(200);
+	zl10353_single_write(fe, 0xEA, 0x00);
+
+	zl10353_single_write(fe, 0x56, 0x28);
+	zl10353_single_write(fe, 0x89, 0x20);
+	zl10353_single_write(fe, 0x5E, 0x00);
+	zl10353_single_write(fe, 0x65, 0x5A);
+	zl10353_single_write(fe, 0x66, 0xE9);
+	zl10353_single_write(fe, 0x62, 0x0A);
+
+	state-&gt;config.pll_set(fe, param, pllbuf + 1);
+	zl10353_write(fe, pllbuf, sizeof(pllbuf));
+
+	zl10353_single_write(fe, 0x70, 0x01);
+	udelay(250);
+	zl10353_single_write(fe, 0xE4, 0x00);
+	zl10353_single_write(fe, 0xE5, 0x2A);
+	zl10353_single_write(fe, 0xE9, 0x02);
+	zl10353_single_write(fe, 0xE7, 0x40);
+	zl10353_single_write(fe, 0xE8, 0x10);
+
+	return 0;
+}
+
+static int zl10353_read_status(struct dvb_frontend *fe, fe_status_t *status)
+{
+	struct zl10353_state *state = fe-&gt;demodulator_priv;
+	int s6, s7, s8;
+
+	if ((s6 = zl10353_read_register(state, STATUS_6)) &lt; 0)
+		return -EREMOTEIO;
+	if ((s7 = zl10353_read_register(state, STATUS_7)) &lt; 0)
+		return -EREMOTEIO;
+	if ((s8 = zl10353_read_register(state, STATUS_8)) &lt; 0)
+		return -EREMOTEIO;
+
+	*status = 0;
+	if (s6 &amp; (1 &lt;&lt; 2))
+		*status |= FE_HAS_CARRIER;
+	if (s6 &amp; (1 &lt;&lt; 1))
+		*status |= FE_HAS_VITERBI;
+	if (s6 &amp; (1 &lt;&lt; 5))
+		*status |= FE_HAS_LOCK;
+	if (s7 &amp; (1 &lt;&lt; 4))
+		*status |= FE_HAS_SYNC;
+	if (s8 &amp; (1 &lt;&lt; 6))
+		*status |= FE_HAS_SIGNAL;
+
+	if ((*status &amp; (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC)) !=
+	    (FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC))
+		*status &amp;= ~FE_HAS_LOCK;
+
+	return 0;
+}
+
+static int zl10353_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct zl10353_state *state = fe-&gt;demodulator_priv;
+	u8 _snr;
+
+	if (debug_regs)
+		zl10353_dump_regs(fe);
+
+	_snr = zl10353_read_register(state, SNR);
+	*snr = (_snr &lt;&lt; 8) | _snr;
+
+	return 0;
+}
+
+static int zl10353_get_tune_settings(struct dvb_frontend *fe,
+				     struct dvb_frontend_tune_settings
+					 *fe_tune_settings)
+{
+	fe_tune_settings-&gt;min_delay_ms = 1000;
+	fe_tune_settings-&gt;step_size = 0;
+	fe_tune_settings-&gt;max_drift = 0;
+
+	return 0;
+}
+
+static int zl10353_init(struct dvb_frontend *fe)
+{
+	struct zl10353_state *state = fe-&gt;demodulator_priv;
+	u8 zl10353_reset_attach[6] = { 0x50, 0x03, 0x64, 0x46, 0x15, 0x0F };
+	int rc = 0;
+
+	if (debug_regs)
+		zl10353_dump_regs(fe);
+
+	/* Do a "hard" reset if not already done */
+	if (zl10353_read_register(state, 0x50) != 0x03) {
+		rc = zl10353_write(fe, zl10353_reset_attach,
+				   sizeof(zl10353_reset_attach));
+		if (debug_regs)
+			zl10353_dump_regs(fe);
+	}
+
+	return 0;
+}
+
+static void zl10353_release(struct dvb_frontend *fe)
+{
+	struct zl10353_state *state = fe-&gt;demodulator_priv;
+
+	kfree(state);
+}
+
+static struct dvb_frontend_ops zl10353_ops;
+
+struct dvb_frontend *zl10353_attach(const struct zl10353_config *config,
+				    struct i2c_adapter *i2c)
+{
+	struct zl10353_state *state = NULL;
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct zl10353_state), GFP_KERNEL);
+	if (state == NULL)
+		goto error;
+
+	/* setup the state */
+	state-&gt;i2c = i2c;
+	memcpy(&amp;state-&gt;config, config, sizeof(struct zl10353_config));
+	memcpy(&amp;state-&gt;ops, &amp;zl10353_ops, sizeof(struct dvb_frontend_ops));
+
+	/* check if the demod is there */
+	if (zl10353_read_register(state, CHIP_ID) != ID_ZL10353)
+		goto error;
+
+	/* create dvb_frontend */
+	state-&gt;frontend.ops = &amp;state-&gt;ops;
+	state-&gt;frontend.demodulator_priv = state;
+
+	return &amp;state-&gt;frontend;
+error:
+	kfree(state);
+	return NULL;
+}
+
+static struct dvb_frontend_ops zl10353_ops = {
+
+	.info = {
+		.name			= "Zarlink ZL10353 DVB-T",
+		.type			= FE_OFDM,
+		.frequency_min		= 174000000,
+		.frequency_max		= 862000000,
+		.frequency_stepsize	= 166667,
+		.frequency_tolerance	= 0,
+		.caps = FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 |
+			FE_CAN_FEC_3_4 | FE_CAN_FEC_5_6 | FE_CAN_FEC_7_8 |
+			FE_CAN_FEC_AUTO |
+			FE_CAN_QPSK | FE_CAN_QAM_16 | FE_CAN_QAM_64 | FE_CAN_QAM_AUTO |
+			FE_CAN_TRANSMISSION_MODE_AUTO | FE_CAN_GUARD_INTERVAL_AUTO |
+			FE_CAN_HIERARCHY_AUTO | FE_CAN_RECOVER |
+			FE_CAN_MUTE_TS
+	},
+
+	.release = zl10353_release,
+
+	.init = zl10353_init,
+	.sleep = zl10353_sleep,
+
+	.set_frontend = zl10353_set_parameters,
+	.get_tune_settings = zl10353_get_tune_settings,
+
+	.read_status = zl10353_read_status,
+	.read_snr = zl10353_read_snr,
+};
+
+module_param(debug_regs, int, 0644);
+MODULE_PARM_DESC(debug_regs, "Turn on/off frontend register dumps (default:off).");
+
+MODULE_DESCRIPTION("Zarlink ZL10353 DVB-T demodulator driver");
+MODULE_AUTHOR("Chris Pascoe");
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(zl10353_attach);
+EXPORT_SYMBOL(zl10353_write);
diff --git a/drivers/media/dvb/frontends/zl10353.h b/drivers/media/dvb/frontends/zl10353.h
new file mode 100644
index 000000000000..5cc4ae718d8c
--- /dev/null
+++ b/drivers/media/dvb/frontends/zl10353.h
@@ -0,0 +1,43 @@
+/*
+ *  Driver for Zarlink DVB-T ZL10353 demodulator
+ *
+ *  Copyright (C) 2006 Christopher Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
+ */
+
+#ifndef ZL10353_H
+#define ZL10353_H
+
+#include &lt;linux/dvb/frontend.h&gt;
+
+struct zl10353_config
+{
+	/* demodulator's I2C address */
+	u8 demod_address;
+
+	/* function which configures the PLL buffer (for secondary I2C
+	 * connected tuner) or tunes the PLL (for direct connected tuner) */
+	int (*pll_set)(struct dvb_frontend *fe,
+		       struct dvb_frontend_parameters *params, u8 *pllbuf);
+};
+
+extern struct dvb_frontend* zl10353_attach(const struct zl10353_config *config,
+					   struct i2c_adapter *i2c);
+
+extern int zl10353_write(struct dvb_frontend *fe, u8 *ibuf, int ilen);
+
+#endif /* ZL10353_H */
diff --git a/drivers/media/dvb/frontends/zl10353_priv.h b/drivers/media/dvb/frontends/zl10353_priv.h
new file mode 100644
index 000000000000..b72224bd7dde
--- /dev/null
+++ b/drivers/media/dvb/frontends/zl10353_priv.h
@@ -0,0 +1,42 @@
+/*
+ *  Driver for Zarlink DVB-T ZL10353 demodulator
+ *
+ *  Copyright (C) 2006 Christopher Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.=
+ */
+
+#ifndef _ZL10353_PRIV_
+#define _ZL10353_PRIV_
+
+#define ID_ZL10353	0x14
+
+enum zl10353_reg_addr {
+	INTERRUPT_0	= 0x00,
+	INTERRUPT_1	= 0x01,
+	INTERRUPT_2	= 0x02,
+	INTERRUPT_3	= 0x03,
+	INTERRUPT_4	= 0x04,
+	INTERRUPT_5	= 0x05,
+	STATUS_6	= 0x06,
+	STATUS_7	= 0x07,
+	STATUS_8	= 0x08,
+	STATUS_9	= 0x09,
+	SNR		= 0x10,
+	CHIP_ID		= 0x7F,
+};
+
+#endif                          /* _ZL10353_PRIV_ */
diff --git a/drivers/media/video/cx88/Makefile b/drivers/media/video/cx88/Makefile
index 2b902784facc..6482b9aa6a1f 100644
--- a/drivers/media/video/cx88/Makefile
+++ b/drivers/media/video/cx88/Makefile
@@ -17,6 +17,7 @@ extra-cflags-$(CONFIG_DVB_CX22702)   += -DHAVE_CX22702=1
 extra-cflags-$(CONFIG_DVB_OR51132)   += -DHAVE_OR51132=1
 extra-cflags-$(CONFIG_DVB_LGDT330X)  += -DHAVE_LGDT330X=1
 extra-cflags-$(CONFIG_DVB_MT352)     += -DHAVE_MT352=1
+extra-cflags-$(CONFIG_DVB_ZL10353)   += -DHAVE_ZL10353=1
 extra-cflags-$(CONFIG_DVB_NXT200X)   += -DHAVE_NXT200X=1
 extra-cflags-$(CONFIG_DVB_CX24123)   += -DHAVE_CX24123=1
 extra-cflags-$(CONFIG_VIDEO_CX88_VP3054)+= -DHAVE_VP3054_I2C=1
diff --git a/drivers/media/video/cx88/cx88-cards.c b/drivers/media/video/cx88/cx88-cards.c
index 44e27dc646ae..d91e5b3a64ef 100644
--- a/drivers/media/video/cx88/cx88-cards.c
+++ b/drivers/media/video/cx88/cx88-cards.c
@@ -1071,6 +1071,27 @@ struct cx88_board cx88_boards[] = {
 			.gpio2  = 0x00ff,
 		},
 	},
+	[CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID] = {
+		.name           = "DViCO FusionHDTV DVB-T Hybrid",
+		.tuner_type     = TUNER_FE6600,
+		.radio_type     = UNSET,
+		.tuner_addr	= ADDR_UNSET,
+		.radio_addr	= ADDR_UNSET,
+		.input          = {{
+			.type   = CX88_VMUX_TELEVISION,
+			.vmux   = 0,
+			.gpio0  = 0x0000a75f,
+		},{
+			.type   = CX88_VMUX_COMPOSITE1,
+			.vmux   = 1,
+			.gpio0  = 0x0000a75b,
+		},{
+			.type   = CX88_VMUX_SVIDEO,
+			.vmux   = 2,
+			.gpio0  = 0x0000a75b,
+		}},
+		.dvb            = 1,
+	},
 
 };
 const unsigned int cx88_bcount = ARRAY_SIZE(cx88_boards);
@@ -1281,6 +1302,14 @@ struct cx88_subid cx88_subids[] = {
 		.subvendor = 0x17de,
 		.subdevice = 0x0840,
 		.card      = CX88_BOARD_KWORLD_HARDWARE_MPEG_TV_XPERT,
+	},{
+		.subvendor = 0x18ac,
+		.subdevice = 0xdb40,
+		.card      = CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID,
+	},{
+		.subvendor = 0x18ac,
+		.subdevice = 0xdb44,
+		.card      = CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID,
 	},
 };
 const unsigned int cx88_idcount = ARRAY_SIZE(cx88_subids);
@@ -1399,6 +1428,40 @@ static void gdi_eeprom(struct cx88_core *core, u8 *eeprom_data)
 	core-&gt;has_radio  = gdi_tuner[eeprom_data[0x0d]].fm;
 }
 
+/* ----------------------------------------------------------------------- */
+/* some DViCO specific stuff                                               */
+
+static void dvico_fusionhdtv_hybrid_init(struct cx88_core *core)
+{
+	struct i2c_msg msg = { .addr = 0x45, .flags = 0 };
+	int i, err;
+	u8 init_bufs[13][5] = {
+		{ 0x10, 0x00, 0x20, 0x01, 0x03 },
+		{ 0x10, 0x10, 0x01, 0x00, 0x21 },
+		{ 0x10, 0x10, 0x10, 0x00, 0xCA },
+		{ 0x10, 0x10, 0x12, 0x00, 0x08 },
+		{ 0x10, 0x10, 0x13, 0x00, 0x0A },
+		{ 0x10, 0x10, 0x16, 0x01, 0xC0 },
+		{ 0x10, 0x10, 0x22, 0x01, 0x3D },
+		{ 0x10, 0x10, 0x73, 0x01, 0x2E },
+		{ 0x10, 0x10, 0x72, 0x00, 0xC5 },
+		{ 0x10, 0x10, 0x71, 0x01, 0x97 },
+		{ 0x10, 0x10, 0x70, 0x00, 0x0F },
+		{ 0x10, 0x10, 0xB0, 0x00, 0x01 },
+		{ 0x03, 0x0C },
+	};
+
+	for (i = 0; i &lt; 13; i++) {
+		msg.buf = init_bufs[i];
+		msg.len = (i != 12 ? 5 : 2);
+		err = i2c_transfer(&amp;core-&gt;i2c_adap, &amp;msg, 1);
+		if (err != 1) {
+			printk("dvico_fusionhdtv_hybrid_init buf %d failed (err = %d)!\n", i, err);
+			return;
+		}
+	}
+}
+
 /* ----------------------------------------------------------------------- */
 
 void cx88_card_list(struct cx88_core *core, struct pci_dev *pci)
@@ -1465,11 +1528,15 @@ void cx88_card_setup(struct cx88_core *core)
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PLUS:
 	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL:
+	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID:
 		/* GPIO0:0 is hooked to mt352 reset pin */
 		cx_set(MO_GP0_IO, 0x00000101);
 		cx_clear(MO_GP0_IO, 0x00000001);
 		msleep(1);
 		cx_set(MO_GP0_IO, 0x00000101);
+		if (0 == core-&gt;i2c_rc &amp;&amp;
+		    core-&gt;board == CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID)
+			dvico_fusionhdtv_hybrid_init(core);
 		break;
 	case CX88_BOARD_KWORLD_DVB_T:
 	case CX88_BOARD_DNTV_LIVE_DVB_T:
diff --git a/drivers/media/video/cx88/cx88-dvb.c b/drivers/media/video/cx88/cx88-dvb.c
index e48aa3f6e500..2c97d3f7101a 100644
--- a/drivers/media/video/cx88/cx88-dvb.c
+++ b/drivers/media/video/cx88/cx88-dvb.c
@@ -40,6 +40,9 @@
 #  include "cx88-vp3054-i2c.h"
 # endif
 #endif
+#ifdef HAVE_ZL10353
+# include "zl10353.h"
+#endif
 #ifdef HAVE_CX22702
 # include "cx22702.h"
 #endif
@@ -111,6 +114,21 @@ static struct videobuf_queue_ops dvb_qops = {
 
 /* ------------------------------------------------------------------ */
 
+#if defined(HAVE_MT352) || defined(HAVE_ZL10353)
+static int zarlink_pll_set(struct dvb_frontend *fe,
+			      struct dvb_frontend_parameters *params,
+			      u8 *pllbuf)
+{
+	struct cx8802_dev *dev = fe-&gt;dvb-&gt;priv;
+
+	pllbuf[0] = dev-&gt;core-&gt;pll_addr &lt;&lt; 1;
+	dvb_pll_configure(dev-&gt;core-&gt;pll_desc, pllbuf + 1,
+			  params-&gt;frequency,
+			  params-&gt;u.ofdm.bandwidth);
+	return 0;
+}
+#endif
+
 #ifdef HAVE_MT352
 static int dvico_fusionhdtv_demod_init(struct dvb_frontend* fe)
 {
@@ -176,35 +194,22 @@ static int dntv_live_dvbt_demod_init(struct dvb_frontend* fe)
 	return 0;
 }
 
-static int mt352_pll_set(struct dvb_frontend* fe,
-			 struct dvb_frontend_parameters* params,
-			 u8* pllbuf)
-{
-	struct cx8802_dev *dev= fe-&gt;dvb-&gt;priv;
-
-	pllbuf[0] = dev-&gt;core-&gt;pll_addr &lt;&lt; 1;
-	dvb_pll_configure(dev-&gt;core-&gt;pll_desc, pllbuf+1,
-			  params-&gt;frequency,
-			  params-&gt;u.ofdm.bandwidth);
-	return 0;
-}
-
 static struct mt352_config dvico_fusionhdtv = {
 	.demod_address = 0x0F,
 	.demod_init    = dvico_fusionhdtv_demod_init,
-	.pll_set       = mt352_pll_set,
+	.pll_set       = zarlink_pll_set,
 };
 
 static struct mt352_config dntv_live_dvbt_config = {
 	.demod_address = 0x0f,
 	.demod_init    = dntv_live_dvbt_demod_init,
-	.pll_set       = mt352_pll_set,
+	.pll_set       = zarlink_pll_set,
 };
 
 static struct mt352_config dvico_fusionhdtv_dual = {
 	.demod_address = 0x0F,
 	.demod_init    = dvico_dual_demod_init,
-	.pll_set       = mt352_pll_set,
+	.pll_set       = zarlink_pll_set,
 };
 
 #ifdef HAVE_VP3054_I2C
@@ -294,6 +299,46 @@ static struct mt352_config dntv_live_dvbt_pro_config = {
 #endif
 #endif
 
+#ifdef HAVE_ZL10353
+static int dvico_hybrid_tune_pll(struct dvb_frontend *fe,
+				 struct dvb_frontend_parameters *params,
+				 u8 *pllbuf)
+{
+	struct cx8802_dev *dev= fe-&gt;dvb-&gt;priv;
+	struct i2c_msg msg =
+		{ .addr = dev-&gt;core-&gt;pll_addr, .flags = 0,
+		  .buf = pllbuf + 1, .len = 4 };
+	int err;
+
+	pllbuf[0] = dev-&gt;core-&gt;pll_addr &lt;&lt; 1;
+	dvb_pll_configure(dev-&gt;core-&gt;pll_desc, pllbuf + 1,
+			  params-&gt;frequency,
+			  params-&gt;u.ofdm.bandwidth);
+
+	if ((err = i2c_transfer(&amp;dev-&gt;core-&gt;i2c_adap, &amp;msg, 1)) != 1) {
+		printk(KERN_WARNING "cx88-dvb: %s error "
+			   "(addr %02x &lt;- %02x, err = %i)\n",
+			   __FUNCTION__, pllbuf[0], pllbuf[1], err);
+		if (err &lt; 0)
+			return err;
+		else
+			return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+static struct zl10353_config dvico_fusionhdtv_hybrid = {
+	.demod_address = 0x0F,
+	.pll_set       = dvico_hybrid_tune_pll,
+};
+
+static struct zl10353_config dvico_fusionhdtv_plus_v1_1 = {
+	.demod_address = 0x0F,
+	.pll_set       = zarlink_pll_set,
+};
+#endif
+
 #ifdef HAVE_CX22702
 static struct cx22702_config connexant_refboard_config = {
 	.demod_address = 0x43,
@@ -500,16 +545,27 @@ static int dvb_register(struct cx8802_dev *dev)
 						   &amp;dev-&gt;core-&gt;i2c_adap);
 		break;
 #endif
+#if defined(HAVE_MT352) || defined(HAVE_ZL10353)
+	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PLUS:
+		dev-&gt;core-&gt;pll_addr = 0x60;
+		dev-&gt;core-&gt;pll_desc = &amp;dvb_pll_thomson_dtt7579;
 #ifdef HAVE_MT352
-	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:
-		dev-&gt;core-&gt;pll_addr = 0x61;
-		dev-&gt;core-&gt;pll_desc = &amp;dvb_pll_lg_z201;
 		dev-&gt;dvb.frontend = mt352_attach(&amp;dvico_fusionhdtv,
 						 &amp;dev-&gt;core-&gt;i2c_adap);
+		if (dev-&gt;dvb.frontend != NULL)
+			break;
+#endif
+#ifdef HAVE_ZL10353
+		/* ZL10353 replaces MT352 on later cards */
+		dev-&gt;dvb.frontend = zl10353_attach(&amp;dvico_fusionhdtv_plus_v1_1,
+						   &amp;dev-&gt;core-&gt;i2c_adap);
+#endif
 		break;
-	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_PLUS:
-		dev-&gt;core-&gt;pll_addr = 0x60;
-		dev-&gt;core-&gt;pll_desc = &amp;dvb_pll_thomson_dtt7579;
+#endif /* HAVE_MT352 || HAVE_ZL10353 */
+#ifdef HAVE_MT352
+	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T1:
+		dev-&gt;core-&gt;pll_addr = 0x61;
+		dev-&gt;core-&gt;pll_desc = &amp;dvb_pll_lg_z201;
 		dev-&gt;dvb.frontend = mt352_attach(&amp;dvico_fusionhdtv,
 						 &amp;dev-&gt;core-&gt;i2c_adap);
 		break;
@@ -540,6 +596,14 @@ static int dvb_register(struct cx8802_dev *dev)
 						 &amp;dev-&gt;core-&gt;i2c_adap);
 		break;
 #endif
+#ifdef HAVE_ZL10353
+	case CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID:
+		dev-&gt;core-&gt;pll_addr = 0x61;
+		dev-&gt;core-&gt;pll_desc = &amp;dvb_pll_unknown_fe6600;
+		dev-&gt;dvb.frontend = zl10353_attach(&amp;dvico_fusionhdtv_hybrid,
+						   &amp;dev-&gt;core-&gt;i2c_adap);
+		break;
+#endif
 #ifdef HAVE_OR51132
 	case CX88_BOARD_PCHDTV_HD3000:
 		dev-&gt;dvb.frontend = or51132_attach(&amp;pchdtv_hd3000,
diff --git a/drivers/media/video/cx88/cx88.h b/drivers/media/video/cx88/cx88.h
index a4cf2473eacf..21738b664bc9 100644
--- a/drivers/media/video/cx88/cx88.h
+++ b/drivers/media/video/cx88/cx88.h
@@ -189,6 +189,7 @@ extern struct sram_channel cx88_sram_channels[];
 #define CX88_BOARD_KWORLD_DVB_T_CX22702    43
 #define CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL 44
 #define CX88_BOARD_KWORLD_HARDWARE_MPEG_TV_XPERT 45
+#define CX88_BOARD_DVICO_FUSIONHDTV_DVB_T_HYBRID 46
 
 enum cx88_itype {
 	CX88_VMUX_COMPOSITE1 = 1,
diff --git a/drivers/media/video/tuner-types.c b/drivers/media/video/tuner-types.c
index 15761dd8607d..d10cfd400f2b 100644
--- a/drivers/media/video/tuner-types.c
+++ b/drivers/media/video/tuner-types.c
@@ -983,6 +983,22 @@ static struct tuner_params tuner_samsung_tcpn_2121p30a_params[] = {
 	},
 };
 
+/* ------------ TUNER_FE6600 - DViCO Hybrid PAL ------------ */
+
+static struct tuner_range tuner_fe6600_ranges[] = {
+	{ 16 * 160.00 /*MHz*/, 0xfe, 0x11, },
+	{ 16 * 442.00 /*MHz*/, 0xf6, 0x12, },
+	{ 16 * 999.99        , 0xf6, 0x18, },
+};
+
+static struct tuner_params tuner_fe6600_params[] = {
+	{
+		.type   = TUNER_PARAM_TYPE_PAL,
+		.ranges = tuner_fe6600_ranges,
+		.count  = ARRAY_SIZE(tuner_fe6600_ranges),
+	},
+};
+
 /* --------------------------------------------------------------------- */
 
 struct tunertype tuners[] = {
@@ -1354,6 +1370,10 @@ struct tunertype tuners[] = {
 		.name	= "Xceive xc3028",
 		/* see xc3028.c for details */
 	},
+	[TUNER_FE6600] = { /* */
+		.name   = "FE6600",
+		.params = tuner_fe6600_params,
+	},
 };
 
 unsigned const int tuner_count = ARRAY_SIZE(tuners);
diff --git a/include/media/tuner.h b/include/media/tuner.h
index f51759c0d180..039c77e02d34 100644
--- a/include/media/tuner.h
+++ b/include/media/tuner.h
@@ -116,9 +116,10 @@
 #define TUNER_PHILIPS_TUV1236D		68	/* ATI HDTV Wonder */
 #define TUNER_TNF_5335MF                69	/* Sabrent Bt848   */
 #define TUNER_SAMSUNG_TCPN_2121P30A     70 	/* Hauppauge PVR-500MCE NTSC */
-
 #define TUNER_XCEIVE_XC3028		71
 
+#define TUNER_FE6600			72	/* DViCO FusionHDTV DVB-T Hybrid */
+
 /* tv card specific */
 #define TDA9887_PRESENT 		(1&lt;&lt;0)
 #define TDA9887_PORT1_INACTIVE 		(1&lt;&lt;1)</pre><hr><pre>commit 4055d392aa0256462758b40cedb9eb7d564de93a
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Tue Feb 7 06:49:11 2006 -0200

    V4L/DVB (3308): Use parallel transport for FusionHDTV Dual Digital USB
    
    Use the parallel transport function of the MT352 in USB demodulator of the
    Dual Digital board.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Michael Krufky &lt;mkrufky@linuxtv.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/dvb/dvb-usb/cxusb.c b/drivers/media/dvb/dvb-usb/cxusb.c
index f14003736afe..650536a4169c 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.c
+++ b/drivers/media/dvb/dvb-usb/cxusb.c
@@ -234,7 +234,7 @@ static struct dvb_usb_rc_key dvico_mce_rc_keys[] = {
 
 static int cxusb_dee1601_demod_init(struct dvb_frontend* fe)
 {
-	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x38 };
+	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x28 };
 	static u8 reset []         = { RESET,      0x80 };
 	static u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };
 	static u8 agc_cfg []       = { AGC_TARGET, 0x28, 0x20 };</pre><hr><pre>commit d9ed881c66525ac0d95fbf76a46187a5de43be2d
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Tue Feb 7 06:49:11 2006 -0200

    V4L/DVB (3308): Use parallel transport for FusionHDTV Dual Digital USB
    
    Use the parallel transport function of the MT352 in USB demodulator of the
    Dual Digital board.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Michael Krufky &lt;mkrufky@linuxtv.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/dvb/dvb-usb/cxusb.c b/drivers/media/dvb/dvb-usb/cxusb.c
index f14003736afe..650536a4169c 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.c
+++ b/drivers/media/dvb/dvb-usb/cxusb.c
@@ -234,7 +234,7 @@ static struct dvb_usb_rc_key dvico_mce_rc_keys[] = {
 
 static int cxusb_dee1601_demod_init(struct dvb_frontend* fe)
 {
-	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x38 };
+	static u8 clock_config []  = { CLOCK_CTL,  0x38, 0x28 };
 	static u8 reset []         = { RESET,      0x80 };
 	static u8 adc_ctl_1_cfg [] = { ADC_CTL_1,  0x40 };
 	static u8 agc_cfg []       = { AGC_TARGET, 0x28, 0x20 };</pre><hr><pre>commit 30367bfda384ccb96c0fe35aaa001c7624e9fd01
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Wed Jan 11 19:40:01 2006 -0200

    V4L/DVB (3339): Activate remote control on HVR1100
    
    
    - Add a missing case which was preventing the operation of the HVR1100
    remote.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/cx88/cx88-input.c b/drivers/media/video/cx88/cx88-input.c
index 286c85b6bdf9..da2ad5c4b553 100644
--- a/drivers/media/video/cx88/cx88-input.c
+++ b/drivers/media/video/cx88/cx88-input.c
@@ -697,6 +697,7 @@ void cx88_ir_irq(struct cx88_core *core)
 	case CX88_BOARD_HAUPPAUGE_DVB_T1:
 	case CX88_BOARD_HAUPPAUGE_NOVASE2_S1:
 	case CX88_BOARD_HAUPPAUGE_NOVASPLUS_S1:
+	case CX88_BOARD_HAUPPAUGE_HVR1100:
 		ircode = ir_decode_biphase(ir-&gt;samples, ir-&gt;scount, 5, 7);
 		ir_dprintk("biphase decoded: %x\n", ircode);
 		if ((ircode &amp; 0xfffff000) != 0x3000)</pre>
    <div class="pagination">
        <a href='18_5.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><a href='18_3.html'>3</a><a href='18_4.html'>4</a><a href='18_5.html'>5</a><span>[6]</span><a href='18_7.html'>7</a><a href='18_7.html'>Next&gt;&gt;</a>
    <div>
</body>
