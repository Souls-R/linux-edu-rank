<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Virginia, Charlottesville</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Virginia, Charlottesville</h1>
    <div class="pagination">
        <a href='3_52.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><span>[53]</span><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_54.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d75662e164d5175c5e5f9339ff4d6f6980613d96
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Sun May 31 15:49:43 2009 -0400

    Staging: Add serqt_usb2, a rewrite of serqt_usb for the usb-serial layer
    
    This is the serqt_usb driver rewritten to use usb-serial.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/serqt_usb2/Kconfig b/drivers/staging/serqt_usb2/Kconfig
new file mode 100644
index 000000000000..f4fed40e23dd
--- /dev/null
+++ b/drivers/staging/serqt_usb2/Kconfig
@@ -0,0 +1,9 @@
+config USB_SERIAL_QUATECH2
+	tristate "USB Quatech ESU-100 8 Port Serial Driver"
+	depends on USB_SERIAL
+	help
+	  Say Y here if you want to use the Quatech ESU-100 8 port usb to
+	  serial adapter.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called serqt_usb2.
diff --git a/drivers/staging/serqt_usb2/Makefile b/drivers/staging/serqt_usb2/Makefile
new file mode 100644
index 000000000000..21578617f7e8
--- /dev/null
+++ b/drivers/staging/serqt_usb2/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_USB_SERIAL_QUATECH2)		+= serqt_usb2.o
diff --git a/drivers/staging/serqt_usb2/serqt_usb2.c b/drivers/staging/serqt_usb2/serqt_usb2.c
new file mode 100644
index 000000000000..581232b719fd
--- /dev/null
+++ b/drivers/staging/serqt_usb2/serqt_usb2.c
@@ -0,0 +1,1664 @@
+/*
+ * This code was developed for the Quatech USB line for linux, it used
+ * much of the code developed by Greg Kroah-Hartman for USB serial devices
+ *
+ */
+
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/tty.h&gt;
+#include &lt;linux/tty_driver.h&gt;
+#include &lt;linux/tty_flip.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/serial.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/serial.h&gt;
+#include &lt;linux/uaccess.h&gt;
+
+static int debug;
+
+/* Version Information */
+#define DRIVER_VERSION "v2.14"
+#define DRIVER_AUTHOR "Tim Gobeli, Quatech, Inc"
+#define DRIVER_DESC "Quatech USB to Serial Driver"
+
+#define	USB_VENDOR_ID_QUATECH			0x061d	/* Quatech VID */
+#define QUATECH_SSU100	0xC020	/* SSU100 */
+#define QUATECH_SSU200	0xC030	/* SSU200 */
+#define QUATECH_DSU100	0xC040	/* DSU100 */
+#define QUATECH_DSU200	0xC050	/* DSU200 */
+#define QUATECH_QSU100	0xC060	/* QSU100 */
+#define QUATECH_QSU200	0xC070	/* QSU200 */
+#define QUATECH_ESU100A	0xC080	/* ESU100A */
+#define QUATECH_ESU100B	0xC081	/* ESU100B */
+#define QUATECH_ESU200A	0xC0A0	/* ESU200A */
+#define QUATECH_ESU200B	0xC0A1	/* ESU200B */
+#define QUATECH_HSU100A	0xC090	/* HSU100A */
+#define QUATECH_HSU100B	0xC091	/* HSU100B */
+#define QUATECH_HSU100C	0xC092	/* HSU100C */
+#define QUATECH_HSU100D	0xC093	/* HSU100D */
+#define QUATECH_HSU200A	0xC0B0	/* HSU200A */
+#define QUATECH_HSU200B	0xC0B1	/* HSU200B */
+#define QUATECH_HSU200C	0xC0B2	/* HSU200C */
+#define QUATECH_HSU200D	0xC0B3	/* HSU200D */
+#define QUATECH_SSU100_2  0xC120	/* SSU100_2 */
+#define QUATECH_DSU100_2  0xC140	/* DSU100_2 */
+#define QUATECH_DSU400_2  0xC150	/* DSU400_2 */
+#define QUATECH_QSU100_2  0xC160	/* QSU100_2 */
+#define QUATECH_QSU400_2  0xC170	/* QSU400_2 */
+#define QUATECH_ESU400_2  0xC180	/* ESU400_2 */
+#define QUATECH_ESU100_2  0xC1A0	/* ESU100_2 */
+
+#define QT_SET_GET_DEVICE           0xc2
+#define QT_OPEN_CLOSE_CHANNEL       0xca
+#define QT_GET_SET_PREBUF_TRIG_LVL  0xcc
+#define QT_SET_ATF                  0xcd
+#define QT_GET_SET_REGISTER         0xc0
+#define QT_GET_SET_UART             0xc1
+#define QT_HW_FLOW_CONTROL_MASK     0xc5
+#define QT_SW_FLOW_CONTROL_MASK     0xc6
+#define QT_SW_FLOW_CONTROL_DISABLE  0xc7
+#define QT_BREAK_CONTROL            0xc8
+
+#define USBD_TRANSFER_DIRECTION_IN    0xc0
+#define USBD_TRANSFER_DIRECTION_OUT   0x40
+
+#define  MAX_BAUD_RATE              460800
+#define  MAX_BAUD_REMAINDER         4608
+
+#define  DIV_LATCH_LS               0x00
+#define  XMT_HOLD_REGISTER          0x00
+#define  XVR_BUFFER_REGISTER        0x00
+#define  DIV_LATCH_MS               0x01
+#define  FIFO_CONTROL_REGISTER      0x02
+#define  LINE_CONTROL_REGISTER      0x03
+#define  MODEM_CONTROL_REGISTER     0x04
+#define  LINE_STATUS_REGISTER       0x05
+#define  MODEM_STATUS_REGISTER      0x06
+
+#define  SERIAL_MCR_DTR             0x01
+#define  SERIAL_MCR_RTS             0x02
+#define  SERIAL_MCR_LOOP            0x10
+
+#define  SERIAL_MSR_CTS             0x10
+#define  SERIAL_MSR_CD              0x80
+#define  SERIAL_MSR_RI              0x40
+#define  SERIAL_MSR_DSR             0x20
+#define  SERIAL_MSR_MASK            0xf0
+
+#define  SERIAL_8_DATA              0x03
+#define  SERIAL_7_DATA              0x02
+#define  SERIAL_6_DATA              0x01
+#define  SERIAL_5_DATA              0x00
+
+#define  SERIAL_ODD_PARITY          0X08
+#define  SERIAL_EVEN_PARITY         0X18
+#define  SERIAL_TWO_STOPB           0x04
+#define  SERIAL_ONE_STOPB           0x00
+
+#define DEFAULT_DIVISOR  0x30	/* gives 9600 baud rate */
+#define DEFAULT_LCR SERIAL_8_DATA	/* 8, none , 1 */
+
+#define FULLPWRBIT          0x00000080
+#define NEXT_BOARD_POWER_BIT        0x00000004
+
+#define SERIAL_LSR_OE       0x02
+#define SERIAL_LSR_PE       0x04
+#define SERIAL_LSR_FE       0x08
+#define SERIAL_LSR_BI       0x10
+
+#define  SERIAL_MSR_CTS             0x10
+#define  SERIAL_MSR_CD              0x80
+#define  SERIAL_MSR_RI              0x40
+#define  SERIAL_MSR_DSR             0x20
+#define  SERIAL_MSR_MASK            0xf0
+
+#define PREFUFF_LEVEL_CONSERVATIVE  128
+#define ATC_DISABLED                0x0
+
+#define RR_BITS             0x03	/* for clearing clock bits */
+#define DUPMODE_BITS        0xc0
+#define CLKS_X4             0x02
+
+#define LOOPMODE_BITS       0x41	/* LOOP1 = b6, LOOP0 = b0 (PORT B) */
+#define ALL_LOOPBACK        0x01
+#define MODEM_CTRL          0x40
+#define RS232_MODE          0x00
+
+static struct usb_device_id serqt_id_table[] = {
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU100)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU200)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU100)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU200)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU100)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU200)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU100A)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU100B)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU200A)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU200B)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU100A)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU100B)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU100C)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU100D)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU200A)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU200B)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU200C)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_HSU200D)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU100_2)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU100_2)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU400_2)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU100_2)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU400_2)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU400_2)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU100_2)},
+	{}			/* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE(usb, serqt_id_table);
+
+struct qt_get_device_data {
+	__u8 porta;
+	__u8 portb;
+	__u8 portc;
+};
+
+struct qt_open_channel_data {
+	__u8 line_status;
+	__u8 modem_status;
+};
+
+struct quatech_port {
+	int port_num;		/* number of the port */
+	struct urb *write_urb;	/* write URB for this port */
+	struct urb *read_urb;	/* read URB for this port */
+	struct urb *int_urb;
+
+	__u8 shadowLCR;		/* last LCR value received */
+	__u8 shadowMCR;		/* last MCR value received */
+	__u8 shadowMSR;		/* last MSR value received */
+	__u8 shadowLSR;		/* last LSR value received */
+	char open_ports;
+
+	/* Used for TIOCMIWAIT */
+	wait_queue_head_t msr_wait;
+	char prev_status, diff_status;
+
+	wait_queue_head_t wait;
+
+	struct async_icount icount;
+
+	struct usb_serial_port *port;	/* owner of this object */
+	struct qt_get_device_data DeviceData;
+	spinlock_t lock;
+	bool read_urb_busy;
+	int RxHolding;
+	int ReadBulkStopped;
+	char closePending;
+};
+
+static struct usb_driver serqt_usb_driver = {
+	.name = "quatech-usb-serial",
+	.probe = usb_serial_probe,
+	.disconnect = usb_serial_disconnect,
+	.id_table = serqt_id_table,
+	.no_dynamic_id = 1,
+};
+
+static int port_paranoia_check(struct usb_serial_port *port,
+			       const char *function)
+{
+	if (!port) {
+		dbg("%s - port == NULL", function);
+		return -1;
+	}
+	if (!port-&gt;serial) {
+		dbg("%s - port-&gt;serial == NULL\n", function);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int serial_paranoia_check(struct usb_serial *serial,
+				 const char *function)
+{
+	if (!serial) {
+		dbg("%s - serial == NULL\n", function);
+		return -1;
+	}
+
+	if (!serial-&gt;type) {
+		dbg("%s - serial-&gt;type == NULL!", function);
+		return -1;
+	}
+
+	return 0;
+}
+
+static inline struct quatech_port *qt_get_port_private(struct usb_serial_port
+						       *port)
+{
+	return (struct quatech_port *)usb_get_serial_port_data(port);
+}
+
+static inline void qt_set_port_private(struct usb_serial_port *port,
+				       struct quatech_port *data)
+{
+	usb_set_serial_port_data(port, (void *)data);
+}
+
+static struct usb_serial *get_usb_serial(struct usb_serial_port *port,
+					 const char *function)
+{
+	/* if no port was specified, or it fails a paranoia check */
+	if (!port ||
+	    port_paranoia_check(port, function) ||
+	    serial_paranoia_check(port-&gt;serial, function)) {
+		/*
+		 * then say that we dont have a valid usb_serial thing,
+		 * which will end up genrating -ENODEV return values
+		 */
+		return NULL;
+	}
+
+	return port-&gt;serial;
+}
+
+static void ProcessLineStatus(struct quatech_port *qt_port,
+			      unsigned char line_status)
+{
+
+	qt_port-&gt;shadowLSR =
+	    line_status &amp; (SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE |
+			   SERIAL_LSR_BI);
+	return;
+}
+
+static void ProcessModemStatus(struct quatech_port *qt_port,
+			       unsigned char modem_status)
+{
+
+	qt_port-&gt;shadowMSR = modem_status;
+	wake_up_interruptible(&amp;qt_port-&gt;wait);
+	return;
+}
+
+static void ProcessRxChar(struct usb_serial_port *port, unsigned char Data)
+{
+	struct tty_struct *tty;
+	struct urb *urb = port-&gt;read_urb;
+	tty = tty_port_tty_get(&amp;port-&gt;port);
+
+	/* if we insert more than TTY_FLIPBUF_SIZE characters, we drop them. */
+
+	if (tty &amp;&amp; urb-&gt;actual_length) {
+		tty_buffer_request_room(tty, 1);
+		tty_insert_flip_string(tty, &amp;Data, 1);
+		/* tty_flip_buffer_push(tty); */
+	}
+
+	return;
+}
+
+static void qt_write_bulk_callback(struct urb *urb)
+{
+	struct tty_struct *tty;
+	int status;
+	struct quatech_port *quatech_port;
+
+	status = urb-&gt;status;
+
+	if (status) {
+		dbg("nonzero write bulk status received:%d\n", status);
+		return;
+	}
+
+	quatech_port = urb-&gt;context;
+
+	dbg("%s - port %d\n", __func__, quatech_port-&gt;port_num);
+
+	tty = tty_port_tty_get(&amp;quatech_port-&gt;port-&gt;port);
+
+	if (tty)
+		tty_wakeup(tty);
+	tty_kref_put(tty);
+}
+
+static void qt_interrupt_callback(struct urb *urb)
+{
+	/* FIXME */
+}
+
+static void qt_read_bulk_callback(struct urb *urb)
+{
+
+	struct usb_serial_port *port = urb-&gt;context;
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+	struct quatech_port *qt_port = qt_get_port_private(port);
+	unsigned char *data;
+	struct tty_struct *tty;
+	unsigned int index;
+	unsigned int RxCount;
+	int i, result;
+	int flag, flag_data;
+
+	if (urb-&gt;status) {
+		qt_port-&gt;ReadBulkStopped = 1;
+		dbg("%s - nonzero write bulk status received: %d\n",
+		    __func__, urb-&gt;status);
+		return;
+	}
+
+	tty = tty_port_tty_get(&amp;port-&gt;port);
+	if (!tty) {
+		dbg("%s - bad tty pointer - exiting", __func__);
+		return;
+	}
+
+	data = urb-&gt;transfer_buffer;
+
+	RxCount = urb-&gt;actual_length;
+
+	/* index = MINOR(port-&gt;tty-&gt;device) - serial-&gt;minor; */
+	index = tty-&gt;index - serial-&gt;minor;
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+	dbg("%s - port-&gt;RxHolding = %d\n", __func__, qt_port-&gt;RxHolding);
+
+	if (port_paranoia_check(port, __func__) != 0) {
+		dbg("%s - port_paranoia_check, exiting\n", __func__);
+		qt_port-&gt;ReadBulkStopped = 1;
+		return;
+	}
+
+	if (!serial) {
+		dbg("%s - bad serial pointer, exiting\n", __func__);
+		return;
+	}
+	if (qt_port-&gt;closePending == 1) {
+		/* Were closing , stop reading */
+		dbg("%s - (qt_port-&gt;closepending == 1\n", __func__);
+		qt_port-&gt;ReadBulkStopped = 1;
+		return;
+	}
+
+	/*
+	 * RxHolding is asserted by throttle, if we assert it, we're not
+	 * receiving any more characters and let the box handle the flow
+	 * control
+	 */
+	if (qt_port-&gt;RxHolding == 1) {
+		qt_port-&gt;ReadBulkStopped = 1;
+		return;
+	}
+
+	if (urb-&gt;status) {
+		qt_port-&gt;ReadBulkStopped = 1;
+
+		dbg("%s - nonzero read bulk status received: %d\n",
+		    __func__, urb-&gt;status);
+		return;
+	}
+
+	if (tty &amp;&amp; RxCount) {
+		flag_data = 0;
+		for (i = 0; i &lt; RxCount; ++i) {
+			/* Look ahead code here */
+			if ((i &lt;= (RxCount - 3)) &amp;&amp; (data[i] == 0x1b)
+			    &amp;&amp; (data[i + 1] == 0x1b)) {
+				flag = 0;
+				switch (data[i + 2]) {
+				case 0x00:
+					/* line status change 4th byte must follow */
+					if (i &gt; (RxCount - 4)) {
+						dbg("Illegal escape seuences in received data\n");
+						break;
+					}
+					ProcessLineStatus(qt_port, data[i + 3]);
+					i += 3;
+					flag = 1;
+					break;
+
+				case 0x01:
+					/* Modem status status change 4th byte must follow */
+					dbg("Modem status status. \n");
+					if (i &gt; (RxCount - 4)) {
+						dbg("Illegal escape sequences in received data\n");
+						break;
+					}
+					ProcessModemStatus(qt_port,
+							   data[i + 3]);
+					i += 3;
+					flag = 1;
+					break;
+				case 0xff:
+					dbg("No status sequence. \n");
+
+					ProcessRxChar(port, data[i]);
+					ProcessRxChar(port, data[i + 1]);
+					i += 2;
+					break;
+				}
+				if (flag == 1)
+					continue;
+			}
+
+			if (tty &amp;&amp; urb-&gt;actual_length) {
+				tty_buffer_request_room(tty, 1);
+				tty_insert_flip_string(tty, (data + i), 1);
+			}
+
+		}
+		tty_flip_buffer_push(tty);
+	}
+
+	/* Continue trying to always read  */
+	usb_fill_bulk_urb(port-&gt;read_urb, serial-&gt;dev,
+			  usb_rcvbulkpipe(serial-&gt;dev,
+					  port-&gt;bulk_in_endpointAddress),
+			  port-&gt;read_urb-&gt;transfer_buffer,
+			  port-&gt;read_urb-&gt;transfer_buffer_length,
+			  qt_read_bulk_callback, port);
+	result = usb_submit_urb(port-&gt;read_urb, GFP_ATOMIC);
+	if (result)
+		dbg("%s - failed resubmitting read urb, error %d",
+		    __func__, result);
+	else {
+		if (tty &amp;&amp; RxCount) {
+			tty_flip_buffer_push(tty);
+			tty_schedule_flip(tty);
+		}
+	}
+
+	schedule_work(&amp;port-&gt;work);
+}
+
+/*
+ * qt_get_device
+ *   Issue a GET_DEVICE vendor-specific request on the default control pipe If
+ *   successful, fills in the qt_get_device_data structure pointed to by
+ *   device_data, otherwise return a negative error number of the problem.
+ */
+
+static int qt_get_device(struct usb_serial *serial,
+			 struct qt_get_device_data *device_data)
+{
+	int result;
+	unsigned char *transfer_buffer;
+
+	transfer_buffer =
+	    kmalloc(sizeof(struct qt_get_device_data), GFP_KERNEL);
+	if (!transfer_buffer)
+		return -ENOMEM;
+
+	result = usb_control_msg(serial-&gt;dev, usb_rcvctrlpipe(serial-&gt;dev, 0),
+				 QT_SET_GET_DEVICE, 0xc0, 0, 0,
+				 transfer_buffer,
+				 sizeof(struct qt_get_device_data), 300);
+	if (result &gt; 0)
+		memcpy(device_data, transfer_buffer,
+		       sizeof(struct qt_get_device_data));
+	kfree(transfer_buffer);
+
+	return result;
+}
+
+/****************************************************************************
+ *  BoxSetPrebufferLevel
+   TELLS BOX WHEN TO ASSERT FLOW CONTROL
+ ****************************************************************************/
+static int BoxSetPrebufferLevel(struct usb_serial *serial)
+{
+	int result;
+	__u16 buffer_length;
+
+	buffer_length = PREFUFF_LEVEL_CONSERVATIVE;
+	result = usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+				 QT_GET_SET_PREBUF_TRIG_LVL, 0x40,
+				 buffer_length, 0, NULL, 0, 300);
+	return result;
+}
+
+/****************************************************************************
+ *  BoxSetATC
+   TELLS BOX WHEN TO ASSERT automatic transmitter control
+   ****************************************************************************/
+static int BoxSetATC(struct usb_serial *serial, __u16 n_Mode)
+{
+	int result;
+	__u16 buffer_length;
+
+	buffer_length = PREFUFF_LEVEL_CONSERVATIVE;
+
+	result =
+	    usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_SET_ATF, 0x40, n_Mode, 0, NULL, 0, 300);
+
+	return result;
+}
+
+/**
+ * qt_set_device
+ *   Issue a SET_DEVICE vendor-specific request on the default control pipe If
+ *   successful returns the number of bytes written, otherwise it returns a
+ *   negative error number of the problem.
+ */
+static int qt_set_device(struct usb_serial *serial,
+			 struct qt_get_device_data *device_data)
+{
+	int result;
+	__u16 length;
+	__u16 PortSettings;
+
+	PortSettings = ((__u16) (device_data-&gt;portb));
+	PortSettings = (PortSettings &lt;&lt; 8);
+	PortSettings += ((__u16) (device_data-&gt;porta));
+
+	length = sizeof(struct qt_get_device_data);
+	dbg("%s - PortSettings = 0x%x\n", __func__, PortSettings);
+
+	result = usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+				 QT_SET_GET_DEVICE, 0x40, PortSettings,
+				 0, NULL, 0, 300);
+	return result;
+}
+
+static int qt_open_channel(struct usb_serial *serial, __u16 Uart_Number,
+			   struct qt_open_channel_data *pDeviceData)
+{
+	int result;
+
+	result = usb_control_msg(serial-&gt;dev, usb_rcvctrlpipe(serial-&gt;dev, 0),
+				 QT_OPEN_CLOSE_CHANNEL,
+				 USBD_TRANSFER_DIRECTION_IN, 1, Uart_Number,
+				 pDeviceData,
+				 sizeof(struct qt_open_channel_data), 300);
+
+	return result;
+
+}
+
+static int qt_close_channel(struct usb_serial *serial, __u16 Uart_Number)
+{
+	int result;
+
+	result = usb_control_msg(serial-&gt;dev, usb_rcvctrlpipe(serial-&gt;dev, 0),
+				 QT_OPEN_CLOSE_CHANNEL,
+				 USBD_TRANSFER_DIRECTION_OUT, 0, Uart_Number,
+				 NULL, 0, 300);
+
+	return result;
+
+}
+
+/****************************************************************************
+* BoxGetRegister
+*	issuse a GET_REGISTER vendor-spcific request on the default control pipe
+*	If successful, fills in the  pValue with the register value asked for
+****************************************************************************/
+static int BoxGetRegister(struct usb_serial *serial, unsigned short Uart_Number,
+			  unsigned short Register_Num, __u8 *pValue)
+{
+	int result;
+	__u16 current_length;
+
+	current_length = sizeof(struct qt_get_device_data);
+
+	result =
+	    usb_control_msg(serial-&gt;dev, usb_rcvctrlpipe(serial-&gt;dev, 0),
+			    QT_GET_SET_REGISTER, 0xC0, Register_Num,
+			    Uart_Number, (void *)pValue, sizeof(*pValue), 300);
+
+	return result;
+}
+
+/****************************************************************************
+* BoxSetRegister
+*	issuse a GET_REGISTER vendor-spcific request on the default control pipe
+*	If successful, fills in the  pValue with the register value asked for
+****************************************************************************/
+static int BoxSetRegister(struct usb_serial *serial, unsigned short Uart_Number,
+			  unsigned short Register_Num, unsigned short Value)
+{
+	int result;
+	unsigned short RegAndByte;
+
+	RegAndByte = Value;
+	RegAndByte = RegAndByte &lt;&lt; 8;
+	RegAndByte = RegAndByte + Register_Num;
+
+/*
+	result = usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+				 QT_GET_SET_REGISTER, 0xC0, Register_Num,
+				 Uart_Number, NULL, 0, 300);
+*/
+
+	result =
+	    usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_GET_SET_REGISTER, 0x40, RegAndByte, Uart_Number,
+			    NULL, 0, 300);
+
+	return result;
+}
+
+/*
+ * qt_setuart
+ * issuse a SET_UART vendor-spcific request on the default control pipe
+ * If successful sets baud rate divisor and LCR value
+ */
+static int qt_setuart(struct usb_serial *serial, unsigned short Uart_Number,
+		      unsigned short default_divisor, unsigned char default_LCR)
+{
+	int result;
+	unsigned short UartNumandLCR;
+
+	UartNumandLCR = (default_LCR &lt;&lt; 8) + Uart_Number;
+
+	result =
+	    usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_GET_SET_UART, 0x40, default_divisor,
+			    UartNumandLCR, NULL, 0, 300);
+
+	return result;
+}
+
+static int BoxSetHW_FlowCtrl(struct usb_serial *serial, unsigned int index,
+			     int bSet)
+{
+	__u8 mcr = 0;
+	__u8 msr = 0, MOUT_Value = 0;
+	unsigned int status;
+
+	if (bSet == 1) {
+		/* flow control, box will clear RTS line to prevent remote */
+		mcr = SERIAL_MCR_RTS;
+	} /* device from xmitting more chars */
+	else {
+		/* no flow control to remote device */
+		mcr = 0;
+
+	}
+	MOUT_Value = mcr &lt;&lt; 8;
+
+	if (bSet == 1) {
+		/* flow control, box will inhibit xmit data if CTS line is
+		 * asserted */
+		msr = SERIAL_MSR_CTS;
+	} else {
+		/* Box will not inhimbe xmit data due to CTS line */
+		msr = 0;
+	}
+	MOUT_Value |= msr;
+
+	status =
+	    usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_HW_FLOW_CONTROL_MASK, 0x40, MOUT_Value,
+			    index, NULL, 0, 300);
+	return status;
+
+}
+
+static int BoxSetSW_FlowCtrl(struct usb_serial *serial, __u16 index,
+			     unsigned char stop_char, unsigned char start_char)
+{
+	__u16 nSWflowout;
+	int result;
+
+	nSWflowout = start_char &lt;&lt; 8;
+	nSWflowout = (unsigned short)stop_char;
+
+	result =
+	    usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_SW_FLOW_CONTROL_MASK, 0x40, nSWflowout,
+			    index, NULL, 0, 300);
+	return result;
+
+}
+
+static int BoxDisable_SW_FlowCtrl(struct usb_serial *serial, __u16 index)
+{
+	int result;
+
+	result =
+	    usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_SW_FLOW_CONTROL_DISABLE, 0x40, 0, index,
+			    NULL, 0, 300);
+	return result;
+
+}
+
+static int qt_startup(struct usb_serial *serial)
+{
+	struct usb_serial_port *port;
+	struct quatech_port *qt_port;
+	struct qt_get_device_data DeviceData;
+	int i;
+	int status;
+
+	dbg("enterting %s", __func__);
+
+	/* Now setup per port private data */
+	for (i = 0; i &lt; serial-&gt;num_ports; i++) {
+		port = serial-&gt;port[i];
+		qt_port = kzalloc(sizeof(*qt_port), GFP_KERNEL);
+		if (!qt_port) {
+			dbg("%s: kmalloc for quatech_port (%d) failed!.",
+			    __func__, i);
+			return -ENOMEM;
+		}
+		spin_lock_init(&amp;qt_port-&gt;lock);
+
+		usb_set_serial_port_data(port, qt_port);
+
+	}
+
+	status = qt_get_device(serial, &amp;DeviceData);
+	if (status &lt; 0) {
+		dbg(__FILE__ "box_get_device failed");
+		goto startup_error;
+	}
+
+	dbg(__FILE__ "DeviceData.portb = 0x%x", DeviceData.portb);
+
+	DeviceData.portb &amp;= ~FULLPWRBIT;
+	dbg(__FILE__ "Changing DeviceData.portb to 0x%x", DeviceData.portb);
+
+	status = qt_set_device(serial, &amp;DeviceData);
+	if (status &lt; 0) {
+		dbg(__FILE__ "qt_set_device failed\n");
+		goto startup_error;
+	}
+
+	status = qt_get_device(serial, &amp;DeviceData);
+	if (status &lt; 0) {
+		dbg(__FILE__ "qt_get_device failed");
+		goto startup_error;
+	}
+
+	switch (serial-&gt;dev-&gt;descriptor.idProduct) {
+	case QUATECH_SSU100:
+	case QUATECH_DSU100:
+	case QUATECH_QSU100:
+	case QUATECH_ESU100A:
+	case QUATECH_ESU100B:
+	case QUATECH_HSU100A:
+	case QUATECH_HSU100B:
+	case QUATECH_HSU100C:
+	case QUATECH_HSU100D:
+		DeviceData.porta &amp;= ~(RR_BITS | DUPMODE_BITS);
+		DeviceData.porta |= CLKS_X4;
+		DeviceData.portb &amp;= ~(LOOPMODE_BITS);
+		DeviceData.portb |= RS232_MODE;
+		break;
+
+	case QUATECH_SSU200:
+	case QUATECH_DSU200:
+	case QUATECH_QSU200:
+	case QUATECH_ESU200A:
+	case QUATECH_ESU200B:
+	case QUATECH_HSU200A:
+	case QUATECH_HSU200B:
+	case QUATECH_HSU200C:
+	case QUATECH_HSU200D:
+		DeviceData.porta &amp;= ~(RR_BITS | DUPMODE_BITS);
+		DeviceData.porta |= CLKS_X4;
+		DeviceData.portb &amp;= ~(LOOPMODE_BITS);
+		DeviceData.portb |= ALL_LOOPBACK;
+		break;
+	default:
+		DeviceData.porta &amp;= ~(RR_BITS | DUPMODE_BITS);
+		DeviceData.porta |= CLKS_X4;
+		DeviceData.portb &amp;= ~(LOOPMODE_BITS);
+		DeviceData.portb |= RS232_MODE;
+		break;
+
+	}
+
+	status = BoxSetPrebufferLevel(serial);	/* sets to default value */
+	if (status &lt; 0) {
+		dbg(__FILE__ "BoxSetPrebufferLevel failed\n");
+		goto startup_error;
+	}
+
+	status = BoxSetATC(serial, ATC_DISABLED);
+	if (status &lt; 0) {
+		dbg(__FILE__ "BoxSetATC failed\n");
+		goto startup_error;
+	}
+
+	dbg(__FILE__ "DeviceData.portb = 0x%x", DeviceData.portb);
+
+	DeviceData.portb |= NEXT_BOARD_POWER_BIT;
+	dbg(__FILE__ "Changing DeviceData.portb to 0x%x", DeviceData.portb);
+
+	status = qt_set_device(serial, &amp;DeviceData);
+	if (status &lt; 0) {
+		dbg(__FILE__ "qt_set_device failed\n");
+		goto startup_error;
+	}
+
+	dbg("Exit Success %s\n", __func__);
+
+	return 0;
+
+startup_error:
+	for (i = 0; i &lt; serial-&gt;num_ports; i++) {
+		port = serial-&gt;port[i];
+		qt_port = qt_get_port_private(port);
+		kfree(qt_port);
+		usb_set_serial_port_data(port, NULL);
+	}
+
+	dbg("Exit fail %s\n", __func__);
+
+	return -EIO;
+}
+
+static void qt_release(struct usb_serial *serial)
+{
+	struct usb_serial_port *port;
+	struct quatech_port *qt_port;
+	int i;
+
+	dbg("enterting %s", __func__);
+
+	for (i = 0; i &lt; serial-&gt;num_ports; i++) {
+		port = serial-&gt;port[i];
+		if (!port)
+			continue;
+
+		qt_port = usb_get_serial_port_data(port);
+		kfree(qt_port);
+		usb_set_serial_port_data(port, NULL);
+	}
+
+}
+
+int qt_open(struct tty_struct *tty,
+	    struct usb_serial_port *port, struct file *filp)
+{
+	struct usb_serial *serial;
+	struct quatech_port *quatech_port;
+	struct quatech_port *port0;
+	struct qt_open_channel_data ChannelData;
+
+	int result;
+
+	if (port_paranoia_check(port, __func__))
+		return -ENODEV;
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	serial = port-&gt;serial;
+
+	if (serial_paranoia_check(serial, __func__))
+		return -ENODEV;
+
+	quatech_port = qt_get_port_private(port);
+	port0 = qt_get_port_private(serial-&gt;port[0]);
+
+	if (quatech_port == NULL || port0 == NULL)
+		return -ENODEV;
+
+	usb_clear_halt(serial-&gt;dev, port-&gt;write_urb-&gt;pipe);
+	usb_clear_halt(serial-&gt;dev, port-&gt;read_urb-&gt;pipe);
+	port0-&gt;open_ports++;
+
+	result = qt_get_device(serial, &amp;port0-&gt;DeviceData);
+
+	/* Port specific setups */
+	result = qt_open_channel(serial, port-&gt;number, &amp;ChannelData);
+	if (result &lt; 0) {
+		dbg(__FILE__ "qt_open_channel failed\n");
+		return result;
+	}
+	dbg(__FILE__ "qt_open_channel completed.\n");
+
+/* FIXME: are these needed?  Does it even do anything useful? */
+	quatech_port-&gt;shadowLSR = ChannelData.line_status &amp;
+	    (SERIAL_LSR_OE | SERIAL_LSR_PE | SERIAL_LSR_FE | SERIAL_LSR_BI);
+
+	quatech_port-&gt;shadowMSR = ChannelData.modem_status &amp;
+	    (SERIAL_MSR_CTS | SERIAL_MSR_DSR | SERIAL_MSR_RI | SERIAL_MSR_CD);
+
+	/* Set Baud rate to default and turn off (default)flow control here */
+	result = qt_setuart(serial, port-&gt;number, DEFAULT_DIVISOR, DEFAULT_LCR);
+	if (result &lt; 0) {
+		dbg(__FILE__ "qt_setuart failed\n");
+		return result;
+	}
+	dbg(__FILE__ "qt_setuart completed.\n");
+
+	/*
+	 * Put this here to make it responsive to stty and defauls set by
+	 * the tty layer
+	 */
+	/* FIXME: is this needed? */
+	/* qt_set_termios(tty, port, NULL); */
+
+	/*  Check to see if we've set up our endpoint info yet */
+	if (port0-&gt;open_ports == 1) {
+		if (serial-&gt;port[0]-&gt;interrupt_in_buffer == NULL) {
+			/* set up interrupt urb */
+			usb_fill_int_urb(serial-&gt;port[0]-&gt;interrupt_in_urb,
+					 serial-&gt;dev,
+					 usb_rcvintpipe(serial-&gt;dev,
+							serial-&gt;port[0]-&gt;interrupt_in_endpointAddress),
+					 serial-&gt;port[0]-&gt;interrupt_in_buffer,
+					 serial-&gt;port[0]-&gt;
+					 interrupt_in_urb-&gt;transfer_buffer_length,
+					 qt_interrupt_callback, serial,
+					 serial-&gt;port[0]-&gt;
+					 interrupt_in_urb-&gt;interval);
+
+			result =
+			    usb_submit_urb(serial-&gt;port[0]-&gt;interrupt_in_urb,
+					   GFP_KERNEL);
+			if (result) {
+				dev_err(&amp;port-&gt;dev,
+					"%s - Error %d submitting "
+					"interrupt urb\n", __func__, result);
+			}
+
+		}
+
+	}
+
+	dbg("port number is %d \n", port-&gt;number);
+	dbg("serial number is %d \n", port-&gt;serial-&gt;minor);
+	dbg("Bulkin endpoint is %d \n", port-&gt;bulk_in_endpointAddress);
+	dbg("BulkOut endpoint is %d \n", port-&gt;bulk_out_endpointAddress);
+	dbg("Interrupt endpoint is %d \n", port-&gt;interrupt_in_endpointAddress);
+	dbg("port's number in the device is %d\n", quatech_port-&gt;port_num);
+	quatech_port-&gt;read_urb = port-&gt;read_urb;
+
+	/* set up our bulk in urb */
+
+	usb_fill_bulk_urb(quatech_port-&gt;read_urb,
+			  serial-&gt;dev,
+			  usb_rcvbulkpipe(serial-&gt;dev,
+					  port-&gt;bulk_in_endpointAddress),
+			  port-&gt;bulk_in_buffer,
+			  quatech_port-&gt;read_urb-&gt;transfer_buffer_length,
+			  qt_read_bulk_callback, quatech_port);
+
+	dbg("qt_open: bulkin endpoint is %d\n", port-&gt;bulk_in_endpointAddress);
+	quatech_port-&gt;read_urb_busy = true;
+	result = usb_submit_urb(quatech_port-&gt;read_urb, GFP_KERNEL);
+	if (result) {
+		dev_err(&amp;port-&gt;dev,
+			"%s - Error %d submitting control urb\n",
+			__func__, result);
+		quatech_port-&gt;read_urb_busy = false;
+	}
+
+	/* initialize our wait queues */
+	init_waitqueue_head(&amp;quatech_port-&gt;wait);
+	init_waitqueue_head(&amp;quatech_port-&gt;msr_wait);
+
+	/* initialize our icount structure */
+	memset(&amp;(quatech_port-&gt;icount), 0x00, sizeof(quatech_port-&gt;icount));
+
+	return 0;
+
+}
+
+static int qt_chars_in_buffer(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial;
+	int chars = 0;
+
+	serial = get_usb_serial(port, __func__);
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	if (serial-&gt;num_bulk_out) {
+		if (port-&gt;write_urb-&gt;status == -EINPROGRESS)
+			chars = port-&gt;write_urb-&gt;transfer_buffer_length;
+	}
+
+	dbg("%s - returns %d\n", __func__, chars);
+
+	return chars;
+}
+
+static void qt_block_until_empty(struct tty_struct *tty,
+				 struct quatech_port *qt_port)
+{
+	int timeout = HZ / 10;
+	int wait = 30;
+	int count;
+
+	while (1) {
+
+		count = qt_chars_in_buffer(tty);
+
+		if (count &lt;= 0)
+			return;
+
+		interruptible_sleep_on_timeout(&amp;qt_port-&gt;wait, timeout);
+
+		wait--;
+		if (wait == 0) {
+			dbg("%s - TIMEOUT", __func__);
+			return;
+		} else {
+			wait = 30;
+		}
+	}
+}
+
+static void qt_close(struct tty_struct *tty, struct usb_serial_port *port,
+		     struct file *filp)
+{
+	struct usb_serial *serial = port-&gt;serial;
+	struct quatech_port *qt_port;
+	struct quatech_port *port0;
+	int status;
+	unsigned int index;
+	status = 0;
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+	index = tty-&gt;index - serial-&gt;minor;
+
+	qt_port = qt_get_port_private(port);
+	port0 = qt_get_port_private(serial-&gt;port[0]);
+
+	/* shutdown any bulk reads that might be going on */
+	if (serial-&gt;num_bulk_out)
+		usb_unlink_urb(port-&gt;write_urb);
+	if (serial-&gt;num_bulk_in)
+		usb_unlink_urb(port-&gt;read_urb);
+
+	/* wait up to for transmitter to empty */
+	if (serial-&gt;dev)
+		qt_block_until_empty(tty, qt_port);
+
+	/* Close uart channel */
+	status = qt_close_channel(serial, index);
+	if (status &lt; 0)
+		dbg("%s - port %d qt_close_channel failed.\n",
+		    __func__, port-&gt;number);
+
+	port0-&gt;open_ports--;
+
+	dbg("qt_num_open_ports in close%d:in port%d\n",
+	    port0-&gt;open_ports, port-&gt;number);
+
+	if (port0-&gt;open_ports == 0) {
+		if (serial-&gt;port[0]-&gt;interrupt_in_urb) {
+			dbg("%s", "Shutdown interrupt_in_urb\n");
+			usb_kill_urb(serial-&gt;port[0]-&gt;interrupt_in_urb);
+		}
+
+	}
+
+	if (qt_port-&gt;write_urb) {
+		/* if this urb had a transfer buffer already (old tx) free it */
+		if (qt_port-&gt;write_urb-&gt;transfer_buffer != NULL)
+			kfree(qt_port-&gt;write_urb-&gt;transfer_buffer);
+		usb_free_urb(qt_port-&gt;write_urb);
+	}
+
+}
+
+static int qt_write(struct tty_struct *tty, struct usb_serial_port *port,
+		    const unsigned char *buf, int count)
+{
+	int result;
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+
+	if (serial == NULL)
+		return -ENODEV;
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	if (count == 0) {
+		dbg("%s - write request of 0 bytes\n", __func__);
+		return 0;
+	}
+
+	/* only do something if we have a bulk out endpoint */
+	if (serial-&gt;num_bulk_out) {
+		if (port-&gt;write_urb-&gt;status == -EINPROGRESS) {
+			dbg("%s - already writing\n", __func__);
+			return 0;
+		}
+
+		count =
+		    (count &gt; port-&gt;bulk_out_size) ? port-&gt;bulk_out_size : count;
+		memcpy(port-&gt;write_urb-&gt;transfer_buffer, buf, count);
+
+		/* set up our urb */
+
+		usb_fill_bulk_urb(port-&gt;write_urb, serial-&gt;dev,
+				  usb_sndbulkpipe(serial-&gt;dev,
+						  port-&gt;
+						  bulk_out_endpointAddress),
+				  port-&gt;write_urb-&gt;transfer_buffer, count,
+				  qt_write_bulk_callback, port);
+
+		/* send the data out the bulk port */
+		result = usb_submit_urb(port-&gt;write_urb, GFP_ATOMIC);
+		if (result)
+			dbg("%s - failed submitting write urb, error %d\n",
+			    __func__, result);
+		else
+			result = count;
+
+		return result;
+	}
+
+	/* no bulk out, so return 0 bytes written */
+	return 0;
+}
+
+static int qt_write_room(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial;
+	struct quatech_port *qt_port;
+	unsigned long flags;
+
+	int retval = -EINVAL;
+
+	if (port_paranoia_check(port, __func__)) {
+		dbg("%s", "Invalid port\n");
+		return -1;
+	}
+
+	serial = get_usb_serial(port, __func__);
+
+	if (!serial)
+		return -ENODEV;
+
+	qt_port = qt_get_port_private(port);
+
+	spin_lock_irqsave(&amp;qt_port-&gt;lock, flags);
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	if (serial-&gt;num_bulk_out) {
+		if (port-&gt;write_urb-&gt;status != -EINPROGRESS)
+			retval = port-&gt;bulk_out_size;
+	}
+
+	spin_unlock_irqrestore(&amp;qt_port-&gt;lock, flags);
+	return retval;
+
+}
+
+static int qt_ioctl(struct tty_struct *tty, struct file *file,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct quatech_port *qt_port = qt_get_port_private(port);
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+	unsigned int index;
+
+	dbg("%s cmd 0x%04x", __func__, cmd);
+
+	index = tty-&gt;index - serial-&gt;minor;
+
+	if (cmd == TIOCMIWAIT) {
+		while (qt_port != NULL) {
+			interruptible_sleep_on(&amp;qt_port-&gt;msr_wait);
+			if (signal_pending(current))
+				return -ERESTARTSYS;
+			else {
+				char diff = qt_port-&gt;diff_status;
+
+				if (diff == 0)
+					return -EIO;	/* no change =&gt; error */
+
+				/* Consume all events */
+				qt_port-&gt;diff_status = 0;
+
+				if (((arg &amp; TIOCM_RNG)
+				     &amp;&amp; (diff &amp; SERIAL_MSR_RI))
+				    || ((arg &amp; TIOCM_DSR)
+					&amp;&amp; (diff &amp; SERIAL_MSR_DSR))
+				    || ((arg &amp; TIOCM_CD)
+					&amp;&amp; (diff &amp; SERIAL_MSR_CD))
+				    || ((arg &amp; TIOCM_CTS)
+					&amp;&amp; (diff &amp; SERIAL_MSR_CTS))) {
+					return 0;
+				}
+			}
+		}
+		return 0;
+	}
+
+	dbg("%s -No ioctl for that one.  port = %d\n", __func__, port-&gt;number);
+	return -ENOIOCTLCMD;
+}
+
+static void qt_set_termios(struct tty_struct *tty,
+			   struct usb_serial_port *port,
+			   struct ktermios *old_termios)
+{
+	struct ktermios *termios = tty-&gt;termios;
+	unsigned char new_LCR = 0;
+	unsigned int cflag = termios-&gt;c_cflag;
+	unsigned int index;
+	int baud, divisor, remainder;
+	int status;
+
+	dbg("%s", __func__);
+
+	index = tty-&gt;index - port-&gt;serial-&gt;minor;
+
+	switch (cflag) {
+	case CS5:
+		new_LCR |= SERIAL_5_DATA;
+		break;
+	case CS6:
+		new_LCR |= SERIAL_6_DATA;
+		break;
+	case CS7:
+		new_LCR |= SERIAL_7_DATA;
+		break;
+	default:
+	case CS8:
+		new_LCR |= SERIAL_8_DATA;
+		break;
+	}
+
+	/* Parity stuff */
+	if (cflag &amp; PARENB) {
+		if (cflag &amp; PARODD)
+			new_LCR |= SERIAL_ODD_PARITY;
+		else
+			new_LCR |= SERIAL_EVEN_PARITY;
+	}
+	if (cflag &amp; CSTOPB)
+		new_LCR |= SERIAL_TWO_STOPB;
+	else
+		new_LCR |= SERIAL_TWO_STOPB;
+
+	dbg("%s - 4\n", __func__);
+
+	/* Thats the LCR stuff, go ahead and set it */
+	baud = tty_get_baud_rate(tty);
+	if (!baud)
+		/* pick a default, any default... */
+		baud = 9600;
+
+	dbg("%s - got baud = %d\n", __func__, baud);
+
+	divisor = MAX_BAUD_RATE / baud;
+	remainder = MAX_BAUD_RATE % baud;
+	/* Round to nearest divisor */
+	if (((remainder * 2) &gt;= baud) &amp;&amp; (baud != 110))
+		divisor++;
+
+	/*
+	 * Set Baud rate to default and turn off (default)flow control here
+	 */
+	status =
+	    qt_setuart(port-&gt;serial, index, (unsigned short)divisor, new_LCR);
+	if (status &lt; 0) {
+		dbg(__FILE__ "qt_setuart failed\n");
+		return;
+	}
+
+	/* Now determine flow control */
+	if (cflag &amp; CRTSCTS) {
+		dbg("%s - Enabling HW flow control port %d\n", __func__,
+		    port-&gt;number);
+
+		/* Enable RTS/CTS flow control */
+		status = BoxSetHW_FlowCtrl(port-&gt;serial, index, 1);
+
+		if (status &lt; 0) {
+			dbg(__FILE__ "BoxSetHW_FlowCtrl failed\n");
+			return;
+		}
+	} else {
+		/* Disable RTS/CTS flow control */
+		dbg("%s - disabling HW flow control port %d\n", __func__,
+		    port-&gt;number);
+
+		status = BoxSetHW_FlowCtrl(port-&gt;serial, index, 0);
+		if (status &lt; 0) {
+			dbg(__FILE__ "BoxSetHW_FlowCtrl failed\n");
+			return;
+		}
+
+	}
+
+	/* if we are implementing XON/XOFF, set the start and stop character in
+	 * the device */
+	if (I_IXOFF(tty) || I_IXON(tty)) {
+		unsigned char stop_char = STOP_CHAR(tty);
+		unsigned char start_char = START_CHAR(tty);
+		status =
+		    BoxSetSW_FlowCtrl(port-&gt;serial, index, stop_char,
+				      start_char);
+		if (status &lt; 0)
+			dbg(__FILE__ "BoxSetSW_FlowCtrl (enabled) failed\n");
+
+	} else {
+		/* disable SW flow control */
+		status = BoxDisable_SW_FlowCtrl(port-&gt;serial, index);
+		if (status &lt; 0)
+			dbg(__FILE__ "BoxSetSW_FlowCtrl (diabling) failed\n");
+
+	}
+	tty-&gt;termios-&gt;c_cflag &amp;= ~CMSPAR;
+	/* FIXME: Error cases should be returning the actual bits changed only */
+}
+
+static void qt_break(struct tty_struct *tty, int break_state)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+	struct quatech_port *qt_port;
+	u16 index, onoff;
+	unsigned int result;
+	unsigned long flags;
+
+	index = tty-&gt;index - serial-&gt;minor;
+
+	qt_port = qt_get_port_private(port);
+
+	if (break_state == -1)
+		onoff = 1;
+	else
+		onoff = 0;
+
+	spin_lock_irqsave(&amp;qt_port-&gt;lock, flags);
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	result =
+	    usb_control_msg(serial-&gt;dev, usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_BREAK_CONTROL, 0x40, onoff, index, NULL, 0, 300);
+
+	spin_unlock_irqrestore(&amp;qt_port-&gt;lock, flags);
+}
+
+static inline int qt_real_tiocmget(struct tty_struct *tty,
+				   struct usb_serial_port *port,
+				   struct file *file, struct usb_serial *serial)
+{
+
+	u8 mcr;
+	u8 msr;
+	unsigned int result = 0;
+	int status;
+	unsigned int index;
+
+	dbg("%s - port %d, tty =0x%p\n", __func__, port-&gt;number, tty);
+
+	index = tty-&gt;index - serial-&gt;minor;
+	status =
+	    BoxGetRegister(port-&gt;serial, index, MODEM_CONTROL_REGISTER, &amp;mcr);
+	if (status &gt;= 0) {
+		status =
+		    BoxGetRegister(port-&gt;serial, index,
+				   MODEM_STATUS_REGISTER, &amp;msr);
+
+	}
+
+	if (status &gt;= 0) {
+		result = ((mcr &amp; SERIAL_MCR_DTR) ? TIOCM_DTR : 0)
+		    /* DTR IS SET */
+		    | ((mcr &amp; SERIAL_MCR_RTS) ? TIOCM_RTS : 0)
+		    /* RTS IS SET */
+		    | ((msr &amp; SERIAL_MSR_CTS) ? TIOCM_CTS : 0)
+		    /* CTS is set */
+		    | ((msr &amp; SERIAL_MSR_CD) ? TIOCM_CAR : 0)
+		    /* Carrier detect is set */
+		    | ((msr &amp; SERIAL_MSR_RI) ? TIOCM_RI : 0)
+		    /* Ring indicator set */
+		    | ((msr &amp; SERIAL_MSR_DSR) ? TIOCM_DSR : 0);
+		/* DSR is set */
+		return result;
+
+	} else
+		return -ESPIPE;
+}
+
+static inline int qt_real_tiocmset(struct tty_struct *tty,
+				   struct usb_serial_port *port,
+				   struct file *file,
+				   struct usb_serial *serial,
+				   unsigned int value)
+{
+
+	u8 mcr;
+	int status;
+	unsigned int index;
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	index = tty-&gt;index - serial-&gt;minor;
+	status =
+	    BoxGetRegister(port-&gt;serial, index, MODEM_CONTROL_REGISTER, &amp;mcr);
+	if (status &lt; 0)
+		return -ESPIPE;
+
+	/*
+	 * Turn off the RTS and DTR and loopbcck and then only turn on what was
+	 * asked for
+	 */
+	mcr &amp;= ~(SERIAL_MCR_RTS | SERIAL_MCR_DTR | SERIAL_MCR_LOOP);
+	if (value &amp; TIOCM_RTS)
+		mcr |= SERIAL_MCR_RTS;
+	if (value &amp; TIOCM_DTR)
+		mcr |= SERIAL_MCR_DTR;
+	if (value &amp; TIOCM_LOOP)
+		mcr |= SERIAL_MCR_LOOP;
+
+	status =
+	    BoxSetRegister(port-&gt;serial, index, MODEM_CONTROL_REGISTER, mcr);
+	if (status &lt; 0)
+		return -ESPIPE;
+	else
+		return 0;
+}
+
+static int qt_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+	struct quatech_port *qt_port = qt_get_port_private(port);
+	int retval = -ENODEV;
+	unsigned long flags;
+
+	dbg("In %s \n", __func__);
+
+	if (!serial)
+		return -ENODEV;
+
+	spin_lock_irqsave(&amp;qt_port-&gt;lock, flags);
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+	dbg("%s - port-&gt;RxHolding = %d\n", __func__, qt_port-&gt;RxHolding);
+
+	retval = qt_real_tiocmget(tty, port, file, serial);
+
+	spin_unlock_irqrestore(&amp;qt_port-&gt;lock, flags);
+	return retval;
+}
+
+static int qt_tiocmset(struct tty_struct *tty, struct file *file,
+		       unsigned int set, unsigned int clear)
+{
+
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+	struct quatech_port *qt_port = qt_get_port_private(port);
+	unsigned long flags;
+	int retval = -ENODEV;
+
+	dbg("In %s \n", __func__);
+
+	if (!serial)
+		return -ENODEV;
+
+	spin_lock_irqsave(&amp;qt_port-&gt;lock, flags);
+
+	dbg("%s - port %d \n", __func__, port-&gt;number);
+	dbg("%s - qt_port-&gt;RxHolding = %d\n", __func__, qt_port-&gt;RxHolding);
+
+	retval = qt_real_tiocmset(tty, port, file, serial, set);
+
+	spin_unlock_irqrestore(&amp;qt_port-&gt;lock, flags);
+	return retval;
+}
+
+static void qt_throttle(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+	struct quatech_port *qt_port;
+	unsigned long flags;
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	if (!serial)
+		return;
+
+	qt_port = qt_get_port_private(port);
+
+	spin_lock_irqsave(&amp;qt_port-&gt;lock, flags);
+
+	/* pass on to the driver specific version of this function */
+	qt_port-&gt;RxHolding = 1;
+	dbg("%s - port-&gt;RxHolding = 1\n", __func__);
+
+	spin_unlock_irqrestore(&amp;qt_port-&gt;lock, flags);
+	return;
+}
+
+static void qt_unthrottle(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial = get_usb_serial(port, __func__);
+	struct quatech_port *qt_port;
+	unsigned long flags;
+	unsigned int result;
+
+	if (!serial)
+		return;
+
+	qt_port = qt_get_port_private(port);
+
+	spin_lock_irqsave(&amp;qt_port-&gt;lock, flags);
+
+	dbg("%s - port %d\n", __func__, port-&gt;number);
+
+	if (qt_port-&gt;RxHolding == 1) {
+		dbg("%s -qt_port-&gt;RxHolding == 1\n", __func__);
+
+		qt_port-&gt;RxHolding = 0;
+		dbg("%s - qt_port-&gt;RxHolding = 0\n", __func__);
+
+		/* if we have a bulk endpoint, start it up */
+		if ((serial-&gt;num_bulk_in) &amp;&amp; (qt_port-&gt;ReadBulkStopped == 1)) {
+			/* Start reading from the device */
+			usb_fill_bulk_urb(port-&gt;read_urb, serial-&gt;dev,
+					  usb_rcvbulkpipe(serial-&gt;dev,
+							  port-&gt;bulk_in_endpointAddress),
+					  port-&gt;read_urb-&gt;transfer_buffer,
+					  port-&gt;read_urb-&gt;
+					  transfer_buffer_length,
+					  qt_read_bulk_callback, port);
+			result = usb_submit_urb(port-&gt;read_urb, GFP_ATOMIC);
+			if (result)
+				err("%s - failed restarting read urb, error %d",
+				    __func__, result);
+		}
+	}
+	spin_unlock_irqrestore(&amp;qt_port-&gt;lock, flags);
+	return;
+
+}
+
+static int qt_calc_num_ports(struct usb_serial *serial)
+{
+	int num_ports;
+
+	dbg("numberofendpoints: %d \n",
+	    (int)serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints);
+	dbg("numberofendpoints: %d \n",
+	    (int)serial-&gt;interface-&gt;altsetting-&gt;desc.bNumEndpoints);
+
+	num_ports =
+	    (serial-&gt;interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints - 1) / 2;
+
+	return num_ports;
+}
+
+static struct usb_serial_driver quatech_device = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "serqt",
+		   },
+	.description = DRIVER_DESC,
+	.usb_driver = &amp;serqt_usb_driver,
+	.id_table = serqt_id_table,
+	.num_ports = 8,
+	.open = qt_open,
+	.close = qt_close,
+	.write = qt_write,
+	.write_room = qt_write_room,
+	.chars_in_buffer = qt_chars_in_buffer,
+	.throttle = qt_throttle,
+	.unthrottle = qt_unthrottle,
+	.calc_num_ports = qt_calc_num_ports,
+	.ioctl = qt_ioctl,
+	.set_termios = qt_set_termios,
+	.break_ctl = qt_break,
+	.tiocmget = qt_tiocmget,
+	.tiocmset = qt_tiocmset,
+	.attach = qt_startup,
+	.release = qt_release,
+};
+
+static int __init serqt_usb_init(void)
+{
+	int retval;
+
+	dbg("%s\n", __func__);
+
+	/* register with usb-serial */
+	retval = usb_serial_register(&amp;quatech_device);
+
+	if (retval)
+		goto failed_usb_serial_register;
+
+	printk(KERN_INFO KBUILD_MODNAME ": " DRIVER_VERSION ":"
+	       DRIVER_DESC "\n");
+
+	/* register with usb */
+
+	retval = usb_register(&amp;serqt_usb_driver);
+	if (retval == 0)
+		return 0;
+
+	/* if we're here, usb_register() failed */
+	usb_serial_deregister(&amp;quatech_device);
+failed_usb_serial_register:
+	return retval;
+}
+
+static void __exit serqt_usb_exit(void)
+{
+	usb_deregister(&amp;serqt_usb_driver);
+	usb_serial_deregister(&amp;quatech_device);
+}
+
+module_init(serqt_usb_init);
+module_exit(serqt_usb_exit);
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");</pre><hr><pre>commit dc8284611bf7ee2e871919fa441a9c7afe4d5486
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Apr 22 08:59:15 2009 -0400

    Staging: pohmelfs: Remove braces around single statements
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Evgeniy Polyakov &lt;zbr@ioremap.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/pohmelfs/dir.c b/drivers/staging/pohmelfs/dir.c
index 71210b1c86c9..4c58e22c1fbe 100644
--- a/drivers/staging/pohmelfs/dir.c
+++ b/drivers/staging/pohmelfs/dir.c
@@ -692,9 +692,9 @@ static int pohmelfs_remove_entry(struct inode *dir, struct dentry *dentry)
 	n = pohmelfs_search_hash(parent, str.hash);
 	if (n) {
 		pohmelfs_fix_offset(parent, n);
-		if (test_bit(NETFS_INODE_REMOTE_SYNCED, &amp;pi-&gt;state)) {
+		if (test_bit(NETFS_INODE_REMOTE_SYNCED, &amp;pi-&gt;state))
 			pohmelfs_remove_child(pi, n);
-		}
+
 		pohmelfs_name_free(parent, n);
 		err = 0;
 	}
@@ -1006,9 +1006,8 @@ static int pohmelfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	pi = POHMELFS_I(inode);
 	old_parent = POHMELFS_I(old_dir);
 
-	if (new_dir) {
+	if (new_dir)
 		new_dir-&gt;i_sb-&gt;s_op-&gt;write_inode(new_dir, 0);
-	}
 
 	old_hash = jhash(old_dentry-&gt;d_name.name, old_dentry-&gt;d_name.len, 0);
 	str.hash = jhash(new_dentry-&gt;d_name.name, new_dentry-&gt;d_name.len, 0);
diff --git a/drivers/staging/pohmelfs/inode.c b/drivers/staging/pohmelfs/inode.c
index 6256c5c7a5ad..882c619c01d0 100644
--- a/drivers/staging/pohmelfs/inode.c
+++ b/drivers/staging/pohmelfs/inode.c
@@ -1529,9 +1529,9 @@ static void pohmelfs_drop_scan(struct work_struct *work)
 	struct pohmelfs_inode *pi;
 	unsigned int count = 0;
 
-	while ((pi = pohmelfs_get_inode_from_list(psb, &amp;psb-&gt;drop_list, &amp;count))) {
+	while ((pi = pohmelfs_get_inode_from_list(psb, &amp;psb-&gt;drop_list, &amp;count)))
 		pohmelfs_put_inode_count(pi, count);
-	}
+
 	pohmelfs_check_states(psb);
 
 	if (psb-&gt;drop_scan_timeout)
@@ -1568,9 +1568,8 @@ static void pohmelfs_trans_scan_state(struct netfs_state *st)
 		rb_node = rb_next(rb_node);
 
 		err = -ETIMEDOUT;
-		if (timeout &amp;&amp; (++dst-&gt;retries &lt; psb-&gt;trans_retries)) {
+		if (timeout &amp;&amp; (++dst-&gt;retries &lt; psb-&gt;trans_retries))
 			err = netfs_trans_resend(t, psb);
-		}
 
 		if (err || (t-&gt;flags &amp; NETFS_TRANS_SINGLE_DST)) {
 			if (netfs_trans_remove_nolock(dst, st))
diff --git a/drivers/staging/pohmelfs/net.c b/drivers/staging/pohmelfs/net.c
index 3d1c0bc5558d..5f312c91aab6 100644
--- a/drivers/staging/pohmelfs/net.c
+++ b/drivers/staging/pohmelfs/net.c
@@ -914,9 +914,9 @@ static int pohmelfs_recv(void *data)
 				unsigned char *hash = e-&gt;data;
 
 				dprintk("%s: received hash: ", __func__);
-				for (i=0; i&lt;cmd-&gt;csize; ++i) {
+				for (i=0; i&lt;cmd-&gt;csize; ++i)
 					printk("%02x ", hash[i]);
-				}
+
 				printk("\n");
 			}
 #endif
diff --git a/drivers/staging/pohmelfs/trans.c b/drivers/staging/pohmelfs/trans.c
index 2a4568d58012..4587f6d546aa 100644
--- a/drivers/staging/pohmelfs/trans.c
+++ b/drivers/staging/pohmelfs/trans.c
@@ -178,9 +178,9 @@ int netfs_trans_send(struct netfs_trans *t, struct netfs_state *st)
 
 err_out_unlock_return:
 
-	if (st-&gt;need_reset) {
+	if (st-&gt;need_reset)
 		netfs_state_exit(st);
-	}
+
 	netfs_state_unlock_send(st);
 
 	dprintk("%s: t: %p, gen: %u, err: %d.\n",</pre><hr><pre>commit 3bafeab78116bb58be3cafb06b401b2973a71ed4
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Apr 22 08:59:14 2009 -0400

    Staging: pohmelfs: Remove C99 comments
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Evgeniy Polyakov &lt;zbr@ioremap.net&gt;

diff --git a/drivers/staging/pohmelfs/dir.c b/drivers/staging/pohmelfs/dir.c
index b5799842fb84..71210b1c86c9 100644
--- a/drivers/staging/pohmelfs/dir.c
+++ b/drivers/staging/pohmelfs/dir.c
@@ -562,7 +562,7 @@ struct dentry *pohmelfs_lookup(struct inode *dir, struct dentry *dentry, struct
 		if (!inode) {
 			dprintk("%s: No inode for ino: %lu, name: '%s', hash: %x.\n",
 				__func__, ino, str.name, str.hash);
-			//return NULL;
+			/* return NULL; */
 			return ERR_PTR(-EACCES);
 		}
 	} else {
diff --git a/drivers/staging/pohmelfs/inode.c b/drivers/staging/pohmelfs/inode.c
index b2eaf9047266..6256c5c7a5ad 100644
--- a/drivers/staging/pohmelfs/inode.c
+++ b/drivers/staging/pohmelfs/inode.c
@@ -386,7 +386,7 @@ static int pohmelfs_write_inode_create_children(struct inode *inode)
 		if (inode &amp;&amp; (inode-&gt;i_state &amp; I_DIRTY)) {
 			struct pohmelfs_inode *pi = POHMELFS_I(inode);
 			pohmelfs_write_create_inode(pi);
-			//pohmelfs_meta_command(pi, NETFS_INODE_INFO, 0, NULL, NULL, 0);
+			/* pohmelfs_meta_command(pi, NETFS_INODE_INFO, 0, NULL, NULL, 0); */
 			iput(inode);
 		}
 	}
@@ -845,7 +845,7 @@ static void pohmelfs_destroy_inode(struct inode *inode)
 	struct pohmelfs_sb *psb = POHMELFS_SB(sb);
 	struct pohmelfs_inode *pi = POHMELFS_I(inode);
 
-	//pohmelfs_data_unlock(pi, 0, inode-&gt;i_size, POHMELFS_READ_LOCK);
+	/* pohmelfs_data_unlock(pi, 0, inode-&gt;i_size, POHMELFS_READ_LOCK); */
 
 	pohmelfs_inode_del_inode(psb, pi);
 
@@ -1777,7 +1777,7 @@ static int pohmelfs_show_stats(struct seq_file *m, struct vfsmount *mnt)
 		seq_printf(m, "%u ", ctl-&gt;idx);
 		if (ctl-&gt;addr.sa_family == AF_INET) {
 			struct sockaddr_in *sin = (struct sockaddr_in *)&amp;st-&gt;ctl.addr;
-			//seq_printf(m, "%pi4:%u", &amp;sin-&gt;sin_addr.s_addr, ntohs(sin-&gt;sin_port));
+			/* seq_printf(m, "%pi4:%u", &amp;sin-&gt;sin_addr.s_addr, ntohs(sin-&gt;sin_port)); */
 			seq_printf(m, "%u.%u.%u.%u:%u", NIPQUAD(sin-&gt;sin_addr.s_addr), ntohs(sin-&gt;sin_port));
 		} else if (ctl-&gt;addr.sa_family == AF_INET6) {
 			struct sockaddr_in6 *sin = (struct sockaddr_in6 *)&amp;st-&gt;ctl.addr;
diff --git a/drivers/staging/pohmelfs/netfs.h b/drivers/staging/pohmelfs/netfs.h
index 7ef2769f353d..3b60c611ba80 100644
--- a/drivers/staging/pohmelfs/netfs.h
+++ b/drivers/staging/pohmelfs/netfs.h
@@ -844,7 +844,7 @@ static inline int pohmelfs_need_lock(struct pohmelfs_inode *pi, int type)
 int __init pohmelfs_mcache_init(void);
 void pohmelfs_mcache_exit(void);
 
-//#define CONFIG_POHMELFS_DEBUG
+/* #define CONFIG_POHMELFS_DEBUG */
 
 #ifdef CONFIG_POHMELFS_DEBUG
 #define dprintka(f, a...) printk(f, ##a)</pre><hr><pre>commit 385e3f1a1464b4ec27bbd92a999f05de0dabaa85
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Apr 22 08:59:13 2009 -0400

    Staging: pohmelfs: move open brace to same line on structs
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: Evgeniy Polyakov &lt;zbr@ioremap.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/pohmelfs/crypto.c b/drivers/staging/pohmelfs/crypto.c
index 31d765de92ce..19781ad782fb 100644
--- a/drivers/staging/pohmelfs/crypto.c
+++ b/drivers/staging/pohmelfs/crypto.c
@@ -832,8 +832,7 @@ int pohmelfs_trans_crypt(struct netfs_trans *trans, struct pohmelfs_sb *psb)
 	return pohmelfs_crypto_thread_get(psb, pohmelfs_trans_crypt_action, trans);
 }
 
-struct pohmelfs_crypto_input_action_data
-{
+struct pohmelfs_crypto_input_action_data {
 	struct page			*page;
 	struct pohmelfs_crypto_engine	*e;
 	u64				iv;
diff --git a/drivers/staging/pohmelfs/net.c b/drivers/staging/pohmelfs/net.c
index 11ecac026ca7..3d1c0bc5558d 100644
--- a/drivers/staging/pohmelfs/net.c
+++ b/drivers/staging/pohmelfs/net.c
@@ -168,8 +168,7 @@ int pohmelfs_data_recv_and_check(struct netfs_state *st, void *data, unsigned in
  * Polling machinery.
  */
 
-struct netfs_poll_helper
-{
+struct netfs_poll_helper {
 	poll_table 		pt;
 	struct netfs_state	*st;
 };
diff --git a/drivers/staging/pohmelfs/netfs.h b/drivers/staging/pohmelfs/netfs.h
index c78cfcb042fb..7ef2769f353d 100644
--- a/drivers/staging/pohmelfs/netfs.h
+++ b/drivers/staging/pohmelfs/netfs.h
@@ -30,8 +30,7 @@
  * Network command structure.
  * Will be extended.
  */
-struct netfs_cmd
-{
+struct netfs_cmd {
 	__u16			cmd;	/* Command number */
 	__u16			csize;	/* Attached crypto information size */
 	__u16			cpad;	/* Attached padding size */
@@ -96,8 +95,7 @@ enum {
  */
 #define _K_SS_MAXSIZE	128
 
-struct saddr
-{
+struct saddr {
 	unsigned short		sa_family;
 	char			addr[_K_SS_MAXSIZE];
 };
@@ -107,8 +105,7 @@ enum {
 	POHMELFS_CRYPTO_CIPHER,
 };
 
-struct pohmelfs_crypto
-{
+struct pohmelfs_crypto {
 	unsigned int		idx;		/* Config index */
 	unsigned short		strlen;		/* Size of the attached crypto string including 0-byte
 						 * "cbc(aes)" for example */
@@ -123,8 +120,7 @@ struct pohmelfs_crypto
 /*
  * Configuration command used to create table of different remote servers.
  */
-struct pohmelfs_ctl
-{
+struct pohmelfs_ctl {
 	__u32			idx;		/* Config index */
 	__u32			type;		/* Socket type */
 	__u32			proto;		/* Socket protocol */
@@ -137,8 +133,7 @@ struct pohmelfs_ctl
 /*
  * Ack for userspace about requested command.
  */
-struct pohmelfs_cn_ack
-{
+struct pohmelfs_cn_ack {
 	struct cn_msg		msg;
 	int			error;
 	int			msg_num;
@@ -150,8 +145,7 @@ struct pohmelfs_cn_ack
  * Inode info structure used to sync with server.
  * Check what stat() returns.
  */
-struct netfs_inode_info
-{
+struct netfs_inode_info {
 	unsigned int		mode;
 	unsigned int		nlink;
 	unsigned int		uid;
@@ -205,8 +199,7 @@ enum pohmelfs_capabilities {
 /* Extended attributes support on/off */
 #define POHMELFS_FLAGS_XATTR		(1&lt;&lt;1)
 
-struct netfs_root_capabilities
-{
+struct netfs_root_capabilities {
 	__u64			nr_files;
 	__u64			used, avail;
 	__u64			flags;
@@ -220,8 +213,7 @@ static inline void netfs_convert_root_capabilities(struct netfs_root_capabilitie
 	cap-&gt;flags = __cpu_to_be64(cap-&gt;flags);
 }
 
-struct netfs_crypto_capabilities
-{
+struct netfs_crypto_capabilities {
 	unsigned short		hash_strlen;	/* Hash string length, like "hmac(sha1) including 0 byte "*/
 	unsigned short		cipher_strlen;	/* Cipher string length with the same format */
 	unsigned int		cipher_keysize;	/* Cipher key size */
@@ -241,8 +233,7 @@ enum pohmelfs_lock_type {
 	POHMELFS_WRITE_LOCK,
 };
 
-struct netfs_lock
-{
+struct netfs_lock {
 	__u64			start;
 	__u64			ino;
 	__u32			size;
@@ -268,8 +259,7 @@ static inline void netfs_convert_lock(struct netfs_lock *lock)
 /*
  * Private POHMELFS cache of objects in directory.
  */
-struct pohmelfs_name
-{
+struct pohmelfs_name {
 	struct rb_node		hash_node;
 
 	struct list_head	sync_create_entry;
@@ -286,8 +276,7 @@ struct pohmelfs_name
 /*
  * POHMELFS inode. Main object.
  */
-struct pohmelfs_inode
-{
+struct pohmelfs_inode {
 	struct list_head	inode_entry;		/* Entry in superblock list.
 							 * Objects which are not bound to dentry require to be dropped
 							 * in -&gt;put_super()
@@ -318,8 +307,7 @@ typedef int (* netfs_trans_complete_t)(struct page **pages, unsigned int page_nu
 struct netfs_state;
 struct pohmelfs_sb;
 
-struct netfs_trans
-{
+struct netfs_trans {
 	/*
 	 * Transaction header and attached contiguous data live here.
 	 */
@@ -426,8 +414,7 @@ static inline void netfs_trans_reset(struct netfs_trans *t)
 	t-&gt;complete = NULL;
 }
 
-struct netfs_trans_dst
-{
+struct netfs_trans_dst {
 	struct list_head		trans_entry;
 	struct rb_node			state_entry;
 
@@ -456,8 +443,7 @@ int netfs_trans_remove_nolock(struct netfs_trans_dst *dst, struct netfs_state *s
 int netfs_trans_init(void);
 void netfs_trans_exit(void);
 
-struct pohmelfs_crypto_engine
-{
+struct pohmelfs_crypto_engine {
 	u64				iv;		/* Crypto IV for current operation */
 	unsigned long			timeout;	/* Crypto waiting timeout */
 	unsigned int			size;		/* Size of crypto scratchpad */
@@ -474,8 +460,7 @@ struct pohmelfs_crypto_engine
 	unsigned int			page_num;
 };
 
-struct pohmelfs_crypto_thread
-{
+struct pohmelfs_crypto_thread {
 	struct list_head		thread_entry;
 
 	struct task_struct		*thread;
@@ -497,8 +482,7 @@ void pohmelfs_crypto_thread_make_ready(struct pohmelfs_crypto_thread *th);
 /*
  * Network state, attached to one server.
  */
-struct netfs_state
-{
+struct netfs_state {
 	struct mutex		__state_lock;		/* Can not allow to use the same socket simultaneously */
 	struct mutex		__state_send_lock;
 	struct netfs_cmd 	cmd;			/* Cached command */
@@ -580,8 +564,7 @@ static inline unsigned int netfs_state_poll(struct netfs_state *st)
 
 struct pohmelfs_config;
 
-struct pohmelfs_sb
-{
+struct pohmelfs_sb {
 	struct rb_root		mcache_root;
 	struct mutex		mcache_lock;
 	atomic_long_t		mcache_gen;
@@ -718,15 +701,13 @@ static inline void pohmelfs_put_inode(struct pohmelfs_inode *pi)
 	spin_unlock(&amp;psb-&gt;ino_lock);
 }
 
-struct pohmelfs_config
-{
+struct pohmelfs_config {
 	struct list_head	config_entry;
 
 	struct netfs_state	state;
 };
 
-struct pohmelfs_config_group
-{
+struct pohmelfs_config_group {
 	/*
 	 * Entry in the global config group list.
 	 */
@@ -814,8 +795,7 @@ void pohmelfs_switch_active(struct pohmelfs_sb *psb);
 int pohmelfs_construct_path_string(struct pohmelfs_inode *pi, void *data, int len);
 int pohmelfs_path_length(struct pohmelfs_inode *pi);
 
-struct pohmelfs_crypto_completion
-{
+struct pohmelfs_crypto_completion {
 	struct completion	complete;
 	int			error;
 };
@@ -891,8 +871,7 @@ static inline void netfs_trans_put(struct netfs_trans *t)
 	}
 }
 
-struct pohmelfs_mcache
-{
+struct pohmelfs_mcache {
 	struct rb_node			mcache_entry;
 	struct completion		complete;
 </pre><hr><pre>commit 0b8f754a6220158f2348bc6eae2772bc64bc98a2
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu May 14 15:24:29 2009 -0400

    staging: comedi: Move pcm do_cmdtest function into a single source file
    
    Many of the comedi source code has functions that were created with
    cut and paste, this moves the do_cmdtest function into a single file.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/Makefile b/drivers/staging/comedi/drivers/Makefile
index 4b56c07823b7..df2854d543cc 100644
--- a/drivers/staging/comedi/drivers/Makefile
+++ b/drivers/staging/comedi/drivers/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_COMEDI)			+= comedi_fc.o
 obj-$(CONFIG_COMEDI)			+= comedi_bond.o
 obj-$(CONFIG_COMEDI)			+= comedi_test.o
 obj-$(CONFIG_COMEDI)			+= comedi_parport.o
+obj-$(CONFIG_COMEDI)			+= pcm_common.o
 
 # Comedi PCI drivers
 obj-$(CONFIG_COMEDI_PCI_DRIVERS)	+= 8255.o
diff --git a/drivers/staging/comedi/drivers/pcm_common.c b/drivers/staging/comedi/drivers/pcm_common.c
new file mode 100644
index 000000000000..ebd9838232af
--- /dev/null
+++ b/drivers/staging/comedi/drivers/pcm_common.c
@@ -0,0 +1,111 @@
+#include "../comedidev.h"
+#include "pcm_common.h"
+
+/*
+ * 'do_cmdtest' function for an 'INTERRUPT' subdevice.  This is for
+ * the PCM drivers.
+ */
+int comedi_pcm_cmdtest(struct comedi_device *dev,
+		       struct comedi_subdevice *s, struct comedi_cmd *cmd)
+{
+	int err = 0;
+	unsigned int tmp;
+
+	/* step 1: make sure trigger sources are trivially valid */
+
+	tmp = cmd-&gt;start_src;
+	cmd-&gt;start_src &amp;= (TRIG_NOW | TRIG_INT);
+	if (!cmd-&gt;start_src || tmp != cmd-&gt;start_src)
+		err++;
+
+	tmp = cmd-&gt;scan_begin_src;
+	cmd-&gt;scan_begin_src &amp;= TRIG_EXT;
+	if (!cmd-&gt;scan_begin_src || tmp != cmd-&gt;scan_begin_src)
+		err++;
+
+	tmp = cmd-&gt;convert_src;
+	cmd-&gt;convert_src &amp;= TRIG_NOW;
+	if (!cmd-&gt;convert_src || tmp != cmd-&gt;convert_src)
+		err++;
+
+	tmp = cmd-&gt;scan_end_src;
+	cmd-&gt;scan_end_src &amp;= TRIG_COUNT;
+	if (!cmd-&gt;scan_end_src || tmp != cmd-&gt;scan_end_src)
+		err++;
+
+	tmp = cmd-&gt;stop_src;
+	cmd-&gt;stop_src &amp;= (TRIG_COUNT | TRIG_NONE);
+	if (!cmd-&gt;stop_src || tmp != cmd-&gt;stop_src)
+		err++;
+
+	if (err)
+		return 1;
+
+	/* step 2: make sure trigger sources are unique and mutually compatible */
+
+	/* these tests are true if more than one _src bit is set */
+	if ((cmd-&gt;start_src &amp; (cmd-&gt;start_src - 1)) != 0)
+		err++;
+	if ((cmd-&gt;scan_begin_src &amp; (cmd-&gt;scan_begin_src - 1)) != 0)
+		err++;
+	if ((cmd-&gt;convert_src &amp; (cmd-&gt;convert_src - 1)) != 0)
+		err++;
+	if ((cmd-&gt;scan_end_src &amp; (cmd-&gt;scan_end_src - 1)) != 0)
+		err++;
+	if ((cmd-&gt;stop_src &amp; (cmd-&gt;stop_src - 1)) != 0)
+		err++;
+
+	if (err)
+		return 2;
+
+	/* step 3: make sure arguments are trivially compatible */
+
+	/* cmd-&gt;start_src == TRIG_NOW || cmd-&gt;start_src == TRIG_INT */
+	if (cmd-&gt;start_arg != 0) {
+		cmd-&gt;start_arg = 0;
+		err++;
+	}
+
+	/* cmd-&gt;scan_begin_src == TRIG_EXT */
+	if (cmd-&gt;scan_begin_arg != 0) {
+		cmd-&gt;scan_begin_arg = 0;
+		err++;
+	}
+
+	/* cmd-&gt;convert_src == TRIG_NOW */
+	if (cmd-&gt;convert_arg != 0) {
+		cmd-&gt;convert_arg = 0;
+		err++;
+	}
+
+	/* cmd-&gt;scan_end_src == TRIG_COUNT */
+	if (cmd-&gt;scan_end_arg != cmd-&gt;chanlist_len) {
+		cmd-&gt;scan_end_arg = cmd-&gt;chanlist_len;
+		err++;
+	}
+
+	switch (cmd-&gt;stop_src) {
+	case TRIG_COUNT:
+		/* any count allowed */
+		break;
+	case TRIG_NONE:
+		if (cmd-&gt;stop_arg != 0) {
+			cmd-&gt;stop_arg = 0;
+			err++;
+		}
+		break;
+	default:
+		break;
+	}
+
+	if (err)
+		return 3;
+
+	/* step 4: fix up any arguments */
+
+	/* if (err) return 4; */
+
+	return 0;
+}
+
+EXPORT_SYMBOL(comedi_pcm_cmdtest);
diff --git a/drivers/staging/comedi/drivers/pcm_common.h b/drivers/staging/comedi/drivers/pcm_common.h
new file mode 100644
index 000000000000..cd4840c11444
--- /dev/null
+++ b/drivers/staging/comedi/drivers/pcm_common.h
@@ -0,0 +1,8 @@
+#ifndef _comedi_common_H
+#define _comedi_common_H
+
+extern int comedi_pcm_cmdtest(struct comedi_device *dev,
+			      struct comedi_subdevice *s,
+			      struct comedi_cmd *cmd);
+
+#endif
diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index e1ad03e234b7..cdf501afa14e 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -75,6 +75,7 @@ Configuration Options:
 
 #include &lt;linux/interrupt.h&gt;
 #include "../comedidev.h"
+#include "pcm_common.h"
 #include &lt;linux/pci.h&gt;		/* for PCI devices */
 
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
@@ -1073,110 +1074,10 @@ static int pcmmio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/*
- * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
- */
 static int
 pcmmio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	int err = 0;
-	unsigned int tmp;
-
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd-&gt;start_src;
-	cmd-&gt;start_src &amp;= (TRIG_NOW | TRIG_INT);
-	if (!cmd-&gt;start_src || tmp != cmd-&gt;start_src)
-		err++;
-
-	tmp = cmd-&gt;scan_begin_src;
-	cmd-&gt;scan_begin_src &amp;= TRIG_EXT;
-	if (!cmd-&gt;scan_begin_src || tmp != cmd-&gt;scan_begin_src)
-		err++;
-
-	tmp = cmd-&gt;convert_src;
-	cmd-&gt;convert_src &amp;= TRIG_NOW;
-	if (!cmd-&gt;convert_src || tmp != cmd-&gt;convert_src)
-		err++;
-
-	tmp = cmd-&gt;scan_end_src;
-	cmd-&gt;scan_end_src &amp;= TRIG_COUNT;
-	if (!cmd-&gt;scan_end_src || tmp != cmd-&gt;scan_end_src)
-		err++;
-
-	tmp = cmd-&gt;stop_src;
-	cmd-&gt;stop_src &amp;= (TRIG_COUNT | TRIG_NONE);
-	if (!cmd-&gt;stop_src || tmp != cmd-&gt;stop_src)
-		err++;
-
-	if (err)
-		return 1;
-
-	/* step 2: make sure trigger sources are unique and mutually compatible */
-
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd-&gt;start_src &amp; (cmd-&gt;start_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;scan_begin_src &amp; (cmd-&gt;scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;convert_src &amp; (cmd-&gt;convert_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;scan_end_src &amp; (cmd-&gt;scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;stop_src &amp; (cmd-&gt;stop_src - 1)) != 0)
-		err++;
-
-	if (err)
-		return 2;
-
-	/* step 3: make sure arguments are trivially compatible */
-
-	/* cmd-&gt;start_src == TRIG_NOW || cmd-&gt;start_src == TRIG_INT */
-	if (cmd-&gt;start_arg != 0) {
-		cmd-&gt;start_arg = 0;
-		err++;
-	}
-
-	/* cmd-&gt;scan_begin_src == TRIG_EXT */
-	if (cmd-&gt;scan_begin_arg != 0) {
-		cmd-&gt;scan_begin_arg = 0;
-		err++;
-	}
-
-	/* cmd-&gt;convert_src == TRIG_NOW */
-	if (cmd-&gt;convert_arg != 0) {
-		cmd-&gt;convert_arg = 0;
-		err++;
-	}
-
-	/* cmd-&gt;scan_end_src == TRIG_COUNT */
-	if (cmd-&gt;scan_end_arg != cmd-&gt;chanlist_len) {
-		cmd-&gt;scan_end_arg = cmd-&gt;chanlist_len;
-		err++;
-	}
-
-	switch (cmd-&gt;stop_src) {
-	case TRIG_COUNT:
-		/* any count allowed */
-		break;
-	case TRIG_NONE:
-		if (cmd-&gt;stop_arg != 0) {
-			cmd-&gt;stop_arg = 0;
-			err++;
-		}
-		break;
-	default:
-		break;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	/* if (err) return 4; */
-
-	return 0;
+	return comedi_pcm_cmdtest(dev, s, cmd);
 }
 
 static int adc_wait_ready(unsigned long iobase)
diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index ce0aa6b87fb0..81ee7cdc0caf 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -77,6 +77,7 @@ Configuration Options:
 
 #include &lt;linux/interrupt.h&gt;
 #include "../comedidev.h"
+#include "pcm_common.h"
 
 #include &lt;linux/pci.h&gt;		/* for PCI devices */
 
@@ -984,110 +985,10 @@ static int pcmuio_cmd(struct comedi_device *dev, struct comedi_subdevice *s)
 	return 0;
 }
 
-/*
- * 'do_cmdtest' function for an 'INTERRUPT' subdevice.
- */
 static int
 pcmuio_cmdtest(struct comedi_device *dev, struct comedi_subdevice *s, struct comedi_cmd *cmd)
 {
-	int err = 0;
-	unsigned int tmp;
-
-	/* step 1: make sure trigger sources are trivially valid */
-
-	tmp = cmd-&gt;start_src;
-	cmd-&gt;start_src &amp;= (TRIG_NOW | TRIG_INT);
-	if (!cmd-&gt;start_src || tmp != cmd-&gt;start_src)
-		err++;
-
-	tmp = cmd-&gt;scan_begin_src;
-	cmd-&gt;scan_begin_src &amp;= TRIG_EXT;
-	if (!cmd-&gt;scan_begin_src || tmp != cmd-&gt;scan_begin_src)
-		err++;
-
-	tmp = cmd-&gt;convert_src;
-	cmd-&gt;convert_src &amp;= TRIG_NOW;
-	if (!cmd-&gt;convert_src || tmp != cmd-&gt;convert_src)
-		err++;
-
-	tmp = cmd-&gt;scan_end_src;
-	cmd-&gt;scan_end_src &amp;= TRIG_COUNT;
-	if (!cmd-&gt;scan_end_src || tmp != cmd-&gt;scan_end_src)
-		err++;
-
-	tmp = cmd-&gt;stop_src;
-	cmd-&gt;stop_src &amp;= (TRIG_COUNT | TRIG_NONE);
-	if (!cmd-&gt;stop_src || tmp != cmd-&gt;stop_src)
-		err++;
-
-	if (err)
-		return 1;
-
-	/* step 2: make sure trigger sources are unique and mutually compatible */
-
-	/* these tests are true if more than one _src bit is set */
-	if ((cmd-&gt;start_src &amp; (cmd-&gt;start_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;scan_begin_src &amp; (cmd-&gt;scan_begin_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;convert_src &amp; (cmd-&gt;convert_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;scan_end_src &amp; (cmd-&gt;scan_end_src - 1)) != 0)
-		err++;
-	if ((cmd-&gt;stop_src &amp; (cmd-&gt;stop_src - 1)) != 0)
-		err++;
-
-	if (err)
-		return 2;
-
-	/* step 3: make sure arguments are trivially compatible */
-
-	/* cmd-&gt;start_src == TRIG_NOW || cmd-&gt;start_src == TRIG_INT */
-	if (cmd-&gt;start_arg != 0) {
-		cmd-&gt;start_arg = 0;
-		err++;
-	}
-
-	/* cmd-&gt;scan_begin_src == TRIG_EXT */
-	if (cmd-&gt;scan_begin_arg != 0) {
-		cmd-&gt;scan_begin_arg = 0;
-		err++;
-	}
-
-	/* cmd-&gt;convert_src == TRIG_NOW */
-	if (cmd-&gt;convert_arg != 0) {
-		cmd-&gt;convert_arg = 0;
-		err++;
-	}
-
-	/* cmd-&gt;scan_end_src == TRIG_COUNT */
-	if (cmd-&gt;scan_end_arg != cmd-&gt;chanlist_len) {
-		cmd-&gt;scan_end_arg = cmd-&gt;chanlist_len;
-		err++;
-	}
-
-	switch (cmd-&gt;stop_src) {
-	case TRIG_COUNT:
-		/* any count allowed */
-		break;
-	case TRIG_NONE:
-		if (cmd-&gt;stop_arg != 0) {
-			cmd-&gt;stop_arg = 0;
-			err++;
-		}
-		break;
-	default:
-		break;
-	}
-
-	if (err)
-		return 3;
-
-	/* step 4: fix up any arguments */
-
-	/* if (err) return 4; */
-
-	return 0;
+	return comedi_pcm_cmdtest(dev, s, cmd);
 }
 
 /*</pre><hr><pre>commit 214e7b5c8281bf41238f575128e4fec5652ed797
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu May 14 15:24:28 2009 -0400

    staging: comedi: Remove MIN macro
    
    Remove the MIN() macro and instead use the min() provided by kernel.h
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/pcmda12.c b/drivers/staging/comedi/drivers/pcmda12.c
index f1a8cdfaaa48..6e172a6b1cb2 100644
--- a/drivers/staging/comedi/drivers/pcmda12.c
+++ b/drivers/staging/comedi/drivers/pcmda12.c
@@ -55,7 +55,6 @@ Configuration Options:
 
 #include &lt;linux/pci.h&gt;		/* for PCI devices */
 
-#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
 #define SDEV_NO ((int)(s - dev-&gt;subdevices))
 #define CHANS 8
 #define IOSIZE 16
diff --git a/drivers/staging/comedi/drivers/pcmmio.c b/drivers/staging/comedi/drivers/pcmmio.c
index 6931f1075089..e1ad03e234b7 100644
--- a/drivers/staging/comedi/drivers/pcmmio.c
+++ b/drivers/staging/comedi/drivers/pcmmio.c
@@ -77,8 +77,6 @@ Configuration Options:
 #include "../comedidev.h"
 #include &lt;linux/pci.h&gt;		/* for PCI devices */
 
-#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
-
 /* This stuff is all from pcmuio.c -- it refers to the DIO subdevices only */
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
@@ -436,7 +434,7 @@ static int pcmmio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s-&gt;type = COMEDI_SUBD_DIO;
 		s-&gt;insn_bits = pcmmio_dio_insn_bits;
 		s-&gt;insn_config = pcmmio_dio_insn_config;
-		s-&gt;n_chan = MIN(chans_left, MAX_CHANS_PER_SUBDEV);
+		s-&gt;n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv-&gt;dio.intr.asic = -1;
 		subpriv-&gt;dio.intr.first_chan = -1;
 		subpriv-&gt;dio.intr.asic_chan = -1;
diff --git a/drivers/staging/comedi/drivers/pcmuio.c b/drivers/staging/comedi/drivers/pcmuio.c
index 8df67c37795b..ce0aa6b87fb0 100644
--- a/drivers/staging/comedi/drivers/pcmuio.c
+++ b/drivers/staging/comedi/drivers/pcmuio.c
@@ -80,7 +80,6 @@ Configuration Options:
 
 #include &lt;linux/pci.h&gt;		/* for PCI devices */
 
-#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b))
 #define CHANS_PER_PORT   8
 #define PORTS_PER_ASIC   6
 #define INTR_PORTS_PER_ASIC   3
@@ -360,7 +359,7 @@ static int pcmuio_attach(struct comedi_device *dev, struct comedi_devconfig *it)
 		s-&gt;type = COMEDI_SUBD_DIO;
 		s-&gt;insn_bits = pcmuio_dio_insn_bits;
 		s-&gt;insn_config = pcmuio_dio_insn_config;
-		s-&gt;n_chan = MIN(chans_left, MAX_CHANS_PER_SUBDEV);
+		s-&gt;n_chan = min(chans_left, MAX_CHANS_PER_SUBDEV);
 		subpriv-&gt;intr.asic = -1;
 		subpriv-&gt;intr.first_chan = -1;
 		subpriv-&gt;intr.asic_chan = -1;</pre><hr><pre>commit ba7834b3f335f6bdef95e416d72245f6687cc660
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Sun Apr 26 14:45:12 2009 -0400

    Staging: comedi: simply read and write functions in adl_pci8164
    
    There are several read and write functions in adl_pci8164 that are
    essentially the same thing.  They were created with a cut and paste.
    Change them to use a common function.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/adl_pci8164.c b/drivers/staging/comedi/drivers/adl_pci8164.c
index 2fe577a973af..2d7d68af6b1e 100644
--- a/drivers/staging/comedi/drivers/adl_pci8164.c
+++ b/drivers/staging/comedi/drivers/adl_pci8164.c
@@ -208,8 +208,16 @@ static int adl_pci8164_detach(struct comedi_device *dev)
 	return 0;
 }
 
-static int adl_pci8164_insn_read_msts(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+/*
+ all the read commands are the same except for the addition a constant
+ * const to the data for inw()
+ */
+static void adl_pci8164_insn_read(struct comedi_device *dev,
+				  struct comedi_subdevice *s,
+				  struct comedi_insn *insn,
+				  unsigned int *data,
+				  char *action,
+				  unsigned short offset)
 {
 	int axis, axis_reg;
 	char *axisname;
@@ -238,127 +246,51 @@ static int adl_pci8164_insn_read_msts(struct comedi_device *dev, struct comedi_s
 		axisname = "X";
 	}
 
-	data[0] = inw(dev-&gt;iobase + axis_reg + PCI8164_MSTS);
-	printk("comedi: pci8164 MSTS read -&gt; %04X:%04X on axis %s\n", data[0],
+	data[0] = inw(dev-&gt;iobase + axis_reg + offset);
+	printk("comedi: pci8164 %s read -&gt; %04X:%04X on axis %s\n", action, data[0],
 		data[1], axisname);
+}
 
+static int adl_pci8164_insn_read_msts(struct comedi_device *dev,
+				      struct comedi_subdevice *s,
+				      struct comedi_insn *insn,
+				      unsigned int *data)
+{
+	adl_pci8164_insn_read(dev, s, insn, data, "MSTS", PCI8164_MSTS);
 	return 2;
 }
 
 static int adl_pci8164_insn_read_ssts(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct comedi_insn *insn, unsigned int *data)
 {
-	int axis, axis_reg;
-	char *axisname;
-
-	axis = CR_CHAN(insn-&gt;chanspec);
-
-	switch (axis) {
-	case 0:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-		break;
-	case 1:
-		axis_reg = PCI8164_AXIS_Y;
-		axisname = "Y";
-		break;
-	case 2:
-		axis_reg = PCI8164_AXIS_Z;
-		axisname = "Z";
-		break;
-	case 3:
-		axis_reg = PCI8164_AXIS_U;
-		axisname = "U";
-		break;
-	default:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-	}
-
-	data[0] = inw(dev-&gt;iobase + axis_reg + PCI8164_SSTS);
-	printk("comedi: pci8164 SSTS read -&gt; %04X:%04X on axis %s\n", data[0],
-		data[1], axisname);
-
+	adl_pci8164_insn_read(dev, s, insn, data, "SSTS", PCI8164_SSTS);
 	return 2;
 }
 
 static int adl_pci8164_insn_read_buf0(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct comedi_insn *insn, unsigned int *data)
 {
-	int axis, axis_reg;
-	char *axisname;
-
-	axis = CR_CHAN(insn-&gt;chanspec);
-
-	switch (axis) {
-	case 0:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-		break;
-	case 1:
-		axis_reg = PCI8164_AXIS_Y;
-		axisname = "Y";
-		break;
-	case 2:
-		axis_reg = PCI8164_AXIS_Z;
-		axisname = "Z";
-		break;
-	case 3:
-		axis_reg = PCI8164_AXIS_U;
-		axisname = "U";
-		break;
-	default:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-	}
-
-	data[0] = inw(dev-&gt;iobase + axis_reg + PCI8164_BUF0);
-	printk("comedi: pci8164 BUF0 read -&gt; %04X:%04X on axis %s\n", data[0],
-		data[1], axisname);
-
+	adl_pci8164_insn_read(dev, s, insn, data, "BUF0", PCI8164_BUF0);
 	return 2;
 }
 
 static int adl_pci8164_insn_read_buf1(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct comedi_insn *insn, unsigned int *data)
 {
-	int axis, axis_reg;
-
-	char *axisname;
-
-	axis = CR_CHAN(insn-&gt;chanspec);
-
-	switch (axis) {
-	case 0:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-		break;
-	case 1:
-		axis_reg = PCI8164_AXIS_Y;
-		axisname = "Y";
-		break;
-	case 2:
-		axis_reg = PCI8164_AXIS_Z;
-		axisname = "Z";
-		break;
-	case 3:
-		axis_reg = PCI8164_AXIS_U;
-		axisname = "U";
-		break;
-	default:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-	}
-
-	data[0] = inw(dev-&gt;iobase + axis_reg + PCI8164_BUF1);
-	printk("comedi: pci8164 BUF1 read -&gt; %04X:%04X on axis %s\n", data[0],
-		data[1], axisname);
-
+	adl_pci8164_insn_read(dev, s, insn, data, "BUF1", PCI8164_BUF1);
 	return 2;
 }
 
-static int adl_pci8164_insn_write_cmd(struct comedi_device *dev, struct comedi_subdevice *s,
-	struct comedi_insn *insn, unsigned int *data)
+/*
+ all the write commands are the same except for the addition a constant
+ * const to the data for outw()
+ */
+static void adl_pci8164_insn_out(struct comedi_device *dev,
+					struct comedi_subdevice *s,
+					struct comedi_insn *insn,
+					unsigned int *data,
+					char *action,
+					unsigned short offset)
 {
 	unsigned int axis, axis_reg;
 
@@ -388,124 +320,39 @@ static int adl_pci8164_insn_write_cmd(struct comedi_device *dev, struct comedi_s
 		axisname = "X";
 	}
 
-	outw(data[0], dev-&gt;iobase + axis_reg + PCI8164_CMD);
-	printk("comedi: pci8164 CMD write -&gt; %04X:%04X on axis %s\n", data[0],
-		data[1], axisname);
+	outw(data[0], dev-&gt;iobase + axis_reg + offset);
 
+	printk("comedi: pci8164 %s write -&gt; %04X:%04X on axis %s\n", action,
+	       data[0], data[1], axisname);
+
+}
+
+
+static int adl_pci8164_insn_write_cmd(struct comedi_device *dev, struct comedi_subdevice *s,
+	struct comedi_insn *insn, unsigned int *data)
+{
+	adl_pci8164_insn_out(dev, s, insn, data, "CMD", PCI8164_CMD);
 	return 2;
 }
 
 static int adl_pci8164_insn_write_otp(struct comedi_device *dev, struct comedi_subdevice *s,
 	struct comedi_insn *insn, unsigned int *data)
 {
-	int axis, axis_reg;
-
-	char *axisname;
-
-	axis = CR_CHAN(insn-&gt;chanspec);
-
-	switch (axis) {
-	case 0:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-		break;
-	case 1:
-		axis_reg = PCI8164_AXIS_Y;
-		axisname = "Y";
-		break;
-	case 2:
-		axis_reg = PCI8164_AXIS_Z;
-		axisname = "Z";
-		break;
-	case 3:
-		axis_reg = PCI8164_AXIS_U;
-		axisname = "U";
-		break;
-	default:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-	}
-
-	outw(data[0], dev-&gt;iobase + axis_reg + PCI8164_OTP);
-	printk("comedi: pci8164 OTP write -&gt; %04X:%04X on axis %s\n", data[0],
-		data[1], axisname);
-
+	adl_pci8164_insn_out(dev, s, insn, data, "OTP", PCI8164_OTP);
 	return 2;
 }
 
 static int adl_pci8164_insn_write_buf0(struct comedi_device *dev,
 	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
-	int axis, axis_reg;
-
-	char *axisname;
-
-	axis = CR_CHAN(insn-&gt;chanspec);
-
-	switch (axis) {
-	case 0:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-		break;
-	case 1:
-		axis_reg = PCI8164_AXIS_Y;
-		axisname = "Y";
-		break;
-	case 2:
-		axis_reg = PCI8164_AXIS_Z;
-		axisname = "Z";
-		break;
-	case 3:
-		axis_reg = PCI8164_AXIS_U;
-		axisname = "U";
-		break;
-	default:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-	}
-
-	outw(data[0], dev-&gt;iobase + axis_reg + PCI8164_BUF0);
-	printk("comedi: pci8164 BUF0 write -&gt; %04X:%04X on axis %s\n", data[0],
-		data[1], axisname);
-
+	adl_pci8164_insn_out(dev, s, insn, data, "BUF0", PCI8164_BUF0);
 	return 2;
 }
 
 static int adl_pci8164_insn_write_buf1(struct comedi_device *dev,
 	struct comedi_subdevice *s, struct comedi_insn *insn, unsigned int *data)
 {
-	int axis, axis_reg;
-
-	char *axisname;
-
-	axis = CR_CHAN(insn-&gt;chanspec);
-
-	switch (axis) {
-	case 0:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-		break;
-	case 1:
-		axis_reg = PCI8164_AXIS_Y;
-		axisname = "Y";
-		break;
-	case 2:
-		axis_reg = PCI8164_AXIS_Z;
-		axisname = "Z";
-		break;
-	case 3:
-		axis_reg = PCI8164_AXIS_U;
-		axisname = "U";
-		break;
-	default:
-		axis_reg = PCI8164_AXIS_X;
-		axisname = "X";
-	}
-
-	outw(data[0], dev-&gt;iobase + axis_reg + PCI8164_BUF1);
-	printk("comedi: pci8164 BUF1 write -&gt; %04X:%04X on axis %s\n", data[0],
-		data[1], axisname);
-
+	adl_pci8164_insn_out(dev, s, insn, data, "BUF1", PCI8164_BUF1);
 	return 2;
 }
 </pre><hr><pre>commit 8605b3aa0c107b5df59e99dbde2e708aa0012efd
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Sun Apr 26 14:45:11 2009 -0400

    Staging: comedi: replace for loop with msleep()
    
    Replace 2 attempts to use a for loop as a sleep with a call to msleep().
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c b/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
index 556ed46d78a7..6e9e7ed4dba9 100644
--- a/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
@@ -180,7 +180,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 			}
 
 			/* Sleep */
-			for (i = 0; i &lt; 10000; i++) ;
+			msleep(1);
 
 		}
 		w_ReadWord =
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
index 89d4e21b9954..9b53255bd45b 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
@@ -224,7 +224,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 
 
 			/* Sleep */
-			for (i = 0; i &lt; 10000; i++) ;
+			msleep(1);
 
 		}
 		w_ReadWord =</pre><hr><pre>commit ff89514f8d46f470ffafeda129138ce73efd4c60
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Apr 23 15:54:58 2009 -0400

    Staging: comedi: move while to same line as } in do loops
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/addi-data/APCI1710_Ssi.c b/drivers/staging/comedi/drivers/addi-data/APCI1710_Ssi.c
index a94b98093826..a445dab50eac 100644
--- a/drivers/staging/comedi/drivers/addi-data/APCI1710_Ssi.c
+++ b/drivers/staging/comedi/drivers/addi-data/APCI1710_Ssi.c
@@ -477,9 +477,8 @@ int i_APCI1710_InsnReadSSIValue(struct comedi_device *dev, struct comedi_subdevi
 								s_BoardInfos.
 								ui_Address +
 								(64 * b_ModulNbr));
-						}
-						while ((dw_StatusReg &amp; 0x1) !=
-							0);
+						} while ((dw_StatusReg &amp; 0x1)
+							 != 0);
 
 		    /******************************/
 						/* Read the SSI counter value */
@@ -608,8 +607,7 @@ int i_APCI1710_InsnReadSSIValue(struct comedi_device *dev, struct comedi_subdevi
 							s_BoardInfos.
 							ui_Address +
 							(64 * b_ModulNbr));
-					}
-					while ((dw_StatusReg &amp; 0x1) != 0);
+					} while ((dw_StatusReg &amp; 0x1) != 0);
 
 					for (b_SSICpt = 0; b_SSICpt &lt; 3;
 						b_SSICpt++) {
diff --git a/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c b/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
index 6ada45a46d67..556ed46d78a7 100644
--- a/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_amcc_S5920.c
@@ -88,8 +88,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 				inl(dw_PCIBoardEepromAddress +
 				AMCC_OP_REG_MCSR);
 			dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-		}
-		while (dw_eeprom_busy == EEPROM_BUSY);
+		} while (dw_eeprom_busy == EEPROM_BUSY);
 
 		for (i_Counter = 0; i_Counter &lt; 2; i_Counter++) {
 			b_SelectedAddressLow = (w_EepromStartAddress + i_Counter) % 256;	/* Read the low 8 bit part */
@@ -106,8 +105,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Load the low address */
 			outb(b_SelectedAddressLow,
@@ -120,8 +118,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Select the load high address mode */
 			outb(NVCMD_LOAD_HIGH,
@@ -134,8 +131,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Load the high address */
 			outb(b_SelectedAddressHigh,
@@ -148,8 +144,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Select the READ mode */
 			outb(NVCMD_BEGIN_READ,
@@ -162,8 +157,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Read data into the EEPROM */
 			*pb_ReadByte =
@@ -176,8 +170,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Select the upper address part */
 			if (i_Counter == 0) {
diff --git a/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c b/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
index 208ade70ad0c..69b427390e53 100644
--- a/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
+++ b/drivers/staging/comedi/drivers/addi-data/addi_eeprom.c
@@ -411,8 +411,7 @@ void v_EepromWaitBusy(unsigned short w_PCIBoardEepromAddress)
 		b_EepromBusy = inb(w_PCIBoardEepromAddress + 0x3F);
 		b_EepromBusy = b_EepromBusy &amp; 0x80;
 
-	}
-	while (b_EepromBusy == 0x80);
+	} while (b_EepromBusy == 0x80);
 
 }
 
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
index 26aaeaf25683..69d5c3a92f08 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c
@@ -368,9 +368,8 @@ int i_APCI3120_InsnReadAnalogInput(struct comedi_device *dev, struct comedi_subd
 					us_TmpValue =
 						inw(devpriv-&gt;iobase +
 						APCI3120_RD_STATUS);
-				}
-				while ((us_TmpValue &amp; APCI3120_EOS) !=
-					APCI3120_EOS);
+				} while ((us_TmpValue &amp; APCI3120_EOS) !=
+					 APCI3120_EOS);
 
 				for (i = 0; i &lt; devpriv-&gt;ui_AiNbrofChannels;
 					i++) {
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
index 7dda06653402..89d4e21b9954 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3200.c
@@ -132,8 +132,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 				inl(dw_PCIBoardEepromAddress +
 				AMCC_OP_REG_MCSR);
 			dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-		}
-		while (dw_eeprom_busy == EEPROM_BUSY);
+		} while (dw_eeprom_busy == EEPROM_BUSY);
 
 		for (i_Counter = 0; i_Counter &lt; 2; i_Counter++) {
 			b_SelectedAddressLow = (w_EepromStartAddress + i_Counter) % 256;	/* Read the low 8 bit part */
@@ -150,8 +149,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Load the low address */
 			outb(b_SelectedAddressLow,
@@ -164,8 +162,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Select the load high address mode */
 			outb(NVCMD_LOAD_HIGH,
@@ -178,8 +175,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Load the high address */
 			outb(b_SelectedAddressHigh,
@@ -192,8 +188,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Select the READ mode */
 			outb(NVCMD_BEGIN_READ,
@@ -206,8 +201,7 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Read data into the EEPROM */
 			*pb_ReadByte =
@@ -220,15 +214,14 @@ int i_AddiHeaderRW_ReadEeprom(int i_NbOfWordsToRead,
 					inl(dw_PCIBoardEepromAddress +
 					AMCC_OP_REG_MCSR);
 				dw_eeprom_busy = dw_eeprom_busy &amp; EEPROM_BUSY;
-			}
-			while (dw_eeprom_busy == EEPROM_BUSY);
+			} while (dw_eeprom_busy == EEPROM_BUSY);
 
 			/* Select the upper address part */
-			if (i_Counter == 0) {
+			if (i_Counter == 0)
 				b_ReadLowByte = pb_ReadByte[0];
-			} else {
+			else
 				b_ReadHighByte = pb_ReadByte[0];
-			}
+
 
 			/* Sleep */
 			for (i = 0; i &lt; 10000; i++) ;
diff --git a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c
index 30594c8acd35..338727879827 100644
--- a/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c
+++ b/drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c
@@ -535,8 +535,7 @@ int i_APCI3XXX_InsnReadAnalogInput(struct comedi_device *dev,
 								dw_Temp =
 									dw_Temp
 									&amp; 1;
-							}
-							while (dw_Temp != 1);
+							} while (dw_Temp != 1);
 
 			  /*************************/
 							/* Read the analog value */
@@ -729,8 +728,7 @@ int i_APCI3XXX_InsnWriteAnalogOutput(struct comedi_device *dev,
 					dw_Status =
 						readl((void *)(devpriv-&gt;
 							dw_AiBase + 96));
-				}
-				while ((dw_Status &amp; 0x100) != 0x100);
+				} while ((dw_Status &amp; 0x100) != 0x100);
 			} else {
 		 /***************************/
 				/* Channel not initialised */</pre><hr><pre>commit c4d30ee861c3a3a361f934e6f96b1d07a2889976
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Apr 23 15:54:57 2009 -0400

    Staging: comedi: comment out useless if
    
    This if test doesn't do anything, so comment it out.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/8255.c b/drivers/staging/comedi/drivers/8255.c
index 2e181f01d39d..bdc3957bceb8 100644
--- a/drivers/staging/comedi/drivers/8255.c
+++ b/drivers/staging/comedi/drivers/8255.c
@@ -361,8 +361,10 @@ int subdev_8255_init_irq(struct comedi_device *dev, struct comedi_subdevice * s,
 void subdev_8255_cleanup(struct comedi_device *dev, struct comedi_subdevice * s)
 {
 	if (s-&gt;private) {
-		if (subdevpriv-&gt;have_irq) {
-		}
+		/* this test does nothing, so comment it out
+		 * if (subdevpriv-&gt;have_irq) {
+		 * }
+		 */
 
 		kfree(s-&gt;private);
 	}</pre>
    <div class="pagination">
        <a href='3_52.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><span>[53]</span><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_54.html'>Next&gt;&gt;</a>
    <div>
</body>
