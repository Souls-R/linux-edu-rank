<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_3.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><span>[4]</span><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b09b58e31b0f43d76f79b9943da3fb7c2843dcbb
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Thu Feb 1 20:47:13 2024 +0800

    octeontx2-pf: Fix a memleak otx2_sq_init
    
    When qmem_alloc and pfvf-&gt;hw_ops-&gt;sq_aq_init fails, sq-&gt;sg should be
    freed to prevent memleak.
    
    Fixes: c9c12d339d93 ("octeontx2-pf: Add support for PTP clock")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Acked-by: Jiri Pirko &lt;jiri@nvidia.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
index 7ca6941ea0b9..02d0b707aea5 100644
--- a/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
+++ b/drivers/net/ethernet/marvell/octeontx2/nic/otx2_common.c
@@ -951,8 +951,11 @@ int otx2_sq_init(struct otx2_nic *pfvf, u16 qidx, u16 sqb_aura)
 	if (pfvf-&gt;ptp &amp;&amp; qidx &lt; pfvf-&gt;hw.tx_queues) {
 		err = qmem_alloc(pfvf-&gt;dev, &amp;sq-&gt;timestamps, qset-&gt;sqe_cnt,
 				 sizeof(*sq-&gt;timestamps));
-		if (err)
+		if (err) {
+			kfree(sq-&gt;sg);
+			sq-&gt;sg = NULL;
 			return err;
+		}
 	}
 
 	sq-&gt;head = 0;
@@ -968,7 +971,14 @@ int otx2_sq_init(struct otx2_nic *pfvf, u16 qidx, u16 sqb_aura)
 	sq-&gt;stats.bytes = 0;
 	sq-&gt;stats.pkts = 0;
 
-	return pfvf-&gt;hw_ops-&gt;sq_aq_init(pfvf, qidx, sqb_aura);
+	err = pfvf-&gt;hw_ops-&gt;sq_aq_init(pfvf, qidx, sqb_aura);
+	if (err) {
+		kfree(sq-&gt;sg);
+		sq-&gt;sg = NULL;
+		return err;
+	}
+
+	return 0;
 
 }
 </pre><hr><pre>commit f3616173bf9be9bf39d131b120d6eea4e6324cb5
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Thu Feb 1 20:41:05 2024 +0800

    atm: idt77252: fix a memleak in open_card_ubr0
    
    When alloc_scq fails, card-&gt;vcs[0] (i.e. vc) should be freed. Otherwise,
    in the following call chain:
    
    idt77252_init_one
      |-&gt; idt77252_dev_open
            |-&gt; open_card_ubr0
                  |-&gt; alloc_scq [failed]
      |-&gt; deinit_card
            |-&gt; vfree(card-&gt;vcs);
    
    card-&gt;vcs is freed and card-&gt;vcs[0] is leaked.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Jiri Pirko &lt;jiri@nvidia.com&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/atm/idt77252.c b/drivers/atm/idt77252.c
index e327a0229dc1..e7f713cd70d3 100644
--- a/drivers/atm/idt77252.c
+++ b/drivers/atm/idt77252.c
@@ -2930,6 +2930,8 @@ open_card_ubr0(struct idt77252_dev *card)
 	vc-&gt;scq = alloc_scq(card, vc-&gt;class);
 	if (!vc-&gt;scq) {
 		printk("%s: can't get SCQ.\n", card-&gt;name);
+		kfree(card-&gt;vcs[0]);
+		card-&gt;vcs[0] = NULL;
 		return -ENOMEM;
 	}
 </pre><hr><pre>commit dc9ceb90c4b42c6e5c6757df1d6257110433788e
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Wed Jan 17 09:14:19 2024 +0100

    media: ir_toy: fix a memleak in irtoy_tx
    
    When irtoy_command fails, buf should be freed since it is allocated by
    irtoy_tx, or there is a memleak.
    
    Fixes: 4114978dcd24 ("media: ir_toy: prevent device from hanging during transmit")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Sean Young &lt;sean@mess.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;

diff --git a/drivers/media/rc/ir_toy.c b/drivers/media/rc/ir_toy.c
index 196806709259..69e630d85262 100644
--- a/drivers/media/rc/ir_toy.c
+++ b/drivers/media/rc/ir_toy.c
@@ -332,6 +332,7 @@ static int irtoy_tx(struct rc_dev *rc, uint *txbuf, uint count)
 			    sizeof(COMMAND_SMODE_EXIT), STATE_COMMAND_NO_RESP);
 	if (err) {
 		dev_err(irtoy-&gt;dev, "exit sample mode: %d\n", err);
+		kfree(buf);
 		return err;
 	}
 
@@ -339,6 +340,7 @@ static int irtoy_tx(struct rc_dev *rc, uint *txbuf, uint count)
 			    sizeof(COMMAND_SMODE_ENTER), STATE_COMMAND);
 	if (err) {
 		dev_err(irtoy-&gt;dev, "enter sample mode: %d\n", err);
+		kfree(buf);
 		return err;
 	}
 </pre><hr><pre>commit 5dee6d6923458e26966717f2a3eae7d09fc10bf6
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Mon Jan 29 17:10:17 2024 +0800

    net: ipv4: fix a memleak in ip_setup_cork
    
    When inetdev_valid_mtu fails, cork-&gt;opt should be freed if it is
    allocated in ip_setup_cork. Otherwise there could be a memleak.
    
    Fixes: 501a90c94510 ("inet: protect against too small mtu values.")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Eric Dumazet &lt;edumazet@google.com&gt;
    Link: https://lore.kernel.org/r/20240129091017.2938835-1-alexious@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index b06f678b03a1..41537d18eecf 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -1287,6 +1287,12 @@ static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,
 	if (unlikely(!rt))
 		return -EFAULT;
 
+	cork-&gt;fragsize = ip_sk_use_pmtu(sk) ?
+			 dst_mtu(&amp;rt-&gt;dst) : READ_ONCE(rt-&gt;dst.dev-&gt;mtu);
+
+	if (!inetdev_valid_mtu(cork-&gt;fragsize))
+		return -ENETUNREACH;
+
 	/*
 	 * setup for corking.
 	 */
@@ -1303,12 +1309,6 @@ static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,
 		cork-&gt;addr = ipc-&gt;addr;
 	}
 
-	cork-&gt;fragsize = ip_sk_use_pmtu(sk) ?
-			 dst_mtu(&amp;rt-&gt;dst) : READ_ONCE(rt-&gt;dst.dev-&gt;mtu);
-
-	if (!inetdev_valid_mtu(cork-&gt;fragsize))
-		return -ENETUNREACH;
-
 	cork-&gt;gso_size = ipc-&gt;gso_size;
 
 	cork-&gt;dst = &amp;rt-&gt;dst;</pre><hr><pre>commit 809aa64ebff51eb170ee31a95f83b2d21efa32e2
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Fri Jan 12 16:55:23 2024 +0800

    IB/hfi1: Fix a memleak in init_credit_return
    
    When dma_alloc_coherent fails to allocate dd-&gt;cr_base[i].va,
    init_credit_return should deallocate dd-&gt;cr_base and
    dd-&gt;cr_base[i] that allocated before. Or those resources
    would be never freed and a memleak is triggered.
    
    Fixes: 7724105686e7 ("IB/hfi1: add driver files")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20240112085523.3731720-1-alexious@zju.edu.cn
    Acked-by: Dennis Dalessandro &lt;dennis.dalessandro@cornelisnetworks.com&gt;
    Signed-off-by: Leon Romanovsky &lt;leon@kernel.org&gt;

diff --git a/drivers/infiniband/hw/hfi1/pio.c b/drivers/infiniband/hw/hfi1/pio.c
index 68c621ff59d0..5a91cbda4aee 100644
--- a/drivers/infiniband/hw/hfi1/pio.c
+++ b/drivers/infiniband/hw/hfi1/pio.c
@@ -2086,7 +2086,7 @@ int init_credit_return(struct hfi1_devdata *dd)
 				   "Unable to allocate credit return DMA range for NUMA %d\n",
 				   i);
 			ret = -ENOMEM;
-			goto done;
+			goto free_cr_base;
 		}
 	}
 	set_dev_node(&amp;dd-&gt;pcidev-&gt;dev, dd-&gt;node);
@@ -2094,6 +2094,10 @@ int init_credit_return(struct hfi1_devdata *dd)
 	ret = 0;
 done:
 	return ret;
+
+free_cr_base:
+	free_credit_return(dd);
+	goto done;
 }
 
 void free_credit_return(struct hfi1_devdata *dd)</pre><hr><pre>commit ebeae8adf89d9a82359f6659b1663d09beec2faa
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Sun Jan 21 15:35:06 2024 +0800

    ksmbd: fix global oob in ksmbd_nl_policy
    
    Similar to a reported issue (check the commit b33fb5b801c6 ("net:
    qualcomm: rmnet: fix global oob in rmnet_policy"), my local fuzzer finds
    another global out-of-bounds read for policy ksmbd_nl_policy. See bug
    trace below:
    
    ==================================================================
    BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:386 [inline]
    BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
    Read of size 1 at addr ffffffff8f24b100 by task syz-executor.1/62810
    
    CPU: 0 PID: 62810 Comm: syz-executor.1 Tainted: G                 N 6.1.0 #3
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014
    Call Trace:
     &lt;TASK&gt;
     __dump_stack lib/dump_stack.c:88 [inline]
     dump_stack_lvl+0x8b/0xb3 lib/dump_stack.c:106
     print_address_description mm/kasan/report.c:284 [inline]
     print_report+0x172/0x475 mm/kasan/report.c:395
     kasan_report+0xbb/0x1c0 mm/kasan/report.c:495
     validate_nla lib/nlattr.c:386 [inline]
     __nla_validate_parse+0x24af/0x2750 lib/nlattr.c:600
     __nla_parse+0x3e/0x50 lib/nlattr.c:697
     __nlmsg_parse include/net/netlink.h:748 [inline]
     genl_family_rcv_msg_attrs_parse.constprop.0+0x1b0/0x290 net/netlink/genetlink.c:565
     genl_family_rcv_msg_doit+0xda/0x330 net/netlink/genetlink.c:734
     genl_family_rcv_msg net/netlink/genetlink.c:833 [inline]
     genl_rcv_msg+0x441/0x780 net/netlink/genetlink.c:850
     netlink_rcv_skb+0x14f/0x410 net/netlink/af_netlink.c:2540
     genl_rcv+0x24/0x40 net/netlink/genetlink.c:861
     netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]
     netlink_unicast+0x54e/0x800 net/netlink/af_netlink.c:1345
     netlink_sendmsg+0x930/0xe50 net/netlink/af_netlink.c:1921
     sock_sendmsg_nosec net/socket.c:714 [inline]
     sock_sendmsg+0x154/0x190 net/socket.c:734
     ____sys_sendmsg+0x6df/0x840 net/socket.c:2482
     ___sys_sendmsg+0x110/0x1b0 net/socket.c:2536
     __sys_sendmsg+0xf3/0x1c0 net/socket.c:2565
     do_syscall_x64 arch/x86/entry/common.c:50 [inline]
     do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    RIP: 0033:0x7fdd66a8f359
    Code: 28 00 00 00 75 05 48 83 c4 28 c3 e8 f1 19 00 00 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff ff 73 01 c3 48 c7 c1 b8 ff ff ff f7 d8 64 89 01 48
    RSP: 002b:00007fdd65e00168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e
    RAX: ffffffffffffffda RBX: 00007fdd66bbcf80 RCX: 00007fdd66a8f359
    RDX: 0000000000000000 RSI: 0000000020000500 RDI: 0000000000000003
    RBP: 00007fdd66ada493 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000
    R13: 00007ffc84b81aff R14: 00007fdd65e00300 R15: 0000000000022000
     &lt;/TASK&gt;
    
    The buggy address belongs to the variable:
     ksmbd_nl_policy+0x100/0xa80
    
    The buggy address belongs to the physical page:
    page:0000000034f47940 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x1ccc4b
    flags: 0x200000000001000(reserved|node=0|zone=2)
    raw: 0200000000001000 ffffea00073312c8 ffffea00073312c8 0000000000000000
    raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000
    page dumped because: kasan: bad access detected
    
    Memory state around the buggy address:
     ffffffff8f24b000: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
     ffffffff8f24b080: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    &gt;ffffffff8f24b100: f9 f9 f9 f9 00 00 f9 f9 f9 f9 f9 f9 00 00 07 f9
                       ^
     ffffffff8f24b180: f9 f9 f9 f9 00 05 f9 f9 f9 f9 f9 f9 00 00 00 05
     ffffffff8f24b200: f9 f9 f9 f9 00 00 03 f9 f9 f9 f9 f9 00 00 04 f9
    ==================================================================
    
    To fix it, add a placeholder named __KSMBD_EVENT_MAX and let
    KSMBD_EVENT_MAX to be its original value - 1 according to what other
    netlink families do. Also change two sites that refer the
    KSMBD_EVENT_MAX to correct value.
    
    Cc: stable@vger.kernel.org
    Fixes: 0626e6641f6b ("cifsd: add server handler for central processing and tranport layers")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Acked-by: Namjae Jeon &lt;linkinjeon@kernel.org&gt;
    Signed-off-by: Steve French &lt;stfrench@microsoft.com&gt;

diff --git a/fs/smb/server/ksmbd_netlink.h b/fs/smb/server/ksmbd_netlink.h
index b7521e41402e..0ebf91ffa236 100644
--- a/fs/smb/server/ksmbd_netlink.h
+++ b/fs/smb/server/ksmbd_netlink.h
@@ -304,7 +304,8 @@ enum ksmbd_event {
 	KSMBD_EVENT_SPNEGO_AUTHEN_REQUEST,
 	KSMBD_EVENT_SPNEGO_AUTHEN_RESPONSE	= 15,
 
-	KSMBD_EVENT_MAX
+	__KSMBD_EVENT_MAX,
+	KSMBD_EVENT_MAX = __KSMBD_EVENT_MAX - 1
 };
 
 /*
diff --git a/fs/smb/server/transport_ipc.c b/fs/smb/server/transport_ipc.c
index b49d47bdafc9..f29bb03f0dc4 100644
--- a/fs/smb/server/transport_ipc.c
+++ b/fs/smb/server/transport_ipc.c
@@ -74,7 +74,7 @@ static int handle_unsupported_event(struct sk_buff *skb, struct genl_info *info)
 static int handle_generic_event(struct sk_buff *skb, struct genl_info *info);
 static int ksmbd_ipc_heartbeat_request(void);
 
-static const struct nla_policy ksmbd_nl_policy[KSMBD_EVENT_MAX] = {
+static const struct nla_policy ksmbd_nl_policy[KSMBD_EVENT_MAX + 1] = {
 	[KSMBD_EVENT_UNSPEC] = {
 		.len = 0,
 	},
@@ -403,7 +403,7 @@ static int handle_generic_event(struct sk_buff *skb, struct genl_info *info)
 		return -EPERM;
 #endif
 
-	if (type &gt;= KSMBD_EVENT_MAX) {
+	if (type &gt; KSMBD_EVENT_MAX) {
 		WARN_ON(1);
 		return -EINVAL;
 	}</pre><hr><pre>commit f6cc4b6a3ae53df425771000e9c9540cce9b7bb1
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Tue Jan 23 01:24:42 2024 +0800

    fjes: fix memleaks in fjes_hw_setup
    
    In fjes_hw_setup, it allocates several memory and delay the deallocation
    to the fjes_hw_exit in fjes_probe through the following call chain:
    
    fjes_probe
      |-&gt; fjes_hw_init
            |-&gt; fjes_hw_setup
      |-&gt; fjes_hw_exit
    
    However, when fjes_hw_setup fails, fjes_hw_exit won't be called and thus
    all the resources allocated in fjes_hw_setup will be leaked. In this
    patch, we free those resources in fjes_hw_setup and prevents such leaks.
    
    Fixes: 2fcbca687702 ("fjes: platform_driver's .probe and .remove routine")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Link: https://lore.kernel.org/r/20240122172445.3841883-1-alexious@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/drivers/net/fjes/fjes_hw.c b/drivers/net/fjes/fjes_hw.c
index 704e949484d0..b9b5554ea862 100644
--- a/drivers/net/fjes/fjes_hw.c
+++ b/drivers/net/fjes/fjes_hw.c
@@ -221,21 +221,25 @@ static int fjes_hw_setup(struct fjes_hw *hw)
 
 	mem_size = FJES_DEV_REQ_BUF_SIZE(hw-&gt;max_epid);
 	hw-&gt;hw_info.req_buf = kzalloc(mem_size, GFP_KERNEL);
-	if (!(hw-&gt;hw_info.req_buf))
-		return -ENOMEM;
+	if (!(hw-&gt;hw_info.req_buf)) {
+		result = -ENOMEM;
+		goto free_ep_info;
+	}
 
 	hw-&gt;hw_info.req_buf_size = mem_size;
 
 	mem_size = FJES_DEV_RES_BUF_SIZE(hw-&gt;max_epid);
 	hw-&gt;hw_info.res_buf = kzalloc(mem_size, GFP_KERNEL);
-	if (!(hw-&gt;hw_info.res_buf))
-		return -ENOMEM;
+	if (!(hw-&gt;hw_info.res_buf)) {
+		result = -ENOMEM;
+		goto free_req_buf;
+	}
 
 	hw-&gt;hw_info.res_buf_size = mem_size;
 
 	result = fjes_hw_alloc_shared_status_region(hw);
 	if (result)
-		return result;
+		goto free_res_buf;
 
 	hw-&gt;hw_info.buffer_share_bit = 0;
 	hw-&gt;hw_info.buffer_unshare_reserve_bit = 0;
@@ -246,11 +250,11 @@ static int fjes_hw_setup(struct fjes_hw *hw)
 
 			result = fjes_hw_alloc_epbuf(&amp;buf_pair-&gt;tx);
 			if (result)
-				return result;
+				goto free_epbuf;
 
 			result = fjes_hw_alloc_epbuf(&amp;buf_pair-&gt;rx);
 			if (result)
-				return result;
+				goto free_epbuf;
 
 			spin_lock_irqsave(&amp;hw-&gt;rx_status_lock, flags);
 			fjes_hw_setup_epbuf(&amp;buf_pair-&gt;tx, mac,
@@ -273,6 +277,25 @@ static int fjes_hw_setup(struct fjes_hw *hw)
 	fjes_hw_init_command_registers(hw, &amp;param);
 
 	return 0;
+
+free_epbuf:
+	for (epidx = 0; epidx &lt; hw-&gt;max_epid ; epidx++) {
+		if (epidx == hw-&gt;my_epid)
+			continue;
+		fjes_hw_free_epbuf(&amp;hw-&gt;ep_shm_info[epidx].tx);
+		fjes_hw_free_epbuf(&amp;hw-&gt;ep_shm_info[epidx].rx);
+	}
+	fjes_hw_free_shared_status_region(hw);
+free_res_buf:
+	kfree(hw-&gt;hw_info.res_buf);
+	hw-&gt;hw_info.res_buf = NULL;
+free_req_buf:
+	kfree(hw-&gt;hw_info.req_buf);
+	hw-&gt;hw_info.req_buf = NULL;
+free_ep_info:
+	kfree(hw-&gt;ep_shm_info);
+	hw-&gt;ep_shm_info = NULL;
+	return result;
 }
 
 static void fjes_hw_cleanup(struct fjes_hw *hw)</pre><hr><pre>commit aef855df7e1bbd5aa4484851561211500b22707e
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Tue Nov 28 17:29:01 2023 +0800

    net/mlx5e: fix a potential double-free in fs_any_create_groups
    
    When kcalloc() for ft-&gt;g succeeds but kvzalloc() for in fails,
    fs_any_create_groups() will free ft-&gt;g. However, its caller
    fs_any_create_table() will free ft-&gt;g again through calling
    mlx5e_destroy_flow_table(), which will lead to a double-free.
    Fix this by setting ft-&gt;g to NULL in fs_any_create_groups().
    
    Fixes: 0f575c20bf06 ("net/mlx5e: Introduce Flow Steering ANY API")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Reviewed-by: Tariq Toukan &lt;tariqt@nvidia.com&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Signed-off-by: Saeed Mahameed &lt;saeedm@nvidia.com&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
index e1283531e0b8..671adbad0a40 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs_tt_redirect.c
@@ -436,6 +436,7 @@ static int fs_any_create_groups(struct mlx5e_flow_table *ft)
 	in = kvzalloc(inlen, GFP_KERNEL);
 	if  (!in || !ft-&gt;g) {
 		kfree(ft-&gt;g);
+		ft-&gt;g = NULL;
 		kvfree(in);
 		return -ENOMEM;
 	}</pre><hr><pre>commit 3c6d5189246f590e4e1f167991558bdb72a4738b
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Wed Jan 17 15:17:36 2024 +0800

    net/mlx5e: fix a double-free in arfs_create_groups
    
    When `in` allocated by kvzalloc fails, arfs_create_groups will free
    ft-&gt;g and return an error. However, arfs_create_table, the only caller of
    arfs_create_groups, will hold this error and call to
    mlx5e_destroy_flow_table, in which the ft-&gt;g will be freed again.
    
    Fixes: 1cabe6b0965e ("net/mlx5e: Create aRFS flow tables")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Simon Horman &lt;horms@kernel.org&gt;
    Signed-off-by: Saeed Mahameed &lt;saeedm@nvidia.com&gt;

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index bb7f86c993e5..e66f486faafe 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@ -254,11 +254,13 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 
 	ft-&gt;g = kcalloc(MLX5E_ARFS_NUM_GROUPS,
 			sizeof(*ft-&gt;g), GFP_KERNEL);
-	in = kvzalloc(inlen, GFP_KERNEL);
-	if  (!in || !ft-&gt;g) {
-		kfree(ft-&gt;g);
-		kvfree(in);
+	if (!ft-&gt;g)
 		return -ENOMEM;
+
+	in = kvzalloc(inlen, GFP_KERNEL);
+	if (!in) {
+		err = -ENOMEM;
+		goto err_free_g;
 	}
 
 	mc = MLX5_ADDR_OF(create_flow_group_in, in, match_criteria);
@@ -278,7 +280,7 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 		break;
 	default:
 		err = -EINVAL;
-		goto out;
+		goto err_free_in;
 	}
 
 	switch (type) {
@@ -300,7 +302,7 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 		break;
 	default:
 		err = -EINVAL;
-		goto out;
+		goto err_free_in;
 	}
 
 	MLX5_SET_CFG(in, match_criteria_enable, MLX5_MATCH_OUTER_HEADERS);
@@ -309,7 +311,7 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft-&gt;g[ft-&gt;num_groups] = mlx5_create_flow_group(ft-&gt;t, in);
 	if (IS_ERR(ft-&gt;g[ft-&gt;num_groups]))
-		goto err;
+		goto err_clean_group;
 	ft-&gt;num_groups++;
 
 	memset(in, 0, inlen);
@@ -318,18 +320,20 @@ static int arfs_create_groups(struct mlx5e_flow_table *ft,
 	MLX5_SET_CFG(in, end_flow_index, ix - 1);
 	ft-&gt;g[ft-&gt;num_groups] = mlx5_create_flow_group(ft-&gt;t, in);
 	if (IS_ERR(ft-&gt;g[ft-&gt;num_groups]))
-		goto err;
+		goto err_clean_group;
 	ft-&gt;num_groups++;
 
 	kvfree(in);
 	return 0;
 
-err:
+err_clean_group:
 	err = PTR_ERR(ft-&gt;g[ft-&gt;num_groups]);
 	ft-&gt;g[ft-&gt;num_groups] = NULL;
-out:
+err_free_in:
 	kvfree(in);
-
+err_free_g:
+	kfree(ft-&gt;g);
+	ft-&gt;g = NULL;
 	return err;
 }
 </pre><hr><pre>commit 95a0d596bbd0552a78e13ced43f2be1038883c81
Author: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
Date:   Fri Dec 8 15:31:19 2023 +0800

    iio: core: fix memleak in iio_device_register_sysfs
    
    When iio_device_register_sysfs_group() fails, we should
    free iio_dev_opaque-&gt;chan_attr_group.attrs to prevent
    potential memleak.
    
    Fixes: 32f171724e5c ("iio: core: rework iio device group creation")
    Signed-off-by: Dinghao Liu &lt;dinghao.liu@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20231208073119.29283-1-dinghao.liu@zju.edu.cn
    Cc: &lt;Stable@vger.kernel.org&gt;
    Signed-off-by: Jonathan Cameron &lt;Jonathan.Cameron@huawei.com&gt;

diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c
index 9a85752124dd..173dc00762a1 100644
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@ -1584,10 +1584,13 @@ static int iio_device_register_sysfs(struct iio_dev *indio_dev)
 	ret = iio_device_register_sysfs_group(indio_dev,
 					      &amp;iio_dev_opaque-&gt;chan_attr_group);
 	if (ret)
-		goto error_clear_attrs;
+		goto error_free_chan_attrs;
 
 	return 0;
 
+error_free_chan_attrs:
+	kfree(iio_dev_opaque-&gt;chan_attr_group.attrs);
+	iio_dev_opaque-&gt;chan_attr_group.attrs = NULL;
 error_clear_attrs:
 	iio_free_chan_devattr_list(&amp;iio_dev_opaque-&gt;channel_attr_list);
 </pre>
    <div class="pagination">
        <a href='6_3.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><span>[4]</span><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_5.html'>Next&gt;&gt;</a>
    <div>
</body>
