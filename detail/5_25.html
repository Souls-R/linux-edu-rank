<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_24.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><span>[25]</span><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_26.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 06520edea0fc7007985fa4cd51560149feb3f442
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:15 2008 -0500

    [SCSI] iscsi_tcp: hook iscsi_tcp into iscsi_endpoint code
    
    iscsi_tcp creates its ep in userspace using sockets because
    it is virtual, so we just check if we are sent a ep and fail
    if we are.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index aa3c7f0c550d..92d031959002 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1838,17 +1838,17 @@ iscsi_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)
 }
 
 static struct iscsi_cls_session *
-iscsi_tcp_session_create(struct Scsi_Host *shost, uint16_t cmds_max,
+iscsi_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 			 uint16_t qdepth, uint32_t initial_cmdsn,
 			 uint32_t *hostno)
 {
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
+	struct Scsi_Host *shost;
 	int cmd_i;
 
-	if (shost) {
-		printk(KERN_ERR "iscsi_tcp: invalid shost %d.\n",
-		       shost-&gt;host_no);
+	if (ep) {
+		printk(KERN_ERR "iscsi_tcp: invalid ep %p.\n", ep);
 		return NULL;
 	}
 </pre><hr><pre>commit 412eeafa0a51a8d86545d0be637bf84e4374fccf
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:14 2008 -0500

    [SCSI] iser: Modify iser to take a iscsi_endpoint struct in ep callouts and session setup
    
    This hooks iser into the iscsi endpoint code. Previously it handled the
    lookup and allocation. This has been made generic so bnx2i and iser can
    share it. It also allows us to pass iser the leading conn's ep, so we
    know the ib_deivce being used and can set it as the scsi_host's parent.
    And that allows scsi-ml to set the dma_mask based on those values.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 3a89039e9a96..42e95b833092 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -262,24 +262,6 @@ iscsi_iser_cleanup_task(struct iscsi_conn *conn, struct iscsi_task *task)
 	}
 }
 
-static struct iser_conn *
-iscsi_iser_ib_conn_lookup(__u64 ep_handle)
-{
-	struct iser_conn *ib_conn;
-	struct iser_conn *uib_conn = (struct iser_conn *)(unsigned long)ep_handle;
-
-	mutex_lock(&amp;ig.connlist_mutex);
-	list_for_each_entry(ib_conn, &amp;ig.connlist, conn_list) {
-		if (ib_conn == uib_conn) {
-			mutex_unlock(&amp;ig.connlist_mutex);
-			return ib_conn;
-		}
-	}
-	mutex_unlock(&amp;ig.connlist_mutex);
-	iser_err("no conn exists for eph %llx\n",(unsigned long long)ep_handle);
-	return NULL;
-}
-
 static struct iscsi_cls_conn *
 iscsi_iser_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 {
@@ -335,6 +317,7 @@ iscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_iser_conn *iser_conn;
 	struct iser_conn *ib_conn;
+	struct iscsi_endpoint *ep;
 	int error;
 
 	error = iscsi_conn_bind(cls_session, cls_conn, is_leading);
@@ -343,12 +326,14 @@ iscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,
 
 	/* the transport ep handle comes from user space so it must be
 	 * verified against the global ib connections list */
-	ib_conn = iscsi_iser_ib_conn_lookup(transport_eph);
-	if (!ib_conn) {
+	ep = iscsi_lookup_endpoint(transport_eph);
+	if (!ep) {
 		iser_err("can't bind eph %llx\n",
 			 (unsigned long long)transport_eph);
 		return -EINVAL;
 	}
+	ib_conn = ep-&gt;dd_data;
+
 	/* binds the iSER connection retrieved from the previously
 	 * connected ep_handle to the iSCSI layer connection. exchanges
 	 * connection pointers */
@@ -401,21 +386,17 @@ static void iscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)
 }
 
 static struct iscsi_cls_session *
-iscsi_iser_session_create(struct Scsi_Host *shost,
+iscsi_iser_session_create(struct iscsi_endpoint *ep,
 			  uint16_t cmds_max, uint16_t qdepth,
 			  uint32_t initial_cmdsn, uint32_t *hostno)
 {
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
+	struct Scsi_Host *shost;
 	int i;
 	struct iscsi_task *task;
 	struct iscsi_iser_task *iser_task;
-
-	if (shost) {
-		printk(KERN_ERR "iscsi_tcp: invalid shost %d.\n",
-		       shost-&gt;host_no);
-		return NULL;
-	}
+	struct iser_conn *ib_conn;
 
 	shost = iscsi_host_alloc(&amp;iscsi_iser_sht, 0, ISCSI_MAX_CMD_PER_LUN);
 	if (!shost)
@@ -426,7 +407,15 @@ iscsi_iser_session_create(struct Scsi_Host *shost,
 	shost-&gt;max_channel = 0;
 	shost-&gt;max_cmd_len = 16;
 
-	if (iscsi_host_add(shost, NULL))
+	/*
+	 * older userspace tools (before 2.0-870) did not pass us
+	 * the leading conn's ep so this will be NULL;
+	 */
+	if (ep)
+		ib_conn = ep-&gt;dd_data;
+
+	if (iscsi_host_add(shost,
+			   ep ? ib_conn-&gt;device-&gt;ib_device-&gt;dma_device : NULL))
 		goto free_host;
 	*hostno = shost-&gt;host_no;
 
@@ -529,34 +518,37 @@ iscsi_iser_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *s
 	stats-&gt;custom[3].value = conn-&gt;fmr_unalign_cnt;
 }
 
-static int
-iscsi_iser_ep_connect(struct sockaddr *dst_addr, int non_blocking,
-		      __u64 *ep_handle)
+static struct iscsi_endpoint *
+iscsi_iser_ep_connect(struct sockaddr *dst_addr, int non_blocking)
 {
 	int err;
 	struct iser_conn *ib_conn;
+	struct iscsi_endpoint *ep;
 
-	err = iser_conn_init(&amp;ib_conn);
-	if (err)
-		goto out;
+	ep = iscsi_create_endpoint(sizeof(*ib_conn));
+	if (!ep)
+		return ERR_PTR(-ENOMEM);
 
-	err = iser_connect(ib_conn, NULL, (struct sockaddr_in *)dst_addr, non_blocking);
-	if (!err)
-		*ep_handle = (__u64)(unsigned long)ib_conn;
+	ib_conn = ep-&gt;dd_data;
+	ib_conn-&gt;ep = ep;
+	iser_conn_init(ib_conn);
 
-out:
-	return err;
+	err = iser_connect(ib_conn, NULL, (struct sockaddr_in *)dst_addr,
+			   non_blocking);
+	if (err) {
+		iscsi_destroy_endpoint(ep);
+		return ERR_PTR(err);
+	}
+	return ep;
 }
 
 static int
-iscsi_iser_ep_poll(__u64 ep_handle, int timeout_ms)
+iscsi_iser_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)
 {
-	struct iser_conn *ib_conn = iscsi_iser_ib_conn_lookup(ep_handle);
+	struct iser_conn *ib_conn;
 	int rc;
 
-	if (!ib_conn)
-		return -EINVAL;
-
+	ib_conn = ep-&gt;dd_data;
 	rc = wait_event_interruptible_timeout(ib_conn-&gt;wait,
 			     ib_conn-&gt;state == ISER_CONN_UP,
 			     msecs_to_jiffies(timeout_ms));
@@ -578,14 +570,11 @@ iscsi_iser_ep_poll(__u64 ep_handle, int timeout_ms)
 }
 
 static void
-iscsi_iser_ep_disconnect(__u64 ep_handle)
+iscsi_iser_ep_disconnect(struct iscsi_endpoint *ep)
 {
 	struct iser_conn *ib_conn;
 
-	ib_conn = iscsi_iser_ib_conn_lookup(ep_handle);
-	if (!ib_conn)
-		return;
-
+	ib_conn = ep-&gt;dd_data;
 	if (ib_conn-&gt;iser_conn)
 		/*
 		 * Must suspend xmit path if the ep is bound to the
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index 05431f270fe8..cdf48763b082 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -174,6 +174,7 @@ struct iser_data_buf {
 struct iser_device;
 struct iscsi_iser_conn;
 struct iscsi_iser_task;
+struct iscsi_endpoint;
 
 struct iser_mem_reg {
 	u32  lkey;
@@ -241,6 +242,7 @@ struct iser_device {
 
 struct iser_conn {
 	struct iscsi_iser_conn       *iser_conn; /* iser conn for upcalls  */
+	struct iscsi_endpoint	     *ep;
 	enum iser_ib_conn_state	     state;	    /* rdma connection state   */
 	atomic_t		     refcount;
 	spinlock_t		     lock;	    /* used for state changes  */
@@ -313,7 +315,7 @@ void iscsi_iser_recv(struct iscsi_conn *conn,
 		     char                   *rx_data,
 		     int                    rx_data_len);
 
-int  iser_conn_init(struct iser_conn **ib_conn);
+void iser_conn_init(struct iser_conn *ib_conn);
 
 void iser_conn_get(struct iser_conn *ib_conn);
 
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 5daed2bd710e..81b45d4d9aa9 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -325,7 +325,7 @@ static void iser_conn_release(struct iser_conn *ib_conn)
 		iser_device_try_release(device);
 	if (ib_conn-&gt;iser_conn)
 		ib_conn-&gt;iser_conn-&gt;ib_conn = NULL;
-	kfree(ib_conn);
+	iscsi_destroy_endpoint(ib_conn-&gt;ep);
 }
 
 void iser_conn_get(struct iser_conn *ib_conn)
@@ -494,15 +494,8 @@ static int iser_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *eve
 	return ret;
 }
 
-int iser_conn_init(struct iser_conn **ibconn)
+void iser_conn_init(struct iser_conn *ib_conn)
 {
-	struct iser_conn *ib_conn;
-
-	ib_conn = kzalloc(sizeof *ib_conn, GFP_KERNEL);
-	if (!ib_conn) {
-		iser_err("can't alloc memory for struct iser_conn\n");
-		return -ENOMEM;
-	}
 	ib_conn-&gt;state = ISER_CONN_INIT;
 	init_waitqueue_head(&amp;ib_conn-&gt;wait);
 	atomic_set(&amp;ib_conn-&gt;post_recv_buf_count, 0);
@@ -510,9 +503,6 @@ int iser_conn_init(struct iser_conn **ibconn)
 	atomic_set(&amp;ib_conn-&gt;refcount, 1);
 	INIT_LIST_HEAD(&amp;ib_conn-&gt;conn_list);
 	spin_lock_init(&amp;ib_conn-&gt;lock);
-
-	*ibconn = ib_conn;
-	return 0;
 }
 
  /**</pre><hr><pre>commit d82ff9be733a2e6da4f6c2ab4e9216f3f536503d
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:13 2008 -0500

    [SCSI] iscsi class: add endpoint class
    
    Add sysfs representation for the endpoint, so userspace can match the
    host and session to the endpoint. This will allow us to set the host's
    parent correctly at host creation time.
    
    The next patches will convert tcp and iser, and fix iser's dma_mask
    bug.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index ac9d298f54e7..c3c07ccccca7 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -33,6 +33,7 @@
 #define ISCSI_SESSION_ATTRS 19
 #define ISCSI_CONN_ATTRS 13
 #define ISCSI_HOST_ATTRS 4
+
 #define ISCSI_TRANSPORT_VERSION "2.0-869"
 
 struct iscsi_internal {
@@ -112,6 +113,123 @@ static struct attribute_group iscsi_transport_group = {
 	.attrs = iscsi_transport_attrs,
 };
 
+/*
+ * iSCSI endpoint attrs
+ */
+#define iscsi_dev_to_endpoint(_dev) \
+	container_of(_dev, struct iscsi_endpoint, dev)
+
+#define ISCSI_ATTR(_prefix,_name,_mode,_show,_store)	\
+struct device_attribute dev_attr_##_prefix##_##_name =	\
+        __ATTR(_name,_mode,_show,_store)
+
+static void iscsi_endpoint_release(struct device *dev)
+{
+	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
+	kfree(ep);
+}
+
+static struct class iscsi_endpoint_class = {
+	.name = "iscsi_endpoint",
+	.dev_release = iscsi_endpoint_release,
+};
+
+static ssize_t
+show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
+	return sprintf(buf, "%u\n", ep-&gt;id);
+}
+static ISCSI_ATTR(ep, handle, S_IRUGO, show_ep_handle, NULL);
+
+static struct attribute *iscsi_endpoint_attrs[] = {
+	&amp;dev_attr_ep_handle.attr,
+	NULL,
+};
+
+static struct attribute_group iscsi_endpoint_group = {
+	.attrs = iscsi_endpoint_attrs,
+};
+
+#define ISCSI_MAX_EPID -1
+
+static int iscsi_match_epid(struct device *dev, void *data)
+{
+	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
+	unsigned int *epid = (unsigned int *) data;
+
+	return *epid == ep-&gt;id;
+}
+
+struct iscsi_endpoint *
+iscsi_create_endpoint(int dd_size)
+{
+	struct device *dev;
+	struct iscsi_endpoint *ep;
+	unsigned int id;
+	int err;
+
+	for (id = 1; id &lt; ISCSI_MAX_EPID; id++) {
+		dev = class_find_device(&amp;iscsi_endpoint_class, &amp;id,
+					iscsi_match_epid);
+		if (!dev)
+			break;
+	}
+	if (id == ISCSI_MAX_EPID) {
+		printk(KERN_ERR "Too many connections. Max supported %u\n",
+		       ISCSI_MAX_EPID - 1);
+		return NULL;
+	}
+
+	ep = kzalloc(sizeof(*ep) + dd_size, GFP_KERNEL);
+	if (!ep)
+		return NULL;
+
+	ep-&gt;id = id;
+	ep-&gt;dev.class = &amp;iscsi_endpoint_class;
+	snprintf(ep-&gt;dev.bus_id, BUS_ID_SIZE, "ep-%u", id);
+	err = device_register(&amp;ep-&gt;dev);
+        if (err)
+                goto free_ep;
+
+	err = sysfs_create_group(&amp;ep-&gt;dev.kobj, &amp;iscsi_endpoint_group);
+	if (err)
+		goto unregister_dev;
+
+	if (dd_size)
+		ep-&gt;dd_data = &amp;ep[1];
+	return ep;
+
+unregister_dev:
+	device_unregister(&amp;ep-&gt;dev);
+	return NULL;
+
+free_ep:
+	kfree(ep);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(iscsi_create_endpoint);
+
+void iscsi_destroy_endpoint(struct iscsi_endpoint *ep)
+{
+	sysfs_remove_group(&amp;ep-&gt;dev.kobj, &amp;iscsi_endpoint_group);
+	device_unregister(&amp;ep-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(iscsi_destroy_endpoint);
+
+struct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle)
+{
+	struct device *dev;
+
+	dev = class_find_device(&amp;iscsi_endpoint_class, &amp;handle,
+				iscsi_match_epid);
+	if (!dev)
+		return NULL;
+
+	return iscsi_dev_to_endpoint(dev);
+}
+EXPORT_SYMBOL_GPL(iscsi_lookup_endpoint);
+
 static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
 			    struct device *cdev)
 {
@@ -1094,33 +1212,16 @@ int iscsi_session_event(struct iscsi_cls_session *session,
 EXPORT_SYMBOL_GPL(iscsi_session_event);
 
 static int
-iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_uevent *ev,
-			uint32_t host_no, uint32_t initial_cmdsn,
+iscsi_if_create_session(struct iscsi_internal *priv, struct iscsi_endpoint *ep,
+			struct iscsi_uevent *ev, uint32_t initial_cmdsn,
 			uint16_t cmds_max, uint16_t queue_depth)
 {
 	struct iscsi_transport *transport = priv-&gt;iscsi_transport;
 	struct iscsi_cls_session *session;
-	struct Scsi_Host *shost = NULL;
+	uint32_t host_no;
 
-	/*
-	 * Software iscsi allocates a host per session, but
-	 * offload drivers (and possibly iser one day) allocate a host per
-	 * hba/nic/rnic. Offload will match a host here, but software will
-	 * return a new hostno after the create_session callback has returned.
-	 */
-	if (host_no != UINT_MAX) {
-		shost = scsi_host_lookup(host_no);
-		if (IS_ERR(shost)) {
-			printk(KERN_ERR "Could not find host no %u to "
-			       "create session\n", host_no);
-			return -ENODEV;
-		}
-	}
-
-	session = transport-&gt;create_session(shost, cmds_max, queue_depth,
+	session = transport-&gt;create_session(ep, cmds_max, queue_depth,
 					    initial_cmdsn, &amp;host_no);
-	if (shost)
-		scsi_host_put(shost);
 	if (!session)
 		return -ENOMEM;
 
@@ -1199,6 +1300,7 @@ static int
 iscsi_if_transport_ep(struct iscsi_transport *transport,
 		      struct iscsi_uevent *ev, int msg_type)
 {
+	struct iscsi_endpoint *ep;
 	struct sockaddr *dst_addr;
 	int rc = 0;
 
@@ -1208,22 +1310,33 @@ iscsi_if_transport_ep(struct iscsi_transport *transport,
 			return -EINVAL;
 
 		dst_addr = (struct sockaddr *)((char*)ev + sizeof(*ev));
-		rc = transport-&gt;ep_connect(dst_addr,
-					   ev-&gt;u.ep_connect.non_blocking,
-					   &amp;ev-&gt;r.ep_connect_ret.handle);
+		ep = transport-&gt;ep_connect(dst_addr,
+					   ev-&gt;u.ep_connect.non_blocking);
+		if (IS_ERR(ep))
+			return PTR_ERR(ep);
+
+		ev-&gt;r.ep_connect_ret.handle = ep-&gt;id;
 		break;
 	case ISCSI_UEVENT_TRANSPORT_EP_POLL:
 		if (!transport-&gt;ep_poll)
 			return -EINVAL;
 
-		ev-&gt;r.retcode = transport-&gt;ep_poll(ev-&gt;u.ep_poll.ep_handle,
+		ep = iscsi_lookup_endpoint(ev-&gt;u.ep_poll.ep_handle);
+		if (!ep)
+			return -EINVAL;
+
+		ev-&gt;r.retcode = transport-&gt;ep_poll(ep,
 						   ev-&gt;u.ep_poll.timeout_ms);
 		break;
 	case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:
 		if (!transport-&gt;ep_disconnect)
 			return -EINVAL;
 
-		transport-&gt;ep_disconnect(ev-&gt;u.ep_disconnect.ep_handle);
+		ep = iscsi_lookup_endpoint(ev-&gt;u.ep_disconnect.ep_handle);
+		if (!ep)
+			return -EINVAL;
+
+		transport-&gt;ep_disconnect(ep);
 		break;
 	}
 	return rc;
@@ -1283,12 +1396,12 @@ static int
 iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
 	int err = 0;
-	uint32_t host_no = UINT_MAX;
 	struct iscsi_uevent *ev = NLMSG_DATA(nlh);
 	struct iscsi_transport *transport = NULL;
 	struct iscsi_internal *priv;
 	struct iscsi_cls_session *session;
 	struct iscsi_cls_conn *conn;
+	struct iscsi_endpoint *ep = NULL;
 
 	priv = iscsi_if_transport_lookup(iscsi_ptr(ev-&gt;transport_handle));
 	if (!priv)
@@ -1302,14 +1415,17 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 
 	switch (nlh-&gt;nlmsg_type) {
 	case ISCSI_UEVENT_CREATE_SESSION:
-		err = iscsi_if_create_session(priv, ev, host_no,
+		err = iscsi_if_create_session(priv, ep, ev,
 					      ev-&gt;u.c_session.initial_cmdsn,
 					      ev-&gt;u.c_session.cmds_max,
 					      ev-&gt;u.c_session.queue_depth);
 		break;
 	case ISCSI_UEVENT_CREATE_BOUND_SESSION:
-		err = iscsi_if_create_session(priv, ev,
-					ev-&gt;u.c_bound_session.host_no,
+		ep = iscsi_lookup_endpoint(ev-&gt;u.c_bound_session.ep_handle);
+		if (!ep)
+			return -EINVAL;
+
+		err = iscsi_if_create_session(priv, ep, ev,
 					ev-&gt;u.c_bound_session.initial_cmdsn,
 					ev-&gt;u.c_bound_session.cmds_max,
 					ev-&gt;u.c_bound_session.queue_depth);
@@ -1774,6 +1890,7 @@ iscsi_register_transport(struct iscsi_transport *tt)
 
 unregister_dev:
 	device_unregister(&amp;priv-&gt;dev);
+	return NULL;
 free_priv:
 	kfree(priv);
 	return NULL;
@@ -1821,10 +1938,14 @@ static __init int iscsi_transport_init(void)
 	if (err)
 		return err;
 
-	err = transport_class_register(&amp;iscsi_host_class);
+	err = class_register(&amp;iscsi_endpoint_class);
 	if (err)
 		goto unregister_transport_class;
 
+	err = transport_class_register(&amp;iscsi_host_class);
+	if (err)
+		goto unregister_endpoint_class;
+
 	err = transport_class_register(&amp;iscsi_connection_class);
 	if (err)
 		goto unregister_host_class;
@@ -1833,8 +1954,8 @@ static __init int iscsi_transport_init(void)
 	if (err)
 		goto unregister_conn_class;
 
-	nls = netlink_kernel_create(&amp;init_net, NETLINK_ISCSI, 1, iscsi_if_rx, NULL,
-			THIS_MODULE);
+	nls = netlink_kernel_create(&amp;init_net, NETLINK_ISCSI, 1, iscsi_if_rx,
+				    NULL, THIS_MODULE);
 	if (!nls) {
 		err = -ENOBUFS;
 		goto unregister_session_class;
@@ -1854,6 +1975,8 @@ static __init int iscsi_transport_init(void)
 	transport_class_unregister(&amp;iscsi_connection_class);
 unregister_host_class:
 	transport_class_unregister(&amp;iscsi_host_class);
+unregister_endpoint_class:
+	class_unregister(&amp;iscsi_endpoint_class);
 unregister_transport_class:
 	class_unregister(&amp;iscsi_transport_class);
 	return err;
@@ -1866,6 +1989,7 @@ static void __exit iscsi_transport_exit(void)
 	transport_class_unregister(&amp;iscsi_connection_class);
 	transport_class_unregister(&amp;iscsi_session_class);
 	transport_class_unregister(&amp;iscsi_host_class);
+	class_unregister(&amp;iscsi_endpoint_class);
 	class_unregister(&amp;iscsi_transport_class);
 }
 
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 801a677777cc..a0f13a280e71 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -80,7 +80,7 @@ struct iscsi_uevent {
 			uint16_t	queue_depth;
 		} c_session;
 		struct msg_create_bound_session {
-			uint32_t	host_no;
+			uint64_t	ep_handle;
 			uint32_t	initial_cmdsn;
 			uint16_t	cmds_max;
 			uint16_t	queue_depth;
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index d6b823195563..f5444e033cc9 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -30,6 +30,7 @@
 
 struct scsi_transport_template;
 struct iscsi_transport;
+struct iscsi_endpoint;
 struct Scsi_Host;
 struct iscsi_cls_conn;
 struct iscsi_conn;
@@ -85,7 +86,7 @@ struct iscsi_transport {
 	/* LLD sets this to indicate what values it can export to sysfs */
 	uint64_t param_mask;
 	uint64_t host_param_mask;
-	struct iscsi_cls_session *(*create_session) (struct Scsi_Host *shost,
+	struct iscsi_cls_session *(*create_session) (struct iscsi_endpoint *ep,
 					uint16_t cmds_max, uint16_t qdepth,
 					uint32_t sn, uint32_t *hn);
 	void (*destroy_session) (struct iscsi_cls_session *session);
@@ -117,10 +118,10 @@ struct iscsi_transport {
 	void (*cleanup_task) (struct iscsi_conn *conn,
 				  struct iscsi_task *task);
 	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
-	int (*ep_connect) (struct sockaddr *dst_addr, int non_blocking,
-			   uint64_t *ep_handle);
-	int (*ep_poll) (uint64_t ep_handle, int timeout_ms);
-	void (*ep_disconnect) (uint64_t ep_handle);
+	struct iscsi_endpoint *(*ep_connect) (struct sockaddr *dst_addr,
+					      int non_blocking);
+	int (*ep_poll) (struct iscsi_endpoint *ep, int timeout_ms);
+	void (*ep_disconnect) (struct iscsi_endpoint *ep);
 	int (*tgt_dscvr) (struct Scsi_Host *shost, enum iscsi_tgt_dscvr type,
 			  uint32_t enable, struct sockaddr *dst_addr);
 };
@@ -203,6 +204,11 @@ struct iscsi_cls_host {
 extern void iscsi_host_for_each_session(struct Scsi_Host *shost,
 				void (*fn)(struct iscsi_cls_session *));
 
+struct iscsi_endpoint {
+	void *dd_data;			/* LLD private data */
+	struct device dev;
+	unsigned int id;
+};
 
 /*
  * session and connection functions that can be used by HW iSCSI LLDs
@@ -233,5 +239,8 @@ extern int iscsi_destroy_conn(struct iscsi_cls_conn *conn);
 extern void iscsi_unblock_session(struct iscsi_cls_session *session);
 extern void iscsi_block_session(struct iscsi_cls_session *session);
 extern int iscsi_scan_finished(struct Scsi_Host *shost, unsigned long time);
+extern struct iscsi_endpoint *iscsi_create_endpoint(int dd_size);
+extern void iscsi_destroy_endpoint(struct iscsi_endpoint *ep);
+extern struct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle);
 
 #endif</pre><hr><pre>commit 7970634b81a6e3561954517bca42615542c4535b
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:12 2008 -0500

    [SCSI] iscsi class: user device_for_each_child instead of duplicating session list
    
    Currently we duplicate the list of sessions, because we were using the
    test for if a session was on the host list to indicate if the session
    was bound or unbound. We can instead use the target_id and fix up
    the class so that drivers like bnx2i do not have to manage the target id
    space.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 86d9c42f0d33..3a89039e9a96 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -437,7 +437,7 @@ iscsi_iser_session_create(struct Scsi_Host *shost,
 	cls_session = iscsi_session_setup(&amp;iscsi_iser_transport, shost,
 					  ISCSI_DEF_XMIT_CMDS_MAX,
 					  sizeof(struct iscsi_iser_task),
-					  initial_cmdsn);
+					  initial_cmdsn, 0);
 	if (!cls_session)
 		goto remove_host;
 	session = cls_session-&gt;dd_data;
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 33cd0ca7cc8d..aa3c7f0c550d 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1868,7 +1868,7 @@ iscsi_tcp_session_create(struct Scsi_Host *shost, uint16_t cmds_max,
 
 	cls_session = iscsi_session_setup(&amp;iscsi_tcp_transport, shost, cmds_max,
 					  sizeof(struct iscsi_tcp_task),
-					  initial_cmdsn);
+					  initial_cmdsn, 0);
 	if (!cls_session)
 		goto remove_host;
 	session = cls_session-&gt;dd_data;
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 92ee6d94aaf9..e88b726ab2e0 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1897,7 +1897,7 @@ EXPORT_SYMBOL_GPL(iscsi_host_free);
 struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 		    uint16_t scsi_cmds_max, int cmd_task_size,
-		    uint32_t initial_cmdsn)
+		    uint32_t initial_cmdsn, unsigned int id)
 {
 	struct iscsi_session *session;
 	struct iscsi_cls_session *cls_session;
@@ -1957,7 +1957,7 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 	if (!try_module_get(iscsit-&gt;owner))
 		goto module_get_fail;
 
-	if (iscsi_add_session(cls_session, 0))
+	if (iscsi_add_session(cls_session, id))
 		goto cls_session_fail;
 	return cls_session;
 
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 6b8516a0970b..ac9d298f54e7 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -119,9 +119,8 @@ static int iscsi_setup_host(struct transport_container *tc, struct device *dev,
 	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
 
 	memset(ihost, 0, sizeof(*ihost));
-	INIT_LIST_HEAD(&amp;ihost-&gt;sessions);
-	mutex_init(&amp;ihost-&gt;mutex);
 	atomic_set(&amp;ihost-&gt;nr_scans, 0);
+	mutex_init(&amp;ihost-&gt;mutex);
 
 	snprintf(ihost-&gt;scan_workq_name, KOBJ_NAME_LEN, "iscsi_scan_%d",
 		shost-&gt;host_no);
@@ -316,42 +315,76 @@ int iscsi_scan_finished(struct Scsi_Host *shost, unsigned long time)
 }
 EXPORT_SYMBOL_GPL(iscsi_scan_finished);
 
-static int iscsi_user_scan(struct Scsi_Host *shost, uint channel,
-			   uint id, uint lun)
+struct iscsi_scan_data {
+	unsigned int channel;
+	unsigned int id;
+	unsigned int lun;
+};
+
+static int iscsi_user_scan_session(struct device *dev, void *data)
 {
-	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
+	struct iscsi_scan_data *scan_data = data;
 	struct iscsi_cls_session *session;
+	struct Scsi_Host *shost;
+	struct iscsi_cls_host *ihost;
+	unsigned long flags;
+	unsigned int id;
+
+	if (!iscsi_is_session_dev(dev))
+		return 0;
+
+	session = iscsi_dev_to_session(dev);
+	shost = iscsi_session_to_shost(session);
+	ihost = shost-&gt;shost_data;
 
 	mutex_lock(&amp;ihost-&gt;mutex);
-	list_for_each_entry(session, &amp;ihost-&gt;sessions, host_list) {
-		if ((channel == SCAN_WILD_CARD || channel == 0) &amp;&amp;
-		    (id == SCAN_WILD_CARD || id == session-&gt;target_id))
-			scsi_scan_target(&amp;session-&gt;dev, 0,
-					 session-&gt;target_id, lun, 1);
+	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	if (session-&gt;state != ISCSI_SESSION_LOGGED_IN) {
+		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+		mutex_unlock(&amp;ihost-&gt;mutex);
+		return 0;
 	}
-	mutex_unlock(&amp;ihost-&gt;mutex);
+	id = session-&gt;target_id;
+	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 
+	if (id != ISCSI_MAX_TARGET) {
+		if ((scan_data-&gt;channel == SCAN_WILD_CARD ||
+		     scan_data-&gt;channel == 0) &amp;&amp;
+		    (scan_data-&gt;id == SCAN_WILD_CARD ||
+		     scan_data-&gt;id == id))
+			scsi_scan_target(&amp;session-&gt;dev, 0, id,
+					 scan_data-&gt;lun, 1);
+	}
+	mutex_unlock(&amp;ihost-&gt;mutex);
 	return 0;
 }
 
+static int iscsi_user_scan(struct Scsi_Host *shost, uint channel,
+			   uint id, uint lun)
+{
+	struct iscsi_scan_data scan_data;
+
+	scan_data.channel = channel;
+	scan_data.id = id;
+	scan_data.lun = lun;
+
+	return device_for_each_child(&amp;shost-&gt;shost_gendev, &amp;scan_data,
+				     iscsi_user_scan_session);
+}
+
 static void iscsi_scan_session(struct work_struct *work)
 {
 	struct iscsi_cls_session *session =
 			container_of(work, struct iscsi_cls_session, scan_work);
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
-	unsigned long flags;
+	struct iscsi_scan_data scan_data;
 
-	spin_lock_irqsave(&amp;session-&gt;lock, flags);
-	if (session-&gt;state != ISCSI_SESSION_LOGGED_IN) {
-		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
-		goto done;
-	}
-	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+	scan_data.channel = 0;
+	scan_data.id = SCAN_WILD_CARD;
+	scan_data.lun = SCAN_WILD_CARD;
 
-	scsi_scan_target(&amp;session-&gt;dev, 0, session-&gt;target_id,
-			 SCAN_WILD_CARD, 1);
-done:
+	iscsi_user_scan_session(&amp;session-&gt;dev, &amp;scan_data);
 	atomic_dec(&amp;ihost-&gt;nr_scans);
 }
 
@@ -460,14 +493,18 @@ static void __iscsi_unbind_session(struct work_struct *work)
 				     unbind_work);
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_cls_host *ihost = shost-&gt;shost_data;
+	unsigned long flags;
 
 	/* Prevent new scans and make sure scanning is not in progress */
 	mutex_lock(&amp;ihost-&gt;mutex);
-	if (list_empty(&amp;session-&gt;host_list)) {
+	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	if (session-&gt;target_id == ISCSI_MAX_TARGET) {
+		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 		mutex_unlock(&amp;ihost-&gt;mutex);
 		return;
 	}
-	list_del_init(&amp;session-&gt;host_list);
+	session-&gt;target_id = ISCSI_MAX_TARGET;
+	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	mutex_unlock(&amp;ihost-&gt;mutex);
 
 	scsi_remove_target(&amp;session-&gt;dev);
@@ -497,7 +534,6 @@ iscsi_alloc_session(struct Scsi_Host *shost, struct iscsi_transport *transport,
 	session-&gt;recovery_tmo = 120;
 	session-&gt;state = ISCSI_SESSION_FREE;
 	INIT_DELAYED_WORK(&amp;session-&gt;recovery_work, session_recovery_timedout);
-	INIT_LIST_HEAD(&amp;session-&gt;host_list);
 	INIT_LIST_HEAD(&amp;session-&gt;sess_list);
 	INIT_WORK(&amp;session-&gt;unblock_work, __iscsi_unblock_session);
 	INIT_WORK(&amp;session-&gt;block_work, __iscsi_block_session);
@@ -516,16 +552,51 @@ iscsi_alloc_session(struct Scsi_Host *shost, struct iscsi_transport *transport,
 }
 EXPORT_SYMBOL_GPL(iscsi_alloc_session);
 
+static int iscsi_get_next_target_id(struct device *dev, void *data)
+{
+	struct iscsi_cls_session *session;
+	unsigned long flags;
+	int err = 0;
+
+	if (!iscsi_is_session_dev(dev))
+		return 0;
+
+	session = iscsi_dev_to_session(dev);
+	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	if (*((unsigned int *) data) == session-&gt;target_id)
+		err = -EEXIST;
+	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+	return err;
+}
+
 int iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)
 {
 	struct Scsi_Host *shost = iscsi_session_to_shost(session);
 	struct iscsi_cls_host *ihost;
 	unsigned long flags;
+	unsigned int id = target_id;
 	int err;
 
 	ihost = shost-&gt;shost_data;
 	session-&gt;sid = atomic_add_return(1, &amp;iscsi_session_nr);
-	session-&gt;target_id = target_id;
+
+	if (id == ISCSI_MAX_TARGET) {
+		for (id = 0; id &lt; ISCSI_MAX_TARGET; id++) {
+			err = device_for_each_child(&amp;shost-&gt;shost_gendev, &amp;id,
+						    iscsi_get_next_target_id);
+			if (!err)
+				break;
+		}
+
+		if (id == ISCSI_MAX_TARGET) {
+			iscsi_cls_session_printk(KERN_ERR, session,
+						 "Too many iscsi targets. Max "
+						 "number of targets is %d.\n",
+						 ISCSI_MAX_TARGET - 1);
+			goto release_host;
+		}
+	}
+	session-&gt;target_id = id;
 
 	snprintf(session-&gt;dev.bus_id, BUS_ID_SIZE, "session%u",
 		 session-&gt;sid);
@@ -541,10 +612,6 @@ int iscsi_add_session(struct iscsi_cls_session *session, unsigned int target_id)
 	list_add(&amp;session-&gt;sess_list, &amp;sesslist);
 	spin_unlock_irqrestore(&amp;sesslock, flags);
 
-	mutex_lock(&amp;ihost-&gt;mutex);
-	list_add(&amp;session-&gt;host_list, &amp;ihost-&gt;sessions);
-	mutex_unlock(&amp;ihost-&gt;mutex);
-
 	iscsi_session_event(session, ISCSI_KEVENT_CREATE_SESSION);
 	return 0;
 
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 176353c117b6..13c92d7ba969 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -331,7 +331,7 @@ extern void iscsi_host_free(struct Scsi_Host *shost);
  */
 extern struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *, struct Scsi_Host *shost,
-		    uint16_t, int, uint32_t);
+		    uint16_t, int, uint32_t, unsigned int);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 0553240796e9..d6b823195563 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -161,9 +161,10 @@ enum {
 	ISCSI_SESSION_FREE,
 };
 
+#define ISCSI_MAX_TARGET -1
+
 struct iscsi_cls_session {
 	struct list_head sess_list;		/* item in session_list */
-	struct list_head host_list;
 	struct iscsi_transport *transport;
 	spinlock_t lock;
 	struct work_struct block_work;
@@ -175,7 +176,7 @@ struct iscsi_cls_session {
 	int recovery_tmo;
 	struct delayed_work recovery_work;
 
-	int target_id;
+	unsigned int target_id;
 
 	int state;
 	int sid;				/* session id */
@@ -193,7 +194,6 @@ struct iscsi_cls_session {
 	iscsi_dev_to_session(_stgt-&gt;dev.parent)
 
 struct iscsi_cls_host {
-	struct list_head sessions;
 	atomic_t nr_scans;
 	struct mutex mutex;
 	struct workqueue_struct *scan_workq;</pre><hr><pre>commit 2261ec3d686e35c1a6088ab7f00a1d02b528b994
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:11 2008 -0500

    [SCSI] iser: handle iscsi_cmd_task rename
    
    This handles the iscsi_cmd_task rename and renames
    the iser cmd task to iser task.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index baecca1ed42a..86d9c42f0d33 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -124,33 +124,33 @@ iscsi_iser_recv(struct iscsi_conn *conn,
 
 
 /**
- * iscsi_iser_task_init - Initialize ctask
- * @ctask: iscsi ctask
+ * iscsi_iser_task_init - Initialize task
+ * @task: iscsi task
  *
- * Initialize the ctask for the scsi command or mgmt command.
+ * Initialize the task for the scsi command or mgmt command.
  */
 static int
-iscsi_iser_task_init(struct iscsi_cmd_task *ctask)
+iscsi_iser_task_init(struct iscsi_task *task)
 {
-	struct iscsi_iser_conn *iser_conn  = ctask-&gt;conn-&gt;dd_data;
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iscsi_iser_conn *iser_conn  = task-&gt;conn-&gt;dd_data;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 
-	/* mgmt ctask */
-	if (!ctask-&gt;sc) {
-		iser_ctask-&gt;desc.data = ctask-&gt;data;
+	/* mgmt task */
+	if (!task-&gt;sc) {
+		iser_task-&gt;desc.data = task-&gt;data;
 		return 0;
 	}
 
-	iser_ctask-&gt;command_sent = 0;
-	iser_ctask-&gt;iser_conn    = iser_conn;
-	iser_ctask_rdma_init(iser_ctask);
+	iser_task-&gt;command_sent = 0;
+	iser_task-&gt;iser_conn    = iser_conn;
+	iser_task_rdma_init(iser_task);
 	return 0;
 }
 
 /**
- * iscsi_iser_mtask_xmit - xmit management(immediate) ctask
+ * iscsi_iser_mtask_xmit - xmit management(immediate) task
  * @conn: iscsi connection
- * @ctask: ctask management ctask
+ * @task: task management task
  *
  * Notes:
  *	The function can return -EAGAIN in which case caller must
@@ -159,19 +159,19 @@ iscsi_iser_task_init(struct iscsi_cmd_task *ctask)
  *
  **/
 static int
-iscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)
 {
 	int error = 0;
 
-	debug_scsi("ctask deq [cid %d itt 0x%x]\n", conn-&gt;id, ctask-&gt;itt);
+	debug_scsi("task deq [cid %d itt 0x%x]\n", conn-&gt;id, task-&gt;itt);
 
-	error = iser_send_control(conn, ctask);
+	error = iser_send_control(conn, task);
 
-	/* since iser xmits control with zero copy, ctasks can not be recycled
+	/* since iser xmits control with zero copy, tasks can not be recycled
 	 * right after sending them.
 	 * The recycling scheme is based on whether a response is expected
-	 * - if yes, the ctask is recycled at iscsi_complete_pdu
-	 * - if no,  the ctask is recycled at iser_snd_completion
+	 * - if yes, the task is recycled at iscsi_complete_pdu
+	 * - if no,  the task is recycled at iser_snd_completion
 	 */
 	if (error &amp;&amp; error != -ENOBUFS)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
@@ -181,27 +181,27 @@ iscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 
 static int
 iscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,
-				 struct iscsi_cmd_task *ctask)
+				 struct iscsi_task *task)
 {
 	struct iscsi_data  hdr;
 	int error = 0;
 
 	/* Send data-out PDUs while there's still unsolicited data to send */
-	while (ctask-&gt;unsol_count &gt; 0) {
-		iscsi_prep_unsolicit_data_pdu(ctask, &amp;hdr);
+	while (task-&gt;unsol_count &gt; 0) {
+		iscsi_prep_unsolicit_data_pdu(task, &amp;hdr);
 		debug_scsi("Sending data-out: itt 0x%x, data count %d\n",
-			   hdr.itt, ctask-&gt;data_count);
+			   hdr.itt, task-&gt;data_count);
 
 		/* the buffer description has been passed with the command */
 		/* Send the command */
-		error = iser_send_data_out(conn, ctask, &amp;hdr);
+		error = iser_send_data_out(conn, task, &amp;hdr);
 		if (error) {
-			ctask-&gt;unsol_datasn--;
+			task-&gt;unsol_datasn--;
 			goto iscsi_iser_task_xmit_unsol_data_exit;
 		}
-		ctask-&gt;unsol_count -= ctask-&gt;data_count;
+		task-&gt;unsol_count -= task-&gt;data_count;
 		debug_scsi("Need to send %d more as data-out PDUs\n",
-			   ctask-&gt;unsol_count);
+			   task-&gt;unsol_count);
 	}
 
 iscsi_iser_task_xmit_unsol_data_exit:
@@ -209,37 +209,37 @@ iscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,
 }
 
 static int
-iscsi_iser_task_xmit(struct iscsi_cmd_task *ctask)
+iscsi_iser_task_xmit(struct iscsi_task *task)
 {
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iscsi_conn *conn = task-&gt;conn;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 	int error = 0;
 
-	if (!ctask-&gt;sc)
-		return iscsi_iser_mtask_xmit(conn, ctask);
+	if (!task-&gt;sc)
+		return iscsi_iser_mtask_xmit(conn, task);
 
-	if (ctask-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
-		BUG_ON(scsi_bufflen(ctask-&gt;sc) == 0);
+	if (task-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
+		BUG_ON(scsi_bufflen(task-&gt;sc) == 0);
 
 		debug_scsi("cmd [itt %x total %d imm %d unsol_data %d\n",
-			   ctask-&gt;itt, scsi_bufflen(ctask-&gt;sc),
-			   ctask-&gt;imm_count, ctask-&gt;unsol_count);
+			   task-&gt;itt, scsi_bufflen(task-&gt;sc),
+			   task-&gt;imm_count, task-&gt;unsol_count);
 	}
 
-	debug_scsi("ctask deq [cid %d itt 0x%x]\n",
-		   conn-&gt;id, ctask-&gt;itt);
+	debug_scsi("task deq [cid %d itt 0x%x]\n",
+		   conn-&gt;id, task-&gt;itt);
 
 	/* Send the cmd PDU */
-	if (!iser_ctask-&gt;command_sent) {
-		error = iser_send_command(conn, ctask);
+	if (!iser_task-&gt;command_sent) {
+		error = iser_send_command(conn, task);
 		if (error)
 			goto iscsi_iser_task_xmit_exit;
-		iser_ctask-&gt;command_sent = 1;
+		iser_task-&gt;command_sent = 1;
 	}
 
 	/* Send unsolicited data-out PDU(s) if necessary */
-	if (ctask-&gt;unsol_count)
-		error = iscsi_iser_task_xmit_unsol_data(conn, ctask);
+	if (task-&gt;unsol_count)
+		error = iscsi_iser_task_xmit_unsol_data(conn, task);
 
  iscsi_iser_task_xmit_exit:
 	if (error &amp;&amp; error != -ENOBUFS)
@@ -248,17 +248,17 @@ iscsi_iser_task_xmit(struct iscsi_cmd_task *ctask)
 }
 
 static void
-iscsi_iser_cleanup_task(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_iser_cleanup_task(struct iscsi_conn *conn, struct iscsi_task *task)
 {
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 
 	/* mgmt tasks do not need special cleanup */
-	if (!ctask-&gt;sc)
+	if (!task-&gt;sc)
 		return;
 
-	if (iser_ctask-&gt;status == ISER_TASK_STATUS_STARTED) {
-		iser_ctask-&gt;status = ISER_TASK_STATUS_COMPLETED;
-		iser_ctask_rdma_finalize(iser_ctask);
+	if (iser_task-&gt;status == ISER_TASK_STATUS_STARTED) {
+		iser_task-&gt;status = ISER_TASK_STATUS_COMPLETED;
+		iser_task_rdma_finalize(iser_task);
 	}
 }
 
@@ -408,8 +408,8 @@ iscsi_iser_session_create(struct Scsi_Host *shost,
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
 	int i;
-	struct iscsi_cmd_task *ctask;
-	struct iscsi_iser_cmd_task *iser_ctask;
+	struct iscsi_task *task;
+	struct iscsi_iser_task *iser_task;
 
 	if (shost) {
 		printk(KERN_ERR "iscsi_tcp: invalid shost %d.\n",
@@ -436,7 +436,7 @@ iscsi_iser_session_create(struct Scsi_Host *shost,
 	 */
 	cls_session = iscsi_session_setup(&amp;iscsi_iser_transport, shost,
 					  ISCSI_DEF_XMIT_CMDS_MAX,
-					  sizeof(struct iscsi_iser_cmd_task),
+					  sizeof(struct iscsi_iser_task),
 					  initial_cmdsn);
 	if (!cls_session)
 		goto remove_host;
@@ -445,10 +445,10 @@ iscsi_iser_session_create(struct Scsi_Host *shost,
 	shost-&gt;can_queue = session-&gt;scsi_cmds_max;
 	/* libiscsi setup itts, data and pool so just set desc fields */
 	for (i = 0; i &lt; session-&gt;cmds_max; i++) {
-		ctask = session-&gt;cmds[i];
-		iser_ctask = ctask-&gt;dd_data;
-		ctask-&gt;hdr = (struct iscsi_cmd *)&amp;iser_ctask-&gt;desc.iscsi_header;
-		ctask-&gt;hdr_max = sizeof(iser_ctask-&gt;desc.iscsi_header);
+		task = session-&gt;cmds[i];
+		iser_task = task-&gt;dd_data;
+		task-&gt;hdr = (struct iscsi_cmd *)&amp;iser_task-&gt;desc.iscsi_header;
+		task-&gt;hdr_max = sizeof(iser_task-&gt;desc.iscsi_header);
 	}
 	return cls_session;
 
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index 96a600f127c8..05431f270fe8 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -173,7 +173,7 @@ struct iser_data_buf {
 /* fwd declarations */
 struct iser_device;
 struct iscsi_iser_conn;
-struct iscsi_iser_cmd_task;
+struct iscsi_iser_task;
 
 struct iser_mem_reg {
 	u32  lkey;
@@ -197,7 +197,7 @@ struct iser_regd_buf {
 #define MAX_REGD_BUF_VECTOR_LEN	2
 
 struct iser_dto {
-	struct iscsi_iser_cmd_task *ctask;
+	struct iscsi_iser_task *task;
 	struct iser_conn *ib_conn;
 	int                        notify_enable;
 
@@ -265,7 +265,7 @@ struct iscsi_iser_conn {
 	rwlock_t		     lock;
 };
 
-struct iscsi_iser_cmd_task {
+struct iscsi_iser_task {
 	struct iser_desc             desc;
 	struct iscsi_iser_conn	     *iser_conn;
 	enum iser_task_status 	     status;
@@ -299,13 +299,13 @@ extern int iser_debug_level;
 int iser_conn_set_full_featured_mode(struct iscsi_conn *conn);
 
 int iser_send_control(struct iscsi_conn *conn,
-		      struct iscsi_cmd_task *ctask);
+		      struct iscsi_task *task);
 
 int iser_send_command(struct iscsi_conn *conn,
-		      struct iscsi_cmd_task *ctask);
+		      struct iscsi_task *task);
 
 int iser_send_data_out(struct iscsi_conn *conn,
-		       struct iscsi_cmd_task *ctask,
+		       struct iscsi_task *task,
 		       struct iscsi_data *hdr);
 
 void iscsi_iser_recv(struct iscsi_conn *conn,
@@ -326,9 +326,9 @@ void iser_rcv_completion(struct iser_desc *desc,
 
 void iser_snd_completion(struct iser_desc *desc);
 
-void iser_ctask_rdma_init(struct iscsi_iser_cmd_task *ctask);
+void iser_task_rdma_init(struct iscsi_iser_task *task);
 
-void iser_ctask_rdma_finalize(struct iscsi_iser_cmd_task *ctask);
+void iser_task_rdma_finalize(struct iscsi_iser_task *task);
 
 void iser_dto_buffs_release(struct iser_dto *dto);
 
@@ -338,10 +338,10 @@ void iser_reg_single(struct iser_device      *device,
 		     struct iser_regd_buf    *regd_buf,
 		     enum dma_data_direction direction);
 
-void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_cmd_task *ctask,
+void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_task *task,
 				     enum iser_data_dir         cmd_dir);
 
-int  iser_reg_rdma_mem(struct iscsi_iser_cmd_task *ctask,
+int  iser_reg_rdma_mem(struct iscsi_iser_task *task,
 		       enum   iser_data_dir        cmd_dir);
 
 int  iser_connect(struct iser_conn   *ib_conn,
@@ -361,10 +361,10 @@ int  iser_post_send(struct iser_desc *tx_desc);
 int iser_conn_state_comp(struct iser_conn *ib_conn,
 			 enum iser_ib_conn_state comp);
 
-int iser_dma_map_task_data(struct iscsi_iser_cmd_task *iser_ctask,
+int iser_dma_map_task_data(struct iscsi_iser_task *iser_task,
 			    struct iser_data_buf       *data,
 			    enum   iser_data_dir       iser_dir,
 			    enum   dma_data_direction  dma_dir);
 
-void iser_dma_unmap_task_data(struct iscsi_iser_cmd_task *iser_ctask);
+void iser_dma_unmap_task_data(struct iscsi_iser_task *iser_task);
 #endif
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index 4ea78fbeee95..35af60a23c61 100644
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -66,46 +66,46 @@ static void iser_dto_add_regd_buff(struct iser_dto *dto,
 
 /* Register user buffer memory and initialize passive rdma
  *  dto descriptor. Total data size is stored in
- *  iser_ctask-&gt;data[ISER_DIR_IN].data_len
+ *  iser_task-&gt;data[ISER_DIR_IN].data_len
  */
-static int iser_prepare_read_cmd(struct iscsi_cmd_task *ctask,
+static int iser_prepare_read_cmd(struct iscsi_task *task,
 				 unsigned int edtl)
 
 {
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 	struct iser_regd_buf *regd_buf;
 	int err;
-	struct iser_hdr *hdr = &amp;iser_ctask-&gt;desc.iser_header;
-	struct iser_data_buf *buf_in = &amp;iser_ctask-&gt;data[ISER_DIR_IN];
+	struct iser_hdr *hdr = &amp;iser_task-&gt;desc.iser_header;
+	struct iser_data_buf *buf_in = &amp;iser_task-&gt;data[ISER_DIR_IN];
 
-	err = iser_dma_map_task_data(iser_ctask,
+	err = iser_dma_map_task_data(iser_task,
 				     buf_in,
 				     ISER_DIR_IN,
 				     DMA_FROM_DEVICE);
 	if (err)
 		return err;
 
-	if (edtl &gt; iser_ctask-&gt;data[ISER_DIR_IN].data_len) {
+	if (edtl &gt; iser_task-&gt;data[ISER_DIR_IN].data_len) {
 		iser_err("Total data length: %ld, less than EDTL: "
 			 "%d, in READ cmd BHS itt: %d, conn: 0x%p\n",
-			 iser_ctask-&gt;data[ISER_DIR_IN].data_len, edtl,
-			 ctask-&gt;itt, iser_ctask-&gt;iser_conn);
+			 iser_task-&gt;data[ISER_DIR_IN].data_len, edtl,
+			 task-&gt;itt, iser_task-&gt;iser_conn);
 		return -EINVAL;
 	}
 
-	err = iser_reg_rdma_mem(iser_ctask,ISER_DIR_IN);
+	err = iser_reg_rdma_mem(iser_task,ISER_DIR_IN);
 	if (err) {
 		iser_err("Failed to set up Data-IN RDMA\n");
 		return err;
 	}
-	regd_buf = &amp;iser_ctask-&gt;rdma_regd[ISER_DIR_IN];
+	regd_buf = &amp;iser_task-&gt;rdma_regd[ISER_DIR_IN];
 
 	hdr-&gt;flags    |= ISER_RSV;
 	hdr-&gt;read_stag = cpu_to_be32(regd_buf-&gt;reg.rkey);
 	hdr-&gt;read_va   = cpu_to_be64(regd_buf-&gt;reg.va);
 
 	iser_dbg("Cmd itt:%d READ tags RKEY:%#.4X VA:%#llX\n",
-		 ctask-&gt;itt, regd_buf-&gt;reg.rkey,
+		 task-&gt;itt, regd_buf-&gt;reg.rkey,
 		 (unsigned long long)regd_buf-&gt;reg.va);
 
 	return 0;
@@ -113,43 +113,43 @@ static int iser_prepare_read_cmd(struct iscsi_cmd_task *ctask,
 
 /* Register user buffer memory and initialize passive rdma
  *  dto descriptor. Total data size is stored in
- *  ctask-&gt;data[ISER_DIR_OUT].data_len
+ *  task-&gt;data[ISER_DIR_OUT].data_len
  */
 static int
-iser_prepare_write_cmd(struct iscsi_cmd_task *ctask,
+iser_prepare_write_cmd(struct iscsi_task *task,
 		       unsigned int imm_sz,
 		       unsigned int unsol_sz,
 		       unsigned int edtl)
 {
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 	struct iser_regd_buf *regd_buf;
 	int err;
-	struct iser_dto *send_dto = &amp;iser_ctask-&gt;desc.dto;
-	struct iser_hdr *hdr = &amp;iser_ctask-&gt;desc.iser_header;
-	struct iser_data_buf *buf_out = &amp;iser_ctask-&gt;data[ISER_DIR_OUT];
+	struct iser_dto *send_dto = &amp;iser_task-&gt;desc.dto;
+	struct iser_hdr *hdr = &amp;iser_task-&gt;desc.iser_header;
+	struct iser_data_buf *buf_out = &amp;iser_task-&gt;data[ISER_DIR_OUT];
 
-	err = iser_dma_map_task_data(iser_ctask,
+	err = iser_dma_map_task_data(iser_task,
 				     buf_out,
 				     ISER_DIR_OUT,
 				     DMA_TO_DEVICE);
 	if (err)
 		return err;
 
-	if (edtl &gt; iser_ctask-&gt;data[ISER_DIR_OUT].data_len) {
+	if (edtl &gt; iser_task-&gt;data[ISER_DIR_OUT].data_len) {
 		iser_err("Total data length: %ld, less than EDTL: %d, "
 			 "in WRITE cmd BHS itt: %d, conn: 0x%p\n",
-			 iser_ctask-&gt;data[ISER_DIR_OUT].data_len,
-			 edtl, ctask-&gt;itt, ctask-&gt;conn);
+			 iser_task-&gt;data[ISER_DIR_OUT].data_len,
+			 edtl, task-&gt;itt, task-&gt;conn);
 		return -EINVAL;
 	}
 
-	err = iser_reg_rdma_mem(iser_ctask,ISER_DIR_OUT);
+	err = iser_reg_rdma_mem(iser_task,ISER_DIR_OUT);
 	if (err != 0) {
 		iser_err("Failed to register write cmd RDMA mem\n");
 		return err;
 	}
 
-	regd_buf = &amp;iser_ctask-&gt;rdma_regd[ISER_DIR_OUT];
+	regd_buf = &amp;iser_task-&gt;rdma_regd[ISER_DIR_OUT];
 
 	if (unsol_sz &lt; edtl) {
 		hdr-&gt;flags     |= ISER_WSV;
@@ -158,13 +158,13 @@ iser_prepare_write_cmd(struct iscsi_cmd_task *ctask,
 
 		iser_dbg("Cmd itt:%d, WRITE tags, RKEY:%#.4X "
 			 "VA:%#llX + unsol:%d\n",
-			 ctask-&gt;itt, regd_buf-&gt;reg.rkey,
+			 task-&gt;itt, regd_buf-&gt;reg.rkey,
 			 (unsigned long long)regd_buf-&gt;reg.va, unsol_sz);
 	}
 
 	if (imm_sz &gt; 0) {
 		iser_dbg("Cmd itt:%d, WRITE, adding imm.data sz: %d\n",
-			 ctask-&gt;itt, imm_sz);
+			 task-&gt;itt, imm_sz);
 		iser_dto_add_regd_buff(send_dto,
 				       regd_buf,
 				       0,
@@ -300,13 +300,13 @@ int iser_conn_set_full_featured_mode(struct iscsi_conn *conn)
 }
 
 static int
-iser_check_xmit(struct iscsi_conn *conn, void *ctask)
+iser_check_xmit(struct iscsi_conn *conn, void *task)
 {
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
 
 	if (atomic_read(&amp;iser_conn-&gt;ib_conn-&gt;post_send_buf_count) ==
 	    ISER_QP_MAX_REQ_DTOS) {
-		iser_dbg("%ld can't xmit ctask %p\n",jiffies,ctask);
+		iser_dbg("%ld can't xmit task %p\n",jiffies,task);
 		return -ENOBUFS;
 	}
 	return 0;
@@ -317,37 +317,37 @@ iser_check_xmit(struct iscsi_conn *conn, void *ctask)
  * iser_send_command - send command PDU
  */
 int iser_send_command(struct iscsi_conn *conn,
-		      struct iscsi_cmd_task *ctask)
+		      struct iscsi_task *task)
 {
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 	struct iser_dto *send_dto = NULL;
 	unsigned long edtl;
 	int err = 0;
 	struct iser_data_buf *data_buf;
 
-	struct iscsi_cmd *hdr =  ctask-&gt;hdr;
-	struct scsi_cmnd *sc  =  ctask-&gt;sc;
+	struct iscsi_cmd *hdr =  task-&gt;hdr;
+	struct scsi_cmnd *sc  =  task-&gt;sc;
 
 	if (!iser_conn_state_comp(iser_conn-&gt;ib_conn, ISER_CONN_UP)) {
 		iser_err("Failed to send, conn: 0x%p is not up\n", iser_conn-&gt;ib_conn);
 		return -EPERM;
 	}
-	if (iser_check_xmit(conn, ctask))
+	if (iser_check_xmit(conn, task))
 		return -ENOBUFS;
 
 	edtl = ntohl(hdr-&gt;data_length);
 
 	/* build the tx desc regd header and add it to the tx desc dto */
-	iser_ctask-&gt;desc.type = ISCSI_TX_SCSI_COMMAND;
-	send_dto = &amp;iser_ctask-&gt;desc.dto;
-	send_dto-&gt;ctask = iser_ctask;
-	iser_create_send_desc(iser_conn, &amp;iser_ctask-&gt;desc);
+	iser_task-&gt;desc.type = ISCSI_TX_SCSI_COMMAND;
+	send_dto = &amp;iser_task-&gt;desc.dto;
+	send_dto-&gt;task = iser_task;
+	iser_create_send_desc(iser_conn, &amp;iser_task-&gt;desc);
 
 	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ)
-		data_buf = &amp;iser_ctask-&gt;data[ISER_DIR_IN];
+		data_buf = &amp;iser_task-&gt;data[ISER_DIR_IN];
 	else
-		data_buf = &amp;iser_ctask-&gt;data[ISER_DIR_OUT];
+		data_buf = &amp;iser_task-&gt;data[ISER_DIR_OUT];
 
 	if (scsi_sg_count(sc)) { /* using a scatter list */
 		data_buf-&gt;buf  = scsi_sglist(sc);
@@ -357,15 +357,15 @@ int iser_send_command(struct iscsi_conn *conn,
 	data_buf-&gt;data_len = scsi_bufflen(sc);
 
 	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_READ) {
-		err = iser_prepare_read_cmd(ctask, edtl);
+		err = iser_prepare_read_cmd(task, edtl);
 		if (err)
 			goto send_command_error;
 	}
 	if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE) {
-		err = iser_prepare_write_cmd(ctask,
-					     ctask-&gt;imm_count,
-				             ctask-&gt;imm_count +
-					     ctask-&gt;unsol_count,
+		err = iser_prepare_write_cmd(task,
+					     task-&gt;imm_count,
+				             task-&gt;imm_count +
+					     task-&gt;unsol_count,
 					     edtl);
 		if (err)
 			goto send_command_error;
@@ -380,15 +380,15 @@ int iser_send_command(struct iscsi_conn *conn,
 		goto send_command_error;
 	}
 
-	iser_ctask-&gt;status = ISER_TASK_STATUS_STARTED;
+	iser_task-&gt;status = ISER_TASK_STATUS_STARTED;
 
-	err = iser_post_send(&amp;iser_ctask-&gt;desc);
+	err = iser_post_send(&amp;iser_task-&gt;desc);
 	if (!err)
 		return 0;
 
 send_command_error:
 	iser_dto_buffs_release(send_dto);
-	iser_err("conn %p failed ctask-&gt;itt %d err %d\n",conn, ctask-&gt;itt, err);
+	iser_err("conn %p failed task-&gt;itt %d err %d\n",conn, task-&gt;itt, err);
 	return err;
 }
 
@@ -396,11 +396,11 @@ int iser_send_command(struct iscsi_conn *conn,
  * iser_send_data_out - send data out PDU
  */
 int iser_send_data_out(struct iscsi_conn *conn,
-		       struct iscsi_cmd_task *ctask,
+		       struct iscsi_task *task,
 		       struct iscsi_data *hdr)
 {
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
 	struct iser_desc *tx_desc = NULL;
 	struct iser_dto *send_dto = NULL;
 	unsigned long buf_offset;
@@ -413,7 +413,7 @@ int iser_send_data_out(struct iscsi_conn *conn,
 		return -EPERM;
 	}
 
-	if (iser_check_xmit(conn, ctask))
+	if (iser_check_xmit(conn, task))
 		return -ENOBUFS;
 
 	itt = (__force uint32_t)hdr-&gt;itt;
@@ -434,7 +434,7 @@ int iser_send_data_out(struct iscsi_conn *conn,
 
 	/* build the tx desc regd header and add it to the tx desc dto */
 	send_dto = &amp;tx_desc-&gt;dto;
-	send_dto-&gt;ctask = iser_ctask;
+	send_dto-&gt;task = iser_task;
 	iser_create_send_desc(iser_conn, tx_desc);
 
 	iser_reg_single(iser_conn-&gt;ib_conn-&gt;device,
@@ -442,15 +442,15 @@ int iser_send_data_out(struct iscsi_conn *conn,
 
 	/* all data was registered for RDMA, we can use the lkey */
 	iser_dto_add_regd_buff(send_dto,
-			       &amp;iser_ctask-&gt;rdma_regd[ISER_DIR_OUT],
+			       &amp;iser_task-&gt;rdma_regd[ISER_DIR_OUT],
 			       buf_offset,
 			       data_seg_len);
 
-	if (buf_offset + data_seg_len &gt; iser_ctask-&gt;data[ISER_DIR_OUT].data_len) {
+	if (buf_offset + data_seg_len &gt; iser_task-&gt;data[ISER_DIR_OUT].data_len) {
 		iser_err("Offset:%ld &amp; DSL:%ld in Data-Out "
 			 "inconsistent with total len:%ld, itt:%d\n",
 			 buf_offset, data_seg_len,
-			 iser_ctask-&gt;data[ISER_DIR_OUT].data_len, itt);
+			 iser_task-&gt;data[ISER_DIR_OUT].data_len, itt);
 		err = -EINVAL;
 		goto send_data_out_error;
 	}
@@ -470,11 +470,11 @@ int iser_send_data_out(struct iscsi_conn *conn,
 }
 
 int iser_send_control(struct iscsi_conn *conn,
-		      struct iscsi_cmd_task *ctask)
+		      struct iscsi_task *task)
 {
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
-	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
-	struct iser_desc *mdesc = &amp;iser_ctask-&gt;desc;
+	struct iscsi_iser_task *iser_task = task-&gt;dd_data;
+	struct iser_desc *mdesc = &amp;iser_task-&gt;desc;
 	struct iser_dto *send_dto = NULL;
 	unsigned long data_seg_len;
 	int err = 0;
@@ -486,27 +486,27 @@ int iser_send_control(struct iscsi_conn *conn,
 		return -EPERM;
 	}
 
-	if (iser_check_xmit(conn, ctask))
+	if (iser_check_xmit(conn, task))
 		return -ENOBUFS;
 
 	/* build the tx desc regd header and add it to the tx desc dto */
 	mdesc-&gt;type = ISCSI_TX_CONTROL;
 	send_dto = &amp;mdesc-&gt;dto;
-	send_dto-&gt;ctask = NULL;
+	send_dto-&gt;task = NULL;
 	iser_create_send_desc(iser_conn, mdesc);
 
 	device = iser_conn-&gt;ib_conn-&gt;device;
 
 	iser_reg_single(device, send_dto-&gt;regd[0], DMA_TO_DEVICE);
 
-	data_seg_len = ntoh24(ctask-&gt;hdr-&gt;dlength);
+	data_seg_len = ntoh24(task-&gt;hdr-&gt;dlength);
 
 	if (data_seg_len &gt; 0) {
 		regd_buf = &amp;mdesc-&gt;data_regd_buf;
 		memset(regd_buf, 0, sizeof(struct iser_regd_buf));
 		regd_buf-&gt;device = device;
-		regd_buf-&gt;virt_addr = ctask-&gt;data;
-		regd_buf-&gt;data_size = ctask-&gt;data_count;
+		regd_buf-&gt;virt_addr = task-&gt;data;
+		regd_buf-&gt;data_size = task-&gt;data_count;
 		iser_reg_single(device, regd_buf,
 				DMA_TO_DEVICE);
 		iser_dto_add_regd_buff(send_dto, regd_buf,
@@ -538,8 +538,8 @@ void iser_rcv_completion(struct iser_desc *rx_desc,
 {
 	struct iser_dto *dto = &amp;rx_desc-&gt;dto;
 	struct iscsi_iser_conn *conn = dto-&gt;ib_conn-&gt;iser_conn;
-	struct iscsi_cmd_task *ctask;
-	struct iscsi_iser_cmd_task *iser_ctask;
+	struct iscsi_task *task;
+	struct iscsi_iser_task *iser_task;
 	struct iscsi_hdr *hdr;
 	char   *rx_data = NULL;
 	int     rx_data_len = 0;
@@ -558,16 +558,16 @@ void iser_rcv_completion(struct iser_desc *rx_desc,
 	opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
 
 	if (opcode == ISCSI_OP_SCSI_CMD_RSP) {
-		ctask = iscsi_itt_to_ctask(conn-&gt;iscsi_conn, hdr-&gt;itt);
-		if (!ctask)
-			iser_err("itt can't be matched to ctask!!! "
+		task = iscsi_itt_to_ctask(conn-&gt;iscsi_conn, hdr-&gt;itt);
+		if (!task)
+			iser_err("itt can't be matched to task!!! "
 				 "conn %p opcode %d itt %d\n",
 				 conn-&gt;iscsi_conn, opcode, hdr-&gt;itt);
 		else {
-			iser_ctask = ctask-&gt;dd_data;
-			iser_dbg("itt %d ctask %p\n",hdr-&gt;itt, ctask);
-			iser_ctask-&gt;status = ISER_TASK_STATUS_COMPLETED;
-			iser_ctask_rdma_finalize(iser_ctask);
+			iser_task = task-&gt;dd_data;
+			iser_dbg("itt %d task %p\n",hdr-&gt;itt, task);
+			iser_task-&gt;status = ISER_TASK_STATUS_COMPLETED;
+			iser_task_rdma_finalize(iser_task);
 		}
 	}
 	iser_dto_buffs_release(dto);
@@ -578,7 +578,7 @@ void iser_rcv_completion(struct iser_desc *rx_desc,
 	kmem_cache_free(ig.desc_cache, rx_desc);
 
 	/* decrementing conn-&gt;post_recv_buf_count only --after-- freeing the   *
-	 * ctask eliminates the need to worry on ctasks which are completed in   *
+	 * task eliminates the need to worry on tasks which are completed in   *
 	 * parallel to the execution of iser_conn_term. So the code that waits *
 	 * for the posted rx bufs refcount to become zero handles everything   */
 	atomic_dec(&amp;conn-&gt;ib_conn-&gt;post_recv_buf_count);
@@ -590,7 +590,7 @@ void iser_snd_completion(struct iser_desc *tx_desc)
 	struct iser_conn       *ib_conn = dto-&gt;ib_conn;
 	struct iscsi_iser_conn *iser_conn = ib_conn-&gt;iser_conn;
 	struct iscsi_conn      *conn = iser_conn-&gt;iscsi_conn;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 	int resume_tx = 0;
 
 	iser_dbg("Initiator, Data sent dto=0x%p\n", dto);
@@ -613,31 +613,31 @@ void iser_snd_completion(struct iser_desc *tx_desc)
 
 	if (tx_desc-&gt;type == ISCSI_TX_CONTROL) {
 		/* this arithmetic is legal by libiscsi dd_data allocation */
-		ctask = (void *) ((long)(void *)tx_desc -
-				  sizeof(struct iscsi_cmd_task));
-		if (ctask-&gt;hdr-&gt;itt == RESERVED_ITT)
-			iscsi_put_ctask(ctask);
+		task = (void *) ((long)(void *)tx_desc -
+				  sizeof(struct iscsi_task));
+		if (task-&gt;hdr-&gt;itt == RESERVED_ITT)
+			iscsi_put_task(task);
 	}
 }
 
-void iser_ctask_rdma_init(struct iscsi_iser_cmd_task *iser_ctask)
+void iser_task_rdma_init(struct iscsi_iser_task *iser_task)
 
 {
-	iser_ctask-&gt;status = ISER_TASK_STATUS_INIT;
+	iser_task-&gt;status = ISER_TASK_STATUS_INIT;
 
-	iser_ctask-&gt;dir[ISER_DIR_IN] = 0;
-	iser_ctask-&gt;dir[ISER_DIR_OUT] = 0;
+	iser_task-&gt;dir[ISER_DIR_IN] = 0;
+	iser_task-&gt;dir[ISER_DIR_OUT] = 0;
 
-	iser_ctask-&gt;data[ISER_DIR_IN].data_len  = 0;
-	iser_ctask-&gt;data[ISER_DIR_OUT].data_len = 0;
+	iser_task-&gt;data[ISER_DIR_IN].data_len  = 0;
+	iser_task-&gt;data[ISER_DIR_OUT].data_len = 0;
 
-	memset(&amp;iser_ctask-&gt;rdma_regd[ISER_DIR_IN], 0,
+	memset(&amp;iser_task-&gt;rdma_regd[ISER_DIR_IN], 0,
 	       sizeof(struct iser_regd_buf));
-	memset(&amp;iser_ctask-&gt;rdma_regd[ISER_DIR_OUT], 0,
+	memset(&amp;iser_task-&gt;rdma_regd[ISER_DIR_OUT], 0,
 	       sizeof(struct iser_regd_buf));
 }
 
-void iser_ctask_rdma_finalize(struct iscsi_iser_cmd_task *iser_ctask)
+void iser_task_rdma_finalize(struct iscsi_iser_task *iser_task)
 {
 	int deferred;
 	int is_rdma_aligned = 1;
@@ -646,17 +646,17 @@ void iser_ctask_rdma_finalize(struct iscsi_iser_cmd_task *iser_ctask)
 	/* if we were reading, copy back to unaligned sglist,
 	 * anyway dma_unmap and free the copy
 	 */
-	if (iser_ctask-&gt;data_copy[ISER_DIR_IN].copy_buf != NULL) {
+	if (iser_task-&gt;data_copy[ISER_DIR_IN].copy_buf != NULL) {
 		is_rdma_aligned = 0;
-		iser_finalize_rdma_unaligned_sg(iser_ctask, ISER_DIR_IN);
+		iser_finalize_rdma_unaligned_sg(iser_task, ISER_DIR_IN);
 	}
-	if (iser_ctask-&gt;data_copy[ISER_DIR_OUT].copy_buf != NULL) {
+	if (iser_task-&gt;data_copy[ISER_DIR_OUT].copy_buf != NULL) {
 		is_rdma_aligned = 0;
-		iser_finalize_rdma_unaligned_sg(iser_ctask, ISER_DIR_OUT);
+		iser_finalize_rdma_unaligned_sg(iser_task, ISER_DIR_OUT);
 	}
 
-	if (iser_ctask-&gt;dir[ISER_DIR_IN]) {
-		regd = &amp;iser_ctask-&gt;rdma_regd[ISER_DIR_IN];
+	if (iser_task-&gt;dir[ISER_DIR_IN]) {
+		regd = &amp;iser_task-&gt;rdma_regd[ISER_DIR_IN];
 		deferred = iser_regd_buff_release(regd);
 		if (deferred) {
 			iser_err("%d references remain for BUF-IN rdma reg\n",
@@ -664,8 +664,8 @@ void iser_ctask_rdma_finalize(struct iscsi_iser_cmd_task *iser_ctask)
 		}
 	}
 
-	if (iser_ctask-&gt;dir[ISER_DIR_OUT]) {
-		regd = &amp;iser_ctask-&gt;rdma_regd[ISER_DIR_OUT];
+	if (iser_task-&gt;dir[ISER_DIR_OUT]) {
+		regd = &amp;iser_task-&gt;rdma_regd[ISER_DIR_OUT];
 		deferred = iser_regd_buff_release(regd);
 		if (deferred) {
 			iser_err("%d references remain for BUF-OUT rdma reg\n",
@@ -675,7 +675,7 @@ void iser_ctask_rdma_finalize(struct iscsi_iser_cmd_task *iser_ctask)
 
        /* if the data was unaligned, it was already unmapped and then copied */
        if (is_rdma_aligned)
-		iser_dma_unmap_task_data(iser_ctask);
+		iser_dma_unmap_task_data(iser_task);
 }
 
 void iser_dto_buffs_release(struct iser_dto *dto)
diff --git a/drivers/infiniband/ulp/iser/iser_memory.c b/drivers/infiniband/ulp/iser/iser_memory.c
index cac50c4dc159..48f2a601fc27 100644
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@ -101,13 +101,13 @@ void iser_reg_single(struct iser_device *device,
 /**
  * iser_start_rdma_unaligned_sg
  */
-static int iser_start_rdma_unaligned_sg(struct iscsi_iser_cmd_task *iser_ctask,
+static int iser_start_rdma_unaligned_sg(struct iscsi_iser_task *iser_task,
 					enum iser_data_dir cmd_dir)
 {
 	int dma_nents;
 	struct ib_device *dev;
 	char *mem = NULL;
-	struct iser_data_buf *data = &amp;iser_ctask-&gt;data[cmd_dir];
+	struct iser_data_buf *data = &amp;iser_task-&gt;data[cmd_dir];
 	unsigned long  cmd_data_len = data-&gt;data_len;
 
 	if (cmd_data_len &gt; ISER_KMALLOC_THRESHOLD)
@@ -140,37 +140,37 @@ static int iser_start_rdma_unaligned_sg(struct iscsi_iser_cmd_task *iser_ctask,
 		}
 	}
 
-	sg_init_one(&amp;iser_ctask-&gt;data_copy[cmd_dir].sg_single, mem, cmd_data_len);
-	iser_ctask-&gt;data_copy[cmd_dir].buf  =
-		&amp;iser_ctask-&gt;data_copy[cmd_dir].sg_single;
-	iser_ctask-&gt;data_copy[cmd_dir].size = 1;
+	sg_init_one(&amp;iser_task-&gt;data_copy[cmd_dir].sg_single, mem, cmd_data_len);
+	iser_task-&gt;data_copy[cmd_dir].buf  =
+		&amp;iser_task-&gt;data_copy[cmd_dir].sg_single;
+	iser_task-&gt;data_copy[cmd_dir].size = 1;
 
-	iser_ctask-&gt;data_copy[cmd_dir].copy_buf  = mem;
+	iser_task-&gt;data_copy[cmd_dir].copy_buf  = mem;
 
-	dev = iser_ctask-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
+	dev = iser_task-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
 	dma_nents = ib_dma_map_sg(dev,
-				  &amp;iser_ctask-&gt;data_copy[cmd_dir].sg_single,
+				  &amp;iser_task-&gt;data_copy[cmd_dir].sg_single,
 				  1,
 				  (cmd_dir == ISER_DIR_OUT) ?
 				  DMA_TO_DEVICE : DMA_FROM_DEVICE);
 	BUG_ON(dma_nents == 0);
 
-	iser_ctask-&gt;data_copy[cmd_dir].dma_nents = dma_nents;
+	iser_task-&gt;data_copy[cmd_dir].dma_nents = dma_nents;
 	return 0;
 }
 
 /**
  * iser_finalize_rdma_unaligned_sg
  */
-void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_cmd_task *iser_ctask,
+void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_task *iser_task,
 				     enum iser_data_dir         cmd_dir)
 {
 	struct ib_device *dev;
 	struct iser_data_buf *mem_copy;
 	unsigned long  cmd_data_len;
 
-	dev = iser_ctask-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
-	mem_copy = &amp;iser_ctask-&gt;data_copy[cmd_dir];
+	dev = iser_task-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
+	mem_copy = &amp;iser_task-&gt;data_copy[cmd_dir];
 
 	ib_dma_unmap_sg(dev, &amp;mem_copy-&gt;sg_single, 1,
 			(cmd_dir == ISER_DIR_OUT) ?
@@ -186,8 +186,8 @@ void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_cmd_task *iser_ctask,
 		/* copy back read RDMA to unaligned sg */
 		mem	= mem_copy-&gt;copy_buf;
 
-		sgl	= (struct scatterlist *)iser_ctask-&gt;data[ISER_DIR_IN].buf;
-		sg_size = iser_ctask-&gt;data[ISER_DIR_IN].size;
+		sgl	= (struct scatterlist *)iser_task-&gt;data[ISER_DIR_IN].buf;
+		sg_size = iser_task-&gt;data[ISER_DIR_IN].size;
 
 		p = mem;
 		for_each_sg(sgl, sg, sg_size, i) {
@@ -200,7 +200,7 @@ void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_cmd_task *iser_ctask,
 		}
 	}
 
-	cmd_data_len = iser_ctask-&gt;data[cmd_dir].data_len;
+	cmd_data_len = iser_task-&gt;data[cmd_dir].data_len;
 
 	if (cmd_data_len &gt; ISER_KMALLOC_THRESHOLD)
 		free_pages((unsigned long)mem_copy-&gt;copy_buf,
@@ -378,15 +378,15 @@ static void iser_page_vec_build(struct iser_data_buf *data,
 	}
 }
 
-int iser_dma_map_task_data(struct iscsi_iser_cmd_task *iser_ctask,
-			    struct iser_data_buf       *data,
-			    enum   iser_data_dir       iser_dir,
-			    enum   dma_data_direction  dma_dir)
+int iser_dma_map_task_data(struct iscsi_iser_task *iser_task,
+			    struct iser_data_buf *data,
+			    enum iser_data_dir iser_dir,
+			    enum dma_data_direction dma_dir)
 {
 	struct ib_device *dev;
 
-	iser_ctask-&gt;dir[iser_dir] = 1;
-	dev = iser_ctask-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
+	iser_task-&gt;dir[iser_dir] = 1;
+	dev = iser_task-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
 
 	data-&gt;dma_nents = ib_dma_map_sg(dev, data-&gt;buf, data-&gt;size, dma_dir);
 	if (data-&gt;dma_nents == 0) {
@@ -396,20 +396,20 @@ int iser_dma_map_task_data(struct iscsi_iser_cmd_task *iser_ctask,
 	return 0;
 }
 
-void iser_dma_unmap_task_data(struct iscsi_iser_cmd_task *iser_ctask)
+void iser_dma_unmap_task_data(struct iscsi_iser_task *iser_task)
 {
 	struct ib_device *dev;
 	struct iser_data_buf *data;
 
-	dev = iser_ctask-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
+	dev = iser_task-&gt;iser_conn-&gt;ib_conn-&gt;device-&gt;ib_device;
 
-	if (iser_ctask-&gt;dir[ISER_DIR_IN]) {
-		data = &amp;iser_ctask-&gt;data[ISER_DIR_IN];
+	if (iser_task-&gt;dir[ISER_DIR_IN]) {
+		data = &amp;iser_task-&gt;data[ISER_DIR_IN];
 		ib_dma_unmap_sg(dev, data-&gt;buf, data-&gt;size, DMA_FROM_DEVICE);
 	}
 
-	if (iser_ctask-&gt;dir[ISER_DIR_OUT]) {
-		data = &amp;iser_ctask-&gt;data[ISER_DIR_OUT];
+	if (iser_task-&gt;dir[ISER_DIR_OUT]) {
+		data = &amp;iser_task-&gt;data[ISER_DIR_OUT];
 		ib_dma_unmap_sg(dev, data-&gt;buf, data-&gt;size, DMA_TO_DEVICE);
 	}
 }
@@ -420,21 +420,21 @@ void iser_dma_unmap_task_data(struct iscsi_iser_cmd_task *iser_ctask)
  *
  * returns 0 on success, errno code on failure
  */
-int iser_reg_rdma_mem(struct iscsi_iser_cmd_task *iser_ctask,
+int iser_reg_rdma_mem(struct iscsi_iser_task *iser_task,
 		      enum   iser_data_dir        cmd_dir)
 {
-	struct iscsi_conn    *iscsi_conn = iser_ctask-&gt;iser_conn-&gt;iscsi_conn;
-	struct iser_conn     *ib_conn = iser_ctask-&gt;iser_conn-&gt;ib_conn;
+	struct iscsi_conn    *iscsi_conn = iser_task-&gt;iser_conn-&gt;iscsi_conn;
+	struct iser_conn     *ib_conn = iser_task-&gt;iser_conn-&gt;ib_conn;
 	struct iser_device   *device = ib_conn-&gt;device;
 	struct ib_device     *ibdev = device-&gt;ib_device;
-	struct iser_data_buf *mem = &amp;iser_ctask-&gt;data[cmd_dir];
+	struct iser_data_buf *mem = &amp;iser_task-&gt;data[cmd_dir];
 	struct iser_regd_buf *regd_buf;
 	int aligned_len;
 	int err;
 	int i;
 	struct scatterlist *sg;
 
-	regd_buf = &amp;iser_ctask-&gt;rdma_regd[cmd_dir];
+	regd_buf = &amp;iser_task-&gt;rdma_regd[cmd_dir];
 
 	aligned_len = iser_data_buf_aligned_len(mem, ibdev);
 	if (aligned_len != mem-&gt;dma_nents) {
@@ -444,13 +444,13 @@ int iser_reg_rdma_mem(struct iscsi_iser_cmd_task *iser_ctask,
 		iser_data_buf_dump(mem, ibdev);
 
 		/* unmap the command data before accessing it */
-		iser_dma_unmap_task_data(iser_ctask);
+		iser_dma_unmap_task_data(iser_task);
 
 		/* allocate copy buf, if we are writing, copy the */
 		/* unaligned scatterlist, dma map the copy        */
-		if (iser_start_rdma_unaligned_sg(iser_ctask, cmd_dir) != 0)
+		if (iser_start_rdma_unaligned_sg(iser_task, cmd_dir) != 0)
 				return -ENOMEM;
-		mem = &amp;iser_ctask-&gt;data_copy[cmd_dir];
+		mem = &amp;iser_task-&gt;data_copy[cmd_dir];
 	}
 
 	/* if there a single dma entry, FMR is not needed */
@@ -474,8 +474,9 @@ int iser_reg_rdma_mem(struct iscsi_iser_cmd_task *iser_ctask,
 		err = iser_reg_page_vec(ib_conn, ib_conn-&gt;page_vec, &amp;regd_buf-&gt;reg);
 		if (err) {
 			iser_data_buf_dump(mem, ibdev);
-			iser_err("mem-&gt;dma_nents = %d (dlength = 0x%x)\n", mem-&gt;dma_nents,
-				 ntoh24(iser_ctask-&gt;desc.iscsi_header.dlength));
+			iser_err("mem-&gt;dma_nents = %d (dlength = 0x%x)\n",
+				 mem-&gt;dma_nents,
+				 ntoh24(iser_task-&gt;desc.iscsi_header.dlength));
 			iser_err("page_vec: data_size = 0x%x, length = %d, offset = 0x%x\n",
 				 ib_conn-&gt;page_vec-&gt;data_size, ib_conn-&gt;page_vec-&gt;length,
 				 ib_conn-&gt;page_vec-&gt;offset);</pre><hr><pre>commit 135a8ad4e09309d36dcb8b5c7f55db0b6a15b2d6
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:10 2008 -0500

    [SCSI] iscsi_tcp: handle iscsi_cmd_task rename
    
    This converts iscsi_tcp to use the iscsi_task name.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 517bad160bea..33cd0ca7cc8d 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -498,43 +498,43 @@ iscsi_tcp_data_recv_prep(struct iscsi_tcp_conn *tcp_conn)
  * must be called with session lock
  */
 static void
-iscsi_tcp_cleanup_task(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_tcp_cleanup_task(struct iscsi_conn *conn, struct iscsi_task *task)
 {
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 	struct iscsi_r2t_info *r2t;
 
-	/* nothing to do for mgmt ctasks */
-	if (!ctask-&gt;sc)
+	/* nothing to do for mgmt tasks */
+	if (!task-&gt;sc)
 		return;
 
-	/* flush ctask's r2t queues */
-	while (__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*))) {
-		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
+	/* flush task's r2t queues */
+	while (__kfifo_get(tcp_task-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*))) {
+		__kfifo_put(tcp_task-&gt;r2tpool.queue, (void*)&amp;r2t,
 			    sizeof(void*));
-		debug_scsi("iscsi_tcp_cleanup_ctask pending r2t dropped\n");
+		debug_scsi("iscsi_tcp_cleanup_task pending r2t dropped\n");
 	}
 
-	r2t = tcp_ctask-&gt;r2t;
+	r2t = tcp_task-&gt;r2t;
 	if (r2t != NULL) {
-		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
+		__kfifo_put(tcp_task-&gt;r2tpool.queue, (void*)&amp;r2t,
 			    sizeof(void*));
-		tcp_ctask-&gt;r2t = NULL;
+		tcp_task-&gt;r2t = NULL;
 	}
 }
 
 /**
  * iscsi_data_rsp - SCSI Data-In Response processing
  * @conn: iscsi connection
- * @ctask: scsi command ctask
+ * @task: scsi command task
  **/
 static int
-iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_task *task)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 	struct iscsi_data_rsp *rhdr = (struct iscsi_data_rsp *)tcp_conn-&gt;in.hdr;
 	struct iscsi_session *session = conn-&gt;session;
-	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct scsi_cmnd *sc = task-&gt;sc;
 	int datasn = be32_to_cpu(rhdr-&gt;datasn);
 	unsigned total_in_length = scsi_in(sc)-&gt;length;
 
@@ -542,18 +542,18 @@ iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	if (tcp_conn-&gt;in.datalen == 0)
 		return 0;
 
-	if (tcp_ctask-&gt;exp_datasn != datasn) {
-		debug_tcp("%s: ctask-&gt;exp_datasn(%d) != rhdr-&gt;datasn(%d)\n",
-		          __FUNCTION__, tcp_ctask-&gt;exp_datasn, datasn);
+	if (tcp_task-&gt;exp_datasn != datasn) {
+		debug_tcp("%s: task-&gt;exp_datasn(%d) != rhdr-&gt;datasn(%d)\n",
+		          __FUNCTION__, tcp_task-&gt;exp_datasn, datasn);
 		return ISCSI_ERR_DATASN;
 	}
 
-	tcp_ctask-&gt;exp_datasn++;
+	tcp_task-&gt;exp_datasn++;
 
-	tcp_ctask-&gt;data_offset = be32_to_cpu(rhdr-&gt;offset);
-	if (tcp_ctask-&gt;data_offset + tcp_conn-&gt;in.datalen &gt; total_in_length) {
+	tcp_task-&gt;data_offset = be32_to_cpu(rhdr-&gt;offset);
+	if (tcp_task-&gt;data_offset + tcp_conn-&gt;in.datalen &gt; total_in_length) {
 		debug_tcp("%s: data_offset(%d) + data_len(%d) &gt; total_length_in(%d)\n",
-		          __FUNCTION__, tcp_ctask-&gt;data_offset,
+		          __FUNCTION__, tcp_task-&gt;data_offset,
 		          tcp_conn-&gt;in.datalen, total_in_length);
 		return ISCSI_ERR_DATA_OFFSET;
 	}
@@ -582,7 +582,7 @@ iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 /**
  * iscsi_solicit_data_init - initialize first Data-Out
  * @conn: iscsi connection
- * @ctask: scsi command ctask
+ * @task: scsi command task
  * @r2t: R2T info
  *
  * Notes:
@@ -592,7 +592,7 @@ iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
  *	This function is called with connection lock taken.
  **/
 static void
-iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_task *task,
 			struct iscsi_r2t_info *r2t)
 {
 	struct iscsi_data *hdr;
@@ -603,8 +603,8 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
 	r2t-&gt;solicit_datasn++;
 	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
+	memcpy(hdr-&gt;lun, task-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;itt = task-&gt;hdr-&gt;itt;
 	hdr-&gt;exp_statsn = r2t-&gt;exp_statsn;
 	hdr-&gt;offset = cpu_to_be32(r2t-&gt;data_offset);
 	if (r2t-&gt;data_length &gt; conn-&gt;max_xmit_dlength) {
@@ -624,14 +624,14 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 /**
  * iscsi_r2t_rsp - iSCSI R2T Response processing
  * @conn: iscsi connection
- * @ctask: scsi command ctask
+ * @task: scsi command task
  **/
 static int
-iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_task *task)
 {
 	struct iscsi_r2t_info *r2t;
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct iscsi_r2t_rsp *rhdr = (struct iscsi_r2t_rsp *)tcp_conn-&gt;in.hdr;
 	int r2tsn = be32_to_cpu(rhdr-&gt;r2tsn);
@@ -644,23 +644,23 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		return ISCSI_ERR_DATALEN;
 	}
 
-	if (tcp_ctask-&gt;exp_datasn != r2tsn){
-		debug_tcp("%s: ctask-&gt;exp_datasn(%d) != rhdr-&gt;r2tsn(%d)\n",
-		          __FUNCTION__, tcp_ctask-&gt;exp_datasn, r2tsn);
+	if (tcp_task-&gt;exp_datasn != r2tsn){
+		debug_tcp("%s: task-&gt;exp_datasn(%d) != rhdr-&gt;r2tsn(%d)\n",
+		          __FUNCTION__, tcp_task-&gt;exp_datasn, r2tsn);
 		return ISCSI_ERR_R2TSN;
 	}
 
-	/* fill-in new R2T associated with the ctask */
+	/* fill-in new R2T associated with the task */
 	iscsi_update_cmdsn(session, (struct iscsi_nopin*)rhdr);
 
-	if (!ctask-&gt;sc || session-&gt;state != ISCSI_STATE_LOGGED_IN) {
+	if (!task-&gt;sc || session-&gt;state != ISCSI_STATE_LOGGED_IN) {
 		iscsi_conn_printk(KERN_INFO, conn,
 				  "dropping R2T itt %d in recovery.\n",
-				  ctask-&gt;itt);
+				  task-&gt;itt);
 		return 0;
 	}
 
-	rc = __kfifo_get(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
+	rc = __kfifo_get(tcp_task-&gt;r2tpool.queue, (void*)&amp;r2t, sizeof(void*));
 	BUG_ON(!rc);
 
 	r2t-&gt;exp_statsn = rhdr-&gt;statsn;
@@ -668,7 +668,7 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	if (r2t-&gt;data_length == 0) {
 		iscsi_conn_printk(KERN_ERR, conn,
 				  "invalid R2T with zero data len\n");
-		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
+		__kfifo_put(tcp_task-&gt;r2tpool.queue, (void*)&amp;r2t,
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
 	}
@@ -679,12 +679,12 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 			    r2t-&gt;data_length, session-&gt;max_burst);
 
 	r2t-&gt;data_offset = be32_to_cpu(rhdr-&gt;data_offset);
-	if (r2t-&gt;data_offset + r2t-&gt;data_length &gt; scsi_out(ctask-&gt;sc)-&gt;length) {
+	if (r2t-&gt;data_offset + r2t-&gt;data_length &gt; scsi_out(task-&gt;sc)-&gt;length) {
 		iscsi_conn_printk(KERN_ERR, conn,
 				  "invalid R2T with data len %u at offset %u "
 				  "and total length %d\n", r2t-&gt;data_length,
-				  r2t-&gt;data_offset, scsi_out(ctask-&gt;sc)-&gt;length);
-		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
+				  r2t-&gt;data_offset, scsi_out(task-&gt;sc)-&gt;length);
+		__kfifo_put(tcp_task-&gt;r2tpool.queue, (void*)&amp;r2t,
 			    sizeof(void*));
 		return ISCSI_ERR_DATALEN;
 	}
@@ -692,13 +692,13 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	r2t-&gt;ttt = rhdr-&gt;ttt; /* no flip */
 	r2t-&gt;solicit_datasn = 0;
 
-	iscsi_solicit_data_init(conn, ctask, r2t);
+	iscsi_solicit_data_init(conn, task, r2t);
 
-	tcp_ctask-&gt;exp_datasn = r2tsn + 1;
-	__kfifo_put(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*));
+	tcp_task-&gt;exp_datasn = r2tsn + 1;
+	__kfifo_put(tcp_task-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*));
 	conn-&gt;r2t_pdus_cnt++;
 
-	iscsi_requeue_ctask(ctask);
+	iscsi_requeue_task(task);
 	return 0;
 }
 
@@ -743,7 +743,7 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 	int rc = 0, opcode, ahslen;
 	struct iscsi_session *session = conn-&gt;session;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 
 	/* verify PDU length */
 	tcp_conn-&gt;in.datalen = ntoh24(hdr-&gt;dlength);
@@ -770,21 +770,21 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 
 	switch(opcode) {
 	case ISCSI_OP_SCSI_DATA_IN:
-		ctask = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
-		if (!ctask)
+		task = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
+		if (!task)
 			return ISCSI_ERR_BAD_ITT;
-		if (!ctask-&gt;sc)
+		if (!task-&gt;sc)
 			return ISCSI_ERR_NO_SCSI_CMD;
 
 		spin_lock(&amp;conn-&gt;session-&gt;lock);
-		rc = iscsi_data_rsp(conn, ctask);
+		rc = iscsi_data_rsp(conn, task);
 		spin_unlock(&amp;conn-&gt;session-&gt;lock);
 		if (rc)
 			return rc;
 		if (tcp_conn-&gt;in.datalen) {
-			struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+			struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 			struct hash_desc *rx_hash = NULL;
-			struct scsi_data_buffer *sdb = scsi_in(ctask-&gt;sc);
+			struct scsi_data_buffer *sdb = scsi_in(task-&gt;sc);
 
 			/*
 			 * Setup copy of Data-In into the Scsi_Cmnd
@@ -799,12 +799,12 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 
 			debug_tcp("iscsi_tcp_begin_data_in(%p, offset=%d, "
 				  "datalen=%d)\n", tcp_conn,
-				  tcp_ctask-&gt;data_offset,
+				  tcp_task-&gt;data_offset,
 				  tcp_conn-&gt;in.datalen);
 			return iscsi_segment_seek_sg(&amp;tcp_conn-&gt;in.segment,
 						     sdb-&gt;table.sgl,
 						     sdb-&gt;table.nents,
-						     tcp_ctask-&gt;data_offset,
+						     tcp_task-&gt;data_offset,
 						     tcp_conn-&gt;in.datalen,
 						     iscsi_tcp_process_data_in,
 						     rx_hash);
@@ -818,17 +818,17 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 		rc = iscsi_complete_pdu(conn, hdr, NULL, 0);
 		break;
 	case ISCSI_OP_R2T:
-		ctask = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
-		if (!ctask)
+		task = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
+		if (!task)
 			return ISCSI_ERR_BAD_ITT;
-		if (!ctask-&gt;sc)
+		if (!task-&gt;sc)
 			return ISCSI_ERR_NO_SCSI_CMD;
 
 		if (ahslen)
 			rc = ISCSI_ERR_AHSLEN;
-		else if (ctask-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
+		else if (task-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
 			spin_lock(&amp;session-&gt;lock);
-			rc = iscsi_r2t_rsp(conn, ctask);
+			rc = iscsi_r2t_rsp(conn, task);
 			spin_unlock(&amp;session-&gt;lock);
 		} else
 			rc = ISCSI_ERR_PROTO;
@@ -1202,7 +1202,7 @@ iscsi_tcp_send_hdr_prep(struct iscsi_conn *conn, void *hdr, size_t hdrlen)
 
 	/* If header digest is enabled, compute the CRC and
 	 * place the digest into the same buffer. We make
-	 * sure that both iscsi_tcp_cmd_task and mctask have
+	 * sure that both iscsi_tcp_task and mtask have
 	 * sufficient room.
 	 */
 	if (conn-&gt;hdrdgst_en) {
@@ -1277,7 +1277,7 @@ iscsi_tcp_send_linear_data_prepare(struct iscsi_conn *conn, void *data,
 /**
  * iscsi_solicit_data_cont - initialize next Data-Out
  * @conn: iscsi connection
- * @ctask: scsi command ctask
+ * @task: scsi command task
  * @r2t: R2T info
  * @left: bytes left to transfer
  *
@@ -1288,7 +1288,7 @@ iscsi_tcp_send_linear_data_prepare(struct iscsi_conn *conn, void *data,
  *	Called under connection lock.
  **/
 static int
-iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_task *task,
 			struct iscsi_r2t_info *r2t)
 {
 	struct iscsi_data *hdr;
@@ -1305,8 +1305,8 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 	hdr-&gt;datasn = cpu_to_be32(r2t-&gt;solicit_datasn);
 	r2t-&gt;solicit_datasn++;
 	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
+	memcpy(hdr-&gt;lun, task-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;itt = task-&gt;hdr-&gt;itt;
 	hdr-&gt;exp_statsn = r2t-&gt;exp_statsn;
 	new_offset = r2t-&gt;data_offset + r2t-&gt;sent;
 	hdr-&gt;offset = cpu_to_be32(new_offset);
@@ -1326,73 +1326,73 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 /**
  * iscsi_tcp_task - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
  * @conn: iscsi connection
- * @ctask: scsi command ctask
+ * @task: scsi command task
  * @sc: scsi command
  **/
 static int
-iscsi_tcp_task_init(struct iscsi_cmd_task *ctask)
+iscsi_tcp_task_init(struct iscsi_task *task)
 {
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
+	struct iscsi_conn *conn = task-&gt;conn;
+	struct scsi_cmnd *sc = task-&gt;sc;
 	int err;
 
 	if (!sc) {
 		/*
-		 * mgmt ctasks do not have a scatterlist since they come
+		 * mgmt tasks do not have a scatterlist since they come
 		 * in from the iscsi interface.
 		 */
-		debug_scsi("mctask deq [cid %d itt 0x%x]\n", conn-&gt;id,
-			   ctask-&gt;itt);
+		debug_scsi("mtask deq [cid %d itt 0x%x]\n", conn-&gt;id,
+			   task-&gt;itt);
 
 		/* Prepare PDU, optionally w/ immediate data */
-		iscsi_tcp_send_hdr_prep(conn, ctask-&gt;hdr, sizeof(*ctask-&gt;hdr));
+		iscsi_tcp_send_hdr_prep(conn, task-&gt;hdr, sizeof(*task-&gt;hdr));
 
 		/* If we have immediate data, attach a payload */
-		if (ctask-&gt;data_count)
-			iscsi_tcp_send_linear_data_prepare(conn, ctask-&gt;data,
-							   ctask-&gt;data_count);
+		if (task-&gt;data_count)
+			iscsi_tcp_send_linear_data_prepare(conn, task-&gt;data,
+							   task-&gt;data_count);
 		return 0;
 	}
 
-	BUG_ON(__kfifo_len(tcp_ctask-&gt;r2tqueue));
-	tcp_ctask-&gt;sent = 0;
-	tcp_ctask-&gt;exp_datasn = 0;
+	BUG_ON(__kfifo_len(tcp_task-&gt;r2tqueue));
+	tcp_task-&gt;sent = 0;
+	tcp_task-&gt;exp_datasn = 0;
 
 	/* Prepare PDU, optionally w/ immediate data */
-	debug_scsi("ctask deq [cid %d itt 0x%x imm %d unsol %d]\n",
-		    conn-&gt;id, ctask-&gt;itt, ctask-&gt;imm_count,
-		    ctask-&gt;unsol_count);
-	iscsi_tcp_send_hdr_prep(conn, ctask-&gt;hdr, ctask-&gt;hdr_len);
+	debug_scsi("task deq [cid %d itt 0x%x imm %d unsol %d]\n",
+		    conn-&gt;id, task-&gt;itt, task-&gt;imm_count,
+		    task-&gt;unsol_count);
+	iscsi_tcp_send_hdr_prep(conn, task-&gt;hdr, task-&gt;hdr_len);
 
-	if (!ctask-&gt;imm_count)
+	if (!task-&gt;imm_count)
 		return 0;
 
 	/* If we have immediate data, attach a payload */
 	err = iscsi_tcp_send_data_prep(conn, scsi_out(sc)-&gt;table.sgl,
 				       scsi_out(sc)-&gt;table.nents,
-				       0, ctask-&gt;imm_count);
+				       0, task-&gt;imm_count);
 	if (err)
 		return err;
-	tcp_ctask-&gt;sent += ctask-&gt;imm_count;
-	ctask-&gt;imm_count = 0;
+	tcp_task-&gt;sent += task-&gt;imm_count;
+	task-&gt;imm_count = 0;
 	return 0;
 }
 
 /*
- * iscsi_tcp_task_xmit - xmit normal PDU ctask
- * @ctask: iscsi command ctask
+ * iscsi_tcp_task_xmit - xmit normal PDU task
+ * @task: iscsi command task
  *
  * We're expected to return 0 when everything was transmitted succesfully,
  * -EAGAIN if there's still data in the queue, or != 0 for any other kind
  * of error.
  */
 static int
-iscsi_tcp_task_xmit(struct iscsi_cmd_task *ctask)
+iscsi_tcp_task_xmit(struct iscsi_task *task)
 {
-	struct iscsi_conn *conn = ctask-&gt;conn;
-	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
-	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct iscsi_conn *conn = task-&gt;conn;
+	struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
+	struct scsi_cmnd *sc = task-&gt;sc;
 	struct scsi_data_buffer *sdb;
 	int rc = 0;
 
@@ -1404,8 +1404,8 @@ iscsi_tcp_task_xmit(struct iscsi_cmd_task *ctask)
 
 	/* mgmt command */
 	if (!sc) {
-		if (ctask-&gt;hdr-&gt;itt == RESERVED_ITT)
-			iscsi_put_ctask(ctask);
+		if (task-&gt;hdr-&gt;itt == RESERVED_ITT)
+			iscsi_put_task(task);
 		return 0;
 	}
 
@@ -1414,27 +1414,27 @@ iscsi_tcp_task_xmit(struct iscsi_cmd_task *ctask)
 		return 0;
 
 	sdb = scsi_out(sc);
-	if (ctask-&gt;unsol_count != 0) {
-		struct iscsi_data *hdr = &amp;tcp_ctask-&gt;unsol_dtask.hdr;
+	if (task-&gt;unsol_count != 0) {
+		struct iscsi_data *hdr = &amp;tcp_task-&gt;unsol_dtask.hdr;
 
 		/* Prepare a header for the unsolicited PDU.
 		 * The amount of data we want to send will be
-		 * in ctask-&gt;data_count.
+		 * in task-&gt;data_count.
 		 * FIXME: return the data count instead.
 		 */
-		iscsi_prep_unsolicit_data_pdu(ctask, hdr);
+		iscsi_prep_unsolicit_data_pdu(task, hdr);
 
 		debug_tcp("unsol dout [itt 0x%x doff %d dlen %d]\n",
-				ctask-&gt;itt, tcp_ctask-&gt;sent, ctask-&gt;data_count);
+				task-&gt;itt, tcp_task-&gt;sent, task-&gt;data_count);
 
 		iscsi_tcp_send_hdr_prep(conn, hdr, sizeof(*hdr));
 		rc = iscsi_tcp_send_data_prep(conn, sdb-&gt;table.sgl,
-					      sdb-&gt;table.nents, tcp_ctask-&gt;sent,
-					      ctask-&gt;data_count);
+					      sdb-&gt;table.nents, tcp_task-&gt;sent,
+					      task-&gt;data_count);
 		if (rc)
 			goto fail;
-		tcp_ctask-&gt;sent += ctask-&gt;data_count;
-		ctask-&gt;unsol_count -= ctask-&gt;data_count;
+		tcp_task-&gt;sent += task-&gt;data_count;
+		task-&gt;unsol_count -= task-&gt;data_count;
 		goto flush;
 	} else {
 		struct iscsi_session *session = conn-&gt;session;
@@ -1443,22 +1443,22 @@ iscsi_tcp_task_xmit(struct iscsi_cmd_task *ctask)
 		/* All unsolicited PDUs sent. Check for solicited PDUs.
 		 */
 		spin_lock_bh(&amp;session-&gt;lock);
-		r2t = tcp_ctask-&gt;r2t;
+		r2t = tcp_task-&gt;r2t;
 		if (r2t != NULL) {
 			/* Continue with this R2T? */
-			if (!iscsi_solicit_data_cont(conn, ctask, r2t)) {
+			if (!iscsi_solicit_data_cont(conn, task, r2t)) {
 				debug_scsi("  done with r2t %p\n", r2t);
 
-				__kfifo_put(tcp_ctask-&gt;r2tpool.queue,
+				__kfifo_put(tcp_task-&gt;r2tpool.queue,
 					    (void*)&amp;r2t, sizeof(void*));
-				tcp_ctask-&gt;r2t = r2t = NULL;
+				tcp_task-&gt;r2t = r2t = NULL;
 			}
 		}
 
 		if (r2t == NULL) {
-			__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;tcp_ctask-&gt;r2t,
+			__kfifo_get(tcp_task-&gt;r2tqueue, (void*)&amp;tcp_task-&gt;r2t,
 				    sizeof(void*));
-			r2t = tcp_ctask-&gt;r2t;
+			r2t = tcp_task-&gt;r2t;
 		}
 		spin_unlock_bh(&amp;session-&gt;lock);
 
@@ -1469,7 +1469,7 @@ iscsi_tcp_task_xmit(struct iscsi_cmd_task *ctask)
 		}
 
 		debug_scsi("sol dout %p [dsn %d itt 0x%x doff %d dlen %d]\n",
-			r2t, r2t-&gt;solicit_datasn - 1, ctask-&gt;itt,
+			r2t, r2t-&gt;solicit_datasn - 1, task-&gt;itt,
 			r2t-&gt;data_offset + r2t-&gt;sent, r2t-&gt;data_count);
 
 		iscsi_tcp_send_hdr_prep(conn, &amp;r2t-&gt;dtask.hdr,
@@ -1481,7 +1481,7 @@ iscsi_tcp_task_xmit(struct iscsi_cmd_task *ctask)
 					      r2t-&gt;data_count);
 		if (rc)
 			goto fail;
-		tcp_ctask-&gt;sent += r2t-&gt;data_count;
+		tcp_task-&gt;sent += r2t-&gt;data_count;
 		r2t-&gt;sent += r2t-&gt;data_count;
 		goto flush;
 	}
@@ -1698,11 +1698,11 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 	int cmd_i;
 
 	/*
-	 * initialize per-ctask: R2T pool and xmit queue
+	 * initialize per-task: R2T pool and xmit queue
 	 */
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
-	        struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
-		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	        struct iscsi_task *task = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 
 		/*
 		 * pre-allocated x4 as much r2ts to handle race when
@@ -1711,16 +1711,16 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 		 */
 
 		/* R2T pool */
-		if (iscsi_pool_init(&amp;tcp_ctask-&gt;r2tpool, session-&gt;max_r2t * 4, NULL,
+		if (iscsi_pool_init(&amp;tcp_task-&gt;r2tpool, session-&gt;max_r2t * 4, NULL,
 				    sizeof(struct iscsi_r2t_info))) {
 			goto r2t_alloc_fail;
 		}
 
 		/* R2T xmit queue */
-		tcp_ctask-&gt;r2tqueue = kfifo_alloc(
+		tcp_task-&gt;r2tqueue = kfifo_alloc(
 		      session-&gt;max_r2t * 4 * sizeof(void*), GFP_KERNEL, NULL);
-		if (tcp_ctask-&gt;r2tqueue == ERR_PTR(-ENOMEM)) {
-			iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool);
+		if (tcp_task-&gt;r2tqueue == ERR_PTR(-ENOMEM)) {
+			iscsi_pool_free(&amp;tcp_task-&gt;r2tpool);
 			goto r2t_alloc_fail;
 		}
 	}
@@ -1729,11 +1729,11 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 
 r2t_alloc_fail:
 	for (i = 0; i &lt; cmd_i; i++) {
-		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
-		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+		struct iscsi_task *task = session-&gt;cmds[i];
+		struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 
-		kfifo_free(tcp_ctask-&gt;r2tqueue);
-		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool);
+		kfifo_free(tcp_task-&gt;r2tqueue);
+		iscsi_pool_free(&amp;tcp_task-&gt;r2tpool);
 	}
 	return -ENOMEM;
 }
@@ -1744,11 +1744,11 @@ iscsi_r2tpool_free(struct iscsi_session *session)
 	int i;
 
 	for (i = 0; i &lt; session-&gt;cmds_max; i++) {
-		struct iscsi_cmd_task *ctask = session-&gt;cmds[i];
-		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+		struct iscsi_task *task = session-&gt;cmds[i];
+		struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 
-		kfifo_free(tcp_ctask-&gt;r2tqueue);
-		iscsi_pool_free(&amp;tcp_ctask-&gt;r2tpool);
+		kfifo_free(tcp_task-&gt;r2tqueue);
+		iscsi_pool_free(&amp;tcp_task-&gt;r2tpool);
 	}
 }
 
@@ -1867,7 +1867,7 @@ iscsi_tcp_session_create(struct Scsi_Host *shost, uint16_t cmds_max,
 	*hostno = shost-&gt;host_no;
 
 	cls_session = iscsi_session_setup(&amp;iscsi_tcp_transport, shost, cmds_max,
-					  sizeof(struct iscsi_tcp_cmd_task),
+					  sizeof(struct iscsi_tcp_task),
 					  initial_cmdsn);
 	if (!cls_session)
 		goto remove_host;
@@ -1875,11 +1875,11 @@ iscsi_tcp_session_create(struct Scsi_Host *shost, uint16_t cmds_max,
 
 	shost-&gt;can_queue = session-&gt;scsi_cmds_max;
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
-		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
-		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+		struct iscsi_task *task = session-&gt;cmds[cmd_i];
+		struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 
-		ctask-&gt;hdr = &amp;tcp_ctask-&gt;hdr.cmd_hdr;
-		ctask-&gt;hdr_max = sizeof(tcp_ctask-&gt;hdr) - ISCSI_DIGEST_SIZE;
+		task-&gt;hdr = &amp;tcp_task-&gt;hdr.cmd_hdr;
+		task-&gt;hdr_max = sizeof(tcp_task-&gt;hdr) - ISCSI_DIGEST_SIZE;
 	}
 
 	if (iscsi_r2tpool_alloc(session))
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index c9c8633c41a6..498d8ca39848 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -114,7 +114,7 @@ struct iscsi_r2t_info {
 	struct iscsi_data_task	dtask;		/* Data-Out header buf */
 };
 
-struct iscsi_tcp_cmd_task {
+struct iscsi_tcp_task {
 	struct iscsi_hdr_buff {
 		struct iscsi_cmd	cmd_hdr;
 		char			hdrextbuf[ISCSI_MAX_AHS_SIZE +</pre><hr><pre>commit 9c19a7d0387124a508d2cdb38ebf8cd484631ad0
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:09 2008 -0500

    [SCSI] libiscsi: rename iscsi_cmd_task to iscsi_task
    
    This is the second part of the iscsi task merging, and
    all it does it rename iscsi_cmd_task to iscsi_task and
    mtask/ctask to just task.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index ef92b1b0f16e..92ee6d94aaf9 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -88,61 +88,61 @@ iscsi_update_cmdsn(struct iscsi_session *session, struct iscsi_nopin *hdr)
 }
 EXPORT_SYMBOL_GPL(iscsi_update_cmdsn);
 
-void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *ctask,
+void iscsi_prep_unsolicit_data_pdu(struct iscsi_task *task,
 				   struct iscsi_data *hdr)
 {
-	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_conn *conn = task-&gt;conn;
 
 	memset(hdr, 0, sizeof(struct iscsi_data));
 	hdr-&gt;ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	hdr-&gt;datasn = cpu_to_be32(ctask-&gt;unsol_datasn);
-	ctask-&gt;unsol_datasn++;
+	hdr-&gt;datasn = cpu_to_be32(task-&gt;unsol_datasn);
+	task-&gt;unsol_datasn++;
 	hdr-&gt;opcode = ISCSI_OP_SCSI_DATA_OUT;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	memcpy(hdr-&gt;lun, task-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
 
-	hdr-&gt;itt = ctask-&gt;hdr-&gt;itt;
+	hdr-&gt;itt = task-&gt;hdr-&gt;itt;
 	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
-	hdr-&gt;offset = cpu_to_be32(ctask-&gt;unsol_offset);
+	hdr-&gt;offset = cpu_to_be32(task-&gt;unsol_offset);
 
-	if (ctask-&gt;unsol_count &gt; conn-&gt;max_xmit_dlength) {
+	if (task-&gt;unsol_count &gt; conn-&gt;max_xmit_dlength) {
 		hton24(hdr-&gt;dlength, conn-&gt;max_xmit_dlength);
-		ctask-&gt;data_count = conn-&gt;max_xmit_dlength;
-		ctask-&gt;unsol_offset += ctask-&gt;data_count;
+		task-&gt;data_count = conn-&gt;max_xmit_dlength;
+		task-&gt;unsol_offset += task-&gt;data_count;
 		hdr-&gt;flags = 0;
 	} else {
-		hton24(hdr-&gt;dlength, ctask-&gt;unsol_count);
-		ctask-&gt;data_count = ctask-&gt;unsol_count;
+		hton24(hdr-&gt;dlength, task-&gt;unsol_count);
+		task-&gt;data_count = task-&gt;unsol_count;
 		hdr-&gt;flags = ISCSI_FLAG_CMD_FINAL;
 	}
 }
 EXPORT_SYMBOL_GPL(iscsi_prep_unsolicit_data_pdu);
 
-static int iscsi_add_hdr(struct iscsi_cmd_task *ctask, unsigned len)
+static int iscsi_add_hdr(struct iscsi_task *task, unsigned len)
 {
-	unsigned exp_len = ctask-&gt;hdr_len + len;
+	unsigned exp_len = task-&gt;hdr_len + len;
 
-	if (exp_len &gt; ctask-&gt;hdr_max) {
+	if (exp_len &gt; task-&gt;hdr_max) {
 		WARN_ON(1);
 		return -EINVAL;
 	}
 
 	WARN_ON(len &amp; (ISCSI_PAD_LEN - 1)); /* caller must pad the AHS */
-	ctask-&gt;hdr_len = exp_len;
+	task-&gt;hdr_len = exp_len;
 	return 0;
 }
 
 /*
  * make an extended cdb AHS
  */
-static int iscsi_prep_ecdb_ahs(struct iscsi_cmd_task *ctask)
+static int iscsi_prep_ecdb_ahs(struct iscsi_task *task)
 {
-	struct scsi_cmnd *cmd = ctask-&gt;sc;
+	struct scsi_cmnd *cmd = task-&gt;sc;
 	unsigned rlen, pad_len;
 	unsigned short ahslength;
 	struct iscsi_ecdb_ahdr *ecdb_ahdr;
 	int rc;
 
-	ecdb_ahdr = iscsi_next_hdr(ctask);
+	ecdb_ahdr = iscsi_next_hdr(task);
 	rlen = cmd-&gt;cmd_len - ISCSI_CDB_SIZE;
 
 	BUG_ON(rlen &gt; sizeof(ecdb_ahdr-&gt;ecdb));
@@ -150,7 +150,7 @@ static int iscsi_prep_ecdb_ahs(struct iscsi_cmd_task *ctask)
 
 	pad_len = iscsi_padding(rlen);
 
-	rc = iscsi_add_hdr(ctask, sizeof(ecdb_ahdr-&gt;ahslength) +
+	rc = iscsi_add_hdr(task, sizeof(ecdb_ahdr-&gt;ahslength) +
 	                   sizeof(ecdb_ahdr-&gt;ahstype) + ahslength + pad_len);
 	if (rc)
 		return rc;
@@ -165,19 +165,19 @@ static int iscsi_prep_ecdb_ahs(struct iscsi_cmd_task *ctask)
 
 	debug_scsi("iscsi_prep_ecdb_ahs: varlen_cdb_len %d "
 		   "rlen %d pad_len %d ahs_length %d iscsi_headers_size %u\n",
-		   cmd-&gt;cmd_len, rlen, pad_len, ahslength, ctask-&gt;hdr_len);
+		   cmd-&gt;cmd_len, rlen, pad_len, ahslength, task-&gt;hdr_len);
 
 	return 0;
 }
 
-static int iscsi_prep_bidi_ahs(struct iscsi_cmd_task *ctask)
+static int iscsi_prep_bidi_ahs(struct iscsi_task *task)
 {
-	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct scsi_cmnd *sc = task-&gt;sc;
 	struct iscsi_rlength_ahdr *rlen_ahdr;
 	int rc;
 
-	rlen_ahdr = iscsi_next_hdr(ctask);
-	rc = iscsi_add_hdr(ctask, sizeof(*rlen_ahdr));
+	rlen_ahdr = iscsi_next_hdr(task);
+	rc = iscsi_add_hdr(task, sizeof(*rlen_ahdr));
 	if (rc)
 		return rc;
 
@@ -197,28 +197,28 @@ static int iscsi_prep_bidi_ahs(struct iscsi_cmd_task *ctask)
 
 /**
  * iscsi_prep_scsi_cmd_pdu - prep iscsi scsi cmd pdu
- * @ctask: iscsi task
+ * @task: iscsi task
  *
  * Prep basic iSCSI PDU fields for a scsi cmd pdu. The LLD should set
  * fields like dlength or final based on how much data it sends
  */
-static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
+static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 {
-	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_conn *conn = task-&gt;conn;
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_cmd *hdr = ctask-&gt;hdr;
-	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct iscsi_cmd *hdr = task-&gt;hdr;
+	struct scsi_cmnd *sc = task-&gt;sc;
 	unsigned hdrlength, cmd_len;
 	int rc;
 
-	ctask-&gt;hdr_len = 0;
-	rc = iscsi_add_hdr(ctask, sizeof(*hdr));
+	task-&gt;hdr_len = 0;
+	rc = iscsi_add_hdr(task, sizeof(*hdr));
 	if (rc)
 		return rc;
 	hdr-&gt;opcode = ISCSI_OP_SCSI_CMD;
 	hdr-&gt;flags = ISCSI_ATTR_SIMPLE;
 	int_to_scsilun(sc-&gt;device-&gt;lun, (struct scsi_lun *)hdr-&gt;lun);
-	hdr-&gt;itt = build_itt(ctask-&gt;itt, session-&gt;age);
+	hdr-&gt;itt = build_itt(task-&gt;itt, session-&gt;age);
 	hdr-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	session-&gt;cmdsn++;
 	hdr-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
@@ -226,17 +226,17 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
 	if (cmd_len &lt; ISCSI_CDB_SIZE)
 		memset(&amp;hdr-&gt;cdb[cmd_len], 0, ISCSI_CDB_SIZE - cmd_len);
 	else if (cmd_len &gt; ISCSI_CDB_SIZE) {
-		rc = iscsi_prep_ecdb_ahs(ctask);
+		rc = iscsi_prep_ecdb_ahs(task);
 		if (rc)
 			return rc;
 		cmd_len = ISCSI_CDB_SIZE;
 	}
 	memcpy(hdr-&gt;cdb, sc-&gt;cmnd, cmd_len);
 
-	ctask-&gt;imm_count = 0;
+	task-&gt;imm_count = 0;
 	if (scsi_bidi_cmnd(sc)) {
 		hdr-&gt;flags |= ISCSI_FLAG_CMD_READ;
-		rc = iscsi_prep_bidi_ahs(ctask);
+		rc = iscsi_prep_bidi_ahs(task);
 		if (rc)
 			return rc;
 	}
@@ -258,28 +258,28 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
 		 *
 		 *      pad_count       bytes to be sent as zero-padding
 		 */
-		ctask-&gt;unsol_count = 0;
-		ctask-&gt;unsol_offset = 0;
-		ctask-&gt;unsol_datasn = 0;
+		task-&gt;unsol_count = 0;
+		task-&gt;unsol_offset = 0;
+		task-&gt;unsol_datasn = 0;
 
 		if (session-&gt;imm_data_en) {
 			if (out_len &gt;= session-&gt;first_burst)
-				ctask-&gt;imm_count = min(session-&gt;first_burst,
+				task-&gt;imm_count = min(session-&gt;first_burst,
 							conn-&gt;max_xmit_dlength);
 			else
-				ctask-&gt;imm_count = min(out_len,
+				task-&gt;imm_count = min(out_len,
 							conn-&gt;max_xmit_dlength);
-			hton24(hdr-&gt;dlength, ctask-&gt;imm_count);
+			hton24(hdr-&gt;dlength, task-&gt;imm_count);
 		} else
 			zero_data(hdr-&gt;dlength);
 
 		if (!session-&gt;initial_r2t_en) {
-			ctask-&gt;unsol_count = min(session-&gt;first_burst, out_len)
-							     - ctask-&gt;imm_count;
-			ctask-&gt;unsol_offset = ctask-&gt;imm_count;
+			task-&gt;unsol_count = min(session-&gt;first_burst, out_len)
+							     - task-&gt;imm_count;
+			task-&gt;unsol_offset = task-&gt;imm_count;
 		}
 
-		if (!ctask-&gt;unsol_count)
+		if (!task-&gt;unsol_count)
 			/* No unsolicit Data-Out's */
 			hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
 	} else {
@@ -292,7 +292,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
 	}
 
 	/* calculate size of additional header segments (AHSs) */
-	hdrlength = ctask-&gt;hdr_len - sizeof(*hdr);
+	hdrlength = task-&gt;hdr_len - sizeof(*hdr);
 
 	WARN_ON(hdrlength &amp; (ISCSI_PAD_LEN-1));
 	hdrlength /= ISCSI_PAD_LEN;
@@ -301,17 +301,17 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
 	hdr-&gt;hlength = hdrlength &amp; 0xFF;
 
 	if (conn-&gt;session-&gt;tt-&gt;init_task &amp;&amp;
-	    conn-&gt;session-&gt;tt-&gt;init_task(ctask))
+	    conn-&gt;session-&gt;tt-&gt;init_task(task))
 		return -EIO;
 
-	ctask-&gt;state = ISCSI_TASK_RUNNING;
-	list_move_tail(&amp;ctask-&gt;running, &amp;conn-&gt;run_list);
+	task-&gt;state = ISCSI_TASK_RUNNING;
+	list_move_tail(&amp;task-&gt;running, &amp;conn-&gt;run_list);
 
 	conn-&gt;scsicmd_pdus_cnt++;
 	debug_scsi("iscsi prep [%s cid %d sc %p cdb 0x%x itt 0x%x len %d "
 		   "bidi_len %d cmdsn %d win %d]\n", scsi_bidi_cmnd(sc) ?
 		   "bidirectional" : sc-&gt;sc_data_direction == DMA_TO_DEVICE ?
-		   "write" : "read", conn-&gt;id, sc, sc-&gt;cmnd[0], ctask-&gt;itt,
+		   "write" : "read", conn-&gt;id, sc, sc-&gt;cmnd[0], task-&gt;itt,
 		   scsi_bufflen(sc),
 		   scsi_bidi_cmnd(sc) ? scsi_in(sc)-&gt;length : 0,
 		   session-&gt;cmdsn, session-&gt;max_cmdsn - session-&gt;exp_cmdsn + 1);
@@ -320,37 +320,37 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
 
 /**
  * iscsi_complete_command - finish a task
- * @ctask: iscsi cmd task
+ * @task: iscsi cmd task
  *
  * Must be called with session lock.
  * This function returns the scsi command to scsi-ml or cleans
  * up mgmt tasks then returns the task to the pool.
  */
-static void iscsi_complete_command(struct iscsi_cmd_task *ctask)
+static void iscsi_complete_command(struct iscsi_task *task)
 {
-	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_conn *conn = task-&gt;conn;
 	struct iscsi_session *session = conn-&gt;session;
-	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct scsi_cmnd *sc = task-&gt;sc;
 
-	list_del_init(&amp;ctask-&gt;running);
-	ctask-&gt;state = ISCSI_TASK_COMPLETED;
-	ctask-&gt;sc = NULL;
+	list_del_init(&amp;task-&gt;running);
+	task-&gt;state = ISCSI_TASK_COMPLETED;
+	task-&gt;sc = NULL;
 
-	if (conn-&gt;ctask == ctask)
-		conn-&gt;ctask = NULL;
+	if (conn-&gt;task == task)
+		conn-&gt;task = NULL;
 	/*
-	 * login ctask is preallocated so do not free
+	 * login task is preallocated so do not free
 	 */
-	if (conn-&gt;login_ctask == ctask)
+	if (conn-&gt;login_task == task)
 		return;
 
-	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
+	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;task, sizeof(void*));
 
-	if (conn-&gt;ping_ctask == ctask)
-		conn-&gt;ping_ctask = NULL;
+	if (conn-&gt;ping_task == task)
+		conn-&gt;ping_task = NULL;
 
 	if (sc) {
-		ctask-&gt;sc = NULL;
+		task-&gt;sc = NULL;
 		/* SCSI eh reuses commands to verify us */
 		sc-&gt;SCp.ptr = NULL;
 		/*
@@ -362,47 +362,47 @@ static void iscsi_complete_command(struct iscsi_cmd_task *ctask)
 	}
 }
 
-static void __iscsi_get_ctask(struct iscsi_cmd_task *ctask)
+static void __iscsi_get_task(struct iscsi_task *task)
 {
-	atomic_inc(&amp;ctask-&gt;refcount);
+	atomic_inc(&amp;task-&gt;refcount);
 }
 
-static void __iscsi_put_ctask(struct iscsi_cmd_task *ctask)
+static void __iscsi_put_task(struct iscsi_task *task)
 {
-	if (atomic_dec_and_test(&amp;ctask-&gt;refcount))
-		iscsi_complete_command(ctask);
+	if (atomic_dec_and_test(&amp;task-&gt;refcount))
+		iscsi_complete_command(task);
 }
 
-void iscsi_put_ctask(struct iscsi_cmd_task *ctask)
+void iscsi_put_task(struct iscsi_task *task)
 {
-	struct iscsi_session *session = ctask-&gt;conn-&gt;session;
+	struct iscsi_session *session = task-&gt;conn-&gt;session;
 
 	spin_lock_bh(&amp;session-&gt;lock);
-	__iscsi_put_ctask(ctask);
+	__iscsi_put_task(task);
 	spin_unlock_bh(&amp;session-&gt;lock);
 }
-EXPORT_SYMBOL_GPL(iscsi_put_ctask);
+EXPORT_SYMBOL_GPL(iscsi_put_task);
 
 /*
  * session lock must be held
  */
-static void fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
+static void fail_command(struct iscsi_conn *conn, struct iscsi_task *task,
 			 int err)
 {
 	struct scsi_cmnd *sc;
 
-	sc = ctask-&gt;sc;
+	sc = task-&gt;sc;
 	if (!sc)
 		return;
 
-	if (ctask-&gt;state == ISCSI_TASK_PENDING)
+	if (task-&gt;state == ISCSI_TASK_PENDING)
 		/*
 		 * cmd never made it to the xmit thread, so we should not count
 		 * the cmd in the sequencing
 		 */
 		conn-&gt;session-&gt;queued_cmdsn--;
 	else
-		conn-&gt;session-&gt;tt-&gt;cleanup_task(conn, ctask);
+		conn-&gt;session-&gt;tt-&gt;cleanup_task(conn, task);
 
 	sc-&gt;result = err;
 
@@ -413,17 +413,17 @@ static void fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 		scsi_in(sc)-&gt;resid = scsi_in(sc)-&gt;length;
 	}
 
-	if (conn-&gt;ctask == ctask)
-		conn-&gt;ctask = NULL;
+	if (conn-&gt;task == task)
+		conn-&gt;task = NULL;
 	/* release ref from queuecommand */
-	__iscsi_put_ctask(ctask);
+	__iscsi_put_task(task);
 }
 
 static int iscsi_prep_mgmt_task(struct iscsi_conn *conn,
-				struct iscsi_cmd_task *ctask)
+				struct iscsi_task *task)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_hdr *hdr = (struct iscsi_hdr *)ctask-&gt;hdr;
+	struct iscsi_hdr *hdr = (struct iscsi_hdr *)task-&gt;hdr;
 	struct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;
 
 	if (conn-&gt;session-&gt;state == ISCSI_STATE_LOGGING_OUT)
@@ -437,7 +437,7 @@ static int iscsi_prep_mgmt_task(struct iscsi_conn *conn,
 	 */
 	nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	if (hdr-&gt;itt != RESERVED_ITT) {
-		hdr-&gt;itt = build_itt(ctask-&gt;itt, session-&gt;age);
+		hdr-&gt;itt = build_itt(task-&gt;itt, session-&gt;age);
 		/*
 		 * TODO: We always use immediate, so we never hit this.
 		 * If we start to send tmfs or nops as non-immediate then
@@ -451,24 +451,24 @@ static int iscsi_prep_mgmt_task(struct iscsi_conn *conn,
 	}
 
 	if (session-&gt;tt-&gt;init_task)
-		session-&gt;tt-&gt;init_task(ctask);
+		session-&gt;tt-&gt;init_task(task);
 
 	if ((hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) == ISCSI_OP_LOGOUT)
 		session-&gt;state = ISCSI_STATE_LOGGING_OUT;
 
-	list_move_tail(&amp;ctask-&gt;running, &amp;conn-&gt;mgmt_run_list);
+	list_move_tail(&amp;task-&gt;running, &amp;conn-&gt;mgmt_run_list);
 	debug_scsi("mgmtpdu [op 0x%x hdr-&gt;itt 0x%x datalen %d]\n",
 		   hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, hdr-&gt;itt,
-		   ctask-&gt;data_count);
+		   task-&gt;data_count);
 	return 0;
 }
 
-static struct iscsi_cmd_task *
+static struct iscsi_task *
 __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		      char *data, uint32_t data_size)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 
 	if (session-&gt;state == ISCSI_STATE_TERMINATE)
 		return NULL;
@@ -481,18 +481,18 @@ __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		 * Same task can be used. Same ITT must be used.
 		 * Note that login_task is preallocated at conn_create().
 		 */
-		ctask = conn-&gt;login_ctask;
+		task = conn-&gt;login_task;
 	else {
 		BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
 		BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
 
 		if (!__kfifo_get(session-&gt;cmdpool.queue,
-				 (void*)&amp;ctask, sizeof(void*)))
+				 (void*)&amp;task, sizeof(void*)))
 			return NULL;
 
 		if ((hdr-&gt;opcode == (ISCSI_OP_NOOP_OUT | ISCSI_OP_IMMEDIATE)) &amp;&amp;
 		     hdr-&gt;ttt == RESERVED_ITT) {
-			conn-&gt;ping_ctask = ctask;
+			conn-&gt;ping_task = task;
 			conn-&gt;last_ping = jiffies;
 		}
 	}
@@ -501,33 +501,33 @@ __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	 * released by the lld when it has transmitted the task for
 	 * pdus we do not expect a response for.
 	 */
-	atomic_set(&amp;ctask-&gt;refcount, 1);
-	ctask-&gt;conn = conn;
-	ctask-&gt;sc = NULL;
+	atomic_set(&amp;task-&gt;refcount, 1);
+	task-&gt;conn = conn;
+	task-&gt;sc = NULL;
 
 	if (data_size) {
-		memcpy(ctask-&gt;data, data, data_size);
-		ctask-&gt;data_count = data_size;
+		memcpy(task-&gt;data, data, data_size);
+		task-&gt;data_count = data_size;
 	} else
-		ctask-&gt;data_count = 0;
+		task-&gt;data_count = 0;
 
-	memcpy(ctask-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
-	INIT_LIST_HEAD(&amp;ctask-&gt;running);
-	list_add_tail(&amp;ctask-&gt;running, &amp;conn-&gt;mgmtqueue);
+	memcpy(task-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
+	INIT_LIST_HEAD(&amp;task-&gt;running);
+	list_add_tail(&amp;task-&gt;running, &amp;conn-&gt;mgmtqueue);
 
 	if (session-&gt;tt-&gt;caps &amp; CAP_DATA_PATH_OFFLOAD) {
-		if (iscsi_prep_mgmt_task(conn, ctask)) {
-			__iscsi_put_ctask(ctask);
+		if (iscsi_prep_mgmt_task(conn, task)) {
+			__iscsi_put_task(task);
 			return NULL;
 		}
 
-		if (session-&gt;tt-&gt;xmit_task(ctask))
-			ctask = NULL;
+		if (session-&gt;tt-&gt;xmit_task(task))
+			task = NULL;
 
 	} else
 		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 
-	return ctask;
+	return task;
 }
 
 int iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,
@@ -549,20 +549,20 @@ EXPORT_SYMBOL_GPL(iscsi_conn_send_pdu);
  * iscsi_cmd_rsp - SCSI Command Response processing
  * @conn: iscsi connection
  * @hdr: iscsi header
- * @ctask: scsi command task
+ * @task: scsi command task
  * @data: cmd data buffer
  * @datalen: len of buffer
  *
  * iscsi_cmd_rsp sets up the scsi_cmnd fields based on the PDU and
- * then completes the command and ctask.
+ * then completes the command and task.
  **/
 static void iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
-			       struct iscsi_cmd_task *ctask, char *data,
+			       struct iscsi_task *task, char *data,
 			       int datalen)
 {
 	struct iscsi_cmd_rsp *rhdr = (struct iscsi_cmd_rsp *)hdr;
 	struct iscsi_session *session = conn-&gt;session;
-	struct scsi_cmnd *sc = ctask-&gt;sc;
+	struct scsi_cmnd *sc = task-&gt;sc;
 
 	iscsi_update_cmdsn(session, (struct iscsi_nopin*)rhdr);
 	conn-&gt;exp_statsn = be32_to_cpu(rhdr-&gt;statsn) + 1;
@@ -622,10 +622,10 @@ static void iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	}
 out:
 	debug_scsi("done [sc %lx res %d itt 0x%x]\n",
-		   (long)sc, sc-&gt;result, ctask-&gt;itt);
+		   (long)sc, sc-&gt;result, task-&gt;itt);
 	conn-&gt;scsirsp_pdus_cnt++;
 
-	__iscsi_put_ctask(ctask);
+	__iscsi_put_task(task);
 }
 
 static void iscsi_tmf_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
@@ -650,9 +650,9 @@ static void iscsi_tmf_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 static void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)
 {
         struct iscsi_nopout hdr;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 
-	if (!rhdr &amp;&amp; conn-&gt;ping_ctask)
+	if (!rhdr &amp;&amp; conn-&gt;ping_task)
 		return;
 
 	memset(&amp;hdr, 0, sizeof(struct iscsi_nopout));
@@ -666,8 +666,8 @@ static void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)
 	} else
 		hdr.ttt = RESERVED_ITT;
 
-	ctask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)&amp;hdr, NULL, 0);
-	if (!ctask)
+	task = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)&amp;hdr, NULL, 0);
+	if (!task)
 		iscsi_conn_printk(KERN_ERR, conn, "Could not send nopout\n");
 }
 
@@ -712,7 +712,7 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 {
 	struct iscsi_session *session = conn-&gt;session;
 	int opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, rc = 0;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 	uint32_t itt;
 
 	conn-&gt;last_recv = jiffies;
@@ -758,27 +758,27 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		goto out;
 	}
 
-	ctask = session-&gt;cmds[itt];
+	task = session-&gt;cmds[itt];
 	switch(opcode) {
 	case ISCSI_OP_SCSI_CMD_RSP:
-		if (!ctask-&gt;sc) {
+		if (!task-&gt;sc) {
 			rc = ISCSI_ERR_NO_SCSI_CMD;
 			break;
 		}
-		BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
-		iscsi_scsi_cmd_rsp(conn, hdr, ctask, data, datalen);
+		BUG_ON((void*)task != task-&gt;sc-&gt;SCp.ptr);
+		iscsi_scsi_cmd_rsp(conn, hdr, task, data, datalen);
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
-		if (!ctask-&gt;sc) {
+		if (!task-&gt;sc) {
 			rc = ISCSI_ERR_NO_SCSI_CMD;
 			break;
 		}
-		BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
+		BUG_ON((void*)task != task-&gt;sc-&gt;SCp.ptr);
 		if (hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
 			conn-&gt;scsirsp_pdus_cnt++;
 			iscsi_update_cmdsn(session,
 					   (struct iscsi_nopin*) hdr);
-			__iscsi_put_ctask(ctask);
+			__iscsi_put_task(task);
 		}
 		break;
 	case ISCSI_OP_R2T:
@@ -808,7 +808,7 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		}
 
 		iscsi_tmf_rsp(conn, hdr);
-		__iscsi_put_ctask(ctask);
+		__iscsi_put_task(task);
 		break;
 	case ISCSI_OP_NOOP_IN:
 		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
@@ -818,13 +818,15 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		}
 		conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
 
-		if (conn-&gt;ping_ctask != ctask)
+		if (conn-&gt;ping_task != task)
 			/*
 			 * If this is not in response to one of our
 			 * nops then it must be from userspace.
 			 */
 			goto recv_pdu;
-		__iscsi_put_ctask(ctask);
+
+		mod_timer(&amp;conn-&gt;transport_timer, jiffies + conn-&gt;recv_timeout);
+		__iscsi_put_task(task);
 		break;
 	default:
 		rc = ISCSI_ERR_BAD_OPCODE;
@@ -836,7 +838,7 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 recv_pdu:
 	if (iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen))
 		rc = ISCSI_ERR_CONN_FAILED;
-	__iscsi_put_ctask(ctask);
+	__iscsi_put_task(task);
 	return rc;
 }
 
@@ -855,7 +857,7 @@ EXPORT_SYMBOL_GPL(iscsi_complete_pdu);
 int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 	uint32_t i;
 
 	if (itt == RESERVED_ITT)
@@ -878,11 +880,11 @@ int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 		return ISCSI_ERR_BAD_ITT;
 	}
 
-	ctask = session-&gt;cmds[i];
-	if (ctask-&gt;sc &amp;&amp; ctask-&gt;sc-&gt;SCp.phase != session-&gt;age) {
+	task = session-&gt;cmds[i];
+	if (task-&gt;sc &amp;&amp; task-&gt;sc-&gt;SCp.phase != session-&gt;age) {
 		iscsi_conn_printk(KERN_ERR, conn,
-				  "iscsi: ctask's session age %d, "
-				  "expected %d\n", ctask-&gt;sc-&gt;SCp.phase,
+				  "iscsi: task's session age %d, "
+				  "expected %d\n", task-&gt;sc-&gt;SCp.phase,
 				  session-&gt;age);
 		return ISCSI_ERR_SESSION_FAILED;
 	}
@@ -890,11 +892,11 @@ int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 }
 EXPORT_SYMBOL_GPL(iscsi_verify_itt);
 
-struct iscsi_cmd_task *
+struct iscsi_task *
 iscsi_itt_to_ctask(struct iscsi_conn *conn, itt_t itt)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 	uint32_t i;
 
 	if (iscsi_verify_itt(conn, itt))
@@ -907,14 +909,14 @@ iscsi_itt_to_ctask(struct iscsi_conn *conn, itt_t itt)
 	if (i &gt;= session-&gt;cmds_max)
 		return NULL;
 
-	ctask = session-&gt;cmds[i];
-	if (!ctask-&gt;sc)
+	task = session-&gt;cmds[i];
+	if (!task-&gt;sc)
 		return NULL;
 
-	if (ctask-&gt;sc-&gt;SCp.phase != session-&gt;age)
+	if (task-&gt;sc-&gt;SCp.phase != session-&gt;age)
 		return NULL;
 
-	return ctask;
+	return task;
 }
 EXPORT_SYMBOL_GPL(iscsi_itt_to_ctask);
 
@@ -955,38 +957,38 @@ static int iscsi_check_cmdsn_window_closed(struct iscsi_conn *conn)
 	return 0;
 }
 
-static int iscsi_xmit_ctask(struct iscsi_conn *conn)
+static int iscsi_xmit_task(struct iscsi_conn *conn)
 {
-	struct iscsi_cmd_task *ctask = conn-&gt;ctask;
+	struct iscsi_task *task = conn-&gt;task;
 	int rc;
 
-	__iscsi_get_ctask(ctask);
+	__iscsi_get_task(task);
 	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-	rc = conn-&gt;session-&gt;tt-&gt;xmit_task(ctask);
+	rc = conn-&gt;session-&gt;tt-&gt;xmit_task(task);
 	spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-	__iscsi_put_ctask(ctask);
+	__iscsi_put_task(task);
 	if (!rc)
-		/* done with this ctask */
-		conn-&gt;ctask = NULL;
+		/* done with this task */
+		conn-&gt;task = NULL;
 	return rc;
 }
 
 /**
- * iscsi_requeue_ctask - requeue ctask to run from session workqueue
- * @ctask: ctask to requeue
+ * iscsi_requeue_task - requeue task to run from session workqueue
+ * @task: task to requeue
  *
- * LLDs that need to run a ctask from the session workqueue should call
+ * LLDs that need to run a task from the session workqueue should call
  * this. The session lock must be held. This should only be called
  * by software drivers.
  */
-void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask)
+void iscsi_requeue_task(struct iscsi_task *task)
 {
-	struct iscsi_conn *conn = ctask-&gt;conn;
+	struct iscsi_conn *conn = task-&gt;conn;
 
-	list_move_tail(&amp;ctask-&gt;running, &amp;conn-&gt;requeue);
+	list_move_tail(&amp;task-&gt;running, &amp;conn-&gt;requeue);
 	scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 }
-EXPORT_SYMBOL_GPL(iscsi_requeue_ctask);
+EXPORT_SYMBOL_GPL(iscsi_requeue_task);
 
 /**
  * iscsi_data_xmit - xmit any command into the scheduled connection
@@ -1008,8 +1010,8 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		return -ENODATA;
 	}
 
-	if (conn-&gt;ctask) {
-		rc = iscsi_xmit_ctask(conn);
+	if (conn-&gt;task) {
+		rc = iscsi_xmit_task(conn);
 	        if (rc)
 		        goto again;
 	}
@@ -1021,14 +1023,14 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 	 */
 check_mgmt:
 	while (!list_empty(&amp;conn-&gt;mgmtqueue)) {
-		conn-&gt;ctask = list_entry(conn-&gt;mgmtqueue.next,
-					 struct iscsi_cmd_task, running);
-		if (iscsi_prep_mgmt_task(conn, conn-&gt;ctask)) {
-			__iscsi_put_ctask(conn-&gt;ctask);
-			conn-&gt;ctask = NULL;
+		conn-&gt;task = list_entry(conn-&gt;mgmtqueue.next,
+					 struct iscsi_task, running);
+		if (iscsi_prep_mgmt_task(conn, conn-&gt;task)) {
+			__iscsi_put_task(conn-&gt;task);
+			conn-&gt;task = NULL;
 			continue;
 		}
-		rc = iscsi_xmit_ctask(conn);
+		rc = iscsi_xmit_task(conn);
 		if (rc)
 			goto again;
 	}
@@ -1038,21 +1040,21 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		if (conn-&gt;tmf_state == TMF_QUEUED)
 			break;
 
-		conn-&gt;ctask = list_entry(conn-&gt;xmitqueue.next,
-					 struct iscsi_cmd_task, running);
+		conn-&gt;task = list_entry(conn-&gt;xmitqueue.next,
+					 struct iscsi_task, running);
 		if (conn-&gt;session-&gt;state == ISCSI_STATE_LOGGING_OUT) {
-			fail_command(conn, conn-&gt;ctask, DID_IMM_RETRY &lt;&lt; 16);
+			fail_command(conn, conn-&gt;task, DID_IMM_RETRY &lt;&lt; 16);
 			continue;
 		}
-		if (iscsi_prep_scsi_cmd_pdu(conn-&gt;ctask)) {
-			fail_command(conn, conn-&gt;ctask, DID_ABORT &lt;&lt; 16);
+		if (iscsi_prep_scsi_cmd_pdu(conn-&gt;task)) {
+			fail_command(conn, conn-&gt;task, DID_ABORT &lt;&lt; 16);
 			continue;
 		}
-		rc = iscsi_xmit_ctask(conn);
+		rc = iscsi_xmit_task(conn);
 		if (rc)
 			goto again;
 		/*
-		 * we could continuously get new ctask requests so
+		 * we could continuously get new task requests so
 		 * we need to check the mgmt queue for nops that need to
 		 * be sent to aviod starvation
 		 */
@@ -1070,11 +1072,11 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		if (conn-&gt;session-&gt;state == ISCSI_STATE_LOGGING_OUT)
 			break;
 
-		conn-&gt;ctask = list_entry(conn-&gt;requeue.next,
-					 struct iscsi_cmd_task, running);
-		conn-&gt;ctask-&gt;state = ISCSI_TASK_RUNNING;
+		conn-&gt;task = list_entry(conn-&gt;requeue.next,
+					 struct iscsi_task, running);
+		conn-&gt;task-&gt;state = ISCSI_TASK_RUNNING;
 		list_move_tail(conn-&gt;requeue.next, &amp;conn-&gt;run_list);
-		rc = iscsi_xmit_ctask(conn);
+		rc = iscsi_xmit_task(conn);
 		if (rc)
 			goto again;
 		if (!list_empty(&amp;conn-&gt;mgmtqueue))
@@ -1123,7 +1125,7 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 	int reason = 0;
 	struct iscsi_session *session;
 	struct iscsi_conn *conn;
-	struct iscsi_cmd_task *ctask = NULL;
+	struct iscsi_task *task = NULL;
 
 	sc-&gt;scsi_done = done;
 	sc-&gt;result = 0;
@@ -1191,31 +1193,31 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 		goto reject;
 	}
 
-	if (!__kfifo_get(session-&gt;cmdpool.queue, (void*)&amp;ctask,
+	if (!__kfifo_get(session-&gt;cmdpool.queue, (void*)&amp;task,
 			 sizeof(void*))) {
 		reason = FAILURE_OOM;
 		goto reject;
 	}
 	sc-&gt;SCp.phase = session-&gt;age;
-	sc-&gt;SCp.ptr = (char *)ctask;
+	sc-&gt;SCp.ptr = (char *)task;
 
-	atomic_set(&amp;ctask-&gt;refcount, 1);
-	ctask-&gt;state = ISCSI_TASK_PENDING;
-	ctask-&gt;conn = conn;
-	ctask-&gt;sc = sc;
-	INIT_LIST_HEAD(&amp;ctask-&gt;running);
-	list_add_tail(&amp;ctask-&gt;running, &amp;conn-&gt;xmitqueue);
+	atomic_set(&amp;task-&gt;refcount, 1);
+	task-&gt;state = ISCSI_TASK_PENDING;
+	task-&gt;conn = conn;
+	task-&gt;sc = sc;
+	INIT_LIST_HEAD(&amp;task-&gt;running);
+	list_add_tail(&amp;task-&gt;running, &amp;conn-&gt;xmitqueue);
 
 	if (session-&gt;tt-&gt;caps &amp; CAP_DATA_PATH_OFFLOAD) {
-		if (iscsi_prep_scsi_cmd_pdu(ctask)) {
+		if (iscsi_prep_scsi_cmd_pdu(task)) {
 			sc-&gt;result = DID_ABORT &lt;&lt; 16;
 			sc-&gt;scsi_done = NULL;
-			iscsi_complete_command(ctask);
+			iscsi_complete_command(task);
 			goto fault;
 		}
-		if (session-&gt;tt-&gt;xmit_task(ctask)) {
+		if (session-&gt;tt-&gt;xmit_task(task)) {
 			sc-&gt;scsi_done = NULL;
-			iscsi_complete_command(ctask);
+			iscsi_complete_command(task);
 			reason = FAILURE_SESSION_NOT_READY;
 			goto reject;
 		}
@@ -1336,16 +1338,16 @@ static void iscsi_tmf_timedout(unsigned long data)
 	spin_unlock(&amp;session-&gt;lock);
 }
 
-static int iscsi_exec_ctask_mgmt_fn(struct iscsi_conn *conn,
+static int iscsi_exec_task_mgmt_fn(struct iscsi_conn *conn,
 				   struct iscsi_tm *hdr, int age,
 				   int timeout)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 
-	ctask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)hdr,
+	task = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)hdr,
 				      NULL, 0);
-	if (!ctask) {
+	if (!task) {
 		spin_unlock_bh(&amp;session-&gt;lock);
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 		spin_lock_bh(&amp;session-&gt;lock);
@@ -1379,7 +1381,7 @@ static int iscsi_exec_ctask_mgmt_fn(struct iscsi_conn *conn,
 
 	mutex_lock(&amp;session-&gt;eh_mutex);
 	spin_lock_bh(&amp;session-&gt;lock);
-	/* if the session drops it will clean up the ctask */
+	/* if the session drops it will clean up the task */
 	if (age != session-&gt;age ||
 	    session-&gt;state != ISCSI_STATE_LOGGED_IN)
 		return -ENOTCONN;
@@ -1393,34 +1395,34 @@ static int iscsi_exec_ctask_mgmt_fn(struct iscsi_conn *conn,
 static void fail_all_commands(struct iscsi_conn *conn, unsigned lun,
 			      int error)
 {
-	struct iscsi_cmd_task *ctask, *tmp;
+	struct iscsi_task *task, *tmp;
 
-	if (conn-&gt;ctask &amp;&amp; (conn-&gt;ctask-&gt;sc-&gt;device-&gt;lun == lun || lun == -1))
-		conn-&gt;ctask = NULL;
+	if (conn-&gt;task &amp;&amp; (conn-&gt;task-&gt;sc-&gt;device-&gt;lun == lun || lun == -1))
+		conn-&gt;task = NULL;
 
 	/* flush pending */
-	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;xmitqueue, running) {
-		if (lun == ctask-&gt;sc-&gt;device-&gt;lun || lun == -1) {
+	list_for_each_entry_safe(task, tmp, &amp;conn-&gt;xmitqueue, running) {
+		if (lun == task-&gt;sc-&gt;device-&gt;lun || lun == -1) {
 			debug_scsi("failing pending sc %p itt 0x%x\n",
-				   ctask-&gt;sc, ctask-&gt;itt);
-			fail_command(conn, ctask, error &lt;&lt; 16);
+				   task-&gt;sc, task-&gt;itt);
+			fail_command(conn, task, error &lt;&lt; 16);
 		}
 	}
 
-	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;requeue, running) {
-		if (lun == ctask-&gt;sc-&gt;device-&gt;lun || lun == -1) {
+	list_for_each_entry_safe(task, tmp, &amp;conn-&gt;requeue, running) {
+		if (lun == task-&gt;sc-&gt;device-&gt;lun || lun == -1) {
 			debug_scsi("failing requeued sc %p itt 0x%x\n",
-				   ctask-&gt;sc, ctask-&gt;itt);
-			fail_command(conn, ctask, error &lt;&lt; 16);
+				   task-&gt;sc, task-&gt;itt);
+			fail_command(conn, task, error &lt;&lt; 16);
 		}
 	}
 
 	/* fail all other running */
-	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;run_list, running) {
-		if (lun == ctask-&gt;sc-&gt;device-&gt;lun || lun == -1) {
+	list_for_each_entry_safe(task, tmp, &amp;conn-&gt;run_list, running) {
+		if (lun == task-&gt;sc-&gt;device-&gt;lun || lun == -1) {
 			debug_scsi("failing in progress sc %p itt 0x%x\n",
-				   ctask-&gt;sc, ctask-&gt;itt);
-			fail_command(conn, ctask, DID_BUS_BUSY &lt;&lt; 16);
+				   task-&gt;sc, task-&gt;itt);
+			fail_command(conn, task, DID_BUS_BUSY &lt;&lt; 16);
 		}
 	}
 }
@@ -1486,7 +1488,7 @@ static enum scsi_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *scmd)
 			   jiffies))
 		rc = EH_RESET_TIMER;
 	/* if in the middle of checking the transport then give us more time */
-	if (conn-&gt;ping_ctask)
+	if (conn-&gt;ping_task)
 		rc = EH_RESET_TIMER;
 done:
 	spin_unlock(&amp;session-&gt;lock);
@@ -1510,7 +1512,7 @@ static void iscsi_check_transport_timeouts(unsigned long data)
 
 	recv_timeout *= HZ;
 	last_recv = conn-&gt;last_recv;
-	if (conn-&gt;ping_ctask &amp;&amp;
+	if (conn-&gt;ping_task &amp;&amp;
 	    time_before_eq(conn-&gt;last_ping + (conn-&gt;ping_timeout * HZ),
 			   jiffies)) {
 		iscsi_conn_printk(KERN_ERR, conn, "ping timeout of %d secs "
@@ -1536,16 +1538,16 @@ static void iscsi_check_transport_timeouts(unsigned long data)
 	spin_unlock(&amp;session-&gt;lock);
 }
 
-static void iscsi_prep_abort_ctask_pdu(struct iscsi_cmd_task *ctask,
+static void iscsi_prep_abort_task_pdu(struct iscsi_task *task,
 				      struct iscsi_tm *hdr)
 {
 	memset(hdr, 0, sizeof(*hdr));
 	hdr-&gt;opcode = ISCSI_OP_SCSI_TMFUNC | ISCSI_OP_IMMEDIATE;
 	hdr-&gt;flags = ISCSI_TM_FUNC_ABORT_TASK &amp; ISCSI_FLAG_TM_FUNC_MASK;
 	hdr-&gt;flags |= ISCSI_FLAG_CMD_FINAL;
-	memcpy(hdr-&gt;lun, ctask-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
-	hdr-&gt;rtt = ctask-&gt;hdr-&gt;itt;
-	hdr-&gt;refcmdsn = ctask-&gt;hdr-&gt;cmdsn;
+	memcpy(hdr-&gt;lun, task-&gt;hdr-&gt;lun, sizeof(hdr-&gt;lun));
+	hdr-&gt;rtt = task-&gt;hdr-&gt;itt;
+	hdr-&gt;refcmdsn = task-&gt;hdr-&gt;cmdsn;
 }
 
 int iscsi_eh_abort(struct scsi_cmnd *sc)
@@ -1553,7 +1555,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
 	struct iscsi_conn *conn;
-	struct iscsi_cmd_task *ctask;
+	struct iscsi_task *task;
 	struct iscsi_tm *hdr;
 	int rc, age;
 
@@ -1588,17 +1590,17 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	conn-&gt;eh_abort_cnt++;
 	age = session-&gt;age;
 
-	ctask = (struct iscsi_cmd_task *)sc-&gt;SCp.ptr;
-	debug_scsi("aborting [sc %p itt 0x%x]\n", sc, ctask-&gt;itt);
+	task = (struct iscsi_task *)sc-&gt;SCp.ptr;
+	debug_scsi("aborting [sc %p itt 0x%x]\n", sc, task-&gt;itt);
 
-	/* ctask completed before time out */
-	if (!ctask-&gt;sc) {
+	/* task completed before time out */
+	if (!task-&gt;sc) {
 		debug_scsi("sc completed while abort in progress\n");
 		goto success;
 	}
 
-	if (ctask-&gt;state == ISCSI_TASK_PENDING) {
-		fail_command(conn, ctask, DID_ABORT &lt;&lt; 16);
+	if (task-&gt;state == ISCSI_TASK_PENDING) {
+		fail_command(conn, task, DID_ABORT &lt;&lt; 16);
 		goto success;
 	}
 
@@ -1608,9 +1610,9 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	conn-&gt;tmf_state = TMF_QUEUED;
 
 	hdr = &amp;conn-&gt;tmhdr;
-	iscsi_prep_abort_ctask_pdu(ctask, hdr);
+	iscsi_prep_abort_task_pdu(task, hdr);
 
-	if (iscsi_exec_ctask_mgmt_fn(conn, hdr, age, session-&gt;abort_timeout)) {
+	if (iscsi_exec_task_mgmt_fn(conn, hdr, age, session-&gt;abort_timeout)) {
 		rc = FAILED;
 		goto failed;
 	}
@@ -1620,11 +1622,11 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 		spin_unlock_bh(&amp;session-&gt;lock);
 		iscsi_suspend_tx(conn);
 		/*
-		 * clean up ctask if aborted. grab the recv lock as a writer
+		 * clean up task if aborted. grab the recv lock as a writer
 		 */
 		write_lock_bh(conn-&gt;recv_lock);
 		spin_lock(&amp;session-&gt;lock);
-		fail_command(conn, ctask, DID_ABORT &lt;&lt; 16);
+		fail_command(conn, task, DID_ABORT &lt;&lt; 16);
 		conn-&gt;tmf_state = TMF_INITIAL;
 		spin_unlock(&amp;session-&gt;lock);
 		write_unlock_bh(conn-&gt;recv_lock);
@@ -1637,7 +1639,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	case TMF_NOT_FOUND:
 		if (!sc-&gt;SCp.ptr) {
 			conn-&gt;tmf_state = TMF_INITIAL;
-			/* ctask completed before tmf abort response */
+			/* task completed before tmf abort response */
 			debug_scsi("sc completed while abort in progress\n");
 			goto success;
 		}
@@ -1650,7 +1652,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 success:
 	spin_unlock_bh(&amp;session-&gt;lock);
 success_unlocked:
-	debug_scsi("abort success [sc %lx itt 0x%x]\n", (long)sc, ctask-&gt;itt);
+	debug_scsi("abort success [sc %lx itt 0x%x]\n", (long)sc, task-&gt;itt);
 	mutex_unlock(&amp;session-&gt;eh_mutex);
 	return SUCCESS;
 
@@ -1658,7 +1660,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	spin_unlock_bh(&amp;session-&gt;lock);
 failed_unlocked:
 	debug_scsi("abort failed [sc %p itt 0x%x]\n", sc,
-		    ctask ? ctask-&gt;itt : 0);
+		    task ? task-&gt;itt : 0);
 	mutex_unlock(&amp;session-&gt;eh_mutex);
 	return FAILED;
 }
@@ -1705,7 +1707,7 @@ int iscsi_eh_device_reset(struct scsi_cmnd *sc)
 	hdr = &amp;conn-&gt;tmhdr;
 	iscsi_prep_lun_reset_pdu(sc, hdr);
 
-	if (iscsi_exec_ctask_mgmt_fn(conn, hdr, session-&gt;age,
+	if (iscsi_exec_task_mgmt_fn(conn, hdr, session-&gt;age,
 				    session-&gt;lu_reset_timeout)) {
 		rc = FAILED;
 		goto unlock;
@@ -1886,7 +1888,7 @@ EXPORT_SYMBOL_GPL(iscsi_host_free);
  * @iscsit: iscsi transport template
  * @shost: scsi host
  * @cmds_max: session can queue
- * @cmd_ctask_size: LLD ctask private data size
+ * @cmd_task_size: LLD task private data size
  * @initial_cmdsn: initial CmdSN
  *
  * This can be used by software iscsi_transports that allocate
@@ -1894,7 +1896,7 @@ EXPORT_SYMBOL_GPL(iscsi_host_free);
  */
 struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
-		    uint16_t scsi_cmds_max, int cmd_ctask_size,
+		    uint16_t scsi_cmds_max, int cmd_task_size,
 		    uint32_t initial_cmdsn)
 {
 	struct iscsi_session *session;
@@ -1902,7 +1904,7 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 	int cmd_i, cmds_max;
 
 	/*
-	 * The iscsi layer needs some ctasks for nop handling and tmfs.
+	 * The iscsi layer needs some tasks for nop handling and tmfs.
 	 */
 	if (scsi_cmds_max &lt; 1)
 		scsi_cmds_max = ISCSI_MGMT_CMDS_MAX;
@@ -1939,17 +1941,17 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 	/* initialize SCSI PDU commands pool */
 	if (iscsi_pool_init(&amp;session-&gt;cmdpool, session-&gt;cmds_max,
 			    (void***)&amp;session-&gt;cmds,
-			    cmd_ctask_size + sizeof(struct iscsi_cmd_task)))
+			    cmd_task_size + sizeof(struct iscsi_task)))
 		goto cmdpool_alloc_fail;
 
 	/* pre-format cmds pool with ITT */
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
-		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
+		struct iscsi_task *task = session-&gt;cmds[cmd_i];
 
-		if (cmd_ctask_size)
-			ctask-&gt;dd_data = &amp;ctask[1];
-		ctask-&gt;itt = cmd_i;
-		INIT_LIST_HEAD(&amp;ctask-&gt;running);
+		if (cmd_task_size)
+			task-&gt;dd_data = &amp;task[1];
+		task-&gt;itt = cmd_i;
+		INIT_LIST_HEAD(&amp;task-&gt;running);
 	}
 
 	if (!try_module_get(iscsit-&gt;owner))
@@ -2035,30 +2037,30 @@ iscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,
 	INIT_LIST_HEAD(&amp;conn-&gt;requeue);
 	INIT_WORK(&amp;conn-&gt;xmitwork, iscsi_xmitworker);
 
-	/* allocate login_ctask used for the login/text sequences */
+	/* allocate login_task used for the login/text sequences */
 	spin_lock_bh(&amp;session-&gt;lock);
 	if (!__kfifo_get(session-&gt;cmdpool.queue,
-                         (void*)&amp;conn-&gt;login_ctask,
+                         (void*)&amp;conn-&gt;login_task,
 			 sizeof(void*))) {
 		spin_unlock_bh(&amp;session-&gt;lock);
-		goto login_ctask_alloc_fail;
+		goto login_task_alloc_fail;
 	}
 	spin_unlock_bh(&amp;session-&gt;lock);
 
 	data = kmalloc(ISCSI_DEF_MAX_RECV_SEG_LEN, GFP_KERNEL);
 	if (!data)
-		goto login_ctask_data_alloc_fail;
-	conn-&gt;login_ctask-&gt;data = conn-&gt;data = data;
+		goto login_task_data_alloc_fail;
+	conn-&gt;login_task-&gt;data = conn-&gt;data = data;
 
 	init_timer(&amp;conn-&gt;tmf_timer);
 	init_waitqueue_head(&amp;conn-&gt;ehwait);
 
 	return cls_conn;
 
-login_ctask_data_alloc_fail:
-	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;conn-&gt;login_ctask,
+login_task_data_alloc_fail:
+	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;conn-&gt;login_task,
 		    sizeof(void*));
-login_ctask_alloc_fail:
+login_task_alloc_fail:
 	iscsi_destroy_conn(cls_conn);
 	return NULL;
 }
@@ -2118,7 +2120,7 @@ void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
 	spin_lock_bh(&amp;session-&gt;lock);
 	kfree(conn-&gt;data);
 	kfree(conn-&gt;persistent_address);
-	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;conn-&gt;login_ctask,
+	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;conn-&gt;login_task,
 		    sizeof(void*));
 	if (session-&gt;leadconn == conn)
 		session-&gt;leadconn = NULL;
@@ -2199,23 +2201,23 @@ EXPORT_SYMBOL_GPL(iscsi_conn_start);
 static void
 flush_control_queues(struct iscsi_session *session, struct iscsi_conn *conn)
 {
-	struct iscsi_cmd_task *ctask, *tmp;
+	struct iscsi_task *task, *tmp;
 
 	/* handle pending */
-	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;mgmtqueue, running) {
-		debug_scsi("flushing pending mgmt ctask itt 0x%x\n", ctask-&gt;itt);
-		/* release ref from prep ctask */
-		__iscsi_put_ctask(ctask);
+	list_for_each_entry_safe(task, tmp, &amp;conn-&gt;mgmtqueue, running) {
+		debug_scsi("flushing pending mgmt task itt 0x%x\n", task-&gt;itt);
+		/* release ref from prep task */
+		__iscsi_put_task(task);
 	}
 
 	/* handle running */
-	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;mgmt_run_list, running) {
-		debug_scsi("flushing running mgmt ctask itt 0x%x\n", ctask-&gt;itt);
-		/* release ref from prep ctask */
-		__iscsi_put_ctask(ctask);
+	list_for_each_entry_safe(task, tmp, &amp;conn-&gt;mgmt_run_list, running) {
+		debug_scsi("flushing running mgmt task itt 0x%x\n", task-&gt;itt);
+		/* release ref from prep task */
+		__iscsi_put_task(task);
 	}
 
-	conn-&gt;ctask = NULL;
+	conn-&gt;task = NULL;
 }
 
 static void iscsi_start_session_recovery(struct iscsi_session *session,
@@ -2246,7 +2248,7 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 
 	/*
 	 * When this is called for the in_login state, we only want to clean
-	 * up the login ctask and connection. We do not need to block and set
+	 * up the login task and connection. We do not need to block and set
 	 * the recovery state again
 	 */
 	if (flag == STOP_CONN_TERM)
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index d1c36759b350..176353c117b6 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -92,7 +92,7 @@ enum {
 	ISCSI_TASK_RUNNING,
 };
 
-struct iscsi_cmd_task {
+struct iscsi_task {
 	/*
 	 * Because LLDs allocate their hdr differently, this is a pointer
 	 * and length to that storage. It must be setup at session
@@ -120,9 +120,9 @@ struct iscsi_cmd_task {
 	void			*dd_data;	/* driver/transport data */
 };
 
-static inline void* iscsi_next_hdr(struct iscsi_cmd_task *ctask)
+static inline void* iscsi_next_hdr(struct iscsi_task *task)
 {
-	return (void*)ctask-&gt;hdr + ctask-&gt;hdr_len;
+	return (void*)task-&gt;hdr + task-&gt;hdr_len;
 }
 
 /* Connection's states */
@@ -151,7 +151,7 @@ struct iscsi_conn {
 	unsigned long		last_ping;
 	int			ping_timeout;
 	int			recv_timeout;
-	struct iscsi_cmd_task 	*ping_ctask;
+	struct iscsi_task 	*ping_task;
 
 	/* iSCSI connection-wide sequencing */
 	uint32_t		exp_statsn;
@@ -167,8 +167,8 @@ struct iscsi_conn {
 	 * should always fit in this buffer
 	 */
 	char			*data;
-	struct iscsi_cmd_task 	*login_ctask;	/* mtask used for login/text */
-	struct iscsi_cmd_task	*ctask;		/* xmit task in progress */
+	struct iscsi_task 	*login_task;	/* mtask used for login/text */
+	struct iscsi_task	*task;		/* xmit task in progress */
 
 	/* xmit */
 	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
@@ -285,7 +285,7 @@ struct iscsi_session {
 
 	int			scsi_cmds_max; 	/* max scsi commands */
 	int			cmds_max;	/* size of cmds array */
-	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
+	struct iscsi_task	**cmds;		/* Original Cmds arr */
 	struct iscsi_pool	cmdpool;	/* PDU's pool */
 };
 
@@ -365,16 +365,16 @@ extern void iscsi_suspend_tx(struct iscsi_conn *conn);
  * pdu and task processing
  */
 extern void iscsi_update_cmdsn(struct iscsi_session *, struct iscsi_nopin *);
-extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_cmd_task *,
+extern void iscsi_prep_unsolicit_data_pdu(struct iscsi_task *,
 					struct iscsi_data *hdr);
 extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 			      char *, int);
 extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
-extern struct iscsi_cmd_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
-extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
-extern void iscsi_put_ctask(struct iscsi_cmd_task *ctask);
+extern struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
+extern void iscsi_requeue_task(struct iscsi_task *task);
+extern void iscsi_put_task(struct iscsi_task *task);
 
 /*
  * generic helpers
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 3f24503dfdf9..0553240796e9 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -33,7 +33,7 @@ struct iscsi_transport;
 struct Scsi_Host;
 struct iscsi_cls_conn;
 struct iscsi_conn;
-struct iscsi_cmd_task;
+struct iscsi_task;
 struct sockaddr;
 
 /**
@@ -112,10 +112,10 @@ struct iscsi_transport {
 			 char *data, uint32_t data_size);
 	void (*get_stats) (struct iscsi_cls_conn *conn,
 			   struct iscsi_stats *stats);
-	int (*init_task) (struct iscsi_cmd_task *task);
-	int (*xmit_task) (struct iscsi_cmd_task *task);
+	int (*init_task) (struct iscsi_task *task);
+	int (*xmit_task) (struct iscsi_task *task);
 	void (*cleanup_task) (struct iscsi_conn *conn,
-				  struct iscsi_cmd_task *task);
+				  struct iscsi_task *task);
 	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
 	int (*ep_connect) (struct sockaddr *dst_addr, int non_blocking,
 			   uint64_t *ep_handle);</pre><hr><pre>commit 2747fdb25726caa1a89229f43d99ca50af72576a
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:08 2008 -0500

    [SCSI] iser: convert ib_iser to support merged tasks
    
    Convert ib_iser to support merged tasks.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 7b1468869066..baecca1ed42a 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -124,15 +124,23 @@ iscsi_iser_recv(struct iscsi_conn *conn,
 
 
 /**
- * iscsi_iser_cmd_init - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
+ * iscsi_iser_task_init - Initialize ctask
+ * @ctask: iscsi ctask
  *
- **/
+ * Initialize the ctask for the scsi command or mgmt command.
+ */
 static int
-iscsi_iser_cmd_init(struct iscsi_cmd_task *ctask)
+iscsi_iser_task_init(struct iscsi_cmd_task *ctask)
 {
-	struct iscsi_iser_conn     *iser_conn  = ctask-&gt;conn-&gt;dd_data;
+	struct iscsi_iser_conn *iser_conn  = ctask-&gt;conn-&gt;dd_data;
 	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
 
+	/* mgmt ctask */
+	if (!ctask-&gt;sc) {
+		iser_ctask-&gt;desc.data = ctask-&gt;data;
+		return 0;
+	}
+
 	iser_ctask-&gt;command_sent = 0;
 	iser_ctask-&gt;iser_conn    = iser_conn;
 	iser_ctask_rdma_init(iser_ctask);
@@ -140,9 +148,9 @@ iscsi_iser_cmd_init(struct iscsi_cmd_task *ctask)
 }
 
 /**
- * iscsi_mtask_xmit - xmit management(immediate) task
+ * iscsi_iser_mtask_xmit - xmit management(immediate) ctask
  * @conn: iscsi connection
- * @mtask: task management task
+ * @ctask: ctask management ctask
  *
  * Notes:
  *	The function can return -EAGAIN in which case caller must
@@ -151,20 +159,19 @@ iscsi_iser_cmd_init(struct iscsi_cmd_task *ctask)
  *
  **/
 static int
-iscsi_iser_mtask_xmit(struct iscsi_conn *conn,
-		      struct iscsi_mgmt_task *mtask)
+iscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	int error = 0;
 
-	debug_scsi("mtask deq [cid %d itt 0x%x]\n", conn-&gt;id, mtask-&gt;itt);
+	debug_scsi("ctask deq [cid %d itt 0x%x]\n", conn-&gt;id, ctask-&gt;itt);
 
-	error = iser_send_control(conn, mtask);
+	error = iser_send_control(conn, ctask);
 
-	/* since iser xmits control with zero copy, mtasks can not be recycled
+	/* since iser xmits control with zero copy, ctasks can not be recycled
 	 * right after sending them.
 	 * The recycling scheme is based on whether a response is expected
-	 * - if yes, the mtask is recycled at iscsi_complete_pdu
-	 * - if no,  the mtask is recycled at iser_snd_completion
+	 * - if yes, the ctask is recycled at iscsi_complete_pdu
+	 * - if no,  the ctask is recycled at iser_snd_completion
 	 */
 	if (error &amp;&amp; error != -ENOBUFS)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
@@ -173,7 +180,7 @@ iscsi_iser_mtask_xmit(struct iscsi_conn *conn,
 }
 
 static int
-iscsi_iser_ctask_xmit_unsol_data(struct iscsi_conn *conn,
+iscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,
 				 struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_data  hdr;
@@ -190,24 +197,27 @@ iscsi_iser_ctask_xmit_unsol_data(struct iscsi_conn *conn,
 		error = iser_send_data_out(conn, ctask, &amp;hdr);
 		if (error) {
 			ctask-&gt;unsol_datasn--;
-			goto iscsi_iser_ctask_xmit_unsol_data_exit;
+			goto iscsi_iser_task_xmit_unsol_data_exit;
 		}
 		ctask-&gt;unsol_count -= ctask-&gt;data_count;
 		debug_scsi("Need to send %d more as data-out PDUs\n",
 			   ctask-&gt;unsol_count);
 	}
 
-iscsi_iser_ctask_xmit_unsol_data_exit:
+iscsi_iser_task_xmit_unsol_data_exit:
 	return error;
 }
 
 static int
-iscsi_iser_ctask_xmit(struct iscsi_conn *conn,
-		      struct iscsi_cmd_task *ctask)
+iscsi_iser_task_xmit(struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_conn *conn = ctask-&gt;conn;
 	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
 	int error = 0;
 
+	if (!ctask-&gt;sc)
+		return iscsi_iser_mtask_xmit(conn, ctask);
+
 	if (ctask-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
 		BUG_ON(scsi_bufflen(ctask-&gt;sc) == 0);
 
@@ -223,25 +233,29 @@ iscsi_iser_ctask_xmit(struct iscsi_conn *conn,
 	if (!iser_ctask-&gt;command_sent) {
 		error = iser_send_command(conn, ctask);
 		if (error)
-			goto iscsi_iser_ctask_xmit_exit;
+			goto iscsi_iser_task_xmit_exit;
 		iser_ctask-&gt;command_sent = 1;
 	}
 
 	/* Send unsolicited data-out PDU(s) if necessary */
 	if (ctask-&gt;unsol_count)
-		error = iscsi_iser_ctask_xmit_unsol_data(conn, ctask);
+		error = iscsi_iser_task_xmit_unsol_data(conn, ctask);
 
- iscsi_iser_ctask_xmit_exit:
+ iscsi_iser_task_xmit_exit:
 	if (error &amp;&amp; error != -ENOBUFS)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 	return error;
 }
 
 static void
-iscsi_iser_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_iser_cleanup_task(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
 
+	/* mgmt tasks do not need special cleanup */
+	if (!ctask-&gt;sc)
+		return;
+
 	if (iser_ctask-&gt;status == ISER_TASK_STATUS_STARTED) {
 		iser_ctask-&gt;status = ISER_TASK_STATUS_COMPLETED;
 		iser_ctask_rdma_finalize(iser_ctask);
@@ -394,10 +408,8 @@ iscsi_iser_session_create(struct Scsi_Host *shost,
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
 	int i;
-	struct iscsi_cmd_task  *ctask;
-	struct iscsi_mgmt_task *mtask;
+	struct iscsi_cmd_task *ctask;
 	struct iscsi_iser_cmd_task *iser_ctask;
-	struct iser_desc *desc;
 
 	if (shost) {
 		printk(KERN_ERR "iscsi_tcp: invalid shost %d.\n",
@@ -425,28 +437,19 @@ iscsi_iser_session_create(struct Scsi_Host *shost,
 	cls_session = iscsi_session_setup(&amp;iscsi_iser_transport, shost,
 					  ISCSI_DEF_XMIT_CMDS_MAX,
 					  sizeof(struct iscsi_iser_cmd_task),
-					  sizeof(struct iser_desc),
 					  initial_cmdsn);
 	if (!cls_session)
 		goto remove_host;
 	session = cls_session-&gt;dd_data;
 
-	shost-&gt;can_queue = session-&gt;cmds_max;
+	shost-&gt;can_queue = session-&gt;scsi_cmds_max;
 	/* libiscsi setup itts, data and pool so just set desc fields */
 	for (i = 0; i &lt; session-&gt;cmds_max; i++) {
-		ctask      = session-&gt;cmds[i];
+		ctask = session-&gt;cmds[i];
 		iser_ctask = ctask-&gt;dd_data;
 		ctask-&gt;hdr = (struct iscsi_cmd *)&amp;iser_ctask-&gt;desc.iscsi_header;
 		ctask-&gt;hdr_max = sizeof(iser_ctask-&gt;desc.iscsi_header);
 	}
-
-	for (i = 0; i &lt; session-&gt;mgmtpool_max; i++) {
-		mtask      = session-&gt;mgmt_cmds[i];
-		desc       = mtask-&gt;dd_data;
-		mtask-&gt;hdr = &amp;desc-&gt;iscsi_header;
-		desc-&gt;data = mtask-&gt;data;
-	}
-
 	return cls_session;
 
 remove_host:
@@ -659,10 +662,9 @@ static struct iscsi_transport iscsi_iser_transport = {
 	/* IO */
 	.send_pdu		= iscsi_conn_send_pdu,
 	.get_stats		= iscsi_iser_conn_get_stats,
-	.init_cmd_task		= iscsi_iser_cmd_init,
-	.xmit_cmd_task		= iscsi_iser_ctask_xmit,
-	.xmit_mgmt_task		= iscsi_iser_mtask_xmit,
-	.cleanup_cmd_task	= iscsi_iser_cleanup_ctask,
+	.init_task		= iscsi_iser_task_init,
+	.xmit_task		= iscsi_iser_task_xmit,
+	.cleanup_task		= iscsi_iser_cleanup_task,
 	/* recovery */
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index bd5c1a554ea6..96a600f127c8 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -298,15 +298,15 @@ extern int iser_debug_level;
 /* allocate connection resources needed for rdma functionality */
 int iser_conn_set_full_featured_mode(struct iscsi_conn *conn);
 
-int iser_send_control(struct iscsi_conn      *conn,
-		      struct iscsi_mgmt_task *mtask);
+int iser_send_control(struct iscsi_conn *conn,
+		      struct iscsi_cmd_task *ctask);
 
-int iser_send_command(struct iscsi_conn      *conn,
-		      struct iscsi_cmd_task  *ctask);
+int iser_send_command(struct iscsi_conn *conn,
+		      struct iscsi_cmd_task *ctask);
 
-int iser_send_data_out(struct iscsi_conn     *conn,
+int iser_send_data_out(struct iscsi_conn *conn,
 		       struct iscsi_cmd_task *ctask,
-		       struct iscsi_data          *hdr);
+		       struct iscsi_data *hdr);
 
 void iscsi_iser_recv(struct iscsi_conn *conn,
 		     struct iscsi_hdr       *hdr,
@@ -326,7 +326,7 @@ void iser_rcv_completion(struct iser_desc *desc,
 
 void iser_snd_completion(struct iser_desc *desc);
 
-void iser_ctask_rdma_init(struct iscsi_iser_cmd_task     *ctask);
+void iser_ctask_rdma_init(struct iscsi_iser_cmd_task *ctask);
 
 void iser_ctask_rdma_finalize(struct iscsi_iser_cmd_task *ctask);
 
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index b82a5f2d4d37..4ea78fbeee95 100644
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -300,13 +300,13 @@ int iser_conn_set_full_featured_mode(struct iscsi_conn *conn)
 }
 
 static int
-iser_check_xmit(struct iscsi_conn *conn, void *task)
+iser_check_xmit(struct iscsi_conn *conn, void *ctask)
 {
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
 
 	if (atomic_read(&amp;iser_conn-&gt;ib_conn-&gt;post_send_buf_count) ==
 	    ISER_QP_MAX_REQ_DTOS) {
-		iser_dbg("%ld can't xmit task %p\n",jiffies,task);
+		iser_dbg("%ld can't xmit ctask %p\n",jiffies,ctask);
 		return -ENOBUFS;
 	}
 	return 0;
@@ -316,7 +316,7 @@ iser_check_xmit(struct iscsi_conn *conn, void *task)
 /**
  * iser_send_command - send command PDU
  */
-int iser_send_command(struct iscsi_conn     *conn,
+int iser_send_command(struct iscsi_conn *conn,
 		      struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
@@ -395,7 +395,7 @@ int iser_send_command(struct iscsi_conn     *conn,
 /**
  * iser_send_data_out - send data out PDU
  */
-int iser_send_data_out(struct iscsi_conn     *conn,
+int iser_send_data_out(struct iscsi_conn *conn,
 		       struct iscsi_cmd_task *ctask,
 		       struct iscsi_data *hdr)
 {
@@ -470,10 +470,11 @@ int iser_send_data_out(struct iscsi_conn     *conn,
 }
 
 int iser_send_control(struct iscsi_conn *conn,
-		      struct iscsi_mgmt_task *mtask)
+		      struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
-	struct iser_desc *mdesc = mtask-&gt;dd_data;
+	struct iscsi_iser_cmd_task *iser_ctask = ctask-&gt;dd_data;
+	struct iser_desc *mdesc = &amp;iser_ctask-&gt;desc;
 	struct iser_dto *send_dto = NULL;
 	unsigned long data_seg_len;
 	int err = 0;
@@ -485,7 +486,7 @@ int iser_send_control(struct iscsi_conn *conn,
 		return -EPERM;
 	}
 
-	if (iser_check_xmit(conn,mtask))
+	if (iser_check_xmit(conn, ctask))
 		return -ENOBUFS;
 
 	/* build the tx desc regd header and add it to the tx desc dto */
@@ -498,14 +499,14 @@ int iser_send_control(struct iscsi_conn *conn,
 
 	iser_reg_single(device, send_dto-&gt;regd[0], DMA_TO_DEVICE);
 
-	data_seg_len = ntoh24(mtask-&gt;hdr-&gt;dlength);
+	data_seg_len = ntoh24(ctask-&gt;hdr-&gt;dlength);
 
 	if (data_seg_len &gt; 0) {
 		regd_buf = &amp;mdesc-&gt;data_regd_buf;
 		memset(regd_buf, 0, sizeof(struct iser_regd_buf));
 		regd_buf-&gt;device = device;
-		regd_buf-&gt;virt_addr = mtask-&gt;data;
-		regd_buf-&gt;data_size = mtask-&gt;data_count;
+		regd_buf-&gt;virt_addr = ctask-&gt;data;
+		regd_buf-&gt;data_size = ctask-&gt;data_count;
 		iser_reg_single(device, regd_buf,
 				DMA_TO_DEVICE);
 		iser_dto_add_regd_buff(send_dto, regd_buf,
@@ -535,7 +536,7 @@ int iser_send_control(struct iscsi_conn *conn,
 void iser_rcv_completion(struct iser_desc *rx_desc,
 			 unsigned long dto_xfer_len)
 {
-	struct iser_dto        *dto = &amp;rx_desc-&gt;dto;
+	struct iser_dto *dto = &amp;rx_desc-&gt;dto;
 	struct iscsi_iser_conn *conn = dto-&gt;ib_conn-&gt;iser_conn;
 	struct iscsi_cmd_task *ctask;
 	struct iscsi_iser_cmd_task *iser_ctask;
@@ -559,7 +560,7 @@ void iser_rcv_completion(struct iser_desc *rx_desc,
 	if (opcode == ISCSI_OP_SCSI_CMD_RSP) {
 		ctask = iscsi_itt_to_ctask(conn-&gt;iscsi_conn, hdr-&gt;itt);
 		if (!ctask)
-			iser_err("itt can't be matched to task!!! "
+			iser_err("itt can't be matched to ctask!!! "
 				 "conn %p opcode %d itt %d\n",
 				 conn-&gt;iscsi_conn, opcode, hdr-&gt;itt);
 		else {
@@ -577,7 +578,7 @@ void iser_rcv_completion(struct iser_desc *rx_desc,
 	kmem_cache_free(ig.desc_cache, rx_desc);
 
 	/* decrementing conn-&gt;post_recv_buf_count only --after-- freeing the   *
-	 * task eliminates the need to worry on tasks which are completed in   *
+	 * ctask eliminates the need to worry on ctasks which are completed in   *
 	 * parallel to the execution of iser_conn_term. So the code that waits *
 	 * for the posted rx bufs refcount to become zero handles everything   */
 	atomic_dec(&amp;conn-&gt;ib_conn-&gt;post_recv_buf_count);
@@ -589,7 +590,7 @@ void iser_snd_completion(struct iser_desc *tx_desc)
 	struct iser_conn       *ib_conn = dto-&gt;ib_conn;
 	struct iscsi_iser_conn *iser_conn = ib_conn-&gt;iser_conn;
 	struct iscsi_conn      *conn = iser_conn-&gt;iscsi_conn;
-	struct iscsi_mgmt_task *mtask;
+	struct iscsi_cmd_task *ctask;
 	int resume_tx = 0;
 
 	iser_dbg("Initiator, Data sent dto=0x%p\n", dto);
@@ -612,15 +613,10 @@ void iser_snd_completion(struct iser_desc *tx_desc)
 
 	if (tx_desc-&gt;type == ISCSI_TX_CONTROL) {
 		/* this arithmetic is legal by libiscsi dd_data allocation */
-		mtask = (void *) ((long)(void *)tx_desc -
-				  sizeof(struct iscsi_mgmt_task));
-		if (mtask-&gt;hdr-&gt;itt == RESERVED_ITT) {
-			struct iscsi_session *session = conn-&gt;session;
-
-			spin_lock(&amp;conn-&gt;session-&gt;lock);
-			iscsi_free_mgmt_task(conn, mtask);
-			spin_unlock(&amp;session-&gt;lock);
-		}
+		ctask = (void *) ((long)(void *)tx_desc -
+				  sizeof(struct iscsi_cmd_task));
+		if (ctask-&gt;hdr-&gt;itt == RESERVED_ITT)
+			iscsi_put_ctask(ctask);
 	}
 }
 </pre><hr><pre>commit fbc514b4e262bc0596faae8640ebc0b9142a1cdd
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:07 2008 -0500

    [SCSI] iscsi_tcp: convert iscsi_tcp to support merged tasks
    
    Convert iscsi_tcp to support merged tasks.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index f2a08f7ed902..517bad160bea 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -498,11 +498,15 @@ iscsi_tcp_data_recv_prep(struct iscsi_tcp_conn *tcp_conn)
  * must be called with session lock
  */
 static void
-iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_tcp_cleanup_task(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_r2t_info *r2t;
 
+	/* nothing to do for mgmt ctasks */
+	if (!ctask-&gt;sc)
+		return;
+
 	/* flush ctask's r2t queues */
 	while (__kfifo_get(tcp_ctask-&gt;r2tqueue, (void*)&amp;r2t, sizeof(void*))) {
 		__kfifo_put(tcp_ctask-&gt;r2tpool.queue, (void*)&amp;r2t,
@@ -521,7 +525,7 @@ iscsi_tcp_cleanup_ctask(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 /**
  * iscsi_data_rsp - SCSI Data-In Response processing
  * @conn: iscsi connection
- * @ctask: scsi command task
+ * @ctask: scsi command ctask
  **/
 static int
 iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
@@ -578,7 +582,7 @@ iscsi_data_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 /**
  * iscsi_solicit_data_init - initialize first Data-Out
  * @conn: iscsi connection
- * @ctask: scsi command task
+ * @ctask: scsi command ctask
  * @r2t: R2T info
  *
  * Notes:
@@ -620,7 +624,7 @@ iscsi_solicit_data_init(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 /**
  * iscsi_r2t_rsp - iSCSI R2T Response processing
  * @conn: iscsi connection
- * @ctask: scsi command task
+ * @ctask: scsi command ctask
  **/
 static int
 iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
@@ -646,7 +650,7 @@ iscsi_r2t_rsp(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		return ISCSI_ERR_R2TSN;
 	}
 
-	/* fill-in new R2T associated with the task */
+	/* fill-in new R2T associated with the ctask */
 	iscsi_update_cmdsn(session, (struct iscsi_nopin*)rhdr);
 
 	if (!ctask-&gt;sc || session-&gt;state != ISCSI_STATE_LOGGED_IN) {
@@ -769,6 +773,8 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 		ctask = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
 		if (!ctask)
 			return ISCSI_ERR_BAD_ITT;
+		if (!ctask-&gt;sc)
+			return ISCSI_ERR_NO_SCSI_CMD;
 
 		spin_lock(&amp;conn-&gt;session-&gt;lock);
 		rc = iscsi_data_rsp(conn, ctask);
@@ -815,6 +821,8 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 		ctask = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
 		if (!ctask)
 			return ISCSI_ERR_BAD_ITT;
+		if (!ctask-&gt;sc)
+			return ISCSI_ERR_NO_SCSI_CMD;
 
 		if (ahslen)
 			rc = ISCSI_ERR_AHSLEN;
@@ -1194,7 +1202,7 @@ iscsi_tcp_send_hdr_prep(struct iscsi_conn *conn, void *hdr, size_t hdrlen)
 
 	/* If header digest is enabled, compute the CRC and
 	 * place the digest into the same buffer. We make
-	 * sure that both iscsi_tcp_ctask and mtask have
+	 * sure that both iscsi_tcp_cmd_task and mctask have
 	 * sufficient room.
 	 */
 	if (conn-&gt;hdrdgst_en) {
@@ -1269,7 +1277,7 @@ iscsi_tcp_send_linear_data_prepare(struct iscsi_conn *conn, void *data,
 /**
  * iscsi_solicit_data_cont - initialize next Data-Out
  * @conn: iscsi connection
- * @ctask: scsi command task
+ * @ctask: scsi command ctask
  * @r2t: R2T info
  * @left: bytes left to transfer
  *
@@ -1316,19 +1324,37 @@ iscsi_solicit_data_cont(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 }
 
 /**
- * iscsi_tcp_ctask - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
+ * iscsi_tcp_task - Initialize iSCSI SCSI_READ or SCSI_WRITE commands
  * @conn: iscsi connection
- * @ctask: scsi command task
+ * @ctask: scsi command ctask
  * @sc: scsi command
  **/
 static int
-iscsi_tcp_ctask_init(struct iscsi_cmd_task *ctask)
+iscsi_tcp_task_init(struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_conn *conn = ctask-&gt;conn;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
 	int err;
 
+	if (!sc) {
+		/*
+		 * mgmt ctasks do not have a scatterlist since they come
+		 * in from the iscsi interface.
+		 */
+		debug_scsi("mctask deq [cid %d itt 0x%x]\n", conn-&gt;id,
+			   ctask-&gt;itt);
+
+		/* Prepare PDU, optionally w/ immediate data */
+		iscsi_tcp_send_hdr_prep(conn, ctask-&gt;hdr, sizeof(*ctask-&gt;hdr));
+
+		/* If we have immediate data, attach a payload */
+		if (ctask-&gt;data_count)
+			iscsi_tcp_send_linear_data_prepare(conn, ctask-&gt;data,
+							   ctask-&gt;data_count);
+		return 0;
+	}
+
 	BUG_ON(__kfifo_len(tcp_ctask-&gt;r2tqueue));
 	tcp_ctask-&gt;sent = 0;
 	tcp_ctask-&gt;exp_datasn = 0;
@@ -1353,52 +1379,21 @@ iscsi_tcp_ctask_init(struct iscsi_cmd_task *ctask)
 	return 0;
 }
 
-/**
- * iscsi_tcp_mtask_xmit - xmit management(immediate) task
- * @conn: iscsi connection
- * @mtask: task management task
- *
- * Notes:
- *	The function can return -EAGAIN in which case caller must
- *	call it again later, or recover. '0' return code means successful
- *	xmit.
- **/
-static int
-iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
-{
-	int rc;
-
-	/* Flush any pending data first. */
-	rc = iscsi_tcp_flush(conn);
-	if (rc &lt; 0)
-		return rc;
-
-	if (mtask-&gt;hdr-&gt;itt == RESERVED_ITT) {
-		struct iscsi_session *session = conn-&gt;session;
-
-		spin_lock_bh(&amp;session-&gt;lock);
-		iscsi_free_mgmt_task(conn, mtask);
-		spin_unlock_bh(&amp;session-&gt;lock);
-	}
-
-	return 0;
-}
-
 /*
- * iscsi_tcp_ctask_xmit - xmit normal PDU task
- * @conn: iscsi connection
- * @ctask: iscsi command task
+ * iscsi_tcp_task_xmit - xmit normal PDU ctask
+ * @ctask: iscsi command ctask
  *
  * We're expected to return 0 when everything was transmitted succesfully,
  * -EAGAIN if there's still data in the queue, or != 0 for any other kind
  * of error.
  */
 static int
-iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
+iscsi_tcp_task_xmit(struct iscsi_cmd_task *ctask)
 {
+	struct iscsi_conn *conn = ctask-&gt;conn;
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
-	struct scsi_data_buffer *sdb = scsi_out(sc);
+	struct scsi_data_buffer *sdb;
 	int rc = 0;
 
 flush:
@@ -1407,10 +1402,18 @@ iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	if (rc &lt; 0)
 		return rc;
 
+	/* mgmt command */
+	if (!sc) {
+		if (ctask-&gt;hdr-&gt;itt == RESERVED_ITT)
+			iscsi_put_ctask(ctask);
+		return 0;
+	}
+
 	/* Are we done already? */
 	if (sc-&gt;sc_data_direction != DMA_TO_DEVICE)
 		return 0;
 
+	sdb = scsi_out(sc);
 	if (ctask-&gt;unsol_count != 0) {
 		struct iscsi_data *hdr = &amp;tcp_ctask-&gt;unsol_dtask.hdr;
 
@@ -1688,21 +1691,6 @@ iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 	return err;
 }
 
-/* called with host lock */
-static void
-iscsi_tcp_mtask_init(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
-{
-	debug_scsi("mtask deq [cid %d itt 0x%x]\n", conn-&gt;id, mtask-&gt;itt);
-
-	/* Prepare PDU, optionally w/ immediate data */
-	iscsi_tcp_send_hdr_prep(conn, mtask-&gt;hdr, sizeof(*mtask-&gt;hdr));
-
-	/* If we have immediate data, attach a payload */
-	if (mtask-&gt;data_count)
-		iscsi_tcp_send_linear_data_prepare(conn, mtask-&gt;data,
-						   mtask-&gt;data_count);
-}
-
 static int
 iscsi_r2tpool_alloc(struct iscsi_session *session)
 {
@@ -1710,7 +1698,7 @@ iscsi_r2tpool_alloc(struct iscsi_session *session)
 	int cmd_i;
 
 	/*
-	 * initialize per-task: R2T pool and xmit queue
+	 * initialize per-ctask: R2T pool and xmit queue
 	 */
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
 	        struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
@@ -1880,13 +1868,12 @@ iscsi_tcp_session_create(struct Scsi_Host *shost, uint16_t cmds_max,
 
 	cls_session = iscsi_session_setup(&amp;iscsi_tcp_transport, shost, cmds_max,
 					  sizeof(struct iscsi_tcp_cmd_task),
-					  sizeof(struct iscsi_tcp_mgmt_task),
 					  initial_cmdsn);
 	if (!cls_session)
 		goto remove_host;
 	session = cls_session-&gt;dd_data;
 
-	shost-&gt;can_queue = session-&gt;cmds_max;
+	shost-&gt;can_queue = session-&gt;scsi_cmds_max;
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
 		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
 		struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
@@ -1895,13 +1882,6 @@ iscsi_tcp_session_create(struct Scsi_Host *shost, uint16_t cmds_max,
 		ctask-&gt;hdr_max = sizeof(tcp_ctask-&gt;hdr) - ISCSI_DIGEST_SIZE;
 	}
 
-	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++) {
-		struct iscsi_mgmt_task *mtask = session-&gt;mgmt_cmds[cmd_i];
-		struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
-
-		mtask-&gt;hdr = (struct iscsi_hdr *) &amp;tcp_mtask-&gt;hdr;
-	}
-
 	if (iscsi_r2tpool_alloc(session))
 		goto remove_session;
 	return cls_session;
@@ -1999,11 +1979,9 @@ static struct iscsi_transport iscsi_tcp_transport = {
 	/* IO */
 	.send_pdu		= iscsi_conn_send_pdu,
 	.get_stats		= iscsi_conn_get_stats,
-	.init_cmd_task		= iscsi_tcp_ctask_init,
-	.init_mgmt_task		= iscsi_tcp_mtask_init,
-	.xmit_cmd_task		= iscsi_tcp_ctask_xmit,
-	.xmit_mgmt_task		= iscsi_tcp_mtask_xmit,
-	.cleanup_cmd_task	= iscsi_tcp_cleanup_ctask,
+	.init_task		= iscsi_tcp_task_init,
+	.xmit_task		= iscsi_tcp_task_xmit,
+	.cleanup_task		= iscsi_tcp_cleanup_task,
 	/* recovery */
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 };
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index ed0b991d1e72..c9c8633c41a6 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -103,11 +103,6 @@ struct iscsi_data_task {
 	char			hdrext[ISCSI_DIGEST_SIZE];/* Header-Digest */
 };
 
-struct iscsi_tcp_mgmt_task {
-	struct iscsi_hdr	hdr;
-	char			hdrext[ISCSI_DIGEST_SIZE]; /* Header-Digest */
-};
-
 struct iscsi_r2t_info {
 	__be32			ttt;		/* copied from R2T */
 	__be32			exp_statsn;	/* copied from R2T */</pre><hr><pre>commit 3e5c28ad0391389959ccae81c938c7533efb3490
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:06 2008 -0500

    [SCSI] libiscsi: merge iscsi_mgmt_task and iscsi_cmd_task
    
    There is no need to have the mgmt and cmd tasks separate
    structs. It used to save a lot of memory when we overprealocated
    memory for tasks, but the next patches will set up the
    driver so in the future they can use a mempool or some other
    common scsi command allocator and common tagging.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 1e605de07cff..ef92b1b0f16e 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -197,7 +197,7 @@ static int iscsi_prep_bidi_ahs(struct iscsi_cmd_task *ctask)
 
 /**
  * iscsi_prep_scsi_cmd_pdu - prep iscsi scsi cmd pdu
- * @ctask: iscsi cmd task
+ * @ctask: iscsi task
  *
  * Prep basic iSCSI PDU fields for a scsi cmd pdu. The LLD should set
  * fields like dlength or final based on how much data it sends
@@ -300,31 +300,31 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_cmd_task *ctask)
 	WARN_ON(hdrlength &gt;= 256);
 	hdr-&gt;hlength = hdrlength &amp; 0xFF;
 
-	if (conn-&gt;session-&gt;tt-&gt;init_cmd_task &amp;&amp;
-	    conn-&gt;session-&gt;tt-&gt;init_cmd_task(ctask))
+	if (conn-&gt;session-&gt;tt-&gt;init_task &amp;&amp;
+	    conn-&gt;session-&gt;tt-&gt;init_task(ctask))
 		return -EIO;
 
 	ctask-&gt;state = ISCSI_TASK_RUNNING;
 	list_move_tail(&amp;ctask-&gt;running, &amp;conn-&gt;run_list);
 
 	conn-&gt;scsicmd_pdus_cnt++;
-	debug_scsi("iscsi prep [%s cid %d sc %p cdb 0x%x itt 0x%x "
-		"len %d bidi_len %d cmdsn %d win %d]\n",
-		scsi_bidi_cmnd(sc) ? "bidirectional" :
-		     sc-&gt;sc_data_direction == DMA_TO_DEVICE ? "write" : "read",
-		conn-&gt;id, sc, sc-&gt;cmnd[0], ctask-&gt;itt,
-		scsi_bufflen(sc), scsi_bidi_cmnd(sc) ? scsi_in(sc)-&gt;length : 0,
-		session-&gt;cmdsn, session-&gt;max_cmdsn - session-&gt;exp_cmdsn + 1);
+	debug_scsi("iscsi prep [%s cid %d sc %p cdb 0x%x itt 0x%x len %d "
+		   "bidi_len %d cmdsn %d win %d]\n", scsi_bidi_cmnd(sc) ?
+		   "bidirectional" : sc-&gt;sc_data_direction == DMA_TO_DEVICE ?
+		   "write" : "read", conn-&gt;id, sc, sc-&gt;cmnd[0], ctask-&gt;itt,
+		   scsi_bufflen(sc),
+		   scsi_bidi_cmnd(sc) ? scsi_in(sc)-&gt;length : 0,
+		   session-&gt;cmdsn, session-&gt;max_cmdsn - session-&gt;exp_cmdsn + 1);
 	return 0;
 }
 
 /**
- * iscsi_complete_command - return command back to scsi-ml
+ * iscsi_complete_command - finish a task
  * @ctask: iscsi cmd task
  *
  * Must be called with session lock.
- * This function returns the scsi command to scsi-ml and returns
- * the cmd task to the pool of available cmd tasks.
+ * This function returns the scsi command to scsi-ml or cleans
+ * up mgmt tasks then returns the task to the pool.
  */
 static void iscsi_complete_command(struct iscsi_cmd_task *ctask)
 {
@@ -332,17 +332,34 @@ static void iscsi_complete_command(struct iscsi_cmd_task *ctask)
 	struct iscsi_session *session = conn-&gt;session;
 	struct scsi_cmnd *sc = ctask-&gt;sc;
 
+	list_del_init(&amp;ctask-&gt;running);
 	ctask-&gt;state = ISCSI_TASK_COMPLETED;
 	ctask-&gt;sc = NULL;
-	/* SCSI eh reuses commands to verify us */
-	sc-&gt;SCp.ptr = NULL;
+
 	if (conn-&gt;ctask == ctask)
 		conn-&gt;ctask = NULL;
-	list_del_init(&amp;ctask-&gt;running);
+	/*
+	 * login ctask is preallocated so do not free
+	 */
+	if (conn-&gt;login_ctask == ctask)
+		return;
+
 	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;ctask, sizeof(void*));
 
-	if (sc-&gt;scsi_done)
-		sc-&gt;scsi_done(sc);
+	if (conn-&gt;ping_ctask == ctask)
+		conn-&gt;ping_ctask = NULL;
+
+	if (sc) {
+		ctask-&gt;sc = NULL;
+		/* SCSI eh reuses commands to verify us */
+		sc-&gt;SCp.ptr = NULL;
+		/*
+		 * queue command may call this to free the task, but
+		 * not have setup the sc callback
+		 */
+		if (sc-&gt;scsi_done)
+			sc-&gt;scsi_done(sc);
+	}
 }
 
 static void __iscsi_get_ctask(struct iscsi_cmd_task *ctask)
@@ -356,6 +373,16 @@ static void __iscsi_put_ctask(struct iscsi_cmd_task *ctask)
 		iscsi_complete_command(ctask);
 }
 
+void iscsi_put_ctask(struct iscsi_cmd_task *ctask)
+{
+	struct iscsi_session *session = ctask-&gt;conn-&gt;session;
+
+	spin_lock_bh(&amp;session-&gt;lock);
+	__iscsi_put_ctask(ctask);
+	spin_unlock_bh(&amp;session-&gt;lock);
+}
+EXPORT_SYMBOL_GPL(iscsi_put_ctask);
+
 /*
  * session lock must be held
  */
@@ -375,47 +402,28 @@ static void fail_command(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask,
 		 */
 		conn-&gt;session-&gt;queued_cmdsn--;
 	else
-		conn-&gt;session-&gt;tt-&gt;cleanup_cmd_task(conn, ctask);
+		conn-&gt;session-&gt;tt-&gt;cleanup_task(conn, ctask);
 
 	sc-&gt;result = err;
+
 	if (!scsi_bidi_cmnd(sc))
 		scsi_set_resid(sc, scsi_bufflen(sc));
 	else {
 		scsi_out(sc)-&gt;resid = scsi_out(sc)-&gt;length;
 		scsi_in(sc)-&gt;resid = scsi_in(sc)-&gt;length;
 	}
+
 	if (conn-&gt;ctask == ctask)
 		conn-&gt;ctask = NULL;
 	/* release ref from queuecommand */
 	__iscsi_put_ctask(ctask);
 }
 
-/**
- * iscsi_free_mgmt_task - return mgmt task back to pool
- * @conn: iscsi connection
- * @mtask: mtask
- *
- * Must be called with session lock.
- */
-void iscsi_free_mgmt_task(struct iscsi_conn *conn,
-			  struct iscsi_mgmt_task *mtask)
-{
-	list_del_init(&amp;mtask-&gt;running);
-	if (conn-&gt;login_mtask == mtask)
-		return;
-
-	if (conn-&gt;ping_mtask == mtask)
-		conn-&gt;ping_mtask = NULL;
-	__kfifo_put(conn-&gt;session-&gt;mgmtpool.queue,
-		    (void*)&amp;mtask, sizeof(void*));
-}
-EXPORT_SYMBOL_GPL(iscsi_free_mgmt_task);
-
-static int iscsi_prep_mtask(struct iscsi_conn *conn,
-			    struct iscsi_mgmt_task *mtask)
+static int iscsi_prep_mgmt_task(struct iscsi_conn *conn,
+				struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_hdr *hdr = mtask-&gt;hdr;
+	struct iscsi_hdr *hdr = (struct iscsi_hdr *)ctask-&gt;hdr;
 	struct iscsi_nopout *nop = (struct iscsi_nopout *)hdr;
 
 	if (conn-&gt;session-&gt;state == ISCSI_STATE_LOGGING_OUT)
@@ -429,7 +437,7 @@ static int iscsi_prep_mtask(struct iscsi_conn *conn,
 	 */
 	nop-&gt;cmdsn = cpu_to_be32(session-&gt;cmdsn);
 	if (hdr-&gt;itt != RESERVED_ITT) {
-		hdr-&gt;itt = build_itt(mtask-&gt;itt, session-&gt;age);
+		hdr-&gt;itt = build_itt(ctask-&gt;itt, session-&gt;age);
 		/*
 		 * TODO: We always use immediate, so we never hit this.
 		 * If we start to send tmfs or nops as non-immediate then
@@ -442,25 +450,25 @@ static int iscsi_prep_mtask(struct iscsi_conn *conn,
 		}
 	}
 
-	if (session-&gt;tt-&gt;init_mgmt_task)
-		session-&gt;tt-&gt;init_mgmt_task(conn, mtask);
+	if (session-&gt;tt-&gt;init_task)
+		session-&gt;tt-&gt;init_task(ctask);
 
 	if ((hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) == ISCSI_OP_LOGOUT)
 		session-&gt;state = ISCSI_STATE_LOGGING_OUT;
 
-	list_move_tail(&amp;mtask-&gt;running, &amp;conn-&gt;mgmt_run_list);
+	list_move_tail(&amp;ctask-&gt;running, &amp;conn-&gt;mgmt_run_list);
 	debug_scsi("mgmtpdu [op 0x%x hdr-&gt;itt 0x%x datalen %d]\n",
 		   hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, hdr-&gt;itt,
-		   mtask-&gt;data_count);
+		   ctask-&gt;data_count);
 	return 0;
 }
 
-static struct iscsi_mgmt_task *
+static struct iscsi_cmd_task *
 __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		      char *data, uint32_t data_size)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_mgmt_task *mtask;
+	struct iscsi_cmd_task *ctask;
 
 	if (session-&gt;state == ISCSI_STATE_TERMINATE)
 		return NULL;
@@ -470,48 +478,56 @@ __iscsi_conn_send_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		/*
 		 * Login and Text are sent serially, in
 		 * request-followed-by-response sequence.
-		 * Same mtask can be used. Same ITT must be used.
-		 * Note that login_mtask is preallocated at conn_create().
+		 * Same task can be used. Same ITT must be used.
+		 * Note that login_task is preallocated at conn_create().
 		 */
-		mtask = conn-&gt;login_mtask;
+		ctask = conn-&gt;login_ctask;
 	else {
 		BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
 		BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
 
-		if (!__kfifo_get(session-&gt;mgmtpool.queue,
-				 (void*)&amp;mtask, sizeof(void*)))
+		if (!__kfifo_get(session-&gt;cmdpool.queue,
+				 (void*)&amp;ctask, sizeof(void*)))
 			return NULL;
 
 		if ((hdr-&gt;opcode == (ISCSI_OP_NOOP_OUT | ISCSI_OP_IMMEDIATE)) &amp;&amp;
 		     hdr-&gt;ttt == RESERVED_ITT) {
-			conn-&gt;ping_mtask = mtask;
+			conn-&gt;ping_ctask = ctask;
 			conn-&gt;last_ping = jiffies;
 		}
 	}
+	/*
+	 * released in complete pdu for task we expect a response for, and
+	 * released by the lld when it has transmitted the task for
+	 * pdus we do not expect a response for.
+	 */
+	atomic_set(&amp;ctask-&gt;refcount, 1);
+	ctask-&gt;conn = conn;
+	ctask-&gt;sc = NULL;
 
 	if (data_size) {
-		memcpy(mtask-&gt;data, data, data_size);
-		mtask-&gt;data_count = data_size;
+		memcpy(ctask-&gt;data, data, data_size);
+		ctask-&gt;data_count = data_size;
 	} else
-		mtask-&gt;data_count = 0;
+		ctask-&gt;data_count = 0;
 
-	memcpy(mtask-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
-	INIT_LIST_HEAD(&amp;mtask-&gt;running);
-	list_add_tail(&amp;mtask-&gt;running, &amp;conn-&gt;mgmtqueue);
+	memcpy(ctask-&gt;hdr, hdr, sizeof(struct iscsi_hdr));
+	INIT_LIST_HEAD(&amp;ctask-&gt;running);
+	list_add_tail(&amp;ctask-&gt;running, &amp;conn-&gt;mgmtqueue);
 
 	if (session-&gt;tt-&gt;caps &amp; CAP_DATA_PATH_OFFLOAD) {
-		if (iscsi_prep_mtask(conn, mtask)) {
-			iscsi_free_mgmt_task(conn, mtask);
+		if (iscsi_prep_mgmt_task(conn, ctask)) {
+			__iscsi_put_ctask(ctask);
 			return NULL;
 		}
 
-		if (session-&gt;tt-&gt;xmit_mgmt_task(conn, mtask))
-			mtask = NULL;
+		if (session-&gt;tt-&gt;xmit_task(ctask))
+			ctask = NULL;
 
 	} else
 		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 
-	return mtask;
+	return ctask;
 }
 
 int iscsi_conn_send_pdu(struct iscsi_cls_conn *cls_conn, struct iscsi_hdr *hdr,
@@ -538,7 +554,7 @@ EXPORT_SYMBOL_GPL(iscsi_conn_send_pdu);
  * @datalen: len of buffer
  *
  * iscsi_cmd_rsp sets up the scsi_cmnd fields based on the PDU and
- * then completes the command and task.
+ * then completes the command and ctask.
  **/
 static void iscsi_scsi_cmd_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 			       struct iscsi_cmd_task *ctask, char *data,
@@ -634,9 +650,9 @@ static void iscsi_tmf_rsp(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 static void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)
 {
         struct iscsi_nopout hdr;
-	struct iscsi_mgmt_task *mtask;
+	struct iscsi_cmd_task *ctask;
 
-	if (!rhdr &amp;&amp; conn-&gt;ping_mtask)
+	if (!rhdr &amp;&amp; conn-&gt;ping_ctask)
 		return;
 
 	memset(&amp;hdr, 0, sizeof(struct iscsi_nopout));
@@ -650,8 +666,8 @@ static void iscsi_send_nopout(struct iscsi_conn *conn, struct iscsi_nopin *rhdr)
 	} else
 		hdr.ttt = RESERVED_ITT;
 
-	mtask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)&amp;hdr, NULL, 0);
-	if (!mtask)
+	ctask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)&amp;hdr, NULL, 0);
+	if (!ctask)
 		iscsi_conn_printk(KERN_ERR, conn, "Could not send nopout\n");
 }
 
@@ -697,7 +713,6 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	struct iscsi_session *session = conn-&gt;session;
 	int opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, rc = 0;
 	struct iscsi_cmd_task *ctask;
-	struct iscsi_mgmt_task *mtask;
 	uint32_t itt;
 
 	conn-&gt;last_recv = jiffies;
@@ -710,93 +725,10 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	else
 		itt = ~0U;
 
-	if (itt &lt; session-&gt;cmds_max) {
-		ctask = session-&gt;cmds[itt];
-
-		debug_scsi("cmdrsp [op 0x%x cid %d itt 0x%x len %d]\n",
-			   opcode, conn-&gt;id, ctask-&gt;itt, datalen);
-
-		switch(opcode) {
-		case ISCSI_OP_SCSI_CMD_RSP:
-			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
-			iscsi_scsi_cmd_rsp(conn, hdr, ctask, data,
-					   datalen);
-			break;
-		case ISCSI_OP_SCSI_DATA_IN:
-			BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
-			if (hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
-				conn-&gt;scsirsp_pdus_cnt++;
-				__iscsi_put_ctask(ctask);
-			}
-			break;
-		case ISCSI_OP_R2T:
-			/* LLD handles this for now */
-			break;
-		default:
-			rc = ISCSI_ERR_BAD_OPCODE;
-			break;
-		}
-	} else if (itt &gt;= ISCSI_MGMT_ITT_OFFSET &amp;&amp;
-		   itt &lt; ISCSI_MGMT_ITT_OFFSET + session-&gt;mgmtpool_max) {
-		mtask = session-&gt;mgmt_cmds[itt - ISCSI_MGMT_ITT_OFFSET];
-
-		debug_scsi("immrsp [op 0x%x cid %d itt 0x%x len %d]\n",
-			   opcode, conn-&gt;id, mtask-&gt;itt, datalen);
+	debug_scsi("[op 0x%x cid %d itt 0x%x len %d]\n",
+		   opcode, conn-&gt;id, itt, datalen);
 
-		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
-		switch(opcode) {
-		case ISCSI_OP_LOGOUT_RSP:
-			if (datalen) {
-				rc = ISCSI_ERR_PROTO;
-				break;
-			}
-			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
-			/* fall through */
-		case ISCSI_OP_LOGIN_RSP:
-		case ISCSI_OP_TEXT_RSP:
-			/*
-			 * login related PDU's exp_statsn is handled in
-			 * userspace
-			 */
-			if (iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen))
-				rc = ISCSI_ERR_CONN_FAILED;
-			iscsi_free_mgmt_task(conn, mtask);
-			break;
-		case ISCSI_OP_SCSI_TMFUNC_RSP:
-			if (datalen) {
-				rc = ISCSI_ERR_PROTO;
-				break;
-			}
-
-			iscsi_tmf_rsp(conn, hdr);
-			iscsi_free_mgmt_task(conn, mtask);
-			break;
-		case ISCSI_OP_NOOP_IN:
-			if (hdr-&gt;ttt != cpu_to_be32(ISCSI_RESERVED_TAG) ||
-			    datalen) {
-				rc = ISCSI_ERR_PROTO;
-				break;
-			}
-			conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
-
-			if (conn-&gt;ping_mtask != mtask) {
-				/*
-				 * If this is not in response to one of our
-				 * nops then it must be from userspace.
-				 */
-				if (iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data,
-						   datalen))
-					rc = ISCSI_ERR_CONN_FAILED;
-			} else
-				mod_timer(&amp;conn-&gt;transport_timer,
-					  jiffies + conn-&gt;recv_timeout);
-			iscsi_free_mgmt_task(conn, mtask);
-			break;
-		default:
-			rc = ISCSI_ERR_BAD_OPCODE;
-			break;
-		}
-	} else if (itt == ~0U) {
+	if (itt == ~0U) {
 		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
 
 		switch(opcode) {
@@ -823,9 +755,88 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 			rc = ISCSI_ERR_BAD_OPCODE;
 			break;
 		}
-	} else
-		rc = ISCSI_ERR_BAD_ITT;
+		goto out;
+	}
+
+	ctask = session-&gt;cmds[itt];
+	switch(opcode) {
+	case ISCSI_OP_SCSI_CMD_RSP:
+		if (!ctask-&gt;sc) {
+			rc = ISCSI_ERR_NO_SCSI_CMD;
+			break;
+		}
+		BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
+		iscsi_scsi_cmd_rsp(conn, hdr, ctask, data, datalen);
+		break;
+	case ISCSI_OP_SCSI_DATA_IN:
+		if (!ctask-&gt;sc) {
+			rc = ISCSI_ERR_NO_SCSI_CMD;
+			break;
+		}
+		BUG_ON((void*)ctask != ctask-&gt;sc-&gt;SCp.ptr);
+		if (hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
+			conn-&gt;scsirsp_pdus_cnt++;
+			iscsi_update_cmdsn(session,
+					   (struct iscsi_nopin*) hdr);
+			__iscsi_put_ctask(ctask);
+		}
+		break;
+	case ISCSI_OP_R2T:
+		/* LLD handles this for now */
+		break;
+	case ISCSI_OP_LOGOUT_RSP:
+		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
+		if (datalen) {
+			rc = ISCSI_ERR_PROTO;
+			break;
+		}
+		conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+		goto recv_pdu;
+	case ISCSI_OP_LOGIN_RSP:
+	case ISCSI_OP_TEXT_RSP:
+		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
+		/*
+		 * login related PDU's exp_statsn is handled in
+		 * userspace
+		 */
+		goto recv_pdu;
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
+		if (datalen) {
+			rc = ISCSI_ERR_PROTO;
+			break;
+		}
+
+		iscsi_tmf_rsp(conn, hdr);
+		__iscsi_put_ctask(ctask);
+		break;
+	case ISCSI_OP_NOOP_IN:
+		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
+		if (hdr-&gt;ttt != cpu_to_be32(ISCSI_RESERVED_TAG) || datalen) {
+			rc = ISCSI_ERR_PROTO;
+			break;
+		}
+		conn-&gt;exp_statsn = be32_to_cpu(hdr-&gt;statsn) + 1;
+
+		if (conn-&gt;ping_ctask != ctask)
+			/*
+			 * If this is not in response to one of our
+			 * nops then it must be from userspace.
+			 */
+			goto recv_pdu;
+		__iscsi_put_ctask(ctask);
+		break;
+	default:
+		rc = ISCSI_ERR_BAD_OPCODE;
+		break;
+	}
 
+out:
+	return rc;
+recv_pdu:
+	if (iscsi_recv_pdu(conn-&gt;cls_conn, hdr, data, datalen))
+		rc = ISCSI_ERR_CONN_FAILED;
+	__iscsi_put_ctask(ctask);
 	return rc;
 }
 
@@ -845,6 +856,7 @@ int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 {
 	struct iscsi_session *session = conn-&gt;session;
 	struct iscsi_cmd_task *ctask;
+	uint32_t i;
 
 	if (itt == RESERVED_ITT)
 		return 0;
@@ -858,25 +870,22 @@ int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 		return ISCSI_ERR_BAD_ITT;
 	}
 
-	if (itt &lt; session-&gt;cmds_max) {
-		ctask = session-&gt;cmds[itt];
-
-		if (!ctask-&gt;sc) {
-			iscsi_conn_printk(KERN_INFO, conn, "dropping ctask "
-					  "with itt 0x%x\n", ctask-&gt;itt);
-			/* force drop */
-			return ISCSI_ERR_NO_SCSI_CMD;
-		}
-
-		if (ctask-&gt;sc-&gt;SCp.phase != session-&gt;age) {
-			iscsi_conn_printk(KERN_ERR, conn,
-					  "iscsi: ctask's session age %d, "
-					  "expected %d\n", ctask-&gt;sc-&gt;SCp.phase,
-					  session-&gt;age);
-			return ISCSI_ERR_SESSION_FAILED;
-		}
+	i = get_itt(itt);
+	if (i &gt;= session-&gt;cmds_max) {
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "received invalid itt index %u (max cmds "
+				   "%u.\n", i, session-&gt;cmds_max);
+		return ISCSI_ERR_BAD_ITT;
 	}
 
+	ctask = session-&gt;cmds[i];
+	if (ctask-&gt;sc &amp;&amp; ctask-&gt;sc-&gt;SCp.phase != session-&gt;age) {
+		iscsi_conn_printk(KERN_ERR, conn,
+				  "iscsi: ctask's session age %d, "
+				  "expected %d\n", ctask-&gt;sc-&gt;SCp.phase,
+				  session-&gt;age);
+		return ISCSI_ERR_SESSION_FAILED;
+	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iscsi_verify_itt);
@@ -929,20 +938,6 @@ void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_failure);
 
-static int iscsi_xmit_mtask(struct iscsi_conn *conn)
-{
-	int rc;
-
-	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-	rc = conn-&gt;session-&gt;tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask);
-	spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-	if (rc)
-		return rc;
-	/* done with this in-progress mtask */
-	conn-&gt;mtask = NULL;
-	return 0;
-}
-
 static int iscsi_check_cmdsn_window_closed(struct iscsi_conn *conn)
 {
 	struct iscsi_session *session = conn-&gt;session;
@@ -967,7 +962,7 @@ static int iscsi_xmit_ctask(struct iscsi_conn *conn)
 
 	__iscsi_get_ctask(ctask);
 	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-	rc = conn-&gt;session-&gt;tt-&gt;xmit_cmd_task(conn, ctask);
+	rc = conn-&gt;session-&gt;tt-&gt;xmit_task(ctask);
 	spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
 	__iscsi_put_ctask(ctask);
 	if (!rc)
@@ -1015,12 +1010,6 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 
 	if (conn-&gt;ctask) {
 		rc = iscsi_xmit_ctask(conn);
-		if (rc)
-			goto again;
-	}
-
-	if (conn-&gt;mtask) {
-		rc = iscsi_xmit_mtask(conn);
 	        if (rc)
 		        goto again;
 	}
@@ -1032,14 +1021,14 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 	 */
 check_mgmt:
 	while (!list_empty(&amp;conn-&gt;mgmtqueue)) {
-		conn-&gt;mtask = list_entry(conn-&gt;mgmtqueue.next,
-					 struct iscsi_mgmt_task, running);
-		if (iscsi_prep_mtask(conn, conn-&gt;mtask)) {
-			iscsi_free_mgmt_task(conn, conn-&gt;mtask);
-			conn-&gt;mtask = NULL;
+		conn-&gt;ctask = list_entry(conn-&gt;mgmtqueue.next,
+					 struct iscsi_cmd_task, running);
+		if (iscsi_prep_mgmt_task(conn, conn-&gt;ctask)) {
+			__iscsi_put_ctask(conn-&gt;ctask);
+			conn-&gt;ctask = NULL;
 			continue;
 		}
-		rc = iscsi_xmit_mtask(conn);
+		rc = iscsi_xmit_ctask(conn);
 		if (rc)
 			goto again;
 	}
@@ -1224,7 +1213,7 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 			iscsi_complete_command(ctask);
 			goto fault;
 		}
-		if (session-&gt;tt-&gt;xmit_cmd_task(conn, ctask)) {
+		if (session-&gt;tt-&gt;xmit_task(ctask)) {
 			sc-&gt;scsi_done = NULL;
 			iscsi_complete_command(ctask);
 			reason = FAILURE_SESSION_NOT_READY;
@@ -1347,16 +1336,16 @@ static void iscsi_tmf_timedout(unsigned long data)
 	spin_unlock(&amp;session-&gt;lock);
 }
 
-static int iscsi_exec_task_mgmt_fn(struct iscsi_conn *conn,
+static int iscsi_exec_ctask_mgmt_fn(struct iscsi_conn *conn,
 				   struct iscsi_tm *hdr, int age,
 				   int timeout)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_mgmt_task *mtask;
+	struct iscsi_cmd_task *ctask;
 
-	mtask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)hdr,
+	ctask = __iscsi_conn_send_pdu(conn, (struct iscsi_hdr *)hdr,
 				      NULL, 0);
-	if (!mtask) {
+	if (!ctask) {
 		spin_unlock_bh(&amp;session-&gt;lock);
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
 		spin_lock_bh(&amp;session-&gt;lock);
@@ -1390,7 +1379,7 @@ static int iscsi_exec_task_mgmt_fn(struct iscsi_conn *conn,
 
 	mutex_lock(&amp;session-&gt;eh_mutex);
 	spin_lock_bh(&amp;session-&gt;lock);
-	/* if the session drops it will clean up the mtask */
+	/* if the session drops it will clean up the ctask */
 	if (age != session-&gt;age ||
 	    session-&gt;state != ISCSI_STATE_LOGGED_IN)
 		return -ENOTCONN;
@@ -1497,7 +1486,7 @@ static enum scsi_eh_timer_return iscsi_eh_cmd_timed_out(struct scsi_cmnd *scmd)
 			   jiffies))
 		rc = EH_RESET_TIMER;
 	/* if in the middle of checking the transport then give us more time */
-	if (conn-&gt;ping_mtask)
+	if (conn-&gt;ping_ctask)
 		rc = EH_RESET_TIMER;
 done:
 	spin_unlock(&amp;session-&gt;lock);
@@ -1521,7 +1510,7 @@ static void iscsi_check_transport_timeouts(unsigned long data)
 
 	recv_timeout *= HZ;
 	last_recv = conn-&gt;last_recv;
-	if (conn-&gt;ping_mtask &amp;&amp;
+	if (conn-&gt;ping_ctask &amp;&amp;
 	    time_before_eq(conn-&gt;last_ping + (conn-&gt;ping_timeout * HZ),
 			   jiffies)) {
 		iscsi_conn_printk(KERN_ERR, conn, "ping timeout of %d secs "
@@ -1547,7 +1536,7 @@ static void iscsi_check_transport_timeouts(unsigned long data)
 	spin_unlock(&amp;session-&gt;lock);
 }
 
-static void iscsi_prep_abort_task_pdu(struct iscsi_cmd_task *ctask,
+static void iscsi_prep_abort_ctask_pdu(struct iscsi_cmd_task *ctask,
 				      struct iscsi_tm *hdr)
 {
 	memset(hdr, 0, sizeof(*hdr));
@@ -1619,9 +1608,9 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	conn-&gt;tmf_state = TMF_QUEUED;
 
 	hdr = &amp;conn-&gt;tmhdr;
-	iscsi_prep_abort_task_pdu(ctask, hdr);
+	iscsi_prep_abort_ctask_pdu(ctask, hdr);
 
-	if (iscsi_exec_task_mgmt_fn(conn, hdr, age, session-&gt;abort_timeout)) {
+	if (iscsi_exec_ctask_mgmt_fn(conn, hdr, age, session-&gt;abort_timeout)) {
 		rc = FAILED;
 		goto failed;
 	}
@@ -1631,7 +1620,7 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 		spin_unlock_bh(&amp;session-&gt;lock);
 		iscsi_suspend_tx(conn);
 		/*
-		 * clean up task if aborted. grab the recv lock as a writer
+		 * clean up ctask if aborted. grab the recv lock as a writer
 		 */
 		write_lock_bh(conn-&gt;recv_lock);
 		spin_lock(&amp;session-&gt;lock);
@@ -1716,7 +1705,7 @@ int iscsi_eh_device_reset(struct scsi_cmnd *sc)
 	hdr = &amp;conn-&gt;tmhdr;
 	iscsi_prep_lun_reset_pdu(sc, hdr);
 
-	if (iscsi_exec_task_mgmt_fn(conn, hdr, session-&gt;age,
+	if (iscsi_exec_ctask_mgmt_fn(conn, hdr, session-&gt;age,
 				    session-&gt;lu_reset_timeout)) {
 		rc = FAILED;
 		goto unlock;
@@ -1897,8 +1886,7 @@ EXPORT_SYMBOL_GPL(iscsi_host_free);
  * @iscsit: iscsi transport template
  * @shost: scsi host
  * @cmds_max: session can queue
- * @cmd_task_size: LLD ctask private data size
- * @mgmt_task_size: LLD mtask private data size
+ * @cmd_ctask_size: LLD ctask private data size
  * @initial_cmdsn: initial CmdSN
  *
  * This can be used by software iscsi_transports that allocate
@@ -1906,22 +1894,26 @@ EXPORT_SYMBOL_GPL(iscsi_host_free);
  */
 struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
-		    uint16_t cmds_max, int cmd_task_size, int mgmt_task_size,
+		    uint16_t scsi_cmds_max, int cmd_ctask_size,
 		    uint32_t initial_cmdsn)
 {
 	struct iscsi_session *session;
 	struct iscsi_cls_session *cls_session;
-	int cmd_i;
+	int cmd_i, cmds_max;
 
-	if (!is_power_of_2(cmds_max) || cmds_max &gt;= ISCSI_MGMT_ITT_OFFSET ||
-	    cmds_max &lt; 2) {
-		if (cmds_max != 0)
-			printk(KERN_ERR "iscsi: invalid can_queue of %d. "
-			       "can_queue must be a power of 2 and between "
-			       "2 and %d - setting to %d.\n", cmds_max,
-			       ISCSI_MGMT_ITT_OFFSET, ISCSI_DEF_XMIT_CMDS_MAX);
-		cmds_max = ISCSI_DEF_XMIT_CMDS_MAX;
+	/*
+	 * The iscsi layer needs some ctasks for nop handling and tmfs.
+	 */
+	if (scsi_cmds_max &lt; 1)
+		scsi_cmds_max = ISCSI_MGMT_CMDS_MAX;
+	if ((scsi_cmds_max + ISCSI_MGMT_CMDS_MAX) &gt;= ISCSI_MGMT_ITT_OFFSET) {
+		printk(KERN_ERR "iscsi: invalid can_queue of %d. "
+		       "can_queue must be less than %d.\n",
+		       scsi_cmds_max,
+		       ISCSI_MGMT_ITT_OFFSET - ISCSI_MGMT_CMDS_MAX);
+		scsi_cmds_max = ISCSI_DEF_XMIT_CMDS_MAX;
 	}
+	cmds_max = roundup_pow_of_two(scsi_cmds_max + ISCSI_MGMT_CMDS_MAX);
 
 	cls_session = iscsi_alloc_session(shost, iscsit,
 					  sizeof(struct iscsi_session));
@@ -1934,7 +1926,7 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 	session-&gt;fast_abort = 1;
 	session-&gt;lu_reset_timeout = 15;
 	session-&gt;abort_timeout = 10;
-	session-&gt;mgmtpool_max = ISCSI_MGMT_CMDS_MAX;
+	session-&gt;scsi_cmds_max = scsi_cmds_max;
 	session-&gt;cmds_max = cmds_max;
 	session-&gt;queued_cmdsn = session-&gt;cmdsn = initial_cmdsn;
 	session-&gt;exp_cmdsn = initial_cmdsn + 1;
@@ -1947,36 +1939,19 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 	/* initialize SCSI PDU commands pool */
 	if (iscsi_pool_init(&amp;session-&gt;cmdpool, session-&gt;cmds_max,
 			    (void***)&amp;session-&gt;cmds,
-			    cmd_task_size + sizeof(struct iscsi_cmd_task)))
+			    cmd_ctask_size + sizeof(struct iscsi_cmd_task)))
 		goto cmdpool_alloc_fail;
 
 	/* pre-format cmds pool with ITT */
 	for (cmd_i = 0; cmd_i &lt; session-&gt;cmds_max; cmd_i++) {
 		struct iscsi_cmd_task *ctask = session-&gt;cmds[cmd_i];
 
-		if (cmd_task_size)
+		if (cmd_ctask_size)
 			ctask-&gt;dd_data = &amp;ctask[1];
 		ctask-&gt;itt = cmd_i;
 		INIT_LIST_HEAD(&amp;ctask-&gt;running);
 	}
 
-	/* initialize immediate command pool */
-	if (iscsi_pool_init(&amp;session-&gt;mgmtpool, session-&gt;mgmtpool_max,
-			   (void***)&amp;session-&gt;mgmt_cmds,
-			   mgmt_task_size + sizeof(struct iscsi_mgmt_task)))
-		goto mgmtpool_alloc_fail;
-
-
-	/* pre-format immediate cmds pool with ITT */
-	for (cmd_i = 0; cmd_i &lt; session-&gt;mgmtpool_max; cmd_i++) {
-		struct iscsi_mgmt_task *mtask = session-&gt;mgmt_cmds[cmd_i];
-
-		if (mgmt_task_size)
-			mtask-&gt;dd_data = &amp;mtask[1];
-		mtask-&gt;itt = ISCSI_MGMT_ITT_OFFSET + cmd_i;
-		INIT_LIST_HEAD(&amp;mtask-&gt;running);
-	}
-
 	if (!try_module_get(iscsit-&gt;owner))
 		goto module_get_fail;
 
@@ -1987,8 +1962,6 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 cls_session_fail:
 	module_put(iscsit-&gt;owner);
 module_get_fail:
-	iscsi_pool_free(&amp;session-&gt;mgmtpool);
-mgmtpool_alloc_fail:
 	iscsi_pool_free(&amp;session-&gt;cmdpool);
 cmdpool_alloc_fail:
 	iscsi_free_session(cls_session);
@@ -2008,7 +1981,6 @@ void iscsi_session_teardown(struct iscsi_cls_session *cls_session)
 	struct iscsi_session *session = cls_session-&gt;dd_data;
 	struct module *owner = cls_session-&gt;transport-&gt;owner;
 
-	iscsi_pool_free(&amp;session-&gt;mgmtpool);
 	iscsi_pool_free(&amp;session-&gt;cmdpool);
 
 	kfree(session-&gt;password);
@@ -2063,30 +2035,30 @@ iscsi_conn_setup(struct iscsi_cls_session *cls_session, int dd_size,
 	INIT_LIST_HEAD(&amp;conn-&gt;requeue);
 	INIT_WORK(&amp;conn-&gt;xmitwork, iscsi_xmitworker);
 
-	/* allocate login_mtask used for the login/text sequences */
+	/* allocate login_ctask used for the login/text sequences */
 	spin_lock_bh(&amp;session-&gt;lock);
-	if (!__kfifo_get(session-&gt;mgmtpool.queue,
-                         (void*)&amp;conn-&gt;login_mtask,
+	if (!__kfifo_get(session-&gt;cmdpool.queue,
+                         (void*)&amp;conn-&gt;login_ctask,
 			 sizeof(void*))) {
 		spin_unlock_bh(&amp;session-&gt;lock);
-		goto login_mtask_alloc_fail;
+		goto login_ctask_alloc_fail;
 	}
 	spin_unlock_bh(&amp;session-&gt;lock);
 
 	data = kmalloc(ISCSI_DEF_MAX_RECV_SEG_LEN, GFP_KERNEL);
 	if (!data)
-		goto login_mtask_data_alloc_fail;
-	conn-&gt;login_mtask-&gt;data = conn-&gt;data = data;
+		goto login_ctask_data_alloc_fail;
+	conn-&gt;login_ctask-&gt;data = conn-&gt;data = data;
 
 	init_timer(&amp;conn-&gt;tmf_timer);
 	init_waitqueue_head(&amp;conn-&gt;ehwait);
 
 	return cls_conn;
 
-login_mtask_data_alloc_fail:
-	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
+login_ctask_data_alloc_fail:
+	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;conn-&gt;login_ctask,
 		    sizeof(void*));
-login_mtask_alloc_fail:
+login_ctask_alloc_fail:
 	iscsi_destroy_conn(cls_conn);
 	return NULL;
 }
@@ -2146,7 +2118,7 @@ void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
 	spin_lock_bh(&amp;session-&gt;lock);
 	kfree(conn-&gt;data);
 	kfree(conn-&gt;persistent_address);
-	__kfifo_put(session-&gt;mgmtpool.queue, (void*)&amp;conn-&gt;login_mtask,
+	__kfifo_put(session-&gt;cmdpool.queue, (void*)&amp;conn-&gt;login_ctask,
 		    sizeof(void*));
 	if (session-&gt;leadconn == conn)
 		session-&gt;leadconn = NULL;
@@ -2227,21 +2199,23 @@ EXPORT_SYMBOL_GPL(iscsi_conn_start);
 static void
 flush_control_queues(struct iscsi_session *session, struct iscsi_conn *conn)
 {
-	struct iscsi_mgmt_task *mtask, *tmp;
+	struct iscsi_cmd_task *ctask, *tmp;
 
 	/* handle pending */
-	list_for_each_entry_safe(mtask, tmp, &amp;conn-&gt;mgmtqueue, running) {
-		debug_scsi("flushing pending mgmt task itt 0x%x\n", mtask-&gt;itt);
-		iscsi_free_mgmt_task(conn, mtask);
+	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;mgmtqueue, running) {
+		debug_scsi("flushing pending mgmt ctask itt 0x%x\n", ctask-&gt;itt);
+		/* release ref from prep ctask */
+		__iscsi_put_ctask(ctask);
 	}
 
 	/* handle running */
-	list_for_each_entry_safe(mtask, tmp, &amp;conn-&gt;mgmt_run_list, running) {
-		debug_scsi("flushing running mgmt task itt 0x%x\n", mtask-&gt;itt);
-		iscsi_free_mgmt_task(conn, mtask);
+	list_for_each_entry_safe(ctask, tmp, &amp;conn-&gt;mgmt_run_list, running) {
+		debug_scsi("flushing running mgmt ctask itt 0x%x\n", ctask-&gt;itt);
+		/* release ref from prep ctask */
+		__iscsi_put_ctask(ctask);
 	}
 
-	conn-&gt;mtask = NULL;
+	conn-&gt;ctask = NULL;
 }
 
 static void iscsi_start_session_recovery(struct iscsi_session *session,
@@ -2272,7 +2246,7 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 
 	/*
 	 * When this is called for the in_login state, we only want to clean
-	 * up the login task and connection. We do not need to block and set
+	 * up the login ctask and connection. We do not need to block and set
 	 * the recovery state again
 	 */
 	if (flag == STOP_CONN_TERM)
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 9be6a70faff5..d1c36759b350 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -85,18 +85,6 @@ enum {
 	ISCSI_DIGEST_SIZE = sizeof(__u32),
 };
 
-struct iscsi_mgmt_task {
-	/*
-	 * Becuae LLDs allocate their hdr differently, this is a pointer to
-	 * that storage. It must be setup at session creation time.
-	 */
-	struct iscsi_hdr	*hdr;
-	char			*data;		/* mgmt payload */
-	unsigned		data_count;	/* counts data to be sent */
-	uint32_t		itt;		/* this ITT */
-	void			*dd_data;	/* driver/transport data */
-	struct list_head	running;
-};
 
 enum {
 	ISCSI_TASK_COMPLETED,
@@ -121,6 +109,7 @@ struct iscsi_cmd_task {
 	/* offset in unsolicited stream (bytes); */
 	unsigned		unsol_offset;
 	unsigned		data_count;	/* remaining Data-Out */
+	char			*data;		/* mgmt payload */
 	struct scsi_cmnd	*sc;		/* associated SCSI cmd*/
 	struct iscsi_conn	*conn;		/* used connection    */
 
@@ -162,7 +151,7 @@ struct iscsi_conn {
 	unsigned long		last_ping;
 	int			ping_timeout;
 	int			recv_timeout;
-	struct iscsi_mgmt_task	*ping_mtask;
+	struct iscsi_cmd_task 	*ping_ctask;
 
 	/* iSCSI connection-wide sequencing */
 	uint32_t		exp_statsn;
@@ -178,9 +167,8 @@ struct iscsi_conn {
 	 * should always fit in this buffer
 	 */
 	char			*data;
-	struct iscsi_mgmt_task	*login_mtask;	/* mtask used for login/text */
-	struct iscsi_mgmt_task	*mtask;		/* xmit mtask in progress */
-	struct iscsi_cmd_task	*ctask;		/* xmit ctask in progress */
+	struct iscsi_cmd_task 	*login_ctask;	/* mtask used for login/text */
+	struct iscsi_cmd_task	*ctask;		/* xmit task in progress */
 
 	/* xmit */
 	struct list_head	mgmtqueue;	/* mgmt (control) xmit queue */
@@ -295,12 +283,10 @@ struct iscsi_session {
 	int			state;		/* session state           */
 	int			age;		/* counts session re-opens */
 
+	int			scsi_cmds_max; 	/* max scsi commands */
 	int			cmds_max;	/* size of cmds array */
 	struct iscsi_cmd_task	**cmds;		/* Original Cmds arr */
 	struct iscsi_pool	cmdpool;	/* PDU's pool */
-	int			mgmtpool_max;	/* size of mgmt array */
-	struct iscsi_mgmt_task	**mgmt_cmds;	/* Original mgmt arr */
-	struct iscsi_pool	mgmtpool;	/* Mgmt PDU's pool */
 };
 
 struct iscsi_host {
@@ -345,7 +331,7 @@ extern void iscsi_host_free(struct Scsi_Host *shost);
  */
 extern struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *, struct Scsi_Host *shost,
-		    uint16_t, int, int, uint32_t);
+		    uint16_t, int, uint32_t);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
@@ -388,8 +374,7 @@ extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
 extern struct iscsi_cmd_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_ctask(struct iscsi_cmd_task *ctask);
-extern void iscsi_free_mgmt_task(struct iscsi_conn *conn,
-				 struct iscsi_mgmt_task *mtask);
+extern void iscsi_put_ctask(struct iscsi_cmd_task *ctask);
 
 /*
  * generic helpers
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 4028f121d548..3f24503dfdf9 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -34,7 +34,6 @@ struct Scsi_Host;
 struct iscsi_cls_conn;
 struct iscsi_conn;
 struct iscsi_cmd_task;
-struct iscsi_mgmt_task;
 struct sockaddr;
 
 /**
@@ -58,19 +57,22 @@ struct sockaddr;
  * @stop_conn:		suspend/recover/terminate connection
  * @send_pdu:		send iSCSI PDU, Login, Logout, NOP-Out, Reject, Text.
  * @session_recovery_timedout: notify LLD a block during recovery timed out
- * @init_cmd_task:	Initialize a iscsi_cmd_task and any internal structs.
- *			Called from queuecommand with session lock held.
- * @init_mgmt_task:	Initialize a iscsi_mgmt_task and any internal structs.
- *			Called from iscsi_conn_send_generic with xmitmutex.
- * @xmit_cmd_task:	Requests LLD to transfer cmd task. Returns 0 or the
+ * @init_task:		Initialize a iscsi_task and any internal structs.
+ *			When offloading the data path, this is called from
+ *			queuecommand with the session lock, or from the
+ *			iscsi_conn_send_pdu context with the session lock.
+ *			When not offloading the data path, this is called
+ *			from the scsi work queue without the session lock.
+ * @xmit_task		Requests LLD to transfer cmd task. Returns 0 or the
  *			the number of bytes transferred on success, and -Exyz
- *			value on error.
- * @xmit_mgmt_task:	Requests LLD to transfer mgmt task. Returns 0 or the
- *			the number of bytes transferred on success, and -Exyz
- *			value on error.
- * @cleanup_cmd_task:	requests LLD to fail cmd task. Called with xmitmutex
- *			and session-&gt;lock after the connection has been
- *			suspended and terminated during recovery. If called
+ *			value on error. When offloading the data path, this
+ *			is called from queuecommand with the session lock, or
+ *			from the iscsi_conn_send_pdu context with the session
+ *			lock. When not offloading the data path, this is called
+ *			from the scsi work queue without the session lock.
+ * @cleanup_task:	requests LLD to fail task. Called with session lock
+ *			and after the connection has been suspended and
+ *			terminated during recovery. If called
  *			from abort task then connection is not suspended
  *			or terminated but sk_callback_lock is held
  *
@@ -110,15 +112,10 @@ struct iscsi_transport {
 			 char *data, uint32_t data_size);
 	void (*get_stats) (struct iscsi_cls_conn *conn,
 			   struct iscsi_stats *stats);
-	int (*init_cmd_task) (struct iscsi_cmd_task *ctask);
-	void (*init_mgmt_task) (struct iscsi_conn *conn,
-				struct iscsi_mgmt_task *mtask);
-	int (*xmit_cmd_task) (struct iscsi_conn *conn,
-			      struct iscsi_cmd_task *ctask);
-	void (*cleanup_cmd_task) (struct iscsi_conn *conn,
-				  struct iscsi_cmd_task *ctask);
-	int (*xmit_mgmt_task) (struct iscsi_conn *conn,
-			       struct iscsi_mgmt_task *mtask);
+	int (*init_task) (struct iscsi_cmd_task *task);
+	int (*xmit_task) (struct iscsi_cmd_task *task);
+	void (*cleanup_task) (struct iscsi_conn *conn,
+				  struct iscsi_cmd_task *task);
 	void (*session_recovery_timedout) (struct iscsi_cls_session *session);
 	int (*ep_connect) (struct sockaddr *dst_addr, int non_blocking,
 			   uint64_t *ep_handle);</pre>
    <div class="pagination">
        <a href='5_24.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><span>[25]</span><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_26.html'>Next&gt;&gt;</a>
    <div>
</body>
