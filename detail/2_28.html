<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_27.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><span>[28]</span><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_29.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 93c9bf4d1838d5851a18ca398b0ad66397f05056
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 31 14:49:47 2014 -0400

    usb-storage: handle a skipped data phase
    
    Sometimes mass-storage devices using the Bulk-only transport will
    mistakenly skip the data phase of a command.  Rather than sending the
    data expected by the host or sending a zero-length packet, they go
    directly to the status phase and send the CSW.
    
    This causes problems for usb-storage, for obvious reasons.  The driver
    will interpret the CSW as a short data transfer and will wait to
    receive a CSW.  The device won't have anything left to send, so the
    command eventually times out.
    
    The SCSI layer doesn't retry commands after they time out (this is a
    relatively recent change).  Therefore we should do our best to detect
    a skipped data phase and handle it promptly.
    
    This patch adds code to do that.  If usb-storage receives a short
    13-byte data transfer from the device, and if the first four bytes of
    the data match the CSW signature, the driver will set the residue to
    the full transfer length and interpret the data as a CSW.
    
    This fixes Bugzilla #86611.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Tested-by: Paul Osmialowski &lt;newchief@king.net.pl&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 22c7d4360fa2..b1d815eb6d0b 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -1118,6 +1118,31 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 		 */
 		if (result == USB_STOR_XFER_LONG)
 			fake_sense = 1;
+
+		/*
+		 * Sometimes a device will mistakenly skip the data phase
+		 * and go directly to the status phase without sending a
+		 * zero-length packet.  If we get a 13-byte response here,
+		 * check whether it really is a CSW.
+		 */
+		if (result == USB_STOR_XFER_SHORT &amp;&amp;
+				srb-&gt;sc_data_direction == DMA_FROM_DEVICE &amp;&amp;
+				transfer_length - scsi_get_resid(srb) ==
+					US_BULK_CS_WRAP_LEN) {
+			struct scatterlist *sg = NULL;
+			unsigned int offset = 0;
+
+			if (usb_stor_access_xfer_buf((unsigned char *) bcs,
+					US_BULK_CS_WRAP_LEN, srb, &amp;sg,
+					&amp;offset, FROM_XFER_BUF) ==
+						US_BULK_CS_WRAP_LEN &amp;&amp;
+					bcs-&gt;Signature ==
+						cpu_to_le32(US_BULK_CS_SIGN)) {
+				usb_stor_dbg(us, "Device skipped data phase\n");
+				scsi_set_resid(srb, transfer_length);
+				goto skipped_data_phase;
+			}
+		}
 	}
 
 	/* See flow chart on pg 15 of the Bulk Only Transport spec for
@@ -1153,6 +1178,7 @@ int usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
+ skipped_data_phase:
 	/* check bulk status */
 	residue = le32_to_cpu(bcs-&gt;Residue);
 	usb_stor_dbg(us, "Bulk Status S 0x%x T 0x%x R %u Stat 0x%x\n",</pre><hr><pre>commit 7312b5ddd47fee2356baa78c5516ef8e04eed452
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 17 11:23:54 2014 -0400

    USB: EHCI: unlink QHs even after the controller has stopped
    
    Old code in ehci-hcd tries to expedite disabling endpoints after the
    controller has stopped, by destroying the endpoint's associated QH
    without first unlinking the QH.  This was necessary back when the
    driver wasn't so careful about keeping track of the controller's
    state.
    
    But now we are careful about it, and the driver knows that when the
    controller isn't running, no unlinking delay is needed.  Furthermore,
    skipping the unlink step will trigger a BUG() in qh_destroy() when the
    preceding QH is released, because the link pointer will be non-NULL.
    
    Removing the lines that skip the unlinking step and go directly to
    QH_STATE_IDLE fixes the problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Joe Lawrence &lt;joe.lawrence@stratus.com&gt;
    Tested-by: Joe Lawrence &lt;joe.lawrence@stratus.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 81cda09b47e3..488a30836c36 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -965,8 +965,6 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	}
 
 	qh-&gt;exception = 1;
-	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
-		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
 	case QH_STATE_LINKED:
 		WARN_ON(!list_empty(&amp;qh-&gt;qtd_list));</pre><hr><pre>commit 50c4e96411a6cd728f04cf70d8d6def57828b320
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 2 11:35:50 2014 -0400

    scsi: don't store LUN bits in CDB[1] for USB mass-storage devices
    
    The SCSI specification requires that the second Command Data Byte
    should contain the LUN value in its high-order bits if the recipient
    device reports SCSI level 2 or below.  Nevertheless, some USB
    mass-storage devices use those bits for other purposes in
    vendor-specific commands.  Currently Linux has no way to send such
    commands, because the SCSI stack always overwrites the LUN bits.
    
    Testing shows that Windows 7 and XP do not store the LUN bits in the
    CDB when sending commands to a USB device.  This doesn't matter if the
    device uses the Bulk-Only or UAS transports (which virtually all
    modern USB mass-storage devices do), as these have a separate
    mechanism for sending the LUN value.
    
    Therefore this patch introduces a flag in the Scsi_Host structure to
    inform the SCSI midlayer that a transport does not require the LUN
    bits to be stored in the CDB, and it makes usb-storage set this flag
    for all devices using the Bulk-Only transport.  (UAS is handled by a
    separate driver, but it doesn't really matter because no SCSI-2 or
    lower device is at all likely to use UAS.)
    
    The patch also cleans up the code responsible for storing the LUN
    value by adding a bitflag to the scsi_device structure.  The test for
    whether to stick the LUN value in the CDB can be made when the device
    is probed, and stored for future use rather than being made over and
    over in the fast path.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Tiziano Bacocco &lt;tiziano.bacocco@gmail.com&gt;
    Acked-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;
    Acked-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    Signed-off-by: Christoph Hellwig &lt;hch@lst.de&gt;

diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index d81f3cc43ff1..1423cb17fbfd 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -670,14 +670,10 @@ int scsi_dispatch_cmd(struct scsi_cmnd *cmd)
 		return SCSI_MLQUEUE_DEVICE_BUSY;
 	}
 
-	/*
-	 * If SCSI-2 or lower, store the LUN value in cmnd.
-	 */
-	if (cmd-&gt;device-&gt;scsi_level &lt;= SCSI_2 &amp;&amp;
-	    cmd-&gt;device-&gt;scsi_level != SCSI_UNKNOWN) {
+	/* Store the LUN value in cmnd, if needed. */
+	if (cmd-&gt;device-&gt;lun_in_cdb)
 		cmd-&gt;cmnd[1] = (cmd-&gt;cmnd[1] &amp; 0x1f) |
 			       (cmd-&gt;device-&gt;lun &lt;&lt; 5 &amp; 0xe0);
-	}
 
 	scsi_log_send(cmd);
 
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 56675dbbf681..f84c40188478 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -736,6 +736,16 @@ static int scsi_probe_lun(struct scsi_device *sdev, unsigned char *inq_result,
 		sdev-&gt;scsi_level++;
 	sdev-&gt;sdev_target-&gt;scsi_level = sdev-&gt;scsi_level;
 
+	/*
+	 * If SCSI-2 or lower, and if the transport requires it,
+	 * store the LUN value in CDB[1].
+	 */
+	sdev-&gt;lun_in_cdb = 0;
+	if (sdev-&gt;scsi_level &lt;= SCSI_2 &amp;&amp;
+	    sdev-&gt;scsi_level != SCSI_UNKNOWN &amp;&amp;
+	    !sdev-&gt;host-&gt;no_scsi2_lun_in_cdb)
+		sdev-&gt;lun_in_cdb = 1;
+
 	return 0;
 }
 
diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
index 8b4105a22ac2..85e36f3a5585 100644
--- a/drivers/scsi/scsi_sysfs.c
+++ b/drivers/scsi/scsi_sysfs.c
@@ -1263,7 +1263,19 @@ void scsi_sysfs_device_initialize(struct scsi_device *sdev)
 	sdev-&gt;sdev_dev.class = &amp;sdev_class;
 	dev_set_name(&amp;sdev-&gt;sdev_dev, "%d:%d:%d:%llu",
 		     sdev-&gt;host-&gt;host_no, sdev-&gt;channel, sdev-&gt;id, sdev-&gt;lun);
+	/*
+	 * Get a default scsi_level from the target (derived from sibling
+	 * devices).  This is the best we can do for guessing how to set
+	 * sdev-&gt;lun_in_cdb for the initial INQUIRY command.  For LUN 0 the
+	 * setting doesn't matter, because all the bits are zero anyway.
+	 * But it does matter for higher LUNs.
+	 */
 	sdev-&gt;scsi_level = starget-&gt;scsi_level;
+	if (sdev-&gt;scsi_level &lt;= SCSI_2 &amp;&amp;
+			sdev-&gt;scsi_level != SCSI_UNKNOWN &amp;&amp;
+			!shost-&gt;no_scsi2_lun_in_cdb)
+		sdev-&gt;lun_in_cdb = 1;
+
 	transport_setup_device(&amp;sdev-&gt;sdev_gendev);
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	list_add_tail(&amp;sdev-&gt;same_target_siblings, &amp;starget-&gt;devices);
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index cedb29252a92..bf3f8e2de046 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -983,6 +983,14 @@ int usb_stor_probe2(struct us_data *us)
 	if (!(us-&gt;fflags &amp; US_FL_SCM_MULT_TARG))
 		us_to_host(us)-&gt;max_id = 1;
 
+	/*
+	 * Like Windows, we won't store the LUN bits in CDB[1] for SCSI-2
+	 * devices using the Bulk-Only transport (even though this violates
+	 * the SCSI spec).
+	 */
+	if (us-&gt;transport == usb_stor_Bulk_transport)
+		us_to_host(us)-&gt;no_scsi2_lun_in_cdb = 1;
+
 	/* Find the endpoints and calculate pipe values */
 	result = get_pipes(us);
 	if (result)
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index 1a0d1842962e..27ecee73bd72 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -174,6 +174,7 @@ struct scsi_device {
 	unsigned wce_default_on:1;	/* Cache is ON by default */
 	unsigned no_dif:1;	/* T10 PI (DIF) should be disabled */
 	unsigned broken_fua:1;		/* Don't set FUA bit */
+	unsigned lun_in_cdb:1;		/* Store LUN bits in CDB[1] */
 
 	atomic_t disk_events_disable_depth; /* disable depth for disk events */
 
diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
index cafb260ef2d3..d0f69a3210df 100644
--- a/include/scsi/scsi_host.h
+++ b/include/scsi/scsi_host.h
@@ -693,6 +693,9 @@ struct Scsi_Host {
 	 */
 	struct workqueue_struct *tmf_work_q;
 
+	/* The transport requires the LUN bits NOT to be stored in CDB[1] */
+	unsigned no_scsi2_lun_in_cdb:1;
+
 	/*
 	 * Value host_blocked counts down from
 	 */</pre><hr><pre>commit df35c7c912fe668797681842b3b74c61b0664050
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 9 11:50:58 2014 -0400

    Block: fix unbalanced bypass-disable in blk_register_queue
    
    When a queue is registered, the block layer turns off the bypass
    setting (because bypass is enabled when the queue is created).  This
    doesn't work well for queues that are unregistered and then registered
    again; we get a WARNING because of the unbalanced calls to
    blk_queue_bypass_end().
    
    This patch fixes the problem by making blk_register_queue() call
    blk_queue_bypass_end() only the first time the queue is registered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Tejun Heo &lt;tj@kernel.org&gt;
    CC: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;
    CC: Jens Axboe &lt;axboe@kernel.dk&gt;
    Signed-off-by: Jens Axboe &lt;axboe@fb.com&gt;

diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c
index 4db5abf96b9e..17f5c84ce7bf 100644
--- a/block/blk-sysfs.c
+++ b/block/blk-sysfs.c
@@ -554,8 +554,10 @@ int blk_register_queue(struct gendisk *disk)
 	 * Initialization must be complete by now.  Finish the initial
 	 * bypass from queue allocation.
 	 */
-	queue_flag_set_unlocked(QUEUE_FLAG_INIT_DONE, q);
-	blk_queue_bypass_end(q);
+	if (!blk_queue_init_done(q)) {
+		queue_flag_set_unlocked(QUEUE_FLAG_INIT_DONE, q);
+		blk_queue_bypass_end(q);
+	}
 
 	ret = blk_trace_init_sysfs(dev);
 	if (ret)</pre><hr><pre>commit b6089f19fe0cec625b5963a851a07c3e412c27c8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 2 15:42:18 2014 -0400

    USB: document the 'u' flag for usb-storage quirks parameter
    
    Commit d24d481b7d36 (usb-storage: Modify and export adjust_quirks so
    that it can be used by uas) added the 'u' flag to the quirks module
    parameter for usb-storage, but neglected to update the
    documentation.  This patch adds the documentation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;  # 3.15+
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 5ae8608ca9f5..10d51c2f10d7 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -3541,6 +3541,7 @@ bytes respectively. Such letter suffixes can also be entirely omitted.
 					bogus residue values);
 				s = SINGLE_LUN (the device has only one
 					Logical Unit);
+				u = IGNORE_UAS (don't bind to the uas driver);
 				w = NO_WP_DETECT (don't test whether the
 					medium is write-protected).
 			Example: quirks=0419:aaf5:rl,0421:0433:rc</pre><hr><pre>commit 8f507ef522d55a6e2f9e11a1c1163a92756da044
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 2 11:39:15 2014 -0400

    HID: usbhid: improve handling of Clear-Halt and reset
    
    This patch changes the way usbhid carries out Clear-Halt and reset.
    
    Currently, after a Clear-Halt on the interrupt-IN endpoint, the driver
    immediately restarts the interrupt URB, even if the Clear-Halt failed.
    This doesn't work out well when the reason for the failure was that
    the device was disconnected (when a low- or full-speed device is
    connected through a hub to an EHCI controller, transfer errors caused
    by disconnection are reported as stalls by the hub).  Instead now the
    driver will attempt a reset after a failed Clear-Halt.
    
    The way resets are carried out is also changed.  Now the driver will
    call usb_queue_reset_device() instead of calling usb_reset_device()
    directly.  This avoids a deadlock that would arise when a device is
    unplugged: The hid_reset() routine runs as a workqueue item, a reset
    attempt after the device has been unplugged will fail, failure will
    cause usbhid to be unbound, and the disconnect routine will try to do
    cancel_work_sync().  The usb_queue_reset_device() implementation is
    carefully written to handle scenarios like this one properly.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 79cf503e37bf..80c50763b3f8 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -116,40 +116,24 @@ static void hid_reset(struct work_struct *work)
 	struct usbhid_device *usbhid =
 		container_of(work, struct usbhid_device, reset_work);
 	struct hid_device *hid = usbhid-&gt;hid;
-	int rc = 0;
+	int rc;
 
 	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl)) {
 		dev_dbg(&amp;usbhid-&gt;intf-&gt;dev, "clear halt\n");
 		rc = usb_clear_halt(hid_to_usb_dev(hid), usbhid-&gt;urbin-&gt;pipe);
 		clear_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl);
-		hid_start_in(hid);
-	}
-
-	else if (test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)) {
-		dev_dbg(&amp;usbhid-&gt;intf-&gt;dev, "resetting device\n");
-		rc = usb_lock_device_for_reset(hid_to_usb_dev(hid), usbhid-&gt;intf);
 		if (rc == 0) {
-			rc = usb_reset_device(hid_to_usb_dev(hid));
-			usb_unlock_device(hid_to_usb_dev(hid));
+			hid_start_in(hid);
+		} else {
+			dev_dbg(&amp;usbhid-&gt;intf-&gt;dev,
+					"clear-halt failed: %d\n", rc);
+			set_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl);
 		}
-		clear_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl);
 	}
 
-	switch (rc) {
-	case 0:
-		if (!test_bit(HID_IN_RUNNING, &amp;usbhid-&gt;iofl))
-			hid_io_error(hid);
-		break;
-	default:
-		hid_err(hid, "can't reset device, %s-%s/input%d, status %d\n",
-			hid_to_usb_dev(hid)-&gt;bus-&gt;bus_name,
-			hid_to_usb_dev(hid)-&gt;devpath,
-			usbhid-&gt;ifnum, rc);
-		/* FALLTHROUGH */
-	case -EHOSTUNREACH:
-	case -ENODEV:
-	case -EINTR:
-		break;
+	if (test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl)) {
+		dev_dbg(&amp;usbhid-&gt;intf-&gt;dev, "resetting device\n");
+		usb_queue_reset_device(usbhid-&gt;intf);
 	}
 }
 </pre><hr><pre>commit 499b3803d3e2f062f73bf22372b38393369ffcbf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:26:17 2014 -0400

    USB: OHCI: add check for stopped frame counter
    
    This patch adds an extra check to ohci-hcd's I/O watchdog routine.  If
    the controller stops updating the frame counter, we will assume it is
    dead.  But there has to be an exception: Some controllers stop the
    frame counter when no ports are connected.  Check to make sure there
    is at least one active port before deciding the controller is dead.
    
    (This test may appear racy, but it isn't.  Enabling a newly connected
    port takes several milliseconds, during which time the frame counter
    must advance.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Dennis New &lt;dennisn@dennisn.linuxd.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index aba8f19eae4d..46987735a2e3 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -72,7 +72,7 @@
 static const char	hcd_name [] = "ohci_hcd";
 
 #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
-#define IO_WATCHDOG_DELAY	msecs_to_jiffies(250)
+#define	IO_WATCHDOG_DELAY	msecs_to_jiffies(250)
 
 #include "ohci.h"
 #include "pci-quirks.h"
@@ -230,9 +230,11 @@ static int ohci_urb_enqueue (
 
 		/* Start up the I/O watchdog timer, if it's not running */
 		if (!timer_pending(&amp;ohci-&gt;io_watchdog) &amp;&amp;
-				list_empty(&amp;ohci-&gt;eds_in_use))
+				list_empty(&amp;ohci-&gt;eds_in_use)) {
+			ohci-&gt;prev_frame_no = ohci_frame_no(ohci);
 			mod_timer(&amp;ohci-&gt;io_watchdog,
 					jiffies + IO_WATCHDOG_DELAY);
+		}
 		list_add(&amp;ed-&gt;in_use_list, &amp;ohci-&gt;eds_in_use);
 
 		if (ed-&gt;type == PIPE_ISOCHRONOUS) {
@@ -727,6 +729,7 @@ static void io_watchdog_func(unsigned long _ohci)
 	u32		head;
 	struct ed	*ed;
 	struct td	*td, *td_start, *td_next;
+	unsigned	frame_no;
 	unsigned long	flags;
 
 	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
@@ -742,6 +745,7 @@ static void io_watchdog_func(unsigned long _ohci)
 	if (!(status &amp; OHCI_INTR_WDH) &amp;&amp; ohci-&gt;wdh_cnt == ohci-&gt;prev_wdh_cnt) {
 		if (ohci-&gt;prev_donehead) {
 			ohci_err(ohci, "HcDoneHead not written back; disabled\n");
+ died:
 			usb_hc_died(ohci_to_hcd(ohci));
 			ohci_dump(ohci);
 			ohci_shutdown(ohci_to_hcd(ohci));
@@ -802,7 +806,35 @@ static void io_watchdog_func(unsigned long _ohci)
 	ohci_work(ohci);
 
 	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
+
+		/*
+		 * Sometimes a controller just stops working.  We can tell
+		 * by checking that the frame counter has advanced since
+		 * the last time we ran.
+		 *
+		 * But be careful: Some controllers violate the spec by
+		 * stopping their frame counter when no ports are active.
+		 */
+		frame_no = ohci_frame_no(ohci);
+		if (frame_no == ohci-&gt;prev_frame_no) {
+			int		active_cnt = 0;
+			int		i;
+			unsigned	tmp;
+
+			for (i = 0; i &lt; ohci-&gt;num_ports; ++i) {
+				tmp = roothub_portstatus(ohci, i);
+				/* Enabled and not suspended? */
+				if ((tmp &amp; RH_PS_PES) &amp;&amp; !(tmp &amp; RH_PS_PSS))
+					++active_cnt;
+			}
+
+			if (active_cnt &gt; 0) {
+				ohci_err(ohci, "frame counter not updating; disabled\n");
+				goto died;
+			}
+		}
 		if (!list_empty(&amp;ohci-&gt;eds_in_use)) {
+			ohci-&gt;prev_frame_no = frame_no;
 			ohci-&gt;prev_wdh_cnt = ohci-&gt;wdh_cnt;
 			ohci-&gt;prev_donehead = ohci_readl(ohci,
 					&amp;ohci-&gt;regs-&gt;donehead);
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 0548f5ca18e2..59f424567a8d 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -421,6 +421,7 @@ struct ohci_hcd {
 
 	// there are also chip quirks/bugs in init logic
 
+	unsigned		prev_frame_no;
 	unsigned		wdh_cnt, prev_wdh_cnt;
 	u32			prev_donehead;
 	struct timer_list	io_watchdog;</pre><hr><pre>commit 81e38333513cec155c720432226dabe9f9f76a77
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:26:12 2014 -0400

    USB: OHCI: add I/O watchdog for orphan TDs
    
    Some OHCI controllers have a bug: They fail to add completed TDs to
    the done queue.  Examining this queue is the only method ohci-hcd has
    for telling when a transfer is complete; failure to add a TD can
    result in an URB that never completes and cannot be unlinked.
    
    This patch adds a watchdog routine to ohci-hcd.  The routine
    periodically scans the active ED and TD lists, looking for TDs which
    are finished but not on the done queue.  When one is found, and it is
    certain that the controller hardware will never add the TD to the done
    queue, the watchdog routine manually puts the TD on the done list so
    that it can be handled normally.
    
    The watchdog routine also checks for a condition indicating the
    controller has died.  If the done queue is non-empty but the
    HccaDoneHead pointer hasn't been updated for a few hundred
    milliseconds, we assume the controller will never update it and
    therefore is dead.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index ad588538e2e7..aba8f19eae4d 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -72,12 +72,14 @@
 static const char	hcd_name [] = "ohci_hcd";
 
 #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
+#define IO_WATCHDOG_DELAY	msecs_to_jiffies(250)
 
 #include "ohci.h"
 #include "pci-quirks.h"
 
 static void ohci_dump(struct ohci_hcd *ohci);
 static void ohci_stop(struct usb_hcd *hcd);
+static void io_watchdog_func(unsigned long _ohci);
 
 #include "ohci-hub.c"
 #include "ohci-dbg.c"
@@ -225,6 +227,14 @@ static int ohci_urb_enqueue (
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 			goto fail;
 		}
+
+		/* Start up the I/O watchdog timer, if it's not running */
+		if (!timer_pending(&amp;ohci-&gt;io_watchdog) &amp;&amp;
+				list_empty(&amp;ohci-&gt;eds_in_use))
+			mod_timer(&amp;ohci-&gt;io_watchdog,
+					jiffies + IO_WATCHDOG_DELAY);
+		list_add(&amp;ed-&gt;in_use_list, &amp;ohci-&gt;eds_in_use);
+
 		if (ed-&gt;type == PIPE_ISOCHRONOUS) {
 			u16	frame = ohci_frame_no(ohci);
 
@@ -416,6 +426,7 @@ ohci_shutdown (struct usb_hcd *hcd)
 	udelay(10);
 
 	ohci_writel(ohci, ohci-&gt;fminterval, &amp;ohci-&gt;regs-&gt;fminterval);
+	ohci-&gt;rh_state = OHCI_RH_HALTED;
 }
 
 /*-------------------------------------------------------------------------*
@@ -484,6 +495,10 @@ static int ohci_init (struct ohci_hcd *ohci)
 	if (ohci-&gt;hcca)
 		return 0;
 
+	setup_timer(&amp;ohci-&gt;io_watchdog, io_watchdog_func,
+			(unsigned long) ohci);
+	set_timer_slack(&amp;ohci-&gt;io_watchdog, msecs_to_jiffies(20));
+
 	ohci-&gt;hcca = dma_alloc_coherent (hcd-&gt;self.controller,
 			sizeof(*ohci-&gt;hcca), &amp;ohci-&gt;hcca_dma, GFP_KERNEL);
 	if (!ohci-&gt;hcca)
@@ -694,6 +709,112 @@ static int ohci_start(struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * Some OHCI controllers are known to lose track of completed TDs.  They
+ * don't add the TDs to the hardware done queue, which means we never see
+ * them as being completed.
+ *
+ * This watchdog routine checks for such problems.  Without some way to
+ * tell when those TDs have completed, we would never take their EDs off
+ * the unlink list.  As a result, URBs could never be dequeued and
+ * endpoints could never be released.
+ */
+static void io_watchdog_func(unsigned long _ohci)
+{
+	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
+	bool		takeback_all_pending = false;
+	u32		status;
+	u32		head;
+	struct ed	*ed;
+	struct td	*td, *td_start, *td_next;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
+
+	/*
+	 * One way to lose track of completed TDs is if the controller
+	 * never writes back the done queue head.  If it hasn't been
+	 * written back since the last time this function ran and if it
+	 * was non-empty at that time, something is badly wrong with the
+	 * hardware.
+	 */
+	status = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus);
+	if (!(status &amp; OHCI_INTR_WDH) &amp;&amp; ohci-&gt;wdh_cnt == ohci-&gt;prev_wdh_cnt) {
+		if (ohci-&gt;prev_donehead) {
+			ohci_err(ohci, "HcDoneHead not written back; disabled\n");
+			usb_hc_died(ohci_to_hcd(ohci));
+			ohci_dump(ohci);
+			ohci_shutdown(ohci_to_hcd(ohci));
+			goto done;
+		} else {
+			/* No write back because the done queue was empty */
+			takeback_all_pending = true;
+		}
+	}
+
+	/* Check every ED which might have pending TDs */
+	list_for_each_entry(ed, &amp;ohci-&gt;eds_in_use, in_use_list) {
+		if (ed-&gt;pending_td) {
+			if (takeback_all_pending ||
+					OKAY_TO_TAKEBACK(ohci, ed)) {
+				unsigned tmp = hc32_to_cpu(ohci, ed-&gt;hwINFO);
+
+				ohci_dbg(ohci, "takeback pending TD for dev %d ep 0x%x\n",
+						0x007f &amp; tmp,
+						(0x000f &amp; (tmp &gt;&gt; 7)) +
+							((tmp &amp; ED_IN) &gt;&gt; 5));
+				add_to_done_list(ohci, ed-&gt;pending_td);
+			}
+		}
+
+		/* Starting from the latest pending TD, */
+		td = ed-&gt;pending_td;
+
+		/* or the last TD on the done list, */
+		if (!td) {
+			list_for_each_entry(td_next, &amp;ed-&gt;td_list, td_list) {
+				if (!td_next-&gt;next_dl_td)
+					break;
+				td = td_next;
+			}
+		}
+
+		/* find the last TD processed by the controller. */
+		head = hc32_to_cpu(ohci, ACCESS_ONCE(ed-&gt;hwHeadP)) &amp; TD_MASK;
+		td_start = td;
+		td_next = list_prepare_entry(td, &amp;ed-&gt;td_list, td_list);
+		list_for_each_entry_continue(td_next, &amp;ed-&gt;td_list, td_list) {
+			if (head == (u32) td_next-&gt;td_dma)
+				break;
+			td = td_next;	/* head pointer has passed this TD */
+		}
+		if (td != td_start) {
+			/*
+			 * In case a WDH cycle is in progress, we will wait
+			 * for the next two cycles to complete before assuming
+			 * this TD will never get on the done queue.
+			 */
+			ed-&gt;takeback_wdh_cnt = ohci-&gt;wdh_cnt + 2;
+			ed-&gt;pending_td = td;
+		}
+	}
+
+	ohci_work(ohci);
+
+	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
+		if (!list_empty(&amp;ohci-&gt;eds_in_use)) {
+			ohci-&gt;prev_wdh_cnt = ohci-&gt;wdh_cnt;
+			ohci-&gt;prev_donehead = ohci_readl(ohci,
+					&amp;ohci-&gt;regs-&gt;donehead);
+			mod_timer(&amp;ohci-&gt;io_watchdog,
+					jiffies + IO_WATCHDOG_DELAY);
+		}
+	}
+
+ done:
+	spin_unlock_irqrestore(&amp;ohci-&gt;lock, flags);
+}
+
 /* an interrupt happens */
 
 static irqreturn_t ohci_irq (struct usb_hcd *hcd)
@@ -796,6 +917,9 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 
 	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 		ohci_writel (ohci, ints, &amp;regs-&gt;intrstatus);
+		if (ints &amp; OHCI_INTR_WDH)
+			++ohci-&gt;wdh_cnt;
+
 		ohci_writel (ohci, OHCI_INTR_MIE, &amp;regs-&gt;intrenable);
 		// flush those writes
 		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
@@ -815,6 +939,7 @@ static void ohci_stop (struct usb_hcd *hcd)
 
 	if (quirk_nec(ohci))
 		flush_work(&amp;ohci-&gt;nec_work);
+	del_timer_sync(&amp;ohci-&gt;io_watchdog);
 
 	ohci_writel (ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrdisable);
 	ohci_usb_reset(ohci);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 8991692bcfb8..17d32b0ea565 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -309,6 +309,9 @@ static int ohci_bus_suspend (struct usb_hcd *hcd)
 	else
 		rc = ohci_rh_suspend (ohci, 0);
 	spin_unlock_irq (&amp;ohci-&gt;lock);
+
+	if (rc == 0)
+		del_timer_sync(&amp;ohci-&gt;io_watchdog);
 	return rc;
 }
 
diff --git a/drivers/usb/host/ohci-mem.c b/drivers/usb/host/ohci-mem.c
index 2f20d3dc895b..c9e315c6808a 100644
--- a/drivers/usb/host/ohci-mem.c
+++ b/drivers/usb/host/ohci-mem.c
@@ -28,6 +28,7 @@ static void ohci_hcd_init (struct ohci_hcd *ohci)
 	ohci-&gt;next_statechange = jiffies;
 	spin_lock_init (&amp;ohci-&gt;lock);
 	INIT_LIST_HEAD (&amp;ohci-&gt;pending);
+	INIT_LIST_HEAD(&amp;ohci-&gt;eds_in_use);
 }
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 1974ddc68e45..1463c398d322 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -921,6 +921,11 @@ static void add_to_done_list(struct ohci_hcd *ohci, struct td *td)
 	 * that td is on the done list.
 	 */
 	ohci-&gt;dl_end = td-&gt;next_dl_td = td;
+
+	/* Did we just add the latest pending TD? */
+	td2 = ed-&gt;pending_td;
+	if (td2 &amp;&amp; td2-&gt;next_dl_td)
+		ed-&gt;pending_td = NULL;
 }
 
 /* Get the entries on the hardware done queue and put them on our list */
@@ -1082,6 +1087,7 @@ static void finish_unlinks(struct ohci_hcd *ohci)
 		if (list_empty(&amp;ed-&gt;td_list)) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
+			list_del(&amp;ed-&gt;in_use_list);
 		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index ef348c2e1e4b..0548f5ca18e2 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -47,6 +47,7 @@ struct ed {
 	struct ed		*ed_next;	/* on schedule or rm_list */
 	struct ed		*ed_prev;	/* for non-interrupt EDs */
 	struct list_head	td_list;	/* "shadow list" of our TDs */
+	struct list_head	in_use_list;
 
 	/* create --&gt; IDLE --&gt; OPER --&gt; ... --&gt; IDLE --&gt; destroy
 	 * usually:  OPER --&gt; UNLINK --&gt; (IDLE | OPER) --&gt; ...
@@ -66,6 +67,13 @@ struct ed {
 
 	/* HC may see EDs on rm_list until next frame (frame_no == tick) */
 	u16			tick;
+
+	/* Detect TDs not added to the done queue */
+	unsigned		takeback_wdh_cnt;
+	struct td		*pending_td;
+#define	OKAY_TO_TAKEBACK(ohci, ed)			\
+		((int) (ohci-&gt;wdh_cnt - ed-&gt;takeback_wdh_cnt) &gt;= 0)
+
 } __attribute__ ((aligned(16)));
 
 #define ED_MASK	((u32)~0x0f)		/* strip hw status in low addr bits */
@@ -382,6 +390,7 @@ struct ohci_hcd {
 	struct td		*td_hash [TD_HASH_SIZE];
 	struct td		*dl_start, *dl_end;	/* the done list */
 	struct list_head	pending;
+	struct list_head	eds_in_use;	/* all EDs with at least 1 TD */
 
 	/*
 	 * driver state
@@ -412,6 +421,10 @@ struct ohci_hcd {
 
 	// there are also chip quirks/bugs in init logic
 
+	unsigned		wdh_cnt, prev_wdh_cnt;
+	u32			prev_donehead;
+	struct timer_list	io_watchdog;
+
 	struct work_struct	nec_work;	/* Worker for NEC quirk */
 
 	struct dentry		*debug_dir;</pre><hr><pre>commit cdb4dd15e62eb984d9461b520d15d00ff2b88d9d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:26:07 2014 -0400

    USB: OHCI: make URB completions single-threaded
    
    URBs for a particular endpoint should complete sequentially.  That is,
    we shouldn't call the completion handler for one URB until the handler
    for the previous URB has returned.
    
    When the OHCI watchdog routine is added, there will be two paths for
    completing URBs: interrupt handler and watchdog routine.  Their
    activities have to be synchronized so that completions don't occur in
    multiple threads concurrently.
    
    For that purpose, this patch creates an ohci_work() routine which will
    be responsible for calling process_done_list() and finish_unlinks(),
    the two routines that detect when an URB is complete.  Everything will
    funnel through ohci_work(), and it will be careful not to run in more
    than one thread at a time.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 3112799bba7f..ad588538e2e7 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -316,7 +316,7 @@ static int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 
 		if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 			/* With HC dead, we can clean up right away */
-			finish_unlinks(ohci, 0);
+			ohci_work(ohci);
 		}
 	}
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);
@@ -349,7 +349,7 @@ ohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 	if (ohci-&gt;rh_state != OHCI_RH_RUNNING) {
 sanitize:
 		ed-&gt;state = ED_IDLE;
-		finish_unlinks (ohci, 0);
+		ohci_work(ohci);
 	}
 
 	switch (ed-&gt;state) {
@@ -789,9 +789,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
 	 * when there's still unlinking to be done (next frame).
 	 */
-	process_done_list(ohci);
-	if (ohci-&gt;ed_rm_list)
-		finish_unlinks (ohci, ohci_frame_no(ohci));
+	ohci_work(ohci);
 	if ((ints &amp; OHCI_INTR_SF) != 0 &amp;&amp; !ohci-&gt;ed_rm_list
 			&amp;&amp; ohci-&gt;rh_state == OHCI_RH_RUNNING)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;regs-&gt;intrdisable);
@@ -879,7 +877,7 @@ int ohci_restart(struct ohci_hcd *ohci)
 		if (!urb-&gt;unlinked)
 			urb-&gt;unlinked = -ESHUTDOWN;
 	}
-	finish_unlinks (ohci, 0);
+	ohci_work(ohci);
 	spin_unlock_irq(&amp;ohci-&gt;lock);
 
 	/* paranoia, in case that didn't work: */
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index dccb90edd66e..8991692bcfb8 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -40,8 +40,7 @@
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
 static void update_done_list(struct ohci_hcd *);
-static void process_done_list(struct ohci_hcd *);
-static void finish_unlinks (struct ohci_hcd *, u16);
+static void ohci_work(struct ohci_hcd *);
 
 #ifdef	CONFIG_PM
 static int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)
@@ -89,8 +88,7 @@ __acquires(ohci-&gt;lock)
 		spin_lock_irq (&amp;ohci-&gt;lock);
 	}
 	update_done_list(ohci);
-	process_done_list(ohci);
-	finish_unlinks (ohci, ohci_frame_no(ohci));
+	ohci_work(ohci);
 
 	/*
 	 * Some controllers don't handle "global" suspend properly if
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index f36b2fa0ee2f..1974ddc68e45 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -964,9 +964,9 @@ static void update_done_list(struct ohci_hcd *ohci)
 /*-------------------------------------------------------------------------*/
 
 /* there are some urbs/eds to unlink; called in_irq(), with HCD locked */
-static void
-finish_unlinks (struct ohci_hcd *ohci, u16 tick)
+static void finish_unlinks(struct ohci_hcd *ohci)
 {
+	unsigned	tick = ohci_frame_no(ohci);
 	struct ed	*ed, **last;
 
 rescan_all:
@@ -1202,3 +1202,27 @@ static void process_done_list(struct ohci_hcd *ohci)
 		takeback_td(ohci, td);
 	}
 }
+
+/*
+ * TD takeback and URB giveback must be single-threaded.
+ * This routine takes care of it all.
+ */
+static void ohci_work(struct ohci_hcd *ohci)
+{
+	if (ohci-&gt;working) {
+		ohci-&gt;restart_work = 1;
+		return;
+	}
+	ohci-&gt;working = 1;
+
+ restart:
+	process_done_list(ohci);
+	if (ohci-&gt;ed_rm_list)
+		finish_unlinks(ohci);
+
+	if (ohci-&gt;restart_work) {
+		ohci-&gt;restart_work = 0;
+		goto restart;
+	}
+	ohci-&gt;working = 0;
+}
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index a8259bc6fd8b..ef348c2e1e4b 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -393,6 +393,8 @@ struct ohci_hcd {
 	unsigned long		next_statechange;	/* suspend/resume */
 	u32			fminterval;		/* saved register */
 	unsigned		autostop:1;	/* rh auto stopping/stopped */
+	unsigned		working:1;
+	unsigned		restart_work:1;
 
 	unsigned long		flags;		/* for HC bugs */
 #define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */</pre><hr><pre>commit c6fcb85ea22889527ee44aba42c3e3b479fd2d92
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 18 16:25:59 2014 -0400

    USB: OHCI: redesign the TD done list
    
    This patch changes the way ohci-hcd handles the TD done list.  In
    addition to relying on the TD pointers stored by the controller
    hardware, we need to handle TDs that the hardware has forgotten about.
    
    This means the list has to exist even while the dl_done_list() routine
    isn't running.  That function essentially gets split in two:
    update_done_list() reads the TD pointers stored by the hardware and
    adds the TDs to the done list, and process_done_list() scans through
    the list to handle URB completions.  When we detect a TD that the
    hardware forgot about, we will be able to add it to the done list
    manually and then process it normally.
    
    Since the list is really a queue, and because there can be a lot of
    TDs, keep the existing singly linked implementation.  To insure that
    URBs are given back in order of submission, whenever a TD is added to
    the done list, all the preceding TDs for the same endpoint must be
    added as well (going back to the first one that isn't already on the
    done list).
    
    The done list manipulations must all be protected by the private
    lock.  The scope of the lock is expanded in preparation for the
    watchdog routine to be added in a later patch.
    
    We have to be more careful about giving back unlinked URBs.  Since TDs
    may be added to the done list by the watchdog routine and not in
    response to a controller interrupt, we have to check explicitly to
    make sure all the URB's TDs that were added to the done list have been
    processed before giving back the URB.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 52829276a44e..3112799bba7f 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -780,24 +780,21 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 			usb_hcd_resume_root_hub(hcd);
 	}
 
-	if (ints &amp; OHCI_INTR_WDH) {
-		spin_lock (&amp;ohci-&gt;lock);
-		dl_done_list (ohci);
-		spin_unlock (&amp;ohci-&gt;lock);
-	}
+	spin_lock(&amp;ohci-&gt;lock);
+	if (ints &amp; OHCI_INTR_WDH)
+		update_done_list(ohci);
 
 	/* could track INTR_SO to reduce available PCI/... bandwidth */
 
 	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
 	 * when there's still unlinking to be done (next frame).
 	 */
-	spin_lock (&amp;ohci-&gt;lock);
+	process_done_list(ohci);
 	if (ohci-&gt;ed_rm_list)
 		finish_unlinks (ohci, ohci_frame_no(ohci));
 	if ((ints &amp; OHCI_INTR_SF) != 0 &amp;&amp; !ohci-&gt;ed_rm_list
 			&amp;&amp; ohci-&gt;rh_state == OHCI_RH_RUNNING)
 		ohci_writel (ohci, OHCI_INTR_SF, &amp;regs-&gt;intrdisable);
-	spin_unlock (&amp;ohci-&gt;lock);
 
 	if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 		ohci_writel (ohci, ints, &amp;regs-&gt;intrstatus);
@@ -805,6 +802,7 @@ static irqreturn_t ohci_irq (struct usb_hcd *hcd)
 		// flush those writes
 		(void) ohci_readl (ohci, &amp;ohci-&gt;regs-&gt;control);
 	}
+	spin_unlock(&amp;ohci-&gt;lock);
 
 	return IRQ_HANDLED;
 }
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index b4940de1eba3..dccb90edd66e 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -39,7 +39,8 @@
 #define OHCI_SCHED_ENABLES \
 	(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)
 
-static void dl_done_list (struct ohci_hcd *);
+static void update_done_list(struct ohci_hcd *);
+static void process_done_list(struct ohci_hcd *);
 static void finish_unlinks (struct ohci_hcd *, u16);
 
 #ifdef	CONFIG_PM
@@ -87,7 +88,8 @@ __acquires(ohci-&gt;lock)
 		msleep (8);
 		spin_lock_irq (&amp;ohci-&gt;lock);
 	}
-	dl_done_list (ohci);
+	update_done_list(ohci);
+	process_done_list(ohci);
 	finish_unlinks (ohci, ohci_frame_no(ohci));
 
 	/*
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index a9f4f04c3fad..f36b2fa0ee2f 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -892,13 +892,41 @@ static void ed_halted(struct ohci_hcd *ohci, struct td *td, int cc)
 	}
 }
 
-/* replies to the request have to be on a FIFO basis so
- * we unreverse the hc-reversed done-list
- */
-static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
+/* Add a TD to the done list */
+static void add_to_done_list(struct ohci_hcd *ohci, struct td *td)
+{
+	struct td	*td2, *td_prev;
+	struct ed	*ed;
+
+	if (td-&gt;next_dl_td)
+		return;		/* Already on the list */
+
+	/* Add all the TDs going back until we reach one that's on the list */
+	ed = td-&gt;ed;
+	td2 = td_prev = td;
+	list_for_each_entry_continue_reverse(td2, &amp;ed-&gt;td_list, td_list) {
+		if (td2-&gt;next_dl_td)
+			break;
+		td2-&gt;next_dl_td = td_prev;
+		td_prev = td2;
+	}
+
+	if (ohci-&gt;dl_end)
+		ohci-&gt;dl_end-&gt;next_dl_td = td_prev;
+	else
+		ohci-&gt;dl_start = td_prev;
+
+	/*
+	 * Make td-&gt;next_dl_td point to td itself, to mark the fact
+	 * that td is on the done list.
+	 */
+	ohci-&gt;dl_end = td-&gt;next_dl_td = td;
+}
+
+/* Get the entries on the hardware done queue and put them on our list */
+static void update_done_list(struct ohci_hcd *ohci)
 {
 	u32		td_dma;
-	struct td	*td_rev = NULL;
 	struct td	*td = NULL;
 
 	td_dma = hc32_to_cpup (ohci, &amp;ohci-&gt;hcca-&gt;done_head);
@@ -906,7 +934,7 @@ static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
 	wmb();
 
 	/* get TD from hc's singly linked list, and
-	 * prepend to ours.  ed-&gt;td_list changes later.
+	 * add to ours.  ed-&gt;td_list changes later.
 	 */
 	while (td_dma) {
 		int		cc;
@@ -928,11 +956,9 @@ static struct td *dl_reverse_done_list (struct ohci_hcd *ohci)
 				&amp;&amp; (td-&gt;ed-&gt;hwHeadP &amp; cpu_to_hc32 (ohci, ED_H)))
 			ed_halted(ohci, td, cc);
 
-		td-&gt;next_dl_td = td_rev;
-		td_rev = td;
 		td_dma = hc32_to_cpup (ohci, &amp;td-&gt;hwNextTD);
+		add_to_done_list(ohci, td);
 	}
-	return td_rev;
 }
 
 /*-------------------------------------------------------------------------*/
@@ -956,26 +982,27 @@ finish_unlinks (struct ohci_hcd *ohci, u16 tick)
 		/* only take off EDs that the HC isn't using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
-		if (likely(ohci-&gt;rh_state == OHCI_RH_RUNNING)) {
-			if (tick_before (tick, ed-&gt;tick)) {
+		if (likely(ohci-&gt;rh_state == OHCI_RH_RUNNING) &amp;&amp;
+				tick_before(tick, ed-&gt;tick)) {
 skip_ed:
-				last = &amp;ed-&gt;ed_next;
-				continue;
-			}
+			last = &amp;ed-&gt;ed_next;
+			continue;
+		}
+		if (!list_empty(&amp;ed-&gt;td_list)) {
+			struct td	*td;
+			u32		head;
 
-			if (!list_empty (&amp;ed-&gt;td_list)) {
-				struct td	*td;
-				u32		head;
+			td = list_first_entry(&amp;ed-&gt;td_list, struct td, td_list);
 
-				td = list_entry (ed-&gt;td_list.next, struct td,
-							td_list);
-				head = hc32_to_cpu (ohci, ed-&gt;hwHeadP) &amp;
-								TD_MASK;
+			/* INTR_WDH may need to clean up first */
+			head = hc32_to_cpu(ohci, ed-&gt;hwHeadP) &amp; TD_MASK;
+			if (td-&gt;td_dma != head &amp;&amp;
+					ohci-&gt;rh_state == OHCI_RH_RUNNING)
+				goto skip_ed;
 
-				/* INTR_WDH may need to clean up first */
-				if (td-&gt;td_dma != head)
-					goto skip_ed;
-			}
+			/* Don't mess up anything already on the done list */
+			if (td-&gt;next_dl_td)
+				goto skip_ed;
 		}
 
 		/* ED's now officially unlinked, hc doesn't see */
@@ -1161,33 +1188,17 @@ static void takeback_td(struct ohci_hcd *ohci, struct td *td)
  * normal path is finish_unlinks(), which unlinks URBs using ed_rm_list,
  * instead of scanning the (re-reversed) donelist as this does.
  */
-static void
-dl_done_list (struct ohci_hcd *ohci)
+static void process_done_list(struct ohci_hcd *ohci)
 {
-	struct td	*td = dl_reverse_done_list (ohci);
-
-	while (td) {
-		struct td	*td_next = td-&gt;next_dl_td;
-		struct ed	*ed = td-&gt;ed;
+	struct td	*td;
 
-		/*
-		 * Some OHCI controllers (NVIDIA for sure, maybe others)
-		 * occasionally forget to add TDs to the done queue.  Since
-		 * TDs for a given endpoint are always processed in order,
-		 * if we find a TD on the donelist then all of its
-		 * predecessors must be finished as well.
-		 */
-		for (;;) {
-			struct td	*td2;
-
-			td2 = list_first_entry(&amp;ed-&gt;td_list, struct td,
-					td_list);
-			if (td2 == td)
-				break;
-			takeback_td(ohci, td2);
-		}
+	while (ohci-&gt;dl_start) {
+		td = ohci-&gt;dl_start;
+		if (td == ohci-&gt;dl_end)
+			ohci-&gt;dl_start = ohci-&gt;dl_end = NULL;
+		else
+			ohci-&gt;dl_start = td-&gt;next_dl_td;
 
 		takeback_td(ohci, td);
-		td = td_next;
 	}
 }
diff --git a/drivers/usb/host/ohci.h b/drivers/usb/host/ohci.h
index 392932dd6318..a8259bc6fd8b 100644
--- a/drivers/usb/host/ohci.h
+++ b/drivers/usb/host/ohci.h
@@ -380,6 +380,7 @@ struct ohci_hcd {
 	struct dma_pool		*td_cache;
 	struct dma_pool		*ed_cache;
 	struct td		*td_hash [TD_HASH_SIZE];
+	struct td		*dl_start, *dl_end;	/* the done list */
 	struct list_head	pending;
 
 	/*</pre>
    <div class="pagination">
        <a href='2_27.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><span>[28]</span><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_29.html'>Next&gt;&gt;</a>
    <div>
</body>
