<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of New South Wales</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of New South Wales</h1>
    <div class="pagination">
        <a href='8_14.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><a href='8_5.html'>5</a><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><span>[15]</span><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_16.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 63de428b139d3d31d86ebe25ae97b33f6540fb7e
Author: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
Date:   Thu Aug 14 18:17:13 2008 +1000

    deadline-iosched: allow non-sequential batching
    
    Deadline currently only batches sector-contiguous requests, so except
    for a few circumstances (e.g. requests in a single direction), it is
    essentially first come first served.  This is bad for throughput, so
    change it to CSCAN, which means requests in a batch do not need to be
    sequential and are issued in increasing sector order.
    
    Signed-off-by: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
    Signed-off-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;

diff --git a/block/deadline-iosched.c b/block/deadline-iosched.c
index 342448c3d2dd..07b80e4642f9 100644
--- a/block/deadline-iosched.c
+++ b/block/deadline-iosched.c
@@ -258,17 +258,9 @@ static int deadline_dispatch_requests(struct request_queue *q, int force)
 	else
 		rq = dd-&gt;next_rq[READ];
 
-	if (rq) {
-		/* we have a "next request" */
-		
-		if (dd-&gt;last_sector != rq-&gt;sector)
-			/* end the batch on a non sequential request */
-			dd-&gt;batching += dd-&gt;fifo_batch;
-		
-		if (dd-&gt;batching &lt; dd-&gt;fifo_batch)
-			/* we are still entitled to batch */
-			goto dispatch_request;
-	}
+	if (rq &amp;&amp; dd-&gt;batching &lt; dd-&gt;fifo_batch)
+		/* we have a next request are still entitled to batch */
+		goto dispatch_request;
 
 	/*
 	 * at this point we are not running a batch. select the appropriate</pre><hr><pre>commit bf4634afd8bb72936d2d56425ec792ca1bfa92a2
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Thu Jul 31 10:56:34 2008 +1000

    rt2500pci: restoring missing line
    
    In kernel version 2.6.26-rc9 my wireless LAN card worked; but in the
    released 2.6.26, my RaLink rt2500 card wouldn't associate.
    
    Git-bisect led me to this patch:
    
            61486e0f68d1f8966c09b734566a187d42d65c54
            rt2x00: Remove ieee80211_tx_control argument from write_tx_desc()
    
    I believe that there is a problem with that patch --- it
    (inadvertantly) removes an extra line of code, that used to set the
    DATABYTE_COUNT field.
    
    This patch reinstates that line, and with it my card works again.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Acked-by: Ivo van Doorn &lt;IvDoorn@gmail.com&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/rt2x00/rt2500pci.c b/drivers/net/wireless/rt2x00/rt2500pci.c
index aa6dfb811c71..181a146b4768 100644
--- a/drivers/net/wireless/rt2x00/rt2500pci.c
+++ b/drivers/net/wireless/rt2x00/rt2500pci.c
@@ -1220,6 +1220,7 @@ static void rt2500pci_write_tx_desc(struct rt2x00_dev *rt2x00dev,
 	rt2x00_set_field32(&amp;word, TXD_W0_IFS, txdesc-&gt;ifs);
 	rt2x00_set_field32(&amp;word, TXD_W0_RETRY_MODE,
 			   test_bit(ENTRY_TXD_RETRY_MODE, &amp;txdesc-&gt;flags));
+	rt2x00_set_field32(&amp;word, TXD_W0_DATABYTE_COUNT, skb-&gt;len);
 	rt2x00_set_field32(&amp;word, TXD_W0_CIPHER_ALG, CIPHER_NONE);
 	rt2x00_desc_write(txd, 0, word);
 }</pre><hr><pre>commit e384f41409cb9e543fbc84b375e2ba46cbcbec6a
Author: Ian Wienand &lt;ianw@gelato.unsw.edu.au&gt;
Date:   Tue Nov 20 14:12:46 2007 +1100

    [IA64] set_thread_area fails in IA32 chroot
    
    I tried to upgrade an IA32 chroot on my IA64 to a new glibc with TLS.
    It kept dying because set_thread_area was returning -ESRCH
    (bugs.debian.org/451939).
    
    I instrumented arch/ia64/ia32/sys_ia32.c:get_free_idx() and ended up
    seeing output like
    
    [pid] idx   desc-&gt;a  desc-&gt;b
    -----------------------------
    [2710] 0 -&gt; c6b0ffff 40dff31b
    [2710] 1 -&gt; 0 0
    [2710] 2 -&gt; 0 0
    
    [2710] 0 -&gt; c6b0ffff 40dff31b
    [2710] 1 -&gt; c6b0ffff 40dff31b
    [2710] 2 -&gt; 0 0
    
    [2711] 0 -&gt; c6b0ffff 40dff31b
    [2711] 1 -&gt; c6b0ffff 40dff31b
    [2711] 2 -&gt; 48c0ffff 40dff317
    
    which suggested to me that TLS pointers were surviving exec() calls,
    leading to GDT pointers filling up and the eventual failure of
    get_free_idx().
    
    I think the solution is flushing the tls array on exec.
    
    Signed-Off-By: Ian Wienand &lt;ianw@gelato.unsw.edu.au&gt;
    Signed-off-by: Tony Luck &lt;tony.luck@intel.com&gt;

diff --git a/arch/ia64/kernel/process.c b/arch/ia64/kernel/process.c
index a70ad185725c..7377d323131d 100644
--- a/arch/ia64/kernel/process.c
+++ b/arch/ia64/kernel/process.c
@@ -739,6 +739,7 @@ flush_thread (void)
 		ia32_drop_ia64_partial_page_list(current);
 		current-&gt;thread.task_size = IA32_PAGE_OFFSET;
 		set_fs(USER_DS);
+		memset(current-&gt;thread.tls_array, 0, sizeof(current-&gt;thread.tls_array));
 	}
 #endif
 }</pre><hr><pre>commit 49565124b13bb16607e7f8fc8fb1d9c5c355a1a3
Author: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
Date:   Wed Dec 5 21:07:07 2007 +1100

    as-iosched: fix write batch start point
    
    New write batches currently start from where the last one completed.
    We have no idea where the head is after switching batches, so this
    makes little sense.  Instead, start the next batch from the request
    with the earliest deadline in the hope that we avoid a deadline
    expiry later on.
    
    Signed-off-by: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
    Acked-by: Nick Piggin &lt;npiggin@suse.de&gt;
    Signed-off-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;

diff --git a/block/as-iosched.c b/block/as-iosched.c
index 4513fc59c9da..555cd6bf4ce5 100644
--- a/block/as-iosched.c
+++ b/block/as-iosched.c
@@ -1097,7 +1097,8 @@ static int as_dispatch_request(struct request_queue *q, int force)
 		ad-&gt;batch_data_dir = REQ_ASYNC;
 		ad-&gt;current_write_count = ad-&gt;write_batch_count;
 		ad-&gt;write_batch_idled = 0;
-		rq = ad-&gt;next_rq[ad-&gt;batch_data_dir];
+		rq = rq_entry_fifo(ad-&gt;fifo_list[REQ_ASYNC].next);
+		ad-&gt;last_check_fifo[REQ_ASYNC] = jiffies;
 		goto dispatch_request;
 	}
 </pre><hr><pre>commit 8896f3c039b0834ba695d154299b724ee5710b97
Author: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
Date:   Wed Dec 5 21:06:50 2007 +1100

    as-iosched: fix incorrect comments
    
    Two comments refer to deadlines applying to reads only.  This is
    not the case.
    
    Signed-off-by: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
    Acked-by: Nick Piggin &lt;npiggin@suse.de&gt;
    Signed-off-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;

diff --git a/block/as-iosched.c b/block/as-iosched.c
index dc715a562e14..4513fc59c9da 100644
--- a/block/as-iosched.c
+++ b/block/as-iosched.c
@@ -880,7 +880,7 @@ static void as_remove_queued_request(struct request_queue *q,
 }
 
 /*
- * as_fifo_expired returns 0 if there are no expired reads on the fifo,
+ * as_fifo_expired returns 0 if there are no expired requests on the fifo,
  * 1 otherwise.  It is ratelimited so that we only perform the check once per
  * `fifo_expire' interval.  Otherwise a large number of expired requests
  * would create a hopeless seekstorm.
@@ -1159,7 +1159,7 @@ static void as_add_request(struct request_queue *q, struct request *rq)
 	as_add_rq_rb(ad, rq);
 
 	/*
-	 * set expire time (only used for reads) and add to fifo list
+	 * set expire time and add to fifo list
 	 */
 	rq_set_fifo_time(rq, jiffies + ad-&gt;fifo_expire[data_dir]);
 	list_add_tail(&amp;rq-&gt;queuelist, &amp;ad-&gt;fifo_list[data_dir]);</pre><hr><pre>commit c5d07d6ccc6710cad5815768c6d5e629c99b4dca
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Wed Oct 31 11:45:50 2007 +1100

    [IA64] Add gate.lds to list of files ignored by Git
    
    If you build the kernel `in-place' then do a git update, git
    complains about arch/ia64/kernel/gate.lds being modified and
    untracked.
    
    Add that (generated) file to a .gitignore file.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: Tony Luck &lt;tony.luck@intel.com&gt;

diff --git a/arch/ia64/kernel/.gitignore b/arch/ia64/kernel/.gitignore
new file mode 100644
index 000000000000..98307759a3b8
--- /dev/null
+++ b/arch/ia64/kernel/.gitignore
@@ -0,0 +1 @@
+gate.lds</pre><hr><pre>commit 6f5d8aa6382eef2b26032c88656270bdae7f0c42
Author: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
Date:   Tue Oct 30 10:40:13 2007 +0100

    Deadline iosched: Fix batching fairness
    
    After switching data directions, deadline always starts the next batch
    from the lowest-sector request.  This gives excessive deadline expiries
    and large latency and throughput disparity between high- and low-sector
    requests; an order of magnitude in some tests.
    
    This patch changes the batching behaviour so new batches start from the
    request whose expiry is earliest.
    
    Signed-off-by: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
    Signed-off-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;

diff --git a/block/deadline-iosched.c b/block/deadline-iosched.c
index cb94c838087a..a054eef8dff6 100644
--- a/block/deadline-iosched.c
+++ b/block/deadline-iosched.c
@@ -306,27 +306,20 @@ static int deadline_dispatch_requests(struct request_queue *q, int force)
 dispatch_find_request:
 	/*
 	 * we are not running a batch, find best request for selected data_dir
-	 * and start a new batch
 	 */
-	if (deadline_check_fifo(dd, data_dir)) {
-		/* An expired request exists - satisfy it */
+	if (deadline_check_fifo(dd, data_dir) || !dd-&gt;next_rq[data_dir]) {
+		/*
+		 * A deadline has expired, the last request was in the other
+		 * direction, or we have run out of higher-sectored requests.
+		 * Start again from the request with the earliest expiry time.
+		 */
 		rq = rq_entry_fifo(dd-&gt;fifo_list[data_dir].next);
-	} else if (dd-&gt;next_rq[data_dir]) {
+	} else {
 		/*
 		 * The last req was the same dir and we have a next request in
 		 * sort order. No expired requests so continue on from here.
 		 */
 		rq = dd-&gt;next_rq[data_dir];
-	} else {
-		struct rb_node *node;
-		/*
-		 * The last req was the other direction or we have run out of
-		 * higher-sectored requests. Go back to the lowest sectored
-		 * request (1 way elevator) and start a new batch.
-		 */
-		node = rb_first(&amp;dd-&gt;sort_list[data_dir]);
-		if (node)
-			rq = rb_entry_rq(node);
 	}
 
 	dd-&gt;batching = 0;</pre><hr><pre>commit dfb3d72a9aa519672c9ae06f0d2f93eccb35482f
Author: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
Date:   Tue Oct 30 10:40:13 2007 +0100

    Deadline iosched: Reset batch for ordered requests
    
    The deadline I/O scheduler does not reset the batch count when starting
    a new batch at a higher-sectored request.  This means the second and
    subsequent batch in the same data direction will never exceed a single
    request in size whenever higher-sectored requests are pending.
    
    This patch gives new batches in the same data direction as old ones
    their full quota of requests by resetting the batch count.
    
    Signed-off-by: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
    Signed-off-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;

diff --git a/block/deadline-iosched.c b/block/deadline-iosched.c
index a44437e5a94b..cb94c838087a 100644
--- a/block/deadline-iosched.c
+++ b/block/deadline-iosched.c
@@ -306,12 +306,11 @@ static int deadline_dispatch_requests(struct request_queue *q, int force)
 dispatch_find_request:
 	/*
 	 * we are not running a batch, find best request for selected data_dir
+	 * and start a new batch
 	 */
 	if (deadline_check_fifo(dd, data_dir)) {
 		/* An expired request exists - satisfy it */
-		dd-&gt;batching = 0;
 		rq = rq_entry_fifo(dd-&gt;fifo_list[data_dir].next);
-		
 	} else if (dd-&gt;next_rq[data_dir]) {
 		/*
 		 * The last req was the same dir and we have a next request in
@@ -325,12 +324,13 @@ static int deadline_dispatch_requests(struct request_queue *q, int force)
 		 * higher-sectored requests. Go back to the lowest sectored
 		 * request (1 way elevator) and start a new batch.
 		 */
-		dd-&gt;batching = 0;
 		node = rb_first(&amp;dd-&gt;sort_list[data_dir]);
 		if (node)
 			rq = rb_entry_rq(node);
 	}
 
+	dd-&gt;batching = 0;
+
 dispatch_request:
 	/*
 	 * rq is the selected appropriate request.</pre><hr><pre>commit 5d1a536621403b442eef60ddd35e6b7a46fb04b7
Author: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
Date:   Tue Oct 30 10:40:12 2007 +0100

    Deadline iosched: Factor out finding latter reques
    
    Factor finding the next request in sector-sorted order into
    a function deadline_latter_request.
    
    Signed-off-by: Aaron Carroll &lt;aaronc@gelato.unsw.edu.au&gt;
    Signed-off-by: Jens Axboe &lt;jens.axboe@oracle.com&gt;

diff --git a/block/deadline-iosched.c b/block/deadline-iosched.c
index 1a511ffaf8a4..a44437e5a94b 100644
--- a/block/deadline-iosched.c
+++ b/block/deadline-iosched.c
@@ -55,6 +55,20 @@ static void deadline_move_request(struct deadline_data *, struct request *);
 
 #define RQ_RB_ROOT(dd, rq)	(&amp;(dd)-&gt;sort_list[rq_data_dir((rq))])
 
+/*
+ * get the request after `rq' in sector-sorted order
+ */
+static inline struct request *
+deadline_latter_request(struct request *rq)
+{
+	struct rb_node *node = rb_next(&amp;rq-&gt;rb_node);
+
+	if (node)
+		return rb_entry_rq(node);
+
+	return NULL;
+}
+
 static void
 deadline_add_rq_rb(struct deadline_data *dd, struct request *rq)
 {
@@ -74,13 +88,8 @@ deadline_del_rq_rb(struct deadline_data *dd, struct request *rq)
 {
 	const int data_dir = rq_data_dir(rq);
 
-	if (dd-&gt;next_rq[data_dir] == rq) {
-		struct rb_node *rbnext = rb_next(&amp;rq-&gt;rb_node);
-
-		dd-&gt;next_rq[data_dir] = NULL;
-		if (rbnext)
-			dd-&gt;next_rq[data_dir] = rb_entry_rq(rbnext);
-	}
+	if (dd-&gt;next_rq[data_dir] == rq)
+		dd-&gt;next_rq[data_dir] = deadline_latter_request(rq);
 
 	elv_rb_del(RQ_RB_ROOT(dd, rq), rq);
 }
@@ -198,14 +207,11 @@ static void
 deadline_move_request(struct deadline_data *dd, struct request *rq)
 {
 	const int data_dir = rq_data_dir(rq);
-	struct rb_node *rbnext = rb_next(&amp;rq-&gt;rb_node);
 
 	dd-&gt;next_rq[READ] = NULL;
 	dd-&gt;next_rq[WRITE] = NULL;
+	dd-&gt;next_rq[data_dir] = deadline_latter_request(rq);
 
-	if (rbnext)
-		dd-&gt;next_rq[data_dir] = rb_entry_rq(rbnext);
-	
 	dd-&gt;last_sector = rq-&gt;sector + rq-&gt;nr_sectors;
 
 	/*</pre><hr><pre>commit 7b3166dbc3df5b72f2ba4ea130f4461e318a3838
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Tue Aug 21 13:57:01 2007 +1000

    [IA64] Cleanup HPSIM code (was: Re: Enable early console for Ski simulator)
    
    After my last patch we have a new header file for HP simulator use.
    Here's code to use it for stuff that used to have `extern' statements
    inline in the code.  Functionality should not change with this patch.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: Tony Luck &lt;tony.luck@intel.com&gt;

diff --git a/arch/ia64/hp/sim/hpsim_console.c b/arch/ia64/hp/sim/hpsim_console.c
index 0475a5452404..01663bc42b1a 100644
--- a/arch/ia64/hp/sim/hpsim_console.c
+++ b/arch/ia64/hp/sim/hpsim_console.c
@@ -59,7 +59,6 @@ simcons_write (struct console *cons, const char *buf, unsigned count)
 
 static struct tty_driver *simcons_console_device (struct console *c, int *index)
 {
-	extern struct tty_driver *hp_simserial_driver;
 	*index = c-&gt;index;
 	return hp_simserial_driver;
 }
diff --git a/arch/ia64/hp/sim/simeth.c b/arch/ia64/hp/sim/simeth.c
index f26077a773d5..4017696ada63 100644
--- a/arch/ia64/hp/sim/simeth.c
+++ b/arch/ia64/hp/sim/simeth.c
@@ -22,6 +22,9 @@
 #include &lt;linux/bitops.h&gt;
 #include &lt;asm/system.h&gt;
 #include &lt;asm/irq.h&gt;
+#include &lt;asm/hpsim.h&gt;
+
+#include "hpsim_ssc.h"
 
 #define SIMETH_RECV_MAX	10
 
@@ -35,12 +38,6 @@
 #define SIMETH_FRAME_SIZE	ETH_FRAME_LEN
 
 
-#define SSC_NETDEV_PROBE		100
-#define SSC_NETDEV_SEND			101
-#define SSC_NETDEV_RECV			102
-#define SSC_NETDEV_ATTACH		103
-#define SSC_NETDEV_DETACH		104
-
 #define NETWORK_INTR			8
 
 struct simeth_local {
@@ -124,9 +121,6 @@ simeth_probe (void)
 	return r;
 }
 
-extern long ia64_ssc (long, long, long, long, int);
-extern void ia64_ssc_connect_irq (long intr, long irq);
-
 static inline int
 netdev_probe(char *name, unsigned char *ether)
 {
diff --git a/arch/ia64/hp/sim/simscsi.c b/arch/ia64/hp/sim/simscsi.c
index e62694f8ef75..4552a1cf5b33 100644
--- a/arch/ia64/hp/sim/simscsi.c
+++ b/arch/ia64/hp/sim/simscsi.c
@@ -14,6 +14,7 @@
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/timer.h&gt;
 #include &lt;asm/irq.h&gt;
+#include "hpsim_ssc.h"
 
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_cmnd.h&gt;
@@ -59,8 +60,6 @@ struct disk_stat {
 	unsigned count;
 };
 
-extern long ia64_ssc (long arg0, long arg1, long arg2, long arg3, int nr);
-
 static int desc[16] = {
 	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
 };
diff --git a/include/asm-ia64/hpsim.h b/include/asm-ia64/hpsim.h
index d6be3fdc39fa..892ab198a9da 100644
--- a/include/asm-ia64/hpsim.h
+++ b/include/asm-ia64/hpsim.h
@@ -7,4 +7,10 @@ static inline int simcons_register(void) { return 1; }
 int simcons_register(void);
 #endif
 
+struct tty_driver;
+extern struct tty_driver *hp_simserial_driver;
+
+void ia64_ssc_connect_irq(long intr, long irq);
+void ia64_ctl_trace(long on);
+
 #endif</pre>
    <div class="pagination">
        <a href='8_14.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><a href='8_5.html'>5</a><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><span>[15]</span><a href='8_16.html'>16</a><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_16.html'>Next&gt;&gt;</a>
    <div>
</body>
