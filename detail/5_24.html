<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_23.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><span>[24]</span><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_25.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 5d90027fb579eee41ec1b61f23195ed2fdd51da2
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Jul 11 19:50:34 2008 -0500

    [SCSI] stex: fix queue depth setting
    
    We want to set the queue depth to something reasonable - not
    the can_queue.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: Ed Lin &lt;ed.lin@promise.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/stex.c b/drivers/scsi/stex.c
index f308a0308829..3790906a77d1 100644
--- a/drivers/scsi/stex.c
+++ b/drivers/scsi/stex.c
@@ -467,7 +467,7 @@ stex_slave_alloc(struct scsi_device *sdev)
 	/* Cheat: usually extracted from Inquiry data */
 	sdev-&gt;tagged_supported = 1;
 
-	scsi_activate_tcq(sdev, sdev-&gt;host-&gt;can_queue);
+	scsi_activate_tcq(sdev, ST_CMD_PER_LUN);
 
 	return 0;
 }</pre><hr><pre>commit d510d965e17a81d4d41c03a3927f6ef450b73ff5
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Jul 11 19:50:33 2008 -0500

    [SCSI] qla4xxx: fix queue depth setting
    
    We want to set the queue depth to something reasonable - not
    the can_queue.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Cc: David Somayajulu &lt;david.somayajulu@qlogic.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 5822dd595826..88bebb13bc52 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -46,6 +46,8 @@ MODULE_PARM_DESC(ql4xextended_error_logging,
 
 int ql4_mod_unload = 0;
 
+#define QL4_DEF_QDEPTH 32
+
 /*
  * SCSI host template entry points
  */
@@ -1387,7 +1389,7 @@ static int qla4xxx_slave_alloc(struct scsi_device *sdev)
 
 	sdev-&gt;hostdata = ddb;
 	sdev-&gt;tagged_supported = 1;
-	scsi_activate_tcq(sdev, sdev-&gt;host-&gt;can_queue);
+	scsi_activate_tcq(sdev, QL4_DEF_QDEPTH);
 	return 0;
 }
 </pre><hr><pre>commit 885ace9e2f120439043ffa1bb72a2fa1f3afc645
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Jul 11 19:50:32 2008 -0500

    [SCSI] fix shared tag map setup
    
    Currently qla4xxx and stex pass in their can_queue values into
    scsi_activate_tcq because they wanted the tag map that large.
    The problem with this is that it ends up also setting the queue
    depth to that large value. All we want to do this in this case
    is set the device queue depth and the other device settings.
    We do not need to touch the tag map sizing because the drivers
    had setup that map according to their can_queue limits when the
    shared map was created.
    
    The scsi mid layer in request_fn will then handle the case where we
    have more requests than available tags when it checks the host
    queue ready function.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
index 36c92f961e15..5276e73c58fc 100644
--- a/drivers/scsi/scsi.c
+++ b/drivers/scsi/scsi.c
@@ -902,11 +902,20 @@ void scsi_adjust_queue_depth(struct scsi_device *sdev, int tagged, int tags)
 
 	spin_lock_irqsave(sdev-&gt;request_queue-&gt;queue_lock, flags);
 
-	/* Check to see if the queue is managed by the block layer.
-	 * If it is, and we fail to adjust the depth, exit. */
-	if (blk_queue_tagged(sdev-&gt;request_queue) &amp;&amp;
-	    blk_queue_resize_tags(sdev-&gt;request_queue, tags) != 0)
-		goto out;
+	/*
+	 * Check to see if the queue is managed by the block layer.
+	 * If it is, and we fail to adjust the depth, exit.
+	 *
+	 * Do not resize the tag map if it is a host wide share bqt,
+	 * because the size should be the hosts's can_queue. If there
+	 * is more IO than the LLD's can_queue (so there are not enuogh
+	 * tags) request_fn's host queue ready check will handle it.
+	 */
+	if (!sdev-&gt;host-&gt;bqt) {
+		if (blk_queue_tagged(sdev-&gt;request_queue) &amp;&amp;
+		    blk_queue_resize_tags(sdev-&gt;request_queue, tags) != 0)
+			goto out;
+	}
 
 	sdev-&gt;queue_depth = tags;
 	switch (tagged) {</pre><hr><pre>commit f80f868ec463b0463b332cdb704fe5438f013f98
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Jun 16 10:11:35 2008 -0500

    [SCSI] iscsi class: fix endpoint leak
    
    class_find_device gets a ref to the device so we must release it.
    The class will serialize access to the ep so we do not have to worry
    about a remove racing with the callers access, so we can simplify the
    use and drop the ref right away.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 8e34f3c08575..3af7cbcc5c5d 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -219,6 +219,7 @@ EXPORT_SYMBOL_GPL(iscsi_destroy_endpoint);
 
 struct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle)
 {
+	struct iscsi_endpoint *ep;
 	struct device *dev;
 
 	dev = class_find_device(&amp;iscsi_endpoint_class, &amp;handle,
@@ -226,7 +227,13 @@ struct iscsi_endpoint *iscsi_lookup_endpoint(u64 handle)
 	if (!dev)
 		return NULL;
 
-	return iscsi_dev_to_endpoint(dev);
+	ep = iscsi_dev_to_endpoint(dev);
+	/*
+	 * we can drop this now because the interface will prevent
+	 * removals and lookups from racing.
+	 */
+	put_device(dev);
+	return ep;
 }
 EXPORT_SYMBOL_GPL(iscsi_lookup_endpoint);
 </pre><hr><pre>commit 4c2133c82385c31dd3eed76b07da1e986eb00294
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Jun 16 10:11:34 2008 -0500

    [SCSI] iscsi class: update version number
    
    Update iscsi class version number.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index bc0f74d4ea09..8e34f3c08575 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -34,7 +34,7 @@
 #define ISCSI_CONN_ATTRS 13
 #define ISCSI_HOST_ATTRS 4
 
-#define ISCSI_TRANSPORT_VERSION "2.0-869"
+#define ISCSI_TRANSPORT_VERSION "2.0-870"
 
 struct iscsi_internal {
 	int daemon_pid;</pre><hr><pre>commit 8e9a20cee4511be4560f9c858d9994eb6913731e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Jun 16 10:11:33 2008 -0500

    [SCSI] libiscsi, iscsi_tcp, ib_iser: fix setting of can_queue with old tools.
    
    This patch fixes two bugs that are related.
    
    1. Old tools did not set can_queue/cmds_max. This patch modifies
    libiscsi so that when we add the host we catch this and set it
    to the default.
    
    2. iscsi_tcp thought that the scsi command that was passed to
    the eh functions needed a iscsi_cmd_task allocated for it. It
    only needed a mgmt task, and now it does not matter since it
    all comes from the same pool and libiscsi handles this for the
    drivers. ib_iser had copied iscsi_tcp's code and set can_queue
    to its max - 1 to handle this. So this patch removes the max -1,
    and just sets it to the max.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index c02eabd383a1..a56931e03976 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -595,7 +595,6 @@ static struct scsi_host_template iscsi_iser_sht = {
 	.name                   = "iSCSI Initiator over iSER, v." DRV_VER,
 	.queuecommand           = iscsi_queuecommand,
 	.change_queue_depth	= iscsi_change_queue_depth,
-	.can_queue		= ISCSI_DEF_XMIT_CMDS_MAX - 1,
 	.sg_tablesize           = ISCSI_ISER_SG_TABLESIZE,
 	.max_sectors		= 1024,
 	.cmd_per_lun            = ISCSI_MAX_CMD_PER_LUN,
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 0bd8b3dc3c19..2a2f0094570f 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1865,7 +1865,6 @@ iscsi_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 	shost-&gt;max_id = 0;
 	shost-&gt;max_channel = 0;
 	shost-&gt;max_cmd_len = SCSI_MAX_VARLEN_CDB_SIZE;
-	shost-&gt;can_queue = cmds_max;
 
 	if (iscsi_host_add(shost, NULL))
 		goto free_host;
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 8b4e412a0974..299e075a7b34 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1857,6 +1857,9 @@ EXPORT_SYMBOL_GPL(iscsi_pool_free);
  */
 int iscsi_host_add(struct Scsi_Host *shost, struct device *pdev)
 {
+	if (!shost-&gt;can_queue)
+		shost-&gt;can_queue = ISCSI_DEF_XMIT_CMDS_MAX;
+
 	return scsi_add_host(shost, pdev);
 }
 EXPORT_SYMBOL_GPL(iscsi_host_add);
@@ -1942,6 +1945,9 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 	struct iscsi_session *session;
 	struct iscsi_cls_session *cls_session;
 	int cmd_i, scsi_cmds, total_cmds = cmds_max;
+
+	if (!total_cmds)
+		total_cmds = ISCSI_DEF_XMIT_CMDS_MAX;
 	/*
 	 * The iscsi layer needs some tasks for nop handling and tmfs,
 	 * so the cmds_max must at least be greater than ISCSI_MGMT_CMDS_MAX</pre><hr><pre>commit c95fddc729fafb43f420747027eeb998c2e5e798
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Mon Jun 16 10:11:32 2008 -0500

    [SCSI] iscsi class: fix refcount leak
    
    Must do a module_out if the endpoint lookup fails.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 9fd5c6d87ed1..bc0f74d4ea09 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -1422,8 +1422,10 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 		break;
 	case ISCSI_UEVENT_CREATE_BOUND_SESSION:
 		ep = iscsi_lookup_endpoint(ev-&gt;u.c_bound_session.ep_handle);
-		if (!ep)
-			return -EINVAL;
+		if (!ep) {
+			err = -EINVAL;
+			break;
+		}
 
 		err = iscsi_if_create_session(priv, ep, ev,
 					ev-&gt;u.c_bound_session.initial_cmdsn,</pre><hr><pre>commit 913e5bf435617aa529919a4f7567f849f9f35f9f
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:18 2008 -0500

    [SCSI] libiscsi, iser, tcp: remove recv_lock
    
    The recv lock was defined so the iscsi layer could block
    the recv path from processing IO during recovery. It
    turns out iser just set a lock to that pointer which was pointless.
    
    We now disconnect the transport connection before doing recovery
    so we do not need the recv lock. For iscsi_tcp we still stop
    the recv path incase older tools are being used.
    
    This patch also has iscsi_itt_to_ctask user grab the session lock
    and has the caller access the task with the lock or get a ref
    to it in case the target is broken and sends a tmf success response
    then sends data or a response for the command that was supposed to
    be affected bty the tmf.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 08edbaf89223..c02eabd383a1 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -281,9 +281,6 @@ iscsi_iser_conn_create(struct iscsi_cls_session *cls_session, uint32_t conn_idx)
 	conn-&gt;max_recv_dlength = 128;
 
 	iser_conn = conn-&gt;dd_data;
-	/* currently this is the only field which need to be initiated */
-	rwlock_init(&amp;iser_conn-&gt;lock);
-
 	conn-&gt;dd_data = iser_conn;
 	iser_conn-&gt;iscsi_conn = conn;
 
@@ -342,9 +339,6 @@ iscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,
 	ib_conn-&gt;iser_conn = iser_conn;
 	iser_conn-&gt;ib_conn  = ib_conn;
 	iser_conn_get(ib_conn);
-
-	conn-&gt;recv_lock = &amp;iser_conn-&gt;lock;
-
 	return 0;
 }
 
@@ -355,12 +349,18 @@ iscsi_iser_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	struct iscsi_iser_conn *iser_conn = conn-&gt;dd_data;
 	struct iser_conn *ib_conn = iser_conn-&gt;ib_conn;
 
-	iscsi_conn_stop(cls_conn, flag);
 	/*
-	 * There is no unbind event so the stop callback
-	 * must release the ref from the bind.
+	 * Userspace may have goofed up and not bound the connection or
+	 * might have only partially setup the connection.
 	 */
-	iser_conn_put(ib_conn);
+	if (ib_conn) {
+		iscsi_conn_stop(cls_conn, flag);
+		/*
+		 * There is no unbind event so the stop callback
+		 * must release the ref from the bind.
+		 */
+		iser_conn_put(ib_conn);
+	}
 	iser_conn-&gt;ib_conn = NULL;
 }
 
diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h
index cdf48763b082..a547edeea969 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@ -263,8 +263,6 @@ struct iser_conn {
 struct iscsi_iser_conn {
 	struct iscsi_conn            *iscsi_conn;/* ptr to iscsi conn */
 	struct iser_conn             *ib_conn;   /* iSER IB conn      */
-
-	rwlock_t		     lock;
 };
 
 struct iscsi_iser_task {
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index 35af60a23c61..c36083922134 100644
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -558,7 +558,12 @@ void iser_rcv_completion(struct iser_desc *rx_desc,
 	opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK;
 
 	if (opcode == ISCSI_OP_SCSI_CMD_RSP) {
+		spin_lock(&amp;conn-&gt;iscsi_conn-&gt;session-&gt;lock);
 		task = iscsi_itt_to_ctask(conn-&gt;iscsi_conn, hdr-&gt;itt);
+		if (task)
+			__iscsi_get_task(task);
+		spin_unlock(&amp;conn-&gt;iscsi_conn-&gt;session-&gt;lock);
+
 		if (!task)
 			iser_err("itt can't be matched to task!!! "
 				 "conn %p opcode %d itt %d\n",
@@ -568,6 +573,7 @@ void iser_rcv_completion(struct iser_desc *rx_desc,
 			iser_dbg("itt %d task %p\n",hdr-&gt;itt, task);
 			iser_task-&gt;status = ISER_TASK_STATUS_COMPLETED;
 			iser_task_rdma_finalize(iser_task);
+			iscsi_put_task(task);
 		}
 	}
 	iser_dto_buffs_release(dto);
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 7552dd8a88f3..91cb1fd523f0 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -741,7 +741,6 @@ static int
 iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 {
 	int rc = 0, opcode, ahslen;
-	struct iscsi_session *session = conn-&gt;session;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct iscsi_task *task;
 
@@ -770,17 +769,17 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 
 	switch(opcode) {
 	case ISCSI_OP_SCSI_DATA_IN:
+		spin_lock(&amp;conn-&gt;session-&gt;lock);
 		task = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
 		if (!task)
-			return ISCSI_ERR_BAD_ITT;
-		if (!task-&gt;sc)
-			return ISCSI_ERR_NO_SCSI_CMD;
+			rc = ISCSI_ERR_BAD_ITT;
+		else
+			rc = iscsi_data_rsp(conn, task);
+		if (rc) {
+			spin_unlock(&amp;conn-&gt;session-&gt;lock);
+			break;
+		}
 
-		spin_lock(&amp;conn-&gt;session-&gt;lock);
-		rc = iscsi_data_rsp(conn, task);
-		spin_unlock(&amp;conn-&gt;session-&gt;lock);
-		if (rc)
-			return rc;
 		if (tcp_conn-&gt;in.datalen) {
 			struct iscsi_tcp_task *tcp_task = task-&gt;dd_data;
 			struct hash_desc *rx_hash = NULL;
@@ -801,15 +800,19 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 				  "datalen=%d)\n", tcp_conn,
 				  tcp_task-&gt;data_offset,
 				  tcp_conn-&gt;in.datalen);
-			return iscsi_segment_seek_sg(&amp;tcp_conn-&gt;in.segment,
-						     sdb-&gt;table.sgl,
-						     sdb-&gt;table.nents,
-						     tcp_task-&gt;data_offset,
-						     tcp_conn-&gt;in.datalen,
-						     iscsi_tcp_process_data_in,
-						     rx_hash);
+			rc = iscsi_segment_seek_sg(&amp;tcp_conn-&gt;in.segment,
+						   sdb-&gt;table.sgl,
+						   sdb-&gt;table.nents,
+						   tcp_task-&gt;data_offset,
+						   tcp_conn-&gt;in.datalen,
+						   iscsi_tcp_process_data_in,
+						   rx_hash);
+			spin_unlock(&amp;conn-&gt;session-&gt;lock);
+			return rc;
 		}
-		/* fall through */
+		rc = __iscsi_complete_pdu(conn, hdr, NULL, 0);
+		spin_unlock(&amp;conn-&gt;session-&gt;lock);
+		break;
 	case ISCSI_OP_SCSI_CMD_RSP:
 		if (tcp_conn-&gt;in.datalen) {
 			iscsi_tcp_data_recv_prep(tcp_conn);
@@ -818,20 +821,17 @@ iscsi_tcp_hdr_dissect(struct iscsi_conn *conn, struct iscsi_hdr *hdr)
 		rc = iscsi_complete_pdu(conn, hdr, NULL, 0);
 		break;
 	case ISCSI_OP_R2T:
+		spin_lock(&amp;conn-&gt;session-&gt;lock);
 		task = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
 		if (!task)
-			return ISCSI_ERR_BAD_ITT;
-		if (!task-&gt;sc)
-			return ISCSI_ERR_NO_SCSI_CMD;
-
-		if (ahslen)
+			rc = ISCSI_ERR_BAD_ITT;
+		else if (ahslen)
 			rc = ISCSI_ERR_AHSLEN;
-		else if (task-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE) {
-			spin_lock(&amp;session-&gt;lock);
+		else if (task-&gt;sc-&gt;sc_data_direction == DMA_TO_DEVICE)
 			rc = iscsi_r2t_rsp(conn, task);
-			spin_unlock(&amp;session-&gt;lock);
-		} else
+		else
 			rc = ISCSI_ERR_PROTO;
+		spin_unlock(&amp;conn-&gt;session-&gt;lock);
 		break;
 	case ISCSI_OP_LOGIN_RSP:
 	case ISCSI_OP_TEXT_RSP:
@@ -1553,7 +1553,6 @@ iscsi_tcp_release_conn(struct iscsi_conn *conn)
 
 	spin_lock_bh(&amp;session-&gt;lock);
 	tcp_conn-&gt;sock = NULL;
-	conn-&gt;recv_lock = NULL;
 	spin_unlock_bh(&amp;session-&gt;lock);
 	sockfd_put(sock);
 }
@@ -1578,6 +1577,19 @@ static void
 iscsi_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+
+	/* userspace may have goofed up and not bound us */
+	if (!tcp_conn-&gt;sock)
+		return;
+	/*
+	 * Make sure our recv side is stopped.
+	 * Older tools called conn stop before ep_disconnect
+	 * so IO could still be coming in.
+	 */
+	write_lock_bh(&amp;tcp_conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
+	write_unlock_bh(&amp;tcp_conn-&gt;sock-&gt;sk-&gt;sk_callback_lock);
 
 	iscsi_conn_stop(cls_conn, flag);
 	iscsi_tcp_release_conn(conn);
@@ -1671,13 +1683,6 @@ iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 	sk-&gt;sk_sndtimeo = 15 * HZ; /* FIXME: make it configurable */
 	sk-&gt;sk_allocation = GFP_ATOMIC;
 
-	/* FIXME: disable Nagle's algorithm */
-
-	/*
-	 * Intercept TCP callbacks for sendfile like receive
-	 * processing.
-	 */
-	conn-&gt;recv_lock = &amp;sk-&gt;sk_callback_lock;
 	iscsi_conn_set_callbacks(conn);
 	tcp_conn-&gt;sendpage = tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
 	/*
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index c723e60f02b0..9c267b440444 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -362,10 +362,11 @@ static void iscsi_complete_command(struct iscsi_task *task)
 	}
 }
 
-static void __iscsi_get_task(struct iscsi_task *task)
+void __iscsi_get_task(struct iscsi_task *task)
 {
 	atomic_inc(&amp;task-&gt;refcount);
 }
+EXPORT_SYMBOL_GPL(__iscsi_get_task);
 
 static void __iscsi_put_task(struct iscsi_task *task)
 {
@@ -403,9 +404,13 @@ static void fail_command(struct iscsi_conn *conn, struct iscsi_task *task,
 		conn-&gt;session-&gt;queued_cmdsn--;
 	else
 		conn-&gt;session-&gt;tt-&gt;cleanup_task(conn, task);
+	/*
+	 * Check if cleanup_task dropped the lock and the command completed,
+	 */
+	if (!task-&gt;sc)
+		return;
 
 	sc-&gt;result = err;
-
 	if (!scsi_bidi_cmnd(sc))
 		scsi_set_resid(sc, scsi_bufflen(sc));
 	else {
@@ -696,6 +701,31 @@ static int iscsi_handle_reject(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	return 0;
 }
 
+/**
+ * iscsi_itt_to_task - look up task by itt
+ * @conn: iscsi connection
+ * @itt: itt
+ *
+ * This should be used for mgmt tasks like login and nops, or if
+ * the LDD's itt space does not include the session age.
+ *
+ * The session lock must be held.
+ */
+static struct iscsi_task *iscsi_itt_to_task(struct iscsi_conn *conn, itt_t itt)
+{
+	struct iscsi_session *session = conn-&gt;session;
+	uint32_t i;
+
+	if (itt == RESERVED_ITT)
+		return NULL;
+
+	i = get_itt(itt);
+	if (i &gt;= session-&gt;cmds_max)
+		return NULL;
+
+	return session-&gt;cmds[i];
+}
+
 /**
  * __iscsi_complete_pdu - complete pdu
  * @conn: iscsi conn
@@ -707,8 +737,8 @@ static int iscsi_handle_reject(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
  * queuecommand or send generic. session lock must be held and verify
  * itt must have been called.
  */
-static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
-				char *data, int datalen)
+int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
+			 char *data, int datalen)
 {
 	struct iscsi_session *session = conn-&gt;session;
 	int opcode = hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK, rc = 0;
@@ -758,22 +788,36 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		goto out;
 	}
 
-	task = session-&gt;cmds[itt];
 	switch(opcode) {
 	case ISCSI_OP_SCSI_CMD_RSP:
-		if (!task-&gt;sc) {
-			rc = ISCSI_ERR_NO_SCSI_CMD;
-			break;
-		}
-		BUG_ON((void*)task != task-&gt;sc-&gt;SCp.ptr);
+	case ISCSI_OP_SCSI_DATA_IN:
+		task = iscsi_itt_to_ctask(conn, hdr-&gt;itt);
+		if (!task)
+			return ISCSI_ERR_BAD_ITT;
+		break;
+	case ISCSI_OP_R2T:
+		/*
+		 * LLD handles R2Ts if they need to.
+		 */
+		return 0;
+	case ISCSI_OP_LOGOUT_RSP:
+	case ISCSI_OP_LOGIN_RSP:
+	case ISCSI_OP_TEXT_RSP:
+	case ISCSI_OP_SCSI_TMFUNC_RSP:
+	case ISCSI_OP_NOOP_IN:
+		task = iscsi_itt_to_task(conn, hdr-&gt;itt);
+		if (!task)
+			return ISCSI_ERR_BAD_ITT;
+		break;
+	default:
+		return ISCSI_ERR_BAD_OPCODE;
+	}
+
+	switch(opcode) {
+	case ISCSI_OP_SCSI_CMD_RSP:
 		iscsi_scsi_cmd_rsp(conn, hdr, task, data, datalen);
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
-		if (!task-&gt;sc) {
-			rc = ISCSI_ERR_NO_SCSI_CMD;
-			break;
-		}
-		BUG_ON((void*)task != task-&gt;sc-&gt;SCp.ptr);
 		if (hdr-&gt;flags &amp; ISCSI_FLAG_DATA_STATUS) {
 			conn-&gt;scsirsp_pdus_cnt++;
 			iscsi_update_cmdsn(session,
@@ -781,9 +825,6 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 			__iscsi_put_task(task);
 		}
 		break;
-	case ISCSI_OP_R2T:
-		/* LLD handles this for now */
-		break;
 	case ISCSI_OP_LOGOUT_RSP:
 		iscsi_update_cmdsn(session, (struct iscsi_nopin*)hdr);
 		if (datalen) {
@@ -841,6 +882,7 @@ static int __iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 	__iscsi_put_task(task);
 	return rc;
 }
+EXPORT_SYMBOL_GPL(__iscsi_complete_pdu);
 
 int iscsi_complete_pdu(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		       char *data, int datalen)
@@ -857,7 +899,6 @@ EXPORT_SYMBOL_GPL(iscsi_complete_pdu);
 int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	struct iscsi_task *task;
 	uint32_t i;
 
 	if (itt == RESERVED_ITT)
@@ -867,8 +908,7 @@ int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 	    (session-&gt;age &lt;&lt; ISCSI_AGE_SHIFT)) {
 		iscsi_conn_printk(KERN_ERR, conn,
 				  "received itt %x expected session age (%x)\n",
-				  (__force u32)itt,
-				  session-&gt;age &amp; ISCSI_AGE_MASK);
+				  (__force u32)itt, session-&gt;age);
 		return ISCSI_ERR_BAD_ITT;
 	}
 
@@ -879,42 +919,36 @@ int iscsi_verify_itt(struct iscsi_conn *conn, itt_t itt)
 				   "%u.\n", i, session-&gt;cmds_max);
 		return ISCSI_ERR_BAD_ITT;
 	}
-
-	task = session-&gt;cmds[i];
-	if (task-&gt;sc &amp;&amp; task-&gt;sc-&gt;SCp.phase != session-&gt;age) {
-		iscsi_conn_printk(KERN_ERR, conn,
-				  "iscsi: task's session age %d, "
-				  "expected %d\n", task-&gt;sc-&gt;SCp.phase,
-				  session-&gt;age);
-		return ISCSI_ERR_SESSION_FAILED;
-	}
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iscsi_verify_itt);
 
-struct iscsi_task *
-iscsi_itt_to_ctask(struct iscsi_conn *conn, itt_t itt)
+/**
+ * iscsi_itt_to_ctask - look up ctask by itt
+ * @conn: iscsi connection
+ * @itt: itt
+ *
+ * This should be used for cmd tasks.
+ *
+ * The session lock must be held.
+ */
+struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *conn, itt_t itt)
 {
-	struct iscsi_session *session = conn-&gt;session;
 	struct iscsi_task *task;
-	uint32_t i;
 
 	if (iscsi_verify_itt(conn, itt))
 		return NULL;
 
-	if (itt == RESERVED_ITT)
+	task = iscsi_itt_to_task(conn, itt);
+	if (!task || !task-&gt;sc)
 		return NULL;
 
-	i = get_itt(itt);
-	if (i &gt;= session-&gt;cmds_max)
-		return NULL;
-
-	task = session-&gt;cmds[i];
-	if (!task-&gt;sc)
-		return NULL;
-
-	if (task-&gt;sc-&gt;SCp.phase != session-&gt;age)
+	if (task-&gt;sc-&gt;SCp.phase != conn-&gt;session-&gt;age) {
+		iscsi_session_printk(KERN_ERR, conn-&gt;session,
+				  "task's session age %d, expected %d\n",
+				  task-&gt;sc-&gt;SCp.phase, conn-&gt;session-&gt;age);
 		return NULL;
+	}
 
 	return task;
 }
@@ -1620,16 +1654,20 @@ int iscsi_eh_abort(struct scsi_cmnd *sc)
 	switch (conn-&gt;tmf_state) {
 	case TMF_SUCCESS:
 		spin_unlock_bh(&amp;session-&gt;lock);
+		/*
+		 * stop tx side incase the target had sent a abort rsp but
+		 * the initiator was still writing out data.
+		 */
 		iscsi_suspend_tx(conn);
 		/*
-		 * clean up task if aborted. grab the recv lock as a writer
+		 * we do not stop the recv side because targets have been
+		 * good and have never sent us a successful tmf response
+		 * then sent more data for the cmd.
 		 */
-		write_lock_bh(conn-&gt;recv_lock);
 		spin_lock(&amp;session-&gt;lock);
 		fail_command(conn, task, DID_ABORT &lt;&lt; 16);
 		conn-&gt;tmf_state = TMF_INITIAL;
 		spin_unlock(&amp;session-&gt;lock);
-		write_unlock_bh(conn-&gt;recv_lock);
 		iscsi_start_tx(conn);
 		goto success_unlocked;
 	case TMF_TIMEDOUT:
@@ -1729,13 +1767,11 @@ int iscsi_eh_device_reset(struct scsi_cmnd *sc)
 	spin_unlock_bh(&amp;session-&gt;lock);
 
 	iscsi_suspend_tx(conn);
-	/* need to grab the recv lock then session lock */
-	write_lock_bh(conn-&gt;recv_lock);
+
 	spin_lock(&amp;session-&gt;lock);
 	fail_all_commands(conn, sc-&gt;device-&gt;lun, DID_ERROR);
 	conn-&gt;tmf_state = TMF_INITIAL;
 	spin_unlock(&amp;session-&gt;lock);
-	write_unlock_bh(conn-&gt;recv_lock);
 
 	iscsi_start_tx(conn);
 	goto done;
@@ -2256,17 +2292,6 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 		return;
 	}
 
-	/*
-	 * The LLD either freed/unset the lock on us, or userspace called
-	 * stop but did not create a proper connection (connection was never
-	 * bound or it was unbound then stop was called).
-	 */
-	if (!conn-&gt;recv_lock) {
-		spin_unlock_bh(&amp;session-&gt;lock);
-		mutex_unlock(&amp;session-&gt;eh_mutex);
-		return;
-	}
-
 	/*
 	 * When this is called for the in_login state, we only want to clean
 	 * up the login task and connection. We do not need to block and set
@@ -2283,11 +2308,6 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 	spin_unlock_bh(&amp;session-&gt;lock);
 
 	iscsi_suspend_tx(conn);
-
-	write_lock_bh(conn-&gt;recv_lock);
-	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
-	write_unlock_bh(conn-&gt;recv_lock);
-
 	/*
 	 * for connection level recovery we should not calculate
 	 * header digest. conn-&gt;hdr_size used for optimization
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 5bf0187e7520..5e75bb7f311c 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -138,11 +138,6 @@ struct iscsi_conn {
 	struct iscsi_cls_conn	*cls_conn;	/* ptr to class connection */
 	void			*dd_data;	/* iscsi_transport data */
 	struct iscsi_session	*session;	/* parent session */
-	/*
-	 * LLDs should set this lock. It protects the transport recv
-	 * code
-	 */
-	rwlock_t		*recv_lock;
 	/*
 	 * conn_stop() flag: stop to recover, stop to terminate
 	 */
@@ -374,10 +369,13 @@ extern int iscsi_conn_send_pdu(struct iscsi_cls_conn *, struct iscsi_hdr *,
 				char *, uint32_t);
 extern int iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
 			      char *, int);
+extern int __iscsi_complete_pdu(struct iscsi_conn *, struct iscsi_hdr *,
+				char *, int);
 extern int iscsi_verify_itt(struct iscsi_conn *, itt_t);
 extern struct iscsi_task *iscsi_itt_to_ctask(struct iscsi_conn *, itt_t);
 extern void iscsi_requeue_task(struct iscsi_task *task);
 extern void iscsi_put_task(struct iscsi_task *task);
+extern void __iscsi_get_task(struct iscsi_task *task);
 
 /*
  * generic helpers</pre><hr><pre>commit 3cf7b233ffc45d4fc381221f74d24f10e692c4ea
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:17 2008 -0500

    [SCSI] libiscsi: fix cmds_max setting
    
    Drivers expect that the cmds_max value they pass to the iscsi layer
    is the max scsi commands  + mgmt tasks. This patch implements that
    and fixes some checks for nr cmd limits.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index c1af2aa8e4e0..c723e60f02b0 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1893,29 +1893,48 @@ EXPORT_SYMBOL_GPL(iscsi_host_free);
  *
  * This can be used by software iscsi_transports that allocate
  * a session per scsi host.
+ *
+ * Callers should set cmds_max to the largest total numer (mgmt + scsi) of
+ * tasks they support. The iscsi layer reserves ISCSI_MGMT_CMDS_MAX tasks
+ * for nop handling and login/logout requests.
  */
 struct iscsi_cls_session *
 iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
-		    uint16_t scsi_cmds_max, int cmd_task_size,
+		    uint16_t cmds_max, int cmd_task_size,
 		    uint32_t initial_cmdsn, unsigned int id)
 {
 	struct iscsi_session *session;
 	struct iscsi_cls_session *cls_session;
-	int cmd_i, cmds_max;
-
+	int cmd_i, scsi_cmds, total_cmds = cmds_max;
 	/*
-	 * The iscsi layer needs some tasks for nop handling and tmfs.
+	 * The iscsi layer needs some tasks for nop handling and tmfs,
+	 * so the cmds_max must at least be greater than ISCSI_MGMT_CMDS_MAX
+	 * + 1 command for scsi IO.
 	 */
-	if (scsi_cmds_max &lt; 1)
-		scsi_cmds_max = ISCSI_MGMT_CMDS_MAX;
-	if ((scsi_cmds_max + ISCSI_MGMT_CMDS_MAX) &gt;= ISCSI_MGMT_ITT_OFFSET) {
-		printk(KERN_ERR "iscsi: invalid can_queue of %d. "
-		       "can_queue must be less than %d.\n",
-		       scsi_cmds_max,
-		       ISCSI_MGMT_ITT_OFFSET - ISCSI_MGMT_CMDS_MAX);
-		scsi_cmds_max = ISCSI_DEF_XMIT_CMDS_MAX;
+	if (total_cmds &lt; ISCSI_TOTAL_CMDS_MIN) {
+		printk(KERN_ERR "iscsi: invalid can_queue of %d. can_queue "
+		       "must be a power of two that is at least %d.\n",
+		       total_cmds, ISCSI_TOTAL_CMDS_MIN);
+		return NULL;
+	}
+
+	if (total_cmds &gt; ISCSI_TOTAL_CMDS_MAX) {
+		printk(KERN_ERR "iscsi: invalid can_queue of %d. can_queue "
+		       "must be a power of 2 less than or equal to %d.\n",
+		       cmds_max, ISCSI_TOTAL_CMDS_MAX);
+		total_cmds = ISCSI_TOTAL_CMDS_MAX;
+	}
+
+	if (!is_power_of_2(total_cmds)) {
+		printk(KERN_ERR "iscsi: invalid can_queue of %d. can_queue "
+		       "must be a power of 2.\n", total_cmds);
+		total_cmds = rounddown_pow_of_two(total_cmds);
+		if (total_cmds &lt; ISCSI_TOTAL_CMDS_MIN)
+			return NULL;
+		printk(KERN_INFO "iscsi: Rounding can_queue to %d.\n",
+		       total_cmds);
 	}
-	cmds_max = roundup_pow_of_two(scsi_cmds_max + ISCSI_MGMT_CMDS_MAX);
+	scsi_cmds = total_cmds - ISCSI_MGMT_CMDS_MAX;
 
 	cls_session = iscsi_alloc_session(shost, iscsit,
 					  sizeof(struct iscsi_session));
@@ -1928,8 +1947,8 @@ iscsi_session_setup(struct iscsi_transport *iscsit, struct Scsi_Host *shost,
 	session-&gt;fast_abort = 1;
 	session-&gt;lu_reset_timeout = 15;
 	session-&gt;abort_timeout = 10;
-	session-&gt;scsi_cmds_max = scsi_cmds_max;
-	session-&gt;cmds_max = cmds_max;
+	session-&gt;scsi_cmds_max = scsi_cmds;
+	session-&gt;cmds_max = total_cmds;
 	session-&gt;queued_cmdsn = session-&gt;cmdsn = initial_cmdsn;
 	session-&gt;exp_cmdsn = initial_cmdsn + 1;
 	session-&gt;max_cmdsn = initial_cmdsn + 1;
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 21cfb1d5483f..5bf0187e7520 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -52,9 +52,7 @@ struct device;
 #endif
 
 #define ISCSI_DEF_XMIT_CMDS_MAX	128	/* must be power of 2 */
-#define ISCSI_MGMT_CMDS_MAX	16	/* must be power of 2 */
-
-#define ISCSI_MGMT_ITT_OFFSET	0xa00
+#define ISCSI_MGMT_CMDS_MAX	15
 
 #define ISCSI_DEF_CMD_PER_LUN		32
 #define ISCSI_MAX_CMD_PER_LUN		128
@@ -72,7 +70,10 @@ enum {
 /* Connection suspend "bit" */
 #define ISCSI_SUSPEND_BIT		1
 
-#define ISCSI_ITT_MASK			(0xfff)
+#define ISCSI_ITT_MASK			(0x1fff)
+#define ISCSI_TOTAL_CMDS_MAX		4096
+/* this must be a power of two greater than ISCSI_MGMT_CMDS_MAX */
+#define ISCSI_TOTAL_CMDS_MIN		16
 #define ISCSI_AGE_SHIFT			28
 #define ISCSI_AGE_MASK			(0xf &lt;&lt; ISCSI_AGE_SHIFT)
 </pre><hr><pre>commit 88dfd340b9dece8fcaa1a2d4c782338926c017f7
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed May 21 15:54:16 2008 -0500

    [SCSI] iscsi class: Add session initiatorname and ifacename sysfs attrs.
    
    This adds two new attrs used for creating initiator ports and
    binding sessions to hardware.
    
    The session level initiatorname:
    
    Since bnx2i does a scsi_host per host device, we need to add the
    iface initiator port settings on the session, so we can create
    multiple initiator ports (each with different inames) per device/scsi_host.
    
    The current iname reflects that qla4xxx can have one iname per hba, and we are
    allocating a host per session for software. The iname on the host will
    remain so we can export and set the hba level qla4xxx setting.
    
    The ifacename attr:
    
    To bind a session to a some peice of hardware in userspace we maintain
    some mappings, but during boot or iscsid restart (iscsid contains the user
    space part of the driver) we need to be able to figure out which of those
    host mappings abstractions maps to certain sessions. This patch adds
    a ifacename attr, which userspace can set to id the host side of the
    endpoint across pivot_roots and iscsid restarts.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index 42e95b833092..08edbaf89223 100644
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -629,7 +629,8 @@ static struct iscsi_transport iscsi_iser_transport = {
 				  ISCSI_USERNAME | ISCSI_PASSWORD |
 				  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN |
 				  ISCSI_FAST_ABORT | ISCSI_ABORT_TMO |
-				  ISCSI_PING_TMO | ISCSI_RECV_TMO,
+				  ISCSI_PING_TMO | ISCSI_RECV_TMO |
+				  ISCSI_IFACE_NAME | ISCSI_INITIATOR_NAME,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS |
 				  ISCSI_HOST_NETDEV_NAME |
 				  ISCSI_HOST_INITIATOR_NAME,
diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 92d031959002..7552dd8a88f3 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1957,7 +1957,8 @@ static struct iscsi_transport iscsi_tcp_transport = {
 				  ISCSI_USERNAME_IN | ISCSI_PASSWORD_IN |
 				  ISCSI_FAST_ABORT | ISCSI_ABORT_TMO |
 				  ISCSI_LU_RESET_TMO |
-				  ISCSI_PING_TMO | ISCSI_RECV_TMO,
+				  ISCSI_PING_TMO | ISCSI_RECV_TMO |
+				  ISCSI_IFACE_NAME | ISCSI_INITIATOR_NAME,
 	.host_param_mask	= ISCSI_HOST_HWADDRESS | ISCSI_HOST_IPADDRESS |
 				  ISCSI_HOST_INITIATOR_NAME |
 				  ISCSI_HOST_NETDEV_NAME,
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index e88b726ab2e0..c1af2aa8e4e0 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1990,6 +1990,8 @@ void iscsi_session_teardown(struct iscsi_cls_session *cls_session)
 	kfree(session-&gt;username);
 	kfree(session-&gt;username_in);
 	kfree(session-&gt;targetname);
+	kfree(session-&gt;initiatorname);
+	kfree(session-&gt;ifacename);
 
 	iscsi_destroy_session(cls_session);
 	module_put(owner);
@@ -2453,6 +2455,14 @@ int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
 		if (!conn-&gt;persistent_address)
 			return -ENOMEM;
 		break;
+	case ISCSI_PARAM_IFACE_NAME:
+		if (!session-&gt;ifacename)
+			session-&gt;ifacename = kstrdup(buf, GFP_KERNEL);
+		break;
+	case ISCSI_PARAM_INITIATOR_NAME:
+		if (!session-&gt;initiatorname)
+			session-&gt;initiatorname = kstrdup(buf, GFP_KERNEL);
+		break;
 	default:
 		return -ENOSYS;
 	}
@@ -2519,6 +2529,15 @@ int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
 	case ISCSI_PARAM_PASSWORD_IN:
 		len = sprintf(buf, "%s\n", session-&gt;password_in);
 		break;
+	case ISCSI_PARAM_IFACE_NAME:
+		len = sprintf(buf, "%s\n", session-&gt;ifacename);
+		break;
+	case ISCSI_PARAM_INITIATOR_NAME:
+		if (!session-&gt;initiatorname)
+			len = sprintf(buf, "%s\n", "unknown");
+		else
+			len = sprintf(buf, "%s\n", session-&gt;initiatorname);
+		break;
 	default:
 		return -ENOSYS;
 	}
@@ -2606,6 +2625,7 @@ int iscsi_host_get_param(struct Scsi_Host *shost, enum iscsi_host_param param,
 		else
 			len = sprintf(buf, "%s\n",
 				      ihost-&gt;local_address);
+		break;
 	default:
 		return -ENOSYS;
 	}
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index c3c07ccccca7..9fd5c6d87ed1 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -30,7 +30,7 @@
 #include &lt;scsi/scsi_transport_iscsi.h&gt;
 #include &lt;scsi/iscsi_if.h&gt;
 
-#define ISCSI_SESSION_ATTRS 19
+#define ISCSI_SESSION_ATTRS 21
 #define ISCSI_CONN_ATTRS 13
 #define ISCSI_HOST_ATTRS 4
 
@@ -1634,6 +1634,8 @@ iscsi_session_attr(password_in, ISCSI_PARAM_PASSWORD_IN, 1);
 iscsi_session_attr(fast_abort, ISCSI_PARAM_FAST_ABORT, 0);
 iscsi_session_attr(abort_tmo, ISCSI_PARAM_ABORT_TMO, 0);
 iscsi_session_attr(lu_reset_tmo, ISCSI_PARAM_LU_RESET_TMO, 0);
+iscsi_session_attr(ifacename, ISCSI_PARAM_IFACE_NAME, 0);
+iscsi_session_attr(initiatorname, ISCSI_PARAM_INITIATOR_NAME, 0)
 
 static ssize_t
 show_priv_session_state(struct device *dev, struct device_attribute *attr,
@@ -1875,6 +1877,8 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	SETUP_SESSION_RD_ATTR(fast_abort, ISCSI_FAST_ABORT);
 	SETUP_SESSION_RD_ATTR(abort_tmo, ISCSI_ABORT_TMO);
 	SETUP_SESSION_RD_ATTR(lu_reset_tmo,ISCSI_LU_RESET_TMO);
+	SETUP_SESSION_RD_ATTR(ifacename, ISCSI_IFACE_NAME);
+	SETUP_SESSION_RD_ATTR(initiatorname, ISCSI_INITIATOR_NAME);
 	SETUP_PRIV_SESSION_RD_ATTR(recovery_tmo);
 	SETUP_PRIV_SESSION_RD_ATTR(state);
 
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index a0f13a280e71..16be12f1cbe8 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -257,42 +257,49 @@ enum iscsi_param {
 
 	ISCSI_PARAM_PING_TMO,
 	ISCSI_PARAM_RECV_TMO,
+
+	ISCSI_PARAM_IFACE_NAME,
+	ISCSI_PARAM_ISID,
+	ISCSI_PARAM_INITIATOR_NAME,
 	/* must always be last */
 	ISCSI_PARAM_MAX,
 };
 
-#define ISCSI_MAX_RECV_DLENGTH		(1 &lt;&lt; ISCSI_PARAM_MAX_RECV_DLENGTH)
-#define ISCSI_MAX_XMIT_DLENGTH		(1 &lt;&lt; ISCSI_PARAM_MAX_XMIT_DLENGTH)
-#define ISCSI_HDRDGST_EN		(1 &lt;&lt; ISCSI_PARAM_HDRDGST_EN)
-#define ISCSI_DATADGST_EN		(1 &lt;&lt; ISCSI_PARAM_DATADGST_EN)
-#define ISCSI_INITIAL_R2T_EN		(1 &lt;&lt; ISCSI_PARAM_INITIAL_R2T_EN)
-#define ISCSI_MAX_R2T			(1 &lt;&lt; ISCSI_PARAM_MAX_R2T)
-#define ISCSI_IMM_DATA_EN		(1 &lt;&lt; ISCSI_PARAM_IMM_DATA_EN)
-#define ISCSI_FIRST_BURST		(1 &lt;&lt; ISCSI_PARAM_FIRST_BURST)
-#define ISCSI_MAX_BURST			(1 &lt;&lt; ISCSI_PARAM_MAX_BURST)
-#define ISCSI_PDU_INORDER_EN		(1 &lt;&lt; ISCSI_PARAM_PDU_INORDER_EN)
-#define ISCSI_DATASEQ_INORDER_EN	(1 &lt;&lt; ISCSI_PARAM_DATASEQ_INORDER_EN)
-#define ISCSI_ERL			(1 &lt;&lt; ISCSI_PARAM_ERL)
-#define ISCSI_IFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_IFMARKER_EN)
-#define ISCSI_OFMARKER_EN		(1 &lt;&lt; ISCSI_PARAM_OFMARKER_EN)
-#define ISCSI_EXP_STATSN		(1 &lt;&lt; ISCSI_PARAM_EXP_STATSN)
-#define ISCSI_TARGET_NAME		(1 &lt;&lt; ISCSI_PARAM_TARGET_NAME)
-#define ISCSI_TPGT			(1 &lt;&lt; ISCSI_PARAM_TPGT)
-#define ISCSI_PERSISTENT_ADDRESS	(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_ADDRESS)
-#define ISCSI_PERSISTENT_PORT		(1 &lt;&lt; ISCSI_PARAM_PERSISTENT_PORT)
-#define ISCSI_SESS_RECOVERY_TMO		(1 &lt;&lt; ISCSI_PARAM_SESS_RECOVERY_TMO)
-#define ISCSI_CONN_PORT			(1 &lt;&lt; ISCSI_PARAM_CONN_PORT)
-#define ISCSI_CONN_ADDRESS		(1 &lt;&lt; ISCSI_PARAM_CONN_ADDRESS)
-#define ISCSI_USERNAME			(1 &lt;&lt; ISCSI_PARAM_USERNAME)
-#define ISCSI_USERNAME_IN		(1 &lt;&lt; ISCSI_PARAM_USERNAME_IN)
-#define ISCSI_PASSWORD			(1 &lt;&lt; ISCSI_PARAM_PASSWORD)
-#define ISCSI_PASSWORD_IN		(1 &lt;&lt; ISCSI_PARAM_PASSWORD_IN)
-#define ISCSI_FAST_ABORT		(1 &lt;&lt; ISCSI_PARAM_FAST_ABORT)
-#define ISCSI_ABORT_TMO			(1 &lt;&lt; ISCSI_PARAM_ABORT_TMO)
-#define ISCSI_LU_RESET_TMO		(1 &lt;&lt; ISCSI_PARAM_LU_RESET_TMO)
-#define ISCSI_HOST_RESET_TMO		(1 &lt;&lt; ISCSI_PARAM_HOST_RESET_TMO)
-#define ISCSI_PING_TMO			(1 &lt;&lt; ISCSI_PARAM_PING_TMO)
-#define ISCSI_RECV_TMO			(1 &lt;&lt; ISCSI_PARAM_RECV_TMO)
+#define ISCSI_MAX_RECV_DLENGTH		(1ULL &lt;&lt; ISCSI_PARAM_MAX_RECV_DLENGTH)
+#define ISCSI_MAX_XMIT_DLENGTH		(1ULL &lt;&lt; ISCSI_PARAM_MAX_XMIT_DLENGTH)
+#define ISCSI_HDRDGST_EN		(1ULL &lt;&lt; ISCSI_PARAM_HDRDGST_EN)
+#define ISCSI_DATADGST_EN		(1ULL &lt;&lt; ISCSI_PARAM_DATADGST_EN)
+#define ISCSI_INITIAL_R2T_EN		(1ULL &lt;&lt; ISCSI_PARAM_INITIAL_R2T_EN)
+#define ISCSI_MAX_R2T			(1ULL &lt;&lt; ISCSI_PARAM_MAX_R2T)
+#define ISCSI_IMM_DATA_EN		(1ULL &lt;&lt; ISCSI_PARAM_IMM_DATA_EN)
+#define ISCSI_FIRST_BURST		(1ULL &lt;&lt; ISCSI_PARAM_FIRST_BURST)
+#define ISCSI_MAX_BURST			(1ULL &lt;&lt; ISCSI_PARAM_MAX_BURST)
+#define ISCSI_PDU_INORDER_EN		(1ULL &lt;&lt; ISCSI_PARAM_PDU_INORDER_EN)
+#define ISCSI_DATASEQ_INORDER_EN	(1ULL &lt;&lt; ISCSI_PARAM_DATASEQ_INORDER_EN)
+#define ISCSI_ERL			(1ULL &lt;&lt; ISCSI_PARAM_ERL)
+#define ISCSI_IFMARKER_EN		(1ULL &lt;&lt; ISCSI_PARAM_IFMARKER_EN)
+#define ISCSI_OFMARKER_EN		(1ULL &lt;&lt; ISCSI_PARAM_OFMARKER_EN)
+#define ISCSI_EXP_STATSN		(1ULL &lt;&lt; ISCSI_PARAM_EXP_STATSN)
+#define ISCSI_TARGET_NAME		(1ULL &lt;&lt; ISCSI_PARAM_TARGET_NAME)
+#define ISCSI_TPGT			(1ULL &lt;&lt; ISCSI_PARAM_TPGT)
+#define ISCSI_PERSISTENT_ADDRESS	(1ULL &lt;&lt; ISCSI_PARAM_PERSISTENT_ADDRESS)
+#define ISCSI_PERSISTENT_PORT		(1ULL &lt;&lt; ISCSI_PARAM_PERSISTENT_PORT)
+#define ISCSI_SESS_RECOVERY_TMO		(1ULL &lt;&lt; ISCSI_PARAM_SESS_RECOVERY_TMO)
+#define ISCSI_CONN_PORT			(1ULL &lt;&lt; ISCSI_PARAM_CONN_PORT)
+#define ISCSI_CONN_ADDRESS		(1ULL &lt;&lt; ISCSI_PARAM_CONN_ADDRESS)
+#define ISCSI_USERNAME			(1ULL &lt;&lt; ISCSI_PARAM_USERNAME)
+#define ISCSI_USERNAME_IN		(1ULL &lt;&lt; ISCSI_PARAM_USERNAME_IN)
+#define ISCSI_PASSWORD			(1ULL &lt;&lt; ISCSI_PARAM_PASSWORD)
+#define ISCSI_PASSWORD_IN		(1ULL &lt;&lt; ISCSI_PARAM_PASSWORD_IN)
+#define ISCSI_FAST_ABORT		(1ULL &lt;&lt; ISCSI_PARAM_FAST_ABORT)
+#define ISCSI_ABORT_TMO			(1ULL &lt;&lt; ISCSI_PARAM_ABORT_TMO)
+#define ISCSI_LU_RESET_TMO		(1ULL &lt;&lt; ISCSI_PARAM_LU_RESET_TMO)
+#define ISCSI_HOST_RESET_TMO		(1ULL &lt;&lt; ISCSI_PARAM_HOST_RESET_TMO)
+#define ISCSI_PING_TMO			(1ULL &lt;&lt; ISCSI_PARAM_PING_TMO)
+#define ISCSI_RECV_TMO			(1ULL &lt;&lt; ISCSI_PARAM_RECV_TMO)
+#define ISCSI_IFACE_NAME		(1ULL &lt;&lt; ISCSI_PARAM_IFACE_NAME)
+#define ISCSI_ISID			(1ULL &lt;&lt; ISCSI_PARAM_ISID)
+#define ISCSI_INITIATOR_NAME		(1ULL &lt;&lt; ISCSI_PARAM_INITIATOR_NAME)
 
 /* iSCSI HBA params */
 enum iscsi_host_param {
@@ -303,10 +310,10 @@ enum iscsi_host_param {
 	ISCSI_HOST_PARAM_MAX,
 };
 
-#define ISCSI_HOST_HWADDRESS		(1 &lt;&lt; ISCSI_HOST_PARAM_HWADDRESS)
-#define ISCSI_HOST_INITIATOR_NAME	(1 &lt;&lt; ISCSI_HOST_PARAM_INITIATOR_NAME)
-#define ISCSI_HOST_NETDEV_NAME		(1 &lt;&lt; ISCSI_HOST_PARAM_NETDEV_NAME)
-#define ISCSI_HOST_IPADDRESS		(1 &lt;&lt; ISCSI_HOST_PARAM_IPADDRESS)
+#define ISCSI_HOST_HWADDRESS		(1ULL &lt;&lt; ISCSI_HOST_PARAM_HWADDRESS)
+#define ISCSI_HOST_INITIATOR_NAME	(1ULL &lt;&lt; ISCSI_HOST_PARAM_INITIATOR_NAME)
+#define ISCSI_HOST_NETDEV_NAME		(1ULL &lt;&lt; ISCSI_HOST_PARAM_NETDEV_NAME)
+#define ISCSI_HOST_IPADDRESS		(1ULL &lt;&lt; ISCSI_HOST_PARAM_IPADDRESS)
 
 #define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
 #define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 13c92d7ba969..21cfb1d5483f 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -270,6 +270,8 @@ struct iscsi_session {
 	char			*password;
 	char			*password_in;
 	char			*targetname;
+	char			*ifacename;
+	char			*initiatorname;
 	/* control data */
 	struct iscsi_transport	*tt;
 	struct Scsi_Host	*host;</pre>
    <div class="pagination">
        <a href='5_23.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><span>[24]</span><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_25.html'>Next&gt;&gt;</a>
    <div>
</body>
