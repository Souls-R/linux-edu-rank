<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Georgia Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Georgia Institute of Technology</h1>
    <div class="pagination">
        <a href='27.html'>&lt;&lt;Prev</a><a href='27.html'>1</a><span>[2]</span><a href='27_3.html'>3</a><a href='27_3.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 65ead4ecb2d22a78592263ecba3decbc9df548dd
Author: Anish Bhatt &lt;anish@gatech.edu&gt;
Date:   Tue Sep 29 12:15:48 2015 -0700

    wilc1000 : Remove leftover comment delimiters
    
    Remove leftover comment delimiters that were only partially removed
    in a previous cleanup.
    
    Fixes : c3ca63728ad8 ("staging: wilc1000: remove useless comment")
    Signed-off-by: Anish Bhatt &lt;anish@gatech.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/wilc1000/wilc_wlan.c b/drivers/staging/wilc1000/wilc_wlan.c
index be5e6f964d68..93af5d430f91 100644
--- a/drivers/staging/wilc1000/wilc_wlan.c
+++ b/drivers/staging/wilc1000/wilc_wlan.c
@@ -1637,13 +1637,12 @@ static int wilc_wlan_stop(void)
 		}
 
 	} while (timeout);
-	reg = ((1 &lt;&lt; 0) | (1 &lt;&lt; 1) | (1 &lt;&lt; 2) | (1 &lt;&lt; 3) | (1 &lt;&lt; 8) | (1 &lt;&lt; 9) | (1 &lt;&lt; 26) | (1 &lt;&lt; 29) | (1 &lt;&lt; 30) | (1 &lt;&lt; 31)); /**/
-	/**/
-	p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);                                 /**/
-	reg = ~(1 &lt;&lt; 10);                                                                                               /**/
-	/**/
-	ret = p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);                                 /**/
-/******************************************************************************/
+	reg = ((1 &lt;&lt; 0) | (1 &lt;&lt; 1) | (1 &lt;&lt; 2) | (1 &lt;&lt; 3) | (1 &lt;&lt; 8) | (1 &lt;&lt; 9) | (1 &lt;&lt; 26) | (1 &lt;&lt; 29) | (1 &lt;&lt; 30) | (1 &lt;&lt; 31));
+
+	p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
+	reg = ~(1 &lt;&lt; 10);
+
+	ret = p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
 
 	release_bus(RELEASE_ALLOW_SLEEP);
 </pre><hr><pre>commit 5cfe8c144524f7e1688b41c5dab46722be4a912b
Author: Anish Bhatt &lt;anish@gatech.edu&gt;
Date:   Fri Sep 25 00:45:15 2015 -0700

    wilc1000 : Remove unused macro definitions
    
    Remove all unused TCP_*_MASK macro definitions
    
    Signed-off-by: Anish Bhatt &lt;anish@gatech.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/wilc1000/wilc_wlan.c b/drivers/staging/wilc1000/wilc_wlan.c
index 54d0d7100b02..be5e6f964d68 100644
--- a/drivers/staging/wilc1000/wilc_wlan.c
+++ b/drivers/staging/wilc1000/wilc_wlan.c
@@ -279,9 +279,6 @@ typedef struct {
 struct Ack_session_info *Free_head;
 struct Ack_session_info *Alloc_head;
 
-#define TCP_FIN_MASK		(1 &lt;&lt; 0)
-#define TCP_SYN_MASK		(1 &lt;&lt; 1)
-#define TCP_Ack_MASK		(1 &lt;&lt; 4)
 #define NOT_TCP_ACK			(-1)
 
 #define MAX_TCP_SESSION		25</pre><hr><pre>commit 00b8c95b680791a72b4bb14dc371ff1f1daae39c
Author: Chengyu Song &lt;csong84@gatech.edu&gt;
Date:   Tue Mar 24 20:18:49 2015 -0400

    cifs: potential missing check for posix_lock_file_wait
    
    posix_lock_file_wait may fail under certain circumstances, and its result is
    usually checked/returned. But given the complexity of cifs, I'm not sure if
    the result is intentially left unchecked and always expected to succeed.
    
    Signed-off-by: Chengyu Song &lt;csong84@gatech.edu&gt;
    Acked-by: Jeff Layton &lt;jeff.layton@primarydata.com&gt;
    Signed-off-by: Steve French &lt;smfrench@gmail.com&gt;

diff --git a/fs/cifs/file.c b/fs/cifs/file.c
index 5cfa7129d876..3f50cee79df9 100644
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@ -1552,8 +1552,8 @@ cifs_setlk(struct file *file, struct file_lock *flock, __u32 type,
 		rc = server-&gt;ops-&gt;mand_unlock_range(cfile, flock, xid);
 
 out:
-	if (flock-&gt;fl_flags &amp; FL_POSIX)
-		posix_lock_file_wait(file, flock);
+	if (flock-&gt;fl_flags &amp; FL_POSIX &amp;&amp; !rc)
+		rc = posix_lock_file_wait(file, flock);
 	return rc;
 }
 </pre><hr><pre>commit 27a4e3884e9c6497f96cc28256c3cdaa93d4cf97
Author: Chengyu Song &lt;csong84@gatech.edu&gt;
Date:   Thu Apr 16 12:47:12 2015 -0700

    hfsplus: incorrect return value
    
    In case of memory allocation error, the return should be -ENOMEM, instead
    of -ENOSPC.
    
    Signed-off-by: Chengyu Song &lt;csong84@gatech.edu&gt;
    Reviewed-by: Sergei Antonov &lt;saproj@gmail.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/hfsplus/dir.c b/fs/hfsplus/dir.c
index f0235c1640af..3074609befc3 100644
--- a/fs/hfsplus/dir.c
+++ b/fs/hfsplus/dir.c
@@ -434,7 +434,7 @@ static int hfsplus_symlink(struct inode *dir, struct dentry *dentry,
 {
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(dir-&gt;i_sb);
 	struct inode *inode;
-	int res = -ENOSPC;
+	int res = -ENOMEM;
 
 	mutex_lock(&amp;sbi-&gt;vh_mutex);
 	inode = hfsplus_new_inode(dir-&gt;i_sb, S_IFLNK | S_IRWXUGO);
@@ -476,7 +476,7 @@ static int hfsplus_mknod(struct inode *dir, struct dentry *dentry,
 {
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(dir-&gt;i_sb);
 	struct inode *inode;
-	int res = -ENOSPC;
+	int res = -ENOMEM;
 
 	mutex_lock(&amp;sbi-&gt;vh_mutex);
 	inode = hfsplus_new_inode(dir-&gt;i_sb, mode);</pre><hr><pre>commit 13f244852f1197b623af2d3076fae197d2e038ec
Author: Chengyu Song &lt;csong84@gatech.edu&gt;
Date:   Thu Apr 16 12:46:53 2015 -0700

    hfs: incorrect return values
    
    In case of memory allocation error, the return should be -ENOMEM, instead
    of -ENOSPC.
    
    Signed-off-by: Chengyu Song &lt;csong84@gatech.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/hfs/dir.c b/fs/hfs/dir.c
index 145566851e7a..36d1a6ae7655 100644
--- a/fs/hfs/dir.c
+++ b/fs/hfs/dir.c
@@ -197,7 +197,7 @@ static int hfs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
 
 	inode = hfs_new_inode(dir, &amp;dentry-&gt;d_name, mode);
 	if (!inode)
-		return -ENOSPC;
+		return -ENOMEM;
 
 	res = hfs_cat_create(inode-&gt;i_ino, dir, &amp;dentry-&gt;d_name, inode);
 	if (res) {
@@ -226,7 +226,7 @@ static int hfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 
 	inode = hfs_new_inode(dir, &amp;dentry-&gt;d_name, S_IFDIR | mode);
 	if (!inode)
-		return -ENOSPC;
+		return -ENOMEM;
 
 	res = hfs_cat_create(inode-&gt;i_ino, dir, &amp;dentry-&gt;d_name, inode);
 	if (res) {</pre><hr><pre>commit e2ac55b6a8e337fac7cc59c6f452caac92ab5ee6
Author: Chengyu Song &lt;csong84@gatech.edu&gt;
Date:   Tue Apr 14 15:43:44 2015 -0700

    ocfs2: incorrect check for debugfs returns
    
    debugfs_create_dir and debugfs_create_file may return -ENODEV when debugfs
    is not configured, so the return value should be checked against
    ERROR_VALUE as well, otherwise the later dereference of the dentry pointer
    would crash the kernel.
    
    This patch tries to solve this problem by fixing certain checks. However,
    I have that found other call sites are protected by #ifdef CONFIG_DEBUG_FS.
    In current implementation, if CONFIG_DEBUG_FS is defined, then the above
    two functions will never return any ERROR_VALUE. So another possibility
    to fix this is to surround all the buggy checks/functions with the same
    #ifdef CONFIG_DEBUG_FS. But I'm not sure if this would break any functionality,
    as only OCFS2_FS_STATS declares dependency on DEBUG_FS.
    
    Signed-off-by: Chengyu Song &lt;csong84@gatech.edu&gt;
    Cc: Mark Fasheh &lt;mfasheh@suse.com&gt;
    Cc: Joel Becker &lt;jlbec@evilplan.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/ocfs2/cluster/heartbeat.c b/fs/ocfs2/cluster/heartbeat.c
index 16eff45727ee..8e19b9d7aba8 100644
--- a/fs/ocfs2/cluster/heartbeat.c
+++ b/fs/ocfs2/cluster/heartbeat.c
@@ -1312,7 +1312,9 @@ static int o2hb_debug_init(void)
 	int ret = -ENOMEM;
 
 	o2hb_debug_dir = debugfs_create_dir(O2HB_DEBUG_DIR, NULL);
-	if (!o2hb_debug_dir) {
+	if (IS_ERR_OR_NULL(o2hb_debug_dir)) {
+		ret = o2hb_debug_dir ?
+			PTR_ERR(o2hb_debug_dir) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -1325,7 +1327,9 @@ static int o2hb_debug_init(void)
 						 sizeof(o2hb_live_node_bitmap),
 						 O2NM_MAX_NODES,
 						 o2hb_live_node_bitmap);
-	if (!o2hb_debug_livenodes) {
+	if (IS_ERR_OR_NULL(o2hb_debug_livenodes)) {
+		ret = o2hb_debug_livenodes ?
+			PTR_ERR(o2hb_debug_livenodes) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -1338,7 +1342,9 @@ static int o2hb_debug_init(void)
 						   sizeof(o2hb_live_region_bitmap),
 						   O2NM_MAX_REGIONS,
 						   o2hb_live_region_bitmap);
-	if (!o2hb_debug_liveregions) {
+	if (IS_ERR_OR_NULL(o2hb_debug_liveregions)) {
+		ret = o2hb_debug_liveregions ?
+			PTR_ERR(o2hb_debug_liveregions) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -1352,7 +1358,9 @@ static int o2hb_debug_init(void)
 					  sizeof(o2hb_quorum_region_bitmap),
 					  O2NM_MAX_REGIONS,
 					  o2hb_quorum_region_bitmap);
-	if (!o2hb_debug_quorumregions) {
+	if (IS_ERR_OR_NULL(o2hb_debug_quorumregions)) {
+		ret = o2hb_debug_quorumregions ?
+			PTR_ERR(o2hb_debug_quorumregions) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -1366,7 +1374,9 @@ static int o2hb_debug_init(void)
 					  sizeof(o2hb_failed_region_bitmap),
 					  O2NM_MAX_REGIONS,
 					  o2hb_failed_region_bitmap);
-	if (!o2hb_debug_failedregions) {
+	if (IS_ERR_OR_NULL(o2hb_debug_failedregions)) {
+		ret = o2hb_debug_failedregions ?
+			PTR_ERR(o2hb_debug_failedregions) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -2000,7 +2010,8 @@ static int o2hb_debug_region_init(struct o2hb_region *reg, struct dentry *dir)
 
 	reg-&gt;hr_debug_dir =
 		debugfs_create_dir(config_item_name(&amp;reg-&gt;hr_item), dir);
-	if (!reg-&gt;hr_debug_dir) {
+	if (IS_ERR_OR_NULL(reg-&gt;hr_debug_dir)) {
+		ret = reg-&gt;hr_debug_dir ? PTR_ERR(reg-&gt;hr_debug_dir) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -2013,7 +2024,9 @@ static int o2hb_debug_region_init(struct o2hb_region *reg, struct dentry *dir)
 					  O2HB_DB_TYPE_REGION_LIVENODES,
 					  sizeof(reg-&gt;hr_live_node_bitmap),
 					  O2NM_MAX_NODES, reg);
-	if (!reg-&gt;hr_debug_livenodes) {
+	if (IS_ERR_OR_NULL(reg-&gt;hr_debug_livenodes)) {
+		ret = reg-&gt;hr_debug_livenodes ?
+			PTR_ERR(reg-&gt;hr_debug_livenodes) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -2025,7 +2038,9 @@ static int o2hb_debug_region_init(struct o2hb_region *reg, struct dentry *dir)
 					  sizeof(*(reg-&gt;hr_db_regnum)),
 					  O2HB_DB_TYPE_REGION_NUMBER,
 					  0, O2NM_MAX_NODES, reg);
-	if (!reg-&gt;hr_debug_regnum) {
+	if (IS_ERR_OR_NULL(reg-&gt;hr_debug_regnum)) {
+		ret = reg-&gt;hr_debug_regnum ?
+			PTR_ERR(reg-&gt;hr_debug_regnum) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -2037,7 +2052,9 @@ static int o2hb_debug_region_init(struct o2hb_region *reg, struct dentry *dir)
 					  sizeof(*(reg-&gt;hr_db_elapsed_time)),
 					  O2HB_DB_TYPE_REGION_ELAPSED_TIME,
 					  0, 0, reg);
-	if (!reg-&gt;hr_debug_elapsed_time) {
+	if (IS_ERR_OR_NULL(reg-&gt;hr_debug_elapsed_time)) {
+		ret = reg-&gt;hr_debug_elapsed_time ?
+			PTR_ERR(reg-&gt;hr_debug_elapsed_time) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
@@ -2049,13 +2066,16 @@ static int o2hb_debug_region_init(struct o2hb_region *reg, struct dentry *dir)
 					  sizeof(*(reg-&gt;hr_db_pinned)),
 					  O2HB_DB_TYPE_REGION_PINNED,
 					  0, 0, reg);
-	if (!reg-&gt;hr_debug_pinned) {
+	if (IS_ERR_OR_NULL(reg-&gt;hr_debug_pinned)) {
+		ret = reg-&gt;hr_debug_pinned ?
+			PTR_ERR(reg-&gt;hr_debug_pinned) : -ENOMEM;
 		mlog_errno(ret);
 		goto bail;
 	}
 
-	ret = 0;
+	return 0;
 bail:
+	debugfs_remove_recursive(reg-&gt;hr_debug_dir);
 	return ret;
 }
 
diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c
index 11849a44dc5a..23adcbf374d3 100644
--- a/fs/ocfs2/dlmglue.c
+++ b/fs/ocfs2/dlmglue.c
@@ -2954,7 +2954,7 @@ static int ocfs2_dlm_init_debug(struct ocfs2_super *osb)
 							 osb-&gt;osb_debug_root,
 							 osb,
 							 &amp;ocfs2_dlm_debug_fops);
-	if (!dlm_debug-&gt;d_locking_state) {
+	if (IS_ERR_OR_NULL(dlm_debug-&gt;d_locking_state)) {
 		ret = -EINVAL;
 		mlog(ML_ERROR,
 		     "Unable to create locking state debugfs file.\n");
diff --git a/fs/ocfs2/super.c b/fs/ocfs2/super.c
index 26675185b886..fb43de586791 100644
--- a/fs/ocfs2/super.c
+++ b/fs/ocfs2/super.c
@@ -1112,7 +1112,7 @@ static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)
 
 	osb-&gt;osb_debug_root = debugfs_create_dir(osb-&gt;uuid_str,
 						 ocfs2_debugfs_root);
-	if (!osb-&gt;osb_debug_root) {
+	if (IS_ERR_OR_NULL(osb-&gt;osb_debug_root)) {
 		status = -EINVAL;
 		mlog(ML_ERROR, "Unable to create per-mount debugfs root.\n");
 		goto read_super_error;
@@ -1122,7 +1122,7 @@ static int ocfs2_fill_super(struct super_block *sb, void *data, int silent)
 					    osb-&gt;osb_debug_root,
 					    osb,
 					    &amp;ocfs2_osb_debug_fops);
-	if (!osb-&gt;osb_ctxt) {
+	if (IS_ERR_OR_NULL(osb-&gt;osb_ctxt)) {
 		status = -EINVAL;
 		mlog_errno(status);
 		goto read_super_error;
@@ -1606,8 +1606,9 @@ static int __init ocfs2_init(void)
 	}
 
 	ocfs2_debugfs_root = debugfs_create_dir("ocfs2", NULL);
-	if (!ocfs2_debugfs_root) {
-		status = -ENOMEM;
+	if (IS_ERR_OR_NULL(ocfs2_debugfs_root)) {
+		status = ocfs2_debugfs_root ?
+			PTR_ERR(ocfs2_debugfs_root) : -ENOMEM;
 		mlog(ML_ERROR, "Unable to create ocfs2 debugfs root.\n");
 		goto out4;
 	}</pre><hr><pre>commit 629b8729cc2ca8fde7deb008dab09f3ad19fed52
Author: Chengyu Song &lt;csong84@gatech.edu&gt;
Date:   Wed Mar 25 16:37:07 2015 -0400

    nfsd: NFSD_FAULT_INJECTION depends on DEBUG_FS
    
    NFSD_FAULT_INJECTION depends on DEBUG_FS, otherwise the debugfs_create_*
    interface may return unexpected error -ENODEV, and cause system crash.
    
    Signed-off-by: Chengyu Song &lt;csong84@gatech.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@redhat.com&gt;

diff --git a/fs/nfsd/Kconfig b/fs/nfsd/Kconfig
index 683bf718aead..8b87b7a0eab5 100644
--- a/fs/nfsd/Kconfig
+++ b/fs/nfsd/Kconfig
@@ -107,7 +107,7 @@ config NFSD_V4_SECURITY_LABEL
 
 config NFSD_FAULT_INJECTION
 	bool "NFS server manual fault injection"
-	depends on NFSD_V4 &amp;&amp; DEBUG_KERNEL
+	depends on NFSD_V4 &amp;&amp; DEBUG_KERNEL &amp;&amp; DEBUG_FS
 	help
 	  This option enables support for manually injecting faults
 	  into the NFS server.  This is intended to be used for</pre><hr><pre>commit 7b4ddfa7c9523a19fca30830f8b426964d359da2
Author: Chengyu Song &lt;csong84@gatech.edu&gt;
Date:   Tue Mar 24 09:37:53 2015 -0500

    gfs2: incorrect check for debugfs returns
    
    debugfs_create_dir and debugfs_create_file may return -ENODEV when debugfs
    is not configured, so the return value should be checked against ERROR_VALUE
    as well, otherwise the later dereference of the dentry pointer would crash
    the kernel.
    
    Signed-off-by: Chengyu Song &lt;csong84@gatech.edu&gt;
    Signed-off-by: Bob Peterson &lt;rpeterso@redhat.com&gt;
    Acked-by: Steven Whitehouse &lt;swhiteho@redhat.com&gt;

diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c
index f42dffba056a..0fa8062f85a7 100644
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@ -2047,34 +2047,41 @@ static const struct file_operations gfs2_sbstats_fops = {
 
 int gfs2_create_debugfs_file(struct gfs2_sbd *sdp)
 {
-	sdp-&gt;debugfs_dir = debugfs_create_dir(sdp-&gt;sd_table_name, gfs2_root);
-	if (!sdp-&gt;debugfs_dir)
-		return -ENOMEM;
-	sdp-&gt;debugfs_dentry_glocks = debugfs_create_file("glocks",
-							 S_IFREG | S_IRUGO,
-							 sdp-&gt;debugfs_dir, sdp,
-							 &amp;gfs2_glocks_fops);
-	if (!sdp-&gt;debugfs_dentry_glocks)
+	struct dentry *dent;
+
+	dent = debugfs_create_dir(sdp-&gt;sd_table_name, gfs2_root);
+	if (IS_ERR_OR_NULL(dent))
+		goto fail;
+	sdp-&gt;debugfs_dir = dent;
+
+	dent = debugfs_create_file("glocks",
+				   S_IFREG | S_IRUGO,
+				   sdp-&gt;debugfs_dir, sdp,
+				   &amp;gfs2_glocks_fops);
+	if (IS_ERR_OR_NULL(dent))
 		goto fail;
+	sdp-&gt;debugfs_dentry_glocks = dent;
 
-	sdp-&gt;debugfs_dentry_glstats = debugfs_create_file("glstats",
-							S_IFREG | S_IRUGO,
-							sdp-&gt;debugfs_dir, sdp,
-							&amp;gfs2_glstats_fops);
-	if (!sdp-&gt;debugfs_dentry_glstats)
+	dent = debugfs_create_file("glstats",
+				   S_IFREG | S_IRUGO,
+				   sdp-&gt;debugfs_dir, sdp,
+				   &amp;gfs2_glstats_fops);
+	if (IS_ERR_OR_NULL(dent))
 		goto fail;
+	sdp-&gt;debugfs_dentry_glstats = dent;
 
-	sdp-&gt;debugfs_dentry_sbstats = debugfs_create_file("sbstats",
-							S_IFREG | S_IRUGO,
-							sdp-&gt;debugfs_dir, sdp,
-							&amp;gfs2_sbstats_fops);
-	if (!sdp-&gt;debugfs_dentry_sbstats)
+	dent = debugfs_create_file("sbstats",
+				   S_IFREG | S_IRUGO,
+				   sdp-&gt;debugfs_dir, sdp,
+				   &amp;gfs2_sbstats_fops);
+	if (IS_ERR_OR_NULL(dent))
 		goto fail;
+	sdp-&gt;debugfs_dentry_sbstats = dent;
 
 	return 0;
 fail:
 	gfs2_delete_debugfs_file(sdp);
-	return -ENOMEM;
+	return dent ? PTR_ERR(dent) : -ENOMEM;
 }
 
 void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp)
@@ -2100,6 +2107,8 @@ void gfs2_delete_debugfs_file(struct gfs2_sbd *sdp)
 int gfs2_register_debugfs(void)
 {
 	gfs2_root = debugfs_create_dir("gfs2", NULL);
+	if (IS_ERR(gfs2_root))
+		return PTR_ERR(gfs2_root);
 	return gfs2_root ? 0 : -ENOMEM;
 }
 </pre><hr><pre>commit 26e726afe01c1c82072cf23a5ed89ce25f39d9f2
Author: Chengyu Song &lt;csong84@gatech.edu&gt;
Date:   Tue Mar 24 18:12:56 2015 -0400

    btrfs: incorrect handling for fiemap_fill_next_extent return
    
    fiemap_fill_next_extent returns 0 on success, -errno on error, 1 if this was
    the last extent that will fit in user array. If 1 is returned, the return
    value may eventually returned to user space, which should not happen, according
    to manpage of ioctl.
    
    Signed-off-by: Chengyu Song &lt;csong84@gatech.edu&gt;
    Reviewed-by: David Sterba &lt;dsterba@suse.cz&gt;
    Reviewed-by: Liu Bo &lt;bo.li.liu@oracle.com&gt;
    Signed-off-by: Chris Mason &lt;clm@fb.com&gt;

diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
index d688cfe5d496..782f3bc4651d 100644
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -4514,8 +4514,11 @@ int extent_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 		}
 		ret = fiemap_fill_next_extent(fieinfo, em_start, disko,
 					      em_len, flags);
-		if (ret)
+		if (ret) {
+			if (ret == 1)
+				ret = 0;
 			goto out_free;
+		}
 	}
 out_free:
 	free_extent_map(em);</pre><hr><pre>commit 20dafeefac97d1a690b113f2a954dc84fdf8f290
Author: Byoungyoung Lee &lt;blee@gatech.edu&gt;
Date:   Wed Mar 25 14:57:53 2015 +1100

    xfs: xfs_mru_cache_insert() should use GFP_NOFS
    
    xfs_mru_cache_insert() can be called from within transaction context
    during block allocation like so:
    
    write(2)
      ....
        xfs_get_blocks
          xfs_iomap_write_direct
            start transaction
            xfs_bmapi_write
              xfs_bmapi_allocate
                xfs_bmap_btalloc
                  xfs_bmap_btalloc_filestreams
                    xfs_filestream_new_ag
                      xfs_filestream_pick_ag
                        xfs_mru_cache_insert
                          radix_tree_preload(GFP_KERNEL)
    
    In this case, GFP_KERNEL is incorrect and can potentially lead to
    deadlocks in memory reclaim. It should use GFP_NOFS allocations to
    avoid lock recursion problems.
    
    [dchinner: rewrote commit message]
    
    Signed-off-by: Byoungyoung Lee &lt;blee@gatech.edu&gt;
    Signed-off-by: Sanidhya Kashyap &lt;sanidhya.gatech@gmail.com&gt;
    Reviewed-by: Dave Chinner &lt;dchinner@redhat.com&gt;
    Signed-off-by: Dave Chinner &lt;david@fromorbit.com&gt;

diff --git a/fs/xfs/xfs_mru_cache.c b/fs/xfs/xfs_mru_cache.c
index 30ecca3037e3..f8a674d7f092 100644
--- a/fs/xfs/xfs_mru_cache.c
+++ b/fs/xfs/xfs_mru_cache.c
@@ -437,7 +437,7 @@ xfs_mru_cache_insert(
 	if (!mru || !mru-&gt;lists)
 		return -EINVAL;
 
-	if (radix_tree_preload(GFP_KERNEL))
+	if (radix_tree_preload(GFP_NOFS))
 		return -ENOMEM;
 
 	INIT_LIST_HEAD(&amp;elem-&gt;list_node);</pre>
    <div class="pagination">
        <a href='27.html'>&lt;&lt;Prev</a><a href='27.html'>1</a><span>[2]</span><a href='27_3.html'>3</a><a href='27_3.html'>Next&gt;&gt;</a>
    <div>
</body>
