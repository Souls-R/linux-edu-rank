<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Georgia Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Georgia Institute of Technology</h1>
    <div class="pagination">
        <span>[1]</span><a href='27_2.html'>2</a><a href='27_3.html'>3</a><a href='27_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit fe1c97d008f86f672f0e9265f180c22451ca3b9f
Author: David Ward &lt;david.ward@gatech.edu&gt;
Date:   Mon May 10 05:30:39 2021 -0400

    drm/amd/display: Initialize attribute for hdcp_srm sysfs file
    
    It is stored in dynamically allocated memory, so sysfs_bin_attr_init() must
    be called to initialize it. (Note: "initialization" only sets the .attr.key
    member in this struct; it does not change the value of any other members.)
    
    Otherwise, when CONFIG_DEBUG_LOCK_ALLOC=y this message appears during boot:
    
        BUG: key ffff9248900cd148 has not been registered!
    
    Fixes: 9037246bb2da ("drm/amd/display: Add sysfs interface for set/get srm")
    Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/1586
    Reported-by: Mikhail Gavrilov &lt;mikhail.v.gavrilov@gmail.com&gt;
    Signed-off-by: David Ward &lt;david.ward@gatech.edu&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c
index 616f5b1ea3a8..666796a0067c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c
@@ -650,6 +650,7 @@ struct hdcp_workqueue *hdcp_create_workqueue(struct amdgpu_device *adev, struct
 
 	/* File created at /sys/class/drm/card0/device/hdcp_srm*/
 	hdcp_work[0].attr = data_attr;
+	sysfs_bin_attr_init(&amp;hdcp_work[0].attr);
 
 	if (sysfs_create_bin_file(&amp;adev-&gt;dev-&gt;kobj, &amp;hdcp_work[0].attr))
 		DRM_WARN("Failed to create device file hdcp_srm");</pre><hr><pre>commit 29b25b7067a4fa92afd379ebd7c16b9cbed5e0c0
Author: David Ward &lt;david.ward@gatech.edu&gt;
Date:   Mon May 10 05:30:39 2021 -0400

    drm/amd/display: Initialize attribute for hdcp_srm sysfs file
    
    It is stored in dynamically allocated memory, so sysfs_bin_attr_init() must
    be called to initialize it. (Note: "initialization" only sets the .attr.key
    member in this struct; it does not change the value of any other members.)
    
    Otherwise, when CONFIG_DEBUG_LOCK_ALLOC=y this message appears during boot:
    
        BUG: key ffff9248900cd148 has not been registered!
    
    Fixes: 9037246bb2da ("drm/amd/display: Add sysfs interface for set/get srm")
    Bug: https://gitlab.freedesktop.org/drm/amd/-/issues/1586
    Reported-by: Mikhail Gavrilov &lt;mikhail.v.gavrilov@gmail.com&gt;
    Signed-off-by: David Ward &lt;david.ward@gatech.edu&gt;
    Signed-off-by: Alex Deucher &lt;alexander.deucher@amd.com&gt;

diff --git a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c
index 616f5b1ea3a8..666796a0067c 100644
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_hdcp.c
@@ -650,6 +650,7 @@ struct hdcp_workqueue *hdcp_create_workqueue(struct amdgpu_device *adev, struct
 
 	/* File created at /sys/class/drm/card0/device/hdcp_srm*/
 	hdcp_work[0].attr = data_attr;
+	sysfs_bin_attr_init(&amp;hdcp_work[0].attr);
 
 	if (sysfs_create_bin_file(&amp;adev-&gt;dev-&gt;kobj, &amp;hdcp_work[0].attr))
 		DRM_WARN("Failed to create device file hdcp_srm");</pre><hr><pre>commit aa2f9c12821e6a4ba1df4fb34a3dbc6a2a1ee7fe
Author: David Ward &lt;david.ward@gatech.edu&gt;
Date:   Sun Apr 18 09:46:58 2021 -0400

    ASoC: rt286: Generalize support for ALC3263 codec
    
    The ALC3263 codec on the XPS 13 9343 is also found on the Latitude 13 7350
    and Venue 11 Pro 7140. They require the same handling for the combo jack to
    work with a headset: GPIO pin 6 must be set.
    
    The HDA driver always sets this pin on the ALC3263, which it distinguishes
    by the codec vendor/device ID 0x10ec0288 and PCI subsystem vendor ID 0x1028
    (Dell). The ASoC driver does not use PCI, so adapt this check to use DMI to
    determine if Dell is the system vendor.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=150601
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=205961
    Signed-off-by: David Ward &lt;david.ward@gatech.edu&gt;
    Reviewed-by: Pierre-Louis Bossart &lt;pierre-louis.bossart@linux.intel.com&gt;
    Link: https://lore.kernel.org/r/20210418134658.4333-6-david.ward@gatech.edu
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/codecs/rt286.c b/sound/soc/codecs/rt286.c
index 45e4a48ef5bf..802f4851c3df 100644
--- a/sound/soc/codecs/rt286.c
+++ b/sound/soc/codecs/rt286.c
@@ -1125,12 +1125,11 @@ static const struct dmi_system_id force_combo_jack_table[] = {
 	{ }
 };
 
-static const struct dmi_system_id dmi_dell_dino[] = {
+static const struct dmi_system_id dmi_dell[] = {
 	{
-		.ident = "Dell Dino",
+		.ident = "Dell",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
-			DMI_MATCH(DMI_PRODUCT_NAME, "XPS 13 9343")
 		}
 	},
 	{ }
@@ -1141,7 +1140,7 @@ static int rt286_i2c_probe(struct i2c_client *i2c,
 {
 	struct rt286_platform_data *pdata = dev_get_platdata(&amp;i2c-&gt;dev);
 	struct rt286_priv *rt286;
-	int i, ret, val;
+	int i, ret, vendor_id;
 
 	rt286 = devm_kzalloc(&amp;i2c-&gt;dev,	sizeof(*rt286),
 				GFP_KERNEL);
@@ -1157,14 +1156,15 @@ static int rt286_i2c_probe(struct i2c_client *i2c,
 	}
 
 	ret = regmap_read(rt286-&gt;regmap,
-		RT286_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &amp;val);
+		RT286_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &amp;vendor_id);
 	if (ret != 0) {
 		dev_err(&amp;i2c-&gt;dev, "I2C error %d\n", ret);
 		return ret;
 	}
-	if (val != RT286_VENDOR_ID &amp;&amp; val != RT288_VENDOR_ID) {
+	if (vendor_id != RT286_VENDOR_ID &amp;&amp; vendor_id != RT288_VENDOR_ID) {
 		dev_err(&amp;i2c-&gt;dev,
-			"Device with ID register %#x is not rt286\n", val);
+			"Device with ID register %#x is not rt286\n",
+			vendor_id);
 		return -ENODEV;
 	}
 
@@ -1188,8 +1188,8 @@ static int rt286_i2c_probe(struct i2c_client *i2c,
 	if (pdata)
 		rt286-&gt;pdata = *pdata;
 
-	if (dmi_check_system(force_combo_jack_table) ||
-		dmi_check_system(dmi_dell_dino))
+	if ((vendor_id == RT288_VENDOR_ID &amp;&amp; dmi_check_system(dmi_dell)) ||
+		dmi_check_system(force_combo_jack_table))
 		rt286-&gt;pdata.cbj_en = true;
 
 	regmap_write(rt286-&gt;regmap, RT286_SET_AUDIO_POWER, AC_PWRST_D3);
@@ -1228,7 +1228,7 @@ static int rt286_i2c_probe(struct i2c_client *i2c,
 	regmap_update_bits(rt286-&gt;regmap, RT286_DEPOP_CTRL3, 0xf777, 0x4737);
 	regmap_update_bits(rt286-&gt;regmap, RT286_DEPOP_CTRL4, 0x00ff, 0x003f);
 
-	if (dmi_check_system(dmi_dell_dino)) {
+	if (vendor_id == RT288_VENDOR_ID &amp;&amp; dmi_check_system(dmi_dell)) {
 		regmap_update_bits(rt286-&gt;regmap,
 			RT286_SET_GPIO_MASK, 0x40, 0x40);
 		regmap_update_bits(rt286-&gt;regmap,</pre><hr><pre>commit f3bd4dde9f048fa711e98626c8c3bc4d1eae3436
Author: David Ward &lt;david.ward@gatech.edu&gt;
Date:   Sun Apr 18 09:46:56 2021 -0400

    ASoC: rt298: Configure combo jack for headphones
    
    During jack detection, the combo jack is configured for a CTIA headset, and
    then for an OMTP headset, while sensing the mic connection. If a mic is not
    found in either case, the combo jack should be re-configured for headphones
    only. This is consistent with the HDA driver behavior.
    
    Signed-off-by: David Ward &lt;david.ward@gatech.edu&gt;
    Reviewed-by: Pierre-Louis Bossart &lt;pierre-louis.bossart@linux.intel.com&gt;
    Link: https://lore.kernel.org/r/20210418134658.4333-4-david.ward@gatech.edu
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/codecs/rt298.c b/sound/soc/codecs/rt298.c
index 32cc9b6287d2..c592c40a7ab3 100644
--- a/sound/soc/codecs/rt298.c
+++ b/sound/soc/codecs/rt298.c
@@ -267,11 +267,16 @@ static int rt298_jack_detect(struct rt298_priv *rt298, bool *hp, bool *mic)
 				msleep(300);
 				regmap_read(rt298-&gt;regmap,
 					RT298_CBJ_CTRL2, &amp;val);
-				if (0x0070 == (val &amp; 0x0070))
+				if (0x0070 == (val &amp; 0x0070)) {
 					*mic = true;
-				else
+				} else {
 					*mic = false;
+					regmap_update_bits(rt298-&gt;regmap,
+						RT298_CBJ_CTRL1,
+						0xfcc0, 0xc400);
+				}
 			}
+
 			regmap_update_bits(rt298-&gt;regmap,
 				RT298_DC_GAIN, 0x200, 0x0);
 </pre><hr><pre>commit b15c3ea7e0d2c53b33adc8ca0896de378d6df853
Author: David Ward &lt;david.ward@gatech.edu&gt;
Date:   Sun Apr 18 09:46:55 2021 -0400

    ASoC: rt286: Configure combo jack for headphones
    
    During jack detection, the combo jack is configured for a CTIA headset, and
    then for an OMTP headset, while sensing the mic connection. If a mic is not
    found in either case, the combo jack should be re-configured for headphones
    only. This is consistent with the HDA driver behavior.
    
    Signed-off-by: David Ward &lt;david.ward@gatech.edu&gt;
    Reviewed-by: Pierre-Louis Bossart &lt;pierre-louis.bossart@linux.intel.com&gt;
    Link: https://lore.kernel.org/r/20210418134658.4333-3-david.ward@gatech.edu
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/codecs/rt286.c b/sound/soc/codecs/rt286.c
index e16e7237156f..45e4a48ef5bf 100644
--- a/sound/soc/codecs/rt286.c
+++ b/sound/soc/codecs/rt286.c
@@ -255,11 +255,16 @@ static int rt286_jack_detect(struct rt286_priv *rt286, bool *hp, bool *mic)
 				msleep(300);
 				regmap_read(rt286-&gt;regmap,
 					RT286_CBJ_CTRL2, &amp;val);
-				if (0x0070 == (val &amp; 0x0070))
+				if (0x0070 == (val &amp; 0x0070)) {
 					*mic = true;
-				else
+				} else {
 					*mic = false;
+					regmap_update_bits(rt286-&gt;regmap,
+						RT286_CBJ_CTRL1,
+						0xfcc0, 0xc400);
+				}
 			}
+
 			regmap_update_bits(rt286-&gt;regmap,
 				RT286_DC_GAIN, 0x200, 0x0);
 </pre><hr><pre>commit cd8499d5c03ba260e3191e90236d0e5f6b147563
Author: David Ward &lt;david.ward@gatech.edu&gt;
Date:   Sun Apr 18 09:46:57 2021 -0400

    ASoC: rt286: Make RT286_SET_GPIO_* readable and writable
    
    The GPIO configuration cannot be applied if the registers are inaccessible.
    This prevented the headset mic from working on the Dell XPS 13 9343.
    
    BugLink: https://bugzilla.kernel.org/show_bug.cgi?id=114171
    Signed-off-by: David Ward &lt;david.ward@gatech.edu&gt;
    Link: https://lore.kernel.org/r/20210418134658.4333-5-david.ward@gatech.edu
    Reviewed-by: Pierre-Louis Bossart &lt;pierre-louis.bossart@linux.intel.com&gt;
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/codecs/rt286.c b/sound/soc/codecs/rt286.c
index f9b29782b62a..e16e7237156f 100644
--- a/sound/soc/codecs/rt286.c
+++ b/sound/soc/codecs/rt286.c
@@ -171,6 +171,9 @@ static bool rt286_readable_register(struct device *dev, unsigned int reg)
 	case RT286_PROC_COEF:
 	case RT286_SET_AMP_GAIN_ADC_IN1:
 	case RT286_SET_AMP_GAIN_ADC_IN2:
+	case RT286_SET_GPIO_MASK:
+	case RT286_SET_GPIO_DIRECTION:
+	case RT286_SET_GPIO_DATA:
 	case RT286_SET_POWER(RT286_DAC_OUT1):
 	case RT286_SET_POWER(RT286_DAC_OUT2):
 	case RT286_SET_POWER(RT286_ADC_IN1):</pre><hr><pre>commit dfa7b01dbdc9723ced606425b47005bb583a8778
Author: David Ward &lt;david.ward@gatech.edu&gt;
Date:   Sun Apr 18 09:46:54 2021 -0400

    ASoC: rt286: Fix upper byte in DMIC2 configuration
    
    This HDA verb sets the upper byte of the Configuration Default register, so
    only an 8-bit value should be used. For the rt298, the same fix was applied
    in commit f8f2dc4a7127 ("ASoC: rt298: fix wrong setting of gpio2_en").
    
    Signed-off-by: David Ward &lt;david.ward@gatech.edu&gt;
    Link: https://lore.kernel.org/r/20210418134658.4333-2-david.ward@gatech.edu
    Reviewed-by: Pierre-Louis Bossart &lt;pierre-louis.bossart@linux.intel.com&gt;
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/codecs/rt286.c b/sound/soc/codecs/rt286.c
index 8abe232ca4a4..f9b29782b62a 100644
--- a/sound/soc/codecs/rt286.c
+++ b/sound/soc/codecs/rt286.c
@@ -1204,7 +1204,7 @@ static int rt286_i2c_probe(struct i2c_client *i2c,
 	mdelay(10);
 
 	if (!rt286-&gt;pdata.gpio2_en)
-		regmap_write(rt286-&gt;regmap, RT286_SET_DMIC2_DEFAULT, 0x4000);
+		regmap_write(rt286-&gt;regmap, RT286_SET_DMIC2_DEFAULT, 0x40);
 	else
 		regmap_write(rt286-&gt;regmap, RT286_SET_DMIC2_DEFAULT, 0);
 </pre><hr><pre>commit 9c68ed09fe11cdd45cd84f8dcf634c2ca4075a52
Author: Anish Bhatt &lt;anish@gatech.edu&gt;
Date:   Sun Oct 18 22:51:41 2015 -0700

    rtl8188eu : BIT() macro cleanup
    
    Use the BIT(x) macro directly instead using multiple
    BITX defines.
    
    Signed-off-by: Anish Bhatt &lt;anish@gatech.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtl8188eu/core/rtw_efuse.c b/drivers/staging/rtl8188eu/core/rtw_efuse.c
index 7b99ea91a9e6..685ce98620f1 100644
--- a/drivers/staging/rtl8188eu/core/rtw_efuse.c
+++ b/drivers/staging/rtl8188eu/core/rtw_efuse.c
@@ -396,7 +396,7 @@ u8 Efuse_WordEnableDataWrite(struct adapter *pAdapter, u16 efuse_addr, u8 word_e
 
 	memset((void *)tmpdata, 0xff, PGPKT_DATA_SIZE);
 
-	if (!(word_en&amp;BIT0)) {
+	if (!(word_en &amp; BIT(0))) {
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter, start_addr++, data[0]);
 		efuse_OneByteWrite(pAdapter, start_addr++, data[1]);
@@ -404,9 +404,9 @@ u8 Efuse_WordEnableDataWrite(struct adapter *pAdapter, u16 efuse_addr, u8 word_e
 		efuse_OneByteRead(pAdapter, tmpaddr, &amp;tmpdata[0]);
 		efuse_OneByteRead(pAdapter, tmpaddr+1, &amp;tmpdata[1]);
 		if ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1]))
-			badworden &amp;= (~BIT0);
+			badworden &amp;= (~BIT(0));
 	}
-	if (!(word_en&amp;BIT1)) {
+	if (!(word_en &amp; BIT(1))) {
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter, start_addr++, data[2]);
 		efuse_OneByteWrite(pAdapter, start_addr++, data[3]);
@@ -414,9 +414,9 @@ u8 Efuse_WordEnableDataWrite(struct adapter *pAdapter, u16 efuse_addr, u8 word_e
 		efuse_OneByteRead(pAdapter, tmpaddr, &amp;tmpdata[2]);
 		efuse_OneByteRead(pAdapter, tmpaddr+1, &amp;tmpdata[3]);
 		if ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3]))
-			badworden &amp;= (~BIT1);
+			badworden &amp;= (~BIT(1));
 	}
-	if (!(word_en&amp;BIT2)) {
+	if (!(word_en &amp; BIT(2))) {
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter, start_addr++, data[4]);
 		efuse_OneByteWrite(pAdapter, start_addr++, data[5]);
@@ -424,9 +424,9 @@ u8 Efuse_WordEnableDataWrite(struct adapter *pAdapter, u16 efuse_addr, u8 word_e
 		efuse_OneByteRead(pAdapter, tmpaddr, &amp;tmpdata[4]);
 		efuse_OneByteRead(pAdapter, tmpaddr+1, &amp;tmpdata[5]);
 		if ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5]))
-			badworden &amp;= (~BIT2);
+			badworden &amp;= (~BIT(2));
 	}
-	if (!(word_en&amp;BIT3)) {
+	if (!(word_en &amp; BIT(3))) {
 		tmpaddr = start_addr;
 		efuse_OneByteWrite(pAdapter, start_addr++, data[6]);
 		efuse_OneByteWrite(pAdapter, start_addr++, data[7]);
@@ -434,7 +434,7 @@ u8 Efuse_WordEnableDataWrite(struct adapter *pAdapter, u16 efuse_addr, u8 word_e
 		efuse_OneByteRead(pAdapter, tmpaddr, &amp;tmpdata[6]);
 		efuse_OneByteRead(pAdapter, tmpaddr+1, &amp;tmpdata[7]);
 		if ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7]))
-			badworden &amp;= (~BIT3);
+			badworden &amp;= (~BIT(3));
 	}
 	return badworden;
 }
@@ -738,18 +738,18 @@ static bool wordEnMatched(struct pgpkt *pTargetPkt, struct pgpkt *pCurPkt,
 	u8 match_word_en = 0x0F;	/*  default all words are disabled */
 
 	/*  check if the same words are enabled both target and current PG packet */
-	if (((pTargetPkt-&gt;word_en &amp; BIT0) == 0) &amp;&amp;
-	    ((pCurPkt-&gt;word_en &amp; BIT0) == 0))
-		match_word_en &amp;= ~BIT0;				/*  enable word 0 */
-	if (((pTargetPkt-&gt;word_en &amp; BIT1) == 0) &amp;&amp;
-	    ((pCurPkt-&gt;word_en &amp; BIT1) == 0))
-		match_word_en &amp;= ~BIT1;				/*  enable word 1 */
-	if (((pTargetPkt-&gt;word_en &amp; BIT2) == 0) &amp;&amp;
-	    ((pCurPkt-&gt;word_en &amp; BIT2) == 0))
-		match_word_en &amp;= ~BIT2;				/*  enable word 2 */
-	if (((pTargetPkt-&gt;word_en &amp; BIT3) == 0) &amp;&amp;
-	    ((pCurPkt-&gt;word_en &amp; BIT3) == 0))
-		match_word_en &amp;= ~BIT3;				/*  enable word 3 */
+	if (((pTargetPkt-&gt;word_en &amp; BIT(0)) == 0) &amp;&amp;
+	    ((pCurPkt-&gt;word_en &amp; BIT(0)) == 0))
+		match_word_en &amp;= ~BIT(0);				/*  enable word 0 */
+	if (((pTargetPkt-&gt;word_en &amp; BIT(1)) == 0) &amp;&amp;
+	    ((pCurPkt-&gt;word_en &amp; BIT(1)) == 0))
+		match_word_en &amp;= ~BIT(1);				/*  enable word 1 */
+	if (((pTargetPkt-&gt;word_en &amp; BIT(2)) == 0) &amp;&amp;
+	    ((pCurPkt-&gt;word_en &amp; BIT(2)) == 0))
+		match_word_en &amp;= ~BIT(2);				/*  enable word 2 */
+	if (((pTargetPkt-&gt;word_en &amp; BIT(3)) == 0) &amp;&amp;
+	    ((pCurPkt-&gt;word_en &amp; BIT(3)) == 0))
+		match_word_en &amp;= ~BIT(3);				/*  enable word 3 */
 
 	*pWden = match_word_en;
 
@@ -961,19 +961,19 @@ u8 efuse_OneByteWrite(struct adapter *pAdapter, u16 addr, u8 data)
  */
 void efuse_WordEnableDataRead(u8 word_en, u8 *sourdata, u8 *targetdata)
 {
-	if (!(word_en&amp;BIT(0))) {
+	if (!(word_en &amp; BIT(0))) {
 		targetdata[0] = sourdata[0];
 		targetdata[1] = sourdata[1];
 	}
-	if (!(word_en&amp;BIT(1))) {
+	if (!(word_en &amp; BIT(1))) {
 		targetdata[2] = sourdata[2];
 		targetdata[3] = sourdata[3];
 	}
-	if (!(word_en&amp;BIT(2))) {
+	if (!(word_en &amp; BIT(2))) {
 		targetdata[4] = sourdata[4];
 		targetdata[5] = sourdata[5];
 	}
-	if (!(word_en&amp;BIT(3))) {
+	if (!(word_en &amp; BIT(3))) {
 		targetdata[6] = sourdata[6];
 		targetdata[7] = sourdata[7];
 	}
diff --git a/drivers/staging/rtl8188eu/hal/bb_cfg.c b/drivers/staging/rtl8188eu/hal/bb_cfg.c
index 4eb982bdbfc0..264d7e366246 100644
--- a/drivers/staging/rtl8188eu/hal/bb_cfg.c
+++ b/drivers/staging/rtl8188eu/hal/bb_cfg.c
@@ -705,7 +705,7 @@ bool rtl88eu_phy_bb_config(struct adapter *adapt)
 
 	/*  Enable BB and RF */
 	regval = usb_read16(adapt, REG_SYS_FUNC_EN);
-	usb_write16(adapt, REG_SYS_FUNC_EN, (u16)(regval|BIT13|BIT0|BIT1));
+	usb_write16(adapt, REG_SYS_FUNC_EN, (u16)(regval | BIT(13) | BIT(0) | BIT(1)));
 
 	usb_write8(adapt, REG_RF_CTRL, RF_EN|RF_RSTB|RF_SDMRSTB);
 
diff --git a/drivers/staging/rtl8188eu/hal/odm.c b/drivers/staging/rtl8188eu/hal/odm.c
index 46be4de50629..2c25d3b02036 100644
--- a/drivers/staging/rtl8188eu/hal/odm.c
+++ b/drivers/staging/rtl8188eu/hal/odm.c
@@ -437,7 +437,7 @@ void odm_CommonInfoSelfInit(struct odm_dm_struct *pDM_Odm)
 {
 	struct adapter *adapter = pDM_Odm-&gt;Adapter;
 
-	pDM_Odm-&gt;bCckHighPower = (bool)phy_query_bb_reg(adapter, 0x824, BIT9);
+	pDM_Odm-&gt;bCckHighPower = (bool)phy_query_bb_reg(adapter, 0x824, BIT(9));
 	pDM_Odm-&gt;RFPathRxEnable = (u8)phy_query_bb_reg(adapter, 0xc04, 0x0F);
 
 	ODM_InitDebugSetting(pDM_Odm);
@@ -736,8 +736,8 @@ void odm_FalseAlarmCounterStatistics(struct odm_dm_struct *pDM_Odm)
 		return;
 
 	/* hold ofdm counter */
-	phy_set_bb_reg(adapter, ODM_REG_OFDM_FA_HOLDC_11N, BIT31, 1); /* hold page C counter */
-	phy_set_bb_reg(adapter, ODM_REG_OFDM_FA_RSTD_11N, BIT31, 1); /* hold page D counter */
+	phy_set_bb_reg(adapter, ODM_REG_OFDM_FA_HOLDC_11N, BIT(31), 1); /* hold page C counter */
+	phy_set_bb_reg(adapter, ODM_REG_OFDM_FA_RSTD_11N, BIT(31), 1); /* hold page D counter */
 
 	ret_value = phy_query_bb_reg(adapter, ODM_REG_OFDM_FA_TYPE1_11N, bMaskDWord);
 	FalseAlmCnt-&gt;Cnt_Fast_Fsync = (ret_value&amp;0xffff);
@@ -760,8 +760,8 @@ void odm_FalseAlarmCounterStatistics(struct odm_dm_struct *pDM_Odm)
 	FalseAlmCnt-&gt;Cnt_BW_USC = (ret_value &amp; 0xffff0000)&gt;&gt;16;
 
 	/* hold cck counter */
-	phy_set_bb_reg(adapter, ODM_REG_CCK_FA_RST_11N, BIT12, 1);
-	phy_set_bb_reg(adapter, ODM_REG_CCK_FA_RST_11N, BIT14, 1);
+	phy_set_bb_reg(adapter, ODM_REG_CCK_FA_RST_11N, BIT(12), 1);
+	phy_set_bb_reg(adapter, ODM_REG_CCK_FA_RST_11N, BIT(14), 1);
 
 	ret_value = phy_query_bb_reg(adapter, ODM_REG_CCK_FA_LSB_11N, bMaskByte0);
 	FalseAlmCnt-&gt;Cnt_Cck_fail = ret_value;
@@ -853,7 +853,7 @@ void ODM_RF_Saving(struct odm_dm_struct *pDM_Odm, u8 bForceInNormal)
 	}
 	if (pDM_PSTable-&gt;initialize == 0) {
 		pDM_PSTable-&gt;Reg874 = (phy_query_bb_reg(adapter, 0x874, bMaskDWord)&amp;0x1CC000)&gt;&gt;14;
-		pDM_PSTable-&gt;RegC70 = (phy_query_bb_reg(adapter, 0xc70, bMaskDWord)&amp;BIT3)&gt;&gt;3;
+		pDM_PSTable-&gt;RegC70 = (phy_query_bb_reg(adapter, 0xc70, bMaskDWord) &amp; BIT(3))&gt;&gt;3;
 		pDM_PSTable-&gt;Reg85C = (phy_query_bb_reg(adapter, 0x85c, bMaskDWord)&amp;0xFF000000)&gt;&gt;24;
 		pDM_PSTable-&gt;RegA74 = (phy_query_bb_reg(adapter, 0xa74, bMaskDWord)&amp;0xF000)&gt;&gt;12;
 		pDM_PSTable-&gt;initialize = 1;
@@ -882,18 +882,18 @@ void ODM_RF_Saving(struct odm_dm_struct *pDM_Odm, u8 bForceInNormal)
 	if (pDM_PSTable-&gt;PreRFState != pDM_PSTable-&gt;CurRFState) {
 		if (pDM_PSTable-&gt;CurRFState == RF_Save) {
 			phy_set_bb_reg(adapter, 0x874, 0x1C0000, 0x2); /* Reg874[20:18]=3'b010 */
-			phy_set_bb_reg(adapter, 0xc70, BIT3, 0); /* RegC70[3]=1'b0 */
+			phy_set_bb_reg(adapter, 0xc70, BIT(3), 0); /* RegC70[3]=1'b0 */
 			phy_set_bb_reg(adapter, 0x85c, 0xFF000000, 0x63); /* Reg85C[31:24]=0x63 */
 			phy_set_bb_reg(adapter, 0x874, 0xC000, 0x2); /* Reg874[15:14]=2'b10 */
 			phy_set_bb_reg(adapter, 0xa74, 0xF000, 0x3); /* RegA75[7:4]=0x3 */
-			phy_set_bb_reg(adapter, 0x818, BIT28, 0x0); /* Reg818[28]=1'b0 */
-			phy_set_bb_reg(adapter, 0x818, BIT28, 0x1); /* Reg818[28]=1'b1 */
+			phy_set_bb_reg(adapter, 0x818, BIT(28), 0x0); /* Reg818[28]=1'b0 */
+			phy_set_bb_reg(adapter, 0x818, BIT(28), 0x1); /* Reg818[28]=1'b1 */
 		} else {
 			phy_set_bb_reg(adapter, 0x874, 0x1CC000, pDM_PSTable-&gt;Reg874);
-			phy_set_bb_reg(adapter, 0xc70, BIT3, pDM_PSTable-&gt;RegC70);
+			phy_set_bb_reg(adapter, 0xc70, BIT(3), pDM_PSTable-&gt;RegC70);
 			phy_set_bb_reg(adapter, 0x85c, 0xFF000000, pDM_PSTable-&gt;Reg85C);
 			phy_set_bb_reg(adapter, 0xa74, 0xF000, pDM_PSTable-&gt;RegA74);
-			phy_set_bb_reg(adapter, 0x818, BIT28, 0x0);
+			phy_set_bb_reg(adapter, 0x818, BIT(28), 0x0);
 		}
 		pDM_PSTable-&gt;PreRFState = pDM_PSTable-&gt;CurRFState;
 	}
@@ -1229,7 +1229,7 @@ void odm_TXPowerTrackingCheckCE(struct odm_dm_struct *pDM_Odm)
 		return;
 
 	if (!pDM_Odm-&gt;RFCalibrateInfo.TM_Trigger) {		/* at least delay 1 sec */
-		phy_set_rf_reg(Adapter, RF_PATH_A, RF_T_METER_88E, BIT17 | BIT16, 0x03);
+		phy_set_rf_reg(Adapter, RF_PATH_A, RF_T_METER_88E, BIT(17) | BIT(16), 0x03);
 
 		pDM_Odm-&gt;RFCalibrateInfo.TM_Trigger = 1;
 		return;
diff --git a/drivers/staging/rtl8188eu/hal/odm_HWConfig.c b/drivers/staging/rtl8188eu/hal/odm_HWConfig.c
index 36afe45d1c9a..3dd6cff873d9 100644
--- a/drivers/staging/rtl8188eu/hal/odm_HWConfig.c
+++ b/drivers/staging/rtl8188eu/hal/odm_HWConfig.c
@@ -362,7 +362,7 @@ static void odm_Process_RSSIForDM(struct odm_dm_struct *dm_odm,
 				}
 			}
 
-			pEntry-&gt;rssi_stat.PacketMap = (pEntry-&gt;rssi_stat.PacketMap&lt;&lt;1) | BIT0;
+			pEntry-&gt;rssi_stat.PacketMap = (pEntry-&gt;rssi_stat.PacketMap&lt;&lt;1) | BIT(0);
 
 		} else {
 			RSSI_Ave = pPhyInfo-&gt;RxPWDBAll;
@@ -391,7 +391,7 @@ static void odm_Process_RSSIForDM(struct odm_dm_struct *dm_odm,
 			pEntry-&gt;rssi_stat.ValidBit++;
 
 		for (i = 0; i &lt; pEntry-&gt;rssi_stat.ValidBit; i++)
-			OFDM_pkt += (u8)(pEntry-&gt;rssi_stat.PacketMap&gt;&gt;i)&amp;BIT0;
+			OFDM_pkt += (u8)(pEntry-&gt;rssi_stat.PacketMap&gt;&gt;i) &amp; BIT(0);
 
 		if (pEntry-&gt;rssi_stat.ValidBit == 64) {
 			Weighting = ((OFDM_pkt&lt;&lt;4) &gt; 64) ? 64 : (OFDM_pkt&lt;&lt;4);
diff --git a/drivers/staging/rtl8188eu/hal/odm_RTL8188E.c b/drivers/staging/rtl8188eu/hal/odm_RTL8188E.c
index d3c6873925ba..0be6c051e804 100644
--- a/drivers/staging/rtl8188eu/hal/odm_RTL8188E.c
+++ b/drivers/staging/rtl8188eu/hal/odm_RTL8188E.c
@@ -28,26 +28,26 @@ static void dm_rx_hw_antena_div_init(struct odm_dm_struct *dm_odm)
 
 	if (*(dm_odm-&gt;mp_mode) == 1) {
 		dm_odm-&gt;AntDivType = CGCS_RX_SW_ANTDIV;
-		phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT7, 0);
-		phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT31, 1);
+		phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 0);
+		phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(31), 1);
 		return;
 	}
 
 	/* MAC Setting */
 	value32 = phy_query_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord);
 	phy_set_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord,
-		       value32|(BIT23|BIT25));
+		       value32|(BIT(23) | BIT(25)));
 	/* Pin Settings */
-	phy_set_bb_reg(adapter, ODM_REG_PIN_CTRL_11N, BIT9|BIT8, 0);
-	phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N, BIT10, 0);
-	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT22, 1);
-	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT31, 1);
+	phy_set_bb_reg(adapter, ODM_REG_PIN_CTRL_11N, BIT(9) | BIT(8), 0);
+	phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N, BIT(10), 0);
+	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(22), 1);
+	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(31), 1);
 	/* OFDM Settings */
 	phy_set_bb_reg(adapter, ODM_REG_ANTDIV_PARA1_11N, bMaskDWord,
 		       0x000000a0);
 	/* CCK Settings */
-	phy_set_bb_reg(adapter, ODM_REG_BB_PWR_SAV4_11N, BIT7, 1);
-	phy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA2_11N, BIT4, 1);
+	phy_set_bb_reg(adapter, ODM_REG_BB_PWR_SAV4_11N, BIT(7), 1);
+	phy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA2_11N, BIT(4), 1);
 	rtl88eu_dm_update_rx_idle_ant(dm_odm, MAIN_ANT);
 	phy_set_bb_reg(adapter, ODM_REG_ANT_MAPPING1_11N, 0xFFFF, 0x0201);
 }
@@ -59,37 +59,37 @@ static void dm_trx_hw_antenna_div_init(struct odm_dm_struct *dm_odm)
 
 	if (*(dm_odm-&gt;mp_mode) == 1) {
 		dm_odm-&gt;AntDivType = CGCS_RX_SW_ANTDIV;
-		phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT7, 0);
+		phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 0);
 		phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,
-			       BIT5|BIT4|BIT3, 0);
+			       BIT(5) | BIT(4) | BIT(3), 0);
 		return;
 	}
 
 	/* MAC Setting */
 	value32 = phy_query_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord);
 	phy_set_bb_reg(adapter, ODM_REG_ANTSEL_PIN_11N, bMaskDWord,
-		       value32|(BIT23|BIT25));
+		       value32|(BIT(23) | BIT(25)));
 	/* Pin Settings */
-	phy_set_bb_reg(adapter, ODM_REG_PIN_CTRL_11N, BIT9|BIT8, 0);
-	phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N, BIT10, 0);
-	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT22, 0);
-	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT31, 1);
+	phy_set_bb_reg(adapter, ODM_REG_PIN_CTRL_11N, BIT(9) | BIT(8), 0);
+	phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N, BIT(10), 0);
+	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(22), 0);
+	phy_set_bb_reg(adapter, ODM_REG_LNA_SWITCH_11N, BIT(31), 1);
 	/* OFDM Settings */
 	phy_set_bb_reg(adapter, ODM_REG_ANTDIV_PARA1_11N, bMaskDWord,
 		       0x000000a0);
 	/* CCK Settings */
-	phy_set_bb_reg(adapter, ODM_REG_BB_PWR_SAV4_11N, BIT7, 1);
-	phy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA2_11N, BIT4, 1);
+	phy_set_bb_reg(adapter, ODM_REG_BB_PWR_SAV4_11N, BIT(7), 1);
+	phy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA2_11N, BIT(4), 1);
 	/* Tx Settings */
-	phy_set_bb_reg(adapter, ODM_REG_TX_ANT_CTRL_11N, BIT21, 0);
+	phy_set_bb_reg(adapter, ODM_REG_TX_ANT_CTRL_11N, BIT(21), 0);
 	rtl88eu_dm_update_rx_idle_ant(dm_odm, MAIN_ANT);
 
 	/* antenna mapping table */
 	if (!dm_odm-&gt;bIsMPChip) { /* testchip */
 		phy_set_bb_reg(adapter, ODM_REG_RX_DEFUALT_A_11N,
-			       BIT10|BIT9|BIT8, 1);
+			       BIT(10) | BIT(9) | BIT(8), 1);
 		phy_set_bb_reg(adapter, ODM_REG_RX_DEFUALT_A_11N,
-			       BIT13|BIT12|BIT11, 2);
+			       BIT(13) | BIT(12) | BIT(11), 2);
 	} else { /* MPchip */
 		phy_set_bb_reg(adapter, ODM_REG_ANT_MAPPING1_11N, bMaskDWord,
 			       0x0201);
@@ -118,40 +118,40 @@ static void dm_fast_training_init(struct odm_dm_struct *dm_odm)
 
 	/* MAC Setting */
 	value32 = phy_query_bb_reg(adapter, 0x4c, bMaskDWord);
-	phy_set_bb_reg(adapter, 0x4c, bMaskDWord, value32|(BIT23|BIT25));
+	phy_set_bb_reg(adapter, 0x4c, bMaskDWord, value32|(BIT(23) | BIT(25)));
 	value32 = phy_query_bb_reg(adapter,  0x7B4, bMaskDWord);
-	phy_set_bb_reg(adapter, 0x7b4, bMaskDWord, value32|(BIT16|BIT17));
+	phy_set_bb_reg(adapter, 0x7b4, bMaskDWord, value32|(BIT(16) | BIT(17)));
 
 	/* Match MAC ADDR */
 	phy_set_bb_reg(adapter, 0x7b4, 0xFFFF, 0);
 	phy_set_bb_reg(adapter, 0x7b0, bMaskDWord, 0);
 
-	phy_set_bb_reg(adapter, 0x870, BIT9|BIT8, 0);
-	phy_set_bb_reg(adapter, 0x864, BIT10, 0);
-	phy_set_bb_reg(adapter, 0xb2c, BIT22, 0);
-	phy_set_bb_reg(adapter, 0xb2c, BIT31, 1);
+	phy_set_bb_reg(adapter, 0x870, BIT(9) | BIT(8), 0);
+	phy_set_bb_reg(adapter, 0x864, BIT(10), 0);
+	phy_set_bb_reg(adapter, 0xb2c, BIT(22), 0);
+	phy_set_bb_reg(adapter, 0xb2c, BIT(31), 1);
 	phy_set_bb_reg(adapter, 0xca4, bMaskDWord, 0x000000a0);
 
 	/* antenna mapping table */
 	if (AntCombination == 2) {
 		if (!dm_odm-&gt;bIsMPChip) { /* testchip */
-			phy_set_bb_reg(adapter, 0x858, BIT10|BIT9|BIT8, 1);
-			phy_set_bb_reg(adapter, 0x858, BIT13|BIT12|BIT11, 2);
+			phy_set_bb_reg(adapter, 0x858, BIT(10) | BIT(9) | BIT(8), 1);
+			phy_set_bb_reg(adapter, 0x858, BIT(13) | BIT(12) | BIT(11), 2);
 		} else { /* MPchip */
 			phy_set_bb_reg(adapter, 0x914, bMaskByte0, 1);
 			phy_set_bb_reg(adapter, 0x914, bMaskByte1, 2);
 		}
 	} else if (AntCombination == 7) {
 		if (!dm_odm-&gt;bIsMPChip) { /* testchip */
-			phy_set_bb_reg(adapter, 0x858, BIT10|BIT9|BIT8, 0);
-			phy_set_bb_reg(adapter, 0x858, BIT13|BIT12|BIT11, 1);
-			phy_set_bb_reg(adapter, 0x878, BIT16, 0);
-			phy_set_bb_reg(adapter, 0x858, BIT15|BIT14, 2);
-			phy_set_bb_reg(adapter, 0x878, BIT19|BIT18|BIT17, 3);
-			phy_set_bb_reg(adapter, 0x878, BIT22|BIT21|BIT20, 4);
-			phy_set_bb_reg(adapter, 0x878, BIT25|BIT24|BIT23, 5);
-			phy_set_bb_reg(adapter, 0x878, BIT28|BIT27|BIT26, 6);
-			phy_set_bb_reg(adapter, 0x878, BIT31|BIT30|BIT29, 7);
+			phy_set_bb_reg(adapter, 0x858, BIT(10) | BIT(9) | BIT(8), 0);
+			phy_set_bb_reg(adapter, 0x858, BIT(13) | BIT(12) | BIT(11), 1);
+			phy_set_bb_reg(adapter, 0x878, BIT(16), 0);
+			phy_set_bb_reg(adapter, 0x858, BIT(15) | BIT(14), 2);
+			phy_set_bb_reg(adapter, 0x878, BIT(19) | BIT(18) | BIT(17), 3);
+			phy_set_bb_reg(adapter, 0x878, BIT(22) | BIT(21) | BIT(20), 4);
+			phy_set_bb_reg(adapter, 0x878, BIT(25) | BIT(24) | BIT(23), 5);
+			phy_set_bb_reg(adapter, 0x878, BIT(28) | BIT(27) | BIT(26), 6);
+			phy_set_bb_reg(adapter, 0x878, BIT(31) | BIT(30) | BIT(29), 7);
 		} else { /* MPchip */
 			phy_set_bb_reg(adapter, 0x914, bMaskByte0, 0);
 			phy_set_bb_reg(adapter, 0x914, bMaskByte1, 1);
@@ -165,13 +165,13 @@ static void dm_fast_training_init(struct odm_dm_struct *dm_odm)
 	}
 
 	/* Default Ant Setting when no fast training */
-	phy_set_bb_reg(adapter, 0x80c, BIT21, 1);
-	phy_set_bb_reg(adapter, 0x864, BIT5|BIT4|BIT3, 0);
-	phy_set_bb_reg(adapter, 0x864, BIT8|BIT7|BIT6, 1);
+	phy_set_bb_reg(adapter, 0x80c, BIT(21), 1);
+	phy_set_bb_reg(adapter, 0x864, BIT(5) | BIT(4) | BIT(3), 0);
+	phy_set_bb_reg(adapter, 0x864, BIT(8) | BIT(7) | BIT(6), 1);
 
 	/* Enter Traing state */
-	phy_set_bb_reg(adapter, 0x864, BIT2|BIT1|BIT0, (AntCombination-1));
-	phy_set_bb_reg(adapter, 0xc50, BIT7, 1);
+	phy_set_bb_reg(adapter, 0x864, BIT(2) | BIT(1) | BIT(0), (AntCombination-1));
+	phy_set_bb_reg(adapter, 0xc50, BIT(7), 1);
 }
 
 void rtl88eu_dm_antenna_div_init(struct odm_dm_struct *dm_odm)
@@ -205,18 +205,18 @@ void rtl88eu_dm_update_rx_idle_ant(struct odm_dm_struct *dm_odm, u8 ant)
 
 		if (dm_odm-&gt;AntDivType == CG_TRX_HW_ANTDIV) {
 			phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,
-				       BIT5|BIT4|BIT3, default_ant);
+				       BIT(5) | BIT(4) | BIT(3), default_ant);
 			phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,
-				       BIT8|BIT7|BIT6, optional_ant);
+				       BIT(8) | BIT(7) | BIT(6), optional_ant);
 			phy_set_bb_reg(adapter, ODM_REG_ANTSEL_CTRL_11N,
-				       BIT14|BIT13|BIT12, default_ant);
+				       BIT(14) | BIT(13) | BIT(12), default_ant);
 			phy_set_bb_reg(adapter, ODM_REG_RESP_TX_11N,
-				       BIT6|BIT7, default_ant);
+				       BIT(6) | BIT(7), default_ant);
 		} else if (dm_odm-&gt;AntDivType == CGCS_RX_HW_ANTDIV) {
 			phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,
-				       BIT5|BIT4|BIT3, default_ant);
+				       BIT(5) | BIT(4) | BIT(3), default_ant);
 			phy_set_bb_reg(adapter, ODM_REG_RX_ANT_CTRL_11N,
-				       BIT8|BIT7|BIT6, optional_ant);
+				       BIT(8) | BIT(7) | BIT(6), optional_ant);
 		}
 	}
 	dm_fat_tbl-&gt;RxIdleAnt = ant;
@@ -231,9 +231,9 @@ static void update_tx_ant_88eu(struct odm_dm_struct *dm_odm, u8 ant, u32 mac_id)
 		target_ant = MAIN_ANT_CG_TRX;
 	else
 		target_ant = AUX_ANT_CG_TRX;
-	dm_fat_tbl-&gt;antsel_a[mac_id] = target_ant&amp;BIT0;
-	dm_fat_tbl-&gt;antsel_b[mac_id] = (target_ant&amp;BIT1)&gt;&gt;1;
-	dm_fat_tbl-&gt;antsel_c[mac_id] = (target_ant&amp;BIT2)&gt;&gt;2;
+	dm_fat_tbl-&gt;antsel_a[mac_id] = target_ant &amp; BIT(0);
+	dm_fat_tbl-&gt;antsel_b[mac_id] = (target_ant &amp; BIT(1))&gt;&gt;1;
+	dm_fat_tbl-&gt;antsel_c[mac_id] = (target_ant &amp; BIT(2))&gt;&gt;2;
 }
 
 void rtl88eu_dm_set_tx_ant_by_tx_info(struct odm_dm_struct *dm_odm,
@@ -344,12 +344,12 @@ void rtl88eu_dm_antenna_diversity(struct odm_dm_struct *dm_odm)
 		if (dm_fat_tbl-&gt;bBecomeLinked) {
 			ODM_RT_TRACE(dm_odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
 				     ("Need to Turn off HW AntDiv\n"));
-			phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT7, 0);
+			phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 0);
 			phy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA1_11N,
-				       BIT15, 0);
+				       BIT(15), 0);
 			if (dm_odm-&gt;AntDivType == CG_TRX_HW_ANTDIV)
 				phy_set_bb_reg(adapter, ODM_REG_TX_ANT_CTRL_11N,
-					       BIT21, 0);
+					       BIT(21), 0);
 			dm_fat_tbl-&gt;bBecomeLinked = dm_odm-&gt;bLinked;
 		}
 		return;
@@ -357,12 +357,12 @@ void rtl88eu_dm_antenna_diversity(struct odm_dm_struct *dm_odm)
 		if (!dm_fat_tbl-&gt;bBecomeLinked) {
 			ODM_RT_TRACE(dm_odm, ODM_COMP_ANT_DIV, ODM_DBG_LOUD,
 				     ("Need to Turn on HW AntDiv\n"));
-			phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT7, 1);
+			phy_set_bb_reg(adapter, ODM_REG_IGI_A_11N, BIT(7), 1);
 			phy_set_bb_reg(adapter, ODM_REG_CCK_ANTDIV_PARA1_11N,
-				       BIT15, 1);
+				       BIT(15), 1);
 			if (dm_odm-&gt;AntDivType == CG_TRX_HW_ANTDIV)
 				phy_set_bb_reg(adapter, ODM_REG_TX_ANT_CTRL_11N,
-					       BIT21, 1);
+					       BIT(21), 1);
 			dm_fat_tbl-&gt;bBecomeLinked = dm_odm-&gt;bLinked;
 		}
 	}
diff --git a/drivers/staging/rtl8188eu/hal/phy.c b/drivers/staging/rtl8188eu/hal/phy.c
index 2eafa503f343..bb3c7773d74f 100644
--- a/drivers/staging/rtl8188eu/hal/phy.c
+++ b/drivers/staging/rtl8188eu/hal/phy.c
@@ -97,9 +97,9 @@ static u32 rf_serial_read(struct adapter *adapt,
 	udelay(10);
 
 	if (rfpath == RF_PATH_A)
-		rfpi_enable = (u8)phy_query_bb_reg(adapt, rFPGA0_XA_HSSIParameter1, BIT8);
+		rfpi_enable = (u8)phy_query_bb_reg(adapt, rFPGA0_XA_HSSIParameter1, BIT(8));
 	else if (rfpath == RF_PATH_B)
-		rfpi_enable = (u8)phy_query_bb_reg(adapt, rFPGA0_XB_HSSIParameter1, BIT8);
+		rfpi_enable = (u8)phy_query_bb_reg(adapt, rFPGA0_XB_HSSIParameter1, BIT(8));
 
 	if (rfpi_enable)
 		ret = phy_query_bb_reg(adapt, phyreg-&gt;rfLSSIReadBackPi,
@@ -293,7 +293,7 @@ static void phy_set_bw_mode_callback(struct adapter *adapt)
 		    (hal_data-&gt;nCur40MhzPrimeSC&gt;&gt;1));
 		phy_set_bb_reg(adapt, rOFDM1_LSTF, 0xC00,
 			       hal_data-&gt;nCur40MhzPrimeSC);
-		phy_set_bb_reg(adapt, 0x818, (BIT26 | BIT27),
+		phy_set_bb_reg(adapt, 0x818, (BIT(26) | BIT(27)),
 		   (hal_data-&gt;nCur40MhzPrimeSC == HAL_PRIME_CHNL_OFFSET_LOWER) ? 2 : 1);
 		break;
 	default:
@@ -652,7 +652,7 @@ static u8 phy_path_a_iqk(struct adapter *adapt, bool config_pathb)
 	reg_e94 = phy_query_bb_reg(adapt, rTx_Power_Before_IQK_A, bMaskDWord);
 	reg_e9c = phy_query_bb_reg(adapt, rTx_Power_After_IQK_A, bMaskDWord);
 
-	if (!(reg_eac &amp; BIT28) &amp;&amp;
+	if (!(reg_eac &amp; BIT(28)) &amp;&amp;
 	    (((reg_e94 &amp; 0x03FF0000)&gt;&gt;16) != 0x142) &amp;&amp;
 	    (((reg_e9c &amp; 0x03FF0000)&gt;&gt;16) != 0x42))
 		result |= 0x01;
@@ -705,7 +705,7 @@ static u8 phy_path_a_rx_iqk(struct adapter *adapt, bool configPathB)
 	reg_e94 = phy_query_bb_reg(adapt, rTx_Power_Before_IQK_A, bMaskDWord);
 	reg_e9c = phy_query_bb_reg(adapt, rTx_Power_After_IQK_A, bMaskDWord);
 
-	if (!(reg_eac &amp; BIT28) &amp;&amp;
+	if (!(reg_eac &amp; BIT(28)) &amp;&amp;
 	    (((reg_e94 &amp; 0x03FF0000)&gt;&gt;16) != 0x142) &amp;&amp;
 	    (((reg_e9c &amp; 0x03FF0000)&gt;&gt;16) != 0x42))
 		result |= 0x01;
@@ -753,7 +753,7 @@ static u8 phy_path_a_rx_iqk(struct adapter *adapt, bool configPathB)
 	phy_set_bb_reg(adapt, rFPGA0_IQK, bMaskDWord, 0x00000000);
 	phy_set_rf_reg(adapt, RF_PATH_A, 0xdf, bRFRegOffsetMask, 0x180);
 
-	if (!(reg_eac &amp; BIT27) &amp;&amp; /* if Tx is OK, check whether Rx is OK */
+	if (!(reg_eac &amp; BIT(27)) &amp;&amp; /* if Tx is OK, check whether Rx is OK */
 	    (((reg_ea4 &amp; 0x03FF0000)&gt;&gt;16) != 0x132) &amp;&amp;
 	    (((reg_eac &amp; 0x03FF0000)&gt;&gt;16) != 0x36))
 		result |= 0x02;
@@ -783,14 +783,14 @@ static u8 phy_path_b_iqk(struct adapter *adapt)
 	regec4 = phy_query_bb_reg(adapt, rRx_Power_Before_IQK_B_2, bMaskDWord);
 	regecc = phy_query_bb_reg(adapt, rRx_Power_After_IQK_B_2, bMaskDWord);
 
-	if (!(regeac &amp; BIT31) &amp;&amp;
+	if (!(regeac &amp; BIT(31)) &amp;&amp;
 	    (((regeb4 &amp; 0x03FF0000)&gt;&gt;16) != 0x142) &amp;&amp;
 	    (((regebc &amp; 0x03FF0000)&gt;&gt;16) != 0x42))
 		result |= 0x01;
 	else
 		return result;
 
-	if (!(regeac &amp; BIT30) &amp;&amp;
+	if (!(regeac &amp; BIT(30)) &amp;&amp;
 	    (((regec4 &amp; 0x03FF0000)&gt;&gt;16) != 0x132) &amp;&amp;
 	    (((regecc &amp; 0x03FF0000)&gt;&gt;16) != 0x36))
 		result |= 0x02;
@@ -959,9 +959,9 @@ static void mac_setting_calibration(struct adapter *adapt, u32 *mac_reg, u32 *ba
 	usb_write8(adapt, mac_reg[i], 0x3F);
 
 	for (i = 1; i &lt; (IQK_MAC_REG_NUM - 1); i++) {
-		usb_write8(adapt, mac_reg[i], (u8)(backup[i]&amp;(~BIT3)));
+		usb_write8(adapt, mac_reg[i], (u8)(backup[i]&amp;(~BIT(3))));
 	}
-	usb_write8(adapt, mac_reg[i], (u8)(backup[i]&amp;(~BIT5)));
+	usb_write8(adapt, mac_reg[i], (u8)(backup[i]&amp;(~BIT(5))));
 }
 
 static void path_a_standby(struct adapter *adapt)
@@ -1117,15 +1117,15 @@ static void phy_iq_calibrate(struct adapter *adapt, s32 result[][8],
 	}
 
 	/* BB setting */
-	phy_set_bb_reg(adapt, rFPGA0_RFMOD, BIT24, 0x00);
+	phy_set_bb_reg(adapt, rFPGA0_RFMOD, BIT(24), 0x00);
 	phy_set_bb_reg(adapt, rOFDM0_TRxPathEnable, bMaskDWord, 0x03a05600);
 	phy_set_bb_reg(adapt, rOFDM0_TRMuxPar, bMaskDWord, 0x000800e4);
 	phy_set_bb_reg(adapt, rFPGA0_XCD_RFInterfaceSW, bMaskDWord, 0x22204000);
 
-	phy_set_bb_reg(adapt, rFPGA0_XAB_RFInterfaceSW, BIT10, 0x01);
-	phy_set_bb_reg(adapt, rFPGA0_XAB_RFInterfaceSW, BIT26, 0x01);
-	phy_set_bb_reg(adapt, rFPGA0_XA_RFInterfaceOE, BIT10, 0x00);
-	phy_set_bb_reg(adapt, rFPGA0_XB_RFInterfaceOE, BIT10, 0x00);
+	phy_set_bb_reg(adapt, rFPGA0_XAB_RFInterfaceSW, BIT(10), 0x01);
+	phy_set_bb_reg(adapt, rFPGA0_XAB_RFInterfaceSW, BIT(26), 0x01);
+	phy_set_bb_reg(adapt, rFPGA0_XA_RFInterfaceOE, BIT(10), 0x00);
+	phy_set_bb_reg(adapt, rFPGA0_XB_RFInterfaceOE, BIT(10), 0x00);
 
 	if (is2t) {
 		phy_set_bb_reg(adapt, rFPGA0_XA_LSSIParameter, bMaskDWord,
diff --git a/drivers/staging/rtl8188eu/hal/rtl8188e_cmd.c b/drivers/staging/rtl8188eu/hal/rtl8188e_cmd.c
index d5281409168d..2d88c5a44439 100644
--- a/drivers/staging/rtl8188eu/hal/rtl8188e_cmd.c
+++ b/drivers/staging/rtl8188eu/hal/rtl8188e_cmd.c
@@ -149,7 +149,7 @@ void rtl8188e_Add_RateATid(struct adapter *pAdapter, u32 bitmap, u8 arg, u8 rssi
 
 	init_rate = get_highest_rate_idx(bitmap&amp;0x0fffffff)&amp;0x3f;
 
-	shortGIrate = (arg&amp;BIT(5)) ? true : false;
+	shortGIrate = (arg &amp; BIT(5)) ? true : false;
 
 	if (shortGIrate)
 		init_rate |= BIT(6);
@@ -577,23 +577,23 @@ void rtl8188e_set_FwJoinBssReport_cmd(struct adapter *adapt, u8 mstatus)
 		/*  Do not set TSF again here or vWiFi beacon DMA INT will not work. */
 
 		/* Set REG_CR bit 8. DMA beacon by SW. */
-		haldata-&gt;RegCR_1 |= BIT0;
+		haldata-&gt;RegCR_1 |= BIT(0);
 		usb_write8(adapt,  REG_CR+1, haldata-&gt;RegCR_1);
 
 		/*  Disable Hw protection for a time which revserd for Hw sending beacon. */
 		/*  Fix download reserved page packet fail that access collision with the protection time. */
 		/*  2010.05.11. Added by tynli. */
 		usb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)&amp;(~BIT(3)));
-		usb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)|BIT(4));
+		usb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL) | BIT(4));
 
-		if (haldata-&gt;RegFwHwTxQCtrl&amp;BIT6) {
+		if (haldata-&gt;RegFwHwTxQCtrl &amp; BIT(6)) {
 			DBG_88E("HalDownloadRSVDPage(): There is an Adapter is sending beacon.\n");
 			bSendBeacon = true;
 		}
 
 		/*  Set FWHW_TXQ_CTRL 0x422[6]=0 to tell Hw the packet is not a real beacon frame. */
-		usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl&amp;(~BIT6)));
-		haldata-&gt;RegFwHwTxQCtrl &amp;= (~BIT6);
+		usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl&amp;(~BIT(6))));
+		haldata-&gt;RegFwHwTxQCtrl &amp;= (~BIT(6));
 
 		/*  Clear beacon valid check bit. */
 		rtw_hal_set_hwreg(adapt, HW_VAR_BCN_VALID, NULL);
@@ -626,7 +626,7 @@ void rtl8188e_set_FwJoinBssReport_cmd(struct adapter *adapt, u8 mstatus)
 		/*  */
 
 		/*  Enable Bcn */
-		usb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)|BIT(3));
+		usb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL) | BIT(3));
 		usb_write8(adapt, REG_BCN_CTRL, usb_read8(adapt, REG_BCN_CTRL)&amp;(~BIT(4)));
 
 		/*  To make sure that if there exists an adapter which would like to send beacon. */
@@ -635,8 +635,8 @@ void rtl8188e_set_FwJoinBssReport_cmd(struct adapter *adapt, u8 mstatus)
 		/*  the beacon cannot be sent by HW. */
 		/*  2010.06.23. Added by tynli. */
 		if (bSendBeacon) {
-			usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl|BIT6));
-			haldata-&gt;RegFwHwTxQCtrl |= BIT6;
+			usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl | BIT(6)));
+			haldata-&gt;RegFwHwTxQCtrl |= BIT(6);
 		}
 
 		/*  Update RSVD page location H2C to Fw. */
@@ -647,7 +647,7 @@ void rtl8188e_set_FwJoinBssReport_cmd(struct adapter *adapt, u8 mstatus)
 
 		/*  Do not enable HW DMA BCN or it will cause Pcie interface hang by timing issue. 2011.11.24. by tynli. */
 		/*  Clear CR[8] or beacon packet will not be send to TxBuf anymore. */
-		haldata-&gt;RegCR_1 &amp;= (~BIT0);
+		haldata-&gt;RegCR_1 &amp;= (~BIT(0));
 		usb_write8(adapt,  REG_CR+1, haldata-&gt;RegCR_1);
 	}
 }
diff --git a/drivers/staging/rtl8188eu/hal/rtl8188e_hal_init.c b/drivers/staging/rtl8188eu/hal/rtl8188e_hal_init.c
index a6295ca6a73e..29353bf1884e 100644
--- a/drivers/staging/rtl8188eu/hal/rtl8188e_hal_init.c
+++ b/drivers/staging/rtl8188eu/hal/rtl8188e_hal_init.c
@@ -106,8 +106,8 @@ void _8051Reset88E(struct adapter *padapter)
 	u8 u1bTmp;
 
 	u1bTmp = usb_read8(padapter, REG_SYS_FUNC_EN+1);
-	usb_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp&amp;(~BIT2));
-	usb_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp|(BIT2));
+	usb_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp&amp;(~BIT(2)));
+	usb_write8(padapter, REG_SYS_FUNC_EN+1, u1bTmp|(BIT(2)));
 	DBG_88E("=====&gt; _8051Reset88E(): 8051 reset success .\n");
 }
 
@@ -184,10 +184,10 @@ static void hal_notch_filter_8188e(struct adapter *adapter, bool enable)
 {
 	if (enable) {
 		DBG_88E("Enable notch filter\n");
-		usb_write8(adapter, rOFDM0_RxDSP+1, usb_read8(adapter, rOFDM0_RxDSP+1) | BIT1);
+		usb_write8(adapter, rOFDM0_RxDSP+1, usb_read8(adapter, rOFDM0_RxDSP+1) | BIT(1));
 	} else {
 		DBG_88E("Disable notch filter\n");
-		usb_write8(adapter, rOFDM0_RxDSP+1, usb_read8(adapter, rOFDM0_RxDSP+1) &amp; ~BIT1);
+		usb_write8(adapter, rOFDM0_RxDSP+1, usb_read8(adapter, rOFDM0_RxDSP+1) &amp; ~BIT(1));
 	}
 }
 void rtl8188e_set_hal_ops(struct hal_ops *pHalFunc)
@@ -372,7 +372,7 @@ static void Hal_ReadPowerValueFromPROM_8188E(struct txpowerinfo24g *pwrInfo24G,
 					pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] = EEPROM_DEFAULT_24G_HT20_DIFF;
 				} else {
 					pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] = (PROMContent[eeAddr]&amp;0xf0)&gt;&gt;4;
-					if (pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] &amp; BIT3)		/* 4bit sign number to 8 bit sign number */
+					if (pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] &amp; BIT(3))		/* 4bit sign number to 8 bit sign number */
 						pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] |= 0xF0;
 				}
 
@@ -380,7 +380,7 @@ static void Hal_ReadPowerValueFromPROM_8188E(struct txpowerinfo24g *pwrInfo24G,
 					pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] =	EEPROM_DEFAULT_24G_OFDM_DIFF;
 				} else {
 					pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] =	(PROMContent[eeAddr]&amp;0x0f);
-					if (pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] &amp; BIT3)		/* 4bit sign number to 8 bit sign number */
+					if (pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] &amp; BIT(3))		/* 4bit sign number to 8 bit sign number */
 						pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] |= 0xF0;
 				}
 				pwrInfo24G-&gt;CCK_Diff[rfPath][TxCount] = 0;
@@ -390,7 +390,7 @@ static void Hal_ReadPowerValueFromPROM_8188E(struct txpowerinfo24g *pwrInfo24G,
 					pwrInfo24G-&gt;BW40_Diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
 				} else {
 					pwrInfo24G-&gt;BW40_Diff[rfPath][TxCount] =	(PROMContent[eeAddr]&amp;0xf0)&gt;&gt;4;
-					if (pwrInfo24G-&gt;BW40_Diff[rfPath][TxCount] &amp; BIT3)		/* 4bit sign number to 8 bit sign number */
+					if (pwrInfo24G-&gt;BW40_Diff[rfPath][TxCount] &amp; BIT(3))		/* 4bit sign number to 8 bit sign number */
 						pwrInfo24G-&gt;BW40_Diff[rfPath][TxCount] |= 0xF0;
 				}
 
@@ -398,7 +398,7 @@ static void Hal_ReadPowerValueFromPROM_8188E(struct txpowerinfo24g *pwrInfo24G,
 					pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
 				} else {
 					pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] =	(PROMContent[eeAddr]&amp;0x0f);
-					if (pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] &amp; BIT3)		/* 4bit sign number to 8 bit sign number */
+					if (pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] &amp; BIT(3))		/* 4bit sign number to 8 bit sign number */
 						pwrInfo24G-&gt;BW20_Diff[rfPath][TxCount] |= 0xF0;
 				}
 				eeAddr++;
@@ -407,7 +407,7 @@ static void Hal_ReadPowerValueFromPROM_8188E(struct txpowerinfo24g *pwrInfo24G,
 					pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] = EEPROM_DEFAULT_DIFF;
 				} else {
 					pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] =	(PROMContent[eeAddr]&amp;0xf0)&gt;&gt;4;
-					if (pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] &amp; BIT3)		/* 4bit sign number to 8 bit sign number */
+					if (pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] &amp; BIT(3))		/* 4bit sign number to 8 bit sign number */
 						pwrInfo24G-&gt;OFDM_Diff[rfPath][TxCount] |= 0xF0;
 				}
 
@@ -415,7 +415,7 @@ static void Hal_ReadPowerValueFromPROM_8188E(struct txpowerinfo24g *pwrInfo24G,
 					pwrInfo24G-&gt;CCK_Diff[rfPath][TxCount] =	EEPROM_DEFAULT_DIFF;
 				} else {
 					pwrInfo24G-&gt;CCK_Diff[rfPath][TxCount] =	(PROMContent[eeAddr]&amp;0x0f);
-					if (pwrInfo24G-&gt;CCK_Diff[rfPath][TxCount] &amp; BIT3)		/* 4bit sign number to 8 bit sign number */
+					if (pwrInfo24G-&gt;CCK_Diff[rfPath][TxCount] &amp; BIT(3))		/* 4bit sign number to 8 bit sign number */
 						pwrInfo24G-&gt;CCK_Diff[rfPath][TxCount] |= 0xF0;
 				}
 				eeAddr++;
@@ -485,13 +485,13 @@ void Hal_ReadPowerSavingMode88E(struct adapter *padapter, u8 *hwinfo, bool AutoL
 		/* hw power down mode selection , 0:rf-off / 1:power down */
 
 		if (padapter-&gt;registrypriv.hwpdn_mode == 2)
-			padapter-&gt;pwrctrlpriv.bHWPowerdown = (hwinfo[EEPROM_RF_FEATURE_OPTION_88E] &amp; BIT4);
+			padapter-&gt;pwrctrlpriv.bHWPowerdown = (hwinfo[EEPROM_RF_FEATURE_OPTION_88E] &amp; BIT(4));
 		else
 			padapter-&gt;pwrctrlpriv.bHWPowerdown = padapter-&gt;registrypriv.hwpdn_mode;
 
 		/*  decide hw if support remote wakeup function */
 		/*  if hw supported, 8051 (SIE) will generate WeakUP signal(D+/D- toggle) when autoresume */
-		padapter-&gt;pwrctrlpriv.bSupportRemoteWakeup = (hwinfo[EEPROM_USB_OPTIONAL_FUNCTION0] &amp; BIT1) ? true : false;
+		padapter-&gt;pwrctrlpriv.bSupportRemoteWakeup = (hwinfo[EEPROM_USB_OPTIONAL_FUNCTION0] &amp; BIT(1)) ? true : false;
 
 		DBG_88E("%s...bHWPwrPindetect(%x)-bHWPowerdown(%x) , bSupportRemoteWakeup(%x)\n", __func__,
 		padapter-&gt;pwrctrlpriv.bHWPwrPindetect, padapter-&gt;pwrctrlpriv.bHWPowerdown , padapter-&gt;pwrctrlpriv.bSupportRemoteWakeup);
diff --git a/drivers/staging/rtl8188eu/hal/rtl8188eu_led.c b/drivers/staging/rtl8188eu/hal/rtl8188eu_led.c
index 81d691ddd6c6..564cf53bff1b 100644
--- a/drivers/staging/rtl8188eu/hal/rtl8188eu_led.c
+++ b/drivers/staging/rtl8188eu/hal/rtl8188eu_led.c
@@ -36,7 +36,7 @@ void SwLedOn(struct adapter *padapter, struct LED_871x *pLed)
 	if (padapter-&gt;bSurpriseRemoved || padapter-&gt;bDriverStopped)
 		return;
 	LedCfg = usb_read8(padapter, REG_LEDCFG2);
-	usb_write8(padapter, REG_LEDCFG2, (LedCfg&amp;0xf0)|BIT5|BIT6); /*  SW control led0 on. */
+	usb_write8(padapter, REG_LEDCFG2, (LedCfg&amp;0xf0) | BIT(5) | BIT(6)); /*  SW control led0 on. */
 	pLed-&gt;bLedOn = true;
 }
 
@@ -55,12 +55,12 @@ void SwLedOff(struct adapter *padapter, struct LED_871x *pLed)
 	if (pHalData-&gt;bLedOpenDrain) {
 			/*  Open-drain arrangement for controlling the LED) */
 		LedCfg &amp;= 0x90; /*  Set to software control. */
-		usb_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3));
+		usb_write8(padapter, REG_LEDCFG2, (LedCfg | BIT(3)));
 		LedCfg = usb_read8(padapter, REG_MAC_PINMUX_CFG);
 		LedCfg &amp;= 0xFE;
 		usb_write8(padapter, REG_MAC_PINMUX_CFG, LedCfg);
 	} else {
-		usb_write8(padapter, REG_LEDCFG2, (LedCfg|BIT3|BIT5|BIT6));
+		usb_write8(padapter, REG_LEDCFG2, (LedCfg | BIT(3) | BIT(5) | BIT(6)));
 	}
 exit:
 	pLed-&gt;bLedOn = false;
diff --git a/drivers/staging/rtl8188eu/hal/usb_halinit.c b/drivers/staging/rtl8188eu/hal/usb_halinit.c
index 1ef878fd997b..7e72259f0e40 100644
--- a/drivers/staging/rtl8188eu/hal/usb_halinit.c
+++ b/drivers/staging/rtl8188eu/hal/usb_halinit.c
@@ -607,7 +607,7 @@ static void _InitBeaconParameters(struct adapter *Adapter)
 static void _BeaconFunctionEnable(struct adapter *Adapter,
 				  bool Enable, bool Linked)
 {
-	usb_write8(Adapter, REG_BCN_CTRL, (BIT4 | BIT3 | BIT1));
+	usb_write8(Adapter, REG_BCN_CTRL, (BIT(4) | BIT(3) | BIT(1)));
 
 	usb_write8(Adapter, REG_RD_CTRL+1, 0x6F);
 }
@@ -632,8 +632,8 @@ static void _InitAntenna_Selection(struct adapter *Adapter)
 		return;
 	DBG_88E("==&gt;  %s ....\n", __func__);
 
-	usb_write32(Adapter, REG_LEDCFG0, usb_read32(Adapter, REG_LEDCFG0)|BIT23);
-	phy_set_bb_reg(Adapter, rFPGA0_XAB_RFParameter, BIT13, 0x01);
+	usb_write32(Adapter, REG_LEDCFG0, usb_read32(Adapter, REG_LEDCFG0) | BIT(23));
+	phy_set_bb_reg(Adapter, rFPGA0_XAB_RFParameter, BIT(13), 0x01);
 
 	if (phy_query_bb_reg(Adapter, rFPGA0_XA_RFInterfaceOE, 0x300) == Antenna_A)
 		haldata-&gt;CurAntenna = Antenna_A;
@@ -664,13 +664,13 @@ enum rt_rf_power_state RfOnOffDetect(struct adapter *adapt)
 
 	if (adapt-&gt;pwrctrlpriv.bHWPowerdown) {
 		val8 = usb_read8(adapt, REG_HSISR);
-		DBG_88E("pwrdown, 0x5c(BIT7)=%02x\n", val8);
-		rfpowerstate = (val8 &amp; BIT7) ? rf_off : rf_on;
+		DBG_88E("pwrdown, 0x5c(BIT(7))=%02x\n", val8);
+		rfpowerstate = (val8 &amp; BIT(7)) ? rf_off : rf_on;
 	} else { /*  rf on/off */
-		usb_write8(adapt, REG_MAC_PINMUX_CFG, usb_read8(adapt, REG_MAC_PINMUX_CFG)&amp;~(BIT3));
+		usb_write8(adapt, REG_MAC_PINMUX_CFG, usb_read8(adapt, REG_MAC_PINMUX_CFG)&amp;~(BIT(3)));
 		val8 = usb_read8(adapt, REG_GPIO_IO_SEL);
 		DBG_88E("GPIO_IN=%02x\n", val8);
-		rfpowerstate = (val8 &amp; BIT3) ? rf_on : rf_off;
+		rfpowerstate = (val8 &amp; BIT(3)) ? rf_on : rf_off;
 	}
 	return rfpowerstate;
 }	/*  HalDetectPwrDownMode */
@@ -805,7 +805,7 @@ static u32 rtl8188eu_hal_init(struct adapter *Adapter)
 	/* Enable TX Report */
 	/* Enable Tx Report Timer */
 	value8 = usb_read8(Adapter, REG_TX_RPT_CTRL);
-	usb_write8(Adapter,  REG_TX_RPT_CTRL, (value8|BIT1|BIT0));
+	usb_write8(Adapter,  REG_TX_RPT_CTRL, (value8 | BIT(1) | BIT(0)));
 	/* Set MAX RPT MACID */
 	usb_write8(Adapter,  REG_TX_RPT_CTRL+1, 2);/* FOR sta mode ,0: bc/mc ,1:AP */
 	/* Tx RPT Timer. Unit: 32us */
@@ -898,7 +898,7 @@ HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_LCK);
 	usb_write8(Adapter, REG_USB_HRPWM, 0);
 
 	/* ack for xmit mgmt frames. */
-	usb_write32(Adapter, REG_FWHW_TXQ_CTRL, usb_read32(Adapter, REG_FWHW_TXQ_CTRL)|BIT(12));
+	usb_write32(Adapter, REG_FWHW_TXQ_CTRL, usb_read32(Adapter, REG_FWHW_TXQ_CTRL) | BIT(12));
 
 exit:
 HAL_INIT_PROFILE_TAG(HAL_INIT_STAGES_END);
@@ -918,7 +918,7 @@ static void CardDisableRTL8188EU(struct adapter *Adapter)
 
 	/* Stop Tx Report Timer. 0x4EC[Bit1]=b'0 */
 	val8 = usb_read8(Adapter, REG_TX_RPT_CTRL);
-	usb_write8(Adapter, REG_TX_RPT_CTRL, val8&amp;(~BIT1));
+	usb_write8(Adapter, REG_TX_RPT_CTRL, val8&amp;(~BIT(1)));
 
 	/*  stop rx */
 	usb_write8(Adapter, REG_CR, 0x0);
@@ -944,7 +944,7 @@ static void CardDisableRTL8188EU(struct adapter *Adapter)
 	/* YJ,add,111212 */
 	/* Disable 32k */
 	val8 = usb_read8(Adapter, REG_32K_CTRL);
-	usb_write8(Adapter, REG_32K_CTRL, val8&amp;(~BIT0));
+	usb_write8(Adapter, REG_32K_CTRL, val8&amp;(~BIT(0)));
 
 	/*  Card disable power action flow */
 	rtl88eu_pwrseqcmdparsing(Adapter, PWR_CUT_ALL_MSK,
@@ -953,9 +953,9 @@ static void CardDisableRTL8188EU(struct adapter *Adapter)
 
 	/*  Reset MCU IO Wrapper */
 	val8 = usb_read8(Adapter, REG_RSV_CTRL+1);
-	usb_write8(Adapter, REG_RSV_CTRL+1, (val8&amp;(~BIT3)));
+	usb_write8(Adapter, REG_RSV_CTRL+1, (val8&amp;(~BIT(3))));
 	val8 = usb_read8(Adapter, REG_RSV_CTRL+1);
-	usb_write8(Adapter, REG_RSV_CTRL+1, val8|BIT3);
+	usb_write8(Adapter, REG_RSV_CTRL+1, val8 | BIT(3));
 
 	/* YJ,test add, 111207. For Power Consumption. */
 	val8 = usb_read8(Adapter, GPIO_IN);
@@ -1171,10 +1171,10 @@ static void ResumeTxBeacon(struct adapter *adapt)
 	/*  2010.03.01. Marked by tynli. No need to call workitem beacause we record the value */
 	/*  which should be read from register to a global variable. */
 
-	usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl) | BIT6);
-	haldata-&gt;RegFwHwTxQCtrl |= BIT6;
+	usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl) | BIT(6));
+	haldata-&gt;RegFwHwTxQCtrl |= BIT(6);
 	usb_write8(adapt, REG_TBTT_PROHIBIT+1, 0xff);
-	haldata-&gt;RegReg542 |= BIT0;
+	haldata-&gt;RegReg542 |= BIT(0);
 	usb_write8(adapt, REG_TBTT_PROHIBIT+2, haldata-&gt;RegReg542);
 }
 
@@ -1185,10 +1185,10 @@ static void StopTxBeacon(struct adapter *adapt)
 	/*  2010.03.01. Marked by tynli. No need to call workitem beacause we record the value */
 	/*  which should be read from register to a global variable. */
 
-	usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl) &amp; (~BIT6));
-	haldata-&gt;RegFwHwTxQCtrl &amp;= (~BIT6);
+	usb_write8(adapt, REG_FWHW_TXQ_CTRL+2, (haldata-&gt;RegFwHwTxQCtrl) &amp; (~BIT(6)));
+	haldata-&gt;RegFwHwTxQCtrl &amp;= (~BIT(6));
 	usb_write8(adapt, REG_TBTT_PROHIBIT+1, 0x64);
-	haldata-&gt;RegReg542 &amp;= ~(BIT0);
+	haldata-&gt;RegReg542 &amp;= ~(BIT(0));
 	usb_write8(adapt, REG_TBTT_PROHIBIT+2, haldata-&gt;RegReg542);
 
 	 /* todo: CheckFwRsvdPageContent(Adapter);  2010.06.23. Added by tynli. */
@@ -1200,7 +1200,7 @@ static void hw_var_set_opmode(struct adapter *Adapter, u8 variable, u8 *val)
 	u8 mode = *((u8 *)val);
 
 	/*  disable Port0 TSF update */
-	usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+	usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL) | BIT(4));
 
 	/*  set net_type */
 	val8 = usb_read8(Adapter, MSR)&amp;0x0c;
@@ -1378,7 +1378,7 @@ static void SetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)
 			usb_write32(Adapter, REG_TSFTR+4, tsf&gt;&gt;32);
 
 			/* enable related TSF function */
-			usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(3));
+			usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL) | BIT(3));
 
 			if (((pmlmeinfo-&gt;state&amp;0x03) == WIFI_FW_ADHOC_STATE) || ((pmlmeinfo-&gt;state&amp;0x03) == WIFI_FW_AP_STATE))
 				ResumeTxBeacon(Adapter);
@@ -1403,10 +1403,10 @@ static void SetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)
 		usb_write16(Adapter, REG_RXFLTMAP2, 0x00);
 
 		/* reset TSF */
-		usb_write8(Adapter, REG_DUAL_TSF_RST, (BIT(0)|BIT(1)));
+		usb_write8(Adapter, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));
 
 		/* disable update TSF */
-		usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+		usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL) | BIT(4));
 		break;
 	case HW_VAR_MLME_SITESURVEY:
 		if (*((u8 *)val)) { /* under sitesurvey */
@@ -1418,7 +1418,7 @@ static void SetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)
 			usb_write16(Adapter, REG_RXFLTMAP2, 0x00);
 
 			/* disable update TSF */
-			usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL)|BIT(4));
+			usb_write8(Adapter, REG_BCN_CTRL, usb_read8(Adapter, REG_BCN_CTRL) | BIT(4));
 		} else { /* sitesurvey done */
 			struct mlme_ext_priv	*pmlmeext = &amp;Adapter-&gt;mlmeextpriv;
 			struct mlme_ext_info	*pmlmeinfo = &amp;(pmlmeext-&gt;mlmext_info);
@@ -1578,7 +1578,7 @@ static void SetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)
 		}
 		break;
 	case HW_VAR_CAM_INVALID_ALL:
-		usb_write32(Adapter, RWCAM, BIT(31)|BIT(30));
+		usb_write32(Adapter, RWCAM, BIT(31) | BIT(30));
 		break;
 	case HW_VAR_CAM_WRITE:
 		{
@@ -1795,7 +1795,7 @@ static void SetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)
 		break;
 	case HW_VAR_BCN_VALID:
 		/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2, write 1 to clear, Clear by sw */
-		usb_write8(Adapter, REG_TDECTRL+2, usb_read8(Adapter, REG_TDECTRL+2) | BIT0);
+		usb_write8(Adapter, REG_TDECTRL+2, usb_read8(Adapter, REG_TDECTRL+2) | BIT(0));
 		break;
 	default:
 		break;
@@ -1815,7 +1815,7 @@ static void GetHwReg8188EU(struct adapter *Adapter, u8 variable, u8 *val)
 		break;
 	case HW_VAR_BCN_VALID:
 		/* BCN_VALID, BIT16 of REG_TDECTRL = BIT0 of REG_TDECTRL+2 */
-		val[0] = (BIT0 &amp; usb_read8(Adapter, REG_TDECTRL+2)) ? true : false;
+		val[0] = (BIT(0) &amp; usb_read8(Adapter, REG_TDECTRL+2)) ? true : false;
 		break;
 	case HW_VAR_DM_FLAG:
 		val[0] = podmpriv-&gt;SupportAbility;
@@ -2052,7 +2052,7 @@ static void SetBeaconRelatedRegisters8188EUsb(struct adapter *adapt)
 
 	ResumeTxBeacon(adapt);
 
-	usb_write8(adapt, bcn_ctrl_reg, usb_read8(adapt, bcn_ctrl_reg)|BIT(1));
+	usb_write8(adapt, bcn_ctrl_reg, usb_read8(adapt, bcn_ctrl_reg) | BIT(1));
 }
 
 static void rtl8188eu_init_default_value(struct adapter *adapt)
diff --git a/drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h b/drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h
index 20e6b40fc35c..e058162fe2ba 100644
--- a/drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h
+++ b/drivers/staging/rtl8188eu/include/Hal8188EPhyCfg.h
@@ -87,13 +87,13 @@ enum rf_radio_path {
 
 enum wireless_mode {
 	WIRELESS_MODE_UNKNOWN = 0x00,
-	WIRELESS_MODE_A			= BIT2,
-	WIRELESS_MODE_B			= BIT0,
-	WIRELESS_MODE_G			= BIT1,
-	WIRELESS_MODE_AUTO		= BIT5,
-	WIRELESS_MODE_N_24G		= BIT3,
-	WIRELESS_MODE_N_5G		= BIT4,
-	WIRELESS_MODE_AC		= BIT6
+	WIRELESS_MODE_A			= BIT(2),
+	WIRELESS_MODE_B			= BIT(0),
+	WIRELESS_MODE_G			= BIT(1),
+	WIRELESS_MODE_AUTO		= BIT(5),
+	WIRELESS_MODE_N_24G		= BIT(3),
+	WIRELESS_MODE_N_5G		= BIT(4),
+	WIRELESS_MODE_AC		= BIT(6)
 };
 
 enum phy_rate_tx_offset_area {
diff --git a/drivers/staging/rtl8188eu/include/hal_intf.h b/drivers/staging/rtl8188eu/include/hal_intf.h
index e73c6341248e..1b1c10292456 100644
--- a/drivers/staging/rtl8188eu/include/hal_intf.h
+++ b/drivers/staging/rtl8188eu/include/hal_intf.h
@@ -25,10 +25,10 @@
 #include &lt;Hal8188EPhyCfg.h&gt;
 
 enum RTL871X_HCI_TYPE {
-	RTW_PCIE	= BIT0,
-	RTW_USB		= BIT1,
-	RTW_SDIO	= BIT2,
-	RTW_GSPI	= BIT3,
+	RTW_PCIE	= BIT(0),
+	RTW_USB		= BIT(1),
+	RTW_SDIO	= BIT(2),
+	RTW_GSPI	= BIT(3),
 };
 
 enum _CHIP_TYPE {
@@ -226,10 +226,10 @@ enum rt_eeprom_type {
 };
 
 #define RF_CHANGE_BY_INIT	0
-#define RF_CHANGE_BY_IPS	BIT28
-#define RF_CHANGE_BY_PS		BIT29
-#define RF_CHANGE_BY_HW		BIT30
-#define RF_CHANGE_BY_SW		BIT31
+#define RF_CHANGE_BY_IPS	BIT(28)
+#define RF_CHANGE_BY_PS		BIT(29)
+#define RF_CHANGE_BY_HW		BIT(30)
+#define RF_CHANGE_BY_SW		BIT(31)
 
 enum hardware_type {
 	HARDWARE_TYPE_RTL8188EU,
diff --git a/drivers/staging/rtl8188eu/include/odm.h b/drivers/staging/rtl8188eu/include/odm.h
index 73ef9c7596c1..bc970caf7eda 100644
--- a/drivers/staging/rtl8188eu/include/odm.h
+++ b/drivers/staging/rtl8188eu/include/odm.h
@@ -414,31 +414,31 @@ enum odm_common_info_def {
 
 enum odm_ability_def {
 	/*  BB ODM section BIT 0-15 */
-	ODM_BB_DIG			= BIT0,
-	ODM_BB_RA_MASK			= BIT1,
-	ODM_BB_DYNAMIC_TXPWR		= BIT2,
-	ODM_BB_FA_CNT			= BIT3,
-	ODM_BB_RSSI_MONITOR		= BIT4,
-	ODM_BB_CCK_PD			= BIT5,
-	ODM_BB_ANT_DIV			= BIT6,
-	ODM_BB_PWR_SAVE			= BIT7,
-	ODM_BB_PWR_TRA			= BIT8,
-	ODM_BB_RATE_ADAPTIVE		= BIT9,
-	ODM_BB_PATH_DIV			= BIT10,
-	ODM_BB_PSD			= BIT11,
-	ODM_BB_RXHP			= BIT12,
+	ODM_BB_DIG			= BIT(0),
+	ODM_BB_RA_MASK			= BIT(1),
+	ODM_BB_DYNAMIC_TXPWR		= BIT(2),
+	ODM_BB_FA_CNT			= BIT(3),
+	ODM_BB_RSSI_MONITOR		= BIT(4),
+	ODM_BB_CCK_PD			= BIT(5),
+	ODM_BB_ANT_DIV			= BIT(6),
+	ODM_BB_PWR_SAVE			= BIT(7),
+	ODM_BB_PWR_TRA			= BIT(8),
+	ODM_BB_RATE_ADAPTIVE		= BIT(9),
+	ODM_BB_PATH_DIV			= BIT(10),
+	ODM_BB_PSD			= BIT(11),
+	ODM_BB_RXHP			= BIT(12),
 
 	/*  MAC DM section BIT 16-23 */
-	ODM_MAC_EDCA_TURBO		= BIT16,
-	ODM_MAC_EARLY_MODE		= BIT17,
+	ODM_MAC_EDCA_TURBO		= BIT(16),
+	ODM_MAC_EARLY_MODE		= BIT(17),
 
 	/*  RF ODM section BIT 24-31 */
-	ODM_RF_TX_PWR_TRACK		= BIT24,
-	ODM_RF_RX_GAIN_TRACK		= BIT25,
-	ODM_RF_CALIBRATION		= BIT26,
+	ODM_RF_TX_PWR_TRACK		= BIT(24),
+	ODM_RF_RX_GAIN_TRACK		= BIT(25),
+	ODM_RF_CALIBRATION		= BIT(26),
 };
 
-#define ODM_RTL8188E		BIT4
+#define ODM_RTL8188E		BIT(4)
 
 /* ODM_CMNINFO_CUT_VER */
 enum odm_cut_version {
@@ -460,14 +460,14 @@ enum odm_fab_Version {
 /*  ODM_CMNINFO_RF_TYPE */
 /*  For example 1T2R (A+AB = BIT0|BIT4|BIT5) */
 enum odm_rf_path {
-	ODM_RF_TX_A	=	BIT0,
-	ODM_RF_TX_B	=	BIT1,
-	ODM_RF_TX_C	=	BIT2,
-	ODM_RF_TX_D	=	BIT3,
-	ODM_RF_RX_A	=	BIT4,
-	ODM_RF_RX_B	=	BIT5,
-	ODM_RF_RX_C	=	BIT6,
-	ODM_RF_RX_D	=	BIT7,
+	ODM_RF_TX_A	=	BIT(0),
+	ODM_RF_TX_B	=	BIT(1),
+	ODM_RF_TX_C	=	BIT(2),
+	ODM_RF_TX_D	=	BIT(3),
+	ODM_RF_RX_A	=	BIT(4),
+	ODM_RF_RX_B	=	BIT(5),
+	ODM_RF_RX_C	=	BIT(6),
+	ODM_RF_RX_D	=	BIT(7),
 };
 
 enum odm_rf_type {
@@ -498,33 +498,33 @@ enum odm_bt_coexist {
 
 /*  ODM_CMNINFO_OP_MODE */
 enum odm_operation_mode {
-	ODM_NO_LINK		= BIT0,
-	ODM_LINK		= BIT1,
-	ODM_SCAN		= BIT2,
-	ODM_POWERSAVE		= BIT3,
-	ODM_AP_MODE		= BIT4,
-	ODM_CLIENT_MODE		= BIT5,
-	ODM_AD_HOC		= BIT6,
-	ODM_WIFI_DIRECT		= BIT7,
-	ODM_WIFI_DISPLAY	= BIT8,
+	ODM_NO_LINK		= BIT(0),
+	ODM_LINK		= BIT(1),
+	ODM_SCAN		= BIT(2),
+	ODM_POWERSAVE		= BIT(3),
+	ODM_AP_MODE		= BIT(4),
+	ODM_CLIENT_MODE		= BIT(5),
+	ODM_AD_HOC		= BIT(6),
+	ODM_WIFI_DIRECT		= BIT(7),
+	ODM_WIFI_DISPLAY	= BIT(8),
 };
 
 /*  ODM_CMNINFO_WM_MODE */
 enum odm_wireless_mode {
 	ODM_WM_UNKNOW	= 0x0,
-	ODM_WM_B	= BIT0,
-	ODM_WM_G	= BIT1,
-	ODM_WM_A	= BIT2,
-	ODM_WM_N24G	= BIT3,
-	ODM_WM_N5G	= BIT4,
-	ODM_WM_AUTO	= BIT5,
-	ODM_WM_AC	= BIT6,
+	ODM_WM_B	= BIT(0),
+	ODM_WM_G	= BIT(1),
+	ODM_WM_A	= BIT(2),
+	ODM_WM_N24G	= BIT(3),
+	ODM_WM_N5G	= BIT(4),
+	ODM_WM_AUTO	= BIT(5),
+	ODM_WM_AC	= BIT(6),
 };
 
 /*  ODM_CMNINFO_BAND */
 enum odm_band_type {
-	ODM_BAND_2_4G	= BIT0,
-	ODM_BAND_5G	= BIT1,
+	ODM_BAND_2_4G	= BIT(0),
+	ODM_BAND_5G	= BIT(1),
 };
 
 /*  ODM_CMNINFO_SEC_CHNL_OFFSET */
diff --git a/drivers/staging/rtl8188eu/include/odm_debug.h b/drivers/staging/rtl8188eu/include/odm_debug.h
index 914f831a5b77..e9390963d6ff 100644
--- a/drivers/staging/rtl8188eu/include/odm_debug.h
+++ b/drivers/staging/rtl8188eu/include/odm_debug.h
@@ -57,30 +57,30 @@
 
 /*  Define the tracing components */
 /* BB Functions */
-#define ODM_COMP_DIG					BIT0
-#define ODM_COMP_RA_MASK				BIT1
-#define ODM_COMP_DYNAMIC_TXPWR				BIT2
-#define ODM_COMP_FA_CNT					BIT3
-#define ODM_COMP_RSSI_MONITOR				BIT4
-#define ODM_COMP_CCK_PD					BIT5
-#define ODM_COMP_ANT_DIV				BIT6
-#define ODM_COMP_PWR_SAVE				BIT7
-#define ODM_COMP_PWR_TRA				BIT8
-#define ODM_COMP_RATE_ADAPTIVE				BIT9
-#define ODM_COMP_PATH_DIV				BIT10
-#define ODM_COMP_PSD					BIT11
-#define ODM_COMP_DYNAMIC_PRICCA				BIT12
-#define ODM_COMP_RXHP					BIT13
+#define ODM_COMP_DIG					BIT(0)
+#define ODM_COMP_RA_MASK				BIT(1)
+#define ODM_COMP_DYNAMIC_TXPWR				BIT(2)
+#define ODM_COMP_FA_CNT					BIT(3)
+#define ODM_COMP_RSSI_MONITOR				BIT(4)
+#define ODM_COMP_CCK_PD					BIT(5)
+#define ODM_COMP_ANT_DIV				BIT(6)
+#define ODM_COMP_PWR_SAVE				BIT(7)
+#define ODM_COMP_PWR_TRA				BIT(8)
+#define ODM_COMP_RATE_ADAPTIVE				BIT(9)
+#define ODM_COMP_PATH_DIV				BIT(10)
+#define ODM_COMP_PSD					BIT(11)
+#define ODM_COMP_DYNAMIC_PRICCA				BIT(12)
+#define ODM_COMP_RXHP					BIT(13)
 /* MAC Functions */
-#define ODM_COMP_EDCA_TURBO				BIT16
-#define ODM_COMP_EARLY_MODE				BIT17
+#define ODM_COMP_EDCA_TURBO				BIT(16)
+#define ODM_COMP_EARLY_MODE				BIT(17)
 /* RF Functions */
-#define ODM_COMP_TX_PWR_TRACK				BIT24
-#define ODM_COMP_RX_GAIN_TRACK				BIT25
-#define ODM_COMP_CALIBRATION				BIT26
+#define ODM_COMP_TX_PWR_TRACK				BIT(24)
+#define ODM_COMP_RX_GAIN_TRACK				BIT(25)
+#define ODM_COMP_CALIBRATION				BIT(26)
 /* Common Functions */
-#define ODM_COMP_COMMON					BIT30
-#define ODM_COMP_INIT					BIT31
+#define ODM_COMP_COMMON					BIT(30)
+#define ODM_COMP_INIT					BIT(31)
 
 /*------------------------Export Marco Definition---------------------------*/
 #define RT_PRINTK(fmt, args...)				\
diff --git a/drivers/staging/rtl8188eu/include/odm_reg.h b/drivers/staging/rtl8188eu/include/odm_reg.h
index 89bc46bc71b0..7f10b695cf9d 100644
--- a/drivers/staging/rtl8188eu/include/odm_reg.h
+++ b/drivers/staging/rtl8188eu/include/odm_reg.h
@@ -112,7 +112,7 @@
 /*  Bitmap Definition */
 /*  */
 
-#define	BIT_FA_RESET					BIT0
+#define	BIT_FA_RESET					BIT(0)
 
 
 
diff --git a/drivers/staging/rtl8188eu/include/osdep_service.h b/drivers/staging/rtl8188eu/include/osdep_service.h
index 96505a6dbe2c..e24fe8cc3d0b 100644
--- a/drivers/staging/rtl8188eu/include/osdep_service.h
+++ b/drivers/staging/rtl8188eu/include/osdep_service.h
@@ -75,45 +75,6 @@ static inline int rtw_netif_queue_stopped(struct net_device *pnetdev)
 		netif_tx_queue_stopped(netdev_get_tx_queue(pnetdev, 3));
 }
 
-
-#define BIT0	0x00000001
-#define BIT1	0x00000002
-#define BIT2	0x00000004
-#define BIT3	0x00000008
-#define BIT4	0x00000010
-#define BIT5	0x00000020
-#define BIT6	0x00000040
-#define BIT7	0x00000080
-#define BIT8	0x00000100
-#define BIT9	0x00000200
-#define BIT10	0x00000400
-#define BIT11	0x00000800
-#define BIT12	0x00001000
-#define BIT13	0x00002000
-#define BIT14	0x00004000
-#define BIT15	0x00008000
-#define BIT16	0x00010000
-#define BIT17	0x00020000
-#define BIT18	0x00040000
-#define BIT19	0x00080000
-#define BIT20	0x00100000
-#define BIT21	0x00200000
-#define BIT22	0x00400000
-#define BIT23	0x00800000
-#define BIT24	0x01000000
-#define BIT25	0x02000000
-#define BIT26	0x04000000
-#define BIT27	0x08000000
-#define BIT28	0x10000000
-#define BIT29	0x20000000
-#define BIT30	0x40000000
-#define BIT31	0x80000000
-#define BIT32	0x0100000000
-#define BIT33	0x0200000000
-#define BIT34	0x0400000000
-#define BIT35	0x0800000000
-#define BIT36	0x1000000000
-
 int RTW_STATUS_CODE(int error_code);
 
 #define rtw_update_mem_stat(flag, sz) do {} while (0)
diff --git a/drivers/staging/rtl8188eu/include/pwrseq.h b/drivers/staging/rtl8188eu/include/pwrseq.h
index 43db92dcb8b3..8c876c6c7a4f 100644
--- a/drivers/staging/rtl8188eu/include/pwrseq.h
+++ b/drivers/staging/rtl8188eu/include/pwrseq.h
@@ -65,31 +65,31 @@
 	 * comment here
 	 */								\
 	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, BIT1},			\
+	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(1), BIT(1)},		\
 	/* wait till 0x04[17] = 1    power ready*/	\
 	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0|BIT1, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0) | BIT(1), 0},		\
 	/* 0x02[1:0] = 0	reset BB*/				\
 	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), BIT(7)},		\
 	/*0x24[23] = 2b'01 schmit trigger */				\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), 0},			\
 	/* 0x04[15] = 0 disable HWPDN (control by DRV)*/		\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4|BIT3, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4) | BIT(3), 0},		\
 	/*0x04[12:11] = 2b'00 disable WL suspend*/			\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, BIT0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), BIT(0)},		\
 	/*0x04[8] = 1 polling until return 0*/				\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT0, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(0), 0},			\
 	/*wait till 0x04[8] = 0*/					\
 	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), 0},			\
 	/*LDO normal mode*/						\
 	{0x0074, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), BIT(4)},		\
 	/*SDIO Driving*/
 
 #define RTL8188E_TRANS_ACT_TO_CARDEMU					\
@@ -102,13 +102,13 @@
 	PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0},			\
 	/*0x1F[7:0] = 0 turn off RF*/					\
 	{0x0023, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), BIT(4)},		\
 	/*LDO Sleep mode*/						\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), BIT(1)},		\
 	/*0x04[9] = 1 turn off MAC by HW state machine*/		\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT1, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(1), 0},			\
 	/*wait till 0x04[9] = 0 polling until return 0 to disable*/
 
 #define RTL8188E_TRANS_CARDEMU_TO_SUS					\
@@ -119,28 +119,28 @@
 	 */								\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,			\
 	PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC,		\
-	PWR_CMD_WRITE, BIT3|BIT4, BIT3},				\
+	PWR_CMD_WRITE, BIT(3) | BIT(4), BIT(3)},			\
 	/* 0x04[12:11] = 2b'01enable WL suspend */			\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3|BIT4, BIT3|BIT4},		\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), BIT(3) | BIT(4)}, \
 	/* 0x04[12:11] = 2b'11enable WL suspend for PCIe */		\
 	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,			\
 	PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC,		\
-	PWR_CMD_WRITE, 0xFF, BIT7},					\
+	PWR_CMD_WRITE, 0xFF, BIT(7)},					\
 	/* 0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */\
 	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,			\
 	PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC,		\
-	PWR_CMD_WRITE, BIT4, 0},					\
+	PWR_CMD_WRITE, BIT(4), 0},					\
 	/*Clear SIC_EN register 0x40[12] = 1'b0 */			\
 	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,			\
 	PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC,		\
-	PWR_CMD_WRITE, BIT4, BIT4},					\
+	PWR_CMD_WRITE, BIT(4), BIT(4)},					\
 	/*Set USB suspend enable local register  0xfe10[4]=1 */		\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0},			\
+	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), BIT(0)},		\
 	/*Set SDIO suspend local register*/				\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0},			\
+	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), 0},			\
 	/*wait power state to suspend*/
 
 #define RTL8188E_TRANS_SUS_TO_CARDEMU					\
@@ -150,13 +150,13 @@
 	 * comments here
 	 */								\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0},			\
+	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), 0},			\
 	/*Set SDIO suspend local register*/				\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1},		\
+	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), BIT(1)},		\
 	/*wait power state to suspend*/					\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3|BIT4, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), 0},		\
 	/*0x04[12:11] = 2b'01enable WL suspend*/
 
 #define RTL8188E_TRANS_CARDEMU_TO_CARDDIS				\
@@ -166,11 +166,11 @@
 	 * comments here
 	 */								\
 	{0x0026, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), BIT(7)},		\
 	/*0x24[23] = 2b'01 schmit trigger */				\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,			\
 	PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC,		\
-	PWR_CMD_WRITE, BIT3|BIT4, BIT3},				\
+	PWR_CMD_WRITE, BIT(3) | BIT(4), BIT(3)},			\
 	/*0x04[12:11] = 2b'01 enable WL suspend*/			\
 	{0x0007, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,			\
 	PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC,		\
@@ -178,16 +178,16 @@
 	/* 0x04[31:30] = 2b'10 enable enable bandgap mbias in suspend */\
 	{0x0041, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,			\
 	PWR_INTF_USB_MSK|PWR_INTF_SDIO_MSK, PWR_BASEADDR_MAC,		\
-	PWR_CMD_WRITE, BIT4, 0},					\
+	PWR_CMD_WRITE, BIT(4), 0},					\
 	/*Clear SIC_EN register 0x40[12] = 1'b0 */			\
 	{0xfe10, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_USB_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, BIT4},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), BIT(4)},		\
 	/*Set USB suspend enable local register  0xfe10[4]=1 */		\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, BIT0},			\
+	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), BIT(0)},		\
 	/*Set SDIO suspend local register*/				\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, 0},			\
+	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), 0},			\
 	/*wait power state to suspend*/
 
 #define RTL8188E_TRANS_CARDDIS_TO_CARDEMU				\
@@ -197,13 +197,13 @@
 	 * comments here
 	 */								\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT0, 0},			\
+	PWR_BASEADDR_SDIO, PWR_CMD_WRITE, BIT(0), 0},			\
 	/*Set SDIO suspend local register*/				\
 	{0x0086, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_SDIO_MSK,	\
-	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT1, BIT1},		\
+	PWR_BASEADDR_SDIO, PWR_CMD_POLLING, BIT(1), BIT(1)},		\
 	/*wait power state to suspend*/					\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT3|BIT4, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(3) | BIT(4), 0},		\
 	/*0x04[12:11] = 2b'01enable WL suspend*/
 
 #define RTL8188E_TRANS_CARDEMU_TO_PDN					\
@@ -213,10 +213,10 @@
 	 * comments here
 	 */								\
 	{0x0006, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 0},			\
 	/* 0x04[16] = 0*/						\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, BIT7},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), BIT(7)},		\
 	/* 0x04[15] = 1*/
 
 #define RTL8188E_TRANS_PDN_TO_CARDEMU					\
@@ -226,7 +226,7 @@
 	 * comments here
 	 */								\
 	{0x0005, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT7, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(7), 0},			\
 	/* 0x04[15] = 0*/
 
 /* This is used by driver for LPSRadioOff Procedure, not for FW LPS Step */
@@ -251,7 +251,7 @@
 	PWR_BASEADDR_MAC, PWR_CMD_POLLING, 0xFF, 0},			\
 	/*Should be zero if no packet is transmitting*/			\
 	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT0, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(0), 0},			\
 	/*CCK and OFDM are disabled,and clock are gated*/		\
 	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
 	PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0,				\
@@ -259,9 +259,9 @@
 	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
 	PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0x3F},/*Reset MAC TRX*/	\
 	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, 0},/*check if removed later*/\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), 0},/*check if removed later*/\
 	{0x0553, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT5, BIT5},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(5), BIT(5)},		\
 	/*Respond TxOK to scheduler*/
 
 
@@ -280,22 +280,22 @@
 	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
 	PWR_BASEADDR_MAC, PWR_CMD_DELAY, 0, PWRSEQ_DELAY_MS}, /*Delay*/	\
 	{0x0008, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT4, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(4), 0},			\
 	/* 0x08[4] = 0 switch TSF to 40M */				\
 	{0x0109, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT7, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_POLLING, BIT(7), 0},			\
 	/* Polling 0x109[7]=0  TSF in 40M */				\
 	{0x0029, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT6|BIT7, 0},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(6) | BIT(7), 0},		\
 	/* 0x29[7:6] = 2b'00  enable BB clock */			\
 	{0x0101, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1, BIT1},			\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1), BIT(1)},		\
 	/* 0x101[1] = 1 */						\
 	{0x0100, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
 	PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0xFF},			\
 	/* 0x100[7:0] = 0xFF enable WMAC TRX */				\
 	{0x0002, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
-	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT1|BIT0, BIT1|BIT0},		\
+	PWR_BASEADDR_MAC, PWR_CMD_WRITE, BIT(1) | BIT(0), BIT(1) | BIT(0)}, \
 	/* 0x02[1:0] = 2b'11 enable BB macro */				\
 	{0x0522, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK, PWR_INTF_ALL_MSK,	\
 	PWR_BASEADDR_MAC, PWR_CMD_WRITE, 0xFF, 0}, /*.	0x522 = 0*/
diff --git a/drivers/staging/rtl8188eu/include/rtl8188e_spec.h b/drivers/staging/rtl8188eu/include/rtl8188e_spec.h
index e99179a794af..beeee4a6b0bc 100644
--- a/drivers/staging/rtl8188eu/include/rtl8188e_spec.h
+++ b/drivers/staging/rtl8188eu/include/rtl8188e_spec.h
@@ -19,39 +19,6 @@
 #ifndef __RTL8188E_SPEC_H__
 #define __RTL8188E_SPEC_H__
 
-#define BIT0	0x00000001
-#define BIT1	0x00000002
-#define BIT2	0x00000004
-#define BIT3	0x00000008
-#define BIT4	0x00000010
-#define BIT5	0x00000020
-#define BIT6	0x00000040
-#define BIT7	0x00000080
-#define BIT8	0x00000100
-#define BIT9	0x00000200
-#define BIT10	0x00000400
-#define BIT11	0x00000800
-#define BIT12	0x00001000
-#define BIT13	0x00002000
-#define BIT14	0x00004000
-#define BIT15	0x00008000
-#define BIT16	0x00010000
-#define BIT17	0x00020000
-#define BIT18	0x00040000
-#define BIT19	0x00080000
-#define BIT20	0x00100000
-#define BIT21	0x00200000
-#define BIT22	0x00400000
-#define BIT23	0x00800000
-#define BIT24	0x01000000
-#define BIT25	0x02000000
-#define BIT26	0x04000000
-#define BIT27	0x08000000
-#define BIT28	0x10000000
-#define BIT29	0x20000000
-#define BIT30	0x40000000
-#define BIT31	0x80000000
-
 /*        8192C Regsiter offset definition */
 
 #define		HAL_PS_TIMER_INT_DELAY	50	/*   50 microseconds */
@@ -477,14 +444,14 @@
 #define	MAX_MSS_DENSITY_1T		0x0A
 
 /*  EEPROM enable when set 1 */
-#define	CmdEEPROM_En			BIT5
+#define	CmdEEPROM_En			BIT(5)
 /*  System EEPROM select, 0: boot from E-FUSE, 1: The EEPROM used is 9346 */
-#define	CmdEERPOMSEL			BIT4
-#define	Cmd9346CR_9356SEL		BIT4
+#define	CmdEERPOMSEL			BIT(4)
+#define	Cmd9346CR_9356SEL		BIT(4)
 
 /*        8192C GPIO MUX Configuration Register (offset 0x40, 4 byte) */
 #define	GPIOSEL_GPIO			0
-#define	GPIOSEL_ENBT			BIT5
+#define	GPIOSEL_ENBT			BIT(5)
 
 /*        8192C GPIO PIN Control Register (offset 0x44, 4 byte) */
 /*  GPIO pins input value */
@@ -497,18 +464,18 @@
 #define	GPIO_MOD			(REG_GPIO_PIN_CTRL+3)
 
 /* 8723/8188E Host System Interrupt Mask Register (offset 0x58, 32 byte) */
-#define	HSIMR_GPIO12_0_INT_EN		BIT0
-#define	HSIMR_SPS_OCP_INT_EN		BIT5
-#define	HSIMR_RON_INT_EN		BIT6
-#define	HSIMR_PDN_INT_EN		BIT7
-#define	HSIMR_GPIO9_INT_EN		BIT25
+#define	HSIMR_GPIO12_0_INT_EN		BIT(0)
+#define	HSIMR_SPS_OCP_INT_EN		BIT(5)
+#define	HSIMR_RON_INT_EN		BIT(6)
+#define	HSIMR_PDN_INT_EN		BIT(7)
+#define	HSIMR_GPIO9_INT_EN		BIT(25)
 
 /* 8723/8188E Host System Interrupt Status Register (offset 0x5C, 32 byte) */
-#define	HSISR_GPIO12_0_INT		BIT0
-#define	HSISR_SPS_OCP_INT		BIT5
-#define	HSISR_RON_INT_EN		BIT6
-#define	HSISR_PDNINT			BIT7
-#define	HSISR_GPIO9_INT			BIT25
+#define	HSISR_GPIO12_0_INT		BIT(0)
+#define	HSISR_SPS_OCP_INT		BIT(5)
+#define	HSISR_RON_INT_EN		BIT(6)
+#define	HSISR_PDNINT			BIT(7)
+#define	HSISR_GPIO9_INT			BIT(25)
 
 /*   8192C (MSR) Media Status Register	(Offset 0x4C, 8 bits) */
 /*
@@ -533,51 +500,51 @@ Default: 00b.
 
 /*  88E Driver Initialization Offload REG_FDHM0(Offset 0x88, 8 bits) */
 /* IOL config for REG_FDHM0(Reg0x88) */
-#define CMD_INIT_LLT			BIT0
-#define CMD_READ_EFUSE_MAP		BIT1
-#define CMD_EFUSE_PATCH			BIT2
-#define CMD_IOCONFIG			BIT3
-#define CMD_INIT_LLT_ERR		BIT4
-#define CMD_READ_EFUSE_MAP_ERR		BIT5
-#define CMD_EFUSE_PATCH_ERR		BIT6
-#define CMD_IOCONFIG_ERR		BIT7
+#define CMD_INIT_LLT			BIT(0)
+#define CMD_READ_EFUSE_MAP		BIT(1)
+#define CMD_EFUSE_PATCH			BIT(2)
+#define CMD_IOCONFIG			BIT(3)
+#define CMD_INIT_LLT_ERR		BIT(4)
+#define CMD_READ_EFUSE_MAP_ERR		BIT(5)
+#define CMD_EFUSE_PATCH_ERR		BIT(6)
+#define CMD_IOCONFIG_ERR		BIT(7)
 
 /*  6. Adaptive Control Registers  (Offset: 0x0160 - 0x01CF) */
 /*  8192C Response Rate Set Register	(offset 0x181, 24bits) */
-#define	RRSR_1M				BIT0
-#define	RRSR_2M				BIT1
-#define	RRSR_5_5M			BIT2
-#define	RRSR_11M			BIT3
-#define	RRSR_6M				BIT4
-#define	RRSR_9M				BIT5
-#define	RRSR_12M			BIT6
-#define	RRSR_18M			BIT7
-#define	RRSR_24M			BIT8
-#define	RRSR_36M			BIT9
-#define	RRSR_48M			BIT10
-#define	RRSR_54M			BIT11
-#define	RRSR_MCS0			BIT12
-#define	RRSR_MCS1			BIT13
-#define	RRSR_MCS2			BIT14
-#define	RRSR_MCS3			BIT15
-#define	RRSR_MCS4			BIT16
-#define	RRSR_MCS5			BIT17
-#define	RRSR_MCS6			BIT18
-#define	RRSR_MCS7			BIT19
+#define	RRSR_1M				BIT(0)
+#define	RRSR_2M				BIT(1)
+#define	RRSR_5_5M			BIT(2)
+#define	RRSR_11M			BIT(3)
+#define	RRSR_6M				BIT(4)
+#define	RRSR_9M				BIT(5)
+#define	RRSR_12M			BIT(6)
+#define	RRSR_18M			BIT(7)
+#define	RRSR_24M			BIT(8)
+#define	RRSR_36M			BIT(9)
+#define	RRSR_48M			BIT(10)
+#define	RRSR_54M			BIT(11)
+#define	RRSR_MCS0			BIT(12)
+#define	RRSR_MCS1			BIT(13)
+#define	RRSR_MCS2			BIT(14)
+#define	RRSR_MCS3			BIT(15)
+#define	RRSR_MCS4			BIT(16)
+#define	RRSR_MCS5			BIT(17)
+#define	RRSR_MCS6			BIT(18)
+#define	RRSR_MCS7			BIT(19)
 
 /*  8192C Response Rate Set Register	(offset 0x1BF, 8bits) */
 /*  WOL bit information */
-#define	HAL92C_WOL_PTK_UPDATE_EVENT	BIT0
-#define	HAL92C_WOL_GTK_UPDATE_EVENT	BIT1
+#define	HAL92C_WOL_PTK_UPDATE_EVENT	BIT(0)
+#define	HAL92C_WOL_GTK_UPDATE_EVENT	BIT(1)
 
 /*        8192C BW_OPMODE bits		(Offset 0x203, 8bit) */
-#define	BW_OPMODE_20MHZ			BIT2
-#define	BW_OPMODE_5G			BIT1
+#define	BW_OPMODE_20MHZ			BIT(2)
+#define	BW_OPMODE_5G			BIT(1)
 
 /*        8192C CAM Config Setting (offset 0x250, 1 byte) */
-#define	CAM_VALID			BIT15
+#define	CAM_VALID			BIT(15)
 #define	CAM_NOTVALID			0x0000
-#define	CAM_USEDK			BIT5
+#define	CAM_USEDK			BIT(5)
 
 #define	CAM_CONTENT_COUNT		8
 
@@ -594,69 +561,69 @@ Default: 00b.
 #define	CAM_CONFIG_USEDK		true
 #define	CAM_CONFIG_NO_USEDK		false
 
-#define	CAM_WRITE			BIT16
+#define	CAM_WRITE			BIT(16)
 #define	CAM_READ			0x00000000
-#define	CAM_POLLINIG			BIT31
+#define	CAM_POLLINIG			BIT(31)
 
 #define	SCR_UseDK			0x01
 #define	SCR_TxSecEnable			0x02
 #define	SCR_RxSecEnable			0x04
 
 /*  10. Power Save Control Registers	 (Offset: 0x0260 - 0x02DF) */
-#define	WOW_PMEN			BIT0 /*  Power management Enable. */
-#define	WOW_WOMEN			BIT1 /*  WoW function on or off. */
-#define	WOW_MAGIC			BIT2 /*  Magic packet */
-#define	WOW_UWF				BIT3 /*  Unicast Wakeup frame. */
+#define	WOW_PMEN			BIT(0) /*  Power management Enable. */
+#define	WOW_WOMEN			BIT(1) /*  WoW function on or off. */
+#define	WOW_MAGIC			BIT(2) /*  Magic packet */
+#define	WOW_UWF				BIT(3) /*  Unicast Wakeup frame. */
 
 /*  12. Host Interrupt Status Registers	 (Offset: 0x0300 - 0x030F) */
 /*        8188 IMR/ISR bits */
 #define	IMR_DISABLED_88E		0x0
 /*  IMR DW0(0x0060-0063) Bit 0-31 */
-#define	IMR_TXCCK_88E			BIT30	/*  TXRPT interrupt when CCX bit of the packet is set */
-#define	IMR_PSTIMEOUT_88E		BIT29	/*  Power Save Time Out Interrupt */
-#define	IMR_GTINT4_88E			BIT28	/*  When GTIMER4 expires, this bit is set to 1 */
-#define	IMR_GTINT3_88E			BIT27	/*  When GTIMER3 expires, this bit is set to 1 */
-#define	IMR_TBDER_88E			BIT26	/*  Transmit Beacon0 Error */
-#define	IMR_TBDOK_88E			BIT25	/*  Transmit Beacon0 OK */
-#define	IMR_TSF_BIT32_TOGGLE_88E	BIT24	/*  TSF Timer BIT32 toggle indication interrupt */
-#define	IMR_BCNDMAINT0_88E		BIT20	/*  Beacon DMA Interrupt 0 */
-#define	IMR_BCNDERR0_88E		BIT16	/*  Beacon Queue DMA Error 0 */
-#define	IMR_HSISR_IND_ON_INT_88E	BIT15	/*  HSISR Indicator (HSIMR &amp; HSISR is true, this bit is set to 1) */
-#define	IMR_BCNDMAINT_E_88E		BIT14	/*  Beacon DMA Interrupt Extension for Win7 */
-#define	IMR_ATIMEND_88E			BIT12	/*  CTWidnow End or ATIM Window End */
-#define	IMR_HISR1_IND_INT_88E		BIT11	/*  HISR1 Indicator (HISR1 &amp; HIMR1 is true, this bit is set to 1) */
-#define	IMR_C2HCMD_88E			BIT10	/*  CPU to Host Command INT Status, Write 1 clear */
-#define	IMR_CPWM2_88E			BIT9	/*  CPU power Mode exchange INT Status, Write 1 clear */
-#define	IMR_CPWM_88E			BIT8	/*  CPU power Mode exchange INT Status, Write 1 clear */
-#define	IMR_HIGHDOK_88E			BIT7	/*  High Queue DMA OK */
-#define	IMR_MGNTDOK_88E			BIT6	/*  Management Queue DMA OK */
-#define	IMR_BKDOK_88E			BIT5	/*  AC_BK DMA OK */
-#define	IMR_BEDOK_88E			BIT4	/*  AC_BE DMA OK */
-#define	IMR_VIDOK_88E			BIT3	/*  AC_VI DMA OK */
-#define	IMR_VODOK_88E			BIT2	/*  AC_VO DMA OK */
-#define	IMR_RDU_88E			BIT1	/*  Rx Descriptor Unavailable */
-#define	IMR_ROK_88E			BIT0	/*  Receive DMA OK */
+#define	IMR_TXCCK_88E			BIT(30)	/*  TXRPT interrupt when CCX bit of the packet is set */
+#define	IMR_PSTIMEOUT_88E		BIT(29)	/*  Power Save Time Out Interrupt */
+#define	IMR_GTINT4_88E			BIT(28)	/*  When GTIMER4 expires, this bit is set to 1 */
+#define	IMR_GTINT3_88E			BIT(27)	/*  When GTIMER3 expires, this bit is set to 1 */
+#define	IMR_TBDER_88E			BIT(26)	/*  Transmit Beacon0 Error */
+#define	IMR_TBDOK_88E			BIT(25)	/*  Transmit Beacon0 OK */
+#define	IMR_TSF_BIT32_TOGGLE_88E	BIT(24)	/*  TSF Timer BIT32 toggle indication interrupt */
+#define	IMR_BCNDMAINT0_88E		BIT(20)	/*  Beacon DMA Interrupt 0 */
+#define	IMR_BCNDERR0_88E		BIT(16)	/*  Beacon Queue DMA Error 0 */
+#define	IMR_HSISR_IND_ON_INT_88E	BIT(15)	/*  HSISR Indicator (HSIMR &amp; HSISR is true, this bit is set to 1) */
+#define	IMR_BCNDMAINT_E_88E		BIT(14)	/*  Beacon DMA Interrupt Extension for Win7 */
+#define	IMR_ATIMEND_88E			BIT(12)	/*  CTWidnow End or ATIM Window End */
+#define	IMR_HISR1_IND_INT_88E		BIT(11)	/*  HISR1 Indicator (HISR1 &amp; HIMR1 is true, this bit is set to 1) */
+#define	IMR_C2HCMD_88E			BIT(10)	/*  CPU to Host Command INT Status, Write 1 clear */
+#define	IMR_CPWM2_88E			BIT(9)	/*  CPU power Mode exchange INT Status, Write 1 clear */
+#define	IMR_CPWM_88E			BIT(8)	/*  CPU power Mode exchange INT Status, Write 1 clear */
+#define	IMR_HIGHDOK_88E			BIT(7)	/*  High Queue DMA OK */
+#define	IMR_MGNTDOK_88E			BIT(6)	/*  Management Queue DMA OK */
+#define	IMR_BKDOK_88E			BIT(5)	/*  AC_BK DMA OK */
+#define	IMR_BEDOK_88E			BIT(4)	/*  AC_BE DMA OK */
+#define	IMR_VIDOK_88E			BIT(3)	/*  AC_VI DMA OK */
+#define	IMR_VODOK_88E			BIT(2)	/*  AC_VO DMA OK */
+#define	IMR_RDU_88E			BIT(1)	/*  Rx Descriptor Unavailable */
+#define	IMR_ROK_88E			BIT(0)	/*  Receive DMA OK */
 
 /*  IMR DW1(0x00B4-00B7) Bit 0-31 */
-#define	IMR_BCNDMAINT7_88E		BIT27	/*  Beacon DMA Interrupt 7 */
-#define	IMR_BCNDMAINT6_88E		BIT26	/*  Beacon DMA Interrupt 6 */
-#define	IMR_BCNDMAINT5_88E		BIT25	/*  Beacon DMA Interrupt 5 */
-#define	IMR_BCNDMAINT4_88E		BIT24	/*  Beacon DMA Interrupt 4 */
-#define	IMR_BCNDMAINT3_88E		BIT23	/*  Beacon DMA Interrupt 3 */
-#define	IMR_BCNDMAINT2_88E		BIT22	/*  Beacon DMA Interrupt 2 */
-#define	IMR_BCNDMAINT1_88E		BIT21	/*  Beacon DMA Interrupt 1 */
-#define	IMR_BCNDERR7_88E		BIT20	/*  Beacon DMA Error Int 7 */
-#define	IMR_BCNDERR6_88E		BIT19	/*  Beacon DMA Error Int 6 */
-#define	IMR_BCNDERR5_88E		BIT18	/*  Beacon DMA Error Int 5 */
-#define	IMR_BCNDERR4_88E		BIT17	/*  Beacon DMA Error Int 4 */
-#define	IMR_BCNDERR3_88E		BIT16	/*  Beacon DMA Error Int 3 */
-#define	IMR_BCNDERR2_88E		BIT15	/*  Beacon DMA Error Int 2 */
-#define	IMR_BCNDERR1_88E		BIT14	/*  Beacon DMA Error Int 1 */
-#define	IMR_ATIMEND_E_88E		BIT13	/*  ATIM Window End Ext for Win7 */
-#define	IMR_TXERR_88E			BIT11	/*  Tx Err Flag Int Status, write 1 clear. */
-#define	IMR_RXERR_88E			BIT10	/*  Rx Err Flag INT Status, Write 1 clear */
-#define	IMR_TXFOVW_88E			BIT9	/*  Transmit FIFO Overflow */
-#define	IMR_RXFOVW_88E			BIT8	/*  Receive FIFO Overflow */
+#define	IMR_BCNDMAINT7_88E		BIT(27)	/*  Beacon DMA Interrupt 7 */
+#define	IMR_BCNDMAINT6_88E		BIT(26)	/*  Beacon DMA Interrupt 6 */
+#define	IMR_BCNDMAINT5_88E		BIT(25)	/*  Beacon DMA Interrupt 5 */
+#define	IMR_BCNDMAINT4_88E		BIT(24)	/*  Beacon DMA Interrupt 4 */
+#define	IMR_BCNDMAINT3_88E		BIT(23)	/*  Beacon DMA Interrupt 3 */
+#define	IMR_BCNDMAINT2_88E		BIT(22)	/*  Beacon DMA Interrupt 2 */
+#define	IMR_BCNDMAINT1_88E		BIT(21)	/*  Beacon DMA Interrupt 1 */
+#define	IMR_BCNDERR7_88E		BIT(20)	/*  Beacon DMA Error Int 7 */
+#define	IMR_BCNDERR6_88E		BIT(19)	/*  Beacon DMA Error Int 6 */
+#define	IMR_BCNDERR5_88E		BIT(18)	/*  Beacon DMA Error Int 5 */
+#define	IMR_BCNDERR4_88E		BIT(17)	/*  Beacon DMA Error Int 4 */
+#define	IMR_BCNDERR3_88E		BIT(16)	/*  Beacon DMA Error Int 3 */
+#define	IMR_BCNDERR2_88E		BIT(15)	/*  Beacon DMA Error Int 2 */
+#define	IMR_BCNDERR1_88E		BIT(14)	/*  Beacon DMA Error Int 1 */
+#define	IMR_ATIMEND_E_88E		BIT(13)	/*  ATIM Window End Ext for Win7 */
+#define	IMR_TXERR_88E			BIT(11)	/*  Tx Err Flag Int Status, write 1 clear. */
+#define	IMR_RXERR_88E			BIT(10)	/*  Rx Err Flag INT Status, Write 1 clear */
+#define	IMR_TXFOVW_88E			BIT(9)	/*  Transmit FIFO Overflow */
+#define	IMR_RXFOVW_88E			BIT(8)	/*  Receive FIFO Overflow */
 
 #define	HAL_NIC_UNPLUG_ISR		0xFFFFFFFF	/*  The value when the NIC is unplugged for PCI. */
 
@@ -692,40 +659,40 @@ Current IOREG MAP
 /*	the correct arragement is VO - Bit0, VI - Bit1, BE - Bit2,
  *	and BK - Bit3. */
 /*	8723 and 88E may be not correct either in the earlier version. */
-#define		StopBecon			BIT6
-#define		StopHigh			BIT5
-#define		StopMgt				BIT4
-#define		StopBK				BIT3
-#define		StopBE				BIT2
-#define		StopVI				BIT1
-#define		StopVO				BIT0
+#define		StopBecon			BIT(6)
+#define		StopHigh			BIT(5)
+#define		StopMgt				BIT(4)
+#define		StopBK				BIT(3)
+#define		StopBE				BIT(2)
+#define		StopVI				BIT(1)
+#define		StopVO				BIT(0)
 
 /*        8192C (RCR) Receive Configuration Register(Offset 0x608, 32 bits) */
-#define	RCR_APPFCS		BIT31	/* WMAC append FCS after payload */
-#define	RCR_APP_MIC		BIT30
-#define	RCR_APP_PHYSTS		BIT28
-#define	RCR_APP_ICV		BIT29
-#define	RCR_APP_PHYST_RXFF	BIT28
-#define	RCR_APP_BA_SSN		BIT27	/* Accept BA SSN */
-#define	RCR_ENMBID		BIT24	/* Enable Multiple BssId. */
-#define	RCR_LSIGEN		BIT23
-#define	RCR_MFBEN		BIT22
-#define	RCR_HTC_LOC_CTRL	BIT14   /* MFC&lt;--HTC=1 MFC--&gt;HTC=0 */
-#define	RCR_AMF			BIT13	/* Accept management type frame */
-#define	RCR_ACF			BIT12	/* Accept control type frame */
-#define	RCR_ADF			BIT11	/* Accept data type frame */
-#define	RCR_AICV		BIT9	/* Accept ICV error packet */
-#define	RCR_ACRC32		BIT8	/* Accept CRC32 error packet */
-#define	RCR_CBSSID_BCN		BIT7	/* Accept BSSID match packet
+#define	RCR_APPFCS		BIT(31)	/* WMAC append FCS after payload */
+#define	RCR_APP_MIC		BIT(30)
+#define	RCR_APP_PHYSTS		BIT(28)
+#define	RCR_APP_ICV		BIT(29)
+#define	RCR_APP_PHYST_RXFF	BIT(28)
+#define	RCR_APP_BA_SSN		BIT(27)	/* Accept BA SSN */
+#define	RCR_ENMBID		BIT(24)	/* Enable Multiple BssId. */
+#define	RCR_LSIGEN		BIT(23)
+#define	RCR_MFBEN		BIT(22)
+#define	RCR_HTC_LOC_CTRL	BIT(14)   /* MFC&lt;--HTC=1 MFC--&gt;HTC=0 */
+#define	RCR_AMF			BIT(13)	/* Accept management type frame */
+#define	RCR_ACF			BIT(12)	/* Accept control type frame */
+#define	RCR_ADF			BIT(11)	/* Accept data type frame */
+#define	RCR_AICV		BIT(9)	/* Accept ICV error packet */
+#define	RCR_ACRC32		BIT(8)	/* Accept CRC32 error packet */
+#define	RCR_CBSSID_BCN		BIT(7)	/* Accept BSSID match packet
 					 * (Rx beacon, probe rsp) */
-#define	RCR_CBSSID_DATA		BIT6	/* Accept BSSID match (Data)*/
+#define	RCR_CBSSID_DATA		BIT(6)	/* Accept BSSID match (Data)*/
 #define	RCR_CBSSID		RCR_CBSSID_DATA	/* Accept BSSID match */
-#define	RCR_APWRMGT		BIT5	/* Accept power management pkt*/
-#define	RCR_ADD3		BIT4	/* Accept address 3 match pkt */
-#define	RCR_AB			BIT3	/* Accept broadcast packet */
-#define	RCR_AM			BIT2	/* Accept multicast packet */
-#define	RCR_APM			BIT1	/* Accept physical match pkt */
-#define	RCR_AAP			BIT0	/* Accept all unicast packet */
+#define	RCR_APWRMGT		BIT(5)	/* Accept power management pkt*/
+#define	RCR_ADD3		BIT(4)	/* Accept address 3 match pkt */
+#define	RCR_AB			BIT(3)	/* Accept broadcast packet */
+#define	RCR_AM			BIT(2)	/* Accept multicast packet */
+#define	RCR_APM			BIT(1)	/* Accept physical match pkt */
+#define	RCR_AAP			BIT(0)	/* Accept all unicast packet */
 #define	RCR_MXDMA_OFFSET	8
 #define	RCR_FIFO_OFFSET		13
 
@@ -1193,56 +1160,56 @@ Current IOREG MAP
 #define SDIO_HIMR_DISABLED			0
 
 /*  RTL8188E SDIO Host Interrupt Mask Register */
-#define SDIO_HIMR_RX_REQUEST_MSK		BIT0
-#define SDIO_HIMR_AVAL_MSK			BIT1
-#define SDIO_HIMR_TXERR_MSK			BIT2
-#define SDIO_HIMR_RXERR_MSK			BIT3
-#define SDIO_HIMR_TXFOVW_MSK			BIT4
-#define SDIO_HIMR_RXFOVW_MSK			BIT5
-#define SDIO_HIMR_TXBCNOK_MSK			BIT6
-#define SDIO_HIMR_TXBCNERR_MSK			BIT7
-#define SDIO_HIMR_BCNERLY_INT_MSK		BIT16
-#define SDIO_HIMR_C2HCMD_MSK			BIT17
-#define SDIO_HIMR_CPWM1_MSK			BIT18
-#define SDIO_HIMR_CPWM2_MSK			BIT19
-#define SDIO_HIMR_HSISR_IND_MSK			BIT20
-#define SDIO_HIMR_GTINT3_IND_MSK		BIT21
-#define SDIO_HIMR_GTINT4_IND_MSK		BIT22
-#define SDIO_HIMR_PSTIMEOUT_MSK			BIT23
-#define SDIO_HIMR_OCPINT_MSK			BIT24
-#define SDIO_HIMR_ATIMEND_MSK			BIT25
-#define SDIO_HIMR_ATIMEND_E_MSK			BIT26
-#define SDIO_HIMR_CTWEND_MSK			BIT27
+#define SDIO_HIMR_RX_REQUEST_MSK		BIT(0)
+#define SDIO_HIMR_AVAL_MSK			BIT(1)
+#define SDIO_HIMR_TXERR_MSK			BIT(2)
+#define SDIO_HIMR_RXERR_MSK			BIT(3)
+#define SDIO_HIMR_TXFOVW_MSK			BIT(4)
+#define SDIO_HIMR_RXFOVW_MSK			BIT(5)
+#define SDIO_HIMR_TXBCNOK_MSK			BIT(6)
+#define SDIO_HIMR_TXBCNERR_MSK			BIT(7)
+#define SDIO_HIMR_BCNERLY_INT_MSK		BIT(16)
+#define SDIO_HIMR_C2HCMD_MSK			BIT(17)
+#define SDIO_HIMR_CPWM1_MSK			BIT(18)
+#define SDIO_HIMR_CPWM2_MSK			BIT(19)
+#define SDIO_HIMR_HSISR_IND_MSK			BIT(20)
+#define SDIO_HIMR_GTINT3_IND_MSK		BIT(21)
+#define SDIO_HIMR_GTINT4_IND_MSK		BIT(22)
+#define SDIO_HIMR_PSTIMEOUT_MSK			BIT(23)
+#define SDIO_HIMR_OCPINT_MSK			BIT(24)
+#define SDIO_HIMR_ATIMEND_MSK			BIT(25)
+#define SDIO_HIMR_ATIMEND_E_MSK			BIT(26)
+#define SDIO_HIMR_CTWEND_MSK			BIT(27)
 
 /* RTL8188E SDIO Specific */
-#define	SDIO_HIMR_MCU_ERR_MSK			BIT28
-#define	SDIO_HIMR_TSF_BIT32_TOGGLE_MSK		BIT29
+#define	SDIO_HIMR_MCU_ERR_MSK			BIT(28)
+#define	SDIO_HIMR_TSF_BIT32_TOGGLE_MSK		BIT(29)
 
 /*  SDIO Host Interrupt Service Routine */
-#define SDIO_HISR_RX_REQUEST			BIT0
-#define SDIO_HISR_AVAL				BIT1
-#define SDIO_HISR_TXERR				BIT2
-#define SDIO_HISR_RXERR				BIT3
-#define SDIO_HISR_TXFOVW			BIT4
-#define SDIO_HISR_RXFOVW			BIT5
-#define SDIO_HISR_TXBCNOK			BIT6
-#define SDIO_HISR_TXBCNERR			BIT7
-#define SDIO_HISR_BCNERLY_INT			BIT16
-#define SDIO_HISR_C2HCMD			BIT17
-#define SDIO_HISR_CPWM1				BIT18
-#define SDIO_HISR_CPWM2				BIT19
-#define SDIO_HISR_HSISR_IND			BIT20
-#define SDIO_HISR_GTINT3_IND			BIT21
-#define SDIO_HISR_GTINT4_IND			BIT22
-#define SDIO_HISR_PSTIME			BIT23
-#define SDIO_HISR_OCPINT			BIT24
-#define SDIO_HISR_ATIMEND			BIT25
-#define SDIO_HISR_ATIMEND_E			BIT26
-#define SDIO_HISR_CTWEND			BIT27
+#define SDIO_HISR_RX_REQUEST			BIT(0)
+#define SDIO_HISR_AVAL				BIT(1)
+#define SDIO_HISR_TXERR				BIT(2)
+#define SDIO_HISR_RXERR				BIT(3)
+#define SDIO_HISR_TXFOVW			BIT(4)
+#define SDIO_HISR_RXFOVW			BIT(5)
+#define SDIO_HISR_TXBCNOK			BIT(6)
+#define SDIO_HISR_TXBCNERR			BIT(7)
+#define SDIO_HISR_BCNERLY_INT			BIT(16)
+#define SDIO_HISR_C2HCMD			BIT(17)
+#define SDIO_HISR_CPWM1				BIT(18)
+#define SDIO_HISR_CPWM2				BIT(19)
+#define SDIO_HISR_HSISR_IND			BIT(20)
+#define SDIO_HISR_GTINT3_IND			BIT(21)
+#define SDIO_HISR_GTINT4_IND			BIT(22)
+#define SDIO_HISR_PSTIME			BIT(23)
+#define SDIO_HISR_OCPINT			BIT(24)
+#define SDIO_HISR_ATIMEND			BIT(25)
+#define SDIO_HISR_ATIMEND_E			BIT(26)
+#define SDIO_HISR_CTWEND			BIT(27)
 
 /* RTL8188E SDIO Specific */
-#define	SDIO_HISR_MCU_ERR			BIT28
-#define	SDIO_HISR_TSF_BIT32_TOGGLE		BIT29
+#define	SDIO_HISR_MCU_ERR			BIT(28)
+#define	SDIO_HISR_TSF_BIT32_TOGGLE		BIT(29)
 
 #define MASK_SDIO_HISR_CLEAR				\
 	(SDIO_HISR_TXERR | SDIO_HISR_RXERR | SDIO_HISR_TXFOVW |\
@@ -1252,8 +1219,8 @@ Current IOREG MAP
 	 SDIO_HISR_PSTIMEOUT | SDIO_HISR_OCPINT)
 
 /*  SDIO HCI Suspend Control Register */
-#define HCI_RESUME_PWR_RDY		BIT1
-#define HCI_SUS_CTRL			BIT0
+#define HCI_RESUME_PWR_RDY		BIT(1)
+#define HCI_SUS_CTRL			BIT(0)
 
 /*  SDIO Tx FIFO related */
 /*  The number of Tx FIFO free page */
@@ -1287,33 +1254,33 @@ Current IOREG MAP
 
 /* 2REG_MULTI_FUNC_CTRL(For RTL8723 Only) */
 /*  Enable GPIO[9] as WiFi HW PDn source */
-#define	WL_HWPDN_EN				BIT0
+#define	WL_HWPDN_EN				BIT(0)
 /*  WiFi HW PDn polarity control */
-#define	WL_HWPDN_SL				BIT1
+#define	WL_HWPDN_SL				BIT(1)
 /*  WiFi function enable */
-#define	WL_FUNC_EN				BIT2
+#define	WL_FUNC_EN				BIT(2)
 /*  Enable GPIO[9] as WiFi RF HW PDn source */
-#define	WL_HWROF_EN				BIT3
+#define	WL_HWROF_EN				BIT(3)
 /*  Enable GPIO[11] as BT HW PDn source */
-#define	BT_HWPDN_EN				BIT16
+#define	BT_HWPDN_EN				BIT(16)
 /*  BT HW PDn polarity control */
-#define	BT_HWPDN_SL				BIT17
+#define	BT_HWPDN_SL				BIT(17)
 /*  BT function enable */
-#define	BT_FUNC_EN				BIT18
+#define	BT_FUNC_EN				BIT(18)
 /*  Enable GPIO[11] as BT/GPS RF HW PDn source */
-#define	BT_HWROF_EN				BIT19
+#define	BT_HWROF_EN				BIT(19)
 /*  Enable GPIO[10] as GPS HW PDn source */
-#define	GPS_HWPDN_EN				BIT20
+#define	GPS_HWPDN_EN				BIT(20)
 /*  GPS HW PDn polarity control */
-#define	GPS_HWPDN_SL				BIT21
+#define	GPS_HWPDN_SL				BIT(21)
 /*  GPS function enable */
-#define	GPS_FUNC_EN				BIT22
+#define	GPS_FUNC_EN				BIT(22)
 
 /* 3 REG_LIFECTRL_CTRL */
-#define	HAL92C_EN_PKT_LIFE_TIME_BK		BIT3
-#define	HAL92C_EN_PKT_LIFE_TIME_BE		BIT2
-#define	HAL92C_EN_PKT_LIFE_TIME_VI		BIT1
-#define	HAL92C_EN_PKT_LIFE_TIME_VO		BIT0
+#define	HAL92C_EN_PKT_LIFE_TIME_BK		BIT(3)
+#define	HAL92C_EN_PKT_LIFE_TIME_BE		BIT(2)
+#define	HAL92C_EN_PKT_LIFE_TIME_VI		BIT(1)
+#define	HAL92C_EN_PKT_LIFE_TIME_VO		BIT(0)
 
 #define	HAL92C_MSDU_LIFE_TIME_UNIT		128	/*  in us */
 
@@ -1323,7 +1290,7 @@ Current IOREG MAP
 #define POLLING_LLT_THRESHOLD			20
 #define POLLING_READY_TIMEOUT_COUNT		1000
 /*  GPIO BIT */
-#define	HAL_8192C_HW_GPIO_WPS_BIT		BIT2
+#define	HAL_8192C_HW_GPIO_WPS_BIT		BIT(2)
 
 /*	8192C EEPROM/EFUSE share register definition. */
 
diff --git a/drivers/staging/rtl8188eu/include/rtw_sreset.h b/drivers/staging/rtl8188eu/include/rtw_sreset.h
index 580e850511a7..3a62ed010875 100644
--- a/drivers/staging/rtl8188eu/include/rtw_sreset.h
+++ b/drivers/staging/rtl8188eu/include/rtw_sreset.h
@@ -30,13 +30,13 @@ struct sreset_priv {
 #include &lt;rtl8188e_hal.h&gt;
 
 #define	WIFI_STATUS_SUCCESS		0
-#define	USB_VEN_REQ_CMD_FAIL	BIT0
-#define	USB_READ_PORT_FAIL		BIT1
-#define	USB_WRITE_PORT_FAIL		BIT2
-#define	WIFI_MAC_TXDMA_ERROR	BIT3
-#define   WIFI_TX_HANG				BIT4
-#define	WIFI_RX_HANG				BIT5
-#define		WIFI_IF_NOT_EXIST			BIT6
+#define	USB_VEN_REQ_CMD_FAIL		BIT(0)
+#define	USB_READ_PORT_FAIL		BIT(1)
+#define	USB_WRITE_PORT_FAIL		BIT(2)
+#define	WIFI_MAC_TXDMA_ERROR		BIT(3)
+#define   WIFI_TX_HANG			BIT(4)
+#define	WIFI_RX_HANG			BIT(5)
+#define		WIFI_IF_NOT_EXIST	BIT(6)
 
 void sreset_init_value(struct adapter *padapter);
 u8 sreset_get_wifi_status(struct adapter *padapter);</pre><hr><pre>commit 56b3152e5e8b0501ff9ef100b772df8ecb3efd82
Author: Anish Bhatt &lt;anish@gatech.edu&gt;
Date:   Mon Oct 12 21:02:36 2015 -0700

    rtl8192u: BIT() macro cleanup
    
    Use the BIT(x) macro directly instead using multiple
    BITX defines.
    
    Signed-off-by: Anish Bhatt &lt;anish@gatech.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtl8192u/ieee80211/ieee80211.h b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
index d481a26c25ae..967ef9a98fc0 100644
--- a/drivers/staging/rtl8192u/ieee80211/ieee80211.h
+++ b/drivers/staging/rtl8192u/ieee80211/ieee80211.h
@@ -415,7 +415,7 @@ typedef struct ieee_param {
 /* QOS control */
 #define IEEE80211_QCTL_TID              0x000F
 
-#define	FC_QOS_BIT					BIT7
+#define	FC_QOS_BIT					BIT(7)
 #define IsDataFrame(pdu)			( ((pdu[0] &amp; 0x0C)==0x08) ? true : false )
 #define	IsLegacyDataFrame(pdu)	(IsDataFrame(pdu) &amp;&amp; (!(pdu[0]&amp;FC_QOS_BIT)) )
 //added by wb. Is this right?
@@ -1565,10 +1565,10 @@ typedef struct _RT_POWER_SAVE_CONTROL {
 } RT_POWER_SAVE_CONTROL, *PRT_POWER_SAVE_CONTROL;
 
 typedef u32 RT_RF_CHANGE_SOURCE;
-#define RF_CHANGE_BY_SW BIT31
-#define RF_CHANGE_BY_HW BIT30
-#define RF_CHANGE_BY_PS BIT29
-#define RF_CHANGE_BY_IPS BIT28
+#define RF_CHANGE_BY_SW		BIT(31)
+#define RF_CHANGE_BY_HW		BIT(30)
+#define RF_CHANGE_BY_PS		BIT(29)
+#define RF_CHANGE_BY_IPS	BIT(28)
 #define RF_CHANGE_BY_INIT	0	// Do not change the RFOff reason. Defined by Bruce, 2008-01-17.
 
 typedef enum
diff --git a/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h b/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
index 9fbce912a74b..49c23c720f78 100644
--- a/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
+++ b/drivers/staging/rtl8192u/ieee80211/rtl819x_Qos.h
@@ -1,39 +1,6 @@
 #ifndef __INC_QOS_TYPE_H
 #define __INC_QOS_TYPE_H
 
-#define BIT0                    0x00000001
-#define BIT1                    0x00000002
-#define BIT2                    0x00000004
-#define BIT3                    0x00000008
-#define BIT4                    0x00000010
-#define BIT5                    0x00000020
-#define BIT6                    0x00000040
-#define BIT7                    0x00000080
-#define BIT8                    0x00000100
-#define BIT9                    0x00000200
-#define BIT10                   0x00000400
-#define BIT11                   0x00000800
-#define BIT12                   0x00001000
-#define BIT13                   0x00002000
-#define BIT14                   0x00004000
-#define BIT15                   0x00008000
-#define BIT16                   0x00010000
-#define BIT17                   0x00020000
-#define BIT18                   0x00040000
-#define BIT19                   0x00080000
-#define BIT20                   0x00100000
-#define BIT21                   0x00200000
-#define BIT22                   0x00400000
-#define BIT23                   0x00800000
-#define BIT24                   0x01000000
-#define BIT25                   0x02000000
-#define BIT26                   0x04000000
-#define BIT27                   0x08000000
-#define BIT28                   0x10000000
-#define BIT29                   0x20000000
-#define BIT30                   0x40000000
-#define BIT31                   0x80000000
-
 #define	MAX_WMMELE_LENGTH	64
 
 //
@@ -375,17 +342,17 @@ typedef struct _ACM{
 
 typedef	u8		AC_UAPSD, *PAC_UAPSD;
 
-#define	GET_VO_UAPSD(_apsd) ((_apsd) &amp; BIT0)
-#define	SET_VO_UAPSD(_apsd) ((_apsd) |= BIT0)
+#define	GET_VO_UAPSD(_apsd) ((_apsd) &amp; BIT(0))
+#define	SET_VO_UAPSD(_apsd) ((_apsd) |= BIT(0))
 
-#define	GET_VI_UAPSD(_apsd) ((_apsd) &amp; BIT1)
-#define	SET_VI_UAPSD(_apsd) ((_apsd) |= BIT1)
+#define	GET_VI_UAPSD(_apsd) ((_apsd) &amp; BIT(1))
+#define	SET_VI_UAPSD(_apsd) ((_apsd) |= BIT(1))
 
-#define	GET_BK_UAPSD(_apsd) ((_apsd) &amp; BIT2)
-#define	SET_BK_UAPSD(_apsd) ((_apsd) |= BIT2)
+#define	GET_BK_UAPSD(_apsd) ((_apsd) &amp; BIT(2))
+#define	SET_BK_UAPSD(_apsd) ((_apsd) |= BIT(2))
 
-#define	GET_BE_UAPSD(_apsd) ((_apsd) &amp; BIT3)
-#define	SET_BE_UAPSD(_apsd) ((_apsd) |= BIT3)
+#define	GET_BE_UAPSD(_apsd) ((_apsd) &amp; BIT(3))
+#define	SET_BE_UAPSD(_apsd) ((_apsd) |= BIT(3))
 
 
 //typedef struct _TCLASS{
diff --git a/drivers/staging/rtl8192u/r8192U.h b/drivers/staging/rtl8192u/r8192U.h
index a76748e3b506..ee1c72267811 100644
--- a/drivers/staging/rtl8192u/r8192U.h
+++ b/drivers/staging/rtl8192u/r8192U.h
@@ -43,39 +43,6 @@
 #define MAX_KEY_LEN     61
 #define KEY_BUF_SIZE    5
 
-#define BIT0            0x00000001
-#define BIT1            0x00000002
-#define BIT2            0x00000004
-#define BIT3            0x00000008
-#define BIT4            0x00000010
-#define BIT5            0x00000020
-#define BIT6            0x00000040
-#define BIT7            0x00000080
-#define BIT8            0x00000100
-#define BIT9            0x00000200
-#define BIT10           0x00000400
-#define BIT11           0x00000800
-#define BIT12           0x00001000
-#define BIT13           0x00002000
-#define BIT14           0x00004000
-#define BIT15           0x00008000
-#define BIT16           0x00010000
-#define BIT17           0x00020000
-#define BIT18           0x00040000
-#define BIT19           0x00080000
-#define BIT20           0x00100000
-#define BIT21           0x00200000
-#define BIT22           0x00400000
-#define BIT23           0x00800000
-#define BIT24           0x01000000
-#define BIT25           0x02000000
-#define BIT26           0x04000000
-#define BIT27           0x08000000
-#define BIT28           0x10000000
-#define BIT29           0x20000000
-#define BIT30           0x40000000
-#define BIT31           0x80000000
-
 #define	Rx_Smooth_Factor		20
 #define DMESG(x, a...)
 #define DMESGW(x, a...)
@@ -87,44 +54,44 @@ extern u32 rt_global_debug_component;
 			pr_debug("RTL8192U: " x "\n", ##args);	\
 	} while (0)
 
-#define COMP_TRACE              BIT0  /* Function call tracing. */
-#define COMP_DBG                BIT1
-#define COMP_INIT               BIT2  /* Driver initialization/halt/reset. */
+#define COMP_TRACE              BIT(0)  /* Function call tracing. */
+#define COMP_DBG                BIT(1)
+#define COMP_INIT               BIT(2)  /* Driver initialization/halt/reset. */
 
 
-#define COMP_RECV               BIT3  /* Receive data path. */
-#define COMP_SEND               BIT4  /* Send data path. */
-#define COMP_IO                 BIT5
+#define COMP_RECV               BIT(3)  /* Receive data path. */
+#define COMP_SEND               BIT(4)  /* Send data path. */
+#define COMP_IO                 BIT(5)
 /* 802.11 Power Save mode or System/Device Power state. */
-#define COMP_POWER              BIT6
+#define COMP_POWER              BIT(6)
 /* 802.11 link related: join/start BSS, leave BSS. */
-#define COMP_EPROM              BIT7
-#define COMP_SWBW               BIT8  /* Bandwidth switch. */
-#define COMP_POWER_TRACKING     BIT9  /* 8190 TX Power Tracking */
-#define COMP_TURBO              BIT10 /* Turbo Mode */
-#define COMP_QOS                BIT11
-#define COMP_RATE               BIT12 /* Rate Adaptive mechanism */
-#define COMP_RM                 BIT13 /* Radio Measurement */
-#define COMP_DIG                BIT14
-#define COMP_PHY                BIT15
-#define COMP_CH                 BIT16 /* Channel setting debug */
-#define COMP_TXAGC              BIT17 /* Tx power */
-#define COMP_HIPWR              BIT18 /* High Power Mechanism */
-#define COMP_HALDM              BIT19 /* HW Dynamic Mechanism */
-#define COMP_SEC                BIT20 /* Event handling */
-#define COMP_LED                BIT21
-#define COMP_RF                 BIT22
-#define COMP_RXDESC             BIT23 /* Rx desc information for SD3 debug */
+#define COMP_EPROM              BIT(7)
+#define COMP_SWBW               BIT(8)  /* Bandwidth switch. */
+#define COMP_POWER_TRACKING     BIT(9)  /* 8190 TX Power Tracking */
+#define COMP_TURBO              BIT(10) /* Turbo Mode */
+#define COMP_QOS                BIT(11)
+#define COMP_RATE               BIT(12) /* Rate Adaptive mechanism */
+#define COMP_RM                 BIT(13) /* Radio Measurement */
+#define COMP_DIG                BIT(14)
+#define COMP_PHY                BIT(15)
+#define COMP_CH                 BIT(16) /* Channel setting debug */
+#define COMP_TXAGC              BIT(17) /* Tx power */
+#define COMP_HIPWR              BIT(18) /* High Power Mechanism */
+#define COMP_HALDM              BIT(19) /* HW Dynamic Mechanism */
+#define COMP_SEC                BIT(20) /* Event handling */
+#define COMP_LED                BIT(21)
+#define COMP_RF                 BIT(22)
+#define COMP_RXDESC             BIT(23) /* Rx desc information for SD3 debug */
 
 /* 11n or 8190 specific code */
 
-#define COMP_FIRMWARE           BIT24 /* Firmware downloading */
-#define COMP_HT                 BIT25 /* 802.11n HT related information */
-#define COMP_AMSDU              BIT26 /* A-MSDU Debugging */
-#define COMP_SCAN               BIT27
-#define COMP_DOWN               BIT29 /* rm driver module */
-#define COMP_RESET              BIT30 /* Silent reset */
-#define COMP_ERR                BIT31 /* Error out, always on */
+#define COMP_FIRMWARE           BIT(24) /* Firmware downloading */
+#define COMP_HT                 BIT(25) /* 802.11n HT related information */
+#define COMP_AMSDU              BIT(26) /* A-MSDU Debugging */
+#define COMP_SCAN               BIT(27)
+#define COMP_DOWN               BIT(29) /* rm driver module */
+#define COMP_RESET              BIT(30) /* Silent reset */
+#define COMP_ERR                BIT(31) /* Error out, always on */
 
 #define RTL819x_DEBUG
 #ifdef RTL819x_DEBUG
diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index eab0d811e85a..678ecf6d2b79 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -233,7 +233,7 @@ static void CamResetAllEntry(struct net_device *dev)
 	 * condition, Cam can not be reset because upper layer will not set
 	 * this static key again.
 	 */
-	ulcommand |= BIT31 | BIT30;
+	ulcommand |= BIT(31) | BIT(30);
 	write_nic_dword(dev, RWCAM, ulcommand);
 
 }
@@ -242,7 +242,7 @@ static void CamResetAllEntry(struct net_device *dev)
 void write_cam(struct net_device *dev, u8 addr, u32 data)
 {
 	write_nic_dword(dev, WCAMI, data);
-	write_nic_dword(dev, RWCAM, BIT31 | BIT16 | (addr &amp; 0xff));
+	write_nic_dword(dev, RWCAM, BIT(31) | BIT(16) | (addr &amp; 0xff));
 }
 
 u32 read_cam(struct net_device *dev, u8 addr)
@@ -2412,7 +2412,7 @@ static void rtl8192_get_eeprom_size(struct net_device *dev)
 	read_nic_word_E(dev, EPROM_CMD, &amp;curCR);
 	RT_TRACE(COMP_EPROM,
 		 "read from Reg EPROM_CMD(%x):%x\n", EPROM_CMD, curCR);
-	/* whether need I consider BIT5? */
+	/* whether need I consider BIT(5?) */
 	priv-&gt;epromtype =
 		(curCR &amp; Cmd9346CR_9356SEL) ? EPROM_93c56 : EPROM_93c46;
 	RT_TRACE(COMP_EPROM,
@@ -5180,14 +5180,14 @@ void setKey(struct net_device *dev, u8 EntryNo, u8 KeyIndex, u16 KeyType,
 		 dev, EntryNo, KeyIndex, KeyType, MacAddr);
 
 	if (DefaultKey)
-		usConfig |= BIT15 | (KeyType &lt;&lt; 2);
+		usConfig |= BIT(15) | (KeyType &lt;&lt; 2);
 	else
-		usConfig |= BIT15 | (KeyType &lt;&lt; 2) | KeyIndex;
+		usConfig |= BIT(15) | (KeyType &lt;&lt; 2) | KeyIndex;
 
 
 	for (i = 0; i &lt; CAM_CONTENT_COUNT; i++) {
 		TargetCommand  = i + CAM_CONTENT_COUNT * EntryNo;
-		TargetCommand |= BIT31 | BIT16;
+		TargetCommand |= BIT(31) | BIT(16);
 
 		if (i == 0) { /* MAC|Config */
 			TargetContent = (u32)(*(MacAddr + 0)) &lt;&lt; 16 |
diff --git a/drivers/staging/rtl8192u/r8192U_dm.c b/drivers/staging/rtl8192u/r8192U_dm.c
index 5277f2eec033..375ec96b9469 100644
--- a/drivers/staging/rtl8192u/r8192U_dm.c
+++ b/drivers/staging/rtl8192u/r8192U_dm.c
@@ -325,21 +325,26 @@ static void dm_check_rate_adaptive(struct net_device *dev)
 			(!pHTInfo-&gt;bCurTxBW40MHz &amp;&amp; pHTInfo-&gt;bCurShortGI20MHz);
 
 		pra-&gt;upper_rssi_threshold_ratr =
-				(pra-&gt;upper_rssi_threshold_ratr &amp; (~BIT31)) | ((bshort_gi_enabled) ? BIT31:0);
+				(pra-&gt;upper_rssi_threshold_ratr &amp; (~BIT(31))) |
+				((bshort_gi_enabled) ? BIT(31) : 0);
 
 		pra-&gt;middle_rssi_threshold_ratr =
-				(pra-&gt;middle_rssi_threshold_ratr &amp; (~BIT31)) | ((bshort_gi_enabled) ? BIT31:0);
+				(pra-&gt;middle_rssi_threshold_ratr &amp; (~BIT(31))) |
+				((bshort_gi_enabled) ? BIT(31) : 0);
 
 		if (priv-&gt;CurrentChannelBW != HT_CHANNEL_WIDTH_20) {
 			pra-&gt;low_rssi_threshold_ratr =
-				(pra-&gt;low_rssi_threshold_ratr_40M &amp; (~BIT31)) | ((bshort_gi_enabled) ? BIT31:0);
+			      (pra-&gt;low_rssi_threshold_ratr_40M &amp; (~BIT(31))) |
+			      ((bshort_gi_enabled) ? BIT(31) : 0);
 		} else {
 			pra-&gt;low_rssi_threshold_ratr =
-			(pra-&gt;low_rssi_threshold_ratr_20M &amp; (~BIT31)) | ((bshort_gi_enabled) ? BIT31:0);
+			(pra-&gt;low_rssi_threshold_ratr_20M &amp; (~BIT(31))) |
+			((bshort_gi_enabled) ? BIT(31) : 0);
 		}
 		/* cosa add for test */
 		pra-&gt;ping_rssi_ratr =
-				(pra-&gt;ping_rssi_ratr &amp; (~BIT31)) | ((bshort_gi_enabled) ? BIT31:0);
+				(pra-&gt;ping_rssi_ratr &amp; (~BIT(31))) |
+				((bshort_gi_enabled) ? BIT(31) : 0);
 
 		/* 2007/10/08 MH We support RA smooth scheme now. When it is the first
 		   time to link with AP. We will not change upper/lower threshold. If
@@ -2378,7 +2383,7 @@ static	void	dm_check_pbc_gpio(struct net_device *dev)
 	if (tmp1byte == 0xff)
 		return;
 
-	if (tmp1byte&amp;BIT6 || tmp1byte&amp;BIT0) {
+	if (tmp1byte &amp; BIT(6) || tmp1byte &amp; BIT(0)) {
 		/*
 		 * Here we only set bPbcPressed to TRUE
 		 * After trigger PBC, the variable will be set to FALSE
diff --git a/drivers/staging/rtl8192u/r8192U_hw.h b/drivers/staging/rtl8192u/r8192U_hw.h
index a93694ff0c42..e07d65d04dbc 100644
--- a/drivers/staging/rtl8192u/r8192U_hw.h
+++ b/drivers/staging/rtl8192u/r8192U_hw.h
@@ -55,17 +55,17 @@ typedef enum _BaseBand_Config_Type{
 #define BB_ANTATTEN_CHAN14	0x0c
 #define BB_ANTENNA_B 0x40
 
-#define BB_HOST_BANG (1&lt;&lt;30)
-#define BB_HOST_BANG_EN (1&lt;&lt;2)
-#define BB_HOST_BANG_CLK (1&lt;&lt;1)
-#define BB_HOST_BANG_RW (1&lt;&lt;3)
+#define BB_HOST_BANG		BIT(30)
+#define BB_HOST_BANG_EN		BIT(2)
+#define BB_HOST_BANG_CLK	BIT(1)
+#define BB_HOST_BANG_RW		BIT(3)
 #define BB_HOST_BANG_DATA	 1
 
 //#if (RTL819X_FPGA_VER &amp; RTL819X_FPGA_VIVI_070920)
 #define AFR			0x010
-#define AFR_CardBEn		(1&lt;&lt;0)
-#define AFR_CLKRUN_SEL		(1&lt;&lt;1)
-#define AFR_FuncRegEn		(1&lt;&lt;2)
+#define AFR_CardBEn		BIT(0)
+#define AFR_CLKRUN_SEL		BIT(1)
+#define AFR_FuncRegEn		BIT(2)
 #define RTL8190_EEPROM_ID	0x8129
 #define EEPROM_VID		0x02
 #define EEPROM_PID		0x04
@@ -126,38 +126,39 @@ enum _RTL8192Usb_HW {
 #define TCR_LRL_OFFSET		0
 #define TCR_SRL_OFFSET		8
 #define TCR_MXDMA_OFFSET	21
-#define TCR_SAT			BIT24		// Enable Rate depedent ack timeout timer
+#define TCR_SAT			BIT(24)	// Enable Rate depedent ack timeout timer
 	RCR			= 0x044, // Receive Configuration Register
-#define MAC_FILTER_MASK ((1&lt;&lt;0) | (1&lt;&lt;1) | (1&lt;&lt;2) | (1&lt;&lt;3) | (1&lt;&lt;5) | \
-		(1&lt;&lt;12) | (1&lt;&lt;18) | (1&lt;&lt;19) | (1&lt;&lt;20) | (1&lt;&lt;21) | (1&lt;&lt;22) | (1&lt;&lt;23))
-#define RX_FIFO_THRESHOLD_MASK ((1&lt;&lt;13) | (1&lt;&lt;14) | (1&lt;&lt;15))
+#define MAC_FILTER_MASK (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(5) | \
+			 BIT(12) | BIT(18) | BIT(19) | BIT(20) | BIT(21) | \
+			 BIT(22) | BIT(23))
+#define RX_FIFO_THRESHOLD_MASK (BIT(13) | BIT(14) | BIT(15))
 #define RX_FIFO_THRESHOLD_SHIFT 13
 #define RX_FIFO_THRESHOLD_128 3
 #define RX_FIFO_THRESHOLD_256 4
 #define RX_FIFO_THRESHOLD_512 5
 #define RX_FIFO_THRESHOLD_1024 6
 #define RX_FIFO_THRESHOLD_NONE 7
-#define MAX_RX_DMA_MASK ((1&lt;&lt;8) | (1&lt;&lt;9) | (1&lt;&lt;10))
+#define MAX_RX_DMA_MASK 	(BIT(8) | BIT(9) | BIT(10))
 #define RCR_MXDMA_OFFSET	8
 #define RCR_FIFO_OFFSET		13
-#define RCR_ONLYERLPKT		BIT31			// Early Receiving based on Packet Size.
-#define RCR_ENCS2		BIT30			// Enable Carrier Sense Detection Method 2
-#define RCR_ENCS1		BIT29			// Enable Carrier Sense Detection Method 1
-#define RCR_ENMBID		BIT27			// Enable Multiple BssId.
-#define RCR_ACKTXBW		(BIT24|BIT25)		// TXBW Setting of ACK frames
-#define RCR_CBSSID		BIT23			// Accept BSSID match packet
-#define RCR_APWRMGT		BIT22			// Accept power management packet
-#define	RCR_ADD3		BIT21			// Accept address 3 match packet
-#define RCR_AMF			BIT20			// Accept management type frame
-#define RCR_ACF			BIT19			// Accept control type frame
-#define RCR_ADF			BIT18			// Accept data type frame
-#define RCR_RXFTH		BIT13			// Rx FIFO Threshold
-#define RCR_AICV		BIT12			// Accept ICV error packet
-#define	RCR_ACRC32		BIT5			// Accept CRC32 error packet
-#define	RCR_AB			BIT3			// Accept broadcast packet
-#define	RCR_AM			BIT2			// Accept multicast packet
-#define	RCR_APM			BIT1			// Accept physical match packet
-#define	RCR_AAP			BIT0			// Accept all unicast packet
+#define RCR_ONLYERLPKT		BIT(31)			// Early Receiving based on Packet Size.
+#define RCR_ENCS2		BIT(30)			// Enable Carrier Sense Detection Method 2
+#define RCR_ENCS1		BIT(29)			// Enable Carrier Sense Detection Method 1
+#define RCR_ENMBID		BIT(27)			// Enable Multiple BssId.
+#define RCR_ACKTXBW		(BIT(24) | BIT(25))	// TXBW Setting of ACK frames
+#define RCR_CBSSID		BIT(23)			// Accept BSSID match packet
+#define RCR_APWRMGT		BIT(22)			// Accept power management packet
+#define	RCR_ADD3		BIT(21)			// Accept address 3 match packet
+#define RCR_AMF			BIT(20)			// Accept management type frame
+#define RCR_ACF			BIT(19)			// Accept control type frame
+#define RCR_ADF			BIT(18)			// Accept data type frame
+#define RCR_RXFTH		BIT(13)			// Rx FIFO Threshold
+#define RCR_AICV		BIT(12)			// Accept ICV error packet
+#define	RCR_ACRC32		BIT(5)			// Accept CRC32 error packet
+#define	RCR_AB			BIT(3)			// Accept broadcast packet
+#define	RCR_AM			BIT(2)			// Accept multicast packet
+#define	RCR_APM			BIT(1)			// Accept physical match packet
+#define	RCR_AAP			BIT(0)			// Accept all unicast packet
 	SLOT_TIME		= 0x049, // Slot Time Register
 	ACK_TIMEOUT		= 0x04c, // Ack Timeout Register
 	PIFS_TIME		= 0x04d, // PIFS time
@@ -180,12 +181,12 @@ enum _RTL8192Usb_HW {
 	WCAMI			= 0x0A4, // Software write CAM input content
 	RCAMO			= 0x0A8, // Software read/write CAM config
 	SECR			= 0x0B0, //Security Configuration Register
-#define	SCR_TxUseDK		BIT0			//Force Tx Use Default Key
-#define SCR_RxUseDK		BIT1			//Force Rx Use Default Key
-#define SCR_TxEncEnable		BIT2			//Enable Tx Encryption
-#define SCR_RxDecEnable		BIT3			//Enable Rx Decryption
-#define SCR_SKByA2		BIT4			//Search kEY BY A2
-#define SCR_NoSKMC		BIT5			//No Key Search for Multicast
+#define	SCR_TxUseDK		BIT(0)			//Force Tx Use Default Key
+#define SCR_RxUseDK		BIT(1)			//Force Rx Use Default Key
+#define SCR_TxEncEnable		BIT(2)			//Enable Tx Encryption
+#define SCR_RxDecEnable		BIT(3)			//Enable Rx Decryption
+#define SCR_SKByA2		BIT(4)			//Search kEY BY A2
+#define SCR_NoSKMC		BIT(5)			//No Key Search for Multicast
 #define SCR_UseDK		0x01
 #define SCR_TxSecEnable		0x02
 #define SCR_RxSecEnable		0x04
@@ -226,13 +227,13 @@ enum _RTL8192Usb_HW {
 ////       8190 AcmHwCtrl bits                                    (offset 0x171, 1 byte)
 ////----------------------------------------------------------------------------
 //
-#define AcmHw_HwEn              BIT0
-#define AcmHw_BeqEn             BIT1
-#define AcmHw_ViqEn             BIT2
-#define AcmHw_VoqEn             BIT3
-#define AcmHw_BeqStatus         BIT4
-#define AcmHw_ViqStatus         BIT5
-#define AcmHw_VoqStatus         BIT6
+#define AcmHw_HwEn              BIT(0)
+#define AcmHw_BeqEn             BIT(1)
+#define AcmHw_ViqEn             BIT(2)
+#define AcmHw_VoqEn             BIT(3)
+#define AcmHw_BeqStatus         BIT(4)
+#define AcmHw_ViqStatus         BIT(5)
+#define AcmHw_VoqStatus         BIT(6)
 
 	AcmFwCtrl		= 0x172, // ACM Firmware Control Register
 	AES_11N_FIX		= 0x173,
@@ -281,18 +282,18 @@ enum _RTL8192Usb_HW {
 	NHM_RPI_COUNTER5	= 0x269, // Noise Histogram RPI counter5, the fraction of signal strength in (NHM_THRESHOLD4, NHM_THRESHOLD5].
 	NHM_RPI_COUNTER6	= 0x26A, // Noise Histogram RPI counter6, the fraction of signal strength in (NHM_THRESHOLD5, NHM_THRESHOLD6].
 	NHM_RPI_COUNTER7	= 0x26B, // Noise Histogram RPI counter7, the fraction of signal strength in (NHM_THRESHOLD6, NHM_THRESHOLD7].
-#define	BW_OPMODE_11J			BIT0
-#define	BW_OPMODE_5G			BIT1
-#define	BW_OPMODE_20MHZ			BIT2
+#define	BW_OPMODE_11J			BIT(0)
+#define	BW_OPMODE_5G			BIT(1)
+#define	BW_OPMODE_20MHZ			BIT(2)
 	BW_OPMODE		= 0x300, // Bandwidth operation mode
 	MSR			= 0x303, // Media Status register
-#define MSR_LINK_MASK      ((1&lt;&lt;0)|(1&lt;&lt;1))
+#define MSR_LINK_MASK      (BIT(0)|BIT(1))
 #define MSR_LINK_MANAGED   2
 #define MSR_LINK_NONE      0
 #define MSR_LINK_SHIFT     0
 #define MSR_LINK_ADHOC     1
 #define MSR_LINK_MASTER    3
-#define MSR_LINK_ENEDCA	   (1&lt;&lt;4)
+#define MSR_LINK_ENEDCA	   BIT(4)
 	RETRY_LIMIT		= 0x304, // Retry Limit [15:8]-short, [7:0]-long
 #define RETRY_LIMIT_SHORT_SHIFT 8
 #define RETRY_LIMIT_LONG_SHIFT 0
@@ -304,27 +305,27 @@ enum _RTL8192Usb_HW {
 #define RRSR_RSC_LOWSUBCHNL		0x400000
 #define RRSR_RSC_UPSUBCHANL		0x200000
 #define RRSR_SHORT					0x800000
-#define RRSR_1M						BIT0
-#define RRSR_2M						BIT1
-#define RRSR_5_5M					BIT2
-#define RRSR_11M					BIT3
-#define RRSR_6M						BIT4
-#define RRSR_9M						BIT5
-#define RRSR_12M					BIT6
-#define RRSR_18M					BIT7
-#define RRSR_24M					BIT8
-#define RRSR_36M					BIT9
-#define RRSR_48M					BIT10
-#define RRSR_54M					BIT11
-#define RRSR_MCS0					BIT12
-#define RRSR_MCS1					BIT13
-#define RRSR_MCS2					BIT14
-#define RRSR_MCS3					BIT15
-#define RRSR_MCS4					BIT16
-#define RRSR_MCS5					BIT17
-#define RRSR_MCS6					BIT18
-#define RRSR_MCS7					BIT19
-#define BRSR_AckShortPmb			BIT23		// CCK ACK: use Short Preamble or not.
+#define RRSR_1M						BIT(0)
+#define RRSR_2M						BIT(1)
+#define RRSR_5_5M					BIT(2)
+#define RRSR_11M					BIT(3)
+#define RRSR_6M						BIT(4)
+#define RRSR_9M						BIT(5)
+#define RRSR_12M					BIT(6)
+#define RRSR_18M					BIT(7)
+#define RRSR_24M					BIT(8)
+#define RRSR_36M					BIT(9)
+#define RRSR_48M					BIT(10)
+#define RRSR_54M					BIT(11)
+#define RRSR_MCS0					BIT(12)
+#define RRSR_MCS1					BIT(13)
+#define RRSR_MCS2					BIT(14)
+#define RRSR_MCS3					BIT(15)
+#define RRSR_MCS4					BIT(16)
+#define RRSR_MCS5					BIT(17)
+#define RRSR_MCS6					BIT(18)
+#define RRSR_MCS7					BIT(19)
+#define BRSR_AckShortPmb			BIT(23)		// CCK ACK: use Short Preamble or not.
 	RATR0			= 0x320, // Rate Adaptive Table register1
 	UFWP			= 0x318,
 	DRIVER_RSSI		= 0x32c,					// Driver tell Firmware current RSSI
@@ -380,10 +381,10 @@ enum _RTL8192Usb_HW {
 	MacBlkCtrl		= 0x403, // Mac block on/off control register
 
 	EPROM_CMD		= 0xfe58,
-#define Cmd9346CR_9356SEL	(1&lt;&lt;4)
-#define EPROM_CMD_RESERVED_MASK (1&lt;&lt;5)
+#define Cmd9346CR_9356SEL	BIT(4)
+#define EPROM_CMD_RESERVED_MASK BIT(5)
 #define EPROM_CMD_OPERATING_MODE_SHIFT 6
-#define EPROM_CMD_OPERATING_MODE_MASK ((1&lt;&lt;7)|(1&lt;&lt;6))
+#define EPROM_CMD_OPERATING_MODE_MASK (BIT(7) | BIT(6))
 #define EPROM_CMD_CONFIG 0x3
 #define EPROM_CMD_NORMAL 0
 #define EPROM_CMD_LOAD 1
diff --git a/drivers/staging/rtl8192u/r819xU_cmdpkt.h b/drivers/staging/rtl8192u/r819xU_cmdpkt.h
index cc8029a15df4..f490e253ee50 100644
--- a/drivers/staging/rtl8192u/r819xU_cmdpkt.h
+++ b/drivers/staging/rtl8192u/r819xU_cmdpkt.h
@@ -9,9 +9,9 @@
 #define		CMPK_TX_RAHIS_SIZE		sizeof(cmpk_tx_rahis_t)
 
 /* 2008/05/08 amy For USB constant. */
-#define ISR_TxBcnOk		BIT27		/* Transmit Beacon OK */
-#define ISR_TxBcnErr		BIT26		/* Transmit Beacon Error */
-#define ISR_BcnTimerIntr	BIT13		/* Beacon Timer Interrupt */
+#define ISR_TxBcnOk		BIT(27)		/* Transmit Beacon OK */
+#define ISR_TxBcnErr		BIT(26)		/* Transmit Beacon Error */
+#define ISR_BcnTimerIntr	BIT(13)		/* Beacon Timer Interrupt */
 
 
 /* Define element ID of command packet. */
diff --git a/drivers/staging/rtl8192u/r819xU_phy.c b/drivers/staging/rtl8192u/r819xU_phy.c
index e5dbaca9e518..70656441c145 100644
--- a/drivers/staging/rtl8192u/r819xU_phy.c
+++ b/drivers/staging/rtl8192u/r819xU_phy.c
@@ -1110,7 +1110,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 		case eRfOn:
 			/* RF-A, RF-B */
 			/* enable RF-Chip A/B - 0x860[4] */
-			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,
+			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT(4),
 					 0x1);
 			/* analog to digital on - 0x88c[9:8] */
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0x300,
@@ -1135,7 +1135,7 @@ bool rtl8192_SetRFPowerState(struct net_device *dev,
 		case eRfOff:
 			/* RF-A, RF-B */
 			/* disable RF-Chip A/B - 0x860[4] */
-			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT4,
+			rtl8192_setBBreg(dev, rFPGA0_XA_RFInterfaceOE, BIT(4),
 					 0x0);
 			/* analog to digital off, for power save */
 			rtl8192_setBBreg(dev, rFPGA0_AnalogParameter4, 0xf00,</pre><hr><pre>commit ffda203c0cf3b5b4648ba24c7d1ca34b9dcd4a3e
Author: Anish Bhatt &lt;anish@gatech.edu&gt;
Date:   Tue Sep 29 12:15:49 2015 -0700

    wilc1000 : Use BIT() macro where possible
    
    Replace (1 &lt;&lt; x) by BIT(x) as recommended by
    checkpatch.pl
    
    Signed-off-by: Anish Bhatt &lt;anish@gatech.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/wilc1000/host_interface.c b/drivers/staging/wilc1000/host_interface.c
index 99de804a1da8..358bd2dd0a13 100644
--- a/drivers/staging/wilc1000/host_interface.c
+++ b/drivers/staging/wilc1000/host_interface.c
@@ -7316,7 +7316,7 @@ static void *host_int_ParseJoinBssParam(tstrNetworkInfo *ptstrNetworkInfo)
 				pNewJoinBssParam-&gt;wmm_cap = true;
 
 				/* Check if Bit 7 is set indicating U-APSD capability */
-				if (pu8IEs[index + 8] &amp; (1 &lt;&lt; 7))
+				if (pu8IEs[index + 8] &amp; BIT(7))
 					pNewJoinBssParam-&gt;uapsd_cap = true;
 				index += pu8IEs[index + 1] + 2;
 				continue;
@@ -7332,7 +7332,7 @@ static void *host_int_ParseJoinBssParam(tstrNetworkInfo *ptstrNetworkInfo)
 				pNewJoinBssParam-&gt;u8Index = pu8IEs[index + 9];
 
 				/* Check if Bit 7 is set indicating Opss capability */
-				if (pu8IEs[index + 10] &amp; (1 &lt;&lt; 7)) {
+				if (pu8IEs[index + 10] &amp; BIT(7)) {
 					pNewJoinBssParam-&gt;u8OppEnable = 1;
 					pNewJoinBssParam-&gt;u8CtWindow = pu8IEs[index + 10];
 				} else
diff --git a/drivers/staging/wilc1000/host_interface.h b/drivers/staging/wilc1000/host_interface.h
index c96fff998e26..0261b367f077 100644
--- a/drivers/staging/wilc1000/host_interface.h
+++ b/drivers/staging/wilc1000/host_interface.h
@@ -138,25 +138,25 @@ typedef struct {
 } tstrCfgParamVal;
 
 typedef enum {
-	RETRY_SHORT		= 1 &lt;&lt; 0,
-	RETRY_LONG		= 1 &lt;&lt; 1,
-	FRAG_THRESHOLD		= 1 &lt;&lt; 2,
-	RTS_THRESHOLD		= 1 &lt;&lt; 3,
-	BSS_TYPE		= 1 &lt;&lt; 4,
-	AUTH_TYPE		= 1 &lt;&lt; 5,
-	AUTHEN_TIMEOUT		= 1 &lt;&lt; 6,
-	POWER_MANAGEMENT	= 1 &lt;&lt; 7,
-	PREAMBLE		= 1 &lt;&lt; 8,
-	SHORT_SLOT_ALLOWED	= 1 &lt;&lt; 9,
-	TXOP_PROT_DISABLE	= 1 &lt;&lt; 10,
-	BEACON_INTERVAL		= 1 &lt;&lt; 11,
-	DTIM_PERIOD		= 1 &lt;&lt; 12,
-	SITE_SURVEY		= 1 &lt;&lt; 13,
-	SITE_SURVEY_SCAN_TIME	= 1 &lt;&lt; 14,
-	ACTIVE_SCANTIME		= 1 &lt;&lt; 15,
-	PASSIVE_SCANTIME	= 1 &lt;&lt; 16,
-	CURRENT_TX_RATE		= 1 &lt;&lt; 17,
-	HT_ENABLE		= 1 &lt;&lt; 18,
+	RETRY_SHORT		= BIT(0),
+	RETRY_LONG		= BIT(1),
+	FRAG_THRESHOLD		= BIT(2),
+	RTS_THRESHOLD		= BIT(3),
+	BSS_TYPE		= BIT(4),
+	AUTH_TYPE		= BIT(5),
+	AUTHEN_TIMEOUT		= BIT(6),
+	POWER_MANAGEMENT	= BIT(7),
+	PREAMBLE		= BIT(8),
+	SHORT_SLOT_ALLOWED	= BIT(9),
+	TXOP_PROT_DISABLE	= BIT(10),
+	BEACON_INTERVAL		= BIT(11),
+	DTIM_PERIOD		= BIT(12),
+	SITE_SURVEY		= BIT(13),
+	SITE_SURVEY_SCAN_TIME	= BIT(14),
+	ACTIVE_SCANTIME		= BIT(15),
+	PASSIVE_SCANTIME	= BIT(16),
+	CURRENT_TX_RATE		= BIT(17),
+	HT_ENABLE		= BIT(18),
 } tenuCfgParam;
 
 typedef struct {
diff --git a/drivers/staging/wilc1000/linux_wlan_common.h b/drivers/staging/wilc1000/linux_wlan_common.h
index 8ef80c6ffbad..2b76e41ebd4d 100644
--- a/drivers/staging/wilc1000/linux_wlan_common.h
+++ b/drivers/staging/wilc1000/linux_wlan_common.h
@@ -44,10 +44,10 @@ void wilc_debugfs_remove(void);
 extern atomic_t REGION;
 extern atomic_t DEBUG_LEVEL;
 
-#define DEBUG           (1 &lt;&lt; 0)
-#define INFO            (1 &lt;&lt; 1)
-#define WRN             (1 &lt;&lt; 2)
-#define ERR             (1 &lt;&lt; 3)
+#define DEBUG           BIT(0)
+#define INFO            BIT(1)
+#define WRN             BIT(2)
+#define ERR             BIT(3)
 
 #define PRINT_D(region, ...)						\
 	do {								\
diff --git a/drivers/staging/wilc1000/wilc_sdio.c b/drivers/staging/wilc1000/wilc_sdio.c
index c22b35e643c7..6da65e88c345 100644
--- a/drivers/staging/wilc1000/wilc_sdio.c
+++ b/drivers/staging/wilc1000/wilc_sdio.c
@@ -529,7 +529,7 @@ static int sdio_sync(void)
 		return 0;
 	}
 
-	reg &amp;= ~(1 &lt;&lt; 8);
+	reg &amp;= ~BIT(8);
 	if (!sdio_write_reg(WILC_MISC, reg)) {
 		g_sdio.dPrint(N_ERR, "[wilc sdio]: Failed write misc reg...\n");
 		return 0;
@@ -548,7 +548,7 @@ static int sdio_sync(void)
 			g_sdio.dPrint(N_ERR, "[wilc spi]: Failed read reg (%08x)...\n", WILC_PIN_MUX_0);
 			return 0;
 		}
-		reg |= (1 &lt;&lt; 8);
+		reg |= BIT(8);
 		ret = sdio_write_reg(WILC_PIN_MUX_0, reg);
 		if (!ret) {
 			g_sdio.dPrint(N_ERR, "[wilc spi]: Failed write reg (%08x)...\n", WILC_PIN_MUX_0);
@@ -563,7 +563,7 @@ static int sdio_sync(void)
 			g_sdio.dPrint(N_ERR, "[wilc spi]: Failed read reg (%08x)...\n", WILC_INTR_ENABLE);
 			return 0;
 		}
-		reg |= (1 &lt;&lt; 16);
+		reg |= BIT(16);
 		ret = sdio_write_reg(WILC_INTR_ENABLE, reg);
 		if (!ret) {
 			g_sdio.dPrint(N_ERR, "[wilc spi]: Failed write reg (%08x)...\n", WILC_INTR_ENABLE);
@@ -756,17 +756,17 @@ static int sdio_read_int(u32 *int_status)
 	cmd.data = 0;
 	g_sdio.sdio_cmd52(&amp;cmd);
 
-	if (cmd.data &amp; (1 &lt;&lt; 0))
+	if (cmd.data &amp; BIT(0))
 		tmp |= INT_0;
-	if (cmd.data &amp; (1 &lt;&lt; 2))
+	if (cmd.data &amp; BIT(2))
 		tmp |= INT_1;
-	if (cmd.data &amp; (1 &lt;&lt; 3))
+	if (cmd.data &amp; BIT(3))
 		tmp |= INT_2;
-	if (cmd.data &amp; (1 &lt;&lt; 4))
+	if (cmd.data &amp; BIT(4))
 		tmp |= INT_3;
-	if (cmd.data &amp; (1 &lt;&lt; 5))
+	if (cmd.data &amp; BIT(5))
 		tmp |= INT_4;
-	if (cmd.data &amp; (1 &lt;&lt; 6))
+	if (cmd.data &amp; BIT(6))
 		tmp |= INT_5;
 	{
 		int i;
@@ -810,7 +810,7 @@ static int sdio_clear_int_ext(u32 val)
 		{
 			u32 flags;
 
-			flags = val &amp; ((1 &lt;&lt; MAX_NUN_INT_THRPT_ENH2) - 1);
+			flags = val &amp; (BIT(MAX_NUN_INT_THRPT_ENH2) - 1);
 			reg = flags;
 		}
 #else
@@ -818,13 +818,13 @@ static int sdio_clear_int_ext(u32 val)
 #endif
 		/* select VMM table 0 */
 		if ((val &amp; SEL_VMM_TBL0) == SEL_VMM_TBL0)
-			reg |= (1 &lt;&lt; 5);
+			reg |= BIT(5);
 		/* select VMM table 1 */
 		if ((val &amp; SEL_VMM_TBL1) == SEL_VMM_TBL1)
-			reg |= (1 &lt;&lt; 6);
+			reg |= BIT(6);
 		/* enable VMM */
 		if ((val &amp; EN_VMM) == EN_VMM)
-			reg |= (1 &lt;&lt; 7);
+			reg |= BIT(7);
 		if (reg) {
 			sdio_cmd52_t cmd;
 
@@ -848,7 +848,7 @@ static int sdio_clear_int_ext(u32 val)
 			/* Cannot clear multiple interrupts. Must clear each interrupt individually */
 			u32 flags;
 
-			flags = val &amp; ((1 &lt;&lt; MAX_NUM_INT) - 1);
+			flags = val &amp; (BIT(MAX_NUM_INT) - 1);
 			if (flags) {
 				int i;
 
@@ -861,7 +861,7 @@ static int sdio_clear_int_ext(u32 val)
 						cmd.function = 0;
 						cmd.raw = 0;
 						cmd.address = 0xf8;
-						cmd.data = (1 &lt;&lt; i);
+						cmd.data = BIT(i);
 
 						ret = g_sdio.sdio_cmd52(&amp;cmd);
 						if (!ret) {
@@ -891,13 +891,13 @@ static int sdio_clear_int_ext(u32 val)
 			vmm_ctl = 0;
 			/* select VMM table 0 */
 			if ((val &amp; SEL_VMM_TBL0) == SEL_VMM_TBL0)
-				vmm_ctl |= (1 &lt;&lt; 0);
+				vmm_ctl |= BIT(0);
 			/* select VMM table 1 */
 			if ((val &amp; SEL_VMM_TBL1) == SEL_VMM_TBL1)
-				vmm_ctl |= (1 &lt;&lt; 1);
+				vmm_ctl |= BIT(1);
 			/* enable VMM */
 			if ((val &amp; EN_VMM) == EN_VMM)
-				vmm_ctl |= (1 &lt;&lt; 2);
+				vmm_ctl |= BIT(2);
 
 			if (vmm_ctl) {
 				sdio_cmd52_t cmd;
@@ -944,7 +944,7 @@ static int sdio_sync_ext(int nint /*  how mant interrupts to enable. */)
 		return 0;
 	}
 
-	reg &amp;= ~(1 &lt;&lt; 8);
+	reg &amp;= ~BIT(8);
 	if (!sdio_write_reg(WILC_MISC, reg)) {
 		g_sdio.dPrint(N_ERR, "[wilc sdio]: Failed write misc reg...\n");
 		return 0;
@@ -963,7 +963,7 @@ static int sdio_sync_ext(int nint /*  how mant interrupts to enable. */)
 			g_sdio.dPrint(N_ERR, "[wilc sdio]: Failed read reg (%08x)...\n", WILC_PIN_MUX_0);
 			return 0;
 		}
-		reg |= (1 &lt;&lt; 8);
+		reg |= BIT(8);
 		ret = sdio_write_reg(WILC_PIN_MUX_0, reg);
 		if (!ret) {
 			g_sdio.dPrint(N_ERR, "[wilc sdio]: Failed write reg (%08x)...\n", WILC_PIN_MUX_0);
@@ -980,7 +980,7 @@ static int sdio_sync_ext(int nint /*  how mant interrupts to enable. */)
 		}
 
 		for (i = 0; (i &lt; 5) &amp;&amp; (nint &gt; 0); i++, nint--)
-			reg |= (1 &lt;&lt; (27 + i));
+			reg |= BIT((27 + i));
 		ret = sdio_write_reg(WILC_INTR_ENABLE, reg);
 		if (!ret) {
 			g_sdio.dPrint(N_ERR, "[wilc sdio]: Failed write reg (%08x)...\n", WILC_INTR_ENABLE);
@@ -994,7 +994,7 @@ static int sdio_sync_ext(int nint /*  how mant interrupts to enable. */)
 			}
 
 			for (i = 0; (i &lt; 3) &amp;&amp; (nint &gt; 0); i++, nint--)
-				reg |= (1 &lt;&lt; i);
+				reg |= BIT(i);
 
 			ret = sdio_read_reg(WILC_INTR2_ENABLE, &amp;reg);
 			if (!ret) {
diff --git a/drivers/staging/wilc1000/wilc_spi.c b/drivers/staging/wilc1000/wilc_spi.c
index 8426641197ca..f7627701fb35 100644
--- a/drivers/staging/wilc1000/wilc_spi.c
+++ b/drivers/staging/wilc1000/wilc_spi.c
@@ -128,7 +128,7 @@ static int spi_cmd(u8 cmd, u32 adr, u32 data, u32 sz, u8 clockless)
 	case CMD_INTERNAL_READ:                 /* internal register read */
 		bc[1] = (u8)(adr &gt;&gt; 8);
 		if (clockless)
-			bc[1] |= (1 &lt;&lt; 7);
+			bc[1] |= BIT(7);
 		bc[2] = (u8)adr;
 		bc[3] = 0x00;
 		len = 5;
@@ -179,7 +179,7 @@ static int spi_cmd(u8 cmd, u32 adr, u32 data, u32 sz, u8 clockless)
 	case CMD_INTERNAL_WRITE:                /* internal register write */
 		bc[1] = (u8)(adr &gt;&gt; 8);
 		if (clockless)
-			bc[1] |= (1 &lt;&lt; 7);
+			bc[1] |= BIT(7);
 		bc[2] = (u8)(adr);
 		bc[3] = (u8)(data &gt;&gt; 24);
 		bc[4] = (u8)(data &gt;&gt; 16);
@@ -288,7 +288,7 @@ static int spi_cmd_complete(u8 cmd, u32 adr, u8 *b, u32 sz, u8 clockless)
 	case CMD_INTERNAL_READ:                 /* internal register read */
 		wb[1] = (u8)(adr &gt;&gt; 8);
 		if (clockless == 1)
-			wb[1] |= (1 &lt;&lt; 7);
+			wb[1] |= BIT(7);
 		wb[2] = (u8)adr;
 		wb[3] = 0x00;
 		len = 5;
@@ -339,7 +339,7 @@ static int spi_cmd_complete(u8 cmd, u32 adr, u8 *b, u32 sz, u8 clockless)
 	case CMD_INTERNAL_WRITE:                /* internal register write */
 		wb[1] = (u8)(adr &gt;&gt; 8);
 		if (clockless == 1)
-			wb[1] |= (1 &lt;&lt; 7);
+			wb[1] |= BIT(7);
 		wb[2] = (u8)(adr);
 		wb[3] = b[3];
 		wb[4] = b[2];
@@ -1048,7 +1048,7 @@ static int spi_sync(void)
 		PRINT_ER("[wilc spi]: Failed read reg (%08x)...\n", WILC_PIN_MUX_0);
 		return 0;
 	}
-	reg |= (1 &lt;&lt; 8);
+	reg |= BIT(8);
 	ret = spi_write_reg(WILC_PIN_MUX_0, reg);
 	if (!ret) {
 		PRINT_ER("[wilc spi]: Failed write reg (%08x)...\n", WILC_PIN_MUX_0);
@@ -1063,7 +1063,7 @@ static int spi_sync(void)
 		PRINT_ER("[wilc spi]: Failed read reg (%08x)...\n", WILC_INTR_ENABLE);
 		return 0;
 	}
-	reg |= (1 &lt;&lt; 16);
+	reg |= BIT(16);
 	ret = spi_write_reg(WILC_INTR_ENABLE, reg);
 	if (!ret) {
 		PRINT_ER("[wilc spi]: Failed write reg (%08x)...\n", WILC_INTR_ENABLE);
@@ -1254,7 +1254,7 @@ static int spi_clear_int_ext(u32 val)
 	} else {
 		u32 flags;
 
-		flags = val &amp; ((1 &lt;&lt; MAX_NUM_INT) - 1);
+		flags = val &amp; (BIT(MAX_NUM_INT) - 1);
 		if (flags) {
 			int i;
 
@@ -1284,10 +1284,10 @@ static int spi_clear_int_ext(u32 val)
 			tbl_ctl = 0;
 			/* select VMM table 0 */
 			if ((val &amp; SEL_VMM_TBL0) == SEL_VMM_TBL0)
-				tbl_ctl |= (1 &lt;&lt; 0);
+				tbl_ctl |= BIT(0);
 			/* select VMM table 1 */
 			if ((val &amp; SEL_VMM_TBL1) == SEL_VMM_TBL1)
-				tbl_ctl |= (1 &lt;&lt; 1);
+				tbl_ctl |= BIT(1);
 
 			ret = spi_write_reg(WILC_VMM_TBL_CTL, tbl_ctl);
 			if (!ret) {
@@ -1331,7 +1331,7 @@ static int spi_sync_ext(int nint /*  how mant interrupts to enable. */)
 		PRINT_ER("[wilc spi]: Failed read reg (%08x)...\n", WILC_PIN_MUX_0);
 		return 0;
 	}
-	reg |= (1 &lt;&lt; 8);
+	reg |= BIT(8);
 	ret = spi_write_reg(WILC_PIN_MUX_0, reg);
 	if (!ret) {
 		PRINT_ER("[wilc spi]: Failed write reg (%08x)...\n", WILC_PIN_MUX_0);
@@ -1348,7 +1348,7 @@ static int spi_sync_ext(int nint /*  how mant interrupts to enable. */)
 	}
 
 	for (i = 0; (i &lt; 5) &amp;&amp; (nint &gt; 0); i++, nint--) {
-		reg |= (1 &lt;&lt; (27 + i));
+		reg |= (BIT((27 + i)));
 	}
 	ret = spi_write_reg(WILC_INTR_ENABLE, reg);
 	if (!ret) {
@@ -1363,7 +1363,7 @@ static int spi_sync_ext(int nint /*  how mant interrupts to enable. */)
 		}
 
 		for (i = 0; (i &lt; 3) &amp;&amp; (nint &gt; 0); i++, nint--) {
-			reg |= (1 &lt;&lt; i);
+			reg |= BIT(i);
 		}
 
 		ret = spi_read_reg(WILC_INTR2_ENABLE, &amp;reg);
diff --git a/drivers/staging/wilc1000/wilc_wfi_netdevice.h b/drivers/staging/wilc1000/wilc_wfi_netdevice.h
index af49c912558e..d3a03c68f803 100644
--- a/drivers/staging/wilc1000/wilc_wfi_netdevice.h
+++ b/drivers/staging/wilc1000/wilc_wfi_netdevice.h
@@ -52,8 +52,8 @@
 
 /*iftype*/
 enum stats_flags {
-	WILC_WFI_RX_PKT = 1 &lt;&lt; 0,
-	WILC_WFI_TX_PKT = 1 &lt;&lt; 1,
+	WILC_WFI_RX_PKT = BIT(0),
+	WILC_WFI_TX_PKT = BIT(1),
 };
 
 struct WILC_WFI_stats {
diff --git a/drivers/staging/wilc1000/wilc_wlan.c b/drivers/staging/wilc1000/wilc_wlan.c
index 93af5d430f91..428e94fdd716 100644
--- a/drivers/staging/wilc1000/wilc_wlan.c
+++ b/drivers/staging/wilc1000/wilc_wlan.c
@@ -649,7 +649,7 @@ static inline void chip_allow_sleep(void)
 	/* Clear bit 1 */
 	g_wlan.hif_func.hif_read_reg(0xf0, &amp;reg);
 
-	g_wlan.hif_func.hif_write_reg(0xf0, reg &amp; ~(1 &lt;&lt; 0));
+	g_wlan.hif_func.hif_write_reg(0xf0, reg &amp; ~BIT(0));
 }
 
 static inline void chip_wakeup(void)
@@ -661,10 +661,10 @@ static inline void chip_wakeup(void)
 		do {
 			g_wlan.hif_func.hif_read_reg(1, &amp;reg);
 			/* Set bit 1 */
-			g_wlan.hif_func.hif_write_reg(1, reg | (1 &lt;&lt; 1));
+			g_wlan.hif_func.hif_write_reg(1, reg | BIT(1));
 
 			/* Clear bit 1*/
-			g_wlan.hif_func.hif_write_reg(1, reg &amp; ~(1 &lt;&lt; 1));
+			g_wlan.hif_func.hif_write_reg(1, reg &amp; ~BIT(1));
 
 			do {
 				/* Wait for the chip to stabilize*/
@@ -681,7 +681,7 @@ static inline void chip_wakeup(void)
 		g_wlan.hif_func.hif_read_reg(0xf0, &amp;reg);
 		do {
 			/* Set bit 1 */
-			g_wlan.hif_func.hif_write_reg(0xf0, reg | (1 &lt;&lt; 0));
+			g_wlan.hif_func.hif_write_reg(0xf0, reg | BIT(0));
 
 			/* Check the clock status */
 			g_wlan.hif_func.hif_read_reg(0xf1, &amp;clk_status_reg);
@@ -704,7 +704,8 @@ static inline void chip_wakeup(void)
 			/* in case of failure, Reset the wakeup bit to introduce a new edge on the next loop */
 			if ((clk_status_reg &amp; 0x1) == 0) {
 				/* Reset bit 0 */
-				g_wlan.hif_func.hif_write_reg(0xf0, reg &amp; (~(1 &lt;&lt; 0)));
+				g_wlan.hif_func.hif_write_reg(0xf0, reg &amp;
+							      (~BIT(0)));
 			}
 		} while ((clk_status_reg &amp; 0x1) == 0);
 	}
@@ -712,7 +713,7 @@ static inline void chip_wakeup(void)
 
 	if (genuChipPSstate == CHIP_SLEEPING_MANUAL) {
 		g_wlan.hif_func.hif_read_reg(0x1C0C, &amp;reg);
-		reg &amp;= ~(1 &lt;&lt; 0);
+		reg &amp;= ~BIT(0);
 		g_wlan.hif_func.hif_write_reg(0x1C0C, reg);
 
 		if (wilc_get_chipid(false) &gt;= 0x1002b0) {
@@ -720,11 +721,11 @@ static inline void chip_wakeup(void)
 			u32 val32;
 
 			g_wlan.hif_func.hif_read_reg(0x1e1c, &amp;val32);
-			val32 |= (1 &lt;&lt; 6);
+			val32 |= BIT(6);
 			g_wlan.hif_func.hif_write_reg(0x1e1c, val32);
 
 			g_wlan.hif_func.hif_read_reg(0x1e9c, &amp;val32);
-			val32 |= (1 &lt;&lt; 6);
+			val32 |= BIT(6);
 			g_wlan.hif_func.hif_write_reg(0x1e9c, val32);
 		}
 	}
@@ -739,19 +740,19 @@ static inline void chip_wakeup(void)
 		if ((g_wlan.io_func.io_type &amp; 0x1) == HIF_SPI) {
 			g_wlan.hif_func.hif_read_reg(1, &amp;reg);
 			/* Make sure bit 1 is 0 before we start. */
-			g_wlan.hif_func.hif_write_reg(1, reg &amp; ~(1 &lt;&lt; 1));
+			g_wlan.hif_func.hif_write_reg(1, reg &amp; ~BIT(1));
 			/* Set bit 1 */
-			g_wlan.hif_func.hif_write_reg(1, reg | (1 &lt;&lt; 1));
+			g_wlan.hif_func.hif_write_reg(1, reg | BIT(1));
 			/* Clear bit 1*/
-			g_wlan.hif_func.hif_write_reg(1, reg  &amp; ~(1 &lt;&lt; 1));
+			g_wlan.hif_func.hif_write_reg(1, reg  &amp; ~BIT(1));
 		} else if ((g_wlan.io_func.io_type &amp; 0x1) == HIF_SDIO)	 {
 			/* Make sure bit 0 is 0 before we start. */
 			g_wlan.hif_func.hif_read_reg(0xf0, &amp;reg);
-			g_wlan.hif_func.hif_write_reg(0xf0, reg &amp; ~(1 &lt;&lt; 0));
+			g_wlan.hif_func.hif_write_reg(0xf0, reg &amp; ~BIT(0));
 			/* Set bit 1 */
-			g_wlan.hif_func.hif_write_reg(0xf0, reg | (1 &lt;&lt; 0));
+			g_wlan.hif_func.hif_write_reg(0xf0, reg | BIT(0));
 			/* Clear bit 1 */
-			g_wlan.hif_func.hif_write_reg(0xf0, reg  &amp; ~(1 &lt;&lt; 0));
+			g_wlan.hif_func.hif_write_reg(0xf0, reg  &amp; ~BIT(0));
 		}
 
 		do {
@@ -769,7 +770,7 @@ static inline void chip_wakeup(void)
 
 	if (genuChipPSstate == CHIP_SLEEPING_MANUAL) {
 		g_wlan.hif_func.hif_read_reg(0x1C0C, &amp;reg);
-		reg &amp;= ~(1 &lt;&lt; 0);
+		reg &amp;= ~BIT(0);
 		g_wlan.hif_func.hif_write_reg(0x1C0C, reg);
 
 		if (wilc_get_chipid(false) &gt;= 0x1002b0) {
@@ -777,11 +778,11 @@ static inline void chip_wakeup(void)
 			u32 val32;
 
 			g_wlan.hif_func.hif_read_reg(0x1e1c, &amp;val32);
-			val32 |= (1 &lt;&lt; 6);
+			val32 |= BIT(6);
 			g_wlan.hif_func.hif_write_reg(0x1e1c, val32);
 
 			g_wlan.hif_func.hif_read_reg(0x1e9c, &amp;val32);
-			val32 |= (1 &lt;&lt; 6);
+			val32 |= BIT(6);
 			g_wlan.hif_func.hif_write_reg(0x1e9c, val32);
 		}
 	}
@@ -873,7 +874,7 @@ static int wilc_wlan_handle_txq(u32 *pu32TxqCount)
 				PRINT_D(TX_DBG, "VMMTable entry size = %d\n", vmm_table[i]);
 
 				if (tqe-&gt;type == WILC_CFG_PKT) {
-					vmm_table[i] |= (1 &lt;&lt; 10);
+					vmm_table[i] |= BIT(10);
 					PRINT_D(TX_DBG, "VMMTable entry changed for CFG packet = %d\n", vmm_table[i]);
 				}
 #ifdef BIG_ENDIAN
@@ -998,7 +999,7 @@ static int wilc_wlan_handle_txq(u32 *pu32TxqCount)
 					wilc_debug(N_ERR, "[wilc txq]: fail can't read reg WILC_HOST_TX_CTRL..\n");
 					break;
 				}
-				reg &amp;= ~(1ul &lt;&lt; 0);
+				reg &amp;= ~BIT(0);
 				ret = p-&gt;hif_func.hif_write_reg(WILC_HOST_TX_CTRL, reg);
 				if (!ret) {
 					wilc_debug(N_ERR, "[wilc txq]: fail can't write reg WILC_HOST_TX_CTRL..\n");
@@ -1039,9 +1040,9 @@ static int wilc_wlan_handle_txq(u32 *pu32TxqCount)
 				vmm_sz *= 4;
 				header = (tqe-&gt;type &lt;&lt; 31) | (tqe-&gt;buffer_size &lt;&lt; 15) | vmm_sz;
 				if (tqe-&gt;type == WILC_MGMT_PKT)
-					header |= (1 &lt;&lt; 30);
+					header |= BIT(30);
 				else
-					header &amp;= ~(1 &lt;&lt; 30);
+					header &amp;= ~BIT(30);
 
 #ifdef BIG_ENDIAN
 				header = BYTE_SWAP(header);
@@ -1405,7 +1406,7 @@ static int wilc_wlan_firmware_download(const u8 *buffer, u32 buffer_size)
 	u8 *dma_buffer;
 	int ret = 0;
 
-	blksz = (1ul &lt;&lt; 12);
+	blksz = BIT(12);
 	/* Allocate a DMA coherent  buffer. */
 
 	dma_buffer = kmalloc(blksz, GFP_KERNEL);
@@ -1482,7 +1483,7 @@ static int wilc_wlan_start(void)
 	 **/
 	if (p-&gt;io_func.io_type == HIF_SDIO) {
 		reg = 0;
-		reg |= (1 &lt;&lt; 3); /* bug 4456 and 4557 */
+		reg |= BIT(3); /* bug 4456 and 4557 */
 	} else if (p-&gt;io_func.io_type == HIF_SPI) {
 		reg = 1;
 	}
@@ -1557,13 +1558,13 @@ static int wilc_wlan_start(void)
 
 
 	p-&gt;hif_func.hif_read_reg(WILC_GLB_RESET_0, &amp;reg);
-	if ((reg &amp; (1ul &lt;&lt; 10)) == (1ul &lt;&lt; 10)) {
-		reg &amp;= ~(1ul &lt;&lt; 10);
+	if ((reg &amp; BIT(10)) == BIT(10)) {
+		reg &amp;= ~BIT(10);
 		p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
 		p-&gt;hif_func.hif_read_reg(WILC_GLB_RESET_0, &amp;reg);
 	}
 
-	reg |= (1ul &lt;&lt; 10);
+	reg |= BIT(10);
 	ret = p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
 	p-&gt;hif_func.hif_read_reg(WILC_GLB_RESET_0, &amp;reg);
 	release_bus(RELEASE_ONLY);
@@ -1598,7 +1599,7 @@ static int wilc_wlan_stop(void)
 		return ret;
 	}
 
-	reg &amp;= ~(1 &lt;&lt; 10);
+	reg &amp;= ~BIT(10);
 
 
 	ret = p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
@@ -1619,9 +1620,9 @@ static int wilc_wlan_stop(void)
 		}
 		PRINT_D(GENERIC_DBG, "Read RESET Reg %x : Retry%d\n", reg, timeout);
 		/*Workaround to ensure that the chip is actually reset*/
-		if ((reg &amp; (1 &lt;&lt; 10))) {
+		if ((reg &amp; BIT(10))) {
 			PRINT_D(GENERIC_DBG, "Bit 10 not reset : Retry %d\n", timeout);
-			reg &amp;= ~(1 &lt;&lt; 10);
+			reg &amp;= ~BIT(10);
 			ret = p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
 			timeout--;
 		} else {
@@ -1637,10 +1638,11 @@ static int wilc_wlan_stop(void)
 		}
 
 	} while (timeout);
-	reg = ((1 &lt;&lt; 0) | (1 &lt;&lt; 1) | (1 &lt;&lt; 2) | (1 &lt;&lt; 3) | (1 &lt;&lt; 8) | (1 &lt;&lt; 9) | (1 &lt;&lt; 26) | (1 &lt;&lt; 29) | (1 &lt;&lt; 30) | (1 &lt;&lt; 31));
+	reg = (BIT(0) | BIT(1) | BIT(2) | BIT(3) | BIT(8) | BIT(9) | BIT(26) |
+	       BIT(29) | BIT(30) | BIT(31));
 
 	p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
-	reg = ~(1 &lt;&lt; 10);
+	reg = (u32)~BIT(10);
 
 	ret = p-&gt;hif_func.hif_write_reg(WILC_GLB_RESET_0, reg);
 
@@ -1868,7 +1870,7 @@ u32 init_chip(void)
 			wilc_debug(N_ERR, "[wilc start]: fail read reg 0x1118 ...\n");
 			return ret;
 		}
-		reg |= (1 &lt;&lt; 0);
+		reg |= BIT(0);
 		ret = g_wlan.hif_func.hif_write_reg(0x1118, reg);
 		if (!ret) {
 			wilc_debug(N_ERR, "[wilc start]: fail write reg 0x1118 ...\n");
diff --git a/drivers/staging/wilc1000/wilc_wlan.h b/drivers/staging/wilc1000/wilc_wlan.h
index 60da18c9d938..1ed4e2c9d396 100644
--- a/drivers/staging/wilc1000/wilc_wlan.h
+++ b/drivers/staging/wilc1000/wilc_wlan.h
@@ -152,7 +152,7 @@
 #endif
 
 
-#define ABORT_INT   (1 &lt;&lt; 31)
+#define ABORT_INT   BIT(31)
 
 /*******************************************/
 /*        E0 and later Interrupt flags.    */
@@ -191,15 +191,15 @@
 /* 7: Select VMM table 2                   */
 /* 8: Enable VMM                           */
 /*******************************************/
-#define CLR_INT0             (1 &lt;&lt; 0)
-#define CLR_INT1             (1 &lt;&lt; 1)
-#define CLR_INT2             (1 &lt;&lt; 2)
-#define CLR_INT3             (1 &lt;&lt; 3)
-#define CLR_INT4             (1 &lt;&lt; 4)
-#define CLR_INT5             (1 &lt;&lt; 5)
-#define SEL_VMM_TBL0         (1 &lt;&lt; 6)
-#define SEL_VMM_TBL1         (1 &lt;&lt; 7)
-#define EN_VMM               (1 &lt;&lt; 8)
+#define CLR_INT0             BIT(0)
+#define CLR_INT1             BIT(1)
+#define CLR_INT2             BIT(2)
+#define CLR_INT3             BIT(3)
+#define CLR_INT4             BIT(4)
+#define CLR_INT5             BIT(5)
+#define SEL_VMM_TBL0         BIT(6)
+#define SEL_VMM_TBL1         BIT(7)
+#define EN_VMM               BIT(8)
 
 #define DATA_INT_EXT	INT_0
 #define PLL_INT_EXT         INT_1</pre>
    <div class="pagination">
        <span>[1]</span><a href='27_2.html'>2</a><a href='27_3.html'>3</a><a href='27_2.html'>Next&gt;&gt;</a>
    <div>
</body>
