<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_91.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><span>[92]</span><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_93.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b01b03f3ad82b4293f6ca4da9b2692b6a377c609
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 28 11:06:11 2008 -0400

    USB: add new routine for checking port-resume type
    
    This patch (as1070) creates a new subroutine to check whether a device
    can be resumed.  This code is needed even when CONFIG_USB_SUSPEND
    isn't set, because devices do suspend themselves when the root hub
    (and hence the entire bus) is suspended, and power sessions can get
    lost during a system sleep even without individual port suspends.
    
    The patch also fixes a loose end in USB-Persist reset-resume handling.
    When a low- or full-speed device is attached to an EHCI's companion
    controller, the port handoff during resume will cause the companion
    port's connect-status-change feature to be set.  If that flag isn't
    cleared, the port-reset code will think it indicates that the device
    has been unplugged and the reset-resume will fail.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2a5c2833de38..d14da2123eb5 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1821,6 +1821,45 @@ static int hub_port_reset(struct usb_hub *hub, int port1,
 
 #ifdef	CONFIG_PM
 
+#define MASK_BITS	(USB_PORT_STAT_POWER | USB_PORT_STAT_CONNECTION | \
+				USB_PORT_STAT_SUSPEND)
+#define WANT_BITS	(USB_PORT_STAT_POWER | USB_PORT_STAT_CONNECTION)
+
+/* Determine whether the device on a port is ready for a normal resume,
+ * is ready for a reset-resume, or should be disconnected.
+ */
+static int check_port_resume_type(struct usb_device *udev,
+		struct usb_hub *hub, int port1,
+		int status, unsigned portchange, unsigned portstatus)
+{
+	/* Is the device still present? */
+	if (status || (portstatus &amp; MASK_BITS) != WANT_BITS) {
+		if (status &gt;= 0)
+			status = -ENODEV;
+	}
+
+	/* Can't do a normal resume if the port isn't enabled */
+	else if (!(portstatus &amp; USB_PORT_STAT_ENABLE) &amp;&amp; !udev-&gt;reset_resume)
+		status = -ENODEV;
+
+	if (status) {
+		dev_dbg(hub-&gt;intfdev,
+				"port %d status %04x.%04x after resume, %d\n",
+				port1, portchange, portstatus, status);
+	} else if (udev-&gt;reset_resume) {
+
+		/* Late port handoff can set status-change bits */
+		if (portchange &amp; USB_PORT_STAT_C_CONNECTION)
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_CONNECTION);
+		if (portchange &amp; USB_PORT_STAT_C_ENABLE)
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_ENABLE);
+	}
+
+	return status;
+}
+
 #ifdef	CONFIG_USB_SUSPEND
 
 /*
@@ -2025,7 +2064,6 @@ int usb_port_resume(struct usb_device *udev)
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	u16		portchange, portstatus;
-	unsigned	mask_flags, want_flags;
 
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
@@ -2054,35 +2092,23 @@ int usb_port_resume(struct usb_device *udev)
 		 */
 		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
 
- SuspendCleared:
-		if (udev-&gt;reset_resume)
-			want_flags = USB_PORT_STAT_POWER
-					| USB_PORT_STAT_CONNECTION;
-		else
-			want_flags = USB_PORT_STAT_POWER
-					| USB_PORT_STAT_CONNECTION
-					| USB_PORT_STAT_ENABLE;
-		mask_flags = want_flags | USB_PORT_STAT_SUSPEND;
+		/* TRSMRCY = 10 msec */
+		msleep(10);
+	}
 
-		if (status &lt; 0 || (portstatus &amp; mask_flags) != want_flags) {
-			dev_dbg(hub-&gt;intfdev,
-				"port %d status %04x.%04x after resume, %d\n",
-				port1, portchange, portstatus, status);
-			if (status &gt;= 0)
-				status = -ENODEV;
-		} else {
-			if (portchange &amp; USB_PORT_STAT_C_SUSPEND)
-				clear_port_feature(hub-&gt;hdev, port1,
-						USB_PORT_FEAT_C_SUSPEND);
-			/* TRSMRCY = 10 msec */
-			msleep(10);
-		}
+ SuspendCleared:
+	if (status == 0) {
+		if (portchange &amp; USB_PORT_STAT_C_SUSPEND)
+			clear_port_feature(hub-&gt;hdev, port1,
+					USB_PORT_FEAT_C_SUSPEND);
 	}
 
 	clear_bit(port1, hub-&gt;busy_bits);
 	if (!hub-&gt;hdev-&gt;parent &amp;&amp; !hub-&gt;busy_bits[0])
 		usb_enable_root_hub_irq(hub-&gt;hdev-&gt;bus);
 
+	status = check_port_resume_type(udev,
+			hub, port1, status, portchange, portstatus);
 	if (status == 0)
 		status = finish_port_resume(udev);
 	if (status &lt; 0) {
@@ -2115,12 +2141,23 @@ int usb_port_suspend(struct usb_device *udev)
 	return 0;
 }
 
+/* However we may need to do a reset-resume */
+
 int usb_port_resume(struct usb_device *udev)
 {
-	int status = 0;
+	struct usb_hub	*hub = hdev_to_hub(udev-&gt;parent);
+	int		port1 = udev-&gt;portnum;
+	int		status;
+	u16		portchange, portstatus;
 
-	/* However we may need to do a reset-resume */
-	if (udev-&gt;reset_resume) {
+	status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
+	status = check_port_resume_type(udev,
+			hub, port1, status, portchange, portstatus);
+
+	if (status) {
+		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n", status);
+		hub_port_logical_disconnect(hub, port1);
+	} else if (udev-&gt;reset_resume) {
 		dev_dbg(&amp;udev-&gt;dev, "reset-resume\n");
 		status = usb_reset_device(udev);
 	}</pre><hr><pre>commit bdb2b8cab4392ce41ddfbd6773a3da3334daf836
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 24 14:03:14 2008 -0400

    [SCSI] erase invalid data returned by device
    
    This patch (as1108) fixes a problem that can occur with certain USB
    mass-storage devices: They return invalid data together with a residue
    indicating that the data should be ignored.  Rather than leave the
    invalid data in a transfer buffer, where it can get misinterpreted,
    the patch clears the invalid portion of the buffer.
    
    This solves a problem (wrong write-protect setting detected) reported
    by Maciej Rutecki and Peter Teoh.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Peter Teoh &lt;htmldeveloper@gmail.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index a82d2fe80fb5..cbf55d59a54c 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -207,6 +207,15 @@ int scsi_execute(struct scsi_device *sdev, const unsigned char *cmd,
 	 */
 	blk_execute_rq(req-&gt;q, NULL, req, 1);
 
+	/*
+	 * Some devices (USB mass-storage in particular) may transfer
+	 * garbage data together with a residue indicating that the data
+	 * is invalid.  Prevent the garbage from being misinterpreted
+	 * and prevent security leaks by zeroing out the excess data.
+	 */
+	if (unlikely(req-&gt;data_len &gt; 0 &amp;&amp; req-&gt;data_len &lt;= bufflen))
+		memset(buffer + (bufflen - req-&gt;data_len), 0, req-&gt;data_len);
+
 	ret = req-&gt;errors;
  out:
 	blk_put_request(req);</pre><hr><pre>commit 1236edf1c70107a0d31b3fba0b2a8783615d0d24
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 1 10:45:51 2008 -0400

    USB: don't lose disconnections during suspend
    
    This patch (as1111) fixes a bug in the hub driver.  When a hub
    resumes, disconnections that occurred while the hub was suspended are
    lost.
    
    A completely different fix for this problem has already been accepted
    for 2.6.27; however the problem still needs to be handled in 2.6.26.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Lukas Hejtmanek &lt;xhejtman@ics.muni.cz&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 94789be54ca3..512d2d57d41e 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -713,18 +713,11 @@ static void hub_restart(struct usb_hub *hub, int type)
 		}
 
 		/* Was the power session lost while we were suspended? */
-		switch (type) {
-		case HUB_RESET_RESUME:
-			portstatus = 0;
-			portchange = USB_PORT_STAT_C_CONNECTION;
-			break;
+		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
 
-		case HUB_RESET:
-		case HUB_RESUME:
-			status = hub_port_status(hub, port1,
-					&amp;portstatus, &amp;portchange);
-			break;
-		}
+		/* If the device is gone, khubd will handle it later */
+		if (status == 0 &amp;&amp; !(portstatus &amp; USB_PORT_STAT_CONNECTION))
+			continue;
 
 		/* For "USB_PERSIST"-enabled children we must
 		 * mark the child device for reset-resume and</pre><hr><pre>commit 19c4158bcdf42ee3b2394342caf14f8471d2c78e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Mar 7 11:20:25 2008 -0500

    [SCSI] SCSI: remove dev-&gt;power.power_state from mesh driver
    
    power.power_state is scheduled for removal.  This patch (as1055)
    removes all uses of that field from the SCSI mesh driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Paul Mackerras &lt;paulus@au.ibm.com&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/mesh.c b/drivers/scsi/mesh.c
index fd63b06d9ef1..11aa917629ac 100644
--- a/drivers/scsi/mesh.c
+++ b/drivers/scsi/mesh.c
@@ -1765,7 +1765,7 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 	default:
 		return 0;
 	}
-	if (mesg.event == mdev-&gt;ofdev.dev.power.power_state.event)
+	if (ms-&gt;phase == sleeping)
 		return 0;
 
 	scsi_block_requests(ms-&gt;host);
@@ -1780,8 +1780,6 @@ static int mesh_suspend(struct macio_dev *mdev, pm_message_t mesg)
 	disable_irq(ms-&gt;meshintr);
 	set_mesh_power(ms, 0);
 
-	mdev-&gt;ofdev.dev.power.power_state = mesg;
-
 	return 0;
 }
 
@@ -1790,7 +1788,7 @@ static int mesh_resume(struct macio_dev *mdev)
 	struct mesh_state *ms = (struct mesh_state *)macio_get_drvdata(mdev);
 	unsigned long flags;
 
-	if (mdev-&gt;ofdev.dev.power.power_state.event == PM_EVENT_ON)
+	if (ms-&gt;phase != sleeping)
 		return 0;
 
 	set_mesh_power(ms, 1);
@@ -1801,8 +1799,6 @@ static int mesh_resume(struct macio_dev *mdev)
 	enable_irq(ms-&gt;meshintr);
 	scsi_unblock_requests(ms-&gt;host);
 
-	mdev-&gt;ofdev.dev.power.power_state.event = PM_EVENT_ON;
-
 	return 0;
 }
 </pre><hr><pre>commit c7257bd2ecb7b4cc42f9f152c7c059258d434169
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 21 13:53:01 2008 -0400

    USB: usb-storage: unusual_devs update for Cypress ATACB
    
    This patch (as1101) updates the unusual_devs entry for the Cypress
    ATACB pass-through.  The protocol field is changed from US_PR_BULK to
    US_PR_DEVICE, since the Cypress devices already set bInterfaceProtocol
    to Bulk-only.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1b09578cbb10..5d56893fc1cc 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -405,7 +405,7 @@ UNUSUAL_DEV(  0x04a5, 0x3010, 0x0100, 0x0100,
 UNUSUAL_DEV(  0x04b4, 0x6830, 0x0000, 0x9999,
 		"Cypress",
 		"Cypress AT2LP",
-		US_SC_CYP_ATACB, US_PR_BULK, NULL,
+		US_SC_CYP_ATACB, US_PR_DEVICE, NULL,
 		0),
 #endif
 </pre><hr><pre>commit fa38dfcc56b5f6cce787f9aaa5d1830509213802
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:59:33 2008 -0400

    USB: EHCI: fix performance regression
    
    This patch (as1099) fixes a performance regression in ehci-hcd.  The
    fundamental problem is that queue headers get removed from the
    schedule too quickly, since the code checks for a counter advancing
    rather than making an actual time-based check.  The latency involved
    in removing the queue header and then relinking it can severely
    degrade certain kinds of workloads.
    
    The patch replaces a simple counter with a timestamp derived from the
    controller's uframe value.  In addition, the delay for unlinking an
    idle queue header is increased from 5 ms to 10 ms; since some
    controllers (nVidia) have a latency of up to 1 ms for unlinking, this
    reduces the relative impact from 20% to 10%.
    
    Finally, a logical error left over from the IAA watchdog-timer
    conversion is corrected.  Now the driver will always either unlink an
    idle queue header or set up a timer to unlink it later.  The old code
    would sometimes fail to do either.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: Leonid &lt;leonidv11@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 369a8a5ea7bb..3e3c5d3ea0ad 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -84,7 +84,8 @@ static const char	hcd_name [] = "ehci_hcd";
 #define EHCI_IAA_MSECS		10		/* arbitrary */
 #define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
 #define EHCI_ASYNC_JIFFIES	(HZ/20)		/* async idle timeout */
-#define EHCI_SHRINK_JIFFIES	(HZ/200)	/* async qh unlink delay */
+#define EHCI_SHRINK_JIFFIES	(HZ/100)	/* async qh unlink delay */
+#define EHCI_SHRINK_UFRAMES	(10*8)		/* same value in uframes */
 
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index b85b54160cda..5200481deb27 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1116,8 +1116,7 @@ static void scan_async (struct ehci_hcd *ehci)
 	struct ehci_qh		*qh;
 	enum ehci_timer_action	action = TIMER_IO_WATCHDOG;
 
-	if (!++(ehci-&gt;stamp))
-		ehci-&gt;stamp++;
+	ehci-&gt;stamp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;frame_index);
 	timer_action_done (ehci, TIMER_ASYNC_SHRINK);
 rescan:
 	qh = ehci-&gt;async-&gt;qh_next.qh;
@@ -1148,12 +1147,14 @@ static void scan_async (struct ehci_hcd *ehci)
 			 * doesn't stay idle for long.
 			 * (plus, avoids some kind of re-activation race.)
 			 */
-			if (list_empty (&amp;qh-&gt;qtd_list)) {
-				if (qh-&gt;stamp == ehci-&gt;stamp)
+			if (list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+					qh-&gt;qh_state == QH_STATE_LINKED) {
+				if (!ehci-&gt;reclaim &amp;&amp;
+				    ((ehci-&gt;stamp - qh-&gt;stamp) &amp; 8191) &gt;=
+						EHCI_SHRINK_UFRAMES)
+					start_unlink_async(ehci, qh);
+				else
 					action = TIMER_ASYNC_SHRINK;
-				else if (!ehci-&gt;reclaim
-					    &amp;&amp; qh-&gt;qh_state == QH_STATE_LINKED)
-					start_unlink_async (ehci, qh);
 			}
 
 			qh = qh-&gt;qh_next.qh;</pre><hr><pre>commit b40e43fcc532fa44a375a37d592e32cd0d50fe7a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:59:10 2008 -0400

    USB: EHCI: fix bug in Iso scheduling
    
    This patch (as1098) changes the way ehci-hcd schedules its periodic
    Iso transfers.  That the current scheduling code is wrong is clear on
    the face of it: Sometimes it returns -EL2NSYNC (meaning that an URB
    couldn't be scheduled because it was submitted too late), but it does
    this even when the URB_ISO_ASAP flag is set (meaning the URB should be
    scheduled as soon as possible).
    
    The new code properly implements as-soon-as-possible scheduling,
    assigning the next unexpired slot as the URB's starting point.  It
    also is more careful about checking for Iso URB completion: It doesn't
    bother to check for activity during frames that are already over,
    and it allows for the possibility that some of the URB's packets may
    have raced the hardware when they were submitted and so never got used
    (the packet status is set to -EXDEV).
    
    This fixes problems several people have experienced with USB video
    applications.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index be575e46eac3..b7853c8bac0f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -1349,18 +1349,27 @@ iso_stream_schedule (
 	/* when's the last uframe this urb could start? */
 	max = now + mod;
 
-	/* typical case: reuse current schedule. stream is still active,
-	 * and no gaps from host falling behind (irq delays etc)
+	/* Typical case: reuse current schedule, stream is still active.
+	 * Hopefully there are no gaps from the host falling behind
+	 * (irq delays etc), but if there are we'll take the next
+	 * slot in the schedule, implicitly assuming URB_ISO_ASAP.
 	 */
 	if (likely (!list_empty (&amp;stream-&gt;td_list))) {
 		start = stream-&gt;next_uframe;
 		if (start &lt; now)
 			start += mod;
-		if (likely ((start + sched-&gt;span) &lt; max))
-			goto ready;
-		/* else fell behind; someday, try to reschedule */
-		status = -EL2NSYNC;
-		goto fail;
+
+		/* Fell behind (by up to twice the slop amount)? */
+		if (start &gt;= max - 2 * 8 * SCHEDULE_SLOP)
+			start += stream-&gt;interval * DIV_ROUND_UP(
+					max - start, stream-&gt;interval) - mod;
+
+		/* Tried to schedule too far into the future? */
+		if (unlikely((start + sched-&gt;span) &gt;= max)) {
+			status = -EFBIG;
+			goto fail;
+		}
+		goto ready;
 	}
 
 	/* need to schedule; when's the next (u)frame we could start?
@@ -1613,6 +1622,9 @@ itd_complete (
 		} else if (likely ((t &amp; EHCI_ISOC_ACTIVE) == 0)) {
 			desc-&gt;status = 0;
 			desc-&gt;actual_length = EHCI_ITD_LENGTH (t);
+		} else {
+			/* URB was too late */
+			desc-&gt;status = -EXDEV;
 		}
 	}
 
@@ -2095,7 +2107,7 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 static void
 scan_periodic (struct ehci_hcd *ehci)
 {
-	unsigned	frame, clock, now_uframe, mod;
+	unsigned	now_uframe, frame, clock, clock_frame, mod;
 	unsigned	modified;
 
 	mod = ehci-&gt;periodic_size &lt;&lt; 3;
@@ -2111,6 +2123,7 @@ scan_periodic (struct ehci_hcd *ehci)
 	else
 		clock = now_uframe + mod - 1;
 	clock %= mod;
+	clock_frame = clock &gt;&gt; 3;
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
@@ -2157,22 +2170,26 @@ scan_periodic (struct ehci_hcd *ehci)
 			case Q_TYPE_ITD:
 				/* If this ITD is still active, leave it for
 				 * later processing ... check the next entry.
+				 * No need to check for activity unless the
+				 * frame is current.
 				 */
-				rmb ();
-				for (uf = 0; uf &lt; 8 &amp;&amp; live; uf++) {
-					if (0 == (q.itd-&gt;hw_transaction [uf]
-							&amp; ITD_ACTIVE(ehci)))
-						continue;
-					incomplete = true;
-					q_p = &amp;q.itd-&gt;itd_next;
-					hw_p = &amp;q.itd-&gt;hw_next;
-					type = Q_NEXT_TYPE(ehci,
+				if (frame == clock_frame &amp;&amp; live) {
+					rmb();
+					for (uf = 0; uf &lt; 8; uf++) {
+						if (q.itd-&gt;hw_transaction[uf] &amp;
+							    ITD_ACTIVE(ehci))
+							break;
+					}
+					if (uf &lt; 8) {
+						incomplete = true;
+						q_p = &amp;q.itd-&gt;itd_next;
+						hw_p = &amp;q.itd-&gt;hw_next;
+						type = Q_NEXT_TYPE(ehci,
 							q.itd-&gt;hw_next);
-					q = *q_p;
-					break;
+						q = *q_p;
+						break;
+					}
 				}
-				if (uf &lt; 8 &amp;&amp; live)
-					break;
 
 				/* Take finished ITDs out of the schedule
 				 * and process them:  recycle, maybe report
@@ -2189,9 +2206,12 @@ scan_periodic (struct ehci_hcd *ehci)
 			case Q_TYPE_SITD:
 				/* If this SITD is still active, leave it for
 				 * later processing ... check the next entry.
+				 * No need to check for activity unless the
+				 * frame is current.
 				 */
-				if ((q.sitd-&gt;hw_results &amp; SITD_ACTIVE(ehci))
-						&amp;&amp; live) {
+				if (frame == clock_frame &amp;&amp; live &amp;&amp;
+						(q.sitd-&gt;hw_results &amp;
+							SITD_ACTIVE(ehci))) {
 					incomplete = true;
 					q_p = &amp;q.sitd-&gt;sitd_next;
 					hw_p = &amp;q.sitd-&gt;hw_next;
@@ -2260,6 +2280,7 @@ scan_periodic (struct ehci_hcd *ehci)
 
 			/* rescan the rest of this frame, then ... */
 			clock = now;
+			clock_frame = clock &gt;&gt; 3;
 		} else {
 			now_uframe++;
 			now_uframe %= mod;</pre><hr><pre>commit d1f114d12bb4db3147e1b1342ae31083c5a79c84
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:58:58 2008 -0400

    USB: EHCI: fix remote-wakeup regression
    
    This patch (as1097) fixes a bug in the remote-wakeup handling in
    ehci-hcd.  The driver currently does not keep track of whether the
    change-suspend feature is enabled for each port; the feature is
    automatically reset the first time it is read.  But recent changes to
    the hub driver require that the feature be read at least twice in
    order to work properly.
    
    A bit-vector is added for storing the change-suspend feature values.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index d613dc9e9c05..740835bb8575 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -609,7 +609,7 @@ static int ehci_hub_control (
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
-			/* we auto-clear this feature */
+			clear_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci-&gt;hcs_params))
@@ -688,7 +688,7 @@ static int ehci_hub_control (
 			/* resume completed? */
 			else if (time_after_eq(jiffies,
 					ehci-&gt;reset_done[wIndex])) {
-				status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
+				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
 				ehci-&gt;reset_done[wIndex] = 0;
 
 				/* stop resume signaling */
@@ -765,6 +765,8 @@ static int ehci_hub_control (
 			status |= 1 &lt;&lt; USB_PORT_FEAT_RESET;
 		if (temp &amp; PORT_POWER)
 			status |= 1 &lt;&lt; USB_PORT_FEAT_POWER;
+		if (test_bit(wIndex, &amp;ehci-&gt;port_c_suspend))
+			status |= 1 &lt;&lt; USB_PORT_FEAT_C_SUSPEND;
 
 #ifndef	VERBOSE_DEBUG
 	if (status &amp; ~0xffff)	/* only if wPortChange is interesting */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 3cb482308343..35a03095757e 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -97,6 +97,8 @@ struct ehci_hcd {			/* one per controller */
 			dedicated to the companion controller */
 	unsigned long		owned_ports;		/* which ports are
 			owned by the companion during a bus suspend */
+	unsigned long		port_c_suspend;		/* which ports have
+			the change-suspend feature turned on */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 3a31155cfff0935e4b178f3dca733d2d60d2eb8d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:58:29 2008 -0400

    USB: EHCI: suppress unwanted error messages
    
    This patch (as1096) fixes an annoying problem: When a full-speed or
    low-speed device is plugged into an EHCI controller, it fails to
    enumerate at high speed and then is handed over to the companion
    controller.  But usbcore logs a misleading and unwanted error message
    when the high-speed enumeration fails.
    
    The patch adds a new HCD method, port_handed_over, which asks whether
    a port has been handed over to a companion controller.  If it has, the
    error message is suppressed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 1e4b81e9eb50..a0bf5df6cb6f 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -213,6 +213,8 @@ struct hc_driver {
 
 		/* force handover of high-speed port to full-speed companion */
 	void	(*relinquish_port)(struct usb_hcd *, int);
+		/* has a port been handed over to a companion? */
+	int	(*port_handed_over)(struct usb_hcd *, int);
 };
 
 extern int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 1a3d2879bc1d..8eb4da332f56 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2753,7 +2753,11 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))
 			break;
 	}
-	dev_err(hub_dev, "unable to enumerate USB device on port %d\n", port1);
+	if (hub-&gt;hdev-&gt;parent ||
+			!hcd-&gt;driver-&gt;port_handed_over ||
+			!(hcd-&gt;driver-&gt;port_handed_over)(hcd, port1))
+		dev_err(hub_dev, "unable to enumerate USB device on port %d\n",
+				port1);
  
 done:
 	hub_port_disable(hub, port1, 1);
diff --git a/drivers/usb/host/ehci-au1xxx.c b/drivers/usb/host/ehci-au1xxx.c
index 8b5f991e949c..08a4335401a9 100644
--- a/drivers/usb/host/ehci-au1xxx.c
+++ b/drivers/usb/host/ehci-au1xxx.c
@@ -223,6 +223,7 @@ static const struct hc_driver ehci_au1xxx_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 4843062e6e21..7370d6187c64 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -318,6 +318,7 @@ static const struct hc_driver ehci_fsl_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 static int ehci_fsl_drv_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 382587c4457c..d613dc9e9c05 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -875,3 +875,13 @@ static void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)
 	set_owner(ehci, --portnum, PORT_OWNER);
 }
 
+static int ehci_port_handed_over(struct usb_hcd *hcd, int portnum)
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	u32 __iomem		*reg;
+
+	if (ehci_is_TDI(ehci))
+		return 0;
+	reg = &amp;ehci-&gt;regs-&gt;port_status[portnum - 1];
+	return ehci_readl(ehci, reg) &amp; PORT_OWNER;
+}
diff --git a/drivers/usb/host/ehci-ixp4xx.c b/drivers/usb/host/ehci-ixp4xx.c
index 539257f15924..9d042f220097 100644
--- a/drivers/usb/host/ehci-ixp4xx.c
+++ b/drivers/usb/host/ehci-ixp4xx.c
@@ -59,6 +59,7 @@ static const struct hc_driver ixp4xx_ehci_hc_driver = {
 	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 static int ixp4xx_ehci_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
index 9c5266d02d6c..ab625f0ba1d9 100644
--- a/drivers/usb/host/ehci-orion.c
+++ b/drivers/usb/host/ehci-orion.c
@@ -162,6 +162,7 @@ static const struct hc_driver ehci_orion_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 static void __init
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 6ff453f935e7..c46a58f9181d 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -379,6 +379,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
 	.relinquish_port =	ehci_relinquish_port,
+	.port_handed_over =	ehci_port_handed_over,
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-ppc-of.c b/drivers/usb/host/ehci-ppc-of.c
index d94a2ef4944c..b018deed2e8f 100644
--- a/drivers/usb/host/ehci-ppc-of.c
+++ b/drivers/usb/host/ehci-ppc-of.c
@@ -77,6 +77,7 @@ static const struct hc_driver ehci_ppc_of_hc_driver = {
 	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 
diff --git a/drivers/usb/host/ehci-ppc-soc.c b/drivers/usb/host/ehci-ppc-soc.c
index 6c76036783a1..529590eb4037 100644
--- a/drivers/usb/host/ehci-ppc-soc.c
+++ b/drivers/usb/host/ehci-ppc-soc.c
@@ -163,6 +163,7 @@ static const struct hc_driver ehci_ppc_soc_hc_driver = {
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
 	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
 };
 
 static int ehci_hcd_ppc_soc_drv_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-ps3.c b/drivers/usb/host/ehci-ps3.c
index 69782221bcf3..37e6abeb794c 100644
--- a/drivers/usb/host/ehci-ps3.c
+++ b/drivers/usb/host/ehci-ps3.c
@@ -73,6 +73,7 @@ static const struct hc_driver ps3_ehci_hc_driver = {
 	.bus_resume		= ehci_bus_resume,
 #endif
 	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
 };
 
 static int ps3_ehci_probe(struct ps3_system_bus_device *dev)</pre><hr><pre>commit a8e5177583e975fc1f7c621c93956f494df9b979
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 20 16:58:11 2008 -0400

    USB: EHCI: fix up root-hub TT mess
    
    This patch (as1095) cleans up the HCD glue and several of the EHCI
    bus-glue files.  The ehci-&gt;is_tdi_rh_tt flag is redundant, since it
    means the same thing as the hcd-&gt;has_tt flag, so it is removed and the
    other flag used in its place.
    
    Some of the bus-glue files didn't get the relinquish_port method added
    to their hc_driver structures.  Although that routine currently
    doesn't do anything for controllers with an integrated TT, in the
    future it might.  So the patch adds it where it is missing.
    
    Lastly, some of the bus-glue files have erroneous entries for their
    hc_driver's suspend and resume methods.  These method pointers are
    specific to PCI and shouldn't be used otherwise.
    
    (The patch also includes an invisible whitespace fix.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;

diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 6d9bed6c1f48..4843062e6e21 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -269,7 +269,7 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 	if (retval)
 		return retval;
 
-	ehci-&gt;is_tdi_rh_tt = 1;
+	hcd-&gt;has_tt = 1;
 
 	ehci-&gt;sbrn = 0x20;
 
@@ -295,10 +295,6 @@ static const struct hc_driver ehci_fsl_hc_driver = {
 	 */
 	.reset = ehci_fsl_setup,
 	.start = ehci_run,
-#ifdef	CONFIG_PM
-	.suspend = ehci_bus_suspend,
-	.resume = ehci_bus_resume,
-#endif
 	.stop = ehci_stop,
 	.shutdown = ehci_shutdown,
 
diff --git a/drivers/usb/host/ehci-ixp4xx.c b/drivers/usb/host/ehci-ixp4xx.c
index 601c8795a854..539257f15924 100644
--- a/drivers/usb/host/ehci-ixp4xx.c
+++ b/drivers/usb/host/ehci-ixp4xx.c
@@ -26,7 +26,7 @@ static int ixp4xx_ehci_init(struct usb_hcd *hcd)
 		+ HC_LENGTH(ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
 	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
 
-	ehci-&gt;is_tdi_rh_tt = 1;
+	hcd-&gt;has_tt = 1;
 	ehci_reset(ehci);
 
 	retval = ehci_init(hcd);
@@ -58,6 +58,7 @@ static const struct hc_driver ixp4xx_ehci_hc_driver = {
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 #endif
+	.relinquish_port	= ehci_relinquish_port,
 };
 
 static int ixp4xx_ehci_probe(struct platform_device *pdev)
diff --git a/drivers/usb/host/ehci-orion.c b/drivers/usb/host/ehci-orion.c
index 3adfda813a7b..9c5266d02d6c 100644
--- a/drivers/usb/host/ehci-orion.c
+++ b/drivers/usb/host/ehci-orion.c
@@ -139,10 +139,6 @@ static const struct hc_driver ehci_orion_hc_driver = {
 	 */
 	.reset = ehci_orion_setup,
 	.start = ehci_run,
-#ifdef CONFIG_PM
-	.suspend = ehci_bus_suspend,
-	.resume = ehci_bus_resume,
-#endif
 	.stop = ehci_stop,
 	.shutdown = ehci_shutdown,
 
@@ -165,6 +161,7 @@ static const struct hc_driver ehci_orion_hc_driver = {
 	.hub_control = ehci_hub_control,
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
+	.relinquish_port = ehci_relinquish_port,
 };
 
 static void __init
@@ -250,7 +247,7 @@ static int __init ehci_orion_drv_probe(struct platform_device *pdev)
 	ehci-&gt;regs = hcd-&gt;regs + 0x100 +
 		HC_LENGTH(ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
 	ehci-&gt;hcs_params = ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hcs_params);
-	ehci-&gt;is_tdi_rh_tt = 1;
+	hcd-&gt;has_tt = 1;
 	ehci-&gt;sbrn = 0x20;
 
 	/*
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 5bb7f6bb13f3..6ff453f935e7 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -129,7 +129,6 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	switch (pdev-&gt;vendor) {
 	case PCI_VENDOR_ID_TDI:
 		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
-			ehci-&gt;is_tdi_rh_tt = 1;
 			hcd-&gt;has_tt = 1;
 			tdi_reset(ehci);
 		}
@@ -379,7 +378,7 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.hub_control =		ehci_hub_control,
 	.bus_suspend =		ehci_bus_suspend,
 	.bus_resume =		ehci_bus_resume,
-	.relinquish_port = 	ehci_relinquish_port,
+	.relinquish_port =	ehci_relinquish_port,
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/ehci-ppc-of.c b/drivers/usb/host/ehci-ppc-of.c
index ee305b1f99ff..d94a2ef4944c 100644
--- a/drivers/usb/host/ehci-ppc-of.c
+++ b/drivers/usb/host/ehci-ppc-of.c
@@ -76,6 +76,7 @@ static const struct hc_driver ehci_ppc_of_hc_driver = {
 	.bus_suspend		= ehci_bus_suspend,
 	.bus_resume		= ehci_bus_resume,
 #endif
+	.relinquish_port	= ehci_relinquish_port,
 };
 
 
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index bf92d209a1a9..3cb482308343 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -112,7 +112,6 @@ struct ehci_hcd {			/* one per controller */
 	u32			command;
 
 	/* SILICON QUIRKS */
-	unsigned		is_tdi_rh_tt:1;	/* TDI roothub with TT */
 	unsigned		no_selective_suspend:1;
 	unsigned		has_fsl_port_bug:1; /* FreeScale */
 	unsigned		big_endian_mmio:1;
@@ -678,7 +677,7 @@ struct ehci_fstn {
  * needed (mostly in root hub code).
  */
 
-#define	ehci_is_TDI(e)			((e)-&gt;is_tdi_rh_tt)
+#define	ehci_is_TDI(e)			(ehci_to_hcd(e)-&gt;has_tt)
 
 /* Returns the speed of a device attached to a port on the root hub. */
 static inline unsigned int</pre>
    <div class="pagination">
        <a href='2_91.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><span>[92]</span><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_93.html'>Next&gt;&gt;</a>
    <div>
</body>
