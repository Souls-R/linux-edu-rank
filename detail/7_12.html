<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Minnesota</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Minnesota</h1>
    <div class="pagination">
        <a href='7_11.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><span>[12]</span><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_13.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 51dd97d1df5fb9ac58b9b358e63e67b530f6ae21
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Thu Mar 14 22:48:32 2019 -0500

    ASoC: rt5645: fix a NULL pointer dereference
    
    devm_kcalloc() may fail and return NULL. The fix returns ENOMEM
    in case it fails to avoid NULL pointer dereference.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c
index 9a0751978090..f842775dbf2c 100644
--- a/sound/soc/codecs/rt5645.c
+++ b/sound/soc/codecs/rt5645.c
@@ -3419,6 +3419,9 @@ static int rt5645_probe(struct snd_soc_component *component)
 		RT5645_HWEQ_NUM, sizeof(struct rt5645_eq_param_s),
 		GFP_KERNEL);
 
+	if (!rt5645-&gt;eq_param)
+		return -ENOMEM;
+
 	return 0;
 }
 </pre><hr><pre>commit cbb88db76a1536e02e93e5bd37ebbfbb6c4043a9
Author: Wenwen Wang &lt;wang6495@umn.edu&gt;
Date:   Mon Apr 29 12:45:40 2019 -0500

    ALSA: usx2y: fix a double free bug
    
    In usX2Y_In04_init(), a new urb is firstly created through usb_alloc_urb()
    and saved to 'usX2Y-&gt;In04urb'. Then, a buffer is allocated through
    kmalloc() and saved to 'usX2Y-&gt;In04Buf'. If the allocation of the buffer
    fails, the error code ENOMEM is returned after usb_free_urb(), which frees
    the created urb. However, the urb is actually freed at card-&gt;private_free
    callback, i.e., snd_usX2Y_card_private_free(). So the free operation here
    leads to a double free bug.
    
    To fix the above issue, simply remove usb_free_urb().
    
    Signed-off-by: Wenwen Wang &lt;wang6495@umn.edu&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/usb/usx2y/usbusx2y.c b/sound/usb/usx2y/usbusx2y.c
index 9f7bbed2c0f0..e8687b3bd3c8 100644
--- a/sound/usb/usx2y/usbusx2y.c
+++ b/sound/usb/usx2y/usbusx2y.c
@@ -293,10 +293,8 @@ int usX2Y_In04_init(struct usX2Ydev *usX2Y)
 	if (! (usX2Y-&gt;In04urb = usb_alloc_urb(0, GFP_KERNEL)))
 		return -ENOMEM;
 
-	if (! (usX2Y-&gt;In04Buf = kmalloc(21, GFP_KERNEL))) {
-		usb_free_urb(usX2Y-&gt;In04urb);
+	if (! (usX2Y-&gt;In04Buf = kmalloc(21, GFP_KERNEL)))
 		return -ENOMEM;
-	}
 	 
 	init_waitqueue_head(&amp;usX2Y-&gt;In04WaitQueue);
 	usb_fill_int_urb(usX2Y-&gt;In04urb, usX2Y-&gt;dev, usb_rcvintpipe(usX2Y-&gt;dev, 0x4),</pre><hr><pre>commit cb5173594d50c72b7bfa14113dfc5084b4d2f726
Author: Wenwen Wang &lt;wang6495@umn.edu&gt;
Date:   Sat Apr 27 01:06:46 2019 -0500

    ALSA: usb-audio: Fix a memory leak bug
    
    In parse_audio_selector_unit(), the string array 'namelist' is allocated
    through kmalloc_array(), and each string pointer in this array, i.e.,
    'namelist[]', is allocated through kmalloc() in the following for loop.
    Then, a control instance 'kctl' is created by invoking snd_ctl_new1(). If
    an error occurs during the creation process, the string array 'namelist',
    including all string pointers in the array 'namelist[]', should be freed,
    before the error code ENOMEM is returned. However, the current code does
    not free 'namelist[]', resulting in memory leaks.
    
    To fix the above issue, free all string pointers 'namelist[]' in a loop.
    
    Signed-off-by: Wenwen Wang &lt;wang6495@umn.edu&gt;
    Cc: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c
index c095d9751924..e003b5e7b01a 100644
--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -2675,6 +2675,8 @@ static int parse_audio_selector_unit(struct mixer_build *state, int unitid,
 	kctl = snd_ctl_new1(&amp;mixer_selectunit_ctl, cval);
 	if (! kctl) {
 		usb_audio_err(state-&gt;chip, "cannot malloc kcontrol\n");
+		for (i = 0; i &lt; desc-&gt;bNrInPins; i++)
+			kfree(namelist[i]);
 		kfree(namelist);
 		kfree(cval);
 		return -ENOMEM;</pre><hr><pre>commit 91862cc7867bba4ee5c8fcf0ca2f1d30427b6129
Author: Wenwen Wang &lt;wang6495@umn.edu&gt;
Date:   Fri Apr 19 21:22:59 2019 -0500

    tracing: Fix a memory leak by early error exit in trace_pid_write()
    
    In trace_pid_write(), the buffer for trace parser is allocated through
    kmalloc() in trace_parser_get_init(). Later on, after the buffer is used,
    it is then freed through kfree() in trace_parser_put(). However, it is
    possible that trace_pid_write() is terminated due to unexpected errors,
    e.g., ENOMEM. In that case, the allocated buffer will not be freed, which
    is a memory leak bug.
    
    To fix this issue, free the allocated buffer when an error is encountered.
    
    Link: http://lkml.kernel.org/r/1555726979-15633-1-git-send-email-wang6495@umn.edu
    
    Fixes: f4d34a87e9c10 ("tracing: Use pid bitmap instead of a pid array for set_event_pid")
    Cc: stable@vger.kernel.org
    Signed-off-by: Wenwen Wang &lt;wang6495@umn.edu&gt;
    Signed-off-by: Steven Rostedt (VMware) &lt;rostedt@goodmis.org&gt;

diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 0cfa13a60086..46f68fad6373 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -496,8 +496,10 @@ int trace_pid_write(struct trace_pid_list *filtered_pids,
 	 * not modified.
 	 */
 	pid_list = kmalloc(sizeof(*pid_list), GFP_KERNEL);
-	if (!pid_list)
+	if (!pid_list) {
+		trace_parser_put(&amp;parser);
 		return -ENOMEM;
+	}
 
 	pid_list-&gt;pid_max = READ_ONCE(pid_max);
 
@@ -507,6 +509,7 @@ int trace_pid_write(struct trace_pid_list *filtered_pids,
 
 	pid_list-&gt;pids = vzalloc((pid_list-&gt;pid_max + 7) &gt;&gt; 3);
 	if (!pid_list-&gt;pids) {
+		trace_parser_put(&amp;parser);
 		kfree(pid_list);
 		return -ENOMEM;
 	}</pre><hr><pre>commit 06d5d6b7f9948a89543e1160ef852d57892c750d
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Sat Apr 13 11:34:47 2019 +0100

    slimbus: fix a potential NULL pointer dereference in of_qcom_slim_ngd_register
    
    In case platform_device_alloc fails, the fix returns an error
    code to avoid the NULL pointer dereference.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Srinivas Kandagatla &lt;srinivas.kandagatla@linaro.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/slimbus/qcom-ngd-ctrl.c b/drivers/slimbus/qcom-ngd-ctrl.c
index 71f094c9ec68..f3585777324c 100644
--- a/drivers/slimbus/qcom-ngd-ctrl.c
+++ b/drivers/slimbus/qcom-ngd-ctrl.c
@@ -1342,6 +1342,10 @@ static int of_qcom_slim_ngd_register(struct device *parent,
 			return -ENOMEM;
 
 		ngd-&gt;pdev = platform_device_alloc(QCOM_SLIM_NGD_DRV_NAME, id);
+		if (!ngd-&gt;pdev) {
+			kfree(ngd);
+			return -ENOMEM;
+		}
 		ngd-&gt;id = id;
 		ngd-&gt;pdev-&gt;dev.parent = parent;
 		ngd-&gt;pdev-&gt;driver_override = QCOM_SLIM_NGD_DRV_NAME;</pre><hr><pre>commit d5414c2355b20ea8201156d2e874265f1cb0d775
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Sat Mar 23 15:49:16 2019 -0500

    rsi: Fix NULL pointer dereference in kmalloc
    
    kmalloc can fail in rsi_register_rates_channels but memcpy still attempts
    to write to channels. The patch replaces these calls with kmemdup and
    passes the error upstream.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: Kalle Valo &lt;kvalo@codeaurora.org&gt;

diff --git a/drivers/net/wireless/rsi/rsi_91x_mac80211.c b/drivers/net/wireless/rsi/rsi_91x_mac80211.c
index 831046e760f8..49df3bb08d41 100644
--- a/drivers/net/wireless/rsi/rsi_91x_mac80211.c
+++ b/drivers/net/wireless/rsi/rsi_91x_mac80211.c
@@ -188,27 +188,27 @@ bool rsi_is_cipher_wep(struct rsi_common *common)
  * @adapter: Pointer to the adapter structure.
  * @band: Operating band to be set.
  *
- * Return: None.
+ * Return: int - 0 on success, negative error on failure.
  */
-static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
+static int rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 {
 	struct ieee80211_supported_band *sbands = &amp;adapter-&gt;sbands[band];
 	void *channels = NULL;
 
 	if (band == NL80211_BAND_2GHZ) {
-		channels = kmalloc(sizeof(rsi_2ghz_channels), GFP_KERNEL);
-		memcpy(channels,
-		       rsi_2ghz_channels,
-		       sizeof(rsi_2ghz_channels));
+		channels = kmemdup(rsi_2ghz_channels, sizeof(rsi_2ghz_channels),
+				   GFP_KERNEL);
+		if (!channels)
+			return -ENOMEM;
 		sbands-&gt;band = NL80211_BAND_2GHZ;
 		sbands-&gt;n_channels = ARRAY_SIZE(rsi_2ghz_channels);
 		sbands-&gt;bitrates = rsi_rates;
 		sbands-&gt;n_bitrates = ARRAY_SIZE(rsi_rates);
 	} else {
-		channels = kmalloc(sizeof(rsi_5ghz_channels), GFP_KERNEL);
-		memcpy(channels,
-		       rsi_5ghz_channels,
-		       sizeof(rsi_5ghz_channels));
+		channels = kmemdup(rsi_5ghz_channels, sizeof(rsi_5ghz_channels),
+				   GFP_KERNEL);
+		if (!channels)
+			return -ENOMEM;
 		sbands-&gt;band = NL80211_BAND_5GHZ;
 		sbands-&gt;n_channels = ARRAY_SIZE(rsi_5ghz_channels);
 		sbands-&gt;bitrates = &amp;rsi_rates[4];
@@ -227,6 +227,7 @@ static void rsi_register_rates_channels(struct rsi_hw *adapter, int band)
 	sbands-&gt;ht_cap.mcs.rx_mask[0] = 0xff;
 	sbands-&gt;ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;
 	/* sbands-&gt;ht_cap.mcs.rx_highest = 0x82; */
+	return 0;
 }
 
 static int rsi_mac80211_hw_scan_start(struct ieee80211_hw *hw,
@@ -2064,11 +2065,16 @@ int rsi_mac80211_attach(struct rsi_common *common)
 	wiphy-&gt;available_antennas_rx = 1;
 	wiphy-&gt;available_antennas_tx = 1;
 
-	rsi_register_rates_channels(adapter, NL80211_BAND_2GHZ);
+	status = rsi_register_rates_channels(adapter, NL80211_BAND_2GHZ);
+	if (status)
+		return status;
 	wiphy-&gt;bands[NL80211_BAND_2GHZ] =
 		&amp;adapter-&gt;sbands[NL80211_BAND_2GHZ];
 	if (common-&gt;num_supp_bands &gt; 1) {
-		rsi_register_rates_channels(adapter, NL80211_BAND_5GHZ);
+		status = rsi_register_rates_channels(adapter,
+						     NL80211_BAND_5GHZ);
+		if (status)
+			return status;
 		wiphy-&gt;bands[NL80211_BAND_5GHZ] =
 			&amp;adapter-&gt;sbands[NL80211_BAND_5GHZ];
 	}</pre><hr><pre>commit 0ed2a005347400500a39ea7c7318f1fea57fb3ca
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Tue Mar 12 03:05:02 2019 -0500

    net: cw1200: fix a NULL pointer dereference
    
    In case create_singlethread_workqueue fails, the fix free the
    hardware and returns NULL to avoid NULL pointer dereference.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Kalle Valo &lt;kvalo@codeaurora.org&gt;

diff --git a/drivers/net/wireless/st/cw1200/main.c b/drivers/net/wireless/st/cw1200/main.c
index 90dc979f260b..c1608f0bf6d0 100644
--- a/drivers/net/wireless/st/cw1200/main.c
+++ b/drivers/net/wireless/st/cw1200/main.c
@@ -345,6 +345,11 @@ static struct ieee80211_hw *cw1200_init_common(const u8 *macaddr,
 	mutex_init(&amp;priv-&gt;wsm_cmd_mux);
 	mutex_init(&amp;priv-&gt;conf_mutex);
 	priv-&gt;workqueue = create_singlethread_workqueue("cw1200_wq");
+	if (!priv-&gt;workqueue) {
+		ieee80211_free_hw(hw);
+		return NULL;
+	}
+
 	sema_init(&amp;priv-&gt;scan.lock, 1);
 	INIT_WORK(&amp;priv-&gt;scan.work, cw1200_scan_work);
 	INIT_DELAYED_WORK(&amp;priv-&gt;scan.probe_work, cw1200_probe_work);</pre><hr><pre>commit 22e8860cf8f777fbf6a83f2fb7127f682a8e9de4
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Sun Mar 24 18:18:56 2019 -0500

    net: ieee802154: fix missing checks for regmap_update_bits
    
    regmap_update_bits could fail and deserves a check.
    
    The patch adds the checks and if it fails, returns its error
    code upstream.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Reviewed-by: Mukesh Ojha &lt;mojha@codeaurora.org&gt;
    Signed-off-by: Stefan Schmidt &lt;stefan@datenfreihafen.org&gt;

diff --git a/drivers/net/ieee802154/mcr20a.c b/drivers/net/ieee802154/mcr20a.c
index c589f5ae75bb..8bb53ec8d9cf 100644
--- a/drivers/net/ieee802154/mcr20a.c
+++ b/drivers/net/ieee802154/mcr20a.c
@@ -533,6 +533,8 @@ mcr20a_start(struct ieee802154_hw *hw)
 	dev_dbg(printdev(lp), "no slotted operation\n");
 	ret = regmap_update_bits(lp-&gt;regmap_dar, DAR_PHY_CTRL1,
 				 DAR_PHY_CTRL1_SLOTTED, 0x0);
+	if (ret &lt; 0)
+		return ret;
 
 	/* enable irq */
 	enable_irq(lp-&gt;spi-&gt;irq);
@@ -540,11 +542,15 @@ mcr20a_start(struct ieee802154_hw *hw)
 	/* Unmask SEQ interrupt */
 	ret = regmap_update_bits(lp-&gt;regmap_dar, DAR_PHY_CTRL2,
 				 DAR_PHY_CTRL2_SEQMSK, 0x0);
+	if (ret &lt; 0)
+		return ret;
 
 	/* Start the RX sequence */
 	dev_dbg(printdev(lp), "start the RX sequence\n");
 	ret = regmap_update_bits(lp-&gt;regmap_dar, DAR_PHY_CTRL1,
 				 DAR_PHY_CTRL1_XCVSEQ_MASK, MCR20A_XCVSEQ_RX);
+	if (ret &lt; 0)
+		return ret;
 
 	return 0;
 }</pre><hr><pre>commit 70c4cf17e445264453bc5323db3e50aa0ac9e81f
Author: Wenwen Wang &lt;wang6495@umn.edu&gt;
Date:   Fri Apr 19 20:49:29 2019 -0500

    audit: fix a memory leak bug
    
    In audit_rule_change(), audit_data_to_entry() is firstly invoked to
    translate the payload data to the kernel's rule representation. In
    audit_data_to_entry(), depending on the audit field type, an audit tree may
    be created in audit_make_tree(), which eventually invokes kmalloc() to
    allocate the tree.  Since this tree is a temporary tree, it will be then
    freed in the following execution, e.g., audit_add_rule() if the message
    type is AUDIT_ADD_RULE or audit_del_rule() if the message type is
    AUDIT_DEL_RULE. However, if the message type is neither AUDIT_ADD_RULE nor
    AUDIT_DEL_RULE, i.e., the default case of the switch statement, this
    temporary tree is not freed.
    
    To fix this issue, only allocate the tree when the type is AUDIT_ADD_RULE
    or AUDIT_DEL_RULE.
    
    Signed-off-by: Wenwen Wang &lt;wang6495@umn.edu&gt;
    Reviewed-by: Richard Guy Briggs &lt;rgb@redhat.com&gt;
    Signed-off-by: Paul Moore &lt;paul@paul-moore.com&gt;

diff --git a/kernel/auditfilter.c b/kernel/auditfilter.c
index 2c3c2f349b23..1bc6410413e6 100644
--- a/kernel/auditfilter.c
+++ b/kernel/auditfilter.c
@@ -1114,22 +1114,24 @@ int audit_rule_change(int type, int seq, void *data, size_t datasz)
 	int err = 0;
 	struct audit_entry *entry;
 
-	entry = audit_data_to_entry(data, datasz);
-	if (IS_ERR(entry))
-		return PTR_ERR(entry);
-
 	switch (type) {
 	case AUDIT_ADD_RULE:
+		entry = audit_data_to_entry(data, datasz);
+		if (IS_ERR(entry))
+			return PTR_ERR(entry);
 		err = audit_add_rule(entry);
 		audit_log_rule_change("add_rule", &amp;entry-&gt;rule, !err);
 		break;
 	case AUDIT_DEL_RULE:
+		entry = audit_data_to_entry(data, datasz);
+		if (IS_ERR(entry))
+			return PTR_ERR(entry);
 		err = audit_del_rule(entry);
 		audit_log_rule_change("remove_rule", &amp;entry-&gt;rule, !err);
 		break;
 	default:
-		err = -EINVAL;
 		WARN_ON(1);
+		return -EINVAL;
 	}
 
 	if (err || type == AUDIT_DEL_RULE) {</pre><hr><pre>commit ea094d53580f40c2124cef3d072b73b2425e7bfd
Author: Wenwen Wang &lt;wang6495@umn.edu&gt;
Date:   Wed Apr 17 09:18:50 2019 -0500

    x86/PCI: Fix PCI IRQ routing table memory leak
    
    In pcibios_irq_init(), the PCI IRQ routing table 'pirq_table' is first
    found through pirq_find_routing_table().  If the table is not found and
    CONFIG_PCI_BIOS is defined, the table is then allocated in
    pcibios_get_irq_routing_table() using kmalloc().  Later, if the I/O APIC is
    used, this table is actually not used.  In that case, the allocated table
    is not freed, which is a memory leak.
    
    Free the allocated table if it is not used.
    
    Signed-off-by: Wenwen Wang &lt;wang6495@umn.edu&gt;
    [bhelgaas: added Ingo's reviewed-by, since the only change since v1 was to
    use the irq_routing_table local variable name he suggested]
    Signed-off-by: Bjorn Helgaas &lt;bhelgaas@google.com&gt;
    Reviewed-by: Ingo Molnar &lt;mingo@kernel.org&gt;
    Acked-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;

diff --git a/arch/x86/pci/irq.c b/arch/x86/pci/irq.c
index 52e55108404e..d3a73f9335e1 100644
--- a/arch/x86/pci/irq.c
+++ b/arch/x86/pci/irq.c
@@ -1119,6 +1119,8 @@ static const struct dmi_system_id pciirq_dmi_table[] __initconst = {
 
 void __init pcibios_irq_init(void)
 {
+	struct irq_routing_table *rtable = NULL;
+
 	DBG(KERN_DEBUG "PCI: IRQ init\n");
 
 	if (raw_pci_ops == NULL)
@@ -1129,8 +1131,10 @@ void __init pcibios_irq_init(void)
 	pirq_table = pirq_find_routing_table();
 
 #ifdef CONFIG_PCI_BIOS
-	if (!pirq_table &amp;&amp; (pci_probe &amp; PCI_BIOS_IRQ_SCAN))
+	if (!pirq_table &amp;&amp; (pci_probe &amp; PCI_BIOS_IRQ_SCAN)) {
 		pirq_table = pcibios_get_irq_routing_table();
+		rtable = pirq_table;
+	}
 #endif
 	if (pirq_table) {
 		pirq_peer_trick();
@@ -1145,8 +1149,10 @@ void __init pcibios_irq_init(void)
 		 * If we're using the I/O APIC, avoid using the PCI IRQ
 		 * routing table
 		 */
-		if (io_apic_assign_pci_irqs)
+		if (io_apic_assign_pci_irqs) {
+			kfree(rtable);
 			pirq_table = NULL;
+		}
 	}
 
 	x86_init.pci.fixup_irqs();</pre>
    <div class="pagination">
        <a href='7_11.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><span>[12]</span><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_13.html'>Next&gt;&gt;</a>
    <div>
</body>
