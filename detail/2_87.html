<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_86.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><span>[87]</span><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_88.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8fc7aeab3851ed8c3ecf28901ca2c6f0400955c7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 20 09:52:12 2008 -0400

    USB: Speedtouch: add pre_reset and post_reset routines
    
    This patch (as1150) fixes a problem in the speedtch driver.  When it
    resets the modem during probe it will be unbound from the other
    interfaces it has claimed, because it doesn't define a pre_reset and a
    post_reset method.
    
    The patch defines "do-nothing" methods.  This fixes Bugzilla #11767.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/atm/speedtch.c b/drivers/usb/atm/speedtch.c
index 76fce44c2f9a..3e862401a638 100644
--- a/drivers/usb/atm/speedtch.c
+++ b/drivers/usb/atm/speedtch.c
@@ -722,6 +722,16 @@ static void speedtch_atm_stop(struct usbatm_data *usbatm, struct atm_dev *atm_de
 	flush_scheduled_work();
 }
 
+static int speedtch_pre_reset(struct usb_interface *intf)
+{
+	return 0;
+}
+
+static int speedtch_post_reset(struct usb_interface *intf)
+{
+	return 0;
+}
+
 
 /**********
 **  USB  **
@@ -740,6 +750,8 @@ static struct usb_driver speedtch_usb_driver = {
 	.name		= speedtch_driver_name,
 	.probe		= speedtch_usb_probe,
 	.disconnect	= usbatm_usb_disconnect,
+	.pre_reset	= speedtch_pre_reset,
+	.post_reset	= speedtch_post_reset,
 	.id_table	= speedtch_usb_ids
 };
 </pre><hr><pre>commit 71b7497c078a97e2afb774ad7c1f8ff5bdda8a60
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 9 15:40:23 2008 -0400

    USB: OHCI: fix endless polling behavior
    
    This patch (as1149) fixes an obscure problem in OHCI polling.  In the
    current code, if the RHSC interrupt status flag turns on at a time
    when RHSC interrupts are disabled, it will remain on forever:
    
            The interrupt handler is the only place where RHSC status
            gets turned back off;
    
            The interrupt handler won't turn RHSC status off because it
            doesn't turn off status flags if the corresponding interrupt
            isn't enabled;
    
            RHSC interrupts will never get enabled because
            ohci_root_hub_state_changes() doesn't reenable RHSC if RHSC
            status is on!
    
    As a result we will continue polling indefinitely instead of reverting
    to interrupt-driven operation, and the root hub will not autosuspend.
    This particular sequence of events is not at all unusual; in fact
    plugging a USB device into an OHCI controller will usually cause it to
    occur.
    
    Of course, this is a bug.  The proper thing to do is to turn off RHSC
    status just before reading the actual port status values.  That way
    either a port status change will be detected (if it occurs before the
    status read) or it will turn RHSC back on.  Possibly both, but that
    won't hurt anything.
    
    We can still check for systems in which RHSC is totally broken, by
    re-reading RHSC after clearing it and before reading the port
    statuses.  (This re-read has to be done anyway, to post the earlier
    write.)  If RHSC is on but no port-change statuses are set, then we
    know that RHSC is broken and we can avoid re-enabling it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index a150e85c901a..32bbce9718f0 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -359,17 +359,15 @@ static void ohci_finish_controller_resume(struct usb_hcd *hcd)
 
 /* Carry out polling-, autostop-, and autoresume-related state changes */
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
-		int any_connected)
+		int any_connected, int rhsc_status)
 {
 	int	poll_rh = 1;
-	int	rhsc_status, rhsc_enable;
+	int	rhsc_enable;
 
 	/* Some broken controllers never turn off RHCS in the interrupt
 	 * status register.  For their sake we won't re-enable RHSC
 	 * interrupts if the interrupt bit is already active.
 	 */
-	rhsc_status = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp;
-			OHCI_INTR_RHSC;
 	rhsc_enable = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
 			OHCI_INTR_RHSC;
 
@@ -421,14 +419,23 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 				ohci_rh_resume(ohci);
 			else
 				usb_hcd_resume_root_hub(ohci_to_hcd(ohci));
+
+		/* If remote wakeup is disabled, stop polling */
+		} else if (!ohci-&gt;autostop &amp;&amp;
+				!ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;
+					do_remote_wakeup) {
+			poll_rh = 0;
+
 		} else {
-			if (!rhsc_enable &amp;&amp; !rhsc_status &amp;&amp; (ohci-&gt;autostop ||
-					ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;
-						do_remote_wakeup)) {
+			/* If no status changes are pending,
+			 * enable RHSC interrupts
+			 */
+			if (!rhsc_enable &amp;&amp; !rhsc_status) {
 				rhsc_enable = OHCI_INTR_RHSC;
 				ohci_writel(ohci, rhsc_enable,
 						&amp;ohci-&gt;regs-&gt;intrenable);
 			}
+			/* Keep polling until RHSC is enabled */
 			if (rhsc_enable)
 				poll_rh = 0;
 		}
@@ -448,22 +455,22 @@ static inline int ohci_rh_resume(struct ohci_hcd *ohci)
  * autostop isn't used when CONFIG_PM is turned off.
  */
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
-		int any_connected)
+		int any_connected, int rhsc_status)
 {
-	int	rhsc_status;
-
 	/* If RHSC is enabled, don't poll */
 	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp; OHCI_INTR_RHSC)
 		return 0;
 
-	/* If no status changes are pending, enable RHSC interrupts */
-	rhsc_status = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp;
-			OHCI_INTR_RHSC;
-	if (!changed &amp;&amp; !rhsc_status) {
-		ohci_writel(ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
-		return 0;
-	}
-	return 1;
+	/* If status changes are pending, continue polling.
+	 * Conversely, if no status changes are pending but the RHSC
+	 * status bit was set, then RHSC may be broken so continue polling.
+	 */
+	if (changed || rhsc_status)
+		return 1;
+
+	/* It's safe to re-enable RHSC interrupts */
+	ohci_writel(ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
+	return 0;
 }
 
 #endif	/* CONFIG_PM */
@@ -478,6 +485,7 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
 	int		i, changed = 0, length = 1;
 	int		any_connected = 0;
+	int		rhsc_status;
 	unsigned long	flags;
 
 	spin_lock_irqsave (&amp;ohci-&gt;lock, flags);
@@ -503,6 +511,11 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		length++;
 	}
 
+	/* Clear the RHSC status flag before reading the port statuses */
+	ohci_writel(ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrstatus);
+	rhsc_status = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp;
+			OHCI_INTR_RHSC;
+
 	/* look at each port */
 	for (i = 0; i &lt; ohci-&gt;num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);
@@ -521,7 +534,7 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 	}
 
 	hcd-&gt;poll_rh = ohci_root_hub_state_changes(ohci, changed,
-			any_connected);
+			any_connected, rhsc_status);
 
 done:
 	spin_unlock_irqrestore (&amp;ohci-&gt;lock, flags);</pre><hr><pre>commit eafe5b99f2135488b21cf17a262c54997c44f784
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 6 11:25:53 2008 -0400

    USB: EHCI: fix remote-wakeup support for ARC/TDI core
    
    This patch (as1147) fixes the remote-wakeup support for EHCI
    controllers using the ARC/TDI "embedded-TT" core.  These controllers
    turn off the RESUME bit by themselves when a port resume is complete;
    hence we need to keep separate track of which ports are suspended or
    in the process of resuming.
    
    The patch also makes a couple of small improvements in ehci_irq(),
    replacing reads of the command register with the value already stored
    in a local variable.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Thomas Reitmayr &lt;treitmayr@devbase.at&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 358df2a6c396..d343afacb0b0 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -706,7 +706,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		pcd_status = status;
 
 		/* resume root hub? */
-		if (!(ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command) &amp; CMD_RUN))
+		if (!(cmd &amp; CMD_RUN))
 			usb_hcd_resume_root_hub(hcd);
 
 		while (i--) {
@@ -715,8 +715,11 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 			if (pstatus &amp; PORT_OWNER)
 				continue;
-			if (!(pstatus &amp; PORT_RESUME)
-					|| ehci-&gt;reset_done [i] != 0)
+			if (!(test_bit(i, &amp;ehci-&gt;suspended_ports) &amp;&amp;
+					((pstatus &amp; PORT_RESUME) ||
+						!(pstatus &amp; PORT_SUSPEND)) &amp;&amp;
+					(pstatus &amp; PORT_PE) &amp;&amp;
+					ehci-&gt;reset_done[i] == 0))
 				continue;
 
 			/* start 20 msec resume signaling from this port,
@@ -731,9 +734,8 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 	/* PCI errors [4.15.2.4] */
 	if (unlikely ((status &amp; STS_FATAL) != 0)) {
-		dbg_cmd (ehci, "fatal", ehci_readl(ehci,
-						   &amp;ehci-&gt;regs-&gt;command));
-		dbg_status (ehci, "fatal", status);
+		dbg_cmd(ehci, "fatal", cmd);
+		dbg_status(ehci, "fatal", status);
 		if (status &amp; STS_HALT) {
 			ehci_err (ehci, "fatal error\n");
 dead:
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 740835bb8575..218f9660d7ee 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -236,10 +236,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
 		temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
-				(temp &amp; PORT_SUSPEND)) {
-			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
+				(temp &amp; PORT_SUSPEND))
 			temp |= PORT_RESUME;
-		}
 		ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;port_status [i]);
 	}
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
@@ -482,10 +480,9 @@ ehci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		 * controller by the user.
 		 */
 
-		if ((temp &amp; mask) != 0
-				|| ((temp &amp; PORT_RESUME) != 0
-					&amp;&amp; time_after_eq(jiffies,
-						ehci-&gt;reset_done[i]))) {
+		if ((temp &amp; mask) != 0 || test_bit(i, &amp;ehci-&gt;port_c_suspend)
+				|| (ehci-&gt;reset_done[i] &amp;&amp; time_after_eq(
+					jiffies, ehci-&gt;reset_done[i]))) {
 			if (i &lt; 7)
 			    buf [0] |= 1 &lt;&lt; (i + 1);
 			else
@@ -688,6 +685,7 @@ static int ehci_hub_control (
 			/* resume completed? */
 			else if (time_after_eq(jiffies,
 					ehci-&gt;reset_done[wIndex])) {
+				clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
 				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
 				ehci-&gt;reset_done[wIndex] = 0;
 
@@ -734,6 +732,9 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
+		if (!(temp &amp; (PORT_RESUME|PORT_RESET)))
+			ehci-&gt;reset_done[wIndex] = 0;
+
 		/* transfer dedicated ports to the companion hc */
 		if ((temp &amp; PORT_CONNECT) &amp;&amp;
 				test_bit(wIndex, &amp;ehci-&gt;companion_ports)) {
@@ -757,8 +758,17 @@ static int ehci_hub_control (
 		}
 		if (temp &amp; PORT_PE)
 			status |= 1 &lt;&lt; USB_PORT_FEAT_ENABLE;
-		if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
+
+		/* maybe the port was unsuspended without our knowledge */
+		if (temp &amp; (PORT_SUSPEND|PORT_RESUME)) {
 			status |= 1 &lt;&lt; USB_PORT_FEAT_SUSPEND;
+		} else if (test_bit(wIndex, &amp;ehci-&gt;suspended_ports)) {
+			clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
+			ehci-&gt;reset_done[wIndex] = 0;
+			if (temp &amp; PORT_PE)
+				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
+		}
+
 		if (temp &amp; PORT_OC)
 			status |= 1 &lt;&lt; USB_PORT_FEAT_OVER_CURRENT;
 		if (temp &amp; PORT_RESET)
@@ -803,6 +813,7 @@ static int ehci_hub_control (
 					|| (temp &amp; PORT_RESET) != 0)
 				goto error;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
+			set_bit(wIndex, &amp;ehci-&gt;suspended_ports);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (HCS_PPC (ehci-&gt;hcs_params))
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index a6fd550b6903..b11798d17ae5 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -99,6 +99,8 @@ struct ehci_hcd {			/* one per controller */
 			owned by the companion during a bus suspend */
 	unsigned long		port_c_suspend;		/* which ports have
 			the change-suspend feature turned on */
+	unsigned long		suspended_ports;	/* which ports are
+			suspended */
 
 	/* per-HC memory pools (could be per-bus, but ...) */
 	struct dma_pool		*qh_pool;	/* qh per active urb */</pre><hr><pre>commit 2da41d5f6c036e7a6e496a7e601a685f8b87acb0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 6 11:24:26 2008 -0400

    USB: snoop processes opening usbfs device files
    
    This patch (as1148) adds a new "snoop" message to usbfs when a device
    file is opened, identifying the process responsible.  This comes in
    extremely handy when trying to determine which program is doing some
    unwanted USB access.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 7a4fa791dc19..528befdcc781 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -624,6 +624,8 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	smp_wmb();
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
+	snoop(&amp;dev-&gt;dev, "opened by process %d: %s\n", task_pid_nr(current),
+			current-&gt;comm);
  out:
 	if (ret) {
 		kfree(ps);</pre><hr><pre>commit 9beeee6584b9aa4f9192055512411484a2a624df
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 2 11:48:13 2008 -0400

    USB: EHCI: log a warning if ehci-hcd is not loaded first
    
    This patch (as1139) adds a warning to the system log whenever ehci-hcd
    is loaded after ohci-hcd or uhci-hcd.  Nowadays most distributions are
    pretty good about not doing this; maybe the warning will help convince
    anyone still doing it wrong.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;  [2.6.27]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index c8035a8216bd..fc9018e72a09 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -81,6 +81,10 @@
 
 /*-------------------------------------------------------------------------*/
 
+/* Keep track of which host controller drivers are loaded */
+unsigned long usb_hcds_loaded;
+EXPORT_SYMBOL_GPL(usb_hcds_loaded);
+
 /* host controllers we manage */
 LIST_HEAD (usb_bus_list);
 EXPORT_SYMBOL_GPL (usb_bus_list);
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index e710ce04e228..2dcde61c465e 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -482,4 +482,10 @@ static inline void usbmon_urb_complete(struct usb_bus *bus, struct urb *urb,
  */
 extern struct rw_semaphore ehci_cf_port_reset_rwsem;
 
+/* Keep track of which host controller drivers are loaded */
+#define USB_UHCI_LOADED		0
+#define USB_OHCI_LOADED		1
+#define USB_EHCI_LOADED		2
+extern unsigned long usb_hcds_loaded;
+
 #endif /* __KERNEL__ */
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index fcbc1f2b2377..358df2a6c396 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1046,6 +1046,12 @@ static int __init ehci_hcd_init(void)
 		return -ENODEV;
 
 	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
+	set_bit(USB_EHCI_LOADED, &amp;usb_hcds_loaded);
+	if (test_bit(USB_UHCI_LOADED, &amp;usb_hcds_loaded) ||
+			test_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded))
+		printk(KERN_WARNING "Warning! ehci_hcd should always be loaded"
+				" before uhci_hcd and ohci_hcd, not after\n");
+
 	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
 		 hcd_name,
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
@@ -1053,8 +1059,10 @@ static int __init ehci_hcd_init(void)
 
 #ifdef DEBUG
 	ehci_debug_root = debugfs_create_dir("ehci", NULL);
-	if (!ehci_debug_root)
-		return -ENOENT;
+	if (!ehci_debug_root) {
+		retval = -ENOENT;
+		goto err_debug;
+	}
 #endif
 
 #ifdef PLATFORM_DRIVER
@@ -1102,6 +1110,8 @@ static int __init ehci_hcd_init(void)
 	debugfs_remove(ehci_debug_root);
 	ehci_debug_root = NULL;
 #endif
+err_debug:
+	clear_bit(USB_EHCI_LOADED, &amp;usb_hcds_loaded);
 	return retval;
 }
 module_init(ehci_hcd_init);
@@ -1123,6 +1133,7 @@ static void __exit ehci_hcd_cleanup(void)
 #ifdef DEBUG
 	debugfs_remove(ehci_debug_root);
 #endif
+	clear_bit(USB_EHCI_LOADED, &amp;usb_hcds_loaded);
 }
 module_exit(ehci_hcd_cleanup);
 
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 0afeda836df3..8647dab0d7f9 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1095,6 +1095,7 @@ static int __init ohci_hcd_mod_init(void)
 	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
 	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
 		sizeof (struct ed), sizeof (struct td));
+	set_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);
 
 #ifdef DEBUG
 	ohci_debug_root = debugfs_create_dir("ohci", NULL);
@@ -1181,6 +1182,7 @@ static int __init ohci_hcd_mod_init(void)
  error_debug:
 #endif
 
+	clear_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);
 	return retval;
 }
 module_init(ohci_hcd_mod_init);
@@ -1211,6 +1213,7 @@ static void __exit ohci_hcd_mod_exit(void)
 #ifdef DEBUG
 	debugfs_remove(ohci_debug_root);
 #endif
+	clear_bit(USB_OHCI_LOADED, &amp;usb_hcds_loaded);
 }
 module_exit(ohci_hcd_mod_exit);
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 2dddb258b0db..cf5e4cf7ea42 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -955,6 +955,7 @@ static int __init uhci_hcd_init(void)
 
 	printk(KERN_INFO "uhci_hcd: " DRIVER_DESC "%s\n",
 			ignore_oc ? ", overcurrent ignored" : "");
+	set_bit(USB_UHCI_LOADED, &amp;usb_hcds_loaded);
 
 	if (DEBUG_CONFIGURED) {
 		errbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);
@@ -987,6 +988,7 @@ static int __init uhci_hcd_init(void)
 
 errbuf_failed:
 
+	clear_bit(USB_UHCI_LOADED, &amp;usb_hcds_loaded);
 	return retval;
 }
 
@@ -996,6 +998,7 @@ static void __exit uhci_hcd_cleanup(void)
 	kmem_cache_destroy(uhci_up_cachep);
 	debugfs_remove(uhci_debugfs_root);
 	kfree(errbuf);
+	clear_bit(USB_UHCI_LOADED, &amp;usb_hcds_loaded);
 }
 
 module_init(uhci_hcd_init);</pre><hr><pre>commit 2b70f07343389cb474235def00b021a645ede916
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 2 11:47:15 2008 -0400

    USB: EHCI, OHCI, UHCI: remove version numbers
    
    This patch (as1145) removes the essentially useless driver-version
    strings from ehci-hcd, ohci-hcd, and uhci-hcd.  It also unifies the
    form of the banner lines they display upon loading and adds a missing
    test for usb_disabled() to ehci-hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 5d57773e730e..0cb53ca8d343 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -675,7 +675,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
 		size = scnprintf (next, size,
-			"bus %s, device %s (driver " DRIVER_VERSION ")\n"
+			"bus %s, device %s\n"
 			"%s\n"
 			"SUSPENDED (no register access)\n",
 			hcd-&gt;self.controller-&gt;bus-&gt;name,
@@ -687,7 +687,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	/* Capability Registers */
 	i = HC_VERSION(ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
 	temp = scnprintf (next, size,
-		"bus %s, device %s (driver " DRIVER_VERSION ")\n"
+		"bus %s, device %s\n"
 		"%s\n"
 		"EHCI %x.%02x, hcd state %d\n",
 		hcd-&gt;self.controller-&gt;bus-&gt;name,
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c6f9961eed3c..fcbc1f2b2377 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -60,7 +60,6 @@
  * providing early devices for those host controllers to talk to!
  */
 
-#define DRIVER_VERSION "10 Dec 2004"
 #define DRIVER_AUTHOR "David Brownell"
 #define DRIVER_DESC "USB 2.0 'Enhanced' Host Controller (EHCI) Driver"
 
@@ -621,9 +620,9 @@ static int ehci_run (struct usb_hcd *hcd)
 
 	temp = HC_VERSION(ehci_readl(ehci, &amp;ehci-&gt;caps-&gt;hc_capbase));
 	ehci_info (ehci,
-		"USB %x.%x started, EHCI %x.%02x, driver %s%s\n",
+		"USB %x.%x started, EHCI %x.%02x%s\n",
 		((ehci-&gt;sbrn &amp; 0xf0)&gt;&gt;4), (ehci-&gt;sbrn &amp; 0x0f),
-		temp &gt;&gt; 8, temp &amp; 0xff, DRIVER_VERSION,
+		temp &gt;&gt; 8, temp &amp; 0xff,
 		ignore_oc ? ", overcurrent ignored" : "");
 
 	ehci_writel(ehci, INTR_MASK,
@@ -995,9 +994,7 @@ static int ehci_get_frame (struct usb_hcd *hcd)
 
 /*-------------------------------------------------------------------------*/
 
-#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
-
-MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
@@ -1045,6 +1042,10 @@ static int __init ehci_hcd_init(void)
 {
 	int retval = 0;
 
+	if (usb_disabled())
+		return -ENODEV;
+
+	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
 	pr_debug("%s: block sizes: qh %Zd qtd %Zd itd %Zd sitd %Zd\n",
 		 hcd_name,
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
diff --git a/drivers/usb/host/ohci-dbg.c b/drivers/usb/host/ohci-dbg.c
index 7cef1d2f7ccc..d3269656aa4d 100644
--- a/drivers/usb/host/ohci-dbg.c
+++ b/drivers/usb/host/ohci-dbg.c
@@ -649,7 +649,7 @@ static ssize_t fill_registers_buffer(struct debug_buffer *buf)
 	ohci_dbg_sw (ohci, &amp;next, &amp;size,
 		"bus %s, device %s\n"
 		"%s\n"
-		"%s version " DRIVER_VERSION "\n",
+		"%s\n",
 		hcd-&gt;self.controller-&gt;bus-&gt;name,
 		dev_name(hcd-&gt;self.controller),
 		hcd-&gt;product_desc,
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 89901962cbfd..0afeda836df3 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -46,7 +46,6 @@
 
 #include "../core/hcd.h"
 
-#define DRIVER_VERSION "2006 August 04"
 #define DRIVER_AUTHOR "Roman Weissgaerber, David Brownell"
 #define DRIVER_DESC "USB 1.1 'Open' Host Controller (OHCI) Driver"
 
@@ -984,10 +983,8 @@ static int ohci_restart (struct ohci_hcd *ohci)
 
 /*-------------------------------------------------------------------------*/
 
-#define DRIVER_INFO DRIVER_VERSION " " DRIVER_DESC
-
 MODULE_AUTHOR (DRIVER_AUTHOR);
-MODULE_DESCRIPTION (DRIVER_INFO);
+MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE ("GPL");
 
 #ifdef CONFIG_PCI
@@ -1095,7 +1092,7 @@ static int __init ohci_hcd_mod_init(void)
 	if (usb_disabled())
 		return -ENODEV;
 
-	printk (KERN_DEBUG "%s: " DRIVER_INFO "\n", hcd_name);
+	printk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);
 	pr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,
 		sizeof (struct ed), sizeof (struct td));
 
diff --git a/drivers/usb/host/ohci-pnx4008.c b/drivers/usb/host/ohci-pnx4008.c
index 658a2a978c32..e306ca6aef3d 100644
--- a/drivers/usb/host/ohci-pnx4008.c
+++ b/drivers/usb/host/ohci-pnx4008.c
@@ -331,7 +331,7 @@ static int __devinit usb_hcd_pnx4008_probe(struct platform_device *pdev)
 
 	int ret = 0, irq;
 
-	dev_dbg(&amp;pdev-&gt;dev, "%s: " DRIVER_INFO " (pnx4008)\n", hcd_name);
+	dev_dbg(&amp;pdev-&gt;dev, "%s: " DRIVER_DESC " (pnx4008)\n", hcd_name);
 	if (usb_disabled()) {
 		err("USB is disabled");
 		ret = -ENODEV;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 3a7bfe7a8874..2dddb258b0db 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -53,7 +53,6 @@
 /*
  * Version Information
  */
-#define DRIVER_VERSION "v3.0"
 #define DRIVER_AUTHOR "Linus 'Frodo Rabbit' Torvalds, Johannes Erdfelt, \
 Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, Roman Weissgaerber, \
 Alan Stern"
@@ -951,12 +950,12 @@ static int __init uhci_hcd_init(void)
 {
 	int retval = -ENOMEM;
 
-	printk(KERN_INFO DRIVER_DESC " " DRIVER_VERSION "%s\n",
-			ignore_oc ? ", overcurrent ignored" : "");
-
 	if (usb_disabled())
 		return -ENODEV;
 
+	printk(KERN_INFO "uhci_hcd: " DRIVER_DESC "%s\n",
+			ignore_oc ? ", overcurrent ignored" : "");
+
 	if (DEBUG_CONFIGURED) {
 		errbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);
 		if (!errbuf)</pre><hr><pre>commit e58dcebcd83b5902411e747ee7807219dee6bcf2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 25 16:59:57 2008 -0400

    USB: UHCI: improve scheduling of interrupt URBs
    
    This patch (as1140) adds a little intelligence to the interrupt-URB
    scheduler in uhci-hcd.  Right now the scheduler is stupid; every URB
    having the same period is assigned to the same slot.  Thus a large
    group of period-N URBs can fill their slot and cause -ENOSPC errors
    even when all the lower-period slots are empty.
    
    With the patch, if an URB doesn't fit in its assigned slot then the
    scheduler will try using lower-period slots.  This will provide
    greater flexibility.  As an example, the driver will be able to handle
    more than just three or four mice, which the current driver cannot.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 1f0c2cf26e5d..5631d89c8730 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1065,13 +1065,18 @@ static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 		}
 		if (exponent &lt; 0)
 			return -EINVAL;
-		qh-&gt;period = 1 &lt;&lt; exponent;
-		qh-&gt;skel = SKEL_INDEX(exponent);
 
-		/* For now, interrupt phase is fixed by the layout
-		 * of the QH lists. */
-		qh-&gt;phase = (qh-&gt;period / 2) &amp; (MAX_PHASE - 1);
-		ret = uhci_check_bandwidth(uhci, qh);
+		/* If the slot is full, try a lower period */
+		do {
+			qh-&gt;period = 1 &lt;&lt; exponent;
+			qh-&gt;skel = SKEL_INDEX(exponent);
+
+			/* For now, interrupt phase is fixed by the layout
+			 * of the QH lists.
+			 */
+			qh-&gt;phase = (qh-&gt;period / 2) &amp; (MAX_PHASE - 1);
+			ret = uhci_check_bandwidth(uhci, qh);
+		} while (ret != 0 &amp;&amp; --exponent &gt;= 0);
 		if (ret)
 			return ret;
 	} else if (qh-&gt;period &gt; urb-&gt;interval)</pre><hr><pre>commit 8520f38099ccfdac2147a0852f84ee7a8ee5e197
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 22 14:44:26 2008 -0400

    USB: change hub initialization sleeps to delayed_work
    
    This patch (as1137) changes the hub_activate() routine, replacing the
    power-power-up and debounce delays with delayed_work calls.  The idea
    is that on systems where the USB stack is compiled into the kernel
    rather than built as modules, these delays will no longer block the
    boot thread.  At least 100 ms is saved for each root hub, which can
    add up to a significant savings in total boot time.
    
    Arjan van de Ven was very pleased to see that this shaved 700 ms off
    his computer's boot time.  Since his total boot time is on the order
    of two seconds, the improvement is considerable.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Arjan van de Ven &lt;arjan@infradead.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index d99963873e37..b97110ca352d 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -77,6 +77,7 @@ struct usb_hub {
 	unsigned		has_indicators:1;
 	u8			indicator[USB_MAXCHILDREN];
 	struct delayed_work	leds;
+	struct delayed_work	init_work;
 };
 
 
@@ -515,10 +516,14 @@ void usb_hub_tt_clear_buffer (struct usb_device *udev, int pipe)
 }
 EXPORT_SYMBOL_GPL(usb_hub_tt_clear_buffer);
 
-static void hub_power_on(struct usb_hub *hub)
+/* If do_delay is false, return the number of milliseconds the caller
+ * needs to delay.
+ */
+static unsigned hub_power_on(struct usb_hub *hub, bool do_delay)
 {
 	int port1;
 	unsigned pgood_delay = hub-&gt;descriptor-&gt;bPwrOn2PwrGood * 2;
+	unsigned delay;
 	u16 wHubCharacteristics =
 			le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
 
@@ -537,7 +542,10 @@ static void hub_power_on(struct usb_hub *hub)
 		set_port_feature(hub-&gt;hdev, port1, USB_PORT_FEAT_POWER);
 
 	/* Wait at least 100 msec for power to become stable */
-	msleep(max(pgood_delay, (unsigned) 100));
+	delay = max(pgood_delay, (unsigned) 100);
+	if (do_delay)
+		msleep(delay);
+	return delay;
 }
 
 static int hub_hub_status(struct usb_hub *hub,
@@ -599,21 +607,55 @@ static void hub_port_logical_disconnect(struct usb_hub *hub, int port1)
 }
 
 enum hub_activation_type {
-	HUB_INIT, HUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME
+	HUB_INIT, HUB_INIT2, HUB_INIT3,
+	HUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,
 };
 
+static void hub_init_func2(struct work_struct *ws);
+static void hub_init_func3(struct work_struct *ws);
+
 static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 {
 	struct usb_device *hdev = hub-&gt;hdev;
 	int port1;
 	int status;
 	bool need_debounce_delay = false;
+	unsigned delay;
+
+	/* Continue a partial initialization */
+	if (type == HUB_INIT2)
+		goto init2;
+	if (type == HUB_INIT3)
+		goto init3;
 
 	/* After a resume, port power should still be on.
 	 * For any other type of activation, turn it on.
 	 */
-	if (type != HUB_RESUME)
-		hub_power_on(hub);
+	if (type != HUB_RESUME) {
+
+		/* Speed up system boot by using a delayed_work for the
+		 * hub's initial power-up delays.  This is pretty awkward
+		 * and the implementation looks like a home-brewed sort of
+		 * setjmp/longjmp, but it saves at least 100 ms for each
+		 * root hub (assuming usbcore is compiled into the kernel
+		 * rather than as a module).  It adds up.
+		 *
+		 * This can't be done for HUB_RESUME or HUB_RESET_RESUME
+		 * because for those activation types the ports have to be
+		 * operational when we return.  In theory this could be done
+		 * for HUB_POST_RESET, but it's easier not to.
+		 */
+		if (type == HUB_INIT) {
+			delay = hub_power_on(hub, false);
+			PREPARE_DELAYED_WORK(&amp;hub-&gt;init_work, hub_init_func2);
+			schedule_delayed_work(&amp;hub-&gt;init_work,
+					msecs_to_jiffies(delay));
+			return;		/* Continues at init2: below */
+		} else {
+			hub_power_on(hub, true);
+		}
+	}
+ init2:
 
 	/* Check each port and set hub-&gt;change_bits to let khubd know
 	 * which ports need attention.
@@ -692,9 +734,20 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	 * If any port-status changes do occur during this delay, khubd
 	 * will see them later and handle them normally.
 	 */
-	if (need_debounce_delay)
-		msleep(HUB_DEBOUNCE_STABLE);
-
+	if (need_debounce_delay) {
+		delay = HUB_DEBOUNCE_STABLE;
+
+		/* Don't do a long sleep inside a workqueue routine */
+		if (type == HUB_INIT2) {
+			PREPARE_DELAYED_WORK(&amp;hub-&gt;init_work, hub_init_func3);
+			schedule_delayed_work(&amp;hub-&gt;init_work,
+					msecs_to_jiffies(delay));
+			return;		/* Continues at init3: below */
+		} else {
+			msleep(delay);
+		}
+	}
+ init3:
 	hub-&gt;quiescing = 0;
 
 	status = usb_submit_urb(hub-&gt;urb, GFP_NOIO);
@@ -707,6 +760,21 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 	kick_khubd(hub);
 }
 
+/* Implement the continuations for the delays above */
+static void hub_init_func2(struct work_struct *ws)
+{
+	struct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);
+
+	hub_activate(hub, HUB_INIT2);
+}
+
+static void hub_init_func3(struct work_struct *ws)
+{
+	struct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);
+
+	hub_activate(hub, HUB_INIT3);
+}
+
 enum hub_quiescing_type {
 	HUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND
 };
@@ -716,6 +784,8 @@ static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)
 	struct usb_device *hdev = hub-&gt;hdev;
 	int i;
 
+	cancel_delayed_work_sync(&amp;hub-&gt;init_work);
+
 	/* khubd and related activity won't re-trigger */
 	hub-&gt;quiescing = 1;
 
@@ -1099,6 +1169,7 @@ static int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)
 	hub-&gt;intfdev = &amp;intf-&gt;dev;
 	hub-&gt;hdev = hdev;
 	INIT_DELAYED_WORK(&amp;hub-&gt;leds, led_work);
+	INIT_DELAYED_WORK(&amp;hub-&gt;init_work, NULL);
 	usb_get_intf(intf);
 
 	usb_set_intfdata (intf, hub);
@@ -3035,7 +3106,7 @@ static void hub_events(void)
 					i);
 				clear_port_feature(hdev, i,
 					USB_PORT_FEAT_C_OVER_CURRENT);
-				hub_power_on(hub);
+				hub_power_on(hub, true);
 			}
 
 			if (portchange &amp; USB_PORT_STAT_C_RESET) {
@@ -3070,7 +3141,7 @@ static void hub_events(void)
 				dev_dbg (hub_dev, "overcurrent change\n");
 				msleep(500);	/* Cool down */
 				clear_hub_feature(hdev, C_HUB_OVER_CURRENT);
-                        	hub_power_on(hub);
+                        	hub_power_on(hub, true);
 			}
 		}
 </pre><hr><pre>commit 4a511bc3f5829bc18428bcf11c25417a79d09396
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 3 16:38:32 2008 -0400

    OHCI: Allow broken controllers to auto-stop
    
    This patch (as1134) attempts to improve the way we handle OHCI
    controllers with broken Root Hub Status Change interrupt support.  In
    these controllers the RHSC interrupt bit essentially never turns off,
    making RHSC interrupts useless -- they have to remain permanently
    disabled.
    
    Such controllers should still be allowed to turn off their root hubs
    when no devices are attached.  Polling for new connections can
    continue while the root hub is suspended.  The patch implements this
    feature.  (It won't have much effect unless CONFIG_PM is enabled and
    CONFIG_USB_SUSPEND is disabled, but since the overhead is very small
    we may as well do it.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 7ea9a7b31155..a150e85c901a 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -362,18 +362,23 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 		int any_connected)
 {
 	int	poll_rh = 1;
-	int	rhsc;
+	int	rhsc_status, rhsc_enable;
 
-	rhsc = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp; OHCI_INTR_RHSC;
-	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
+	/* Some broken controllers never turn off RHCS in the interrupt
+	 * status register.  For their sake we won't re-enable RHSC
+	 * interrupts if the interrupt bit is already active.
+	 */
+	rhsc_status = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp;
+			OHCI_INTR_RHSC;
+	rhsc_enable = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp;
+			OHCI_INTR_RHSC;
 
+	switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
 	case OHCI_USB_OPER:
-		/* If no status changes are pending, enable status-change
-		 * interrupts.
-		 */
-		if (!rhsc &amp;&amp; !changed) {
-			rhsc = OHCI_INTR_RHSC;
-			ohci_writel(ohci, rhsc, &amp;ohci-&gt;regs-&gt;intrenable);
+		/* If no status changes are pending, enable RHSC interrupts. */
+		if (!rhsc_enable &amp;&amp; !rhsc_status &amp;&amp; !changed) {
+			rhsc_enable = OHCI_INTR_RHSC;
+			ohci_writel(ohci, rhsc_enable, &amp;ohci-&gt;regs-&gt;intrenable);
 		}
 
 		/* Keep on polling until we know a device is connected
@@ -383,7 +388,7 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 			if (any_connected ||
 					!device_may_wakeup(&amp;ohci_to_hcd(ohci)
 						-&gt;self.root_hub-&gt;dev)) {
-				if (rhsc)
+				if (rhsc_enable)
 					poll_rh = 0;
 			} else {
 				ohci-&gt;autostop = 1;
@@ -396,34 +401,36 @@ static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 				ohci-&gt;autostop = 0;
 				ohci-&gt;next_statechange = jiffies +
 						STATECHANGE_DELAY;
-			} else if (rhsc &amp;&amp; time_after_eq(jiffies,
+			} else if (time_after_eq(jiffies,
 						ohci-&gt;next_statechange)
 					&amp;&amp; !ohci-&gt;ed_rm_list
 					&amp;&amp; !(ohci-&gt;hc_control &amp;
 						OHCI_SCHED_ENABLES)) {
 				ohci_rh_suspend(ohci, 1);
-				poll_rh = 0;
+				if (rhsc_enable)
+					poll_rh = 0;
 			}
 		}
 		break;
 
-	/* if there is a port change, autostart or ask to be resumed */
 	case OHCI_USB_SUSPEND:
 	case OHCI_USB_RESUME:
+		/* if there is a port change, autostart or ask to be resumed */
 		if (changed) {
 			if (ohci-&gt;autostop)
 				ohci_rh_resume(ohci);
 			else
 				usb_hcd_resume_root_hub(ohci_to_hcd(ohci));
 		} else {
-			if (!rhsc &amp;&amp; (ohci-&gt;autostop ||
+			if (!rhsc_enable &amp;&amp; !rhsc_status &amp;&amp; (ohci-&gt;autostop ||
 					ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;
-						do_remote_wakeup))
-				ohci_writel(ohci, OHCI_INTR_RHSC,
+						do_remote_wakeup)) {
+				rhsc_enable = OHCI_INTR_RHSC;
+				ohci_writel(ohci, rhsc_enable,
 						&amp;ohci-&gt;regs-&gt;intrenable);
-
-			/* everything is idle, no need for polling */
-			poll_rh = 0;
+			}
+			if (rhsc_enable)
+				poll_rh = 0;
 		}
 		break;
 	}
@@ -443,12 +450,16 @@ static inline int ohci_rh_resume(struct ohci_hcd *ohci)
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 		int any_connected)
 {
+	int	rhsc_status;
+
 	/* If RHSC is enabled, don't poll */
 	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable) &amp; OHCI_INTR_RHSC)
 		return 0;
 
-	/* If no status changes are pending, enable status-change interrupts */
-	if (!changed) {
+	/* If no status changes are pending, enable RHSC interrupts */
+	rhsc_status = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp;
+			OHCI_INTR_RHSC;
+	if (!changed &amp;&amp; !rhsc_status) {
 		ohci_writel(ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrenable);
 		return 0;
 	}
@@ -492,13 +503,6 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 		length++;
 	}
 
-	/* Some broken controllers never turn off RHCS in the interrupt
-	 * status register.  For their sake we won't re-enable RHSC
-	 * interrupts if the flag is already set.
-	 */
-	if (ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrstatus) &amp; OHCI_INTR_RHSC)
-		changed = 1;
-
 	/* look at each port */
 	for (i = 0; i &lt; ohci-&gt;num_ports; i++) {
 		u32	status = roothub_portstatus (ohci, i);</pre><hr><pre>commit 8bfa24727087d7252f9ecfb5fea2dfc92d797fbd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 2 10:12:11 2008 -0400

    usb-storage: report underflow with no sense data
    
    This patch (as1118) addresses a problem with certain USB mass-storage
    devices.  These devices sometimes return less data than asked for and
    then provide no sense data to explain the problem.  Currently
    usb-storage leaves it up to the SCSI layer to decide how this should
    be handled, and the SCSI layer interprets the lack of sense data to
    mean that nothing went wrong.  But if we got less data than required
    then something definitely _did_ go wrong, and we should say so.
    
    The patch tells the SCSI layer to retry the command when this sort of
    thing happens.  Retrying may not solve the underlying problem, but
    it's better than believing that data was transferred when it wasn't.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index 3523a0bfa0ff..79108d5d3171 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -663,7 +663,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 	}
 
 	/* Did we transfer less than the minimum amount required? */
-	if (srb-&gt;result == SAM_STAT_GOOD &amp;&amp;
+	if ((srb-&gt;result == SAM_STAT_GOOD || srb-&gt;sense_buffer[2] == 0) &amp;&amp;
 			scsi_bufflen(srb) - scsi_get_resid(srb) &lt; srb-&gt;underflow)
 		srb-&gt;result = (DID_ERROR &lt;&lt; 16) | (SUGGEST_RETRY &lt;&lt; 24);
 </pre>
    <div class="pagination">
        <a href='2_86.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><span>[87]</span><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_88.html'>Next&gt;&gt;</a>
    <div>
</body>
