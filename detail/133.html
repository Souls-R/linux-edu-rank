<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Rice University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Rice University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit ab7f863e4183057dc494f3180199934a9637d401
Author: Scott Rixner &lt;rixner@rice.edu&gt;
Date:   Thu Mar 3 09:30:08 2011 +0000

    xen: events: Process event channels notifications in round-robin order.
    
    Avoids fairness issue resulting from domain 0 processing lowest
    numbered event channel first.
    
    Fixes bug #1115 "Event channel port scanning unfair".
    
    Bugzilla: http://bugzilla.xensource.com/bugzilla/show_bug.cgi?id=1115
    Signed-off-by: Ian Campbell &lt;ian.campbell@citrix.com&gt;
    [ijc: forward ported from linux-2.6.18-xen.hg 324:7fe1c6d02a2b
     various variables have different names in this tree:
      l1  -&gt; pending_words
      l2  -&gt; pending_bits
      l1i -&gt; word_idx
      l2i -&gt; bit_idx]
    Signed-off-by: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;

diff --git a/drivers/xen/events.c b/drivers/xen/events.c
index 6befe6227159..75cc6f50bd29 100644
--- a/drivers/xen/events.c
+++ b/drivers/xen/events.c
@@ -1027,6 +1027,11 @@ irqreturn_t xen_debug_interrupt(int irq, void *dev_id)
 
 static DEFINE_PER_CPU(unsigned, xed_nesting_count);
 
+/*
+ * Mask out the i least significant bits of w
+ */
+#define MASK_LSBS(w, i) (w &amp; ((~0UL) &lt;&lt; i))
+
 /*
  * Search the CPUs pending events bitmasks.  For each one found, map
  * the event number to an irq, and feed it into do_IRQ() for
@@ -1038,6 +1043,9 @@ static DEFINE_PER_CPU(unsigned, xed_nesting_count);
  */
 static void __xen_evtchn_do_upcall(void)
 {
+	static unsigned int last_word_idx = BITS_PER_LONG - 1;
+	static unsigned int last_bit_idx = BITS_PER_LONG - 1;
+	int word_idx, bit_idx;
 	int cpu = get_cpu();
 	struct shared_info *s = HYPERVISOR_shared_info;
 	struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);
@@ -1056,17 +1064,50 @@ static void __xen_evtchn_do_upcall(void)
 		wmb();
 #endif
 		pending_words = xchg(&amp;vcpu_info-&gt;evtchn_pending_sel, 0);
+
+		word_idx = last_word_idx;
+		bit_idx = last_bit_idx;
+
 		while (pending_words != 0) {
 			unsigned long pending_bits;
-			int word_idx = __ffs(pending_words);
-			pending_words &amp;= ~(1UL &lt;&lt; word_idx);
+			unsigned long words;
+
+			word_idx = (word_idx + 1) % BITS_PER_LONG;
+			words = MASK_LSBS(pending_words, word_idx);
+
+			/*
+			 * If we masked out all events, wrap around to the
+			 * beginning.
+			 */
+			if (words == 0) {
+				word_idx = BITS_PER_LONG - 1;
+				bit_idx = BITS_PER_LONG - 1;
+				continue;
+			}
+			word_idx = __ffs(words);
 
-			while ((pending_bits = active_evtchns(cpu, s, word_idx)) != 0) {
-				int bit_idx = __ffs(pending_bits);
-				int port = (word_idx * BITS_PER_LONG) + bit_idx;
-				int irq = evtchn_to_irq[port];
+			do {
+				unsigned long bits;
+				int port, irq;
 				struct irq_desc *desc;
 
+				pending_bits = active_evtchns(cpu, s, word_idx);
+
+				bit_idx = (bit_idx + 1) % BITS_PER_LONG;
+				bits = MASK_LSBS(pending_bits, bit_idx);
+
+				/* If we masked out all events, move on. */
+				if (bits == 0) {
+					bit_idx = BITS_PER_LONG - 1;
+					break;
+				}
+
+				bit_idx = __ffs(bits);
+
+				/* Process port. */
+				port = (word_idx * BITS_PER_LONG) + bit_idx;
+				irq = evtchn_to_irq[port];
+
 				mask_evtchn(port);
 				clear_evtchn(port);
 
@@ -1075,7 +1116,24 @@ static void __xen_evtchn_do_upcall(void)
 					if (desc)
 						generic_handle_irq_desc(irq, desc);
 				}
-			}
+
+				/*
+				 * If this is the final port processed, we'll
+				 * pick up here+1 next time.
+				 */
+				last_word_idx = word_idx;
+				last_bit_idx = bit_idx;
+
+			} while (bit_idx != BITS_PER_LONG - 1);
+
+			pending_bits = active_evtchns(cpu, s, word_idx);
+
+			/*
+			 * We handled all ports, so we can clear the
+			 * selector bit.
+			 */
+			if (pending_bits == 0)
+				pending_words &amp;= ~(1UL &lt;&lt; word_idx);
 		}
 
 		BUG_ON(!irqs_disabled());</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
