<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_99.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><span>[100]</span><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_101.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7108f28465a0a37d5afc05c5ad788938423b74a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 20 12:37:50 2007 -0400

    USB: don't propagate FREEZE or PRETHAW suspends
    
    This patch (as992) fixes a recently-added bug.  During a FREEZE or
    PRETHAW suspend notification, non-root devices don't actually get
    suspended.  So we shouldn't tell their parent hubs that they did.
    
    (This code path used to be skipped over, until the FREEZE/PRETHAW test
    got moved out of usb_suspend_both() into generic_suspend().)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ba5bbc7eedcc..3f734240e0ec 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1112,7 +1112,12 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 			usb_hcd_flush_endpoint(udev, udev-&gt;ep_out[i]);
 			usb_hcd_flush_endpoint(udev, udev-&gt;ep_in[i]);
 		}
-		if (parent)
+
+		/* If this is just a FREEZE or a PRETHAW, udev might
+		 * not really be suspended.  Only true suspends get
+		 * propagated up the device tree.
+		 */
+		if (parent &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
 			usb_autosuspend_device(parent);
 	}
 </pre><hr><pre>commit 393e5511a5f58e82b88589f1dd2464f6b661df06
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 18 10:09:32 2007 -0400

    USB: unusual_devs update for Nokia 6131
    
    This patch (as991) updates the unusual_devs entry for the Nokia 6131
    phone.  As reported by Juan Ignacio Cherrutti, there's new firmware
    available but it still has the same old transfer-size limit.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 94b1dd2aeb3b..b0ff02955804 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -198,7 +198,7 @@ UNUSUAL_DEV(  0x0421, 0x044e, 0x0100, 0x0100,
 		US_FL_IGNORE_RESIDUE | US_FL_FIX_CAPACITY ),
 
 /* Reported by Bardur Arantsson &lt;bardur@scientician.net&gt; */
-UNUSUAL_DEV(  0x0421, 0x047c, 0x0370, 0x0370,
+UNUSUAL_DEV(  0x0421, 0x047c, 0x0370, 0x0610,
 		"Nokia",
 		"6131",
 		US_SC_DEVICE, US_PR_DEVICE, NULL,</pre><hr><pre>commit 6840d2555afd66290be7a39b400b5e66a840b82d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 11:34:26 2007 -0400

    USB: flush outstanding URBs when suspending
    
    This patch (as989) makes usbcore flush all outstanding URBs for each
    device as the device is suspended.  This will be true even when
    CONFIG_USB_SUSPEND is not enabled.
    
    In addition, an extra can_submit flag is added to the usb_device
    structure.  That flag will be turned off whenever a suspend request
    has been received for the device, even if the device isn't actually
    suspended because CONFIG_USB_SUSPEND isn't set.
    
    It's no longer necessary to check for the device state being equal to
    USB_STATE_SUSPENDED during URB submission; that check can be replaced
    by a check of the can_submit flag.  This also permits us to remove
    some questionable references to the deprecated power.power_state field.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ca43a6f824ab..ba5bbc7eedcc 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1102,9 +1102,16 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 		if (udev-&gt;auto_pm)
 			autosuspend_check(udev);
 
-	/* If the suspend succeeded, propagate it up the tree */
+	/* If the suspend succeeded then prevent any more URB submissions,
+	 * flush any outstanding URBs, and propagate the suspend up the tree.
+	 */
 	} else {
 		cancel_delayed_work(&amp;udev-&gt;autosuspend);
+		udev-&gt;can_submit = 0;
+		for (i = 0; i &lt; 16; ++i) {
+			usb_hcd_flush_endpoint(udev, udev-&gt;ep_out[i]);
+			usb_hcd_flush_endpoint(udev, udev-&gt;ep_in[i]);
+		}
 		if (parent)
 			usb_autosuspend_device(parent);
 	}
@@ -1154,6 +1161,7 @@ static int usb_resume_both(struct usb_device *udev)
 		status = -ENODEV;
 		goto done;
 	}
+	udev-&gt;can_submit = 1;
 
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index e5874e8b8cbc..2c79aa6ca2b4 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1014,6 +1014,11 @@ int usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)
 		goto done;
 	}
 
+	if (unlikely(!urb-&gt;dev-&gt;can_submit)) {
+		rc = -EHOSTUNREACH;
+		goto done;
+	}
+
 	/*
 	 * Check the host controller's state and add the URB to the
 	 * endpoint's queue.
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index bd08d51d7f41..691acf2223c2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1955,14 +1955,7 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 		struct usb_device	*udev;
 
 		udev = hdev-&gt;children [port1-1];
-		if (udev &amp;&amp; msg.event == PM_EVENT_SUSPEND &amp;&amp;
-#ifdef	CONFIG_USB_SUSPEND
-				udev-&gt;state != USB_STATE_SUSPENDED
-#else
-				udev-&gt;dev.power.power_state.event
-					== PM_EVENT_ON
-#endif
-				) {
+		if (udev &amp;&amp; udev-&gt;can_submit) {
 			if (!hdev-&gt;auto_pm)
 				dev_dbg(&amp;intf-&gt;dev, "port %d nyet suspended\n",
 						port1);
diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 76db76fdb4ec..c20c03aaf012 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -286,9 +286,6 @@ int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 		return -EINVAL;
 	if (!(dev = urb-&gt;dev) || dev-&gt;state &lt; USB_STATE_DEFAULT)
 		return -ENODEV;
-	if (dev-&gt;bus-&gt;controller-&gt;power.power_state.event != PM_EVENT_ON
-			|| dev-&gt;state == USB_STATE_SUSPENDED)
-		return -EHOSTUNREACH;
 
 	/* For now, get the endpoint from the pipe.  Eventually drivers
 	 * will be required to set urb-&gt;ep directly and we will eliminate
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index e5ff161776fa..8121edbd1494 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -272,6 +272,7 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
 	/* ep0 maxpacket comes later, from device descriptor */
 	usb_enable_endpoint(dev, &amp;dev-&gt;ep0);
+	dev-&gt;can_submit = 1;
 
 	/* Save readable and stable topology id, distinguishing devices
 	 * by location for diagnostics, tools, driver model, etc.  The
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5b14b4c81fd6..e5b35e0dca23 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -383,6 +383,7 @@ struct usb_device {
 	u8 portnum;			/* Parent port number (origin 1) */
 	u8 level;			/* Number of USB hub ancestors */
 
+	unsigned can_submit:1;		/* URBs may be submitted */
 	unsigned discon_suspended:1;	/* Disconnected while suspended */
 	unsigned have_langid:1;		/* whether string_langid is valid */
 	unsigned authorized:1;		/* Policy has determined we can use it */</pre><hr><pre>commit 95cf82f99cfbd697c15572c444bd4f54f19745b0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 11:33:05 2007 -0400

    USB: break apart flush_endpoint and disable_endpoint
    
    This patch (as988) breaks usb_hcd_endpoint_disable() apart into two
    routines.  The first, usb_hcd_flush_endpoint() does the -ESHUTDOWN
    unlinking of all URBs in the endpoint's queue and waits for them to
    complete.  The second, usb_hcd_disable_endpoint() -- renamed for
    better grammatical style -- merely calls the HCD's endpoint_disable
    method.  The changeover is easy because the routine currently has only
    one caller.
    
    This separation of function will be exploited in the following patch:
    When a device is suspended, the core will be able to cancel all
    outstanding URBs for that device while leaving the HCD's
    endpoint-related data structures intact for later.
    
    As an added benefit, HCDs no longer need to check for existing URBs in
    their endpoint_disable methods.  It is now guaranteed that there will
    be none.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 1c5e5d35e08d..e5874e8b8cbc 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1289,24 +1289,22 @@ EXPORT_SYMBOL (usb_hcd_giveback_urb);
 
 /*-------------------------------------------------------------------------*/
 
-/* disables the endpoint: cancels any pending urbs, then synchronizes with
- * the hcd to make sure all endpoint state is gone from hardware, and then
- * waits until the endpoint's queue is completely drained. use for
- * set_configuration, set_interface, driver removal, physical disconnect.
- *
- * example:  a qh stored in ep-&gt;hcpriv, holding state related to endpoint
- * type, maxpacket size, toggle, halt status, and scheduling.
+/* Cancel all URBs pending on this endpoint and wait for the endpoint's
+ * queue to drain completely.  The caller must first insure that no more
+ * URBs can be submitted for this endpoint.
  */
-void usb_hcd_endpoint_disable (struct usb_device *udev,
+void usb_hcd_flush_endpoint(struct usb_device *udev,
 		struct usb_host_endpoint *ep)
 {
 	struct usb_hcd		*hcd;
 	struct urb		*urb;
 
+	if (!ep)
+		return;
 	might_sleep();
 	hcd = bus_to_hcd(udev-&gt;bus);
 
-	/* ep is already gone from udev-&gt;ep_{in,out}[]; no more submits */
+	/* No more submits can occur */
 rescan:
 	spin_lock_irq(&amp;hcd_urb_list_lock);
 	list_for_each_entry (urb, &amp;ep-&gt;urb_list, urb_list) {
@@ -1345,18 +1343,7 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	}
 	spin_unlock_irq(&amp;hcd_urb_list_lock);
 
-	/* synchronize with the hardware, so old configuration state
-	 * clears out immediately (and will be freed).
-	 */
-	if (hcd-&gt;driver-&gt;endpoint_disable)
-		hcd-&gt;driver-&gt;endpoint_disable (hcd, ep);
-
-	/* Wait until the endpoint queue is completely empty.  Most HCDs
-	 * will have done this already in their endpoint_disable method,
-	 * but some might not.  And there could be root-hub control URBs
-	 * still pending since they aren't affected by the HCDs'
-	 * endpoint_disable methods.
-	 */
+	/* Wait until the endpoint queue is completely empty */
 	while (!list_empty (&amp;ep-&gt;urb_list)) {
 		spin_lock_irq(&amp;hcd_urb_list_lock);
 
@@ -1376,6 +1363,25 @@ void usb_hcd_endpoint_disable (struct usb_device *udev,
 	}
 }
 
+/* Disables the endpoint: synchronizes with the hcd to make sure all
+ * endpoint state is gone from hardware.  usb_hcd_flush_endpoint() must
+ * have been called previously.  Use for set_configuration, set_interface,
+ * driver removal, physical disconnect.
+ *
+ * example:  a qh stored in ep-&gt;hcpriv, holding state related to endpoint
+ * type, maxpacket size, toggle, halt status, and scheduling.
+ */
+void usb_hcd_disable_endpoint(struct usb_device *udev,
+		struct usb_host_endpoint *ep)
+{
+	struct usb_hcd		*hcd;
+
+	might_sleep();
+	hcd = bus_to_hcd(udev-&gt;bus);
+	if (hcd-&gt;driver-&gt;endpoint_disable)
+		hcd-&gt;driver-&gt;endpoint_disable(hcd, ep);
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* called in any context */
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 0fc7b95259f5..1396141274f1 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -219,7 +219,9 @@ extern int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb (struct urb *urb, int status);
 extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
 		int status);
-extern void usb_hcd_endpoint_disable (struct usb_device *udev,
+extern void usb_hcd_flush_endpoint(struct usb_device *udev,
+		struct usb_host_endpoint *ep);
+extern void usb_hcd_disable_endpoint(struct usb_device *udev,
 		struct usb_host_endpoint *ep);
 extern int usb_hcd_get_frame_number (struct usb_device *udev);
 
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index d638375e22e7..98fcddba6908 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1017,7 +1017,8 @@ void usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr)
 	}
 	if (ep) {
 		ep-&gt;enabled = 0;
-		usb_hcd_endpoint_disable(dev, ep);
+		usb_hcd_flush_endpoint(dev, ep);
+		usb_hcd_disable_endpoint(dev, ep);
 	}
 }
 </pre><hr><pre>commit 5ad4f71e2f19a06f738463da1f09ea7fda3a3db2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 11:31:43 2007 -0400

    USB: move decision to ignore FREEZE events
    
    This patch (as987) changes the way FREEZE and PRETHAW suspend events
    are handled in usbcore.  The decision about whether or not to ignore
    them for non-root devices is pushed down into the USB-device driver,
    instead of being made in the core code.
    
    This is appropriate, since devices exported to a virtualized guest or
    over a network may indeed need to handle these types of suspend, even
    though normal devices don't.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8da4801bb922..ca43a6f824ab 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -1088,15 +1088,8 @@ static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)
 				break;
 		}
 	}
-	if (status == 0) {
-
-		/* Non-root devices don't need to do anything for FREEZE
-		 * or PRETHAW. */
-		if (udev-&gt;parent &amp;&amp; (msg.event == PM_EVENT_FREEZE ||
-				msg.event == PM_EVENT_PRETHAW))
-			goto done;
+	if (status == 0)
 		status = usb_suspend_device(udev, msg);
-	}
 
 	/* If the suspend failed, resume interfaces that did get suspended */
 	if (status != 0) {
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 9148b69785c5..c1cb94e9f242 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -206,8 +206,13 @@ static int generic_suspend(struct usb_device *udev, pm_message_t msg)
 	 */
 	if (!udev-&gt;parent)
 		rc = hcd_bus_suspend(udev);
+
+	/* Non-root devices don't need to do anything for FREEZE or PRETHAW */
+	else if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)
+		rc = 0;
 	else
 		rc = usb_port_suspend(udev);
+
 	return rc;
 }
 </pre><hr><pre>commit 7477120e34eef65a530cfb3fea5fe612c89669e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 11:35:14 2007 -0400

    USB: Get rid of annoying endpoint-release message
    
    This patch (as990) removes an annoying debugging message.  Nobody
    really cares when endpoint pseudo-devices are released.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/endpoint.c b/drivers/usb/core/endpoint.c
index e0ec7045e865..7dc123d6b2d0 100644
--- a/drivers/usb/core/endpoint.c
+++ b/drivers/usb/core/endpoint.c
@@ -267,7 +267,6 @@ static void ep_device_release(struct device *dev)
 {
 	struct ep_device *ep_dev = to_ep_device(dev);
 
-	dev_dbg(dev, "%s called for %s\n", __FUNCTION__, dev-&gt;bus_id);
 	endpoint_free_minor(ep_dev);
 	kfree(ep_dev);
 }</pre><hr><pre>commit 63f991b2871bdb1431e8ff62cae2b7b94b4e5b0c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 4 09:53:24 2007 -0400

    USB: fix location of statement label in dummy-hcd
    
    This patch (as984) fixes a rather elementary mistake in dummy_hcd.
    The new statement label should come before the spin_unlock_irqrestore,
    not after it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 58e4d7208805..6479a36d6f0e 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1001,8 +1001,8 @@ static int dummy_urb_enqueue (
 	if (!timer_pending (&amp;dum-&gt;timer))
 		mod_timer (&amp;dum-&gt;timer, jiffies + 1);
 
-	spin_unlock_irqrestore (&amp;dum-&gt;lock, flags);
  done:
+	spin_unlock_irqrestore(&amp;dum-&gt;lock, flags);
 	return rc;
 }
 </pre><hr><pre>commit e015268d2fcfcaef70a1ec535e6381f75aafbf81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:42:52 2007 -0400

    USB: remove traces of urb-&gt;status from usbcore
    
    This patch (as981) removes the remaining nontrivial usages of
    urb-&gt;status from usbcore.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index b9f1edd6af53..e5ad76b4a738 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -71,6 +71,7 @@ struct async {
 	void __user *userbuffer;
 	void __user *userurb;
 	struct urb *urb;
+	int status;
 	u32 secid;
 };
 
@@ -310,9 +311,10 @@ static void async_completed(struct urb *urb)
         spin_lock(&amp;ps-&gt;lock);
         list_move_tail(&amp;as-&gt;asynclist, &amp;ps-&gt;async_completed);
         spin_unlock(&amp;ps-&gt;lock);
+	as-&gt;status = urb-&gt;status;
 	if (as-&gt;signr) {
 		sinfo.si_signo = as-&gt;signr;
-		sinfo.si_errno = as-&gt;urb-&gt;status;
+		sinfo.si_errno = as-&gt;status;
 		sinfo.si_code = SI_ASYNCIO;
 		sinfo.si_addr = as-&gt;userurb;
 		kill_pid_info_as_uid(as-&gt;signr, &amp;sinfo, as-&gt;pid, as-&gt;uid,
@@ -1132,7 +1134,7 @@ static int processcompl(struct async *as, void __user * __user *arg)
 	if (as-&gt;userbuffer)
 		if (copy_to_user(as-&gt;userbuffer, urb-&gt;transfer_buffer, urb-&gt;transfer_buffer_length))
 			return -EFAULT;
-	if (put_user(urb-&gt;status, &amp;userurb-&gt;status))
+	if (put_user(as-&gt;status, &amp;userurb-&gt;status))
 		return -EFAULT;
 	if (put_user(urb-&gt;actual_length, &amp;userurb-&gt;actual_length))
 		return -EFAULT;
@@ -1246,7 +1248,7 @@ static int processcompl_compat(struct async *as, void __user * __user *arg)
 	if (as-&gt;userbuffer)
 		if (copy_to_user(as-&gt;userbuffer, urb-&gt;transfer_buffer, urb-&gt;transfer_buffer_length))
 			return -EFAULT;
-	if (put_user(urb-&gt;status, &amp;userurb-&gt;status))
+	if (put_user(as-&gt;status, &amp;userurb-&gt;status))
 		return -EFAULT;
 	if (put_user(urb-&gt;actual_length, &amp;userurb-&gt;actual_length))
 		return -EFAULT;
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4c495c4d5053..bd08d51d7f41 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -347,11 +347,11 @@ void usb_kick_khubd(struct usb_device *hdev)
 static void hub_irq(struct urb *urb)
 {
 	struct usb_hub *hub = urb-&gt;context;
-	int status;
+	int status = urb-&gt;status;
 	int i;
 	unsigned long bits;
 
-	switch (urb-&gt;status) {
+	switch (status) {
 	case -ENOENT:		/* synchronous unlink */
 	case -ECONNRESET:	/* async unlink */
 	case -ESHUTDOWN:	/* hardware going away */
@@ -359,10 +359,10 @@ static void hub_irq(struct urb *urb)
 
 	default:		/* presumably an error */
 		/* Cause a hub reset after 10 consecutive errors */
-		dev_dbg (hub-&gt;intfdev, "transfer --&gt; %d\n", urb-&gt;status);
+		dev_dbg (hub-&gt;intfdev, "transfer --&gt; %d\n", status);
 		if ((++hub-&gt;nerrors &lt; 10) || hub-&gt;error)
 			goto resubmit;
-		hub-&gt;error = urb-&gt;status;
+		hub-&gt;error = status;
 		/* FALL THROUGH */
 
 	/* let khubd handle things */</pre><hr><pre>commit 1431d2a44ccf68a547094976f363f94177ab00c6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:42:39 2007 -0400

    USB: get rid of urb-&gt;lock
    
    Now that urb-&gt;status isn't used, urb-&gt;lock doesn't protect anything.
    This patch (as980) removes it and replaces it with a private mutex in
    the one remaining place it was still used: usb_kill_urb.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c
index 19f5f66c2733..76db76fdb4ec 100644
--- a/drivers/usb/core/urb.c
+++ b/drivers/usb/core/urb.c
@@ -39,7 +39,6 @@ void usb_init_urb(struct urb *urb)
 	if (urb) {
 		memset(urb, 0, sizeof(*urb));
 		kref_init(&amp;urb-&gt;kref);
-		spin_lock_init(&amp;urb-&gt;lock);
 		INIT_LIST_HEAD(&amp;urb-&gt;anchor_list);
 	}
 }
@@ -541,19 +540,21 @@ int usb_unlink_urb(struct urb *urb)
  */
 void usb_kill_urb(struct urb *urb)
 {
+	static DEFINE_MUTEX(reject_mutex);
+
 	might_sleep();
 	if (!(urb &amp;&amp; urb-&gt;dev &amp;&amp; urb-&gt;ep))
 		return;
-	spin_lock_irq(&amp;urb-&gt;lock);
+	mutex_lock(&amp;reject_mutex);
 	++urb-&gt;reject;
-	spin_unlock_irq(&amp;urb-&gt;lock);
+	mutex_unlock(&amp;reject_mutex);
 
 	usb_hcd_unlink_urb(urb, -ENOENT);
 	wait_event(usb_kill_urb_queue, atomic_read(&amp;urb-&gt;use_count) == 0);
 
-	spin_lock_irq(&amp;urb-&gt;lock);
+	mutex_lock(&amp;reject_mutex);
 	--urb-&gt;reject;
-	spin_unlock_irq(&amp;urb-&gt;lock);
+	mutex_unlock(&amp;reject_mutex);
 }
 
 /**
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 5c7b79088add..5b14b4c81fd6 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1241,7 +1241,6 @@ struct urb
 {
 	/* private: usb core and host controller only fields in the urb */
 	struct kref kref;		/* reference count of the URB */
-	spinlock_t lock;		/* lock for the URB */
 	void *hcpriv;			/* private data for host controller */
 	atomic_t use_count;		/* concurrent submissions counter */
 	u8 reject;			/* submissions will fail */
@@ -1299,7 +1298,6 @@ static inline void usb_fill_control_urb (struct urb *urb,
 					 usb_complete_t complete_fn,
 					 void *context)
 {
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev = dev;
 	urb-&gt;pipe = pipe;
 	urb-&gt;setup_packet = setup_packet;
@@ -1330,7 +1328,6 @@ static inline void usb_fill_bulk_urb (struct urb *urb,
 				      usb_complete_t complete_fn,
 				      void *context)
 {
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev = dev;
 	urb-&gt;pipe = pipe;
 	urb-&gt;transfer_buffer = transfer_buffer;
@@ -1366,7 +1363,6 @@ static inline void usb_fill_int_urb (struct urb *urb,
 				     void *context,
 				     int interval)
 {
-	spin_lock_init(&amp;urb-&gt;lock);
 	urb-&gt;dev = dev;
 	urb-&gt;pipe = pipe;
 	urb-&gt;transfer_buffer = transfer_buffer;</pre><hr><pre>commit 4a00027dcb088bf90fa8fb14a7e8ba3506d78f22
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 24 15:42:24 2007 -0400

    USB: Eliminate urb-&gt;status usage!
    
    This patch (as979) removes the last vestiges of urb-&gt;status from the
    host controller drivers and the root-hub emulator.  Now the field
    doesn't get set until just before the URB's completion routine is
    called.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    CC: Olav Kongas &lt;ok@artecdesign.ee&gt;
    CC: Yoshihiro Shimoda &lt;shimoda.yoshihiro@renesas.com&gt;
    CC: Tony Olech &lt;tony.olech@elandigitalsystems.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 4ac021e42cd8..1c5e5d35e08d 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -532,7 +532,6 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 
 	/* any errors get returned through the urb completion */
 	spin_lock_irq(&amp;hcd_root_hub_lock);
-	urb-&gt;status = status;
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 	/* This peculiar use of spinlocks echoes what real HC drivers do.
@@ -540,7 +539,7 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 	 * RT-friendly.
 	 */
 	spin_unlock(&amp;hcd_root_hub_lock);
-	usb_hcd_giveback_urb(hcd, urb);
+	usb_hcd_giveback_urb(hcd, urb, status);
 	spin_lock(&amp;hcd_root_hub_lock);
 
 	spin_unlock_irq(&amp;hcd_root_hub_lock);
@@ -578,13 +577,12 @@ void usb_hcd_poll_rh_status(struct usb_hcd *hcd)
 		if (urb) {
 			hcd-&gt;poll_pending = 0;
 			hcd-&gt;status_urb = NULL;
-			urb-&gt;status = 0;
 			urb-&gt;actual_length = length;
 			memcpy(urb-&gt;transfer_buffer, buffer, length);
 
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 			spin_unlock(&amp;hcd_root_hub_lock);
-			usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, 0);
 			spin_lock(&amp;hcd_root_hub_lock);
 		} else {
 			length = 0;
@@ -677,7 +675,7 @@ static int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 			spin_unlock(&amp;hcd_root_hub_lock);
-			usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, status);
 			spin_lock(&amp;hcd_root_hub_lock);
 		}
 	}
@@ -1252,6 +1250,7 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  * usb_hcd_giveback_urb - return URB from HCD to device driver
  * @hcd: host controller returning the URB
  * @urb: urb being returned to the USB device driver.
+ * @status: completion status code for the URB.
  * Context: in_interrupt()
  *
  * This hands the URB from HCD to its USB device driver, using its
@@ -1260,25 +1259,26 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
  * the device driver won't cause problems if it frees, modifies,
  * or resubmits this URB.
  *
- * If @urb was unlinked, the value of @urb-&gt;status will be overridden by
+ * If @urb was unlinked, the value of @status will be overridden by
  * @urb-&gt;unlinked.  Erroneous short transfers are detected in case
  * the HCD hasn't checked for them.
  */
-void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb)
+void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	urb-&gt;hcpriv = NULL;
 	if (unlikely(urb-&gt;unlinked))
-		urb-&gt;status = urb-&gt;unlinked;
+		status = urb-&gt;unlinked;
 	else if (unlikely((urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) &amp;&amp;
 			urb-&gt;actual_length &lt; urb-&gt;transfer_buffer_length &amp;&amp;
-			!urb-&gt;status))
-		urb-&gt;status = -EREMOTEIO;
+			!status))
+		status = -EREMOTEIO;
 
 	unmap_urb_for_dma(hcd, urb);
-	usbmon_urb_complete(&amp;hcd-&gt;self, urb, urb-&gt;status);
+	usbmon_urb_complete(&amp;hcd-&gt;self, urb, status);
 	usb_unanchor_urb(urb);
 
 	/* pass ownership to the completion handler */
+	urb-&gt;status = status;
 	urb-&gt;complete (urb);
 	atomic_dec (&amp;urb-&gt;use_count);
 	if (unlikely (urb-&gt;reject))
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 729b7a03acd8..0fc7b95259f5 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -217,7 +217,8 @@ extern void usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb);
 
 extern int usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags);
 extern int usb_hcd_unlink_urb (struct urb *urb, int status);
-extern void usb_hcd_giveback_urb (struct usb_hcd *hcd, struct urb *urb);
+extern void usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb,
+		int status);
 extern void usb_hcd_endpoint_disable (struct usb_device *udev,
 		struct usb_host_endpoint *ep);
 extern int usb_hcd_get_frame_number (struct usb_device *udev);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index c1af7bab26f0..58e4d7208805 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1511,8 +1511,7 @@ static void dummy_timer (unsigned long _dum)
 
 		usb_hcd_unlink_urb_from_ep(dummy_to_hcd(dum), urb);
 		spin_unlock (&amp;dum-&gt;lock);
-		urb-&gt;status = status;
-		usb_hcd_giveback_urb (dummy_to_hcd(dum), urb);
+		usb_hcd_giveback_urb(dummy_to_hcd(dum), urb, status);
 		spin_lock (&amp;dum-&gt;lock);
 
 		goto restart;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 794d27e07807..b10f39c047e9 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -256,8 +256,7 @@ __acquires(ehci-&gt;lock)
 	/* complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);
 	spin_unlock (&amp;ehci-&gt;lock);
-	urb-&gt;status = status;
-	usb_hcd_giveback_urb (ehci_to_hcd(ehci), urb);
+	usb_hcd_giveback_urb(ehci_to_hcd(ehci), urb, status);
 	spin_lock (&amp;ehci-&gt;lock);
 }
 
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 35b3507ff401..c27417f5b9d8 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -277,7 +277,7 @@ static void preproc_atl_queue(struct isp116x *isp116x)
   processed urbs.
 */
 static void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,
-			   struct urb *urb)
+			   struct urb *urb, int status)
 __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 {
 	unsigned i;
@@ -291,7 +291,7 @@ __releases(isp116x-&gt;lock) __acquires(isp116x-&gt;lock)
 
 	usb_hcd_unlink_urb_from_ep(isp116x_to_hcd(isp116x), urb);
 	spin_unlock(&amp;isp116x-&gt;lock);
-	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb);
+	usb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb, status);
 	spin_lock(&amp;isp116x-&gt;lock);
 
 	/* take idle endpoints out of the schedule */
@@ -453,13 +453,8 @@ static void postproc_atl_queue(struct isp116x *isp116x)
 		}
 
  done:
-		if (status != -EINPROGRESS) {
-			spin_lock(&amp;urb-&gt;lock);
-			urb-&gt;status = status;
-			spin_unlock(&amp;urb-&gt;lock);
-		}
-		if (urb-&gt;status != -EINPROGRESS || urb-&gt;unlinked)
-			finish_request(isp116x, ep, urb);
+		if (status != -EINPROGRESS || urb-&gt;unlinked)
+			finish_request(isp116x, ep, urb, status);
 	}
 }
 
@@ -853,7 +848,7 @@ static int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
 			}
 
 	if (urb)
-		finish_request(isp116x, ep, urb);
+		finish_request(isp116x, ep, urb, status);
  done:
 	spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
 	return rc;
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index 13d31edd1a86..51817322232b 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -62,8 +62,7 @@ __acquires(ohci-&gt;lock)
 	/* urb-&gt;complete() can reenter this HCD */
 	usb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);
 	spin_unlock (&amp;ohci-&gt;lock);
-	urb-&gt;status = status;
-	usb_hcd_giveback_urb (ohci_to_hcd(ohci), urb);
+	usb_hcd_giveback_urb(ohci_to_hcd(ohci), urb, status);
 	spin_lock (&amp;ohci-&gt;lock);
 
 	/* stop periodic dma if it's not needed */
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
index fea6036771f6..fd00f1e33fb5 100644
--- a/drivers/usb/host/r8a66597-hcd.c
+++ b/drivers/usb/host/r8a66597-hcd.c
@@ -782,12 +782,12 @@ static void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)
 		kfree(td);
 
 		if (urb) {
-			urb-&gt;status = -ENODEV;
 			usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597),
 					urb);
 
 			spin_unlock(&amp;r8a66597-&gt;lock);
-			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb);
+			usb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb,
+					-ENODEV);
 			spin_lock(&amp;r8a66597-&gt;lock);
 		}
 		break;
@@ -1134,10 +1134,8 @@ __releases(r8a66597-&gt;lock) __acquires(r8a66597-&gt;lock)
 			urb-&gt;start_frame = r8a66597_get_frame(hcd);
 
 		usb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);
-
-		urb-&gt;status = status;
 		spin_unlock(&amp;r8a66597-&gt;lock);
-		usb_hcd_giveback_urb(hcd, urb);
+		usb_hcd_giveback_urb(hcd, urb, status);
 		spin_lock(&amp;r8a66597-&gt;lock);
 	}
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index 515152809d37..94d859aa73f8 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -436,9 +436,8 @@ static void finish_request(
 		ep-&gt;nextpid = USB_PID_SETUP;
 
 	usb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);
-	urb-&gt;status = status;
 	spin_unlock(&amp;sl811-&gt;lock);
-	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb);
+	usb_hcd_giveback_urb(sl811_to_hcd(sl811), urb, status);
 	spin_lock(&amp;sl811-&gt;lock);
 
 	/* leave active endpoints in the schedule */
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index db800a434b83..2b379a78d0d5 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -518,7 +518,6 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         unsigned long irqs;
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
-        urb-&gt;status = status;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -542,7 +541,7 @@ static void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,
         u132_ring_queue_work(u132, ring, 0);
         up(&amp;u132-&gt;scheduler_lock);
         u132_endp_put_kref(u132, endp);
-        usb_hcd_giveback_urb(hcd, urb);
+	usb_hcd_giveback_urb(hcd, urb, status);
         return;
 }
 
@@ -558,7 +557,6 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
         unsigned long irqs;
         struct usb_hcd *hcd = u132_to_hcd(u132);
         urb-&gt;error_count = 0;
-        urb-&gt;status = status;
         spin_lock_irqsave(&amp;endp-&gt;queue_lock.slock, irqs);
 	usb_hcd_unlink_urb_from_ep(hcd, urb);
         endp-&gt;queue_next += 1;
@@ -575,7 +573,7 @@ static void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,
                 endp-&gt;active = 0;
                 spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
                 kfree(urbq);
-        } usb_hcd_giveback_urb(hcd, urb);
+	} usb_hcd_giveback_urb(hcd, urb, status);
         return;
 }
 
@@ -719,7 +717,7 @@ static void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -771,7 +769,7 @@ static void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -874,7 +872,7 @@ static void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -911,7 +909,7 @@ static void u132_hcd_configure_empty_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -983,7 +981,7 @@ static void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1020,7 +1018,7 @@ static void u132_hcd_configure_empty_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1080,7 +1078,7 @@ static void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1121,7 +1119,7 @@ static void u132_hcd_enumeration_empty_recv(void *data, struct urb *urb,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1165,7 +1163,7 @@ static void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1202,7 +1200,7 @@ static void u132_hcd_initial_empty_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1254,7 +1252,7 @@ static void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -1299,7 +1297,7 @@ static void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,
 		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "CALLBACK called urb=%p "
 				"unlinked=%d\n", urb, urb-&gt;unlinked);
                 up(&amp;u132-&gt;scheduler_lock);
-                u132_hcd_giveback_urb(u132, endp, urb, urb-&gt;status);
+		u132_hcd_giveback_urb(u132, endp, urb, 0);
                 return;
         }
 }
@@ -2428,7 +2426,7 @@ static int dequeue_from_overflow_chain(struct u132 *u132,
                         list_del(scan);
                         endp-&gt;queue_size -= 1;
                         urb-&gt;error_count = 0;
-                        usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, 0);
                         return 0;
                 } else
                         continue;
@@ -2472,7 +2470,7 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                         return 0;
                 } else {
                         spin_unlock_irqrestore(&amp;endp-&gt;queue_lock.slock, irqs);
-                        u132_hcd_abandon_urb(u132, endp, urb, urb-&gt;status);
+			u132_hcd_abandon_urb(u132, endp, urb, status);
                         return 0;
                 }
         } else {
@@ -2513,7 +2511,7 @@ static int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,
                                         irqs);
                                 kfree(urbq);
                         } urb-&gt;error_count = 0;
-                        usb_hcd_giveback_urb(hcd, urb);
+			usb_hcd_giveback_urb(hcd, urb, status);
                         return 0;
                 } else if (list_empty(&amp;endp-&gt;urb_more)) {
                         dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "urb=%p not found in "
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index e46d2b0203cb..340d6ed3e6e9 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -456,21 +456,6 @@ struct urb_priv {
 };
 
 
-/*
- * Locking in uhci.c
- *
- * Almost everything relating to the hardware schedule and processing
- * of URBs is protected by uhci-&gt;lock.  urb-&gt;status is protected by
- * urb-&gt;lock; that's the one exception.
- *
- * To prevent deadlocks, never lock uhci-&gt;lock while holding urb-&gt;lock.
- * The safe order of locking is:
- *
- * #1 uhci-&gt;lock
- * #2 urb-&gt;lock
- */
-
-
 /* Some special IDs */
 
 #define PCI_VENDOR_ID_GENESYS		0x17a0
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index bab567266559..e5d60d5b105a 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1480,7 +1480,7 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
  * Finish unlinking an URB and give it back
  */
 static void uhci_giveback_urb(struct uhci_hcd *uhci, struct uhci_qh *qh,
-		struct urb *urb)
+		struct urb *urb, int status)
 __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
@@ -1520,7 +1520,7 @@ __acquires(uhci-&gt;lock)
 	usb_hcd_unlink_urb_from_ep(uhci_to_hcd(uhci), urb);
 
 	spin_unlock(&amp;uhci-&gt;lock);
-	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb);
+	usb_hcd_giveback_urb(uhci_to_hcd(uhci), urb, status);
 	spin_lock(&amp;uhci-&gt;lock);
 
 	/* If the queue is now empty, we can unlink the QH and give up its
@@ -1556,10 +1556,6 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		if (status == -EINPROGRESS)
 			break;
 
-		spin_lock(&amp;urb-&gt;lock);
-		urb-&gt;status = status;
-		spin_unlock(&amp;urb-&gt;lock);
-
 		/* Dequeued but completed URBs can't be given back unless
 		 * the QH is stopped or has finished unlinking. */
 		if (urb-&gt;unlinked) {
@@ -1569,7 +1565,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 				return;
 		}
 
-		uhci_giveback_urb(uhci, qh, urb);
+		uhci_giveback_urb(uhci, qh, urb, status);
 		if (status &lt; 0)
 			break;
 	}
@@ -1594,7 +1590,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 				qh-&gt;is_stopped = 0;
 				return;
 			}
-			uhci_giveback_urb(uhci, qh, urb);
+			uhci_giveback_urb(uhci, qh, urb, 0);
 			goto restart;
 		}
 	}</pre>
    <div class="pagination">
        <a href='2_99.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><span>[100]</span><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_101.html'>Next&gt;&gt;</a>
    <div>
</body>
