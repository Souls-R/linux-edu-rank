<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Queensland</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Queensland</h1>
    <div class="pagination">
        <a href='18_3.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><a href='18_3.html'>3</a><span>[4]</span><a href='18_5.html'>5</a><a href='18_6.html'>6</a><a href='18_7.html'>7</a><a href='18_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a44f1c43dfa98e2eb763968890157bfaf9001add
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 06:35:26 2007 -0300

    V4L/DVB (6641): xc2028: correct tuner offset for 7MHz DTV
    
    7MHz bandwidth DVB-T needs an adjusted offset at the PLL to ensure the IF
    output is correctly centered.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index adef80e627b8..c921d6009a8b 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -764,8 +764,11 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 	if (check_firmware(fe, new_mode, std, bandwidth) &lt; 0)
 		goto ret;
 
-	if (new_mode == T_DIGITAL_TV)
+	if (new_mode == T_DIGITAL_TV) {
 		offset = 2750000;
+		if (priv-&gt;bandwidth == BANDWIDTH_7_MHZ)
+			offset -= 500000;
+	}
 
 	div = (freq - offset + DIV / 2) / DIV;
 </pre><hr><pre>commit ddf1c5f1d78c1ce30a7e6b2447670fc0e103bb62
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 06:33:16 2007 -0300

    V4L/DVB (6640): xc2028: correctly select 8MHz firmware
    
    We were using priv-&gt;bandwidth to select the base firmware to load, not the
    requested bandwidth value, oops.  Also, 7MHz Digital TV needs 8MHz base
    firmware loaded.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index e85992f970f7..adef80e627b8 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -608,7 +608,8 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 		if (priv-&gt;ctrl.type == XC2028_FIRM_MTS)
 			type0 |= MTS;
 
-		if (priv-&gt;bandwidth == 8)
+		if (bandwidth == BANDWIDTH_7_MHZ ||
+		    bandwidth == BANDWIDTH_8_MHZ)
 			type0 |= F8MHZ;
 
 		/* FIXME: How to load FM and FM|INPUT1 firmwares? */
@@ -814,7 +815,8 @@ static int xc2028_set_tv_freq(struct dvb_frontend *fe,
 	tuner_dbg("%s called\n", __FUNCTION__);
 
 	return generic_set_tv_freq(fe, 62500l * p-&gt;frequency, T_ANALOG_TV,
-				   p-&gt;std, BANDWIDTH_8_MHZ /* NOT USED */);
+				   p-&gt;std, BANDWIDTH_8_MHZ);
+				   /* XXX Are some analog standards 6MHz? */
 }
 
 static int xc2028_set_params(struct dvb_frontend *fe,</pre><hr><pre>commit 2ce4b3aa7c3c199466ae9f5ed32ea177912c8c3a
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 06:20:17 2007 -0300

    V4L/DVB (6639): xc2028: correct divisor length
    
    The frequency divisor should only be four bytes long.  Also, display the
    frequency and divisor correctly in the debug output.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 7c86971a8d64..e85992f970f7 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -740,7 +740,7 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 {
 	struct xc2028_data *priv = fe-&gt;tuner_priv;
 	int		   rc = -EINVAL;
-	unsigned char	   buf[5];
+	unsigned char	   buf[4];
 	u32		   div, offset = 0;
 
 	tuner_dbg("%s called\n", __FUNCTION__);
@@ -758,7 +758,7 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 		goto ret;
 
 	msleep(10);
-	tuner_dbg("should set frequency %d kHz)\n", freq / 1000);
+	tuner_dbg("should set frequency %d kHz\n", freq / 1000);
 
 	if (check_firmware(fe, new_mode, std, bandwidth) &lt; 0)
 		goto ret;
@@ -769,7 +769,6 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 	div = (freq - offset + DIV / 2) / DIV;
 
 	/* CMD= Set frequency */
-
 	if (priv-&gt;firm_version &lt; 0x0202)
 		rc = send_seq(priv, {0x00, 0x02, 0x00, 0x00});
 	else
@@ -787,7 +786,6 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 	buf[1] = 0xff &amp; (div &gt;&gt; 16);
 	buf[2] = 0xff &amp; (div &gt;&gt; 8);
 	buf[3] = 0xff &amp; (div);
-	buf[4] = 0;
 
 	rc = i2c_send(priv, buf, sizeof(buf));
 	if (rc &lt; 0)
@@ -796,9 +794,9 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 
 	priv-&gt;frequency = freq;
 
-	tuner_dbg("divider= %02x %02x %02x %02x (freq=%d.%02d)\n",
-	       buf[1], buf[2], buf[3], buf[4],
-	       freq / 1000000, (freq % 1000000) / 10000);
+	tuner_dbg("divisor= %02x %02x %02x %02x (freq=%d.%03d)\n",
+	       buf[0], buf[1], buf[2], buf[3],
+	       freq / 1000000, (freq % 1000000) / 1000);
 
 	rc = 0;
 </pre><hr><pre>commit 06fd82dc7bdc6045bf8d6c1438d2a33ffb1cf337
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 06:06:08 2007 -0300

    V4L/DVB (6638): xc2028: firmware loading cleanup
    
    Hold the private lock over set_config and set priv-&gt;firm_size to 0 after a
    failed firmware load to prevent firmware accidentally being freed on us.
    
    Clean up the firmware load/error messages somewhat and rename priv-&gt;version
    to priv-&gt;firm_version to make it clear which "version" it is.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 7e558decad84..7c86971a8d64 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -65,8 +65,7 @@ struct xc2028_data {
 
 	struct firmware_description *firm;
 	int			firm_size;
-
-	__u16			version;
+	__u16			firm_version;
 
 	struct xc2028_ctrl	ctrl;
 
@@ -237,6 +236,7 @@ static void free_firmware(struct xc2028_data *priv)
 	kfree(priv-&gt;firm);
 
 	priv-&gt;firm = NULL;
+	priv-&gt;firm_size = 0;
 	priv-&gt;need_load_generic = 1;
 }
 
@@ -251,7 +251,7 @@ static int load_all_firmwares(struct dvb_frontend *fe)
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
-	tuner_info("Reading firmware %s\n", priv-&gt;ctrl.fname);
+	tuner_dbg("Reading firmware %s\n", priv-&gt;ctrl.fname);
 	rc = request_firmware(&amp;fw, priv-&gt;ctrl.fname,
 			      &amp;priv-&gt;i2c_props.adap-&gt;dev);
 	if (rc &lt; 0) {
@@ -267,40 +267,34 @@ static int load_all_firmwares(struct dvb_frontend *fe)
 	p = fw-&gt;data;
 	endp = p + fw-&gt;size;
 
-	if (fw-&gt;size &lt; sizeof(name) - 1 + 2) {
-		tuner_err("Error: firmware size is zero!\n");
-		rc = -EINVAL;
-		goto done;
+	if (fw-&gt;size &lt; sizeof(name) - 1 + 2 + 2) {
+		tuner_err("Error: firmware file %s has invalid size!\n",
+			  priv-&gt;ctrl.fname);
+		goto corrupt;
 	}
 
 	memcpy(name, p, sizeof(name) - 1);
 	name[sizeof(name) - 1] = 0;
 	p += sizeof(name) - 1;
 
-	priv-&gt;version = le16_to_cpu(*(__u16 *) p);
+	priv-&gt;firm_version = le16_to_cpu(*(__u16 *) p);
 	p += 2;
 
-	tuner_info("Firmware: %s, ver %d.%d\n", name,
-		   priv-&gt;version &gt;&gt; 8, priv-&gt;version &amp; 0xff);
-
-	if (p + 2 &gt; endp)
-		goto corrupt;
-
 	n_array = le16_to_cpu(*(__u16 *) p);
 	p += 2;
 
-	tuner_info("There are %d firmwares at %s\n",
-		   n_array, priv-&gt;ctrl.fname);
+	tuner_info("Loading %d firmware images from %s, type: %s, ver %d.%d\n",
+		   n_array, priv-&gt;ctrl.fname, name,
+		   priv-&gt;firm_version &gt;&gt; 8, priv-&gt;firm_version &amp; 0xff);
 
 	priv-&gt;firm = kzalloc(sizeof(*priv-&gt;firm) * n_array, GFP_KERNEL);
-
-	if (!fw) {
-		tuner_err("Not enough memory for reading firmware.\n");
+	if (priv-&gt;firm == NULL) {
+		tuner_err("Not enough memory to load firmware file.\n");
 		rc = -ENOMEM;
-		goto done;
+		goto err;
 	}
-
 	priv-&gt;firm_size = n_array;
+
 	n = -1;
 	while (p &lt; endp) {
 		__u32 type, size;
@@ -308,7 +302,8 @@ static int load_all_firmwares(struct dvb_frontend *fe)
 
 		n++;
 		if (n &gt;= n_array) {
-			tuner_err("Too much firmwares at the file\n");
+			tuner_err("More firmware images in file than "
+				  "were expected!\n");
 			goto corrupt;
 		}
 
@@ -338,15 +333,17 @@ static int load_all_firmwares(struct dvb_frontend *fe)
 		}
 
 		priv-&gt;firm[n].ptr = kzalloc(size, GFP_KERNEL);
-		if (!priv-&gt;firm[n].ptr) {
-			tuner_err("Not enough memory.\n");
+		if (priv-&gt;firm[n].ptr == NULL) {
+			tuner_err("Not enough memory to load firmware file.\n");
 			rc = -ENOMEM;
 			goto err;
 		}
-		tuner_info("Reading firmware type ");
-		dump_firm_type(type);
-		printk("(%x), id %llx, size=%d.\n",
-			   type, (unsigned long long)id, size);
+		tuner_dbg("Reading firmware type ");
+		if (debug) {
+			dump_firm_type(type);
+			printk("(%x), id %llx, size=%d.\n",
+				   type, (unsigned long long)id, size);
+		}
 
 		memcpy(priv-&gt;firm[n].ptr, p, size);
 		priv-&gt;firm[n].type = type;
@@ -368,13 +365,13 @@ static int load_all_firmwares(struct dvb_frontend *fe)
 	tuner_err("Error: firmware file is corrupted!\n");
 
 err:
-	tuner_info("Releasing loaded firmware file.\n");
-
+	tuner_info("Releasing partially loaded firmware file.\n");
 	free_firmware(priv);
 
 done:
 	release_firmware(fw);
-	tuner_dbg("Firmware files loaded.\n");
+	if (rc == 0)
+		tuner_dbg("Firmware files loaded.\n");
 
 	return rc;
 }
@@ -442,11 +439,6 @@ static int load_firmware(struct dvb_frontend *fe, unsigned int type,
 	printk("(%x), id %016llx.\n", type, (unsigned long long)*id);
 
 	p = priv-&gt;firm[pos].ptr;
-
-	if (!p) {
-		tuner_err("Firmware pointer were freed!");
-		return -EINVAL;
-	}
 	endp = p + priv-&gt;firm[pos].size;
 
 	while (p &lt; endp) {
@@ -546,15 +538,10 @@ static int load_scode(struct dvb_frontend *fe, unsigned int type,
 
 	p = priv-&gt;firm[pos].ptr;
 
-	if (!p) {
-		tuner_err("Firmware pointer were freed!");
-		return -EINVAL;
-	}
-
 	if ((priv-&gt;firm[pos].size != 12 * 16) || (scode &gt;= 16))
 		return -EINVAL;
 
-	if (priv-&gt;version &lt; 0x0202)
+	if (priv-&gt;firm_version &lt; 0x0202)
 		rc = send_seq(priv, {0x20, 0x00, 0x00, 0x00});
 	else
 		rc = send_seq(priv, {0xa0, 0x00, 0x00, 0x00});
@@ -783,7 +770,7 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 
 	/* CMD= Set frequency */
 
-	if (priv-&gt;version &lt; 0x0202)
+	if (priv-&gt;firm_version &lt; 0x0202)
 		rc = send_seq(priv, {0x00, 0x02, 0x00, 0x00});
 	else
 		rc = send_seq(priv, {0x80, 0x02, 0x00, 0x00});
@@ -868,6 +855,7 @@ static int xc2028_dvb_release(struct dvb_frontend *fe)
 
 		free_firmware(priv);
 		kfree(priv);
+		fe-&gt;tuner_priv = NULL;
 	}
 
 	mutex_unlock(&amp;xc2028_list_mutex);
@@ -893,14 +881,18 @@ static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
+	mutex_lock(&amp;priv-&gt;lock);
+
 	priv-&gt;ctrl.type = p-&gt;type;
 
 	if (p-&gt;fname) {
 		kfree(priv-&gt;ctrl.fname);
 
 		priv-&gt;ctrl.fname = kmalloc(strlen(p-&gt;fname) + 1, GFP_KERNEL);
-		if (!priv-&gt;ctrl.fname)
+		if (priv-&gt;ctrl.fname == NULL) {
+			mutex_unlock(&amp;priv-&gt;lock);
 			return -ENOMEM;
+		}
 
 		free_firmware(priv);
 		strcpy(priv-&gt;ctrl.fname, p-&gt;fname);
@@ -909,6 +901,8 @@ static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)
 	if (p-&gt;max_len &gt; 0)
 		priv-&gt;max_len = p-&gt;max_len;
 
+	mutex_unlock(&amp;priv-&gt;lock);
+
 	return 0;
 }
 </pre><hr><pre>commit b32f9fb962d593e3c5a61092a79434714f405ef5
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 04:53:50 2007 -0300

    V4L/DVB (6637): xc2028: add missing break
    
    Add break to stop us from following the default failure path even upon success.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index ac7f3e1d32f4..7e558decad84 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -485,6 +485,7 @@ static int load_firmware(struct dvb_frontend *fe, unsigned int type,
 						  (*p) &amp; 0x7f);
 					return -EINVAL;
 				}
+				break;
 			default:
 				tuner_info("Invalid RESET code %d\n",
 					   size &amp; 0x7f);</pre><hr><pre>commit aa501be989f5df58c4732d5eb1989e5ca6479d90
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 04:45:38 2007 -0300

    V4L/DVB (6636): xc2028: protect device list
    
    Protect refcount changes and modifications to xc2028_list with a mutex.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index a01231a0410d..ac7f3e1d32f4 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -44,6 +44,8 @@ MODULE_PARM_DESC(audio_std,
 	"NICAM/B\n");
 
 static LIST_HEAD(xc2028_list);
+static DEFINE_MUTEX(xc2028_list_mutex);
+
 /* struct for storing firmware table */
 struct firmware_description {
 	unsigned int  type;
@@ -854,6 +856,8 @@ static int xc2028_dvb_release(struct dvb_frontend *fe)
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
+	mutex_lock(&amp;xc2028_list_mutex);
+
 	priv-&gt;count--;
 
 	if (!priv-&gt;count) {
@@ -865,6 +869,8 @@ static int xc2028_dvb_release(struct dvb_frontend *fe)
 		kfree(priv);
 	}
 
+	mutex_unlock(&amp;xc2028_list_mutex);
+
 	return 0;
 }
 
@@ -940,6 +946,8 @@ void *xc2028_attach(struct dvb_frontend *fe, struct xc2028_config *cfg)
 
 	video_dev = cfg-&gt;video_dev;
 
+	mutex_lock(&amp;xc2028_list_mutex);
+
 	list_for_each_entry(priv, &amp;xc2028_list, xc2028_list) {
 		if (priv-&gt;video_dev == cfg-&gt;video_dev) {
 			video_dev = NULL;
@@ -949,8 +957,10 @@ void *xc2028_attach(struct dvb_frontend *fe, struct xc2028_config *cfg)
 
 	if (video_dev) {
 		priv = kzalloc(sizeof(*priv), GFP_KERNEL);
-		if (priv == NULL)
+		if (priv == NULL) {
+			mutex_unlock(&amp;xc2028_list_mutex);
 			return NULL;
+		}
 
 		priv-&gt;bandwidth = BANDWIDTH_6_MHZ;
 		priv-&gt;need_load_generic = 1;
@@ -974,6 +984,8 @@ void *xc2028_attach(struct dvb_frontend *fe, struct xc2028_config *cfg)
 
 	tuner_info("type set to %s\n", "XCeive xc2028/xc3028 tuner");
 
+	mutex_unlock(&amp;xc2028_list_mutex);
+
 	return fe;
 }
 </pre><hr><pre>commit 91240dd92474d4124f80b00e6200052b275a99a1
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 04:38:53 2007 -0300

    V4L/DVB (6635): xc2028: v4l2_std_id needs to be long long to display completely
    
    Cast v4l2_std_id variables to unsigned long long so they will printk properly.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index c208f1f5e72c..a01231a0410d 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -330,7 +330,7 @@ static int load_all_firmwares(struct dvb_frontend *fe)
 			dump_firm_type(type);
 			printk("(%x), id %llx is corrupted "
 			       "(size=%d, expected %d)\n",
-			       type, id,
+			       type, (unsigned long long)id,
 			       (unsigned)(endp - p), size);
 			goto corrupt;
 		}
@@ -343,8 +343,8 @@ static int load_all_firmwares(struct dvb_frontend *fe)
 		}
 		tuner_info("Reading firmware type ");
 		dump_firm_type(type);
-		printk("(%x), id %lx, size=%d.\n",
-			   type, (unsigned long)id, size);
+		printk("(%x), id %llx, size=%d.\n",
+			   type, (unsigned long long)id, size);
 
 		memcpy(priv-&gt;firm[n].ptr, p, size);
 		priv-&gt;firm[n].type = type;
@@ -417,7 +417,7 @@ static int seek_firmware(struct dvb_frontend *fe, unsigned int type,
 	tuner_dbg("%s firmware for type=", (i &lt; 0)? "Can't find": "Found");
 	if (debug) {
 		dump_firm_type(type);
-		printk("(%x), id %08lx.\n", type, (unsigned long)*id);
+		printk("(%x), id %016llx.\n", type, (unsigned long long)*id);
 	}
 	return i;
 }
@@ -437,7 +437,7 @@ static int load_firmware(struct dvb_frontend *fe, unsigned int type,
 
 	tuner_info("Loading firmware for type=");
 	dump_firm_type(type);
-	printk("(%x), id %08lx.\n", type, (unsigned long)*id);
+	printk("(%x), id %016llx.\n", type, (unsigned long long)*id);
 
 	p = priv-&gt;firm[pos].ptr;
 </pre><hr><pre>commit 3157ecef3bce47df74427d6656fa8592bfe8d2d7
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 04:34:29 2007 -0300

    V4L/DVB (6634): xc2028: error messages missing whitespace
    
    Fix some missing spaces in errors that may be emitted during attach failure.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index a49a4e886897..c208f1f5e72c 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -928,13 +928,13 @@ void *xc2028_attach(struct dvb_frontend *fe, struct xc2028_config *cfg)
 	void               *video_dev;
 
 	if (debug)
-		printk(KERN_DEBUG PREFIX "Xcv2028/3028 init called!\n");
+		printk(KERN_DEBUG PREFIX ": Xcv2028/3028 init called!\n");
 
 	if (NULL == cfg-&gt;video_dev)
 		return NULL;
 
 	if (!fe) {
-		printk(KERN_ERR PREFIX "No frontend!\n");
+		printk(KERN_ERR PREFIX ": No frontend!\n");
 		return NULL;
 	}
 </pre><hr><pre>commit 7d58d1117ec02f5fe22ddd03ca08fe2a8c777ea2
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 04:31:58 2007 -0300

    V4L/DVB (6633): xc2028: make register reads atomic
    
    Issuing register reads as a separate address write and data read transactions
    means that other I2C activity could occur in between and state could get out
    of sync.  Issue both the write and read in a single transaction so that the
    i2c layer can prevent other users accessing the bus until we are complete.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-i2c.h b/drivers/media/video/tuner-i2c.h
index b5ac189ba40f..d7cf72c3fd71 100644
--- a/drivers/media/video/tuner-i2c.h
+++ b/drivers/media/video/tuner-i2c.h
@@ -46,6 +46,19 @@ static inline int tuner_i2c_xfer_recv(struct tuner_i2c_props *props, char *buf,
 	return (ret == 1) ? len : ret;
 }
 
+static inline int tuner_i2c_xfer_send_recv(struct tuner_i2c_props *props,
+					   char *obuf, int olen,
+					   char *ibuf, int ilen)
+{
+	struct i2c_msg msg[2] = { { .addr = props-&gt;addr, .flags = 0,
+				    .buf = obuf, .len = olen },
+				  { .addr = props-&gt;addr, .flags = I2C_M_RD,
+				    .buf = ibuf, .len = ilen } };
+	int ret = i2c_transfer(props-&gt;adap, msg, 2);
+
+	return (ret == 2) ? ilen : ret;
+}
+
 #ifndef __TUNER_DRIVER_H__
 #define tuner_warn(fmt, arg...) do {					\
 	printk(KERN_WARNING "%s %d-%04x: " fmt, PREFIX,			\
diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 166fede7d0e3..a49a4e886897 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -101,6 +101,16 @@ struct xc2028_data {
 	_rc;								\
 })
 
+#define i2c_send_recv(priv, obuf, osize, ibuf, isize) ({		\
+	int _rc;							\
+	_rc = tuner_i2c_xfer_send_recv(&amp;priv-&gt;i2c_props, obuf, osize,	\
+				       ibuf, isize);			\
+	if (isize != _rc)						\
+		tuner_err("i2c input error: rc = %d (should be %d)\n",	\
+			   _rc, (int)isize); 				\
+	_rc;								\
+})
+
 #define send_seq(priv, data...)	({					\
 	static u8 _val[] = data;					\
 	int _rc;							\
@@ -113,25 +123,21 @@ struct xc2028_data {
 	_rc;								\
 })
 
-static unsigned int xc2028_get_reg(struct xc2028_data *priv, u16 reg)
+static unsigned int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
 {
-	int rc;
 	unsigned char buf[2];
+	unsigned char ibuf[2];
 
-	tuner_dbg("%s called\n", __FUNCTION__);
+	tuner_dbg("%s %04x called\n", __FUNCTION__, reg);
 
-	buf[0] = reg&gt;&gt;8;
+	buf[0] = reg &gt;&gt; 8;
 	buf[1] = (unsigned char) reg;
 
-	rc = i2c_send(priv, buf, 2);
-	if (rc &lt; 0)
-		return rc;
-
-	rc = i2c_rcv(priv, buf, 2);
-	if (rc &lt; 0)
-		return rc;
+	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
+		return -EIO;
 
-	return (buf[1]) | (buf[0] &lt;&lt; 8);
+	*val = (ibuf[1]) | (ibuf[0] &lt;&lt; 8);
+	return 0;
 }
 
 void dump_firm_type(unsigned int type)
@@ -567,7 +573,8 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 			  v4l2_std_id std, fe_bandwidth_t bandwidth)
 {
 	struct xc2028_data      *priv = fe-&gt;tuner_priv;
-	int			rc, version, hwmodel;
+	int			rc;
+	u16			version, hwmodel;
 	v4l2_std_id		std0 = 0;
 	unsigned int		type0 = 0, type = 0;
 	int			change_digital_bandwidth;
@@ -692,8 +699,8 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 
 	rc = load_scode(fe, type, &amp;std, 0);
 
-	version = xc2028_get_reg(priv, 0x0004);
-	hwmodel = xc2028_get_reg(priv, 0x0008);
+	xc2028_get_reg(priv, 0x0004, &amp;version);
+	xc2028_get_reg(priv, 0x0008, &amp;hwmodel);
 
 	tuner_info("Device is Xceive %d version %d.%d, "
 		   "firmware version %d.%d\n",
@@ -708,33 +715,31 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 static int xc2028_signal(struct dvb_frontend *fe, u16 *strength)
 {
 	struct xc2028_data *priv = fe-&gt;tuner_priv;
-	int                frq_lock, signal = 0;
+	u16                 frq_lock, signal = 0;
+	int                 rc;
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
 	mutex_lock(&amp;priv-&gt;lock);
 
-	*strength = 0;
-
 	/* Sync Lock Indicator */
-	frq_lock = xc2028_get_reg(priv, 0x0002);
-	if (frq_lock &lt;= 0)
+	rc = xc2028_get_reg(priv, 0x0002, &amp;frq_lock);
+	if (rc &lt; 0 || frq_lock == 0)
 		goto ret;
 
 	/* Frequency is locked. Return signal quality */
 
 	/* Get SNR of the video signal */
-	signal = xc2028_get_reg(priv, 0x0040);
-
-	if (signal &lt;= 0)
-		signal = frq_lock;
+	rc = xc2028_get_reg(priv, 0x0040, &amp;signal);
+	if (rc &lt; 0)
+		signal = -frq_lock;
 
 ret:
 	mutex_unlock(&amp;priv-&gt;lock);
 
 	*strength = signal;
 
-	return 0;
+	return rc;
 }
 
 #define DIV 15625</pre><hr><pre>commit e155d908f72cc429b538c101ee8ffcd10a44b69b
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 04:16:47 2007 -0300

    V4L/DVB (6632): xc2028: fix inverted logic in audio standard check
    
    strcasecmp returns 0 on match, not true.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 6e23fad0e560..166fede7d0e3 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -200,17 +200,17 @@ void dump_firm_type(unsigned int type)
 
 static  v4l2_std_id parse_audio_std_option(void)
 {
-	if (strcasecmp(audio_std, "A2"))
+	if (strcasecmp(audio_std, "A2") == 0)
 		return V4L2_STD_A2;
-	if (strcasecmp(audio_std, "A2/A"))
+	if (strcasecmp(audio_std, "A2/A") == 0)
 		return V4L2_STD_A2_A;
-	if (strcasecmp(audio_std, "A2/B"))
+	if (strcasecmp(audio_std, "A2/B") == 0)
 		return V4L2_STD_A2_B;
-	if (strcasecmp(audio_std, "NICAM"))
+	if (strcasecmp(audio_std, "NICAM") == 0)
 		return V4L2_STD_NICAM;
-	if (strcasecmp(audio_std, "NICAM/A"))
+	if (strcasecmp(audio_std, "NICAM/A") == 0)
 		return V4L2_STD_NICAM_A;
-	if (strcasecmp(audio_std, "NICAM/B"))
+	if (strcasecmp(audio_std, "NICAM/B") == 0)
 		return V4L2_STD_NICAM_B;
 
 	return 0;</pre>
    <div class="pagination">
        <a href='18_3.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><a href='18_3.html'>3</a><span>[4]</span><a href='18_5.html'>5</a><a href='18_6.html'>6</a><a href='18_7.html'>7</a><a href='18_5.html'>Next&gt;&gt;</a>
    <div>
</body>
