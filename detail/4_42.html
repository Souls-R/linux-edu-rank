<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_41.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><span>[42]</span><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_43.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 02888f41e9d7fa95d1f5b2f76e0f0af6ea8198cc
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Sep 12 15:45:07 2007 -0400

    locks: fix flock_lock_file() comment
    
    This comment wasn't updated when lease support was added, and it makes
    essentially the same mistake that the code made before a recent bugfix.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 6e22c8129a80..c7c69d29a576 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -715,8 +715,7 @@ static int posix_locks_deadlock(struct file_lock *caller_fl,
 }
 
 /* Try to create a FLOCK lock on filp. We always insert new FLOCK locks
- * at the head of the list, but that's secret knowledge known only to
- * flock_lock_file and posix_lock_file.
+ * after any leases, but before any posix locks.
  *
  * Note that if called with an FL_EXISTS argument, the caller may determine
  * whether or not a lock was successfully freed by testing the return</pre><hr><pre>commit b842e240f27678aa5d71611cddc8d17a93fb0caf
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu May 10 19:02:07 2007 -0400

    locks: reverse order of posix_locks_conflict() arguments
    
    The first argument to posix_locks_conflict() is meant to be a lock request,
    and the second a lock from an inode's lock request.  It doesn't really
    make a difference which order you call them in, since the only
    asymmetric test in posix_lock_conflict() is the check whether the second
    argument is a posix lock--and every caller already does that check for
    some reason.
    
    But may as well fix posix_test_lock() to call posix_locks_conflict()
    with the arguments in the same order as everywhere else.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index c795eaaf6c4c..51bae6227c25 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -668,7 +668,7 @@ posix_test_lock(struct file *filp, struct file_lock *fl)
 	for (cfl = filp-&gt;f_path.dentry-&gt;d_inode-&gt;i_flock; cfl; cfl = cfl-&gt;fl_next) {
 		if (!IS_POSIX(cfl))
 			continue;
-		if (posix_locks_conflict(cfl, fl))
+		if (posix_locks_conflict(fl, cfl))
 			break;
 	}
 	if (cfl)</pre><hr><pre>commit a16e92edcd0a2846455a30823e1bac964e743baa
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Sep 28 16:45:51 2007 -0400

    knfsd: query filesystem for NFSv4 getattr of FATTR4_MAXNAME
    
    Without this we always return 2^32-1 as the the maximum namelength.
    
    Thanks to Andreas Gruenbacher for bug report and testing.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: Andreas Gruenbacher &lt;agruen@suse.de&gt;

diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 9cf900740c76..e15f2cf8ac15 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1475,7 +1475,8 @@ nfsd4_encode_fattr(struct svc_fh *fhp, struct svc_export *exp,
 	err = vfs_getattr(exp-&gt;ex_mnt, dentry, &amp;stat);
 	if (err)
 		goto out_nfserr;
-	if ((bmval0 &amp; (FATTR4_WORD0_FILES_FREE | FATTR4_WORD0_FILES_TOTAL)) ||
+	if ((bmval0 &amp; (FATTR4_WORD0_FILES_FREE | FATTR4_WORD0_FILES_TOTAL |
+			FATTR4_WORD0_MAXNAME)) ||
 	    (bmval1 &amp; (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |
 		       FATTR4_WORD1_SPACE_TOTAL))) {
 		err = vfs_statfs(dentry, &amp;statfs);
@@ -1721,7 +1722,7 @@ nfsd4_encode_fattr(struct svc_fh *fhp, struct svc_export *exp,
 	if (bmval0 &amp; FATTR4_WORD0_MAXNAME) {
 		if ((buflen -= 4) &lt; 0)
 			goto out_resource;
-		WRITE32(~(u32) 0);
+		WRITE32(statfs.f_namelen);
 	}
 	if (bmval0 &amp; FATTR4_WORD0_MAXREAD) {
 		if ((buflen -= 8) &lt; 0)</pre><hr><pre>commit cfdcad4da1903720b9b8c1f176e46a0ebf546be3
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Sep 12 20:35:15 2007 -0400

    knfsd: nfsv4 delegation recall should take reference on client
    
    It's not enough to take a reference on the delegation object itself; we
    need to ensure that the rpc_client won't go away just as we're about to
    make an rpc call.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index c1cb7e009c1e..9d536a8cb379 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -486,6 +486,7 @@ nfsd4_cb_recall(struct nfs4_delegation *dp)
 	/* Success or failure, now we're either waiting for lease expiration
 	 * or deleg_return. */
 	dprintk("NFSD: nfs4_cb_recall: dp %p dl_flock %p dl_count %d\n",dp, dp-&gt;dl_flock, atomic_read(&amp;dp-&gt;dl_count));
+	put_nfs4_client(clp);
 	nfs4_put_delegation(dp);
 	return;
 }
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index e706c6961691..6f182d25793d 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1345,6 +1345,7 @@ void nfsd_break_deleg_cb(struct file_lock *fl)
 	 * lock) we know the server hasn't removed the lease yet, we know
 	 * it's safe to take a reference: */
 	atomic_inc(&amp;dp-&gt;dl_count);
+	atomic_inc(&amp;dp-&gt;dl_client-&gt;cl_count);
 
 	spin_lock(&amp;recall_lock);
 	list_add_tail(&amp;dp-&gt;dl_recall_lru, &amp;del_recall_lru);
@@ -1367,6 +1368,7 @@ void nfsd_break_deleg_cb(struct file_lock *fl)
 		printk(KERN_INFO "NFSD: Callback thread failed for "
 			"for client (clientid %08x/%08x)\n",
 			clp-&gt;cl_clientid.cl_boot, clp-&gt;cl_clientid.cl_id);
+		put_nfs4_client(dp-&gt;dl_client);
 		nfs4_put_delegation(dp);
 	}
 }</pre><hr><pre>commit 1b1a9b3163a83f52ea2ac333846d4dfd2c4edd90
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Sep 12 08:43:59 2007 -0400

    knfsd: don't shutdown callbacks until nfsv4 client is freed
    
    If a callback still holds a reference on the client, then it may be
    about to perform an rpc call, so it isn't safe to call rpc_shutdown().
    (Though rpc_shutdown() does wait for any outstanding rpc's, it can't
    know if a new rpc is about to be issued with that client.)
    
    So, wait to shutdown the rpc_client until the reference count on the
    client has gone to zero.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 48fbdac33c7c..e706c6961691 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -358,9 +358,22 @@ alloc_client(struct xdr_netobj name)
 	return clp;
 }
 
+static void
+shutdown_callback_client(struct nfs4_client *clp)
+{
+	struct rpc_clnt *clnt = clp-&gt;cl_callback.cb_client;
+
+	/* shutdown rpc client, ending any outstanding recall rpcs */
+	if (clnt) {
+		clp-&gt;cl_callback.cb_client = NULL;
+		rpc_shutdown_client(clnt);
+	}
+}
+
 static inline void
 free_client(struct nfs4_client *clp)
 {
+	shutdown_callback_client(clp);
 	if (clp-&gt;cl_cred.cr_group_info)
 		put_group_info(clp-&gt;cl_cred.cr_group_info);
 	kfree(clp-&gt;cl_name.data);
@@ -374,18 +387,6 @@ put_nfs4_client(struct nfs4_client *clp)
 		free_client(clp);
 }
 
-static void
-shutdown_callback_client(struct nfs4_client *clp)
-{
-	struct rpc_clnt *clnt = clp-&gt;cl_callback.cb_client;
-
-	/* shutdown rpc client, ending any outstanding recall rpcs */
-	if (clnt) {
-		clp-&gt;cl_callback.cb_client = NULL;
-		rpc_shutdown_client(clnt);
-	}
-}
-
 static void
 expire_client(struct nfs4_client *clp)
 {
@@ -396,8 +397,6 @@ expire_client(struct nfs4_client *clp)
 	dprintk("NFSD: expire_client cl_count %d\n",
 	                    atomic_read(&amp;clp-&gt;cl_count));
 
-	shutdown_callback_client(clp);
-
 	INIT_LIST_HEAD(&amp;reaplist);
 	spin_lock(&amp;recall_lock);
 	while (!list_empty(&amp;clp-&gt;cl_delegations)) {</pre><hr><pre>commit 0272e1fd9f4fa8a43357c168e081744f99e67195
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Sep 12 18:56:12 2007 -0400

    knfsd: let nfsd manage timing out its own leases
    
    Currently there's a race that can cause an oops in generic_setlease.
    
    (In detail: nfsd, when it removes a lease, does so by calling
    vfs_setlease() with F_UNLCK and a pointer to the fl_flock field, which
    in turn points to nfsd's existing lease; but the first thing the
    setlease code does is call time_out_leases().  If the lease happens to
    already be beyond the lease break time, that will free the lease and (in
    nfsd's release_private callback) set fl_flock to NULL, leading to a NULL
    deference soon after in vfs_setlease().)
    
    There are probably other things to fix here too, but it seems inherently
    racy to allow either locks.c or nfsd to time out this lease.  Instead
    just set the fl_break_time to 0 (preventing locks.c from ever timing out
    this lock) and leave it up to nfsd's laundromat thread to deal with it.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 6256492b2363..48fbdac33c7c 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1354,8 +1354,12 @@ void nfsd_break_deleg_cb(struct file_lock *fl)
 	/* only place dl_time is set. protected by lock_kernel*/
 	dp-&gt;dl_time = get_seconds();
 
-	/* XXX need to merge NFSD_LEASE_TIME with fs/locks.c:lease_break_time */
-	fl-&gt;fl_break_time = jiffies + NFSD_LEASE_TIME * HZ;
+	/*
+	 * We don't want the locks code to timeout the lease for us;
+	 * we'll remove it ourself if the delegation isn't returned
+	 * in time.
+	 */
+	fl-&gt;fl_break_time = 0;
 
 	t = kthread_run(do_recall, dp, "%s", "nfs4_cb_recall");
 	if (IS_ERR(t)) {</pre><hr><pre>commit 21fcd02be34f73bbc94db267b4db6ccd7332923d
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Aug 9 20:16:22 2007 -0400

    svcgss: move init code into separate function
    
    We've let svcauth_gss_accept() get much too long and hairy.  The
    RPC_GSS_PROC_INIT and RPC_GSS_PROC_CONTINUE_INIT cases share very little
    with the other cases, so it's very natural to split them off into a
    separate function.
    
    This will also nicely isolate the piece of code we need to parametrize
    to authenticating gss-protected NFSv4 callbacks on behalf of the NFS
    client.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Acked-by: Neil Brown &lt;neilb@suse.de&gt;

diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index 7da7050f06c3..73940df6c460 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -631,7 +631,8 @@ svc_safe_putnetobj(struct kvec *resv, struct xdr_netobj *o)
 	return 0;
 }
 
-/* Verify the checksum on the header and return SVC_OK on success.
+/*
+ * Verify the checksum on the header and return SVC_OK on success.
  * Otherwise, return SVC_DROP (in the case of a bad sequence number)
  * or return SVC_DENIED and indicate error in authp.
  */
@@ -960,6 +961,78 @@ gss_write_init_verf(struct svc_rqst *rqstp, struct rsi *rsip)
 	return rc;
 }
 
+/*
+ * Having read the cred already and found we're in the context
+ * initiation case, read the verifier and initiate (or check the results
+ * of) upcalls to userspace for help with context initiation.  If
+ * the upcall results are available, write the verifier and result.
+ * Otherwise, drop the request pending an answer to the upcall.
+ */
+static int svcauth_gss_handle_init(struct svc_rqst *rqstp,
+			struct rpc_gss_wire_cred *gc, __be32 *authp)
+{
+	struct kvec *argv = &amp;rqstp-&gt;rq_arg.head[0];
+	struct kvec *resv = &amp;rqstp-&gt;rq_res.head[0];
+	struct xdr_netobj tmpobj;
+	struct rsi *rsip, rsikey;
+
+	/* Read the verifier; should be NULL: */
+	*authp = rpc_autherr_badverf;
+	if (argv-&gt;iov_len &lt; 2 * 4)
+		return SVC_DENIED;
+	if (svc_getnl(argv) != RPC_AUTH_NULL)
+		return SVC_DENIED;
+	if (svc_getnl(argv) != 0)
+		return SVC_DENIED;
+
+	/* Martial context handle and token for upcall: */
+	*authp = rpc_autherr_badcred;
+	if (gc-&gt;gc_proc == RPC_GSS_PROC_INIT &amp;&amp; gc-&gt;gc_ctx.len != 0)
+		return SVC_DENIED;
+	memset(&amp;rsikey, 0, sizeof(rsikey));
+	if (dup_netobj(&amp;rsikey.in_handle, &amp;gc-&gt;gc_ctx))
+		return SVC_DROP;
+	*authp = rpc_autherr_badverf;
+	if (svc_safe_getnetobj(argv, &amp;tmpobj)) {
+		kfree(rsikey.in_handle.data);
+		return SVC_DENIED;
+	}
+	if (dup_netobj(&amp;rsikey.in_token, &amp;tmpobj)) {
+		kfree(rsikey.in_handle.data);
+		return SVC_DROP;
+	}
+
+	/* Perform upcall, or find upcall result: */
+	rsip = rsi_lookup(&amp;rsikey);
+	rsi_free(&amp;rsikey);
+	if (!rsip)
+		return SVC_DROP;
+	switch (cache_check(&amp;rsi_cache, &amp;rsip-&gt;h, &amp;rqstp-&gt;rq_chandle)) {
+	case -EAGAIN:
+	case -ETIMEDOUT:
+	case -ENOENT:
+		/* No upcall result: */
+		return SVC_DROP;
+	case 0:
+		/* Got an answer to the upcall; use it: */
+		if (gss_write_init_verf(rqstp, rsip))
+			return SVC_DROP;
+		if (resv-&gt;iov_len + 4 &gt; PAGE_SIZE)
+			return SVC_DROP;
+		svc_putnl(resv, RPC_SUCCESS);
+		if (svc_safe_putnetobj(resv, &amp;rsip-&gt;out_handle))
+			return SVC_DROP;
+		if (resv-&gt;iov_len + 3 * 4 &gt; PAGE_SIZE)
+			return SVC_DROP;
+		svc_putnl(resv, rsip-&gt;major_status);
+		svc_putnl(resv, rsip-&gt;minor_status);
+		svc_putnl(resv, GSS_SEQ_WIN);
+		if (svc_safe_putnetobj(resv, &amp;rsip-&gt;out_token))
+			return SVC_DROP;
+	}
+	return SVC_COMPLETE;
+}
+
 /*
  * Accept an rpcsec packet.
  * If context establishment, punt to user space
@@ -974,11 +1047,9 @@ svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)
 	struct kvec	*argv = &amp;rqstp-&gt;rq_arg.head[0];
 	struct kvec	*resv = &amp;rqstp-&gt;rq_res.head[0];
 	u32		crlen;
-	struct xdr_netobj tmpobj;
 	struct gss_svc_data *svcdata = rqstp-&gt;rq_auth_data;
 	struct rpc_gss_wire_cred *gc;
 	struct rsc	*rsci = NULL;
-	struct rsi	*rsip, rsikey;
 	__be32		*rpcstart;
 	__be32		*reject_stat = resv-&gt;iov_base + resv-&gt;iov_len;
 	int		ret;
@@ -1023,30 +1094,14 @@ svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)
 	if ((gc-&gt;gc_proc != RPC_GSS_PROC_DATA) &amp;&amp; (rqstp-&gt;rq_proc != 0))
 		goto auth_err;
 
-	/*
-	 * We've successfully parsed the credential. Let's check out the
-	 * verifier.  An AUTH_NULL verifier is allowed (and required) for
-	 * INIT and CONTINUE_INIT requests. AUTH_RPCSEC_GSS is required for
-	 * PROC_DATA and PROC_DESTROY.
-	 *
-	 * AUTH_NULL verifier is 0 (AUTH_NULL), 0 (length).
-	 * AUTH_RPCSEC_GSS verifier is:
-	 *   6 (AUTH_RPCSEC_GSS), length, checksum.
-	 * checksum is calculated over rpcheader from xid up to here.
-	 */
 	*authp = rpc_autherr_badverf;
 	switch (gc-&gt;gc_proc) {
 	case RPC_GSS_PROC_INIT:
 	case RPC_GSS_PROC_CONTINUE_INIT:
-		if (argv-&gt;iov_len &lt; 2 * 4)
-			goto auth_err;
-		if (svc_getnl(argv) != RPC_AUTH_NULL)
-			goto auth_err;
-		if (svc_getnl(argv) != 0)
-			goto auth_err;
-		break;
+		return svcauth_gss_handle_init(rqstp, gc, authp);
 	case RPC_GSS_PROC_DATA:
 	case RPC_GSS_PROC_DESTROY:
+		/* Look up the context, and check the verifier: */
 		*authp = rpcsec_gsserr_credproblem;
 		rsci = gss_svc_searchbyctx(&amp;gc-&gt;gc_ctx);
 		if (!rsci)
@@ -1067,51 +1122,6 @@ svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)
 
 	/* now act upon the command: */
 	switch (gc-&gt;gc_proc) {
-	case RPC_GSS_PROC_INIT:
-	case RPC_GSS_PROC_CONTINUE_INIT:
-		*authp = rpc_autherr_badcred;
-		if (gc-&gt;gc_proc == RPC_GSS_PROC_INIT &amp;&amp; gc-&gt;gc_ctx.len != 0)
-			goto auth_err;
-		memset(&amp;rsikey, 0, sizeof(rsikey));
-		if (dup_netobj(&amp;rsikey.in_handle, &amp;gc-&gt;gc_ctx))
-			goto drop;
-		*authp = rpc_autherr_badverf;
-		if (svc_safe_getnetobj(argv, &amp;tmpobj)) {
-			kfree(rsikey.in_handle.data);
-			goto auth_err;
-		}
-		if (dup_netobj(&amp;rsikey.in_token, &amp;tmpobj)) {
-			kfree(rsikey.in_handle.data);
-			goto drop;
-		}
-
-		rsip = rsi_lookup(&amp;rsikey);
-		rsi_free(&amp;rsikey);
-		if (!rsip) {
-			goto drop;
-		}
-		switch(cache_check(&amp;rsi_cache, &amp;rsip-&gt;h, &amp;rqstp-&gt;rq_chandle)) {
-		case -EAGAIN:
-		case -ETIMEDOUT:
-		case -ENOENT:
-			goto drop;
-		case 0:
-			if (gss_write_init_verf(rqstp, rsip))
-				goto drop;
-			if (resv-&gt;iov_len + 4 &gt; PAGE_SIZE)
-				goto drop;
-			svc_putnl(resv, RPC_SUCCESS);
-			if (svc_safe_putnetobj(resv, &amp;rsip-&gt;out_handle))
-				goto drop;
-			if (resv-&gt;iov_len + 3 * 4 &gt; PAGE_SIZE)
-				goto drop;
-			svc_putnl(resv, rsip-&gt;major_status);
-			svc_putnl(resv, rsip-&gt;minor_status);
-			svc_putnl(resv, GSS_SEQ_WIN);
-			if (svc_safe_putnetobj(resv, &amp;rsip-&gt;out_token))
-				goto drop;
-		}
-		goto complete;
 	case RPC_GSS_PROC_DESTROY:
 		if (gss_write_verf(rqstp, rsci-&gt;mechctx, gc-&gt;gc_seq))
 			goto auth_err;
@@ -1158,7 +1168,7 @@ svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)
 		goto out;
 	}
 auth_err:
-	/* Restore write pointer to original value: */
+	/* Restore write pointer to its original value: */
 	xdr_ressize_check(rqstp, reject_stat);
 	ret = SVC_DENIED;
 	goto out;</pre><hr><pre>commit c175b83c4c4be72535c5c12abc155e29a08323a0
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Aug 9 18:34:32 2007 -0400

    knfsd: remove code duplication in nfsd4_setclientid()
    
    Each branch of this if-then-else has a bunch of duplicated code that we
    could just put at the end.
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by: Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 09573b9f76c7..6256492b2363 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -774,13 +774,7 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		new = create_client(clname, dname);
 		if (new == NULL)
 			goto out;
-		copy_verf(new, &amp;clverifier);
-		new-&gt;cl_addr = sin-&gt;sin_addr.s_addr;
-		copy_cred(&amp;new-&gt;cl_cred,&amp;rqstp-&gt;rq_cred);
 		gen_clid(new);
-		gen_confirm(new);
-		gen_callback(new, setclid);
-		add_to_unconfirmed(new, strhashval);
 	} else if (same_verf(&amp;conf-&gt;cl_verifier, &amp;clverifier)) {
 		/*
 		 * CASE 1:
@@ -806,13 +800,7 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		new = create_client(clname, dname);
 		if (new == NULL)
 			goto out;
-		copy_verf(new,&amp;conf-&gt;cl_verifier);
-		new-&gt;cl_addr = sin-&gt;sin_addr.s_addr;
-		copy_cred(&amp;new-&gt;cl_cred,&amp;rqstp-&gt;rq_cred);
 		copy_clid(new, conf);
-		gen_confirm(new);
-		gen_callback(new, setclid);
-		add_to_unconfirmed(new,strhashval);
 	} else if (!unconf) {
 		/*
 		 * CASE 2:
@@ -825,13 +813,7 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		new = create_client(clname, dname);
 		if (new == NULL)
 			goto out;
-		copy_verf(new,&amp;clverifier);
-		new-&gt;cl_addr = sin-&gt;sin_addr.s_addr;
-		copy_cred(&amp;new-&gt;cl_cred,&amp;rqstp-&gt;rq_cred);
 		gen_clid(new);
-		gen_confirm(new);
-		gen_callback(new, setclid);
-		add_to_unconfirmed(new, strhashval);
 	} else if (!same_verf(&amp;conf-&gt;cl_confirm, &amp;unconf-&gt;cl_confirm)) {
 		/*	
 		 * CASE3:
@@ -852,19 +834,19 @@ nfsd4_setclientid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		new = create_client(clname, dname);
 		if (new == NULL)
 			goto out;
-		copy_verf(new,&amp;clverifier);
-		new-&gt;cl_addr = sin-&gt;sin_addr.s_addr;
-		copy_cred(&amp;new-&gt;cl_cred,&amp;rqstp-&gt;rq_cred);
 		gen_clid(new);
-		gen_confirm(new);
-		gen_callback(new, setclid);
-		add_to_unconfirmed(new, strhashval);
 	} else {
 		/* No cases hit !!! */
 		status = nfserr_inval;
 		goto out;
 
 	}
+	copy_verf(new, &amp;clverifier);
+	new-&gt;cl_addr = sin-&gt;sin_addr.s_addr;
+	copy_cred(&amp;new-&gt;cl_cred, &amp;rqstp-&gt;rq_cred);
+	gen_confirm(new);
+	gen_callback(new, setclid);
+	add_to_unconfirmed(new, strhashval);
 	setclid-&gt;se_clientid.cl_boot = new-&gt;cl_clientid.cl_boot;
 	setclid-&gt;se_clientid.cl_id = new-&gt;cl_clientid.cl_id;
 	memcpy(setclid-&gt;se_confirm.data, new-&gt;cl_confirm.data, sizeof(setclid-&gt;se_confirm.data));</pre><hr><pre>commit e8ff2a8453cedf38d6d7a0528cb9c308066a3e3e
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Aug 1 15:30:59 2007 -0400

    knfsd: move nfsv4 slab creation/destruction to module init/exit
    
    We have some slabs that the nfs4 server uses to store state objects.
    We're currently creating and destroying those slabs whenever the server
    is brought up or down.  That seems excessive; may as well just do that
    in module initialization and exit.
    
    Also add some minor header cleanup.  (Thanks to Andrew Morton for that
    and a compile fix.)
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Acked-by:  Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 2b20eb8589a0..09573b9f76c7 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1021,7 +1021,7 @@ nfsd4_free_slab(struct kmem_cache **slab)
 	*slab = NULL;
 }
 
-static void
+void
 nfsd4_free_slabs(void)
 {
 	nfsd4_free_slab(&amp;stateowner_slab);
@@ -3152,11 +3152,14 @@ nfs4_check_open_reclaim(clientid_t *clid)
 
 /* initialization to perform at module load time: */
 
-void
+int
 nfs4_state_init(void)
 {
-	int i;
+	int i, status;
 
+	status = nfsd4_init_slabs();
+	if (status)
+		return status;
 	for (i = 0; i &lt; CLIENT_HASH_SIZE; i++) {
 		INIT_LIST_HEAD(&amp;conf_id_hashtbl[i]);
 		INIT_LIST_HEAD(&amp;conf_str_hashtbl[i]);
@@ -3185,6 +3188,7 @@ nfs4_state_init(void)
 	for (i = 0; i &lt; CLIENT_HASH_SIZE; i++)
 		INIT_LIST_HEAD(&amp;reclaim_str_hashtbl[i]);
 	reclaim_str_hashtbl_size = 0;
+	return 0;
 }
 
 static void
@@ -3245,20 +3249,15 @@ __nfs4_state_start(void)
 	set_max_delegations();
 }
 
-int
+void
 nfs4_state_start(void)
 {
-	int status;
-
 	if (nfs4_init)
-		return 0;
-	status = nfsd4_init_slabs();
-	if (status)
-		return status;
+		return;
 	nfsd4_load_reboot_recovery_data();
 	__nfs4_state_start();
 	nfs4_init = 1;
-	return 0;
+	return;
 }
 
 int
@@ -3316,7 +3315,6 @@ nfs4_state_shutdown(void)
 	nfs4_lock_state();
 	nfs4_release_reclaim();
 	__nfs4_state_shutdown();
-	nfsd4_free_slabs();
 	nfs4_unlock_state();
 }
 
diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c
index baac89d917ca..d135f5f98519 100644
--- a/fs/nfsd/nfsctl.c
+++ b/fs/nfsd/nfsctl.c
@@ -679,11 +679,13 @@ static int __init init_nfsd(void)
 	int retval;
 	printk(KERN_INFO "Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\n");
 
+	retval = nfs4_state_init(); /* nfs4 locking state */
+	if (retval)
+		return retval;
 	nfsd_stat_init();	/* Statistics */
 	nfsd_cache_init();	/* RPC reply cache */
 	nfsd_export_init();	/* Exports table */
 	nfsd_lockd_init();	/* lockd-&gt;nfsd callbacks */
-	nfs4_state_init();	/* NFSv4 locking state */
 	nfsd_idmap_init();      /* Name to ID mapping */
 	if (proc_mkdir("fs/nfs", NULL)) {
 		struct proc_dir_entry *entry;
@@ -712,6 +714,7 @@ static void __exit exit_nfsd(void)
 	nfsd_stat_shutdown();
 	nfsd_lockd_shutdown();
 	nfsd_idmap_shutdown();
+	nfsd4_free_slabs();
 	unregister_filesystem(&amp;nfsd_fs_type);
 }
 
diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c
index ef46f3228330..1190aeaa92be 100644
--- a/fs/nfsd/nfssvc.c
+++ b/fs/nfsd/nfssvc.c
@@ -349,9 +349,7 @@ nfsd_svc(unsigned short port, int nrservs)
 	error =	nfsd_racache_init(2*nrservs);
 	if (error&lt;0)
 		goto out;
-	error = nfs4_state_start();
-	if (error&lt;0)
-		goto out;
+	nfs4_state_start();
 
 	nfsd_reset_versions();
 
diff --git a/include/linux/nfsd/nfsd.h b/include/linux/nfsd/nfsd.h
index e452256d3f72..604a0d786bc6 100644
--- a/include/linux/nfsd/nfsd.h
+++ b/include/linux/nfsd/nfsd.h
@@ -153,19 +153,21 @@ extern int nfsd_max_blksize;
  */
 #ifdef CONFIG_NFSD_V4
 extern unsigned int max_delegations;
-void nfs4_state_init(void);
-int nfs4_state_start(void);
+int nfs4_state_init(void);
+void nfsd4_free_slabs(void);
+void nfs4_state_start(void);
 void nfs4_state_shutdown(void);
 time_t nfs4_lease_time(void);
 void nfs4_reset_lease(time_t leasetime);
 int nfs4_reset_recoverydir(char *recdir);
 #else
-static inline void nfs4_state_init(void){};
-static inline int nfs4_state_start(void){return 0;}
-static inline void nfs4_state_shutdown(void){}
-static inline time_t nfs4_lease_time(void){return 0;}
-static inline void nfs4_reset_lease(time_t leasetime){}
-static inline int nfs4_reset_recoverydir(char *recdir) {return 0;}
+static inline int nfs4_state_init(void) { return 0; }
+static inline void nfsd4_free_slabs(void) { }
+static inline void nfs4_state_start(void) { }
+static inline void nfs4_state_shutdown(void) { }
+static inline time_t nfs4_lease_time(void) { return 0; }
+static inline void nfs4_reset_lease(time_t leasetime) { }
+static inline int nfs4_reset_recoverydir(char *recdir) { return 0; }
 #endif
 
 /*</pre><hr><pre>commit 2b47eece1fa519a81c8b802af77a8b8aa44baa10
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Jul 27 18:06:50 2007 -0400

    knfsd: spawn kernel thread to probe callback channel
    
    We want to allow gss on the callback channel, so people using krb5 can
    still get the benefits of delegations.
    
    But looking up the rpc credential can take some time in that case.  And
    we shouldn't delay the response to setclientid_confirm while we wait.
    
    It may be inefficient, but for now the simplest solution is just to
    spawn a new thread as necessary for the purpose.
    
    (Thanks to Adrian Bunk for catching a missing static here.)
    
    Signed-off-by: "J. Bruce Fields" &lt;bfields@citi.umich.edu&gt;
    Cc: Adrian Bunk &lt;bunk@kernel.org&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 31d6633c7fe4..c17a5202ee3f 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -39,6 +39,7 @@
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/sched.h&gt;
+#include &lt;linux/kthread.h&gt;
 #include &lt;linux/sunrpc/xdr.h&gt;
 #include &lt;linux/sunrpc/svc.h&gt;
 #include &lt;linux/sunrpc/clnt.h&gt;
@@ -365,6 +366,35 @@ nfsd4_lookupcred(struct nfs4_client *clp, int taskflags)
         return ret;
 }
 
+/* Reference counting, callback cleanup, etc., all look racy as heck.
+ * And why is cb_set an atomic? */
+
+static int do_probe_callback(void *data)
+{
+	struct nfs4_client *clp = data;
+	struct nfs4_callback *cb = &amp;clp-&gt;cl_callback;
+	struct rpc_message msg = {
+		.rpc_proc       = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL],
+		.rpc_argp       = clp,
+	};
+	int status;
+
+	msg.rpc_cred = nfsd4_lookupcred(clp, 0);
+	if (IS_ERR(msg.rpc_cred))
+		goto out;
+	status = rpc_call_sync(cb-&gt;cb_client, &amp;msg, RPC_TASK_SOFT);
+	put_rpccred(msg.rpc_cred);
+
+	if (status) {
+		rpc_shutdown_client(cb-&gt;cb_client);
+		cb-&gt;cb_client = NULL;
+	} else
+		atomic_set(&amp;cb-&gt;cb_set, 1);
+out:
+	put_nfs4_client(clp);
+	return 0;
+}
+
 /*
  * Set up the callback client and put a NFSPROC4_CB_NULL on the wire...
  */
@@ -390,11 +420,7 @@ nfsd4_probe_callback(struct nfs4_client *clp)
 		.authflavor	= RPC_AUTH_UNIX,	/* XXX: need AUTH_GSS... */
 		.flags		= (RPC_CLNT_CREATE_NOPING),
 	};
-	struct rpc_message msg = {
-		.rpc_proc       = &amp;nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL],
-		.rpc_argp       = clp,
-	};
-	int status;
+	struct task_struct *t;
 
 	if (atomic_read(&amp;cb-&gt;cb_set))
 		return;
@@ -426,16 +452,11 @@ nfsd4_probe_callback(struct nfs4_client *clp)
 	/* the task holds a reference to the nfs4_client struct */
 	atomic_inc(&amp;clp-&gt;cl_count);
 
-	msg.rpc_cred = nfsd4_lookupcred(clp,0);
-	if (IS_ERR(msg.rpc_cred))
-		goto out_release_clp;
-	status = rpc_call_async(cb-&gt;cb_client, &amp;msg, RPC_TASK_ASYNC, &amp;nfs4_cb_null_ops, NULL);
-	put_rpccred(msg.rpc_cred);
+	t = kthread_run(do_probe_callback, clp, "nfs4_cb_probe");
 
-	if (status != 0) {
-		dprintk("NFSD: asynchronous NFSPROC4_CB_NULL failed!\n");
+	if (IS_ERR(t))
 		goto out_release_clp;
-	}
+
 	return;
 
 out_release_clp:
@@ -447,30 +468,6 @@ nfsd4_probe_callback(struct nfs4_client *clp)
 		(int)clp-&gt;cl_name.len, clp-&gt;cl_name.data);
 }
 
-static void
-nfs4_cb_null(struct rpc_task *task, void *dummy)
-{
-	struct nfs4_client *clp = (struct nfs4_client *)task-&gt;tk_msg.rpc_argp;
-	struct nfs4_callback *cb = &amp;clp-&gt;cl_callback;
-	__be32 addr = htonl(cb-&gt;cb_addr);
-
-	dprintk("NFSD: nfs4_cb_null task-&gt;tk_status %d\n", task-&gt;tk_status);
-
-	if (task-&gt;tk_status &lt; 0) {
-		dprintk("NFSD: callback establishment to client %.*s failed\n",
-			(int)clp-&gt;cl_name.len, clp-&gt;cl_name.data);
-		goto out;
-	}
-	atomic_set(&amp;cb-&gt;cb_set, 1);
-	dprintk("NFSD: callback set to client %u.%u.%u.%u\n", NIPQUAD(addr));
-out:
-	put_nfs4_client(clp);
-}
-
-static const struct rpc_call_ops nfs4_cb_null_ops = {
-	.rpc_call_done = nfs4_cb_null,
-};
-
 /*
  * called with dp-&gt;dl_count inc'ed.
  * nfs4_lock_state() may or may not have been called.</pre>
    <div class="pagination">
        <a href='4_41.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><span>[42]</span><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_43.html'>Next&gt;&gt;</a>
    <div>
</body>
