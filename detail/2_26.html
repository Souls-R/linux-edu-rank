<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_25.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><span>[26]</span><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_27.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b9a6e8e1001e28fecbd74c073f5503dac2790563
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 09:48:01 2015 +0800

    usb: misc: usbtest: format the data pattern according to max packet size
    
    With this change, the host and gadget doesn't need to agree with transfer
    length for comparing the data, since they doesn't know each other's
    transfer size, but know max packet size.
    
    Signed-off-by: Peter Chen &lt;peter.chen@freescale.com&gt;
    Acked-by: Michal Nazarewicz &lt;mina86@mina86.com&gt;
    (Fixed the 'line over 80 characters warning' by Peter Chen)
    Tested-by: Peter Chen &lt;peter.chen@freescale.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index cac93b77f9a7..ad6dd4a1de6c 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -304,11 +304,20 @@ static unsigned mod_pattern;
 module_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(mod_pattern, "i/o pattern (0 == zeroes)");
 
-static inline void simple_fill_buf(struct urb *urb)
+static unsigned get_maxpacket(struct usb_device *udev, int pipe)
+{
+	struct usb_host_endpoint	*ep;
+
+	ep = usb_pipe_endpoint(udev, pipe);
+	return le16_to_cpup(&amp;ep-&gt;desc.wMaxPacketSize);
+}
+
+static void simple_fill_buf(struct urb *urb)
 {
 	unsigned	i;
 	u8		*buf = urb-&gt;transfer_buffer;
 	unsigned	len = urb-&gt;transfer_buffer_length;
+	unsigned	maxpacket;
 
 	switch (pattern) {
 	default:
@@ -317,8 +326,9 @@ static inline void simple_fill_buf(struct urb *urb)
 		memset(buf, 0, len);
 		break;
 	case 1:			/* mod63 */
+		maxpacket = get_maxpacket(urb-&gt;dev, urb-&gt;pipe);
 		for (i = 0; i &lt; len; i++)
-			*buf++ = (u8) (i % 63);
+			*buf++ = (u8) ((i % maxpacket) % 63);
 		break;
 	}
 }
@@ -350,6 +360,7 @@ static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 	u8		expected;
 	u8		*buf = urb-&gt;transfer_buffer;
 	unsigned	len = urb-&gt;actual_length;
+	unsigned	maxpacket = get_maxpacket(urb-&gt;dev, urb-&gt;pipe);
 
 	int ret = check_guard_bytes(tdev, urb);
 	if (ret)
@@ -367,7 +378,7 @@ static int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)
 		 * with set_interface or set_config.
 		 */
 		case 1:			/* mod63 */
-			expected = i % 63;
+			expected = (i % maxpacket) % 63;
 			break;
 		/* always fail unsupported patterns */
 		default:
@@ -479,11 +490,13 @@ static void free_sglist(struct scatterlist *sg, int nents)
 }
 
 static struct scatterlist *
-alloc_sglist(int nents, int max, int vary)
+alloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)
 {
 	struct scatterlist	*sg;
 	unsigned		i;
 	unsigned		size = max;
+	unsigned		maxpacket =
+		get_maxpacket(interface_to_usbdev(dev-&gt;intf), pipe);
 
 	if (max == 0)
 		return NULL;
@@ -512,7 +525,7 @@ alloc_sglist(int nents, int max, int vary)
 			break;
 		case 1:
 			for (j = 0; j &lt; size; j++)
-				*buf++ = (u8) (j % 63);
+				*buf++ = (u8) ((j % maxpacket) % 63);
 			break;
 		}
 
@@ -2176,7 +2189,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 5:  write %d sglists %d entries of %d bytes\n",
 				param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, 0);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				0, dev, dev-&gt;out_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2194,7 +2208,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 6:  read %d sglists %d entries of %d bytes\n",
 				param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, 0);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				0, dev, dev-&gt;in_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2211,7 +2226,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\n",
 				param-&gt;vary, param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, param-&gt;vary);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				param-&gt;vary, dev, dev-&gt;out_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;
@@ -2228,7 +2244,8 @@ usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)
 			"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\n",
 				param-&gt;vary, param-&gt;iterations,
 				param-&gt;sglen, param-&gt;length);
-		sg = alloc_sglist(param-&gt;sglen, param-&gt;length, param-&gt;vary);
+		sg = alloc_sglist(param-&gt;sglen, param-&gt;length,
+				param-&gt;vary, dev, dev-&gt;in_pipe);
 		if (!sg) {
 			retval = -ENOMEM;
 			break;</pre><hr><pre>commit 49718f0fb8c9af192b33d8af3a2826db04025371
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 17 11:02:42 2015 -0400

    SCSI: Fix NULL pointer dereference in runtime PM
    
    The routines in scsi_rpm.c assume that if a runtime-PM callback is
    invoked for a SCSI device, it can only mean that the device's driver
    has asked the block layer to handle the runtime power management (by
    calling blk_pm_runtime_init(), which among other things sets q-&gt;dev).
    
    However, this assumption turns out to be wrong for things like the ses
    driver.  Normally ses devices are not allowed to do runtime PM, but
    userspace can override this setting.  If this happens, the kernel gets
    a NULL pointer dereference when blk_post_runtime_resume() tries to use
    the uninitialized q-&gt;dev pointer.
    
    This patch fixes the problem by calling the block layer's runtime-PM
    routines only if the device's driver really does have a runtime-PM
    callback routine.  Since ses doesn't define any such callbacks, the
    crash won't occur.
    
    This fixes Bugzilla #101371.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Stanisław Pitucha &lt;viraptor@gmail.com&gt;
    Reported-by: Ilan Cohen &lt;ilanco@gmail.com&gt;
    Tested-by: Ilan Cohen &lt;ilanco@gmail.com&gt;
    Reviewed-by: Johannes Thumshirn &lt;jthumshirn@suse.de&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: James Bottomley &lt;JBottomley@Odin.com&gt;

diff --git a/drivers/scsi/scsi_pm.c b/drivers/scsi/scsi_pm.c
index 9e43ae1d2163..e4b799837948 100644
--- a/drivers/scsi/scsi_pm.c
+++ b/drivers/scsi/scsi_pm.c
@@ -217,15 +217,15 @@ static int sdev_runtime_suspend(struct device *dev)
 {
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	struct scsi_device *sdev = to_scsi_device(dev);
-	int err;
+	int err = 0;
 
-	err = blk_pre_runtime_suspend(sdev-&gt;request_queue);
-	if (err)
-		return err;
-	if (pm &amp;&amp; pm-&gt;runtime_suspend)
+	if (pm &amp;&amp; pm-&gt;runtime_suspend) {
+		err = blk_pre_runtime_suspend(sdev-&gt;request_queue);
+		if (err)
+			return err;
 		err = pm-&gt;runtime_suspend(dev);
-	blk_post_runtime_suspend(sdev-&gt;request_queue, err);
-
+		blk_post_runtime_suspend(sdev-&gt;request_queue, err);
+	}
 	return err;
 }
 
@@ -248,11 +248,11 @@ static int sdev_runtime_resume(struct device *dev)
 	const struct dev_pm_ops *pm = dev-&gt;driver ? dev-&gt;driver-&gt;pm : NULL;
 	int err = 0;
 
-	blk_pre_runtime_resume(sdev-&gt;request_queue);
-	if (pm &amp;&amp; pm-&gt;runtime_resume)
+	if (pm &amp;&amp; pm-&gt;runtime_resume) {
+		blk_pre_runtime_resume(sdev-&gt;request_queue);
 		err = pm-&gt;runtime_resume(dev);
-	blk_post_runtime_resume(sdev-&gt;request_queue, err);
-
+		blk_post_runtime_resume(sdev-&gt;request_queue, err);
+	}
 	return err;
 }
 </pre><hr><pre>commit c93e64e91248becd0edb8f01723dff9da890e2ab
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 16 11:32:51 2015 -0500

    usb: udc: core: add device_del() call to error pathway
    
    This patch fixes a bug in the error pathway of
    usb_add_gadget_udc_release() in udc-core.c.  If the udc registration
    fails, the gadget registration is not fully undone; there's a
    put_device(&amp;gadget-&gt;dev) call but no device_del().
    
    CC: &lt;stable@vger.kernel.org&gt;
    Acked-by: Peter Chen &lt;peter.chen@freescale.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc/udc-core.c b/drivers/usb/gadget/udc/udc-core.c
index 362ee8af5fce..89ed5e71a199 100644
--- a/drivers/usb/gadget/udc/udc-core.c
+++ b/drivers/usb/gadget/udc/udc-core.c
@@ -323,6 +323,7 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 
 err3:
 	put_device(&amp;udc-&gt;dev);
+	device_del(&amp;gadget-&gt;dev);
 
 err2:
 	put_device(&amp;gadget-&gt;dev);</pre><hr><pre>commit 1209544d8a2a6084f58625ca66f5cd77580df53f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 8 12:14:56 2015 -0400

    USB: OHCI: fix bad #define in ohci-tmio.c
    
    An incorrect definition of CCR_PM_USBPW3 in ohci-tmio.c is a perennial
    source of invalid diagnoses from static scanners, such as in
    &lt;http://marc.info/?l=linux-usb&amp;m=143634574527641&amp;w=2&gt;.  This patch
    fixes the definition.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: David Binderman &lt;dcb314@hotmail.com&gt;
    CC: Dmitry Eremin-Solenikov &lt;dbaryshkov@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-tmio.c b/drivers/usb/host/ohci-tmio.c
index e9a6eec39142..cfcfadfc94fc 100644
--- a/drivers/usb/host/ohci-tmio.c
+++ b/drivers/usb/host/ohci-tmio.c
@@ -58,7 +58,7 @@
 #define CCR_PM_CKRNEN    0x0002
 #define CCR_PM_USBPW1    0x0004
 #define CCR_PM_USBPW2    0x0008
-#define CCR_PM_USBPW3    0x0008
+#define CCR_PM_USBPW3    0x0010
 #define CCR_PM_PMEE      0x0100
 #define CCR_PM_PMES      0x8000
 </pre><hr><pre>commit 7d8021c967648accd1b78e5e1ddaad655cd2c61f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 30 11:25:54 2015 -0400

    USB: OHCI: Fix race between ED unlink and URB submission
    
    This patch fixes a bug introduced by commit 977dcfdc6031 ("USB: OHCI:
    don't lose track of EDs when a controller dies").  The commit changed
    ed_state from ED_UNLINK to ED_IDLE too early, before finish_urb() had
    been called.  The user-visible consequence is that the driver
    occasionally crashes or locks up when an URB is submitted while
    another URB for the same endpoint is being unlinked.
    
    This patch moves the ED state change later, to the right place.  The
    drawback is that now we may unnecessarily execute some instructions
    multiple times when a controller dies.  Since controllers dying is an
    exceptional occurrence, a little wasted time won't matter.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Heiko Przybyl &lt;lil_tux@web.de&gt;
    Tested-by: Heiko Przybyl &lt;lil_tux@web.de&gt;
    Fixes: 977dcfdc60311e7aa571cabf6f39c36dde13339e
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
index f7d561ed3c23..d029bbe9eb36 100644
--- a/drivers/usb/host/ohci-q.c
+++ b/drivers/usb/host/ohci-q.c
@@ -981,10 +981,6 @@ static void finish_unlinks(struct ohci_hcd *ohci)
 		int			completed, modified;
 		__hc32			*prev;
 
-		/* Is this ED already invisible to the hardware? */
-		if (ed-&gt;state == ED_IDLE)
-			goto ed_idle;
-
 		/* only take off EDs that the HC isn't using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
@@ -1012,12 +1008,10 @@ static void finish_unlinks(struct ohci_hcd *ohci)
 		}
 
 		/* ED's now officially unlinked, hc doesn't see */
-		ed-&gt;state = ED_IDLE;
 		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
 		ed-&gt;hwNextED = 0;
 		wmb();
 		ed-&gt;hwINFO &amp;= ~cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE);
-ed_idle:
 
 		/* reentrancy:  if we drop the schedule lock, someone might
 		 * have modified this list.  normally it's just prepending
@@ -1088,6 +1082,7 @@ static void finish_unlinks(struct ohci_hcd *ohci)
 		if (list_empty(&amp;ed-&gt;td_list)) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
+			ed-&gt;state = ED_IDLE;
 			list_del(&amp;ed-&gt;in_use_list);
 		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 			*last = ed-&gt;ed_next;</pre><hr><pre>commit 019d8817b1b064c2bacfbcf40fc68184438ad05a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 15 14:40:06 2015 +0200

    PM / sleep: Allow devices without runtime PM to do direct-complete
    
    Don't unset the direct_complete flag on devices that have runtime PM
    disabled, if they are runtime suspended.
    
    This is needed because otherwise ancestor devices wouldn't be able to
    do direct_complete without adding runtime PM support to all its
    descendants.
    
    Also removes pm_runtime_suspended_if_enabled() because it's now unused.
    
    Signed-off-by: Tomeu Vizoso &lt;tomeu.vizoso@collabora.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;

diff --git a/Documentation/power/devices.txt b/Documentation/power/devices.txt
index d172bce0fd49..8ba6625fdd63 100644
--- a/Documentation/power/devices.txt
+++ b/Documentation/power/devices.txt
@@ -341,6 +341,13 @@ the phases are:
 	and is entirely responsible for bringing the device back to the
 	functional state as appropriate.
 
+	Note that this direct-complete procedure applies even if the device is
+	disabled for runtime PM; only the runtime-PM status matters.  It follows
+	that if a device has system-sleep callbacks but does not support runtime
+	PM, then its prepare callback must never return a positive value.  This
+	is because all devices are initially set to runtime-suspended with
+	runtime PM disabled.
+
     2.	The suspend methods should quiesce the device to stop it from performing
 	I/O.  They also may save the device registers and put it into the
 	appropriate low-power state, depending on the bus type the device is on,
diff --git a/Documentation/power/runtime_pm.txt b/Documentation/power/runtime_pm.txt
index e76dc0ad4d2b..0784bc3a2ab5 100644
--- a/Documentation/power/runtime_pm.txt
+++ b/Documentation/power/runtime_pm.txt
@@ -445,10 +445,6 @@ drivers/base/power/runtime.c and include/linux/pm_runtime.h:
   bool pm_runtime_status_suspended(struct device *dev);
     - return true if the device's runtime PM status is 'suspended'
 
-  bool pm_runtime_suspended_if_enabled(struct device *dev);
-    - return true if the device's runtime PM status is 'suspended' and its
-      'power.disable_depth' field is equal to 1
-
   void pm_runtime_allow(struct device *dev);
     - set the power.runtime_auto flag for the device and decrease its usage
       counter (used by the /sys/devices/.../power/control interface to
diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 30b7bbfdc558..1710c26ba097 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -1377,7 +1377,7 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	if (dev-&gt;power.direct_complete) {
 		if (pm_runtime_status_suspended(dev)) {
 			pm_runtime_disable(dev);
-			if (pm_runtime_suspended_if_enabled(dev))
+			if (pm_runtime_status_suspended(dev))
 				goto Complete;
 
 			pm_runtime_enable(dev);
diff --git a/include/linux/pm_runtime.h b/include/linux/pm_runtime.h
index 30e84d48bfea..3bdbb4189780 100644
--- a/include/linux/pm_runtime.h
+++ b/include/linux/pm_runtime.h
@@ -98,11 +98,6 @@ static inline bool pm_runtime_status_suspended(struct device *dev)
 	return dev-&gt;power.runtime_status == RPM_SUSPENDED;
 }
 
-static inline bool pm_runtime_suspended_if_enabled(struct device *dev)
-{
-	return pm_runtime_status_suspended(dev) &amp;&amp; dev-&gt;power.disable_depth == 1;
-}
-
 static inline bool pm_runtime_enabled(struct device *dev)
 {
 	return !dev-&gt;power.disable_depth;
@@ -164,7 +159,6 @@ static inline void device_set_run_wake(struct device *dev, bool enable) {}
 static inline bool pm_runtime_suspended(struct device *dev) { return false; }
 static inline bool pm_runtime_active(struct device *dev) { return true; }
 static inline bool pm_runtime_status_suspended(struct device *dev) { return false; }
-static inline bool pm_runtime_suspended_if_enabled(struct device *dev) { return false; }
 static inline bool pm_runtime_enabled(struct device *dev) { return false; }
 
 static inline void pm_runtime_no_callbacks(struct device *dev) {}</pre><hr><pre>commit 3091fa77ffb1b91f4ac3ae005efe6213508f7ec1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Apr 22 12:11:59 2015 -0400

    USB: don't build PCI quirks if USB support isn't configured
    
    The USB PCI quirks code gets built into the kernel whenever CONFIG_PCI
    is enabled, even if CONFIG_USB is not set.  This can cause unnecessary
    messages to show up in the kernel log, such as "CONFIG_USB_XHCI_HCD is
    turned off, defaulting to EHCI" (which makes no sense when the kernel
    has been configured without host-side USB support).
    
    This patch addresses the problem by building pci-quirks.o only when
    CONFIG_PCI and CONFIG_USB are both enabled.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Toralf Förster &lt;toralf.foerster@gmx.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
index 65b0b6a58599..972a74a6f428 100644
--- a/drivers/usb/host/Makefile
+++ b/drivers/usb/host/Makefile
@@ -24,7 +24,9 @@ endif
 
 obj-$(CONFIG_USB_WHCI_HCD)	+= whci/
 
-obj-$(CONFIG_PCI)		+= pci-quirks.o
+ifneq ($(CONFIG_USB), )
+	obj-$(CONFIG_PCI)	+= pci-quirks.o
+endif
 
 obj-$(CONFIG_USB_XHCI_PCI)	+= xhci-pci.o
 obj-$(CONFIG_USB_XHCI_PLATFORM) += xhci-plat-hcd.o</pre><hr><pre>commit 96b62a57193494010eed66ca0739c93eb4653162
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 4 10:31:50 2015 -0500

    gadgetfs: really get rid of switching -&gt;f_op
    
    ... for ep0 as well
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;

diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c
index c0e25320a3c4..200f9a584064 100644
--- a/drivers/usb/gadget/legacy/inode.c
+++ b/drivers/usb/gadget/legacy/inode.c
@@ -909,6 +909,10 @@ ep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)
 	enum ep0_state			state;
 
 	spin_lock_irq (&amp;dev-&gt;lock);
+	if (dev-&gt;state &lt;= STATE_DEV_OPENED) {
+		retval = -EINVAL;
+		goto done;
+	}
 
 	/* report fd mode change before acting on it */
 	if (dev-&gt;setup_abort) {
@@ -1107,8 +1111,6 @@ ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	struct dev_data		*dev = fd-&gt;private_data;
 	ssize_t			retval = -ESRCH;
 
-	spin_lock_irq (&amp;dev-&gt;lock);
-
 	/* report fd mode change before acting on it */
 	if (dev-&gt;setup_abort) {
 		dev-&gt;setup_abort = 0;
@@ -1154,7 +1156,6 @@ ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	} else
 		DBG (dev, "fail %s, state %d\n", __func__, dev-&gt;state);
 
-	spin_unlock_irq (&amp;dev-&gt;lock);
 	return retval;
 }
 
@@ -1201,6 +1202,9 @@ ep0_poll (struct file *fd, poll_table *wait)
        struct dev_data         *dev = fd-&gt;private_data;
        int                     mask = 0;
 
+	if (dev-&gt;state &lt;= STATE_DEV_OPENED)
+		return DEFAULT_POLLMASK;
+
        poll_wait(fd, &amp;dev-&gt;wait, wait);
 
        spin_lock_irq (&amp;dev-&gt;lock);
@@ -1236,19 +1240,6 @@ static long dev_ioctl (struct file *fd, unsigned code, unsigned long value)
 	return ret;
 }
 
-/* used after device configuration */
-static const struct file_operations ep0_io_operations = {
-	.owner =	THIS_MODULE,
-	.llseek =	no_llseek,
-
-	.read =		ep0_read,
-	.write =	ep0_write,
-	.fasync =	ep0_fasync,
-	.poll =		ep0_poll,
-	.unlocked_ioctl =	dev_ioctl,
-	.release =	dev_release,
-};
-
 /*----------------------------------------------------------------------*/
 
 /* The in-kernel gadget driver handles most ep0 issues, in particular
@@ -1772,6 +1763,14 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 	u32			tag;
 	char			*kbuf;
 
+	spin_lock_irq(&amp;dev-&gt;lock);
+	if (dev-&gt;state &gt; STATE_DEV_OPENED) {
+		value = ep0_write(fd, buf, len, ptr);
+		spin_unlock_irq(&amp;dev-&gt;lock);
+		return value;
+	}
+	spin_unlock_irq(&amp;dev-&gt;lock);
+
 	if (len &lt; (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4))
 		return -EINVAL;
 
@@ -1845,7 +1844,6 @@ dev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 		 * on, they can work ... except in cleanup paths that
 		 * kick in after the ep0 descriptor is closed.
 		 */
-		fd-&gt;f_op = &amp;ep0_io_operations;
 		value = len;
 	}
 	return value;
@@ -1876,12 +1874,14 @@ dev_open (struct inode *inode, struct file *fd)
 	return value;
 }
 
-static const struct file_operations dev_init_operations = {
+static const struct file_operations ep0_operations = {
 	.llseek =	no_llseek,
 
 	.open =		dev_open,
+	.read =		ep0_read,
 	.write =	dev_config,
 	.fasync =	ep0_fasync,
+	.poll =		ep0_poll,
 	.unlocked_ioctl = dev_ioctl,
 	.release =	dev_release,
 };
@@ -1997,7 +1997,7 @@ gadgetfs_fill_super (struct super_block *sb, void *opts, int silent)
 		goto Enomem;
 
 	dev-&gt;sb = sb;
-	dev-&gt;dentry = gadgetfs_create_file(sb, CHIP, dev, &amp;dev_init_operations);
+	dev-&gt;dentry = gadgetfs_create_file(sb, CHIP, dev, &amp;ep0_operations);
 	if (!dev-&gt;dentry) {
 		put_dev(dev);
 		goto Enomem;</pre><hr><pre>commit f0c2b68198589249afd2b1f2c4e8de8c03e19c16
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 13 10:54:53 2015 -0500

    USB: usbfs: don't leak kernel data in siginfo
    
    When a signal is delivered, the information in the siginfo structure
    is copied to userspace.  Good security practice dicatates that the
    unused fields in this structure should be initialized to 0 so that
    random kernel stack data isn't exposed to the user.  This patch adds
    such an initialization to the two places where usbfs raises signals.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Dave Mielke &lt;dave@mielke.cc&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 66abdbcfbfa5..11635537c052 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -501,6 +501,7 @@ static void async_completed(struct urb *urb)
 	as-&gt;status = urb-&gt;status;
 	signr = as-&gt;signr;
 	if (signr) {
+		memset(&amp;sinfo, 0, sizeof(sinfo));
 		sinfo.si_signo = as-&gt;signr;
 		sinfo.si_errno = as-&gt;status;
 		sinfo.si_code = SI_ASYNCIO;
@@ -2382,6 +2383,7 @@ static void usbdev_remove(struct usb_device *udev)
 		wake_up_all(&amp;ps-&gt;wait);
 		list_del_init(&amp;ps-&gt;list);
 		if (ps-&gt;discsignr) {
+			memset(&amp;sinfo, 0, sizeof(sinfo));
 			sinfo.si_signo = ps-&gt;discsignr;
 			sinfo.si_errno = EPIPE;
 			sinfo.si_code = SI_ASYNCIO;</pre><hr><pre>commit c99197902da284b4b723451c1471c45b18537cde
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 30 12:58:26 2015 -0500

    USB: fix use-after-free bug in usb_hcd_unlink_urb()
    
    The usb_hcd_unlink_urb() routine in hcd.c contains two possible
    use-after-free errors.  The dev_dbg() statement at the end of the
    routine dereferences urb and urb-&gt;dev even though both structures may
    have been deallocated.
    
    This patch fixes the problem by storing urb-&gt;dev in a local variable
    (avoiding the dereference of urb) and moving the dev_dbg() up before
    the usb_put_dev() call.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Joe Lawrence &lt;joe.lawrence@stratus.com&gt;
    Tested-by: Joe Lawrence &lt;joe.lawrence@stratus.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;greg@kroah.com&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 11cee55ae397..45a915ccd71c 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1618,6 +1618,7 @@ static int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
 	struct usb_hcd		*hcd;
+	struct usb_device	*udev = urb-&gt;dev;
 	int			retval = -EIDRM;
 	unsigned long		flags;
 
@@ -1629,20 +1630,19 @@ int usb_hcd_unlink_urb (struct urb *urb, int status)
 	spin_lock_irqsave(&amp;hcd_urb_unlink_lock, flags);
 	if (atomic_read(&amp;urb-&gt;use_count) &gt; 0) {
 		retval = 0;
-		usb_get_dev(urb-&gt;dev);
+		usb_get_dev(udev);
 	}
 	spin_unlock_irqrestore(&amp;hcd_urb_unlink_lock, flags);
 	if (retval == 0) {
 		hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
 		retval = unlink1(hcd, urb, status);
-		usb_put_dev(urb-&gt;dev);
+		if (retval == 0)
+			retval = -EINPROGRESS;
+		else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)
+			dev_dbg(&amp;udev-&gt;dev, "hcd_unlink_urb %p fail %d\n",
+					urb, retval);
+		usb_put_dev(udev);
 	}
-
-	if (retval == 0)
-		retval = -EINPROGRESS;
-	else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)
-		dev_dbg(&amp;urb-&gt;dev-&gt;dev, "hcd_unlink_urb %p fail %d\n",
-				urb, retval);
 	return retval;
 }
 </pre>
    <div class="pagination">
        <a href='2_25.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><span>[26]</span><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_27.html'>Next&gt;&gt;</a>
    <div>
</body>
