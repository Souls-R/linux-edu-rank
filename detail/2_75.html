<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_74.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><span>[75]</span><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_76.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7bd032dc2793afcbaf4a350056768da84cdbd89b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 4 15:29:59 2009 -0400

    USB serial: update the console driver
    
    This patch (as1292) modifies the USB serial console driver, to make it
    compatible with the recent changes to the USB serial core.  The most
    important change is that serial-&gt;disc_mutex now has to be unlocked
    following a successful call to usb_serial_get_by_index().
    
    Other less notable changes include:
    
            Use the requested port number instead of port 0 always.
    
            Prevent the serial device from being autosuspended.
    
            Use the ASYNCB_INITIALIZED flag bit to indicate when the
            port hardware has been initialized.
    
    In spite of these changes, there's no question that the USB serial
    console code is still a big hack.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/console.c b/drivers/usb/serial/console.c
index be086e4c76b6..b22ac3258523 100644
--- a/drivers/usb/serial/console.c
+++ b/drivers/usb/serial/console.c
@@ -16,6 +16,7 @@
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/tty.h&gt;
 #include &lt;linux/console.h&gt;
+#include &lt;linux/serial.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/serial.h&gt;
 
@@ -63,7 +64,7 @@ static int usb_console_setup(struct console *co, char *options)
 	char *s;
 	struct usb_serial *serial;
 	struct usb_serial_port *port;
-	int retval = 0;
+	int retval;
 	struct tty_struct *tty = NULL;
 	struct ktermios *termios = NULL, dummy;
 
@@ -116,13 +117,17 @@ static int usb_console_setup(struct console *co, char *options)
 		return -ENODEV;
 	}
 
-	port = serial-&gt;port[0];
+	retval = usb_autopm_get_interface(serial-&gt;interface);
+	if (retval)
+		goto error_get_interface;
+
+	port = serial-&gt;port[co-&gt;index - serial-&gt;minor];
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
 
 	info-&gt;port = port;
 
 	++port-&gt;port.count;
-	if (port-&gt;port.count == 1) {
+	if (!test_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags)) {
 		if (serial-&gt;type-&gt;set_termios) {
 			/*
 			 * allocate a fake tty so the driver can initialize
@@ -168,6 +173,7 @@ static int usb_console_setup(struct console *co, char *options)
 			kfree(termios);
 			kfree(tty);
 		}
+		set_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags);
 	}
 	/* Now that any required fake tty operations are completed restore
 	 * the tty port count */
@@ -175,18 +181,22 @@ static int usb_console_setup(struct console *co, char *options)
 	/* The console is special in terms of closing the device so
 	 * indicate this port is now acting as a system console. */
 	port-&gt;console = 1;
-	retval = 0;
 
-out:
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
 	return retval;
-free_termios:
+
+ free_termios:
 	kfree(termios);
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
-free_tty:
+ free_tty:
 	kfree(tty);
-reset_open_count:
+ reset_open_count:
 	port-&gt;port.count = 0;
-	goto out;
+	usb_autopm_put_interface(serial-&gt;interface);
+ error_get_interface:
+	usb_serial_put(serial);
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
+	return retval;
 }
 
 static void usb_console_write(struct console *co,</pre><hr><pre>commit 320348c8d5c9b591282633ddb8959b42f7fc7a1c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:59 2009 -0400

    usb-serial: straighten out serial_open
    
    This patch (as1291) removes a bunch of code from serial_open(), things
    that were rendered unnecessary by earlier patches.  A missing spinlock
    is added to protect port-&gt;port.count, which needs to be incremented
    even if the open fails but not if the tty has gotten a hangup.  The
    test for whether the hardware has been initialized, based on the use
    count, is replaced by a more transparent test of the
    ASYNCB_INITIALIZED bit in the port flags.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 9a3258046c8c..9d7ca4868d37 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -245,55 +245,40 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	return retval;
 }
 
-static int serial_open (struct tty_struct *tty, struct file *filp)
+static int serial_open(struct tty_struct *tty, struct file *filp)
 {
-	struct usb_serial *serial;
-	struct usb_serial_port *port;
-	int retval = 0;
-	int first = 0;
-
-	port = tty-&gt;driver_data;
-	serial = port-&gt;serial;
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_serial *serial = port-&gt;serial;
+	int retval;
 
 	dbg("%s - port %d", __func__, port-&gt;number);
 
-	if (mutex_lock_interruptible(&amp;port-&gt;mutex))
-		return -ERESTARTSYS;
-
-	++port-&gt;port.count;
+	spin_lock_irq(&amp;port-&gt;port.lock);
+	if (!tty_hung_up_p(filp))
+		++port-&gt;port.count;
+	spin_unlock_irq(&amp;port-&gt;port.lock);
 	tty_port_tty_set(&amp;port-&gt;port, tty);
 
-	/* If the console is attached, the device is already open */
-	if (port-&gt;port.count == 1 &amp;&amp; !port-&gt;console) {
-		first = 1;
+	/* Do the device-specific open only if the hardware isn't
+	 * already initialized.
+	 */
+	if (!test_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags)) {
+		if (mutex_lock_interruptible(&amp;port-&gt;mutex))
+			return -ERESTARTSYS;
 		mutex_lock(&amp;serial-&gt;disc_mutex);
-
-		/* only call the device specific open if this
-		 * is the first time the port is opened */
-		retval = serial-&gt;type-&gt;open(tty, port);
-		if (retval)
-			goto bailout_module_put;
+		if (serial-&gt;disconnected)
+			retval = -ENODEV;
+		else
+			retval = port-&gt;serial-&gt;type-&gt;open(tty, port);
 		mutex_unlock(&amp;serial-&gt;disc_mutex);
+		mutex_unlock(&amp;port-&gt;mutex);
+		if (retval)
+			return retval;
 		set_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags);
 	}
-	mutex_unlock(&amp;port-&gt;mutex);
+
 	/* Now do the correct tty layer semantics */
 	retval = tty_port_block_til_ready(&amp;port-&gt;port, tty, filp);
-	if (retval == 0) {
-		if (!first)
-			usb_serial_put(serial);
-		return 0;
-	}
-	mutex_lock(&amp;port-&gt;mutex);
-	if (first == 0)
-		goto bailout_mutex_unlock;
-	/* Undo the initial port actions */
-	mutex_lock(&amp;serial-&gt;disc_mutex);
-bailout_module_put:
-	mutex_unlock(&amp;serial-&gt;disc_mutex);
-bailout_mutex_unlock:
-	port-&gt;port.count = 0;
-	mutex_unlock(&amp;port-&gt;mutex);
 	return retval;
 }
 </pre><hr><pre>commit ff8324df1187b7280e507c976777df76c73a1ef1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:51 2009 -0400

    usb-serial: add missing tests and debug lines
    
    This patch (as1290) adds some missing tests.  serial_down() isn't
    supposed to do anything if the hardware hasn't been initialized, and
    serial_close() isn't supposed to do anything if the tty has gotten a
    hangup (because serial_hangup() takes care of shutting down the
    hardware).
    
    The patch also updates and adds a few debugging lines.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 28125de7d902..9a3258046c8c 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -200,6 +200,8 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	struct usb_serial_port *port;
 	int retval = -ENODEV;
 
+	dbg("%s", __func__);
+
 	serial = usb_serial_get_by_index(idx);
 	if (!serial)
 		return retval;
@@ -250,11 +252,11 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 	int retval = 0;
 	int first = 0;
 
-	dbg("%s", __func__);
-
 	port = tty-&gt;driver_data;
 	serial = port-&gt;serial;
 
+	dbg("%s - port %d", __func__, port-&gt;number);
+
 	if (mutex_lock_interruptible(&amp;port-&gt;mutex))
 		return -ERESTARTSYS;
 
@@ -315,6 +317,12 @@ static void serial_down(struct usb_serial_port *port)
 	if (port-&gt;console)
 		return;
 
+	/* Don't call the close method if the hardware hasn't been
+	 * initialized.
+	 */
+	if (!test_and_clear_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags))
+		return;
+
 	mutex_lock(&amp;port-&gt;mutex);
 	serial = port-&gt;serial;
 	owner = serial-&gt;type-&gt;driver.owner;
@@ -328,10 +336,11 @@ static void serial_down(struct usb_serial_port *port)
 static void serial_hangup(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
+
+	dbg("%s - port %d", __func__, port-&gt;number);
+
 	serial_down(port);
 	tty_port_hangup(&amp;port-&gt;port);
-	/* We must not free port yet - the USB serial layer depends on it's
-	   continued existence */
 }
 
 static void serial_close(struct tty_struct *tty, struct file *filp)
@@ -340,6 +349,8 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 
 	dbg("%s - port %d", __func__, port-&gt;number);
 
+	if (tty_hung_up_p(filp))
+		return;
 	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
 		return;
 	serial_down(port);
@@ -368,6 +379,8 @@ static void serial_release(struct tty_struct *tty)
 	if (port-&gt;console)
 		return;
 
+	dbg("%s - port %d", __func__, port-&gt;number);
+
 	/* Standard shutdown processing */
 	tty_shutdown(tty);
 </pre><hr><pre>commit 74556123e034c8337b69a3ebac2f3a5fc0a97032
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:40 2009 -0400

    usb-serial: rename subroutines
    
    This patch (as1289) renames serial_do_down() to serial_down() and
    serial_do_free() to serial_release().  It also adds a missing call to
    tty_shutdown() in serial_release().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 1bc0a24b896b..28125de7d902 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -191,7 +191,7 @@ void usb_serial_put(struct usb_serial *serial)
  * This is the first place a new tty gets used.  Hence this is where we
  * acquire references to the usb_serial structure and the driver module,
  * where we store a pointer to the port, and where we do an autoresume.
- * All these actions are reversed in serial_do_free().
+ * All these actions are reversed in serial_release().
  */
 static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 {
@@ -296,13 +296,13 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 }
 
 /**
- * serial_do_down - shut down hardware
+ * serial_down - shut down hardware
  * @port: port to shut down
  *
  * Shut down a USB serial port unless it is the console.  We never
  * shut down the console hardware as it will always be in use.
  */
-static void serial_do_down(struct usb_serial_port *port)
+static void serial_down(struct usb_serial_port *port)
 {
 	struct usb_serial_driver *drv = port-&gt;serial-&gt;type;
 	struct usb_serial *serial;
@@ -328,7 +328,7 @@ static void serial_do_down(struct usb_serial_port *port)
 static void serial_hangup(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
-	serial_do_down(port);
+	serial_down(port);
 	tty_port_hangup(&amp;port-&gt;port);
 	/* We must not free port yet - the USB serial layer depends on it's
 	   continued existence */
@@ -342,13 +342,13 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 
 	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
 		return;
-	serial_do_down(port);
+	serial_down(port);
 	tty_port_close_end(&amp;port-&gt;port, tty);
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
 }
 
 /**
- * serial_do_free - free resources post close/hangup
+ * serial_release - free resources post close/hangup
  * @port: port to free up
  *
  * Do the resource freeing and refcount dropping for the port.
@@ -356,7 +356,7 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
  *
  * Called when the last tty kref is dropped.
  */
-static void serial_do_free(struct tty_struct *tty)
+static void serial_release(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
 	struct usb_serial *serial;
@@ -368,6 +368,9 @@ static void serial_do_free(struct tty_struct *tty)
 	if (port-&gt;console)
 		return;
 
+	/* Standard shutdown processing */
+	tty_shutdown(tty);
+
 	tty-&gt;driver_data = NULL;
 
 	serial = port-&gt;serial;
@@ -1204,7 +1207,7 @@ static const struct tty_operations serial_ops = {
 	.chars_in_buffer =	serial_chars_in_buffer,
 	.tiocmget =		serial_tiocmget,
 	.tiocmset =		serial_tiocmset,
-	.shutdown = 		serial_do_free,
+	.shutdown = 		serial_release,
 	.install = 		serial_install,
 	.proc_fops =		&amp;serial_proc_fops,
 };</pre><hr><pre>commit 7e29bb4b779f4f35385e6f21994758845bf14d23
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:22 2009 -0400

    usb-serial: fix termios initialization logic
    
    This patch (as1288) fixes the initialization logic in
    serial_install().  A new tty always needs to have a termios
    initialized no matter what, not just in the case where the lower
    driver will override the termios settings.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 7d207d91a6a8..1bc0a24b896b 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -210,22 +210,21 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	if (!try_module_get(serial-&gt;type-&gt;driver.owner))
 		goto error_module_get;
 
+	/* perform the standard setup */
+	retval = tty_init_termios(tty);
+	if (retval)
+		goto error_init_termios;
+
 	retval = usb_autopm_get_interface(serial-&gt;interface);
 	if (retval)
 		goto error_get_interface;
 
-	/* If the termios setup has yet to be done */
-	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
-		/* perform the standard setup */
-		retval = tty_init_termios(tty);
-		if (retval)
-			goto error_init_termios;
-		/* allow the driver to update it */
-		if (serial-&gt;type-&gt;init_termios)
-			serial-&gt;type-&gt;init_termios(tty);
-	}
 	mutex_unlock(&amp;serial-&gt;disc_mutex);
 
+	/* allow the driver to update the settings */
+	if (serial-&gt;type-&gt;init_termios)
+		serial-&gt;type-&gt;init_termios(tty);
+
 	tty-&gt;driver_data = port;
 
 	/* Final install (we use the default method) */
@@ -234,9 +233,8 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 	driver-&gt;ttys[idx] = tty;
 	return retval;
 
- error_init_termios:
-	usb_autopm_put_interface(serial-&gt;interface);
  error_get_interface:
+ error_init_termios:
 	module_put(serial-&gt;type-&gt;driver.owner);
  error_module_get:
  error_no_port:</pre><hr><pre>commit cc56cd0157753c04a987888a2f793803df661a40
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:39:13 2009 -0400

    usb-serial: acquire references when a new tty is installed
    
    This patch (as1287) makes serial_install() be reponsible for acquiring
    references to the usb_serial structure and the driver module when a
    tty is first used.  This is more sensible than having serial_open() do
    it, because a tty can be opened many times whereas it is installed
    only once, when it is created.  (Not to mention that these actions are
    reversed when the tty is released, not when it is closed.)  Finally,
    it is at install time that the TTY core takes its own reference to the
    usb_serial module, so it is only fitting that we should act the same
    way in regard to the lower-level serial driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 87802ea8bbc8..7d207d91a6a8 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -187,100 +187,92 @@ void usb_serial_put(struct usb_serial *serial)
  * Create the termios objects for this tty.  We use the default
  * USB serial settings but permit them to be overridden by
  * serial-&gt;type-&gt;init_termios.
+ *
+ * This is the first place a new tty gets used.  Hence this is where we
+ * acquire references to the usb_serial structure and the driver module,
+ * where we store a pointer to the port, and where we do an autoresume.
+ * All these actions are reversed in serial_do_free().
  */
 static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 {
 	int idx = tty-&gt;index;
 	struct usb_serial *serial;
-	int retval;
+	struct usb_serial_port *port;
+	int retval = -ENODEV;
+
+	serial = usb_serial_get_by_index(idx);
+	if (!serial)
+		return retval;
+
+	port = serial-&gt;port[idx - serial-&gt;minor];
+	if (!port)
+		goto error_no_port;
+	if (!try_module_get(serial-&gt;type-&gt;driver.owner))
+		goto error_module_get;
+
+	retval = usb_autopm_get_interface(serial-&gt;interface);
+	if (retval)
+		goto error_get_interface;
 
 	/* If the termios setup has yet to be done */
 	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
 		/* perform the standard setup */
 		retval = tty_init_termios(tty);
 		if (retval)
-			return retval;
+			goto error_init_termios;
 		/* allow the driver to update it */
-		serial = usb_serial_get_by_index(tty-&gt;index);
-		if (serial) {
-			if (serial-&gt;type-&gt;init_termios)
-				serial-&gt;type-&gt;init_termios(tty);
-			usb_serial_put(serial);
-			mutex_unlock(&amp;serial-&gt;disc_mutex);
-		}
+		if (serial-&gt;type-&gt;init_termios)
+			serial-&gt;type-&gt;init_termios(tty);
 	}
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
+
+	tty-&gt;driver_data = port;
+
 	/* Final install (we use the default method) */
 	tty_driver_kref_get(driver);
 	tty-&gt;count++;
 	driver-&gt;ttys[idx] = tty;
-	return 0;
+	return retval;
+
+ error_init_termios:
+	usb_autopm_put_interface(serial-&gt;interface);
+ error_get_interface:
+	module_put(serial-&gt;type-&gt;driver.owner);
+ error_module_get:
+ error_no_port:
+	usb_serial_put(serial);
+	mutex_unlock(&amp;serial-&gt;disc_mutex);
+	return retval;
 }
 
 static int serial_open (struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial *serial;
 	struct usb_serial_port *port;
-	unsigned int portNumber;
 	int retval = 0;
 	int first = 0;
 
 	dbg("%s", __func__);
 
-	/* get the serial object associated with this tty pointer */
-	serial = usb_serial_get_by_index(tty-&gt;index);
-	if (!serial) {
-		tty-&gt;driver_data = NULL;
-		return -ENODEV;
-	}
-
-	portNumber = tty-&gt;index - serial-&gt;minor;
-	port = serial-&gt;port[portNumber];
-	if (!port || serial-&gt;disconnected)
-		retval = -ENODEV;
-	/*
-	 * Note: Our locking order requirement does not allow port-&gt;mutex
-	 * to be acquired while serial-&gt;disc_mutex is held.
-	 */
-	mutex_unlock(&amp;serial-&gt;disc_mutex);
-	if (retval)
-		goto bailout_serial_put;
+	port = tty-&gt;driver_data;
+	serial = port-&gt;serial;
 
-	if (mutex_lock_interruptible(&amp;port-&gt;mutex)) {
-		retval = -ERESTARTSYS;
-		goto bailout_serial_put;
-	}
+	if (mutex_lock_interruptible(&amp;port-&gt;mutex))
+		return -ERESTARTSYS;
 
 	++port-&gt;port.count;
-
-	/* set up our port structure making the tty driver
-	 * remember our port object, and us it */
-	tty-&gt;driver_data = port;
 	tty_port_tty_set(&amp;port-&gt;port, tty);
 
 	/* If the console is attached, the device is already open */
 	if (port-&gt;port.count == 1 &amp;&amp; !port-&gt;console) {
 		first = 1;
-		/* lock this module before we call it
-		 * this may fail, which means we must bail out,
-		 * safe because we are called with BKL held */
-		if (!try_module_get(serial-&gt;type-&gt;driver.owner)) {
-			retval = -ENODEV;
-			goto bailout_mutex_unlock;
-		}
-
 		mutex_lock(&amp;serial-&gt;disc_mutex);
-		if (serial-&gt;disconnected)
-			retval = -ENODEV;
-		else
-			retval = usb_autopm_get_interface(serial-&gt;interface);
-		if (retval)
-			goto bailout_module_put;
 
 		/* only call the device specific open if this
 		 * is the first time the port is opened */
 		retval = serial-&gt;type-&gt;open(tty, port);
 		if (retval)
-			goto bailout_interface_put;
+			goto bailout_module_put;
 		mutex_unlock(&amp;serial-&gt;disc_mutex);
 		set_bit(ASYNCB_INITIALIZED, &amp;port-&gt;port.flags);
 	}
@@ -297,18 +289,11 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 		goto bailout_mutex_unlock;
 	/* Undo the initial port actions */
 	mutex_lock(&amp;serial-&gt;disc_mutex);
-bailout_interface_put:
-	usb_autopm_put_interface(serial-&gt;interface);
 bailout_module_put:
 	mutex_unlock(&amp;serial-&gt;disc_mutex);
-	module_put(serial-&gt;type-&gt;driver.owner);
 bailout_mutex_unlock:
 	port-&gt;port.count = 0;
-	tty-&gt;driver_data = NULL;
-	tty_port_tty_set(&amp;port-&gt;port, NULL);
 	mutex_unlock(&amp;port-&gt;mutex);
-bailout_serial_put:
-	usb_serial_put(serial);
 	return retval;
 }
 
@@ -355,9 +340,6 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
 
-	if (!port)
-		return;
-
 	dbg("%s - port %d", __func__, port-&gt;number);
 
 	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
@@ -365,7 +347,6 @@ static void serial_close(struct tty_struct *tty, struct file *filp)
 	serial_do_down(port);
 	tty_port_close_end(&amp;port-&gt;port, tty);
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
-
 }
 
 /**
@@ -386,9 +367,11 @@ static void serial_do_free(struct tty_struct *tty)
 	/* The console is magical.  Do not hang up the console hardware
 	 * or there will be tears.
 	 */
-	if (port == NULL || port-&gt;console)
+	if (port-&gt;console)
 		return;
 
+	tty-&gt;driver_data = NULL;
+
 	serial = port-&gt;serial;
 	owner = serial-&gt;type-&gt;driver.owner;
 </pre><hr><pre>commit 8bc2c1b2daf95029658868cb1427baea2da87139
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:38:59 2009 -0400

    usb-serial: change logic of serial lookups
    
    This patch (as1286) changes usb_serial_get_by_index().  Now the
    routine will check whether the serial device has been disconnected; if
    it has then the return value will be NULL.  If the device hasn't been
    disconnected then the routine will return with serial-&gt;disc_mutex
    held, so that the caller can use the structure without fear of racing
    against driver unloads.
    
    This permits the scope of table_mutex in destroy_serial() to be
    reduced.  Instead of protecting the entire function, it suffices to
    protect the part that actually uses serial_table[], i.e., the call to
    return_serial().  There's no longer any danger of the refcount being
    incremented after it reaches 0 (which was the reason for having the
    large scope previously), because it can't reach 0 until the serial
    device has been disconnected.
    
    Also, the patch makes serial_install() check that serial is non-NULL
    before attempting to use it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 266dc583867b..87802ea8bbc8 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -66,6 +66,11 @@ static struct usb_serial *serial_table[SERIAL_TTY_MINORS];
 static DEFINE_MUTEX(table_lock);
 static LIST_HEAD(usb_serial_driver_list);
 
+/*
+ * Look up the serial structure.  If it is found and it hasn't been
+ * disconnected, return with its disc_mutex held and its refcount
+ * incremented.  Otherwise return NULL.
+ */
 struct usb_serial *usb_serial_get_by_index(unsigned index)
 {
 	struct usb_serial *serial;
@@ -73,8 +78,15 @@ struct usb_serial *usb_serial_get_by_index(unsigned index)
 	mutex_lock(&amp;table_lock);
 	serial = serial_table[index];
 
-	if (serial)
-		kref_get(&amp;serial-&gt;kref);
+	if (serial) {
+		mutex_lock(&amp;serial-&gt;disc_mutex);
+		if (serial-&gt;disconnected) {
+			mutex_unlock(&amp;serial-&gt;disc_mutex);
+			serial = NULL;
+		} else {
+			kref_get(&amp;serial-&gt;kref);
+		}
+	}
 	mutex_unlock(&amp;table_lock);
 	return serial;
 }
@@ -123,8 +135,10 @@ static void return_serial(struct usb_serial *serial)
 
 	dbg("%s", __func__);
 
+	mutex_lock(&amp;table_lock);
 	for (i = 0; i &lt; serial-&gt;num_ports; ++i)
 		serial_table[serial-&gt;minor + i] = NULL;
+	mutex_unlock(&amp;table_lock);
 }
 
 static void destroy_serial(struct kref *kref)
@@ -158,9 +172,7 @@ static void destroy_serial(struct kref *kref)
 
 void usb_serial_put(struct usb_serial *serial)
 {
-	mutex_lock(&amp;table_lock);
 	kref_put(&amp;serial-&gt;kref, destroy_serial);
-	mutex_unlock(&amp;table_lock);
 }
 
 /*****************************************************************************
@@ -190,9 +202,12 @@ static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
 			return retval;
 		/* allow the driver to update it */
 		serial = usb_serial_get_by_index(tty-&gt;index);
-		if (serial-&gt;type-&gt;init_termios)
-			serial-&gt;type-&gt;init_termios(tty);
-		usb_serial_put(serial);
+		if (serial) {
+			if (serial-&gt;type-&gt;init_termios)
+				serial-&gt;type-&gt;init_termios(tty);
+			usb_serial_put(serial);
+			mutex_unlock(&amp;serial-&gt;disc_mutex);
+		}
 	}
 	/* Final install (we use the default method) */
 	tty_driver_kref_get(driver);
@@ -218,7 +233,6 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 		return -ENODEV;
 	}
 
-	mutex_lock(&amp;serial-&gt;disc_mutex);
 	portNumber = tty-&gt;index - serial-&gt;minor;
 	port = serial-&gt;port[portNumber];
 	if (!port || serial-&gt;disconnected)
@@ -529,6 +543,7 @@ static int serial_proc_show(struct seq_file *m, void *v)
 
 		seq_putc(m, '\n');
 		usb_serial_put(serial);
+		mutex_unlock(&amp;serial-&gt;disc_mutex);
 	}
 	return 0;
 }</pre><hr><pre>commit f5b0953a89fa3407fb293cc54ead7d8feec489e4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:38:44 2009 -0400

    usb-serial: put subroutines in logical order
    
    This patch (as1285) rearranges the subroutines in usb-serial.c
    concerned with tty lifetimes into a more logical order: install, open,
    hangup, close, release.  It also updates the formatting of the
    kerneldoc comments.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index f1a1f0fb6d1b..266dc583867b 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -166,6 +166,41 @@ void usb_serial_put(struct usb_serial *serial)
 /*****************************************************************************
  * Driver tty interface functions
  *****************************************************************************/
+
+/**
+ * serial_install - install tty
+ * @driver: the driver (USB in our case)
+ * @tty: the tty being created
+ *
+ * Create the termios objects for this tty.  We use the default
+ * USB serial settings but permit them to be overridden by
+ * serial-&gt;type-&gt;init_termios.
+ */
+static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
+{
+	int idx = tty-&gt;index;
+	struct usb_serial *serial;
+	int retval;
+
+	/* If the termios setup has yet to be done */
+	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
+		/* perform the standard setup */
+		retval = tty_init_termios(tty);
+		if (retval)
+			return retval;
+		/* allow the driver to update it */
+		serial = usb_serial_get_by_index(tty-&gt;index);
+		if (serial-&gt;type-&gt;init_termios)
+			serial-&gt;type-&gt;init_termios(tty);
+		usb_serial_put(serial);
+	}
+	/* Final install (we use the default method) */
+	tty_driver_kref_get(driver);
+	tty-&gt;count++;
+	driver-&gt;ttys[idx] = tty;
+	return 0;
+}
+
 static int serial_open (struct tty_struct *tty, struct file *filp)
 {
 	struct usb_serial *serial;
@@ -264,13 +299,11 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 }
 
 /**
- *	serial_do_down		-	shut down hardware
- *	@port: port to shut down
+ * serial_do_down - shut down hardware
+ * @port: port to shut down
  *
- *	Shut down a USB port unless it is the console. We never shut down the
- *	console hardware as it will always be in use.
- *
- *	Don't free any resources at this point
+ * Shut down a USB serial port unless it is the console.  We never
+ * shut down the console hardware as it will always be in use.
  */
 static void serial_do_down(struct usb_serial_port *port)
 {
@@ -278,8 +311,10 @@ static void serial_do_down(struct usb_serial_port *port)
 	struct usb_serial *serial;
 	struct module *owner;
 
-	/* The console is magical, do not hang up the console hardware
-	   or there will be tears */
+	/*
+	 * The console is magical.  Do not hang up the console hardware
+	 * or there will be tears.
+	 */
 	if (port-&gt;console)
 		return;
 
@@ -293,24 +328,50 @@ static void serial_do_down(struct usb_serial_port *port)
 	mutex_unlock(&amp;port-&gt;mutex);
 }
 
+static void serial_hangup(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	serial_do_down(port);
+	tty_port_hangup(&amp;port-&gt;port);
+	/* We must not free port yet - the USB serial layer depends on it's
+	   continued existence */
+}
+
+static void serial_close(struct tty_struct *tty, struct file *filp)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+
+	if (!port)
+		return;
+
+	dbg("%s - port %d", __func__, port-&gt;number);
+
+	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
+		return;
+	serial_do_down(port);
+	tty_port_close_end(&amp;port-&gt;port, tty);
+	tty_port_tty_set(&amp;port-&gt;port, NULL);
+
+}
+
 /**
- *	serial_do_free		-	free resources post close/hangup
- *	@port: port to free up
+ * serial_do_free - free resources post close/hangup
+ * @port: port to free up
  *
- *	Do the resource freeing and refcount dropping for the port. We must
- *	be careful about ordering and we must avoid freeing up the console.
+ * Do the resource freeing and refcount dropping for the port.
+ * Avoid freeing the console.
  *
- *	Called when the last tty kref is dropped.
+ * Called when the last tty kref is dropped.
  */
-
 static void serial_do_free(struct tty_struct *tty)
 {
 	struct usb_serial_port *port = tty-&gt;driver_data;
 	struct usb_serial *serial;
 	struct module *owner;
 
-	/* The console is magical, do not hang up the console hardware
-	   or there will be tears */
+	/* The console is magical.  Do not hang up the console hardware
+	 * or there will be tears.
+	 */
 	if (port == NULL || port-&gt;console)
 		return;
 
@@ -326,32 +387,6 @@ static void serial_do_free(struct tty_struct *tty)
 	module_put(owner);
 }
 
-static void serial_close(struct tty_struct *tty, struct file *filp)
-{
-	struct usb_serial_port *port = tty-&gt;driver_data;
-
-	if (!port)
-		return;
-
-	dbg("%s - port %d", __func__, port-&gt;number);
-
-	if (tty_port_close_start(&amp;port-&gt;port, tty, filp) == 0)
-		return;
-	serial_do_down(port);		
-	tty_port_close_end(&amp;port-&gt;port, tty);
-	tty_port_tty_set(&amp;port-&gt;port, NULL);
-
-}
-
-static void serial_hangup(struct tty_struct *tty)
-{
-	struct usb_serial_port *port = tty-&gt;driver_data;
-	serial_do_down(port);
-	tty_port_hangup(&amp;port-&gt;port);
-	/* We must not free port yet - the USB serial layer depends on it's
-	   continued existence */
-}
-
 static int serial_write(struct tty_struct *tty, const unsigned char *buf,
 								int count)
 {
@@ -699,41 +734,6 @@ static const struct tty_port_operations serial_port_ops = {
 	.dtr_rts = serial_dtr_rts,
 };
 
-/**
- *	serial_install		-	install tty
- *	@driver: the driver (USB in our case)
- *	@tty: the tty being created
- *
- *	Create the termios objects for this tty. We use the default USB
- *	serial ones but permit them to be overriddenby serial-&gt;type-&gt;termios.
- *	This lets us remove all the ugly hackery
- */
-
-static int serial_install(struct tty_driver *driver, struct tty_struct *tty)
-{
-	int idx = tty-&gt;index;
-	struct usb_serial *serial;
-	int retval;
-
-	/* If the termios setup has yet to be done */
-	if (tty-&gt;driver-&gt;termios[idx] == NULL) {
-		/* perform the standard setup */
-		retval = tty_init_termios(tty);
-		if (retval)
-			return retval;
-		/* allow the driver to update it */
-		serial = usb_serial_get_by_index(tty-&gt;index);
-		if (serial-&gt;type-&gt;init_termios)
-			serial-&gt;type-&gt;init_termios(tty);
-		usb_serial_put(serial);
-	}
-	/* Final install (we use the default method) */
-	tty_driver_kref_get(driver);
-	tty-&gt;count++;
-	driver-&gt;ttys[idx] = tty;
-	return 0;
-}
-
 int usb_serial_probe(struct usb_interface *interface,
 			       const struct usb_device_id *id)
 {</pre><hr><pre>commit 41bd34ddd7aa46dbc03b5bb33896e0fa8100fe7b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:38:34 2009 -0400

    usb-serial: change referencing of port and serial structures
    
    This patch (as1284) changes the referencing of the usb_serial and
    usb_serial_port structures in usb-serial.c.  It's not feasible to make
    the port structures keep a reference to the serial structure, because
    the ports need to remain in existence when serial is released -- quite
    a few of the drivers expect this.  Consequently taking a reference
    to the port when the device file is open is insufficient; such a
    reference would not pin serial.
    
    To fix this, we now take a reference to serial when the device file is
    opened.  The final put_device() for the ports occurs in
    destroy_serial(), so that the ports will last as long as they are
    needed.
    
    The patch initializes all the port devices, including those in the
    unused "fake" ports.  This makes the code more uniform because they
    can all be released in the same way.  The error handling code in
    usb_serial_probe() is much simplified by this approach; instead of
    freeing everything by hand we can use a single usb_serial_put() call.
    
    Also simplified is the port-release mechanism.  Instead of being two
    separate routines, port_release() and port_free() can be combined into
    one.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index 80c1f4d8e910..f1a1f0fb6d1b 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -43,8 +43,6 @@
 #define DRIVER_AUTHOR "Greg Kroah-Hartman, greg@kroah.com, http://www.kroah.com/linux/"
 #define DRIVER_DESC "USB Serial Driver core"
 
-static void port_free(struct usb_serial_port *port);
-
 /* Driver structure we register with the USB core */
 static struct usb_driver usb_serial_driver = {
 	.name =		"usbserial",
@@ -145,27 +143,16 @@ static void destroy_serial(struct kref *kref)
 
 	serial-&gt;type-&gt;release(serial);
 
-	for (i = 0; i &lt; serial-&gt;num_ports; ++i) {
+	/* Now that nothing is using the ports, they can be freed */
+	for (i = 0; i &lt; serial-&gt;num_port_pointers; ++i) {
 		port = serial-&gt;port[i];
-		if (port)
+		if (port) {
+			port-&gt;serial = NULL;
 			put_device(&amp;port-&gt;dev);
-	}
-
-	/* If this is a "fake" port, we have to clean it up here, as it will
-	 * not get cleaned up in port_release() as it was never registered with
-	 * the driver core */
-	if (serial-&gt;num_ports &lt; serial-&gt;num_port_pointers) {
-		for (i = serial-&gt;num_ports;
-					i &lt; serial-&gt;num_port_pointers; ++i) {
-			port = serial-&gt;port[i];
-			if (port)
-				port_free(port);
 		}
 	}
 
 	usb_put_dev(serial-&gt;dev);
-
-	/* free up any memory that we allocated */
 	kfree(serial);
 }
 
@@ -201,8 +188,6 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 	port = serial-&gt;port[portNumber];
 	if (!port || serial-&gt;disconnected)
 		retval = -ENODEV;
-	else
-		get_device(&amp;port-&gt;dev);
 	/*
 	 * Note: Our locking order requirement does not allow port-&gt;mutex
 	 * to be acquired while serial-&gt;disc_mutex is held.
@@ -213,7 +198,7 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 
 	if (mutex_lock_interruptible(&amp;port-&gt;mutex)) {
 		retval = -ERESTARTSYS;
-		goto bailout_port_put;
+		goto bailout_serial_put;
 	}
 
 	++port-&gt;port.count;
@@ -273,8 +258,6 @@ static int serial_open (struct tty_struct *tty, struct file *filp)
 	tty-&gt;driver_data = NULL;
 	tty_port_tty_set(&amp;port-&gt;port, NULL);
 	mutex_unlock(&amp;port-&gt;mutex);
-bailout_port_put:
-	put_device(&amp;port-&gt;dev);
 bailout_serial_put:
 	usb_serial_put(serial);
 	return retval;
@@ -333,14 +316,13 @@ static void serial_do_free(struct tty_struct *tty)
 
 	serial = port-&gt;serial;
 	owner = serial-&gt;type-&gt;driver.owner;
-	put_device(&amp;port-&gt;dev);
-	/* Mustn't dereference port any more */
+
 	mutex_lock(&amp;serial-&gt;disc_mutex);
 	if (!serial-&gt;disconnected)
 		usb_autopm_put_interface(serial-&gt;interface);
 	mutex_unlock(&amp;serial-&gt;disc_mutex);
+
 	usb_serial_put(serial);
-	/* Mustn't dereference serial any more */
 	module_put(owner);
 }
 
@@ -581,14 +563,6 @@ static void usb_serial_port_work(struct work_struct *work)
 	tty_kref_put(tty);
 }
 
-static void port_release(struct device *dev)
-{
-	struct usb_serial_port *port = to_usb_serial_port(dev);
-
-	dbg ("%s - %s", __func__, dev_name(dev));
-	port_free(port);
-}
-
 static void kill_traffic(struct usb_serial_port *port)
 {
 	usb_kill_urb(port-&gt;read_urb);
@@ -608,8 +582,12 @@ static void kill_traffic(struct usb_serial_port *port)
 	usb_kill_urb(port-&gt;interrupt_out_urb);
 }
 
-static void port_free(struct usb_serial_port *port)
+static void port_release(struct device *dev)
 {
+	struct usb_serial_port *port = to_usb_serial_port(dev);
+
+	dbg ("%s - %s", __func__, dev_name(dev));
+
 	/*
 	 * Stop all the traffic before cancelling the work, so that
 	 * nobody will restart it by calling usb_serial_port_softint.
@@ -955,6 +933,11 @@ int usb_serial_probe(struct usb_interface *interface,
 		mutex_init(&amp;port-&gt;mutex);
 		INIT_WORK(&amp;port-&gt;work, usb_serial_port_work);
 		serial-&gt;port[i] = port;
+		port-&gt;dev.parent = &amp;interface-&gt;dev;
+		port-&gt;dev.driver = NULL;
+		port-&gt;dev.bus = &amp;usb_serial_bus_type;
+		port-&gt;dev.release = &amp;port_release;
+		device_initialize(&amp;port-&gt;dev);
 	}
 
 	/* set up the endpoint information */
@@ -1097,15 +1080,10 @@ int usb_serial_probe(struct usb_interface *interface,
 	/* register all of the individual ports with the driver core */
 	for (i = 0; i &lt; num_ports; ++i) {
 		port = serial-&gt;port[i];
-		port-&gt;dev.parent = &amp;interface-&gt;dev;
-		port-&gt;dev.driver = NULL;
-		port-&gt;dev.bus = &amp;usb_serial_bus_type;
-		port-&gt;dev.release = &amp;port_release;
-
 		dev_set_name(&amp;port-&gt;dev, "ttyUSB%d", port-&gt;number);
 		dbg ("%s - registering %s", __func__, dev_name(&amp;port-&gt;dev));
 		port-&gt;dev_state = PORT_REGISTERING;
-		retval = device_register(&amp;port-&gt;dev);
+		retval = device_add(&amp;port-&gt;dev);
 		if (retval) {
 			dev_err(&amp;port-&gt;dev, "Error registering port device, "
 				"continuing\n");
@@ -1123,39 +1101,7 @@ int usb_serial_probe(struct usb_interface *interface,
 	return 0;
 
 probe_error:
-	for (i = 0; i &lt; num_bulk_in; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;read_urb);
-		kfree(port-&gt;bulk_in_buffer);
-	}
-	for (i = 0; i &lt; num_bulk_out; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;write_urb);
-		kfree(port-&gt;bulk_out_buffer);
-	}
-	for (i = 0; i &lt; num_interrupt_in; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;interrupt_in_urb);
-		kfree(port-&gt;interrupt_in_buffer);
-	}
-	for (i = 0; i &lt; num_interrupt_out; ++i) {
-		port = serial-&gt;port[i];
-		if (!port)
-			continue;
-		usb_free_urb(port-&gt;interrupt_out_urb);
-		kfree(port-&gt;interrupt_out_buffer);
-	}
-
-	/* free up any memory that we allocated */
-	for (i = 0; i &lt; serial-&gt;num_port_pointers; ++i)
-		kfree(serial-&gt;port[i]);
-	kfree(serial);
+	usb_serial_put(serial);
 	return -EIO;
 }
 EXPORT_SYMBOL_GPL(usb_serial_probe);
@@ -1206,8 +1152,7 @@ void usb_serial_disconnect(struct usb_interface *interface)
 	}
 	serial-&gt;type-&gt;disconnect(serial);
 
-	/* let the last holder of this object
-	 * cause it to be cleaned up */
+	/* let the last holder of this object cause it to be cleaned up */
 	usb_serial_put(serial);
 	dev_info(dev, "device disconnected\n");
 }</pre><hr><pre>commit 1f5c13fad4ec5617b610e12205902c06298c096a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 20 15:23:47 2009 -0400

    TTY: fix typos
    
    This patch (as1282) fixes some obvious typos in the TTY core.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/char/tty_port.c b/drivers/char/tty_port.c
index c767e30a1425..a4bbb28f10be 100644
--- a/drivers/char/tty_port.c
+++ b/drivers/char/tty_port.c
@@ -100,7 +100,7 @@ EXPORT_SYMBOL(tty_port_tty_set);
 static void tty_port_shutdown(struct tty_port *port)
 {
 	if (port-&gt;ops-&gt;shutdown &amp;&amp;
-		test_and_clear_bit(ASYNC_INITIALIZED, &amp;port-&gt;flags))
+		test_and_clear_bit(ASYNCB_INITIALIZED, &amp;port-&gt;flags))
 			port-&gt;ops-&gt;shutdown(port);
 
 }
@@ -311,7 +311,7 @@ int tty_port_close_start(struct tty_port *port, struct tty_struct *tty, struct f
 			port-&gt;ops-&gt;drop(port);
 		return 0;
 	}
-	set_bit(ASYNC_CLOSING, &amp;port-&gt;flags);
+	set_bit(ASYNCB_CLOSING, &amp;port-&gt;flags);
 	tty-&gt;closing = 1;
 	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);
 	/* Don't block on a stalled port, just pull the chain */</pre>
    <div class="pagination">
        <a href='2_74.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><span>[75]</span><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_76.html'>Next&gt;&gt;</a>
    <div>
</body>
