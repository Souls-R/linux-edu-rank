<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_12.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><span>[13]</span><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_14.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 12ad3d2d6c5b0131a6052de91360849e3e154846
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Fri Nov 25 07:15:54 2022 -0700

    io_uring/poll: fix poll_refs race with cancelation
    
    There is an interesting race condition of poll_refs which could result
    in a NULL pointer dereference. The crash trace is like:
    
    KASAN: null-ptr-deref in range [0x0000000000000008-0x000000000000000f]
    CPU: 0 PID: 30781 Comm: syz-executor.2 Not tainted 6.0.0-g493ffd6605b2 #1
    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
    1.13.0-1ubuntu1.1 04/01/2014
    RIP: 0010:io_poll_remove_entry io_uring/poll.c:154 [inline]
    RIP: 0010:io_poll_remove_entries+0x171/0x5b4 io_uring/poll.c:190
    Code: ...
    RSP: 0018:ffff88810dfefba0 EFLAGS: 00010202
    RAX: 0000000000000001 RBX: 0000000000000000 RCX: 0000000000040000
    RDX: ffffc900030c4000 RSI: 000000000003ffff RDI: 0000000000040000
    RBP: 0000000000000008 R08: ffffffff9764d3dd R09: fffffbfff3836781
    R10: fffffbfff3836781 R11: 0000000000000000 R12: 1ffff11003422d60
    R13: ffff88801a116b04 R14: ffff88801a116ac0 R15: dffffc0000000000
    FS:  00007f9c07497700(0000) GS:ffff88811a600000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 00007ffb5c00ea98 CR3: 0000000105680005 CR4: 0000000000770ef0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    PKRU: 55555554
    Call Trace:
     &lt;TASK&gt;
     io_apoll_task_func+0x3f/0xa0 io_uring/poll.c:299
     handle_tw_list io_uring/io_uring.c:1037 [inline]
     tctx_task_work+0x37e/0x4f0 io_uring/io_uring.c:1090
     task_work_run+0x13a/0x1b0 kernel/task_work.c:177
     get_signal+0x2402/0x25a0 kernel/signal.c:2635
     arch_do_signal_or_restart+0x3b/0x660 arch/x86/kernel/signal.c:869
     exit_to_user_mode_loop kernel/entry/common.c:166 [inline]
     exit_to_user_mode_prepare+0xc2/0x160 kernel/entry/common.c:201
     __syscall_exit_to_user_mode_work kernel/entry/common.c:283 [inline]
     syscall_exit_to_user_mode+0x58/0x160 kernel/entry/common.c:294
     entry_SYSCALL_64_after_hwframe+0x63/0xcd
    
    The root cause for this is a tiny overlooking in
    io_poll_check_events() when cocurrently run with poll cancel routine
    io_poll_cancel_req().
    
    The interleaving to trigger use-after-free:
    
    CPU0                                       |  CPU1
                                               |
    io_apoll_task_func()                       |  io_poll_cancel_req()
     io_poll_check_events()                    |
      // do while first loop                   |
      v = atomic_read(...)                     |
      // v = poll_refs = 1                     |
      ...                                      |  io_poll_mark_cancelled()
                                               |   atomic_or()
                                               |   // poll_refs =
    IO_POLL_CANCEL_FLAG | 1
                                               |
      atomic_sub_return(...)                   |
      // poll_refs = IO_POLL_CANCEL_FLAG       |
      // loop continue                         |
                                               |
                                               |  io_poll_execute()
                                               |   io_poll_get_ownership()
                                               |   // poll_refs =
    IO_POLL_CANCEL_FLAG | 1
                                               |   // gets the ownership
      v = atomic_read(...)                     |
      // poll_refs not change                  |
                                               |
      if (v &amp; IO_POLL_CANCEL_FLAG)             |
       return -ECANCELED;                      |
      // io_poll_check_events return           |
      // will go into                          |
      // io_req_complete_failed() free req     |
                                               |
                                               |  io_apoll_task_func()
                                               |  // also go into
    io_req_complete_failed()
    
    And the interleaving to trigger the kernel WARNING:
    
    CPU0                                       |  CPU1
                                               |
    io_apoll_task_func()                       |  io_poll_cancel_req()
     io_poll_check_events()                    |
      // do while first loop                   |
      v = atomic_read(...)                     |
      // v = poll_refs = 1                     |
      ...                                      |  io_poll_mark_cancelled()
                                               |   atomic_or()
                                               |   // poll_refs =
    IO_POLL_CANCEL_FLAG | 1
                                               |
      atomic_sub_return(...)                   |
      // poll_refs = IO_POLL_CANCEL_FLAG       |
      // loop continue                         |
                                               |
      v = atomic_read(...)                     |
      // v = IO_POLL_CANCEL_FLAG               |
                                               |  io_poll_execute()
                                               |   io_poll_get_ownership()
                                               |   // poll_refs =
    IO_POLL_CANCEL_FLAG | 1
                                               |   // gets the ownership
                                               |
      WARN_ON_ONCE(!(v &amp; IO_POLL_REF_MASK)))   |
      // v &amp; IO_POLL_REF_MASK = 0 WARN         |
                                               |
                                               |  io_apoll_task_func()
                                               |  // also go into
    io_req_complete_failed()
    
    By looking up the source code and communicating with Pavel, the
    implementation of this atomic poll refs should continue the loop of
    io_poll_check_events() just to avoid somewhere else to grab the
    ownership. Therefore, this patch simply adds another AND operation to
    make sure the loop will stop if it finds the poll_refs is exactly equal
    to IO_POLL_CANCEL_FLAG. Since io_poll_cancel_req() grabs ownership and
    will finally make its way to io_req_complete_failed(), the req will
    be reclaimed as expected.
    
    Fixes: aa43477b0402 ("io_uring: poll rework")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reviewed-by: Pavel Begunkov &lt;asml.silence@gmail.com&gt;
    [axboe: tweak description and code style]
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/io_uring/poll.c b/io_uring/poll.c
index b444b7d87697..d9bf1767867e 100644
--- a/io_uring/poll.c
+++ b/io_uring/poll.c
@@ -308,7 +308,8 @@ static int io_poll_check_events(struct io_kiocb *req, bool *locked)
 		 * Release all references, retry if someone tried to restart
 		 * task_work while we were executing it.
 		 */
-	} while (atomic_sub_return(v &amp; IO_POLL_REF_MASK, &amp;req-&gt;poll_refs));
+	} while (atomic_sub_return(v &amp; IO_POLL_REF_MASK, &amp;req-&gt;poll_refs) &amp;
+					IO_POLL_REF_MASK);
 
 	return IOU_POLL_NO_ACTION;
 }</pre><hr><pre>commit 9d94c04c0db024922e886c9fd429659f22f48ea4
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Wed Nov 23 02:40:15 2022 +0800

    io_uring/filetable: fix file reference underflow
    
    There is an interesting reference bug when -ENOMEM occurs in calling of
    io_install_fixed_file(). KASan report like below:
    
    [   14.057131] ==================================================================
    [   14.059161] BUG: KASAN: use-after-free in unix_get_socket+0x10/0x90
    [   14.060975] Read of size 8 at addr ffff88800b09cf20 by task kworker/u8:2/45
    [   14.062684]
    [   14.062768] CPU: 2 PID: 45 Comm: kworker/u8:2 Not tainted 6.1.0-rc4 #1
    [   14.063099] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014
    [   14.063666] Workqueue: events_unbound io_ring_exit_work
    [   14.063936] Call Trace:
    [   14.064065]  &lt;TASK&gt;
    [   14.064175]  dump_stack_lvl+0x34/0x48
    [   14.064360]  print_report+0x172/0x475
    [   14.064547]  ? _raw_spin_lock_irq+0x83/0xe0
    [   14.064758]  ? __virt_addr_valid+0xef/0x170
    [   14.064975]  ? unix_get_socket+0x10/0x90
    [   14.065167]  kasan_report+0xad/0x130
    [   14.065353]  ? unix_get_socket+0x10/0x90
    [   14.065553]  unix_get_socket+0x10/0x90
    [   14.065744]  __io_sqe_files_unregister+0x87/0x1e0
    [   14.065989]  ? io_rsrc_refs_drop+0x1c/0xd0
    [   14.066199]  io_ring_exit_work+0x388/0x6a5
    [   14.066410]  ? io_uring_try_cancel_requests+0x5bf/0x5bf
    [   14.066674]  ? try_to_wake_up+0xdb/0x910
    [   14.066873]  ? virt_to_head_page+0xbe/0xbe
    [   14.067080]  ? __schedule+0x574/0xd20
    [   14.067273]  ? read_word_at_a_time+0xe/0x20
    [   14.067492]  ? strscpy+0xb5/0x190
    [   14.067665]  process_one_work+0x423/0x710
    [   14.067879]  worker_thread+0x2a2/0x6f0
    [   14.068073]  ? process_one_work+0x710/0x710
    [   14.068284]  kthread+0x163/0x1a0
    [   14.068454]  ? kthread_complete_and_exit+0x20/0x20
    [   14.068697]  ret_from_fork+0x22/0x30
    [   14.068886]  &lt;/TASK&gt;
    [   14.069000]
    [   14.069088] Allocated by task 289:
    [   14.069269]  kasan_save_stack+0x1e/0x40
    [   14.069463]  kasan_set_track+0x21/0x30
    [   14.069652]  __kasan_slab_alloc+0x58/0x70
    [   14.069899]  kmem_cache_alloc+0xc5/0x200
    [   14.070100]  __alloc_file+0x20/0x160
    [   14.070283]  alloc_empty_file+0x3b/0xc0
    [   14.070479]  path_openat+0xc3/0x1770
    [   14.070689]  do_filp_open+0x150/0x270
    [   14.070888]  do_sys_openat2+0x113/0x270
    [   14.071081]  __x64_sys_openat+0xc8/0x140
    [   14.071283]  do_syscall_64+0x3b/0x90
    [   14.071466]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [   14.071791]
    [   14.071874] Freed by task 0:
    [   14.072027]  kasan_save_stack+0x1e/0x40
    [   14.072224]  kasan_set_track+0x21/0x30
    [   14.072415]  kasan_save_free_info+0x2a/0x50
    [   14.072627]  __kasan_slab_free+0x106/0x190
    [   14.072858]  kmem_cache_free+0x98/0x340
    [   14.073075]  rcu_core+0x427/0xe50
    [   14.073249]  __do_softirq+0x110/0x3cd
    [   14.073440]
    [   14.073523] Last potentially related work creation:
    [   14.073801]  kasan_save_stack+0x1e/0x40
    [   14.074017]  __kasan_record_aux_stack+0x97/0xb0
    [   14.074264]  call_rcu+0x41/0x550
    [   14.074436]  task_work_run+0xf4/0x170
    [   14.074619]  exit_to_user_mode_prepare+0x113/0x120
    [   14.074858]  syscall_exit_to_user_mode+0x1d/0x40
    [   14.075092]  do_syscall_64+0x48/0x90
    [   14.075272]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [   14.075529]
    [   14.075612] Second to last potentially related work creation:
    [   14.075900]  kasan_save_stack+0x1e/0x40
    [   14.076098]  __kasan_record_aux_stack+0x97/0xb0
    [   14.076325]  task_work_add+0x72/0x1b0
    [   14.076512]  fput+0x65/0xc0
    [   14.076657]  filp_close+0x8e/0xa0
    [   14.076825]  __x64_sys_close+0x15/0x50
    [   14.077019]  do_syscall_64+0x3b/0x90
    [   14.077199]  entry_SYSCALL_64_after_hwframe+0x63/0xcd
    [   14.077448]
    [   14.077530] The buggy address belongs to the object at ffff88800b09cf00
    [   14.077530]  which belongs to the cache filp of size 232
    [   14.078105] The buggy address is located 32 bytes inside of
    [   14.078105]  232-byte region [ffff88800b09cf00, ffff88800b09cfe8)
    [   14.078685]
    [   14.078771] The buggy address belongs to the physical page:
    [   14.079046] page:000000001bd520e7 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff88800b09de00 pfn:0xb09c
    [   14.079575] head:000000001bd520e7 order:1 compound_mapcount:0 compound_pincount:0
    [   14.079946] flags: 0x100000000010200(slab|head|node=0|zone=1)
    [   14.080244] raw: 0100000000010200 0000000000000000 dead000000000001 ffff88800493cc80
    [   14.080629] raw: ffff88800b09de00 0000000080190018 00000001ffffffff 0000000000000000
    [   14.081016] page dumped because: kasan: bad access detected
    [   14.081293]
    [   14.081376] Memory state around the buggy address:
    [   14.081618]  ffff88800b09ce00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    [   14.081974]  ffff88800b09ce80: 00 00 00 00 00 fc fc fc fc fc fc fc fc fc fc fc
    [   14.082336] &gt;ffff88800b09cf00: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [   14.082690]                                ^
    [   14.082909]  ffff88800b09cf80: fb fb fb fb fb fb fb fb fb fb fb fb fb fc fc fc
    [   14.083266]  ffff88800b09d000: fc fc fc fc fc fc fc fc fa fb fb fb fb fb fb fb
    [   14.083622] ==================================================================
    
    The actual tracing of this bug is shown below:
    
    commit 8c71fe750215 ("io_uring: ensure fput() called correspondingly
    when direct install fails") adds an additional fput() in
    io_fixed_fd_install() when io_file_bitmap_get() returns error values. In
    that case, the routine will never make it to io_install_fixed_file() due
    to an early return.
    
    static int io_fixed_fd_install(...)
    {
      if (alloc_slot) {
        ...
        ret = io_file_bitmap_get(ctx);
        if (unlikely(ret &lt; 0)) {
          io_ring_submit_unlock(ctx, issue_flags);
          fput(file);
          return ret;
        }
        ...
      }
      ...
      ret = io_install_fixed_file(req, file, issue_flags, file_slot);
      ...
    }
    
    In the above scenario, the reference is okay as io_fixed_fd_install()
    ensures the fput() is called when something bad happens, either via
    bitmap or via inner io_install_fixed_file().
    
    However, the commit 61c1b44a21d7 ("io_uring: fix deadlock on iowq file
    slot alloc") breaks the balance because it places fput() into the common
    path for both io_file_bitmap_get() and io_install_fixed_file(). Since
    io_install_fixed_file() handles the fput() itself, the reference
    underflow come across then.
    
    There are some extra commits make the current code into
    io_fixed_fd_install() -&gt; __io_fixed_fd_install() -&gt;
    io_install_fixed_file()
    
    However, the fact that there is an extra fput() is called if
    io_install_fixed_file() calls fput(). Traversing through the code, I
    find that the existing two callers to __io_fixed_fd_install():
    io_fixed_fd_install() and io_msg_send_fd() have fput() when handling
    error return, this patch simply removes the fput() in
    io_install_fixed_file() to fix the bug.
    
    Fixes: 61c1b44a21d7 ("io_uring: fix deadlock on iowq file slot alloc")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/be4ba4b.5d44.184a0a406a4.Coremail.linma@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/io_uring/filetable.c b/io_uring/filetable.c
index 7b473259f3f4..68dfc6936aa7 100644
--- a/io_uring/filetable.c
+++ b/io_uring/filetable.c
@@ -101,8 +101,6 @@ static int io_install_fixed_file(struct io_ring_ctx *ctx, struct file *file,
 err:
 	if (needs_switch)
 		io_rsrc_node_switch(ctx, ctx-&gt;file_data);
-	if (ret)
-		fput(file);
 	return ret;
 }
 </pre><hr><pre>commit 0fc044b2b5e2d05a1fa1fb0d7f270367a7855d79
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Sun Aug 7 15:59:52 2022 +0100

    media: dvbdev: adopts refcnt to avoid UAF
    
    dvb_unregister_device() is known that prone to use-after-free.
    That is, the cleanup from dvb_unregister_device() releases the dvb_device
    even if there are pointers stored in file-&gt;private_data still refer to it.
    
    This patch adds a reference counter into struct dvb_device and delays its
    deallocation until no pointer refers to the object.
    
    Link: https://lore.kernel.org/linux-media/20220807145952.10368-1-linma@zju.edu.cn
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Reported-by: kernel test robot &lt;lkp@intel.com&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;

diff --git a/drivers/media/dvb-core/dvb_ca_en50221.c b/drivers/media/dvb-core/dvb_ca_en50221.c
index 15a08d8c69ef..c2d2792227f8 100644
--- a/drivers/media/dvb-core/dvb_ca_en50221.c
+++ b/drivers/media/dvb-core/dvb_ca_en50221.c
@@ -157,7 +157,7 @@ static void dvb_ca_private_free(struct dvb_ca_private *ca)
 {
 	unsigned int i;
 
-	dvb_free_device(ca-&gt;dvbdev);
+	dvb_device_put(ca-&gt;dvbdev);
 	for (i = 0; i &lt; ca-&gt;slot_count; i++)
 		vfree(ca-&gt;slot_info[i].rx_buffer.data);
 
diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c
index 2a98082c605e..7ce4785c8d88 100644
--- a/drivers/media/dvb-core/dvb_frontend.c
+++ b/drivers/media/dvb-core/dvb_frontend.c
@@ -136,7 +136,7 @@ static void __dvb_frontend_free(struct dvb_frontend *fe)
 	struct dvb_frontend_private *fepriv = fe-&gt;frontend_priv;
 
 	if (fepriv)
-		dvb_free_device(fepriv-&gt;dvbdev);
+		dvb_device_put(fepriv-&gt;dvbdev);
 
 	dvb_frontend_invoke_release(fe, fe-&gt;ops.release);
 
diff --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
index 5b275a9395c1..d45673cb3ce1 100644
--- a/drivers/media/dvb-core/dvbdev.c
+++ b/drivers/media/dvb-core/dvbdev.c
@@ -97,7 +97,7 @@ static int dvb_device_open(struct inode *inode, struct file *file)
 		new_fops = fops_get(dvbdev-&gt;fops);
 		if (!new_fops)
 			goto fail;
-		file-&gt;private_data = dvbdev;
+		file-&gt;private_data = dvb_device_get(dvbdev);
 		replace_fops(file, new_fops);
 		if (file-&gt;f_op-&gt;open)
 			err = file-&gt;f_op-&gt;open(inode, file);
@@ -161,6 +161,9 @@ int dvb_generic_release(struct inode *inode, struct file *file)
 	}
 
 	dvbdev-&gt;users++;
+
+	dvb_device_put(dvbdev);
+
 	return 0;
 }
 EXPORT_SYMBOL(dvb_generic_release);
@@ -479,6 +482,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 		return -ENOMEM;
 	}
 
+	kref_init(&amp;dvbdev-&gt;ref);
 	memcpy(dvbdev, template, sizeof(struct dvb_device));
 	dvbdev-&gt;type = type;
 	dvbdev-&gt;id = id;
@@ -510,7 +514,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 #endif
 
 	dvbdev-&gt;minor = minor;
-	dvb_minors[minor] = dvbdev;
+	dvb_minors[minor] = dvb_device_get(dvbdev);
 	up_write(&amp;minor_rwsem);
 
 	ret = dvb_register_media_device(dvbdev, type, minor, demux_sink_pads);
@@ -555,6 +559,7 @@ void dvb_remove_device(struct dvb_device *dvbdev)
 
 	down_write(&amp;minor_rwsem);
 	dvb_minors[dvbdev-&gt;minor] = NULL;
+	dvb_device_put(dvbdev);
 	up_write(&amp;minor_rwsem);
 
 	dvb_media_device_free(dvbdev);
@@ -566,21 +571,34 @@ void dvb_remove_device(struct dvb_device *dvbdev)
 EXPORT_SYMBOL(dvb_remove_device);
 
 
-void dvb_free_device(struct dvb_device *dvbdev)
+static void dvb_free_device(struct kref *ref)
 {
-	if (!dvbdev)
-		return;
+	struct dvb_device *dvbdev = container_of(ref, struct dvb_device, ref);
 
 	kfree (dvbdev-&gt;fops);
 	kfree (dvbdev);
 }
-EXPORT_SYMBOL(dvb_free_device);
+
+
+struct dvb_device *dvb_device_get(struct dvb_device *dvbdev)
+{
+	kref_get(&amp;dvbdev-&gt;ref);
+	return dvbdev;
+}
+EXPORT_SYMBOL(dvb_device_get);
+
+
+void dvb_device_put(struct dvb_device *dvbdev)
+{
+	if (dvbdev)
+		kref_put(&amp;dvbdev-&gt;ref, dvb_free_device);
+}
 
 
 void dvb_unregister_device(struct dvb_device *dvbdev)
 {
 	dvb_remove_device(dvbdev);
-	dvb_free_device(dvbdev);
+	dvb_device_put(dvbdev);
 }
 EXPORT_SYMBOL(dvb_unregister_device);
 
diff --git a/include/media/dvbdev.h b/include/media/dvbdev.h
index 6ccff7c6fa6b..fad9871157e2 100644
--- a/include/media/dvbdev.h
+++ b/include/media/dvbdev.h
@@ -160,6 +160,7 @@ struct dvb_adapter {
  */
 struct dvb_device {
 	struct list_head list_head;
+	struct kref ref;
 	const struct file_operations *fops;
 	struct dvb_adapter *adapter;
 	enum dvb_device_type type;
@@ -191,6 +192,20 @@ struct dvb_device {
 	void *priv;
 };
 
+/**
+ * dvb_device_get - Increase dvb_device reference
+ *
+ * @dvbdev:	pointer to struct dvb_device
+ */
+struct dvb_device *dvb_device_get(struct dvb_device *dvbdev);
+
+/**
+ * dvb_device_get - Decrease dvb_device reference
+ *
+ * @dvbdev:	pointer to struct dvb_device
+ */
+void dvb_device_put(struct dvb_device *dvbdev);
+
 /**
  * dvb_register_adapter - Registers a new DVB adapter
  *
@@ -235,29 +250,17 @@ int dvb_register_device(struct dvb_adapter *adap,
 /**
  * dvb_remove_device - Remove a registered DVB device
  *
- * This does not free memory.  To do that, call dvb_free_device().
+ * This does not free memory. dvb_free_device() will do that when
+ * reference counter is empty
  *
  * @dvbdev:	pointer to struct dvb_device
  */
 void dvb_remove_device(struct dvb_device *dvbdev);
 
-/**
- * dvb_free_device - Free memory occupied by a DVB device.
- *
- * Call dvb_unregister_device() before calling this function.
- *
- * @dvbdev:	pointer to struct dvb_device
- */
-void dvb_free_device(struct dvb_device *dvbdev);
 
 /**
  * dvb_unregister_device - Unregisters a DVB device
  *
- * This is a combination of dvb_remove_device() and dvb_free_device().
- * Using this function is usually a mistake, and is often an indicator
- * for a use-after-free bug (when a userspace process keeps a file
- * handle to a detached device).
- *
  * @dvbdev:	pointer to struct dvb_device
  */
 void dvb_unregister_device(struct dvb_device *dvbdev);</pre><hr><pre>commit 8dbd6e4ce1b9c527921643d9e34f188a10d4e893
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Wed Nov 23 18:06:42 2022 +0800

    qlcnic: fix sleep-in-atomic-context bugs caused by msleep
    
    The watchdog timer is used to monitor whether the process
    of transmitting data is timeout. If we use qlcnic driver,
    the dev_watchdog() that is the timer handler of watchdog
    timer will call qlcnic_tx_timeout() to process the timeout.
    But the qlcnic_tx_timeout() calls msleep(), as a result,
    the sleep-in-atomic-context bugs will happen. The processes
    are shown below:
    
       (atomic context)
    dev_watchdog
      qlcnic_tx_timeout
        qlcnic_83xx_idc_request_reset
          qlcnic_83xx_lock_driver
            msleep
    
    ---------------------------
    
       (atomic context)
    dev_watchdog
      qlcnic_tx_timeout
        qlcnic_83xx_idc_request_reset
          qlcnic_83xx_lock_driver
            qlcnic_83xx_recover_driver_lock
              msleep
    
    Fix by changing msleep() to mdelay(), the mdelay() is
    busy-waiting and the bugs could be mitigated.
    
    Fixes: 629263acaea3 ("qlcnic: 83xx CNA inter driver communication mechanism")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index bd0607680329..2fd5c6fdb500 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@ -2991,7 +2991,7 @@ static void qlcnic_83xx_recover_driver_lock(struct qlcnic_adapter *adapter)
 		QLCWRX(adapter-&gt;ahw, QLC_83XX_RECOVER_DRV_LOCK, val);
 		dev_info(&amp;adapter-&gt;pdev-&gt;dev,
 			 "%s: lock recovery initiated\n", __func__);
-		msleep(QLC_83XX_DRV_LOCK_RECOVERY_DELAY);
+		mdelay(QLC_83XX_DRV_LOCK_RECOVERY_DELAY);
 		val = QLCRDX(adapter-&gt;ahw, QLC_83XX_RECOVER_DRV_LOCK);
 		id = ((val &gt;&gt; 2) &amp; 0xF);
 		if (id == adapter-&gt;portnum) {
@@ -3027,7 +3027,7 @@ int qlcnic_83xx_lock_driver(struct qlcnic_adapter *adapter)
 		if (status)
 			break;
 
-		msleep(QLC_83XX_DRV_LOCK_WAIT_DELAY);
+		mdelay(QLC_83XX_DRV_LOCK_WAIT_DELAY);
 		i++;
 
 		if (i == 1)</pre><hr><pre>commit 4284354758d67cf77ab2a4494e28d4c05fb83074
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Tue Nov 22 22:21:26 2022 +0800

    elevator: remove an outdated comment in elevator_change
    
    mq is no longer a special case.
    
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/cbf47824fc726440371e74c867bf635ae1b671a3.1669126766.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index 5287b39cd7a9..599413620558 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -721,9 +721,6 @@ static int elevator_change(struct request_queue *q, const char *elevator_name)
 	if (!blk_queue_registered(q))
 		return -ENOENT;
 
-	/*
-	 * Special case for mq, turn off scheduling
-	 */
 	if (!strncmp(elevator_name, "none", 4)) {
 		if (q-&gt;elevator)
 			elevator_disable(q);</pre><hr><pre>commit f69b5e8f356e4e57e94b806ca1dcb9771933bb9c
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Tue Nov 22 22:21:25 2022 +0800

    elevator: update the document of elevator_match
    
    elevator_match does not care about elevator_features any more. Remove
    related descriptions from its document.
    
    Fixes: ffb86425ee2c ("block: don't check for required features in elevator_match")
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/a58424555202c07a9ccf7f60c3ad7e247da09e25.1669126766.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index 1fa45717b1d6..5287b39cd7a9 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -91,12 +91,11 @@ static inline bool elv_support_features(struct request_queue *q,
 }
 
 /**
- * elevator_match - Test an elevator name and features
+ * elevator_match - Check whether @e's name or alias matches @name
  * @e: Scheduler to test
  * @name: Elevator name to test
  *
- * Return true if the elevator @e name matches @name and if @e provides all
- * the features specified by @required_features.
+ * Return true if the elevator @e's name or alias matches @name.
  */
 static bool elevator_match(const struct elevator_type *e, const char *name)
 {</pre><hr><pre>commit e0cca8bc9cd8d6176921cb3f5f466d3ccfbc6b99
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Tue Nov 22 22:21:24 2022 +0800

    elevator: printk a warning if switching to a new io scheduler fails
    
    printk a warning to indicate that the io scheduler has been set to none
    if switching to a new io scheduler fails.
    
    Suggested-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/d51ed0fb457db7a4f9cbb0dbce36d534e22be457.1669126766.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index 01aa9f38f22e..1fa45717b1d6 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -683,6 +683,12 @@ int elevator_switch(struct request_queue *q, struct elevator_type *new_e)
 out_unfreeze:
 	blk_mq_unquiesce_queue(q);
 	blk_mq_unfreeze_queue(q);
+
+	if (ret) {
+		pr_warn("elv: switch to \"%s\" failed, falling back to \"none\"\n",
+			new_e-&gt;elevator_name);
+	}
+
 	return ret;
 }
 </pre><hr><pre>commit ac1171bd2c7a3a32dfbdd3c347919fee32b745a1
Author: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
Date:   Tue Nov 22 22:21:23 2022 +0800

    elevator: update the document of elevator_switch
    
    We no longer support falling back to the old io scheduler if switching to
    the new one fails. Update the document to indicate that.
    
    Fixes: a1ce35fa4985 ("block: remove dead elevator code")
    Signed-off-by: Jinlong Chen &lt;nickyc975@zju.edu.cn&gt;
    Reviewed-by: Christoph Hellwig &lt;hch@lst.de&gt;
    Link: https://lore.kernel.org/r/94250961689ba7d2e67a7d9e7995a11166fedb31.1669126766.git.nickyc975@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/block/elevator.c b/block/elevator.c
index a5bdc3b1e7e5..01aa9f38f22e 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -650,10 +650,10 @@ void elevator_init_mq(struct request_queue *q)
 }
 
 /*
- * switch to new_e io scheduler. be careful not to introduce deadlocks -
- * we don't free the old io scheduler, before we have allocated what we
- * need for the new one. this way we have a chance of going back to the old
- * one, if the new one fails init for some reason.
+ * Switch to new_e io scheduler.
+ *
+ * If switching fails, we are most likely running out of memory and not able
+ * to restore the old io scheduler, so leaving the io scheduler being none.
  */
 int elevator_switch(struct request_queue *q, struct elevator_type *new_e)
 {</pre><hr><pre>commit 23a6c9ac4dbd7cccf5b909e78aa84192b65f2833
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Nov 10 20:21:03 2022 +0800

    io_uring: update outdated comment of callbacks
    
    Previous commit ebc11b6c6b87 ("io_uring: clean io-wq callbacks") rename
    io_free_work() into io_wq_free_work() for consistency. This patch also
    updates relevant comment to avoid misunderstanding.
    
    Fixes: ebc11b6c6b87 ("io_uring: clean io-wq callbacks")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221110122103.20120-1-linma@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/io_uring/io_uring.c b/io_uring/io_uring.c
index cf68d16255a0..c770eed4d717 100644
--- a/io_uring/io_uring.c
+++ b/io_uring/io_uring.c
@@ -1781,7 +1781,7 @@ void io_wq_submit_work(struct io_wq_work *work)
 	bool needs_poll = false;
 	int ret = 0, err = -ECANCELED;
 
-	/* one will be dropped by -&gt;io_free_work() after returning to io-wq */
+	/* one will be dropped by -&gt;io_wq_free_work() after returning to io-wq */
 	if (!(req-&gt;flags &amp; REQ_F_REFCOUNT))
 		__io_req_set_refcount(req, 2);
 	else</pre><hr><pre>commit cd42a53d25d489317b9ae5213da721cde8cb7071
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Thu Nov 10 14:03:13 2022 +0800

    io_uring/poll: remove outdated comments of caching
    
    Previous commit 13a99017ff19 ("io_uring: remove events caching
    atavisms") entirely removes the events caching optimization introduced
    by commit 81459350d581 ("io_uring: cache req-&gt;apoll-&gt;events in
    req-&gt;cflags"). Hence the related comment should also be removed to avoid
    misunderstanding.
    
    Fixes: 13a99017ff19 ("io_uring: remove events caching atavisms")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221110060313.16303-1-linma@zju.edu.cn
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/io_uring/poll.c b/io_uring/poll.c
index 58e02d963961..8fb8e781c02d 100644
--- a/io_uring/poll.c
+++ b/io_uring/poll.c
@@ -324,12 +324,7 @@ static void io_apoll_task_func(struct io_kiocb *req, bool *locked)
 static void __io_poll_execute(struct io_kiocb *req, int mask)
 {
 	io_req_set_res(req, mask, 0);
-	/*
-	 * This is useful for poll that is armed on behalf of another
-	 * request, and where the wakeup path could be on a different
-	 * CPU. We want to avoid pulling in req-&gt;apoll-&gt;events for that
-	 * case.
-	 */
+
 	if (req-&gt;opcode == IORING_OP_POLL_ADD)
 		req-&gt;io_task_work.func = io_poll_task_func;
 	else</pre>
    <div class="pagination">
        <a href='6_12.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><span>[13]</span><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_14.html'>Next&gt;&gt;</a>
    <div>
</body>
