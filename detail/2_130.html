<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_129.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><span>[130]</span><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_131.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1bfc5d9d5eb8e1a2efacc306bc55c248ed259a8e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 9 15:26:18 2006 -0500

    [SCSI] Recognize missing LUNs for non-standard devices
    
    Some non-standard SCSI targets or protocols, such as USB UFI, report "no
    LUN present" by setting the Peripheral Device Type to 0x1f and the
    Peripheral Qualifier to 0 (not 3 as the standard requires) in the INQUIRY
    response.  This patch (as650b) adds a new target flag and code to
    accomodate such targets.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 803c7b9690c5..94b86d5b1469 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -853,6 +853,19 @@ static int scsi_probe_and_add_lun(struct scsi_target *starget,
 		goto out_free_result;
 	}
 
+	/*
+	 * Non-standard SCSI targets may set the PDT to 0x1f (unknown or
+	 * no device type) instead of using the Peripheral Qualifier to
+	 * indicate that no LUN is present.  For example, USB UFI does this.
+	 */
+	if (starget-&gt;pdt_1f_for_no_lun &amp;&amp; (result[0] &amp; 0x1f) == 0x1f) {
+		SCSI_LOG_SCAN_BUS(3, printk(KERN_INFO
+					"scsi scan: peripheral device type"
+					" of 31, no device added\n"));
+		res = SCSI_SCAN_TARGET_PRESENT;
+		goto out_free_result;
+	}
+
 	res = scsi_add_lun(sdev, result, &amp;bflags);
 	if (res == SCSI_SCAN_LUN_PRESENT) {
 		if (bflags &amp; BLIST_KEY) {
diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
index cde84b39bb65..8d77da932d2c 100644
--- a/include/scsi/scsi_device.h
+++ b/include/scsi/scsi_device.h
@@ -167,7 +167,10 @@ struct scsi_target {
 	unsigned int		channel;
 	unsigned int		id; /* target id ... replace
 				     * scsi_device.id eventually */
-	unsigned long		create:1; /* signal that it needs to be added */
+	unsigned int		create:1; /* signal that it needs to be added */
+	unsigned int		pdt_1f_for_no_lun;	/* PDT = 0x1f */
+						/* means no lun present */
+
 	char			scsi_level;
 	void 			*hostdata; /* available to low-level driver */
 	unsigned long		starget_data[0]; /* for the transport */</pre><hr><pre>commit 982db2a127b29c9e1f5896d2ba691e84446cc858
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 13 10:16:04 2006 -0500

    [PATCH] USB: unusual_devs.h entry: iAUDIO M5
    
    Another unusual_devs.h entry (as652).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 1d8a739ccc96..7e1cb03c2ed7 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1098,6 +1098,13 @@ UNUSUAL_DEV(  0x0dda, 0x0301, 0x0012, 0x0012,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
+/* Reported by Jim McCloskey &lt;mcclosk@ucsc.edu&gt; */
+UNUSUAL_DEV( 0x0e21, 0x0520, 0x0100, 0x0100,
+		"Cowon Systems",
+		"iAUDIO M5",
+		US_SC_DEVICE, US_PR_BULK, NULL,
+		0 ),
+
 /* Submitted by Antoine Mairesse &lt;antoine.mairesse@free.fr&gt; */
 UNUSUAL_DEV( 0x0ed1, 0x6660, 0x0100, 0x0300,
 		"USB",</pre><hr><pre>commit 1d614a4b0d2613d83f7bf0978e213ba29aebc44f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Feb 13 10:15:22 2006 -0500

    [PATCH] USB: unusual_devs.h entry: TrekStor i.Beat
    
    A new unusual_devs.h entry (as651).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 6e326159c2dd..1d8a739ccc96 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -106,6 +106,13 @@ UNUSUAL_DEV(  0x0411, 0x001c, 0x0113, 0x0113,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_INQUIRY ),
 
+/* Reported by Christian Leber &lt;christian@leber.de&gt; */
+UNUSUAL_DEV(  0x0419, 0xaaf5, 0x0100, 0x0100,
+		"TrekStor",
+		"i.Beat 115 2.0",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_IGNORE_RESIDUE | US_FL_NOT_LOCKABLE ),
+
 /* Reported by Stefan Werner &lt;dustbln@gmx.de&gt; */
 UNUSUAL_DEV(  0x0419, 0xaaf6, 0x0100, 0x0100,
 		"TrekStor",</pre><hr><pre>commit ba3e93ad3c6e511f68c1b3e46954feff6cdd5a62
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 30 10:19:43 2006 -0500

    [PATCH] usb-storage: unusual_devs entry
    
    Here is a new entry for unusual_devs.h (as630).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index c5d6d84b9b2b..6e326159c2dd 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -946,6 +946,12 @@ UNUSUAL_DEV(  0x084d, 0x0011, 0x0110, 0x0110,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_BULK32),
 
+/* Submitted by Jan De Luyck &lt;lkml@kcore.org&gt; */
+UNUSUAL_DEV(  0x08bd, 0x1100, 0x0000, 0x0000,
+		"CITIZEN",
+		"X1DE-USB",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_SINGLE_LUN),
 
 /* Entry needed for flags. Moreover, all devices with this ID use
  * bulk-only transport, but _some_ falsely report Control/Bulk instead.</pre><hr><pre>commit a2149bce2535047371a1309f032f0320b05db791
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 2 09:52:45 2006 -0500

    [PATCH] usb-storage: new unusual_devs entry
    
    This patch (as631) for unusual_devs.h fixes bugzilla entry 5913.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index ee958f986eb8..c5d6d84b9b2b 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -1162,6 +1162,13 @@ UNUSUAL_DEV(  0x55aa, 0xa103, 0x0000, 0x9999,
 		US_FL_SINGLE_LUN),
 #endif
 
+/* Reported by Andrew Simmons &lt;andrew.simmons@gmail.com&gt; */
+UNUSUAL_DEV(  0xed06, 0x4500, 0x0001, 0x0001,
+		"DataStor",
+		"USB4500 FW1.04",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY),
+
 /* Control/Bulk transport for all SubClass values */
 USUAL_DEV(US_SC_RBC, US_PR_CB, USB_US_TYPE_STOR),
 USUAL_DEV(US_SC_8020, US_PR_CB, USB_US_TYPE_STOR),</pre><hr><pre>commit 979063692726fa40863345fb1b62daf2f795ddc0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jan 3 10:30:31 2006 -0500

    [PATCH] USB: gadgetfs: set "zero" flag for short control-IN response
    
    This patch (as622) makes gadgetfs set the "zero" flag for control-IN
    responses, when the length of the response is shorter than the length of
    the request.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c
index 9a4edc5657aa..0aab7d24c768 100644
--- a/drivers/usb/gadget/inode.c
+++ b/drivers/usb/gadget/inode.c
@@ -135,6 +135,7 @@ struct dev_data {
 					setup_out_ready : 1,
 					setup_out_error : 1,
 					setup_abort : 1;
+	unsigned			setup_wLength;
 
 	/* the rest is basically write-once */
 	struct usb_config_descriptor	*config, *hs_config;
@@ -942,6 +943,7 @@ static int setup_req (struct usb_ep *ep, struct usb_request *req, u16 len)
 	}
 	req-&gt;complete = ep0_complete;
 	req-&gt;length = len;
+	req-&gt;zero = 0;
 	return 0;
 }
 
@@ -1161,10 +1163,13 @@ ep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
 				spin_unlock_irq (&amp;dev-&gt;lock);
 				if (copy_from_user (dev-&gt;req-&gt;buf, buf, len))
 					retval = -EFAULT;
-				else
+				else {
+					if (len &lt; dev-&gt;setup_wLength)
+						dev-&gt;req-&gt;zero = 1;
 					retval = usb_ep_queue (
 						dev-&gt;gadget-&gt;ep0, dev-&gt;req,
 						GFP_KERNEL);
+				}
 				if (retval &lt; 0) {
 					spin_lock_irq (&amp;dev-&gt;lock);
 					clean_req (dev-&gt;gadget-&gt;ep0, dev-&gt;req);
@@ -1483,6 +1488,7 @@ gadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)
 delegate:
 			dev-&gt;setup_in = (ctrl-&gt;bRequestType &amp; USB_DIR_IN)
 						? 1 : 0;
+			dev-&gt;setup_wLength = w_length;
 			dev-&gt;setup_out_ready = 0;
 			dev-&gt;setup_out_error = 0;
 			value = 0;</pre><hr><pre>commit 630aa3cfd5f0bae9547fe7dff175d7323d60140d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 23 17:17:21 2006 -0500

    [PATCH] USB: UHCI: No FSBR until device is configured
    
    Some USB devices don't enumerate well with FSBR turned on.  This patch
    keeps devices on the low-speed part of the schedule (which doesn't use
    FSBR) until they have been fully configured.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index b6076004a437..782398045f9f 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -672,9 +672,9 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	/* Low-speed transfers get a different queue, and won't hog the bus.
 	 * Also, some devices enumerate better without FSBR; the easiest way
 	 * to do that is to put URBs on the low-speed queue while the device
-	 * is in the DEFAULT state. */
+	 * isn't in the CONFIGURED state. */
 	if (urb-&gt;dev-&gt;speed == USB_SPEED_LOW ||
-			urb-&gt;dev-&gt;state == USB_STATE_DEFAULT)
+			urb-&gt;dev-&gt;state != USB_STATE_CONFIGURED)
 		skelqh = uhci-&gt;skel_ls_control_qh;
 	else {
 		skelqh = uhci-&gt;skel_fs_control_qh;</pre><hr><pre>commit bf74ad5bc41727d5f2f1c6bedb2c1fac394de731
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Nov 17 16:54:12 2005 -0500

    [PATCH] Hold the device's parent's lock during probe and remove
    
    This patch (as604) makes the driver core hold a device's parent's lock
    as well as the device's lock during calls to the probe and remove
    methods in a driver.  This facility is needed by USB device drivers,
    owing to the peculiar way USB devices work:
    
            A device provides multiple interfaces, and drivers are bound
            to interfaces rather than to devices;
    
            Nevertheless a reset, reset-configuration, suspend, or resume
            affects the entire device and requires the caller to hold the
            lock for the device, not just a lock for one of the interfaces.
    
    Since a USB driver's probe method is always called with the interface
    lock held, the locking order rules (always lock parent before child)
    prevent these methods from acquiring the device lock.  The solution
    provided here is to call all probe and remove methods, for all devices
    (not just USB), with the parent lock already acquired.
    
    Although currently only the USB subsystem requires these changes, people
    have mentioned in prior discussion that the overhead of acquiring an
    extra semaphore in all the prove/remove sequences is not overly large.
    
    Up to now, the USB core has been using its own set of private
    semaphores.  A followup patch will remove them, relying entirely on the
    device semaphores provided by the driver core.
    
    The code paths affected by this patch are:
    
            device_add and device_del: The USB core already holds the parent
            lock, so no actual change is needed.
    
            driver_register and driver_unregister: The driver core will now
            lock both the parent and the device before probing or removing.
    
            driver_bind and driver_unbind (in sysfs): These routines will
            now lock both the parent and the device before binding or
            unbinding.
    
            bus_rescan_devices: The helper routine will lock the parent
            before probing a device.
    
    I have not tested this patch for conflicts with other subsystems.  As
    far as I can see, the only possibility of conflict would lie in the
    bus_rescan_devices pathway, and it seems pretty remote.  Nevertheless,
    it would be good for this to get a lot of testing in -mm.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index fa601b085eba..e3f915a24891 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -152,7 +152,11 @@ static ssize_t driver_unbind(struct device_driver *drv,
 
 	dev = bus_find_device(bus, NULL, (void *)buf, driver_helper);
 	if (dev &amp;&amp; dev-&gt;driver == drv) {
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		device_release_driver(dev);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
 		err = count;
 	}
 	put_device(dev);
@@ -175,9 +179,13 @@ static ssize_t driver_bind(struct device_driver *drv,
 
 	dev = bus_find_device(bus, NULL, (void *)buf, driver_helper);
 	if (dev &amp;&amp; dev-&gt;driver == NULL) {
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		down(&amp;dev-&gt;sem);
 		err = driver_probe_device(drv, dev);
 		up(&amp;dev-&gt;sem);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
 	}
 	put_device(dev);
 	put_bus(bus);
@@ -484,8 +492,13 @@ void bus_remove_driver(struct device_driver * drv)
 /* Helper for bus_rescan_devices's iter */
 static int bus_rescan_devices_helper(struct device *dev, void *data)
 {
-	if (!dev-&gt;driver)
+	if (!dev-&gt;driver) {
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		device_attach(dev);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
+	}
 	return 0;
 }
 
diff --git a/drivers/base/dd.c b/drivers/base/dd.c
index 3b419c9a1e7e..2b905016664d 100644
--- a/drivers/base/dd.c
+++ b/drivers/base/dd.c
@@ -65,7 +65,8 @@ void device_bind_driver(struct device * dev)
  *	This function returns 1 if a match is found, an error if one
  *	occurs (that is not -ENODEV or -ENXIO), and 0 otherwise.
  *
- *	This function must be called with @dev-&gt;sem held.
+ *	This function must be called with @dev-&gt;sem held.  When called
+ *	for a USB interface, @dev-&gt;parent-&gt;sem must be held as well.
  */
 int driver_probe_device(struct device_driver * drv, struct device * dev)
 {
@@ -123,6 +124,8 @@ static int __device_attach(struct device_driver * drv, void * data)
  *
  *	Returns 1 if the device was bound to a driver;
  *	0 if no matching device was found; error code otherwise.
+ *
+ *	When called for a USB interface, @dev-&gt;parent-&gt;sem must be held.
  */
 int device_attach(struct device * dev)
 {
@@ -152,10 +155,14 @@ static int __driver_attach(struct device * dev, void * data)
 	 * is an error.
 	 */
 
+	if (dev-&gt;parent)	/* Needed for USB */
+		down(&amp;dev-&gt;parent-&gt;sem);
 	down(&amp;dev-&gt;sem);
 	if (!dev-&gt;driver)
 		driver_probe_device(drv, dev);
 	up(&amp;dev-&gt;sem);
+	if (dev-&gt;parent)
+		up(&amp;dev-&gt;parent-&gt;sem);
 
 	return 0;
 }
@@ -181,6 +188,8 @@ void driver_attach(struct device_driver * drv)
  *	Manually detach device from driver.
  *
  *	__device_release_driver() must be called with @dev-&gt;sem held.
+ *	When called for a USB interface, @dev-&gt;parent-&gt;sem must be held
+ *	as well.
  */
 
 static void __device_release_driver(struct device * dev)
@@ -233,10 +242,14 @@ void driver_detach(struct device_driver * drv)
 		get_device(dev);
 		spin_unlock(&amp;drv-&gt;klist_devices.k_lock);
 
+		if (dev-&gt;parent)	/* Needed for USB */
+			down(&amp;dev-&gt;parent-&gt;sem);
 		down(&amp;dev-&gt;sem);
 		if (dev-&gt;driver == drv)
 			__device_release_driver(dev);
 		up(&amp;dev-&gt;sem);
+		if (dev-&gt;parent)
+			up(&amp;dev-&gt;parent-&gt;sem);
 		put_device(dev);
 	}
 }</pre><hr><pre>commit f3d34ed48c80903544b509031fee64838d29f35f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 13 10:32:13 2005 -0500

    [PATCH] USB: fix local variable clash
    
    This patch (as621) fixes a local variable conflict I accidently
    introduced into usb_set_configuration.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 99ab774d4fdb..319de03944e7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1387,11 +1387,11 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (dev-&gt;state != USB_STATE_ADDRESS)
 		usb_disable_device (dev, 1);	// Skip ep0
 
-	n = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
-	if (n &lt; 0)
+	i = dev-&gt;bus_mA - cp-&gt;desc.bMaxPower * 2;
+	if (i &lt; 0)
 		dev_warn(&amp;dev-&gt;dev, "new config #%d exceeds power "
 				"limit by %dmA\n",
-				configuration, -n);
+				configuration, -i);
 
 	if ((ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
 			USB_REQ_SET_CONFIGURATION, 0, configuration, 0,</pre><hr><pre>commit 687f5f3428157bea4940dd967fd7b4e59c1b13b4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 30 17:16:19 2005 -0500

    [PATCH] USB: UHCI: edit some comments
    
    This patch (as615b) edits a large number of comments in the uhci-hcd code,
    mainly removing excess apostrophes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index cab02e15bfee..5832953086f8 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -2,8 +2,8 @@
  * UHCI-specific debugging code. Invaluable when something
  * goes wrong, but don't get in my face.
  *
- * Kernel visible pointers are surrounded in []'s and bus
- * visible pointers are surrounded in ()'s
+ * Kernel visible pointers are surrounded in []s and bus
+ * visible pointers are surrounded in ()s
  *
  * (C) Copyright 1999 Linus Torvalds
  * (C) Copyright 1999-2001 Johannes Erdfelt
@@ -19,7 +19,7 @@
 
 static struct dentry *uhci_debugfs_root = NULL;
 
-/* Handle REALLY large printk's so we don't overflow buffers */
+/* Handle REALLY large printks so we don't overflow buffers */
 static inline void lprintk(char *buf)
 {
 	char *p;
@@ -160,7 +160,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 			}
 
 			if (active &amp;&amp; ni &gt; i) {
-				out += sprintf(out, "%*s[skipped %d active TD's]\n", space, "", ni - i);
+				out += sprintf(out, "%*s[skipped %d active TDs]\n", space, "", ni - i);
 				tmp = ntmp;
 				td = ntd;
 				i = ni;
@@ -173,7 +173,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	if (list_empty(&amp;urbp-&gt;queue_list) || urbp-&gt;queued)
 		goto out;
 
-	out += sprintf(out, "%*sQueued QH's:\n", -space, "--");
+	out += sprintf(out, "%*sQueued QHs:\n", -space, "--");
 
 	head = &amp;urbp-&gt;queue_list;
 	tmp = head-&gt;next;
@@ -464,7 +464,7 @@ static int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)
 		} while (tmp != head);
 	}
 
-	out += sprintf(out, "Skeleton QH's\n");
+	out += sprintf(out, "Skeleton QHs\n");
 
 	for (i = 0; i &lt; UHCI_NUM_SKELQH; ++i) {
 		int shown = 0;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 120ca64fe3f7..dfe121d35887 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -62,10 +62,10 @@ Alan Stern"
 
 /*
  * debug = 0, no debugging messages
- * debug = 1, dump failed URB's except for stalls
- * debug = 2, dump all failed URB's (including stalls)
+ * debug = 1, dump failed URBs except for stalls
+ * debug = 2, dump all failed URBs (including stalls)
  *            show all queues in /debug/uhci/[pci_addr]
- * debug = 3, show all TD's in URB's when dumping
+ * debug = 3, show all TDs in URBs when dumping
  */
 #ifdef DEBUG
 static int debug = 1;
@@ -88,7 +88,7 @@ static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 #define FSBR_DELAY	msecs_to_jiffies(50)
 
 /* When we timeout an idle transfer for FSBR, we'll switch it over to */
-/* depth first traversal. We'll do it in groups of this number of TD's */
+/* depth first traversal. We'll do it in groups of this number of TDs */
 /* to make sure it doesn't hog all of the bandwidth */
 #define DEPTH_INTERVAL 5
 
@@ -728,8 +728,9 @@ static int uhci_resume(struct usb_hcd *hcd)
 
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
-	/* We aren't in D3 state anymore, we do that even if dead as I
-	 * really don't want to keep a stale HCD_FLAG_HW_ACCESSIBLE=0
+	/* Since we aren't in D3 any more, it's safe to set this flag
+	 * even if the controller was dead.  It might not even be dead
+	 * any more, if the firmware or quirks code has reset it.
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	mb();
@@ -879,7 +880,7 @@ static int __init uhci_hcd_init(void)
 
 init_failed:
 	if (kmem_cache_destroy(uhci_up_cachep))
-		warn("not all urb_priv's were freed!");
+		warn("not all urb_privs were freed!");
 
 up_failed:
 	debugfs_remove(uhci_debugfs_root);
@@ -897,7 +898,7 @@ static void __exit uhci_hcd_cleanup(void)
 	pci_unregister_driver(&amp;uhci_pci_driver);
 	
 	if (kmem_cache_destroy(uhci_up_cachep))
-		warn("not all urb_priv's were freed!");
+		warn("not all urb_privs were freed!");
 
 	debugfs_remove(uhci_debugfs_root);
 	kfree(errbuf);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index e43282e4e806..8b4b887a7d41 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -223,10 +223,10 @@ static u32 inline td_status(struct uhci_td *td) {
  */
 
 /*
- * The UHCI driver places Interrupt, Control and Bulk into QH's both
- * to group together TD's for one transfer, and also to faciliate queuing
- * of URB's. To make it easy to insert entries into the schedule, we have
- * a skeleton of QH's for each predefined Interrupt latency, low-speed
+ * The UHCI driver places Interrupt, Control and Bulk into QHs both
+ * to group together TDs for one transfer, and also to facilitate queuing
+ * of URBs. To make it easy to insert entries into the schedule, we have
+ * a skeleton of QHs for each predefined Interrupt latency, low-speed
  * control, full-speed control and terminating QH (see explanation for
  * the terminating QH below).
  *
@@ -257,8 +257,8 @@ static u32 inline td_status(struct uhci_td *td) {
  *   reclamation.
  *
  * Isochronous transfers are stored before the start of the skeleton
- * schedule and don't use QH's. While the UHCI spec doesn't forbid the
- * use of QH's for Isochronous, it doesn't use them either. And the spec
+ * schedule and don't use QHs. While the UHCI spec doesn't forbid the
+ * use of QHs for Isochronous, it doesn't use them either. And the spec
  * says that queues never advance on an error completion status, which
  * makes them totally unsuitable for Isochronous transfers.
  */
@@ -359,7 +359,7 @@ struct uhci_hcd {
 	struct dma_pool *td_pool;
 
 	struct uhci_td *term_td;	/* Terminating TD, see UHCI bug */
-	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QH's */
+	struct uhci_qh *skelqh[UHCI_NUM_SKELQH];	/* Skeleton QHs */
 
 	spinlock_t lock;
 
@@ -389,22 +389,22 @@ struct uhci_hcd {
 	unsigned long resuming_ports;
 	unsigned long ports_timeout;		/* Time to stop signalling */
 
-	/* Main list of URB's currently controlled by this HC */
+	/* Main list of URBs currently controlled by this HC */
 	struct list_head urb_list;
 
-	/* List of QH's that are done, but waiting to be unlinked (race) */
+	/* List of QHs that are done, but waiting to be unlinked (race) */
 	struct list_head qh_remove_list;
 	unsigned int qh_remove_age;		/* Age in frames */
 
-	/* List of TD's that are done, but waiting to be freed (race) */
+	/* List of TDs that are done, but waiting to be freed (race) */
 	struct list_head td_remove_list;
 	unsigned int td_remove_age;		/* Age in frames */
 
-	/* List of asynchronously unlinked URB's */
+	/* List of asynchronously unlinked URBs */
 	struct list_head urb_remove_list;
 	unsigned int urb_remove_age;		/* Age in frames */
 
-	/* List of URB's awaiting completion callback */
+	/* List of URBs awaiting completion callback */
 	struct list_head complete_list;
 
 	int rh_numports;			/* Number of root-hub ports */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index ace9d15f85d2..b6076004a437 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -80,7 +80,7 @@ static inline void uhci_fill_td(struct uhci_td *td, u32 status,
 }
 
 /*
- * We insert Isochronous URB's directly into the frame list at the beginning
+ * We insert Isochronous URBs directly into the frame list at the beginning
  */
 static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td, unsigned framenum)
 {
@@ -369,7 +369,7 @@ static void uhci_append_queued_urb(struct uhci_hcd *uhci, struct urb *eurb, stru
 				uhci_fixup_toggle(urb,
 					uhci_toggle(td_token(lltd)) ^ 1));
 
-	/* All qh's in the queue need to link to the next queue */
+	/* All qhs in the queue need to link to the next queue */
 	urbp-&gt;qh-&gt;link = eurbp-&gt;qh-&gt;link;
 
 	wmb();			/* Make sure we flush everything */
@@ -502,7 +502,7 @@ static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
 	}
 
 	/* Check to see if the remove list is empty. Set the IOC bit */
-	/* to force an interrupt so we can remove the TD's*/
+	/* to force an interrupt so we can remove the TDs*/
 	if (list_empty(&amp;uhci-&gt;td_remove_list))
 		uhci_set_next_interrupt(uhci);
 
@@ -612,7 +612,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb, struct ur
 	}
 
 	/*
-	 * Build the DATA TD's
+	 * Build the DATA TDs
 	 */
 	while (len &gt; 0) {
 		int pktsze = len;
@@ -744,7 +744,7 @@ static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
 
 	urb-&gt;actual_length = 0;
 
-	/* The rest of the TD's (but the last) are data */
+	/* The rest of the TDs (but the last) are data */
 	tmp = tmp-&gt;next;
 	while (tmp != head &amp;&amp; tmp-&gt;next != head) {
 		unsigned int ctrlstat;
@@ -848,7 +848,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb, struct urb
 		status |= TD_CTRL_SPD;
 
 	/*
-	 * Build the DATA TD's
+	 * Build the DATA TDs
 	 */
 	do {	/* Allow zero length packets */
 		int pktsze = maxsze;
@@ -1025,7 +1025,7 @@ static int isochronous_find_limits(struct uhci_hcd *uhci, struct urb *urb, unsig
 	list_for_each_entry(up, &amp;uhci-&gt;urb_list, urb_list) {
 		struct urb *u = up-&gt;urb;
 
-		/* look for pending URB's with identical pipe handle */
+		/* look for pending URBs with identical pipe handle */
 		if ((urb-&gt;pipe == u-&gt;pipe) &amp;&amp; (urb-&gt;dev == u-&gt;dev) &amp;&amp;
 		    (u-&gt;status == -EINPROGRESS) &amp;&amp; (u != urb)) {
 			if (!last_urb)
@@ -1355,7 +1355,7 @@ static void uhci_unlink_generic(struct uhci_hcd *uhci, struct urb *urb)
 
 	uhci_delete_queued_urb(uhci, urb);
 
-	/* The interrupt loop will reclaim the QH's */
+	/* The interrupt loop will reclaim the QHs */
 	uhci_remove_qh(uhci, urbp-&gt;qh);
 	urbp-&gt;qh = NULL;
 }
@@ -1413,7 +1413,7 @@ static int uhci_fsbr_timeout(struct uhci_hcd *uhci, struct urb *urb)
 	list_for_each_entry(td, head, list) {
 		/*
 		 * Make sure we don't do the last one (since it'll have the
-		 * TERM bit set) as well as we skip every so many TD's to
+		 * TERM bit set) as well as we skip every so many TDs to
 		 * make sure it doesn't hog the bandwidth
 		 */
 		if (td-&gt;list.next != head &amp;&amp; (count % DEPTH_INTERVAL) ==</pre>
    <div class="pagination">
        <a href='2_129.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><span>[130]</span><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_131.html'>Next&gt;&gt;</a>
    <div>
</body>
