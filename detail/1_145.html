<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_144.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><span>[145]</span><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_146.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit eec99016e38b740662509f097effb90abc7a1376
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Wed Nov 27 12:38:42 2013 -0500

    drm/nouveau/hwmon: fix compilation without CONFIG_HWMON
    
    Reported-by: Jim Davis &lt;jim.epost@gmail.com&gt;
    Tested-by: Jim Davis &lt;jim.epost@gmail.com&gt;
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Dave Airlie &lt;airlied@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nouveau_hwmon.c b/drivers/gpu/drm/nouveau/nouveau_hwmon.c
index 38a4db5bfe21..4aff04fa483c 100644
--- a/drivers/gpu/drm/nouveau/nouveau_hwmon.c
+++ b/drivers/gpu/drm/nouveau/nouveau_hwmon.c
@@ -630,7 +630,6 @@ nouveau_hwmon_init(struct drm_device *dev)
 	hwmon-&gt;hwmon = NULL;
 	return ret;
 #else
-	hwmon-&gt;hwmon = NULL;
 	return 0;
 #endif
 }</pre><hr><pre>commit fd34381b0e2827228cbda45aa2cca4127ff073b2
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sun Oct 27 11:54:09 2013 -0400

    drm/nouveau/agp: add a quirk list to limit agp modes
    
    Certain combinations of hardware can't actually support the maximum
    detected speed. Add a quirk list that lists pairs of hostbridge/chip pci
    ids and the mode that they should work with.
    
    See https://bugs.freedesktop.org/show_bug.cgi?id=20341
    
    Reported-by: Jason Detring &lt;detringj@gmail.com&gt;
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nouveau_agp.c b/drivers/gpu/drm/nouveau/nouveau_agp.c
index 6e7a55f93a85..2953c4e91e1a 100644
--- a/drivers/gpu/drm/nouveau/nouveau_agp.c
+++ b/drivers/gpu/drm/nouveau/nouveau_agp.c
@@ -11,10 +11,28 @@ MODULE_PARM_DESC(agpmode, "AGP mode (0 to disable AGP)");
 static int nouveau_agpmode = -1;
 module_param_named(agpmode, nouveau_agpmode, int, 0400);
 
+struct nouveau_agpmode_quirk {
+	u16 hostbridge_vendor;
+	u16 hostbridge_device;
+	u16 chip_vendor;
+	u16 chip_device;
+	int mode;
+};
+
+static struct nouveau_agpmode_quirk nouveau_agpmode_quirk_list[] = {
+	/* VIA Apollo PRO133x / GeForce FX 5600 Ultra, max agpmode 2, fdo #20341 */
+	{ PCI_VENDOR_ID_VIA, 0x0691, PCI_VENDOR_ID_NVIDIA, 0x0311, 2 },
+
+	{},
+};
+
 static unsigned long
-get_agp_mode(struct nouveau_drm *drm, unsigned long mode)
+get_agp_mode(struct nouveau_drm *drm, const struct drm_agp_info *info)
 {
 	struct nouveau_device *device = nv_device(drm-&gt;device);
+	struct nouveau_agpmode_quirk *quirk = nouveau_agpmode_quirk_list;
+	int agpmode = nouveau_agpmode;
+	unsigned long mode = info-&gt;mode;
 
 	/*
 	 * FW seems to be broken on nv18, it makes the card lock up
@@ -23,12 +41,28 @@ get_agp_mode(struct nouveau_drm *drm, unsigned long mode)
 	if (device-&gt;chipset == 0x18)
 		mode &amp;= ~PCI_AGP_COMMAND_FW;
 
+	/*
+	 * Go through the quirks list and adjust the agpmode accordingly.
+	 */
+	while (agpmode == -1 &amp;&amp; quirk-&gt;hostbridge_vendor) {
+		if (info-&gt;id_vendor == quirk-&gt;hostbridge_vendor &amp;&amp;
+		    info-&gt;id_device == quirk-&gt;hostbridge_device &amp;&amp;
+		    device-&gt;pdev-&gt;vendor == quirk-&gt;chip_vendor &amp;&amp;
+		    device-&gt;pdev-&gt;device == quirk-&gt;chip_device) {
+			agpmode = quirk-&gt;mode;
+			nv_info(device, "Forcing agp mode to %dX. Use agpmode to override.\n",
+				agpmode);
+			break;
+		}
+		++quirk;
+	}
+
 	/*
 	 * AGP mode set in the command line.
 	 */
-	if (nouveau_agpmode &gt; 0) {
+	if (agpmode &gt; 0) {
 		bool agpv3 = mode &amp; 0x8;
-		int rate = agpv3 ? nouveau_agpmode / 4 : nouveau_agpmode;
+		int rate = agpv3 ? agpmode / 4 : agpmode;
 
 		mode = (mode &amp; ~0x7) | (rate &amp; 0x7);
 	}
@@ -90,7 +124,7 @@ nouveau_agp_reset(struct nouveau_drm *drm)
 		if (ret)
 			return;
 
-		mode.mode  = get_agp_mode(drm, info.mode);
+		mode.mode  = get_agp_mode(drm, &amp;info);
 		mode.mode &amp;= ~PCI_AGP_COMMAND_FW;
 
 		ret = drm_agp_enable(dev, mode);
@@ -139,7 +173,7 @@ nouveau_agp_init(struct nouveau_drm *drm)
 	}
 
 	/* see agp.h for the AGPSTAT_* modes available */
-	mode.mode = get_agp_mode(drm, info.mode);
+	mode.mode = get_agp_mode(drm, &amp;info);
 
 	ret = drm_agp_enable(dev, mode);
 	if (ret) {</pre><hr><pre>commit be0dd4ddefebb35915979e280047eb6f5ecc3235
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Sep 7 21:04:12 2013 -0400

    drm/nv31/mpeg: split the nv31 and nv40 dma setting implementations
    
    NV31 has different config bits than NV40+ do. Also fix the DMA_IMAGE
    VRAM-only setting to check the right bits.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
index 9330fc42bd89..77b630867010 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
@@ -80,18 +80,18 @@ nv31_mpeg_mthd_dma(struct nouveau_object *object, u32 mthd, void *arg, u32 len)
 
 	if (mthd == 0x0190) {
 		/* DMA_CMD */
-		nv_mask(priv, 0x00b300, 0x00030000, (dma0 &amp; 0x00030000));
+		nv_mask(priv, 0x00b300, 0x00010000, (dma0 &amp; 0x00030000) ? 0x00010000 : 0);
 		nv_wr32(priv, 0x00b334, base);
 		nv_wr32(priv, 0x00b324, size);
 	} else
 	if (mthd == 0x01a0) {
 		/* DMA_DATA */
-		nv_mask(priv, 0x00b300, 0x000c0000, (dma0 &amp; 0x00030000) &lt;&lt; 2);
+		nv_mask(priv, 0x00b300, 0x00020000, (dma0 &amp; 0x00030000) ? 0x00020000 : 0);
 		nv_wr32(priv, 0x00b360, base);
 		nv_wr32(priv, 0x00b364, size);
 	} else {
 		/* DMA_IMAGE, VRAM only */
-		if (dma0 &amp; 0x000c0000)
+		if (dma0 &amp; 0x00030000)
 			return -EINVAL;
 
 		nv_wr32(priv, 0x00b370, base);
@@ -101,7 +101,7 @@ nv31_mpeg_mthd_dma(struct nouveau_object *object, u32 mthd, void *arg, u32 len)
 	return 0;
 }
 
-static struct nouveau_ofuncs
+struct nouveau_ofuncs
 nv31_mpeg_ofuncs = {
 	.ctor = nv31_mpeg_object_ctor,
 	.dtor = _nouveau_gpuobj_dtor,
diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c
index 26f3262c0b2a..d4e7ec0ba68c 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c
@@ -33,6 +33,63 @@
 #include &lt;engine/mpeg.h&gt;
 #include &lt;engine/mpeg/nv31.h&gt;
 
+/*******************************************************************************
+ * MPEG object classes
+ ******************************************************************************/
+
+static int
+nv40_mpeg_mthd_dma(struct nouveau_object *object, u32 mthd, void *arg, u32 len)
+{
+	struct nouveau_instmem *imem = nouveau_instmem(object);
+	struct nv31_mpeg_priv *priv = (void *)object-&gt;engine;
+	u32 inst = *(u32 *)arg &lt;&lt; 4;
+	u32 dma0 = nv_ro32(imem, inst + 0);
+	u32 dma1 = nv_ro32(imem, inst + 4);
+	u32 dma2 = nv_ro32(imem, inst + 8);
+	u32 base = (dma2 &amp; 0xfffff000) | (dma0 &gt;&gt; 20);
+	u32 size = dma1 + 1;
+
+	/* only allow linear DMA objects */
+	if (!(dma0 &amp; 0x00002000))
+		return -EINVAL;
+
+	if (mthd == 0x0190) {
+		/* DMA_CMD */
+		nv_mask(priv, 0x00b300, 0x00030000, (dma0 &amp; 0x00030000));
+		nv_wr32(priv, 0x00b334, base);
+		nv_wr32(priv, 0x00b324, size);
+	} else
+	if (mthd == 0x01a0) {
+		/* DMA_DATA */
+		nv_mask(priv, 0x00b300, 0x000c0000, (dma0 &amp; 0x00030000) &lt;&lt; 2);
+		nv_wr32(priv, 0x00b360, base);
+		nv_wr32(priv, 0x00b364, size);
+	} else {
+		/* DMA_IMAGE, VRAM only */
+		if (dma0 &amp; 0x00030000)
+			return -EINVAL;
+
+		nv_wr32(priv, 0x00b370, base);
+		nv_wr32(priv, 0x00b374, size);
+	}
+
+	return 0;
+}
+
+static struct nouveau_omthds
+nv40_mpeg_omthds[] = {
+	{ 0x0190, 0x0190, nv40_mpeg_mthd_dma },
+	{ 0x01a0, 0x01a0, nv40_mpeg_mthd_dma },
+	{ 0x01b0, 0x01b0, nv40_mpeg_mthd_dma },
+	{}
+};
+
+struct nouveau_oclass
+nv40_mpeg_sclass[] = {
+	{ 0x3174, &amp;nv31_mpeg_ofuncs, nv40_mpeg_omthds },
+	{}
+};
+
 /*******************************************************************************
  * PMPEG engine/subdev functions
  ******************************************************************************/
@@ -68,7 +125,7 @@ nv40_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	nv_subdev(priv)-&gt;unit = 0x00000002;
 	nv_subdev(priv)-&gt;intr = nv40_mpeg_intr;
 	nv_engine(priv)-&gt;cclass = &amp;nv31_mpeg_cclass;
-	nv_engine(priv)-&gt;sclass = nv31_mpeg_sclass;
+	nv_engine(priv)-&gt;sclass = nv40_mpeg_sclass;
 	nv_engine(priv)-&gt;tile_prog = nv31_mpeg_tile_prog;
 	return 0;
 }
diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv44.c
index 012b95d5d4c3..3d8c2133e0e8 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv44.c
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv44.c
@@ -177,7 +177,7 @@ nv44_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	nv_subdev(priv)-&gt;unit = 0x00000002;
 	nv_subdev(priv)-&gt;intr = nv44_mpeg_me_intr;
 	nv_engine(priv)-&gt;cclass = &amp;nv44_mpeg_cclass;
-	nv_engine(priv)-&gt;sclass = nv31_mpeg_sclass;
+	nv_engine(priv)-&gt;sclass = nv40_mpeg_sclass;
 	nv_engine(priv)-&gt;tile_prog = nv31_mpeg_tile_prog;
 	return 0;
 }
diff --git a/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h b/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
index 8b7560e2ec19..9b0d938199f6 100644
--- a/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
+++ b/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
@@ -45,8 +45,10 @@ extern struct nouveau_oclass nv40_mpeg_oclass;
 extern struct nouveau_oclass nv44_mpeg_oclass;
 extern struct nouveau_oclass nv50_mpeg_oclass;
 extern struct nouveau_oclass nv84_mpeg_oclass;
+extern struct nouveau_ofuncs nv31_mpeg_ofuncs;
 extern struct nouveau_oclass nv31_mpeg_cclass;
 extern struct nouveau_oclass nv31_mpeg_sclass[];
+extern struct nouveau_oclass nv40_mpeg_sclass[];
 void nv31_mpeg_intr(struct nouveau_subdev *);
 void nv31_mpeg_tile_prog(struct nouveau_engine *, int);
 int  nv31_mpeg_init(struct nouveau_object *);</pre><hr><pre>commit e6585cab68a71a6025f7b6ace2681ebb866a030e
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Sep 7 21:04:11 2013 -0400

    drm/nv31/mpeg: store chan singleton in engine, use it for dispatch
    
    This makes nv31+ able to actually perform the nv_call, since previously
    the inst was not available.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
index 2f80b2232232..9330fc42bd89 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
@@ -147,6 +147,8 @@ nv31_mpeg_context_ctor(struct nouveau_object *parent,
 	if (ret)
 		return ret;
 
+	priv-&gt;chan = chan;
+
 	return 0;
 }
 
@@ -155,8 +157,11 @@ nv31_mpeg_context_dtor(struct nouveau_object *object)
 {
 	struct nv31_mpeg_priv *priv = (void *)object-&gt;engine;
 	struct nv31_mpeg_chan *chan = (void *)object;
-	atomic_dec(&amp;priv-&gt;refcount);
+
+	WARN_ON(priv-&gt;chan != chan);
+	priv-&gt;chan = NULL;
 	nouveau_object_destroy(&amp;chan-&gt;base);
+	atomic_dec(&amp;priv-&gt;refcount);
 }
 
 struct nouveau_oclass
@@ -189,20 +194,19 @@ void
 nv31_mpeg_intr(struct nouveau_subdev *subdev)
 {
 	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
-	struct nouveau_engine *engine = nv_engine(subdev);
-	struct nouveau_object *engctx;
 	struct nouveau_handle *handle;
 	struct nv31_mpeg_priv *priv = (void *)subdev;
-	u32 inst = nv_rd32(priv, 0x00b318) &amp; 0x000fffff;
+	struct nouveau_object *engctx = &amp;priv-&gt;chan-&gt;base;
 	u32 stat = nv_rd32(priv, 0x00b100);
 	u32 type = nv_rd32(priv, 0x00b230);
 	u32 mthd = nv_rd32(priv, 0x00b234);
 	u32 data = nv_rd32(priv, 0x00b238);
 	u32 show = stat;
-	int chid;
+	int chid = pfifo-&gt;chid(pfifo, engctx);
 
-	engctx = nouveau_engctx_get(engine, inst);
-	chid   = pfifo-&gt;chid(pfifo, engctx);
+	if (engctx)
+		if (nouveau_object_inc(engctx))
+			engctx = NULL;
 
 	if (stat &amp; 0x01000000) {
 		/* happens on initial binding of the object */
@@ -211,7 +215,7 @@ nv31_mpeg_intr(struct nouveau_subdev *subdev)
 			show &amp;= ~0x01000000;
 		}
 
-		if (type == 0x00000010) {
+		if (type == 0x00000010 &amp;&amp; engctx) {
 			handle = nouveau_handle_get_class(engctx, 0x3174);
 			if (handle &amp;&amp; !nv_call(handle-&gt;object, mthd, data))
 				show &amp;= ~0x01000000;
@@ -224,12 +228,13 @@ nv31_mpeg_intr(struct nouveau_subdev *subdev)
 
 	if (show) {
 		nv_error(priv,
-			 "ch %d [0x%08x %s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
-			 chid, inst &lt;&lt; 4, nouveau_client_name(engctx), stat,
+			 "ch %d [%s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+			 chid, nouveau_client_name(engctx), stat,
 			 type, mthd, data);
 	}
 
-	nouveau_engctx_put(engctx);
+	if (engctx)
+		WARN_ON(nouveau_object_dec(engctx, false));
 }
 
 static int
diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.h b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.h
index a488c13bffd6..62d04e475315 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.h
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.h
@@ -3,13 +3,14 @@
 
 #include &lt;engine/mpeg.h&gt;
 
+struct nv31_mpeg_chan {
+	struct nouveau_object base;
+};
+
 struct nv31_mpeg_priv {
 	struct nouveau_mpeg base;
 	atomic_t refcount;
-};
-
-struct nv31_mpeg_chan {
-	struct nouveau_object base;
+	struct nv31_mpeg_chan *chan;
 };
 
 #endif</pre><hr><pre>commit 912de74c811fa5ba523bf1e525ce8ce45ecfeed4
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Sep 7 21:04:10 2013 -0400

    drm/nv40/mpeg: use the nv31-provided classes
    
    Since nv40 only covers pre-nv44 now, it can use the nv31-provided
    functions.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
index 5c54aa10cc0a..2f80b2232232 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
@@ -34,15 +34,7 @@
 
 #include &lt;engine/fifo.h&gt;
 #include &lt;engine/mpeg.h&gt;
-
-struct nv31_mpeg_priv {
-	struct nouveau_mpeg base;
-	atomic_t refcount;
-};
-
-struct nv31_mpeg_chan {
-	struct nouveau_object base;
-};
+#include &lt;engine/mpeg/nv31.h&gt;
 
 /*******************************************************************************
  * MPEG object classes
@@ -167,7 +159,7 @@ nv31_mpeg_context_dtor(struct nouveau_object *object)
 	nouveau_object_destroy(&amp;chan-&gt;base);
 }
 
-static struct nouveau_oclass
+struct nouveau_oclass
 nv31_mpeg_cclass = {
 	.handle = NV_ENGCTX(MPEG, 0x31),
 	.ofuncs = &amp;(struct nouveau_ofuncs) {
diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.h b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.h
new file mode 100644
index 000000000000..a488c13bffd6
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.h
@@ -0,0 +1,15 @@
+#ifndef __NV31_MPEG_H__
+#define __NV31_MPEG_H__
+
+#include &lt;engine/mpeg.h&gt;
+
+struct nv31_mpeg_priv {
+	struct nouveau_mpeg base;
+	atomic_t refcount;
+};
+
+struct nv31_mpeg_chan {
+	struct nouveau_object base;
+};
+
+#endif
diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c
index dd6196072e9c..26f3262c0b2a 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv40.c
@@ -31,67 +31,7 @@
 #include &lt;subdev/instmem.h&gt;
 
 #include &lt;engine/mpeg.h&gt;
-#include &lt;engine/graph/nv40.h&gt;
-
-struct nv40_mpeg_priv {
-	struct nouveau_mpeg base;
-};
-
-struct nv40_mpeg_chan {
-	struct nouveau_mpeg_chan base;
-};
-
-/*******************************************************************************
- * PMPEG context
- ******************************************************************************/
-
-static int
-nv40_mpeg_context_ctor(struct nouveau_object *parent,
-		       struct nouveau_object *engine,
-		       struct nouveau_oclass *oclass, void *data, u32 size,
-		       struct nouveau_object **pobject)
-{
-	struct nv40_mpeg_chan *chan;
-	int ret;
-
-	ret = nouveau_mpeg_context_create(parent, engine, oclass, NULL,
-					  264 * 4, 16,
-					  NVOBJ_FLAG_ZERO_ALLOC, &amp;chan);
-	*pobject = nv_object(chan);
-	if (ret)
-		return ret;
-
-	nv_wo32(&amp;chan-&gt;base.base, 0x78, 0x02001ec1);
-	return 0;
-}
-
-static int
-nv40_mpeg_context_fini(struct nouveau_object *object, bool suspend)
-{
-
-	struct nv40_mpeg_priv *priv = (void *)object-&gt;engine;
-	struct nv40_mpeg_chan *chan = (void *)object;
-	u32 inst = 0x80000000 | nv_gpuobj(chan)-&gt;addr &gt;&gt; 4;
-
-	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000000);
-	if (nv_rd32(priv, 0x00b318) == inst)
-		nv_mask(priv, 0x00b318, 0x80000000, 0x00000000);
-	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);
-	return 0;
-}
-
-static struct nouveau_oclass
-nv40_mpeg_cclass = {
-	.handle = NV_ENGCTX(MPEG, 0x40),
-	.ofuncs = &amp;(struct nouveau_ofuncs) {
-		.ctor = nv40_mpeg_context_ctor,
-		.dtor = _nouveau_mpeg_context_dtor,
-		.init = _nouveau_mpeg_context_init,
-		.fini = nv40_mpeg_context_fini,
-		.rd32 = _nouveau_mpeg_context_rd32,
-		.wr32 = _nouveau_mpeg_context_wr32,
-	},
-};
+#include &lt;engine/mpeg/nv31.h&gt;
 
 /*******************************************************************************
  * PMPEG engine/subdev functions
@@ -100,7 +40,7 @@ nv40_mpeg_cclass = {
 static void
 nv40_mpeg_intr(struct nouveau_subdev *subdev)
 {
-	struct nv40_mpeg_priv *priv = (void *)subdev;
+	struct nv31_mpeg_priv *priv = (void *)subdev;
 	u32 stat;
 
 	if ((stat = nv_rd32(priv, 0x00b100)))
@@ -117,7 +57,7 @@ nv40_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 	       struct nouveau_oclass *oclass, void *data, u32 size,
 	       struct nouveau_object **pobject)
 {
-	struct nv40_mpeg_priv *priv;
+	struct nv31_mpeg_priv *priv;
 	int ret;
 
 	ret = nouveau_mpeg_create(parent, engine, oclass, &amp;priv);
@@ -127,7 +67,7 @@ nv40_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 
 	nv_subdev(priv)-&gt;unit = 0x00000002;
 	nv_subdev(priv)-&gt;intr = nv40_mpeg_intr;
-	nv_engine(priv)-&gt;cclass = &amp;nv40_mpeg_cclass;
+	nv_engine(priv)-&gt;cclass = &amp;nv31_mpeg_cclass;
 	nv_engine(priv)-&gt;sclass = nv31_mpeg_sclass;
 	nv_engine(priv)-&gt;tile_prog = nv31_mpeg_tile_prog;
 	return 0;
diff --git a/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h b/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
index 6f4263dfa578..8b7560e2ec19 100644
--- a/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
+++ b/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
@@ -45,7 +45,7 @@ extern struct nouveau_oclass nv40_mpeg_oclass;
 extern struct nouveau_oclass nv44_mpeg_oclass;
 extern struct nouveau_oclass nv50_mpeg_oclass;
 extern struct nouveau_oclass nv84_mpeg_oclass;
-
+extern struct nouveau_oclass nv31_mpeg_cclass;
 extern struct nouveau_oclass nv31_mpeg_sclass[];
 void nv31_mpeg_intr(struct nouveau_subdev *);
 void nv31_mpeg_tile_prog(struct nouveau_engine *, int);</pre><hr><pre>commit 5fa7543041cbc2d3139e8d2178df61a33ac3f9ac
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Sep 7 21:04:09 2013 -0400

    drm/nv44/mpeg: create a copy of the nv31/nv40 impls
    
    The nv31/nv40 impls are actually fairly nv44-specific, since they assume
    the presence of the instance register/context switching. Create a copy
    before nv31/nv40 get fixed.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/Makefile b/drivers/gpu/drm/nouveau/Makefile
index d939a1da3203..56b35b2dc691 100644
--- a/drivers/gpu/drm/nouveau/Makefile
+++ b/drivers/gpu/drm/nouveau/Makefile
@@ -227,6 +227,7 @@ nouveau-y += core/engine/graph/nve4.o
 nouveau-y += core/engine/graph/nvf0.o
 nouveau-y += core/engine/mpeg/nv31.o
 nouveau-y += core/engine/mpeg/nv40.o
+nouveau-y += core/engine/mpeg/nv44.o
 nouveau-y += core/engine/mpeg/nv50.o
 nouveau-y += core/engine/mpeg/nv84.o
 nouveau-y += core/engine/ppp/nv98.o
diff --git a/drivers/gpu/drm/nouveau/core/engine/device/nv40.c b/drivers/gpu/drm/nouveau/core/engine/device/nv40.c
index 0f3225142168..c0d79435bdff 100644
--- a/drivers/gpu/drm/nouveau/core/engine/device/nv40.c
+++ b/drivers/gpu/drm/nouveau/core/engine/device/nv40.c
@@ -150,7 +150,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x47:
@@ -171,7 +171,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x49:
@@ -192,7 +192,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x4b:
@@ -213,7 +213,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x44:
@@ -234,7 +234,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x46:
@@ -255,7 +255,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x4a:
@@ -276,7 +276,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x4c:
@@ -297,7 +297,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x4e:
@@ -318,7 +318,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x63:
@@ -339,7 +339,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x67:
@@ -360,7 +360,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	case 0x68:
@@ -381,7 +381,7 @@ nv40_identify(struct nouveau_device *device)
 		device-&gt;oclass[NVDEV_ENGINE_FIFO   ] = &amp;nv40_fifo_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_SW     ] =  nv10_software_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_GR     ] = &amp;nv40_graph_oclass;
-		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv40_mpeg_oclass;
+		device-&gt;oclass[NVDEV_ENGINE_MPEG   ] = &amp;nv44_mpeg_oclass;
 		device-&gt;oclass[NVDEV_ENGINE_DISP   ] = &amp;nv04_disp_oclass;
 		break;
 	default:
diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv44.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv44.c
new file mode 100644
index 000000000000..012b95d5d4c3
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv44.c
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2012 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Ben Skeggs
+ */
+
+#include &lt;core/os.h&gt;
+#include &lt;core/class.h&gt;
+#include &lt;core/client.h&gt;
+#include &lt;core/engctx.h&gt;
+#include &lt;core/handle.h&gt;
+
+#include &lt;subdev/fb.h&gt;
+#include &lt;subdev/timer.h&gt;
+#include &lt;subdev/instmem.h&gt;
+
+#include &lt;engine/fifo.h&gt;
+#include &lt;engine/mpeg.h&gt;
+
+struct nv44_mpeg_priv {
+	struct nouveau_mpeg base;
+};
+
+struct nv44_mpeg_chan {
+	struct nouveau_mpeg_chan base;
+};
+
+/*******************************************************************************
+ * PMPEG context
+ ******************************************************************************/
+
+static int
+nv44_mpeg_context_ctor(struct nouveau_object *parent,
+		       struct nouveau_object *engine,
+		       struct nouveau_oclass *oclass, void *data, u32 size,
+		       struct nouveau_object **pobject)
+{
+	struct nv44_mpeg_chan *chan;
+	int ret;
+
+	ret = nouveau_mpeg_context_create(parent, engine, oclass, NULL,
+					  264 * 4, 16,
+					  NVOBJ_FLAG_ZERO_ALLOC, &amp;chan);
+	*pobject = nv_object(chan);
+	if (ret)
+		return ret;
+
+	nv_wo32(&amp;chan-&gt;base.base, 0x78, 0x02001ec1);
+	return 0;
+}
+
+static int
+nv44_mpeg_context_fini(struct nouveau_object *object, bool suspend)
+{
+
+	struct nv44_mpeg_priv *priv = (void *)object-&gt;engine;
+	struct nv44_mpeg_chan *chan = (void *)object;
+	u32 inst = 0x80000000 | nv_gpuobj(chan)-&gt;addr &gt;&gt; 4;
+
+	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000000);
+	if (nv_rd32(priv, 0x00b318) == inst)
+		nv_mask(priv, 0x00b318, 0x80000000, 0x00000000);
+	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);
+	return 0;
+}
+
+static struct nouveau_oclass
+nv44_mpeg_cclass = {
+	.handle = NV_ENGCTX(MPEG, 0x44),
+	.ofuncs = &amp;(struct nouveau_ofuncs) {
+		.ctor = nv44_mpeg_context_ctor,
+		.dtor = _nouveau_mpeg_context_dtor,
+		.init = _nouveau_mpeg_context_init,
+		.fini = nv44_mpeg_context_fini,
+		.rd32 = _nouveau_mpeg_context_rd32,
+		.wr32 = _nouveau_mpeg_context_wr32,
+	},
+};
+
+/*******************************************************************************
+ * PMPEG engine/subdev functions
+ ******************************************************************************/
+
+static void
+nv44_mpeg_intr(struct nouveau_subdev *subdev)
+{
+	struct nouveau_fifo *pfifo = nouveau_fifo(subdev);
+	struct nouveau_engine *engine = nv_engine(subdev);
+	struct nouveau_object *engctx;
+	struct nouveau_handle *handle;
+	struct nv44_mpeg_priv *priv = (void *)subdev;
+	u32 inst = nv_rd32(priv, 0x00b318) &amp; 0x000fffff;
+	u32 stat = nv_rd32(priv, 0x00b100);
+	u32 type = nv_rd32(priv, 0x00b230);
+	u32 mthd = nv_rd32(priv, 0x00b234);
+	u32 data = nv_rd32(priv, 0x00b238);
+	u32 show = stat;
+	int chid;
+
+	engctx = nouveau_engctx_get(engine, inst);
+	chid   = pfifo-&gt;chid(pfifo, engctx);
+
+	if (stat &amp; 0x01000000) {
+		/* happens on initial binding of the object */
+		if (type == 0x00000020 &amp;&amp; mthd == 0x0000) {
+			nv_mask(priv, 0x00b308, 0x00000000, 0x00000000);
+			show &amp;= ~0x01000000;
+		}
+
+		if (type == 0x00000010) {
+			handle = nouveau_handle_get_class(engctx, 0x3174);
+			if (handle &amp;&amp; !nv_call(handle-&gt;object, mthd, data))
+				show &amp;= ~0x01000000;
+			nouveau_handle_put(handle);
+		}
+	}
+
+	nv_wr32(priv, 0x00b100, stat);
+	nv_wr32(priv, 0x00b230, 0x00000001);
+
+	if (show) {
+		nv_error(priv,
+			 "ch %d [0x%08x %s] 0x%08x 0x%08x 0x%08x 0x%08x\n",
+			 chid, inst &lt;&lt; 4, nouveau_client_name(engctx), stat,
+			 type, mthd, data);
+	}
+
+	nouveau_engctx_put(engctx);
+}
+
+static void
+nv44_mpeg_me_intr(struct nouveau_subdev *subdev)
+{
+	struct nv44_mpeg_priv *priv = (void *)subdev;
+	u32 stat;
+
+	if ((stat = nv_rd32(priv, 0x00b100)))
+		nv44_mpeg_intr(subdev);
+
+	if ((stat = nv_rd32(priv, 0x00b800))) {
+		nv_error(priv, "PMSRCH 0x%08x\n", stat);
+		nv_wr32(priv, 0x00b800, stat);
+	}
+}
+
+static int
+nv44_mpeg_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
+	       struct nouveau_oclass *oclass, void *data, u32 size,
+	       struct nouveau_object **pobject)
+{
+	struct nv44_mpeg_priv *priv;
+	int ret;
+
+	ret = nouveau_mpeg_create(parent, engine, oclass, &amp;priv);
+	*pobject = nv_object(priv);
+	if (ret)
+		return ret;
+
+	nv_subdev(priv)-&gt;unit = 0x00000002;
+	nv_subdev(priv)-&gt;intr = nv44_mpeg_me_intr;
+	nv_engine(priv)-&gt;cclass = &amp;nv44_mpeg_cclass;
+	nv_engine(priv)-&gt;sclass = nv31_mpeg_sclass;
+	nv_engine(priv)-&gt;tile_prog = nv31_mpeg_tile_prog;
+	return 0;
+}
+
+struct nouveau_oclass
+nv44_mpeg_oclass = {
+	.handle = NV_ENGINE(MPEG, 0x44),
+	.ofuncs = &amp;(struct nouveau_ofuncs) {
+		.ctor = nv44_mpeg_ctor,
+		.dtor = _nouveau_mpeg_dtor,
+		.init = nv31_mpeg_init,
+		.fini = _nouveau_mpeg_fini,
+	},
+};
diff --git a/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h b/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
index 1d1a89a06ee4..6f4263dfa578 100644
--- a/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
+++ b/drivers/gpu/drm/nouveau/core/include/engine/mpeg.h
@@ -42,6 +42,7 @@ struct nouveau_mpeg {
 
 extern struct nouveau_oclass nv31_mpeg_oclass;
 extern struct nouveau_oclass nv40_mpeg_oclass;
+extern struct nouveau_oclass nv44_mpeg_oclass;
 extern struct nouveau_oclass nv50_mpeg_oclass;
 extern struct nouveau_oclass nv84_mpeg_oclass;
 </pre><hr><pre>commit be4ba550461fbb90a75390b3f001a8fa27e4c70e
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Sep 7 21:04:08 2013 -0400

    drm/nv31/mpeg: no need to set compat mode differently for nv44 gr
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
index c19004301309..5c54aa10cc0a 100644
--- a/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
+++ b/drivers/gpu/drm/nouveau/core/engine/mpeg/nv31.c
@@ -34,7 +34,6 @@
 
 #include &lt;engine/fifo.h&gt;
 #include &lt;engine/mpeg.h&gt;
-#include &lt;engine/graph/nv40.h&gt;
 
 struct nv31_mpeg_priv {
 	struct nouveau_mpeg base;
@@ -284,10 +283,7 @@ nv31_mpeg_init(struct nouveau_object *object)
 	/* PMPEG init */
 	nv_wr32(priv, 0x00b32c, 0x00000000);
 	nv_wr32(priv, 0x00b314, 0x00000100);
-	if (nv_device(priv)-&gt;chipset &gt;= 0x40 &amp;&amp; nv44_graph_class(priv))
-		nv_wr32(priv, 0x00b220, 0x00000044);
-	else
-		nv_wr32(priv, 0x00b220, 0x00000031);
+	nv_wr32(priv, 0x00b220, 0x00000031);
 	nv_wr32(priv, 0x00b300, 0x02001ec1);
 	nv_mask(priv, 0x00b32c, 0x00000001, 0x00000001);
 </pre><hr><pre>commit 515de6b27f96fb7ff58f34bda6e1be44a6f9e46d
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Sep 7 20:33:43 2013 -0400

    drm/nv10/kms: add plane support for nv10-nv40
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/disp/nv04.c b/drivers/gpu/drm/nouveau/core/engine/disp/nv04.c
index 05e903f08a36..a0bc8a89b699 100644
--- a/drivers/gpu/drm/nouveau/core/engine/disp/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/engine/disp/nv04.c
@@ -59,6 +59,7 @@ nv04_disp_intr(struct nouveau_subdev *subdev)
 	struct nv04_disp_priv *priv = (void *)subdev;
 	u32 crtc0 = nv_rd32(priv, 0x600100);
 	u32 crtc1 = nv_rd32(priv, 0x602100);
+	u32 pvideo;
 
 	if (crtc0 &amp; 0x00000001) {
 		nouveau_event_trigger(priv-&gt;base.vblank, 0);
@@ -69,6 +70,14 @@ nv04_disp_intr(struct nouveau_subdev *subdev)
 		nouveau_event_trigger(priv-&gt;base.vblank, 1);
 		nv_wr32(priv, 0x602100, 0x00000001);
 	}
+
+	if (nv_device(priv)-&gt;chipset &gt;= 0x10 &amp;&amp;
+	    nv_device(priv)-&gt;chipset &lt;= 0x40) {
+		pvideo = nv_rd32(priv, 0x8100);
+		if (pvideo &amp; ~0x11)
+			nv_info(priv, "PVIDEO intr: %08x\n", pvideo);
+		nv_wr32(priv, 0x8100, pvideo);
+	}
 }
 
 static int
diff --git a/drivers/gpu/drm/nouveau/core/subdev/mc/nv04.c b/drivers/gpu/drm/nouveau/core/subdev/mc/nv04.c
index 64aa4edb0d9d..062c0489fd5e 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/mc/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/mc/nv04.c
@@ -33,6 +33,7 @@ nv04_mc_intr[] = {
 	{ 0x00000001, NVDEV_ENGINE_MPEG },	/* NV17- MPEG/ME */
 	{ 0x00000100, NVDEV_ENGINE_FIFO },
 	{ 0x00001000, NVDEV_ENGINE_GR },
+	{ 0x00010000, NVDEV_ENGINE_DISP },
 	{ 0x00020000, NVDEV_ENGINE_VP },	/* NV40- */
 	{ 0x00100000, NVDEV_SUBDEV_TIMER },
 	{ 0x01000000, NVDEV_ENGINE_DISP },	/* NV04- PCRTC0 */
diff --git a/drivers/gpu/drm/nouveau/dispnv04/Makefile b/drivers/gpu/drm/nouveau/dispnv04/Makefile
index ea3f5b8a0f95..424a489d0f03 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/Makefile
+++ b/drivers/gpu/drm/nouveau/dispnv04/Makefile
@@ -5,6 +5,7 @@ nouveau-y += dispnv04/dac.o
 nouveau-y += dispnv04/dfp.o
 nouveau-y += dispnv04/disp.o
 nouveau-y += dispnv04/hw.o
+nouveau-y += dispnv04/overlay.o
 nouveau-y += dispnv04/tvmodesnv17.o
 nouveau-y += dispnv04/tvnv04.o
 nouveau-y += dispnv04/tvnv17.o
diff --git a/drivers/gpu/drm/nouveau/dispnv04/disp.c b/drivers/gpu/drm/nouveau/dispnv04/disp.c
index 4908d3fd0486..b13ff0fc42de 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/disp.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/disp.c
@@ -140,6 +140,8 @@ nv04_display_create(struct drm_device *dev)
 		func-&gt;save(encoder);
 	}
 
+	nouveau_overlay_init(dev);
+
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/nouveau/dispnv04/disp.h b/drivers/gpu/drm/nouveau/dispnv04/disp.h
index 2cf65e0b517e..56a28db04000 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/disp.h
+++ b/drivers/gpu/drm/nouveau/dispnv04/disp.h
@@ -123,6 +123,9 @@ int nv04_tv_create(struct drm_connector *, struct dcb_output *);
 /* nv17_tv.c */
 int nv17_tv_create(struct drm_connector *, struct dcb_output *);
 
+/* overlay.c */
+void nouveau_overlay_init(struct drm_device *dev);
+
 static inline bool
 nv_two_heads(struct drm_device *dev)
 {
diff --git a/drivers/gpu/drm/nouveau/dispnv04/hw.c b/drivers/gpu/drm/nouveau/dispnv04/hw.c
index 3d51ae9070f8..aca76af115b3 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/hw.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/hw.c
@@ -27,6 +27,7 @@
 #include "hw.h"
 
 #include &lt;subdev/bios/pll.h&gt;
+#include &lt;subdev/fb.h&gt;
 #include &lt;subdev/clock.h&gt;
 #include &lt;subdev/timer.h&gt;
 
@@ -664,6 +665,7 @@ nv_load_state_ext(struct drm_device *dev, int head,
 	struct nouveau_drm *drm = nouveau_drm(dev);
 	struct nouveau_device *device = nv_device(drm-&gt;device);
 	struct nouveau_timer *ptimer = nouveau_timer(device);
+	struct nouveau_fb *pfb = nouveau_fb(device);
 	struct nv04_crtc_reg *regp = &amp;state-&gt;crtc_reg[head];
 	uint32_t reg900;
 	int i;
@@ -680,10 +682,10 @@ nv_load_state_ext(struct drm_device *dev, int head,
 		nv_wr32(device, NV_PVIDEO_INTR_EN, 0);
 		nv_wr32(device, NV_PVIDEO_OFFSET_BUFF(0), 0);
 		nv_wr32(device, NV_PVIDEO_OFFSET_BUFF(1), 0);
-		nv_wr32(device, NV_PVIDEO_LIMIT(0), 0); //drm-&gt;fb_available_size - 1);
-		nv_wr32(device, NV_PVIDEO_LIMIT(1), 0); //drm-&gt;fb_available_size - 1);
-		nv_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(0), 0); //drm-&gt;fb_available_size - 1);
-		nv_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(1), 0); //drm-&gt;fb_available_size - 1);
+		nv_wr32(device, NV_PVIDEO_LIMIT(0), pfb-&gt;ram-&gt;size - 1);
+		nv_wr32(device, NV_PVIDEO_LIMIT(1), pfb-&gt;ram-&gt;size - 1);
+		nv_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(0), pfb-&gt;ram-&gt;size - 1);
+		nv_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(1), pfb-&gt;ram-&gt;size - 1);
 		nv_wr32(device, NV_PBUS_POWERCTRL_2, 0);
 
 		NVWriteCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG, regp-&gt;cursor_cfg);
diff --git a/drivers/gpu/drm/nouveau/dispnv04/overlay.c b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
new file mode 100644
index 000000000000..3618ac6b6316
--- /dev/null
+++ b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
@@ -0,0 +1,320 @@
+/*
+ * Copyright 2013 Ilia Mirkin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Implementation based on the pre-KMS implementation in xf86-video-nouveau,
+ * written by Arthur Huillet.
+ */
+
+#include &lt;drm/drmP.h&gt;
+#include &lt;drm/drm_crtc.h&gt;
+#include &lt;drm/drm_fourcc.h&gt;
+
+#include "nouveau_drm.h"
+
+#include "nouveau_bo.h"
+#include "nouveau_connector.h"
+#include "nouveau_display.h"
+#include "nvreg.h"
+
+
+struct nouveau_plane {
+	struct drm_plane base;
+	bool flip;
+	struct nouveau_bo *cur;
+
+	struct {
+		struct drm_property *colorkey;
+		struct drm_property *contrast;
+		struct drm_property *brightness;
+		struct drm_property *hue;
+		struct drm_property *saturation;
+		struct drm_property *iturbt_709;
+	} props;
+
+	int colorkey;
+	int contrast;
+	int brightness;
+	int hue;
+	int saturation;
+	int iturbt_709;
+};
+
+static uint32_t formats[] = {
+	DRM_FORMAT_NV12,
+	DRM_FORMAT_UYVY,
+};
+
+/* Sine can be approximated with
+ * http://en.wikipedia.org/wiki/Bhaskara_I's_sine_approximation_formula
+ * sin(x degrees) ~= 4 x (180 - x) / (40500 - x (180 - x) )
+ * Note that this only works for the range [0, 180].
+ * Also note that sin(x) == -sin(x - 180)
+ */
+static inline int
+sin_mul(int degrees, int factor)
+{
+	if (degrees &gt; 180) {
+		degrees -= 180;
+		factor *= -1;
+	}
+	return factor * 4 * degrees * (180 - degrees) /
+		(40500 - degrees * (180 - degrees));
+}
+
+/* cos(x) = sin(x + 90) */
+static inline int
+cos_mul(int degrees, int factor)
+{
+	return sin_mul((degrees + 90) % 360, factor);
+}
+
+static int
+nv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
+		  struct drm_framebuffer *fb, int crtc_x, int crtc_y,
+		  unsigned int crtc_w, unsigned int crtc_h,
+		  uint32_t src_x, uint32_t src_y,
+		  uint32_t src_w, uint32_t src_h)
+{
+	struct nouveau_device *dev = nouveau_dev(plane-&gt;dev);
+	struct nouveau_plane *nv_plane = (struct nouveau_plane *)plane;
+	struct nouveau_framebuffer *nv_fb = nouveau_framebuffer(fb);
+	struct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);
+	struct nouveau_bo *cur = nv_plane-&gt;cur;
+	bool flip = nv_plane-&gt;flip;
+	int format = ALIGN(src_w * 4, 0x100);
+	int soff = NV_PCRTC0_SIZE * nv_crtc-&gt;index;
+	int soff2 = NV_PCRTC0_SIZE * !nv_crtc-&gt;index;
+	int ret;
+
+	if (format &gt; 0xffff)
+		return -EINVAL;
+
+	ret = nouveau_bo_pin(nv_fb-&gt;nvbo, TTM_PL_FLAG_VRAM);
+	if (ret)
+		return ret;
+
+	nv_plane-&gt;cur = nv_fb-&gt;nvbo;
+
+	/* Source parameters given in 16.16 fixed point, ignore fractional. */
+	src_x = src_x &gt;&gt; 16;
+	src_y = src_y &gt;&gt; 16;
+	src_w = src_w &gt;&gt; 16;
+	src_h = src_h &gt;&gt; 16;
+
+	nv_mask(dev, NV_PCRTC_ENGINE_CTRL + soff, NV_CRTC_FSEL_OVERLAY, NV_CRTC_FSEL_OVERLAY);
+	nv_mask(dev, NV_PCRTC_ENGINE_CTRL + soff2, NV_CRTC_FSEL_OVERLAY, 0);
+
+	nv_wr32(dev, NV_PVIDEO_BASE(flip), 0);
+	nv_wr32(dev, NV_PVIDEO_OFFSET_BUFF(flip), nv_fb-&gt;nvbo-&gt;bo.offset);
+	nv_wr32(dev, NV_PVIDEO_SIZE_IN(flip), src_h &lt;&lt; 16 | src_w);
+	nv_wr32(dev, NV_PVIDEO_POINT_IN(flip), src_y &lt;&lt; 16 | src_x);
+	nv_wr32(dev, NV_PVIDEO_DS_DX(flip), (src_w &lt;&lt; 20) / crtc_w);
+	nv_wr32(dev, NV_PVIDEO_DT_DY(flip), (src_h &lt;&lt; 20) / crtc_h);
+	nv_wr32(dev, NV_PVIDEO_POINT_OUT(flip), crtc_y &lt;&lt; 16 | crtc_x);
+	nv_wr32(dev, NV_PVIDEO_SIZE_OUT(flip), crtc_h &lt;&lt; 16 | crtc_w);
+
+	if (fb-&gt;pixel_format == DRM_FORMAT_NV12) {
+		format |= NV_PVIDEO_FORMAT_COLOR_LE_CR8YB8CB8YA8;
+		format |= NV_PVIDEO_FORMAT_PLANAR;
+	}
+	if (nv_plane-&gt;iturbt_709)
+		format |= NV_PVIDEO_FORMAT_MATRIX_ITURBT709;
+	if (nv_plane-&gt;colorkey &amp; (1 &lt;&lt; 24))
+		format |= NV_PVIDEO_FORMAT_DISPLAY_COLOR_KEY;
+
+	if (fb-&gt;pixel_format == DRM_FORMAT_NV12) {
+		nv_wr32(dev, NV_PVIDEO_UVPLANE_BASE(flip), 0);
+		nv_wr32(dev, NV_PVIDEO_UVPLANE_OFFSET_BUFF(flip),
+			nv_fb-&gt;nvbo-&gt;bo.offset + fb-&gt;offsets[1]);
+	}
+	nv_wr32(dev, NV_PVIDEO_FORMAT(flip), format);
+	nv_wr32(dev, NV_PVIDEO_STOP, 0);
+	/* TODO: wait for vblank? */
+	nv_wr32(dev, NV_PVIDEO_BUFFER, flip ? 0x10 : 0x1);
+	nv_plane-&gt;flip = !flip;
+
+	if (cur)
+		nouveau_bo_unpin(cur);
+
+	return 0;
+}
+
+static int
+nv10_disable_plane(struct drm_plane *plane)
+{
+	struct nouveau_device *dev = nouveau_dev(plane-&gt;dev);
+	struct nouveau_plane *nv_plane = (struct nouveau_plane *)plane;
+
+	nv_wr32(dev, NV_PVIDEO_STOP, 1);
+	if (nv_plane-&gt;cur) {
+		nouveau_bo_unpin(nv_plane-&gt;cur);
+		nv_plane-&gt;cur = NULL;
+	}
+
+	return 0;
+}
+
+static void
+nv10_destroy_plane(struct drm_plane *plane)
+{
+	nv10_disable_plane(plane);
+	drm_plane_cleanup(plane);
+	kfree(plane);
+}
+
+static void
+nv10_set_params(struct nouveau_plane *plane)
+{
+	struct nouveau_device *dev = nouveau_dev(plane-&gt;base.dev);
+	u32 luma = (plane-&gt;brightness - 512) &lt;&lt; 16 | plane-&gt;contrast;
+	u32 chroma = ((sin_mul(plane-&gt;hue, plane-&gt;saturation) &amp; 0xffff) &lt;&lt; 16) |
+		(cos_mul(plane-&gt;hue, plane-&gt;saturation) &amp; 0xffff);
+	u32 format = 0;
+
+	nv_wr32(dev, NV_PVIDEO_LUMINANCE(0), luma);
+	nv_wr32(dev, NV_PVIDEO_LUMINANCE(1), luma);
+	nv_wr32(dev, NV_PVIDEO_CHROMINANCE(0), chroma);
+	nv_wr32(dev, NV_PVIDEO_CHROMINANCE(1), chroma);
+	nv_wr32(dev, NV_PVIDEO_COLOR_KEY, plane-&gt;colorkey &amp; 0xffffff);
+
+	if (plane-&gt;cur) {
+		if (plane-&gt;iturbt_709)
+			format |= NV_PVIDEO_FORMAT_MATRIX_ITURBT709;
+		if (plane-&gt;colorkey &amp; (1 &lt;&lt; 24))
+			format |= NV_PVIDEO_FORMAT_DISPLAY_COLOR_KEY;
+		nv_mask(dev, NV_PVIDEO_FORMAT(plane-&gt;flip),
+			NV_PVIDEO_FORMAT_MATRIX_ITURBT709 |
+			NV_PVIDEO_FORMAT_DISPLAY_COLOR_KEY,
+			format);
+	}
+}
+
+static int
+nv10_set_property(struct drm_plane *plane,
+		  struct drm_property *property,
+		  uint64_t value)
+{
+	struct nouveau_plane *nv_plane = (struct nouveau_plane *)plane;
+
+	if (property == nv_plane-&gt;props.colorkey)
+		nv_plane-&gt;colorkey = value;
+	else if (property == nv_plane-&gt;props.contrast)
+		nv_plane-&gt;contrast = value;
+	else if (property == nv_plane-&gt;props.brightness)
+		nv_plane-&gt;brightness = value;
+	else if (property == nv_plane-&gt;props.hue)
+		nv_plane-&gt;hue = value;
+	else if (property == nv_plane-&gt;props.saturation)
+		nv_plane-&gt;saturation = value;
+	else if (property == nv_plane-&gt;props.iturbt_709)
+		nv_plane-&gt;iturbt_709 = value;
+	else
+		return -EINVAL;
+
+	nv10_set_params(nv_plane);
+	return 0;
+}
+
+static const struct drm_plane_funcs nv10_plane_funcs = {
+	.update_plane = nv10_update_plane,
+	.disable_plane = nv10_disable_plane,
+	.set_property = nv10_set_property,
+	.destroy = nv10_destroy_plane,
+};
+
+static void
+nv10_overlay_init(struct drm_device *device)
+{
+	struct nouveau_device *dev = nouveau_dev(device);
+	struct nouveau_plane *plane = kzalloc(sizeof(struct nouveau_plane), GFP_KERNEL);
+	int ret;
+
+	if (!plane)
+		return;
+
+	ret = drm_plane_init(device, &amp;plane-&gt;base, 3 /* both crtc's */,
+			     &amp;nv10_plane_funcs,
+			     formats, ARRAY_SIZE(formats), false);
+	if (ret)
+		goto err;
+
+	/* Set up the plane properties */
+	plane-&gt;props.colorkey = drm_property_create_range(
+			device, 0, "colorkey", 0, 0x01ffffff);
+	plane-&gt;props.contrast = drm_property_create_range(
+			device, 0, "contrast", 0, 8192 - 1);
+	plane-&gt;props.brightness = drm_property_create_range(
+			device, 0, "brightness", 0, 1024);
+	plane-&gt;props.hue = drm_property_create_range(
+			device, 0, "hue", 0, 359);
+	plane-&gt;props.saturation = drm_property_create_range(
+			device, 0, "saturation", 0, 8192 - 1);
+	plane-&gt;props.iturbt_709 = drm_property_create_range(
+			device, 0, "iturbt_709", 0, 1);
+	if (!plane-&gt;props.colorkey ||
+	    !plane-&gt;props.contrast ||
+	    !plane-&gt;props.brightness ||
+	    !plane-&gt;props.hue ||
+	    !plane-&gt;props.saturation ||
+	    !plane-&gt;props.iturbt_709)
+		goto cleanup;
+
+	plane-&gt;colorkey = 0;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.colorkey, plane-&gt;colorkey);
+
+	plane-&gt;contrast = 0x1000;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.contrast, plane-&gt;contrast);
+
+	plane-&gt;brightness = 512;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.brightness, plane-&gt;brightness);
+
+	plane-&gt;hue = 0;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.hue, plane-&gt;hue);
+
+	plane-&gt;saturation = 0x1000;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.saturation, plane-&gt;saturation);
+
+	plane-&gt;iturbt_709 = 0;
+	drm_object_attach_property(&amp;plane-&gt;base.base,
+				   plane-&gt;props.iturbt_709, plane-&gt;iturbt_709);
+
+	nv10_set_params(plane);
+	nv_wr32(dev, NV_PVIDEO_STOP, 1);
+	return;
+cleanup:
+	drm_plane_cleanup(&amp;plane-&gt;base);
+err:
+	kfree(plane);
+	nv_error(dev, "Failed to create plane\n");
+}
+
+void
+nouveau_overlay_init(struct drm_device *device)
+{
+	struct nouveau_device *dev = nouveau_dev(device);
+	if (dev-&gt;chipset &gt;= 0x10 &amp;&amp; dev-&gt;chipset &lt;= 0x40)
+		nv10_overlay_init(device);
+}</pre><hr><pre>commit 8aa816b0bbcefa8517d7e10586d7dbb0ead3c4c1
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Thu Sep 5 04:45:03 2013 -0400

    drm/nv10: fix chipset checks, mostly for the benefit of nv1a
    
    NV1A is numerically higher than NV17 but generationally lower. Use the
    new card type to help disambiguate.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/device/base.c b/drivers/gpu/drm/nouveau/core/engine/device/base.c
index f8b4fbf55889..de1e9eca0151 100644
--- a/drivers/gpu/drm/nouveau/core/engine/device/base.c
+++ b/drivers/gpu/drm/nouveau/core/engine/device/base.c
@@ -219,7 +219,7 @@ nouveau_devobj_ctor(struct nouveau_object *parent,
 		nv_info(device, "Family : NV%02X\n", device-&gt;card_type);
 
 		/* determine frequency of timing crystal */
-		if ( device-&gt;chipset &lt; 0x17 ||
+		if ( device-&gt;card_type &lt;= NV_10 || device-&gt;chipset &lt; 0x17 ||
 		    (device-&gt;chipset &gt;= 0x20 &amp;&amp; device-&gt;chipset &lt; 0x25))
 			strap &amp;= 0x00000040;
 		else
diff --git a/drivers/gpu/drm/nouveau/core/engine/graph/nv10.c b/drivers/gpu/drm/nouveau/core/engine/graph/nv10.c
index 23c143aaa556..4532f7e5618c 100644
--- a/drivers/gpu/drm/nouveau/core/engine/graph/nv10.c
+++ b/drivers/gpu/drm/nouveau/core/engine/graph/nv10.c
@@ -945,7 +945,8 @@ nv10_graph_load_context(struct nv10_graph_chan *chan, int chid)
 	for (i = 0; i &lt; ARRAY_SIZE(nv10_graph_ctx_regs); i++)
 		nv_wr32(priv, nv10_graph_ctx_regs[i], chan-&gt;nv10[i]);
 
-	if (nv_device(priv)-&gt;chipset &gt;= 0x17) {
+	if (nv_device(priv)-&gt;card_type &gt;= NV_11 &amp;&amp;
+	    nv_device(priv)-&gt;chipset &gt;= 0x17) {
 		for (i = 0; i &lt; ARRAY_SIZE(nv17_graph_ctx_regs); i++)
 			nv_wr32(priv, nv17_graph_ctx_regs[i], chan-&gt;nv17[i]);
 	}
@@ -970,7 +971,8 @@ nv10_graph_unload_context(struct nv10_graph_chan *chan)
 	for (i = 0; i &lt; ARRAY_SIZE(nv10_graph_ctx_regs); i++)
 		chan-&gt;nv10[i] = nv_rd32(priv, nv10_graph_ctx_regs[i]);
 
-	if (nv_device(priv)-&gt;chipset &gt;= 0x17) {
+	if (nv_device(priv)-&gt;card_type &gt;= NV_11 &amp;&amp;
+	    nv_device(priv)-&gt;chipset &gt;= 0x17) {
 		for (i = 0; i &lt; ARRAY_SIZE(nv17_graph_ctx_regs); i++)
 			chan-&gt;nv17[i] = nv_rd32(priv, nv17_graph_ctx_regs[i]);
 	}
@@ -1052,7 +1054,8 @@ nv10_graph_context_ctor(struct nouveau_object *parent,
 	NV_WRITE_CTX(0x00400e14, 0x00001000);
 	NV_WRITE_CTX(0x00400e30, 0x00080008);
 	NV_WRITE_CTX(0x00400e34, 0x00080008);
-	if (nv_device(priv)-&gt;chipset &gt;= 0x17) {
+	if (nv_device(priv)-&gt;card_type &gt;= NV_11 &amp;&amp;
+	    nv_device(priv)-&gt;chipset &gt;= 0x17) {
 		/* is it really needed ??? */
 		NV17_WRITE_CTX(NV10_PGRAPH_DEBUG_4,
 					nv_rd32(priv, NV10_PGRAPH_DEBUG_4));
@@ -1231,7 +1234,7 @@ nv10_graph_ctor(struct nouveau_object *parent, struct nouveau_object *engine,
 		nv_engine(priv)-&gt;sclass = nv10_graph_sclass;
 	else
 	if (nv_device(priv)-&gt;chipset &lt;  0x17 ||
-	    nv_device(priv)-&gt;chipset == 0x1a)
+	    nv_device(priv)-&gt;card_type &lt; NV_11)
 		nv_engine(priv)-&gt;sclass = nv15_graph_sclass;
 	else
 		nv_engine(priv)-&gt;sclass = nv17_graph_sclass;
@@ -1270,7 +1273,8 @@ nv10_graph_init(struct nouveau_object *object)
 	nv_wr32(priv, NV04_PGRAPH_DEBUG_2, 0x25f92ad9);
 	nv_wr32(priv, NV04_PGRAPH_DEBUG_3, 0x55DE0830 | (1 &lt;&lt; 29) | (1 &lt;&lt; 31));
 
-	if (nv_device(priv)-&gt;chipset &gt;= 0x17) {
+	if (nv_device(priv)-&gt;card_type &gt;= NV_11 &amp;&amp;
+	    nv_device(priv)-&gt;chipset &gt;= 0x17) {
 		nv_wr32(priv, NV10_PGRAPH_DEBUG_4, 0x1f000000);
 		nv_wr32(priv, 0x400a10, 0x03ff3fb6);
 		nv_wr32(priv, 0x400838, 0x002f8684);
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
index b22357d9b821..27c8235f1a85 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv04.c
@@ -168,7 +168,8 @@ setPLL_single(struct nouveau_devinit *devinit, u32 reg,
 		/* downclock -- write new NM first */
 		nv_wr32(devinit, reg, (oldpll &amp; 0xffff0000) | pv-&gt;NM1);
 
-	if (chip_version &lt; 0x17 &amp;&amp; chip_version != 0x11)
+	if ((chip_version &lt; 0x17 || chip_version == 0x1a) &amp;&amp;
+	    chip_version != 0x11)
 		/* wait a bit on older chips */
 		msleep(64);
 	nv_rd32(devinit, reg);
diff --git a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv10.c b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv10.c
index 463b08fa0968..8d274dba1ef1 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/devinit/nv10.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/devinit/nv10.c
@@ -38,12 +38,18 @@ static void
 nv10_devinit_meminit(struct nouveau_devinit *devinit)
 {
 	struct nv10_devinit_priv *priv = (void *)devinit;
-	const int mem_width[] = { 0x10, 0x00, 0x20 };
-	const int mem_width_count = nv_device(priv)-&gt;chipset &gt;= 0x17 ? 3 : 2;
+	static const int mem_width[] = { 0x10, 0x00, 0x20 };
+	int mem_width_count;
 	uint32_t patt = 0xdeadbeef;
 	struct io_mapping *fb;
 	int i, j, k;
 
+	if (nv_device(priv)-&gt;card_type &gt;= NV_11 &amp;&amp;
+	    nv_device(priv)-&gt;chipset &gt;= 0x17)
+		mem_width_count = 3;
+	else
+		mem_width_count = 2;
+
 	/* Map the framebuffer aperture */
 	fb = fbmem_init(nv_device(priv)-&gt;pdev);
 	if (!fb) {
diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c
index 69bf82d126ea..c0a79c715827 100644
--- a/drivers/gpu/drm/nouveau/nouveau_drm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c
@@ -142,7 +142,8 @@ nouveau_accel_init(struct nouveau_drm *drm)
 
 	/* initialise synchronisation routines */
 	if      (device-&gt;card_type &lt; NV_10) ret = nv04_fence_create(drm);
-	else if (device-&gt;chipset   &lt;  0x17) ret = nv10_fence_create(drm);
+	else if (device-&gt;card_type &lt; NV_11 ||
+		 device-&gt;chipset   &lt;  0x17) ret = nv10_fence_create(drm);
 	else if (device-&gt;card_type &lt; NV_50) ret = nv17_fence_create(drm);
 	else if (device-&gt;chipset   &lt;  0x84) ret = nv50_fence_create(drm);
 	else if (device-&gt;card_type &lt; NV_C0) ret = nv84_fence_create(drm);</pre><hr><pre>commit 4a0ff75418851116d034fa4d91bef114f01a329d
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Thu Sep 5 04:45:02 2013 -0400

    drm/nv10: introduce a new NV_11 card type
    
    NV11/17/1F/18 come after NV10/15/16/1A. In order to facilitate using
    numerical comparisons, split up the two sets into different card types.
    
    This change should be a no-op except that the relevant cards will see
    NV11 printed instead of NV10 for the family.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/core/engine/device/base.c b/drivers/gpu/drm/nouveau/core/engine/device/base.c
index 1407d80b910c..f8b4fbf55889 100644
--- a/drivers/gpu/drm/nouveau/core/engine/device/base.c
+++ b/drivers/gpu/drm/nouveau/core/engine/device/base.c
@@ -161,7 +161,13 @@ nouveau_devobj_ctor(struct nouveau_object *parent,
 		if ((boot0 &amp; 0x0f000000) &gt; 0) {
 			device-&gt;chipset = (boot0 &amp; 0xff00000) &gt;&gt; 20;
 			switch (device-&gt;chipset &amp; 0xf0) {
-			case 0x10: device-&gt;card_type = NV_10; break;
+			case 0x10: {
+				if (0x461 &amp; (1 &lt;&lt; (device-&gt;chipset &amp; 0xf)))
+					device-&gt;card_type = NV_10;
+				else
+					device-&gt;card_type = NV_11;
+				break;
+			}
 			case 0x20: device-&gt;card_type = NV_20; break;
 			case 0x30: device-&gt;card_type = NV_30; break;
 			case 0x40:
@@ -188,7 +194,8 @@ nouveau_devobj_ctor(struct nouveau_object *parent,
 
 		switch (device-&gt;card_type) {
 		case NV_04: ret = nv04_identify(device); break;
-		case NV_10: ret = nv10_identify(device); break;
+		case NV_10:
+		case NV_11: ret = nv10_identify(device); break;
 		case NV_20: ret = nv20_identify(device); break;
 		case NV_30: ret = nv30_identify(device); break;
 		case NV_40: ret = nv40_identify(device); break;
diff --git a/drivers/gpu/drm/nouveau/core/include/core/device.h b/drivers/gpu/drm/nouveau/core/include/core/device.h
index 0a1698faeff3..40c6dcf6ff63 100644
--- a/drivers/gpu/drm/nouveau/core/include/core/device.h
+++ b/drivers/gpu/drm/nouveau/core/include/core/device.h
@@ -72,6 +72,7 @@ struct nouveau_device {
 	enum {
 		NV_04    = 0x04,
 		NV_10    = 0x10,
+		NV_11    = 0x11,
 		NV_20    = 0x20,
 		NV_30    = 0x30,
 		NV_40    = 0x40,
diff --git a/drivers/gpu/drm/nouveau/core/subdev/bios/pll.c b/drivers/gpu/drm/nouveau/core/subdev/bios/pll.c
index f835501203e5..1f76de597d4b 100644
--- a/drivers/gpu/drm/nouveau/core/subdev/bios/pll.c
+++ b/drivers/gpu/drm/nouveau/core/subdev/bios/pll.c
@@ -114,6 +114,7 @@ pll_map(struct nouveau_bios *bios)
 	switch (nv_device(bios)-&gt;card_type) {
 	case NV_04:
 	case NV_10:
+	case NV_11:
 	case NV_20:
 	case NV_30:
 		return nv04_pll_mapping;
diff --git a/drivers/gpu/drm/nouveau/dispnv04/hw.c b/drivers/gpu/drm/nouveau/dispnv04/hw.c
index f8dee834527f..3d51ae9070f8 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/hw.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/hw.c
@@ -740,7 +740,7 @@ nv_load_state_ext(struct drm_device *dev, int head,
 	}
 	/* NV11 and NV20 stop at 0x52. */
 	if (nv_gf4_disp_arch(dev)) {
-		if (nv_device(drm-&gt;device)-&gt;card_type == NV_10) {
+		if (nv_device(drm-&gt;device)-&gt;card_type &lt; NV_20) {
 			/* Not waiting for vertical retrace before modifying
 			   CRE_53/CRE_54 causes lockups. */
 			nouveau_timer_wait_eq(ptimer, 650000000, NV_PRMCIO_INP0__COLOR, 0x8, 0x8);
diff --git a/drivers/gpu/drm/nouveau/nouveau_abi16.c b/drivers/gpu/drm/nouveau/nouveau_abi16.c
index 72055a35f845..3621e7f23477 100644
--- a/drivers/gpu/drm/nouveau/nouveau_abi16.c
+++ b/drivers/gpu/drm/nouveau/nouveau_abi16.c
@@ -87,6 +87,7 @@ nouveau_abi16_swclass(struct nouveau_drm *drm)
 	case NV_04:
 		return 0x006e;
 	case NV_10:
+	case NV_11:
 	case NV_20:
 	case NV_30:
 	case NV_40:
diff --git a/drivers/gpu/drm/nouveau/nouveau_bo.c b/drivers/gpu/drm/nouveau/nouveau_bo.c
index c28a5a9ff053..949ab0cbc4ab 100644
--- a/drivers/gpu/drm/nouveau/nouveau_bo.c
+++ b/drivers/gpu/drm/nouveau/nouveau_bo.c
@@ -269,7 +269,8 @@ set_placement_range(struct nouveau_bo *nvbo, uint32_t type)
 	struct nouveau_fb *pfb = nouveau_fb(drm-&gt;device);
 	u32 vram_pages = pfb-&gt;ram-&gt;size &gt;&gt; PAGE_SHIFT;
 
-	if (nv_device(drm-&gt;device)-&gt;card_type == NV_10 &amp;&amp;
+	if ((nv_device(drm-&gt;device)-&gt;card_type == NV_10 ||
+	     nv_device(drm-&gt;device)-&gt;card_type == NV_11) &amp;&amp;
 	    nvbo-&gt;tile_mode &amp;&amp; (type &amp; TTM_PL_FLAG_VRAM) &amp;&amp;
 	    nvbo-&gt;bo.mem.num_pages &lt; vram_pages / 4) {
 		/*
diff --git a/drivers/gpu/drm/nouveau/nouveau_connector.c b/drivers/gpu/drm/nouveau/nouveau_connector.c
index 1aa682494a18..1674882d60d5 100644
--- a/drivers/gpu/drm/nouveau/nouveau_connector.c
+++ b/drivers/gpu/drm/nouveau/nouveau_connector.c
@@ -215,9 +215,10 @@ nouveau_connector_set_encoder(struct drm_connector *connector,
 	} else {
 		connector-&gt;doublescan_allowed = true;
 		if (nv_device(drm-&gt;device)-&gt;card_type == NV_20 ||
-		   (nv_device(drm-&gt;device)-&gt;card_type == NV_10 &amp;&amp;
-		    (dev-&gt;pdev-&gt;device &amp; 0x0ff0) != 0x0100 &amp;&amp;
-		    (dev-&gt;pdev-&gt;device &amp; 0x0ff0) != 0x0150))
+		    ((nv_device(drm-&gt;device)-&gt;card_type == NV_10 ||
+		      nv_device(drm-&gt;device)-&gt;card_type == NV_11) &amp;&amp;
+		     (dev-&gt;pdev-&gt;device &amp; 0x0ff0) != 0x0100 &amp;&amp;
+		     (dev-&gt;pdev-&gt;device &amp; 0x0ff0) != 0x0150))
 			/* HW is broken */
 			connector-&gt;interlace_allowed = false;
 		else</pre>
    <div class="pagination">
        <a href='1_144.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><span>[145]</span><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_146.html'>Next&gt;&gt;</a>
    <div>
</body>
