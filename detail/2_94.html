<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_93.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><span>[94]</span><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_95.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 58a97ffeb2297f154659f339d77eb3f32c4d8b3e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 14 12:17:10 2008 -0400

    USB: HCDs use the do_remote_wakeup flag
    
    When a USB device is suspended, whether or not it is enabled for
    remote wakeup depends on the device_may_wakeup() setting.  The setting
    is then saved in the do_remote_wakeup flag.
    
    Later on, however, the device_may_wakeup() value can change because of
    user activity.  So when testing whether a suspended device is or
    should be enabled for remote wakeup, we should always test
    do_remote_wakeup instead of device_may_wakeup().  This patch (as1076)
    makes that change for root hubs in several places.
    
    The patch also adjusts uhci-hcd so that when an autostopped controller
    is suspended, the remote wakeup setting agrees with the value recorded
    in the root hub's do_remote_wakeup flag.
    
    And the patch adjusts ehci-hcd so that wakeup events on selectively
    suspended ports (i.e., the bus itself isn't suspended) don't turn on
    the PME# wakeup signal.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2ea333a43d65..edc31e13e95e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -932,7 +932,6 @@ static int autosuspend_check(struct usb_device *udev, int reschedule)
 	 * is disabled.  Also fail if any interfaces require remote wakeup
 	 * but it isn't available.
 	 */
-	udev-&gt;do_remote_wakeup = device_may_wakeup(&amp;udev-&gt;dev);
 	if (udev-&gt;pm_usage_cnt &gt; 0)
 		return -EBUSY;
 	if (udev-&gt;autosuspend_delay &lt; 0 || udev-&gt;autosuspend_disabled)
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 21ac3781f21a..536b433d24f7 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -30,6 +30,8 @@
 
 #ifdef	CONFIG_PM
 
+#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
+
 static int ehci_hub_control(
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -149,10 +151,10 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		}
 
 		/* enable remote wakeup on all ports */
-		if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
-			t2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;
+		if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
+			t2 |= PORT_WAKE_BITS;
 		else
-			t2 &amp;= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);
+			t2 &amp;= ~PORT_WAKE_BITS;
 
 		if (t1 != t2) {
 			ehci_vdbg (ehci, "port %d, %08x -&gt; %08x\n",
@@ -174,7 +176,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	/* allow remote wakeup */
 	mask = INTR_MASK;
-	if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+	if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 		mask &amp;= ~STS_PCD;
 	ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
@@ -232,8 +234,7 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
 	while (i--) {
 		temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;port_status [i]);
-		temp &amp;= ~(PORT_RWC_BITS
-			| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);
+		temp &amp;= ~(PORT_RWC_BITS | PORT_WAKE_BITS);
 		if (test_bit(i, &amp;ehci-&gt;bus_suspended) &amp;&amp;
 				(temp &amp; PORT_SUSPEND)) {
 			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
@@ -534,8 +535,6 @@ ehci_hub_descriptor (
 
 /*-------------------------------------------------------------------------*/
 
-#define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
-
 static int ehci_hub_control (
 	struct usb_hcd	*hcd,
 	u16		typeReq,
@@ -801,8 +800,6 @@ static int ehci_hub_control (
 			if ((temp &amp; PORT_PE) == 0
 					|| (temp &amp; PORT_RESET) != 0)
 				goto error;
-			if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
-				temp |= PORT_WAKE_BITS;
 			ehci_writel(ehci, temp | PORT_SUSPEND, status_reg);
 			break;
 		case USB_PORT_FEAT_POWER:
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index a0afc78b273e..88dad4b53131 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -300,7 +300,7 @@ static int ehci_pci_resume(struct usb_hcd *hcd)
 	if (ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag) == FLAG_CF) {
 		int	mask = INTR_MASK;
 
-		if (!device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index 66d773c726f6..20b9a0d07420 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1400,7 +1400,7 @@ static int isp116x_bus_suspend(struct usb_hcd *hcd)
 		spin_unlock_irqrestore(&amp;isp116x-&gt;lock, flags);
 		val &amp;= (~HCCONTROL_HCFS &amp; ~HCCONTROL_RWE);
 		val |= HCCONTROL_USB_SUSPEND;
-		if (device_may_wakeup(&amp;hcd-&gt;self.root_hub-&gt;dev))
+		if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			val |= HCCONTROL_RWE;
 		/* Wait for usb transfers to finish */
 		msleep(2);
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 28d6d775eb5f..cf3e1d255639 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -103,10 +103,9 @@ __acquires(ohci-&gt;lock)
 	finish_unlinks (ohci, ohci_frame_no(ohci));
 
 	/* maybe resume can wake root hub */
-	if (device_may_wakeup(&amp;ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;dev) ||
-			autostop)
+	if (ohci_to_hcd(ohci)-&gt;self.root_hub-&gt;do_remote_wakeup || autostop) {
 		ohci-&gt;hc_control |= OHCI_CTRL_RWE;
-	else {
+	} else {
 		ohci_writel (ohci, OHCI_INTR_RHSC, &amp;ohci-&gt;regs-&gt;intrdisable);
 		ohci-&gt;hc_control &amp;= ~OHCI_CTRL_RWE;
 	}
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fec9872dd9dc..f65d5a858733 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -262,20 +262,12 @@ __acquires(uhci-&gt;lock)
 {
 	int auto_stop;
 	int int_enable, egsm_enable;
+	struct usb_device *rhdev = uhci_to_hcd(uhci)-&gt;self.root_hub;
 
 	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
-	dev_dbg(&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev,
-			"%s%s\n", __FUNCTION__,
+	dev_dbg(&amp;rhdev-&gt;dev, "%s%s\n", __func__,
 			(auto_stop ? " (auto-stop)" : ""));
 
-	/* If we get a suspend request when we're already auto-stopped
-	 * then there's nothing to do.
-	 */
-	if (uhci-&gt;rh_state == UHCI_RH_AUTO_STOPPED) {
-		uhci-&gt;rh_state = new_state;
-		return;
-	}
-
 	/* Enable resume-detect interrupts if they work.
 	 * Then enter Global Suspend mode if _it_ works, still configured.
 	 */
@@ -285,8 +277,10 @@ __acquires(uhci-&gt;lock)
 	if (remote_wakeup_is_broken(uhci))
 		egsm_enable = 0;
 	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable ||
-			!device_may_wakeup(
-				&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev))
+#ifdef CONFIG_PM
+			(!auto_stop &amp;&amp; !rhdev-&gt;do_remote_wakeup) ||
+#endif
+			(auto_stop &amp;&amp; !device_may_wakeup(&amp;rhdev-&gt;dev)))
 		uhci-&gt;working_RD = int_enable = 0;
 
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
@@ -308,8 +302,7 @@ __acquires(uhci-&gt;lock)
 			return;
 	}
 	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
-		dev_warn(&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev,
-			"Controller not stopped yet!\n");
+		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
 
 	uhci_get_current_frame_number(uhci);
 </pre><hr><pre>commit b950bdbc67041412cb042e404938667204c7902c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 14 11:45:29 2008 -0400

    USB: g_file_storage: ignore bulk-out data after invalid CBW
    
    This patch (as1061) makes g_file_storage more compliant with the
    Bulk-Only Transport specification.  After an invalid CBW is received,
    the gadget must ignore any further bulk-OUT data until it is reset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 017a196d041f..0a726e106ccd 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -644,7 +644,7 @@ struct fsg_dev {
 
 	unsigned long		atomic_bitflags;
 #define REGISTERED		0
-#define CLEAR_BULK_HALTS	1
+#define IGNORE_BULK_OUT		1
 #define SUSPENDED		2
 
 	struct usb_ep		*bulk_in;
@@ -2936,8 +2936,8 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	struct usb_request	*req = bh-&gt;outreq;
 	struct bulk_cb_wrap	*cbw = req-&gt;buf;
 
-	/* Was this a real packet? */
-	if (req-&gt;status)
+	/* Was this a real packet?  Should it be ignored? */
+	if (req-&gt;status || test_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags))
 		return -EINVAL;
 
 	/* Is the CBW valid? */
@@ -2948,13 +2948,17 @@ static int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 				req-&gt;actual,
 				le32_to_cpu(cbw-&gt;Signature));
 
-		/* The Bulk-only spec says we MUST stall the bulk pipes!
-		 * If we want to avoid stalls, set a flag so that we will
-		 * clear the endpoint halts at the next reset. */
-		if (!mod_data.can_stall)
-			set_bit(CLEAR_BULK_HALTS, &amp;fsg-&gt;atomic_bitflags);
-		fsg_set_halt(fsg, fsg-&gt;bulk_out);
+		/* The Bulk-only spec says we MUST stall the IN endpoint
+		 * (6.6.1), so it's unavoidable.  It also says we must
+		 * retain this state until the next reset, but there's
+		 * no way to tell the controller driver it should ignore
+		 * Clear-Feature(HALT) requests.
+		 *
+		 * We aren't required to halt the OUT endpoint; instead
+		 * we can simply accept and discard any data received
+		 * until the next reset. */
 		halt_bulk_in_endpoint(fsg);
+		set_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags);
 		return -EINVAL;
 	}
 
@@ -3140,6 +3144,7 @@ static int do_set_interface(struct fsg_dev *fsg, int altsetting)
 		goto reset;
 	fsg-&gt;bulk_out_enabled = 1;
 	fsg-&gt;bulk_out_maxpacket = le16_to_cpu(d-&gt;wMaxPacketSize);
+	clear_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags);
 
 	if (transport_is_cbi()) {
 		d = ep_desc(fsg-&gt;gadget, &amp;fs_intr_in_desc, &amp;hs_intr_in_desc);
@@ -3321,11 +3326,8 @@ static void handle_exception(struct fsg_dev *fsg)
 		/* In case we were forced against our will to halt a
 		 * bulk endpoint, clear the halt now.  (The SuperH UDC
 		 * requires this.) */
-		if (test_and_clear_bit(CLEAR_BULK_HALTS,
-				&amp;fsg-&gt;atomic_bitflags)) {
+		if (test_and_clear_bit(IGNORE_BULK_OUT, &amp;fsg-&gt;atomic_bitflags))
 			usb_ep_clear_halt(fsg-&gt;bulk_in);
-			usb_ep_clear_halt(fsg-&gt;bulk_out);
-		}
 
 		if (transport_is_bbb()) {
 			if (fsg-&gt;ep0_req_tag == exception_req_tag)</pre><hr><pre>commit 6427f7995338387ddded92f98adec19ddbf0ae5e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 10 12:45:34 2008 -0400

    USB: log an error message when USB enumeration fails
    
    This patch (as1077) logs an error message whenever the kernel is
    unable to enumerate a new USB device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 9fc5179dfc60..1e23e360ea91 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2708,6 +2708,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 		if ((status == -ENOTCONN) || (status == -ENOTSUPP))
 			break;
 	}
+	dev_err(hub_dev, "unable to enumerate USB device on port %d\n", port1);
  
 done:
 	hub_port_disable(hub, port1, 1);</pre><hr><pre>commit a89a2cd396b20c46a37fa8db4b652fb00f29d0a4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Apr 7 15:03:25 2008 -0400

    USB: dummy-hcd: use dynamic allocation for platform_devices
    
    This patch (as1075) changes dummy-hcd to dynamically allocate its
    platform_device structures, using the core platform_device_alloc()
    interface.  This is what it should have done all along, because the
    dynamically-allocated structures have a release method in the driver
    core and are therefore immune to being released after the module has
    been unloaded.
    
    Thanks to Richard Purdie for pointing out the need for this change.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Richard Purdie &lt;rpurdie@rpsys.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 433f8c47cce5..74f51a703b42 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1933,69 +1933,57 @@ static struct platform_driver dummy_hcd_driver = {
 
 /*-------------------------------------------------------------------------*/
 
-/* These don't need to do anything because the pdev structures are
- * statically allocated. */
-static void
-dummy_udc_release (struct device *dev) {}
-
-static void
-dummy_hcd_release (struct device *dev) {}
-
-static struct platform_device		the_udc_pdev = {
-	.name		= (char *) gadget_name,
-	.id		= -1,
-	.dev		= {
-		.release	= dummy_udc_release,
-	},
-};
-
-static struct platform_device		the_hcd_pdev = {
-	.name		= (char *) driver_name,
-	.id		= -1,
-	.dev		= {
-		.release	= dummy_hcd_release,
-	},
-};
+static struct platform_device *the_udc_pdev;
+static struct platform_device *the_hcd_pdev;
 
 static int __init init (void)
 {
-	int	retval;
+	int	retval = -ENOMEM;
 
 	if (usb_disabled ())
 		return -ENODEV;
 
-	retval = platform_driver_register (&amp;dummy_hcd_driver);
-	if (retval &lt; 0)
+	the_hcd_pdev = platform_device_alloc(driver_name, -1);
+	if (!the_hcd_pdev)
 		return retval;
+	the_udc_pdev = platform_device_alloc(gadget_name, -1);
+	if (!the_udc_pdev)
+		goto err_alloc_udc;
 
-	retval = platform_driver_register (&amp;dummy_udc_driver);
+	retval = platform_driver_register(&amp;dummy_hcd_driver);
+	if (retval &lt; 0)
+		goto err_register_hcd_driver;
+	retval = platform_driver_register(&amp;dummy_udc_driver);
 	if (retval &lt; 0)
 		goto err_register_udc_driver;
 
-	retval = platform_device_register (&amp;the_hcd_pdev);
+	retval = platform_device_add(the_hcd_pdev);
 	if (retval &lt; 0)
-		goto err_register_hcd;
-
-	retval = platform_device_register (&amp;the_udc_pdev);
+		goto err_add_hcd;
+	retval = platform_device_add(the_udc_pdev);
 	if (retval &lt; 0)
-		goto err_register_udc;
+		goto err_add_udc;
 	return retval;
 
-err_register_udc:
-	platform_device_unregister (&amp;the_hcd_pdev);
-err_register_hcd:
-	platform_driver_unregister (&amp;dummy_udc_driver);
+err_add_udc:
+	platform_device_del(the_hcd_pdev);
+err_add_hcd:
+	platform_driver_unregister(&amp;dummy_udc_driver);
 err_register_udc_driver:
-	platform_driver_unregister (&amp;dummy_hcd_driver);
+	platform_driver_unregister(&amp;dummy_hcd_driver);
+err_register_hcd_driver:
+	platform_device_put(the_udc_pdev);
+err_alloc_udc:
+	platform_device_put(the_hcd_pdev);
 	return retval;
 }
 module_init (init);
 
 static void __exit cleanup (void)
 {
-	platform_device_unregister (&amp;the_udc_pdev);
-	platform_device_unregister (&amp;the_hcd_pdev);
-	platform_driver_unregister (&amp;dummy_udc_driver);
-	platform_driver_unregister (&amp;dummy_hcd_driver);
+	platform_device_unregister(the_udc_pdev);
+	platform_device_unregister(the_hcd_pdev);
+	platform_driver_unregister(&amp;dummy_udc_driver);
+	platform_driver_unregister(&amp;dummy_hcd_driver);
 }
 module_exit (cleanup);</pre><hr><pre>commit 61a5c657892a43653d6189972159590751a0673e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 4 23:46:59 2008 -0400

    USB: rework sysfs removal of interface files
    
    Removing an interface's sysfs files before unregistering the interface
    doesn't work properly, because usb_unbind_interface() will reinstall
    altsetting 0 and thereby create new sysfs files.  This patch (as1074)
    removes the files after the unregistration is finished.  It's not
    quite as clean, but at least it works.
    
    Also, there's no need to check if an interface has been registered
    before removing its sysfs files.  If it hasn't been registered then
    the files won't have been created, so usb_remove_sysfs_intf_files()
    will simply do nothing.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Jiri Slaby &lt;jirislaby@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index a3695b5115ff..5b23f6b017d7 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1089,8 +1089,8 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 				continue;
 			dev_dbg(&amp;dev-&gt;dev, "unregistering interface %s\n",
 				interface-&gt;dev.bus_id);
-			usb_remove_sysfs_intf_files(interface);
 			device_del(&amp;interface-&gt;dev);
+			usb_remove_sysfs_intf_files(interface);
 		}
 
 		/* Now that the interfaces are unbound, nobody should
@@ -1231,7 +1231,7 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 	 */
 
 	/* prevent submissions using previous endpoint settings */
-	if (iface-&gt;cur_altsetting != alt &amp;&amp; device_is_registered(&amp;iface-&gt;dev))
+	if (iface-&gt;cur_altsetting != alt)
 		usb_remove_sysfs_intf_files(iface);
 	usb_disable_interface(dev, iface);
 
@@ -1330,8 +1330,7 @@ int usb_reset_configuration(struct usb_device *dev)
 		struct usb_interface *intf = config-&gt;interface[i];
 		struct usb_host_interface *alt;
 
-		if (device_is_registered(&amp;intf-&gt;dev))
-			usb_remove_sysfs_intf_files(intf);
+		usb_remove_sysfs_intf_files(intf);
 		alt = usb_altnum_to_altsetting(intf, 0);
 
 		/* No altsetting 0?  We'll assume the first altsetting.</pre><hr><pre>commit 43bbb7e015c4380064796c5868b536437b165615
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 18:03:17 2008 -0400

    USB: OHCI: host-controller resumes leave root hub suspended
    
    Drivers in the ohci-hcd family should perform certain tasks whenever
    their controller device is resumed.  These include checking for loss
    of power during suspend, turning on port power, and enabling interrupt
    requests.
    
    Until now these jobs have been carried out when the root hub is
    resumed, not when the controller is.  Many drivers work around the
    resulting awkwardness by automatically resuming their root hub
    whenever the controller is resumed.  But this is wasteful and
    unnecessary.
    
    To simplify the situation, this patch (as1066) adds a new core
    routine, ohci_finish_controller_resume(), which can be used by all the
    OHCI-variant drivers.  They can call the new routine instead of
    resuming their root hubs.  And ohci-pci.c can call it instead of using
    its own special-purpose handler.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-at91.c b/drivers/usb/host/ohci-at91.c
index d72dc07dda01..e534f9de0f05 100644
--- a/drivers/usb/host/ohci-at91.c
+++ b/drivers/usb/host/ohci-at91.c
@@ -348,6 +348,7 @@ static int ohci_hcd_at91_drv_resume(struct platform_device *pdev)
 	if (!clocked)
 		at91_start_clock();
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #else
diff --git a/drivers/usb/host/ohci-ep93xx.c b/drivers/usb/host/ohci-ep93xx.c
index 40c683f8987d..5adaf36e47d0 100644
--- a/drivers/usb/host/ohci-ep93xx.c
+++ b/drivers/usb/host/ohci-ep93xx.c
@@ -192,8 +192,8 @@ static int ohci_hcd_ep93xx_drv_resume(struct platform_device *pdev)
 	ohci-&gt;next_statechange = jiffies;
 
 	ep93xx_start_hc(&amp;pdev-&gt;dev);
-	usb_hcd_resume_root_hub(hcd);
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index c638e6b33c43..28d6d775eb5f 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -326,6 +326,49 @@ static int ohci_bus_resume (struct usb_hcd *hcd)
 	return rc;
 }
 
+/* Carry out the final steps of resuming the controller device */
+static void ohci_finish_controller_resume(struct usb_hcd *hcd)
+{
+	struct ohci_hcd		*ohci = hcd_to_ohci(hcd);
+	int			port;
+	bool			need_reinit = false;
+
+	/* See if the controller is already running or has been reset */
+	ohci-&gt;hc_control = ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
+	if (ohci-&gt;hc_control &amp; (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {
+		need_reinit = true;
+	} else {
+		switch (ohci-&gt;hc_control &amp; OHCI_CTRL_HCFS) {
+		case OHCI_USB_OPER:
+		case OHCI_USB_RESET:
+			need_reinit = true;
+		}
+	}
+
+	/* If needed, reinitialize and suspend the root hub */
+	if (need_reinit) {
+		spin_lock_irq(&amp;ohci-&gt;lock);
+		hcd-&gt;state = HC_STATE_RESUMING;
+		ohci_rh_resume(ohci);
+		hcd-&gt;state = HC_STATE_QUIESCING;
+		ohci_rh_suspend(ohci, 0);
+		hcd-&gt;state = HC_STATE_SUSPENDED;
+		spin_unlock_irq(&amp;ohci-&gt;lock);
+	}
+
+	/* Normally just turn on port power and enable interrupts */
+	else {
+		ohci_dbg(ohci, "powerup ports\n");
+		for (port = 0; port &lt; ohci-&gt;num_ports; port++)
+			ohci_writel(ohci, RH_PS_PPS,
+					&amp;ohci-&gt;regs-&gt;roothub.portstatus[port]);
+
+		ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrenable);
+		ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrenable);
+		msleep(20);
+	}
+}
+
 /* Carry out polling-, autostop-, and autoresume-related state changes */
 static int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,
 		int any_connected)
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index 2aafa7b6c81f..3a7c24c03671 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -510,14 +510,15 @@ static int ohci_omap_suspend(struct platform_device *dev, pm_message_t message)
 
 static int ohci_omap_resume(struct platform_device *dev)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(dev));
+	struct usb_hcd	*hcd = platform_get_drvdata(dev);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
 	if (time_before(jiffies, ohci-&gt;next_statechange))
 		msleep(5);
 	ohci-&gt;next_statechange = jiffies;
 
 	omap_ohci_clock_power(1);
-	usb_hcd_resume_root_hub(platform_get_drvdata(dev));
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 40b62a35fd3c..4696cc912e16 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -238,42 +238,6 @@ static int __devinit ohci_pci_start (struct usb_hcd *hcd)
 	return ret;
 }
 
-#if	defined(CONFIG_USB_PERSIST) &amp;&amp; (defined(CONFIG_USB_EHCI_HCD) || \
-		defined(CONFIG_USB_EHCI_HCD_MODULE))
-
-/* Following a power loss, we must prepare to regain control of the ports
- * we used to own.  This means turning on the port power before ehci-hcd
- * tries to switch ownership.
- *
- * This isn't a 100% perfect solution.  On most systems the OHCI controllers
- * lie at lower PCI addresses than the EHCI controller, so they will be
- * discovered (and hence resumed) first.  But there is no guarantee things
- * will always work this way.  If the EHCI controller is resumed first and
- * the OHCI ports are unpowered, then the handover will fail.
- */
-static void prepare_for_handover(struct usb_hcd *hcd)
-{
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-	int		port;
-
-	/* Here we "know" root ports should always stay powered */
-	ohci_dbg(ohci, "powerup ports\n");
-	for (port = 0; port &lt; ohci-&gt;num_ports; port++)
-		ohci_writel(ohci, RH_PS_PPS,
-				&amp;ohci-&gt;regs-&gt;roothub.portstatus[port]);
-
-	/* Flush those writes */
-	ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;control);
-	msleep(20);
-}
-
-#else
-
-static inline void prepare_for_handover(struct usb_hcd *hcd)
-{ }
-
-#endif	/* CONFIG_USB_PERSIST etc. */
-
 #ifdef	CONFIG_PM
 
 static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
@@ -312,13 +276,8 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
-	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
-
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	/* FIXME: we should try to detect loss of VBUS power here */
-	prepare_for_handover(hcd);
-	ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrenable);
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 
diff --git a/drivers/usb/host/ohci-pxa27x.c b/drivers/usb/host/ohci-pxa27x.c
index 5d470263eed8..d4ee27d92be8 100644
--- a/drivers/usb/host/ohci-pxa27x.c
+++ b/drivers/usb/host/ohci-pxa27x.c
@@ -356,8 +356,7 @@ static int ohci_hcd_pxa27x_drv_resume(struct platform_device *pdev)
 	if ((status = pxa27x_start_hc(&amp;pdev-&gt;dev)) &lt; 0)
 		return status;
 
-	usb_hcd_resume_root_hub(hcd);
-
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #endif
diff --git a/drivers/usb/host/ohci-sm501.c b/drivers/usb/host/ohci-sm501.c
index 54b6ac2e3e4a..4a11e1816017 100644
--- a/drivers/usb/host/ohci-sm501.c
+++ b/drivers/usb/host/ohci-sm501.c
@@ -231,14 +231,15 @@ static int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)
 static int ohci_sm501_resume(struct platform_device *pdev)
 {
 	struct device *dev = &amp;pdev-&gt;dev;
-	struct ohci_hcd	*ohci = hcd_to_ohci(platform_get_drvdata(pdev));
+	struct usb_hcd	*hcd = platform_get_drvdata(pdev);
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
 
 	if (time_before(jiffies, ohci-&gt;next_statechange))
 		msleep(5);
 	ohci-&gt;next_statechange = jiffies;
 
 	sm501_unit_power(dev-&gt;parent, SM501_GATE_USB_HOST, 1);
-	usb_hcd_resume_root_hub(platform_get_drvdata(pdev));
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 #else
diff --git a/drivers/usb/host/ohci-ssb.c b/drivers/usb/host/ohci-ssb.c
index 7879f2fdad84..7275186db315 100644
--- a/drivers/usb/host/ohci-ssb.c
+++ b/drivers/usb/host/ohci-ssb.c
@@ -189,6 +189,7 @@ static int ssb_ohci_resume(struct ssb_device *dev)
 
 	ssb_device_enable(dev, ohcidev-&gt;enable_flags);
 
+	ohci_finish_controller_resume(hcd);
 	return 0;
 }
 </pre><hr><pre>commit 7be7d7418776a41badce7ca00246e270d408e4b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 18:03:06 2008 -0400

    USB: clarify usage of hcd-&gt;suspend/resume methods
    
    The .suspend and .resume method pointers in struct usb_hcd have not
    been fully understood by host-controller driver writers.  They are
    meant for use with PCI controllers; other platform-specific drivers
    generally should not refer to them.
    
    To try and clarify matters, this patch (as1065) renames those methods
    to .pci_suspend and .pci_resume.  It eliminates corresponding dead code
    and bogus references in the ohci-ssb and u132-hcd drivers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c
index 739407bb8492..5b87ae7f0a6a 100644
--- a/drivers/usb/core/hcd-pci.c
+++ b/drivers/usb/core/hcd-pci.c
@@ -215,9 +215,9 @@ int usb_hcd_pci_suspend(struct pci_dev *dev, pm_message_t message)
 			hcd-&gt;state == HC_STATE_HALT))
 		return -EBUSY;
 
-	if (hcd-&gt;driver-&gt;suspend) {
-		retval = hcd-&gt;driver-&gt;suspend(hcd, message);
-		suspend_report_result(hcd-&gt;driver-&gt;suspend, retval);
+	if (hcd-&gt;driver-&gt;pci_suspend) {
+		retval = hcd-&gt;driver-&gt;pci_suspend(hcd, message);
+		suspend_report_result(hcd-&gt;driver-&gt;pci_suspend, retval);
 		if (retval)
 			goto done;
 	}
@@ -405,8 +405,8 @@ int usb_hcd_pci_resume(struct pci_dev *dev)
 
 	clear_bit(HCD_FLAG_SAW_IRQ, &amp;hcd-&gt;flags);
 
-	if (hcd-&gt;driver-&gt;resume) {
-		retval = hcd-&gt;driver-&gt;resume(hcd);
+	if (hcd-&gt;driver-&gt;pci_resume) {
+		retval = hcd-&gt;driver-&gt;pci_resume(hcd);
 		if (retval) {
 			dev_err(hcd-&gt;self.controller,
 				"PCI post-resume error %d!\n", retval);
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index e0e99471c3fc..3ba258eb05de 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -178,10 +178,10 @@ struct hc_driver {
 	 * a whole, not just the root hub; they're for PCI bus glue.
 	 */
 	/* called after suspending the hub, before entering D3 etc */
-	int	(*suspend) (struct usb_hcd *hcd, pm_message_t message);
+	int	(*pci_suspend) (struct usb_hcd *hcd, pm_message_t message);
 
 	/* called after entering D0 (etc), before resuming the hub */
-	int	(*resume) (struct usb_hcd *hcd);
+	int	(*pci_resume) (struct usb_hcd *hcd);
 
 	/* cleanly make HCD stop writing memory and doing I/O */
 	void	(*stop) (struct usb_hcd *hcd);
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 7c8a2ccf78f1..a0afc78b273e 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -353,8 +353,8 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	.reset =		ehci_pci_setup,
 	.start =		ehci_run,
 #ifdef	CONFIG_PM
-	.suspend =		ehci_pci_suspend,
-	.resume =		ehci_pci_resume,
+	.pci_suspend =		ehci_pci_suspend,
+	.pci_resume =		ehci_pci_resume,
 #endif
 	.stop =			ehci_stop,
 	.shutdown =		ehci_shutdown,
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index b0e2275755c8..40b62a35fd3c 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -347,9 +347,8 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	.shutdown =		ohci_shutdown,
 
 #ifdef	CONFIG_PM
-	/* these suspend/resume entries are for upstream PCI glue ONLY */
-	.suspend =		ohci_pci_suspend,
-	.resume =		ohci_pci_resume,
+	.pci_suspend =		ohci_pci_suspend,
+	.pci_resume =		ohci_pci_resume,
 #endif
 
 	/*
diff --git a/drivers/usb/host/ohci-ssb.c b/drivers/usb/host/ohci-ssb.c
index 6e9c2d6db887..7879f2fdad84 100644
--- a/drivers/usb/host/ohci-ssb.c
+++ b/drivers/usb/host/ohci-ssb.c
@@ -60,36 +60,6 @@ static int ssb_ohci_start(struct usb_hcd *hcd)
 	return err;
 }
 
-#ifdef CONFIG_PM
-static int ssb_ohci_hcd_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-	struct ssb_ohci_device *ohcidev = hcd_to_ssb_ohci(hcd);
-	struct ohci_hcd *ohci = &amp;ohcidev-&gt;ohci;
-	unsigned long flags;
-
-	spin_lock_irqsave(&amp;ohci-&gt;lock, flags);
-
-	ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrdisable);
-	ohci_readl(ohci, &amp;ohci-&gt;regs-&gt;intrdisable); /* commit write */
-
-	/* make sure snapshot being resumed re-enumerates everything */
-	if (message.event == PM_EVENT_PRETHAW)
-		ohci_usb_reset(ohci);
-
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
-	spin_unlock_irqrestore(&amp;ohci-&gt;lock, flags);
-	return 0;
-}
-
-static int ssb_ohci_hcd_resume(struct usb_hcd *hcd)
-{
-	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	usb_hcd_resume_root_hub(hcd);
-	return 0;
-}
-#endif /* CONFIG_PM */
-
 static const struct hc_driver ssb_ohci_hc_driver = {
 	.description		= "ssb-usb-ohci",
 	.product_desc		= "SSB OHCI Controller",
@@ -103,11 +73,6 @@ static const struct hc_driver ssb_ohci_hc_driver = {
 	.stop			= ohci_stop,
 	.shutdown		= ohci_shutdown,
 
-#ifdef CONFIG_PM
-	.suspend		= ssb_ohci_hcd_suspend,
-	.resume			= ssb_ohci_hcd_resume,
-#endif
-
 	.urb_enqueue		= ohci_urb_enqueue,
 	.urb_dequeue		= ohci_urb_dequeue,
 	.endpoint_disable	= ohci_endpoint_disable,
diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index 4616a880d89c..9b6323f768b2 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -2946,34 +2946,6 @@ static void u132_hub_irq_enable(struct usb_hcd *hcd)
 
 
 #ifdef CONFIG_PM
-static int u132_hcd_suspend(struct usb_hcd *hcd, pm_message_t message)
-{
-	struct u132 *u132 = hcd_to_u132(hcd);
-	if (u132-&gt;going &gt; 1) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device has been removed %d\n"
-			, u132-&gt;going);
-		return -ENODEV;
-	} else if (u132-&gt;going &gt; 0) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed\n");
-		return -ESHUTDOWN;
-	} else
-		return 0;
-}
-
-static int u132_hcd_resume(struct usb_hcd *hcd)
-{
-	struct u132 *u132 = hcd_to_u132(hcd);
-	if (u132-&gt;going &gt; 1) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device has been removed %d\n"
-			, u132-&gt;going);
-		return -ENODEV;
-	} else if (u132-&gt;going &gt; 0) {
-		dev_err(&amp;u132-&gt;platform_dev-&gt;dev, "device is being removed\n");
-		return -ESHUTDOWN;
-	} else
-		return 0;
-}
-
 static int u132_bus_suspend(struct usb_hcd *hcd)
 {
 	struct u132 *u132 = hcd_to_u132(hcd);
@@ -3003,8 +2975,6 @@ static int u132_bus_resume(struct usb_hcd *hcd)
 }
 
 #else
-#define u132_hcd_suspend NULL
-#define u132_hcd_resume NULL
 #define u132_bus_suspend NULL
 #define u132_bus_resume NULL
 #endif
@@ -3015,8 +2985,6 @@ static struct hc_driver u132_hc_driver = {
 	.flags = HCD_USB11 | HCD_MEMORY,
 	.reset = u132_hcd_reset,
 	.start = u132_hcd_start,
-	.suspend = u132_hcd_suspend,
-	.resume = u132_hcd_resume,
 	.stop = u132_hcd_stop,
 	.urb_enqueue = u132_urb_enqueue,
 	.urb_dequeue = u132_urb_dequeue,
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index ec987897b8ed..fec9872dd9dc 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -737,7 +737,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 	return rc;
 }
 
-static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
+static int uhci_pci_suspend(struct usb_hcd *hcd, pm_message_t message)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	int rc = 0;
@@ -774,7 +774,7 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	return rc;
 }
 
-static int uhci_resume(struct usb_hcd *hcd)
+static int uhci_pci_resume(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
@@ -872,8 +872,8 @@ static const struct hc_driver uhci_driver = {
 	.reset =		uhci_init,
 	.start =		uhci_start,
 #ifdef CONFIG_PM
-	.suspend =		uhci_suspend,
-	.resume =		uhci_resume,
+	.pci_suspend =		uhci_pci_suspend,
+	.pci_resume =		uhci_pci_resume,
 	.bus_suspend =		uhci_rh_suspend,
 	.bus_resume =		uhci_rh_resume,
 #endif</pre><hr><pre>commit 7329e211b987a493cbcfca0e98c60eb108ab42df
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 18:02:56 2008 -0400

    USB: root hubs don't lie about their number of TTs
    
    Currently EHCI root hubs enumerate with a bDeviceProtocol code
    indicating that they possess a Transaction Translator.  However the
    vast majority of controllers do not; they rely on a companion
    controller to handle full- and low-speed communications.  This patch
    (as1064) changes the root-hub device descriptor to match the actual
    situation.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index f936de75f44e..e68fef5361d2 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -129,7 +129,7 @@ static const u8 usb2_rh_dev_descriptor [18] = {
 
 	0x09,	    /*  __u8  bDeviceClass; HUB_CLASSCODE */
 	0x00,	    /*  __u8  bDeviceSubClass; */
-	0x01,       /*  __u8  bDeviceProtocol; [ usb 2.0 single TT ]*/
+	0x00,       /*  __u8  bDeviceProtocol; [ usb 2.0 no TT ] */
 	0x40,       /*  __u8  bMaxPacketSize0; 64 Bytes */
 
 	0x6b, 0x1d, /*  __le16 idVendor; Linux Foundation */
@@ -354,9 +354,10 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 		__attribute__((aligned(4)));
 	const u8	*bufp = tbuf;
 	int		len = 0;
-	int		patch_wakeup = 0;
 	int		status;
 	int		n;
+	u8		patch_wakeup = 0;
+	u8		patch_protocol = 0;
 
 	might_sleep();
 
@@ -433,6 +434,8 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 			else
 				goto error;
 			len = 18;
+			if (hcd-&gt;has_tt)
+				patch_protocol = 1;
 			break;
 		case USB_DT_CONFIG &lt;&lt; 8:
 			if (hcd-&gt;driver-&gt;flags &amp; HCD_USB2) {
@@ -527,6 +530,13 @@ static int rh_call_control (struct usb_hcd *hcd, struct urb *urb)
 						bmAttributes))
 			((struct usb_config_descriptor *)ubuf)-&gt;bmAttributes
 				|= USB_CONFIG_ATT_WAKEUP;
+
+		/* report whether RH hardware has an integrated TT */
+		if (patch_protocol &amp;&amp;
+				len &gt; offsetof(struct usb_device_descriptor,
+						bDeviceProtocol))
+			((struct usb_device_descriptor *) ubuf)-&gt;
+					bDeviceProtocol = 1;
 	}
 
 	/* any errors get returned through the urb completion */
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 2c086b8460b1..e0e99471c3fc 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -99,6 +99,7 @@ struct usb_hcd {
 	unsigned		poll_pending:1;	/* status has changed? */
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
+	unsigned		has_tt:1;	/* Integrated TT in root hub */
 
 	int			irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 040bd8632eb3..7c8a2ccf78f1 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -130,6 +130,7 @@ static int ehci_pci_setup(struct usb_hcd *hcd)
 	case PCI_VENDOR_ID_TDI:
 		if (pdev-&gt;device == PCI_DEVICE_ID_TDI_EHCI) {
 			ehci-&gt;is_tdi_rh_tt = 1;
+			hcd-&gt;has_tt = 1;
 			tdi_reset(ehci);
 		}
 		break;</pre><hr><pre>commit 0d22f65515307c878ddd20b1305cce925ca9516c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Apr 3 11:35:26 2008 -0400

    USB: OHCI: fix bug in controller resume
    
    This patch (as1063) fixes a bug in the way ohci-hcd resumes its
    controllers.  It leaves the Master Interrupt Enable bit turned off.
    
    If the root hub is resumed immediately this won't matter.  But if the
    root hub is suspended (say because no devices are plugged in), it won't
    ever wake up by itself.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index d0360f65ebd9..b0e2275755c8 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -312,11 +312,13 @@ static int ohci_pci_suspend (struct usb_hcd *hcd, pm_message_t message)
 
 static int ohci_pci_resume (struct usb_hcd *hcd)
 {
+	struct ohci_hcd	*ohci = hcd_to_ohci(hcd);
+
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
 	/* FIXME: we should try to detect loss of VBUS power here */
 	prepare_for_handover(hcd);
-
+	ohci_writel(ohci, OHCI_INTR_MIE, &amp;ohci-&gt;regs-&gt;intrenable);
 	return 0;
 }
 </pre><hr><pre>commit 148d9fe4c91a6356dae1b05b76b8133586c26be4
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Mar 27 14:52:57 2008 -0400

    USB: usb-storage: use adaptive DMA mask
    
    This patch (as1060) makes usb-storage set the DMA alignment mask for
    SCSI slaves to match the maxpacket size of the bulk-IN endpoint,
    rather than always setting it to 511.  For full-speed devices that
    mask is too restrictive, and wireless USB devices can have maxpacket
    sizes larger than 512.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 5405ba8cd9d2..521f0297aef9 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -73,6 +73,7 @@ static const char* host_info(struct Scsi_Host *host)
 static int slave_alloc (struct scsi_device *sdev)
 {
 	struct us_data *us = host_to_us(sdev-&gt;host);
+	struct usb_host_endpoint *bulk_in_ep;
 
 	/*
 	 * Set the INQUIRY transfer length to 36.  We don't use any of
@@ -84,12 +85,13 @@ static int slave_alloc (struct scsi_device *sdev)
 	/* Scatter-gather buffers (all but the last) must have a length
 	 * divisible by the bulk maxpacket size.  Otherwise a data packet
 	 * would end up being short, causing a premature end to the data
-	 * transfer.  Since high-speed bulk pipes have a maxpacket size
-	 * of 512, we'll use that as the scsi device queue's DMA alignment
-	 * mask.  Guaranteeing proper alignment of the first buffer will
-	 * have the desired effect because, except at the beginning and
-	 * the end, scatter-gather buffers follow page boundaries. */
-	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
+	 * transfer.  We'll use the maxpacket value of the bulk-IN pipe
+	 * to set the SCSI device queue's DMA alignment mask.
+	 */
+	bulk_in_ep = us-&gt;pusb_dev-&gt;ep_in[usb_pipeendpoint(us-&gt;recv_bulk_pipe)];
+	blk_queue_update_dma_alignment(sdev-&gt;request_queue,
+			le16_to_cpu(bulk_in_ep-&gt;desc.wMaxPacketSize) - 1);
+			/* wMaxPacketSize must be a power of 2 */
 
 	/*
 	 * The UFI spec treates the Peripheral Qualifier bits in an</pre>
    <div class="pagination">
        <a href='2_93.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><span>[94]</span><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_95.html'>Next&gt;&gt;</a>
    <div>
</body>
