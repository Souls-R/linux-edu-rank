<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_133.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><span>[134]</span><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_135.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit bbafa4668f37f5093a3ae2a8b0cbe327e24e12da
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:40:22 2005 -0700

    [PATCH] PATCH: usb-storage: allocate separate sense buffer
    
    This patch is from Alan Stern (as560).  It has been rediffed against a
    current tree.
    
    This patch allocates a separate buffer for usb-storage to use when
    auto-sensing.  Up to now we have been using the sense buffer embedded in a
    scsi_cmnd struct, which is dangerous on hosts that (a) don't do
    cache-coherent DMA or (b) have DMA alignment restrictions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index e89e945fc4a7..7ca896a342e3 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -636,11 +636,11 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 
 		/* use the new buffer we have */
 		old_request_buffer = srb-&gt;request_buffer;
-		srb-&gt;request_buffer = srb-&gt;sense_buffer;
+		srb-&gt;request_buffer = us-&gt;sensebuf;
 
 		/* set the buffer length for transfer */
 		old_request_bufflen = srb-&gt;request_bufflen;
-		srb-&gt;request_bufflen = 18;
+		srb-&gt;request_bufflen = US_SENSE_SIZE;
 
 		/* set up for no scatter-gather use */
 		old_sg = srb-&gt;use_sg;
@@ -652,6 +652,7 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		temp_result = us-&gt;transport(us-&gt;srb, us);
 
 		/* let's clean up right away */
+		memcpy(srb-&gt;sense_buffer, us-&gt;sensebuf, US_SENSE_SIZE);
 		srb-&gt;resid = old_resid;
 		srb-&gt;request_buffer = old_request_buffer;
 		srb-&gt;request_bufflen = old_request_bufflen;
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 92ee079d9172..eb901817b7d2 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -467,6 +467,12 @@ static int associate_dev(struct us_data *us, struct usb_interface *intf)
 		US_DEBUGP("I/O buffer allocation failed\n");
 		return -ENOMEM;
 	}
+
+	us-&gt;sensebuf = kmalloc(US_SENSE_SIZE, GFP_KERNEL);
+	if (!us-&gt;sensebuf) {
+		US_DEBUGP("Sense buffer allocation failed\n");
+		return -ENOMEM;
+	}
 	return 0;
 }
 
@@ -800,6 +806,8 @@ static void dissociate_dev(struct us_data *us)
 {
 	US_DEBUGP("-- %s\n", __FUNCTION__);
 
+	kfree(us-&gt;sensebuf);
+
 	/* Free the device-related DMA-mapped buffers */
 	if (us-&gt;cr)
 		usb_buffer_free(us-&gt;pusb_dev, sizeof(*us-&gt;cr), us-&gt;cr,
diff --git a/drivers/usb/storage/usb.h b/drivers/usb/storage/usb.h
index a195adae57b6..dfa4dc71dd3e 100644
--- a/drivers/usb/storage/usb.h
+++ b/drivers/usb/storage/usb.h
@@ -117,6 +117,7 @@ enum { US_DO_ALL_FLAGS };
  */
 
 #define US_IOBUF_SIZE		64	/* Size of the DMA-mapped I/O buffer */
+#define US_SENSE_SIZE		18	/* Size of the autosense data buffer */
 
 typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data*);
 typedef int (*trans_reset)(struct us_data*);
@@ -168,6 +169,7 @@ struct us_data {
 	struct usb_ctrlrequest	*cr;		 /* control requests	 */
 	struct usb_sg_request	current_sg;	 /* scatter-gather req.  */
 	unsigned char		*iobuf;		 /* I/O buffer		 */
+	unsigned char		*sensebuf;	 /* sense data buffer	 */
 	dma_addr_t		cr_dma;		 /* buffer DMA addresses */
 	dma_addr_t		iobuf_dma;
 </pre><hr><pre>commit b876aef7f890d8c59a45b78858a36cf60fddf522
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Oct 23 19:38:56 2005 -0700

    [PATCH] PATCH: usb-storage: move GetMaxLUN later in time
    
    This patch is originally from Alan Stern (as557).  It has been re-diffed
    against a current tree, and I also corrected a minor merging error.
    
    Some time ago we introduced a delay before device scanning, because many
    devices do not like to receive SCSI commands right after enumeration.
    Now it turns out there's a device that doesn't like to receive
    Get-Max-LUN right after enumeration either.  Accordingly this patch
    delays the Get-Max-LUN request until the beginning of the scanning
    procedure.  This fixes Bugzilla entry #5010.
    
    Three things are worth noting.  First, I removed the locking code from
    usb_stor_acquire_resources.  It's not needed, because the locking is to
    protect against disconnect events and acquire_resources is only called
    during probe (so the disconnect routine can't be called).  Second, I
    initialized to 0 the buffer used for the Get-Max-LUN response.  It's not
    really necessary, but it will prevent random values from showing up in
    the debugging log when the request fails.  Third, I added a test against
    the SINGLE_LUN flag.  This will allow us to use the flag to indicate
    Bulk-only devices that can't handle Get-Max-LUN.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Matthew Dharm &lt;mdharm-usb@one-eyed-alien.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index c1ba5301ebfc..e89e945fc4a7 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -923,6 +923,7 @@ int usb_stor_Bulk_max_lun(struct us_data *us)
 	int result;
 
 	/* issue the command */
+	us-&gt;iobuf[0] = 0;
 	result = usb_stor_control_msg(us, us-&gt;recv_ctrl_pipe,
 				 US_BULK_GET_MAX_LUN, 
 				 USB_DIR_IN | USB_TYPE_CLASS | 
diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 5164900e40c1..92ee079d9172 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -747,25 +747,13 @@ static int usb_stor_acquire_resources(struct us_data *us)
 		return -ENOMEM;
 	}
 
-	/* Lock the device while we carry out the next two operations */
-	down(&amp;us-&gt;dev_semaphore);
-
-	/* For bulk-only devices, determine the max LUN value */
-	if (us-&gt;protocol == US_PR_BULK) {
-		p = usb_stor_Bulk_max_lun(us);
-		if (p &lt; 0) {
-			up(&amp;us-&gt;dev_semaphore);
-			return p;
-		}
-		us-&gt;max_lun = p;
-	}
-
 	/* Just before we start our control thread, initialize
 	 * the device if it needs initialization */
-	if (us-&gt;unusual_dev-&gt;initFunction)
-		us-&gt;unusual_dev-&gt;initFunction(us);
-
-	up(&amp;us-&gt;dev_semaphore);
+	if (us-&gt;unusual_dev-&gt;initFunction) {
+		p = us-&gt;unusual_dev-&gt;initFunction(us);
+		if (p)
+			return p;
+	}
 
 	/* Start up our control thread */
 	p = kernel_thread(usb_stor_control_thread, us, CLONE_VM);
@@ -904,6 +892,14 @@ static int usb_stor_scan_thread(void * __us)
 
 	/* If the device is still connected, perform the scanning */
 	if (!test_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags)) {
+
+		/* For bulk-only devices, determine the max LUN value */
+		if (us-&gt;protocol == US_PR_BULK &amp;&amp;
+				!(us-&gt;flags &amp; US_FL_SINGLE_LUN)) {
+			down(&amp;us-&gt;dev_semaphore);
+			us-&gt;max_lun = usb_stor_Bulk_max_lun(us);
+			up(&amp;us-&gt;dev_semaphore);
+		}
 		scsi_scan_host(us_to_host(us));
 		printk(KERN_DEBUG "usb-storage: device scan complete\n");
 </pre><hr><pre>commit 423e489d704d05c6e8c2927fb1854db85914912a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 19 13:06:13 2005 -0400

    [PATCH] hid-core: Add Clear-Halt on the Interrupt-in endpoint
    
    This patch (as577) adds a Clear-Halt call on the Interrupt-in endpoint
    during input device configuration.  Without it my HP USB keyboard doesn't
    work.
    
    Vojtech says it's worth trying, since it might help with some recalcitrant
    devices.  On the other hand, it might interfere with others.  I'm
    submitting it so that it can get tested by a range of users.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index f7fcce731f54..79ddce4555ab 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1784,6 +1784,9 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 	hid-&gt;urbctrl-&gt;transfer_dma = hid-&gt;ctrlbuf_dma;
 	hid-&gt;urbctrl-&gt;transfer_flags |= (URB_NO_TRANSFER_DMA_MAP | URB_NO_SETUP_DMA_MAP);
 
+	/* May be needed for some devices */
+	usb_clear_halt(hid-&gt;dev, hid-&gt;urbin-&gt;pipe);
+
 	return hid;
 
 fail:</pre><hr><pre>commit 478a3bab8c87a9ba4a4ba338314e32bb0c378e62
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 19 12:52:02 2005 -0400

    [PATCH] USB: Always do usb-handoff
    
    This revised patch (as586b) makes usb-handoff permanently true and no
    longer a kernel boot parameter.  It also removes the piix3_usb quirk code;
    that was nothing more than an early version of the USB handoff code
    (written at a time when Intel's PIIX3 was about the only motherboard with
    USB support).  And it adds identifiers for the three PCI USB controller
    classes to pci_ids.h.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt
index 971589a9752d..90766b75d1b7 100644
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@ -1517,8 +1517,6 @@ running once the system is up.
 	uart6850=	[HW,OSS]
 			Format: &lt;io&gt;,&lt;irq&gt;
 
-	usb-handoff	[HW] Enable early USB BIOS -&gt; OS handoff
-
 	usbhid.mousepoll=
 			[USBHID] The interval which mice are to be polled at.
 
diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index f7411ca48835..b7fd3f644e1e 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -23,33 +23,6 @@
 #include &lt;linux/acpi.h&gt;
 
 
-/*
- * PIIX3 USB: We have to disable USB interrupts that are
- * hardwired to PIRQD# and may be shared with an
- * external device.
- *
- * Legacy Support Register (LEGSUP):
- *     bit13:  USB PIRQ Enable (USBPIRQDEN),
- *     bit4:   Trap/SMI On IRQ Enable (USBSMIEN).
- *
- * We mask out all r/wc bits, too.
- */
-static void __devinit quirk_piix3_usb(struct pci_dev *dev)
-{
-	u16 legsup;
-
-	pci_read_config_word(dev, 0xc0, &amp;legsup);
-	legsup &amp;= 0x50ef;
-	pci_write_config_word(dev, 0xc0, legsup);
-}
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371SB_2,	quirk_piix3_usb );
-DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_2,	quirk_piix3_usb );
-
-
-/* FIXME these should be the guts of hcd-&gt;reset() methods; resolve all
- * the differences between this version and the HCD's version.
- */
-
 #define UHCI_USBLEGSUP		0xc0		/* legacy support */
 #define UHCI_USBCMD		0		/* command register */
 #define UHCI_USBINTR		4		/* interrupt register */
@@ -83,13 +56,6 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_2,	qui
 #define EHCI_USBLEGCTLSTS	4		/* legacy control/status */
 #define EHCI_USBLEGCTLSTS_SOOE	(1 &lt;&lt; 13)	/* SMI on ownership change */
 
-int usb_early_handoff __devinitdata = 0;
-static int __init usb_handoff_early(char *str)
-{
-	usb_early_handoff = 1;
-	return 0;
-}
-__setup("usb-handoff", usb_handoff_early);
 
 /*
  * Make sure the controller is completely inactive, unable to
@@ -320,17 +286,11 @@ static void __devinit quirk_usb_disable_ehci(struct pci_dev *pdev)
 
 static void __devinit quirk_usb_early_handoff(struct pci_dev *pdev)
 {
-	if (!usb_early_handoff)
-		return;
-
-	if (pdev-&gt;class == ((PCI_CLASS_SERIAL_USB &lt;&lt; 8) | 0x00)) { /* UHCI */
+	if (pdev-&gt;class == PCI_CLASS_SERIAL_USB_UHCI)
 		quirk_usb_handoff_uhci(pdev);
-	} else if (pdev-&gt;class == ((PCI_CLASS_SERIAL_USB &lt;&lt; 8) | 0x10)) { /* OHCI */
+	else if (pdev-&gt;class == PCI_CLASS_SERIAL_USB_OHCI)
 		quirk_usb_handoff_ohci(pdev);
-	} else if (pdev-&gt;class == ((PCI_CLASS_SERIAL_USB &lt;&lt; 8) | 0x20)) { /* EHCI */
+	else if (pdev-&gt;class == PCI_CLASS_SERIAL_USB_EHCI)
 		quirk_usb_disable_ehci(pdev);
-	}
-
-	return;
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, quirk_usb_early_handoff);
diff --git a/include/asm-i386/mach-summit/mach_mpparse.h b/include/asm-i386/mach-summit/mach_mpparse.h
index 2b9e6d55bef1..1cce2b924a80 100644
--- a/include/asm-i386/mach-summit/mach_mpparse.h
+++ b/include/asm-i386/mach-summit/mach_mpparse.h
@@ -22,7 +22,6 @@ static inline void mpc_oem_pci_bus(struct mpc_config_bus *m,
 {
 }
 
-extern int usb_early_handoff;
 static inline int mps_oem_check(struct mp_config_table *mpc, char *oem, 
 		char *productid)
 {
@@ -32,7 +31,6 @@ static inline int mps_oem_check(struct mp_config_table *mpc, char *oem,
 			 || !strncmp(productid, "RUTHLESS SMP", 12))){
 		use_cyclone = 1; /*enable cyclone-timer*/
 		setup_summit();
-		usb_early_handoff = 1;
 		return 1;
 	}
 	return 0;
@@ -46,7 +44,6 @@ static inline int acpi_madt_oem_check(char *oem_id, char *oem_table_id)
 	     || !strncmp(oem_table_id, "EXA", 3))){
 		use_cyclone = 1; /*enable cyclone-timer*/
 		setup_summit();
-		usb_early_handoff = 1;
 		return 1;
 	}
 	return 0;
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 7d300f7469e3..467a096c3b81 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -96,6 +96,9 @@
 #define PCI_CLASS_SERIAL_ACCESS		0x0c01
 #define PCI_CLASS_SERIAL_SSA		0x0c02
 #define PCI_CLASS_SERIAL_USB		0x0c03
+#define PCI_CLASS_SERIAL_USB_UHCI	0x0c0300
+#define PCI_CLASS_SERIAL_USB_OHCI	0x0c0310
+#define PCI_CLASS_SERIAL_USB_EHCI	0x0c0320
 #define PCI_CLASS_SERIAL_FIBER		0x0c04
 #define PCI_CLASS_SERIAL_SMBUS		0x0c05
 </pre><hr><pre>commit 3e8a556a02d5aa16375d4d74aad0f67cd844c047
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 18 10:08:31 2005 -0400

    [PATCH] Missing transfer_flags setting in usbtest
    
    This patch (as582) adds a missing transfer_flags setting to the usbtest
    driver.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index d055196533af..90a96257d6ce 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -983,6 +983,7 @@ test_ctrl_queue (struct usbtest_dev *dev, struct usbtest_param *param)
 		reqp-&gt;number = i % NUM_SUBCASES;
 		reqp-&gt;expected = expected;
 		u-&gt;setup_packet = (char *) &amp;reqp-&gt;setup;
+		u-&gt;transfer_flags |= URB_NO_SETUP_DMA_MAP;
 
 		u-&gt;context = &amp;context;
 		u-&gt;complete = ctrl_complete;</pre><hr><pre>commit f37be9b9be3ebc02d2d075d7f53f7802f3e005db
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 17 10:42:06 2005 -0400

    [PATCH] Fix hcd-&gt;state assignments in uhci-hcd
    
    This patch (as581) changes the assignments to hcd-&gt;state in the uhci-hcd
    driver.  It fixes part of bugzilla entry #5227.  The problem was revealed
    by David's large suite of USB suspend/resume patches; this patch should go
    to Linus at the same time those do.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 72cd1576d20c..d33ce3982a5f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -161,8 +161,8 @@ static void configure_hc(struct uhci_hcd *uhci)
 	/* Set the current frame number */
 	outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
 
-	/* Mark controller as running before we enable interrupts */
-	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
+	/* Mark controller as not halted before we enable interrupts */
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_SUSPENDED;
 	mb();
 
 	/* Enable PIRQ */
@@ -263,6 +263,7 @@ __acquires(uhci-&gt;lock)
 
 static void start_rh(struct uhci_hcd *uhci)
 {
+	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
 	uhci-&gt;is_stopped = 0;
 	smp_wmb();
 
@@ -708,7 +709,6 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 
 	if (uhci-&gt;rh_state &gt; UHCI_RH_SUSPENDED) {
 		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
-		hcd-&gt;state = HC_STATE_RUNNING;
 		rc = -EBUSY;
 		goto done;
 	};</pre><hr><pre>commit b81d34363c0b17c47f4ef63d5888c4f47f315d29
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 13 17:00:24 2005 -0400

    [PATCH] UHCI: Improve handling of iso TDs
    
    The uhci-hcd driver is fairly lax about the way it handles isochronous
    transfers.  This patch (as579) improves it in three respects:
    
            TDs for a new URB aren't added to the schedule until all of
            them have been allocated.  This way there's no risk of the
            controller executing some of them when an allocation fails.
    
            TDs for an unlinked URB are removed from the schedule as soon
            as the URB is unlinked, rather than waiting until the URB is
            given back.  This way there's no risk of the controller still
            executing a TD after the URB completes.
    
            The urb-&gt;error_count values are now reported correctly.
            Although since they aren't used in any drivers except for
            debug messages in the system log, probably nobody cares.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 51de06bc438d..7e46887d9e12 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -108,13 +108,16 @@ static void uhci_insert_td_frame_list(struct uhci_hcd *uhci, struct uhci_td *td,
 	}
 }
 
-static void uhci_remove_td(struct uhci_hcd *uhci, struct uhci_td *td)
+static inline void uhci_remove_td_frame_list(struct uhci_hcd *uhci,
+		struct uhci_td *td)
 {
 	/* If it's not inserted, don't remove it */
-	if (td-&gt;frame == -1 &amp;&amp; list_empty(&amp;td-&gt;fl_list))
+	if (td-&gt;frame == -1) {
+		WARN_ON(!list_empty(&amp;td-&gt;fl_list));
 		return;
+	}
 
-	if (td-&gt;frame != -1 &amp;&amp; uhci-&gt;frame_cpu[td-&gt;frame] == td) {
+	if (uhci-&gt;frame_cpu[td-&gt;frame] == td) {
 		if (list_empty(&amp;td-&gt;fl_list)) {
 			uhci-&gt;frame[td-&gt;frame] = td-&gt;link;
 			uhci-&gt;frame_cpu[td-&gt;frame] = NULL;
@@ -132,13 +135,20 @@ static void uhci_remove_td(struct uhci_hcd *uhci, struct uhci_td *td)
 		ptd-&gt;link = td-&gt;link;
 	}
 
-	wmb();
-	td-&gt;link = UHCI_PTR_TERM;
-
 	list_del_init(&amp;td-&gt;fl_list);
 	td-&gt;frame = -1;
 }
 
+static void unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)
+{
+	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
+	struct uhci_td *td;
+
+	list_for_each_entry(td, &amp;urbp-&gt;td_list, list)
+		uhci_remove_td_frame_list(uhci, td);
+	wmb();
+}
+
 /*
  * Inserts a td list into qh.
  */
@@ -498,7 +508,6 @@ static void uhci_destroy_urb_priv(struct uhci_hcd *uhci, struct urb *urb)
 
 	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
 		uhci_remove_td_from_urb(td);
-		uhci_remove_td(uhci, td);
 		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
 	}
 
@@ -1068,6 +1077,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 	struct uhci_td *td;
 	int i, ret, frame;
 	int status, destination;
+	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
 	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
@@ -1076,11 +1086,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 	if (ret)
 		return ret;
 
-	frame = urb-&gt;start_frame;
-	for (i = 0; i &lt; urb-&gt;number_of_packets; i++, frame += urb-&gt;interval) {
-		if (!urb-&gt;iso_frame_desc[i].length)
-			continue;
-
+	for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 		td = uhci_alloc_td(uhci);
 		if (!td)
 			return -ENOMEM;
@@ -1091,8 +1097,12 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 
 		if (i + 1 &gt;= urb-&gt;number_of_packets)
 			td-&gt;status |= cpu_to_le32(TD_CTRL_IOC);
+	}
 
+	frame = urb-&gt;start_frame;
+	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
 		uhci_insert_td_frame_list(uhci, td, frame);
+		frame += urb-&gt;interval;
 	}
 
 	return -EINPROGRESS;
@@ -1105,7 +1115,7 @@ static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 	int status;
 	int i, ret = 0;
 
-	urb-&gt;actual_length = 0;
+	urb-&gt;actual_length = urb-&gt;error_count = 0;
 
 	i = 0;
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
@@ -1129,6 +1139,7 @@ static int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)
 
 		i++;
 	}
+	unlink_isochronous_tds(uhci, urb);
 
 	return ret;
 }
@@ -1361,6 +1372,8 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 		goto done;
 	list_del_init(&amp;urbp-&gt;urb_list);
 
+	if (usb_pipetype(urb-&gt;pipe) == PIPE_ISOCHRONOUS)
+		unlink_isochronous_tds(uhci, urb);
 	uhci_unlink_generic(uhci, urb);
 
 	uhci_get_current_frame_number(uhci);</pre><hr><pre>commit 0c0382e32d46f606951010b202382be14d180a17
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 13 17:08:02 2005 -0400

    [PATCH] USB: Rename hcd-&gt;hub_suspend to hcd-&gt;bus_suspend
    
    This patch (as580) is perhaps the only result from the long discussion I
    had with David about his changes to the root-hub suspend/resume code.  It
    renames the hub_suspend and hub_resume methods in struct usb_hcd to
    bus_suspend and bus_resume.  These are more descriptive names, since the
    methods really do suspend or resume an entire USB bus, and less likely to
    be confused with the hub_suspend and hub_resume routines in hub.c.
    
    It also takes David's advice about removing the layer of bus glue, where
    those methods are called.  And it implements a related change that David
    made to the other HCDs but forgot to put into dummy_hcd.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index b7bb8dd1894a..9ad3912a5ed7 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1433,16 +1433,16 @@ hcd_endpoint_disable (struct usb_device *udev, struct usb_host_endpoint *ep)
 
 #ifdef	CONFIG_PM
 
-static int hcd_hub_suspend (struct usb_bus *bus)
+int hcd_bus_suspend (struct usb_bus *bus)
 {
 	struct usb_hcd		*hcd;
 	int			status;
 
 	hcd = container_of (bus, struct usb_hcd, self);
-	if (!hcd-&gt;driver-&gt;hub_suspend)
+	if (!hcd-&gt;driver-&gt;bus_suspend)
 		return -ENOENT;
 	hcd-&gt;state = HC_STATE_QUIESCING;
-	status = hcd-&gt;driver-&gt;hub_suspend (hcd);
+	status = hcd-&gt;driver-&gt;bus_suspend (hcd);
 	if (status == 0)
 		hcd-&gt;state = HC_STATE_SUSPENDED;
 	else
@@ -1451,18 +1451,18 @@ static int hcd_hub_suspend (struct usb_bus *bus)
 	return status;
 }
 
-static int hcd_hub_resume (struct usb_bus *bus)
+int hcd_bus_resume (struct usb_bus *bus)
 {
 	struct usb_hcd		*hcd;
 	int			status;
 
 	hcd = container_of (bus, struct usb_hcd, self);
-	if (!hcd-&gt;driver-&gt;hub_resume)
+	if (!hcd-&gt;driver-&gt;bus_resume)
 		return -ENOENT;
 	if (hcd-&gt;state == HC_STATE_RUNNING)
 		return 0;
 	hcd-&gt;state = HC_STATE_RESUMING;
-	status = hcd-&gt;driver-&gt;hub_resume (hcd);
+	status = hcd-&gt;driver-&gt;bus_resume (hcd);
 	if (status == 0)
 		hcd-&gt;state = HC_STATE_RUNNING;
 	else {
@@ -1590,10 +1590,6 @@ static struct usb_operations usb_hcd_operations = {
 	.buffer_alloc =		hcd_buffer_alloc,
 	.buffer_free =		hcd_buffer_free,
 	.disable =		hcd_endpoint_disable,
-#ifdef	CONFIG_PM
-	.hub_suspend =		hcd_hub_suspend,
-	.hub_resume =		hcd_hub_resume,
-#endif
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/core/hcd.h b/drivers/usb/core/hcd.h
index 74757fc1a99f..d8f0d29a45b7 100644
--- a/drivers/usb/core/hcd.h
+++ b/drivers/usb/core/hcd.h
@@ -154,10 +154,6 @@ struct usb_operations {
 
 	void (*disable)(struct usb_device *udev,
 			struct usb_host_endpoint *ep);
-
-	/* global suspend/resume of bus */
-	int (*hub_suspend)(struct usb_bus *);
-	int (*hub_resume)(struct usb_bus *);
 };
 
 /* each driver provides one of these, and hardware init support */
@@ -212,8 +208,8 @@ struct hc_driver {
 	int		(*hub_control) (struct usb_hcd *hcd,
 				u16 typeReq, u16 wValue, u16 wIndex,
 				char *buf, u16 wLength);
-	int		(*hub_suspend)(struct usb_hcd *);
-	int		(*hub_resume)(struct usb_hcd *);
+	int		(*bus_suspend)(struct usb_hcd *);
+	int		(*bus_resume)(struct usb_hcd *);
 	int		(*start_port_reset)(struct usb_hcd *, unsigned port_num);
 	void		(*hub_irq_enable)(struct usb_hcd *);
 		/* Needed only if port-change IRQs are level-triggered */
@@ -379,6 +375,21 @@ extern int usb_find_interface_driver (struct usb_device *dev,
 
 #define usb_endpoint_out(ep_dir)	(!((ep_dir) &amp; USB_DIR_IN))
 
+#ifdef CONFIG_PM
+extern int hcd_bus_suspend (struct usb_bus *bus);
+extern int hcd_bus_resume (struct usb_bus *bus);
+#else
+static inline int hcd_bus_suspend(struct usb_bus *bus)
+{
+	return 0;
+}
+
+static inline int hcd_bus_resume (struct usb_bus *bus)
+{
+	return 0;
+}
+#endif /* CONFIG_PM */
+
 /*
  * USB device fs stuff
  */
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index e2802bf18095..273e6ccca213 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1917,8 +1917,8 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 	/* "global suspend" of the downstream HC-to-USB interface */
 	if (!hdev-&gt;parent) {
 		struct usb_bus	*bus = hdev-&gt;bus;
-		if (bus &amp;&amp; bus-&gt;op-&gt;hub_suspend) {
-			int	status = bus-&gt;op-&gt;hub_suspend (bus);
+		if (bus) {
+			int	status = hcd_bus_suspend (bus);
 
 			if (status != 0) {
 				dev_dbg(&amp;hdev-&gt;dev, "'global' suspend %d\n",
@@ -1943,8 +1943,8 @@ static int hub_resume(struct usb_interface *intf)
 	/* "global resume" of the downstream HC-to-USB interface */
 	if (!hdev-&gt;parent) {
 		struct usb_bus	*bus = hdev-&gt;bus;
-		if (bus &amp;&amp; bus-&gt;op-&gt;hub_resume) {
-			status = bus-&gt;op-&gt;hub_resume (bus);
+		if (bus) {
+			status = hcd_bus_resume (bus);
 			if (status) {
 				dev_dbg(&amp;intf-&gt;dev, "'global' resume %d\n",
 					status);
diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index 503201764f6b..c605aaeed636 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1751,7 +1751,7 @@ static int dummy_hub_control (
 	return retval;
 }
 
-static int dummy_hub_suspend (struct usb_hcd *hcd)
+static int dummy_bus_suspend (struct usb_hcd *hcd)
 {
 	struct dummy *dum = hcd_to_dummy (hcd);
 
@@ -1762,7 +1762,7 @@ static int dummy_hub_suspend (struct usb_hcd *hcd)
 	return 0;
 }
 
-static int dummy_hub_resume (struct usb_hcd *hcd)
+static int dummy_bus_resume (struct usb_hcd *hcd)
 {
 	struct dummy *dum = hcd_to_dummy (hcd);
 
@@ -1894,8 +1894,8 @@ static const struct hc_driver dummy_hcd = {
 
 	.hub_status_data = 	dummy_hub_status,
 	.hub_control = 		dummy_hub_control,
-	.hub_suspend =		dummy_hub_suspend,
-	.hub_resume =		dummy_hub_resume,
+	.bus_suspend =		dummy_bus_suspend,
+	.bus_resume =		dummy_bus_resume,
 };
 
 static int dummy_hcd_probe (struct device *dev)
@@ -1936,13 +1936,6 @@ static int dummy_hcd_suspend (struct device *dev, pm_message_t state)
 	dev_dbg (dev, "%s\n", __FUNCTION__);
 	hcd = dev_get_drvdata (dev);
 
-#ifndef CONFIG_USB_SUSPEND
-	/* Otherwise this would never happen */
-	usb_lock_device (hcd-&gt;self.root_hub);
-	dummy_hub_suspend (hcd);
-	usb_unlock_device (hcd-&gt;self.root_hub);
-#endif
-
 	hcd-&gt;state = HC_STATE_SUSPENDED;
 	return 0;
 }
@@ -1955,13 +1948,6 @@ static int dummy_hcd_resume (struct device *dev)
 	hcd = dev_get_drvdata (dev);
 	hcd-&gt;state = HC_STATE_RUNNING;
 
-#ifndef CONFIG_USB_SUSPEND
-	/* Otherwise this would never happen */
-	usb_lock_device (hcd-&gt;self.root_hub);
-	dummy_hub_resume (hcd);
-	usb_unlock_device (hcd-&gt;self.root_hub);
-#endif
-
 	usb_hcd_poll_rh_status (hcd);
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 18d3f2270316..88cb4ada686e 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -30,7 +30,7 @@
 
 #ifdef	CONFIG_PM
 
-static int ehci_hub_suspend (struct usb_hcd *hcd)
+static int ehci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	int			port;
@@ -83,7 +83,7 @@ static int ehci_hub_suspend (struct usb_hcd *hcd)
 
 
 /* caller has locked the root hub, and should reset/reinit on error */
-static int ehci_hub_resume (struct usb_hcd *hcd)
+static int ehci_bus_resume (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
 	u32			temp;
@@ -159,8 +159,8 @@ static int ehci_hub_resume (struct usb_hcd *hcd)
 
 #else
 
-#define ehci_hub_suspend	NULL
-#define ehci_hub_resume		NULL
+#define ehci_bus_suspend	NULL
+#define ehci_bus_resume		NULL
 
 #endif	/* CONFIG_PM */
 
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index 66ebf75b2037..8bbc8dfe19f3 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -363,8 +363,8 @@ static const struct hc_driver ehci_pci_hc_driver = {
 	 */
 	.hub_status_data =	ehci_hub_status_data,
 	.hub_control =		ehci_hub_control,
-	.hub_suspend =		ehci_hub_suspend,
-	.hub_resume =		ehci_hub_resume,
+	.bus_suspend =		ehci_bus_suspend,
+	.bus_resume =		ehci_bus_resume,
 };
 
 /*-------------------------------------------------------------------------*/
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
index f68220fc53fd..ddb8fc591466 100644
--- a/drivers/usb/host/isp116x-hcd.c
+++ b/drivers/usb/host/isp116x-hcd.c
@@ -1160,7 +1160,7 @@ static int isp116x_hub_control(struct usb_hcd *hcd,
 
 #ifdef	CONFIG_PM
 
-static int isp116x_hub_suspend(struct usb_hcd *hcd)
+static int isp116x_bus_suspend(struct usb_hcd *hcd)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	unsigned long flags;
@@ -1200,7 +1200,7 @@ static int isp116x_hub_suspend(struct usb_hcd *hcd)
 	return ret;
 }
 
-static int isp116x_hub_resume(struct usb_hcd *hcd)
+static int isp116x_bus_resume(struct usb_hcd *hcd)
 {
 	struct isp116x *isp116x = hcd_to_isp116x(hcd);
 	u32 val;
@@ -1266,8 +1266,8 @@ static int isp116x_hub_resume(struct usb_hcd *hcd)
 
 #else
 
-#define	isp116x_hub_suspend	NULL
-#define	isp116x_hub_resume	NULL
+#define	isp116x_bus_suspend	NULL
+#define	isp116x_bus_resume	NULL
 
 #endif
 
@@ -1626,8 +1626,8 @@ static struct hc_driver isp116x_hc_driver = {
 
 	.hub_status_data = isp116x_hub_status_data,
 	.hub_control = isp116x_hub_control,
-	.hub_suspend = isp116x_hub_suspend,
-	.hub_resume = isp116x_hub_resume,
+	.bus_suspend = isp116x_bus_suspend,
+	.bus_resume = isp116x_bus_resume,
 };
 
 /*----------------------------------------------------------------*/
diff --git a/drivers/usb/host/ohci-au1xxx.c b/drivers/usb/host/ohci-au1xxx.c
index 550d67a554f6..ac463c493035 100644
--- a/drivers/usb/host/ohci-au1xxx.c
+++ b/drivers/usb/host/ohci-au1xxx.c
@@ -215,8 +215,8 @@ static const struct hc_driver ohci_au1xxx_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/ohci-hub.c b/drivers/usb/host/ohci-hub.c
index 39a60e731ec2..e01e77bc324b 100644
--- a/drivers/usb/host/ohci-hub.c
+++ b/drivers/usb/host/ohci-hub.c
@@ -45,7 +45,7 @@ static void dl_done_list (struct ohci_hcd *, struct pt_regs *);
 static void finish_unlinks (struct ohci_hcd *, u16 , struct pt_regs *);
 static int ohci_restart (struct ohci_hcd *ohci);
 
-static int ohci_hub_suspend (struct usb_hcd *hcd)
+static int ohci_bus_suspend (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	int			status = 0;
@@ -135,7 +135,7 @@ static inline struct ed *find_head (struct ed *ed)
 }
 
 /* caller has locked the root hub */
-static int ohci_hub_resume (struct usb_hcd *hcd)
+static int ohci_bus_resume (struct usb_hcd *hcd)
 {
 	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
 	u32			temp, enables;
@@ -362,7 +362,7 @@ ohci_hub_status_data (struct usb_hcd *hcd, char *buf)
 			&amp;&amp; usb_trylock_device (hcd-&gt;self.root_hub)
 			) {
 		ohci_vdbg (ohci, "autosuspend\n");
-		(void) ohci_hub_suspend (hcd);
+		(void) ohci_bus_suspend (hcd);
 		usb_unlock_device (hcd-&gt;self.root_hub);
 	}
 #endif
diff --git a/drivers/usb/host/ohci-lh7a404.c b/drivers/usb/host/ohci-lh7a404.c
index 71d975ae78bd..e2ed55b69f86 100644
--- a/drivers/usb/host/ohci-lh7a404.c
+++ b/drivers/usb/host/ohci-lh7a404.c
@@ -194,8 +194,8 @@ static const struct hc_driver ohci_lh7a404_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/ohci-omap.c b/drivers/usb/host/ohci-omap.c
index b3498b9b965f..982cdca22516 100644
--- a/drivers/usb/host/ohci-omap.c
+++ b/drivers/usb/host/ohci-omap.c
@@ -421,8 +421,8 @@ static const struct hc_driver ohci_omap_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index 99a0ad41aec5..a8dde8b75691 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -195,8 +195,8 @@ static const struct hc_driver ohci_pci_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/ohci-ppc-soc.c b/drivers/usb/host/ohci-ppc-soc.c
index ec20710e99fe..228845eb7eab 100644
--- a/drivers/usb/host/ohci-ppc-soc.c
+++ b/drivers/usb/host/ohci-ppc-soc.c
@@ -164,8 +164,8 @@ static const struct hc_driver ohci_ppc_soc_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/ohci-pxa27x.c b/drivers/usb/host/ohci-pxa27x.c
index 2e7b48502a3d..d287dcccd415 100644
--- a/drivers/usb/host/ohci-pxa27x.c
+++ b/drivers/usb/host/ohci-pxa27x.c
@@ -279,8 +279,8 @@ static const struct hc_driver ohci_pxa27x_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef  CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/ohci-s3c2410.c b/drivers/usb/host/ohci-s3c2410.c
index 922e2a6f46ef..3225d455f459 100644
--- a/drivers/usb/host/ohci-s3c2410.c
+++ b/drivers/usb/host/ohci-s3c2410.c
@@ -449,8 +449,8 @@ static const struct hc_driver ohci_s3c2410_hc_driver = {
 	.hub_status_data =	ohci_s3c2410_hub_status_data,
 	.hub_control =		ohci_s3c2410_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/ohci-sa1111.c b/drivers/usb/host/ohci-sa1111.c
index 13324b7f9c59..fb3221ebbb29 100644
--- a/drivers/usb/host/ohci-sa1111.c
+++ b/drivers/usb/host/ohci-sa1111.c
@@ -236,8 +236,8 @@ static const struct hc_driver ohci_sa1111_hc_driver = {
 	.hub_status_data =	ohci_hub_status_data,
 	.hub_control =		ohci_hub_control,
 #ifdef	CONFIG_PM
-	.hub_suspend =		ohci_hub_suspend,
-	.hub_resume =		ohci_hub_resume,
+	.bus_suspend =		ohci_bus_suspend,
+	.bus_resume =		ohci_bus_resume,
 #endif
 	.start_port_reset =	ohci_start_port_reset,
 };
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index b5e7a478bc01..1e47c1f86e70 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -1363,7 +1363,7 @@ sl811h_hub_control(
 #ifdef	CONFIG_PM
 
 static int
-sl811h_hub_suspend(struct usb_hcd *hcd)
+sl811h_bus_suspend(struct usb_hcd *hcd)
 {
 	// SOFs off
 	DBG("%s\n", __FUNCTION__);
@@ -1371,7 +1371,7 @@ sl811h_hub_suspend(struct usb_hcd *hcd)
 }
 
 static int
-sl811h_hub_resume(struct usb_hcd *hcd)
+sl811h_bus_resume(struct usb_hcd *hcd)
 {
 	// SOFs on
 	DBG("%s\n", __FUNCTION__);
@@ -1380,8 +1380,8 @@ sl811h_hub_resume(struct usb_hcd *hcd)
 
 #else
 
-#define	sl811h_hub_suspend	NULL
-#define	sl811h_hub_resume	NULL
+#define	sl811h_bus_suspend	NULL
+#define	sl811h_bus_resume	NULL
 
 #endif
 
@@ -1623,8 +1623,8 @@ static struct hc_driver sl811h_hc_driver = {
 	 */
 	.hub_status_data =	sl811h_hub_status_data,
 	.hub_control =		sl811h_hub_control,
-	.hub_suspend =		sl811h_hub_suspend,
-	.hub_resume =		sl811h_hub_resume,
+	.bus_suspend =		sl811h_bus_suspend,
+	.bus_resume =		sl811h_bus_resume,
 };
 
 /*-------------------------------------------------------------------------*/
@@ -1791,7 +1791,7 @@ sl811h_suspend(struct device *dev, pm_message_t state)
 	int		retval = 0;
 
 	if (state.event == PM_EVENT_FREEZE)
-		retval = sl811h_hub_suspend(hcd);
+		retval = sl811h_bus_suspend(hcd);
 	else if (state.event == PM_EVENT_SUSPEND)
 		port_power(sl811, 0);
 	if (retval == 0)
@@ -1816,7 +1816,7 @@ sl811h_resume(struct device *dev)
 	}
 
 	dev-&gt;power.power_state = PMSG_ON;
-	return sl811h_hub_resume(hcd);
+	return sl811h_bus_resume(hcd);
 }
 
 #else
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 6df555e3d97c..72cd1576d20c 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -804,8 +804,8 @@ static const struct hc_driver uhci_driver = {
 #ifdef CONFIG_PM
 	.suspend =		uhci_suspend,
 	.resume =		uhci_resume,
-	.hub_suspend =		uhci_rh_suspend,
-	.hub_resume =		uhci_rh_resume,
+	.bus_suspend =		uhci_rh_suspend,
+	.bus_resume =		uhci_rh_resume,
 #endif
 	.stop =			uhci_stop,
 </pre><hr><pre>commit bb200f6eac6372839921be1fe87c1f5c292a7bd6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 3 16:36:29 2005 -0400

    [PATCH] UHCI: unify BIOS handoff and driver reset code
    
    This patch (as574) updates the PCI BIOS usb-handoff code for UHCI
    controllers, making it work like the reset routines in uhci-hcd.  This
    allows uhci-hcd to drop its own routines in favor of the new ones
    (code-sharing).
    
    Once the patch is merged we can turn the usb-handoff option on
    permanently, as far as UHCI is concerned.  OHCI and EHCI may still have
    some issues.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 49f7381a6fd3..f7411ca48835 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -9,6 +9,12 @@
  */
 
 #include &lt;linux/config.h&gt;
+#ifdef CONFIG_USB_DEBUG
+#define DEBUG
+#else
+#undef DEBUG
+#endif
+
 #include &lt;linux/types.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/pci.h&gt;
@@ -46,13 +52,14 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_2,	qui
 
 #define UHCI_USBLEGSUP		0xc0		/* legacy support */
 #define UHCI_USBCMD		0		/* command register */
-#define UHCI_USBSTS		2		/* status register */
 #define UHCI_USBINTR		4		/* interrupt register */
-#define UHCI_USBLEGSUP_DEFAULT	0x2000		/* only PIRQ enable set */
-#define UHCI_USBCMD_RUN		(1 &lt;&lt; 0)	/* RUN/STOP bit */
-#define UHCI_USBCMD_GRESET	(1 &lt;&lt; 2)	/* Global reset */
-#define UHCI_USBCMD_CONFIGURE	(1 &lt;&lt; 6)	/* config semaphore */
-#define UHCI_USBSTS_HALTED	(1 &lt;&lt; 5)	/* HCHalted bit */
+#define UHCI_USBLEGSUP_RWC	0x8f00		/* the R/WC bits */
+#define UHCI_USBLEGSUP_RO	0x5040		/* R/O and reserved bits */
+#define UHCI_USBCMD_RUN		0x0001		/* RUN/STOP bit */
+#define UHCI_USBCMD_HCRESET	0x0002		/* Host Controller reset */
+#define UHCI_USBCMD_EGSM	0x0008		/* Global Suspend Mode */
+#define UHCI_USBCMD_CONFIGURE	0x0040		/* Config Flag */
+#define UHCI_USBINTR_RESUME	0x0002		/* Resume interrupt enable */
 
 #define OHCI_CONTROL		0x04
 #define OHCI_CMDSTATUS		0x08
@@ -84,57 +91,100 @@ static int __init usb_handoff_early(char *str)
 }
 __setup("usb-handoff", usb_handoff_early);
 
-static void __devinit quirk_usb_handoff_uhci(struct pci_dev *pdev)
+/*
+ * Make sure the controller is completely inactive, unable to
+ * generate interrupts or do DMA.
+ */
+void uhci_reset_hc(struct pci_dev *pdev, unsigned long base)
 {
-	unsigned long base = 0;
-	int wait_time, delta;
-	u16 val, sts;
-	int i;
+	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
+	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
+	 */
+	pci_write_config_word(pdev, UHCI_USBLEGSUP, UHCI_USBLEGSUP_RWC);
 
-	for (i = 0; i &lt; PCI_ROM_RESOURCE; i++)
-		if ((pci_resource_flags(pdev, i) &amp; IORESOURCE_IO)) {
-			base = pci_resource_start(pdev, i);
-			break;
-		}
+	/* Reset the HC - this will force us to get a
+	 * new notification of any already connected
+	 * ports due to the virtual disconnect that it
+	 * implies.
+	 */
+	outw(UHCI_USBCMD_HCRESET, base + UHCI_USBCMD);
+	mb();
+	udelay(5);
+	if (inw(base + UHCI_USBCMD) &amp; UHCI_USBCMD_HCRESET)
+		dev_warn(&amp;pdev-&gt;dev, "HCRESET not completed yet!\n");
+
+	/* Just to be safe, disable interrupt requests and
+	 * make sure the controller is stopped.
+	 */
+	outw(0, base + UHCI_USBINTR);
+	outw(0, base + UHCI_USBCMD);
+}
+EXPORT_SYMBOL_GPL(uhci_reset_hc);
 
-	if (!base)
-		return;
+/*
+ * Initialize a controller that was newly discovered or has just been
+ * resumed.  In either case we can't be sure of its previous state.
+ *
+ * Returns: 1 if the controller was reset, 0 otherwise.
+ */
+int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)
+{
+	u16 legsup;
+	unsigned int cmd, intr;
 
 	/*
-	 * stop controller
+	 * When restarting a suspended controller, we expect all the
+	 * settings to be the same as we left them:
+	 *
+	 *	PIRQ and SMI disabled, no R/W bits set in USBLEGSUP;
+	 *	Controller is stopped and configured with EGSM set;
+	 *	No interrupts enabled except possibly Resume Detect.
+	 *
+	 * If any of these conditions are violated we do a complete reset.
 	 */
-	sts = inw(base + UHCI_USBSTS);
-	val = inw(base + UHCI_USBCMD);
-	val &amp;= ~(u16)(UHCI_USBCMD_RUN | UHCI_USBCMD_CONFIGURE);
-	outw(val, base + UHCI_USBCMD);
+	pci_read_config_word(pdev, UHCI_USBLEGSUP, &amp;legsup);
+	if (legsup &amp; ~(UHCI_USBLEGSUP_RO | UHCI_USBLEGSUP_RWC)) {
+		dev_dbg(&amp;pdev-&gt;dev, "%s: legsup = 0x%04x\n",
+				__FUNCTION__, legsup);
+		goto reset_needed;
+	}
 
-	/*
-	 * wait while it stops if it was running
-	 */
-	if ((sts &amp; UHCI_USBSTS_HALTED) == 0)
-	{
-		wait_time = 1000;
-		delta = 100;
+	cmd = inw(base + UHCI_USBCMD);
+	if ((cmd &amp; UHCI_USBCMD_RUN) || !(cmd &amp; UHCI_USBCMD_CONFIGURE) ||
+			!(cmd &amp; UHCI_USBCMD_EGSM)) {
+		dev_dbg(&amp;pdev-&gt;dev, "%s: cmd = 0x%04x\n",
+				__FUNCTION__, cmd);
+		goto reset_needed;
+	}
 
-		do {
-			outw(0x1f, base + UHCI_USBSTS);
-			udelay(delta);
-			wait_time -= delta;
-			val = inw(base + UHCI_USBSTS);
-			if (val &amp; UHCI_USBSTS_HALTED)
-				break;
-		} while (wait_time &gt; 0);
+	intr = inw(base + UHCI_USBINTR);
+	if (intr &amp; (~UHCI_USBINTR_RESUME)) {
+		dev_dbg(&amp;pdev-&gt;dev, "%s: intr = 0x%04x\n",
+				__FUNCTION__, intr);
+		goto reset_needed;
 	}
+	return 0;
 
-	/*
-	 * disable interrupts &amp; legacy support
-	 */
-	outw(0, base + UHCI_USBINTR);
-	outw(0x1f, base + UHCI_USBSTS);
-	pci_read_config_word(pdev, UHCI_USBLEGSUP, &amp;val);
-	if (val &amp; 0xbf)
-		pci_write_config_word(pdev, UHCI_USBLEGSUP, UHCI_USBLEGSUP_DEFAULT);
+reset_needed:
+	dev_dbg(&amp;pdev-&gt;dev, "Performing full reset\n");
+	uhci_reset_hc(pdev, base);
+	return 1;
+}
+EXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);
+
+static void __devinit quirk_usb_handoff_uhci(struct pci_dev *pdev)
+{
+	unsigned long base = 0;
+	int i;
+
+	for (i = 0; i &lt; PCI_ROM_RESOURCE; i++)
+		if ((pci_resource_flags(pdev, i) &amp; IORESOURCE_IO)) {
+			base = pci_resource_start(pdev, i);
+			break;
+		}
 
+	if (base)
+		uhci_check_and_reset_hc(pdev, base);
 }
 
 static void __devinit quirk_usb_handoff_ohci(struct pci_dev *pdev)
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 34c9dbc6a156..6df555e3d97c 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -101,37 +101,16 @@ static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 #include "uhci-q.c"
 #include "uhci-hub.c"
 
+extern void uhci_reset_hc(struct pci_dev *pdev, unsigned long base);
+extern int uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base);
+
 /*
- * Make sure the controller is completely inactive, unable to
- * generate interrupts or do DMA.
+ * Finish up a host controller reset and update the recorded state.
  */
-static void reset_hc(struct uhci_hcd *uhci)
+static void finish_reset(struct uhci_hcd *uhci)
 {
 	int port;
 
-	/* Turn off PIRQ enable and SMI enable.  (This also turns off the
-	 * BIOS's USB Legacy Support.)  Turn off all the R/WC bits too.
-	 */
-	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP,
-			USBLEGSUP_RWC);
-
-	/* Reset the HC - this will force us to get a
-	 * new notification of any already connected
-	 * ports due to the virtual disconnect that it
-	 * implies.
-	 */
-	outw(USBCMD_HCRESET, uhci-&gt;io_addr + USBCMD);
-	mb();
-	udelay(5);
-	if (inw(uhci-&gt;io_addr + USBCMD) &amp; USBCMD_HCRESET)
-		dev_warn(uhci_dev(uhci), "HCRESET not completed yet!\n");
-
-	/* Just to be safe, disable interrupt requests and
-	 * make sure the controller is stopped.
-	 */
-	outw(0, uhci-&gt;io_addr + USBINTR);
-	outw(0, uhci-&gt;io_addr + USBCMD);
-
 	/* HCRESET doesn't affect the Suspend, Reset, and Resume Detect
 	 * bits in the port status and control registers.
 	 * We have to clear them by hand.
@@ -153,7 +132,8 @@ static void reset_hc(struct uhci_hcd *uhci)
  */
 static void hc_died(struct uhci_hcd *uhci)
 {
-	reset_hc(uhci);
+	uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci-&gt;io_addr);
+	finish_reset(uhci);
 	uhci-&gt;hc_inaccessible = 1;
 }
 
@@ -163,44 +143,8 @@ static void hc_died(struct uhci_hcd *uhci)
  */
 static void check_and_reset_hc(struct uhci_hcd *uhci)
 {
-	u16 legsup;
-	unsigned int cmd, intr;
-
-	/*
-	 * When restarting a suspended controller, we expect all the
-	 * settings to be the same as we left them:
-	 *
-	 *	PIRQ and SMI disabled, no R/W bits set in USBLEGSUP;
-	 *	Controller is stopped and configured with EGSM set;
-	 *	No interrupts enabled except possibly Resume Detect.
-	 *
-	 * If any of these conditions are violated we do a complete reset.
-	 */
-	pci_read_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, &amp;legsup);
-	if (legsup &amp; ~(USBLEGSUP_RO | USBLEGSUP_RWC)) {
-		dev_dbg(uhci_dev(uhci), "%s: legsup = 0x%04x\n",
-				__FUNCTION__, legsup);
-		goto reset_needed;
-	}
-
-	cmd = inw(uhci-&gt;io_addr + USBCMD);
-	if ((cmd &amp; USBCMD_RS) || !(cmd &amp; USBCMD_CF) || !(cmd &amp; USBCMD_EGSM)) {
-		dev_dbg(uhci_dev(uhci), "%s: cmd = 0x%04x\n",
-				__FUNCTION__, cmd);
-		goto reset_needed;
-	}
-
-	intr = inw(uhci-&gt;io_addr + USBINTR);
-	if (intr &amp; (~USBINTR_RESUME)) {
-		dev_dbg(uhci_dev(uhci), "%s: intr = 0x%04x\n",
-				__FUNCTION__, intr);
-		goto reset_needed;
-	}
-	return;
-
-reset_needed:
-	dev_dbg(uhci_dev(uhci), "Performing full reset\n");
-	reset_hc(uhci);
+	if (uhci_check_and_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci-&gt;io_addr))
+		finish_reset(uhci);
 }
 
 /*
@@ -714,7 +658,7 @@ static void uhci_stop(struct usb_hcd *hcd)
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
 	if (!uhci-&gt;hc_inaccessible)
-		reset_hc(uhci);
+		hc_died(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 </pre><hr><pre>commit a922c68732725866c88457026cf06a7620846506
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 6 16:38:45 2005 -0400

    [PATCH] g_file_storage: fix obscure race condition
    
    This patch (as575) fixes an unlikely race in the g_file_storage driver.
    The problem can occur only when the driver is unbound before its
    initialization routine has finished.
    
    I also took the opportunity to replace kmalloc/memset with kzalloc.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index 241c570e541c..86a6aeb9ed76 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -3823,12 +3823,11 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 
 	/* Create the LUNs, open their backing files, and register the
 	 * LUN devices in sysfs. */
-	fsg-&gt;luns = kmalloc(i * sizeof(struct lun), GFP_KERNEL);
+	fsg-&gt;luns = kzalloc(i * sizeof(struct lun), GFP_KERNEL);
 	if (!fsg-&gt;luns) {
 		rc = -ENOMEM;
 		goto out;
 	}
-	memset(fsg-&gt;luns, 0, i * sizeof(struct lun));
 	fsg-&gt;nluns = i;
 
 	for (i = 0; i &lt; fsg-&gt;nluns; ++i) {
@@ -3989,6 +3988,11 @@ static int __init fsg_bind(struct usb_gadget *gadget)
 			mod_data.removable, mod_data.can_stall,
 			mod_data.buflen);
 	DBG(fsg, "I/O thread pid: %d\n", fsg-&gt;thread_task-&gt;pid);
+
+	set_bit(REGISTERED, &amp;fsg-&gt;atomic_bitflags);
+
+	/* Tell the thread to start working */
+	wake_up_process(fsg-&gt;thread_task);
 	return 0;
 
 autoconf_fail:
@@ -4051,10 +4055,9 @@ static int __init fsg_alloc(void)
 {
 	struct fsg_dev		*fsg;
 
-	fsg = kmalloc(sizeof *fsg, GFP_KERNEL);
+	fsg = kzalloc(sizeof *fsg, GFP_KERNEL);
 	if (!fsg)
 		return -ENOMEM;
-	memset(fsg, 0, sizeof *fsg);
 	spin_lock_init(&amp;fsg-&gt;lock);
 	init_rwsem(&amp;fsg-&gt;filesem);
 	init_waitqueue_head(&amp;fsg-&gt;thread_wqh);
@@ -4080,15 +4083,9 @@ static int __init fsg_init(void)
 	if ((rc = fsg_alloc()) != 0)
 		return rc;
 	fsg = the_fsg;
-	if ((rc = usb_gadget_register_driver(&amp;fsg_driver)) != 0) {
+	if ((rc = usb_gadget_register_driver(&amp;fsg_driver)) != 0)
 		fsg_free(fsg);
-		return rc;
-	}
-	set_bit(REGISTERED, &amp;fsg-&gt;atomic_bitflags);
-
-	/* Tell the thread to start working */
-	wake_up_process(fsg-&gt;thread_task);
-	return 0;
+	return rc;
 }
 module_init(fsg_init);
 </pre>
    <div class="pagination">
        <a href='2_133.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><span>[134]</span><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_135.html'>Next&gt;&gt;</a>
    <div>
</body>
