<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_125.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><span>[126]</span><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_127.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit caf3827a65af476c71eaeb79636869a4ab128d48
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:44:55 2006 -0400

    [PATCH] UHCI: store the period in the queue header
    
    This patch (as689) stores the period for periodic transfers (interrupt
    and ISO) in the queue header.  This is necessary for proper bandwidth
    tracking (not yet implemented).  It also makes the scheduling of ISO
    transfers a bit more rigorous, with checks for out-of-bounds frame
    numbers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index ecef5880cfd9..ab8ba8220ad1 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -153,7 +153,7 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	char *qtype;
 
 	/* Try to make sure there's enough memory */
-	if (len &lt; 80 * 6)
+	if (len &lt; 80 * 7)
 		return 0;
 
 	switch (qh-&gt;type) {
@@ -167,6 +167,9 @@ static int uhci_show_qh(struct uhci_qh *qh, char *buf, int len, int space)
 	out += sprintf(out, "%*s[%p] %s QH link (%08x) element (%08x)\n",
 			space, "", qh, qtype,
 			le32_to_cpu(qh-&gt;link), le32_to_cpu(element));
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+		out += sprintf(out, "%*s    period %d\n",
+				space, "", qh-&gt;period);
 
 	if (element &amp; UHCI_PTR_QH)
 		out += sprintf(out, "%*s  Element points to QH (bug?)\n", space, "");
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index c87ceaa178b6..eaac6ddf03a0 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -140,6 +140,8 @@ struct uhci_qh {
 
 	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
+	unsigned int period;		/* For Interrupt and Isochronous QHs */
+
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
 
@@ -315,38 +317,8 @@ static inline u32 td_status(struct uhci_td *td) {
 #define skel_bulk_qh		skelqh[12]
 #define skel_term_qh		skelqh[13]
 
-/*
- * Search tree for determining where &lt;interval&gt; fits in the skelqh[]
- * skeleton.
- *
- * An interrupt request should be placed into the slowest skelqh[]
- * which meets the interval/period/frequency requirement.
- * An interrupt request is allowed to be faster than &lt;interval&gt; but not slower.
- *
- * For a given &lt;interval&gt;, this function returns the appropriate/matching
- * skelqh[] index value.
- */
-static inline int __interval_to_skel(int interval)
-{
-	if (interval &lt; 16) {
-		if (interval &lt; 4) {
-			if (interval &lt; 2)
-				return 9;	/* int1 for 0-1 ms */
-			return 8;		/* int2 for 2-3 ms */
-		}
-		if (interval &lt; 8)
-			return 7;		/* int4 for 4-7 ms */
-		return 6;			/* int8 for 8-15 ms */
-	}
-	if (interval &lt; 64) {
-		if (interval &lt; 32)
-			return 5;		/* int16 for 16-31 ms */
-		return 4;			/* int32 for 32-63 ms */
-	}
-	if (interval &lt; 128)
-		return 3;			/* int64 for 64-127 ms */
-	return 2;				/* int128 for 128-255 ms (Max.) */
-}
+/* Find the skelqh entry corresponding to an interval exponent */
+#define UHCI_SKEL_INDEX(exponent)	(9 - exponent)
 
 
 /*
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 96ce4c87c871..7acc23473c63 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -763,6 +763,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	wmb();
 	qh-&gt;dummy_td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_ACTIVE);
 	qh-&gt;dummy_td = td;
+	qh-&gt;period = urb-&gt;interval;
 
 	usb_settoggle(urb-&gt;dev, usb_pipeendpoint(urb-&gt;pipe),
 			usb_pipeout(urb-&gt;pipe), toggle);
@@ -790,14 +791,30 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 	return ret;
 }
 
-static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
+static int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
+	int exponent;
+
 	/* USB 1.1 interrupt transfers only involve one packet per interval.
 	 * Drivers can submit URBs of any length, but longer ones will need
 	 * multiple intervals to complete.
 	 */
-	qh-&gt;skel = uhci-&gt;skelqh[__interval_to_skel(urb-&gt;interval)];
+
+	/* Figure out which power-of-two queue to use */
+	for (exponent = 7; exponent &gt;= 0; --exponent) {
+		if ((1 &lt;&lt; exponent) &lt;= urb-&gt;interval)
+			break;
+	}
+	if (exponent &lt; 0)
+		return -EINVAL;
+	urb-&gt;interval = 1 &lt;&lt; exponent;
+
+	if (qh-&gt;period == 0)
+		qh-&gt;skel = uhci-&gt;skelqh[UHCI_SKEL_INDEX(exponent)];
+	else if (qh-&gt;period != urb-&gt;interval)
+		return -EINVAL;		/* Can't change the period */
+
 	return uhci_submit_common(uhci, urb, qh);
 }
 
@@ -937,31 +954,50 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	unsigned long destination, status;
 	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
 
-	if (urb-&gt;number_of_packets &gt; 900)	/* 900? Why? */
+	/* Values must not be too big (could overflow below) */
+	if (urb-&gt;interval &gt;= UHCI_NUMFRAMES ||
+			urb-&gt;number_of_packets &gt;= UHCI_NUMFRAMES)
 		return -EFBIG;
 
-	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
-	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
+	/* Check the period and figure out the starting frame number */
+	uhci_get_current_frame_number(uhci);
+	if (qh-&gt;period == 0) {
+		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+			urb-&gt;start_frame = uhci-&gt;frame_number + 10;
+		} else {
+			i = urb-&gt;start_frame - uhci-&gt;frame_number;
+			if (i &lt;= 0 || i &gt;= UHCI_NUMFRAMES)
+				return -EINVAL;
+		}
+	} else if (qh-&gt;period != urb-&gt;interval) {
+		return -EINVAL;		/* Can't change the period */
 
-	/* Figure out the starting frame number */
-	if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+	} else {	/* Pick up where the last URB leaves off */
 		if (list_empty(&amp;qh-&gt;queue)) {
-			uhci_get_current_frame_number(uhci);
-			urb-&gt;start_frame = (uhci-&gt;frame_number + 10);
-
-		} else {		/* Go right after the last one */
-			struct urb *last_urb;
+			frame = uhci-&gt;frame_number + 10;
+		} else {
+			struct urb *lurb;
 
-			last_urb = list_entry(qh-&gt;queue.prev,
+			lurb = list_entry(qh-&gt;queue.prev,
 					struct urb_priv, node)-&gt;urb;
-			urb-&gt;start_frame = (last_urb-&gt;start_frame +
-					last_urb-&gt;number_of_packets *
-					last_urb-&gt;interval);
+			frame = lurb-&gt;start_frame +
+					lurb-&gt;number_of_packets *
+					lurb-&gt;interval;
 		}
-	} else {
+		if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+			urb-&gt;start_frame = frame;
 		/* FIXME: Sanity check */
 	}
 
+	/* Make sure we won't have to go too far into the future */
+	if (uhci_frame_before_eq(uhci-&gt;frame_number + UHCI_NUMFRAMES,
+			urb-&gt;start_frame + urb-&gt;number_of_packets *
+				urb-&gt;interval))
+		return -EFBIG;
+
+	status = TD_CTRL_ACTIVE | TD_CTRL_IOS;
+	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | usb_packetid(urb-&gt;pipe);
+
 	for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 		td = uhci_alloc_td(uhci);
 		if (!td)
@@ -978,6 +1014,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	td-&gt;status |= __constant_cpu_to_le32(TD_CTRL_IOC);
 
 	qh-&gt;skel = uhci-&gt;skel_iso_qh;
+	qh-&gt;period = urb-&gt;interval;
 
 	/* Add the TDs to the frame list */
 	frame = urb-&gt;start_frame;
@@ -1206,6 +1243,7 @@ __acquires(uhci-&gt;lock)
 		uhci_unlink_qh(uhci, qh);
 
 		/* Bandwidth stuff not yet implemented */
+		qh-&gt;period = 0;
 	}
 }
 </pre><hr><pre>commit 10b8e47d6b32bfba22874354c62770cb4e42aa6c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:39:52 2006 -0400

    [PATCH] UHCI: fix race in ISO dequeuing
    
    This patch (as688) fixes a small race in uhci-hcd.  Because ISO queues
    aren't controlled by queue headers, they can't be unlinked.  Only
    individual URBs can.  So whenever multiple ISO URBs are dequeued, it's
    necessary to make sure the hardware is done with each one.  We can't
    assume that dequeuing the first URB will suffice to unlink the entire
    queue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 76b0a9e95a7a..96ce4c87c871 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -194,7 +194,6 @@ static void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)
 
 	list_for_each_entry(td, &amp;urbp-&gt;td_list, list)
 		uhci_remove_td_from_frame_list(uhci, td);
-	wmb();
 }
 
 static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
@@ -253,17 +252,25 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
  * When a queue is stopped and a dequeued URB is given back, adjust
  * the previous TD link (if the URB isn't first on the queue) or
  * save its toggle value (if it is first and is currently executing).
+ *
+ * Returns 0 if the URB should not yet be given back, 1 otherwise.
  */
-static void uhci_cleanup_queue(struct uhci_qh *qh,
+static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		struct urb *urb)
 {
 	struct urb_priv *urbp = urb-&gt;hcpriv;
 	struct uhci_td *td;
+	int ret = 1;
 
 	/* Isochronous pipes don't use toggles and their TD link pointers
-	 * get adjusted during uhci_urb_dequeue(). */
-	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		return;
+	 * get adjusted during uhci_urb_dequeue().  But since their queues
+	 * cannot truly be stopped, we have to watch out for dequeues
+	 * occurring after the nominal unlink frame. */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
+		ret = (uhci-&gt;frame_number + uhci-&gt;is_stopped !=
+				qh-&gt;unlink_frame);
+		return ret;
+	}
 
 	/* If the URB isn't first on its queue, adjust the link pointer
 	 * of the last TD in the previous URB.  The toggle doesn't need
@@ -279,24 +286,25 @@ static void uhci_cleanup_queue(struct uhci_qh *qh,
 		td = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
 				list);
 		ptd-&gt;link = td-&gt;link;
-		return;
+		return ret;
 	}
 
 	/* If the QH element pointer is UHCI_PTR_TERM then then currently
 	 * executing URB has already been unlinked, so this one isn't it. */
 	if (qh_element(qh) == UHCI_PTR_TERM)
-		return;
+		return ret;
 	qh-&gt;element = UHCI_PTR_TERM;
 
 	/* Control pipes have to worry about toggles */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
-		return;
+		return ret;
 
 	/* Save the next toggle value */
 	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
 	qh-&gt;needs_fixup = 1;
 	qh-&gt;initial_toggle = uhci_toggle(td_token(td));
+	return ret;
 }
 
 /*
@@ -953,7 +961,6 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 	} else {
 		/* FIXME: Sanity check */
 	}
-	urb-&gt;start_frame &amp;= (UHCI_NUMFRAMES - 1);
 
 	for (i = 0; i &lt; urb-&gt;number_of_packets; i++) {
 		td = uhci_alloc_td(uhci);
@@ -1120,16 +1127,26 @@ static int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 	unsigned long flags;
 	struct urb_priv *urbp;
+	struct uhci_qh *qh;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 	urbp = urb-&gt;hcpriv;
 	if (!urbp)			/* URB was never linked! */
 		goto done;
+	qh = urbp-&gt;qh;
 
 	/* Remove Isochronous TDs from the frame list ASAP */
-	if (urbp-&gt;qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
 		uhci_unlink_isochronous_tds(uhci, urb);
-	uhci_unlink_qh(uhci, urbp-&gt;qh);
+		mb();
+
+		/* If the URB has already started, update the QH unlink time */
+		uhci_get_current_frame_number(uhci);
+		if (uhci_frame_before_eq(urb-&gt;start_frame, uhci-&gt;frame_number))
+			qh-&gt;unlink_frame = uhci-&gt;frame_number;
+	}
+
+	uhci_unlink_qh(uhci, qh);
 
 done:
 	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
@@ -1250,7 +1267,14 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
 		if (urb-&gt;status != -EINPROGRESS) {
-			uhci_cleanup_queue(qh, urb);
+
+			/* Fix up the TD links and save the toggles for
+			 * non-Isochronous queues.  For Isochronous queues,
+			 * test for too-recent dequeues. */
+			if (!uhci_cleanup_queue(uhci, qh, urb)) {
+				qh-&gt;is_stopped = 0;
+				return;
+			}
 			uhci_giveback_urb(uhci, qh, urb, regs);
 			goto restart;
 		}</pre><hr><pre>commit c433472658b4df11bd3590a59be79194a1ff43ae
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 19 16:34:57 2006 -0400

    [PATCH] UHCI: use integer-sized frame numbers
    
    This patch (as687) changes uhci-hcd to keep track of frame numbers as
    full-sized integers rather than 11-bit values.  This makes them a lot
    easier to handle and makes it possible to schedule beyond a 2-second
    window, should anyone ever want to do so.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 081c592fe8b1..ecef5880cfd9 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -289,7 +289,7 @@ static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 	unsigned short portsc1, portsc2;
 
 	/* Try to make sure there's enough memory */
-	if (len &lt; 80 * 6)
+	if (len &lt; 80 * 9)
 		return 0;
 
 	usbcmd    = inw(io_addr + 0);
@@ -328,6 +328,8 @@ static int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)
 	out += sprintf(out, "  sof       =       %02x\n", sof);
 	out += uhci_show_sc(1, portsc1, out, len - (out - buf));
 	out += uhci_show_sc(2, portsc2, out, len - (out - buf));
+	out += sprintf(out, "Most recent frame: %x\n",
+			uhci-&gt;frame_number);
 
 	return out - buf;
 }
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 395402eec5ef..5e75ad6dc29f 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
  *
  * Intel documents this fairly well, and as far as I know there
  * are no royalties or anything like that, but even so there are
@@ -31,7 +31,6 @@
 #include &lt;linux/ioport.h&gt;
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/slab.h&gt;
-#include &lt;linux/smp_lock.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/unistd.h&gt;
 #include &lt;linux/interrupt.h&gt;
@@ -146,7 +145,8 @@ static void configure_hc(struct uhci_hcd *uhci)
 	outl(uhci-&gt;frame_dma_handle, uhci-&gt;io_addr + USBFLBASEADD);
 
 	/* Set the current frame number */
-	outw(uhci-&gt;frame_number, uhci-&gt;io_addr + USBFRNUM);
+	outw(uhci-&gt;frame_number &amp; UHCI_MAX_SOF_NUMBER,
+			uhci-&gt;io_addr + USBFRNUM);
 
 	/* Mark controller as not halted before we enable interrupts */
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_SUSPENDED;
@@ -239,7 +239,6 @@ __acquires(uhci-&gt;lock)
 		dev_warn(uhci_dev(uhci), "Controller not stopped yet!\n");
 
 	uhci_get_current_frame_number(uhci);
-	smp_wmb();
 
 	uhci-&gt;rh_state = new_state;
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
@@ -253,7 +252,6 @@ static void start_rh(struct uhci_hcd *uhci)
 {
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_RUNNING;
 	uhci-&gt;is_stopped = 0;
-	smp_wmb();
 
 	/* Mark it configured and running with a 64-byte max packet.
 	 * All interrupts are enabled, even though RESUME won't do anything.
@@ -360,12 +358,21 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 
 /*
  * Store the current frame number in uhci-&gt;frame_number if the controller
- * is runnning
+ * is runnning.  Expand from 11 bits (of which we use only 10) to a
+ * full-sized integer.
+ *
+ * Like many other parts of the driver, this code relies on being polled
+ * more than once per second as long as the controller is running.
  */
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci)
 {
-	if (!uhci-&gt;is_stopped)
-		uhci-&gt;frame_number = inw(uhci-&gt;io_addr + USBFRNUM);
+	if (!uhci-&gt;is_stopped) {
+		unsigned delta;
+
+		delta = (inw(uhci-&gt;io_addr + USBFRNUM) - uhci-&gt;frame_number) &amp;
+				(UHCI_NUMFRAMES - 1);
+		uhci-&gt;frame_number += delta;
+	}
 }
 
 /*
@@ -798,18 +805,15 @@ static void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,
 static int uhci_hcd_get_frame_number(struct usb_hcd *hcd)
 {
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
-	unsigned long flags;
-	int is_stopped;
-	int frame_number;
+	unsigned frame_number;
+	unsigned delta;
 
 	/* Minimize latency by avoiding the spinlock */
-	local_irq_save(flags);
-	is_stopped = uhci-&gt;is_stopped;
-	smp_rmb();
-	frame_number = (is_stopped ? uhci-&gt;frame_number :
-			inw(uhci-&gt;io_addr + USBFRNUM));
-	local_irq_restore(flags);
-	return frame_number;
+	frame_number = uhci-&gt;frame_number;
+	barrier();
+	delta = (inw(uhci-&gt;io_addr + USBFRNUM) - frame_number) &amp;
+			(UHCI_NUMFRAMES - 1);
+	return frame_number + delta;
 }
 
 static const char hcd_name[] = "uhci_hcd";
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 04938e64799f..c87ceaa178b6 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -448,6 +448,9 @@ static inline struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci)
 
 #define uhci_dev(u)	(uhci_to_hcd(u)-&gt;self.controller)
 
+/* Utility macro for comparing frame numbers */
+#define uhci_frame_before_eq(f1, f2)	(0 &lt;= (int) ((f2) - (f1)))
+
 
 /*
  *	Private per-URB data</pre><hr><pre>commit b761d9d867bcc29e8de3e62d1d72b27e75078ca6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:41:59 2006 -0400

    [PATCH] UHCI: Work around old Intel bug
    
    Some old Intel UHCI controllers have a bug that has shown up in a few
    systems (the PIIX3 "Neptune" chip set).  Until now there has not been
    any simple way to work around the bug, but the lastest changes in
    uhci-hcd have made it easy.  This patch (as684) adds the work-around.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 2be84b3b40fe..76b0a9e95a7a 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -13,7 +13,7 @@
  * (C) Copyright 2000 Yggdrasil Computing, Inc. (port of new PCI interface
  *               support from usb-ohci.c by Adam Richter, adam@yggdrasil.com).
  * (C) Copyright 1999 Gregory P. Smith (from usb-ohci.c)
- * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
+ * (C) Copyright 2004-2006 Alan Stern, stern@rowland.harvard.edu
  */
 
 
@@ -1287,6 +1287,11 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
  * Check for queues that have made some forward progress.
  * Returns 0 if the queue is not Isochronous, is ACTIVE, and
  * has not advanced since last examined; 1 otherwise.
+ *
+ * Early Intel controllers have a bug which causes qh-&gt;element sometimes
+ * not to advance when a TD completes successfully.  The queue remains
+ * stuck on the inactive completed TD.  We detect such cases and advance
+ * the element pointer by hand.
  */
 static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 {
@@ -1327,6 +1332,15 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	/* The queue hasn't advanced; check for timeout */
 	if (!qh-&gt;wait_expired &amp;&amp; time_after(jiffies,
 			qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
+
+		/* Detect the Intel bug and work around it */
+		if (qh-&gt;post_td &amp;&amp; qh_element(qh) ==
+				cpu_to_le32(qh-&gt;post_td-&gt;dma_handle)) {
+			qh-&gt;element = qh-&gt;post_td-&gt;link;
+			qh-&gt;advance_jiffies = jiffies;
+			return 1;
+		}
+
 		qh-&gt;wait_expired = 1;
 
 		/* If the current URB wants FSBR, unlink it temporarily</pre><hr><pre>commit 84afddd7ac58adad00cb0e50d0af25fcf825668b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:35:45 2006 -0400

    [PATCH] UHCI: Reimplement FSBR
    
    This patch (as683) re-implements Full-Speed Bandwidth Reclamation (FSBR)
    properly.  It keeps track of which endpoint queues have advanced, and
    when none have advanced for a sufficiently long time, FSBR is turned
    off.  The next TD on each of the non-moving queues is modified to
    generate an interrupt on completion, so that FSBR can be re-enabled as
    soon as the hardware starts to make some progress.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 6bbd33db9358..081c592fe8b1 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -274,7 +274,8 @@ static int uhci_show_root_hub_state(struct uhci_hcd *uhci, char *buf, int len)
 	    default:
 		rh_state = "?";			break;
 	}
-	out += sprintf(out, "Root-hub state: %s\n", rh_state);
+	out += sprintf(out, "Root-hub state: %s   FSBR: %d\n",
+			rh_state, uhci-&gt;fsbr_is_on);
 	return out - buf;
 }
 
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index fb4c1a8cadf4..395402eec5ef 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -88,15 +88,6 @@ static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);
 static void wakeup_rh(struct uhci_hcd *uhci);
 static void uhci_get_current_frame_number(struct uhci_hcd *uhci);
 
-/* If a transfer is still active after this much time, turn off FSBR */
-#define IDLE_TIMEOUT	msecs_to_jiffies(50)
-#define FSBR_DELAY	msecs_to_jiffies(50)
-
-/* When we timeout an idle transfer for FSBR, we'll switch it over to */
-/* depth first traversal. We'll do it in groups of this number of TDs */
-/* to make sure it doesn't hog all of the bandwidth */
-#define DEPTH_INTERVAL 5
-
 #include "uhci-debug.c"
 #include "uhci-q.c"
 #include "uhci-hub.c"
@@ -255,6 +246,7 @@ __acquires(uhci-&gt;lock)
 	uhci_to_hcd(uhci)-&gt;poll_rh = !int_enable;
 
 	uhci_scan_schedule(uhci, NULL);
+	uhci_fsbr_off(uhci);
 }
 
 static void start_rh(struct uhci_hcd *uhci)
@@ -487,9 +479,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	hcd-&gt;uses_new_polling = 1;
 
-	uhci-&gt;fsbr = 0;
-	uhci-&gt;fsbrtimeout = 0;
-
 	spin_lock_init(&amp;uhci-&gt;lock);
 
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 90ef7fbbf2fb..04938e64799f 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -84,6 +84,13 @@
 #define CAN_SCHEDULE_FRAMES	1000	/* how far in the future frames
 					 * can be scheduled */
 
+/* When no queues need Full-Speed Bandwidth Reclamation,
+ * delay this long before turning FSBR off */
+#define FSBR_OFF_DELAY		msecs_to_jiffies(400)
+
+/* If a queue hasn't advanced after this much time, assume it is stuck */
+#define QH_WAIT_TIMEOUT		msecs_to_jiffies(200)
+
 
 /*
  *	Queue Headers
@@ -131,6 +138,7 @@ struct uhci_qh {
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
 	struct uhci_td *post_td;	/* Last TD completed */
 
+	unsigned long advance_jiffies;	/* Time of last queue advance */
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
 	int type;			/* Queue type (control, bulk, etc) */
@@ -138,6 +146,7 @@ struct uhci_qh {
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
 	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
+	unsigned int wait_expired:1;	/* QH_WAIT_TIMEOUT has expired */
 } __attribute__((aligned(16)));
 
 /*
@@ -397,8 +406,7 @@ struct uhci_hcd {
 	__le32 *frame;
 	void **frame_cpu;		/* CPU's frame list */
 
-	int fsbr;			/* Full-speed bandwidth reclamation */
-	unsigned long fsbrtimeout;	/* FSBR delay */
+	unsigned long fsbr_jiffies;	/* Time when FSBR was last wanted */
 
 	enum uhci_rh_state rh_state;
 	unsigned long auto_stop_time;		/* When to AUTO_STOP */
@@ -413,6 +421,7 @@ struct uhci_hcd {
 	unsigned int working_RD:1;		/* Suspended root hub doesn't
 						   need to be polled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
+	unsigned int fsbr_is_on:1;		/* FSBR is turned on */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
@@ -451,7 +460,7 @@ struct urb_priv {
 	struct uhci_qh *qh;		/* QH for this URB */
 	struct list_head td_list;
 
-	unsigned fsbr : 1;		/* URB turned on FSBR */
+	unsigned fsbr:1;		/* URB wants FSBR */
 };
 
 
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index c8451d9578f1..f53c116e0dfd 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -173,7 +173,6 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	uhci_scan_schedule(uhci, NULL);
 	if (uhci-&gt;hc_inaccessible)
 		goto done;
-	check_fsbr(uhci);
 	uhci_check_ports(uhci);
 
 	status = get_hub_status_data(uhci, buf);
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 12af6fb05a30..2be84b3b40fe 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -37,6 +37,46 @@ static inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)
 	uhci-&gt;term_td-&gt;status &amp;= ~cpu_to_le32(TD_CTRL_IOC);
 }
 
+
+/*
+ * Full-Speed Bandwidth Reclamation (FSBR).
+ * We turn on FSBR whenever a queue that wants it is advancing,
+ * and leave it on for a short time thereafter.
+ */
+static void uhci_fsbr_on(struct uhci_hcd *uhci)
+{
+	uhci-&gt;fsbr_is_on = 1;
+	uhci-&gt;skel_term_qh-&gt;link = cpu_to_le32(
+			uhci-&gt;skel_fs_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
+}
+
+static void uhci_fsbr_off(struct uhci_hcd *uhci)
+{
+	uhci-&gt;fsbr_is_on = 0;
+	uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
+}
+
+static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
+{
+	struct urb_priv *urbp = urb-&gt;hcpriv;
+
+	if (!(urb-&gt;transfer_flags &amp; URB_NO_FSBR))
+		urbp-&gt;fsbr = 1;
+}
+
+static void uhci_qh_wants_fsbr(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct urb_priv *urbp =
+			list_entry(qh-&gt;queue.next, struct urb_priv, node);
+
+	if (urbp-&gt;fsbr) {
+		uhci-&gt;fsbr_jiffies = jiffies;
+		if (!uhci-&gt;fsbr_is_on)
+			uhci_fsbr_on(uhci);
+	}
+}
+
+
 static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 {
 	dma_addr_t dma_handle;
@@ -331,6 +371,10 @@ static void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
 	}
 
+	/* Treat the queue as if it has just advanced */
+	qh-&gt;wait_expired = 0;
+	qh-&gt;advance_jiffies = jiffies;
+
 	if (qh-&gt;state == QH_STATE_ACTIVE)
 		return;
 	qh-&gt;state = QH_STATE_ACTIVE;
@@ -445,28 +489,6 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 	kmem_cache_free(uhci_up_cachep, urbp);
 }
 
-static void uhci_inc_fsbr(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-
-	if ((!(urb-&gt;transfer_flags &amp; URB_NO_FSBR)) &amp;&amp; !urbp-&gt;fsbr) {
-		urbp-&gt;fsbr = 1;
-		if (!uhci-&gt;fsbr++ &amp;&amp; !uhci-&gt;fsbrtimeout)
-			uhci-&gt;skel_term_qh-&gt;link = cpu_to_le32(uhci-&gt;skel_fs_control_qh-&gt;dma_handle) | UHCI_PTR_QH;
-	}
-}
-
-static void uhci_dec_fsbr(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-
-	if ((!(urb-&gt;transfer_flags &amp; URB_NO_FSBR)) &amp;&amp; urbp-&gt;fsbr) {
-		urbp-&gt;fsbr = 0;
-		if (!--uhci-&gt;fsbr)
-			uhci-&gt;fsbrtimeout = jiffies + FSBR_DELAY;
-	}
-}
-
 /*
  * Map status to standard result codes
  *
@@ -613,7 +635,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;skel = uhci-&gt;skel_ls_control_qh;
 	else {
 		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
-		uhci_inc_fsbr(uhci, urb);
+		uhci_add_fsbr(uhci, urb);
 	}
 
 	urb-&gt;actual_length = -8;	/* Account for the SETUP packet */
@@ -756,7 +778,7 @@ static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 	qh-&gt;skel = uhci-&gt;skel_bulk_qh;
 	ret = uhci_submit_common(uhci, urb, qh);
 	if (ret == 0)
-		uhci_inc_fsbr(uhci, urb);
+		uhci_add_fsbr(uhci, urb);
 	return ret;
 }
 
@@ -1075,8 +1097,10 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	 * the QH is new and idle or else it's unlinked and waiting to
 	 * become idle, so we can activate it right away.  But only if the
 	 * queue isn't stopped. */
-	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped)
+	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped) {
 		uhci_activate_qh(uhci, qh);
+		uhci_qh_wants_fsbr(uhci, qh);
+	}
 	goto done;
 
 err_submit_failed:
@@ -1135,7 +1159,6 @@ __acquires(uhci-&gt;lock)
 		qh-&gt;needs_fixup = 0;
 	}
 
-	uhci_dec_fsbr(uhci, urb);	/* Safe since it checks */
 	uhci_free_urb_priv(uhci, urbp);
 
 	switch (qh-&gt;type) {
@@ -1239,6 +1262,18 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	if (!list_empty(&amp;qh-&gt;queue)) {
 		if (qh-&gt;needs_fixup)
 			uhci_fixup_toggles(qh, 0);
+
+		/* If the first URB on the queue wants FSBR but its time
+		 * limit has expired, set the next TD to interrupt on
+		 * completion before reactivating the QH. */
+		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
+		if (urbp-&gt;fsbr &amp;&amp; qh-&gt;wait_expired) {
+			struct uhci_td *td = list_entry(urbp-&gt;td_list.next,
+					struct uhci_td, list);
+
+			td-&gt;status |= __cpu_to_le32(TD_CTRL_IOC);
+		}
+
 		uhci_activate_qh(uhci, qh);
 	}
 
@@ -1248,6 +1283,62 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		uhci_make_qh_idle(uhci, qh);
 }
 
+/*
+ * Check for queues that have made some forward progress.
+ * Returns 0 if the queue is not Isochronous, is ACTIVE, and
+ * has not advanced since last examined; 1 otherwise.
+ */
+static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
+{
+	struct urb_priv *urbp = NULL;
+	struct uhci_td *td;
+	int ret = 1;
+	unsigned status;
+
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+		return ret;
+
+	/* Treat an UNLINKING queue as though it hasn't advanced.
+	 * This is okay because reactivation will treat it as though
+	 * it has advanced, and if it is going to become IDLE then
+	 * this doesn't matter anyway.  Furthermore it's possible
+	 * for an UNLINKING queue not to have any URBs at all, or
+	 * for its first URB not to have any TDs (if it was dequeued
+	 * just as it completed).  So it's not easy in any case to
+	 * test whether such queues have advanced. */
+	if (qh-&gt;state != QH_STATE_ACTIVE) {
+		urbp = NULL;
+		status = 0;
+
+	} else {
+		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
+		td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
+		status = td_status(td);
+		if (!(status &amp; TD_CTRL_ACTIVE)) {
+
+			/* We're okay, the queue has advanced */
+			qh-&gt;wait_expired = 0;
+			qh-&gt;advance_jiffies = jiffies;
+			return ret;
+		}
+		ret = 0;
+	}
+
+	/* The queue hasn't advanced; check for timeout */
+	if (!qh-&gt;wait_expired &amp;&amp; time_after(jiffies,
+			qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
+		qh-&gt;wait_expired = 1;
+
+		/* If the current URB wants FSBR, unlink it temporarily
+		 * so that we can safely set the next TD to interrupt on
+		 * completion.  That way we'll know as soon as the queue
+		 * starts moving again. */
+		if (urbp &amp;&amp; urbp-&gt;fsbr &amp;&amp; !(status &amp; TD_CTRL_IOC))
+			uhci_unlink_qh(uhci, qh);
+	}
+	return ret;
+}
+
 /*
  * Process events in the schedule, but only in one thread at a time
  */
@@ -1262,7 +1353,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		return;
 	}
 	uhci-&gt;scan_in_progress = 1;
- rescan:
+rescan:
 	uhci-&gt;need_rescan = 0;
 
 	uhci_clear_next_interrupt(uhci);
@@ -1275,7 +1366,12 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		while ((qh = uhci-&gt;next_qh) != uhci-&gt;skelqh[i]) {
 			uhci-&gt;next_qh = list_entry(qh-&gt;node.next,
 					struct uhci_qh, node);
-			uhci_scan_qh(uhci, qh, regs);
+
+			if (uhci_advance_check(uhci, qh)) {
+				uhci_scan_qh(uhci, qh, regs);
+				if (qh-&gt;state == QH_STATE_ACTIVE)
+					uhci_qh_wants_fsbr(uhci, qh);
+			}
 		}
 	}
 
@@ -1283,20 +1379,12 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
+	if (uhci-&gt;fsbr_is_on &amp;&amp; time_after(jiffies,
+			uhci-&gt;fsbr_jiffies + FSBR_OFF_DELAY))
+		uhci_fsbr_off(uhci);
+
 	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_clear_next_interrupt(uhci);
 	else
 		uhci_set_next_interrupt(uhci);
 }
-
-static void check_fsbr(struct uhci_hcd *uhci)
-{
-	/* For now, don't scan URBs for FSBR timeouts.
-	 * Add it back in later... */
-
-	/* Really disable FSBR */
-	if (!uhci-&gt;fsbr &amp;&amp; uhci-&gt;fsbrtimeout &amp;&amp; time_after_eq(jiffies, uhci-&gt;fsbrtimeout)) {
-		uhci-&gt;fsbrtimeout = 0;
-		uhci-&gt;skel_term_qh-&gt;link = UHCI_PTR_TERM;
-	}
-}</pre><hr><pre>commit 04538a255ac8b404c20cbf15867c9829254c470f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:29:04 2006 -0400

    [PATCH] UHCI: Eliminate the TD-removal list
    
    This patch (as682) gets rid of the TD-removal list in uhci-hcd.  It is
    no longer needed because now TDs are not freed until we know the
    hardware isn't using them.  It also simplifies the code for adding and
    removing TDs to/from URBs.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index d225e11f4055..fb4c1a8cadf4 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -492,7 +492,6 @@ static int uhci_start(struct usb_hcd *hcd)
 
 	spin_lock_init(&amp;uhci-&gt;lock);
 
-	INIT_LIST_HEAD(&amp;uhci-&gt;td_remove_list);
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
 
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 3093ca250942..90ef7fbbf2fb 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -228,7 +228,6 @@ struct uhci_td {
 	dma_addr_t dma_handle;
 
 	struct list_head list;
-	struct list_head remove_list;
 
 	int frame;			/* for iso: what frame? */
 	struct list_head fl_list;
@@ -420,10 +419,6 @@ struct uhci_hcd {
 	unsigned long resuming_ports;
 	unsigned long ports_timeout;		/* Time to stop signalling */
 
-	/* List of TDs that are done, but waiting to be freed (race) */
-	struct list_head td_remove_list;
-	unsigned int td_remove_age;		/* Age in frames */
-
 	struct list_head idle_qh_list;		/* Where the idle QHs live */
 
 	int rh_numports;			/* Number of root-hub ports */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 64b6c74789fd..12af6fb05a30 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -16,7 +16,6 @@
  * (C) Copyright 2004-2005 Alan Stern, stern@rowland.harvard.edu
  */
 
-static void uhci_free_pending_tds(struct uhci_hcd *uhci);
 
 /*
  * Technically, updating td-&gt;status here is a race, but it's not really a
@@ -51,7 +50,6 @@ static struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)
 	td-&gt;frame = -1;
 
 	INIT_LIST_HEAD(&amp;td-&gt;list);
-	INIT_LIST_HEAD(&amp;td-&gt;remove_list);
 	INIT_LIST_HEAD(&amp;td-&gt;fl_list);
 
 	return td;
@@ -61,8 +59,6 @@ static void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)
 {
 	if (!list_empty(&amp;td-&gt;list))
 		dev_warn(uhci_dev(uhci), "td %p still in list!\n", td);
-	if (!list_empty(&amp;td-&gt;remove_list))
-		dev_warn(uhci_dev(uhci), "td %p still in remove_list!\n", td);
 	if (!list_empty(&amp;td-&gt;fl_list))
 		dev_warn(uhci_dev(uhci), "td %p still in fl_list!\n", td);
 
@@ -77,6 +73,16 @@ static inline void uhci_fill_td(struct uhci_td *td, u32 status,
 	td-&gt;buffer = cpu_to_le32(buffer);
 }
 
+static void uhci_add_td_to_urbp(struct uhci_td *td, struct urb_priv *urbp)
+{
+	list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;td_list);
+}
+
+static void uhci_remove_td_from_urbp(struct uhci_td *td)
+{
+	list_del_init(&amp;td-&gt;list);
+}
+
 /*
  * We insert Isochronous URBs directly into the frame list at the beginning
  */
@@ -421,21 +427,6 @@ static inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,
 	return urbp;
 }
 
-static void uhci_add_td_to_urb(struct urb *urb, struct uhci_td *td)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-
-	list_add_tail(&amp;td-&gt;list, &amp;urbp-&gt;td_list);
-}
-
-static void uhci_remove_td_from_urb(struct uhci_td *td)
-{
-	if (list_empty(&amp;td-&gt;list))
-		return;
-
-	list_del_init(&amp;td-&gt;list);
-}
-
 static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 		struct urb_priv *urbp)
 {
@@ -445,20 +436,9 @@ static void uhci_free_urb_priv(struct uhci_hcd *uhci,
 		dev_warn(uhci_dev(uhci), "urb %p still on QH's list!\n",
 				urbp-&gt;urb);
 
-	uhci_get_current_frame_number(uhci);
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;td_remove_age) {
-		uhci_free_pending_tds(uhci);
-		uhci-&gt;td_remove_age = uhci-&gt;frame_number;
-	}
-
-	/* Check to see if the remove list is empty. Set the IOC bit */
-	/* to force an interrupt so we can remove the TDs. */
-	if (list_empty(&amp;uhci-&gt;td_remove_list))
-		uhci_set_next_interrupt(uhci);
-
 	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
-		uhci_remove_td_from_urb(td);
-		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
+		uhci_remove_td_from_urbp(td);
+		uhci_free_td(uhci, td);
 	}
 
 	urbp-&gt;urb-&gt;hcpriv = NULL;
@@ -529,6 +509,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	int len = urb-&gt;transfer_buffer_length;
 	dma_addr_t data = urb-&gt;transfer_dma;
 	__le32 *plink;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
 
 	/* The "pipe" thing contains the destination in bits 8--18 */
 	destination = (urb-&gt;pipe &amp; PIPE_DEVEP_MASK) | USB_PID_SETUP;
@@ -542,7 +523,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	 * Build the TD for the control request setup packet
 	 */
 	td = qh-&gt;dummy_td;
-	uhci_add_td_to_urb(urb, td);
+	uhci_add_td_to_urbp(td, urbp);
 	uhci_fill_td(td, status, destination | uhci_explen(8),
 			urb-&gt;setup_dma);
 	plink = &amp;td-&gt;link;
@@ -574,7 +555,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		/* Alternate Data0/1 (start with Data1) */
 		destination ^= TD_TOKEN_TOGGLE;
 	
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status, destination | uhci_explen(pktsze),
 				data);
 		plink = &amp;td-&gt;link;
@@ -605,7 +586,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 
 	status &amp;= ~TD_CTRL_SPD;
 
-	uhci_add_td_to_urb(urb, td);
+	uhci_add_td_to_urbp(td, urbp);
 	uhci_fill_td(td, status | TD_CTRL_IOC,
 			destination | uhci_explen(0), 0);
 	plink = &amp;td-&gt;link;
@@ -640,7 +621,7 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 
 nomem:
 	/* Remove the dummy TD from the td_list so it doesn't get freed */
-	uhci_remove_td_from_urb(qh-&gt;dummy_td);
+	uhci_remove_td_from_urbp(qh-&gt;dummy_td);
 	return -ENOMEM;
 }
 
@@ -656,6 +637,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	int len = urb-&gt;transfer_buffer_length;
 	dma_addr_t data = urb-&gt;transfer_dma;
 	__le32 *plink;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
 	unsigned int toggle;
 
 	if (len &lt; 0)
@@ -693,7 +675,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 				goto nomem;
 			*plink = cpu_to_le32(td-&gt;dma_handle);
 		}
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
 				destination | uhci_explen(pktsze) |
 					(toggle &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
@@ -721,7 +703,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 			goto nomem;
 		*plink = cpu_to_le32(td-&gt;dma_handle);
 
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status,
 				destination | uhci_explen(0) |
 					(toggle &lt;&lt; TD_TOKEN_TOGGLE_SHIFT),
@@ -758,7 +740,7 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 
 nomem:
 	/* Remove the dummy TD from the td_list so it doesn't get freed */
-	uhci_remove_td_from_urb(qh-&gt;dummy_td);
+	uhci_remove_td_from_urbp(qh-&gt;dummy_td);
 	return -ENOMEM;
 }
 
@@ -830,8 +812,8 @@ static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
 		td = list_entry(tmp, struct uhci_td, list);
 		tmp = tmp-&gt;prev;
 
-		uhci_remove_td_from_urb(td);
-		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
+		uhci_remove_td_from_urbp(td);
+		uhci_free_td(uhci, td);
 	}
 	return ret;
 }
@@ -885,10 +867,9 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				ret = 1;
 		}
 
-		uhci_remove_td_from_urb(td);
+		uhci_remove_td_from_urbp(td);
 		if (qh-&gt;post_td)
-			list_add(&amp;qh-&gt;post_td-&gt;remove_list,
-					&amp;uhci-&gt;td_remove_list);
+			uhci_free_td(uhci, qh-&gt;post_td);
 		qh-&gt;post_td = td;
 
 		if (ret != 0)
@@ -957,7 +938,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		if (!td)
 			return -ENOMEM;
 
-		uhci_add_td_to_urb(urb, td);
+		uhci_add_td_to_urbp(td, urbp);
 		uhci_fill_td(td, status, destination |
 				uhci_explen(urb-&gt;iso_frame_desc[i].length),
 				urb-&gt;transfer_dma +
@@ -1267,17 +1248,6 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		uhci_make_qh_idle(uhci, qh);
 }
 
-static void uhci_free_pending_tds(struct uhci_hcd *uhci)
-{
-	struct uhci_td *td, *tmp;
-
-	list_for_each_entry_safe(td, tmp, &amp;uhci-&gt;td_remove_list, remove_list) {
-		list_del_init(&amp;td-&gt;remove_list);
-
-		uhci_free_td(uhci, td);
-	}
-}
-
 /*
  * Process events in the schedule, but only in one thread at a time
  */
@@ -1298,9 +1268,6 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
 
-	if (uhci-&gt;frame_number + uhci-&gt;is_stopped != uhci-&gt;td_remove_age)
-		uhci_free_pending_tds(uhci);
-
 	/* Go through all the QH queues and process the URBs in each one */
 	for (i = 0; i &lt; UHCI_NUM_SKELQH - 1; ++i) {
 		uhci-&gt;next_qh = list_entry(uhci-&gt;skelqh[i]-&gt;node.next,
@@ -1316,12 +1283,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
-	/* If the controller is stopped, we can finish these off right now */
-	if (uhci-&gt;is_stopped)
-		uhci_free_pending_tds(uhci);
-
-	if (list_empty(&amp;uhci-&gt;td_remove_list) &amp;&amp;
-			list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
+	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_clear_next_interrupt(uhci);
 	else
 		uhci_set_next_interrupt(uhci);</pre><hr><pre>commit a0b458b64b2a3a4cb806dd5cd889bbf6c7e9d686
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:23:19 2006 -0400

    [PATCH] UHCI: Move code for cleaning up unlinked URBs
    
    This patch (as681) moves some code for cleaning up after unlinked URBs
    out of the general completion pathway into the unlinking pathway.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 888938d78230..64b6c74789fd 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -204,25 +204,49 @@ static void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)
 }
 
 /*
- * When the currently executing URB is dequeued, save its current toggle value
+ * When a queue is stopped and a dequeued URB is given back, adjust
+ * the previous TD link (if the URB isn't first on the queue) or
+ * save its toggle value (if it is first and is currently executing).
  */
-static void uhci_save_toggle(struct uhci_qh *qh, struct urb *urb)
+static void uhci_cleanup_queue(struct uhci_qh *qh,
+		struct urb *urb)
 {
-	struct urb_priv *urbp = (struct urb_priv *) urb-&gt;hcpriv;
+	struct urb_priv *urbp = urb-&gt;hcpriv;
 	struct uhci_td *td;
 
+	/* Isochronous pipes don't use toggles and their TD link pointers
+	 * get adjusted during uhci_urb_dequeue(). */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
+		return;
+
+	/* If the URB isn't first on its queue, adjust the link pointer
+	 * of the last TD in the previous URB.  The toggle doesn't need
+	 * to be saved since this URB can't be executing yet. */
+	if (qh-&gt;queue.next != &amp;urbp-&gt;node) {
+		struct urb_priv *purbp;
+		struct uhci_td *ptd;
+
+		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
+		WARN_ON(list_empty(&amp;purbp-&gt;td_list));
+		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		td = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
+				list);
+		ptd-&gt;link = td-&gt;link;
+		return;
+	}
+
 	/* If the QH element pointer is UHCI_PTR_TERM then then currently
 	 * executing URB has already been unlinked, so this one isn't it. */
-	if (qh_element(qh) == UHCI_PTR_TERM ||
-				qh-&gt;queue.next != &amp;urbp-&gt;node)
+	if (qh_element(qh) == UHCI_PTR_TERM)
 		return;
 	qh-&gt;element = UHCI_PTR_TERM;
 
-	/* Only bulk and interrupt pipes have to worry about toggles */
-	if (!(qh-&gt;type == USB_ENDPOINT_XFER_BULK ||
-			qh-&gt;type == USB_ENDPOINT_XFER_INT))
+	/* Control pipes have to worry about toggles */
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
 		return;
 
+	/* Save the next toggle value */
 	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
 	qh-&gt;needs_fixup = 1;
@@ -1121,21 +1145,6 @@ __acquires(uhci-&gt;lock)
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 		uhci_unlink_isochronous_tds(uhci, urb);
 
-	/* If the URB isn't first on its queue, adjust the link pointer
-	 * of the last TD in the previous URB. */
-	else if (qh-&gt;queue.next != &amp;urbp-&gt;node) {
-		struct urb_priv *purbp;
-		struct uhci_td *ptd, *ltd;
-
-		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
-		WARN_ON(list_empty(&amp;purbp-&gt;td_list));
-		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
-				list);
-		ltd = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
-				list);
-		ptd-&gt;link = ltd-&gt;link;
-	}
-
 	/* Take the URB off the QH's queue.  If the queue is now empty,
 	 * this is a perfect time for a toggle fixup. */
 	list_del_init(&amp;urbp-&gt;node);
@@ -1237,7 +1246,7 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	list_for_each_entry(urbp, &amp;qh-&gt;queue, node) {
 		urb = urbp-&gt;urb;
 		if (urb-&gt;status != -EINPROGRESS) {
-			uhci_save_toggle(qh, urb);
+			uhci_cleanup_queue(qh, urb);
 			uhci_giveback_urb(uhci, qh, urb, regs);
 			goto restart;
 		}</pre><hr><pre>commit 59e29ed91cff90b27d393c7a3d3ac9c3fcaea7dd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:19:19 2006 -0400

    [PATCH] UHCI: Remove non-iso TDs as they are used
    
    This patch (as680) frees non-isochronous TDs as they are used, rather
    than all at once when an URB is complete.  Although not a terribly
    important change in itself, it opens the door to a later enhancement
    that will reduce storage requirements by allocating only a limited
    number of TDs at any time for each endpoint queue.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-debug.c b/drivers/usb/host/uhci-debug.c
index 28c1c51ec475..6bbd33db9358 100644
--- a/drivers/usb/host/uhci-debug.c
+++ b/drivers/usb/host/uhci-debug.c
@@ -119,6 +119,7 @@ static int uhci_show_urbp(struct urb_priv *urbp, char *buf, int len, int space)
 	}
 
 	out += sprintf(out, "%s%s", ptype, (urbp-&gt;fsbr ? " FSBR" : ""));
+	out += sprintf(out, " Actlen=%d", urbp-&gt;urb-&gt;actual_length);
 
 	if (urbp-&gt;urb-&gt;status != -EINPROGRESS)
 		out += sprintf(out, " Status=%d", urbp-&gt;urb-&gt;status);
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 8e5778650493..3093ca250942 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -129,6 +129,7 @@ struct uhci_qh {
 	struct list_head queue;		/* Queue of urbps for this QH */
 	struct uhci_qh *skel;		/* Skeleton for this QH */
 	struct uhci_td *dummy_td;	/* Dummy TD to end the queue */
+	struct uhci_td *post_td;	/* Last TD completed */
 
 	unsigned int unlink_frame;	/* When the QH was unlinked */
 	int state;			/* QH_STATE_xxx; see above */
@@ -136,7 +137,7 @@ struct uhci_qh {
 
 	unsigned int initial_toggle:1;	/* Endpoint's current toggle value */
 	unsigned int needs_fixup:1;	/* Must fix the TD toggle values */
-	unsigned int is_stopped:1;	/* Queue was stopped by an error */
+	unsigned int is_stopped:1;	/* Queue was stopped by error/unlink */
 } __attribute__((aligned(16)));
 
 /*
@@ -456,8 +457,6 @@ struct urb_priv {
 	struct list_head td_list;
 
 	unsigned fsbr : 1;		/* URB turned on FSBR */
-	unsigned short_transfer : 1;	/* URB got a short transfer, no
-					 * need to rescan */
 };
 
 
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 30e36031fe21..888938d78230 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -161,6 +161,7 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 	if (!qh)
 		return NULL;
 
+	memset(qh, 0, sizeof(*qh));
 	qh-&gt;dma_handle = dma_handle;
 
 	qh-&gt;element = UHCI_PTR_TERM;
@@ -183,7 +184,6 @@ static struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,
 
 	} else {		/* Skeleton QH */
 		qh-&gt;state = QH_STATE_ACTIVE;
-		qh-&gt;udev = NULL;
 		qh-&gt;type = -1;
 	}
 	return qh;
@@ -223,16 +223,10 @@ static void uhci_save_toggle(struct uhci_qh *qh, struct urb *urb)
 			qh-&gt;type == USB_ENDPOINT_XFER_INT))
 		return;
 
-	/* Find the first active TD; that's the device's toggle state */
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		if (td_status(td) &amp; TD_CTRL_ACTIVE) {
-			qh-&gt;needs_fixup = 1;
-			qh-&gt;initial_toggle = uhci_toggle(td_token(td));
-			return;
-		}
-	}
-
-	WARN_ON(1);
+	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
+	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
+	qh-&gt;needs_fixup = 1;
+	qh-&gt;initial_toggle = uhci_toggle(td_token(td));
 }
 
 /*
@@ -372,6 +366,12 @@ static void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	list_move(&amp;qh-&gt;node, &amp;uhci-&gt;idle_qh_list);
 	qh-&gt;state = QH_STATE_IDLE;
 
+	/* Now that the QH is idle, its post_td isn't being used */
+	if (qh-&gt;post_td) {
+		uhci_free_td(uhci, qh-&gt;post_td);
+		qh-&gt;post_td = NULL;
+	}
+
 	/* If anyone is waiting for a QH to become idle, wake them up */
 	if (uhci-&gt;num_waiting)
 		wake_up_all(&amp;uhci-&gt;waitqh);
@@ -610,6 +610,8 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 		qh-&gt;skel = uhci-&gt;skel_fs_control_qh;
 		uhci_inc_fsbr(uhci, urb);
 	}
+
+	urb-&gt;actual_length = -8;	/* Account for the SETUP packet */
 	return 0;
 
 nomem:
@@ -767,34 +769,46 @@ static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
  * Fix up the data structures following a short transfer
  */
 static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
-		struct uhci_qh *qh, struct urb_priv *urbp,
-		struct uhci_td *short_td)
+		struct uhci_qh *qh, struct urb_priv *urbp)
 {
 	struct uhci_td *td;
-	int ret = 0;
+	struct list_head *tmp;
+	int ret;
 
 	td = list_entry(urbp-&gt;td_list.prev, struct uhci_td, list);
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
-		urbp-&gt;short_transfer = 1;
 
 		/* When a control transfer is short, we have to restart
 		 * the queue at the status stage transaction, which is
 		 * the last TD. */
+		WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		tmp = td-&gt;list.prev;
 		ret = -EINPROGRESS;
 
-	} else if (!urbp-&gt;short_transfer) {
-		urbp-&gt;short_transfer = 1;
+	} else {
 
 		/* When a bulk/interrupt transfer is short, we have to
 		 * fix up the toggles of the following URBs on the queue
 		 * before restarting the queue at the next URB. */
-		qh-&gt;initial_toggle = uhci_toggle(td_token(short_td)) ^ 1;
+		qh-&gt;initial_toggle = uhci_toggle(td_token(qh-&gt;post_td)) ^ 1;
 		uhci_fixup_toggles(qh, 1);
 
+		if (list_empty(&amp;urbp-&gt;td_list))
+			td = qh-&gt;post_td;
 		qh-&gt;element = td-&gt;link;
+		tmp = urbp-&gt;td_list.prev;
+		ret = 0;
 	}
 
+	/* Remove all the TDs we skipped over, from tmp back to the start */
+	while (tmp != &amp;urbp-&gt;td_list) {
+		td = list_entry(tmp, struct uhci_td, list);
+		tmp = tmp-&gt;prev;
+
+		uhci_remove_td_from_urb(td);
+		list_add(&amp;td-&gt;remove_list, &amp;uhci-&gt;td_remove_list);
+	}
 	return ret;
 }
 
@@ -805,29 +819,14 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 {
 	struct urb_priv *urbp = urb-&gt;hcpriv;
 	struct uhci_qh *qh = urbp-&gt;qh;
-	struct uhci_td *td;
-	struct list_head *tmp;
+	struct uhci_td *td, *tmp;
 	unsigned status;
 	int ret = 0;
 
-	tmp = urbp-&gt;td_list.next;
-
-	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
-		if (urbp-&gt;short_transfer)
-			tmp = urbp-&gt;td_list.prev;
-		else
-			urb-&gt;actual_length = -8;	/* SETUP packet */
-	} else
-		urb-&gt;actual_length = 0;
-
-
-	while (tmp != &amp;urbp-&gt;td_list) {
+	list_for_each_entry_safe(td, tmp, &amp;urbp-&gt;td_list, list) {
 		unsigned int ctrlstat;
 		int len;
 
-		td = list_entry(tmp, struct uhci_td, list);
-		tmp = tmp-&gt;next;
-
 		ctrlstat = td_status(td);
 		status = uhci_status_bits(ctrlstat);
 		if (status &amp; TD_CTRL_ACTIVE)
@@ -862,6 +861,12 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				ret = 1;
 		}
 
+		uhci_remove_td_from_urb(td);
+		if (qh-&gt;post_td)
+			list_add(&amp;qh-&gt;post_td-&gt;remove_list,
+					&amp;uhci-&gt;td_remove_list);
+		qh-&gt;post_td = td;
+
 		if (ret != 0)
 			goto err;
 	}
@@ -882,7 +887,7 @@ static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
 				(ret == -EREMOTEIO);
 
 	} else		/* Short packet received */
-		ret = uhci_fixup_short_transfer(uhci, qh, urbp, td);
+		ret = uhci_fixup_short_transfer(uhci, qh, urbp);
 	return ret;
 }
 
@@ -1123,6 +1128,7 @@ __acquires(uhci-&gt;lock)
 		struct uhci_td *ptd, *ltd;
 
 		purbp = list_entry(urbp-&gt;node.prev, struct urb_priv, node);
+		WARN_ON(list_empty(&amp;purbp-&gt;td_list));
 		ptd = list_entry(purbp-&gt;td_list.prev, struct uhci_td,
 				list);
 		ltd = list_entry(urbp-&gt;td_list.prev, struct uhci_td,</pre><hr><pre>commit b1869000a60b0c72022811f24110a52d3e300b1e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri May 12 11:14:25 2006 -0400

    [PATCH] UHCI: Common result routine for Control/Bulk/Interrupt
    
    This patch (as679) combines the result routine for Control URBs with the
    routine for Bulk/Interrupt URBs.  Along the way I eliminated the
    debugging printouts for Control transfers unless the debugging level is
    set higher than 1.  I also eliminated a long-unused (#ifdef'ed-out)
    section that works around some buggy old APC BackUPS devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index 693e92c1bd9e..30e36031fe21 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -618,134 +618,6 @@ static int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,
 	return -ENOMEM;
 }
 
-/*
- * If control-IN transfer was short, the status packet wasn't sent.
- * This routine changes the element pointer in the QH to point at the
- * status TD.  It's safe to do this even while the QH is live, because
- * the hardware only updates the element pointer following a successful
- * transfer.  The inactive TD for the short packet won't cause an update,
- * so the pointer won't get overwritten.  The next time the controller
- * sees this QH, it will send the status packet.
- */
-static int usb_control_retrigger_status(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = (struct urb_priv *)urb-&gt;hcpriv;
-	struct uhci_td *td;
-
-	urbp-&gt;short_transfer = 1;
-
-	td = list_entry(urbp-&gt;td_list.prev, struct uhci_td, list);
-	urbp-&gt;qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
-
-	return -EINPROGRESS;
-}
-
-
-static int uhci_result_control(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct list_head *tmp, *head;
-	struct urb_priv *urbp = urb-&gt;hcpriv;
-	struct uhci_td *td;
-	unsigned int status;
-	int ret = 0;
-
-	head = &amp;urbp-&gt;td_list;
-	if (urbp-&gt;short_transfer) {
-		tmp = head-&gt;prev;
-		goto status_stage;
-	}
-
-	urb-&gt;actual_length = 0;
-
-	tmp = head-&gt;next;
-	td = list_entry(tmp, struct uhci_td, list);
-
-	/* The first TD is the SETUP stage, check the status, but skip */
-	/*  the count */
-	status = uhci_status_bits(td_status(td));
-	if (status &amp; TD_CTRL_ACTIVE)
-		return -EINPROGRESS;
-
-	if (status)
-		goto td_error;
-
-	/* The rest of the TDs (but the last) are data */
-	tmp = tmp-&gt;next;
-	while (tmp != head &amp;&amp; tmp-&gt;next != head) {
-		unsigned int ctrlstat;
-
-		td = list_entry(tmp, struct uhci_td, list);
-		tmp = tmp-&gt;next;
-
-		ctrlstat = td_status(td);
-		status = uhci_status_bits(ctrlstat);
-		if (status &amp; TD_CTRL_ACTIVE)
-			return -EINPROGRESS;
-
-		urb-&gt;actual_length += uhci_actual_length(ctrlstat);
-
-		if (status)
-			goto td_error;
-
-		/* Check to see if we received a short packet */
-		if (uhci_actual_length(ctrlstat) &lt;
-				uhci_expected_length(td_token(td))) {
-			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) {
-				ret = -EREMOTEIO;
-				goto err;
-			}
-
-			return usb_control_retrigger_status(uhci, urb);
-		}
-	}
-
-status_stage:
-	td = list_entry(tmp, struct uhci_td, list);
-
-	/* Control status stage */
-	status = td_status(td);
-
-#ifdef I_HAVE_BUGGY_APC_BACKUPS
-	/* APC BackUPS Pro kludge */
-	/* It tries to send all of the descriptor instead of the amount */
-	/*  we requested */
-	if (status &amp; TD_CTRL_IOC &amp;&amp;	/* IOC is masked out by uhci_status_bits */
-	    status &amp; TD_CTRL_ACTIVE &amp;&amp;
-	    status &amp; TD_CTRL_NAK)
-		return 0;
-#endif
-
-	status = uhci_status_bits(status);
-	if (status &amp; TD_CTRL_ACTIVE)
-		return -EINPROGRESS;
-
-	if (status)
-		goto td_error;
-
-	return 0;
-
-td_error:
-	ret = uhci_map_status(status, uhci_packetout(td_token(td)));
-
-err:
-	if ((debug == 1 &amp;&amp; ret != -EPIPE) || debug &gt; 1) {
-		/* Some debugging code */
-		dev_dbg(uhci_dev(uhci), "%s: failed with status %x\n",
-				__FUNCTION__, status);
-
-		if (errbuf) {
-			/* Print the chain for debugging purposes */
-			uhci_show_qh(urbp-&gt;qh, errbuf, ERRBUF_LEN, 0);
-			lprintk(errbuf);
-		}
-	}
-
-	/* Note that the queue has stopped */
-	urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
-	urbp-&gt;qh-&gt;is_stopped = 1;
-	return ret;
-}
-
 /*
  * Common submit for bulk and interrupt
  */
@@ -864,86 +736,6 @@ static int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,
 	return -ENOMEM;
 }
 
-/*
- * Common result for bulk and interrupt
- */
-static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
-{
-	struct urb_priv *urbp = urb-&gt;hcpriv;
-	struct uhci_td *td;
-	unsigned int status = 0;
-	int ret = 0;
-
-	urb-&gt;actual_length = 0;
-
-	list_for_each_entry(td, &amp;urbp-&gt;td_list, list) {
-		unsigned int ctrlstat = td_status(td);
-
-		status = uhci_status_bits(ctrlstat);
-		if (status &amp; TD_CTRL_ACTIVE)
-			return -EINPROGRESS;
-
-		urb-&gt;actual_length += uhci_actual_length(ctrlstat);
-
-		if (status)
-			goto td_error;
-
-		if (uhci_actual_length(ctrlstat) &lt;
-				uhci_expected_length(td_token(td))) {
-			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK) {
-				ret = -EREMOTEIO;
-				goto err;
-			}
-
-			/*
-			 * This URB stopped short of its end.  We have to
-			 * fix up the toggles of the following URBs on the
-			 * queue and restart the queue.
-			 *
-			 * Do this only the first time we encounter the
-			 * short URB.
-			 */
-			if (!urbp-&gt;short_transfer) {
-				urbp-&gt;short_transfer = 1;
-				urbp-&gt;qh-&gt;initial_toggle =
-						uhci_toggle(td_token(td)) ^ 1;
-				uhci_fixup_toggles(urbp-&gt;qh, 1);
-
-				td = list_entry(urbp-&gt;td_list.prev,
-						struct uhci_td, list);
-				urbp-&gt;qh-&gt;element = td-&gt;link;
-			}
-			break;
-		}
-	}
-
-	return 0;
-
-td_error:
-	ret = uhci_map_status(status, uhci_packetout(td_token(td)));
-
-	if ((debug == 1 &amp;&amp; ret != -EPIPE) || debug &gt; 1) {
-		/* Some debugging code */
-		dev_dbg(uhci_dev(uhci), "%s: failed with status %x\n",
-				__FUNCTION__, status);
-
-		if (debug &gt; 1 &amp;&amp; errbuf) {
-			/* Print the chain for debugging purposes */
-			uhci_show_qh(urbp-&gt;qh, errbuf, ERRBUF_LEN, 0);
-			lprintk(errbuf);
-		}
-	}
-err:
-
-	/* Note that the queue has stopped and save the next toggle value */
-	urbp-&gt;qh-&gt;element = UHCI_PTR_TERM;
-	urbp-&gt;qh-&gt;is_stopped = 1;
-	urbp-&gt;qh-&gt;needs_fixup = 1;
-	urbp-&gt;qh-&gt;initial_toggle = uhci_toggle(td_token(td)) ^
-			(ret == -EREMOTEIO);
-	return ret;
-}
-
 static inline int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,
 		struct uhci_qh *qh)
 {
@@ -971,6 +763,129 @@ static inline int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,
 	return uhci_submit_common(uhci, urb, qh);
 }
 
+/*
+ * Fix up the data structures following a short transfer
+ */
+static int uhci_fixup_short_transfer(struct uhci_hcd *uhci,
+		struct uhci_qh *qh, struct urb_priv *urbp,
+		struct uhci_td *short_td)
+{
+	struct uhci_td *td;
+	int ret = 0;
+
+	td = list_entry(urbp-&gt;td_list.prev, struct uhci_td, list);
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+		urbp-&gt;short_transfer = 1;
+
+		/* When a control transfer is short, we have to restart
+		 * the queue at the status stage transaction, which is
+		 * the last TD. */
+		qh-&gt;element = cpu_to_le32(td-&gt;dma_handle);
+		ret = -EINPROGRESS;
+
+	} else if (!urbp-&gt;short_transfer) {
+		urbp-&gt;short_transfer = 1;
+
+		/* When a bulk/interrupt transfer is short, we have to
+		 * fix up the toggles of the following URBs on the queue
+		 * before restarting the queue at the next URB. */
+		qh-&gt;initial_toggle = uhci_toggle(td_token(short_td)) ^ 1;
+		uhci_fixup_toggles(qh, 1);
+
+		qh-&gt;element = td-&gt;link;
+	}
+
+	return ret;
+}
+
+/*
+ * Common result for control, bulk, and interrupt
+ */
+static int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)
+{
+	struct urb_priv *urbp = urb-&gt;hcpriv;
+	struct uhci_qh *qh = urbp-&gt;qh;
+	struct uhci_td *td;
+	struct list_head *tmp;
+	unsigned status;
+	int ret = 0;
+
+	tmp = urbp-&gt;td_list.next;
+
+	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL) {
+		if (urbp-&gt;short_transfer)
+			tmp = urbp-&gt;td_list.prev;
+		else
+			urb-&gt;actual_length = -8;	/* SETUP packet */
+	} else
+		urb-&gt;actual_length = 0;
+
+
+	while (tmp != &amp;urbp-&gt;td_list) {
+		unsigned int ctrlstat;
+		int len;
+
+		td = list_entry(tmp, struct uhci_td, list);
+		tmp = tmp-&gt;next;
+
+		ctrlstat = td_status(td);
+		status = uhci_status_bits(ctrlstat);
+		if (status &amp; TD_CTRL_ACTIVE)
+			return -EINPROGRESS;
+
+		len = uhci_actual_length(ctrlstat);
+		urb-&gt;actual_length += len;
+
+		if (status) {
+			ret = uhci_map_status(status,
+					uhci_packetout(td_token(td)));
+			if ((debug == 1 &amp;&amp; ret != -EPIPE) || debug &gt; 1) {
+				/* Some debugging code */
+				dev_dbg(uhci_dev(uhci),
+						"%s: failed with status %x\n",
+						__FUNCTION__, status);
+
+				if (debug &gt; 1 &amp;&amp; errbuf) {
+					/* Print the chain for debugging */
+					uhci_show_qh(urbp-&gt;qh, errbuf,
+							ERRBUF_LEN, 0);
+					lprintk(errbuf);
+				}
+			}
+
+		} else if (len &lt; uhci_expected_length(td_token(td))) {
+
+			/* We received a short packet */
+			if (urb-&gt;transfer_flags &amp; URB_SHORT_NOT_OK)
+				ret = -EREMOTEIO;
+			else if (ctrlstat &amp; TD_CTRL_SPD)
+				ret = 1;
+		}
+
+		if (ret != 0)
+			goto err;
+	}
+	return ret;
+
+err:
+	if (ret &lt; 0) {
+		/* In case a control transfer gets an error
+		 * during the setup stage */
+		urb-&gt;actual_length = max(urb-&gt;actual_length, 0);
+
+		/* Note that the queue has stopped and save
+		 * the next toggle value */
+		qh-&gt;element = UHCI_PTR_TERM;
+		qh-&gt;is_stopped = 1;
+		qh-&gt;needs_fixup = (qh-&gt;type != USB_ENDPOINT_XFER_CONTROL);
+		qh-&gt;initial_toggle = uhci_toggle(td_token(td)) ^
+				(ret == -EREMOTEIO);
+
+	} else		/* Short packet received */
+		ret = uhci_fixup_short_transfer(uhci, qh, urbp, td);
+	return ret;
+}
+
 /*
  * Isochronous transfers
  */
@@ -1276,17 +1191,10 @@ static void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		urbp = list_entry(qh-&gt;queue.next, struct urb_priv, node);
 		urb = urbp-&gt;urb;
 
-		switch (qh-&gt;type) {
-		case USB_ENDPOINT_XFER_CONTROL:
-			status = uhci_result_control(uhci, urb);
-			break;
-		case USB_ENDPOINT_XFER_ISOC:
+		if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
 			status = uhci_result_isochronous(uhci, urb);
-			break;
-		default:	/* USB_ENDPOINT_XFER_BULK or _INT */
+		else
 			status = uhci_result_common(uhci, urb);
-			break;
-		}
 		if (status == -EINPROGRESS)
 			break;
 </pre><hr><pre>commit 0f28b55db543001d360e4319bfc3f2c4e28ba05f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon May 15 14:49:04 2006 -0400

    [PATCH] usbhid: automatically set HID_QUIRK_NOGET for keyboards and mice
    
    It seems to be relatively common for USB keyboards and mice to dislike
    being polled for reports.  Since there's no need to poll a keyboard or
    a mouse, this patch (as685) automatically sets the HID_QUIRK_NOGET flag
    for devices that advertise themselves as either sort of device with boot
    protocol support.
    
    This won't cure all the problems since some devices don't support the
    boot protocol, but it's simple and easy and it should fix quite a few
    problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/input/hid-core.c b/drivers/usb/input/hid-core.c
index bb1f5211ff9d..061002fc66fc 100644
--- a/drivers/usb/input/hid-core.c
+++ b/drivers/usb/input/hid-core.c
@@ -1797,6 +1797,14 @@ static struct hid_device *usb_hid_configure(struct usb_interface *intf)
 			(hid_blacklist[n].idProduct == le16_to_cpu(dev-&gt;descriptor.idProduct)))
 				quirks = hid_blacklist[n].quirks;
 
+	/* Many keyboards and mice don't like to be polled for reports,
+	 * so we will always set the HID_QUIRK_NOGET flag for them. */
+	if (interface-&gt;desc.bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT) {
+		if (interface-&gt;desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD ||
+			interface-&gt;desc.bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE)
+				quirks |= HID_QUIRK_NOGET;
+	}
+
 	if (quirks &amp; HID_QUIRK_IGNORE)
 		return NULL;
 
diff --git a/drivers/usb/input/hid.h b/drivers/usb/input/hid.h
index 7efbfff8adde..778e575de352 100644
--- a/drivers/usb/input/hid.h
+++ b/drivers/usb/input/hid.h
@@ -40,6 +40,14 @@
 
 #define USB_INTERFACE_CLASS_HID		3
 
+/*
+ * USB HID interface subclass and protocol codes
+ */
+
+#define USB_INTERFACE_SUBCLASS_BOOT	1
+#define USB_INTERFACE_PROTOCOL_KEYBOARD	1
+#define USB_INTERFACE_PROTOCOL_MOUSE	2
+
 /*
  * HID class requests
  */</pre>
    <div class="pagination">
        <a href='2_125.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><span>[126]</span><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_127.html'>Next&gt;&gt;</a>
    <div>
</body>
