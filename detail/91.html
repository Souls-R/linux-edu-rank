<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Michigan Technological University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Michigan Technological University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit f0623340fd2cab724e3c54ac026d1414325f375d
Author: Peter Lafreniere &lt;pjlafren@mtu.edu&gt;
Date:   Thu Jun 16 11:23:33 2022 -0400

    ax25: use GFP_KERNEL in ax25_dev_device_up()
    
    ax25_dev_device_up() is only called during device setup, which is
    done in user context. In addition, ax25_dev_device_up()
    unconditionally calls ax25_register_dev_sysctl(), which already
    allocates with GFP_KERNEL.
    
    Since it is allowed to sleep in this function, here we change
    ax25_dev_device_up() to use GFP_KERNEL to reduce unnecessary
    out-of-memory errors.
    
    Reported-by: Dan Carpenter &lt;dan.carpenter@oracle.com&gt;
    Signed-off-by: Peter Lafreniere &lt;pjlafren@mtu.edu&gt;
    Link: https://lore.kernel.org/r/20220616152333.9812-1-pjlafren@mtu.edu
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index ab88b6ac5401..c5462486dbca 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -52,7 +52,8 @@ void ax25_dev_device_up(struct net_device *dev)
 {
 	ax25_dev *ax25_dev;
 
-	if ((ax25_dev = kzalloc(sizeof(*ax25_dev), GFP_ATOMIC)) == NULL) {
+	ax25_dev = kzalloc(sizeof(*ax25_dev), GFP_KERNEL);
+	if (!ax25_dev) {
 		printk(KERN_ERR "AX.25: ax25_dev_device_up - out of memory\n");
 		return;
 	}
@@ -60,7 +61,7 @@ void ax25_dev_device_up(struct net_device *dev)
 	refcount_set(&amp;ax25_dev-&gt;refcount, 1);
 	dev-&gt;ax25_ptr     = ax25_dev;
 	ax25_dev-&gt;dev     = dev;
-	netdev_hold(dev, &amp;ax25_dev-&gt;dev_tracker, GFP_ATOMIC);
+	netdev_hold(dev, &amp;ax25_dev-&gt;dev_tracker, GFP_KERNEL);
 	ax25_dev-&gt;forward = NULL;
 	ax25_dev-&gt;device_up = true;
 </pre><hr><pre>commit a84a434baf9427a1c49782fb1f0973d1308016df
Author: Peter Lafreniere &lt;pjlafren@mtu.edu&gt;
Date:   Mon Jun 6 07:34:58 2022 -0400

    net: constify some inline functions in sock.h
    
    Despite these inline functions having full visibility to the compiler
    at compile time, they still strip const from passed pointers.
    This change allows for functions in various network drivers to be marked as
    const that could not be marked const before.
    
    Signed-off-by: Peter Lafreniere &lt;pjlafren@mtu.edu&gt;
    Link: https://lore.kernel.org/r/20220606113458.35953-1-pjlafren@mtu.edu
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/include/net/sock.h b/include/net/sock.h
index c585ef6565d9..657873e2d90f 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -611,7 +611,7 @@ void sock_net_set(struct sock *sk, struct net *net)
 
 int sk_set_peek_off(struct sock *sk, int val);
 
-static inline int sk_peek_offset(struct sock *sk, int flags)
+static inline int sk_peek_offset(const struct sock *sk, int flags)
 {
 	if (unlikely(flags &amp; MSG_PEEK)) {
 		return READ_ONCE(sk-&gt;sk_peek_off);
@@ -863,7 +863,7 @@ static inline void sk_add_bind2_node(struct sock *sk, struct hlist_head *list)
 		({ tpos = (typeof(*tpos) *)((void *)pos - offset); 1;});       \
 	     pos = rcu_dereference(hlist_next_rcu(pos)))
 
-static inline struct user_namespace *sk_user_ns(struct sock *sk)
+static inline struct user_namespace *sk_user_ns(const struct sock *sk)
 {
 	/* Careful only use this in a context where these parameters
 	 * can not change and must all be valid, such as recvmsg from
@@ -909,7 +909,7 @@ enum sock_flags {
 
 #define SK_FLAGS_TIMESTAMP ((1UL &lt;&lt; SOCK_TIMESTAMP) | (1UL &lt;&lt; SOCK_TIMESTAMPING_RX_SOFTWARE))
 
-static inline void sock_copy_flags(struct sock *nsk, struct sock *osk)
+static inline void sock_copy_flags(struct sock *nsk, const struct sock *osk)
 {
 	nsk-&gt;sk_flags = osk-&gt;sk_flags;
 }</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
