<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_73.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><span>[74]</span><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_75.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 01c6460f968d7b57fc6f98adb587952628c6e099
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 1 11:09:56 2009 -0400

    USB: usbfs: add USBDEVFS_URB_BULK_CONTINUATION flag
    
    This patch (as1283) adds a new flag, USBDEVFS_URB_BULK_CONTINUATION,
    to usbfs.  It is intended for userspace libraries such as libusb and
    openusb.  When they have to break up a single usbfs bulk transfer into
    multiple URBs, they will set the flag on all but the first URB of the
    series.
    
    If an error other than an unlink occurs, the kernel will automatically
    cancel all the following URBs for the same endpoint and refuse to
    accept new submissions, until an URB is encountered that is not marked
    as a BULK_CONTINUATION.  Such an URB would indicate the start of a new
    transfer or the presence of an older library, so the kernel returns to
    normal operation.
    
    This enables libraries to delimit bulk transfers correctly, even in
    the presence of early termination as indicated by short packets.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 71514be8b715..181f78c84105 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -74,6 +74,7 @@ struct dev_state {
 	void __user *disccontext;
 	unsigned long ifclaimed;
 	u32 secid;
+	u32 disabled_bulk_eps;
 };
 
 struct async {
@@ -88,6 +89,8 @@ struct async {
 	struct urb *urb;
 	int status;
 	u32 secid;
+	u8 bulk_addr;
+	u8 bulk_status;
 };
 
 static int usbfs_snoop;
@@ -343,6 +346,43 @@ static void snoop_urb(struct usb_device *udev,
 	}
 }
 
+#define AS_CONTINUATION	1
+#define AS_UNLINK	2
+
+static void cancel_bulk_urbs(struct dev_state *ps, unsigned bulk_addr)
+__releases(ps-&gt;lock)
+__acquires(ps-&gt;lock)
+{
+	struct async *as;
+
+	/* Mark all the pending URBs that match bulk_addr, up to but not
+	 * including the first one without AS_CONTINUATION.  If such an
+	 * URB is encountered then a new transfer has already started so
+	 * the endpoint doesn't need to be disabled; otherwise it does.
+	 */
+	list_for_each_entry(as, &amp;ps-&gt;async_pending, asynclist) {
+		if (as-&gt;bulk_addr == bulk_addr) {
+			if (as-&gt;bulk_status != AS_CONTINUATION)
+				goto rescan;
+			as-&gt;bulk_status = AS_UNLINK;
+			as-&gt;bulk_addr = 0;
+		}
+	}
+	ps-&gt;disabled_bulk_eps |= (1 &lt;&lt; bulk_addr);
+
+	/* Now carefully unlink all the marked pending URBs */
+ rescan:
+	list_for_each_entry(as, &amp;ps-&gt;async_pending, asynclist) {
+		if (as-&gt;bulk_status == AS_UNLINK) {
+			as-&gt;bulk_status = 0;		/* Only once */
+			spin_unlock(&amp;ps-&gt;lock);		/* Allow completions */
+			usb_unlink_urb(as-&gt;urb);
+			spin_lock(&amp;ps-&gt;lock);
+			goto rescan;
+		}
+	}
+}
+
 static void async_completed(struct urb *urb)
 {
 	struct async *as = urb-&gt;context;
@@ -371,6 +411,9 @@ static void async_completed(struct urb *urb)
 	snoop(&amp;urb-&gt;dev-&gt;dev, "urb complete\n");
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE);
+	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
+			as-&gt;status != -ENOENT)
+		cancel_bulk_urbs(ps, as-&gt;bulk_addr);
 	spin_unlock(&amp;ps-&gt;lock);
 
 	if (signr)
@@ -993,6 +1036,7 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 
 	if (uurb-&gt;flags &amp; ~(USBDEVFS_URB_ISO_ASAP |
 				USBDEVFS_URB_SHORT_NOT_OK |
+				USBDEVFS_URB_BULK_CONTINUATION |
 				USBDEVFS_URB_NO_FSBR |
 				USBDEVFS_URB_ZERO_PACKET |
 				USBDEVFS_URB_NO_INTERRUPT))
@@ -1194,7 +1238,39 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 	snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
 			as-&gt;urb-&gt;transfer_buffer_length, 0, SUBMIT);
 	async_newpending(as);
-	if ((ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL))) {
+
+	if (usb_endpoint_xfer_bulk(&amp;ep-&gt;desc)) {
+		spin_lock_irq(&amp;ps-&gt;lock);
+
+		/* Not exactly the endpoint address; the direction bit is
+		 * shifted to the 0x10 position so that the value will be
+		 * between 0 and 31.
+		 */
+		as-&gt;bulk_addr = usb_endpoint_num(&amp;ep-&gt;desc) |
+			((ep-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_DIR_MASK)
+				&gt;&gt; 3);
+
+		/* If this bulk URB is the start of a new transfer, re-enable
+		 * the endpoint.  Otherwise mark it as a continuation URB.
+		 */
+		if (uurb-&gt;flags &amp; USBDEVFS_URB_BULK_CONTINUATION)
+			as-&gt;bulk_status = AS_CONTINUATION;
+		else
+			ps-&gt;disabled_bulk_eps &amp;= ~(1 &lt;&lt; as-&gt;bulk_addr);
+
+		/* Don't accept continuation URBs if the endpoint is
+		 * disabled because of an earlier error.
+		 */
+		if (ps-&gt;disabled_bulk_eps &amp; (1 &lt;&lt; as-&gt;bulk_addr))
+			ret = -EREMOTEIO;
+		else
+			ret = usb_submit_urb(as-&gt;urb, GFP_ATOMIC);
+		spin_unlock_irq(&amp;ps-&gt;lock);
+	} else {
+		ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL);
+	}
+
+	if (ret) {
 		dev_printk(KERN_DEBUG, &amp;ps-&gt;dev-&gt;dev,
 			   "usbfs: usb_submit_urb returned %d\n", ret);
 		snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 00ceebeb9e5c..b2a7d8ba6ee3 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -77,6 +77,7 @@ struct usbdevfs_connectinfo {
 
 #define USBDEVFS_URB_SHORT_NOT_OK	0x01
 #define USBDEVFS_URB_ISO_ASAP		0x02
+#define USBDEVFS_URB_BULK_CONTINUATION	0x04
 #define USBDEVFS_URB_NO_FSBR		0x20
 #define USBDEVFS_URB_ZERO_PACKET	0x40
 #define USBDEVFS_URB_NO_INTERRUPT	0x80</pre><hr><pre>commit a448c9d8c58ff7d3f8cc2a8f835065460099b22d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 19 12:22:44 2009 -0400

    USB: EHCI: change deschedule logic for interrupt QHs
    
    This patch (as1281) changes the way ehci-hcd deschedules interrupt
    QHs, copying the approach used for async QHs.  The caller is no longer
    responsible for rescheduling the QH if its queue is non-empty; instead
    the reschedule is done directly by intr_deschedule(), after calling
    qh_completions().  This is exactly the same as how end_unlink_async()
    works.
    
    ehci_urb_dequeue() and intr_deschedule() now correctly handle the case
    where they are called while another interrupt URB for the same QH is
    being given back.  This was a surprisingly large blind spot.  And
    scan_periodic() now respects the new needs_rescan flag.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index d7e85b6231b3..4f89d7ffd53a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -934,8 +934,9 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			break;
 		switch (qh-&gt;qh_state) {
 		case QH_STATE_LINKED:
+		case QH_STATE_COMPLETING:
 			intr_deschedule (ehci, qh);
-			/* FALL THROUGH */
+			break;
 		case QH_STATE_IDLE:
 			qh_completions (ehci, qh);
 			break;
@@ -944,23 +945,6 @@ static int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 					qh, qh-&gt;qh_state);
 			goto done;
 		}
-
-		/* reschedule QH iff another request is queued */
-		if (!list_empty (&amp;qh-&gt;qtd_list)
-				&amp;&amp; HC_IS_RUNNING (hcd-&gt;state)) {
-			rc = qh_schedule(ehci, qh);
-
-			/* An error here likely indicates handshake failure
-			 * or no space left in the schedule.  Neither fault
-			 * should happen often ...
-			 *
-			 * FIXME kill the now-dysfunctional queued urbs
-			 */
-			if (rc != 0)
-				ehci_err(ehci,
-					"can't reschedule qh %p, err %d",
-					qh, rc);
-		}
 		break;
 
 	case PIPE_ISOCHRONOUS:
@@ -1079,12 +1063,10 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 			 * while the QH is active.  Unlink it now;
 			 * re-linking will call qh_refresh().
 			 */
-			if (eptype == USB_ENDPOINT_XFER_BULK) {
+			if (eptype == USB_ENDPOINT_XFER_BULK)
 				unlink_async(ehci, qh);
-			} else {
+			else
 				intr_deschedule(ehci, qh);
-				(void) qh_schedule(ehci, qh);
-			}
 		}
 	}
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 57a84795c43f..00ad9ce392ed 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -299,7 +299,6 @@ __acquires(ehci-&gt;lock)
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
-static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*
@@ -555,14 +554,9 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 * That should be rare for interrupt transfers,
 			 * except maybe high bandwidth ...
 			 */
-			if ((cpu_to_hc32(ehci, QH_SMASK)
-					&amp; hw-&gt;hw_info2) != 0) {
-				intr_deschedule (ehci, qh);
-				(void) qh_schedule (ehci, qh);
-			} else {
-				/* Tell the caller to start an unlink */
-				qh-&gt;needs_rescan = 1;
-			}
+
+			/* Tell the caller to start an unlink */
+			qh-&gt;needs_rescan = 1;
 			break;
 		/* otherwise, unlink already started */
 		}
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 327437af2122..3ea05936851f 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -615,8 +615,19 @@ static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	unsigned	wait;
-	struct ehci_qh_hw *hw = qh-&gt;hw;
+	unsigned		wait;
+	struct ehci_qh_hw	*hw = qh-&gt;hw;
+	int			rc;
+
+	/* If the QH isn't linked then there's nothing we can do
+	 * unless we were called during a giveback, in which case
+	 * qh_completions() has to deal with it.
+	 */
+	if (qh-&gt;qh_state != QH_STATE_LINKED) {
+		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
+			qh-&gt;needs_rescan = 1;
+		return;
+	}
 
 	qh_unlink_periodic (ehci, qh);
 
@@ -636,6 +647,24 @@ static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	qh-&gt;qh_state = QH_STATE_IDLE;
 	hw-&gt;hw_next = EHCI_LIST_END(ehci);
 	wmb ();
+
+	qh_completions(ehci, qh);
+
+	/* reschedule QH iff another request is queued */
+	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+			HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state)) {
+		rc = qh_schedule(ehci, qh);
+
+		/* An error here likely indicates handshake failure
+		 * or no space left in the schedule.  Neither fault
+		 * should happen often ...
+		 *
+		 * FIXME kill the now-dysfunctional queued urbs
+		 */
+		if (rc != 0)
+			ehci_err(ehci, "can't reschedule qh %p, err %d\n",
+					qh, rc);
+	}
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2213,7 +2242,8 @@ scan_periodic (struct ehci_hcd *ehci)
 				type = Q_NEXT_TYPE(ehci, q.qh-&gt;hw-&gt;hw_next);
 				q = q.qh-&gt;qh_next;
 				modified = qh_completions (ehci, temp.qh);
-				if (unlikely (list_empty (&amp;temp.qh-&gt;qtd_list)))
+				if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
+						temp.qh-&gt;needs_rescan))
 					intr_deschedule (ehci, temp.qh);
 				qh_put (temp.qh);
 				break;</pre><hr><pre>commit 3a44494e233c0fdd818d485cfea8998500543589
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 19 12:22:06 2009 -0400

    USB: EHCI: rescan the queue after an unlink
    
    This patch (as1280) fixes an obscure bug in ehci-hcd's dequeuing logic
    for async URBs.  If a later URB is unlinked and the completion
    routine unlinks an earlier URB, then the earlier URB won't be given
    back in a timely manner because the endpoint queue isn't rescanned as
    it should be.
    
    Similar bugs occur if an endpoint is reset or a halt is cleared while
    a completion routine is running, because the subroutines don't test
    for the COMPLETING state.
    
    All these problems are solved by adding a new needs_rescan flag to the
    ehci_qh structure.  If the flag is set while scanning through an idle
    QH, the scan will be repeated.  If the QH isn't idle then an unlink
    cycle will be initiated, and the proper action will be taken when it
    becomes idle.
    
    Also, an unnecessary test is removed from qh_link_async(): That
    routine is never called if the QH's state isn't IDLE.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 6887aac5e73d..d7e85b6231b3 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -863,12 +863,18 @@ static void unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state) &amp;&amp; ehci-&gt;reclaim)
 		end_unlink_async(ehci);
 
-	/* if it's not linked then there's nothing to do */
-	if (qh-&gt;qh_state != QH_STATE_LINKED)
-		;
+	/* If the QH isn't linked then there's nothing we can do
+	 * unless we were called during a giveback, in which case
+	 * qh_completions() has to deal with it.
+	 */
+	if (qh-&gt;qh_state != QH_STATE_LINKED) {
+		if (qh-&gt;qh_state == QH_STATE_COMPLETING)
+			qh-&gt;needs_rescan = 1;
+		return;
+	}
 
 	/* defer till later if busy */
-	else if (ehci-&gt;reclaim) {
+	if (ehci-&gt;reclaim) {
 		struct ehci_qh		*last;
 
 		for (last = ehci-&gt;reclaim;
@@ -1001,6 +1007,7 @@ ehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		qh-&gt;qh_state = QH_STATE_IDLE;
 	switch (qh-&gt;qh_state) {
 	case QH_STATE_LINKED:
+	case QH_STATE_COMPLETING:
 		for (tmp = ehci-&gt;async-&gt;qh_next.qh;
 				tmp &amp;&amp; tmp != qh;
 				tmp = tmp-&gt;qh_next.qh)
@@ -1065,7 +1072,8 @@ ehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)
 		usb_settoggle(qh-&gt;dev, epnum, is_out, 0);
 		if (!list_empty(&amp;qh-&gt;qtd_list)) {
 			WARN_ONCE(1, "clear_halt for a busy endpoint\n");
-		} else if (qh-&gt;qh_state == QH_STATE_LINKED) {
+		} else if (qh-&gt;qh_state == QH_STATE_LINKED ||
+				qh-&gt;qh_state == QH_STATE_COMPLETING) {
 
 			/* The toggle value in the QH can't be updated
 			 * while the QH is active.  Unlink it now;
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 377ed530b920..57a84795c43f 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -310,13 +310,13 @@ static int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);
 static unsigned
 qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
-	struct ehci_qtd		*last = NULL, *end = qh-&gt;dummy;
+	struct ehci_qtd		*last, *end = qh-&gt;dummy;
 	struct list_head	*entry, *tmp;
-	int			last_status = -EINPROGRESS;
+	int			last_status;
 	int			stopped;
 	unsigned		count = 0;
 	u8			state;
-	__le32			halt = HALT_BIT(ehci);
+	const __le32		halt = HALT_BIT(ehci);
 	struct ehci_qh_hw	*hw = qh-&gt;hw;
 
 	if (unlikely (list_empty (&amp;qh-&gt;qtd_list)))
@@ -327,11 +327,20 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 * they add urbs to this qh's queue or mark them for unlinking.
 	 *
 	 * NOTE:  unlinking expects to be done in queue order.
+	 *
+	 * It's a bug for qh-&gt;qh_state to be anything other than
+	 * QH_STATE_IDLE, unless our caller is scan_async() or
+	 * scan_periodic().
 	 */
 	state = qh-&gt;qh_state;
 	qh-&gt;qh_state = QH_STATE_COMPLETING;
 	stopped = (state == QH_STATE_IDLE);
 
+ rescan:
+	last = NULL;
+	last_status = -EINPROGRESS;
+	qh-&gt;needs_rescan = 0;
+
 	/* remove de-activated QTDs from front of queue.
 	 * after faults (including short reads), cleanup this urb
 	 * then let the queue advance.
@@ -507,6 +516,21 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		ehci_qtd_free (ehci, last);
 	}
 
+	/* Do we need to rescan for URBs dequeued during a giveback? */
+	if (unlikely(qh-&gt;needs_rescan)) {
+		/* If the QH is already unlinked, do the rescan now. */
+		if (state == QH_STATE_IDLE)
+			goto rescan;
+
+		/* Otherwise we have to wait until the QH is fully unlinked.
+		 * Our caller will start an unlink if qh-&gt;needs_rescan is
+		 * set.  But if an unlink has already started, nothing needs
+		 * to be done.
+		 */
+		if (state != QH_STATE_LINKED)
+			qh-&gt;needs_rescan = 0;
+	}
+
 	/* restore original state; caller must unlink or relink */
 	qh-&gt;qh_state = state;
 
@@ -535,8 +559,10 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 					&amp; hw-&gt;hw_info2) != 0) {
 				intr_deschedule (ehci, qh);
 				(void) qh_schedule (ehci, qh);
-			} else
-				unlink_async (ehci, qh);
+			} else {
+				/* Tell the caller to start an unlink */
+				qh-&gt;needs_rescan = 1;
+			}
 			break;
 		/* otherwise, unlink already started */
 		}
@@ -916,6 +942,8 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	if (unlikely(qh-&gt;clearing_tt))
 		return;
 
+	WARN_ON(qh-&gt;qh_state != QH_STATE_IDLE);
+
 	/* (re)start the async schedule? */
 	head = ehci-&gt;async;
 	timer_action_done (ehci, TIMER_ASYNC_OFF);
@@ -934,8 +962,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* clear halt and/or toggle; and maybe recover from silicon quirk */
-	if (qh-&gt;qh_state == QH_STATE_IDLE)
-		qh_refresh (ehci, qh);
+	qh_refresh(ehci, qh);
 
 	/* splice right after start */
 	qh-&gt;qh_next = head-&gt;qh_next;
@@ -1220,6 +1247,8 @@ static void scan_async (struct ehci_hcd *ehci)
 				qh = qh_get (qh);
 				qh-&gt;stamp = ehci-&gt;stamp;
 				temp = qh_completions (ehci, qh);
+				if (qh-&gt;needs_rescan)
+					unlink_async(ehci, qh);
 				qh_put (qh);
 				if (temp != 0) {
 					goto rescan;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index ec3dba6b8e48..064e76821ff5 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -341,6 +341,7 @@ struct ehci_qh {
 	u32			refcount;
 	unsigned		stamp;
 
+	u8			needs_rescan;	/* Dequeue during giveback */
 	u8			qh_state;
 #define	QH_STATE_LINKED		1		/* HC sees this */
 #define	QH_STATE_UNLINK		2		/* HC may still see this */</pre><hr><pre>commit 823c3fd9cc71714fe22ea415a68da746800d5a9a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 3 11:05:59 2009 -0400

    USB: s3c2410: unregister should call unbind, not disconnect
    
    This patch (as1275) fixes the s3c2410 device controller driver.  Its
    usb_gadget_unregister_driver() routine is supposed to call the gadget
    driver's unbind method, not the disconnect method.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/s3c2410_udc.c b/drivers/usb/gadget/s3c2410_udc.c
index a9b452fe6221..d5f4c1d45c97 100644
--- a/drivers/usb/gadget/s3c2410_udc.c
+++ b/drivers/usb/gadget/s3c2410_udc.c
@@ -1703,8 +1703,7 @@ int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
 	dprintk(DEBUG_NORMAL,"usb_gadget_register_driver() '%s'\n",
 		driver-&gt;driver.name);
 
-	if (driver-&gt;disconnect)
-		driver-&gt;disconnect(&amp;udc-&gt;gadget);
+	driver-&gt;unbind(&amp;udc-&gt;gadget);
 
 	device_del(&amp;udc-&gt;gadget.dev);
 	udc-&gt;driver = NULL;</pre><hr><pre>commit e9238221d3fef990e2fd01702ebe5af90dda52a2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 22 14:44:17 2009 -0400

    USB: dummy-hcd: accept mismatch between wLength and transfer length
    
    This patch (as1269) fixes a bug in the way dummy_hcd handles control
    URBs.  Currently it returns a -EOVERFLOW error if the wLength value in
    the setup packet is different from the URB's transfer_buffer_length.
    
    Other host controller drivers don't do this.  There's no reason the
    two length values have to be equal, and in fact they sometimes aren't
    -- a driver might set the transfer length to the maxpacket value in
    order to handle buggy devices that don't respect wLength.
    
    This patch simply removes the unnecessary check and error return.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index a56b24d305f8..5e0966485188 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -1306,11 +1306,6 @@ static void dummy_timer (unsigned long _dum)
 			setup = *(struct usb_ctrlrequest*) urb-&gt;setup_packet;
 			w_index = le16_to_cpu(setup.wIndex);
 			w_value = le16_to_cpu(setup.wValue);
-			if (le16_to_cpu(setup.wLength) !=
-					urb-&gt;transfer_buffer_length) {
-				status = -EOVERFLOW;
-				goto return_urb;
-			}
 
 			/* paranoia, in case of stale queued data */
 			list_for_each_entry (req, &amp;ep-&gt;queue, queue) {</pre><hr><pre>commit 527101ce6a96c037a2555aa43222faa6fdd21e97
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 22 14:42:54 2009 -0400

    USB: don't lose mode switch events on suspended devices
    
    This patch (as1268) changes the way usbcore handles child devices that
    undergo a disconnection and reconnection while the parent hub is
    suspended.  Currently, if the child isn't enabled for remote wakeup we
    leave it alone, figuring that it will go through a reset-resume when
    somebody tries to use it.
    
    However this isn't a good approach if the reason for the disconnection
    is that the child decided to switch modes or in some other way alter
    its descriptors.  In that case we want to re-enumerate it as soon as
    possible, not wait until somebody forces a reset-resume.
    
    To resolve the issue, this patch treats reconnected suspended child
    devices as though they had requested a remote wakeup, even if they
    weren't enabled for it.  The mode switch or descriptor change will be
    detected during the reset part of the reset-resume, and the device
    will be re-enumerated immediately.
    
    The disadvantage of this change is that it will cause autosuspended
    devices to be resumed when the computer wakes up from a system sleep
    during which the root hub was reset or lost power.  This shouldn't
    matter much; some people would even argue that autosuspended devices
    should _always_ be resumed when the system wakes up!
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: "Yang Fei-AFY095" &lt;fei.yang@motorola.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 645686a14214..a880516020f3 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2932,14 +2932,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 			/* For a suspended device, treat this as a
 			 * remote wakeup event.
 			 */
-			if (udev-&gt;do_remote_wakeup)
-				status = remote_wakeup(udev);
-
-			/* Otherwise leave it be; devices can't tell the
-			 * difference between suspended and disabled.
-			 */
-			else
-				status = 0;
+			status = remote_wakeup(udev);
 #endif
 
 		} else {</pre><hr><pre>commit 25118084ef03f4fc314ab33ef6a9d9271d0e616a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 22 14:41:18 2009 -0400

    USB: check for hub driver not bound to root hub device
    
    This patch (as1267) changes usb_kick_khubd() and hdev_to_hub() to make
    them more resilient against situations where a hub device isn't bound
    to the hub driver.  The code assumes that if a root hub was
    successfully registered then it must be bound to the hub driver.
    
    But this assumption can fail if the user manually unbinds the hub
    driver, or more importantly, if the host controller dies causing
    usb_set_configuration to fail.
    
    To protect against these possibilities, make hdev_to_hub() check that
    the hub device is configured before dereferencing the active
    configuration, and make usb_kick_khubd() check that the pointer to the
    hub's private data structure isn't NULL.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 69e3a966a4b7..645686a14214 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -163,8 +163,10 @@ static inline char *portspeed(int portstatus)
 }
 
 /* Note that hdev or one of its children must be locked! */
-static inline struct usb_hub *hdev_to_hub(struct usb_device *hdev)
+static struct usb_hub *hdev_to_hub(struct usb_device *hdev)
 {
+	if (!hdev || !hdev-&gt;actconfig)
+		return NULL;
 	return usb_get_intfdata(hdev-&gt;actconfig-&gt;interface[0]);
 }
 
@@ -385,8 +387,10 @@ static void kick_khubd(struct usb_hub *hub)
 
 void usb_kick_khubd(struct usb_device *hdev)
 {
-	/* FIXME: What if hdev isn't bound to the hub driver? */
-	kick_khubd(hdev_to_hub(hdev));
+	struct usb_hub *hub = hdev_to_hub(hdev);
+
+	if (hub)
+		kick_khubd(hub);
 }
 
 </pre><hr><pre>commit 4c6e8971cbe0148085fcf6fd30eaa3c39f8a8cce
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 11:02:04 2009 -0400

    USB: make the "usbfs_snoop" log more pertinent
    
    This patch (as1261) reduces the amount of detailed URB information
    logged by usbfs when the usbfs_snoop parameter is enabled.
    
    Currently we don't display the final status value for a completed URB.
    But we do display the entire data buffer twice: both before submission
    and after completion.  The after-completion display doesn't limit
    itself to the actual_length value.  But since usbmon is readily
    available in virtually all distributions, there's no reason for usbfs
    to print out any buffer contents at all!
    
    So this patch restricts the information to: userspace buffer pointer,
    endpoint number, type, and direction, length or actual_length, and
    timeout value or status.  Now everything fits neatly into a single
    line.
    
    Along with those changes, the patch also fixes the snoop output for
    the REAPURBNDELAY and REAPURBNDELAY32 ioctls.  The current version
    omits the 'N' from the names.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 165de5d59005..a1add776e89a 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -100,11 +100,15 @@ MODULE_PARM_DESC(usbfs_snoop, "true to log all usbfs traffic");
 			dev_info(dev , format , ## arg);	\
 	} while (0)
 
-#define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
+enum snoop_when {
+	SUBMIT, COMPLETE
+};
 
+#define USB_DEVICE_DEV		MKDEV(USB_DEVICE_MAJOR, 0)
 
 #define	MAX_USBFS_BUFFER_SIZE	16384
 
+
 static int connected(struct dev_state *ps)
 {
 	return (!list_empty(&amp;ps-&gt;list) &amp;&amp;
@@ -301,24 +305,42 @@ static struct async *async_getpending(struct dev_state *ps,
 	return NULL;
 }
 
-static void snoop_urb(struct urb *urb, void __user *userurb)
+static void snoop_urb(struct usb_device *udev,
+		void __user *userurb, int pipe, unsigned length,
+		int timeout_or_status, enum snoop_when when)
 {
-	unsigned j;
-	unsigned char *data = urb-&gt;transfer_buffer;
+	static const char *types[] = {"isoc", "int", "ctrl", "bulk"};
+	static const char *dirs[] = {"out", "in"};
+	int ep;
+	const char *t, *d;
 
 	if (!usbfs_snoop)
 		return;
 
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "direction=%s\n",
-			usb_urb_dir_in(urb) ? "IN" : "OUT");
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "userurb=%p\n", userurb);
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "transfer_buffer_length=%u\n",
-		 urb-&gt;transfer_buffer_length);
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "actual_length=%u\n", urb-&gt;actual_length);
-	dev_info(&amp;urb-&gt;dev-&gt;dev, "data: ");
-	for (j = 0; j &lt; urb-&gt;transfer_buffer_length; ++j)
-		printk("%02x ", data[j]);
-	printk("\n");
+	ep = usb_pipeendpoint(pipe);
+	t = types[usb_pipetype(pipe)];
+	d = dirs[!!usb_pipein(pipe)];
+
+	if (userurb) {		/* Async */
+		if (when == SUBMIT)
+			dev_info(&amp;udev-&gt;dev, "userurb %p, ep%d %s-%s, "
+					"length %u\n",
+					userurb, ep, t, d, length);
+		else
+			dev_info(&amp;udev-&gt;dev, "userurb %p, ep%d %s-%s, "
+					"actual_length %u status %d\n",
+					userurb, ep, t, d, length,
+					timeout_or_status);
+	} else {
+		if (when == SUBMIT)
+			dev_info(&amp;udev-&gt;dev, "ep%d %s-%s, length %u, "
+					"timeout %d\n",
+					ep, t, d, length, timeout_or_status);
+		else
+			dev_info(&amp;udev-&gt;dev, "ep%d %s-%s, actual_length %u, "
+					"status %d\n",
+					ep, t, d, length, timeout_or_status);
+	}
 }
 
 static void async_completed(struct urb *urb)
@@ -347,7 +369,8 @@ static void async_completed(struct urb *urb)
 		secid = as-&gt;secid;
 	}
 	snoop(&amp;urb-&gt;dev-&gt;dev, "urb complete\n");
-	snoop_urb(urb, as-&gt;userurb);
+	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
+			as-&gt;status, COMPLETE);
 	spin_unlock(&amp;ps-&gt;lock);
 
 	if (signr)
@@ -690,7 +713,7 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 	unsigned int tmo;
 	unsigned char *tbuf;
 	unsigned wLength;
-	int i, j, ret;
+	int i, pipe, ret;
 
 	if (copy_from_user(&amp;ctrl, arg, sizeof(ctrl)))
 		return -EFAULT;
@@ -710,24 +733,17 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 			free_page((unsigned long)tbuf);
 			return -EINVAL;
 		}
-		snoop(&amp;dev-&gt;dev, "control read: bRequest=%02x "
-				"bRrequestType=%02x wValue=%04x "
-				"wIndex=%04x wLength=%04x\n",
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
-				ctrl.wIndex, ctrl.wLength);
+		pipe = usb_rcvctrlpipe(dev, 0);
+		snoop_urb(dev, NULL, pipe, ctrl.wLength, tmo, SUBMIT);
 
 		usb_unlock_device(dev);
-		i = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), ctrl.bRequest,
+		i = usb_control_msg(dev, pipe, ctrl.bRequest,
 				    ctrl.bRequestType, ctrl.wValue, ctrl.wIndex,
 				    tbuf, ctrl.wLength, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE);
+
 		if ((i &gt; 0) &amp;&amp; ctrl.wLength) {
-			if (usbfs_snoop) {
-				dev_info(&amp;dev-&gt;dev, "control read: data ");
-				for (j = 0; j &lt; i; ++j)
-					printk("%02x ", (u8)(tbuf)[j]);
-				printk("\n");
-			}
 			if (copy_to_user(ctrl.data, tbuf, i)) {
 				free_page((unsigned long)tbuf);
 				return -EFAULT;
@@ -740,22 +756,15 @@ static int proc_control(struct dev_state *ps, void __user *arg)
 				return -EFAULT;
 			}
 		}
-		snoop(&amp;dev-&gt;dev, "control write: bRequest=%02x "
-				"bRrequestType=%02x wValue=%04x "
-				"wIndex=%04x wLength=%04x\n",
-			ctrl.bRequest, ctrl.bRequestType, ctrl.wValue,
-				ctrl.wIndex, ctrl.wLength);
-		if (usbfs_snoop) {
-			dev_info(&amp;dev-&gt;dev, "control write: data: ");
-			for (j = 0; j &lt; ctrl.wLength; ++j)
-				printk("%02x ", (unsigned char)(tbuf)[j]);
-			printk("\n");
-		}
+		pipe = usb_sndctrlpipe(dev, 0);
+		snoop_urb(dev, NULL, pipe, ctrl.wLength, tmo, SUBMIT);
+
 		usb_unlock_device(dev);
 		i = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), ctrl.bRequest,
 				    ctrl.bRequestType, ctrl.wValue, ctrl.wIndex,
 				    tbuf, ctrl.wLength, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, max(i, 0), min(i, 0), COMPLETE);
 	}
 	free_page((unsigned long)tbuf);
 	if (i &lt; 0 &amp;&amp; i != -EPIPE) {
@@ -774,7 +783,7 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 	unsigned int tmo, len1, pipe;
 	int len2;
 	unsigned char *tbuf;
-	int i, j, ret;
+	int i, ret;
 
 	if (copy_from_user(&amp;bulk, arg, sizeof(bulk)))
 		return -EFAULT;
@@ -801,18 +810,14 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 			kfree(tbuf);
 			return -EINVAL;
 		}
-		snoop(&amp;dev-&gt;dev, "bulk read: len=0x%02x timeout=%04d\n",
-			bulk.len, bulk.timeout);
+		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT);
+
 		usb_unlock_device(dev);
 		i = usb_bulk_msg(dev, pipe, tbuf, len1, &amp;len2, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, len2, i, COMPLETE);
+
 		if (!i &amp;&amp; len2) {
-			if (usbfs_snoop) {
-				dev_info(&amp;dev-&gt;dev, "bulk read: data ");
-				for (j = 0; j &lt; len2; ++j)
-					printk("%02x ", (u8)(tbuf)[j]);
-				printk("\n");
-			}
 			if (copy_to_user(bulk.data, tbuf, len2)) {
 				kfree(tbuf);
 				return -EFAULT;
@@ -825,17 +830,12 @@ static int proc_bulk(struct dev_state *ps, void __user *arg)
 				return -EFAULT;
 			}
 		}
-		snoop(&amp;dev-&gt;dev, "bulk write: len=0x%02x timeout=%04d\n",
-			bulk.len, bulk.timeout);
-		if (usbfs_snoop) {
-			dev_info(&amp;dev-&gt;dev, "bulk write: data: ");
-			for (j = 0; j &lt; len1; ++j)
-				printk("%02x ", (unsigned char)(tbuf)[j]);
-			printk("\n");
-		}
+		snoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT);
+
 		usb_unlock_device(dev);
 		i = usb_bulk_msg(dev, pipe, tbuf, len1, &amp;len2, tmo);
 		usb_lock_device(dev);
+		snoop_urb(dev, NULL, pipe, len2, i, COMPLETE);
 	}
 	kfree(tbuf);
 	if (i &lt; 0)
@@ -1053,13 +1053,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			is_in = 0;
 			uurb-&gt;endpoint &amp;= ~USB_DIR_IN;
 		}
-		snoop(&amp;ps-&gt;dev-&gt;dev, "control urb: bRequest=%02x "
-			"bRrequestType=%02x wValue=%04x "
-			"wIndex=%04x wLength=%04x\n",
-			dr-&gt;bRequest, dr-&gt;bRequestType,
-			__le16_to_cpup(&amp;dr-&gt;wValue),
-			__le16_to_cpup(&amp;dr-&gt;wIndex),
-			__le16_to_cpup(&amp;dr-&gt;wLength));
 		break;
 
 	case USBDEVFS_URB_TYPE_BULK:
@@ -1072,7 +1065,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 		uurb-&gt;number_of_packets = 0;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		snoop(&amp;ps-&gt;dev-&gt;dev, "bulk urb\n");
 		break;
 
 	case USBDEVFS_URB_TYPE_ISO:
@@ -1104,7 +1096,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EINVAL;
 		}
 		uurb-&gt;buffer_length = totlen;
-		snoop(&amp;ps-&gt;dev-&gt;dev, "iso urb\n");
 		break;
 
 	case USBDEVFS_URB_TYPE_INTERRUPT:
@@ -1113,7 +1104,6 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EINVAL;
 		if (uurb-&gt;buffer_length &gt; MAX_USBFS_BUFFER_SIZE)
 			return -EINVAL;
-		snoop(&amp;ps-&gt;dev-&gt;dev, "interrupt urb\n");
 		break;
 
 	default:
@@ -1200,11 +1190,14 @@ static int proc_do_submiturb(struct dev_state *ps, struct usbdevfs_urb *uurb,
 			return -EFAULT;
 		}
 	}
-	snoop_urb(as-&gt;urb, as-&gt;userurb);
+	snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
+			as-&gt;urb-&gt;transfer_buffer_length, 0, SUBMIT);
 	async_newpending(as);
 	if ((ret = usb_submit_urb(as-&gt;urb, GFP_KERNEL))) {
 		dev_printk(KERN_DEBUG, &amp;ps-&gt;dev-&gt;dev,
 			   "usbfs: usb_submit_urb returned %d\n", ret);
+		snoop_urb(ps-&gt;dev, as-&gt;userurb, as-&gt;urb-&gt;pipe,
+				0, ret, COMPLETE);
 		async_removepending(as);
 		free_async(as);
 		return ret;
@@ -1670,7 +1663,7 @@ static int usbdev_ioctl(struct inode *inode, struct file *file,
 		break;
 
 	case USBDEVFS_REAPURBNDELAY32:
-		snoop(&amp;dev-&gt;dev, "%s: REAPURBDELAY32\n", __func__);
+		snoop(&amp;dev-&gt;dev, "%s: REAPURBNDELAY32\n", __func__);
 		ret = proc_reapurbnonblock_compat(ps, p);
 		break;
 
@@ -1691,7 +1684,7 @@ static int usbdev_ioctl(struct inode *inode, struct file *file,
 		break;
 
 	case USBDEVFS_REAPURBNDELAY:
-		snoop(&amp;dev-&gt;dev, "%s: REAPURBDELAY\n", __func__);
+		snoop(&amp;dev-&gt;dev, "%s: REAPURBNDELAY\n", __func__);
 		ret = proc_reapurbnonblock(ps, p);
 		break;
 </pre><hr><pre>commit ccf5b801cef4f9e2d708d3b87e91e2bc6abd5206
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 11:00:01 2009 -0400

    USB: make intf.pm_usage an atomic_t
    
    This patch (as1260) changes the pm_usage_cnt field in struct
    usb_interface from an int to an atomic_t.  This is so that drivers can
    invoke the usb_autopm_get_interface_async() and
    usb_autopm_put_interface_async() routines without locking and without
    fear of corrupting the pm_usage_cnt value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 1bad4e5a6abb..1c976c141f33 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -235,7 +235,7 @@ static int usb_probe_interface(struct device *dev)
 		/* The interface should always appear to be in use
 		 * unless the driver suports autosuspend.
 		 */
-		intf-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+		atomic_set(&amp;intf-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
 
 		/* Carry out a deferred switch to altsetting 0 */
 		if (intf-&gt;needs_altsetting0) {
@@ -347,7 +347,7 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
-	iface-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
+	atomic_set(&amp;iface-&gt;pm_usage_cnt, !driver-&gt;supports_autosuspend);
 	usb_pm_unlock(udev);
 
 	/* if interface was already added, bind now; else let
@@ -1068,7 +1068,7 @@ static int autosuspend_check(struct usb_device *udev, int reschedule)
 			intf = udev-&gt;actconfig-&gt;interface[i];
 			if (!is_active(intf))
 				continue;
-			if (intf-&gt;pm_usage_cnt &gt; 0)
+			if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0)
 				return -EBUSY;
 			if (intf-&gt;needs_remote_wakeup &amp;&amp;
 					!udev-&gt;do_remote_wakeup) {
@@ -1464,17 +1464,19 @@ static int usb_autopm_do_interface(struct usb_interface *intf,
 		status = -ENODEV;
 	else {
 		udev-&gt;auto_pm = 1;
-		intf-&gt;pm_usage_cnt += inc_usage_cnt;
+		atomic_add(inc_usage_cnt, &amp;intf-&gt;pm_usage_cnt);
 		udev-&gt;last_busy = jiffies;
-		if (inc_usage_cnt &gt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &gt; 0) {
+		if (inc_usage_cnt &gt;= 0 &amp;&amp;
+				atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0) {
 			if (udev-&gt;state == USB_STATE_SUSPENDED)
 				status = usb_resume_both(udev,
 						PMSG_AUTO_RESUME);
 			if (status != 0)
-				intf-&gt;pm_usage_cnt -= inc_usage_cnt;
+				atomic_sub(inc_usage_cnt, &amp;intf-&gt;pm_usage_cnt);
 			else
 				udev-&gt;last_busy = jiffies;
-		} else if (inc_usage_cnt &lt;= 0 &amp;&amp; intf-&gt;pm_usage_cnt &lt;= 0) {
+		} else if (inc_usage_cnt &lt;= 0 &amp;&amp;
+				atomic_read(&amp;intf-&gt;pm_usage_cnt) &lt;= 0) {
 			status = usb_suspend_both(udev, PMSG_AUTO_SUSPEND);
 		}
 	}
@@ -1519,7 +1521,7 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 
 	status = usb_autopm_do_interface(intf, -1);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface);
 
@@ -1547,10 +1549,10 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 		status = -ENODEV;
 	} else {
 		udev-&gt;last_busy = jiffies;
-		--intf-&gt;pm_usage_cnt;
+		atomic_dec(&amp;intf-&gt;pm_usage_cnt);
 		if (udev-&gt;autosuspend_disabled || udev-&gt;autosuspend_delay &lt; 0)
 			status = -EPERM;
-		else if (intf-&gt;pm_usage_cnt &lt;= 0 &amp;&amp;
+		else if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &lt;= 0 &amp;&amp;
 				!timer_pending(&amp;udev-&gt;autosuspend.timer)) {
 			queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 					round_jiffies_up_relative(
@@ -1558,7 +1560,7 @@ void usb_autopm_put_interface_async(struct usb_interface *intf)
 		}
 	}
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 }
 EXPORT_SYMBOL_GPL(usb_autopm_put_interface_async);
 
@@ -1602,7 +1604,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 
 	status = usb_autopm_do_interface(intf, 1);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface);
@@ -1630,10 +1632,14 @@ int usb_autopm_get_interface_async(struct usb_interface *intf)
 		status = -ENODEV;
 	else if (udev-&gt;autoresume_disabled)
 		status = -EPERM;
-	else if (++intf-&gt;pm_usage_cnt &gt; 0 &amp;&amp; udev-&gt;state == USB_STATE_SUSPENDED)
-		queue_work(ksuspend_usb_wq, &amp;udev-&gt;autoresume);
+	else {
+		atomic_inc(&amp;intf-&gt;pm_usage_cnt);
+		if (atomic_read(&amp;intf-&gt;pm_usage_cnt) &gt; 0 &amp;&amp;
+				udev-&gt;state == USB_STATE_SUSPENDED)
+			queue_work(ksuspend_usb_wq, &amp;udev-&gt;autoresume);
+	}
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_get_interface_async);
@@ -1655,7 +1661,7 @@ int usb_autopm_set_interface(struct usb_interface *intf)
 
 	status = usb_autopm_do_interface(intf, 0);
 	dev_vdbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
-			__func__, status, intf-&gt;pm_usage_cnt);
+			__func__, status, atomic_read(&amp;intf-&gt;pm_usage_cnt));
 	return status;
 }
 EXPORT_SYMBOL_GPL(usb_autopm_set_interface);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index cb54420ed583..69e3a966a4b7 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -373,7 +373,7 @@ static void kick_khubd(struct usb_hub *hub)
 	unsigned long	flags;
 
 	/* Suppress autosuspend until khubd runs */
-	to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt = 1;
+	atomic_set(&amp;to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt, 1);
 
 	spin_lock_irqsave(&amp;hub_event_lock, flags);
 	if (!hub-&gt;disconnected &amp;&amp; list_empty(&amp;hub-&gt;event_list)) {
@@ -678,7 +678,8 @@ static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)
 					msecs_to_jiffies(delay));
 
 			/* Suppress autosuspend until init is done */
-			to_usb_interface(hub-&gt;intfdev)-&gt;pm_usage_cnt = 1;
+			atomic_set(&amp;to_usb_interface(hub-&gt;intfdev)-&gt;
+					pm_usage_cnt, 1);
 			return;		/* Continues at init2: below */
 		} else {
 			hub_power_on(hub, true);
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 3b45a0d27b80..a34fa89f1474 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -195,7 +195,7 @@ struct usb_interface {
 
 	struct device dev;		/* interface specific device info */
 	struct device *usb_dev;
-	int pm_usage_cnt;		/* usage counter for autosuspend */
+	atomic_t pm_usage_cnt;		/* usage counter for autosuspend */
 	struct work_struct reset_ws;	/* for resets in atomic context */
 };
 #define	to_usb_interface(d) container_of(d, struct usb_interface, dev)
@@ -551,13 +551,13 @@ extern void usb_autopm_put_interface_async(struct usb_interface *intf);
 
 static inline void usb_autopm_enable(struct usb_interface *intf)
 {
-	intf-&gt;pm_usage_cnt = 0;
+	atomic_set(&amp;intf-&gt;pm_usage_cnt, 0);
 	usb_autopm_set_interface(intf);
 }
 
 static inline void usb_autopm_disable(struct usb_interface *intf)
 {
-	intf-&gt;pm_usage_cnt = 1;
+	atomic_set(&amp;intf-&gt;pm_usage_cnt, 1);
 	usb_autopm_set_interface(intf);
 }
 </pre><hr><pre>commit 7cbe5dca399a50ce8aa74314b1d276e2fb904e1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 29 10:56:54 2009 -0400

    USB: add API for userspace drivers to "claim" ports
    
    This patch (as1258) implements a feature that users have been asking
    for: It gives programs the ability to "claim" a port on a hub, via a
    new usbfs ioctl.  A device plugged into a "claimed" port will not be
    touched by the kernel beyond the immediate necessities of
    initialization and enumeration.
    
    In particular, when a device is plugged into a "claimed" port, the
    kernel will not select and install a configuration.  And when a config
    is installed by usbfs or sysfs, the kernel will not probe any drivers
    for any of the interfaces.  (However the kernel will fetch various
    string descriptors during enumeration.  One could argue that this
    isn't really necessary, but the strings are exported in sysfs.)
    
    The patch does not guarantee exclusive access to these devices; it is
    still possible for more than one program to open the device file
    concurrently.  Programs are responsible for coordinating access among
    themselves.
    
    A demonstration program showing how to use the new interface can be
    found in an attachment to
    
            http://marc.info/?l=linux-usb&amp;m=124345857431452&amp;w=2
    
    The patch also makes a small simplification to the hub driver,
    replacing a bunch of more-or-less useless variants of "out of memory"
    with a single message.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 4247eccf858c..165de5d59005 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -52,6 +52,7 @@
 
 #include "hcd.h"	/* for usbcore internals */
 #include "usb.h"
+#include "hub.h"
 
 #define USB_MAXBUS			64
 #define USB_DEVICE_MAX			USB_MAXBUS * 128
@@ -655,6 +656,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	struct async *as;
 
 	usb_lock_device(dev);
+	usb_hub_release_all_ports(dev, ps);
 
 	/* Protect against simultaneous open */
 	mutex_lock(&amp;usbfs_mutex);
@@ -1548,6 +1550,29 @@ static int proc_ioctl_compat(struct dev_state *ps, compat_uptr_t arg)
 }
 #endif
 
+static int proc_claim_port(struct dev_state *ps, void __user *arg)
+{
+	unsigned portnum;
+	int rc;
+
+	if (get_user(portnum, (unsigned __user *) arg))
+		return -EFAULT;
+	rc = usb_hub_claim_port(ps-&gt;dev, portnum, ps);
+	if (rc == 0)
+		snoop(&amp;ps-&gt;dev-&gt;dev, "port %d claimed by process %d: %s\n",
+			portnum, task_pid_nr(current), current-&gt;comm);
+	return rc;
+}
+
+static int proc_release_port(struct dev_state *ps, void __user *arg)
+{
+	unsigned portnum;
+
+	if (get_user(portnum, (unsigned __user *) arg))
+		return -EFAULT;
+	return usb_hub_release_port(ps-&gt;dev, portnum, ps);
+}
+
 /*
  * NOTE:  All requests here that have interface numbers as parameters
  * are assuming that somehow the configuration has been prevented from
@@ -1689,6 +1714,16 @@ static int usbdev_ioctl(struct inode *inode, struct file *file,
 		snoop(&amp;dev-&gt;dev, "%s: IOCTL\n", __func__);
 		ret = proc_ioctl_default(ps, p);
 		break;
+
+	case USBDEVFS_CLAIM_PORT:
+		snoop(&amp;dev-&gt;dev, "%s: CLAIM_PORT\n", __func__);
+		ret = proc_claim_port(ps, p);
+		break;
+
+	case USBDEVFS_RELEASE_PORT:
+		snoop(&amp;dev-&gt;dev, "%s: RELEASE_PORT\n", __func__);
+		ret = proc_release_port(ps, p);
+		break;
 	}
 	usb_unlock_device(dev);
 	if (ret &gt;= 0)
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 69e5773abfce..1bad4e5a6abb 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -207,6 +207,9 @@ static int usb_probe_interface(struct device *dev)
 
 	intf-&gt;needs_binding = 0;
 
+	if (usb_device_is_owned(udev))
+		return -ENODEV;
+
 	if (udev-&gt;authorized == 0) {
 		dev_err(&amp;intf-&gt;dev, "Device is not authorized for usage\n");
 		return -ENODEV;
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 30ecac3af15a..05e6d313961e 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -158,7 +158,9 @@ static int generic_probe(struct usb_device *udev)
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
-	if (udev-&gt;authorized == 0)
+	if (usb_device_is_owned(udev))
+		;		/* Don't configure if the device is owned */
+	else if (udev-&gt;authorized == 0)
 		dev_err(&amp;udev-&gt;dev, "Device is not authorized for usage\n");
 	else {
 		c = usb_choose_configuration(udev);
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 71f86c60d83c..cb54420ed583 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -78,6 +78,7 @@ struct usb_hub {
 	u8			indicator[USB_MAXCHILDREN];
 	struct delayed_work	leds;
 	struct delayed_work	init_work;
+	void			**port_owners;
 };
 
 
@@ -860,19 +861,17 @@ static int hub_configure(struct usb_hub *hub,
 	u16 wHubCharacteristics;
 	unsigned int pipe;
 	int maxp, ret;
-	char *message;
+	char *message = "out of memory";
 
 	hub-&gt;buffer = usb_buffer_alloc(hdev, sizeof(*hub-&gt;buffer), GFP_KERNEL,
 			&amp;hub-&gt;buffer_dma);
 	if (!hub-&gt;buffer) {
-		message = "can't allocate hub irq buffer";
 		ret = -ENOMEM;
 		goto fail;
 	}
 
 	hub-&gt;status = kmalloc(sizeof(*hub-&gt;status), GFP_KERNEL);
 	if (!hub-&gt;status) {
-		message = "can't kmalloc hub status buffer";
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -880,7 +879,6 @@ static int hub_configure(struct usb_hub *hub,
 
 	hub-&gt;descriptor = kmalloc(sizeof(*hub-&gt;descriptor), GFP_KERNEL);
 	if (!hub-&gt;descriptor) {
-		message = "can't kmalloc hub descriptor";
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -904,6 +902,12 @@ static int hub_configure(struct usb_hub *hub,
 	dev_info (hub_dev, "%d port%s detected\n", hdev-&gt;maxchild,
 		(hdev-&gt;maxchild == 1) ? "" : "s");
 
+	hub-&gt;port_owners = kzalloc(hdev-&gt;maxchild * sizeof(void *), GFP_KERNEL);
+	if (!hub-&gt;port_owners) {
+		ret = -ENOMEM;
+		goto fail;
+	}
+
 	wHubCharacteristics = le16_to_cpu(hub-&gt;descriptor-&gt;wHubCharacteristics);
 
 	if (wHubCharacteristics &amp; HUB_CHAR_COMPOUND) {
@@ -1082,7 +1086,6 @@ static int hub_configure(struct usb_hub *hub,
 
 	hub-&gt;urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!hub-&gt;urb) {
-		message = "couldn't allocate interrupt urb";
 		ret = -ENOMEM;
 		goto fail;
 	}
@@ -1131,11 +1134,13 @@ static void hub_disconnect(struct usb_interface *intf)
 	hub_quiesce(hub, HUB_DISCONNECT);
 
 	usb_set_intfdata (intf, NULL);
+	hub-&gt;hdev-&gt;maxchild = 0;
 
 	if (hub-&gt;hdev-&gt;speed == USB_SPEED_HIGH)
 		highspeed_hubs--;
 
 	usb_free_urb(hub-&gt;urb);
+	kfree(hub-&gt;port_owners);
 	kfree(hub-&gt;descriptor);
 	kfree(hub-&gt;status);
 	usb_buffer_free(hub-&gt;hdev, sizeof(*hub-&gt;buffer), hub-&gt;buffer,
@@ -1250,6 +1255,79 @@ hub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)
 	}
 }
 
+/*
+ * Allow user programs to claim ports on a hub.  When a device is attached
+ * to one of these "claimed" ports, the program will "own" the device.
+ */
+static int find_port_owner(struct usb_device *hdev, unsigned port1,
+		void ***ppowner)
+{
+	if (hdev-&gt;state == USB_STATE_NOTATTACHED)
+		return -ENODEV;
+	if (port1 == 0 || port1 &gt; hdev-&gt;maxchild)
+		return -EINVAL;
+
+	/* This assumes that devices not managed by the hub driver
+	 * will always have maxchild equal to 0.
+	 */
+	*ppowner = &amp;(hdev_to_hub(hdev)-&gt;port_owners[port1 - 1]);
+	return 0;
+}
+
+/* In the following three functions, the caller must hold hdev's lock */
+int usb_hub_claim_port(struct usb_device *hdev, unsigned port1, void *owner)
+{
+	int rc;
+	void **powner;
+
+	rc = find_port_owner(hdev, port1, &amp;powner);
+	if (rc)
+		return rc;
+	if (*powner)
+		return -EBUSY;
+	*powner = owner;
+	return rc;
+}
+
+int usb_hub_release_port(struct usb_device *hdev, unsigned port1, void *owner)
+{
+	int rc;
+	void **powner;
+
+	rc = find_port_owner(hdev, port1, &amp;powner);
+	if (rc)
+		return rc;
+	if (*powner != owner)
+		return -ENOENT;
+	*powner = NULL;
+	return rc;
+}
+
+void usb_hub_release_all_ports(struct usb_device *hdev, void *owner)
+{
+	int n;
+	void **powner;
+
+	n = find_port_owner(hdev, 1, &amp;powner);
+	if (n == 0) {
+		for (; n &lt; hdev-&gt;maxchild; (++n, ++powner)) {
+			if (*powner == owner)
+				*powner = NULL;
+		}
+	}
+}
+
+/* The caller must hold udev's lock */
+bool usb_device_is_owned(struct usb_device *udev)
+{
+	struct usb_hub *hub;
+
+	if (udev-&gt;state == USB_STATE_NOTATTACHED || !udev-&gt;parent)
+		return false;
+	hub = hdev_to_hub(udev-&gt;parent);
+	return !!hub-&gt;port_owners[udev-&gt;portnum - 1];
+}
+
 
 static void recursively_mark_NOTATTACHED(struct usb_device *udev)
 {
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index c0e0ae2bb8e7..9a8b15e6377a 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -37,6 +37,13 @@ extern int usb_match_device(struct usb_device *dev,
 extern void usb_forced_unbind_intf(struct usb_interface *intf);
 extern void usb_rebind_intf(struct usb_interface *intf);
 
+extern int usb_hub_claim_port(struct usb_device *hdev, unsigned port,
+		void *owner);
+extern int usb_hub_release_port(struct usb_device *hdev, unsigned port,
+		void *owner);
+extern void usb_hub_release_all_ports(struct usb_device *hdev, void *owner);
+extern bool usb_device_is_owned(struct usb_device *udev);
+
 extern int  usb_hub_init(void);
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
diff --git a/include/linux/usbdevice_fs.h b/include/linux/usbdevice_fs.h
index 0044d9b4cb85..00ceebeb9e5c 100644
--- a/include/linux/usbdevice_fs.h
+++ b/include/linux/usbdevice_fs.h
@@ -175,4 +175,6 @@ struct usbdevfs_ioctl32 {
 #define USBDEVFS_CLEAR_HALT        _IOR('U', 21, unsigned int)
 #define USBDEVFS_DISCONNECT        _IO('U', 22)
 #define USBDEVFS_CONNECT           _IO('U', 23)
+#define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
+#define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
 #endif /* _LINUX_USBDEVICE_FS_H */</pre>
    <div class="pagination">
        <a href='2_73.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><span>[74]</span><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_75.html'>Next&gt;&gt;</a>
    <div>
</body>
