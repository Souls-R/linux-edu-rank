<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_23.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><span>[24]</span><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_25.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ab2a4bf83902c170d29ba130a8abb5f9d90559e1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 27 10:23:10 2016 -0400

    USB: don't free bandwidth_mutex too early
    
    The USB core contains a bug that can show up when a USB-3 host
    controller is removed.  If the primary (USB-2) hcd structure is
    released before the shared (USB-3) hcd, the core will try to do a
    double-free of the common bandwidth_mutex.
    
    The problem was described in graphical form by Chung-Geol Kim, who
    first reported it:
    
    =================================================
         At *remove USB(3.0) Storage
         sequence &lt;1&gt; --&gt; &lt;5&gt; ((Problem Case))
    =================================================
                                      VOLD
    ------------------------------------|------------
                                     (uevent)
                                ________|_________
                               |&lt;1&gt;               |
                               |dwc3_otg_sm_work  |
                               |usb_put_hcd       |
                               |peer_hcd(kref=2)|
                               |__________________|
                                ________|_________
                               |&lt;2&gt;               |
                               |New USB BUS #2    |
                               |                  |
                               |peer_hcd(kref=1)  |
                               |                  |
                             --(Link)-bandXX_mutex|
                             | |__________________|
                             |
        ___________________  |
       |&lt;3&gt;                | |
       |dwc3_otg_sm_work   | |
       |usb_put_hcd        | |
       |primary_hcd(kref=1)| |
       |___________________| |
        _________|_________  |
       |&lt;4&gt;                | |
       |New USB BUS #1     | |
       |hcd_release        | |
       |primary_hcd(kref=0)| |
       |                   | |
       |bandXX_mutex(free) |&lt;-
       |___________________|
                                   (( VOLD ))
                                ______|___________
                               |&lt;5&gt;               |
                               |      SCSI        |
                               |usb_put_hcd       |
                               |peer_hcd(kref=0)  |
                               |*hcd_release      |
                               |bandXX_mutex(free*)|&lt;- double free
                               |__________________|
    
    =================================================
    
    This happens because hcd_release() frees the bandwidth_mutex whenever
    it sees a primary hcd being released (which is not a very good idea
    in any case), but in the course of releasing the primary hcd, it
    changes the pointers in the shared hcd in such a way that the shared
    hcd will appear to be primary when it gets released.
    
    This patch fixes the problem by changing hcd_release() so that it
    deallocates the bandwidth_mutex only when the _last_ hcd structure
    referencing it is released.  The patch also removes an unnecessary
    test, so that when an hcd is released, both the shared_hcd and
    primary_hcd pointers in the hcd's peer will be cleared.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Chung-Geol Kim &lt;chunggeol.kim@samsung.com&gt;
    Tested-by: Chung-Geol Kim &lt;chunggeol.kim@samsung.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 34b837ae1ed7..d2e3f655c26f 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2598,26 +2598,23 @@ EXPORT_SYMBOL_GPL(usb_create_hcd);
  * Don't deallocate the bandwidth_mutex until the last shared usb_hcd is
  * deallocated.
  *
- * Make sure to only deallocate the bandwidth_mutex when the primary HCD is
- * freed.  When hcd_release() is called for either hcd in a peer set
- * invalidate the peer's -&gt;shared_hcd and -&gt;primary_hcd pointers to
- * block new peering attempts
+ * Make sure to deallocate the bandwidth_mutex only when the last HCD is
+ * freed.  When hcd_release() is called for either hcd in a peer set,
+ * invalidate the peer's -&gt;shared_hcd and -&gt;primary_hcd pointers.
  */
 static void hcd_release(struct kref *kref)
 {
 	struct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);
 
 	mutex_lock(&amp;usb_port_peer_mutex);
-	if (usb_hcd_is_primary_hcd(hcd)) {
-		kfree(hcd-&gt;address0_mutex);
-		kfree(hcd-&gt;bandwidth_mutex);
-	}
 	if (hcd-&gt;shared_hcd) {
 		struct usb_hcd *peer = hcd-&gt;shared_hcd;
 
 		peer-&gt;shared_hcd = NULL;
-		if (peer-&gt;primary_hcd == hcd)
-			peer-&gt;primary_hcd = NULL;
+		peer-&gt;primary_hcd = NULL;
+	} else {
+		kfree(hcd-&gt;address0_mutex);
+		kfree(hcd-&gt;bandwidth_mutex);
 	}
 	mutex_unlock(&amp;usb_port_peer_mutex);
 	kfree(hcd);</pre><hr><pre>commit 7e8b3dfef16375dbfeb1f36a83eb9f27117c51fd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 23 14:54:37 2016 -0400

    USB: EHCI: declare hostpc register as zero-length array
    
    The HOSTPC extension registers found in some EHCI implementations form
    a variable-length array, with one element for each port.  Therefore
    the hostpc field in struct ehci_regs should be declared as a
    zero-length array, not a single-element array.
    
    This fixes a problem reported by UBSAN.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Wilfried Klaebe &lt;linux-kernel@lebenslange-mailadresse.de&gt;
    Tested-by: Wilfried Klaebe &lt;linux-kernel@lebenslange-mailadresse.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb/ehci_def.h b/include/linux/usb/ehci_def.h
index 966889a20ea3..e479033bd782 100644
--- a/include/linux/usb/ehci_def.h
+++ b/include/linux/usb/ehci_def.h
@@ -180,11 +180,11 @@ struct ehci_regs {
  * PORTSCx
  */
 	/* HOSTPC: offset 0x84 */
-	u32		hostpc[1];	/* HOSTPC extension */
+	u32		hostpc[0];	/* HOSTPC extension */
 #define HOSTPC_PHCD	(1&lt;&lt;22)		/* Phy clock disable */
 #define HOSTPC_PSPD	(3&lt;&lt;25)		/* Port speed detection */
 
-	u32		reserved5[16];
+	u32		reserved5[17];
 
 	/* USBMODE_EX: offset 0xc8 */
 	u32		usbmode_ex;	/* USB Device mode extension */</pre><hr><pre>commit 85e3990bea49a50cb389015fea564b58899ab7c1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu May 19 16:29:50 2016 -0400

    USB: EHCI: avoid undefined pointer arithmetic and placate UBSAN
    
    Several people have reported that UBSAN doesn't like the pointer
    arithmetic in ehci_hub_control():
    
            u32 __iomem     *status_reg = &amp;ehci-&gt;regs-&gt;port_status[
                                    (wIndex &amp; 0xff) - 1];
            u32 __iomem     *hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[(wIndex &amp; 0xff) - 1];
    
    If wIndex is 0 (and it often is), these calculations underflow and
    UBSAN complains.
    
    According to the C standard, pointer computations leading to locations
    outside the bounds of an array object (other than 1 position past the
    end) are undefined.  In this case, the compiler would be justified in
    concluding the wIndex can never be 0 and then optimizing away the
    tests for !wIndex that occur later in the subroutine.  (Although,
    since ehci-&gt;regs-&gt;port_status and ehci-&gt;regs-&gt;hostpc are both 0-length
    arrays and are thus GCC extensions to the C standard, it's not clear
    what the compiler is really allowed to do.)
    
    At any rate, we can avoid all these difficulties, at the cost of
    making the code slightly longer, by not decrementing the index when it
    is equal to 0.  The runtime effect is minimal, and anyway
    ehci_hub_control() is not on a hot path.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Reported-by: Meelis Roos &lt;mroos@linux.ee&gt;
    Reported-by: Martin_MOKREJÅ &lt;mmokrejs@gmail.com&gt;
    Reported-by: "Navin P.S" &lt;navinp1912@gmail.com&gt;
    CC: Andrey Ryabinin &lt;ryabinin.a.a@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index ffc90295a95f..74f62d68f013 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -872,14 +872,22 @@ int ehci_hub_control(
 ) {
 	struct ehci_hcd	*ehci = hcd_to_ehci (hcd);
 	int		ports = HCS_N_PORTS (ehci-&gt;hcs_params);
-	u32 __iomem	*status_reg = &amp;ehci-&gt;regs-&gt;port_status[
-				(wIndex &amp; 0xff) - 1];
-	u32 __iomem	*hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[(wIndex &amp; 0xff) - 1];
+	u32 __iomem	*status_reg, *hostpc_reg;
 	u32		temp, temp1, status;
 	unsigned long	flags;
 	int		retval = 0;
 	unsigned	selector;
 
+	/*
+	 * Avoid underflow while calculating (wIndex &amp; 0xff) - 1.
+	 * The compiler might deduce that wIndex can never be 0 and then
+	 * optimize away the tests for !wIndex below.
+	 */
+	temp = wIndex &amp; 0xff;
+	temp -= (temp &gt; 0);
+	status_reg = &amp;ehci-&gt;regs-&gt;port_status[temp];
+	hostpc_reg = &amp;ehci-&gt;regs-&gt;hostpc[temp];
+
 	/*
 	 * FIXME:  support SetPortFeatures USB_PORT_FEAT_INDICATOR.
 	 * HCS_INDICATOR may say we can change LEDs to off/amber/green.</pre><hr><pre>commit 6fb650d43da3e7054984dc548eaa88765a94d49f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 29 15:25:17 2016 -0400

    USB: leave LPM alone if possible when binding/unbinding interface drivers
    
    When a USB driver is bound to an interface (either through probing or
    by claiming it) or is unbound from an interface, the USB core always
    disables Link Power Management during the transition and then
    re-enables it afterward.  The reason is because the driver might want
    to prevent hub-initiated link power transitions, in which case the HCD
    would have to recalculate the various LPM parameters.  This
    recalculation takes place when LPM is re-enabled and the new
    parameters are sent to the device and its parent hub.
    
    However, if the driver does not want to prevent hub-initiated link
    power transitions then none of this work is necessary.  The parameters
    don't need to be recalculated, and LPM doesn't need to be disabled and
    re-enabled.
    
    It turns out that disabling and enabling LPM can be time-consuming,
    enough so that it interferes with user programs that want to claim and
    release interfaces rapidly via usbfs.  Since the usbfs kernel driver
    doesn't set the disable_hub_initiated_lpm flag, we can speed things up
    and get the user programs to work by leaving LPM alone whenever the
    flag isn't set.
    
    And while we're improving the way disable_hub_initiated_lpm gets used,
    let's also fix its kerneldoc.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Matthew Giassa &lt;matthew@giassa.net&gt;
    CC: Mathias Nyman &lt;mathias.nyman@intel.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 2057d91d8336..dadd1e8dfe09 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -284,7 +284,7 @@ static int usb_probe_interface(struct device *dev)
 	struct usb_device *udev = interface_to_usbdev(intf);
 	const struct usb_device_id *id;
 	int error = -ENODEV;
-	int lpm_disable_error;
+	int lpm_disable_error = -ENODEV;
 
 	dev_dbg(dev, "%s\n", __func__);
 
@@ -336,12 +336,14 @@ static int usb_probe_interface(struct device *dev)
 	 * setting during probe, that should also be fine.  usb_set_interface()
 	 * will attempt to disable LPM, and fail if it can't disable it.
 	 */
-	lpm_disable_error = usb_unlocked_disable_lpm(udev);
-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {
-		dev_err(&amp;intf-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
-				__func__, driver-&gt;name);
-		error = lpm_disable_error;
-		goto err;
+	if (driver-&gt;disable_hub_initiated_lpm) {
+		lpm_disable_error = usb_unlocked_disable_lpm(udev);
+		if (lpm_disable_error) {
+			dev_err(&amp;intf-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
+					__func__, driver-&gt;name);
+			error = lpm_disable_error;
+			goto err;
+		}
 	}
 
 	/* Carry out a deferred switch to altsetting 0 */
@@ -391,7 +393,8 @@ static int usb_unbind_interface(struct device *dev)
 	struct usb_interface *intf = to_usb_interface(dev);
 	struct usb_host_endpoint *ep, **eps = NULL;
 	struct usb_device *udev;
-	int i, j, error, r, lpm_disable_error;
+	int i, j, error, r;
+	int lpm_disable_error = -ENODEV;
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
@@ -399,12 +402,13 @@ static int usb_unbind_interface(struct device *dev)
 	udev = interface_to_usbdev(intf);
 	error = usb_autoresume_device(udev);
 
-	/* Hub-initiated LPM policy may change, so attempt to disable LPM until
+	/* If hub-initiated LPM policy may change, attempt to disable LPM until
 	 * the driver is unbound.  If LPM isn't disabled, that's fine because it
 	 * wouldn't be enabled unless all the bound interfaces supported
 	 * hub-initiated LPM.
 	 */
-	lpm_disable_error = usb_unlocked_disable_lpm(udev);
+	if (driver-&gt;disable_hub_initiated_lpm)
+		lpm_disable_error = usb_unlocked_disable_lpm(udev);
 
 	/*
 	 * Terminate all URBs for this interface unless the driver
@@ -505,7 +509,7 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	struct device *dev;
 	struct usb_device *udev;
 	int retval = 0;
-	int lpm_disable_error;
+	int lpm_disable_error = -ENODEV;
 
 	if (!iface)
 		return -ENODEV;
@@ -526,12 +530,14 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
-	/* Disable LPM until this driver is bound. */
-	lpm_disable_error = usb_unlocked_disable_lpm(udev);
-	if (lpm_disable_error &amp;&amp; driver-&gt;disable_hub_initiated_lpm) {
-		dev_err(&amp;iface-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
-				__func__, driver-&gt;name);
-		return -ENOMEM;
+	/* See the comment about disabling LPM in usb_probe_interface(). */
+	if (driver-&gt;disable_hub_initiated_lpm) {
+		lpm_disable_error = usb_unlocked_disable_lpm(udev);
+		if (lpm_disable_error) {
+			dev_err(&amp;iface-&gt;dev, "%s Failed to disable LPM for driver %s\n.",
+					__func__, driver-&gt;name);
+			return -ENOMEM;
+		}
 	}
 
 	/* Claimed interfaces are initially inactive (suspended) and
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 01b6c61cf9bb..eba1f10e8cfd 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -1068,7 +1068,7 @@ struct usbdrv_wrap {
  *	for interfaces bound to this driver.
  * @soft_unbind: if set to 1, the USB core will not kill URBs and disable
  *	endpoints before calling the driver's disconnect method.
- * @disable_hub_initiated_lpm: if set to 0, the USB core will not allow hubs
+ * @disable_hub_initiated_lpm: if set to 1, the USB core will not allow hubs
  *	to initiate lower power link state transitions when an idle timeout
  *	occurs.  Device-initiated USB 3.0 link PM will still be allowed.
  *</pre><hr><pre>commit 128f8b3d77149e9f38fb6f52931cf791155d277a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Apr 29 15:19:56 2016 -0400

    USB: EHCI: make all debugging depend on CONFIG_DYNAMIC_DEBUG
    
    The debugging facilities in ehci-dbg.c follow an uneven pattern.  Some
    of them are protected by "#ifdef CONFIG_DYNAMIC_DEBUG" and some
    aren't, presumably in the hope of having some of the debugging output
    available in any configuration.
    
    This leads to build problems when dynamic debugging isn't configured.
    Rather than try to keep this complicated state of affairs, let's just
    make everything dependent on CONFIG_DYNAMIC_DEBUG.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Rafał Miłecki &lt;zajec5@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index 79d12b2ba3c4..1a2614aae42c 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -52,13 +52,6 @@ static void dbg_hcs_params(struct ehci_hcd *ehci, char *label)
 		ehci_dbg(ehci, "%s portroute %s\n", label, buf);
 	}
 }
-#else
-
-static inline void dbg_hcs_params(struct ehci_hcd *ehci, char *label) {}
-
-#endif
-
-#ifdef CONFIG_DYNAMIC_DEBUG
 
 /*
  * check the values in the HCCPARAMS register
@@ -92,13 +85,6 @@ static void dbg_hcc_params(struct ehci_hcd *ehci, char *label)
 				" 32 periodic list" : "");
 	}
 }
-#else
-
-static inline void dbg_hcc_params(struct ehci_hcd *ehci, char *label) {}
-
-#endif
-
-#ifdef CONFIG_DYNAMIC_DEBUG
 
 static void __maybe_unused
 dbg_qtd(const char *label, struct ehci_hcd *ehci, struct ehci_qtd *qtd)
@@ -281,37 +267,6 @@ dbg_port_buf(char *buf, unsigned len, const char *label, int port, u32 status)
 		(status &amp; PORT_CONNECT) ? " CONNECT" : "");
 }
 
-#else
-static inline void __maybe_unused
-dbg_qh(char *label, struct ehci_hcd *ehci, struct ehci_qh *qh)
-{}
-
-static inline int __maybe_unused
-dbg_status_buf(char *buf, unsigned len, const char *label, u32 status)
-{
-	return 0;
-}
-
-static inline int __maybe_unused
-dbg_command_buf(char *buf, unsigned len, const char *label, u32 command)
-{
-	return 0;
-}
-
-static inline int __maybe_unused
-dbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)
-{
-	return 0;
-}
-
-static inline int __maybe_unused
-dbg_port_buf(char *buf, unsigned len, const char *label, int port, u32 status)
-{
-	return 0;
-}
-
-#endif	/* CONFIG_DYNAMIC_DEBUG */
-
 static inline void
 dbg_status(struct ehci_hcd *ehci, const char *label, u32 status)
 {
@@ -341,13 +296,6 @@ dbg_port(struct ehci_hcd *ehci, const char *label, int port, u32 status)
 
 /*-------------------------------------------------------------------------*/
 
-#ifndef CONFIG_DYNAMIC_DEBUG
-
-static inline void create_debug_files(struct ehci_hcd *bus) { }
-static inline void remove_debug_files(struct ehci_hcd *bus) { }
-
-#else
-
 /* troubleshooting help: expose state in debugfs */
 
 static int debug_async_open(struct inode *, struct file *);
@@ -1120,4 +1068,38 @@ static inline void remove_debug_files(struct ehci_hcd *ehci)
 	debugfs_remove_recursive(ehci-&gt;debug_dir);
 }
 
+#else /* CONFIG_DYNAMIC_DEBUG */
+
+static inline void dbg_hcs_params(struct ehci_hcd *ehci, char *label) { }
+static inline void dbg_hcc_params(struct ehci_hcd *ehci, char *label) { }
+
+static inline void __maybe_unused dbg_qh(const char *label,
+		struct ehci_hcd *ehci, struct ehci_qh *qh) { }
+
+static inline int __maybe_unused dbg_status_buf(const char *buf,
+		unsigned int len, const char *label, u32 status)
+{ return 0; }
+
+static inline int __maybe_unused dbg_command_buf(const char *buf,
+		unsigned int len, const char *label, u32 command)
+{ return 0; }
+
+static inline int __maybe_unused dbg_intr_buf(const char *buf,
+		unsigned int len, const char *label, u32 enable)
+{ return 0; }
+
+static inline int __maybe_unused dbg_port_buf(char *buf,
+		unsigned int len, const char *label, int port, u32 status)
+{ return 0; }
+
+static inline void dbg_status(struct ehci_hcd *ehci, const char *label,
+		u32 status) { }
+static inline void dbg_cmd(struct ehci_hcd *ehci, const char *label,
+		u32 command) { }
+static inline void dbg_port(struct ehci_hcd *ehci, const char *label,
+		int port, u32 status) { }
+
+static inline void create_debug_files(struct ehci_hcd *bus) { }
+static inline void remove_debug_files(struct ehci_hcd *bus) { }
+
 #endif /* CONFIG_DYNAMIC_DEBUG */</pre><hr><pre>commit 972e6a993f278b416a8ee3ec65475724fc36feb2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 23 12:17:09 2016 -0400

    HID: usbhid: fix inconsistent reset/resume/reset-resume behavior
    
    The usbhid driver has inconsistently duplicated code in its post-reset,
    resume, and reset-resume pathways.
    
            reset-resume doesn't check HID_STARTED before trying to
            restart the I/O queues.
    
            resume fails to clear the HID_SUSPENDED flag if HID_STARTED
            isn't set.
    
            resume calls usbhid_restart_queues() with usbhid-&gt;lock held
            and the others call it without holding the lock.
    
    The first item in particular causes a problem following a reset-resume
    if the driver hasn't started up its I/O.  URB submission fails because
    usbhid-&gt;urbin is NULL, and this triggers an unending reset-retry loop.
    
    This patch fixes the problem by creating a new subroutine,
    hid_restart_io(), to carry out all the common activities.  It also
    adds some checks that were missing in the original code:
    
            After a reset, there's no need to clear any halted endpoints.
    
            After a resume, if a reset is pending there's no need to
            restart any I/O until the reset is finished.
    
            After a resume, if the interrupt-IN endpoint is halted there's
            no need to submit the input URB until the halt has been
            cleared.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Daniel Fraga &lt;fragabr@gmail.com&gt;
    Tested-by: Daniel Fraga &lt;fragabr@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index ad71160b9ea4..ae83af649a60 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -951,14 +951,6 @@ static int usbhid_output_report(struct hid_device *hid, __u8 *buf, size_t count)
 	return ret;
 }
 
-static void usbhid_restart_queues(struct usbhid_device *usbhid)
-{
-	if (usbhid-&gt;urbout &amp;&amp; !test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
-		usbhid_restart_out_queue(usbhid);
-	if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
-		usbhid_restart_ctrl_queue(usbhid);
-}
-
 static void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)
 {
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
@@ -1404,6 +1396,37 @@ static void hid_cease_io(struct usbhid_device *usbhid)
 	usb_kill_urb(usbhid-&gt;urbout);
 }
 
+static void hid_restart_io(struct hid_device *hid)
+{
+	struct usbhid_device *usbhid = hid-&gt;driver_data;
+	int clear_halt = test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl);
+	int reset_pending = test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl);
+
+	spin_lock_irq(&amp;usbhid-&gt;lock);
+	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
+	usbhid_mark_busy(usbhid);
+
+	if (clear_halt || reset_pending)
+		schedule_work(&amp;usbhid-&gt;reset_work);
+	usbhid-&gt;retry_delay = 0;
+	spin_unlock_irq(&amp;usbhid-&gt;lock);
+
+	if (reset_pending || !test_bit(HID_STARTED, &amp;usbhid-&gt;iofl))
+		return;
+
+	if (!clear_halt) {
+		if (hid_start_in(hid) &lt; 0)
+			hid_io_error(hid);
+	}
+
+	spin_lock_irq(&amp;usbhid-&gt;lock);
+	if (usbhid-&gt;urbout &amp;&amp; !test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
+		usbhid_restart_out_queue(usbhid);
+	if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
+		usbhid_restart_ctrl_queue(usbhid);
+	spin_unlock_irq(&amp;usbhid-&gt;lock);
+}
+
 /* Treat USB reset pretty much the same as suspend/resume */
 static int hid_pre_reset(struct usb_interface *intf)
 {
@@ -1453,14 +1476,14 @@ static int hid_post_reset(struct usb_interface *intf)
 		return 1;
 	}
 
+	/* No need to do another reset or clear a halted endpoint */
 	spin_lock_irq(&amp;usbhid-&gt;lock);
 	clear_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl);
+	clear_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl);
 	spin_unlock_irq(&amp;usbhid-&gt;lock);
 	hid_set_idle(dev, intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber, 0, 0);
-	status = hid_start_in(hid);
-	if (status &lt; 0)
-		hid_io_error(hid);
-	usbhid_restart_queues(usbhid);
+
+	hid_restart_io(hid);
 
 	return 0;
 }
@@ -1483,25 +1506,9 @@ void usbhid_put_power(struct hid_device *hid)
 #ifdef CONFIG_PM
 static int hid_resume_common(struct hid_device *hid, bool driver_suspended)
 {
-	struct usbhid_device *usbhid = hid-&gt;driver_data;
-	int status;
-
-	spin_lock_irq(&amp;usbhid-&gt;lock);
-	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
-	usbhid_mark_busy(usbhid);
-
-	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl) ||
-			test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl))
-		schedule_work(&amp;usbhid-&gt;reset_work);
-	usbhid-&gt;retry_delay = 0;
-
-	usbhid_restart_queues(usbhid);
-	spin_unlock_irq(&amp;usbhid-&gt;lock);
-
-	status = hid_start_in(hid);
-	if (status &lt; 0)
-		hid_io_error(hid);
+	int status = 0;
 
+	hid_restart_io(hid);
 	if (driver_suspended &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;resume)
 		status = hid-&gt;driver-&gt;resume(hid);
 	return status;
@@ -1570,12 +1577,8 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 static int hid_resume(struct usb_interface *intf)
 {
 	struct hid_device *hid = usb_get_intfdata (intf);
-	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
 
-	if (!test_bit(HID_STARTED, &amp;usbhid-&gt;iofl))
-		return 0;
-
 	status = hid_resume_common(hid, true);
 	dev_dbg(&amp;intf-&gt;dev, "resume status %d\n", status);
 	return 0;
@@ -1584,10 +1587,8 @@ static int hid_resume(struct usb_interface *intf)
 static int hid_reset_resume(struct usb_interface *intf)
 {
 	struct hid_device *hid = usb_get_intfdata(intf);
-	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
 
-	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 	status = hid_post_reset(intf);
 	if (status &gt;= 0 &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;reset_resume) {
 		int ret = hid-&gt;driver-&gt;reset_resume(hid);</pre><hr><pre>commit 1586ba0c218b10cce1de57c45f599dd8831a2d12
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Feb 4 11:17:36 2016 -0500

    USB: EHCI: fix compiler warning introduced by commit 2a40f324541e
    
    Fix the following compiler warning (found by the kbuild test robot):
    
    drivers/usb/host/ehci-hcd.c:312:13: warning: 'unlink_empty_async_suspended' declared 'static' but never defined
    
    Commit 2a40f324541e ("USB: EHCI: fix regression during bus resume")
    protected the function definition with a "#ifdef CONFIG_PM" block, so
    now the declaration needs to be similarly protected.  This patch moves
    it to a better location.
    
    Reported-by: kbuild test robot &lt;fengguang.wu@intel.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index a93d445b63a4..ae1b6e69eb96 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -309,7 +309,6 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 static void end_iaa_cycle(struct ehci_hcd *ehci);
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void unlink_empty_async(struct ehci_hcd *ehci);
-static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
 static void ehci_work(struct ehci_hcd *ehci);
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6333d3c2be9c..ffc90295a95f 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -33,6 +33,8 @@
 
 #ifdef	CONFIG_PM
 
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
+
 static int persist_enabled_on_companion(struct usb_device *udev, void *unused)
 {
 	return !udev-&gt;maxchild &amp;&amp; udev-&gt;persist_enabled &amp;&amp;</pre><hr><pre>commit 8df0d77d8ce065ef536676fb4e1f36bfbf1dd809
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 25 15:45:38 2016 -0500

    USB: EHCI: improvements to unlink_empty_async_suspended()
    
    unlink_empty_async_suspended() is marked __maybe_unused.  This is
    because its caller, ehci_bus_suspend(), is protected by "#ifdef
    CONFIG_PM".  We should use the same protection here instead of
    __maybe_unused.
    
    unlink_empty_async_suspended() gets called only when the root hub is
    suspended.  It's silly for it to call start_iaa_cycle() at such a
    time; the IAA mechanism doesn't work when the root hub isn't running.
    It should call end_unlink_async() instead.  But even this isn't
    necessary, since there already is a call to end_iaa_cycle() right
    before the call to unlink_empty_async_suspended().  All we have to do
    is interchange the two subroutine calls.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6d84ce2edc27..6333d3c2be9c 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -347,9 +347,10 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		goto done;
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
+	unlink_empty_async_suspended(ehci);
+
 	/* Any IAA cycle that started before the suspend is now invalid */
 	end_iaa_cycle(ehci);
-	unlink_empty_async_suspended(ehci);
 	ehci_handle_start_intr_unlinks(ehci);
 	ehci_handle_intr_unlinks(ehci);
 	end_free_itds(ehci);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index a24341ef863d..eca3710d8fc4 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1459,8 +1459,10 @@ static void unlink_empty_async(struct ehci_hcd *ehci)
 	}
 }
 
+#ifdef	CONFIG_PM
+
 /* The root hub is suspended; unlink all the async QHs */
-static void __maybe_unused unlink_empty_async_suspended(struct ehci_hcd *ehci)
+static void unlink_empty_async_suspended(struct ehci_hcd *ehci)
 {
 	struct ehci_qh		*qh;
 
@@ -1469,9 +1471,10 @@ static void __maybe_unused unlink_empty_async_suspended(struct ehci_hcd *ehci)
 		WARN_ON(!list_empty(&amp;qh-&gt;qtd_list));
 		single_unlink_async(ehci, qh);
 	}
-	start_iaa_cycle(ehci);
 }
 
+#endif
+
 /* makes sure the async qh will become idle */
 /* caller must own ehci-&gt;lock */
 </pre><hr><pre>commit 87d61912c23a746ee9a8a8d2fe17af217c87f761
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 25 15:45:25 2016 -0500

    USB: EHCI: add a delay when unlinking an active QH
    
    Michael Reutman reports that an AMD/ATI EHCI host controller on one of
    his computers does not stop transferring data when an active bulk QH
    is unlinked from the async schedule.  Apparently that host controller
    fails to implement the IAA mechanism correctly when an active QH is
    unlinked.  This leads to data corruption, because the controller
    continues to update the QH in memory when the driver doesn't expect
    it.  As a result, the next URB submitted for that QH can hang, because
    the link pointers for the TD queue have been messed up.  This
    misbehavior is observed quite regularly.
    
    To be fair, the EHCI spec (section 4.8.2) says that active QHs should
    not be unlinked.  It goes on to recommend a procedure that involves
    waiting for the QH to go inactive before unlinking it.  In the real
    world this is impractical, not least because the QH may _never_ go
    inactive.  (What were they thinking?)  Sometimes we have no choice but
    to unlink an active QH.
    
    In an attempt to avoid the problems that can ensue, this patch changes
    how the driver decides when the unlink is complete.  In addition to
    waiting through two IAA cycles, in cases where the QH was not known to
    be inactive beforehand we now wait until a 2-ms period has elapsed
    with the host controller making no change to the QH data structure
    (the hw_current and hw_token fields in particular).  The intuition
    here is that after such a long period, the endpoint must be NAKing and
    hopefully the QH has been dropped from the host controller's internal
    cache.  There's no way to know if this reasoning is really valid --
    the spec is no help in this regard -- but at least this approach fixes
    Michael's problem.
    
    The test for whether the QH is already known to be inactive involves
    the reason for unlinking the QH originally.  If it was unlinked
    because it had halted, or it stopped in response to a short read, or
    it overlaid a dummy TD (a silicon bug), then it certainly is inactive.
    If it was unlinked because the TD queue was empty and no TDs have been
    added to the queue in the meantime, then it must be inactive.  Or if
    the hardware status indicates that the QH is currently halted (even if
    that wasn't the reason for unlinking it), then it is inactive.
    Otherwise, if none of those checks apply, we go through the 2-ms
    delay.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Michael Reutman &lt;mreutman@epiqsolutions.com&gt;
    Tested-by: Michael Reutman &lt;mreutman@epiqsolutions.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 84c41262109c..a93d445b63a4 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -566,6 +566,9 @@ static int ehci_init(struct usb_hcd *hcd)
 	/* Accept arbitrarily long scatter-gather lists */
 	if (!(hcd-&gt;driver-&gt;flags &amp; HCD_LOCAL_MEM))
 		hcd-&gt;self.sg_tablesize = ~0;
+
+	/* Prepare for unlinking active QHs */
+	ehci-&gt;old_current = ~0;
 	return 0;
 }
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 15dcae8f0631..a24341ef863d 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1341,14 +1341,60 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	 * after the IAA interrupt occurs.  In self-defense, always go
 	 * through two IAA cycles for each QH.
 	 */
-	else if (qh-&gt;qh_state == QH_STATE_UNLINK_WAIT) {
+	else if (qh-&gt;qh_state == QH_STATE_UNLINK) {
+		/*
+		 * Second IAA cycle has finished.  Process only the first
+		 * waiting QH (NVIDIA (?) bug).
+		 */
+		list_move_tail(&amp;qh-&gt;unlink_node, &amp;ehci-&gt;async_idle);
+	}
+
+	/*
+	 * AMD/ATI (?) bug: The HC can continue to use an active QH long
+	 * after the IAA interrupt occurs.  To prevent problems, QHs that
+	 * may still be active will wait until 2 ms have passed with no
+	 * change to the hw_current and hw_token fields (this delay occurs
+	 * between the two IAA cycles).
+	 *
+	 * The EHCI spec (4.8.2) says that active QHs must not be removed
+	 * from the async schedule and recommends waiting until the QH
+	 * goes inactive.  This is ridiculous because the QH will _never_
+	 * become inactive if the endpoint NAKs indefinitely.
+	 */
+
+	/* Some reasons for unlinking guarantee the QH can't be active */
+	else if (qh-&gt;unlink_reason &amp; (QH_UNLINK_HALTED |
+			QH_UNLINK_SHORT_READ | QH_UNLINK_DUMMY_OVERLAY))
+		goto DelayDone;
+
+	/* The QH can't be active if the queue was and still is empty... */
+	else if	((qh-&gt;unlink_reason &amp; QH_UNLINK_QUEUE_EMPTY) &amp;&amp;
+			list_empty(&amp;qh-&gt;qtd_list))
+		goto DelayDone;
+
+	/* ... or if the QH has halted */
+	else if	(qh-&gt;hw-&gt;hw_token &amp; cpu_to_hc32(ehci, QTD_STS_HALT))
+		goto DelayDone;
+
+	/* Otherwise we have to wait until the QH stops changing */
+	else {
+		__hc32		qh_current, qh_token;
+
+		qh_current = qh-&gt;hw-&gt;hw_current;
+		qh_token = qh-&gt;hw-&gt;hw_token;
+		if (qh_current != ehci-&gt;old_current ||
+				qh_token != ehci-&gt;old_token) {
+			ehci-&gt;old_current = qh_current;
+			ehci-&gt;old_token = qh_token;
+			ehci_enable_event(ehci,
+					EHCI_HRTIMER_ACTIVE_UNLINK, true);
+			return;
+		}
+ DelayDone:
 		qh-&gt;qh_state = QH_STATE_UNLINK;
 		early_exit = true;
 	}
-
-	/* Otherwise process only the first waiting QH (NVIDIA bug?) */
-	else
-		list_move_tail(&amp;qh-&gt;unlink_node, &amp;ehci-&gt;async_idle);
+	ehci-&gt;old_current = ~0;		/* Prepare for next QH */
 
 	/* Start a new IAA cycle if any QHs are waiting for it */
 	if (!list_empty(&amp;ehci-&gt;async_unlink))
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 6bea4d553ec5..69f50e6533a6 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -72,6 +72,7 @@ static unsigned event_delays_ns[] = {
 	1 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_POLL_DEAD */
 	1125 * NSEC_PER_USEC,	/* EHCI_HRTIMER_UNLINK_INTR */
 	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_FREE_ITDS */
+	2 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ACTIVE_UNLINK */
 	5 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_START_UNLINK_INTR */
 	6 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
@@ -395,6 +396,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_handle_controller_death,	/* EHCI_HRTIMER_POLL_DEAD */
 	ehci_handle_intr_unlinks,	/* EHCI_HRTIMER_UNLINK_INTR */
 	end_free_itds,			/* EHCI_HRTIMER_FREE_ITDS */
+	end_unlink_async,		/* EHCI_HRTIMER_ACTIVE_UNLINK */
 	ehci_handle_start_intr_unlinks,	/* EHCI_HRTIMER_START_UNLINK_INTR */
 	unlink_empty_async,		/* EHCI_HRTIMER_ASYNC_UNLINKS */
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index f11b9dc53981..b13894550139 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -110,6 +110,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_POLL_DEAD,		/* Wait for dead controller to stop */
 	EHCI_HRTIMER_UNLINK_INTR,	/* Wait for interrupt QH unlink */
 	EHCI_HRTIMER_FREE_ITDS,		/* Wait for unused iTDs and siTDs */
+	EHCI_HRTIMER_ACTIVE_UNLINK,	/* Wait while unlinking an active QH */
 	EHCI_HRTIMER_START_UNLINK_INTR, /* Unlink empty interrupt QHs */
 	EHCI_HRTIMER_ASYNC_UNLINKS,	/* Unlink empty async QHs */
 	EHCI_HRTIMER_IAA_WATCHDOG,	/* Handle lost IAA interrupts */
@@ -156,6 +157,8 @@ struct ehci_hcd {			/* one per controller */
 	struct list_head	async_idle;
 	unsigned		async_unlink_cycle;
 	unsigned		async_count;	/* async activity count */
+	__hc32			old_current;	/* Test for QH becoming */
+	__hc32			old_token;	/*  inactive during unlink */
 
 	/* periodic schedule support */
 #define	DEFAULT_I_TDPS		1024		/* some HCs can do less */</pre><hr><pre>commit f96fba0dbf8f6b0eaa313b4c230f93c9bb0dd759
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jan 25 15:44:16 2016 -0500

    USB: EHCI: improve handling of the ehci-&gt;iaa_in_progress flag
    
    This patch improves the way ehci-hcd handles the iaa_in_progress flag.
    The current code is somewhat careless in this regard:
    
            The flag is meaningless when the root hub isn't running, most
            particularly after the root hub has been suspended.  But in
            start_iaa_cycle(), the driver checks the flag before checking
            the root hub's state.  They should be checked in the opposite
            order.
    
            That routine also sets the flag too early, before it has
            definitely committed to starting an IAA cycle.
    
            The flag is turned off in end_unlink_async().  Upcoming
            changes will call that routine at other times, not just at the
            end of an IAA cycle.  The two actions are logically separate
            (although related), so we separate out a new routine to be
            called in place of end_unlink_async() whenever an IAA cycle
            ends: end_iaa_cycle().
    
            iaa_in_progress should be turned off when the root hub is
            suspended -- we certainly don't want it still to be set when
            the root hub resumes.  Therefore the call to
            end_unlink_async() in ehci_bus_suspend() should also be
            replaced with a call to end_iaa_cycle().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c5465bf9a798..84c41262109c 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -306,6 +306,7 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 
 /*-------------------------------------------------------------------------*/
 
+static void end_iaa_cycle(struct ehci_hcd *ehci);
 static void end_unlink_async(struct ehci_hcd *ehci);
 static void unlink_empty_async(struct ehci_hcd *ehci);
 static void unlink_empty_async_suspended(struct ehci_hcd *ehci);
@@ -758,7 +759,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 			ehci_dbg(ehci, "IAA with IAAD still set?\n");
 		if (ehci-&gt;iaa_in_progress)
 			COUNT(ehci-&gt;stats.iaa);
-		end_unlink_async(ehci);
+		end_iaa_cycle(ehci);
 	}
 
 	/* remote wakeup [4.3.1] */
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 086a7115d263..6d84ce2edc27 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -347,7 +347,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		goto done;
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
-	end_unlink_async(ehci);
+	/* Any IAA cycle that started before the suspend is now invalid */
+	end_iaa_cycle(ehci);
 	unlink_empty_async_suspended(ehci);
 	ehci_handle_start_intr_unlinks(ehci);
 	ehci_handle_intr_unlinks(ehci);
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 1b42bcb59743..15dcae8f0631 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1283,17 +1283,13 @@ static void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)
 
 static void start_iaa_cycle(struct ehci_hcd *ehci)
 {
-	/* Do nothing if an IAA cycle is already running */
-	if (ehci-&gt;iaa_in_progress)
-		return;
-	ehci-&gt;iaa_in_progress = true;
-
 	/* If the controller isn't running, we don't have to wait for it */
 	if (unlikely(ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)) {
 		end_unlink_async(ehci);
 
-	/* Otherwise start a new IAA cycle */
-	} else if (likely(ehci-&gt;rh_state == EHCI_RH_RUNNING)) {
+	/* Otherwise start a new IAA cycle if one isn't already running */
+	} else if (ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
+			!ehci-&gt;iaa_in_progress) {
 
 		/* Make sure the unlinks are all visible to the hardware */
 		wmb();
@@ -1301,17 +1297,13 @@ static void start_iaa_cycle(struct ehci_hcd *ehci)
 		ehci_writel(ehci, ehci-&gt;command | CMD_IAAD,
 				&amp;ehci-&gt;regs-&gt;command);
 		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
+		ehci-&gt;iaa_in_progress = true;
 		ehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);
 	}
 }
 
-/* the async qh for the qtds being unlinked are now gone from the HC */
-
-static void end_unlink_async(struct ehci_hcd *ehci)
+static void end_iaa_cycle(struct ehci_hcd *ehci)
 {
-	struct ehci_qh		*qh;
-	bool			early_exit;
-
 	if (ehci-&gt;has_synopsys_hc_bug)
 		ehci_writel(ehci, (u32) ehci-&gt;async-&gt;qh_dma,
 			    &amp;ehci-&gt;regs-&gt;async_next);
@@ -1319,6 +1311,16 @@ static void end_unlink_async(struct ehci_hcd *ehci)
 	/* The current IAA cycle has ended */
 	ehci-&gt;iaa_in_progress = false;
 
+	end_unlink_async(ehci);
+}
+
+/* See if the async qh for the qtds being unlinked are now gone from the HC */
+
+static void end_unlink_async(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh;
+	bool			early_exit;
+
 	if (list_empty(&amp;ehci-&gt;async_unlink))
 		return;
 	qh = list_first_entry(&amp;ehci-&gt;async_unlink, struct ehci_qh,
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 37a3e0dece84..6bea4d553ec5 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -361,7 +361,7 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 	}
 
 	ehci_dbg(ehci, "IAA watchdog: status %x cmd %x\n", status, cmd);
-	end_unlink_async(ehci);
+	end_iaa_cycle(ehci);
 }
 
 </pre>
    <div class="pagination">
        <a href='2_23.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><span>[24]</span><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_25.html'>Next&gt;&gt;</a>
    <div>
</body>
