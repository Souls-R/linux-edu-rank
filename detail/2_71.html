<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_70.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><span>[71]</span><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_72.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d5469119f0098881ab7f991990ef4f81ef13a194
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 12:13:39 2010 -0500

    [SCSI] fix refcounting bug in scsi_get_host_dev
    
    This patch (as1334) fixes a bug in scsi_get_host_dev().  It
    incorrectly calls get_device() on the new device's target.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 60b262d66b5b..f697229ae5a9 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1909,10 +1909,9 @@ struct scsi_device *scsi_get_host_dev(struct Scsi_Host *shost)
 		goto out;
 
 	sdev = scsi_alloc_sdev(starget, 0, NULL);
-	if (sdev) {
-		sdev-&gt;sdev_gendev.parent = get_device(&amp;starget-&gt;dev);
+	if (sdev)
 		sdev-&gt;borken = 0;
-	} else
+	else
 		scsi_target_reap(starget);
 	put_device(&amp;starget-&gt;dev);
  out:</pre><hr><pre>commit 75f8ee8e01a6c96652f27da40d4bdac9e2e485f0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 12 12:13:31 2010 -0500

    [SCSI] fix memory leak in scsi_report_lun_scan
    
    This patch (as1333) fixes a bug in scsi_report_lun_scan().  If a
    newly-allocated device can't be used, it should be deleted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 012f73a96880..60b262d66b5b 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -1339,8 +1339,10 @@ static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,
 		sdev = scsi_alloc_sdev(starget, 0, NULL);
 		if (!sdev)
 			return 0;
-		if (scsi_device_get(sdev))
+		if (scsi_device_get(sdev)) {
+			__scsi_remove_device(sdev);
 			return 0;
+		}
 	}
 
 	sprintf(devname, "host %d channel %d id %d",</pre><hr><pre>commit 49d0f078f494b9d81e820a13dd8093a9bfb0b6b1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 11:18:38 2010 -0500

    USB: add missing delay during remote wakeup
    
    This patch (as1330) fixes a bug in khbud's handling of remote
    wakeups.  When a device sends a remote-wakeup request, the parent hub
    (or the host controller driver, for directly attached devices) begins
    the resume sequence and notifies khubd when the sequence finishes.  At
    this point the port's SUSPEND feature is automatically turned off.
    
    However the device needs an additional 10-ms resume-recovery time
    (TRSMRCY in the USB spec).  Khubd does not wait for this delay if the
    SUSPEND feature is off, and as a result some devices fail to behave
    properly following a remote wakeup.  This patch adds the missing
    delay to the remote-wakeup path.
    
    It also extends the resume-signalling delay used by ehci-hcd and
    uhci-hcd from 20 ms (the value in the spec) to 25 ms (the value we use
    for non-remote-wakeup resumes).  The extra time appears to help some
    devices.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Cc: Rickard Bellini &lt;rickard.bellini@ericsson.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0cec6caf6e9b..b9f5fcd713e2 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -3347,6 +3347,9 @@ static void hub_events(void)
 					USB_PORT_FEAT_C_SUSPEND);
 				udev = hdev-&gt;children[i-1];
 				if (udev) {
+					/* TRSMRCY = 10 msec */
+					msleep(10);
+
 					usb_lock_device(udev);
 					ret = remote_wakeup(hdev-&gt;
 							children[i-1]);
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 5859522d6edd..1ec3857f22e6 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -787,9 +787,10 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 
 			/* start 20 msec resume signaling from this port,
 			 * and make khubd collect PORT_STAT_C_SUSPEND to
-			 * stop that signaling.
+			 * stop that signaling.  Use 5 ms extra for safety,
+			 * like usb_port_resume() does.
 			 */
-			ehci-&gt;reset_done [i] = jiffies + msecs_to_jiffies (20);
+			ehci-&gt;reset_done[i] = jiffies + msecs_to_jiffies(25);
 			ehci_dbg (ehci, "port %d remote wakeup\n", i + 1);
 			mod_timer(&amp;hcd-&gt;rh_timer, ehci-&gt;reset_done[i]);
 		}
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index 885b585360b9..8270055848ca 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -167,7 +167,7 @@ static void uhci_check_ports(struct uhci_hcd *uhci)
 				/* Port received a wakeup request */
 				set_bit(port, &amp;uhci-&gt;resuming_ports);
 				uhci-&gt;ports_timeout = jiffies +
-						msecs_to_jiffies(20);
+						msecs_to_jiffies(25);
 
 				/* Make sure we see the port again
 				 * after the resuming period is over. */</pre><hr><pre>commit cec3a53c7fe794237b582e8e77fc0e48465e65ee
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 11:18:20 2010 -0500

    USB: EHCI &amp; UHCI: fix race between root-hub suspend and port resume
    
    This patch (as1321) fixes a problem with EHCI and UHCI root-hub
    suspends: If the suspend occurs while a port is trying to resume, the
    resume doesn't finish and simply gets lost.  When remote wakeup is
    enabled, this is undesirable behavior.
    
    The patch checks first to see if any port resumes are in progress, and
    if they are then it fails the root-hub suspend with -EBUSY.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 2c6571c05f35..c75d9270c752 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -120,9 +120,26 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	del_timer_sync(&amp;ehci-&gt;watchdog);
 	del_timer_sync(&amp;ehci-&gt;iaa_watchdog);
 
-	port = HCS_N_PORTS (ehci-&gt;hcs_params);
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
+	/* Once the controller is stopped, port resumes that are already
+	 * in progress won't complete.  Hence if remote wakeup is enabled
+	 * for the root hub and any ports are in the middle of a resume or
+	 * remote wakeup, we must fail the suspend.
+	 */
+	if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup) {
+		port = HCS_N_PORTS(ehci-&gt;hcs_params);
+		while (port--) {
+			if (ehci-&gt;reset_done[port] != 0) {
+				spin_unlock_irq(&amp;ehci-&gt;lock);
+				ehci_dbg(ehci, "suspend failed because "
+						"port %d is resuming\n",
+						port + 1);
+				return -EBUSY;
+			}
+		}
+	}
+
 	/* stop schedules, clean any completed work */
 	if (HC_IS_RUNNING(hcd-&gt;state)) {
 		ehci_quiesce (ehci);
@@ -138,6 +155,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	 */
 	ehci-&gt;bus_suspended = 0;
 	ehci-&gt;owned_ports = 0;
+	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		u32 __iomem	*reg = &amp;ehci-&gt;regs-&gt;port_status [port];
 		u32		t1 = ehci_readl(ehci, reg) &amp; ~PORT_RWC_BITS;
diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 5cd0e48f67fb..99cd00fd3514 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -749,7 +749,20 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 	spin_lock_irq(&amp;uhci-&gt;lock);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		rc = -ESHUTDOWN;
-	else if (!uhci-&gt;dead)
+	else if (uhci-&gt;dead)
+		;		/* Dead controllers tell no tales */
+
+	/* Once the controller is stopped, port resumes that are already
+	 * in progress won't complete.  Hence if remote wakeup is enabled
+	 * for the root hub and any ports are in the middle of a resume or
+	 * remote wakeup, we must fail the suspend.
+	 */
+	else if (hcd-&gt;self.root_hub-&gt;do_remote_wakeup &amp;&amp;
+			uhci-&gt;resuming_ports) {
+		dev_dbg(uhci_dev(uhci), "suspend failed because a port "
+				"is resuming\n");
+		rc = -EBUSY;
+	} else
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;</pre><hr><pre>commit 1b9a38bfa6e664ff02511314f5586d711c83cc91
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jan 8 11:17:55 2010 -0500

    USB: EHCI: fix handling of unusual interrupt intervals
    
    This patch (as1320) fixes two problems related to interrupt-URB
    scheduling in ehci-hcd.
    
            URBs with an interval of 2 or 4 microframes aren't handled.
            For the time being, the patch reduces to interval to 1 uframe.
    
            URBs are constrained to have an interval no larger than 1024
            frames by usb_submit_urb().  But some EHCI controllers allow
            use of a schedule as short as 256 frames; for these
            controllers we may have to decrease the interval to the
            actual schedule length.
    
    The second problem isn't very significant since few devices expose
    interrupt endpoints with an interval larger than 256 frames.  But the
    first problem is critical; it will prevent the kernel from working
    with devices having interrupt intervals of 2 or 4 uframes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Tested-by: Glynn Farrow &lt;farrowg@sg.ibm.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index a427d3b00634..89521775c567 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -849,9 +849,10 @@ qh_make (
 				 * But interval 1 scheduling is simpler, and
 				 * includes high bandwidth.
 				 */
-				dbg ("intr period %d uframes, NYET!",
-						urb-&gt;interval);
-				goto done;
+				urb-&gt;interval = 1;
+			} else if (qh-&gt;period &gt; ehci-&gt;periodic_size) {
+				qh-&gt;period = ehci-&gt;periodic_size;
+				urb-&gt;interval = qh-&gt;period &lt;&lt; 3;
 			}
 		} else {
 			int		think_time;
@@ -874,6 +875,10 @@ qh_make (
 					usb_calc_bus_time (urb-&gt;dev-&gt;speed,
 					is_input, 0, max_packet (maxp)));
 			qh-&gt;period = urb-&gt;interval;
+			if (qh-&gt;period &gt; ehci-&gt;periodic_size) {
+				qh-&gt;period = ehci-&gt;periodic_size;
+				urb-&gt;interval = qh-&gt;period;
+			}
 		}
 	}
 </pre><hr><pre>commit a91b593edd4b3e8aa91f671b763b27b8119eb49d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 22 23:16:32 2009 -0500

    USB: fix bitmask merge error
    
    This patch adds a mask bit which was mistakenly omitted from the
    as1311 patch (usb-storage: add BAD_SENSE flag).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 5a53d4f0dd11..e9f995486ec1 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -434,7 +434,8 @@ static void adjust_quirks(struct us_data *us)
 	u16 vid = le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idVendor);
 	u16 pid = le16_to_cpu(us-&gt;pusb_dev-&gt;descriptor.idProduct);
 	unsigned f = 0;
-	unsigned int mask = (US_FL_SANE_SENSE | US_FL_FIX_CAPACITY |
+	unsigned int mask = (US_FL_SANE_SENSE | US_FL_BAD_SENSE |
+			US_FL_FIX_CAPACITY |
 			US_FL_CAPACITY_HEURISTICS | US_FL_IGNORE_DEVICE |
 			US_FL_NOT_LOCKABLE | US_FL_MAX_SECTORS_64 |
 			US_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |</pre><hr><pre>commit da307123c621b01cce147a4be313d8a754674f63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 8 15:54:44 2009 -0500

    USB: fix bugs in usb_(de)authorize_device
    
    This patch (as1315) fixes some bugs in the USB core authorization
    code:
    
            usb_deauthorize_device() should deallocate the device strings
            instead of leaking them, and it should invoke
            usb_destroy_configuration() (which does proper reference
            counting) instead of freeing the config information directly.
    
            usb_authorize_device() shouldn't change the device strings
            until it knows that the authorization will succeed, and it should
            autosuspend the device at the end (having autoresumed the
            device at the start).
    
            Because the device strings can be changed, the sysfs routines
            to display the strings must protect the string pointers by
            locking the device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Inaky Perez-Gonzalez &lt;inaky@linux.intel.com&gt;
    Acked-by: David Vrabel &lt;david.vrabel@csr.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 28738fa17afb..0cec6caf6e9b 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1849,21 +1849,23 @@ int usb_new_device(struct usb_device *udev)
  */
 int usb_deauthorize_device(struct usb_device *usb_dev)
 {
-	unsigned cnt;
 	usb_lock_device(usb_dev);
 	if (usb_dev-&gt;authorized == 0)
 		goto out_unauthorized;
+
 	usb_dev-&gt;authorized = 0;
 	usb_set_configuration(usb_dev, -1);
+
+	kfree(usb_dev-&gt;product);
 	usb_dev-&gt;product = kstrdup("n/a (unauthorized)", GFP_KERNEL);
+	kfree(usb_dev-&gt;manufacturer);
 	usb_dev-&gt;manufacturer = kstrdup("n/a (unauthorized)", GFP_KERNEL);
+	kfree(usb_dev-&gt;serial);
 	usb_dev-&gt;serial = kstrdup("n/a (unauthorized)", GFP_KERNEL);
-	kfree(usb_dev-&gt;config);
-	usb_dev-&gt;config = NULL;
-	for (cnt = 0; cnt &lt; usb_dev-&gt;descriptor.bNumConfigurations; cnt++)
-		kfree(usb_dev-&gt;rawdescriptors[cnt]);
+
+	usb_destroy_configuration(usb_dev);
 	usb_dev-&gt;descriptor.bNumConfigurations = 0;
-	kfree(usb_dev-&gt;rawdescriptors);
+
 out_unauthorized:
 	usb_unlock_device(usb_dev);
 	return 0;
@@ -1873,15 +1875,11 @@ int usb_deauthorize_device(struct usb_device *usb_dev)
 int usb_authorize_device(struct usb_device *usb_dev)
 {
 	int result = 0, c;
+
 	usb_lock_device(usb_dev);
 	if (usb_dev-&gt;authorized == 1)
 		goto out_authorized;
-	kfree(usb_dev-&gt;product);
-	usb_dev-&gt;product = NULL;
-	kfree(usb_dev-&gt;manufacturer);
-	usb_dev-&gt;manufacturer = NULL;
-	kfree(usb_dev-&gt;serial);
-	usb_dev-&gt;serial = NULL;
+
 	result = usb_autoresume_device(usb_dev);
 	if (result &lt; 0) {
 		dev_err(&amp;usb_dev-&gt;dev,
@@ -1894,6 +1892,14 @@ int usb_authorize_device(struct usb_device *usb_dev)
 			"authorization: %d\n", result);
 		goto error_device_descriptor;
 	}
+
+	kfree(usb_dev-&gt;product);
+	usb_dev-&gt;product = NULL;
+	kfree(usb_dev-&gt;manufacturer);
+	usb_dev-&gt;manufacturer = NULL;
+	kfree(usb_dev-&gt;serial);
+	usb_dev-&gt;serial = NULL;
+
 	usb_dev-&gt;authorized = 1;
 	result = usb_enumerate_device(usb_dev);
 	if (result &lt; 0)
@@ -1912,8 +1918,10 @@ int usb_authorize_device(struct usb_device *usb_dev)
 		}
 	}
 	dev_info(&amp;usb_dev-&gt;dev, "authorized to connect\n");
+
 error_enumerate:
 error_device_descriptor:
+	usb_autosuspend_device(usb_dev);
 error_autoresume:
 out_authorized:
 	usb_unlock_device(usb_dev);	// complements locktree
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 15477008b631..485edf937f25 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -82,9 +82,13 @@ static ssize_t  show_##name(struct device *dev,				\
 		struct device_attribute *attr, char *buf)		\
 {									\
 	struct usb_device *udev;					\
+	int retval;							\
 									\
 	udev = to_usb_device(dev);					\
-	return sprintf(buf, "%s\n", udev-&gt;name);			\
+	usb_lock_device(udev);						\
+	retval = sprintf(buf, "%s\n", udev-&gt;name);			\
+	usb_unlock_device(udev);					\
+	return retval;							\
 }									\
 static DEVICE_ATTR(name, S_IRUGO, show_##name, NULL);
 </pre><hr><pre>commit 8d8558d10806b7e805cb80df867ebb0a453d4765
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 8 15:50:41 2009 -0500

    USB: rename usb_configure_device
    
    This patch (as1314) renames usb_configure_device() and
    usb_configure_device_otg() in the hub driver.  Neither name is
    appropriate because these routines enumerate devices, they don't
    configure them.  That's handled by usb_choose_configuration() and
    usb_set_configuration().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 06af970e1064..28738fa17afb 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1658,12 +1658,12 @@ static inline void announce_device(struct usb_device *udev) { }
 #endif
 
 /**
- * usb_configure_device_otg - FIXME (usbcore-internal)
+ * usb_enumerate_device_otg - FIXME (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
- * Do configuration for On-The-Go devices
+ * Finish enumeration for On-The-Go devices
  */
-static int usb_configure_device_otg(struct usb_device *udev)
+static int usb_enumerate_device_otg(struct usb_device *udev)
 {
 	int err = 0;
 
@@ -1734,7 +1734,7 @@ static int usb_configure_device_otg(struct usb_device *udev)
 
 
 /**
- * usb_configure_device - Detect and probe device intfs/otg (usbcore-internal)
+ * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
  * This is only called by usb_new_device() and usb_authorize_device()
@@ -1745,7 +1745,7 @@ static int usb_configure_device_otg(struct usb_device *udev)
  * the string descriptors, as they will be errored out by the device
  * until it has been authorized.
  */
-static int usb_configure_device(struct usb_device *udev)
+static int usb_enumerate_device(struct usb_device *udev)
 {
 	int err;
 
@@ -1769,7 +1769,7 @@ static int usb_configure_device(struct usb_device *udev)
 						      udev-&gt;descriptor.iManufacturer);
 		udev-&gt;serial = usb_cache_string(udev, udev-&gt;descriptor.iSerialNumber);
 	}
-	err = usb_configure_device_otg(udev);
+	err = usb_enumerate_device_otg(udev);
 fail:
 	return err;
 }
@@ -1779,8 +1779,8 @@ static int usb_configure_device(struct usb_device *udev)
  * usb_new_device - perform initial device setup (usbcore-internal)
  * @udev: newly addressed device (in ADDRESS state)
  *
- * This is called with devices which have been enumerated, but not yet
- * configured.  The device descriptor is available, but not descriptors
+ * This is called with devices which have been detected but not fully
+ * enumerated.  The device descriptor is available, but not descriptors
  * for any device configuration.  The caller must have locked either
  * the parent hub (if udev is a normal device) or else the
  * usb_bus_list_lock (if udev is a root hub).  The parent's pointer to
@@ -1803,8 +1803,8 @@ int usb_new_device(struct usb_device *udev)
 	if (udev-&gt;parent)
 		usb_autoresume_device(udev-&gt;parent);
 
-	usb_detect_quirks(udev);		/* Determine quirks */
-	err = usb_configure_device(udev);	/* detect &amp; probe dev/intfs */
+	usb_detect_quirks(udev);
+	err = usb_enumerate_device(udev);	/* Read descriptors */
 	if (err &lt; 0)
 		goto fail;
 	dev_dbg(&amp;udev-&gt;dev, "udev %d, busnum %d, minor = %d\n",
@@ -1895,9 +1895,9 @@ int usb_authorize_device(struct usb_device *usb_dev)
 		goto error_device_descriptor;
 	}
 	usb_dev-&gt;authorized = 1;
-	result = usb_configure_device(usb_dev);
+	result = usb_enumerate_device(usb_dev);
 	if (result &lt; 0)
-		goto error_configure;
+		goto error_enumerate;
 	/* Choose and set the configuration.  This registers the interfaces
 	 * with the driver core and lets interface drivers bind to them.
 	 */
@@ -1912,7 +1912,7 @@ int usb_authorize_device(struct usb_device *usb_dev)
 		}
 	}
 	dev_info(&amp;usb_dev-&gt;dev, "authorized to connect\n");
-error_configure:
+error_enumerate:
 error_device_descriptor:
 error_autoresume:
 out_authorized:</pre><hr><pre>commit baf67741bf52b985e318bed3c4acadcda5351e08
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 8 15:49:48 2009 -0500

    USB: power management documentation update
    
    This patch (as1313) updates the documentation concerning USB power
    management.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/Documentation/ABI/testing/sysfs-bus-usb b/Documentation/ABI/testing/sysfs-bus-usb
index deb6b489e4e5..a07c0f366f91 100644
--- a/Documentation/ABI/testing/sysfs-bus-usb
+++ b/Documentation/ABI/testing/sysfs-bus-usb
@@ -21,25 +21,27 @@ Contact:	Alan Stern &lt;stern@rowland.harvard.edu&gt;
 Description:
 		Each USB device directory will contain a file named
 		power/level.  This file holds a power-level setting for
-		the device, one of "on", "auto", or "suspend".
+		the device, either "on" or "auto".
 
 		"on" means that the device is not allowed to autosuspend,
 		although normal suspends for system sleep will still
 		be honored.  "auto" means the device will autosuspend
 		and autoresume in the usual manner, according to the
-		capabilities of its driver.  "suspend" means the device
-		is forced into a suspended state and it will not autoresume
-		in response to I/O requests.  However remote-wakeup requests
-		from the device may still be enabled (the remote-wakeup
-		setting is controlled separately by the power/wakeup
-		attribute).
+		capabilities of its driver.
 
 		During normal use, devices should be left in the "auto"
-		level.  The other levels are meant for administrative uses.
+		level.  The "on" level is meant for administrative uses.
 		If you want to suspend a device immediately but leave it
 		free to wake up in response to I/O requests, you should
 		write "0" to power/autosuspend.
 
+		Device not capable of proper suspend and resume should be
+		left in the "on" level.  Although the USB spec requires
+		devices to support suspend/resume, many of them do not.
+		In fact so many don't that by default, the USB core
+		initializes all non-hub devices in the "on" level.  Some
+		drivers may change this setting when they are bound.
+
 What:		/sys/bus/usb/devices/.../power/persist
 Date:		May 2007
 KernelVersion:	2.6.23
diff --git a/Documentation/usb/power-management.txt b/Documentation/usb/power-management.txt
index c7c1dc2f8017..3bf6818c8cf5 100644
--- a/Documentation/usb/power-management.txt
+++ b/Documentation/usb/power-management.txt
@@ -71,12 +71,10 @@ being accessed through sysfs, then it definitely is idle.
 	Forms of dynamic PM
 	-------------------
 
-Dynamic suspends can occur in two ways: manual and automatic.
-"Manual" means that the user has told the kernel to suspend a device,
-whereas "automatic" means that the kernel has decided all by itself to
-suspend a device.  Automatic suspend is called "autosuspend" for
-short.  In general, a device won't be autosuspended unless it has been
-idle for some minimum period of time, the so-called idle-delay time.
+Dynamic suspends occur when the kernel decides to suspend an idle
+device.  This is called "autosuspend" for short.  In general, a device
+won't be autosuspended unless it has been idle for some minimum period
+of time, the so-called idle-delay time.
 
 Of course, nothing the kernel does on its own initiative should
 prevent the computer or its devices from working properly.  If a
@@ -96,10 +94,11 @@ idle.
 We can categorize power management events in two broad classes:
 external and internal.  External events are those triggered by some
 agent outside the USB stack: system suspend/resume (triggered by
-userspace), manual dynamic suspend/resume (also triggered by
-userspace), and remote wakeup (triggered by the device).  Internal
-events are those triggered within the USB stack: autosuspend and
-autoresume.
+userspace), manual dynamic resume (also triggered by userspace), and
+remote wakeup (triggered by the device).  Internal events are those
+triggered within the USB stack: autosuspend and autoresume.  Note that
+all dynamic suspend events are internal; external agents are not
+allowed to issue dynamic suspends.
 
 
 	The user interface for dynamic PM
@@ -145,9 +144,9 @@ relevant attribute files are: wakeup, level, and autosuspend.
 		number of seconds the device should remain idle before
 		the kernel will autosuspend it (the idle-delay time).
 		The default is 2.  0 means to autosuspend as soon as
-		the device becomes idle, and -1 means never to
-		autosuspend.  You can write a number to the file to
-		change the autosuspend idle-delay time.
+		the device becomes idle, and negative values mean
+		never to autosuspend.  You can write a number to the
+		file to change the autosuspend idle-delay time.
 
 Writing "-1" to power/autosuspend and writing "on" to power/level do
 essentially the same thing -- they both prevent the device from being
@@ -377,9 +376,9 @@ the device hasn't been idle for long enough, a delayed workqueue
 routine is automatically set up to carry out the operation when the
 autosuspend idle-delay has expired.
 
-Autoresume attempts also can fail.  This will happen if power/level is
-set to "suspend" or if the device doesn't manage to resume properly.
-Unlike autosuspend, there's no delay for an autoresume.
+Autoresume attempts also can fail, although failure would mean that
+the device is no longer present or operating properly.  Unlike
+autosuspend, there's no delay for an autoresume.
 
 
 	Other parts of the driver interface
@@ -527,13 +526,3 @@ succeed, it may still remain active and thus cause the system to
 resume as soon as the system suspend is complete.  Or the remote
 wakeup may fail and get lost.  Which outcome occurs depends on timing
 and on the hardware and firmware design.
-
-More interestingly, a device might undergo a manual resume or
-autoresume during system suspend.  With current kernels this shouldn't
-happen, because manual resumes must be initiated by userspace and
-autoresumes happen in response to I/O requests, but all user processes
-and I/O should be quiescent during a system suspend -- thanks to the
-freezer.  However there are plans to do away with the freezer, which
-would mean these things would become possible.  If and when this comes
-about, the USB core will carefully arrange matters so that either type
-of resume will block until the entire system has resumed.</pre><hr><pre>commit f1212ae1332b95fe3bafa7b5c063dd8e473247cf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Dec 22 20:43:40 2009 +0100

    PM: Runtime PM documentation update
    
    This patch (as1318) updates the runtime PM documentation, adding a
    section discussing the interaction between runtime PM and system sleep.
    
    [rjw: Rebased and made it agree with the other updates better.]
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/Documentation/power/runtime_pm.txt b/Documentation/power/runtime_pm.txt
index 7b5ab2701247..356fd86f4ea8 100644
--- a/Documentation/power/runtime_pm.txt
+++ b/Documentation/power/runtime_pm.txt
@@ -381,3 +381,53 @@ incremented by the core before executing -&gt;probe() and -&gt;remove().  Still, it
 may be desirable to suspend the device as soon as -&gt;probe() or -&gt;remove() has
 finished, so the PM core uses pm_runtime_idle_sync() to invoke the
 subsystem-level idle callback for the device at that time.
+
+6. Run-time PM and System Sleep
+
+Run-time PM and system sleep (i.e., system suspend and hibernation, also known
+as suspend-to-RAM and suspend-to-disk) interact with each other in a couple of
+ways.  If a device is active when a system sleep starts, everything is
+straightforward.  But what should happen if the device is already suspended?
+
+The device may have different wake-up settings for run-time PM and system sleep.
+For example, remote wake-up may be enabled for run-time suspend but disallowed
+for system sleep (device_may_wakeup(dev) returns 'false').  When this happens,
+the subsystem-level system suspend callback is responsible for changing the
+device's wake-up setting (it may leave that to the device driver's system
+suspend routine).  It may be necessary to resume the device and suspend it again
+in order to do so.  The same is true if the driver uses different power levels
+or other settings for run-time suspend and system sleep.
+
+During system resume, devices generally should be brought back to full power,
+even if they were suspended before the system sleep began.  There are several
+reasons for this, including:
+
+  * The device might need to switch power levels, wake-up settings, etc.
+
+  * Remote wake-up events might have been lost by the firmware.
+
+  * The device's children may need the device to be at full power in order
+    to resume themselves.
+
+  * The driver's idea of the device state may not agree with the device's
+    physical state.  This can happen during resume from hibernation.
+
+  * The device might need to be reset.
+
+  * Even though the device was suspended, if its usage counter was &gt; 0 then most
+    likely it would need a run-time resume in the near future anyway.
+
+  * Always going back to full power is simplest.
+
+If the device was suspended before the sleep began, then its run-time PM status
+will have to be updated to reflect the actual post-system sleep status.  The way
+to do this is:
+
+	pm_runtime_disable(dev);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+
+The PM core always increments the run-time usage counter before calling the
+-&gt;prepare() callback and decrements it after calling the -&gt;complete() callback.
+Hence disabling run-time PM temporarily like this will not cause any run-time
+suspend callbacks to be lost.</pre>
    <div class="pagination">
        <a href='2_70.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><span>[71]</span><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_72.html'>Next&gt;&gt;</a>
    <div>
</body>
