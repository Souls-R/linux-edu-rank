<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of New South Wales</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of New South Wales</h1>
    <div class="pagination">
        <a href='8_15.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><a href='8_5.html'>5</a><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><span>[16]</span><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_17.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 471e7a44848f467c9b83adc3463d019d2fa8817f
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Thu Aug 16 15:03:07 2007 +1000

    [IA64] Enable early console for Ski simulator
    
    When using Ski to debug early startup, it's a bit of a pain not to
    have printk.
    
    This patch enables the simulated console very early.
    It may be worth conditionalising on the command line... but this is
    enough for now.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: Tony Luck &lt;tony.luck@intel.com&gt;

diff --git a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c
index cd9a37a552c3..407efea04bf5 100644
--- a/arch/ia64/kernel/setup.c
+++ b/arch/ia64/kernel/setup.c
@@ -389,6 +389,13 @@ early_console_setup (char *cmdline)
 	if (!efi_setup_pcdp_console(cmdline))
 		earlycons++;
 #endif
+#ifdef CONFIG_HP_SIMSERIAL_CONSOLE
+	{
+		extern struct console hpsim_cons;
+		register_console(&amp;hpsim_cons);
+		earlycons++;
+	}
+#endif
 
 	return (earlycons) ? 0 : -1;
 }</pre><hr><pre>commit cd5bfea278987ebfe60f3ff92a01696b17c4f978
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Fri Aug 10 13:01:10 2007 -0700

    fix compilation with gcc 4.2
    
    gcc-4.2 is a lot more picky about its symbol handling.  EXPORT_SYMBOL no
    longer works on symbols that are undefined or defined with static scope.
    
    For example, with CONFIG_PROFILE off, I see:
    
      kernel/profile.c:206: error: __ksymtab_profile_event_unregister causes a section type conflict
      kernel/profile.c:205: error: __ksymtab_profile_event_register causes a section type conflict
    
    This patch moves the EXPORTs inside the #ifdef CONFIG_PROFILE, so we
    only try to export symbols that are defined.
    
    Also, in kernel/kprobes.c there's an EXPORT_SYMBOL_GPL() for
    jprobes_return, which if CONFIG_JPROBES is undefined is a static
    inline and gives the same error.
    
    And in drivers/acpi/resources/rsxface.c, there's an
    ACPI_EXPORT_SYMBOPL() for a static symbol. If it's static, it's not
    accessible from outside the compilation unit, so should bot be exported.
    
    These three changes allow building a zx1_defconfig kernel with gcc 4.2
    on IA64.
    
    [akpm@linux-foundation.org: export jpobe_return properly]
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Cc: Prasanna S Panchamukhi &lt;prasanna@in.ibm.com&gt;
    Cc: Ananth N Mavinakayanahalli &lt;ananth@in.ibm.com&gt;
    Cc: Anil S Keshavamurthy &lt;anil.s.keshavamurthy@intel.com&gt;
    Cc: "Luck, Tony" &lt;tony.luck@intel.com&gt;
    Cc: Len Brown &lt;lenb@kernel.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/drivers/acpi/resources/rsxface.c b/drivers/acpi/resources/rsxface.c
index f63813a358c5..4c3fd4cdaf73 100644
--- a/drivers/acpi/resources/rsxface.c
+++ b/drivers/acpi/resources/rsxface.c
@@ -474,8 +474,6 @@ acpi_rs_match_vendor_resource(struct acpi_resource *resource, void *context)
 	return (AE_CTRL_TERMINATE);
 }
 
-ACPI_EXPORT_SYMBOL(acpi_rs_match_vendor_resource)
-
 /*******************************************************************************
  *
  * FUNCTION:    acpi_walk_resources
diff --git a/kernel/kprobes.c b/kernel/kprobes.c
index 3e9f513a728d..4b8a4493c541 100644
--- a/kernel/kprobes.c
+++ b/kernel/kprobes.c
@@ -1063,6 +1063,11 @@ EXPORT_SYMBOL_GPL(register_kprobe);
 EXPORT_SYMBOL_GPL(unregister_kprobe);
 EXPORT_SYMBOL_GPL(register_jprobe);
 EXPORT_SYMBOL_GPL(unregister_jprobe);
+#ifdef CONFIG_KPROBES
 EXPORT_SYMBOL_GPL(jprobe_return);
+#endif
+
+#ifdef CONFIG_KPROBES
 EXPORT_SYMBOL_GPL(register_kretprobe);
 EXPORT_SYMBOL_GPL(unregister_kretprobe);
+#endif
diff --git a/kernel/profile.c b/kernel/profile.c
index 5b20fe977bed..cb1e37d2dac3 100644
--- a/kernel/profile.c
+++ b/kernel/profile.c
@@ -199,11 +199,11 @@ EXPORT_SYMBOL_GPL(register_timer_hook);
 EXPORT_SYMBOL_GPL(unregister_timer_hook);
 EXPORT_SYMBOL_GPL(task_handoff_register);
 EXPORT_SYMBOL_GPL(task_handoff_unregister);
+EXPORT_SYMBOL_GPL(profile_event_register);
+EXPORT_SYMBOL_GPL(profile_event_unregister);
 
 #endif /* CONFIG_PROFILING */
 
-EXPORT_SYMBOL_GPL(profile_event_register);
-EXPORT_SYMBOL_GPL(profile_event_unregister);
 
 #ifdef CONFIG_SMP
 /*</pre><hr><pre>commit c7f570a5eca59575572ee231390df727df207bda
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Tue Dec 5 12:25:31 2006 +1100

    [IA64] Fix pci.c kernel compilation breakage.
    
    The recent change to convert the is_enabled flag in the PCI device to an
    atomic count broke the IA64 compilation.
    
    As pcibios_disable_device is only ever called if the reference count
    is zero, convert the if to a BUG_ON.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: Tony Luck &lt;tony.luck@intel.com&gt;

diff --git a/arch/ia64/pci/pci.c b/arch/ia64/pci/pci.c
index f4edfbf27134..eb92cef9cd0d 100644
--- a/arch/ia64/pci/pci.c
+++ b/arch/ia64/pci/pci.c
@@ -564,8 +564,8 @@ pcibios_enable_device (struct pci_dev *dev, int mask)
 void
 pcibios_disable_device (struct pci_dev *dev)
 {
-	if (dev-&gt;is_enabled)
-		acpi_pci_irq_disable(dev);
+	BUG_ON(atomic_read(&amp;dev-&gt;enable_cnt));
+	acpi_pci_irq_disable(dev);
 }
 
 void</pre><hr><pre>commit 23219c134865d524357e9bb90e5badb422ac8fff
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Tue Jul 25 20:39:14 2006 +1000

    USB: Patch for rtl8150 to fix unplug problems
    
    The RTL8150 driver currently crashes the kernel if the USB lead is unplugged
    while the device is active.  The attached patch adds error handling to
    tell the network layer that the device has gone away when the device is
    unplugged.  With this patch, the device can be plugged and unplugged
    to one's hearts' content, without crashing anything.
    
    Oh, I've also added rudimentary suspend and resume methods.
    
    Signed-off-by: Peter Chubb &lt;peter@gelato.unsw.edu.au&gt;
    Acked-by: Petko Manolov &lt;petkan@nucleusys.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/net/rtl8150.c b/drivers/usb/net/rtl8150.c
index e5e6e4f3ef87..bd09232ce13c 100644
--- a/drivers/usb/net/rtl8150.c
+++ b/drivers/usb/net/rtl8150.c
@@ -175,6 +175,8 @@ static inline struct sk_buff *pull_skb(rtl8150_t *);
 static void rtl8150_disconnect(struct usb_interface *intf);
 static int rtl8150_probe(struct usb_interface *intf,
 			   const struct usb_device_id *id);
+static int rtl8150_suspend(struct usb_interface *intf, pm_message_t message);
+static int rtl8150_resume(struct usb_interface *intf);
 
 static const char driver_name [] = "rtl8150";
 
@@ -183,6 +185,8 @@ static struct usb_driver rtl8150_driver = {
 	.probe =	rtl8150_probe,
 	.disconnect =	rtl8150_disconnect,
 	.id_table =	rtl8150_table,
+	.suspend =	rtl8150_suspend,
+	.resume =	rtl8150_resume
 };
 
 /*
@@ -238,9 +242,11 @@ static int async_set_registers(rtl8150_t * dev, u16 indx, u16 size)
 	usb_fill_control_urb(dev-&gt;ctrl_urb, dev-&gt;udev,
 			 usb_sndctrlpipe(dev-&gt;udev, 0), (char *) &amp;dev-&gt;dr,
 			 &amp;dev-&gt;rx_creg, size, ctrl_callback, dev);
-	if ((ret = usb_submit_urb(dev-&gt;ctrl_urb, GFP_ATOMIC)))
+	if ((ret = usb_submit_urb(dev-&gt;ctrl_urb, GFP_ATOMIC))) {
+		if (ret == -ENODEV)
+			netif_device_detach(dev-&gt;netdev);
 		err("control request submission failed: %d", ret);
-	else
+	} else
 		set_bit(RX_REG_SET, &amp;dev-&gt;flags);
 
 	return ret;
@@ -416,6 +422,7 @@ static void read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 	struct sk_buff *skb;
 	struct net_device *netdev;
 	u16 rx_stat;
+	int status;
 
 	dev = urb-&gt;context;
 	if (!dev)
@@ -465,7 +472,10 @@ static void read_bulk_callback(struct urb *urb, struct pt_regs *regs)
 goon:
 	usb_fill_bulk_urb(dev-&gt;rx_urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 1),
 		      dev-&gt;rx_skb-&gt;data, RTL8150_MTU, read_bulk_callback, dev);
-	if (usb_submit_urb(dev-&gt;rx_urb, GFP_ATOMIC)) {
+	status = usb_submit_urb(dev-&gt;rx_urb, GFP_ATOMIC);
+	if (status == -ENODEV)
+		netif_device_detach(dev-&gt;netdev);
+	else if (status) {
 		set_bit(RX_URB_FAIL, &amp;dev-&gt;flags);
 		goto resched;
 	} else {
@@ -481,6 +491,7 @@ static void rx_fixup(unsigned long data)
 {
 	rtl8150_t *dev;
 	struct sk_buff *skb;
+	int status;
 
 	dev = (rtl8150_t *)data;
 
@@ -499,10 +510,13 @@ static void rx_fixup(unsigned long data)
 	usb_fill_bulk_urb(dev-&gt;rx_urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 1),
 		      dev-&gt;rx_skb-&gt;data, RTL8150_MTU, read_bulk_callback, dev);
 try_again:
-	if (usb_submit_urb(dev-&gt;rx_urb, GFP_ATOMIC)) {
+	status = usb_submit_urb(dev-&gt;rx_urb, GFP_ATOMIC);
+	if (status == -ENODEV) {
+		netif_device_detach(dev-&gt;netdev);
+	} else if (status) {
 		set_bit(RX_URB_FAIL, &amp;dev-&gt;flags);
 		goto tlsched;
-	 } else {
+	} else {
 		clear_bit(RX_URB_FAIL, &amp;dev-&gt;flags);
 	}
 
@@ -574,12 +588,43 @@ static void intr_callback(struct urb *urb, struct pt_regs *regs)
 
 resubmit:
 	status = usb_submit_urb (urb, SLAB_ATOMIC);
-	if (status)
+	if (status == -ENODEV)
+		netif_device_detach(dev-&gt;netdev);
+	else if (status)
 		err ("can't resubmit intr, %s-%s/input0, status %d",
 				dev-&gt;udev-&gt;bus-&gt;bus_name,
 				dev-&gt;udev-&gt;devpath, status);
 }
 
+static int rtl8150_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	rtl8150_t *dev = usb_get_intfdata(intf);
+
+	netif_device_detach(dev-&gt;netdev);
+
+	if (netif_running(dev-&gt;netdev)) {
+		usb_kill_urb(dev-&gt;rx_urb);
+		usb_kill_urb(dev-&gt;intr_urb);
+	}
+	return 0;
+}
+
+static int rtl8150_resume(struct usb_interface *intf)
+{
+	rtl8150_t *dev = usb_get_intfdata(intf);
+
+	netif_device_attach(dev-&gt;netdev);
+	if (netif_running(dev-&gt;netdev)) {
+		dev-&gt;rx_urb-&gt;status = 0;
+		dev-&gt;rx_urb-&gt;actual_length = 0;
+		read_bulk_callback(dev-&gt;rx_urb, NULL);
+
+		dev-&gt;intr_urb-&gt;status = 0;
+		dev-&gt;intr_urb-&gt;actual_length = 0;
+		intr_callback(dev-&gt;intr_urb, NULL);
+	}
+	return 0;
+}
 
 /*
 **
@@ -690,9 +735,14 @@ static int rtl8150_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 	usb_fill_bulk_urb(dev-&gt;tx_urb, dev-&gt;udev, usb_sndbulkpipe(dev-&gt;udev, 2),
 		      skb-&gt;data, count, write_bulk_callback, dev);
 	if ((res = usb_submit_urb(dev-&gt;tx_urb, GFP_ATOMIC))) {
-		warn("failed tx_urb %d\n", res);
-		dev-&gt;stats.tx_errors++;
-		netif_start_queue(netdev);
+		/* Can we get/handle EPIPE here? */
+		if (res == -ENODEV)
+			netif_device_detach(dev-&gt;netdev);
+		else {
+			warn("failed tx_urb %d\n", res);
+			dev-&gt;stats.tx_errors++;
+			netif_start_queue(netdev);
+		}
 	} else {
 		dev-&gt;stats.tx_packets++;
 		dev-&gt;stats.tx_bytes += skb-&gt;len;
@@ -729,16 +779,25 @@ static int rtl8150_open(struct net_device *netdev)
 	
 	usb_fill_bulk_urb(dev-&gt;rx_urb, dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, 1),
 		      dev-&gt;rx_skb-&gt;data, RTL8150_MTU, read_bulk_callback, dev);
-	if ((res = usb_submit_urb(dev-&gt;rx_urb, GFP_KERNEL)))
+	if ((res = usb_submit_urb(dev-&gt;rx_urb, GFP_KERNEL))) {
+		if (res == -ENODEV)
+			netif_device_detach(dev-&gt;netdev);
 		warn("%s: rx_urb submit failed: %d", __FUNCTION__, res);
+		return res;
+	}
 	usb_fill_int_urb(dev-&gt;intr_urb, dev-&gt;udev, usb_rcvintpipe(dev-&gt;udev, 3),
 		     dev-&gt;intr_buff, INTBUFSIZE, intr_callback,
 		     dev, dev-&gt;intr_interval);
-	if ((res = usb_submit_urb(dev-&gt;intr_urb, GFP_KERNEL)))
+	if ((res = usb_submit_urb(dev-&gt;intr_urb, GFP_KERNEL))) {
+		if (res == -ENODEV)
+			netif_device_detach(dev-&gt;netdev);
 		warn("%s: intr_urb submit failed: %d", __FUNCTION__, res);
-	netif_start_queue(netdev);
+		usb_kill_urb(dev-&gt;rx_urb);
+		return res;
+	}
 	enable_net_traffic(dev);
 	set_carrier(netdev);
+	netif_start_queue(netdev);
 
 	return res;
 }</pre><hr><pre>commit bdcfd9e349eff9398a1d85eaa517294f493bb3c8
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Tue May 2 18:29:34 2006 +0100

    [PATCH] USB: shuttle_usbat: Hardcode detection of HP CDRW devices
    
    Use USB vendor and product IDs to determine whether the attached
    device is a CDROM or a Flash device.  Daniel Drake says that the
    *same* vendor and product IDs for non-HP vendor ID could be either
    flash or cdrom, so try to probe for them.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: Daniel Drake &lt;dsd@gentoo.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/shuttle_usbat.c b/drivers/usb/storage/shuttle_usbat.c
index 92095b858eb7..8fcec01dc622 100644
--- a/drivers/usb/storage/shuttle_usbat.c
+++ b/drivers/usb/storage/shuttle_usbat.c
@@ -893,22 +893,28 @@ static int usbat_identify_device(struct us_data *us,
  * Set the transport function based on the device type
  */
 static int usbat_set_transport(struct us_data *us,
-			       struct usbat_info *info)
+			       struct usbat_info *info,
+			       int devicetype)
 {
-	int rc;
 
-	if (!info-&gt;devicetype) {
-		rc = usbat_identify_device(us, info);
-		if (rc != USB_STOR_TRANSPORT_GOOD) {
-			US_DEBUGP("usbat_set_transport: Could not identify device\n");
-			return 1;
-		}
-	}
+	if (!info-&gt;devicetype)
+		info-&gt;devicetype = devicetype;
 
-	if (usbat_get_device_type(us) == USBAT_DEV_HP8200)
+	if (!info-&gt;devicetype)
+		usbat_identify_device(us, info);
+
+	switch (info-&gt;devicetype) {
+	default:
+		return USB_STOR_TRANSPORT_ERROR;
+
+	case  USBAT_DEV_HP8200:
 		us-&gt;transport = usbat_hp8200e_transport;
-	else if (usbat_get_device_type(us) == USBAT_DEV_FLASH)
+		break;
+
+	case USBAT_DEV_FLASH:
 		us-&gt;transport = usbat_flash_transport;
+		break;
+	}
 
 	return 0;
 }
@@ -1316,7 +1322,7 @@ static int usbat_select_and_test_registers(struct us_data *us)
 /*
  * Initialize the USBAT processor and the storage device
  */
-int init_usbat(struct us_data *us)
+static int init_usbat(struct us_data *us, int devicetype)
 {
 	int rc;
 	struct usbat_info *info;
@@ -1398,7 +1404,7 @@ int init_usbat(struct us_data *us)
 	US_DEBUGP("INIT 9\n");
 
 	/* At this point, we need to detect which device we are using */
-	if (usbat_set_transport(us, info))
+	if (usbat_set_transport(us, info, devicetype))
 		return USB_STOR_TRANSPORT_ERROR;
 
 	US_DEBUGP("INIT 10\n");
@@ -1701,6 +1707,22 @@ static int usbat_flash_transport(struct scsi_cmnd * srb, struct us_data *us)
 	return USB_STOR_TRANSPORT_FAILED;
 }
 
+int init_usbat_cd(struct us_data *us)
+{
+	return init_usbat(us, USBAT_DEV_HP8200);
+}
+
+
+int init_usbat_flash(struct us_data *us)
+{
+	return init_usbat(us, USBAT_DEV_FLASH);
+}
+
+int init_usbat_probe(struct us_data *us)
+{
+	return init_usbat(us, 0);
+}
+
 /*
  * Default transport function. Attempts to detect which transport function
  * should be called, makes it the new default, and calls it.
@@ -1714,9 +1736,8 @@ int usbat_transport(struct scsi_cmnd *srb, struct us_data *us)
 {
 	struct usbat_info *info = (struct usbat_info*) (us-&gt;extra);
 
-	if (usbat_set_transport(us, info))
+	if (usbat_set_transport(us, info, 0))
 		return USB_STOR_TRANSPORT_ERROR;
 
 	return us-&gt;transport(srb, us);	
 }
-
diff --git a/drivers/usb/storage/shuttle_usbat.h b/drivers/usb/storage/shuttle_usbat.h
index 25e7d8b340b8..3ddf143a1dec 100644
--- a/drivers/usb/storage/shuttle_usbat.h
+++ b/drivers/usb/storage/shuttle_usbat.h
@@ -106,7 +106,9 @@
 #define USBAT_FEAT_ET2	0x01
 
 extern int usbat_transport(struct scsi_cmnd *srb, struct us_data *us);
-extern int init_usbat(struct us_data *us);
+extern int init_usbat_cd(struct us_data *us);
+extern int init_usbat_flash(struct us_data *us);
+extern int init_usbat_probe(struct us_data *us);
 
 struct usbat_info {
 	int devicetype;
diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index aec5ea8682d5..f24fa12eaedf 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -78,12 +78,12 @@ UNUSUAL_DEV(  0x03f0, 0x0107, 0x0200, 0x0200,
 UNUSUAL_DEV(  0x03f0, 0x0207, 0x0001, 0x0001, 
 		"HP",
 		"CD-Writer+ 8200e",
-		US_SC_8070, US_PR_USBAT, init_usbat, 0),
+		US_SC_8070, US_PR_USBAT, init_usbat_cd, 0),
 
 UNUSUAL_DEV(  0x03f0, 0x0307, 0x0001, 0x0001, 
 		"HP",
 		"CD-Writer+ CD-4e",
-		US_SC_8070, US_PR_USBAT, init_usbat, 0),
+		US_SC_8070, US_PR_USBAT, init_usbat_cd, 0),
 #endif
 
 /* Reported by Sebastian Kapfer &lt;sebastian_kapfer@gmx.net&gt;
@@ -393,7 +393,7 @@ UNUSUAL_DEV(  0x04fc, 0x80c2, 0x0100, 0x0100,
 UNUSUAL_DEV(  0x04e6, 0x1010, 0x0000, 0x9999,
 		"Shuttle/SCM",
 		"USBAT-02",
-		US_SC_SCSI, US_PR_USBAT, init_usbat,
+		US_SC_SCSI, US_PR_USBAT, init_usbat_probe,
 		US_FL_SINGLE_LUN),
 #endif
 
@@ -797,7 +797,7 @@ UNUSUAL_DEV(  0x0781, 0x0002, 0x0009, 0x0009,
 UNUSUAL_DEV(  0x0781, 0x0005, 0x0005, 0x0005,
 		"Sandisk",
 		"ImageMate SDDR-05b",
-		US_SC_SCSI, US_PR_USBAT, init_usbat,
+		US_SC_SCSI, US_PR_USBAT, init_usbat_flash,
 		US_FL_SINGLE_LUN ),
 #endif
 </pre><hr><pre>commit 141804d401631f0384feabfa5fc3e2ce1321c0f0
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Tue May 2 18:30:12 2006 +0100

    [PATCH] USB: shuttle_usbat: Fix handling of scatter-gather buffers
    
    I've worked out what's going wrong.  The scsi layer is now much
    more likely to pass down scatterlists instead of plain buffers.  So
    you have to make sure that they're handled correctly.  In one of the
    changes along the way, usbat_write_block and friends stopped obeying
    the srb-&gt;use_sg flag.
    
    Anyway, with the appended patch, and the one I'm putting in the next email, it
    all seems to work for the HP cd4e.  Of course, someone's going to have
    to test it with the flash drives as well....
    
    This patch teaches the usbat_{read,write}_block functions to
    obey the use_sg flag in the scsi-request.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: Daniel Drake &lt;dsd@gentoo.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/shuttle_usbat.c b/drivers/usb/storage/shuttle_usbat.c
index f2bc5c9e23d5..92095b858eb7 100644
--- a/drivers/usb/storage/shuttle_usbat.c
+++ b/drivers/usb/storage/shuttle_usbat.c
@@ -131,28 +131,30 @@ static int usbat_write(struct us_data *us,
  * Convenience function to perform a bulk read
  */
 static int usbat_bulk_read(struct us_data *us,
-							 unsigned char *data,
-							 unsigned int len)
+			   unsigned char *data,
+			   unsigned int len,
+			   int use_sg)
 {
 	if (len == 0)
 		return USB_STOR_XFER_GOOD;
 
 	US_DEBUGP("usbat_bulk_read: len = %d\n", len);
-	return usb_stor_bulk_transfer_buf(us, us-&gt;recv_bulk_pipe, data, len, NULL);
+	return usb_stor_bulk_transfer_sg(us, us-&gt;recv_bulk_pipe, data, len, use_sg, NULL);
 }
 
 /*
  * Convenience function to perform a bulk write
  */
 static int usbat_bulk_write(struct us_data *us,
-							unsigned char *data,
-							unsigned int len)
+			    unsigned char *data,
+			    unsigned int len,
+			    int use_sg)
 {
 	if (len == 0)
 		return USB_STOR_XFER_GOOD;
 
 	US_DEBUGP("usbat_bulk_write:  len = %d\n", len);
-	return usb_stor_bulk_transfer_buf(us, us-&gt;send_bulk_pipe, data, len, NULL);
+	return usb_stor_bulk_transfer_sg(us, us-&gt;send_bulk_pipe, data, len, use_sg, NULL);
 }
 
 /*
@@ -317,7 +319,8 @@ static int usbat_wait_not_busy(struct us_data *us, int minutes)
  */
 static int usbat_read_block(struct us_data *us,
 			    unsigned char *content,
-			    unsigned short len)
+			    unsigned short len,
+			    int use_sg)
 {
 	int result;
 	unsigned char *command = us-&gt;iobuf;
@@ -338,7 +341,7 @@ static int usbat_read_block(struct us_data *us,
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
-	result = usbat_bulk_read(us, content, len);
+	result = usbat_bulk_read(us, content, len, use_sg);
 	return (result == USB_STOR_XFER_GOOD ?
 			USB_STOR_TRANSPORT_GOOD : USB_STOR_TRANSPORT_ERROR);
 }
@@ -350,7 +353,8 @@ static int usbat_write_block(struct us_data *us,
 			     unsigned char access,
 			     unsigned char *content,
 			     unsigned short len,
-			     int minutes)
+			     int minutes,
+			     int use_sg)
 {
 	int result;
 	unsigned char *command = us-&gt;iobuf;
@@ -372,7 +376,7 @@ static int usbat_write_block(struct us_data *us,
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
-	result = usbat_bulk_write(us, content, len);
+	result = usbat_bulk_write(us, content, len, use_sg);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
@@ -465,7 +469,7 @@ static int usbat_hp8200e_rw_block_test(struct us_data *us,
 				data[1+(j&lt;&lt;1)] = data_out[j];
 			}
 
-			result = usbat_bulk_write(us, data, num_registers*2);
+			result = usbat_bulk_write(us, data, num_registers*2, 0);
 			if (result != USB_STOR_XFER_GOOD)
 				return USB_STOR_TRANSPORT_ERROR;
 
@@ -583,7 +587,7 @@ static int usbat_multiple_write(struct us_data *us,
 	}
 
 	/* Send the data */
-	result = usbat_bulk_write(us, data, num_registers*2);
+	result = usbat_bulk_write(us, data, num_registers*2, 0);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_ERROR;
 
@@ -606,8 +610,9 @@ static int usbat_multiple_write(struct us_data *us,
  * other related details) are defined beforehand with _set_shuttle_features().
  */
 static int usbat_read_blocks(struct us_data *us,
-							 unsigned char *buffer,
-							 int len)
+			     unsigned char *buffer,
+			     int len,
+			     int use_sg)
 {
 	int result;
 	unsigned char *command = us-&gt;iobuf;
@@ -627,7 +632,7 @@ static int usbat_read_blocks(struct us_data *us,
 		return USB_STOR_TRANSPORT_FAILED;
 	
 	/* Read the blocks we just asked for */
-	result = usbat_bulk_read(us, buffer, len);
+	result = usbat_bulk_read(us, buffer, len, use_sg);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_FAILED;
 
@@ -648,7 +653,8 @@ static int usbat_read_blocks(struct us_data *us,
  */
 static int usbat_write_blocks(struct us_data *us,
 							  unsigned char *buffer,
-							  int len)
+			      int len,
+			      int use_sg)
 {
 	int result;
 	unsigned char *command = us-&gt;iobuf;
@@ -668,7 +674,7 @@ static int usbat_write_blocks(struct us_data *us,
 		return USB_STOR_TRANSPORT_FAILED;
 	
 	/* Write the data */
-	result = usbat_bulk_write(us, buffer, len);
+	result = usbat_bulk_write(us, buffer, len, use_sg);
 	if (result != USB_STOR_XFER_GOOD)
 		return USB_STOR_TRANSPORT_FAILED;
 
@@ -947,7 +953,7 @@ static int usbat_flash_get_sector_count(struct us_data *us,
 	msleep(100);
 
 	/* Read the device identification data */
-	rc = usbat_read_block(us, reply, 512);
+	rc = usbat_read_block(us, reply, 512, 0);
 	if (rc != USB_STOR_TRANSPORT_GOOD)
 		goto leave;
 
@@ -1031,7 +1037,7 @@ static int usbat_flash_read_data(struct us_data *us,
 			goto leave;
 
 		/* Read the data we just requested */
-		result = usbat_read_blocks(us, buffer, len);
+		result = usbat_read_blocks(us, buffer, len, 0);
 		if (result != USB_STOR_TRANSPORT_GOOD)
 			goto leave;
   	 
@@ -1125,7 +1131,7 @@ static int usbat_flash_write_data(struct us_data *us,
 			goto leave;
 
 		/* Write the data */
-		result = usbat_write_blocks(us, buffer, len);
+		result = usbat_write_blocks(us, buffer, len, 0);
 		if (result != USB_STOR_TRANSPORT_GOOD)
 			goto leave;
 
@@ -1503,10 +1509,10 @@ static int usbat_hp8200e_transport(struct scsi_cmnd *srb, struct us_data *us)
 	 * AT SPEED 4 IS UNRELIABLE!!!
 	 */
 
-	if ( (result = usbat_write_block(us, 
+	if ((result = usbat_write_block(us,
 			USBAT_ATA, srb-&gt;cmnd, 12,
-			srb-&gt;cmnd[0]==GPCMD_BLANK ? 75 : 10)) !=
-				USB_STOR_TRANSPORT_GOOD) {
+				(srb-&gt;cmnd[0]==GPCMD_BLANK ? 75 : 10), 0) !=
+			     USB_STOR_TRANSPORT_GOOD)) {
 		return result;
 	}
 
@@ -1533,7 +1539,7 @@ static int usbat_hp8200e_transport(struct scsi_cmnd *srb, struct us_data *us)
 			len = *status;
 
 
-		result = usbat_read_block(us, srb-&gt;request_buffer, len);
+		result = usbat_read_block(us, srb-&gt;request_buffer, len, srb-&gt;use_sg);
 
 		/* Debug-print the first 32 bytes of the transfer */
 </pre><hr><pre>commit 9ba89334552b96e2127dcafb1c46ce255ecf2667
Author: Ian Wienand &lt;ianw@gelato.unsw.edu.au&gt;
Date:   Wed Jun 21 10:33:04 2006 +1000

    [IA64] SKI Simulator boot
    
    Sorry I didn't notice earlier, but that BUG_ON triggers for me on the
    simulator.  AFAICS the mask for itv is set in cpu_init(), which comes
    after sal_init().  Consequently on the simulator the itv still has its
    start value of zero.  I've probably missed something, but I wonder why
    at this stage of the boot you even need to save and restore the itv?
    
    Signed-Off-By: Ian Wienand &lt;ianw@gelato.unsw.edu.au&gt;
    Signed-off-by: Tony Luck &lt;tony.luck@intel.com&gt;

diff --git a/arch/ia64/kernel/sal.c b/arch/ia64/kernel/sal.c
index 056f7a6eedc7..77fa65903d94 100644
--- a/arch/ia64/kernel/sal.c
+++ b/arch/ia64/kernel/sal.c
@@ -227,7 +227,7 @@ static int sal_cache_flush_drops_interrupts;
 static void __init
 check_sal_cache_flush (void)
 {
-	unsigned long flags, itv;
+	unsigned long flags;
 	int cpu;
 	u64 vector;
 
@@ -238,9 +238,6 @@ check_sal_cache_flush (void)
 	 * Schedule a timer interrupt, wait until it's reported, and see if
 	 * SAL_CACHE_FLUSH drops it.
 	 */
-	itv = ia64_get_itv();
-	BUG_ON((itv &amp; (1 &lt;&lt; 16)) == 0);
-
 	ia64_set_itv(IA64_TIMER_VECTOR);
 	ia64_set_itm(ia64_get_itc() + 1000);
 
@@ -260,7 +257,6 @@ check_sal_cache_flush (void)
 		ia64_eoi();
 	}
 
-	ia64_set_itv(itv);
 	local_irq_restore(flags);
 	put_cpu();
 }</pre><hr><pre>commit 4dc6d9cc38cea1004a7f827cf76409ae42231fee
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Thu Mar 23 21:39:47 2006 -0800

    [BRIDGE]: Unaligned accesses in the ethernet bridge
    
    I see lots of
            kernel unaligned access to 0xa0000001009dbb6f, ip=0xa000000100811591
            kernel unaligned access to 0xa0000001009dbb6b, ip=0xa0000001008115c1
            kernel unaligned access to 0xa0000001009dbb6d, ip=0xa0000001008115f1
    messages in my logs on IA64 when using the ethernet bridge with 2.6.16.
    
    Appended is a patch to fix them.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: Stephen Hemminger &lt;shemminger@osdl.org&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/bridge/br_stp_bpdu.c b/net/bridge/br_stp_bpdu.c
index 8934a54792be..a7ba0cce0b46 100644
--- a/net/bridge/br_stp_bpdu.c
+++ b/net/bridge/br_stp_bpdu.c
@@ -19,6 +19,7 @@
 #include &lt;linux/llc.h&gt;
 #include &lt;net/llc.h&gt;
 #include &lt;net/llc_pdu.h&gt;
+#include &lt;asm/unaligned.h&gt;
 
 #include "br_private.h"
 #include "br_private_stp.h"
@@ -59,12 +60,12 @@ static inline void br_set_ticks(unsigned char *dest, int j)
 {
 	unsigned long ticks = (STP_HZ * j)/ HZ;
 
-	*((__be16 *) dest) = htons(ticks);
+	put_unaligned(htons(ticks), (__be16 *)dest);
 }
 
 static inline int br_get_ticks(const unsigned char *src)
 {
-	unsigned long ticks = ntohs(*(__be16 *)src);
+	unsigned long ticks = ntohs(get_unaligned((__be16 *)src));
 
 	return (ticks * HZ + STP_HZ - 1) / STP_HZ;
 }</pre><hr><pre>commit 44fd0261d3509b0b4303fd9ba792058d230186ab
Author: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
Date:   Wed Nov 9 13:05:47 2005 -0800

    [IPV6]: Fix fallout from CONFIG_IPV6_PRIVACY
    
    Trying to build today's 2.6.14+git snapshot gives undefined references
    to use_tempaddr
    
    Looks like an ifdef got left out.
    
    Signed-off-by: Peter Chubb &lt;peterc@gelato.unsw.edu.au&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c
index b7a5f51238b3..ddcf7754eec2 100644
--- a/net/ipv6/addrconf.c
+++ b/net/ipv6/addrconf.c
@@ -1022,6 +1022,7 @@ int ipv6_dev_get_saddr(struct net_device *daddr_dev,
 					continue;
 			}
 
+#ifdef CONFIG_IPV6_PRIVACY
 			/* Rule 7: Prefer public address
 			 * Note: prefer temprary address if use_tempaddr &gt;= 2
 			 */
@@ -1042,7 +1043,7 @@ int ipv6_dev_get_saddr(struct net_device *daddr_dev,
 				if (hiscore.attrs &amp; IPV6_SADDR_SCORE_PRIVACY)
 					continue;
 			}
-
+#endif
 			/* Rule 8: Use longest matching prefix */
 			if (hiscore.rule &lt; 8)
 				hiscore.matchlen = ipv6_addr_diff(&amp;ifa_result-&gt;addr, daddr);</pre><hr><pre>commit 7afada45da2727fd96402b1244168e0420ca496a
Author: Ian Wienand &lt;ianw@gelato.unsw.edu.au&gt;
Date:   Wed Nov 2 22:49:10 2005 -0500

    Input: convert dmasound_awacs (OSS) to dynamic input allocation
    
    Signed-off-by: Ian Wienand &lt;ianw@gelato.unsw.edu.au&gt;
    Signed-off-by: Dmitry Torokhov &lt;dtor@mail.ru&gt;

diff --git a/sound/oss/dmasound/dmasound_awacs.c b/sound/oss/dmasound/dmasound_awacs.c
index b2bf8bac842d..cebd881b91ae 100644
--- a/sound/oss/dmasound/dmasound_awacs.c
+++ b/sound/oss/dmasound/dmasound_awacs.c
@@ -2805,16 +2805,7 @@ __init setup_beep(void)
 	return 0 ;
 }
 
-static struct input_dev awacs_beep_dev = {
-	.evbit		= { BIT(EV_SND) },
-	.sndbit		= { BIT(SND_BELL) | BIT(SND_TONE) },
-	.event		= awacs_beep_event,
-	.name		= "dmasound beeper",
-	.phys		= "macio/input0", /* what the heck is this?? */
-	.id		= {
-		.bustype	= BUS_HOST,
-	},
-};
+static struct input_dev *awacs_beep_dev;
 
 int __init dmasound_awacs_init(void)
 {
@@ -2907,6 +2898,22 @@ printk("dmasound_pmac: couldn't find a Codec we can handle\n");
 		return -ENODEV;
 	}
 
+	awacs_beep_dev = input_allocate_device();
+	if (!awacs_beep_dev) {
+		release_OF_resource(io, 0);
+		release_OF_resource(io, 1);
+		release_OF_resource(io, 2);
+		printk(KERN_ERR "dmasound: can't allocate input device !\n");
+		return -ENOMEM;
+	}
+
+	awacs_beep_dev-&gt;name = "dmasound beeper";
+	awacs_beep_dev-&gt;phys = "macio/input0";
+	awacs_beep_dev-&gt;id.bustype = BUS_HOST;
+	awacs_beep_dev-&gt;event = awacs_beep_event;
+	awacs_beep_dev-&gt;sndbit[0] = BIT(SND_BELL) | BIT(SND_TONE);
+	awacs_beep_dev-&gt;evbit[0] = BIT(EV_SND);
+
 	/* all OF versions I've seen use this value */
 	if (i2s_node)
 		i2s = ioremap(io-&gt;addrs[0].address, 0x1000);
@@ -3140,14 +3147,14 @@ printk("dmasound_pmac: Awacs/Screamer Codec Mfct: %d Rev %d\n", mfg, rev);
 	 * XXX: we should handle errors here, but that would mean
 	 * rewriting the whole init code.  later..
 	 */
-	input_register_device(&amp;awacs_beep_dev);
+	input_register_device(awacs_beep_dev);
 
 	return dmasound_init();
 }
 
 static void __exit dmasound_awacs_cleanup(void)
 {
-	input_unregister_device(&amp;awacs_beep_dev);
+	input_unregister_device(awacs_beep_dev);
 
 	switch (awacs_revision) {
 		case AWACS_TUMBLER:</pre>
    <div class="pagination">
        <a href='8_15.html'>&lt;&lt;Prev</a><a href='8.html'>1</a><a href='8_2.html'>2</a><a href='8_3.html'>3</a><a href='8_4.html'>4</a><a href='8_5.html'>5</a><a href='8_6.html'>6</a><a href='8_7.html'>7</a><a href='8_8.html'>8</a><a href='8_9.html'>9</a><a href='8_10.html'>10</a><a href='8_11.html'>11</a><a href='8_12.html'>12</a><a href='8_13.html'>13</a><a href='8_14.html'>14</a><a href='8_15.html'>15</a><span>[16]</span><a href='8_17.html'>17</a><a href='8_18.html'>18</a><a href='8_17.html'>Next&gt;&gt;</a>
    <div>
</body>
