<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Minnesota</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Minnesota</h1>
    <div class="pagination">
        <a href='7_16.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><span>[17]</span><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_18.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7ecced0934e574b528a1ba6c237731e682216a74
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Fri Mar 8 22:07:57 2019 -0600

    gpio: exar: add a check for the return value of ida_simple_get fails
    
    ida_simple_get may fail and return a negative error number.
    The fix checks its return value; if it fails, go to err_destroy.
    
    Cc: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Bartosz Golaszewski &lt;bgolaszewski@baylibre.com&gt;

diff --git a/drivers/gpio/gpio-exar.c b/drivers/gpio/gpio-exar.c
index 0ecd2369c2ca..a09d2f9ebacc 100644
--- a/drivers/gpio/gpio-exar.c
+++ b/drivers/gpio/gpio-exar.c
@@ -148,6 +148,8 @@ static int gpio_exar_probe(struct platform_device *pdev)
 	mutex_init(&amp;exar_gpio-&gt;lock);
 
 	index = ida_simple_get(&amp;ida_index, 0, 0, GFP_KERNEL);
+	if (index &lt; 0)
+		goto err_destroy;
 
 	sprintf(exar_gpio-&gt;name, "exar_gpio%d", index);
 	exar_gpio-&gt;gpio_chip.label = exar_gpio-&gt;name;</pre><hr><pre>commit 48f40b96de2c790eac6114e3e879a48fe9f89349
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Wed Mar 20 11:47:20 2019 -0500

    thunderbolt: xdomain: Fix to check return value of kmemdup
    
    kmemdup can fail and return a NULL pointer. The patch modifies the
    signature of tb_xdp_schedule_request and passes the failure error upstream.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: Mika Westerberg &lt;mika.westerberg@linux.intel.com&gt;

diff --git a/drivers/thunderbolt/xdomain.c b/drivers/thunderbolt/xdomain.c
index e0642dcb8b9b..e2fc4543142d 100644
--- a/drivers/thunderbolt/xdomain.c
+++ b/drivers/thunderbolt/xdomain.c
@@ -526,7 +526,7 @@ static void tb_xdp_handle_request(struct work_struct *work)
 	kfree(xw);
 }
 
-static void
+static bool
 tb_xdp_schedule_request(struct tb *tb, const struct tb_xdp_header *hdr,
 			size_t size)
 {
@@ -534,13 +534,18 @@ tb_xdp_schedule_request(struct tb *tb, const struct tb_xdp_header *hdr,
 
 	xw = kmalloc(sizeof(*xw), GFP_KERNEL);
 	if (!xw)
-		return;
+		return false;
 
 	INIT_WORK(&amp;xw-&gt;work, tb_xdp_handle_request);
 	xw-&gt;pkg = kmemdup(hdr, size, GFP_KERNEL);
+	if (!xw-&gt;pkg) {
+		kfree(xw);
+		return false;
+	}
 	xw-&gt;tb = tb;
 
 	queue_work(tb-&gt;wq, &amp;xw-&gt;work);
+	return true;
 }
 
 /**
@@ -1422,10 +1427,8 @@ bool tb_xdomain_handle_request(struct tb *tb, enum tb_cfg_pkg_type type,
 	 * handlers in turn.
 	 */
 	if (uuid_equal(&amp;hdr-&gt;uuid, &amp;tb_xdp_uuid)) {
-		if (type == TB_CFG_PKG_XDOMAIN_REQ) {
-			tb_xdp_schedule_request(tb, hdr, size);
-			return true;
-		}
+		if (type == TB_CFG_PKG_XDOMAIN_REQ)
+			return tb_xdp_schedule_request(tb, hdr, size);
 		return false;
 	}
 </pre><hr><pre>commit 9aabb68568b473bf2f0b179d053b403961e42e4d
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Wed Mar 20 11:34:09 2019 -0500

    thunderbolt: Fix to check return value of ida_simple_get
    
    In enumerate_services, ida_simple_get on failure can return an error and
    leaks memory. The patch ensures that the dev_set_name is set on non
    failure cases, and releases memory during failure.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: Mika Westerberg &lt;mika.westerberg@linux.intel.com&gt;

diff --git a/drivers/thunderbolt/xdomain.c b/drivers/thunderbolt/xdomain.c
index e27dd8beb94b..e0642dcb8b9b 100644
--- a/drivers/thunderbolt/xdomain.c
+++ b/drivers/thunderbolt/xdomain.c
@@ -740,6 +740,7 @@ static void enumerate_services(struct tb_xdomain *xd)
 	struct tb_service *svc;
 	struct tb_property *p;
 	struct device *dev;
+	int id;
 
 	/*
 	 * First remove all services that are not available anymore in
@@ -768,7 +769,12 @@ static void enumerate_services(struct tb_xdomain *xd)
 			break;
 		}
 
-		svc-&gt;id = ida_simple_get(&amp;xd-&gt;service_ids, 0, 0, GFP_KERNEL);
+		id = ida_simple_get(&amp;xd-&gt;service_ids, 0, 0, GFP_KERNEL);
+		if (id &lt; 0) {
+			kfree(svc);
+			break;
+		}
+		svc-&gt;id = id;
 		svc-&gt;dev.bus = &amp;tb_bus_type;
 		svc-&gt;dev.type = &amp;tb_service_type;
 		svc-&gt;dev.parent = &amp;xd-&gt;dev;</pre><hr><pre>commit 2cc12751cf464a722ff57b54d17d30c84553f9c0
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Wed Mar 20 10:57:54 2019 -0500

    thunderbolt: Fix to check for kmemdup failure
    
    Memory allocated via kmemdup might fail and return a NULL pointer.
    This patch adds a check on the return value of kmemdup and passes the
    error upstream.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Reviewed-by: Mukesh Ojha &lt;mojha@codeaurora.org&gt;
    Signed-off-by: Mika Westerberg &lt;mika.westerberg@linux.intel.com&gt;

diff --git a/drivers/thunderbolt/switch.c b/drivers/thunderbolt/switch.c
index cd96994dc094..504365d46827 100644
--- a/drivers/thunderbolt/switch.c
+++ b/drivers/thunderbolt/switch.c
@@ -1294,13 +1294,14 @@ int tb_switch_configure(struct tb_switch *sw)
 	return tb_plug_events_active(sw, true);
 }
 
-static void tb_switch_set_uuid(struct tb_switch *sw)
+static int tb_switch_set_uuid(struct tb_switch *sw)
 {
 	u32 uuid[4];
-	int cap;
+	int cap, ret;
 
+	ret = 0;
 	if (sw-&gt;uuid)
-		return;
+		return ret;
 
 	/*
 	 * The newer controllers include fused UUID as part of link
@@ -1308,7 +1309,9 @@ static void tb_switch_set_uuid(struct tb_switch *sw)
 	 */
 	cap = tb_switch_find_vse_cap(sw, TB_VSE_CAP_LINK_CONTROLLER);
 	if (cap &gt; 0) {
-		tb_sw_read(sw, uuid, TB_CFG_SWITCH, cap + 3, 4);
+		ret = tb_sw_read(sw, uuid, TB_CFG_SWITCH, cap + 3, 4);
+		if (ret)
+			return ret;
 	} else {
 		/*
 		 * ICM generates UUID based on UID and fills the upper
@@ -1323,6 +1326,9 @@ static void tb_switch_set_uuid(struct tb_switch *sw)
 	}
 
 	sw-&gt;uuid = kmemdup(uuid, sizeof(uuid), GFP_KERNEL);
+	if (!sw-&gt;uuid)
+		ret = -ENOMEM;
+	return ret;
 }
 
 static int tb_switch_add_dma_port(struct tb_switch *sw)
@@ -1372,7 +1378,9 @@ static int tb_switch_add_dma_port(struct tb_switch *sw)
 
 	if (status) {
 		tb_sw_info(sw, "switch flash authentication failed\n");
-		tb_switch_set_uuid(sw);
+		ret = tb_switch_set_uuid(sw);
+		if (ret)
+			return ret;
 		nvm_set_auth_status(sw, status);
 	}
 
@@ -1422,7 +1430,9 @@ int tb_switch_add(struct tb_switch *sw)
 		}
 		tb_sw_dbg(sw, "uid: %#llx\n", sw-&gt;uid);
 
-		tb_switch_set_uuid(sw);
+		ret = tb_switch_set_uuid(sw);
+		if (ret)
+			return ret;
 
 		for (i = 0; i &lt;= sw-&gt;config.max_port_number; i++) {
 			if (sw-&gt;ports[i].disabled) {</pre><hr><pre>commit 534c89c22e26b183d838294f0937ee092c82ad3a
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Thu Mar 14 00:46:51 2019 -0500

    x86/hyperv: Prevent potential NULL pointer dereference
    
    The page allocation in hv_cpu_init() can fail, but the code does not
    have a check for that.
    
    Add a check and return -ENOMEM when the allocation fails.
    
    [ tglx: Massaged changelog ]
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Reviewed-by: Mukesh Ojha &lt;mojha@codeaurora.org&gt;
    Acked-by: "K. Y. Srinivasan" &lt;kys@microsoft.com&gt;
    Cc: pakki001@umn.edu
    Cc: Haiyang Zhang &lt;haiyangz@microsoft.com&gt;
    Cc: Stephen Hemminger &lt;sthemmin@microsoft.com&gt;
    Cc: Sasha Levin &lt;sashal@kernel.org&gt;
    Cc: Borislav Petkov &lt;bp@alien8.de&gt;
    Cc: "H. Peter Anvin" &lt;hpa@zytor.com&gt;
    Cc: linux-hyperv@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190314054651.1315-1-kjlu@umn.edu

diff --git a/arch/x86/hyperv/hv_init.c b/arch/x86/hyperv/hv_init.c
index 6461a16b4559..e4ba467a9fc6 100644
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@ -103,9 +103,13 @@ static int hv_cpu_init(unsigned int cpu)
 	u64 msr_vp_index;
 	struct hv_vp_assist_page **hvp = &amp;hv_vp_assist_page[smp_processor_id()];
 	void **input_arg;
+	struct page *pg;
 
 	input_arg = (void **)this_cpu_ptr(hyperv_pcpu_input_arg);
-	*input_arg = page_address(alloc_page(GFP_KERNEL));
+	pg = alloc_page(GFP_KERNEL);
+	if (unlikely(!pg))
+		return -ENOMEM;
+	*input_arg = page_address(pg);
 
 	hv_get_vp_index(msr_vp_index);
 </pre><hr><pre>commit 2e84f116afca3719c9d0a1a78b47b48f75fd5724
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Mon Mar 18 21:19:56 2019 -0500

    x86/hpet: Prevent potential NULL pointer dereference
    
    hpet_virt_address may be NULL when ioremap_nocache fail, but the code lacks
    a check.
    
    Add a check to prevent NULL pointer dereference.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Cc: kjlu@umn.edu
    Cc: Borislav Petkov &lt;bp@alien8.de&gt;
    Cc: "H. Peter Anvin" &lt;hpa@zytor.com&gt;
    Cc: Kees Cook &lt;keescook@chromium.org&gt;
    Cc: Joe Perches &lt;joe@perches.com&gt;
    Cc: Nicolai Stange &lt;nstange@suse.de&gt;
    Cc: Roland Dreier &lt;roland@purestorage.com&gt;
    Link: https://lkml.kernel.org/r/20190319021958.17275-1-pakki001@umn.edu

diff --git a/arch/x86/kernel/hpet.c b/arch/x86/kernel/hpet.c
index dfd3aca82c61..fb32925a2e62 100644
--- a/arch/x86/kernel/hpet.c
+++ b/arch/x86/kernel/hpet.c
@@ -905,6 +905,8 @@ int __init hpet_enable(void)
 		return 0;
 
 	hpet_set_mapping();
+	if (!hpet_virt_address)
+		return 0;
 
 	/*
 	 * Read the period and check for a sane value:</pre><hr><pre>commit 6a8ca24590a2136921439b376c926c11a6effc0e
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Wed Mar 20 10:42:32 2019 -0500

    staging: rtlwifi: Fix potential NULL pointer dereference of kzalloc
    
    phydm.internal is allocated using kzalloc which is used multiple
    times without a check for NULL pointer. This patch avoids such a
    scenario by returning 0, consistent with the failure case.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Reviewed-by: Mukesh Ojha &lt;mojha@codeaurora.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtlwifi/phydm/rtl_phydm.c b/drivers/staging/rtlwifi/phydm/rtl_phydm.c
index 9930ed954abb..4cc77b2016e1 100644
--- a/drivers/staging/rtlwifi/phydm/rtl_phydm.c
+++ b/drivers/staging/rtlwifi/phydm/rtl_phydm.c
@@ -180,6 +180,8 @@ static int rtl_phydm_init_priv(struct rtl_priv *rtlpriv,
 
 	rtlpriv-&gt;phydm.internal =
 		kzalloc(sizeof(struct phy_dm_struct), GFP_KERNEL);
+	if (!rtlpriv-&gt;phydm.internal)
+		return 0;
 
 	_rtl_phydm_init_com_info(rtlpriv, ic, params);
 </pre><hr><pre>commit d70d70aec9632679dd00dcc1b1e8b2517e2c7da0
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Wed Mar 20 12:02:49 2019 -0500

    staging: rtlwifi: rtl8822b: fix to avoid potential NULL pointer dereference
    
    skb allocated via dev_alloc_skb can fail and return a NULL pointer.
    This patch avoids such a scenario and returns, consistent with other
    invocations.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Reviewed-by: Mukesh Ojha &lt;mojha@codeaurora.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtlwifi/rtl8822be/fw.c b/drivers/staging/rtlwifi/rtl8822be/fw.c
index f061dd1382aa..cf6b7a80b753 100644
--- a/drivers/staging/rtlwifi/rtl8822be/fw.c
+++ b/drivers/staging/rtlwifi/rtl8822be/fw.c
@@ -743,6 +743,8 @@ void rtl8822be_set_fw_rsvdpagepkt(struct ieee80211_hw *hw, bool b_dl_finished)
 		      u1_rsvd_page_loc, 3);
 
 	skb = dev_alloc_skb(totalpacketlen);
+	if (!skb)
+		return;
 	memcpy((u8 *)skb_put(skb, totalpacketlen), &amp;reserved_page_packet,
 	       totalpacketlen);
 </pre><hr><pre>commit 7671ce0d92933762f469266daf43bd34d422d58c
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Wed Mar 20 12:21:35 2019 -0500

    staging: rtl8188eu: Fix potential NULL pointer dereference of kcalloc
    
    hwxmits is allocated via kcalloc and not checked for failure before its
    dereference. The patch fixes this problem by returning error upstream
    in rtl8723bs, rtl8188eu.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Acked-by: Mukesh Ojha &lt;mojha@codeaurora.org&gt;
    Reviewed-by: Hans de Goede &lt;hdegoede@redhat.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/rtl8188eu/core/rtw_xmit.c b/drivers/staging/rtl8188eu/core/rtw_xmit.c
index 1723a47a96b4..952f2ab51347 100644
--- a/drivers/staging/rtl8188eu/core/rtw_xmit.c
+++ b/drivers/staging/rtl8188eu/core/rtw_xmit.c
@@ -174,7 +174,9 @@ s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter)
 
 	pxmitpriv-&gt;free_xmit_extbuf_cnt = num_xmit_extbuf;
 
-	rtw_alloc_hwxmits(padapter);
+	res = rtw_alloc_hwxmits(padapter);
+	if (res == _FAIL)
+		goto exit;
 	rtw_init_hwxmits(pxmitpriv-&gt;hwxmits, pxmitpriv-&gt;hwxmit_entry);
 
 	for (i = 0; i &lt; 4; i++)
@@ -1503,7 +1505,7 @@ s32 rtw_xmit_classifier(struct adapter *padapter, struct xmit_frame *pxmitframe)
 	return res;
 }
 
-void rtw_alloc_hwxmits(struct adapter *padapter)
+s32 rtw_alloc_hwxmits(struct adapter *padapter)
 {
 	struct hw_xmit *hwxmits;
 	struct xmit_priv *pxmitpriv = &amp;padapter-&gt;xmitpriv;
@@ -1512,6 +1514,8 @@ void rtw_alloc_hwxmits(struct adapter *padapter)
 
 	pxmitpriv-&gt;hwxmits = kcalloc(pxmitpriv-&gt;hwxmit_entry,
 				     sizeof(struct hw_xmit), GFP_KERNEL);
+	if (!pxmitpriv-&gt;hwxmits)
+		return _FAIL;
 
 	hwxmits = pxmitpriv-&gt;hwxmits;
 
@@ -1519,6 +1523,7 @@ void rtw_alloc_hwxmits(struct adapter *padapter)
 	hwxmits[1] .sta_queue = &amp;pxmitpriv-&gt;vi_pending;
 	hwxmits[2] .sta_queue = &amp;pxmitpriv-&gt;be_pending;
 	hwxmits[3] .sta_queue = &amp;pxmitpriv-&gt;bk_pending;
+	return _SUCCESS;
 }
 
 void rtw_free_hwxmits(struct adapter *padapter)
diff --git a/drivers/staging/rtl8188eu/include/rtw_xmit.h b/drivers/staging/rtl8188eu/include/rtw_xmit.h
index 788f59c74ea1..ba7e15fbde72 100644
--- a/drivers/staging/rtl8188eu/include/rtw_xmit.h
+++ b/drivers/staging/rtl8188eu/include/rtw_xmit.h
@@ -336,7 +336,7 @@ s32 rtw_txframes_sta_ac_pending(struct adapter *padapter,
 void rtw_init_hwxmits(struct hw_xmit *phwxmit, int entry);
 s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter);
 void _rtw_free_xmit_priv(struct xmit_priv *pxmitpriv);
-void rtw_alloc_hwxmits(struct adapter *padapter);
+s32 rtw_alloc_hwxmits(struct adapter *padapter);
 void rtw_free_hwxmits(struct adapter *padapter);
 s32 rtw_xmit(struct adapter *padapter, struct sk_buff **pkt);
 
diff --git a/drivers/staging/rtl8723bs/core/rtw_xmit.c b/drivers/staging/rtl8723bs/core/rtw_xmit.c
index 094d61bcb469..b87f13a0b563 100644
--- a/drivers/staging/rtl8723bs/core/rtw_xmit.c
+++ b/drivers/staging/rtl8723bs/core/rtw_xmit.c
@@ -260,7 +260,9 @@ s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter)
 		}
 	}
 
-	rtw_alloc_hwxmits(padapter);
+	res = rtw_alloc_hwxmits(padapter);
+	if (res == _FAIL)
+		goto exit;
 	rtw_init_hwxmits(pxmitpriv-&gt;hwxmits, pxmitpriv-&gt;hwxmit_entry);
 
 	for (i = 0; i &lt; 4; i++) {
@@ -2144,7 +2146,7 @@ s32 rtw_xmit_classifier(struct adapter *padapter, struct xmit_frame *pxmitframe)
 	return res;
 }
 
-void rtw_alloc_hwxmits(struct adapter *padapter)
+s32 rtw_alloc_hwxmits(struct adapter *padapter)
 {
 	struct hw_xmit *hwxmits;
 	struct xmit_priv *pxmitpriv = &amp;padapter-&gt;xmitpriv;
@@ -2155,10 +2157,8 @@ void rtw_alloc_hwxmits(struct adapter *padapter)
 
 	pxmitpriv-&gt;hwxmits = rtw_zmalloc(sizeof(struct hw_xmit) * pxmitpriv-&gt;hwxmit_entry);
 
-	if (pxmitpriv-&gt;hwxmits == NULL) {
-		DBG_871X("alloc hwxmits fail!...\n");
-		return;
-	}
+	if (!pxmitpriv-&gt;hwxmits)
+		return _FAIL;
 
 	hwxmits = pxmitpriv-&gt;hwxmits;
 
@@ -2204,7 +2204,7 @@ void rtw_alloc_hwxmits(struct adapter *padapter)
 
 	}
 
-
+	return _SUCCESS;
 }
 
 void rtw_free_hwxmits(struct adapter *padapter)
diff --git a/drivers/staging/rtl8723bs/include/rtw_xmit.h b/drivers/staging/rtl8723bs/include/rtw_xmit.h
index 1b38b9182b31..37f42b2f22f1 100644
--- a/drivers/staging/rtl8723bs/include/rtw_xmit.h
+++ b/drivers/staging/rtl8723bs/include/rtw_xmit.h
@@ -487,7 +487,7 @@ s32 _rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter);
 void _rtw_free_xmit_priv (struct xmit_priv *pxmitpriv);
 
 
-void rtw_alloc_hwxmits(struct adapter *padapter);
+s32 rtw_alloc_hwxmits(struct adapter *padapter);
 void rtw_free_hwxmits(struct adapter *padapter);
 
 </pre><hr><pre>commit e4dfdd5804cce1255f99c5dd033526a18135a616
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Thu Mar 14 01:55:31 2019 -0500

    thunderbolt: Fix a missing check of kmemdup
    
    kmemdup may fail and return NULL. The fix adds a check and returns
    NULL in case it fails to avoid NULL pointer dereferecen.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Mika Westerberg &lt;mika.westerberg@linux.intel.com&gt;

diff --git a/drivers/thunderbolt/property.c b/drivers/thunderbolt/property.c
index ee76449524a3..841314deb446 100644
--- a/drivers/thunderbolt/property.c
+++ b/drivers/thunderbolt/property.c
@@ -176,6 +176,10 @@ static struct tb_property_dir *__tb_property_parse_dir(const u32 *block,
 	} else {
 		dir-&gt;uuid = kmemdup(&amp;block[dir_offset], sizeof(*dir-&gt;uuid),
 				    GFP_KERNEL);
+		if (!dir-&gt;uuid) {
+			tb_property_free_dir(dir);
+			return NULL;
+		}
 		content_offset = dir_offset + 4;
 		content_len = dir_len - 4; /* Length includes UUID */
 	}</pre>
    <div class="pagination">
        <a href='7_16.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><span>[17]</span><a href='7_18.html'>18</a><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_18.html'>Next&gt;&gt;</a>
    <div>
</body>
