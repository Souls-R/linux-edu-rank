<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Virginia, Charlottesville</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Virginia, Charlottesville</h1>
    <div class="pagination">
        <a href='3_39.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><span>[40]</span><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_41.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 3f0c54131679889d64e8b1831bac40c0d64cf511
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 9 09:23:21 2012 -0400

    localmodconfig: Rework find_config in streamline_config.pl
    
    Change find_config function to read_config.  It now finds the config,
    reads the config into an array, and returns the array.  This makes it
    a little cleaner and changes the open to use perl's 3 option open.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Steven Rostedt &lt;rostedt@goodmis.org&gt;

diff --git a/scripts/kconfig/streamline_config.pl b/scripts/kconfig/streamline_config.pl
index e3687f98e0c8..62d64ce5c581 100644
--- a/scripts/kconfig/streamline_config.pl
+++ b/scripts/kconfig/streamline_config.pl
@@ -100,7 +100,7 @@ my @searchconfigs = (
 	},
 );
 
-sub find_config {
+sub read_config {
     foreach my $conf (@searchconfigs) {
 	my $file = $conf-&gt;{"file"};
 
@@ -115,17 +115,15 @@ sub find_config {
 
 	print STDERR "using config: '$file'\n";
 
-	open(CIN, "$exec $file |") || die "Failed to run $exec $file";
-	return;
+	open(my $infile, '-|', "$exec $file") || die "Failed to run $exec $file";
+	my @x = &lt;$infile&gt;;
+	close $infile;
+	return @x;
     }
     die "No config file found";
 }
 
-find_config;
-
-# Read in the entire config file into config_file
-my @config_file = &lt;CIN&gt;;
-close CIN;
+my @config_file = read_config;
 
 # Parse options
 my $localmodconfig = 0;</pre><hr><pre>commit 224a257190694f253f7a4c533fd6958d2e5fa669
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Aug 9 09:23:20 2012 -0400

    localmodconfig: Set default value for ksource in streamline_config.pl
    
    Running streamline_config.pl as it's shown it in the comment header,
    you will get a warning about $ksource being uninitialized.  This is
    because $ksource is set to ARGV[0], but the examples don't require any
    arguments.  Fix by setting ksource to . if no ARGV[0] is given.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Steven Rostedt &lt;rostedt@goodmis.org&gt;

diff --git a/scripts/kconfig/streamline_config.pl b/scripts/kconfig/streamline_config.pl
index 2fbbbc1ddea0..e3687f98e0c8 100644
--- a/scripts/kconfig/streamline_config.pl
+++ b/scripts/kconfig/streamline_config.pl
@@ -135,7 +135,7 @@ GetOptions("localmodconfig" =&gt; \$localmodconfig,
 	   "localyesconfig" =&gt; \$localyesconfig);
 
 # Get the build source and top level Kconfig file (passed in)
-my $ksource = $ARGV[0];
+my $ksource = ($ARGV[0] ? $ARGV[0] : '.');
 my $kconfig = $ARGV[1];
 my $lsmod_file = $ENV{'LSMOD'};
 </pre><hr><pre>commit c50f2af8e1a33e95e4d3b7af9db05ed9096c6072
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Tue Jun 19 10:34:07 2012 -0400

    USB: serial: Remove unused serial_priv variable
    
    qt2_open() and qt2_close() both set a serial_priv variable but never
    used it.  Remove the variable from the functions.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c
index 8dd88ebe9863..151670b6b72a 100644
--- a/drivers/usb/serial/quatech2.c
+++ b/drivers/usb/serial/quatech2.c
@@ -345,7 +345,6 @@ static void qt2_set_termios(struct tty_struct *tty,
 static int qt2_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct usb_serial *serial;
-	struct qt2_serial_private *serial_priv;
 	struct qt2_port_private *port_priv;
 	u8 *data;
 	u16 device_port;
@@ -357,7 +356,6 @@ static int qt2_open(struct tty_struct *tty, struct usb_serial_port *port)
 	serial = port-&gt;serial;
 
 	port_priv = usb_get_serial_port_data(port);
-	serial_priv = usb_get_serial_data(serial);
 
 	/* set the port to RS232 mode */
 	status = qt2_control_msg(serial-&gt;dev, QT2_GET_SET_QMCR,
@@ -417,13 +415,11 @@ static int qt2_open(struct tty_struct *tty, struct usb_serial_port *port)
 static void qt2_close(struct usb_serial_port *port)
 {
 	struct usb_serial *serial;
-	struct qt2_serial_private *serial_priv;
 	struct qt2_port_private *port_priv;
 	unsigned long flags;
 	int i;
 
 	serial = port-&gt;serial;
-	serial_priv = usb_get_serial_data(serial);
 	port_priv = usb_get_serial_port_data(port);
 
 	port_priv-&gt;is_open = false;</pre><hr><pre>commit 996a776544cc8a71653ffa95a89c317f33d2cb4a
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Tue Jun 19 10:34:06 2012 -0400

    USB: serial: Remove unused s_priv variable
    
    s_priv was set but never used in keyspan_open() and keyspan_close(),
    remove it.
    
    This also makes the serial variable in keyspan_open() unused since
    it's only use was to set s_priv, so it is also removed.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c
index a1b99243dac9..9a0ca8355905 100644
--- a/drivers/usb/serial/keyspan.c
+++ b/drivers/usb/serial/keyspan.c
@@ -1036,15 +1036,12 @@ static int keyspan_write_room(struct tty_struct *tty)
 static int keyspan_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct keyspan_port_private 	*p_priv;
-	struct keyspan_serial_private 	*s_priv;
-	struct usb_serial 		*serial = port-&gt;serial;
 	const struct keyspan_device_details	*d_details;
 	int				i, err;
 	int				baud_rate, device_port;
 	struct urb			*urb;
 	unsigned int			cflag = 0;
 
-	s_priv = usb_get_serial_data(serial);
 	p_priv = usb_get_serial_port_data(port);
 	d_details = p_priv-&gt;device_details;
 
@@ -1130,10 +1127,8 @@ static void keyspan_close(struct usb_serial_port *port)
 {
 	int			i;
 	struct usb_serial	*serial = port-&gt;serial;
-	struct keyspan_serial_private 	*s_priv;
 	struct keyspan_port_private 	*p_priv;
 
-	s_priv = usb_get_serial_data(serial);
 	p_priv = usb_get_serial_port_data(port);
 
 	p_priv-&gt;rts_state = 0;</pre><hr><pre>commit f88e6a30da1088143092f7b92ec2c8bd3b128350
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu May 10 16:57:39 2012 -0400

    USB: serial: add copyright and license to quatech2
    
    Add a copyright and license statement to the head of quatech.c source
    file.  No code change here.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c
index 3aa63f1f6dfe..8dd88ebe9863 100644
--- a/drivers/usb/serial/quatech2.c
+++ b/drivers/usb/serial/quatech2.c
@@ -1,6 +1,12 @@
 /*
  * usb-serial driver for Quatech USB 2 devices
  *
+ * Copyright (C) 2012 Bill Pemberton (wfp5p@virginia.edu)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
  *
  *  These devices all have only 1 bulk in and 1 bulk out that is shared
  *  for all serial ports.</pre><hr><pre>commit f7a33e608d9ae022b7f49307921627e34e9484ed
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu May 10 15:36:02 2012 -0400

    USB: serial: add quatech2 usb to serial driver
    
    This supports the Quatech USB 2 usb to serial adapters.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig
index 7141d6599060..325d2910f9f9 100644
--- a/drivers/usb/serial/Kconfig
+++ b/drivers/usb/serial/Kconfig
@@ -669,6 +669,15 @@ config USB_SERIAL_SSU100
 	  To compile this driver as a module, choose M here: the
 	  module will be called ssu100.
 
+config USB_SERIAL_QT2
+	tristate "USB Quatech Serial Driver for USB 2 devices"
+	help
+	  Say Y here if you want to use the Quatech USB 2
+	  serial adapters.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called quatech-serial.
+
 config USB_SERIAL_DEBUG
 	tristate "USB Debugging Device"
 	help
diff --git a/drivers/usb/serial/Makefile b/drivers/usb/serial/Makefile
index 07f198ee0486..1dc483a8bfc7 100644
--- a/drivers/usb/serial/Makefile
+++ b/drivers/usb/serial/Makefile
@@ -49,6 +49,7 @@ obj-$(CONFIG_USB_SERIAL_OTI6858)		+= oti6858.o
 obj-$(CONFIG_USB_SERIAL_PL2303)			+= pl2303.o
 obj-$(CONFIG_USB_SERIAL_QCAUX)			+= qcaux.o
 obj-$(CONFIG_USB_SERIAL_QUALCOMM)		+= qcserial.o
+obj-$(CONFIG_USB_SERIAL_QT2)			+= quatech2.o
 obj-$(CONFIG_USB_SERIAL_SAFE)			+= safe_serial.o
 obj-$(CONFIG_USB_SERIAL_SIEMENS_MPI)		+= siemens_mpi.o
 obj-$(CONFIG_USB_SERIAL_SIERRAWIRELESS)		+= sierra.o
diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c
new file mode 100644
index 000000000000..3aa63f1f6dfe
--- /dev/null
+++ b/drivers/usb/serial/quatech2.c
@@ -0,0 +1,1149 @@
+/*
+ * usb-serial driver for Quatech USB 2 devices
+ *
+ *
+ *  These devices all have only 1 bulk in and 1 bulk out that is shared
+ *  for all serial ports.
+ *
+ */
+
+#include &lt;asm/unaligned.h&gt;
+#include &lt;linux/errno.h&gt;
+#include &lt;linux/init.h&gt;
+#include &lt;linux/slab.h&gt;
+#include &lt;linux/tty.h&gt;
+#include &lt;linux/tty_driver.h&gt;
+#include &lt;linux/tty_flip.h&gt;
+#include &lt;linux/module.h&gt;
+#include &lt;linux/serial.h&gt;
+#include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/serial.h&gt;
+#include &lt;linux/serial_reg.h&gt;
+#include &lt;linux/uaccess.h&gt;
+
+static bool debug;
+
+/* default urb timeout for usb operations */
+#define QT2_USB_TIMEOUT USB_CTRL_SET_TIMEOUT
+
+#define QT_OPEN_CLOSE_CHANNEL       0xca
+#define QT_SET_GET_DEVICE           0xc2
+#define QT_SET_GET_REGISTER         0xc0
+#define QT_GET_SET_PREBUF_TRIG_LVL  0xcc
+#define QT_SET_ATF                  0xcd
+#define QT_TRANSFER_IN              0xc0
+#define QT_HW_FLOW_CONTROL_MASK     0xc5
+#define QT_SW_FLOW_CONTROL_MASK     0xc6
+#define QT2_BREAK_CONTROL	    0xc8
+#define QT2_GET_SET_UART            0xc1
+#define QT2_FLUSH_DEVICE	    0xc4
+#define QT2_GET_SET_QMCR            0xe1
+#define QT2_QMCR_RS232              0x40
+#define QT2_QMCR_RS422              0x10
+
+#define  SERIAL_CRTSCTS ((UART_MCR_RTS &lt;&lt; 8) | UART_MSR_CTS)
+
+#define  SERIAL_EVEN_PARITY         (UART_LCR_PARITY | UART_LCR_EPAR)
+
+/* status bytes for the device */
+#define QT2_CONTROL_BYTE    0x1b
+#define QT2_LINE_STATUS     0x00  /* following 1 byte is line status */
+#define QT2_MODEM_STATUS    0x01  /* following 1 byte is modem status */
+#define QT2_XMIT_HOLD       0x02  /* following 2 bytes are ?? */
+#define QT2_CHANGE_PORT     0x03  /* following 1 byte is port to change to */
+#define QT2_REC_FLUSH       0x04  /* no following info */
+#define QT2_XMIT_FLUSH      0x05  /* no following info */
+#define QT2_CONTROL_ESCAPE  0xff  /* pass through previous 2 control bytes */
+
+#define  MAX_BAUD_RATE              921600
+#define  DEFAULT_BAUD_RATE          9600
+
+#define QT2_WRITE_BUFFER_SIZE   512  /* size of write buffer */
+#define QT2_WRITE_CONTROL_SIZE  5    /* control bytes used for a write */
+
+/* Version Information */
+#define DRIVER_VERSION "v0.1"
+#define DRIVER_DESC "Quatech 2nd gen USB to Serial Driver"
+
+#define	USB_VENDOR_ID_QUATECH	0x061d
+#define QUATECH_SSU2_100	0xC120	/* RS232 single port */
+#define QUATECH_DSU2_100	0xC140	/* RS232 dual port */
+#define QUATECH_DSU2_400	0xC150	/* RS232/422/485 dual port */
+#define QUATECH_QSU2_100	0xC160	/* RS232 four port */
+#define QUATECH_QSU2_400	0xC170	/* RS232/422/485 four port */
+#define QUATECH_ESU2_100	0xC1A0	/* RS232 eight port */
+#define QUATECH_ESU2_400	0xC180	/* RS232/422/485 eight port */
+
+struct qt2_device_detail {
+	int product_id;
+	int num_ports;
+};
+
+#define QT_DETAILS(prod, ports)	\
+	.product_id = (prod),   \
+	.num_ports = (ports)
+
+static const struct qt2_device_detail qt2_device_details[] = {
+	{QT_DETAILS(QUATECH_SSU2_100, 1)},
+	{QT_DETAILS(QUATECH_DSU2_400, 2)},
+	{QT_DETAILS(QUATECH_DSU2_100, 2)},
+	{QT_DETAILS(QUATECH_QSU2_400, 4)},
+	{QT_DETAILS(QUATECH_QSU2_100, 4)},
+	{QT_DETAILS(QUATECH_ESU2_400, 8)},
+	{QT_DETAILS(QUATECH_ESU2_100, 8)},
+	{QT_DETAILS(0, 0)}	/* Terminating entry */
+};
+
+static const struct usb_device_id id_table[] = {
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU2_100)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU2_100)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU2_400)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU2_100)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU2_400)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU2_100)},
+	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU2_400)},
+	{}			/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(usb, id_table);
+
+struct qt2_serial_private {
+	unsigned char current_port;  /* current port for incoming data */
+
+	struct urb	*read_urb;   /* shared among all ports */
+	char		read_buffer[512];
+};
+
+struct qt2_port_private {
+	bool is_open;
+	u8   device_port;
+
+	spinlock_t urb_lock;
+	bool       urb_in_use;
+	struct urb *write_urb;
+	char       write_buffer[QT2_WRITE_BUFFER_SIZE];
+
+	spinlock_t  lock;
+	u8          shadowLSR;
+	u8          shadowMSR;
+
+	wait_queue_head_t   delta_msr_wait; /* Used for TIOCMIWAIT */
+	struct async_icount icount;
+
+	struct usb_serial_port *port;
+};
+
+static void qt2_update_lsr(struct usb_serial_port *port, unsigned char *ch);
+static void qt2_update_msr(struct usb_serial_port *port, unsigned char *ch);
+static void qt2_write_bulk_callback(struct urb *urb);
+static void qt2_read_bulk_callback(struct urb *urb);
+
+static void qt2_release(struct usb_serial *serial)
+{
+	int i;
+
+	kfree(usb_get_serial_data(serial));
+
+	for (i = 0; i &lt; serial-&gt;num_ports; i++)
+		kfree(usb_get_serial_port_data(serial-&gt;port[i]));
+}
+
+static inline int calc_baud_divisor(int baudrate)
+{
+	int divisor, rem;
+
+	divisor = MAX_BAUD_RATE / baudrate;
+	rem = MAX_BAUD_RATE % baudrate;
+	/* Round to nearest divisor */
+	if (((rem * 2) &gt;= baudrate) &amp;&amp; (baudrate != 110))
+		divisor++;
+
+	return divisor;
+}
+
+static inline int qt2_set_port_config(struct usb_device *dev,
+				      unsigned char port_number,
+				      u16 baudrate, u16 lcr)
+{
+	int divisor = calc_baud_divisor(baudrate);
+	u16 index = ((u16) (lcr &lt;&lt; 8) | (u16) (port_number));
+
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       QT2_GET_SET_UART, 0x40,
+			       divisor, index, NULL, 0, QT2_USB_TIMEOUT);
+}
+
+static inline int qt2_control_msg(struct usb_device *dev,
+				  u8 request, u16 data, u16 index)
+{
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       request, 0x40, data, index,
+			       NULL, 0, QT2_USB_TIMEOUT);
+}
+
+static inline int qt2_setdevice(struct usb_device *dev, u8 *data)
+{
+	u16 x = ((u16) (data[1] &lt;&lt; 8) | (u16) (data[0]));
+
+	return qt2_control_msg(dev, QT_SET_GET_DEVICE, x, 0);
+}
+
+
+static inline int qt2_getdevice(struct usb_device *dev, u8 *data)
+{
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			       QT_SET_GET_DEVICE, 0xc0, 0, 0,
+			       data, 3, QT2_USB_TIMEOUT);
+}
+
+static inline int qt2_getregister(struct usb_device *dev,
+				  u8 uart,
+				  u8 reg,
+				  u8 *data)
+{
+	return usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),
+			       QT_SET_GET_REGISTER, 0xc0, reg,
+			       uart, data, sizeof(*data), QT2_USB_TIMEOUT);
+
+}
+
+static inline int qt2_setregister(struct usb_device *dev,
+				  u8 uart, u8 reg, u16 data)
+{
+	u16 value = (data &lt;&lt; 8) | reg;
+
+	return usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
+			       QT_SET_GET_REGISTER, 0x40, value, uart,
+			       NULL, 0, QT2_USB_TIMEOUT);
+}
+
+static inline int update_mctrl(struct qt2_port_private *port_priv,
+			       unsigned int set, unsigned int clear)
+{
+	struct usb_serial_port *port = port_priv-&gt;port;
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+	unsigned urb_value;
+	int status;
+
+	if (((set | clear) &amp; (TIOCM_DTR | TIOCM_RTS)) == 0) {
+		dev_dbg(&amp;port-&gt;dev,
+			"update_mctrl - DTR|RTS not being set|cleared\n");
+		return 0;	/* no change */
+	}
+
+	clear &amp;= ~set;	/* 'set' takes precedence over 'clear' */
+	urb_value = 0;
+	if (set &amp; TIOCM_DTR)
+		urb_value |= UART_MCR_DTR;
+	if (set &amp; TIOCM_RTS)
+		urb_value |= UART_MCR_RTS;
+
+	status = qt2_setregister(dev, port_priv-&gt;device_port, UART_MCR,
+				 urb_value);
+	if (status &lt; 0)
+		dev_err(&amp;port-&gt;dev,
+			"update_mctrl - Error from MODEM_CTRL urb: %i\n",
+			status);
+	return status;
+}
+
+static int qt2_calc_num_ports(struct usb_serial *serial)
+{
+	struct qt2_device_detail d;
+	int i;
+
+	for (i = 0; d = qt2_device_details[i], d.product_id != 0; i++) {
+		if (d.product_id == le16_to_cpu(serial-&gt;dev-&gt;descriptor.idProduct))
+			return d.num_ports;
+	}
+
+	/* we didn't recognize the device */
+	dev_err(&amp;serial-&gt;dev-&gt;dev,
+		 "don't know the number of ports, assuming 1\n");
+
+	return 1;
+}
+
+static void qt2_set_termios(struct tty_struct *tty,
+			    struct usb_serial_port *port,
+			    struct ktermios *old_termios)
+{
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+	struct qt2_port_private *port_priv;
+	struct ktermios *termios = tty-&gt;termios;
+	u16 baud;
+	unsigned int cflag = termios-&gt;c_cflag;
+	u16 new_lcr = 0;
+	int status;
+
+	port_priv = usb_get_serial_port_data(port);
+
+	if (cflag &amp; PARENB) {
+		if (cflag &amp; PARODD)
+			new_lcr |= UART_LCR_PARITY;
+		else
+			new_lcr |= SERIAL_EVEN_PARITY;
+	}
+
+	switch (cflag &amp; CSIZE) {
+	case CS5:
+		new_lcr |= UART_LCR_WLEN5;
+		break;
+	case CS6:
+		new_lcr |= UART_LCR_WLEN6;
+		break;
+	case CS7:
+		new_lcr |= UART_LCR_WLEN7;
+		break;
+	default:
+	case CS8:
+		new_lcr |= UART_LCR_WLEN8;
+		break;
+	}
+
+	baud = tty_get_baud_rate(tty);
+	if (!baud)
+		baud = 9600;
+
+	status = qt2_set_port_config(dev, port_priv-&gt;device_port, baud,
+				     new_lcr);
+	if (status &lt; 0)
+		dev_err(&amp;port-&gt;dev, "%s - qt2_set_port_config failed: %i\n",
+			__func__, status);
+
+	if (cflag &amp; CRTSCTS)
+		status = qt2_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
+					 SERIAL_CRTSCTS,
+					 port_priv-&gt;device_port);
+	else
+		status = qt2_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,
+					 0, port_priv-&gt;device_port);
+	if (status &lt; 0)
+		dev_err(&amp;port-&gt;dev, "%s - set HW flow control failed: %i\n",
+			__func__, status);
+
+	if (I_IXOFF(tty) || I_IXON(tty)) {
+		u16 x = ((u16) (START_CHAR(tty) &lt;&lt; 8) | (u16) (STOP_CHAR(tty)));
+
+		status = qt2_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,
+					 x, port_priv-&gt;device_port);
+	} else
+		status = qt2_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,
+					 0, port_priv-&gt;device_port);
+
+	if (status &lt; 0)
+		dev_err(&amp;port-&gt;dev, "%s - set SW flow control failed: %i\n",
+			__func__, status);
+
+}
+
+static int qt2_open(struct tty_struct *tty, struct usb_serial_port *port)
+{
+	struct usb_serial *serial;
+	struct qt2_serial_private *serial_priv;
+	struct qt2_port_private *port_priv;
+	u8 *data;
+	u16 device_port;
+	int status;
+	unsigned long flags;
+
+	device_port = (u16) (port-&gt;number - port-&gt;serial-&gt;minor);
+
+	serial = port-&gt;serial;
+
+	port_priv = usb_get_serial_port_data(port);
+	serial_priv = usb_get_serial_data(serial);
+
+	/* set the port to RS232 mode */
+	status = qt2_control_msg(serial-&gt;dev, QT2_GET_SET_QMCR,
+				 QT2_QMCR_RS232, device_port);
+	if (status &lt; 0) {
+		dev_err(&amp;port-&gt;dev,
+			"%s failed to set RS232 mode for port %i error %i\n",
+			__func__, device_port, status);
+		return status;
+	}
+
+	data = kzalloc(2, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	/* open the port */
+	status = usb_control_msg(serial-&gt;dev,
+				 usb_rcvctrlpipe(serial-&gt;dev, 0),
+				 QT_OPEN_CLOSE_CHANNEL,
+				 0xc0, 0,
+				 device_port, data, 2, QT2_USB_TIMEOUT);
+
+	if (status &lt; 0) {
+		dev_err(&amp;port-&gt;dev, "%s - open port failed %i", __func__,
+			status);
+		kfree(data);
+		return status;
+	}
+
+	spin_lock_irqsave(&amp;port_priv-&gt;lock, flags);
+	port_priv-&gt;shadowLSR = data[0];
+	port_priv-&gt;shadowMSR = data[1];
+	spin_unlock_irqrestore(&amp;port_priv-&gt;lock, flags);
+
+	kfree(data);
+
+	/* set to default speed and 8bit word size */
+	status = qt2_set_port_config(serial-&gt;dev, device_port,
+				     DEFAULT_BAUD_RATE, UART_LCR_WLEN8);
+	if (status &lt; 0) {
+		dev_err(&amp;port-&gt;dev,
+			"%s - initial setup failed for port %i (%i)\n",
+			__func__, port-&gt;number, device_port);
+		return status;
+	}
+
+	port_priv-&gt;is_open = true;
+	port_priv-&gt;device_port = (u8) device_port;
+
+	if (tty)
+		qt2_set_termios(tty, port, tty-&gt;termios);
+
+	return 0;
+
+}
+
+static void qt2_close(struct usb_serial_port *port)
+{
+	struct usb_serial *serial;
+	struct qt2_serial_private *serial_priv;
+	struct qt2_port_private *port_priv;
+	unsigned long flags;
+	int i;
+
+	serial = port-&gt;serial;
+	serial_priv = usb_get_serial_data(serial);
+	port_priv = usb_get_serial_port_data(port);
+
+	port_priv-&gt;is_open = false;
+
+	spin_lock_irqsave(&amp;port_priv-&gt;urb_lock, flags);
+	if (port_priv-&gt;write_urb-&gt;status == -EINPROGRESS)
+		usb_kill_urb(port_priv-&gt;write_urb);
+	port_priv-&gt;urb_in_use = false;
+	spin_unlock_irqrestore(&amp;port_priv-&gt;urb_lock, flags);
+
+	/* flush the port transmit buffer */
+	i = usb_control_msg(serial-&gt;dev,
+			    usb_rcvctrlpipe(serial-&gt;dev, 0),
+			    QT2_FLUSH_DEVICE, 0x40, 1,
+			    port_priv-&gt;device_port, NULL, 0, QT2_USB_TIMEOUT);
+
+	if (i &lt; 0)
+		dev_err(&amp;port-&gt;dev, "%s - transmit buffer flush failed: %i\n",
+			__func__, i);
+
+	/* flush the port receive buffer */
+	i = usb_control_msg(serial-&gt;dev,
+			    usb_rcvctrlpipe(serial-&gt;dev, 0),
+			    QT2_FLUSH_DEVICE, 0x40, 0,
+			    port_priv-&gt;device_port, NULL, 0, QT2_USB_TIMEOUT);
+
+	if (i &lt; 0)
+		dev_err(&amp;port-&gt;dev, "%s - receive buffer flush failed: %i\n",
+			__func__, i);
+
+	/* close the port */
+	i = usb_control_msg(serial-&gt;dev,
+			    usb_sndctrlpipe(serial-&gt;dev, 0),
+			    QT_OPEN_CLOSE_CHANNEL,
+			    0x40, 0,
+			    port_priv-&gt;device_port, NULL, 0, QT2_USB_TIMEOUT);
+
+	if (i &lt; 0)
+		dev_err(&amp;port-&gt;dev, "%s - close port failed %i\n",
+			__func__, i);
+
+}
+
+static void qt2_disconnect(struct usb_serial *serial)
+{
+	struct qt2_serial_private *serial_priv = usb_get_serial_data(serial);
+	struct qt2_port_private *port_priv;
+	int i;
+
+	if (serial_priv-&gt;read_urb-&gt;status == -EINPROGRESS)
+		usb_kill_urb(serial_priv-&gt;read_urb);
+
+	usb_free_urb(serial_priv-&gt;read_urb);
+
+	for (i = 0; i &lt; serial-&gt;num_ports; i++) {
+		port_priv = usb_get_serial_port_data(serial-&gt;port[i]);
+
+		if (port_priv-&gt;write_urb-&gt;status == -EINPROGRESS)
+			usb_kill_urb(port_priv-&gt;write_urb);
+		usb_free_urb(port_priv-&gt;write_urb);
+	}
+}
+
+static int get_serial_info(struct usb_serial_port *port,
+			   struct serial_struct __user *retinfo)
+{
+	struct serial_struct tmp;
+
+	if (!retinfo)
+		return -EFAULT;
+
+	memset(&amp;tmp, 0, sizeof(tmp));
+	tmp.line		= port-&gt;serial-&gt;minor;
+	tmp.port		= 0;
+	tmp.irq			= 0;
+	tmp.flags		= ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ;
+	tmp.xmit_fifo_size	= port-&gt;bulk_out_size;
+	tmp.baud_base		= 9600;
+	tmp.close_delay		= 5*HZ;
+	tmp.closing_wait	= 30*HZ;
+
+	if (copy_to_user(retinfo, &amp;tmp, sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int wait_modem_info(struct usb_serial_port *port, unsigned int arg)
+{
+	struct qt2_port_private *priv = usb_get_serial_port_data(port);
+	struct async_icount prev, cur;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
+	prev = priv-&gt;icount;
+	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
+
+	while (1) {
+		wait_event_interruptible(priv-&gt;delta_msr_wait,
+					 ((priv-&gt;icount.rng != prev.rng) ||
+					  (priv-&gt;icount.dsr != prev.dsr) ||
+					  (priv-&gt;icount.dcd != prev.dcd) ||
+					  (priv-&gt;icount.cts != prev.cts)));
+
+		if (signal_pending(current))
+			return -ERESTARTSYS;
+
+		spin_lock_irqsave(&amp;priv-&gt;lock, flags);
+		cur = priv-&gt;icount;
+		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
+
+		if ((prev.rng == cur.rng) &amp;&amp;
+		    (prev.dsr == cur.dsr) &amp;&amp;
+		    (prev.dcd == cur.dcd) &amp;&amp;
+		    (prev.cts == cur.cts))
+			return -EIO;
+
+		if ((arg &amp; TIOCM_RNG &amp;&amp; (prev.rng != cur.rng)) ||
+		    (arg &amp; TIOCM_DSR &amp;&amp; (prev.dsr != cur.dsr)) ||
+		    (arg &amp; TIOCM_CD &amp;&amp; (prev.dcd != cur.dcd)) ||
+		    (arg &amp; TIOCM_CTS &amp;&amp; (prev.cts != cur.cts)))
+			return 0;
+	}
+	return 0;
+}
+
+static int qt2_get_icount(struct tty_struct *tty,
+			  struct serial_icounter_struct *icount)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct qt2_port_private *priv = usb_get_serial_port_data(port);
+	struct async_icount cnow = priv-&gt;icount;
+
+	icount-&gt;cts = cnow.cts;
+	icount-&gt;dsr = cnow.dsr;
+	icount-&gt;rng = cnow.rng;
+	icount-&gt;dcd = cnow.dcd;
+	icount-&gt;rx = cnow.rx;
+	icount-&gt;tx = cnow.tx;
+	icount-&gt;frame = cnow.frame;
+	icount-&gt;overrun = cnow.overrun;
+	icount-&gt;parity = cnow.parity;
+	icount-&gt;brk = cnow.brk;
+	icount-&gt;buf_overrun = cnow.buf_overrun;
+
+	return 0;
+}
+
+static int qt2_ioctl(struct tty_struct *tty,
+		     unsigned int cmd, unsigned long arg)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+
+	switch (cmd) {
+	case TIOCGSERIAL:
+		return get_serial_info(port,
+				       (struct serial_struct __user *)arg);
+
+	case TIOCMIWAIT:
+		return wait_modem_info(port, arg);
+
+	default:
+		break;
+	}
+
+	return -ENOIOCTLCMD;
+}
+
+static void qt2_process_status(struct usb_serial_port *port, unsigned char *ch)
+{
+	switch (*ch) {
+	case QT2_LINE_STATUS:
+		qt2_update_lsr(port, ch + 1);
+		break;
+	case QT2_MODEM_STATUS:
+		qt2_update_msr(port, ch + 1);
+		break;
+	}
+}
+
+/* not needed, kept to document functionality */
+static void qt2_process_xmit_empty(struct usb_serial_port *port,
+				   unsigned char *ch)
+{
+	int bytes_written;
+
+	bytes_written = (int)(*ch) + (int)(*(ch + 1) &lt;&lt; 4);
+}
+
+/* not needed, kept to document functionality */
+static void qt2_process_flush(struct usb_serial_port *port, unsigned char *ch)
+{
+	return;
+}
+
+void qt2_process_read_urb(struct urb *urb)
+{
+	struct usb_serial *serial;
+	struct qt2_serial_private *serial_priv;
+	struct usb_serial_port *port;
+	struct qt2_port_private *port_priv;
+	struct tty_struct *tty;
+	bool escapeflag;
+	unsigned char *ch;
+	int i;
+	unsigned char newport;
+	int len = urb-&gt;actual_length;
+
+	if (!len)
+		return;
+
+	ch = urb-&gt;transfer_buffer;
+	tty = NULL;
+	serial = urb-&gt;context;
+	serial_priv = usb_get_serial_data(serial);
+	port = serial-&gt;port[serial_priv-&gt;current_port];
+	port_priv = usb_get_serial_port_data(port);
+
+	if (port_priv-&gt;is_open)
+		tty = tty_port_tty_get(&amp;port-&gt;port);
+
+	for (i = 0; i &lt; urb-&gt;actual_length; i++) {
+		ch = (unsigned char *)urb-&gt;transfer_buffer + i;
+		if ((i &lt;= (len - 3)) &amp;&amp;
+		    (*ch == QT2_CONTROL_BYTE) &amp;&amp;
+		    (*(ch + 1) == QT2_CONTROL_BYTE)) {
+			escapeflag = false;
+			switch (*(ch + 2)) {
+			case QT2_LINE_STATUS:
+			case QT2_MODEM_STATUS:
+				if (i &gt; (len - 4)) {
+					dev_warn(&amp;port-&gt;dev,
+						 "%s - status message too short\n",
+						__func__);
+					break;
+				}
+				qt2_process_status(port, ch + 2);
+				i += 3;
+				escapeflag = true;
+				break;
+			case QT2_XMIT_HOLD:
+				if (i &gt; (len - 5)) {
+					dev_warn(&amp;port-&gt;dev,
+						 "%s - xmit_empty message too short\n",
+						 __func__);
+					break;
+				}
+				qt2_process_xmit_empty(port, ch + 3);
+				i += 4;
+				escapeflag = true;
+				break;
+			case QT2_CHANGE_PORT:
+				if (i &gt; (len - 4)) {
+					dev_warn(&amp;port-&gt;dev,
+						 "%s - change_port message too short\n",
+						 __func__);
+					break;
+				}
+				if (tty) {
+					tty_flip_buffer_push(tty);
+					tty_kref_put(tty);
+				}
+
+				newport = *(ch + 3);
+
+				if (newport &gt; serial-&gt;num_ports) {
+					dev_err(&amp;port-&gt;dev,
+						"%s - port change to invalid port: %i\n",
+						__func__, newport);
+					break;
+				}
+
+				serial_priv-&gt;current_port = newport;
+				port = serial-&gt;port[serial_priv-&gt;current_port];
+				port_priv = usb_get_serial_port_data(port);
+				if (port_priv-&gt;is_open)
+					tty = tty_port_tty_get(&amp;port-&gt;port);
+				else
+					tty = NULL;
+				i += 3;
+				escapeflag = true;
+				break;
+			case QT2_REC_FLUSH:
+			case QT2_XMIT_FLUSH:
+				qt2_process_flush(port, ch + 2);
+				i += 2;
+				escapeflag = true;
+				break;
+			case QT2_CONTROL_ESCAPE:
+				tty_buffer_request_room(tty, 2);
+				tty_insert_flip_string(tty, ch, 2);
+				i += 2;
+				escapeflag = true;
+				break;
+			default:
+				dev_warn(&amp;port-&gt;dev,
+					 "%s - unsupported command %i\n",
+					 __func__, *(ch + 2));
+				break;
+			}
+			if (escapeflag)
+				continue;
+		}
+
+		if (tty) {
+			tty_buffer_request_room(tty, 1);
+			tty_insert_flip_string(tty, ch, 1);
+		}
+	}
+
+	if (tty) {
+		tty_flip_buffer_push(tty);
+		tty_kref_put(tty);
+	}
+}
+
+static void qt2_write_bulk_callback(struct urb *urb)
+{
+	struct usb_serial_port *port;
+	struct qt2_port_private *port_priv;
+
+	port = urb-&gt;context;
+	port_priv = usb_get_serial_port_data(port);
+
+	spin_lock(&amp;port_priv-&gt;urb_lock);
+
+	port_priv-&gt;urb_in_use = false;
+	usb_serial_port_softint(port);
+
+	spin_unlock(&amp;port_priv-&gt;urb_lock);
+
+}
+
+static void qt2_read_bulk_callback(struct urb *urb)
+{
+	struct usb_serial *serial = urb-&gt;context;
+	int status;
+
+	if (urb-&gt;status) {
+		dev_warn(&amp;serial-&gt;dev-&gt;dev,
+			 "%s - non-zero urb status: %i\n", __func__,
+			 urb-&gt;status);
+		return;
+	}
+
+	qt2_process_read_urb(urb);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status != 0)
+		dev_err(&amp;serial-&gt;dev-&gt;dev,
+			"%s - resubmit read urb failed: %i\n",
+			__func__, status);
+}
+
+static int qt2_setup_urbs(struct usb_serial *serial)
+{
+	struct usb_serial_port *port;
+	struct usb_serial_port *port0;
+	struct qt2_serial_private *serial_priv;
+	struct qt2_port_private *port_priv;
+	int pcount, status;
+
+	port0 = serial-&gt;port[0];
+
+	serial_priv = usb_get_serial_data(serial);
+	serial_priv-&gt;read_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!serial_priv-&gt;read_urb) {
+		dev_err(&amp;serial-&gt;dev-&gt;dev, "No free urbs available\n");
+		return -ENOMEM;
+	}
+
+	usb_fill_bulk_urb(serial_priv-&gt;read_urb, serial-&gt;dev,
+			  usb_rcvbulkpipe(serial-&gt;dev,
+					  port0-&gt;bulk_in_endpointAddress),
+			  serial_priv-&gt;read_buffer,
+			  sizeof(serial_priv-&gt;read_buffer),
+			  qt2_read_bulk_callback, serial);
+
+	/* setup write_urb for each port */
+	for (pcount = 0; pcount &lt; serial-&gt;num_ports; pcount++) {
+
+		port = serial-&gt;port[pcount];
+		port_priv = usb_get_serial_port_data(port);
+
+		port_priv-&gt;write_urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!port_priv-&gt;write_urb) {
+			dev_err(&amp;serial-&gt;dev-&gt;dev,
+				"failed to alloc write_urb for port %i\n",
+				pcount);
+			return -ENOMEM;
+		}
+
+		usb_fill_bulk_urb(port_priv-&gt;write_urb,
+				  serial-&gt;dev,
+				  usb_sndbulkpipe(serial-&gt;dev,
+						  port0-&gt;
+						  bulk_out_endpointAddress),
+				  port_priv-&gt;write_buffer,
+				  sizeof(port_priv-&gt;write_buffer),
+				  qt2_write_bulk_callback, port);
+	}
+
+	status = usb_submit_urb(serial_priv-&gt;read_urb, GFP_KERNEL);
+	if (status != 0) {
+		dev_err(&amp;serial-&gt;dev-&gt;dev,
+			"%s - submit read urb failed %i\n", __func__, status);
+		return status;
+	}
+
+	return 0;
+
+}
+
+static int qt2_attach(struct usb_serial *serial)
+{
+	struct qt2_serial_private *serial_priv;
+	struct qt2_port_private *port_priv;
+	int status, pcount;
+
+	/* power on unit */
+	status = usb_control_msg(serial-&gt;dev, usb_rcvctrlpipe(serial-&gt;dev, 0),
+				 0xc2, 0x40, 0x8000, 0, NULL, 0,
+				 QT2_USB_TIMEOUT);
+	if (status &lt; 0) {
+		dev_err(&amp;serial-&gt;dev-&gt;dev,
+			"%s - failed to power on unit: %i\n", __func__, status);
+		return status;
+	}
+
+	serial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);
+	if (!serial_priv) {
+		dev_err(&amp;serial-&gt;dev-&gt;dev, "%s - Out of memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	usb_set_serial_data(serial, serial_priv);
+
+	for (pcount = 0; pcount &lt; serial-&gt;num_ports; pcount++) {
+		port_priv = kzalloc(sizeof(*port_priv), GFP_KERNEL);
+		if (!port_priv) {
+			dev_err(&amp;serial-&gt;dev-&gt;dev,
+				"%s- kmalloc(%Zd) failed.\n", __func__,
+				sizeof(*port_priv));
+			pcount--;
+			status = -ENOMEM;
+			goto attach_failed;
+		}
+
+		spin_lock_init(&amp;port_priv-&gt;lock);
+		spin_lock_init(&amp;port_priv-&gt;urb_lock);
+		init_waitqueue_head(&amp;port_priv-&gt;delta_msr_wait);
+
+		port_priv-&gt;port = serial-&gt;port[pcount];
+
+		usb_set_serial_port_data(serial-&gt;port[pcount], port_priv);
+	}
+
+	status = qt2_setup_urbs(serial);
+	if (status != 0)
+		goto attach_failed;
+
+	return 0;
+
+attach_failed:
+	for (/* empty */; pcount &gt;= 0; pcount--) {
+		port_priv = usb_get_serial_port_data(serial-&gt;port[pcount]);
+		kfree(port_priv);
+	}
+	kfree(serial_priv);
+	return status;
+}
+
+static int qt2_tiocmget(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+	struct qt2_port_private *port_priv = usb_get_serial_port_data(port);
+	u8 *d;
+	int r;
+
+	d = kzalloc(2, GFP_KERNEL);
+	if (!d)
+		return -ENOMEM;
+
+	r = qt2_getregister(dev, port_priv-&gt;device_port, UART_MCR, d);
+	if (r &lt; 0)
+		goto mget_out;
+
+	r = qt2_getregister(dev, port_priv-&gt;device_port, UART_MSR, d + 1);
+	if (r &lt; 0)
+		goto mget_out;
+
+	r = (d[0] &amp; UART_MCR_DTR ? TIOCM_DTR : 0) |
+	    (d[0] &amp; UART_MCR_RTS ? TIOCM_RTS : 0) |
+	    (d[1] &amp; UART_MSR_CTS ? TIOCM_CTS : 0) |
+	    (d[1] &amp; UART_MSR_DCD ? TIOCM_CAR : 0) |
+	    (d[1] &amp; UART_MSR_RI ? TIOCM_RI : 0) |
+	    (d[1] &amp; UART_MSR_DSR ? TIOCM_DSR : 0);
+
+mget_out:
+	kfree(d);
+	return r;
+}
+
+static int qt2_tiocmset(struct tty_struct *tty,
+			unsigned int set, unsigned int clear)
+{
+	struct qt2_port_private *port_priv;
+
+	port_priv = usb_get_serial_port_data(tty-&gt;driver_data);
+	return update_mctrl(port_priv, set, clear);
+}
+
+static void qt2_break_ctl(struct tty_struct *tty, int break_state)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct qt2_port_private *port_priv;
+	int status;
+	u16 val;
+
+	port_priv = usb_get_serial_port_data(port);
+
+	if (!port_priv-&gt;is_open) {
+		dev_err(&amp;port-&gt;dev,
+			"%s - port is not open\n", __func__);
+		return;
+	}
+
+	val = (break_state == -1) ? 1 : 0;
+
+	status = qt2_control_msg(port-&gt;serial-&gt;dev, QT2_BREAK_CONTROL,
+				 val, port_priv-&gt;device_port);
+	if (status &lt; 0)
+		dev_warn(&amp;port-&gt;dev,
+			 "%s - failed to send control message: %i\n", __func__,
+			 status);
+}
+
+
+
+static void qt2_dtr_rts(struct usb_serial_port *port, int on)
+{
+	struct usb_device *dev = port-&gt;serial-&gt;dev;
+	struct qt2_port_private *port_priv = usb_get_serial_port_data(port);
+
+	mutex_lock(&amp;port-&gt;serial-&gt;disc_mutex);
+	if (!port-&gt;serial-&gt;disconnected) {
+		/* Disable flow control */
+		if (!on &amp;&amp; qt2_setregister(dev, port_priv-&gt;device_port,
+					   UART_MCR, 0) &lt; 0)
+			dev_warn(&amp;port-&gt;dev, "error from flowcontrol urb\n");
+		/* drop RTS and DTR */
+		if (on)
+			update_mctrl(port_priv, TIOCM_DTR | TIOCM_RTS, 0);
+		else
+			update_mctrl(port_priv, 0, TIOCM_DTR | TIOCM_RTS);
+	}
+	mutex_unlock(&amp;port-&gt;serial-&gt;disc_mutex);
+}
+
+static void qt2_update_msr(struct usb_serial_port *port, unsigned char *ch)
+{
+	struct qt2_port_private *port_priv;
+	u8 newMSR = (u8) *ch;
+	unsigned long flags;
+
+	port_priv = usb_get_serial_port_data(port);
+
+	spin_lock_irqsave(&amp;port_priv-&gt;lock, flags);
+	port_priv-&gt;shadowMSR = newMSR;
+	spin_unlock_irqrestore(&amp;port_priv-&gt;lock, flags);
+
+	if (newMSR &amp; UART_MSR_ANY_DELTA) {
+		/* update input line counters */
+		if (newMSR &amp; UART_MSR_DCTS)
+			port_priv-&gt;icount.cts++;
+
+		if (newMSR &amp; UART_MSR_DDSR)
+			port_priv-&gt;icount.dsr++;
+
+		if (newMSR &amp; UART_MSR_DDCD)
+			port_priv-&gt;icount.dcd++;
+
+		if (newMSR &amp; UART_MSR_TERI)
+			port_priv-&gt;icount.rng++;
+
+		wake_up_interruptible(&amp;port_priv-&gt;delta_msr_wait);
+	}
+}
+
+static void qt2_update_lsr(struct usb_serial_port *port, unsigned char *ch)
+{
+	struct qt2_port_private *port_priv;
+	struct async_icount *icount;
+	unsigned long flags;
+	u8 newLSR = (u8) *ch;
+
+	port_priv = usb_get_serial_port_data(port);
+
+	if (newLSR &amp; UART_LSR_BI)
+		newLSR &amp;= (u8) (UART_LSR_OE | UART_LSR_BI);
+
+	spin_lock_irqsave(&amp;port_priv-&gt;lock, flags);
+	port_priv-&gt;shadowLSR = newLSR;
+	spin_unlock_irqrestore(&amp;port_priv-&gt;lock, flags);
+
+	icount = &amp;port_priv-&gt;icount;
+
+	if (newLSR &amp; UART_LSR_BRK_ERROR_BITS) {
+
+		if (newLSR &amp; UART_LSR_BI)
+			icount-&gt;brk++;
+
+		if (newLSR &amp; UART_LSR_OE)
+			icount-&gt;overrun++;
+
+		if (newLSR &amp; UART_LSR_PE)
+			icount-&gt;parity++;
+
+		if (newLSR &amp; UART_LSR_FE)
+			icount-&gt;frame++;
+	}
+
+}
+
+static int qt2_write_room(struct tty_struct *tty)
+{
+	struct usb_serial_port *port = tty-&gt;driver_data;
+	struct qt2_port_private *port_priv;
+	unsigned long flags = 0;
+	int r;
+
+	port_priv = usb_get_serial_port_data(port);
+
+	spin_lock_irqsave(&amp;port_priv-&gt;urb_lock, flags);
+
+	if (port_priv-&gt;urb_in_use)
+		r = 0;
+	else
+		r = QT2_WRITE_BUFFER_SIZE - QT2_WRITE_CONTROL_SIZE;
+
+	spin_unlock_irqrestore(&amp;port_priv-&gt;urb_lock, flags);
+
+	return r;
+}
+
+static int qt2_write(struct tty_struct *tty,
+		     struct usb_serial_port *port,
+		     const unsigned char *buf, int count)
+{
+	struct qt2_port_private *port_priv;
+	struct urb *write_urb;
+	unsigned char *data;
+	unsigned long flags;
+	int status;
+	int bytes_out = 0;
+
+	port_priv = usb_get_serial_port_data(port);
+
+	if (port_priv-&gt;write_urb == NULL) {
+		dev_err(&amp;port-&gt;dev, "%s - no output urb\n", __func__);
+		return 0;
+	}
+	write_urb = port_priv-&gt;write_urb;
+
+	count = min(count, QT2_WRITE_BUFFER_SIZE - QT2_WRITE_CONTROL_SIZE);
+
+	data = write_urb-&gt;transfer_buffer;
+	spin_lock_irqsave(&amp;port_priv-&gt;urb_lock, flags);
+	if (port_priv-&gt;urb_in_use == true) {
+		printk(KERN_INFO "qt2_write - urb is in use\n");
+		goto write_out;
+	}
+
+	*data++ = QT2_CONTROL_BYTE;
+	*data++ = QT2_CONTROL_BYTE;
+	*data++ = port_priv-&gt;device_port;
+	put_unaligned_le16(count, data);
+	data += 2;
+	memcpy(data, buf, count);
+
+	write_urb-&gt;transfer_buffer_length = count + QT2_WRITE_CONTROL_SIZE;
+
+	status = usb_submit_urb(write_urb, GFP_ATOMIC);
+	if (status == 0) {
+		port_priv-&gt;urb_in_use = true;
+		bytes_out += count;
+	}
+
+write_out:
+	spin_unlock_irqrestore(&amp;port_priv-&gt;urb_lock, flags);
+	return bytes_out;
+}
+
+
+static struct usb_serial_driver qt2_device = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "quatech-serial",
+	},
+	.description	     = DRIVER_DESC,
+	.id_table	     = id_table,
+	.open		     = qt2_open,
+	.close		     = qt2_close,
+	.write               = qt2_write,
+	.write_room          = qt2_write_room,
+	.calc_num_ports      = qt2_calc_num_ports,
+	.attach              = qt2_attach,
+	.release             = qt2_release,
+	.disconnect          = qt2_disconnect,
+	.dtr_rts             = qt2_dtr_rts,
+	.break_ctl           = qt2_break_ctl,
+	.tiocmget            = qt2_tiocmget,
+	.tiocmset            = qt2_tiocmset,
+	.get_icount	     = qt2_get_icount,
+	.ioctl               = qt2_ioctl,
+	.set_termios         = qt2_set_termios,
+};
+
+static struct usb_serial_driver *const serial_drivers[] = {
+	&amp;qt2_device, NULL
+};
+
+module_usb_serial_driver(serial_drivers, id_table);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+
+module_param(debug, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Debug enabled or not");</pre><hr><pre>commit 7cbf3c7cd59288fb5e9f31815c74773549668d43
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Mon Aug 29 13:48:54 2011 -0400

    staging: serqt_usb2: remove ssu100 from supported devices
    
    The serqt_usb2 driver will not work properly with the ssu100 device
    even though it claims to support it.  The ssu100 is supported by the
    ssu100 driver in mainline so there is no need to have it claimed by
    serqt_usb2.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/serqt_usb2/serqt_usb2.c b/drivers/staging/serqt_usb2/serqt_usb2.c
index 2ea82c104d57..c44e41af2880 100644
--- a/drivers/staging/serqt_usb2/serqt_usb2.c
+++ b/drivers/staging/serqt_usb2/serqt_usb2.c
@@ -24,7 +24,6 @@ static int debug;
 #define DRIVER_DESC "Quatech USB to Serial Driver"
 
 #define	USB_VENDOR_ID_QUATECH			0x061d	/* Quatech VID */
-#define QUATECH_SSU100	0xC020	/* SSU100 */
 #define QUATECH_SSU200	0xC030	/* SSU200 */
 #define QUATECH_DSU100	0xC040	/* DSU100 */
 #define QUATECH_DSU200	0xC050	/* DSU200 */
@@ -127,7 +126,6 @@ static int debug;
 #define RS232_MODE          0x00
 
 static const struct usb_device_id serqt_id_table[] = {
-	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU100)},
 	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU200)},
 	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU100)},
 	{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU200)},
@@ -775,7 +773,6 @@ static int qt_startup(struct usb_serial *serial)
 	}
 
 	switch (serial-&gt;dev-&gt;descriptor.idProduct) {
-	case QUATECH_SSU100:
 	case QUATECH_DSU100:
 	case QUATECH_QSU100:
 	case QUATECH_ESU100A:</pre><hr><pre>commit f7043ecbb3f7b8632a6d6470f8f95160ac868d0f
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Thu Oct 21 14:43:05 2010 -0400

    USB: ssu100: remove max_packet_size calculation
    
    The max_packet_size logic is taken from ftdi_sio, but it's not needed
    for this device.  This also makes proces_read_urb simpler.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index f5312dd3331b..8359ec798959 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -79,7 +79,6 @@ struct ssu100_port_private {
 	u8 shadowLSR;
 	u8 shadowMSR;
 	wait_queue_head_t delta_msr_wait; /* Used for TIOCMIWAIT */
-	unsigned short max_packet_size;
 	struct async_icount icount;
 };
 
@@ -464,36 +463,6 @@ static int ssu100_ioctl(struct tty_struct *tty, struct file *file,
 	return -ENOIOCTLCMD;
 }
 
-static void ssu100_set_max_packet_size(struct usb_serial_port *port)
-{
-	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
-	struct usb_serial *serial = port-&gt;serial;
-	struct usb_device *udev = serial-&gt;dev;
-
-	struct usb_interface *interface = serial-&gt;interface;
-	struct usb_endpoint_descriptor *ep_desc = &amp;interface-&gt;cur_altsetting-&gt;endpoint[1].desc;
-
-	unsigned num_endpoints;
-	int i;
-	unsigned long flags;
-
-	num_endpoints = interface-&gt;cur_altsetting-&gt;desc.bNumEndpoints;
-	dev_info(&amp;udev-&gt;dev, "Number of endpoints %d\n", num_endpoints);
-
-	for (i = 0; i &lt; num_endpoints; i++) {
-		dev_info(&amp;udev-&gt;dev, "Endpoint %d MaxPacketSize %d\n", i+1,
-			interface-&gt;cur_altsetting-&gt;endpoint[i].desc.wMaxPacketSize);
-		ep_desc = &amp;interface-&gt;cur_altsetting-&gt;endpoint[i].desc;
-	}
-
-	/* set max packet size based on descriptor */
-	spin_lock_irqsave(&amp;priv-&gt;status_lock, flags);
-	priv-&gt;max_packet_size = ep_desc-&gt;wMaxPacketSize;
-	spin_unlock_irqrestore(&amp;priv-&gt;status_lock, flags);
-
-	dev_info(&amp;udev-&gt;dev, "Setting MaxPacketSize %d\n", priv-&gt;max_packet_size);
-}
-
 static int ssu100_attach(struct usb_serial *serial)
 {
 	struct ssu100_port_private *priv;
@@ -511,7 +480,6 @@ static int ssu100_attach(struct usb_serial *serial)
 	spin_lock_init(&amp;priv-&gt;status_lock);
 	init_waitqueue_head(&amp;priv-&gt;delta_msr_wait);
 	usb_set_serial_port_data(port, priv);
-	ssu100_set_max_packet_size(port);
 
 	return ssu100_initdevice(serial-&gt;dev);
 }
@@ -641,13 +609,14 @@ static void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,
 
 }
 
-static int ssu100_process_packet(struct tty_struct *tty,
-				 struct usb_serial_port *port,
-				 struct ssu100_port_private *priv,
-				 char *packet, int len)
+static int ssu100_process_packet(struct urb *urb,
+				 struct tty_struct *tty)
 {
-	int i;
+	struct usb_serial_port *port = urb-&gt;context;
+	char *packet = (char *)urb-&gt;transfer_buffer;
 	char flag = TTY_NORMAL;
+	u32 len = urb-&gt;actual_length;
+	int i;
 	char *ch;
 
 	dbg("%s - port %d", __func__, port-&gt;number);
@@ -685,12 +654,8 @@ static int ssu100_process_packet(struct tty_struct *tty,
 static void ssu100_process_read_urb(struct urb *urb)
 {
 	struct usb_serial_port *port = urb-&gt;context;
-	struct ssu100_port_private *priv = usb_get_serial_port_data(port);
-	char *data = (char *)urb-&gt;transfer_buffer;
 	struct tty_struct *tty;
-	int count = 0;
-	int i;
-	int len;
+	int count;
 
 	dbg("%s", __func__);
 
@@ -698,10 +663,7 @@ static void ssu100_process_read_urb(struct urb *urb)
 	if (!tty)
 		return;
 
-	for (i = 0; i &lt; urb-&gt;actual_length; i += priv-&gt;max_packet_size) {
-		len = min_t(int, urb-&gt;actual_length - i, priv-&gt;max_packet_size);
-		count += ssu100_process_packet(tty, port, priv, &amp;data[i], len);
-	}
+	count = ssu100_process_packet(urb, tty);
 
 	if (count)
 		tty_flip_buffer_push(tty);
@@ -717,8 +679,6 @@ static struct usb_serial_driver ssu100_device = {
 	.id_table	     = id_table,
 	.usb_driver	     = &amp;ssu100_driver,
 	.num_ports	     = 1,
-	.bulk_in_size        = 256,
-	.bulk_out_size       = 256,
 	.open		     = ssu100_open,
 	.close		     = ssu100_close,
 	.attach              = ssu100_attach,</pre><hr><pre>commit 50c1126ee1990920705a067a6f3f9bb892369b08
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Tue Aug 3 15:18:43 2010 -0400

    PCI: aerdrv: fix uninitialized variable warning
    
    quiet the warning about use of uninitialized e_src in
    aer_isr()  e_src is initialized by get_e_source()
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Jesse Barnes &lt;jbarnes@virtuousgeek.org&gt;

diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c
index 29e268fadf14..43421fbe080a 100644
--- a/drivers/pci/pcie/aer/aerdrv_core.c
+++ b/drivers/pci/pcie/aer/aerdrv_core.c
@@ -754,7 +754,7 @@ void aer_isr(struct work_struct *work)
 {
 	struct aer_rpc *rpc = container_of(work, struct aer_rpc, dpc_handler);
 	struct pcie_device *p_device = rpc-&gt;rpd;
-	struct aer_err_source e_src;
+	struct aer_err_source uninitialized_var(e_src);
 
 	mutex_lock(&amp;rpc-&gt;rpc_mutex);
 	while (get_e_source(rpc, &amp;e_src))</pre><hr><pre>commit 3c35b002da0c749ec15cf25cfe58f06aa230ae9c
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Wed Aug 25 18:21:23 2010 -0400

    USB: ssu100: turn off debug flag
    
    Remove the hard coding of the debug flag to 1.
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ssu100.c b/drivers/usb/serial/ssu100.c
index 68c18fdfc6da..e986002b3844 100644
--- a/drivers/usb/serial/ssu100.c
+++ b/drivers/usb/serial/ssu100.c
@@ -46,7 +46,7 @@
 #define FULLPWRBIT          0x00000080
 #define NEXT_BOARD_POWER_BIT        0x00000004
 
-static int debug = 1;
+static int debug;
 
 /* Version Information */
 #define DRIVER_VERSION "v0.1"</pre>
    <div class="pagination">
        <a href='3_39.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><span>[40]</span><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><a href='3_83.html'>83</a><a href='3_41.html'>Next&gt;&gt;</a>
    <div>
</body>
