<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <span>[1]</span><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 166fcf86cd34e15c7f383eda4642d7a212393008
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu May 30 13:17:33 2024 +0800

    ax25: Replace kfree() in ax25_dev_free() with ax25_dev_put()
    
    The object "ax25_dev" is managed by reference counting. Thus it should
    not be directly released by kfree(), replace with ax25_dev_put().
    
    Fixes: d01ffb9eee4a ("ax25: add refcount in ax25_dev to avoid UAF bugs")
    Suggested-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Link: https://lore.kernel.org/r/20240530051733.11416-1-duoming@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index 742d7c68e7e7..9efd6690b344 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -196,7 +196,7 @@ void __exit ax25_dev_free(void)
 	list_for_each_entry_safe(s, n, &amp;ax25_dev_list, list) {
 		netdev_put(s-&gt;dev, &amp;s-&gt;dev_tracker);
 		list_del(&amp;s-&gt;list);
-		kfree(s);
+		ax25_dev_put(s);
 	}
 	spin_unlock_bh(&amp;ax25_dev_lock);
 }</pre><hr><pre>commit ab904521f4de52fef4f179d2dfc1877645ef5f5c
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue May 21 15:50:59 2024 +0800

    wifi: cfg80211: pmsr: use correct nla_get_uX functions
    
    The commit 9bb7e0f24e7e ("cfg80211: add peer measurement with FTM
    initiator API") defines four attributes NL80211_PMSR_FTM_REQ_ATTR_
    {NUM_BURSTS_EXP}/{BURST_PERIOD}/{BURST_DURATION}/{FTMS_PER_BURST} in
    following ways.
    
    static const struct nla_policy
    nl80211_pmsr_ftm_req_attr_policy[NL80211_PMSR_FTM_REQ_ATTR_MAX + 1] = {
        ...
        [NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP] =
            NLA_POLICY_MAX(NLA_U8, 15),
        [NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD] = { .type = NLA_U16 },
        [NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION] =
            NLA_POLICY_MAX(NLA_U8, 15),
        [NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST] =
            NLA_POLICY_MAX(NLA_U8, 31),
        ...
    };
    
    That is, those attributes are expected to be NLA_U8 and NLA_U16 types.
    However, the consumers of these attributes in `pmsr_parse_ftm` blindly
    all use `nla_get_u32`, which is incorrect and causes functionality issues
    on little-endian platforms. Hence, fix them with the correct `nla_get_u8`
    and `nla_get_u16` functions.
    
    Fixes: 9bb7e0f24e7e ("cfg80211: add peer measurement with FTM initiator API")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Link: https://msgid.link/20240521075059.47999-1-linma@zju.edu.cn
    Signed-off-by: Johannes Berg &lt;johannes.berg@intel.com&gt;

diff --git a/net/wireless/pmsr.c b/net/wireless/pmsr.c
index e106dcea3977..c569c37da317 100644
--- a/net/wireless/pmsr.c
+++ b/net/wireless/pmsr.c
@@ -56,7 +56,7 @@ static int pmsr_parse_ftm(struct cfg80211_registered_device *rdev,
 	out-&gt;ftm.burst_period = 0;
 	if (tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD])
 		out-&gt;ftm.burst_period =
-			nla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD]);
+			nla_get_u16(tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD]);
 
 	out-&gt;ftm.asap = !!tb[NL80211_PMSR_FTM_REQ_ATTR_ASAP];
 	if (out-&gt;ftm.asap &amp;&amp; !capa-&gt;ftm.asap) {
@@ -75,7 +75,7 @@ static int pmsr_parse_ftm(struct cfg80211_registered_device *rdev,
 	out-&gt;ftm.num_bursts_exp = 0;
 	if (tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP])
 		out-&gt;ftm.num_bursts_exp =
-			nla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP]);
+			nla_get_u8(tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP]);
 
 	if (capa-&gt;ftm.max_bursts_exponent &gt;= 0 &amp;&amp;
 	    out-&gt;ftm.num_bursts_exp &gt; capa-&gt;ftm.max_bursts_exponent) {
@@ -88,7 +88,7 @@ static int pmsr_parse_ftm(struct cfg80211_registered_device *rdev,
 	out-&gt;ftm.burst_duration = 15;
 	if (tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION])
 		out-&gt;ftm.burst_duration =
-			nla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION]);
+			nla_get_u8(tb[NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION]);
 
 	out-&gt;ftm.ftms_per_burst = 0;
 	if (tb[NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST])
@@ -107,7 +107,7 @@ static int pmsr_parse_ftm(struct cfg80211_registered_device *rdev,
 	out-&gt;ftm.ftmr_retries = 3;
 	if (tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES])
 		out-&gt;ftm.ftmr_retries =
-			nla_get_u32(tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES]);
+			nla_get_u8(tb[NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES]);
 
 	out-&gt;ftm.request_lci = !!tb[NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI];
 	if (out-&gt;ftm.request_lci &amp;&amp; !capa-&gt;ftm.request_lci) {</pre><hr><pre>commit 36e56b1b002bb26440403053f19f9e1a8bc075b2
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu May 9 17:37:02 2024 +0800

    ax25: Fix reference count leak issue of net_device
    
    There is a reference count leak issue of the object "net_device" in
    ax25_dev_device_down(). When the ax25 device is shutting down, the
    ax25_dev_device_down() drops the reference count of net_device one
    or zero times depending on if we goto unlock_put or not, which will
    cause memory leak.
    
    In order to solve the above issue, decrease the reference count of
    net_device after dev-&gt;ax25_ptr is set to null.
    
    Fixes: d01ffb9eee4a ("ax25: add refcount in ax25_dev to avoid UAF bugs")
    Suggested-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Link: https://lore.kernel.org/r/7ce3b23a40d9084657ba1125432f0ecc380cbc80.1715247018.git.duoming@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index 52ccc37d5687..c9d55b99a7a5 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -118,15 +118,10 @@ void ax25_dev_device_down(struct net_device *dev)
 	list_for_each_entry(s, &amp;ax25_dev_list, list) {
 		if (s == ax25_dev) {
 			list_del(&amp;s-&gt;list);
-			goto unlock_put;
+			break;
 		}
 	}
-	dev-&gt;ax25_ptr = NULL;
-	spin_unlock_bh(&amp;ax25_dev_lock);
-	ax25_dev_put(ax25_dev);
-	return;
 
-unlock_put:
 	dev-&gt;ax25_ptr = NULL;
 	spin_unlock_bh(&amp;ax25_dev_lock);
 	netdev_put(dev, &amp;ax25_dev-&gt;dev_tracker);</pre><hr><pre>commit b505e0319852b08a3a716b64620168eab21f4ced
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu May 9 17:36:47 2024 +0800

    ax25: Fix reference count leak issues of ax25_dev
    
    The ax25_addr_ax25dev() and ax25_dev_device_down() exist a reference
    count leak issue of the object "ax25_dev".
    
    Memory leak issue in ax25_addr_ax25dev():
    
    The reference count of the object "ax25_dev" can be increased multiple
    times in ax25_addr_ax25dev(). This will cause a memory leak.
    
    Memory leak issues in ax25_dev_device_down():
    
    The reference count of ax25_dev is set to 1 in ax25_dev_device_up() and
    then increase the reference count when ax25_dev is added to ax25_dev_list.
    As a result, the reference count of ax25_dev is 2. But when the device is
    shutting down. The ax25_dev_device_down() drops the reference count once
    or twice depending on if we goto unlock_put or not, which will cause
    memory leak.
    
    As for the issue of ax25_addr_ax25dev(), it is impossible for one pointer
    to be on a list twice. So add a break in ax25_addr_ax25dev(). As for the
    issue of ax25_dev_device_down(), increase the reference count of ax25_dev
    once in ax25_dev_device_up() and decrease the reference count of ax25_dev
    after it is removed from the ax25_dev_list.
    
    Fixes: d01ffb9eee4a ("ax25: add refcount in ax25_dev to avoid UAF bugs")
    Suggested-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Link: https://lore.kernel.org/r/361bbf2a4b091e120006279ec3b382d73c4a0c17.1715247018.git.duoming@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index f16ee5c09d07..52ccc37d5687 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -39,6 +39,7 @@ ax25_dev *ax25_addr_ax25dev(ax25_address *addr)
 		if (ax25cmp(addr, (const ax25_address *)ax25_dev-&gt;dev-&gt;dev_addr) == 0) {
 			res = ax25_dev;
 			ax25_dev_hold(ax25_dev);
+			break;
 		}
 	spin_unlock_bh(&amp;ax25_dev_lock);
 
@@ -88,7 +89,6 @@ void ax25_dev_device_up(struct net_device *dev)
 	list_add(&amp;ax25_dev-&gt;list, &amp;ax25_dev_list);
 	dev-&gt;ax25_ptr     = ax25_dev;
 	spin_unlock_bh(&amp;ax25_dev_lock);
-	ax25_dev_hold(ax25_dev);
 
 	ax25_register_dev_sysctl(ax25_dev);
 }
@@ -129,7 +129,6 @@ void ax25_dev_device_down(struct net_device *dev)
 unlock_put:
 	dev-&gt;ax25_ptr = NULL;
 	spin_unlock_bh(&amp;ax25_dev_lock);
-	ax25_dev_put(ax25_dev);
 	netdev_put(dev, &amp;ax25_dev-&gt;dev_tracker);
 	ax25_dev_put(ax25_dev);
 }</pre><hr><pre>commit a7d6e36b9ad052926ba2ecba3a59d8bb67dabcb4
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu May 9 17:36:33 2024 +0800

    ax25: Use kernel universal linked list to implement ax25_dev_list
    
    The origin ax25_dev_list implements its own single linked list,
    which is complicated and error-prone. For example, when deleting
    the node of ax25_dev_list in ax25_dev_device_down(), we have to
    operate on the head node and other nodes separately.
    
    This patch uses kernel universal linked list to replace original
    ax25_dev_list, which make the operation of ax25_dev_list easier.
    
    We should do "dev-&gt;ax25_ptr = ax25_dev;" and "dev-&gt;ax25_ptr = NULL;"
    while holding the spinlock, otherwise the ax25_dev_device_up() and
    ax25_dev_device_down() could race.
    
    Suggested-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Dan Carpenter &lt;dan.carpenter@linaro.org&gt;
    Link: https://lore.kernel.org/r/85bba3af651ca0e1a519da8d0d715b949891171c.1715247018.git.duoming@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/include/net/ax25.h b/include/net/ax25.h
index 0d939e5aee4e..c2a85fd3f5ea 100644
--- a/include/net/ax25.h
+++ b/include/net/ax25.h
@@ -216,7 +216,7 @@ typedef struct {
 struct ctl_table;
 
 typedef struct ax25_dev {
-	struct ax25_dev		*next;
+	struct list_head	list;
 
 	struct net_device	*dev;
 	netdevice_tracker	dev_tracker;
@@ -330,7 +330,6 @@ int ax25_addr_size(const ax25_digi *);
 void ax25_digi_invert(const ax25_digi *, ax25_digi *);
 
 /* ax25_dev.c */
-extern ax25_dev *ax25_dev_list;
 extern spinlock_t ax25_dev_lock;
 
 #if IS_ENABLED(CONFIG_AX25)
diff --git a/net/ax25/ax25_dev.c b/net/ax25/ax25_dev.c
index 282ec581c072..f16ee5c09d07 100644
--- a/net/ax25/ax25_dev.c
+++ b/net/ax25/ax25_dev.c
@@ -22,11 +22,12 @@
 #include &lt;net/sock.h&gt;
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/fcntl.h&gt;
+#include &lt;linux/list.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/init.h&gt;
 
-ax25_dev *ax25_dev_list;
+static LIST_HEAD(ax25_dev_list);
 DEFINE_SPINLOCK(ax25_dev_lock);
 
 ax25_dev *ax25_addr_ax25dev(ax25_address *addr)
@@ -34,7 +35,7 @@ ax25_dev *ax25_addr_ax25dev(ax25_address *addr)
 	ax25_dev *ax25_dev, *res = NULL;
 
 	spin_lock_bh(&amp;ax25_dev_lock);
-	for (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev-&gt;next)
+	list_for_each_entry(ax25_dev, &amp;ax25_dev_list, list)
 		if (ax25cmp(addr, (const ax25_address *)ax25_dev-&gt;dev-&gt;dev_addr) == 0) {
 			res = ax25_dev;
 			ax25_dev_hold(ax25_dev);
@@ -59,7 +60,6 @@ void ax25_dev_device_up(struct net_device *dev)
 	}
 
 	refcount_set(&amp;ax25_dev-&gt;refcount, 1);
-	dev-&gt;ax25_ptr     = ax25_dev;
 	ax25_dev-&gt;dev     = dev;
 	netdev_hold(dev, &amp;ax25_dev-&gt;dev_tracker, GFP_KERNEL);
 	ax25_dev-&gt;forward = NULL;
@@ -85,8 +85,8 @@ void ax25_dev_device_up(struct net_device *dev)
 #endif
 
 	spin_lock_bh(&amp;ax25_dev_lock);
-	ax25_dev-&gt;next = ax25_dev_list;
-	ax25_dev_list  = ax25_dev;
+	list_add(&amp;ax25_dev-&gt;list, &amp;ax25_dev_list);
+	dev-&gt;ax25_ptr     = ax25_dev;
 	spin_unlock_bh(&amp;ax25_dev_lock);
 	ax25_dev_hold(ax25_dev);
 
@@ -111,32 +111,25 @@ void ax25_dev_device_down(struct net_device *dev)
 	/*
 	 *	Remove any packet forwarding that points to this device.
 	 */
-	for (s = ax25_dev_list; s != NULL; s = s-&gt;next)
+	list_for_each_entry(s, &amp;ax25_dev_list, list)
 		if (s-&gt;forward == dev)
 			s-&gt;forward = NULL;
 
-	if ((s = ax25_dev_list) == ax25_dev) {
-		ax25_dev_list = s-&gt;next;
-		goto unlock_put;
-	}
-
-	while (s != NULL &amp;&amp; s-&gt;next != NULL) {
-		if (s-&gt;next == ax25_dev) {
-			s-&gt;next = ax25_dev-&gt;next;
+	list_for_each_entry(s, &amp;ax25_dev_list, list) {
+		if (s == ax25_dev) {
+			list_del(&amp;s-&gt;list);
 			goto unlock_put;
 		}
-
-		s = s-&gt;next;
 	}
-	spin_unlock_bh(&amp;ax25_dev_lock);
 	dev-&gt;ax25_ptr = NULL;
+	spin_unlock_bh(&amp;ax25_dev_lock);
 	ax25_dev_put(ax25_dev);
 	return;
 
 unlock_put:
+	dev-&gt;ax25_ptr = NULL;
 	spin_unlock_bh(&amp;ax25_dev_lock);
 	ax25_dev_put(ax25_dev);
-	dev-&gt;ax25_ptr = NULL;
 	netdev_put(dev, &amp;ax25_dev-&gt;dev_tracker);
 	ax25_dev_put(ax25_dev);
 }
@@ -200,16 +193,13 @@ struct net_device *ax25_fwd_dev(struct net_device *dev)
  */
 void __exit ax25_dev_free(void)
 {
-	ax25_dev *s, *ax25_dev;
+	ax25_dev *s, *n;
 
 	spin_lock_bh(&amp;ax25_dev_lock);
-	ax25_dev = ax25_dev_list;
-	while (ax25_dev != NULL) {
-		s        = ax25_dev;
-		netdev_put(ax25_dev-&gt;dev, &amp;ax25_dev-&gt;dev_tracker);
-		ax25_dev = ax25_dev-&gt;next;
+	list_for_each_entry_safe(s, n, &amp;ax25_dev_list, list) {
+		netdev_put(s-&gt;dev, &amp;s-&gt;dev_tracker);
+		list_del(&amp;s-&gt;list);
 		kfree(s);
 	}
-	ax25_dev_list = NULL;
 	spin_unlock_bh(&amp;ax25_dev_lock);
 }</pre><hr><pre>commit 573601521277119f2e2ba5f28ae6e87fc594f4d4
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sun Mar 24 22:04:44 2024 +0800

    watchdog: cpu5wdt.c: Fix use-after-free bug caused by cpu5wdt_trigger
    
    When the cpu5wdt module is removing, the origin code uses del_timer() to
    de-activate the timer. If the timer handler is running, del_timer() could
    not stop it and will return directly. If the port region is released by
    release_region() and then the timer handler cpu5wdt_trigger() calls outb()
    to write into the region that is released, the use-after-free bug will
    happen.
    
    Change del_timer() to timer_shutdown_sync() in order that the timer handler
    could be finished before the port region is released.
    
    Fixes: e09d9c3e9f85 ("watchdog: cpu5wdt.c: add missing del_timer call")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Link: https://lore.kernel.org/r/20240324140444.119584-1-duoming@zju.edu.cn
    Signed-off-by: Guenter Roeck &lt;linux@roeck-us.net&gt;
    Signed-off-by: Wim Van Sebroeck &lt;wim@linux-watchdog.org&gt;

diff --git a/drivers/watchdog/cpu5wdt.c b/drivers/watchdog/cpu5wdt.c
index 688b112e712b..9f279c0e13a6 100644
--- a/drivers/watchdog/cpu5wdt.c
+++ b/drivers/watchdog/cpu5wdt.c
@@ -252,7 +252,7 @@ static void cpu5wdt_exit(void)
 	if (cpu5wdt_device.queue) {
 		cpu5wdt_device.queue = 0;
 		wait_for_completion(&amp;cpu5wdt_device.stop);
-		del_timer(&amp;cpu5wdt_device.timer);
+		timer_shutdown_sync(&amp;cpu5wdt_device.timer);
 	}
 
 	misc_deregister(&amp;cpu5wdt_misc);</pre><hr><pre>commit adf0398cee86643b8eacde95f17d073d022f782c
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu May 2 20:57:36 2024 +0800

    Bluetooth: l2cap: fix null-ptr-deref in l2cap_chan_timeout
    
    There is a race condition between l2cap_chan_timeout() and
    l2cap_chan_del(). When we use l2cap_chan_del() to delete the
    channel, the chan-&gt;conn will be set to null. But the conn could
    be dereferenced again in the mutex_lock() of l2cap_chan_timeout().
    As a result the null pointer dereference bug will happen. The
    KASAN report triggered by POC is shown below:
    
    [  472.074580] ==================================================================
    [  472.075284] BUG: KASAN: null-ptr-deref in mutex_lock+0x68/0xc0
    [  472.075308] Write of size 8 at addr 0000000000000158 by task kworker/0:0/7
    [  472.075308]
    [  472.075308] CPU: 0 PID: 7 Comm: kworker/0:0 Not tainted 6.9.0-rc5-00356-g78c0094a146b #36
    [  472.075308] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu4
    [  472.075308] Workqueue: events l2cap_chan_timeout
    [  472.075308] Call Trace:
    [  472.075308]  &lt;TASK&gt;
    [  472.075308]  dump_stack_lvl+0x137/0x1a0
    [  472.075308]  print_report+0x101/0x250
    [  472.075308]  ? __virt_addr_valid+0x77/0x160
    [  472.075308]  ? mutex_lock+0x68/0xc0
    [  472.075308]  kasan_report+0x139/0x170
    [  472.075308]  ? mutex_lock+0x68/0xc0
    [  472.075308]  kasan_check_range+0x2c3/0x2e0
    [  472.075308]  mutex_lock+0x68/0xc0
    [  472.075308]  l2cap_chan_timeout+0x181/0x300
    [  472.075308]  process_one_work+0x5d2/0xe00
    [  472.075308]  worker_thread+0xe1d/0x1660
    [  472.075308]  ? pr_cont_work+0x5e0/0x5e0
    [  472.075308]  kthread+0x2b7/0x350
    [  472.075308]  ? pr_cont_work+0x5e0/0x5e0
    [  472.075308]  ? kthread_blkcg+0xd0/0xd0
    [  472.075308]  ret_from_fork+0x4d/0x80
    [  472.075308]  ? kthread_blkcg+0xd0/0xd0
    [  472.075308]  ret_from_fork_asm+0x11/0x20
    [  472.075308]  &lt;/TASK&gt;
    [  472.075308] ==================================================================
    [  472.094860] Disabling lock debugging due to kernel taint
    [  472.096136] BUG: kernel NULL pointer dereference, address: 0000000000000158
    [  472.096136] #PF: supervisor write access in kernel mode
    [  472.096136] #PF: error_code(0x0002) - not-present page
    [  472.096136] PGD 0 P4D 0
    [  472.096136] Oops: 0002 [#1] PREEMPT SMP KASAN NOPTI
    [  472.096136] CPU: 0 PID: 7 Comm: kworker/0:0 Tainted: G    B              6.9.0-rc5-00356-g78c0094a146b #36
    [  472.096136] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu4
    [  472.096136] Workqueue: events l2cap_chan_timeout
    [  472.096136] RIP: 0010:mutex_lock+0x88/0xc0
    [  472.096136] Code: be 08 00 00 00 e8 f8 23 1f fd 4c 89 f7 be 08 00 00 00 e8 eb 23 1f fd 42 80 3c 23 00 74 08 48 88
    [  472.096136] RSP: 0018:ffff88800744fc78 EFLAGS: 00000246
    [  472.096136] RAX: 0000000000000000 RBX: 1ffff11000e89f8f RCX: ffffffff8457c865
    [  472.096136] RDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff88800744fc78
    [  472.096136] RBP: 0000000000000158 R08: ffff88800744fc7f R09: 1ffff11000e89f8f
    [  472.096136] R10: dffffc0000000000 R11: ffffed1000e89f90 R12: dffffc0000000000
    [  472.096136] R13: 0000000000000158 R14: ffff88800744fc78 R15: ffff888007405a00
    [  472.096136] FS:  0000000000000000(0000) GS:ffff88806d200000(0000) knlGS:0000000000000000
    [  472.096136] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  472.096136] CR2: 0000000000000158 CR3: 000000000da32000 CR4: 00000000000006f0
    [  472.096136] Call Trace:
    [  472.096136]  &lt;TASK&gt;
    [  472.096136]  ? __die_body+0x8d/0xe0
    [  472.096136]  ? page_fault_oops+0x6b8/0x9a0
    [  472.096136]  ? kernelmode_fixup_or_oops+0x20c/0x2a0
    [  472.096136]  ? do_user_addr_fault+0x1027/0x1340
    [  472.096136]  ? _printk+0x7a/0xa0
    [  472.096136]  ? mutex_lock+0x68/0xc0
    [  472.096136]  ? add_taint+0x42/0xd0
    [  472.096136]  ? exc_page_fault+0x6a/0x1b0
    [  472.096136]  ? asm_exc_page_fault+0x26/0x30
    [  472.096136]  ? mutex_lock+0x75/0xc0
    [  472.096136]  ? mutex_lock+0x88/0xc0
    [  472.096136]  ? mutex_lock+0x75/0xc0
    [  472.096136]  l2cap_chan_timeout+0x181/0x300
    [  472.096136]  process_one_work+0x5d2/0xe00
    [  472.096136]  worker_thread+0xe1d/0x1660
    [  472.096136]  ? pr_cont_work+0x5e0/0x5e0
    [  472.096136]  kthread+0x2b7/0x350
    [  472.096136]  ? pr_cont_work+0x5e0/0x5e0
    [  472.096136]  ? kthread_blkcg+0xd0/0xd0
    [  472.096136]  ret_from_fork+0x4d/0x80
    [  472.096136]  ? kthread_blkcg+0xd0/0xd0
    [  472.096136]  ret_from_fork_asm+0x11/0x20
    [  472.096136]  &lt;/TASK&gt;
    [  472.096136] Modules linked in:
    [  472.096136] CR2: 0000000000000158
    [  472.096136] ---[ end trace 0000000000000000 ]---
    [  472.096136] RIP: 0010:mutex_lock+0x88/0xc0
    [  472.096136] Code: be 08 00 00 00 e8 f8 23 1f fd 4c 89 f7 be 08 00 00 00 e8 eb 23 1f fd 42 80 3c 23 00 74 08 48 88
    [  472.096136] RSP: 0018:ffff88800744fc78 EFLAGS: 00000246
    [  472.096136] RAX: 0000000000000000 RBX: 1ffff11000e89f8f RCX: ffffffff8457c865
    [  472.096136] RDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff88800744fc78
    [  472.096136] RBP: 0000000000000158 R08: ffff88800744fc7f R09: 1ffff11000e89f8f
    [  472.132932] R10: dffffc0000000000 R11: ffffed1000e89f90 R12: dffffc0000000000
    [  472.132932] R13: 0000000000000158 R14: ffff88800744fc78 R15: ffff888007405a00
    [  472.132932] FS:  0000000000000000(0000) GS:ffff88806d200000(0000) knlGS:0000000000000000
    [  472.132932] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  472.132932] CR2: 0000000000000158 CR3: 000000000da32000 CR4: 00000000000006f0
    [  472.132932] Kernel panic - not syncing: Fatal exception
    [  472.132932] Kernel Offset: disabled
    [  472.132932] ---[ end Kernel panic - not syncing: Fatal exception ]---
    
    Add a check to judge whether the conn is null in l2cap_chan_timeout()
    in order to mitigate the bug.
    
    Fixes: 3df91ea20e74 ("Bluetooth: Revert to mutexes from RCU list")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: Luiz Augusto von Dentz &lt;luiz.von.dentz@intel.com&gt;

diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c
index 868a370a16aa..9223b1a698e3 100644
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@ -415,6 +415,9 @@ static void l2cap_chan_timeout(struct work_struct *work)
 
 	BT_DBG("chan %p state %s", chan, state_to_string(chan-&gt;state));
 
+	if (!conn)
+		return;
+
 	mutex_lock(&amp;conn-&gt;chan_lock);
 	/* __set_chan_timer() calls l2cap_chan_hold(chan) while scheduling
 	 * this work. No need to call l2cap_chan_hold(chan) here again.</pre><hr><pre>commit 483bc08181827fc475643272ffb69c533007e546
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu Apr 25 22:23:45 2024 +0800

    Bluetooth: Fix use-after-free bugs caused by sco_sock_timeout
    
    When the sco connection is established and then, the sco socket
    is releasing, timeout_work will be scheduled to judge whether
    the sco disconnection is timeout. The sock will be deallocated
    later, but it is dereferenced again in sco_sock_timeout. As a
    result, the use-after-free bugs will happen. The root cause is
    shown below:
    
        Cleanup Thread               |      Worker Thread
    sco_sock_release                 |
      sco_sock_close                 |
        __sco_sock_close             |
          sco_sock_set_timer         |
            schedule_delayed_work    |
      sco_sock_kill                  |    (wait a time)
        sock_put(sk) //FREE          |  sco_sock_timeout
                                     |    sock_hold(sk) //USE
    
    The KASAN report triggered by POC is shown below:
    
    [   95.890016] ==================================================================
    [   95.890496] BUG: KASAN: slab-use-after-free in sco_sock_timeout+0x5e/0x1c0
    [   95.890755] Write of size 4 at addr ffff88800c388080 by task kworker/0:0/7
    ...
    [   95.890755] Workqueue: events sco_sock_timeout
    [   95.890755] Call Trace:
    [   95.890755]  &lt;TASK&gt;
    [   95.890755]  dump_stack_lvl+0x45/0x110
    [   95.890755]  print_address_description+0x78/0x390
    [   95.890755]  print_report+0x11b/0x250
    [   95.890755]  ? __virt_addr_valid+0xbe/0xf0
    [   95.890755]  ? sco_sock_timeout+0x5e/0x1c0
    [   95.890755]  kasan_report+0x139/0x170
    [   95.890755]  ? update_load_avg+0xe5/0x9f0
    [   95.890755]  ? sco_sock_timeout+0x5e/0x1c0
    [   95.890755]  kasan_check_range+0x2c3/0x2e0
    [   95.890755]  sco_sock_timeout+0x5e/0x1c0
    [   95.890755]  process_one_work+0x561/0xc50
    [   95.890755]  worker_thread+0xab2/0x13c0
    [   95.890755]  ? pr_cont_work+0x490/0x490
    [   95.890755]  kthread+0x279/0x300
    [   95.890755]  ? pr_cont_work+0x490/0x490
    [   95.890755]  ? kthread_blkcg+0xa0/0xa0
    [   95.890755]  ret_from_fork+0x34/0x60
    [   95.890755]  ? kthread_blkcg+0xa0/0xa0
    [   95.890755]  ret_from_fork_asm+0x11/0x20
    [   95.890755]  &lt;/TASK&gt;
    [   95.890755]
    [   95.890755] Allocated by task 506:
    [   95.890755]  kasan_save_track+0x3f/0x70
    [   95.890755]  __kasan_kmalloc+0x86/0x90
    [   95.890755]  __kmalloc+0x17f/0x360
    [   95.890755]  sk_prot_alloc+0xe1/0x1a0
    [   95.890755]  sk_alloc+0x31/0x4e0
    [   95.890755]  bt_sock_alloc+0x2b/0x2a0
    [   95.890755]  sco_sock_create+0xad/0x320
    [   95.890755]  bt_sock_create+0x145/0x320
    [   95.890755]  __sock_create+0x2e1/0x650
    [   95.890755]  __sys_socket+0xd0/0x280
    [   95.890755]  __x64_sys_socket+0x75/0x80
    [   95.890755]  do_syscall_64+0xc4/0x1b0
    [   95.890755]  entry_SYSCALL_64_after_hwframe+0x67/0x6f
    [   95.890755]
    [   95.890755] Freed by task 506:
    [   95.890755]  kasan_save_track+0x3f/0x70
    [   95.890755]  kasan_save_free_info+0x40/0x50
    [   95.890755]  poison_slab_object+0x118/0x180
    [   95.890755]  __kasan_slab_free+0x12/0x30
    [   95.890755]  kfree+0xb2/0x240
    [   95.890755]  __sk_destruct+0x317/0x410
    [   95.890755]  sco_sock_release+0x232/0x280
    [   95.890755]  sock_close+0xb2/0x210
    [   95.890755]  __fput+0x37f/0x770
    [   95.890755]  task_work_run+0x1ae/0x210
    [   95.890755]  get_signal+0xe17/0xf70
    [   95.890755]  arch_do_signal_or_restart+0x3f/0x520
    [   95.890755]  syscall_exit_to_user_mode+0x55/0x120
    [   95.890755]  do_syscall_64+0xd1/0x1b0
    [   95.890755]  entry_SYSCALL_64_after_hwframe+0x67/0x6f
    [   95.890755]
    [   95.890755] The buggy address belongs to the object at ffff88800c388000
    [   95.890755]  which belongs to the cache kmalloc-1k of size 1024
    [   95.890755] The buggy address is located 128 bytes inside of
    [   95.890755]  freed 1024-byte region [ffff88800c388000, ffff88800c388400)
    [   95.890755]
    [   95.890755] The buggy address belongs to the physical page:
    [   95.890755] page: refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff88800c38a800 pfn:0xc388
    [   95.890755] head: order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0
    [   95.890755] anon flags: 0x100000000000840(slab|head|node=0|zone=1)
    [   95.890755] page_type: 0xffffffff()
    [   95.890755] raw: 0100000000000840 ffff888006842dc0 0000000000000000 0000000000000001
    [   95.890755] raw: ffff88800c38a800 000000000010000a 00000001ffffffff 0000000000000000
    [   95.890755] head: 0100000000000840 ffff888006842dc0 0000000000000000 0000000000000001
    [   95.890755] head: ffff88800c38a800 000000000010000a 00000001ffffffff 0000000000000000
    [   95.890755] head: 0100000000000003 ffffea000030e201 ffffea000030e248 00000000ffffffff
    [   95.890755] head: 0000000800000000 0000000000000000 00000000ffffffff 0000000000000000
    [   95.890755] page dumped because: kasan: bad access detected
    [   95.890755]
    [   95.890755] Memory state around the buggy address:
    [   95.890755]  ffff88800c387f80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc
    [   95.890755]  ffff88800c388000: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [   95.890755] &gt;ffff88800c388080: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [   95.890755]                    ^
    [   95.890755]  ffff88800c388100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [   95.890755]  ffff88800c388180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb
    [   95.890755] ==================================================================
    
    Fix this problem by adding a check protected by sco_conn_lock to judget
    whether the conn-&gt;hcon is null. Because the conn-&gt;hcon will be set to null,
    when the sock is releasing.
    
    Fixes: ba316be1b6a0 ("Bluetooth: schedule SCO timeouts with delayed_work")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Signed-off-by: Luiz Augusto von Dentz &lt;luiz.von.dentz@intel.com&gt;

diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c
index 5d03c5440b06..e0ad30862ee4 100644
--- a/net/bluetooth/sco.c
+++ b/net/bluetooth/sco.c
@@ -83,6 +83,10 @@ static void sco_sock_timeout(struct work_struct *work)
 	struct sock *sk;
 
 	sco_conn_lock(conn);
+	if (!conn-&gt;hcon) {
+		sco_conn_unlock(conn);
+		return;
+	}
 	sk = conn-&gt;sk;
 	if (sk)
 		sock_hold(sk);</pre><hr><pre>commit e6f7d27df5d208b50cae817a91d128fb434bb12c
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Sun Mar 3 18:57:29 2024 +0800

    PCI: of_property: Return error for int_map allocation failure
    
    Return -ENOMEM from of_pci_prop_intr_map() if kcalloc() fails to prevent a
    NULL pointer dereference in this case.
    
    Fixes: 407d1a51921e ("PCI: Create device tree node for bridge")
    Link: https://lore.kernel.org/r/20240303105729.78624-1-duoming@zju.edu.cn
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    [bhelgaas: commit log]
    Signed-off-by: Bjorn Helgaas &lt;bhelgaas@google.com&gt;

diff --git a/drivers/pci/of_property.c b/drivers/pci/of_property.c
index c2c7334152bc..03539e505372 100644
--- a/drivers/pci/of_property.c
+++ b/drivers/pci/of_property.c
@@ -238,6 +238,8 @@ static int of_pci_prop_intr_map(struct pci_dev *pdev, struct of_changeset *ocs,
 		return 0;
 
 	int_map = kcalloc(map_sz, sizeof(u32), GFP_KERNEL);
+	if (!int_map)
+		return -ENOMEM;
 	mapp = int_map;
 
 	list_for_each_entry(child, &amp;pdev-&gt;subordinate-&gt;devices, bus_list) {</pre><hr><pre>commit c2af060d1c18beaec56351cf9c9bcbbc5af341a3
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Tue Mar 12 08:59:05 2024 +0800

    lib/test_hmm.c: handle src_pfns and dst_pfns allocation failure
    
    The kcalloc() in dmirror_device_evict_chunk() will return null if the
    physical memory has run out.  As a result, if src_pfns or dst_pfns is
    dereferenced, the null pointer dereference bug will happen.
    
    Moreover, the device is going away.  If the kcalloc() fails, the pages
    mapping a chunk could not be evicted.  So add a __GFP_NOFAIL flag in
    kcalloc().
    
    Finally, as there is no need to have physically contiguous memory, Switch
    kcalloc() to kvcalloc() in order to avoid failing allocations.
    
    Link: https://lkml.kernel.org/r/20240312005905.9939-1-duoming@zju.edu.cn
    Fixes: b2ef9f5a5cb3 ("mm/hmm/test: add selftest driver for HMM")
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Cc: Jérôme Glisse &lt;jglisse@redhat.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/lib/test_hmm.c b/lib/test_hmm.c
index 717dcb830127..b823ba7cb6a1 100644
--- a/lib/test_hmm.c
+++ b/lib/test_hmm.c
@@ -1226,8 +1226,8 @@ static void dmirror_device_evict_chunk(struct dmirror_chunk *chunk)
 	unsigned long *src_pfns;
 	unsigned long *dst_pfns;
 
-	src_pfns = kcalloc(npages, sizeof(*src_pfns), GFP_KERNEL);
-	dst_pfns = kcalloc(npages, sizeof(*dst_pfns), GFP_KERNEL);
+	src_pfns = kvcalloc(npages, sizeof(*src_pfns), GFP_KERNEL | __GFP_NOFAIL);
+	dst_pfns = kvcalloc(npages, sizeof(*dst_pfns), GFP_KERNEL | __GFP_NOFAIL);
 
 	migrate_device_range(src_pfns, start_pfn, npages);
 	for (i = 0; i &lt; npages; i++) {
@@ -1250,8 +1250,8 @@ static void dmirror_device_evict_chunk(struct dmirror_chunk *chunk)
 	}
 	migrate_device_pages(src_pfns, dst_pfns, npages);
 	migrate_device_finalize(src_pfns, dst_pfns, npages);
-	kfree(src_pfns);
-	kfree(dst_pfns);
+	kvfree(src_pfns);
+	kvfree(dst_pfns);
 }
 
 /* Removes free pages from the free list so they can't be re-allocated */</pre>
    <div class="pagination">
        <span>[1]</span><a href='6_2.html'>2</a><a href='6_3.html'>3</a><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_2.html'>Next&gt;&gt;</a>
    <div>
</body>
