<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_32.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><span>[33]</span><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_34.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 9d91cdcc0cce3186742f38e7352459b2087fbb86
Author: David M. Richter &lt;richterd@citi.umich.edu&gt;
Date:   Wed Apr 23 16:29:02 2008 -0400

    leases: remove unneeded variable from fcntl_setlease().
    
    fcntl_setlease() has a struct dentry* that is used only once; this patch
    removes it.
    
    Signed-off-by: David M. Richter &lt;richterd@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 6a132cd4fa57..2e0fa661e423 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1493,8 +1493,7 @@ EXPORT_SYMBOL_GPL(vfs_setlease);
 int fcntl_setlease(unsigned int fd, struct file *filp, long arg)
 {
 	struct file_lock fl, *flp = &amp;fl;
-	struct dentry *dentry = filp-&gt;f_path.dentry;
-	struct inode *inode = dentry-&gt;d_inode;
+	struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 	int error;
 
 	locks_init_lock(&amp;fl);</pre><hr><pre>commit 190855576743a510219fc67886dace29b825d8cb
Author: David M. Richter &lt;richterd@citi.umich.edu&gt;
Date:   Wed Apr 23 16:29:01 2008 -0400

    leases: move lock allocation earlier in generic_setlease()
    
    In generic_setlease(), the struct file_lock is allocated after tests for the
    presence of conflicting readers/writers is done, despite the fact that the
    allocation might block; this patch moves the allocation earlier.  A subsequent
    set of patches will rely on this behavior to properly serialize between a
    modified __break_lease() and generic_setlease().
    
    Signed-off-by: David M. Richter &lt;richterd@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index da1d0ddb4abd..6a132cd4fa57 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1368,6 +1368,11 @@ int generic_setlease(struct file *filp, long arg, struct file_lock **flp)
 	lease = *flp;
 
 	if (arg != F_UNLCK) {
+		error = -ENOMEM;
+		new_fl = locks_alloc_lock();
+		if (new_fl == NULL)
+			goto out;
+
 		error = -EAGAIN;
 		if ((arg == F_RDLCK) &amp;&amp; (atomic_read(&amp;inode-&gt;i_writecount) &gt; 0))
 			goto out;
@@ -1375,11 +1380,6 @@ int generic_setlease(struct file *filp, long arg, struct file_lock **flp)
 		    &amp;&amp; ((atomic_read(&amp;dentry-&gt;d_count) &gt; 1)
 			|| (atomic_read(&amp;inode-&gt;i_count) &gt; 1)))
 			goto out;
-
-		error = -ENOMEM;
-		new_fl = locks_alloc_lock();
-		if (new_fl == NULL)
-			goto out;
 	}
 
 	/*</pre><hr><pre>commit 288b2fd8251cb0bcb14b8a93755ef9c78de70e0f
Author: David M. Richter &lt;richterd@citi.umich.edu&gt;
Date:   Wed Apr 23 16:29:00 2008 -0400

    leases: when unlocking, skip locking-related steps
    
    In generic_setlease(), we don't need to allocate a new struct file_lock
    or check for readers or writers when called with F_UNLCK.
    
    Signed-off-by: David M. Richter &lt;richterd@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index b9f3a0bed300..da1d0ddb4abd 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1367,18 +1367,20 @@ int generic_setlease(struct file *filp, long arg, struct file_lock **flp)
 
 	lease = *flp;
 
-	error = -EAGAIN;
-	if ((arg == F_RDLCK) &amp;&amp; (atomic_read(&amp;inode-&gt;i_writecount) &gt; 0))
-		goto out;
-	if ((arg == F_WRLCK)
-	    &amp;&amp; ((atomic_read(&amp;dentry-&gt;d_count) &gt; 1)
-		|| (atomic_read(&amp;inode-&gt;i_count) &gt; 1)))
-		goto out;
+	if (arg != F_UNLCK) {
+		error = -EAGAIN;
+		if ((arg == F_RDLCK) &amp;&amp; (atomic_read(&amp;inode-&gt;i_writecount) &gt; 0))
+			goto out;
+		if ((arg == F_WRLCK)
+		    &amp;&amp; ((atomic_read(&amp;dentry-&gt;d_count) &gt; 1)
+			|| (atomic_read(&amp;inode-&gt;i_count) &gt; 1)))
+			goto out;
 
-	error = -ENOMEM;
-	new_fl = locks_alloc_lock();
-	if (new_fl == NULL)
-		goto out;
+		error = -ENOMEM;
+		new_fl = locks_alloc_lock();
+		if (new_fl == NULL)
+			goto out;
+	}
 
 	/*
 	 * At this point, we know that if there is an exclusive</pre><hr><pre>commit 5fcc60c3a05bf417229fba715e7aec52bf6717fb
Author: David M. Richter &lt;richterd@citi.umich.edu&gt;
Date:   Wed Apr 23 16:28:59 2008 -0400

    leases: fix a return-value mixup
    
    Fixes a return-value mixup from 85c59580b30c82aa771aa33b37217a6b6851bc14
    "locks: Fix potential OOPS in generic_setlease()", in which -ENOMEM replaced
    what had been intended to stay -EAGAIN in the variable "error".
    
    Signed-off-by: David M. Richter &lt;richterd@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/locks.c b/fs/locks.c
index 592faadbcec1..b9f3a0bed300 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -1404,6 +1404,7 @@ int generic_setlease(struct file *filp, long arg, struct file_lock **flp)
 			rdlease_count++;
 	}
 
+	error = -EAGAIN;
 	if ((arg == F_RDLCK &amp;&amp; (wrlease_count &gt; 0)) ||
 	    (arg == F_WRLCK &amp;&amp; ((rdlease_count + wrlease_count) &gt; 0)))
 		goto out;</pre><hr><pre>commit ff7d9756b501744540be65e172d27ee321d86103
Author: Olga Kornievskaia &lt;aglo@citi.umich.edu&gt;
Date:   Fri Mar 28 16:04:56 2008 -0400

    nfsd: use static memory for callback program and stats
    
    There's no need to dynamically allocate this memory, and doing so may
    create the possibility of races on shutdown of the rpc client.  (We've
    witnessed it only after adding rpcsec_gss support to the server, after
    which the rpc code can send destroys calls that expect to still be able
    to access the rpc_stats structure after it has been destroyed.)
    
    Such races are in theory possible if the module containing this "static"
    memory is removed very quickly after an rpc client is destroyed, but
    we haven't seen that happen.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index aae2b29ae2c9..562abf3380d0 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -344,6 +344,21 @@ static struct rpc_version *	nfs_cb_version[] = {
 	&amp;nfs_cb_version4,
 };
 
+static struct rpc_program cb_program;
+
+static struct rpc_stat cb_stats = {
+		.program	= &amp;cb_program
+};
+
+#define NFS4_CALLBACK 0x40000000
+static struct rpc_program cb_program = {
+		.name 		= "nfs4_cb",
+		.number		= NFS4_CALLBACK,
+		.nrvers		= ARRAY_SIZE(nfs_cb_version),
+		.version	= nfs_cb_version,
+		.stats		= &amp;cb_stats,
+};
+
 /* Reference counting, callback cleanup, etc., all look racy as heck.
  * And why is cb_set an atomic? */
 
@@ -358,13 +373,12 @@ static int do_probe_callback(void *data)
 		.to_maxval	= (NFSD_LEASE_TIME/2) * HZ,
 		.to_exponential	= 1,
 	};
-	struct rpc_program *	program = &amp;cb-&gt;cb_program;
 	struct rpc_create_args args = {
 		.protocol	= IPPROTO_TCP,
 		.address	= (struct sockaddr *)&amp;addr,
 		.addrsize	= sizeof(addr),
 		.timeout	= &amp;timeparms,
-		.program	= program,
+		.program	= &amp;cb_program,
 		.version	= nfs_cb_version[1]-&gt;number,
 		.authflavor	= RPC_AUTH_UNIX, /* XXX: need AUTH_GSS... */
 		.flags		= (RPC_CLNT_CREATE_NOPING),
@@ -382,16 +396,8 @@ static int do_probe_callback(void *data)
 	addr.sin_port = htons(cb-&gt;cb_port);
 	addr.sin_addr.s_addr = htonl(cb-&gt;cb_addr);
 
-	/* Initialize rpc_program */
-	program-&gt;name = "nfs4_cb";
-	program-&gt;number = cb-&gt;cb_prog;
-	program-&gt;nrvers = ARRAY_SIZE(nfs_cb_version);
-	program-&gt;version = nfs_cb_version;
-	program-&gt;stats = &amp;cb-&gt;cb_stat;
-
 	/* Initialize rpc_stat */
-	memset(program-&gt;stats, 0, sizeof(cb-&gt;cb_stat));
-	program-&gt;stats-&gt;program = program;
+	memset(args.program-&gt;stats, 0, sizeof(struct rpc_stat));
 
 	/* Create RPC client */
 	client = rpc_create(&amp;args);</pre><hr><pre>commit e1ba1ab76e68de9f4a93fae8406627924efaed99
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Apr 7 13:09:47 2008 -0400

    nfsd: fix comment
    
    Obvious comment nit.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c
index 2e5de77ff030..a9f153867554 100644
--- a/fs/nfs/callback.c
+++ b/fs/nfs/callback.c
@@ -153,7 +153,7 @@ int nfs_callback_up(void)
 }
 
 /*
- * Kill the server process if it is not already up.
+ * Kill the server process if it is not already down.
  */
 void nfs_callback_down(void)
 {</pre><hr><pre>commit 3c61eecb607dbc2777074b1a95b8a97e31a96a73
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Apr 7 13:05:27 2008 -0400

    lockd: Fix stale nlmsvc_unlink_block comment
    
    As of 5996a298da43a03081e9ba2116983d173001c862 ("NLM: don't unlock on
    cancel requests") we no longer unlock in this case, so the comment is no
    longer accurate.
    
    Thanks to Stuart Friedberg for pointing out the inconsistency.
    
    Cc: Stuart Friedberg &lt;sfriedberg@hp.com&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.c
index 4da7c4c27064..1f122c1940af 100644
--- a/fs/lockd/svclock.c
+++ b/fs/lockd/svclock.c
@@ -227,8 +227,7 @@ nlmsvc_create_block(struct svc_rqst *rqstp, struct nlm_host *host,
 }
 
 /*
- * Delete a block. If the lock was cancelled or the grant callback
- * failed, unlock is set to 1.
+ * Delete a block.
  * It is the caller's responsibility to check whether the file
  * can be closed hereafter.
  */</pre><hr><pre>commit 4ab4b0bedda7d41c63cef98cd5d6cabada460936
Author: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
Date:   Mon Mar 31 10:31:44 2008 -0400

    sunrpc: make token header values less confusing
    
    g_make_token_header() and g_token_size() add two too many, and
    therefore their callers pass in "(logical_value - 2)" rather
    than "logical_value" as hard-coded values which causes confusion.
    
    This dates back to the original g_make_token_header which took an
    optional token type (token_id) value and added it to the token.
    This was removed, but the routine always adds room for the token_id
    rather than not.
    
    Signed-off-by: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/net/sunrpc/auth_gss/gss_generic_token.c b/net/sunrpc/auth_gss/gss_generic_token.c
index ea8c92ecdae5..d83b881685fe 100644
--- a/net/sunrpc/auth_gss/gss_generic_token.c
+++ b/net/sunrpc/auth_gss/gss_generic_token.c
@@ -148,7 +148,7 @@ int
 g_token_size(struct xdr_netobj *mech, unsigned int body_size)
 {
 	/* set body_size to sequence contents size */
-	body_size += 4 + (int) mech-&gt;len;         /* NEED overflow check */
+	body_size += 2 + (int) mech-&gt;len;         /* NEED overflow check */
 	return(1 + der_length_size(body_size) + body_size);
 }
 
@@ -161,7 +161,7 @@ void
 g_make_token_header(struct xdr_netobj *mech, int body_size, unsigned char **buf)
 {
 	*(*buf)++ = 0x60;
-	der_write_length(buf, 4 + mech-&gt;len + body_size);
+	der_write_length(buf, 2 + mech-&gt;len + body_size);
 	*(*buf)++ = 0x06;
 	*(*buf)++ = (unsigned char) mech-&gt;len;
 	TWRITE_STR(*buf, mech-&gt;data, ((int) mech-&gt;len));
diff --git a/net/sunrpc/auth_gss/gss_krb5_seal.c b/net/sunrpc/auth_gss/gss_krb5_seal.c
index 8e3c87df5836..5f1d36dfbcf7 100644
--- a/net/sunrpc/auth_gss/gss_krb5_seal.c
+++ b/net/sunrpc/auth_gss/gss_krb5_seal.c
@@ -87,10 +87,10 @@ gss_get_mic_kerberos(struct gss_ctx *gss_ctx, struct xdr_buf *text,
 
 	now = get_seconds();
 
-	token-&gt;len = g_token_size(&amp;ctx-&gt;mech_used, 22);
+	token-&gt;len = g_token_size(&amp;ctx-&gt;mech_used, 24);
 
 	ptr = token-&gt;data;
-	g_make_token_header(&amp;ctx-&gt;mech_used, 22, &amp;ptr);
+	g_make_token_header(&amp;ctx-&gt;mech_used, 24, &amp;ptr);
 
 	*ptr++ = (unsigned char) ((KG_TOK_MIC_MSG&gt;&gt;8)&amp;0xff);
 	*ptr++ = (unsigned char) (KG_TOK_MIC_MSG&amp;0xff);
diff --git a/net/sunrpc/auth_gss/gss_krb5_wrap.c b/net/sunrpc/auth_gss/gss_krb5_wrap.c
index 3cd99a795d7a..b00b1b426301 100644
--- a/net/sunrpc/auth_gss/gss_krb5_wrap.c
+++ b/net/sunrpc/auth_gss/gss_krb5_wrap.c
@@ -137,7 +137,7 @@ gss_wrap_kerberos(struct gss_ctx *ctx, int offset,
 	BUG_ON((buf-&gt;len - offset) % blocksize);
 	plainlen = blocksize + buf-&gt;len - offset;
 
-	headlen = g_token_size(&amp;kctx-&gt;mech_used, 22 + plainlen) -
+	headlen = g_token_size(&amp;kctx-&gt;mech_used, 24 + plainlen) -
 						(buf-&gt;len - offset);
 
 	ptr = buf-&gt;head[0].iov_base + offset;
@@ -149,7 +149,7 @@ gss_wrap_kerberos(struct gss_ctx *ctx, int offset,
 	buf-&gt;len += headlen;
 	BUG_ON((buf-&gt;len - offset - headlen) % blocksize);
 
-	g_make_token_header(&amp;kctx-&gt;mech_used, 22 + plainlen, &amp;ptr);
+	g_make_token_header(&amp;kctx-&gt;mech_used, 24 + plainlen, &amp;ptr);
 
 
 	*ptr++ = (unsigned char) ((KG_TOK_WRAP_MSG&gt;&gt;8)&amp;0xff);
diff --git a/net/sunrpc/auth_gss/gss_spkm3_seal.c b/net/sunrpc/auth_gss/gss_spkm3_seal.c
index abf17ce2e3b1..c832712f8d55 100644
--- a/net/sunrpc/auth_gss/gss_spkm3_seal.c
+++ b/net/sunrpc/auth_gss/gss_spkm3_seal.c
@@ -107,10 +107,10 @@ spkm3_make_token(struct spkm3_ctx *ctx,
 		tokenlen = 10 + ctxelen + 1 + md5elen + 1;
 
 		/* Create token header using generic routines */
-		token-&gt;len = g_token_size(&amp;ctx-&gt;mech_used, tokenlen);
+		token-&gt;len = g_token_size(&amp;ctx-&gt;mech_used, tokenlen + 2);
 
 		ptr = token-&gt;data;
-		g_make_token_header(&amp;ctx-&gt;mech_used, tokenlen, &amp;ptr);
+		g_make_token_header(&amp;ctx-&gt;mech_used, tokenlen + 2, &amp;ptr);
 
 		spkm3_make_mic_token(&amp;ptr, tokenlen, &amp;mic_hdr, &amp;md5cksum, md5elen, md5zbit);
 	} else if (toktype == SPKM_WRAP_TOK) { /* Not Supported */</pre><hr><pre>commit 5743d65c2f77d5145fb4c4262c4dd70c3f078776
Author: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
Date:   Mon Mar 31 10:31:33 2008 -0400

    gss_krb5: consistently use unsigned for seqnum
    
    Consistently use unsigned (u32 vs. s32) for seqnum.
    
    In get_mic function, send the local copy of seq_send,
    rather than the context version.
    
    Signed-off-by: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/include/linux/sunrpc/gss_krb5.h b/include/linux/sunrpc/gss_krb5.h
index 216738394f64..a10f1fb0bf7c 100644
--- a/include/linux/sunrpc/gss_krb5.h
+++ b/include/linux/sunrpc/gss_krb5.h
@@ -148,9 +148,9 @@ gss_decrypt_xdr_buf(struct crypto_blkcipher *tfm, struct xdr_buf *inbuf,
 s32
 krb5_make_seq_num(struct crypto_blkcipher *key,
 		int direction,
-		s32 seqnum, unsigned char *cksum, unsigned char *buf);
+		u32 seqnum, unsigned char *cksum, unsigned char *buf);
 
 s32
 krb5_get_seq_num(struct crypto_blkcipher *key,
 	       unsigned char *cksum,
-	       unsigned char *buf, int *direction, s32 * seqnum);
+	       unsigned char *buf, int *direction, u32 *seqnum);
diff --git a/net/sunrpc/auth_gss/gss_krb5_seal.c b/net/sunrpc/auth_gss/gss_krb5_seal.c
index 39c08b7e33af..8e3c87df5836 100644
--- a/net/sunrpc/auth_gss/gss_krb5_seal.c
+++ b/net/sunrpc/auth_gss/gss_krb5_seal.c
@@ -116,7 +116,7 @@ gss_get_mic_kerberos(struct gss_ctx *gss_ctx, struct xdr_buf *text,
 	spin_unlock(&amp;krb5_seq_lock);
 
 	if (krb5_make_seq_num(ctx-&gt;seq, ctx-&gt;initiate ? 0 : 0xff,
-			       ctx-&gt;seq_send, krb5_hdr + 16, krb5_hdr + 8))
+			      seq_send, krb5_hdr + 16, krb5_hdr + 8))
 		return GSS_S_FAILURE;
 
 	return (ctx-&gt;endtime &lt; now) ? GSS_S_CONTEXT_EXPIRED : GSS_S_COMPLETE;
diff --git a/net/sunrpc/auth_gss/gss_krb5_seqnum.c b/net/sunrpc/auth_gss/gss_krb5_seqnum.c
index 43f3421f1e6a..f160be6c1a46 100644
--- a/net/sunrpc/auth_gss/gss_krb5_seqnum.c
+++ b/net/sunrpc/auth_gss/gss_krb5_seqnum.c
@@ -43,7 +43,7 @@
 s32
 krb5_make_seq_num(struct crypto_blkcipher *key,
 		int direction,
-		s32 seqnum,
+		u32 seqnum,
 		unsigned char *cksum, unsigned char *buf)
 {
 	unsigned char plain[8];
@@ -65,7 +65,7 @@ s32
 krb5_get_seq_num(struct crypto_blkcipher *key,
 	       unsigned char *cksum,
 	       unsigned char *buf,
-	       int *direction, s32 * seqnum)
+	       int *direction, u32 *seqnum)
 {
 	s32 code;
 	unsigned char plain[8];
diff --git a/net/sunrpc/auth_gss/gss_krb5_unseal.c b/net/sunrpc/auth_gss/gss_krb5_unseal.c
index e30a993466bc..d91a5d004803 100644
--- a/net/sunrpc/auth_gss/gss_krb5_unseal.c
+++ b/net/sunrpc/auth_gss/gss_krb5_unseal.c
@@ -82,7 +82,7 @@ gss_verify_mic_kerberos(struct gss_ctx *gss_ctx,
 	struct xdr_netobj	md5cksum = {.len = 0, .data = cksumdata};
 	s32			now;
 	int			direction;
-	s32			seqnum;
+	u32			seqnum;
 	unsigned char		*ptr = (unsigned char *)read_token-&gt;data;
 	int			bodysize;
 </pre><hr><pre>commit 03550fac06c4f0c39a1885d46015c28794413c82
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri Mar 14 17:51:12 2008 -0400

    nfsd: move most of fh_verify to separate function
    
    Move the code that actually parses the filehandle and looks up the
    dentry and export to a separate function.  This simplifies the reference
    counting a little and moves fh_verify() a little closer to the kernel
    ideal of small, minimally-indentended functions.  Clean up a few other
    minor style sins along the way.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: Neil Brown &lt;neilb@suse.de&gt;

diff --git a/fs/nfsd/nfsfh.c b/fs/nfsd/nfsfh.c
index 3e6b3f41ee1f..100ae5641162 100644
--- a/fs/nfsd/nfsfh.c
+++ b/fs/nfsd/nfsfh.c
@@ -112,6 +112,124 @@ static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,
 	return nfserrno(nfsd_setuser(rqstp, exp));
 }
 
+/*
+ * Use the given filehandle to look up the corresponding export and
+ * dentry.  On success, the results are used to set fh_export and
+ * fh_dentry.
+ */
+static __be32 nfsd_set_fh_dentry(struct svc_rqst *rqstp, struct svc_fh *fhp)
+{
+	struct knfsd_fh	*fh = &amp;fhp-&gt;fh_handle;
+	struct fid *fid = NULL, sfid;
+	struct svc_export *exp;
+	struct dentry *dentry;
+	int fileid_type;
+	int data_left = fh-&gt;fh_size/4;
+	__be32 error;
+
+	error = nfserr_stale;
+	if (rqstp-&gt;rq_vers &gt; 2)
+		error = nfserr_badhandle;
+	if (rqstp-&gt;rq_vers == 4 &amp;&amp; fh-&gt;fh_size == 0)
+		return nfserr_nofilehandle;
+
+	if (fh-&gt;fh_version == 1) {
+		int len;
+
+		if (--data_left &lt; 0)
+			return error;
+		if (fh-&gt;fh_auth_type != 0)
+			return error;
+		len = key_len(fh-&gt;fh_fsid_type) / 4;
+		if (len == 0)
+			return error;
+		if  (fh-&gt;fh_fsid_type == FSID_MAJOR_MINOR) {
+			/* deprecated, convert to type 3 */
+			len = key_len(FSID_ENCODE_DEV)/4;
+			fh-&gt;fh_fsid_type = FSID_ENCODE_DEV;
+			fh-&gt;fh_fsid[0] = new_encode_dev(MKDEV(ntohl(fh-&gt;fh_fsid[0]), ntohl(fh-&gt;fh_fsid[1])));
+			fh-&gt;fh_fsid[1] = fh-&gt;fh_fsid[2];
+		}
+		data_left -= len;
+		if (data_left &lt; 0)
+			return error;
+		exp = rqst_exp_find(rqstp, fh-&gt;fh_fsid_type, fh-&gt;fh_auth);
+		fid = (struct fid *)(fh-&gt;fh_auth + len);
+	} else {
+		__u32 tfh[2];
+		dev_t xdev;
+		ino_t xino;
+
+		if (fh-&gt;fh_size != NFS_FHSIZE)
+			return error;
+		/* assume old filehandle format */
+		xdev = old_decode_dev(fh-&gt;ofh_xdev);
+		xino = u32_to_ino_t(fh-&gt;ofh_xino);
+		mk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);
+		exp = rqst_exp_find(rqstp, FSID_DEV, tfh);
+	}
+
+	error = nfserr_stale;
+	if (PTR_ERR(exp) == -ENOENT)
+		return error;
+
+	if (IS_ERR(exp))
+		return nfserrno(PTR_ERR(exp));
+
+	error = nfsd_setuser_and_check_port(rqstp, exp);
+	if (error)
+		goto out;
+
+	/*
+	 * Look up the dentry using the NFS file handle.
+	 */
+	error = nfserr_stale;
+	if (rqstp-&gt;rq_vers &gt; 2)
+		error = nfserr_badhandle;
+
+	if (fh-&gt;fh_version != 1) {
+		sfid.i32.ino = fh-&gt;ofh_ino;
+		sfid.i32.gen = fh-&gt;ofh_generation;
+		sfid.i32.parent_ino = fh-&gt;ofh_dirino;
+		fid = &amp;sfid;
+		data_left = 3;
+		if (fh-&gt;ofh_dirino == 0)
+			fileid_type = FILEID_INO32_GEN;
+		else
+			fileid_type = FILEID_INO32_GEN_PARENT;
+	} else
+		fileid_type = fh-&gt;fh_fileid_type;
+
+	if (fileid_type == FILEID_ROOT)
+		dentry = dget(exp-&gt;ex_path.dentry);
+	else {
+		dentry = exportfs_decode_fh(exp-&gt;ex_path.mnt, fid,
+				data_left, fileid_type,
+				nfsd_acceptable, exp);
+	}
+	if (dentry == NULL)
+		goto out;
+	if (IS_ERR(dentry)) {
+		if (PTR_ERR(dentry) != -EINVAL)
+			error = nfserrno(PTR_ERR(dentry));
+		goto out;
+	}
+
+	if (S_ISDIR(dentry-&gt;d_inode-&gt;i_mode) &amp;&amp;
+			(dentry-&gt;d_flags &amp; DCACHE_DISCONNECTED)) {
+		printk("nfsd: find_fh_dentry returned a DISCONNECTED directory: %s/%s\n",
+				dentry-&gt;d_parent-&gt;d_name.name, dentry-&gt;d_name.name);
+	}
+
+	fhp-&gt;fh_dentry = dentry;
+	fhp-&gt;fh_export = exp;
+	nfsd_nr_verified++;
+	return 0;
+out:
+	exp_put(exp);
+	return error;
+}
+
 /*
  * Perform sanity checks on the dentry in a client's file handle.
  *
@@ -124,115 +242,18 @@ static __be32 nfsd_setuser_and_check_port(struct svc_rqst *rqstp,
 __be32
 fh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, int type, int access)
 {
-	struct knfsd_fh	*fh = &amp;fhp-&gt;fh_handle;
-	struct svc_export *exp = NULL;
+	struct svc_export *exp;
 	struct dentry	*dentry;
-	__be32		error = 0;
+	__be32		error;
 
 	dprintk("nfsd: fh_verify(%s)\n", SVCFH_fmt(fhp));
 
 	if (!fhp-&gt;fh_dentry) {
-		struct fid *fid = NULL, sfid;
-		int fileid_type;
-		int data_left = fh-&gt;fh_size/4;
-
-		error = nfserr_stale;
-		if (rqstp-&gt;rq_vers &gt; 2)
-			error = nfserr_badhandle;
-		if (rqstp-&gt;rq_vers == 4 &amp;&amp; fh-&gt;fh_size == 0)
-			return nfserr_nofilehandle;
-
-		if (fh-&gt;fh_version == 1) {
-			int len;
-			if (--data_left&lt;0) goto out;
-			switch (fh-&gt;fh_auth_type) {
-			case 0: break;
-			default: goto out;
-			}
-			len = key_len(fh-&gt;fh_fsid_type) / 4;
-			if (len == 0) goto out;
-			if  (fh-&gt;fh_fsid_type == FSID_MAJOR_MINOR) {
-				/* deprecated, convert to type 3 */
-				len = key_len(FSID_ENCODE_DEV)/4;
-				fh-&gt;fh_fsid_type = FSID_ENCODE_DEV;
-				fh-&gt;fh_fsid[0] = new_encode_dev(MKDEV(ntohl(fh-&gt;fh_fsid[0]), ntohl(fh-&gt;fh_fsid[1])));
-				fh-&gt;fh_fsid[1] = fh-&gt;fh_fsid[2];
-			}
-			if ((data_left -= len)&lt;0) goto out;
-			exp = rqst_exp_find(rqstp, fh-&gt;fh_fsid_type,
-					    fh-&gt;fh_auth);
-			fid = (struct fid *)(fh-&gt;fh_auth + len);
-		} else {
-			__u32 tfh[2];
-			dev_t xdev;
-			ino_t xino;
-			if (fh-&gt;fh_size != NFS_FHSIZE)
-				goto out;
-			/* assume old filehandle format */
-			xdev = old_decode_dev(fh-&gt;ofh_xdev);
-			xino = u32_to_ino_t(fh-&gt;ofh_xino);
-			mk_fsid(FSID_DEV, tfh, xdev, xino, 0, NULL);
-			exp = rqst_exp_find(rqstp, FSID_DEV, tfh);
-		}
-
-		error = nfserr_stale;
-		if (PTR_ERR(exp) == -ENOENT)
-			goto out;
-
-		if (IS_ERR(exp)) {
-			error = nfserrno(PTR_ERR(exp));
-			goto out;
-		}
-
-		error = nfsd_setuser_and_check_port(rqstp, exp);
+		error = nfsd_set_fh_dentry(rqstp, fhp);
 		if (error)
 			goto out;
-
-		/*
-		 * Look up the dentry using the NFS file handle.
-		 */
-		error = nfserr_stale;
-		if (rqstp-&gt;rq_vers &gt; 2)
-			error = nfserr_badhandle;
-
-		if (fh-&gt;fh_version != 1) {
-			sfid.i32.ino = fh-&gt;ofh_ino;
-			sfid.i32.gen = fh-&gt;ofh_generation;
-			sfid.i32.parent_ino = fh-&gt;ofh_dirino;
-			fid = &amp;sfid;
-			data_left = 3;
-			if (fh-&gt;ofh_dirino == 0)
-				fileid_type = FILEID_INO32_GEN;
-			else
-				fileid_type = FILEID_INO32_GEN_PARENT;
-		} else
-			fileid_type = fh-&gt;fh_fileid_type;
-
-		if (fileid_type == FILEID_ROOT)
-			dentry = dget(exp-&gt;ex_path.dentry);
-		else {
-			dentry = exportfs_decode_fh(exp-&gt;ex_path.mnt, fid,
-					data_left, fileid_type,
-					nfsd_acceptable, exp);
-		}
-		if (dentry == NULL)
-			goto out;
-		if (IS_ERR(dentry)) {
-			if (PTR_ERR(dentry) != -EINVAL)
-				error = nfserrno(PTR_ERR(dentry));
-			goto out;
-		}
-
-		if (S_ISDIR(dentry-&gt;d_inode-&gt;i_mode) &amp;&amp;
-		    (dentry-&gt;d_flags &amp; DCACHE_DISCONNECTED)) {
-			printk("nfsd: find_fh_dentry returned a DISCONNECTED directory: %s/%s\n",
-			       dentry-&gt;d_parent-&gt;d_name.name, dentry-&gt;d_name.name);
-		}
-
-		fhp-&gt;fh_dentry = dentry;
-		fhp-&gt;fh_export = exp;
-		nfsd_nr_verified++;
-		cache_get(&amp;exp-&gt;h);
+		dentry = fhp-&gt;fh_dentry;
+		exp = fhp-&gt;fh_export;
 	} else {
 		/*
 		 * just rechecking permissions
@@ -242,7 +263,6 @@ fh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, int type, int access)
 		dprintk("nfsd: fh_verify - just checking\n");
 		dentry = fhp-&gt;fh_dentry;
 		exp = fhp-&gt;fh_export;
-		cache_get(&amp;exp-&gt;h);
 		/*
 		 * Set user creds for this exportpoint; necessary even
 		 * in the "just checking" case because this may be a
@@ -281,8 +301,6 @@ fh_verify(struct svc_rqst *rqstp, struct svc_fh *fhp, int type, int access)
 			access, ntohl(error));
 	}
 out:
-	if (exp &amp;&amp; !IS_ERR(exp))
-		exp_put(exp);
 	if (error == nfserr_stale)
 		nfsdstats.fh_stale++;
 	return error;</pre>
    <div class="pagination">
        <a href='4_32.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><span>[33]</span><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_34.html'>Next&gt;&gt;</a>
    <div>
</body>
