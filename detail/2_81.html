<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_80.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><span>[81]</span><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_82.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a2c2706e1043c17139c2dafd171c4a5cf008ef7e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 10 10:16:58 2009 -0500

    USB: EHCI: add software retry for transaction errors
    
    This patch (as1204) adds a software retry mechanism to ehci-hcd.  It
    gets invoked when the driver encounters transaction errors on an
    asynchronous endpoint.  On many systems, hardware deficiencies cause
    such errors to occur if one device is unplugged while the host is
    communicating with another device.  With the patch, the failed
    transactions are retried and generally succeed the second or third
    time through.
    
    This is based on code originally written by Koichiro Saito.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested by: Koichiro Saito &lt;Saito.Koichiro@adniss.jp&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index ecc9b66c03cd..01132ac74eb8 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -333,12 +333,40 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		token = hc32_to_cpu(ehci, qtd-&gt;hw_token);
 
 		/* always clean up qtds the hc de-activated */
+ retry_xacterr:
 		if ((token &amp; QTD_STS_ACTIVE) == 0) {
 
 			/* on STALL, error, and short reads this urb must
 			 * complete and all its qtds must be recycled.
 			 */
 			if ((token &amp; QTD_STS_HALT) != 0) {
+
+				/* retry transaction errors until we
+				 * reach the software xacterr limit
+				 */
+				if ((token &amp; QTD_STS_XACT) &amp;&amp;
+						QTD_CERR(token) == 0 &amp;&amp;
+						--qh-&gt;xacterrs &gt; 0 &amp;&amp;
+						!urb-&gt;unlinked) {
+					ehci_dbg(ehci,
+	"detected XactErr len %d/%d retry %d\n",
+	qtd-&gt;length - QTD_LENGTH(token), qtd-&gt;length,
+	QH_XACTERR_MAX - qh-&gt;xacterrs);
+
+					/* reset the token in the qtd and the
+					 * qh overlay (which still contains
+					 * the qtd) so that we pick up from
+					 * where we left off
+					 */
+					token &amp;= ~QTD_STS_HALT;
+					token |= QTD_STS_ACTIVE |
+							(EHCI_TUNE_CERR &lt;&lt; 10);
+					qtd-&gt;hw_token = cpu_to_hc32(ehci,
+							token);
+					wmb();
+					qh-&gt;hw_token = cpu_to_hc32(ehci, token);
+					goto retry_xacterr;
+				}
 				stopped = 1;
 
 			/* magic dummy for some short reads; qh won't advance.
@@ -421,6 +449,9 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 		/* remove qtd; it's recycled after possible urb completion */
 		list_del (&amp;qtd-&gt;qtd_list);
 		last = qtd;
+
+		/* reinit the xacterr counter for the next qtd */
+		qh-&gt;xacterrs = QH_XACTERR_MAX;
 	}
 
 	/* last urb's completion might still need calling */
@@ -862,6 +893,7 @@ static void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	head-&gt;qh_next.qh = qh;
 	head-&gt;hw_next = dma;
 
+	qh-&gt;xacterrs = QH_XACTERR_MAX;
 	qh-&gt;qh_state = QH_STATE_LINKED;
 	/* qtd completions reported later by interrupt */
 }
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 0042deb671dd..9aba560fd569 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -342,6 +342,9 @@ struct ehci_qh {
 #define	QH_STATE_UNLINK_WAIT	4		/* LINKED and on reclaim q */
 #define	QH_STATE_COMPLETING	5		/* don't touch token.HALT */
 
+	u8			xacterrs;	/* XactErr retry counter */
+#define	QH_XACTERR_MAX		32		/* XactErr retry limit */
+
 	/* periodic schedule info */
 	u8			usecs;		/* intr bandwidth */
 	u8			gap_uf;		/* uframes split/csplit gap */</pre><hr><pre>commit bc29847e16cb6b571157220ec9b20a7d86e58046
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Feb 11 14:26:38 2009 -0500

    USB: EHCI: Make timer_action out-of-line
    
    This patch (as1205) moves timer_action() from ehci.h to ehci-hcd.c and
    makes it out-of-line.  Over the years it has grown too big to be inline
    any more.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index e551bb38852b..f2618d17710d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -110,6 +110,42 @@ MODULE_PARM_DESC (ignore_oc, "ignore bogus hardware overcurrent indications");
 
 /*-------------------------------------------------------------------------*/
 
+static void
+timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
+{
+	/* Don't override timeouts which shrink or (later) disable
+	 * the async ring; just the I/O watchdog.  Note that if a
+	 * SHRINK were pending, OFF would never be requested.
+	 */
+	if (timer_pending(&amp;ehci-&gt;watchdog)
+			&amp;&amp; ((BIT(TIMER_ASYNC_SHRINK) | BIT(TIMER_ASYNC_OFF))
+				&amp; ehci-&gt;actions))
+		return;
+
+	if (!test_and_set_bit(action, &amp;ehci-&gt;actions)) {
+		unsigned long t;
+
+		switch (action) {
+		case TIMER_IO_WATCHDOG:
+			t = EHCI_IO_JIFFIES;
+			break;
+		case TIMER_ASYNC_OFF:
+			t = EHCI_ASYNC_JIFFIES;
+			break;
+		/* case TIMER_ASYNC_SHRINK: */
+		default:
+			/* add a jiffie since we synch against the
+			 * 8 KHz uframe counter.
+			 */
+			t = DIV_ROUND_UP(EHCI_SHRINK_FRAMES * HZ, 1000) + 1;
+			break;
+		}
+		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
+	}
+}
+
+/*-------------------------------------------------------------------------*/
+
 /*
  * handshake - spin reading hc until handshake completes or fails
  * @ptr: address of hc register to be read
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 262b00c9b334..0042deb671dd 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -190,40 +190,6 @@ timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
 	clear_bit (action, &amp;ehci-&gt;actions);
 }
 
-static inline void
-timer_action (struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	/* Don't override timeouts which shrink or (later) disable
-	 * the async ring; just the I/O watchdog.  Note that if a
-	 * SHRINK were pending, OFF would never be requested.
-	 */
-	if (timer_pending(&amp;ehci-&gt;watchdog)
-			&amp;&amp; ((BIT(TIMER_ASYNC_SHRINK) | BIT(TIMER_ASYNC_OFF))
-				&amp; ehci-&gt;actions))
-		return;
-
-	if (!test_and_set_bit (action, &amp;ehci-&gt;actions)) {
-		unsigned long t;
-
-		switch (action) {
-		case TIMER_IO_WATCHDOG:
-			t = EHCI_IO_JIFFIES;
-			break;
-		case TIMER_ASYNC_OFF:
-			t = EHCI_ASYNC_JIFFIES;
-			break;
-		// case TIMER_ASYNC_SHRINK:
-		default:
-			/* add a jiffie since we synch against the
-			 * 8 KHz uframe counter.
-			 */
-			t = DIV_ROUND_UP(EHCI_SHRINK_FRAMES * HZ, 1000) + 1;
-			break;
-		}
-		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
-	}
-}
-
 static void free_cached_itd_list(struct ehci_hcd *ehci);
 
 /*-------------------------------------------------------------------------*/</pre><hr><pre>commit 5c16034d73da2c1b663aa25dedadbc533b3d811c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 23 09:51:02 2009 -0400

    USB: usb-storage: increase max_sectors for tape drives
    
    This patch (as1203) increases the max_sector limit for USB tape
    drives.  By default usb-storage sets max_sectors to 240 (i.e., 120 KB)
    for all devices.  But tape drives need a higher limit, since tapes can
    and do have very large block sizes.  Without the ability to transfer
    an entire large block in a single command, such tapes can't be used.
    
    This fixes Bugzilla #12207.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Phil Mitchell &lt;philipm@sybase.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/scsiglue.c b/drivers/usb/storage/scsiglue.c
index 727c506417cc..ed710bcdaab2 100644
--- a/drivers/usb/storage/scsiglue.c
+++ b/drivers/usb/storage/scsiglue.c
@@ -135,6 +135,12 @@ static int slave_configure(struct scsi_device *sdev)
 		if (sdev-&gt;request_queue-&gt;max_sectors &gt; max_sectors)
 			blk_queue_max_sectors(sdev-&gt;request_queue,
 					      max_sectors);
+	} else if (sdev-&gt;type == TYPE_TAPE) {
+		/* Tapes need much higher max_sector limits, so just
+		 * raise it to the maximum possible (4 GB / 512) and
+		 * let the queue segment size sort out the real limit.
+		 */
+		blk_queue_max_sectors(sdev-&gt;request_queue, 0x7FFFFF);
 	}
 
 	/* Some USB host controllers can't do DMA; they have to use PIO.</pre><hr><pre>commit 1662e3a7f076e51e3073faf9ce77157b529c475b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Mar 18 14:28:53 2009 -0400

    USB: add quirk to avoid config and interface strings
    
    Apparently the Configuration and Interface strings aren't used as
    often as the Vendor, Product, and Serial strings.  In at least one
    device (a Saitek Cyborg Gold 3D joystick), attempts to read the
    Configuration string cause the device to stop responding to Control
    requests.
    
    This patch (as1226) adds a quirks flag, telling the kernel not to
    read a device's Configuration or Interface strings, together with a
    new quirk for the offending joystick.
    
    Reported-by: Melchior FRANZ &lt;melchior.franz@gmail.com&gt;
    Tested-by: Melchior FRANZ &lt;melchior.franz@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;  [2.6.28 and 2.6.29, nothing earlier]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 49e7f56e0d7f..3922fa915ed2 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -1719,7 +1719,8 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	}
 	kfree(new_interfaces);
 
-	if (cp-&gt;string == NULL)
+	if (cp-&gt;string == NULL &amp;&amp;
+			!(dev-&gt;quirks &amp; USB_QUIRK_CONFIG_INTF_STRINGS))
 		cp-&gt;string = usb_cache_string(dev, cp-&gt;desc.iConfiguration);
 
 	/* Now that all the interfaces are set up, register them
diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index c070b34b669d..ab93918d9207 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -54,6 +54,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x0638, 0x0a13), .driver_info =
 	  USB_QUIRK_STRING_FETCH_255 },
 
+	/* Saitek Cyborg Gold Joystick */
+	{ USB_DEVICE(0x06a3, 0x0006), .driver_info =
+			USB_QUIRK_CONFIG_INTF_STRINGS },
+
 	/* M-Systems Flash Disk Pioneers */
 	{ USB_DEVICE(0x08ec, 0x1000), .driver_info = USB_QUIRK_RESET_RESUME },
 
diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index 4cc2456ef3be..c66789197927 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -13,6 +13,7 @@
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/string.h&gt;
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/usb/quirks.h&gt;
 #include "usb.h"
 
 /* Active configuration fields */
@@ -813,7 +814,8 @@ int usb_create_sysfs_intf_files(struct usb_interface *intf)
 	if (intf-&gt;sysfs_files_created || intf-&gt;unregistering)
 		return 0;
 
-	if (alt-&gt;string == NULL)
+	if (alt-&gt;string == NULL &amp;&amp;
+			!(udev-&gt;quirks &amp; USB_QUIRK_CONFIG_INTF_STRINGS))
 		alt-&gt;string = usb_cache_string(udev, alt-&gt;desc.iInterface);
 	if (alt-&gt;string)
 		retval = device_create_file(&amp;intf-&gt;dev, &amp;dev_attr_interface);
diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h
index 7f6c603db654..2526f3bbd273 100644
--- a/include/linux/usb/quirks.h
+++ b/include/linux/usb/quirks.h
@@ -16,4 +16,7 @@
 /* device can't handle Set-Interface requests */
 #define USB_QUIRK_NO_SET_INTF		0x00000004
 
+/* device can't handle its Configuration or Interface strings */
+#define USB_QUIRK_CONFIG_INTF_STRINGS	0x00000008
+
 #endif /* __LINUX_USB_QUIRKS_H */</pre><hr><pre>commit 391016f6e2fe3b9979b4c6880a76e5e434d6947c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 16 14:21:56 2009 -0400

    USB: EHCI: expedite unlinks when the root hub is suspended
    
    This patch (as1225) fixes a bug in ehci-hcd.  The condition for
    whether unlinked QHs can become IDLE should not be that the controller
    is halted, but rather that the controller isn't running.  In other
    words when the root hub is suspended, the hardware doesn't own any
    QHs.
    
    This fixes a problem that can show up during hibernation: If a QH is
    only partially unlinked when the root hub is frozen, then when the
    root hub is thawed the QH won't be in the IDLE state.  As a result it
    can't be used properly for new URB submissions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Brandon Philips &lt;brandon@ifup.org&gt;
    Tested-by: Brandon Philips &lt;brandon@ifup.org&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Cc: Stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 3712b925b315..ecc9b66c03cd 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -1095,7 +1095,8 @@ static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	prev-&gt;qh_next = qh-&gt;qh_next;
 	wmb ();
 
-	if (unlikely (ehci_to_hcd(ehci)-&gt;state == HC_STATE_HALT)) {
+	/* If the controller isn't running, we don't have to wait for it */
+	if (unlikely(!HC_IS_RUNNING(ehci_to_hcd(ehci)-&gt;state))) {
 		/* if (unlikely (qh-&gt;reclaim != 0))
 		 *	this will recurse, probably not much
 		 */</pre><hr><pre>commit 6ff10464096540e14d7575a72c50d0316d003714
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Mar 9 13:44:02 2009 -0400

    USB: usbfs: keep async URBs until the device file is closed
    
    The usbfs driver manages a list of completed asynchronous URBs.  But
    it is too eager to free the entries on this list: destroy_async() gets
    called whenever an interface is unbound or a device is removed, and it
    deallocates the outstanding struct async entries for all URBs on that
    interface or device.  This is wrong; the user program should be able
    to reap an URB any time after it has completed, regardless of whether
    or not the interface is still bound or the device is still present.
    
    This patch (as1222) moves the code for deallocating the completed list
    entries from destroy_async() to usbdev_release().  The outstanding
    entries won't be freed until the user program has closed the device
    file, thereby eliminating any possibility that the remaining URBs
    might still be reaped.
    
    This fixes a bug in which a program can hang in the USBDEVFS_REAPURB
    ioctl when the device is unplugged.
    
    Reported-and-tested-by: Martin Poupe &lt;martin.poupe@upek.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 7513bb083c15..6585f527e381 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -359,11 +359,6 @@ static void destroy_async(struct dev_state *ps, struct list_head *list)
 		spin_lock_irqsave(&amp;ps-&gt;lock, flags);
 	}
 	spin_unlock_irqrestore(&amp;ps-&gt;lock, flags);
-	as = async_getcompleted(ps);
-	while (as) {
-		free_async(as);
-		as = async_getcompleted(ps);
-	}
 }
 
 static void destroy_async_on_interface(struct dev_state *ps,
@@ -643,6 +638,7 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	struct dev_state *ps = file-&gt;private_data;
 	struct usb_device *dev = ps-&gt;dev;
 	unsigned int ifnum;
+	struct async *as;
 
 	usb_lock_device(dev);
 
@@ -661,6 +657,12 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
 	put_pid(ps-&gt;disc_pid);
+
+	as = async_getcompleted(ps);
+	while (as) {
+		free_async(as);
+		as = async_getcompleted(ps);
+	}
 	kfree(ps);
 	return 0;
 }</pre><hr><pre>commit 77c019768f0607c36e25bec11ce3e1eabef09277
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 27 16:51:42 2009 -0500

    [SCSI] fix /proc memory leak in the SCSI core
    
    The SCSI core calls scsi_proc_hostdir_add() from within
    scsi_host_alloc(), but the corresponding scsi_proc_hostdir_rm()
    routine is called from within scsi_remove_host().  As a result, if a
    host is allocated and then deallocated without ever being registered,
    the host's directory in /proc is leaked.
    
    This patch (as1181b) fixes this bug in the SCSI core by moving
    scsi_proc_hostdir_rm() into scsi_host_dev_release().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index aa670a1d1513..89d41a424b33 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -176,7 +176,6 @@ void scsi_remove_host(struct Scsi_Host *shost)
 	transport_unregister_device(&amp;shost-&gt;shost_gendev);
 	device_unregister(&amp;shost-&gt;shost_dev);
 	device_del(&amp;shost-&gt;shost_gendev);
-	scsi_proc_hostdir_rm(shost-&gt;hostt);
 }
 EXPORT_SYMBOL(scsi_remove_host);
 
@@ -270,6 +269,8 @@ static void scsi_host_dev_release(struct device *dev)
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct device *parent = dev-&gt;parent;
 
+	scsi_proc_hostdir_rm(shost-&gt;hostt);
+
 	if (shost-&gt;ehandler)
 		kthread_stop(shost-&gt;ehandler);
 	if (shost-&gt;work_q)</pre><hr><pre>commit 5c211caa9f341f9eefbda89436d1440d1eccb3bc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Feb 18 10:54:44 2009 -0500

    [SCSI] sd: tell the user when a disk's capacity is adjusted
    
    This patch (as1188) combines the tests for decrementing a drive's
    reported capacity and expands the comment.  It also adds an
    informational message to the system log, informing the user when the
    reported value has been changed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@HansenPartnership.com&gt;

diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c
index 4970ae4a62d6..e744ee40be69 100644
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@ -1383,18 +1383,22 @@ sd_read_capacity(struct scsi_disk *sdkp, unsigned char *buffer)
 		sd_read_protection_type(sdkp, buffer);
 	}	
 
-	/* Some devices return the total number of sectors, not the
-	 * highest sector number.  Make the necessary adjustment. */
-	if (sdp-&gt;fix_capacity) {
+	/* Some devices are known to return the total number of blocks,
+	 * not the highest block number.  Some devices have versions
+	 * which do this and others which do not.  Some devices we might
+	 * suspect of doing this but we don't know for certain.
+	 *
+	 * If we know the reported capacity is wrong, decrement it.  If
+	 * we can only guess, then assume the number of blocks is even
+	 * (usually true but not always) and err on the side of lowering
+	 * the capacity.
+	 */
+	if (sdp-&gt;fix_capacity ||
+	    (sdp-&gt;guess_capacity &amp;&amp; (sdkp-&gt;capacity &amp; 0x01))) {
+		sd_printk(KERN_INFO, sdkp, "Adjusting the sector count "
+				"from its reported value: %llu\n",
+				(unsigned long long) sdkp-&gt;capacity);
 		--sdkp-&gt;capacity;
-
-	/* Some devices have version which report the correct sizes
-	 * and others which do not. We guess size according to a heuristic
-	 * and err on the side of lowering the capacity. */
-	} else {
-		if (sdp-&gt;guess_capacity)
-			if (sdkp-&gt;capacity &amp; 0x01) /* odd sizes are odd */
-				--sdkp-&gt;capacity;
 	}
 
 got_data:</pre><hr><pre>commit 67f5a4ba9741fcef3f4db3509ad03565d9e33af2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Feb 20 16:33:08 2009 -0500

    USB: usb_get_string should check the descriptor type
    
    This patch (as1218) fixes a problem with a radio-control joystick used
    in the "walkera 4#3" helicopter.  This device responds to the initial
    Get-String-Descriptor request for string 0 (which is really the list
    of supported languages) by sending its config descriptor!  The
    usb_get_string() routine needs to check whether it got the right
    type of descriptor.
    
    Oddly enough, this sort of check is already present in
    usb_get_descriptor().  The patch changes the error code from -EPROTO
    to -ENODATA, because -EPROTO shows up in so many other contexts to
    indicate a hardware failure rather than a firmware error.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Guillermo Jarabo &lt;williamjap@gmail.com&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
    
    ===================================================================

diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 31fb204f44c6..49e7f56e0d7f 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -653,7 +653,7 @@ int usb_get_descriptor(struct usb_device *dev, unsigned char type,
 		if (result &lt;= 0 &amp;&amp; result != -ETIMEDOUT)
 			continue;
 		if (result &gt; 1 &amp;&amp; ((u8 *)buf)[1] != type) {
-			result = -EPROTO;
+			result = -ENODATA;
 			continue;
 		}
 		break;
@@ -696,8 +696,13 @@ static int usb_get_string(struct usb_device *dev, unsigned short langid,
 			USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,
 			(USB_DT_STRING &lt;&lt; 8) + index, langid, buf, size,
 			USB_CTRL_GET_TIMEOUT);
-		if (!(result == 0 || result == -EPIPE))
-			break;
+		if (result == 0 || result == -EPIPE)
+			continue;
+		if (result &gt; 1 &amp;&amp; ((u8 *) buf)[1] != USB_DT_STRING) {
+			result = -ENODATA;
+			continue;
+		}
+		break;
 	}
 	return result;
 }</pre><hr><pre>commit ce459ec1d278b19be8e0719dbfd47dd1d6687bfb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 24 16:19:47 2009 -0500

    USB: g_file_storage: automatically disable stalls under Atmel
    
    This patch (as1220) automatically disables stalls when g_file_storage
    finds itself running with an Atmel device controller, because the
    Atmel hardware/driver isn't capable of halting bulk endpoints
    correctly.
    
    Reported-by: Stanislaw Gruszka &lt;stf_xl@wp.pl&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: David Brownell &lt;dbrownell@users.sourceforge.net&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index b10fa31cc915..1ab9dac7e12d 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -3879,7 +3879,11 @@ static int __init check_parameters(struct fsg_dev *fsg)
 	mod_data.protocol_type = USB_SC_SCSI;
 	mod_data.protocol_name = "Transparent SCSI";
 
-	if (gadget_is_sh(fsg-&gt;gadget))
+	/* Some peripheral controllers are known not to be able to
+	 * halt bulk endpoints correctly.  If one of them is present,
+	 * disable stalls.
+	 */
+	if (gadget_is_sh(fsg-&gt;gadget) || gadget_is_at91(fsg-&gt;gadget))
 		mod_data.can_stall = 0;
 
 	if (mod_data.release == 0xffff) {	// Parameter wasn't set</pre>
    <div class="pagination">
        <a href='2_80.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><span>[81]</span><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_82.html'>Next&gt;&gt;</a>
    <div>
</body>
