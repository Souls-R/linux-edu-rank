<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_15.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><span>[16]</span><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_17.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 1e19a520a9258f3c7286826e7172e56bf6da86dc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Feb 5 14:33:02 2019 -0500

    USB: gadget: Improve kerneldoc for usb_ep_dequeue()
    
    Commit bf594c1070f5 ("USB: gadget: Document that certain ep operations
    can be called in interrupt context") documented that usb_ep_dequeue()
    may be called in a non-process context.  It follows that the routine
    must not sleep or wait for events.
    
    However, the routine's existing kerneldoc seems to imply that it will
    wait until the request being cancelled has fully completed.  This is
    not so, and thus the comment needs to be improved.  Misunderstanding
    this point may very well have been responsible for a bug recently
    uncovered in the f_fs function.
    
    The updated comment explicitly says that the routine may return before
    the request's completion handler is called.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: John Stultz &lt;john.stultz@linaro.org&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 87d6b12779f2..7cf34beb50df 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -281,10 +281,10 @@ EXPORT_SYMBOL_GPL(usb_ep_queue);
  * @ep:the endpoint associated with the request
  * @req:the request being canceled
  *
- * If the request is still active on the endpoint, it is dequeued and its
- * completion routine is called (with status -ECONNRESET); else a negative
- * error code is returned. This is guaranteed to happen before the call to
- * usb_ep_dequeue() returns.
+ * If the request is still active on the endpoint, it is dequeued and
+ * eventually its completion routine is called (with status -ECONNRESET);
+ * else a negative error code is returned.  This routine is asynchronous,
+ * that is, it may return before the completion routine runs.
  *
  * Note that some hardware can't clear out write fifos (to unlink the request
  * at the head of the queue) except as part of disconnecting from usb. Such</pre><hr><pre>commit d81bb019d7bb30091e3c796102c00935d6dd7ca9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 28 11:25:58 2018 -0500

    USB: Fix invalid-free bug in port_over_current_notify()
    
    Syzbot and KASAN found the following invalid-free bug in
    port_over_current_notify():
    
    --------------------------------------------------------------------------
    BUG: KASAN: double-free or invalid-free in port_over_current_notify
    drivers/usb/core/hub.c:5192 [inline]
    BUG: KASAN: double-free or invalid-free in port_event
    drivers/usb/core/hub.c:5241 [inline]
    BUG: KASAN: double-free or invalid-free in hub_event+0xd97/0x4140
    drivers/usb/core/hub.c:5384
    
    CPU: 1 PID: 32710 Comm: kworker/1:3 Not tainted 4.20.0-rc3+ #129
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Workqueue: usb_hub_wq hub_event
    Call Trace:
      __dump_stack lib/dump_stack.c:77 [inline]
      dump_stack+0x244/0x39d lib/dump_stack.c:113
      print_address_description.cold.7+0x9/0x1ff mm/kasan/report.c:256
      kasan_report_invalid_free+0x64/0xa0 mm/kasan/report.c:336
      __kasan_slab_free+0x13a/0x150 mm/kasan/kasan.c:501
      kasan_slab_free+0xe/0x10 mm/kasan/kasan.c:528
      __cache_free mm/slab.c:3498 [inline]
      kfree+0xcf/0x230 mm/slab.c:3817
      port_over_current_notify drivers/usb/core/hub.c:5192 [inline]
      port_event drivers/usb/core/hub.c:5241 [inline]
      hub_event+0xd97/0x4140 drivers/usb/core/hub.c:5384
      process_one_work+0xc90/0x1c40 kernel/workqueue.c:2153
      worker_thread+0x17f/0x1390 kernel/workqueue.c:2296
      kthread+0x35a/0x440 kernel/kthread.c:246
      ret_from_fork+0x3a/0x50 arch/x86/entry/entry_64.S:352
    --------------------------------------------------------------------------
    
    The problem is caused by use of a static array to store
    environment-string pointers.  When the routine is called by multiple
    threads concurrently, the pointers from one thread can overwrite those
    from another.
    
    The solution is to use an ordinary automatic array instead of a static
    array.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: syzbot+98881958e1410ec7e53c@syzkaller.appspotmail.com
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 0f9381b69a3b..528664059a12 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5163,7 +5163,7 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 /* Handle notifying userspace about hub over-current events */
 static void port_over_current_notify(struct usb_port *port_dev)
 {
-	static char *envp[] = { NULL, NULL, NULL };
+	char *envp[3];
 	struct device *hub_dev;
 	char *port_dev_path;
 
@@ -5187,6 +5187,7 @@ static void port_over_current_notify(struct usb_port *port_dev)
 	if (!envp[1])
 		goto exit;
 
+	envp[2] = NULL;
 	kobject_uevent_env(&amp;hub_dev-&gt;kobj, KOBJ_CHANGE, envp);
 
 	kfree(envp[1]);</pre><hr><pre>commit 665c365a77fbfeabe52694aedf3446d5f2f1ce42
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 15 16:55:04 2018 -0400

    USB: fix the usbfs flag sanitization for control transfers
    
    Commit 7a68d9fb8510 ("USB: usbdevfs: sanitize flags more") checks the
    transfer flags for URBs submitted from userspace via usbfs.  However,
    the check for whether the USBDEVFS_URB_SHORT_NOT_OK flag should be
    allowed for a control transfer was added in the wrong place, before
    the code has properly determined the direction of the control
    transfer.  (Control transfers are special because for them, the
    direction is set by the bRequestType byte of the Setup packet rather
    than direction bit of the endpoint address.)
    
    This patch moves code which sets up the allow_short flag for control
    transfers down after is_in has been set to the correct value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: syzbot+24a30223a4b609bb802e@syzkaller.appspotmail.com
    Fixes: 7a68d9fb8510 ("USB: usbdevfs: sanitize flags more")
    CC: Oliver Neukum &lt;oneukum@suse.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 244417d0dfd1..ffccd40ea67d 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -1474,8 +1474,6 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 	u = 0;
 	switch (uurb-&gt;type) {
 	case USBDEVFS_URB_TYPE_CONTROL:
-		if (is_in)
-			allow_short = true;
 		if (!usb_endpoint_xfer_control(&amp;ep-&gt;desc))
 			return -EINVAL;
 		/* min 8 byte setup packet */
@@ -1505,6 +1503,8 @@ static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb
 			is_in = 0;
 			uurb-&gt;endpoint &amp;= ~USB_DIR_IN;
 		}
+		if (is_in)
+			allow_short = true;
 		snoop(&amp;ps-&gt;dev-&gt;dev, "control urb: bRequestType=%02x "
 			"bRequest=%02x wValue=%04x "
 			"wIndex=%04x wLength=%04x\n",</pre><hr><pre>commit 3b766f45355775fc5c404b7ff88f3fd3e9d77f86
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 2 10:18:40 2018 -0400

    USB: net2280: Remove -&gt;disconnect() callback from net2280_pullup()
    
    The net2280 UDC driver invokes the gadget driver's -&gt;disconnect()
    callback routine when the net2280_pullup() routine turns off the D+
    pullup.  This is now unnecessary, because the gadget core performs the
    callback on our behalf.  This patch removes the unneeded callback.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index b02ab2a8d927..e7dae5379e04 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -1550,9 +1550,6 @@ static int net2280_pullup(struct usb_gadget *_gadget, int is_on)
 
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
-	if (!is_on &amp;&amp; dev-&gt;driver)
-		dev-&gt;driver-&gt;disconnect(&amp;dev-&gt;gadget);
-
 	return 0;
 }
 </pre><hr><pre>commit 6e89e831a90172bc3d34ecbba52af5b9c4a447d1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 26 11:29:17 2018 -0700

    tools/memory-model: Add extra ordering for locks and remove it for ordinary release/acquire
    
    More than one kernel developer has expressed the opinion that the LKMM
    should enforce ordering of writes by locking.  In other words, given
    the following code:
    
            WRITE_ONCE(x, 1);
            spin_unlock(&amp;s):
            spin_lock(&amp;s);
            WRITE_ONCE(y, 1);
    
    the stores to x and y should be propagated in order to all other CPUs,
    even though those other CPUs might not access the lock s.  In terms of
    the memory model, this means expanding the cumul-fence relation.
    
    Locks should also provide read-read (and read-write) ordering in a
    similar way.  Given:
    
            READ_ONCE(x);
            spin_unlock(&amp;s);
            spin_lock(&amp;s);
            READ_ONCE(y);           // or WRITE_ONCE(y, 1);
    
    the load of x should be executed before the load of (or store to) y.
    The LKMM already provides this ordering, but it provides it even in
    the case where the two accesses are separated by a release/acquire
    pair of fences rather than unlock/lock.  This would prevent
    architectures from using weakly ordered implementations of release and
    acquire, which seems like an unnecessary restriction.  The patch
    therefore removes the ordering requirement from the LKMM for that
    case.
    
    There are several arguments both for and against this change.  Let us
    refer to these enhanced ordering properties by saying that the LKMM
    would require locks to be RCtso (a bit of a misnomer, but analogous to
    RCpc and RCsc) and it would require ordinary acquire/release only to
    be RCpc.  (Note: In the following, the phrase "all supported
    architectures" is meant not to include RISC-V.  Although RISC-V is
    indeed supported by the kernel, the implementation is still somewhat
    in a state of flux and therefore statements about it would be
    premature.)
    
    Pros:
    
            The kernel already provides RCtso ordering for locks on all
            supported architectures, even though this is not stated
            explicitly anywhere.  Therefore the LKMM should formalize it.
    
            In theory, guaranteeing RCtso ordering would reduce the need
            for additional barrier-like constructs meant to increase the
            ordering strength of locks.
    
            Will Deacon and Peter Zijlstra are strongly in favor of
            formalizing the RCtso requirement.  Linus Torvalds and Will
            would like to go even further, requiring locks to have RCsc
            behavior (ordering preceding writes against later reads), but
            they recognize that this would incur a noticeable performance
            degradation on the POWER architecture.  Linus also points out
            that people have made the mistake, in the past, of assuming
            that locking has stronger ordering properties than is
            currently guaranteed, and this change would reduce the
            likelihood of such mistakes.
    
            Not requiring ordinary acquire/release to be any stronger than
            RCpc may prove advantageous for future architectures, allowing
            them to implement smp_load_acquire() and smp_store_release()
            with more efficient machine instructions than would be
            possible if the operations had to be RCtso.  Will and Linus
            approve this rationale, hypothetical though it is at the
            moment (it may end up affecting the RISC-V implementation).
            The same argument may or may not apply to RMW-acquire/release;
            see also the second Con entry below.
    
            Linus feels that locks should be easy for people to use
            without worrying about memory consistency issues, since they
            are so pervasive in the kernel, whereas acquire/release is
            much more of an "experts only" tool.  Requiring locks to be
            RCtso is a step in this direction.
    
    Cons:
    
            Andrea Parri and Luc Maranget think that locks should have the
            same ordering properties as ordinary acquire/release (indeed,
            Luc points out that the names "acquire" and "release" derive
            from the usage of locks).  Andrea points out that having
            different ordering properties for different forms of acquires
            and releases is not only unnecessary, it would also be
            confusing and unmaintainable.
    
            Locks are constructed from lower-level primitives, typically
            RMW-acquire (for locking) and ordinary release (for unlock).
            It is illogical to require stronger ordering properties from
            the high-level operations than from the low-level operations
            they comprise.  Thus, this change would make
    
                    while (cmpxchg_acquire(&amp;s, 0, 1) != 0)
                            cpu_relax();
    
            an incorrect implementation of spin_lock(&amp;s) as far as the
            LKMM is concerned.  In theory this weakness can be ameliorated
            by changing the LKMM even further, requiring
            RMW-acquire/release also to be RCtso (which it already is on
            all supported architectures).
    
            As far as I know, nobody has singled out any examples of code
            in the kernel that actually relies on locks being RCtso.
            (People mumble about RCU and the scheduler, but nobody has
            pointed to any actual code.  If there are any real cases,
            their number is likely quite small.)  If RCtso ordering is not
            needed, why require it?
    
            A handful of locking constructs (qspinlocks, qrwlocks, and
            mcs_spinlocks) are built on top of smp_cond_load_acquire()
            instead of an RMW-acquire instruction.  It currently provides
            only the ordinary acquire semantics, not the stronger ordering
            this patch would require of locks.  In theory this could be
            ameliorated by requiring smp_cond_load_acquire() in
            combination with ordinary release also to be RCtso (which is
            currently true on all supported architectures).
    
            On future weakly ordered architectures, people may be able to
            implement locks in a non-RCtso fashion with significant
            performance improvement.  Meeting the RCtso requirement would
            necessarily add run-time overhead.
    
    Overall, the technical aspects of these arguments seem relatively
    minor, and it appears mostly to boil down to a matter of opinion.
    Since the opinions of senior kernel maintainers such as Linus,
    Peter, and Will carry more weight than those of Luc and Andrea, this
    patch changes the model in accordance with the maintainers' wishes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@linux.vnet.ibm.com&gt;
    Reviewed-by: Will Deacon &lt;will.deacon@arm.com&gt;
    Reviewed-by: Andrea Parri &lt;andrea.parri@amarulasolutions.com&gt;
    Acked-by: Peter Zijlstra (Intel) &lt;peterz@infradead.org&gt;
    Cc: Alexander Shishkin &lt;alexander.shishkin@linux.intel.com&gt;
    Cc: Arnaldo Carvalho de Melo &lt;acme@redhat.com&gt;
    Cc: Jiri Olsa &lt;jolsa@redhat.com&gt;
    Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
    Cc: Peter Zijlstra &lt;peterz@infradead.org&gt;
    Cc: Stephane Eranian &lt;eranian@google.com&gt;
    Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Cc: Vince Weaver &lt;vincent.weaver@maine.edu&gt;
    Cc: akiyks@gmail.com
    Cc: boqun.feng@gmail.com
    Cc: dhowells@redhat.com
    Cc: j.alglave@ucl.ac.uk
    Cc: linux-arch@vger.kernel.org
    Cc: luc.maranget@inria.fr
    Cc: npiggin@gmail.com
    Cc: parri.andrea@gmail.com
    Link: http://lkml.kernel.org/r/20180926182920.27644-2-paulmck@linux.ibm.com
    Signed-off-by: Ingo Molnar &lt;mingo@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 0cbd1ef8f86d..35bff92cc773 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -28,7 +28,8 @@ Explanation of the Linux-Kernel Memory Consistency Model
   20. THE HAPPENS-BEFORE RELATION: hb
   21. THE PROPAGATES-BEFORE RELATION: pb
   22. RCU RELATIONS: rcu-link, gp, rscs, rcu-fence, and rb
-  23. ODDS AND ENDS
+  23. LOCKING
+  24. ODDS AND ENDS
 
 
 
@@ -1067,28 +1068,6 @@ allowing out-of-order writes like this to occur.  The model avoided
 violating the write-write coherence rule by requiring the CPU not to
 send the W write to the memory subsystem at all!)
 
-There is one last example of preserved program order in the LKMM: when
-a load-acquire reads from an earlier store-release.  For example:
-
-	smp_store_release(&amp;x, 123);
-	r1 = smp_load_acquire(&amp;x);
-
-If the smp_load_acquire() ends up obtaining the 123 value that was
-stored by the smp_store_release(), the LKMM says that the load must be
-executed after the store; the store cannot be forwarded to the load.
-This requirement does not arise from the operational model, but it
-yields correct predictions on all architectures supported by the Linux
-kernel, although for differing reasons.
-
-On some architectures, including x86 and ARMv8, it is true that the
-store cannot be forwarded to the load.  On others, including PowerPC
-and ARMv7, smp_store_release() generates object code that starts with
-a fence and smp_load_acquire() generates object code that ends with a
-fence.  The upshot is that even though the store may be forwarded to
-the load, it is still true that any instruction preceding the store
-will be executed before the load or any following instructions, and
-the store will be executed before any instruction following the load.
-
 
 AND THEN THERE WAS ALPHA
 ------------------------
@@ -1766,6 +1745,147 @@ before it does, and the critical section in P2 both starts after P1's
 grace period does and ends after it does.
 
 
+LOCKING
+-------
+
+The LKMM includes locking.  In fact, there is special code for locking
+in the formal model, added in order to make tools run faster.
+However, this special code is intended to be more or less equivalent
+to concepts we have already covered.  A spinlock_t variable is treated
+the same as an int, and spin_lock(&amp;s) is treated almost the same as:
+
+	while (cmpxchg_acquire(&amp;s, 0, 1) != 0)
+		cpu_relax();
+
+This waits until s is equal to 0 and then atomically sets it to 1,
+and the read part of the cmpxchg operation acts as an acquire fence.
+An alternate way to express the same thing would be:
+
+	r = xchg_acquire(&amp;s, 1);
+
+along with a requirement that at the end, r = 0.  Similarly,
+spin_trylock(&amp;s) is treated almost the same as:
+
+	return !cmpxchg_acquire(&amp;s, 0, 1);
+
+which atomically sets s to 1 if it is currently equal to 0 and returns
+true if it succeeds (the read part of the cmpxchg operation acts as an
+acquire fence only if the operation is successful).  spin_unlock(&amp;s)
+is treated almost the same as:
+
+	smp_store_release(&amp;s, 0);
+
+The "almost" qualifiers above need some explanation.  In the LKMM, the
+store-release in a spin_unlock() and the load-acquire which forms the
+first half of the atomic rmw update in a spin_lock() or a successful
+spin_trylock() -- we can call these things lock-releases and
+lock-acquires -- have two properties beyond those of ordinary releases
+and acquires.
+
+First, when a lock-acquire reads from a lock-release, the LKMM
+requires that every instruction po-before the lock-release must
+execute before any instruction po-after the lock-acquire.  This would
+naturally hold if the release and acquire operations were on different
+CPUs, but the LKMM says it holds even when they are on the same CPU.
+For example:
+
+	int x, y;
+	spinlock_t s;
+
+	P0()
+	{
+		int r1, r2;
+
+		spin_lock(&amp;s);
+		r1 = READ_ONCE(x);
+		spin_unlock(&amp;s);
+		spin_lock(&amp;s);
+		r2 = READ_ONCE(y);
+		spin_unlock(&amp;s);
+	}
+
+	P1()
+	{
+		WRITE_ONCE(y, 1);
+		smp_wmb();
+		WRITE_ONCE(x, 1);
+	}
+
+Here the second spin_lock() reads from the first spin_unlock(), and
+therefore the load of x must execute before the load of y.  Thus we
+cannot have r1 = 1 and r2 = 0 at the end (this is an instance of the
+MP pattern).
+
+This requirement does not apply to ordinary release and acquire
+fences, only to lock-related operations.  For instance, suppose P0()
+in the example had been written as:
+
+	P0()
+	{
+		int r1, r2, r3;
+
+		r1 = READ_ONCE(x);
+		smp_store_release(&amp;s, 1);
+		r3 = smp_load_acquire(&amp;s);
+		r2 = READ_ONCE(y);
+	}
+
+Then the CPU would be allowed to forward the s = 1 value from the
+smp_store_release() to the smp_load_acquire(), executing the
+instructions in the following order:
+
+		r3 = smp_load_acquire(&amp;s);	// Obtains r3 = 1
+		r2 = READ_ONCE(y);
+		r1 = READ_ONCE(x);
+		smp_store_release(&amp;s, 1);	// Value is forwarded
+
+and thus it could load y before x, obtaining r2 = 0 and r1 = 1.
+
+Second, when a lock-acquire reads from a lock-release, and some other
+stores W and W' occur po-before the lock-release and po-after the
+lock-acquire respectively, the LKMM requires that W must propagate to
+each CPU before W' does.  For example, consider:
+
+	int x, y;
+	spinlock_t x;
+
+	P0()
+	{
+		spin_lock(&amp;s);
+		WRITE_ONCE(x, 1);
+		spin_unlock(&amp;s);
+	}
+
+	P1()
+	{
+		int r1;
+
+		spin_lock(&amp;s);
+		r1 = READ_ONCE(x);
+		WRITE_ONCE(y, 1);
+		spin_unlock(&amp;s);
+	}
+
+	P2()
+	{
+		int r2, r3;
+
+		r2 = READ_ONCE(y);
+		smp_rmb();
+		r3 = READ_ONCE(x);
+	}
+
+If r1 = 1 at the end then the spin_lock() in P1 must have read from
+the spin_unlock() in P0.  Hence the store to x must propagate to P2
+before the store to y does, so we cannot have r2 = 1 and r3 = 0.
+
+These two special requirements for lock-release and lock-acquire do
+not arise from the operational model.  Nevertheless, kernel developers
+have come to expect and rely on them because they do hold on all
+architectures supported by the Linux kernel, albeit for various
+differing reasons.
+
+
 ODDS AND ENDS
 -------------
 
@@ -1831,26 +1951,6 @@ they behave as follows:
 	events and the events preceding them against all po-later
 	events.
 
-The LKMM includes locking.  In fact, there is special code for locking
-in the formal model, added in order to make tools run faster.
-However, this special code is intended to be exactly equivalent to
-concepts we have already covered.  A spinlock_t variable is treated
-the same as an int, and spin_lock(&amp;s) is treated the same as:
-
-	while (cmpxchg_acquire(&amp;s, 0, 1) != 0)
-		cpu_relax();
-
-which waits until s is equal to 0 and then atomically sets it to 1,
-and where the read part of the atomic update is also an acquire fence.
-An alternate way to express the same thing would be:
-
-	r = xchg_acquire(&amp;s, 1);
-
-along with a requirement that at the end, r = 0.  spin_unlock(&amp;s) is
-treated the same as:
-
-	smp_store_release(&amp;s, 0);
-
 Interestingly, RCU and locking each introduce the possibility of
 deadlock.  When faced with code sequences such as:
 
diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index 59b5cbe6b624..882fc33274ac 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -38,7 +38,7 @@ let strong-fence = mb | gp
 (* Release Acquire *)
 let acq-po = [Acquire] ; po ; [M]
 let po-rel = [M] ; po ; [Release]
-let rfi-rel-acq = [Release] ; rfi ; [Acquire]
+let po-unlock-rf-lock-po = po ; [UL] ; rf ; [LKR] ; po
 
 (**********************************)
 (* Fundamental coherence ordering *)
@@ -60,13 +60,13 @@ let dep = addr | data
 let rwdep = (dep | ctrl) ; [W]
 let overwrite = co | fr
 let to-w = rwdep | (overwrite &amp; int)
-let to-r = addr | (dep ; rfi) | rfi-rel-acq
+let to-r = addr | (dep ; rfi)
 let fence = strong-fence | wmb | po-rel | rmb | acq-po
-let ppo = to-r | to-w | fence
+let ppo = to-r | to-w | fence | (po-unlock-rf-lock-po &amp; int)
 
 (* Propagation: Ordering from release operations and strong fences. *)
 let A-cumul(r) = rfe? ; r
-let cumul-fence = A-cumul(strong-fence | po-rel) | wmb
+let cumul-fence = A-cumul(strong-fence | po-rel) | wmb | po-unlock-rf-lock-po
 let prop = (overwrite &amp; ext)? ; cumul-fence* ; rfe?
 
 (*
diff --git a/tools/memory-model/litmus-tests/ISA2+pooncelock+pooncelock+pombonce.litmus b/tools/memory-model/litmus-tests/ISA2+pooncelock+pooncelock+pombonce.litmus
index 0f749e419b34..094d58df7789 100644
--- a/tools/memory-model/litmus-tests/ISA2+pooncelock+pooncelock+pombonce.litmus
+++ b/tools/memory-model/litmus-tests/ISA2+pooncelock+pooncelock+pombonce.litmus
@@ -1,11 +1,10 @@
 C ISA2+pooncelock+pooncelock+pombonce
 
 (*
- * Result: Sometimes
+ * Result: Never
  *
- * This test shows that the ordering provided by a lock-protected S
- * litmus test (P0() and P1()) are not visible to external process P2().
- * This is likely to change soon.
+ * This test shows that write-write ordering provided by locks
+ * (in P0() and P1()) is visible to external process P2().
  *)
 
 {}</pre><hr><pre>commit 0a55187a1ec8c03d0619e7ce41d10fdc39cff036
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 10 15:32:25 2018 -0400

    USB: gadget core: Issue -&gt;disconnect() callback from usb_gadget_disconnect()
    
    The gadget documentation doesn't state clearly whether a gadget
    driver's -&gt;disconnect() callback should be invoked when the D+ pullup
    is turned off.  Some UDC drivers do this and some don't.  This patch
    settles the issue by making the core function usb_gadget_disconnect()
    issue the callback, so that UDC drivers don't need to worry about it.
    
    A description of the new behavior is added to the function's
    kerneldoc.  Also, the patch removes a few superseded callbacks from
    other core routines.
    
    Future patches will remove the -&gt;disconnect() calls from the UDC
    drivers that make them, as they are now unnecessary.  Until all those
    patches are merged gadget drivers may receive extra -&gt;disconnect()
    callbacks, but this should be harmless.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;felipe.balbi@linux.intel.com&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index af88b48c1cea..87d6b12779f2 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -690,6 +690,9 @@ EXPORT_SYMBOL_GPL(usb_gadget_connect);
  * as a disconnect (when a VBUS session is active).  Not all systems
  * support software pullup controls.
  *
+ * Following a successful disconnect, invoke the -&gt;disconnect() callback
+ * for the current gadget driver so that UDC drivers don't need to.
+ *
  * Returns zero on success, else negative errno.
  */
 int usb_gadget_disconnect(struct usb_gadget *gadget)
@@ -711,8 +714,10 @@ int usb_gadget_disconnect(struct usb_gadget *gadget)
 	}
 
 	ret = gadget-&gt;ops-&gt;pullup(gadget, 0);
-	if (!ret)
+	if (!ret) {
 		gadget-&gt;connected = 0;
+		gadget-&gt;udc-&gt;driver-&gt;disconnect(gadget);
+	}
 
 out:
 	trace_usb_gadget_disconnect(gadget, ret);
@@ -1281,7 +1286,6 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_CHANGE);
 
 	usb_gadget_disconnect(udc-&gt;gadget);
-	udc-&gt;driver-&gt;disconnect(udc-&gt;gadget);
 	udc-&gt;driver-&gt;unbind(udc-&gt;gadget);
 	usb_gadget_udc_stop(udc);
 
@@ -1471,7 +1475,6 @@ static ssize_t soft_connect_store(struct device *dev,
 		usb_gadget_connect(udc-&gt;gadget);
 	} else if (sysfs_streq(buf, "disconnect")) {
 		usb_gadget_disconnect(udc-&gt;gadget);
-		udc-&gt;driver-&gt;disconnect(udc-&gt;gadget);
 		usb_gadget_udc_stop(udc);
 	} else {
 		dev_err(dev, "unsupported command '%s'\n", buf);</pre><hr><pre>commit c9a4cb204e9eb7fa7dfbe3f7d3a674fa530aa193
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 14:00:53 2018 -0400

    USB: handle NULL config in usb_find_alt_setting()
    
    usb_find_alt_setting() takes a pointer to a struct usb_host_config as
    an argument; it searches for an interface with specified interface and
    alternate setting numbers in that config.  However, it crashes if the
    usb_host_config pointer argument is NULL.
    
    Since this is a general-purpose routine, available for use in many
    places, we want to to be more robust.  This patch makes it return NULL
    whenever the config argument is NULL.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: syzbot+19c3aaef85a89d451eac@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 623be3174fb3..79d8bd7a612e 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -228,6 +228,8 @@ struct usb_host_interface *usb_find_alt_setting(
 	struct usb_interface_cache *intf_cache = NULL;
 	int i;
 
+	if (!config)
+		return NULL;
 	for (i = 0; i &lt; config-&gt;desc.bNumInterfaces; i++) {
 		if (config-&gt;intf_cache[i]-&gt;altsetting[0].desc.bInterfaceNumber
 				== iface_num) {</pre><hr><pre>commit bd729f9d67aa9a303d8925bb8c4f06af25f407d1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 13:59:59 2018 -0400

    USB: fix error handling in usb_driver_claim_interface()
    
    The syzbot fuzzing project found a use-after-free bug in the USB
    core.  The bug was caused by usbfs not unbinding from an interface
    when the USB device file was closed, which led another process to
    attempt the unbind later on, after the private data structure had been
    deallocated.
    
    The reason usbfs did not unbind the interface at the appropriate time
    was because it thought the interface had never been claimed in the
    first place.  This was caused by the fact that
    usb_driver_claim_interface() does not clean up properly when
    device_bind_driver() returns an error.  Although the error code gets
    passed back to the caller, the iface-&gt;dev.driver pointer remains set
    and iface-&gt;condition remains equal to USB_INTERFACE_BOUND.
    
    This patch adds proper error handling to usb_driver_claim_interface().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: syzbot+f84aa7209ccec829536f@syzkaller.appspotmail.com
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 7652dcb57998..a1f225f077cd 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -550,6 +550,21 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	if (device_is_registered(dev))
 		retval = device_bind_driver(dev);
 
+	if (retval) {
+		dev-&gt;driver = NULL;
+		usb_set_intfdata(iface, NULL);
+		iface-&gt;needs_remote_wakeup = 0;
+		iface-&gt;condition = USB_INTERFACE_UNBOUND;
+
+		/*
+		 * Unbound interfaces are always runtime-PM-disabled
+		 * and runtime-PM-suspended
+		 */
+		if (driver-&gt;supports_autosuspend)
+			pm_runtime_disable(dev);
+		pm_runtime_set_suspended(dev);
+	}
+
 	return retval;
 }
 EXPORT_SYMBOL_GPL(usb_driver_claim_interface);</pre><hr><pre>commit c183813fcee44a249339b7c46e1ad271ca1870aa
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 10 13:58:51 2018 -0400

    USB: remove LPM management from usb_driver_claim_interface()
    
    usb_driver_claim_interface() disables and re-enables Link Power
    Management, but it shouldn't do either one, for the reasons listed
    below.  This patch removes the two LPM-related function calls from the
    routine.
    
    The reason for disabling LPM in the analogous function
    usb_probe_interface() is so that drivers won't have to deal with
    unwanted LPM transitions in their probe routine.  But
    usb_driver_claim_interface() doesn't call the driver's probe routine
    (or any other callbacks), so that reason doesn't apply here.
    
    Furthermore, no driver other than usbfs will ever call
    usb_driver_claim_interface() unless it is already bound to another
    interface in the same device, which means disabling LPM here would be
    redundant.  usbfs doesn't interact with LPM at all.
    
    Lastly, the error return from usb_unlocked_disable_lpm() isn't handled
    properly; the code doesn't clean up its earlier actions before
    returning.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: 8306095fd2c1 ("USB: Disable USB 3.0 LPM in critical sections.")
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index e76e95f62f76..7652dcb57998 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -512,7 +512,6 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	struct device *dev;
 	struct usb_device *udev;
 	int retval = 0;
-	int lpm_disable_error = -ENODEV;
 
 	if (!iface)
 		return -ENODEV;
@@ -533,16 +532,6 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 
-	/* See the comment about disabling LPM in usb_probe_interface(). */
-	if (driver-&gt;disable_hub_initiated_lpm) {
-		lpm_disable_error = usb_unlocked_disable_lpm(udev);
-		if (lpm_disable_error) {
-			dev_err(&amp;iface-&gt;dev, "%s Failed to disable LPM for driver %s\n",
-				__func__, driver-&gt;name);
-			return -ENOMEM;
-		}
-	}
-
 	/* Claimed interfaces are initially inactive (suspended) and
 	 * runtime-PM-enabled, but only if the driver has autosuspend
 	 * support.  Otherwise they are marked active, to prevent the
@@ -561,10 +550,6 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	if (device_is_registered(dev))
 		retval = device_bind_driver(dev);
 
-	/* Attempt to re-enable USB3 LPM, if the disable was successful. */
-	if (!lpm_disable_error)
-		usb_unlocked_enable_lpm(udev);
-
 	return retval;
 }
 EXPORT_SYMBOL_GPL(usb_driver_claim_interface);</pre><hr><pre>commit 87f88dfcde0ecde2a1136b8364099dddb9895b12
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 28 10:57:25 2018 -0400

    USB: OHCI: Remove USB bus reset delay from OHCI handover code
    
    Paul pointed out that the 50-ms sleep during OHCI initialization takes
    up a large fraction of a system's boot time.  Things get worse when
    there are two OHCI controllers present, each requiring 50 ms.
    
    However, there really is no need to send a 50-ms reset signal out all
    the root-hub ports during initialization.  The ports themselves will
    be disabled, and the only way to enable a port is to reset it.
    Therefore all attached USB devices will receive a proper reset in any
    case.  The controller reset does not need to be long enough to reset
    those other devices, so the 50-ms delay isn't necessary.
    
    Without the delay, there is no remaining incentive for skipping the
    reset when the controller is already in the RESET state.  This patch
    removes the test, issuing the command unconditionally, and removes the
    following delay.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Suggested-by: Paul Menzel &lt;pmenzel@molgen.mpg.de&gt;
    Tested-by: Paul Menzel &lt;pmenzel@molgen.mpg.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c
index 3625a5c1a41b..3ce71cbfbb58 100644
--- a/drivers/usb/host/pci-quirks.c
+++ b/drivers/usb/host/pci-quirks.c
@@ -783,15 +783,9 @@ static void quirk_usb_handoff_ohci(struct pci_dev *pdev)
 	/* disable interrupts */
 	writel((u32) ~0, base + OHCI_INTRDISABLE);
 
-	/* Reset the USB bus, if the controller isn't already in RESET */
-	if (control &amp; OHCI_HCFS) {
-		/* Go into RESET, preserving RWC (and possibly IR) */
-		writel(control &amp; OHCI_CTRL_MASK, base + OHCI_CONTROL);
-		readl(base + OHCI_CONTROL);
-
-		/* drive bus reset for at least 50 ms (7.1.7.5) */
-		msleep(50);
-	}
+	/* Go into the USB_RESET state, preserving RWC (and possibly IR) */
+	writel(control &amp; OHCI_CTRL_MASK, base + OHCI_CONTROL);
+	readl(base + OHCI_CONTROL);
 
 	/* software reset of the controller, preserving HcFmInterval */
 	if (!no_fminterval)</pre>
    <div class="pagination">
        <a href='2_15.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><span>[16]</span><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_17.html'>Next&gt;&gt;</a>
    <div>
</body>
