<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_38.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><span>[39]</span><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_40.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit a54a52caad4bd6166cb7fa64e4e93031fa2fda5d
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Jun 28 12:00:23 2006 -0500

    [SCSI] iscsi: fixup set/get param functions
    
    Reduce duplication in the software iscsi_transport modules by
    adding a libiscsi function to handle the common grunt work.
    
    This also has the drivers return specifc -EXXX values for different
    errors so userspace can finally handle them in a sane way.
    
    Also just pass the sysfs buffers to the drivers so HW iscsi can
    get/set its string values, like targetname, and initiatorname.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 2673a11a9495..7c76a989b218 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1697,6 +1697,185 @@ int iscsi_conn_bind(struct iscsi_cls_session *cls_session,
 }
 EXPORT_SYMBOL_GPL(iscsi_conn_bind);
 
+
+int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
+		    enum iscsi_param param, char *buf, int buflen)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	struct iscsi_session *session = conn-&gt;session;
+	uint32_t value;
+
+	switch(param) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		sscanf(buf, "%d", &amp;conn-&gt;max_recv_dlength);
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		sscanf(buf, "%d", &amp;conn-&gt;max_xmit_dlength);
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		sscanf(buf, "%d", &amp;conn-&gt;hdrdgst_en);
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		sscanf(buf, "%d", &amp;conn-&gt;datadgst_en);
+		break;
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		sscanf(buf, "%d", &amp;session-&gt;initial_r2t_en);
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		sscanf(buf, "%d", &amp;session-&gt;max_r2t);
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		sscanf(buf, "%d", &amp;session-&gt;imm_data_en);
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		sscanf(buf, "%d", &amp;session-&gt;first_burst);
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		sscanf(buf, "%d", &amp;session-&gt;max_burst);
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		sscanf(buf, "%d", &amp;session-&gt;pdu_inorder_en);
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		sscanf(buf, "%d", &amp;session-&gt;dataseq_inorder_en);
+		break;
+	case ISCSI_PARAM_ERL:
+		sscanf(buf, "%d", &amp;session-&gt;erl);
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		sscanf(buf, "%d", &amp;value);
+		BUG_ON(value);
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		sscanf(buf, "%d", &amp;value);
+		BUG_ON(value);
+		break;
+	case ISCSI_PARAM_EXP_STATSN:
+		sscanf(buf, "%u", &amp;conn-&gt;exp_statsn);
+		break;
+	case ISCSI_PARAM_TARGET_NAME:
+		/* this should not change between logins */
+		if (session-&gt;targetname)
+			break;
+
+		session-&gt;targetname = kstrdup(buf, GFP_KERNEL);
+		if (!session-&gt;targetname)
+			return -ENOMEM;
+		break;
+	case ISCSI_PARAM_TPGT:
+		sscanf(buf, "%d", &amp;session-&gt;tpgt);
+		break;
+	case ISCSI_PARAM_PERSISTENT_PORT:
+		sscanf(buf, "%d", &amp;conn-&gt;persistent_port);
+		break;
+	case ISCSI_PARAM_PERSISTENT_ADDRESS:
+		/*
+		 * this is the address returned in discovery so it should
+		 * not change between logins.
+		 */
+		if (conn-&gt;persistent_address)
+			break;
+
+		conn-&gt;persistent_address = kstrdup(buf, GFP_KERNEL);
+		if (!conn-&gt;persistent_address)
+			return -ENOMEM;
+		break;
+	default:
+		return -ENOSYS;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iscsi_set_param);
+
+int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
+			    enum iscsi_param param, char *buf)
+{
+	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
+	struct iscsi_session *session = iscsi_hostdata(shost-&gt;hostdata);
+	int len;
+
+	switch(param) {
+	case ISCSI_PARAM_INITIAL_R2T_EN:
+		len = sprintf(buf, "%d\n", session-&gt;initial_r2t_en);
+		break;
+	case ISCSI_PARAM_MAX_R2T:
+		len = sprintf(buf, "%hu\n", session-&gt;max_r2t);
+		break;
+	case ISCSI_PARAM_IMM_DATA_EN:
+		len = sprintf(buf, "%d\n", session-&gt;imm_data_en);
+		break;
+	case ISCSI_PARAM_FIRST_BURST:
+		len = sprintf(buf, "%u\n", session-&gt;first_burst);
+		break;
+	case ISCSI_PARAM_MAX_BURST:
+		len = sprintf(buf, "%u\n", session-&gt;max_burst);
+		break;
+	case ISCSI_PARAM_PDU_INORDER_EN:
+		len = sprintf(buf, "%d\n", session-&gt;pdu_inorder_en);
+		break;
+	case ISCSI_PARAM_DATASEQ_INORDER_EN:
+		len = sprintf(buf, "%d\n", session-&gt;dataseq_inorder_en);
+		break;
+	case ISCSI_PARAM_ERL:
+		len = sprintf(buf, "%d\n", session-&gt;erl);
+		break;
+	case ISCSI_PARAM_TARGET_NAME:
+		len = sprintf(buf, "%s\n", session-&gt;targetname);
+		break;
+	case ISCSI_PARAM_TPGT:
+		len = sprintf(buf, "%d\n", session-&gt;tpgt);
+		break;
+	default:
+		return -ENOSYS;
+	}
+
+	return len;
+}
+EXPORT_SYMBOL_GPL(iscsi_session_get_param);
+
+int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
+			 enum iscsi_param param, char *buf)
+{
+	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
+	int len;
+
+	switch(param) {
+	case ISCSI_PARAM_MAX_RECV_DLENGTH:
+		len = sprintf(buf, "%u\n", conn-&gt;max_recv_dlength);
+		break;
+	case ISCSI_PARAM_MAX_XMIT_DLENGTH:
+		len = sprintf(buf, "%u\n", conn-&gt;max_xmit_dlength);
+		break;
+	case ISCSI_PARAM_HDRDGST_EN:
+		len = sprintf(buf, "%d\n", conn-&gt;hdrdgst_en);
+		break;
+	case ISCSI_PARAM_DATADGST_EN:
+		len = sprintf(buf, "%d\n", conn-&gt;datadgst_en);
+		break;
+	case ISCSI_PARAM_IFMARKER_EN:
+		len = sprintf(buf, "%d\n", conn-&gt;ifmarker_en);
+		break;
+	case ISCSI_PARAM_OFMARKER_EN:
+		len = sprintf(buf, "%d\n", conn-&gt;ofmarker_en);
+		break;
+	case ISCSI_PARAM_EXP_STATSN:
+		len = sprintf(buf, "%u\n", conn-&gt;exp_statsn);
+		break;
+	case ISCSI_PARAM_PERSISTENT_PORT:
+		len = sprintf(buf, "%d\n", conn-&gt;persistent_port);
+		break;
+	case ISCSI_PARAM_PERSISTENT_ADDRESS:
+		len = sprintf(buf, "%s\n", conn-&gt;persistent_address);
+		break;
+	default:
+		return -ENOSYS;
+	}
+
+	return len;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_get_param);
+
 MODULE_AUTHOR("Mike Christie");
 MODULE_DESCRIPTION("iSCSI library functions");
 MODULE_LICENSE("GPL");
diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 99e76d458290..147c854e1d4d 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -233,7 +233,6 @@ static void iscsi_session_release(struct device *dev)
 
 	shost = iscsi_session_to_shost(session);
 	scsi_host_put(shost);
-	kfree(session-&gt;targetname);
 	kfree(session);
 	module_put(transport-&gt;owner);
 }
@@ -388,7 +387,6 @@ static void iscsi_conn_release(struct device *dev)
 	struct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev);
 	struct device *parent = conn-&gt;dev.parent;
 
-	kfree(conn-&gt;persistent_address);
 	kfree(conn);
 	put_device(parent);
 }
@@ -877,23 +875,13 @@ iscsi_if_destroy_conn(struct iscsi_transport *transport, struct iscsi_uevent *ev
 	return 0;
 }
 
-static void
-iscsi_copy_param(struct iscsi_uevent *ev, uint32_t *value, char *data)
-{
-	if (ev-&gt;u.set_param.len != sizeof(uint32_t))
-		BUG();
-	memcpy(value, data, min_t(uint32_t, sizeof(uint32_t),
-		ev-&gt;u.set_param.len));
-}
-
 static int
 iscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 {
 	char *data = (char*)ev + sizeof(*ev);
 	struct iscsi_cls_conn *conn;
 	struct iscsi_cls_session *session;
-	int err = 0;
-	uint32_t value = 0;
+	int err = 0, value = 0;
 
 	session = iscsi_session_lookup(ev-&gt;u.set_param.sid);
 	conn = iscsi_conn_lookup(ev-&gt;u.set_param.sid, ev-&gt;u.set_param.cid);
@@ -902,42 +890,13 @@ iscsi_set_param(struct iscsi_transport *transport, struct iscsi_uevent *ev)
 
 	switch (ev-&gt;u.set_param.param) {
 	case ISCSI_PARAM_SESS_RECOVERY_TMO:
-		iscsi_copy_param(ev, &amp;value, data);
+		sscanf(data, "%d", &amp;value);
 		if (value != 0)
 			session-&gt;recovery_tmo = value;
 		break;
-	case ISCSI_PARAM_TARGET_NAME:
-		/* this should not change between logins */
-		if (session-&gt;targetname)
-			return 0;
-
-		session-&gt;targetname = kstrdup(data, GFP_KERNEL);
-		if (!session-&gt;targetname)
-			return -ENOMEM;
-		break;
-	case ISCSI_PARAM_TPGT:
-		iscsi_copy_param(ev, &amp;value, data);
-		session-&gt;tpgt = value;
-		break;
-	case ISCSI_PARAM_PERSISTENT_PORT:
-		iscsi_copy_param(ev, &amp;value, data);
-		conn-&gt;persistent_port = value;
-		break;
-	case ISCSI_PARAM_PERSISTENT_ADDRESS:
-		/*
-		 * this is the address returned in discovery so it should
-		 * not change between logins.
-		 */
-		if (conn-&gt;persistent_address)
-			return 0;
-
-		conn-&gt;persistent_address = kstrdup(data, GFP_KERNEL);
-		if (!conn-&gt;persistent_address)
-			return -ENOMEM;
-		break;
 	default:
-		iscsi_copy_param(ev, &amp;value, data);
-		err = transport-&gt;set_param(conn, ev-&gt;u.set_param.param, value);
+		err = transport-&gt;set_param(conn, ev-&gt;u.set_param.param,
+					   data, ev-&gt;u.set_param.len);
 	}
 
 	return err;
@@ -1165,49 +1124,31 @@ struct class_device_attribute class_device_attr_##_prefix##_##_name =	\
 /*
  * iSCSI connection attrs
  */
-#define iscsi_conn_int_attr_show(param, format)				\
+#define iscsi_conn_attr_show(param)					\
 static ssize_t								\
-show_conn_int_param_##param(struct class_device *cdev, char *buf)	\
+show_conn_param_##param(struct class_device *cdev, char *buf)		\
 {									\
-	uint32_t value = 0;						\
 	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
 	struct iscsi_transport *t = conn-&gt;transport;			\
-									\
-	t-&gt;get_conn_param(conn, param, &amp;value);				\
-	return snprintf(buf, 20, format"\n", value);			\
+	return t-&gt;get_conn_param(conn, param, buf);			\
 }
 
-#define iscsi_conn_int_attr(field, param, format)			\
-	iscsi_conn_int_attr_show(param, format)				\
-static ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_int_param_##param, \
+#define iscsi_conn_attr(field, param)					\
+	iscsi_conn_attr_show(param)					\
+static ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_param_##param,	\
 			NULL);
 
-iscsi_conn_int_attr(max_recv_dlength, ISCSI_PARAM_MAX_RECV_DLENGTH, "%u");
-iscsi_conn_int_attr(max_xmit_dlength, ISCSI_PARAM_MAX_XMIT_DLENGTH, "%u");
-iscsi_conn_int_attr(header_digest, ISCSI_PARAM_HDRDGST_EN, "%d");
-iscsi_conn_int_attr(data_digest, ISCSI_PARAM_DATADGST_EN, "%d");
-iscsi_conn_int_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN, "%d");
-iscsi_conn_int_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN, "%d");
-iscsi_conn_int_attr(persistent_port, ISCSI_PARAM_PERSISTENT_PORT, "%d");
-iscsi_conn_int_attr(port, ISCSI_PARAM_CONN_PORT, "%d");
-iscsi_conn_int_attr(exp_statsn, ISCSI_PARAM_EXP_STATSN, "%u");
-
-#define iscsi_conn_str_attr_show(param)					\
-static ssize_t								\
-show_conn_str_param_##param(struct class_device *cdev, char *buf)	\
-{									\
-	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
-	struct iscsi_transport *t = conn-&gt;transport;			\
-	return t-&gt;get_conn_str_param(conn, param, buf);			\
-}
-
-#define iscsi_conn_str_attr(field, param)				\
-	iscsi_conn_str_attr_show(param)					\
-static ISCSI_CLASS_ATTR(conn, field, S_IRUGO, show_conn_str_param_##param, \
-			NULL);
-
-iscsi_conn_str_attr(persistent_address, ISCSI_PARAM_PERSISTENT_ADDRESS);
-iscsi_conn_str_attr(address, ISCSI_PARAM_CONN_ADDRESS);
+iscsi_conn_attr(max_recv_dlength, ISCSI_PARAM_MAX_RECV_DLENGTH);
+iscsi_conn_attr(max_xmit_dlength, ISCSI_PARAM_MAX_XMIT_DLENGTH);
+iscsi_conn_attr(header_digest, ISCSI_PARAM_HDRDGST_EN);
+iscsi_conn_attr(data_digest, ISCSI_PARAM_DATADGST_EN);
+iscsi_conn_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN);
+iscsi_conn_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN);
+iscsi_conn_attr(persistent_port, ISCSI_PARAM_PERSISTENT_PORT);
+iscsi_conn_attr(port, ISCSI_PARAM_CONN_PORT);
+iscsi_conn_attr(exp_statsn, ISCSI_PARAM_EXP_STATSN);
+iscsi_conn_attr(persistent_address, ISCSI_PARAM_PERSISTENT_ADDRESS);
+iscsi_conn_attr(address, ISCSI_PARAM_CONN_ADDRESS);
 
 #define iscsi_cdev_to_session(_cdev) \
 	iscsi_dev_to_session(_cdev-&gt;dev)
@@ -1215,61 +1156,36 @@ iscsi_conn_str_attr(address, ISCSI_PARAM_CONN_ADDRESS);
 /*
  * iSCSI session attrs
  */
-#define iscsi_session_int_attr_show(param, format)			\
-static ssize_t								\
-show_session_int_param_##param(struct class_device *cdev, char *buf)	\
-{									\
-	uint32_t value = 0;						\
-	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev);	\
-	struct iscsi_transport *t = session-&gt;transport;			\
-									\
-	t-&gt;get_session_param(session, param, &amp;value);			\
-	return snprintf(buf, 20, format"\n", value);			\
-}
-
-#define iscsi_session_int_attr(field, param, format)			\
-	iscsi_session_int_attr_show(param, format)			\
-static ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_int_param_##param, \
-			NULL);
-
-iscsi_session_int_attr(initial_r2t, ISCSI_PARAM_INITIAL_R2T_EN, "%d");
-iscsi_session_int_attr(max_outstanding_r2t, ISCSI_PARAM_MAX_R2T, "%hu");
-iscsi_session_int_attr(immediate_data, ISCSI_PARAM_IMM_DATA_EN, "%d");
-iscsi_session_int_attr(first_burst_len, ISCSI_PARAM_FIRST_BURST, "%u");
-iscsi_session_int_attr(max_burst_len, ISCSI_PARAM_MAX_BURST, "%u");
-iscsi_session_int_attr(data_pdu_in_order, ISCSI_PARAM_PDU_INORDER_EN, "%d");
-iscsi_session_int_attr(data_seq_in_order, ISCSI_PARAM_DATASEQ_INORDER_EN, "%d");
-iscsi_session_int_attr(erl, ISCSI_PARAM_ERL, "%d");
-iscsi_session_int_attr(tpgt, ISCSI_PARAM_TPGT, "%d");
-
-#define iscsi_session_str_attr_show(param)				\
+#define iscsi_session_attr_show(param)					\
 static ssize_t								\
-show_session_str_param_##param(struct class_device *cdev, char *buf)	\
+show_session_param_##param(struct class_device *cdev, char *buf)	\
 {									\
 	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev); \
 	struct iscsi_transport *t = session-&gt;transport;			\
-	return t-&gt;get_session_str_param(session, param, buf);		\
+	return t-&gt;get_session_param(session, param, buf);		\
 }
 
-#define iscsi_session_str_attr(field, param)				\
-	iscsi_session_str_attr_show(param)				\
-static ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_str_param_##param, \
+#define iscsi_session_attr(field, param)				\
+	iscsi_session_attr_show(param)					\
+static ISCSI_CLASS_ATTR(sess, field, S_IRUGO, show_session_param_##param, \
 			NULL);
 
-iscsi_session_str_attr(targetname, ISCSI_PARAM_TARGET_NAME);
+iscsi_session_attr(targetname, ISCSI_PARAM_TARGET_NAME);
+iscsi_session_attr(initial_r2t, ISCSI_PARAM_INITIAL_R2T_EN);
+iscsi_session_attr(max_outstanding_r2t, ISCSI_PARAM_MAX_R2T);
+iscsi_session_attr(immediate_data, ISCSI_PARAM_IMM_DATA_EN);
+iscsi_session_attr(first_burst_len, ISCSI_PARAM_FIRST_BURST);
+iscsi_session_attr(max_burst_len, ISCSI_PARAM_MAX_BURST);
+iscsi_session_attr(data_pdu_in_order, ISCSI_PARAM_PDU_INORDER_EN);
+iscsi_session_attr(data_seq_in_order, ISCSI_PARAM_DATASEQ_INORDER_EN);
+iscsi_session_attr(erl, ISCSI_PARAM_ERL);
+iscsi_session_attr(tpgt, ISCSI_PARAM_TPGT);
 
-/*
- * Private session and conn attrs. userspace uses several iscsi values
- * to identify each session between reboots. Some of these values may not
- * be present in the iscsi_transport/LLD driver becuase userspace handles
- * login (and failback for login redirect) so for these type of drivers
- * the class manages the attrs and values for the iscsi_transport/LLD
- */
 #define iscsi_priv_session_attr_show(field, format)			\
 static ssize_t								\
-show_priv_session_##field(struct class_device *cdev, char *buf)	\
+show_priv_session_##field(struct class_device *cdev, char *buf)		\
 {									\
-	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev); \
+	struct iscsi_cls_session *session = iscsi_cdev_to_session(cdev);\
 	return sprintf(buf, format"\n", session-&gt;field);		\
 }
 
@@ -1277,31 +1193,15 @@ show_priv_session_##field(struct class_device *cdev, char *buf)	\
 	iscsi_priv_session_attr_show(field, format)			\
 static ISCSI_CLASS_ATTR(priv_sess, field, S_IRUGO, show_priv_session_##field, \
 			NULL)
-iscsi_priv_session_attr(targetname, "%s");
-iscsi_priv_session_attr(tpgt, "%d");
 iscsi_priv_session_attr(recovery_tmo, "%d");
 
-#define iscsi_priv_conn_attr_show(field, format)			\
-static ssize_t								\
-show_priv_conn_##field(struct class_device *cdev, char *buf)		\
-{									\
-	struct iscsi_cls_conn *conn = iscsi_cdev_to_conn(cdev);		\
-	return sprintf(buf, format"\n", conn-&gt;field);			\
-}
-
-#define iscsi_priv_conn_attr(field, format)				\
-	iscsi_priv_conn_attr_show(field, format)			\
-static ISCSI_CLASS_ATTR(priv_conn, field, S_IRUGO, show_priv_conn_##field, \
-			NULL)
-iscsi_priv_conn_attr(persistent_address, "%s");
-iscsi_priv_conn_attr(persistent_port, "%d");
-
 #define SETUP_PRIV_SESSION_RD_ATTR(field)				\
 do {									\
 	priv-&gt;session_attrs[count] = &amp;class_device_attr_priv_sess_##field; \
 	count++;							\
 } while (0)
 
+
 #define SETUP_SESSION_RD_ATTR(field, param_flag)			\
 do {									\
 	if (tt-&gt;param_mask &amp; param_flag) {				\
@@ -1310,12 +1210,6 @@ do {									\
 	}								\
 } while (0)
 
-#define SETUP_PRIV_CONN_RD_ATTR(field)					\
-do {									\
-	priv-&gt;conn_attrs[count] = &amp;class_device_attr_priv_conn_##field; \
-	count++;							\
-} while (0)
-
 #define SETUP_CONN_RD_ATTR(field, param_flag)				\
 do {									\
 	if (tt-&gt;param_mask &amp; param_flag) {				\
@@ -1442,16 +1336,8 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	SETUP_CONN_RD_ATTR(address, ISCSI_CONN_ADDRESS);
 	SETUP_CONN_RD_ATTR(port, ISCSI_CONN_PORT);
 	SETUP_CONN_RD_ATTR(exp_statsn, ISCSI_EXP_STATSN);
-
-	if (tt-&gt;param_mask &amp; ISCSI_PERSISTENT_ADDRESS)
-		SETUP_CONN_RD_ATTR(persistent_address, ISCSI_PERSISTENT_ADDRESS);
-	else
-		SETUP_PRIV_CONN_RD_ATTR(persistent_address);
-
-	if (tt-&gt;param_mask &amp; ISCSI_PERSISTENT_PORT)
-		SETUP_CONN_RD_ATTR(persistent_port, ISCSI_PERSISTENT_PORT);
-	else
-		SETUP_PRIV_CONN_RD_ATTR(persistent_port);
+	SETUP_CONN_RD_ATTR(persistent_address, ISCSI_PERSISTENT_ADDRESS);
+	SETUP_CONN_RD_ATTR(persistent_port, ISCSI_PERSISTENT_PORT);
 
 	BUG_ON(count &gt; ISCSI_CONN_ATTRS);
 	priv-&gt;conn_attrs[count] = NULL;
@@ -1471,18 +1357,10 @@ iscsi_register_transport(struct iscsi_transport *tt)
 	SETUP_SESSION_RD_ATTR(data_pdu_in_order, ISCSI_PDU_INORDER_EN);
 	SETUP_SESSION_RD_ATTR(data_seq_in_order, ISCSI_DATASEQ_INORDER_EN);
 	SETUP_SESSION_RD_ATTR(erl, ISCSI_ERL);
+	SETUP_SESSION_RD_ATTR(targetname, ISCSI_TARGET_NAME);
+	SETUP_SESSION_RD_ATTR(tpgt, ISCSI_TPGT);
 	SETUP_PRIV_SESSION_RD_ATTR(recovery_tmo);
 
-	if (tt-&gt;param_mask &amp; ISCSI_TARGET_NAME)
-		SETUP_SESSION_RD_ATTR(targetname, ISCSI_TARGET_NAME);
-	else
-		SETUP_PRIV_SESSION_RD_ATTR(targetname);
-
-	if (tt-&gt;param_mask &amp; ISCSI_TPGT)
-		SETUP_SESSION_RD_ATTR(tpgt, ISCSI_TPGT);
-	else
-		SETUP_PRIV_SESSION_RD_ATTR(tpgt);
-
 	BUG_ON(count &gt; ISCSI_SESSION_ATTRS);
 	priv-&gt;session_attrs[count] = NULL;
 
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index cbf7e58bd6f9..ba2760802ded 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -157,6 +157,11 @@ struct iscsi_conn {
 	int			max_xmit_dlength; /* target_max_recv_dsl */
 	int			hdrdgst_en;
 	int			datadgst_en;
+	int			ifmarker_en;
+	int			ofmarker_en;
+	/* values userspace uses to id a conn */
+	int			persistent_port;
+	char			*persistent_address;
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;
@@ -196,8 +201,8 @@ struct iscsi_session {
 	int			pdu_inorder_en;
 	int			dataseq_inorder_en;
 	int			erl;
-	int			ifmarker_en;
-	int			ofmarker_en;
+	int			tpgt;
+	char			*targetname;
 
 	/* control data */
 	struct iscsi_transport	*tt;
@@ -240,6 +245,10 @@ iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
+extern int iscsi_set_param(struct iscsi_cls_conn *cls_conn,
+			   enum iscsi_param param, char *buf, int buflen);
+extern int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
+				   enum iscsi_param param, char *buf);
 
 #define session_to_cls(_sess) \
 	hostdata_session(_sess-&gt;host-&gt;hostdata)
@@ -255,6 +264,8 @@ extern void iscsi_conn_stop(struct iscsi_cls_conn *, int);
 extern int iscsi_conn_bind(struct iscsi_cls_session *, struct iscsi_cls_conn *,
 			   int);
 extern void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err);
+extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
+				enum iscsi_param param, char *buf);
 
 /*
  * pdu and task processing
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index b95151aec602..05397058a9b8 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -34,6 +34,7 @@ struct iscsi_cls_conn;
 struct iscsi_conn;
 struct iscsi_cmd_task;
 struct iscsi_mgmt_task;
+struct sockaddr;
 
 /**
  * struct iscsi_transport - iSCSI Transport template
@@ -46,7 +47,12 @@ struct iscsi_mgmt_task;
  * @bind_conn:		associate this connection with existing iSCSI session
  *			and specified transport descriptor
  * @destroy_conn:	destroy inactive iSCSI connection
- * @set_param:		set iSCSI Data-Path operational parameter
+ * @set_param:		set iSCSI parameter. Return 0 on success, -ENODATA
+ *			when param is not supported, and a -Exx value on other
+ *			error.
+ * @get_param		get iSCSI parameter. Must return number of bytes
+ *			copied to buffer on success, -ENODATA when param
+ *			is not supported, and a -Exx value on other error
  * @start_conn:		set connection to be operational
  * @stop_conn:		suspend/recover/terminate connection
  * @send_pdu:		send iSCSI PDU, Login, Logout, NOP-Out, Reject, Text.
@@ -97,15 +103,11 @@ struct iscsi_transport {
 	void (*stop_conn) (struct iscsi_cls_conn *conn, int flag);
 	void (*destroy_conn) (struct iscsi_cls_conn *conn);
 	int (*set_param) (struct iscsi_cls_conn *conn, enum iscsi_param param,
-			  uint32_t value);
+			  char *buf, int buflen);
 	int (*get_conn_param) (struct iscsi_cls_conn *conn,
-			       enum iscsi_param param, uint32_t *value);
+			       enum iscsi_param param, char *buf);
 	int (*get_session_param) (struct iscsi_cls_session *session,
-				  enum iscsi_param param, uint32_t *value);
-	int (*get_conn_str_param) (struct iscsi_cls_conn *conn,
-				   enum iscsi_param param, char *buf);
-	int (*get_session_str_param) (struct iscsi_cls_session *session,
-				      enum iscsi_param param, char *buf);
+				  enum iscsi_param param, char *buf);
 	int (*send_pdu) (struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 			 char *data, uint32_t data_size);
 	void (*get_stats) (struct iscsi_cls_conn *conn,
@@ -157,13 +159,6 @@ struct iscsi_cls_conn {
 	struct iscsi_transport *transport;
 	uint32_t cid;			/* connection id */
 
-	/* portal/group values we got during discovery */
-	char *persistent_address;
-	int persistent_port;
-	/* portal/group values we are currently using */
-	char *address;
-	int port;
-
 	int active;			/* must be accessed with the connlock */
 	struct device dev;		/* sysfs transport/container device */
 	struct mempool_zone *z_error;
@@ -187,10 +182,6 @@ struct iscsi_cls_session {
 	struct list_head host_list;
 	struct iscsi_transport *transport;
 
-	/* iSCSI values used as unique id by userspace. */
-	char *targetname;
-	int tpgt;
-
 	/* recovery fields */
 	int recovery_tmo;
 	struct work_struct recovery_work;</pre><hr><pre>commit 01cb225dad8da2e717356fab03240e2f4a8d01bf
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Jun 28 12:00:22 2006 -0500

    [SCSI] iscsi: add target discvery event to transport class
    
    Patch from david.somayajulu@qlogic.com:
    
    Add target discovery event. We may have a setup where the iscsi traffic
    is on a different netowrk than the other network traffic. In this case
    we will want to do discovery though the iscsi card. This patch adds
    a event to the transport class that can be used by hw iscsi cards that
    support this.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 5569fdcfd621..99e76d458290 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -977,6 +977,21 @@ iscsi_if_transport_ep(struct iscsi_transport *transport,
 	return rc;
 }
 
+static int
+iscsi_tgt_dscvr(struct iscsi_transport *transport,
+		struct iscsi_uevent *ev)
+{
+	struct sockaddr *dst_addr;
+
+	if (!transport-&gt;tgt_dscvr)
+		return -EINVAL;
+
+	dst_addr = (struct sockaddr *)((char*)ev + sizeof(*ev));
+	return transport-&gt;tgt_dscvr(ev-&gt;u.tgt_dscvr.type,
+				    ev-&gt;u.tgt_dscvr.host_no,
+				    ev-&gt;u.tgt_dscvr.enable, dst_addr);
+}
+
 static int
 iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 {
@@ -1065,6 +1080,9 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:
 		err = iscsi_if_transport_ep(transport, ev, nlh-&gt;nlmsg_type);
 		break;
+	case ISCSI_UEVENT_TGT_DSCVR:
+		err = iscsi_tgt_dscvr(transport, ev);
+		break;
 	default:
 		err = -EINVAL;
 		break;
diff --git a/include/scsi/iscsi_if.h b/include/scsi/iscsi_if.h
index 253797c60095..8813f0f4c624 100644
--- a/include/scsi/iscsi_if.h
+++ b/include/scsi/iscsi_if.h
@@ -47,12 +47,20 @@ enum iscsi_uevent_e {
 	ISCSI_UEVENT_TRANSPORT_EP_POLL		= UEVENT_BASE + 13,
 	ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT	= UEVENT_BASE + 14,
 
+	ISCSI_UEVENT_TGT_DSCVR		= UEVENT_BASE + 15,
+
 	/* up events */
 	ISCSI_KEVENT_RECV_PDU		= KEVENT_BASE + 1,
 	ISCSI_KEVENT_CONN_ERROR		= KEVENT_BASE + 2,
 	ISCSI_KEVENT_IF_ERROR		= KEVENT_BASE + 3,
 };
 
+enum iscsi_tgt_dscvr {
+	ISCSI_TGT_DSCVR_SEND_TARGETS	= 1,
+	ISCSI_TGT_DSCVR_ISNS		= 2,
+	ISCSI_TGT_DSCVR_SLP		= 3,
+};
+
 struct iscsi_uevent {
 	uint32_t type; /* k/u events type */
 	uint32_t iferror; /* carries interface or resource errors */
@@ -116,6 +124,17 @@ struct iscsi_uevent {
 		struct msg_transport_disconnect {
 			uint64_t	ep_handle;
 		} ep_disconnect;
+		struct msg_tgt_dscvr {
+			enum iscsi_tgt_dscvr	type;
+			uint32_t	host_no;
+			/*
+ 			 * enable = 1 to establish a new connection
+			 * with the server. enable = 0 to disconnect
+			 * from the server. Used primarily to switch
+			 * from one iSNS server to another.
+			 */
+			uint32_t	enable;
+		} tgt_dscvr;
 	} u;
 	union {
 		/* messages k -&gt; u */
@@ -141,6 +160,24 @@ struct iscsi_uevent {
 		struct msg_transport_connect_ret {
 			uint64_t	handle;
 		} ep_connect_ret;
+		struct msg_tgt_dscvr_ret {
+			/*
+			 * session/connection pair used to reference
+			 * the connection to server
+			 */
+			uint32_t	sid;
+			uint32_t	cid;
+			union {
+				struct isns {
+					/* port # for conn to iSNS server */
+					uint16_t isns_port;
+					/* listening port to receive SCNs */
+					uint16_t scn_port;
+					/* listening port to receive ESIs */
+					uint16_t esi_port;
+				} isns_attrib;
+			} u;
+		} tgt_dscvr_ret;
 	} r;
 } __attribute__ ((aligned (sizeof(uint64_t))));
 
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index b684426a5900..b95151aec602 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -127,6 +127,8 @@ struct iscsi_transport {
 			   uint64_t *ep_handle);
 	int (*ep_poll) (uint64_t ep_handle, int timeout_ms);
 	void (*ep_disconnect) (uint64_t ep_handle);
+	int (*tgt_dscvr) (enum iscsi_tgt_dscvr type, uint32_t host_no,
+			  uint32_t enable, struct sockaddr *dst_addr);
 };
 
 /*</pre><hr><pre>commit f70e9c5f91f1d2d9ce79dc45221540e25b4e4ac0
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 30 01:04:51 2006 -0500

    [SCSI] iscsi: update version to 1.0-595
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 7fa85937a99f..b4743a9ecc80 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -43,7 +43,7 @@
 
 #include "iscsi_tcp.h"
 
-#define ISCSI_TCP_VERSION "1.0-574"
+#define ISCSI_TCP_VERSION "1.0-595"
 
 MODULE_AUTHOR("Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;, "
 	      "Alex Aizman &lt;itn780@yahoo.com&gt;");</pre><hr><pre>commit 3219e5294150aee7d389e19029f49b44fb6b5c9f
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 30 00:37:28 2006 -0500

    [SCSI] iscsi: fix writepsace race
    
    We can race and misset the suspend bit if iscsi_write_space is
    called then iscsi_send returns with a failure indicating
    there is no space.
    
    To handle this this patch returns a error upwards allowing xmitworker
    to decide if we need to try and transmit again. For the no
    write space case xmitworker will not retry, and instead
    let iscsi_write_space queue it back up if needed (this relies
    on the work queue code to properly requeue us if needed).
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 2abda804a924..7fa85937a99f 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1006,7 +1006,6 @@ iscsi_write_space(struct sock *sk)
 
 	tcp_conn-&gt;old_write_space(sk);
 	debug_tcp("iscsi_write_space: cid %d\n", conn-&gt;id);
-	clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
 }
 
@@ -1056,7 +1055,7 @@ iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
 {
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct socket *sk = tcp_conn-&gt;sock;
-	int offset = buf-&gt;sg.offset + buf-&gt;sent;
+	int offset = buf-&gt;sg.offset + buf-&gt;sent, res;
 
 	/*
 	 * if we got use_sg=0 or are sending something we kmallocd
@@ -1067,10 +1066,22 @@ iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
 	 * slab case.
 	 */
 	if (buf-&gt;use_sendmsg)
-		return sock_no_sendpage(sk, buf-&gt;sg.page, offset, size, flags);
+		res = sock_no_sendpage(sk, buf-&gt;sg.page, offset, size, flags);
 	else
-		return tcp_conn-&gt;sendpage(sk, buf-&gt;sg.page, offset, size,
-					  flags);
+		res = tcp_conn-&gt;sendpage(sk, buf-&gt;sg.page, offset, size, flags);
+
+	if (res &gt;= 0) {
+		conn-&gt;txdata_octets += res;
+		buf-&gt;sent += res;
+		return res;
+	}
+
+	tcp_conn-&gt;sendpage_failures_cnt++;
+	if (res == -EAGAIN)
+		res = -ENOBUFS;
+	else
+		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	return res;
 }
 
 /**
@@ -1085,7 +1096,6 @@ iscsi_send(struct iscsi_conn *conn, struct iscsi_buf *buf, int size, int flags)
 static inline int
 iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
 {
-	struct iscsi_tcp_conn *tcp_conn;
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
 
@@ -1097,17 +1107,10 @@ iscsi_sendhdr(struct iscsi_conn *conn, struct iscsi_buf *buf, int datalen)
 	res = iscsi_send(conn, buf, size, flags);
 	debug_tcp("sendhdr %d bytes, sent %d res %d\n", size, buf-&gt;sent, res);
 	if (res &gt;= 0) {
-		conn-&gt;txdata_octets += res;
-		buf-&gt;sent += res;
 		if (size != res)
 			return -EAGAIN;
 		return 0;
-	} else if (res == -EAGAIN) {
-		tcp_conn = conn-&gt;dd_data;
-		tcp_conn-&gt;sendpage_failures_cnt++;
-		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-	} else if (res == -EPIPE)
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	}
 
 	return res;
 }
@@ -1126,7 +1129,6 @@ static inline int
 iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 	       int *count, int *sent)
 {
-	struct iscsi_tcp_conn *tcp_conn;
 	int flags = 0; /* MSG_DONTWAIT; */
 	int res, size;
 
@@ -1141,19 +1143,12 @@ iscsi_sendpage(struct iscsi_conn *conn, struct iscsi_buf *buf,
 	debug_tcp("sendpage: %d bytes, sent %d left %d sent %d res %d\n",
 		  size, buf-&gt;sent, *count, *sent, res);
 	if (res &gt;= 0) {
-		conn-&gt;txdata_octets += res;
-		buf-&gt;sent += res;
 		*count -= res;
 		*sent += res;
 		if (size != res)
 			return -EAGAIN;
 		return 0;
-	} else if (res == -EAGAIN) {
-		tcp_conn = conn-&gt;dd_data;
-		tcp_conn-&gt;sendpage_failures_cnt++;
-		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-	} else if (res == -EPIPE)
-		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
+	}
 
 	return res;
 }
@@ -1342,6 +1337,7 @@ static int
 iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
 {
 	struct iscsi_tcp_mgmt_task *tcp_mtask = mtask-&gt;dd_data;
+	int rc;
 
 	debug_scsi("mtask deq [cid %d state %x itt 0x%x]\n",
 		conn-&gt;id, tcp_mtask-&gt;xmstate, mtask-&gt;itt);
@@ -1355,12 +1351,13 @@ iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
 		    conn-&gt;hdrdgst_en)
 			iscsi_hdr_digest(conn, &amp;tcp_mtask-&gt;headbuf,
 					(u8*)tcp_mtask-&gt;hdrext);
-		if (iscsi_sendhdr(conn, &amp;tcp_mtask-&gt;headbuf,
-				  mtask-&gt;data_count)) {
+		rc = iscsi_sendhdr(conn, &amp;tcp_mtask-&gt;headbuf,
+				   mtask-&gt;data_count);
+		if (rc) {
 			tcp_mtask-&gt;xmstate |= XMSTATE_IMM_HDR;
 			if (mtask-&gt;data_count)
 				tcp_mtask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
-			return -EAGAIN;
+			return rc;
 		}
 	}
 
@@ -1371,10 +1368,13 @@ iscsi_tcp_mtask_xmit(struct iscsi_conn *conn, struct iscsi_mgmt_task *mtask)
 		 * Virtual buffer could be spreaded across multiple pages...
 		 */
 		do {
-			if (iscsi_sendpage(conn, &amp;tcp_mtask-&gt;sendbuf,
-				   &amp;mtask-&gt;data_count, &amp;tcp_mtask-&gt;sent)) {
+			int rc;
+
+			rc = iscsi_sendpage(conn, &amp;tcp_mtask-&gt;sendbuf,
+					&amp;mtask-&gt;data_count, &amp;tcp_mtask-&gt;sent);
+			if (rc) {
 				tcp_mtask-&gt;xmstate |= XMSTATE_IMM_DATA;
-				return -EAGAIN;
+				return rc;
 			}
 		} while (mtask-&gt;data_count);
 	}
@@ -1396,16 +1396,19 @@ static inline int
 handle_xmstate_r_hdr(struct iscsi_conn *conn,
 		     struct iscsi_tcp_cmd_task *tcp_ctask)
 {
+	int rc;
+
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_R_HDR;
 	if (conn-&gt;hdrdgst_en)
 		iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
 				 (u8*)tcp_ctask-&gt;hdrext);
-	if (!iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, 0)) {
+	rc = iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, 0);
+	if (!rc) {
 		BUG_ON(tcp_ctask-&gt;xmstate != XMSTATE_IDLE);
 		return 0; /* wait for Data-In */
 	}
 	tcp_ctask-&gt;xmstate |= XMSTATE_R_HDR;
-	return -EAGAIN;
+	return rc;
 }
 
 static inline int
@@ -1413,16 +1416,16 @@ handle_xmstate_w_hdr(struct iscsi_conn *conn,
 		     struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	int rc;
 
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_W_HDR;
 	if (conn-&gt;hdrdgst_en)
 		iscsi_hdr_digest(conn, &amp;tcp_ctask-&gt;headbuf,
 				 (u8*)tcp_ctask-&gt;hdrext);
-	if (iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;imm_count)) {
+	rc = iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;imm_count);
+	if (rc)
 		tcp_ctask-&gt;xmstate |= XMSTATE_W_HDR;
-		return -EAGAIN;
-	}
-	return 0;
+	return rc;
 }
 
 static inline int
@@ -1430,17 +1433,19 @@ handle_xmstate_data_digest(struct iscsi_conn *conn,
 			   struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
+	int rc;
 
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_DATA_DIGEST;
 	debug_tcp("resent data digest 0x%x\n", tcp_ctask-&gt;datadigest);
-	if (iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
-				    &amp;tcp_ctask-&gt;datadigest, 0)) {
+	rc = iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
+				    &amp;tcp_ctask-&gt;datadigest, 0);
+	if (rc) {
 		tcp_ctask-&gt;xmstate |= XMSTATE_DATA_DIGEST;
 		debug_tcp("resent data digest 0x%x fail!\n",
 			  tcp_ctask-&gt;datadigest);
-		return -EAGAIN;
 	}
-	return 0;
+
+	return rc;
 }
 
 static inline int
@@ -1448,6 +1453,7 @@ handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int rc;
 
 	BUG_ON(!ctask-&gt;imm_count);
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_IMM_DATA;
@@ -1458,8 +1464,9 @@ handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	}
 
 	for (;;) {
-		if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;ctask-&gt;imm_count,
-				   &amp;tcp_ctask-&gt;sent)) {
+		rc = iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf,
+				   &amp;ctask-&gt;imm_count, &amp;tcp_ctask-&gt;sent);
+		if (rc) {
 			tcp_ctask-&gt;xmstate |= XMSTATE_IMM_DATA;
 			if (conn-&gt;datadgst_en) {
 				crypto_digest_final(tcp_conn-&gt;data_tx_tfm,
@@ -1467,7 +1474,7 @@ handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 				debug_tcp("tx imm sendpage fail 0x%x\n",
 					  tcp_ctask-&gt;datadigest);
 			}
-			return -EAGAIN;
+			return rc;
 		}
 		if (conn-&gt;datadgst_en)
 			crypto_digest_update(tcp_conn-&gt;data_tx_tfm,
@@ -1480,11 +1487,12 @@ handle_xmstate_imm_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	}
 
 	if (conn-&gt;datadgst_en &amp;&amp; !(tcp_ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
-		if (iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
-				            &amp;tcp_ctask-&gt;immdigest, 1)) {
+		rc = iscsi_digest_final_send(conn, ctask, &amp;tcp_ctask-&gt;immbuf,
+				            &amp;tcp_ctask-&gt;immdigest, 1);
+		if (rc) {
 			debug_tcp("sending imm digest 0x%x fail!\n",
 				  tcp_ctask-&gt;immdigest);
-			return -EAGAIN;
+			return rc;
 		}
 		debug_tcp("sending imm digest 0x%x\n", tcp_ctask-&gt;immdigest);
 	}
@@ -1497,6 +1505,7 @@ handle_xmstate_uns_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 {
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_data_task *dtask;
+	int rc;
 
 	tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
 	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_UNS_INIT) {
@@ -1507,10 +1516,12 @@ handle_xmstate_uns_hdr(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 					(u8*)dtask-&gt;hdrext);
 		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_INIT;
 	}
-	if (iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;data_count)) {
+
+	rc = iscsi_sendhdr(conn, &amp;tcp_ctask-&gt;headbuf, ctask-&gt;data_count);
+	if (rc) {
 		tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
 		tcp_ctask-&gt;xmstate |= XMSTATE_UNS_HDR;
-		return -EAGAIN;
+		return rc;
 	}
 
 	debug_scsi("uns dout [itt 0x%x dlen %d sent %d]\n",
@@ -1524,6 +1535,7 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_data_task *dtask = tcp_ctask-&gt;dtask;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	int rc;
 
 	BUG_ON(!ctask-&gt;data_count);
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_UNS_DATA;
@@ -1536,8 +1548,9 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	for (;;) {
 		int start = tcp_ctask-&gt;sent;
 
-		if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf,
-				   &amp;ctask-&gt;data_count, &amp;tcp_ctask-&gt;sent)) {
+		rc = iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf,
+				   &amp;ctask-&gt;data_count, &amp;tcp_ctask-&gt;sent);
+		if (rc) {
 			ctask-&gt;unsol_count -= tcp_ctask-&gt;sent - start;
 			tcp_ctask-&gt;xmstate |= XMSTATE_UNS_DATA;
 			/* will continue with this ctask later.. */
@@ -1547,7 +1560,7 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 				debug_tcp("tx uns data fail 0x%x\n",
 					  dtask-&gt;digest);
 			}
-			return -EAGAIN;
+			return rc;
 		}
 
 		BUG_ON(tcp_ctask-&gt;sent &gt; ctask-&gt;total_length);
@@ -1574,12 +1587,13 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	 */
 	if (ctask-&gt;unsol_count) {
 		if (conn-&gt;datadgst_en) {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &amp;dtask-&gt;digestbuf,
-						    &amp;dtask-&gt;digest, 1)) {
+						    &amp;dtask-&gt;digest, 1);
+			if (rc) {
 				debug_tcp("send uns digest 0x%x fail\n",
 					  dtask-&gt;digest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("sending uns digest 0x%x, more uns\n",
 				  dtask-&gt;digest);
@@ -1589,12 +1603,13 @@ handle_xmstate_uns_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	}
 
 	if (conn-&gt;datadgst_en &amp;&amp; !(tcp_ctask-&gt;xmstate &amp; XMSTATE_W_PAD)) {
-		if (iscsi_digest_final_send(conn, ctask,
+		rc = iscsi_digest_final_send(conn, ctask,
 					    &amp;dtask-&gt;digestbuf,
-					    &amp;dtask-&gt;digest, 1)) {
+					    &amp;dtask-&gt;digest, 1);
+		if (rc) {
 			debug_tcp("send last uns digest 0x%x fail\n",
 				   dtask-&gt;digest);
-			return -EAGAIN;
+			return rc;
 		}
 		debug_tcp("sending uns digest 0x%x\n",dtask-&gt;digest);
 	}
@@ -1610,7 +1625,7 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_r2t_info *r2t = tcp_ctask-&gt;r2t;
 	struct iscsi_data_task *dtask = &amp;r2t-&gt;dtask;
-	int left;
+	int left, rc;
 
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
 	tcp_ctask-&gt;dtask = dtask;
@@ -1626,7 +1641,8 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	if (!r2t-&gt;data_count)
 		goto data_out_done;
 
-	if (iscsi_sendpage(conn, &amp;r2t-&gt;sendbuf, &amp;r2t-&gt;data_count, &amp;r2t-&gt;sent)) {
+	rc = iscsi_sendpage(conn, &amp;r2t-&gt;sendbuf, &amp;r2t-&gt;data_count, &amp;r2t-&gt;sent);
+	if (rc) {
 		tcp_ctask-&gt;xmstate |= XMSTATE_SOL_DATA;
 		/* will continue with this ctask later.. */
 		if (conn-&gt;datadgst_en) {
@@ -1634,7 +1650,7 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 					  (u8 *)&amp;dtask-&gt;digest);
 			debug_tcp("r2t data send fail 0x%x\n", dtask-&gt;digest);
 		}
-		return -EAGAIN;
+		return rc;
 	}
 
 	BUG_ON(r2t-&gt;data_count &lt; 0);
@@ -1661,12 +1677,13 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	left = r2t-&gt;data_length - r2t-&gt;sent;
 	if (left) {
 		if (conn-&gt;datadgst_en) {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &amp;dtask-&gt;digestbuf,
-						    &amp;dtask-&gt;digest, 1)) {
+						    &amp;dtask-&gt;digest, 1);
+			if (rc) {
 				debug_tcp("send r2t data digest 0x%x"
 					  "fail\n", dtask-&gt;digest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("r2t data send digest 0x%x\n",
 				  dtask-&gt;digest);
@@ -1683,11 +1700,12 @@ handle_xmstate_sol_data(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	 */
 	BUG_ON(tcp_ctask-&gt;r2t_data_count - r2t-&gt;data_length &lt; 0);
 	if (conn-&gt;datadgst_en) {
-		if (iscsi_digest_final_send(conn, ctask, &amp;dtask-&gt;digestbuf,
-					    &amp;dtask-&gt;digest, 1)) {
+		rc = iscsi_digest_final_send(conn, ctask, &amp;dtask-&gt;digestbuf,
+					    &amp;dtask-&gt;digest, 1);
+		if (rc) {
 			debug_tcp("send last r2t data digest 0x%x"
 				  "fail\n", dtask-&gt;digest);
-			return -EAGAIN;
+			return rc;
 		}
 		debug_tcp("r2t done dout digest 0x%x\n", dtask-&gt;digest);
 	}
@@ -1713,15 +1731,16 @@ handle_xmstate_w_pad(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	struct iscsi_tcp_cmd_task *tcp_ctask = ctask-&gt;dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct iscsi_data_task *dtask = tcp_ctask-&gt;dtask;
-	int sent;
+	int sent, rc;
 
 	tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_W_PAD;
 	iscsi_buf_init_iov(&amp;tcp_ctask-&gt;sendbuf, (char*)&amp;tcp_ctask-&gt;pad,
 			    tcp_ctask-&gt;pad_count);
-	if (iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;tcp_ctask-&gt;pad_count,
-			   &amp;sent)) {
+	rc = iscsi_sendpage(conn, &amp;tcp_ctask-&gt;sendbuf, &amp;tcp_ctask-&gt;pad_count,
+			   &amp;sent);
+	if (rc) {
 		tcp_ctask-&gt;xmstate |= XMSTATE_W_PAD;
-		return -EAGAIN;
+		return rc;
 	}
 
 	if (conn-&gt;datadgst_en) {
@@ -1729,22 +1748,24 @@ handle_xmstate_w_pad(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 				     &amp;tcp_ctask-&gt;sendbuf.sg, 1);
 		/* imm data? */
 		if (!dtask) {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &amp;tcp_ctask-&gt;immbuf,
-						    &amp;tcp_ctask-&gt;immdigest, 1)) {
+						    &amp;tcp_ctask-&gt;immdigest, 1);
+			if (rc) {
 				debug_tcp("send padding digest 0x%x"
 					  "fail!\n", tcp_ctask-&gt;immdigest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("done with padding, digest 0x%x\n",
 				  tcp_ctask-&gt;datadigest);
 		} else {
-			if (iscsi_digest_final_send(conn, ctask,
+			rc = iscsi_digest_final_send(conn, ctask,
 						    &amp;dtask-&gt;digestbuf,
-						    &amp;dtask-&gt;digest, 1)) {
+						    &amp;dtask-&gt;digest, 1);
+			if (rc) {
 				debug_tcp("send padding digest 0x%x"
 				          "fail\n", dtask-&gt;digest);
-				return -EAGAIN;
+				return rc;
 			}
 			debug_tcp("done with padding, digest 0x%x\n",
 				  dtask-&gt;digest);
@@ -1769,10 +1790,8 @@ iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 	if (ctask-&gt;mtask)
 		return rc;
 
-	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_R_HDR) {
-		rc = handle_xmstate_r_hdr(conn, tcp_ctask);
-		return rc;
-	}
+	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_R_HDR)
+		return handle_xmstate_r_hdr(conn, tcp_ctask);
 
 	if (tcp_ctask-&gt;xmstate &amp; XMSTATE_W_HDR) {
 		rc = handle_xmstate_w_hdr(conn, ctask);
@@ -1824,10 +1843,11 @@ iscsi_tcp_ctask_xmit(struct iscsi_conn *conn, struct iscsi_cmd_task *ctask)
 		if (conn-&gt;hdrdgst_en)
 			iscsi_hdr_digest(conn, &amp;r2t-&gt;headbuf,
 					(u8*)r2t-&gt;dtask.hdrext);
-		if (iscsi_sendhdr(conn, &amp;r2t-&gt;headbuf, r2t-&gt;data_count)) {
+		rc = iscsi_sendhdr(conn, &amp;r2t-&gt;headbuf, r2t-&gt;data_count);
+		if (rc) {
 			tcp_ctask-&gt;xmstate &amp;= ~XMSTATE_SOL_DATA;
 			tcp_ctask-&gt;xmstate |= XMSTATE_SOL_HDR;
-			return -EAGAIN;
+			return rc;
 		}
 
 		debug_scsi("sol dout [dsn %d itt 0x%x dlen %d sent %d]\n",
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 256b87a85978..2673a11a9495 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -513,10 +513,11 @@ EXPORT_SYMBOL_GPL(iscsi_conn_failure);
 static int iscsi_data_xmit(struct iscsi_conn *conn)
 {
 	struct iscsi_transport *tt;
+	int rc = 0;
 
 	if (unlikely(conn-&gt;suspend_tx)) {
 		debug_scsi("conn %d Tx suspended!\n", conn-&gt;id);
-		return 0;
+		return -ENODATA;
 	}
 	tt = conn-&gt;session-&gt;tt;
 
@@ -536,13 +537,15 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 	BUG_ON(conn-&gt;ctask &amp;&amp; conn-&gt;mtask);
 
 	if (conn-&gt;ctask) {
-		if (tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask))
+		rc = tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask);
+		if (rc)
 			goto again;
 		/* done with this in-progress ctask */
 		conn-&gt;ctask = NULL;
 	}
 	if (conn-&gt;mtask) {
-	        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+		rc = tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask);
+	        if (rc)
 		        goto again;
 		/* done with this in-progress mtask */
 		conn-&gt;mtask = NULL;
@@ -556,7 +559,8 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
 				      &amp;conn-&gt;mgmt_run_list);
 			spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+			rc = tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask);
+		        if (rc)
 			        goto again;
 	        }
 		/* done with this mtask */
@@ -574,7 +578,8 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		if (list_empty(&amp;conn-&gt;ctask-&gt;running))
 			list_add_tail(&amp;conn-&gt;ctask-&gt;running, &amp;conn-&gt;run_list);
 		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-		if (tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask))
+		rc = tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask);
+		if (rc)
 			goto again;
 	}
 	/* done with this ctask */
@@ -588,32 +593,34 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
 				      &amp;conn-&gt;mgmt_run_list);
 			spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
+		        rc = tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask);
+			if (rc)
 			        goto again;
 	        }
 		/* done with this mtask */
 		conn-&gt;mtask = NULL;
 	}
 
-	return 0;
+	return -ENODATA;
 
 again:
 	if (unlikely(conn-&gt;suspend_tx))
-		return 0;
+		return -ENODATA;
 
-	return -EAGAIN;
+	return rc;
 }
 
 static void iscsi_xmitworker(void *data)
 {
 	struct iscsi_conn *conn = data;
-
+	int rc;
 	/*
 	 * serialize Xmit worker on a per-connection basis.
 	 */
 	mutex_lock(&amp;conn-&gt;xmitmutex);
-	if (iscsi_data_xmit(conn))
-		scsi_queue_work(conn-&gt;session-&gt;host, &amp;conn-&gt;xmitwork);
+	do {
+		rc = iscsi_data_xmit(conn);
+	} while (rc &gt;= 0 || rc == -EAGAIN);
 	mutex_unlock(&amp;conn-&gt;xmitmutex);
 }
 
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 92129b97d31e..b684426a5900 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -57,8 +57,12 @@ struct iscsi_mgmt_task;
  *			Called from queuecommand with session lock held.
  * @init_mgmt_task:	Initialize a iscsi_mgmt_task and any internal structs.
  *			Called from iscsi_conn_send_generic with xmitmutex.
- * @xmit_cmd_task:	requests LLD to transfer cmd task
- * @xmit_mgmt_task:	requests LLD to transfer mgmt task
+ * @xmit_cmd_task:	Requests LLD to transfer cmd task. Returns 0 or the
+ *			the number of bytes transferred on success, and -Exyz
+ *			value on error.
+ * @xmit_mgmt_task:	Requests LLD to transfer mgmt task. Returns 0 or the
+ *			the number of bytes transferred on success, and -Exyz
+ *			value on error.
  * @cleanup_cmd_task:	requests LLD to fail cmd task. Called with xmitmutex
  *			and session-&gt;lock after the connection has been
  *			suspended and terminated during recovery. If called</pre><hr><pre>commit 040515f53c09047c76ad074dc6a280984dc84b04
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 30 00:37:25 2006 -0500

    [SCSI] iscsi: return task found during search
    
    from davidw@netapp.com:
    
    remove task type should return a task on success.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index a223413e1564..256b87a85978 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -985,7 +985,7 @@ iscsi_remove_##tasktype(struct kfifo *fifo, uint32_t itt)		\
 									\
 		if (task-&gt;itt == itt) {					\
 			debug_scsi("matched task\n");			\
-			break;						\
+			return task;					\
 		}							\
 									\
 		__kfifo_put(fifo, (void*)&amp;task, sizeof(void*));		\</pre><hr><pre>commit 994442e807782d68bb1d3ae34044f95990411a22
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 30 00:37:22 2006 -0500

    [SCSI] iscsi: fix run list corruption
    
    from davidw@netapp.com:
    
    We must grab the session lock when modifying the running lists.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 963002598995..a223413e1564 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -552,8 +552,10 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
         if (unlikely(__kfifo_len(conn-&gt;immqueue))) {
 	        while (__kfifo_get(conn-&gt;immqueue, (void*)&amp;conn-&gt;mtask,
 			           sizeof(void*))) {
+			spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
 			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
 				      &amp;conn-&gt;mgmt_run_list);
+			spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
 			        goto again;
 	        }
@@ -568,8 +570,10 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
 		 * iscsi tcp may readd the task to the xmitqueue to send
 		 * write data
 		 */
+		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
 		if (list_empty(&amp;conn-&gt;ctask-&gt;running))
 			list_add_tail(&amp;conn-&gt;ctask-&gt;running, &amp;conn-&gt;run_list);
+		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 		if (tt-&gt;xmit_cmd_task(conn, conn-&gt;ctask))
 			goto again;
 	}
@@ -580,8 +584,10 @@ static int iscsi_data_xmit(struct iscsi_conn *conn)
         if (unlikely(__kfifo_len(conn-&gt;mgmtqueue))) {
 	        while (__kfifo_get(conn-&gt;mgmtqueue, (void*)&amp;conn-&gt;mtask,
 			           sizeof(void*))) {
+			spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
 			list_add_tail(&amp;conn-&gt;mtask-&gt;running,
 				      &amp;conn-&gt;mgmt_run_list);
+			spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
 		        if (tt-&gt;xmit_mgmt_task(conn, conn-&gt;mtask))
 			        goto again;
 	        }</pre><hr><pre>commit 67a611149b2ac5f4af1e36bfffbfe3198cd3712c
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Tue May 30 00:37:20 2006 -0500

    [SCSI] iscsi: don't switch states when just cleaning up
    
    If recovery failed or we are in recovery only overwrite the state
    if we are going to terminate the session or if we logged back in.
    
    STOP_CONN_SUSPEND and conn_cnt are not used. We only support
    a single connection session ATM, so cleanup that code while
    we are working around it.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index c66faee07ca5..2abda804a924 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -1955,30 +1955,28 @@ iscsi_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 	if (err)
 		return err;
 
-	if (conn-&gt;stop_stage != STOP_CONN_SUSPEND) {
-		/* bind iSCSI connection and socket */
-		tcp_conn-&gt;sock = sock;
+	/* bind iSCSI connection and socket */
+	tcp_conn-&gt;sock = sock;
 
-		/* setup Socket parameters */
-		sk = sock-&gt;sk;
-		sk-&gt;sk_reuse = 1;
-		sk-&gt;sk_sndtimeo = 15 * HZ; /* FIXME: make it configurable */
-		sk-&gt;sk_allocation = GFP_ATOMIC;
+	/* setup Socket parameters */
+	sk = sock-&gt;sk;
+	sk-&gt;sk_reuse = 1;
+	sk-&gt;sk_sndtimeo = 15 * HZ; /* FIXME: make it configurable */
+	sk-&gt;sk_allocation = GFP_ATOMIC;
 
-		/* FIXME: disable Nagle's algorithm */
+	/* FIXME: disable Nagle's algorithm */
 
-		/*
-		 * Intercept TCP callbacks for sendfile like receive
-		 * processing.
-		 */
-		conn-&gt;recv_lock = &amp;sk-&gt;sk_callback_lock;
-		iscsi_conn_set_callbacks(conn);
-		tcp_conn-&gt;sendpage = tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
-		/*
-		 * set receive state machine into initial state
-		 */
-		tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
-	}
+	/*
+	 * Intercept TCP callbacks for sendfile like receive
+	 * processing.
+	 */
+	conn-&gt;recv_lock = &amp;sk-&gt;sk_callback_lock;
+	iscsi_conn_set_callbacks(conn);
+	tcp_conn-&gt;sendpage = tcp_conn-&gt;sock-&gt;ops-&gt;sendpage;
+	/*
+	 * set receive state machine into initial state
+	 */
+	tcp_conn-&gt;in_progress = IN_PROGRESS_WAIT_HEADER;
 
 	return 0;
 }
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index d810acae45f7..963002598995 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -492,7 +492,7 @@ void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
 		return;
 	}
 
-	if (session-&gt;conn_cnt == 1 || session-&gt;leadconn == conn)
+	if (conn-&gt;stop_stage == 0)
 		session-&gt;state = ISCSI_STATE_FAILED;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
@@ -652,7 +652,7 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 		 */
 		if (session-&gt;state == ISCSI_STATE_IN_RECOVERY) {
 			reason = FAILURE_SESSION_IN_RECOVERY;
-			goto fault;
+			goto reject;
 		}
 
 		if (session-&gt;state == ISCSI_STATE_RECOVERY_FAILED)
@@ -1411,8 +1411,8 @@ void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)
 	struct iscsi_session *session = conn-&gt;session;
 	unsigned long flags;
 
-	mutex_lock(&amp;conn-&gt;xmitmutex);
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
+	mutex_lock(&amp;conn-&gt;xmitmutex);
 	if (conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE) {
 		if (session-&gt;tt-&gt;suspend_conn_recv)
 			session-&gt;tt-&gt;suspend_conn_recv(conn);
@@ -1498,7 +1498,6 @@ int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 		 * unblock eh_abort() if it is blocked. re-try all
 		 * commands after successful recovery
 		 */
-		session-&gt;conn_cnt++;
 		conn-&gt;stop_stage = 0;
 		conn-&gt;tmabort_state = TMABORT_INITIAL;
 		session-&gt;age++;
@@ -1508,13 +1507,7 @@ int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 		wake_up(&amp;conn-&gt;ehwait);
 		return 0;
 	case STOP_CONN_TERM:
-		session-&gt;conn_cnt++;
-		conn-&gt;stop_stage = 0;
-		break;
-	case STOP_CONN_SUSPEND:
 		conn-&gt;stop_stage = 0;
-		clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);
-		clear_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 		break;
 	default:
 		break;
@@ -1589,28 +1582,24 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 
 	/*
 	 * When this is called for the in_login state, we only want to clean
-	 * up the login task and connection.
+	 * up the login task and connection. We do not need to block and set
+	 * the recovery state again
 	 */
-	if (conn-&gt;stop_stage != STOP_CONN_RECOVER)
-		session-&gt;conn_cnt--;
+	if (flag == STOP_CONN_TERM)
+		session-&gt;state = ISCSI_STATE_TERMINATE;
+	else if (conn-&gt;stop_stage != STOP_CONN_RECOVER)
+		session-&gt;state = ISCSI_STATE_IN_RECOVERY;
 
 	old_stop_stage = conn-&gt;stop_stage;
 	conn-&gt;stop_stage = flag;
+	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
+	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	spin_unlock_bh(&amp;session-&gt;lock);
 
 	if (session-&gt;tt-&gt;suspend_conn_recv)
 		session-&gt;tt-&gt;suspend_conn_recv(conn);
 
 	mutex_lock(&amp;conn-&gt;xmitmutex);
-	spin_lock_bh(&amp;session-&gt;lock);
-	conn-&gt;c_stage = ISCSI_CONN_STOPPED;
-	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-
-	if (session-&gt;conn_cnt == 0 || session-&gt;leadconn == conn)
-		session-&gt;state = ISCSI_STATE_IN_RECOVERY;
-
-	spin_unlock_bh(&amp;session-&gt;lock);
-
 	/*
 	 * for connection level recovery we should not calculate
 	 * header digest. conn-&gt;hdr_size used for optimization
@@ -1620,13 +1609,11 @@ static void iscsi_start_session_recovery(struct iscsi_session *session,
 	if (flag == STOP_CONN_RECOVER) {
 		conn-&gt;hdrdgst_en = 0;
 		conn-&gt;datadgst_en = 0;
-		/*
-		 * if this is called from the eh and and from userspace
-		 * then we only need to block once.
-		 */
 		if (session-&gt;state == ISCSI_STATE_IN_RECOVERY &amp;&amp;
-		    old_stop_stage != STOP_CONN_RECOVER)
+		    old_stop_stage != STOP_CONN_RECOVER) {
+			debug_scsi("blocking session\n");
 			iscsi_block_session(session_to_cls(session));
+		}
 	}
 
 	session-&gt;tt-&gt;terminate_conn(conn);
@@ -1651,20 +1638,6 @@ void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	case STOP_CONN_TERM:
 		iscsi_start_session_recovery(session, conn, flag);
 		break;
-	case STOP_CONN_SUSPEND:
-		if (session-&gt;tt-&gt;suspend_conn_recv)
-			session-&gt;tt-&gt;suspend_conn_recv(conn);
-
-		mutex_lock(&amp;conn-&gt;xmitmutex);
-		spin_lock_bh(&amp;session-&gt;lock);
-
-		conn-&gt;stop_stage = flag;
-		conn-&gt;c_stage = ISCSI_CONN_STOPPED;
-		set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
-
-		spin_unlock_bh(&amp;session-&gt;lock);
-		mutex_unlock(&amp;conn-&gt;xmitmutex);
-		break;
 	default:
 		printk(KERN_ERR "iscsi: invalid stop flag %d\n", flag);
 	}
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 17b28f08b692..cbf7e58bd6f9 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -211,7 +211,6 @@ struct iscsi_session {
 						 * - r2tpool		   */
 	int			state;		/* session state           */
 	struct list_head	item;
-	int			conn_cnt;
 	int			age;		/* counts session re-opens */
 
 	struct list_head	connections;	/* list of connections */</pre><hr><pre>commit e0ecae8da26d94dd878ff1d939c5aa4224df18a4
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 18 20:31:43 2006 -0500

    [SCSI] iscsi: update version
    
    update version
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index 08357a6c7e09..c66faee07ca5 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -43,11 +43,13 @@
 
 #include "iscsi_tcp.h"
 
+#define ISCSI_TCP_VERSION "1.0-574"
+
 MODULE_AUTHOR("Dmitry Yusupov &lt;dmitry_yus@yahoo.com&gt;, "
 	      "Alex Aizman &lt;itn780@yahoo.com&gt;");
 MODULE_DESCRIPTION("iSCSI/TCP data-path");
 MODULE_LICENSE("GPL");
-MODULE_VERSION("0:4.445");
+MODULE_VERSION(ISCSI_TCP_VERSION);
 /* #define DEBUG_TCP */
 #define DEBUG_ASSERT
 
@@ -2448,8 +2450,8 @@ static void iscsi_tcp_session_destroy(struct iscsi_cls_session *cls_session)
 }
 
 static struct scsi_host_template iscsi_sht = {
-	.name			= "iSCSI Initiator over TCP/IP, v."
-				  ISCSI_VERSION_STR,
+	.name			= "iSCSI Initiator over TCP/IP, v"
+				  ISCSI_TCP_VERSION,
 	.queuecommand           = iscsi_queuecommand,
 	.change_queue_depth	= iscsi_change_queue_depth,
 	.can_queue		= ISCSI_XMIT_CMDS_MAX - 1,
diff --git a/include/scsi/iscsi_proto.h b/include/scsi/iscsi_proto.h
index 4feda05fdf25..02f6e4b9e693 100644
--- a/include/scsi/iscsi_proto.h
+++ b/include/scsi/iscsi_proto.h
@@ -21,8 +21,6 @@
 #ifndef ISCSI_PROTO_H
 #define ISCSI_PROTO_H
 
-#define ISCSI_VERSION_STR	"0.3"
-#define ISCSI_DATE_STR		"22-Apr-2005"
 #define ISCSI_DRAFT20_VERSION	0x00
 
 /* default iSCSI listen port for incoming connections */</pre><hr><pre>commit 656cffc95f0cb8211aa75eaca249e6ff4f59ec83
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 18 20:31:42 2006 -0500

    [SCSI] iscsi: fix command requeues during iscsi recovery
    
    Do not flush queues then block session. This will cause commands
    to needlessly swing around on us and remove goofy
    recovery_failed field and replace with state value.
    
    And do not start recovery from within the host reset function.
    This causeis too many problems becuase open-iscsi was desinged to
    call out to userspace then have userpscae decide if we should
    go into recovery or kill the session.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 580c0505603c..d810acae45f7 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -487,6 +487,11 @@ void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	if (session-&gt;state == ISCSI_STATE_FAILED) {
+		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+		return;
+	}
+
 	if (session-&gt;conn_cnt == 1 || session-&gt;leadconn == conn)
 		session-&gt;state = ISCSI_STATE_FAILED;
 	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
@@ -612,6 +617,7 @@ enum {
 	FAILURE_SESSION_FREED,
 	FAILURE_WINDOW_CLOSED,
 	FAILURE_SESSION_TERMINATE,
+	FAILURE_SESSION_IN_RECOVERY,
 	FAILURE_SESSION_RECOVERY_TIMEOUT,
 };
 
@@ -631,18 +637,30 @@ int iscsi_queuecommand(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
 
 	spin_lock(&amp;session-&gt;lock);
 
-	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
-		if (session-&gt;recovery_failed) {
-			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
-			goto fault;
-		} else if (session-&gt;state == ISCSI_STATE_FAILED) {
-			reason = FAILURE_SESSION_FAILED;
-			goto reject;
-		} else if (session-&gt;state == ISCSI_STATE_TERMINATE) {
-			reason = FAILURE_SESSION_TERMINATE;
+	/*
+	 * ISCSI_STATE_FAILED is a temp. state. The recovery
+	 * code will decide what is best to do with command queued
+	 * during this time
+	 */
+	if (session-&gt;state != ISCSI_STATE_LOGGED_IN &amp;&amp;
+	    session-&gt;state != ISCSI_STATE_FAILED) {
+		/*
+		 * to handle the race between when we set the recovery state
+		 * and block the session we requeue here (commands could
+		 * be entering our queuecommand while a block is starting
+		 * up because the block code is not locked)
+		 */
+		if (session-&gt;state == ISCSI_STATE_IN_RECOVERY) {
+			reason = FAILURE_SESSION_IN_RECOVERY;
 			goto fault;
 		}
-		reason = FAILURE_SESSION_FREED;
+
+		if (session-&gt;state == ISCSI_STATE_RECOVERY_FAILED)
+			reason = FAILURE_SESSION_RECOVERY_TIMEOUT;
+		else if (session-&gt;state == ISCSI_STATE_TERMINATE)
+			reason = FAILURE_SESSION_TERMINATE;
+		else
+			reason = FAILURE_SESSION_FREED;
 		goto fault;
 	}
 
@@ -728,8 +746,8 @@ iscsi_conn_send_generic(struct iscsi_conn *conn, struct iscsi_hdr *hdr,
 		 */
 		mtask = conn-&gt;login_mtask;
 	else {
-	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
-	        BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
+		BUG_ON(conn-&gt;c_stage == ISCSI_CONN_INITIAL_STAGE);
+		BUG_ON(conn-&gt;c_stage == ISCSI_CONN_STOPPED);
 
 		nop-&gt;exp_statsn = cpu_to_be32(conn-&gt;exp_statsn);
 		if (!__kfifo_get(session-&gt;mgmtpool.queue,
@@ -803,7 +821,7 @@ void iscsi_session_recovery_timedout(struct iscsi_cls_session *cls_session)
 
 	spin_lock_bh(&amp;session-&gt;lock);
 	if (session-&gt;state != ISCSI_STATE_LOGGED_IN) {
-		session-&gt;recovery_failed = 1;
+		session-&gt;state = ISCSI_STATE_RECOVERY_FAILED;
 		if (conn)
 			wake_up(&amp;conn-&gt;ehwait);
 	}
@@ -838,20 +856,14 @@ int iscsi_eh_host_reset(struct scsi_cmnd *sc)
 	 * we drop the lock here but the leadconn cannot be destoyed while
 	 * we are in the scsi eh
 	 */
-	if (fail_session) {
+	if (fail_session)
 		iscsi_conn_failure(conn, ISCSI_ERR_CONN_FAILED);
-		/*
-		 * if userspace cannot respond then we must kick this off
-		 * here for it
-		 */
-		iscsi_start_session_recovery(session, conn, STOP_CONN_RECOVER);
-	}
 
 	debug_scsi("iscsi_eh_host_reset wait for relogin\n");
 	wait_event_interruptible(conn-&gt;ehwait,
 				 session-&gt;state == ISCSI_STATE_TERMINATE ||
 				 session-&gt;state == ISCSI_STATE_LOGGED_IN ||
-				 session-&gt;recovery_failed);
+				 session-&gt;state == ISCSI_STATE_RECOVERY_FAILED);
 	if (signal_pending(current))
 		flush_signals(current);
 
@@ -940,8 +952,7 @@ static int iscsi_exec_abort_task(struct scsi_cmnd *sc,
 	wait_event_interruptible(conn-&gt;ehwait,
 				 sc-&gt;SCp.phase != session-&gt;age ||
 				 session-&gt;state != ISCSI_STATE_LOGGED_IN ||
-				 conn-&gt;tmabort_state != TMABORT_INITIAL ||
-				 session-&gt;recovery_failed);
+				 conn-&gt;tmabort_state != TMABORT_INITIAL);
 	if (signal_pending(current))
 		flush_signals(current);
 	del_timer_sync(&amp;conn-&gt;tmabort_timer);
@@ -1491,7 +1502,6 @@ int iscsi_conn_start(struct iscsi_cls_conn *cls_conn)
 		conn-&gt;stop_stage = 0;
 		conn-&gt;tmabort_state = TMABORT_INITIAL;
 		session-&gt;age++;
-		session-&gt;recovery_failed = 0;
 		spin_unlock_bh(&amp;session-&gt;lock);
 
 		iscsi_unblock_session(session_to_cls(session));
@@ -1566,8 +1576,8 @@ static void fail_all_commands(struct iscsi_conn *conn)
 	conn-&gt;ctask = NULL;
 }
 
-void iscsi_start_session_recovery(struct iscsi_session *session,
-				  struct iscsi_conn *conn, int flag)
+static void iscsi_start_session_recovery(struct iscsi_session *session,
+					 struct iscsi_conn *conn, int flag)
 {
 	int old_stop_stage;
 
@@ -1597,19 +1607,10 @@ void iscsi_start_session_recovery(struct iscsi_session *session,
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 
 	if (session-&gt;conn_cnt == 0 || session-&gt;leadconn == conn)
-		session-&gt;state = ISCSI_STATE_FAILED;
+		session-&gt;state = ISCSI_STATE_IN_RECOVERY;
 
 	spin_unlock_bh(&amp;session-&gt;lock);
 
-	session-&gt;tt-&gt;terminate_conn(conn);
-	/*
-	 * flush queues.
-	 */
-	spin_lock_bh(&amp;session-&gt;lock);
-	fail_all_commands(conn);
-	flush_control_queues(session, conn);
-	spin_unlock_bh(&amp;session-&gt;lock);
-
 	/*
 	 * for connection level recovery we should not calculate
 	 * header digest. conn-&gt;hdr_size used for optimization
@@ -1619,18 +1620,26 @@ void iscsi_start_session_recovery(struct iscsi_session *session,
 	if (flag == STOP_CONN_RECOVER) {
 		conn-&gt;hdrdgst_en = 0;
 		conn-&gt;datadgst_en = 0;
-
 		/*
 		 * if this is called from the eh and and from userspace
 		 * then we only need to block once.
 		 */
-		if (session-&gt;state == ISCSI_STATE_FAILED &amp;&amp;
+		if (session-&gt;state == ISCSI_STATE_IN_RECOVERY &amp;&amp;
 		    old_stop_stage != STOP_CONN_RECOVER)
 			iscsi_block_session(session_to_cls(session));
 	}
+
+	session-&gt;tt-&gt;terminate_conn(conn);
+	/*
+	 * flush queues.
+	 */
+	spin_lock_bh(&amp;session-&gt;lock);
+	fail_all_commands(conn);
+	flush_control_queues(session, conn);
+	spin_unlock_bh(&amp;session-&gt;lock);
+
 	mutex_unlock(&amp;conn-&gt;xmitmutex);
 }
-EXPORT_SYMBOL_GPL(iscsi_start_session_recovery);
 
 void iscsi_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 {
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 2dba929a2a05..17b28f08b692 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -210,7 +210,6 @@ struct iscsi_session {
 						 * - mgmtpool,		   *
 						 * - r2tpool		   */
 	int			state;		/* session state           */
-	int			recovery_failed;
 	struct list_head	item;
 	int			conn_cnt;
 	int			age;		/* counts session re-opens */
@@ -241,8 +240,6 @@ iscsi_session_setup(struct iscsi_transport *, struct scsi_transport_template *,
 		    int, int, uint32_t, uint32_t *);
 extern void iscsi_session_teardown(struct iscsi_cls_session *);
 extern struct iscsi_session *class_to_transport_session(struct iscsi_cls_session *);
-extern void iscsi_start_session_recovery(struct iscsi_session *,
-					struct iscsi_conn *, int);
 extern void iscsi_session_recovery_timedout(struct iscsi_cls_session *);
 
 #define session_to_cls(_sess) \
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index c9e9475c6dff..92129b97d31e 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -173,6 +173,8 @@ struct iscsi_cls_conn {
 #define ISCSI_STATE_LOGGED_IN		2
 #define ISCSI_STATE_FAILED		3
 #define ISCSI_STATE_TERMINATE		4
+#define ISCSI_STATE_IN_RECOVERY		5
+#define ISCSI_STATE_RECOVERY_FAILED	6
 
 struct iscsi_cls_session {
 	struct list_head sess_list;		/* item in session_list */</pre><hr><pre>commit 790f39a2d5f03623b027f340b945f135d006ceba
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Thu May 18 20:31:39 2006 -0500

    [SCSI] iscsi: support mutiple daemons
    
    Patch from david.somayajulu@qlogic.com and cleaned up by Tomo.
    
    qla4xxx is going to have a different daemon so this patch
    just routes the events to the right daemon.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 44adafac861f..5569fdcfd621 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -36,6 +36,7 @@
 #define ISCSI_HOST_ATTRS 0
 
 struct iscsi_internal {
+	int daemon_pid;
 	struct scsi_transport_template t;
 	struct iscsi_transport *iscsi_transport;
 	struct list_head list;
@@ -145,7 +146,6 @@ static DECLARE_TRANSPORT_CLASS(iscsi_connection_class,
 			       NULL);
 
 static struct sock *nls;
-static int daemon_pid;
 static DEFINE_MUTEX(rx_queue_mutex);
 
 struct mempool_zone {
@@ -572,13 +572,13 @@ mempool_zone_get_skb(struct mempool_zone *zone)
 }
 
 static int
-iscsi_unicast_skb(struct mempool_zone *zone, struct sk_buff *skb)
+iscsi_unicast_skb(struct mempool_zone *zone, struct sk_buff *skb, int pid)
 {
 	unsigned long flags;
 	int rc;
 
 	skb_get(skb);
-	rc = netlink_unicast(nls, skb, daemon_pid, MSG_DONTWAIT);
+	rc = netlink_unicast(nls, skb, pid, MSG_DONTWAIT);
 	if (rc &lt; 0) {
 		mempool_free(skb, zone-&gt;pool);
 		printk(KERN_ERR "iscsi: can not unicast skb (%d)\n", rc);
@@ -600,9 +600,14 @@ int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 	struct sk_buff *skb;
 	struct iscsi_uevent *ev;
 	char *pdu;
+	struct iscsi_internal *priv;
 	int len = NLMSG_SPACE(sizeof(*ev) + sizeof(struct iscsi_hdr) +
 			      data_size);
 
+	priv = iscsi_if_transport_lookup(conn-&gt;transport);
+	if (!priv)
+		return -EINVAL;
+
 	mempool_zone_complete(conn-&gt;z_pdu);
 
 	skb = mempool_zone_get_skb(conn-&gt;z_pdu);
@@ -613,7 +618,7 @@ int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 		return -ENOMEM;
 	}
 
-	nlh = __nlmsg_put(skb, daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
+	nlh = __nlmsg_put(skb, priv-&gt;daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
 	ev = NLMSG_DATA(nlh);
 	memset(ev, 0, sizeof(*ev));
 	ev-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
@@ -626,7 +631,7 @@ int iscsi_recv_pdu(struct iscsi_cls_conn *conn, struct iscsi_hdr *hdr,
 	memcpy(pdu, hdr, sizeof(struct iscsi_hdr));
 	memcpy(pdu + sizeof(struct iscsi_hdr), data, data_size);
 
-	return iscsi_unicast_skb(conn-&gt;z_pdu, skb);
+	return iscsi_unicast_skb(conn-&gt;z_pdu, skb, priv-&gt;daemon_pid);
 }
 EXPORT_SYMBOL_GPL(iscsi_recv_pdu);
 
@@ -635,8 +640,13 @@ void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error)
 	struct nlmsghdr	*nlh;
 	struct sk_buff	*skb;
 	struct iscsi_uevent *ev;
+	struct iscsi_internal *priv;
 	int len = NLMSG_SPACE(sizeof(*ev));
 
+	priv = iscsi_if_transport_lookup(conn-&gt;transport);
+	if (!priv)
+		return;
+
 	mempool_zone_complete(conn-&gt;z_error);
 
 	skb = mempool_zone_get_skb(conn-&gt;z_error);
@@ -646,7 +656,7 @@ void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error)
 		return;
 	}
 
-	nlh = __nlmsg_put(skb, daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
+	nlh = __nlmsg_put(skb, priv-&gt;daemon_pid, 0, 0, (len - sizeof(*nlh)), 0);
 	ev = NLMSG_DATA(nlh);
 	ev-&gt;transport_handle = iscsi_handle(conn-&gt;transport);
 	ev-&gt;type = ISCSI_KEVENT_CONN_ERROR;
@@ -656,7 +666,7 @@ void iscsi_conn_error(struct iscsi_cls_conn *conn, enum iscsi_err error)
 	ev-&gt;r.connerror.cid = conn-&gt;cid;
 	ev-&gt;r.connerror.sid = iscsi_conn_get_sid(conn);
 
-	iscsi_unicast_skb(conn-&gt;z_error, skb);
+	iscsi_unicast_skb(conn-&gt;z_error, skb, priv-&gt;daemon_pid);
 
 	dev_printk(KERN_INFO, &amp;conn-&gt;dev, "iscsi: detected conn error (%d)\n",
 		   error);
@@ -686,7 +696,7 @@ iscsi_if_send_reply(int pid, int seq, int type, int done, int multi,
 	nlh = __nlmsg_put(skb, pid, seq, t, (len - sizeof(*nlh)), 0);
 	nlh-&gt;nlmsg_flags = flags;
 	memcpy(NLMSG_DATA(nlh), payload, size);
-	return iscsi_unicast_skb(z_reply, skb);
+	return iscsi_unicast_skb(z_reply, skb, pid);
 }
 
 static int
@@ -698,12 +708,17 @@ iscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
 	struct iscsi_cls_conn *conn;
 	struct nlmsghdr	*nlhstat;
 	struct iscsi_uevent *evstat;
+	struct iscsi_internal *priv;
 	int len = NLMSG_SPACE(sizeof(*ev) +
 			      sizeof(struct iscsi_stats) +
 			      sizeof(struct iscsi_stats_custom) *
 			      ISCSI_STATS_CUSTOM_MAX);
 	int err = 0;
 
+	priv = iscsi_if_transport_lookup(transport);
+	if (!priv)
+		return -EINVAL;
+
 	conn = iscsi_conn_lookup(ev-&gt;u.get_stats.sid, ev-&gt;u.get_stats.cid);
 	if (!conn)
 		return -EEXIST;
@@ -720,7 +735,7 @@ iscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
 			return -ENOMEM;
 		}
 
-		nlhstat = __nlmsg_put(skbstat, daemon_pid, 0, 0,
+		nlhstat = __nlmsg_put(skbstat, priv-&gt;daemon_pid, 0, 0,
 				      (len - sizeof(*nlhstat)), 0);
 		evstat = NLMSG_DATA(nlhstat);
 		memset(evstat, 0, sizeof(*evstat));
@@ -746,7 +761,7 @@ iscsi_if_get_stats(struct iscsi_transport *transport, struct nlmsghdr *nlh)
 		skb_trim(skbstat, NLMSG_ALIGN(actual_size));
 		nlhstat-&gt;nlmsg_len = actual_size;
 
-		err = iscsi_unicast_skb(conn-&gt;z_pdu, skbstat);
+		err = iscsi_unicast_skb(conn-&gt;z_pdu, skbstat, priv-&gt;daemon_pid);
 	} while (err &lt; 0 &amp;&amp; err != -ECONNREFUSED);
 
 	return err;
@@ -981,6 +996,8 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
 	if (!try_module_get(transport-&gt;owner))
 		return -EINVAL;
 
+	priv-&gt;daemon_pid = NETLINK_CREDS(skb)-&gt;pid;
+
 	switch (nlh-&gt;nlmsg_type) {
 	case ISCSI_UEVENT_CREATE_SESSION:
 		err = iscsi_if_create_session(priv, ev);
@@ -1073,7 +1090,6 @@ iscsi_if_rx(struct sock *sk, int len)
 			skb_pull(skb, skb-&gt;len);
 			goto free_skb;
 		}
-		daemon_pid = NETLINK_CREDS(skb)-&gt;pid;
 
 		while (skb-&gt;len &gt;= NLMSG_SPACE(0)) {
 			int err;</pre>
    <div class="pagination">
        <a href='5_38.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><a href='5_9.html'>9</a><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><span>[39]</span><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_40.html'>Next&gt;&gt;</a>
    <div>
</body>
