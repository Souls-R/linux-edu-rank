<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of South Carolina</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of South Carolina</h1>
    <div class="pagination">
        <a href='5_8.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><span>[9]</span><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_10.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit c71b9b669e1243623f7ed4332877d3f2beafc6ab
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 16 15:04:38 2011 -0600

    [SCSI] cxgbi: convert to use iscsi_conn_get_addr_param
    
    This has cxgbi use the iscsi_conn_get_addr_param helper
    and the get ep callback.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
index 69a6769c633e..fc2cdb62f53b 100644
--- a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
+++ b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
@@ -137,7 +137,7 @@ static struct iscsi_transport cxgb3i_iscsi_transport = {
 	.destroy_conn	= iscsi_tcp_conn_teardown,
 	.start_conn	= iscsi_conn_start,
 	.stop_conn	= iscsi_conn_stop,
-	.get_conn_param	= cxgbi_get_conn_param,
+	.get_conn_param	= iscsi_conn_get_param,
 	.set_param	= cxgbi_set_conn_param,
 	.get_stats	= cxgbi_get_conn_stats,
 	/* pdu xmit req from user space */
@@ -152,6 +152,7 @@ static struct iscsi_transport cxgb3i_iscsi_transport = {
 	.xmit_pdu	= cxgbi_conn_xmit_pdu,
 	.parse_pdu_itt	= cxgbi_parse_pdu_itt,
 	/* TCP connect/disconnect */
+	.get_ep_param	= cxgbi_get_ep_param,
 	.ep_connect	= cxgbi_ep_connect,
 	.ep_poll	= cxgbi_ep_poll,
 	.ep_disconnect	= cxgbi_ep_disconnect,
diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
index 719aa71f5b10..f3a4cd7cf782 100644
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -138,7 +138,7 @@ static struct iscsi_transport cxgb4i_iscsi_transport = {
 	.destroy_conn	= iscsi_tcp_conn_teardown,
 	.start_conn		= iscsi_conn_start,
 	.stop_conn		= iscsi_conn_stop,
-	.get_conn_param	= cxgbi_get_conn_param,
+	.get_conn_param	= iscsi_conn_get_param,
 	.set_param	= cxgbi_set_conn_param,
 	.get_stats	= cxgbi_get_conn_stats,
 	/* pdu xmit req from user space */
@@ -153,6 +153,7 @@ static struct iscsi_transport cxgb4i_iscsi_transport = {
 	.xmit_pdu	= cxgbi_conn_xmit_pdu,
 	.parse_pdu_itt	= cxgbi_parse_pdu_itt,
 	/* TCP connect/disconnect */
+	.get_ep_param	= cxgbi_get_ep_param,
 	.ep_connect	= cxgbi_ep_connect,
 	.ep_poll	= cxgbi_ep_poll,
 	.ep_disconnect	= cxgbi_ep_disconnect,
diff --git a/drivers/scsi/cxgbi/libcxgbi.c b/drivers/scsi/cxgbi/libcxgbi.c
index b2acdef3dcb7..fedf1be278ff 100644
--- a/drivers/scsi/cxgbi/libcxgbi.c
+++ b/drivers/scsi/cxgbi/libcxgbi.c
@@ -543,6 +543,7 @@ static struct cxgbi_sock *cxgbi_check_route(struct sockaddr *dst_addr)
 	csk-&gt;dst = dst;
 	csk-&gt;daddr.sin_addr.s_addr = daddr-&gt;sin_addr.s_addr;
 	csk-&gt;daddr.sin_port = daddr-&gt;sin_port;
+	csk-&gt;daddr.sin_family = daddr-&gt;sin_family;
 	csk-&gt;saddr.sin_addr.s_addr = rt-&gt;rt_src;
 
 	return csk;
@@ -2200,32 +2201,34 @@ int cxgbi_set_conn_param(struct iscsi_cls_conn *cls_conn,
 }
 EXPORT_SYMBOL_GPL(cxgbi_set_conn_param);
 
-int cxgbi_get_conn_param(struct iscsi_cls_conn *cls_conn,
-			enum iscsi_param param, char *buf)
+int cxgbi_get_ep_param(struct iscsi_endpoint *ep, enum iscsi_param param,
+		       char *buf)
 {
-	struct iscsi_conn *iconn = cls_conn-&gt;dd_data;
+	struct cxgbi_endpoint *cep = ep-&gt;dd_data;
+	struct cxgbi_sock *csk;
 	int len;
 
 	log_debug(1 &lt;&lt; CXGBI_DBG_ISCSI,
-		"cls_conn 0x%p, param %d.\n", cls_conn, param);
+		"cls_conn 0x%p, param %d.\n", ep, param);
 
 	switch (param) {
 	case ISCSI_PARAM_CONN_PORT:
-		spin_lock_bh(&amp;iconn-&gt;session-&gt;lock);
-		len = sprintf(buf, "%hu\n", iconn-&gt;portal_port);
-		spin_unlock_bh(&amp;iconn-&gt;session-&gt;lock);
-		break;
 	case ISCSI_PARAM_CONN_ADDRESS:
-		spin_lock_bh(&amp;iconn-&gt;session-&gt;lock);
-		len = sprintf(buf, "%s\n", iconn-&gt;portal_address);
-		spin_unlock_bh(&amp;iconn-&gt;session-&gt;lock);
-		break;
+		if (!cep)
+			return -ENOTCONN;
+
+		csk = cep-&gt;csk;
+		if (!csk)
+			return -ENOTCONN;
+
+		return iscsi_conn_get_addr_param((struct sockaddr_storage *)
+						 &amp;csk-&gt;daddr, param, buf);
 	default:
-		return iscsi_conn_get_param(cls_conn, param, buf);
+		return -ENOSYS;
 	}
 	return len;
 }
-EXPORT_SYMBOL_GPL(cxgbi_get_conn_param);
+EXPORT_SYMBOL_GPL(cxgbi_get_ep_param);
 
 struct iscsi_cls_conn *
 cxgbi_create_conn(struct iscsi_cls_session *cls_session, u32 cid)
@@ -2292,11 +2295,6 @@ int cxgbi_bind_conn(struct iscsi_cls_session *cls_session,
 	cxgbi_conn_max_xmit_dlength(conn);
 	cxgbi_conn_max_recv_dlength(conn);
 
-	spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-	sprintf(conn-&gt;portal_address, "%pI4", &amp;csk-&gt;daddr.sin_addr.s_addr);
-	conn-&gt;portal_port = ntohs(csk-&gt;daddr.sin_port);
-	spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-
 	log_debug(1 &lt;&lt; CXGBI_DBG_ISCSI,
 		"cls 0x%p,0x%p, ep 0x%p, cconn 0x%p, csk 0x%p.\n",
 		cls_session, cls_conn, ep, cconn, csk);
diff --git a/drivers/scsi/cxgbi/libcxgbi.h b/drivers/scsi/cxgbi/libcxgbi.h
index 23cbc5854503..0a20fd5f7102 100644
--- a/drivers/scsi/cxgbi/libcxgbi.h
+++ b/drivers/scsi/cxgbi/libcxgbi.h
@@ -712,7 +712,7 @@ void cxgbi_cleanup_task(struct iscsi_task *task);
 void cxgbi_get_conn_stats(struct iscsi_cls_conn *, struct iscsi_stats *);
 int cxgbi_set_conn_param(struct iscsi_cls_conn *,
 			enum iscsi_param, char *, int);
-int cxgbi_get_conn_param(struct iscsi_cls_conn *, enum iscsi_param, char *);
+int cxgbi_get_ep_param(struct iscsi_endpoint *ep, enum iscsi_param, char *);
 struct iscsi_cls_conn *cxgbi_create_conn(struct iscsi_cls_session *, u32);
 int cxgbi_bind_conn(struct iscsi_cls_session *,
 			struct iscsi_cls_conn *, u64, int);
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 4bef19fb3a65..0f4367751b71 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -212,9 +212,6 @@ struct iscsi_conn {
 	/* values userspace uses to id a conn */
 	int			persistent_port;
 	char			*persistent_address;
-	/* remote portal currently connected to */
-	int			portal_port;
-	char			portal_address[ISCSI_ADDRESS_BUF_LEN];
 
 	/* MIB-statistics */
 	uint64_t		txdata_octets;
@@ -319,9 +316,6 @@ struct iscsi_host {
 	/* hw address or netdev iscsi connection is bound to */
 	char			*hwaddress;
 	char			*netdev;
-	/* local address */
-	int			local_port;
-	char			local_address[ISCSI_ADDRESS_BUF_LEN];
 
 	wait_queue_head_t	session_removal_wq;
 	/* protects sessions and state */</pre><hr><pre>commit 289324b0c6007171d67bf1ab0827355ae3374773
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 16 15:04:37 2011 -0600

    [SCSI] iscsi class: add callout to get iscsi_endpoint values
    
    For drivers using the ep callbacks the addr and port
    are attached to the endpoint instead of the conn.
    This adds a callout to the iscsi_transport to get
    ep values. It also adds locking around the get
    param call to make sure that ep_disconnect does
    not free the LLD's ep interconnect structs from
    under us (the ep has a refcount so it will not
    go away but the LLD may have structs from other
    subsystems that are not allocated in the ep so
    we need to protect them from getting freed).
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index a631e58894f1..b4218390941e 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -1782,13 +1782,48 @@ iscsi_conn_attr(data_digest, ISCSI_PARAM_DATADGST_EN);
 iscsi_conn_attr(ifmarker, ISCSI_PARAM_IFMARKER_EN);
 iscsi_conn_attr(ofmarker, ISCSI_PARAM_OFMARKER_EN);
 iscsi_conn_attr(persistent_port, ISCSI_PARAM_PERSISTENT_PORT);
-iscsi_conn_attr(port, ISCSI_PARAM_CONN_PORT);
 iscsi_conn_attr(exp_statsn, ISCSI_PARAM_EXP_STATSN);
 iscsi_conn_attr(persistent_address, ISCSI_PARAM_PERSISTENT_ADDRESS);
-iscsi_conn_attr(address, ISCSI_PARAM_CONN_ADDRESS);
 iscsi_conn_attr(ping_tmo, ISCSI_PARAM_PING_TMO);
 iscsi_conn_attr(recv_tmo, ISCSI_PARAM_RECV_TMO);
 
+#define iscsi_conn_ep_attr_show(param)					\
+static ssize_t show_conn_ep_param_##param(struct device *dev,		\
+					  struct device_attribute *attr,\
+					  char *buf)			\
+{									\
+	struct iscsi_cls_conn *conn = iscsi_dev_to_conn(dev-&gt;parent);	\
+	struct iscsi_transport *t = conn-&gt;transport;			\
+	struct iscsi_endpoint *ep;					\
+	ssize_t rc;							\
+									\
+	/*								\
+	 * Need to make sure ep_disconnect does not free the LLD's	\
+	 * interconnect resources while we are trying to read them.	\
+	 */								\
+	mutex_lock(&amp;conn-&gt;ep_mutex);					\
+	ep = conn-&gt;ep;							\
+	if (!ep &amp;&amp; t-&gt;ep_connect) {					\
+		mutex_unlock(&amp;conn-&gt;ep_mutex);				\
+		return -ENOTCONN;					\
+	}								\
+									\
+	if (ep)								\
+		rc = t-&gt;get_ep_param(ep, param, buf);			\
+	else								\
+		rc = t-&gt;get_conn_param(conn, param, buf);		\
+	mutex_unlock(&amp;conn-&gt;ep_mutex);					\
+	return rc;							\
+}
+
+#define iscsi_conn_ep_attr(field, param)				\
+	iscsi_conn_ep_attr_show(param)					\
+static ISCSI_CLASS_ATTR(conn, field, S_IRUGO,				\
+			show_conn_ep_param_##param, NULL);
+
+iscsi_conn_ep_attr(address, ISCSI_PARAM_CONN_ADDRESS);
+iscsi_conn_ep_attr(port, ISCSI_PARAM_CONN_PORT);
+
 /*
  * iSCSI session attrs
  */
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 00e5bf7c9de6..bf8f52965675 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -101,6 +101,8 @@ struct iscsi_transport {
 	void (*destroy_conn) (struct iscsi_cls_conn *conn);
 	int (*set_param) (struct iscsi_cls_conn *conn, enum iscsi_param param,
 			  char *buf, int buflen);
+	int (*get_ep_param) (struct iscsi_endpoint *ep, enum iscsi_param param,
+			     char *buf);
 	int (*get_conn_param) (struct iscsi_cls_conn *conn,
 			       enum iscsi_param param, char *buf);
 	int (*get_session_param) (struct iscsi_cls_session *session,</pre><hr><pre>commit a79af8a64d395bd89de8695a5ea5e1a7f01f02a8
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 16 15:04:36 2011 -0600

    [SCSI] iscsi_tcp: use iscsi_conn_get_addr_param libiscsi function
    
    This has iscsi_tcp use the iscsi_conn_get_addr_param
    libiscsi function. It also drops the use of the libiscsi
    session portal buffers, so they can be removed in
    the next patches. Instead of copying the values
    at bind time we get them during get() time. If we are
    not connected userspace will now get -ENOTCONN,
    so it knows that connection is disconnected instead
    of a possible stale value.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/iscsi_tcp.c b/drivers/scsi/iscsi_tcp.c
index fec47de72535..a860452a8f71 100644
--- a/drivers/scsi/iscsi_tcp.c
+++ b/drivers/scsi/iscsi_tcp.c
@@ -608,54 +608,12 @@ static void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)
 	iscsi_sw_tcp_release_conn(conn);
 }
 
-static int iscsi_sw_tcp_get_addr(struct iscsi_conn *conn, struct socket *sock,
-				 char *buf, int *port,
-				 int (*getname)(struct socket *,
-						struct sockaddr *,
-						int *addrlen))
-{
-	struct sockaddr_storage *addr;
-	struct sockaddr_in6 *sin6;
-	struct sockaddr_in *sin;
-	int rc = 0, len;
-
-	addr = kmalloc(sizeof(*addr), GFP_KERNEL);
-	if (!addr)
-		return -ENOMEM;
-
-	if (getname(sock, (struct sockaddr *) addr, &amp;len)) {
-		rc = -ENODEV;
-		goto free_addr;
-	}
-
-	switch (addr-&gt;ss_family) {
-	case AF_INET:
-		sin = (struct sockaddr_in *)addr;
-		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-		sprintf(buf, "%pI4", &amp;sin-&gt;sin_addr.s_addr);
-		*port = be16_to_cpu(sin-&gt;sin_port);
-		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-		break;
-	case AF_INET6:
-		sin6 = (struct sockaddr_in6 *)addr;
-		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-		sprintf(buf, "%pI6", &amp;sin6-&gt;sin6_addr);
-		*port = be16_to_cpu(sin6-&gt;sin6_port);
-		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-		break;
-	}
-free_addr:
-	kfree(addr);
-	return rc;
-}
-
 static int
 iscsi_sw_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 		       struct iscsi_cls_conn *cls_conn, uint64_t transport_eph,
 		       int is_leading)
 {
-	struct Scsi_Host *shost = iscsi_session_to_shost(cls_session);
-	struct iscsi_host *ihost = shost_priv(shost);
+	struct iscsi_session *session = cls_session-&gt;dd_data;
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
 	struct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn-&gt;dd_data;
@@ -670,27 +628,15 @@ iscsi_sw_tcp_conn_bind(struct iscsi_cls_session *cls_session,
 				  "sockfd_lookup failed %d\n", err);
 		return -EEXIST;
 	}
-	/*
-	 * copy these values now because if we drop the session
-	 * userspace may still want to query the values since we will
-	 * be using them for the reconnect
-	 */
-	err = iscsi_sw_tcp_get_addr(conn, sock, conn-&gt;portal_address,
-				    &amp;conn-&gt;portal_port, kernel_getpeername);
-	if (err)
-		goto free_socket;
-
-	err = iscsi_sw_tcp_get_addr(conn, sock, ihost-&gt;local_address,
-				    &amp;ihost-&gt;local_port, kernel_getsockname);
-	if (err)
-		goto free_socket;
 
 	err = iscsi_conn_bind(cls_session, cls_conn, is_leading);
 	if (err)
 		goto free_socket;
 
+	spin_lock_bh(&amp;session-&gt;lock);
 	/* bind iSCSI connection and socket */
 	tcp_sw_conn-&gt;sock = sock;
+	spin_unlock_bh(&amp;session-&gt;lock);
 
 	/* setup Socket parameters */
 	sk = sock-&gt;sk;
@@ -752,24 +698,74 @@ static int iscsi_sw_tcp_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				       enum iscsi_param param, char *buf)
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
-	int len;
+	struct iscsi_tcp_conn *tcp_conn = conn-&gt;dd_data;
+	struct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn-&gt;dd_data;
+	struct sockaddr_in6 addr;
+	int rc, len;
 
 	switch(param) {
 	case ISCSI_PARAM_CONN_PORT:
-		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-		len = sprintf(buf, "%hu\n", conn-&gt;portal_port);
-		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-		break;
 	case ISCSI_PARAM_CONN_ADDRESS:
 		spin_lock_bh(&amp;conn-&gt;session-&gt;lock);
-		len = sprintf(buf, "%s\n", conn-&gt;portal_address);
+		if (!tcp_sw_conn || !tcp_sw_conn-&gt;sock) {
+			spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
+			return -ENOTCONN;
+		}
+		rc = kernel_getpeername(tcp_sw_conn-&gt;sock,
+					(struct sockaddr *)&amp;addr, &amp;len);
 		spin_unlock_bh(&amp;conn-&gt;session-&gt;lock);
-		break;
+		if (rc)
+			return rc;
+
+		return iscsi_conn_get_addr_param((struct sockaddr_storage *)
+						 &amp;addr, param, buf);
 	default:
 		return iscsi_conn_get_param(cls_conn, param, buf);
 	}
 
-	return len;
+	return 0;
+}
+
+static int iscsi_sw_tcp_host_get_param(struct Scsi_Host *shost,
+				       enum iscsi_host_param param, char *buf)
+{
+	struct iscsi_sw_tcp_host *tcp_sw_host = iscsi_host_priv(shost);
+	struct iscsi_session *session = tcp_sw_host-&gt;session;
+	struct iscsi_conn *conn;
+	struct iscsi_tcp_conn *tcp_conn;
+	struct iscsi_sw_tcp_conn *tcp_sw_conn;
+	struct sockaddr_in6 addr;
+	int rc, len;
+
+	switch (param) {
+	case ISCSI_HOST_PARAM_IPADDRESS:
+		spin_lock_bh(&amp;session-&gt;lock);
+		conn = session-&gt;leadconn;
+		if (!conn) {
+			spin_unlock_bh(&amp;session-&gt;lock);
+			return -ENOTCONN;
+		}
+		tcp_conn = conn-&gt;dd_data;
+
+		tcp_sw_conn = tcp_conn-&gt;dd_data;
+		if (!tcp_sw_conn-&gt;sock) {
+			spin_unlock_bh(&amp;session-&gt;lock);
+			return -ENOTCONN;
+		}
+
+		rc = kernel_getsockname(tcp_sw_conn-&gt;sock,
+					(struct sockaddr *)&amp;addr, &amp;len);
+		spin_unlock_bh(&amp;session-&gt;lock);
+		if (rc)
+			return rc;
+
+		return iscsi_conn_get_addr_param((struct sockaddr_storage *)
+						 &amp;addr, param, buf);
+	default:
+		return iscsi_host_get_param(shost, param, buf);
+	}
+
+	return 0;
 }
 
 static void
@@ -797,6 +793,7 @@ iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 {
 	struct iscsi_cls_session *cls_session;
 	struct iscsi_session *session;
+	struct iscsi_sw_tcp_host *tcp_sw_host;
 	struct Scsi_Host *shost;
 
 	if (ep) {
@@ -804,7 +801,8 @@ iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 		return NULL;
 	}
 
-	shost = iscsi_host_alloc(&amp;iscsi_sw_tcp_sht, 0, 1);
+	shost = iscsi_host_alloc(&amp;iscsi_sw_tcp_sht,
+				 sizeof(struct iscsi_sw_tcp_host), 1);
 	if (!shost)
 		return NULL;
 	shost-&gt;transportt = iscsi_sw_tcp_scsi_transport;
@@ -825,6 +823,8 @@ iscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,
 	if (!cls_session)
 		goto remove_host;
 	session = cls_session-&gt;dd_data;
+	tcp_sw_host = iscsi_host_priv(shost);
+	tcp_sw_host-&gt;session = session;
 
 	shost-&gt;can_queue = session-&gt;scsi_cmds_max;
 	if (iscsi_tcp_r2tpool_alloc(session))
@@ -929,7 +929,7 @@ static struct iscsi_transport iscsi_sw_tcp_transport = {
 	.start_conn		= iscsi_conn_start,
 	.stop_conn		= iscsi_sw_tcp_conn_stop,
 	/* iscsi host params */
-	.get_host_param		= iscsi_host_get_param,
+	.get_host_param		= iscsi_sw_tcp_host_get_param,
 	.set_host_param		= iscsi_host_set_param,
 	/* IO */
 	.send_pdu		= iscsi_conn_send_pdu,
diff --git a/drivers/scsi/iscsi_tcp.h b/drivers/scsi/iscsi_tcp.h
index 94644bad0ed7..666fe09378fa 100644
--- a/drivers/scsi/iscsi_tcp.h
+++ b/drivers/scsi/iscsi_tcp.h
@@ -55,6 +55,10 @@ struct iscsi_sw_tcp_conn {
 	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
 };
 
+struct iscsi_sw_tcp_host {
+	struct iscsi_session	*session;
+};
+
 struct iscsi_sw_tcp_hdrbuf {
 	struct iscsi_hdr	hdrbuf;
 	char			hdrextbuf[ISCSI_MAX_AHS_SIZE +</pre><hr><pre>commit 00f3708e6ed1698d6aee3901ea991197e31a8007
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 16 15:04:35 2011 -0600

    [SCSI] libiscsi: add helper to convert addr to string
    
    This adds a helper to convert a addr struct to
    a string. This will be used by the drivers in
    the next patches.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index da8b61543ee4..0c550d5b9133 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -3352,6 +3352,47 @@ int iscsi_session_get_param(struct iscsi_cls_session *cls_session,
 }
 EXPORT_SYMBOL_GPL(iscsi_session_get_param);
 
+int iscsi_conn_get_addr_param(struct sockaddr_storage *addr,
+			      enum iscsi_param param, char *buf)
+{
+	struct sockaddr_in6 *sin6 = NULL;
+	struct sockaddr_in *sin = NULL;
+	int len;
+
+	switch (addr-&gt;ss_family) {
+	case AF_INET:
+		sin = (struct sockaddr_in *)addr;
+		break;
+	case AF_INET6:
+		sin6 = (struct sockaddr_in6 *)addr;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (param) {
+	case ISCSI_PARAM_CONN_ADDRESS:
+	case ISCSI_HOST_PARAM_IPADDRESS:
+		if (sin)
+			len = sprintf(buf, "%pI4\n", &amp;sin-&gt;sin_addr.s_addr);
+		else
+			len = sprintf(buf, "%pI6\n", &amp;sin6-&gt;sin6_addr);
+		break;
+	case ISCSI_PARAM_CONN_PORT:
+		if (sin)
+			len = sprintf(buf, "%hu\n", be16_to_cpu(sin-&gt;sin_port));
+		else
+			len = sprintf(buf, "%hu\n",
+				      be16_to_cpu(sin6-&gt;sin6_port));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return len;
+}
+EXPORT_SYMBOL_GPL(iscsi_conn_get_addr_param);
+
 int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 			 enum iscsi_param param, char *buf)
 {
@@ -3416,9 +3457,6 @@ int iscsi_host_get_param(struct Scsi_Host *shost, enum iscsi_host_param param,
 	case ISCSI_HOST_PARAM_INITIATOR_NAME:
 		len = sprintf(buf, "%s\n", ihost-&gt;initiatorname);
 		break;
-	case ISCSI_HOST_PARAM_IPADDRESS:
-		len = sprintf(buf, "%s\n", ihost-&gt;local_address);
-		break;
 	default:
 		return -ENOSYS;
 	}
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 748382b32b52..4bef19fb3a65 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -394,6 +394,8 @@ extern void iscsi_session_failure(struct iscsi_session *session,
 				  enum iscsi_err err);
 extern int iscsi_conn_get_param(struct iscsi_cls_conn *cls_conn,
 				enum iscsi_param param, char *buf);
+extern int iscsi_conn_get_addr_param(struct sockaddr_storage *addr,
+				     enum iscsi_param param, char *buf);
 extern void iscsi_suspend_tx(struct iscsi_conn *conn);
 extern void iscsi_suspend_queue(struct iscsi_conn *conn);
 extern void iscsi_conn_queue_work(struct iscsi_conn *conn);</pre><hr><pre>commit bbc5261b2cb5e69754c935ea2466fb22775f0e48
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 16 15:04:34 2011 -0600

    [SCSI] iscsi class: remove unused active variable
    
    The active variable on the iscsi_cls_conn is not used
    so this patch removes it.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index 4e09b68a0789..a631e58894f1 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -976,7 +976,6 @@ iscsi_create_conn(struct iscsi_cls_session *session, int dd_size, uint32_t cid)
 
 	spin_lock_irqsave(&amp;connlock, flags);
 	list_add(&amp;conn-&gt;conn_list, &amp;connlist);
-	conn-&gt;active = 1;
 	spin_unlock_irqrestore(&amp;connlock, flags);
 
 	ISCSI_DBG_TRANS_CONN(conn, "Completed conn creation\n");
@@ -1002,7 +1001,6 @@ int iscsi_destroy_conn(struct iscsi_cls_conn *conn)
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;connlock, flags);
-	conn-&gt;active = 0;
 	list_del(&amp;conn-&gt;conn_list);
 	spin_unlock_irqrestore(&amp;connlock, flags);
 
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index b9ba349ef257..00e5bf7c9de6 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -163,7 +163,6 @@ struct iscsi_cls_conn {
 	struct mutex ep_mutex;
 	struct iscsi_endpoint *ep;
 
-	int active;			/* must be accessed with the connlock */
 	struct device dev;		/* sysfs transport/container device */
 };
 </pre><hr><pre>commit 22a39fbbfecfea703b686a4626a631d706ccb3ee
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 16 15:04:33 2011 -0600

    [SCSI] iscsi: fix iscsi_endpoint leak
    
    When iscsid restarts it does not know the connection's
    endpoint, so it is getting leaked. This fixes the problem
    by having the iscsi class force a disconnect before a
    new connection is bound.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/scsi_transport_iscsi.c b/drivers/scsi/scsi_transport_iscsi.c
index f905ecb5704d..4e09b68a0789 100644
--- a/drivers/scsi/scsi_transport_iscsi.c
+++ b/drivers/scsi/scsi_transport_iscsi.c
@@ -954,6 +954,7 @@ iscsi_create_conn(struct iscsi_cls_session *session, int dd_size, uint32_t cid)
 	if (dd_size)
 		conn-&gt;dd_data = &amp;conn[1];
 
+	mutex_init(&amp;conn-&gt;ep_mutex);
 	INIT_LIST_HEAD(&amp;conn-&gt;conn_list);
 	conn-&gt;transport = transport;
 	conn-&gt;cid = cid;
@@ -1430,6 +1431,29 @@ static int iscsi_if_ep_connect(struct iscsi_transport *transport,
 	return err;
 }
 
+static int iscsi_if_ep_disconnect(struct iscsi_transport *transport,
+				  u64 ep_handle)
+{
+	struct iscsi_cls_conn *conn;
+	struct iscsi_endpoint *ep;
+
+	if (!transport-&gt;ep_disconnect)
+		return -EINVAL;
+
+	ep = iscsi_lookup_endpoint(ep_handle);
+	if (!ep)
+		return -EINVAL;
+	conn = ep-&gt;conn;
+	if (conn) {
+		mutex_lock(&amp;conn-&gt;ep_mutex);
+		conn-&gt;ep = NULL;
+		mutex_unlock(&amp;conn-&gt;ep_mutex);
+	}
+
+	transport-&gt;ep_disconnect(ep);
+	return 0;
+}
+
 static int
 iscsi_if_transport_ep(struct iscsi_transport *transport,
 		      struct iscsi_uevent *ev, int msg_type)
@@ -1454,14 +1478,8 @@ iscsi_if_transport_ep(struct iscsi_transport *transport,
 						   ev-&gt;u.ep_poll.timeout_ms);
 		break;
 	case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT:
-		if (!transport-&gt;ep_disconnect)
-			return -EINVAL;
-
-		ep = iscsi_lookup_endpoint(ev-&gt;u.ep_disconnect.ep_handle);
-		if (!ep)
-			return -EINVAL;
-
-		transport-&gt;ep_disconnect(ep);
+		rc = iscsi_if_ep_disconnect(transport,
+					    ev-&gt;u.ep_disconnect.ep_handle);
 		break;
 	}
 	return rc;
@@ -1609,12 +1627,31 @@ iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group)
 		session = iscsi_session_lookup(ev-&gt;u.b_conn.sid);
 		conn = iscsi_conn_lookup(ev-&gt;u.b_conn.sid, ev-&gt;u.b_conn.cid);
 
-		if (session &amp;&amp; conn)
-			ev-&gt;r.retcode =	transport-&gt;bind_conn(session, conn,
-					ev-&gt;u.b_conn.transport_eph,
-					ev-&gt;u.b_conn.is_leading);
-		else
+		if (conn &amp;&amp; conn-&gt;ep)
+			iscsi_if_ep_disconnect(transport, conn-&gt;ep-&gt;id);
+
+		if (!session || !conn) {
 			err = -EINVAL;
+			break;
+		}
+
+		ev-&gt;r.retcode =	transport-&gt;bind_conn(session, conn,
+						ev-&gt;u.b_conn.transport_eph,
+						ev-&gt;u.b_conn.is_leading);
+		if (ev-&gt;r.retcode || !transport-&gt;ep_connect)
+			break;
+
+		ep = iscsi_lookup_endpoint(ev-&gt;u.b_conn.transport_eph);
+		if (ep) {
+			ep-&gt;conn = conn;
+
+			mutex_lock(&amp;conn-&gt;ep_mutex);
+			conn-&gt;ep = ep;
+			mutex_unlock(&amp;conn-&gt;ep_mutex);
+		} else
+			iscsi_cls_conn_printk(KERN_ERR, conn,
+					      "Could not set ep conn "
+					      "binding\n");
 		break;
 	case ISCSI_UEVENT_SET_PARAM:
 		err = iscsi_set_param(transport, ev);
diff --git a/include/scsi/scsi_transport_iscsi.h b/include/scsi/scsi_transport_iscsi.h
index 7fff94b3b2a8..b9ba349ef257 100644
--- a/include/scsi/scsi_transport_iscsi.h
+++ b/include/scsi/scsi_transport_iscsi.h
@@ -160,6 +160,8 @@ struct iscsi_cls_conn {
 	void *dd_data;			/* LLD private data */
 	struct iscsi_transport *transport;
 	uint32_t cid;			/* connection id */
+	struct mutex ep_mutex;
+	struct iscsi_endpoint *ep;
 
 	int active;			/* must be accessed with the connlock */
 	struct device dev;		/* sysfs transport/container device */
@@ -222,6 +224,7 @@ struct iscsi_endpoint {
 	void *dd_data;			/* LLD private data */
 	struct device dev;
 	uint64_t id;
+	struct iscsi_cls_conn *conn;
 };
 
 /*</pre><hr><pre>commit fdafd4dfc7bbdd40a4692192b77299b28c8a948f
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Wed Feb 16 15:04:32 2011 -0600

    [SCSI] cxgbi: enable TEXT PDU support
    
    cxgb3i and cxgb4i support TEXT PDU offloading, so set
    the bits to enable it.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
index e2362b97f329..69a6769c633e 100644
--- a/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
+++ b/drivers/scsi/cxgbi/cxgb3i/cxgb3i.c
@@ -105,7 +105,7 @@ static struct iscsi_transport cxgb3i_iscsi_transport = {
 	/* owner and name should be set already */
 	.caps		= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST
 				| CAP_DATADGST | CAP_DIGEST_OFFLOAD |
-				CAP_PADDING_OFFLOAD,
+				CAP_PADDING_OFFLOAD | CAP_TEXT_NEGO,
 	.param_mask	= ISCSI_MAX_RECV_DLENGTH | ISCSI_MAX_XMIT_DLENGTH |
 				ISCSI_HDRDGST_EN | ISCSI_DATADGST_EN |
 				ISCSI_INITIAL_R2T_EN | ISCSI_MAX_R2T |
diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
index 5b1f0785dafd..719aa71f5b10 100644
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@ -106,7 +106,7 @@ static struct iscsi_transport cxgb4i_iscsi_transport = {
 	.name		= DRV_MODULE_NAME,
 	.caps		= CAP_RECOVERY_L0 | CAP_MULTI_R2T | CAP_HDRDGST |
 				CAP_DATADGST | CAP_DIGEST_OFFLOAD |
-				CAP_PADDING_OFFLOAD,
+				CAP_PADDING_OFFLOAD | CAP_TEXT_NEGO,
 	.param_mask	= ISCSI_MAX_RECV_DLENGTH | ISCSI_MAX_XMIT_DLENGTH |
 				ISCSI_HDRDGST_EN | ISCSI_DATADGST_EN |
 				ISCSI_INITIAL_R2T_EN | ISCSI_MAX_R2T |</pre><hr><pre>commit bfcf72e4426da2fd8f8081a641385ffc3ccc2282
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Dec 31 02:22:22 2010 -0600

    [SCSI] libiscsi: use bh locking instead of irq with session lock
    
    The session lock is taken in threads, timers, and bottom halves
    like softirqs and tasklets. All the code but
    iscsi_conn/session_failure take the session lock with the spin_lock_bh
    call. This was done because I thought some offload drivers
    would be calling these functions from a irq. They never did,
    so this patch has iscsi_conn/session_failure use the bh
    locking.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 1def8e101249..da8b61543ee4 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -1338,17 +1338,16 @@ void iscsi_session_failure(struct iscsi_session *session,
 {
 	struct iscsi_conn *conn;
 	struct device *dev;
-	unsigned long flags;
 
-	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	spin_lock_bh(&amp;session-&gt;lock);
 	conn = session-&gt;leadconn;
 	if (session-&gt;state == ISCSI_STATE_TERMINATE || !conn) {
-		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+		spin_unlock_bh(&amp;session-&gt;lock);
 		return;
 	}
 
 	dev = get_device(&amp;conn-&gt;cls_conn-&gt;dev);
-	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+	spin_unlock_bh(&amp;session-&gt;lock);
 	if (!dev)
 	        return;
 	/*
@@ -1367,17 +1366,16 @@ EXPORT_SYMBOL_GPL(iscsi_session_failure);
 void iscsi_conn_failure(struct iscsi_conn *conn, enum iscsi_err err)
 {
 	struct iscsi_session *session = conn-&gt;session;
-	unsigned long flags;
 
-	spin_lock_irqsave(&amp;session-&gt;lock, flags);
+	spin_lock_bh(&amp;session-&gt;lock);
 	if (session-&gt;state == ISCSI_STATE_FAILED) {
-		spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+		spin_unlock_bh(&amp;session-&gt;lock);
 		return;
 	}
 
 	if (conn-&gt;stop_stage == 0)
 		session-&gt;state = ISCSI_STATE_FAILED;
-	spin_unlock_irqrestore(&amp;session-&gt;lock, flags);
+	spin_unlock_bh(&amp;session-&gt;lock);
 
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_tx);
 	set_bit(ISCSI_SUSPEND_BIT, &amp;conn-&gt;suspend_rx);</pre><hr><pre>commit f41d472179a0d7c8e8160c85180ab1124947068e
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Dec 31 02:22:21 2010 -0600

    [SCSI] libiscsi: do not take host lock in queuecommand
    
    iscsi_tcp, ib_iser, cxgb*, be2iscsi and bnx2i do not use
    the host lock and do not take the session lock against
    a irq, so this patch drops the DEF_SCSI_QCMD use. Instead
    we just take the session lock and disable bhs.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 3eddab0774e4..1def8e101249 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -505,6 +505,7 @@ static void iscsi_free_task(struct iscsi_task *task)
 	struct iscsi_conn *conn = task-&gt;conn;
 	struct iscsi_session *session = conn-&gt;session;
 	struct scsi_cmnd *sc = task-&gt;sc;
+	int oldstate = task-&gt;state;
 
 	ISCSI_DBG_SESSION(session, "freeing task itt 0x%x state %d sc %p\n",
 			  task-&gt;itt, task-&gt;state, task-&gt;sc);
@@ -525,10 +526,10 @@ static void iscsi_free_task(struct iscsi_task *task)
 		/* SCSI eh reuses commands to verify us */
 		sc-&gt;SCp.ptr = NULL;
 		/*
-		 * queue command may call this to free the task, but
-		 * not have setup the sc callback
+		 * queue command may call this to free the task, so
+		 * it will decide how to return sc to scsi-ml.
 		 */
-		if (sc-&gt;scsi_done)
+		if (oldstate != ISCSI_TASK_REQUEUE_SCSIQ)
 			sc-&gt;scsi_done(sc);
 	}
 }
@@ -572,7 +573,8 @@ static void iscsi_complete_task(struct iscsi_task *task, int state)
 			  task-&gt;itt, task-&gt;state, task-&gt;sc);
 	if (task-&gt;state == ISCSI_TASK_COMPLETED ||
 	    task-&gt;state == ISCSI_TASK_ABRT_TMF ||
-	    task-&gt;state == ISCSI_TASK_ABRT_SESS_RECOV)
+	    task-&gt;state == ISCSI_TASK_ABRT_SESS_RECOV ||
+	    task-&gt;state == ISCSI_TASK_REQUEUE_SCSIQ)
 		return;
 	WARN_ON_ONCE(task-&gt;state == ISCSI_TASK_FREE);
 	task-&gt;state = state;
@@ -1600,27 +1602,23 @@ enum {
 	FAILURE_SESSION_NOT_READY,
 };
 
-static int iscsi_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi_cmnd *))
+int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc)
 {
 	struct iscsi_cls_session *cls_session;
-	struct Scsi_Host *host;
 	struct iscsi_host *ihost;
 	int reason = 0;
 	struct iscsi_session *session;
 	struct iscsi_conn *conn;
 	struct iscsi_task *task = NULL;
 
-	sc-&gt;scsi_done = done;
 	sc-&gt;result = 0;
 	sc-&gt;SCp.ptr = NULL;
 
-	host = sc-&gt;device-&gt;host;
 	ihost = shost_priv(host);
-	spin_unlock(host-&gt;host_lock);
 
 	cls_session = starget_to_session(scsi_target(sc-&gt;device));
 	session = cls_session-&gt;dd_data;
-	spin_lock(&amp;session-&gt;lock);
+	spin_lock_bh(&amp;session-&gt;lock);
 
 	reason = iscsi_session_chkready(cls_session);
 	if (reason) {
@@ -1706,25 +1704,21 @@ static int iscsi_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi
 	}
 
 	session-&gt;queued_cmdsn++;
-	spin_unlock(&amp;session-&gt;lock);
-	spin_lock(host-&gt;host_lock);
+	spin_unlock_bh(&amp;session-&gt;lock);
 	return 0;
 
 prepd_reject:
-	sc-&gt;scsi_done = NULL;
-	iscsi_complete_task(task, ISCSI_TASK_COMPLETED);
+	iscsi_complete_task(task, ISCSI_TASK_REQUEUE_SCSIQ);
 reject:
-	spin_unlock(&amp;session-&gt;lock);
+	spin_unlock_bh(&amp;session-&gt;lock);
 	ISCSI_DBG_SESSION(session, "cmd 0x%x rejected (%d)\n",
 			  sc-&gt;cmnd[0], reason);
-	spin_lock(host-&gt;host_lock);
 	return SCSI_MLQUEUE_TARGET_BUSY;
 
 prepd_fault:
-	sc-&gt;scsi_done = NULL;
-	iscsi_complete_task(task, ISCSI_TASK_COMPLETED);
+	iscsi_complete_task(task, ISCSI_TASK_REQUEUE_SCSIQ);
 fault:
-	spin_unlock(&amp;session-&gt;lock);
+	spin_unlock_bh(&amp;session-&gt;lock);
 	ISCSI_DBG_SESSION(session, "iscsi: cmd 0x%x is not queued (%d)\n",
 			  sc-&gt;cmnd[0], reason);
 	if (!scsi_bidi_cmnd(sc))
@@ -1733,12 +1727,9 @@ static int iscsi_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi
 		scsi_out(sc)-&gt;resid = scsi_out(sc)-&gt;length;
 		scsi_in(sc)-&gt;resid = scsi_in(sc)-&gt;length;
 	}
-	done(sc);
-	spin_lock(host-&gt;host_lock);
+	sc-&gt;scsi_done(sc);
 	return 0;
 }
-
-DEF_SCSI_QCMD(iscsi_queuecommand)
 EXPORT_SYMBOL_GPL(iscsi_queuecommand);
 
 int iscsi_change_queue_depth(struct scsi_device *sdev, int depth, int reason)
diff --git a/include/scsi/libiscsi.h b/include/scsi/libiscsi.h
index 68e951d79f0b..748382b32b52 100644
--- a/include/scsi/libiscsi.h
+++ b/include/scsi/libiscsi.h
@@ -89,6 +89,7 @@ enum {
 	ISCSI_TASK_RUNNING,
 	ISCSI_TASK_ABRT_TMF,		/* aborted due to TMF */
 	ISCSI_TASK_ABRT_SESS_RECOV,	/* aborted due to session recovery */
+	ISCSI_TASK_REQUEUE_SCSIQ,	/* qcmd requeueing to scsi-ml */
 };
 
 struct iscsi_r2t_info {
@@ -341,7 +342,7 @@ extern int iscsi_eh_abort(struct scsi_cmnd *sc);
 extern int iscsi_eh_recover_target(struct scsi_cmnd *sc);
 extern int iscsi_eh_session_reset(struct scsi_cmnd *sc);
 extern int iscsi_eh_device_reset(struct scsi_cmnd *sc);
-extern int iscsi_queuecommand(struct Scsi_Host *h, struct scsi_cmnd *sc);
+extern int iscsi_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *sc);
 
 /*
  * iSCSI host helpers.</pre><hr><pre>commit 1227633a441363642cdbaf38c4241d071e917095
Author: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
Date:   Fri Dec 31 02:22:20 2010 -0600

    [SCSI] be2iscsi: fix null ptr when accessing task hdr
    
    If alloc_pdu fails then the task-&gt;hdr pointer may not be
    set. This adds a check for this case in the cleanup callback.
    
    Signed-off-by: Mike Christie &lt;michaelc@cs.wisc.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@suse.de&gt;

diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c
index be07ca06177e..79cefbe31367 100644
--- a/drivers/scsi/be2iscsi/be_main.c
+++ b/drivers/scsi/be2iscsi/be_main.c
@@ -3914,7 +3914,8 @@ static void beiscsi_cleanup_task(struct iscsi_task *task)
 			io_task-&gt;psgl_handle = NULL;
 		}
 	} else {
-		if ((task-&gt;hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) == ISCSI_OP_LOGIN)
+		if (task-&gt;hdr &amp;&amp;
+		   ((task-&gt;hdr-&gt;opcode &amp; ISCSI_OPCODE_MASK) == ISCSI_OP_LOGIN))
 			return;
 		if (io_task-&gt;psgl_handle) {
 			spin_lock(&amp;phba-&gt;mgmt_sgl_lock);</pre>
    <div class="pagination">
        <a href='5_8.html'>&lt;&lt;Prev</a><a href='5.html'>1</a><a href='5_2.html'>2</a><a href='5_3.html'>3</a><a href='5_4.html'>4</a><a href='5_5.html'>5</a><a href='5_6.html'>6</a><a href='5_7.html'>7</a><a href='5_8.html'>8</a><span>[9]</span><a href='5_10.html'>10</a><a href='5_11.html'>11</a><a href='5_12.html'>12</a><a href='5_13.html'>13</a><a href='5_14.html'>14</a><a href='5_15.html'>15</a><a href='5_16.html'>16</a><a href='5_17.html'>17</a><a href='5_18.html'>18</a><a href='5_19.html'>19</a><a href='5_20.html'>20</a><a href='5_21.html'>21</a><a href='5_22.html'>22</a><a href='5_23.html'>23</a><a href='5_24.html'>24</a><a href='5_25.html'>25</a><a href='5_26.html'>26</a><a href='5_27.html'>27</a><a href='5_28.html'>28</a><a href='5_29.html'>29</a><a href='5_30.html'>30</a><a href='5_31.html'>31</a><a href='5_32.html'>32</a><a href='5_33.html'>33</a><a href='5_34.html'>34</a><a href='5_35.html'>35</a><a href='5_36.html'>36</a><a href='5_37.html'>37</a><a href='5_38.html'>38</a><a href='5_39.html'>39</a><a href='5_40.html'>40</a><a href='5_41.html'>41</a><a href='5_42.html'>42</a><a href='5_43.html'>43</a><a href='5_44.html'>44</a><a href='5_45.html'>45</a><a href='5_46.html'>46</a><a href='5_47.html'>47</a><a href='5_48.html'>48</a><a href='5_10.html'>Next&gt;&gt;</a>
    <div>
</body>
