<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_123.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><span>[124]</span><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_125.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 20307949469269ceea6262aaa306dcb55cf43b25
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jun 28 11:20:41 2006 -0400

    [PATCH] usbcore: fixes for hub_port_resume
    
    This patch (as731) makes a couple of small fixes to the hub_port_resume
    routine:
    
            Don't return status &gt;= 0 when an error occurs;
    
            Clear the port-change-suspend status indicator after
            resuming a device.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 41531bba4321..26c8cb5f3e67 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1882,7 +1882,12 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			dev_dbg(hub-&gt;intfdev,
 				"port %d status %04x.%04x after resume, %d\n",
 				port1, portchange, devstatus, status);
+			if (status &gt;= 0)
+				status = -ENODEV;
 		} else {
+			if (portchange &amp; USB_PORT_STAT_C_SUSPEND)
+				clear_port_feature(hub-&gt;hdev, port1,
+						USB_PORT_FEAT_C_SUSPEND);
 			/* TRSMRCY = 10 msec */
 			msleep(10);
 			if (udev)</pre><hr><pre>commit b40b7a905ce57608ca93c5032d5ab1f5508d2f11
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 19 15:12:38 2006 -0400

    [PATCH] USB hub: don't return status &gt; 0 from resume
    
    finish_device_resume() in the hub driver isn't careful always to return
    a negative code in all the error pathways.  It also doesn't return 0 in
    all the success pathways.  This patch (as724) fixes the behavior.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 875596e98e42..41531bba4321 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1790,7 +1790,10 @@ static int finish_device_resume(struct usb_device *udev)
 	 * and device drivers will know about any resume quirks.
 	 */
 	status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-	if (status &lt; 2)
+	if (status &gt;= 0)
+		status = (status == 2 ? 0 : -ENODEV);
+
+	if (status)
 		dev_dbg(&amp;udev-&gt;dev,
 			"gone after usb resume? status %d\n",
 			status);</pre><hr><pre>commit eecd11ed47c8c9bd8e7e3dff35baccae18dd0d84
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 19 14:50:15 2006 -0400

    [PATCH] usb-storage: fix race between reset and disconnect
    
    My recent patch converting usb-storage to use
    usb_reset_composite_device() added a bug, a race between reset and
    disconnect.  It was necessary to drop the private lock while executing a
    reset, and if a disconnect occurs at that time it will cause a crash.
    
    This patch (as722) fixes the problem by explicitly checking for an early
    termination after executing each command.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
index 1185acac4b21..04c3bec81201 100644
--- a/drivers/usb/storage/usb.c
+++ b/drivers/usb/storage/usb.c
@@ -373,8 +373,12 @@ static int usb_stor_control_thread(void * __us)
 		/* lock access to the state */
 		scsi_lock(host);
 
+		/* did the command already complete because of a disconnect? */
+		if (!us-&gt;srb)
+			;		/* nothing to do */
+
 		/* indicate that the command is done */
-		if (us-&gt;srb-&gt;result != DID_ABORT &lt;&lt; 16) {
+		else if (us-&gt;srb-&gt;result != DID_ABORT &lt;&lt; 16) {
 			US_DEBUGP("scsi cmd done, result=0x%x\n", 
 				   us-&gt;srb-&gt;result);
 			us-&gt;srb-&gt;scsi_done(us-&gt;srb);
@@ -836,32 +840,34 @@ static void dissociate_dev(struct us_data *us)
  * the host */
 static void quiesce_and_remove_host(struct us_data *us)
 {
+	struct Scsi_Host *host = us_to_host(us);
+
 	/* Prevent new USB transfers, stop the current command, and
 	 * interrupt a SCSI-scan or device-reset delay */
+	scsi_lock(host);
 	set_bit(US_FLIDX_DISCONNECTING, &amp;us-&gt;flags);
+	scsi_unlock(host);
 	usb_stor_stop_transport(us);
 	wake_up(&amp;us-&gt;delay_wait);
 
 	/* It doesn't matter if the SCSI-scanning thread is still running.
 	 * The thread will exit when it sees the DISCONNECTING flag. */
 
-	/* Wait for the current command to finish, then remove the host */
-	mutex_lock(&amp;us-&gt;dev_mutex);
-	mutex_unlock(&amp;us-&gt;dev_mutex);
-
 	/* queuecommand won't accept any new commands and the control
 	 * thread won't execute a previously-queued command.  If there
 	 * is such a command pending, complete it with an error. */
+	mutex_lock(&amp;us-&gt;dev_mutex);
 	if (us-&gt;srb) {
 		us-&gt;srb-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
-		scsi_lock(us_to_host(us));
+		scsi_lock(host);
 		us-&gt;srb-&gt;scsi_done(us-&gt;srb);
 		us-&gt;srb = NULL;
-		scsi_unlock(us_to_host(us));
+		scsi_unlock(host);
 	}
+	mutex_unlock(&amp;us-&gt;dev_mutex);
 
 	/* Now we own no commands so it's safe to remove the SCSI host */
-	scsi_remove_host(us_to_host(us));
+	scsi_remove_host(host);
 }
 
 /* Second stage of disconnect processing: deallocate all resources */</pre><hr><pre>commit d6b7d3b62069be60d5b13358bac8670dacdd7a81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jul 10 04:44:47 2006 -0700

    [PATCH] usb-storage: wait for URB to complete
    
    We all failed to notice that Franck's recent update to usb-storage allowed
    an URB to complete after its context data was no longer valid.  This patch
    (as746) makes the driver wait for the URB to complete whenever there's a
    timeout.
    
    Although timeouts in usb-storage are relatively uncommon, they do occur.
    Without this patch the code in 2.6.18-rc1 will fault within an interrupt
    handler, which is not nice at all.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: Greg KH &lt;greg@kroah.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index eb7188b3565c..d6acc92a4ae3 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -180,7 +180,7 @@ static int usb_stor_msg_common(struct us_data *us, int timeout)
 	if (timeleft &lt;= 0) {
 		US_DEBUGP("%s -- cancelling URB\n",
 			  timeleft == 0 ? "Timeout" : "Signal");
-		usb_unlink_urb(us-&gt;current_urb);
+		usb_kill_urb(us-&gt;current_urb);
 	}
 
 	/* return the URB status */</pre><hr><pre>commit 9ea7290902abcf22f796e9aeae4dc2e71d3f7e67
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jun 23 14:25:34 2006 -0400

    [SCSI] SCSI core: Allow QUIESCE -&gt; CANCEL sdev transition
    
    We have to be able to remove SCSI devices even when they are suspended, so
    QUIESCE -&gt; CANCEL must be a legal state transition.  This patch (as727)
    adds the transition to the state machine.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: James Bottomley &lt;James.Bottomley@SteelEye.com&gt;

diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
index 4c4add53d69b..68e0d7dbe6ce 100644
--- a/drivers/scsi/scsi_lib.c
+++ b/drivers/scsi/scsi_lib.c
@@ -2026,6 +2026,7 @@ scsi_device_set_state(struct scsi_device *sdev, enum scsi_device_state state)
 		switch (oldstate) {
 		case SDEV_CREATED:
 		case SDEV_RUNNING:
+		case SDEV_QUIESCE:
 		case SDEV_OFFLINE:
 		case SDEV_BLOCK:
 			break;</pre><hr><pre>commit bbb1747d4e44ce49acc73daa8d66e5f6bd546f1b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sun Jun 25 05:47:15 2006 -0700

    [PATCH] Allow raw_notifier callouts to unregister themselves
    
    Since raw_notifier chains don't benefit from any centralized locking
    protections, they shouldn't suffer from the associated limitations.  Under
    some circumstances it might make sense for a raw_notifier callout routine
    to unregister itself from the notifier chain.  This patch (as678) changes
    the notifier core to allow for such things.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/kernel/sys.c b/kernel/sys.c
index 90930b28d2ca..7e0927bad713 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -137,14 +137,15 @@ static int __kprobes notifier_call_chain(struct notifier_block **nl,
 		unsigned long val, void *v)
 {
 	int ret = NOTIFY_DONE;
-	struct notifier_block *nb;
+	struct notifier_block *nb, *next_nb;
 
 	nb = rcu_dereference(*nl);
 	while (nb) {
+		next_nb = rcu_dereference(nb-&gt;next);
 		ret = nb-&gt;notifier_call(nb, val, v);
 		if ((ret &amp; NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
 			break;
-		nb = rcu_dereference(nb-&gt;next);
+		nb = next_nb;
 	}
 	return ret;
 }</pre><hr><pre>commit d5681fe8110e1169902df37a8fd8bd01c2b7810e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 13 09:59:32 2006 -0400

    [PATCH] USB: unusual_devs entry for Nokia N80
    
    Here is a patch (as720) adding an unusual_devs entry for the Nokia N80
    mobile phone.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 3ec17689b81c..543244d421c1 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -133,6 +133,14 @@ UNUSUAL_DEV(  0x0420, 0x0001, 0x0100, 0x0100,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE ),
 
+/* Reported by Jiri Slaby &lt;jirislaby@gmail.com&gt; and
+ * Rene C. Castberg &lt;Rene@Castberg.org&gt; */
+UNUSUAL_DEV(  0x0421, 0x0446, 0x0100, 0x0100,
+		"Nokia",
+		"N80",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_IGNORE_RESIDUE | US_FL_FIX_CAPACITY ),
+
 /* Reported by Olaf Hering &lt;olh@suse.de&gt; from novell bug #105878 */
 UNUSUAL_DEV(  0x0424, 0x0fdc, 0x0210, 0x0210,
 		"SMSC",</pre><hr><pre>commit c5e3b741a3fec6077a480aa65ded29d79ded8898
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 5 12:28:57 2006 -0400

    [PATCH] UHCI: Improve FSBR-off timing
    
    This patch (as707) improves the FSBR operation in uhci-hcd by turning it
    off more quickly when it isn't needed.  FSBR puts a noticeable load on a
    computer's PCI bus, so it should be disabled as soon as possible when it
    isn't in use.  The patch leaves it running for only 10 ms after the last
    URB stops using it, on the theory that this should be long enough for a
    driver to submit another URB if it wants keep FSBR going.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 025b969f95e8..7b48567622ef 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -497,9 +497,9 @@ static int uhci_start(struct usb_hcd *hcd)
 	hcd-&gt;uses_new_polling = 1;
 
 	spin_lock_init(&amp;uhci-&gt;lock);
-
+	setup_timer(&amp;uhci-&gt;fsbr_timer, uhci_fsbr_timeout,
+			(unsigned long) uhci);
 	INIT_LIST_HEAD(&amp;uhci-&gt;idle_qh_list);
-
 	init_waitqueue_head(&amp;uhci-&gt;waitqh);
 
 	if (DEBUG_CONFIGURED) {
@@ -675,6 +675,7 @@ static void uhci_stop(struct usb_hcd *hcd)
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
+	del_timer_sync(&amp;uhci-&gt;fsbr_timer);
 	release_uhci(uhci);
 }
 
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 619d704f4e8f..108e3de2dc26 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -86,7 +86,7 @@
 
 /* When no queues need Full-Speed Bandwidth Reclamation,
  * delay this long before turning FSBR off */
-#define FSBR_OFF_DELAY		msecs_to_jiffies(400)
+#define FSBR_OFF_DELAY		msecs_to_jiffies(10)
 
 /* If a queue hasn't advanced after this much time, assume it is stuck */
 #define QH_WAIT_TIMEOUT		msecs_to_jiffies(200)
@@ -382,8 +382,6 @@ struct uhci_hcd {
 	__le32 *frame;
 	void **frame_cpu;		/* CPU's frame list */
 
-	unsigned long fsbr_jiffies;	/* Time when FSBR was last wanted */
-
 	enum uhci_rh_state rh_state;
 	unsigned long auto_stop_time;		/* When to AUTO_STOP */
 
@@ -400,6 +398,10 @@ struct uhci_hcd {
 						   need to be polled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
 	unsigned int fsbr_is_on:1;		/* FSBR is turned on */
+	unsigned int fsbr_is_wanted:1;		/* Does any URB want FSBR? */
+	unsigned int fsbr_expiring:1;		/* FSBR is timing out */
+
+	struct timer_list fsbr_timer;		/* For turning off FBSR */
 
 	/* Support for port suspend/resume/reset */
 	unsigned long port_c_suspend;		/* Bit-arrays of ports */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index b173d914d748..c9d72ac0a1d7 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -64,16 +64,30 @@ static void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)
 		urbp-&gt;fsbr = 1;
 }
 
-static void uhci_qh_wants_fsbr(struct uhci_hcd *uhci, struct uhci_qh *qh)
+static void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci, struct urb_priv *urbp)
 {
-	struct urb_priv *urbp =
-			list_entry(qh-&gt;queue.next, struct urb_priv, node);
-
 	if (urbp-&gt;fsbr) {
-		uhci-&gt;fsbr_jiffies = jiffies;
+		uhci-&gt;fsbr_is_wanted = 1;
 		if (!uhci-&gt;fsbr_is_on)
 			uhci_fsbr_on(uhci);
+		else if (uhci-&gt;fsbr_expiring) {
+			uhci-&gt;fsbr_expiring = 0;
+			del_timer(&amp;uhci-&gt;fsbr_timer);
+		}
+	}
+}
+
+static void uhci_fsbr_timeout(unsigned long _uhci)
+{
+	struct uhci_hcd *uhci = (struct uhci_hcd *) _uhci;
+	unsigned long flags;
+
+	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
+	if (uhci-&gt;fsbr_expiring) {
+		uhci-&gt;fsbr_expiring = 0;
+		uhci_fsbr_off(uhci);
 	}
+	spin_unlock_irqrestore(&amp;uhci-&gt;lock, flags);
 }
 
 
@@ -287,7 +301,7 @@ static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC) {
 		ret = (uhci-&gt;frame_number + uhci-&gt;is_stopped !=
 				qh-&gt;unlink_frame);
-		return ret;
+		goto done;
 	}
 
 	/* If the URB isn't first on its queue, adjust the link pointer
@@ -304,24 +318,26 @@ static int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,
 		td = list_entry(urbp-&gt;td_list.prev, struct uhci_td,
 				list);
 		ptd-&gt;link = td-&gt;link;
-		return ret;
+		goto done;
 	}
 
 	/* If the QH element pointer is UHCI_PTR_TERM then then currently
 	 * executing URB has already been unlinked, so this one isn't it. */
 	if (qh_element(qh) == UHCI_PTR_TERM)
-		return ret;
+		goto done;
 	qh-&gt;element = UHCI_PTR_TERM;
 
 	/* Control pipes have to worry about toggles */
 	if (qh-&gt;type == USB_ENDPOINT_XFER_CONTROL)
-		return ret;
+		goto done;
 
 	/* Save the next toggle value */
 	WARN_ON(list_empty(&amp;urbp-&gt;td_list));
 	td = list_entry(urbp-&gt;td_list.next, struct uhci_td, list);
 	qh-&gt;needs_fixup = 1;
 	qh-&gt;initial_toggle = uhci_toggle(td_token(td));
+
+done:
 	return ret;
 }
 
@@ -1175,7 +1191,7 @@ static int uhci_urb_enqueue(struct usb_hcd *hcd,
 	 * queue isn't stopped. */
 	if (qh-&gt;queue.next == &amp;urbp-&gt;node &amp;&amp; !qh-&gt;is_stopped) {
 		uhci_activate_qh(uhci, qh);
-		uhci_qh_wants_fsbr(uhci, qh);
+		uhci_urbp_wants_fsbr(uhci, urbp);
 	}
 	goto done;
 
@@ -1404,7 +1420,7 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 	unsigned status;
 
 	if (qh-&gt;type == USB_ENDPOINT_XFER_ISOC)
-		return ret;
+		goto done;
 
 	/* Treat an UNLINKING queue as though it hasn't advanced.
 	 * This is okay because reactivation will treat it as though
@@ -1427,21 +1443,24 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 			/* We're okay, the queue has advanced */
 			qh-&gt;wait_expired = 0;
 			qh-&gt;advance_jiffies = jiffies;
-			return ret;
+			goto done;
 		}
 		ret = 0;
 	}
 
 	/* The queue hasn't advanced; check for timeout */
-	if (!qh-&gt;wait_expired &amp;&amp; time_after(jiffies,
-			qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
+	if (qh-&gt;wait_expired)
+		goto done;
+
+	if (time_after(jiffies, qh-&gt;advance_jiffies + QH_WAIT_TIMEOUT)) {
 
 		/* Detect the Intel bug and work around it */
 		if (qh-&gt;post_td &amp;&amp; qh_element(qh) ==
 				cpu_to_le32(qh-&gt;post_td-&gt;dma_handle)) {
 			qh-&gt;element = qh-&gt;post_td-&gt;link;
 			qh-&gt;advance_jiffies = jiffies;
-			return 1;
+			ret = 1;
+			goto done;
 		}
 
 		qh-&gt;wait_expired = 1;
@@ -1452,7 +1471,14 @@ static int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)
 		 * starts moving again. */
 		if (urbp &amp;&amp; urbp-&gt;fsbr &amp;&amp; !(status &amp; TD_CTRL_IOC))
 			uhci_unlink_qh(uhci, qh);
+
+	} else {
+		/* Unmoving but not-yet-expired queues keep FSBR alive */
+		if (urbp)
+			uhci_urbp_wants_fsbr(uhci, urbp);
 	}
+
+done:
 	return ret;
 }
 
@@ -1472,6 +1498,7 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 	uhci-&gt;scan_in_progress = 1;
 rescan:
 	uhci-&gt;need_rescan = 0;
+	uhci-&gt;fsbr_is_wanted = 0;
 
 	uhci_clear_next_interrupt(uhci);
 	uhci_get_current_frame_number(uhci);
@@ -1487,8 +1514,10 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 
 			if (uhci_advance_check(uhci, qh)) {
 				uhci_scan_qh(uhci, qh, regs);
-				if (qh-&gt;state == QH_STATE_ACTIVE)
-					uhci_qh_wants_fsbr(uhci, qh);
+				if (qh-&gt;state == QH_STATE_ACTIVE) {
+					uhci_urbp_wants_fsbr(uhci,
+	list_entry(qh-&gt;queue.next, struct urb_priv, node));
+				}
 			}
 		}
 	}
@@ -1498,9 +1527,11 @@ static void uhci_scan_schedule(struct uhci_hcd *uhci, struct pt_regs *regs)
 		goto rescan;
 	uhci-&gt;scan_in_progress = 0;
 
-	if (uhci-&gt;fsbr_is_on &amp;&amp; time_after(jiffies,
-			uhci-&gt;fsbr_jiffies + FSBR_OFF_DELAY))
-		uhci_fsbr_off(uhci);
+	if (uhci-&gt;fsbr_is_on &amp;&amp; !uhci-&gt;fsbr_is_wanted &amp;&amp;
+			!uhci-&gt;fsbr_expiring) {
+		uhci-&gt;fsbr_expiring = 1;
+		mod_timer(&amp;uhci-&gt;fsbr_timer, jiffies + FSBR_OFF_DELAY);
+	}
 
 	if (list_empty(&amp;uhci-&gt;skel_unlink_qh-&gt;node))
 		uhci_clear_next_interrupt(uhci);</pre><hr><pre>commit e323de46e83b6df2f330651907ac823f8d53308a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 5 12:21:30 2006 -0400

    [PATCH] UHCI: remove hc_inaccessible flag
    
    This patch (as706) removes the private hc_inaccessible flag from
    uhci-hcd.  It's not needed because it conveys exactly the same
    information as the generic HCD_FLAG_HW_ACCESSIBLE bit.
    
    In its place goes a new flag recording whether the controller is dead.
    The new code allows a complete device reset to resurrect a dead
    controller (although usbcore doesn't yet implement such a facility).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index dc9ed29c6175..025b969f95e8 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -110,17 +110,23 @@ static void finish_reset(struct uhci_hcd *uhci)
 	uhci-&gt;is_stopped = UHCI_IS_STOPPED;
 	uhci_to_hcd(uhci)-&gt;state = HC_STATE_HALT;
 	uhci_to_hcd(uhci)-&gt;poll_rh = 0;
+
+	uhci-&gt;dead = 0;		/* Full reset resurrects the controller */
 }
 
 /*
  * Last rites for a defunct/nonfunctional controller
  * or one we don't want to use any more.
  */
-static void hc_died(struct uhci_hcd *uhci)
+static void uhci_hc_died(struct uhci_hcd *uhci)
 {
+	uhci_get_current_frame_number(uhci);
 	uhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci-&gt;io_addr);
 	finish_reset(uhci);
-	uhci-&gt;hc_inaccessible = 1;
+	uhci-&gt;dead = 1;
+
+	/* The current frame may already be partway finished */
+	++uhci-&gt;frame_number;
 }
 
 /*
@@ -234,7 +240,7 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(1);
 		spin_lock_irq(&amp;uhci-&gt;lock);
-		if (uhci-&gt;hc_inaccessible)	/* Died */
+		if (uhci-&gt;dead)
 			return;
 	}
 	if (!(inw(uhci-&gt;io_addr + USBSTS) &amp; USBSTS_HCH))
@@ -287,7 +293,7 @@ __acquires(uhci-&gt;lock)
 		spin_unlock_irq(&amp;uhci-&gt;lock);
 		msleep(20);
 		spin_lock_irq(&amp;uhci-&gt;lock);
-		if (uhci-&gt;hc_inaccessible)	/* Died */
+		if (uhci-&gt;dead)
 			return;
 
 		/* End Global Resume and wait for EOP to be sent */
@@ -339,7 +345,7 @@ static irqreturn_t uhci_irq(struct usb_hcd *hcd, struct pt_regs *regs)
 							errbuf, ERRBUF_LEN);
 					lprintk(errbuf);
 				}
-				hc_died(uhci);
+				uhci_hc_died(uhci);
 
 				/* Force a callback in case there are
 				 * pending unlinks */
@@ -462,7 +468,7 @@ static void uhci_shutdown(struct pci_dev *pdev)
 {
 	struct usb_hcd *hcd = (struct usb_hcd *) pci_get_drvdata(pdev);
 
-	hc_died(hcd_to_uhci(hcd));
+	uhci_hc_died(hcd_to_uhci(hcd));
 }
 
 /*
@@ -664,8 +670,8 @@ static void uhci_stop(struct usb_hcd *hcd)
 	struct uhci_hcd *uhci = hcd_to_uhci(hcd);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (!uhci-&gt;hc_inaccessible)
-		hc_died(uhci);
+	if (test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) &amp;&amp; !uhci-&gt;dead)
+		uhci_hc_died(uhci);
 	uhci_scan_schedule(uhci, NULL);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 
@@ -681,7 +687,7 @@ static int uhci_rh_suspend(struct usb_hcd *hcd)
 	spin_lock_irq(&amp;uhci-&gt;lock);
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags))
 		rc = -ESHUTDOWN;
-	else if (!uhci-&gt;hc_inaccessible)
+	else if (!uhci-&gt;dead)
 		suspend_rh(uhci, UHCI_RH_SUSPENDED);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;
@@ -696,7 +702,7 @@ static int uhci_rh_resume(struct usb_hcd *hcd)
 	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags)) {
 		dev_warn(&amp;hcd-&gt;self.root_hub-&gt;dev, "HC isn't running!\n");
 		rc = -ESHUTDOWN;
-	} else if (!uhci-&gt;hc_inaccessible)
+	} else if (!uhci-&gt;dead)
 		wakeup_rh(uhci);
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;
@@ -710,8 +716,8 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
 	spin_lock_irq(&amp;uhci-&gt;lock);
-	if (uhci-&gt;hc_inaccessible)	/* Dead or already suspended */
-		goto done;
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
+		goto done_okay;		/* Already suspended or dead */
 
 	if (uhci-&gt;rh_state &gt; UHCI_RH_SUSPENDED) {
 		dev_warn(uhci_dev(uhci), "Root hub isn't suspended!\n");
@@ -724,12 +730,12 @@ static int uhci_suspend(struct usb_hcd *hcd, pm_message_t message)
 	 */
 	pci_write_config_word(to_pci_dev(uhci_dev(uhci)), USBLEGSUP, 0);
 	mb();
-	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-	uhci-&gt;hc_inaccessible = 1;
 	hcd-&gt;poll_rh = 0;
 
 	/* FIXME: Enable non-PME# remote wakeup? */
 
+done_okay:
+	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 done:
 	spin_unlock_irq(&amp;uhci-&gt;lock);
 	return rc;
@@ -742,25 +748,22 @@ static int uhci_resume(struct usb_hcd *hcd)
 	dev_dbg(uhci_dev(uhci), "%s\n", __FUNCTION__);
 
 	/* Since we aren't in D3 any more, it's safe to set this flag
-	 * even if the controller was dead.  It might not even be dead
-	 * any more, if the firmware or quirks code has reset it.
+	 * even if the controller was dead.
 	 */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 	mb();
 
-	if (uhci-&gt;rh_state == UHCI_RH_RESET)	/* Dead */
-		return 0;
-
 	spin_lock_irq(&amp;uhci-&gt;lock);
 
 	/* FIXME: Disable non-PME# remote wakeup? */
 
-	uhci-&gt;hc_inaccessible = 0;
-
-	/* The BIOS may have changed the controller settings during a
-	 * system wakeup.  Check it and reconfigure to avoid problems.
+	/* The firmware or a boot kernel may have changed the controller
+	 * settings during a system wakeup.  Check it and reconfigure
+	 * to avoid problems.
 	 */
 	check_and_reset_hc(uhci);
+
+	/* If the controller was dead before, it's back alive now */
 	configure_hc(uhci);
 
 	if (uhci-&gt;rh_state == UHCI_RH_RESET) {
diff --git a/drivers/usb/host/uhci-hcd.h b/drivers/usb/host/uhci-hcd.h
index 469b4268b850..619d704f4e8f 100644
--- a/drivers/usb/host/uhci-hcd.h
+++ b/drivers/usb/host/uhci-hcd.h
@@ -395,7 +395,7 @@ struct uhci_hcd {
 
 	unsigned int scan_in_progress:1;	/* Schedule scan is running */
 	unsigned int need_rescan:1;		/* Redo the schedule scan */
-	unsigned int hc_inaccessible:1;		/* HC is suspended or dead */
+	unsigned int dead:1;			/* Controller has died */
 	unsigned int working_RD:1;		/* Suspended root hub doesn't
 						   need to be polled */
 	unsigned int is_initialized:1;		/* Data structure is usable */
diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index f53c116e0dfd..c545ef92fe29 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -171,7 +171,7 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);
 
 	uhci_scan_schedule(uhci, NULL);
-	if (uhci-&gt;hc_inaccessible)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
 		goto done;
 	uhci_check_ports(uhci);
 
@@ -227,7 +227,7 @@ static int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 	u16 wPortChange, wPortStatus;
 	unsigned long flags;
 
-	if (uhci-&gt;hc_inaccessible)
+	if (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags) || uhci-&gt;dead)
 		return -ETIMEDOUT;
 
 	spin_lock_irqsave(&amp;uhci-&gt;lock, flags);</pre><hr><pre>commit ae671813affd947d2f21ff8e3cd329e466ee85b2
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jun 6 15:19:17 2006 -0400

    [PATCH] usb-storage: unusual_devs entry for Nikon DSC D70s
    
    This patch (as704) adds an unusual_devs entry for the Nikon DSC D70s,
    which uses a different Product ID from the D70.  It also moves the entry
    for the DSC E2000 up in the list, to preserve the numerical ordering.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index 9f72000a0064..3ec17689b81c 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -216,6 +216,14 @@ UNUSUAL_DEV(  0x04a4, 0x0004, 0x0001, 0x0001,
 		"DVD-CAM DZ-MV100A Camcorder",
 		US_SC_SCSI, US_PR_CB, NULL, US_FL_SINGLE_LUN),
 
+/* Patch for Nikon coolpix 2000
+ * Submitted by Fabien Cosse &lt;fabien.cosse@wanadoo.fr&gt;*/
+UNUSUAL_DEV(  0x04b0, 0x0301, 0x0010, 0x0010,
+		"NIKON",
+		"NIKON DSC E2000",
+		US_SC_DEVICE, US_PR_DEVICE,NULL,
+		US_FL_NOT_LOCKABLE ),
+
 /* Reported by Andreas Bockhold &lt;andreas@bockionline.de&gt; */
 UNUSUAL_DEV(  0x04b0, 0x0405, 0x0100, 0x0100,
 		"NIKON",
@@ -223,13 +231,12 @@ UNUSUAL_DEV(  0x04b0, 0x0405, 0x0100, 0x0100,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_FIX_CAPACITY),
 
-/* Patch for Nikon coolpix 2000
- * Submitted by Fabien Cosse &lt;fabien.cosse@wanadoo.fr&gt;*/
-UNUSUAL_DEV(  0x04b0, 0x0301, 0x0010, 0x0010,
+/* Reported by Jamie Kitson &lt;jamie@staberinde.fsnet.co.uk&gt; */
+UNUSUAL_DEV(  0x04b0, 0x040d, 0x0100, 0x0100,
 		"NIKON",
-		"NIKON DSC E2000",
-		US_SC_DEVICE, US_PR_DEVICE,NULL,
-		US_FL_NOT_LOCKABLE ),
+		"NIKON DSC D70s",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_FIX_CAPACITY),
 
 /* BENQ DC5330
  * Reported by Manuel Fombuena &lt;mfombuena@ya.com&gt; and</pre>
    <div class="pagination">
        <a href='2_123.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><span>[124]</span><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_125.html'>Next&gt;&gt;</a>
    <div>
</body>
