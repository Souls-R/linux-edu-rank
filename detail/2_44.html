<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_43.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><span>[44]</span><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_45.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 0d00dc2611abbe6ad244d50569c2ee82ce42846c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 26 13:09:53 2012 -0400

    USB: Fix race condition when removing host controllers
    
    This patch (as1607) fixes a race that can occur if a USB host
    controller is removed while a process is reading the
    /sys/kernel/debug/usb/devices file.
    
    The usb_device_read() routine uses the bus-&gt;root_hub pointer to
    determine whether or not the root hub is registered.  The is not a
    valid test, because the pointer is set before the root hub gets
    registered and remains set even after the root hub is unregistered and
    deallocated.  As a result, usb_device_read() or usb_device_dump() can
    access freed memory, causing an oops.
    
    The patch changes the test to use the hcd-&gt;rh_registered flag, which
    does get set and cleared at the appropriate times.  It also makes sure
    to hold the usb_bus_list_lock mutex while setting the flag, so that
    usb_device_read() will become aware of new root hubs as soon as they
    are registered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Don Zickus &lt;dzickus@redhat.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c
index d95696584762..3440812b4a84 100644
--- a/drivers/usb/core/devices.c
+++ b/drivers/usb/core/devices.c
@@ -624,7 +624,7 @@ static ssize_t usb_device_read(struct file *file, char __user *buf,
 	/* print devices for all busses */
 	list_for_each_entry(bus, &amp;usb_bus_list, bus_list) {
 		/* recurse through all children of the root hub */
-		if (!bus-&gt;root_hub)
+		if (!bus_to_hcd(bus)-&gt;rh_registered)
 			continue;
 		usb_lock_device(bus-&gt;root_hub);
 		ret = usb_device_dump(&amp;buf, &amp;nbytes, &amp;skip_bytes, ppos,
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index bc84106ac057..75ba2091f9b4 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1011,10 +1011,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 	if (retval) {
 		dev_err (parent_dev, "can't register root hub for %s, %d\n",
 				dev_name(&amp;usb_dev-&gt;dev), retval);
-	}
-	mutex_unlock(&amp;usb_bus_list_lock);
-
-	if (retval == 0) {
+	} else {
 		spin_lock_irq (&amp;hcd_root_hub_lock);
 		hcd-&gt;rh_registered = 1;
 		spin_unlock_irq (&amp;hcd_root_hub_lock);
@@ -1023,6 +1020,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 		if (HCD_DEAD(hcd))
 			usb_hc_died (hcd);	/* This time clean up */
 	}
+	mutex_unlock(&amp;usb_bus_list_lock);
 
 	return retval;
 }</pre><hr><pre>commit 0a2314035cab62cafc38ea11ec5b6f95cf347b38
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 26 13:09:53 2012 -0400

    USB: Fix race condition when removing host controllers
    
    This patch (as1607) fixes a race that can occur if a USB host
    controller is removed while a process is reading the
    /sys/kernel/debug/usb/devices file.
    
    The usb_device_read() routine uses the bus-&gt;root_hub pointer to
    determine whether or not the root hub is registered.  The is not a
    valid test, because the pointer is set before the root hub gets
    registered and remains set even after the root hub is unregistered and
    deallocated.  As a result, usb_device_read() or usb_device_dump() can
    access freed memory, causing an oops.
    
    The patch changes the test to use the hcd-&gt;rh_registered flag, which
    does get set and cleared at the appropriate times.  It also makes sure
    to hold the usb_bus_list_lock mutex while setting the flag, so that
    usb_device_read() will become aware of new root hubs as soon as they
    are registered.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Don Zickus &lt;dzickus@redhat.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c
index f4ead1296820..f460de31acee 100644
--- a/drivers/usb/core/devices.c
+++ b/drivers/usb/core/devices.c
@@ -623,7 +623,7 @@ static ssize_t usb_device_read(struct file *file, char __user *buf,
 	/* print devices for all busses */
 	list_for_each_entry(bus, &amp;usb_bus_list, bus_list) {
 		/* recurse through all children of the root hub */
-		if (!bus-&gt;root_hub)
+		if (!bus_to_hcd(bus)-&gt;rh_registered)
 			continue;
 		usb_lock_device(bus-&gt;root_hub);
 		ret = usb_device_dump(&amp;buf, &amp;nbytes, &amp;skip_bytes, ppos,
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 35b52f6e1c5e..1e741bca0265 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -1011,10 +1011,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 	if (retval) {
 		dev_err (parent_dev, "can't register root hub for %s, %d\n",
 				dev_name(&amp;usb_dev-&gt;dev), retval);
-	}
-	mutex_unlock(&amp;usb_bus_list_lock);
-
-	if (retval == 0) {
+	} else {
 		spin_lock_irq (&amp;hcd_root_hub_lock);
 		hcd-&gt;rh_registered = 1;
 		spin_unlock_irq (&amp;hcd_root_hub_lock);
@@ -1023,6 +1020,7 @@ static int register_root_hub(struct usb_hcd *hcd)
 		if (HCD_DEAD(hcd))
 			usb_hc_died (hcd);	/* This time clean up */
 	}
+	mutex_unlock(&amp;usb_bus_list_lock);
 
 	return retval;
 }</pre><hr><pre>commit d16ba48774913d244c7eb894d28d8ae2c019a827
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 19 17:02:29 2012 -0400

    USB: EHCI: convert warning messages to debug-level
    
    This patch (as1606) converts two warning messages in the ehci-hcd
    driver to debug messages, and adds a little extra information to each.
    
    The log messages occur when an EHCI controller takes too long (more
    than 20 ms) to turn its async or periodic schedule on or off.  If this
    happens at all, it's liable to happen quite often and there's no point
    spamming the system log with these warnings.  Furthermore, there's
    nothing much we can do about it when the problem happens.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Thomas Voegtle &lt;tv@lio96.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt; # [3.6]
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index eb896a2c8f2e..20dbdcbe9b0f 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -118,7 +118,8 @@ static void ehci_poll_ASS(struct ehci_hcd *ehci)
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);
 			return;
 		}
-		ehci_warn(ehci, "Waited too long for the async schedule status, giving up\n");
+		ehci_dbg(ehci, "Waited too long for the async schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
 	ehci-&gt;ASS_poll_count = 0;
 
@@ -163,7 +164,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 			ehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);
 			return;
 		}
-		ehci_warn(ehci, "Waited too long for the periodic schedule status, giving up\n");
+		ehci_dbg(ehci, "Waited too long for the periodic schedule status (%x/%x), giving up\n",
+				want, actual);
 	}
 	ehci-&gt;PSS_poll_count = 0;
 </pre><hr><pre>commit 17dcfc9bd3dfb699e00205ec9d431b5a5cb00b34
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 19 17:00:55 2012 -0400

    USB: EHCI: remove useless test
    
    This patch (as1605) removes a useless test from the EHCI debugfs
    code.  There's no point checking whether p.qh is non-NULL; we already
    know it is and in any case it gets dereferenced aerlier in the
    function.
    
    The useless test was identified by smatch.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Fengguang Wu &lt;fengguang.wu@intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-dbg.c b/drivers/usb/host/ehci-dbg.c
index f0c00de035ef..1599806e3d47 100644
--- a/drivers/usb/host/ehci-dbg.c
+++ b/drivers/usb/host/ehci-dbg.c
@@ -653,10 +653,8 @@ static ssize_t fill_periodic_buffer(struct debug_buffer *buf)
 						seen [seen_count++].qh = p.qh;
 				} else
 					temp = 0;
-				if (p.qh) {
-					tag = Q_NEXT_TYPE(ehci, hw-&gt;hw_next);
-					p = p.qh-&gt;qh_next;
-				}
+				tag = Q_NEXT_TYPE(ehci, hw-&gt;hw_next);
+				p = p.qh-&gt;qh_next;
 				break;
 			case Q_TYPE_FSTN:
 				temp = scnprintf (next, size,</pre><hr><pre>commit 88d26136a256576e444db312179e17af6dd0ea87
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 19 21:59:02 2012 +0200

    PM: Prevent runtime suspend during system resume
    
    This patch (as1591) moves the pm_runtime_get_noresume() and
    pm_runtime_put_sync() calls from __device_suspend() and
    device_resume() to device_prepare() and device_complete() in the PM
    core.
    
    The reason for doing this is to make sure that parent devices remain
    at full power (i.e., don't go into runtime suspend) while their
    children are being resumed from a system sleep.
    
    The PCI core already contained equivalent code to serve the same
    purpose.  The patch removes the duplicated code, since it is no longer
    needed.  One of the comments from the PCI core gets moved into the PM
    core, and a second comment is added to explain whe the _get_noresume
    and _put_sync calls are present.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 2700f2e4066f..077b9756fd8f 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -565,7 +565,6 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 	pm_callback_t callback = NULL;
 	char *info = NULL;
 	int error = 0;
-	bool put = false;
 
 	TRACE_DEVICE(dev);
 	TRACE_RESUME(0);
@@ -583,7 +582,6 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 		goto Unlock;
 
 	pm_runtime_enable(dev);
-	put = true;
 
 	if (dev-&gt;pm_domain) {
 		info = "power domain ";
@@ -636,9 +634,6 @@ static int device_resume(struct device *dev, pm_message_t state, bool async)
 
 	TRACE_RESUME(error);
 
-	if (put)
-		pm_runtime_put_sync(dev);
-
 	return error;
 }
 
@@ -749,6 +744,8 @@ static void device_complete(struct device *dev, pm_message_t state)
 	}
 
 	device_unlock(dev);
+
+	pm_runtime_put_sync(dev);
 }
 
 /**
@@ -1043,12 +1040,16 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
 	if (async_error)
 		goto Complete;
 
-	pm_runtime_get_noresume(dev);
+	/*
+	 * If a device configured to wake up the system from sleep states
+	 * has been suspended at run time and there's a resume request pending
+	 * for it, this is equivalent to the device signaling wakeup, so the
+	 * system suspend operation should be aborted.
+	 */
 	if (pm_runtime_barrier(dev) &amp;&amp; device_may_wakeup(dev))
 		pm_wakeup_event(dev, 0);
 
 	if (pm_wakeup_pending()) {
-		pm_runtime_put_sync(dev);
 		async_error = -EBUSY;
 		goto Complete;
 	}
@@ -1111,12 +1112,10 @@ static int __device_suspend(struct device *dev, pm_message_t state, bool async)
  Complete:
 	complete_all(&amp;dev-&gt;power.completion);
 
-	if (error) {
-		pm_runtime_put_sync(dev);
+	if (error)
 		async_error = error;
-	} else if (dev-&gt;power.is_suspended) {
+	else if (dev-&gt;power.is_suspended)
 		__pm_runtime_disable(dev, false);
-	}
 
 	return error;
 }
@@ -1209,6 +1208,14 @@ static int device_prepare(struct device *dev, pm_message_t state)
 	char *info = NULL;
 	int error = 0;
 
+	/*
+	 * If a device's parent goes into runtime suspend at the wrong time,
+	 * it won't be possible to resume the device.  To prevent this we
+	 * block runtime suspend here, during the prepare phase, and allow
+	 * it again during the complete phase.
+	 */
+	pm_runtime_get_noresume(dev);
+
 	device_lock(dev);
 
 	dev-&gt;power.wakeup_path = device_may_wakeup(dev);
diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c
index 185be3703343..51cd90bcdd4c 100644
--- a/drivers/pci/pci-driver.c
+++ b/drivers/pci/pci-driver.c
@@ -623,21 +623,6 @@ static int pci_pm_prepare(struct device *dev)
 	struct device_driver *drv = dev-&gt;driver;
 	int error = 0;
 
-	/*
-	 * If a PCI device configured to wake up the system from sleep states
-	 * has been suspended at run time and there's a resume request pending
-	 * for it, this is equivalent to the device signaling wakeup, so the
-	 * system suspend operation should be aborted.
-	 */
-	pm_runtime_get_noresume(dev);
-	if (pm_runtime_barrier(dev) &amp;&amp; device_may_wakeup(dev))
-		pm_wakeup_event(dev, 0);
-
-	if (pm_wakeup_pending()) {
-		pm_runtime_put_sync(dev);
-		return -EBUSY;
-	}
-
 	/*
 	 * PCI devices suspended at run time need to be resumed at this
 	 * point, because in general it is necessary to reconfigure them for
@@ -661,8 +646,6 @@ static void pci_pm_complete(struct device *dev)
 
 	if (drv &amp;&amp; drv-&gt;pm &amp;&amp; drv-&gt;pm-&gt;complete)
 		drv-&gt;pm-&gt;complete(dev);
-
-	pm_runtime_put_sync(dev);
 }
 
 #else /* !CONFIG_PM_SLEEP */</pre><hr><pre>commit 92fc7a8b0f20bdb243c706daf42658e8e0cd2ef0
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 4 10:41:02 2012 -0400

    USB: add device quirk for Joss Optical touchboard
    
    This patch (as1604) adds a CONFIG_INTF_STRINGS quirk for the Joss
    infrared touchboard device.  The device doesn't like to be asked for
    its interface strings.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: adam ? &lt;adam3337@wp.pl&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index f15501f4c585..e77a8e8eaa23 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -71,6 +71,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x04b4, 0x0526), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
 
+	/* Microchip Joss Optical infrared touchboard device */
+	{ USB_DEVICE(0x04d8, 0x000c), .driver_info =
+			USB_QUIRK_CONFIG_INTF_STRINGS },
+
 	/* Samsung Android phone modem - ID conflict with SPH-I500 */
 	{ USB_DEVICE(0x04e8, 0x6601), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },</pre><hr><pre>commit d0d860758bd350206242962a223858bd01cd8a93
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 20 16:12:47 2012 -0400

    usb: gadget: dummy-hcd: remember to update driver pointer
    
    This patch (as1599) fixes dummy-hcd to make it update the appropriate
    driver pointer when a new gadget driver is bound or unbound.  Without
    this change, the gadget driver's name doesn't appear in dev_printk
    output.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/dummy_hcd.c b/drivers/usb/gadget/dummy_hcd.c
index b799106027ad..91916f693ff7 100644
--- a/drivers/usb/gadget/dummy_hcd.c
+++ b/drivers/usb/gadget/dummy_hcd.c
@@ -909,6 +909,7 @@ static int dummy_udc_start(struct usb_gadget *g,
 	dum-&gt;devstatus = 0;
 
 	dum-&gt;driver = driver;
+	dum-&gt;gadget.dev.driver = &amp;driver-&gt;driver;
 	dev_dbg(udc_dev(dum), "binding gadget driver '%s'\n",
 			driver-&gt;driver.name);
 	return 0;
@@ -923,6 +924,7 @@ static int dummy_udc_stop(struct usb_gadget *g,
 	dev_dbg(udc_dev(dum), "unregister gadget driver '%s'\n",
 			driver-&gt;driver.name);
 
+	dum-&gt;gadget.dev.driver = NULL;
 	dum-&gt;driver = NULL;
 
 	return 0;</pre><hr><pre>commit 67ddbb3e6568fb1820b2cc45b00c50702b114801
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 23 10:51:55 2012 -0400

    HID: add NOGET quirk for Eaton Ellipse MAX UPS
    
    This patch (as1603) adds a NOGET quirk for the Eaton Ellipse MAX UPS
    device.  (The USB IDs were already present in hid-ids.h, apparently
    under a different name.)
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Laurent Bigonville &lt;l.bigonville@edpnet.be&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c
index 903eef3d3e10..991e85c7325c 100644
--- a/drivers/hid/usbhid/hid-quirks.c
+++ b/drivers/hid/usbhid/hid-quirks.c
@@ -70,6 +70,7 @@ static const struct hid_blacklist {
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_AXIS_295, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_DMI, USB_DEVICE_ID_DMI_ENC, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ELO, USB_DEVICE_ID_ELO_TS2700, HID_QUIRK_NOGET },
+	{ USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_PIXART, USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_PIXART, USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN1, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_PIXART, USB_DEVICE_ID_PIXART_OPTICAL_TOUCH_SCREEN2, HID_QUIRK_NO_INIT_REPORTS },</pre><hr><pre>commit eb055fd0560b9835e9e1a956aa6a83c51a735801
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:09:01 2012 -0400

    HID: usbhid: fix error paths in suspend
    
    This patch (as1597) fixes some of the error paths in usbhid's suspend
    routine.  The driver was not careful to restart everything that might
    have been stopped, in cases where a suspend failed.
    
    For example, once the HID_SUSPENDED flag is set, an output report
    submission would not restart the corresponding URB queue.  If a
    suspend fails, it's therefore necessary to check whether the queues
    need to be restarted.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 4309c03038f6..dedd8e4e5c6d 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -993,9 +993,10 @@ static int usbhid_output_raw_report(struct hid_device *hid, __u8 *buf, size_t co
 
 static void usbhid_restart_queues(struct usbhid_device *usbhid)
 {
-	if (usbhid-&gt;urbout)
+	if (usbhid-&gt;urbout &amp;&amp; !test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
 		usbhid_restart_out_queue(usbhid);
-	usbhid_restart_ctrl_queue(usbhid);
+	if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
+		usbhid_restart_ctrl_queue(usbhid);
 }
 
 static void hid_free_buffers(struct usb_device *dev, struct hid_device *hid)
@@ -1462,11 +1463,38 @@ void usbhid_put_power(struct hid_device *hid)
 
 
 #ifdef CONFIG_PM
+static int hid_resume_common(struct hid_device *hid, bool driver_suspended)
+{
+	struct usbhid_device *usbhid = hid-&gt;driver_data;
+	int status;
+
+	spin_lock_irq(&amp;usbhid-&gt;lock);
+	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
+	usbhid_mark_busy(usbhid);
+
+	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl) ||
+			test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl))
+		schedule_work(&amp;usbhid-&gt;reset_work);
+	usbhid-&gt;retry_delay = 0;
+
+	usbhid_restart_queues(usbhid);
+	spin_unlock_irq(&amp;usbhid-&gt;lock);
+
+	status = hid_start_in(hid);
+	if (status &lt; 0)
+		hid_io_error(hid);
+
+	if (driver_suspended &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;resume)
+		status = hid-&gt;driver-&gt;resume(hid);
+	return status;
+}
+
 static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 {
 	struct hid_device *hid = usb_get_intfdata(intf);
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
+	bool driver_suspended = false;
 
 	if (PMSG_IS_AUTO(message)) {
 		spin_lock_irq(&amp;usbhid-&gt;lock);	/* Sync with error handler */
@@ -1482,8 +1510,9 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 			if (hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;suspend) {
 				status = hid-&gt;driver-&gt;suspend(hid, message);
 				if (status &lt; 0)
-					return status;
+					goto failed;
 			}
+			driver_suspended = true;
 		} else {
 			usbhid_mark_busy(usbhid);
 			spin_unlock_irq(&amp;usbhid-&gt;lock);
@@ -1496,11 +1525,14 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 			if (status &lt; 0)
 				return status;
 		}
+		driver_suspended = true;
 		spin_lock_irq(&amp;usbhid-&gt;lock);
 		set_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 		spin_unlock_irq(&amp;usbhid-&gt;lock);
-		if (usbhid_wait_io(hid) &lt; 0)
-			return -EIO;
+		if (usbhid_wait_io(hid) &lt; 0) {
+			status = -EIO;
+			goto failed;
+		}
 	}
 
 	hid_cancel_delayed_stuff(usbhid);
@@ -1508,14 +1540,15 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 
 	if (PMSG_IS_AUTO(message) &amp;&amp; test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)) {
 		/* lost race against keypresses */
-		status = hid_start_in(hid);
-		if (status &lt; 0)
-			hid_io_error(hid);
-		usbhid_mark_busy(usbhid);
-		return -EBUSY;
+		status = -EBUSY;
+		goto failed;
 	}
 	dev_dbg(&amp;intf-&gt;dev, "suspend\n");
 	return 0;
+
+ failed:
+	hid_resume_common(hid, driver_suspended);
+	return status;
 }
 
 static int hid_resume(struct usb_interface *intf)
@@ -1527,23 +1560,7 @@ static int hid_resume(struct usb_interface *intf)
 	if (!test_bit(HID_STARTED, &amp;usbhid-&gt;iofl))
 		return 0;
 
-	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
-	usbhid_mark_busy(usbhid);
-
-	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl) ||
-	    test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl))
-		schedule_work(&amp;usbhid-&gt;reset_work);
-	usbhid-&gt;retry_delay = 0;
-	status = hid_start_in(hid);
-	if (status &lt; 0)
-		hid_io_error(hid);
-	usbhid_restart_queues(usbhid);
-
-	if (status &gt;= 0 &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;resume) {
-		int ret = hid-&gt;driver-&gt;resume(hid);
-		if (ret &lt; 0)
-			status = ret;
-	}
+	status = hid_resume_common(hid, true);
 	dev_dbg(&amp;intf-&gt;dev, "resume status %d\n", status);
 	return 0;
 }</pre><hr><pre>commit d4150c8f3d80b4a9387083478a86da8b3390dd83
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:54 2012 -0400

    HID: usbhid: check for suspend or reset before restarting
    
    This patch (as1596) improves the queue-restart logic in usbhid by
    checking to see if the device is suspended or a reset is about to
    occur.  There's no point submitting an URB if either of those is
    true.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 271578b85d91..4309c03038f6 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -207,7 +207,8 @@ static int usbhid_restart_out_queue(struct usbhid_device *usbhid)
 	int kicked;
 	int r;
 
-	if (!hid)
+	if (!hid || test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl) ||
+			test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl))
 		return 0;
 
 	if ((kicked = (usbhid-&gt;outhead != usbhid-&gt;outtail))) {
@@ -245,7 +246,8 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 	int r;
 
 	WARN_ON(hid == NULL);
-	if (!hid)
+	if (!hid || test_bit(HID_RESET_PENDING, &amp;usbhid-&gt;iofl) ||
+			test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl))
 		return 0;
 
 	if ((kicked = (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail))) {</pre>
    <div class="pagination">
        <a href='2_43.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><span>[44]</span><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_45.html'>Next&gt;&gt;</a>
    <div>
</body>
