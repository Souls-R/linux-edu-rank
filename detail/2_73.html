<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_72.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><span>[73]</span><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_74.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d697cdda43939a80432863e2e26df6701ce72b63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 27 15:18:46 2009 -0400

    USB: don't use a fixed DMA mapping for hub status URBs
    
    This patch (as1296) gets rid of the fixed DMA-buffer mapping used by
    the hub driver for its status URB.  This URB doesn't get used much --
    mainly when a device is plugged in or unplugged -- so the dynamic
    mapping overhead is minimal.  And most systems have many fewer
    external hubs than root hubs, which don't need a mapped buffer anyway.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2ac115015229..708c63826100 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -45,7 +45,6 @@ struct usb_hub {
 
 	/* buffer for urb ... with extra space in case of babble */
 	char			(*buffer)[8];
-	dma_addr_t		buffer_dma;	/* DMA address for buffer */
 	union {
 		struct usb_hub_status	hub;
 		struct usb_port_status	port;
@@ -869,8 +868,7 @@ static int hub_configure(struct usb_hub *hub,
 	int maxp, ret;
 	char *message = "out of memory";
 
-	hub-&gt;buffer = usb_buffer_alloc(hdev, sizeof(*hub-&gt;buffer), GFP_KERNEL,
-			&amp;hub-&gt;buffer_dma);
+	hub-&gt;buffer = kmalloc(sizeof(*hub-&gt;buffer), GFP_KERNEL);
 	if (!hub-&gt;buffer) {
 		ret = -ENOMEM;
 		goto fail;
@@ -1111,8 +1109,6 @@ static int hub_configure(struct usb_hub *hub,
 
 	usb_fill_int_urb(hub-&gt;urb, hdev, pipe, *hub-&gt;buffer, maxp, hub_irq,
 		hub, endpoint-&gt;bInterval);
-	hub-&gt;urb-&gt;transfer_dma = hub-&gt;buffer_dma;
-	hub-&gt;urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 	/* maybe cycle the hub leds */
 	if (hub-&gt;has_indicators &amp;&amp; blinkenlights)
@@ -1162,8 +1158,7 @@ static void hub_disconnect(struct usb_interface *intf)
 	kfree(hub-&gt;port_owners);
 	kfree(hub-&gt;descriptor);
 	kfree(hub-&gt;status);
-	usb_buffer_free(hub-&gt;hdev, sizeof(*hub-&gt;buffer), hub-&gt;buffer,
-			hub-&gt;buffer_dma);
+	kfree(hub-&gt;buffer);
 
 	kref_put(&amp;hub-&gt;kref, hub_release);
 }</pre><hr><pre>commit 3589972e51fac1e02d0aaa576fa47f568cb94d40
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Dec 4 11:06:57 2009 -0500

    Driver core: fix race in dev_driver_string
    
    This patch (as1310) works around a race in dev_driver_string().  If
    the device is unbound while the function is running, dev-&gt;driver might
    become NULL after we test it and before we dereference it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Cc: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/core.c b/drivers/base/core.c
index 353b13782165..f1290cbd1350 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -56,7 +56,14 @@ static inline int device_is_not_partition(struct device *dev)
  */
 const char *dev_driver_string(const struct device *dev)
 {
-	return dev-&gt;driver ? dev-&gt;driver-&gt;name :
+	struct device_driver *drv;
+
+	/* dev-&gt;driver can change to NULL underneath us because of unbinding,
+	 * so be careful about accessing it.  dev-&gt;bus and dev-&gt;class should
+	 * never change once they are set, so they don't need special care.
+	 */
+	drv = ACCESS_ONCE(dev-&gt;driver);
+	return drv ? drv-&gt;name :
 			(dev-&gt;bus ? dev-&gt;bus-&gt;name :
 			(dev-&gt;class ? dev-&gt;class-&gt;name : ""));
 }</pre><hr><pre>commit 63c94801701abfea21570d3302687ec027ed33e8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Dec 3 20:22:34 2009 +0100

    PM / Runtime: Use deferred_resume flag in pm_request_resume
    
    This patch (as1307) adds a small optimization to
    __pm_request_resume().  If the device is currently being suspended,
    there's no need to queue a work routine to resume it.  Setting the
    deferred_resume flag will suffice.  (There's also a minor improvement
    to the function's code layout: An unnecessary "else" is removed.)
    
    Also, the patch clarifies the usage of the deferred_resume flag.  It
    is meaningful only while a suspend is in progress, so it should be
    cleared just before a suspend starts, not just after one ends.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index 0a4b75f834c0..6e8577d1f750 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -185,6 +185,7 @@ int __pm_runtime_suspend(struct device *dev, bool from_wq)
 	}
 
 	dev-&gt;power.runtime_status = RPM_SUSPENDING;
+	dev-&gt;power.deferred_resume = false;
 
 	if (dev-&gt;bus &amp;&amp; dev-&gt;bus-&gt;pm &amp;&amp; dev-&gt;bus-&gt;pm-&gt;runtime_suspend) {
 		spin_unlock_irq(&amp;dev-&gt;power.lock);
@@ -200,7 +201,6 @@ int __pm_runtime_suspend(struct device *dev, bool from_wq)
 	if (retval) {
 		dev-&gt;power.runtime_status = RPM_ACTIVE;
 		pm_runtime_cancel_pending(dev);
-		dev-&gt;power.deferred_resume = false;
 
 		if (retval == -EAGAIN || retval == -EBUSY) {
 			notify = true;
@@ -217,7 +217,6 @@ int __pm_runtime_suspend(struct device *dev, bool from_wq)
 	wake_up_all(&amp;dev-&gt;power.wait_queue);
 
 	if (dev-&gt;power.deferred_resume) {
-		dev-&gt;power.deferred_resume = false;
 		__pm_runtime_resume(dev, false);
 		retval = -EAGAIN;
 		goto out;
@@ -659,13 +658,17 @@ static int __pm_request_resume(struct device *dev)
 
 	pm_runtime_deactivate_timer(dev);
 
+	if (dev-&gt;power.runtime_status == RPM_SUSPENDING) {
+		dev-&gt;power.deferred_resume = true;
+		return retval;
+	}
 	if (dev-&gt;power.request_pending) {
 		/* If non-resume request is pending, we can overtake it. */
 		dev-&gt;power.request = retval ? RPM_REQ_NONE : RPM_REQ_RESUME;
 		return retval;
-	} else if (retval) {
-		return retval;
 	}
+	if (retval)
+		return retval;
 
 	dev-&gt;power.request = RPM_REQ_RESUME;
 	dev-&gt;power.request_pending = true;</pre><hr><pre>commit 7b199ca2025f4756daceec8802f07da636c524c9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Dec 3 20:22:21 2009 +0100

    PM / Runtime: Export the PM runtime workqueue
    
    This patch (as1306) exports the PM runtime workqueue for use by
    loadable modules.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/kernel/power/main.c b/kernel/power/main.c
index 347d2cc88cd0..0998c7139053 100644
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -220,6 +220,7 @@ static struct attribute_group attr_group = {
 
 #ifdef CONFIG_PM_RUNTIME
 struct workqueue_struct *pm_wq;
+EXPORT_SYMBOL_GPL(pm_wq);
 
 static int __init pm_start_workqueue(void)
 {</pre><hr><pre>commit c2f6595fbdb408d3d6850cfae590c8fa93e27399
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 18 11:37:15 2009 -0500

    USB: EHCI: don't send Clear-TT-Buffer following a STALL
    
    This patch (as1304) fixes a regression in ehci-hcd.  Evidently some
    hubs don't handle Clear-TT-Buffer requests correctly, so we should
    avoid sending them when they don't appear to be absolutely necessary.
    The reported symptom is that output on a downstream audio device cuts
    out because the hub stops relaying isochronous packets.
    
    The patch prevents Clear-TT-Buffer requests from being sent following
    a STALL handshake.  In theory a STALL indicates either that the
    downstream device sent a STALL or that no matching TT buffer could be
    found.  In either case, the transfer is completed and the TT buffer
    does not remain busy, so it doesn't need to be cleared.
    
    Also, the patch fixes a minor flaw in the code that actually sends the
    Clear-TT-Buffer requests.  Although the pipe direction isn't really
    used for control transfers, it should be a Send rather than a Receive.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-by: Javier Kohen &lt;jkohen@users.sourceforge.net&gt;
    CC: David Brownell &lt;david-b@pacbell.net&gt;
    Cc: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5ce839137ad6..0f857e645058 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -444,7 +444,7 @@ static void hub_irq(struct urb *urb)
 static inline int
 hub_clear_tt_buffer (struct usb_device *hdev, u16 devinfo, u16 tt)
 {
-	return usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),
+	return usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),
 			       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,
 			       tt, NULL, 0, 1000);
 }
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index 00ad9ce392ed..139a2cc3f641 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -487,8 +487,20 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 			 * we must clear the TT buffer (11.17.5).
 			 */
 			if (unlikely(last_status != -EINPROGRESS &amp;&amp;
-					last_status != -EREMOTEIO))
-				ehci_clear_tt_buffer(ehci, qh, urb, token);
+					last_status != -EREMOTEIO)) {
+				/* The TT's in some hubs malfunction when they
+				 * receive this request following a STALL (they
+				 * stop sending isochronous packets).  Since a
+				 * STALL can't leave the TT buffer in a busy
+				 * state (if you believe Figures 11-48 - 11-51
+				 * in the USB 2.0 spec), we won't clear the TT
+				 * buffer in this case.  Strictly speaking this
+				 * is a violation of the spec.
+				 */
+				if (last_status != -EPIPE)
+					ehci_clear_tt_buffer(ehci, qh, urb,
+							token);
+			}
 		}
 
 		/* if we're removing something not at the queue head,</pre><hr><pre>commit 862f89b3d4c6bf3caab7fc69661fc6e725edd00a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 25 01:06:37 2009 +0100

    PM: fix irq enable/disable in runtime PM code
    
    This patch (as1305) fixes a bug in the irq-enable settings and removes
    some related overhead in the runtime PM code.
    
            In __pm_runtime_resume(), within the scope of the original
            spin_lock_irq(), we know that irqs are disabled.  There's no
            reason to go through a pair of enable/disable cycles when
            acquiring and releasing the parent's lock.
    
            In __pm_runtime_set_status(), irqs are already disabled when
            the parent's lock is acquired, and they must remain disabled
            when it is released.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rjw@sisk.pl&gt;

diff --git a/drivers/base/power/runtime.c b/drivers/base/power/runtime.c
index a770498a74ec..846d89e3d122 100644
--- a/drivers/base/power/runtime.c
+++ b/drivers/base/power/runtime.c
@@ -328,11 +328,11 @@ int __pm_runtime_resume(struct device *dev, bool from_wq)
 		 * necessary.
 		 */
 		parent = dev-&gt;parent;
-		spin_unlock_irq(&amp;dev-&gt;power.lock);
+		spin_unlock(&amp;dev-&gt;power.lock);
 
 		pm_runtime_get_noresume(parent);
 
-		spin_lock_irq(&amp;parent-&gt;power.lock);
+		spin_lock(&amp;parent-&gt;power.lock);
 		/*
 		 * We can resume if the parent's run-time PM is disabled or it
 		 * is set to ignore children.
@@ -343,9 +343,9 @@ int __pm_runtime_resume(struct device *dev, bool from_wq)
 			if (parent-&gt;power.runtime_status != RPM_ACTIVE)
 				retval = -EBUSY;
 		}
-		spin_unlock_irq(&amp;parent-&gt;power.lock);
+		spin_unlock(&amp;parent-&gt;power.lock);
 
-		spin_lock_irq(&amp;dev-&gt;power.lock);
+		spin_lock(&amp;dev-&gt;power.lock);
 		if (retval)
 			goto out;
 		goto repeat;
@@ -777,7 +777,7 @@ int __pm_runtime_set_status(struct device *dev, unsigned int status)
 	}
 
 	if (parent) {
-		spin_lock_irq(&amp;parent-&gt;power.lock);
+		spin_lock(&amp;parent-&gt;power.lock);
 
 		/*
 		 * It is invalid to put an active child under a parent that is
@@ -793,7 +793,7 @@ int __pm_runtime_set_status(struct device *dev, unsigned int status)
 				atomic_inc(&amp;parent-&gt;power.child_count);
 		}
 
-		spin_unlock_irq(&amp;parent-&gt;power.lock);
+		spin_unlock(&amp;parent-&gt;power.lock);
 
 		if (error)
 			goto out;</pre><hr><pre>commit fca94748c5136ff390eadc443871b82f1f77dcd6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Nov 4 11:35:53 2009 -0500

    USB: usbmon: fix bug in mon_buff_area_shrink
    
    This patch (as1299b) fixes a bug in an error-handling path of usbmon's
    binary interface.  The storage area for URB data is divided into
    fixed-size blocks.  If an URB's data can't be copied, the area
    reserved for it should be decreased to the size of the truncated
    information (rounded up to a block boundary).  Rounding up the amount
    to be removed and subtracting it from the reserved size is definitely
    the wrong thing to do.
    
    Also, when the data for an isochronous URB can't be copied, we can
    still copy the isoc packet descriptors.  In fact the current code does
    copy the descriptors, but then sets the capture length to 0 so they
    remain inaccessible.  The capture length should be reduced to the
    length of the descriptors, not set to 0.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Pete Zaitcev &lt;zaitcev@redhat.com&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/mon/mon_bin.c b/drivers/usb/mon/mon_bin.c
index 9ed3e741bee1..10f3205798e8 100644
--- a/drivers/usb/mon/mon_bin.c
+++ b/drivers/usb/mon/mon_bin.c
@@ -348,12 +348,12 @@ static unsigned int mon_buff_area_alloc_contiguous(struct mon_reader_bin *rp,
 
 /*
  * Return a few (kilo-)bytes to the head of the buffer.
- * This is used if a DMA fetch fails.
+ * This is used if a data fetch fails.
  */
 static void mon_buff_area_shrink(struct mon_reader_bin *rp, unsigned int size)
 {
 
-	size = (size + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
+	/* size &amp;= ~(PKT_ALIGN-1);  -- we're called with aligned size */
 	rp-&gt;b_cnt -= size;
 	if (rp-&gt;b_in &lt; size)
 		rp-&gt;b_in += rp-&gt;b_size;
@@ -433,6 +433,7 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	unsigned int urb_length;
 	unsigned int offset;
 	unsigned int length;
+	unsigned int delta;
 	unsigned int ndesc, lendesc;
 	unsigned char dir;
 	struct mon_bin_hdr *ep;
@@ -537,8 +538,10 @@ static void mon_bin_event(struct mon_reader_bin *rp, struct urb *urb,
 	if (length != 0) {
 		ep-&gt;flag_data = mon_bin_get_data(rp, offset, urb, length);
 		if (ep-&gt;flag_data != 0) {	/* Yes, it's 0x00, not '0' */
-			ep-&gt;len_cap = 0;
-			mon_buff_area_shrink(rp, length);
+			delta = (ep-&gt;len_cap + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
+			ep-&gt;len_cap -= length;
+			delta -= (ep-&gt;len_cap + PKT_ALIGN-1) &amp; ~(PKT_ALIGN-1);
+			mon_buff_area_shrink(rp, delta);
 		}
 	} else {
 		ep-&gt;flag_data = data_tag;</pre><hr><pre>commit f1a0743bc0e7a30c032b1eb78f6a2b0f805b4597
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 6 14:07:57 2009 -0400

    USB: storage: When a device returns no sense data, call it a Hardware Error
    
    This patch (as1294) fixes a problem that has plagued users for several
    kernel releases.  Some USB mass-storage devices don't return any sense
    data when they encounter certain kinds of errors.  The SCSI layer
    interprets this to mean that the operation should be retried, and the
    same thing happens -- over and over again with no limit.  In some
    circumstances (such as when a bus reset occurs) that is the right
    thing to do, but not here.
    
    The patch checks for this condition (a transport failure with no sense
    data) and changes the result code to DID_ERROR and the sense code to
    Hardware Error.  This does get only a limited number of retries, and
    so the command will fail relatively quickly instead of getting stuck
    in an infinite loop.
    
    This fixes a large part of Bugzilla #14118.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Mantas Mikulenas &lt;grawity@gmail.com&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c
index e20dc525d177..3a4fb023af72 100644
--- a/drivers/usb/storage/transport.c
+++ b/drivers/usb/storage/transport.c
@@ -768,17 +768,32 @@ void usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)
 		/* set the result so the higher layers expect this data */
 		srb-&gt;result = SAM_STAT_CHECK_CONDITION;
 
-		/* If things are really okay, then let's show that.  Zero
-		 * out the sense buffer so the higher layers won't realize
-		 * we did an unsolicited auto-sense. */
-		if (result == USB_STOR_TRANSPORT_GOOD &amp;&amp;
-			/* Filemark 0, ignore EOM, ILI 0, no sense */
+		/* We often get empty sense data.  This could indicate that
+		 * everything worked or that there was an unspecified
+		 * problem.  We have to decide which.
+		 */
+		if (	/* Filemark 0, ignore EOM, ILI 0, no sense */
 				(srb-&gt;sense_buffer[2] &amp; 0xaf) == 0 &amp;&amp;
 			/* No ASC or ASCQ */
 				srb-&gt;sense_buffer[12] == 0 &amp;&amp;
 				srb-&gt;sense_buffer[13] == 0) {
-			srb-&gt;result = SAM_STAT_GOOD;
-			srb-&gt;sense_buffer[0] = 0x0;
+
+			/* If things are really okay, then let's show that.
+			 * Zero out the sense buffer so the higher layers
+			 * won't realize we did an unsolicited auto-sense.
+			 */
+			if (result == USB_STOR_TRANSPORT_GOOD) {
+				srb-&gt;result = SAM_STAT_GOOD;
+				srb-&gt;sense_buffer[0] = 0x0;
+
+			/* If there was a problem, report an unspecified
+			 * hardware error to prevent the higher layers from
+			 * entering an infinite retry loop.
+			 */
+			} else {
+				srb-&gt;result = DID_ERROR &lt;&lt; 16;
+				srb-&gt;sense_buffer[2] = HARDWARE_ERROR;
+			}
 		}
 	}
 </pre><hr><pre>commit 06bad89da686f6323e95cf925105e8cf88d87caf
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Oct 5 15:53:58 2009 -0400

    USB: ipaq: fix oops when device is plugged in
    
    This patch (as1293) fixes a problem with the ipaq serial driver.  It
    tries to bind to all the interfaces, even those that don't have enough
    endpoints.  The symptom is an invalid memory reference and oops when
    the device is plugged in.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Tested-by: Matthias Geissert &lt;geissert@mathematik.tu-darmstadt.de&gt;
    Tested-by: Tilman Schmidt &lt;tilman@imap.cc&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c
index 24fcc64b837d..d6231c38813e 100644
--- a/drivers/usb/serial/ipaq.c
+++ b/drivers/usb/serial/ipaq.c
@@ -966,6 +966,15 @@ static int ipaq_calc_num_ports(struct usb_serial *serial)
 static int ipaq_startup(struct usb_serial *serial)
 {
 	dbg("%s", __func__);
+
+	/* Some of the devices in ipaq_id_table[] are composite, and we
+	 * shouldn't bind to all the interfaces.  This test will rule out
+	 * some obviously invalid possibilities.
+	 */
+	if (serial-&gt;num_bulk_in &lt; serial-&gt;num_ports ||
+			serial-&gt;num_bulk_out &lt; serial-&gt;num_ports)
+		return -ENODEV;
+
 	if (serial-&gt;dev-&gt;actconfig-&gt;desc.bConfigurationValue != 1) {
 		/*
 		 * FIXME: HP iPaq rx3715, possibly others, have 1 config that</pre><hr><pre>commit a4720c650b68a5fe7faed2edeb0ad12645f7ae63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Oct 9 12:43:12 2009 -0400

    USB: serial: don't call release without attach
    
    This patch (as1295) fixes a recently-added bug in the USB serial core.
    If certain kinds of errors occur during probing, the core may call a
    serial driver's release method without previously calling the attach
    method.  This causes some drivers (io_ti in particular) to perform an
    invalid memory access.
    
    The patch adds a new flag to keep track of whether or not attach has
    been called.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Tested-by: Jean-Denis Girard &lt;jd.girard@sysnux.pf&gt;
    CC: stable &lt;stable@kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index aa6b2ae951ae..2d0f75d63ff0 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -156,7 +156,8 @@ static void destroy_serial(struct kref *kref)
 	if (serial-&gt;minor != SERIAL_TTY_NO_MINOR)
 		return_serial(serial);
 
-	serial-&gt;type-&gt;release(serial);
+	if (serial-&gt;attached)
+		serial-&gt;type-&gt;release(serial);
 
 	/* Now that nothing is using the ports, they can be freed */
 	for (i = 0; i &lt; serial-&gt;num_port_pointers; ++i) {
@@ -1059,12 +1060,15 @@ int usb_serial_probe(struct usb_interface *interface,
 		module_put(type-&gt;driver.owner);
 		if (retval &lt; 0)
 			goto probe_error;
+		serial-&gt;attached = 1;
 		if (retval &gt; 0) {
 			/* quietly accept this device, but don't bind to a
 			   serial port as it's about to disappear */
 			serial-&gt;num_ports = 0;
 			goto exit;
 		}
+	} else {
+		serial-&gt;attached = 1;
 	}
 
 	if (get_free_serial(serial, num_ports, &amp;minor) == NULL) {
diff --git a/include/linux/usb/serial.h b/include/linux/usb/serial.h
index c17eb64d7213..ce911ebf91e8 100644
--- a/include/linux/usb/serial.h
+++ b/include/linux/usb/serial.h
@@ -150,6 +150,7 @@ struct usb_serial {
 	struct usb_interface		*interface;
 	unsigned char			disconnected:1;
 	unsigned char			suspending:1;
+	unsigned char			attached:1;
 	unsigned char			minor;
 	unsigned char			num_ports;
 	unsigned char			num_port_pointers;</pre>
    <div class="pagination">
        <a href='2_72.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><span>[73]</span><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_74.html'>Next&gt;&gt;</a>
    <div>
</body>
