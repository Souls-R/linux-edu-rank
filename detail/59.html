<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Northeastern University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Northeastern University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit e9ec6cc74e0add3d4f27348fc93ba9d0a705d75e
Author: Changming Liu &lt;liu.changm@northeastern.edu&gt;
Date:   Fri May 29 21:48:15 2020 -0400

    USB: sisusbvga: change char to u8 for sisusb_copy_memory
    
    sisusb_copy_memory is called in several places.
    
    sisusb_copy_memory calls sisusb_write_mem_bulk which
    is called by sisusb_write and sisusb_send_bulk_msg.
    
    change the related parameters from char to u8 accordingly
    
    Signed-off-by: Changming Liu &lt;liu.changm@northeastern.edu&gt;
    Link: https://lore.kernel.org/r/20200530014820.9967-2-liu.changm@northeastern.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/sisusbvga/sisusb.c b/drivers/usb/misc/sisusbvga/sisusb.c
index fc8a5da4a07c..88c4975e303d 100644
--- a/drivers/usb/misc/sisusbvga/sisusb.c
+++ b/drivers/usb/misc/sisusbvga/sisusb.c
@@ -1283,7 +1283,7 @@ int sisusb_readb(struct sisusb_usb_data *sisusb, u32 adr, u8 *data)
 	return sisusb_read_memio_byte(sisusb, SISUSB_TYPE_MEM, adr, data);
 }
 
-int sisusb_copy_memory(struct sisusb_usb_data *sisusb, char *src,
+int sisusb_copy_memory(struct sisusb_usb_data *sisusb, u8 *src,
 		u32 dest, int length)
 {
 	size_t dummy;
@@ -1307,7 +1307,7 @@ static int sisusb_read_memory(struct sisusb_usb_data *sisusb, char *dest,
 #ifdef SISUSBENDIANTEST
 static void sisusb_testreadwrite(struct sisusb_usb_data *sisusb)
 {
-	static char srcbuffer[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };
+	static u8 srcbuffer[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };
 	char destbuffer[10];
 	int i, j;
 
@@ -2340,7 +2340,7 @@ int sisusb_reset_text_mode(struct sisusb_usb_data *sisusb, int init)
 		}
 
 	} else if (sisusb-&gt;scrbuf) {
-		ret |= sisusb_copy_memory(sisusb, (char *)sisusb-&gt;scrbuf,
+		ret |= sisusb_copy_memory(sisusb, (u8 *)sisusb-&gt;scrbuf,
 				sisusb-&gt;vrambase, sisusb-&gt;scrbuf_size);
 	}
 
diff --git a/drivers/usb/misc/sisusbvga/sisusb_con.c b/drivers/usb/misc/sisusbvga/sisusb_con.c
index 586d6b01c3c4..15e62a2e9b1b 100644
--- a/drivers/usb/misc/sisusbvga/sisusb_con.c
+++ b/drivers/usb/misc/sisusbvga/sisusb_con.c
@@ -509,7 +509,7 @@ sisusbcon_switch(struct vc_data *c)
 	/* Restore the screen contents */
 	memcpy((u16 *)c-&gt;vc_origin, (u16 *)c-&gt;vc_screenbuf, length);
 
-	sisusb_copy_memory(sisusb, (char *)c-&gt;vc_origin,
+	sisusb_copy_memory(sisusb, (u8 *)c-&gt;vc_origin,
 			sisusb_haddr(sisusb, c, 0, 0), length);
 
 	mutex_unlock(&amp;sisusb-&gt;lock);
@@ -615,7 +615,7 @@ sisusbcon_blank(struct vc_data *c, int blank, int mode_switch)
 		sisusbcon_memsetw((u16 *)c-&gt;vc_origin,
 				c-&gt;vc_video_erase_char,
 				c-&gt;vc_screenbuf_size);
-		sisusb_copy_memory(sisusb, (char *)c-&gt;vc_origin,
+		sisusb_copy_memory(sisusb, (u8 *)c-&gt;vc_origin,
 				sisusb_haddr(sisusb, c, 0, 0),
 				c-&gt;vc_screenbuf_size);
 		sisusb-&gt;con_blanked = 1;
@@ -897,18 +897,18 @@ sisusbcon_scroll(struct vc_data *c, unsigned int t, unsigned int b,
 
 	if (copyall)
 		sisusb_copy_memory(sisusb,
-			(char *)c-&gt;vc_origin,
+			(u8 *)c-&gt;vc_origin,
 			sisusb_haddr(sisusb, c, 0, 0),
 			c-&gt;vc_screenbuf_size);
 	else if (dir == SM_UP)
 		sisusb_copy_memory(sisusb,
-			(char *)c-&gt;vc_origin + c-&gt;vc_screenbuf_size - delta,
+			(u8 *)c-&gt;vc_origin + c-&gt;vc_screenbuf_size - delta,
 			sisusb_haddr(sisusb, c, 0, 0) +
 					c-&gt;vc_screenbuf_size - delta,
 			delta);
 	else
 		sisusb_copy_memory(sisusb,
-			(char *)c-&gt;vc_origin,
+			(u8 *)c-&gt;vc_origin,
 			sisusb_haddr(sisusb, c, 0, 0),
 			delta);
 
diff --git a/drivers/usb/misc/sisusbvga/sisusb_init.h b/drivers/usb/misc/sisusbvga/sisusb_init.h
index aa33bc81ee52..b79bdf989933 100644
--- a/drivers/usb/misc/sisusbvga/sisusb_init.h
+++ b/drivers/usb/misc/sisusbvga/sisusb_init.h
@@ -828,7 +828,7 @@ extern int sisusb_setidxregand(struct sisusb_usb_data *sisusb, u32 port,
 void sisusb_delete(struct kref *kref);
 int sisusb_writeb(struct sisusb_usb_data *sisusb, u32 adr, u8 data);
 int sisusb_readb(struct sisusb_usb_data *sisusb, u32 adr, u8 * data);
-int sisusb_copy_memory(struct sisusb_usb_data *sisusb, char *src,
+int sisusb_copy_memory(struct sisusb_usb_data *sisusb, u8 *src,
 		       u32 dest, int length);
 int sisusb_reset_text_mode(struct sisusb_usb_data *sisusb, int init);
 int sisusbcon_do_font_op(struct sisusb_usb_data *sisusb, int set, int slot,</pre><hr><pre>commit fb8cd6481ffd126f35e9e146a0dcf0c4e8899f2e
Author: Changming Liu &lt;liu.changm@northeastern.edu&gt;
Date:   Tue May 26 00:39:21 2020 +0000

    ALSA: hwdep: fix a left shifting 1 by 31 UB bug
    
    The "info.index" variable can be 31 in "1 &lt;&lt; info.index".
    This might trigger an undefined behavior since 1 is signed.
    
    Fix this by casting 1 to 1u just to be sure "1u &lt;&lt; 31" is defined.
    
    Signed-off-by: Changming Liu &lt;liu.changm@northeastern.edu&gt;
    Cc: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/BL0PR06MB4548170B842CB055C9AF695DE5B00@BL0PR06MB4548.namprd06.prod.outlook.com
    Signed-off-by: Takashi Iwai &lt;tiwai@suse.de&gt;

diff --git a/sound/core/hwdep.c b/sound/core/hwdep.c
index b412d3b3d5ff..21edb8ac95eb 100644
--- a/sound/core/hwdep.c
+++ b/sound/core/hwdep.c
@@ -216,12 +216,12 @@ static int snd_hwdep_dsp_load(struct snd_hwdep *hw,
 	if (info.index &gt;= 32)
 		return -EINVAL;
 	/* check whether the dsp was already loaded */
-	if (hw-&gt;dsp_loaded &amp; (1 &lt;&lt; info.index))
+	if (hw-&gt;dsp_loaded &amp; (1u &lt;&lt; info.index))
 		return -EBUSY;
 	err = hw-&gt;ops.dsp_load(hw, &amp;info);
 	if (err &lt; 0)
 		return err;
-	hw-&gt;dsp_loaded |= (1 &lt;&lt; info.index);
+	hw-&gt;dsp_loaded |= (1u &lt;&lt; info.index);
 	return 0;
 }
 </pre><hr><pre>commit 2df7405f79ce1674d73c2786fe1a8727c905d65b
Author: Changming Liu &lt;liu.changm@northeastern.edu&gt;
Date:   Mon Apr 20 23:41:25 2020 -0400

    USB: sisusbvga: Change port variable from signed to unsigned
    
    Change a bunch of arguments of wrapper functions which pass signed
    integer to an unsigned integer which might cause undefined behaviors
    when sign integer overflow.
    
    Signed-off-by: Changming Liu &lt;liu.changm@northeastern.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/BL0PR06MB45482D71EA822D75A0E60A2EE5D50@BL0PR06MB4548.namprd06.prod.outlook.com
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/sisusbvga/sisusb.c b/drivers/usb/misc/sisusbvga/sisusb.c
index 2ab9600d0898..fc8a5da4a07c 100644
--- a/drivers/usb/misc/sisusbvga/sisusb.c
+++ b/drivers/usb/misc/sisusbvga/sisusb.c
@@ -1199,18 +1199,18 @@ static int sisusb_read_mem_bulk(struct sisusb_usb_data *sisusb, u32 addr,
 /* High level: Gfx (indexed) register access */
 
 #ifdef CONFIG_USB_SISUSBVGA_CON
-int sisusb_setreg(struct sisusb_usb_data *sisusb, int port, u8 data)
+int sisusb_setreg(struct sisusb_usb_data *sisusb, u32 port, u8 data)
 {
 	return sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, data);
 }
 
-int sisusb_getreg(struct sisusb_usb_data *sisusb, int port, u8 *data)
+int sisusb_getreg(struct sisusb_usb_data *sisusb, u32 port, u8 *data)
 {
 	return sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port, data);
 }
 #endif
 
-int sisusb_setidxreg(struct sisusb_usb_data *sisusb, int port,
+int sisusb_setidxreg(struct sisusb_usb_data *sisusb, u32 port,
 		u8 index, u8 data)
 {
 	int ret;
@@ -1220,7 +1220,7 @@ int sisusb_setidxreg(struct sisusb_usb_data *sisusb, int port,
 	return ret;
 }
 
-int sisusb_getidxreg(struct sisusb_usb_data *sisusb, int port,
+int sisusb_getidxreg(struct sisusb_usb_data *sisusb, u32 port,
 		u8 index, u8 *data)
 {
 	int ret;
@@ -1230,7 +1230,7 @@ int sisusb_getidxreg(struct sisusb_usb_data *sisusb, int port,
 	return ret;
 }
 
-int sisusb_setidxregandor(struct sisusb_usb_data *sisusb, int port, u8 idx,
+int sisusb_setidxregandor(struct sisusb_usb_data *sisusb, u32 port, u8 idx,
 		u8 myand, u8 myor)
 {
 	int ret;
@@ -1245,7 +1245,7 @@ int sisusb_setidxregandor(struct sisusb_usb_data *sisusb, int port, u8 idx,
 }
 
 static int sisusb_setidxregmask(struct sisusb_usb_data *sisusb,
-		int port, u8 idx, u8 data, u8 mask)
+		u32 port, u8 idx, u8 data, u8 mask)
 {
 	int ret;
 	u8 tmp;
@@ -1258,13 +1258,13 @@ static int sisusb_setidxregmask(struct sisusb_usb_data *sisusb,
 	return ret;
 }
 
-int sisusb_setidxregor(struct sisusb_usb_data *sisusb, int port,
+int sisusb_setidxregor(struct sisusb_usb_data *sisusb, u32 port,
 		u8 index, u8 myor)
 {
 	return sisusb_setidxregandor(sisusb, port, index, 0xff, myor);
 }
 
-int sisusb_setidxregand(struct sisusb_usb_data *sisusb, int port,
+int sisusb_setidxregand(struct sisusb_usb_data *sisusb, u32 port,
 		u8 idx, u8 myand)
 {
 	return sisusb_setidxregandor(sisusb, port, idx, myand, 0x00);
@@ -2785,8 +2785,8 @@ static loff_t sisusb_lseek(struct file *file, loff_t offset, int orig)
 static int sisusb_handle_command(struct sisusb_usb_data *sisusb,
 		struct sisusb_command *y, unsigned long arg)
 {
-	int	retval, port, length;
-	u32	address;
+	int	retval, length;
+	u32	port, address;
 
 	/* All our commands require the device
 	 * to be initialized.
diff --git a/drivers/usb/misc/sisusbvga/sisusb_init.h b/drivers/usb/misc/sisusbvga/sisusb_init.h
index 1782c759c4ad..ace09985dae4 100644
--- a/drivers/usb/misc/sisusbvga/sisusb_init.h
+++ b/drivers/usb/misc/sisusbvga/sisusb_init.h
@@ -812,17 +812,17 @@ static const struct SiS_VCLKData SiSUSB_VCLKData[] = {
 int SiSUSBSetMode(struct SiS_Private *SiS_Pr, unsigned short ModeNo);
 int SiSUSBSetVESAMode(struct SiS_Private *SiS_Pr, unsigned short VModeNo);
 
-extern int sisusb_setreg(struct sisusb_usb_data *sisusb, int port, u8 data);
-extern int sisusb_getreg(struct sisusb_usb_data *sisusb, int port, u8 * data);
-extern int sisusb_setidxreg(struct sisusb_usb_data *sisusb, int port,
+extern int sisusb_setreg(struct sisusb_usb_data *sisusb, u32 port, u8 data);
+extern int sisusb_getreg(struct sisusb_usb_data *sisusb, u32 port, u8 * data);
+extern int sisusb_setidxreg(struct sisusb_usb_data *sisusb, u32 port,
 			    u8 index, u8 data);
-extern int sisusb_getidxreg(struct sisusb_usb_data *sisusb, int port,
+extern int sisusb_getidxreg(struct sisusb_usb_data *sisusb, u32 port,
 			    u8 index, u8 * data);
-extern int sisusb_setidxregandor(struct sisusb_usb_data *sisusb, int port,
+extern int sisusb_setidxregandor(struct sisusb_usb_data *sisusb, u32 port,
 				 u8 idx, u8 myand, u8 myor);
-extern int sisusb_setidxregor(struct sisusb_usb_data *sisusb, int port,
+extern int sisusb_setidxregor(struct sisusb_usb_data *sisusb, u32 port,
 			      u8 index, u8 myor);
-extern int sisusb_setidxregand(struct sisusb_usb_data *sisusb, int port,
+extern int sisusb_setidxregand(struct sisusb_usb_data *sisusb, u32 port,
 			       u8 idx, u8 myand);
 
 void sisusb_delete(struct kref *kref);</pre><hr><pre>commit 8fa196478b8fb30e59456252ab4b309985f67443
Author: Jim Faulkner &lt;jfaulkne@ccs.neu.edu&gt;
Date:   Tue May 1 21:58:08 2012 -0400

    alpha: include module.h to fix modpost on Tsunami
    
    Signed-off-by: Jim Faulkner &lt;jfaulkne@ccs.neu.edu&gt;
    Signed-off-by: Matt Turner &lt;mattst88@gmail.com&gt;

diff --git a/arch/alpha/kernel/core_tsunami.c b/arch/alpha/kernel/core_tsunami.c
index 5e7c28f92f19..61893d7bdda5 100644
--- a/arch/alpha/kernel/core_tsunami.c
+++ b/arch/alpha/kernel/core_tsunami.c
@@ -11,6 +11,7 @@
 #include &lt;asm/core_tsunami.h&gt;
 #undef __EXTERN_INLINE
 
+#include &lt;linux/module.h&gt;
 #include &lt;linux/types.h&gt;
 #include &lt;linux/pci.h&gt;
 #include &lt;linux/sched.h&gt;</pre><hr><pre>commit eec9fe7d1ab4a0dfac4cb43047a7657fffd0002f
Author: Ari Entlich &lt;atrigent@ccs.neu.edu&gt;
Date:   Fri Feb 19 09:37:55 2010 -0500

    tty: Add a new VT mode which is like VT_PROCESS but doesn't require a VT_RELDISP ioctl call
    
    This new VT mode (VT_PROCESS_AUTO) does everything that VT_PROCESS does
    except that it doesn't wait for a VT_RELDISP ioctl before switching
    away from a VT with that mode.
    
    If the X server eventually uses this new mode, debugging and crash
    recovery should become easier. This is because even when currently in
    the VT of a frozen X server it would still be possible to switch out
    by doing SysRq-r and then CTRL-&lt;number of a text vt&gt;, sshing in and
    doing chvt &lt;number of a text vt&gt;, or any other method of VT switching.
    The general concensus on #xorg-devel seems to be that it should be
    safe to use this with X now that we have KMS.
    
    This also moves the VT_ACKACQ define to a more appropriate place,
    for clarity's sake.
    
    Signed-off-by: Ari Entlich &lt;atrigent@ccs.neu.edu&gt;
    Acked-by: Alan Cox &lt;alan@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/char/vt_ioctl.c b/drivers/char/vt_ioctl.c
index 6aa10284104a..87778dcf8727 100644
--- a/drivers/char/vt_ioctl.c
+++ b/drivers/char/vt_ioctl.c
@@ -888,7 +888,7 @@ int vt_ioctl(struct tty_struct *tty, struct file * file,
 			ret = -EFAULT;
 			goto out;
 		}
-		if (tmp.mode != VT_AUTO &amp;&amp; tmp.mode != VT_PROCESS) {
+		if (tmp.mode != VT_AUTO &amp;&amp; tmp.mode != VT_PROCESS &amp;&amp; tmp.mode != VT_PROCESS_AUTO) {
 			ret = -EINVAL;
 			goto out;
 		}
@@ -1622,7 +1622,7 @@ static void complete_change_console(struct vc_data *vc)
 	 * telling it that it has acquired. Also check if it has died and
 	 * clean up (similar to logic employed in change_console())
 	 */
-	if (vc-&gt;vt_mode.mode == VT_PROCESS) {
+	if (vc-&gt;vt_mode.mode == VT_PROCESS || vc-&gt;vt_mode.mode == VT_PROCESS_AUTO) {
 		/*
 		 * Send the signal as privileged - kill_pid() will
 		 * tell us if the process has gone or something else
@@ -1682,7 +1682,7 @@ void change_console(struct vc_data *new_vc)
 	 * vt to auto control.
 	 */
 	vc = vc_cons[fg_console].d;
-	if (vc-&gt;vt_mode.mode == VT_PROCESS) {
+	if (vc-&gt;vt_mode.mode == VT_PROCESS || vc-&gt;vt_mode.mode == VT_PROCESS_AUTO) {
 		/*
 		 * Send the signal as privileged - kill_pid() will
 		 * tell us if the process has gone or something else
@@ -1693,27 +1693,28 @@ void change_console(struct vc_data *new_vc)
 		 */
 		vc-&gt;vt_newvt = new_vc-&gt;vc_num;
 		if (kill_pid(vc-&gt;vt_pid, vc-&gt;vt_mode.relsig, 1) == 0) {
+			if(vc-&gt;vt_mode.mode == VT_PROCESS)
+				/*
+				 * It worked. Mark the vt to switch to and
+				 * return. The process needs to send us a
+				 * VT_RELDISP ioctl to complete the switch.
+				 */
+				return;
+		} else {
 			/*
-			 * It worked. Mark the vt to switch to and
-			 * return. The process needs to send us a
-			 * VT_RELDISP ioctl to complete the switch.
+			 * The controlling process has died, so we revert back to
+			 * normal operation. In this case, we'll also change back
+			 * to KD_TEXT mode. I'm not sure if this is strictly correct
+			 * but it saves the agony when the X server dies and the screen
+			 * remains blanked due to KD_GRAPHICS! It would be nice to do
+			 * this outside of VT_PROCESS but there is no single process
+			 * to account for and tracking tty count may be undesirable.
 			 */
-			return;
+			reset_vc(vc);
 		}
 
 		/*
-		 * The controlling process has died, so we revert back to
-		 * normal operation. In this case, we'll also change back
-		 * to KD_TEXT mode. I'm not sure if this is strictly correct
-		 * but it saves the agony when the X server dies and the screen
-		 * remains blanked due to KD_GRAPHICS! It would be nice to do
-		 * this outside of VT_PROCESS but there is no single process
-		 * to account for and tracking tty count may be undesirable.
-		 */
-		reset_vc(vc);
-
-		/*
-		 * Fall through to normal (VT_AUTO) handling of the switch...
+		 * Fall through to normal (VT_AUTO and VT_PROCESS_AUTO) handling of the switch...
 		 */
 	}
 
diff --git a/include/linux/vt.h b/include/linux/vt.h
index d5dd0bc408fd..778b7b2a47d4 100644
--- a/include/linux/vt.h
+++ b/include/linux/vt.h
@@ -27,7 +27,7 @@ struct vt_mode {
 #define VT_SETMODE	0x5602	/* set mode of active vt */
 #define		VT_AUTO		0x00	/* auto vt switching */
 #define		VT_PROCESS	0x01	/* process controls switching */
-#define		VT_ACKACQ	0x02	/* acknowledge switch */
+#define		VT_PROCESS_AUTO 0x02	/* process is notified of switching */
 
 struct vt_stat {
 	unsigned short v_active;	/* active vt */
@@ -38,6 +38,7 @@ struct vt_stat {
 #define VT_SENDSIG	0x5604	/* signal to send to bitmask of vts */
 
 #define VT_RELDISP	0x5605	/* release display */
+#define		VT_ACKACQ	0x02	/* acknowledge switch */
 
 #define VT_ACTIVATE	0x5606	/* make vt active */
 #define VT_WAITACTIVE	0x5607	/* wait for vt active */</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
