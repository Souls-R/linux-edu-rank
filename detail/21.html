<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Shenzhen University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Shenzhen University</h1>
    <div class="pagination">
        <span>[1]</span><a href='21_2.html'>2</a><a href='21_3.html'>3</a><a href='21_4.html'>4</a><a href='21_2.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8e6657159131f90b746572f6a5bd622b3ccac82d
Author: Senhong Liu &lt;liusenhong2022@email.szu.edu.cn&gt;
Date:   Sat Aug 19 06:33:45 2023 -0700

    ASoC: rt5640: fix typos
    
    I noticed typos and i fixed them.
    
    Signed-off-by: Senhong Liu &lt;liusenhong2022@email.szu.edu.cn&gt;
    Link: https://lore.kernel.org/r/20230819133345.39961-1-liusenhong2022@email.szu.edu.cn
    Signed-off-by: Mark Brown &lt;broonie@kernel.org&gt;

diff --git a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c
index 8920726c38e8..15e1a62b9e57 100644
--- a/sound/soc/codecs/rt5640.c
+++ b/sound/soc/codecs/rt5640.c
@@ -2570,7 +2570,7 @@ static void rt5640_enable_jack_detect(struct snd_soc_component *component,
 					IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
 					"rt5640", rt5640);
 	if (ret) {
-		dev_warn(component-&gt;dev, "Failed to reguest IRQ %d: %d\n", rt5640-&gt;irq, ret);
+		dev_warn(component-&gt;dev, "Failed to request IRQ %d: %d\n", rt5640-&gt;irq, ret);
 		rt5640_disable_jack_detect(component);
 		return;
 	}
@@ -2625,7 +2625,7 @@ static void rt5640_enable_hda_jack_detect(
 					NULL, rt5640_irq, IRQF_TRIGGER_RISING | IRQF_ONESHOT,
 					"rt5640", rt5640);
 	if (ret) {
-		dev_warn(component-&gt;dev, "Failed to reguest IRQ %d: %d\n", rt5640-&gt;irq, ret);
+		dev_warn(component-&gt;dev, "Failed to request IRQ %d: %d\n", rt5640-&gt;irq, ret);
 		rt5640-&gt;irq = -ENXIO;
 		return;
 	}</pre><hr><pre>commit 25e9fa22fbfec1e58c955d2670bf9a18f4ebe9ef
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Tue Nov 15 01:14:26 2022 +0800

    mm/kmemleak.c: fix a comment
    
    I noticed a typo in a code comment and I fixed it.
    
    Link: https://lkml.kernel.org/r/20221114171426.91745-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/mm/kmemleak.c b/mm/kmemleak.c
index 646e2979641f..267332904354 100644
--- a/mm/kmemleak.c
+++ b/mm/kmemleak.c
@@ -1461,7 +1461,7 @@ static void scan_gray_list(void)
 }
 
 /*
- * Conditionally call resched() in a object iteration loop while making sure
+ * Conditionally call resched() in an object iteration loop while making sure
  * that the given object won't go away without RCU read lock by performing a
  * get_object() if !pinned.
  *</pre><hr><pre>commit 0719fdba54836b6d7acbe7d74f81df2153a40810
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Wed Oct 5 22:55:25 2022 +0800

    Documentation/mm/page_owner.rst: delete frequently changing experimental data
    
    The kernel size changes due to many factors, such as compiler
    version, configuration, and the build environment. This makes
    size comparison figures irrelevant to reader's setup.
    
    Remove these figures and describe the effects of page owner
    to the kernel size in general instead.
    
    Thanks for Jonathan Corbet, Bagas Sanjaya and Mike Rapoport's
    constructive suggestions.
    
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Link: https://lore.kernel.org/r/20221005145525.10359-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Jonathan Corbet &lt;corbet@lwn.net&gt;

diff --git a/Documentation/mm/page_owner.rst b/Documentation/mm/page_owner.rst
index f5c954afe97c..f1efbb414ea6 100644
--- a/Documentation/mm/page_owner.rst
+++ b/Documentation/mm/page_owner.rst
@@ -38,22 +38,10 @@ not affect to allocation performance, especially if the static keys jump
 label patching functionality is available. Following is the kernel's code
 size change due to this facility.
 
-- Without page owner::
-
-   text    data     bss     dec     hex filename
-   48392   2333     644   51369    c8a9 mm/page_alloc.o
-
-- With page owner::
-
-   text    data     bss     dec     hex filename
-   48800   2445     644   51889    cab1 mm/page_alloc.o
-   6662     108      29    6799    1a8f mm/page_owner.o
-   1025       8       8    1041     411 mm/page_ext.o
-
-Although, roughly, 8 KB code is added in total, page_alloc.o increase by
-520 bytes and less than half of it is in hotpath. Building the kernel with
-page owner and turning it on if needed would be great option to debug
-kernel memory problem.
+Although enabling page owner increases kernel size by several kilobytes,
+most of this code is outside page allocator and its hot path. Building
+the kernel with page owner and turning it on if needed would be great
+option to debug kernel memory problem.
 
 There is one notice that is caused by implementation detail. page owner
 stores information into the memory from struct page extension. This memory</pre><hr><pre>commit 57eb60c04d2c7b0de91eac2bc5d0331f8fe72fd7
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Fri Aug 12 23:55:15 2022 +0800

    tools/vm/page_owner_sort: fix -f option
    
    The -f option is to filter out the information of blocks whose memory has
    not been released, I noticed some blocks should not be filtered out.
    
    Commit 9cc7e96aa846 ("mm/page_owner: record timestamp and pid") records
    the allocation timestamp (ts_nsec) of all pages.
    
    Commit 866b48526217 ("mm/page_owner: record the timestamp of all pages
    during free") records the free timestamp (free_ts_nsec) of all pages.
    When the page is allocated for the first time, the initial value of
    free_ts_nsec is 0, and the corresponding time will be obtained when the
    page is released.  But during reallocation the free_ts_nsec will not reset
    to 0 again.  In particular, when page migration occurs, these two
    timestamps will be the same.
    
    Now page_owner_sort removes all text blocks whose free_ts_nsec is not 0
    when using -f option.  However, this way can only select pages allocated
    for the first time.  If a freed page is reallocated, free_ts_nsec will be
    less than ts_nsec; if page migration occurs, the two timestamps will be
    equal.  These cases should be considered as pages are not released.
    
    So I fix the function is_need() to keep text blocks that meet the above
    two conditions when using -f option.
    
    Link: https://lkml.kernel.org/r/20220812155515.30846-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Cc: Liam Mark &lt;lmark@codeaurora.org&gt;
    Cc: Georgi Djakov &lt;georgi.djakov@linaro.org&gt;
    Cc: Vlastimil Babka &lt;vbabka@suse.cz&gt;
    Cc: Joonsoo Kim &lt;iamjoonsoo.kim@lge.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index ec2e67c85b84..ce860ab94162 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -470,7 +470,12 @@ static bool match_str_list(const char *str, char **list, int list_size)
 
 static bool is_need(char *buf)
 {
-	if ((filter &amp; FILTER_UNRELEASE) &amp;&amp; get_free_ts_nsec(buf) != 0)
+	__u64 ts_nsec, free_ts_nsec;
+
+	ts_nsec = get_ts_nsec(buf);
+	free_ts_nsec = get_free_ts_nsec(buf);
+
+	if ((filter &amp; FILTER_UNRELEASE) &amp;&amp; free_ts_nsec != 0 &amp;&amp; ts_nsec &lt; free_ts_nsec)
 		return false;
 	if ((filter &amp; FILTER_PID) &amp;&amp; !match_num_list(get_pid(buf), fc.pids, fc.pids_size))
 		return false;</pre><hr><pre>commit 9b7a4039d6856f66521486da68c76838929039eb
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Mon Jul 18 03:55:06 2022 +0800

    tools/vm/page_owner_sort.c: adjust the indent in is_need()
    
    I noticed one more indentation than necessary in is_need().
    
    Link: https://lkml.kernel.org/r/20220717195506.7602-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index 74c3dcecf64d..ec2e67c85b84 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -470,23 +470,23 @@ static bool match_str_list(const char *str, char **list, int list_size)
 
 static bool is_need(char *buf)
 {
-		if ((filter &amp; FILTER_UNRELEASE) &amp;&amp; get_free_ts_nsec(buf) != 0)
-			return false;
-		if ((filter &amp; FILTER_PID) &amp;&amp; !match_num_list(get_pid(buf), fc.pids, fc.pids_size))
-			return false;
-		if ((filter &amp; FILTER_TGID) &amp;&amp;
-			!match_num_list(get_tgid(buf), fc.tgids, fc.tgids_size))
-			return false;
-
-		char *comm = get_comm(buf);
-
-		if ((filter &amp; FILTER_COMM) &amp;&amp;
-		!match_str_list(comm, fc.comms, fc.comms_size)) {
-			free(comm);
-			return false;
-		}
+	if ((filter &amp; FILTER_UNRELEASE) &amp;&amp; get_free_ts_nsec(buf) != 0)
+		return false;
+	if ((filter &amp; FILTER_PID) &amp;&amp; !match_num_list(get_pid(buf), fc.pids, fc.pids_size))
+		return false;
+	if ((filter &amp; FILTER_TGID) &amp;&amp;
+		!match_num_list(get_tgid(buf), fc.tgids, fc.tgids_size))
+		return false;
+
+	char *comm = get_comm(buf);
+
+	if ((filter &amp; FILTER_COMM) &amp;&amp;
+	!match_str_list(comm, fc.comms, fc.comms_size)) {
 		free(comm);
-		return true;
+		return false;
+	}
+	free(comm);
+	return true;
 }
 
 static void add_list(char *buf, int len, char *ext_buf)</pre><hr><pre>commit e6bd91a7a45e750b471a24496a7c1a612c0ce899
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Sat Jul 9 01:23:51 2022 +0800

    Documentation/translations/zh_CN/mm/page_owner.rst: adjust some words
    
    I noticed that there are some Chinese words that can be more accurate.
    So I fix them as follows.
    
    首先，英文原文中的"release" 在这个语境下
    是物理页面“释放”的意思，而不是“发布”。
    其次，标准表的第一列和第二列，
    表达的是“长短键”的意思，第一列是“短键”，
    而第二列是“长键”。这样翻译或会更清晰一些。
    
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Acked-by: Yanteng Si&lt;siyanteng@loongson.cn&gt;
    Link: https://lore.kernel.org/r/20220708172351.20928-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Jonathan Corbet &lt;corbet@lwn.net&gt;

diff --git a/Documentation/translations/zh_CN/vm/page_owner.rst b/Documentation/translations/zh_CN/vm/page_owner.rst
index 0034d2ae1cd5..7bd740bc5bf4 100644
--- a/Documentation/translations/zh_CN/vm/page_owner.rst
+++ b/Documentation/translations/zh_CN/vm/page_owner.rst
@@ -156,22 +156,22 @@ page owner在默认情况下是禁用的。所以，如果你想使用它，你
 
   --sort的选项:
 
-	键		键长		描述
+	短键		长键		描述
 	p		pid		进程ID
 	tg		tgid		线程组ID
 	n		name		任务命令名称
 	st		stacktrace	页面分配的堆栈跟踪
 	T		txt		块的全文
-	ft		free_ts		页面发布时的时间戳
+	ft		free_ts		页面释放时的时间戳
 	at		alloc_ts	页面被分配时的时间戳
 	ator		allocator	页面的内存分配器
 
   --curl的选项:
 
-	键		键长		描述
+	短键		长键		描述
 	p		pid		进程ID
 	tg		tgid		线程组ID
 	n		name		任务命令名称
-	f		free		该页是否已经发布
+	f		free		该页是否已经释放
 	st		stacktrace	页面分配的堆栈跟踪
 	ator		allocator	页面的内存分配器</pre><hr><pre>commit 98af39d52e336b2d7d7be67ac405f978d81f65b8
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Thu Apr 28 23:16:00 2022 -0700

    mm/vmalloc: fix a comment
    
    The sentence
    "but the mempolcy want to alloc memory by interleaving"
    should be rephrased with
    "but the mempolicy wants to alloc memory by interleaving"
    where "mempolicy" is a struct name.
    
    This work is coauthored by
    Yinan Zhang
    Jiajian Ye
    Shenghong Han
    Chongxi Zhao
    Yuhong Feng
    Yongqiang Liu
    
    Link: https://lkml.kernel.org/r/20220401064543.4447-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index cadfbb5155ea..9d68ac51a19d 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -2895,7 +2895,7 @@ vm_area_alloc_pages(gfp_t gfp, int nid,
 			/* memory allocation should consider mempolicy, we can't
 			 * wrongly use nearest node when nid == NUMA_NO_NODE,
 			 * otherwise memory may be allocated in only one node,
-			 * but mempolcy want to alloc memory by interleaving.
+			 * but mempolicy wants to alloc memory by interleaving.
 			 */
 			if (IS_ENABLED(CONFIG_NUMA) &amp;&amp; nid == NUMA_NO_NODE)
 				nr = alloc_pages_bulk_array_mempolicy(bulk_gfp,</pre><hr><pre>commit c7c4ab859642830a14c45785ca7866659b65fc44
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Thu Apr 28 23:15:57 2022 -0700

    tools/vm/page_owner_sort.c: avoid repeated judgments
    
    I noticed a detail that needs to be adjusted.  When judging whether a page
    is allocated by vmalloc, the value of the variable "tmp" was repeatedly
    judged, so the code was adjusted.
    
    This work is coauthored by Yinan Zhang, Jiajian Ye, Shenghong Han, Chongxi
    Zhao, Yuhong Feng and Yongqiang Liu.
    
    Link: https://lkml.kernel.org/r/20220414042744.13896-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Haowen Bai &lt;baihaowen@meizu.com&gt;
    Cc: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Cc: Shenghong Han &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Yongqiang Liu &lt;liuyongqiang13@huawei.com&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index fa2e4d2a9d68..c149427eb1c9 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -444,10 +444,8 @@ static int get_allocator(const char *buf, const char *migrate_info)
 			tmp--;
 		first_line = ++tmp;
 		tmp = strstr(tmp, "alloc_pages");
-		if (tmp) {
-			if (tmp &amp;&amp; first_line &lt;= tmp &amp;&amp; tmp &lt; second_line)
-				allocator |= ALLOCATOR_VMALLOC;
-		}
+		if (tmp &amp;&amp; first_line &lt;= tmp &amp;&amp; tmp &lt; second_line)
+			allocator |= ALLOCATOR_VMALLOC;
 	}
 	if (allocator == 0)
 		allocator = ALLOCATOR_OTHERS;</pre><hr><pre>commit f09654bb88127473b4baf3bc0b68d4d4695aca7b
Author: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
Date:   Thu Apr 28 23:15:57 2022 -0700

    tools/vm/page_owner_sort.c: provide allocator labelling and update --cull and --sort options
    
    An application is suspected of having memory leak when its memory
    consumption is high and keeps increasing.  There are several commonly used
    memory allocators: slab, cma, vmalloc, etc.  The memory leak
    identification can be sped up if the page information allocated by an
    allocator can be analyzed separately.
    
    This patch provides supports for memory allocator labelling for slab,
    vmalloc, and cma.  The pages allocated by slab and cma can be confirmed
    from the "PFN" line according to the kernel codes, and the label of the
    vmalloc allocator can be obtained by analyzing the stack trace.  Thanks
    for Vlastimil Babka's constructive suggestions.
    
    Based on Yinan Zhang's study, the call chain of vmalloc() is vmalloc() -&gt;
    ...  -&gt; __vmalloc_node_range() -&gt; __vmalloc_area_node().
    __vmalloc_area_node() requests memory through the interface of buddy
    allocation system.  In the current version, __vmalloc_area_node() uses
    four interfaces: alloc_pages_bulk_array_mempolicy(),
    alloc_pages_bulk_array_node(), alloc_pages() and alloc_pages_node().  By
    disassembling the code, we find that __vmalloc_area_node() is expanded in
    __vmalloc_node_range().  So __vmalloc_area_node is not in the stack trace.
    
    On the test machine, the stack trace of pages allocated by vmalloc has the
    following four forms:
    
    __alloc_pages_bulk+0x230/0x6a0
    __vmalloc_node_range+0x19c/0x598
    
    alloc_pages_bulk_array_mempolicy+0xbc/0x278
    __vmalloc_node_range+0x1e8/0x598
    
    __alloc_pages+0x160/0x2b0
    __vmalloc_node_range+0x234/0x598
    
    alloc_pages+0xac/0x150
    __vmalloc_node_range+0x44c/0x598
    
    Therefore, in two consecutive lines of stacktrace, if the first line
    contains the word "alloc_pages" and the second line contains the word
    "__vmalloc_node_range", it can be determined that the page is allocated by
    vmalloc.  And the function offset and size are not the same on different
    machines, so there is no need to match them.
    
    At the same time, this patch updates the --cull and --sort options to
    support allocator-based merge statistics and sorting.  The added functions
    are fully compatible with the original work.  When using, you can use
    "allocator", or abbreviated as "ator".  Relevant updates have also been
    made in the documentation(Documentation/vm/page_owner.rst).
    
    Example:
    ./page_owner_sort &lt;input&gt; &lt;output&gt; --cull=st,pid,name,allocator
    ./page_owner_sort &lt;input&gt; &lt;output&gt; --sort=ator,pid,name
    
    This work is coauthored by Jiajian Ye, Yinan Zhang, Shenghong Han,
    Chongxi Zhao, Yuhong Feng and Yongqiang Liu.
    
    Link: https://lkml.kernel.org/r/20220410132932.9402-1-caoyixuan2019@email.szu.edu.cn
    Signed-off-by: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Haowen Bai &lt;baihaowen@meizu.com&gt;
    Cc: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Cc: Shenghong Han &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Yongqiang Liu &lt;liuyongqiang13@huawei.com&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index 523bf3419512..25622c715823 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -183,6 +183,7 @@ For --sort option:
 	T		txt		full text of block
 	ft		free_ts		timestamp of the page when it was released
 	at		alloc_ts	timestamp of the page when it was allocated
+        ator            allocator       memory allocator for pages
 
 For --curl option:
 
@@ -192,4 +193,4 @@ For --curl option:
 	n		name		task command name
 	f		free		whether the page has been released or not
 	st		stacktrace	stack trace of the page allocation
-
+        ator            allocator       memory allocator for pages
diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index a32e446e5bb2..fa2e4d2a9d68 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -39,6 +39,7 @@ struct block_list {
 	int page_num;
 	pid_t pid;
 	pid_t tgid;
+	int allocator;
 };
 enum FILTER_BIT {
 	FILTER_UNRELEASE = 1&lt;&lt;1,
@@ -51,11 +52,19 @@ enum CULL_BIT {
 	CULL_PID = 1&lt;&lt;2,
 	CULL_TGID = 1&lt;&lt;3,
 	CULL_COMM = 1&lt;&lt;4,
-	CULL_STACKTRACE = 1&lt;&lt;5
+	CULL_STACKTRACE = 1&lt;&lt;5,
+	CULL_ALLOCATOR = 1&lt;&lt;6
+};
+enum ALLOCATOR_BIT {
+	ALLOCATOR_CMA = 1&lt;&lt;1,
+	ALLOCATOR_SLAB = 1&lt;&lt;2,
+	ALLOCATOR_VMALLOC = 1&lt;&lt;3,
+	ALLOCATOR_OTHERS = 1&lt;&lt;4
 };
 enum ARG_TYPE {
 	ARG_TXT, ARG_COMM, ARG_STACKTRACE, ARG_ALLOC_TS, ARG_FREE_TS,
-	ARG_CULL_TIME, ARG_PAGE_NUM, ARG_PID, ARG_TGID, ARG_UNKNOWN, ARG_FREE
+	ARG_CULL_TIME, ARG_PAGE_NUM, ARG_PID, ARG_TGID, ARG_UNKNOWN, ARG_FREE,
+	ARG_ALLOCATOR
 };
 enum SORT_ORDER {
 	SORT_ASC = 1,
@@ -89,15 +98,20 @@ static int cull;
 static int filter;
 static bool debug_on;
 
-int read_block(char *buf, int buf_size, FILE *fin)
+static void set_single_cmp(int (*cmp)(const void *, const void *), int sign);
+
+int read_block(char *buf, char *ext_buf, int buf_size, FILE *fin)
 {
 	char *curr = buf, *const buf_end = buf + buf_size;
 
 	while (buf_end - curr &gt; 1 &amp;&amp; fgets(curr, buf_end - curr, fin)) {
-		if (*curr == '\n') /* empty line */
+		if (*curr == '\n') { /* empty line */
 			return curr - buf;
-		if (!strncmp(curr, "PFN", 3))
+		}
+		if (!strncmp(curr, "PFN", 3)) {
+			strcpy(ext_buf, curr);
 			continue;
+		}
 		curr += strlen(curr);
 	}
 
@@ -146,6 +160,13 @@ static int compare_tgid(const void *p1, const void *p2)
 	return l1-&gt;tgid - l2-&gt;tgid;
 }
 
+static int compare_allocator(const void *p1, const void *p2)
+{
+	const struct block_list *l1 = p1, *l2 = p2;
+
+	return l1-&gt;allocator - l2-&gt;allocator;
+}
+
 static int compare_comm(const void *p1, const void *p2)
 {
 	const struct block_list *l1 = p1, *l2 = p2;
@@ -192,6 +213,8 @@ static int compare_cull_condition(const void *p1, const void *p2)
 		return compare_comm(p1, p2);
 	if ((cull &amp; CULL_UNRELEASE) &amp;&amp; compare_release(p1, p2))
 		return compare_release(p1, p2);
+	if ((cull &amp; CULL_ALLOCATOR) &amp;&amp; compare_allocator(p1, p2))
+		return compare_allocator(p1, p2);
 	return 0;
 }
 
@@ -395,11 +418,42 @@ static int get_arg_type(const char *arg)
 		return ARG_FREE_TS;
 	else if (!strcmp(arg, "alloc_ts") || !strcmp(arg, "at"))
 		return ARG_ALLOC_TS;
+	else if (!strcmp(arg, "allocator") || !strcmp(arg, "ator"))
+		return ARG_ALLOCATOR;
 	else {
 		return ARG_UNKNOWN;
 	}
 }
 
+static int get_allocator(const char *buf, const char *migrate_info)
+{
+	char *tmp, *first_line, *second_line;
+	int allocator = 0;
+
+	if (strstr(migrate_info, "CMA"))
+		allocator |= ALLOCATOR_CMA;
+	if (strstr(migrate_info, "slab"))
+		allocator |= ALLOCATOR_SLAB;
+	tmp = strstr(buf, "__vmalloc_node_range");
+	if (tmp) {
+		second_line = tmp;
+		while (*tmp != '\n')
+			tmp--;
+		tmp--;
+		while (*tmp != '\n')
+			tmp--;
+		first_line = ++tmp;
+		tmp = strstr(tmp, "alloc_pages");
+		if (tmp) {
+			if (tmp &amp;&amp; first_line &lt;= tmp &amp;&amp; tmp &lt; second_line)
+				allocator |= ALLOCATOR_VMALLOC;
+		}
+	}
+	if (allocator == 0)
+		allocator = ALLOCATOR_OTHERS;
+	return allocator;
+}
+
 static bool match_num_list(int num, int *list, int list_size)
 {
 	for (int i = 0; i &lt; list_size; ++i)
@@ -437,7 +491,7 @@ static bool is_need(char *buf)
 		return true;
 }
 
-static void add_list(char *buf, int len)
+static void add_list(char *buf, int len, char *ext_buf)
 {
 	if (list_size != 0 &amp;&amp;
 		len == list[list_size-1].len &amp;&amp;
@@ -471,6 +525,7 @@ static void add_list(char *buf, int len)
 		list[list_size].stacktrace++;
 	list[list_size].ts_nsec = get_ts_nsec(buf);
 	list[list_size].free_ts_nsec = get_free_ts_nsec(buf);
+	list[list_size].allocator = get_allocator(buf, ext_buf);
 	list_size++;
 	if (list_size % 1000 == 0) {
 		printf("loaded %d\r", list_size);
@@ -496,12 +551,16 @@ static bool parse_cull_args(const char *arg_str)
 			cull |= CULL_STACKTRACE;
 		else if (arg_type == ARG_FREE)
 			cull |= CULL_UNRELEASE;
+		else if (arg_type == ARG_ALLOCATOR)
+			cull |= CULL_ALLOCATOR;
 		else {
 			free_explode(args, size);
 			return false;
 		}
 	}
 	free_explode(args, size);
+	if (sc.size == 0)
+		set_single_cmp(compare_num, SORT_DESC);
 	return true;
 }
 
@@ -556,6 +615,8 @@ static bool parse_sort_args(const char *arg_str)
 			sc.cmps[i] = compare_free_ts;
 		else if (arg_type == ARG_TXT)
 			sc.cmps[i] = compare_txt;
+		else if (arg_type == ARG_ALLOCATOR)
+			sc.cmps[i] = compare_allocator;
 		else {
 			free_explode(args, size);
 			sc.size = 0;
@@ -588,6 +649,19 @@ static int *parse_nums_list(char *arg_str, int *list_size)
 	return list;
 }
 
+static void print_allocator(FILE *out, int allocator)
+{
+	fprintf(out, "allocated by ");
+	if (allocator &amp; ALLOCATOR_CMA)
+		fprintf(out, "CMA ");
+	if (allocator &amp; ALLOCATOR_SLAB)
+		fprintf(out, "SLAB ");
+	if (allocator &amp; ALLOCATOR_VMALLOC)
+		fprintf(out, "VMALLOC ");
+	if (allocator &amp; ALLOCATOR_OTHERS)
+		fprintf(out, "OTHERS ");
+}
+
 #define BUF_SIZE	(128 * 1024)
 
 static void usage(void)
@@ -614,8 +688,8 @@ static void usage(void)
 int main(int argc, char **argv)
 {
 	FILE *fin, *fout;
-	char *buf;
-	int ret, i, count;
+	char *buf, *ext_buf;
+	int i, count;
 	struct stat st;
 	int opt;
 	struct option longopts[] = {
@@ -724,16 +798,18 @@ int main(int argc, char **argv)
 
 	list = malloc(max_size * sizeof(*list));
 	buf = malloc(BUF_SIZE);
-	if (!list || !buf) {
+	ext_buf = malloc(BUF_SIZE);
+	if (!list || !buf || !ext_buf) {
 		fprintf(stderr, "Out of memory\n");
 		exit(1);
 	}
 
 	for ( ; ; ) {
-		ret = read_block(buf, BUF_SIZE, fin);
-		if (ret &lt; 0)
+		int buf_len = read_block(buf, ext_buf, BUF_SIZE, fin);
+
+		if (buf_len &lt; 0)
 			break;
-		add_list(buf, ret);
+		add_list(buf, buf_len, ext_buf);
 	}
 
 	printf("loaded %d\n", list_size);
@@ -757,9 +833,11 @@ int main(int argc, char **argv)
 	qsort(list, count, sizeof(list[0]), compare_sort_condition);
 
 	for (i = 0; i &lt; count; i++) {
-		if (cull == 0)
-			fprintf(fout, "%d times, %d pages:\n%s\n",
-					list[i].num, list[i].page_num, list[i].txt);
+		if (cull == 0) {
+			fprintf(fout, "%d times, %d pages, ", list[i].num, list[i].page_num);
+			print_allocator(fout, list[i].allocator);
+			fprintf(fout, ":\n%s\n", list[i].txt);
+		}
 		else {
 			fprintf(fout, "%d times, %d pages",
 					list[i].num, list[i].page_num);
@@ -769,6 +847,10 @@ int main(int argc, char **argv)
 				fprintf(fout, ", TGID %d", list[i].pid);
 			if (cull &amp; CULL_COMM || filter &amp; FILTER_COMM)
 				fprintf(fout, ", task_comm_name: %s", list[i].comm);
+			if (cull &amp; CULL_ALLOCATOR) {
+				fprintf(fout, ", ");
+				print_allocator(fout, list[i].allocator);
+			}
 			if (cull &amp; CULL_UNRELEASE)
 				fprintf(fout, " (%s)",
 						list[i].free_ts_nsec ? "UNRELEASED" : "RELEASED");</pre><hr><pre>commit ebbeae36387ccf1326c896167872c3acf6c3c956
Author: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
Date:   Thu Apr 28 23:15:57 2022 -0700

    tools/vm/page_owner_sort.c: support sorting blocks by multiple keys
    
    When viewing page owner information, we may want to sort blocks of
    information by multiple keys, since one single key does not uniquely
    identify a block. Therefore, following adjustments are made:
    
    1. Add a new --sort option to support sorting blocks of information by
    multiple keys.
    
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --sort=&lt;order&gt;
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --sort &lt;order&gt;
    
    &lt;order&gt; is a single argument in the form of a comma-separated list,
    which offers a way to specify sorting order.
    
    Sorting syntax is [+|-]key[,[+|-]key[,...]]. The ascending or descending
    order can be specified by adding the + (ascending, default) or - (descend
    -ing) prefix to the key:
    
            ./page_owner_sort &lt;input&gt; &lt;output&gt; [option] --sort -key1,+key2,key3...
    
    For example, to sort the blocks first by task command name in lexicographic
    order and then by pid in ascending numerical order, use the following:
    
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --sort=name,+pid
    
    To sort the blocks first by pid in ascending order and then by timestamp
    of the page when it is allocated in descending order, use the following:
    
            ./page_owner_sort &lt;input&gt; &lt;output&gt; --sort=pid,-alloc_ts
    
    2. Add explanations of a newly added --sort option in the function usage()
    and the document(Documentation/vm/page_owner.rst).
    
    This work is coauthored by
            Yixuan Cao
            Shenghong Han
            Yinan Zhang
            Chongxi Zhao
            Yuhong Feng
            Yongqiang Liu
    
    Link: https://lkml.kernel.org/r/20220401024856.767-3-yejiajian2018@email.szu.edu.cn
    Signed-off-by: Jiajian Ye &lt;yejiajian2018@email.szu.edu.cn&gt;
    Cc: Chongxi Zhao &lt;zhaochongxi2019@email.szu.edu.cn&gt;
    Cc: Shenghong Han &lt;hanshenghong2019@email.szu.edu.cn&gt;
    Cc: Yinan Zhang &lt;zhangyinan2019@email.szu.edu.cn&gt;
    Cc: Yixuan Cao &lt;caoyixuan2019@email.szu.edu.cn&gt;
    Cc: Yongqiang Liu &lt;liuyongqiang13@huawei.com&gt;
    Cc: Yuhong Feng &lt;yuhongf@szu.edu.cn&gt;
    Cc: Haowen Bai &lt;baihaowen@meizu.com&gt;
    Cc: Sean Anderson &lt;seanga2@gmail.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/Documentation/vm/page_owner.rst b/Documentation/vm/page_owner.rst
index 3102f91d635c..523bf3419512 100644
--- a/Documentation/vm/page_owner.rst
+++ b/Documentation/vm/page_owner.rst
@@ -121,6 +121,14 @@ Usage
 		-r		Sort by memory release time.
 		-s		Sort by stack trace.
 		-t		Sort by times (default).
+		--sort &lt;order&gt;	Specify sorting order.  Sorting syntax is [+|-]key[,[+|-]key[,...]].
+				Choose a key from the **STANDARD FORMAT SPECIFIERS** section. The "+" is
+				optional since default direction is increasing numerical or lexicographic
+				order. Mixed use of abbreviated and complete-form of keys is allowed.
+
+		Examples:
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --sort=n,+pid,-tgid
+				./page_owner_sort &lt;input&gt; &lt;output&gt; --sort=at
 
    additional function::
 
@@ -165,9 +173,23 @@ STANDARD FORMAT SPECIFIERS
 ==========================
 ::
 
+For --sort option:
+
+	KEY		LONG		DESCRIPTION
+	p		pid		process ID
+	tg		tgid		thread group ID
+	n		name		task command name
+	st		stacktrace	stack trace of the page allocation
+	T		txt		full text of block
+	ft		free_ts		timestamp of the page when it was released
+	at		alloc_ts	timestamp of the page when it was allocated
+
+For --curl option:
+
 	KEY		LONG		DESCRIPTION
 	p		pid		process ID
 	tg		tgid		thread group ID
 	n		name		task command name
 	f		free		whether the page has been released or not
-	st		stacktrace	stace trace of the page allocation
+	st		stacktrace	stack trace of the page allocation
+
diff --git a/tools/vm/page_owner_sort.c b/tools/vm/page_owner_sort.c
index 16fb034c6a4e..beca990707fb 100644
--- a/tools/vm/page_owner_sort.c
+++ b/tools/vm/page_owner_sort.c
@@ -53,15 +53,29 @@ enum CULL_BIT {
 	CULL_COMM = 1&lt;&lt;4,
 	CULL_STACKTRACE = 1&lt;&lt;5
 };
+enum ARG_TYPE {
+	ARG_TXT, ARG_COMM, ARG_STACKTRACE, ARG_ALLOC_TS, ARG_FREE_TS,
+	ARG_CULL_TIME, ARG_PAGE_NUM, ARG_PID, ARG_TGID, ARG_UNKNOWN, ARG_FREE
+};
+enum SORT_ORDER {
+	SORT_ASC = 1,
+	SORT_DESC = -1,
+};
 struct filter_condition {
-	pid_t *tgids;
-	int tgids_size;
 	pid_t *pids;
-	int pids_size;
+	pid_t *tgids;
 	char **comms;
+	int pids_size;
+	int tgids_size;
 	int comms_size;
 };
+struct sort_condition {
+	int (**cmps)(const void *, const void *);
+	int *signs;
+	int size;
+};
 static struct filter_condition fc;
+static struct sort_condition sc;
 static regex_t order_pattern;
 static regex_t pid_pattern;
 static regex_t tgid_pattern;
@@ -107,14 +121,14 @@ static int compare_num(const void *p1, const void *p2)
 {
 	const struct block_list *l1 = p1, *l2 = p2;
 
-	return l2-&gt;num - l1-&gt;num;
+	return l1-&gt;num - l2-&gt;num;
 }
 
 static int compare_page_num(const void *p1, const void *p2)
 {
 	const struct block_list *l1 = p1, *l2 = p2;
 
-	return l2-&gt;page_num - l1-&gt;page_num;
+	return l1-&gt;page_num - l2-&gt;page_num;
 }
 
 static int compare_pid(const void *p1, const void *p2)
@@ -180,6 +194,16 @@ static int compare_cull_condition(const void *p1, const void *p2)
 	return 0;
 }
 
+static int compare_sort_condition(const void *p1, const void *p2)
+{
+	int cmp = 0;
+
+	for (int i = 0; i &lt; sc.size; ++i)
+		if (cmp == 0)
+			cmp = sc.signs[i] * sc.cmps[i](p1, p2);
+	return cmp;
+}
+
 static int search_pattern(regex_t *pattern, char *pattern_str, char *buf)
 {
 	int err, val_len;
@@ -345,6 +369,29 @@ static char *get_comm(char *buf)
 	return comm_str;
 }
 
+static int get_arg_type(const char *arg)
+{
+	if (!strcmp(arg, "pid") || !strcmp(arg, "p"))
+		return ARG_PID;
+	else if (!strcmp(arg, "tgid") || !strcmp(arg, "tg"))
+		return ARG_TGID;
+	else if (!strcmp(arg, "name") || !strcmp(arg, "n"))
+		return  ARG_COMM;
+	else if (!strcmp(arg, "stacktrace") || !strcmp(arg, "st"))
+		return ARG_STACKTRACE;
+	else if (!strcmp(arg, "free") || !strcmp(arg, "f"))
+		return ARG_FREE;
+	else if (!strcmp(arg, "txt") || !strcmp(arg, "T"))
+		return ARG_TXT;
+	else if (!strcmp(arg, "free_ts") || !strcmp(arg, "ft"))
+		return ARG_FREE_TS;
+	else if (!strcmp(arg, "alloc_ts") || !strcmp(arg, "at"))
+		return ARG_ALLOC_TS;
+	else {
+		return ARG_UNKNOWN;
+	}
+}
+
 static bool match_num_list(int num, int *list, int list_size)
 {
 	for (int i = 0; i &lt; list_size; ++i)
@@ -428,21 +475,86 @@ static bool parse_cull_args(const char *arg_str)
 	int size = 0;
 	char **args = explode(',', arg_str, &amp;size);
 
-	for (int i = 0; i &lt; size; ++i)
-		if (!strcmp(args[i], "pid") || !strcmp(args[i], "p"))
+	for (int i = 0; i &lt; size; ++i) {
+		int arg_type = get_arg_type(args[i]);
+
+		if (arg_type == ARG_PID)
 			cull |= CULL_PID;
-		else if (!strcmp(args[i], "tgid") || !strcmp(args[i], "tg"))
+		else if (arg_type == ARG_TGID)
 			cull |= CULL_TGID;
-		else if (!strcmp(args[i], "name") || !strcmp(args[i], "n"))
+		else if (arg_type == ARG_COMM)
 			cull |= CULL_COMM;
-		else if (!strcmp(args[i], "stacktrace") || !strcmp(args[i], "st"))
+		else if (arg_type == ARG_STACKTRACE)
 			cull |= CULL_STACKTRACE;
-		else if (!strcmp(args[i], "free") || !strcmp(args[i], "f"))
+		else if (arg_type == ARG_FREE)
 			cull |= CULL_UNRELEASE;
 		else {
 			free_explode(args, size);
 			return false;
 		}
+	}
+	free_explode(args, size);
+	return true;
+}
+
+static void set_single_cmp(int (*cmp)(const void *, const void *), int sign)
+{
+	if (sc.signs == NULL || sc.size &lt; 1)
+		sc.signs = calloc(1, sizeof(int));
+	sc.signs[0] = sign;
+	if (sc.cmps == NULL || sc.size &lt; 1)
+		sc.cmps = calloc(1, sizeof(int *));
+	sc.cmps[0] = cmp;
+	sc.size = 1;
+}
+
+static bool parse_sort_args(const char *arg_str)
+{
+	int size = 0;
+
+	if (sc.size != 0) { /* reset sort_condition */
+		free(sc.signs);
+		free(sc.cmps);
+		size = 0;
+	}
+
+	char **args = explode(',', arg_str, &amp;size);
+
+	sc.signs = calloc(size, sizeof(int));
+	sc.cmps = calloc(size, sizeof(int *));
+	for (int i = 0; i &lt; size; ++i) {
+		int offset = 0;
+
+		sc.signs[i] = SORT_ASC;
+		if (args[i][0] == '-' || args[i][0] == '+') {
+			if (args[i][0] == '-')
+				sc.signs[i] = SORT_DESC;
+			offset = 1;
+		}
+
+		int arg_type = get_arg_type(args[i]+offset);
+
+		if (arg_type == ARG_PID)
+			sc.cmps[i] = compare_pid;
+		else if (arg_type == ARG_TGID)
+			sc.cmps[i] = compare_tgid;
+		else if (arg_type == ARG_COMM)
+			sc.cmps[i] = compare_comm;
+		else if (arg_type == ARG_STACKTRACE)
+			sc.cmps[i] = compare_stacktrace;
+		else if (arg_type == ARG_ALLOC_TS)
+			sc.cmps[i] = compare_ts;
+		else if (arg_type == ARG_FREE_TS)
+			sc.cmps[i] = compare_free_ts;
+		else if (arg_type == ARG_TXT)
+			sc.cmps[i] = compare_txt;
+		else {
+			free_explode(args, size);
+			sc.size = 0;
+			return false;
+		}
+	}
+	sc.size = size;
 	free_explode(args, size);
 	return true;
 }
@@ -485,13 +597,13 @@ static void usage(void)
 		"--pid &lt;pidlist&gt;\tSelect by pid. This selects the information of blocks whose process ID numbers appear in &lt;pidlist&gt;.\n"
 		"--tgid &lt;tgidlist&gt;\tSelect by tgid. This selects the information of blocks whose Thread Group ID numbers appear in &lt;tgidlist&gt;.\n"
 		"--name &lt;cmdlist&gt;\n\t\tSelect by command name. This selects the information of blocks whose command name appears in &lt;cmdlist&gt;.\n"
-		"--cull &lt;rules&gt;\tCull by user-defined rules. &lt;rules&gt; is a single argument in the form of a comma-separated list with some common fields predefined\n"
+		"--cull &lt;rules&gt;\tCull by user-defined rules.&lt;rules&gt; is a single argument in the form of a comma-separated list with some common fields predefined\n"
+		"--sort &lt;order&gt;\tSpecify sort order as: [+|-]key[,[+|-]key[,...]]\n"
 	);
 }
 
 int main(int argc, char **argv)
 {
-	int (*cmp)(const void *, const void *) = compare_num;
 	FILE *fin, *fout;
 	char *buf;
 	int ret, i, count;
@@ -502,37 +614,38 @@ int main(int argc, char **argv)
 		{ "tgid", required_argument, NULL, 2 },
 		{ "name", required_argument, NULL, 3 },
 		{ "cull",  required_argument, NULL, 4 },
+		{ "sort",  required_argument, NULL, 5 },
 		{ 0, 0, 0, 0},
 	};
 
 	while ((opt = getopt_long(argc, argv, "afmnprstP", longopts, NULL)) != -1)
 		switch (opt) {
 		case 'a':
-			cmp = compare_ts;
+			set_single_cmp(compare_ts, SORT_ASC);
 			break;
 		case 'f':
 			filter = filter | FILTER_UNRELEASE;
 			break;
 		case 'm':
-			cmp = compare_page_num;
+			set_single_cmp(compare_page_num, SORT_DESC);
 			break;
 		case 'p':
-			cmp = compare_pid;
+			set_single_cmp(compare_pid, SORT_ASC);
 			break;
 		case 'r':
-			cmp = compare_free_ts;
+			set_single_cmp(compare_free_ts, SORT_ASC);
 			break;
 		case 's':
-			cmp = compare_stacktrace;
+			set_single_cmp(compare_stacktrace, SORT_ASC);
 			break;
 		case 't':
-			cmp = compare_num;
+			set_single_cmp(compare_num, SORT_DESC);
 			break;
 		case 'P':
-			cmp = compare_tgid;
+			set_single_cmp(compare_tgid, SORT_ASC);
 			break;
 		case 'n':
-			cmp = compare_comm;
+			set_single_cmp(compare_comm, SORT_ASC);
 			break;
 		case 1:
 			filter = filter | FILTER_PID;
@@ -563,6 +676,13 @@ int main(int argc, char **argv)
 				exit(1);
 			}
 			break;
+		case 5:
+			if (!parse_sort_args(optarg)) {
+				fprintf(stderr, "wrong argument after --sort option:%s\n",
+						optarg);
+				exit(1);
+			}
+			break;
 		default:
 			usage();
 			exit(1);
@@ -622,7 +742,7 @@ int main(int argc, char **argv)
 		}
 	}
 
-	qsort(list, count, sizeof(list[0]), cmp);
+	qsort(list, count, sizeof(list[0]), compare_sort_condition);
 
 	for (i = 0; i &lt; count; i++) {
 		if (cull == 0)</pre>
    <div class="pagination">
        <span>[1]</span><a href='21_2.html'>2</a><a href='21_3.html'>3</a><a href='21_4.html'>4</a><a href='21_2.html'>Next&gt;&gt;</a>
    <div>
</body>
