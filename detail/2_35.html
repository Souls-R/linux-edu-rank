<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_34.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><span>[35]</span><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_36.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 6753f4cf29046f4a2ae68c3a93bf6e6e6dce9fb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 1 17:09:28 2013 -0400

    USB: EHCI: don't depend on hardware for tracking port resets and resumes
    
    In theory, an EHCI controller can turn off the PORT_RESUME or
    PORT_RESET bits in a port status register all by itself (and some
    controllers actually do this).  We shouldn't depend on these bits
    being set correctly.
    
    This patch rearranges the code in ehci-hcd that handles completion of
    port resets and resumes.  We guarantee that ehci-&gt;reset_done[portnum]
    is nonzero if a reset or resume is in progress, and that the portnum
    bit is set in ehci-&gt;resuming_ports if the operation is a resume.  (To
    help enforce this guarantee, the patch prevents suspended ports from
    being reset.)  Therefore it's not necessary to look at the port status
    bits to learn what's going on.
    
    The patch looks bigger than it really is, because it changes the
    indentation level of a sizeable region of code.  Most of what it
    actually does is interchange some tests.  The only functional changes
    are testing reset_done and resuming_ports rather than PORT_RESUME and
    PORT_RESET, removing a now-unnecessary check for spontaneous
    resets of the PORT_RESUME and PORT_RESET bits, and preventing a
    suspended or resuming port from being reset.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6d0e59306ed9..6e69ee1a3371 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -867,11 +867,11 @@ static int ehci_hub_control (
 			}
 		}
 
-		/* whoever resumes must GetPortStatus to complete it!! */
-		if (temp &amp; PORT_RESUME) {
+		/* no reset or resume pending */
+		if (!ehci-&gt;reset_done[wIndex]) {
 
 			/* Remote Wakeup received? */
-			if (!ehci-&gt;reset_done[wIndex]) {
+			if (temp &amp; PORT_RESUME) {
 				/* resume signaling for 20 msec */
 				ehci-&gt;reset_done[wIndex] = jiffies
 						+ msecs_to_jiffies(20);
@@ -882,35 +882,32 @@ static int ehci_hub_control (
 						ehci-&gt;reset_done[wIndex]);
 			}
 
-			/* resume completed? */
-			else if (time_after_eq(jiffies,
-					ehci-&gt;reset_done[wIndex])) {
-				clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
-				set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
-				ehci-&gt;reset_done[wIndex] = 0;
-				usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
-
-				/* stop resume signaling */
-				temp &amp;= ~(PORT_RWC_BITS |
-						PORT_SUSPEND | PORT_RESUME);
-				ehci_writel(ehci, temp, status_reg);
-				clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
-				retval = ehci_handshake(ehci, status_reg,
-					   PORT_RESUME, 0, 2000 /* 2msec */);
-				if (retval != 0) {
-					ehci_err(ehci,
-						"port %d resume error %d\n",
+		/* reset or resume not yet complete */
+		} else if (!time_after_eq(jiffies, ehci-&gt;reset_done[wIndex])) {
+			;	/* wait until it is complete */
+
+		/* resume completed */
+		} else if (test_bit(wIndex, &amp;ehci-&gt;resuming_ports)) {
+			clear_bit(wIndex, &amp;ehci-&gt;suspended_ports);
+			set_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
+			ehci-&gt;reset_done[wIndex] = 0;
+			usb_hcd_end_port_resume(&amp;hcd-&gt;self, wIndex);
+
+			/* stop resume signaling */
+			temp &amp;= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);
+			ehci_writel(ehci, temp, status_reg);
+			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
+			retval = ehci_handshake(ehci, status_reg,
+					PORT_RESUME, 0, 2000 /* 2msec */);
+			if (retval != 0) {
+				ehci_err(ehci, "port %d resume error %d\n",
 						wIndex + 1, retval);
-					goto error;
-				}
-				temp = ehci_readl(ehci, status_reg);
+				goto error;
 			}
-		}
+			temp = ehci_readl(ehci, status_reg);
 
 		/* whoever resets must GetPortStatus to complete it!! */
-		if ((temp &amp; PORT_RESET)
-				&amp;&amp; time_after_eq(jiffies,
-					ehci-&gt;reset_done[wIndex])) {
+		} else {
 			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			ehci-&gt;reset_done [wIndex] = 0;
 
@@ -933,11 +930,6 @@ static int ehci_hub_control (
 					ehci_readl(ehci, status_reg));
 		}
 
-		if (!(temp &amp; (PORT_RESUME|PORT_RESET))) {
-			ehci-&gt;reset_done[wIndex] = 0;
-			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
-		}
-
 		/* transfer dedicated ports to the companion hc */
 		if ((temp &amp; PORT_CONNECT) &amp;&amp;
 				test_bit(wIndex, &amp;ehci-&gt;companion_ports)) {
@@ -1058,7 +1050,7 @@ static int ehci_hub_control (
 						status_reg);
 			break;
 		case USB_PORT_FEAT_RESET:
-			if (temp &amp; PORT_RESUME)
+			if (temp &amp; (PORT_SUSPEND|PORT_RESUME))
 				goto error;
 			/* line status bits may report this as low speed,
 			 * which can be fine if this root hub has a</pre><hr><pre>commit 3a20446f02bfb71d68ae9ec673268bb7823f878c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 1 17:09:23 2013 -0400

    USB: EHCI: keep better track of resuming ports
    
    The ehci-hcd driver isn't as careful as it should be about the way it
    uses ehci-&gt;resuming_ports.  One of the omissions was fixed recently by
    commit 47a64a13d54 (USB: EHCI: Fix resume signalling on remote
    wakeup), but there are other places that need attention:
    
            When a port's suspend feature is explicitly cleared, the
            corresponding bit in resuming_ports should be set and the core
            should be notified about the port resume.
    
            We don't need to clear a resuming_ports bit when a reset
            completes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 6dce37555c4f..6d0e59306ed9 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -801,6 +801,8 @@ static int ehci_hub_control (
 			ehci_writel(ehci, temp | PORT_RESUME, status_reg);
 			ehci-&gt;reset_done[wIndex] = jiffies
 					+ msecs_to_jiffies(20);
+			set_bit(wIndex, &amp;ehci-&gt;resuming_ports);
+			usb_hcd_start_port_resume(&amp;hcd-&gt;self, wIndex);
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
 			clear_bit(wIndex, &amp;ehci-&gt;port_c_suspend);
@@ -911,7 +913,6 @@ static int ehci_hub_control (
 					ehci-&gt;reset_done[wIndex])) {
 			status |= USB_PORT_STAT_C_RESET &lt;&lt; 16;
 			ehci-&gt;reset_done [wIndex] = 0;
-			clear_bit(wIndex, &amp;ehci-&gt;resuming_ports);
 
 			/* force reset to complete */
 			ehci_writel(ehci, temp &amp; ~(PORT_RWC_BITS | PORT_RESET),</pre><hr><pre>commit 4fae6f0fa86f92e6bc7429371b1e177ad0aaac66
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:39:02 2013 -0400

    USB: handle LPM errors during device suspend correctly
    
    The hub driver's usb_port_suspend() routine doesn't handle errors
    related to Link Power Management properly.  It always returns failure,
    it doesn't try to clean up the wakeup setting, (in the case of system
    sleep) it doesn't try to go ahead with the port suspend regardless,
    and it doesn't try to apply the new power-off mechanism.
    
    This patch fixes these problems.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Sarah Sharp &lt;sarah.a.sharp@linux.intel.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c376c8bad40c..0416f835cfee 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2948,7 +2948,6 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_hub	*hub = usb_hub_to_struct_hub(udev-&gt;parent);
 	struct usb_port *port_dev = hub-&gt;ports[udev-&gt;portnum - 1];
-	enum pm_qos_flags_status pm_qos_stat;
 	int		port1 = udev-&gt;portnum;
 	int		status;
 	bool		really_suspend = true;
@@ -2966,7 +2965,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 					status);
 			/* bail if autosuspend is requested */
 			if (PMSG_IS_AUTO(msg))
-				return status;
+				goto err_wakeup;
 		}
 	}
 
@@ -2975,14 +2974,16 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		usb_set_usb2_hardware_lpm(udev, 0);
 
 	if (usb_disable_ltm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LTM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LTM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_ltm;
 	}
 	if (usb_unlocked_disable_lpm(udev)) {
-		dev_err(&amp;udev-&gt;dev, "%s Failed to disable LPM before suspend\n.",
-				__func__);
-		return -ENOMEM;
+		dev_err(&amp;udev-&gt;dev, "Failed to disable LPM before suspend\n.");
+		status = -ENOMEM;
+		if (PMSG_IS_AUTO(msg))
+			goto err_lpm3;
 	}
 
 	/* see 7.1.7.6 */
@@ -3010,17 +3011,19 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	if (status) {
 		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
-		/* paranoia:  "should not happen" */
-		if (udev-&gt;do_remote_wakeup)
-			(void) usb_disable_remote_wakeup(udev);
 
+		/* Try to enable USB3 LPM and LTM again */
+		usb_unlocked_enable_lpm(udev);
+ err_lpm3:
+		usb_enable_ltm(udev);
+ err_ltm:
 		/* Try to enable USB2 hardware LPM again */
 		if (udev-&gt;usb2_hw_lpm_capable == 1)
 			usb_set_usb2_hardware_lpm(udev, 1);
 
-		/* Try to enable USB3 LTM and LPM again */
-		usb_enable_ltm(udev);
-		usb_unlocked_enable_lpm(udev);
+		if (udev-&gt;do_remote_wakeup)
+			(void) usb_disable_remote_wakeup(udev);
+ err_wakeup:
 
 		/* System sleep transitions should never fail */
 		if (!PMSG_IS_AUTO(msg))
@@ -3042,14 +3045,15 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	 * Check whether current status meets the requirement of
 	 * usb port power off mechanism
 	 */
-	pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
-			PM_QOS_FLAG_NO_POWER_OFF);
-	if (!udev-&gt;do_remote_wakeup
-			&amp;&amp; pm_qos_stat != PM_QOS_FLAGS_ALL
-			&amp;&amp; udev-&gt;persist_enabled
-			&amp;&amp; !status) {
-		pm_runtime_put_sync(&amp;port_dev-&gt;dev);
-		port_dev-&gt;did_runtime_put = true;
+	if (status == 0 &amp;&amp; !udev-&gt;do_remote_wakeup &amp;&amp; udev-&gt;persist_enabled) {
+		enum pm_qos_flags_status pm_qos_stat;
+
+		pm_qos_stat = dev_pm_qos_flags(&amp;port_dev-&gt;dev,
+				PM_QOS_FLAG_NO_POWER_OFF);
+		if (pm_qos_stat != PM_QOS_FLAGS_ALL) {
+			pm_runtime_put_sync(&amp;port_dev-&gt;dev);
+			port_dev-&gt;did_runtime_put = true;
+		}
 	}
 
 	usb_mark_last_busy(hub-&gt;hdev);</pre><hr><pre>commit 28e861658e23ca94692f98e245d254c75c8088a7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:37:33 2013 -0400

    USB: refactor code for enabling/disabling remote wakeup
    
    The hub driver is inconsistent in its organization of code for
    enabling and disabling remote wakeup.  There is a special routine to
    disable wakeup for SuperSpeed devices but not for slower devices, and
    there is no special routine to enable wakeup.
    
    This patch refactors the code.  It renames and changes the existing
    function to make it handle both SuperSpeed and non-SuperSpeed devices,
    and it adds a corresponding routine to enable remote wakeup.  It also
    changes the speed determination to look at the device's speed rather
    than the speed of the parent hub -- this shouldn't make any difference
    because a SuperSpeed device always has to be attached to a SuperSpeed
    hub and conversely.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 11a92198bfc7..c376c8bad40c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2838,18 +2838,50 @@ void usb_enable_ltm(struct usb_device *udev)
 EXPORT_SYMBOL_GPL(usb_enable_ltm);
 
 /*
- * usb_disable_function_remotewakeup - disable usb3.0
- * device's function remote wakeup
+ * usb_enable_remote_wakeup - enable remote wakeup for a device
  * @udev: target device
  *
- * Assume there's only one function on the USB 3.0
- * device and disable remote wake for the first
- * interface. FIXME if the interface association
- * descriptor shows there's more than one function.
+ * For USB-2 devices: Set the device's remote wakeup feature.
+ *
+ * For USB-3 devices: Assume there's only one function on the device and
+ * enable remote wake for the first interface.  FIXME if the interface
+ * association descriptor shows there's more than one function.
  */
-static int usb_disable_function_remotewakeup(struct usb_device *udev)
+static int usb_enable_remote_wakeup(struct usb_device *udev)
 {
-	return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+	if (udev-&gt;speed &lt; USB_SPEED_SUPER)
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
+				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
+				USB_CTRL_SET_TIMEOUT);
+	else
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
+				USB_INTRF_FUNC_SUSPEND,
+				USB_INTRF_FUNC_SUSPEND_RW |
+					USB_INTRF_FUNC_SUSPEND_LP,
+				NULL, 0, USB_CTRL_SET_TIMEOUT);
+}
+
+/*
+ * usb_disable_remote_wakeup - disable remote wakeup for a device
+ * @udev: target device
+ *
+ * For USB-2 devices: Clear the device's remote wakeup feature.
+ *
+ * For USB-3 devices: Assume there's only one function on the device and
+ * disable remote wake for the first interface.  FIXME if the interface
+ * association descriptor shows there's more than one function.
+ */
+static int usb_disable_remote_wakeup(struct usb_device *udev)
+{
+	if (udev-&gt;speed &lt; USB_SPEED_SUPER)
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
+				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
+				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
+				USB_CTRL_SET_TIMEOUT);
+	else
+		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_CLEAR_FEATURE, USB_RECIP_INTERFACE,
 				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
 				USB_CTRL_SET_TIMEOUT);
@@ -2928,27 +2960,7 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	 * we don't explicitly enable it here.
 	 */
 	if (udev-&gt;do_remote_wakeup) {
-		if (!hub_is_superspeed(hub-&gt;hdev)) {
-			status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-					USB_REQ_SET_FEATURE, USB_RECIP_DEVICE,
-					USB_DEVICE_REMOTE_WAKEUP, 0,
-					NULL, 0,
-					USB_CTRL_SET_TIMEOUT);
-		} else {
-			/* Assume there's only one function on the USB 3.0
-			 * device and enable remote wake for the first
-			 * interface. FIXME if the interface association
-			 * descriptor shows there's more than one function.
-			 */
-			status = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
-					USB_REQ_SET_FEATURE,
-					USB_RECIP_INTERFACE,
-					USB_INTRF_FUNC_SUSPEND,
-					USB_INTRF_FUNC_SUSPEND_RW |
-					USB_INTRF_FUNC_SUSPEND_LP,
-					NULL, 0,
-					USB_CTRL_SET_TIMEOUT);
-		}
+		status = usb_enable_remote_wakeup(udev);
 		if (status) {
 			dev_dbg(&amp;udev-&gt;dev, "won't remote wakeup, status %d\n",
 					status);
@@ -2999,19 +3011,8 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		dev_dbg(hub-&gt;intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
 		/* paranoia:  "should not happen" */
-		if (udev-&gt;do_remote_wakeup) {
-			if (!hub_is_superspeed(hub-&gt;hdev)) {
-				(void) usb_control_msg(udev,
-						usb_sndctrlpipe(udev, 0),
-						USB_REQ_CLEAR_FEATURE,
-						USB_RECIP_DEVICE,
-						USB_DEVICE_REMOTE_WAKEUP, 0,
-						NULL, 0,
-						USB_CTRL_SET_TIMEOUT);
-			} else
-				(void) usb_disable_function_remotewakeup(udev);
-
-		}
+		if (udev-&gt;do_remote_wakeup)
+			(void) usb_disable_remote_wakeup(udev);
 
 		/* Try to enable USB2 hardware LPM again */
 		if (udev-&gt;usb2_hw_lpm_capable == 1)
@@ -3119,22 +3120,15 @@ static int finish_port_resume(struct usb_device *udev)
 	 * udev-&gt;reset_resume
 	 */
 	} else if (udev-&gt;actconfig &amp;&amp; !udev-&gt;reset_resume) {
-		if (!hub_is_superspeed(udev-&gt;parent)) {
+		if (udev-&gt;speed &lt; USB_SPEED_SUPER) {
 			if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
-				status = usb_control_msg(udev,
-						usb_sndctrlpipe(udev, 0),
-						USB_REQ_CLEAR_FEATURE,
-						USB_RECIP_DEVICE,
-						USB_DEVICE_REMOTE_WAKEUP, 0,
-						NULL, 0,
-						USB_CTRL_SET_TIMEOUT);
+				status = usb_disable_remote_wakeup(udev);
 		} else {
 			status = usb_get_status(udev, USB_RECIP_INTERFACE, 0,
 					&amp;devstatus);
 			if (!status &amp;&amp; devstatus &amp; (USB_INTRF_STAT_FUNC_RW_CAP
 					| USB_INTRF_STAT_FUNC_RW))
-				status =
-					usb_disable_function_remotewakeup(udev);
+				status = usb_disable_remote_wakeup(udev);
 		}
 
 		if (status)</pre><hr><pre>commit 15b7336e02d998720c5ace47036f7e539365bb05
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Jul 30 15:35:40 2013 -0400

    USB: simplify the interface of usb_get_status()
    
    This patch simplifies the interface presented by usb_get_status().
    Instead of forcing callers to check for the proper data length and
    convert the status value to host byte order, the function will now
    do these things itself.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index c881830af55f..11a92198bfc7 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1464,11 +1464,10 @@ static int hub_configure(struct usb_hub *hub,
 	 * and battery-powered root hubs (may provide just 8 mA).
 	 */
 	ret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &amp;hubstatus);
-	if (ret &lt; 2) {
+	if (ret) {
 		message = "can't get hub status";
 		goto fail;
 	}
-	le16_to_cpus(&amp;hubstatus);
 	hcd = bus_to_hcd(hdev-&gt;bus);
 	if (hdev == hdev-&gt;bus-&gt;root_hub) {
 		if (hcd-&gt;power_budget &gt; 0)
@@ -3101,8 +3100,6 @@ static int finish_port_resume(struct usb_device *udev)
 	if (status == 0) {
 		devstatus = 0;
 		status = usb_get_status(udev, USB_RECIP_DEVICE, 0, &amp;devstatus);
-		if (status &gt;= 0)
-			status = (status &gt; 0 ? 0 : -ENODEV);
 
 		/* If a normal resume failed, try doing a reset-resume */
 		if (status &amp;&amp; !udev-&gt;reset_resume &amp;&amp; udev-&gt;persist_enabled) {
@@ -3123,7 +3120,6 @@ static int finish_port_resume(struct usb_device *udev)
 	 */
 	} else if (udev-&gt;actconfig &amp;&amp; !udev-&gt;reset_resume) {
 		if (!hub_is_superspeed(udev-&gt;parent)) {
-			le16_to_cpus(&amp;devstatus);
 			if (devstatus &amp; (1 &lt;&lt; USB_DEVICE_REMOTE_WAKEUP))
 				status = usb_control_msg(udev,
 						usb_sndctrlpipe(udev, 0),
@@ -3135,7 +3131,6 @@ static int finish_port_resume(struct usb_device *udev)
 		} else {
 			status = usb_get_status(udev, USB_RECIP_INTERFACE, 0,
 					&amp;devstatus);
-			le16_to_cpus(&amp;devstatus);
 			if (!status &amp;&amp; devstatus &amp; (USB_INTRF_STAT_FUNC_RW_CAP
 					| USB_INTRF_STAT_FUNC_RW))
 				status =
@@ -4481,11 +4476,10 @@ static void hub_port_connect_change(struct usb_hub *hub, int port1,
 
 			status = usb_get_status(udev, USB_RECIP_DEVICE, 0,
 					&amp;devstat);
-			if (status &lt; 2) {
+			if (status) {
 				dev_dbg(&amp;udev-&gt;dev, "get status %d ?\n", status);
 				goto loop_disable;
 			}
-			le16_to_cpus(&amp;devstat);
 			if ((devstat &amp; (1 &lt;&lt; USB_DEVICE_SELF_POWERED)) == 0) {
 				dev_err(&amp;udev-&gt;dev,
 					"can't connect bus-powered hub "
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index e7ee1e451660..6549a975b0c5 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -934,13 +934,13 @@ int usb_get_device_descriptor(struct usb_device *dev, unsigned int size)
  *
  * This call is synchronous, and may not be used in an interrupt context.
  *
- * Returns the number of bytes received on success, or else the status code
- * returned by the underlying usb_control_msg() call.
+ * Returns 0 and the status value in *@data (in host byte order) on success,
+ * or else the status code from the underlying usb_control_msg() call.
  */
 int usb_get_status(struct usb_device *dev, int type, int target, void *data)
 {
 	int ret;
-	u16 *status = kmalloc(sizeof(*status), GFP_KERNEL);
+	__le16 *status = kmalloc(sizeof(*status), GFP_KERNEL);
 
 	if (!status)
 		return -ENOMEM;
@@ -949,7 +949,12 @@ int usb_get_status(struct usb_device *dev, int type, int target, void *data)
 		USB_REQ_GET_STATUS, USB_DIR_IN | type, 0, target, status,
 		sizeof(*status), USB_CTRL_GET_TIMEOUT);
 
-	*(u16 *)data = *status;
+	if (ret == 2) {
+		*(u16 *) data = le16_to_cpu(*status);
+		ret = 0;
+	} else if (ret &gt;= 0) {
+		ret = -EIO;
+	}
 	kfree(status);
 	return ret;
 }
diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c
index 8b4ca1cb450a..aa28ac8c7607 100644
--- a/drivers/usb/misc/usbtest.c
+++ b/drivers/usb/misc/usbtest.c
@@ -747,9 +747,9 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 
 	/* [9.4.5] get_status always works */
 	retval = usb_get_status(udev, USB_RECIP_DEVICE, 0, dev-&gt;buf);
-	if (retval != 2) {
+	if (retval) {
 		dev_err(&amp;iface-&gt;dev, "get dev status --&gt; %d\n", retval);
-		return (retval &lt; 0) ? retval : -EDOM;
+		return retval;
 	}
 
 	/* FIXME configuration.bmAttributes says if we could try to set/clear
@@ -758,9 +758,9 @@ static int ch9_postconfig(struct usbtest_dev *dev)
 
 	retval = usb_get_status(udev, USB_RECIP_INTERFACE,
 			iface-&gt;altsetting[0].desc.bInterfaceNumber, dev-&gt;buf);
-	if (retval != 2) {
+	if (retval) {
 		dev_err(&amp;iface-&gt;dev, "get interface status --&gt; %d\n", retval);
-		return (retval &lt; 0) ? retval : -EDOM;
+		return retval;
 	}
 	/* FIXME get status for each endpoint in the interface */
 
@@ -1351,7 +1351,6 @@ static int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)
 				ep, retval);
 		return retval;
 	}
-	le16_to_cpus(&amp;status);
 	if (status != 1) {
 		ERROR(tdev, "ep %02x bogus status: %04x != 1\n", ep, status);
 		return -EINVAL;</pre><hr><pre>commit c4b51a431561f0bacc1740aa27f080bf95c4d6c7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 11 14:58:23 2013 -0400

    USB: remove redundant "#if"
    
    This patch removes a redundant nested "#ifdef CONFIG_PM" from the hub
    driver.  It also adds a label to the "#endif" line corresponding to
    the outer "#ifdef CONFIG_PM".
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4191db32f12c..f735f6bc929c 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2829,7 +2829,6 @@ void usb_enable_ltm(struct usb_device *udev)
 }
 EXPORT_SYMBOL_GPL(usb_enable_ltm);
 
-#ifdef	CONFIG_PM
 /*
  * usb_disable_function_remotewakeup - disable usb3.0
  * device's function remote wakeup
@@ -3249,8 +3248,6 @@ int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-#endif	/* CONFIG_PM */
-
 #ifdef	CONFIG_PM_RUNTIME
 
 /* caller has locked udev */
@@ -3811,7 +3808,8 @@ EXPORT_SYMBOL_GPL(usb_disable_ltm);
 
 void usb_enable_ltm(struct usb_device *udev) { }
 EXPORT_SYMBOL_GPL(usb_enable_ltm);
-#endif
+
+#endif	/* CONFIG_PM */
 
 
 /* USB 2.0 spec, 7.1.7.3 / fig 7-29:</pre><hr><pre>commit e583d9db9960cf40e0bc8afee4946baa9d71596e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 11 14:58:04 2013 -0400

    USB: global suspend and remote wakeup don't mix
    
    The hub driver was recently changed to use "global" suspend for system
    suspend transitions on non-SuperSpeed buses.  This means that we don't
    suspend devices individually by setting the suspend feature on the
    upstream hub port; instead devices all go into suspend automatically
    when the root hub stops transmitting packets.  The idea was to save
    time and to avoid certain kinds of wakeup races.
    
    Now it turns out that many hubs are buggy; they don't relay wakeup
    requests from a downstream port to their upstream port if the
    downstream port's suspend feature is not set (depending on the speed
    of the downstream port, whether or not the hub is enabled for remote
    wakeup, and possibly other factors).
    
    We can't have hubs dropping wakeup requests.  Therefore this patch
    goes partway back to the old policy: It sets the suspend feature for a
    port if the device attached to that port or any of its descendants is
    enabled for wakeup.  People will still be able to benefit from the
    time savings if they don't care about wakeup and leave it disabled on
    all their devices.
    
    In order to accomplish this, the patch adds a new field to the usb_hub
    structure: wakeup_enabled_descendants is a count of how many devices
    below a suspended hub are enabled for remote wakeup.  A corresponding
    new subroutine determines the number of wakeup-enabled devices at or
    below an arbitrary suspended USB device.
    
    This should be applied to the 3.10 stable kernel.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Toralf Förster &lt;toralf.foerster@gmx.de&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 4191db32f12c..c857471519e3 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2848,6 +2848,15 @@ static int usb_disable_function_remotewakeup(struct usb_device *udev)
 				USB_CTRL_SET_TIMEOUT);
 }
 
+/* Count of wakeup-enabled devices at or below udev */
+static unsigned wakeup_enabled_descendants(struct usb_device *udev)
+{
+	struct usb_hub *hub = usb_hub_to_struct_hub(udev);
+
+	return udev-&gt;do_remote_wakeup +
+			(hub ? hub-&gt;wakeup_enabled_descendants : 0);
+}
+
 /*
  * usb_port_suspend - suspend a usb device's upstream port
  * @udev: device that's no longer in active use, not a root hub
@@ -2888,8 +2897,8 @@ static int usb_disable_function_remotewakeup(struct usb_device *udev)
  * Linux (2.6) currently has NO mechanisms to initiate that:  no khubd
  * timer, no SRP, no requests through sysfs.
  *
- * If Runtime PM isn't enabled or used, non-SuperSpeed devices really get
- * suspended only when their bus goes into global suspend (i.e., the root
+ * If Runtime PM isn't enabled or used, non-SuperSpeed devices may not get
+ * suspended until their bus goes into global suspend (i.e., the root
  * hub is suspended).  Nevertheless, we change @udev-&gt;state to
  * USB_STATE_SUSPENDED as this is the device's "logical" state.  The actual
  * upstream port setting is stored in @udev-&gt;port_is_suspended.
@@ -2960,15 +2969,21 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 	/* see 7.1.7.6 */
 	if (hub_is_superspeed(hub-&gt;hdev))
 		status = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);
-	else if (PMSG_IS_AUTO(msg))
-		status = set_port_feature(hub-&gt;hdev, port1,
-						USB_PORT_FEAT_SUSPEND);
+
 	/*
 	 * For system suspend, we do not need to enable the suspend feature
 	 * on individual USB-2 ports.  The devices will automatically go
 	 * into suspend a few ms after the root hub stops sending packets.
 	 * The USB 2.0 spec calls this "global suspend".
+	 *
+	 * However, many USB hubs have a bug: They don't relay wakeup requests
+	 * from a downstream port if the port's suspend feature isn't on.
+	 * Therefore we will turn on the suspend feature if udev or any of its
+	 * descendants is enabled for remote wakeup.
 	 */
+	else if (PMSG_IS_AUTO(msg) || wakeup_enabled_descendants(udev) &gt; 0)
+		status = set_port_feature(hub-&gt;hdev, port1,
+				USB_PORT_FEAT_SUSPEND);
 	else {
 		really_suspend = false;
 		status = 0;
@@ -3003,15 +3018,16 @@ int usb_port_suspend(struct usb_device *udev, pm_message_t msg)
 		if (!PMSG_IS_AUTO(msg))
 			status = 0;
 	} else {
-		/* device has up to 10 msec to fully suspend */
 		dev_dbg(&amp;udev-&gt;dev, "usb %ssuspend, wakeup %d\n",
 				(PMSG_IS_AUTO(msg) ? "auto-" : ""),
 				udev-&gt;do_remote_wakeup);
-		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 		if (really_suspend) {
 			udev-&gt;port_is_suspended = 1;
+
+			/* device has up to 10 msec to fully suspend */
 			msleep(10);
 		}
+		usb_set_device_state(udev, USB_STATE_SUSPENDED);
 	}
 
 	/*
@@ -3293,7 +3309,11 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 	unsigned		port1;
 	int			status;
 
-	/* Warn if children aren't already suspended */
+	/*
+	 * Warn if children aren't already suspended.
+	 * Also, add up the number of wakeup-enabled descendants.
+	 */
+	hub-&gt;wakeup_enabled_descendants = 0;
 	for (port1 = 1; port1 &lt;= hdev-&gt;maxchild; port1++) {
 		struct usb_device	*udev;
 
@@ -3303,6 +3323,9 @@ static int hub_suspend(struct usb_interface *intf, pm_message_t msg)
 			if (PMSG_IS_AUTO(msg))
 				return -EBUSY;
 		}
+		if (udev)
+			hub-&gt;wakeup_enabled_descendants +=
+					wakeup_enabled_descendants(udev);
 	}
 
 	if (hdev-&gt;do_remote_wakeup &amp;&amp; hub-&gt;quirk_check_port_auto_suspend) {
diff --git a/drivers/usb/core/hub.h b/drivers/usb/core/hub.h
index 6508e02b3dac..4e4790dea343 100644
--- a/drivers/usb/core/hub.h
+++ b/drivers/usb/core/hub.h
@@ -59,6 +59,9 @@ struct usb_hub {
 	struct usb_tt		tt;		/* Transaction Translator */
 
 	unsigned		mA_per_port;	/* current for each child */
+#ifdef	CONFIG_PM
+	unsigned		wakeup_enabled_descendants;
+#endif
 
 	unsigned		limited_power:1;
 	unsigned		quiescing:1;</pre><hr><pre>commit 36ff66db3fb5642906e46e73ca9cf92f1c5974ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jun 27 15:27:07 2013 -0400

    USB: move the definition of USB_MAXCHILDREN
    
    The USB_MAXCHILDREN symbol is used in include/uapi/linux/usb/ch11.h, a
    user-mode header, even though it is defined in include/linux/usb.h,
    which is kernel-only.  This causes compile-time errors when user
    programs try to #include linux/usb/ch11.h.
    
    This patch fixes the problem by moving the definition of USB_MAXCHILDREN
    into ch11.h.  It also gets rid of unneeded parentheses.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/include/linux/usb.h b/include/linux/usb.h
index a232b7ece1f6..0eec2689b955 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -367,17 +367,6 @@ struct usb_bus {
 
 /* ----------------------------------------------------------------------- */
 
-/* This is arbitrary.
- * From USB 2.0 spec Table 11-13, offset 7, a hub can
- * have up to 255 ports. The most yet reported is 10.
- *
- * Current Wireless USB host hardware (Intel i1480 for example) allows
- * up to 22 devices to connect. Upcoming hardware might raise that
- * limit. Because the arrays need to add a bit for hub status data, we
- * do 31, so plus one evens out to four bytes.
- */
-#define USB_MAXCHILDREN		(31)
-
 struct usb_tt;
 
 enum usb_device_removable {
diff --git a/include/uapi/linux/usb/ch11.h b/include/uapi/linux/usb/ch11.h
index 7692dc69ccf7..331499d597fa 100644
--- a/include/uapi/linux/usb/ch11.h
+++ b/include/uapi/linux/usb/ch11.h
@@ -11,6 +11,17 @@
 
 #include &lt;linux/types.h&gt;	/* __u8 etc */
 
+/* This is arbitrary.
+ * From USB 2.0 spec Table 11-13, offset 7, a hub can
+ * have up to 255 ports. The most yet reported is 10.
+ *
+ * Current Wireless USB host hardware (Intel i1480 for example) allows
+ * up to 22 devices to connect. Upcoming hardware might raise that
+ * limit. Because the arrays need to add a bit for hub status data, we
+ * use 31, so plus one evens out to four bytes.
+ */
+#define USB_MAXCHILDREN		31
+
 /*
  * Hub request types
  */</pre><hr><pre>commit 908b961326b2ecfbf494c9b2f206847d925f269d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Jul 12 11:06:21 2013 -0400

    usb: gadget: don't fail when DMA isn't present
    
    When CONFIG_HAS_DMA isn't enabled, the UDC core gets build errors:
    
    drivers/built-in.o: In function `dma_set_coherent_mask':
    include/linux/dma-mapping.h:93: undefined reference to `dma_supported'
    include/linux/dma-mapping.h:93: undefined reference to `dma_supported'
    drivers/built-in.o: In function `usb_gadget_unmap_request':
    drivers/usb/gadget/udc-core.c:91: undefined reference to `dma_unmap_sg'
    drivers/usb/gadget/udc-core.c:96: undefined reference to `dma_unmap_single'
    drivers/built-in.o: In function `usb_gadget_map_request':
    drivers/usb/gadget/udc-core.c:62: undefined reference to `dma_map_sg'
    drivers/usb/gadget/udc-core.c:71: undefined reference to `dma_map_single'
    drivers/usb/gadget/udc-core.c:74: undefined reference to `dma_mapping_error'
    
    Prevent this by protecting the DMA API routines with preprocessor tests.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Geert Uytterhoeven &lt;geert@linux-m68k.org&gt;
    Acked-by: Alexander Shishkin &lt;alexander.shishkin@linux.intel.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@ti.com&gt;

diff --git a/drivers/usb/gadget/udc-core.c b/drivers/usb/gadget/udc-core.c
index ffd8fa541101..c28ac9872030 100644
--- a/drivers/usb/gadget/udc-core.c
+++ b/drivers/usb/gadget/udc-core.c
@@ -50,6 +50,8 @@ static DEFINE_MUTEX(udc_lock);
 
 /* ------------------------------------------------------------------------- */
 
+#ifdef	CONFIG_HAS_DMA
+
 int usb_gadget_map_request(struct usb_gadget *gadget,
 		struct usb_request *req, int is_in)
 {
@@ -99,6 +101,8 @@ void usb_gadget_unmap_request(struct usb_gadget *gadget,
 }
 EXPORT_SYMBOL_GPL(usb_gadget_unmap_request);
 
+#endif	/* CONFIG_HAS_DMA */
+
 /* ------------------------------------------------------------------------- */
 
 void usb_gadget_set_state(struct usb_gadget *gadget,
@@ -194,9 +198,11 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	gadget-&gt;dev.parent = parent;
 
+#ifdef	CONFIG_HAS_DMA
 	dma_set_coherent_mask(&amp;gadget-&gt;dev, parent-&gt;coherent_dma_mask);
 	gadget-&gt;dev.dma_parms = parent-&gt;dma_parms;
 	gadget-&gt;dev.dma_mask = parent-&gt;dma_mask;
+#endif
 
 	if (release)
 		gadget-&gt;dev.release = release;</pre><hr><pre>commit 43d51af489126305dbacc1b8ebd1ce4797d277ea
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Jun 3 21:49:59 2013 +0200

    PM / Runtime: Update .runtime_idle() callback documentation
    
    Runtime PM documentation needs to be updated after the previous
    change of the rpm_idle() behavior, so modify it as appropriate.
    
    [rjw: Subject and changelog]
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Rafael J. Wysocki &lt;rafael.j.wysocki@intel.com&gt;

diff --git a/Documentation/power/runtime_pm.txt b/Documentation/power/runtime_pm.txt
index 6c470c71ba27..71d8fe4e75d3 100644
--- a/Documentation/power/runtime_pm.txt
+++ b/Documentation/power/runtime_pm.txt
@@ -144,8 +144,12 @@ The action performed by the idle callback is totally dependent on the subsystem
 (or driver) in question, but the expected and recommended action is to check
 if the device can be suspended (i.e. if all of the conditions necessary for
 suspending the device are satisfied) and to queue up a suspend request for the
-device in that case.  The value returned by this callback is ignored by the PM
-core.
+device in that case.  If there is no idle callback, or if the callback returns
+0, then the PM core will attempt to carry out a runtime suspend of the device;
+in essence, it will call pm_runtime_suspend() directly.  To prevent this (for
+example, if the callback routine has started a delayed suspend), the routine
+should return a non-zero value.  Negative error return codes are ignored by the
+PM core.
 
 The helper functions provided by the PM core, described in Section 4, guarantee
 that the following constraints are met with respect to runtime PM callbacks for
@@ -301,9 +305,10 @@ drivers/base/power/runtime.c and include/linux/pm_runtime.h:
       removing the device from device hierarchy
 
   int pm_runtime_idle(struct device *dev);
-    - execute the subsystem-level idle callback for the device; returns 0 on
-      success or error code on failure, where -EINPROGRESS means that
-      -&gt;runtime_idle() is already being executed
+    - execute the subsystem-level idle callback for the device; returns an
+      error code on failure, where -EINPROGRESS means that -&gt;runtime_idle() is
+      already being executed; if there is no callback or the callback returns 0
+      then run pm_runtime_suspend(dev) and return its result
 
   int pm_runtime_suspend(struct device *dev);
     - execute the subsystem-level suspend callback for the device; returns 0 on</pre>
    <div class="pagination">
        <a href='2_34.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><span>[35]</span><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_36.html'>Next&gt;&gt;</a>
    <div>
</body>
