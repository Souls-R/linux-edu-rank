<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_75.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><span>[76]</span><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_77.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b05e6ae58a13b56e3e11882c1fc71948c9b29760
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Jan 10 12:13:26 2011 -0500

    ext4: drop ec_type from the ext4_ext_cache structure
    
    We can encode the ec_type information by using ee_len == 0 to denote
    EXT4_EXT_CACHE_NO, ee_start == 0 to denote EXT4_EXT_CACHE_GAP, and if
    neither is true, then the cache type must be EXT4_EXT_CACHE_EXTENT.
    This allows us to reduce the size of ext4_ext_inode by another 8
    bytes.  (ec_type is 4 bytes, plus another 4 bytes of padding)
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 746a59853a07..de937fc10503 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -738,12 +738,13 @@ do {									       \
 
 /*
  * storage for cached extent
+ * If ec_len == 0, then the cache is invalid.
+ * If ec_start == 0, then the cache represents a gap (null mapping)
  */
 struct ext4_ext_cache {
 	ext4_fsblk_t	ec_start;
 	ext4_lblk_t	ec_block;
 	__u32		ec_len; /* must be 32bit to return holes */
-	__u32		ec_type;
 };
 
 /*
diff --git a/fs/ext4/ext4_extents.h b/fs/ext4/ext4_extents.h
index dfdda1766927..2e29abb30f76 100644
--- a/fs/ext4/ext4_extents.h
+++ b/fs/ext4/ext4_extents.h
@@ -119,10 +119,6 @@ struct ext4_ext_path {
  * structure for external API
  */
 
-#define EXT4_EXT_CACHE_NO	0
-#define EXT4_EXT_CACHE_GAP	1
-#define EXT4_EXT_CACHE_EXTENT	2
-
 /*
  * to be called by ext4_ext_walk_space()
  * negative retcode - error
@@ -197,7 +193,7 @@ static inline unsigned short ext_depth(struct inode *inode)
 static inline void
 ext4_ext_invalidate_cache(struct inode *inode)
 {
-	EXT4_I(inode)-&gt;i_cached_extent.ec_type = EXT4_EXT_CACHE_NO;
+	EXT4_I(inode)-&gt;i_cached_extent.ec_len = 0;
 }
 
 static inline void ext4_ext_mark_uninitialized(struct ext4_extent *ext)
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index f1a4354ea3cf..9081d1060a5f 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -1894,12 +1894,10 @@ static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
 			cbex.ec_block = start;
 			cbex.ec_len = end - start;
 			cbex.ec_start = 0;
-			cbex.ec_type = EXT4_EXT_CACHE_GAP;
 		} else {
 			cbex.ec_block = le32_to_cpu(ex-&gt;ee_block);
 			cbex.ec_len = ext4_ext_get_actual_len(ex);
 			cbex.ec_start = ext4_ext_pblock(ex);
-			cbex.ec_type = EXT4_EXT_CACHE_EXTENT;
 		}
 
 		if (unlikely(cbex.ec_len == 0)) {
@@ -1939,13 +1937,12 @@ static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
 
 static void
 ext4_ext_put_in_cache(struct inode *inode, ext4_lblk_t block,
-			__u32 len, ext4_fsblk_t start, int type)
+			__u32 len, ext4_fsblk_t start)
 {
 	struct ext4_ext_cache *cex;
 	BUG_ON(len == 0);
 	spin_lock(&amp;EXT4_I(inode)-&gt;i_block_reservation_lock);
 	cex = &amp;EXT4_I(inode)-&gt;i_cached_extent;
-	cex-&gt;ec_type = type;
 	cex-&gt;ec_block = block;
 	cex-&gt;ec_len = len;
 	cex-&gt;ec_start = start;
@@ -1998,15 +1995,18 @@ ext4_ext_put_gap_in_cache(struct inode *inode, struct ext4_ext_path *path,
 	}
 
 	ext_debug(" -&gt; %u:%lu\n", lblock, len);
-	ext4_ext_put_in_cache(inode, lblock, len, 0, EXT4_EXT_CACHE_GAP);
+	ext4_ext_put_in_cache(inode, lblock, len, 0);
 }
 
+/*
+ * Return 0 if cache is invalid; 1 if the cache is valid
+ */
 static int
 ext4_ext_in_cache(struct inode *inode, ext4_lblk_t block,
 			struct ext4_extent *ex)
 {
 	struct ext4_ext_cache *cex;
-	int ret = EXT4_EXT_CACHE_NO;
+	int ret = 0;
 
 	/*
 	 * We borrow i_block_reservation_lock to protect i_cached_extent
@@ -2015,11 +2015,9 @@ ext4_ext_in_cache(struct inode *inode, ext4_lblk_t block,
 	cex = &amp;EXT4_I(inode)-&gt;i_cached_extent;
 
 	/* has cache valid data? */
-	if (cex-&gt;ec_type == EXT4_EXT_CACHE_NO)
+	if (cex-&gt;ec_len == 0)
 		goto errout;
 
-	BUG_ON(cex-&gt;ec_type != EXT4_EXT_CACHE_GAP &amp;&amp;
-			cex-&gt;ec_type != EXT4_EXT_CACHE_EXTENT);
 	if (in_range(block, cex-&gt;ec_block, cex-&gt;ec_len)) {
 		ex-&gt;ee_block = cpu_to_le32(cex-&gt;ec_block);
 		ext4_ext_store_pblock(ex, cex-&gt;ec_start);
@@ -2027,7 +2025,7 @@ ext4_ext_in_cache(struct inode *inode, ext4_lblk_t block,
 		ext_debug("%u cached by %u:%u:%llu\n",
 				block,
 				cex-&gt;ec_block, cex-&gt;ec_len, cex-&gt;ec_start);
-		ret = cex-&gt;ec_type;
+		ret = 1;
 	}
 errout:
 	spin_unlock(&amp;EXT4_I(inode)-&gt;i_block_reservation_lock);
@@ -3298,7 +3296,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 	struct ext4_extent_header *eh;
 	struct ext4_extent newex, *ex;
 	ext4_fsblk_t newblock;
-	int err = 0, depth, ret, cache_type;
+	int err = 0, depth, ret;
 	unsigned int allocated = 0;
 	struct ext4_allocation_request ar;
 	ext4_io_end_t *io = EXT4_I(inode)-&gt;cur_aio_dio;
@@ -3307,9 +3305,8 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 		  map-&gt;m_lblk, map-&gt;m_len, inode-&gt;i_ino);
 
 	/* check in cache */
-	cache_type = ext4_ext_in_cache(inode, map-&gt;m_lblk, &amp;newex);
-	if (cache_type) {
-		if (cache_type == EXT4_EXT_CACHE_GAP) {
+	if (ext4_ext_in_cache(inode, map-&gt;m_lblk, &amp;newex)) {
+		if (!newex.ee_start_lo &amp;&amp; !newex.ee_start_hi) {
 			if ((flags &amp; EXT4_GET_BLOCKS_CREATE) == 0) {
 				/*
 				 * block isn't allocated yet and
@@ -3318,7 +3315,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 				goto out2;
 			}
 			/* we should allocate requested block */
-		} else if (cache_type == EXT4_EXT_CACHE_EXTENT) {
+		} else {
 			/* block is already allocated */
 			newblock = map-&gt;m_lblk
 				   - le32_to_cpu(newex.ee_block)
@@ -3327,8 +3324,6 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 			allocated = ext4_ext_get_actual_len(&amp;newex) -
 				(map-&gt;m_lblk - le32_to_cpu(newex.ee_block));
 			goto out;
-		} else {
-			BUG();
 		}
 	}
 
@@ -3379,8 +3374,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 			/* Do not put uninitialized extent in the cache */
 			if (!ext4_ext_is_uninitialized(ex)) {
 				ext4_ext_put_in_cache(inode, ee_block,
-							ee_len, ee_start,
-							EXT4_EXT_CACHE_EXTENT);
+							ee_len, ee_start);
 				goto out;
 			}
 			ret = ext4_ext_handle_uninitialized_extents(handle,
@@ -3512,8 +3506,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 	 * when it is _not_ an uninitialized extent.
 	 */
 	if ((flags &amp; EXT4_GET_BLOCKS_UNINIT_EXT) == 0) {
-		ext4_ext_put_in_cache(inode, map-&gt;m_lblk, allocated, newblock,
-						EXT4_EXT_CACHE_EXTENT);
+		ext4_ext_put_in_cache(inode, map-&gt;m_lblk, allocated, newblock);
 		ext4_update_inode_fsync_trans(handle, inode, 1);
 	} else
 		ext4_update_inode_fsync_trans(handle, inode, 0);
@@ -3789,7 +3782,7 @@ static int ext4_ext_fiemap_cb(struct inode *inode, struct ext4_ext_path *path,
 
 	logical =  (__u64)newex-&gt;ec_block &lt;&lt; blksize_bits;
 
-	if (newex-&gt;ec_type == EXT4_EXT_CACHE_GAP) {
+	if (newex-&gt;ec_start == 0) {
 		pgoff_t offset;
 		struct page *page;
 		struct buffer_head *bh = NULL;</pre><hr><pre>commit 01f49d0b9d0209dc1194255b11601e4b94447b36
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Jan 10 12:13:03 2011 -0500

    ext4: use ext4_lblk_t instead of sector_t for logical blocks
    
    This fixes a number of places where we used sector_t instead of
    ext4_lblk_t for logical blocks, which for ext4 are still 32-bit data
    types.  No point wasting space in the ext4_inode_info structure, and
    requiring 64-bit arithmetic on 32-bit systems, when it isn't
    necessary.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index b7ee66ff9962..746a59853a07 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -828,7 +828,7 @@ struct ext4_inode_info {
 	unsigned int i_reserved_data_blocks;
 	unsigned int i_reserved_meta_blocks;
 	unsigned int i_allocated_meta_blocks;
-	sector_t i_da_metadata_calc_last_lblock;
+	ext4_lblk_t i_da_metadata_calc_last_lblock;
 	int i_da_metadata_calc_len;
 
 	/* on-disk additional length */
diff --git a/fs/ext4/ext4_extents.h b/fs/ext4/ext4_extents.h
index 28ce70fd9cd0..dfdda1766927 100644
--- a/fs/ext4/ext4_extents.h
+++ b/fs/ext4/ext4_extents.h
@@ -278,7 +278,7 @@ static inline void ext4_idx_store_pblock(struct ext4_extent_idx *ix,
 }
 
 extern int ext4_ext_calc_metadata_amount(struct inode *inode,
-					 sector_t lblocks);
+					 ext4_lblk_t lblocks);
 extern int ext4_extent_tree_init(handle_t *, struct inode *);
 extern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,
 						   int num,
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index d53e20f53103..f1a4354ea3cf 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -266,7 +266,7 @@ static inline int ext4_ext_space_root_idx(struct inode *inode, int check)
  * to allocate @blocks
  * Worse case is one block per extent
  */
-int ext4_ext_calc_metadata_amount(struct inode *inode, sector_t lblock)
+int ext4_ext_calc_metadata_amount(struct inode *inode, ext4_lblk_t lblock)
 {
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	int idxs, num = 0;
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index ac08460921aa..3ae83137cf34 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1091,7 +1091,7 @@ static int ext4_indirect_calc_metadata_amount(struct inode *inode,
  * Calculate the number of metadata blocks need to reserve
  * to allocate a block located at @lblock
  */
-static int ext4_calc_metadata_amount(struct inode *inode, sector_t lblock)
+static int ext4_calc_metadata_amount(struct inode *inode, ext4_lblk_t lblock)
 {
 	if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))
 		return ext4_ext_calc_metadata_amount(inode, lblock);
@@ -1888,7 +1888,7 @@ static int ext4_journalled_write_end(struct file *file,
 /*
  * Reserve a single block located at lblock
  */
-static int ext4_da_reserve_space(struct inode *inode, sector_t lblock)
+static int ext4_da_reserve_space(struct inode *inode, ext4_lblk_t lblock)
 {
 	int retries = 0;
 	struct ext4_sb_info *sbi = EXT4_SB(inode-&gt;i_sb);</pre><hr><pre>commit f232109773ff5b0c840a6761d74940b9cf0d66ec
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Jan 10 12:12:36 2011 -0500

    ext4: replace i_delalloc_reserved_flag with EXT4_STATE_DELALLOC_RESERVED
    
    Remove the short element i_delalloc_reserved_flag from the
    ext4_inode_info structure and replace it a new bit in i_state_flags.
    Since we have an ext4_inode_info for every ext4 inode cached in the
    inode cache, any savings we can produce here is a very good thing from
    a memory utilization perspective.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index 14c3af26c671..adf96b822781 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -592,7 +592,8 @@ ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,
 	 * Account for the allocated meta blocks.  We will never
 	 * fail EDQUOT for metdata, but we do account for it.
 	 */
-	if (!(*errp) &amp;&amp; EXT4_I(inode)-&gt;i_delalloc_reserved_flag) {
+	if (!(*errp) &amp;&amp;
+	    ext4_test_inode_state(inode, EXT4_STATE_DELALLOC_RESERVED)) {
 		spin_lock(&amp;EXT4_I(inode)-&gt;i_block_reservation_lock);
 		EXT4_I(inode)-&gt;i_allocated_meta_blocks += ar.len;
 		spin_unlock(&amp;EXT4_I(inode)-&gt;i_block_reservation_lock);
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 2a739255ee05..b7ee66ff9962 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -828,7 +828,6 @@ struct ext4_inode_info {
 	unsigned int i_reserved_data_blocks;
 	unsigned int i_reserved_meta_blocks;
 	unsigned int i_allocated_meta_blocks;
-	unsigned short i_delalloc_reserved_flag;
 	sector_t i_da_metadata_calc_last_lblock;
 	int i_da_metadata_calc_len;
 
@@ -1235,6 +1234,7 @@ enum {
 	EXT4_STATE_EXT_MIGRATE,		/* Inode is migrating */
 	EXT4_STATE_DIO_UNWRITTEN,	/* need convert on dio done*/
 	EXT4_STATE_NEWENTRY,		/* File just added to dir */
+	EXT4_STATE_DELALLOC_RESERVED,	/* blks already reserved for delalloc */
 };
 
 #define EXT4_INODE_BIT_FNS(name, field)					\
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index c0fe426d444a..ac08460921aa 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -1330,7 +1330,7 @@ int ext4_map_blocks(handle_t *handle, struct inode *inode,
 	 * avoid double accounting
 	 */
 	if (flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE)
-		EXT4_I(inode)-&gt;i_delalloc_reserved_flag = 1;
+		ext4_set_inode_state(inode, EXT4_STATE_DELALLOC_RESERVED);
 	/*
 	 * We need to check for EXT4 here because migrate
 	 * could have changed the inode type in between
@@ -1360,7 +1360,7 @@ int ext4_map_blocks(handle_t *handle, struct inode *inode,
 			ext4_da_update_reserve_space(inode, retval, 1);
 	}
 	if (flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE)
-		EXT4_I(inode)-&gt;i_delalloc_reserved_flag = 0;
+		ext4_clear_inode_state(inode, EXT4_STATE_DELALLOC_RESERVED);
 
 	up_write((&amp;EXT4_I(inode)-&gt;i_data_sem));
 	if (retval &gt; 0 &amp;&amp; map-&gt;m_flags &amp; EXT4_MAP_MAPPED) {
@@ -2249,7 +2249,7 @@ static void mpage_da_map_and_submit(struct mpage_da_data *mpd)
 	 * affects functions in many different parts of the allocation
 	 * call path.  This flag exists primarily because we don't
 	 * want to change *many* call functions, so ext4_map_blocks()
-	 * will set the magic i_delalloc_reserved_flag once the
+	 * will set the EXT4_STATE_DELALLOC_RESERVED flag once the
 	 * inode's allocation semaphore is taken.
 	 *
 	 * If the blocks in questions were delalloc blocks, set
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 12b604abc2fe..d47a80ec231d 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -4283,7 +4283,7 @@ ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,
 	 * EDQUOT check, as blocks and quotas have been already
 	 * reserved when data being copied into pagecache.
 	 */
-	if (EXT4_I(ar-&gt;inode)-&gt;i_delalloc_reserved_flag)
+	if (ext4_test_inode_state(ar-&gt;inode, EXT4_STATE_DELALLOC_RESERVED))
 		ar-&gt;flags |= EXT4_MB_DELALLOC_RESERVED;
 	else {
 		/* Without delayed allocation we need to verify
@@ -4380,7 +4380,8 @@ ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,
 	if (inquota &amp;&amp; ar-&gt;len &lt; inquota)
 		dquot_free_block(ar-&gt;inode, inquota - ar-&gt;len);
 	if (!ar-&gt;len) {
-		if (!EXT4_I(ar-&gt;inode)-&gt;i_delalloc_reserved_flag)
+		if (!ext4_test_inode_state(ar-&gt;inode,
+					   EXT4_STATE_DELALLOC_RESERVED))
 			/* release all the reserved blocks if non delalloc */
 			percpu_counter_sub(&amp;sbi-&gt;s_dirtyblocks_counter,
 						reserv_blks);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 7728a4ca3d6c..f5960d673e4e 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -828,7 +828,6 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 	ei-&gt;i_reserved_meta_blocks = 0;
 	ei-&gt;i_allocated_meta_blocks = 0;
 	ei-&gt;i_da_metadata_calc_len = 0;
-	ei-&gt;i_delalloc_reserved_flag = 0;
 	spin_lock_init(&amp;(ei-&gt;i_block_reservation_lock));
 #ifdef CONFIG_QUOTA
 	ei-&gt;i_reserved_quota = 0;</pre><hr><pre>commit f7c21177af0b32a2cd9ee36189637f0c1f0e1e17
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Jan 10 12:10:55 2011 -0500

    ext4: Use ext4_error_file() to print the pathname to the corrupted inode
    
    Where the file pointer is available, use ext4_error_file() instead of
    ext4_error_inode().
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/dir.c b/fs/ext4/dir.c
index bd5d74d06399..164c56092e58 100644
--- a/fs/ext4/dir.c
+++ b/fs/ext4/dir.c
@@ -66,7 +66,7 @@ static unsigned char get_dtype(struct super_block *sb, int filetype)
  * Note: this is the opposite of what ext2 and ext3 historically returned...
  */
 int __ext4_check_dir_entry(const char *function, unsigned int line,
-			   struct inode *dir,
+			   struct inode *dir, struct file *filp,
 			   struct ext4_dir_entry_2 *de,
 			   struct buffer_head *bh,
 			   unsigned int offset)
@@ -90,12 +90,21 @@ int __ext4_check_dir_entry(const char *function, unsigned int line,
 	else
 		return 0;
 
-	ext4_error_inode(dir, function, line, bh-&gt;b_blocknr,
-			 "bad entry in directory: %s - "
-			 "offset=%u(%u), inode=%u, rec_len=%d, name_len=%d",
-			 error_msg, (unsigned) (offset%bh-&gt;b_size), offset,
-			 le32_to_cpu(de-&gt;inode),
-			 rlen, de-&gt;name_len);
+	if (filp)
+		ext4_error_file(filp, function, line, bh ? bh-&gt;b_blocknr : 0,
+				"bad entry in directory: %s - offset=%u(%u), "
+				"inode=%u, rec_len=%d, name_len=%d",
+				error_msg, (unsigned) (offset%bh-&gt;b_size),
+				offset, le32_to_cpu(de-&gt;inode),
+				rlen, de-&gt;name_len);
+	else
+		ext4_error_inode(dir, function, line, bh ? bh-&gt;b_blocknr : 0,
+				"bad entry in directory: %s - offset=%u(%u), "
+				"inode=%u, rec_len=%d, name_len=%d",
+				error_msg, (unsigned) (offset%bh-&gt;b_size),
+				offset, le32_to_cpu(de-&gt;inode),
+				rlen, de-&gt;name_len);
+
 	return 1;
 }
 
@@ -158,8 +167,9 @@ static int ext4_readdir(struct file *filp,
 		 */
 		if (!bh) {
 			if (!dir_has_error) {
-				EXT4_ERROR_INODE(inode, "directory "
-					   "contains a hole at offset %Lu",
+				EXT4_ERROR_FILE(filp, 0,
+						"directory contains a "
+						"hole at offset %llu",
 					   (unsigned long long) filp-&gt;f_pos);
 				dir_has_error = 1;
 			}
@@ -200,7 +210,7 @@ static int ext4_readdir(struct file *filp,
 		while (!error &amp;&amp; filp-&gt;f_pos &lt; inode-&gt;i_size
 		       &amp;&amp; offset &lt; sb-&gt;s_blocksize) {
 			de = (struct ext4_dir_entry_2 *) (bh-&gt;b_data + offset);
-			if (ext4_check_dir_entry(inode, de,
+			if (ext4_check_dir_entry(inode, filp, de,
 						 bh, offset)) {
 				/*
 				 * On error, skip the f_pos to the next block
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 8104ab7eb7d4..2a739255ee05 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -62,8 +62,8 @@
 #define EXT4_ERROR_INODE_BLOCK(inode, block, fmt, a...)			\
 	ext4_error_inode((inode), __func__, __LINE__, (block), (fmt), ## a)
 
-#define EXT4_ERROR_FILE(file, fmt, a...)	\
-	ext4_error_file(__func__, __LINE__, (file), (fmt), ## a)
+#define EXT4_ERROR_FILE(file, block, fmt, a...)				\
+	ext4_error_file((file), __func__, __LINE__, (block), (fmt), ## a)
 
 /* data type for block offset of block group */
 typedef int ext4_grpblk_t;
@@ -1640,11 +1640,12 @@ extern unsigned ext4_init_block_bitmap(struct super_block *sb,
 
 /* dir.c */
 extern int __ext4_check_dir_entry(const char *, unsigned int, struct inode *,
+				  struct file *,
 				  struct ext4_dir_entry_2 *,
 				  struct buffer_head *, unsigned int);
-#define ext4_check_dir_entry(dir, de, bh, offset) \
-	unlikely(__ext4_check_dir_entry(__func__, __LINE__, (dir), (de), \
-					(bh), (offset)))
+#define ext4_check_dir_entry(dir, filp, de, bh, offset)			\
+	unlikely(__ext4_check_dir_entry(__func__, __LINE__, (dir), (filp), \
+					(de), (bh), (offset)))
 extern int ext4_htree_store_dirent(struct file *dir_file, __u32 hash,
 				    __u32 minor_hash,
 				    struct ext4_dir_entry_2 *dirent);
@@ -1751,8 +1752,8 @@ extern void ext4_error_inode(struct inode *, const char *, unsigned int,
 			     ext4_fsblk_t, const char *, ...)
 	__attribute__ ((format (printf, 5, 6)));
 extern void ext4_error_file(struct file *, const char *, unsigned int,
-			    const char *, ...)
-	__attribute__ ((format (printf, 4, 5)));
+			    ext4_fsblk_t, const char *, ...)
+	__attribute__ ((format (printf, 5, 6)));
 extern void __ext4_std_error(struct super_block *, const char *,
 			     unsigned int, int);
 extern void __ext4_abort(struct super_block *, const char *, unsigned int,
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index e275464f7754..96a594d86a19 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -581,7 +581,7 @@ static int htree_dirblock_to_tree(struct file *dir_file,
 					   dir-&gt;i_sb-&gt;s_blocksize -
 					   EXT4_DIR_REC_LEN(0));
 	for (; de &lt; top; de = ext4_next_entry(de, dir-&gt;i_sb-&gt;s_blocksize)) {
-		if (ext4_check_dir_entry(dir, de, bh,
+		if (ext4_check_dir_entry(dir, NULL, de, bh,
 				(block&lt;&lt;EXT4_BLOCK_SIZE_BITS(dir-&gt;i_sb))
 					 + ((char *)de - bh-&gt;b_data))) {
 			/* On error, skip the f_pos to the next block. */
@@ -820,7 +820,7 @@ static inline int search_dirblock(struct buffer_head *bh,
 		if ((char *) de + namelen &lt;= dlimit &amp;&amp;
 		    ext4_match (namelen, name, de)) {
 			/* found a match - just to be sure, do a full check */
-			if (ext4_check_dir_entry(dir, de, bh, offset))
+			if (ext4_check_dir_entry(dir, NULL, de, bh, offset))
 				return -1;
 			*res_dir = de;
 			return 1;
@@ -1269,7 +1269,7 @@ static int add_dirent_to_buf(handle_t *handle, struct dentry *dentry,
 		de = (struct ext4_dir_entry_2 *)bh-&gt;b_data;
 		top = bh-&gt;b_data + blocksize - reclen;
 		while ((char *) de &lt;= top) {
-			if (ext4_check_dir_entry(dir, de, bh, offset))
+			if (ext4_check_dir_entry(dir, NULL, de, bh, offset))
 				return -EIO;
 			if (ext4_match(namelen, name, de))
 				return -EEXIST;
@@ -1636,7 +1636,7 @@ static int ext4_delete_entry(handle_t *handle,
 	pde = NULL;
 	de = (struct ext4_dir_entry_2 *) bh-&gt;b_data;
 	while (i &lt; bh-&gt;b_size) {
-		if (ext4_check_dir_entry(dir, de, bh, i))
+		if (ext4_check_dir_entry(dir, NULL, de, bh, i))
 			return -EIO;
 		if (de == de_del)  {
 			BUFFER_TRACE(bh, "get_write_access");
@@ -1919,7 +1919,7 @@ static int empty_dir(struct inode *inode)
 			}
 			de = (struct ext4_dir_entry_2 *) bh-&gt;b_data;
 		}
-		if (ext4_check_dir_entry(inode, de, bh, offset)) {
+		if (ext4_check_dir_entry(inode, NULL, de, bh, offset)) {
 			de = (struct ext4_dir_entry_2 *)(bh-&gt;b_data +
 							 sb-&gt;s_blocksize);
 			offset = (offset | (sb-&gt;s_blocksize - 1)) + 1;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index d49e3b1ec41e..7728a4ca3d6c 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -406,28 +406,31 @@ void ext4_error_inode(struct inode *inode, const char *function,
 		      const char *fmt, ...)
 {
 	va_list args;
+	struct va_format vaf;
 	struct ext4_super_block *es = EXT4_SB(inode-&gt;i_sb)-&gt;s_es;
 
 	es-&gt;s_last_error_ino = cpu_to_le32(inode-&gt;i_ino);
 	es-&gt;s_last_error_block = cpu_to_le64(block);
 	save_error_info(inode-&gt;i_sb, function, line);
 	va_start(args, fmt);
+	vaf.fmt = fmt;
+	vaf.va = &amp;args;
 	printk(KERN_CRIT "EXT4-fs error (device %s): %s:%d: inode #%lu: ",
 	       inode-&gt;i_sb-&gt;s_id, function, line, inode-&gt;i_ino);
 	if (block)
-		printk("block %llu: ", block);
-	printk("comm %s: ", current-&gt;comm);
-	vprintk(fmt, args);
-	printk("\n");
+		printk(KERN_CONT "block %llu: ", block);
+	printk(KERN_CONT "comm %s: %pV\n", current-&gt;comm, &amp;vaf);
 	va_end(args);
 
 	ext4_handle_error(inode-&gt;i_sb);
 }
 
 void ext4_error_file(struct file *file, const char *function,
-		     unsigned int line, const char *fmt, ...)
+		     unsigned int line, ext4_fsblk_t block,
+		     const char *fmt, ...)
 {
 	va_list args;
+	struct va_format vaf;
 	struct ext4_super_block *es;
 	struct inode *inode = file-&gt;f_dentry-&gt;d_inode;
 	char pathname[80], *path;
@@ -435,17 +438,18 @@ void ext4_error_file(struct file *file, const char *function,
 	es = EXT4_SB(inode-&gt;i_sb)-&gt;s_es;
 	es-&gt;s_last_error_ino = cpu_to_le32(inode-&gt;i_ino);
 	save_error_info(inode-&gt;i_sb, function, line);
-	va_start(args, fmt);
 	path = d_path(&amp;(file-&gt;f_path), pathname, sizeof(pathname));
 	if (IS_ERR(path))
 		path = "(unknown)";
 	printk(KERN_CRIT
-	       "EXT4-fs error (device %s): %s:%d: inode #%lu "
-	       "(comm %s path %s): ",
-	       inode-&gt;i_sb-&gt;s_id, function, line, inode-&gt;i_ino,
-	       current-&gt;comm, path);
-	vprintk(fmt, args);
-	printk("\n");
+	       "EXT4-fs error (device %s): %s:%d: inode #%lu: ",
+	       inode-&gt;i_sb-&gt;s_id, function, line, inode-&gt;i_ino);
+	if (block)
+		printk(KERN_CONT "block %llu: ", block);
+	va_start(args, fmt);
+	vaf.fmt = fmt;
+	vaf.va = &amp;args;
+	printk(KERN_CONT "comm %s: path %s: %pV\n", current-&gt;comm, path, &amp;vaf);
 	va_end(args);
 
 	ext4_handle_error(inode-&gt;i_sb);</pre><hr><pre>commit eaeef86718249f5c75b1370f77a9bc11f196a01c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Jan 10 12:10:07 2011 -0500

    ext4: clean up ext4_xattr_list()'s error code checking and return strategy
    
    Any time you see code that tries to add error codes together, you
    should want to claw your eyes out...
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index fa4b899da4b3..ca6ca14a827d 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -427,23 +427,23 @@ ext4_xattr_ibody_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 static int
 ext4_xattr_list(struct dentry *dentry, char *buffer, size_t buffer_size)
 {
-	int i_error, b_error;
+	int ret, ret2;
 
 	down_read(&amp;EXT4_I(dentry-&gt;d_inode)-&gt;xattr_sem);
-	i_error = ext4_xattr_ibody_list(dentry, buffer, buffer_size);
-	if (i_error &lt; 0) {
-		b_error = 0;
-	} else {
-		if (buffer) {
-			buffer += i_error;
-			buffer_size -= i_error;
-		}
-		b_error = ext4_xattr_block_list(dentry, buffer, buffer_size);
-		if (b_error &lt; 0)
-			i_error = 0;
+	ret = ret2 = ext4_xattr_ibody_list(dentry, buffer, buffer_size);
+	if (ret &lt; 0)
+		goto errout;
+	if (buffer) {
+		buffer += ret;
+		buffer_size -= ret;
 	}
+	ret = ext4_xattr_block_list(dentry, buffer, buffer_size);
+	if (ret &lt; 0)
+		goto errout;
+	ret += ret2;
+errout:
 	up_read(&amp;EXT4_I(dentry-&gt;d_inode)-&gt;xattr_sem);
-	return i_error + b_error;
+	return ret;
 }
 
 /*</pre><hr><pre>commit 5026e90b86684bc878e4db0a8cd043fed769719c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Oct 16 19:37:00 2010 -0400

    ext3: Use search_dirblock() in ext3_dx_find_entry()
    
    Use the search_dirblock() in ext3_dx_find_entry().  It makes the code
    easier to read, and it takes advantage of common code.  It also saves
    100 bytes or so of text space.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Brad Spengler &lt;spender@grsecurity.net&gt;
    Signed-off-by: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index d093cbbe38b7..9cc0b2c9664f 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -975,12 +975,9 @@ static struct buffer_head * ext3_dx_find_entry(struct inode *dir,
 	struct super_block *sb = dir-&gt;i_sb;
 	struct dx_hash_info	hinfo;
 	struct dx_frame frames[2], *frame;
-	struct ext3_dir_entry_2 *de, *top;
 	struct buffer_head *bh;
 	unsigned long block;
 	int retval;
-	int namelen = entry-&gt;len;
-	const u8 *name = entry-&gt;name;
 
 	if (!(frame = dx_probe(entry, dir, &amp;hinfo, frames, err)))
 		return NULL;
@@ -988,26 +985,20 @@ static struct buffer_head * ext3_dx_find_entry(struct inode *dir,
 		block = dx_get_block(frame-&gt;at);
 		if (!(bh = ext3_bread (NULL,dir, block, 0, err)))
 			goto errout;
-		de = (struct ext3_dir_entry_2 *) bh-&gt;b_data;
-		top = (struct ext3_dir_entry_2 *) ((char *) de + sb-&gt;s_blocksize -
-				       EXT3_DIR_REC_LEN(0));
-		for (; de &lt; top; de = ext3_next_entry(de)) {
-			int off = (block &lt;&lt; EXT3_BLOCK_SIZE_BITS(sb))
-				  + ((char *) de - bh-&gt;b_data);
-
-			if (!ext3_check_dir_entry(__func__, dir, de, bh, off)) {
-				brelse(bh);
-				*err = ERR_BAD_DX_DIR;
-				goto errout;
-			}
 
-			if (ext3_match(namelen, name, de)) {
-				*res_dir = de;
-				dx_release(frames);
-				return bh;
-			}
+		retval = search_dirblock(bh, dir, entry,
+					 block &lt;&lt; EXT3_BLOCK_SIZE_BITS(sb),
+					 res_dir);
+		if (retval == 1) {
+			dx_release(frames);
+			return bh;
 		}
-		brelse (bh);
+		brelse(bh);
+		if (retval == -1) {
+			*err = ERR_BAD_DX_DIR;
+			goto errout;
+		}
+
 		/* Check to see if we should continue to search */
 		retval = ext3_htree_next_block(dir, hinfo.hash, frame,
 					       frames, NULL);</pre><hr><pre>commit f0cad89f5e8ef8b6d0c065115565524137e44f0b
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Oct 16 19:36:59 2010 -0400

    ext3: Avoid uninitialized memory references with a corrupted htree directory
    
    If the first htree directory is missing '.' or '..' but is otherwise a
    valid directory, and we do a lookup for '.' or '..', it's possible to
    dereference an uninitialized memory pointer in ext3_htree_next_block().
    Avoid this.
    
    We avoid this by moving the special case from ext3_dx_find_entry() to
    ext3_find_entry(); this also means we can optimize ext3_find_entry()
    slightly when NFS looks up "..".
    
    Thanks to Brad Spengler for pointing a Clang warning that led me to
    look more closely at this code.  The warning was harmless, but it was
    useful in pointing out code that was too ugly to live.  This warning was
    also reported by Roman Borisov.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Jan Kara &lt;jack@suse.cz&gt;
    Cc: Brad Spengler &lt;spender@grsecurity.net&gt;
    Signed-off-by: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext3/namei.c b/fs/ext3/namei.c
index 672cea16a8b9..d093cbbe38b7 100644
--- a/fs/ext3/namei.c
+++ b/fs/ext3/namei.c
@@ -858,6 +858,7 @@ static struct buffer_head *ext3_find_entry(struct inode *dir,
 	struct buffer_head * bh_use[NAMEI_RA_SIZE];
 	struct buffer_head * bh, *ret = NULL;
 	unsigned long start, block, b;
+	const u8 *name = entry-&gt;name;
 	int ra_max = 0;		/* Number of bh's in the readahead
 				   buffer, bh_use[] */
 	int ra_ptr = 0;		/* Current index into readahead
@@ -871,6 +872,16 @@ static struct buffer_head *ext3_find_entry(struct inode *dir,
 	namelen = entry-&gt;len;
 	if (namelen &gt; EXT3_NAME_LEN)
 		return NULL;
+	if ((namelen &lt;= 2) &amp;&amp; (name[0] == '.') &amp;&amp;
+	    (name[1] == '.' || name[1] == 0)) {
+		/*
+		 * "." or ".." will only be in the first block
+		 * NFS may look up ".."; "." should be handled by the VFS
+		 */
+		block = start = 0;
+		nblocks = 1;
+		goto restart;
+	}
 	if (is_dx(dir)) {
 		bh = ext3_dx_find_entry(dir, entry, res_dir, &amp;err);
 		/*
@@ -961,9 +972,8 @@ static struct buffer_head * ext3_dx_find_entry(struct inode *dir,
 			struct qstr *entry, struct ext3_dir_entry_2 **res_dir,
 			int *err)
 {
-	struct super_block * sb;
+	struct super_block *sb = dir-&gt;i_sb;
 	struct dx_hash_info	hinfo;
-	u32 hash;
 	struct dx_frame frames[2], *frame;
 	struct ext3_dir_entry_2 *de, *top;
 	struct buffer_head *bh;
@@ -972,18 +982,8 @@ static struct buffer_head * ext3_dx_find_entry(struct inode *dir,
 	int namelen = entry-&gt;len;
 	const u8 *name = entry-&gt;name;
 
-	sb = dir-&gt;i_sb;
-	/* NFS may look up ".." - look at dx_root directory block */
-	if (namelen &gt; 2 || name[0] != '.'|| (namelen == 2 &amp;&amp; name[1] != '.')) {
-		if (!(frame = dx_probe(entry, dir, &amp;hinfo, frames, err)))
-			return NULL;
-	} else {
-		frame = frames;
-		frame-&gt;bh = NULL;			/* for dx_release() */
-		frame-&gt;at = (struct dx_entry *)frames;	/* hack for zero entry*/
-		dx_set_block(frame-&gt;at, 0);		/* dx_root block is 0 */
-	}
-	hash = hinfo.hash;
+	if (!(frame = dx_probe(entry, dir, &amp;hinfo, frames, err)))
+		return NULL;
 	do {
 		block = dx_get_block(frame-&gt;at);
 		if (!(bh = ext3_bread (NULL,dir, block, 0, err)))
@@ -1009,7 +1009,7 @@ static struct buffer_head * ext3_dx_find_entry(struct inode *dir,
 		}
 		brelse (bh);
 		/* Check to see if we should continue to search */
-		retval = ext3_htree_next_block(dir, hash, frame,
+		retval = ext3_htree_next_block(dir, hinfo.hash, frame,
 					       frames, NULL);
 		if (retval &lt; 0) {
 			ext3_warning(sb, __func__,</pre><hr><pre>commit cd8d60a20a4516016c117ac0f1ac7b06ff606f7e
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri Dec 24 09:42:10 2010 -0500

    kbuild: create linux-headers package in deb-pkg
    
    Create a linux-headers-$KVER.deb package which can be used to build
    external modules without having the source tree around.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Signed-off-by: Michal Marek &lt;mmarek@suse.cz&gt;

diff --git a/scripts/package/builddeb b/scripts/package/builddeb
index ffe24194b763..5fc1e6f71838 100644
--- a/scripts/package/builddeb
+++ b/scripts/package/builddeb
@@ -76,15 +76,17 @@ else
 fi
 tmpdir="$objtree/debian/tmp"
 fwdir="$objtree/debian/fwtmp"
+hdrdir="$objtree/debian/hdrtmp"
 packagename=linux-image-$version
 fwpackagename=linux-firmware-image
+hdrpackagename=linux-headers-$version
 
 if [ "$ARCH" = "um" ] ; then
 	packagename=user-mode-linux-$version
 fi
 
 # Setup the directory structure
-rm -rf "$tmpdir" "$fwdir"
+rm -rf "$tmpdir" "$fwdir" "$hdrdir"
 mkdir -m 755 -p "$tmpdir/DEBIAN"
 mkdir -p  "$tmpdir/lib" "$tmpdir/boot" "$tmpdir/usr/share/doc/$packagename"
 mkdir -m 755 -p "$fwdir/DEBIAN"
@@ -226,6 +228,30 @@ EOF
 
 fi
 
+# Build header package
+find . -name Makefile -o -name Kconfig\* -o -name \*.pl &gt; /tmp/files$$
+find arch/x86/include include scripts -type f &gt;&gt; /tmp/files$$
+(cd $objtree; find .config Module.symvers include scripts -type f &gt;&gt; /tmp/objfiles$$)
+destdir=$hdrdir/usr/src/linux-headers-$version
+mkdir -p "$destdir" "$hdrdir/DEBIAN" "$hdrdir/usr/share/doc/$hdrpackagename"
+tar -c -f - -T /tmp/files$$ | (cd $destdir; tar -xf -)
+(cd $objtree; tar -c -f - -T /tmp/objfiles$$) | (cd $destdir; tar -xf -)
+rm -f /tmp/files$$ /tmp/objfiles$$
+arch=$(dpkg --print-architecture)
+
+cat &lt;&lt;EOF &gt;&gt; debian/control
+
+Package: $hdrpackagename
+Provides: linux-headers, linux-headers-2.6
+Architecture: $arch
+Description: Linux kernel headers for $KERNELRELEASE on $arch
+ This package provides kernel header files for $KERNELRELEASE on $arch
+ .
+ This is useful for people who need to build external modules
+EOF
+
+create_package "$hdrpackagename" "$hdrdir"
+
 # Do we have firmware? Move it out of the way and build it into a package.
 if [ -e "$tmpdir/lib/firmware" ]; then
 	mv "$tmpdir/lib/firmware" "$fwdir/lib/"</pre><hr><pre>commit 8a7411a24350bac141271755c66f40c56b0535ae
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Dec 20 22:30:36 2010 -0500

    ext4: fix on-line resizing regression
    
    https://bugzilla.kernel.org/show_bug.cgi?id=25352
    
    This regression was caused by commit a31437b85: "ext4: use
    sb_issue_zeroout in setup_new_group_blocks", by accidentally dropping
    the code which reserved the block group descriptor and inode table
    blocks.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index dc963929de65..981c8477adab 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -232,6 +232,8 @@ static int setup_new_group_blocks(struct super_block *sb,
 			       GFP_NOFS);
 	if (err)
 		goto exit_bh;
+	for (i = 0, bit = gdblocks + 1; i &lt; reserved_gdb; i++, bit++)
+		ext4_set_bit(bit, bh-&gt;b_data);
 
 	ext4_debug("mark block bitmap %#04llx (+%llu)\n", input-&gt;block_bitmap,
 		   input-&gt;block_bitmap - start);
@@ -247,6 +249,9 @@ static int setup_new_group_blocks(struct super_block *sb,
 	err = sb_issue_zeroout(sb, block, sbi-&gt;s_itb_per_group, GFP_NOFS);
 	if (err)
 		goto exit_bh;
+	for (i = 0, bit = input-&gt;inode_table - start;
+	     i &lt; sbi-&gt;s_itb_per_group; i++, bit++)
+		ext4_set_bit(bit, bh-&gt;b_data);
 
 	if ((err = extend_or_restart_transaction(handle, 2, bh)))
 		goto exit_bh;</pre><hr><pre>commit b72143ab3ed566a12560fa4411a1f02c276dcc39
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Dec 20 07:26:59 2010 -0500

    ext4: Add error checking to kmem_cache_alloc() call in ext4_free_blocks()
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 731b6f738a03..46d5414f59c1 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -4626,7 +4626,11 @@ void ext4_free_blocks(handle_t *handle, struct inode *inode,
 		 * blocks being freed are metadata. these blocks shouldn't
 		 * be used until this transaction is committed
 		 */
-		new_entry  = kmem_cache_alloc(ext4_free_ext_cachep, GFP_NOFS);
+		new_entry = kmem_cache_alloc(ext4_free_ext_cachep, GFP_NOFS);
+		if (!new_entry) {
+			err = -ENOMEM;
+			goto error_return;
+		}
 		new_entry-&gt;start_blk = bit;
 		new_entry-&gt;group  = block_group;
 		new_entry-&gt;count = count;</pre>
    <div class="pagination">
        <a href='1_75.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><span>[76]</span><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_77.html'>Next&gt;&gt;</a>
    <div>
</body>
