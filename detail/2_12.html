<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_11.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><span>[12]</span><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_13.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ddc82999f02580f93f9be2b8fb3b10f6139fb281
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 1 13:40:11 2019 -0400

    tools/memory-model/Documentation: Put redefinition of rcu-fence into explanation.txt
    
    This patch updates the Linux Kernel Memory Model's explanation.txt
    file to incorporate the introduction of the rcu-order relation and
    the redefinition of rcu-fence made by commit 15aa25cbf0cc
    ("tools/memory-model: Change definition of rcu-fence").
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Andrea Parri &lt;parri.andrea@gmail.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 1b5264559cd6..ecf6cccea5c3 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -27,7 +27,7 @@ Explanation of the Linux-Kernel Memory Consistency Model
   19. AND THEN THERE WAS ALPHA
   20. THE HAPPENS-BEFORE RELATION: hb
   21. THE PROPAGATES-BEFORE RELATION: pb
-  22. RCU RELATIONS: rcu-link, rcu-gp, rcu-rscsi, rcu-fence, and rb
+  22. RCU RELATIONS: rcu-link, rcu-gp, rcu-rscsi, rcu-order, rcu-fence, and rb
   23. LOCKING
   24. ODDS AND ENDS
 
@@ -1425,8 +1425,8 @@ they execute means that it cannot have cycles.  This requirement is
 the content of the LKMM's "propagation" axiom.
 
 
-RCU RELATIONS: rcu-link, rcu-gp, rcu-rscsi, rcu-fence, and rb
--------------------------------------------------------------
+RCU RELATIONS: rcu-link, rcu-gp, rcu-rscsi, rcu-order, rcu-fence, and rb
+------------------------------------------------------------------------
 
 RCU (Read-Copy-Update) is a powerful synchronization mechanism.  It
 rests on two concepts: grace periods and read-side critical sections.
@@ -1536,29 +1536,29 @@ Z's CPU before Z begins but doesn't propagate to some other CPU until
 after X ends.)  Similarly, X -&gt;rcu-rscsi Y -&gt;rcu-link Z says that X is
 the end of a critical section which starts before Z begins.
 
-The LKMM goes on to define the rcu-fence relation as a sequence of
+The LKMM goes on to define the rcu-order relation as a sequence of
 rcu-gp and rcu-rscsi links separated by rcu-link links, in which the
 number of rcu-gp links is &gt;= the number of rcu-rscsi links.  For
 example:
 
 	X -&gt;rcu-gp Y -&gt;rcu-link Z -&gt;rcu-rscsi T -&gt;rcu-link U -&gt;rcu-gp V
 
-would imply that X -&gt;rcu-fence V, because this sequence contains two
+would imply that X -&gt;rcu-order V, because this sequence contains two
 rcu-gp links and one rcu-rscsi link.  (It also implies that
-X -&gt;rcu-fence T and Z -&gt;rcu-fence V.)  On the other hand:
+X -&gt;rcu-order T and Z -&gt;rcu-order V.)  On the other hand:
 
 	X -&gt;rcu-rscsi Y -&gt;rcu-link Z -&gt;rcu-rscsi T -&gt;rcu-link U -&gt;rcu-gp V
 
-does not imply X -&gt;rcu-fence V, because the sequence contains only
+does not imply X -&gt;rcu-order V, because the sequence contains only
 one rcu-gp link but two rcu-rscsi links.
 
-The rcu-fence relation is important because the Grace Period Guarantee
-means that rcu-fence acts kind of like a strong fence.  In particular,
-E -&gt;rcu-fence F implies not only that E begins before F ends, but also
-that any write po-before E will propagate to every CPU before any
-instruction po-after F can execute.  (However, it does not imply that
-E must execute before F; in fact, each synchronize_rcu() fence event
-is linked to itself by rcu-fence as a degenerate case.)
+The rcu-order relation is important because the Grace Period Guarantee
+means that rcu-order links act kind of like strong fences.  In
+particular, E -&gt;rcu-order F implies not only that E begins before F
+ends, but also that any write po-before E will propagate to every CPU
+before any instruction po-after F can execute.  (However, it does not
+imply that E must execute before F; in fact, each synchronize_rcu()
+fence event is linked to itself by rcu-order as a degenerate case.)
 
 To prove this in full generality requires some intellectual effort.
 We'll consider just a very simple case:
@@ -1585,7 +1585,26 @@ G's CPU before G starts must propagate to every CPU before C starts.
 In particular, the write propagates to every CPU before F finishes
 executing and hence before any instruction po-after F can execute.
 This sort of reasoning can be extended to handle all the situations
-covered by rcu-fence.
+covered by rcu-order.
+
+The rcu-fence relation is a simple extension of rcu-order.  While
+rcu-order only links certain fence events (calls to synchronize_rcu(),
+rcu_read_lock(), or rcu_read_unlock()), rcu-fence links any events
+that are separated by an rcu-order link.  This is analogous to the way
+the strong-fence relation links events that are separated by an
+smp_mb() fence event (as mentioned above, rcu-order links act kind of
+like strong fences).  Written symbolically, X -&gt;rcu-fence Y means
+there are fence events E and F such that:
+
+	X -&gt;po E -&gt;rcu-order F -&gt;po Y.
+
+From the discussion above, we see this implies not only that X
+executes before Y, but also (if X is a store) that X propagates to
+every CPU before Y executes.  Thus rcu-fence is sort of a
+"super-strong" fence: Unlike the original strong fences (smp_mb() and
+synchronize_rcu()), rcu-fence is able to link events on different
+CPUs.  (Perhaps this fact should lead us to say that rcu-fence isn't
+really a fence at all!)
 
 Finally, the LKMM defines the RCU-before (rb) relation in terms of
 rcu-fence.  This is done in essentially the same way as the pb
@@ -1596,7 +1615,7 @@ before F, just as E -&gt;pb F does (and for much the same reasons).
 Putting this all together, the LKMM expresses the Grace Period
 Guarantee by requiring that the rb relation does not contain a cycle.
 Equivalently, this "rcu" axiom requires that there are no events E
-and F with E -&gt;rcu-link F -&gt;rcu-fence E.  Or to put it a third way,
+and F with E -&gt;rcu-link F -&gt;rcu-order E.  Or to put it a third way,
 the axiom requires that there are no cycles consisting of rcu-gp and
 rcu-rscsi alternating with rcu-link, where the number of rcu-gp links
 is &gt;= the number of rcu-rscsi links.
@@ -1750,7 +1769,7 @@ addition to normal RCU.  The ideas involved are much the same as
 above, with new relations srcu-gp and srcu-rscsi added to represent
 SRCU grace periods and read-side critical sections.  There is a
 restriction on the srcu-gp and srcu-rscsi links that can appear in an
-rcu-fence sequence (the srcu-rscsi links must be paired with srcu-gp
+rcu-order sequence (the srcu-rscsi links must be paired with srcu-gp
 links having the same SRCU domain with proper nesting); the details
 are relatively unimportant.
 </pre><hr><pre>commit 3321ea12907abd477ff7e9bf5f365524b8f1f2fc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 1 13:39:47 2019 -0400

    tools/memory-model/Documentation: Fix typos in explanation.txt
    
    This patch fixes a few minor typos and improves word usage in a few
    places in the Linux Kernel Memory Model's explanation.txt file.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Joel Fernandes (Google) &lt;joel@joelfernandes.org&gt;
    Acked-by: Andrea Parri &lt;parri.andrea@gmail.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/explanation.txt b/tools/memory-model/Documentation/explanation.txt
index 488f11f6c588..1b5264559cd6 100644
--- a/tools/memory-model/Documentation/explanation.txt
+++ b/tools/memory-model/Documentation/explanation.txt
@@ -206,7 +206,7 @@ goes like this:
 	P0 stores 1 to buf before storing 1 to flag, since it executes
 	its instructions in order.
 
-	Since an instruction (in this case, P1's store to flag) cannot
+	Since an instruction (in this case, P0's store to flag) cannot
 	execute before itself, the specified outcome is impossible.
 
 However, real computer hardware almost never follows the Sequential
@@ -419,7 +419,7 @@ example:
 
 The object code might call f(5) either before or after g(6); the
 memory model cannot assume there is a fixed program order relation
-between them.  (In fact, if the functions are inlined then the
+between them.  (In fact, if the function calls are inlined then the
 compiler might even interleave their object code.)
 
 
@@ -499,7 +499,7 @@ different CPUs (external reads-from, or rfe).
 
 For our purposes, a memory location's initial value is treated as
 though it had been written there by an imaginary initial store that
-executes on a separate CPU before the program runs.
+executes on a separate CPU before the main program runs.
 
 Usage of the rf relation implicitly assumes that loads will always
 read from a single store.  It doesn't apply properly in the presence
@@ -955,7 +955,7 @@ atomic update.  This is what the LKMM's "atomic" axiom says.
 THE PRESERVED PROGRAM ORDER RELATION: ppo
 -----------------------------------------
 
-There are many situations where a CPU is obligated to execute two
+There are many situations where a CPU is obliged to execute two
 instructions in program order.  We amalgamate them into the ppo (for
 "preserved program order") relation, which links the po-earlier
 instruction to the po-later instruction and is thus a sub-relation of
@@ -1572,7 +1572,7 @@ and there are events X, Y and a read-side critical section C such that:
 
 	2. X comes "before" Y in some sense (including rfe, co and fr);
 
-	2. Y is po-before Z;
+	3. Y is po-before Z;
 
 	4. Z is the rcu_read_unlock() event marking the end of C;
 </pre><hr><pre>commit daebf24a8e8c6064cba3a330db9fe9376a137d2c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 6 16:57:22 2019 -0400

    tools/memory-model: Fix data race detection for unordered store and load
    
    Currently the Linux Kernel Memory Model gives an incorrect response
    for the following litmus test:
    
    C plain-WWC
    
    {}
    
    P0(int *x)
    {
            WRITE_ONCE(*x, 2);
    }
    
    P1(int *x, int *y)
    {
            int r1;
            int r2;
            int r3;
    
            r1 = READ_ONCE(*x);
            if (r1 == 2) {
                    smp_rmb();
                    r2 = *x;
            }
            smp_rmb();
            r3 = READ_ONCE(*x);
            WRITE_ONCE(*y, r3 - 1);
    }
    
    P2(int *x, int *y)
    {
            int r4;
    
            r4 = READ_ONCE(*y);
            if (r4 &gt; 0)
                    WRITE_ONCE(*x, 1);
    }
    
    exists (x=2 /\ 1:r2=2 /\ 2:r4=1)
    
    The memory model says that the plain read of *x in P1 races with the
    WRITE_ONCE(*x) in P2.
    
    The problem is that we have a write W and a read R related by neither
    fre or rfe, but rather W -&gt;coe W' -&gt;rfe R, where W' is an intermediate
    write (the WRITE_ONCE() in P0).  In this situation there is no
    particular ordering between W and R, so either a wr-vis link from W to
    R or an rw-xbstar link from R to W would prove that the accesses
    aren't concurrent.
    
    But the LKMM only looks for a wr-vis link, which is equivalent to
    assuming that W must execute before R.  This is not necessarily true
    on non-multicopy-atomic systems, as the WWC pattern demonstrates.
    
    This patch changes the LKMM to accept either a wr-vis or a reverse
    rw-xbstar link as a proof of non-concurrency.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Andrea Parri &lt;parri.andrea@gmail.com&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/linux-kernel.cat b/tools/memory-model/linux-kernel.cat
index ea2ff4b94074..2a9b4fe4a84e 100644
--- a/tools/memory-model/linux-kernel.cat
+++ b/tools/memory-model/linux-kernel.cat
@@ -197,7 +197,7 @@ empty (wr-incoh | rw-incoh | ww-incoh) as plain-coherence
 (* Actual races *)
 let ww-nonrace = ww-vis &amp; ((Marked * W) | rw-xbstar) &amp; ((W * Marked) | wr-vis)
 let ww-race = (pre-race &amp; co) \ ww-nonrace
-let wr-race = (pre-race &amp; (co? ; rf)) \ wr-vis
+let wr-race = (pre-race &amp; (co? ; rf)) \ wr-vis \ rw-xbstar^-1
 let rw-race = (pre-race &amp; fr) \ rw-xbstar
 
 flag ~empty (ww-race | wr-race | rw-race) as data-race</pre><hr><pre>commit 32a0721c6620b77504916dac0cea8ad497c4878a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 17 12:47:23 2019 -0400

    USB: yurex: Don't retry on unexpected errors
    
    According to Greg KH, it has been generally agreed that when a USB
    driver encounters an unknown error (or one it can't handle directly),
    it should just give up instead of going into a potentially infinite
    retry loop.
    
    The three codes -EPROTO, -EILSEQ, and -ETIME fall into this category.
    They can be caused by bus errors such as packet loss or corruption,
    attempting to communicate with a disconnected device, or by malicious
    firmware.  Nowadays the extent of packet loss or corruption is
    negligible, so it should be safe for a driver to give up whenever one
    of these errors occurs.
    
    Although the yurex driver handles -EILSEQ errors in this way, it
    doesn't do the same for -EPROTO (as discovered by the syzbot fuzzer)
    or other unrecognized errors.  This patch adjusts the driver so that
    it doesn't log an error message for -EPROTO or -ETIME, and it doesn't
    retry after any errors.
    
    Reported-and-tested-by: syzbot+b24d736f18a1541ad550@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Tomoki Sekiyama &lt;tomoki.sekiyama@gmail.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1909171245410.1590-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 6715a128e6c8..8d52d4336c29 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -132,6 +132,7 @@ static void yurex_interrupt(struct urb *urb)
 	switch (status) {
 	case 0: /*success*/
 		break;
+	/* The device is terminated or messed up, give up */
 	case -EOVERFLOW:
 		dev_err(&amp;dev-&gt;interface-&gt;dev,
 			"%s - overflow with length %d, actual length is %d\n",
@@ -140,12 +141,13 @@ static void yurex_interrupt(struct urb *urb)
 	case -ENOENT:
 	case -ESHUTDOWN:
 	case -EILSEQ:
-		/* The device is terminated, clean up */
+	case -EPROTO:
+	case -ETIME:
 		return;
 	default:
 		dev_err(&amp;dev-&gt;interface-&gt;dev,
 			"%s - unknown status received: %d\n", __func__, status);
-		goto exit;
+		return;
 	}
 
 	/* handle received message */
@@ -177,7 +179,6 @@ static void yurex_interrupt(struct urb *urb)
 		break;
 	}
 
-exit:
 	retval = usb_submit_urb(dev-&gt;urb, GFP_ATOMIC);
 	if (retval) {
 		dev_err(&amp;dev-&gt;interface-&gt;dev, "%s - usb_submit_urb failed: %d\n",</pre><hr><pre>commit d9d4b1e46d9543a82c23f6df03f4ad697dab361b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Oct 3 14:53:59 2019 -0400

    HID: Fix assumption that devices have inputs
    
    The syzbot fuzzer found a slab-out-of-bounds write bug in the hid-gaff
    driver.  The problem is caused by the driver's assumption that the
    device must have an input report.  While this will be true for all
    normal HID input devices, a suitably malicious device can violate the
    assumption.
    
    The same assumption is present in over a dozen other HID drivers.
    This patch fixes them by checking that the list of hid_inputs for the
    hid_device is nonempty before allowing it to be used.
    
    Reported-and-tested-by: syzbot+403741a091bf41d4ae79@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt;

diff --git a/drivers/hid/hid-axff.c b/drivers/hid/hid-axff.c
index 6654c1550e2e..fbe4e16ab029 100644
--- a/drivers/hid/hid-axff.c
+++ b/drivers/hid/hid-axff.c
@@ -63,13 +63,20 @@ static int axff_init(struct hid_device *hid)
 {
 	struct axff_device *axff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int field_count = 0;
 	int i, j;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-dr.c b/drivers/hid/hid-dr.c
index 17e17f9a597b..947f19f8685f 100644
--- a/drivers/hid/hid-dr.c
+++ b/drivers/hid/hid-dr.c
@@ -75,13 +75,19 @@ static int drff_init(struct hid_device *hid)
 {
 	struct drff_device *drff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_first_entry(&amp;hid-&gt;inputs,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-emsff.c b/drivers/hid/hid-emsff.c
index 7cd5651872d3..c34f2e5a049f 100644
--- a/drivers/hid/hid-emsff.c
+++ b/drivers/hid/hid-emsff.c
@@ -47,13 +47,19 @@ static int emsff_init(struct hid_device *hid)
 {
 	struct emsff_device *emsff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_first_entry(&amp;hid-&gt;inputs,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_first_entry(&amp;hid-&gt;inputs, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-gaff.c b/drivers/hid/hid-gaff.c
index 0f95c96b70f8..ecbd3995a4eb 100644
--- a/drivers/hid/hid-gaff.c
+++ b/drivers/hid/hid-gaff.c
@@ -64,14 +64,20 @@ static int gaff_init(struct hid_device *hid)
 {
 	struct gaff_device *gaff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
 	struct list_head *report_ptr = report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output reports found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-holtekff.c b/drivers/hid/hid-holtekff.c
index 10a720558830..8619b80c834c 100644
--- a/drivers/hid/hid-holtekff.c
+++ b/drivers/hid/hid-holtekff.c
@@ -124,13 +124,19 @@ static int holtekff_init(struct hid_device *hid)
 {
 	struct holtekff_device *holtekff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
+	struct hid_input *hidinput;
 	struct list_head *report_list =
 			&amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
-	struct input_dev *dev = hidinput-&gt;input;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (list_empty(report_list)) {
 		hid_err(hid, "no output report found\n");
 		return -ENODEV;
diff --git a/drivers/hid/hid-lg2ff.c b/drivers/hid/hid-lg2ff.c
index dd1a6c3a7de6..73d07e35f12a 100644
--- a/drivers/hid/hid-lg2ff.c
+++ b/drivers/hid/hid-lg2ff.c
@@ -50,11 +50,17 @@ int lg2ff_init(struct hid_device *hid)
 {
 	struct lg2ff_device *lg2ff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	int error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7);
 	if (!report)
diff --git a/drivers/hid/hid-lg3ff.c b/drivers/hid/hid-lg3ff.c
index 9ecb6fd06203..b7e1949f3cf7 100644
--- a/drivers/hid/hid-lg3ff.c
+++ b/drivers/hid/hid-lg3ff.c
@@ -117,12 +117,19 @@ static const signed short ff3_joystick_ac[] = {
 
 int lg3ff_init(struct hid_device *hid)
 {
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	const signed short *ff_bits = ff3_joystick_ac;
 	int error;
 	int i;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 35))
 		return -ENODEV;
diff --git a/drivers/hid/hid-lg4ff.c b/drivers/hid/hid-lg4ff.c
index 03f0220062ca..5e6a0cef2a06 100644
--- a/drivers/hid/hid-lg4ff.c
+++ b/drivers/hid/hid-lg4ff.c
@@ -1253,8 +1253,8 @@ static int lg4ff_handle_multimode_wheel(struct hid_device *hid, u16 *real_produc
 
 int lg4ff_init(struct hid_device *hid)
 {
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	struct list_head *report_list = &amp;hid-&gt;report_enum[HID_OUTPUT_REPORT].report_list;
 	struct hid_report *report = list_entry(report_list-&gt;next, struct hid_report, list);
 	const struct usb_device_descriptor *udesc = &amp;(hid_to_usb_dev(hid)-&gt;descriptor);
@@ -1266,6 +1266,13 @@ int lg4ff_init(struct hid_device *hid)
 	int mmode_ret, mmode_idx = -1;
 	u16 real_product_id;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return -1;
diff --git a/drivers/hid/hid-lgff.c b/drivers/hid/hid-lgff.c
index c79a6ec43745..aed4ddc397a9 100644
--- a/drivers/hid/hid-lgff.c
+++ b/drivers/hid/hid-lgff.c
@@ -115,12 +115,19 @@ static void hid_lgff_set_autocenter(struct input_dev *dev, u16 magnitude)
 
 int lgff_init(struct hid_device* hid)
 {
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	const signed short *ff_bits = ff_joystick;
 	int error;
 	int i;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	/* Check that the report looks ok */
 	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
 		return -ENODEV;
diff --git a/drivers/hid/hid-logitech-hidpp.c b/drivers/hid/hid-logitech-hidpp.c
index 0179f7ed77e5..1ac1ecc1e67c 100644
--- a/drivers/hid/hid-logitech-hidpp.c
+++ b/drivers/hid/hid-logitech-hidpp.c
@@ -2084,8 +2084,8 @@ static void hidpp_ff_destroy(struct ff_device *ff)
 static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 {
 	struct hid_device *hid = hidpp-&gt;hid_dev;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	const struct usb_device_descriptor *udesc = &amp;(hid_to_usb_dev(hid)-&gt;descriptor);
 	const u16 bcdDevice = le16_to_cpu(udesc-&gt;bcdDevice);
 	struct ff_device *ff;
@@ -2094,6 +2094,13 @@ static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 	int error, j, num_slots;
 	u8 version;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	if (!dev) {
 		hid_err(hid, "Struct input_dev not set!\n");
 		return -EINVAL;
diff --git a/drivers/hid/hid-microsoft.c b/drivers/hid/hid-microsoft.c
index 2cf83856f2e4..2d8b589201a4 100644
--- a/drivers/hid/hid-microsoft.c
+++ b/drivers/hid/hid-microsoft.c
@@ -328,11 +328,17 @@ static int ms_play_effect(struct input_dev *dev, void *data,
 
 static int ms_init_ff(struct hid_device *hdev)
 {
-	struct hid_input *hidinput = list_entry(hdev-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *input_dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *input_dev;
 	struct ms_data *ms = hid_get_drvdata(hdev);
 
+	if (list_empty(&amp;hdev-&gt;inputs)) {
+		hid_err(hdev, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hdev-&gt;inputs.next, struct hid_input, list);
+	input_dev = hidinput-&gt;input;
+
 	if (!(ms-&gt;quirks &amp; MS_QUIRK_FF))
 		return 0;
 
diff --git a/drivers/hid/hid-sony.c b/drivers/hid/hid-sony.c
index 73c0f7a95e2d..4c6ed6ef31f1 100644
--- a/drivers/hid/hid-sony.c
+++ b/drivers/hid/hid-sony.c
@@ -2254,9 +2254,15 @@ static int sony_play_effect(struct input_dev *dev, void *data,
 
 static int sony_init_ff(struct sony_sc *sc)
 {
-	struct hid_input *hidinput = list_entry(sc-&gt;hdev-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *input_dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *input_dev;
+
+	if (list_empty(&amp;sc-&gt;hdev-&gt;inputs)) {
+		hid_err(sc-&gt;hdev, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(sc-&gt;hdev-&gt;inputs.next, struct hid_input, list);
+	input_dev = hidinput-&gt;input;
 
 	input_set_capability(input_dev, EV_FF, FF_RUMBLE);
 	return input_ff_create_memless(input_dev, NULL, sony_play_effect);
diff --git a/drivers/hid/hid-tmff.c b/drivers/hid/hid-tmff.c
index bdfc5ff3b2c5..90acef304536 100644
--- a/drivers/hid/hid-tmff.c
+++ b/drivers/hid/hid-tmff.c
@@ -124,12 +124,18 @@ static int tmff_init(struct hid_device *hid, const signed short *ff_bits)
 	struct tmff_device *tmff;
 	struct hid_report *report;
 	struct list_head *report_list;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-							struct hid_input, list);
-	struct input_dev *input_dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *input_dev;
 	int error;
 	int i;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	input_dev = hidinput-&gt;input;
+
 	tmff = kzalloc(sizeof(struct tmff_device), GFP_KERNEL);
 	if (!tmff)
 		return -ENOMEM;
diff --git a/drivers/hid/hid-zpff.c b/drivers/hid/hid-zpff.c
index f90959e94028..3abaca045869 100644
--- a/drivers/hid/hid-zpff.c
+++ b/drivers/hid/hid-zpff.c
@@ -54,11 +54,17 @@ static int zpff_init(struct hid_device *hid)
 {
 	struct zpff_device *zpff;
 	struct hid_report *report;
-	struct hid_input *hidinput = list_entry(hid-&gt;inputs.next,
-						struct hid_input, list);
-	struct input_dev *dev = hidinput-&gt;input;
+	struct hid_input *hidinput;
+	struct input_dev *dev;
 	int i, error;
 
+	if (list_empty(&amp;hid-&gt;inputs)) {
+		hid_err(hid, "no inputs found\n");
+		return -ENODEV;
+	}
+	hidinput = list_entry(hid-&gt;inputs.next, struct hid_input, list);
+	dev = hidinput-&gt;input;
+
 	for (i = 0; i &lt; 4; i++) {
 		report = hid_validate_values(hid, HID_OUTPUT_REPORT, 0, i, 1);
 		if (!report)</pre><hr><pre>commit 98375b86c79137416e9fd354177b85e768c16e56
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 4 11:54:20 2019 -0400

    HID: prodikeys: Fix general protection fault during probe
    
    The syzbot fuzzer provoked a general protection fault in the
    hid-prodikeys driver:
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] SMP KASAN
    CPU: 0 PID: 12 Comm: kworker/0:1 Not tainted 5.3.0-rc5+ #28
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Workqueue: usb_hub_wq hub_event
    RIP: 0010:pcmidi_submit_output_report drivers/hid/hid-prodikeys.c:300  [inline]
    RIP: 0010:pcmidi_set_operational drivers/hid/hid-prodikeys.c:558 [inline]
    RIP: 0010:pcmidi_snd_initialise drivers/hid/hid-prodikeys.c:686 [inline]
    RIP: 0010:pk_probe+0xb51/0xfd0 drivers/hid/hid-prodikeys.c:836
    Code: 0f 85 50 04 00 00 48 8b 04 24 4c 89 7d 10 48 8b 58 08 e8 b2 53 e4 fc
    48 8b 54 24 20 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 &lt;80&gt; 3c 02 00 0f
    85 13 04 00 00 48 ba 00 00 00 00 00 fc ff df 49 8b
    
    The problem is caused by the fact that pcmidi_get_output_report() will
    return an error if the HID device doesn't provide the right sort of
    output report, but pcmidi_set_operational() doesn't bother to check
    the return code and assumes the function call always succeeds.
    
    This patch adds the missing check and aborts the probe operation if
    necessary.
    
    Reported-and-tested-by: syzbot+1088533649dafa1c9004@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-prodikeys.c b/drivers/hid/hid-prodikeys.c
index 21544ebff855..5a3b3d974d84 100644
--- a/drivers/hid/hid-prodikeys.c
+++ b/drivers/hid/hid-prodikeys.c
@@ -551,10 +551,14 @@ static void pcmidi_setup_extra_keys(
 
 static int pcmidi_set_operational(struct pcmidi_snd *pm)
 {
+	int rc;
+
 	if (pm-&gt;ifnum != 1)
 		return 0; /* only set up ONCE for interace 1 */
 
-	pcmidi_get_output_report(pm);
+	rc = pcmidi_get_output_report(pm);
+	if (rc &lt; 0)
+		return rc;
 	pcmidi_submit_output_report(pm, 0xc1);
 	return 0;
 }
@@ -683,7 +687,11 @@ static int pcmidi_snd_initialise(struct pcmidi_snd *pm)
 	spin_lock_init(&amp;pm-&gt;rawmidi_in_lock);
 
 	init_sustain_timers(pm);
-	pcmidi_set_operational(pm);
+	err = pcmidi_set_operational(pm);
+	if (err &lt; 0) {
+		pk_error("failed to find output report\n");
+		goto fail_register;
+	}
 
 	/* register it */
 	err = snd_card_register(card);</pre><hr><pre>commit 3dd550a2d36596a1b0ee7955da3b611c031d3873
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Sep 4 11:56:27 2019 -0400

    USB: usbcore: Fix slab-out-of-bounds bug during device reset
    
    The syzbot fuzzer provoked a slab-out-of-bounds error in the USB core:
    
    BUG: KASAN: slab-out-of-bounds in memcmp+0xa6/0xb0 lib/string.c:904
    Read of size 1 at addr ffff8881d175bed6 by task kworker/0:3/2746
    
    CPU: 0 PID: 2746 Comm: kworker/0:3 Not tainted 5.3.0-rc5+ #28
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Workqueue: usb_hub_wq hub_event
    Call Trace:
      __dump_stack lib/dump_stack.c:77 [inline]
      dump_stack+0xca/0x13e lib/dump_stack.c:113
      print_address_description+0x6a/0x32c mm/kasan/report.c:351
      __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482
      kasan_report+0xe/0x12 mm/kasan/common.c:612
      memcmp+0xa6/0xb0 lib/string.c:904
      memcmp include/linux/string.h:400 [inline]
      descriptors_changed drivers/usb/core/hub.c:5579 [inline]
      usb_reset_and_verify_device+0x564/0x1300 drivers/usb/core/hub.c:5729
      usb_reset_device+0x4c1/0x920 drivers/usb/core/hub.c:5898
      rt2x00usb_probe+0x53/0x7af
    drivers/net/wireless/ralink/rt2x00/rt2x00usb.c:806
    
    The error occurs when the descriptors_changed() routine (called during
    a device reset) attempts to compare the old and new BOS and capability
    descriptors.  The length it uses for the comparison is the
    wTotalLength value stored in BOS descriptor, but this value is not
    necessarily the same as the length actually allocated for the
    descriptors.  If it is larger the routine will call memcmp() with a
    length that is too big, thus reading beyond the end of the allocated
    region and leading to this fault.
    
    The kernel reads the BOS descriptor twice: first to get the total
    length of all the capability descriptors, and second to read it along
    with all those other descriptors.  A malicious (or very faulty) device
    may send different values for the BOS descriptor fields each time.
    The memory area will be allocated using the wTotalLength value read
    the first time, but stored within it will be the value read the second
    time.
    
    To prevent this possibility from causing any errors, this patch
    modifies the BOS descriptor after it has been read the second time:
    It sets the wTotalLength field to the actual length of the descriptors
    that were read in and validated.  Then the memcpy() call, or any other
    code using these descriptors, will be able to rely on wTotalLength
    being valid.
    
    Reported-and-tested-by: syzbot+35f4d916c623118d576e@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1909041154260.1722-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index 9d6cb709ca7b..151a74a54386 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -921,7 +921,7 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 	struct usb_bos_descriptor *bos;
 	struct usb_dev_cap_header *cap;
 	struct usb_ssp_cap_descriptor *ssp_cap;
-	unsigned char *buffer;
+	unsigned char *buffer, *buffer0;
 	int length, total_len, num, i, ssac;
 	__u8 cap_type;
 	int ret;
@@ -966,10 +966,12 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 			ret = -ENOMSG;
 		goto err;
 	}
+
+	buffer0 = buffer;
 	total_len -= length;
+	buffer += length;
 
 	for (i = 0; i &lt; num; i++) {
-		buffer += length;
 		cap = (struct usb_dev_cap_header *)buffer;
 
 		if (total_len &lt; sizeof(*cap) || total_len &lt; cap-&gt;bLength) {
@@ -983,8 +985,6 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 			break;
 		}
 
-		total_len -= length;
-
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
 			dev_warn(ddev, "descriptor type invalid, skip\n");
 			continue;
@@ -1019,7 +1019,11 @@ int usb_get_bos_descriptor(struct usb_device *dev)
 		default:
 			break;
 		}
+
+		total_len -= length;
+		buffer += length;
 	}
+	dev-&gt;bos-&gt;desc-&gt;wTotalLength = cpu_to_le16(buffer - buffer0);
 
 	return 0;
 </pre><hr><pre>commit 9472aff16ca0fd9351eea7773facef364743088f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Aug 8 13:34:08 2019 -0400

    USB: rio500: Fix lockdep violation
    
    The syzbot fuzzer found a lockdep violation in the rio500 driver:
    
            ======================================================
            WARNING: possible circular locking dependency detected
            5.3.0-rc2+ #23 Not tainted
            ------------------------------------------------------
            syz-executor.2/20386 is trying to acquire lock:
            00000000772249c6 (rio500_mutex){+.+.}, at: open_rio+0x16/0xc0
            drivers/usb/misc/rio500.c:64
    
            but task is already holding lock:
            00000000d3e8f4b9 (minor_rwsem){++++}, at: usb_open+0x23/0x270
            drivers/usb/core/file.c:39
    
            which lock already depends on the new lock.
    
    The problem is that the driver's open_rio() routine is called while
    the usbcore's minor_rwsem is locked for reading, and it acquires the
    rio500_mutex; whereas conversely, probe_rio() and disconnect_rio()
    first acquire the rio500_mutex and then call usb_register_dev() or
    usb_deregister_dev(), which lock minor_rwsem for writing.
    
    The correct ordering of acquisition should be: minor_rwsem first, then
    rio500_mutex (since the locking in open_rio() cannot be changed).
    Thus, the probe and disconnect routines should avoid holding
    rio500_mutex while doing their registration and deregistration.
    
    This patch adjusts the code in those two routines to do just that.  It
    also relies on the fact that the probe and disconnect routines are
    protected by the device mutex, so the initial test of rio-&gt;present
    needs no extra locking.
    
    Reported-by: syzbot+7bbcbe9c9ff0cd49592a@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Fixes: d710734b0677 ("USB: rio500: simplify locking")
    Acked-by: Oliver Neukum &lt;oneukum@suse.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    
    Link: https://lore.kernel.org/r/Pine.LNX.4.44L0.1908081329240.1319-100000@iolanthe.rowland.org
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/rio500.c b/drivers/usb/misc/rio500.c
index 27e9c78a791e..30cae5e1954d 100644
--- a/drivers/usb/misc/rio500.c
+++ b/drivers/usb/misc/rio500.c
@@ -454,51 +454,55 @@ static int probe_rio(struct usb_interface *intf,
 {
 	struct usb_device *dev = interface_to_usbdev(intf);
 	struct rio_usb_data *rio = &amp;rio_instance;
-	int retval = 0;
+	int retval = -ENOMEM;
+	char *ibuf, *obuf;
 
-	mutex_lock(&amp;rio500_mutex);
 	if (rio-&gt;present) {
 		dev_info(&amp;intf-&gt;dev, "Second USB Rio at address %d refused\n", dev-&gt;devnum);
-		retval = -EBUSY;
-		goto bail_out;
-	} else {
-		dev_info(&amp;intf-&gt;dev, "USB Rio found at address %d\n", dev-&gt;devnum);
-	}
-
-	retval = usb_register_dev(intf, &amp;usb_rio_class);
-	if (retval) {
-		dev_err(&amp;dev-&gt;dev,
-			"Not able to get a minor for this device.\n");
-		retval = -ENOMEM;
-		goto bail_out;
+		return -EBUSY;
 	}
+	dev_info(&amp;intf-&gt;dev, "USB Rio found at address %d\n", dev-&gt;devnum);
 
-	rio-&gt;rio_dev = dev;
-
-	if (!(rio-&gt;obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {
+	obuf = kmalloc(OBUF_SIZE, GFP_KERNEL);
+	if (!obuf) {
 		dev_err(&amp;dev-&gt;dev,
 			"probe_rio: Not enough memory for the output buffer\n");
-		usb_deregister_dev(intf, &amp;usb_rio_class);
-		retval = -ENOMEM;
-		goto bail_out;
+		goto err_obuf;
 	}
-	dev_dbg(&amp;intf-&gt;dev, "obuf address:%p\n", rio-&gt;obuf);
+	dev_dbg(&amp;intf-&gt;dev, "obuf address: %p\n", obuf);
 
-	if (!(rio-&gt;ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {
+	ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL);
+	if (!ibuf) {
 		dev_err(&amp;dev-&gt;dev,
 			"probe_rio: Not enough memory for the input buffer\n");
-		usb_deregister_dev(intf, &amp;usb_rio_class);
-		kfree(rio-&gt;obuf);
-		retval = -ENOMEM;
-		goto bail_out;
+		goto err_ibuf;
 	}
-	dev_dbg(&amp;intf-&gt;dev, "ibuf address:%p\n", rio-&gt;ibuf);
+	dev_dbg(&amp;intf-&gt;dev, "ibuf address: %p\n", ibuf);
 
-	usb_set_intfdata (intf, rio);
+	mutex_lock(&amp;rio500_mutex);
+	rio-&gt;rio_dev = dev;
+	rio-&gt;ibuf = ibuf;
+	rio-&gt;obuf = obuf;
 	rio-&gt;present = 1;
-bail_out:
 	mutex_unlock(&amp;rio500_mutex);
 
+	retval = usb_register_dev(intf, &amp;usb_rio_class);
+	if (retval) {
+		dev_err(&amp;dev-&gt;dev,
+			"Not able to get a minor for this device.\n");
+		goto err_register;
+	}
+
+	usb_set_intfdata(intf, rio);
+	return retval;
+
+ err_register:
+	mutex_lock(&amp;rio500_mutex);
+	rio-&gt;present = 0;
+	mutex_unlock(&amp;rio500_mutex);
+ err_ibuf:
+	kfree(obuf);
+ err_obuf:
 	return retval;
 }
 
@@ -507,10 +511,10 @@ static void disconnect_rio(struct usb_interface *intf)
 	struct rio_usb_data *rio = usb_get_intfdata (intf);
 
 	usb_set_intfdata (intf, NULL);
-	mutex_lock(&amp;rio500_mutex);
 	if (rio) {
 		usb_deregister_dev(intf, &amp;usb_rio_class);
 
+		mutex_lock(&amp;rio500_mutex);
 		if (rio-&gt;isopen) {
 			rio-&gt;isopen = 0;
 			/* better let it finish - the release will do whats needed */
@@ -524,8 +528,8 @@ static void disconnect_rio(struct usb_interface *intf)
 		dev_info(&amp;intf-&gt;dev, "USB Rio disconnected.\n");
 
 		rio-&gt;present = 0;
+		mutex_unlock(&amp;rio500_mutex);
 	}
-	mutex_unlock(&amp;rio500_mutex);
 }
 
 static const struct usb_device_id rio_table[] = {</pre><hr><pre>commit 5f9242775bb61f390f0885f23fc16397262c7538
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Aug 20 16:00:21 2019 -0400

    HID: logitech: Fix general protection fault caused by Logitech driver
    
    The syzbot fuzzer found a general protection fault in the HID subsystem:
    
    kasan: CONFIG_KASAN_INLINE enabled
    kasan: GPF could be caused by NULL-ptr deref or user memory access
    general protection fault: 0000 [#1] SMP KASAN
    CPU: 0 PID: 3715 Comm: syz-executor.3 Not tainted 5.2.0-rc6+ #15
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    RIP: 0010:__pm_runtime_resume+0x49/0x180 drivers/base/power/runtime.c:1069
    Code: ed 74 d5 fe 45 85 ed 0f 85 9a 00 00 00 e8 6f 73 d5 fe 48 8d bd c1 02
    00 00 48 b8 00 00 00 00 00 fc ff df 48 89 fa 48 c1 ea 03 &lt;0f&gt; b6 04 02 48
    89 fa 83 e2 07 38 d0 7f 08 84 c0 0f 85 fe 00 00 00
    RSP: 0018:ffff8881d99d78e0 EFLAGS: 00010202
    RAX: dffffc0000000000 RBX: 0000000000000020 RCX: ffffc90003f3f000
    RDX: 0000000416d8686d RSI: ffffffff82676841 RDI: 00000020b6c3436a
    RBP: 00000020b6c340a9 R08: ffff8881c6d64800 R09: fffffbfff0e84c25
    R10: ffff8881d99d7940 R11: ffffffff87426127 R12: 0000000000000004
    R13: 0000000000000000 R14: ffff8881d9b94000 R15: ffffffff897f9048
    FS:  00007f047f542700(0000) GS:ffff8881db200000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000001b30f21000 CR3: 00000001ca032000 CR4: 00000000001406f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
      pm_runtime_get_sync include/linux/pm_runtime.h:226 [inline]
      usb_autopm_get_interface+0x1b/0x50 drivers/usb/core/driver.c:1707
      usbhid_power+0x7c/0xe0 drivers/hid/usbhid/hid-core.c:1234
      hid_hw_power include/linux/hid.h:1038 [inline]
      hidraw_open+0x20d/0x740 drivers/hid/hidraw.c:282
      chrdev_open+0x219/0x5c0 fs/char_dev.c:413
      do_dentry_open+0x497/0x1040 fs/open.c:778
      do_last fs/namei.c:3416 [inline]
      path_openat+0x1430/0x3ff0 fs/namei.c:3533
      do_filp_open+0x1a1/0x280 fs/namei.c:3563
      do_sys_open+0x3c0/0x580 fs/open.c:1070
      do_syscall_64+0xb7/0x560 arch/x86/entry/common.c:301
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    
    It turns out the fault was caused by a bug in the HID Logitech driver,
    which violates the requirement that every pathway calling
    hid_hw_start() must also call hid_hw_stop().  This patch fixes the bug
    by making sure the requirement is met.
    
    Reported-and-tested-by: syzbot+3cbe5cd105d2ad56a1df@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-lg.c b/drivers/hid/hid-lg.c
index 5008a3dc28f4..0dc7cdfc56f7 100644
--- a/drivers/hid/hid-lg.c
+++ b/drivers/hid/hid-lg.c
@@ -818,7 +818,7 @@ static int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)
 
 		if (!buf) {
 			ret = -ENOMEM;
-			goto err_free;
+			goto err_stop;
 		}
 
 		ret = hid_hw_raw_request(hdev, buf[0], buf, sizeof(cbuf),
@@ -850,9 +850,12 @@ static int lg_probe(struct hid_device *hdev, const struct hid_device_id *id)
 		ret = lg4ff_init(hdev);
 
 	if (ret)
-		goto err_free;
+		goto err_stop;
 
 	return 0;
+
+err_stop:
+	hid_hw_stop(hdev);
 err_free:
 	kfree(drv_data);
 	return ret;
@@ -863,8 +866,7 @@ static void lg_remove(struct hid_device *hdev)
 	struct lg_drv_data *drv_data = hid_get_drvdata(hdev);
 	if (drv_data-&gt;quirks &amp; LG_FF4)
 		lg4ff_deinit(hdev);
-	else
-		hid_hw_stop(hdev);
+	hid_hw_stop(hdev);
 	kfree(drv_data);
 }
 
diff --git a/drivers/hid/hid-lg4ff.c b/drivers/hid/hid-lg4ff.c
index cefba038520c..03f0220062ca 100644
--- a/drivers/hid/hid-lg4ff.c
+++ b/drivers/hid/hid-lg4ff.c
@@ -1477,7 +1477,6 @@ int lg4ff_deinit(struct hid_device *hid)
 		}
 	}
 #endif
-	hid_hw_stop(hid);
 	drv_data-&gt;device_props = NULL;
 
 	kfree(entry);</pre><hr><pre>commit 416dacb819f59180e4d86a5550052033ebb6d72c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 21 13:27:12 2019 -0400

    HID: hidraw: Fix invalid read in hidraw_ioctl
    
    The syzbot fuzzer has reported a pair of problems in the
    hidraw_ioctl() function: slab-out-of-bounds read and use-after-free
    read.  An example of the first:
    
    BUG: KASAN: slab-out-of-bounds in strlen+0x79/0x90 lib/string.c:525
    Read of size 1 at addr ffff8881c8035f38 by task syz-executor.4/2833
    
    CPU: 1 PID: 2833 Comm: syz-executor.4 Not tainted 5.3.0-rc2+ #1
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS
    Google 01/01/2011
    Call Trace:
      __dump_stack lib/dump_stack.c:77 [inline]
      dump_stack+0xca/0x13e lib/dump_stack.c:113
      print_address_description+0x6a/0x32c mm/kasan/report.c:351
      __kasan_report.cold+0x1a/0x33 mm/kasan/report.c:482
      kasan_report+0xe/0x12 mm/kasan/common.c:612
      strlen+0x79/0x90 lib/string.c:525
      strlen include/linux/string.h:281 [inline]
      hidraw_ioctl+0x245/0xae0 drivers/hid/hidraw.c:446
      vfs_ioctl fs/ioctl.c:46 [inline]
      file_ioctl fs/ioctl.c:509 [inline]
      do_vfs_ioctl+0xd2d/0x1330 fs/ioctl.c:696
      ksys_ioctl+0x9b/0xc0 fs/ioctl.c:713
      __do_sys_ioctl fs/ioctl.c:720 [inline]
      __se_sys_ioctl fs/ioctl.c:718 [inline]
      __x64_sys_ioctl+0x6f/0xb0 fs/ioctl.c:718
      do_syscall_64+0xb7/0x580 arch/x86/entry/common.c:296
      entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x459829
    Code: fd b7 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7
    48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 &lt;48&gt; 3d 01 f0 ff
    ff 0f 83 cb b7 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007f7a68f6dc78 EFLAGS: 00000246 ORIG_RAX: 0000000000000010
    RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 0000000000459829
    RDX: 0000000000000000 RSI: 0000000080404805 RDI: 0000000000000004
    RBP: 000000000075bf20 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00007f7a68f6e6d4
    R13: 00000000004c21de R14: 00000000004d5620 R15: 00000000ffffffff
    
    The two problems have the same cause: hidraw_ioctl() fails to test
    whether the device has been removed.  This patch adds the missing test.
    
    Reported-and-tested-by: syzbot+5a6c4ec678a0c6ee84ba@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hidraw.c b/drivers/hid/hidraw.c
index 006bd6f4f653..62ef47a730b0 100644
--- a/drivers/hid/hidraw.c
+++ b/drivers/hid/hidraw.c
@@ -370,7 +370,7 @@ static long hidraw_ioctl(struct file *file, unsigned int cmd,
 
 	mutex_lock(&amp;minors_lock);
 	dev = hidraw_table[minor];
-	if (!dev) {
+	if (!dev || !dev-&gt;exist) {
 		ret = -ENODEV;
 		goto out;
 	}</pre>
    <div class="pagination">
        <a href='2_11.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><span>[12]</span><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_13.html'>Next&gt;&gt;</a>
    <div>
</body>
