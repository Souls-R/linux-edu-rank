<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Minnesota</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Minnesota</h1>
    <div class="pagination">
        <a href='7_17.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><span>[18]</span><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_19.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 106204b56f60abf1bead7dceb88f2be3e34433da
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Tue Mar 12 03:33:28 2019 -0500

    thunderbolt: property: Fix a NULL pointer dereference
    
    In case kzalloc fails, the fix releases resources and returns
    -ENOMEM to avoid the NULL pointer dereference.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Mika Westerberg &lt;mika.westerberg@linux.intel.com&gt;

diff --git a/drivers/thunderbolt/property.c b/drivers/thunderbolt/property.c
index b2f0d6386cee..ee76449524a3 100644
--- a/drivers/thunderbolt/property.c
+++ b/drivers/thunderbolt/property.c
@@ -548,6 +548,11 @@ int tb_property_add_data(struct tb_property_dir *parent, const char *key,
 
 	property-&gt;length = size / 4;
 	property-&gt;value.data = kzalloc(size, GFP_KERNEL);
+	if (!property-&gt;value.data) {
+		kfree(property);
+		return -ENOMEM;
+	}
+
 	memcpy(property-&gt;value.data, buf, buflen);
 
 	list_add_tail(&amp;property-&gt;list, &amp;parent-&gt;properties);</pre><hr><pre>commit d7737d4257459ca8921ff911c88937be1a11ea9d
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Mon Mar 18 22:19:44 2019 -0500

    nfc: Fix to check for kmemdup failure
    
    In case of kmemdup failure while setting the service name the patch
    returns -ENOMEM upstream for processing.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Signed-off-by: David S. Miller &lt;davem@davemloft.net&gt;

diff --git a/net/nfc/llcp_sock.c b/net/nfc/llcp_sock.c
index ae296273ce3d..17dcd0b5eb32 100644
--- a/net/nfc/llcp_sock.c
+++ b/net/nfc/llcp_sock.c
@@ -726,6 +726,10 @@ static int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr,
 	llcp_sock-&gt;service_name = kmemdup(addr-&gt;service_name,
 					  llcp_sock-&gt;service_name_len,
 					  GFP_KERNEL);
+	if (!llcp_sock-&gt;service_name) {
+		ret = -ENOMEM;
+		goto sock_llcp_release;
+	}
 
 	nfc_llcp_sock_link(&amp;local-&gt;connecting_sockets, sk);
 
@@ -745,10 +749,11 @@ static int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr,
 	return ret;
 
 sock_unlink:
-	nfc_llcp_put_ssap(local, llcp_sock-&gt;ssap);
-
 	nfc_llcp_sock_unlink(&amp;local-&gt;connecting_sockets, sk);
 
+sock_llcp_release:
+	nfc_llcp_put_ssap(local, llcp_sock-&gt;ssap);
+
 put_dev:
 	nfc_put_device(dev);
 </pre><hr><pre>commit 0ab34a08812a3334350dbaf69a018ee0ab3d2ddd
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Thu Dec 20 23:54:03 2018 -0500

    media: si2165: fix a missing check of return value
    
    si2165_readreg8() may fail. Looking into si2165_readreg8(), we will find
    that "val_tmp" will be an uninitialized value when regmap_read() fails.
    "val_tmp" is then assigned to "val". So if si2165_readreg8() fails,
    "val" will be a random value. Further use will lead to undefined
    behaviors. The fix checks if si2165_readreg8() fails, and if so, returns
    its error code upstream.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Reviewed-by: Matthias Schwarzott &lt;zzam@gentoo.org&gt;
    Tested-by: Matthias Schwarzott &lt;zzam@gentoo.org&gt;
    Signed-off-by: Sean Young &lt;sean@mess.org&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab+samsung@kernel.org&gt;

diff --git a/drivers/media/dvb-frontends/si2165.c b/drivers/media/dvb-frontends/si2165.c
index feacd8da421d..d55d8f169dca 100644
--- a/drivers/media/dvb-frontends/si2165.c
+++ b/drivers/media/dvb-frontends/si2165.c
@@ -275,18 +275,20 @@ static u32 si2165_get_fe_clk(struct si2165_state *state)
 
 static int si2165_wait_init_done(struct si2165_state *state)
 {
-	int ret = -EINVAL;
+	int ret;
 	u8 val = 0;
 	int i;
 
 	for (i = 0; i &lt; 3; ++i) {
-		si2165_readreg8(state, REG_INIT_DONE, &amp;val);
+		ret = si2165_readreg8(state, REG_INIT_DONE, &amp;val);
+		if (ret &lt; 0)
+			return ret;
 		if (val == 0x01)
 			return 0;
 		usleep_range(1000, 50000);
 	}
 	dev_err(&amp;state-&gt;client-&gt;dev, "init_done was not set\n");
-	return ret;
+	return -EINVAL;
 }
 
 static int si2165_upload_firmware_block(struct si2165_state *state,</pre><hr><pre>commit 63a06181d7ce169d09843645c50fea1901bc9f0a
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Fri Mar 15 02:11:56 2019 -0500

    scsi: ufs: fix a missing check of devm_reset_control_get
    
    devm_reset_control_get could fail, so the fix checks its return value and
    passes the error code upstream in case it fails.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Acked-by: Avri Altman &lt;avri.altman@wdc.com&gt;
    Signed-off-by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;

diff --git a/drivers/scsi/ufs/ufs-hisi.c b/drivers/scsi/ufs/ufs-hisi.c
index 0e855b5afe82..2f592df921d9 100644
--- a/drivers/scsi/ufs/ufs-hisi.c
+++ b/drivers/scsi/ufs/ufs-hisi.c
@@ -587,6 +587,10 @@ static int ufs_hisi_init_common(struct ufs_hba *hba)
 	ufshcd_set_variant(hba, host);
 
 	host-&gt;rst  = devm_reset_control_get(dev, "rst");
+	if (IS_ERR(host-&gt;rst)) {
+		dev_err(dev, "%s: failed to get reset control\n", __func__);
+		return PTR_ERR(host-&gt;rst);
+	}
 
 	ufs_hisi_set_pm_lvl(hba);
 </pre><hr><pre>commit 6734330654dac550f12e932996b868c6d0dcb421
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Thu Mar 14 02:21:51 2019 -0500

    tty: mxs-auart: fix a potential NULL pointer dereference
    
    In case ioremap fails, the fix returns -ENOMEM to avoid NULL
    pointer dereferences.
    Multiple places use port.membase.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/tty/serial/mxs-auart.c b/drivers/tty/serial/mxs-auart.c
index 27235a526cce..4c188f4079b3 100644
--- a/drivers/tty/serial/mxs-auart.c
+++ b/drivers/tty/serial/mxs-auart.c
@@ -1686,6 +1686,10 @@ static int mxs_auart_probe(struct platform_device *pdev)
 
 	s-&gt;port.mapbase = r-&gt;start;
 	s-&gt;port.membase = ioremap(r-&gt;start, resource_size(r));
+	if (!s-&gt;port.membase) {
+		ret = -ENOMEM;
+		goto out_disable_clks;
+	}
 	s-&gt;port.ops = &amp;mxs_auart_ops;
 	s-&gt;port.iotype = UPIO_MEM;
 	s-&gt;port.fifosize = MXS_AUART_FIFO_SIZE;</pre><hr><pre>commit c85be041065c0be8bc48eda4c45e0319caf1d0e5
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Fri Mar 15 12:16:06 2019 -0500

    tty: atmel_serial: fix a potential NULL pointer dereference
    
    In case dmaengine_prep_dma_cyclic fails, the fix returns a proper
    error code to avoid NULL pointer dereference.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Fixes: 34df42f59a60 ("serial: at91: add rx dma support")
    Acked-by: Richard Genoud &lt;richard.genoud@gmail.com&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c
index 05147fe24343..41b728d223d1 100644
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -1288,6 +1288,10 @@ static int atmel_prepare_rx_dma(struct uart_port *port)
 					 sg_dma_len(&amp;atmel_port-&gt;sg_rx)/2,
 					 DMA_DEV_TO_MEM,
 					 DMA_PREP_INTERRUPT);
+	if (!desc) {
+		dev_err(port-&gt;dev, "Preparing DMA cyclic failed\n");
+		goto chan_err;
+	}
 	desc-&gt;callback = atmel_complete_rx_dma;
 	desc-&gt;callback_param = port;
 	atmel_port-&gt;desc_rx = desc;</pre><hr><pre>commit 3a10e3dd52e80b9a97a3346020024d17b2c272d6
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Mon Mar 18 18:44:14 2019 -0500

    serial: max310x: Fix to avoid potential NULL pointer dereference
    
    of_match_device can return a NULL pointer when matching device is not
    found. This patch avoids a scenario causing NULL pointer derefernce.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/tty/serial/max310x.c b/drivers/tty/serial/max310x.c
index f5bdde405627..450ba6d7996c 100644
--- a/drivers/tty/serial/max310x.c
+++ b/drivers/tty/serial/max310x.c
@@ -1415,6 +1415,8 @@ static int max310x_spi_probe(struct spi_device *spi)
 	if (spi-&gt;dev.of_node) {
 		const struct of_device_id *of_id =
 			of_match_device(max310x_dt_ids, &amp;spi-&gt;dev);
+		if (!of_id)
+			return -ENODEV;
 
 		devtype = (struct max310x_devtype *)of_id-&gt;data;
 	} else {</pre><hr><pre>commit 32f47179833b63de72427131169809065db6745e
Author: Aditya Pakki &lt;pakki001@umn.edu&gt;
Date:   Mon Mar 18 18:50:56 2019 -0500

    serial: mvebu-uart: Fix to avoid a potential NULL pointer dereference
    
    of_match_device on failure to find a matching device can return a NULL
    pointer. The patch checks for such a scenrio and passes the error upstream.
    
    Signed-off-by: Aditya Pakki &lt;pakki001@umn.edu&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/tty/serial/mvebu-uart.c b/drivers/tty/serial/mvebu-uart.c
index 231f751d1ef4..7e7b1559fa36 100644
--- a/drivers/tty/serial/mvebu-uart.c
+++ b/drivers/tty/serial/mvebu-uart.c
@@ -810,6 +810,9 @@ static int mvebu_uart_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	if (!match)
+		return -ENODEV;
+
 	/* Assume that all UART ports have a DT alias or none has */
 	id = of_alias_get_id(pdev-&gt;dev.of_node, "serial");
 	if (!pdev-&gt;dev.of_node || id &lt; 0)</pre><hr><pre>commit 6c44b15e1c9076d925d5236ddadf1318b0a25ce2
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Thu Mar 14 00:24:02 2019 -0500

    HID: logitech: check the return value of create_singlethread_workqueue
    
    create_singlethread_workqueue may fail and return NULL. The fix checks if it is
    NULL to avoid NULL pointer dereference.  Also, the fix moves the call of
    create_singlethread_workqueue earlier to avoid resource-release issues.
    
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/hid-logitech-hidpp.c b/drivers/hid/hid-logitech-hidpp.c
index 15ed6177a7a3..0a243247b231 100644
--- a/drivers/hid/hid-logitech-hidpp.c
+++ b/drivers/hid/hid-logitech-hidpp.c
@@ -2111,6 +2111,13 @@ static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 		kfree(data);
 		return -ENOMEM;
 	}
+	data-&gt;wq = create_singlethread_workqueue("hidpp-ff-sendqueue");
+	if (!data-&gt;wq) {
+		kfree(data-&gt;effect_ids);
+		kfree(data);
+		return -ENOMEM;
+	}
+
 	data-&gt;hidpp = hidpp;
 	data-&gt;feature_index = feature_index;
 	data-&gt;version = version;
@@ -2155,7 +2162,6 @@ static int hidpp_ff_init(struct hidpp_device *hidpp, u8 feature_index)
 	/* ignore boost value at response.fap.params[2] */
 
 	/* init the hardware command queue */
-	data-&gt;wq = create_singlethread_workqueue("hidpp-ff-sendqueue");
 	atomic_set(&amp;data-&gt;workqueue_size, 0);
 
 	/* initialize with zero autocenter to get wheel in usable state */</pre><hr><pre>commit 6d65561f3d5ec933151939c543d006b79044e7a6
Author: Kangjie Lu &lt;kjlu@umn.edu&gt;
Date:   Thu Mar 14 02:58:18 2019 -0500

    netfilter: ip6t_srh: fix NULL pointer dereferences
    
    skb_header_pointer may return NULL. The current code dereference
    its return values without a NULL check.
    
    The fix inserts the checks to avoid NULL pointer dereferences.
    
    Fixes: 202a8ff545cc ("netfilter: add IPv6 segment routing header 'srh' match")
    Signed-off-by: Kangjie Lu &lt;kjlu@umn.edu&gt;
    Signed-off-by: Pablo Neira Ayuso &lt;pablo@netfilter.org&gt;

diff --git a/net/ipv6/netfilter/ip6t_srh.c b/net/ipv6/netfilter/ip6t_srh.c
index 1059894a6f4c..4cb83fb69844 100644
--- a/net/ipv6/netfilter/ip6t_srh.c
+++ b/net/ipv6/netfilter/ip6t_srh.c
@@ -210,6 +210,8 @@ static bool srh1_mt6(const struct sk_buff *skb, struct xt_action_param *par)
 		psidoff = srhoff + sizeof(struct ipv6_sr_hdr) +
 			  ((srh-&gt;segments_left + 1) * sizeof(struct in6_addr));
 		psid = skb_header_pointer(skb, psidoff, sizeof(_psid), &amp;_psid);
+		if (!psid)
+			return false;
 		if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_PSID,
 				ipv6_masked_addr_cmp(psid, &amp;srhinfo-&gt;psid_msk,
 						     &amp;srhinfo-&gt;psid_addr)))
@@ -223,6 +225,8 @@ static bool srh1_mt6(const struct sk_buff *skb, struct xt_action_param *par)
 		nsidoff = srhoff + sizeof(struct ipv6_sr_hdr) +
 			  ((srh-&gt;segments_left - 1) * sizeof(struct in6_addr));
 		nsid = skb_header_pointer(skb, nsidoff, sizeof(_nsid), &amp;_nsid);
+		if (!nsid)
+			return false;
 		if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_NSID,
 				ipv6_masked_addr_cmp(nsid, &amp;srhinfo-&gt;nsid_msk,
 						     &amp;srhinfo-&gt;nsid_addr)))
@@ -233,6 +237,8 @@ static bool srh1_mt6(const struct sk_buff *skb, struct xt_action_param *par)
 	if (srhinfo-&gt;mt_flags &amp; IP6T_SRH_LSID) {
 		lsidoff = srhoff + sizeof(struct ipv6_sr_hdr);
 		lsid = skb_header_pointer(skb, lsidoff, sizeof(_lsid), &amp;_lsid);
+		if (!lsid)
+			return false;
 		if (NF_SRH_INVF(srhinfo, IP6T_SRH_INV_LSID,
 				ipv6_masked_addr_cmp(lsid, &amp;srhinfo-&gt;lsid_msk,
 						     &amp;srhinfo-&gt;lsid_addr)))</pre>
    <div class="pagination">
        <a href='7_17.html'>&lt;&lt;Prev</a><a href='7.html'>1</a><a href='7_2.html'>2</a><a href='7_3.html'>3</a><a href='7_4.html'>4</a><a href='7_5.html'>5</a><a href='7_6.html'>6</a><a href='7_7.html'>7</a><a href='7_8.html'>8</a><a href='7_9.html'>9</a><a href='7_10.html'>10</a><a href='7_11.html'>11</a><a href='7_12.html'>12</a><a href='7_13.html'>13</a><a href='7_14.html'>14</a><a href='7_15.html'>15</a><a href='7_16.html'>16</a><a href='7_17.html'>17</a><span>[18]</span><a href='7_19.html'>19</a><a href='7_20.html'>20</a><a href='7_21.html'>21</a><a href='7_22.html'>22</a><a href='7_23.html'>23</a><a href='7_24.html'>24</a><a href='7_25.html'>25</a><a href='7_26.html'>26</a><a href='7_27.html'>27</a><a href='7_28.html'>28</a><a href='7_29.html'>29</a><a href='7_30.html'>30</a><a href='7_19.html'>Next&gt;&gt;</a>
    <div>
</body>
