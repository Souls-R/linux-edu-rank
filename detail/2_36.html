<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_35.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><span>[36]</span><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_37.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit f467ff4c7dd736b4a3c7e715efed763c0b021838
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 13:19:10 2013 -0400

    USB: FHCI: upgrade the isochronous API
    
    This patch attempts to fix the isochronous API in the fhci-hcd
    driver.  There are two problems with the current code:
    
            ed-&gt;last_iso is used but not set anywhere.  The patch changes
            its name to ed-&gt;next_iso and uses it to store the frame number
            of the next available slot in the isochronous stream.
    
            urb-&gt;start_frame isn't set when the URB_ISO_ASAP flag is off.
            The patch sets it to the next available slot if the stream is
            in use, or the current frame otherwise.
    
    This won't give the right behavior when an underrun occurs, but I
    don't know enough about the driver to handle that case.
    
    Unfortunately, I don't have any way to test these changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Anton Vorontsov &lt;avorontsov@ru.mvista.com&gt;
    CC: Li Yang &lt;leoli@freescale.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/fhci-sched.c b/drivers/usb/host/fhci-sched.c
index 8f18538e0ff7..95ca5986e672 100644
--- a/drivers/usb/host/fhci-sched.c
+++ b/drivers/usb/host/fhci-sched.c
@@ -739,9 +739,13 @@ void fhci_queue_urb(struct fhci_hcd *fhci, struct urb *urb)
 	}
 
 	/* for ISO transfer calculate start frame index */
-	if (ed-&gt;mode == FHCI_TF_ISO &amp;&amp; urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
-		urb-&gt;start_frame = ed-&gt;td_head ? ed-&gt;last_iso + 1 :
+	if (ed-&gt;mode == FHCI_TF_ISO) {
+		/* Ignore the possibility of underruns */
+		urb-&gt;start_frame = ed-&gt;td_head ? ed-&gt;next_iso :
 						 get_frame_num(fhci);
+		ed-&gt;next_iso = (urb-&gt;start_frame + urb-&gt;interval *
+				urb-&gt;number_of_packets) &amp; 0x07ff;
+	}
 
 	/*
 	 * OHCI handles the DATA toggle itself,we just use the USB
diff --git a/drivers/usb/host/fhci.h b/drivers/usb/host/fhci.h
index 7cc1c32dc36c..154e6a007727 100644
--- a/drivers/usb/host/fhci.h
+++ b/drivers/usb/host/fhci.h
@@ -338,7 +338,7 @@ struct ed {
 
 	/* read only parameters, should be cleared upon initialization */
 	u8 toggle_carry;	/* toggle carry from the last TD submitted */
-	u32 last_iso;		/* time stamp of last queued ISO transfer */
+	u16 next_iso;		/* time stamp of next queued ISO transfer */
 	struct td *td_head;	/* a pointer to the current TD handled */
 };
 </pre><hr><pre>commit 9db33f317432d1a9e22116092c6455ae71bf73fc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 13:20:00 2013 -0400

    USB: IMX21: upgrade the isochronous API
    
    This patch attempts to update the imx21-hcd driver to the current
    standard for the isochronous API.  Firstly, urb-&gt;start_frame should
    always be set by the driver; it is not an input parameter.  Secondly,
    the URB_ISO_ASAP flag matters only when an URB is submitted to a
    stream that has gotten an underrun.  It causes the URB to be scheduled
    for the next available slot in the future, rather than the earliest
    unused (and expired) slot.
    
    Unfortunately, I don't have any way to test these changes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Sascha Hauer &lt;kernel@pengutronix.de&gt;
    CC: Martin Fuzzey &lt;mfuzzey@gmail.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/imx21-hcd.c b/drivers/usb/host/imx21-hcd.c
index f0ebe8e7c58b..03dc4d9cbeca 100644
--- a/drivers/usb/host/imx21-hcd.c
+++ b/drivers/usb/host/imx21-hcd.c
@@ -809,26 +809,36 @@ static int imx21_hc_urb_enqueue_isoc(struct usb_hcd *hcd,
 
 	/* calculate frame */
 	cur_frame = imx21_hc_get_frame(hcd);
-	if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
-		if (list_empty(&amp;ep_priv-&gt;td_list))
-			urb-&gt;start_frame = cur_frame + 5;
-		else
-			urb-&gt;start_frame = list_entry(
-				ep_priv-&gt;td_list.prev,
-				struct td, list)-&gt;frame + urb-&gt;interval;
-	}
-	urb-&gt;start_frame = wrap_frame(urb-&gt;start_frame);
-	if (frame_after(cur_frame, urb-&gt;start_frame)) {
-		dev_dbg(imx21-&gt;dev,
-			"enqueue: adjusting iso start %d (cur=%d) asap=%d\n",
-			urb-&gt;start_frame, cur_frame,
-			(urb-&gt;transfer_flags &amp; URB_ISO_ASAP) != 0);
-		urb-&gt;start_frame = wrap_frame(cur_frame + 1);
+	i = 0;
+	if (list_empty(&amp;ep_priv-&gt;td_list)) {
+		urb-&gt;start_frame = wrap_frame(cur_frame + 5);
+	} else {
+		urb-&gt;start_frame = wrap_frame(list_entry(ep_priv-&gt;td_list.prev,
+				struct td, list)-&gt;frame + urb-&gt;interval);
+
+		if (frame_after(cur_frame, urb-&gt;start_frame)) {
+			dev_dbg(imx21-&gt;dev,
+				"enqueue: adjusting iso start %d (cur=%d) asap=%d\n",
+				urb-&gt;start_frame, cur_frame,
+				(urb-&gt;transfer_flags &amp; URB_ISO_ASAP) != 0);
+			i = DIV_ROUND_UP(wrap_frame(
+					cur_frame - urb-&gt;start_frame),
+					urb-&gt;interval);
+			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
+				urb-&gt;start_frame = wrap_frame(urb-&gt;start_frame
+						+ i * urb-&gt;interval);
+				i = 0;
+			} else if (i &gt;= urb-&gt;number_of_packets) {
+				ret = -EXDEV;
+				goto alloc_dmem_failed;
+			}
+		}
 	}
 
 	/* set up transfers */
+	urb_priv-&gt;isoc_remaining = urb-&gt;number_of_packets - i;
 	td = urb_priv-&gt;isoc_td;
-	for (i = 0; i &lt; urb-&gt;number_of_packets; i++, td++) {
+	for (; i &lt; urb-&gt;number_of_packets; i++, td++) {
 		unsigned int offset = urb-&gt;iso_frame_desc[i].offset;
 		td-&gt;ep = ep;
 		td-&gt;urb = urb;
@@ -840,7 +850,6 @@ static int imx21_hc_urb_enqueue_isoc(struct usb_hcd *hcd,
 		list_add_tail(&amp;td-&gt;list, &amp;ep_priv-&gt;td_list);
 	}
 
-	urb_priv-&gt;isoc_remaining = urb-&gt;number_of_packets;
 	dev_vdbg(imx21-&gt;dev, "setup %d packets for iso frame %d-&gt;%d\n",
 		urb-&gt;number_of_packets, urb-&gt;start_frame, td-&gt;frame);
 </pre><hr><pre>commit 8a1ea51f87a6149c3263a63e9c60d852bedbecd7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 13:21:01 2013 -0400

    USB: MUSB: upgrade the isochronous API
    
    This patch attempts to fix the isochonour API in the musb host
    driver.  In particular, the urb-&gt;start_frame field should always be
    set by the driver; it isn't an input parameter.
    
    The simplest way to accomplish this is to treat all URBs as though the
    URB_ISO_ASAP flag was set.  This won't give the right behavior when an
    underrun occurs, but I don't know enough about the musb driver to
    handle that case.
    
    Unfortunately, I have no way to test this change.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 8914dec49f01..85ed11e04f35 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -269,8 +269,7 @@ musb_start_urb(struct musb *musb, int is_in, struct musb_qh *qh)
 		/* FIXME this doesn't implement that scheduling policy ...
 		 * or handle framecounter wrapping
 		 */
-		if ((urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
-				|| (frame &gt;= urb-&gt;start_frame)) {
+		if (1) {	/* Always assume URB_ISO_ASAP */
 			/* REVISIT the SOF irq handler shouldn't duplicate
 			 * this code; and we don't init urb-&gt;start_frame...
 			 */</pre><hr><pre>commit 077f5f1c23b3cf1134c031677497dfb6077e6bdd
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 29 11:33:52 2013 -0400

    USB: EHCI: fix regression related to qh_refresh()
    
    This patch adds some code that inadvertently got left out of commit
    c1fdb68e3d73741630ca16695cf9176c233be7ed (USB: EHCI: changes related
    to qh_refresh()).  The calls to qh_refresh() and qh_link_periodic()
    were taken out of qh_schedule(); therefore it is necessary to call
    these routines manually after calling qh_schedule().
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Oleksij Rempel &lt;linux@rempel-privat.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index f3c1028a54fc..f80d0330d548 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -646,6 +646,10 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* reschedule QH iff another request is queued */
 	if (!list_empty(&amp;qh-&gt;qtd_list) &amp;&amp; ehci-&gt;rh_state == EHCI_RH_RUNNING) {
 		rc = qh_schedule(ehci, qh);
+		if (rc == 0) {
+			qh_refresh(ehci, qh);
+			qh_link_periodic(ehci, qh);
+		}
 
 		/* An error here likely indicates handshake failure
 		 * or no space left in the schedule.  Neither fault
@@ -653,9 +657,10 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		 *
 		 * FIXME kill the now-dysfunctional queued urbs
 		 */
-		if (rc != 0)
+		else {
 			ehci_err(ehci, "can't reschedule qh %p, err %d\n",
 					qh, rc);
+		}
 	}
 
 	/* maybe turn off periodic schedule */</pre><hr><pre>commit fdc03438f53a00294ed9939eb3a1f6db6f3d8963
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 28 14:03:10 2013 -0400

    USB: revert periodic scheduling bugfix
    
    This patch reverts commit 3e619d04159be54b3daa0b7036b0ce9e067f4b5d
    (USB: EHCI: fix bug in scheduling periodic split transfers).  The
    commit was valid -- it fixed a real bug -- but the periodic scheduler
    in ehci-hcd is in such bad shape (especially the part that handles
    split transactions) that fixing one bug is very likely to cause
    another to surface.  That's what happened in this case; the result was
    choppy and noisy playback on certain 24-bit audio devices.
    
    The only real fix will be to rewrite this entire section of code.  My
    next project...
    
    This fixes https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1136110.
    
    Thanks to Tim Richardson for extra testing and feedback, and to Joseph
    Salisbury and Tyson Tan for tracking down the original source of the
    problem.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Joseph Salisbury &lt;joseph.salisbury@canonical.com&gt;
    CC: Tim Richardson &lt;tim@tim-richardson.net&gt;
    Cc: stable &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index acff5b8f6e89..f3c1028a54fc 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -213,7 +213,7 @@ static inline unsigned char tt_start_uframe(struct ehci_hcd *ehci, __hc32 mask)
 }
 
 static const unsigned char
-max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 125, 25 };
+max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 30, 0 };
 
 /* carryover low/fullspeed bandwidth that crosses uframe boundries */
 static inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])</pre><hr><pre>commit 98f541c6e390d48643047e0924da8ccc10bb1598
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed May 1 12:13:54 2013 -0400

    USB: remove remaining instances of USB_SUSPEND
    
    Commit 84ebc10294a3d7be4c66f51070b7aedbaa24de9b (USB: remove
    CONFIG_USB_SUSPEND option) failed to remove all of the usages of
    USB_SUSPEND throughout the kernel.  This patch (as1677) removes the
    remaining instances of that symbol.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/arch/arm/configs/omap1_defconfig b/arch/arm/configs/omap1_defconfig
index 7e0ebb64a7f9..9940f7b4e438 100644
--- a/arch/arm/configs/omap1_defconfig
+++ b/arch/arm/configs/omap1_defconfig
@@ -199,7 +199,6 @@ CONFIG_USB_PHY=y
 CONFIG_USB_DEBUG=y
 CONFIG_USB_DEVICEFS=y
 # CONFIG_USB_DEVICE_CLASS is not set
-CONFIG_USB_SUSPEND=y
 CONFIG_USB_MON=y
 CONFIG_USB_OHCI_HCD=y
 CONFIG_USB_STORAGE=y
diff --git a/arch/arm/configs/omap2plus_defconfig b/arch/arm/configs/omap2plus_defconfig
index c1ef64bc5abd..435d69b83e32 100644
--- a/arch/arm/configs/omap2plus_defconfig
+++ b/arch/arm/configs/omap2plus_defconfig
@@ -204,7 +204,6 @@ CONFIG_USB=y
 CONFIG_USB_DEBUG=y
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 CONFIG_USB_DEVICEFS=y
-CONFIG_USB_SUSPEND=y
 CONFIG_USB_MON=y
 CONFIG_USB_WDM=y
 CONFIG_USB_STORAGE=y
diff --git a/arch/mips/configs/db1000_defconfig b/arch/mips/configs/db1000_defconfig
index face9d26e6d5..bac26b971c5e 100644
--- a/arch/mips/configs/db1000_defconfig
+++ b/arch/mips/configs/db1000_defconfig
@@ -228,7 +228,6 @@ CONFIG_HIDRAW=y
 CONFIG_USB_HID=y
 CONFIG_USB_SUPPORT=y
 CONFIG_USB=y
-CONFIG_USB_SUSPEND=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
 CONFIG_USB_EHCI_TT_NEWSCHED=y
diff --git a/arch/mips/configs/db1235_defconfig b/arch/mips/configs/db1235_defconfig
index 14752dde7540..e2b4ad55462f 100644
--- a/arch/mips/configs/db1235_defconfig
+++ b/arch/mips/configs/db1235_defconfig
@@ -344,7 +344,6 @@ CONFIG_UHID=y
 CONFIG_USB_HIDDEV=y
 CONFIG_USB=y
 CONFIG_USB_DYNAMIC_MINORS=y
-CONFIG_USB_SUSPEND=y
 CONFIG_USB_EHCI_HCD=y
 CONFIG_USB_EHCI_HCD_PLATFORM=y
 CONFIG_USB_EHCI_ROOT_HUB_TT=y
diff --git a/arch/mips/configs/lemote2f_defconfig b/arch/mips/configs/lemote2f_defconfig
index b6acd2f256b6..343bebc4b63b 100644
--- a/arch/mips/configs/lemote2f_defconfig
+++ b/arch/mips/configs/lemote2f_defconfig
@@ -300,7 +300,6 @@ CONFIG_USB=y
 CONFIG_USB_DEVICEFS=y
 # CONFIG_USB_DEVICE_CLASS is not set
 CONFIG_USB_DYNAMIC_MINORS=y
-CONFIG_USB_SUSPEND=y
 CONFIG_USB_OTG_WHITELIST=y
 CONFIG_USB_MON=y
 CONFIG_USB_EHCI_HCD=y
diff --git a/arch/powerpc/configs/ps3_defconfig b/arch/powerpc/configs/ps3_defconfig
index f79196232917..139a8308070c 100644
--- a/arch/powerpc/configs/ps3_defconfig
+++ b/arch/powerpc/configs/ps3_defconfig
@@ -136,7 +136,6 @@ CONFIG_HID_SMARTJOYPLUS=m
 CONFIG_USB_HIDDEV=y
 CONFIG_USB=m
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
-CONFIG_USB_SUSPEND=y
 CONFIG_USB_MON=m
 CONFIG_USB_EHCI_HCD=m
 # CONFIG_USB_EHCI_HCD_PPC_OF is not set
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index f95cb032394b..06ee82f557d4 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -1477,7 +1477,7 @@ usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod)
 
 	/* usbnet already took usb runtime pm, so have to enable the feature
 	 * for usb interface, otherwise usb_autopm_get_interface may return
-	 * failure if USB_SUSPEND(RUNTIME_PM) is enabled.
+	 * failure if RUNTIME_PM is enabled.
 	 */
 	if (!driver-&gt;supports_autosuspend) {
 		driver-&gt;supports_autosuspend = 1;
diff --git a/drivers/staging/gdm72xx/Kconfig b/drivers/staging/gdm72xx/Kconfig
index 3c18efe31365..69059138de4a 100644
--- a/drivers/staging/gdm72xx/Kconfig
+++ b/drivers/staging/gdm72xx/Kconfig
@@ -39,7 +39,7 @@ if WIMAX_GDM72XX_USB
 
 config WIMAX_GDM72XX_USB_PM
 	bool "Enable power managerment support"
-	depends on USB_SUSPEND
+	depends on PM_RUNTIME
 
 endif # WIMAX_GDM72XX_USB
 
diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index 8772b3659296..db535b0aa172 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -51,7 +51,7 @@ config USB_DYNAMIC_MINORS
 
 config USB_OTG
 	bool "OTG support"
-	depends on USB_SUSPEND
+	depends on PM_RUNTIME
 	default n
 	help
 	  The most notable feature of USB OTG is support for a
diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c
index 125e261f5bfc..2facee53eab1 100644
--- a/drivers/usb/host/isp1760-hcd.c
+++ b/drivers/usb/host/isp1760-hcd.c
@@ -1739,7 +1739,7 @@ static int isp1760_hub_status_data(struct usb_hcd *hcd, char *buf)
 	int retval = 1;
 	unsigned long flags;
 
-	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
+	/* if !PM_RUNTIME, root hub timers won't get shut down ... */
 	if (!HC_IS_RUNNING(hcd-&gt;state))
 		return 0;
 
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
index 4f0f0339532f..0f401dbfaf07 100644
--- a/drivers/usb/host/oxu210hp-hcd.c
+++ b/drivers/usb/host/oxu210hp-hcd.c
@@ -3084,7 +3084,7 @@ static int oxu_hub_status_data(struct usb_hcd *hcd, char *buf)
 	int ports, i, retval = 1;
 	unsigned long flags;
 
-	/* if !USB_SUSPEND, root hub timers won't get shut down ... */
+	/* if !PM_RUNTIME, root hub timers won't get shut down ... */
 	if (!HC_IS_RUNNING(hcd-&gt;state))
 		return 0;
 
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
index ad4483efb6d6..b2ec7fe758dd 100644
--- a/drivers/usb/host/sl811-hcd.c
+++ b/drivers/usb/host/sl811-hcd.c
@@ -22,7 +22,7 @@
  * and usb-storage.
  *
  * TODO:
- * - usb suspend/resume triggered by sl811 (with USB_SUSPEND)
+ * - usb suspend/resume triggered by sl811 (with PM_RUNTIME)
  * - various issues noted in the code
  * - performance work; use both register banks; ...
  * - use urb-&gt;iso_frame_desc[] with ISO transfers
diff --git a/drivers/usb/phy/Kconfig b/drivers/usb/phy/Kconfig
index 5053cea0ad89..7ef3eb8617a6 100644
--- a/drivers/usb/phy/Kconfig
+++ b/drivers/usb/phy/Kconfig
@@ -25,7 +25,7 @@ config AB8500_USB
 
 config FSL_USB2_OTG
 	bool "Freescale USB OTG Transceiver Driver"
-	depends on USB_EHCI_FSL &amp;&amp; USB_FSL_USB2 &amp;&amp; USB_SUSPEND
+	depends on USB_EHCI_FSL &amp;&amp; USB_FSL_USB2 &amp;&amp; PM_RUNTIME
 	select USB_OTG
 	help
 	  Enable this to support Freescale USB OTG transceiver.
@@ -161,7 +161,7 @@ config USB_MSM_OTG
 
 config USB_MV_OTG
 	tristate "Marvell USB OTG support"
-	depends on USB_EHCI_MV &amp;&amp; USB_MV_UDC &amp;&amp; USB_SUSPEND
+	depends on USB_EHCI_MV &amp;&amp; USB_MV_UDC &amp;&amp; PM_RUNTIME
 	select USB_OTG
 	help
 	  Say Y here if you want to build Marvell USB OTG transciever</pre><hr><pre>commit 815fa7b917614261748d1ecd9600ff27f99508e5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 14 13:57:51 2013 -0400

    USB: OHCI: fix logic for scheduling isochronous URBs
    
    The isochronous scheduling logic in ohci-hcd has a bug.  The
    calculation for skipping TDs that are too late should be carried out
    only in the !URB_ISO_ASAP case.  When URB_ISO_ASAP is set, the URB is
    pushed back so that none of the TDs are too late, which would cause
    the calculation to overflow.
    
    The patch also fixes the calculation to avoid overflow in the case
    where the frame value wraps around.
    
    This should be applied to -stable kernels going back to 3.8.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index df1af0bcfe99..fc627fd54116 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -240,7 +240,7 @@ static int ohci_urb_enqueue (
 		if (unlikely(tick_before(frame, next))) {
 
 			/* USB_ISO_ASAP: Round up to the first available slot */
-			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP)
+			if (urb-&gt;transfer_flags &amp; URB_ISO_ASAP) {
 				frame += (next - frame + ed-&gt;interval - 1) &amp;
 						-ed-&gt;interval;
 
@@ -248,21 +248,25 @@ static int ohci_urb_enqueue (
 			 * Not ASAP: Use the next slot in the stream.  If
 			 * the entire URB falls before the threshold, fail.
 			 */
-			else if (tick_before(frame + ed-&gt;interval *
+			} else {
+				if (tick_before(frame + ed-&gt;interval *
 					(urb-&gt;number_of_packets - 1), next)) {
-				retval = -EXDEV;
-				usb_hcd_unlink_urb_from_ep(hcd, urb);
-				goto fail;
-			}
+					retval = -EXDEV;
+					usb_hcd_unlink_urb_from_ep(hcd, urb);
+					goto fail;
+				}
 
-			/*
-			 * Some OHCI hardware doesn't handle late TDs
-			 * correctly.  After retiring them it proceeds to
-			 * the next ED instead of the next TD.  Therefore
-			 * we have to omit the late TDs entirely.
-			 */
-			urb_priv-&gt;td_cnt = DIV_ROUND_UP(next - frame,
-					ed-&gt;interval);
+				/*
+				 * Some OHCI hardware doesn't handle late TDs
+				 * correctly.  After retiring them it proceeds
+				 * to the next ED instead of the next TD.
+				 * Therefore we have to omit the late TDs
+				 * entirely.
+				 */
+				urb_priv-&gt;td_cnt = DIV_ROUND_UP(
+						(u16) (next - frame),
+						ed-&gt;interval);
+			}
 		}
 		urb-&gt;start_frame = frame;
 	}</pre><hr><pre>commit e1944017839d7dfbf7329fac4bdec8b4050edf5e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 14 13:57:19 2013 -0400

    USB: fix latency in uhci-hcd and ohci-hcd
    
    Commits c44b225077bb1fb25ed5cd5c4f226897b91bedd4 (UHCI: implement new
    semantics for URB_ISO_ASAP) and
    6a41b4d3fe8cd4cc95181516fc6fba7b1747a27c (OHCI: implement new
    semantics for URB_ISO_ASAP) increased the latency for isochronous URBs
    in uhci-hcd and ohci-hcd respectively to 2 milliseconds, in an
    attempt to avoid underruns.  It turns out that not only was this
    unnecessary -- 1-ms latency works okay -- it also causes problems with
    certain application loads such as real-time audio.
    
    This patch changes the latency for both drivers back to 1 ms.
    
    This should be applied to -stable kernels going back to 3.8.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: Joe Rayhawk &lt;jrayhawk@fairlystable.org&gt;
    CC: Clemens Ladisch &lt;clemens@ladisch.de&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 9e6de9586ae4..df1af0bcfe99 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -233,7 +233,7 @@ static int ohci_urb_enqueue (
 			urb-&gt;start_frame = frame;
 		}
 	} else if (ed-&gt;type == PIPE_ISOCHRONOUS) {
-		u16	next = ohci_frame_no(ohci) + 2;
+		u16	next = ohci_frame_no(ohci) + 1;
 		u16	frame = ed-&gt;last_iso + ed-&gt;interval;
 
 		/* Behind the scheduling threshold? */
diff --git a/drivers/usb/host/uhci-q.c b/drivers/usb/host/uhci-q.c
index f0976d8190bc..041c6ddb695c 100644
--- a/drivers/usb/host/uhci-q.c
+++ b/drivers/usb/host/uhci-q.c
@@ -1287,7 +1287,7 @@ static int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,
 		return -EINVAL;		/* Can't change the period */
 
 	} else {
-		next = uhci-&gt;frame_number + 2;
+		next = uhci-&gt;frame_number + 1;
 
 		/* Find the next unused frame */
 		if (list_empty(&amp;qh-&gt;queue)) {</pre><hr><pre>commit 997ff893603c6455da4c5e26ba1d0f81adfecdfc
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 14 13:55:29 2013 -0400

    USB: UHCI: fix for suspend of virtual HP controller
    
    HP's virtual UHCI host controller takes a long time to suspend
    (several hundred microseconds), even when no devices are attached.
    This provokes a warning message from uhci-hcd in the auto-stop case.
    
    To prevent this from happening, this patch adds a test to avoid
    performing an auto-stop when the wait_for_hp quirk flag is set.  The
    controller will still suspend through the normal runtime PM mechanism.
    And since that pathway includes a 1-ms delay, the slowness of the
    virtual hardware won't matter.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reported-and-tested-by: ZhenHua &lt;zhen-hual@hp.com&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/uhci-hub.c b/drivers/usb/host/uhci-hub.c
index f87bee6d2789..9189bc984c98 100644
--- a/drivers/usb/host/uhci-hub.c
+++ b/drivers/usb/host/uhci-hub.c
@@ -225,7 +225,8 @@ static int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)
 		/* auto-stop if nothing connected for 1 second */
 		if (any_ports_active(uhci))
 			uhci-&gt;rh_state = UHCI_RH_RUNNING;
-		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time))
+		else if (time_after_eq(jiffies, uhci-&gt;auto_stop_time) &amp;&amp;
+				!uhci-&gt;wait_for_hp)
 			suspend_rh(uhci, UHCI_RH_AUTO_STOPPED);
 		break;
 </pre><hr><pre>commit ccd9509a0b942f7a139f1adb741a746ef0220911
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue May 14 13:54:12 2013 -0400

    USB: fix Kconfig logic for USB_UHCI_HCD
    
    The Kconfig settings for uhci-hcd are too permissive; they allow the
    driver to be built without any bus-glue modules configured
    (USB_UHCI_HCD enabled, PCI disabled, SPARC_LEON disabled, ARCH_VT8500
    enabled, and USB_UHCI_PLATFORM disabled).
    
    This patch fixes the problem by rearranging the dependencies.  Now the
    platform-dependent config options don't depend on USB_UHCI_HCD;
    instead it depends on them.  Furthermore, there is no user-selectable
    choice as to which glue modules will be built.  If USB_UHCI_HCD is
    enabled then all applicable bus glues will be built.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Arnd Bergmann &lt;arnd@arndb.de&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index de94f2699063..344d5e2f87d7 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -507,7 +507,7 @@ endif # USB_OHCI_HCD
 
 config USB_UHCI_HCD
 	tristate "UHCI HCD (most Intel and VIA) support"
-	depends on PCI || SPARC_LEON || ARCH_VT8500
+	depends on PCI || USB_UHCI_SUPPORT_NON_PCI_HC
 	---help---
 	  The Universal Host Controller Interface is a standard by Intel for
 	  accessing the USB hardware in the PC (which is also called the USB
@@ -524,26 +524,19 @@ config USB_UHCI_HCD
 
 config USB_UHCI_SUPPORT_NON_PCI_HC
 	bool
-	depends on USB_UHCI_HCD
-	default y if (SPARC_LEON || ARCH_VT8500)
+	default y if (SPARC_LEON || USB_UHCI_PLATFORM)
 
 config USB_UHCI_PLATFORM
-	bool "Generic UHCI Platform Driver support"
-	depends on USB_UHCI_SUPPORT_NON_PCI_HC
+	bool
 	default y if ARCH_VT8500
-	---help---
-	  Enable support for generic UHCI platform devices that require no
-	  additional configuration.
 
 config USB_UHCI_BIG_ENDIAN_MMIO
 	bool
-	depends on USB_UHCI_SUPPORT_NON_PCI_HC &amp;&amp; SPARC_LEON
-	default y
+	default y if SPARC_LEON
 
 config USB_UHCI_BIG_ENDIAN_DESC
 	bool
-	depends on USB_UHCI_SUPPORT_NON_PCI_HC &amp;&amp; SPARC_LEON
-	default y
+	default y if SPARC_LEON
 
 config USB_FHCI_HCD
 	tristate "Freescale QE USB Host Controller support"</pre>
    <div class="pagination">
        <a href='2_35.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><span>[36]</span><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_37.html'>Next&gt;&gt;</a>
    <div>
</body>
