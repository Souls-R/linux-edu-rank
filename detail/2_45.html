<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_44.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><span>[45]</span><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_46.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit f2b5264d4f77328e45d73cd135772b6e88a4951a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:45 2012 -0400

    HID: usbhid: replace HID_REPORTED_IDLE with HID_SUSPENDED
    
    This patch (as1595) improves the usbhid driver by using the
    HID_SUSPENDED bitflag to indicate that the device is suspended rather
    than using HID_REPORTED_IDLE, which the patch removes.
    
    Since HID_SUSPENDED was not being used for anything, and since the
    name "HID_REPORTED_IDLE" doesn't convey much meaning, the end result
    is easier to read and understand.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 0fa07d95202d..271578b85d91 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -84,7 +84,7 @@ static int hid_start_in(struct hid_device *hid)
 	spin_lock_irqsave(&amp;usbhid-&gt;lock, flags);
 	if (hid-&gt;open &gt; 0 &amp;&amp;
 			!test_bit(HID_DISCONNECTED, &amp;usbhid-&gt;iofl) &amp;&amp;
-			!test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl) &amp;&amp;
+			!test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl) &amp;&amp;
 			!test_and_set_bit(HID_IN_RUNNING, &amp;usbhid-&gt;iofl)) {
 		rc = usb_submit_urb(usbhid-&gt;urbin, GFP_ATOMIC);
 		if (rc != 0) {
@@ -222,7 +222,7 @@ static int usbhid_restart_out_queue(struct usbhid_device *usbhid)
 		 * If still suspended, don't submit.  Submission will
 		 * occur if/when resume drains the queue.
 		 */
-		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+		if (test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl)) {
 			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
 			return r;
 		}
@@ -260,7 +260,7 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 		 * If still suspended, don't submit.  Submission will
 		 * occur if/when resume drains the queue.
 		 */
-		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+		if (test_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl)) {
 			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
 			return r;
 		}
@@ -1475,7 +1475,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 		    &amp;&amp; !test_bit(HID_KEYS_PRESSED, &amp;usbhid-&gt;iofl)
 		    &amp;&amp; (!usbhid-&gt;ledcount || ignoreled))
 		{
-			set_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+			set_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 			spin_unlock_irq(&amp;usbhid-&gt;lock);
 			if (hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;suspend) {
 				status = hid-&gt;driver-&gt;suspend(hid, message);
@@ -1495,7 +1495,7 @@ static int hid_suspend(struct usb_interface *intf, pm_message_t message)
 				return status;
 		}
 		spin_lock_irq(&amp;usbhid-&gt;lock);
-		set_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+		set_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 		spin_unlock_irq(&amp;usbhid-&gt;lock);
 		if (usbhid_wait_io(hid) &lt; 0)
 			return -EIO;
@@ -1525,7 +1525,7 @@ static int hid_resume(struct usb_interface *intf)
 	if (!test_bit(HID_STARTED, &amp;usbhid-&gt;iofl))
 		return 0;
 
-	clear_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 	usbhid_mark_busy(usbhid);
 
 	if (test_bit(HID_CLEAR_HALT, &amp;usbhid-&gt;iofl) ||
@@ -1552,7 +1552,7 @@ static int hid_reset_resume(struct usb_interface *intf)
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int status;
 
-	clear_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl);
+	clear_bit(HID_SUSPENDED, &amp;usbhid-&gt;iofl);
 	status = hid_post_reset(intf);
 	if (status &gt;= 0 &amp;&amp; hid-&gt;driver &amp;&amp; hid-&gt;driver-&gt;reset_resume) {
 		int ret = hid-&gt;driver-&gt;reset_resume(hid);
diff --git a/drivers/hid/usbhid/usbhid.h b/drivers/hid/usbhid/usbhid.h
index 1883d7b94870..bd87a61e5303 100644
--- a/drivers/hid/usbhid/usbhid.h
+++ b/drivers/hid/usbhid/usbhid.h
@@ -53,7 +53,6 @@ struct usb_interface *usbhid_find_interface(int minor);
 #define HID_CLEAR_HALT		6
 #define HID_DISCONNECTED	7
 #define HID_STARTED		8
-#define HID_REPORTED_IDLE	9
 #define HID_KEYS_PRESSED	10
 #define HID_NO_BANDWIDTH	11
 </pre><hr><pre>commit 93101af31bc5df4486103f6b3ef212aaa5341b09
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:39 2012 -0400

    HID: usbhid: inline some simple routines
    
    This patch (as1594) simplifies the usbhid driver by inlining a couple
    of routines.  As a result of an earlier patch, irq_out_pump_restart()
    and ctrl_pump_restart() are each used in only one place.  Since they
    don't really do what their names say, and since they each involve only
    about two lines of actual code, there's no reason to keep them as
    separate functions.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 213b3f39753c..0fa07d95202d 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -435,16 +435,6 @@ static int hid_submit_ctrl(struct hid_device *hid)
  * Output interrupt completion handler.
  */
 
-static int irq_out_pump_restart(struct hid_device *hid)
-{
-	struct usbhid_device *usbhid = hid-&gt;driver_data;
-
-	if (usbhid-&gt;outhead != usbhid-&gt;outtail)
-		return hid_submit_out(hid);
-	else
-		return -1;
-}
-
 static void hid_irq_out(struct urb *urb)
 {
 	struct hid_device *hid = urb-&gt;context;
@@ -469,15 +459,17 @@ static void hid_irq_out(struct urb *urb)
 
 	spin_lock_irqsave(&amp;usbhid-&gt;lock, flags);
 
-	if (unplug)
+	if (unplug) {
 		usbhid-&gt;outtail = usbhid-&gt;outhead;
-	else
+	} else {
 		usbhid-&gt;outtail = (usbhid-&gt;outtail + 1) &amp; (HID_OUTPUT_FIFO_SIZE - 1);
 
-	if (!irq_out_pump_restart(hid)) {
-		/* Successfully submitted next urb in queue */
-		spin_unlock_irqrestore(&amp;usbhid-&gt;lock, flags);
-		return;
+		if (usbhid-&gt;outhead != usbhid-&gt;outtail &amp;&amp;
+				hid_submit_out(hid) == 0) {
+			/* Successfully submitted next urb in queue */
+			spin_unlock_irqrestore(&amp;usbhid-&gt;lock, flags);
+			return;
+		}
 	}
 
 	clear_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
@@ -489,15 +481,6 @@ static void hid_irq_out(struct urb *urb)
 /*
  * Control pipe completion handler.
  */
-static int ctrl_pump_restart(struct hid_device *hid)
-{
-	struct usbhid_device *usbhid = hid-&gt;driver_data;
-
-	if (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail)
-		return hid_submit_ctrl(hid);
-	else
-		return -1;
-}
 
 static void hid_ctrl(struct urb *urb)
 {
@@ -526,15 +509,17 @@ static void hid_ctrl(struct urb *urb)
 		hid_warn(urb-&gt;dev, "ctrl urb status %d received\n", status);
 	}
 
-	if (unplug)
+	if (unplug) {
 		usbhid-&gt;ctrltail = usbhid-&gt;ctrlhead;
-	else
+	} else {
 		usbhid-&gt;ctrltail = (usbhid-&gt;ctrltail + 1) &amp; (HID_CONTROL_FIFO_SIZE - 1);
 
-	if (!ctrl_pump_restart(hid)) {
-		/* Successfully submitted next urb in queue */
-		spin_unlock(&amp;usbhid-&gt;lock);
-		return;
+		if (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail &amp;&amp;
+				hid_submit_ctrl(hid) == 0) {
+			/* Successfully submitted next urb in queue */
+			spin_unlock(&amp;usbhid-&gt;lock);
+			return;
+		}
 	}
 
 	clear_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);</pre><hr><pre>commit 01a7c984e86fd45b760bb0da8b635059dff602e1
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:31 2012 -0400

    HID: usbhid: fix autosuspend calls
    
    This patch (as1593) fixes some logic errors in the usbhid driver
    relating to runtime PM.  The driver does not balance its calls to
    usb_autopm_get_interface_async() and usb_autopm_put_interface_async().
    
    For example, when the control queue is restarted the driver does a
    _get.  But the resume won't happen immediately, so the driver leaves
    the queue stopped.  When the resume does occur, the queue is restarted
    and a second _get occurs, with no balancing _put.
    
    The patch fixes the problem by rearranging the logic for restarting
    the queues.  All the _get/_put calls and bitflag settings in
    __usbhid_submit_report() are moved into the queue-restart routines.  A
    balancing _put call is added for the case where the queue is still
    suspended.  A call to irq_out_pump_restart(), which doesn't take all
    the right actions for restarting the irq-OUT queue, is replaced by a
    call to usbhid_restart_out_queue(), which does.  Similarly for
    ctrl_pump_restart().
    
    Finally, new code is added to prevent an autosuspend from happening
    every time an URB is cancelled, and the comments explaining what
    happens when an URB needs to be cancelled are expanded and clarified.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 6b9bad540702..213b3f39753c 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -213,9 +213,20 @@ static int usbhid_restart_out_queue(struct usbhid_device *usbhid)
 	if ((kicked = (usbhid-&gt;outhead != usbhid-&gt;outtail))) {
 		hid_dbg(hid, "Kicking head %d tail %d", usbhid-&gt;outhead, usbhid-&gt;outtail);
 
+		/* Try to wake up from autosuspend... */
 		r = usb_autopm_get_interface_async(usbhid-&gt;intf);
 		if (r &lt; 0)
 			return r;
+
+		/*
+		 * If still suspended, don't submit.  Submission will
+		 * occur if/when resume drains the queue.
+		 */
+		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
+			return r;
+		}
+
 		/* Asynchronously flush queue. */
 		set_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
 		if (hid_submit_out(hid)) {
@@ -240,9 +251,20 @@ static int usbhid_restart_ctrl_queue(struct usbhid_device *usbhid)
 	if ((kicked = (usbhid-&gt;ctrlhead != usbhid-&gt;ctrltail))) {
 		hid_dbg(hid, "Kicking head %d tail %d", usbhid-&gt;ctrlhead, usbhid-&gt;ctrltail);
 
+		/* Try to wake up from autosuspend... */
 		r = usb_autopm_get_interface_async(usbhid-&gt;intf);
 		if (r &lt; 0)
 			return r;
+
+		/*
+		 * If still suspended, don't submit.  Submission will
+		 * occur if/when resume drains the queue.
+		 */
+		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl)) {
+			usb_autopm_put_interface_no_suspend(usbhid-&gt;intf);
+			return r;
+		}
+
 		/* Asynchronously flush queue. */
 		set_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);
 		if (hid_submit_ctrl(hid)) {
@@ -546,49 +568,36 @@ static void __usbhid_submit_report(struct hid_device *hid, struct hid_report *re
 		usbhid-&gt;out[usbhid-&gt;outhead].report = report;
 		usbhid-&gt;outhead = head;
 
-		/* Try to awake from autosuspend... */
-		if (usb_autopm_get_interface_async(usbhid-&gt;intf) &lt; 0)
-			return;
+		/* If the queue isn't running, restart it */
+		if (!test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl)) {
+			usbhid_restart_out_queue(usbhid);
 
-		/*
-		 * But if still suspended, leave urb enqueued, don't submit.
-		 * Submission will occur if/when resume() drains the queue.
-		 */
-		if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl))
-			return;
+		/* Otherwise see if an earlier request has timed out */
+		} else if (time_after(jiffies, usbhid-&gt;last_out + HZ * 5)) {
+
+			/* Prevent autosuspend following the unlink */
+			usb_autopm_get_interface_no_resume(usbhid-&gt;intf);
 
-		if (!test_and_set_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl)) {
-			if (hid_submit_out(hid)) {
-				clear_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
-				usb_autopm_put_interface_async(usbhid-&gt;intf);
-			}
-			wake_up(&amp;usbhid-&gt;wait);
-		} else {
 			/*
-			 * the queue is known to run
-			 * but an earlier request may be stuck
-			 * we may need to time out
-			 * no race because the URB is blocked under
-			 * spinlock
+			 * Prevent resubmission in case the URB completes
+			 * before we can unlink it.  We don't want to cancel
+			 * the wrong transfer!
 			 */
-			if (time_after(jiffies, usbhid-&gt;last_out + HZ * 5)) {
-				usb_block_urb(usbhid-&gt;urbout);
-				/* drop lock to not deadlock if the callback is called */
-				spin_unlock(&amp;usbhid-&gt;lock);
-				usb_unlink_urb(usbhid-&gt;urbout);
-				spin_lock(&amp;usbhid-&gt;lock);
-				usb_unblock_urb(usbhid-&gt;urbout);
-				/*
-				 * if the unlinking has already completed
-				 * the pump will have been stopped
-				 * it must be restarted now
-				 */
-				if (!test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
-					if (!irq_out_pump_restart(hid))
-						set_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl);
+			usb_block_urb(usbhid-&gt;urbout);
 
+			/* Drop lock to avoid deadlock if the callback runs */
+			spin_unlock(&amp;usbhid-&gt;lock);
 
-			}
+			usb_unlink_urb(usbhid-&gt;urbout);
+			spin_lock(&amp;usbhid-&gt;lock);
+			usb_unblock_urb(usbhid-&gt;urbout);
+
+			/* Unlink might have stopped the queue */
+			if (!test_bit(HID_OUT_RUNNING, &amp;usbhid-&gt;iofl))
+				usbhid_restart_out_queue(usbhid);
+
+			/* Now we can allow autosuspend again */
+			usb_autopm_put_interface_async(usbhid-&gt;intf);
 		}
 		return;
 	}
@@ -610,47 +619,36 @@ static void __usbhid_submit_report(struct hid_device *hid, struct hid_report *re
 	usbhid-&gt;ctrl[usbhid-&gt;ctrlhead].dir = dir;
 	usbhid-&gt;ctrlhead = head;
 
-	/* Try to awake from autosuspend... */
-	if (usb_autopm_get_interface_async(usbhid-&gt;intf) &lt; 0)
-		return;
+	/* If the queue isn't running, restart it */
+	if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl)) {
+		usbhid_restart_ctrl_queue(usbhid);
 
-	/*
-	 * If already suspended, leave urb enqueued, but don't submit.
-	 * Submission will occur if/when resume() drains the queue.
-	 */
-	if (test_bit(HID_REPORTED_IDLE, &amp;usbhid-&gt;iofl))
-		return;
+	/* Otherwise see if an earlier request has timed out */
+	} else if (time_after(jiffies, usbhid-&gt;last_ctrl + HZ * 5)) {
+
+		/* Prevent autosuspend following the unlink */
+		usb_autopm_get_interface_no_resume(usbhid-&gt;intf);
 
-	if (!test_and_set_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl)) {
-		if (hid_submit_ctrl(hid)) {
-			clear_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);
-			usb_autopm_put_interface_async(usbhid-&gt;intf);
-		}
-		wake_up(&amp;usbhid-&gt;wait);
-	} else {
 		/*
-		 * the queue is known to run
-		 * but an earlier request may be stuck
-		 * we may need to time out
-		 * no race because the URB is blocked under
-		 * spinlock
+		 * Prevent resubmission in case the URB completes
+		 * before we can unlink it.  We don't want to cancel
+		 * the wrong transfer!
 		 */
-		if (time_after(jiffies, usbhid-&gt;last_ctrl + HZ * 5)) {
-			usb_block_urb(usbhid-&gt;urbctrl);
-			/* drop lock to not deadlock if the callback is called */
-			spin_unlock(&amp;usbhid-&gt;lock);
-			usb_unlink_urb(usbhid-&gt;urbctrl);
-			spin_lock(&amp;usbhid-&gt;lock);
-			usb_unblock_urb(usbhid-&gt;urbctrl);
-			/*
-			 * if the unlinking has already completed
-			 * the pump will have been stopped
-			 * it must be restarted now
-			 */
-			if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
-				if (!ctrl_pump_restart(hid))
-					set_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl);
-		}
+		usb_block_urb(usbhid-&gt;urbctrl);
+
+		/* Drop lock to avoid deadlock if the callback runs */
+		spin_unlock(&amp;usbhid-&gt;lock);
+
+		usb_unlink_urb(usbhid-&gt;urbctrl);
+		spin_lock(&amp;usbhid-&gt;lock);
+		usb_unblock_urb(usbhid-&gt;urbctrl);
+
+		/* Unlink might have stopped the queue */
+		if (!test_bit(HID_CTRL_RUNNING, &amp;usbhid-&gt;iofl))
+			usbhid_restart_ctrl_queue(usbhid);
+
+		/* Now we can allow autosuspend again */
+		usb_autopm_put_interface_async(usbhid-&gt;intf);
 	}
 }
 </pre><hr><pre>commit 668160e5a80536251b4931a332dfe34d6ec2aeb7
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 19 16:08:21 2012 -0400

    HID: usbhid: fix use-after-free bug
    
    This patch (as1592) fixes an obscure problem in the usbhid driver.
    Under some circumstances, a control or interrupt-OUT URB can be
    submitted twice.  This will happen if the first submission fails; the
    queue pointers aren't updated, so the next time the queue is restarted
    the same URB will be submitted again.
    
    The problem is that raw_report gets deallocated during the first
    submission.  The second submission will then dereference and try to
    free an already-freed region of memory.  The patch fixes the problem
    by setting raw_report to NULL when it is deallocated and checking for
    NULL before dereferencing it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: Oliver Neukum &lt;oliver@neukum.org&gt;
    Signed-off-by: Jiri Kosina &lt;jkosina@suse.cz&gt;

diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 482f936fc29b..6b9bad540702 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -331,9 +331,12 @@ static int hid_submit_out(struct hid_device *hid)
 	usbhid-&gt;urbout-&gt;transfer_buffer_length = ((report-&gt;size - 1) &gt;&gt; 3) +
 						 1 + (report-&gt;id &gt; 0);
 	usbhid-&gt;urbout-&gt;dev = hid_to_usb_dev(hid);
-	memcpy(usbhid-&gt;outbuf, raw_report,
-	       usbhid-&gt;urbout-&gt;transfer_buffer_length);
-	kfree(raw_report);
+	if (raw_report) {
+		memcpy(usbhid-&gt;outbuf, raw_report,
+				usbhid-&gt;urbout-&gt;transfer_buffer_length);
+		kfree(raw_report);
+		usbhid-&gt;out[usbhid-&gt;outtail].raw_report = NULL;
+	}
 
 	dbg_hid("submitting out urb\n");
 
@@ -362,8 +365,11 @@ static int hid_submit_ctrl(struct hid_device *hid)
 	if (dir == USB_DIR_OUT) {
 		usbhid-&gt;urbctrl-&gt;pipe = usb_sndctrlpipe(hid_to_usb_dev(hid), 0);
 		usbhid-&gt;urbctrl-&gt;transfer_buffer_length = len;
-		memcpy(usbhid-&gt;ctrlbuf, raw_report, len);
-		kfree(raw_report);
+		if (raw_report) {
+			memcpy(usbhid-&gt;ctrlbuf, raw_report, len);
+			kfree(raw_report);
+			usbhid-&gt;ctrl[usbhid-&gt;ctrltail].raw_report = NULL;
+		}
 	} else {
 		int maxpacket, padlen;
 </pre><hr><pre>commit 43fe3a99d9caf10b25f9c596e9854cdae30db418
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:16 2012 -0400

    USB: EHCI: resolve some unlikely races
    
    This patch (as1589) resolves some unlikely races involving system
    shutdown or controller death in ehci-hcd:
    
            Shutdown races with both root-hub resume and controller
            resume.
    
            Controller death races with root-hub suspend.
    
    A new bitflag is added to indicate that the controller has been shut
    down (whether for system shutdown or because it died).  Tests are
    added in the suspend and resume pathways to avoid reactivating the
    controller after any sort of shutdown.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index ac4c8ddde20a..e44ca5453aa2 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -343,6 +343,7 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	ehci-&gt;shutdown = true;
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
 	ehci-&gt;enabled_hrtimer_events = 0;
 	spin_unlock_irq(&amp;ehci-&gt;lock);
@@ -823,6 +824,7 @@ static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 		usb_hc_died(hcd);
 
 		/* Don't let the controller do anything more */
+		ehci-&gt;shutdown = true;
 		ehci-&gt;rh_state = EHCI_RH_STOPPING;
 		ehci-&gt;command &amp;= ~(CMD_RUN | CMD_ASE | CMD_PSE);
 		ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
@@ -1129,6 +1131,9 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	/* Mark hardware accessible again as we are back to full power by now */
 	set_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
 
+	if (ehci-&gt;shutdown)
+		return 0;		/* Controller is dead */
+
 	/*
 	 * If CF is still set and we aren't resuming from hibernation
 	 * then we maintained suspend power.
@@ -1139,10 +1144,17 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 		int	mask = INTR_MASK;
 
 		ehci_prepare_ports_for_controller_resume(ehci);
+
+		spin_lock_irq(&amp;ehci-&gt;lock);
+		if (ehci-&gt;shutdown)
+			goto skip;
+
 		if (!hcd-&gt;self.root_hub-&gt;do_remote_wakeup)
 			mask &amp;= ~STS_PCD;
 		ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 		ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
+ skip:
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 		return 0;
 	}
 
@@ -1154,14 +1166,20 @@ static int __maybe_unused ehci_resume(struct usb_hcd *hcd, bool hibernated)
 	(void) ehci_halt(ehci);
 	(void) ehci_reset(ehci);
 
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;shutdown)
+		goto skip;
+
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
 	ehci_writel(ehci, FLAG_CF, &amp;ehci-&gt;regs-&gt;configured_flag);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);	/* unblock posted writes */
 
+	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
 	/* here we "know" root ports should always stay powered */
 	ehci_port_power(ehci, 1);
 
-	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 	return 1;
 }
 
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index ffc5f27df725..c7880223738a 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -221,6 +221,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_quiesce(ehci);
 
 	spin_lock_irq (&amp;ehci-&gt;lock);
+	if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING)
+		goto done;
 
 	/* Once the controller is stopped, port resumes that are already
 	 * in progress won't complete.  Hence if remote wakeup is enabled
@@ -306,6 +308,10 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_halt (ehci);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;enabled_hrtimer_events &amp; BIT(EHCI_HRTIMER_POLL_DEAD))
+		ehci_handle_controller_death(ehci);
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING)
+		goto done;
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
@@ -320,6 +326,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci_writel(ehci, mask, &amp;ehci-&gt;regs-&gt;intr_enable);
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
+ done:
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(10);
 	ehci-&gt;enabled_hrtimer_events = 0;
 	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
@@ -342,10 +349,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 	spin_lock_irq (&amp;ehci-&gt;lock);
-	if (!HCD_HW_ACCESSIBLE(hcd)) {
-		spin_unlock_irq(&amp;ehci-&gt;lock);
-		return -ESHUTDOWN;
-	}
+	if (!HCD_HW_ACCESSIBLE(hcd) || ehci-&gt;shutdown)
+		goto shutdown;
 
 	if (unlikely(ehci-&gt;debug)) {
 		if (!dbgp_reset_prep())
@@ -384,6 +389,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 	msleep(8);
 	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;shutdown)
+		goto shutdown;
 
 	/* clear phy low-power mode before resume */
 	if (ehci-&gt;bus_suspended &amp;&amp; ehci-&gt;has_hostpc) {
@@ -401,6 +408,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		spin_unlock_irq(&amp;ehci-&gt;lock);
 		msleep(5);
 		spin_lock_irq(&amp;ehci-&gt;lock);
+		if (ehci-&gt;shutdown)
+			goto shutdown;
 	}
 
 	/* manually resume the ports we suspended during bus_suspend() */
@@ -421,6 +430,8 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 		spin_unlock_irq(&amp;ehci-&gt;lock);
 		msleep(20);
 		spin_lock_irq(&amp;ehci-&gt;lock);
+		if (ehci-&gt;shutdown)
+			goto shutdown;
 	}
 
 	i = HCS_N_PORTS (ehci-&gt;hcs_params);
@@ -439,10 +450,18 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	ehci_handover_companion_ports(ehci);
 
 	/* Now we can safely re-enable irqs */
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	if (ehci-&gt;shutdown)
+		goto shutdown;
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void) ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	return 0;
+
+ shutdown:
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+	return -ESHUTDOWN;
 }
 
 #else
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 7de58fe52d51..da07d98f7d1d 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -118,6 +118,7 @@ struct ehci_hcd {			/* one per controller */
 	bool			need_rescan:1;
 	bool			intr_unlinking:1;
 	bool			async_unlinking:1;
+	bool			shutdown:1;
 	struct ehci_qh		*qh_scan_next;
 
 	/* async schedule support */</pre><hr><pre>commit c4f3476436f7452b97c8accb5dd7d53219a11a3f
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:10 2012 -0400

    USB: EHCI: fix up locking
    
    This patch (as1588) adjusts the locking in ehci-hcd's various halt,
    shutdown, and suspend/resume pathways.  We want to hold the spinlock
    while writing device registers and accessing shared variables, but not
    while polling in a loop.
    
    In addition, there's no need to call ehci_work() at times when no URBs
    can be active, i.e., in ehci_stop() and ehci_bus_suspend().
    
    Finally, ehci_adjust_port_wakeup_flags() is called only in situations
    where interrupts are enabled; therefore it can use spin_lock_irq
    rather than spin_lock_irqsave.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 340c9c4894bf..ac4c8ddde20a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -167,21 +167,24 @@ static int tdi_in_host_mode (struct ehci_hcd *ehci)
 	return (tmp &amp; 3) == USBMODE_CM_HC;
 }
 
-/* force HC to halt state from unknown (EHCI spec section 2.3) */
+/*
+ * Force HC to halt state from unknown (EHCI spec section 2.3).
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static int ehci_halt (struct ehci_hcd *ehci)
 {
-	u32	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;status);
+	u32	temp;
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
 
 	/* disable any irqs left enabled by previous code */
 	ehci_writel(ehci, 0, &amp;ehci-&gt;regs-&gt;intr_enable);
 
-	if (ehci_is_TDI(ehci) &amp;&amp; tdi_in_host_mode(ehci) == 0) {
+	if (ehci_is_TDI(ehci) &amp;&amp; !tdi_in_host_mode(ehci)) {
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 		return 0;
 	}
 
-	if ((temp &amp; STS_HALT) != 0)
-		return 0;
-
 	/*
 	 * This routine gets called during probe before ehci-&gt;command
 	 * has been initialized, so we can't rely on its value.
@@ -190,7 +193,11 @@ static int ehci_halt (struct ehci_hcd *ehci)
 	temp = ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;command);
 	temp &amp;= ~(CMD_RUN | CMD_IAAD);
 	ehci_writel(ehci, temp, &amp;ehci-&gt;regs-&gt;command);
-	return handshake (ehci, &amp;ehci-&gt;regs-&gt;status,
+
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+	synchronize_irq(ehci_to_hcd(ehci)-&gt;irq);
+
+	return handshake(ehci, &amp;ehci-&gt;regs-&gt;status,
 			  STS_HALT, STS_HALT, 16 * 125);
 }
 
@@ -210,7 +217,10 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	ehci_writel(ehci, tmp, &amp;ehci-&gt;regs-&gt;usbmode);
 }
 
-/* reset a non-running (STS_HALT == 1) controller */
+/*
+ * Reset a non-running (STS_HALT == 1) controller.
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static int ehci_reset (struct ehci_hcd *ehci)
 {
 	int	retval;
@@ -248,7 +258,10 @@ static int ehci_reset (struct ehci_hcd *ehci)
 	return retval;
 }
 
-/* idle the controller (from running) */
+/*
+ * Idle the controller (turn off the schedules).
+ * Must be called with interrupts enabled and the lock not held.
+ */
 static void ehci_quiesce (struct ehci_hcd *ehci)
 {
 	u32	temp;
@@ -261,8 +274,10 @@ static void ehci_quiesce (struct ehci_hcd *ehci)
 	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, temp, 16 * 125);
 
 	/* then disable anything that's still active */
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;command &amp;= ~(CMD_ASE | CMD_PSE);
 	ehci_writel(ehci, ehci-&gt;command, &amp;ehci-&gt;regs-&gt;command);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	/* hardware can take 16 microframes to turn off ... */
 	handshake(ehci, &amp;ehci-&gt;regs-&gt;status, STS_ASS | STS_PSS, 0, 16 * 125);
@@ -301,11 +316,14 @@ static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)
 
 /*
  * Halt HC, turn off all ports, and let the BIOS use the companion controllers.
- * Should be called with ehci-&gt;lock held.
+ * Must be called with interrupts enabled and the lock not held.
  */
 static void ehci_silence_controller(struct ehci_hcd *ehci)
 {
 	ehci_halt(ehci);
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
+	ehci-&gt;rh_state = EHCI_RH_HALTED;
 	ehci_turn_off_all_ports(ehci);
 
 	/* make BIOS/etc use companion controller during reboot */
@@ -313,6 +331,7 @@ static void ehci_silence_controller(struct ehci_hcd *ehci)
 
 	/* unblock posted writes */
 	ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;configured_flag);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 }
 
 /* ehci_shutdown kick in for silicon on any bus (not just pci, etc).
@@ -325,10 +344,11 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
-	ehci_silence_controller(ehci);
 	ehci-&gt;enabled_hrtimer_events = 0;
 	spin_unlock_irq(&amp;ehci-&gt;lock);
 
+	ehci_silence_controller(ehci);
+
 	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 }
 
@@ -400,11 +420,11 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;enabled_hrtimer_events = 0;
-	ehci_quiesce(ehci);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
+	ehci_quiesce(ehci);
 	ehci_silence_controller(ehci);
 	ehci_reset (ehci);
-	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 	remove_sysfs_files(ehci);
@@ -412,8 +432,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 
 	/* root hub is shut down separately (first, when possible) */
 	spin_lock_irq (&amp;ehci-&gt;lock);
-	if (ehci-&gt;async)
-		ehci_work (ehci);
 	end_free_itds(ehci);
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 	ehci_mem_cleanup (ehci);
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 05490d387fd2..ffc5f27df725 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -59,6 +59,7 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	/* Give the connections some time to appear */
 	msleep(20);
 
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
@@ -70,23 +71,30 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 				clear_bit(port, &amp;ehci-&gt;owned_ports);
 			else if (test_bit(port, &amp;ehci-&gt;companion_ports))
 				ehci_writel(ehci, status &amp; ~PORT_PE, reg);
-			else
+			else {
+				spin_unlock_irq(&amp;ehci-&gt;lock);
 				ehci_hub_control(hcd, SetPortFeature,
 						USB_PORT_FEAT_RESET, port + 1,
 						NULL, 0);
+				spin_lock_irq(&amp;ehci-&gt;lock);
+			}
 		}
 	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	if (!ehci-&gt;owned_ports)
 		return;
 	msleep(90);		/* Wait for resets to complete */
 
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 	while (port--) {
 		if (test_bit(port, &amp;ehci-&gt;owned_ports)) {
+			spin_unlock_irq(&amp;ehci-&gt;lock);
 			ehci_hub_control(hcd, GetPortStatus,
 					0, port + 1,
 					(char *) &amp;buf, sizeof(buf));
+			spin_lock_irq(&amp;ehci-&gt;lock);
 
 			/* The companion should now own the port,
 			 * but if something went wrong the port must not
@@ -105,6 +113,7 @@ static void ehci_handover_companion_ports(struct ehci_hcd *ehci)
 	}
 
 	ehci-&gt;owned_ports = 0;
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 }
 
 static int ehci_port_change(struct ehci_hcd *ehci)
@@ -133,7 +142,6 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 {
 	int		port;
 	u32		temp;
-	unsigned long	flags;
 
 	/* If remote wakeup is enabled for the root hub but disabled
 	 * for the controller, we must adjust all the port wakeup flags
@@ -143,7 +151,7 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 	if (!ehci_to_hcd(ehci)-&gt;self.root_hub-&gt;do_remote_wakeup || do_wakeup)
 		return;
 
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+	spin_lock_irq(&amp;ehci-&gt;lock);
 
 	/* clear phy low-power mode before changing wakeup flags */
 	if (ehci-&gt;has_hostpc) {
@@ -154,9 +162,9 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 			temp = ehci_readl(ehci, hostpc_reg);
 			ehci_writel(ehci, temp &amp; ~HOSTPC_PHCD, hostpc_reg);
 		}
-		spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+		spin_unlock_irq(&amp;ehci-&gt;lock);
 		msleep(5);
-		spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+		spin_lock_irq(&amp;ehci-&gt;lock);
 	}
 
 	port = HCS_N_PORTS(ehci-&gt;hcs_params);
@@ -194,7 +202,7 @@ static void ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,
 	if (!suspending &amp;&amp; ehci_port_change(ehci))
 		usb_hcd_resume_root_hub(ehci_to_hcd(ehci));
 
-	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 }
 
 static int ehci_bus_suspend (struct usb_hcd *hcd)
@@ -209,6 +217,9 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
 
+	/* stop the schedules */
+	ehci_quiesce(ehci);
+
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
 	/* Once the controller is stopped, port resumes that are already
@@ -224,10 +235,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 		}
 	}
 
-	/* stop schedules, clean any completed work */
-	ehci_quiesce(ehci);
-	ehci_work(ehci);
-
 	/* Unlike other USB host controller types, EHCI doesn't have
 	 * any notion of "global" or bus-wide suspend.  The driver has
 	 * to manually suspend all the active unsuspended ports, and
@@ -289,6 +296,7 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 					"succeeded" : "failed");
 		}
 	}
+	spin_unlock_irq(&amp;ehci-&gt;lock);
 
 	/* Apparently some devices need a &gt;= 1-uframe delay here */
 	if (ehci-&gt;bus_suspended)
@@ -296,6 +304,8 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	/* turn off now-idle HC */
 	ehci_halt (ehci);
+
+	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_SUSPENDED;
 
 	end_unlink_async(ehci);
@@ -424,13 +434,14 @@ static int ehci_bus_resume (struct usb_hcd *hcd)
 	}
 
 	ehci-&gt;next_statechange = jiffies + msecs_to_jiffies(5);
+	spin_unlock_irq(&amp;ehci-&gt;lock);
+
+	ehci_handover_companion_ports(ehci);
 
 	/* Now we can safely re-enable irqs */
 	ehci_writel(ehci, INTR_MASK, &amp;ehci-&gt;regs-&gt;intr_enable);
 	(void) ehci_readl(ehci, &amp;ehci-&gt;regs-&gt;intr_enable);
 
-	spin_unlock_irq (&amp;ehci-&gt;lock);
-	ehci_handover_companion_ports(ehci);
 	return 0;
 }
 
@@ -1018,7 +1029,9 @@ static int ehci_hub_control (
 		case USB_PORT_FEAT_TEST:
 			if (!selector || selector &gt; 5)
 				goto error;
+			spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 			ehci_quiesce(ehci);
+			spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 
 			/* Put all enabled ports into suspend */
 			while (ports--) {
@@ -1030,7 +1043,11 @@ static int ehci_hub_control (
 					ehci_writel(ehci, temp | PORT_SUSPEND,
 							sreg);
 			}
+
+			spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 			ehci_halt(ehci);
+			spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+
 			temp = ehci_readl(ehci, status_reg);
 			temp |= selector &lt;&lt; 16;
 			ehci_writel(ehci, temp, status_reg);
diff --git a/drivers/usb/host/ehci-tegra.c b/drivers/usb/host/ehci-tegra.c
index f7f3ce3275b8..65360945df78 100644
--- a/drivers/usb/host/ehci-tegra.c
+++ b/drivers/usb/host/ehci-tegra.c
@@ -445,12 +445,11 @@ static int controller_suspend(struct device *dev)
 	if (time_before(jiffies, ehci-&gt;next_statechange))
 		msleep(10);
 
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
+	ehci_halt(ehci);
 
+	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
 	tegra-&gt;port_speed = (readl(&amp;hw-&gt;port_status[0]) &gt;&gt; 26) &amp; 0x3;
-	ehci_halt(ehci);
 	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &amp;hcd-&gt;flags);
-
 	spin_unlock_irqrestore(&amp;ehci-&gt;lock, flags);
 
 	tegra_ehci_power_down(hcd);</pre><hr><pre>commit f42890782241a60d107f23d08089a4a12b507a11
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:07 2012 -0400

    USB: EHCI: simplify isochronous scanning
    
    This patch (as1587) simplifies ehci-hcd's scan_isoc() routine by
    eliminating some local variables, declaring boolean-valued values as
    bool rather than unsigned, changing variable names to make more sense,
    and so on.
    
    The logic at the end of the routine is cut down significantly.  The
    scanning doesn't have to catch up all the way to where the hardware
    is; it merely has to catch up to where the hardware was when the last
    interrupt occurred.  If the hardware has made more progress since then
    and issued another interrupt, a rescan will catch up to it.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 9f26080889f5..340c9c4894bf 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -488,9 +488,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	else					// N microframes cached
 		ehci-&gt;i_thresh = 2 + HCC_ISOC_THRES(hcc_params);
 
-	ehci-&gt;next_uframe = -1;
-	ehci-&gt;clock_frame = -1;
-
 	/*
 	 * dedicate a qh for the async ring head, since we couldn't unlink
 	 * a 'real' qh without stopping the async schedule [4.8].  use it
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 26ce8fef0e5b..7cf3da7babf0 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -497,8 +497,6 @@ static void disable_periodic(struct ehci_hcd *ehci)
 	if (--ehci-&gt;periodic_count)
 		return;
 
-	ehci-&gt;next_uframe = -1;		/* the periodic schedule is empty */
-
 	/* Don't turn off the schedule until PSS is 1 */
 	ehci_poll_PSS(ehci);
 }
@@ -1220,7 +1218,7 @@ itd_urb_transaction (
 		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
 			itd = list_first_entry(&amp;stream-&gt;free_list,
 					struct ehci_itd, itd_list);
-			if (itd-&gt;frame == ehci-&gt;clock_frame)
+			if (itd-&gt;frame == ehci-&gt;now_frame)
 				goto alloc_itd;
 			list_del (&amp;itd-&gt;itd_list);
 			itd_dma = itd-&gt;itd_dma;
@@ -1492,7 +1490,7 @@ iso_stream_schedule (
 
 	/* Make sure scan_isoc() sees these */
 	if (ehci-&gt;isoc_count == 0)
-		ehci-&gt;next_uframe = now;
+		ehci-&gt;next_frame = now &gt;&gt; 3;
 	return 0;
 
  fail:
@@ -1666,11 +1664,8 @@ static void itd_link_urb(
  * (b) only this endpoint's completions submit URBs.  It seems some silicon
  * corrupts things if you reuse completed descriptors very quickly...
  */
-static unsigned
-itd_complete (
-	struct ehci_hcd	*ehci,
-	struct ehci_itd	*itd
-) {
+static bool itd_complete(struct ehci_hcd *ehci, struct ehci_itd *itd)
+{
 	struct urb				*urb = itd-&gt;urb;
 	struct usb_iso_packet_descriptor	*desc;
 	u32					t;
@@ -1678,7 +1673,7 @@ itd_complete (
 	int					urb_index = -1;
 	struct ehci_iso_stream			*stream = itd-&gt;stream;
 	struct usb_device			*dev;
-	unsigned				retval = false;
+	bool					retval = false;
 
 	/* for each uframe with a packet */
 	for (uframe = 0; uframe &lt; 8; uframe++) {
@@ -1917,7 +1912,7 @@ sitd_urb_transaction (
 		if (likely(!list_empty(&amp;stream-&gt;free_list))) {
 			sitd = list_first_entry(&amp;stream-&gt;free_list,
 					 struct ehci_sitd, sitd_list);
-			if (sitd-&gt;frame == ehci-&gt;clock_frame)
+			if (sitd-&gt;frame == ehci-&gt;now_frame)
 				goto alloc_sitd;
 			list_del (&amp;sitd-&gt;sitd_list);
 			sitd_dma = sitd-&gt;sitd_dma;
@@ -2071,18 +2066,15 @@ static void sitd_link_urb(
  * (b) only this endpoint's completions submit URBs.  It seems some silicon
  * corrupts things if you reuse completed descriptors very quickly...
  */
-static unsigned
-sitd_complete (
-	struct ehci_hcd		*ehci,
-	struct ehci_sitd	*sitd
-) {
+static bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)
+{
 	struct urb				*urb = sitd-&gt;urb;
 	struct usb_iso_packet_descriptor	*desc;
 	u32					t;
 	int					urb_index = -1;
 	struct ehci_iso_stream			*stream = sitd-&gt;stream;
 	struct usb_device			*dev;
-	unsigned				retval = false;
+	bool					retval = false;
 
 	urb_index = sitd-&gt;index;
 	desc = &amp;urb-&gt;iso_frame_desc [urb_index];
@@ -2214,34 +2206,29 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 static void scan_isoc(struct ehci_hcd *ehci)
 {
-	unsigned	now_uframe, frame, clock, clock_frame, mod;
-	unsigned	modified;
-
-	mod = ehci-&gt;periodic_size &lt;&lt; 3;
+	unsigned	uf, now_frame, frame;
+	unsigned	fmask = ehci-&gt;periodic_size - 1;
+	bool		modified, live;
 
 	/*
 	 * When running, scan from last scan point up to "now"
 	 * else clean up by scanning everything that's left.
 	 * Touches as few pages as possible:  cache-friendly.
 	 */
-	now_uframe = ehci-&gt;next_uframe;
 	if (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING) {
-		clock = ehci_read_frame_index(ehci);
-		clock_frame = (clock &gt;&gt; 3) &amp; (ehci-&gt;periodic_size - 1);
+		uf = ehci_read_frame_index(ehci);
+		now_frame = (uf &gt;&gt; 3) &amp; fmask;
+		live = true;
 	} else  {
-		clock = now_uframe + mod - 1;
-		clock_frame = -1;
+		now_frame = (ehci-&gt;next_frame - 1) &amp; fmask;
+		live = false;
 	}
-	ehci-&gt;clock_frame = clock_frame;
-	clock &amp;= mod - 1;
-	clock_frame = clock &gt;&gt; 3;
+	ehci-&gt;now_frame = now_frame;
 
+	frame = ehci-&gt;next_frame;
 	for (;;) {
 		union ehci_shadow	q, *q_p;
 		__hc32			type, *hw_p;
-		unsigned		incomplete = false;
-
-		frame = now_uframe &gt;&gt; 3;
 
 restart:
 		/* scan each element in frame's queue for completions */
@@ -2249,13 +2236,9 @@ static void scan_isoc(struct ehci_hcd *ehci)
 		hw_p = &amp;ehci-&gt;periodic [frame];
 		q.ptr = q_p-&gt;ptr;
 		type = Q_NEXT_TYPE(ehci, *hw_p);
-		modified = 0;
+		modified = false;
 
 		while (q.ptr != NULL) {
-			unsigned		uf;
-			int			live;
-
-			live = (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING);
 			switch (hc32_to_cpu(ehci, type)) {
 			case Q_TYPE_ITD:
 				/* If this ITD is still active, leave it for
@@ -2263,7 +2246,7 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				 * No need to check for activity unless the
 				 * frame is current.
 				 */
-				if (frame == clock_frame &amp;&amp; live) {
+				if (frame == now_frame &amp;&amp; live) {
 					rmb();
 					for (uf = 0; uf &lt; 8; uf++) {
 						if (q.itd-&gt;hw_transaction[uf] &amp;
@@ -2271,7 +2254,6 @@ static void scan_isoc(struct ehci_hcd *ehci)
 							break;
 					}
 					if (uf &lt; 8) {
-						incomplete = true;
 						q_p = &amp;q.itd-&gt;itd_next;
 						hw_p = &amp;q.itd-&gt;hw_next;
 						type = Q_NEXT_TYPE(ehci,
@@ -2303,14 +2285,12 @@ static void scan_isoc(struct ehci_hcd *ehci)
 				 * No need to check for activity unless the
 				 * frame is current.
 				 */
-				if (((frame == clock_frame) ||
-				     (((frame + 1) &amp; (ehci-&gt;periodic_size - 1))
-				      == clock_frame))
+				if (((frame == now_frame) ||
+				     (((frame + 1) &amp; fmask) == now_frame))
 				    &amp;&amp; live
 				    &amp;&amp; (q.sitd-&gt;hw_results &amp;
 					SITD_ACTIVE(ehci))) {
 
-					incomplete = true;
 					q_p = &amp;q.sitd-&gt;sitd_next;
 					hw_p = &amp;q.sitd-&gt;hw_next;
 					type = Q_NEXT_TYPE(ehci,
@@ -2347,50 +2327,14 @@ static void scan_isoc(struct ehci_hcd *ehci)
 			}
 
 			/* assume completion callbacks modify the queue */
-			if (unlikely (modified)) {
-				if (likely(ehci-&gt;isoc_count &gt; 0))
-					goto restart;
-				/* short-circuit this scan */
-				now_uframe = clock;
-				break;
-			}
+			if (unlikely(modified &amp;&amp; ehci-&gt;isoc_count &gt; 0))
+				goto restart;
 		}
 
-		/* If we can tell we caught up to the hardware, stop now.
-		 * We can't advance our scan without collecting the ISO
-		 * transfers that are still pending in this frame.
-		 */
-		if (incomplete &amp;&amp; ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING) {
-			ehci-&gt;next_uframe = now_uframe;
+		/* Stop when we have reached the current frame */
+		if (frame == now_frame)
 			break;
-		}
-
-		// FIXME:  this assumes we won't get lapped when
-		// latencies climb; that should be rare, but...
-		// detect it, and just go all the way around.
-		// FLR might help detect this case, so long as latencies
-		// don't exceed periodic_size msec (default 1.024 sec).
-
-		// FIXME:  likewise assumes HC doesn't halt mid-scan
-
-		if (now_uframe == clock) {
-			unsigned	now;
-
-			if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING
-					|| ehci-&gt;isoc_count == 0)
-				break;
-			ehci-&gt;next_uframe = now_uframe;
-			now = ehci_read_frame_index(ehci) &amp; (mod - 1);
-			if (now_uframe == now)
-				break;
-
-			/* rescan the rest of this frame, then ... */
-			clock = now;
-			clock_frame = clock &gt;&gt; 3;
-			ehci-&gt;clock_frame = clock_frame;
-		} else {
-			now_uframe++;
-			now_uframe &amp;= mod - 1;
-		}
+		frame = (frame + 1) &amp; fmask;
 	}
+	ehci-&gt;next_frame = now_frame;
 }
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 254f414bd0bd..7de58fe52d51 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -141,19 +141,19 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*intr_unlink;
 	struct ehci_qh		*intr_unlink_last;
 	unsigned		intr_unlink_cycle;
-	int			next_uframe;	/* scan periodic, start here */
+	unsigned		now_frame;	/* frame from HC hardware */
+	unsigned		next_frame;	/* scan periodic, start here */
 	unsigned		intr_count;	/* intr activity count */
 	unsigned		isoc_count;	/* isoc activity count */
 	unsigned		periodic_count;	/* periodic activity count */
 	unsigned		uframe_periodic_max; /* max periodic time per uframe */
 
 
-	/* list of itds &amp; sitds completed while clock_frame was still active */
+	/* list of itds &amp; sitds completed while now_frame was still active */
 	struct list_head	cached_itd_list;
 	struct ehci_itd		*last_itd_to_free;
 	struct list_head	cached_sitd_list;
 	struct ehci_sitd	*last_sitd_to_free;
-	unsigned		clock_frame;
 
 	/* per root hub port */
 	unsigned long		reset_done [EHCI_MAX_ROOT_PORTS];</pre><hr><pre>commit 18aafe64d75d0e27dae206cacf4171e4e485d285
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:04 2012 -0400

    USB: EHCI: use hrtimer for the I/O watchdog
    
    This patch (as1586) replaces the kernel timer used by ehci-hcd as an
    I/O watchdog with an hrtimer event.
    
    Unlike in the current code, the watchdog event is now always enabled
    whenever any isochronous URBs are active.  This will prevent bugs
    caused by the periodic schedule wrapping around with no completion
    interrupts; the watchdog handler is guaranteed to scan the isochronous
    transfers at least once during each iteration of the schedule.  The
    extra overhead will be negligible: one timer interrupt every 100 ms.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index c13dad8a8503..9f26080889f5 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -93,8 +93,6 @@ static const char	hcd_name [] = "ehci_hcd";
  */
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
 
-#define EHCI_IO_JIFFIES		(HZ/10)		/* io watchdog &gt; irq_thresh */
-
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
 module_param (log2_irq_thresh, int, S_IRUGO);
@@ -125,25 +123,6 @@ MODULE_PARM_DESC(hird, "host initiated resume duration, +1 for each 75us");
 
 /*-------------------------------------------------------------------------*/
 
-static void
-timer_action(struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	if (!test_and_set_bit(action, &amp;ehci-&gt;actions)) {
-		unsigned long t;
-
-		switch (action) {
-		case TIMER_IO_WATCHDOG:
-			if (!ehci-&gt;need_io_watchdog)
-				return;
-			t = EHCI_IO_JIFFIES;
-			break;
-		}
-		mod_timer(&amp;ehci-&gt;watchdog, t + jiffies);
-	}
-}
-
-/*-------------------------------------------------------------------------*/
-
 /*
  * handshake - spin reading hc until handshake completes or fails
  * @ptr: address of hc register to be read
@@ -307,19 +286,6 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 /*-------------------------------------------------------------------------*/
 
-static void ehci_watchdog(unsigned long param)
-{
-	struct ehci_hcd		*ehci = (struct ehci_hcd *) param;
-	unsigned long		flags;
-
-	spin_lock_irqsave(&amp;ehci-&gt;lock, flags);
-
-	/* ehci could run by timer, without IRQs ... */
-	ehci_work (ehci);
-
-	spin_unlock_irqrestore (&amp;ehci-&gt;lock, flags);
-}
-
 /* On some systems, leaving remote wakeup enabled prevents system shutdown.
  * The firmware seems to think that powering off is a wakeup event!
  * This routine turns off remote wakeup and everything else, on all ports.
@@ -357,8 +323,6 @@ static void ehci_shutdown(struct usb_hcd *hcd)
 {
 	struct ehci_hcd	*ehci = hcd_to_ehci(hcd);
 
-	del_timer_sync(&amp;ehci-&gt;watchdog);
-
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;rh_state = EHCI_RH_STOPPING;
 	ehci_silence_controller(ehci);
@@ -394,8 +358,6 @@ static void ehci_port_power (struct ehci_hcd *ehci, int is_on)
  */
 static void ehci_work (struct ehci_hcd *ehci)
 {
-	timer_action_done (ehci, TIMER_IO_WATCHDOG);
-
 	/* another CPU may drop ehci-&gt;lock during a schedule scan while
 	 * it reports urb completions.  this flag guards against bogus
 	 * attempts at re-entrant schedule scanning.
@@ -422,10 +384,7 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * misplace IRQs, and should let us run completely without IRQs.
 	 * such lossage has been observed on both VT6202 and VT8235.
 	 */
-	if (ehci-&gt;rh_state == EHCI_RH_RUNNING &amp;&amp;
-			(ehci-&gt;async-&gt;qh_next.ptr != NULL ||
-			 ehci-&gt;periodic_count != 0))
-		timer_action (ehci, TIMER_IO_WATCHDOG);
+	turn_on_io_watchdog(ehci);
 }
 
 /*
@@ -438,7 +397,6 @@ static void ehci_stop (struct usb_hcd *hcd)
 	ehci_dbg (ehci, "stop\n");
 
 	/* no more interrupts ... */
-	del_timer_sync (&amp;ehci-&gt;watchdog);
 
 	spin_lock_irq(&amp;ehci-&gt;lock);
 	ehci-&gt;enabled_hrtimer_events = 0;
@@ -490,9 +448,6 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * keep io watchdog by default, those good HCDs could turn off it later
 	 */
 	ehci-&gt;need_io_watchdog = 1;
-	init_timer(&amp;ehci-&gt;watchdog);
-	ehci-&gt;watchdog.function = ehci_watchdog;
-	ehci-&gt;watchdog.data = (unsigned long) ehci;
 
 	hrtimer_init(&amp;ehci-&gt;hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
 	ehci-&gt;hrtimer.function = ehci_hrtimer_func;
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 5d84562e2716..05490d387fd2 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -208,7 +208,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 
 	if (time_before (jiffies, ehci-&gt;next_statechange))
 		msleep(5);
-	del_timer_sync(&amp;ehci-&gt;watchdog);
 
 	spin_lock_irq (&amp;ehci-&gt;lock);
 
@@ -316,10 +315,6 @@ static int ehci_bus_suspend (struct usb_hcd *hcd)
 	ehci-&gt;next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;
 	spin_unlock_irq (&amp;ehci-&gt;lock);
 
-	/* ehci_work() may have re-enabled the watchdog timer, which we do not
-	 * want, and so we must delete any pending watchdog timer events.
-	 */
-	del_timer_sync(&amp;ehci-&gt;watchdog);
 	hrtimer_cancel(&amp;ehci-&gt;hrtimer);
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index c9c7f7b3b7db..9bc39ca460c8 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -970,6 +970,7 @@ static void enable_async(struct ehci_hcd *ehci)
 
 	/* Don't start the schedule until ASS is 0 */
 	ehci_poll_ASS(ehci);
+	turn_on_io_watchdog(ehci);
 }
 
 static void disable_async(struct ehci_hcd *ehci)
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 263b542985c0..26ce8fef0e5b 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -489,6 +489,7 @@ static void enable_periodic(struct ehci_hcd *ehci)
 
 	/* Don't start the schedule until PSS is 0 */
 	ehci_poll_PSS(ehci);
+	turn_on_io_watchdog(ehci);
 }
 
 static void disable_periodic(struct ehci_hcd *ehci)
@@ -1649,7 +1650,6 @@ static void itd_link_urb(
 	iso_sched_free (stream, iso_sched);
 	urb-&gt;hcpriv = NULL;
 
-	timer_action (ehci, TIMER_IO_WATCHDOG);
 	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
@@ -2052,7 +2052,6 @@ static void sitd_link_urb(
 	iso_sched_free (stream, sched);
 	urb-&gt;hcpriv = NULL;
 
-	timer_action (ehci, TIMER_IO_WATCHDOG);
 	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index 0e28bae78d18..eb896a2c8f2e 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -76,6 +76,7 @@ static unsigned event_delays_ns[] = {
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IAA_WATCHDOG */
 	10 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	15 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_DISABLE_ASYNC */
+	100 * NSEC_PER_MSEC,	/* EHCI_HRTIMER_IO_WATCHDOG */
 };
 
 /* Enable a pending hrtimer event */
@@ -332,6 +333,25 @@ static void ehci_iaa_watchdog(struct ehci_hcd *ehci)
 }
 
 
+/* Enable the I/O watchdog, if appropriate */
+static void turn_on_io_watchdog(struct ehci_hcd *ehci)
+{
+	/* Not needed if the controller isn't running or it's already enabled */
+	if (ehci-&gt;rh_state != EHCI_RH_RUNNING ||
+			(ehci-&gt;enabled_hrtimer_events &amp;
+				BIT(EHCI_HRTIMER_IO_WATCHDOG)))
+		return;
+
+	/*
+	 * Isochronous transfers always need the watchdog.
+	 * For other sorts we use it only if the flag is set.
+	 */
+	if (ehci-&gt;isoc_count &gt; 0 || (ehci-&gt;need_io_watchdog &amp;&amp;
+			ehci-&gt;async_count + ehci-&gt;intr_count &gt; 0))
+		ehci_enable_event(ehci, EHCI_HRTIMER_IO_WATCHDOG, true);
+}
+
+
 /*
  * Handler functions for the hrtimer event types.
  * Keep this array in the same order as the event types indexed by
@@ -347,6 +367,7 @@ static void (*event_handlers[])(struct ehci_hcd *) = {
 	ehci_iaa_watchdog,		/* EHCI_HRTIMER_IAA_WATCHDOG */
 	ehci_disable_PSE,		/* EHCI_HRTIMER_DISABLE_PERIODIC */
 	ehci_disable_ASE,		/* EHCI_HRTIMER_DISABLE_ASYNC */
+	ehci_work,			/* EHCI_HRTIMER_IO_WATCHDOG */
 };
 
 static enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 08637183aad0..254f414bd0bd 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -88,6 +88,7 @@ enum ehci_hrtimer_event {
 	EHCI_HRTIMER_IAA_WATCHDOG,	/* Handle lost IAA interrupts */
 	EHCI_HRTIMER_DISABLE_PERIODIC,	/* Wait to disable periodic sched */
 	EHCI_HRTIMER_DISABLE_ASYNC,	/* Wait to disable async sched */
+	EHCI_HRTIMER_IO_WATCHDOG,	/* Check for missing IRQs */
 	EHCI_HRTIMER_NUM_EVENTS		/* Must come last */
 };
 #define EHCI_HRTIMER_NO_EVENT	99
@@ -177,8 +178,6 @@ struct ehci_hcd {			/* one per controller */
 	struct dma_pool		*itd_pool;	/* itd per iso urb */
 	struct dma_pool		*sitd_pool;	/* sitd per split iso urb */
 
-	struct timer_list	watchdog;
-	unsigned long		actions;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
 	ktime_t			last_periodic_enable;
@@ -235,16 +234,6 @@ static inline struct usb_hcd *ehci_to_hcd (struct ehci_hcd *ehci)
 	return container_of ((void *) ehci, struct usb_hcd, hcd_priv);
 }
 
-enum ehci_timer_action {
-	TIMER_IO_WATCHDOG,
-};
-
-static inline void
-timer_action_done (struct ehci_hcd *ehci, enum ehci_timer_action action)
-{
-	clear_bit (action, &amp;ehci-&gt;actions);
-}
-
 /*-------------------------------------------------------------------------*/
 
 #include &lt;linux/usb/ehci_def.h&gt;</pre><hr><pre>commit 569b394f53f0abd177cc665c9b4ace89e3f4c7fb
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:23:00 2012 -0400

    USB: EHCI: always scan each interrupt QH
    
    This patch (as1585) fixes a bug in ehci-hcd's scheme for scanning
    interrupt QHs.
    
    Currently a single routine takes care of scanning everything on the
    periodic schedule.  Whenever an interrupt occurs, it scans all
    isochronous and interrupt URBs scheduled for frames that have elapsed
    since the last scan.
    
    This has two disadvantages.  The first is relatively minor: An
    interrupt QH is likely to end up getting scanned multiple times,
    particularly if the last scan was not fairly recent.  (The current
    code avoids this by maintaining a periodic_stamp in each interrupt
    QH.)
    
    The second is more serious.  The periodic schedule wraps around.  If
    the last scan occurred during frame N, and the next scan occurs when
    the schedule has gone through an entire cycle and is back at frame N,
    the scanning code won't look at any frames other than N.  Consequently
    it won't see any QHs that completed during frame N-1 or earlier.
    
    The patch replaces the entire frame-based approach for scanning
    interrupt QHs with a new routine using a list-based approach, the same
    as for async QHs.  This has a slight disadvantage, because it means
    that all interrupt QHs have to be scanned every time.  But it is more
    robust than the current approach.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index f6cf1d178107..c13dad8a8503 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -410,8 +410,10 @@ static void ehci_work (struct ehci_hcd *ehci)
 	ehci-&gt;need_rescan = false;
 	if (ehci-&gt;async_count)
 		scan_async(ehci);
-	if (ehci-&gt;next_uframe != -1)
-		scan_periodic (ehci);
+	if (ehci-&gt;intr_count &gt; 0)
+		scan_intr(ehci);
+	if (ehci-&gt;isoc_count &gt; 0)
+		scan_isoc(ehci);
 	if (ehci-&gt;need_rescan)
 		goto rescan;
 	ehci-&gt;scanning = false;
@@ -509,6 +511,7 @@ static int ehci_init(struct usb_hcd *hcd)
 	 * periodic_size can shrink by USBCMD update if hcc_params allows.
 	 */
 	ehci-&gt;periodic_size = DEFAULT_I_TDPS;
+	INIT_LIST_HEAD(&amp;ehci-&gt;intr_qh_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_itd_list);
 	INIT_LIST_HEAD(&amp;ehci-&gt;cached_sitd_list);
 
diff --git a/drivers/usb/host/ehci-q.c b/drivers/usb/host/ehci-q.c
index bae931767825..c9c7f7b3b7db 100644
--- a/drivers/usb/host/ehci-q.c
+++ b/drivers/usb/host/ehci-q.c
@@ -322,7 +322,7 @@ qh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)
 	 *
 	 * It's a bug for qh-&gt;qh_state to be anything other than
 	 * QH_STATE_IDLE, unless our caller is scan_async() or
-	 * scan_periodic().
+	 * scan_intr().
 	 */
 	state = qh-&gt;qh_state;
 	qh-&gt;qh_state = QH_STATE_COMPLETING;
@@ -832,7 +832,6 @@ qh_make (
 				is_input, 0,
 				hb_mult(maxp) * max_packet(maxp)));
 		qh-&gt;start = NO_FRAME;
-		qh-&gt;stamp = ehci-&gt;periodic_stamp;
 
 		if (urb-&gt;dev-&gt;speed == USB_SPEED_HIGH) {
 			qh-&gt;c_usecs = 0;
diff --git a/drivers/usb/host/ehci-sched.c b/drivers/usb/host/ehci-sched.c
index 11b2f21d7ac1..263b542985c0 100644
--- a/drivers/usb/host/ehci-sched.c
+++ b/drivers/usb/host/ehci-sched.c
@@ -569,7 +569,10 @@ static void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 		? ((qh-&gt;usecs + qh-&gt;c_usecs) / qh-&gt;period)
 		: (qh-&gt;usecs * 8);
 
+	list_add(&amp;qh-&gt;intr_node, &amp;ehci-&gt;intr_qh_list);
+
 	/* maybe enable periodic schedule processing */
+	++ehci-&gt;intr_count;
 	enable_periodic(ehci);
 }
 
@@ -614,6 +617,11 @@ static void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	/* qh-&gt;qh_next still "live" to HC */
 	qh-&gt;qh_state = QH_STATE_UNLINK;
 	qh-&gt;qh_next.ptr = NULL;
+
+	if (ehci-&gt;qh_scan_next == qh)
+		ehci-&gt;qh_scan_next = list_entry(qh-&gt;intr_node.next,
+				struct ehci_qh, intr_node);
+	list_del(&amp;qh-&gt;intr_node);
 }
 
 static void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -683,6 +691,7 @@ static void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)
 	}
 
 	/* maybe turn off periodic schedule */
+	--ehci-&gt;intr_count;
 	disable_periodic(ehci);
 }
 
@@ -920,6 +929,35 @@ static int intr_submit (
 	return status;
 }
 
+static void scan_intr(struct ehci_hcd *ehci)
+{
+	struct ehci_qh		*qh;
+
+	list_for_each_entry_safe(qh, ehci-&gt;qh_scan_next, &amp;ehci-&gt;intr_qh_list,
+			intr_node) {
+ rescan:
+		/* clean any finished work for this qh */
+		if (!list_empty(&amp;qh-&gt;qtd_list)) {
+			int temp;
+
+			/*
+			 * Unlinks could happen here; completion reporting
+			 * drops the lock.  That's why ehci-&gt;qh_scan_next
+			 * always holds the next qh to scan; if the next qh
+			 * gets unlinked then ehci-&gt;qh_scan_next is adjusted
+			 * in qh_unlink_periodic().
+			 */
+			temp = qh_completions(ehci, qh);
+			if (unlikely(qh-&gt;needs_rescan ||
+					(list_empty(&amp;qh-&gt;qtd_list) &amp;&amp;
+						qh-&gt;qh_state == QH_STATE_LINKED)))
+				start_unlink_intr(ehci, qh);
+			else if (temp != 0)
+				goto rescan;
+		}
+	}
+}
+
 /*-------------------------------------------------------------------------*/
 
 /* ehci_iso_stream ops work with both ITD and SITD */
@@ -1450,6 +1488,10 @@ iso_stream_schedule (
 	urb-&gt;start_frame = stream-&gt;next_uframe;
 	if (!stream-&gt;highspeed)
 		urb-&gt;start_frame &gt;&gt;= 3;
+
+	/* Make sure scan_isoc() sees these */
+	if (ehci-&gt;isoc_count == 0)
+		ehci-&gt;next_uframe = now;
 	return 0;
 
  fail:
@@ -1608,6 +1650,7 @@ static void itd_link_urb(
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
 
@@ -1688,9 +1731,11 @@ itd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+
+	--ehci-&gt;isoc_count;
 	disable_periodic(ehci);
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {
 		if (ehci-&gt;amd_pll_fix == 1)
 			usb_amd_quirk_pll_enable();
@@ -2008,6 +2053,7 @@ static void sitd_link_urb(
 	urb-&gt;hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+	++ehci-&gt;isoc_count;
 	enable_periodic(ehci);
 }
 
@@ -2074,9 +2120,11 @@ sitd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+
+	--ehci-&gt;isoc_count;
 	disable_periodic(ehci);
-	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 
+	ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs--;
 	if (ehci_to_hcd(ehci)-&gt;self.bandwidth_isoc_reqs == 0) {
 		if (ehci-&gt;amd_pll_fix == 1)
 			usb_amd_quirk_pll_enable();
@@ -2165,8 +2213,7 @@ static int sitd_submit (struct ehci_hcd *ehci, struct urb *urb,
 
 /*-------------------------------------------------------------------------*/
 
-static void
-scan_periodic (struct ehci_hcd *ehci)
+static void scan_isoc(struct ehci_hcd *ehci)
 {
 	unsigned	now_uframe, frame, clock, clock_frame, mod;
 	unsigned	modified;
@@ -2189,7 +2236,6 @@ scan_periodic (struct ehci_hcd *ehci)
 	ehci-&gt;clock_frame = clock_frame;
 	clock &amp;= mod - 1;
 	clock_frame = clock &gt;&gt; 3;
-	++ehci-&gt;periodic_stamp;
 
 	for (;;) {
 		union ehci_shadow	q, *q_p;
@@ -2208,36 +2254,10 @@ scan_periodic (struct ehci_hcd *ehci)
 
 		while (q.ptr != NULL) {
 			unsigned		uf;
-			union ehci_shadow	temp;
 			int			live;
 
 			live = (ehci-&gt;rh_state &gt;= EHCI_RH_RUNNING);
 			switch (hc32_to_cpu(ehci, type)) {
-			case Q_TYPE_QH:
-				/* handle any completions */
-				temp.qh = q.qh;
-				type = Q_NEXT_TYPE(ehci, q.qh-&gt;hw-&gt;hw_next);
-				q = q.qh-&gt;qh_next;
-				if (temp.qh-&gt;stamp != ehci-&gt;periodic_stamp) {
-					modified = qh_completions(ehci, temp.qh);
-					if (!modified)
-						temp.qh-&gt;stamp = ehci-&gt;periodic_stamp;
-					if (unlikely(list_empty(&amp;temp.qh-&gt;qtd_list) ||
-							temp.qh-&gt;needs_rescan))
-						start_unlink_intr(ehci, temp.qh);
-				}
-				break;
-			case Q_TYPE_FSTN:
-				/* for "save place" FSTNs, look at QH entries
-				 * in the previous frame for completions.
-				 */
-				if (q.fstn-&gt;hw_prev != EHCI_LIST_END(ehci)) {
-					ehci_dbg(ehci,
-						"ignoring completions from FSTNs\n");
-				}
-				type = Q_NEXT_TYPE(ehci, q.fstn-&gt;hw_next);
-				q = q.fstn-&gt;fstn_next;
-				break;
 			case Q_TYPE_ITD:
 				/* If this ITD is still active, leave it for
 				 * later processing ... check the next entry.
@@ -2319,12 +2339,17 @@ scan_periodic (struct ehci_hcd *ehci)
 				ehci_dbg(ehci, "corrupt type %d frame %d shadow %p\n",
 					type, frame, q.ptr);
 				// BUG ();
+				/* FALL THROUGH */
+			case Q_TYPE_QH:
+			case Q_TYPE_FSTN:
+				/* End of the iTDs and siTDs */
 				q.ptr = NULL;
+				break;
 			}
 
 			/* assume completion callbacks modify the queue */
 			if (unlikely (modified)) {
-				if (likely(ehci-&gt;periodic_count &gt; 0))
+				if (likely(ehci-&gt;isoc_count &gt; 0))
 					goto restart;
 				/* short-circuit this scan */
 				now_uframe = clock;
@@ -2353,7 +2378,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			unsigned	now;
 
 			if (ehci-&gt;rh_state &lt; EHCI_RH_RUNNING
-					|| ehci-&gt;periodic_count == 0)
+					|| ehci-&gt;isoc_count == 0)
 				break;
 			ehci-&gt;next_uframe = now_uframe;
 			now = ehci_read_frame_index(ehci) &amp; (mod - 1);
@@ -2363,10 +2388,7 @@ scan_periodic (struct ehci_hcd *ehci)
 			/* rescan the rest of this frame, then ... */
 			clock = now;
 			clock_frame = clock &gt;&gt; 3;
-			if (ehci-&gt;clock_frame != clock_frame) {
-				ehci-&gt;clock_frame = clock_frame;
-				++ehci-&gt;periodic_stamp;
-			}
+			ehci-&gt;clock_frame = clock_frame;
 		} else {
 			now_uframe++;
 			now_uframe &amp;= mod - 1;
diff --git a/drivers/usb/host/ehci-timer.c b/drivers/usb/host/ehci-timer.c
index a823290b5139..0e28bae78d18 100644
--- a/drivers/usb/host/ehci-timer.c
+++ b/drivers/usb/host/ehci-timer.c
@@ -168,13 +168,8 @@ static void ehci_poll_PSS(struct ehci_hcd *ehci)
 
 	/* The status is up-to-date; restart or stop the schedule as needed */
 	if (want == 0) {	/* Stopped */
-		if (ehci-&gt;periodic_count &gt; 0) {
-
-			/* make sure ehci_work scans these */
-			ehci-&gt;next_uframe = ehci_read_frame_index(ehci)
-					&amp; ((ehci-&gt;periodic_size &lt;&lt; 3) - 1);
+		if (ehci-&gt;periodic_count &gt; 0)
 			ehci_set_command_bit(ehci, CMD_PSE);
-		}
 
 	} else {		/* Running */
 		if (ehci-&gt;periodic_count == 0) {
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index c462d52ac575..08637183aad0 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -117,6 +117,7 @@ struct ehci_hcd {			/* one per controller */
 	bool			need_rescan:1;
 	bool			intr_unlinking:1;
 	bool			async_unlinking:1;
+	struct ehci_qh		*qh_scan_next;
 
 	/* async schedule support */
 	struct ehci_qh		*async;
@@ -124,7 +125,6 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*async_unlink;
 	struct ehci_qh		*async_unlink_last;
 	struct ehci_qh		*async_iaa;
-	struct ehci_qh		*qh_scan_next;
 	unsigned		async_unlink_cycle;
 	unsigned		async_count;	/* async activity count */
 
@@ -133,6 +133,7 @@ struct ehci_hcd {			/* one per controller */
 	unsigned		periodic_size;
 	__hc32			*periodic;	/* hw periodic table */
 	dma_addr_t		periodic_dma;
+	struct list_head	intr_qh_list;
 	unsigned		i_thresh;	/* uframes HC might cache */
 
 	union ehci_shadow	*pshadow;	/* mirror hw periodic table */
@@ -140,6 +141,8 @@ struct ehci_hcd {			/* one per controller */
 	struct ehci_qh		*intr_unlink_last;
 	unsigned		intr_unlink_cycle;
 	int			next_uframe;	/* scan periodic, start here */
+	unsigned		intr_count;	/* intr activity count */
+	unsigned		isoc_count;	/* isoc activity count */
 	unsigned		periodic_count;	/* periodic activity count */
 	unsigned		uframe_periodic_max; /* max periodic time per uframe */
 
@@ -176,7 +179,6 @@ struct ehci_hcd {			/* one per controller */
 
 	struct timer_list	watchdog;
 	unsigned long		actions;
-	unsigned		periodic_stamp;
 	unsigned		random_frame;
 	unsigned long		next_statechange;
 	ktime_t			last_periodic_enable;
@@ -381,11 +383,11 @@ struct ehci_qh {
 	dma_addr_t		qh_dma;		/* address of qh */
 	union ehci_shadow	qh_next;	/* ptr to qh; or periodic */
 	struct list_head	qtd_list;	/* sw qtd list */
+	struct list_head	intr_node;	/* list of intr QHs */
 	struct ehci_qtd		*dummy;
 	struct ehci_qh		*unlink_next;	/* next on unlink list */
 
 	unsigned		unlink_cycle;
-	unsigned		stamp;
 
 	u8			needs_rescan;	/* Dequeue during giveback */
 	u8			qh_state;</pre><hr><pre>commit 361aabf395e4a23cf554cf4ec0c0c6963b8beb01
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Jul 11 11:22:57 2012 -0400

    USB: EHCI: don't lose events during a scan
    
    This patch (as1584) fixes a minor bug that has been present in
    ehci-hcd since the beginning.
    
    Scanning the schedules for URB completions is single-threaded.  If a
    completion interrupt occurs while an URB is being given back, the
    interrupt handler realizes that a scan is in progress on another CPU
    and avoids starting a new one.
    
    This means that completion events can be lost.  If an URB completes
    after it has been scanned but while a scan is still in progress, the
    driver won't notice and won't rescan the completed URB.
    
    The patch fixes the problem by adding a new flag to indicate that
    another scan is needed after the current scan is done.  The flag gets
    set whenever a completion interrupt occurs while a scan is in
    progress.  The rescan will see the completion, thus preventing it from
    getting lost.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 74ffd20edff8..f6cf1d178107 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -400,14 +400,21 @@ static void ehci_work (struct ehci_hcd *ehci)
 	 * it reports urb completions.  this flag guards against bogus
 	 * attempts at re-entrant schedule scanning.
 	 */
-	if (ehci-&gt;scanning)
+	if (ehci-&gt;scanning) {
+		ehci-&gt;need_rescan = true;
 		return;
-	ehci-&gt;scanning = 1;
+	}
+	ehci-&gt;scanning = true;
+
+ rescan:
+	ehci-&gt;need_rescan = false;
 	if (ehci-&gt;async_count)
 		scan_async(ehci);
 	if (ehci-&gt;next_uframe != -1)
 		scan_periodic (ehci);
-	ehci-&gt;scanning = 0;
+	if (ehci-&gt;need_rescan)
+		goto rescan;
+	ehci-&gt;scanning = false;
 
 	/* the IO watchdog guards against hardware or driver bugs that
 	 * misplace IRQs, and should let us run completely without IRQs.
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index 303c36cc99c9..c462d52ac575 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -113,7 +113,8 @@ struct ehci_hcd {			/* one per controller */
 	enum ehci_rh_state	rh_state;
 
 	/* general schedule support */
-	unsigned		scanning:1;
+	bool			scanning:1;
+	bool			need_rescan:1;
 	bool			intr_unlinking:1;
 	bool			async_unlinking:1;
 </pre>
    <div class="pagination">
        <a href='2_44.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><span>[45]</span><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_46.html'>Next&gt;&gt;</a>
    <div>
</body>
