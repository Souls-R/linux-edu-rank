<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Zhejiang University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Zhejiang University</h1>
    <div class="pagination">
        <a href='6_2.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><span>[3]</span><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_4.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit b4152222e04cb8afeeca239c90e3fcaf4c553b42
Author: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
Date:   Thu Feb 29 18:31:53 2024 +0800

    wifi: brcm80211: handle pmk_op allocation failure
    
    The kzalloc() in brcmf_pmksa_v3_op() will return null if the
    physical memory has run out. As a result, if we dereference
    the null value, the null pointer dereference bug will happen.
    
    Return -ENOMEM from brcmf_pmksa_v3_op() if kzalloc() fails
    for pmk_op.
    
    Fixes: a96202acaea4 ("wifi: brcmfmac: cfg80211: Add support for PMKID_V3 operations")
    Acked-by: Arend van Spriel &lt;arend.vanspriel@broadcom.com&gt;
    Signed-off-by: Duoming Zhou &lt;duoming@zju.edu.cn&gt;
    Reviewed-by: Kees Cook &lt;keescook@chromium.org&gt;
    Signed-off-by: Kalle Valo &lt;kvalo@kernel.org&gt;
    Link: https://msgid.link/20240229103153.18533-1-duoming@zju.edu.cn

diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index 54ff59a8c35c..b99aa66dc5a9 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -4308,6 +4308,9 @@ brcmf_pmksa_v3_op(struct brcmf_if *ifp, struct cfg80211_pmksa *pmksa,
 	int ret;
 
 	pmk_op = kzalloc(sizeof(*pmk_op), GFP_KERNEL);
+	if (!pmk_op)
+		return -ENOMEM;
+
 	pmk_op-&gt;version = cpu_to_le16(BRCMF_PMKSA_VER_3);
 
 	if (!pmksa) {</pre><hr><pre>commit 3cfcfc102a5e57b021b786a755a38935e357797d
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Tue Jan 2 13:38:13 2024 +0800

    SUNRPC: fix some memleaks in gssx_dec_option_array
    
    The creds and oa-&gt;data need to be freed in the error-handling paths after
    their allocation. So this patch add these deallocations in the
    corresponding paths.
    
    Fixes: 1d658336b05f ("SUNRPC: Add RPC based upcall mechanism for RPCGSS auth")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Chuck Lever &lt;chuck.lever@oracle.com&gt;

diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c
index d79f12c2550a..cb32ab9a8395 100644
--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c
+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c
@@ -250,8 +250,8 @@ static int gssx_dec_option_array(struct xdr_stream *xdr,
 
 	creds = kzalloc(sizeof(struct svc_cred), GFP_KERNEL);
 	if (!creds) {
-		kfree(oa-&gt;data);
-		return -ENOMEM;
+		err = -ENOMEM;
+		goto free_oa;
 	}
 
 	oa-&gt;data[0].option.data = CREDS_VALUE;
@@ -265,29 +265,40 @@ static int gssx_dec_option_array(struct xdr_stream *xdr,
 
 		/* option buffer */
 		p = xdr_inline_decode(xdr, 4);
-		if (unlikely(p == NULL))
-			return -ENOSPC;
+		if (unlikely(p == NULL)) {
+			err = -ENOSPC;
+			goto free_creds;
+		}
 
 		length = be32_to_cpup(p);
 		p = xdr_inline_decode(xdr, length);
-		if (unlikely(p == NULL))
-			return -ENOSPC;
+		if (unlikely(p == NULL)) {
+			err = -ENOSPC;
+			goto free_creds;
+		}
 
 		if (length == sizeof(CREDS_VALUE) &amp;&amp;
 		    memcmp(p, CREDS_VALUE, sizeof(CREDS_VALUE)) == 0) {
 			/* We have creds here. parse them */
 			err = gssx_dec_linux_creds(xdr, creds);
 			if (err)
-				return err;
+				goto free_creds;
 			oa-&gt;data[0].value.len = 1; /* presence */
 		} else {
 			/* consume uninteresting buffer */
 			err = gssx_dec_buffer(xdr, &amp;dummy);
 			if (err)
-				return err;
+				goto free_creds;
 		}
 	}
 	return 0;
+
+free_creds:
+	kfree(creds);
+free_oa:
+	kfree(oa-&gt;data);
+	oa-&gt;data = NULL;
+	return err;
 }
 
 static int gssx_dec_status(struct xdr_stream *xdr,</pre><hr><pre>commit e67b652d8e8591d3b1e569dbcdfcee15993e91fa
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Sun Dec 24 16:20:33 2023 +0800

    SUNRPC: fix a memleak in gss_import_v2_context
    
    The ctx-&gt;mech_used.data allocated by kmemdup is not freed in neither
    gss_import_v2_context nor it only caller gss_krb5_import_sec_context,
    which frees ctx on error.
    
    Thus, this patch reform the last call of gss_import_v2_context to the
    gss_krb5_import_ctx_v2, preventing the memleak while keepping the return
    formation.
    
    Fixes: 47d848077629 ("gss_krb5: handle new context format from gssd")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Reviewed-by: Jeff Layton &lt;jlayton@kernel.org&gt;
    Signed-off-by: Chuck Lever &lt;chuck.lever@oracle.com&gt;

diff --git a/net/sunrpc/auth_gss/gss_krb5_mech.c b/net/sunrpc/auth_gss/gss_krb5_mech.c
index 64cff717c3d9..3366505bc669 100644
--- a/net/sunrpc/auth_gss/gss_krb5_mech.c
+++ b/net/sunrpc/auth_gss/gss_krb5_mech.c
@@ -398,6 +398,7 @@ gss_import_v2_context(const void *p, const void *end, struct krb5_ctx *ctx,
 	u64 seq_send64;
 	int keylen;
 	u32 time32;
+	int ret;
 
 	p = simple_get_bytes(p, end, &amp;ctx-&gt;flags, sizeof(ctx-&gt;flags));
 	if (IS_ERR(p))
@@ -450,8 +451,16 @@ gss_import_v2_context(const void *p, const void *end, struct krb5_ctx *ctx,
 	}
 	ctx-&gt;mech_used.len = gss_kerberos_mech.gm_oid.len;
 
-	return gss_krb5_import_ctx_v2(ctx, gfp_mask);
+	ret = gss_krb5_import_ctx_v2(ctx, gfp_mask);
+	if (ret) {
+		p = ERR_PTR(ret);
+		goto out_free;
+	}
 
+	return 0;
+
+out_free:
+	kfree(ctx-&gt;mech_used.data);
 out_err:
 	return PTR_ERR(p);
 }</pre><hr><pre>commit 743ad091fb46e622f1b690385bb15e3cd3daf874
Author: Lin Ma &lt;linma@zju.edu.cn&gt;
Date:   Tue Feb 27 20:11:28 2024 +0800

    rtnetlink: fix error logic of IFLA_BRIDGE_FLAGS writing back
    
    In the commit d73ef2d69c0d ("rtnetlink: let rtnl_bridge_setlink checks
    IFLA_BRIDGE_MODE length"), an adjustment was made to the old loop logic
    in the function `rtnl_bridge_setlink` to enable the loop to also check
    the length of the IFLA_BRIDGE_MODE attribute. However, this adjustment
    removed the `break` statement and led to an error logic of the flags
    writing back at the end of this function.
    
    if (have_flags)
        memcpy(nla_data(attr), &amp;flags, sizeof(flags));
        // attr should point to IFLA_BRIDGE_FLAGS NLA !!!
    
    Before the mentioned commit, the `attr` is granted to be IFLA_BRIDGE_FLAGS.
    However, this is not necessarily true fow now as the updated loop will let
    the attr point to the last NLA, even an invalid NLA which could cause
    overflow writes.
    
    This patch introduces a new variable `br_flag` to save the NLA pointer
    that points to IFLA_BRIDGE_FLAGS and uses it to resolve the mentioned
    error logic.
    
    Fixes: d73ef2d69c0d ("rtnetlink: let rtnl_bridge_setlink checks IFLA_BRIDGE_MODE length")
    Signed-off-by: Lin Ma &lt;linma@zju.edu.cn&gt;
    Acked-by: Nikolay Aleksandrov &lt;razor@blackwall.org&gt;
    Link: https://lore.kernel.org/r/20240227121128.608110-1-linma@zju.edu.cn
    Signed-off-by: Jakub Kicinski &lt;kuba@kernel.org&gt;

diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 9c4f427f3a50..ae86f751efc3 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -5169,10 +5169,9 @@ static int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,
 	struct net *net = sock_net(skb-&gt;sk);
 	struct ifinfomsg *ifm;
 	struct net_device *dev;
-	struct nlattr *br_spec, *attr = NULL;
+	struct nlattr *br_spec, *attr, *br_flags_attr = NULL;
 	int rem, err = -EOPNOTSUPP;
 	u16 flags = 0;
-	bool have_flags = false;
 
 	if (nlmsg_len(nlh) &lt; sizeof(*ifm))
 		return -EINVAL;
@@ -5190,11 +5189,11 @@ static int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,
 	br_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
 	if (br_spec) {
 		nla_for_each_nested(attr, br_spec, rem) {
-			if (nla_type(attr) == IFLA_BRIDGE_FLAGS &amp;&amp; !have_flags) {
+			if (nla_type(attr) == IFLA_BRIDGE_FLAGS &amp;&amp; !br_flags_attr) {
 				if (nla_len(attr) &lt; sizeof(flags))
 					return -EINVAL;
 
-				have_flags = true;
+				br_flags_attr = attr;
 				flags = nla_get_u16(attr);
 			}
 
@@ -5238,8 +5237,8 @@ static int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh,
 		}
 	}
 
-	if (have_flags)
-		memcpy(nla_data(attr), &amp;flags, sizeof(flags));
+	if (br_flags_attr)
+		memcpy(nla_data(br_flags_attr), &amp;flags, sizeof(flags));
 out:
 	return err;
 }</pre><hr><pre>commit d0b07f712bf61e1a3cf23c87c663791c42e50837
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Wed Feb 21 13:17:04 2024 +0800

    media: ttpci: fix two memleaks in budget_av_attach
    
    When saa7146_register_device and saa7146_vv_init fails, budget_av_attach
    should free the resources it allocates, like the error-handling of
    ttpci_budget_init does. Besides, there are two fixme comment refers to
    such deallocations.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;

diff --git a/drivers/media/pci/ttpci/budget-av.c b/drivers/media/pci/ttpci/budget-av.c
index 230b104a7cdf..a47c5850ef87 100644
--- a/drivers/media/pci/ttpci/budget-av.c
+++ b/drivers/media/pci/ttpci/budget-av.c
@@ -1463,7 +1463,8 @@ static int budget_av_attach(struct saa7146_dev *dev, struct saa7146_pci_extensio
 		budget_av-&gt;has_saa7113 = 1;
 		err = saa7146_vv_init(dev, &amp;vv_data);
 		if (err != 0) {
-			/* fixme: proper cleanup here */
+			ttpci_budget_deinit(&amp;budget_av-&gt;budget);
+			kfree(budget_av);
 			ERR("cannot init vv subsystem\n");
 			return err;
 		}
@@ -1472,9 +1473,10 @@ static int budget_av_attach(struct saa7146_dev *dev, struct saa7146_pci_extensio
 		vv_data.vid_ops.vidioc_s_input = vidioc_s_input;
 
 		if ((err = saa7146_register_device(&amp;budget_av-&gt;vd, dev, "knc1", VFL_TYPE_VIDEO))) {
-			/* fixme: proper cleanup here */
-			ERR("cannot register capture v4l2 device\n");
 			saa7146_vv_release(dev);
+			ttpci_budget_deinit(&amp;budget_av-&gt;budget);
+			kfree(budget_av);
+			ERR("cannot register capture v4l2 device\n");
 			return err;
 		}
 </pre><hr><pre>commit b9b683844b01d171a72b9c0419a2d760d946ee12
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Wed Feb 21 12:37:13 2024 +0800

    media: go7007: fix a memleak in go7007_load_encoder
    
    In go7007_load_encoder, bounce(i.e. go-&gt;boot_fw), is allocated without
    a deallocation thereafter. After the following call chain:
    
    saa7134_go7007_init
      |-&gt; go7007_boot_encoder
            |-&gt; go7007_load_encoder
      |-&gt; kfree(go)
    
    go is freed and thus bounce is leaked.
    
    Fixes: 95ef39403f89 ("[media] go7007: remember boot firmware")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;

diff --git a/drivers/media/usb/go7007/go7007-driver.c b/drivers/media/usb/go7007/go7007-driver.c
index 0c24e2984304..eb03f98b2ef1 100644
--- a/drivers/media/usb/go7007/go7007-driver.c
+++ b/drivers/media/usb/go7007/go7007-driver.c
@@ -80,7 +80,7 @@ static int go7007_load_encoder(struct go7007 *go)
 	const struct firmware *fw_entry;
 	char fw_name[] = "go7007/go7007fw.bin";
 	void *bounce;
-	int fw_len, rv = 0;
+	int fw_len;
 	u16 intr_val, intr_data;
 
 	if (go-&gt;boot_fw == NULL) {
@@ -109,9 +109,11 @@ static int go7007_load_encoder(struct go7007 *go)
 	    go7007_read_interrupt(go, &amp;intr_val, &amp;intr_data) &lt; 0 ||
 			(intr_val &amp; ~0x1) != 0x5a5a) {
 		v4l2_err(go, "error transferring firmware\n");
-		rv = -1;
+		kfree(go-&gt;boot_fw);
+		go-&gt;boot_fw = NULL;
+		return -1;
 	}
-	return rv;
+	return 0;
 }
 
 MODULE_FIRMWARE("go7007/go7007fw.bin");</pre><hr><pre>commit 8c64f4cdf4e6cc5682c52523713af8c39c94e6d5
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Sat Feb 3 14:40:43 2024 +0100

    media: edia: dvbdev: fix a use-after-free
    
    In dvb_register_device, *pdvbdev is set equal to dvbdev, which is freed
    in several error-handling paths. However, *pdvbdev is not set to NULL
    after dvbdev's deallocation, causing use-after-frees in many places,
    for example, in the following call chain:
    
    budget_register
      |-&gt; dvb_dmxdev_init
            |-&gt; dvb_register_device
      |-&gt; dvb_dmxdev_release
            |-&gt; dvb_unregister_device
                  |-&gt; dvb_remove_device
                        |-&gt; dvb_device_put
                              |-&gt; kref_put
    
    When calling dvb_unregister_device, dmxdev-&gt;dvbdev (i.e. *pdvbdev in
    dvb_register_device) could point to memory that had been freed in
    dvb_register_device. Thereafter, this pointer is transferred to
    kref_put and triggering a use-after-free.
    
    Link: https://lore.kernel.org/linux-media/20240203134046.3120099-1-alexious@zju.edu.cn
    Fixes: b61901024776 ("V4L/DVB (5244): Dvbdev: fix illegal re-usage of fileoperations struct")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@kernel.org&gt;

diff --git a/drivers/media/dvb-core/dvbdev.c b/drivers/media/dvb-core/dvbdev.c
index 49f0eb7d0b9d..733d0bc4b4cc 100644
--- a/drivers/media/dvb-core/dvbdev.c
+++ b/drivers/media/dvb-core/dvbdev.c
@@ -490,6 +490,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 		dvbdevfops = kmemdup(template-&gt;fops, sizeof(*dvbdevfops), GFP_KERNEL);
 		if (!dvbdevfops) {
 			kfree(dvbdev);
+			*pdvbdev = NULL;
 			mutex_unlock(&amp;dvbdev_register_lock);
 			return -ENOMEM;
 		}
@@ -498,6 +499,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 		if (!new_node) {
 			kfree(dvbdevfops);
 			kfree(dvbdev);
+			*pdvbdev = NULL;
 			mutex_unlock(&amp;dvbdev_register_lock);
 			return -ENOMEM;
 		}
@@ -531,6 +533,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 		}
 		list_del(&amp;dvbdev-&gt;list_head);
 		kfree(dvbdev);
+		*pdvbdev = NULL;
 		up_write(&amp;minor_rwsem);
 		mutex_unlock(&amp;dvbdev_register_lock);
 		return -EINVAL;
@@ -553,6 +556,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 		dvb_media_device_free(dvbdev);
 		list_del(&amp;dvbdev-&gt;list_head);
 		kfree(dvbdev);
+		*pdvbdev = NULL;
 		mutex_unlock(&amp;dvbdev_register_lock);
 		return ret;
 	}
@@ -571,6 +575,7 @@ int dvb_register_device(struct dvb_adapter *adap, struct dvb_device **pdvbdev,
 		dvb_media_device_free(dvbdev);
 		list_del(&amp;dvbdev-&gt;list_head);
 		kfree(dvbdev);
+		*pdvbdev = NULL;
 		mutex_unlock(&amp;dvbdev_register_lock);
 		return PTR_ERR(clsdev);
 	}</pre><hr><pre>commit 5f0e4aede01cb01fa633171f0533affd25328c3a
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Fri Jan 26 15:53:34 2024 +0800

    wifi: libertas: fix some memleaks in lbs_allocate_cmd_buffer()
    
    In the for statement of lbs_allocate_cmd_buffer(), if the allocation of
    cmdarray[i].cmdbuf fails, both cmdarray and cmdarray[i].cmdbuf needs to
    be freed. Otherwise, there will be memleaks in lbs_allocate_cmd_buffer().
    
    Fixes: 876c9d3aeb98 ("[PATCH] Marvell Libertas 8388 802.11b/g USB driver")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Kalle Valo &lt;kvalo@kernel.org&gt;
    Link: https://msgid.link/20240126075336.2825608-1-alexious@zju.edu.cn

diff --git a/drivers/net/wireless/marvell/libertas/cmd.c b/drivers/net/wireless/marvell/libertas/cmd.c
index 104d2b6dc9af..5a525da434c2 100644
--- a/drivers/net/wireless/marvell/libertas/cmd.c
+++ b/drivers/net/wireless/marvell/libertas/cmd.c
@@ -1132,7 +1132,7 @@ int lbs_allocate_cmd_buffer(struct lbs_private *priv)
 		if (!cmdarray[i].cmdbuf) {
 			lbs_deb_host("ALLOC_CMD_BUF: ptempvirtualaddr is NULL\n");
 			ret = -1;
-			goto done;
+			goto free_cmd_array;
 		}
 	}
 
@@ -1140,8 +1140,17 @@ int lbs_allocate_cmd_buffer(struct lbs_private *priv)
 		init_waitqueue_head(&amp;cmdarray[i].cmdwait_q);
 		lbs_cleanup_and_insert_cmd(priv, &amp;cmdarray[i]);
 	}
-	ret = 0;
+	return 0;
 
+free_cmd_array:
+	for (i = 0; i &lt; LBS_NUM_CMD_BUFFERS; i++) {
+		if (cmdarray[i].cmdbuf) {
+			kfree(cmdarray[i].cmdbuf);
+			cmdarray[i].cmdbuf = NULL;
+		}
+	}
+	kfree(priv-&gt;cmd_array);
+	priv-&gt;cmd_array = NULL;
 done:
 	return ret;
 }</pre><hr><pre>commit 8f94b49a5b5d386c038e355bef6347298aabd211
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Thu Feb 1 20:48:44 2024 +0800

    media: v4l2-mem2mem: fix a memleak in v4l2_m2m_register_entity
    
    The entity-&gt;name (i.e. name) is allocated in v4l2_m2m_register_entity
    but isn't freed in its following error-handling paths. This patch
    adds such deallocation to prevent memleak of entity-&gt;name.
    
    Fixes: be2fff656322 ("media: add helpers for memory-to-memory media controller")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;

diff --git a/drivers/media/v4l2-core/v4l2-mem2mem.c b/drivers/media/v4l2-core/v4l2-mem2mem.c
index 9e983176542b..75517134a5e9 100644
--- a/drivers/media/v4l2-core/v4l2-mem2mem.c
+++ b/drivers/media/v4l2-core/v4l2-mem2mem.c
@@ -1087,11 +1087,17 @@ static int v4l2_m2m_register_entity(struct media_device *mdev,
 	entity-&gt;function = function;
 
 	ret = media_entity_pads_init(entity, num_pads, pads);
-	if (ret)
+	if (ret) {
+		kfree(entity-&gt;name);
+		entity-&gt;name = NULL;
 		return ret;
+	}
 	ret = media_device_register_entity(mdev, entity);
-	if (ret)
+	if (ret) {
+		kfree(entity-&gt;name);
+		entity-&gt;name = NULL;
 		return ret;
+	}
 
 	return 0;
 }</pre><hr><pre>commit 8cf9c5051076e0eb958f4361d50d8b0c3ee6691c
Author: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
Date:   Thu Feb 1 20:47:53 2024 +0800

    media: v4l2-tpg: fix some memleaks in tpg_alloc
    
    In tpg_alloc, resources should be deallocated in each and every
    error-handling paths, since they are allocated in for statements.
    Otherwise there would be memleaks because tpg_free is called only when
    tpg_alloc return 0.
    
    Fixes: 63881df94d3e ("[media] vivid: add the Test Pattern Generator")
    Signed-off-by: Zhipeng Lu &lt;alexious@zju.edu.cn&gt;
    Signed-off-by: Hans Verkuil &lt;hverkuil-cisco@xs4all.nl&gt;

diff --git a/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c b/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
index a366566f22c3..642c48e8c1f5 100644
--- a/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
+++ b/drivers/media/common/v4l2-tpg/v4l2-tpg-core.c
@@ -113,6 +113,7 @@ int tpg_alloc(struct tpg_data *tpg, unsigned max_w)
 {
 	unsigned pat;
 	unsigned plane;
+	int ret = 0;
 
 	tpg-&gt;max_line_width = max_w;
 	for (pat = 0; pat &lt; TPG_MAX_PAT_LINES; pat++) {
@@ -121,14 +122,18 @@ int tpg_alloc(struct tpg_data *tpg, unsigned max_w)
 
 			tpg-&gt;lines[pat][plane] =
 				vzalloc(array3_size(max_w, 2, pixelsz));
-			if (!tpg-&gt;lines[pat][plane])
-				return -ENOMEM;
+			if (!tpg-&gt;lines[pat][plane]) {
+				ret = -ENOMEM;
+				goto free_lines;
+			}
 			if (plane == 0)
 				continue;
 			tpg-&gt;downsampled_lines[pat][plane] =
 				vzalloc(array3_size(max_w, 2, pixelsz));
-			if (!tpg-&gt;downsampled_lines[pat][plane])
-				return -ENOMEM;
+			if (!tpg-&gt;downsampled_lines[pat][plane]) {
+				ret = -ENOMEM;
+				goto free_lines;
+			}
 		}
 	}
 	for (plane = 0; plane &lt; TPG_MAX_PLANES; plane++) {
@@ -136,18 +141,45 @@ int tpg_alloc(struct tpg_data *tpg, unsigned max_w)
 
 		tpg-&gt;contrast_line[plane] =
 			vzalloc(array_size(pixelsz, max_w));
-		if (!tpg-&gt;contrast_line[plane])
-			return -ENOMEM;
+		if (!tpg-&gt;contrast_line[plane]) {
+			ret = -ENOMEM;
+			goto free_contrast_line;
+		}
 		tpg-&gt;black_line[plane] =
 			vzalloc(array_size(pixelsz, max_w));
-		if (!tpg-&gt;black_line[plane])
-			return -ENOMEM;
+		if (!tpg-&gt;black_line[plane]) {
+			ret = -ENOMEM;
+			goto free_contrast_line;
+		}
 		tpg-&gt;random_line[plane] =
 			vzalloc(array3_size(max_w, 2, pixelsz));
-		if (!tpg-&gt;random_line[plane])
-			return -ENOMEM;
+		if (!tpg-&gt;random_line[plane]) {
+			ret = -ENOMEM;
+			goto free_contrast_line;
+		}
 	}
 	return 0;
+
+free_contrast_line:
+	for (plane = 0; plane &lt; TPG_MAX_PLANES; plane++) {
+		vfree(tpg-&gt;contrast_line[plane]);
+		vfree(tpg-&gt;black_line[plane]);
+		vfree(tpg-&gt;random_line[plane]);
+		tpg-&gt;contrast_line[plane] = NULL;
+		tpg-&gt;black_line[plane] = NULL;
+		tpg-&gt;random_line[plane] = NULL;
+	}
+free_lines:
+	for (pat = 0; pat &lt; TPG_MAX_PAT_LINES; pat++)
+		for (plane = 0; plane &lt; TPG_MAX_PLANES; plane++) {
+			vfree(tpg-&gt;lines[pat][plane]);
+			tpg-&gt;lines[pat][plane] = NULL;
+			if (plane == 0)
+				continue;
+			vfree(tpg-&gt;downsampled_lines[pat][plane]);
+			tpg-&gt;downsampled_lines[pat][plane] = NULL;
+		}
+	return ret;
 }
 EXPORT_SYMBOL_GPL(tpg_alloc);
 </pre>
    <div class="pagination">
        <a href='6_2.html'>&lt;&lt;Prev</a><a href='6.html'>1</a><a href='6_2.html'>2</a><span>[3]</span><a href='6_4.html'>4</a><a href='6_5.html'>5</a><a href='6_6.html'>6</a><a href='6_7.html'>7</a><a href='6_8.html'>8</a><a href='6_9.html'>9</a><a href='6_10.html'>10</a><a href='6_11.html'>11</a><a href='6_12.html'>12</a><a href='6_13.html'>13</a><a href='6_14.html'>14</a><a href='6_15.html'>15</a><a href='6_16.html'>16</a><a href='6_17.html'>17</a><a href='6_18.html'>18</a><a href='6_19.html'>19</a><a href='6_20.html'>20</a><a href='6_21.html'>21</a><a href='6_22.html'>22</a><a href='6_23.html'>23</a><a href='6_24.html'>24</a><a href='6_25.html'>25</a><a href='6_26.html'>26</a><a href='6_27.html'>27</a><a href='6_28.html'>28</a><a href='6_29.html'>29</a><a href='6_30.html'>30</a><a href='6_31.html'>31</a><a href='6_32.html'>32</a><a href='6_33.html'>33</a><a href='6_34.html'>34</a><a href='6_35.html'>35</a><a href='6_36.html'>36</a><a href='6_4.html'>Next&gt;&gt;</a>
    <div>
</body>
