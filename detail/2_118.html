<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_117.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><span>[118]</span><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_119.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit d5477c11111467e19787f00d3cab20fb48c2699e
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 10 11:56:26 2006 -0400

    usbcore: fix endpoint device creation
    
    This patch (as800) straightens out the USB endpoint class device
    creation routine, fixing a refcount bug in the process.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/endpoint.c b/drivers/usb/core/endpoint.c
index 40ba76a17571..3b2d137912be 100644
--- a/drivers/usb/core/endpoint.c
+++ b/drivers/usb/core/endpoint.c
@@ -223,7 +223,7 @@ int usb_create_ep_files(struct device *parent,
 	ep_dev = kzalloc(sizeof(*ep_dev), GFP_KERNEL);
 	if (!ep_dev) {
 		retval = -ENOMEM;
-		goto exit;
+		goto error_alloc;
 	}
 
 	/* fun calculation to determine the minor of this endpoint */
@@ -241,33 +241,31 @@ int usb_create_ep_files(struct device *parent,
 
 	retval = device_register(&amp;ep_dev-&gt;dev);
 	if (retval)
-		goto error;
+		goto error_register;
 	retval = sysfs_create_group(&amp;ep_dev-&gt;dev.kobj, &amp;ep_dev_attr_grp);
 	if (retval)
 		goto error_group;
 
-	endpoint-&gt;ep_dev = ep_dev;
-
 	/* create the symlink to the old-style "ep_XX" directory */
 	sprintf(name, "ep_%02x", endpoint-&gt;desc.bEndpointAddress);
-	retval = sysfs_create_link(&amp;parent-&gt;kobj,
-				   &amp;endpoint-&gt;ep_dev-&gt;dev.kobj, name);
+	retval = sysfs_create_link(&amp;parent-&gt;kobj, &amp;ep_dev-&gt;dev.kobj, name);
 	if (retval)
 		goto error_link;
-exit:
+	endpoint-&gt;ep_dev = ep_dev;
 	return retval;
 
 error_link:
 	sysfs_remove_group(&amp;ep_dev-&gt;dev.kobj, &amp;ep_dev_attr_grp);
-
 error_group:
 	device_unregister(&amp;ep_dev-&gt;dev);
-	endpoint-&gt;ep_dev = NULL;
 	destroy_endpoint_class();
 	return retval;
-error:
+
+error_register:
 	kfree(ep_dev);
+error_alloc:
 	destroy_endpoint_class();
+exit:
 	return retval;
 }
 </pre><hr><pre>commit c40fd5ea565587c05b0e2c49c02cad2c35fd85c6
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 10 11:55:47 2006 -0400

    usbcore: fix refcount bug in endpoint removal
    
    This patch (as799) fixes a nasty refcount error in the USB endpoint class.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/endpoint.c b/drivers/usb/core/endpoint.c
index 3ebb90149e93..40ba76a17571 100644
--- a/drivers/usb/core/endpoint.c
+++ b/drivers/usb/core/endpoint.c
@@ -282,8 +282,6 @@ void usb_remove_ep_files(struct usb_host_endpoint *endpoint)
 		sysfs_remove_group(&amp;endpoint-&gt;ep_dev-&gt;dev.kobj, &amp;ep_dev_attr_grp);
 		device_unregister(&amp;endpoint-&gt;ep_dev-&gt;dev);
 		endpoint-&gt;ep_dev = NULL;
+		destroy_endpoint_class();
 	}
-	destroy_endpoint_class();
 }
-
-</pre><hr><pre>commit b62df4516981745d4b5de01ceec1d65a9174a524
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Oct 10 10:54:00 2006 -0400

    UHCI: workaround for Asus motherboard
    
    This patch (as798) adds a workaround to uhci-hcd.  At least one Asus
    motherboard is wired in such a way that any device attached to a
    suspended UHCI controller will prevent the system from entering
    suspend-to-RAM by immediately waking it up.  The only way around the
    problem is to turn the controller off instead of suspending it.
    
    This fixes Bugzilla #6193.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/uhci-hcd.c b/drivers/usb/host/uhci-hcd.c
index 45ee6920a850..226bf3de8edd 100644
--- a/drivers/usb/host/uhci-hcd.c
+++ b/drivers/usb/host/uhci-hcd.c
@@ -40,6 +40,7 @@
 #include &lt;linux/dma-mapping.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/bitops.h&gt;
+#include &lt;linux/dmi.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/io.h&gt;
@@ -196,12 +197,42 @@ static int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)
 	return 0;
 }
 
+static int remote_wakeup_is_broken(struct uhci_hcd *uhci)
+{
+	static struct dmi_system_id broken_wakeup_table[] = {
+		{
+			.ident = "Asus A7V8X",
+			.matches = {
+				DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK"),
+				DMI_MATCH(DMI_BOARD_NAME, "A7V8X"),
+				DMI_MATCH(DMI_BOARD_VERSION, "REV 1.xx"),
+			}
+		},
+		{ }
+	};
+	int port;
+
+	/* One of Asus's motherboards has a bug which causes it to
+	 * wake up immediately from suspend-to-RAM if any of the ports
+	 * are connected.  In such cases we will not set EGSM.
+	 */
+	if (dmi_check_system(broken_wakeup_table)) {
+		for (port = 0; port &lt; uhci-&gt;rh_numports; ++port) {
+			if (inw(uhci-&gt;io_addr + USBPORTSC1 + port * 2) &amp;
+					USBPORTSC_CCS)
+				return 1;
+		}
+	}
+
+	return 0;
+}
+
 static void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state)
 __releases(uhci-&gt;lock)
 __acquires(uhci-&gt;lock)
 {
 	int auto_stop;
-	int int_enable;
+	int int_enable, egsm_enable;
 
 	auto_stop = (new_state == UHCI_RH_AUTO_STOPPED);
 	dev_dbg(&amp;uhci_to_hcd(uhci)-&gt;self.root_hub-&gt;dev,
@@ -217,15 +248,18 @@ __acquires(uhci-&gt;lock)
 	}
 
 	/* Enable resume-detect interrupts if they work.
-	 * Then enter Global Suspend mode, still configured.
+	 * Then enter Global Suspend mode if _it_ works, still configured.
 	 */
+	egsm_enable = USBCMD_EGSM;
 	uhci-&gt;working_RD = 1;
 	int_enable = USBINTR_RESUME;
-	if (resume_detect_interrupts_are_broken(uhci)) {
+	if (remote_wakeup_is_broken(uhci))
+		egsm_enable = 0;
+	if (resume_detect_interrupts_are_broken(uhci) || !egsm_enable)
 		uhci-&gt;working_RD = int_enable = 0;
-	}
+
 	outw(int_enable, uhci-&gt;io_addr + USBINTR);
-	outw(USBCMD_EGSM | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
+	outw(egsm_enable | USBCMD_CF, uhci-&gt;io_addr + USBCMD);
 	mb();
 	udelay(5);
 </pre><hr><pre>commit e4a20daa7b44ab9805979eb716f6bb7532bc67b9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 4 16:31:15 2006 -0400

    USB: unusual_devs entry for Nokia 6131
    
    This patch (as796) adds an unusual_devs entry for the Nokia 6131, which
    doesn't like large transfer sizes.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index c9a8d50106d1..0a846e4a101e 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -182,6 +182,13 @@ UNUSUAL_DEV(  0x0421, 0x044e, 0x0100, 0x0100,
 		US_SC_DEVICE, US_PR_DEVICE, NULL,
 		US_FL_IGNORE_RESIDUE | US_FL_FIX_CAPACITY ),
 
+/* Reported by Bardur Arantsson &lt;bardur@scientician.net&gt; */
+UNUSUAL_DEV(  0x0421, 0x047c, 0x0370, 0x0370,
+		"Nokia",
+		"6131",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_MAX_SECTORS_64 ),
+
 /* Reported by Olaf Hering &lt;olh@suse.de&gt; from novell bug #105878 */
 UNUSUAL_DEV(  0x0424, 0x0fdc, 0x0210, 0x0210,
 		"SMSC",</pre><hr><pre>commit b4dfdbb3c707474a2254c5b4d7e62be31a4b7da9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 4 02:17:06 2006 -0700

    [PATCH] cpufreq: make the transition_notifier chain use SRCU
    
    This patch (as762) changes the cpufreq_transition_notifier_list from a
    blocking_notifier_head to an srcu_notifier_head.  This will prevent errors
    caused attempting to call down_read() to access the notifier chain at a
    time when interrupts must remain disabled, during system suspend.
    
    It's not clear to me whether this is really necessary; perhaps the chain
    could be made into an atomic_notifier.  However a couple of the callout
    routines do use blocking operations, so this approach seems safer.
    
    The head of the notifier chain needs to be initialized before use; this is
    done by an __init routine at core_initcall time.  If this turns out not to
    be a good choice, it can easily be changed.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Cc: "Paul E. McKenney" &lt;paulmck@us.ibm.com&gt;
    Cc: Jesse Brandeburg &lt;jesse.brandeburg@gmail.com&gt;
    Cc: Dave Jones &lt;davej@codemonkey.org.uk&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 2caaf71d80c8..86e69b7f9122 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -52,8 +52,14 @@ static void handle_update(void *data);
  * The mutex locks both lists.
  */
 static BLOCKING_NOTIFIER_HEAD(cpufreq_policy_notifier_list);
-static BLOCKING_NOTIFIER_HEAD(cpufreq_transition_notifier_list);
+static struct srcu_notifier_head cpufreq_transition_notifier_list;
 
+static int __init init_cpufreq_transition_notifier_list(void)
+{
+	srcu_init_notifier_head(&amp;cpufreq_transition_notifier_list);
+	return 0;
+}
+core_initcall(init_cpufreq_transition_notifier_list);
 
 static LIST_HEAD(cpufreq_governor_list);
 static DEFINE_MUTEX (cpufreq_governor_mutex);
@@ -262,14 +268,14 @@ void cpufreq_notify_transition(struct cpufreq_freqs *freqs, unsigned int state)
 				freqs-&gt;old = policy-&gt;cur;
 			}
 		}
-		blocking_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
 				CPUFREQ_PRECHANGE, freqs);
 		adjust_jiffies(CPUFREQ_PRECHANGE, freqs);
 		break;
 
 	case CPUFREQ_POSTCHANGE:
 		adjust_jiffies(CPUFREQ_POSTCHANGE, freqs);
-		blocking_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
 				CPUFREQ_POSTCHANGE, freqs);
 		if (likely(policy) &amp;&amp; likely(policy-&gt;cpu == freqs-&gt;cpu))
 			policy-&gt;cur = freqs-&gt;new;
@@ -1049,7 +1055,7 @@ static int cpufreq_suspend(struct sys_device * sysdev, pm_message_t pmsg)
 		freqs.old = cpu_policy-&gt;cur;
 		freqs.new = cur_freq;
 
-		blocking_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,
 				    CPUFREQ_SUSPENDCHANGE, &amp;freqs);
 		adjust_jiffies(CPUFREQ_SUSPENDCHANGE, &amp;freqs);
 
@@ -1130,7 +1136,7 @@ static int cpufreq_resume(struct sys_device * sysdev)
 			freqs.old = cpu_policy-&gt;cur;
 			freqs.new = cur_freq;
 
-			blocking_notifier_call_chain(
+			srcu_notifier_call_chain(
 					&amp;cpufreq_transition_notifier_list,
 					CPUFREQ_RESUMECHANGE, &amp;freqs);
 			adjust_jiffies(CPUFREQ_RESUMECHANGE, &amp;freqs);
@@ -1176,7 +1182,7 @@ int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)
 
 	switch (list) {
 	case CPUFREQ_TRANSITION_NOTIFIER:
-		ret = blocking_notifier_chain_register(
+		ret = srcu_notifier_chain_register(
 				&amp;cpufreq_transition_notifier_list, nb);
 		break;
 	case CPUFREQ_POLICY_NOTIFIER:
@@ -1208,7 +1214,7 @@ int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list)
 
 	switch (list) {
 	case CPUFREQ_TRANSITION_NOTIFIER:
-		ret = blocking_notifier_chain_unregister(
+		ret = srcu_notifier_chain_unregister(
 				&amp;cpufreq_transition_notifier_list, nb);
 		break;
 	case CPUFREQ_POLICY_NOTIFIER:</pre><hr><pre>commit e6a92013ba458804161c0c5b6d134d82204dc233
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 4 02:17:05 2006 -0700

    [PATCH] SRCU: report out-of-memory errors
    
    Currently the init_srcu_struct() routine has no way to report out-of-memory
    errors.  This patch (as761) makes it return -ENOMEM when the per-cpu data
    allocation fails.
    
    The patch also makes srcu_init_notifier_head() report a BUG if a notifier
    head can't be initialized.  Perhaps it should return -ENOMEM instead, but
    in the most likely cases where this might occur I don't think any recovery
    is possible.  Notifier chains generally are not created dynamically.
    
    [akpm@osdl.org: avoid statement-with-side-effect in macro]
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Paul E. McKenney &lt;paulmck@us.ibm.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/include/linux/srcu.h b/include/linux/srcu.h
index 8a45367b5f3a..aca0eee53930 100644
--- a/include/linux/srcu.h
+++ b/include/linux/srcu.h
@@ -43,7 +43,7 @@ struct srcu_struct {
 #define srcu_barrier()
 #endif /* #else #ifndef CONFIG_PREEMPT */
 
-void init_srcu_struct(struct srcu_struct *sp);
+int init_srcu_struct(struct srcu_struct *sp);
 void cleanup_srcu_struct(struct srcu_struct *sp);
 int srcu_read_lock(struct srcu_struct *sp) __acquires(sp);
 void srcu_read_unlock(struct srcu_struct *sp, int idx) __releases(sp);
diff --git a/kernel/srcu.c b/kernel/srcu.c
index 7e1979f624ba..3507cabe963b 100644
--- a/kernel/srcu.c
+++ b/kernel/srcu.c
@@ -42,11 +42,12 @@
  * to any other function.  Each srcu_struct represents a separate domain
  * of SRCU protection.
  */
-void init_srcu_struct(struct srcu_struct *sp)
+int init_srcu_struct(struct srcu_struct *sp)
 {
 	sp-&gt;completed = 0;
-	sp-&gt;per_cpu_ref = alloc_percpu(struct srcu_struct_array);
 	mutex_init(&amp;sp-&gt;mutex);
+	sp-&gt;per_cpu_ref = alloc_percpu(struct srcu_struct_array);
+	return (sp-&gt;per_cpu_ref ? 0 : -ENOMEM);
 }
 
 /*
diff --git a/kernel/sys.c b/kernel/sys.c
index fd5c71006775..98489d82801b 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -517,7 +517,8 @@ EXPORT_SYMBOL_GPL(srcu_notifier_call_chain);
 void srcu_init_notifier_head(struct srcu_notifier_head *nh)
 {
 	mutex_init(&amp;nh-&gt;mutex);
-	init_srcu_struct(&amp;nh-&gt;srcu);
+	if (init_srcu_struct(&amp;nh-&gt;srcu) &lt; 0)
+		BUG();
 	nh-&gt;head = NULL;
 }
 </pre><hr><pre>commit eabc069401bcf45bcc3f19e643017bf761780aa8
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Oct 4 02:17:04 2006 -0700

    [PATCH] Add SRCU-based notifier chains
    
    This patch (as751) adds a new type of notifier chain, based on the SRCU
    (Sleepable Read-Copy Update) primitives recently added to the kernel.  An
    SRCU notifier chain is much like a blocking notifier chain, in that it must
    be called in process context and its callout routines are allowed to sleep.
     The difference is that the chain's links are protected by the SRCU
    mechanism rather than by an rw-semaphore, so calling the chain has
    extremely low overhead: no memory barriers and no cache-line bouncing.  On
    the other hand, unregistering from the chain is expensive and the chain
    head requires special runtime initialization (plus cleanup if it is to be
    deallocated).
    
    SRCU notifiers are appropriate for notifiers that will be called very
    frequently and for which unregistration occurs very seldom.  The proposed
    "task notifier" scheme qualifies, as may some of the network notifiers.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Acked-by: Paul E. McKenney &lt;paulmck@us.ibm.com&gt;
    Acked-by: Chandra Seetharaman &lt;sekharan@us.ibm.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/include/linux/notifier.h b/include/linux/notifier.h
index 7ff386a6ae87..10a43ed0527e 100644
--- a/include/linux/notifier.h
+++ b/include/linux/notifier.h
@@ -12,9 +12,10 @@
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/rwsem.h&gt;
+#include &lt;linux/srcu.h&gt;
 
 /*
- * Notifier chains are of three types:
+ * Notifier chains are of four types:
  *
  *	Atomic notifier chains: Chain callbacks run in interrupt/atomic
  *		context. Callouts are not allowed to block.
@@ -23,13 +24,27 @@
  *	Raw notifier chains: There are no restrictions on callbacks,
  *		registration, or unregistration.  All locking and protection
  *		must be provided by the caller.
+ *	SRCU notifier chains: A variant of blocking notifier chains, with
+ *		the same restrictions.
  *
  * atomic_notifier_chain_register() may be called from an atomic context,
- * but blocking_notifier_chain_register() must be called from a process
- * context.  Ditto for the corresponding _unregister() routines.
+ * but blocking_notifier_chain_register() and srcu_notifier_chain_register()
+ * must be called from a process context.  Ditto for the corresponding
+ * _unregister() routines.
  *
- * atomic_notifier_chain_unregister() and blocking_notifier_chain_unregister()
- * _must not_ be called from within the call chain.
+ * atomic_notifier_chain_unregister(), blocking_notifier_chain_unregister(),
+ * and srcu_notifier_chain_unregister() _must not_ be called from within
+ * the call chain.
+ *
+ * SRCU notifier chains are an alternative form of blocking notifier chains.
+ * They use SRCU (Sleepable Read-Copy Update) instead of rw-semaphores for
+ * protection of the chain links.  This means there is _very_ low overhead
+ * in srcu_notifier_call_chain(): no cache bounces and no memory barriers.
+ * As compensation, srcu_notifier_chain_unregister() is rather expensive.
+ * SRCU notifier chains should be used when the chain will be called very
+ * often but notifier_blocks will seldom be removed.  Also, SRCU notifier
+ * chains are slightly more difficult to use because they require special
+ * runtime initialization.
  */
 
 struct notifier_block {
@@ -52,6 +67,12 @@ struct raw_notifier_head {
 	struct notifier_block *head;
 };
 
+struct srcu_notifier_head {
+	struct mutex mutex;
+	struct srcu_struct srcu;
+	struct notifier_block *head;
+};
+
 #define ATOMIC_INIT_NOTIFIER_HEAD(name) do {	\
 		spin_lock_init(&amp;(name)-&gt;lock);	\
 		(name)-&gt;head = NULL;		\
@@ -64,6 +85,11 @@ struct raw_notifier_head {
 		(name)-&gt;head = NULL;		\
 	} while (0)
 
+/* srcu_notifier_heads must be initialized and cleaned up dynamically */
+extern void srcu_init_notifier_head(struct srcu_notifier_head *nh);
+#define srcu_cleanup_notifier_head(name)	\
+		cleanup_srcu_struct(&amp;(name)-&gt;srcu);
+
 #define ATOMIC_NOTIFIER_INIT(name) {				\
 		.lock = __SPIN_LOCK_UNLOCKED(name.lock),	\
 		.head = NULL }
@@ -72,6 +98,7 @@ struct raw_notifier_head {
 		.head = NULL }
 #define RAW_NOTIFIER_INIT(name)	{				\
 		.head = NULL }
+/* srcu_notifier_heads cannot be initialized statically */
 
 #define ATOMIC_NOTIFIER_HEAD(name)				\
 	struct atomic_notifier_head name =			\
@@ -91,6 +118,8 @@ extern int blocking_notifier_chain_register(struct blocking_notifier_head *,
 		struct notifier_block *);
 extern int raw_notifier_chain_register(struct raw_notifier_head *,
 		struct notifier_block *);
+extern int srcu_notifier_chain_register(struct srcu_notifier_head *,
+		struct notifier_block *);
 
 extern int atomic_notifier_chain_unregister(struct atomic_notifier_head *,
 		struct notifier_block *);
@@ -98,6 +127,8 @@ extern int blocking_notifier_chain_unregister(struct blocking_notifier_head *,
 		struct notifier_block *);
 extern int raw_notifier_chain_unregister(struct raw_notifier_head *,
 		struct notifier_block *);
+extern int srcu_notifier_chain_unregister(struct srcu_notifier_head *,
+		struct notifier_block *);
 
 extern int atomic_notifier_call_chain(struct atomic_notifier_head *,
 		unsigned long val, void *v);
@@ -105,6 +136,8 @@ extern int blocking_notifier_call_chain(struct blocking_notifier_head *,
 		unsigned long val, void *v);
 extern int raw_notifier_call_chain(struct raw_notifier_head *,
 		unsigned long val, void *v);
+extern int srcu_notifier_call_chain(struct srcu_notifier_head *,
+		unsigned long val, void *v);
 
 #define NOTIFY_DONE		0x0000		/* Don't care */
 #define NOTIFY_OK		0x0001		/* Suits me */
diff --git a/include/linux/srcu.h b/include/linux/srcu.h
index 947fdab2ddb0..8a45367b5f3a 100644
--- a/include/linux/srcu.h
+++ b/include/linux/srcu.h
@@ -24,6 +24,9 @@
  *
  */
 
+#ifndef _LINUX_SRCU_H
+#define _LINUX_SRCU_H
+
 struct srcu_struct_array {
 	int c[2];
 };
@@ -46,4 +49,5 @@ int srcu_read_lock(struct srcu_struct *sp) __acquires(sp);
 void srcu_read_unlock(struct srcu_struct *sp, int idx) __releases(sp);
 void synchronize_srcu(struct srcu_struct *sp);
 long srcu_batches_completed(struct srcu_struct *sp);
-void cleanup_srcu_struct(struct srcu_struct *sp);
+
+#endif
diff --git a/kernel/sys.c b/kernel/sys.c
index 2314867ae34f..fd5c71006775 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -153,7 +153,7 @@ static int __kprobes notifier_call_chain(struct notifier_block **nl,
 
 /*
  *	Atomic notifier chain routines.  Registration and unregistration
- *	use a mutex, and call_chain is synchronized by RCU (no locks).
+ *	use a spinlock, and call_chain is synchronized by RCU (no locks).
  */
 
 /**
@@ -401,6 +401,128 @@ int raw_notifier_call_chain(struct raw_notifier_head *nh,
 
 EXPORT_SYMBOL_GPL(raw_notifier_call_chain);
 
+/*
+ *	SRCU notifier chain routines.    Registration and unregistration
+ *	use a mutex, and call_chain is synchronized by SRCU (no locks).
+ */
+
+/**
+ *	srcu_notifier_chain_register - Add notifier to an SRCU notifier chain
+ *	@nh: Pointer to head of the SRCU notifier chain
+ *	@n: New entry in notifier chain
+ *
+ *	Adds a notifier to an SRCU notifier chain.
+ *	Must be called in process context.
+ *
+ *	Currently always returns zero.
+ */
+
+int srcu_notifier_chain_register(struct srcu_notifier_head *nh,
+		struct notifier_block *n)
+{
+	int ret;
+
+	/*
+	 * This code gets used during boot-up, when task switching is
+	 * not yet working and interrupts must remain disabled.  At
+	 * such times we must not call mutex_lock().
+	 */
+	if (unlikely(system_state == SYSTEM_BOOTING))
+		return notifier_chain_register(&amp;nh-&gt;head, n);
+
+	mutex_lock(&amp;nh-&gt;mutex);
+	ret = notifier_chain_register(&amp;nh-&gt;head, n);
+	mutex_unlock(&amp;nh-&gt;mutex);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(srcu_notifier_chain_register);
+
+/**
+ *	srcu_notifier_chain_unregister - Remove notifier from an SRCU notifier chain
+ *	@nh: Pointer to head of the SRCU notifier chain
+ *	@n: Entry to remove from notifier chain
+ *
+ *	Removes a notifier from an SRCU notifier chain.
+ *	Must be called from process context.
+ *
+ *	Returns zero on success or %-ENOENT on failure.
+ */
+int srcu_notifier_chain_unregister(struct srcu_notifier_head *nh,
+		struct notifier_block *n)
+{
+	int ret;
+
+	/*
+	 * This code gets used during boot-up, when task switching is
+	 * not yet working and interrupts must remain disabled.  At
+	 * such times we must not call mutex_lock().
+	 */
+	if (unlikely(system_state == SYSTEM_BOOTING))
+		return notifier_chain_unregister(&amp;nh-&gt;head, n);
+
+	mutex_lock(&amp;nh-&gt;mutex);
+	ret = notifier_chain_unregister(&amp;nh-&gt;head, n);
+	mutex_unlock(&amp;nh-&gt;mutex);
+	synchronize_srcu(&amp;nh-&gt;srcu);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(srcu_notifier_chain_unregister);
+
+/**
+ *	srcu_notifier_call_chain - Call functions in an SRCU notifier chain
+ *	@nh: Pointer to head of the SRCU notifier chain
+ *	@val: Value passed unmodified to notifier function
+ *	@v: Pointer passed unmodified to notifier function
+ *
+ *	Calls each function in a notifier chain in turn.  The functions
+ *	run in a process context, so they are allowed to block.
+ *
+ *	If the return value of the notifier can be and'ed
+ *	with %NOTIFY_STOP_MASK then srcu_notifier_call_chain
+ *	will return immediately, with the return value of
+ *	the notifier function which halted execution.
+ *	Otherwise the return value is the return value
+ *	of the last notifier function called.
+ */
+
+int srcu_notifier_call_chain(struct srcu_notifier_head *nh,
+		unsigned long val, void *v)
+{
+	int ret;
+	int idx;
+
+	idx = srcu_read_lock(&amp;nh-&gt;srcu);
+	ret = notifier_call_chain(&amp;nh-&gt;head, val, v);
+	srcu_read_unlock(&amp;nh-&gt;srcu, idx);
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(srcu_notifier_call_chain);
+
+/**
+ *	srcu_init_notifier_head - Initialize an SRCU notifier head
+ *	@nh: Pointer to head of the srcu notifier chain
+ *
+ *	Unlike other sorts of notifier heads, SRCU notifier heads require
+ *	dynamic initialization.  Be sure to call this routine before
+ *	calling any of the other SRCU notifier routines for this head.
+ *
+ *	If an SRCU notifier head is deallocated, it must first be cleaned
+ *	up by calling srcu_cleanup_notifier_head().  Otherwise the head's
+ *	per-cpu data (used by the SRCU mechanism) will leak.
+ */
+
+void srcu_init_notifier_head(struct srcu_notifier_head *nh)
+{
+	mutex_init(&amp;nh-&gt;mutex);
+	init_srcu_struct(&amp;nh-&gt;srcu);
+	nh-&gt;head = NULL;
+}
+
+EXPORT_SYMBOL_GPL(srcu_init_notifier_head);
+
 /**
  *	register_reboot_notifier - Register function to be called at reboot time
  *	@nb: Info about notifier function to be called</pre><hr><pre>commit c16a02d6f5fcfe05dc6fd40aa80a8e1d055300db
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Sep 29 02:01:21 2006 -0700

    [PATCH] Add section on function return values to CodingStyle
    
    This patch (as776) adds a new chapter to Documentation/CodingStyle,
    explaining the circumstances under which a function should return 0 for
    failure and non-zero for success as opposed to a negative error code for
    failure and 0 for success.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/Documentation/CodingStyle b/Documentation/CodingStyle
index 6d2412ec91ed..29c18966b050 100644
--- a/Documentation/CodingStyle
+++ b/Documentation/CodingStyle
@@ -532,6 +532,40 @@ appears outweighs the potential value of the hint that tells gcc to do
 something it would have done anyway.
 
 
+		Chapter 16: Function return values and names
+
+Functions can return values of many different kinds, and one of the
+most common is a value indicating whether the function succeeded or
+failed.  Such a value can be represented as an error-code integer
+(-Exxx = failure, 0 = success) or a "succeeded" boolean (0 = failure,
+non-zero = success).
+
+Mixing up these two sorts of representations is a fertile source of
+difficult-to-find bugs.  If the C language included a strong distinction
+between integers and booleans then the compiler would find these mistakes
+for us... but it doesn't.  To help prevent such bugs, always follow this
+convention:
+
+	If the name of a function is an action or an imperative command,
+	the function should return an error-code integer.  If the name
+	is a predicate, the function should return a "succeeded" boolean.
+
+For example, "add work" is a command, and the add_work() function returns 0
+for success or -EBUSY for failure.  In the same way, "PCI device present" is
+a predicate, and the pci_dev_present() function returns 1 if it succeeds in
+finding a matching device or 0 if it doesn't.
+
+All EXPORTed functions must respect this convention, and so should all
+public functions.  Private (static) functions need not, but it is
+recommended that they do.
+
+Functions whose return value is the actual result of a computation, rather
+than an indication of whether the computation succeeded, are not subject to
+this rule.  Generally they indicate failure by returning some out-of-range
+result.  Typical examples would be functions that return pointers; they use
+NULL or the ERR_PTR mechanism to report failure.
+
+
 
 		Appendix I: References
 </pre><hr><pre>commit 6174d0fd35f486f59b743630bdf088a9f9792d4d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 14:51:48 2006 -0400

    USB: g_file_storage: Set sense info Valid bit only when needed
    
    Strictly speaking, the Valid bit in SCSI sense data is supposed to
    be set only when the Information field contains a valid number.  This
    patch (as793) turns off the Valid bit when the Information field
    hasn't been set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/gadget/file_storage.c b/drivers/usb/gadget/file_storage.c
index d472c9c29904..c83d3b6c68f2 100644
--- a/drivers/usb/gadget/file_storage.c
+++ b/drivers/usb/gadget/file_storage.c
@@ -567,6 +567,7 @@ struct lun {
 	unsigned int	ro : 1;
 	unsigned int	prevent_medium_removal : 1;
 	unsigned int	registered : 1;
+	unsigned int	info_valid : 1;
 
 	u32		sense_data;
 	u32		sense_data_info;
@@ -1656,6 +1657,7 @@ static int do_read(struct fsg_dev *fsg)
 			curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			bh-&gt;inreq-&gt;length = 0;
 			bh-&gt;state = BUF_STATE_FULL;
 			break;
@@ -1691,6 +1693,7 @@ static int do_read(struct fsg_dev *fsg)
 		if (nread &lt; amount) {
 			curlun-&gt;sense_data = SS_UNRECOVERED_READ_ERROR;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			break;
 		}
 
@@ -1785,6 +1788,7 @@ static int do_write(struct fsg_dev *fsg)
 				curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 				curlun-&gt;sense_data_info = usb_offset &gt;&gt; 9;
+				curlun-&gt;info_valid = 1;
 				continue;
 			}
 			amount -= (amount &amp; 511);
@@ -1827,6 +1831,7 @@ static int do_write(struct fsg_dev *fsg)
 			if (bh-&gt;outreq-&gt;status != 0) {
 				curlun-&gt;sense_data = SS_COMMUNICATION_FAILURE;
 				curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+				curlun-&gt;info_valid = 1;
 				break;
 			}
 
@@ -1868,6 +1873,7 @@ static int do_write(struct fsg_dev *fsg)
 			if (nwritten &lt; amount) {
 				curlun-&gt;sense_data = SS_WRITE_ERROR;
 				curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+				curlun-&gt;info_valid = 1;
 				break;
 			}
 
@@ -2010,6 +2016,7 @@ static int do_verify(struct fsg_dev *fsg)
 			curlun-&gt;sense_data =
 					SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			break;
 		}
 
@@ -2036,6 +2043,7 @@ static int do_verify(struct fsg_dev *fsg)
 		if (nread == 0) {
 			curlun-&gt;sense_data = SS_UNRECOVERED_READ_ERROR;
 			curlun-&gt;sense_data_info = file_offset &gt;&gt; 9;
+			curlun-&gt;info_valid = 1;
 			break;
 		}
 		file_offset += nread;
@@ -2079,6 +2087,7 @@ static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 	struct lun	*curlun = fsg-&gt;curlun;
 	u8		*buf = (u8 *) bh-&gt;buf;
 	u32		sd, sdinfo;
+	int		valid;
 
 	/*
 	 * From the SCSI-2 spec., section 7.9 (Unit attention condition):
@@ -2106,15 +2115,18 @@ static int do_request_sense(struct fsg_dev *fsg, struct fsg_buffhd *bh)
 		fsg-&gt;bad_lun_okay = 1;
 		sd = SS_LOGICAL_UNIT_NOT_SUPPORTED;
 		sdinfo = 0;
+		valid = 0;
 	} else {
 		sd = curlun-&gt;sense_data;
 		sdinfo = curlun-&gt;sense_data_info;
+		valid = curlun-&gt;info_valid &lt;&lt; 7;
 		curlun-&gt;sense_data = SS_NO_SENSE;
 		curlun-&gt;sense_data_info = 0;
+		curlun-&gt;info_valid = 0;
 	}
 
 	memset(buf, 0, 18);
-	buf[0] = 0x80 | 0x70;			// Valid, current error
+	buf[0] = valid | 0x70;			// Valid, current error
 	buf[2] = SK(sd);
 	put_be32(&amp;buf[3], sdinfo);		// Sense information
 	buf[7] = 18 - 8;			// Additional sense length
@@ -2703,6 +2715,7 @@ static int check_command(struct fsg_dev *fsg, int cmnd_size,
 		if (fsg-&gt;cmnd[0] != SC_REQUEST_SENSE) {
 			curlun-&gt;sense_data = SS_NO_SENSE;
 			curlun-&gt;sense_data_info = 0;
+			curlun-&gt;info_valid = 0;
 		}
 	} else {
 		fsg-&gt;curlun = curlun = NULL;
@@ -3332,6 +3345,7 @@ static void handle_exception(struct fsg_dev *fsg)
 			curlun-&gt;sense_data = curlun-&gt;unit_attention_data =
 					SS_NO_SENSE;
 			curlun-&gt;sense_data_info = 0;
+			curlun-&gt;info_valid = 0;
 		}
 		fsg-&gt;state = FSG_STATE_IDLE;
 	}</pre><hr><pre>commit e0318ebff4d96131bb3524308b845f642e64df81
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Tue Sep 26 14:50:20 2006 -0400

    USB: fix autosuspend when CONFIG_PM isn't set
    
    This patch (as791b) fixes things up to avoid compiler warnings or
    errors when CONFIG_USB_SUSPEND or CONFIG_PM isn't set.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ee18d187ca17..113e484c763e 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -303,11 +303,11 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	dev-&gt;driver = &amp;driver-&gt;drvwrap.driver;
 	usb_set_intfdata(iface, priv);
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
 	iface-&gt;pm_usage_cnt = !(driver-&gt;supports_autosuspend);
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()
@@ -356,11 +356,11 @@ void usb_driver_release_interface(struct usb_driver *driver,
 	dev-&gt;driver = NULL;
 	usb_set_intfdata(iface, NULL);
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	iface-&gt;condition = USB_INTERFACE_UNBOUND;
 	mark_quiesced(iface);
 	iface-&gt;needs_remote_wakeup = 0;
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 }
 EXPORT_SYMBOL(usb_driver_release_interface);
 
@@ -789,7 +789,7 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
 
 #ifdef CONFIG_PM
 
-/* Caller has locked udev-&gt;pm_mutex */
+/* Caller has locked udev's pm_mutex */
 static int suspend_device(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_device_driver	*udriver;
@@ -816,7 +816,7 @@ static int suspend_device(struct usb_device *udev, pm_message_t msg)
 	return status;
 }
 
-/* Caller has locked udev-&gt;pm_mutex */
+/* Caller has locked udev's pm_mutex */
 static int resume_device(struct usb_device *udev)
 {
 	struct usb_device_driver	*udriver;
@@ -842,7 +842,7 @@ static int resume_device(struct usb_device *udev)
 	return status;
 }
 
-/* Caller has locked intf's usb_device's pm_mutex */
+/* Caller has locked intf's usb_device's pm mutex */
 static int suspend_interface(struct usb_interface *intf, pm_message_t msg)
 {
 	struct usb_driver	*driver;
@@ -1064,7 +1064,7 @@ int usb_resume_both(struct usb_device *udev)
 	/* Propagate the resume up the tree, if necessary */
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		if (parent) {
-			mutex_lock_nested(&amp;parent-&gt;pm_mutex, parent-&gt;level);
+			usb_pm_lock(parent);
 			parent-&gt;auto_pm = 1;
 			status = usb_resume_both(parent);
 		} else {
@@ -1079,7 +1079,7 @@ int usb_resume_both(struct usb_device *udev)
 		if (status == 0)
 			status = resume_device(udev);
 		if (parent)
-			mutex_unlock(&amp;parent-&gt;pm_mutex);
+			usb_pm_unlock(parent);
 	} else {
 
 		/* Needed only for setting udev-&gt;dev.power.power_state.event
@@ -1129,12 +1129,12 @@ int usb_resume_both(struct usb_device *udev)
  */
 void usb_autosuspend_device(struct usb_device *udev, int dec_usage_cnt)
 {
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	udev-&gt;pm_usage_cnt -= dec_usage_cnt;
 	if (udev-&gt;pm_usage_cnt &lt;= 0)
 		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 				USB_AUTOSUSPEND_DELAY);
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: cnt %d\n",
 	//		__FUNCTION__, udev-&gt;pm_usage_cnt);
 }
@@ -1168,13 +1168,13 @@ int usb_autoresume_device(struct usb_device *udev, int inc_usage_cnt)
 {
 	int	status;
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	udev-&gt;pm_usage_cnt += inc_usage_cnt;
 	udev-&gt;auto_pm = 1;
 	status = usb_resume_both(udev);
 	if (status != 0)
 		udev-&gt;pm_usage_cnt -= inc_usage_cnt;
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;udev-&gt;dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, udev-&gt;pm_usage_cnt);
 	return status;
@@ -1215,13 +1215,13 @@ void usb_autopm_put_interface(struct usb_interface *intf)
 {
 	struct usb_device	*udev = interface_to_usbdev(intf);
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	if (intf-&gt;condition != USB_INTERFACE_UNBOUND &amp;&amp;
 			--intf-&gt;pm_usage_cnt &lt;= 0) {
 		queue_delayed_work(ksuspend_usb_wq, &amp;udev-&gt;autosuspend,
 				USB_AUTOSUSPEND_DELAY);
 	}
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;intf-&gt;dev, "%s: cnt %d\n",
 	//		__FUNCTION__, intf-&gt;pm_usage_cnt);
 }
@@ -1263,7 +1263,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 	struct usb_device	*udev = interface_to_usbdev(intf);
 	int			status;
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	if (intf-&gt;condition == USB_INTERFACE_UNBOUND)
 		status = -ENODEV;
 	else {
@@ -1273,7 +1273,7 @@ int usb_autopm_get_interface(struct usb_interface *intf)
 		if (status != 0)
 			--intf-&gt;pm_usage_cnt;
 	}
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 	// dev_dbg(&amp;intf-&gt;dev, "%s: status %d cnt %d\n",
 	//		__FUNCTION__, status, intf-&gt;pm_usage_cnt);
 	return status;
@@ -1289,10 +1289,10 @@ static int usb_suspend(struct device *dev, pm_message_t message)
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		usb_pm_lock(udev);
 		udev-&gt;auto_pm = 0;
 		status = usb_suspend_both(udev, message);
-		mutex_unlock(&amp;udev-&gt;pm_mutex);
+		usb_pm_unlock(udev);
 	} else
 		status = 0;
 	return status;
@@ -1305,10 +1305,10 @@ static int usb_resume(struct device *dev)
 	if (is_usb_device(dev)) {
 		struct usb_device *udev = to_usb_device(dev);
 
-		mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+		usb_pm_lock(udev);
 		udev-&gt;auto_pm = 0;
 		status = usb_resume_both(udev);
-		mutex_unlock(&amp;udev-&gt;pm_mutex);
+		usb_pm_unlock(udev);
 
 		/* Rebind drivers that had no suspend method? */
 	} else
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 2a8cb3c2b19c..7676690a0386 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1779,7 +1779,7 @@ static int remote_wakeup(struct usb_device *udev)
 	 * to the parent hub! */
 
 	usb_lock_device(udev);
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	if (udev-&gt;state == USB_STATE_SUSPENDED) {
 		dev_dbg(&amp;udev-&gt;dev, "usb %sresume\n", "wakeup-");
 		/* TRSMRCY = 10 msec */
@@ -1788,7 +1788,7 @@ static int remote_wakeup(struct usb_device *udev)
 		if (status == 0)
 			udev-&gt;dev.power.power_state.event = PM_EVENT_ON;
 	}
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 
 	if (status == 0)
 		usb_autoresume_device(udev, 0);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 239f8e5d247f..e4df9edf1bc0 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -214,10 +214,10 @@ static void usb_autosuspend_work(void *_udev)
 {
 	struct usb_device	*udev = _udev;
 
-	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+	usb_pm_lock(udev);
 	udev-&gt;auto_pm = 1;
 	usb_suspend_both(udev, PMSG_SUSPEND);
-	mutex_unlock(&amp;udev-&gt;pm_mutex);
+	usb_pm_unlock(udev);
 }
 
 #else
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index fb6eb41c374f..f69df137ec0e 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -36,6 +36,16 @@ extern int usb_resume_both(struct usb_device *udev);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+static inline void usb_pm_lock(struct usb_device *udev)
+{
+	mutex_lock_nested(&amp;udev-&gt;pm_mutex, udev-&gt;level);
+}
+
+static inline void usb_pm_unlock(struct usb_device *udev)
+{
+	mutex_unlock(&amp;udev-&gt;pm_mutex);
+}
+
 #else
 
 #define usb_suspend_both(udev, msg)	0
@@ -45,6 +55,8 @@ static inline int usb_resume_both(struct usb_device *udev)
 }
 #define usb_port_suspend(dev)		0
 #define usb_port_resume(dev)		0
+static inline void usb_pm_lock(struct usb_device *udev) {}
+static inline void usb_pm_unlock(struct usb_device *udev) {}
 
 #endif
 
@@ -58,7 +70,11 @@ extern int usb_autoresume_device(struct usb_device *udev, int inc_busy_cnt);
 #else
 
 #define usb_autosuspend_device(udev, dec_busy_cnt)	do {} while (0)
-#define usb_autoresume_device(udev, inc_busy_cnt)	0
+static inline int usb_autoresume_device(struct usb_device *udev,
+		int inc_busy_cnt)
+{
+	return 0;
+}
 
 #endif
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index 0da15b0b02be..190cc1b78fe2 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -380,10 +380,10 @@ struct usb_device {
 	int maxchild;			/* Number of ports if hub */
 	struct usb_device *children[USB_MAXCHILDREN];
 
+	int pm_usage_cnt;		/* usage counter for autosuspend */
 #ifdef CONFIG_PM
 	struct work_struct autosuspend;	/* for delayed autosuspends */
 	struct mutex pm_mutex;		/* protects PM operations */
-	int pm_usage_cnt;		/* usage counter for autosuspend */
 
 	unsigned auto_pm:1;		/* autosuspend/resume in progress */
 	unsigned do_remote_wakeup:1;	/* remote wakeup should be enabled */</pre>
    <div class="pagination">
        <a href='2_117.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><span>[118]</span><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_119.html'>Next&gt;&gt;</a>
    <div>
</body>
