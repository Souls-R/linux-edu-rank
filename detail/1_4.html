<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_3.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><span>[4]</span><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_5.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 3478c83cf26bbffd026ae6a56bcb1fe544f0834e
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Dec 14 15:08:18 2022 -0500

    ext4: improve xattr consistency checking and error reporting
    
    Refactor the in-inode and xattr block consistency checking, and report
    more fine-grained reports of the consistency problems.  Also add more
    consistency checks for ea_inode number.
    
    Reviewed-by: Andreas Dilger &lt;adilger@dilger.ca&gt;
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Link: https://lore.kernel.org/r/20221214200818.870087-1-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index 69a1b8c6a2ec..e51052a247cc 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -184,27 +184,73 @@ ext4_xattr_handler(int name_index)
 }
 
 static int
-ext4_xattr_check_entries(struct ext4_xattr_entry *entry, void *end,
-			 void *value_start)
+check_xattrs(struct inode *inode, struct buffer_head *bh,
+	     struct ext4_xattr_entry *entry, void *end, void *value_start,
+	     const char *function, unsigned int line)
 {
 	struct ext4_xattr_entry *e = entry;
+	int err = -EFSCORRUPTED;
+	char *err_str;
+
+	if (bh) {
+		if (BHDR(bh)-&gt;h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
+		    BHDR(bh)-&gt;h_blocks != cpu_to_le32(1)) {
+			err_str = "invalid header";
+			goto errout;
+		}
+		if (buffer_verified(bh))
+			return 0;
+		if (!ext4_xattr_block_csum_verify(inode, bh)) {
+			err = -EFSBADCRC;
+			err_str = "invalid checksum";
+			goto errout;
+		}
+	} else {
+		struct ext4_xattr_ibody_header *header = value_start;
+
+		header -= 1;
+		if (end - (void *)header &lt; sizeof(*header) + sizeof(u32)) {
+			err_str = "in-inode xattr block too small";
+			goto errout;
+		}
+		if (header-&gt;h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {
+			err_str = "bad magic number in in-inode xattr";
+			goto errout;
+		}
+	}
 
 	/* Find the end of the names list */
 	while (!IS_LAST_ENTRY(e)) {
 		struct ext4_xattr_entry *next = EXT4_XATTR_NEXT(e);
-		if ((void *)next &gt;= end)
-			return -EFSCORRUPTED;
-		if (strnlen(e-&gt;e_name, e-&gt;e_name_len) != e-&gt;e_name_len)
-			return -EFSCORRUPTED;
+		if ((void *)next &gt;= end) {
+			err_str = "e_name out of bounds";
+			goto errout;
+		}
+		if (strnlen(e-&gt;e_name, e-&gt;e_name_len) != e-&gt;e_name_len) {
+			err_str = "bad e_name length";
+			goto errout;
+		}
 		e = next;
 	}
 
 	/* Check the values */
 	while (!IS_LAST_ENTRY(entry)) {
 		u32 size = le32_to_cpu(entry-&gt;e_value_size);
+		unsigned long ea_ino = le32_to_cpu(entry-&gt;e_value_inum);
 
-		if (size &gt; EXT4_XATTR_SIZE_MAX)
-			return -EFSCORRUPTED;
+		if (!ext4_has_feature_ea_inode(inode-&gt;i_sb) &amp;&amp; ea_ino) {
+			err_str = "ea_inode specified without ea_inode feature enabled";
+			goto errout;
+		}
+		if (ea_ino &amp;&amp; ((ea_ino == EXT4_ROOT_INO) ||
+			       !ext4_valid_inum(inode-&gt;i_sb, ea_ino))) {
+			err_str = "invalid ea_ino";
+			goto errout;
+		}
+		if (size &gt; EXT4_XATTR_SIZE_MAX) {
+			err_str = "e_value size too large";
+			goto errout;
+		}
 
 		if (size != 0 &amp;&amp; entry-&gt;e_value_inum == 0) {
 			u16 offs = le16_to_cpu(entry-&gt;e_value_offs);
@@ -216,66 +262,54 @@ ext4_xattr_check_entries(struct ext4_xattr_entry *entry, void *end,
 			 * the padded and unpadded sizes, since the size may
 			 * overflow to 0 when adding padding.
 			 */
-			if (offs &gt; end - value_start)
-				return -EFSCORRUPTED;
+			if (offs &gt; end - value_start) {
+				err_str = "e_value out of bounds";
+				goto errout;
+			}
 			value = value_start + offs;
 			if (value &lt; (void *)e + sizeof(u32) ||
 			    size &gt; end - value ||
-			    EXT4_XATTR_SIZE(size) &gt; end - value)
-				return -EFSCORRUPTED;
+			    EXT4_XATTR_SIZE(size) &gt; end - value) {
+				err_str = "overlapping e_value ";
+				goto errout;
+			}
 		}
 		entry = EXT4_XATTR_NEXT(entry);
 	}
-
+	if (bh)
+		set_buffer_verified(bh);
 	return 0;
+
+errout:
+	if (bh)
+		__ext4_error_inode(inode, function, line, 0, -err,
+				   "corrupted xattr block %llu: %s",
+				   (unsigned long long) bh-&gt;b_blocknr,
+				   err_str);
+	else
+		__ext4_error_inode(inode, function, line, 0, -err,
+				   "corrupted in-inode xattr: %s", err_str);
+	return err;
 }
 
 static inline int
 __ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,
 			 const char *function, unsigned int line)
 {
-	int error = -EFSCORRUPTED;
-
-	if (BHDR(bh)-&gt;h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
-	    BHDR(bh)-&gt;h_blocks != cpu_to_le32(1))
-		goto errout;
-	if (buffer_verified(bh))
-		return 0;
-
-	error = -EFSBADCRC;
-	if (!ext4_xattr_block_csum_verify(inode, bh))
-		goto errout;
-	error = ext4_xattr_check_entries(BFIRST(bh), bh-&gt;b_data + bh-&gt;b_size,
-					 bh-&gt;b_data);
-errout:
-	if (error)
-		__ext4_error_inode(inode, function, line, 0, -error,
-				   "corrupted xattr block %llu",
-				   (unsigned long long) bh-&gt;b_blocknr);
-	else
-		set_buffer_verified(bh);
-	return error;
+	return check_xattrs(inode, bh, BFIRST(bh), bh-&gt;b_data + bh-&gt;b_size,
+			    bh-&gt;b_data, function, line);
 }
 
 #define ext4_xattr_check_block(inode, bh) \
 	__ext4_xattr_check_block((inode), (bh),  __func__, __LINE__)
 
 
-static int
+static inline int
 __xattr_check_inode(struct inode *inode, struct ext4_xattr_ibody_header *header,
 			 void *end, const char *function, unsigned int line)
 {
-	int error = -EFSCORRUPTED;
-
-	if (end - (void *)header &lt; sizeof(*header) + sizeof(u32) ||
-	    (header-&gt;h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)))
-		goto errout;
-	error = ext4_xattr_check_entries(IFIRST(header), end, IFIRST(header));
-errout:
-	if (error)
-		__ext4_error_inode(inode, function, line, 0, -error,
-				   "corrupted in-inode xattr");
-	return error;
+	return check_xattrs(inode, NULL, IFIRST(header), end, IFIRST(header),
+			    function, line);
 }
 
 #define xattr_check_inode(inode, header, end) \</pre><hr><pre>commit 0d043351e5baf3857f915367deba2a518b6a0809
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Nov 5 23:42:36 2022 -0400

    ext4: fix fortify warning in fs/ext4/fast_commit.c:1551
    
    With the new fortify string system, rework the memcpy to avoid this
    warning:
    
    memcpy: detected field-spanning write (size 60) of single field "&amp;raw_inode-&gt;i_generation" at fs/ext4/fast_commit.c:1551 (size 4)
    
    Cc: stable@kernel.org
    Fixes: 54d9469bc515 ("fortify: Add run-time WARN for cross-field memcpy()")
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/fast_commit.c b/fs/ext4/fast_commit.c
index ef05bfa87798..0f6d0a80467d 100644
--- a/fs/ext4/fast_commit.c
+++ b/fs/ext4/fast_commit.c
@@ -1521,6 +1521,7 @@ static int ext4_fc_replay_inode(struct super_block *sb, struct ext4_fc_tl *tl,
 	struct ext4_iloc iloc;
 	int inode_len, ino, ret, tag = tl-&gt;fc_tag;
 	struct ext4_extent_header *eh;
+	size_t off_gen = offsetof(struct ext4_inode, i_generation);
 
 	memcpy(&amp;fc_inode, val, sizeof(fc_inode));
 
@@ -1548,8 +1549,8 @@ static int ext4_fc_replay_inode(struct super_block *sb, struct ext4_fc_tl *tl,
 	raw_inode = ext4_raw_inode(&amp;iloc);
 
 	memcpy(raw_inode, raw_fc_inode, offsetof(struct ext4_inode, i_block));
-	memcpy(&amp;raw_inode-&gt;i_generation, &amp;raw_fc_inode-&gt;i_generation,
-		inode_len - offsetof(struct ext4_inode, i_generation));
+	memcpy((u8 *)raw_inode + off_gen, (u8 *)raw_fc_inode + off_gen,
+	       inode_len - off_gen);
 	if (le32_to_cpu(raw_inode-&gt;i_flags) &amp; EXT4_EXTENTS_FL) {
 		eh = (struct ext4_extent_header *)(&amp;raw_inode-&gt;i_block[0]);
 		if (eh-&gt;eh_magic != EXT4_EXT_MAGIC) {</pre><hr><pre>commit 9a8c5b0d061554fedd7dbe894e63aa34d0bac7c4
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Oct 27 16:04:36 2022 -0400

    ext4: update the backup superblock's at the end of the online resize
    
    When expanding a file system using online resize, various fields in
    the superblock (e.g., s_blocks_count, s_inodes_count, etc.) change.
    To update the backup superblocks, the online resize uses the function
    update_backups() in fs/ext4/resize.c.  This function was not updating
    the checksum field in the backup superblocks.  This wasn't a big deal
    previously, because e2fsck didn't care about the checksum field in the
    backup superblock.  (And indeed, update_backups() goes all the way
    back to the ext3 days, well before we had support for metadata
    checksums.)
    
    However, there is an alternate, more general way of updating
    superblock fields, ext4_update_primary_sb() in fs/ext4/ioctl.c.  This
    function does check the checksum of the backup superblock, and if it
    doesn't match will mark the file system as corrupted.  That was
    clearly not the intent, so avoid to aborting the resize when a bad
    superblock is found.
    
    In addition, teach update_backups() to properly update the checksum in
    the backup superblocks.  We will eventually want to unify
    updapte_backups() with the infrasture in ext4_update_primary_sb(), but
    that's for another day.
    
    Note: The problem has been around for a while; it just didn't really
    matter until ext4_update_primary_sb() was added by commit bbc605cdb1e1
    ("ext4: implement support for get/set fs label").  And it became
    trivially easy to reproduce after commit 827891a38acc ("ext4: update
    the s_overhead_clusters in the backup sb's when resizing") in v6.0.
    
    Cc: stable@kernel.org # 5.17+
    Fixes: bbc605cdb1e1 ("ext4: implement support for get/set fs label")
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index 4d49c5cfb690..790d5ffe8559 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -145,9 +145,8 @@ static int ext4_update_backup_sb(struct super_block *sb,
 	if (ext4_has_metadata_csum(sb) &amp;&amp;
 	    es-&gt;s_checksum != ext4_superblock_csum(sb, es)) {
 		ext4_msg(sb, KERN_ERR, "Invalid checksum for backup "
-		"superblock %llu\n", sb_block);
+		"superblock %llu", sb_block);
 		unlock_buffer(bh);
-		err = -EFSBADCRC;
 		goto out_bh;
 	}
 	func(es, arg);
diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index 6dfe9ccae0c5..46b87ffeb304 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -1158,6 +1158,7 @@ static void update_backups(struct super_block *sb, sector_t blk_off, char *data,
 	while (group &lt; sbi-&gt;s_groups_count) {
 		struct buffer_head *bh;
 		ext4_fsblk_t backup_block;
+		struct ext4_super_block *es;
 
 		/* Out of journal space, and can't get more - abort - so sad */
 		err = ext4_resize_ensure_credits_batch(handle, 1);
@@ -1186,6 +1187,10 @@ static void update_backups(struct super_block *sb, sector_t blk_off, char *data,
 		memcpy(bh-&gt;b_data, data, size);
 		if (rest)
 			memset(bh-&gt;b_data + size, 0, rest);
+		es = (struct ext4_super_block *) bh-&gt;b_data;
+		es-&gt;s_block_group_nr = cpu_to_le16(group);
+		if (ext4_has_metadata_csum(sb))
+			es-&gt;s_checksum = ext4_superblock_csum(sb, es);
 		set_buffer_uptodate(bh);
 		unlock_buffer(bh);
 		err = ext4_handle_dirty_metadata(handle, NULL, bh);</pre><hr><pre>commit 80fa46d6b9e7b1527bfd2197d75431fd9c382161
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Sep 1 18:03:14 2022 -0400

    ext4: limit the number of retries after discarding preallocations blocks
    
    This patch avoids threads live-locking for hours when a large number
    threads are competing over the last few free extents as they blocks
    getting added and removed from preallocation pools.  From our bug
    reporter:
    
       A reliable way for triggering this has multiple writers
       continuously write() to files when the filesystem is full, while
       small amounts of space are freed (e.g. by truncating a large file
       -1MiB at a time). In the local filesystem, this can be done by
       simply not checking the return code of write (0) and/or the error
       (ENOSPACE) that is set. Over NFS with an async mount, even clients
       with proper error checking will behave this way since the linux NFS
       client implementation will not propagate the server errors [the
       write syscalls immediately return success] until the file handle is
       closed. This leads to a situation where NFS clients send a
       continuous stream of WRITE rpcs which result in ERRNOSPACE -- but
       since the client isn't seeing this, the stream of writes continues
       at maximum network speed.
    
       When some space does appear, multiple writers will all attempt to
       claim it for their current write. For NFS, we may see dozens to
       hundreds of threads that do this.
    
       The real-world scenario of this is database backup tooling (in
       particular, github.com/mdkent/percona-xtrabackup) which may write
       large files (&gt;1TiB) to NFS for safe keeping. Some temporary files
       are written, rewound, and read back -- all before closing the file
       handle (the temp file is actually unlinked, to trigger automatic
       deletion on close/crash.) An application like this operating on an
       async NFS mount will not see an error code until TiB have been
       written/read.
    
       The lockup was observed when running this database backup on large
       filesystems (64 TiB in this case) with a high number of block
       groups and no free space. Fragmentation is generally not a factor
       in this filesystem (~thousands of large files, mostly contiguous
       except for the parts written while the filesystem is at capacity.)
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@kernel.org

diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index 31873af0421b..71f5b67d7f28 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -5533,6 +5533,7 @@ ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,
 	ext4_fsblk_t block = 0;
 	unsigned int inquota = 0;
 	unsigned int reserv_clstrs = 0;
+	int retries = 0;
 	u64 seq;
 
 	might_sleep();
@@ -5635,7 +5636,8 @@ ext4_fsblk_t ext4_mb_new_blocks(handle_t *handle,
 			ar-&gt;len = ac-&gt;ac_b_ex.fe_len;
 		}
 	} else {
-		if (ext4_mb_discard_preallocations_should_retry(sb, ac, &amp;seq))
+		if (++retries &lt; 3 &amp;&amp;
+		    ext4_mb_discard_preallocations_should_retry(sb, ac, &amp;seq))
 			goto repeat;
 		/*
 		 * If block allocation fails then the pa allocated above</pre><hr><pre>commit 827891a38accfb4e04dbcdefe710f8746c6ad16d
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Jun 29 00:00:26 2022 -0400

    ext4: update the s_overhead_clusters in the backup sb's when resizing
    
    When the EXT4_IOC_RESIZE_FS ioctl is complete, update the backup
    superblocks.  We don't do this for the old-style resize ioctls since
    they are quite ancient, and only used by very old versions of
    resize2fs --- and we don't want to update the backup superblocks every
    time EXT4_IOC_GROUP_ADD is called, since it might get called a lot.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Reviewed-by: Andreas Dilger &lt;adilger@dilger.ca&gt;
    Link: https://lore.kernel.org/r/20220629040026.112371-2-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index adfc30ee4b7b..310e976ef1fd 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -3016,7 +3016,7 @@ int ext4_fileattr_set(struct user_namespace *mnt_userns,
 		      struct dentry *dentry, struct fileattr *fa);
 int ext4_fileattr_get(struct dentry *dentry, struct fileattr *fa);
 extern void ext4_reset_inode_seed(struct inode *inode);
-int ext4_update_overhead(struct super_block *sb);
+int ext4_update_overhead(struct super_block *sb, bool force);
 
 /* migrate.c */
 extern int ext4_ext_migrate(struct inode *);
@@ -3800,7 +3800,7 @@ static inline void set_bitmap_uptodate(struct buffer_head *bh)
 extern wait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];
 
 extern int ext4_resize_begin(struct super_block *sb);
-extern void ext4_resize_end(struct super_block *sb);
+extern int ext4_resize_end(struct super_block *sb, bool update_backups);
 
 static inline void ext4_set_io_unwritten_flag(struct inode *inode,
 					      struct ext4_io_end *io_end)
diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index cb01c1da0f9d..1702c574407a 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -944,7 +944,9 @@ static long ext4_ioctl_group_add(struct file *file,
 	    test_opt(sb, INIT_INODE_TABLE))
 		err = ext4_register_li_request(sb, input-&gt;group);
 group_add_out:
-	ext4_resize_end(sb);
+	err2 = ext4_resize_end(sb, false);
+	if (err == 0)
+		err = err2;
 	return err;
 }
 
@@ -1223,7 +1225,9 @@ static long __ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			err = err2;
 		mnt_drop_write_file(filp);
 group_extend_out:
-		ext4_resize_end(sb);
+		err2 = ext4_resize_end(sb, false);
+		if (err == 0)
+			err = err2;
 		return err;
 	}
 
@@ -1371,7 +1375,9 @@ static long __ext4_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 			err = ext4_register_li_request(sb, o_group);
 
 resizefs_out:
-		ext4_resize_end(sb);
+		err2 = ext4_resize_end(sb, true);
+		if (err == 0)
+			err = err2;
 		return err;
 	}
 
@@ -1599,13 +1605,15 @@ static void set_overhead(struct ext4_super_block *es, const void *arg)
 	es-&gt;s_overhead_clusters = cpu_to_le32(*((unsigned long *) arg));
 }
 
-int ext4_update_overhead(struct super_block *sb)
+int ext4_update_overhead(struct super_block *sb, bool force)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 
-	if (sb_rdonly(sb) || sbi-&gt;s_overhead == 0 ||
-	    sbi-&gt;s_overhead == le32_to_cpu(sbi-&gt;s_es-&gt;s_overhead_clusters))
+	if (sb_rdonly(sb))
+		return 0;
+	if (!force &amp;&amp;
+	    (sbi-&gt;s_overhead == 0 ||
+	     sbi-&gt;s_overhead == le32_to_cpu(sbi-&gt;s_es-&gt;s_overhead_clusters)))
 		return 0;
-
 	return ext4_update_superblocks_fn(sb, set_overhead, &amp;sbi-&gt;s_overhead);
 }
diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index e5c2713aa11a..e4e89ca82f8c 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -97,10 +97,13 @@ int ext4_resize_begin(struct super_block *sb)
 	return ret;
 }
 
-void ext4_resize_end(struct super_block *sb)
+int ext4_resize_end(struct super_block *sb, bool update_backups)
 {
 	clear_bit_unlock(EXT4_FLAGS_RESIZING, &amp;EXT4_SB(sb)-&gt;s_ext4_flags);
 	smp_mb__after_atomic();
+	if (update_backups)
+		return ext4_update_overhead(sb, true);
+	return 0;
 }
 
 static ext4_group_t ext4_meta_bg_first_group(struct super_block *sb,
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 845f2f8aee5f..6a8a752d812b 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -5523,7 +5523,7 @@ static int ext4_fill_super(struct super_block *sb, struct fs_context *fc)
 			 "Quota mode: %s.", descr, ext4_quota_mode(sb));
 
 	/* Update the s_overhead_clusters if necessary */
-	ext4_update_overhead(sb);
+	ext4_update_overhead(sb, false);
 	return 0;
 
 free_sbi:</pre><hr><pre>commit de394a86658ffe4e89e5328fd4993abfe41b7435
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Jun 29 00:00:25 2022 -0400

    ext4: update s_overhead_clusters in the superblock during an on-line resize
    
    When doing an online resize, the on-disk superblock on-disk wasn't
    updated.  This means that when the file system is unmounted and
    remounted, and the on-disk overhead value is non-zero, this would
    result in the results of statfs(2) to be incorrect.
    
    This was partially fixed by Commits 10b01ee92df5 ("ext4: fix overhead
    calculation to account for the reserved gdt blocks"), 85d825dbf489
    ("ext4: force overhead calculation if the s_overhead_cluster makes no
    sense"), and eb7054212eac ("ext4: update the cached overhead value in
    the superblock").
    
    However, since it was too expensive to forcibly recalculate the
    overhead for bigalloc file systems at every mount, this didn't fix the
    problem for bigalloc file systems.  This commit should address the
    problem when resizing file systems with the bigalloc feature enabled.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@kernel.org
    Reviewed-by: Andreas Dilger &lt;adilger@dilger.ca&gt;
    Link: https://lore.kernel.org/r/20220629040026.112371-1-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index 8b70a4701293..e5c2713aa11a 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -1484,6 +1484,7 @@ static void ext4_update_super(struct super_block *sb,
 	 * Update the fs overhead information
 	 */
 	ext4_calculate_overhead(sb);
+	es-&gt;s_overhead_clusters = cpu_to_le32(sbi-&gt;s_overhead);
 
 	if (test_opt(sb, DEBUG))
 		printk(KERN_DEBUG "EXT4-fs: added group %u:"</pre><hr><pre>commit e408e695f5f1f60d784913afc45ff2c387a5aeb8
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Jul 14 21:59:12 2022 -0400

    mm/shmem: support FS_IOC_[SG]ETFLAGS in tmpfs
    
    This allows userspace to set flags like FS_APPEND_FL, FS_IMMUTABLE_FL,
    FS_NODUMP_FL, etc., like all other standard Linux file systems.
    
    [akpm@linux-foundation.org: fix CONFIG_TMPFS_XATTR=n warnings]
    Link: https://lkml.kernel.org/r/20220715015912.2560575-1-tytso@mit.edu
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: Hugh Dickins &lt;hughd@google.com&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;

diff --git a/include/linux/shmem_fs.h b/include/linux/shmem_fs.h
index a68f982f22d1..1b6c4013f691 100644
--- a/include/linux/shmem_fs.h
+++ b/include/linux/shmem_fs.h
@@ -25,9 +25,20 @@ struct shmem_inode_info {
 	struct simple_xattrs	xattrs;		/* list of xattrs */
 	atomic_t		stop_eviction;	/* hold when working on inode */
 	struct timespec64	i_crtime;	/* file creation time */
+	unsigned int		fsflags;	/* flags for FS_IOC_[SG]ETFLAGS */
 	struct inode		vfs_inode;
 };
 
+#define SHMEM_FL_USER_VISIBLE FS_FL_USER_VISIBLE
+#define SHMEM_FL_USER_MODIFIABLE FS_FL_USER_MODIFIABLE
+#define SHMEM_FL_INHERITED FS_FL_USER_MODIFIABLE
+
+/* Flags that are appropriate for regular files (all but dir-specific ones). */
+#define SHMEM_REG_FLMASK (~(FS_DIRSYNC_FL | FS_TOPDIR_FL))
+
+/* Flags that are appropriate for non-directories/regular files. */
+#define SHMEM_OTHER_FLMASK (FS_NODUMP_FL | FS_NOATIME_FL)
+
 struct shmem_sb_info {
 	unsigned long max_blocks;   /* How many blocks are allowed */
 	struct percpu_counter used_blocks;  /* How many are allocated */
diff --git a/mm/shmem.c b/mm/shmem.c
index 12ac67dc831f..06871a913b49 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -28,6 +28,7 @@
 #include &lt;linux/ramfs.h&gt;
 #include &lt;linux/pagemap.h&gt;
 #include &lt;linux/file.h&gt;
+#include &lt;linux/fileattr.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/random.h&gt;
 #include &lt;linux/sched/signal.h&gt;
@@ -1058,6 +1059,15 @@ static int shmem_getattr(struct user_namespace *mnt_userns,
 		shmem_recalc_inode(inode);
 		spin_unlock_irq(&amp;info-&gt;lock);
 	}
+	if (info-&gt;fsflags &amp; FS_APPEND_FL)
+		stat-&gt;attributes |= STATX_ATTR_APPEND;
+	if (info-&gt;fsflags &amp; FS_IMMUTABLE_FL)
+		stat-&gt;attributes |= STATX_ATTR_IMMUTABLE;
+	if (info-&gt;fsflags &amp; FS_NODUMP_FL)
+		stat-&gt;attributes |= STATX_ATTR_NODUMP;
+	stat-&gt;attributes_mask |= (STATX_ATTR_APPEND |
+			STATX_ATTR_IMMUTABLE |
+			STATX_ATTR_NODUMP);
 	generic_fillattr(&amp;init_user_ns, inode, stat);
 
 	if (shmem_is_huge(NULL, inode, 0))
@@ -2272,7 +2282,18 @@ static int shmem_mmap(struct file *file, struct vm_area_struct *vma)
 	return 0;
 }
 
-static struct inode *shmem_get_inode(struct super_block *sb, const struct inode *dir,
+/* Mask out flags that are inappropriate for the given type of inode. */
+static unsigned shmem_mask_flags(umode_t mode, __u32 flags)
+{
+	if (S_ISDIR(mode))
+		return flags;
+	else if (S_ISREG(mode))
+		return flags &amp; SHMEM_REG_FLMASK;
+	else
+		return flags &amp; SHMEM_OTHER_FLMASK;
+}
+
+static struct inode *shmem_get_inode(struct super_block *sb, struct inode *dir,
 				     umode_t mode, dev_t dev, unsigned long flags)
 {
 	struct inode *inode;
@@ -2297,6 +2318,9 @@ static struct inode *shmem_get_inode(struct super_block *sb, const struct inode
 		info-&gt;seals = F_SEAL_SEAL;
 		info-&gt;flags = flags &amp; VM_NORESERVE;
 		info-&gt;i_crtime = inode-&gt;i_mtime;
+		info-&gt;fsflags = (dir == NULL) ? 0 :
+			SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED;
+		info-&gt;fsflags = shmem_mask_flags(mode, info-&gt;fsflags);
 		INIT_LIST_HEAD(&amp;info-&gt;shrinklist);
 		INIT_LIST_HEAD(&amp;info-&gt;swaplist);
 		simple_xattrs_init(&amp;info-&gt;xattrs);
@@ -3138,6 +3162,40 @@ static const char *shmem_get_link(struct dentry *dentry,
 }
 
 #ifdef CONFIG_TMPFS_XATTR
+
+static int shmem_fileattr_get(struct dentry *dentry, struct fileattr *fa)
+{
+	struct shmem_inode_info *info = SHMEM_I(d_inode(dentry));
+
+	fileattr_fill_flags(fa, info-&gt;fsflags &amp; SHMEM_FL_USER_VISIBLE);
+
+	return 0;
+}
+
+static int shmem_fileattr_set(struct user_namespace *mnt_userns,
+			      struct dentry *dentry, struct fileattr *fa)
+{
+	struct inode *inode = d_inode(dentry);
+	struct shmem_inode_info *info = SHMEM_I(inode);
+
+	if (fileattr_has_fsx(fa))
+		return -EOPNOTSUPP;
+
+	info-&gt;fsflags = (info-&gt;fsflags &amp; ~SHMEM_FL_USER_MODIFIABLE) |
+		(fa-&gt;flags &amp; SHMEM_FL_USER_MODIFIABLE);
+
+	inode-&gt;i_flags &amp;= ~(S_APPEND | S_IMMUTABLE | S_NOATIME);
+	if (info-&gt;fsflags &amp; FS_APPEND_FL)
+		inode-&gt;i_flags |= S_APPEND;
+	if (info-&gt;fsflags &amp; FS_IMMUTABLE_FL)
+		inode-&gt;i_flags |= S_IMMUTABLE;
+	if (info-&gt;fsflags &amp; FS_NOATIME_FL)
+		inode-&gt;i_flags |= S_NOATIME;
+
+	inode-&gt;i_ctime = current_time(inode);
+	return 0;
+}
+
 /*
  * Superblocks without xattr inode operations may get some security.* xattr
  * support from the LSM "for free". As soon as we have any other xattrs
@@ -3828,6 +3886,8 @@ static const struct inode_operations shmem_inode_operations = {
 #ifdef CONFIG_TMPFS_XATTR
 	.listxattr	= shmem_listxattr,
 	.set_acl	= simple_set_acl,
+	.fileattr_get	= shmem_fileattr_get,
+	.fileattr_set	= shmem_fileattr_set,
 #endif
 };
 
@@ -3847,6 +3907,8 @@ static const struct inode_operations shmem_dir_inode_operations = {
 #endif
 #ifdef CONFIG_TMPFS_XATTR
 	.listxattr	= shmem_listxattr,
+	.fileattr_get	= shmem_fileattr_get,
+	.fileattr_set	= shmem_fileattr_set,
 #endif
 #ifdef CONFIG_TMPFS_POSIX_ACL
 	.setattr	= shmem_setattr,</pre><hr><pre>commit c878bea3c9d724ddfa05a813f30de3d25a0ba83f
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue May 17 13:27:55 2022 -0400

    ext4: filter out EXT4_FC_REPLAY from on-disk superblock field s_state
    
    The EXT4_FC_REPLAY bit in sbi-&gt;s_mount_state is used to indicate that
    we are in the middle of replay the fast commit journal.  This was
    actually a mistake, since the sbi-&gt;s_mount_info is initialized from
    es-&gt;s_state.  Arguably s_mount_state is misleadingly named, but the
    name is historical --- s_mount_state and s_state dates back to ext2.
    
    What should have been used is the ext4_{set,clear,test}_mount_flag()
    inline functions, which sets EXT4_MF_* bits in sbi-&gt;s_mount_flags.
    
    The problem with using EXT4_FC_REPLAY is that a maliciously corrupted
    superblock could result in EXT4_FC_REPLAY getting set in
    s_mount_state.  This bypasses some sanity checks, and this can trigger
    a BUG() in ext4_es_cache_extent().  As a easy-to-backport-fix, filter
    out the EXT4_FC_REPLAY bit for now.  We should eventually transition
    away from EXT4_FC_REPLAY to something like EXT4_MF_REPLAY.
    
    Cc: stable@kernel.org
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Link: https://lore.kernel.org/r/20220420192312.1655305-1-phind.uet@gmail.com
    Link: https://lore.kernel.org/r/20220517174028.942119-1-tytso@mit.edu
    Reported-by: syzbot+c7358a3cd05ee786eb31@syzkaller.appspotmail.com

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 7f6cd2473163..9cbb22045379 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4770,7 +4770,7 @@ static int __ext4_fill_super(struct fs_context *fc, struct super_block *sb)
 					sbi-&gt;s_inodes_per_block;
 	sbi-&gt;s_desc_per_block = blocksize / EXT4_DESC_SIZE(sb);
 	sbi-&gt;s_sbh = bh;
-	sbi-&gt;s_mount_state = le16_to_cpu(es-&gt;s_state);
+	sbi-&gt;s_mount_state = le16_to_cpu(es-&gt;s_state) &amp; ~EXT4_FC_REPLAY;
 	sbi-&gt;s_addr_per_block_bits = ilog2(EXT4_ADDR_PER_BLOCK(sb));
 	sbi-&gt;s_desc_per_block_bits = ilog2(EXT4_DESC_PER_BLOCK(sb));
 
@@ -6333,7 +6333,8 @@ static int __ext4_remount(struct fs_context *fc, struct super_block *sb)
 				if (err)
 					goto restore_opts;
 			}
-			sbi-&gt;s_mount_state = le16_to_cpu(es-&gt;s_state);
+			sbi-&gt;s_mount_state = (le16_to_cpu(es-&gt;s_state) &amp;
+					      ~EXT4_FC_REPLAY);
 
 			err = ext4_setup_super(sb, es, 0);
 			if (err)</pre><hr><pre>commit 32452a3eb8b64e01e2be717f518c0be046975b9d
Author: Joseph Ravichandran &lt;jravi@mit.edu&gt;
Date:   Thu Apr 28 12:57:52 2022 -0400

    io_uring: fix uninitialized field in rw io_kiocb
    
    io_rw_init_file does not initialize kiocb-&gt;private, so when iocb_bio_iopoll
    reads kiocb-&gt;private it can contain uninitialized data.
    
    Fixes: 3e08773c3841 ("block: switch polling to be bio based")
    Signed-off-by: Joseph Ravichandran &lt;jravi@mit.edu&gt;
    Signed-off-by: Jens Axboe &lt;axboe@kernel.dk&gt;

diff --git a/fs/io_uring.c b/fs/io_uring.c
index 92ac50f139cd..e3ae26ff5d1a 100644
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@ -3783,6 +3783,7 @@ static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)
 		if (!(kiocb-&gt;ki_flags &amp; IOCB_DIRECT) || !file-&gt;f_op-&gt;iopoll)
 			return -EOPNOTSUPP;
 
+		kiocb-&gt;private = NULL;
 		kiocb-&gt;ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;
 		kiocb-&gt;ki_complete = io_complete_rw_iopoll;
 		req-&gt;iopoll_completed = 0;</pre><hr><pre>commit eb7054212eac8b451d727bf079eae3db8c88f9d3
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Apr 14 22:39:00 2022 -0400

    ext4: update the cached overhead value in the superblock
    
    If we (re-)calculate the file system overhead amount and it's
    different from the on-disk s_overhead_clusters value, update the
    on-disk version since this can take potentially quite a while on
    bigalloc file systems.
    
    Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu&gt;
    Cc: stable@kernel.org

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 48dc2c3247ad..a743b1e3b89e 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -3068,6 +3068,7 @@ int ext4_fileattr_set(struct user_namespace *mnt_userns,
 		      struct dentry *dentry, struct fileattr *fa);
 int ext4_fileattr_get(struct dentry *dentry, struct fileattr *fa);
 extern void ext4_reset_inode_seed(struct inode *inode);
+int ext4_update_overhead(struct super_block *sb);
 
 /* migrate.c */
 extern int ext4_ext_migrate(struct inode *);
diff --git a/fs/ext4/ioctl.c b/fs/ext4/ioctl.c
index 992229ca2d83..ba44fa1be70a 100644
--- a/fs/ext4/ioctl.c
+++ b/fs/ext4/ioctl.c
@@ -1652,3 +1652,19 @@ long ext4_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	return ext4_ioctl(file, cmd, (unsigned long) compat_ptr(arg));
 }
 #endif
+
+static void set_overhead(struct ext4_super_block *es, const void *arg)
+{
+	es-&gt;s_overhead_clusters = cpu_to_le32(*((unsigned long *) arg));
+}
+
+int ext4_update_overhead(struct super_block *sb)
+{
+	struct ext4_sb_info *sbi = EXT4_SB(sb);
+
+	if (sb_rdonly(sb) || sbi-&gt;s_overhead == 0 ||
+	    sbi-&gt;s_overhead == le32_to_cpu(sbi-&gt;s_es-&gt;s_overhead_clusters))
+		return 0;
+
+	return ext4_update_superblocks_fn(sb, set_overhead, &amp;sbi-&gt;s_overhead);
+}
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index d08820fdfdee..1847b46af808 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -5618,6 +5618,8 @@ static int ext4_fill_super(struct super_block *sb, struct fs_context *fc)
 		ext4_msg(sb, KERN_INFO, "mounted filesystem with%s. "
 			 "Quota mode: %s.", descr, ext4_quota_mode(sb));
 
+	/* Update the s_overhead_clusters if necessary */
+	ext4_update_overhead(sb);
 	return 0;
 
 free_sbi:</pre>
    <div class="pagination">
        <a href='1_3.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><span>[4]</span><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_5.html'>Next&gt;&gt;</a>
    <div>
</body>
