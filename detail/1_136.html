<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_135.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><span>[136]</span><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_137.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit dc76803e57cc86589c4efcb5362918f9b0c0436f
Author: Rian Hunter &lt;rian@alum.mit.edu&gt;
Date:   Sun Aug 19 16:08:53 2018 -0700

    x86/process: Re-export start_thread()
    
    The consolidation of the start_thread() functions removed the export
    unintentionally. This breaks binfmt handlers built as a module.
    
    Add it back.
    
    Fixes: e634d8fc792c ("x86-64: merge the standard and compat start_thread() functions")
    Signed-off-by: Rian Hunter &lt;rian@alum.mit.edu&gt;
    Signed-off-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;
    Cc: "H. Peter Anvin" &lt;hpa@zytor.com&gt;
    Cc: Andy Lutomirski &lt;luto@kernel.org&gt;
    Cc: Borislav Petkov &lt;bpetkov@suse.de&gt;
    Cc: Vitaly Kuznetsov &lt;vkuznets@redhat.com&gt;
    Cc: Joerg Roedel &lt;jroedel@suse.de&gt;
    Cc: Dmitry Safonov &lt;dima@arista.com&gt;
    Cc: Josh Poimboeuf &lt;jpoimboe@redhat.com&gt;
    Cc: stable@vger.kernel.org
    Link: https://lkml.kernel.org/r/20180819230854.7275-1-rian@alum.mit.edu

diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c
index 476e3ddf8890..a451bc374b9b 100644
--- a/arch/x86/kernel/process_64.c
+++ b/arch/x86/kernel/process_64.c
@@ -384,6 +384,7 @@ start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)
 	start_thread_common(regs, new_ip, new_sp,
 			    __USER_CS, __USER_DS, 0);
 }
+EXPORT_SYMBOL_GPL(start_thread);
 
 #ifdef CONFIG_COMPAT
 void compat_start_thread(struct pt_regs *regs, u32 new_ip, u32 new_sp)</pre><hr><pre>commit 7a22c737faef99d6f75d7049c1a2f6f0fdefb1ec
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sun Apr 22 17:47:12 2018 -0400

    drm/nouveau: fix temp/pwm visibility, skip hwmon when no sensors exist
    
    A NV34 GPU was seeing temp and pwm entries in hwmon, which would error
    out when read. These should not have been visible, but also the whole
    hwmon object should just not have been registered in the first place.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nouveau_hwmon.c b/drivers/gpu/drm/nouveau/nouveau_hwmon.c
index 7c965648df80..44178b4c3599 100644
--- a/drivers/gpu/drm/nouveau/nouveau_hwmon.c
+++ b/drivers/gpu/drm/nouveau/nouveau_hwmon.c
@@ -327,7 +327,7 @@ nouveau_temp_is_visible(const void *data, u32 attr, int channel)
 	struct nouveau_drm *drm = nouveau_drm((struct drm_device *)data);
 	struct nvkm_therm *therm = nvxx_therm(&amp;drm-&gt;client.device);
 
-	if (therm &amp;&amp; therm-&gt;attr_get &amp;&amp; nvkm_therm_temp_get(therm) &lt; 0)
+	if (!therm || !therm-&gt;attr_get || nvkm_therm_temp_get(therm) &lt; 0)
 		return 0;
 
 	switch (attr) {
@@ -351,8 +351,8 @@ nouveau_pwm_is_visible(const void *data, u32 attr, int channel)
 	struct nouveau_drm *drm = nouveau_drm((struct drm_device *)data);
 	struct nvkm_therm *therm = nvxx_therm(&amp;drm-&gt;client.device);
 
-	if (therm &amp;&amp; therm-&gt;attr_get &amp;&amp; therm-&gt;fan_get &amp;&amp;
-				therm-&gt;fan_get(therm) &lt; 0)
+	if (!therm || !therm-&gt;attr_get || !therm-&gt;fan_get ||
+	    therm-&gt;fan_get(therm) &lt; 0)
 		return 0;
 
 	switch (attr) {
@@ -707,13 +707,20 @@ nouveau_hwmon_init(struct drm_device *dev)
 {
 #if defined(CONFIG_HWMON) || (defined(MODULE) &amp;&amp; defined(CONFIG_HWMON_MODULE))
 	struct nouveau_drm *drm = nouveau_drm(dev);
+	struct nvkm_iccsense *iccsense = nvxx_iccsense(&amp;drm-&gt;client.device);
 	struct nvkm_therm *therm = nvxx_therm(&amp;drm-&gt;client.device);
+	struct nvkm_volt *volt = nvxx_volt(&amp;drm-&gt;client.device);
 	const struct attribute_group *special_groups[N_ATTR_GROUPS];
 	struct nouveau_hwmon *hwmon;
 	struct device *hwmon_dev;
 	int ret = 0;
 	int i = 0;
 
+	if (!iccsense &amp;&amp; !therm &amp;&amp; !volt) {
+		NV_DEBUG(drm, "Skipping hwmon registration\n");
+		return 0;
+	}
+
 	hwmon = drm-&gt;hwmon = kzalloc(sizeof(*hwmon), GFP_KERNEL);
 	if (!hwmon)
 		return -ENOMEM;
@@ -749,6 +756,9 @@ nouveau_hwmon_fini(struct drm_device *dev)
 #if defined(CONFIG_HWMON) || (defined(MODULE) &amp;&amp; defined(CONFIG_HWMON_MODULE))
 	struct nouveau_hwmon *hwmon = nouveau_hwmon(dev);
 
+	if (!hwmon)
+		return;
+
 	if (hwmon-&gt;hwmon)
 		hwmon_device_unregister(hwmon-&gt;hwmon);
 </pre><hr><pre>commit c20bb155c2c5acb775f68be5d84fe679687c3c1e
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Feb 3 14:11:23 2018 -0500

    drm/nouveau: prefer XBGR2101010 for addfb ioctl
    
    Nouveau only exposes support for XBGR2101010. Prior to the atomic
    conversion, drm would pass in the wrong format in the framebuffer, but
    it was always ignored -- both userspace (xf86-video-nouveau) and the
    kernel driver agreed on the layout, so the fact that the format was
    wrong didn't matter.
    
    With the atomic conversion, nouveau all of a sudden started caring about
    the exact format, and so the previously-working code in
    xf86-video-nouveau no longer functioned since the (internally-assigned)
    format from the addfb ioctl was wrong.
    
    This change adds infrastructure to allow a drm driver to specify that it
    prefers the XBGR format variant for the addfb ioctl, and makes nouveau's
    nv50 display driver set it. (Prior gens had no support for 30bpp at all.)
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Cc: stable@vger.kernel.org # v4.10+
    Acked-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;
    Signed-off-by: Daniel Vetter &lt;daniel.vetter@ffwll.ch&gt;
    Link: https://patchwork.freedesktop.org/patch/msgid/20180203191123.31507-1-imirkin@alum.mit.edu

diff --git a/drivers/gpu/drm/drm_framebuffer.c b/drivers/gpu/drm/drm_framebuffer.c
index 5a13ff29f4f0..c0530a1af5e3 100644
--- a/drivers/gpu/drm/drm_framebuffer.c
+++ b/drivers/gpu/drm/drm_framebuffer.c
@@ -121,6 +121,10 @@ int drm_mode_addfb(struct drm_device *dev,
 	r.pixel_format = drm_mode_legacy_fb_format(or-&gt;bpp, or-&gt;depth);
 	r.handles[0] = or-&gt;handle;
 
+	if (r.pixel_format == DRM_FORMAT_XRGB2101010 &amp;&amp;
+	    dev-&gt;driver-&gt;driver_features &amp; DRIVER_PREFER_XBGR_30BPP)
+		r.pixel_format = DRM_FORMAT_XBGR2101010;
+
 	ret = drm_mode_addfb2(dev, &amp;r, file_priv);
 	if (ret)
 		return ret;
diff --git a/drivers/gpu/drm/nouveau/nv50_display.c b/drivers/gpu/drm/nouveau/nv50_display.c
index dd8d4352ed99..caddce88d2d8 100644
--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@ -4477,6 +4477,7 @@ nv50_display_create(struct drm_device *dev)
 	nouveau_display(dev)-&gt;fini = nv50_display_fini;
 	disp-&gt;disp = &amp;nouveau_display(dev)-&gt;disp;
 	dev-&gt;mode_config.funcs = &amp;nv50_disp_func;
+	dev-&gt;driver-&gt;driver_features |= DRIVER_PREFER_XBGR_30BPP;
 	if (nouveau_atomic)
 		dev-&gt;driver-&gt;driver_features |= DRIVER_ATOMIC;
 
diff --git a/include/drm/drm_drv.h b/include/drm/drm_drv.h
index d32b688eb346..d23dcdd1bd95 100644
--- a/include/drm/drm_drv.h
+++ b/include/drm/drm_drv.h
@@ -56,6 +56,7 @@ struct drm_printer;
 #define DRIVER_ATOMIC			0x10000
 #define DRIVER_KMS_LEGACY_CONTEXT	0x20000
 #define DRIVER_SYNCOBJ                  0x40000
+#define DRIVER_PREFER_XBGR_30BPP        0x80000
 
 /**
  * struct drm_driver - DRM driver structure</pre><hr><pre>commit e75182f68b7b3a073e33b89ee4c1688160755930
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Dec 30 23:35:28 2017 -0500

    drm/nouveau/kms/nv50: use "low res" lut for indexed mode
    
    This is what was done prior to the big refactor in kernel 3.8, and what
    was done by xf86-video-nv. Experimentally, it seems like there's some
    sort of issue with the high-res lut to be used there. Tested on G92.
    
    This ends up mattering because fbcon/fbdev chooses the C8 fb format for
    low-vram systems, which can occur with some IGP-based configurations
    with little "stolen" vram.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=80675
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nv50_display.c b/drivers/gpu/drm/nouveau/nv50_display.c
index 2293b8ff56c6..f4daf8c55de1 100644
--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@ -1805,12 +1805,14 @@ nv50_head_lut_set(struct nv50_head *head, struct nv50_head_atom *asyh)
 	if ((push = evo_wait(core, 7))) {
 		if (core-&gt;base.user.oclass &lt; G82_DISP_CORE_CHANNEL_DMA) {
 			evo_mthd(push, 0x0840 + (head-&gt;base.index * 0x400), 2);
-			evo_data(push, 0xc0000000);
+			evo_data(push, asyh-&gt;base.depth == 8 ?
+				 0x80000000 : 0xc0000000);
 			evo_data(push, asyh-&gt;lut.offset &gt;&gt; 8);
 		} else
 		if (core-&gt;base.user.oclass &lt; GF110_DISP_CORE_CHANNEL_DMA) {
 			evo_mthd(push, 0x0840 + (head-&gt;base.index * 0x400), 2);
-			evo_data(push, 0xc0000000);
+			evo_data(push, asyh-&gt;base.depth == 8 ?
+				 0x80000000 : 0xc0000000);
 			evo_data(push, asyh-&gt;lut.offset &gt;&gt; 8);
 			evo_mthd(push, 0x085c + (head-&gt;base.index * 0x400), 1);
 			evo_data(push, asyh-&gt;lut.handle);</pre><hr><pre>commit 3a0bc8cb9b102229ad26ae3788cef8c6c5273be1
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Wed Nov 1 03:56:19 2017 +1000

    drm/nouveau/kms: add 8.1Gbps DP link rate
    
    This was already done in dcb.c inside nvkm, but the other parser did not
    get the update.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nouveau_bios.c b/drivers/gpu/drm/nouveau/nouveau_bios.c
index dd6fba55ad5d..c4ef3a0a737e 100644
--- a/drivers/gpu/drm/nouveau/nouveau_bios.c
+++ b/drivers/gpu/drm/nouveau/nouveau_bios.c
@@ -1478,9 +1478,13 @@ parse_dcb20_entry(struct drm_device *dev, struct dcb_table *dcb,
 		case 1:
 			entry-&gt;dpconf.link_bw = 270000;
 			break;
-		default:
+		case 2:
 			entry-&gt;dpconf.link_bw = 540000;
 			break;
+		case 3:
+		default:
+			entry-&gt;dpconf.link_bw = 810000;
+			break;
 		}
 		switch ((conf &amp; 0x0f000000) &gt;&gt; 24) {
 		case 0xf:</pre><hr><pre>commit 194d68dd051c2dd5ac2b522ae16100e774e8d869
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sun Oct 1 13:52:43 2017 -0400

    drm/nouveau/bsp/g92: disable by default
    
    G92's seem to require some additional bit of initialization before the
    BSP engine can work. It feels like clocks are not set up for the
    underlying VLD engine, which means that all commands submitted to the
    xtensa chip end up hanging. VP seems to work fine though.
    
    This still allows people to force-enable the bsp engine if they want to
    play around with it, but makes it harder for the card to hang by
    default.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;
    Cc: stable@vger.kernel.org

diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/bsp/g84.c b/drivers/gpu/drm/nouveau/nvkm/engine/bsp/g84.c
index 8e2e24a74774..44e116f7880d 100644
--- a/drivers/gpu/drm/nouveau/nvkm/engine/bsp/g84.c
+++ b/drivers/gpu/drm/nouveau/nvkm/engine/bsp/g84.c
@@ -39,5 +39,5 @@ int
 g84_bsp_new(struct nvkm_device *device, int index, struct nvkm_engine **pengine)
 {
 	return nvkm_xtensa_new_(&amp;g84_bsp, device, index,
-				true, 0x103000, pengine);
+				device-&gt;chipset != 0x92, 0x103000, pengine);
 }</pre><hr><pre>commit bc60c90f472b6e762ea96ef384072145adc8d4af
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Thu Aug 10 12:13:40 2017 -0400

    drm/nouveau/pci/msi: disable MSI on big-endian platforms by default
    
    It appears that MSI does not work on either G5 PPC nor on a E5500-based
    platform, where other hardware is reported to work fine with MSI.
    
    Both tests were conducted with NV4x hardware, so perhaps other (or even
    this) hardware can be made to work. It's still possible to force-enable
    with config=NvMSI=1 on load.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Cc: stable@vger.kernel.org
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/base.c
index eb9b278198b2..a4cb82495cee 100644
--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pci/base.c
+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pci/base.c
@@ -192,6 +192,10 @@ nvkm_pci_new_(const struct nvkm_pci_func *func, struct nvkm_device *device,
 		}
 	}
 
+#ifdef __BIG_ENDIAN
+	pci-&gt;msi = false;
+#endif
+
 	pci-&gt;msi = nvkm_boolopt(device-&gt;cfgopt, "NvMSI", pci-&gt;msi);
 	if (pci-&gt;msi &amp;&amp; func-&gt;msi_rearm) {
 		pci-&gt;msi = pci_enable_msi(pci-&gt;pdev) == 0;</pre><hr><pre>commit 856718054a1b6f38e085021bbd5b0e74817a8fa6
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Aug 5 22:25:05 2017 -0400

    drm/nouveau/kms/nv04-nv4x: fix exposed format list
    
    drm_crtc_init exposes the XRGB8888 and ARGB8888 formats. In actuality,
    ARGB8888's 32-bit depth messes up some formulas that weren't meant for
    it, and the alpha is fairly meaningless for the primary plane.
    
    The modesetting logic appears to be fully prepared for RGB565 as well as
    XRGB1555 however, as tested with modetest.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv04/crtc.c b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
index 8f689f1f6122..6aa6ee16dcbd 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/crtc.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/crtc.c
@@ -1096,6 +1096,38 @@ static const struct drm_crtc_helper_funcs nv04_crtc_helper_funcs = {
 	.disable = nv_crtc_disable,
 };
 
+static const uint32_t modeset_formats[] = {
+        DRM_FORMAT_XRGB8888,
+        DRM_FORMAT_RGB565,
+        DRM_FORMAT_XRGB1555,
+};
+
+static struct drm_plane *
+create_primary_plane(struct drm_device *dev)
+{
+        struct drm_plane *primary;
+        int ret;
+
+        primary = kzalloc(sizeof(*primary), GFP_KERNEL);
+        if (primary == NULL) {
+                DRM_DEBUG_KMS("Failed to allocate primary plane\n");
+                return NULL;
+        }
+
+        /* possible_crtc's will be filled in later by crtc_init */
+        ret = drm_universal_plane_init(dev, primary, 0,
+                                       &amp;drm_primary_helper_funcs,
+                                       modeset_formats,
+                                       ARRAY_SIZE(modeset_formats), NULL,
+                                       DRM_PLANE_TYPE_PRIMARY, NULL);
+        if (ret) {
+                kfree(primary);
+                primary = NULL;
+        }
+
+        return primary;
+}
+
 int
 nv04_crtc_create(struct drm_device *dev, int crtc_num)
 {
@@ -1114,7 +1146,9 @@ nv04_crtc_create(struct drm_device *dev, int crtc_num)
 	nv_crtc-&gt;save = nv_crtc_save;
 	nv_crtc-&gt;restore = nv_crtc_restore;
 
-	drm_crtc_init(dev, &amp;nv_crtc-&gt;base, &amp;nv04_crtc_funcs);
+	drm_crtc_init_with_planes(dev, &amp;nv_crtc-&gt;base,
+                                  create_primary_plane(dev), NULL,
+                                  &amp;nv04_crtc_funcs, NULL);
 	drm_crtc_helper_add(&amp;nv_crtc-&gt;base, &amp;nv04_crtc_helper_funcs);
 	drm_mode_crtc_set_gamma_size(&amp;nv_crtc-&gt;base, 256);
 </pre><hr><pre>commit 7fa620d577502670741925198b1ee5c55d3a65cf
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Aug 5 22:25:04 2017 -0400

    drm/nouveau/kms/nv10-nv40: add NV21 support to overlay
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv04/overlay.c b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
index 5bd63c2f14a6..c8c2333f24ee 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/overlay.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
@@ -63,6 +63,7 @@ static uint32_t formats[] = {
 	DRM_FORMAT_YUYV,
 	DRM_FORMAT_UYVY,
 	DRM_FORMAT_NV12,
+	DRM_FORMAT_NV21,
 };
 
 /* Sine can be approximated with
@@ -159,16 +160,18 @@ nv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 	nvif_wr32(dev, NV_PVIDEO_POINT_OUT(flip), crtc_y &lt;&lt; 16 | crtc_x);
 	nvif_wr32(dev, NV_PVIDEO_SIZE_OUT(flip), crtc_h &lt;&lt; 16 | crtc_w);
 
-	if (fb-&gt;format-&gt;format != DRM_FORMAT_UYVY)
+	if (fb-&gt;format-&gt;format == DRM_FORMAT_YUYV ||
+	    fb-&gt;format-&gt;format == DRM_FORMAT_NV12)
 		format |= NV_PVIDEO_FORMAT_COLOR_LE_CR8YB8CB8YA8;
-	if (fb-&gt;format-&gt;format == DRM_FORMAT_NV12)
+	if (fb-&gt;format-&gt;format == DRM_FORMAT_NV12 ||
+	    fb-&gt;format-&gt;format == DRM_FORMAT_NV21)
 		format |= NV_PVIDEO_FORMAT_PLANAR;
 	if (nv_plane-&gt;iturbt_709)
 		format |= NV_PVIDEO_FORMAT_MATRIX_ITURBT709;
 	if (nv_plane-&gt;colorkey &amp; (1 &lt;&lt; 24))
 		format |= NV_PVIDEO_FORMAT_DISPLAY_COLOR_KEY;
 
-	if (fb-&gt;format-&gt;format == DRM_FORMAT_NV12) {
+	if (format &amp; NV_PVIDEO_FORMAT_PLANAR) {
 		nvif_wr32(dev, NV_PVIDEO_UVPLANE_BASE(flip), 0);
 		nvif_wr32(dev, NV_PVIDEO_UVPLANE_OFFSET_BUFF(flip),
 			nv_fb-&gt;nvbo-&gt;bo.offset + fb-&gt;offsets[1]);</pre><hr><pre>commit 9a6edc3ac968aca9ce51d16917705a857285286b
Author: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
Date:   Sat Aug 5 22:25:03 2017 -0400

    drm/nouveau/kms/nv04-nv40: improve overlay error detection, fix pitch setting
    
    We were previously setting the pitch based on a perfectly packed buffer.
    This does not necessarily happen. Either modetest started generating
    such buffers recently, or earlier testing only happened with well-picked
    overlay sizes.
    
    While we're at it, beef up and refactor the error state detection.
    
    Signed-off-by: Ilia Mirkin &lt;imirkin@alum.mit.edu&gt;
    Signed-off-by: Ben Skeggs &lt;bskeggs@redhat.com&gt;

diff --git a/drivers/gpu/drm/nouveau/dispnv04/overlay.c b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
index e54944d23268..5bd63c2f14a6 100644
--- a/drivers/gpu/drm/nouveau/dispnv04/overlay.c
+++ b/drivers/gpu/drm/nouveau/dispnv04/overlay.c
@@ -89,6 +89,26 @@ cos_mul(int degrees, int factor)
 	return sin_mul((degrees + 90) % 360, factor);
 }
 
+static int
+verify_scaling(const struct drm_framebuffer *fb, uint8_t shift,
+               uint32_t src_x, uint32_t src_y, uint32_t src_w, uint32_t src_h,
+               uint32_t crtc_w, uint32_t crtc_h)
+{
+	if (crtc_w &lt; (src_w &gt;&gt; shift) || crtc_h &lt; (src_h &gt;&gt; shift)) {
+		DRM_DEBUG_KMS("Unsuitable framebuffer scaling: %dx%d -&gt; %dx%d\n",
+			      src_w, src_h, crtc_w, crtc_h);
+		return -ERANGE;
+	}
+
+	if (src_x != 0 || src_y != 0) {
+		DRM_DEBUG_KMS("Unsuitable framebuffer offset: %d,%d\n",
+                              src_x, src_y);
+		return -ERANGE;
+	}
+
+	return 0;
+}
+
 static int
 nv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 		  struct drm_framebuffer *fb, int crtc_x, int crtc_y,
@@ -107,7 +127,9 @@ nv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 	bool flip = nv_plane-&gt;flip;
 	int soff = NV_PCRTC0_SIZE * nv_crtc-&gt;index;
 	int soff2 = NV_PCRTC0_SIZE * !nv_crtc-&gt;index;
-	int format, ret;
+	unsigned shift = drm-&gt;client.device.info.chipset &gt;= 0x30 ? 1 : 3;
+	unsigned format = 0;
+	int ret;
 
 	/* Source parameters given in 16.16 fixed point, ignore fractional. */
 	src_x &gt;&gt;= 16;
@@ -115,18 +137,9 @@ nv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 	src_w &gt;&gt;= 16;
 	src_h &gt;&gt;= 16;
 
-	format = ALIGN(src_w * 4, 0x100);
-
-	if (format &gt; 0xffff)
-		return -ERANGE;
-
-	if (drm-&gt;client.device.info.chipset &gt;= 0x30) {
-		if (crtc_w &lt; (src_w &gt;&gt; 1) || crtc_h &lt; (src_h &gt;&gt; 1))
-			return -ERANGE;
-	} else {
-		if (crtc_w &lt; (src_w &gt;&gt; 3) || crtc_h &lt; (src_h &gt;&gt; 3))
-			return -ERANGE;
-	}
+	ret = verify_scaling(fb, shift, 0, 0, src_w, src_h, crtc_w, crtc_h);
+	if (ret)
+		return ret;
 
 	ret = nouveau_bo_pin(nv_fb-&gt;nvbo, TTM_PL_FLAG_VRAM, false);
 	if (ret)
@@ -160,7 +173,7 @@ nv10_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 		nvif_wr32(dev, NV_PVIDEO_UVPLANE_OFFSET_BUFF(flip),
 			nv_fb-&gt;nvbo-&gt;bo.offset + fb-&gt;offsets[1]);
 	}
-	nvif_wr32(dev, NV_PVIDEO_FORMAT(flip), format);
+	nvif_wr32(dev, NV_PVIDEO_FORMAT(flip), format | fb-&gt;pitches[0]);
 	nvif_wr32(dev, NV_PVIDEO_STOP, 0);
 	/* TODO: wait for vblank? */
 	nvif_wr32(dev, NV_PVIDEO_BUFFER, flip ? 0x10 : 0x1);
@@ -357,7 +370,7 @@ nv04_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 	struct nouveau_bo *cur = nv_plane-&gt;cur;
 	uint32_t overlay = 1;
 	int brightness = (nv_plane-&gt;brightness - 512) * 62 / 512;
-	int pitch, ret, i;
+	int ret, i;
 
 	/* Source parameters given in 16.16 fixed point, ignore fractional. */
 	src_x &gt;&gt;= 16;
@@ -365,17 +378,9 @@ nv04_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 	src_w &gt;&gt;= 16;
 	src_h &gt;&gt;= 16;
 
-	pitch = ALIGN(src_w * 4, 0x100);
-
-	if (pitch &gt; 0xffff)
-		return -ERANGE;
-
-	/* TODO: Compute an offset? Not sure how to do this for YUYV. */
-	if (src_x != 0 || src_y != 0)
-		return -ERANGE;
-
-	if (crtc_w &lt; src_w || crtc_h &lt; src_h)
-		return -ERANGE;
+	ret = verify_scaling(fb, 0, src_x, src_y, src_w, src_h, crtc_w, crtc_h);
+	if (ret)
+		return ret;
 
 	ret = nouveau_bo_pin(nv_fb-&gt;nvbo, TTM_PL_FLAG_VRAM, false);
 	if (ret)
@@ -389,8 +394,9 @@ nv04_update_plane(struct drm_plane *plane, struct drm_crtc *crtc,
 
 	for (i = 0; i &lt; 2; i++) {
 		nvif_wr32(dev, NV_PVIDEO_BUFF0_START_ADDRESS + 4 * i,
-			nv_fb-&gt;nvbo-&gt;bo.offset);
-		nvif_wr32(dev, NV_PVIDEO_BUFF0_PITCH_LENGTH + 4 * i, pitch);
+			  nv_fb-&gt;nvbo-&gt;bo.offset);
+		nvif_wr32(dev, NV_PVIDEO_BUFF0_PITCH_LENGTH + 4 * i,
+			  fb-&gt;pitches[0]);
 		nvif_wr32(dev, NV_PVIDEO_BUFF0_OFFSET + 4 * i, 0);
 	}
 	nvif_wr32(dev, NV_PVIDEO_WINDOW_START, crtc_y &lt;&lt; 16 | crtc_x);</pre>
    <div class="pagination">
        <a href='1_135.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><span>[136]</span><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_137.html'>Next&gt;&gt;</a>
    <div>
</body>
