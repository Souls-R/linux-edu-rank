<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Virginia, Charlottesville</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Virginia, Charlottesville</h1>
    <div class="pagination">
        <a href='3_82.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><span>[83]</span>
    </div>
    <hr>
    <pre>commit 6a98d36e87a0b38d711d580b5fc9dbba17f68dfc
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Mon Mar 16 22:03:45 2009 -0400

    Staging: comedi: Add spaces around parens as requested by checkpatch.pl
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/mite.h b/drivers/staging/comedi/drivers/mite.h
index 37f397b340c5..bca9f3af7adb 100644
--- a/drivers/staging/comedi/drivers/mite.h
+++ b/drivers/staging/comedi/drivers/mite.h
@@ -33,7 +33,7 @@
 #define PCIMIO_COMPAT
 
 #ifdef DEBUG_MITE
-#define MDPRINTK(format, args...)	printk(format , ## args )
+#define MDPRINTK(format, args...)	printk(format , ## args)
 #else
 #define MDPRINTK(format, args...)
 #endif
diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index a3763ade9c96..71309d3e1227 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -345,8 +345,8 @@ static void CountersInit(comedi_device *dev);
 /*  Counter objects constructor. */
 
 /*  Counter overflow/index event flag masks for RDMISC2. */
-#define INDXMASK(C)		( 1 &lt;&lt; ( ( (C) &gt; 2 ) ? ( (C) * 2 - 1 ) : ( (C) * 2 +  4 ) ) )
-#define OVERMASK(C)		( 1 &lt;&lt; ( ( (C) &gt; 2 ) ? ( (C) * 2 + 5 ) : ( (C) * 2 + 10 ) ) )
+#define INDXMASK(C)		(1 &lt;&lt; (((C) &gt; 2) ? ((C) * 2 - 1) : ((C) * 2 +  4)))
+#define OVERMASK(C)		(1 &lt;&lt; (((C) &gt; 2) ? ((C) * 2 + 5) : ((C) * 2 + 10)))
 #define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }
 
 /*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
@@ -454,11 +454,11 @@ static enc_private enc_private_data[] = {
 
 /*  enab/disable a function or test status bit(s) that are accessed */
 /*  through Main Control Registers 1 or 2. */
-#define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) &lt;&lt; 16 ) | (uint32_t)( CTRLWORD ), devpriv-&gt;base_addr+( REGADRS ) )
+#define MC_ENABLE(REGADRS, CTRLWORD)	writel(((uint32_t)(CTRLWORD) &lt;&lt; 16) | (uint32_t)(CTRLWORD), devpriv-&gt;base_addr+(REGADRS))
 
-#define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) &lt;&lt; 16 , devpriv-&gt;base_addr+( REGADRS ) )
+#define MC_DISABLE(REGADRS, CTRLWORD)	writel((uint32_t)(CTRLWORD) &lt;&lt; 16 , devpriv-&gt;base_addr+(REGADRS))
 
-#define MC_TEST( REGADRS, CTRLWORD )	( ( readl(devpriv-&gt;base_addr+( REGADRS )) &amp; CTRLWORD ) != 0 )
+#define MC_TEST(REGADRS, CTRLWORD)	((readl(devpriv-&gt;base_addr+(REGADRS)) &amp; CTRLWORD) != 0)
 
 /* #define WR7146(REGARDS,CTRLWORD)
     writel(CTRLWORD,(uint32_t)(devpriv-&gt;base_addr+(REGARDS))) */
@@ -468,16 +468,16 @@ static enc_private enc_private_data[] = {
     readl((uint32_t)(devpriv-&gt;base_addr+(REGARDS))) */
 #define RR7146(REGARDS)		readl(devpriv-&gt;base_addr+(REGARDS))
 
-#define BUGFIX_STREG(REGADRS)   ( REGADRS - 4 )
+#define BUGFIX_STREG(REGADRS)   (REGADRS - 4)
 
 /*  Write a time slot control record to TSL2. */
-#define VECTPORT( VECTNUM )		(P_TSL2 + ( (VECTNUM) &lt;&lt; 2 ))
-#define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
+#define VECTPORT(VECTNUM)		(P_TSL2 + ((VECTNUM) &lt;&lt; 2))
+#define SETVECT(VECTNUM, VECTVAL)	WR7146(VECTPORT(VECTNUM), (VECTVAL))
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR, VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
-#define I2C_B1(ATTR, VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
-#define I2C_B0(ATTR, VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
+#define I2C_B2(ATTR, VAL)	(((ATTR) &lt;&lt; 6) | ((VAL) &lt;&lt; 24))
+#define I2C_B1(ATTR, VAL)	(((ATTR) &lt;&lt; 4) | ((VAL) &lt;&lt; 16))
+#define I2C_B0(ATTR, VAL)	(((ATTR) &lt;&lt; 2) | ((VAL) &lt;&lt;  8))
 
 static const comedi_lrange s626_range_table = { 2, {
 			RANGE(-5, 5),
@@ -2353,7 +2353,7 @@ static void s626_timer_load(comedi_device *dev, enc_private *k, int tick)
 /* ***********  DAC FUNCTIONS *********** */
 
 /*  Slot 0 base settings. */
-#define VECT0	( XSD2 | RSD3 | SIB_A2 )
+#define VECT0	(XSD2 | RSD3 | SIB_A2)
 /*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
 /*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index c158110aa47c..c48957be2e1c 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -173,7 +173,7 @@
 
 /*  RPS clock parameters. */
 #define RPSCLK_SCALAR		8	/*  This is apparent ratio of PCI/RPS clks (undocumented!!). */
-#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	/*  Number of RPS clocks in one microsecond. */
+#define RPSCLK_PER_US		(33 / RPSCLK_SCALAR)	/*  Number of RPS clocks in one microsecond. */
 
 /*  Event counter source addresses. */
 #define SBA_RPS_A0		0x27	/*  Time of RPS0 busy, in PCI clocks. */
@@ -377,14 +377,14 @@
 
 #if PLATFORM == INTEL		/* Base ACON1 config: always run A1 based
 				 * on TSL1. */
-#define ACON1_BASE		( WS_MODES | A1_RUN )
+#define ACON1_BASE		(WS_MODES | A1_RUN)
 #elif PLATFORM == MOTOROLA
-#define ACON1_BASE		( WS_MODES | A1_RUN | A1_SWAP | A2_SWAP )
+#define ACON1_BASE		(WS_MODES | A1_RUN | A1_SWAP | A2_SWAP)
 #endif
 
 #define ACON1_ADCSTART		ACON1_BASE	/* Start ADC: run A1
 						 *  based on TSL1. */
-#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )
+#define ACON1_DACSTART		(ACON1_BASE | A2_RUN)
 /* Start transmit to DAC: run A2 based on TSL2. */
 #define ACON1_DACSTOP		ACON1_BASE	/*  Halt A2. */
 
@@ -398,7 +398,7 @@
 #define ACON2_XORMASK		0x000C0000	/*  XOR mask for ACON2 */
 						/*  active-low bits. */
 
-#define ACON2_INIT		( ACON2_XORMASK ^ ( A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE ) )
+#define ACON2_INIT		(ACON2_XORMASK ^ (A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE))
 
 /*  Bit masks for timeslot records. */
 #define WS1		     	0x40000000	/*  WS output to assert. */
@@ -452,7 +452,7 @@
 /*  I2C manifest constants. */
 
 /*  Max retries to wait for EEPROM write. */
-#define I2C_RETRIES		( I2C_WRTIME * I2C_BITRATE / 9.0 )
+#define I2C_RETRIES		(I2C_WRTIME * I2C_BITRATE / 9.0)
 #define I2C_ERR			0x0002	/*  I2C control/status */
 						/*  flag ERROR. */
 #define I2C_BUSY		0x0001	/*  I2C control/status */
@@ -464,15 +464,15 @@
 #define I2C_ATTRNOP		0x0	/*  I2C attribute NOP. */
 
 /*  I2C read command  | EEPROM address. */
-#define I2CR			( devpriv-&gt;I2CAdrs | 1 )
+#define I2CR			(devpriv-&gt;I2CAdrs | 1)
 
 /*  I2C write command | EEPROM address. */
-#define I2CW			( devpriv-&gt;I2CAdrs )
+#define I2CW			(devpriv-&gt;I2CAdrs)
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR, VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
-#define I2C_B1(ATTR, VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
-#define I2C_B0(ATTR, VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
+#define I2C_B2(ATTR, VAL)	(((ATTR) &lt;&lt; 6) | ((VAL) &lt;&lt; 24))
+#define I2C_B1(ATTR, VAL)	(((ATTR) &lt;&lt; 4) | ((VAL) &lt;&lt; 16))
+#define I2C_B0(ATTR, VAL)	(((ATTR) &lt;&lt; 2) | ((VAL) &lt;&lt;  8))
 
 /* oldest */
 #define P_DEBICFGq              0x007C	/*  DEBI configuration. */
@@ -490,16 +490,16 @@
 #define DEBI_PAGE_DISABLEQ	0x00000000	/*  paging disable */
 
 /*  DEBI command constants. */
-#define DEBI_CMD_SIZE16		( 2 &lt;&lt; 17 )	/*  Transfer size is */
+#define DEBI_CMD_SIZE16		(2 &lt;&lt; 17)	/*  Transfer size is */
 						/*  always 2 bytes. */
 #define DEBI_CMD_READ		0x00010000	/*  Read operation. */
 #define DEBI_CMD_WRITE		0x00000000	/*  Write operation. */
 
 /*  Read immediate 2 bytes. */
-#define DEBI_CMD_RDWORD		( DEBI_CMD_READ  | DEBI_CMD_SIZE16 )
+#define DEBI_CMD_RDWORD		(DEBI_CMD_READ  | DEBI_CMD_SIZE16)
 
 /*  Write immediate 2 bytes. */
-#define DEBI_CMD_WRWORD		( DEBI_CMD_WRITE | DEBI_CMD_SIZE16 )
+#define DEBI_CMD_WRWORD		(DEBI_CMD_WRITE | DEBI_CMD_SIZE16)
 
 /*  DEBI configuration constants. */
 #define DEBI_CFG_XIRQ_EN	0x80000000	/*  enab external */
@@ -681,29 +681,29 @@
 
 /*  Bit field masks for CRA and CRB. */
 
-#define CRAMSK_INDXSRC_B	( (uint16_t)( 3 &lt;&lt; CRABIT_INDXSRC_B) )
-#define CRAMSK_CLKSRC_B		( (uint16_t)( 3 &lt;&lt; CRABIT_CLKSRC_B) )
-#define CRAMSK_INDXPOL_A	( (uint16_t)( 1 &lt;&lt; CRABIT_INDXPOL_A) )
-#define CRAMSK_LOADSRC_A	( (uint16_t)( 3 &lt;&lt; CRABIT_LOADSRC_A) )
-#define CRAMSK_CLKMULT_A	( (uint16_t)( 3 &lt;&lt; CRABIT_CLKMULT_A) )
-#define CRAMSK_INTSRC_A		( (uint16_t)( 3 &lt;&lt; CRABIT_INTSRC_A) )
-#define CRAMSK_CLKPOL_A		( (uint16_t)( 3 &lt;&lt; CRABIT_CLKPOL_A) )
-#define CRAMSK_INDXSRC_A	( (uint16_t)( 3 &lt;&lt; CRABIT_INDXSRC_A) )
-#define CRAMSK_CLKSRC_A		( (uint16_t)( 3 &lt;&lt; CRABIT_CLKSRC_A) )
-
-#define CRBMSK_INTRESETCMD	( (uint16_t)( 1 &lt;&lt; CRBBIT_INTRESETCMD) )
-#define CRBMSK_INTRESET_B	( (uint16_t)( 1 &lt;&lt; CRBBIT_INTRESET_B) )
-#define CRBMSK_INTRESET_A	( (uint16_t)( 1 &lt;&lt; CRBBIT_INTRESET_A) )
-#define CRBMSK_CLKENAB_A	( (uint16_t)( 1 &lt;&lt; CRBBIT_CLKENAB_A) )
-#define CRBMSK_INTSRC_B		( (uint16_t)( 3 &lt;&lt; CRBBIT_INTSRC_B) )
-#define CRBMSK_LATCHSRC		( (uint16_t)( 3 &lt;&lt; CRBBIT_LATCHSRC) )
-#define CRBMSK_LOADSRC_B	( (uint16_t)( 3 &lt;&lt; CRBBIT_LOADSRC_B) )
-#define CRBMSK_CLKMULT_B	( (uint16_t)( 3 &lt;&lt; CRBBIT_CLKMULT_B) )
-#define CRBMSK_CLKENAB_B	( (uint16_t)( 1 &lt;&lt; CRBBIT_CLKENAB_B) )
-#define CRBMSK_INDXPOL_B	( (uint16_t)( 1 &lt;&lt; CRBBIT_INDXPOL_B) )
-#define CRBMSK_CLKPOL_B		( (uint16_t)( 1 &lt;&lt; CRBBIT_CLKPOL_B) )
-
-#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	/*  Interrupt reset control bits. */
+#define CRAMSK_INDXSRC_B	((uint16_t)(3 &lt;&lt; CRABIT_INDXSRC_B))
+#define CRAMSK_CLKSRC_B		((uint16_t)(3 &lt;&lt; CRABIT_CLKSRC_B))
+#define CRAMSK_INDXPOL_A	((uint16_t)(1 &lt;&lt; CRABIT_INDXPOL_A))
+#define CRAMSK_LOADSRC_A	((uint16_t)(3 &lt;&lt; CRABIT_LOADSRC_A))
+#define CRAMSK_CLKMULT_A	((uint16_t)(3 &lt;&lt; CRABIT_CLKMULT_A))
+#define CRAMSK_INTSRC_A		((uint16_t)(3 &lt;&lt; CRABIT_INTSRC_A))
+#define CRAMSK_CLKPOL_A		((uint16_t)(3 &lt;&lt; CRABIT_CLKPOL_A))
+#define CRAMSK_INDXSRC_A	((uint16_t)(3 &lt;&lt; CRABIT_INDXSRC_A))
+#define CRAMSK_CLKSRC_A		((uint16_t)(3 &lt;&lt; CRABIT_CLKSRC_A))
+
+#define CRBMSK_INTRESETCMD	((uint16_t)(1 &lt;&lt; CRBBIT_INTRESETCMD))
+#define CRBMSK_INTRESET_B	((uint16_t)(1 &lt;&lt; CRBBIT_INTRESET_B))
+#define CRBMSK_INTRESET_A	((uint16_t)(1 &lt;&lt; CRBBIT_INTRESET_A))
+#define CRBMSK_CLKENAB_A	((uint16_t)(1 &lt;&lt; CRBBIT_CLKENAB_A))
+#define CRBMSK_INTSRC_B		((uint16_t)(3 &lt;&lt; CRBBIT_INTSRC_B))
+#define CRBMSK_LATCHSRC		((uint16_t)(3 &lt;&lt; CRBBIT_LATCHSRC))
+#define CRBMSK_LOADSRC_B	((uint16_t)(3 &lt;&lt; CRBBIT_LOADSRC_B))
+#define CRBMSK_CLKMULT_B	((uint16_t)(3 &lt;&lt; CRBBIT_CLKMULT_B))
+#define CRBMSK_CLKENAB_B	((uint16_t)(1 &lt;&lt; CRBBIT_CLKENAB_B))
+#define CRBMSK_INDXPOL_B	((uint16_t)(1 &lt;&lt; CRBBIT_INDXPOL_B))
+#define CRBMSK_CLKPOL_B		((uint16_t)(1 &lt;&lt; CRBBIT_CLKPOL_B))
+
+#define CRBMSK_INTCTRL		(CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B)	/*  Interrupt reset control bits. */
 
 /*  Bit field positions for standardized SETUP structure. */
 
@@ -719,15 +719,15 @@
 
 /*  Bit field masks for standardized SETUP structure. */
 
-#define STDMSK_INTSRC		( (uint16_t)( 3 &lt;&lt; STDBIT_INTSRC   ) )
-#define STDMSK_LATCHSRC		( (uint16_t)( 3 &lt;&lt; STDBIT_LATCHSRC ) )
-#define STDMSK_LOADSRC		( (uint16_t)( 3 &lt;&lt; STDBIT_LOADSRC  ) )
-#define STDMSK_INDXSRC		( (uint16_t)( 1 &lt;&lt; STDBIT_INDXSRC  ) )
-#define STDMSK_INDXPOL		( (uint16_t)( 1 &lt;&lt; STDBIT_INDXPOL  ) )
-#define STDMSK_CLKSRC		( (uint16_t)( 3 &lt;&lt; STDBIT_CLKSRC   ) )
-#define STDMSK_CLKPOL		( (uint16_t)( 1 &lt;&lt; STDBIT_CLKPOL   ) )
-#define STDMSK_CLKMULT		( (uint16_t)( 3 &lt;&lt; STDBIT_CLKMULT  ) )
-#define STDMSK_CLKENAB		( (uint16_t)( 1 &lt;&lt; STDBIT_CLKENAB  ) )
+#define STDMSK_INTSRC		((uint16_t)(3 &lt;&lt; STDBIT_INTSRC))
+#define STDMSK_LATCHSRC		((uint16_t)(3 &lt;&lt; STDBIT_LATCHSRC))
+#define STDMSK_LOADSRC		((uint16_t)(3 &lt;&lt; STDBIT_LOADSRC))
+#define STDMSK_INDXSRC		((uint16_t)(1 &lt;&lt; STDBIT_INDXSRC))
+#define STDMSK_INDXPOL		((uint16_t)(1 &lt;&lt; STDBIT_INDXPOL))
+#define STDMSK_CLKSRC		((uint16_t)(3 &lt;&lt; STDBIT_CLKSRC))
+#define STDMSK_CLKPOL		((uint16_t)(1 &lt;&lt; STDBIT_CLKPOL))
+#define STDMSK_CLKMULT		((uint16_t)(3 &lt;&lt; STDBIT_CLKMULT))
+#define STDMSK_CLKENAB		((uint16_t)(1 &lt;&lt; STDBIT_CLKENAB))
 
 
 /* typedef struct indexCounter */
diff --git a/drivers/staging/comedi/kcomedilib/kcomedilib_main.c b/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
index e758e4e8c91b..7133f2f2607c 100644
--- a/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
+++ b/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
@@ -57,11 +57,11 @@ comedi_t *comedi_open(const char *filename)
 		return NULL;
 
 	dev_file_info = comedi_get_device_file_info(minor);
-	if(dev_file_info == NULL)
+	if (dev_file_info == NULL)
 		return NULL;
 	dev = dev_file_info-&gt;device;
 
-	if(dev == NULL || !dev-&gt;attached)
+	if (dev == NULL || !dev-&gt;attached)
 		return NULL;
 
 	if (!try_module_get(dev-&gt;driver-&gt;module))
@@ -79,11 +79,11 @@ comedi_t *comedi_open_old(unsigned int minor)
 		return NULL;
 
 	dev_file_info = comedi_get_device_file_info(minor);
-	if(dev_file_info == NULL)
+	if (dev_file_info == NULL)
 		return NULL;
 	dev = dev_file_info-&gt;device;
 
-	if(dev == NULL || !dev-&gt;attached)
+	if (dev == NULL || !dev-&gt;attached)
 		return NULL;
 
 	return (comedi_t *) dev;
diff --git a/drivers/staging/comedi/proc.c b/drivers/staging/comedi/proc.c
index 031004ebc6ec..100877362577 100644
--- a/drivers/staging/comedi/proc.c
+++ b/drivers/staging/comedi/proc.c
@@ -55,7 +55,7 @@ int comedi_read_procmem(char *buf, char **start, off_t offset, int len,
 		struct comedi_device_file_info *dev_file_info = comedi_get_device_file_info(i);
 		comedi_device *dev;
 
-		if(dev_file_info == NULL) continue;
+		if (dev_file_info == NULL) continue;
 		dev = dev_file_info-&gt;device;
 
 		if (dev-&gt;attached) {</pre><hr><pre>commit f7266a48a10d76ff512d5eb44aa18364ee203da4
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Mon Mar 16 22:03:40 2009 -0400

    Staging: comedi: Add spaces around colons as needed
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers/icp_multi.c b/drivers/staging/comedi/drivers/icp_multi.c
index ef8f783ba4e4..aefd1c16ab2b 100644
--- a/drivers/staging/comedi/drivers/icp_multi.c
+++ b/drivers/staging/comedi/drivers/icp_multi.c
@@ -175,12 +175,12 @@ static const boardtype boardtypes[] = {
 
 static comedi_driver driver_icp_multi = {
       driver_name:"icp_multi",
-      module:THIS_MODULE,
-      attach:icp_multi_attach,
-      detach:icp_multi_detach,
-      num_names:n_boardtypes,
+      module : THIS_MODULE,
+      attach : icp_multi_attach,
+      detach : icp_multi_detach,
+      num_names : n_boardtypes,
       board_name:&amp;boardtypes[0].name,
-      offset:sizeof(boardtype),
+      offset : sizeof(boardtype),
 };
 
 COMEDI_INITCLEANUP(driver_icp_multi);
diff --git a/drivers/staging/comedi/drivers/me4000.c b/drivers/staging/comedi/drivers/me4000.c
index 3aafedecf7ed..c1f10b89a831 100644
--- a/drivers/staging/comedi/drivers/me4000.c
+++ b/drivers/staging/comedi/drivers/me4000.c
@@ -122,9 +122,9 @@ static int me4000_attach(comedi_device *dev, comedi_devconfig *it);
 static int me4000_detach(comedi_device *dev);
 static comedi_driver driver_me4000 = {
       driver_name:"me4000",
-      module:THIS_MODULE,
-      attach:me4000_attach,
-      detach:me4000_detach,
+      module : THIS_MODULE,
+      attach : me4000_attach,
+      detach : me4000_detach,
 };
 
 /*-----------------------------------------------------------------------------
diff --git a/drivers/staging/comedi/drivers/rtd520.c b/drivers/staging/comedi/drivers/rtd520.c
index 326dd2f1b840..08e3dde67f8c 100644
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -279,7 +279,7 @@ typedef struct rtdBoard_struct {
 static const rtdBoard rtd520Boards[] = {
 	{
 	      name:	"DM7520",
-	      device_id:0x7520,
+	      device_id : 0x7520,
 	      aiChans:	16,
 	      aiBits:	12,
 	      aiMaxGain:32,
@@ -288,7 +288,7 @@ static const rtdBoard rtd520Boards[] = {
 		},
 	{
 	      name:	"PCI4520",
-	      device_id:0x4520,
+	      device_id : 0x4520,
 	      aiChans:	16,
 	      aiBits:	12,
 	      aiMaxGain:128,
@@ -685,9 +685,9 @@ static int rtd_detach(comedi_device *dev);
 
 static comedi_driver rtd520Driver = {
       driver_name: DRV_NAME,
-      module:THIS_MODULE,
-      attach:rtd_attach,
-      detach:rtd_detach,
+      module : THIS_MODULE,
+      attach : rtd_attach,
+      detach : rtd_detach,
 };
 
 static int rtd_ai_rinsn(comedi_device *dev, comedi_subdevice *s,
diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 0c1f5297fe2f..a3763ade9c96 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -96,13 +96,13 @@ typedef struct s626_board_struct {
 static const s626_board s626_boards[] = {
 	{
 	      name:	"s626",
-	      ai_chans:S626_ADC_CHANNELS,
+	      ai_chans : S626_ADC_CHANNELS,
 	      ai_bits:	14,
-	      ao_chans:S626_DAC_CHANNELS,
+	      ao_chans : S626_DAC_CHANNELS,
 	      ao_bits:	13,
-	      dio_chans:S626_DIO_CHANNELS,
-	      dio_banks:S626_DIO_BANKS,
-	      enc_chans:S626_ENCODER_CHANNELS,
+	      dio_chans : S626_DIO_CHANNELS,
+	      dio_banks : S626_DIO_BANKS,
+	      enc_chans : S626_ENCODER_CHANNELS,
 		}
 };
 
@@ -123,9 +123,9 @@ static int s626_detach(comedi_device *dev);
 
 static comedi_driver driver_s626 = {
       driver_name:"s626",
-      module:THIS_MODULE,
-      attach:s626_attach,
-      detach:s626_detach,
+      module : THIS_MODULE,
+      attach : s626_attach,
+      detach : s626_detach,
 };
 
 typedef struct {
@@ -174,38 +174,38 @@ typedef struct {
 
 static dio_private dio_private_A = {
       RDDIn:LP_RDDINA,
-      WRDOut:LP_WRDOUTA,
-      RDEdgSel:LP_RDEDGSELA,
-      WREdgSel:LP_WREDGSELA,
-      RDCapSel:LP_RDCAPSELA,
-      WRCapSel:LP_WRCAPSELA,
-      RDCapFlg:LP_RDCAPFLGA,
-      RDIntSel:LP_RDINTSELA,
-      WRIntSel:LP_WRINTSELA,
+      WRDOut : LP_WRDOUTA,
+      RDEdgSel : LP_RDEDGSELA,
+      WREdgSel : LP_WREDGSELA,
+      RDCapSel : LP_RDCAPSELA,
+      WRCapSel : LP_WRCAPSELA,
+      RDCapFlg : LP_RDCAPFLGA,
+      RDIntSel : LP_RDINTSELA,
+      WRIntSel : LP_WRINTSELA,
 };
 
 static dio_private dio_private_B = {
       RDDIn:LP_RDDINB,
-      WRDOut:LP_WRDOUTB,
-      RDEdgSel:LP_RDEDGSELB,
-      WREdgSel:LP_WREDGSELB,
-      RDCapSel:LP_RDCAPSELB,
-      WRCapSel:LP_WRCAPSELB,
-      RDCapFlg:LP_RDCAPFLGB,
-      RDIntSel:LP_RDINTSELB,
-      WRIntSel:LP_WRINTSELB,
+      WRDOut : LP_WRDOUTB,
+      RDEdgSel : LP_RDEDGSELB,
+      WREdgSel : LP_WREDGSELB,
+      RDCapSel : LP_RDCAPSELB,
+      WRCapSel : LP_WRCAPSELB,
+      RDCapFlg : LP_RDCAPFLGB,
+      RDIntSel : LP_RDINTSELB,
+      WRIntSel : LP_WRINTSELB,
 };
 
 static dio_private dio_private_C = {
       RDDIn:LP_RDDINC,
-      WRDOut:LP_WRDOUTC,
-      RDEdgSel:LP_RDEDGSELC,
-      WREdgSel:LP_WREDGSELC,
-      RDCapSel:LP_RDCAPSELC,
-      WRCapSel:LP_WRCAPSELC,
-      RDCapFlg:LP_RDCAPFLGC,
-      RDIntSel:LP_RDINTSELC,
-      WRIntSel:LP_WRINTSELC,
+      WRDOut : LP_WRDOUTC,
+      RDEdgSel : LP_RDEDGSELC,
+      WREdgSel : LP_WREDGSELC,
+      RDCapSel : LP_RDCAPSELC,
+      WRCapSel : LP_WRCAPSELC,
+      RDCapFlg : LP_RDCAPFLGC,
+      RDIntSel : LP_RDINTSELC,
+      WRIntSel : LP_WRINTSELC,
 };
 
 /* to group dio devices (48 bits mask and data are not allowed ???)
@@ -356,99 +356,99 @@ static void CountersInit(comedi_device *dev);
 static enc_private enc_private_data[] = {
 	{
 	      GetEnable:GetEnable_A,
-	      GetIntSrc:GetIntSrc_A,
-	      GetLoadTrig:GetLoadTrig_A,
+	      GetIntSrc : GetIntSrc_A,
+	      GetLoadTrig : GetLoadTrig_A,
 	      GetMode:	GetMode_A,
-	      PulseIndex:PulseIndex_A,
-	      SetEnable:SetEnable_A,
-	      SetIntSrc:SetIntSrc_A,
-	      SetLoadTrig:SetLoadTrig_A,
+	      PulseIndex : PulseIndex_A,
+	      SetEnable : SetEnable_A,
+	      SetIntSrc : SetIntSrc_A,
+	      SetLoadTrig : SetLoadTrig_A,
 	      SetMode:	SetMode_A,
-	      ResetCapFlags:ResetCapFlags_A,
+	      ResetCapFlags : ResetCapFlags_A,
 	      MyCRA:	LP_CR0A,
 	      MyCRB:	LP_CR0B,
-	      MyLatchLsw:LP_CNTR0ALSW,
-	      MyEventBits:EVBITS(0),
+	      MyLatchLsw : LP_CNTR0ALSW,
+	      MyEventBits : EVBITS(0),
 		},
 	{
 	      GetEnable:GetEnable_A,
-	      GetIntSrc:GetIntSrc_A,
-	      GetLoadTrig:GetLoadTrig_A,
+	      GetIntSrc : GetIntSrc_A,
+	      GetLoadTrig : GetLoadTrig_A,
 	      GetMode:	GetMode_A,
-	      PulseIndex:PulseIndex_A,
-	      SetEnable:SetEnable_A,
-	      SetIntSrc:SetIntSrc_A,
-	      SetLoadTrig:SetLoadTrig_A,
+	      PulseIndex : PulseIndex_A,
+	      SetEnable : SetEnable_A,
+	      SetIntSrc : SetIntSrc_A,
+	      SetLoadTrig : SetLoadTrig_A,
 	      SetMode:	SetMode_A,
-	      ResetCapFlags:ResetCapFlags_A,
+	      ResetCapFlags : ResetCapFlags_A,
 	      MyCRA:	LP_CR1A,
 	      MyCRB:	LP_CR1B,
-	      MyLatchLsw:LP_CNTR1ALSW,
-	      MyEventBits:EVBITS(1),
+	      MyLatchLsw : LP_CNTR1ALSW,
+	      MyEventBits : EVBITS(1),
 		},
 	{
 	      GetEnable:GetEnable_A,
-	      GetIntSrc:GetIntSrc_A,
-	      GetLoadTrig:GetLoadTrig_A,
+	      GetIntSrc : GetIntSrc_A,
+	      GetLoadTrig : GetLoadTrig_A,
 	      GetMode:	GetMode_A,
-	      PulseIndex:PulseIndex_A,
-	      SetEnable:SetEnable_A,
-	      SetIntSrc:SetIntSrc_A,
-	      SetLoadTrig:SetLoadTrig_A,
+	      PulseIndex : PulseIndex_A,
+	      SetEnable : SetEnable_A,
+	      SetIntSrc : SetIntSrc_A,
+	      SetLoadTrig : SetLoadTrig_A,
 	      SetMode:	SetMode_A,
-	      ResetCapFlags:ResetCapFlags_A,
+	      ResetCapFlags : ResetCapFlags_A,
 	      MyCRA:	LP_CR2A,
 	      MyCRB:	LP_CR2B,
-	      MyLatchLsw:LP_CNTR2ALSW,
-	      MyEventBits:EVBITS(2),
+	      MyLatchLsw : LP_CNTR2ALSW,
+	      MyEventBits : EVBITS(2),
 		},
 	{
 	      GetEnable:GetEnable_B,
-	      GetIntSrc:GetIntSrc_B,
-	      GetLoadTrig:GetLoadTrig_B,
+	      GetIntSrc : GetIntSrc_B,
+	      GetLoadTrig : GetLoadTrig_B,
 	      GetMode:	GetMode_B,
-	      PulseIndex:PulseIndex_B,
-	      SetEnable:SetEnable_B,
-	      SetIntSrc:SetIntSrc_B,
-	      SetLoadTrig:SetLoadTrig_B,
+	      PulseIndex : PulseIndex_B,
+	      SetEnable : SetEnable_B,
+	      SetIntSrc : SetIntSrc_B,
+	      SetLoadTrig : SetLoadTrig_B,
 	      SetMode:	SetMode_B,
-	      ResetCapFlags:ResetCapFlags_B,
+	      ResetCapFlags : ResetCapFlags_B,
 	      MyCRA:	LP_CR0A,
 	      MyCRB:	LP_CR0B,
-	      MyLatchLsw:LP_CNTR0BLSW,
-	      MyEventBits:EVBITS(3),
+	      MyLatchLsw : LP_CNTR0BLSW,
+	      MyEventBits : EVBITS(3),
 		},
 	{
 	      GetEnable:GetEnable_B,
-	      GetIntSrc:GetIntSrc_B,
-	      GetLoadTrig:GetLoadTrig_B,
+	      GetIntSrc : GetIntSrc_B,
+	      GetLoadTrig : GetLoadTrig_B,
 	      GetMode:	GetMode_B,
-	      PulseIndex:PulseIndex_B,
-	      SetEnable:SetEnable_B,
-	      SetIntSrc:SetIntSrc_B,
-	      SetLoadTrig:SetLoadTrig_B,
+	      PulseIndex : PulseIndex_B,
+	      SetEnable : SetEnable_B,
+	      SetIntSrc : SetIntSrc_B,
+	      SetLoadTrig : SetLoadTrig_B,
 	      SetMode:	SetMode_B,
-	      ResetCapFlags:ResetCapFlags_B,
+	      ResetCapFlags : ResetCapFlags_B,
 	      MyCRA:	LP_CR1A,
 	      MyCRB:	LP_CR1B,
-	      MyLatchLsw:LP_CNTR1BLSW,
-	      MyEventBits:EVBITS(4),
+	      MyLatchLsw : LP_CNTR1BLSW,
+	      MyEventBits : EVBITS(4),
 		},
 	{
 	      GetEnable:GetEnable_B,
-	      GetIntSrc:GetIntSrc_B,
-	      GetLoadTrig:GetLoadTrig_B,
+	      GetIntSrc : GetIntSrc_B,
+	      GetLoadTrig : GetLoadTrig_B,
 	      GetMode:	GetMode_B,
-	      PulseIndex:PulseIndex_B,
-	      SetEnable:SetEnable_B,
-	      SetIntSrc:SetIntSrc_B,
-	      SetLoadTrig:SetLoadTrig_B,
+	      PulseIndex : PulseIndex_B,
+	      SetEnable : SetEnable_B,
+	      SetIntSrc : SetIntSrc_B,
+	      SetLoadTrig : SetLoadTrig_B,
 	      SetMode:	SetMode_B,
-	      ResetCapFlags:ResetCapFlags_B,
+	      ResetCapFlags : ResetCapFlags_B,
 	      MyCRA:	LP_CR2A,
 	      MyCRB:	LP_CR2B,
-	      MyLatchLsw:LP_CNTR2BLSW,
-	      MyEventBits:EVBITS(5),
+	      MyLatchLsw : LP_CNTR2BLSW,
+	      MyEventBits : EVBITS(5),
 		},
 };
 </pre><hr><pre>commit 8086fff871940e6a348a733a303f39c086e4b3c5
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Mon Mar 16 22:03:35 2009 -0400

    Staging: comedi: Add spaces after commas where suggested by checkpatch.pl
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/comedi_compat32.c b/drivers/staging/comedi/comedi_compat32.c
index 7d0116bcb9ff..98e570a2cb3e 100644
--- a/drivers/staging/comedi/comedi_compat32.c
+++ b/drivers/staging/comedi/comedi_compat32.c
@@ -37,16 +37,16 @@
 #include &lt;linux/ioctl32.h&gt;	/* for (un)register_ioctl32_conversion */
 #endif
 
-#define COMEDI32_CHANINFO _IOR(CIO,3,comedi32_chaninfo)
-#define COMEDI32_RANGEINFO _IOR(CIO,8,comedi32_rangeinfo)
+#define COMEDI32_CHANINFO _IOR(CIO, 3, comedi32_chaninfo)
+#define COMEDI32_RANGEINFO _IOR(CIO, 8, comedi32_rangeinfo)
 /* N.B. COMEDI32_CMD and COMEDI_CMD ought to use _IOWR, not _IOR.
  * It's too late to change it now, but it only affects the command number. */
-#define COMEDI32_CMD _IOR(CIO,9,comedi32_cmd)
+#define COMEDI32_CMD _IOR(CIO, 9, comedi32_cmd)
 /* N.B. COMEDI32_CMDTEST and COMEDI_CMDTEST ought to use _IOWR, not _IOR.
  * It's too late to change it now, but it only affects the command number. */
-#define COMEDI32_CMDTEST _IOR(CIO,10,comedi32_cmd)
-#define COMEDI32_INSNLIST _IOR(CIO,11,comedi32_insnlist)
-#define COMEDI32_INSN _IOR(CIO,12,comedi32_insn)
+#define COMEDI32_CMDTEST _IOR(CIO, 10, comedi32_cmd)
+#define COMEDI32_INSNLIST _IOR(CIO, 11, comedi32_insnlist)
+#define COMEDI32_INSN _IOR(CIO, 12, comedi32_insn)
 
 typedef struct comedi32_chaninfo_struct {
 	unsigned int subdev;
diff --git a/drivers/staging/comedi/drivers/mite.h b/drivers/staging/comedi/drivers/mite.h
index 2b2df8b4e360..37f397b340c5 100644
--- a/drivers/staging/comedi/drivers/mite.h
+++ b/drivers/staging/comedi/drivers/mite.h
@@ -33,9 +33,9 @@
 #define PCIMIO_COMPAT
 
 #ifdef DEBUG_MITE
-#define MDPRINTK(format,args...)	printk(format , ## args )
+#define MDPRINTK(format, args...)	printk(format , ## args )
 #else
-#define MDPRINTK(format,args...)
+#define MDPRINTK(format, args...)
 #endif
 
 #define MAX_MITE_DMA_CHANNELS 8
diff --git a/drivers/staging/comedi/drivers/rtd520.c b/drivers/staging/comedi/drivers/rtd520.c
index 4d8c68104530..326dd2f1b840 100644
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -366,11 +366,11 @@ typedef struct {
 #define DMA1_ACTIVE	0x04	/* DMA1 is active */
 
 /* Macros for accessing channel list bit array */
-#define CHAN_ARRAY_TEST(array,index) \
+#define CHAN_ARRAY_TEST(array, index) \
 	(((array)[(index)/8] &gt;&gt; ((index) &amp; 0x7)) &amp; 0x1)
-#define CHAN_ARRAY_SET(array,index) \
+#define CHAN_ARRAY_SET(array, index) \
 	(((array)[(index)/8] |= 1 &lt;&lt; ((index) &amp; 0x7)))
-#define CHAN_ARRAY_CLEAR(array,index) \
+#define CHAN_ARRAY_CLEAR(array, index) \
 	(((array)[(index)/8] &amp;= ~(1 &lt;&lt; ((index) &amp; 0x7))))
 
 /*
@@ -394,15 +394,15 @@ typedef struct {
     writel (0, devpriv-&gt;las0+LAS0_CGT_CLEAR)
 
 /* Reset channel gain table read and write pointers */
-#define RtdEnableCGT(dev,v) \
+#define RtdEnableCGT(dev, v) \
     writel ((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_CGT_ENABLE)
 
 /* Write channel gain table entry */
-#define RtdWriteCGTable(dev,v) \
+#define RtdWriteCGTable(dev, v) \
     writel (v, devpriv-&gt;las0+LAS0_CGT_WRITE)
 
 /* Write Channel Gain Latch */
-#define RtdWriteCGLatch(dev,v) \
+#define RtdWriteCGLatch(dev, v) \
     writel (v, devpriv-&gt;las0+LAS0_CGL_WRITE)
 
 /* Reset ADC FIFO */
@@ -410,39 +410,39 @@ typedef struct {
     writel (0, devpriv-&gt;las0+LAS0_ADC_FIFO_CLEAR)
 
 /* Set ADC start conversion source select (write only) */
-#define RtdAdcConversionSource(dev,v) \
+#define RtdAdcConversionSource(dev, v) \
     writel (v, devpriv-&gt;las0+LAS0_ADC_CONVERSION)
 
 /* Set burst start source select (write only) */
-#define RtdBurstStartSource(dev,v) \
+#define RtdBurstStartSource(dev, v) \
     writel (v, devpriv-&gt;las0+LAS0_BURST_START)
 
 /* Set Pacer start source select (write only) */
-#define RtdPacerStartSource(dev,v) \
+#define RtdPacerStartSource(dev, v) \
     writel (v, devpriv-&gt;las0+LAS0_PACER_START)
 
 /* Set Pacer stop source select (write only) */
-#define RtdPacerStopSource(dev,v) \
+#define RtdPacerStopSource(dev, v) \
     writel (v, devpriv-&gt;las0+LAS0_PACER_STOP)
 
 /* Set Pacer clock source select (write only) 0=external 1=internal */
-#define RtdPacerClockSource(dev,v) \
+#define RtdPacerClockSource(dev, v) \
     writel ((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_PACER_SELECT)
 
 /* Set sample counter source select (write only) */
-#define RtdAdcSampleCounterSource(dev,v) \
+#define RtdAdcSampleCounterSource(dev, v) \
     writel (v, devpriv-&gt;las0+LAS0_ADC_SCNT_SRC)
 
 /* Set Pacer trigger mode select (write only) 0=single cycle, 1=repeat */
-#define RtdPacerTriggerMode(dev,v) \
+#define RtdPacerTriggerMode(dev, v) \
     writel ((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_PACER_REPEAT)
 
 /* Set About counter stop enable (write only) */
-#define RtdAboutStopEnable(dev,v) \
+#define RtdAboutStopEnable(dev, v) \
     writel ((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_ACNT_STOP_ENABLE)
 
 /* Set external trigger polarity (write only) 0=positive edge, 1=negative */
-#define RtdTriggerPolarity(dev,v) \
+#define RtdTriggerPolarity(dev, v) \
     writel ((v &gt; 0) ? 1 : 0, devpriv-&gt;las0+LAS0_ETRG_POLARITY)
 
 /* Start single ADC conversion */
@@ -473,15 +473,15 @@ typedef struct {
     readw (devpriv-&gt;las0+LAS0_IT)
 
 /* Interrupt mask */
-#define RtdInterruptMask(dev,v) \
-    writew ((devpriv-&gt;intMask = (v)),devpriv-&gt;las0+LAS0_IT)
+#define RtdInterruptMask(dev, v) \
+    writew ((devpriv-&gt;intMask = (v)), devpriv-&gt;las0+LAS0_IT)
 
 /* Interrupt status clear (only bits set in mask) */
 #define RtdInterruptClear(dev) \
     readw (devpriv-&gt;las0+LAS0_CLEAR)
 
 /* Interrupt clear mask */
-#define RtdInterruptClearMask(dev,v) \
+#define RtdInterruptClearMask(dev, v) \
     writew ((devpriv-&gt;intClearMask = (v)), devpriv-&gt;las0+LAS0_CLEAR)
 
 /* Interrupt overrun status */
@@ -495,92 +495,92 @@ typedef struct {
 /* Pacer counter, 24bit */
 #define RtdPacerCount(dev) \
     readl (devpriv-&gt;las0+LAS0_PCLK)
-#define RtdPacerCounter(dev,v) \
-    writel ((v) &amp; 0xffffff,devpriv-&gt;las0+LAS0_PCLK)
+#define RtdPacerCounter(dev, v) \
+    writel ((v) &amp; 0xffffff, devpriv-&gt;las0+LAS0_PCLK)
 
 /* Burst counter, 10bit */
 #define RtdBurstCount(dev) \
     readl (devpriv-&gt;las0+LAS0_BCLK)
-#define RtdBurstCounter(dev,v) \
-    writel ((v) &amp; 0x3ff,devpriv-&gt;las0+LAS0_BCLK)
+#define RtdBurstCounter(dev, v) \
+    writel ((v) &amp; 0x3ff, devpriv-&gt;las0+LAS0_BCLK)
 
 /* Delay counter, 16bit */
 #define RtdDelayCount(dev) \
     readl (devpriv-&gt;las0+LAS0_DCLK)
-#define RtdDelayCounter(dev,v) \
+#define RtdDelayCounter(dev, v) \
     writel ((v) &amp; 0xffff, devpriv-&gt;las0+LAS0_DCLK)
 
 /* About counter, 16bit */
 #define RtdAboutCount(dev) \
     readl (devpriv-&gt;las0+LAS0_ACNT)
-#define RtdAboutCounter(dev,v) \
+#define RtdAboutCounter(dev, v) \
     writel ((v) &amp; 0xffff, devpriv-&gt;las0+LAS0_ACNT)
 
 /* ADC sample counter, 10bit */
 #define RtdAdcSampleCount(dev) \
     readl (devpriv-&gt;las0+LAS0_ADC_SCNT)
-#define RtdAdcSampleCounter(dev,v) \
+#define RtdAdcSampleCounter(dev, v) \
     writel ((v) &amp; 0x3ff, devpriv-&gt;las0+LAS0_ADC_SCNT)
 
 /* User Timer/Counter (8254) */
-#define RtdUtcCounterGet(dev,n) \
+#define RtdUtcCounterGet(dev, n) \
     readb (devpriv-&gt;las0 \
         + ((n &lt;= 0) ? LAS0_UTC0 : ((1 == n) ? LAS0_UTC1 : LAS0_UTC2)))
 
-#define RtdUtcCounterPut(dev,n,v) \
+#define RtdUtcCounterPut(dev, n, v) \
     writeb ((v) &amp; 0xff, devpriv-&gt;las0 \
         + ((n &lt;= 0) ? LAS0_UTC0 : ((1 == n) ? LAS0_UTC1 : LAS0_UTC2)))
 
 /* Set UTC (8254) control byte  */
-#define RtdUtcCtrlPut(dev,n,v) \
+#define RtdUtcCtrlPut(dev, n, v) \
     writeb (devpriv-&gt;utcCtrl[(n) &amp; 3] = (((n) &amp; 3) &lt;&lt; 6) | ((v) &amp; 0x3f), \
       devpriv-&gt;las0 + LAS0_UTC_CTRL)
 
 /* Set UTCn clock source (write only) */
-#define RtdUtcClockSource(dev,n,v) \
+#define RtdUtcClockSource(dev, n, v) \
     writew (v, devpriv-&gt;las0 \
         + ((n &lt;= 0) ? LAS0_UTC0_CLOCK : \
            ((1 == n) ? LAS0_UTC1_CLOCK : LAS0_UTC2_CLOCK)))
 
 /* Set UTCn gate source (write only) */
-#define RtdUtcGateSource(dev,n,v) \
+#define RtdUtcGateSource(dev, n, v) \
     writew (v, devpriv-&gt;las0 \
         + ((n &lt;= 0) ? LAS0_UTC0_GATE : \
            ((1 == n) ? LAS0_UTC1_GATE : LAS0_UTC2_GATE)))
 
 /* User output N source select (write only) */
-#define RtdUsrOutSource(dev,n,v) \
-    writel (v,devpriv-&gt;las0+((n &lt;= 0) ? LAS0_UOUT0_SELECT : LAS0_UOUT1_SELECT))
+#define RtdUsrOutSource(dev, n, v) \
+    writel (v, devpriv-&gt;las0+((n &lt;= 0) ? LAS0_UOUT0_SELECT : LAS0_UOUT1_SELECT))
 
 /* Digital IO */
 #define RtdDio0Read(dev) \
     (readw (devpriv-&gt;las0+LAS0_DIO0) &amp; 0xff)
-#define RtdDio0Write(dev,v) \
+#define RtdDio0Write(dev, v) \
     writew ((v) &amp; 0xff, devpriv-&gt;las0+LAS0_DIO0)
 
 #define RtdDio1Read(dev) \
     (readw (devpriv-&gt;las0+LAS0_DIO1) &amp; 0xff)
-#define RtdDio1Write(dev,v) \
+#define RtdDio1Write(dev, v) \
     writew ((v) &amp; 0xff, devpriv-&gt;las0+LAS0_DIO1)
 
 #define RtdDioStatusRead(dev) \
     (readw (devpriv-&gt;las0+LAS0_DIO_STATUS) &amp; 0xff)
-#define RtdDioStatusWrite(dev,v) \
+#define RtdDioStatusWrite(dev, v) \
     writew ((devpriv-&gt;dioStatus = (v)), devpriv-&gt;las0+LAS0_DIO_STATUS)
 
 #define RtdDio0CtrlRead(dev) \
     (readw (devpriv-&gt;las0+LAS0_DIO0_CTRL) &amp; 0xff)
-#define RtdDio0CtrlWrite(dev,v) \
+#define RtdDio0CtrlWrite(dev, v) \
     writew ((v) &amp; 0xff, devpriv-&gt;las0+LAS0_DIO0_CTRL)
 
 /* Digital to Analog converter */
 /* Write one data value (sign + 12bit + marker bits) */
 /* Note: matches what DMA would put.  Actual value &lt;&lt; 3 */
-#define RtdDacFifoPut(dev,n,v) \
+#define RtdDacFifoPut(dev, n, v) \
     writew ((v), devpriv-&gt;las1 +(((n) == 0) ? LAS1_DAC1_FIFO : LAS1_DAC2_FIFO))
 
 /* Start single DAC conversion */
-#define RtdDacUpdate(dev,n) \
+#define RtdDacUpdate(dev, n) \
     writew (0, devpriv-&gt;las0 +(((n) == 0) ? LAS0_DAC1 : LAS0_DAC2))
 
 /* Start single DAC conversion on both DACs */
@@ -588,20 +588,20 @@ typedef struct {
     writew (0, devpriv-&gt;las0+LAS0_DAC)
 
 /* Set DAC output type and range */
-#define RtdDacRange(dev,n,v) \
+#define RtdDacRange(dev, n, v) \
     writew ((v) &amp; 7, devpriv-&gt;las0 \
 	+(((n) == 0) ? LAS0_DAC1_CTRL : LAS0_DAC2_CTRL))
 
 /* Reset DAC FIFO */
-#define RtdDacClearFifo(dev,n) \
+#define RtdDacClearFifo(dev, n) \
     writel (0, devpriv-&gt;las0+(((n) == 0) ? LAS0_DAC1_RESET : LAS0_DAC2_RESET))
 
 /* Set source for DMA 0 (write only, shadow?) */
-#define RtdDma0Source(dev,n) \
+#define RtdDma0Source(dev, n) \
     writel ((n) &amp; 0xf, devpriv-&gt;las0+LAS0_DMA0_SRC)
 
 /* Set source for DMA 1 (write only, shadow?) */
-#define RtdDma1Source(dev,n) \
+#define RtdDma1Source(dev, n) \
     writel ((n) &amp; 0xf, devpriv-&gt;las0+LAS0_DMA1_SRC)
 
 /* Reset board state for DMA 0 */
@@ -615,51 +615,51 @@ typedef struct {
 /* PLX9080 interrupt mask and status */
 #define RtdPlxInterruptRead(dev) \
     readl (devpriv-&gt;lcfg+LCFG_ITCSR)
-#define RtdPlxInterruptWrite(dev,v) \
+#define RtdPlxInterruptWrite(dev, v) \
     writel (v, devpriv-&gt;lcfg+LCFG_ITCSR)
 
 /* Set  mode for DMA 0 */
-#define RtdDma0Mode(dev,m) \
+#define RtdDma0Mode(dev, m) \
     writel ((m), devpriv-&gt;lcfg+LCFG_DMAMODE0)
 
 /* Set PCI address for DMA 0 */
-#define RtdDma0PciAddr(dev,a) \
+#define RtdDma0PciAddr(dev, a) \
     writel ((a), devpriv-&gt;lcfg+LCFG_DMAPADR0)
 
 /* Set local address for DMA 0 */
-#define RtdDma0LocalAddr(dev,a) \
+#define RtdDma0LocalAddr(dev, a) \
     writel ((a), devpriv-&gt;lcfg+LCFG_DMALADR0)
 
 /* Set byte count for DMA 0 */
-#define RtdDma0Count(dev,c) \
+#define RtdDma0Count(dev, c) \
     writel ((c), devpriv-&gt;lcfg+LCFG_DMASIZ0)
 
 /* Set next descriptor for DMA 0 */
-#define RtdDma0Next(dev,a) \
+#define RtdDma0Next(dev, a) \
     writel ((a), devpriv-&gt;lcfg+LCFG_DMADPR0)
 
 /* Set  mode for DMA 1 */
-#define RtdDma1Mode(dev,m) \
+#define RtdDma1Mode(dev, m) \
     writel ((m), devpriv-&gt;lcfg+LCFG_DMAMODE1)
 
 /* Set PCI address for DMA 1 */
-#define RtdDma1PciAddr(dev,a) \
+#define RtdDma1PciAddr(dev, a) \
     writel ((a), devpriv-&gt;lcfg+LCFG_DMAADR1)
 
 /* Set local address for DMA 1 */
-#define RtdDma1LocalAddr(dev,a) \
+#define RtdDma1LocalAddr(dev, a) \
     writel ((a), devpriv-&gt;lcfg+LCFG_DMALADR1)
 
 /* Set byte count for DMA 1 */
-#define RtdDma1Count(dev,c) \
+#define RtdDma1Count(dev, c) \
     writel ((c), devpriv-&gt;lcfg+LCFG_DMASIZ1)
 
 /* Set next descriptor for DMA 1 */
-#define RtdDma1Next(dev,a) \
+#define RtdDma1Next(dev, a) \
     writel ((a), devpriv-&gt;lcfg+LCFG_DMADPR1)
 
 /* Set control for DMA 0 (write only, shadow?) */
-#define RtdDma0Control(dev,n) \
+#define RtdDma0Control(dev, n) \
     writeb (devpriv-&gt;dma0Control = (n), devpriv-&gt;lcfg+LCFG_DMACSR0)
 
 /* Get status for DMA 0 */
@@ -667,7 +667,7 @@ typedef struct {
     readb (devpriv-&gt;lcfg+LCFG_DMACSR0)
 
 /* Set control for DMA 1 (write only, shadow?) */
-#define RtdDma1Control(dev,n) \
+#define RtdDma1Control(dev, n) \
     writeb (devpriv-&gt;dma1Control = (n), devpriv-&gt;lcfg+LCFG_DMACSR1)
 
 /* Get status for DMA 1 */
diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 41f3736efa3b..0c1f5297fe2f 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -454,7 +454,7 @@ static enc_private enc_private_data[] = {
 
 /*  enab/disable a function or test status bit(s) that are accessed */
 /*  through Main Control Registers 1 or 2. */
-#define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) &lt;&lt; 16 ) | (uint32_t)( CTRLWORD ),devpriv-&gt;base_addr+( REGADRS ) )
+#define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) &lt;&lt; 16 ) | (uint32_t)( CTRLWORD ), devpriv-&gt;base_addr+( REGADRS ) )
 
 #define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) &lt;&lt; 16 , devpriv-&gt;base_addr+( REGADRS ) )
 
@@ -462,7 +462,7 @@ static enc_private enc_private_data[] = {
 
 /* #define WR7146(REGARDS,CTRLWORD)
     writel(CTRLWORD,(uint32_t)(devpriv-&gt;base_addr+(REGARDS))) */
-#define WR7146(REGARDS,CTRLWORD) writel(CTRLWORD,devpriv-&gt;base_addr+(REGARDS))
+#define WR7146(REGARDS, CTRLWORD) writel(CTRLWORD, devpriv-&gt;base_addr+(REGARDS))
 
 /* #define RR7146(REGARDS)
     readl((uint32_t)(devpriv-&gt;base_addr+(REGARDS))) */
@@ -475,9 +475,9 @@ static enc_private enc_private_data[] = {
 #define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR,VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
-#define I2C_B1(ATTR,VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
-#define I2C_B0(ATTR,VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
+#define I2C_B2(ATTR, VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
+#define I2C_B1(ATTR, VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
+#define I2C_B0(ATTR, VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
 
 static const comedi_lrange s626_range_table = { 2, {
 			RANGE(-5, 5),
diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 7a88bb35b50b..c158110aa47c 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -470,9 +470,9 @@
 #define I2CW			( devpriv-&gt;I2CAdrs )
 
 /*  Code macros used for constructing I2C command bytes. */
-#define I2C_B2(ATTR,VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
-#define I2C_B1(ATTR,VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
-#define I2C_B0(ATTR,VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
+#define I2C_B2(ATTR, VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
+#define I2C_B1(ATTR, VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
+#define I2C_B0(ATTR, VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
 
 /* oldest */
 #define P_DEBICFGq              0x007C	/*  DEBI configuration. */</pre><hr><pre>commit e473e9120b0a2d7252aca1ed9db5adadee36c0fa
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Mon Mar 16 22:03:29 2009 -0400

    Staging: comedi: Change "foo * bar" to "foo *bar"
    
    Removes checkpatch.pl errors
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index 48e54042f8b3..a252081b6a08 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -47,13 +47,13 @@
 #include &lt;asm/io.h&gt;
 #include &lt;asm/system.h&gt;
 
-static int postconfig(comedi_device * dev);
-static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+static int postconfig(comedi_device *dev);
+static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
 static void *comedi_recognize(comedi_driver * driv, const char *name);
-static void comedi_report_boards(comedi_driver * driv);
-static int poll_invalid(comedi_device * dev, comedi_subdevice * s);
-int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
+static void comedi_report_boards(comedi_driver *driv);
+static int poll_invalid(comedi_device *dev, comedi_subdevice *s);
+int comedi_buf_alloc(comedi_device *dev, comedi_subdevice *s,
 	unsigned long new_size);
 
 comedi_driver *comedi_drivers;
@@ -63,7 +63,7 @@ int comedi_modprobe(int minor)
 	return -EINVAL;
 }
 
-static void cleanup_device(comedi_device * dev)
+static void cleanup_device(comedi_device *dev)
 {
 	int i;
 	comedi_subdevice *s;
@@ -97,7 +97,7 @@ static void cleanup_device(comedi_device * dev)
 	comedi_set_hw_dev(dev, NULL);
 }
 
-static void __comedi_device_detach(comedi_device * dev)
+static void __comedi_device_detach(comedi_device *dev)
 {
 	dev-&gt;attached = 0;
 	if (dev-&gt;driver) {
@@ -108,14 +108,14 @@ static void __comedi_device_detach(comedi_device * dev)
 	cleanup_device(dev);
 }
 
-void comedi_device_detach(comedi_device * dev)
+void comedi_device_detach(comedi_device *dev)
 {
 	if (!dev-&gt;attached)
 		return;
 	__comedi_device_detach(dev);
 }
 
-int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
+int comedi_device_attach(comedi_device *dev, comedi_devconfig *it)
 {
 	comedi_driver *driv;
 	int ret;
@@ -182,7 +182,7 @@ int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-int comedi_driver_register(comedi_driver * driver)
+int comedi_driver_register(comedi_driver *driver)
 {
 	driver-&gt;next = comedi_drivers;
 	comedi_drivers = driver;
@@ -190,7 +190,7 @@ int comedi_driver_register(comedi_driver * driver)
 	return 0;
 }
 
-int comedi_driver_unregister(comedi_driver * driver)
+int comedi_driver_unregister(comedi_driver *driver)
 {
 	comedi_driver *prev;
 	int i;
@@ -226,7 +226,7 @@ int comedi_driver_unregister(comedi_driver * driver)
 	return -EINVAL;
 }
 
-static int postconfig(comedi_device * dev)
+static int postconfig(comedi_device *dev)
 {
 	int i;
 	comedi_subdevice *s;
@@ -315,7 +315,7 @@ void *comedi_recognize(comedi_driver * driv, const char *name)
 	return NULL;
 }
 
-void comedi_report_boards(comedi_driver * driv)
+void comedi_report_boards(comedi_driver *driv)
 {
 	unsigned int i;
 	const char *const *name_ptr;
@@ -333,19 +333,19 @@ void comedi_report_boards(comedi_driver * driv)
 		printk(" %s\n", driv-&gt;driver_name);
 }
 
-static int poll_invalid(comedi_device * dev, comedi_subdevice * s)
+static int poll_invalid(comedi_device *dev, comedi_subdevice *s)
 {
 	return -EINVAL;
 }
 
-int insn_inval(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+int insn_inval(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	return -EINVAL;
 }
 
-static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int insn_rw_emulate_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	comedi_insn new_insn;
 	int ret;
@@ -381,7 +381,7 @@ static int insn_rw_emulate_bits(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static inline unsigned long uvirt_to_kva(pgd_t * pgd, unsigned long adr)
+static inline unsigned long uvirt_to_kva(pgd_t *pgd, unsigned long adr)
 {
 	unsigned long ret = 0UL;
 	pmd_t *pmd;
@@ -414,7 +414,7 @@ static inline unsigned long kvirt_to_kva(unsigned long adr)
 	return kva;
 }
 
-int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
+int comedi_buf_alloc(comedi_device *dev, comedi_subdevice *s,
 	unsigned long new_size)
 {
 	comedi_async *async = s-&gt;async;
@@ -538,7 +538,7 @@ int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
 
 /* munging is applied to data by core as it passes between user
  * and kernel space */
-unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
+unsigned int comedi_buf_munge(comedi_async *async, unsigned int num_bytes)
 {
 	comedi_subdevice *s = async-&gt;subdevice;
 	unsigned int count = 0;
@@ -582,7 +582,7 @@ unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
 	return count;
 }
 
-unsigned int comedi_buf_write_n_available(comedi_async * async)
+unsigned int comedi_buf_write_n_available(comedi_async *async)
 {
 	unsigned int free_end;
 	unsigned int nbytes;
@@ -602,7 +602,7 @@ unsigned int comedi_buf_write_n_available(comedi_async * async)
 }
 
 /* allocates chunk for the writer from free buffer space */
-unsigned int comedi_buf_write_alloc(comedi_async * async, unsigned int nbytes)
+unsigned int comedi_buf_write_alloc(comedi_async *async, unsigned int nbytes)
 {
 	unsigned int free_end = async-&gt;buf_read_count + async-&gt;prealloc_bufsz;
 
@@ -617,7 +617,7 @@ unsigned int comedi_buf_write_alloc(comedi_async * async, unsigned int nbytes)
 }
 
 /* allocates nothing unless it can completely fulfill the request */
-unsigned int comedi_buf_write_alloc_strict(comedi_async * async,
+unsigned int comedi_buf_write_alloc_strict(comedi_async *async,
 	unsigned int nbytes)
 {
 	unsigned int free_end = async-&gt;buf_read_count + async-&gt;prealloc_bufsz;
@@ -633,7 +633,7 @@ unsigned int comedi_buf_write_alloc_strict(comedi_async * async,
 }
 
 /* transfers a chunk from writer to filled buffer space */
-unsigned comedi_buf_write_free(comedi_async * async, unsigned int nbytes)
+unsigned comedi_buf_write_free(comedi_async *async, unsigned int nbytes)
 {
 	if ((int)(async-&gt;buf_write_count + nbytes -
 			async-&gt;buf_write_alloc_count) &gt; 0) {
@@ -651,7 +651,7 @@ unsigned comedi_buf_write_free(comedi_async * async, unsigned int nbytes)
 }
 
 /* allocates a chunk for the reader from filled (and munged) buffer space */
-unsigned comedi_buf_read_alloc(comedi_async * async, unsigned nbytes)
+unsigned comedi_buf_read_alloc(comedi_async *async, unsigned nbytes)
 {
 	if ((int)(async-&gt;buf_read_alloc_count + nbytes - async-&gt;munge_count) &gt;
 		0) {
@@ -665,7 +665,7 @@ unsigned comedi_buf_read_alloc(comedi_async * async, unsigned nbytes)
 }
 
 /* transfers control of a chunk from reader to free buffer space */
-unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
+unsigned comedi_buf_read_free(comedi_async *async, unsigned int nbytes)
 {
 	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
@@ -681,7 +681,7 @@ unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
 	return nbytes;
 }
 
-void comedi_buf_memcpy_to(comedi_async * async, unsigned int offset,
+void comedi_buf_memcpy_to(comedi_async *async, unsigned int offset,
 	const void *data, unsigned int num_bytes)
 {
 	unsigned int write_ptr = async-&gt;buf_write_ptr + offset;
@@ -706,7 +706,7 @@ void comedi_buf_memcpy_to(comedi_async * async, unsigned int offset,
 	}
 }
 
-void comedi_buf_memcpy_from(comedi_async * async, unsigned int offset,
+void comedi_buf_memcpy_from(comedi_async *async, unsigned int offset,
 	void *dest, unsigned int nbytes)
 {
 	void *src;
@@ -732,7 +732,7 @@ void comedi_buf_memcpy_from(comedi_async * async, unsigned int offset,
 	}
 }
 
-unsigned int comedi_buf_read_n_available(comedi_async * async)
+unsigned int comedi_buf_read_n_available(comedi_async *async)
 {
 	unsigned num_bytes;
 
@@ -747,7 +747,7 @@ unsigned int comedi_buf_read_n_available(comedi_async * async)
 	return num_bytes;
 }
 
-int comedi_buf_get(comedi_async * async, sampl_t * x)
+int comedi_buf_get(comedi_async *async, sampl_t *x)
 {
 	unsigned int n = comedi_buf_read_n_available(async);
 
@@ -759,7 +759,7 @@ int comedi_buf_get(comedi_async * async, sampl_t * x)
 	return 1;
 }
 
-int comedi_buf_put(comedi_async * async, sampl_t x)
+int comedi_buf_put(comedi_async *async, sampl_t x)
 {
 	unsigned int n = comedi_buf_write_alloc_strict(async, sizeof(sampl_t));
 
@@ -772,7 +772,7 @@ int comedi_buf_put(comedi_async * async, sampl_t x)
 	return 1;
 }
 
-void comedi_reset_async_buf(comedi_async * async)
+void comedi_reset_async_buf(comedi_async *async)
 {
 	async-&gt;buf_write_alloc_count = 0;
 	async-&gt;buf_write_count = 0;
diff --git a/drivers/staging/comedi/drivers/icp_multi.c b/drivers/staging/comedi/drivers/icp_multi.c
index 143a5f95b31f..ef8f783ba4e4 100644
--- a/drivers/staging/comedi/drivers/icp_multi.c
+++ b/drivers/staging/comedi/drivers/icp_multi.c
@@ -123,8 +123,8 @@ static const char range_codes_analog[] = { 0x00, 0x20, 0x10, 0x30 };
 	Forward declarations
 ==============================================================================
 */
-static int icp_multi_attach(comedi_device * dev, comedi_devconfig * it);
-static int icp_multi_detach(comedi_device * dev);
+static int icp_multi_attach(comedi_device *dev, comedi_devconfig *it);
+static int icp_multi_detach(comedi_device *dev);
 
 /*
 ==============================================================================
@@ -214,12 +214,12 @@ typedef struct {
 */
 
 #if 0
-static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(comedi_device *dev, comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan);
 #endif
-static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+static void setup_channel_list(comedi_device *dev, comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan);
-static int icp_multi_reset(comedi_device * dev);
+static int icp_multi_reset(comedi_device *dev);
 
 /*
 ==============================================================================
@@ -245,8 +245,8 @@ static int icp_multi_reset(comedi_device * dev);
 
 ==============================================================================
 */
-static int icp_multi_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int icp_multi_insn_read_ai(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	int n, timeout;
 
@@ -364,8 +364,8 @@ static int icp_multi_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static int icp_multi_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int icp_multi_insn_write_ao(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	int n, chan, range, timeout;
 
@@ -472,8 +472,8 @@ static int icp_multi_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static int icp_multi_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int icp_multi_insn_read_ao(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	int n, chan;
 
@@ -505,8 +505,8 @@ static int icp_multi_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static int icp_multi_insn_bits_di(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int icp_multi_insn_bits_di(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	data[1] = readw(devpriv-&gt;io_addr + ICP_MULTI_DI);
 
@@ -531,8 +531,8 @@ static int icp_multi_insn_bits_di(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static int icp_multi_insn_bits_do(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int icp_multi_insn_bits_do(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: BGN: icp_multi_insn_bits_do(...)\n");
@@ -573,8 +573,8 @@ static int icp_multi_insn_bits_do(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static int icp_multi_insn_read_ctr(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int icp_multi_insn_read_ctr(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	return 0;
 }
@@ -597,8 +597,8 @@ static int icp_multi_insn_read_ctr(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static int icp_multi_insn_write_ctr(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int icp_multi_insn_write_ctr(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	return 0;
 }
@@ -689,7 +689,7 @@ static irqreturn_t interrupt_service_icp_multi(int irq, void *d PT_REGS_ARG)
 
 ==============================================================================
 */
-static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
+static int check_channel_list(comedi_device *dev, comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int i;
@@ -743,7 +743,7 @@ static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
+static void setup_channel_list(comedi_device *dev, comedi_subdevice *s,
 	unsigned int *chanlist, unsigned int n_chan)
 {
 	unsigned int i, range, chanprog;
@@ -812,7 +812,7 @@ static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
 
 ==============================================================================
 */
-static int icp_multi_reset(comedi_device * dev)
+static int icp_multi_reset(comedi_device *dev)
 {
 	unsigned int i;
 
@@ -870,7 +870,7 @@ static int icp_multi_reset(comedi_device * dev)
 
 ==============================================================================
 */
-static int icp_multi_attach(comedi_device * dev, comedi_devconfig * it)
+static int icp_multi_attach(comedi_device *dev, comedi_devconfig *it)
 {
 	comedi_subdevice *s;
 	int ret, subdev, n_subdevices;
@@ -1061,7 +1061,7 @@ static int icp_multi_attach(comedi_device * dev, comedi_devconfig * it)
 
 ==============================================================================
 */
-static int icp_multi_detach(comedi_device * dev)
+static int icp_multi_detach(comedi_device *dev)
 {
 
 	if (dev-&gt;private)
diff --git a/drivers/staging/comedi/drivers/me4000.c b/drivers/staging/comedi/drivers/me4000.c
index 2608c8713c90..3aafedecf7ed 100644
--- a/drivers/staging/comedi/drivers/me4000.c
+++ b/drivers/staging/comedi/drivers/me4000.c
@@ -118,8 +118,8 @@ static const me4000_board_t me4000_boards[] = {
 /*-----------------------------------------------------------------------------
   Comedi function prototypes
   ---------------------------------------------------------------------------*/
-static int me4000_attach(comedi_device * dev, comedi_devconfig * it);
-static int me4000_detach(comedi_device * dev);
+static int me4000_attach(comedi_device *dev, comedi_devconfig *it);
+static int me4000_detach(comedi_device *dev);
 static comedi_driver driver_me4000 = {
       driver_name:"me4000",
       module:THIS_MODULE,
@@ -130,91 +130,91 @@ static comedi_driver driver_me4000 = {
 /*-----------------------------------------------------------------------------
   Meilhaus function prototypes
   ---------------------------------------------------------------------------*/
-static int me4000_probe(comedi_device * dev, comedi_devconfig * it);
-static int get_registers(comedi_device * dev, struct pci_dev *pci_dev_p);
-static int init_board_info(comedi_device * dev, struct pci_dev *pci_dev_p);
-static int init_ao_context(comedi_device * dev);
-static int init_ai_context(comedi_device * dev);
-static int init_dio_context(comedi_device * dev);
-static int init_cnt_context(comedi_device * dev);
-static int xilinx_download(comedi_device * dev);
-static int reset_board(comedi_device * dev);
+static int me4000_probe(comedi_device *dev, comedi_devconfig *it);
+static int get_registers(comedi_device *dev, struct pci_dev *pci_dev_p);
+static int init_board_info(comedi_device *dev, struct pci_dev *pci_dev_p);
+static int init_ao_context(comedi_device *dev);
+static int init_ai_context(comedi_device *dev);
+static int init_dio_context(comedi_device *dev);
+static int init_cnt_context(comedi_device *dev);
+static int xilinx_download(comedi_device *dev);
+static int reset_board(comedi_device *dev);
 
-static int me4000_dio_insn_bits(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+static int me4000_dio_insn_bits(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data);
 
-static int me4000_dio_insn_config(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+static int me4000_dio_insn_config(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data);
 
-static int cnt_reset(comedi_device * dev, unsigned int channel);
+static int cnt_reset(comedi_device *dev, unsigned int channel);
 
-static int cnt_config(comedi_device * dev,
+static int cnt_config(comedi_device *dev,
 	unsigned int channel, unsigned int mode);
 
-static int me4000_cnt_insn_config(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+static int me4000_cnt_insn_config(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data);
 
-static int me4000_cnt_insn_write(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+static int me4000_cnt_insn_write(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data);
 
-static int me4000_cnt_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+static int me4000_cnt_insn_read(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data);
 
-static int me4000_ai_insn_read(comedi_device * dev,
-	comedi_subdevice * subdevice, comedi_insn * insn, lsampl_t * data);
+static int me4000_ai_insn_read(comedi_device *dev,
+	comedi_subdevice *subdevice, comedi_insn *insn, lsampl_t *data);
 
-static int me4000_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static int me4000_ai_cancel(comedi_device *dev, comedi_subdevice *s);
 
-static int ai_check_chanlist(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd);
+static int ai_check_chanlist(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd);
 
-static int ai_round_cmd_args(comedi_device * dev,
-	comedi_subdevice * s,
-	comedi_cmd * cmd,
+static int ai_round_cmd_args(comedi_device *dev,
+	comedi_subdevice *s,
+	comedi_cmd *cmd,
 	unsigned int *init_ticks,
 	unsigned int *scan_ticks, unsigned int *chan_ticks);
 
-static int ai_prepare(comedi_device * dev,
-	comedi_subdevice * s,
-	comedi_cmd * cmd,
+static int ai_prepare(comedi_device *dev,
+	comedi_subdevice *s,
+	comedi_cmd *cmd,
 	unsigned int init_ticks,
 	unsigned int scan_ticks, unsigned int chan_ticks);
 
-static int ai_write_chanlist(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd);
+static int ai_write_chanlist(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd);
 
 static irqreturn_t me4000_ai_isr(int irq, void *dev_id PT_REGS_ARG);
 
-static int me4000_ai_do_cmd_test(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd);
+static int me4000_ai_do_cmd_test(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd);
 
-static int me4000_ai_do_cmd(comedi_device * dev, comedi_subdevice * s);
+static int me4000_ai_do_cmd(comedi_device *dev, comedi_subdevice *s);
 
-static int me4000_ao_insn_write(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+static int me4000_ao_insn_write(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data);
 
-static int me4000_ao_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data);
+static int me4000_ao_insn_read(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data);
 
 /*-----------------------------------------------------------------------------
   Meilhaus inline functions
   ---------------------------------------------------------------------------*/
 
-static inline void me4000_outb(comedi_device * dev, unsigned char value,
+static inline void me4000_outb(comedi_device *dev, unsigned char value,
 	unsigned long port)
 {
 	PORT_PDEBUG("--&gt; 0x%02X port 0x%04lX\n", value, port);
 	outb(value, port);
 }
 
-static inline void me4000_outl(comedi_device * dev, unsigned long value,
+static inline void me4000_outl(comedi_device *dev, unsigned long value,
 	unsigned long port)
 {
 	PORT_PDEBUG("--&gt; 0x%08lX port 0x%04lX\n", value, port);
 	outl(value, port);
 }
 
-static inline unsigned long me4000_inl(comedi_device * dev, unsigned long port)
+static inline unsigned long me4000_inl(comedi_device *dev, unsigned long port)
 {
 	unsigned long value;
 	value = inl(port);
@@ -222,7 +222,7 @@ static inline unsigned long me4000_inl(comedi_device * dev, unsigned long port)
 	return value;
 }
 
-static inline unsigned char me4000_inb(comedi_device * dev, unsigned long port)
+static inline unsigned char me4000_inb(comedi_device *dev, unsigned long port)
 {
 	unsigned char value;
 	value = inb(port);
@@ -247,7 +247,7 @@ static const comedi_lrange me4000_ao_range = {
 		}
 };
 
-static int me4000_attach(comedi_device * dev, comedi_devconfig * it)
+static int me4000_attach(comedi_device *dev, comedi_devconfig *it)
 {
 	comedi_subdevice *s;
 	int result;
@@ -369,7 +369,7 @@ static int me4000_attach(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-static int me4000_probe(comedi_device * dev, comedi_devconfig * it)
+static int me4000_probe(comedi_device *dev, comedi_devconfig *it)
 {
 	struct pci_dev *pci_device;
 	int result, i;
@@ -512,7 +512,7 @@ static int me4000_probe(comedi_device * dev, comedi_devconfig * it)
 	return 0;
 }
 
-static int get_registers(comedi_device * dev, struct pci_dev *pci_dev_p)
+static int get_registers(comedi_device *dev, struct pci_dev *pci_dev_p)
 {
 
 	CALL_PDEBUG("In get_registers()\n");
@@ -564,7 +564,7 @@ static int get_registers(comedi_device * dev, struct pci_dev *pci_dev_p)
 	return 0;
 }
 
-static int init_board_info(comedi_device * dev, struct pci_dev *pci_dev_p)
+static int init_board_info(comedi_device *dev, struct pci_dev *pci_dev_p)
 {
 	int result;
 
@@ -598,7 +598,7 @@ static int init_board_info(comedi_device * dev, struct pci_dev *pci_dev_p)
 	return 0;
 }
 
-static int init_ao_context(comedi_device * dev)
+static int init_ao_context(comedi_device *dev)
 {
 	int i;
 
@@ -681,7 +681,7 @@ static int init_ao_context(comedi_device * dev)
 	return 0;
 }
 
-static int init_ai_context(comedi_device * dev)
+static int init_ai_context(comedi_device *dev)
 {
 
 	CALL_PDEBUG("In init_ai_context()\n");
@@ -715,7 +715,7 @@ static int init_ai_context(comedi_device * dev)
 	return 0;
 }
 
-static int init_dio_context(comedi_device * dev)
+static int init_dio_context(comedi_device *dev)
 {
 
 	CALL_PDEBUG("In init_dio_context()\n");
@@ -734,7 +734,7 @@ static int init_dio_context(comedi_device * dev)
 	return 0;
 }
 
-static int init_cnt_context(comedi_device * dev)
+static int init_cnt_context(comedi_device *dev)
 {
 
 	CALL_PDEBUG("In init_cnt_context()\n");
@@ -755,7 +755,7 @@ static int init_cnt_context(comedi_device * dev)
 extern unsigned char *xilinx_firm;
 #endif
 
-static int xilinx_download(comedi_device * dev)
+static int xilinx_download(comedi_device *dev)
 {
 	u32 value = 0;
 	wait_queue_head_t queue;
@@ -837,7 +837,7 @@ static int xilinx_download(comedi_device * dev)
 	return 0;
 }
 
-static int reset_board(comedi_device * dev)
+static int reset_board(comedi_device *dev)
 {
 	unsigned long icr;
 
@@ -895,7 +895,7 @@ static int reset_board(comedi_device * dev)
 	return 0;
 }
 
-static int me4000_detach(comedi_device * dev)
+static int me4000_detach(comedi_device *dev)
 {
 	CALL_PDEBUG("In me4000_detach()\n");
 
@@ -916,8 +916,8 @@ static int me4000_detach(comedi_device * dev)
   Analog input section
   ===========================================================================*/
 
-static int me4000_ai_insn_read(comedi_device * dev,
-	comedi_subdevice * subdevice, comedi_insn * insn, lsampl_t * data)
+static int me4000_ai_insn_read(comedi_device *dev,
+	comedi_subdevice *subdevice, comedi_insn *insn, lsampl_t *data)
 {
 
 	int chan = CR_CHAN(insn-&gt;chanspec);
@@ -1040,7 +1040,7 @@ static int me4000_ai_insn_read(comedi_device * dev,
 	return 1;
 }
 
-static int me4000_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int me4000_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	unsigned long tmp;
 
@@ -1057,8 +1057,8 @@ static int me4000_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int ai_check_chanlist(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int ai_check_chanlist(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd)
 {
 	int aref;
 	int i;
@@ -1138,9 +1138,9 @@ static int ai_check_chanlist(comedi_device * dev,
 	return 0;
 }
 
-static int ai_round_cmd_args(comedi_device * dev,
-	comedi_subdevice * s,
-	comedi_cmd * cmd,
+static int ai_round_cmd_args(comedi_device *dev,
+	comedi_subdevice *s,
+	comedi_cmd *cmd,
 	unsigned int *init_ticks,
 	unsigned int *scan_ticks, unsigned int *chan_ticks)
 {
@@ -1207,7 +1207,7 @@ static int ai_round_cmd_args(comedi_device * dev,
 	return 0;
 }
 
-static void ai_write_timer(comedi_device * dev,
+static void ai_write_timer(comedi_device *dev,
 	unsigned int init_ticks,
 	unsigned int scan_ticks, unsigned int chan_ticks)
 {
@@ -1228,9 +1228,9 @@ static void ai_write_timer(comedi_device * dev,
 	me4000_outl(dev, chan_ticks - 1, info-&gt;ai_context.chan_timer_reg);
 }
 
-static int ai_prepare(comedi_device * dev,
-	comedi_subdevice * s,
-	comedi_cmd * cmd,
+static int ai_prepare(comedi_device *dev,
+	comedi_subdevice *s,
+	comedi_cmd *cmd,
 	unsigned int init_ticks,
 	unsigned int scan_ticks, unsigned int chan_ticks)
 {
@@ -1297,8 +1297,8 @@ static int ai_prepare(comedi_device * dev,
 	return 0;
 }
 
-static int ai_write_chanlist(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int ai_write_chanlist(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd)
 {
 	unsigned int entry;
 	unsigned int chan;
@@ -1337,7 +1337,7 @@ static int ai_write_chanlist(comedi_device * dev,
 	return 0;
 }
 
-static int me4000_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
+static int me4000_ai_do_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 	int err;
 	unsigned int init_ticks = 0;
@@ -1381,8 +1381,8 @@ static int me4000_ai_do_cmd(comedi_device * dev, comedi_subdevice * s)
  * - invalid chanlist
  * So I tried to adopt this scheme.
  */
-static int me4000_ai_do_cmd_test(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int me4000_ai_do_cmd_test(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd)
 {
 
 	unsigned int init_ticks;
@@ -1911,8 +1911,8 @@ static irqreturn_t me4000_ai_isr(int irq, void *dev_id PT_REGS_ARG)
   Analog output section
   ===========================================================================*/
 
-static int me4000_ao_insn_write(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int me4000_ao_insn_write(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 
 	int chan = CR_CHAN(insn-&gt;chanspec);
@@ -1969,8 +1969,8 @@ static int me4000_ao_insn_write(comedi_device * dev,
 	return 1;
 }
 
-static int me4000_ao_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int me4000_ao_insn_read(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	int chan = CR_CHAN(insn-&gt;chanspec);
 
@@ -1990,8 +1990,8 @@ static int me4000_ao_insn_read(comedi_device * dev,
   Digital I/O section
   ===========================================================================*/
 
-static int me4000_dio_insn_bits(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int me4000_dio_insn_bits(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 
 	CALL_PDEBUG("In me4000_dio_insn_bits()\n");
@@ -2041,8 +2041,8 @@ static int me4000_dio_insn_bits(comedi_device * dev,
 	return 2;
 }
 
-static int me4000_dio_insn_config(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int me4000_dio_insn_config(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	unsigned long tmp;
 	int chan = CR_CHAN(insn-&gt;chanspec);
@@ -2135,7 +2135,7 @@ static int me4000_dio_insn_config(comedi_device * dev,
   Counter section
   ===========================================================================*/
 
-static int cnt_reset(comedi_device * dev, unsigned int channel)
+static int cnt_reset(comedi_device *dev, unsigned int channel)
 {
 
 	CALL_PDEBUG("In cnt_reset()\n");
@@ -2166,7 +2166,7 @@ static int cnt_reset(comedi_device * dev, unsigned int channel)
 	return 0;
 }
 
-static int cnt_config(comedi_device * dev, unsigned int channel,
+static int cnt_config(comedi_device *dev, unsigned int channel,
 	unsigned int mode)
 {
 	int tmp = 0;
@@ -2223,8 +2223,8 @@ static int cnt_config(comedi_device * dev, unsigned int channel,
 	return 0;
 }
 
-static int me4000_cnt_insn_config(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int me4000_cnt_insn_config(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 
 	int err;
@@ -2266,8 +2266,8 @@ static int me4000_cnt_insn_config(comedi_device * dev,
 	return 2;
 }
 
-static int me4000_cnt_insn_read(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int me4000_cnt_insn_read(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 
 	unsigned short tmp;
@@ -2313,8 +2313,8 @@ static int me4000_cnt_insn_read(comedi_device * dev,
 	return 1;
 }
 
-static int me4000_cnt_insn_write(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int me4000_cnt_insn_write(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 
 	unsigned short tmp;
diff --git a/drivers/staging/comedi/drivers/mite.c b/drivers/staging/comedi/drivers/mite.c
index 354ed8ddaffd..c82aeff8ff58 100644
--- a/drivers/staging/comedi/drivers/mite.c
+++ b/drivers/staging/comedi/drivers/mite.c
@@ -103,7 +103,7 @@ static void dump_chip_signature(u32 csigr_bits)
 	printk("mite: num channels = %i, write post fifo depth = %i, wins = %i, iowins = %i\n", mite_csigr_dmac(csigr_bits), mite_csigr_wpdep(csigr_bits), mite_csigr_wins(csigr_bits), mite_csigr_iowins(csigr_bits));
 }
 
-unsigned mite_fifo_size(struct mite_struct * mite, unsigned channel)
+unsigned mite_fifo_size(struct mite_struct *mite, unsigned channel)
 {
 	unsigned fcr_bits = readl(mite-&gt;mite_io_addr +
 		MITE_FCR(channel));
@@ -459,7 +459,7 @@ u32 mite_device_bytes_transferred(struct mite_channel *mite_chan)
 	return readl(mite-&gt;mite_io_addr + MITE_DAR(mite_chan-&gt;channel));
 }
 
-u32 mite_bytes_in_transit(struct mite_channel * mite_chan)
+u32 mite_bytes_in_transit(struct mite_channel *mite_chan)
 {
 	struct mite_struct *mite = mite_chan-&gt;mite;
 	return readl(mite-&gt;mite_io_addr +
@@ -467,7 +467,7 @@ u32 mite_bytes_in_transit(struct mite_channel * mite_chan)
 }
 
 /*  returns lower bound for number of bytes transferred from device to memory */
-u32 mite_bytes_written_to_memory_lb(struct mite_channel * mite_chan)
+u32 mite_bytes_written_to_memory_lb(struct mite_channel *mite_chan)
 {
 	u32 device_byte_count;
 
@@ -476,7 +476,7 @@ u32 mite_bytes_written_to_memory_lb(struct mite_channel * mite_chan)
 }
 
 /*  returns upper bound for number of bytes transferred from device to memory */
-u32 mite_bytes_written_to_memory_ub(struct mite_channel * mite_chan)
+u32 mite_bytes_written_to_memory_ub(struct mite_channel *mite_chan)
 {
 	u32 in_transit_count;
 
@@ -485,7 +485,7 @@ u32 mite_bytes_written_to_memory_ub(struct mite_channel * mite_chan)
 }
 
 /*  returns lower bound for number of bytes read from memory for transfer to device */
-u32 mite_bytes_read_from_memory_lb(struct mite_channel * mite_chan)
+u32 mite_bytes_read_from_memory_lb(struct mite_channel *mite_chan)
 {
 	u32 device_byte_count;
 
@@ -494,7 +494,7 @@ u32 mite_bytes_read_from_memory_lb(struct mite_channel * mite_chan)
 }
 
 /*  returns upper bound for number of bytes read from memory for transfer to device */
-u32 mite_bytes_read_from_memory_ub(struct mite_channel * mite_chan)
+u32 mite_bytes_read_from_memory_ub(struct mite_channel *mite_chan)
 {
 	u32 in_transit_count;
 
diff --git a/drivers/staging/comedi/drivers/mite.h b/drivers/staging/comedi/drivers/mite.h
index 26c04c82293c..2b2df8b4e360 100644
--- a/drivers/staging/comedi/drivers/mite.h
+++ b/drivers/staging/comedi/drivers/mite.h
@@ -162,7 +162,7 @@ void mite_setregs(struct mite_struct *mite, unsigned long ll_start, int chan,
 void mite_prep_dma(struct mite_channel *mite_chan,
 	unsigned int num_device_bits, unsigned int num_memory_bits);
 int mite_buf_change(struct mite_dma_descriptor_ring *ring,
-	comedi_async * async);
+	comedi_async *async);
 
 #ifdef DEBUG_MITE
 void mite_print_chsr(unsigned int chsr);
diff --git a/drivers/staging/comedi/drivers/rtd520.c b/drivers/staging/comedi/drivers/rtd520.c
index e9379b80d227..4d8c68104530 100644
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -680,8 +680,8 @@ typedef struct {
  * the board, and also about the kernel module that contains
  * the device code.
  */
-static int rtd_attach(comedi_device * dev, comedi_devconfig * it);
-static int rtd_detach(comedi_device * dev);
+static int rtd_attach(comedi_device *dev, comedi_devconfig *it);
+static int rtd_detach(comedi_device *dev);
 
 static comedi_driver rtd520Driver = {
       driver_name: DRV_NAME,
@@ -690,20 +690,20 @@ static comedi_driver rtd520Driver = {
       detach:rtd_detach,
 };
 
-static int rtd_ai_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int rtd_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int rtd_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int rtd_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int rtd_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int rtd_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
-	comedi_cmd * cmd);
-static int rtd_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int rtd_ai_cancel(comedi_device * dev, comedi_subdevice * s);
+static int rtd_ai_rinsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int rtd_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int rtd_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int rtd_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int rtd_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int rtd_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+	comedi_cmd *cmd);
+static int rtd_ai_cmd(comedi_device *dev, comedi_subdevice *s);
+static int rtd_ai_cancel(comedi_device *dev, comedi_subdevice *s);
 /* static int rtd_ai_poll (comedi_device *dev,comedi_subdevice *s); */
 static int rtd_ns_to_timer(unsigned int *ns, int roundMode);
 static irqreturn_t rtd_interrupt(int irq, void *d PT_REGS_ARG);
@@ -715,7 +715,7 @@ static int rtd520_probe_fifo_depth(comedi_device *dev);
  * in the driver structure, dev-&gt;board_ptr contains that
  * address.
  */
-static int rtd_attach(comedi_device * dev, comedi_devconfig * it)
+static int rtd_attach(comedi_device *dev, comedi_devconfig *it)
 {				/* board name and options flags */
 	comedi_subdevice *s;
 	struct pci_dev *pcidev;
@@ -1057,7 +1057,7 @@ static int rtd_attach(comedi_device * dev, comedi_devconfig * it)
  * allocated by _attach().  dev-&gt;private and dev-&gt;subdevices are
  * deallocated automatically by the core.
  */
-static int rtd_detach(comedi_device * dev)
+static int rtd_detach(comedi_device *dev)
 {
 #ifdef USE_DMA
 	int index;
@@ -1137,7 +1137,7 @@ static int rtd_detach(comedi_device * dev)
 /*
   Convert a single comedi channel-gain entry to a RTD520 table entry
 */
-static unsigned short rtdConvertChanGain(comedi_device * dev,
+static unsigned short rtdConvertChanGain(comedi_device *dev,
 	unsigned int comediChan, int chanIndex)
 {				/* index in channel list */
 	unsigned int chan, range, aref;
@@ -1187,7 +1187,7 @@ static unsigned short rtdConvertChanGain(comedi_device * dev,
 /*
   Setup the channel-gain table from a comedi list
 */
-static void rtd_load_channelgain_list(comedi_device * dev,
+static void rtd_load_channelgain_list(comedi_device *dev,
 	unsigned int n_chan, unsigned int *list)
 {
 	if (n_chan &gt; 1) {	/* setup channel gain table */
@@ -1251,8 +1251,8 @@ static int rtd520_probe_fifo_depth(comedi_device *dev)
   Note, we don't do any settling delays.  Use a instruction list to
   select, delay, then read.
  */
-static int rtd_ai_rinsn(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int rtd_ai_rinsn(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	int n, ii;
 	int stat;
@@ -1304,7 +1304,7 @@ static int rtd_ai_rinsn(comedi_device * dev,
 
   The manual claims that we can do a lword read, but it doesn't work here.
 */
-static int ai_read_n(comedi_device * dev, comedi_subdevice * s, int count)
+static int ai_read_n(comedi_device *dev, comedi_subdevice *s, int count)
 {
 	int ii;
 
@@ -1343,7 +1343,7 @@ static int ai_read_n(comedi_device * dev, comedi_subdevice * s, int count)
 /*
   unknown amout of data is waiting in fifo.
 */
-static int ai_read_dregs(comedi_device * dev, comedi_subdevice * s)
+static int ai_read_dregs(comedi_device *dev, comedi_subdevice *s)
 {
 	while (RtdFifoStatus(dev) &amp; FS_ADC_NOT_EMPTY) {	/* 1 -&gt; not empty */
 		sampl_t sample;
@@ -1372,7 +1372,7 @@ static int ai_read_dregs(comedi_device * dev, comedi_subdevice * s)
 /*
   Terminate a DMA transfer and wait for everything to quiet down
 */
-void abort_dma(comedi_device * dev, unsigned int channel)
+void abort_dma(comedi_device *dev, unsigned int channel)
 {				/* DMA channel 0, 1 */
 	unsigned long dma_cs_addr;	/* the control/status register */
 	uint8_t status;
@@ -1431,7 +1431,7 @@ void abort_dma(comedi_device * dev, unsigned int channel)
   Process what is in the DMA transfer buffer and pass to comedi
   Note: this is not re-entrant
 */
-static int ai_process_dma(comedi_device * dev, comedi_subdevice * s)
+static int ai_process_dma(comedi_device *dev, comedi_subdevice *s)
 {
 	int ii, n;
 	s16 *dp;
@@ -1645,7 +1645,7 @@ static irqreturn_t rtd_interrupt(int irq,	/* interrupt number (ignored) */
 /*
   return the number of samples available
 */
-static int rtd_ai_poll(comedi_device * dev, comedi_subdevice * s)
+static int rtd_ai_poll(comedi_device *dev, comedi_subdevice *s)
 {
 	/* TODO: This needs to mask interrupts, read_dregs, and then re-enable */
 	/* Not sure what to do if DMA is active */
@@ -1662,8 +1662,8 @@ static int rtd_ai_poll(comedi_device * dev, comedi_subdevice * s)
   the command passes.
 */
 
-static int rtd_ai_cmdtest(comedi_device * dev,
-	comedi_subdevice * s, comedi_cmd * cmd)
+static int rtd_ai_cmdtest(comedi_device *dev,
+	comedi_subdevice *s, comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1867,7 +1867,7 @@ static int rtd_ai_cmdtest(comedi_device * dev,
   This is usually done by an interrupt handler.
   Userland gets to the data using read calls.
 */
-static int rtd_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int rtd_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 	comedi_cmd *cmd = &amp;s-&gt;async-&gt;cmd;
 	int timer;
@@ -2064,7 +2064,7 @@ static int rtd_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 /*
   Stop a running data aquisition.
 */
-static int rtd_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int rtd_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	u16 status;
 
@@ -2132,8 +2132,8 @@ static int rtd_ns_to_timer(unsigned int *ns, int round_mode)
 /*
   Output one (or more) analog values to a single port as fast as possible.
 */
-static int rtd_ao_winsn(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int rtd_ao_winsn(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	int i;
 	int chan = CR_CHAN(insn-&gt;chanspec);
@@ -2187,8 +2187,8 @@ static int rtd_ao_winsn(comedi_device * dev,
 
 /* AO subdevices should have a read insn as well as a write insn.
  * Usually this means copying a value stored in devpriv. */
-static int rtd_ao_rinsn(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int rtd_ao_rinsn(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	int i;
 	int chan = CR_CHAN(insn-&gt;chanspec);
@@ -2210,8 +2210,8 @@ static int rtd_ao_rinsn(comedi_device * dev,
  * This allows packed reading/writing of the DIO channels.  The
  * comedi core can convert between insn_bits and insn_read/write
  */
-static int rtd_dio_insn_bits(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int rtd_dio_insn_bits(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	if (insn-&gt;n != 2)
 		return -EINVAL;
@@ -2237,8 +2237,8 @@ static int rtd_dio_insn_bits(comedi_device * dev,
 /*
   Configure one bit on a IO port as Input or Output (hence the name :-).
 */
-static int rtd_dio_insn_config(comedi_device * dev,
-	comedi_subdevice * s, comedi_insn * insn, lsampl_t * data)
+static int rtd_dio_insn_config(comedi_device *dev,
+	comedi_subdevice *s, comedi_insn *insn, lsampl_t *data)
 {
 	int chan = CR_CHAN(insn-&gt;chanspec);
 
diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 24577a9a16b1..41f3736efa3b 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -118,8 +118,8 @@ static DEFINE_PCI_DEVICE_TABLE(s626_pci_table) = {
 
 MODULE_DEVICE_TABLE(pci, s626_pci_table);
 
-static int s626_attach(comedi_device * dev, comedi_devconfig * it);
-static int s626_detach(comedi_device * dev);
+static int s626_attach(comedi_device *dev, comedi_devconfig *it);
+static int s626_detach(comedi_device *dev);
 
 static comedi_driver driver_s626 = {
       driver_name:"s626",
@@ -222,36 +222,36 @@ static dio_private *dio_private_word[]={
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
 /* ioctl routines */
-static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
 /* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data); */
-static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s);
-static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
-	comedi_cmd * cmd);
-static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_dio_set_irq(comedi_device * dev, unsigned int chan);
-static int s626_dio_reset_irq(comedi_device * dev, unsigned int gruop,
+static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s);
+static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+	comedi_cmd *cmd);
+static int s626_ai_cancel(comedi_device *dev, comedi_subdevice *s);
+static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_dio_set_irq(comedi_device *dev, unsigned int chan);
+static int s626_dio_reset_irq(comedi_device *dev, unsigned int gruop,
 	unsigned int mask);
-static int s626_dio_clear_irq(comedi_device * dev);
-static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
-static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data);
+static int s626_dio_clear_irq(comedi_device *dev);
+static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
+static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data);
 static int s626_ns_to_timer(int *nanosec, int round_mode);
-static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd);
-static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd);
+static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 	unsigned int trignum);
 static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
 static lsampl_t s626_ai_reg_to_uint(int data);
@@ -260,36 +260,36 @@ static lsampl_t s626_ai_reg_to_uint(int data);
 /* end ioctl routines */
 
 /* internal routines */
-static void s626_dio_init(comedi_device * dev);
-static void ResetADC(comedi_device * dev, uint8_t * ppl);
-static void LoadTrimDACs(comedi_device * dev);
-static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
+static void s626_dio_init(comedi_device *dev);
+static void ResetADC(comedi_device *dev, uint8_t *ppl);
+static void LoadTrimDACs(comedi_device *dev);
+static void WriteTrimDAC(comedi_device *dev, uint8_t LogicalChan,
 	uint8_t DacData);
-static uint8_t I2Cread(comedi_device * dev, uint8_t addr);
-static uint32_t I2Chandshake(comedi_device * dev, uint32_t val);
-static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata);
-static void SendDAC(comedi_device * dev, uint32_t val);
-static void WriteMISC2(comedi_device * dev, uint16_t NewImage);
-static void DEBItransfer(comedi_device * dev);
-static uint16_t DEBIread(comedi_device * dev, uint16_t addr);
-static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata);
-static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
+static uint8_t I2Cread(comedi_device *dev, uint8_t addr);
+static uint32_t I2Chandshake(comedi_device *dev, uint32_t val);
+static void SetDAC(comedi_device *dev, uint16_t chan, short dacdata);
+static void SendDAC(comedi_device *dev, uint32_t val);
+static void WriteMISC2(comedi_device *dev, uint16_t NewImage);
+static void DEBItransfer(comedi_device *dev);
+static uint16_t DEBIread(comedi_device *dev, uint16_t addr);
+static void DEBIwrite(comedi_device *dev, uint16_t addr, uint16_t wdata);
+static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata);
-static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize);
+static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize);
 
 /*  COUNTER OBJECT ------------------------------------------------ */
 typedef struct enc_private_struct {
 	/*  Pointers to functions that differ for A and B counters: */
-	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	/* Return clock enable. */
-	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	/* Return interrupt source. */
-	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	/* Return preload trigger source. */
-	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	/* Return standardized operating mode. */
-	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	/* Generate soft index strobe. */
-	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
-	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
-	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
-	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
-	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	/* Reset event capture flags. */
+	uint16_t(*GetEnable) (comedi_device *dev, struct enc_private_struct *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (comedi_device *dev, struct enc_private_struct *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (comedi_device *dev, struct enc_private_struct *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (comedi_device *dev, struct enc_private_struct *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (comedi_device *dev, struct enc_private_struct *);	/* Generate soft index strobe. */
+	void (*SetEnable) (comedi_device *dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (comedi_device *dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (comedi_device *dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (comedi_device *dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (comedi_device *dev, struct enc_private_struct *);	/* Reset event capture flags. */
 
 	uint16_t MyCRA;		/*    Address of CRA register. */
 	uint16_t MyCRB;		/*    Address of CRB register. */
@@ -301,33 +301,33 @@ typedef struct enc_private_struct {
 #define encpriv ((enc_private *)(dev-&gt;subdevices+5)-&gt;private)
 
 /* counters routines */
-static void s626_timer_load(comedi_device * dev, enc_private * k, int tick);
-static uint32_t ReadLatch(comedi_device * dev, enc_private * k);
-static void ResetCapFlags_A(comedi_device * dev, enc_private * k);
-static void ResetCapFlags_B(comedi_device * dev, enc_private * k);
-static uint16_t GetMode_A(comedi_device * dev, enc_private * k);
-static uint16_t GetMode_B(comedi_device * dev, enc_private * k);
-static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void s626_timer_load(comedi_device *dev, enc_private *k, int tick);
+static uint32_t ReadLatch(comedi_device *dev, enc_private *k);
+static void ResetCapFlags_A(comedi_device *dev, enc_private *k);
+static void ResetCapFlags_B(comedi_device *dev, enc_private *k);
+static uint16_t GetMode_A(comedi_device *dev, enc_private *k);
+static uint16_t GetMode_B(comedi_device *dev, enc_private *k);
+static void SetMode_A(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void SetMode_B(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc);
-static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab);
-static void SetEnable_B(comedi_device * dev, enc_private * k, uint16_t enab);
-static uint16_t GetEnable_A(comedi_device * dev, enc_private * k);
-static uint16_t GetEnable_B(comedi_device * dev, enc_private * k);
-static void SetLatchSource(comedi_device * dev, enc_private * k,
+static void SetEnable_A(comedi_device *dev, enc_private *k, uint16_t enab);
+static void SetEnable_B(comedi_device *dev, enc_private *k, uint16_t enab);
+static uint16_t GetEnable_A(comedi_device *dev, enc_private *k);
+static uint16_t GetEnable_B(comedi_device *dev, enc_private *k);
+static void SetLatchSource(comedi_device *dev, enc_private *k,
 	uint16_t value);
 /* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ); */
-static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig);
-static void SetLoadTrig_B(comedi_device * dev, enc_private * k, uint16_t Trig);
-static uint16_t GetLoadTrig_A(comedi_device * dev, enc_private * k);
-static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k);
-static void SetIntSrc_B(comedi_device * dev, enc_private * k,
+static void SetLoadTrig_A(comedi_device *dev, enc_private *k, uint16_t Trig);
+static void SetLoadTrig_B(comedi_device *dev, enc_private *k, uint16_t Trig);
+static uint16_t GetLoadTrig_A(comedi_device *dev, enc_private *k);
+static uint16_t GetLoadTrig_B(comedi_device *dev, enc_private *k);
+static void SetIntSrc_B(comedi_device *dev, enc_private *k,
 	uint16_t IntSource);
-static void SetIntSrc_A(comedi_device * dev, enc_private * k,
+static void SetIntSrc_A(comedi_device *dev, enc_private *k,
 	uint16_t IntSource);
-static uint16_t GetIntSrc_A(comedi_device * dev, enc_private * k);
-static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k);
+static uint16_t GetIntSrc_A(comedi_device *dev, enc_private *k);
+static uint16_t GetIntSrc_B(comedi_device *dev, enc_private *k);
 /* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value ) ; */
 /* static uint16_t GetClkMult(comedi_device *dev, enc_private *k ) ; */
 /* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value ); */
@@ -336,10 +336,10 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k);
 /* static uint16_t GetClkSrc( comedi_device *dev,enc_private *k );  */
 /* static void SetIndexSrc( comedi_device *dev,enc_private *k, uint16_t value );  */
 /* static uint16_t GetIndexSrc( comedi_device *dev,enc_private *k );  */
-static void PulseIndex_A(comedi_device * dev, enc_private * k);
-static void PulseIndex_B(comedi_device * dev, enc_private * k);
-static void Preload(comedi_device * dev, enc_private * k, uint32_t value);
-static void CountersInit(comedi_device * dev);
+static void PulseIndex_A(comedi_device *dev, enc_private *k);
+static void PulseIndex_B(comedi_device *dev, enc_private *k);
+static void Preload(comedi_device *dev, enc_private *k, uint32_t value);
+static void CountersInit(comedi_device *dev);
 /* end internal routines */
 
 /*  Counter objects constructor. */
@@ -485,7 +485,7 @@ static const comedi_lrange s626_range_table = { 2, {
 	}
 };
 
-static int s626_attach(comedi_device * dev, comedi_devconfig * it)
+static int s626_attach(comedi_device *dev, comedi_devconfig *it)
 {
 /*   uint8_t	PollList; */
 /*   uint16_t	AdcData; */
@@ -1261,7 +1261,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 	return IRQ_HANDLED;
 }
 
-static int s626_detach(comedi_device * dev)
+static int s626_detach(comedi_device *dev)
 {
 	if (devpriv) {
 		/* stop ai_command */
@@ -1307,7 +1307,7 @@ static int s626_detach(comedi_device * dev)
 /*
  * this functions build the RPS program for hardware driven acquistion
  */
-void ResetADC(comedi_device * dev, uint8_t * ppl)
+void ResetADC(comedi_device *dev, uint8_t *ppl)
 {
 	register uint32_t *pRPS;
 	uint32_t JmpAdrs;
@@ -1499,8 +1499,8 @@ void ResetADC(comedi_device * dev, uint8_t * ppl)
 }
 
 /* TO COMPLETE, IF NECESSARY */
-static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ai_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	return -EINVAL;
@@ -1536,8 +1536,8 @@ static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 /*   return i; */
 /* } */
 
-static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ai_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	uint16_t chan = CR_CHAN(insn-&gt;chanspec);
 	uint16_t range = CR_RANGE(insn-&gt;chanspec);
@@ -1632,7 +1632,7 @@ static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd)
+static int s626_ai_load_polllist(uint8_t *ppl, comedi_cmd *cmd)
 {
 
 	int n;
@@ -1648,7 +1648,7 @@ static int s626_ai_load_polllist(uint8_t * ppl, comedi_cmd * cmd)
 	return n;
 }
 
-static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
+static int s626_ai_inttrig(comedi_device *dev, comedi_subdevice *s,
 	unsigned int trignum)
 {
 	if (trignum != 0)
@@ -1667,7 +1667,7 @@ static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
 }
 
 /*  TO COMPLETE  */
-static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
+static int s626_ai_cmd(comedi_device *dev, comedi_subdevice *s)
 {
 
 	uint8_t ppl[16];
@@ -1813,8 +1813,8 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	return 0;
 }
 
-static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
-	comedi_cmd * cmd)
+static int s626_ai_cmdtest(comedi_device *dev, comedi_subdevice *s,
+	comedi_cmd *cmd)
 {
 	int err = 0;
 	int tmp;
@@ -1998,7 +1998,7 @@ static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	return 0;
 }
 
-static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s)
+static int s626_ai_cancel(comedi_device *dev, comedi_subdevice *s)
 {
 	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
@@ -2039,8 +2039,8 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 	return divider - 1;
 }
 
-static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ao_winsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	int i;
@@ -2058,8 +2058,8 @@ static int s626_ao_winsn(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_ao_rinsn(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	int i;
 
@@ -2076,7 +2076,7 @@ static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
  * ports A, B and C, respectively.
  */
 
-static void s626_dio_init(comedi_device * dev)
+static void s626_dio_init(comedi_device *dev)
 {
 	uint16_t group;
 	comedi_subdevice *s;
@@ -2105,8 +2105,8 @@ static void s626_dio_init(comedi_device * dev)
  * This allows packed reading/writing of the DIO channels.  The comedi
  * core can convert between insn_bits and insn_read/write */
 
-static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_dio_insn_bits(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	/* Length of data must be 2 (mask and new data, see below) */
@@ -2141,8 +2141,8 @@ static int s626_dio_insn_bits(comedi_device * dev, comedi_subdevice * s,
 	return 2;
 }
 
-static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_dio_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	switch (data[0]) {
@@ -2168,7 +2168,7 @@ static int s626_dio_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
+static int s626_dio_set_irq(comedi_device *dev, unsigned int chan)
 {
 	unsigned int group;
 	unsigned int bitmask;
@@ -2210,7 +2210,7 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 	return 0;
 }
 
-static int s626_dio_reset_irq(comedi_device * dev, unsigned int group,
+static int s626_dio_reset_irq(comedi_device *dev, unsigned int group,
 	unsigned int mask)
 {
 	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
@@ -2226,7 +2226,7 @@ static int s626_dio_reset_irq(comedi_device * dev, unsigned int group,
 	return 0;
 }
 
-static int s626_dio_clear_irq(comedi_device * dev)
+static int s626_dio_clear_irq(comedi_device *dev)
 {
 	unsigned int group;
 
@@ -2246,8 +2246,8 @@ static int s626_dio_clear_irq(comedi_device * dev)
 /* Now this function initializes the value of the counter (data[0])
    and set the subdevice. To complete with trigger and interrupt
    configuration */
-static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_enc_insn_config(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2276,8 +2276,8 @@ static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
 	return insn-&gt;n;
 }
 
-static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_enc_insn_read(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	int n;
@@ -2294,8 +2294,8 @@ static int s626_enc_insn_read(comedi_device * dev, comedi_subdevice * s,
 	return n;
 }
 
-static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
-	comedi_insn * insn, lsampl_t * data)
+static int s626_enc_insn_write(comedi_device *dev, comedi_subdevice *s,
+	comedi_insn *insn, lsampl_t *data)
 {
 
 	enc_private *k = &amp;encpriv[CR_CHAN(insn-&gt;chanspec)];
@@ -2317,7 +2317,7 @@ static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
 	return 1;
 }
 
-static void s626_timer_load(comedi_device * dev, enc_private * k, int tick)
+static void s626_timer_load(comedi_device *dev, enc_private *k, int tick)
 {
 	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	/*  Preload upon */
 		/*  index. */
@@ -2363,7 +2363,7 @@ static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 static uint8_t trimadrs[] =
 	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
-static void LoadTrimDACs(comedi_device * dev)
+static void LoadTrimDACs(comedi_device *dev)
 {
 	register uint8_t i;
 
@@ -2372,7 +2372,7 @@ static void LoadTrimDACs(comedi_device * dev)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
 
-static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
+static void WriteTrimDAC(comedi_device *dev, uint8_t LogicalChan,
 	uint8_t DacData)
 {
 	uint32_t chan;
@@ -2413,7 +2413,7 @@ static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
 /* **************  EEPROM ACCESS FUNCTIONS  ************** */
 /*  Read uint8_t from EEPROM. */
 
-static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
+static uint8_t I2Cread(comedi_device *dev, uint8_t addr)
 {
 	uint8_t rtnval;
 
@@ -2448,7 +2448,7 @@ static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
 	return rtnval;
 }
 
-static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
+static uint32_t I2Chandshake(comedi_device *dev, uint32_t val)
 {
 	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
@@ -2469,7 +2469,7 @@ static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
 
 /*  Private helper function: Write setpoint to an application DAC channel. */
 
-static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
+static void SetDAC(comedi_device *dev, uint16_t chan, short dacdata)
 {
 	register uint16_t signmask;
 	register uint32_t WSImage;
@@ -2530,7 +2530,7 @@ static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
  * Dacpol contains valid target image.
  */
 
-static void SendDAC(comedi_device * dev, uint32_t val)
+static void SendDAC(comedi_device *dev, uint32_t val)
 {
 
 	/* START THE SERIAL CLOCK RUNNING ------------- */
@@ -2646,7 +2646,7 @@ static void SendDAC(comedi_device * dev, uint32_t val)
 	while ((RR7146(P_FB_BUFFER2) &amp; 0xFF000000) == 0) ;
 }
 
-static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
+static void WriteMISC2(comedi_device *dev, uint16_t NewImage)
 {
 	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
 	/*  MISC2 register. */
@@ -2656,7 +2656,7 @@ static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
 
 /*  Initialize the DEBI interface for all transfers. */
 
-static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
+static uint16_t DEBIread(comedi_device *dev, uint16_t addr)
 {
 	uint16_t retval;
 
@@ -2675,7 +2675,7 @@ static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
 
 /*  Execute a DEBI transfer.  This must be called from within a */
 /*  critical section. */
-static void DEBItransfer(comedi_device * dev)
+static void DEBItransfer(comedi_device *dev)
 {
 	/*  Initiate upload of shadow RAM to DEBI control register. */
 	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
@@ -2689,7 +2689,7 @@ static void DEBItransfer(comedi_device * dev)
 }
 
 /*  Write a value to a gate array register. */
-static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
+static void DEBIwrite(comedi_device *dev, uint16_t addr, uint16_t wdata)
 {
 
 	/*  Set up DEBI control register value in shadow RAM. */
@@ -2704,7 +2704,7 @@ static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
  * specifies bits that are to be preserved, wdata is new value to be
  * or'd with the masked original.
  */
-static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
+static void DEBIreplace(comedi_device *dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata)
 {
 
@@ -2722,7 +2722,7 @@ static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
 	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
-static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
+static void CloseDMAB(comedi_device *dev, DMABUF *pdma, size_t bsize)
 {
 	void *vbptr;
 	dma_addr_t vpptr;
@@ -2757,7 +2757,7 @@ static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
 
 /*  Read a counter's output latch. */
 
-static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
+static uint32_t ReadLatch(comedi_device *dev, enc_private *k)
 {
 	register uint32_t value;
 	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
@@ -2776,13 +2776,13 @@ static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
 
 /*  Reset a counter's index and overflow event capture flags. */
 
-static void ResetCapFlags_A(comedi_device * dev, enc_private * k)
+static void ResetCapFlags_A(comedi_device *dev, enc_private *k)
 {
 	DEBIreplace(dev, k-&gt;MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 }
 
-static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
+static void ResetCapFlags_B(comedi_device *dev, enc_private *k)
 {
 	DEBIreplace(dev, k-&gt;MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
@@ -2791,7 +2791,7 @@ static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
 /*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
 /*  for both A and B counters. */
 
-static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
+static uint16_t GetMode_A(comedi_device *dev, enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2829,7 +2829,7 @@ static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
 	return setup;
 }
 
-static uint16_t GetMode_B(comedi_device * dev, enc_private * k)
+static uint16_t GetMode_B(comedi_device *dev, enc_private *k)
 {
 	register uint16_t cra;
 	register uint16_t crb;
@@ -2875,7 +2875,7 @@ static uint16_t GetMode_B(comedi_device * dev, enc_private * k)
  * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
  */
 
-static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void SetMode_A(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -2933,7 +2933,7 @@ static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
 }
 
-static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
+static void SetMode_B(comedi_device *dev, enc_private *k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
@@ -2997,7 +2997,7 @@ static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
 
 /*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
-static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
+static void SetEnable_A(comedi_device *dev, enc_private *k, uint16_t enab)
 {
 	DEBUG("SetEnable_A: SetEnable_A enter 3541\n");
 	DEBIreplace(dev, k-&gt;MyCRB,
@@ -3005,19 +3005,19 @@ static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
 		(uint16_t) (enab &lt;&lt; CRBBIT_CLKENAB_A));
 }
 
-static void SetEnable_B(comedi_device * dev, enc_private * k, uint16_t enab)
+static void SetEnable_B(comedi_device *dev, enc_private *k, uint16_t enab)
 {
 	DEBIreplace(dev, k-&gt;MyCRB,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_B)),
 		(uint16_t) (enab &lt;&lt; CRBBIT_CLKENAB_B));
 }
 
-static uint16_t GetEnable_A(comedi_device * dev, enc_private * k)
+static uint16_t GetEnable_A(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_CLKENAB_A) &amp; 1;
 }
 
-static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
+static uint16_t GetEnable_B(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_CLKENAB_B) &amp; 1;
 }
@@ -3027,7 +3027,7 @@ static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
  * latches B.
  */
 
-static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
+static void SetLatchSource(comedi_device *dev, enc_private *k, uint16_t value)
 {
 	DEBUG("SetLatchSource: SetLatchSource enter 3550 \n");
 	DEBIreplace(dev, k-&gt;MyCRB,
@@ -3050,25 +3050,25 @@ static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
  * 2=OverflowA (B counters only), 3=disabled.
  */
 
-static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig)
+static void SetLoadTrig_A(comedi_device *dev, enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k-&gt;MyCRA, (uint16_t) (~CRAMSK_LOADSRC_A),
 		(uint16_t) (Trig &lt;&lt; CRABIT_LOADSRC_A));
 }
 
-static void SetLoadTrig_B(comedi_device * dev, enc_private * k, uint16_t Trig)
+static void SetLoadTrig_B(comedi_device *dev, enc_private *k, uint16_t Trig)
 {
 	DEBIreplace(dev, k-&gt;MyCRB,
 		(uint16_t) (~(CRBMSK_LOADSRC_B | CRBMSK_INTCTRL)),
 		(uint16_t) (Trig &lt;&lt; CRBBIT_LOADSRC_B));
 }
 
-static uint16_t GetLoadTrig_A(comedi_device * dev, enc_private * k)
+static uint16_t GetLoadTrig_A(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k-&gt;MyCRA) &gt;&gt; CRABIT_LOADSRC_A) &amp; 3;
 }
 
-static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
+static uint16_t GetLoadTrig_B(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_LOADSRC_B) &amp; 3;
 }
@@ -3078,7 +3078,7 @@ static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
  * 2=IndexOnly, 3=IndexAndOverflow.
  */
 
-static void SetIntSrc_A(comedi_device * dev, enc_private * k,
+static void SetIntSrc_A(comedi_device *dev, enc_private *k,
 	uint16_t IntSource)
 {
 	/*  Reset any pending counter overflow or index captures. */
@@ -3095,7 +3095,7 @@ static void SetIntSrc_A(comedi_device * dev, enc_private * k,
 		MyEventBits[IntSource];
 }
 
-static void SetIntSrc_B(comedi_device * dev, enc_private * k,
+static void SetIntSrc_B(comedi_device *dev, enc_private *k,
 	uint16_t IntSource)
 {
 	uint16_t crb;
@@ -3118,12 +3118,12 @@ static void SetIntSrc_B(comedi_device * dev, enc_private * k,
 		MyEventBits[IntSource];
 }
 
-static uint16_t GetIntSrc_A(comedi_device * dev, enc_private * k)
+static uint16_t GetIntSrc_A(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k-&gt;MyCRA) &gt;&gt; CRABIT_INTSRC_A) &amp; 3;
 }
 
-static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
+static uint16_t GetIntSrc_B(comedi_device *dev, enc_private *k)
 {
 	return (DEBIread(dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_INTSRC_B) &amp; 3;
 }
@@ -3191,7 +3191,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 
 /*  Generate an index pulse. */
 
-static void PulseIndex_A(comedi_device * dev, enc_private * k)
+static void PulseIndex_A(comedi_device *dev, enc_private *k)
 {
 	register uint16_t cra;
 
@@ -3203,7 +3203,7 @@ static void PulseIndex_A(comedi_device * dev, enc_private * k)
 	DEBIwrite(dev, k-&gt;MyCRA, cra);
 }
 
-static void PulseIndex_B(comedi_device * dev, enc_private * k)
+static void PulseIndex_B(comedi_device *dev, enc_private *k)
 {
 	register uint16_t crb;
 
@@ -3214,7 +3214,7 @@ static void PulseIndex_B(comedi_device * dev, enc_private * k)
 
 /*  Write value into counter preload register. */
 
-static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
+static void Preload(comedi_device *dev, enc_private *k, uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
 	DEBIwrite(dev, (uint16_t) (k-&gt;MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
@@ -3223,7 +3223,7 @@ static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
 		(uint16_t) (value &gt;&gt; 16));
 }
 
-static void CountersInit(comedi_device * dev)
+static void CountersInit(comedi_device *dev)
 {
 	int chan;
 	enc_private *k;
diff --git a/drivers/staging/comedi/kcomedilib/data.c b/drivers/staging/comedi/kcomedilib/data.c
index 79aec2041150..4f1a41d50861 100644
--- a/drivers/staging/comedi/kcomedilib/data.c
+++ b/drivers/staging/comedi/kcomedilib/data.c
@@ -27,7 +27,7 @@
 
 #include &lt;linux/string.h&gt;
 
-int comedi_data_write(comedi_t * dev, unsigned int subdev, unsigned int chan,
+int comedi_data_write(comedi_t *dev, unsigned int subdev, unsigned int chan,
 	unsigned int range, unsigned int aref, lsampl_t data)
 {
 	comedi_insn insn;
@@ -42,8 +42,8 @@ int comedi_data_write(comedi_t * dev, unsigned int subdev, unsigned int chan,
 	return comedi_do_insn(dev, &amp;insn);
 }
 
-int comedi_data_read(comedi_t * dev, unsigned int subdev, unsigned int chan,
-	unsigned int range, unsigned int aref, lsampl_t * data)
+int comedi_data_read(comedi_t *dev, unsigned int subdev, unsigned int chan,
+	unsigned int range, unsigned int aref, lsampl_t *data)
 {
 	comedi_insn insn;
 
@@ -57,7 +57,7 @@ int comedi_data_read(comedi_t * dev, unsigned int subdev, unsigned int chan,
 	return comedi_do_insn(dev, &amp;insn);
 }
 
-int comedi_data_read_hint(comedi_t * dev, unsigned int subdev,
+int comedi_data_read_hint(comedi_t *dev, unsigned int subdev,
 	unsigned int chan, unsigned int range, unsigned int aref)
 {
 	comedi_insn insn;
@@ -73,9 +73,9 @@ int comedi_data_read_hint(comedi_t * dev, unsigned int subdev,
 	return comedi_do_insn(dev, &amp;insn);
 }
 
-int comedi_data_read_delayed(comedi_t * dev, unsigned int subdev,
+int comedi_data_read_delayed(comedi_t *dev, unsigned int subdev,
 	unsigned int chan, unsigned int range, unsigned int aref,
-	lsampl_t * data, unsigned int nano_sec)
+	lsampl_t *data, unsigned int nano_sec)
 {
 	int retval;
 
diff --git a/drivers/staging/comedi/kcomedilib/dio.c b/drivers/staging/comedi/kcomedilib/dio.c
index a9f488aed369..823052776e93 100644
--- a/drivers/staging/comedi/kcomedilib/dio.c
+++ b/drivers/staging/comedi/kcomedilib/dio.c
@@ -26,7 +26,7 @@
 
 #include &lt;linux/string.h&gt;
 
-int comedi_dio_config(comedi_t * dev, unsigned int subdev, unsigned int chan,
+int comedi_dio_config(comedi_t *dev, unsigned int subdev, unsigned int chan,
 	unsigned int io)
 {
 	comedi_insn insn;
@@ -41,7 +41,7 @@ int comedi_dio_config(comedi_t * dev, unsigned int subdev, unsigned int chan,
 	return comedi_do_insn(dev, &amp;insn);
 }
 
-int comedi_dio_read(comedi_t * dev, unsigned int subdev, unsigned int chan,
+int comedi_dio_read(comedi_t *dev, unsigned int subdev, unsigned int chan,
 	unsigned int *val)
 {
 	comedi_insn insn;
@@ -56,7 +56,7 @@ int comedi_dio_read(comedi_t * dev, unsigned int subdev, unsigned int chan,
 	return comedi_do_insn(dev, &amp;insn);
 }
 
-int comedi_dio_write(comedi_t * dev, unsigned int subdev, unsigned int chan,
+int comedi_dio_write(comedi_t *dev, unsigned int subdev, unsigned int chan,
 	unsigned int val)
 {
 	comedi_insn insn;
@@ -71,7 +71,7 @@ int comedi_dio_write(comedi_t * dev, unsigned int subdev, unsigned int chan,
 	return comedi_do_insn(dev, &amp;insn);
 }
 
-int comedi_dio_bitfield(comedi_t * dev, unsigned int subdev, unsigned int mask,
+int comedi_dio_bitfield(comedi_t *dev, unsigned int subdev, unsigned int mask,
 	unsigned int *bits)
 {
 	comedi_insn insn;
diff --git a/drivers/staging/comedi/kcomedilib/get.c b/drivers/staging/comedi/kcomedilib/get.c
index 2004ad4480c0..781733787e96 100644
--- a/drivers/staging/comedi/kcomedilib/get.c
+++ b/drivers/staging/comedi/kcomedilib/get.c
@@ -26,14 +26,14 @@
 #include "../comedilib.h"
 #include "../comedidev.h"
 
-int comedi_get_n_subdevices(comedi_t * d)
+int comedi_get_n_subdevices(comedi_t *d)
 {
 	comedi_device *dev = (comedi_device *) d;
 
 	return dev-&gt;n_subdevices;
 }
 
-int comedi_get_version_code(comedi_t * d)
+int comedi_get_version_code(comedi_t *d)
 {
 	return COMEDI_VERSION_CODE;
 }
@@ -52,7 +52,7 @@ const char *comedi_get_board_name(comedi_t * d)
 	return dev-&gt;board_name;
 }
 
-int comedi_get_subdevice_type(comedi_t * d, unsigned int subdevice)
+int comedi_get_subdevice_type(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -60,7 +60,7 @@ int comedi_get_subdevice_type(comedi_t * d, unsigned int subdevice)
 	return s-&gt;type;
 }
 
-unsigned int comedi_get_subdevice_flags(comedi_t * d, unsigned int subdevice)
+unsigned int comedi_get_subdevice_flags(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -68,7 +68,7 @@ unsigned int comedi_get_subdevice_flags(comedi_t * d, unsigned int subdevice)
 	return s-&gt;subdev_flags;
 }
 
-int comedi_find_subdevice_by_type(comedi_t * d, int type, unsigned int subd)
+int comedi_find_subdevice_by_type(comedi_t *d, int type, unsigned int subd)
 {
 	comedi_device *dev = (comedi_device *) d;
 
@@ -82,7 +82,7 @@ int comedi_find_subdevice_by_type(comedi_t * d, int type, unsigned int subd)
 	return -1;
 }
 
-int comedi_get_n_channels(comedi_t * d, unsigned int subdevice)
+int comedi_get_n_channels(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -90,7 +90,7 @@ int comedi_get_n_channels(comedi_t * d, unsigned int subdevice)
 	return s-&gt;n_chan;
 }
 
-int comedi_get_len_chanlist(comedi_t * d, unsigned int subdevice)
+int comedi_get_len_chanlist(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -98,7 +98,7 @@ int comedi_get_len_chanlist(comedi_t * d, unsigned int subdevice)
 	return s-&gt;len_chanlist;
 }
 
-lsampl_t comedi_get_maxdata(comedi_t * d, unsigned int subdevice,
+lsampl_t comedi_get_maxdata(comedi_t *d, unsigned int subdevice,
 	unsigned int chan)
 {
 	comedi_device *dev = (comedi_device *) d;
@@ -111,7 +111,7 @@ lsampl_t comedi_get_maxdata(comedi_t * d, unsigned int subdevice,
 }
 
 #ifdef KCOMEDILIB_DEPRECATED
-int comedi_get_rangetype(comedi_t * d, unsigned int subdevice,
+int comedi_get_rangetype(comedi_t *d, unsigned int subdevice,
 	unsigned int chan)
 {
 	comedi_device *dev = (comedi_device *) d;
@@ -130,7 +130,7 @@ int comedi_get_rangetype(comedi_t * d, unsigned int subdevice,
 }
 #endif
 
-int comedi_get_n_ranges(comedi_t * d, unsigned int subdevice, unsigned int chan)
+int comedi_get_n_ranges(comedi_t *d, unsigned int subdevice, unsigned int chan)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -148,8 +148,8 @@ int comedi_get_n_ranges(comedi_t * d, unsigned int subdevice, unsigned int chan)
 /*
  * ALPHA (non-portable)
 */
-int comedi_get_krange(comedi_t * d, unsigned int subdevice, unsigned int chan,
-	unsigned int range, comedi_krange * krange)
+int comedi_get_krange(comedi_t *d, unsigned int subdevice, unsigned int chan,
+	unsigned int range, comedi_krange *krange)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -171,7 +171,7 @@ int comedi_get_krange(comedi_t * d, unsigned int subdevice, unsigned int chan,
 /*
  * ALPHA (may be renamed)
 */
-unsigned int comedi_get_buf_head_pos(comedi_t * d, unsigned int subdevice)
+unsigned int comedi_get_buf_head_pos(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -184,7 +184,7 @@ unsigned int comedi_get_buf_head_pos(comedi_t * d, unsigned int subdevice)
 	return async-&gt;buf_write_count;
 }
 
-int comedi_get_buffer_contents(comedi_t * d, unsigned int subdevice)
+int comedi_get_buffer_contents(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
@@ -203,7 +203,7 @@ int comedi_get_buffer_contents(comedi_t * d, unsigned int subdevice)
 /*
  * ALPHA
 */
-int comedi_set_user_int_count(comedi_t * d, unsigned int subdevice,
+int comedi_set_user_int_count(comedi_t *d, unsigned int subdevice,
 	unsigned int buf_user_count)
 {
 	comedi_device *dev = (comedi_device *) d;
@@ -224,7 +224,7 @@ int comedi_set_user_int_count(comedi_t * d, unsigned int subdevice,
 	return 0;
 }
 
-int comedi_mark_buffer_read(comedi_t * d, unsigned int subdevice,
+int comedi_mark_buffer_read(comedi_t *d, unsigned int subdevice,
 	unsigned int num_bytes)
 {
 	comedi_device *dev = (comedi_device *) d;
@@ -243,7 +243,7 @@ int comedi_mark_buffer_read(comedi_t * d, unsigned int subdevice,
 	return 0;
 }
 
-int comedi_mark_buffer_written(comedi_t * d, unsigned int subdevice,
+int comedi_mark_buffer_written(comedi_t *d, unsigned int subdevice,
 	unsigned int num_bytes)
 {
 	comedi_device *dev = (comedi_device *) d;
@@ -263,7 +263,7 @@ int comedi_mark_buffer_written(comedi_t * d, unsigned int subdevice,
 	return 0;
 }
 
-int comedi_get_buffer_size(comedi_t * d, unsigned int subdev)
+int comedi_get_buffer_size(comedi_t *d, unsigned int subdev)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdev;
@@ -278,7 +278,7 @@ int comedi_get_buffer_size(comedi_t * d, unsigned int subdev)
 	return async-&gt;prealloc_bufsz;
 }
 
-int comedi_get_buffer_offset(comedi_t * d, unsigned int subdevice)
+int comedi_get_buffer_offset(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices + subdevice;
diff --git a/drivers/staging/comedi/kcomedilib/kcomedilib_main.c b/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
index 510fbdcec493..e758e4e8c91b 100644
--- a/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
+++ b/drivers/staging/comedi/kcomedilib/kcomedilib_main.c
@@ -89,7 +89,7 @@ comedi_t *comedi_open_old(unsigned int minor)
 	return (comedi_t *) dev;
 }
 
-int comedi_close(comedi_t * d)
+int comedi_close(comedi_t *d)
 {
 	comedi_device *dev = (comedi_device *) d;
 
@@ -113,7 +113,7 @@ char *comedi_strerror(int err)
 	return "unknown error";
 }
 
-int comedi_fileno(comedi_t * d)
+int comedi_fileno(comedi_t *d)
 {
 	comedi_device *dev = (comedi_device *) d;
 
@@ -121,7 +121,7 @@ int comedi_fileno(comedi_t * d)
 	return dev-&gt;minor;
 }
 
-int comedi_command(comedi_t * d, comedi_cmd * cmd)
+int comedi_command(comedi_t *d, comedi_cmd *cmd)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
@@ -161,7 +161,7 @@ int comedi_command(comedi_t * d, comedi_cmd * cmd)
 	return s-&gt;do_cmd(dev, s);
 }
 
-int comedi_command_test(comedi_t * d, comedi_cmd * cmd)
+int comedi_command_test(comedi_t *d, comedi_cmd *cmd)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
@@ -183,7 +183,7 @@ int comedi_command_test(comedi_t * d, comedi_cmd * cmd)
  *	COMEDI_INSN
  *	perform an instruction
  */
-int comedi_do_insn(comedi_t * d, comedi_insn * insn)
+int comedi_do_insn(comedi_t *d, comedi_insn *insn)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
@@ -323,7 +323,7 @@ int comedi_do_insn(comedi_t * d, comedi_insn * insn)
 	- lock while subdevice being programmed
 
 */
-int comedi_lock(comedi_t * d, unsigned int subdevice)
+int comedi_lock(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
@@ -366,7 +366,7 @@ int comedi_lock(comedi_t * d, unsigned int subdevice)
 		none
 
 */
-int comedi_unlock(comedi_t * d, unsigned int subdevice)
+int comedi_unlock(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
@@ -418,7 +418,7 @@ int comedi_unlock(comedi_t * d, unsigned int subdevice)
 		nothing
 
 */
-int comedi_cancel(comedi_t * d, unsigned int subdevice)
+int comedi_cancel(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
@@ -461,7 +461,7 @@ int comedi_cancel(comedi_t * d, unsigned int subdevice)
 /*
    registration of callback functions
  */
-int comedi_register_callback(comedi_t * d, unsigned int subdevice,
+int comedi_register_callback(comedi_t *d, unsigned int subdevice,
 	unsigned int mask, int (*cb) (unsigned int, void *), void *arg)
 {
 	comedi_device *dev = (comedi_device *) d;
@@ -498,7 +498,7 @@ int comedi_register_callback(comedi_t * d, unsigned int subdevice,
 	return 0;
 }
 
-int comedi_poll(comedi_t * d, unsigned int subdevice)
+int comedi_poll(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s = dev-&gt;subdevices;
@@ -525,7 +525,7 @@ int comedi_poll(comedi_t * d, unsigned int subdevice)
 }
 
 /* WARNING: not portable */
-int comedi_map(comedi_t * d, unsigned int subdevice, void *ptr)
+int comedi_map(comedi_t *d, unsigned int subdevice, void *ptr)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
@@ -548,7 +548,7 @@ int comedi_map(comedi_t * d, unsigned int subdevice, void *ptr)
 }
 
 /* WARNING: not portable */
-int comedi_unmap(comedi_t * d, unsigned int subdevice)
+int comedi_unmap(comedi_t *d, unsigned int subdevice)
 {
 	comedi_device *dev = (comedi_device *) d;
 	comedi_subdevice *s;
diff --git a/drivers/staging/comedi/range.c b/drivers/staging/comedi/range.c
index 2934fb3162cd..b8eb4ec41854 100644
--- a/drivers/staging/comedi/range.c
+++ b/drivers/staging/comedi/range.c
@@ -44,7 +44,7 @@ const comedi_lrange range_unknown = { 1, {{0, 1000000, UNIT_none}} };
 	writes:
 		n comedi_krange structures to rangeinfo-&gt;range_ptr
 */
-int do_rangeinfo_ioctl(comedi_device * dev, comedi_rangeinfo * arg)
+int do_rangeinfo_ioctl(comedi_device *dev, comedi_rangeinfo *arg)
 {
 	comedi_rangeinfo it;
 	int subd, chan;
@@ -84,7 +84,7 @@ int do_rangeinfo_ioctl(comedi_device * dev, comedi_rangeinfo * arg)
 	return 0;
 }
 
-static int aref_invalid(comedi_subdevice * s, unsigned int chanspec)
+static int aref_invalid(comedi_subdevice *s, unsigned int chanspec)
 {
 	unsigned int aref;
 
@@ -120,7 +120,7 @@ static int aref_invalid(comedi_subdevice * s, unsigned int chanspec)
    This function checks each element in a channel/gain list to make
    make sure it is valid.
 */
-int check_chanlist(comedi_subdevice * s, int n, unsigned int *chanlist)
+int check_chanlist(comedi_subdevice *s, int n, unsigned int *chanlist)
 {
 	int i;
 	int chan;
diff --git a/drivers/staging/comedi/rt.c b/drivers/staging/comedi/rt.c
index 2546c64dab00..ba9c70ecd044 100644
--- a/drivers/staging/comedi/rt.c
+++ b/drivers/staging/comedi/rt.c
@@ -67,7 +67,7 @@ static struct comedi_irq_struct *comedi_irqs[NR_IRQS];
 
 int comedi_request_irq(unsigned irq, irqreturn_t(*handler) (int,
 		void *PT_REGS_ARG), unsigned long flags, const char *device,
-	comedi_device * dev_id)
+	comedi_device *dev_id)
 {
 	struct comedi_irq_struct *it;
 	int ret;
@@ -102,7 +102,7 @@ int comedi_request_irq(unsigned irq, irqreturn_t(*handler) (int,
 	return 0;
 }
 
-void comedi_free_irq(unsigned int irq, comedi_device * dev_id)
+void comedi_free_irq(unsigned int irq, comedi_device *dev_id)
 {
 	struct comedi_irq_struct *it;
 
@@ -121,7 +121,7 @@ void comedi_free_irq(unsigned int irq, comedi_device * dev_id)
 	comedi_irqs[irq] = NULL;
 }
 
-int comedi_switch_to_rt(comedi_device * dev)
+int comedi_switch_to_rt(comedi_device *dev)
 {
 	struct comedi_irq_struct *it;
 	unsigned long flags;
@@ -145,7 +145,7 @@ int comedi_switch_to_rt(comedi_device * dev)
 	return 0;
 }
 
-void comedi_switch_to_non_rt(comedi_device * dev)
+void comedi_switch_to_non_rt(comedi_device *dev)
 {
 	struct comedi_irq_struct *it;
 	unsigned long flags;
@@ -170,7 +170,7 @@ void wake_up_int_handler(int arg1, void *arg2)
 	wake_up_interruptible((wait_queue_head_t *) arg2);
 }
 
-void comedi_rt_pend_wakeup(wait_queue_head_t * q)
+void comedi_rt_pend_wakeup(wait_queue_head_t *q)
 {
 	rt_pend_call(wake_up_int_handler, 0, q);
 }</pre><hr><pre>commit b6c777571b8d387d3add91170826f32a379e4313
Author: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
Date:   Mon Mar 16 22:03:24 2009 -0400

    Staging: comedi: Convert C99 style comments to traditional style comments
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/staging/comedi/comedi_ksyms.c b/drivers/staging/comedi/comedi_ksyms.c
index 7d0db3bb680f..6e6fb979ef54 100644
--- a/drivers/staging/comedi/comedi_ksyms.c
+++ b/drivers/staging/comedi/comedi_ksyms.c
@@ -31,12 +31,12 @@
 /* for drivers */
 EXPORT_SYMBOL(comedi_driver_register);
 EXPORT_SYMBOL(comedi_driver_unregister);
-//EXPORT_SYMBOL(comedi_bufcheck);
-//EXPORT_SYMBOL(comedi_done);
-//EXPORT_SYMBOL(comedi_error_done);
+/* EXPORT_SYMBOL(comedi_bufcheck); */
+/* EXPORT_SYMBOL(comedi_done); */
+/* EXPORT_SYMBOL(comedi_error_done); */
 EXPORT_SYMBOL(comedi_error);
-//EXPORT_SYMBOL(comedi_eobuf);
-//EXPORT_SYMBOL(comedi_eos);
+/* EXPORT_SYMBOL(comedi_eobuf); */
+/* EXPORT_SYMBOL(comedi_eos); */
 EXPORT_SYMBOL(comedi_event);
 EXPORT_SYMBOL(comedi_get_subdevice_runflags);
 EXPORT_SYMBOL(comedi_set_subdevice_runflags);
diff --git a/drivers/staging/comedi/drivers.c b/drivers/staging/comedi/drivers.c
index e14aef2a197a..48e54042f8b3 100644
--- a/drivers/staging/comedi/drivers.c
+++ b/drivers/staging/comedi/drivers.c
@@ -140,7 +140,7 @@ int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
 				continue;
 			}
 		}
-		//initialize dev-&gt;driver here so comedi_error() can be called from attach
+		/* initialize dev-&gt;driver here so comedi_error() can be called from attach */
 		dev-&gt;driver = driv;
 		ret = driv-&gt;attach(dev, it);
 		if (ret &lt; 0) {
@@ -151,8 +151,8 @@ int comedi_device_attach(comedi_device * dev, comedi_devconfig * it)
 		goto attached;
 	}
 
-	// recognize has failed if we get here
-	// report valid board names before returning error
+	/*  recognize has failed if we get here */
+	/*  report valid board names before returning error */
 	for (driv = comedi_drivers; driv; driv = driv-&gt;next) {
 		if (!try_module_get(driv-&gt;module)) {
 			printk("comedi: failed to increment module count\n");
@@ -299,7 +299,7 @@ static int postconfig(comedi_device * dev)
 	return 0;
 }
 
-// generic recognize function for drivers that register their supported board names
+/*  generic recognize function for drivers that register their supported board names */
 void *comedi_recognize(comedi_driver * driv, const char *name)
 {
 	unsigned i;
@@ -426,7 +426,7 @@ int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
 	if (async-&gt;prealloc_buf &amp;&amp; async-&gt;prealloc_bufsz == new_size) {
 		return 0;
 	}
-	// deallocate old buffer
+	/*  deallocate old buffer */
 	if (async-&gt;prealloc_buf) {
 		vunmap(async-&gt;prealloc_buf);
 		async-&gt;prealloc_buf = NULL;
@@ -455,7 +455,7 @@ int comedi_buf_alloc(comedi_device * dev, comedi_subdevice * s,
 		async-&gt;buf_page_list = NULL;
 		async-&gt;n_buf_pages = 0;
 	}
-	// allocate new buffer
+	/*  allocate new buffer */
 	if (new_size) {
 		unsigned i = 0;
 		unsigned n_pages = new_size &gt;&gt; PAGE_SHIFT;
@@ -568,7 +568,7 @@ unsigned int comedi_buf_munge(comedi_async * async, unsigned int num_bytes)
 		s-&gt;munge(s-&gt;device, s, async-&gt;prealloc_buf + async-&gt;munge_ptr,
 			block_size, async-&gt;munge_chan);
 
-		smp_wmb();	//barrier insures data is munged in buffer before munge_count is incremented
+		smp_wmb();	/* barrier insures data is munged in buffer before munge_count is incremented */
 
 		async-&gt;munge_chan += block_size / num_sample_bytes;
 		async-&gt;munge_chan %= async-&gt;cmd.chanlist_len;
@@ -667,7 +667,7 @@ unsigned comedi_buf_read_alloc(comedi_async * async, unsigned nbytes)
 /* transfers control of a chunk from reader to free buffer space */
 unsigned comedi_buf_read_free(comedi_async * async, unsigned int nbytes)
 {
-	// barrier insures data has been read out of buffer before read count is incremented
+	/*  barrier insures data has been read out of buffer before read count is incremented */
 	smp_mb();
 	if ((int)(async-&gt;buf_read_count + nbytes -
 			async-&gt;buf_read_alloc_count) &gt; 0) {
@@ -852,9 +852,9 @@ int comedi_pci_auto_config(struct pci_dev *pcidev, const char *board_name)
 {
 	int options[2];
 
-	// pci bus
+	/*  pci bus */
 	options[0] = pcidev-&gt;bus-&gt;number;
-	// pci slot
+	/*  pci slot */
 	options[1] = PCI_SLOT(pcidev-&gt;devfn);
 
 	return comedi_auto_config(&amp;pcidev-&gt;dev, board_name, options, sizeof(options) / sizeof(options[0]));
diff --git a/drivers/staging/comedi/drivers/icp_multi.c b/drivers/staging/comedi/drivers/icp_multi.c
index 59144d7cb0bc..143a5f95b31f 100644
--- a/drivers/staging/comedi/drivers/icp_multi.c
+++ b/drivers/staging/comedi/drivers/icp_multi.c
@@ -61,7 +61,7 @@ There are 4 x 12-bit Analogue Outputs.  Ranges : 5V, 10V, +/-5V, +/-10V
 
 #define ICP_MULTI_EXTDEBUG
 
-// Hardware types of the cards
+/*  Hardware types of the cards */
 #define TYPE_ICP_MULTI	0
 
 #define IORANGE_ICP_MULTI 	32
@@ -81,20 +81,20 @@ There are 4 x 12-bit Analogue Outputs.  Ranges : 5V, 10V, +/-5V, +/-10V
 
 #define ICP_MULTI_SIZE		0x20	/* 32 bytes */
 
-// Define bits from ADC command/status register
+/*  Define bits from ADC command/status register */
 #define	ADC_ST		0x0001	/* Start ADC */
 #define	ADC_BSY		0x0001	/* ADC busy */
 #define ADC_BI		0x0010	/* Bipolar input range 1 = bipolar */
 #define ADC_RA		0x0020	/* Input range 0 = 5V, 1 = 10V */
 #define	ADC_DI		0x0040	/* Differential input mode 1 = differential */
 
-// Define bits from DAC command/status register
+/*  Define bits from DAC command/status register */
 #define	DAC_ST		0x0001	/* Start DAC */
 #define DAC_BSY		0x0001	/* DAC busy */
 #define	DAC_BI		0x0010	/* Bipolar input range 1 = bipolar */
 #define	DAC_RA		0x0020	/* Input range 0 = 5V, 1 = 10V */
 
-// Define bits from interrupt enable/status registers
+/*  Define bits from interrupt enable/status registers */
 #define	ADC_READY	0x0001	/* A/d conversion ready interrupt */
 #define	DAC_READY	0x0002	/* D/a conversion ready interrupt */
 #define	DOUT_ERROR	0x0004	/* Digital output error interrupt */
@@ -104,10 +104,10 @@ There are 4 x 12-bit Analogue Outputs.  Ranges : 5V, 10V, +/-5V, +/-10V
 #define	CIE2		0x0040	/* Counter 2 overrun interrupt */
 #define	CIE3		0x0080	/* Counter 3 overrun interrupt */
 
-// Useful definitions
-#define	Status_IRQ	0x00ff	// All interrupts
+/*  Useful definitions */
+#define	Status_IRQ	0x00ff	/*  All interrupts */
 
-// Define analogue range
+/*  Define analogue range */
 static const comedi_lrange range_analog = { 4, {
 			UNI_RANGE(5),
 			UNI_RANGE(10),
@@ -134,41 +134,41 @@ static int icp_multi_detach(comedi_device * dev);
 static unsigned short pci_list_builded = 0;	/*&gt;0 list of card is known */
 
 typedef struct {
-	const char *name;	// driver name
+	const char *name;	/*  driver name */
 	int device_id;
-	int iorange;		// I/O range len
-	char have_irq;		// 1=card support IRQ
-	char cardtype;		// 0=ICP Multi
-	int n_aichan;		// num of A/D chans
-	int n_aichand;		// num of A/D chans in diff mode
-	int n_aochan;		// num of D/A chans
-	int n_dichan;		// num of DI chans
-	int n_dochan;		// num of DO chans
-	int n_ctrs;		// num of counters
-	int ai_maxdata;		// resolution of A/D
-	int ao_maxdata;		// resolution of D/A
-	const comedi_lrange *rangelist_ai;	// rangelist for A/D
-	const char *rangecode;	// range codes for programming
-	const comedi_lrange *rangelist_ao;	// rangelist for D/A
+	int iorange;		/*  I/O range len */
+	char have_irq;		/*  1=card support IRQ */
+	char cardtype;		/*  0=ICP Multi */
+	int n_aichan;		/*  num of A/D chans */
+	int n_aichand;		/*  num of A/D chans in diff mode */
+	int n_aochan;		/*  num of D/A chans */
+	int n_dichan;		/*  num of DI chans */
+	int n_dochan;		/*  num of DO chans */
+	int n_ctrs;		/*  num of counters */
+	int ai_maxdata;		/*  resolution of A/D */
+	int ao_maxdata;		/*  resolution of D/A */
+	const comedi_lrange *rangelist_ai;	/*  rangelist for A/D */
+	const char *rangecode;	/*  range codes for programming */
+	const comedi_lrange *rangelist_ao;	/*  rangelist for D/A */
 } boardtype;
 
 static const boardtype boardtypes[] = {
-	{"icp_multi",		// Driver name
-			DEVICE_ID,	// PCI device ID
-			IORANGE_ICP_MULTI,	// I/O range length
-			1,	// 1=Card supports interrupts
-			TYPE_ICP_MULTI,	// Card type = ICP MULTI
-			16,	// Num of A/D channels
-			8,	// Num of A/D channels in diff mode
-			4,	// Num of D/A channels
-			16,	// Num of digital inputs
-			8,	// Num of digital outputs
-			4,	// Num of counters
-			0x0fff,	// Resolution of A/D
-			0x0fff,	// Resolution of D/A
-			&amp;range_analog,	// Rangelist for A/D
-			range_codes_analog,	// Range codes for programming
-		&amp;range_analog},	// Rangelist for D/A
+	{"icp_multi",		/*  Driver name */
+			DEVICE_ID,	/*  PCI device ID */
+			IORANGE_ICP_MULTI,	/*  I/O range length */
+			1,	/*  1=Card supports interrupts */
+			TYPE_ICP_MULTI,	/*  Card type = ICP MULTI */
+			16,	/*  Num of A/D channels */
+			8,	/*  Num of A/D channels in diff mode */
+			4,	/*  Num of D/A channels */
+			16,	/*  Num of digital inputs */
+			8,	/*  Num of digital outputs */
+			4,	/*  Num of counters */
+			0x0fff,	/*  Resolution of A/D */
+			0x0fff,	/*  Resolution of D/A */
+			&amp;range_analog,	/*  Rangelist for A/D */
+			range_codes_analog,	/*  Range codes for programming */
+		&amp;range_analog},	/*  Rangelist for D/A */
 };
 
 #define n_boardtypes (sizeof(boardtypes)/sizeof(boardtype))
@@ -186,22 +186,22 @@ static comedi_driver driver_icp_multi = {
 COMEDI_INITCLEANUP(driver_icp_multi);
 
 typedef struct {
-	struct pcilst_struct *card;	// pointer to card
-	char valid;		// card is usable
-	void *io_addr;		// Pointer to mapped io address
-	resource_size_t phys_iobase;	// Physical io address
-	unsigned int AdcCmdStatus;	// ADC Command/Status register
-	unsigned int DacCmdStatus;	// DAC Command/Status register
-	unsigned int IntEnable;	// Interrupt Enable register
-	unsigned int IntStatus;	// Interrupt Status register
-	unsigned int act_chanlist[32];	// list of scaned channel
-	unsigned char act_chanlist_len;	// len of scanlist
-	unsigned char act_chanlist_pos;	// actual position in MUX list
-	unsigned int *ai_chanlist;	// actaul chanlist
-	sampl_t *ai_data;	// data buffer
-	sampl_t ao_data[4];	// data output buffer
-	sampl_t di_data;	// Digital input data
-	unsigned int do_data;	// Remember digital output data
+	struct pcilst_struct *card;	/*  pointer to card */
+	char valid;		/*  card is usable */
+	void *io_addr;		/*  Pointer to mapped io address */
+	resource_size_t phys_iobase;	/*  Physical io address */
+	unsigned int AdcCmdStatus;	/*  ADC Command/Status register */
+	unsigned int DacCmdStatus;	/*  DAC Command/Status register */
+	unsigned int IntEnable;	/*  Interrupt Enable register */
+	unsigned int IntStatus;	/*  Interrupt Status register */
+	unsigned int act_chanlist[32];	/*  list of scaned channel */
+	unsigned char act_chanlist_len;	/*  len of scanlist */
+	unsigned char act_chanlist_pos;	/*  actual position in MUX list */
+	unsigned int *ai_chanlist;	/*  actaul chanlist */
+	sampl_t *ai_data;	/*  data buffer */
+	sampl_t ao_data[4];	/*  data output buffer */
+	sampl_t di_data;	/*  Digital input data */
+	unsigned int do_data;	/*  Remember digital output data */
 } icp_multi_private;
 
 #define devpriv ((icp_multi_private *)dev-&gt;private)
@@ -253,15 +253,15 @@ static int icp_multi_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: BGN: icp_multi_insn_read_ai(...)\n");
 #endif
-	// Disable A/D conversion ready interrupt
+	/*  Disable A/D conversion ready interrupt */
 	devpriv-&gt;IntEnable &amp;= ~ADC_READY;
 	writew(devpriv-&gt;IntEnable, devpriv-&gt;io_addr + ICP_MULTI_INT_EN);
 
-	// Clear interrupt status
+	/*  Clear interrupt status */
 	devpriv-&gt;IntStatus |= ADC_READY;
 	writew(devpriv-&gt;IntStatus, devpriv-&gt;io_addr + ICP_MULTI_INT_STAT);
 
-	// Set up appropriate channel, mode and range data, for specified channel
+	/*  Set up appropriate channel, mode and range data, for specified channel */
 	setup_channel_list(dev, s, &amp;insn-&gt;chanspec, 1);
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -271,7 +271,7 @@ static int icp_multi_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 #endif
 
 	for (n = 0; n &lt; insn-&gt;n; n++) {
-		// Set start ADC bit
+		/*  Set start ADC bit */
 		devpriv-&gt;AdcCmdStatus |= ADC_ST;
 		writew(devpriv-&gt;AdcCmdStatus,
 			devpriv-&gt;io_addr + ICP_MULTI_ADC_CSR);
@@ -289,7 +289,7 @@ static int icp_multi_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 			readw(devpriv-&gt;io_addr + ICP_MULTI_ADC_CSR));
 #endif
 
-		// Wait for conversion to complete, or get fed up waiting
+		/*  Wait for conversion to complete, or get fed up waiting */
 		timeout = 100;
 		while (timeout--) {
 			if (!(readw(devpriv-&gt;io_addr +
@@ -307,19 +307,19 @@ static int icp_multi_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 			comedi_udelay(1);
 		}
 
-		// If we reach here, a timeout has occurred
+		/*  If we reach here, a timeout has occurred */
 		comedi_error(dev, "A/D insn timeout");
 
-		// Disable interrupt
+		/*  Disable interrupt */
 		devpriv-&gt;IntEnable &amp;= ~ADC_READY;
 		writew(devpriv-&gt;IntEnable, devpriv-&gt;io_addr + ICP_MULTI_INT_EN);
 
-		// Clear interrupt status
+		/*  Clear interrupt status */
 		devpriv-&gt;IntStatus |= ADC_READY;
 		writew(devpriv-&gt;IntStatus,
 			devpriv-&gt;io_addr + ICP_MULTI_INT_STAT);
 
-		// Clear data received
+		/*  Clear data received */
 		data[n] = 0;
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -332,11 +332,11 @@ static int icp_multi_insn_read_ai(comedi_device * dev, comedi_subdevice * s,
 			(readw(devpriv-&gt;io_addr + ICP_MULTI_AI) &gt;&gt; 4) &amp; 0x0fff;
 	}
 
-	// Disable interrupt
+	/*  Disable interrupt */
 	devpriv-&gt;IntEnable &amp;= ~ADC_READY;
 	writew(devpriv-&gt;IntEnable, devpriv-&gt;io_addr + ICP_MULTI_INT_EN);
 
-	// Clear interrupt status
+	/*  Clear interrupt status */
 	devpriv-&gt;IntStatus |= ADC_READY;
 	writew(devpriv-&gt;IntStatus, devpriv-&gt;io_addr + ICP_MULTI_INT_STAT);
 
@@ -372,23 +372,23 @@ static int icp_multi_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG: BGN: icp_multi_insn_write_ao(...)\n");
 #endif
-	// Disable D/A conversion ready interrupt
+	/*  Disable D/A conversion ready interrupt */
 	devpriv-&gt;IntEnable &amp;= ~DAC_READY;
 	writew(devpriv-&gt;IntEnable, devpriv-&gt;io_addr + ICP_MULTI_INT_EN);
 
-	// Clear interrupt status
+	/*  Clear interrupt status */
 	devpriv-&gt;IntStatus |= DAC_READY;
 	writew(devpriv-&gt;IntStatus, devpriv-&gt;io_addr + ICP_MULTI_INT_STAT);
 
-	// Get channel number and range
+	/*  Get channel number and range */
 	chan = CR_CHAN(insn-&gt;chanspec);
 	range = CR_RANGE(insn-&gt;chanspec);
 
-	// Set up range and channel data
-	// Bit 4 = 1 : Bipolar
-	// Bit 5 = 0 : 5V
-	// Bit 5 = 1 : 10V
-	// Bits 8-9 : Channel number
+	/*  Set up range and channel data */
+	/*  Bit 4 = 1 : Bipolar */
+	/*  Bit 5 = 0 : 5V */
+	/*  Bit 5 = 1 : 10V */
+	/*  Bits 8-9 : Channel number */
 	devpriv-&gt;DacCmdStatus &amp;= 0xfccf;
 	devpriv-&gt;DacCmdStatus |= this_board-&gt;rangecode[range];
 	devpriv-&gt;DacCmdStatus |= (chan &lt;&lt; 8);
@@ -396,7 +396,7 @@ static int icp_multi_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
 	writew(devpriv-&gt;DacCmdStatus, devpriv-&gt;io_addr + ICP_MULTI_DAC_CSR);
 
 	for (n = 0; n &lt; insn-&gt;n; n++) {
-		// Wait for analogue output data register to be ready for new data, or get fed up waiting
+		/*  Wait for analogue output data register to be ready for new data, or get fed up waiting */
 		timeout = 100;
 		while (timeout--) {
 			if (!(readw(devpriv-&gt;io_addr +
@@ -414,19 +414,19 @@ static int icp_multi_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
 			comedi_udelay(1);
 		}
 
-		// If we reach here, a timeout has occurred
+		/*  If we reach here, a timeout has occurred */
 		comedi_error(dev, "D/A insn timeout");
 
-		// Disable interrupt
+		/*  Disable interrupt */
 		devpriv-&gt;IntEnable &amp;= ~DAC_READY;
 		writew(devpriv-&gt;IntEnable, devpriv-&gt;io_addr + ICP_MULTI_INT_EN);
 
-		// Clear interrupt status
+		/*  Clear interrupt status */
 		devpriv-&gt;IntStatus |= DAC_READY;
 		writew(devpriv-&gt;IntStatus,
 			devpriv-&gt;io_addr + ICP_MULTI_INT_STAT);
 
-		// Clear data received
+		/*  Clear data received */
 		devpriv-&gt;ao_data[chan] = 0;
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -435,16 +435,16 @@ static int icp_multi_insn_write_ao(comedi_device * dev, comedi_subdevice * s,
 		return -ETIME;
 
 	      dac_ready:
-		// Write data to analogue output data register
+		/*  Write data to analogue output data register */
 		writew(data[n], devpriv-&gt;io_addr + ICP_MULTI_AO);
 
-		// Set DAC_ST bit to write the data to selected channel
+		/*  Set DAC_ST bit to write the data to selected channel */
 		devpriv-&gt;DacCmdStatus |= DAC_ST;
 		writew(devpriv-&gt;DacCmdStatus,
 			devpriv-&gt;io_addr + ICP_MULTI_DAC_CSR);
 		devpriv-&gt;DacCmdStatus &amp;= ~DAC_ST;
 
-		// Save analogue output data
+		/*  Save analogue output data */
 		devpriv-&gt;ao_data[chan] = data[n];
 	}
 
@@ -477,10 +477,10 @@ static int icp_multi_insn_read_ao(comedi_device * dev, comedi_subdevice * s,
 {
 	int n, chan;
 
-	// Get channel number
+	/*  Get channel number */
 	chan = CR_CHAN(insn-&gt;chanspec);
 
-	// Read analogue outputs
+	/*  Read analogue outputs */
 	for (n = 0; n &lt; insn-&gt;n; n++)
 		data[n] = devpriv-&gt;ao_data[chan];
 
@@ -628,10 +628,10 @@ static irqreturn_t interrupt_service_icp_multi(int irq, void *d PT_REGS_ARG)
 		irq);
 #endif
 
-	// Is this interrupt from our board?
+	/*  Is this interrupt from our board? */
 	int_no = readw(devpriv-&gt;io_addr + ICP_MULTI_INT_STAT) &amp; Status_IRQ;
 	if (!int_no)
-		// No, exit
+		/*  No, exit */
 		return IRQ_NONE;
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -639,7 +639,7 @@ static irqreturn_t interrupt_service_icp_multi(int irq, void *d PT_REGS_ARG)
 		readw(devpriv-&gt;io_addr + ICP_MULTI_INT_STAT));
 #endif
 
-	// Determine which interrupt is active &amp; handle it
+	/*  Determine which interrupt is active &amp; handle it */
 	switch (int_no) {
 	case ADC_READY:
 		break;
@@ -697,14 +697,14 @@ static int check_channel_list(comedi_device * dev, comedi_subdevice * s,
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp multi EDBG:  check_channel_list(...,%d)\n", n_chan);
 #endif
-	// Check that we at least have one channel to check
+	/*  Check that we at least have one channel to check */
 	if (n_chan &lt; 1) {
 		comedi_error(dev, "range/channel list is empty!");
 		return 0;
 	}
-	// Check all channels
+	/*  Check all channels */
 	for (i = 0; i &lt; n_chan; i++) {
-		// Check that channel number is &lt; maximum
+		/*  Check that channel number is &lt; maximum */
 		if (CR_AREF(chanlist[i]) == AREF_DIFF) {
 			if (CR_CHAN(chanlist[i]) &gt; this_board-&gt;n_aichand) {
 				comedi_error(dev,
@@ -756,10 +756,10 @@ static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
 	devpriv-&gt;act_chanlist_pos = 0;
 
 	for (i = 0; i &lt; n_chan; i++) {
-		// Get channel
+		/*  Get channel */
 		chanprog = CR_CHAN(chanlist[i]);
 
-		// Determine if it is a differential channel (Bit 15  = 1)
+		/*  Determine if it is a differential channel (Bit 15  = 1) */
 		if (CR_AREF(chanlist[i]) == AREF_DIFF) {
 			diff = 1;
 			chanprog &amp;= 0x0007;
@@ -768,21 +768,21 @@ static void setup_channel_list(comedi_device * dev, comedi_subdevice * s,
 			chanprog &amp;= 0x000f;
 		}
 
-		// Clear channel, range and input mode bits in A/D command/status register
+		/*  Clear channel, range and input mode bits in A/D command/status register */
 		devpriv-&gt;AdcCmdStatus &amp;= 0xf00f;
 
-		// Set channel number and differential mode status bit
+		/*  Set channel number and differential mode status bit */
 		if (diff) {
-			// Set channel number, bits 9-11 &amp; mode, bit 6
+			/*  Set channel number, bits 9-11 &amp; mode, bit 6 */
 			devpriv-&gt;AdcCmdStatus |= (chanprog &lt;&lt; 9);
 			devpriv-&gt;AdcCmdStatus |= ADC_DI;
 		} else
-			// Set channel number, bits 8-11
+			/*  Set channel number, bits 8-11 */
 			devpriv-&gt;AdcCmdStatus |= (chanprog &lt;&lt; 8);
 
-		// Get range for current channel
+		/*  Get range for current channel */
 		range = this_board-&gt;rangecode[CR_RANGE(chanlist[i])];
-		// Set range. bits 4-5
+		/*  Set range. bits 4-5 */
 		devpriv-&gt;AdcCmdStatus |= range;
 
 		/* Output channel, range, mode to ICP Multi */
@@ -819,32 +819,32 @@ static int icp_multi_reset(comedi_device * dev)
 #ifdef ICP_MULTI_EXTDEBUG
 	printk("icp_multi EDBG: BGN: icp_multi_reset(...)\n");
 #endif
-	// Clear INT enables and requests
+	/*  Clear INT enables and requests */
 	writew(0, devpriv-&gt;io_addr + ICP_MULTI_INT_EN);
 	writew(0x00ff, devpriv-&gt;io_addr + ICP_MULTI_INT_STAT);
 
 	if (this_board-&gt;n_aochan)
-		// Set DACs to 0..5V range and 0V output
+		/*  Set DACs to 0..5V range and 0V output */
 		for (i = 0; i &lt; this_board-&gt;n_aochan; i++) {
 			devpriv-&gt;DacCmdStatus &amp;= 0xfcce;
 
-			// Set channel number
+			/*  Set channel number */
 			devpriv-&gt;DacCmdStatus |= (i &lt;&lt; 8);
 
-			// Output 0V
+			/*  Output 0V */
 			writew(0, devpriv-&gt;io_addr + ICP_MULTI_AO);
 
-			// Set start conversion bit
+			/*  Set start conversion bit */
 			devpriv-&gt;DacCmdStatus |= DAC_ST;
 
-			// Output to command / status register
+			/*  Output to command / status register */
 			writew(devpriv-&gt;DacCmdStatus,
 				devpriv-&gt;io_addr + ICP_MULTI_DAC_CSR);
 
-			// Delay to allow DAC time to recover
+			/*  Delay to allow DAC time to recover */
 			comedi_udelay(1);
 		}
-	// Digital outputs to 0
+	/*  Digital outputs to 0 */
 	writew(0, devpriv-&gt;io_addr + ICP_MULTI_DO);
 
 #ifdef ICP_MULTI_EXTDEBUG
@@ -881,11 +881,11 @@ static int icp_multi_attach(comedi_device * dev, comedi_devconfig * it)
 
 	printk("icp_multi EDBG: BGN: icp_multi_attach(...)\n");
 
-	// Alocate private data storage space
+	/*  Alocate private data storage space */
 	if ((ret = alloc_private(dev, sizeof(icp_multi_private))) &lt; 0)
 		return ret;
 
-	// Initialise list of PCI cards in system, if not already done so
+	/*  Initialise list of PCI cards in system, if not already done so */
 	if (pci_list_builded++ == 0) {
 		pci_card_list_init(PCI_VENDOR_ID_ICP,
 #ifdef ICP_MULTI_EXTDEBUG
diff --git a/drivers/staging/comedi/drivers/icp_multi.h b/drivers/staging/comedi/drivers/icp_multi.h
index 6df4a8d15ff2..c0abc1062b8d 100644
--- a/drivers/staging/comedi/drivers/icp_multi.h
+++ b/drivers/staging/comedi/drivers/icp_multi.h
@@ -28,7 +28,8 @@ struct pcilst_struct {
 	unsigned int irq;
 };
 
-struct pcilst_struct *inova_devices;	// ptr to root list of all Inova devices
+struct pcilst_struct *inova_devices;
+/* ptr to root list of all Inova devices */
 
 /****************************************************************************/
 
@@ -150,14 +151,14 @@ static int find_free_pci_card_by_position(unsigned short vendor_id,
 			&amp;&amp; (inova-&gt;pci_slot == pci_slot)) {
 			if (!(inova-&gt;used)) {
 				*card = inova;
-				return 0;	// ok, card is found
+				return 0;	/* ok, card is found */
 			} else {
-				return 2;	// card exist but is used
+				return 2;	/* card exist but is used */
 			}
 		}
 	}
 
-	return 1;		// no card found
+	return 1;		/* no card found */
 }
 
 /****************************************************************************/
@@ -243,7 +244,7 @@ static struct pcilst_struct *select_and_alloc_pci_card(unsigned short vendor_id,
 	struct pcilst_struct *card;
 	int err;
 
-	if ((pci_bus &lt; 1) &amp; (pci_slot &lt; 1)) {	// use autodetection
+	if ((pci_bus &lt; 1) &amp; (pci_slot &lt; 1)) {	/* use autodetection */
 		if ((card = find_free_pci_card_by_device(vendor_id,
 					device_id)) == NULL) {
 			rt_printk(" - Unused card not found in system!\n");
diff --git a/drivers/staging/comedi/drivers/me4000.c b/drivers/staging/comedi/drivers/me4000.c
index cc29315ecad4..2608c8713c90 100644
--- a/drivers/staging/comedi/drivers/me4000.c
+++ b/drivers/staging/comedi/drivers/me4000.c
@@ -277,7 +277,7 @@ static int me4000_attach(comedi_device * dev, comedi_devconfig * it)
 		s-&gt;subdev_flags =
 			SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;
 		s-&gt;n_chan = thisboard-&gt;ai.count;
-		s-&gt;maxdata = 0xFFFF;	// 16 bit ADC
+		s-&gt;maxdata = 0xFFFF;	/*  16 bit ADC */
 		s-&gt;len_chanlist = ME4000_AI_CHANNEL_LIST_COUNT;
 		s-&gt;range_table = &amp;me4000_ai_range;
 		s-&gt;insn_read = me4000_ai_insn_read;
@@ -312,7 +312,7 @@ static int me4000_attach(comedi_device * dev, comedi_devconfig * it)
 		s-&gt;type = COMEDI_SUBD_AO;
 		s-&gt;subdev_flags = SDF_WRITEABLE | SDF_COMMON | SDF_GROUND;
 		s-&gt;n_chan = thisboard-&gt;ao.count;
-		s-&gt;maxdata = 0xFFFF;	// 16 bit DAC
+		s-&gt;maxdata = 0xFFFF;	/*  16 bit DAC */
 		s-&gt;range_table = &amp;me4000_ao_range;
 		s-&gt;insn_write = me4000_ao_insn_write;
 		s-&gt;insn_read = me4000_ao_insn_read;
@@ -358,7 +358,7 @@ static int me4000_attach(comedi_device * dev, comedi_devconfig * it)
 		s-&gt;type = COMEDI_SUBD_COUNTER;
 		s-&gt;subdev_flags = SDF_READABLE | SDF_WRITABLE;
 		s-&gt;n_chan = thisboard-&gt;cnt.count;
-		s-&gt;maxdata = 0xFFFF;	// 16 bit counters
+		s-&gt;maxdata = 0xFFFF;	/*  16 bit counters */
 		s-&gt;insn_read = me4000_cnt_insn_read;
 		s-&gt;insn_write = me4000_cnt_insn_write;
 		s-&gt;insn_config = me4000_cnt_insn_config;
@@ -571,8 +571,8 @@ static int init_board_info(comedi_device * dev, struct pci_dev *pci_dev_p)
 	CALL_PDEBUG("In init_board_info()\n");
 
 	/* Init spin locks */
-	//spin_lock_init(&amp;info-&gt;preload_lock);
-	//spin_lock_init(&amp;info-&gt;ai_ctrl_lock);
+	/* spin_lock_init(&amp;info-&gt;preload_lock); */
+	/* spin_lock_init(&amp;info-&gt;ai_ctrl_lock); */
 
 	/* Get the serial number */
 	result = pci_read_config_dword(pci_dev_p, 0x2C, &amp;info-&gt;serial_no);
@@ -605,7 +605,7 @@ static int init_ao_context(comedi_device * dev)
 	CALL_PDEBUG("In init_ao_context()\n");
 
 	for (i = 0; i &lt; thisboard-&gt;ao.count; i++) {
-		//spin_lock_init(&amp;info-&gt;ao_context[i].use_lock);
+		/* spin_lock_init(&amp;info-&gt;ao_context[i].use_lock); */
 		info-&gt;ao_context[i].irq = info-&gt;irq;
 
 		switch (i) {
@@ -1604,21 +1604,21 @@ static int me4000_ai_do_cmd_test(comedi_device * dev,
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev-&gt;minor);
-			cmd-&gt;start_arg = 2000;	// 66 ticks at least
+			cmd-&gt;start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks &lt; ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev-&gt;minor);
-			cmd-&gt;convert_arg = 2000;	// 66 ticks at least
+			cmd-&gt;convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (scan_ticks &lt;= cmd-&gt;chanlist_len * chan_ticks) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
 				dev-&gt;minor);
-			cmd-&gt;scan_end_arg = 2000 * cmd-&gt;chanlist_len + 31;	// At least one tick more
+			cmd-&gt;scan_end_arg = 2000 * cmd-&gt;chanlist_len + 31;	/*  At least one tick more */
 			err++;
 		}
 	} else if (cmd-&gt;start_src == TRIG_NOW &amp;&amp;
@@ -1630,14 +1630,14 @@ static int me4000_ai_do_cmd_test(comedi_device * dev,
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev-&gt;minor);
-			cmd-&gt;start_arg = 2000;	// 66 ticks at least
+			cmd-&gt;start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks &lt; ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev-&gt;minor);
-			cmd-&gt;convert_arg = 2000;	// 66 ticks at least
+			cmd-&gt;convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd-&gt;start_src == TRIG_EXT &amp;&amp;
@@ -1649,21 +1649,21 @@ static int me4000_ai_do_cmd_test(comedi_device * dev,
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev-&gt;minor);
-			cmd-&gt;start_arg = 2000;	// 66 ticks at least
+			cmd-&gt;start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks &lt; ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev-&gt;minor);
-			cmd-&gt;convert_arg = 2000;	// 66 ticks at least
+			cmd-&gt;convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (scan_ticks &lt;= cmd-&gt;chanlist_len * chan_ticks) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid scan end arg\n",
 				dev-&gt;minor);
-			cmd-&gt;scan_end_arg = 2000 * cmd-&gt;chanlist_len + 31;	// At least one tick more
+			cmd-&gt;scan_end_arg = 2000 * cmd-&gt;chanlist_len + 31;	/*  At least one tick more */
 			err++;
 		}
 	} else if (cmd-&gt;start_src == TRIG_EXT &amp;&amp;
@@ -1675,14 +1675,14 @@ static int me4000_ai_do_cmd_test(comedi_device * dev,
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev-&gt;minor);
-			cmd-&gt;start_arg = 2000;	// 66 ticks at least
+			cmd-&gt;start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks &lt; ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev-&gt;minor);
-			cmd-&gt;convert_arg = 2000;	// 66 ticks at least
+			cmd-&gt;convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd-&gt;start_src == TRIG_EXT &amp;&amp;
@@ -1694,14 +1694,14 @@ static int me4000_ai_do_cmd_test(comedi_device * dev,
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev-&gt;minor);
-			cmd-&gt;start_arg = 2000;	// 66 ticks at least
+			cmd-&gt;start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 		if (chan_ticks &lt; ME4000_AI_MIN_TICKS) {
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid convert arg\n",
 				dev-&gt;minor);
-			cmd-&gt;convert_arg = 2000;	// 66 ticks at least
+			cmd-&gt;convert_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	} else if (cmd-&gt;start_src == TRIG_EXT &amp;&amp;
@@ -1713,7 +1713,7 @@ static int me4000_ai_do_cmd_test(comedi_device * dev,
 			printk(KERN_ERR
 				"comedi%d: me4000: me4000_ai_do_cmd_test(): Invalid start arg\n",
 				dev-&gt;minor);
-			cmd-&gt;start_arg = 2000;	// 66 ticks at least
+			cmd-&gt;start_arg = 2000;	/*  66 ticks at least */
 			err++;
 		}
 	}
diff --git a/drivers/staging/comedi/drivers/me4000.h b/drivers/staging/comedi/drivers/me4000.h
index f12b8873ec3c..37af3a80263a 100644
--- a/drivers/staging/comedi/drivers/me4000.h
+++ b/drivers/staging/comedi/drivers/me4000.h
@@ -28,37 +28,37 @@
   Debug section
   ===========================================================================*/
 
-#undef ME4000_CALL_DEBUG	// Debug function entry and exit
-#undef ME4000_PORT_DEBUG	// Debug port access
-#undef ME4000_ISR_DEBUG		// Debug the interrupt service routine
-#undef ME4000_DEBUG		// General purpose debug masseges
+#undef ME4000_CALL_DEBUG	/*  Debug function entry and exit */
+#undef ME4000_PORT_DEBUG	/*  Debug port access */
+#undef ME4000_ISR_DEBUG		/*  Debug the interrupt service routine */
+#undef ME4000_DEBUG		/*  General purpose debug masseges */
 
 #ifdef ME4000_CALL_DEBUG
 #undef CALL_PDEBUG
 #define CALL_PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev-&gt;minor, ##args)
 #else
-# define CALL_PDEBUG(fmt, args...)	// no debugging, do nothing
+# define CALL_PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 #ifdef ME4000_PORT_DEBUG
 #undef PORT_PDEBUG
 #define PORT_PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev-&gt;minor,  ##args)
 #else
-#define PORT_PDEBUG(fmt, args...)	// no debugging, do nothing
+#define PORT_PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 #ifdef ME4000_ISR_DEBUG
 #undef ISR_PDEBUG
 #define ISR_PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev-&gt;minor,  ##args)
 #else
-#define ISR_PDEBUG(fmt, args...)	// no debugging, do nothing
+#define ISR_PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 #ifdef ME4000_DEBUG
 #undef PDEBUG
 #define PDEBUG(fmt, args...) printk(KERN_DEBUG"comedi%d: me4000: " fmt, dev-&gt;minor,  ##args)
 #else
-#define PDEBUG(fmt, args...)	// no debugging, do nothing
+#define PDEBUG(fmt, args...)	/*  no debugging, do nothing */
 #endif
 
 /*=============================================================================
@@ -67,78 +67,78 @@
 
 #define PCI_VENDOR_ID_MEILHAUS 0x1402
 
-#define PCI_DEVICE_ID_MEILHAUS_ME4650	0x4650	// Low Cost version
+#define PCI_DEVICE_ID_MEILHAUS_ME4650	0x4650	/*  Low Cost version */
 
-#define PCI_DEVICE_ID_MEILHAUS_ME4660	0x4660	// Standard version
-#define PCI_DEVICE_ID_MEILHAUS_ME4660I	0x4661	// Isolated version
-#define PCI_DEVICE_ID_MEILHAUS_ME4660S	0x4662	// Standard version with Sample and Hold
-#define PCI_DEVICE_ID_MEILHAUS_ME4660IS	0x4663	// Isolated version with Sample and Hold
+#define PCI_DEVICE_ID_MEILHAUS_ME4660	0x4660	/*  Standard version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4660I	0x4661	/*  Isolated version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4660S	0x4662	/*  Standard version with Sample and Hold */
+#define PCI_DEVICE_ID_MEILHAUS_ME4660IS	0x4663	/*  Isolated version with Sample and Hold */
 
-#define PCI_DEVICE_ID_MEILHAUS_ME4670	0x4670	// Standard version
-#define PCI_DEVICE_ID_MEILHAUS_ME4670I	0x4671	// Isolated version
-#define PCI_DEVICE_ID_MEILHAUS_ME4670S	0x4672	// Standard version with Sample and Hold
-#define PCI_DEVICE_ID_MEILHAUS_ME4670IS	0x4673	// Isolated version with Sample and Hold
+#define PCI_DEVICE_ID_MEILHAUS_ME4670	0x4670	/*  Standard version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4670I	0x4671	/*  Isolated version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4670S	0x4672	/*  Standard version with Sample and Hold */
+#define PCI_DEVICE_ID_MEILHAUS_ME4670IS	0x4673	/*  Isolated version with Sample and Hold */
 
-#define PCI_DEVICE_ID_MEILHAUS_ME4680	0x4680	// Standard version
-#define PCI_DEVICE_ID_MEILHAUS_ME4680I	0x4681	// Isolated version
-#define PCI_DEVICE_ID_MEILHAUS_ME4680S	0x4682	// Standard version with Sample and Hold
-#define PCI_DEVICE_ID_MEILHAUS_ME4680IS	0x4683	// Isolated version with Sample and Hold
+#define PCI_DEVICE_ID_MEILHAUS_ME4680	0x4680	/*  Standard version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4680I	0x4681	/*  Isolated version */
+#define PCI_DEVICE_ID_MEILHAUS_ME4680S	0x4682	/*  Standard version with Sample and Hold */
+#define PCI_DEVICE_ID_MEILHAUS_ME4680IS	0x4683	/*  Isolated version with Sample and Hold */
 
 /*=============================================================================
   ME-4000 base register offsets
   ===========================================================================*/
 
-#define ME4000_AO_00_CTRL_REG			0x00	// R/W
-#define ME4000_AO_00_STATUS_REG			0x04	// R/_
-#define ME4000_AO_00_FIFO_REG			0x08	// _/W
-#define ME4000_AO_00_SINGLE_REG			0x0C	// R/W
-#define ME4000_AO_00_TIMER_REG			0x10	// _/W
-
-#define ME4000_AO_01_CTRL_REG			0x18	// R/W
-#define ME4000_AO_01_STATUS_REG			0x1C	// R/_
-#define ME4000_AO_01_FIFO_REG			0x20	// _/W
-#define ME4000_AO_01_SINGLE_REG			0x24	// R/W
-#define ME4000_AO_01_TIMER_REG			0x28	// _/W
-
-#define ME4000_AO_02_CTRL_REG			0x30	// R/W
-#define ME4000_AO_02_STATUS_REG			0x34	// R/_
-#define ME4000_AO_02_FIFO_REG			0x38	// _/W
-#define ME4000_AO_02_SINGLE_REG			0x3C	// R/W
-#define ME4000_AO_02_TIMER_REG			0x40	// _/W
-
-#define ME4000_AO_03_CTRL_REG			0x48	// R/W
-#define ME4000_AO_03_STATUS_REG			0x4C	// R/_
-#define ME4000_AO_03_FIFO_REG			0x50	// _/W
-#define ME4000_AO_03_SINGLE_REG			0x54	// R/W
-#define ME4000_AO_03_TIMER_REG			0x58	// _/W
-
-#define ME4000_AI_CTRL_REG			0x74	// _/W
-#define ME4000_AI_STATUS_REG			0x74	// R/_
-#define ME4000_AI_CHANNEL_LIST_REG		0x78	// _/W
-#define ME4000_AI_DATA_REG			0x7C	// R/_
-#define ME4000_AI_CHAN_TIMER_REG		0x80	// _/W
-#define ME4000_AI_CHAN_PRE_TIMER_REG		0x84	// _/W
-#define ME4000_AI_SCAN_TIMER_LOW_REG		0x88	// _/W
-#define ME4000_AI_SCAN_TIMER_HIGH_REG		0x8C	// _/W
-#define ME4000_AI_SCAN_PRE_TIMER_LOW_REG	0x90	// _/W
-#define ME4000_AI_SCAN_PRE_TIMER_HIGH_REG	0x94	// _/W
-#define ME4000_AI_START_REG			0x98	// R/_
-
-#define ME4000_IRQ_STATUS_REG			0x9C	// R/_
-
-#define ME4000_DIO_PORT_0_REG			0xA0	// R/W
-#define ME4000_DIO_PORT_1_REG			0xA4	// R/W
-#define ME4000_DIO_PORT_2_REG			0xA8	// R/W
-#define ME4000_DIO_PORT_3_REG			0xAC	// R/W
-#define ME4000_DIO_DIR_REG			0xB0	// R/W
-
-#define ME4000_AO_LOADSETREG_XX			0xB4	// R/W
-
-#define ME4000_DIO_CTRL_REG			0xB8	// R/W
-
-#define ME4000_AO_DEMUX_ADJUST_REG		0xBC	// -/W
-
-#define ME4000_AI_SAMPLE_COUNTER_REG		0xC0	// _/W
+#define ME4000_AO_00_CTRL_REG			0x00	/*  R/W */
+#define ME4000_AO_00_STATUS_REG			0x04	/*  R/_ */
+#define ME4000_AO_00_FIFO_REG			0x08	/*  _/W */
+#define ME4000_AO_00_SINGLE_REG			0x0C	/*  R/W */
+#define ME4000_AO_00_TIMER_REG			0x10	/*  _/W */
+
+#define ME4000_AO_01_CTRL_REG			0x18	/*  R/W */
+#define ME4000_AO_01_STATUS_REG			0x1C	/*  R/_ */
+#define ME4000_AO_01_FIFO_REG			0x20	/*  _/W */
+#define ME4000_AO_01_SINGLE_REG			0x24	/*  R/W */
+#define ME4000_AO_01_TIMER_REG			0x28	/*  _/W */
+
+#define ME4000_AO_02_CTRL_REG			0x30	/*  R/W */
+#define ME4000_AO_02_STATUS_REG			0x34	/*  R/_ */
+#define ME4000_AO_02_FIFO_REG			0x38	/*  _/W */
+#define ME4000_AO_02_SINGLE_REG			0x3C	/*  R/W */
+#define ME4000_AO_02_TIMER_REG			0x40	/*  _/W */
+
+#define ME4000_AO_03_CTRL_REG			0x48	/*  R/W */
+#define ME4000_AO_03_STATUS_REG			0x4C	/*  R/_ */
+#define ME4000_AO_03_FIFO_REG			0x50	/*  _/W */
+#define ME4000_AO_03_SINGLE_REG			0x54	/*  R/W */
+#define ME4000_AO_03_TIMER_REG			0x58	/*  _/W */
+
+#define ME4000_AI_CTRL_REG			0x74	/*  _/W */
+#define ME4000_AI_STATUS_REG			0x74	/*  R/_ */
+#define ME4000_AI_CHANNEL_LIST_REG		0x78	/*  _/W */
+#define ME4000_AI_DATA_REG			0x7C	/*  R/_ */
+#define ME4000_AI_CHAN_TIMER_REG		0x80	/*  _/W */
+#define ME4000_AI_CHAN_PRE_TIMER_REG		0x84	/*  _/W */
+#define ME4000_AI_SCAN_TIMER_LOW_REG		0x88	/*  _/W */
+#define ME4000_AI_SCAN_TIMER_HIGH_REG		0x8C	/*  _/W */
+#define ME4000_AI_SCAN_PRE_TIMER_LOW_REG	0x90	/*  _/W */
+#define ME4000_AI_SCAN_PRE_TIMER_HIGH_REG	0x94	/*  _/W */
+#define ME4000_AI_START_REG			0x98	/*  R/_ */
+
+#define ME4000_IRQ_STATUS_REG			0x9C	/*  R/_ */
+
+#define ME4000_DIO_PORT_0_REG			0xA0	/*  R/W */
+#define ME4000_DIO_PORT_1_REG			0xA4	/*  R/W */
+#define ME4000_DIO_PORT_2_REG			0xA8	/*  R/W */
+#define ME4000_DIO_PORT_3_REG			0xAC	/*  R/W */
+#define ME4000_DIO_DIR_REG			0xB0	/*  R/W */
+
+#define ME4000_AO_LOADSETREG_XX			0xB4	/*  R/W */
+
+#define ME4000_DIO_CTRL_REG			0xB8	/*  R/W */
+
+#define ME4000_AO_DEMUX_ADJUST_REG		0xBC	/*  -/W */
+
+#define ME4000_AI_SAMPLE_COUNTER_REG		0xC0	/*  _/W */
 
 /*=============================================================================
   Value to adjust Demux
@@ -159,21 +159,21 @@
   PLX base register offsets
   ===========================================================================*/
 
-#define PLX_INTCSR	0x4C	// Interrupt control and status register
-#define PLX_ICR		0x50	// Initialization control register
+#define PLX_INTCSR	0x4C	/*  Interrupt control and status register */
+#define PLX_ICR		0x50	/*  Initialization control register */
 
 /*=============================================================================
   Bits for the PLX_ICSR register
   ===========================================================================*/
 
-#define PLX_INTCSR_LOCAL_INT1_EN             0x01	// If set, local interrupt 1 is enabled (r/w)
-#define PLX_INTCSR_LOCAL_INT1_POL            0x02	// If set, local interrupt 1 polarity is active high (r/w)
-#define PLX_INTCSR_LOCAL_INT1_STATE          0x04	// If set, local interrupt 1 is active (r/_)
-#define PLX_INTCSR_LOCAL_INT2_EN             0x08	// If set, local interrupt 2 is enabled (r/w)
-#define PLX_INTCSR_LOCAL_INT2_POL            0x10	// If set, local interrupt 2 polarity is active high (r/w)
-#define PLX_INTCSR_LOCAL_INT2_STATE          0x20	// If set, local interrupt 2 is active  (r/_)
-#define PLX_INTCSR_PCI_INT_EN                0x40	// If set, PCI interrupt is enabled (r/w)
-#define PLX_INTCSR_SOFT_INT                  0x80	// If set, a software interrupt is generated (r/w)
+#define PLX_INTCSR_LOCAL_INT1_EN             0x01	/*  If set, local interrupt 1 is enabled (r/w) */
+#define PLX_INTCSR_LOCAL_INT1_POL            0x02	/*  If set, local interrupt 1 polarity is active high (r/w) */
+#define PLX_INTCSR_LOCAL_INT1_STATE          0x04	/*  If set, local interrupt 1 is active (r/_) */
+#define PLX_INTCSR_LOCAL_INT2_EN             0x08	/*  If set, local interrupt 2 is enabled (r/w) */
+#define PLX_INTCSR_LOCAL_INT2_POL            0x10	/*  If set, local interrupt 2 polarity is active high (r/w) */
+#define PLX_INTCSR_LOCAL_INT2_STATE          0x20	/*  If set, local interrupt 2 is active  (r/_) */
+#define PLX_INTCSR_PCI_INT_EN                0x40	/*  If set, PCI interrupt is enabled (r/w) */
+#define PLX_INTCSR_SOFT_INT                  0x80	/*  If set, a software interrupt is generated (r/w) */
 
 /*=============================================================================
   Bits for the PLX_ICR register
@@ -331,7 +331,7 @@ typedef struct me4000_board {
 typedef struct me4000_ao_context {
 	int irq;
 
-	unsigned long mirror;	// Store the last written value
+	unsigned long mirror;	/*  Store the last written value */
 
 	unsigned long ctrl_reg;
 	unsigned long status_reg;
@@ -377,29 +377,29 @@ typedef struct me4000_cnt_context {
 } me4000_cnt_context_t;
 
 typedef struct me4000_info {
-	unsigned long plx_regbase;	// PLX configuration space base address
-	unsigned long me4000_regbase;	// Base address of the ME4000
-	unsigned long timer_regbase;	// Base address of the timer circuit
-	unsigned long program_regbase;	// Base address to set the program pin for the xilinx
+	unsigned long plx_regbase;	/*  PLX configuration space base address */
+	unsigned long me4000_regbase;	/*  Base address of the ME4000 */
+	unsigned long timer_regbase;	/*  Base address of the timer circuit */
+	unsigned long program_regbase;	/*  Base address to set the program pin for the xilinx */
 
-	unsigned long plx_regbase_size;	// PLX register set space
-	unsigned long me4000_regbase_size;	// ME4000 register set space
-	unsigned long timer_regbase_size;	// Timer circuit register set space
-	unsigned long program_regbase_size;	// Size of program base address of the ME4000
+	unsigned long plx_regbase_size;	/*  PLX register set space */
+	unsigned long me4000_regbase_size;	/*  ME4000 register set space */
+	unsigned long timer_regbase_size;	/*  Timer circuit register set space */
+	unsigned long program_regbase_size;	/*  Size of program base address of the ME4000 */
 
-	unsigned int serial_no;	// Serial number of the board
-	unsigned char hw_revision;	// Hardware revision of the board
-	unsigned short vendor_id;	// Meilhaus vendor id
-	unsigned short device_id;	// Device id
+	unsigned int serial_no;	/*  Serial number of the board */
+	unsigned char hw_revision;	/*  Hardware revision of the board */
+	unsigned short vendor_id;	/*  Meilhaus vendor id */
+	unsigned short device_id;	/*  Device id */
 
-	struct pci_dev *pci_dev_p;	// General PCI information
+	struct pci_dev *pci_dev_p;	/*  General PCI information */
 
-	unsigned int irq;	// IRQ assigned from the PCI BIOS
+	unsigned int irq;	/*  IRQ assigned from the PCI BIOS */
 
-	struct me4000_ai_context ai_context;	// Analog input  specific context
-	struct me4000_ao_context ao_context[4];	// Vector with analog output specific context
-	struct me4000_dio_context dio_context;	// Digital I/O specific context
-	struct me4000_cnt_context cnt_context;	// Counter specific context
+	struct me4000_ai_context ai_context;	/*  Analog input  specific context */
+	struct me4000_ao_context ao_context[4];	/*  Vector with analog output specific context */
+	struct me4000_dio_context dio_context;	/*  Digital I/O specific context */
+	struct me4000_cnt_context cnt_context;	/*  Counter specific context */
 } me4000_info_t;
 
 #define info	((me4000_info_t *)dev-&gt;private)
@@ -412,7 +412,7 @@ typedef struct me4000_info {
 #define ME4000_AI_FIFO_COUNT			2048
 
 #define ME4000_AI_MIN_TICKS			66
-#define ME4000_AI_MIN_SAMPLE_TIME		2000	// Minimum sample time [ns]
+#define ME4000_AI_MIN_SAMPLE_TIME		2000	/*  Minimum sample time [ns] */
 #define ME4000_AI_BASE_FREQUENCY		(unsigned int) 33E6
 
 /* Channel list defines and masks */
@@ -436,11 +436,11 @@ typedef struct me4000_info {
 #define ME4000_CNT_COUNTER_1  0x40
 #define ME4000_CNT_COUNTER_2  0x80
 
-#define ME4000_CNT_MODE_0     0x00	// Change state if zero crossing
-#define ME4000_CNT_MODE_1     0x02	// Retriggerable One-Shot
-#define ME4000_CNT_MODE_2     0x04	// Asymmetrical divider
-#define ME4000_CNT_MODE_3     0x06	// Symmetrical divider
-#define ME4000_CNT_MODE_4     0x08	// Counter start by software trigger
-#define ME4000_CNT_MODE_5     0x0A	// Counter start by hardware trigger
+#define ME4000_CNT_MODE_0     0x00	/*  Change state if zero crossing */
+#define ME4000_CNT_MODE_1     0x02	/*  Retriggerable One-Shot */
+#define ME4000_CNT_MODE_2     0x04	/*  Asymmetrical divider */
+#define ME4000_CNT_MODE_3     0x06	/*  Symmetrical divider */
+#define ME4000_CNT_MODE_4     0x08	/*  Counter start by software trigger */
+#define ME4000_CNT_MODE_5     0x0A	/*  Counter start by hardware trigger */
 
 #endif
diff --git a/drivers/staging/comedi/drivers/mite.c b/drivers/staging/comedi/drivers/mite.c
index 9cc527424d04..354ed8ddaffd 100644
--- a/drivers/staging/comedi/drivers/mite.c
+++ b/drivers/staging/comedi/drivers/mite.c
@@ -47,7 +47,7 @@
 
 */
 
-//#define USE_KMALLOC
+/* #define USE_KMALLOC */
 
 #include "mite.h"
 
@@ -139,7 +139,7 @@ int mite_setup2(struct mite_struct *mite, unsigned use_iodwbsr_1)
 	addr = pci_resource_start(mite-&gt;pcidev, 1);
 	mite-&gt;daq_phys_addr = addr;
 	length = pci_resource_len(mite-&gt;pcidev, 1);
-	// In case of a 660x board, DAQ size is 8k instead of 4k (see as shown by lspci output)
+	/*  In case of a 660x board, DAQ size is 8k instead of 4k (see as shown by lspci output) */
 	mite-&gt;daq_io_addr = ioremap(mite-&gt;daq_phys_addr, length);
 	if (!mite-&gt;daq_io_addr) {
 		printk("failed to remap daq io memory address\n");
@@ -212,7 +212,7 @@ void mite_cleanup(void)
 
 void mite_unsetup(struct mite_struct *mite)
 {
-	//unsigned long offset, start, length;
+	/* unsigned long offset, start, length; */
 
 	if (!mite)
 		return;
@@ -257,7 +257,7 @@ struct mite_channel *mite_request_channel_in_range(struct mite_struct *mite,
 	unsigned long flags;
 	struct mite_channel *channel = NULL;
 
-	// spin lock so mite_release_channel can be called safely from interrupts
+	/*  spin lock so mite_release_channel can be called safely from interrupts */
 	comedi_spin_lock_irqsave(&amp;mite-&gt;lock, flags);
 	for (i = min_channel; i &lt;= max_channel; ++i) {
 		if (mite-&gt;channel_allocated[i] == 0) {
@@ -276,7 +276,7 @@ void mite_release_channel(struct mite_channel *mite_chan)
 	struct mite_struct *mite = mite_chan-&gt;mite;
 	unsigned long flags;
 
-	// spin lock to prevent races with mite_request_channel
+	/*  spin lock to prevent races with mite_request_channel */
 	comedi_spin_lock_irqsave(&amp;mite-&gt;lock, flags);
 	if (mite-&gt;channel_allocated[mite_chan-&gt;channel]) {
 		mite_dma_disarm(mite_chan);
@@ -312,7 +312,7 @@ void mite_dma_arm(struct mite_channel *mite_chan)
 	writel(chor, mite-&gt;mite_io_addr + MITE_CHOR(mite_chan-&gt;channel));
 	mmiowb();
 	comedi_spin_unlock_irqrestore(&amp;mite-&gt;lock, flags);
-//      mite_dma_tcr(mite, channel);
+/*       mite_dma_tcr(mite, channel); */
 }
 
 /**************************************/
@@ -466,7 +466,7 @@ u32 mite_bytes_in_transit(struct mite_channel * mite_chan)
 		MITE_FCR(mite_chan-&gt;channel)) &amp; 0x000000FF;
 }
 
-// returns lower bound for number of bytes transferred from device to memory
+/*  returns lower bound for number of bytes transferred from device to memory */
 u32 mite_bytes_written_to_memory_lb(struct mite_channel * mite_chan)
 {
 	u32 device_byte_count;
@@ -475,7 +475,7 @@ u32 mite_bytes_written_to_memory_lb(struct mite_channel * mite_chan)
 	return device_byte_count - mite_bytes_in_transit(mite_chan);
 }
 
-// returns upper bound for number of bytes transferred from device to memory
+/*  returns upper bound for number of bytes transferred from device to memory */
 u32 mite_bytes_written_to_memory_ub(struct mite_channel * mite_chan)
 {
 	u32 in_transit_count;
@@ -484,7 +484,7 @@ u32 mite_bytes_written_to_memory_ub(struct mite_channel * mite_chan)
 	return mite_device_bytes_transferred(mite_chan) - in_transit_count;
 }
 
-// returns lower bound for number of bytes read from memory for transfer to device
+/*  returns lower bound for number of bytes read from memory for transfer to device */
 u32 mite_bytes_read_from_memory_lb(struct mite_channel * mite_chan)
 {
 	u32 device_byte_count;
@@ -493,7 +493,7 @@ u32 mite_bytes_read_from_memory_lb(struct mite_channel * mite_chan)
 	return device_byte_count + mite_bytes_in_transit(mite_chan);
 }
 
-// returns upper bound for number of bytes read from memory for transfer to device
+/*  returns upper bound for number of bytes read from memory for transfer to device */
 u32 mite_bytes_read_from_memory_ub(struct mite_channel * mite_chan)
 {
 	u32 in_transit_count;
@@ -533,7 +533,7 @@ int mite_sync_input_dma(struct mite_channel *mite_chan, comedi_async * async)
 	const unsigned bytes_per_scan = cfc_bytes_per_scan(async-&gt;subdevice);
 
 	old_alloc_count = async-&gt;buf_write_alloc_count;
-	// write alloc as much as we can
+	/*  write alloc as much as we can */
 	comedi_buf_write_alloc(async, async-&gt;prealloc_bufsz);
 
 	nbytes = mite_bytes_written_to_memory_lb(mite_chan);
@@ -570,7 +570,7 @@ int mite_sync_output_dma(struct mite_channel *mite_chan, comedi_async * async)
 		async-&gt;cmd.stop_arg * cfc_bytes_per_scan(async-&gt;subdevice);
 
 	old_alloc_count = async-&gt;buf_read_alloc_count;
-	// read alloc as much as we can
+	/*  read alloc as much as we can */
 	comedi_buf_read_alloc(async, async-&gt;prealloc_bufsz);
 	nbytes_lb = mite_bytes_read_from_memory_lb(mite_chan);
 	if (async-&gt;cmd.stop_src == TRIG_COUNT &amp;&amp;
diff --git a/drivers/staging/comedi/drivers/mite.h b/drivers/staging/comedi/drivers/mite.h
index b84eafa6ff2b..26c04c82293c 100644
--- a/drivers/staging/comedi/drivers/mite.h
+++ b/drivers/staging/comedi/drivers/mite.h
@@ -29,7 +29,7 @@
 
 #define PCI_VENDOR_ID_NATINST		0x1093
 
-// #define DEBUG_MITE
+/*  #define DEBUG_MITE */
 #define PCIMIO_COMPAT
 
 #ifdef DEBUG_MITE
@@ -179,83 +179,83 @@ enum mite_registers {
 	   written and read back.  The bits 0x1f always read as 1.
 	   The rest always read as zero. */
 	MITE_UNKNOWN_DMA_BURST_REG = 0x28,
-	MITE_IODWBSR = 0xc0,	//IO Device Window Base Size Register
-	MITE_IODWBSR_1 = 0xc4,	// IO Device Window Base Size Register 1
+	MITE_IODWBSR = 0xc0,	/* IO Device Window Base Size Register */
+	MITE_IODWBSR_1 = 0xc4,	/*  IO Device Window Base Size Register 1 */
 	MITE_IODWCR_1 = 0xf4,
 	MITE_PCI_CONFIG_OFFSET = 0x300,
-	MITE_CSIGR = 0x460	//chip signature
+	MITE_CSIGR = 0x460	/* chip signature */
 };
-static inline int MITE_CHOR(int channel)	// channel operation
+static inline int MITE_CHOR(int channel)	/*  channel operation */
 {
 	return CHAN_OFFSET(channel) + 0x0;
 };
-static inline int MITE_CHCR(int channel)	// channel control
+static inline int MITE_CHCR(int channel)	/*  channel control */
 {
 	return CHAN_OFFSET(channel) + 0x4;
 };
-static inline int MITE_TCR(int channel)	// transfer count
+static inline int MITE_TCR(int channel)	/*  transfer count */
 {
 	return CHAN_OFFSET(channel) + 0x8;
 };
-static inline int MITE_MCR(int channel)	// memory configuration
+static inline int MITE_MCR(int channel)	/*  memory configuration */
 {
 	return CHAN_OFFSET(channel) + 0xc;
 };
-static inline int MITE_MAR(int channel)	// memory address
+static inline int MITE_MAR(int channel)	/*  memory address */
 {
 	return CHAN_OFFSET(channel) + 0x10;
 };
-static inline int MITE_DCR(int channel)	// device configuration
+static inline int MITE_DCR(int channel)	/*  device configuration */
 {
 	return CHAN_OFFSET(channel) + 0x14;
 };
-static inline int MITE_DAR(int channel)	// device address
+static inline int MITE_DAR(int channel)	/*  device address */
 {
 	return CHAN_OFFSET(channel) + 0x18;
 };
-static inline int MITE_LKCR(int channel)	// link configuration
+static inline int MITE_LKCR(int channel)	/*  link configuration */
 {
 	return CHAN_OFFSET(channel) + 0x1c;
 };
-static inline int MITE_LKAR(int channel)	// link address
+static inline int MITE_LKAR(int channel)	/*  link address */
 {
 	return CHAN_OFFSET(channel) + 0x20;
 };
-static inline int MITE_LLKAR(int channel)	// see mite section of tnt5002 manual
+static inline int MITE_LLKAR(int channel)	/*  see mite section of tnt5002 manual */
 {
 	return CHAN_OFFSET(channel) + 0x24;
 };
-static inline int MITE_BAR(int channel)	// base address
+static inline int MITE_BAR(int channel)	/*  base address */
 {
 	return CHAN_OFFSET(channel) + 0x28;
 };
-static inline int MITE_BCR(int channel)	// base count
+static inline int MITE_BCR(int channel)	/*  base count */
 {
 	return CHAN_OFFSET(channel) + 0x2c;
 };
-static inline int MITE_SAR(int channel)	// ? address
+static inline int MITE_SAR(int channel)	/*  ? address */
 {
 	return CHAN_OFFSET(channel) + 0x30;
 };
-static inline int MITE_WSCR(int channel)	// ?
+static inline int MITE_WSCR(int channel)	/*  ? */
 {
 	return CHAN_OFFSET(channel) + 0x34;
 };
-static inline int MITE_WSER(int channel)	// ?
+static inline int MITE_WSER(int channel)	/*  ? */
 {
 	return CHAN_OFFSET(channel) + 0x38;
 };
-static inline int MITE_CHSR(int channel)	// channel status
+static inline int MITE_CHSR(int channel)	/*  channel status */
 {
 	return CHAN_OFFSET(channel) + 0x3c;
 };
-static inline int MITE_FCR(int channel)	// fifo count
+static inline int MITE_FCR(int channel)	/*  fifo count */
 {
 	return CHAN_OFFSET(channel) + 0x40;
 };
 
 enum MITE_IODWBSR_bits {
-	WENAB = 0x80,		// window enable
+	WENAB = 0x80,		/*  window enable */
 };
 
 static inline unsigned MITE_IODWBSR_1_WSIZE_bits(unsigned size)
@@ -276,23 +276,23 @@ static inline int mite_csigr_version(u32 csigr_bits)
 	return csigr_bits &amp; 0xf;
 };
 static inline int mite_csigr_type(u32 csigr_bits)
-{				// original mite = 0, minimite = 1
+{				/*  original mite = 0, minimite = 1 */
 	return (csigr_bits &gt;&gt; 4) &amp; 0xf;
 };
 static inline int mite_csigr_mmode(u32 csigr_bits)
-{				// mite mode, minimite = 1
+{				/*  mite mode, minimite = 1 */
 	return (csigr_bits &gt;&gt; 8) &amp; 0x3;
 };
 static inline int mite_csigr_imode(u32 csigr_bits)
-{				// cpu port interface mode, pci = 0x3
+{				/*  cpu port interface mode, pci = 0x3 */
 	return (csigr_bits &gt;&gt; 12) &amp; 0x3;
 };
 static inline int mite_csigr_dmac(u32 csigr_bits)
-{				// number of dma channels
+{				/*  number of dma channels */
 	return (csigr_bits &gt;&gt; 16) &amp; 0xf;
 };
 static inline int mite_csigr_wpdep(u32 csigr_bits)
-{				// write post fifo depth
+{				/*  write post fifo depth */
 	unsigned int wpdep_bits = (csigr_bits &gt;&gt; 20) &amp; 0x7;
 	if (wpdep_bits == 0)
 		return 0;
@@ -304,7 +304,7 @@ static inline int mite_csigr_wins(u32 csigr_bits)
 	return (csigr_bits &gt;&gt; 24) &amp; 0x1f;
 };
 static inline int mite_csigr_iowins(u32 csigr_bits)
-{				// number of io windows
+{				/*  number of io windows */
 	return (csigr_bits &gt;&gt; 29) &amp; 0x7;
 };
 
diff --git a/drivers/staging/comedi/drivers/plx9080.h b/drivers/staging/comedi/drivers/plx9080.h
index a5a1a6808c5d..e53d3d429d7f 100644
--- a/drivers/staging/comedi/drivers/plx9080.h
+++ b/drivers/staging/comedi/drivers/plx9080.h
@@ -27,7 +27,7 @@
 #ifndef __COMEDI_PLX9080_H
 #define __COMEDI_PLX9080_H
 
-// descriptor block used for chained dma transfers
+/*  descriptor block used for chained dma transfers */
 struct plx_dma_desc {
 	volatile uint32_t pci_start_addr;
 	volatile uint32_t local_start_addr;
@@ -52,14 +52,14 @@ struct plx_dma_desc {
 #define  LRNG_ANY32        0x00000000	/* Locate anywhere in 32 bit */
 #define  LRNG_LT1MB        0x00000002	/* Locate in 1st meg */
 #define  LRNG_ANY64        0x00000004	/* Locate anywhere in 64 bit */
-#define  LRNG_MEM_MASK     0xfffffff0	// bits that specify range for memory io
-#define  LRNG_IO_MASK     0xfffffffa	// bits that specify range for normal io
+#define  LRNG_MEM_MASK     0xfffffff0	/*  bits that specify range for memory io */
+#define  LRNG_IO_MASK     0xfffffffa	/*  bits that specify range for normal io */
 
 #define PLX_LAS0MAP_REG         0x0004	/* L, Local Addr Space 0 Remap Register */
 #define PLX_LAS1MAP_REG         0x00f4	/* L, Local Addr Space 1 Remap Register */
 #define  LMAP_EN           0x00000001	/* Enable slave decode */
-#define  LMAP_MEM_MASK     0xfffffff0	// bits that specify decode for memory io
-#define  LMAP_IO_MASK     0xfffffffa	// bits that specify decode bits for normal io
+#define  LMAP_MEM_MASK     0xfffffff0	/*  bits that specify decode for memory io */
+#define  LMAP_IO_MASK     0xfffffffa	/*  bits that specify decode bits for normal io */
 
 /* Mode/Arbitration Register.
 */
@@ -169,7 +169,7 @@ enum bigend_bits {
 #define  ICS_AERR          0x00000001	/* Assert LSERR on ABORT */
 #define  ICS_PERR          0x00000002	/* Assert LSERR on Parity Error */
 #define  ICS_SERR          0x00000004	/* Generate PCI SERR# */
-#define  ICS_MBIE          0x00000008	// mailbox interrupt enable
+#define  ICS_MBIE          0x00000008	/*  mailbox interrupt enable */
 #define  ICS_PIE           0x00000100	/* PCI Interrupt Enable */
 #define  ICS_PDIE          0x00000200	/* PCI Doorbell Interrupt Enable */
 #define  ICS_PAIE          0x00000400	/* PCI Abort Interrupt Enable */
@@ -190,7 +190,7 @@ enum bigend_bits {
 #define  ICS_TA_DMA0       0x02000000	/* Target Abort - DMA #0 */
 #define  ICS_TA_DMA1       0x04000000	/* Target Abort - DMA #1 */
 #define  ICS_TA_RA         0x08000000	/* Target Abort - Retry Timeout */
-#define  ICS_MBIA(x)       (0x10000000 &lt;&lt; ((x) &amp; 0x3))	// mailbox x is active
+#define  ICS_MBIA(x)       (0x10000000 &lt;&lt; ((x) &amp; 0x3))	/*  mailbox x is active */
 
 #define PLX_CONTROL_REG        0x006C	/* L, EEPROM Cntl &amp; PCI Cmd Codes */
 #define  CTL_RDMA          0x0000000E	/* DMA Read Command */
@@ -208,51 +208,51 @@ enum bigend_bits {
 #define  CTL_RESET         0x40000000	/* !! Adapter Reset !! */
 #define  CTL_READY         0x80000000	/* Local Init Done */
 
-#define PLX_ID_REG	0x70	// hard-coded plx vendor and device ids
+#define PLX_ID_REG	0x70	/*  hard-coded plx vendor and device ids */
 
-#define PLX_REVISION_REG	0x74	// silicon revision
+#define PLX_REVISION_REG	0x74	/*  silicon revision */
 
-#define PLX_DMA0_MODE_REG	0x80	// dma channel 0 mode register
-#define PLX_DMA1_MODE_REG	0x94	// dma channel 0 mode register
+#define PLX_DMA0_MODE_REG	0x80	/*  dma channel 0 mode register */
+#define PLX_DMA1_MODE_REG	0x94	/*  dma channel 0 mode register */
 #define  PLX_LOCAL_BUS_16_WIDE_BITS	0x1
 #define  PLX_LOCAL_BUS_32_WIDE_BITS	0x3
 #define  PLX_LOCAL_BUS_WIDTH_MASK	0x3
-#define  PLX_DMA_EN_READYIN_BIT	0x40	// enable ready in input
-#define  PLX_EN_BTERM_BIT	0x80	// enable BTERM# input
-#define  PLX_DMA_LOCAL_BURST_EN_BIT	0x100	// enable local burst mode
-#define  PLX_EN_CHAIN_BIT	0x200	// enables chaining
-#define  PLX_EN_DMA_DONE_INTR_BIT	0x400	// enables interrupt on dma done
-#define  PLX_LOCAL_ADDR_CONST_BIT	0x800	// hold local address constant (don't increment)
-#define  PLX_DEMAND_MODE_BIT	0x1000	// enables demand-mode for dma transfer
+#define  PLX_DMA_EN_READYIN_BIT	0x40	/*  enable ready in input */
+#define  PLX_EN_BTERM_BIT	0x80	/*  enable BTERM# input */
+#define  PLX_DMA_LOCAL_BURST_EN_BIT	0x100	/*  enable local burst mode */
+#define  PLX_EN_CHAIN_BIT	0x200	/*  enables chaining */
+#define  PLX_EN_DMA_DONE_INTR_BIT	0x400	/*  enables interrupt on dma done */
+#define  PLX_LOCAL_ADDR_CONST_BIT	0x800	/*  hold local address constant (don't increment) */
+#define  PLX_DEMAND_MODE_BIT	0x1000	/*  enables demand-mode for dma transfer */
 #define  PLX_EOT_ENABLE_BIT	0x4000
 #define  PLX_STOP_MODE_BIT 0x8000
-#define  PLX_DMA_INTR_PCI_BIT	0x20000	// routes dma interrupt to pci bus (instead of local bus)
+#define  PLX_DMA_INTR_PCI_BIT	0x20000	/*  routes dma interrupt to pci bus (instead of local bus) */
 
-#define PLX_DMA0_PCI_ADDRESS_REG	0x84	// pci address that dma transfers start at
+#define PLX_DMA0_PCI_ADDRESS_REG	0x84	/*  pci address that dma transfers start at */
 #define PLX_DMA1_PCI_ADDRESS_REG	0x98
 
-#define PLX_DMA0_LOCAL_ADDRESS_REG	0x88	// local address that dma transfers start at
+#define PLX_DMA0_LOCAL_ADDRESS_REG	0x88	/*  local address that dma transfers start at */
 #define PLX_DMA1_LOCAL_ADDRESS_REG	0x9c
 
-#define PLX_DMA0_TRANSFER_SIZE_REG	0x8c	// number of bytes to transfer (first 23 bits)
+#define PLX_DMA0_TRANSFER_SIZE_REG	0x8c	/*  number of bytes to transfer (first 23 bits) */
 #define PLX_DMA1_TRANSFER_SIZE_REG	0xa0
 
-#define PLX_DMA0_DESCRIPTOR_REG	0x90	// descriptor pointer register
+#define PLX_DMA0_DESCRIPTOR_REG	0x90	/*  descriptor pointer register */
 #define PLX_DMA1_DESCRIPTOR_REG	0xa4
-#define  PLX_DESC_IN_PCI_BIT	0x1	// descriptor is located in pci space (not local space)
-#define  PLX_END_OF_CHAIN_BIT	0x2	// end of chain bit
-#define  PLX_INTR_TERM_COUNT	0x4	// interrupt when this descriptor's transfer is finished
-#define  PLX_XFER_LOCAL_TO_PCI 0x8	// transfer from local to pci bus (not pci to local)
+#define  PLX_DESC_IN_PCI_BIT	0x1	/*  descriptor is located in pci space (not local space) */
+#define  PLX_END_OF_CHAIN_BIT	0x2	/*  end of chain bit */
+#define  PLX_INTR_TERM_COUNT	0x4	/*  interrupt when this descriptor's transfer is finished */
+#define  PLX_XFER_LOCAL_TO_PCI 0x8	/*  transfer from local to pci bus (not pci to local) */
 
-#define PLX_DMA0_CS_REG	0xa8	// command status register
+#define PLX_DMA0_CS_REG	0xa8	/*  command status register */
 #define PLX_DMA1_CS_REG	0xa9
-#define  PLX_DMA_EN_BIT	0x1	// enable dma channel
-#define  PLX_DMA_START_BIT	0x2	// start dma transfer
-#define  PLX_DMA_ABORT_BIT	0x4	// abort dma transfer
-#define  PLX_CLEAR_DMA_INTR_BIT	0x8	// clear dma interrupt
-#define  PLX_DMA_DONE_BIT	0x10	// transfer done status bit
+#define  PLX_DMA_EN_BIT	0x1	/*  enable dma channel */
+#define  PLX_DMA_START_BIT	0x2	/*  start dma transfer */
+#define  PLX_DMA_ABORT_BIT	0x4	/*  abort dma transfer */
+#define  PLX_CLEAR_DMA_INTR_BIT	0x8	/*  clear dma interrupt */
+#define  PLX_DMA_DONE_BIT	0x10	/*  transfer done status bit */
 
-#define PLX_DMA0_THRESHOLD_REG	0xb0	// command status register
+#define PLX_DMA0_THRESHOLD_REG	0xb0	/*  command status register */
 
 /*
  * Accesses near the end of memory can cause the PLX chip
@@ -392,12 +392,12 @@ static inline int plx9080_abort_dma(void *iobase, unsigned int channel)
 	else
 		dma_cs_addr = iobase + PLX_DMA0_CS_REG;
 
-	// abort dma transfer if necessary
+	/*  abort dma transfer if necessary */
 	dma_status = readb(dma_cs_addr);
 	if ((dma_status &amp; PLX_DMA_EN_BIT) == 0) {
 		return 0;
 	}
-	// wait to make sure done bit is zero
+	/*  wait to make sure done bit is zero */
 	for (i = 0; (dma_status &amp; PLX_DMA_DONE_BIT) &amp;&amp; i &lt; timeout; i++) {
 		comedi_udelay(1);
 		dma_status = readb(dma_cs_addr);
@@ -408,9 +408,9 @@ static inline int plx9080_abort_dma(void *iobase, unsigned int channel)
 			channel);
 		return -ETIMEDOUT;
 	}
-	// disable and abort channel
+	/*  disable and abort channel */
 	writeb(PLX_DMA_ABORT_BIT, dma_cs_addr);
-	// wait for dma done bit
+	/*  wait for dma done bit */
 	dma_status = readb(dma_cs_addr);
 	for (i = 0; (dma_status &amp; PLX_DMA_DONE_BIT) == 0 &amp;&amp; i &lt; timeout; i++) {
 		comedi_udelay(1);
diff --git a/drivers/staging/comedi/drivers/rtd520.c b/drivers/staging/comedi/drivers/rtd520.c
index 6c7d54321f88..e9379b80d227 100644
--- a/drivers/staging/comedi/drivers/rtd520.c
+++ b/drivers/staging/comedi/drivers/rtd520.c
@@ -704,7 +704,7 @@ static int rtd_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 	comedi_cmd * cmd);
 static int rtd_ai_cmd(comedi_device * dev, comedi_subdevice * s);
 static int rtd_ai_cancel(comedi_device * dev, comedi_subdevice * s);
-//static int rtd_ai_poll (comedi_device *dev,comedi_subdevice *s);
+/* static int rtd_ai_poll (comedi_device *dev,comedi_subdevice *s); */
 static int rtd_ns_to_timer(unsigned int *ns, int roundMode);
 static irqreturn_t rtd_interrupt(int irq, void *d PT_REGS_ARG);
 static int rtd520_probe_fifo_depth(comedi_device *dev);
@@ -866,7 +866,7 @@ static int rtd_attach(comedi_device * dev, comedi_devconfig * it)
 	s-&gt;do_cmd = rtd_ai_cmd;
 	s-&gt;do_cmdtest = rtd_ai_cmdtest;
 	s-&gt;cancel = rtd_ai_cancel;
-	/*s-&gt;poll = rtd_ai_poll; *//* not ready yet */
+	/* s-&gt;poll = rtd_ai_poll; */ /* not ready yet */
 
 	s = dev-&gt;subdevices + 1;
 	/* analog output subdevice */
@@ -1005,7 +1005,7 @@ static int rtd_attach(comedi_device * dev, comedi_devconfig * it)
 
 #if 0
 	/* hit an error, clean up memory and return ret */
-//rtd_attach_die_error:
+/* rtd_attach_die_error: */
 #ifdef USE_DMA
 	for (index = 0; index &lt; DMA_CHAIN_COUNT; index++) {
 		if (NULL != devpriv-&gt;dma0Buff[index]) {	/* free buffer memory */
@@ -1377,15 +1377,15 @@ void abort_dma(comedi_device * dev, unsigned int channel)
 	unsigned long dma_cs_addr;	/* the control/status register */
 	uint8_t status;
 	unsigned int ii;
-	//unsigned long flags;
+	/* unsigned long flags; */
 
 	dma_cs_addr = (unsigned long)devpriv-&gt;lcfg
 		+ ((channel == 0) ? LCFG_DMACSR0 : LCFG_DMACSR1);
 
-	// spinlock for plx dma control/status reg
-	//comedi_spin_lock_irqsave( &amp;dev-&gt;spinlock, flags );
+	/*  spinlock for plx dma control/status reg */
+	/* comedi_spin_lock_irqsave( &amp;dev-&gt;spinlock, flags ); */
 
-	// abort dma transfer if necessary
+	/*  abort dma transfer if necessary */
 	status = readb(dma_cs_addr);
 	if ((status &amp; PLX_DMA_EN_BIT) == 0) {	/* not enabled (Error?) */
 		DPRINTK("rtd520: AbortDma on non-active channel %d (0x%x)\n",
@@ -1410,7 +1410,7 @@ void abort_dma(comedi_device * dev, unsigned int channel)
 	/* set abort bit for channel */
 	writeb(PLX_DMA_ABORT_BIT, dma_cs_addr);
 
-	// wait for dma done bit to be set
+	/*  wait for dma done bit to be set */
 	status = readb(dma_cs_addr);
 	for (ii = 0;
 		(status &amp; PLX_DMA_DONE_BIT) == 0 &amp;&amp; ii &lt; RTD_DMA_TIMEOUT;
@@ -1424,7 +1424,7 @@ void abort_dma(comedi_device * dev, unsigned int channel)
 	}
 
       abortDmaExit:
-	//comedi_spin_unlock_irqrestore( &amp;dev-&gt;spinlock, flags );
+	/* comedi_spin_unlock_irqrestore( &amp;dev-&gt;spinlock, flags ); */
 }
 
 /*
diff --git a/drivers/staging/comedi/drivers/rtd520.h b/drivers/staging/comedi/drivers/rtd520.h
index 0eb50b8e605e..a3ec2599c4b8 100644
--- a/drivers/staging/comedi/drivers/rtd520.h
+++ b/drivers/staging/comedi/drivers/rtd520.h
@@ -29,366 +29,366 @@
   LAS0 Runtime Area
   Local Address Space 0 Offset		Read Function	Write Function
 */
-#define LAS0_SPARE_00    0x0000	// -                               -
-#define LAS0_SPARE_04    0x0004	// -                               -
-#define LAS0_USER_IO     0x0008	// Read User Inputs                Write User Outputs
-#define LAS0_SPARE_0C    0x000C	// -                               -
-#define LAS0_ADC         0x0010	// Read FIFO Status                Software A/D Start
-#define LAS0_DAC1        0x0014	// -                               Software D/A1 Update
-#define LAS0_DAC2        0x0018	// -                               Software D/A2 Update
-#define LAS0_SPARE_1C    0x001C	// -                               -
-#define LAS0_SPARE_20    0x0020	// -                               -
-#define LAS0_DAC         0x0024	// -                               Software Simultaneous D/A1 and D/A2 Update
-#define LAS0_PACER       0x0028	// Software Pacer Start            Software Pacer Stop
-#define LAS0_TIMER       0x002C	// Read Timer Counters Status      HDIN Software Trigger
-#define LAS0_IT          0x0030	// Read Interrupt Status           Write Interrupt Enable Mask Register
-#define LAS0_CLEAR       0x0034	// Clear ITs set by Clear Mask     Set Interrupt Clear Mask
-#define LAS0_OVERRUN     0x0038	// Read pending interrupts         Clear Overrun Register
-#define LAS0_SPARE_3C    0x003C	// -                               -
+#define LAS0_SPARE_00    0x0000	/*  -                               - */
+#define LAS0_SPARE_04    0x0004	/*  -                               - */
+#define LAS0_USER_IO     0x0008	/*  Read User Inputs                Write User Outputs */
+#define LAS0_SPARE_0C    0x000C	/*  -                               - */
+#define LAS0_ADC         0x0010	/*  Read FIFO Status                Software A/D Start */
+#define LAS0_DAC1        0x0014	/*  -                               Software D/A1 Update */
+#define LAS0_DAC2        0x0018	/*  -                               Software D/A2 Update */
+#define LAS0_SPARE_1C    0x001C	/*  -                               - */
+#define LAS0_SPARE_20    0x0020	/*  -                               - */
+#define LAS0_DAC         0x0024	/*  -                               Software Simultaneous D/A1 and D/A2 Update */
+#define LAS0_PACER       0x0028	/*  Software Pacer Start            Software Pacer Stop */
+#define LAS0_TIMER       0x002C	/*  Read Timer Counters Status      HDIN Software Trigger */
+#define LAS0_IT          0x0030	/*  Read Interrupt Status           Write Interrupt Enable Mask Register */
+#define LAS0_CLEAR       0x0034	/*  Clear ITs set by Clear Mask     Set Interrupt Clear Mask */
+#define LAS0_OVERRUN     0x0038	/*  Read pending interrupts         Clear Overrun Register */
+#define LAS0_SPARE_3C    0x003C	/*  -                               - */
 
 /*
   LAS0 Runtime Area Timer/Counter,Dig.IO
   Name			Local Address			Function
 */
-#define LAS0_PCLK        0x0040	// Pacer Clock value (24bit)             Pacer Clock load (24bit)
-#define LAS0_BCLK        0x0044	// Burst Clock value (10bit)             Burst Clock load (10bit)
-#define LAS0_ADC_SCNT    0x0048	// A/D Sample counter value (10bit)      A/D Sample counter load (10bit)
-#define LAS0_DAC1_UCNT   0x004C	// D/A1 Update counter value (10 bit)    D/A1 Update counter load (10bit)
-#define LAS0_DAC2_UCNT   0x0050	// D/A2 Update counter value (10 bit)    D/A2 Update counter load (10bit)
-#define LAS0_DCNT        0x0054	// Delay counter value (16 bit)          Delay counter load (16bit)
-#define LAS0_ACNT        0x0058	// About counter value (16 bit)          About counter load (16bit)
-#define LAS0_DAC_CLK     0x005C	// DAC clock value (16bit)               DAC clock load (16bit)
-#define LAS0_UTC0        0x0060	// 8254 TC Counter 0 User TC 0 value     Load count in TC Counter 0
-#define LAS0_UTC1        0x0064	// 8254 TC Counter 1 User TC 1 value     Load count in TC Counter 1
-#define LAS0_UTC2        0x0068	// 8254 TC Counter 2 User TC 2 value     Load count in TC Counter 2
-#define LAS0_UTC_CTRL    0x006C	// 8254 TC Control Word                  Program counter mode for TC
-#define LAS0_DIO0        0x0070	// Digital I/O Port 0 Read Port          Digital I/O Port 0 Write Port
-#define LAS0_DIO1        0x0074	// Digital I/O Port 1 Read Port          Digital I/O Port 1 Write Port
-#define LAS0_DIO0_CTRL   0x0078	// Clear digital IRQ status flag/read    Clear digital chip/program Port 0
-#define LAS0_DIO_STATUS  0x007C	// Read Digital I/O Status word          Program digital control register &amp;
+#define LAS0_PCLK        0x0040	/*  Pacer Clock value (24bit)             Pacer Clock load (24bit) */
+#define LAS0_BCLK        0x0044	/*  Burst Clock value (10bit)             Burst Clock load (10bit) */
+#define LAS0_ADC_SCNT    0x0048	/*  A/D Sample counter value (10bit)      A/D Sample counter load (10bit) */
+#define LAS0_DAC1_UCNT   0x004C	/*  D/A1 Update counter value (10 bit)    D/A1 Update counter load (10bit) */
+#define LAS0_DAC2_UCNT   0x0050	/*  D/A2 Update counter value (10 bit)    D/A2 Update counter load (10bit) */
+#define LAS0_DCNT        0x0054	/*  Delay counter value (16 bit)          Delay counter load (16bit) */
+#define LAS0_ACNT        0x0058	/*  About counter value (16 bit)          About counter load (16bit) */
+#define LAS0_DAC_CLK     0x005C	/*  DAC clock value (16bit)               DAC clock load (16bit) */
+#define LAS0_UTC0        0x0060	/*  8254 TC Counter 0 User TC 0 value     Load count in TC Counter 0 */
+#define LAS0_UTC1        0x0064	/*  8254 TC Counter 1 User TC 1 value     Load count in TC Counter 1 */
+#define LAS0_UTC2        0x0068	/*  8254 TC Counter 2 User TC 2 value     Load count in TC Counter 2 */
+#define LAS0_UTC_CTRL    0x006C	/*  8254 TC Control Word                  Program counter mode for TC */
+#define LAS0_DIO0        0x0070	/*  Digital I/O Port 0 Read Port          Digital I/O Port 0 Write Port */
+#define LAS0_DIO1        0x0074	/*  Digital I/O Port 1 Read Port          Digital I/O Port 1 Write Port */
+#define LAS0_DIO0_CTRL   0x0078	/*  Clear digital IRQ status flag/read    Clear digital chip/program Port 0 */
+#define LAS0_DIO_STATUS  0x007C	/*  Read Digital I/O Status word          Program digital control register &amp; */
 
 /*
   LAS0 Setup Area
   Name			Local Address			Function
 */
-#define LAS0_BOARD_RESET        0x0100	// Board reset
-#define LAS0_DMA0_SRC           0x0104	// DMA 0 Sources select
-#define LAS0_DMA1_SRC           0x0108	// DMA 1 Sources select
-#define LAS0_ADC_CONVERSION     0x010C	// A/D Conversion Signal select
-#define LAS0_BURST_START        0x0110	// Burst Clock Start Trigger select
-#define LAS0_PACER_START        0x0114	// Pacer Clock Start Trigger select
-#define LAS0_PACER_STOP         0x0118	// Pacer Clock Stop Trigger select
-#define LAS0_ACNT_STOP_ENABLE   0x011C	// About Counter Stop Enable
-#define LAS0_PACER_REPEAT       0x0120	// Pacer Start Trigger Mode select
-#define LAS0_DIN_START          0x0124	// High Speed Digital Input Sampling Signal select
-#define LAS0_DIN_FIFO_CLEAR     0x0128	// Digital Input FIFO Clear
-#define LAS0_ADC_FIFO_CLEAR     0x012C	// A/D FIFO Clear
-#define LAS0_CGT_WRITE          0x0130	// Channel Gain Table Write
-#define LAS0_CGL_WRITE          0x0134	// Channel Gain Latch Write
-#define LAS0_CG_DATA            0x0138	// Digital Table Write
-#define LAS0_CGT_ENABLE		0x013C	// Channel Gain Table Enable
-#define LAS0_CG_ENABLE          0x0140	// Digital Table Enable
-#define LAS0_CGT_PAUSE          0x0144	// Table Pause Enable
-#define LAS0_CGT_RESET          0x0148	// Reset Channel Gain Table
-#define LAS0_CGT_CLEAR          0x014C	// Clear Channel Gain Table
-#define LAS0_DAC1_CTRL          0x0150	// D/A1 output type/range
-#define LAS0_DAC1_SRC           0x0154	// D/A1 update source
-#define LAS0_DAC1_CYCLE         0x0158	// D/A1 cycle mode
-#define LAS0_DAC1_RESET         0x015C	// D/A1 FIFO reset
-#define LAS0_DAC1_FIFO_CLEAR    0x0160	// D/A1 FIFO clear
-#define LAS0_DAC2_CTRL          0x0164	// D/A2 output type/range
-#define LAS0_DAC2_SRC           0x0168	// D/A2 update source
-#define LAS0_DAC2_CYCLE         0x016C	// D/A2 cycle mode
-#define LAS0_DAC2_RESET         0x0170	// D/A2 FIFO reset
-#define LAS0_DAC2_FIFO_CLEAR    0x0174	// D/A2 FIFO clear
-#define LAS0_ADC_SCNT_SRC       0x0178	// A/D Sample Counter Source select
-#define LAS0_PACER_SELECT       0x0180	// Pacer Clock select
-#define LAS0_SBUS0_SRC          0x0184	// SyncBus 0 Source select
-#define LAS0_SBUS0_ENABLE       0x0188	// SyncBus 0 enable
-#define LAS0_SBUS1_SRC          0x018C	// SyncBus 1 Source select
-#define LAS0_SBUS1_ENABLE       0x0190	// SyncBus 1 enable
-#define LAS0_SBUS2_SRC          0x0198	// SyncBus 2 Source select
-#define LAS0_SBUS2_ENABLE       0x019C	// SyncBus 2 enable
-#define LAS0_ETRG_POLARITY      0x01A4	// External Trigger polarity select
-#define LAS0_EINT_POLARITY      0x01A8	// External Interrupt polarity select
-#define LAS0_UTC0_CLOCK         0x01AC	// UTC0 Clock select
-#define LAS0_UTC0_GATE          0x01B0	// UTC0 Gate select
-#define LAS0_UTC1_CLOCK         0x01B4	// UTC1 Clock select
-#define LAS0_UTC1_GATE          0x01B8	// UTC1 Gate select
-#define LAS0_UTC2_CLOCK         0x01BC	// UTC2 Clock select
-#define LAS0_UTC2_GATE          0x01C0	// UTC2 Gate select
-#define LAS0_UOUT0_SELECT       0x01C4	// User Output 0 source select
-#define LAS0_UOUT1_SELECT       0x01C8	// User Output 1 source select
-#define LAS0_DMA0_RESET         0x01CC	// DMA0 Request state machine reset
-#define LAS0_DMA1_RESET         0x01D0	// DMA1 Request state machine reset
+#define LAS0_BOARD_RESET        0x0100	/*  Board reset */
+#define LAS0_DMA0_SRC           0x0104	/*  DMA 0 Sources select */
+#define LAS0_DMA1_SRC           0x0108	/*  DMA 1 Sources select */
+#define LAS0_ADC_CONVERSION     0x010C	/*  A/D Conversion Signal select */
+#define LAS0_BURST_START        0x0110	/*  Burst Clock Start Trigger select */
+#define LAS0_PACER_START        0x0114	/*  Pacer Clock Start Trigger select */
+#define LAS0_PACER_STOP         0x0118	/*  Pacer Clock Stop Trigger select */
+#define LAS0_ACNT_STOP_ENABLE   0x011C	/*  About Counter Stop Enable */
+#define LAS0_PACER_REPEAT       0x0120	/*  Pacer Start Trigger Mode select */
+#define LAS0_DIN_START          0x0124	/*  High Speed Digital Input Sampling Signal select */
+#define LAS0_DIN_FIFO_CLEAR     0x0128	/*  Digital Input FIFO Clear */
+#define LAS0_ADC_FIFO_CLEAR     0x012C	/*  A/D FIFO Clear */
+#define LAS0_CGT_WRITE          0x0130	/*  Channel Gain Table Write */
+#define LAS0_CGL_WRITE          0x0134	/*  Channel Gain Latch Write */
+#define LAS0_CG_DATA            0x0138	/*  Digital Table Write */
+#define LAS0_CGT_ENABLE		0x013C	/*  Channel Gain Table Enable */
+#define LAS0_CG_ENABLE          0x0140	/*  Digital Table Enable */
+#define LAS0_CGT_PAUSE          0x0144	/*  Table Pause Enable */
+#define LAS0_CGT_RESET          0x0148	/*  Reset Channel Gain Table */
+#define LAS0_CGT_CLEAR          0x014C	/*  Clear Channel Gain Table */
+#define LAS0_DAC1_CTRL          0x0150	/*  D/A1 output type/range */
+#define LAS0_DAC1_SRC           0x0154	/*  D/A1 update source */
+#define LAS0_DAC1_CYCLE         0x0158	/*  D/A1 cycle mode */
+#define LAS0_DAC1_RESET         0x015C	/*  D/A1 FIFO reset */
+#define LAS0_DAC1_FIFO_CLEAR    0x0160	/*  D/A1 FIFO clear */
+#define LAS0_DAC2_CTRL          0x0164	/*  D/A2 output type/range */
+#define LAS0_DAC2_SRC           0x0168	/*  D/A2 update source */
+#define LAS0_DAC2_CYCLE         0x016C	/*  D/A2 cycle mode */
+#define LAS0_DAC2_RESET         0x0170	/*  D/A2 FIFO reset */
+#define LAS0_DAC2_FIFO_CLEAR    0x0174	/*  D/A2 FIFO clear */
+#define LAS0_ADC_SCNT_SRC       0x0178	/*  A/D Sample Counter Source select */
+#define LAS0_PACER_SELECT       0x0180	/*  Pacer Clock select */
+#define LAS0_SBUS0_SRC          0x0184	/*  SyncBus 0 Source select */
+#define LAS0_SBUS0_ENABLE       0x0188	/*  SyncBus 0 enable */
+#define LAS0_SBUS1_SRC          0x018C	/*  SyncBus 1 Source select */
+#define LAS0_SBUS1_ENABLE       0x0190	/*  SyncBus 1 enable */
+#define LAS0_SBUS2_SRC          0x0198	/*  SyncBus 2 Source select */
+#define LAS0_SBUS2_ENABLE       0x019C	/*  SyncBus 2 enable */
+#define LAS0_ETRG_POLARITY      0x01A4	/*  External Trigger polarity select */
+#define LAS0_EINT_POLARITY      0x01A8	/*  External Interrupt polarity select */
+#define LAS0_UTC0_CLOCK         0x01AC	/*  UTC0 Clock select */
+#define LAS0_UTC0_GATE          0x01B0	/*  UTC0 Gate select */
+#define LAS0_UTC1_CLOCK         0x01B4	/*  UTC1 Clock select */
+#define LAS0_UTC1_GATE          0x01B8	/*  UTC1 Gate select */
+#define LAS0_UTC2_CLOCK         0x01BC	/*  UTC2 Clock select */
+#define LAS0_UTC2_GATE          0x01C0	/*  UTC2 Gate select */
+#define LAS0_UOUT0_SELECT       0x01C4	/*  User Output 0 source select */
+#define LAS0_UOUT1_SELECT       0x01C8	/*  User Output 1 source select */
+#define LAS0_DMA0_RESET         0x01CC	/*  DMA0 Request state machine reset */
+#define LAS0_DMA1_RESET         0x01D0	/*  DMA1 Request state machine reset */
 
 /*
   LAS1
   Name			Local Address			Function
 */
-#define LAS1_ADC_FIFO            0x0000	// Read A/D FIFO (16bit) -
-#define LAS1_HDIO_FIFO           0x0004	// Read High Speed Digital Input FIFO (16bit) -
-#define LAS1_DAC1_FIFO           0x0008	// - Write D/A1 FIFO (16bit)
-#define LAS1_DAC2_FIFO           0x000C	// - Write D/A2 FIFO (16bit)
+#define LAS1_ADC_FIFO            0x0000	/*  Read A/D FIFO (16bit) - */
+#define LAS1_HDIO_FIFO           0x0004	/*  Read High Speed Digital Input FIFO (16bit) - */
+#define LAS1_DAC1_FIFO           0x0008	/*  - Write D/A1 FIFO (16bit) */
+#define LAS1_DAC2_FIFO           0x000C	/*  - Write D/A2 FIFO (16bit) */
 
 /*
   LCFG: PLX 9080 local config &amp; runtime registers
   Name			Local Address			Function
 */
-#define LCFG_ITCSR              0x0068	// INTCSR, Interrupt Control/Status Register
-#define LCFG_DMAMODE0           0x0080	// DMA Channel 0 Mode Register
-#define LCFG_DMAPADR0           0x0084	// DMA Channel 0 PCI Address Register
-#define LCFG_DMALADR0           0x0088	// DMA Channel 0 Local Address Reg
-#define LCFG_DMASIZ0            0x008C	// DMA Channel 0 Transfer Size (Bytes) Register
-#define LCFG_DMADPR0            0x0090	// DMA Channel 0 Descriptor Pointer Register
-#define LCFG_DMAMODE1           0x0094	// DMA Channel 1 Mode Register
-#define LCFG_DMAPADR1           0x0098	// DMA Channel 1 PCI Address Register
-#define LCFG_DMALADR1           0x009C	// DMA Channel 1 Local Address Register
-#define LCFG_DMASIZ1            0x00A0	// DMA Channel 1 Transfer Size (Bytes) Register
-#define LCFG_DMADPR1            0x00A4	// DMA Channel 1 Descriptor Pointer Register
-#define LCFG_DMACSR0            0x00A8	// DMA Channel 0 Command/Status Register
-#define LCFG_DMACSR1            0x00A9	// DMA Channel 0 Command/Status Register
-#define LCFG_DMAARB             0x00AC	// DMA Arbitration Register
-#define LCFG_DMATHR             0x00B0	// DMA Threshold Register
+#define LCFG_ITCSR              0x0068	/*  INTCSR, Interrupt Control/Status Register */
+#define LCFG_DMAMODE0           0x0080	/*  DMA Channel 0 Mode Register */
+#define LCFG_DMAPADR0           0x0084	/*  DMA Channel 0 PCI Address Register */
+#define LCFG_DMALADR0           0x0088	/*  DMA Channel 0 Local Address Reg */
+#define LCFG_DMASIZ0            0x008C	/*  DMA Channel 0 Transfer Size (Bytes) Register */
+#define LCFG_DMADPR0            0x0090	/*  DMA Channel 0 Descriptor Pointer Register */
+#define LCFG_DMAMODE1           0x0094	/*  DMA Channel 1 Mode Register */
+#define LCFG_DMAPADR1           0x0098	/*  DMA Channel 1 PCI Address Register */
+#define LCFG_DMALADR1           0x009C	/*  DMA Channel 1 Local Address Register */
+#define LCFG_DMASIZ1            0x00A0	/*  DMA Channel 1 Transfer Size (Bytes) Register */
+#define LCFG_DMADPR1            0x00A4	/*  DMA Channel 1 Descriptor Pointer Register */
+#define LCFG_DMACSR0            0x00A8	/*  DMA Channel 0 Command/Status Register */
+#define LCFG_DMACSR1            0x00A9	/*  DMA Channel 0 Command/Status Register */
+#define LCFG_DMAARB             0x00AC	/*  DMA Arbitration Register */
+#define LCFG_DMATHR             0x00B0	/*  DMA Threshold Register */
 
 /*======================================================================
   Resister bit definitions
 ======================================================================*/
 
-// FIFO Status Word Bits (RtdFifoStatus)
-#define FS_DAC1_NOT_EMPTY    0x0001	// D0  - DAC1 FIFO not empty
-#define FS_DAC1_HEMPTY   0x0002	// D1  - DAC1 FIFO half empty
-#define FS_DAC1_NOT_FULL     0x0004	// D2  - DAC1 FIFO not full
-#define FS_DAC2_NOT_EMPTY    0x0010	// D4  - DAC2 FIFO not empty
-#define FS_DAC2_HEMPTY   0x0020	// D5  - DAC2 FIFO half empty
-#define FS_DAC2_NOT_FULL     0x0040	// D6  - DAC2 FIFO not full
-#define FS_ADC_NOT_EMPTY     0x0100	// D8  - ADC FIFO not empty
-#define FS_ADC_HEMPTY    0x0200	// D9  - ADC FIFO half empty
-#define FS_ADC_NOT_FULL      0x0400	// D10 - ADC FIFO not full
-#define FS_DIN_NOT_EMPTY     0x1000	// D12 - DIN FIFO not empty
-#define FS_DIN_HEMPTY    0x2000	// D13 - DIN FIFO half empty
-#define FS_DIN_NOT_FULL      0x4000	// D14 - DIN FIFO not full
-
-// Timer Status Word Bits (GetTimerStatus)
+/*  FIFO Status Word Bits (RtdFifoStatus) */
+#define FS_DAC1_NOT_EMPTY    0x0001	/*  D0  - DAC1 FIFO not empty */
+#define FS_DAC1_HEMPTY   0x0002	/*  D1  - DAC1 FIFO half empty */
+#define FS_DAC1_NOT_FULL     0x0004	/*  D2  - DAC1 FIFO not full */
+#define FS_DAC2_NOT_EMPTY    0x0010	/*  D4  - DAC2 FIFO not empty */
+#define FS_DAC2_HEMPTY   0x0020	/*  D5  - DAC2 FIFO half empty */
+#define FS_DAC2_NOT_FULL     0x0040	/*  D6  - DAC2 FIFO not full */
+#define FS_ADC_NOT_EMPTY     0x0100	/*  D8  - ADC FIFO not empty */
+#define FS_ADC_HEMPTY    0x0200	/*  D9  - ADC FIFO half empty */
+#define FS_ADC_NOT_FULL      0x0400	/*  D10 - ADC FIFO not full */
+#define FS_DIN_NOT_EMPTY     0x1000	/*  D12 - DIN FIFO not empty */
+#define FS_DIN_HEMPTY    0x2000	/*  D13 - DIN FIFO half empty */
+#define FS_DIN_NOT_FULL      0x4000	/*  D14 - DIN FIFO not full */
+
+/*  Timer Status Word Bits (GetTimerStatus) */
 #define TS_PCLK_GATE   0x0001
-// D0 - Pacer Clock Gate [0 - gated, 1 - enabled]
+/*  D0 - Pacer Clock Gate [0 - gated, 1 - enabled] */
 #define TS_BCLK_GATE   0x0002
-// D1 - Burst Clock Gate [0 - disabled, 1 - running]
+/*  D1 - Burst Clock Gate [0 - disabled, 1 - running] */
 #define TS_DCNT_GATE   0x0004
-// D2 - Pacer Clock Delayed Start Trigger [0 - delay over, 1 - delay in
-// progress]
+/*  D2 - Pacer Clock Delayed Start Trigger [0 - delay over, 1 - delay in */
+/*  progress] */
 #define TS_ACNT_GATE   0x0008
-// D3 - Pacer Clock About Trigger [0 - completed, 1 - in progress]
+/*  D3 - Pacer Clock About Trigger [0 - completed, 1 - in progress] */
 #define TS_PCLK_RUN    0x0010
-// D4 - Pacer Clock Shutdown Flag [0 - Pacer Clock cannot be start
-// triggered only by Software Pacer Start Command, 1 - Pacer Clock can
-// be start triggered]
-
-// External Trigger polarity select
-// External Interrupt polarity select
-#define POL_POSITIVE         0x0	// positive edge
-#define POL_NEGATIVE         0x1	// negative edge
-
-// User Output Signal select (SetUout0Source, SetUout1Source)
-#define UOUT_ADC                0x0	// A/D Conversion Signal
-#define UOUT_DAC1               0x1	// D/A1 Update
-#define UOUT_DAC2               0x2	// D/A2 Update
-#define UOUT_SOFTWARE           0x3	// Software Programmable
-
-// Pacer clock select (SetPacerSource)
-#define PCLK_INTERNAL           1	// Internal Pacer Clock
-#define PCLK_EXTERNAL           0	// External Pacer Clock
-
-// A/D Sample Counter Sources (SetAdcntSource, SetupSampleCounter)
-#define ADC_SCNT_CGT_RESET         0x0	// needs restart with StartPacer
+/*  D4 - Pacer Clock Shutdown Flag [0 - Pacer Clock cannot be start */
+/*  triggered only by Software Pacer Start Command, 1 - Pacer Clock can */
+/*  be start triggered] */
+
+/*  External Trigger polarity select */
+/*  External Interrupt polarity select */
+#define POL_POSITIVE         0x0	/*  positive edge */
+#define POL_NEGATIVE         0x1	/*  negative edge */
+
+/*  User Output Signal select (SetUout0Source, SetUout1Source) */
+#define UOUT_ADC                0x0	/*  A/D Conversion Signal */
+#define UOUT_DAC1               0x1	/*  D/A1 Update */
+#define UOUT_DAC2               0x2	/*  D/A2 Update */
+#define UOUT_SOFTWARE           0x3	/*  Software Programmable */
+
+/*  Pacer clock select (SetPacerSource) */
+#define PCLK_INTERNAL           1	/*  Internal Pacer Clock */
+#define PCLK_EXTERNAL           0	/*  External Pacer Clock */
+
+/*  A/D Sample Counter Sources (SetAdcntSource, SetupSampleCounter) */
+#define ADC_SCNT_CGT_RESET         0x0	/*  needs restart with StartPacer */
 #define ADC_SCNT_FIFO_WRITE        0x1
 
-// A/D Conversion Signal Select (for SetConversionSelect)
-#define ADC_START_SOFTWARE         0x0	// Software A/D Start
-#define ADC_START_PCLK             0x1	// Pacer Clock (Ext. Int. see Func.509)
-#define ADC_START_BCLK             0x2	// Burst Clock
-#define ADC_START_DIGITAL_IT       0x3	// Digital Interrupt
-#define ADC_START_DAC1_MARKER1     0x4	// D/A 1 Data Marker 1
-#define ADC_START_DAC2_MARKER1     0x5	// D/A 2 Data Marker 1
-#define ADC_START_SBUS0            0x6	// SyncBus 0
-#define ADC_START_SBUS1            0x7	// SyncBus 1
-#define ADC_START_SBUS2            0x8	// SyncBus 2
-
-// Burst Clock start trigger select (SetBurstStart)
-#define BCLK_START_SOFTWARE        0x0	// Software A/D Start (StartBurst)
-#define BCLK_START_PCLK            0x1	// Pacer Clock
-#define BCLK_START_ETRIG           0x2	// External Trigger
-#define BCLK_START_DIGITAL_IT      0x3	// Digital Interrupt
-#define BCLK_START_SBUS0           0x4	// SyncBus 0
-#define BCLK_START_SBUS1           0x5	// SyncBus 1
-#define BCLK_START_SBUS2           0x6	// SyncBus 2
-
-// Pacer Clock start trigger select (SetPacerStart)
-#define PCLK_START_SOFTWARE        0x0	// Software Pacer Start (StartPacer)
-#define PCLK_START_ETRIG           0x1	// External trigger
-#define PCLK_START_DIGITAL_IT      0x2	// Digital interrupt
-#define PCLK_START_UTC2            0x3	// User TC 2 out
-#define PCLK_START_SBUS0           0x4	// SyncBus 0
-#define PCLK_START_SBUS1           0x5	// SyncBus 1
-#define PCLK_START_SBUS2           0x6	// SyncBus 2
-#define PCLK_START_D_SOFTWARE      0x8	// Delayed Software Pacer Start
-#define PCLK_START_D_ETRIG         0x9	// Delayed external trigger
-#define PCLK_START_D_DIGITAL_IT    0xA	// Delayed digital interrupt
-#define PCLK_START_D_UTC2          0xB	// Delayed User TC 2 out
-#define PCLK_START_D_SBUS0         0xC	// Delayed SyncBus 0
-#define PCLK_START_D_SBUS1         0xD	// Delayed SyncBus 1
-#define PCLK_START_D_SBUS2         0xE	// Delayed SyncBus 2
-#define PCLK_START_ETRIG_GATED     0xF	// External Trigger Gated controlled mode
-
-// Pacer Clock Stop Trigger select (SetPacerStop)
-#define PCLK_STOP_SOFTWARE         0x0	// Software Pacer Stop (StopPacer)
-#define PCLK_STOP_ETRIG            0x1	// External Trigger
-#define PCLK_STOP_DIGITAL_IT       0x2	// Digital Interrupt
-#define PCLK_STOP_ACNT             0x3	// About Counter
-#define PCLK_STOP_UTC2             0x4	// User TC2 out
-#define PCLK_STOP_SBUS0            0x5	// SyncBus 0
-#define PCLK_STOP_SBUS1            0x6	// SyncBus 1
-#define PCLK_STOP_SBUS2            0x7	// SyncBus 2
-#define PCLK_STOP_A_SOFTWARE       0x8	// About Software Pacer Stop
-#define PCLK_STOP_A_ETRIG          0x9	// About External Trigger
-#define PCLK_STOP_A_DIGITAL_IT     0xA	// About Digital Interrupt
-#define PCLK_STOP_A_UTC2           0xC	// About User TC2 out
-#define PCLK_STOP_A_SBUS0          0xD	// About SyncBus 0
-#define PCLK_STOP_A_SBUS1          0xE	// About SyncBus 1
-#define PCLK_STOP_A_SBUS2          0xF	// About SyncBus 2
-
-// About Counter Stop Enable
-#define ACNT_STOP                  0x0	// stop enable
-#define ACNT_NO_STOP               0x1	// stop disabled
-
-// DAC update source (SetDAC1Start &amp; SetDAC2Start)
-#define DAC_START_SOFTWARE         0x0	// Software Update
-#define DAC_START_CGT              0x1	// CGT controlled Update
-#define DAC_START_DAC_CLK          0x2	// D/A Clock
-#define DAC_START_EPCLK            0x3	// External Pacer Clock
-#define DAC_START_SBUS0            0x4	// SyncBus 0
-#define DAC_START_SBUS1            0x5	// SyncBus 1
-#define DAC_START_SBUS2            0x6	// SyncBus 2
-
-// DAC Cycle Mode (SetDAC1Cycle, SetDAC2Cycle, SetupDAC)
-#define DAC_CYCLE_SINGLE           0x0	// not cycle
-#define DAC_CYCLE_MULTI            0x1	// cycle
-
-// 8254 Operation Modes (Set8254Mode, SetupTimerCounter)
-#define M8254_EVENT_COUNTER        0	// Event Counter
-#define M8254_HW_ONE_SHOT          1	// Hardware-Retriggerable One-Shot
-#define M8254_RATE_GENERATOR       2	// Rate Generator
-#define M8254_SQUARE_WAVE          3	// Square Wave Mode
-#define M8254_SW_STROBE            4	// Software Triggered Strobe
-#define M8254_HW_STROBE            5	// Hardware Triggered Strobe (Retriggerable)
-
-// User Timer/Counter 0 Clock Select (SetUtc0Clock)
-#define CUTC0_8MHZ                 0x0	// 8MHz
-#define CUTC0_EXT_TC_CLOCK1        0x1	// Ext. TC Clock 1
-#define CUTC0_EXT_TC_CLOCK2        0x2	// Ext. TC Clock 2
-#define CUTC0_EXT_PCLK             0x3	// Ext. Pacer Clock
-
-// User Timer/Counter 1 Clock Select (SetUtc1Clock)
-#define CUTC1_8MHZ                 0x0	// 8MHz
-#define CUTC1_EXT_TC_CLOCK1        0x1	// Ext. TC Clock 1
-#define CUTC1_EXT_TC_CLOCK2        0x2	// Ext. TC Clock 2
-#define CUTC1_EXT_PCLK             0x3	// Ext. Pacer Clock
-#define CUTC1_UTC0_OUT             0x4	// User Timer/Counter 0 out
-#define CUTC1_DIN_SIGNAL           0x5	// High-Speed Digital Input   Sampling signal
-
-// User Timer/Counter 2 Clock Select (SetUtc2Clock)
-#define CUTC2_8MHZ                 0x0	// 8MHz
-#define CUTC2_EXT_TC_CLOCK1        0x1	// Ext. TC Clock 1
-#define CUTC2_EXT_TC_CLOCK2        0x2	// Ext. TC Clock 2
-#define CUTC2_EXT_PCLK             0x3	// Ext. Pacer Clock
-#define CUTC2_UTC1_OUT             0x4	// User Timer/Counter 1 out
-
-// User Timer/Counter 0 Gate Select (SetUtc0Gate)
-#define GUTC0_NOT_GATED            0x0	// Not gated
-#define GUTC0_GATED                0x1	// Gated
-#define GUTC0_EXT_TC_GATE1         0x2	// Ext. TC Gate 1
-#define GUTC0_EXT_TC_GATE2         0x3	// Ext. TC Gate 2
-
-// User Timer/Counter 1 Gate Select (SetUtc1Gate)
-#define GUTC1_NOT_GATED            0x0	// Not gated
-#define GUTC1_GATED                0x1	// Gated
-#define GUTC1_EXT_TC_GATE1         0x2	// Ext. TC Gate 1
-#define GUTC1_EXT_TC_GATE2         0x3	// Ext. TC Gate 2
-#define GUTC1_UTC0_OUT             0x4	// User Timer/Counter 0 out
-
-// User Timer/Counter 2 Gate Select (SetUtc2Gate)
-#define GUTC2_NOT_GATED            0x0	// Not gated
-#define GUTC2_GATED                0x1	// Gated
-#define GUTC2_EXT_TC_GATE1         0x2	// Ext. TC Gate 1
-#define GUTC2_EXT_TC_GATE2         0x3	// Ext. TC Gate 2
-#define GUTC2_UTC1_OUT             0x4	// User Timer/Counter 1 out
-
-// Interrupt Source Masks (SetITMask, ClearITMask, GetITStatus)
-#define IRQM_ADC_FIFO_WRITE        0x0001	// ADC FIFO Write
-#define IRQM_CGT_RESET             0x0002	// Reset CGT
-#define IRQM_CGT_PAUSE             0x0008	// Pause CGT
-#define IRQM_ADC_ABOUT_CNT         0x0010	// About Counter out
-#define IRQM_ADC_DELAY_CNT         0x0020	// Delay Counter out
-#define IRQM_ADC_SAMPLE_CNT	   0x0040	// ADC Sample Counter
-#define IRQM_DAC1_UCNT             0x0080	// DAC1 Update Counter
-#define IRQM_DAC2_UCNT             0x0100	// DAC2 Update Counter
-#define IRQM_UTC1                  0x0200	// User TC1 out
-#define IRQM_UTC1_INV              0x0400	// User TC1 out, inverted
-#define IRQM_UTC2                  0x0800	// User TC2 out
-#define IRQM_DIGITAL_IT            0x1000	// Digital Interrupt
-#define IRQM_EXTERNAL_IT           0x2000	// External Interrupt
-#define IRQM_ETRIG_RISING          0x4000	// External Trigger rising-edge
-#define IRQM_ETRIG_FALLING         0x8000	// External Trigger falling-edge
-
-// DMA Request Sources (LAS0)
-#define DMAS_DISABLED              0x0	// DMA Disabled
-#define DMAS_ADC_SCNT              0x1	// ADC Sample Counter
-#define DMAS_DAC1_UCNT             0x2	// D/A1 Update Counter
-#define DMAS_DAC2_UCNT             0x3	// D/A2 Update Counter
-#define DMAS_UTC1                  0x4	// User TC1 out
-#define DMAS_ADFIFO_HALF_FULL      0x8	// A/D FIFO half full
-#define DMAS_DAC1_FIFO_HALF_EMPTY  0x9	// D/A1 FIFO half empty
-#define DMAS_DAC2_FIFO_HALF_EMPTY  0xA	// D/A2 FIFO half empty
-
-// DMA Local Addresses   (0x40000000+LAS1 offset)
-#define DMALADDR_ADC       0x40000000	// A/D FIFO
-#define DMALADDR_HDIN      0x40000004	// High Speed Digital Input FIFO
-#define DMALADDR_DAC1      0x40000008	// D/A1 FIFO
-#define DMALADDR_DAC2      0x4000000C	// D/A2 FIFO
-
-// Port 0 compare modes (SetDIO0CompareMode)
-#define DIO_MODE_EVENT     0	// Event Mode
-#define DIO_MODE_MATCH     1	// Match Mode
-
-// Digital Table Enable (Port 1 disable)
-#define DTBL_DISABLE       0	// Enable Digital Table
-#define DTBL_ENABLE        1	// Disable Digital Table
-
-// Sampling Signal for High Speed Digital Input (SetHdinStart)
-#define HDIN_SOFTWARE      0x0	// Software Trigger
-#define HDIN_ADC           0x1	// A/D Conversion Signal
-#define HDIN_UTC0          0x2	// User TC out 0
-#define HDIN_UTC1          0x3	// User TC out 1
-#define HDIN_UTC2          0x4	// User TC out 2
-#define HDIN_EPCLK         0x5	// External Pacer Clock
-#define HDIN_ETRG          0x6	// External Trigger
-
-// Channel Gain Table / Channel Gain Latch
-#define CSC_LATCH          0	// Channel Gain Latch mode
-#define CSC_CGT            1	// Channel Gain Table mode
-
-// Channel Gain Table Pause Enable
-#define CGT_PAUSE_DISABLE  0	// Channel Gain Table Pause Disable
-#define CGT_PAUSE_ENABLE   1	// Channel Gain Table Pause Enable
-
-// DAC output type/range (p63)
-#define AOUT_UNIP5         0	// 0..+5 Volt
-#define AOUT_UNIP10        1	// 0..+10 Volt
-#define AOUT_BIP5          2	// -5..+5 Volt
-#define AOUT_BIP10         3	// -10..+10 Volt
-
-// Ghannel Gain Table field definitions (p61)
-// Gain
+/*  A/D Conversion Signal Select (for SetConversionSelect) */
+#define ADC_START_SOFTWARE         0x0	/*  Software A/D Start */
+#define ADC_START_PCLK             0x1	/*  Pacer Clock (Ext. Int. see Func.509) */
+#define ADC_START_BCLK             0x2	/*  Burst Clock */
+#define ADC_START_DIGITAL_IT       0x3	/*  Digital Interrupt */
+#define ADC_START_DAC1_MARKER1     0x4	/*  D/A 1 Data Marker 1 */
+#define ADC_START_DAC2_MARKER1     0x5	/*  D/A 2 Data Marker 1 */
+#define ADC_START_SBUS0            0x6	/*  SyncBus 0 */
+#define ADC_START_SBUS1            0x7	/*  SyncBus 1 */
+#define ADC_START_SBUS2            0x8	/*  SyncBus 2 */
+
+/*  Burst Clock start trigger select (SetBurstStart) */
+#define BCLK_START_SOFTWARE        0x0	/*  Software A/D Start (StartBurst) */
+#define BCLK_START_PCLK            0x1	/*  Pacer Clock */
+#define BCLK_START_ETRIG           0x2	/*  External Trigger */
+#define BCLK_START_DIGITAL_IT      0x3	/*  Digital Interrupt */
+#define BCLK_START_SBUS0           0x4	/*  SyncBus 0 */
+#define BCLK_START_SBUS1           0x5	/*  SyncBus 1 */
+#define BCLK_START_SBUS2           0x6	/*  SyncBus 2 */
+
+/*  Pacer Clock start trigger select (SetPacerStart) */
+#define PCLK_START_SOFTWARE        0x0	/*  Software Pacer Start (StartPacer) */
+#define PCLK_START_ETRIG           0x1	/*  External trigger */
+#define PCLK_START_DIGITAL_IT      0x2	/*  Digital interrupt */
+#define PCLK_START_UTC2            0x3	/*  User TC 2 out */
+#define PCLK_START_SBUS0           0x4	/*  SyncBus 0 */
+#define PCLK_START_SBUS1           0x5	/*  SyncBus 1 */
+#define PCLK_START_SBUS2           0x6	/*  SyncBus 2 */
+#define PCLK_START_D_SOFTWARE      0x8	/*  Delayed Software Pacer Start */
+#define PCLK_START_D_ETRIG         0x9	/*  Delayed external trigger */
+#define PCLK_START_D_DIGITAL_IT    0xA	/*  Delayed digital interrupt */
+#define PCLK_START_D_UTC2          0xB	/*  Delayed User TC 2 out */
+#define PCLK_START_D_SBUS0         0xC	/*  Delayed SyncBus 0 */
+#define PCLK_START_D_SBUS1         0xD	/*  Delayed SyncBus 1 */
+#define PCLK_START_D_SBUS2         0xE	/*  Delayed SyncBus 2 */
+#define PCLK_START_ETRIG_GATED     0xF	/*  External Trigger Gated controlled mode */
+
+/*  Pacer Clock Stop Trigger select (SetPacerStop) */
+#define PCLK_STOP_SOFTWARE         0x0	/*  Software Pacer Stop (StopPacer) */
+#define PCLK_STOP_ETRIG            0x1	/*  External Trigger */
+#define PCLK_STOP_DIGITAL_IT       0x2	/*  Digital Interrupt */
+#define PCLK_STOP_ACNT             0x3	/*  About Counter */
+#define PCLK_STOP_UTC2             0x4	/*  User TC2 out */
+#define PCLK_STOP_SBUS0            0x5	/*  SyncBus 0 */
+#define PCLK_STOP_SBUS1            0x6	/*  SyncBus 1 */
+#define PCLK_STOP_SBUS2            0x7	/*  SyncBus 2 */
+#define PCLK_STOP_A_SOFTWARE       0x8	/*  About Software Pacer Stop */
+#define PCLK_STOP_A_ETRIG          0x9	/*  About External Trigger */
+#define PCLK_STOP_A_DIGITAL_IT     0xA	/*  About Digital Interrupt */
+#define PCLK_STOP_A_UTC2           0xC	/*  About User TC2 out */
+#define PCLK_STOP_A_SBUS0          0xD	/*  About SyncBus 0 */
+#define PCLK_STOP_A_SBUS1          0xE	/*  About SyncBus 1 */
+#define PCLK_STOP_A_SBUS2          0xF	/*  About SyncBus 2 */
+
+/*  About Counter Stop Enable */
+#define ACNT_STOP                  0x0	/*  stop enable */
+#define ACNT_NO_STOP               0x1	/*  stop disabled */
+
+/*  DAC update source (SetDAC1Start &amp; SetDAC2Start) */
+#define DAC_START_SOFTWARE         0x0	/*  Software Update */
+#define DAC_START_CGT              0x1	/*  CGT controlled Update */
+#define DAC_START_DAC_CLK          0x2	/*  D/A Clock */
+#define DAC_START_EPCLK            0x3	/*  External Pacer Clock */
+#define DAC_START_SBUS0            0x4	/*  SyncBus 0 */
+#define DAC_START_SBUS1            0x5	/*  SyncBus 1 */
+#define DAC_START_SBUS2            0x6	/*  SyncBus 2 */
+
+/*  DAC Cycle Mode (SetDAC1Cycle, SetDAC2Cycle, SetupDAC) */
+#define DAC_CYCLE_SINGLE           0x0	/*  not cycle */
+#define DAC_CYCLE_MULTI            0x1	/*  cycle */
+
+/*  8254 Operation Modes (Set8254Mode, SetupTimerCounter) */
+#define M8254_EVENT_COUNTER        0	/*  Event Counter */
+#define M8254_HW_ONE_SHOT          1	/*  Hardware-Retriggerable One-Shot */
+#define M8254_RATE_GENERATOR       2	/*  Rate Generator */
+#define M8254_SQUARE_WAVE          3	/*  Square Wave Mode */
+#define M8254_SW_STROBE            4	/*  Software Triggered Strobe */
+#define M8254_HW_STROBE            5	/*  Hardware Triggered Strobe (Retriggerable) */
+
+/*  User Timer/Counter 0 Clock Select (SetUtc0Clock) */
+#define CUTC0_8MHZ                 0x0	/*  8MHz */
+#define CUTC0_EXT_TC_CLOCK1        0x1	/*  Ext. TC Clock 1 */
+#define CUTC0_EXT_TC_CLOCK2        0x2	/*  Ext. TC Clock 2 */
+#define CUTC0_EXT_PCLK             0x3	/*  Ext. Pacer Clock */
+
+/*  User Timer/Counter 1 Clock Select (SetUtc1Clock) */
+#define CUTC1_8MHZ                 0x0	/*  8MHz */
+#define CUTC1_EXT_TC_CLOCK1        0x1	/*  Ext. TC Clock 1 */
+#define CUTC1_EXT_TC_CLOCK2        0x2	/*  Ext. TC Clock 2 */
+#define CUTC1_EXT_PCLK             0x3	/*  Ext. Pacer Clock */
+#define CUTC1_UTC0_OUT             0x4	/*  User Timer/Counter 0 out */
+#define CUTC1_DIN_SIGNAL           0x5	/*  High-Speed Digital Input   Sampling signal */
+
+/*  User Timer/Counter 2 Clock Select (SetUtc2Clock) */
+#define CUTC2_8MHZ                 0x0	/*  8MHz */
+#define CUTC2_EXT_TC_CLOCK1        0x1	/*  Ext. TC Clock 1 */
+#define CUTC2_EXT_TC_CLOCK2        0x2	/*  Ext. TC Clock 2 */
+#define CUTC2_EXT_PCLK             0x3	/*  Ext. Pacer Clock */
+#define CUTC2_UTC1_OUT             0x4	/*  User Timer/Counter 1 out */
+
+/*  User Timer/Counter 0 Gate Select (SetUtc0Gate) */
+#define GUTC0_NOT_GATED            0x0	/*  Not gated */
+#define GUTC0_GATED                0x1	/*  Gated */
+#define GUTC0_EXT_TC_GATE1         0x2	/*  Ext. TC Gate 1 */
+#define GUTC0_EXT_TC_GATE2         0x3	/*  Ext. TC Gate 2 */
+
+/*  User Timer/Counter 1 Gate Select (SetUtc1Gate) */
+#define GUTC1_NOT_GATED            0x0	/*  Not gated */
+#define GUTC1_GATED                0x1	/*  Gated */
+#define GUTC1_EXT_TC_GATE1         0x2	/*  Ext. TC Gate 1 */
+#define GUTC1_EXT_TC_GATE2         0x3	/*  Ext. TC Gate 2 */
+#define GUTC1_UTC0_OUT             0x4	/*  User Timer/Counter 0 out */
+
+/*  User Timer/Counter 2 Gate Select (SetUtc2Gate) */
+#define GUTC2_NOT_GATED            0x0	/*  Not gated */
+#define GUTC2_GATED                0x1	/*  Gated */
+#define GUTC2_EXT_TC_GATE1         0x2	/*  Ext. TC Gate 1 */
+#define GUTC2_EXT_TC_GATE2         0x3	/*  Ext. TC Gate 2 */
+#define GUTC2_UTC1_OUT             0x4	/*  User Timer/Counter 1 out */
+
+/*  Interrupt Source Masks (SetITMask, ClearITMask, GetITStatus) */
+#define IRQM_ADC_FIFO_WRITE        0x0001	/*  ADC FIFO Write */
+#define IRQM_CGT_RESET             0x0002	/*  Reset CGT */
+#define IRQM_CGT_PAUSE             0x0008	/*  Pause CGT */
+#define IRQM_ADC_ABOUT_CNT         0x0010	/*  About Counter out */
+#define IRQM_ADC_DELAY_CNT         0x0020	/*  Delay Counter out */
+#define IRQM_ADC_SAMPLE_CNT	   0x0040	/*  ADC Sample Counter */
+#define IRQM_DAC1_UCNT             0x0080	/*  DAC1 Update Counter */
+#define IRQM_DAC2_UCNT             0x0100	/*  DAC2 Update Counter */
+#define IRQM_UTC1                  0x0200	/*  User TC1 out */
+#define IRQM_UTC1_INV              0x0400	/*  User TC1 out, inverted */
+#define IRQM_UTC2                  0x0800	/*  User TC2 out */
+#define IRQM_DIGITAL_IT            0x1000	/*  Digital Interrupt */
+#define IRQM_EXTERNAL_IT           0x2000	/*  External Interrupt */
+#define IRQM_ETRIG_RISING          0x4000	/*  External Trigger rising-edge */
+#define IRQM_ETRIG_FALLING         0x8000	/*  External Trigger falling-edge */
+
+/*  DMA Request Sources (LAS0) */
+#define DMAS_DISABLED              0x0	/*  DMA Disabled */
+#define DMAS_ADC_SCNT              0x1	/*  ADC Sample Counter */
+#define DMAS_DAC1_UCNT             0x2	/*  D/A1 Update Counter */
+#define DMAS_DAC2_UCNT             0x3	/*  D/A2 Update Counter */
+#define DMAS_UTC1                  0x4	/*  User TC1 out */
+#define DMAS_ADFIFO_HALF_FULL      0x8	/*  A/D FIFO half full */
+#define DMAS_DAC1_FIFO_HALF_EMPTY  0x9	/*  D/A1 FIFO half empty */
+#define DMAS_DAC2_FIFO_HALF_EMPTY  0xA	/*  D/A2 FIFO half empty */
+
+/*  DMA Local Addresses   (0x40000000+LAS1 offset) */
+#define DMALADDR_ADC       0x40000000	/*  A/D FIFO */
+#define DMALADDR_HDIN      0x40000004	/*  High Speed Digital Input FIFO */
+#define DMALADDR_DAC1      0x40000008	/*  D/A1 FIFO */
+#define DMALADDR_DAC2      0x4000000C	/*  D/A2 FIFO */
+
+/*  Port 0 compare modes (SetDIO0CompareMode) */
+#define DIO_MODE_EVENT     0	/*  Event Mode */
+#define DIO_MODE_MATCH     1	/*  Match Mode */
+
+/*  Digital Table Enable (Port 1 disable) */
+#define DTBL_DISABLE       0	/*  Enable Digital Table */
+#define DTBL_ENABLE        1	/*  Disable Digital Table */
+
+/*  Sampling Signal for High Speed Digital Input (SetHdinStart) */
+#define HDIN_SOFTWARE      0x0	/*  Software Trigger */
+#define HDIN_ADC           0x1	/*  A/D Conversion Signal */
+#define HDIN_UTC0          0x2	/*  User TC out 0 */
+#define HDIN_UTC1          0x3	/*  User TC out 1 */
+#define HDIN_UTC2          0x4	/*  User TC out 2 */
+#define HDIN_EPCLK         0x5	/*  External Pacer Clock */
+#define HDIN_ETRG          0x6	/*  External Trigger */
+
+/*  Channel Gain Table / Channel Gain Latch */
+#define CSC_LATCH          0	/*  Channel Gain Latch mode */
+#define CSC_CGT            1	/*  Channel Gain Table mode */
+
+/*  Channel Gain Table Pause Enable */
+#define CGT_PAUSE_DISABLE  0	/*  Channel Gain Table Pause Disable */
+#define CGT_PAUSE_ENABLE   1	/*  Channel Gain Table Pause Enable */
+
+/*  DAC output type/range (p63) */
+#define AOUT_UNIP5         0	/*  0..+5 Volt */
+#define AOUT_UNIP10        1	/*  0..+10 Volt */
+#define AOUT_BIP5          2	/*  -5..+5 Volt */
+#define AOUT_BIP10         3	/*  -10..+10 Volt */
+
+/*  Ghannel Gain Table field definitions (p61) */
+/*  Gain */
 #define GAIN1              0
 #define GAIN2              1
 #define GAIN4              2
@@ -398,15 +398,15 @@
 #define GAIN64             6
 #define GAIN128            7
 
-// Input range/polarity
-#define AIN_BIP5           0	// -5..+5 Volt
-#define AIN_BIP10          1	// -10..+10 Volt
-#define AIN_UNIP10         2	// 0..+10 Volt
+/*  Input range/polarity */
+#define AIN_BIP5           0	/*  -5..+5 Volt */
+#define AIN_BIP10          1	/*  -10..+10 Volt */
+#define AIN_UNIP10         2	/*  0..+10 Volt */
 
-// non referenced single ended select bit
-#define NRSE_AGND          0	// AGND referenced SE input
-#define NRSE_AINS          1	// AIN SENSE referenced SE input
+/*  non referenced single ended select bit */
+#define NRSE_AGND          0	/*  AGND referenced SE input */
+#define NRSE_AINS          1	/*  AIN SENSE referenced SE input */
 
-// single ended vs differential
-#define GND_SE		0	// Single-Ended
-#define GND_DIFF	1	// Differential
+/*  single ended vs differential */
+#define GND_SE		0	/*  Single-Ended */
+#define GND_DIFF	1	/*  Differential */
diff --git a/drivers/staging/comedi/drivers/s626.c b/drivers/staging/comedi/drivers/s626.c
index 469ee8c474c9..24577a9a16b1 100644
--- a/drivers/staging/comedi/drivers/s626.c
+++ b/drivers/staging/comedi/drivers/s626.c
@@ -133,38 +133,30 @@ typedef struct {
 	void *base_addr;
 	int got_regions;
 	short allocatedBuf;
-	uint8_t ai_cmd_running;	// ai_cmd is running
-	uint8_t ai_continous;	// continous aquisition
-	int ai_sample_count;	// number of samples to aquire
-	unsigned int ai_sample_timer;	// time between samples in
-	// units of the timer
-	int ai_convert_count;	// conversion counter
-	unsigned int ai_convert_timer;	// time between conversion in
-	// units of the timer
-	uint16_t CounterIntEnabs;	//Counter interrupt enable
-	//mask for MISC2 register.
-	uint8_t AdcItems;	//Number of items in ADC poll
-	//list.
-	DMABUF RPSBuf;		//DMA buffer used to hold ADC
-	//(RPS1) program.
-	DMABUF ANABuf;		//DMA buffer used to receive
-	//ADC data and hold DAC data.
-	uint32_t *pDacWBuf;	//Pointer to logical adrs of
-	//DMA buffer used to hold DAC
-	//data.
-	uint16_t Dacpol;	//Image of DAC polarity
-	//register.
-	uint8_t TrimSetpoint[12];	//Images of TrimDAC setpoints.
-	//registers.
-	uint16_t ChargeEnabled;	//Image of MISC2 Battery
-	//Charge Enabled (0 or
-	//WRMISC2_CHARGE_ENABLE).
-	uint16_t WDInterval;	//Image of MISC2 watchdog
-	//interval control bits.
-	uint32_t I2CAdrs;	//I2C device address for
-	//onboard EEPROM (board rev
-	//dependent).
-	//  short         I2Cards;
+	uint8_t ai_cmd_running;	/*  ai_cmd is running */
+	uint8_t ai_continous;	/*  continous aquisition */
+	int ai_sample_count;	/*  number of samples to aquire */
+	unsigned int ai_sample_timer;
+	/*  time between samples in  units of the timer */
+	int ai_convert_count;	/*  conversion counter */
+	unsigned int ai_convert_timer;
+	/*  time between conversion in  units of the timer */
+	uint16_t CounterIntEnabs;
+	/* Counter interrupt enable  mask for MISC2 register. */
+	uint8_t AdcItems;	/* Number of items in ADC poll  list. */
+	DMABUF RPSBuf;		/* DMA buffer used to hold ADC (RPS1) program. */
+	DMABUF ANABuf;
+	/* DMA buffer used to receive ADC data and hold DAC data. */
+	uint32_t *pDacWBuf;
+	/* Pointer to logical adrs of DMA buffer used to hold DAC  data. */
+	uint16_t Dacpol;	/* Image of DAC polarity register. */
+	uint8_t TrimSetpoint[12];	/* Images of TrimDAC setpoints */
+	uint16_t ChargeEnabled;	/* Image of MISC2 Battery */
+	/* Charge Enabled (0 or WRMISC2_CHARGE_ENABLE). */
+	uint16_t WDInterval;	/* Image of MISC2 watchdog interval control bits. */
+	uint32_t I2CAdrs;
+	/* I2C device address for onboard EEPROM (board rev dependent). */
+	/*   short         I2Cards; */
 	lsampl_t ao_readback[S626_DAC_CHANNELS];
 } s626_private;
 
@@ -229,7 +221,7 @@ static dio_private *dio_private_word[]={
 
 COMEDI_PCI_INITCLEANUP_NOMODULE(driver_s626, s626_pci_table);
 
-//ioctl routines
+/* ioctl routines */
 static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, lsampl_t * data);
 /* static int s626_ai_rinsn(comedi_device *dev,comedi_subdevice *s,comedi_insn *insn,lsampl_t *data); */
@@ -265,9 +257,9 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG);
 static lsampl_t s626_ai_reg_to_uint(int data);
 /* static lsampl_t s626_uint_to_reg(comedi_subdevice *s, int data); */
 
-//end ioctl routines
+/* end ioctl routines */
 
-//internal routines
+/* internal routines */
 static void s626_dio_init(comedi_device * dev);
 static void ResetADC(comedi_device * dev, uint8_t * ppl);
 static void LoadTrimDACs(comedi_device * dev);
@@ -285,30 +277,30 @@ static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata);
 static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize);
 
-// COUNTER OBJECT ------------------------------------------------
+/*  COUNTER OBJECT ------------------------------------------------ */
 typedef struct enc_private_struct {
-	// Pointers to functions that differ for A and B counters:
-	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	//Return clock enable.
-	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	//Return interrupt source.
-	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	//Return preload trigger source.
-	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	//Return standardized operating mode.
-	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	//Generate soft index strobe.
-	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	//Program clock enable.
-	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	//Program interrupt source.
-	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	//Program preload trigger source.
-	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	//Program standardized operating mode.
-	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	//Reset event capture flags.
-
-	uint16_t MyCRA;		//   Address of CRA register.
-	uint16_t MyCRB;		//   Address of CRB register.
-	uint16_t MyLatchLsw;	//   Address of Latch least-significant-word
-	//   register.
-	uint16_t MyEventBits[4];	//   Bit translations for IntSrc --&gt;RDMISC2.
-} enc_private;			//counter object
+	/*  Pointers to functions that differ for A and B counters: */
+	uint16_t(*GetEnable) (comedi_device * dev, struct enc_private_struct *);	/* Return clock enable. */
+	uint16_t(*GetIntSrc) (comedi_device * dev, struct enc_private_struct *);	/* Return interrupt source. */
+	uint16_t(*GetLoadTrig) (comedi_device * dev, struct enc_private_struct *);	/* Return preload trigger source. */
+	uint16_t(*GetMode) (comedi_device * dev, struct enc_private_struct *);	/* Return standardized operating mode. */
+	void (*PulseIndex) (comedi_device * dev, struct enc_private_struct *);	/* Generate soft index strobe. */
+	void (*SetEnable) (comedi_device * dev, struct enc_private_struct *, uint16_t enab);	/* Program clock enable. */
+	void (*SetIntSrc) (comedi_device * dev, struct enc_private_struct *, uint16_t IntSource);	/* Program interrupt source. */
+	void (*SetLoadTrig) (comedi_device * dev, struct enc_private_struct *, uint16_t Trig);	/* Program preload trigger source. */
+	void (*SetMode) (comedi_device * dev, struct enc_private_struct *, uint16_t Setup, uint16_t DisableIntSrc);	/* Program standardized operating mode. */
+	void (*ResetCapFlags) (comedi_device * dev, struct enc_private_struct *);	/* Reset event capture flags. */
+
+	uint16_t MyCRA;		/*    Address of CRA register. */
+	uint16_t MyCRB;		/*    Address of CRB register. */
+	uint16_t MyLatchLsw;	/*    Address of Latch least-significant-word */
+	/*    register. */
+	uint16_t MyEventBits[4];	/*    Bit translations for IntSrc --&gt;RDMISC2. */
+} enc_private;			/* counter object */
 
 #define encpriv ((enc_private *)(dev-&gt;subdevices+5)-&gt;private)
 
-//counters routines
+/* counters routines */
 static void s626_timer_load(comedi_device * dev, enc_private * k, int tick);
 static uint32_t ReadLatch(comedi_device * dev, enc_private * k);
 static void ResetCapFlags_A(comedi_device * dev, enc_private * k);
@@ -348,19 +340,17 @@ static void PulseIndex_A(comedi_device * dev, enc_private * k);
 static void PulseIndex_B(comedi_device * dev, enc_private * k);
 static void Preload(comedi_device * dev, enc_private * k, uint32_t value);
 static void CountersInit(comedi_device * dev);
-//end internal routines
+/* end internal routines */
 
-/////////////////////////////////////////////////////////////////////////
-// Counter objects constructor.
+/*  Counter objects constructor. */
 
-// Counter overflow/index event flag masks for RDMISC2.
+/*  Counter overflow/index event flag masks for RDMISC2. */
 #define INDXMASK(C)		( 1 &lt;&lt; ( ( (C) &gt; 2 ) ? ( (C) * 2 - 1 ) : ( (C) * 2 +  4 ) ) )
 #define OVERMASK(C)		( 1 &lt;&lt; ( ( (C) &gt; 2 ) ? ( (C) * 2 + 5 ) : ( (C) * 2 + 10 ) ) )
 #define EVBITS(C)		{ 0, OVERMASK(C), INDXMASK(C), OVERMASK(C) | INDXMASK(C) }
 
-// Translation table to map IntSrc into equivalent RDMISC2 event flag
-// bits.
-//static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) };
+/*  Translation table to map IntSrc into equivalent RDMISC2 event flag  bits. */
+/* static const uint16_t EventBits[][4] = { EVBITS(0), EVBITS(1), EVBITS(2), EVBITS(3), EVBITS(4), EVBITS(5) }; */
 
 /* enc_private; */
 static enc_private enc_private_data[] = {
@@ -462,8 +452,8 @@ static enc_private enc_private_data[] = {
 		},
 };
 
-// enab/disable a function or test status bit(s) that are accessed
-// through Main Control Registers 1 or 2.
+/*  enab/disable a function or test status bit(s) that are accessed */
+/*  through Main Control Registers 1 or 2. */
 #define MC_ENABLE( REGADRS, CTRLWORD )	writel(  ( (uint32_t)( CTRLWORD ) &lt;&lt; 16 ) | (uint32_t)( CTRLWORD ),devpriv-&gt;base_addr+( REGADRS ) )
 
 #define MC_DISABLE( REGADRS, CTRLWORD )	writel(  (uint32_t)( CTRLWORD ) &lt;&lt; 16 , devpriv-&gt;base_addr+( REGADRS ) )
@@ -480,11 +470,11 @@ static enc_private enc_private_data[] = {
 
 #define BUGFIX_STREG(REGADRS)   ( REGADRS - 4 )
 
-// Write a time slot control record to TSL2.
+/*  Write a time slot control record to TSL2. */
 #define VECTPORT( VECTNUM )		(P_TSL2 + ( (VECTNUM) &lt;&lt; 2 ))
 #define SETVECT( VECTNUM, VECTVAL )	WR7146(VECTPORT( VECTNUM ), (VECTVAL))
 
-// Code macros used for constructing I2C command bytes.
+/*  Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR,VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
 #define I2C_B1(ATTR,VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
 #define I2C_B0(ATTR,VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
@@ -550,16 +540,16 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 	}
 
 	if (devpriv-&gt;base_addr) {
-		//disable master interrupt
+		/* disable master interrupt */
 		writel(0, devpriv-&gt;base_addr + P_IER);
 
-		//soft reset
+		/* soft reset */
 		writel(MC1_SOFT_RESET, devpriv-&gt;base_addr + P_MC1);
 
-		//DMA FIXME DMA//
+		/* DMA FIXME DMA// */
 		DEBUG("s626_attach: DMA ALLOCATION\n");
 
-		//adc buffer allocation
+		/* adc buffer allocation */
 		devpriv-&gt;allocatedBuf = 0;
 
 		if ((devpriv-&gt;ANABuf.LogicalBase =
@@ -599,7 +589,7 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 	dev-&gt;iobase = (unsigned long)devpriv-&gt;base_addr;
 	dev-&gt;irq = devpriv-&gt;pdev-&gt;irq;
 
-	//set up interrupt handler
+	/* set up interrupt handler */
 	if (dev-&gt;irq == 0) {
 		printk(" unknown irq (bad)\n");
 	} else {
@@ -689,119 +679,119 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 	s-&gt;maxdata = 0xffffff;
 	s-&gt;range_table = &amp;range_unknown;
 
-	//stop ai_command
+	/* stop ai_command */
 	devpriv-&gt;ai_cmd_running = 0;
 
 	if (devpriv-&gt;base_addr &amp;&amp; (devpriv-&gt;allocatedBuf == 2)) {
 		dma_addr_t pPhysBuf;
 		uint16_t chan;
 
-		// enab DEBI and audio pins, enable I2C interface.
+		/*  enab DEBI and audio pins, enable I2C interface. */
 		MC_ENABLE(P_MC1, MC1_DEBI | MC1_AUDIO | MC1_I2C);
-		// Configure DEBI operating mode.
-		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	// Local bus is 16
-			// bits wide.
-			| (DEBI_TOUT &lt;&lt; DEBI_CFG_TOUT_BIT)	// Declare DEBI
-			// transfer timeout
-			// interval.
-			| DEBI_SWAP	// Set up byte lane
-			// steering.
-			| DEBI_CFG_INTEL);	// Intel-compatible
-		// local bus (DEBI
-		// never times out).
+		/*  Configure DEBI operating mode. */
+		WR7146(P_DEBICFG, DEBI_CFG_SLAVE16	/*  Local bus is 16 */
+			/*  bits wide. */
+			| (DEBI_TOUT &lt;&lt; DEBI_CFG_TOUT_BIT)	/*  Declare DEBI */
+			/*  transfer timeout */
+			/*  interval. */
+			| DEBI_SWAP	/*  Set up byte lane */
+			/*  steering. */
+			| DEBI_CFG_INTEL);	/*  Intel-compatible */
+		/*  local bus (DEBI */
+		/*  never times out). */
 		DEBUG("s626_attach: %d debi init -- %d\n",
 			DEBI_CFG_SLAVE16 | (DEBI_TOUT &lt;&lt; DEBI_CFG_TOUT_BIT) |
 			DEBI_SWAP | DEBI_CFG_INTEL,
 			DEBI_CFG_INTEL | DEBI_CFG_TOQ | DEBI_CFG_INCQ |
 			DEBI_CFG_16Q);
 
-		//DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ
-		//| DEBI_CFG_INCQ| DEBI_CFG_16Q); //end
+		/* DEBI INIT S626 WR7146( P_DEBICFG, DEBI_CFG_INTEL | DEBI_CFG_TOQ */
+		/* | DEBI_CFG_INCQ| DEBI_CFG_16Q); //end */
 
-		// Paging is disabled.
-		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	// Disable MMU paging.
+		/*  Paging is disabled. */
+		WR7146(P_DEBIPAGE, DEBI_PAGE_DISABLE);	/*  Disable MMU paging. */
 
-		// Init GPIO so that ADC Start* is negated.
+		/*  Init GPIO so that ADC Start* is negated. */
 		WR7146(P_GPIO, GPIO_BASE | GPIO1_HI);
 
-		//IsBoardRevA is a boolean that indicates whether the board is
-		//RevA.
-
-		// VERSION 2.01 CHANGE: REV A &amp; B BOARDS NOW SUPPORTED BY DYNAMIC
-		// EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
-		// is used to access the onboard serial EEPROM.  The EEPROM's I2C
-		// DeviceAddress is hardwired to a value that is dependent on the
-		// 626 board revision.  On all board revisions, the EEPROM stores
-		// TrimDAC calibration constants for analog I/O.  On RevB and
-		// higher boards, the DeviceAddress is hardwired to 0 to enable
-		// the EEPROM to also store the PCI SubVendorID and SubDeviceID;
-		// this is the address at which the SAA7146 expects a
-		// configuration EEPROM to reside.  On RevA boards, the EEPROM
-		// device address, which is hardwired to 4, prevents the SAA7146
-		// from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
-		// default values, instead.
-
-		//    devpriv-&gt;I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM
-		// DeviceType (0xA0)
-		// and DeviceAddress&lt;&lt;1.
-
-		devpriv-&gt;I2CAdrs = 0xA0;	// I2C device address for onboard
-		// eeprom(revb)
-
-		// Issue an I2C ABORT command to halt any I2C operation in
-		//progress and reset BUSY flag.
-		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);	// Write I2C control:
-		// abort any I2C
-		// activity.
-		MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command
-		// upload
-		while ((RR7146(P_MC2) &amp; MC2_UPLD_IIC) == 0) ;	// and wait for
-		// upload to
-		// complete.
-
-		// Per SAA7146 data sheet, write to STATUS reg twice to reset all
-		// I2C error flags.
+    /* IsBoardRevA is a boolean that indicates whether the board is RevA.
+     *
+     * VERSION 2.01 CHANGE: REV A &amp; B BOARDS NOW SUPPORTED BY DYNAMIC
+     * EEPROM ADDRESS SELECTION.  Initialize the I2C interface, which
+     * is used to access the onboard serial EEPROM.  The EEPROM's I2C
+     * DeviceAddress is hardwired to a value that is dependent on the
+     * 626 board revision.  On all board revisions, the EEPROM stores
+     * TrimDAC calibration constants for analog I/O.  On RevB and
+     * higher boards, the DeviceAddress is hardwired to 0 to enable
+     * the EEPROM to also store the PCI SubVendorID and SubDeviceID;
+     * this is the address at which the SAA7146 expects a
+     * configuration EEPROM to reside.  On RevA boards, the EEPROM
+     * device address, which is hardwired to 4, prevents the SAA7146
+     * from retrieving PCI sub-IDs, so the SAA7146 uses its built-in
+     * default values, instead.
+     */
+
+		/*     devpriv-&gt;I2Cards= IsBoardRevA ? 0xA8 : 0xA0; // Set I2C EEPROM */
+		/*  DeviceType (0xA0) */
+		/*  and DeviceAddress&lt;&lt;1. */
+
+		devpriv-&gt;I2CAdrs = 0xA0;	/*  I2C device address for onboard */
+		/*  eeprom(revb) */
+
+		/*  Issue an I2C ABORT command to halt any I2C operation in */
+		/* progress and reset BUSY flag. */
+		WR7146(P_I2CSTAT, I2C_CLKSEL | I2C_ABORT);
+		/*  Write I2C control: abort any I2C activity. */
+		MC_ENABLE(P_MC2, MC2_UPLD_IIC);
+		/*  Invoke command  upload */
+		while ((RR7146(P_MC2) &amp; MC2_UPLD_IIC) == 0);
+		/*  and wait for upload to complete. */
+
+		/* Per SAA7146 data sheet, write to STATUS reg twice to
+		 * reset all  I2C error flags. */
 		for (i = 0; i &lt; 2; i++) {
-			WR7146(P_I2CSTAT, I2C_CLKSEL);	// Write I2C control: reset
-			// error flags.
-			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	// Invoke command upload
-			while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;	//   and wait for
-			//   upload to
-			//   complete.
+			WR7146(P_I2CSTAT, I2C_CLKSEL);
+			/*  Write I2C control: reset  error flags. */
+			MC_ENABLE(P_MC2, MC2_UPLD_IIC);	/*  Invoke command upload */
+			while (!MC_TEST(P_MC2, MC2_UPLD_IIC));
+			/* and wait for upload to complete. */
 		}
 
-		// Init audio interface functional attributes: set DAC/ADC serial
-		// clock rates, invert DAC serial clock so that DAC data setup
-		// times are satisfied, enable DAC serial clock out.
+		/* Init audio interface functional attributes: set DAC/ADC
+		 * serial clock rates, invert DAC serial clock so that
+		 * DAC data setup times are satisfied, enable DAC serial
+		 * clock out.
+		 */
+
 		WR7146(P_ACON2, ACON2_INIT);
 
-		// Set up TSL1 slot list, which is used to control the
-		// accumulation of ADC data: RSD1 = shift data in on SD1.  SIB_A1
-		// = store data uint8_t at next available location in FB BUFFER1
-		// register.
-		WR7146(P_TSL1, RSD1 | SIB_A1);	// Fetch ADC high data
-		// uint8_t.
-		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);	// Fetch ADC low data
-		// uint8_t; end of
-		// TSL1.
-
-		// enab TSL1 slot list so that it executes all the time.
+		/* Set up TSL1 slot list, which is used to control the
+		 * accumulation of ADC data: RSD1 = shift data in on SD1.
+		 * SIB_A1  = store data uint8_t at next available location in
+		 * FB BUFFER1  register. */
+		WR7146(P_TSL1, RSD1 | SIB_A1);
+		/*  Fetch ADC high data uint8_t. */
+		WR7146(P_TSL1 + 4, RSD1 | SIB_A1 | EOS);
+		/*  Fetch ADC low data uint8_t; end of TSL1. */
+
+		/*  enab TSL1 slot list so that it executes all the time. */
 		WR7146(P_ACON1, ACON1_ADCSTART);
 
-		// Initialize RPS registers used for ADC.
+		/*  Initialize RPS registers used for ADC. */
 
-		//Physical start of RPS program.
+		/* Physical start of RPS program. */
 		WR7146(P_RPSADDR1, (uint32_t) devpriv-&gt;RPSBuf.PhysicalBase);
 
-		WR7146(P_RPSPAGE1, 0);	// RPS program performs no
-		// explicit mem writes.
-		WR7146(P_RPS1_TOUT, 0);	// Disable RPS timeouts.
+		WR7146(P_RPSPAGE1, 0);
+		/*  RPS program performs no explicit mem writes. */
+		WR7146(P_RPS1_TOUT, 0);	/*  Disable RPS timeouts. */
 
-		// SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface to a
-		// known state by invoking ADCs until FB BUFFER 1 register shows
-		// that it is correctly receiving ADC data.  This is necessary
-		// because the SAA7146 ADC interface does not start up in a
-		// defined state after a PCI reset.
+		/* SAA7146 BUG WORKAROUND.  Initialize SAA7146 ADC interface
+		 * to a known state by invoking ADCs until FB BUFFER 1
+		 * register shows that it is correctly receiving ADC data.
+		 * This is necessary because the SAA7146 ADC interface does
+		 * not start up in a defined state after a PCI reset.
+		 */
 
 /*     PollList = EOPL;			// Create a simple polling */
 /* 					// list for analog input */
@@ -829,115 +819,123 @@ static int s626_attach(comedi_device * dev, comedi_devconfig * it)
 /* 	  break; */
 /*       } */
 
-		// end initADC
+		/*  end initADC */
 
-		// init the DAC interface
+		/*  init the DAC interface */
 
-		// Init Audio2's output DMAC attributes: burst length = 1 DWORD,
-		// threshold = 1 DWORD.
+		/* Init Audio2's output DMAC attributes: burst length = 1
+		 * DWORD,  threshold = 1 DWORD.
+		 */
 		WR7146(P_PCI_BT_A, 0);
 
-		// Init Audio2's output DMA physical addresses.  The protection
-		// address is set to 1 DWORD past the base address so that a
-		// single DWORD will be transferred each time a DMA transfer is
-		// enabled.
+		/* Init Audio2's output DMA physical addresses.  The protection
+		 * address is set to 1 DWORD past the base address so that a
+		 * single DWORD will be transferred each time a DMA transfer is
+		 * enabled. */
 
 		pPhysBuf =
 			devpriv-&gt;ANABuf.PhysicalBase +
 			(DAC_WDMABUF_OS * sizeof(uint32_t));
 
-		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	// Buffer base adrs.
-		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	// Protection address.
+		WR7146(P_BASEA2_OUT, (uint32_t) pPhysBuf);	/*  Buffer base adrs. */
+		WR7146(P_PROTA2_OUT, (uint32_t) (pPhysBuf + sizeof(uint32_t)));	/*  Protection address. */
 
-		// Cache Audio2's output DMA buffer logical address.  This is
-		// where DAC data is buffered for A2 output DMA transfers.
+		/* Cache Audio2's output DMA buffer logical address.  This is
+		 * where DAC data is buffered for A2 output DMA transfers. */
 		devpriv-&gt;pDacWBuf =
 			(uint32_t *) devpriv-&gt;ANABuf.LogicalBase +
 			DAC_WDMABUF_OS;
 
-		// Audio2's output channels does not use paging.  The protection
-		// violation handling bit is set so that the DMAC will
-		// automatically halt and its PCI address pointer will be reset
-		// when the protection address is reached.
+		/* Audio2's output channels does not use paging.  The protection
+		 * violation handling bit is set so that the DMAC will
+		 * automatically halt and its PCI address pointer will be reset
+		 * when the protection address is reached. */
+
 		WR7146(P_PAGEA2_OUT, 8);
 
-		// Initialize time slot list 2 (TSL2), which is used to control
-		// the clock generation for and serialization of data to be sent
-		// to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
-		// execution; this permits other slots to be safely modified
-		// without first turning off the TSL sequencer (which is
-		// apparently impossible to do).  Also, SD3 (which is driven by a
-		// pull-up resistor) is shifted in and stored to the MSB of
-		// FB_BUFFER2 to be used as evidence that the slot sequence has
-		// not yet finished executing.
-		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);	// Slot 0: Trap TSL
-		// execution, shift 0xFF
-		// into FB_BUFFER2.
-
-		// Initialize slot 1, which is constant.  Slot 1 causes a DWORD to
-		// be transferred from audio channel 2's output FIFO to the FIFO's
-		// output buffer so that it can be serialized and sent to the DAC
-		// during subsequent slots.  All remaining slots are dynamically
-		// populated as required by the target DAC device.
-		SETVECT(1, LF_A2);	// Slot 1: Fetch DWORD from Audio2's
-		// output FIFO.
-
-		// Start DAC's audio interface (TSL2) running.
+		/* Initialize time slot list 2 (TSL2), which is used to control
+		 * the clock generation for and serialization of data to be sent
+		 * to the DAC devices.  Slot 0 is a NOP that is used to trap TSL
+		 * execution; this permits other slots to be safely modified
+		 * without first turning off the TSL sequencer (which is
+		 * apparently impossible to do).  Also, SD3 (which is driven by a
+		 * pull-up resistor) is shifted in and stored to the MSB of
+		 * FB_BUFFER2 to be used as evidence that the slot sequence has
+		 * not yet finished executing.
+		 */
+
+		SETVECT(0, XSD2 | RSD3 | SIB_A2 | EOS);
+		/*  Slot 0: Trap TSL execution, shift 0xFF into FB_BUFFER2. */
+
+		/* Initialize slot 1, which is constant.  Slot 1 causes a
+		 * DWORD to be transferred from audio channel 2's output FIFO
+		 * to the FIFO's output buffer so that it can be serialized
+		 * and sent to the DAC during subsequent slots.  All remaining
+		 * slots are dynamically populated as required by the target
+		 * DAC device.
+		 */
+		SETVECT(1, LF_A2);
+		/*  Slot 1: Fetch DWORD from Audio2's output FIFO. */
+
+		/*  Start DAC's audio interface (TSL2) running. */
 		WR7146(P_ACON1, ACON1_DACSTART);
 
-		////////////////////////////////////////////////////////
-
-		// end init DAC interface
+		/* end init DAC interface */
 
-		// Init Trim DACs to calibrated values.  Do it twice because the
-		// SAA7146 audio channel does not always reset properly and
-		// sometimes causes the first few TrimDAC writes to malfunction.
+		/* Init Trim DACs to calibrated values.  Do it twice because the
+		 * SAA7146 audio channel does not always reset properly and
+		 * sometimes causes the first few TrimDAC writes to malfunction.
+		 */
 
 		LoadTrimDACs(dev);
-		LoadTrimDACs(dev);	// Insurance.
+		LoadTrimDACs(dev);	/*  Insurance. */
 
-		//////////////////////////////////////////////////////////////////
-		// Manually init all gate array hardware in case this is a soft
-		// reset (we have no way of determining whether this is a warm or
-		// cold start).  This is necessary because the gate array will
-		// reset only in response to a PCI hard reset; there is no soft
-		// reset function.
+		/* Manually init all gate array hardware in case this is a soft
+		 * reset (we have no way of determining whether this is a warm
+		 * or cold start).  This is necessary because the gate array will
+		 * reset only in response to a PCI hard reset; there is no soft
+		 * reset function. */
 
-		// Init all DAC outputs to 0V and init all DAC setpoint and
-		// polarity images.
+		/* Init all DAC outputs to 0V and init all DAC setpoint and
+		 * polarity images.
+		 */
 		for (chan = 0; chan &lt; S626_DAC_CHANNELS; chan++)
 			SetDAC(dev, chan, 0);
 
-		// Init image of WRMISC2 Battery Charger Enabled control bit.
-		// This image is used when the state of the charger control bit,
-		// which has no direct hardware readback mechanism, is queried.
+		/* Init image of WRMISC2 Battery Charger Enabled control bit.
+		 * This image is used when the state of the charger control bit,
+		 * which has no direct hardware readback mechanism, is queried.
+		 */
 		devpriv-&gt;ChargeEnabled = 0;
 
-		// Init image of watchdog timer interval in WRMISC2.  This image
-		// maintains the value of the control bits of MISC2 are
-		// continuously reset to zero as long as the WD timer is disabled.
+		/* Init image of watchdog timer interval in WRMISC2.  This image
+		 * maintains the value of the control bits of MISC2 are
+		 * continuously reset to zero as long as the WD timer is disabled.
+		 */
 		devpriv-&gt;WDInterval = 0;
 
-		// Init Counter Interrupt enab mask for RDMISC2.  This mask is
-		// applied against MISC2 when testing to determine which timer
-		// events are requesting interrupt service.
+		/* Init Counter Interrupt enab mask for RDMISC2.  This mask is
+		 * applied against MISC2 when testing to determine which timer
+		 * events are requesting interrupt service.
+		 */
 		devpriv-&gt;CounterIntEnabs = 0;
 
-		// Init counters.
+		/*  Init counters. */
 		CountersInit(dev);
 
-		// Without modifying the state of the Battery Backup enab, disable
-		// the watchdog timer, set DIO channels 0-5 to operate in the
-		// standard DIO (vs. counter overflow) mode, disable the battery
-		// charger, and reset the watchdog interval selector to zero.
+		/* Without modifying the state of the Battery Backup enab, disable
+		 * the watchdog timer, set DIO channels 0-5 to operate in the
+		 * standard DIO (vs. counter overflow) mode, disable the battery
+		 * charger, and reset the watchdog interval selector to zero.
+		 */
 		WriteMISC2(dev, (uint16_t) (DEBIread(dev,
 					LP_RDMISC2) &amp; MISC2_BATT_ENABLE));
 
-		// Initialize the digital I/O subsystem.
+		/*  Initialize the digital I/O subsystem. */
 		s626_dio_init(dev);
 
-		//enable interrupt test
-		// writel(IRQ_GPIO3 | IRQ_RPS1,devpriv-&gt;base_addr+P_IER);
+		/* enable interrupt test */
+		/*  writel(IRQ_GPIO3 | IRQ_RPS1,devpriv-&gt;base_addr+P_IER); */
 	}
 
 	DEBUG("s626_attach: comedi%d s626 attached %04x\n", dev-&gt;minor,
@@ -981,47 +979,48 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 
 	if (dev-&gt;attached == 0)
 		return IRQ_NONE;
-	// lock to avoid race with comedi_poll
+	/*  lock to avoid race with comedi_poll */
 	comedi_spin_lock_irqsave(&amp;dev-&gt;spinlock, flags);
 
-	//save interrupt enable register state
+	/* save interrupt enable register state */
 	irqstatus = readl(devpriv-&gt;base_addr + P_IER);
 
-	//read interrupt type
+	/* read interrupt type */
 	irqtype = readl(devpriv-&gt;base_addr + P_ISR);
 
-	//disable master interrupt
+	/* disable master interrupt */
 	writel(0, devpriv-&gt;base_addr + P_IER);
 
-	//clear interrupt
+	/* clear interrupt */
 	writel(irqtype, devpriv-&gt;base_addr + P_ISR);
 
-	//do somethings
+	/* do somethings */
 	DEBUG("s626_irq_handler: interrupt type %d\n", irqtype);
 
 	switch (irqtype) {
-	case IRQ_RPS1:		// end_of_scan occurs
+	case IRQ_RPS1:		/*  end_of_scan occurs */
 
 		DEBUG("s626_irq_handler: RPS1 irq detected\n");
 
-		// manage ai subdevice
+		/*  manage ai subdevice */
 		s = dev-&gt;subdevices;
 		cmd = &amp;(s-&gt;async-&gt;cmd);
 
-		// Init ptr to DMA buffer that holds new ADC data.  We skip the
-		// first uint16_t in the buffer because it contains junk data from
-		// the final ADC of the previous poll list scan.
+		/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+		 * first uint16_t in the buffer because it contains junk data from
+		 * the final ADC of the previous poll list scan.
+		 */
 		readaddr = (int32_t *) devpriv-&gt;ANABuf.LogicalBase + 1;
 
-		// get the data and hand it over to comedi
+		/*  get the data and hand it over to comedi */
 		for (i = 0; i &lt; (s-&gt;async-&gt;cmd.chanlist_len); i++) {
-			// Convert ADC data to 16-bit integer values and copy to application
-			// buffer.
+			/*  Convert ADC data to 16-bit integer values and copy to application */
+			/*  buffer. */
 			tempdata = s626_ai_reg_to_uint((int)*readaddr);
 			readaddr++;
 
-			//put data into read buffer
-			// comedi_buf_put(s-&gt;async, tempdata);
+			/* put data into read buffer */
+			/*  comedi_buf_put(s-&gt;async, tempdata); */
 			if (cfc_write_to_buffer(s, tempdata) == 0)
 				printk("s626_irq_handler: cfc_write_to_buffer error!\n");
 
@@ -1029,7 +1028,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 				i, tempdata);
 		}
 
-		//end of scan occurs
+		/* end of scan occurs */
 		s-&gt;async-&gt;events |= COMEDI_CB_EOS;
 
 		if (!(devpriv-&gt;ai_continous))
@@ -1037,13 +1036,13 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 		if (devpriv-&gt;ai_sample_count &lt;= 0) {
 			devpriv-&gt;ai_cmd_running = 0;
 
-			// Stop RPS program.
+			/*  Stop RPS program. */
 			MC_DISABLE(P_MC1, MC1_ERPS1);
 
-			//send end of acquisition
+			/* send end of acquisition */
 			s-&gt;async-&gt;events |= COMEDI_CB_EOA;
 
-			//disable master interrupt
+			/* disable master interrupt */
 			irqstatus = 0;
 		}
 
@@ -1054,40 +1053,40 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 
 			DEBUG("s626_irq_handler: External trigger is set!!!\n");
 		}
-		// tell comedi that data is there
+		/*  tell comedi that data is there */
 		DEBUG("s626_irq_handler: events %d\n", s-&gt;async-&gt;events);
 		comedi_event(dev, s);
 		break;
-	case IRQ_GPIO3:	//check dio and conter interrupt
+	case IRQ_GPIO3:	/* check dio and conter interrupt */
 
 		DEBUG("s626_irq_handler: GPIO3 irq detected\n");
 
-		// manage ai subdevice
+		/*  manage ai subdevice */
 		s = dev-&gt;subdevices;
 		cmd = &amp;(s-&gt;async-&gt;cmd);
 
-		//s626_dio_clear_irq(dev);
+		/* s626_dio_clear_irq(dev); */
 
 		for (group = 0; group &lt; S626_DIO_BANKS; group++) {
 			irqbit = 0;
-			//read interrupt type
+			/* read interrupt type */
 			irqbit = DEBIread(dev,
 				((dio_private *) (dev-&gt;subdevices + 2 +
 						group)-&gt;private)-&gt;RDCapFlg);
 
-			//check if interrupt is generated from dio channels
+			/* check if interrupt is generated from dio channels */
 			if (irqbit) {
 				s626_dio_reset_irq(dev, group, irqbit);
 				DEBUG("s626_irq_handler: check interrupt on dio group %d %d\n", group, i);
 				if (devpriv-&gt;ai_cmd_running) {
-					//check if interrupt is an ai acquisition start trigger
+					/* check if interrupt is an ai acquisition start trigger */
 					if ((irqbit &gt;&gt; (cmd-&gt;start_arg -
 								(16 * group)))
 						== 1
 						&amp;&amp; cmd-&gt;start_src == TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd-&gt;start_arg);
 
-						// Start executing the RPS program.
+						/*  Start executing the RPS program. */
 						MC_ENABLE(P_MC1, MC1_ERPS1);
 
 						DEBUG("s626_irq_handler: aquisition start triggered!!!\n");
@@ -1110,7 +1109,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 						TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd-&gt;scan_begin_arg);
 
-						// Trigger ADC scan loop start by setting RPS Signal 0.
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
 						DEBUG("s626_irq_handler: scan triggered!!! %d\n", devpriv-&gt;ai_sample_count);
@@ -1151,7 +1150,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 						TRIG_EXT) {
 						DEBUG("s626_irq_handler: Edge capture interrupt recieved from channel %d\n", cmd-&gt;convert_arg);
 
-						// Trigger ADC scan loop start by setting RPS Signal 0.
+						/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 						MC_ENABLE(P_MC2, MC2_ADC_RPS);
 
 						DEBUG("s626_irq_handler: adc convert triggered!!!\n");
@@ -1175,10 +1174,10 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 			}
 		}
 
-		//read interrupt type
+		/* read interrupt type */
 		irqbit = DEBIread(dev, LP_RDMISC2);
 
-		//check interrupt on counters
+		/* check interrupt on counters */
 		DEBUG("s626_irq_handler: check counters interrupt %d\n",
 			irqbit);
 
@@ -1186,35 +1185,35 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 			DEBUG("s626_irq_handler: interrupt on counter 1A overflow\n");
 			k = &amp;encpriv[0];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k-&gt;ResetCapFlags(dev, k);
 		}
 		if (irqbit &amp; IRQ_COINT2A) {
 			DEBUG("s626_irq_handler: interrupt on counter 2A overflow\n");
 			k = &amp;encpriv[1];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k-&gt;ResetCapFlags(dev, k);
 		}
 		if (irqbit &amp; IRQ_COINT3A) {
 			DEBUG("s626_irq_handler: interrupt on counter 3A overflow\n");
 			k = &amp;encpriv[2];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k-&gt;ResetCapFlags(dev, k);
 		}
 		if (irqbit &amp; IRQ_COINT1B) {
 			DEBUG("s626_irq_handler: interrupt on counter 1B overflow\n");
 			k = &amp;encpriv[3];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k-&gt;ResetCapFlags(dev, k);
 		}
 		if (irqbit &amp; IRQ_COINT2B) {
 			DEBUG("s626_irq_handler: interrupt on counter 2B overflow\n");
 			k = &amp;encpriv[4];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k-&gt;ResetCapFlags(dev, k);
 
 			if (devpriv-&gt;ai_convert_count &gt; 0) {
@@ -1225,7 +1224,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 				if (cmd-&gt;convert_src == TRIG_TIMER) {
 					DEBUG("s626_irq_handler: conver timer trigger!!! %d\n", devpriv-&gt;ai_convert_count);
 
-					// Trigger ADC scan loop start by setting RPS Signal 0.
+					/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 					MC_ENABLE(P_MC2, MC2_ADC_RPS);
 				}
 			}
@@ -1234,13 +1233,13 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 			DEBUG("s626_irq_handler: interrupt on counter 3B overflow\n");
 			k = &amp;encpriv[5];
 
-			//clear interrupt capture flag
+			/* clear interrupt capture flag */
 			k-&gt;ResetCapFlags(dev, k);
 
 			if (cmd-&gt;scan_begin_src == TRIG_TIMER) {
 				DEBUG("s626_irq_handler: scan timer trigger!!!\n");
 
-				// Trigger ADC scan loop start by setting RPS Signal 0.
+				/*  Trigger ADC scan loop start by setting RPS Signal 0. */
 				MC_ENABLE(P_MC2, MC2_ADC_RPS);
 			}
 
@@ -1253,7 +1252,7 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 		}
 	}
 
-	//enable interrupt
+	/* enable interrupt */
 	writel(irqstatus, devpriv-&gt;base_addr + P_IER);
 
 	DEBUG("s626_irq_handler: exit interrupt service routine.\n");
@@ -1265,18 +1264,18 @@ static irqreturn_t s626_irq_handler(int irq, void *d PT_REGS_ARG)
 static int s626_detach(comedi_device * dev)
 {
 	if (devpriv) {
-		//stop ai_command
+		/* stop ai_command */
 		devpriv-&gt;ai_cmd_running = 0;
 
 		if (devpriv-&gt;base_addr) {
-			//interrupt mask
-			WR7146(P_IER, 0);	// Disable master interrupt.
-			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	// Clear board's IRQ status flag.
+			/* interrupt mask */
+			WR7146(P_IER, 0);	/*  Disable master interrupt. */
+			WR7146(P_ISR, IRQ_GPIO3 | IRQ_RPS1);	/*  Clear board's IRQ status flag. */
 
-			// Disable the watchdog timer and battery charger.
+			/*  Disable the watchdog timer and battery charger. */
 			WriteMISC2(dev, 0);
 
-			// Close all interfaces on 7146 device.
+			/*  Close all interfaces on 7146 device. */
 			WR7146(P_MC1, MC1_SHUTDOWN);
 			WR7146(P_ACON1, ACON1_BASE);
 
@@ -1317,174 +1316,186 @@ void ResetADC(comedi_device * dev, uint8_t * ppl)
 	uint32_t LocalPPL;
 	comedi_cmd *cmd = &amp;(dev-&gt;subdevices-&gt;async-&gt;cmd);
 
-	// Stop RPS program in case it is currently running.
+	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	// Set starting logical address to write RPS commands.
+	/*  Set starting logical address to write RPS commands. */
 	pRPS = (uint32_t *) devpriv-&gt;RPSBuf.LogicalBase;
 
-	// Initialize RPS instruction pointer.
+	/*  Initialize RPS instruction pointer. */
 	WR7146(P_RPSADDR1, (uint32_t) devpriv-&gt;RPSBuf.PhysicalBase);
 
-	// Construct RPS program in RPSBuf DMA buffer
+	/*  Construct RPS program in RPSBuf DMA buffer */
 
 	if (cmd != NULL &amp;&amp; cmd-&gt;scan_begin_src != TRIG_FOLLOW) {
 		DEBUG("ResetADC: scan_begin pause inserted\n");
-		// Wait for Start trigger.
+		/*  Wait for Start trigger. */
 		*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 		*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 	}
-	// SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
-	// because the first RPS DEBI Write following a non-RPS DEBI write
-	// seems to always fail.  If we don't do this dummy write, the ADC
-	// gain might not be set to the value required for the first slot in
-	// the poll list; the ADC gain would instead remain unchanged from
-	// the previously programmed value.
-	*pRPS++ = RPS_LDREG | (P_DEBICMD &gt;&gt; 2);	// Write DEBI Write command
-	// and address to shadow RAM.
+
+	/* SAA7146 BUG WORKAROUND Do a dummy DEBI Write.  This is necessary
+	 * because the first RPS DEBI Write following a non-RPS DEBI write
+	 * seems to always fail.  If we don't do this dummy write, the ADC
+	 * gain might not be set to the value required for the first slot in
+	 * the poll list; the ADC gain would instead remain unchanged from
+	 * the previously programmed value.
+	 */
+	*pRPS++ = RPS_LDREG | (P_DEBICMD &gt;&gt; 2);
+	/* Write DEBI Write command and address to shadow RAM. */
+
 	*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-	*pRPS++ = RPS_LDREG | (P_DEBIAD &gt;&gt; 2);	// Write DEBI immediate data
-	// to shadow RAM:
-	*pRPS++ = GSEL_BIPOLAR5V;	// arbitrary immediate data
-	// value.
-	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM
-	// uploaded" flag.
-	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-	*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to finish.
-
-	// Digitize all slots in the poll list. This is implemented as a
-	// for loop to limit the slot count to 16 in case the application
-	// forgot to set the EOPL flag in the final slot.
+	*pRPS++ = RPS_LDREG | (P_DEBIAD &gt;&gt; 2);
+	/*  Write DEBI immediate data  to shadow RAM: */
+
+	*pRPS++ = GSEL_BIPOLAR5V;
+	/*  arbitrary immediate data  value. */
+
+	*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+	/*  Reset "shadow RAM  uploaded" flag. */
+	*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+	*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to finish. */
+
+	/* Digitize all slots in the poll list. This is implemented as a
+	 * for loop to limit the slot count to 16 in case the application
+	 * forgot to set the EOPL flag in the final slot.
+	 */
 	for (devpriv-&gt;AdcItems = 0; devpriv-&gt;AdcItems &lt; 16; devpriv-&gt;AdcItems++) {
-		// Convert application's poll list item to private board class
-		// format.  Each app poll list item is an uint8_t with form
-		// (EOPL,x,x,RANGE,CHAN&lt;3:0&gt;), where RANGE code indicates 0 =
-		// +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+	 /* Convert application's poll list item to private board class
+	  * format.  Each app poll list item is an uint8_t with form
+	  * (EOPL,x,x,RANGE,CHAN&lt;3:0&gt;), where RANGE code indicates 0 =
+	  * +-10V, 1 = +-5V, and EOPL = End of Poll List marker.
+	  */
 		LocalPPL =
 			(*ppl &lt;&lt; 8) | (*ppl &amp; 0x10 ? GSEL_BIPOLAR5V :
 			GSEL_BIPOLAR10V);
 
-		// Switch ADC analog gain.
-		*pRPS++ = RPS_LDREG | (P_DEBICMD &gt;&gt; 2);	// Write DEBI command
-		// and address to
-		// shadow RAM.
+		/*  Switch ADC analog gain. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD &gt;&gt; 2);	/*  Write DEBI command */
+		/*  and address to */
+		/*  shadow RAM. */
 		*pRPS++ = DEBI_CMD_WRWORD | LP_GSEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD &gt;&gt; 2);	// Write DEBI
-		// immediate data to
-		// shadow RAM.
+		*pRPS++ = RPS_LDREG | (P_DEBIAD &gt;&gt; 2);	/*  Write DEBI */
+		/*  immediate data to */
+		/*  shadow RAM. */
 		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
-		// flag.
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
-		// finish.
-
-		// Select ADC analog input channel.
-		*pRPS++ = RPS_LDREG | (P_DEBICMD &gt;&gt; 2);	// Write DEBI command
-		// and address to
-		// shadow RAM.
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	/*  Reset "shadow RAM uploaded" */
+		/*  flag. */
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	/*  Invoke shadow RAM upload. */
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;	/*  Wait for shadow upload to */
+		/*  finish. */
+
+		/*  Select ADC analog input channel. */
+		*pRPS++ = RPS_LDREG | (P_DEBICMD &gt;&gt; 2);
+		/*  Write DEBI command and address to  shadow RAM. */
 		*pRPS++ = DEBI_CMD_WRWORD | LP_ISEL;
-		*pRPS++ = RPS_LDREG | (P_DEBIAD &gt;&gt; 2);	// Write DEBI
-		// immediate data to
-		// shadow RAM.
+		*pRPS++ = RPS_LDREG | (P_DEBIAD &gt;&gt; 2);
+		/*  Write DEBI immediate data to shadow RAM. */
 		*pRPS++ = LocalPPL;
-		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;	// Reset "shadow RAM uploaded"
-		// flag.
-		*pRPS++ = RPS_UPLOAD | RPS_DEBI;	// Invoke shadow RAM upload.
-		*pRPS++ = RPS_PAUSE | RPS_DEBI;	// Wait for shadow upload to
-		// finish.
-
-		// Delay at least 10 microseconds for analog input settling.
-		// Instead of padding with NOPs, we use RPS_JUMP instructions
-		// here; this allows us to produce a longer delay than is
-		// possible with NOPs because each RPS_JUMP flushes the RPS'
-		// instruction prefetch pipeline.
+		*pRPS++ = RPS_CLRSIGNAL | RPS_DEBI;
+		/*  Reset "shadow RAM uploaded"  flag. */
+
+		*pRPS++ = RPS_UPLOAD | RPS_DEBI;
+		/*  Invoke shadow RAM upload. */
+
+		*pRPS++ = RPS_PAUSE | RPS_DEBI;
+		/*  Wait for shadow upload to finish. */
+
+		/* Delay at least 10 microseconds for analog input settling.
+		 * Instead of padding with NOPs, we use RPS_JUMP instructions
+		 * here; this allows us to produce a longer delay than is
+		 * possible with NOPs because each RPS_JUMP flushes the RPS'
+		 * instruction prefetch pipeline.
+		 */
 		JmpAdrs =
 			(uint32_t) devpriv-&gt;RPSBuf.PhysicalBase +
 			(uint32_t) ((unsigned long)pRPS -
 			(unsigned long)devpriv-&gt;RPSBuf.LogicalBase);
 		for (i = 0; i &lt; (10 * RPSCLK_PER_US / 2); i++) {
-			JmpAdrs += 8;	// Repeat to implement time delay:
-			*pRPS++ = RPS_JUMP;	// Jump to next RPS instruction.
+			JmpAdrs += 8;	/*  Repeat to implement time delay: */
+			*pRPS++ = RPS_JUMP;	/*  Jump to next RPS instruction. */
 			*pRPS++ = JmpAdrs;
 		}
 
 		if (cmd != NULL &amp;&amp; cmd-&gt;convert_src != TRIG_NOW) {
 			DEBUG("ResetADC: convert pause inserted\n");
-			// Wait for Start trigger.
+			/*  Wait for Start trigger. */
 			*pRPS++ = RPS_PAUSE | RPS_SIGADC;
 			*pRPS++ = RPS_CLRSIGNAL | RPS_SIGADC;
 		}
-		// Start ADC by pulsing GPIO1.
-		*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	// Begin ADC Start pulse.
+		/*  Start ADC by pulsing GPIO1. */
+		*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	/*  Begin ADC Start pulse. */
 		*pRPS++ = GPIO_BASE | GPIO1_LO;
 		*pRPS++ = RPS_NOP;
-		// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
-		*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	// End ADC Start pulse.
+		/*  VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+		*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	/*  End ADC Start pulse. */
 		*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-		// Wait for ADC to complete (GPIO2 is asserted high when ADC not
-		// busy) and for data from previous conversion to shift into FB
-		// BUFFER 1 register.
-		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+		/* Wait for ADC to complete (GPIO2 is asserted high when ADC not
+		 * busy) and for data from previous conversion to shift into FB
+		 * BUFFER 1 register.
+		 */
+		*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-		// Transfer ADC data from FB BUFFER 1 register to DMA buffer.
+		/*  Transfer ADC data from FB BUFFER 1 register to DMA buffer. */
 		*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) &gt;&gt; 2);
 		*pRPS++ =
 			(uint32_t) devpriv-&gt;ANABuf.PhysicalBase +
 			(devpriv-&gt;AdcItems &lt;&lt; 2);
 
-		// If this slot's EndOfPollList flag is set, all channels have
-		// now been processed.
+		/*  If this slot's EndOfPollList flag is set, all channels have */
+		/*  now been processed. */
 		if (*ppl++ &amp; EOPL) {
-			devpriv-&gt;AdcItems++;	// Adjust poll list item count.
-			break;	// Exit poll list processing loop.
+			devpriv-&gt;AdcItems++;	/*  Adjust poll list item count. */
+			break;	/*  Exit poll list processing loop. */
 		}
 	}
 	DEBUG("ResetADC: ADC items %d \n", devpriv-&gt;AdcItems);
 
-	// VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
-	// ADC to stabilize for 2 microseconds before starting the final
-	// (dummy) conversion.  This delay is necessary to allow sufficient
-	// time between last conversion finished and the start of the dummy
-	// conversion.  Without this delay, the last conversion's data value
-	// is sometimes set to the previous conversion's data value.
+	/* VERSION 2.01 CHANGE: DELAY CHANGED FROM 250NS to 2US.  Allow the
+	 * ADC to stabilize for 2 microseconds before starting the final
+	 * (dummy) conversion.  This delay is necessary to allow sufficient
+	 * time between last conversion finished and the start of the dummy
+	 * conversion.  Without this delay, the last conversion's data value
+	 * is sometimes set to the previous conversion's data value.
+	 */
 	for (n = 0; n &lt; (2 * RPSCLK_PER_US); n++)
 		*pRPS++ = RPS_NOP;
 
-	// Start a dummy conversion to cause the data from the last
-	// conversion of interest to be shifted in.
-	*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	// Begin ADC Start pulse.
+	/* Start a dummy conversion to cause the data from the last
+	 * conversion of interest to be shifted in.
+	 */
+	*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	/*  Begin ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_LO;
 	*pRPS++ = RPS_NOP;
-	// VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE.
-	*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	// End ADC Start pulse.
+	/* VERSION 2.03 CHANGE: STRETCH OUT ADC START PULSE. */
+	*pRPS++ = RPS_LDREG | (P_GPIO &gt;&gt; 2);	/*  End ADC Start pulse. */
 	*pRPS++ = GPIO_BASE | GPIO1_HI;
 
-	// Wait for the data from the last conversion of interest to arrive
-	// in FB BUFFER 1 register.
-	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	// Wait for ADC done.
+	/* Wait for the data from the last conversion of interest to arrive
+	 * in FB BUFFER 1 register.
+	 */
+	*pRPS++ = RPS_PAUSE | RPS_GPIO2;	/*  Wait for ADC done. */
 
-	// Transfer final ADC data from FB BUFFER 1 register to DMA buffer.
-	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) &gt;&gt; 2);	//
+	/*  Transfer final ADC data from FB BUFFER 1 register to DMA buffer. */
+	*pRPS++ = RPS_STREG | (BUGFIX_STREG(P_FB_BUFFER1) &gt;&gt; 2);	/*  */
 	*pRPS++ =
 		(uint32_t) devpriv-&gt;ANABuf.PhysicalBase +
 		(devpriv-&gt;AdcItems &lt;&lt; 2);
 
-	// Indicate ADC scan loop is finished.
-	// *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done.
+	/*  Indicate ADC scan loop is finished. */
+	/*  *pRPS++= RPS_CLRSIGNAL | RPS_SIGADC ;  // Signal ReadADC() that scan is done. */
 
-	//invoke interrupt
+	/* invoke interrupt */
 	if (devpriv-&gt;ai_cmd_running == 1) {
 		DEBUG("ResetADC: insert irq in ADC RPS task\n");
 		*pRPS++ = RPS_IRQ;
 	}
-	// Restart RPS program at its beginning.
-	*pRPS++ = RPS_JUMP;	// Branch to start of RPS program.
+	/*  Restart RPS program at its beginning. */
+	*pRPS++ = RPS_JUMP;	/*  Branch to start of RPS program. */
 	*pRPS++ = (uint32_t) devpriv-&gt;RPSBuf.PhysicalBase;
 
-	// End of RPS program build
-	// ------------------------------------------------------------
+	/*  End of RPS program build */
 }
 
 /* TO COMPLETE, IF NECESSARY */
@@ -1502,19 +1513,19 @@ static int s626_ai_insn_config(comedi_device * dev, comedi_subdevice * s,
 
 /*   DEBUG("as626_ai_rinsn: ai_rinsn enter \n");  */
 
-/*   // Trigger ADC scan loop start by setting RPS Signal 0. */
+/*   Trigger ADC scan loop start by setting RPS Signal 0. */
 /*   MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-/*   // Wait until ADC scan loop is finished (RPS Signal 0 reset). */
+/*   Wait until ADC scan loop is finished (RPS Signal 0 reset). */
 /*   while ( MC_TEST( P_MC2, MC2_ADC_RPS ) ); */
 
-/*   // Init ptr to DMA buffer that holds new ADC data.  We skip the */
-/*   // first uint16_t in the buffer because it contains junk data from */
-/*   // the final ADC of the previous poll list scan. */
+/* Init ptr to DMA buffer that holds new ADC data.  We skip the
+ * first uint16_t in the buffer because it contains junk data from
+ * the final ADC of the previous poll list scan.
+ */
 /*   readaddr = (uint32_t *)devpriv-&gt;ANABuf.LogicalBase + 1; */
 
-/*   // Convert ADC data to 16-bit integer values and copy to application */
-/*   // buffer.	 */
+/*  Convert ADC data to 16-bit integer values and copy to application buffer. */
 /*   for ( i = 0; i &lt; devpriv-&gt;AdcItems; i++ ) { */
 /*     *data = s626_ai_reg_to_uint( *readaddr++ ); */
 /*     DEBUG("s626_ai_rinsn: data %d \n",*data); */
@@ -1534,86 +1545,85 @@ static int s626_ai_insn_read(comedi_device * dev, comedi_subdevice * s,
 	uint32_t GpioImage;
 	int n;
 
-/*   //interrupt call test  */
-/*   writel(IRQ_GPIO3,devpriv-&gt;base_addr+P_PSR); //Writing a logical 1 */
-/* 					     //into any of the RPS_PSR */
-/* 					     //bits causes the */
-/* 					     //corresponding interrupt */
-/* 					     //to be generated if */
-/* 					     //enabled */
+ /* interrupt call test  */
+/*   writel(IRQ_GPIO3,devpriv-&gt;base_addr+P_PSR); */
+	/* Writing a logical 1 into any of the RPS_PSR bits causes the
+	 * corresponding interrupt to be generated if enabled
+	 */
 
 	DEBUG("s626_ai_insn_read: entering\n");
 
-	// Convert application's ADC specification into form
-	// appropriate for register programming.
+	/* Convert application's ADC specification into form
+	 *  appropriate for register programming.
+	 */
 	if (range == 0)
 		AdcSpec = (chan &lt;&lt; 8) | (GSEL_BIPOLAR5V);
 	else
 		AdcSpec = (chan &lt;&lt; 8) | (GSEL_BIPOLAR10V);
 
-	// Switch ADC analog gain.
-	DEBIwrite(dev, LP_GSEL, AdcSpec);	// Set gain.
+	/*  Switch ADC analog gain. */
+	DEBIwrite(dev, LP_GSEL, AdcSpec);	/*  Set gain. */
 
-	// Select ADC analog input channel.
-	DEBIwrite(dev, LP_ISEL, AdcSpec);	// Select channel.
+	/*  Select ADC analog input channel. */
+	DEBIwrite(dev, LP_ISEL, AdcSpec);	/*  Select channel. */
 
 	for (n = 0; n &lt; insn-&gt;n; n++) {
 
-		// Delay 10 microseconds for analog input settling.
+		/*  Delay 10 microseconds for analog input settling. */
 		comedi_udelay(10);
 
-		// Start ADC by pulsing GPIO1 low.
+		/*  Start ADC by pulsing GPIO1 low. */
 		GpioImage = RR7146(P_GPIO);
-		// Assert ADC Start command
+		/*  Assert ADC Start command */
 		WR7146(P_GPIO, GpioImage &amp; ~GPIO1_HI);
-		//   and stretch it out.
+		/*    and stretch it out. */
 		WR7146(P_GPIO, GpioImage &amp; ~GPIO1_HI);
 		WR7146(P_GPIO, GpioImage &amp; ~GPIO1_HI);
-		// Negate ADC Start command.
+		/*  Negate ADC Start command. */
 		WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-		// Wait for ADC to complete (GPIO2 is asserted high when
-		// ADC not busy) and for data from previous conversion to
-		// shift into FB BUFFER 1 register.
+		/*  Wait for ADC to complete (GPIO2 is asserted high when */
+		/*  ADC not busy) and for data from previous conversion to */
+		/*  shift into FB BUFFER 1 register. */
 
-		// Wait for ADC done.
+		/*  Wait for ADC done. */
 		while (!(RR7146(P_PSR) &amp; PSR_GPIO2)) ;
 
-		// Fetch ADC data.
+		/*  Fetch ADC data. */
 		if (n != 0)
 			data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
-		// Allow the ADC to stabilize for 4 microseconds before
-		// starting the next (final) conversion.  This delay is
-		// necessary to allow sufficient time between last
-		// conversion finished and the start of the next
-		// conversion.  Without this delay, the last conversion's
-		// data value is sometimes set to the previous
-		// conversion's data value.
+		/* Allow the ADC to stabilize for 4 microseconds before
+		 * starting the next (final) conversion.  This delay is
+		 * necessary to allow sufficient time between last
+		 * conversion finished and the start of the next
+		 * conversion.  Without this delay, the last conversion's
+		 * data value is sometimes set to the previous
+		 * conversion's data value.
+		 */
 		comedi_udelay(4);
 	}
 
-	// Start a dummy conversion to cause the data from the
-	// previous conversion to be shifted in.
+	/* Start a dummy conversion to cause the data from the
+	 * previous conversion to be shifted in. */
 	GpioImage = RR7146(P_GPIO);
 
-	//Assert ADC Start command
+	/* Assert ADC Start command */
 	WR7146(P_GPIO, GpioImage &amp; ~GPIO1_HI);
-	//   and stretch it out.
+	/*    and stretch it out. */
 	WR7146(P_GPIO, GpioImage &amp; ~GPIO1_HI);
 	WR7146(P_GPIO, GpioImage &amp; ~GPIO1_HI);
-	// Negate ADC Start command.
+	/*  Negate ADC Start command. */
 	WR7146(P_GPIO, GpioImage | GPIO1_HI);
 
-	// Wait for the data to arrive in FB BUFFER 1 register.
+	/*  Wait for the data to arrive in FB BUFFER 1 register. */
 
-	// Wait for ADC done.
+	/*  Wait for ADC done. */
 	while (!(RR7146(P_PSR) &amp; PSR_GPIO2)) ;
 
-	// Fetch ADC data from audio interface's input shift
-	// register.
+	/*  Fetch ADC data from audio interface's input shift register. */
 
-	// Fetch ADC data.
+	/*  Fetch ADC data. */
 	if (n != 0)
 		data[n - 1] = s626_ai_reg_to_uint(RR7146(P_FB_BUFFER1));
 
@@ -1646,7 +1656,7 @@ static int s626_ai_inttrig(comedi_device * dev, comedi_subdevice * s,
 
 	DEBUG("s626_ai_inttrig: trigger adc start...");
 
-	// Start executing the RPS program.
+	/*  Start executing the RPS program. */
 	MC_ENABLE(P_MC1, MC1_ERPS1);
 
 	s-&gt;async-&gt;inttrig = NULL;
@@ -1672,20 +1682,20 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 			dev-&gt;minor);
 		return -EBUSY;
 	}
-	//disable interrupt
+	/* disable interrupt */
 	writel(0, devpriv-&gt;base_addr + P_IER);
 
-	//clear interrupt request
+	/* clear interrupt request */
 	writel(IRQ_RPS1 | IRQ_GPIO3, devpriv-&gt;base_addr + P_ISR);
 
-	//clear any pending interrupt
+	/* clear any pending interrupt */
 	s626_dio_clear_irq(dev);
-	//  s626_enc_clear_irq(dev);
+	/*   s626_enc_clear_irq(dev); */
 
-	//reset ai_cmd_running flag
+	/* reset ai_cmd_running flag */
 	devpriv-&gt;ai_cmd_running = 0;
 
-	// test if cmd is valid
+	/*  test if cmd is valid */
 	if (cmd == NULL) {
 		DEBUG("s626_ai_cmd: NULL command\n");
 		return -EINVAL;
@@ -1707,12 +1717,12 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	case TRIG_FOLLOW:
 		break;
 	case TRIG_TIMER:
-		// set a conter to generate adc trigger at scan_begin_arg interval
+		/*  set a conter to generate adc trigger at scan_begin_arg interval */
 		k = &amp;encpriv[5];
 		tick = s626_ns_to_timer((int *)&amp;cmd-&gt;scan_begin_arg,
 			cmd-&gt;flags &amp; TRIG_ROUND_MASK);
 
-		//load timer value and enable interrupt
+		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k-&gt;SetEnable(dev, k, CLKENAB_ALWAYS);
 
@@ -1721,7 +1731,7 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 		break;
 	case TRIG_EXT:
-		// set the digital line and interrupt for scan trigger
+		/*  set the digital line and interrupt for scan trigger */
 		if (cmd-&gt;start_src != TRIG_EXT)
 			s626_dio_set_irq(dev, cmd-&gt;scan_begin_arg);
 
@@ -1734,19 +1744,19 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 	case TRIG_NOW:
 		break;
 	case TRIG_TIMER:
-		// set a conter to generate adc trigger at convert_arg interval
+		/*  set a conter to generate adc trigger at convert_arg interval */
 		k = &amp;encpriv[4];
 		tick = s626_ns_to_timer((int *)&amp;cmd-&gt;convert_arg,
 			cmd-&gt;flags &amp; TRIG_ROUND_MASK);
 
-		//load timer value and enable interrupt
+		/* load timer value and enable interrupt */
 		s626_timer_load(dev, k, tick);
 		k-&gt;SetEnable(dev, k, CLKENAB_INDEX);
 
 		DEBUG("s626_ai_cmd: convert trigger timer is set with value %d\n", tick);
 		break;
 	case TRIG_EXT:
-		// set the digital line and interrupt for convert trigger
+		/*  set the digital line and interrupt for convert trigger */
 		if (cmd-&gt;scan_begin_src != TRIG_EXT
 			&amp;&amp; cmd-&gt;start_src == TRIG_EXT)
 			s626_dio_set_irq(dev, cmd-&gt;convert_arg);
@@ -1758,12 +1768,12 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 	switch (cmd-&gt;stop_src) {
 	case TRIG_COUNT:
-		// data arrives as one packet
+		/*  data arrives as one packet */
 		devpriv-&gt;ai_sample_count = cmd-&gt;stop_arg;
 		devpriv-&gt;ai_continous = 0;
 		break;
 	case TRIG_NONE:
-		// continous aquisition
+		/*  continous aquisition */
 		devpriv-&gt;ai_continous = 1;
 		devpriv-&gt;ai_sample_count = 0;
 		break;
@@ -1773,17 +1783,17 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 
 	switch (cmd-&gt;start_src) {
 	case TRIG_NOW:
-		// Trigger ADC scan loop start by setting RPS Signal 0.
-		// MC_ENABLE( P_MC2, MC2_ADC_RPS );
+		/*  Trigger ADC scan loop start by setting RPS Signal 0. */
+		/*  MC_ENABLE( P_MC2, MC2_ADC_RPS ); */
 
-		// Start executing the RPS program.
+		/*  Start executing the RPS program. */
 		MC_ENABLE(P_MC1, MC1_ERPS1);
 
 		DEBUG("s626_ai_cmd: ADC triggered\n");
 		s-&gt;async-&gt;inttrig = NULL;
 		break;
 	case TRIG_EXT:
-		//configure DIO channel for acquisition trigger
+		/* configure DIO channel for acquisition trigger */
 		s626_dio_set_irq(dev, cmd-&gt;start_arg);
 
 		DEBUG("s626_ai_cmd: External start trigger is set!!!\n");
@@ -1795,7 +1805,7 @@ static int s626_ai_cmd(comedi_device * dev, comedi_subdevice * s)
 		break;
 	}
 
-	//enable interrupt
+	/* enable interrupt */
 	writel(IRQ_GPIO3 | IRQ_RPS1, devpriv-&gt;base_addr + P_IER);
 
 	DEBUG("s626_ai_cmd: command function terminated\n");
@@ -1990,10 +2000,10 @@ static int s626_ai_cmdtest(comedi_device * dev, comedi_subdevice * s,
 
 static int s626_ai_cancel(comedi_device * dev, comedi_subdevice * s)
 {
-	// Stop RPS program in case it is currently running.
+	/*  Stop RPS program in case it is currently running. */
 	MC_DISABLE(P_MC1, MC1_ERPS1);
 
-	//disable master interrupt
+	/* disable master interrupt */
 	writel(0, devpriv-&gt;base_addr + P_IER);
 
 	devpriv-&gt;ai_cmd_running = 0;
@@ -2010,7 +2020,7 @@ static int s626_ns_to_timer(int *nanosec, int round_mode)
 {
 	int divider, base;
 
-	base = 500;		//2MHz internal clock
+	base = 500;		/* 2MHz internal clock */
 
 	switch (round_mode) {
 	case TRIG_ROUND_NEAREST:
@@ -2060,33 +2070,31 @@ static int s626_ao_rinsn(comedi_device * dev, comedi_subdevice * s,
 	return i;
 }
 
-/////////////////////////////////////////////////////////////////////
-///////////////  DIGITAL I/O FUNCTIONS  /////////////////////////////
-/////////////////////////////////////////////////////////////////////
-// All DIO functions address a group of DIO channels by means of
-// "group" argument.  group may be 0, 1 or 2, which correspond to DIO
-// ports A, B and C, respectively.
-/////////////////////////////////////////////////////////////////////
+/* *************** DIGITAL I/O FUNCTIONS ***************
+ * All DIO functions address a group of DIO channels by means of
+ * "group" argument.  group may be 0, 1 or 2, which correspond to DIO
+ * ports A, B and C, respectively.
+ */
 
 static void s626_dio_init(comedi_device * dev)
 {
 	uint16_t group;
 	comedi_subdevice *s;
 
-	// Prepare to treat writes to WRCapSel as capture disables.
+	/*  Prepare to treat writes to WRCapSel as capture disables. */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	// For each group of sixteen channels ...
+	/*  For each group of sixteen channels ... */
 	for (group = 0; group &lt; S626_DIO_BANKS; group++) {
 		s = dev-&gt;subdevices + 2 + group;
-		DEBIwrite(dev, diopriv-&gt;WRIntSel, 0);	// Disable all interrupts.
-		DEBIwrite(dev, diopriv-&gt;WRCapSel, 0xFFFF);	// Disable all event
-		// captures.
-		DEBIwrite(dev, diopriv-&gt;WREdgSel, 0);	// Init all DIOs to
-		// default edge
-		// polarity.
-		DEBIwrite(dev, diopriv-&gt;WRDOut, 0);	// Program all outputs
-		// to inactive state.
+		DEBIwrite(dev, diopriv-&gt;WRIntSel, 0);	/*  Disable all interrupts. */
+		DEBIwrite(dev, diopriv-&gt;WRCapSel, 0xFFFF);	/*  Disable all event */
+		/*  captures. */
+		DEBIwrite(dev, diopriv-&gt;WREdgSel, 0);	/*  Init all DIOs to */
+		/*  default edge */
+		/*  polarity. */
+		DEBIwrite(dev, diopriv-&gt;WRDOut, 0);	/*  Program all outputs */
+		/*  to inactive state. */
 	}
 	DEBUG("s626_dio_init: DIO initialized \n");
 }
@@ -2166,13 +2174,13 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 	unsigned int bitmask;
 	unsigned int status;
 
-	//select dio bank
+	/* select dio bank */
 	group = chan / 16;
 	bitmask = 1 &lt;&lt; (chan - (16 * group));
 	DEBUG("s626_dio_set_irq: enable interrupt on dio channel %d group %d\n",
 		chan - (16 * group), group);
 
-	//set channel to capture positive edge
+	/* set channel to capture positive edge */
 	status = DEBIread(dev,
 		((dio_private *) (dev-&gt;subdevices + 2 +
 				group)-&gt;private)-&gt;RDEdgSel);
@@ -2180,7 +2188,7 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 		((dio_private *) (dev-&gt;subdevices + 2 +
 				group)-&gt;private)-&gt;WREdgSel, bitmask | status);
 
-	//enable interrupt on selected channel
+	/* enable interrupt on selected channel */
 	status = DEBIread(dev,
 		((dio_private *) (dev-&gt;subdevices + 2 +
 				group)-&gt;private)-&gt;RDIntSel);
@@ -2188,10 +2196,10 @@ static int s626_dio_set_irq(comedi_device * dev, unsigned int chan)
 		((dio_private *) (dev-&gt;subdevices + 2 +
 				group)-&gt;private)-&gt;WRIntSel, bitmask | status);
 
-	//enable edge capture write command
+	/* enable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_EDCAP);
 
-	//enable edge capture on selected channel
+	/* enable edge capture on selected channel */
 	status = DEBIread(dev,
 		((dio_private *) (dev-&gt;subdevices + 2 +
 				group)-&gt;private)-&gt;RDCapSel);
@@ -2207,10 +2215,10 @@ static int s626_dio_reset_irq(comedi_device * dev, unsigned int group,
 {
 	DEBUG("s626_dio_reset_irq: disable  interrupt on dio channel %d group %d\n", mask, group);
 
-	//disable edge capture write command
+	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
-	//enable edge capture on selected channel
+	/* enable edge capture on selected channel */
 	DEBIwrite(dev,
 		((dio_private *) (dev-&gt;subdevices + 2 +
 				group)-&gt;private)-&gt;WRCapSel, mask);
@@ -2222,11 +2230,11 @@ static int s626_dio_clear_irq(comedi_device * dev)
 {
 	unsigned int group;
 
-	//disable edge capture write command
+	/* disable edge capture write command */
 	DEBIwrite(dev, LP_MISC1, MISC1_NOEDCAP);
 
 	for (group = 0; group &lt; S626_DIO_BANKS; group++) {
-		//clear pending events and interrupt
+		/* clear pending events and interrupt */
 		DEBIwrite(dev,
 			((dio_private *) (dev-&gt;subdevices + 2 +
 					group)-&gt;private)-&gt;WRCapSel, 0xffff);
@@ -2241,23 +2249,23 @@ static int s626_dio_clear_irq(comedi_device * dev)
 static int s626_enc_insn_config(comedi_device * dev, comedi_subdevice * s,
 	comedi_insn * insn, lsampl_t * data)
 {
-	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT &lt;&lt; BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_COUNTER &lt;&lt; BF_CLKSRC) |	// Operating mode is Counter.
-		(CLKPOL_POS &lt;&lt; BF_CLKPOL) |	// Active high clock.
-		//( CNTDIR_UP &lt;&lt; BF_CLKPOL ) |      // Count direction is Down.
-		(CLKMULT_1X &lt;&lt; BF_CLKMULT) |	// Clock multiplier is 1x.
+	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT &lt;&lt; BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_COUNTER &lt;&lt; BF_CLKSRC) |	/*  Operating mode is Counter. */
+		(CLKPOL_POS &lt;&lt; BF_CLKPOL) |	/*  Active high clock. */
+		/* ( CNTDIR_UP &lt;&lt; BF_CLKPOL ) |      // Count direction is Down. */
+		(CLKMULT_1X &lt;&lt; BF_CLKMULT) |	/*  Clock multiplier is 1x. */
 		(CLKENAB_INDEX &lt;&lt; BF_CLKENAB);
 	/*   uint16_t DisableIntSrc=TRUE; */
-	// uint32_t Preloadvalue;              //Counter initial value
+	/*  uint32_t Preloadvalue;              //Counter initial value */
 	uint16_t valueSrclatch = LATCHSRC_AB_READ;
 	uint16_t enab = CLKENAB_ALWAYS;
 	enc_private *k = &amp;encpriv[CR_CHAN(insn-&gt;chanspec)];
 
 	DEBUG("s626_enc_insn_config: encoder config\n");
 
-	//  (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]);
+	/*   (data==NULL) ? (Preloadvalue=0) : (Preloadvalue=data[0]); */
 
 	k-&gt;SetMode(dev, k, Setup, TRUE);
 	Preload(dev, k, *(insn-&gt;data));
@@ -2295,11 +2303,11 @@ static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
 	DEBUG("s626_enc_insn_write: encoder write channel %d \n",
 		CR_CHAN(insn-&gt;chanspec));
 
-	// Set the preload register
+	/*  Set the preload register */
 	Preload(dev, k, data[0]);
 
-	// Software index pulse forces the preload register to load
-	// into the counter
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
 	k-&gt;SetLoadTrig(dev, k, 0);
 	k-&gt;PulseIndex(dev, k);
 	k-&gt;SetLoadTrig(dev, k, 2);
@@ -2311,50 +2319,47 @@ static int s626_enc_insn_write(comedi_device * dev, comedi_subdevice * s,
 
 static void s626_timer_load(comedi_device * dev, enc_private * k, int tick)
 {
-	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT &lt;&lt; BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_TIMER &lt;&lt; BF_CLKSRC) |	// Operating mode is Timer.
-		(CLKPOL_POS &lt;&lt; BF_CLKPOL) |	// Active high clock.
-		(CNTDIR_DOWN &lt;&lt; BF_CLKPOL) |	// Count direction is Down.
-		(CLKMULT_1X &lt;&lt; BF_CLKMULT) |	// Clock multiplier is 1x.
+	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT &lt;&lt; BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_TIMER &lt;&lt; BF_CLKSRC) |	/*  Operating mode is Timer. */
+		(CLKPOL_POS &lt;&lt; BF_CLKPOL) |	/*  Active high clock. */
+		(CNTDIR_DOWN &lt;&lt; BF_CLKPOL) |	/*  Count direction is Down. */
+		(CLKMULT_1X &lt;&lt; BF_CLKMULT) |	/*  Clock multiplier is 1x. */
 		(CLKENAB_INDEX &lt;&lt; BF_CLKENAB);
 	uint16_t valueSrclatch = LATCHSRC_A_INDXA;
-	//  uint16_t enab=CLKENAB_ALWAYS;
+	/*   uint16_t enab=CLKENAB_ALWAYS; */
 
 	k-&gt;SetMode(dev, k, Setup, FALSE);
 
-	// Set the preload register
+	/*  Set the preload register */
 	Preload(dev, k, tick);
 
-	// Software index pulse forces the preload register to load
-	// into the counter
+	/*  Software index pulse forces the preload register to load */
+	/*  into the counter */
 	k-&gt;SetLoadTrig(dev, k, 0);
 	k-&gt;PulseIndex(dev, k);
 
-	//set reload on counter overflow
+	/* set reload on counter overflow */
 	k-&gt;SetLoadTrig(dev, k, 1);
 
-	//set interrupt on overflow
+	/* set interrupt on overflow */
 	k-&gt;SetIntSrc(dev, k, INTSRC_OVER);
 
 	SetLatchSource(dev, k, valueSrclatch);
-	//  k-&gt;SetEnable(dev,k,(uint16_t)(enab != 0));
+	/*   k-&gt;SetEnable(dev,k,(uint16_t)(enab != 0)); */
 }
 
-///////////////////////////////////////////////////////////////////////
-/////////////////////  DAC FUNCTIONS /////////////////////////////////
-///////////////////////////////////////////////////////////////////////
+/* ***********  DAC FUNCTIONS *********** */
 
-// Slot 0 base settings.
-#define VECT0	( XSD2 | RSD3 | SIB_A2 )	// Slot 0 always shifts in
-					 // 0xFF and store it to
-					 // FB_BUFFER2.
+/*  Slot 0 base settings. */
+#define VECT0	( XSD2 | RSD3 | SIB_A2 )
+/*  Slot 0 always shifts in  0xFF and store it to  FB_BUFFER2. */
 
-// TrimDac LogicalChan-to-PhysicalChan mapping table.
+/*  TrimDac LogicalChan-to-PhysicalChan mapping table. */
 static uint8_t trimchan[] = { 10, 9, 8, 3, 2, 7, 6, 1, 0, 5, 4 };
 
-// TrimDac LogicalChan-to-EepromAdrs mapping table.
+/*  TrimDac LogicalChan-to-EepromAdrs mapping table. */
 static uint8_t trimadrs[] =
 	{ 0x40, 0x41, 0x42, 0x50, 0x51, 0x52, 0x53, 0x60, 0x61, 0x62, 0x63 };
 
@@ -2362,7 +2367,7 @@ static void LoadTrimDACs(comedi_device * dev)
 {
 	register uint8_t i;
 
-	// Copy TrimDac setpoint values from EEPROM to TrimDacs.
+	/*  Copy TrimDac setpoint values from EEPROM to TrimDacs. */
 	for (i = 0; i &lt; (sizeof(trimchan) / sizeof(trimchan[0])); i++)
 		WriteTrimDAC(dev, i, I2Cread(dev, trimadrs[i]));
 }
@@ -2372,112 +2377,105 @@ static void WriteTrimDAC(comedi_device * dev, uint8_t LogicalChan,
 {
 	uint32_t chan;
 
-	// Save the new setpoint in case the application needs to read it back later.
+	/*  Save the new setpoint in case the application needs to read it back later. */
 	devpriv-&gt;TrimSetpoint[LogicalChan] = (uint8_t) DacData;
 
-	// Map logical channel number to physical channel number.
+	/*  Map logical channel number to physical channel number. */
 	chan = (uint32_t) trimchan[LogicalChan];
 
-	// Set up TSL2 records for TrimDac write operation.  All slots shift
-	// 0xFF in from pulled-up SD3 so that the end of the slot sequence
-	// can be detected.
-	SETVECT(2, XSD2 | XFIFO_1 | WS3);	// Slot 2: Send high uint8_t
-	// to target TrimDac.
-	SETVECT(3, XSD2 | XFIFO_0 | WS3);	// Slot 3: Send low uint8_t to
-	// target TrimDac.
-	SETVECT(4, XSD2 | XFIFO_3 | WS1);	// Slot 4: Send NOP high
-	// uint8_t to DAC0 to keep
-	// clock running.
-	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);	// Slot 5: Send NOP low
-	// uint8_t to DAC0.
-
-	// Construct and transmit target DAC's serial packet: ( 0000 AAAA
-	// ),( DDDD DDDD ),( 0x00 ),( 0x00 ) where A&lt;3:0&gt; is the DAC
-	// channel's address, and D&lt;7:0&gt; is the DAC setpoint.  Append a WORD
-	// value (that writes a channel 0 NOP command to a non-existent main
-	// DAC channel) that serves to keep the clock running after the
-	// packet has been sent to the target DAC.
-
-	SendDAC(dev, ((uint32_t) chan &lt;&lt; 8)	// Address the DAC channel
-		// within the trimdac device.
-		| (uint32_t) DacData);	// Include DAC setpoint data.
-}
+	/* Set up TSL2 records for TrimDac write operation.  All slots shift
+	 * 0xFF in from pulled-up SD3 so that the end of the slot sequence
+	 * can be detected.
+	 */
+
+	SETVECT(2, XSD2 | XFIFO_1 | WS3);
+	/* Slot 2: Send high uint8_t to target TrimDac. */
+	SETVECT(3, XSD2 | XFIFO_0 | WS3);
+	/* Slot 3: Send low uint8_t to target TrimDac. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS1);
+	/* Slot 4: Send NOP high uint8_t to DAC0 to keep clock running. */
+	SETVECT(5, XSD2 | XFIFO_2 | WS1 | EOS);
+	/* Slot 5: Send NOP low  uint8_t to DAC0. */
+
+	/* Construct and transmit target DAC's serial packet:
+	 * ( 0000 AAAA ), ( DDDD DDDD ),( 0x00 ),( 0x00 ) where A&lt;3:0&gt; is the
+	 * DAC channel's address, and D&lt;7:0&gt; is the DAC setpoint.  Append a
+	 * WORD value (that writes a channel 0 NOP command to a non-existent
+	 * main DAC channel) that serves to keep the clock running after the
+	 * packet has been sent to the target DAC.
+	 */
 
-/////////////////////////////////////////////////////////////////////////
-////////////////  EEPROM ACCESS FUNCTIONS  //////////////////////////////
-/////////////////////////////////////////////////////////////////////////
+	/*  Address the DAC channel within the trimdac device. */
+	SendDAC(dev, ((uint32_t) chan &lt;&lt; 8)
+		| (uint32_t) DacData);	/*  Include DAC setpoint data. */
+}
 
-///////////////////////////////////////////
-// Read uint8_t from EEPROM.
+/* **************  EEPROM ACCESS FUNCTIONS  ************** */
+/*  Read uint8_t from EEPROM. */
 
 static uint8_t I2Cread(comedi_device * dev, uint8_t addr)
 {
 	uint8_t rtnval;
 
-	// Send EEPROM target address.
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)	// Byte2 = I2C
-			// command:
-			// write to
-			// I2C EEPROM
-			// device.
-			| I2C_B1(I2C_ATTRSTOP, addr)	// Byte1 = EEPROM
-			// internal target
-			// address.
-			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
-		// sent.
+	/*  Send EEPROM target address. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CW)
+			 /* Byte2 = I2C command: write to I2C EEPROM  device. */
+			| I2C_B1(I2C_ATTRSTOP, addr)
+			 /* Byte1 = EEPROM internal target address. */
+			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not sent. */
 	{
-		// Abort function and declare error if handshake failed.
+		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread  a\n");
 		return 0;
 	}
-	// Execute EEPROM read.
-	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	// Byte2 = I2C
-			// command: read
-			// from I2C EEPROM
-			// device.
-			| I2C_B1(I2C_ATTRSTOP, 0)	// Byte1 receives
-			// uint8_t from
-			// EEPROM.
-			| I2C_B0(I2C_ATTRNOP, 0)))	// Byte0 = Not
-		// sent.
+	/*  Execute EEPROM read. */
+	if (I2Chandshake(dev, I2C_B2(I2C_ATTRSTART, I2CR)	/*  Byte2 = I2C */
+			/*  command: read */
+			/*  from I2C EEPROM */
+			/*  device. */
+			| I2C_B1(I2C_ATTRSTOP, 0)	/*  Byte1 receives */
+			/*  uint8_t from */
+			/*  EEPROM. */
+			| I2C_B0(I2C_ATTRNOP, 0)))	/*  Byte0 = Not */
+		/*  sent. */
 	{
-		// Abort function and declare error if handshake failed.
+		/*  Abort function and declare error if handshake failed. */
 		DEBUG("I2Cread: error handshake I2Cread b\n");
 		return 0;
 	}
-	// Return copy of EEPROM value.
+	/*  Return copy of EEPROM value. */
 	rtnval = (uint8_t) (RR7146(P_I2CCTRL) &gt;&gt; 16);
 	return rtnval;
 }
 
 static uint32_t I2Chandshake(comedi_device * dev, uint32_t val)
 {
-	// Write I2C command to I2C Transfer Control shadow register.
+	/*  Write I2C command to I2C Transfer Control shadow register. */
 	WR7146(P_I2CCTRL, val);
 
-	// Upload I2C shadow registers into working registers and wait for
-	// upload confirmation.
+	/*  Upload I2C shadow registers into working registers and wait for */
+	/*  upload confirmation. */
 
 	MC_ENABLE(P_MC2, MC2_UPLD_IIC);
 	while (!MC_TEST(P_MC2, MC2_UPLD_IIC)) ;
 
-	// Wait until I2C bus transfer is finished or an error occurs.
+	/*  Wait until I2C bus transfer is finished or an error occurs. */
 	while ((RR7146(P_I2CCTRL) &amp; (I2C_BUSY | I2C_ERR)) == I2C_BUSY) ;
 
-	// Return non-zero if I2C error occured.
+	/*  Return non-zero if I2C error occured. */
 	return RR7146(P_I2CCTRL) &amp; I2C_ERR;
 
 }
 
-// Private helper function: Write setpoint to an application DAC channel.
+/*  Private helper function: Write setpoint to an application DAC channel. */
 
 static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
 {
 	register uint16_t signmask;
 	register uint32_t WSImage;
 
-	// Adjust DAC data polarity and set up Polarity Control Register
-	// image.
+	/*  Adjust DAC data polarity and set up Polarity Control Register */
+	/*  image. */
 	signmask = 1 &lt;&lt; chan;
 	if (dacdata &lt; 0) {
 		dacdata = -dacdata;
@@ -2485,234 +2483,243 @@ static void SetDAC(comedi_device * dev, uint16_t chan, short dacdata)
 	} else
 		devpriv-&gt;Dacpol &amp;= ~signmask;
 
-	// Limit DAC setpoint value to valid range.
+	/*  Limit DAC setpoint value to valid range. */
 	if ((uint16_t) dacdata &gt; 0x1FFF)
 		dacdata = 0x1FFF;
 
-	// Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
-	// and V3 transmit the setpoint to the target DAC.  V4 and V5 send
-	// data to a non-existent TrimDac channel just to keep the clock
-	// running after sending data to the target DAC.  This is necessary
-	// to eliminate the clock glitch that would otherwise occur at the
-	// end of the target DAC's serial data stream.  When the sequence
-	// restarts at V0 (after executing V5), the gate array automatically
-	// disables gating for the DAC clock and all DAC chip selects.
-	WSImage = (chan &amp; 2) ? WS1 : WS2;	// Choose DAC chip select to
-	// be asserted.
-	SETVECT(2, XSD2 | XFIFO_1 | WSImage);	// Slot 2: Transmit high
-	// data byte to target DAC.
-	SETVECT(3, XSD2 | XFIFO_0 | WSImage);	// Slot 3: Transmit low data
-	// byte to target DAC.
-	SETVECT(4, XSD2 | XFIFO_3 | WS3);	// Slot 4: Transmit to
-	// non-existent TrimDac
-	// channel to keep clock
-	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);	// Slot 5: running after
-	// writing target DAC's
-	// low data byte.
-
-	// Construct and transmit target DAC's serial packet: ( A10D DDDD
-	// ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan&lt;0&gt;, and D&lt;12:0&gt;
-	// is the DAC setpoint.  Append a WORD value (that writes to a
-	// non-existent TrimDac channel) that serves to keep the clock
-	// running after the packet has been sent to the target DAC.
-	SendDAC(dev, 0x0F000000	//Continue clock after target DAC
-		//data (write to non-existent
-		//trimdac).
-		| 0x00004000	// Address the two main dual-DAC
-		// devices (TSL's chip select enables
-		// target device).
-		| ((uint32_t) (chan &amp; 1) &lt;&lt; 15)	// Address the DAC
-		// channel within the
-		// device.
-		| (uint32_t) dacdata);	// Include DAC setpoint data.
+	/* Set up TSL2 records (aka "vectors") for DAC update.  Vectors V2
+	 * and V3 transmit the setpoint to the target DAC.  V4 and V5 send
+	 * data to a non-existent TrimDac channel just to keep the clock
+	 * running after sending data to the target DAC.  This is necessary
+	 * to eliminate the clock glitch that would otherwise occur at the
+	 * end of the target DAC's serial data stream.  When the sequence
+	 * restarts at V0 (after executing V5), the gate array automatically
+	 * disables gating for the DAC clock and all DAC chip selects.
+	 */
+
+	WSImage = (chan &amp; 2) ? WS1 : WS2;
+	/* Choose DAC chip select to be asserted. */
+	SETVECT(2, XSD2 | XFIFO_1 | WSImage);
+	/* Slot 2: Transmit high data byte to target DAC. */
+	SETVECT(3, XSD2 | XFIFO_0 | WSImage);
+	/* Slot 3: Transmit low data byte to target DAC. */
+	SETVECT(4, XSD2 | XFIFO_3 | WS3);
+	/* Slot 4: Transmit to non-existent TrimDac channel to keep clock */
+	SETVECT(5, XSD2 | XFIFO_2 | WS3 | EOS);
+	/* Slot 5: running after writing target DAC's low data byte. */
+
+	/*  Construct and transmit target DAC's serial packet:
+	 * ( A10D DDDD ),( DDDD DDDD ),( 0x0F ),( 0x00 ) where A is chan&lt;0&gt;,
+	 * and D&lt;12:0&gt; is the DAC setpoint.  Append a WORD value (that writes
+	 * to a  non-existent TrimDac channel) that serves to keep the clock
+	 * running after the packet has been sent to the target DAC.
+	 */
+	SendDAC(dev, 0x0F000000
+		/* Continue clock after target DAC data (write to non-existent trimdac). */
+		| 0x00004000
+		/* Address the two main dual-DAC devices (TSL's chip select enables
+		 * target device). */
+		| ((uint32_t) (chan &amp; 1) &lt;&lt; 15)
+		/*  Address the DAC channel within the  device. */
+		| (uint32_t) dacdata);	/*  Include DAC setpoint data. */
 
 }
 
-////////////////////////////////////////////////////////
-// Private helper function: Transmit serial data to DAC via Audio
-// channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
-// Dacpol contains valid target image.
+/* Private helper function: Transmit serial data to DAC via Audio
+ * channel 2.  Assumes: (1) TSL2 slot records initialized, and (2)
+ * Dacpol contains valid target image.
+ */
 
 static void SendDAC(comedi_device * dev, uint32_t val)
 {
 
-	// START THE SERIAL CLOCK RUNNING -------------
+	/* START THE SERIAL CLOCK RUNNING ------------- */
 
-	// Assert DAC polarity control and enable gating of DAC serial clock
-	// and audio bit stream signals.  At this point in time we must be
-	// assured of being in time slot 0.  If we are not in slot 0, the
-	// serial clock and audio stream signals will be disabled; this is
-	// because the following DEBIwrite statement (which enables signals
-	// to be passed through the gate array) would execute before the
-	// trailing edge of WS1/WS3 (which turns off the signals), thus
-	// causing the signals to be inactive during the DAC write.
+	/* Assert DAC polarity control and enable gating of DAC serial clock
+	 * and audio bit stream signals.  At this point in time we must be
+	 * assured of being in time slot 0.  If we are not in slot 0, the
+	 * serial clock and audio stream signals will be disabled; this is
+	 * because the following DEBIwrite statement (which enables signals
+	 * to be passed through the gate array) would execute before the
+	 * trailing edge of WS1/WS3 (which turns off the signals), thus
+	 * causing the signals to be inactive during the DAC write.
+	 */
 	DEBIwrite(dev, LP_DACPOL, devpriv-&gt;Dacpol);
 
-	// TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ----------------
+	/* TRANSFER OUTPUT DWORD VALUE INTO A2'S OUTPUT FIFO ---------------- */
 
-	// Copy DAC setpoint value to DAC's output DMA buffer.
+	/* Copy DAC setpoint value to DAC's output DMA buffer. */
 
-	//WR7146( (uint32_t)devpriv-&gt;pDacWBuf, val );
+	/* WR7146( (uint32_t)devpriv-&gt;pDacWBuf, val ); */
 	*devpriv-&gt;pDacWBuf = val;
 
-	// enab the output DMA transfer.  This will cause the DMAC to copy
-	// the DAC's data value to A2's output FIFO.  The DMA transfer will
-	// then immediately terminate because the protection address is
-	// reached upon transfer of the first DWORD value.
+	/* enab the output DMA transfer.  This will cause the DMAC to copy
+	 * the DAC's data value to A2's output FIFO.  The DMA transfer will
+	 * then immediately terminate because the protection address is
+	 * reached upon transfer of the first DWORD value.
+	 */
 	MC_ENABLE(P_MC1, MC1_A2OUT);
 
-	// While the DMA transfer is executing ...
+	/*  While the DMA transfer is executing ... */
 
-	// Reset Audio2 output FIFO's underflow flag (along with any other
-	// FIFO underflow/overflow flags).  When set, this flag will
-	// indicate that we have emerged from slot 0.
+	/* Reset Audio2 output FIFO's underflow flag (along with any other
+	 * FIFO underflow/overflow flags).  When set, this flag will
+	 * indicate that we have emerged from slot 0.
+	 */
 	WR7146(P_ISR, ISR_AFOU);
 
-	// Wait for the DMA transfer to finish so that there will be data
-	// available in the FIFO when time slot 1 tries to transfer a DWORD
-	// from the FIFO to the output buffer register.  We test for DMA
-	// Done by polling the DMAC enable flag; this flag is automatically
-	// cleared when the transfer has finished.
+	/* Wait for the DMA transfer to finish so that there will be data
+	 * available in the FIFO when time slot 1 tries to transfer a DWORD
+	 * from the FIFO to the output buffer register.  We test for DMA
+	 * Done by polling the DMAC enable flag; this flag is automatically
+	 * cleared when the transfer has finished.
+	 */
 	while ((RR7146(P_MC1) &amp; MC1_A2OUT) != 0) ;
 
-	// START THE OUTPUT STREAM TO THE TARGET DAC --------------------
+	/* START THE OUTPUT STREAM TO THE TARGET DAC -------------------- */
 
-	// FIFO data is now available, so we enable execution of time slots
-	// 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
-	// will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
-	// detection.
+	/* FIFO data is now available, so we enable execution of time slots
+	 * 1 and higher by clearing the EOS flag in slot 0.  Note that SD3
+	 * will be shifted in and stored in FB_BUFFER2 for end-of-slot-list
+	 * detection.
+	 */
 	SETVECT(0, XSD2 | RSD3 | SIB_A2);
 
-	// Wait for slot 1 to execute to ensure that the Packet will be
-	// transmitted.  This is detected by polling the Audio2 output FIFO
-	// underflow flag, which will be set when slot 1 execution has
-	// finished transferring the DAC's data DWORD from the output FIFO
-	// to the output buffer register.
+	/* Wait for slot 1 to execute to ensure that the Packet will be
+	 * transmitted.  This is detected by polling the Audio2 output FIFO
+	 * underflow flag, which will be set when slot 1 execution has
+	 * finished transferring the DAC's data DWORD from the output FIFO
+	 * to the output buffer register.
+	 */
 	while ((RR7146(P_SSR) &amp; SSR_AF2_OUT) == 0) ;
 
-	// Set up to trap execution at slot 0 when the TSL sequencer cycles
-	// back to slot 0 after executing the EOS in slot 5.  Also,
-	// simultaneously shift out and in the 0x00 that is ALWAYS the value
-	// stored in the last byte to be shifted out of the FIFO's DWORD
-	// buffer register.
+	/* Set up to trap execution at slot 0 when the TSL sequencer cycles
+	 * back to slot 0 after executing the EOS in slot 5.  Also,
+	 * simultaneously shift out and in the 0x00 that is ALWAYS the value
+	 * stored in the last byte to be shifted out of the FIFO's DWORD
+	 * buffer register.
+	 */
 	SETVECT(0, XSD2 | XFIFO_2 | RSD2 | SIB_A2 | EOS);
 
-	// WAIT FOR THE TRANSACTION TO FINISH -----------------------
-
-	// Wait for the TSL to finish executing all time slots before
-	// exiting this function.  We must do this so that the next DAC
-	// write doesn't start, thereby enabling clock/chip select signals:
-	// 1. Before the TSL sequence cycles back to slot 0, which disables
-	// the clock/cs signal gating and traps slot // list execution.  If
-	// we have not yet finished slot 5 then the clock/cs signals are
-	// still gated and we have // not finished transmitting the stream.
-	// 2. While slots 2-5 are executing due to a late slot 0 trap.  In
-	// this case, the slot sequence is currently // repeating, but with
-	// clock/cs signals disabled.  We must wait for slot 0 to trap
-	// execution before setting // up the next DAC setpoint DMA transfer
-	// and enabling the clock/cs signals.  To detect the end of slot 5,
-	// we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
-	// the TSL has not yet finished executing slot 5 ...
+	/* WAIT FOR THE TRANSACTION TO FINISH ----------------------- */
+
+	/* Wait for the TSL to finish executing all time slots before
+	 * exiting this function.  We must do this so that the next DAC
+	 * write doesn't start, thereby enabling clock/chip select signals:
+	 *
+	 * 1. Before the TSL sequence cycles back to slot 0, which disables
+	 *    the clock/cs signal gating and traps slot // list execution.
+	 *    we have not yet finished slot 5 then the clock/cs signals are
+	 *    still gated and we have not finished transmitting the stream.
+	 *
+	 * 2. While slots 2-5 are executing due to a late slot 0 trap.  In
+	 *    this case, the slot sequence is currently repeating, but with
+	 *    clock/cs signals disabled.  We must wait for slot 0 to trap
+	 *    execution before setting up the next DAC setpoint DMA transfer
+	 *    and enabling the clock/cs signals.  To detect the end of slot 5,
+	 *    we test for the FB_BUFFER2 MSB contents to be equal to 0xFF.  If
+	 *    the TSL has not yet finished executing slot 5 ...
+	 */
 	if ((RR7146(P_FB_BUFFER2) &amp; 0xFF000000) != 0) {
-		// The trap was set on time and we are still executing somewhere
-		// in slots 2-5, so we now wait for slot 0 to execute and trap
-		// TSL execution.  This is detected when FB_BUFFER2 MSB changes
-		// from 0xFF to 0x00, which slot 0 causes to happen by shifting
-		// out/in on SD2 the 0x00 that is always referenced by slot 5.
-		while ((RR7146(P_FB_BUFFER2) &amp; 0xFF000000) != 0) ;
+		/* The trap was set on time and we are still executing somewhere
+		 * in slots 2-5, so we now wait for slot 0 to execute and trap
+		 * TSL execution.  This is detected when FB_BUFFER2 MSB changes
+		 * from 0xFF to 0x00, which slot 0 causes to happen by shifting
+		 * out/in on SD2 the 0x00 that is always referenced by slot 5.
+		 */
+		 while ((RR7146(P_FB_BUFFER2) &amp; 0xFF000000) != 0) ;
 	}
-	// Either (1) we were too late setting the slot 0 trap; the TSL
-	// sequencer restarted slot 0 before we could set the EOS trap flag,
-	// or (2) we were not late and execution is now trapped at slot 0.
-	// In either case, we must now change slot 0 so that it will store
-	// value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
-	// In order to do this, we reprogram slot 0 so that it will shift in
-	// SD3, which is driven only by a pull-up resistor.
+	/* Either (1) we were too late setting the slot 0 trap; the TSL
+	 * sequencer restarted slot 0 before we could set the EOS trap flag,
+	 * or (2) we were not late and execution is now trapped at slot 0.
+	 * In either case, we must now change slot 0 so that it will store
+	 * value 0xFF (instead of 0x00) to FB_BUFFER2 next time it executes.
+	 * In order to do this, we reprogram slot 0 so that it will shift in
+	 * SD3, which is driven only by a pull-up resistor.
+	 */
 	SETVECT(0, RSD3 | SIB_A2 | EOS);
 
-	// Wait for slot 0 to execute, at which time the TSL is setup for
-	// the next DAC write.  This is detected when FB_BUFFER2 MSB changes
-	// from 0x00 to 0xFF.
+	/* Wait for slot 0 to execute, at which time the TSL is setup for
+	 * the next DAC write.  This is detected when FB_BUFFER2 MSB changes
+	 * from 0x00 to 0xFF.
+	 */
 	while ((RR7146(P_FB_BUFFER2) &amp; 0xFF000000) == 0) ;
 }
 
 static void WriteMISC2(comedi_device * dev, uint16_t NewImage)
 {
-	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	// enab writes to
-	// MISC2 register.
-	DEBIwrite(dev, LP_WRMISC2, NewImage);	// Write new image to MISC2.
-	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	// Disable writes to MISC2.
+	DEBIwrite(dev, LP_MISC1, MISC1_WENABLE);	/*  enab writes to */
+	/*  MISC2 register. */
+	DEBIwrite(dev, LP_WRMISC2, NewImage);	/*  Write new image to MISC2. */
+	DEBIwrite(dev, LP_MISC1, MISC1_WDISABLE);	/*  Disable writes to MISC2. */
 }
 
-/////////////////////////////////////////////////////////////////////
-// Initialize the DEBI interface for all transfers.
+/*  Initialize the DEBI interface for all transfers. */
 
 static uint16_t DEBIread(comedi_device * dev, uint16_t addr)
 {
 	uint16_t retval;
 
-	// Set up DEBI control register value in shadow RAM.
+	/*  Set up DEBI control register value in shadow RAM. */
 	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
 
-	// Execute the DEBI transfer.
+	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 
-	// Fetch target register value.
+	/*  Fetch target register value. */
 	retval = (uint16_t) RR7146(P_DEBIAD);
 
-	// Return register value.
+	/*  Return register value. */
 	return retval;
 }
 
-// Execute a DEBI transfer.  This must be called from within a
-// critical section.
+/*  Execute a DEBI transfer.  This must be called from within a */
+/*  critical section. */
 static void DEBItransfer(comedi_device * dev)
 {
-	// Initiate upload of shadow RAM to DEBI control register.
+	/*  Initiate upload of shadow RAM to DEBI control register. */
 	MC_ENABLE(P_MC2, MC2_UPLD_DEBI);
 
-	// Wait for completion of upload from shadow RAM to DEBI control
-	// register.
+	/*  Wait for completion of upload from shadow RAM to DEBI control */
+	/*  register. */
 	while (!MC_TEST(P_MC2, MC2_UPLD_DEBI)) ;
 
-	// Wait until DEBI transfer is done.
+	/*  Wait until DEBI transfer is done. */
 	while (RR7146(P_PSR) &amp; PSR_DEBI_S) ;
 }
 
-// Write a value to a gate array register.
+/*  Write a value to a gate array register. */
 static void DEBIwrite(comedi_device * dev, uint16_t addr, uint16_t wdata)
 {
 
-	// Set up DEBI control register value in shadow RAM.
+	/*  Set up DEBI control register value in shadow RAM. */
 	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
 	WR7146(P_DEBIAD, wdata);
 
-	// Execute the DEBI transfer.
+	/*  Execute the DEBI transfer. */
 	DEBItransfer(dev);
 }
 
-/////////////////////////////////////////////////////////////////////////////
-// Replace the specified bits in a gate array register.  Imports: mask
-// specifies bits that are to be preserved, wdata is new value to be
-// or'd with the masked original.
+/* Replace the specified bits in a gate array register.  Imports: mask
+ * specifies bits that are to be preserved, wdata is new value to be
+ * or'd with the masked original.
+ */
 static void DEBIreplace(comedi_device * dev, uint16_t addr, uint16_t mask,
 	uint16_t wdata)
 {
 
-	// Copy target gate array register into P_DEBIAD register.
-	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);	// Set up DEBI control
-	// reg value in shadow
-	// RAM.
-	DEBItransfer(dev);	// Execute the DEBI
-	// Read transfer.
+	/*  Copy target gate array register into P_DEBIAD register. */
+	WR7146(P_DEBICMD, DEBI_CMD_RDWORD | addr);
+	/* Set up DEBI control reg value in shadow RAM. */
+	DEBItransfer(dev);	/*  Execute the DEBI Read transfer. */
 
-	// Write back the modified image.
-	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);	// Set up DEBI control
-	// reg value in shadow
-	// RAM.
+	/*  Write back the modified image. */
+	WR7146(P_DEBICMD, DEBI_CMD_WRWORD | addr);
+	/* Set up DEBI control reg value in shadow  RAM. */
 
-	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) &amp; mask));	// Modify the register image.
-	DEBItransfer(dev);	// Execute the DEBI Write transfer.
+	WR7146(P_DEBIAD, wdata | ((uint16_t) RR7146(P_DEBIAD) &amp; mask));
+	/* Modify the register image. */
+	DEBItransfer(dev);	/*  Execute the DEBI Write transfer. */
 }
 
 static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
@@ -2723,7 +2730,7 @@ static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
 	DEBUG("CloseDMAB: Entering S626DRV_CloseDMAB():\n");
 	if (pdma == NULL)
 		return;
-	//find the matching allocation from the board struct
+	/* find the matching allocation from the board struct */
 
 	vbptr = pdma-&gt;LogicalBase;
 	vpptr = pdma-&gt;PhysicalBase;
@@ -2737,44 +2744,37 @@ static void CloseDMAB(comedi_device * dev, DMABUF * pdma, size_t bsize)
 	}
 }
 
-////////////////////////////////////////////////////////////////////////
-/////////////////  COUNTER FUNCTIONS  //////////////////////////////////
-////////////////////////////////////////////////////////////////////////
-// All counter functions address a specific counter by means of the
-// "Counter" argument, which is a logical counter number.  The Counter
-// argument may have any of the following legal values: 0=0A, 1=1A,
-// 2=2A, 3=0B, 4=1B, 5=2B.
-////////////////////////////////////////////////////////////////////////
+/* ******  COUNTER FUNCTIONS  ******* */
+/* All counter functions address a specific counter by means of the
+ * "Counter" argument, which is a logical counter number.  The Counter
+ * argument may have any of the following legal values: 0=0A, 1=1A,
+ * 2=2A, 3=0B, 4=1B, 5=2B.
+ */
 
-// Forward declarations for functions that are common to both A and B
-// counters:
+/* Forward declarations for functions that are common to both A and B counters: */
 
-/////////////////////////////////////////////////////////////////////
-//////////////////// PRIVATE COUNTER FUNCTIONS  /////////////////////
-/////////////////////////////////////////////////////////////////////
+/* ******  PRIVATE COUNTER FUNCTIONS ****** */
 
-/////////////////////////////////////////////////////////////////
-// Read a counter's output latch.
+/*  Read a counter's output latch. */
 
 static uint32_t ReadLatch(comedi_device * dev, enc_private * k)
 {
 	register uint32_t value;
-	//DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n");
+	/* DEBUG FIXME DEBUG("ReadLatch: Read Latch enter\n"); */
 
-	// Latch counts and fetch LSW of latched counts value.
+	/*  Latch counts and fetch LSW of latched counts value. */
 	value = (uint32_t) DEBIread(dev, k-&gt;MyLatchLsw);
 
-	// Fetch MSW of latched counts and combine with LSW.
+	/*  Fetch MSW of latched counts and combine with LSW. */
 	value |= ((uint32_t) DEBIread(dev, k-&gt;MyLatchLsw + 2) &lt;&lt; 16);
 
-	// DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n");
+	/*  DEBUG FIXME DEBUG("ReadLatch: Read Latch exit\n"); */
 
-	// Return latched counts.
+	/*  Return latched counts. */
 	return value;
 }
 
-///////////////////////////////////////////////////////////////////
-// Reset a counter's index and overflow event capture flags.
+/*  Reset a counter's index and overflow event capture flags. */
 
 static void ResetCapFlags_A(comedi_device * dev, enc_private * k)
 {
@@ -2788,9 +2788,8 @@ static void ResetCapFlags_B(comedi_device * dev, enc_private * k)
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B);
 }
 
-/////////////////////////////////////////////////////////////////////////
-// Return counter setup in a format (COUNTER_SETUP) that is consistent
-// for both A and B counters.
+/*  Return counter setup in a format (COUNTER_SETUP) that is consistent */
+/*  for both A and B counters. */
 
 static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
 {
@@ -2798,35 +2797,35 @@ static uint16_t GetMode_A(comedi_device * dev, enc_private * k)
 	register uint16_t crb;
 	register uint16_t setup;
 
-	// Fetch CRA and CRB register images.
+	/*  Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k-&gt;MyCRA);
 	crb = DEBIread(dev, k-&gt;MyCRB);
 
-	// Populate the standardized counter setup bit fields.  Note:
-	// IndexSrc is restricted to ENC_X or IndxPol.
-	setup = ((cra &amp; STDMSK_LOADSRC)	// LoadSrc  = LoadSrcA.
-		| ((crb &lt;&lt; (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &amp; STDMSK_LATCHSRC)	// LatchSrc = LatchSrcA.
-		| ((cra &lt;&lt; (STDBIT_INTSRC - CRABIT_INTSRC_A)) &amp; STDMSK_INTSRC)	// IntSrc   = IntSrcA.
-		| ((cra &lt;&lt; (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) &amp; STDMSK_INDXSRC)	// IndxSrc  = IndxSrcA&lt;1&gt;.
-		| ((cra &gt;&gt; (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) &amp; STDMSK_INDXPOL)	// IndxPol  = IndxPolA.
-		| ((crb &gt;&gt; (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) &amp; STDMSK_CLKENAB));	// ClkEnab  = ClkEnabA.
-
-	// Adjust mode-dependent parameters.
-	if (cra &amp; (2 &lt;&lt; CRABIT_CLKSRC_A))	// If Timer mode (ClkSrcA&lt;1&gt; == 1):
-		setup |= ((CLKSRC_TIMER &lt;&lt; STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| ((cra &lt;&lt; (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) &amp; STDMSK_CLKPOL)	//   Set ClkPol to indicate count direction (ClkSrcA&lt;0&gt;).
-			| (MULT_X1 &lt;&lt; STDBIT_CLKMULT));	//   ClkMult must be 1x in Timer mode.
-
-	else			// If Counter mode (ClkSrcA&lt;1&gt; == 0):
-		setup |= ((CLKSRC_COUNTER &lt;&lt; STDBIT_CLKSRC)	//   Indicate Counter mode.
-			| ((cra &gt;&gt; (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) &amp; STDMSK_CLKPOL)	//   Pass through ClkPol.
-			| (((cra &amp; CRAMSK_CLKMULT_A) == (MULT_X0 &lt;&lt; CRABIT_CLKMULT_A)) ?	//   Force ClkMult to 1x if not legal, else pass through.
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = ((cra &amp; STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcA. */
+		| ((crb &lt;&lt; (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &amp; STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcA. */
+		| ((cra &lt;&lt; (STDBIT_INTSRC - CRABIT_INTSRC_A)) &amp; STDMSK_INTSRC)	/*  IntSrc   = IntSrcA. */
+		| ((cra &lt;&lt; (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))) &amp; STDMSK_INDXSRC)	/*  IndxSrc  = IndxSrcA&lt;1&gt;. */
+		| ((cra &gt;&gt; (CRABIT_INDXPOL_A - STDBIT_INDXPOL)) &amp; STDMSK_INDXPOL)	/*  IndxPol  = IndxPolA. */
+		| ((crb &gt;&gt; (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)) &amp; STDMSK_CLKENAB));	/*  ClkEnab  = ClkEnabA. */
+
+	/*  Adjust mode-dependent parameters. */
+	if (cra &amp; (2 &lt;&lt; CRABIT_CLKSRC_A))	/*  If Timer mode (ClkSrcA&lt;1&gt; == 1): */
+		setup |= ((CLKSRC_TIMER &lt;&lt; STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| ((cra &lt;&lt; (STDBIT_CLKPOL - CRABIT_CLKSRC_A)) &amp; STDMSK_CLKPOL)	/*    Set ClkPol to indicate count direction (ClkSrcA&lt;0&gt;). */
+			| (MULT_X1 &lt;&lt; STDBIT_CLKMULT));	/*    ClkMult must be 1x in Timer mode. */
+
+	else			/*  If Counter mode (ClkSrcA&lt;1&gt; == 0): */
+		setup |= ((CLKSRC_COUNTER &lt;&lt; STDBIT_CLKSRC)	/*    Indicate Counter mode. */
+			| ((cra &gt;&gt; (CRABIT_CLKPOL_A - STDBIT_CLKPOL)) &amp; STDMSK_CLKPOL)	/*    Pass through ClkPol. */
+			| (((cra &amp; CRAMSK_CLKMULT_A) == (MULT_X0 &lt;&lt; CRABIT_CLKMULT_A)) ?	/*    Force ClkMult to 1x if not legal, else pass through. */
 				(MULT_X1 &lt;&lt; STDBIT_CLKMULT) :
 				((cra &gt;&gt; (CRABIT_CLKMULT_A -
 							STDBIT_CLKMULT)) &amp;
 					STDMSK_CLKMULT)));
 
-	// Return adjusted counter setup.
+	/*  Return adjusted counter setup. */
 	return setup;
 }
 
@@ -2836,98 +2835,99 @@ static uint16_t GetMode_B(comedi_device * dev, enc_private * k)
 	register uint16_t crb;
 	register uint16_t setup;
 
-	// Fetch CRA and CRB register images.
+	/*  Fetch CRA and CRB register images. */
 	cra = DEBIread(dev, k-&gt;MyCRA);
 	crb = DEBIread(dev, k-&gt;MyCRB);
 
-	// Populate the standardized counter setup bit fields.  Note:
-	// IndexSrc is restricted to ENC_X or IndxPol.
-	setup = (((crb &lt;&lt; (STDBIT_INTSRC - CRBBIT_INTSRC_B)) &amp; STDMSK_INTSRC)	// IntSrc   = IntSrcB.
-		| ((crb &lt;&lt; (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &amp; STDMSK_LATCHSRC)	// LatchSrc = LatchSrcB.
-		| ((crb &lt;&lt; (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) &amp; STDMSK_LOADSRC)	// LoadSrc  = LoadSrcB.
-		| ((crb &lt;&lt; (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) &amp; STDMSK_INDXPOL)	// IndxPol  = IndxPolB.
-		| ((crb &gt;&gt; (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) &amp; STDMSK_CLKENAB)	// ClkEnab  = ClkEnabB.
-		| ((cra &gt;&gt; ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) &amp; STDMSK_INDXSRC));	// IndxSrc  = IndxSrcB&lt;1&gt;.
-
-	// Adjust mode-dependent parameters.
-	if ((crb &amp; CRBMSK_CLKMULT_B) == (MULT_X0 &lt;&lt; CRBBIT_CLKMULT_B))	// If Extender mode (ClkMultB == MULT_X0):
-		setup |= ((CLKSRC_EXTENDER &lt;&lt; STDBIT_CLKSRC)	//   Indicate Extender mode.
-			| (MULT_X1 &lt;&lt; STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
-			| ((cra &gt;&gt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &amp; STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB&lt;0&gt;).
-
-	else if (cra &amp; (2 &lt;&lt; CRABIT_CLKSRC_B))	// If Timer mode (ClkSrcB&lt;1&gt; == 1):
-		setup |= ((CLKSRC_TIMER &lt;&lt; STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| (MULT_X1 &lt;&lt; STDBIT_CLKMULT)	//   Indicate multiplier is 1x.
-			| ((cra &gt;&gt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &amp; STDMSK_CLKPOL));	//   Set ClkPol equal to Timer count direction (ClkSrcB&lt;0&gt;).
-
-	else			// If Counter mode (ClkSrcB&lt;1&gt; == 0):
-		setup |= ((CLKSRC_COUNTER &lt;&lt; STDBIT_CLKSRC)	//   Indicate Timer mode.
-			| ((crb &gt;&gt; (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) &amp; STDMSK_CLKMULT)	//   Clock multiplier is passed through.
-			| ((crb &lt;&lt; (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) &amp; STDMSK_CLKPOL));	//   Clock polarity is passed through.
-
-	// Return adjusted counter setup.
+	/*  Populate the standardized counter setup bit fields.  Note: */
+	/*  IndexSrc is restricted to ENC_X or IndxPol. */
+	setup = (((crb &lt;&lt; (STDBIT_INTSRC - CRBBIT_INTSRC_B)) &amp; STDMSK_INTSRC)	/*  IntSrc   = IntSrcB. */
+		| ((crb &lt;&lt; (STDBIT_LATCHSRC - CRBBIT_LATCHSRC)) &amp; STDMSK_LATCHSRC)	/*  LatchSrc = LatchSrcB. */
+		| ((crb &lt;&lt; (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)) &amp; STDMSK_LOADSRC)	/*  LoadSrc  = LoadSrcB. */
+		| ((crb &lt;&lt; (STDBIT_INDXPOL - CRBBIT_INDXPOL_B)) &amp; STDMSK_INDXPOL)	/*  IndxPol  = IndxPolB. */
+		| ((crb &gt;&gt; (CRBBIT_CLKENAB_B - STDBIT_CLKENAB)) &amp; STDMSK_CLKENAB)	/*  ClkEnab  = ClkEnabB. */
+		| ((cra &gt;&gt; ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC)) &amp; STDMSK_INDXSRC));	/*  IndxSrc  = IndxSrcB&lt;1&gt;. */
+
+	/*  Adjust mode-dependent parameters. */
+	if ((crb &amp; CRBMSK_CLKMULT_B) == (MULT_X0 &lt;&lt; CRBBIT_CLKMULT_B))	/*  If Extender mode (ClkMultB == MULT_X0): */
+		setup |= ((CLKSRC_EXTENDER &lt;&lt; STDBIT_CLKSRC)	/*    Indicate Extender mode. */
+			| (MULT_X1 &lt;&lt; STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			| ((cra &gt;&gt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &amp; STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB&lt;0&gt;). */
+
+	else if (cra &amp; (2 &lt;&lt; CRABIT_CLKSRC_B))	/*  If Timer mode (ClkSrcB&lt;1&gt; == 1): */
+		setup |= ((CLKSRC_TIMER &lt;&lt; STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| (MULT_X1 &lt;&lt; STDBIT_CLKMULT)	/*    Indicate multiplier is 1x. */
+			| ((cra &gt;&gt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)) &amp; STDMSK_CLKPOL));	/*    Set ClkPol equal to Timer count direction (ClkSrcB&lt;0&gt;). */
+
+	else			/*  If Counter mode (ClkSrcB&lt;1&gt; == 0): */
+		setup |= ((CLKSRC_COUNTER &lt;&lt; STDBIT_CLKSRC)	/*    Indicate Timer mode. */
+			| ((crb &gt;&gt; (CRBBIT_CLKMULT_B - STDBIT_CLKMULT)) &amp; STDMSK_CLKMULT)	/*    Clock multiplier is passed through. */
+			| ((crb &lt;&lt; (STDBIT_CLKPOL - CRBBIT_CLKPOL_B)) &amp; STDMSK_CLKPOL));	/*    Clock polarity is passed through. */
+
+	/*  Return adjusted counter setup. */
 	return setup;
 }
 
-/////////////////////////////////////////////////////////////////////////////////////////////
-// Set the operating mode for the specified counter.  The setup
-// parameter is treated as a COUNTER_SETUP data type.  The following
-// parameters are programmable (all other parms are ignored): ClkMult,
-// ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+/*
+ * Set the operating mode for the specified counter.  The setup
+ * parameter is treated as a COUNTER_SETUP data type.  The following
+ * parameters are programmable (all other parms are ignored): ClkMult,
+ * ClkPol, ClkEnab, IndexSrc, IndexPol, LoadSrc.
+ */
 
 static void SetMode_A(comedi_device * dev, enc_private * k, uint16_t Setup,
 	uint16_t DisableIntSrc)
 {
 	register uint16_t cra;
 	register uint16_t crb;
-	register uint16_t setup = Setup;	// Cache the Standard Setup.
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	// Initialize CRA and CRB images.
-	cra = ((setup &amp; CRAMSK_LOADSRC_A)	// Preload trigger is passed through.
-		| ((setup &amp; STDMSK_INDXSRC) &gt;&gt; (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	// IndexSrc is restricted to ENC_X or IndxPol.
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup &amp; CRAMSK_LOADSRC_A)	/*  Preload trigger is passed through. */
+		| ((setup &amp; STDMSK_INDXSRC) &gt;&gt; (STDBIT_INDXSRC - (CRABIT_INDXSRC_A + 1))));	/*  IndexSrc is restricted to ENC_X or IndxPol. */
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	// Reset any pending CounterA event captures.
-		| ((setup &amp; STDMSK_CLKENAB) &lt;&lt; (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	// Clock enable is passed through.
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A	/*  Reset any pending CounterA event captures. */
+		| ((setup &amp; STDMSK_CLKENAB) &lt;&lt; (CRBBIT_CLKENAB_A - STDBIT_CLKENAB)));	/*  Clock enable is passed through. */
 
-	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		cra |= ((setup &amp; STDMSK_INTSRC) &gt;&gt; (STDBIT_INTSRC -
 				CRABIT_INTSRC_A));
 
-	// Populate all mode-dependent attributes of CRA &amp; CRB images.
+	/*  Populate all mode-dependent attributes of CRA &amp; CRB images. */
 	switch ((setup &amp; STDMSK_CLKSRC) &gt;&gt; STDBIT_CLKSRC) {
-	case CLKSRC_EXTENDER:	// Extender Mode: Force to Timer mode
-		// (Extender valid only for B counters).
-
-	case CLKSRC_TIMER:	// Timer Mode:
-		cra |= ((2 &lt;&lt; CRABIT_CLKSRC_A)	//   ClkSrcA&lt;1&gt; selects system clock
-			| ((setup &amp; STDMSK_CLKPOL) &gt;&gt; (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	//     with count direction (ClkSrcA&lt;0&gt;) obtained from ClkPol.
-			| (1 &lt;&lt; CRABIT_CLKPOL_A)	//   ClkPolA behaves as always-on clock enable.
-			| (MULT_X1 &lt;&lt; CRABIT_CLKMULT_A));	//   ClkMult must be 1x.
+	case CLKSRC_EXTENDER:	/*  Extender Mode: Force to Timer mode */
+		/*  (Extender valid only for B counters). */
+
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 &lt;&lt; CRABIT_CLKSRC_A)	/*    ClkSrcA&lt;1&gt; selects system clock */
+			| ((setup &amp; STDMSK_CLKPOL) &gt;&gt; (STDBIT_CLKPOL - CRABIT_CLKSRC_A))	/*      with count direction (ClkSrcA&lt;0&gt;) obtained from ClkPol. */
+			| (1 &lt;&lt; CRABIT_CLKPOL_A)	/*    ClkPolA behaves as always-on clock enable. */
+			| (MULT_X1 &lt;&lt; CRABIT_CLKMULT_A));	/*    ClkMult must be 1x. */
 		break;
 
-	default:		// Counter Mode:
-		cra |= (CLKSRC_COUNTER	//   Select ENC_C and ENC_D as clock/direction inputs.
-			| ((setup &amp; STDMSK_CLKPOL) &lt;&lt; (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	//   Clock polarity is passed through.
-			| (((setup &amp; STDMSK_CLKMULT) == (MULT_X0 &lt;&lt; STDBIT_CLKMULT)) ?	//   Force multiplier to x1 if not legal, otherwise pass through.
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+			| ((setup &amp; STDMSK_CLKPOL) &lt;&lt; (CRABIT_CLKPOL_A - STDBIT_CLKPOL))	/*    Clock polarity is passed through. */
+			| (((setup &amp; STDMSK_CLKMULT) == (MULT_X0 &lt;&lt; STDBIT_CLKMULT)) ?	/*    Force multiplier to x1 if not legal, otherwise pass through. */
 				(MULT_X1 &lt;&lt; CRABIT_CLKMULT_A) :
 				((setup &amp; STDMSK_CLKMULT) &lt;&lt; (CRABIT_CLKMULT_A -
 						STDBIT_CLKMULT))));
 	}
 
-	// Force positive index polarity if IndxSrc is software-driven only,
-	// otherwise pass it through.
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
 	if (~setup &amp; STDMSK_INDXSRC)
 		cra |= ((setup &amp; STDMSK_INDXPOL) &lt;&lt; (CRABIT_INDXPOL_A -
 				STDBIT_INDXPOL));
 
-	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	// enable mask to indicate the counter interrupt is disabled.
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
 	if (DisableIntSrc)
 		devpriv-&gt;CounterIntEnabs &amp;= ~k-&gt;MyEventBits[3];
 
-	// While retaining CounterB and LatchSrc configurations, program the
-	// new counter operating mode.
+	/*  While retaining CounterB and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
 	DEBIreplace(dev, k-&gt;MyCRA, CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B, cra);
 	DEBIreplace(dev, k-&gt;MyCRB,
 		(uint16_t) (~(CRBMSK_INTCTRL | CRBMSK_CLKENAB_A)), crb);
@@ -2938,65 +2938,64 @@ static void SetMode_B(comedi_device * dev, enc_private * k, uint16_t Setup,
 {
 	register uint16_t cra;
 	register uint16_t crb;
-	register uint16_t setup = Setup;	// Cache the Standard Setup.
+	register uint16_t setup = Setup;	/*  Cache the Standard Setup. */
 
-	// Initialize CRA and CRB images.
-	cra = ((setup &amp; STDMSK_INDXSRC) &lt;&lt; ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	// IndexSrc field is restricted to ENC_X or IndxPol.
+	/*  Initialize CRA and CRB images. */
+	cra = ((setup &amp; STDMSK_INDXSRC) &lt;&lt; ((CRABIT_INDXSRC_B + 1) - STDBIT_INDXSRC));	/*  IndexSrc field is restricted to ENC_X or IndxPol. */
 
-	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	// Reset event captures and disable interrupts.
-		| ((setup &amp; STDMSK_CLKENAB) &lt;&lt; (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	// Clock enable is passed through.
-		| ((setup &amp; STDMSK_LOADSRC) &gt;&gt; (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	// Preload trigger source is passed through.
+	crb = (CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B	/*  Reset event captures and disable interrupts. */
+		| ((setup &amp; STDMSK_CLKENAB) &lt;&lt; (CRBBIT_CLKENAB_B - STDBIT_CLKENAB))	/*  Clock enable is passed through. */
+		| ((setup &amp; STDMSK_LOADSRC) &gt;&gt; (STDBIT_LOADSRC - CRBBIT_LOADSRC_B)));	/*  Preload trigger source is passed through. */
 
-	// Force IntSrc to Disabled if DisableIntSrc is asserted.
+	/*  Force IntSrc to Disabled if DisableIntSrc is asserted. */
 	if (!DisableIntSrc)
 		crb |= ((setup &amp; STDMSK_INTSRC) &gt;&gt; (STDBIT_INTSRC -
 				CRBBIT_INTSRC_B));
 
-	// Populate all mode-dependent attributes of CRA &amp; CRB images.
+	/*  Populate all mode-dependent attributes of CRA &amp; CRB images. */
 	switch ((setup &amp; STDMSK_CLKSRC) &gt;&gt; STDBIT_CLKSRC) {
-	case CLKSRC_TIMER:	// Timer Mode:
-		cra |= ((2 &lt;&lt; CRABIT_CLKSRC_B)	//   ClkSrcB&lt;1&gt; selects system clock
-			| ((setup &amp; STDMSK_CLKPOL) &lt;&lt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction (ClkSrcB&lt;0&gt;) obtained from ClkPol.
-		crb |= ((1 &lt;&lt; CRBBIT_CLKPOL_B)	//   ClkPolB behaves as always-on clock enable.
-			| (MULT_X1 &lt;&lt; CRBBIT_CLKMULT_B));	//   ClkMultB must be 1x.
+	case CLKSRC_TIMER:	/*  Timer Mode: */
+		cra |= ((2 &lt;&lt; CRABIT_CLKSRC_B)	/*    ClkSrcB&lt;1&gt; selects system clock */
+			| ((setup &amp; STDMSK_CLKPOL) &lt;&lt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction (ClkSrcB&lt;0&gt;) obtained from ClkPol. */
+		crb |= ((1 &lt;&lt; CRBBIT_CLKPOL_B)	/*    ClkPolB behaves as always-on clock enable. */
+			| (MULT_X1 &lt;&lt; CRBBIT_CLKMULT_B));	/*    ClkMultB must be 1x. */
 		break;
 
-	case CLKSRC_EXTENDER:	// Extender Mode:
-		cra |= ((2 &lt;&lt; CRABIT_CLKSRC_B)	//   ClkSrcB source is OverflowA (same as "timer")
-			| ((setup &amp; STDMSK_CLKPOL) &lt;&lt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	//     with direction obtained from ClkPol.
-		crb |= ((1 &lt;&lt; CRBBIT_CLKPOL_B)	//   ClkPolB controls IndexB -- always set to active.
-			| (MULT_X0 &lt;&lt; CRBBIT_CLKMULT_B));	//   ClkMultB selects OverflowA as the clock source.
+	case CLKSRC_EXTENDER:	/*  Extender Mode: */
+		cra |= ((2 &lt;&lt; CRABIT_CLKSRC_B)	/*    ClkSrcB source is OverflowA (same as "timer") */
+			| ((setup &amp; STDMSK_CLKPOL) &lt;&lt; (CRABIT_CLKSRC_B - STDBIT_CLKPOL)));	/*      with direction obtained from ClkPol. */
+		crb |= ((1 &lt;&lt; CRBBIT_CLKPOL_B)	/*    ClkPolB controls IndexB -- always set to active. */
+			| (MULT_X0 &lt;&lt; CRBBIT_CLKMULT_B));	/*    ClkMultB selects OverflowA as the clock source. */
 		break;
 
-	default:		// Counter Mode:
-		cra |= (CLKSRC_COUNTER &lt;&lt; CRABIT_CLKSRC_B);	//   Select ENC_C and ENC_D as clock/direction inputs.
-		crb |= (((setup &amp; STDMSK_CLKPOL) &gt;&gt; (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	//   ClkPol is passed through.
-			| (((setup &amp; STDMSK_CLKMULT) == (MULT_X0 &lt;&lt; STDBIT_CLKMULT)) ?	//   Force ClkMult to x1 if not legal, otherwise pass through.
+	default:		/*  Counter Mode: */
+		cra |= (CLKSRC_COUNTER &lt;&lt; CRABIT_CLKSRC_B);	/*    Select ENC_C and ENC_D as clock/direction inputs. */
+		crb |= (((setup &amp; STDMSK_CLKPOL) &gt;&gt; (STDBIT_CLKPOL - CRBBIT_CLKPOL_B))	/*    ClkPol is passed through. */
+			| (((setup &amp; STDMSK_CLKMULT) == (MULT_X0 &lt;&lt; STDBIT_CLKMULT)) ?	/*    Force ClkMult to x1 if not legal, otherwise pass through. */
 				(MULT_X1 &lt;&lt; CRBBIT_CLKMULT_B) :
 				((setup &amp; STDMSK_CLKMULT) &lt;&lt; (CRBBIT_CLKMULT_B -
 						STDBIT_CLKMULT))));
 	}
 
-	// Force positive index polarity if IndxSrc is software-driven only,
-	// otherwise pass it through.
+	/*  Force positive index polarity if IndxSrc is software-driven only, */
+	/*  otherwise pass it through. */
 	if (~setup &amp; STDMSK_INDXSRC)
 		crb |= ((setup &amp; STDMSK_INDXPOL) &gt;&gt; (STDBIT_INDXPOL -
 				CRBBIT_INDXPOL_B));
 
-	// If IntSrc has been forced to Disabled, update the MISC2 interrupt
-	// enable mask to indicate the counter interrupt is disabled.
+	/*  If IntSrc has been forced to Disabled, update the MISC2 interrupt */
+	/*  enable mask to indicate the counter interrupt is disabled. */
 	if (DisableIntSrc)
 		devpriv-&gt;CounterIntEnabs &amp;= ~k-&gt;MyEventBits[3];
 
-	// While retaining CounterA and LatchSrc configurations, program the
-	// new counter operating mode.
+	/*  While retaining CounterA and LatchSrc configurations, program the */
+	/*  new counter operating mode. */
 	DEBIreplace(dev, k-&gt;MyCRA,
 		(uint16_t) (~(CRAMSK_INDXSRC_B | CRAMSK_CLKSRC_B)), cra);
 	DEBIreplace(dev, k-&gt;MyCRB, CRBMSK_CLKENAB_A | CRBMSK_LATCHSRC, crb);
 }
 
-////////////////////////////////////////////////////////////////////////
-// Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index.
+/*  Return/set a counter's enable.  enab: 0=always enabled, 1=enabled by index. */
 
 static void SetEnable_A(comedi_device * dev, enc_private * k, uint16_t enab)
 {
@@ -3023,10 +3022,10 @@ static uint16_t GetEnable_B(comedi_device * dev, enc_private * k)
 	return (DEBIread(dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_CLKENAB_B) &amp; 1;
 }
 
-////////////////////////////////////////////////////////////////////////
-// Return/set a counter pair's latch trigger source.  0: On read
-// access, 1: A index latches A, 2: B index latches B, 3: A overflow
-// latches B.
+/* Return/set a counter pair's latch trigger source.  0: On read
+ * access, 1: A index latches A, 2: B index latches B, 3: A overflow
+ * latches B.
+ */
 
 static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
 {
@@ -3038,15 +3037,18 @@ static void SetLatchSource(comedi_device * dev, enc_private * k, uint16_t value)
 	DEBUG("SetLatchSource: SetLatchSource exit \n");
 }
 
-/* static uint16_t GetLatchSource(comedi_device *dev, enc_private *k ) */
-/* { */
-/*   return ( DEBIread( dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_LATCHSRC ) &amp; 3; */
-/* } */
+/*
+ * static uint16_t GetLatchSource(comedi_device *dev, enc_private *k )
+ * {
+ * 	return ( DEBIread( dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_LATCHSRC ) &amp; 3;
+ * }
+ */
 
-/////////////////////////////////////////////////////////////////////////
-// Return/set the event that will trigger transfer of the preload
-// register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
-// 2=OverflowA (B counters only), 3=disabled.
+/*
+ * Return/set the event that will trigger transfer of the preload
+ * register into the counter.  0=ThisCntr_Index, 1=ThisCntr_Overflow,
+ * 2=OverflowA (B counters only), 3=disabled.
+ */
 
 static void SetLoadTrig_A(comedi_device * dev, enc_private * k, uint16_t Trig)
 {
@@ -3071,23 +3073,23 @@ static uint16_t GetLoadTrig_B(comedi_device * dev, enc_private * k)
 	return (DEBIread(dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_LOADSRC_B) &amp; 3;
 }
 
-////////////////////
-// Return/set counter interrupt source and clear any captured
-// index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
-// 2=IndexOnly, 3=IndexAndOverflow.
+/* Return/set counter interrupt source and clear any captured
+ * index/overflow events.  IntSource: 0=Disabled, 1=OverflowOnly,
+ * 2=IndexOnly, 3=IndexAndOverflow.
+ */
 
 static void SetIntSrc_A(comedi_device * dev, enc_private * k,
 	uint16_t IntSource)
 {
-	// Reset any pending counter overflow or index captures.
+	/*  Reset any pending counter overflow or index captures. */
 	DEBIreplace(dev, k-&gt;MyCRB, (uint16_t) (~CRBMSK_INTCTRL),
 		CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A);
 
-	// Program counter interrupt source.
+	/*  Program counter interrupt source. */
 	DEBIreplace(dev, k-&gt;MyCRA, ~CRAMSK_INTSRC_A,
 		(uint16_t) (IntSource &lt;&lt; CRABIT_INTSRC_A));
 
-	// Update MISC2 interrupt enable mask.
+	/*  Update MISC2 interrupt enable mask. */
 	devpriv-&gt;CounterIntEnabs =
 		(devpriv-&gt;CounterIntEnabs &amp; ~k-&gt;MyEventBits[3]) | k-&gt;
 		MyEventBits[IntSource];
@@ -3098,19 +3100,19 @@ static void SetIntSrc_B(comedi_device * dev, enc_private * k,
 {
 	uint16_t crb;
 
-	// Cache writeable CRB register image.
+	/*  Cache writeable CRB register image. */
 	crb = DEBIread(dev, k-&gt;MyCRB) &amp; ~CRBMSK_INTCTRL;
 
-	// Reset any pending counter overflow or index captures.
+	/*  Reset any pending counter overflow or index captures. */
 	DEBIwrite(dev, k-&gt;MyCRB,
 		(uint16_t) (crb | CRBMSK_INTRESETCMD | CRBMSK_INTRESET_B));
 
-	// Program counter interrupt source.
+	/*  Program counter interrupt source. */
 	DEBIwrite(dev, k-&gt;MyCRB,
 		(uint16_t) ((crb &amp; ~CRBMSK_INTSRC_B) | (IntSource &lt;&lt;
 				CRBBIT_INTSRC_B)));
 
-	// Update MISC2 interrupt enable mask.
+	/*  Update MISC2 interrupt enable mask. */
 	devpriv-&gt;CounterIntEnabs =
 		(devpriv-&gt;CounterIntEnabs &amp; ~k-&gt;MyEventBits[3]) | k-&gt;
 		MyEventBits[IntSource];
@@ -3126,8 +3128,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 	return (DEBIread(dev, k-&gt;MyCRB) &gt;&gt; CRBBIT_INTSRC_B) &amp; 3;
 }
 
-/////////////////////////////////////////////////////////////////////////
-// Return/set the clock multiplier.
+/*  Return/set the clock multiplier. */
 
 /* static void SetClkMult(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3139,8 +3140,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_CLKMULT ) &amp; 3; */
 /* } */
 
-/* ////////////////////////////////////////////////////////////////////////// */
-/* // Return/set the clock polarity. */
+/* Return/set the clock polarity. */
 
 /* static void SetClkPol( comedi_device *dev,enc_private *k, uint16_t value )  */
 /* { */
@@ -3152,8 +3152,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_CLKPOL ) &amp; 1; */
 /* } */
 
-/* /////////////////////////////////////////////////////////////////////// */
-/* // Return/set the clock source. */
+/* Return/set the clock source.  */
 
 /* static void SetClkSrc( comedi_device *dev,enc_private *k, uint16_t value )  */
 /* { */
@@ -3165,8 +3164,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_CLKSRC ) &amp; 3; */
 /* } */
 
-/* //////////////////////////////////////////////////////////////////////// */
-/* // Return/set the index polarity. */
+/* Return/set the index polarity. */
 
 /* static void SetIndexPol(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3178,8 +3176,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_INDXPOL ) &amp; 1; */
 /* } */
 
-/* //////////////////////////////////////////////////////////////////////// */
-/* // Return/set the index source. */
+/*  Return/set the index source. */
 
 /* static void SetIndexSrc(comedi_device *dev, enc_private *k, uint16_t value )  */
 /* { */
@@ -3192,8 +3189,7 @@ static uint16_t GetIntSrc_B(comedi_device * dev, enc_private * k)
 /*   return ( k-&gt;GetMode(dev, k ) &gt;&gt; STDBIT_INDXSRC ) &amp; 1; */
 /* } */
 
-///////////////////////////////////////////////////////////////////
-// Generate an index pulse.
+/*  Generate an index pulse. */
 
 static void PulseIndex_A(comedi_device * dev, enc_private * k)
 {
@@ -3201,7 +3197,7 @@ static void PulseIndex_A(comedi_device * dev, enc_private * k)
 
 	DEBUG("PulseIndex_A: pulse index enter\n");
 
-	cra = DEBIread(dev, k-&gt;MyCRA);	// Pulse index.
+	cra = DEBIread(dev, k-&gt;MyCRA);	/*  Pulse index. */
 	DEBIwrite(dev, k-&gt;MyCRA, (uint16_t) (cra ^ CRAMSK_INDXPOL_A));
 	DEBUG("PulseIndex_A: pulse index step1\n");
 	DEBIwrite(dev, k-&gt;MyCRA, cra);
@@ -3211,18 +3207,17 @@ static void PulseIndex_B(comedi_device * dev, enc_private * k)
 {
 	register uint16_t crb;
 
-	crb = DEBIread(dev, k-&gt;MyCRB) &amp; ~CRBMSK_INTCTRL;	// Pulse index.
+	crb = DEBIread(dev, k-&gt;MyCRB) &amp; ~CRBMSK_INTCTRL;	/*  Pulse index. */
 	DEBIwrite(dev, k-&gt;MyCRB, (uint16_t) (crb ^ CRBMSK_INDXPOL_B));
 	DEBIwrite(dev, k-&gt;MyCRB, crb);
 }
 
-/////////////////////////////////////////////////////////
-// Write value into counter preload register.
+/*  Write value into counter preload register. */
 
 static void Preload(comedi_device * dev, enc_private * k, uint32_t value)
 {
 	DEBUG("Preload: preload enter\n");
-	DEBIwrite(dev, (uint16_t) (k-&gt;MyLatchLsw), (uint16_t) value);	// Write value to preload register.
+	DEBIwrite(dev, (uint16_t) (k-&gt;MyLatchLsw), (uint16_t) value);	/*  Write value to preload register. */
 	DEBUG("Preload: preload step 1\n");
 	DEBIwrite(dev, (uint16_t) (k-&gt;MyLatchLsw + 2),
 		(uint16_t) (value &gt;&gt; 16));
@@ -3232,16 +3227,16 @@ static void CountersInit(comedi_device * dev)
 {
 	int chan;
 	enc_private *k;
-	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	// Preload upon
-		// index.
-		(INDXSRC_SOFT &lt;&lt; BF_INDXSRC) |	// Disable hardware index.
-		(CLKSRC_COUNTER &lt;&lt; BF_CLKSRC) |	// Operating mode is counter.
-		(CLKPOL_POS &lt;&lt; BF_CLKPOL) |	// Active high clock.
-		(CNTDIR_UP &lt;&lt; BF_CLKPOL) |	// Count direction is up.
-		(CLKMULT_1X &lt;&lt; BF_CLKMULT) |	// Clock multiplier is 1x.
-		(CLKENAB_INDEX &lt;&lt; BF_CLKENAB);	// Enabled by index
-
-	// Disable all counter interrupts and clear any captured counter events.
+	uint16_t Setup = (LOADSRC_INDX &lt;&lt; BF_LOADSRC) |	/*  Preload upon */
+		/*  index. */
+		(INDXSRC_SOFT &lt;&lt; BF_INDXSRC) |	/*  Disable hardware index. */
+		(CLKSRC_COUNTER &lt;&lt; BF_CLKSRC) |	/*  Operating mode is counter. */
+		(CLKPOL_POS &lt;&lt; BF_CLKPOL) |	/*  Active high clock. */
+		(CNTDIR_UP &lt;&lt; BF_CLKPOL) |	/*  Count direction is up. */
+		(CLKMULT_1X &lt;&lt; BF_CLKMULT) |	/*  Clock multiplier is 1x. */
+		(CLKENAB_INDEX &lt;&lt; BF_CLKENAB);	/*  Enabled by index */
+
+	/*  Disable all counter interrupts and clear any captured counter events. */
 	for (chan = 0; chan &lt; S626_ENCODER_CHANNELS; chan++) {
 		k = &amp;encpriv[chan];
 		k-&gt;SetMode(dev, k, Setup, TRUE);
diff --git a/drivers/staging/comedi/drivers/s626.h b/drivers/staging/comedi/drivers/s626.h
index 11d8b1ceb0b8..7a88bb35b50b 100644
--- a/drivers/staging/comedi/drivers/s626.h
+++ b/drivers/staging/comedi/drivers/s626.h
@@ -51,15 +51,15 @@
 
    Example code
 
-   insn.insn=INSN_CONFIG;   //configuration instruction
-   insn.n=1;                //number of operation (must be 1)
-   insn.data=&amp;initialvalue; //initial value loaded into encoder
-                            //during configuration
-   insn.subdev=5;           //encoder subdevice
-   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); //encoder_channel
-                                                        //to configure
-
-   comedi_do_insn(cf,&amp;insn); //executing configuration
+   insn.insn=INSN_CONFIG;   // configuration instruction
+   insn.n=1;                // number of operation (must be 1)
+   insn.data=&amp;initialvalue; // initial value loaded into encoder
+                            // during configuration
+   insn.subdev=5;           // encoder subdevice
+   insn.chanspec=CR_PACK(encoder_channel,0,AREF_OTHER); // encoder_channel
+                                                        // to configure
+
+   comedi_do_insn(cf,&amp;insn); // executing configuration
 */
 
 #ifdef _DEBUG_
@@ -88,147 +88,136 @@
 #define INLINE static __inline
 #endif
 
-/////////////////////////////////////////////////////
 #include&lt;linux/slab.h&gt;
 
 #define S626_SIZE 0x0200
 #define SIZEOF_ADDRESS_SPACE		0x0200
-#define DMABUF_SIZE			4096	// 4k pages
+#define DMABUF_SIZE			4096	/*  4k pages */
 
 #define S626_ADC_CHANNELS       16
 #define S626_DAC_CHANNELS       4
 #define S626_ENCODER_CHANNELS   6
 #define S626_DIO_CHANNELS       48
-#define S626_DIO_BANKS		3	// Number of DIO groups.
-#define S626_DIO_EXTCHANS	40	// Number of
-					// extended-capability
-					// DIO channels.
+#define S626_DIO_BANKS		3	/*  Number of DIO groups. */
+#define S626_DIO_EXTCHANS	40	/*  Number of */
+					/*  extended-capability */
+					/*  DIO channels. */
 
-#define NUM_TRIMDACS	12	// Number of valid TrimDAC channels.
+#define NUM_TRIMDACS	12	/*  Number of valid TrimDAC channels. */
 
-// PCI bus interface types.
-#define INTEL				1	// Intel bus type.
-#define MOTOROLA			2	// Motorola bus type.
+/*  PCI bus interface types. */
+#define INTEL				1	/*  Intel bus type. */
+#define MOTOROLA			2	/*  Motorola bus type. */
 
-//////////////////////////////////////////////////////////
+#define PLATFORM		INTEL	/*  *** SELECT PLATFORM TYPE *** */
 
-//////////////////////////////////////////////////////////
-#define PLATFORM		INTEL	// *** SELECT PLATFORM TYPE ***
-//////////////////////////////////////////////////////////
+#define RANGE_5V                0x10	/*  +/-5V range */
+#define RANGE_10V               0x00	/*  +/-10V range */
 
-#define RANGE_5V                0x10	// +/-5V range
-#define RANGE_10V               0x00	// +/-10V range
+#define EOPL			0x80	/*  End of ADC poll list marker. */
+#define GSEL_BIPOLAR5V		0x00F0	/*  LP_GSEL setting for 5V bipolar range. */
+#define GSEL_BIPOLAR10V		0x00A0	/*  LP_GSEL setting for 10V bipolar range. */
 
-#define EOPL			0x80	// End of ADC poll list marker.
-#define GSEL_BIPOLAR5V		0x00F0	// LP_GSEL setting for 5V bipolar range.
-#define GSEL_BIPOLAR10V		0x00A0	// LP_GSEL setting for 10V bipolar range.
+/*  Error codes that must be visible to this base class. */
+#define ERR_ILLEGAL_PARM	0x00010000	/*  Illegal function parameter value was specified. */
+#define ERR_I2C			0x00020000	/*  I2C error. */
+#define ERR_COUNTERSETUP	0x00200000	/*  Illegal setup specified for counter channel. */
+#define ERR_DEBI_TIMEOUT	0x00400000	/*  DEBI transfer timed out. */
 
-// Error codes that must be visible to this base class.
-#define ERR_ILLEGAL_PARM	0x00010000	// Illegal function parameter value was specified.
-#define ERR_I2C			0x00020000	// I2C error.
-#define ERR_COUNTERSETUP	0x00200000	// Illegal setup specified for counter channel.
-#define ERR_DEBI_TIMEOUT	0x00400000	// DEBI transfer timed out.
+/*  Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF. */
+#define ADC_DMABUF_DWORDS	40	/*  ADC DMA buffer must hold 16 samples, plus pre/post garbage samples. */
+#define DAC_WDMABUF_DWORDS	1	/*  DAC output DMA buffer holds a single sample. */
 
-// Organization (physical order) and size (in DWORDs) of logical DMA buffers contained by ANA_DMABUF.
-#define ADC_DMABUF_DWORDS	40	// ADC DMA buffer must hold 16 samples, plus pre/post garbage samples.
-#define DAC_WDMABUF_DWORDS	1	// DAC output DMA buffer holds a single sample.
+/*  All remaining space in 4KB DMA buffer is available for the RPS1 program. */
 
-// All remaining space in 4KB DMA buffer is available for the RPS1 program.
-
-// Address offsets, in DWORDS, from base of DMA buffer.
+/*  Address offsets, in DWORDS, from base of DMA buffer. */
 #define DAC_WDMABUF_OS		ADC_DMABUF_DWORDS
 
-// Interrupt enab bit in ISR and IER.
-#define IRQ_GPIO3		0x00000040	// IRQ enable for GPIO3.
+/*  Interrupt enab bit in ISR and IER. */
+#define IRQ_GPIO3		0x00000040  /*  IRQ enable for GPIO3. */
 #define IRQ_RPS1                0x10000000
-#define ISR_AFOU		0x00000800	// Audio fifo
-						// under/overflow
-						// detected.
-#define IRQ_COINT1A             0x0400	// conter 1A overflow
-						// interrupt mask
-#define IRQ_COINT1B             0x0800	// conter 1B overflow
-						// interrupt mask
-#define IRQ_COINT2A             0x1000	// conter 2A overflow
-						// interrupt mask
-#define IRQ_COINT2B             0x2000	// conter 2B overflow
-						// interrupt mask
-#define IRQ_COINT3A             0x4000	// conter 3A overflow
-						// interrupt mask
-#define IRQ_COINT3B             0x8000	// conter 3B overflow
-						// interrupt mask
-
-// RPS command codes.
-#define RPS_CLRSIGNAL		0x00000000	// CLEAR SIGNAL
-#define RPS_SETSIGNAL		0x10000000	// SET SIGNAL
-#define RPS_NOP			0x00000000	// NOP
-#define RPS_PAUSE		0x20000000	// PAUSE
-#define RPS_UPLOAD		0x40000000	// UPLOAD
-#define RPS_JUMP		0x80000000	// JUMP
-#define RPS_LDREG		0x90000100	// LDREG (1 uint32_t only)
-#define RPS_STREG		0xA0000100	// STREG (1 uint32_t only)
-#define RPS_STOP		0x50000000	// STOP
-#define RPS_IRQ                 0x60000000	// IRQ
-
-#define RPS_LOGICAL_OR		0x08000000	// Logical OR conditionals.
-#define RPS_INVERT		0x04000000	// Test for negated semaphores.
-#define RPS_DEBI		0x00000002	// DEBI done
-
-#define RPS_SIG0		0x00200000	// RPS semaphore 0 (used by ADC).
-#define RPS_SIG1		0x00400000	// RPS semaphore 1 (used by DAC).
-#define RPS_SIG2		0x00800000	// RPS semaphore 2 (not used).
-#define RPS_GPIO2		0x00080000	// RPS GPIO2
-#define RPS_GPIO3		0x00100000	// RPS GPIO3
-
-#define RPS_SIGADC		RPS_SIG0	// Trigger/status for ADC's RPS program.
-#define RPS_SIGDAC		RPS_SIG1	// Trigger/status for DAC's RPS program.
-
-// RPS clock parameters.
-#define RPSCLK_SCALAR		8	// This is apparent ratio of PCI/RPS clks (undocumented!!).
-#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	// Number of RPS clocks in one microsecond.
-
-// Event counter source addresses.
-#define SBA_RPS_A0		0x27	// Time of RPS0 busy, in PCI clocks.
-
-// GPIO constants.
-#define GPIO_BASE		0x10004000	// GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out.
-#define GPIO1_LO		0x00000000	// GPIO1 set to LOW.
-#define GPIO1_HI		0x00001000	// GPIO1 set to HIGH.
-
-// Primary Status Register (PSR) constants.
-#define PSR_DEBI_E		0x00040000	// DEBI event flag.
-#define PSR_DEBI_S		0x00080000	// DEBI status flag.
-#define PSR_A2_IN		0x00008000	// Audio output DMA2 protection address reached.
-#define PSR_AFOU		0x00000800	// Audio FIFO under/overflow detected.
-#define PSR_GPIO2		0x00000020	// GPIO2 input pin: 0=AdcBusy, 1=AdcIdle.
-#define PSR_EC0S		0x00000001	// Event counter 0 threshold reached.
-
-// Secondary Status Register (SSR) constants.
-#define SSR_AF2_OUT		0x00000200	// Audio 2 output FIFO under/overflow detected.
-
-// Master Control Register 1 (MC1) constants.
-#define MC1_SOFT_RESET		0x80000000	// Invoke 7146 soft reset.
-#define MC1_SHUTDOWN		0x3FFF0000	// Shut down all MC1-controlled enables.
-
-#define MC1_ERPS1		0x2000	// enab/disable RPS task 1.
-#define MC1_ERPS0		0x1000	// enab/disable RPS task 0.
-#define MC1_DEBI		0x0800	// enab/disable DEBI pins.
-#define MC1_AUDIO		0x0200	// enab/disable audio port pins.
-#define MC1_I2C			0x0100	// enab/disable I2C interface.
-#define MC1_A2OUT		0x0008	// enab/disable transfer on A2 out.
-#define MC1_A2IN		0x0004	// enab/disable transfer on A2 in.
-#define MC1_A1IN		0x0001	// enab/disable transfer on A1 in.
-
-// Master Control Register 2 (MC2) constants.
-#define MC2_UPLD_DEBIq		0x00020002	// Upload DEBI registers.
-#define MC2_UPLD_IICq		0x00010001	// Upload I2C registers.
-#define MC2_RPSSIG2_ONq		0x20002000	// Assert RPS_SIG2.
-#define MC2_RPSSIG1_ONq		0x10001000	// Assert RPS_SIG1.
-#define MC2_RPSSIG0_ONq		0x08000800	// Assert RPS_SIG0.
-#define MC2_UPLD_DEBI_MASKq	0x00000002	// Upload DEBI mask.
-#define MC2_UPLD_IIC_MASKq	0x00000001	// Upload I2C mask.
-#define MC2_RPSSIG2_MASKq	0x00002000	// RPS_SIG2 bit mask.
-#define MC2_RPSSIG1_MASKq	0x00001000	// RPS_SIG1 bit mask.
-#define MC2_RPSSIG0_MASKq	0x00000800	// RPS_SIG0 bit mask.
+#define ISR_AFOU		0x00000800
+/* Audio fifo under/overflow  detected. */
+
+#define IRQ_COINT1A             0x0400 /* conter 1A overflow interrupt mask */
+#define IRQ_COINT1B             0x0800 /* conter 1B overflow interrupt mask */
+#define IRQ_COINT2A             0x1000 /* conter 2A overflow interrupt mask */
+#define IRQ_COINT2B             0x2000 /* conter 2B overflow interrupt mask */
+#define IRQ_COINT3A             0x4000 /* conter 3A overflow interrupt mask */
+#define IRQ_COINT3B             0x8000 /* conter 3B overflow interrupt mask */
+
+/*  RPS command codes. */
+#define RPS_CLRSIGNAL		0x00000000	/*  CLEAR SIGNAL */
+#define RPS_SETSIGNAL		0x10000000	/*  SET SIGNAL */
+#define RPS_NOP			0x00000000	/*  NOP */
+#define RPS_PAUSE		0x20000000	/*  PAUSE */
+#define RPS_UPLOAD		0x40000000	/*  UPLOAD */
+#define RPS_JUMP		0x80000000	/*  JUMP */
+#define RPS_LDREG		0x90000100	/*  LDREG (1 uint32_t only) */
+#define RPS_STREG		0xA0000100	/*  STREG (1 uint32_t only) */
+#define RPS_STOP		0x50000000	/*  STOP */
+#define RPS_IRQ                 0x60000000	/*  IRQ */
+
+#define RPS_LOGICAL_OR		0x08000000	/*  Logical OR conditionals. */
+#define RPS_INVERT		0x04000000	/*  Test for negated semaphores. */
+#define RPS_DEBI		0x00000002	/*  DEBI done */
+
+#define RPS_SIG0		0x00200000	/*  RPS semaphore 0 (used by ADC). */
+#define RPS_SIG1		0x00400000	/*  RPS semaphore 1 (used by DAC). */
+#define RPS_SIG2		0x00800000	/*  RPS semaphore 2 (not used). */
+#define RPS_GPIO2		0x00080000	/*  RPS GPIO2 */
+#define RPS_GPIO3		0x00100000	/*  RPS GPIO3 */
+
+#define RPS_SIGADC		RPS_SIG0	/*  Trigger/status for ADC's RPS program. */
+#define RPS_SIGDAC		RPS_SIG1	/*  Trigger/status for DAC's RPS program. */
+
+/*  RPS clock parameters. */
+#define RPSCLK_SCALAR		8	/*  This is apparent ratio of PCI/RPS clks (undocumented!!). */
+#define RPSCLK_PER_US		( 33 / RPSCLK_SCALAR )	/*  Number of RPS clocks in one microsecond. */
+
+/*  Event counter source addresses. */
+#define SBA_RPS_A0		0x27	/*  Time of RPS0 busy, in PCI clocks. */
+
+/*  GPIO constants. */
+#define GPIO_BASE		0x10004000	/*  GPIO 0,2,3 = inputs, GPIO3 = IRQ; GPIO1 = out. */
+#define GPIO1_LO		0x00000000	/*  GPIO1 set to LOW. */
+#define GPIO1_HI		0x00001000	/*  GPIO1 set to HIGH. */
+
+/*  Primary Status Register (PSR) constants. */
+#define PSR_DEBI_E		0x00040000	/*  DEBI event flag. */
+#define PSR_DEBI_S		0x00080000	/*  DEBI status flag. */
+#define PSR_A2_IN		0x00008000	/*  Audio output DMA2 protection address reached. */
+#define PSR_AFOU		0x00000800	/*  Audio FIFO under/overflow detected. */
+#define PSR_GPIO2		0x00000020	/*  GPIO2 input pin: 0=AdcBusy, 1=AdcIdle. */
+#define PSR_EC0S		0x00000001	/*  Event counter 0 threshold reached. */
+
+/*  Secondary Status Register (SSR) constants. */
+#define SSR_AF2_OUT		0x00000200	/*  Audio 2 output FIFO under/overflow detected. */
+
+/*  Master Control Register 1 (MC1) constants. */
+#define MC1_SOFT_RESET		0x80000000	/*  Invoke 7146 soft reset. */
+#define MC1_SHUTDOWN		0x3FFF0000	/*  Shut down all MC1-controlled enables. */
+
+#define MC1_ERPS1		0x2000	/*  enab/disable RPS task 1. */
+#define MC1_ERPS0		0x1000	/*  enab/disable RPS task 0. */
+#define MC1_DEBI		0x0800	/*  enab/disable DEBI pins. */
+#define MC1_AUDIO		0x0200	/*  enab/disable audio port pins. */
+#define MC1_I2C			0x0100	/*  enab/disable I2C interface. */
+#define MC1_A2OUT		0x0008	/*  enab/disable transfer on A2 out. */
+#define MC1_A2IN		0x0004	/*  enab/disable transfer on A2 in. */
+#define MC1_A1IN		0x0001	/*  enab/disable transfer on A1 in. */
+
+/*  Master Control Register 2 (MC2) constants. */
+#define MC2_UPLD_DEBIq		0x00020002	/*  Upload DEBI registers. */
+#define MC2_UPLD_IICq		0x00010001	/*  Upload I2C registers. */
+#define MC2_RPSSIG2_ONq		0x20002000	/*  Assert RPS_SIG2. */
+#define MC2_RPSSIG1_ONq		0x10001000	/*  Assert RPS_SIG1. */
+#define MC2_RPSSIG0_ONq		0x08000800	/*  Assert RPS_SIG0. */
+#define MC2_UPLD_DEBI_MASKq	0x00000002	/*  Upload DEBI mask. */
+#define MC2_UPLD_IIC_MASKq	0x00000001	/*  Upload I2C mask. */
+#define MC2_RPSSIG2_MASKq	0x00002000	/*  RPS_SIG2 bit mask. */
+#define MC2_RPSSIG1_MASKq	0x00001000	/*  RPS_SIG1 bit mask. */
+#define MC2_RPSSIG0_MASKq	0x00000800	/*  RPS_SIG0 bit mask. */
 
 #define MC2_DELAYTRIG_4USq	MC2_RPSSIG1_ON
 #define MC2_DELAYBUSY_4USq	MC2_RPSSIG1_MASK
@@ -236,469 +225,425 @@
 #define	MC2_DELAYTRIG_6USq	MC2_RPSSIG2_ON
 #define MC2_DELAYBUSY_6USq	MC2_RPSSIG2_MASK
 
-#define MC2_UPLD_DEBI		0x0002	// Upload DEBI.
-#define MC2_UPLD_IIC		0x0001	// Upload I2C.
-#define MC2_RPSSIG2		0x2000	// RPS signal 2 (not used).
-#define MC2_RPSSIG1		0x1000	// RPS signal 1 (DAC RPS busy).
-#define MC2_RPSSIG0		0x0800	// RPS signal 0 (ADC RPS busy).
-
-#define MC2_ADC_RPS		MC2_RPSSIG0	// ADC RPS busy.
-#define MC2_DAC_RPS		MC2_RPSSIG1	// DAC RPS busy.
-
-///////////////////oldies///////////
-#define MC2_UPLD_DEBIQ		0x00020002	// Upload DEBI registers.
-#define MC2_UPLD_IICQ		0x00010001	// Upload I2C registers.
-////////////////////////////////////////
-
-// PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS ////////////////////////
-#define P_PCI_BT_A		0x004C	// Audio DMA
-						// burst/threshold
-						// control.
-#define P_DEBICFG               0x007C	// DEBI configuration.
-#define P_DEBICMD               0x0080	// DEBI command.
-#define P_DEBIPAGE              0x0084	// DEBI page.
-#define P_DEBIAD                0x0088	// DEBI target address.
-#define P_I2CCTRL               0x008C	// I2C control.
-#define P_I2CSTAT               0x0090	// I2C status.
-#define P_BASEA2_IN		0x00AC	// Audio input 2 base
-						// physical DMAbuf
-						// address.
-#define P_PROTA2_IN		0x00B0	// Audio input 2
-						// physical DMAbuf
-						// protection address.
-#define P_PAGEA2_IN		0x00B4	// Audio input 2
-						// paging attributes.
-#define P_BASEA2_OUT		0x00B8	// Audio output 2 base
-						// physical DMAbuf
-						// address.
-#define P_PROTA2_OUT		0x00BC	// Audio output 2
-						// physical DMAbuf
-						// protection address.
-#define P_PAGEA2_OUT		0x00C0	// Audio output 2
-						// paging attributes.
-#define P_RPSPAGE0              0x00C4	// RPS0 page.
-#define P_RPSPAGE1              0x00C8	// RPS1 page.
-#define P_RPS0_TOUT		0x00D4	// RPS0 time-out.
-#define P_RPS1_TOUT		0x00D8	// RPS1 time-out.
-#define P_IER                   0x00DC	// Interrupt enable.
-#define P_GPIO                  0x00E0	// General-purpose I/O.
-#define P_EC1SSR		0x00E4	// Event counter set 1
-						// source select.
-#define P_ECT1R			0x00EC	// Event counter
-						// threshold set 1.
-#define P_ACON1                 0x00F4	// Audio control 1.
-#define P_ACON2                 0x00F8	// Audio control 2.
-#define P_MC1                   0x00FC	// Master control 1.
-#define P_MC2                   0x0100	// Master control 2.
-#define P_RPSADDR0              0x0104	// RPS0 instruction pointer.
-#define P_RPSADDR1              0x0108	// RPS1 instruction pointer.
-#define P_ISR                   0x010C	// Interrupt status.
-#define P_PSR                   0x0110	// Primary status.
-#define P_SSR                   0x0114	// Secondary status.
-#define P_EC1R			0x0118	// Event counter set 1.
-#define P_ADP4			0x0138	// Logical audio DMA
-						// pointer of audio
-						// input FIFO A2_IN.
-#define P_FB_BUFFER1            0x0144	// Audio feedback buffer 1.
-#define P_FB_BUFFER2            0x0148	// Audio feedback buffer 2.
-#define P_TSL1                  0x0180	// Audio time slot list 1.
-#define P_TSL2                  0x01C0	// Audio time slot list 2.
-
-// LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS /////////////////
-// Analog I/O registers:
-#define LP_DACPOL		0x0082	//  Write DAC polarity.
-#define LP_GSEL			0x0084	//  Write ADC gain.
-#define LP_ISEL			0x0086	//  Write ADC channel select.
-// Digital I/O (write only):
-#define LP_WRINTSELA		0x0042	//  Write A interrupt enable.
-#define LP_WREDGSELA		0x0044	//  Write A edge selection.
-#define LP_WRCAPSELA		0x0046	//  Write A capture enable.
-#define LP_WRDOUTA		0x0048	//  Write A digital output.
-#define LP_WRINTSELB		0x0052	//  Write B interrupt enable.
-#define LP_WREDGSELB		0x0054	//  Write B edge selection.
-#define LP_WRCAPSELB		0x0056	//  Write B capture enable.
-#define LP_WRDOUTB		0x0058	//  Write B digital output.
-#define LP_WRINTSELC		0x0062	//  Write C interrupt enable.
-#define LP_WREDGSELC		0x0064	//  Write C edge selection.
-#define LP_WRCAPSELC		0x0066	//  Write C capture enable.
-#define LP_WRDOUTC		0x0068	//  Write C digital output.
-
-// Digital I/O (read only):
-#define LP_RDDINA		0x0040	//  Read digital input.
-#define LP_RDCAPFLGA		0x0048	//  Read edges captured.
-#define LP_RDINTSELA		0x004A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELA		0x004C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELA		0x004E	//  Read capture
-						//  enable register.
-#define LP_RDDINB		0x0050	//  Read digital input.
-#define LP_RDCAPFLGB		0x0058	//  Read edges captured.
-#define LP_RDINTSELB		0x005A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELB		0x005C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELB		0x005E	//  Read capture
-						//  enable register.
-#define LP_RDDINC		0x0060	//  Read digital input.
-#define LP_RDCAPFLGC		0x0068	//  Read edges captured.
-#define LP_RDINTSELC		0x006A	//  Read interrupt
-						//  enable register.
-#define LP_RDEDGSELC		0x006C	//  Read edge
-						//  selection
-						//  register.
-#define LP_RDCAPSELC		0x006E	//  Read capture
-						//  enable register.
-// Counter Registers (read/write):
-#define LP_CR0A			0x0000	//  0A setup register.
-#define LP_CR0B			0x0002	//  0B setup register.
-#define LP_CR1A			0x0004	//  1A setup register.
-#define LP_CR1B			0x0006	//  1B setup register.
-#define LP_CR2A			0x0008	//  2A setup register.
-#define LP_CR2B			0x000A	//  2B setup register.
-// Counter PreLoad (write) and Latch (read) Registers:
-#define	LP_CNTR0ALSW		0x000C	//  0A lsw.
-#define	LP_CNTR0AMSW		0x000E	//  0A msw.
-#define	LP_CNTR0BLSW		0x0010	//  0B lsw.
-#define	LP_CNTR0BMSW		0x0012	//  0B msw.
-#define	LP_CNTR1ALSW		0x0014	//  1A lsw.
-#define	LP_CNTR1AMSW		0x0016	//  1A msw.
-#define	LP_CNTR1BLSW		0x0018	//  1B lsw.
-#define	LP_CNTR1BMSW		0x001A	//  1B msw.
-#define	LP_CNTR2ALSW		0x001C	//  2A lsw.
-#define	LP_CNTR2AMSW		0x001E	//  2A msw.
-#define	LP_CNTR2BLSW		0x0020	//  2B lsw.
-#define	LP_CNTR2BMSW		0x0022	//  2B msw.
-// Miscellaneous Registers (read/write):
-#define LP_MISC1		0x0088	//  Read/write Misc1.
-#define LP_WRMISC2		0x0090	//  Write Misc2.
-#define LP_RDMISC2		0x0082	//  Read Misc2.
-
-// Bit masks for MISC1 register that are the same for reads and writes.
-#define MISC1_WENABLE		0x8000	// enab writes to
-						// MISC2 (except Clear
-						// Watchdog bit).
-#define MISC1_WDISABLE		0x0000	// Disable writes to MISC2.
-#define MISC1_EDCAP		0x1000	// enab edge capture
-						// on DIO chans
-						// specified by
-						// LP_WRCAPSELx.
-#define MISC1_NOEDCAP		0x0000	// Disable edge
-						// capture on
-						// specified DIO
-						// chans.
-
-// Bit masks for MISC1 register reads.
-#define RDMISC1_WDTIMEOUT	0x4000	// Watchdog timer timed out.
-
-// Bit masks for MISC2 register writes.
-#define WRMISC2_WDCLEAR		0x8000	// Reset watchdog
-						// timer to zero.
-#define WRMISC2_CHARGE_ENABLE	0x4000	// enab battery
-						// trickle charging.
-
-// Bit masks for MISC2 register that are the same for reads and writes.
-#define MISC2_BATT_ENABLE	0x0008	// Backup battery enable.
-#define MISC2_WDENABLE		0x0004	// Watchdog timer enable.
-#define MISC2_WDPERIOD_MASK	0x0003	// Watchdog interval
-						// select mask.
-
-// Bit masks for ACON1 register.
-#define A2_RUN			0x40000000	// Run A2 based on TSL2.
-#define A1_RUN			0x20000000	// Run A1 based on TSL1.
-#define A1_SWAP			0x00200000	// Use big-endian for A1.
-#define A2_SWAP			0x00100000	// Use big-endian for A2.
-#define WS_MODES		0x00019999	// WS0 = TSL1 trigger
-						// input, WS1-WS4 =
-						// CS* outputs.
-
-#if PLATFORM == INTEL		// Base ACON1 config:
-						// always run A1 based
-						// on TSL1.
+#define MC2_UPLD_DEBI		0x0002	/*  Upload DEBI. */
+#define MC2_UPLD_IIC		0x0001	/*  Upload I2C. */
+#define MC2_RPSSIG2		0x2000	/*  RPS signal 2 (not used). */
+#define MC2_RPSSIG1		0x1000	/*  RPS signal 1 (DAC RPS busy). */
+#define MC2_RPSSIG0		0x0800	/*  RPS signal 0 (ADC RPS busy). */
+
+#define MC2_ADC_RPS		MC2_RPSSIG0	/*  ADC RPS busy. */
+#define MC2_DAC_RPS		MC2_RPSSIG1	/*  DAC RPS busy. */
+
+/* ***** oldies ***** */
+#define MC2_UPLD_DEBIQ		0x00020002	/*  Upload DEBI registers. */
+#define MC2_UPLD_IICQ		0x00010001	/*  Upload I2C registers. */
+
+/*  PCI BUS (SAA7146) REGISTER ADDRESS OFFSETS */
+#define P_PCI_BT_A		0x004C	/* Audio DMA burst/threshold control. */
+#define P_DEBICFG               0x007C	/* DEBI configuration. */
+#define P_DEBICMD               0x0080	/* DEBI command. */
+#define P_DEBIPAGE              0x0084	/* DEBI page. */
+#define P_DEBIAD                0x0088	/* DEBI target address. */
+#define P_I2CCTRL               0x008C	/* I2C control. */
+#define P_I2CSTAT               0x0090	/* I2C status. */
+#define P_BASEA2_IN		0x00AC	/* Audio input 2 base physical DMAbuf
+					 * address. */
+#define P_PROTA2_IN		0x00B0	/* Audio input 2 physical DMAbuf
+					 * protection address. */
+#define P_PAGEA2_IN		0x00B4	/* Audio input 2 paging attributes. */
+#define P_BASEA2_OUT		0x00B8	/* Audio output 2 base physical DMAbuf
+					 * address. */
+#define P_PROTA2_OUT		0x00BC	/* Audio output 2 physical DMAbuf
+					 * protection address. */
+#define P_PAGEA2_OUT		0x00C0	/* Audio output 2 paging attributes. */
+#define P_RPSPAGE0              0x00C4	/* RPS0 page. */
+#define P_RPSPAGE1              0x00C8	/* RPS1 page. */
+#define P_RPS0_TOUT		0x00D4	/* RPS0 time-out. */
+#define P_RPS1_TOUT		0x00D8	/* RPS1 time-out. */
+#define P_IER                   0x00DC	/* Interrupt enable. */
+#define P_GPIO                  0x00E0	/* General-purpose I/O. */
+#define P_EC1SSR		0x00E4	/* Event counter set 1 source select. */
+#define P_ECT1R			0x00EC	/* Event counter threshold set 1. */
+#define P_ACON1                 0x00F4	/* Audio control 1. */
+#define P_ACON2                 0x00F8	/* Audio control 2. */
+#define P_MC1                   0x00FC	/* Master control 1. */
+#define P_MC2                   0x0100	/* Master control 2. */
+#define P_RPSADDR0              0x0104	/* RPS0 instruction pointer. */
+#define P_RPSADDR1              0x0108	/* RPS1 instruction pointer. */
+#define P_ISR                   0x010C	/* Interrupt status. */
+#define P_PSR                   0x0110	/* Primary status. */
+#define P_SSR                   0x0114	/* Secondary status. */
+#define P_EC1R			0x0118	/* Event counter set 1. */
+#define P_ADP4			0x0138	/* Logical audio DMA pointer of audio
+					 * input FIFO A2_IN. */
+#define P_FB_BUFFER1            0x0144	/* Audio feedback buffer 1. */
+#define P_FB_BUFFER2            0x0148	/* Audio feedback buffer 2. */
+#define P_TSL1                  0x0180	/* Audio time slot list 1. */
+#define P_TSL2                  0x01C0	/* Audio time slot list 2. */
+
+/*  LOCAL BUS (GATE ARRAY) REGISTER ADDRESS OFFSETS */
+/*  Analog I/O registers: */
+#define LP_DACPOL		0x0082	/*   Write DAC polarity. */
+#define LP_GSEL			0x0084	/*   Write ADC gain. */
+#define LP_ISEL			0x0086	/*   Write ADC channel select. */
+/*  Digital I/O (write only): */
+#define LP_WRINTSELA		0x0042	/*   Write A interrupt enable. */
+#define LP_WREDGSELA		0x0044	/*   Write A edge selection. */
+#define LP_WRCAPSELA		0x0046	/*   Write A capture enable. */
+#define LP_WRDOUTA		0x0048	/*   Write A digital output. */
+#define LP_WRINTSELB		0x0052	/*   Write B interrupt enable. */
+#define LP_WREDGSELB		0x0054	/*   Write B edge selection. */
+#define LP_WRCAPSELB		0x0056	/*   Write B capture enable. */
+#define LP_WRDOUTB		0x0058	/*   Write B digital output. */
+#define LP_WRINTSELC		0x0062	/*   Write C interrupt enable. */
+#define LP_WREDGSELC		0x0064	/*   Write C edge selection. */
+#define LP_WRCAPSELC		0x0066	/*   Write C capture enable. */
+#define LP_WRDOUTC		0x0068	/*   Write C digital output. */
+
+/*  Digital I/O (read only): */
+#define LP_RDDINA		0x0040	/*   Read digital input. */
+#define LP_RDCAPFLGA		0x0048	/*   Read edges captured. */
+#define LP_RDINTSELA		0x004A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELA		0x004C	/*   Read edge selection register. */
+#define LP_RDCAPSELA		0x004E	/*   Read capture enable register. */
+#define LP_RDDINB		0x0050	/*   Read digital input. */
+#define LP_RDCAPFLGB		0x0058	/*   Read edges captured. */
+#define LP_RDINTSELB		0x005A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELB		0x005C	/*   Read edge selection register. */
+#define LP_RDCAPSELB		0x005E	/*   Read capture enable register. */
+#define LP_RDDINC		0x0060	/*   Read digital input. */
+#define LP_RDCAPFLGC		0x0068	/*   Read edges captured. */
+#define LP_RDINTSELC		0x006A	/*   Read interrupt enable register. */
+#define LP_RDEDGSELC		0x006C	/*   Read edge selection register. */
+#define LP_RDCAPSELC		0x006E	/*   Read capture enable register. */
+
+/*  Counter Registers (read/write): */
+#define LP_CR0A			0x0000	/*   0A setup register. */
+#define LP_CR0B			0x0002	/*   0B setup register. */
+#define LP_CR1A			0x0004	/*   1A setup register. */
+#define LP_CR1B			0x0006	/*   1B setup register. */
+#define LP_CR2A			0x0008	/*   2A setup register. */
+#define LP_CR2B			0x000A	/*   2B setup register. */
+
+/*  Counter PreLoad (write) and Latch (read) Registers: */
+#define	LP_CNTR0ALSW		0x000C	/*   0A lsw. */
+#define	LP_CNTR0AMSW		0x000E	/*   0A msw. */
+#define	LP_CNTR0BLSW		0x0010	/*   0B lsw. */
+#define	LP_CNTR0BMSW		0x0012	/*   0B msw. */
+#define	LP_CNTR1ALSW		0x0014	/*   1A lsw. */
+#define	LP_CNTR1AMSW		0x0016	/*   1A msw. */
+#define	LP_CNTR1BLSW		0x0018	/*   1B lsw. */
+#define	LP_CNTR1BMSW		0x001A	/*   1B msw. */
+#define	LP_CNTR2ALSW		0x001C	/*   2A lsw. */
+#define	LP_CNTR2AMSW		0x001E	/*   2A msw. */
+#define	LP_CNTR2BLSW		0x0020	/*   2B lsw. */
+#define	LP_CNTR2BMSW		0x0022	/*   2B msw. */
+
+/*  Miscellaneous Registers (read/write): */
+#define LP_MISC1		0x0088	/*   Read/write Misc1. */
+#define LP_WRMISC2		0x0090	/*   Write Misc2. */
+#define LP_RDMISC2		0x0082	/*   Read Misc2. */
+
+/*  Bit masks for MISC1 register that are the same for reads and writes. */
+#define MISC1_WENABLE		0x8000	/* enab writes to MISC2 (except Clear
+					 * Watchdog bit). */
+#define MISC1_WDISABLE		0x0000	/* Disable writes to MISC2. */
+#define MISC1_EDCAP		0x1000	/* enab edge capture on DIO chans
+					 * specified by  LP_WRCAPSELx. */
+#define MISC1_NOEDCAP		0x0000	/* Disable edge capture on specified
+					 * DIO chans. */
+
+/*  Bit masks for MISC1 register reads. */
+#define RDMISC1_WDTIMEOUT	0x4000	/*  Watchdog timer timed out. */
+
+/*  Bit masks for MISC2 register writes. */
+#define WRMISC2_WDCLEAR		0x8000	/*  Reset watchdog timer to zero. */
+#define WRMISC2_CHARGE_ENABLE	0x4000	/*  enab battery trickle charging. */
+
+/*  Bit masks for MISC2 register that are the same for reads and writes. */
+#define MISC2_BATT_ENABLE	0x0008	/*  Backup battery enable. */
+#define MISC2_WDENABLE		0x0004	/*  Watchdog timer enable. */
+#define MISC2_WDPERIOD_MASK	0x0003	/*  Watchdog interval */
+						/*  select mask. */
+
+/*  Bit masks for ACON1 register. */
+#define A2_RUN			0x40000000	/*  Run A2 based on TSL2. */
+#define A1_RUN			0x20000000	/*  Run A1 based on TSL1. */
+#define A1_SWAP			0x00200000	/*  Use big-endian for A1. */
+#define A2_SWAP			0x00100000	/*  Use big-endian for A2. */
+#define WS_MODES		0x00019999	/*  WS0 = TSL1 trigger */
+						/*  input, WS1-WS4 = */
+						/*  CS* outputs. */
+
+#if PLATFORM == INTEL		/* Base ACON1 config: always run A1 based
+				 * on TSL1. */
 #define ACON1_BASE		( WS_MODES | A1_RUN )
 #elif PLATFORM == MOTOROLA
 #define ACON1_BASE		( WS_MODES | A1_RUN | A1_SWAP | A2_SWAP )
 #endif
 
-#define ACON1_ADCSTART		ACON1_BASE	// Start ADC: run A1
-						// based on TSL1.
-#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )	// Start
-							// transmit to
-							// DAC: run A2
-							// based on
-							// TSL2.
-#define ACON1_DACSTOP		ACON1_BASE	// Halt A2.
-
-// Bit masks for ACON2 register.
-#define A1_CLKSRC_BCLK1		0x00000000	// A1 bit rate = BCLK1 (ADC).
-#define A2_CLKSRC_X1		0x00800000	// A2 bit rate = ACLK/1 (DACs).
-#define A2_CLKSRC_X2		0x00C00000	// A2 bit rate = ACLK/2 (DACs).
-#define A2_CLKSRC_X4		0x01400000	// A2 bit rate = ACLK/4 (DACs).
-#define INVERT_BCLK2		0x00100000	// Invert BCLK2 (DACs).
-#define BCLK2_OE		0x00040000	// enab BCLK2 (DACs).
-#define ACON2_XORMASK		0x000C0000	// XOR mask for ACON2
-						// active-low bits.
+#define ACON1_ADCSTART		ACON1_BASE	/* Start ADC: run A1
+						 *  based on TSL1. */
+#define ACON1_DACSTART		( ACON1_BASE | A2_RUN )
+/* Start transmit to DAC: run A2 based on TSL2. */
+#define ACON1_DACSTOP		ACON1_BASE	/*  Halt A2. */
+
+/*  Bit masks for ACON2 register. */
+#define A1_CLKSRC_BCLK1		0x00000000	/*  A1 bit rate = BCLK1 (ADC). */
+#define A2_CLKSRC_X1		0x00800000	/*  A2 bit rate = ACLK/1 (DACs). */
+#define A2_CLKSRC_X2		0x00C00000	/*  A2 bit rate = ACLK/2 (DACs). */
+#define A2_CLKSRC_X4		0x01400000	/*  A2 bit rate = ACLK/4 (DACs). */
+#define INVERT_BCLK2		0x00100000	/*  Invert BCLK2 (DACs). */
+#define BCLK2_OE		0x00040000	/*  enab BCLK2 (DACs). */
+#define ACON2_XORMASK		0x000C0000	/*  XOR mask for ACON2 */
+						/*  active-low bits. */
 
 #define ACON2_INIT		( ACON2_XORMASK ^ ( A1_CLKSRC_BCLK1 | A2_CLKSRC_X2 | INVERT_BCLK2 | BCLK2_OE ) )
 
-// Bit masks for timeslot records.
-#define WS1		     	0x40000000	// WS output to assert.
+/*  Bit masks for timeslot records. */
+#define WS1		     	0x40000000	/*  WS output to assert. */
 #define WS2		     	0x20000000
 #define WS3		     	0x10000000
 #define WS4		     	0x08000000
-#define RSD1			0x01000000	// Shift A1 data in on SD1.
-#define SDW_A1			0x00800000	// Store rcv'd char at
-						// next char slot of
-						// DWORD1 buffer.
-#define SIB_A1			0x00400000	// Store rcv'd char at
-						// next char slot of
-						// FB1 buffer.
-#define SF_A1			0x00200000	// Write unsigned long
-						// buffer to input
-						// FIFO.
-
-//Select parallel-to-serial converter's data source:
-#define XFIFO_0			0x00000000	//   Data fifo byte 0.
-#define XFIFO_1			0x00000010	//   Data fifo byte 1.
-#define XFIFO_2			0x00000020	//   Data fifo byte 2.
-#define XFIFO_3			0x00000030	//   Data fifo byte 3.
-#define XFB0			0x00000040	//   FB_BUFFER byte 0.
-#define XFB1			0x00000050	//   FB_BUFFER byte 1.
-#define XFB2			0x00000060	//   FB_BUFFER byte 2.
-#define XFB3			0x00000070	//   FB_BUFFER byte 3.
-#define SIB_A2			0x00000200	// Store next dword
-						// from A2's input
-						// shifter to FB2
-						// buffer.
-#define SF_A2			0x00000100	// Store next dword
-						// from A2's input
-						// shifter to its
-						// input fifo.
-#define LF_A2			0x00000080	// Load next dword
-						// from A2's output
-						// fifo into its
-						// output dword
-						// buffer.
-#define XSD2			0x00000008	// Shift data out on SD2.
-#define RSD3			0x00001800	// Shift data in on SD3.
-#define RSD2			0x00001000	// Shift data in on SD2.
-#define LOW_A2			0x00000002	// Drive last SD low
-						// for 7 clks, then
-						// tri-state.
-#define EOS		     	0x00000001	// End of superframe.
-
-//////////////////////
-
-// I2C configuration constants.
-#define I2C_CLKSEL		0x0400	// I2C bit rate =
-						// PCIclk/480 = 68.75
-						// KHz.
-#define I2C_BITRATE		68.75	// I2C bus data bit
-						// rate (determined by
-						// I2C_CLKSEL) in KHz.
-#define I2C_WRTIME		15.0	// Worst case time,in
-						// msec, for EEPROM
-						// internal write op.
-
-// I2C manifest constants.
-
-// Max retries to wait for EEPROM write.
+#define RSD1			0x01000000	/* Shift A1 data in on SD1. */
+#define SDW_A1			0x00800000	/* Store rcv'd char at next
+						 * char slot of DWORD1 buffer. */
+#define SIB_A1			0x00400000	/* Store rcv'd char at next
+						 * char slot of FB1 buffer. */
+#define SF_A1			0x00200000	/* Write unsigned long
+						 * buffer to input FIFO. */
+
+/* Select parallel-to-serial converter's data source: */
+#define XFIFO_0			0x00000000	/*    Data fifo byte 0. */
+#define XFIFO_1			0x00000010	/*    Data fifo byte 1. */
+#define XFIFO_2			0x00000020	/*    Data fifo byte 2. */
+#define XFIFO_3			0x00000030	/*    Data fifo byte 3. */
+#define XFB0			0x00000040	/*    FB_BUFFER byte 0. */
+#define XFB1			0x00000050	/*    FB_BUFFER byte 1. */
+#define XFB2			0x00000060	/*    FB_BUFFER byte 2. */
+#define XFB3			0x00000070	/*    FB_BUFFER byte 3. */
+#define SIB_A2			0x00000200	/* Store next dword from A2's
+						 * input shifter to FB2 buffer. */
+#define SF_A2			0x00000100	/* Store next dword from A2's
+						 * input shifter to its input
+						 * fifo. */
+#define LF_A2			0x00000080	/* Load next dword from A2's
+						 * output fifo into its
+						 * output dword buffer. */
+#define XSD2			0x00000008	/*  Shift data out on SD2. */
+#define RSD3			0x00001800	/*  Shift data in on SD3. */
+#define RSD2			0x00001000	/*  Shift data in on SD2. */
+#define LOW_A2			0x00000002	/*  Drive last SD low */
+						/*  for 7 clks, then */
+						/*  tri-state. */
+#define EOS		     	0x00000001	/*  End of superframe. */
+
+
+/*  I2C configuration constants. */
+#define I2C_CLKSEL		0x0400
+/* I2C bit rate = PCIclk/480 = 68.75 KHz. */
+
+#define I2C_BITRATE		68.75
+/* I2C bus data bit rate (determined by I2C_CLKSEL) in KHz. */
+
+#define I2C_WRTIME		15.0
+/* Worst case time, in msec, for EEPROM internal write op. */
+
+/*  I2C manifest constants. */
+
+/*  Max retries to wait for EEPROM write. */
 #define I2C_RETRIES		( I2C_WRTIME * I2C_BITRATE / 9.0 )
-#define I2C_ERR			0x0002	// I2C control/status
-						// flag ERROR.
-#define I2C_BUSY		0x0001	// I2C control/status
-						// flag BUSY.
-#define I2C_ABORT		0x0080	// I2C status flag ABORT.
-#define I2C_ATTRSTART		0x3	// I2C attribute START.
-#define I2C_ATTRCONT		0x2	// I2C attribute CONT.
-#define I2C_ATTRSTOP		0x1	// I2C attribute STOP.
-#define I2C_ATTRNOP		0x0	// I2C attribute NOP.
-
-// I2C read command  | EEPROM address.
+#define I2C_ERR			0x0002	/*  I2C control/status */
+						/*  flag ERROR. */
+#define I2C_BUSY		0x0001	/*  I2C control/status */
+						/*  flag BUSY. */
+#define I2C_ABORT		0x0080	/*  I2C status flag ABORT. */
+#define I2C_ATTRSTART		0x3	/*  I2C attribute START. */
+#define I2C_ATTRCONT		0x2	/*  I2C attribute CONT. */
+#define I2C_ATTRSTOP		0x1	/*  I2C attribute STOP. */
+#define I2C_ATTRNOP		0x0	/*  I2C attribute NOP. */
+
+/*  I2C read command  | EEPROM address. */
 #define I2CR			( devpriv-&gt;I2CAdrs | 1 )
 
-// I2C write command | EEPROM address.
+/*  I2C write command | EEPROM address. */
 #define I2CW			( devpriv-&gt;I2CAdrs )
 
-// Code macros used for constructing I2C command bytes.
+/*  Code macros used for constructing I2C command bytes. */
 #define I2C_B2(ATTR,VAL)	( ( (ATTR) &lt;&lt; 6 ) | ( (VAL) &lt;&lt; 24 ) )
 #define I2C_B1(ATTR,VAL)	( ( (ATTR) &lt;&lt; 4 ) | ( (VAL) &lt;&lt; 16 ) )
 #define I2C_B0(ATTR,VAL)	( ( (ATTR) &lt;&lt; 2 ) | ( (VAL) &lt;&lt;  8 ) )
 
-////////////////////////////////////////////////////////
-//oldest
-#define P_DEBICFGq              0x007C	// DEBI configuration.
-#define P_DEBICMDq              0x0080	// DEBI command.
-#define P_DEBIPAGEq             0x0084	// DEBI page.
-#define P_DEBIADq               0x0088	// DEBI target address.
-
-#define DEBI_CFG_TOQ		0x03C00000	// timeout (15 PCI cycles)
-#define DEBI_CFG_FASTQ		0x10000000	// fast mode enable
-#define DEBI_CFG_16Q		0x00080000	// 16-bit access enable
-#define DEBI_CFG_INCQ		0x00040000	// enable address increment
-#define DEBI_CFG_TIMEROFFQ	0x00010000	// disable timer
-#define DEBI_CMD_RDQ		0x00050000	// read immediate 2 bytes
-#define DEBI_CMD_WRQ		0x00040000	// write immediate 2 bytes
-#define DEBI_PAGE_DISABLEQ	0x00000000	// paging disable
-
-///////////////////////////////////////////
-// DEBI command constants.
-#define DEBI_CMD_SIZE16		( 2 &lt;&lt; 17 )	// Transfer size is
-						// always 2 bytes.
-#define DEBI_CMD_READ		0x00010000	// Read operation.
-#define DEBI_CMD_WRITE		0x00000000	// Write operation.
-
-// Read immediate 2 bytes.
+/* oldest */
+#define P_DEBICFGq              0x007C	/*  DEBI configuration. */
+#define P_DEBICMDq              0x0080	/*  DEBI command. */
+#define P_DEBIPAGEq             0x0084	/*  DEBI page. */
+#define P_DEBIADq               0x0088	/*  DEBI target address. */
+
+#define DEBI_CFG_TOQ		0x03C00000	/*  timeout (15 PCI cycles) */
+#define DEBI_CFG_FASTQ		0x10000000	/*  fast mode enable */
+#define DEBI_CFG_16Q		0x00080000	/*  16-bit access enable */
+#define DEBI_CFG_INCQ		0x00040000	/*  enable address increment */
+#define DEBI_CFG_TIMEROFFQ	0x00010000	/*  disable timer */
+#define DEBI_CMD_RDQ		0x00050000	/*  read immediate 2 bytes */
+#define DEBI_CMD_WRQ		0x00040000	/*  write immediate 2 bytes */
+#define DEBI_PAGE_DISABLEQ	0x00000000	/*  paging disable */
+
+/*  DEBI command constants. */
+#define DEBI_CMD_SIZE16		( 2 &lt;&lt; 17 )	/*  Transfer size is */
+						/*  always 2 bytes. */
+#define DEBI_CMD_READ		0x00010000	/*  Read operation. */
+#define DEBI_CMD_WRITE		0x00000000	/*  Write operation. */
+
+/*  Read immediate 2 bytes. */
 #define DEBI_CMD_RDWORD		( DEBI_CMD_READ  | DEBI_CMD_SIZE16 )
 
-// Write immediate 2 bytes.
+/*  Write immediate 2 bytes. */
 #define DEBI_CMD_WRWORD		( DEBI_CMD_WRITE | DEBI_CMD_SIZE16 )
 
-// DEBI configuration constants.
-#define DEBI_CFG_XIRQ_EN	0x80000000	// enab external
-						// interrupt on GPIO3.
-#define DEBI_CFG_XRESUME	0x40000000	// Resume block
-						// transfer when XIRQ
-						// deasserted.
-#define DEBI_CFG_FAST		0x10000000	// Fast mode enable.
-
-// 4-bit field that specifies DEBI timeout value in PCI clock cycles:
-#define DEBI_CFG_TOUT_BIT	22	//   Finish DEBI cycle after
-					//   this many clocks.
-
-// 2-bit field that specifies Endian byte lane steering:
-#define DEBI_CFG_SWAP_NONE	0x00000000	//   Straight - don't
-						//   swap any bytes
-						//   (Intel).
-#define DEBI_CFG_SWAP_2		0x00100000	//   2-byte swap (Motorola).
-#define DEBI_CFG_SWAP_4		0x00200000	//   4-byte swap.
-#define DEBI_CFG_16		0x00080000	// Slave is able to
-						// serve 16-bit
-						// cycles.
-
-#define DEBI_CFG_SLAVE16	0x00080000	// Slave is able to
-						// serve 16-bit
-						// cycles.
-#define DEBI_CFG_INC		0x00040000	// enab address
-						// increment for block
-						// transfers.
-#define DEBI_CFG_INTEL		0x00020000	// Intel style local bus.
-#define DEBI_CFG_TIMEROFF	0x00010000	// Disable timer.
+/*  DEBI configuration constants. */
+#define DEBI_CFG_XIRQ_EN	0x80000000	/*  enab external */
+						/*  interrupt on GPIO3. */
+#define DEBI_CFG_XRESUME	0x40000000	/*  Resume block */
+						/*  transfer when XIRQ */
+						/*  deasserted. */
+#define DEBI_CFG_FAST		0x10000000	/*  Fast mode enable. */
+
+/*  4-bit field that specifies DEBI timeout value in PCI clock cycles: */
+#define DEBI_CFG_TOUT_BIT	22	/*    Finish DEBI cycle after */
+					/*    this many clocks. */
+
+/*  2-bit field that specifies Endian byte lane steering: */
+#define DEBI_CFG_SWAP_NONE	0x00000000	/*    Straight - don't */
+						/*    swap any bytes */
+						/*    (Intel). */
+#define DEBI_CFG_SWAP_2		0x00100000	/*    2-byte swap (Motorola). */
+#define DEBI_CFG_SWAP_4		0x00200000	/*    4-byte swap. */
+#define DEBI_CFG_16		0x00080000	/*  Slave is able to */
+						/*  serve 16-bit */
+						/*  cycles. */
+
+#define DEBI_CFG_SLAVE16	0x00080000	/*  Slave is able to */
+						/*  serve 16-bit */
+						/*  cycles. */
+#define DEBI_CFG_INC		0x00040000	/*  enab address */
+						/*  increment for block */
+						/*  transfers. */
+#define DEBI_CFG_INTEL		0x00020000	/*  Intel style local bus. */
+#define DEBI_CFG_TIMEROFF	0x00010000	/*  Disable timer. */
 
 #if PLATFORM == INTEL
 
-#define DEBI_TOUT		7	// Wait 7 PCI clocks
-						// (212 ns) before
-						// polling RDY.
+#define DEBI_TOUT		7	/*  Wait 7 PCI clocks */
+						/*  (212 ns) before */
+						/*  polling RDY. */
 
-// Intel byte lane steering (pass through all byte lanes).
+/*  Intel byte lane steering (pass through all byte lanes). */
 #define DEBI_SWAP		DEBI_CFG_SWAP_NONE
 
 #elif PLATFORM == MOTOROLA
 
-#define DEBI_TOUT		15	// Wait 15 PCI clocks (454 ns)
-					// maximum before timing out.
-#define DEBI_SWAP		DEBI_CFG_SWAP_2	// Motorola byte lane steering.
+#define DEBI_TOUT		15	/*  Wait 15 PCI clocks (454 ns) */
+					/*  maximum before timing out. */
+#define DEBI_SWAP		DEBI_CFG_SWAP_2	/*  Motorola byte lane steering. */
 
 #endif
 
-// DEBI page table constants.
-#define DEBI_PAGE_DISABLE	0x00000000	// Paging disable.
-
-///////////////////EXTRA FROM OTHER SANSORAY  * .h////////
-
-// LoadSrc values:
-#define LOADSRC_INDX		0	// Preload core in response to
-					// Index.
-#define LOADSRC_OVER		1	// Preload core in response to
-					// Overflow.
-#define LOADSRCB_OVERA		2	// Preload B core in response
-					// to A Overflow.
-#define LOADSRC_NONE		3	// Never preload core.
-
-// IntSrc values:
-#define INTSRC_NONE 		0	// Interrupts disabled.
-#define INTSRC_OVER 		1	// Interrupt on Overflow.
-#define INTSRC_INDX 		2	// Interrupt on Index.
-#define INTSRC_BOTH 		3	// Interrupt on Index or Overflow.
-
-// LatchSrc values:
-#define LATCHSRC_AB_READ	0	// Latch on read.
-#define LATCHSRC_A_INDXA	1	// Latch A on A Index.
-#define LATCHSRC_B_INDXB	2	// Latch B on B Index.
-#define LATCHSRC_B_OVERA	3	// Latch B on A Overflow.
-
-// IndxSrc values:
-#define INDXSRC_HARD		0	// Hardware or software index.
-#define INDXSRC_SOFT		1	// Software index only.
-
-// IndxPol values:
-#define INDXPOL_POS 		0	// Index input is active high.
-#define INDXPOL_NEG 		1	// Index input is active low.
-
-// ClkSrc values:
-#define CLKSRC_COUNTER		0	// Counter mode.
-#define CLKSRC_TIMER		2	// Timer mode.
-#define CLKSRC_EXTENDER		3	// Extender mode.
-
-// ClkPol values:
-#define CLKPOL_POS		0	// Counter/Extender clock is
-					// active high.
-#define CLKPOL_NEG		1	// Counter/Extender clock is
-					// active low.
-#define CNTDIR_UP		0	// Timer counts up.
-#define CNTDIR_DOWN 		1	// Timer counts down.
-
-// ClkEnab values:
-#define CLKENAB_ALWAYS		0	// Clock always enabled.
-#define CLKENAB_INDEX		1	// Clock is enabled by index.
-
-// ClkMult values:
-#define CLKMULT_4X 		0	// 4x clock multiplier.
-#define CLKMULT_2X 		1	// 2x clock multiplier.
-#define CLKMULT_1X 		2	// 1x clock multiplier.
-
-// Bit Field positions in COUNTER_SETUP structure:
-#define BF_LOADSRC		9	// Preload trigger.
-#define BF_INDXSRC		7	// Index source.
-#define BF_INDXPOL		6	// Index polarity.
-#define BF_CLKSRC		4	// Clock source.
-#define BF_CLKPOL		3	// Clock polarity/count direction.
-#define BF_CLKMULT		1	// Clock multiplier.
-#define BF_CLKENAB		0	// Clock enable.
-
-// Enumerated counter operating modes specified by ClkSrc bit field in
-// a COUNTER_SETUP.
-
-#define CLKSRC_COUNTER		0	// Counter: ENC_C clock, ENC_D
-					// direction.
-#define CLKSRC_TIMER		2	// Timer: SYS_C clock,
-					// direction specified by
-					// ClkPol.
-#define CLKSRC_EXTENDER		3	// Extender: OVR_A clock,
-					// ENC_D direction.
-
-// Enumerated counter clock multipliers.
-
-#define MULT_X0			0x0003	// Supports no multipliers;
-					// fixed physical multiplier =
-					// 3.
-#define MULT_X1			0x0002	// Supports multiplier x1;
-					// fixed physical multiplier =
-					// 2.
-#define MULT_X2			0x0001	// Supports multipliers x1,
-					// x2; physical multipliers =
-					// 1 or 2.
-#define MULT_X4			0x0000	// Supports multipliers x1,
-					// x2, x4; physical
-					// multipliers = 0, 1 or 2.
-
-// Sanity-check limits for parameters.
-
-#define NUM_COUNTERS		6	// Maximum valid counter
-					// logical channel number.
+/*  DEBI page table constants. */
+#define DEBI_PAGE_DISABLE	0x00000000	/*  Paging disable. */
+
+/* ******* EXTRA FROM OTHER SANSORAY  * .h  ******* */
+
+/*  LoadSrc values: */
+#define LOADSRC_INDX		0	/*  Preload core in response to */
+					/*  Index. */
+#define LOADSRC_OVER		1	/*  Preload core in response to */
+					/*  Overflow. */
+#define LOADSRCB_OVERA		2	/*  Preload B core in response */
+					/*  to A Overflow. */
+#define LOADSRC_NONE		3	/*  Never preload core. */
+
+/*  IntSrc values: */
+#define INTSRC_NONE 		0	/*  Interrupts disabled. */
+#define INTSRC_OVER 		1	/*  Interrupt on Overflow. */
+#define INTSRC_INDX 		2	/*  Interrupt on Index. */
+#define INTSRC_BOTH 		3	/*  Interrupt on Index or Overflow. */
+
+/*  LatchSrc values: */
+#define LATCHSRC_AB_READ	0	/*  Latch on read. */
+#define LATCHSRC_A_INDXA	1	/*  Latch A on A Index. */
+#define LATCHSRC_B_INDXB	2	/*  Latch B on B Index. */
+#define LATCHSRC_B_OVERA	3	/*  Latch B on A Overflow. */
+
+/*  IndxSrc values: */
+#define INDXSRC_HARD		0	/*  Hardware or software index. */
+#define INDXSRC_SOFT		1	/*  Software index only. */
+
+/*  IndxPol values: */
+#define INDXPOL_POS 		0	/*  Index input is active high. */
+#define INDXPOL_NEG 		1	/*  Index input is active low. */
+
+/*  ClkSrc values: */
+#define CLKSRC_COUNTER		0	/*  Counter mode. */
+#define CLKSRC_TIMER		2	/*  Timer mode. */
+#define CLKSRC_EXTENDER		3	/*  Extender mode. */
+
+/*  ClkPol values: */
+#define CLKPOL_POS		0	/*  Counter/Extender clock is */
+					/*  active high. */
+#define CLKPOL_NEG		1	/*  Counter/Extender clock is */
+					/*  active low. */
+#define CNTDIR_UP		0	/*  Timer counts up. */
+#define CNTDIR_DOWN 		1	/*  Timer counts down. */
+
+/*  ClkEnab values: */
+#define CLKENAB_ALWAYS		0	/*  Clock always enabled. */
+#define CLKENAB_INDEX		1	/*  Clock is enabled by index. */
+
+/*  ClkMult values: */
+#define CLKMULT_4X 		0	/*  4x clock multiplier. */
+#define CLKMULT_2X 		1	/*  2x clock multiplier. */
+#define CLKMULT_1X 		2	/*  1x clock multiplier. */
+
+/*  Bit Field positions in COUNTER_SETUP structure: */
+#define BF_LOADSRC		9	/*  Preload trigger. */
+#define BF_INDXSRC		7	/*  Index source. */
+#define BF_INDXPOL		6	/*  Index polarity. */
+#define BF_CLKSRC		4	/*  Clock source. */
+#define BF_CLKPOL		3	/*  Clock polarity/count direction. */
+#define BF_CLKMULT		1	/*  Clock multiplier. */
+#define BF_CLKENAB		0	/*  Clock enable. */
+
+/*  Enumerated counter operating modes specified by ClkSrc bit field in */
+/*  a COUNTER_SETUP. */
+
+#define CLKSRC_COUNTER		0	/*  Counter: ENC_C clock, ENC_D */
+					/*  direction. */
+#define CLKSRC_TIMER		2	/*  Timer: SYS_C clock, */
+					/*  direction specified by */
+					/*  ClkPol. */
+#define CLKSRC_EXTENDER		3	/*  Extender: OVR_A clock, */
+					/*  ENC_D direction. */
+
+/*  Enumerated counter clock multipliers. */
+
+#define MULT_X0			0x0003	/*  Supports no multipliers; */
+					/*  fixed physical multiplier = */
+					/*  3. */
+#define MULT_X1			0x0002	/*  Supports multiplier x1; */
+					/*  fixed physical multiplier = */
+					/*  2. */
+#define MULT_X2			0x0001	/*  Supports multipliers x1, */
+					/*  x2; physical multipliers = */
+					/*  1 or 2. */
+#define MULT_X4			0x0000	/*  Supports multipliers x1, */
+					/*  x2, x4; physical */
+					/*  multipliers = 0, 1 or 2. */
+
+/*  Sanity-check limits for parameters. */
+
+#define NUM_COUNTERS		6	/*  Maximum valid counter */
+					/*  logical channel number. */
 #define NUM_INTSOURCES		4
 #define NUM_LATCHSOURCES	4
 #define NUM_CLKMULTS		4
@@ -708,33 +653,33 @@
 #define NUM_INDEXSOURCES	2
 #define NUM_LOADTRIGS		4
 
-// Bit field positions in CRA and CRB counter control registers.
-
-// Bit field positions in CRA:
-#define CRABIT_INDXSRC_B	14	//   B index source.
-#define CRABIT_CLKSRC_B		12	//   B clock source.
-#define CRABIT_INDXPOL_A	11	//   A index polarity.
-#define CRABIT_LOADSRC_A	 9	//   A preload trigger.
-#define CRABIT_CLKMULT_A	 7	//   A clock multiplier.
-#define CRABIT_INTSRC_A		 5	//   A interrupt source.
-#define CRABIT_CLKPOL_A		 4	//   A clock polarity.
-#define CRABIT_INDXSRC_A	 2	//   A index source.
-#define CRABIT_CLKSRC_A		 0	//   A clock source.
-
-// Bit field positions in CRB:
-#define CRBBIT_INTRESETCMD	15	//   Interrupt reset command.
-#define CRBBIT_INTRESET_B	14	//   B interrupt reset enable.
-#define CRBBIT_INTRESET_A	13	//   A interrupt reset enable.
-#define CRBBIT_CLKENAB_A	12	//   A clock enable.
-#define CRBBIT_INTSRC_B		10	//   B interrupt source.
-#define CRBBIT_LATCHSRC		 8	//   A/B latch source.
-#define CRBBIT_LOADSRC_B	 6	//   B preload trigger.
-#define CRBBIT_CLKMULT_B	 3	//   B clock multiplier.
-#define CRBBIT_CLKENAB_B	 2	//   B clock enable.
-#define CRBBIT_INDXPOL_B	 1	//   B index polarity.
-#define CRBBIT_CLKPOL_B		 0	//   B clock polarity.
-
-// Bit field masks for CRA and CRB.
+/*  Bit field positions in CRA and CRB counter control registers. */
+
+/*  Bit field positions in CRA: */
+#define CRABIT_INDXSRC_B	14	/*    B index source. */
+#define CRABIT_CLKSRC_B		12	/*    B clock source. */
+#define CRABIT_INDXPOL_A	11	/*    A index polarity. */
+#define CRABIT_LOADSRC_A	 9	/*    A preload trigger. */
+#define CRABIT_CLKMULT_A	 7	/*    A clock multiplier. */
+#define CRABIT_INTSRC_A		 5	/*    A interrupt source. */
+#define CRABIT_CLKPOL_A		 4	/*    A clock polarity. */
+#define CRABIT_INDXSRC_A	 2	/*    A index source. */
+#define CRABIT_CLKSRC_A		 0	/*    A clock source. */
+
+/*  Bit field positions in CRB: */
+#define CRBBIT_INTRESETCMD	15	/*    Interrupt reset command. */
+#define CRBBIT_INTRESET_B	14	/*    B interrupt reset enable. */
+#define CRBBIT_INTRESET_A	13	/*    A interrupt reset enable. */
+#define CRBBIT_CLKENAB_A	12	/*    A clock enable. */
+#define CRBBIT_INTSRC_B		10	/*    B interrupt source. */
+#define CRBBIT_LATCHSRC		 8	/*    A/B latch source. */
+#define CRBBIT_LOADSRC_B	 6	/*    B preload trigger. */
+#define CRBBIT_CLKMULT_B	 3	/*    B clock multiplier. */
+#define CRBBIT_CLKENAB_B	 2	/*    B clock enable. */
+#define CRBBIT_INDXPOL_B	 1	/*    B index polarity. */
+#define CRBBIT_CLKPOL_B		 0	/*    B clock polarity. */
+
+/*  Bit field masks for CRA and CRB. */
 
 #define CRAMSK_INDXSRC_B	( (uint16_t)( 3 &lt;&lt; CRABIT_INDXSRC_B) )
 #define CRAMSK_CLKSRC_B		( (uint16_t)( 3 &lt;&lt; CRABIT_CLKSRC_B) )
@@ -758,9 +703,9 @@
 #define CRBMSK_INDXPOL_B	( (uint16_t)( 1 &lt;&lt; CRBBIT_INDXPOL_B) )
 #define CRBMSK_CLKPOL_B		( (uint16_t)( 1 &lt;&lt; CRBBIT_CLKPOL_B) )
 
-#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	// Interrupt reset control bits.
+#define CRBMSK_INTCTRL		( CRBMSK_INTRESETCMD | CRBMSK_INTRESET_A | CRBMSK_INTRESET_B )	/*  Interrupt reset control bits. */
 
-// Bit field positions for standardized SETUP structure.
+/*  Bit field positions for standardized SETUP structure. */
 
 #define STDBIT_INTSRC		13
 #define STDBIT_LATCHSRC		11
@@ -772,7 +717,7 @@
 #define STDBIT_CLKMULT		 1
 #define STDBIT_CLKENAB		 0
 
-// Bit field masks for standardized SETUP structure.
+/*  Bit field masks for standardized SETUP structure. */
 
 #define STDMSK_INTSRC		( (uint16_t)( 3 &lt;&lt; STDBIT_INTSRC   ) )
 #define STDMSK_LATCHSRC		( (uint16_t)( 3 &lt;&lt; STDBIT_LATCHSRC ) )
@@ -784,7 +729,6 @@
 #define STDMSK_CLKMULT		( (uint16_t)( 3 &lt;&lt; STDBIT_CLKMULT  ) )
 #define STDMSK_CLKENAB		( (uint16_t)( 1 &lt;&lt; STDBIT_CLKENAB  ) )
 
-//////////////////////////////////////////////////////////
 
 /* typedef struct indexCounter */
 /* { */
diff --git a/drivers/staging/comedi/pci_ids.h b/drivers/staging/comedi/pci_ids.h
index c61ba90f9601..d979aa8e396b 100644
--- a/drivers/staging/comedi/pci_ids.h
+++ b/drivers/staging/comedi/pci_ids.h
@@ -28,4 +28,4 @@
 #define PCI_DEVICE_ID_QUANCOM_GPIB	0x3302
 #endif
 
-#endif // __COMPAT_LINUX_PCI_IDS_H
+#endif /* __COMPAT_LINUX_PCI_IDS_H */
diff --git a/drivers/staging/comedi/proc.c b/drivers/staging/comedi/proc.c
index 5a2b72d87572..031004ebc6ec 100644
--- a/drivers/staging/comedi/proc.c
+++ b/drivers/staging/comedi/proc.c
@@ -31,7 +31,7 @@
 #define __NO_VERSION__
 #include "comedidev.h"
 #include &lt;linux/proc_fs.h&gt;
-//#include &lt;linux/string.h&gt;
+/* #include &lt;linux/string.h&gt; */
 
 int comedi_read_procmem(char *buf, char **start, off_t offset, int len,
 	int *eof, void *data);
diff --git a/drivers/staging/comedi/range.c b/drivers/staging/comedi/range.c
index 61dc3cd6a9fd..2934fb3162cd 100644
--- a/drivers/staging/comedi/range.c
+++ b/drivers/staging/comedi/range.c
@@ -88,7 +88,7 @@ static int aref_invalid(comedi_subdevice * s, unsigned int chanspec)
 {
 	unsigned int aref;
 
-	// disable reporting invalid arefs... maybe someday
+	/*  disable reporting invalid arefs... maybe someday */
 	return 0;
 
 	aref = CR_AREF(chanspec);
diff --git a/drivers/staging/comedi/rt.c b/drivers/staging/comedi/rt.c
index 385b81b94ac5..2546c64dab00 100644
--- a/drivers/staging/comedi/rt.c
+++ b/drivers/staging/comedi/rt.c
@@ -78,7 +78,7 @@ int comedi_request_irq(unsigned irq, irqreturn_t(*handler) (int,
 
 	ret = request_irq(irq, handler, unshared_flags, device, dev_id);
 	if (ret &lt; 0) {
-		// we failed, so fall back on allowing shared interrupt (which we won't ever make RT)
+		/*  we failed, so fall back on allowing shared interrupt (which we won't ever make RT) */
 		if (flags &amp; IRQF_SHARED) {
 			rt_printk
 				("comedi: cannot get unshared interrupt, will not use RT interrupts.\n");
@@ -192,7 +192,7 @@ static void handle_void_irq(int irq)
 		return;
 	}
 	it-&gt;handler(irq, it-&gt;dev_id PT_REGS_NULL);
-	rt_enable_irq(irq);	//needed by rtai-adeos, seems like it shouldn't hurt earlier versions
+	rt_enable_irq(irq);	/* needed by rtai-adeos, seems like it shouldn't hurt earlier versions */
 }
 
 DECLARE_VOID_IRQ(0);
@@ -402,11 +402,11 @@ static int comedi_rt_release_irq(struct comedi_irq_struct *it)
 
 void comedi_rt_init(void)
 {
-	//rt_pend_tq_init();
+	/* rt_pend_tq_init(); */
 }
 
 void comedi_rt_cleanup(void)
 {
-	//rt_pend_tq_cleanup();
+	/* rt_pend_tq_cleanup(); */
 }
 #endif
diff --git a/drivers/staging/comedi/rt_pend_tq.c b/drivers/staging/comedi/rt_pend_tq.c
index 83ccf4da2952..f9dfd9d40cd3 100644
--- a/drivers/staging/comedi/rt_pend_tq.c
+++ b/drivers/staging/comedi/rt_pend_tq.c
@@ -3,7 +3,7 @@
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/sched.h&gt;
-#include "comedidev.h"	// for rt spinlocks
+#include "comedidev.h"	/* for rt spinlocks */
 #include "rt_pend_tq.h"
 #ifdef CONFIG_COMEDI_RTAI
 #include &lt;rtai.h&gt;
@@ -27,7 +27,7 @@ volatile static struct rt_pend_tq *volatile rt_pend_head = rt_pend_tq,
 int rt_pend_tq_irq = 0;
 DEFINE_SPINLOCK(rt_pend_tq_lock);
 
-// WARNING: following code not checked against race conditions yet.
+/* WARNING: following code not checked against race conditions yet. */
 #define INC_CIRCULAR_PTR(ptr,begin,size) do {if(++(ptr)&gt;=(begin)+(size)) (ptr)=(begin); } while(0)
 #define DEC_CIRCULAR_PTR(ptr,begin,size) do {if(--(ptr)&lt;(begin)) (ptr)=(begin)+(size)-1; } while(0)
 
@@ -42,7 +42,7 @@ int rt_pend_call(void (*func) (int arg1, void *arg2), int arg1, void *arg2)
 	comedi_spin_lock_irqsave(&amp;rt_pend_tq_lock, flags);
 	INC_CIRCULAR_PTR(rt_pend_head, rt_pend_tq, RT_PEND_TQ_SIZE);
 	if (rt_pend_head == rt_pend_tail) {
-		// overflow, we just refuse to take this request
+		/* overflow, we just refuse to take this request */
 		DEC_CIRCULAR_PTR(rt_pend_head, rt_pend_tq, RT_PEND_TQ_SIZE);
 		comedi_spin_unlock_irqrestore(&amp;rt_pend_tq_lock, flags);
 		return -EAGAIN;</pre><hr><pre>commit 6641445c3e05460c5164ab15a17fc4ee481ca213
Author: Bill Pemberton &lt;wfp5p@viridian.itc.virginia.edu&gt;
Date:   Thu Apr 29 10:04:56 2010 -0400

    usb: u132-hcd.c: fix shadows sparse warning
    
    Signed-off-by: Bill Pemberton &lt;wfp5p@virginia.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/host/u132-hcd.c b/drivers/usb/host/u132-hcd.c
index fbd7adafd61c..11a97d93dff2 100644
--- a/drivers/usb/host/u132-hcd.c
+++ b/drivers/usb/host/u132-hcd.c
@@ -1446,7 +1446,7 @@ static void u132_hcd_endp_work_scheduler(struct work_struct *work)
 			return;
 		} else {
 			int retval;
-			u8 address = u132-&gt;addr[endp-&gt;usb_addr].address;
+			address = u132-&gt;addr[endp-&gt;usb_addr].address;
 			struct urb *urb = endp-&gt;urb_list[ENDP_QUEUE_MASK &amp;
 				endp-&gt;queue_next];
 			endp-&gt;active = 1;
@@ -3120,8 +3120,8 @@ static int __devinit u132_probe(struct platform_device *pdev)
 		ftdi_elan_gone_away(pdev);
 		return -ENOMEM;
 	} else {
-		int retval = 0;
 		struct u132 *u132 = hcd_to_u132(hcd);
+		retval = 0;
 		hcd-&gt;rsrc_start = 0;
 		mutex_lock(&amp;u132_module_lock);
 		list_add_tail(&amp;u132-&gt;u132_list, &amp;u132_static_list);</pre>
    <div class="pagination">
        <a href='3_82.html'>&lt;&lt;Prev</a><a href='3.html'>1</a><a href='3_2.html'>2</a><a href='3_3.html'>3</a><a href='3_4.html'>4</a><a href='3_5.html'>5</a><a href='3_6.html'>6</a><a href='3_7.html'>7</a><a href='3_8.html'>8</a><a href='3_9.html'>9</a><a href='3_10.html'>10</a><a href='3_11.html'>11</a><a href='3_12.html'>12</a><a href='3_13.html'>13</a><a href='3_14.html'>14</a><a href='3_15.html'>15</a><a href='3_16.html'>16</a><a href='3_17.html'>17</a><a href='3_18.html'>18</a><a href='3_19.html'>19</a><a href='3_20.html'>20</a><a href='3_21.html'>21</a><a href='3_22.html'>22</a><a href='3_23.html'>23</a><a href='3_24.html'>24</a><a href='3_25.html'>25</a><a href='3_26.html'>26</a><a href='3_27.html'>27</a><a href='3_28.html'>28</a><a href='3_29.html'>29</a><a href='3_30.html'>30</a><a href='3_31.html'>31</a><a href='3_32.html'>32</a><a href='3_33.html'>33</a><a href='3_34.html'>34</a><a href='3_35.html'>35</a><a href='3_36.html'>36</a><a href='3_37.html'>37</a><a href='3_38.html'>38</a><a href='3_39.html'>39</a><a href='3_40.html'>40</a><a href='3_41.html'>41</a><a href='3_42.html'>42</a><a href='3_43.html'>43</a><a href='3_44.html'>44</a><a href='3_45.html'>45</a><a href='3_46.html'>46</a><a href='3_47.html'>47</a><a href='3_48.html'>48</a><a href='3_49.html'>49</a><a href='3_50.html'>50</a><a href='3_51.html'>51</a><a href='3_52.html'>52</a><a href='3_53.html'>53</a><a href='3_54.html'>54</a><a href='3_55.html'>55</a><a href='3_56.html'>56</a><a href='3_57.html'>57</a><a href='3_58.html'>58</a><a href='3_59.html'>59</a><a href='3_60.html'>60</a><a href='3_61.html'>61</a><a href='3_62.html'>62</a><a href='3_63.html'>63</a><a href='3_64.html'>64</a><a href='3_65.html'>65</a><a href='3_66.html'>66</a><a href='3_67.html'>67</a><a href='3_68.html'>68</a><a href='3_69.html'>69</a><a href='3_70.html'>70</a><a href='3_71.html'>71</a><a href='3_72.html'>72</a><a href='3_73.html'>73</a><a href='3_74.html'>74</a><a href='3_75.html'>75</a><a href='3_76.html'>76</a><a href='3_77.html'>77</a><a href='3_78.html'>78</a><a href='3_79.html'>79</a><a href='3_80.html'>80</a><a href='3_81.html'>81</a><a href='3_82.html'>82</a><span>[83]</span>
    <div>
</body>
