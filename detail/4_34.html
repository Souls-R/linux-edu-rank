<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_33.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><span>[34]</span><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_35.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 30aef3166ab27f7bcb14c5e809205af8126fa10b
Author: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
Date:   Thu Feb 21 13:44:27 2008 -0500

    Remove define for KRB5_CKSUM_LENGTH, which will become enctype-dependent
    
    cleanup: When adding new encryption types, the checksum length
    can be different for each enctype.  Face the fact that the
    current code only supports DES which has a checksum length of 8.
    
    Signed-off-by: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/include/linux/sunrpc/gss_krb5.h b/include/linux/sunrpc/gss_krb5.h
index 5a4b1e0206e3..216738394f64 100644
--- a/include/linux/sunrpc/gss_krb5.h
+++ b/include/linux/sunrpc/gss_krb5.h
@@ -70,8 +70,6 @@ enum seal_alg {
 	SEAL_ALG_DES3KD = 0x0002
 };
 
-#define KRB5_CKSUM_LENGTH 8
-
 #define CKSUMTYPE_CRC32			0x0001
 #define CKSUMTYPE_RSA_MD4		0x0002
 #define CKSUMTYPE_RSA_MD4_DES		0x0003
diff --git a/net/sunrpc/auth_gss/gss_krb5_seal.c b/net/sunrpc/auth_gss/gss_krb5_seal.c
index dedcbd6108f4..39c08b7e33af 100644
--- a/net/sunrpc/auth_gss/gss_krb5_seal.c
+++ b/net/sunrpc/auth_gss/gss_krb5_seal.c
@@ -109,8 +109,7 @@ gss_get_mic_kerberos(struct gss_ctx *gss_ctx, struct xdr_buf *text,
 			  md5cksum.data, md5cksum.len))
 		return GSS_S_FAILURE;
 
-	memcpy(krb5_hdr + 16, md5cksum.data + md5cksum.len - KRB5_CKSUM_LENGTH,
-	       KRB5_CKSUM_LENGTH);
+	memcpy(krb5_hdr + 16, md5cksum.data + md5cksum.len - 8, 8);
 
 	spin_lock(&amp;krb5_seq_lock);
 	seq_send = ctx-&gt;seq_send++;
diff --git a/net/sunrpc/auth_gss/gss_krb5_wrap.c b/net/sunrpc/auth_gss/gss_krb5_wrap.c
index 3bdc527ee64a..3cd99a795d7a 100644
--- a/net/sunrpc/auth_gss/gss_krb5_wrap.c
+++ b/net/sunrpc/auth_gss/gss_krb5_wrap.c
@@ -176,9 +176,7 @@ gss_wrap_kerberos(struct gss_ctx *ctx, int offset,
 	if (krb5_encrypt(kctx-&gt;seq, NULL, md5cksum.data,
 			  md5cksum.data, md5cksum.len))
 		return GSS_S_FAILURE;
-	memcpy(krb5_hdr + 16,
-	       md5cksum.data + md5cksum.len - KRB5_CKSUM_LENGTH,
-	       KRB5_CKSUM_LENGTH);
+	memcpy(krb5_hdr + 16, md5cksum.data + md5cksum.len - 8, 8);
 
 	spin_lock(&amp;krb5_seq_lock);
 	seq_send = kctx-&gt;seq_send++;</pre><hr><pre>commit 3d4a6886786f839976c36e62303507692bf87d8d
Author: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
Date:   Thu Feb 21 13:44:12 2008 -0500

    Correct grammer/typos in dprintks
    
    cleanup:  Fix grammer/typos to use "too" instead of "to"
    
    Signed-off-by: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/net/sunrpc/auth_gss/gss_krb5_crypto.c b/net/sunrpc/auth_gss/gss_krb5_crypto.c
index 0dd792338fa9..1d52308ca324 100644
--- a/net/sunrpc/auth_gss/gss_krb5_crypto.c
+++ b/net/sunrpc/auth_gss/gss_krb5_crypto.c
@@ -66,8 +66,8 @@ krb5_encrypt(
 		goto out;
 
 	if (crypto_blkcipher_ivsize(tfm) &gt; 16) {
-		dprintk("RPC:       gss_k5encrypt: tfm iv size to large %d\n",
-			 crypto_blkcipher_ivsize(tfm));
+		dprintk("RPC:       gss_k5encrypt: tfm iv size too large %d\n",
+			crypto_blkcipher_ivsize(tfm));
 		goto out;
 	}
 
@@ -102,7 +102,7 @@ krb5_decrypt(
 		goto out;
 
 	if (crypto_blkcipher_ivsize(tfm) &gt; 16) {
-		dprintk("RPC:       gss_k5decrypt: tfm iv size to large %d\n",
+		dprintk("RPC:       gss_k5decrypt: tfm iv size too large %d\n",
 			crypto_blkcipher_ivsize(tfm));
 		goto out;
 	}</pre><hr><pre>commit d8421202121ce74daf4625ca9d1d825bbd7ce66a
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Feb 20 15:40:15 2008 -0500

    lockd: convert nsm_mutex to a spinlock
    
    There's no reason for a mutex here, except to allow an allocation under
    the lock, which we can avoid with the usual trick of preallocating
    memory for the new object and freeing it if it turns out to be
    unnecessary.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/lockd/host.c b/fs/lockd/host.c
index de0ffb6106c4..c7854791898f 100644
--- a/fs/lockd/host.c
+++ b/fs/lockd/host.c
@@ -457,7 +457,7 @@ nlm_gc_hosts(void)
  * Manage NSM handles
  */
 static LIST_HEAD(nsm_handles);
-static DEFINE_MUTEX(nsm_mutex);
+static DEFINE_SPINLOCK(nsm_lock);
 
 static struct nsm_handle *
 __nsm_find(const struct sockaddr_in *sin,
@@ -479,7 +479,8 @@ __nsm_find(const struct sockaddr_in *sin,
 		return NULL;
 	}
 
-	mutex_lock(&amp;nsm_mutex);
+retry:
+	spin_lock(&amp;nsm_lock);
 	list_for_each_entry(pos, &amp;nsm_handles, sm_link) {
 
 		if (hostname &amp;&amp; nsm_use_hostnames) {
@@ -489,28 +490,32 @@ __nsm_find(const struct sockaddr_in *sin,
 		} else if (!nlm_cmp_addr(&amp;pos-&gt;sm_addr, sin))
 			continue;
 		atomic_inc(&amp;pos-&gt;sm_count);
+		kfree(nsm);
 		nsm = pos;
-		goto out;
+		goto found;
 	}
-
-	if (!create) {
-		nsm = NULL;
-		goto out;
+	if (nsm) {
+		list_add(&amp;nsm-&gt;sm_link, &amp;nsm_handles);
+		goto found;
 	}
+	spin_unlock(&amp;nsm_lock);
+
+	if (!create)
+		return NULL;
 
 	nsm = kzalloc(sizeof(*nsm) + hostname_len + 1, GFP_KERNEL);
 	if (nsm == NULL)
-		goto out;
+		return NULL;
+
 	nsm-&gt;sm_addr = *sin;
 	nsm-&gt;sm_name = (char *) (nsm + 1);
 	memcpy(nsm-&gt;sm_name, hostname, hostname_len);
 	nsm-&gt;sm_name[hostname_len] = '\0';
 	atomic_set(&amp;nsm-&gt;sm_count, 1);
+	goto retry;
 
-	list_add(&amp;nsm-&gt;sm_link, &amp;nsm_handles);
-
-out:
-	mutex_unlock(&amp;nsm_mutex);
+found:
+	spin_unlock(&amp;nsm_lock);
 	return nsm;
 }
 
@@ -529,10 +534,9 @@ nsm_release(struct nsm_handle *nsm)
 {
 	if (!nsm)
 		return;
-	mutex_lock(&amp;nsm_mutex);
-	if (atomic_dec_and_test(&amp;nsm-&gt;sm_count)) {
+	if (atomic_dec_and_lock(&amp;nsm-&gt;sm_count, &amp;nsm_lock)) {
 		list_del(&amp;nsm-&gt;sm_link);
+		spin_unlock(&amp;nsm_lock);
 		kfree(nsm);
 	}
-	mutex_unlock(&amp;nsm_mutex);
 }</pre><hr><pre>commit a95e56e72c196970a8067cd515c658d064813170
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Feb 20 15:27:31 2008 -0500

    lockd: clean up __nsm_find()
    
    Use list_for_each_entry().  Also, in keeping with kernel style, make the
    normal case (kzalloc succeeds) unindented and handle the abnormal case
    with a goto.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/lockd/host.c b/fs/lockd/host.c
index 960911c4a11c..de0ffb6106c4 100644
--- a/fs/lockd/host.c
+++ b/fs/lockd/host.c
@@ -465,7 +465,7 @@ __nsm_find(const struct sockaddr_in *sin,
 		int create)
 {
 	struct nsm_handle *nsm = NULL;
-	struct list_head *pos;
+	struct nsm_handle *pos;
 
 	if (!sin)
 		return NULL;
@@ -480,16 +480,16 @@ __nsm_find(const struct sockaddr_in *sin,
 	}
 
 	mutex_lock(&amp;nsm_mutex);
-	list_for_each(pos, &amp;nsm_handles) {
-		nsm = list_entry(pos, struct nsm_handle, sm_link);
+	list_for_each_entry(pos, &amp;nsm_handles, sm_link) {
 
 		if (hostname &amp;&amp; nsm_use_hostnames) {
-			if (strlen(nsm-&gt;sm_name) != hostname_len
-			 || memcmp(nsm-&gt;sm_name, hostname, hostname_len))
+			if (strlen(pos-&gt;sm_name) != hostname_len
+			 || memcmp(pos-&gt;sm_name, hostname, hostname_len))
 				continue;
-		} else if (!nlm_cmp_addr(&amp;nsm-&gt;sm_addr, sin))
+		} else if (!nlm_cmp_addr(&amp;pos-&gt;sm_addr, sin))
 			continue;
-		atomic_inc(&amp;nsm-&gt;sm_count);
+		atomic_inc(&amp;pos-&gt;sm_count);
+		nsm = pos;
 		goto out;
 	}
 
@@ -499,15 +499,15 @@ __nsm_find(const struct sockaddr_in *sin,
 	}
 
 	nsm = kzalloc(sizeof(*nsm) + hostname_len + 1, GFP_KERNEL);
-	if (nsm != NULL) {
-		nsm-&gt;sm_addr = *sin;
-		nsm-&gt;sm_name = (char *) (nsm + 1);
-		memcpy(nsm-&gt;sm_name, hostname, hostname_len);
-		nsm-&gt;sm_name[hostname_len] = '\0';
-		atomic_set(&amp;nsm-&gt;sm_count, 1);
-
-		list_add(&amp;nsm-&gt;sm_link, &amp;nsm_handles);
-	}
+	if (nsm == NULL)
+		goto out;
+	nsm-&gt;sm_addr = *sin;
+	nsm-&gt;sm_name = (char *) (nsm + 1);
+	memcpy(nsm-&gt;sm_name, hostname, hostname_len);
+	nsm-&gt;sm_name[hostname_len] = '\0';
+	atomic_set(&amp;nsm-&gt;sm_count, 1);
+
+	list_add(&amp;nsm-&gt;sm_link, &amp;nsm_handles);
 
 out:
 	mutex_unlock(&amp;nsm_mutex);</pre><hr><pre>commit 164f98adbbd50c67177b096a59f55c1a56a45c82
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Feb 20 14:02:47 2008 -0500

    lockd: fix race in nlm_release()
    
    The sm_count is decremented to zero but left on the nsm_handles list.
    So in the space between decrementing sm_count and acquiring nsm_mutex,
    it is possible for another task to find this nsm_handle, increment the
    use count and then enter nsm_release itself.
    
    Thus there's nothing to prevent the nsm being freed before we acquire
    nsm_mutex here.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/lockd/host.c b/fs/lockd/host.c
index c3f119426d83..960911c4a11c 100644
--- a/fs/lockd/host.c
+++ b/fs/lockd/host.c
@@ -529,12 +529,10 @@ nsm_release(struct nsm_handle *nsm)
 {
 	if (!nsm)
 		return;
+	mutex_lock(&amp;nsm_mutex);
 	if (atomic_dec_and_test(&amp;nsm-&gt;sm_count)) {
-		mutex_lock(&amp;nsm_mutex);
-		if (atomic_read(&amp;nsm-&gt;sm_count) == 0) {
-			list_del(&amp;nsm-&gt;sm_link);
-			kfree(nsm);
-		}
-		mutex_unlock(&amp;nsm_mutex);
+		list_del(&amp;nsm-&gt;sm_link);
+		kfree(nsm);
 	}
+	mutex_unlock(&amp;nsm_mutex);
 }</pre><hr><pre>commit c0ce6ec87c59d7a29438717b1f72f83fb408f416
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Feb 11 15:48:47 2008 -0500

    nfsd: clarify readdir/mountpoint-crossing code
    
    The code here is difficult to understand; attempt to clarify somewhat by
    pulling out one of the more mystifying conditionals into a separate
    function.
    
    While we're here, also add lease_time to the list of attributes that we
    don't really need to cross a mountpoint to fetch.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: Peter Staubach &lt;staubach@redhat.com&gt;

diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 0e6a179eccaf..1ba7ad981935 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -1867,6 +1867,15 @@ nfsd4_encode_fattr(struct svc_fh *fhp, struct svc_export *exp,
 	goto out;
 }
 
+static inline int attributes_need_mount(u32 *bmval)
+{
+	if (bmval[0] &amp; ~(FATTR4_WORD0_RDATTR_ERROR | FATTR4_WORD0_LEASE_TIME))
+		return 1;
+	if (bmval[1] &amp; ~FATTR4_WORD1_MOUNTED_ON_FILEID)
+		return 1;
+	return 0;
+}
+
 static __be32
 nfsd4_encode_dirent_fattr(struct nfsd4_readdir *cd,
 		const char *name, int namlen, __be32 *p, int *buflen)
@@ -1888,9 +1897,7 @@ nfsd4_encode_dirent_fattr(struct nfsd4_readdir *cd,
 	 * we will not follow the cross mount and will fill the attribtutes
 	 * directly from the mountpoint dentry.
 	 */
-	if (d_mountpoint(dentry) &amp;&amp;
-	    (cd-&gt;rd_bmval[0] &amp; ~FATTR4_WORD0_RDATTR_ERROR) == 0 &amp;&amp;
-	    (cd-&gt;rd_bmval[1] &amp; ~FATTR4_WORD1_MOUNTED_ON_FILEID) == 0)
+	if (d_mountpoint(dentry) &amp;&amp; !attributes_need_mount(cd-&gt;rd_bmval))
 		ignore_crossmnt = 1;
 	else if (d_mountpoint(dentry)) {
 		int err;</pre><hr><pre>commit 67eb6ff610d50da231a37beb634d6dea4b5025ab
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Jan 31 16:14:54 2008 -0500

    svcrpc: move unused field from cache_deferred_req
    
    This field is set once and never used; probably some artifact of an
    earlier implementation idea.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/include/linux/sunrpc/cache.h b/include/linux/sunrpc/cache.h
index 03547d6abee5..2d8b211b9324 100644
--- a/include/linux/sunrpc/cache.h
+++ b/include/linux/sunrpc/cache.h
@@ -120,7 +120,6 @@ struct cache_deferred_req {
 	struct list_head	hash;	/* on hash chain */
 	struct list_head	recent; /* on fifo */
 	struct cache_head	*item;  /* cache item we wait on */
-	time_t			recv_time;
 	void			*owner; /* we might need to discard all defered requests
 					 * owned by someone */
 	void			(*revisit)(struct cache_deferred_req *req,
diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c
index b5f2786251b9..d75530ff2a6d 100644
--- a/net/sunrpc/cache.c
+++ b/net/sunrpc/cache.c
@@ -571,7 +571,6 @@ static int cache_defer_req(struct cache_req *req, struct cache_head *item)
 		return -ETIMEDOUT;
 
 	dreq-&gt;item = item;
-	dreq-&gt;recv_time = get_seconds();
 
 	spin_lock(&amp;cache_defer_lock);
 </pre><hr><pre>commit 6a85fa3adddd3a74bd5b94c4b72668d307b88377
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sat Jan 26 23:36:48 2008 -0500

    nfsd4: kill unnecessary check in preprocess_stateid_op
    
    This condition is always true.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index b83b58da0cc0..a40d1ec52fea 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2052,7 +2052,7 @@ nfs4_preprocess_stateid_op(struct svc_fh *current_fh, stateid_t *stateid, int fl
 		renew_client(stp-&gt;st_stateowner-&gt;so_client);
 		if (filpp)
 			*filpp = stp-&gt;st_vfs_file;
-	} else if (dp) {
+	} else {
 		if ((status = nfs4_check_delegmode(dp, flags)))
 			goto out;
 		renew_client(dp-&gt;dl_client);</pre><hr><pre>commit 0836f587258c2a24bfdc8810ad2327e7f354b6c7
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sat Jan 26 19:08:12 2008 -0500

    nfsd4: simplify stateid sequencing checks
    
    Pull this common code into a separate function.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index b73e96db1f50..b83b58da0cc0 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1975,6 +1975,26 @@ io_during_grace_disallowed(struct inode *inode, int flags)
 		&amp;&amp; mandatory_lock(inode);
 }
 
+static int check_stateid_generation(stateid_t *in, stateid_t *ref)
+{
+	/* If the client sends us a stateid from the future, it's buggy: */
+	if (in-&gt;si_generation &gt; ref-&gt;si_generation)
+		return nfserr_bad_stateid;
+	/*
+	 * The following, however, can happen.  For example, if the
+	 * client sends an open and some IO at the same time, the open
+	 * may bump si_generation while the IO is still in flight.
+	 * Thanks to hard links and renames, the client never knows what
+	 * file an open will affect.  So it could avoid that situation
+	 * only by serializing all opens and IO from the same open
+	 * owner.  To recover from the old_stateid error, the client
+	 * will just have to retry the IO:
+	 */
+	if (in-&gt;si_generation &lt; ref-&gt;si_generation)
+		return nfserr_old_stateid;
+	return nfs_ok;
+}
+
 /*
 * Checks for stateid operations
 */
@@ -2023,12 +2043,8 @@ nfs4_preprocess_stateid_op(struct svc_fh *current_fh, stateid_t *stateid, int fl
 			goto out;
 		stidp = &amp;stp-&gt;st_stateid;
 	}
-	if (stateid-&gt;si_generation &gt; stidp-&gt;si_generation)
-		goto out;
-
-	/* OLD STATEID */
-	status = nfserr_old_stateid;
-	if (stateid-&gt;si_generation &lt; stidp-&gt;si_generation)
+	status = check_stateid_generation(stateid, stidp);
+	if (status)
 		goto out;
 	if (stp) {
 		if ((status = nfs4_check_openmode(stp,flags)))
@@ -2065,6 +2081,7 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 {
 	struct nfs4_stateid *stp;
 	struct nfs4_stateowner *sop;
+	__be32 status;
 
 	dprintk("NFSD: preprocess_seqid_op: seqid=%d " 
 			"stateid = (%08x/%08x/%08x/%08x)\n", seqid,
@@ -2150,15 +2167,9 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
 				" confirmed yet!\n");
 		return nfserr_bad_stateid;
 	}
-	if (stateid-&gt;si_generation &gt; stp-&gt;st_stateid.si_generation) {
-		dprintk("NFSD: preprocess_seqid_op: future stateid?!\n");
-		return nfserr_bad_stateid;
-	}
-
-	if (stateid-&gt;si_generation &lt; stp-&gt;st_stateid.si_generation) {
-		dprintk("NFSD: preprocess_seqid_op: old stateid!\n");
-		return nfserr_old_stateid;
-	}
+	status = check_stateid_generation(stateid, &amp;stp-&gt;st_stateid);
+	if (status)
+		return status;
 	renew_client(sop-&gt;so_client);
 	return nfs_ok;
 </pre><hr><pre>commit f3362737be14668f4e8f5c8d082eb131aafc1353
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Sat Jan 26 14:58:45 2008 -0500

    nfsd4: remove unnecessary CHECK_FH check in preprocess_seqid_op
    
    Every caller sets this flag, so it's meaningless.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 81a75f3081f4..b73e96db1f50 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2127,7 +2127,7 @@ nfs4_preprocess_seqid_op(struct svc_fh *current_fh, u32 seqid, stateid_t *statei
                }
 	}
 
-	if ((flags &amp; CHECK_FH) &amp;&amp; nfs4_check_fh(current_fh, stp)) {
+	if (nfs4_check_fh(current_fh, stp)) {
 		dprintk("NFSD: preprocess_seqid_op: fh-stateid mismatch!\n");
 		return nfserr_bad_stateid;
 	}
@@ -2194,7 +2194,7 @@ nfsd4_open_confirm(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 
 	if ((status = nfs4_preprocess_seqid_op(&amp;cstate-&gt;current_fh,
 					oc-&gt;oc_seqid, &amp;oc-&gt;oc_req_stateid,
-					CHECK_FH | CONFIRM | OPEN_STATE,
+					CONFIRM | OPEN_STATE,
 					&amp;oc-&gt;oc_stateowner, &amp;stp, NULL)))
 		goto out; 
 
@@ -2265,7 +2265,7 @@ nfsd4_open_downgrade(struct svc_rqst *rqstp,
 	if ((status = nfs4_preprocess_seqid_op(&amp;cstate-&gt;current_fh,
 					od-&gt;od_seqid,
 					&amp;od-&gt;od_stateid, 
-					CHECK_FH | OPEN_STATE, 
+					OPEN_STATE,
 					&amp;od-&gt;od_stateowner, &amp;stp, NULL)))
 		goto out; 
 
@@ -2318,7 +2318,7 @@ nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	if ((status = nfs4_preprocess_seqid_op(&amp;cstate-&gt;current_fh,
 					close-&gt;cl_seqid,
 					&amp;close-&gt;cl_stateid, 
-					CHECK_FH | OPEN_STATE | CLOSE_STATE,
+					OPEN_STATE | CLOSE_STATE,
 					&amp;close-&gt;cl_stateowner, &amp;stp, NULL)))
 		goto out; 
 	status = nfs_ok;
@@ -2623,7 +2623,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		status = nfs4_preprocess_seqid_op(&amp;cstate-&gt;current_fh,
 				        lock-&gt;lk_new_open_seqid,
 		                        &amp;lock-&gt;lk_new_open_stateid,
-		                        CHECK_FH | OPEN_STATE,
+					OPEN_STATE,
 		                        &amp;lock-&gt;lk_replay_owner, &amp;open_stp,
 					lock);
 		if (status)
@@ -2650,7 +2650,7 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		status = nfs4_preprocess_seqid_op(&amp;cstate-&gt;current_fh,
 				       lock-&gt;lk_old_lock_seqid, 
 				       &amp;lock-&gt;lk_old_lock_stateid, 
-				       CHECK_FH | LOCK_STATE, 
+				       LOCK_STATE,
 				       &amp;lock-&gt;lk_replay_owner, &amp;lock_stp, lock);
 		if (status)
 			goto out;
@@ -2847,7 +2847,7 @@ nfsd4_locku(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	if ((status = nfs4_preprocess_seqid_op(&amp;cstate-&gt;current_fh,
 					locku-&gt;lu_seqid, 
 					&amp;locku-&gt;lu_stateid, 
-					CHECK_FH | LOCK_STATE, 
+					LOCK_STATE,
 					&amp;locku-&gt;lu_stateowner, &amp;stp, NULL)))
 		goto out;
 </pre>
    <div class="pagination">
        <a href='4_33.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><span>[34]</span><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_35.html'>Next&gt;&gt;</a>
    <div>
</body>
