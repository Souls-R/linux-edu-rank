<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Clemson University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Clemson University</h1>
    <div class="pagination">
        <span>[1]</span>
    </div>
    <hr>
    <pre>commit 8bb8aefd5afb54a25a002feb4ec70011812d06a0
Author: Yi Liu &lt;yi9@clemson.edu&gt;
Date:   Tue Nov 24 15:12:14 2015 -0500

    OrangeFS: Change almost all instances of the string PVFS2 to OrangeFS.
    
    OrangeFS was formerly known as PVFS2 and retains the name in many places.
    
    I leave the device /dev/pvfs2-req since this affects userspace.
    
    I leave the filesystem type pvfs2 since this affects userspace. Further
    the OrangeFS sysint library reads fstab for an entry of type pvfs2
    independently of kernel mounts.
    
    I leave extended attribute keys user.pvfs2 and system.pvfs2 as the
    sysint library understands these.
    
    I leave references to userspace binaries still named pvfs2.
    
    I leave the filenames.
    
    Signed-off-by: Yi Liu &lt;yi9@clemson.edu&gt;
    [martin@omnibond.com: clairify above constraints and merge]
    Signed-off-by: Martin Brandenburg &lt;martin@omnibond.com&gt;
    Signed-off-by: Mike Marshall &lt;hubcap@omnibond.com&gt;

diff --git a/fs/orangefs/acl.c b/fs/orangefs/acl.c
index e462b81a3ba1..5e27d5fcb6bf 100644
--- a/fs/orangefs/acl.c
+++ b/fs/orangefs/acl.c
@@ -10,7 +10,7 @@
 #include &lt;linux/posix_acl_xattr.h&gt;
 #include &lt;linux/fs_struct.h&gt;
 
-struct posix_acl *pvfs2_get_acl(struct inode *inode, int type)
+struct posix_acl *orangefs_get_acl(struct inode *inode, int type)
 {
 	struct posix_acl *acl;
 	int ret;
@@ -18,23 +18,23 @@ struct posix_acl *pvfs2_get_acl(struct inode *inode, int type)
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		key = PVFS2_XATTR_NAME_ACL_ACCESS;
+		key = ORANGEFS_XATTR_NAME_ACL_ACCESS;
 		break;
 	case ACL_TYPE_DEFAULT:
-		key = PVFS2_XATTR_NAME_ACL_DEFAULT;
+		key = ORANGEFS_XATTR_NAME_ACL_DEFAULT;
 		break;
 	default:
-		gossip_err("pvfs2_get_acl: bogus value of type %d\n", type);
+		gossip_err("orangefs_get_acl: bogus value of type %d\n", type);
 		return ERR_PTR(-EINVAL);
 	}
 	/*
 	 * Rather than incurring a network call just to determine the exact
 	 * length of the attribute, I just allocate a max length to save on
 	 * the network call. Conceivably, we could pass NULL to
-	 * pvfs2_inode_getxattr() to probe the length of the value, but
+	 * orangefs_inode_getxattr() to probe the length of the value, but
 	 * I don't do that for now.
 	 */
-	value = kmalloc(PVFS_MAX_XATTR_VALUELEN, GFP_KERNEL);
+	value = kmalloc(ORANGEFS_MAX_XATTR_VALUELEN, GFP_KERNEL);
 	if (value == NULL)
 		return ERR_PTR(-ENOMEM);
 
@@ -43,11 +43,11 @@ struct posix_acl *pvfs2_get_acl(struct inode *inode, int type)
 		     get_khandle_from_ino(inode),
 		     key,
 		     type);
-	ret = pvfs2_inode_getxattr(inode,
+	ret = orangefs_inode_getxattr(inode,
 				   "",
 				   key,
 				   value,
-				   PVFS_MAX_XATTR_VALUELEN);
+				   ORANGEFS_MAX_XATTR_VALUELEN);
 	/* if the key exists, convert it to an in-memory rep */
 	if (ret &gt; 0) {
 		acl = posix_acl_from_xattr(&amp;init_user_ns, value, ret);
@@ -64,9 +64,9 @@ struct posix_acl *pvfs2_get_acl(struct inode *inode, int type)
 	return acl;
 }
 
-int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
+int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	int error = 0;
 	void *value = NULL;
 	size_t size = 0;
@@ -74,7 +74,7 @@ int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 
 	switch (type) {
 	case ACL_TYPE_ACCESS:
-		name = PVFS2_XATTR_NAME_ACL_ACCESS;
+		name = ORANGEFS_XATTR_NAME_ACL_ACCESS;
 		if (acl) {
 			umode_t mode = inode-&gt;i_mode;
 			/*
@@ -90,7 +90,7 @@ int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 			}
 
 			if (inode-&gt;i_mode != mode)
-				SetModeFlag(pvfs2_inode);
+				SetModeFlag(orangefs_inode);
 			inode-&gt;i_mode = mode;
 			mark_inode_dirty_sync(inode);
 			if (error == 0)
@@ -98,7 +98,7 @@ int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
-		name = PVFS2_XATTR_NAME_ACL_DEFAULT;
+		name = ORANGEFS_XATTR_NAME_ACL_DEFAULT;
 		break;
 	default:
 		gossip_err("%s: invalid type %d!\n", __func__, type);
@@ -131,7 +131,7 @@ int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	 * will xlate to a removexattr. However, we don't want removexattr
 	 * complain if attributes does not exist.
 	 */
-	error = pvfs2_inode_setxattr(inode, "", name, value, size, 0);
+	error = orangefs_inode_setxattr(inode, "", name, value, size, 0);
 
 out:
 	kfree(value);
@@ -140,35 +140,35 @@ int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 	return error;
 }
 
-int pvfs2_init_acl(struct inode *inode, struct inode *dir)
+int orangefs_init_acl(struct inode *inode, struct inode *dir)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	struct posix_acl *default_acl, *acl;
 	umode_t mode = inode-&gt;i_mode;
 	int error = 0;
 
-	ClearModeFlag(pvfs2_inode);
+	ClearModeFlag(orangefs_inode);
 
 	error = posix_acl_create(dir, &amp;mode, &amp;default_acl, &amp;acl);
 	if (error)
 		return error;
 
 	if (default_acl) {
-		error = pvfs2_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
+		error = orangefs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);
 		posix_acl_release(default_acl);
 	}
 
 	if (acl) {
 		if (!error)
-			error = pvfs2_set_acl(inode, acl, ACL_TYPE_ACCESS);
+			error = orangefs_set_acl(inode, acl, ACL_TYPE_ACCESS);
 		posix_acl_release(acl);
 	}
 
 	/* If mode of the inode was changed, then do a forcible -&gt;setattr */
 	if (mode != inode-&gt;i_mode) {
-		SetModeFlag(pvfs2_inode);
+		SetModeFlag(orangefs_inode);
 		inode-&gt;i_mode = mode;
-		pvfs2_flush_inode(inode);
+		orangefs_flush_inode(inode);
 	}
 
 	return error;
diff --git a/fs/orangefs/dcache.c b/fs/orangefs/dcache.c
index 9466b179bf24..12c916fa4c7f 100644
--- a/fs/orangefs/dcache.c
+++ b/fs/orangefs/dcache.c
@@ -12,27 +12,27 @@
 #include "pvfs2-kernel.h"
 
 /* Returns 1 if dentry can still be trusted, else 0. */
-static int pvfs2_revalidate_lookup(struct dentry *dentry)
+static int orangefs_revalidate_lookup(struct dentry *dentry)
 {
 	struct dentry *parent_dentry = dget_parent(dentry);
 	struct inode *parent_inode = parent_dentry-&gt;d_inode;
-	struct pvfs2_inode_s *parent = PVFS2_I(parent_inode);
+	struct orangefs_inode_s *parent = ORANGEFS_I(parent_inode);
 	struct inode *inode = dentry-&gt;d_inode;
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_kernel_op_s *new_op;
 	int ret = 0;
 	int err = 0;
 
 	gossip_debug(GOSSIP_DCACHE_DEBUG, "%s: attempting lookup.\n", __func__);
 
-	new_op = op_alloc(PVFS2_VFS_OP_LOOKUP);
+	new_op = op_alloc(ORANGEFS_VFS_OP_LOOKUP);
 	if (!new_op)
 		goto out_put_parent;
 
-	new_op-&gt;upcall.req.lookup.sym_follow = PVFS2_LOOKUP_LINK_NO_FOLLOW;
+	new_op-&gt;upcall.req.lookup.sym_follow = ORANGEFS_LOOKUP_LINK_NO_FOLLOW;
 	new_op-&gt;upcall.req.lookup.parent_refn = parent-&gt;refn;
 	strncpy(new_op-&gt;upcall.req.lookup.d_name,
 		dentry-&gt;d_name.name,
-		PVFS2_NAME_LEN);
+		ORANGEFS_NAME_LEN);
 
 	gossip_debug(GOSSIP_DCACHE_DEBUG,
 		     "%s:%s:%d interrupt flag [%d]\n",
@@ -41,7 +41,7 @@ static int pvfs2_revalidate_lookup(struct dentry *dentry)
 		     __LINE__,
 		     get_interruptible_flag(parent_inode));
 
-	err = service_operation(new_op, "pvfs2_lookup",
+	err = service_operation(new_op, "orangefs_lookup",
 			get_interruptible_flag(parent_inode));
 	if (err)
 		goto out_drop;
@@ -79,7 +79,7 @@ static int pvfs2_revalidate_lookup(struct dentry *dentry)
  *
  * Should return 1 if dentry can still be trusted, else 0
  */
-static int pvfs2_d_revalidate(struct dentry *dentry, unsigned int flags)
+static int orangefs_d_revalidate(struct dentry *dentry, unsigned int flags)
 {
 	struct inode *inode;
 	int ret = 0;
@@ -105,7 +105,7 @@ static int pvfs2_d_revalidate(struct dentry *dentry, unsigned int flags)
 	 * exists, but is still in the expected place in the name space
 	 */
 	if (!is_root_handle(inode)) {
-		if (!pvfs2_revalidate_lookup(dentry))
+		if (!orangefs_revalidate_lookup(dentry))
 			goto invalid_exit;
 	} else {
 		gossip_debug(GOSSIP_DCACHE_DEBUG,
@@ -119,7 +119,7 @@ static int pvfs2_d_revalidate(struct dentry *dentry, unsigned int flags)
 		     __func__,
 		     inode,
 		     get_khandle_from_ino(inode));
-	ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);
+	ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);
 	gossip_debug(GOSSIP_DCACHE_DEBUG,
 		     "%s: getattr %s (ret = %d), returning %s for dentry i_count=%d\n",
 		     __func__,
@@ -137,6 +137,6 @@ static int pvfs2_d_revalidate(struct dentry *dentry, unsigned int flags)
 	return 0;
 }
 
-const struct dentry_operations pvfs2_dentry_operations = {
-	.d_revalidate = pvfs2_d_revalidate,
+const struct dentry_operations orangefs_dentry_operations = {
+	.d_revalidate = orangefs_d_revalidate,
 };
diff --git a/fs/orangefs/devpvfs2-req.c b/fs/orangefs/devpvfs2-req.c
index e37b6479a6a1..e18149f0975b 100644
--- a/fs/orangefs/devpvfs2-req.c
+++ b/fs/orangefs/devpvfs2-req.c
@@ -22,14 +22,14 @@ static int open_access_count;
 #define DUMP_DEVICE_ERROR()                                                   \
 do {                                                                          \
 	gossip_err("*****************************************************\n");\
-	gossip_err("PVFS2 Device Error:  You cannot open the device file ");  \
+	gossip_err("ORANGEFS Device Error:  You cannot open the device file ");  \
 	gossip_err("\n/dev/%s more than once.  Please make sure that\nthere " \
-		   "are no ", PVFS2_REQDEVICE_NAME);                          \
+		   "are no ", ORANGEFS_REQDEVICE_NAME);                          \
 	gossip_err("instances of a program using this device\ncurrently "     \
 		   "running. (You must verify this!)\n");                     \
 	gossip_err("For example, you can use the lsof program as follows:\n");\
 	gossip_err("'lsof | grep %s' (run this as root)\n",                   \
-		   PVFS2_REQDEVICE_NAME);                                     \
+		   ORANGEFS_REQDEVICE_NAME);                                     \
 	gossip_err("  open_access_count = %d\n", open_access_count);          \
 	gossip_err("*****************************************************\n");\
 } while (0)
@@ -39,7 +39,7 @@ static int hash_func(__u64 tag, int table_size)
 	return do_div(tag, (unsigned int)table_size);
 }
 
-static void pvfs2_devreq_add_op(struct pvfs2_kernel_op_s *op)
+static void orangefs_devreq_add_op(struct orangefs_kernel_op_s *op)
 {
 	int index = hash_func(op-&gt;tag, hash_table_size);
 
@@ -48,9 +48,9 @@ static void pvfs2_devreq_add_op(struct pvfs2_kernel_op_s *op)
 	spin_unlock(&amp;htable_ops_in_progress_lock);
 }
 
-static struct pvfs2_kernel_op_s *pvfs2_devreq_remove_op(__u64 tag)
+static struct orangefs_kernel_op_s *orangefs_devreq_remove_op(__u64 tag)
 {
-	struct pvfs2_kernel_op_s *op, *next;
+	struct orangefs_kernel_op_s *op, *next;
 	int index;
 
 	index = hash_func(tag, hash_table_size);
@@ -71,12 +71,12 @@ static struct pvfs2_kernel_op_s *pvfs2_devreq_remove_op(__u64 tag)
 	return NULL;
 }
 
-static int pvfs2_devreq_open(struct inode *inode, struct file *file)
+static int orangefs_devreq_open(struct inode *inode, struct file *file)
 {
 	int ret = -EINVAL;
 
 	if (!(file-&gt;f_flags &amp; O_NONBLOCK)) {
-		gossip_err("pvfs2: device cannot be opened in blocking mode\n");
+		gossip_err("orangefs: device cannot be opened in blocking mode\n");
 		goto out;
 	}
 	ret = -EACCES;
@@ -100,14 +100,14 @@ static int pvfs2_devreq_open(struct inode *inode, struct file *file)
 	return ret;
 }
 
-static ssize_t pvfs2_devreq_read(struct file *file,
+static ssize_t orangefs_devreq_read(struct file *file,
 				 char __user *buf,
 				 size_t count, loff_t *offset)
 {
-	struct pvfs2_kernel_op_s *op, *temp;
-	__s32 proto_ver = PVFS_KERNEL_PROTO_VERSION;
-	static __s32 magic = PVFS2_DEVREQ_MAGIC;
-	struct pvfs2_kernel_op_s *cur_op = NULL;
+	struct orangefs_kernel_op_s *op, *temp;
+	__s32 proto_ver = ORANGEFS_KERNEL_PROTO_VERSION;
+	static __s32 magic = ORANGEFS_DEVREQ_MAGIC;
+	struct orangefs_kernel_op_s *cur_op = NULL;
 	unsigned long ret;
 
 	/* We do not support blocking IO. */
@@ -126,14 +126,14 @@ static ssize_t pvfs2_devreq_read(struct file *file,
 	}
 
 	/* Get next op (if any) from top of list. */
-	spin_lock(&amp;pvfs2_request_list_lock);
-	list_for_each_entry_safe(op, temp, &amp;pvfs2_request_list, list) {
+	spin_lock(&amp;orangefs_request_list_lock);
+	list_for_each_entry_safe(op, temp, &amp;orangefs_request_list, list) {
 		__s32 fsid;
 		/* This lock is held past the end of the loop when we break. */
 		spin_lock(&amp;op-&gt;lock);
 
 		fsid = fsid_of_op(op);
-		if (fsid != PVFS_FS_ID_NULL) {
+		if (fsid != ORANGEFS_FS_ID_NULL) {
 			int ret;
 			/* Skip ops whose filesystem needs to be mounted. */
 			ret = fs_mount_pending(fsid);
@@ -147,8 +147,8 @@ static ssize_t pvfs2_devreq_read(struct file *file,
 			 * it is being mounted. */
 			/* XXX: is there a better way to detect this? */
 			} else if (ret == -1 &amp;&amp;
-				   !(op-&gt;upcall.type == PVFS2_VFS_OP_FS_MOUNT ||
-				     op-&gt;upcall.type == PVFS2_VFS_OP_GETATTR)) {
+				   !(op-&gt;upcall.type == ORANGEFS_VFS_OP_FS_MOUNT ||
+				     op-&gt;upcall.type == ORANGEFS_VFS_OP_GETATTR)) {
 				gossip_debug(GOSSIP_DEV_DEBUG,
 				    "orangefs: skipping op tag %llu %s\n",
 				    llu(op-&gt;tag), get_opname_string(op));
@@ -173,7 +173,7 @@ static ssize_t pvfs2_devreq_read(struct file *file,
 	 * found an op and must ask the client to try again later.
 	 */
 	if (!cur_op) {
-		spin_unlock(&amp;pvfs2_request_list_lock);
+		spin_unlock(&amp;orangefs_request_list_lock);
 		return -EAGAIN;
 	}
 
@@ -188,7 +188,7 @@ static ssize_t pvfs2_devreq_read(struct file *file,
 		gossip_err("orangefs: ERROR: Current op already queued.\n");
 		list_del(&amp;cur_op-&gt;list);
 		spin_unlock(&amp;cur_op-&gt;lock);
-		spin_unlock(&amp;pvfs2_request_list_lock);
+		spin_unlock(&amp;orangefs_request_list_lock);
 		return -EAGAIN;
 	}
 
@@ -199,8 +199,8 @@ static ssize_t pvfs2_devreq_read(struct file *file,
 	set_op_state_inprogress(cur_op);
 
 	list_del(&amp;cur_op-&gt;list);
-	spin_unlock(&amp;pvfs2_request_list_lock);
-	pvfs2_devreq_add_op(cur_op);
+	spin_unlock(&amp;orangefs_request_list_lock);
+	orangefs_devreq_add_op(cur_op);
 	spin_unlock(&amp;cur_op-&gt;lock);
 
 	/* Push the upcall out. */
@@ -214,7 +214,7 @@ static ssize_t pvfs2_devreq_read(struct file *file,
 	if (ret != 0)
 		goto error;
 	ret = copy_to_user(buf+2*sizeof(__s32)+sizeof(__u64), &amp;cur_op-&gt;upcall,
-			   sizeof(struct pvfs2_upcall_s));
+			   sizeof(struct orangefs_upcall_s));
 	if (ret != 0)
 		goto error;
 
@@ -227,23 +227,23 @@ static ssize_t pvfs2_devreq_read(struct file *file,
 	 * device is released.
 	 */
 	gossip_err("orangefs: Failed to copy data to user space\n");
-	spin_lock(&amp;pvfs2_request_list_lock);
+	spin_lock(&amp;orangefs_request_list_lock);
 	spin_lock(&amp;cur_op-&gt;lock);
 	set_op_state_waiting(cur_op);
-	pvfs2_devreq_remove_op(cur_op-&gt;tag);
-	list_add(&amp;cur_op-&gt;list, &amp;pvfs2_request_list);
+	orangefs_devreq_remove_op(cur_op-&gt;tag);
+	list_add(&amp;cur_op-&gt;list, &amp;orangefs_request_list);
 	spin_unlock(&amp;cur_op-&gt;lock);
-	spin_unlock(&amp;pvfs2_request_list_lock);
+	spin_unlock(&amp;orangefs_request_list_lock);
 	return -EFAULT;
 }
 
 /* Function for writev() callers into the device */
-static ssize_t pvfs2_devreq_writev(struct file *file,
+static ssize_t orangefs_devreq_writev(struct file *file,
 				   const struct iovec *iov,
 				   size_t count,
 				   loff_t *offset)
 {
-	struct pvfs2_kernel_op_s *op = NULL;
+	struct orangefs_kernel_op_s *op = NULL;
 	void *buffer = NULL;
 	void *ptr = NULL;
 	unsigned long i = 0;
@@ -301,7 +301,7 @@ static ssize_t pvfs2_devreq_writev(struct file *file,
 	tag = *((__u64 *) ptr);
 	ptr += sizeof(__u64);
 
-	if (magic != PVFS2_DEVREQ_MAGIC) {
+	if (magic != ORANGEFS_DEVREQ_MAGIC) {
 		gossip_err("Error: Device magic number does not match.\n");
 		dev_req_release(buffer);
 		return -EPROTO;
@@ -311,17 +311,17 @@ static ssize_t pvfs2_devreq_writev(struct file *file,
 	 * proto_ver = 20902 for 2.9.2
 	 */
 
-	op = pvfs2_devreq_remove_op(tag);
+	op = orangefs_devreq_remove_op(tag);
 	if (op) {
 		/* Increase ref count! */
 		get_op(op);
 		/* cut off magic and tag from payload size */
 		payload_size -= (2 * sizeof(__s32) + sizeof(__u64));
-		if (payload_size &lt;= sizeof(struct pvfs2_downcall_s))
+		if (payload_size &lt;= sizeof(struct orangefs_downcall_s))
 			/* copy the passed in downcall into the op */
 			memcpy(&amp;op-&gt;downcall,
 			       ptr,
-			       sizeof(struct pvfs2_downcall_s));
+			       sizeof(struct orangefs_downcall_s));
 		else
 			gossip_debug(GOSSIP_DEV_DEBUG,
 				     "writev: Ignoring %d bytes\n",
@@ -392,8 +392,8 @@ static ssize_t pvfs2_devreq_writev(struct file *file,
 		 * application reading/writing this device to return until
 		 * the buffers are done being used.
 		 */
-		if (op-&gt;upcall.type == PVFS2_VFS_OP_FILE_IO &amp;&amp;
-		    op-&gt;upcall.req.io.async_vfs_io == PVFS_VFS_SYNC_IO) {
+		if (op-&gt;upcall.type == ORANGEFS_VFS_OP_FILE_IO &amp;&amp;
+		    op-&gt;upcall.req.io.async_vfs_io == ORANGEFS_VFS_SYNC_IO) {
 			int timed_out = 0;
 			DECLARE_WAITQUEUE(wait_entry, current);
 
@@ -473,10 +473,10 @@ static ssize_t pvfs2_devreq_writev(struct file *file,
 	return total_returned_size;
 }
 
-static ssize_t pvfs2_devreq_write_iter(struct kiocb *iocb,
+static ssize_t orangefs_devreq_write_iter(struct kiocb *iocb,
 				      struct iov_iter *iter)
 {
-	return pvfs2_devreq_writev(iocb-&gt;ki_filp,
+	return orangefs_devreq_writev(iocb-&gt;ki_filp,
 				   iter-&gt;iov,
 				   iter-&gt;nr_segs,
 				   &amp;iocb-&gt;ki_pos);
@@ -486,15 +486,15 @@ static ssize_t pvfs2_devreq_write_iter(struct kiocb *iocb,
 static int mark_all_pending_mounts(void)
 {
 	int unmounted = 1;
-	struct pvfs2_sb_info_s *pvfs2_sb = NULL;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
 
-	spin_lock(&amp;pvfs2_superblocks_lock);
-	list_for_each_entry(pvfs2_sb, &amp;pvfs2_superblocks, list) {
+	spin_lock(&amp;orangefs_superblocks_lock);
+	list_for_each_entry(orangefs_sb, &amp;orangefs_superblocks, list) {
 		/* All of these file system require a remount */
-		pvfs2_sb-&gt;mount_pending = 1;
+		orangefs_sb-&gt;mount_pending = 1;
 		unmounted = 0;
 	}
-	spin_unlock(&amp;pvfs2_superblocks_lock);
+	spin_unlock(&amp;orangefs_superblocks_lock);
 	return unmounted;
 }
 
@@ -507,16 +507,16 @@ static int mark_all_pending_mounts(void)
 int fs_mount_pending(__s32 fsid)
 {
 	int mount_pending = -1;
-	struct pvfs2_sb_info_s *pvfs2_sb = NULL;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
 
-	spin_lock(&amp;pvfs2_superblocks_lock);
-	list_for_each_entry(pvfs2_sb, &amp;pvfs2_superblocks, list) {
-		if (pvfs2_sb-&gt;fs_id == fsid) {
-			mount_pending = pvfs2_sb-&gt;mount_pending;
+	spin_lock(&amp;orangefs_superblocks_lock);
+	list_for_each_entry(orangefs_sb, &amp;orangefs_superblocks, list) {
+		if (orangefs_sb-&gt;fs_id == fsid) {
+			mount_pending = orangefs_sb-&gt;mount_pending;
 			break;
 		}
 	}
-	spin_unlock(&amp;pvfs2_superblocks_lock);
+	spin_unlock(&amp;orangefs_superblocks_lock);
 	return mount_pending;
 }
 
@@ -525,10 +525,10 @@ int fs_mount_pending(__s32 fsid)
  * Using the open_access_count variable, we enforce a reference count
  * on this file so that it can be opened by only one process at a time.
  * the devreq_mutex is used to make sure all i/o has completed
- * before we call pvfs_bufmap_finalize, and similar such tricky
+ * before we call orangefs_bufmap_finalize, and similar such tricky
  * situations
  */
-static int pvfs2_devreq_release(struct inode *inode, struct file *file)
+static int orangefs_devreq_release(struct inode *inode, struct file *file)
 {
 	int unmounted = 0;
 
@@ -537,12 +537,12 @@ static int pvfs2_devreq_release(struct inode *inode, struct file *file)
 		     __func__);
 
 	mutex_lock(&amp;devreq_mutex);
-	pvfs_bufmap_finalize();
+	orangefs_bufmap_finalize();
 
 	open_access_count--;
 
 	unmounted = mark_all_pending_mounts();
-	gossip_debug(GOSSIP_DEV_DEBUG, "PVFS2 Device Close: Filesystem(s) %s\n",
+	gossip_debug(GOSSIP_DEV_DEBUG, "ORANGEFS Device Close: Filesystem(s) %s\n",
 		     (unmounted ? "UNMOUNTED" : "MOUNTED"));
 	mutex_unlock(&amp;devreq_mutex);
 
@@ -578,17 +578,17 @@ int is_daemon_in_service(void)
 static inline long check_ioctl_command(unsigned int command)
 {
 	/* Check for valid ioctl codes */
-	if (_IOC_TYPE(command) != PVFS_DEV_MAGIC) {
+	if (_IOC_TYPE(command) != ORANGEFS_DEV_MAGIC) {
 		gossip_err("device ioctl magic numbers don't match! Did you rebuild pvfs2-client-core/libpvfs2? [cmd %x, magic %x != %x]\n",
 			command,
 			_IOC_TYPE(command),
-			PVFS_DEV_MAGIC);
+			ORANGEFS_DEV_MAGIC);
 		return -EINVAL;
 	}
 	/* and valid ioctl commands */
-	if (_IOC_NR(command) &gt;= PVFS_DEV_MAXNR || _IOC_NR(command) &lt;= 0) {
+	if (_IOC_NR(command) &gt;= ORANGEFS_DEV_MAXNR || _IOC_NR(command) &lt;= 0) {
 		gossip_err("Invalid ioctl command number [%d &gt;= %d]\n",
-			   _IOC_NR(command), PVFS_DEV_MAXNR);
+			   _IOC_NR(command), ORANGEFS_DEV_MAXNR);
 		return -ENOIOCTLCMD;
 	}
 	return 0;
@@ -596,46 +596,46 @@ static inline long check_ioctl_command(unsigned int command)
 
 static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 {
-	static __s32 magic = PVFS2_DEVREQ_MAGIC;
+	static __s32 magic = ORANGEFS_DEVREQ_MAGIC;
 	static __s32 max_up_size = MAX_ALIGNED_DEV_REQ_UPSIZE;
 	static __s32 max_down_size = MAX_ALIGNED_DEV_REQ_DOWNSIZE;
-	struct PVFS_dev_map_desc user_desc;
+	struct ORANGEFS_dev_map_desc user_desc;
 	int ret = 0;
 	struct dev_mask_info_s mask_info = { 0 };
 	struct dev_mask2_info_s mask2_info = { 0, 0 };
 	int upstream_kmod = 1;
 	struct list_head *tmp = NULL;
-	struct pvfs2_sb_info_s *pvfs2_sb = NULL;
+	struct orangefs_sb_info_s *orangefs_sb = NULL;
 
 	/* mtmoore: add locking here */
 
 	switch (command) {
-	case PVFS_DEV_GET_MAGIC:
+	case ORANGEFS_DEV_GET_MAGIC:
 		return ((put_user(magic, (__s32 __user *) arg) == -EFAULT) ?
 			-EIO :
 			0);
-	case PVFS_DEV_GET_MAX_UPSIZE:
+	case ORANGEFS_DEV_GET_MAX_UPSIZE:
 		return ((put_user(max_up_size,
 				  (__s32 __user *) arg) == -EFAULT) ?
 					-EIO :
 					0);
-	case PVFS_DEV_GET_MAX_DOWNSIZE:
+	case ORANGEFS_DEV_GET_MAX_DOWNSIZE:
 		return ((put_user(max_down_size,
 				  (__s32 __user *) arg) == -EFAULT) ?
 					-EIO :
 					0);
-	case PVFS_DEV_MAP:
+	case ORANGEFS_DEV_MAP:
 		ret = copy_from_user(&amp;user_desc,
-				     (struct PVFS_dev_map_desc __user *)
+				     (struct ORANGEFS_dev_map_desc __user *)
 				     arg,
-				     sizeof(struct PVFS_dev_map_desc));
-		return ret ? -EIO : pvfs_bufmap_initialize(&amp;user_desc);
-	case PVFS_DEV_REMOUNT_ALL:
+				     sizeof(struct ORANGEFS_dev_map_desc));
+		return ret ? -EIO : orangefs_bufmap_initialize(&amp;user_desc);
+	case ORANGEFS_DEV_REMOUNT_ALL:
 		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "pvfs2_devreq_ioctl: got PVFS_DEV_REMOUNT_ALL\n");
+			     "orangefs_devreq_ioctl: got ORANGEFS_DEV_REMOUNT_ALL\n");
 
 		/*
-		 * remount all mounted pvfs2 volumes to regain the lost
+		 * remount all mounted orangefs volumes to regain the lost
 		 * dynamic mount tables (if any) -- NOTE: this is done
 		 * without keeping the superblock list locked due to the
 		 * upcall/downcall waiting.  also, the request semaphore is
@@ -647,30 +647,30 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		if (ret &lt; 0)
 			return ret;
 		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "pvfs2_devreq_ioctl: priority remount in progress\n");
-		list_for_each(tmp, &amp;pvfs2_superblocks) {
-			pvfs2_sb =
-				list_entry(tmp, struct pvfs2_sb_info_s, list);
-			if (pvfs2_sb &amp;&amp; (pvfs2_sb-&gt;sb)) {
+			     "orangefs_devreq_ioctl: priority remount in progress\n");
+		list_for_each(tmp, &amp;orangefs_superblocks) {
+			orangefs_sb =
+				list_entry(tmp, struct orangefs_sb_info_s, list);
+			if (orangefs_sb &amp;&amp; (orangefs_sb-&gt;sb)) {
 				gossip_debug(GOSSIP_DEV_DEBUG,
 					     "Remounting SB %p\n",
-					     pvfs2_sb);
+					     orangefs_sb);
 
-				ret = pvfs2_remount(pvfs2_sb-&gt;sb);
+				ret = orangefs_remount(orangefs_sb-&gt;sb);
 				if (ret) {
 					gossip_debug(GOSSIP_DEV_DEBUG,
 						     "SB %p remount failed\n",
-						     pvfs2_sb);
+						     orangefs_sb);
 						break;
 				}
 			}
 		}
 		gossip_debug(GOSSIP_DEV_DEBUG,
-			     "pvfs2_devreq_ioctl: priority remount complete\n");
+			     "orangefs_devreq_ioctl: priority remount complete\n");
 		mutex_unlock(&amp;request_mutex);
 		return ret;
 
-	case PVFS_DEV_UPSTREAM:
+	case ORANGEFS_DEV_UPSTREAM:
 		ret = copy_to_user((void __user *)arg,
 				    &amp;upstream_kmod,
 				    sizeof(upstream_kmod));
@@ -680,7 +680,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 		else
 			return ret;
 
-	case PVFS_DEV_CLIENT_MASK:
+	case ORANGEFS_DEV_CLIENT_MASK:
 		ret = copy_from_user(&amp;mask2_info,
 				     (void __user *)arg,
 				     sizeof(struct dev_mask2_info_s));
@@ -699,13 +699,13 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 
 		return ret;
 
-	case PVFS_DEV_CLIENT_STRING:
+	case ORANGEFS_DEV_CLIENT_STRING:
 		ret = copy_from_user(&amp;client_debug_array_string,
 				     (void __user *)arg,
-				     PVFS2_MAX_DEBUG_STRING_LEN);
+				     ORANGEFS_MAX_DEBUG_STRING_LEN);
 		if (ret != 0) {
 			pr_info("%s: "
-				"PVFS_DEV_CLIENT_STRING: copy_from_user failed"
+				"ORANGEFS_DEV_CLIENT_STRING: copy_from_user failed"
 				"\n",
 				__func__);
 			return -EIO;
@@ -753,13 +753,13 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 
 		debugfs_remove(client_debug_dentry);
 
-		pvfs2_client_debug_init();
+		orangefs_client_debug_init();
 
 		help_string_initialized++;
 
 		return ret;
 
-	case PVFS_DEV_DEBUG:
+	case ORANGEFS_DEV_DEBUG:
 		ret = copy_from_user(&amp;mask_info,
 				     (void __user *)arg,
 				     sizeof(mask_info));
@@ -774,21 +774,21 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 				 * the kernel debug mask was set when the
 				 * kernel module was loaded; don't override
 				 * it if the client-core was started without
-				 * a value for PVFS2_KMODMASK.
+				 * a value for ORANGEFS_KMODMASK.
 				 */
 				return 0;
 			}
 			debug_mask_to_string(&amp;mask_info.mask_value,
 					     mask_info.mask_type);
 			gossip_debug_mask = mask_info.mask_value;
-			pr_info("PVFS: kernel debug mask has been modified to "
+			pr_info("ORANGEFS: kernel debug mask has been modified to "
 				":%s: :%llx:\n",
 				kernel_debug_string,
 				(unsigned long long)gossip_debug_mask);
 		} else if (mask_info.mask_type == CLIENT_MASK) {
 			debug_mask_to_string(&amp;mask_info.mask_value,
 					     mask_info.mask_type);
-			pr_info("PVFS: client debug mask has been modified to"
+			pr_info("ORANGEFS: client debug mask has been modified to"
 				":%s: :%llx:\n",
 				client_debug_string,
 				llu(mask_info.mask_value));
@@ -805,7 +805,7 @@ static long dispatch_ioctl_command(unsigned int command, unsigned long arg)
 	return -ENOIOCTLCMD;
 }
 
-static long pvfs2_devreq_ioctl(struct file *file,
+static long orangefs_devreq_ioctl(struct file *file,
 			       unsigned int command, unsigned long arg)
 {
 	long ret;
@@ -820,8 +820,8 @@ static long pvfs2_devreq_ioctl(struct file *file,
 
 #ifdef CONFIG_COMPAT		/* CONFIG_COMPAT is in .config */
 
-/*  Compat structure for the PVFS_DEV_MAP ioctl */
-struct PVFS_dev_map_desc32 {
+/*  Compat structure for the ORANGEFS_DEV_MAP ioctl */
+struct ORANGEFS_dev_map_desc32 {
 	compat_uptr_t ptr;
 	__s32 total_size;
 	__s32 size;
@@ -830,12 +830,12 @@ struct PVFS_dev_map_desc32 {
 
 static unsigned long translate_dev_map26(unsigned long args, long *error)
 {
-	struct PVFS_dev_map_desc32 __user *p32 = (void __user *)args;
+	struct ORANGEFS_dev_map_desc32 __user *p32 = (void __user *)args;
 	/*
 	 * Depending on the architecture, allocate some space on the
 	 * user-call-stack based on our expected layout.
 	 */
-	struct PVFS_dev_map_desc __user *p =
+	struct ORANGEFS_dev_map_desc __user *p =
 	    compat_alloc_user_space(sizeof(*p));
 	compat_uptr_t addr;
 
@@ -863,7 +863,7 @@ static unsigned long translate_dev_map26(unsigned long args, long *error)
  * 32 bit user-space apps' ioctl handlers when kernel modules
  * is compiled as a 64 bit one
  */
-static long pvfs2_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
+static long orangefs_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
 				      unsigned long args)
 {
 	long ret;
@@ -873,7 +873,7 @@ static long pvfs2_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
 	ret = check_ioctl_command(cmd);
 	if (ret &lt; 0)
 		return ret;
-	if (cmd == PVFS_DEV_MAP) {
+	if (cmd == ORANGEFS_DEV_MAP) {
 		/*
 		 * convert the arguments to what we expect internally
 		 * in kernel space
@@ -896,89 +896,89 @@ static long pvfs2_devreq_compat_ioctl(struct file *filp, unsigned int cmd,
  * not noticed until we tried to compile on power pc...
  */
 #if (defined(CONFIG_COMPAT) &amp;&amp; !defined(HAVE_REGISTER_IOCTL32_CONVERSION)) || !defined(CONFIG_COMPAT)
-static int pvfs2_ioctl32_init(void)
+static int orangefs_ioctl32_init(void)
 {
 	return 0;
 }
 
-static void pvfs2_ioctl32_cleanup(void)
+static void orangefs_ioctl32_cleanup(void)
 {
 	return;
 }
 #endif
 
 /* the assigned character device major number */
-static int pvfs2_dev_major;
+static int orangefs_dev_major;
 
 /*
- * Initialize pvfs2 device specific state:
+ * Initialize orangefs device specific state:
  * Must be called at module load time only
  */
-int pvfs2_dev_init(void)
+int orangefs_dev_init(void)
 {
 	int ret;
 
 	/* register the ioctl32 sub-system */
-	ret = pvfs2_ioctl32_init();
+	ret = orangefs_ioctl32_init();
 	if (ret &lt; 0)
 		return ret;
 
-	/* register pvfs2-req device  */
-	pvfs2_dev_major = register_chrdev(0,
-					  PVFS2_REQDEVICE_NAME,
-					  &amp;pvfs2_devreq_file_operations);
-	if (pvfs2_dev_major &lt; 0) {
+	/* register orangefs-req device  */
+	orangefs_dev_major = register_chrdev(0,
+					  ORANGEFS_REQDEVICE_NAME,
+					  &amp;orangefs_devreq_file_operations);
+	if (orangefs_dev_major &lt; 0) {
 		gossip_debug(GOSSIP_DEV_DEBUG,
 			     "Failed to register /dev/%s (error %d)\n",
-			     PVFS2_REQDEVICE_NAME, pvfs2_dev_major);
-		pvfs2_ioctl32_cleanup();
-		return pvfs2_dev_major;
+			     ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);
+		orangefs_ioctl32_cleanup();
+		return orangefs_dev_major;
 	}
 
 	gossip_debug(GOSSIP_DEV_DEBUG,
 		     "*** /dev/%s character device registered ***\n",
-		     PVFS2_REQDEVICE_NAME);
+		     ORANGEFS_REQDEVICE_NAME);
 	gossip_debug(GOSSIP_DEV_DEBUG, "'mknod /dev/%s c %d 0'.\n",
-		     PVFS2_REQDEVICE_NAME, pvfs2_dev_major);
+		     ORANGEFS_REQDEVICE_NAME, orangefs_dev_major);
 	return 0;
 }
 
-void pvfs2_dev_cleanup(void)
+void orangefs_dev_cleanup(void)
 {
-	unregister_chrdev(pvfs2_dev_major, PVFS2_REQDEVICE_NAME);
+	unregister_chrdev(orangefs_dev_major, ORANGEFS_REQDEVICE_NAME);
 	gossip_debug(GOSSIP_DEV_DEBUG,
 		     "*** /dev/%s character device unregistered ***\n",
-		     PVFS2_REQDEVICE_NAME);
+		     ORANGEFS_REQDEVICE_NAME);
 	/* unregister the ioctl32 sub-system */
-	pvfs2_ioctl32_cleanup();
+	orangefs_ioctl32_cleanup();
 }
 
-static unsigned int pvfs2_devreq_poll(struct file *file,
+static unsigned int orangefs_devreq_poll(struct file *file,
 				      struct poll_table_struct *poll_table)
 {
 	int poll_revent_mask = 0;
 
 	if (open_access_count == 1) {
-		poll_wait(file, &amp;pvfs2_request_list_waitq, poll_table);
+		poll_wait(file, &amp;orangefs_request_list_waitq, poll_table);
 
-		spin_lock(&amp;pvfs2_request_list_lock);
-		if (!list_empty(&amp;pvfs2_request_list))
+		spin_lock(&amp;orangefs_request_list_lock);
+		if (!list_empty(&amp;orangefs_request_list))
 			poll_revent_mask |= POLL_IN;
-		spin_unlock(&amp;pvfs2_request_list_lock);
+		spin_unlock(&amp;orangefs_request_list_lock);
 	}
 	return poll_revent_mask;
 }
 
-const struct file_operations pvfs2_devreq_file_operations = {
+const struct file_operations orangefs_devreq_file_operations = {
 	.owner = THIS_MODULE,
-	.read = pvfs2_devreq_read,
-	.write_iter = pvfs2_devreq_write_iter,
-	.open = pvfs2_devreq_open,
-	.release = pvfs2_devreq_release,
-	.unlocked_ioctl = pvfs2_devreq_ioctl,
+	.read = orangefs_devreq_read,
+	.write_iter = orangefs_devreq_write_iter,
+	.open = orangefs_devreq_open,
+	.release = orangefs_devreq_release,
+	.unlocked_ioctl = orangefs_devreq_ioctl,
 
 #ifdef CONFIG_COMPAT		/* CONFIG_COMPAT is in .config */
-	.compat_ioctl = pvfs2_devreq_compat_ioctl,
+	.compat_ioctl = orangefs_devreq_compat_ioctl,
 #endif
-	.poll = pvfs2_devreq_poll
+	.poll = orangefs_devreq_poll
 };
diff --git a/fs/orangefs/dir.c b/fs/orangefs/dir.c
index 3049cd61b700..452d589b9747 100644
--- a/fs/orangefs/dir.c
+++ b/fs/orangefs/dir.c
@@ -10,7 +10,7 @@
 
 struct readdir_handle_s {
 	int buffer_index;
-	struct pvfs2_readdir_response_s readdir_response;
+	struct orangefs_readdir_response_s readdir_response;
 	void *dents_buf;
 };
 
@@ -18,28 +18,28 @@ struct readdir_handle_s {
  * decode routine needed by kmod to make sense of the shared page for readdirs.
  */
 static long decode_dirents(char *ptr, size_t size,
-			   struct pvfs2_readdir_response_s *readdir)
+                           struct orangefs_readdir_response_s *readdir)
 {
 	int i;
-	struct pvfs2_readdir_response_s *rd =
-		(struct pvfs2_readdir_response_s *) ptr;
+	struct orangefs_readdir_response_s *rd =
+		(struct orangefs_readdir_response_s *) ptr;
 	char *buf = ptr;
 
-	if (size &lt; offsetof(struct pvfs2_readdir_response_s, dirent_array))
+	if (size &lt; offsetof(struct orangefs_readdir_response_s, dirent_array))
 		return -EINVAL;
 
 	readdir-&gt;token = rd-&gt;token;
-	readdir-&gt;pvfs_dirent_outcount = rd-&gt;pvfs_dirent_outcount;
-	readdir-&gt;dirent_array = kcalloc(readdir-&gt;pvfs_dirent_outcount,
+	readdir-&gt;orangefs_dirent_outcount = rd-&gt;orangefs_dirent_outcount;
+	readdir-&gt;dirent_array = kcalloc(readdir-&gt;orangefs_dirent_outcount,
 					sizeof(*readdir-&gt;dirent_array),
 					GFP_KERNEL);
 	if (readdir-&gt;dirent_array == NULL)
 		return -ENOMEM;
 
-	buf += offsetof(struct pvfs2_readdir_response_s, dirent_array);
-	size -= offsetof(struct pvfs2_readdir_response_s, dirent_array);
+	buf += offsetof(struct orangefs_readdir_response_s, dirent_array);
+	size -= offsetof(struct orangefs_readdir_response_s, dirent_array);
 
-	for (i = 0; i &lt; readdir-&gt;pvfs_dirent_outcount; i++) {
+	for (i = 0; i &lt; readdir-&gt;orangefs_dirent_outcount; i++) {
 		__u32 len;
 
 		if (size &lt; 4)
@@ -60,7 +60,7 @@ static long decode_dirents(char *ptr, size_t size,
 		buf += len;
 
 		readdir-&gt;dirent_array[i].khandle =
-			*(struct pvfs2_khandle *) buf;
+			*(struct orangefs_khandle *) buf;
 		buf += 16;
 	}
 	return buf - ptr;
@@ -98,7 +98,7 @@ static long readdir_handle_ctor(struct readdir_handle_s *rhandle, void *buf,
 	return ret;
 }
 
-static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,
+static void readdir_handle_dtor(struct orangefs_bufmap *bufmap,
 		struct readdir_handle_s *rhandle)
 {
 	if (rhandle == NULL)
@@ -123,9 +123,9 @@ static void readdir_handle_dtor(struct pvfs2_bufmap *bufmap,
 /*
  * Read directory entries from an instance of an open directory.
  */
-static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
+static int orangefs_readdir(struct file *file, struct dir_context *ctx)
 {
-	struct pvfs2_bufmap *bufmap = NULL;
+	struct orangefs_bufmap *bufmap = NULL;
 	int ret = 0;
 	int buffer_index;
 	/*
@@ -136,8 +136,8 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	__u64 pos = 0;
 	ino_t ino = 0;
 	struct dentry *dentry = file-&gt;f_path.dentry;
-	struct pvfs2_kernel_op_s *new_op = NULL;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(dentry-&gt;d_inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(dentry-&gt;d_inode);
 	int buffer_full = 0;
 	struct readdir_handle_s rhandle;
 	int i = 0;
@@ -155,26 +155,26 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	pos = (__u64) ctx-&gt;pos;
 
 	/* are we done? */
-	if (pos == PVFS_READDIR_END) {
+	if (pos == ORANGEFS_READDIR_END) {
 		gossip_debug(GOSSIP_DIR_DEBUG,
 			     "Skipping to termination path\n");
 		return 0;
 	}
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
-		     "pvfs2_readdir called on %s (pos=%llu)\n",
+		     "orangefs_readdir called on %s (pos=%llu)\n",
 		     dentry-&gt;d_name.name, llu(pos));
 
 	rhandle.buffer_index = -1;
 	rhandle.dents_buf = NULL;
 	memset(&amp;rhandle.readdir_response, 0, sizeof(rhandle.readdir_response));
 
-	new_op = op_alloc(PVFS2_VFS_OP_READDIR);
+	new_op = op_alloc(ORANGEFS_VFS_OP_READDIR);
 	if (!new_op)
 		return -ENOMEM;
 
 	new_op-&gt;uses_shared_memory = 1;
-	new_op-&gt;upcall.req.readdir.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.readdir.refn = orangefs_inode-&gt;refn;
 	new_op-&gt;upcall.req.readdir.max_dirent_count = MAX_DIRENT_COUNT_READDIR;
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
@@ -187,14 +187,14 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 get_new_buffer_index:
 	ret = readdir_index_get(&amp;bufmap, &amp;buffer_index);
 	if (ret &lt; 0) {
-		gossip_lerr("pvfs2_readdir: readdir_index_get() failure (%d)\n",
+		gossip_lerr("orangefs_readdir: readdir_index_get() failure (%d)\n",
 			    ret);
 		goto out_free_op;
 	}
 	new_op-&gt;upcall.req.readdir.buf_index = buffer_index;
 
 	ret = service_operation(new_op,
-				"pvfs2_readdir",
+				"orangefs_readdir",
 				get_interruptible_flag(dentry-&gt;d_inode));
 
 	gossip_debug(GOSSIP_DIR_DEBUG,
@@ -238,7 +238,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 				    new_op-&gt;downcall.trailer_size,
 				    buffer_index);
 	if (bytes_decoded &lt; 0) {
-		gossip_err("pvfs2_readdir: Could not decode trailer buffer into a readdir response %d\n",
+		gossip_err("orangefs_readdir: Could not decode trailer buffer into a readdir response %d\n",
 			ret);
 		ret = bytes_decoded;
 		readdir_index_put(bufmap, buffer_index);
@@ -246,7 +246,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	if (bytes_decoded != new_op-&gt;downcall.trailer_size) {
-		gossip_err("pvfs2_readdir: # bytes decoded (%ld) "
+		gossip_err("orangefs_readdir: # bytes decoded (%ld) "
 			   "!= trailer size (%ld)\n",
 			   bytes_decoded,
 			   (long)new_op-&gt;downcall.trailer_size);
@@ -255,7 +255,7 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	/*
-	 *  pvfs2 doesn't actually store dot and dot-dot, but
+	 *  orangefs doesn't actually store dot and dot-dot, but
 	 *  we need to have them represented.
 	 */
 	if (pos == 0) {
@@ -279,19 +279,19 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	}
 
 	/*
-	 * we stored PVFS_ITERATE_NEXT in ctx-&gt;pos last time around
+	 * we stored ORANGEFS_ITERATE_NEXT in ctx-&gt;pos last time around
 	 * to prevent "finding" dot and dot-dot on any iteration
 	 * other than the first.
 	 */
-	if (ctx-&gt;pos == PVFS_ITERATE_NEXT)
+	if (ctx-&gt;pos == ORANGEFS_ITERATE_NEXT)
 		ctx-&gt;pos = 0;
 
 	for (i = ctx-&gt;pos;
-	     i &lt; rhandle.readdir_response.pvfs_dirent_outcount;
+	     i &lt; rhandle.readdir_response.orangefs_dirent_outcount;
 	     i++) {
 		len = rhandle.readdir_response.dirent_array[i].d_length;
 		current_entry = rhandle.readdir_response.dirent_array[i].d_name;
-		current_ino = pvfs2_khandle_to_ino(
+		current_ino = orangefs_khandle_to_ino(
 			&amp;(rhandle.readdir_response.dirent_array[i].khandle));
 
 		gossip_debug(GOSSIP_DIR_DEBUG,
@@ -323,28 +323,28 @@ static int pvfs2_readdir(struct file *file, struct dir_context *ctx)
 	 */
 	if (ret) {
 		*ptoken = rhandle.readdir_response.token;
-		ctx-&gt;pos = PVFS_ITERATE_NEXT;
+		ctx-&gt;pos = ORANGEFS_ITERATE_NEXT;
 	}
 
 	/*
 	 * Did we hit the end of the directory?
 	 */
-	if (rhandle.readdir_response.token == PVFS_READDIR_END &amp;&amp;
+	if (rhandle.readdir_response.token == ORANGEFS_READDIR_END &amp;&amp;
 	    !buffer_full) {
 		gossip_debug(GOSSIP_DIR_DEBUG,
-		"End of dir detected; setting ctx-&gt;pos to PVFS_READDIR_END.\n");
-		ctx-&gt;pos = PVFS_READDIR_END;
+		"End of dir detected; setting ctx-&gt;pos to ORANGEFS_READDIR_END.\n");
+		ctx-&gt;pos = ORANGEFS_READDIR_END;
 	}
 
 out_destroy_handle:
 	readdir_handle_dtor(bufmap, &amp;rhandle);
 out_free_op:
 	op_release(new_op);
-	gossip_debug(GOSSIP_DIR_DEBUG, "pvfs2_readdir returning %d\n", ret);
+	gossip_debug(GOSSIP_DIR_DEBUG, "orangefs_readdir returning %d\n", ret);
 	return ret;
 }
 
-static int pvfs2_dir_open(struct inode *inode, struct file *file)
+static int orangefs_dir_open(struct inode *inode, struct file *file)
 {
 	__u64 *ptoken;
 
@@ -353,21 +353,21 @@ static int pvfs2_dir_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 
 	ptoken = file-&gt;private_data;
-	*ptoken = PVFS_READDIR_START;
+	*ptoken = ORANGEFS_READDIR_START;
 	return 0;
 }
 
-static int pvfs2_dir_release(struct inode *inode, struct file *file)
+static int orangefs_dir_release(struct inode *inode, struct file *file)
 {
-	pvfs2_flush_inode(inode);
+	orangefs_flush_inode(inode);
 	kfree(file-&gt;private_data);
 	return 0;
 }
 
-/** PVFS2 implementation of VFS directory operations */
-const struct file_operations pvfs2_dir_operations = {
+/** ORANGEFS implementation of VFS directory operations */
+const struct file_operations orangefs_dir_operations = {
 	.read = generic_read_dir,
-	.iterate = pvfs2_readdir,
-	.open = pvfs2_dir_open,
-	.release = pvfs2_dir_release,
+	.iterate = orangefs_readdir,
+	.open = orangefs_dir_open,
+	.release = orangefs_dir_release,
 };
diff --git a/fs/orangefs/downcall.h b/fs/orangefs/downcall.h
index e372f446f6ba..72d4cac54821 100644
--- a/fs/orangefs/downcall.h
+++ b/fs/orangefs/downcall.h
@@ -15,42 +15,42 @@
  * Sanitized the device-client core interaction
  * for clean 32-64 bit usage
  */
-struct pvfs2_io_response {
+struct orangefs_io_response {
 	__s64 amt_complete;
 };
 
-struct pvfs2_lookup_response {
-	struct pvfs2_object_kref refn;
+struct orangefs_lookup_response {
+	struct orangefs_object_kref refn;
 };
 
-struct pvfs2_create_response {
-	struct pvfs2_object_kref refn;
+struct orangefs_create_response {
+	struct orangefs_object_kref refn;
 };
 
-struct pvfs2_symlink_response {
-	struct pvfs2_object_kref refn;
+struct orangefs_symlink_response {
+	struct orangefs_object_kref refn;
 };
 
-struct pvfs2_getattr_response {
-	struct PVFS_sys_attr_s attributes;
-	char link_target[PVFS2_NAME_LEN];
+struct orangefs_getattr_response {
+	struct ORANGEFS_sys_attr_s attributes;
+	char link_target[ORANGEFS_NAME_LEN];
 };
 
-struct pvfs2_mkdir_response {
-	struct pvfs2_object_kref refn;
+struct orangefs_mkdir_response {
+	struct orangefs_object_kref refn;
 };
 
 /*
  * duplication of some system interface structures so that I don't have
  * to allocate extra memory
  */
-struct pvfs2_dirent {
+struct orangefs_dirent {
 	char *d_name;
 	int d_length;
-	struct pvfs2_khandle khandle;
+	struct orangefs_khandle khandle;
 };
 
-struct pvfs2_statfs_response {
+struct orangefs_statfs_response {
 	__s64 block_size;
 	__s64 blocks_total;
 	__s64 blocks_avail;
@@ -58,47 +58,47 @@ struct pvfs2_statfs_response {
 	__s64 files_avail;
 };
 
-struct pvfs2_fs_mount_response {
+struct orangefs_fs_mount_response {
 	__s32 fs_id;
 	__s32 id;
-	struct pvfs2_khandle root_khandle;
+	struct orangefs_khandle root_khandle;
 };
 
 /* the getxattr response is the attribute value */
-struct pvfs2_getxattr_response {
+struct orangefs_getxattr_response {
 	__s32 val_sz;
 	__s32 __pad1;
-	char val[PVFS_MAX_XATTR_VALUELEN];
+	char val[ORANGEFS_MAX_XATTR_VALUELEN];
 };
 
 /* the listxattr response is an array of attribute names */
-struct pvfs2_listxattr_response {
+struct orangefs_listxattr_response {
 	__s32 returned_count;
 	__s32 __pad1;
 	__u64 token;
-	char key[PVFS_MAX_XATTR_LISTLEN * PVFS_MAX_XATTR_NAMELEN];
+	char key[ORANGEFS_MAX_XATTR_LISTLEN * ORANGEFS_MAX_XATTR_NAMELEN];
 	__s32 keylen;
 	__s32 __pad2;
-	__s32 lengths[PVFS_MAX_XATTR_LISTLEN];
+	__s32 lengths[ORANGEFS_MAX_XATTR_LISTLEN];
 };
 
-struct pvfs2_param_response {
+struct orangefs_param_response {
 	__s64 value;
 };
 
 #define PERF_COUNT_BUF_SIZE 4096
-struct pvfs2_perf_count_response {
+struct orangefs_perf_count_response {
 	char buffer[PERF_COUNT_BUF_SIZE];
 };
 
 #define FS_KEY_BUF_SIZE 4096
-struct pvfs2_fs_key_response {
+struct orangefs_fs_key_response {
 	__s32 fs_keylen;
 	__s32 __pad1;
 	char fs_key[FS_KEY_BUF_SIZE];
 };
 
-struct pvfs2_downcall_s {
+struct orangefs_downcall_s {
 	__s32 type;
 	__s32 status;
 	/* currently trailer is used only by readdir */
@@ -106,28 +106,28 @@ struct pvfs2_downcall_s {
 	char *trailer_buf;
 
 	union {
-		struct pvfs2_io_response io;
-		struct pvfs2_lookup_response lookup;
-		struct pvfs2_create_response create;
-		struct pvfs2_symlink_response sym;
-		struct pvfs2_getattr_response getattr;
-		struct pvfs2_mkdir_response mkdir;
-		struct pvfs2_statfs_response statfs;
-		struct pvfs2_fs_mount_response fs_mount;
-		struct pvfs2_getxattr_response getxattr;
-		struct pvfs2_listxattr_response listxattr;
-		struct pvfs2_param_response param;
-		struct pvfs2_perf_count_response perf_count;
-		struct pvfs2_fs_key_response fs_key;
+		struct orangefs_io_response io;
+		struct orangefs_lookup_response lookup;
+		struct orangefs_create_response create;
+		struct orangefs_symlink_response sym;
+		struct orangefs_getattr_response getattr;
+		struct orangefs_mkdir_response mkdir;
+		struct orangefs_statfs_response statfs;
+		struct orangefs_fs_mount_response fs_mount;
+		struct orangefs_getxattr_response getxattr;
+		struct orangefs_listxattr_response listxattr;
+		struct orangefs_param_response param;
+		struct orangefs_perf_count_response perf_count;
+		struct orangefs_fs_key_response fs_key;
 	} resp;
 };
 
-struct pvfs2_readdir_response_s {
+struct orangefs_readdir_response_s {
 	__u64 token;
 	__u64 directory_version;
 	__u32 __pad2;
-	__u32 pvfs_dirent_outcount;
-	struct pvfs2_dirent *dirent_array;
+	__u32 orangefs_dirent_outcount;
+	struct orangefs_dirent *dirent_array;
 };
 
 #endif /* __DOWNCALL_H */
diff --git a/fs/orangefs/file.c b/fs/orangefs/file.c
index 3a8140f289f6..ae5d8ed67ed5 100644
--- a/fs/orangefs/file.c
+++ b/fs/orangefs/file.c
@@ -29,7 +29,7 @@ do {							\
  *       can futher be kernel-space or user-space addresses.
  *       or it can pointers to struct page's
  */
-static int precopy_buffers(struct pvfs2_bufmap *bufmap,
+static int precopy_buffers(struct orangefs_bufmap *bufmap,
 			   int buffer_index,
 			   struct iov_iter *iter,
 			   size_t total_size)
@@ -42,10 +42,10 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
 
 
 	if (total_size) {
-		ret = pvfs_bufmap_copy_from_iovec(bufmap,
-						iter,
-						buffer_index,
-						total_size);
+		ret = orangefs_bufmap_copy_from_iovec(bufmap,
+						      iter,
+						      buffer_index,
+						      total_size);
 		if (ret &lt; 0)
 		gossip_err("%s: Failed to copy-in buffers. Please make sure that the pvfs2-client is running. %ld\n",
 			   __func__,
@@ -66,7 +66,7 @@ static int precopy_buffers(struct pvfs2_bufmap *bufmap,
  *       can futher be kernel-space or user-space addresses.
  *       or it can pointers to struct page's
  */
-static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
+static int postcopy_buffers(struct orangefs_bufmap *bufmap,
 			    int buffer_index,
 			    struct iov_iter *iter,
 			    size_t total_size)
@@ -78,10 +78,10 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
 	 * struct page pointers.
 	 */
 	if (total_size) {
-		ret = pvfs_bufmap_copy_to_iovec(bufmap,
-						iter,
-						buffer_index,
-						total_size);
+		ret = orangefs_bufmap_copy_to_iovec(bufmap,
+						    iter,
+						    buffer_index,
+						    total_size);
 		if (ret &lt; 0)
 			gossip_err("%s: Failed to copy-out buffers. Please make sure that the pvfs2-client is running (%ld)\n",
 				__func__,
@@ -93,34 +93,34 @@ static int postcopy_buffers(struct pvfs2_bufmap *bufmap,
 /*
  * Post and wait for the I/O upcall to finish
  */
-static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
+static ssize_t wait_for_direct_io(enum ORANGEFS_io_type type, struct inode *inode,
 		loff_t *offset, struct iov_iter *iter,
 		size_t total_size, loff_t readahead_size)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_khandle *handle = &amp;pvfs2_inode-&gt;refn.khandle;
-	struct pvfs2_bufmap *bufmap = NULL;
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_khandle *handle = &amp;orangefs_inode-&gt;refn.khandle;
+	struct orangefs_bufmap *bufmap = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int buffer_index = -1;
 	ssize_t ret;
 
-	new_op = op_alloc(PVFS2_VFS_OP_FILE_IO);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FILE_IO);
 	if (!new_op) {
 		ret = -ENOMEM;
 		goto out;
 	}
 	/* synchronous I/O */
-	new_op-&gt;upcall.req.io.async_vfs_io = PVFS_VFS_SYNC_IO;
+	new_op-&gt;upcall.req.io.async_vfs_io = ORANGEFS_VFS_SYNC_IO;
 	new_op-&gt;upcall.req.io.readahead_size = readahead_size;
 	new_op-&gt;upcall.req.io.io_type = type;
-	new_op-&gt;upcall.req.io.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.io.refn = orangefs_inode-&gt;refn;
 
 populate_shared_memory:
 	/* get a shared buffer index */
-	ret = pvfs_bufmap_get(&amp;bufmap, &amp;buffer_index);
+	ret = orangefs_bufmap_get(&amp;bufmap, &amp;buffer_index);
 	if (ret &lt; 0) {
 		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "%s: pvfs_bufmap_get failure (%ld)\n",
+			     "%s: orangefs_bufmap_get failure (%ld)\n",
 			     __func__, (long)ret);
 		goto out;
 	}
@@ -146,7 +146,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * Stage 1: copy the buffers into client-core's address space
 	 * precopy_buffers only pertains to writes.
 	 */
-	if (type == PVFS_IO_WRITE) {
+	if (type == ORANGEFS_IO_WRITE) {
 		ret = precopy_buffers(bufmap,
 				      buffer_index,
 				      iter,
@@ -163,14 +163,14 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 
 	/* Stage 2: Service the I/O operation */
 	ret = service_operation(new_op,
-				type == PVFS_IO_WRITE ?
+				type == ORANGEFS_IO_WRITE ?
 					"file_write" :
 					"file_read",
 				get_interruptible_flag(inode));
 
 	/*
 	 * If service_operation() returns -EAGAIN #and# the operation was
-	 * purged from pvfs2_request_list or htable_ops_in_progress, then
+	 * purged from orangefs_request_list or htable_ops_in_progress, then
 	 * we know that the client was restarted, causing the shared memory
 	 * area to be wiped clean.  To restart a  write operation in this
 	 * case, we must re-copy the data from the user's iovec to a NEW
@@ -178,7 +178,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * a new shared memory location.
 	 */
 	if (ret == -EAGAIN &amp;&amp; op_state_purged(new_op)) {
-		pvfs_bufmap_put(bufmap, buffer_index);
+		orangefs_bufmap_put(bufmap, buffer_index);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s:going to repopulate_shared_memory.\n",
 			     __func__);
@@ -199,7 +199,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 		else
 			gossip_err("%s: error in %s handle %pU, returning %zd\n",
 				__func__,
-				type == PVFS_IO_READ ?
+				type == ORANGEFS_IO_READ ?
 					"read from" : "write to",
 				handle, ret);
 		goto out;
@@ -209,7 +209,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 	 * Stage 3: Post copy buffers from client-core's address space
 	 * postcopy_buffers only pertains to reads.
 	 */
-	if (type == PVFS_IO_READ) {
+	if (type == ORANGEFS_IO_READ) {
 		ret = postcopy_buffers(bufmap,
 				       buffer_index,
 				       iter,
@@ -243,7 +243,7 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
 
 out:
 	if (buffer_index &gt;= 0) {
-		pvfs_bufmap_put(bufmap, buffer_index);
+		orangefs_bufmap_put(bufmap, buffer_index);
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): PUT buffer_index %d\n",
 			     __func__, handle, buffer_index);
@@ -263,12 +263,12 @@ static ssize_t wait_for_direct_io(enum PVFS_io_type type, struct inode *inode,
  * augmented/extended metadata attached to the file.
  * Note: File extended attributes override any mount options.
  */
-static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
+static ssize_t do_readv_writev(enum ORANGEFS_io_type type, struct file *file,
 		loff_t *offset, struct iov_iter *iter)
 {
 	struct inode *inode = file-&gt;f_mapping-&gt;host;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_khandle *handle = &amp;pvfs2_inode-&gt;refn.khandle;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_khandle *handle = &amp;orangefs_inode-&gt;refn.khandle;
 	size_t count = iov_iter_count(iter);
 	ssize_t total_count = 0;
 	ssize_t ret = -EINVAL;
@@ -279,7 +279,7 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		handle,
 		(int)count);
 
-	if (type == PVFS_IO_WRITE) {
+	if (type == ORANGEFS_IO_WRITE) {
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): proceeding with offset : %llu, "
 			     "size %d\n",
@@ -299,8 +299,8 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		size_t amt_complete;
 
 		/* how much to transfer in this loop iteration */
-		if (each_count &gt; pvfs_bufmap_size_query())
-			each_count = pvfs_bufmap_size_query();
+		if (each_count &gt; orangefs_bufmap_size_query())
+			each_count = orangefs_bufmap_size_query();
 
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s(%pU): size of each_count(%d)\n",
@@ -346,10 +346,10 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
 		ret = total_count;
 out:
 	if (ret &gt; 0) {
-		if (type == PVFS_IO_READ) {
+		if (type == ORANGEFS_IO_READ) {
 			file_accessed(file);
 		} else {
-			SetMtimeFlag(pvfs2_inode);
+			SetMtimeFlag(orangefs_inode);
 			inode-&gt;i_mtime = CURRENT_TIME;
 			mark_inode_dirty_sync(inode);
 		}
@@ -368,19 +368,19 @@ static ssize_t do_readv_writev(enum PVFS_io_type type, struct file *file,
  * Read data from a specified offset in a file (referenced by inode).
  * Data may be placed either in a user or kernel buffer.
  */
-ssize_t pvfs2_inode_read(struct inode *inode,
-			 struct iov_iter *iter,
-			 loff_t *offset,
-			 loff_t readahead_size)
+ssize_t orangefs_inode_read(struct inode *inode,
+			    struct iov_iter *iter,
+			    loff_t *offset,
+			    loff_t readahead_size)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	size_t count = iov_iter_count(iter);
 	size_t bufmap_size;
 	ssize_t ret = -EINVAL;
 
-	g_pvfs2_stats.reads++;
+	g_orangefs_stats.reads++;
 
-	bufmap_size = pvfs_bufmap_size_query();
+	bufmap_size = orangefs_bufmap_size_query();
 	if (count &gt; bufmap_size) {
 		gossip_debug(GOSSIP_FILE_DEBUG,
 			     "%s: count is too large (%zd/%zd)!\n",
@@ -391,11 +391,11 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "%s(%pU) %zd@%llu\n",
 		     __func__,
-		     &amp;pvfs2_inode-&gt;refn.khandle,
+		     &amp;orangefs_inode-&gt;refn.khandle,
 		     count,
 		     llu(*offset));
 
-	ret = wait_for_direct_io(PVFS_IO_READ, inode, offset, iter,
+	ret = wait_for_direct_io(ORANGEFS_IO_READ, inode, offset, iter,
 			count, readahead_size);
 	if (ret &gt; 0)
 		*offset += ret;
@@ -403,13 +403,13 @@ ssize_t pvfs2_inode_read(struct inode *inode,
 	gossip_debug(GOSSIP_FILE_DEBUG,
 		     "%s(%pU): Value(%zd) returned.\n",
 		     __func__,
-		     &amp;pvfs2_inode-&gt;refn.khandle,
+		     &amp;orangefs_inode-&gt;refn.khandle,
 		     ret);
 
 	return ret;
 }
 
-static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
+static ssize_t orangefs_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb-&gt;ki_filp;
 	loff_t pos = *(&amp;iocb-&gt;ki_pos);
@@ -417,17 +417,17 @@ static ssize_t pvfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)
 
 	BUG_ON(iocb-&gt;private);
 
-	gossip_debug(GOSSIP_FILE_DEBUG, "pvfs2_file_read_iter\n");
+	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_read_iter\n");
 
-	g_pvfs2_stats.reads++;
+	g_orangefs_stats.reads++;
 
-	rc = do_readv_writev(PVFS_IO_READ, file, &amp;pos, iter);
+	rc = do_readv_writev(ORANGEFS_IO_READ, file, &amp;pos, iter);
 	iocb-&gt;ki_pos = pos;
 
 	return rc;
 }
 
-static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
+static ssize_t orangefs_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 {
 	struct file *file = iocb-&gt;ki_filp;
 	loff_t pos;
@@ -435,23 +435,23 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 
 	BUG_ON(iocb-&gt;private);
 
-	gossip_debug(GOSSIP_FILE_DEBUG, "pvfs2_file_write_iter\n");
+	gossip_debug(GOSSIP_FILE_DEBUG, "orangefs_file_write_iter\n");
 
 	mutex_lock(&amp;file-&gt;f_mapping-&gt;host-&gt;i_mutex);
 
 	/* Make sure generic_write_checks sees an up to date inode size. */
 	if (file-&gt;f_flags &amp; O_APPEND) {
-		rc = pvfs2_inode_getattr(file-&gt;f_mapping-&gt;host,
-					 PVFS_ATTR_SYS_SIZE);
+		rc = orangefs_inode_getattr(file-&gt;f_mapping-&gt;host,
+					 ORANGEFS_ATTR_SYS_SIZE);
 		if (rc) {
-			gossip_err("%s: pvfs2_inode_getattr failed, rc:%zd:.\n",
+			gossip_err("%s: orangefs_inode_getattr failed, rc:%zd:.\n",
 				   __func__, rc);
 			goto out;
 		}
 	}
 
 	if (file-&gt;f_pos &gt; i_size_read(file-&gt;f_mapping-&gt;host))
-		pvfs2_i_size_write(file-&gt;f_mapping-&gt;host, file-&gt;f_pos);
+		orangefs_i_size_write(file-&gt;f_mapping-&gt;host, file-&gt;f_pos);
 
 	rc = generic_write_checks(iocb, iter);
 
@@ -468,7 +468,7 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 	 */
 	pos = *(&amp;iocb-&gt;ki_pos);
 
-	rc = do_readv_writev(PVFS_IO_WRITE,
+	rc = do_readv_writev(ORANGEFS_IO_WRITE,
 			     file,
 			     &amp;pos,
 			     iter);
@@ -479,7 +479,7 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 	}
 
 	iocb-&gt;ki_pos = pos;
-	g_pvfs2_stats.writes++;
+	g_orangefs_stats.writes++;
 
 out:
 
@@ -490,14 +490,14 @@ static ssize_t pvfs2_file_write_iter(struct kiocb *iocb, struct iov_iter *iter)
 /*
  * Perform a miscellaneous operation on a file.
  */
-static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static long orangefs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	int ret = -ENOTTY;
 	__u64 val = 0;
 	unsigned long uval;
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_ioctl: called with cmd %d\n",
+		     "orangefs_ioctl: called with cmd %d\n",
 		     cmd);
 
 	/*
@@ -506,17 +506,17 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	 */
 	if (cmd == FS_IOC_GETFLAGS) {
 		val = 0;
-		ret = pvfs2_inode_getxattr(file_inode(file),
-					   PVFS2_XATTR_NAME_DEFAULT_PREFIX,
-					   "user.pvfs2.meta_hint",
-					   &amp;val, sizeof(val));
+		ret = orangefs_inode_getxattr(file_inode(file),
+					      ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+					      "user.pvfs2.meta_hint",
+					      &amp;val, sizeof(val));
 		if (ret &lt; 0 &amp;&amp; ret != -ENODATA)
 			return ret;
 		else if (ret == -ENODATA)
 			val = 0;
 		uval = val;
 		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "pvfs2_ioctl: FS_IOC_GETFLAGS: %llu\n",
+			     "orangefs_ioctl: FS_IOC_GETFLAGS: %llu\n",
 			     (unsigned long long)uval);
 		return put_user(uval, (int __user *)arg);
 	} else if (cmd == FS_IOC_SETFLAGS) {
@@ -524,25 +524,25 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 		if (get_user(uval, (int __user *)arg))
 			return -EFAULT;
 		/*
-		 * PVFS_MIRROR_FL is set internally when the mirroring mode
+		 * ORANGEFS_MIRROR_FL is set internally when the mirroring mode
 		 * is turned on for a file. The user is not allowed to turn
 		 * on this bit, but the bit is present if the user first gets
 		 * the flags and then updates the flags with some new
 		 * settings. So, we ignore it in the following edit. bligon.
 		 */
-		if ((uval &amp; ~PVFS_MIRROR_FL) &amp;
+		if ((uval &amp; ~ORANGEFS_MIRROR_FL) &amp;
 		    (~(FS_IMMUTABLE_FL | FS_APPEND_FL | FS_NOATIME_FL))) {
-			gossip_err("pvfs2_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\n");
+			gossip_err("orangefs_ioctl: the FS_IOC_SETFLAGS only supports setting one of FS_IMMUTABLE_FL|FS_APPEND_FL|FS_NOATIME_FL\n");
 			return -EINVAL;
 		}
 		val = uval;
 		gossip_debug(GOSSIP_FILE_DEBUG,
-			     "pvfs2_ioctl: FS_IOC_SETFLAGS: %llu\n",
+			     "orangefs_ioctl: FS_IOC_SETFLAGS: %llu\n",
 			     (unsigned long long)val);
-		ret = pvfs2_inode_setxattr(file_inode(file),
-					   PVFS2_XATTR_NAME_DEFAULT_PREFIX,
-					   "user.pvfs2.meta_hint",
-					   &amp;val, sizeof(val), 0);
+		ret = orangefs_inode_setxattr(file_inode(file),
+					      ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+					      "user.pvfs2.meta_hint",
+					      &amp;val, sizeof(val), 0);
 	}
 
 	return ret;
@@ -551,10 +551,10 @@ static long pvfs2_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 /*
  * Memory map a region of a file.
  */
-static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)
+static int orangefs_file_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_file_mmap: called on %s\n",
+		     "orangefs_file_mmap: called on %s\n",
 		     (file ?
 			(char *)file-&gt;f_path.dentry-&gt;d_name.name :
 			(char *)"Unknown"));
@@ -575,13 +575,13 @@ static int pvfs2_file_mmap(struct file *file, struct vm_area_struct *vma)
  *
  * \note Not called when each file is closed.
  */
-static int pvfs2_file_release(struct inode *inode, struct file *file)
+static int orangefs_file_release(struct inode *inode, struct file *file)
 {
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_file_release: called on %s\n",
+		     "orangefs_file_release: called on %s\n",
 		     file-&gt;f_path.dentry-&gt;d_name.name);
 
-	pvfs2_flush_inode(inode);
+	orangefs_flush_inode(inode);
 
 	/*
 	 * remove all associated inode pages from the page cache and mmap
@@ -599,35 +599,35 @@ static int pvfs2_file_release(struct inode *inode, struct file *file)
 /*
  * Push all data for a specific file onto permanent storage.
  */
-static int pvfs2_fsync(struct file *file,
+static int orangefs_fsync(struct file *file,
 		       loff_t start,
 		       loff_t end,
 		       int datasync)
 {
 	int ret = -EINVAL;
-	struct pvfs2_inode_s *pvfs2_inode =
-		PVFS2_I(file-&gt;f_path.dentry-&gt;d_inode);
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode =
+		ORANGEFS_I(file-&gt;f_path.dentry-&gt;d_inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
 
 	/* required call */
 	filemap_write_and_wait_range(file-&gt;f_mapping, start, end);
 
-	new_op = op_alloc(PVFS2_VFS_OP_FSYNC);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FSYNC);
 	if (!new_op)
 		return -ENOMEM;
-	new_op-&gt;upcall.req.fsync.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.fsync.refn = orangefs_inode-&gt;refn;
 
 	ret = service_operation(new_op,
-			"pvfs2_fsync",
+			"orangefs_fsync",
 			get_interruptible_flag(file-&gt;f_path.dentry-&gt;d_inode));
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_fsync got return value of %d\n",
+		     "orangefs_fsync got return value of %d\n",
 		     ret);
 
 	op_release(new_op);
 
-	pvfs2_flush_inode(file-&gt;f_path.dentry-&gt;d_inode);
+	orangefs_flush_inode(file-&gt;f_path.dentry-&gt;d_inode);
 	return ret;
 }
 
@@ -640,36 +640,36 @@ static int pvfs2_fsync(struct file *file,
  * Future upgrade could support SEEK_DATA and SEEK_HOLE but would
  * require much changes to the FS
  */
-static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
+static loff_t orangefs_file_llseek(struct file *file, loff_t offset, int origin)
 {
 	int ret = -EINVAL;
 	struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
 
 	if (!inode) {
-		gossip_err("pvfs2_file_llseek: invalid inode (NULL)\n");
+		gossip_err("orangefs_file_llseek: invalid inode (NULL)\n");
 		return ret;
 	}
 
-	if (origin == PVFS2_SEEK_END) {
+	if (origin == ORANGEFS_SEEK_END) {
 		/*
 		 * revalidate the inode's file size.
 		 * NOTE: We are only interested in file size here,
 		 * so we set mask accordingly.
 		 */
-		ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_SIZE);
+		ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_SIZE);
 		if (ret) {
 			gossip_debug(GOSSIP_FILE_DEBUG,
 				     "%s:%s:%d calling make bad inode\n",
 				     __FILE__,
 				     __func__,
 				     __LINE__);
-			pvfs2_make_bad_inode(inode);
+			orangefs_make_bad_inode(inode);
 			return ret;
 		}
 	}
 
 	gossip_debug(GOSSIP_FILE_DEBUG,
-		     "pvfs2_file_llseek: offset is %ld | origin is %d"
+		     "orangefs_file_llseek: offset is %ld | origin is %d"
 		     " | inode size is %lu\n",
 		     (long)offset,
 		     origin,
@@ -682,11 +682,11 @@ static loff_t pvfs2_file_llseek(struct file *file, loff_t offset, int origin)
  * Support local locks (locks that only this kernel knows about)
  * if Orangefs was mounted -o local_lock.
  */
-static int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
+static int orangefs_lock(struct file *filp, int cmd, struct file_lock *fl)
 {
 	int rc = -EINVAL;
 
-	if (PVFS2_SB(filp-&gt;f_inode-&gt;i_sb)-&gt;flags &amp; PVFS2_OPT_LOCAL_LOCK) {
+	if (ORANGEFS_SB(filp-&gt;f_inode-&gt;i_sb)-&gt;flags &amp; ORANGEFS_OPT_LOCAL_LOCK) {
 		if (cmd == F_GETLK) {
 			rc = 0;
 			posix_test_lock(filp, fl);
@@ -698,15 +698,15 @@ static int pvfs2_lock(struct file *filp, int cmd, struct file_lock *fl)
 	return rc;
 }
 
-/** PVFS2 implementation of VFS file operations */
-const struct file_operations pvfs2_file_operations = {
-	.llseek		= pvfs2_file_llseek,
-	.read_iter	= pvfs2_file_read_iter,
-	.write_iter	= pvfs2_file_write_iter,
-	.lock		= pvfs2_lock,
-	.unlocked_ioctl	= pvfs2_ioctl,
-	.mmap		= pvfs2_file_mmap,
+/** ORANGEFS implementation of VFS file operations */
+const struct file_operations orangefs_file_operations = {
+	.llseek		= orangefs_file_llseek,
+	.read_iter	= orangefs_file_read_iter,
+	.write_iter	= orangefs_file_write_iter,
+	.lock		= orangefs_lock,
+	.unlocked_ioctl	= orangefs_ioctl,
+	.mmap		= orangefs_file_mmap,
 	.open		= generic_file_open,
-	.release	= pvfs2_file_release,
-	.fsync		= pvfs2_fsync,
+	.release	= orangefs_file_release,
+	.fsync		= orangefs_fsync,
 };
diff --git a/fs/orangefs/inode.c b/fs/orangefs/inode.c
index 70d1c1925ea3..58e83182d3dc 100644
--- a/fs/orangefs/inode.c
+++ b/fs/orangefs/inode.c
@@ -26,7 +26,7 @@ static int read_one_page(struct page *page)
 	iov_iter_bvec(&amp;to, ITER_BVEC | READ, &amp;bv, 1, PAGE_SIZE);
 
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		    "pvfs2_readpage called with page %p\n",
+		    "orangefs_readpage called with page %p\n",
 		     page);
 
 	max_block = ((inode-&gt;i_size / blocksize) + 1);
@@ -34,10 +34,10 @@ static int read_one_page(struct page *page)
 	if (page-&gt;index &lt; max_block) {
 		loff_t blockptr_offset = (((loff_t) page-&gt;index) &lt;&lt; blockbits);
 
-		bytes_read = pvfs2_inode_read(inode,
-					      &amp;to,
-					      &amp;blockptr_offset,
-					      inode-&gt;i_size);
+		bytes_read = orangefs_inode_read(inode,
+						 &amp;to,
+						 &amp;blockptr_offset,
+						 inode-&gt;i_size);
 	}
 	/* this will only zero remaining unread portions of the page data */
 	iov_iter_zero(~0U, &amp;to);
@@ -57,12 +57,12 @@ static int read_one_page(struct page *page)
 	return ret;
 }
 
-static int pvfs2_readpage(struct file *file, struct page *page)
+static int orangefs_readpage(struct file *file, struct page *page)
 {
 	return read_one_page(page);
 }
 
-static int pvfs2_readpages(struct file *file,
+static int orangefs_readpages(struct file *file,
 			   struct address_space *mapping,
 			   struct list_head *pages,
 			   unsigned nr_pages)
@@ -70,7 +70,7 @@ static int pvfs2_readpages(struct file *file,
 	int page_idx;
 	int ret;
 
-	gossip_debug(GOSSIP_INODE_DEBUG, "pvfs2_readpages called\n");
+	gossip_debug(GOSSIP_INODE_DEBUG, "orangefs_readpages called\n");
 
 	for (page_idx = 0; page_idx &lt; nr_pages; page_idx++) {
 		struct page *page;
@@ -93,12 +93,12 @@ static int pvfs2_readpages(struct file *file,
 	return 0;
 }
 
-static void pvfs2_invalidatepage(struct page *page,
+static void orangefs_invalidatepage(struct page *page,
 				 unsigned int offset,
 				 unsigned int length)
 {
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		     "pvfs2_invalidatepage called on page %p "
+		     "orangefs_invalidatepage called on page %p "
 		     "(offset is %u)\n",
 		     page,
 		     offset);
@@ -109,10 +109,10 @@ static void pvfs2_invalidatepage(struct page *page,
 
 }
 
-static int pvfs2_releasepage(struct page *page, gfp_t foo)
+static int orangefs_releasepage(struct page *page, gfp_t foo)
 {
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		     "pvfs2_releasepage called on page %p\n",
+		     "orangefs_releasepage called on page %p\n",
 		     page);
 	return 0;
 }
@@ -131,32 +131,32 @@ static int pvfs2_releasepage(struct page *page, gfp_t foo)
  *			loff_t offset)
  *{
  *	gossip_debug(GOSSIP_INODE_DEBUG,
- *		     "pvfs2_direct_IO: %s\n",
+ *		     "orangefs_direct_IO: %s\n",
  *		     iocb-&gt;ki_filp-&gt;f_path.dentry-&gt;d_name.name);
  *
  *	return -EINVAL;
  *}
  */
 
-struct backing_dev_info pvfs2_backing_dev_info = {
-	.name = "pvfs2",
+struct backing_dev_info orangefs_backing_dev_info = {
+	.name = "orangefs",
 	.ra_pages = 0,
 	.capabilities = BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK,
 };
 
-/** PVFS2 implementation of address space operations */
-const struct address_space_operations pvfs2_address_operations = {
-	.readpage = pvfs2_readpage,
-	.readpages = pvfs2_readpages,
-	.invalidatepage = pvfs2_invalidatepage,
-	.releasepage = pvfs2_releasepage,
+/** ORANGEFS2 implementation of address space operations */
+const struct address_space_operations orangefs_address_operations = {
+	.readpage = orangefs_readpage,
+	.readpages = orangefs_readpages,
+	.invalidatepage = orangefs_invalidatepage,
+	.releasepage = orangefs_releasepage,
 /*	.direct_IO = pvfs2_direct_IO */
 };
 
-static int pvfs2_setattr_size(struct inode *inode, struct iattr *iattr)
+static int orangefs_setattr_size(struct inode *inode, struct iattr *iattr)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
 	loff_t orig_size = i_size_read(inode);
 	int ret = -EINVAL;
 
@@ -164,17 +164,17 @@ static int pvfs2_setattr_size(struct inode *inode, struct iattr *iattr)
 		     "%s: %pU: Handle is %pU | fs_id %d | size is %llu\n",
 		     __func__,
 		     get_khandle_from_ino(inode),
-		     &amp;pvfs2_inode-&gt;refn.khandle,
-		     pvfs2_inode-&gt;refn.fs_id,
+		     &amp;orangefs_inode-&gt;refn.khandle,
+		     orangefs_inode-&gt;refn.fs_id,
 		     iattr-&gt;ia_size);
 
 	truncate_setsize(inode, iattr-&gt;ia_size);
 
-	new_op = op_alloc(PVFS2_VFS_OP_TRUNCATE);
+	new_op = op_alloc(ORANGEFS_VFS_OP_TRUNCATE);
 	if (!new_op)
 		return -ENOMEM;
 
-	new_op-&gt;upcall.req.truncate.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.truncate.refn = orangefs_inode-&gt;refn;
 	new_op-&gt;upcall.req.truncate.size = (__s64) iattr-&gt;ia_size;
 
 	ret = service_operation(new_op, __func__,
@@ -185,7 +185,7 @@ static int pvfs2_setattr_size(struct inode *inode, struct iattr *iattr)
 	 * the status value tells us if it went through ok or not
 	 */
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		     "pvfs2: pvfs2_truncate got return value of %d\n",
+		     "orangefs: orangefs_truncate got return value of %d\n",
 		     ret);
 
 	op_release(new_op);
@@ -216,13 +216,13 @@ static int pvfs2_setattr_size(struct inode *inode, struct iattr *iattr)
 /*
  * Change attributes of an object referenced by dentry.
  */
-int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr)
+int orangefs_setattr(struct dentry *dentry, struct iattr *iattr)
 {
 	int ret = -EINVAL;
 	struct inode *inode = dentry-&gt;d_inode;
 
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		     "pvfs2_setattr: called on %s\n",
+		     "orangefs_setattr: called on %s\n",
 		     dentry-&gt;d_name.name);
 
 	ret = inode_change_ok(inode, iattr);
@@ -231,7 +231,7 @@ int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr)
 
 	if ((iattr-&gt;ia_valid &amp; ATTR_SIZE) &amp;&amp;
 	    iattr-&gt;ia_size != i_size_read(inode)) {
-		ret = pvfs2_setattr_size(inode, iattr);
+		ret = orangefs_setattr_size(inode, iattr);
 		if (ret)
 			goto out;
 	}
@@ -239,9 +239,9 @@ int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr)
 	setattr_copy(inode, iattr);
 	mark_inode_dirty(inode);
 
-	ret = pvfs2_inode_setattr(inode, iattr);
+	ret = orangefs_inode_setattr(inode, iattr);
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		     "pvfs2_setattr: inode_setattr returned %d\n",
+		     "orangefs_setattr: inode_setattr returned %d\n",
 		     ret);
 
 	if (!ret &amp;&amp; (iattr-&gt;ia_valid &amp; ATTR_MODE))
@@ -249,23 +249,23 @@ int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr)
 		ret = posix_acl_chmod(inode, inode-&gt;i_mode);
 
 out:
-	gossip_debug(GOSSIP_INODE_DEBUG, "pvfs2_setattr: returning %d\n", ret);
+	gossip_debug(GOSSIP_INODE_DEBUG, "orangefs_setattr: returning %d\n", ret);
 	return ret;
 }
 
 /*
  * Obtain attributes of an object given a dentry
  */
-int pvfs2_getattr(struct vfsmount *mnt,
+int orangefs_getattr(struct vfsmount *mnt,
 		  struct dentry *dentry,
 		  struct kstat *kstat)
 {
 	int ret = -ENOENT;
 	struct inode *inode = dentry-&gt;d_inode;
-	struct pvfs2_inode_s *pvfs2_inode = NULL;
+	struct orangefs_inode_s *orangefs_inode = NULL;
 
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		     "pvfs2_getattr: called on %s\n",
+		     "orangefs_getattr: called on %s\n",
 		     dentry-&gt;d_name.name);
 
 	/*
@@ -273,12 +273,12 @@ int pvfs2_getattr(struct vfsmount *mnt,
 	 * fields/attributes of the inode would be refreshed. So again, we
 	 * dont have too much of a choice but refresh all the attributes.
 	 */
-	ret = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);
+	ret = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);
 	if (ret == 0) {
 		generic_fillattr(inode, kstat);
 		/* override block size reported to stat */
-		pvfs2_inode = PVFS2_I(inode);
-		kstat-&gt;blksize = pvfs2_inode-&gt;blksize;
+		orangefs_inode = ORANGEFS_I(inode);
+		kstat-&gt;blksize = orangefs_inode-&gt;blksize;
 	} else {
 		/* assume an I/O error and flag inode as bad */
 		gossip_debug(GOSSIP_INODE_DEBUG,
@@ -286,39 +286,39 @@ int pvfs2_getattr(struct vfsmount *mnt,
 			     __FILE__,
 			     __func__,
 			     __LINE__);
-		pvfs2_make_bad_inode(inode);
+		orangefs_make_bad_inode(inode);
 	}
 	return ret;
 }
 
-/* PVFS2 implementation of VFS inode operations for files */
-struct inode_operations pvfs2_file_inode_operations = {
-	.get_acl = pvfs2_get_acl,
-	.set_acl = pvfs2_set_acl,
-	.setattr = pvfs2_setattr,
-	.getattr = pvfs2_getattr,
+/* ORANGEDS2 implementation of VFS inode operations for files */
+struct inode_operations orangefs_file_inode_operations = {
+	.get_acl = orangefs_get_acl,
+	.set_acl = orangefs_set_acl,
+	.setattr = orangefs_setattr,
+	.getattr = orangefs_getattr,
 	.setxattr = generic_setxattr,
 	.getxattr = generic_getxattr,
-	.listxattr = pvfs2_listxattr,
+	.listxattr = orangefs_listxattr,
 	.removexattr = generic_removexattr,
 };
 
-static int pvfs2_init_iops(struct inode *inode)
+static int orangefs_init_iops(struct inode *inode)
 {
-	inode-&gt;i_mapping-&gt;a_ops = &amp;pvfs2_address_operations;
+	inode-&gt;i_mapping-&gt;a_ops = &amp;orangefs_address_operations;
 
 	switch (inode-&gt;i_mode &amp; S_IFMT) {
 	case S_IFREG:
-		inode-&gt;i_op = &amp;pvfs2_file_inode_operations;
-		inode-&gt;i_fop = &amp;pvfs2_file_operations;
+		inode-&gt;i_op = &amp;orangefs_file_inode_operations;
+		inode-&gt;i_fop = &amp;orangefs_file_operations;
 		inode-&gt;i_blkbits = PAGE_CACHE_SHIFT;
 		break;
 	case S_IFLNK:
-		inode-&gt;i_op = &amp;pvfs2_symlink_inode_operations;
+		inode-&gt;i_op = &amp;orangefs_symlink_inode_operations;
 		break;
 	case S_IFDIR:
-		inode-&gt;i_op = &amp;pvfs2_dir_inode_operations;
-		inode-&gt;i_fop = &amp;pvfs2_dir_operations;
+		inode-&gt;i_op = &amp;orangefs_dir_inode_operations;
+		inode-&gt;i_fop = &amp;orangefs_dir_operations;
 		break;
 	default:
 		gossip_debug(GOSSIP_INODE_DEBUG,
@@ -331,75 +331,75 @@ static int pvfs2_init_iops(struct inode *inode)
 }
 
 /*
- * Given a PVFS2 object identifier (fsid, handle), convert it into a ino_t type
+ * Given a ORANGEFS object identifier (fsid, handle), convert it into a ino_t type
  * that will be used as a hash-index from where the handle will
  * be searched for in the VFS hash table of inodes.
  */
-static inline ino_t pvfs2_handle_hash(struct pvfs2_object_kref *ref)
+static inline ino_t orangefs_handle_hash(struct orangefs_object_kref *ref)
 {
 	if (!ref)
 		return 0;
-	return pvfs2_khandle_to_ino(&amp;(ref-&gt;khandle));
+	return orangefs_khandle_to_ino(&amp;(ref-&gt;khandle));
 }
 
 /*
  * Called to set up an inode from iget5_locked.
  */
-static int pvfs2_set_inode(struct inode *inode, void *data)
+static int orangefs_set_inode(struct inode *inode, void *data)
 {
-	struct pvfs2_object_kref *ref = (struct pvfs2_object_kref *) data;
-	struct pvfs2_inode_s *pvfs2_inode = NULL;
+	struct orangefs_object_kref *ref = (struct orangefs_object_kref *) data;
+	struct orangefs_inode_s *orangefs_inode = NULL;
 
 	/* Make sure that we have sane parameters */
 	if (!data || !inode)
 		return 0;
-	pvfs2_inode = PVFS2_I(inode);
-	if (!pvfs2_inode)
+	orangefs_inode = ORANGEFS_I(inode);
+	if (!orangefs_inode)
 		return 0;
-	pvfs2_inode-&gt;refn.fs_id = ref-&gt;fs_id;
-	pvfs2_inode-&gt;refn.khandle = ref-&gt;khandle;
+	orangefs_inode-&gt;refn.fs_id = ref-&gt;fs_id;
+	orangefs_inode-&gt;refn.khandle = ref-&gt;khandle;
 	return 0;
 }
 
 /*
  * Called to determine if handles match.
  */
-static int pvfs2_test_inode(struct inode *inode, void *data)
+static int orangefs_test_inode(struct inode *inode, void *data)
 {
-	struct pvfs2_object_kref *ref = (struct pvfs2_object_kref *) data;
-	struct pvfs2_inode_s *pvfs2_inode = NULL;
+	struct orangefs_object_kref *ref = (struct orangefs_object_kref *) data;
+	struct orangefs_inode_s *orangefs_inode = NULL;
 
-	pvfs2_inode = PVFS2_I(inode);
-	return (!PVFS_khandle_cmp(&amp;(pvfs2_inode-&gt;refn.khandle), &amp;(ref-&gt;khandle))
-		&amp;&amp; pvfs2_inode-&gt;refn.fs_id == ref-&gt;fs_id);
+	orangefs_inode = ORANGEFS_I(inode);
+	return (!ORANGEFS_khandle_cmp(&amp;(orangefs_inode-&gt;refn.khandle), &amp;(ref-&gt;khandle))
+		&amp;&amp; orangefs_inode-&gt;refn.fs_id == ref-&gt;fs_id);
 }
 
 /*
- * Front-end to lookup the inode-cache maintained by the VFS using the PVFS2
+ * Front-end to lookup the inode-cache maintained by the VFS using the ORANGEFS
  * file handle.
  *
  * @sb: the file system super block instance.
- * @ref: The PVFS2 object for which we are trying to locate an inode structure.
+ * @ref: The ORANGEFS object for which we are trying to locate an inode structure.
  */
-struct inode *pvfs2_iget(struct super_block *sb, struct pvfs2_object_kref *ref)
+struct inode *orangefs_iget(struct super_block *sb, struct orangefs_object_kref *ref)
 {
 	struct inode *inode = NULL;
 	unsigned long hash;
 	int error;
 
-	hash = pvfs2_handle_hash(ref);
-	inode = iget5_locked(sb, hash, pvfs2_test_inode, pvfs2_set_inode, ref);
+	hash = orangefs_handle_hash(ref);
+	inode = iget5_locked(sb, hash, orangefs_test_inode, orangefs_set_inode, ref);
 	if (!inode || !(inode-&gt;i_state &amp; I_NEW))
 		return inode;
 
-	error = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);
+	error = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);
 	if (error) {
 		iget_failed(inode);
 		return ERR_PTR(error);
 	}
 
 	inode-&gt;i_ino = hash;	/* needed for stat etc */
-	pvfs2_init_iops(inode);
+	orangefs_init_iops(inode);
 	unlock_new_inode(inode);
 
 	gossip_debug(GOSSIP_INODE_DEBUG,
@@ -415,15 +415,15 @@ struct inode *pvfs2_iget(struct super_block *sb, struct pvfs2_object_kref *ref)
 /*
  * Allocate an inode for a newly created file and insert it into the inode hash.
  */
-struct inode *pvfs2_new_inode(struct super_block *sb, struct inode *dir,
-		int mode, dev_t dev, struct pvfs2_object_kref *ref)
+struct inode *orangefs_new_inode(struct super_block *sb, struct inode *dir,
+		int mode, dev_t dev, struct orangefs_object_kref *ref)
 {
-	unsigned long hash = pvfs2_handle_hash(ref);
+	unsigned long hash = orangefs_handle_hash(ref);
 	struct inode *inode;
 	int error;
 
 	gossip_debug(GOSSIP_INODE_DEBUG,
-		     "pvfs2_get_custom_inode_common: called\n"
+		     "orangefs_get_custom_inode_common: called\n"
 		     "(sb is %p | MAJOR(dev)=%u | MINOR(dev)=%u mode=%o)\n",
 		     sb,
 		     MAJOR(dev),
@@ -434,14 +434,14 @@ struct inode *pvfs2_new_inode(struct super_block *sb, struct inode *dir,
 	if (!inode)
 		return NULL;
 
-	pvfs2_set_inode(inode, ref);
+	orangefs_set_inode(inode, ref);
 	inode-&gt;i_ino = hash;	/* needed for stat etc */
 
-	error = pvfs2_inode_getattr(inode, PVFS_ATTR_SYS_ALL_NOHINT);
+	error = orangefs_inode_getattr(inode, ORANGEFS_ATTR_SYS_ALL_NOHINT);
 	if (error)
 		goto out_iput;
 
-	pvfs2_init_iops(inode);
+	orangefs_init_iops(inode);
 
 	inode-&gt;i_mode = mode;
 	inode-&gt;i_uid = current_fsuid();
@@ -450,14 +450,14 @@ struct inode *pvfs2_new_inode(struct super_block *sb, struct inode *dir,
 	inode-&gt;i_size = PAGE_CACHE_SIZE;
 	inode-&gt;i_rdev = dev;
 
-	error = insert_inode_locked4(inode, hash, pvfs2_test_inode, ref);
+	error = insert_inode_locked4(inode, hash, orangefs_test_inode, ref);
 	if (error &lt; 0)
 		goto out_iput;
 
 	gossip_debug(GOSSIP_INODE_DEBUG,
 		     "Initializing ACL's for inode %pU\n",
 		     get_khandle_from_ino(inode));
-	pvfs2_init_acl(inode, dir);
+	orangefs_init_acl(inode, dir);
 	return inode;
 
 out_iput:
diff --git a/fs/orangefs/namei.c b/fs/orangefs/namei.c
index 39f96ace0289..333c87c8b0f5 100644
--- a/fs/orangefs/namei.c
+++ b/fs/orangefs/namei.c
@@ -14,34 +14,34 @@
 /*
  * Get a newly allocated inode to go with a negative dentry.
  */
-static int pvfs2_create(struct inode *dir,
+static int orangefs_create(struct inode *dir,
 			struct dentry *dentry,
 			umode_t mode,
 			bool exclusive)
 {
-	struct pvfs2_inode_s *parent = PVFS2_I(dir);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *parent = ORANGEFS_I(dir);
+	struct orangefs_kernel_op_s *new_op;
 	struct inode *inode;
 	int ret;
 
 	gossip_debug(GOSSIP_NAME_DEBUG, "%s: called\n", __func__);
 
-	new_op = op_alloc(PVFS2_VFS_OP_CREATE);
+	new_op = op_alloc(ORANGEFS_VFS_OP_CREATE);
 	if (!new_op)
 		return -ENOMEM;
 
 	new_op-&gt;upcall.req.create.parent_refn = parent-&gt;refn;
 
 	fill_default_sys_attrs(new_op-&gt;upcall.req.create.attributes,
-			       PVFS_TYPE_METAFILE, mode);
+			       ORANGEFS_TYPE_METAFILE, mode);
 
 	strncpy(new_op-&gt;upcall.req.create.d_name,
-		dentry-&gt;d_name.name, PVFS2_NAME_LEN);
+		dentry-&gt;d_name.name, ORANGEFS_NAME_LEN);
 
 	ret = service_operation(new_op, __func__, get_interruptible_flag(dir));
 
 	gossip_debug(GOSSIP_NAME_DEBUG,
-		     "Create Got PVFS2 handle %pU on fsid %d (ret=%d)\n",
+		     "Create Got ORANGEFS handle %pU on fsid %d (ret=%d)\n",
 		     &amp;new_op-&gt;downcall.resp.create.refn.khandle,
 		     new_op-&gt;downcall.resp.create.refn.fs_id, ret);
 
@@ -52,10 +52,10 @@ static int pvfs2_create(struct inode *dir,
 		goto out;
 	}
 
-	inode = pvfs2_new_inode(dir-&gt;i_sb, dir, S_IFREG | mode, 0,
+	inode = orangefs_new_inode(dir-&gt;i_sb, dir, S_IFREG | mode, 0,
 				&amp;new_op-&gt;downcall.resp.create.refn);
 	if (IS_ERR(inode)) {
-		gossip_err("*** Failed to allocate pvfs2 file inode\n");
+		gossip_err("*** Failed to allocate orangefs file inode\n");
 		ret = PTR_ERR(inode);
 		goto out;
 	}
@@ -86,11 +86,11 @@ static int pvfs2_create(struct inode *dir,
  * Attempt to resolve an object name (dentry-&gt;d_name), parent handle, and
  * fsid into a handle for the object.
  */
-static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,
+static struct dentry *orangefs_lookup(struct inode *dir, struct dentry *dentry,
 				   unsigned int flags)
 {
-	struct pvfs2_inode_s *parent = PVFS2_I(dir);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *parent = ORANGEFS_I(dir);
+	struct orangefs_kernel_op_s *new_op;
 	struct inode *inode;
 	struct dentry *res;
 	int ret = -EINVAL;
@@ -106,10 +106,10 @@ static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,
 	gossip_debug(GOSSIP_NAME_DEBUG, "%s called on %s\n",
 		     __func__, dentry-&gt;d_name.name);
 
-	if (dentry-&gt;d_name.len &gt; (PVFS2_NAME_LEN - 1))
+	if (dentry-&gt;d_name.len &gt; (ORANGEFS_NAME_LEN - 1))
 		return ERR_PTR(-ENAMETOOLONG);
 
-	new_op = op_alloc(PVFS2_VFS_OP_LOOKUP);
+	new_op = op_alloc(ORANGEFS_VFS_OP_LOOKUP);
 	if (!new_op)
 		return ERR_PTR(-ENOMEM);
 
@@ -123,7 +123,7 @@ static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,
 	new_op-&gt;upcall.req.lookup.parent_refn = parent-&gt;refn;
 
 	strncpy(new_op-&gt;upcall.req.lookup.d_name, dentry-&gt;d_name.name,
-		PVFS2_NAME_LEN);
+		ORANGEFS_NAME_LEN);
 
 	gossip_debug(GOSSIP_NAME_DEBUG,
 		     "%s: doing lookup on %s under %pU,%d (follow=%s)\n",
@@ -132,7 +132,7 @@ static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,
 		     &amp;new_op-&gt;upcall.req.lookup.parent_refn.khandle,
 		     new_op-&gt;upcall.req.lookup.parent_refn.fs_id,
 		     ((new_op-&gt;upcall.req.lookup.sym_follow ==
-		       PVFS2_LOOKUP_LINK_FOLLOW) ? "yes" : "no"));
+		       ORANGEFS_LOOKUP_LINK_FOLLOW) ? "yes" : "no"));
 
 	ret = service_operation(new_op, __func__, get_interruptible_flag(dir));
 
@@ -158,7 +158,7 @@ static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,
 			 */
 
 			gossip_debug(GOSSIP_NAME_DEBUG,
-				     "pvfs2_lookup: Adding *negative* dentry "
+				     "orangefs_lookup: Adding *negative* dentry "
 				     "%p for %s\n",
 				     dentry,
 				     dentry-&gt;d_name.name);
@@ -173,7 +173,7 @@ static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,
 		goto out;
 	}
 
-	inode = pvfs2_iget(dir-&gt;i_sb, &amp;new_op-&gt;downcall.resp.lookup.refn);
+	inode = orangefs_iget(dir-&gt;i_sb, &amp;new_op-&gt;downcall.resp.lookup.refn);
 	if (IS_ERR(inode)) {
 		gossip_debug(GOSSIP_NAME_DEBUG,
 			"error %ld from iget\n", PTR_ERR(inode));
@@ -202,11 +202,11 @@ static struct dentry *pvfs2_lookup(struct inode *dir, struct dentry *dentry,
 }
 
 /* return 0 on success; non-zero otherwise */
-static int pvfs2_unlink(struct inode *dir, struct dentry *dentry)
+static int orangefs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	struct inode *inode = dentry-&gt;d_inode;
-	struct pvfs2_inode_s *parent = PVFS2_I(dir);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *parent = ORANGEFS_I(dir);
+	struct orangefs_kernel_op_s *new_op;
 	int ret;
 
 	gossip_debug(GOSSIP_NAME_DEBUG,
@@ -218,15 +218,15 @@ static int pvfs2_unlink(struct inode *dir, struct dentry *dentry)
 		     &amp;parent-&gt;refn.khandle,
 		     parent-&gt;refn.fs_id);
 
-	new_op = op_alloc(PVFS2_VFS_OP_REMOVE);
+	new_op = op_alloc(ORANGEFS_VFS_OP_REMOVE);
 	if (!new_op)
 		return -ENOMEM;
 
 	new_op-&gt;upcall.req.remove.parent_refn = parent-&gt;refn;
 	strncpy(new_op-&gt;upcall.req.remove.d_name, dentry-&gt;d_name.name,
-		PVFS2_NAME_LEN);
+		ORANGEFS_NAME_LEN);
 
-	ret = service_operation(new_op, "pvfs2_unlink",
+	ret = service_operation(new_op, "orangefs_unlink",
 				get_interruptible_flag(inode));
 
 	/* when request is serviced properly, free req op struct */
@@ -242,12 +242,12 @@ static int pvfs2_unlink(struct inode *dir, struct dentry *dentry)
 	return ret;
 }
 
-static int pvfs2_symlink(struct inode *dir,
+static int orangefs_symlink(struct inode *dir,
 			 struct dentry *dentry,
 			 const char *symname)
 {
-	struct pvfs2_inode_s *parent = PVFS2_I(dir);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *parent = ORANGEFS_I(dir);
+	struct orangefs_kernel_op_s *new_op;
 	struct inode *inode;
 	int mode = 755;
 	int ret;
@@ -257,25 +257,25 @@ static int pvfs2_symlink(struct inode *dir,
 	if (!symname)
 		return -EINVAL;
 
-	new_op = op_alloc(PVFS2_VFS_OP_SYMLINK);
+	new_op = op_alloc(ORANGEFS_VFS_OP_SYMLINK);
 	if (!new_op)
 		return -ENOMEM;
 
 	new_op-&gt;upcall.req.sym.parent_refn = parent-&gt;refn;
 
 	fill_default_sys_attrs(new_op-&gt;upcall.req.sym.attributes,
-			       PVFS_TYPE_SYMLINK,
+			       ORANGEFS_TYPE_SYMLINK,
 			       mode);
 
 	strncpy(new_op-&gt;upcall.req.sym.entry_name,
 		dentry-&gt;d_name.name,
-		PVFS2_NAME_LEN);
-	strncpy(new_op-&gt;upcall.req.sym.target, symname, PVFS2_NAME_LEN);
+		ORANGEFS_NAME_LEN);
+	strncpy(new_op-&gt;upcall.req.sym.target, symname, ORANGEFS_NAME_LEN);
 
 	ret = service_operation(new_op, __func__, get_interruptible_flag(dir));
 
 	gossip_debug(GOSSIP_NAME_DEBUG,
-		     "Symlink Got PVFS2 handle %pU on fsid %d (ret=%d)\n",
+		     "Symlink Got ORANGEFS handle %pU on fsid %d (ret=%d)\n",
 		     &amp;new_op-&gt;downcall.resp.sym.refn.khandle,
 		     new_op-&gt;downcall.resp.sym.refn.fs_id, ret);
 
@@ -286,11 +286,11 @@ static int pvfs2_symlink(struct inode *dir,
 		goto out;
 	}
 
-	inode = pvfs2_new_inode(dir-&gt;i_sb, dir, S_IFLNK | mode, 0,
+	inode = orangefs_new_inode(dir-&gt;i_sb, dir, S_IFLNK | mode, 0,
 				&amp;new_op-&gt;downcall.resp.sym.refn);
 	if (IS_ERR(inode)) {
 		gossip_err
-		    ("*** Failed to allocate pvfs2 symlink inode\n");
+		    ("*** Failed to allocate orangefs symlink inode\n");
 		ret = PTR_ERR(inode);
 		goto out;
 	}
@@ -316,29 +316,29 @@ static int pvfs2_symlink(struct inode *dir,
 	return ret;
 }
 
-static int pvfs2_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
+static int orangefs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 {
-	struct pvfs2_inode_s *parent = PVFS2_I(dir);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *parent = ORANGEFS_I(dir);
+	struct orangefs_kernel_op_s *new_op;
 	struct inode *inode;
 	int ret;
 
-	new_op = op_alloc(PVFS2_VFS_OP_MKDIR);
+	new_op = op_alloc(ORANGEFS_VFS_OP_MKDIR);
 	if (!new_op)
 		return -ENOMEM;
 
 	new_op-&gt;upcall.req.mkdir.parent_refn = parent-&gt;refn;
 
 	fill_default_sys_attrs(new_op-&gt;upcall.req.mkdir.attributes,
-			       PVFS_TYPE_DIRECTORY, mode);
+			      ORANGEFS_TYPE_DIRECTORY, mode);
 
 	strncpy(new_op-&gt;upcall.req.mkdir.d_name,
-		dentry-&gt;d_name.name, PVFS2_NAME_LEN);
+		dentry-&gt;d_name.name, ORANGEFS_NAME_LEN);
 
 	ret = service_operation(new_op, __func__, get_interruptible_flag(dir));
 
 	gossip_debug(GOSSIP_NAME_DEBUG,
-		     "Mkdir Got PVFS2 handle %pU on fsid %d\n",
+		     "Mkdir Got ORANGEFS handle %pU on fsid %d\n",
 		     &amp;new_op-&gt;downcall.resp.mkdir.refn.khandle,
 		     new_op-&gt;downcall.resp.mkdir.refn.fs_id);
 
@@ -349,10 +349,10 @@ static int pvfs2_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 		goto out;
 	}
 
-	inode = pvfs2_new_inode(dir-&gt;i_sb, dir, S_IFDIR | mode, 0,
+	inode = orangefs_new_inode(dir-&gt;i_sb, dir, S_IFDIR | mode, 0,
 				&amp;new_op-&gt;downcall.resp.mkdir.refn);
 	if (IS_ERR(inode)) {
-		gossip_err("*** Failed to allocate pvfs2 dir inode\n");
+		gossip_err("*** Failed to allocate orangefs dir inode\n");
 		ret = PTR_ERR(inode);
 		goto out;
 	}
@@ -381,42 +381,42 @@ static int pvfs2_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 	return ret;
 }
 
-static int pvfs2_rename(struct inode *old_dir,
+static int orangefs_rename(struct inode *old_dir,
 			struct dentry *old_dentry,
 			struct inode *new_dir,
 			struct dentry *new_dentry)
 {
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_kernel_op_s *new_op;
 	int ret;
 
 	gossip_debug(GOSSIP_NAME_DEBUG,
-		     "pvfs2_rename: called (%s/%s =&gt; %s/%s) ct=%d\n",
+		     "orangefs_rename: called (%s/%s =&gt; %s/%s) ct=%d\n",
 		     old_dentry-&gt;d_parent-&gt;d_name.name,
 		     old_dentry-&gt;d_name.name,
 		     new_dentry-&gt;d_parent-&gt;d_name.name,
 		     new_dentry-&gt;d_name.name,
 		     d_count(new_dentry));
 
-	new_op = op_alloc(PVFS2_VFS_OP_RENAME);
+	new_op = op_alloc(ORANGEFS_VFS_OP_RENAME);
 	if (!new_op)
 		return -EINVAL;
 
-	new_op-&gt;upcall.req.rename.old_parent_refn = PVFS2_I(old_dir)-&gt;refn;
-	new_op-&gt;upcall.req.rename.new_parent_refn = PVFS2_I(new_dir)-&gt;refn;
+	new_op-&gt;upcall.req.rename.old_parent_refn = ORANGEFS_I(old_dir)-&gt;refn;
+	new_op-&gt;upcall.req.rename.new_parent_refn = ORANGEFS_I(new_dir)-&gt;refn;
 
 	strncpy(new_op-&gt;upcall.req.rename.d_old_name,
 		old_dentry-&gt;d_name.name,
-		PVFS2_NAME_LEN);
+		ORANGEFS_NAME_LEN);
 	strncpy(new_op-&gt;upcall.req.rename.d_new_name,
 		new_dentry-&gt;d_name.name,
-		PVFS2_NAME_LEN);
+		ORANGEFS_NAME_LEN);
 
 	ret = service_operation(new_op,
-				"pvfs2_rename",
+				"orangefs_rename",
 				get_interruptible_flag(old_dentry-&gt;d_inode));
 
 	gossip_debug(GOSSIP_NAME_DEBUG,
-		     "pvfs2_rename: got downcall status %d\n",
+		     "orangefs_rename: got downcall status %d\n",
 		     ret);
 
 	if (new_dentry-&gt;d_inode)
@@ -426,21 +426,21 @@ static int pvfs2_rename(struct inode *old_dir,
 	return ret;
 }
 
-/* PVFS2 implementation of VFS inode operations for directories */
-struct inode_operations pvfs2_dir_inode_operations = {
-	.lookup = pvfs2_lookup,
-	.get_acl = pvfs2_get_acl,
-	.set_acl = pvfs2_set_acl,
-	.create = pvfs2_create,
-	.unlink = pvfs2_unlink,
-	.symlink = pvfs2_symlink,
-	.mkdir = pvfs2_mkdir,
-	.rmdir = pvfs2_unlink,
-	.rename = pvfs2_rename,
-	.setattr = pvfs2_setattr,
-	.getattr = pvfs2_getattr,
+/* ORANGEFS implementation of VFS inode operations for directories */
+struct inode_operations orangefs_dir_inode_operations = {
+	.lookup = orangefs_lookup,
+	.get_acl = orangefs_get_acl,
+	.set_acl = orangefs_set_acl,
+	.create = orangefs_create,
+	.unlink = orangefs_unlink,
+	.symlink = orangefs_symlink,
+	.mkdir = orangefs_mkdir,
+	.rmdir = orangefs_unlink,
+	.rename = orangefs_rename,
+	.setattr = orangefs_setattr,
+	.getattr = orangefs_getattr,
 	.setxattr = generic_setxattr,
 	.getxattr = generic_getxattr,
 	.removexattr = generic_removexattr,
-	.listxattr = pvfs2_listxattr,
+	.listxattr = orangefs_listxattr,
 };
diff --git a/fs/orangefs/protocol.h b/fs/orangefs/protocol.h
index 85f611fe0536..5f10ebc83e76 100644
--- a/fs/orangefs/protocol.h
+++ b/fs/orangefs/protocol.h
@@ -20,13 +20,13 @@ extern int cdm_element_count;
 #define ORANGEFS_KMOD_DEBUG_HELP_FILE "debug-help"
 #define ORANGEFS_KMOD_DEBUG_FILE "kernel-debug"
 #define ORANGEFS_CLIENT_DEBUG_FILE "client-debug"
-#define PVFS2_VERBOSE "verbose"
-#define PVFS2_ALL "all"
+#define ORANGEFS_VERBOSE "verbose"
+#define ORANGEFS_ALL "all"
 
 /* pvfs2-config.h ***********************************************************/
-#define PVFS2_VERSION_MAJOR 2
-#define PVFS2_VERSION_MINOR 9
-#define PVFS2_VERSION_SUB 0
+#define ORANGEFS_VERSION_MAJOR 2
+#define ORANGEFS_VERSION_MINOR 9
+#define ORANGEFS_VERSION_SUB 0
 
 /* khandle stuff  ***********************************************************/
 
@@ -38,15 +38,15 @@ extern int cdm_element_count;
  * The kernel module will always use the first four bytes and
  * the last four bytes as an inum.
  */
-struct pvfs2_khandle {
+struct orangefs_khandle {
 	unsigned char u[16];
 }  __aligned(8);
 
 /*
  * kernel version of an object ref.
  */
-struct pvfs2_object_kref {
-	struct pvfs2_khandle khandle;
+struct orangefs_object_kref {
+	struct orangefs_khandle khandle;
 	__s32 fs_id;
 	__s32 __pad1;
 };
@@ -55,8 +55,8 @@ struct pvfs2_object_kref {
  * compare 2 khandles assumes little endian thus from large address to
  * small address
  */
-static inline int PVFS_khandle_cmp(const struct pvfs2_khandle *kh1,
-				   const struct pvfs2_khandle *kh2)
+static inline int ORANGEFS_khandle_cmp(const struct orangefs_khandle *kh1,
+				   const struct orangefs_khandle *kh2)
 {
 	int i;
 
@@ -70,7 +70,7 @@ static inline int PVFS_khandle_cmp(const struct pvfs2_khandle *kh1,
 	return 0;
 }
 
-static inline void PVFS_khandle_to(const struct pvfs2_khandle *kh,
+static inline void ORANGEFS_khandle_to(const struct orangefs_khandle *kh,
 				   void *p, int size)
 {
 
@@ -79,7 +79,7 @@ static inline void PVFS_khandle_to(const struct pvfs2_khandle *kh,
 
 }
 
-static inline void PVFS_khandle_from(struct pvfs2_khandle *kh,
+static inline void ORANGEFS_khandle_from(struct orangefs_khandle *kh,
 				     void *p, int size)
 {
 	memset(kh, 0, 16);
@@ -88,152 +88,152 @@ static inline void PVFS_khandle_from(struct pvfs2_khandle *kh,
 }
 
 /* pvfs2-types.h ************************************************************/
-typedef __u32 PVFS_uid;
-typedef __u32 PVFS_gid;
-typedef __s32 PVFS_fs_id;
-typedef __u32 PVFS_permissions;
-typedef __u64 PVFS_time;
-typedef __s64 PVFS_size;
-typedef __u64 PVFS_flags;
-typedef __u64 PVFS_ds_position;
-typedef __s32 PVFS_error;
-typedef __s64 PVFS_offset;
-
-#define PVFS2_SUPER_MAGIC 0x20030528
+typedef __u32 ORANGEFS_uid;
+typedef __u32 ORANGEFS_gid;
+typedef __s32 ORANGEFS_fs_id;
+typedef __u32 ORANGEFS_permissions;
+typedef __u64 ORANGEFS_time;
+typedef __s64 ORANGEFS_size;
+typedef __u64 ORANGEFS_flags;
+typedef __u64 ORANGEFS_ds_position;
+typedef __s32 ORANGEFS_error;
+typedef __s64 ORANGEFS_offset;
+
+#define ORANGEFS_SUPER_MAGIC 0x20030528
 
 /*
- * PVFS2 error codes are a signed 32-bit integer. Error codes are negative, but
+ * ORANGEFS error codes are a signed 32-bit integer. Error codes are negative, but
  * the sign is stripped before decoding.
  */
 
 /* Bit 31 is not used since it is the sign. */
 
 /*
- * Bit 30 specifies that this is a PVFS2 error. A PVFS2 error is either an
- * encoded errno value or a PVFS2 protocol error.
+ * Bit 30 specifies that this is a ORANGEFS error. A ORANGEFS error is either an
+ * encoded errno value or a ORANGEFS protocol error.
  */
-#define PVFS_ERROR_BIT (1 &lt;&lt; 30)
+#define ORANGEFS_ERROR_BIT (1 &lt;&lt; 30)
 
 /*
- * Bit 29 specifies that this is a PVFS2 protocol error and not an encoded
+ * Bit 29 specifies that this is a ORANGEFS protocol error and not an encoded
  * errno value.
  */
-#define PVFS_NON_ERRNO_ERROR_BIT (1 &lt;&lt; 29)
+#define ORANGEFS_NON_ERRNO_ERROR_BIT (1 &lt;&lt; 29)
 
 /*
  * Bits 9, 8, and 7 specify the error class, which encodes the section of
  * server code the error originated in for logging purposes. It is not used
  * in the kernel except to be masked out.
  */
-#define PVFS_ERROR_CLASS_BITS 0x380
+#define ORANGEFS_ERROR_CLASS_BITS 0x380
 
 /* Bits 6 - 0 are reserved for the actual error code. */
-#define PVFS_ERROR_NUMBER_BITS 0x7f
+#define ORANGEFS_ERROR_NUMBER_BITS 0x7f
 
 /* Encoded errno values are decoded by PINT_errno_mapping in pvfs2-utils.c. */
 
-/* Our own PVFS2 protocol error codes. */
-#define PVFS_ECANCEL    (1|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EDEVINIT   (2|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EDETAIL    (3|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EHOSTNTFD  (4|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_EADDRNTFD  (5|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ENORECVR   (6|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ETRYAGAIN  (7|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ENOTPVFS   (8|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
-#define PVFS_ESECURITY  (9|PVFS_NON_ERRNO_ERROR_BIT|PVFS_ERROR_BIT)
+/* Our own ORANGEFS protocol error codes. */
+#define ORANGEFS_ECANCEL    (1|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EDEVINIT   (2|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EDETAIL    (3|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EHOSTNTFD  (4|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_EADDRNTFD  (5|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ENORECVR   (6|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ETRYAGAIN  (7|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ENOTPVFS   (8|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
+#define ORANGEFS_ESECURITY  (9|ORANGEFS_NON_ERRNO_ERROR_BIT|ORANGEFS_ERROR_BIT)
 
 /* permission bits */
-#define PVFS_O_EXECUTE (1 &lt;&lt; 0)
-#define PVFS_O_WRITE   (1 &lt;&lt; 1)
-#define PVFS_O_READ    (1 &lt;&lt; 2)
-#define PVFS_G_EXECUTE (1 &lt;&lt; 3)
-#define PVFS_G_WRITE   (1 &lt;&lt; 4)
-#define PVFS_G_READ    (1 &lt;&lt; 5)
-#define PVFS_U_EXECUTE (1 &lt;&lt; 6)
-#define PVFS_U_WRITE   (1 &lt;&lt; 7)
-#define PVFS_U_READ    (1 &lt;&lt; 8)
-/* no PVFS_U_VTX (sticky bit) */
-#define PVFS_G_SGID    (1 &lt;&lt; 10)
-#define PVFS_U_SUID    (1 &lt;&lt; 11)
+#define ORANGEFS_O_EXECUTE (1 &lt;&lt; 0)
+#define ORANGEFS_O_WRITE   (1 &lt;&lt; 1)
+#define ORANGEFS_O_READ    (1 &lt;&lt; 2)
+#define ORANGEFS_G_EXECUTE (1 &lt;&lt; 3)
+#define ORANGEFS_G_WRITE   (1 &lt;&lt; 4)
+#define ORANGEFS_G_READ    (1 &lt;&lt; 5)
+#define ORANGEFS_U_EXECUTE (1 &lt;&lt; 6)
+#define ORANGEFS_U_WRITE   (1 &lt;&lt; 7)
+#define ORANGEFS_U_READ    (1 &lt;&lt; 8)
+/* no ORANGEFS_U_VTX (sticky bit) */
+#define ORANGEFS_G_SGID    (1 &lt;&lt; 10)
+#define ORANGEFS_U_SUID    (1 &lt;&lt; 11)
 
 /* definition taken from stdint.h */
 #define INT32_MAX (2147483647)
-#define PVFS_ITERATE_START    (INT32_MAX - 1)
-#define PVFS_ITERATE_END      (INT32_MAX - 2)
-#define PVFS_ITERATE_NEXT     (INT32_MAX - 3)
-#define PVFS_READDIR_START PVFS_ITERATE_START
-#define PVFS_READDIR_END   PVFS_ITERATE_END
-#define PVFS_IMMUTABLE_FL FS_IMMUTABLE_FL
-#define PVFS_APPEND_FL    FS_APPEND_FL
-#define PVFS_NOATIME_FL   FS_NOATIME_FL
-#define PVFS_MIRROR_FL    0x01000000ULL
-#define PVFS_O_EXECUTE (1 &lt;&lt; 0)
-#define PVFS_FS_ID_NULL       ((__s32)0)
-#define PVFS_ATTR_SYS_UID                   (1 &lt;&lt; 0)
-#define PVFS_ATTR_SYS_GID                   (1 &lt;&lt; 1)
-#define PVFS_ATTR_SYS_PERM                  (1 &lt;&lt; 2)
-#define PVFS_ATTR_SYS_ATIME                 (1 &lt;&lt; 3)
-#define PVFS_ATTR_SYS_CTIME                 (1 &lt;&lt; 4)
-#define PVFS_ATTR_SYS_MTIME                 (1 &lt;&lt; 5)
-#define PVFS_ATTR_SYS_TYPE                  (1 &lt;&lt; 6)
-#define PVFS_ATTR_SYS_ATIME_SET             (1 &lt;&lt; 7)
-#define PVFS_ATTR_SYS_MTIME_SET             (1 &lt;&lt; 8)
-#define PVFS_ATTR_SYS_SIZE                  (1 &lt;&lt; 20)
-#define PVFS_ATTR_SYS_LNK_TARGET            (1 &lt;&lt; 24)
-#define PVFS_ATTR_SYS_DFILE_COUNT           (1 &lt;&lt; 25)
-#define PVFS_ATTR_SYS_DIRENT_COUNT          (1 &lt;&lt; 26)
-#define PVFS_ATTR_SYS_BLKSIZE               (1 &lt;&lt; 28)
-#define PVFS_ATTR_SYS_MIRROR_COPIES_COUNT   (1 &lt;&lt; 29)
-#define PVFS_ATTR_SYS_COMMON_ALL	\
-	(PVFS_ATTR_SYS_UID	|	\
-	 PVFS_ATTR_SYS_GID	|	\
-	 PVFS_ATTR_SYS_PERM	|	\
-	 PVFS_ATTR_SYS_ATIME	|	\
-	 PVFS_ATTR_SYS_CTIME	|	\
-	 PVFS_ATTR_SYS_MTIME	|	\
-	 PVFS_ATTR_SYS_TYPE)
-
-#define PVFS_ATTR_SYS_ALL_SETABLE		\
-(PVFS_ATTR_SYS_COMMON_ALL-PVFS_ATTR_SYS_TYPE)
-
-#define PVFS_ATTR_SYS_ALL_NOHINT			\
-	(PVFS_ATTR_SYS_COMMON_ALL		|	\
-	 PVFS_ATTR_SYS_SIZE			|	\
-	 PVFS_ATTR_SYS_LNK_TARGET		|	\
-	 PVFS_ATTR_SYS_DFILE_COUNT		|	\
-	 PVFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
-	 PVFS_ATTR_SYS_DIRENT_COUNT		|	\
-	 PVFS_ATTR_SYS_BLKSIZE)
-#define PVFS_XATTR_REPLACE 0x2
-#define PVFS_XATTR_CREATE  0x1
-#define PVFS_MAX_SERVER_ADDR_LEN 256
-#define PVFS_NAME_MAX            256
+#define ORANGEFS_ITERATE_START    (INT32_MAX - 1)
+#define ORANGEFS_ITERATE_END      (INT32_MAX - 2)
+#define ORANGEFS_ITERATE_NEXT     (INT32_MAX - 3)
+#define ORANGEFS_READDIR_START ORANGEFS_ITERATE_START
+#define ORANGEFS_READDIR_END   ORANGEFS_ITERATE_END
+#define ORANGEFS_IMMUTABLE_FL FS_IMMUTABLE_FL
+#define ORANGEFS_APPEND_FL    FS_APPEND_FL
+#define ORANGEFS_NOATIME_FL   FS_NOATIME_FL
+#define ORANGEFS_MIRROR_FL    0x01000000ULL
+#define ORANGEFS_O_EXECUTE (1 &lt;&lt; 0)
+#define ORANGEFS_FS_ID_NULL       ((__s32)0)
+#define ORANGEFS_ATTR_SYS_UID                   (1 &lt;&lt; 0)
+#define ORANGEFS_ATTR_SYS_GID                   (1 &lt;&lt; 1)
+#define ORANGEFS_ATTR_SYS_PERM                  (1 &lt;&lt; 2)
+#define ORANGEFS_ATTR_SYS_ATIME                 (1 &lt;&lt; 3)
+#define ORANGEFS_ATTR_SYS_CTIME                 (1 &lt;&lt; 4)
+#define ORANGEFS_ATTR_SYS_MTIME                 (1 &lt;&lt; 5)
+#define ORANGEFS_ATTR_SYS_TYPE                  (1 &lt;&lt; 6)
+#define ORANGEFS_ATTR_SYS_ATIME_SET             (1 &lt;&lt; 7)
+#define ORANGEFS_ATTR_SYS_MTIME_SET             (1 &lt;&lt; 8)
+#define ORANGEFS_ATTR_SYS_SIZE                  (1 &lt;&lt; 20)
+#define ORANGEFS_ATTR_SYS_LNK_TARGET            (1 &lt;&lt; 24)
+#define ORANGEFS_ATTR_SYS_DFILE_COUNT           (1 &lt;&lt; 25)
+#define ORANGEFS_ATTR_SYS_DIRENT_COUNT          (1 &lt;&lt; 26)
+#define ORANGEFS_ATTR_SYS_BLKSIZE               (1 &lt;&lt; 28)
+#define ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT   (1 &lt;&lt; 29)
+#define ORANGEFS_ATTR_SYS_COMMON_ALL	\
+	(ORANGEFS_ATTR_SYS_UID	|	\
+	 ORANGEFS_ATTR_SYS_GID	|	\
+	 ORANGEFS_ATTR_SYS_PERM	|	\
+	 ORANGEFS_ATTR_SYS_ATIME	|	\
+	 ORANGEFS_ATTR_SYS_CTIME	|	\
+	 ORANGEFS_ATTR_SYS_MTIME	|	\
+	 ORANGEFS_ATTR_SYS_TYPE)
+
+#define ORANGEFS_ATTR_SYS_ALL_SETABLE		\
+(ORANGEFS_ATTR_SYS_COMMON_ALL-ORANGEFS_ATTR_SYS_TYPE)
+
+#define ORANGEFS_ATTR_SYS_ALL_NOHINT			\
+	(ORANGEFS_ATTR_SYS_COMMON_ALL		|	\
+	 ORANGEFS_ATTR_SYS_SIZE			|	\
+	 ORANGEFS_ATTR_SYS_LNK_TARGET		|	\
+	 ORANGEFS_ATTR_SYS_DFILE_COUNT		|	\
+	 ORANGEFS_ATTR_SYS_MIRROR_COPIES_COUNT	|	\
+	 ORANGEFS_ATTR_SYS_DIRENT_COUNT		|	\
+	 ORANGEFS_ATTR_SYS_BLKSIZE)
+#define ORANGEFS_XATTR_REPLACE 0x2
+#define ORANGEFS_XATTR_CREATE  0x1
+#define ORANGEFS_MAX_SERVER_ADDR_LEN 256
+#define ORANGEFS_NAME_MAX                256
 /*
  * max extended attribute name len as imposed by the VFS and exploited for the
  * upcall request types.
  * NOTE: Please retain them as multiples of 8 even if you wish to change them
  * This is *NECESSARY* for supporting 32 bit user-space binaries on a 64-bit
  * kernel. Due to implementation within DBPF, this really needs to be
- * PVFS_NAME_MAX, which it was the same value as, but no reason to let it
+ * ORANGEFS_NAME_MAX, which it was the same value as, but no reason to let it
  * break if that changes in the future.
  */
-#define PVFS_MAX_XATTR_NAMELEN   PVFS_NAME_MAX	/* Not the same as
+#define ORANGEFS_MAX_XATTR_NAMELEN   ORANGEFS_NAME_MAX	/* Not the same as
 						 * XATTR_NAME_MAX defined
 						 * by &lt;linux/xattr.h&gt;
 						 */
-#define PVFS_MAX_XATTR_VALUELEN  8192	/* Not the same as XATTR_SIZE_MAX
+#define ORANGEFS_MAX_XATTR_VALUELEN  8192	/* Not the same as XATTR_SIZE_MAX
 					 * defined by &lt;linux/xattr.h&gt;
 					 */
-#define PVFS_MAX_XATTR_LISTLEN   16	/* Not the same as XATTR_LIST_MAX
+#define ORANGEFS_MAX_XATTR_LISTLEN   16	/* Not the same as XATTR_LIST_MAX
 					 * defined by &lt;linux/xattr.h&gt;
 					 */
 /*
- * PVFS I/O operation types, used in both system and server interfaces.
+ * ORANGEFS I/O operation types, used in both system and server interfaces.
  */
-enum PVFS_io_type {
-	PVFS_IO_READ = 1,
-	PVFS_IO_WRITE = 2
+enum ORANGEFS_io_type {
+	ORANGEFS_IO_READ = 1,
+	ORANGEFS_IO_WRITE = 2
 };
 
 /*
@@ -241,21 +241,21 @@ enum PVFS_io_type {
  * batch and low threshold sizes may need to be modified  to reflect this
  * change.
  */
-enum pvfs2_ds_type {
-	PVFS_TYPE_NONE = 0,
-	PVFS_TYPE_METAFILE = (1 &lt;&lt; 0),
-	PVFS_TYPE_DATAFILE = (1 &lt;&lt; 1),
-	PVFS_TYPE_DIRECTORY = (1 &lt;&lt; 2),
-	PVFS_TYPE_SYMLINK = (1 &lt;&lt; 3),
-	PVFS_TYPE_DIRDATA = (1 &lt;&lt; 4),
-	PVFS_TYPE_INTERNAL = (1 &lt;&lt; 5)	/* for the server's private use */
+enum orangefs_ds_type {
+	ORANGEFS_TYPE_NONE = 0,
+	ORANGEFS_TYPE_METAFILE = (1 &lt;&lt; 0),
+	ORANGEFS_TYPE_DATAFILE = (1 &lt;&lt; 1),
+	ORANGEFS_TYPE_DIRECTORY = (1 &lt;&lt; 2),
+	ORANGEFS_TYPE_SYMLINK = (1 &lt;&lt; 3),
+	ORANGEFS_TYPE_DIRDATA = (1 &lt;&lt; 4),
+	ORANGEFS_TYPE_INTERNAL = (1 &lt;&lt; 5)	/* for the server's private use */
 };
 
 /*
- * PVFS_certificate simply stores a buffer with the buffer size.
+ * ORANGEFS_certificate simply stores a buffer with the buffer size.
  * The buffer can be converted to an OpenSSL X509 struct for use.
  */
-struct PVFS_certificate {
+struct ORANGEFS_certificate {
 	__u32 buf_size;
 	unsigned char *buf;
 };
@@ -264,7 +264,7 @@ struct PVFS_certificate {
  * A credential identifies a user and is signed by the client/user
  * private key.
  */
-struct PVFS_credential {
+struct ORANGEFS_credential {
 	__u32 userid;	/* user id */
 	__u32 num_groups;	/* length of group_array */
 	__u32 *group_array;	/* groups for which the user is a member */
@@ -272,25 +272,25 @@ struct PVFS_credential {
 	__u64 timeout;	/* seconds after epoch to time out */
 	__u32 sig_size;	/* length of the signature in bytes */
 	unsigned char *signature;	/* digital signature */
-	struct PVFS_certificate certificate;	/* user certificate buffer */
+	struct ORANGEFS_certificate certificate;	/* user certificate buffer */
 };
-#define extra_size_PVFS_credential (PVFS_REQ_LIMIT_GROUPS	*	\
+#define extra_size_ORANGEFS_credential (ORANGEFS_REQ_LIMIT_GROUPS	*	\
 				    sizeof(__u32)		+	\
-				    PVFS_REQ_LIMIT_ISSUER	+	\
-				    PVFS_REQ_LIMIT_SIGNATURE	+	\
-				    extra_size_PVFS_certificate)
+				    ORANGEFS_REQ_LIMIT_ISSUER	+	\
+				    ORANGEFS_REQ_LIMIT_SIGNATURE	+	\
+				    extra_size_ORANGEFS_certificate)
 
 /* This structure is used by the VFS-client interaction alone */
-struct PVFS_keyval_pair {
-	char key[PVFS_MAX_XATTR_NAMELEN];
+struct ORANGEFS_keyval_pair {
+	char key[ORANGEFS_MAX_XATTR_NAMELEN];
 	__s32 key_sz;	/* __s32 for portable, fixed-size structures */
 	__s32 val_sz;
-	char val[PVFS_MAX_XATTR_VALUELEN];
+	char val[ORANGEFS_MAX_XATTR_VALUELEN];
 };
 
 /* pvfs2-sysint.h ***********************************************************/
 /* Describes attributes for a file, directory, or symlink. */
-struct PVFS_sys_attr_s {
+struct ORANGEFS_sys_attr_s {
 	__u32 owner;
 	__u32 group;
 	__u32 perms;
@@ -323,18 +323,18 @@ struct PVFS_sys_attr_s {
 	char *dist_params;
 
 	__s64 dirent_count;
-	enum pvfs2_ds_type objtype;
+	enum orangefs_ds_type objtype;
 	__u64 flags;
 	__u32 mask;
 	__s64 blksize;
 };
 
-#define PVFS2_LOOKUP_LINK_NO_FOLLOW 0
-#define PVFS2_LOOKUP_LINK_FOLLOW    1
+#define ORANGEFS_LOOKUP_LINK_NO_FOLLOW 0
+#define ORANGEFS_LOOKUP_LINK_FOLLOW    1
 
 /* pint-dev.h ***************************************************************/
 
-/* parameter structure used in PVFS_DEV_DEBUG ioctl command */
+/* parameter structure used in ORANGEFS_DEV_DEBUG ioctl command */
 struct dev_mask_info_s {
 	enum {
 		KERNEL_MASK,
@@ -349,7 +349,7 @@ struct dev_mask2_info_s {
 };
 
 /* pvfs2-util.h *************************************************************/
-__s32 PVFS_util_translate_mode(int mode);
+__s32 ORANGEFS_util_translate_mode(int mode);
 
 /* pvfs2-debug.h ************************************************************/
 #include "pvfs2-debug.h"
@@ -359,9 +359,9 @@ __s32 PVFS_util_translate_mode(int mode);
 #define lld(x) (long long)(x)
 
 /* pint-dev-shared.h ********************************************************/
-#define PVFS_DEV_MAGIC 'k'
+#define ORANGEFS_DEV_MAGIC 'k'
 
-#define PVFS2_READDIR_DEFAULT_DESC_COUNT  5
+#define ORANGEFS_READDIR_DEFAULT_DESC_COUNT  5
 
 #define DEV_GET_MAGIC           0x1
 #define DEV_GET_MAX_UPSIZE      0x2
@@ -376,39 +376,39 @@ __s32 PVFS_util_translate_mode(int mode);
 
 /* supported ioctls, codes are with respect to user-space */
 enum {
-	PVFS_DEV_GET_MAGIC = _IOW(PVFS_DEV_MAGIC, DEV_GET_MAGIC, __s32),
-	PVFS_DEV_GET_MAX_UPSIZE =
-	    _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_UPSIZE, __s32),
-	PVFS_DEV_GET_MAX_DOWNSIZE =
-	    _IOW(PVFS_DEV_MAGIC, DEV_GET_MAX_DOWNSIZE, __s32),
-	PVFS_DEV_MAP = _IO(PVFS_DEV_MAGIC, DEV_MAP),
-	PVFS_DEV_REMOUNT_ALL = _IO(PVFS_DEV_MAGIC, DEV_REMOUNT_ALL),
-	PVFS_DEV_DEBUG = _IOR(PVFS_DEV_MAGIC, DEV_DEBUG, __s32),
-	PVFS_DEV_UPSTREAM = _IOW(PVFS_DEV_MAGIC, DEV_UPSTREAM, int),
-	PVFS_DEV_CLIENT_MASK = _IOW(PVFS_DEV_MAGIC,
+	ORANGEFS_DEV_GET_MAGIC = _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAGIC, __s32),
+	ORANGEFS_DEV_GET_MAX_UPSIZE =
+	    _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAX_UPSIZE, __s32),
+	ORANGEFS_DEV_GET_MAX_DOWNSIZE =
+	    _IOW(ORANGEFS_DEV_MAGIC, DEV_GET_MAX_DOWNSIZE, __s32),
+	ORANGEFS_DEV_MAP = _IO(ORANGEFS_DEV_MAGIC, DEV_MAP),
+	ORANGEFS_DEV_REMOUNT_ALL = _IO(ORANGEFS_DEV_MAGIC, DEV_REMOUNT_ALL),
+	ORANGEFS_DEV_DEBUG = _IOR(ORANGEFS_DEV_MAGIC, DEV_DEBUG, __s32),
+	ORANGEFS_DEV_UPSTREAM = _IOW(ORANGEFS_DEV_MAGIC, DEV_UPSTREAM, int),
+	ORANGEFS_DEV_CLIENT_MASK = _IOW(ORANGEFS_DEV_MAGIC,
 				    DEV_CLIENT_MASK,
 				    struct dev_mask2_info_s),
-	PVFS_DEV_CLIENT_STRING = _IOW(PVFS_DEV_MAGIC,
+	ORANGEFS_DEV_CLIENT_STRING = _IOW(ORANGEFS_DEV_MAGIC,
 				      DEV_CLIENT_STRING,
 				      char *),
-	PVFS_DEV_MAXNR = DEV_MAX_NR,
+	ORANGEFS_DEV_MAXNR = DEV_MAX_NR,
 };
 
 /*
  * version number for use in communicating between kernel space and user
  * space. Zero signifies the upstream version of the kernel module.
  */
-#define PVFS_KERNEL_PROTO_VERSION 0
+#define ORANGEFS_KERNEL_PROTO_VERSION 0
 
 /*
- * describes memory regions to map in the PVFS_DEV_MAP ioctl.
+ * describes memory regions to map in the ORANGEFS_DEV_MAP ioctl.
  * NOTE: See devpvfs2-req.c for 32 bit compat structure.
  * Since this structure has a variable-sized layout that is different
  * on 32 and 64 bit platforms, we need to normalize to a 64 bit layout
  * on such systems before servicing ioctl calls from user-space binaries
  * that may be 32 bit!
  */
-struct PVFS_dev_map_desc {
+struct ORANGEFS_dev_map_desc {
 	void *ptr;
 	__s32 total_size;
 	__s32 size;
diff --git a/fs/orangefs/pvfs2-bufmap.c b/fs/orangefs/pvfs2-bufmap.c
index c7b0f3560734..345287e871b1 100644
--- a/fs/orangefs/pvfs2-bufmap.c
+++ b/fs/orangefs/pvfs2-bufmap.c
@@ -7,9 +7,9 @@
 #include "pvfs2-kernel.h"
 #include "pvfs2-bufmap.h"
 
-DECLARE_WAIT_QUEUE_HEAD(pvfs2_bufmap_init_waitq);
+DECLARE_WAIT_QUEUE_HEAD(orangefs_bufmap_init_waitq);
 
-static struct pvfs2_bufmap {
+static struct orangefs_bufmap {
 	atomic_t refcnt;
 
 	int desc_size;
@@ -19,21 +19,21 @@ static struct pvfs2_bufmap {
 	int page_count;
 
 	struct page **page_array;
-	struct pvfs_bufmap_desc *desc_array;
+	struct orangefs_bufmap_desc *desc_array;
 
 	/* array to track usage of buffer descriptors */
 	int *buffer_index_array;
 	spinlock_t buffer_index_lock;
 
 	/* array to track usage of buffer descriptors for readdir */
-	int readdir_index_array[PVFS2_READDIR_DEFAULT_DESC_COUNT];
+	int readdir_index_array[ORANGEFS_READDIR_DEFAULT_DESC_COUNT];
 	spinlock_t readdir_index_lock;
-} *__pvfs2_bufmap;
+} *__orangefs_bufmap;
 
-static DEFINE_SPINLOCK(pvfs2_bufmap_lock);
+static DEFINE_SPINLOCK(orangefs_bufmap_lock);
 
 static void
-pvfs2_bufmap_unmap(struct pvfs2_bufmap *bufmap)
+orangefs_bufmap_unmap(struct orangefs_bufmap *bufmap)
 {
 	int i;
 
@@ -42,7 +42,7 @@ pvfs2_bufmap_unmap(struct pvfs2_bufmap *bufmap)
 }
 
 static void
-pvfs2_bufmap_free(struct pvfs2_bufmap *bufmap)
+orangefs_bufmap_free(struct orangefs_bufmap *bufmap)
 {
 	kfree(bufmap-&gt;page_array);
 	kfree(bufmap-&gt;desc_array);
@@ -50,45 +50,45 @@ pvfs2_bufmap_free(struct pvfs2_bufmap *bufmap)
 	kfree(bufmap);
 }
 
-struct pvfs2_bufmap *pvfs2_bufmap_ref(void)
+struct orangefs_bufmap *orangefs_bufmap_ref(void)
 {
-	struct pvfs2_bufmap *bufmap = NULL;
+	struct orangefs_bufmap *bufmap = NULL;
 
-	spin_lock(&amp;pvfs2_bufmap_lock);
-	if (__pvfs2_bufmap) {
-		bufmap = __pvfs2_bufmap;
+	spin_lock(&amp;orangefs_bufmap_lock);
+	if (__orangefs_bufmap) {
+		bufmap = __orangefs_bufmap;
 		atomic_inc(&amp;bufmap-&gt;refcnt);
 	}
-	spin_unlock(&amp;pvfs2_bufmap_lock);
+	spin_unlock(&amp;orangefs_bufmap_lock);
 	return bufmap;
 }
 
-void pvfs2_bufmap_unref(struct pvfs2_bufmap *bufmap)
+void orangefs_bufmap_unref(struct orangefs_bufmap *bufmap)
 {
-	if (atomic_dec_and_lock(&amp;bufmap-&gt;refcnt, &amp;pvfs2_bufmap_lock)) {
-		__pvfs2_bufmap = NULL;
-		spin_unlock(&amp;pvfs2_bufmap_lock);
+	if (atomic_dec_and_lock(&amp;bufmap-&gt;refcnt, &amp;orangefs_bufmap_lock)) {
+		__orangefs_bufmap = NULL;
+		spin_unlock(&amp;orangefs_bufmap_lock);
 
-		pvfs2_bufmap_unmap(bufmap);
-		pvfs2_bufmap_free(bufmap);
+		orangefs_bufmap_unmap(bufmap);
+		orangefs_bufmap_free(bufmap);
 	}
 }
 
-inline int pvfs_bufmap_size_query(void)
+inline int orangefs_bufmap_size_query(void)
 {
-	struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();
+	struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();
 	int size = bufmap ? bufmap-&gt;desc_size : 0;
 
-	pvfs2_bufmap_unref(bufmap);
+	orangefs_bufmap_unref(bufmap);
 	return size;
 }
 
-inline int pvfs_bufmap_shift_query(void)
+inline int orangefs_bufmap_shift_query(void)
 {
-	struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();
+	struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();
 	int shift = bufmap ? bufmap-&gt;desc_shift : 0;
 
-	pvfs2_bufmap_unref(bufmap);
+	orangefs_bufmap_unref(bufmap);
 	return shift;
 }
 
@@ -105,14 +105,14 @@ static DECLARE_WAIT_QUEUE_HEAD(readdir_waitq);
  */
 int get_bufmap_init(void)
 {
-	return __pvfs2_bufmap ? 1 : 0;
+	return __orangefs_bufmap ? 1 : 0;
 }
 
 
-static struct pvfs2_bufmap *
-pvfs2_bufmap_alloc(struct PVFS_dev_map_desc *user_desc)
+static struct orangefs_bufmap *
+orangefs_bufmap_alloc(struct ORANGEFS_dev_map_desc *user_desc)
 {
-	struct pvfs2_bufmap *bufmap;
+	struct orangefs_bufmap *bufmap;
 
 	bufmap = kzalloc(sizeof(*bufmap), GFP_KERNEL);
 	if (!bufmap)
@@ -128,17 +128,17 @@ pvfs2_bufmap_alloc(struct PVFS_dev_map_desc *user_desc)
 	bufmap-&gt;buffer_index_array =
 		kcalloc(bufmap-&gt;desc_count, sizeof(int), GFP_KERNEL);
 	if (!bufmap-&gt;buffer_index_array) {
-		gossip_err("pvfs2: could not allocate %d buffer indices\n",
+		gossip_err("orangefs: could not allocate %d buffer indices\n",
 				bufmap-&gt;desc_count);
 		goto out_free_bufmap;
 	}
 	spin_lock_init(&amp;bufmap-&gt;readdir_index_lock);
 
 	bufmap-&gt;desc_array =
-		kcalloc(bufmap-&gt;desc_count, sizeof(struct pvfs_bufmap_desc),
+		kcalloc(bufmap-&gt;desc_count, sizeof(struct orangefs_bufmap_desc),
 			GFP_KERNEL);
 	if (!bufmap-&gt;desc_array) {
-		gossip_err("pvfs2: could not allocate %d descriptors\n",
+		gossip_err("orangefs: could not allocate %d descriptors\n",
 				bufmap-&gt;desc_count);
 		goto out_free_index_array;
 	}
@@ -164,8 +164,8 @@ pvfs2_bufmap_alloc(struct PVFS_dev_map_desc *user_desc)
 }
 
 static int
-pvfs2_bufmap_map(struct pvfs2_bufmap *bufmap,
-		struct PVFS_dev_map_desc *user_desc)
+orangefs_bufmap_map(struct orangefs_bufmap *bufmap,
+		struct ORANGEFS_dev_map_desc *user_desc)
 {
 	int pages_per_desc = bufmap-&gt;desc_size / PAGE_SIZE;
 	int offset = 0, ret, i;
@@ -178,7 +178,7 @@ pvfs2_bufmap_map(struct pvfs2_bufmap *bufmap,
 		return ret;
 
 	if (ret != bufmap-&gt;page_count) {
-		gossip_err("pvfs2 error: asked for %d pages, only got %d.\n",
+		gossip_err("orangefs error: asked for %d pages, only got %d.\n",
 				bufmap-&gt;page_count, ret);
 
 		for (i = 0; i &lt; ret; i++) {
@@ -210,19 +210,19 @@ pvfs2_bufmap_map(struct pvfs2_bufmap *bufmap,
 }
 
 /*
- * pvfs_bufmap_initialize()
+ * orangefs_bufmap_initialize()
  *
  * initializes the mapped buffer interface
  *
  * returns 0 on success, -errno on failure
  */
-int pvfs_bufmap_initialize(struct PVFS_dev_map_desc *user_desc)
+int orangefs_bufmap_initialize(struct ORANGEFS_dev_map_desc *user_desc)
 {
-	struct pvfs2_bufmap *bufmap;
+	struct orangefs_bufmap *bufmap;
 	int ret = -EINVAL;
 
 	gossip_debug(GOSSIP_BUFMAP_DEBUG,
-		     "pvfs_bufmap_initialize: called (ptr ("
+		     "orangefs_bufmap_initialize: called (ptr ("
 		     "%p) sz (%d) cnt(%d).\n",
 		     user_desc-&gt;ptr,
 		     user_desc-&gt;size,
@@ -234,21 +234,21 @@ int pvfs_bufmap_initialize(struct PVFS_dev_map_desc *user_desc)
 	 */
 	if (PAGE_ALIGN((unsigned long)user_desc-&gt;ptr) !=
 	    (unsigned long)user_desc-&gt;ptr) {
-		gossip_err("pvfs2 error: memory alignment (front). %p\n",
+		gossip_err("orangefs error: memory alignment (front). %p\n",
 			   user_desc-&gt;ptr);
 		goto out;
 	}
 
 	if (PAGE_ALIGN(((unsigned long)user_desc-&gt;ptr + user_desc-&gt;total_size))
 	    != (unsigned long)(user_desc-&gt;ptr + user_desc-&gt;total_size)) {
-		gossip_err("pvfs2 error: memory alignment (back).(%p + %d)\n",
+		gossip_err("orangefs error: memory alignment (back).(%p + %d)\n",
 			   user_desc-&gt;ptr,
 			   user_desc-&gt;total_size);
 		goto out;
 	}
 
 	if (user_desc-&gt;total_size != (user_desc-&gt;size * user_desc-&gt;count)) {
-		gossip_err("pvfs2 error: user provided an oddly sized buffer: (%d, %d, %d)\n",
+		gossip_err("orangefs error: user provided an oddly sized buffer: (%d, %d, %d)\n",
 			   user_desc-&gt;total_size,
 			   user_desc-&gt;size,
 			   user_desc-&gt;count);
@@ -256,33 +256,33 @@ int pvfs_bufmap_initialize(struct PVFS_dev_map_desc *user_desc)
 	}
 
 	if ((user_desc-&gt;size % PAGE_SIZE) != 0) {
-		gossip_err("pvfs2 error: bufmap size not page size divisible (%d).\n",
+		gossip_err("orangefs error: bufmap size not page size divisible (%d).\n",
 			   user_desc-&gt;size);
 		goto out;
 	}
 
 	ret = -ENOMEM;
-	bufmap = pvfs2_bufmap_alloc(user_desc);
+	bufmap = orangefs_bufmap_alloc(user_desc);
 	if (!bufmap)
 		goto out;
 
-	ret = pvfs2_bufmap_map(bufmap, user_desc);
+	ret = orangefs_bufmap_map(bufmap, user_desc);
 	if (ret)
 		goto out_free_bufmap;
 
 
-	spin_lock(&amp;pvfs2_bufmap_lock);
-	if (__pvfs2_bufmap) {
-		spin_unlock(&amp;pvfs2_bufmap_lock);
-		gossip_err("pvfs2: error: bufmap already initialized.\n");
+	spin_lock(&amp;orangefs_bufmap_lock);
+	if (__orangefs_bufmap) {
+		spin_unlock(&amp;orangefs_bufmap_lock);
+		gossip_err("orangefs: error: bufmap already initialized.\n");
 		ret = -EALREADY;
 		goto out_unmap_bufmap;
 	}
-	__pvfs2_bufmap = bufmap;
-	spin_unlock(&amp;pvfs2_bufmap_lock);
+	__orangefs_bufmap = bufmap;
+	spin_unlock(&amp;orangefs_bufmap_lock);
 
 	/*
-	 * If there are operations in pvfs2_bufmap_init_waitq, wake them up.
+	 * If there are operations in orangefs_bufmap_init_waitq, wake them up.
 	 * This scenario occurs when the client-core is restarted and I/O
 	 * requests in the in-progress or waiting tables are restarted.  I/O
 	 * requests cannot be restarted until the shared memory system is
@@ -291,35 +291,35 @@ int pvfs_bufmap_initialize(struct PVFS_dev_map_desc *user_desc)
 	 * are also on a timer, so they don't wait forever just in case the
 	 * client-core doesn't come back up.
 	 */
-	wake_up_interruptible(&amp;pvfs2_bufmap_init_waitq);
+	wake_up_interruptible(&amp;orangefs_bufmap_init_waitq);
 
 	gossip_debug(GOSSIP_BUFMAP_DEBUG,
-		     "pvfs_bufmap_initialize: exiting normally\n");
+		     "orangefs_bufmap_initialize: exiting normally\n");
 	return 0;
 
 out_unmap_bufmap:
-	pvfs2_bufmap_unmap(bufmap);
+	orangefs_bufmap_unmap(bufmap);
 out_free_bufmap:
-	pvfs2_bufmap_free(bufmap);
+	orangefs_bufmap_free(bufmap);
 out:
 	return ret;
 }
 
 /*
- * pvfs_bufmap_finalize()
+ * orangefs_bufmap_finalize()
  *
  * shuts down the mapped buffer interface and releases any resources
  * associated with it
  *
  * no return value
  */
-void pvfs_bufmap_finalize(void)
+void orangefs_bufmap_finalize(void)
 {
-	gossip_debug(GOSSIP_BUFMAP_DEBUG, "pvfs2_bufmap_finalize: called\n");
-	BUG_ON(!__pvfs2_bufmap);
-	pvfs2_bufmap_unref(__pvfs2_bufmap);
+	gossip_debug(GOSSIP_BUFMAP_DEBUG, "orangefs_bufmap_finalize: called\n");
+	BUG_ON(!__orangefs_bufmap);
+	orangefs_bufmap_unref(__orangefs_bufmap);
 	gossip_debug(GOSSIP_BUFMAP_DEBUG,
-		     "pvfs2_bufmap_finalize: exiting normally\n");
+		     "orangefs_bufmap_finalize: exiting normally\n");
 }
 
 struct slot_args {
@@ -377,7 +377,7 @@ static int wait_for_a_slot(struct slot_args *slargs, int *buffer_index)
 			continue;
 		}
 
-		gossip_debug(GOSSIP_BUFMAP_DEBUG, "pvfs2: %s interrupted.\n",
+		gossip_debug(GOSSIP_BUFMAP_DEBUG, "orangefs: %s interrupted.\n",
 			     __func__);
 		ret = -EINTR;
 		break;
@@ -406,21 +406,21 @@ static void put_back_slot(struct slot_args *slargs, int buffer_index)
 }
 
 /*
- * pvfs_bufmap_get()
+ * orangefs_bufmap_get()
  *
  * gets a free mapped buffer descriptor, will sleep until one becomes
  * available if necessary
  *
  * returns 0 on success, -errno on failure
  */
-int pvfs_bufmap_get(struct pvfs2_bufmap **mapp, int *buffer_index)
+int orangefs_bufmap_get(struct orangefs_bufmap **mapp, int *buffer_index)
 {
-	struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();
+	struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();
 	struct slot_args slargs;
 	int ret;
 
 	if (!bufmap) {
-		gossip_err("pvfs2: please confirm that pvfs2-client daemon is running.\n");
+		gossip_err("orangefs: please confirm that pvfs2-client daemon is running.\n");
 		return -EIO;
 	}
 
@@ -430,19 +430,19 @@ int pvfs_bufmap_get(struct pvfs2_bufmap **mapp, int *buffer_index)
 	slargs.slot_wq = &amp;bufmap_waitq;
 	ret = wait_for_a_slot(&amp;slargs, buffer_index);
 	if (ret)
-		pvfs2_bufmap_unref(bufmap);
+		orangefs_bufmap_unref(bufmap);
 	*mapp = bufmap;
 	return ret;
 }
 
 /*
- * pvfs_bufmap_put()
+ * orangefs_bufmap_put()
  *
  * returns a mapped buffer descriptor to the collection
  *
  * no return value
  */
-void pvfs_bufmap_put(struct pvfs2_bufmap *bufmap, int buffer_index)
+void orangefs_bufmap_put(struct orangefs_bufmap *bufmap, int buffer_index)
 {
 	struct slot_args slargs;
 
@@ -451,7 +451,7 @@ void pvfs_bufmap_put(struct pvfs2_bufmap *bufmap, int buffer_index)
 	slargs.slot_lock = &amp;bufmap-&gt;buffer_index_lock;
 	slargs.slot_wq = &amp;bufmap_waitq;
 	put_back_slot(&amp;slargs, buffer_index);
-	pvfs2_bufmap_unref(bufmap);
+	orangefs_bufmap_unref(bufmap);
 }
 
 /*
@@ -465,46 +465,46 @@ void pvfs_bufmap_put(struct pvfs2_bufmap *bufmap, int buffer_index)
  *
  * returns 0 on success, -errno on failure
  */
-int readdir_index_get(struct pvfs2_bufmap **mapp, int *buffer_index)
+int readdir_index_get(struct orangefs_bufmap **mapp, int *buffer_index)
 {
-	struct pvfs2_bufmap *bufmap = pvfs2_bufmap_ref();
+	struct orangefs_bufmap *bufmap = orangefs_bufmap_ref();
 	struct slot_args slargs;
 	int ret;
 
 	if (!bufmap) {
-		gossip_err("pvfs2: please confirm that pvfs2-client daemon is running.\n");
+		gossip_err("orangefs: please confirm that pvfs2-client daemon is running.\n");
 		return -EIO;
 	}
 
-	slargs.slot_count = PVFS2_READDIR_DEFAULT_DESC_COUNT;
+	slargs.slot_count = ORANGEFS_READDIR_DEFAULT_DESC_COUNT;
 	slargs.slot_array = bufmap-&gt;readdir_index_array;
 	slargs.slot_lock = &amp;bufmap-&gt;readdir_index_lock;
 	slargs.slot_wq = &amp;readdir_waitq;
 	ret = wait_for_a_slot(&amp;slargs, buffer_index);
 	if (ret)
-		pvfs2_bufmap_unref(bufmap);
+		orangefs_bufmap_unref(bufmap);
 	*mapp = bufmap;
 	return ret;
 }
 
-void readdir_index_put(struct pvfs2_bufmap *bufmap, int buffer_index)
+void readdir_index_put(struct orangefs_bufmap *bufmap, int buffer_index)
 {
 	struct slot_args slargs;
 
-	slargs.slot_count = PVFS2_READDIR_DEFAULT_DESC_COUNT;
+	slargs.slot_count = ORANGEFS_READDIR_DEFAULT_DESC_COUNT;
 	slargs.slot_array = bufmap-&gt;readdir_index_array;
 	slargs.slot_lock = &amp;bufmap-&gt;readdir_index_lock;
 	slargs.slot_wq = &amp;readdir_waitq;
 	put_back_slot(&amp;slargs, buffer_index);
-	pvfs2_bufmap_unref(bufmap);
+	orangefs_bufmap_unref(bufmap);
 }
 
-int pvfs_bufmap_copy_from_iovec(struct pvfs2_bufmap *bufmap,
+int orangefs_bufmap_copy_from_iovec(struct orangefs_bufmap *bufmap,
 				struct iov_iter *iter,
 				int buffer_index,
 				size_t size)
 {
-	struct pvfs_bufmap_desc *to = &amp;bufmap-&gt;desc_array[buffer_index];
+	struct orangefs_bufmap_desc *to = &amp;bufmap-&gt;desc_array[buffer_index];
 	int i;
 
 	gossip_debug(GOSSIP_BUFMAP_DEBUG,
@@ -531,12 +531,12 @@ int pvfs_bufmap_copy_from_iovec(struct pvfs2_bufmap *bufmap,
  * a file being read.
  *
  */
-int pvfs_bufmap_copy_to_iovec(struct pvfs2_bufmap *bufmap,
+int orangefs_bufmap_copy_to_iovec(struct orangefs_bufmap *bufmap,
 				    struct iov_iter *iter,
 				    int buffer_index,
 				    size_t size)
 {
-	struct pvfs_bufmap_desc *from = &amp;bufmap-&gt;desc_array[buffer_index];
+	struct orangefs_bufmap_desc *from = &amp;bufmap-&gt;desc_array[buffer_index];
 	int i;
 
 	gossip_debug(GOSSIP_BUFMAP_DEBUG,
diff --git a/fs/orangefs/pvfs2-bufmap.h b/fs/orangefs/pvfs2-bufmap.h
index d1aedb52a877..91d1755c231a 100644
--- a/fs/orangefs/pvfs2-bufmap.h
+++ b/fs/orangefs/pvfs2-bufmap.h
@@ -4,59 +4,59 @@
  * See COPYING in top-level directory.
  */
 
-#ifndef __PVFS2_BUFMAP_H
-#define __PVFS2_BUFMAP_H
+#ifndef __ORANGEFS_BUFMAP_H
+#define __ORANGEFS_BUFMAP_H
 
 /* used to describe mapped buffers */
-struct pvfs_bufmap_desc {
+struct orangefs_bufmap_desc {
 	void *uaddr;			/* user space address pointer */
 	struct page **page_array;	/* array of mapped pages */
 	int array_count;		/* size of above arrays */
 	struct list_head list_link;
 };
 
-struct pvfs2_bufmap;
+struct orangefs_bufmap;
 
-struct pvfs2_bufmap *pvfs2_bufmap_ref(void);
-void pvfs2_bufmap_unref(struct pvfs2_bufmap *bufmap);
+struct orangefs_bufmap *orangefs_bufmap_ref(void);
+void orangefs_bufmap_unref(struct orangefs_bufmap *bufmap);
 
 /*
- * pvfs_bufmap_size_query is now an inline function because buffer
+ * orangefs_bufmap_size_query is now an inline function because buffer
  * sizes are not hardcoded
  */
-int pvfs_bufmap_size_query(void);
+int orangefs_bufmap_size_query(void);
 
-int pvfs_bufmap_shift_query(void);
+int orangefs_bufmap_shift_query(void);
 
-int pvfs_bufmap_initialize(struct PVFS_dev_map_desc *user_desc);
+int orangefs_bufmap_initialize(struct ORANGEFS_dev_map_desc *user_desc);
 
 int get_bufmap_init(void);
 
-void pvfs_bufmap_finalize(void);
+void orangefs_bufmap_finalize(void);
 
-int pvfs_bufmap_get(struct pvfs2_bufmap **mapp, int *buffer_index);
+int orangefs_bufmap_get(struct orangefs_bufmap **mapp, int *buffer_index);
 
-void pvfs_bufmap_put(struct pvfs2_bufmap *bufmap, int buffer_index);
+void orangefs_bufmap_put(struct orangefs_bufmap *bufmap, int buffer_index);
 
-int readdir_index_get(struct pvfs2_bufmap **mapp, int *buffer_index);
+int readdir_index_get(struct orangefs_bufmap **mapp, int *buffer_index);
 
-void readdir_index_put(struct pvfs2_bufmap *bufmap, int buffer_index);
+void readdir_index_put(struct orangefs_bufmap *bufmap, int buffer_index);
 
-int pvfs_bufmap_copy_from_iovec(struct pvfs2_bufmap *bufmap,
+int orangefs_bufmap_copy_from_iovec(struct orangefs_bufmap *bufmap,
 				struct iov_iter *iter,
 				int buffer_index,
 				size_t size);
 
-int pvfs_bufmap_copy_to_iovec(struct pvfs2_bufmap *bufmap,
+int orangefs_bufmap_copy_to_iovec(struct orangefs_bufmap *bufmap,
 			      struct iov_iter *iter,
 			      int buffer_index,
 			      size_t size);
 
-size_t pvfs_bufmap_copy_to_user_task_iovec(struct task_struct *tsk,
+size_t orangefs_bufmap_copy_to_user_task_iovec(struct task_struct *tsk,
 					   struct iovec *iovec,
 					   unsigned long nr_segs,
-					   struct pvfs2_bufmap *bufmap,
+					   struct orangefs_bufmap *bufmap,
 					   int buffer_index,
 					   size_t bytes_to_be_copied);
 
-#endif /* __PVFS2_BUFMAP_H */
+#endif /* __ORANGEFS_BUFMAP_H */
diff --git a/fs/orangefs/pvfs2-cache.c b/fs/orangefs/pvfs2-cache.c
index f982616a4349..a224831770f4 100644
--- a/fs/orangefs/pvfs2-cache.c
+++ b/fs/orangefs/pvfs2-cache.c
@@ -11,27 +11,27 @@
 static __u64 next_tag_value;
 static DEFINE_SPINLOCK(next_tag_value_lock);
 
-/* the pvfs2 memory caches */
+/* the orangefs memory caches */
 
-/* a cache for pvfs2 upcall/downcall operations */
+/* a cache for orangefs upcall/downcall operations */
 static struct kmem_cache *op_cache;
 
 /* a cache for device (/dev/pvfs2-req) communication */
 static struct kmem_cache *dev_req_cache;
 
-/* a cache for pvfs2_kiocb objects (i.e pvfs2 iocb structures ) */
-static struct kmem_cache *pvfs2_kiocb_cache;
+/* a cache for orangefs_kiocb objects (i.e orangefs iocb structures ) */
+static struct kmem_cache *orangefs_kiocb_cache;
 
 int op_cache_initialize(void)
 {
-	op_cache = kmem_cache_create("pvfs2_op_cache",
-				     sizeof(struct pvfs2_kernel_op_s),
+	op_cache = kmem_cache_create("orangefs_op_cache",
+				     sizeof(struct orangefs_kernel_op_s),
 				     0,
-				     PVFS2_CACHE_CREATE_FLAGS,
+				     ORANGEFS_CACHE_CREATE_FLAGS,
 				     NULL);
 
 	if (!op_cache) {
-		gossip_err("Cannot create pvfs2_op_cache\n");
+		gossip_err("Cannot create orangefs_op_cache\n");
 		return -ENOMEM;
 	}
 
@@ -48,72 +48,72 @@ int op_cache_finalize(void)
 	return 0;
 }
 
-char *get_opname_string(struct pvfs2_kernel_op_s *new_op)
+char *get_opname_string(struct orangefs_kernel_op_s *new_op)
 {
 	if (new_op) {
 		__s32 type = new_op-&gt;upcall.type;
 
-		if (type == PVFS2_VFS_OP_FILE_IO)
+		if (type == ORANGEFS_VFS_OP_FILE_IO)
 			return "OP_FILE_IO";
-		else if (type == PVFS2_VFS_OP_LOOKUP)
+		else if (type == ORANGEFS_VFS_OP_LOOKUP)
 			return "OP_LOOKUP";
-		else if (type == PVFS2_VFS_OP_CREATE)
+		else if (type == ORANGEFS_VFS_OP_CREATE)
 			return "OP_CREATE";
-		else if (type == PVFS2_VFS_OP_GETATTR)
+		else if (type == ORANGEFS_VFS_OP_GETATTR)
 			return "OP_GETATTR";
-		else if (type == PVFS2_VFS_OP_REMOVE)
+		else if (type == ORANGEFS_VFS_OP_REMOVE)
 			return "OP_REMOVE";
-		else if (type == PVFS2_VFS_OP_MKDIR)
+		else if (type == ORANGEFS_VFS_OP_MKDIR)
 			return "OP_MKDIR";
-		else if (type == PVFS2_VFS_OP_READDIR)
+		else if (type == ORANGEFS_VFS_OP_READDIR)
 			return "OP_READDIR";
-		else if (type == PVFS2_VFS_OP_READDIRPLUS)
+		else if (type == ORANGEFS_VFS_OP_READDIRPLUS)
 			return "OP_READDIRPLUS";
-		else if (type == PVFS2_VFS_OP_SETATTR)
+		else if (type == ORANGEFS_VFS_OP_SETATTR)
 			return "OP_SETATTR";
-		else if (type == PVFS2_VFS_OP_SYMLINK)
+		else if (type == ORANGEFS_VFS_OP_SYMLINK)
 			return "OP_SYMLINK";
-		else if (type == PVFS2_VFS_OP_RENAME)
+		else if (type == ORANGEFS_VFS_OP_RENAME)
 			return "OP_RENAME";
-		else if (type == PVFS2_VFS_OP_STATFS)
+		else if (type == ORANGEFS_VFS_OP_STATFS)
 			return "OP_STATFS";
-		else if (type == PVFS2_VFS_OP_TRUNCATE)
+		else if (type == ORANGEFS_VFS_OP_TRUNCATE)
 			return "OP_TRUNCATE";
-		else if (type == PVFS2_VFS_OP_MMAP_RA_FLUSH)
+		else if (type == ORANGEFS_VFS_OP_MMAP_RA_FLUSH)
 			return "OP_MMAP_RA_FLUSH";
-		else if (type == PVFS2_VFS_OP_FS_MOUNT)
+		else if (type == ORANGEFS_VFS_OP_FS_MOUNT)
 			return "OP_FS_MOUNT";
-		else if (type == PVFS2_VFS_OP_FS_UMOUNT)
+		else if (type == ORANGEFS_VFS_OP_FS_UMOUNT)
 			return "OP_FS_UMOUNT";
-		else if (type == PVFS2_VFS_OP_GETXATTR)
+		else if (type == ORANGEFS_VFS_OP_GETXATTR)
 			return "OP_GETXATTR";
-		else if (type == PVFS2_VFS_OP_SETXATTR)
+		else if (type == ORANGEFS_VFS_OP_SETXATTR)
 			return "OP_SETXATTR";
-		else if (type == PVFS2_VFS_OP_LISTXATTR)
+		else if (type == ORANGEFS_VFS_OP_LISTXATTR)
 			return "OP_LISTXATTR";
-		else if (type == PVFS2_VFS_OP_REMOVEXATTR)
+		else if (type == ORANGEFS_VFS_OP_REMOVEXATTR)
 			return "OP_REMOVEXATTR";
-		else if (type == PVFS2_VFS_OP_PARAM)
+		else if (type == ORANGEFS_VFS_OP_PARAM)
 			return "OP_PARAM";
-		else if (type == PVFS2_VFS_OP_PERF_COUNT)
+		else if (type == ORANGEFS_VFS_OP_PERF_COUNT)
 			return "OP_PERF_COUNT";
-		else if (type == PVFS2_VFS_OP_CANCEL)
+		else if (type == ORANGEFS_VFS_OP_CANCEL)
 			return "OP_CANCEL";
-		else if (type == PVFS2_VFS_OP_FSYNC)
+		else if (type == ORANGEFS_VFS_OP_FSYNC)
 			return "OP_FSYNC";
-		else if (type == PVFS2_VFS_OP_FSKEY)
+		else if (type == ORANGEFS_VFS_OP_FSKEY)
 			return "OP_FSKEY";
 	}
 	return "OP_UNKNOWN?";
 }
 
-struct pvfs2_kernel_op_s *op_alloc(__s32 type)
+struct orangefs_kernel_op_s *op_alloc(__s32 type)
 {
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 
-	new_op = kmem_cache_alloc(op_cache, PVFS2_CACHE_ALLOC_FLAGS);
+	new_op = kmem_cache_alloc(op_cache, ORANGEFS_CACHE_ALLOC_FLAGS);
 	if (new_op) {
-		memset(new_op, 0, sizeof(struct pvfs2_kernel_op_s));
+		memset(new_op, 0, sizeof(struct orangefs_kernel_op_s));
 
 		INIT_LIST_HEAD(&amp;new_op-&gt;list);
 		spin_lock_init(&amp;new_op-&gt;lock);
@@ -122,7 +122,7 @@ struct pvfs2_kernel_op_s *op_alloc(__s32 type)
 		init_waitqueue_head(&amp;new_op-&gt;io_completion_waitq);
 		atomic_set(&amp;new_op-&gt;aio_ref_count, 0);
 
-		pvfs2_op_initialize(new_op);
+		orangefs_op_initialize(new_op);
 
 		/* initialize the op specific tag and upcall credentials */
 		spin_lock(&amp;next_tag_value_lock);
@@ -149,15 +149,15 @@ struct pvfs2_kernel_op_s *op_alloc(__s32 type)
 	return new_op;
 }
 
-void op_release(struct pvfs2_kernel_op_s *pvfs2_op)
+void op_release(struct orangefs_kernel_op_s *orangefs_op)
 {
-	if (pvfs2_op) {
+	if (orangefs_op) {
 		gossip_debug(GOSSIP_CACHE_DEBUG,
 			     "Releasing OP (%p: %llu)\n",
-			     pvfs2_op,
-			     llu(pvfs2_op-&gt;tag));
-		pvfs2_op_initialize(pvfs2_op);
-		kmem_cache_free(op_cache, pvfs2_op);
+			     orangefs_op,
+			     llu(orangefs_op-&gt;tag));
+		orangefs_op_initialize(orangefs_op);
+		kmem_cache_free(op_cache, orangefs_op);
 	} else {
 		gossip_err("NULL pointer in op_release\n");
 	}
@@ -165,14 +165,14 @@ void op_release(struct pvfs2_kernel_op_s *pvfs2_op)
 
 int dev_req_cache_initialize(void)
 {
-	dev_req_cache = kmem_cache_create("pvfs2_devreqcache",
+	dev_req_cache = kmem_cache_create("orangefs_devreqcache",
 					  MAX_ALIGNED_DEV_REQ_DOWNSIZE,
 					  0,
-					  PVFS2_CACHE_CREATE_FLAGS,
+					  ORANGEFS_CACHE_CREATE_FLAGS,
 					  NULL);
 
 	if (!dev_req_cache) {
-		gossip_err("Cannot create pvfs2_dev_req_cache\n");
+		gossip_err("Cannot create orangefs_dev_req_cache\n");
 		return -ENOMEM;
 	}
 	return 0;
@@ -188,7 +188,7 @@ void *dev_req_alloc(void)
 {
 	void *buffer;
 
-	buffer = kmem_cache_alloc(dev_req_cache, PVFS2_CACHE_ALLOC_FLAGS);
+	buffer = kmem_cache_alloc(dev_req_cache, ORANGEFS_CACHE_ALLOC_FLAGS);
 	if (buffer == NULL)
 		gossip_err("Failed to allocate from dev_req_cache\n");
 	else
@@ -206,14 +206,14 @@ void dev_req_release(void *buffer)
 
 int kiocb_cache_initialize(void)
 {
-	pvfs2_kiocb_cache = kmem_cache_create("pvfs2_kiocbcache",
-					      sizeof(struct pvfs2_kiocb_s),
+	orangefs_kiocb_cache = kmem_cache_create("orangefs_kiocbcache",
+					      sizeof(struct orangefs_kiocb_s),
 					      0,
-					      PVFS2_CACHE_CREATE_FLAGS,
+					      ORANGEFS_CACHE_CREATE_FLAGS,
 					      NULL);
 
-	if (!pvfs2_kiocb_cache) {
-		gossip_err("Cannot create pvfs2_kiocb_cache!\n");
+	if (!orangefs_kiocb_cache) {
+		gossip_err("Cannot create orangefs_kiocb_cache!\n");
 		return -ENOMEM;
 	}
 	return 0;
@@ -221,26 +221,26 @@ int kiocb_cache_initialize(void)
 
 int kiocb_cache_finalize(void)
 {
-	kmem_cache_destroy(pvfs2_kiocb_cache);
+	kmem_cache_destroy(orangefs_kiocb_cache);
 	return 0;
 }
 
-struct pvfs2_kiocb_s *kiocb_alloc(void)
+struct orangefs_kiocb_s *kiocb_alloc(void)
 {
-	struct pvfs2_kiocb_s *x = NULL;
+	struct orangefs_kiocb_s *x = NULL;
 
-	x = kmem_cache_alloc(pvfs2_kiocb_cache, PVFS2_CACHE_ALLOC_FLAGS);
+	x = kmem_cache_alloc(orangefs_kiocb_cache, ORANGEFS_CACHE_ALLOC_FLAGS);
 	if (x == NULL)
 		gossip_err("kiocb_alloc: kmem_cache_alloc failed!\n");
 	else
-		memset(x, 0, sizeof(struct pvfs2_kiocb_s));
+		memset(x, 0, sizeof(struct orangefs_kiocb_s));
 	return x;
 }
 
-void kiocb_release(struct pvfs2_kiocb_s *x)
+void kiocb_release(struct orangefs_kiocb_s *x)
 {
 	if (x)
-		kmem_cache_free(pvfs2_kiocb_cache, x);
+		kmem_cache_free(orangefs_kiocb_cache, x);
 	else
 		gossip_err("kiocb_release: kmem_cache_free NULL pointer!\n");
 }
diff --git a/fs/orangefs/pvfs2-debug.h b/fs/orangefs/pvfs2-debug.h
index fd71d6c84cf6..e6b4baa5e8fb 100644
--- a/fs/orangefs/pvfs2-debug.h
+++ b/fs/orangefs/pvfs2-debug.h
@@ -5,12 +5,12 @@
  */
 
 /* This file just defines debugging masks to be used with the gossip
- * logging utility.  All debugging masks for PVFS2 are kept here to make
+ * logging utility.  All debugging masks for ORANGEFS are kept here to make
  * sure we don't have collisions.
  */
 
-#ifndef __PVFS2_DEBUG_H
-#define __PVFS2_DEBUG_H
+#ifndef __ORANGEFS_DEBUG_H
+#define __ORANGEFS_DEBUG_H
 
 #ifdef __KERNEL__
 #include &lt;linux/types.h&gt;
@@ -90,7 +90,7 @@
 					 GOSSIP_BMI_DEBUG_MX +		\
 					 GOSSIP_BMI_DEBUG_PORTALS))
 
-const char *PVFS_debug_get_next_debug_keyword(int position);
+const char *ORANGEFS_debug_get_next_debug_keyword(int position);
 
 #define GOSSIP_SUPER_DEBUG		((__u64)1 &lt;&lt; 0)
 #define GOSSIP_INODE_DEBUG		((__u64)1 &lt;&lt; 1)
@@ -113,10 +113,10 @@ const char *PVFS_debug_get_next_debug_keyword(int position);
 #define GOSSIP_MAX_DEBUG              (((__u64)1 &lt;&lt; GOSSIP_MAX_NR) - 1)
 
 /*function prototypes*/
-__u64 PVFS_kmod_eventlog_to_mask(const char *event_logging);
-__u64 PVFS_debug_eventlog_to_mask(const char *event_logging);
-char *PVFS_debug_mask_to_eventlog(__u64 mask);
-char *PVFS_kmod_mask_to_eventlog(__u64 mask);
+__u64 ORANGEFS_kmod_eventlog_to_mask(const char *event_logging);
+__u64 ORANGEFS_debug_eventlog_to_mask(const char *event_logging);
+char *ORANGEFS_debug_mask_to_eventlog(__u64 mask);
+char *ORANGEFS_kmod_mask_to_eventlog(__u64 mask);
 
 /* a private internal type */
 struct __keyword_mask_s {
@@ -289,4 +289,4 @@ static const int num_kmod_keyword_mask_map = (int)
 static const int num_keyword_mask_map = (int)
 	(sizeof(s_keyword_mask_map) / sizeof(struct __keyword_mask_s));
 
-#endif /* __PVFS2_DEBUG_H */
+#endif /* __ORANGEFS_DEBUG_H */
diff --git a/fs/orangefs/pvfs2-debugfs.c b/fs/orangefs/pvfs2-debugfs.c
index ba5bfef7a3f3..315dc538b723 100644
--- a/fs/orangefs/pvfs2-debugfs.c
+++ b/fs/orangefs/pvfs2-debugfs.c
@@ -95,7 +95,7 @@ static const struct file_operations kernel_debug_fops = {
  * initialize kmod debug operations, create orangefs debugfs dir and
  * ORANGEFS_KMOD_DEBUG_HELP_FILE.
  */
-int pvfs2_debugfs_init(void)
+int orangefs_debugfs_init(void)
 {
 
 	int rc = -ENOMEM;
@@ -117,12 +117,12 @@ int pvfs2_debugfs_init(void)
 
 out:
 	if (rc)
-		pvfs2_debugfs_cleanup();
+		orangefs_debugfs_cleanup();
 
 	return rc;
 }
 
-void pvfs2_debugfs_cleanup(void)
+void orangefs_debugfs_cleanup(void)
 {
 	debugfs_remove_recursive(debug_dir);
 }
@@ -196,7 +196,7 @@ static int help_show(struct seq_file *m, void *v)
 /*
  * initialize the kernel-debug file.
  */
-int pvfs2_kernel_debug_init(void)
+int orangefs_kernel_debug_init(void)
 {
 
 	int rc = -ENOMEM;
@@ -205,11 +205,11 @@ int pvfs2_kernel_debug_init(void)
 
 	gossip_debug(GOSSIP_DEBUGFS_DEBUG, "%s: start\n", __func__);
 
-	k_buffer = kzalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
+	k_buffer = kzalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
 	if (!k_buffer)
 		goto out;
 
-	if (strlen(kernel_debug_string) + 1 &lt; PVFS2_MAX_DEBUG_STRING_LEN) {
+	if (strlen(kernel_debug_string) + 1 &lt; ORANGEFS_MAX_DEBUG_STRING_LEN) {
 		strcpy(k_buffer, kernel_debug_string);
 		strcat(k_buffer, "\n");
 	} else {
@@ -233,7 +233,7 @@ int pvfs2_kernel_debug_init(void)
 
 out:
 	if (rc)
-		pvfs2_debugfs_cleanup();
+		orangefs_debugfs_cleanup();
 
 	gossip_debug(GOSSIP_DEBUGFS_DEBUG, "%s: rc:%d:\n", __func__, rc);
 	return rc;
@@ -242,7 +242,7 @@ int pvfs2_kernel_debug_init(void)
 /*
  * initialize the client-debug file.
  */
-int pvfs2_client_debug_init(void)
+int orangefs_client_debug_init(void)
 {
 
 	int rc = -ENOMEM;
@@ -250,11 +250,11 @@ int pvfs2_client_debug_init(void)
 
 	gossip_debug(GOSSIP_DEBUGFS_DEBUG, "%s: start\n", __func__);
 
-	c_buffer = kzalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
+	c_buffer = kzalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
 	if (!c_buffer)
 		goto out;
 
-	if (strlen(client_debug_string) + 1 &lt; PVFS2_MAX_DEBUG_STRING_LEN) {
+	if (strlen(client_debug_string) + 1 &lt; ORANGEFS_MAX_DEBUG_STRING_LEN) {
 		strcpy(c_buffer, client_debug_string);
 		strcat(c_buffer, "\n");
 	} else {
@@ -278,7 +278,7 @@ int pvfs2_client_debug_init(void)
 
 out:
 	if (rc)
-		pvfs2_debugfs_cleanup();
+		orangefs_debugfs_cleanup();
 
 	gossip_debug(GOSSIP_DEBUGFS_DEBUG, "%s: rc:%d:\n", __func__, rc);
 	return rc;
@@ -320,7 +320,7 @@ static ssize_t orangefs_debug_read(struct file *file,
 
 	gossip_debug(GOSSIP_DEBUGFS_DEBUG, "orangefs_debug_read: start\n");
 
-	buf = kmalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
+	buf = kmalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
 	if (!buf)
 		goto out;
 
@@ -349,7 +349,7 @@ static ssize_t orangefs_debug_write(struct file *file,
 	int rc = -EFAULT;
 	size_t silly = 0;
 	char *debug_string;
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 	struct client_debug_mask c_mask = { NULL, 0, 0 };
 
 	gossip_debug(GOSSIP_DEBUGFS_DEBUG,
@@ -360,15 +360,15 @@ static ssize_t orangefs_debug_write(struct file *file,
 	 * Thwart users who try to jamb a ridiculous number
 	 * of bytes into the debug file...
 	 */
-	if (count &gt; PVFS2_MAX_DEBUG_STRING_LEN + 1) {
+	if (count &gt; ORANGEFS_MAX_DEBUG_STRING_LEN + 1) {
 		silly = count;
-		count = PVFS2_MAX_DEBUG_STRING_LEN + 1;
+		count = ORANGEFS_MAX_DEBUG_STRING_LEN + 1;
 	}
 
-	buf = kmalloc(PVFS2_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
+	buf = kmalloc(ORANGEFS_MAX_DEBUG_STRING_LEN, GFP_KERNEL);
 	if (!buf)
 		goto out;
-	memset(buf, 0, PVFS2_MAX_DEBUG_STRING_LEN);
+	memset(buf, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);
 
 	if (copy_from_user(buf, ubuf, count - 1)) {
 		gossip_debug(GOSSIP_DEBUGFS_DEBUG,
@@ -407,18 +407,18 @@ static ssize_t orangefs_debug_write(struct file *file,
 		debug_mask_to_string(&amp;c_mask, 1);
 		debug_string = client_debug_string;
 
-		new_op = op_alloc(PVFS2_VFS_OP_PARAM);
+		new_op = op_alloc(ORANGEFS_VFS_OP_PARAM);
 		if (!new_op) {
 			pr_info("%s: op_alloc failed!\n", __func__);
 			goto out;
 		}
 
 		new_op-&gt;upcall.req.param.op =
-			PVFS2_PARAM_REQUEST_OP_TWO_MASK_VALUES;
-		new_op-&gt;upcall.req.param.type = PVFS2_PARAM_REQUEST_SET;
+			ORANGEFS_PARAM_REQUEST_OP_TWO_MASK_VALUES;
+		new_op-&gt;upcall.req.param.type = ORANGEFS_PARAM_REQUEST_SET;
 		memset(new_op-&gt;upcall.req.param.s_value,
 		       0,
-		       PVFS2_MAX_DEBUG_STRING_LEN);
+		       ORANGEFS_MAX_DEBUG_STRING_LEN);
 		sprintf(new_op-&gt;upcall.req.param.s_value,
 			"%llx %llx\n",
 			c_mask.mask1,
@@ -426,8 +426,8 @@ static ssize_t orangefs_debug_write(struct file *file,
 
 		/* service_operation returns 0 on success... */
 		rc = service_operation(new_op,
-				       "pvfs2_param",
-					PVFS2_OP_INTERRUPTIBLE);
+				       "orangefs_param",
+					ORANGEFS_OP_INTERRUPTIBLE);
 
 		if (rc)
 			gossip_debug(GOSSIP_DEBUGFS_DEBUG,
@@ -439,7 +439,7 @@ static ssize_t orangefs_debug_write(struct file *file,
 	}
 
 	mutex_lock(&amp;orangefs_debug_lock);
-	memset(file-&gt;f_inode-&gt;i_private, 0, PVFS2_MAX_DEBUG_STRING_LEN);
+	memset(file-&gt;f_inode-&gt;i_private, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);
 	sprintf((char *)file-&gt;f_inode-&gt;i_private, "%s\n", debug_string);
 	mutex_unlock(&amp;orangefs_debug_lock);
 
diff --git a/fs/orangefs/pvfs2-debugfs.h b/fs/orangefs/pvfs2-debugfs.h
index a66b7d08c14d..e4828c0e3ef9 100644
--- a/fs/orangefs/pvfs2-debugfs.h
+++ b/fs/orangefs/pvfs2-debugfs.h
@@ -1,3 +1,3 @@
-int pvfs2_debugfs_init(void);
-int pvfs2_kernel_debug_init(void);
-void pvfs2_debugfs_cleanup(void);
+int orangefs_debugfs_init(void);
+int orangefs_kernel_debug_init(void);
+void orangefs_debugfs_cleanup(void);
diff --git a/fs/orangefs/pvfs2-dev-proto.h b/fs/orangefs/pvfs2-dev-proto.h
index 71ab56df4ad7..dc1951dd7045 100644
--- a/fs/orangefs/pvfs2-dev-proto.h
+++ b/fs/orangefs/pvfs2-dev-proto.h
@@ -4,8 +4,8 @@
  * See COPYING in top-level directory.
  */
 
-#ifndef _PVFS2_DEV_PROTO_H
-#define _PVFS2_DEV_PROTO_H
+#ifndef _ORANGEFS_DEV_PROTO_H
+#define _ORANGEFS_DEV_PROTO_H
 
 /*
  * types and constants shared between user space and kernel space for
@@ -13,46 +13,46 @@
  */
 
 /*
- * valid pvfs2 kernel operation types
+ * valid orangefs kernel operation types
  */
-#define PVFS2_VFS_OP_INVALID           0xFF000000
-#define PVFS2_VFS_OP_FILE_IO           0xFF000001
-#define PVFS2_VFS_OP_LOOKUP            0xFF000002
-#define PVFS2_VFS_OP_CREATE            0xFF000003
-#define PVFS2_VFS_OP_GETATTR           0xFF000004
-#define PVFS2_VFS_OP_REMOVE            0xFF000005
-#define PVFS2_VFS_OP_MKDIR             0xFF000006
-#define PVFS2_VFS_OP_READDIR           0xFF000007
-#define PVFS2_VFS_OP_SETATTR           0xFF000008
-#define PVFS2_VFS_OP_SYMLINK           0xFF000009
-#define PVFS2_VFS_OP_RENAME            0xFF00000A
-#define PVFS2_VFS_OP_STATFS            0xFF00000B
-#define PVFS2_VFS_OP_TRUNCATE          0xFF00000C
-#define PVFS2_VFS_OP_MMAP_RA_FLUSH     0xFF00000D
-#define PVFS2_VFS_OP_FS_MOUNT          0xFF00000E
-#define PVFS2_VFS_OP_FS_UMOUNT         0xFF00000F
-#define PVFS2_VFS_OP_GETXATTR          0xFF000010
-#define PVFS2_VFS_OP_SETXATTR          0xFF000011
-#define PVFS2_VFS_OP_LISTXATTR         0xFF000012
-#define PVFS2_VFS_OP_REMOVEXATTR       0xFF000013
-#define PVFS2_VFS_OP_PARAM             0xFF000014
-#define PVFS2_VFS_OP_PERF_COUNT        0xFF000015
-#define PVFS2_VFS_OP_CANCEL            0xFF00EE00
-#define PVFS2_VFS_OP_FSYNC             0xFF00EE01
-#define PVFS2_VFS_OP_FSKEY             0xFF00EE02
-#define PVFS2_VFS_OP_READDIRPLUS       0xFF00EE03
+#define ORANGEFS_VFS_OP_INVALID           0xFF000000
+#define ORANGEFS_VFS_OP_FILE_IO        0xFF000001
+#define ORANGEFS_VFS_OP_LOOKUP         0xFF000002
+#define ORANGEFS_VFS_OP_CREATE         0xFF000003
+#define ORANGEFS_VFS_OP_GETATTR        0xFF000004
+#define ORANGEFS_VFS_OP_REMOVE         0xFF000005
+#define ORANGEFS_VFS_OP_MKDIR          0xFF000006
+#define ORANGEFS_VFS_OP_READDIR        0xFF000007
+#define ORANGEFS_VFS_OP_SETATTR        0xFF000008
+#define ORANGEFS_VFS_OP_SYMLINK        0xFF000009
+#define ORANGEFS_VFS_OP_RENAME         0xFF00000A
+#define ORANGEFS_VFS_OP_STATFS         0xFF00000B
+#define ORANGEFS_VFS_OP_TRUNCATE       0xFF00000C
+#define ORANGEFS_VFS_OP_MMAP_RA_FLUSH  0xFF00000D
+#define ORANGEFS_VFS_OP_FS_MOUNT       0xFF00000E
+#define ORANGEFS_VFS_OP_FS_UMOUNT      0xFF00000F
+#define ORANGEFS_VFS_OP_GETXATTR       0xFF000010
+#define ORANGEFS_VFS_OP_SETXATTR          0xFF000011
+#define ORANGEFS_VFS_OP_LISTXATTR         0xFF000012
+#define ORANGEFS_VFS_OP_REMOVEXATTR       0xFF000013
+#define ORANGEFS_VFS_OP_PARAM          0xFF000014
+#define ORANGEFS_VFS_OP_PERF_COUNT     0xFF000015
+#define ORANGEFS_VFS_OP_CANCEL            0xFF00EE00
+#define ORANGEFS_VFS_OP_FSYNC          0xFF00EE01
+#define ORANGEFS_VFS_OP_FSKEY             0xFF00EE02
+#define ORANGEFS_VFS_OP_READDIRPLUS       0xFF00EE03
 
 /*
  * Misc constants. Please retain them as multiples of 8!
  * Otherwise 32-64 bit interactions will be messed up :)
  */
-#define PVFS2_NAME_LEN			0x00000100
-#define PVFS2_MAX_DEBUG_STRING_LEN	0x00000400
-#define PVFS2_MAX_DEBUG_ARRAY_LEN	0x00000800
+#define ORANGEFS_NAME_LEN		0x00000100
+#define ORANGEFS_MAX_DEBUG_STRING_LEN	0x00000400
+#define ORANGEFS_MAX_DEBUG_ARRAY_LEN	0x00000800
 
 /*
- * MAX_DIRENT_COUNT cannot be larger than PVFS_REQ_LIMIT_LISTATTR.
- * The value of PVFS_REQ_LIMIT_LISTATTR has been changed from 113 to 60
+ * MAX_DIRENT_COUNT cannot be larger than ORANGEFS_REQ_LIMIT_LISTATTR.
+ * The value of ORANGEFS_REQ_LIMIT_LISTATTR has been changed from 113 to 60
  * to accomodate an attribute object with mirrored handles.
  * MAX_DIRENT_COUNT is replaced by MAX_DIRENT_COUNT_READDIR and
  * MAX_DIRENT_COUNT_READDIRPLUS, since readdir doesn't trigger a listattr
diff --git a/fs/orangefs/pvfs2-kernel.h b/fs/orangefs/pvfs2-kernel.h
index 4295e263e25b..33fcf3bccd2e 100644
--- a/fs/orangefs/pvfs2-kernel.h
+++ b/fs/orangefs/pvfs2-kernel.h
@@ -5,18 +5,18 @@
  */
 
 /*
- *  The PVFS2 Linux kernel support allows PVFS2 volumes to be mounted and
+ *  The ORANGEFS Linux kernel support allows ORANGEFS volumes to be mounted and
  *  accessed through the Linux VFS (i.e. using standard I/O system calls).
  *  This support is only needed on clients that wish to mount the file system.
  *
  */
 
 /*
- *  Declarations and macros for the PVFS2 Linux kernel support.
+ *  Declarations and macros for the ORANGEFS Linux kernel support.
  */
 
-#ifndef __PVFS2KERNEL_H
-#define __PVFS2KERNEL_H
+#ifndef __ORANGEFSKERNEL_H
+#define __ORANGEFSKERNEL_H
 
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/moduleparam.h&gt;
@@ -55,30 +55,30 @@
 
 #include "pvfs2-dev-proto.h"
 
-#ifdef PVFS2_KERNEL_DEBUG
-#define PVFS2_DEFAULT_OP_TIMEOUT_SECS       10
+#ifdef ORANGEFS_KERNEL_DEBUG
+#define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       10
 #else
-#define PVFS2_DEFAULT_OP_TIMEOUT_SECS       20
+#define ORANGEFS_DEFAULT_OP_TIMEOUT_SECS       20
 #endif
 
-#define PVFS2_BUFMAP_WAIT_TIMEOUT_SECS      30
+#define ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS   30
 
-#define PVFS2_DEFAULT_SLOT_TIMEOUT_SECS     900	/* 15 minutes */
+#define ORANGEFS_DEFAULT_SLOT_TIMEOUT_SECS     900	/* 15 minutes */
 
-#define PVFS2_REQDEVICE_NAME          "pvfs2-req"
+#define ORANGEFS_REQDEVICE_NAME          "pvfs2-req"
 
-#define PVFS2_DEVREQ_MAGIC             0x20030529
-#define PVFS2_LINK_MAX                 0x000000FF
-#define PVFS2_PURGE_RETRY_COUNT        0x00000005
-#define PVFS2_SEEK_END                 0x00000002
-#define PVFS2_MAX_NUM_OPTIONS          0x00000004
-#define PVFS2_MAX_MOUNT_OPT_LEN        0x00000080
-#define PVFS2_MAX_FSKEY_LEN            64
+#define ORANGEFS_DEVREQ_MAGIC             0x20030529
+#define ORANGEFS_LINK_MAX                 0x000000FF
+#define ORANGEFS_PURGE_RETRY_COUNT     0x00000005
+#define ORANGEFS_SEEK_END              0x00000002
+#define ORANGEFS_MAX_NUM_OPTIONS          0x00000004
+#define ORANGEFS_MAX_MOUNT_OPT_LEN        0x00000080
+#define ORANGEFS_MAX_FSKEY_LEN            64
 
 #define MAX_DEV_REQ_UPSIZE (2*sizeof(__s32) +   \
-sizeof(__u64) + sizeof(struct pvfs2_upcall_s))
+sizeof(__u64) + sizeof(struct orangefs_upcall_s))
 #define MAX_DEV_REQ_DOWNSIZE (2*sizeof(__s32) + \
-sizeof(__u64) + sizeof(struct pvfs2_downcall_s))
+sizeof(__u64) + sizeof(struct orangefs_downcall_s))
 
 #define BITS_PER_LONG_DIV_8 (BITS_PER_LONG &gt;&gt; 3)
 
@@ -104,7 +104,7 @@ sizeof(__u64) + sizeof(struct pvfs2_downcall_s))
 			MAX_DEV_REQ_DOWNSIZE))
 
 /*
- * valid pvfs2 kernel operation states
+ * valid orangefs kernel operation states
  *
  * unknown  - op was just initialized
  * waiting  - op is on request_list (upward bound)
@@ -113,7 +113,7 @@ sizeof(__u64) + sizeof(struct pvfs2_downcall_s))
  * purged   - op has to start a timer since client-core
  *            exited uncleanly before servicing op
  */
-enum pvfs2_vfs_op_states {
+enum orangefs_vfs_op_states {
 	OP_VFS_STATE_UNKNOWN = 0,
 	OP_VFS_STATE_WAITING = 1,
 	OP_VFS_STATE_INPROGR = 2,
@@ -156,9 +156,9 @@ enum pvfs2_vfs_op_states {
 /*
  * Defines for controlling whether I/O upcalls are for async or sync operations
  */
-enum PVFS_async_io_type {
-	PVFS_VFS_SYNC_IO = 0,
-	PVFS_VFS_ASYNC_IO = 1,
+enum ORANGEFS_async_io_type {
+	ORANGEFS_VFS_SYNC_IO = 0,
+	ORANGEFS_VFS_ASYNC_IO = 1,
 };
 
 /*
@@ -172,24 +172,24 @@ struct client_debug_mask {
 };
 
 /*
- * pvfs2 kernel memory related flags
+ * orangefs kernel memory related flags
  */
 
-#if ((defined PVFS2_KERNEL_DEBUG) &amp;&amp; (defined CONFIG_DEBUG_SLAB))
-#define PVFS2_CACHE_CREATE_FLAGS SLAB_RED_ZONE
+#if ((defined ORANGEFS_KERNEL_DEBUG) &amp;&amp; (defined CONFIG_DEBUG_SLAB))
+#define ORANGEFS_CACHE_CREATE_FLAGS SLAB_RED_ZONE
 #else
-#define PVFS2_CACHE_CREATE_FLAGS 0
-#endif /* ((defined PVFS2_KERNEL_DEBUG) &amp;&amp; (defined CONFIG_DEBUG_SLAB)) */
+#define ORANGEFS_CACHE_CREATE_FLAGS 0
+#endif /* ((defined ORANGEFS_KERNEL_DEBUG) &amp;&amp; (defined CONFIG_DEBUG_SLAB)) */
 
-#define PVFS2_CACHE_ALLOC_FLAGS (GFP_KERNEL)
-#define PVFS2_GFP_FLAGS (GFP_KERNEL)
-#define PVFS2_BUFMAP_GFP_FLAGS (GFP_KERNEL)
+#define ORANGEFS_CACHE_ALLOC_FLAGS (GFP_KERNEL)
+#define ORANGEFS_GFP_FLAGS (GFP_KERNEL)
+#define ORANGEFS_BUFMAP_GFP_FLAGS (GFP_KERNEL)
 
-/* pvfs2 xattr and acl related defines */
-#define PVFS2_XATTR_INDEX_POSIX_ACL_ACCESS  1
-#define PVFS2_XATTR_INDEX_POSIX_ACL_DEFAULT 2
-#define PVFS2_XATTR_INDEX_TRUSTED           3
-#define PVFS2_XATTR_INDEX_DEFAULT           4
+/* orangefs xattr and acl related defines */
+#define ORANGEFS_XATTR_INDEX_POSIX_ACL_ACCESS  1
+#define ORANGEFS_XATTR_INDEX_POSIX_ACL_DEFAULT 2
+#define ORANGEFS_XATTR_INDEX_TRUSTED           3
+#define ORANGEFS_XATTR_INDEX_DEFAULT           4
 
 #if 0
 #ifndef POSIX_ACL_XATTR_ACCESS
@@ -200,17 +200,17 @@ struct client_debug_mask {
 #endif
 #endif
 
-#define PVFS2_XATTR_NAME_ACL_ACCESS  POSIX_ACL_XATTR_ACCESS
-#define PVFS2_XATTR_NAME_ACL_DEFAULT POSIX_ACL_XATTR_DEFAULT
-#define PVFS2_XATTR_NAME_TRUSTED_PREFIX "trusted."
-#define PVFS2_XATTR_NAME_DEFAULT_PREFIX ""
+#define ORANGEFS_XATTR_NAME_ACL_ACCESS  POSIX_ACL_XATTR_ACCESS
+#define ORANGEFS_XATTR_NAME_ACL_DEFAULT POSIX_ACL_XATTR_DEFAULT
+#define ORANGEFS_XATTR_NAME_TRUSTED_PREFIX "trusted."
+#define ORANGEFS_XATTR_NAME_DEFAULT_PREFIX ""
 
-/* these functions are defined in pvfs2-utils.c */
+/* these functions are defined in orangefs-utils.c */
 int orangefs_prepare_cdm_array(char *debug_array_string);
 int orangefs_prepare_debugfs_help_string(int);
 
-/* defined in pvfs2-debugfs.c */
-int pvfs2_client_debug_init(void);
+/* defined in orangefs-debugfs.c */
+int orangefs_client_debug_init(void);
 
 void debug_string_to_mask(char *, void *, int);
 void do_c_mask(int, char *, struct client_debug_mask **);
@@ -222,17 +222,17 @@ void do_c_string(void *, int);
 int check_amalgam_keyword(void *, int);
 int keyword_is_amalgam(char *);
 
-/*these variables are defined in pvfs2-mod.c */
-extern char kernel_debug_string[PVFS2_MAX_DEBUG_STRING_LEN];
-extern char client_debug_string[PVFS2_MAX_DEBUG_STRING_LEN];
-extern char client_debug_array_string[PVFS2_MAX_DEBUG_STRING_LEN];
+/*these variables are defined in orangefs-mod.c */
+extern char kernel_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
+extern char client_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
+extern char client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
 extern unsigned int kernel_mask_set_mod_init;
 
-extern int pvfs2_init_acl(struct inode *inode, struct inode *dir);
-extern const struct xattr_handler *pvfs2_xattr_handlers[];
+extern int orangefs_init_acl(struct inode *inode, struct inode *dir);
+extern const struct xattr_handler *orangefs_xattr_handlers[];
 
-extern struct posix_acl *pvfs2_get_acl(struct inode *inode, int type);
-extern int pvfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type);
+extern struct posix_acl *orangefs_get_acl(struct inode *inode, int type);
+extern int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type);
 
 /*
  * Redefine xtvec structure so that we could move helper functions out of
@@ -244,10 +244,10 @@ struct xtvec {
 };
 
 /*
- * pvfs2 data structures
+ * orangefs data structures
  */
-struct pvfs2_kernel_op_s {
-	enum pvfs2_vfs_op_states op_state;
+struct orangefs_kernel_op_s {
+	enum orangefs_vfs_op_states op_state;
 	__u64 tag;
 
 	/*
@@ -257,8 +257,8 @@ struct pvfs2_kernel_op_s {
 	 */
 	int uses_shared_memory;
 
-	struct pvfs2_upcall_s upcall;
-	struct pvfs2_downcall_s downcall;
+	struct orangefs_upcall_s upcall;
+	struct orangefs_downcall_s downcall;
 
 	wait_queue_head_t waitq;
 	spinlock_t lock;
@@ -268,7 +268,7 @@ struct pvfs2_kernel_op_s {
 
 	/* VFS aio fields */
 
-	/* used by the async I/O code to stash the pvfs2_kiocb_s structure */
+	/* used by the async I/O code to stash the orangefs_kiocb_s structure */
 	void *priv;
 
 	/* used again for the async I/O code for deallocation */
@@ -279,14 +279,14 @@ struct pvfs2_kernel_op_s {
 	struct list_head list;
 };
 
-/* per inode private pvfs2 info */
-struct pvfs2_inode_s {
-	struct pvfs2_object_kref refn;
-	char link_target[PVFS_NAME_MAX];
+/* per inode private orangefs info */
+struct orangefs_inode_s {
+	struct orangefs_object_kref refn;
+	char link_target[ORANGEFS_NAME_MAX];
 	__s64 blksize;
 	/*
 	 * Reading/Writing Extended attributes need to acquire the appropriate
-	 * reader/writer semaphore on the pvfs2_inode_s structure.
+	 * reader/writer semaphore on the orangefs_inode_s structure.
 	 */
 	struct rw_semaphore xattr_sem;
 
@@ -299,7 +299,7 @@ struct pvfs2_inode_s {
 	 */
 	unsigned long pinode_flags;
 
-	/* All allocated pvfs2_inode_s objects are chained to a list */
+	/* All allocated orangefs_inode_s objects are chained to a list */
 	struct list_head list;
 };
 
@@ -324,15 +324,15 @@ struct pvfs2_inode_s {
 #define SetModeFlag(pinode)   set_bit(P_MODE_FLAG, &amp;(pinode)-&gt;pinode_flags)
 #define ModeFlag(pinode)      test_bit(P_MODE_FLAG, &amp;(pinode)-&gt;pinode_flags)
 
-/* per superblock private pvfs2 info */
-struct pvfs2_sb_info_s {
-	struct pvfs2_khandle root_khandle;
+/* per superblock private orangefs info */
+struct orangefs_sb_info_s {
+	struct orangefs_khandle root_khandle;
 	__s32 fs_id;
 	int id;
 	int flags;
-#define PVFS2_OPT_INTR		0x01
-#define PVFS2_OPT_LOCAL_LOCK	0x02
-	char devname[PVFS_MAX_SERVER_ADDR_LEN];
+#define ORANGEFS_OPT_INTR	0x01
+#define ORANGEFS_OPT_LOCAL_LOCK	0x02
+	char devname[ORANGEFS_MAX_SERVER_ADDR_LEN];
 	struct super_block *sb;
 	int mount_pending;
 	struct list_head list;
@@ -344,7 +344,7 @@ struct pvfs2_sb_info_s {
  * or even completion notification so that the VFS client-side daemon
  * can free up its vfs_request slots.
  */
-struct pvfs2_kiocb_s {
+struct orangefs_kiocb_s {
 	/* the pointer to the task that initiated the AIO */
 	struct task_struct *tsk;
 
@@ -352,11 +352,11 @@ struct pvfs2_kiocb_s {
 	struct kiocb *kiocb;
 
 	/* buffer index that was used for the I/O */
-	struct pvfs2_bufmap *bufmap;
+	struct orangefs_bufmap *bufmap;
 	int buffer_index;
 
-	/* pvfs2 kernel operation type */
-	struct pvfs2_kernel_op_s *op;
+	/* orangefs kernel operation type */
+	struct orangefs_kernel_op_s *op;
 
 	/* The user space buffers from/to which I/O is being staged */
 	struct iovec *iov;
@@ -377,31 +377,31 @@ struct pvfs2_kiocb_s {
 	int needs_cleanup;
 };
 
-struct pvfs2_stats {
+struct orangefs_stats {
 	unsigned long cache_hits;
 	unsigned long cache_misses;
 	unsigned long reads;
 	unsigned long writes;
 };
 
-extern struct pvfs2_stats g_pvfs2_stats;
+extern struct orangefs_stats g_orangefs_stats;
 
 /*
  * NOTE: See Documentation/filesystems/porting for information
  * on implementing FOO_I and properly accessing fs private data
  */
-static inline struct pvfs2_inode_s *PVFS2_I(struct inode *inode)
+static inline struct orangefs_inode_s *ORANGEFS_I(struct inode *inode)
 {
-	return container_of(inode, struct pvfs2_inode_s, vfs_inode);
+	return container_of(inode, struct orangefs_inode_s, vfs_inode);
 }
 
-static inline struct pvfs2_sb_info_s *PVFS2_SB(struct super_block *sb)
+static inline struct orangefs_sb_info_s *ORANGEFS_SB(struct super_block *sb)
 {
-	return (struct pvfs2_sb_info_s *) sb-&gt;s_fs_info;
+	return (struct orangefs_sb_info_s *) sb-&gt;s_fs_info;
 }
 
 /* ino_t descends from "unsigned long", 8 bytes, 64 bits. */
-static inline ino_t pvfs2_khandle_to_ino(struct pvfs2_khandle *khandle)
+static inline ino_t orangefs_khandle_to_ino(struct orangefs_khandle *khandle)
 {
 	union {
 		unsigned char u[8];
@@ -420,23 +420,23 @@ static inline ino_t pvfs2_khandle_to_ino(struct pvfs2_khandle *khandle)
 	return ihandle.ino;
 }
 
-static inline struct pvfs2_khandle *get_khandle_from_ino(struct inode *inode)
+static inline struct orangefs_khandle *get_khandle_from_ino(struct inode *inode)
 {
-	return &amp;(PVFS2_I(inode)-&gt;refn.khandle);
+	return &amp;(ORANGEFS_I(inode)-&gt;refn.khandle);
 }
 
 static inline __s32 get_fsid_from_ino(struct inode *inode)
 {
-	return PVFS2_I(inode)-&gt;refn.fs_id;
+	return ORANGEFS_I(inode)-&gt;refn.fs_id;
 }
 
 static inline ino_t get_ino_from_khandle(struct inode *inode)
 {
-	struct pvfs2_khandle *khandle;
+	struct orangefs_khandle *khandle;
 	ino_t ino;
 
 	khandle = get_khandle_from_ino(inode);
-	ino = pvfs2_khandle_to_ino(khandle);
+	ino = orangefs_khandle_to_ino(khandle);
 	return ino;
 }
 
@@ -450,17 +450,17 @@ static inline int is_root_handle(struct inode *inode)
 	gossip_debug(GOSSIP_DCACHE_DEBUG,
 		     "%s: root handle: %pU, this handle: %pU:\n",
 		     __func__,
-		     &amp;PVFS2_SB(inode-&gt;i_sb)-&gt;root_khandle,
+		     &amp;ORANGEFS_SB(inode-&gt;i_sb)-&gt;root_khandle,
 		     get_khandle_from_ino(inode));
 
-	if (PVFS_khandle_cmp(&amp;(PVFS2_SB(inode-&gt;i_sb)-&gt;root_khandle),
+	if (ORANGEFS_khandle_cmp(&amp;(ORANGEFS_SB(inode-&gt;i_sb)-&gt;root_khandle),
 			     get_khandle_from_ino(inode)))
 		return 0;
 	else
 		return 1;
 }
 
-static inline int match_handle(struct pvfs2_khandle resp_handle,
+static inline int match_handle(struct orangefs_khandle resp_handle,
 			       struct inode *inode)
 {
 	gossip_debug(GOSSIP_DCACHE_DEBUG,
@@ -469,57 +469,57 @@ static inline int match_handle(struct pvfs2_khandle resp_handle,
 		     &amp;resp_handle,
 		     get_khandle_from_ino(inode));
 
-	if (PVFS_khandle_cmp(&amp;resp_handle, get_khandle_from_ino(inode)))
+	if (ORANGEFS_khandle_cmp(&amp;resp_handle, get_khandle_from_ino(inode)))
 		return 0;
 	else
 		return 1;
 }
 
 /*
- * defined in pvfs2-cache.c
+ * defined in orangefs-cache.c
  */
 int op_cache_initialize(void);
 int op_cache_finalize(void);
-struct pvfs2_kernel_op_s *op_alloc(__s32 type);
-char *get_opname_string(struct pvfs2_kernel_op_s *new_op);
-void op_release(struct pvfs2_kernel_op_s *op);
+struct orangefs_kernel_op_s *op_alloc(__s32 type);
+char *get_opname_string(struct orangefs_kernel_op_s *new_op);
+void op_release(struct orangefs_kernel_op_s *op);
 
 int dev_req_cache_initialize(void);
 int dev_req_cache_finalize(void);
 void *dev_req_alloc(void);
 void dev_req_release(void *);
 
-int pvfs2_inode_cache_initialize(void);
-int pvfs2_inode_cache_finalize(void);
+int orangefs_inode_cache_initialize(void);
+int orangefs_inode_cache_finalize(void);
 
 int kiocb_cache_initialize(void);
 int kiocb_cache_finalize(void);
-struct pvfs2_kiocb_s *kiocb_alloc(void);
-void kiocb_release(struct pvfs2_kiocb_s *ptr);
+struct orangefs_kiocb_s *kiocb_alloc(void);
+void kiocb_release(struct orangefs_kiocb_s *ptr);
 
 /*
- * defined in pvfs2-mod.c
+ * defined in orangefs-mod.c
  */
 void purge_inprogress_ops(void);
 
 /*
  * defined in waitqueue.c
  */
-int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op);
-int wait_for_cancellation_downcall(struct pvfs2_kernel_op_s *op);
-void pvfs2_clean_up_interrupted_operation(struct pvfs2_kernel_op_s *op);
+int wait_for_matching_downcall(struct orangefs_kernel_op_s *op);
+int wait_for_cancellation_downcall(struct orangefs_kernel_op_s *op);
+void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op);
 void purge_waiting_ops(void);
 
 /*
  * defined in super.c
  */
-struct dentry *pvfs2_mount(struct file_system_type *fst,
+struct dentry *orangefs_mount(struct file_system_type *fst,
 			   int flags,
 			   const char *devname,
 			   void *data);
 
-void pvfs2_kill_sb(struct super_block *sb);
-int pvfs2_remount(struct super_block *sb);
+void orangefs_kill_sb(struct super_block *sb);
+int orangefs_remount(struct super_block *sb);
 
 int fsid_key_table_initialize(void);
 void fsid_key_table_finalize(void);
@@ -527,175 +527,175 @@ void fsid_key_table_finalize(void);
 /*
  * defined in inode.c
  */
-__u32 convert_to_pvfs2_mask(unsigned long lite_mask);
-struct inode *pvfs2_new_inode(struct super_block *sb,
+__u32 convert_to_orangefs_mask(unsigned long lite_mask);
+struct inode *orangefs_new_inode(struct super_block *sb,
 			      struct inode *dir,
 			      int mode,
 			      dev_t dev,
-			      struct pvfs2_object_kref *ref);
+			      struct orangefs_object_kref *ref);
 
-int pvfs2_setattr(struct dentry *dentry, struct iattr *iattr);
+int orangefs_setattr(struct dentry *dentry, struct iattr *iattr);
 
-int pvfs2_getattr(struct vfsmount *mnt,
+int orangefs_getattr(struct vfsmount *mnt,
 		  struct dentry *dentry,
 		  struct kstat *kstat);
 
 /*
  * defined in xattr.c
  */
-int pvfs2_setxattr(struct dentry *dentry,
+int orangefs_setxattr(struct dentry *dentry,
 		   const char *name,
 		   const void *value,
 		   size_t size,
 		   int flags);
 
-ssize_t pvfs2_getxattr(struct dentry *dentry,
+ssize_t orangefs_getxattr(struct dentry *dentry,
 		       const char *name,
 		       void *buffer,
 		       size_t size);
 
-ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size);
+ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size);
 
 /*
  * defined in namei.c
  */
-struct inode *pvfs2_iget(struct super_block *sb,
-			 struct pvfs2_object_kref *ref);
+struct inode *orangefs_iget(struct super_block *sb,
+			 struct orangefs_object_kref *ref);
 
-ssize_t pvfs2_inode_read(struct inode *inode,
-			 struct iov_iter *iter,
-			 loff_t *offset,
-			 loff_t readahead_size);
+ssize_t orangefs_inode_read(struct inode *inode,
+			    struct iov_iter *iter,
+			    loff_t *offset,
+			    loff_t readahead_size);
 
 /*
- * defined in devpvfs2-req.c
+ * defined in devorangefs-req.c
  */
-int pvfs2_dev_init(void);
-void pvfs2_dev_cleanup(void);
+int orangefs_dev_init(void);
+void orangefs_dev_cleanup(void);
 int is_daemon_in_service(void);
 int fs_mount_pending(__s32 fsid);
 
 /*
- * defined in pvfs2-utils.c
+ * defined in orangefs-utils.c
  */
-__s32 fsid_of_op(struct pvfs2_kernel_op_s *op);
+__s32 fsid_of_op(struct orangefs_kernel_op_s *op);
 
-int pvfs2_flush_inode(struct inode *inode);
+int orangefs_flush_inode(struct inode *inode);
 
-ssize_t pvfs2_inode_getxattr(struct inode *inode,
+ssize_t orangefs_inode_getxattr(struct inode *inode,
 			     const char *prefix,
 			     const char *name,
 			     void *buffer,
 			     size_t size);
 
-int pvfs2_inode_setxattr(struct inode *inode,
+int orangefs_inode_setxattr(struct inode *inode,
 			 const char *prefix,
 			 const char *name,
 			 const void *value,
 			 size_t size,
 			 int flags);
 
-int pvfs2_inode_getattr(struct inode *inode, __u32 mask);
+int orangefs_inode_getattr(struct inode *inode, __u32 mask);
 
-int pvfs2_inode_setattr(struct inode *inode, struct iattr *iattr);
+int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr);
 
-void pvfs2_op_initialize(struct pvfs2_kernel_op_s *op);
+void orangefs_op_initialize(struct orangefs_kernel_op_s *op);
 
-void pvfs2_make_bad_inode(struct inode *inode);
+void orangefs_make_bad_inode(struct inode *inode);
 
 void block_signals(sigset_t *);
 
 void set_signals(sigset_t *);
 
-int pvfs2_unmount_sb(struct super_block *sb);
+int orangefs_unmount_sb(struct super_block *sb);
 
-int pvfs2_cancel_op_in_progress(__u64 tag);
+int orangefs_cancel_op_in_progress(__u64 tag);
 
-static inline __u64 pvfs2_convert_time_field(const struct timespec *ts)
+static inline __u64 orangefs_convert_time_field(const struct timespec *ts)
 {
 	return (__u64)ts-&gt;tv_sec;
 }
 
-int pvfs2_normalize_to_errno(__s32 error_code);
+int orangefs_normalize_to_errno(__s32 error_code);
 
 extern struct mutex devreq_mutex;
 extern struct mutex request_mutex;
 extern int debug;
 extern int op_timeout_secs;
 extern int slot_timeout_secs;
-extern struct list_head pvfs2_superblocks;
-extern spinlock_t pvfs2_superblocks_lock;
-extern struct list_head pvfs2_request_list;
-extern spinlock_t pvfs2_request_list_lock;
-extern wait_queue_head_t pvfs2_request_list_waitq;
+extern struct list_head orangefs_superblocks;
+extern spinlock_t orangefs_superblocks_lock;
+extern struct list_head orangefs_request_list;
+extern spinlock_t orangefs_request_list_lock;
+extern wait_queue_head_t orangefs_request_list_waitq;
 extern struct list_head *htable_ops_in_progress;
 extern spinlock_t htable_ops_in_progress_lock;
 extern int hash_table_size;
 
-extern const struct address_space_operations pvfs2_address_operations;
-extern struct backing_dev_info pvfs2_backing_dev_info;
-extern struct inode_operations pvfs2_file_inode_operations;
-extern const struct file_operations pvfs2_file_operations;
-extern struct inode_operations pvfs2_symlink_inode_operations;
-extern struct inode_operations pvfs2_dir_inode_operations;
-extern const struct file_operations pvfs2_dir_operations;
-extern const struct dentry_operations pvfs2_dentry_operations;
-extern const struct file_operations pvfs2_devreq_file_operations;
+extern const struct address_space_operations orangefs_address_operations;
+extern struct backing_dev_info orangefs_backing_dev_info;
+extern struct inode_operations orangefs_file_inode_operations;
+extern const struct file_operations orangefs_file_operations;
+extern struct inode_operations orangefs_symlink_inode_operations;
+extern struct inode_operations orangefs_dir_inode_operations;
+extern const struct file_operations orangefs_dir_operations;
+extern const struct dentry_operations orangefs_dentry_operations;
+extern const struct file_operations orangefs_devreq_file_operations;
 
-extern wait_queue_head_t pvfs2_bufmap_init_waitq;
+extern wait_queue_head_t orangefs_bufmap_init_waitq;
 
 /*
  * misc convenience macros
  */
 #define add_op_to_request_list(op)				\
 do {								\
-	spin_lock(&amp;pvfs2_request_list_lock);			\
+	spin_lock(&amp;orangefs_request_list_lock);			\
 	spin_lock(&amp;op-&gt;lock);					\
 	set_op_state_waiting(op);				\
-	list_add_tail(&amp;op-&gt;list, &amp;pvfs2_request_list);		\
-	spin_unlock(&amp;pvfs2_request_list_lock);			\
+	list_add_tail(&amp;op-&gt;list, &amp;orangefs_request_list);		\
+	spin_unlock(&amp;orangefs_request_list_lock);			\
 	spin_unlock(&amp;op-&gt;lock);					\
-	wake_up_interruptible(&amp;pvfs2_request_list_waitq);	\
+	wake_up_interruptible(&amp;orangefs_request_list_waitq);	\
 } while (0)
 
 #define add_priority_op_to_request_list(op)				\
 	do {								\
-		spin_lock(&amp;pvfs2_request_list_lock);			\
+		spin_lock(&amp;orangefs_request_list_lock);			\
 		spin_lock(&amp;op-&gt;lock);					\
 		set_op_state_waiting(op);				\
 									\
-		list_add(&amp;op-&gt;list, &amp;pvfs2_request_list);		\
-		spin_unlock(&amp;pvfs2_request_list_lock);			\
+		list_add(&amp;op-&gt;list, &amp;orangefs_request_list);		\
+		spin_unlock(&amp;orangefs_request_list_lock);			\
 		spin_unlock(&amp;op-&gt;lock);					\
-		wake_up_interruptible(&amp;pvfs2_request_list_waitq);	\
+		wake_up_interruptible(&amp;orangefs_request_list_waitq);	\
 } while (0)
 
 #define remove_op_from_request_list(op)					\
 	do {								\
 		struct list_head *tmp = NULL;				\
 		struct list_head *tmp_safe = NULL;			\
-		struct pvfs2_kernel_op_s *tmp_op = NULL;		\
+		struct orangefs_kernel_op_s *tmp_op = NULL;		\
 									\
-		spin_lock(&amp;pvfs2_request_list_lock);			\
-		list_for_each_safe(tmp, tmp_safe, &amp;pvfs2_request_list) { \
+		spin_lock(&amp;orangefs_request_list_lock);			\
+		list_for_each_safe(tmp, tmp_safe, &amp;orangefs_request_list) { \
 			tmp_op = list_entry(tmp,			\
-					    struct pvfs2_kernel_op_s,	\
+					    struct orangefs_kernel_op_s,	\
 					    list);			\
 			if (tmp_op &amp;&amp; (tmp_op == op)) {			\
 				list_del(&amp;tmp_op-&gt;list);		\
 				break;					\
 			}						\
 		}							\
-		spin_unlock(&amp;pvfs2_request_list_lock);			\
+		spin_unlock(&amp;orangefs_request_list_lock);			\
 	} while (0)
 
-#define PVFS2_OP_INTERRUPTIBLE 1   /* service_operation() is interruptible */
-#define PVFS2_OP_PRIORITY      2   /* service_operation() is high priority */
-#define PVFS2_OP_CANCELLATION  4   /* this is a cancellation */
-#define PVFS2_OP_NO_SEMAPHORE  8   /* don't acquire semaphore */
-#define PVFS2_OP_ASYNC         16  /* Queue it, but don't wait */
+#define ORANGEFS_OP_INTERRUPTIBLE 1   /* service_operation() is interruptible */
+#define ORANGEFS_OP_PRIORITY      2   /* service_operation() is high priority */
+#define ORANGEFS_OP_CANCELLATION  4   /* this is a cancellation */
+#define ORANGEFS_OP_NO_SEMAPHORE  8   /* don't acquire semaphore */
+#define ORANGEFS_OP_ASYNC         16  /* Queue it, but don't wait */
 
-int service_operation(struct pvfs2_kernel_op_s *op,
+int service_operation(struct orangefs_kernel_op_s *op,
 		      const char *op_name,
 		      int flags);
 
@@ -719,7 +719,7 @@ int service_operation(struct pvfs2_kernel_op_s *op,
  * sent and have handle_error
  * take care of this situation as well..
  *
- * if a pvfs2 sysint level error occured and i/o has been completed,
+ * if a orangefs sysint level error occured and i/o has been completed,
  * there is no need to cancel the operation, as the user has finished
  * using the bufmap page and so there is no danger in this case.  in
  * this case, we wake up the device normally so that it may free the
@@ -731,77 +731,77 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 #define handle_io_error()					\
 do {								\
 	if (!op_state_serviced(new_op)) {			\
-		pvfs2_cancel_op_in_progress(new_op-&gt;tag);	\
+		orangefs_cancel_op_in_progress(new_op-&gt;tag);	\
 		op_release(new_op);				\
 	} else {						\
 		wake_up_daemon_for_return(new_op);		\
 	}							\
 	new_op = NULL;						\
-	pvfs_bufmap_put(bufmap, buffer_index);				\
+	orangefs_bufmap_put(bufmap, buffer_index);				\
 	buffer_index = -1;					\
 } while (0)
 
 #define get_interruptible_flag(inode) \
-	((PVFS2_SB(inode-&gt;i_sb)-&gt;flags &amp; PVFS2_OPT_INTR) ? \
-		PVFS2_OP_INTERRUPTIBLE : 0)
+	((ORANGEFS_SB(inode-&gt;i_sb)-&gt;flags &amp; ORANGEFS_OPT_INTR) ? \
+		ORANGEFS_OP_INTERRUPTIBLE : 0)
 
-#define add_pvfs2_sb(sb)						\
+#define add_orangefs_sb(sb)						\
 do {									\
 	gossip_debug(GOSSIP_SUPER_DEBUG,				\
-		     "Adding SB %p to pvfs2 superblocks\n",		\
-		     PVFS2_SB(sb));					\
-	spin_lock(&amp;pvfs2_superblocks_lock);				\
-	list_add_tail(&amp;PVFS2_SB(sb)-&gt;list, &amp;pvfs2_superblocks);		\
-	spin_unlock(&amp;pvfs2_superblocks_lock); \
+		     "Adding SB %p to orangefs superblocks\n",		\
+		     ORANGEFS_SB(sb));					\
+	spin_lock(&amp;orangefs_superblocks_lock);				\
+	list_add_tail(&amp;ORANGEFS_SB(sb)-&gt;list, &amp;orangefs_superblocks);		\
+	spin_unlock(&amp;orangefs_superblocks_lock); \
 } while (0)
 
-#define remove_pvfs2_sb(sb)						\
+#define remove_orangefs_sb(sb)						\
 do {									\
 	struct list_head *tmp = NULL;					\
 	struct list_head *tmp_safe = NULL;				\
-	struct pvfs2_sb_info_s *pvfs2_sb = NULL;			\
+	struct orangefs_sb_info_s *orangefs_sb = NULL;			\
 									\
-	spin_lock(&amp;pvfs2_superblocks_lock);				\
-	list_for_each_safe(tmp, tmp_safe, &amp;pvfs2_superblocks) {		\
-		pvfs2_sb = list_entry(tmp,				\
-				      struct pvfs2_sb_info_s,		\
+	spin_lock(&amp;orangefs_superblocks_lock);				\
+	list_for_each_safe(tmp, tmp_safe, &amp;orangefs_superblocks) {		\
+		orangefs_sb = list_entry(tmp,				\
+				      struct orangefs_sb_info_s,		\
 				      list);				\
-		if (pvfs2_sb &amp;&amp; (pvfs2_sb-&gt;sb == sb)) {			\
+		if (orangefs_sb &amp;&amp; (orangefs_sb-&gt;sb == sb)) {			\
 			gossip_debug(GOSSIP_SUPER_DEBUG,		\
-			    "Removing SB %p from pvfs2 superblocks\n",	\
-			pvfs2_sb);					\
-			list_del(&amp;pvfs2_sb-&gt;list);			\
+			    "Removing SB %p from orangefs superblocks\n",	\
+			orangefs_sb);					\
+			list_del(&amp;orangefs_sb-&gt;list);			\
 			break;						\
 		}							\
 	}								\
-	spin_unlock(&amp;pvfs2_superblocks_lock);				\
+	spin_unlock(&amp;orangefs_superblocks_lock);				\
 } while (0)
 
-#define pvfs2_lock_inode(inode) spin_lock(&amp;inode-&gt;i_lock)
-#define pvfs2_unlock_inode(inode) spin_unlock(&amp;inode-&gt;i_lock)
+#define orangefs_lock_inode(inode) spin_lock(&amp;inode-&gt;i_lock)
+#define orangefs_unlock_inode(inode) spin_unlock(&amp;inode-&gt;i_lock)
 
 #define fill_default_sys_attrs(sys_attr, type, mode)			\
 do {									\
 	sys_attr.owner = from_kuid(current_user_ns(), current_fsuid()); \
 	sys_attr.group = from_kgid(current_user_ns(), current_fsgid()); \
 	sys_attr.size = 0;						\
-	sys_attr.perms = PVFS_util_translate_mode(mode);		\
+	sys_attr.perms = ORANGEFS_util_translate_mode(mode);		\
 	sys_attr.objtype = type;					\
-	sys_attr.mask = PVFS_ATTR_SYS_ALL_SETABLE;			\
+	sys_attr.mask = ORANGEFS_ATTR_SYS_ALL_SETABLE;			\
 } while (0)
 
-#define pvfs2_inode_lock(__i)  mutex_lock(&amp;(__i)-&gt;i_mutex)
+#define orangefs_inode_lock(__i)  mutex_lock(&amp;(__i)-&gt;i_mutex)
 
-#define pvfs2_inode_unlock(__i) mutex_unlock(&amp;(__i)-&gt;i_mutex)
+#define orangefs_inode_unlock(__i) mutex_unlock(&amp;(__i)-&gt;i_mutex)
 
-static inline void pvfs2_i_size_write(struct inode *inode, loff_t i_size)
+static inline void orangefs_i_size_write(struct inode *inode, loff_t i_size)
 {
 #if BITS_PER_LONG == 32 &amp;&amp; defined(CONFIG_SMP)
-	pvfs2_inode_lock(inode);
+	ornagefs_inode_lock(inode);
 #endif
 	i_size_write(inode, i_size);
 #if BITS_PER_LONG == 32 &amp;&amp; defined(CONFIG_SMP)
-	pvfs2_inode_unlock(inode);
+	orangefs_inode_unlock(inode);
 #endif
 }
 
@@ -816,4 +816,4 @@ static inline unsigned int diff(struct timeval *end, struct timeval *begin)
 	return (end-&gt;tv_sec * 1000000) + end-&gt;tv_usec;
 }
 
-#endif /* __PVFS2KERNEL_H */
+#endif /* __ORANGEFSKERNEL_H */
diff --git a/fs/orangefs/pvfs2-mod.c b/fs/orangefs/pvfs2-mod.c
index d848c90413d1..d8642908a917 100644
--- a/fs/orangefs/pvfs2-mod.c
+++ b/fs/orangefs/pvfs2-mod.c
@@ -12,9 +12,9 @@
 #include "pvfs2-debugfs.h"
 #include "pvfs2-sysfs.h"
 
-/* PVFS2_VERSION is a ./configure define */
-#ifndef PVFS2_VERSION
-#define PVFS2_VERSION "Unknown"
+/* ORANGEFS_VERSION is a ./configure define */
+#ifndef ORANGEFS_VERSION
+#define ORANGEFS_VERSION "Unknown"
 #endif
 
 /*
@@ -25,9 +25,9 @@
 struct client_debug_mask *cdm_array;
 int cdm_element_count;
 
-char kernel_debug_string[PVFS2_MAX_DEBUG_STRING_LEN] = "none";
-char client_debug_string[PVFS2_MAX_DEBUG_STRING_LEN];
-char client_debug_array_string[PVFS2_MAX_DEBUG_STRING_LEN];
+char kernel_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN] = "none";
+char client_debug_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
+char client_debug_array_string[ORANGEFS_MAX_DEBUG_STRING_LEN];
 
 char *debug_help_string;
 int help_string_initialized;
@@ -36,7 +36,7 @@ struct dentry *client_debug_dentry;
 struct dentry *debug_dir;
 int client_verbose_index;
 int client_all_index;
-struct pvfs2_stats g_pvfs2_stats;
+struct orangefs_stats g_orangefs_stats;
 
 /* the size of the hash tables for ops in progress */
 int hash_table_size = 509;
@@ -45,22 +45,22 @@ static ulong module_parm_debug_mask;
 __u64 gossip_debug_mask;
 struct client_debug_mask client_debug_mask = { NULL, 0, 0 };
 unsigned int kernel_mask_set_mod_init; /* implicitly false */
-int op_timeout_secs = PVFS2_DEFAULT_OP_TIMEOUT_SECS;
-int slot_timeout_secs = PVFS2_DEFAULT_SLOT_TIMEOUT_SECS;
+int op_timeout_secs = ORANGEFS_DEFAULT_OP_TIMEOUT_SECS;
+int slot_timeout_secs = ORANGEFS_DEFAULT_SLOT_TIMEOUT_SECS;
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("PVFS2 Development Team");
-MODULE_DESCRIPTION("The Linux Kernel VFS interface to PVFS2");
-MODULE_PARM_DESC(module_parm_debug_mask, "debugging level (see pvfs2-debug.h for values)");
+MODULE_AUTHOR("ORANGEFS Development Team");
+MODULE_DESCRIPTION("The Linux Kernel VFS interface to ORANGEFS");
+MODULE_PARM_DESC(module_parm_debug_mask, "debugging level (see orangefs-debug.h for values)");
 MODULE_PARM_DESC(op_timeout_secs, "Operation timeout in seconds");
 MODULE_PARM_DESC(slot_timeout_secs, "Slot timeout in seconds");
 MODULE_PARM_DESC(hash_table_size,
 		 "size of hash table for operations in progress");
 
-static struct file_system_type pvfs2_fs_type = {
+static struct file_system_type orangefs_fs_type = {
 	.name = "pvfs2",
-	.mount = pvfs2_mount,
-	.kill_sb = pvfs2_kill_sb,
+	.mount = orangefs_mount,
+	.kill_sb = orangefs_kill_sb,
 	.owner = THIS_MODULE,
 };
 
@@ -85,15 +85,15 @@ struct list_head *htable_ops_in_progress;
 DEFINE_SPINLOCK(htable_ops_in_progress_lock);
 
 /* list for queueing upcall operations */
-LIST_HEAD(pvfs2_request_list);
+LIST_HEAD(orangefs_request_list);
 
-/* used to protect the above pvfs2_request_list */
-DEFINE_SPINLOCK(pvfs2_request_list_lock);
+/* used to protect the above orangefs_request_list */
+DEFINE_SPINLOCK(orangefs_request_list_lock);
 
 /* used for incoming request notification */
-DECLARE_WAIT_QUEUE_HEAD(pvfs2_request_list_waitq);
+DECLARE_WAIT_QUEUE_HEAD(orangefs_request_list_waitq);
 
-static int __init pvfs2_init(void)
+static int __init orangefs_init(void)
 {
 	int ret = -1;
 	__u32 i = 0;
@@ -112,7 +112,7 @@ static int __init pvfs2_init(void)
 
 	/*
 	 * if the mask has a non-zero value, then indicate that the mask
-	 * was set when the kernel module was loaded.  The pvfs2 dev ioctl
+	 * was set when the kernel module was loaded.  The orangefs dev ioctl
 	 * command will look at this boolean to determine if the kernel's
 	 * debug mask should be overwritten when the client-core is started.
 	 */
@@ -120,11 +120,11 @@ static int __init pvfs2_init(void)
 		kernel_mask_set_mod_init = true;
 
 	/* print information message to the system log */
-	pr_info("pvfs2: pvfs2_init called with debug mask: :%s: :%llx:\n",
+	pr_info("orangefs: orangefs_init called with debug mask: :%s: :%llx:\n",
 	       kernel_debug_string,
 	       (unsigned long long)gossip_debug_mask);
 
-	ret = bdi_init(&amp;pvfs2_backing_dev_info);
+	ret = bdi_init(&amp;orangefs_backing_dev_info);
 
 	if (ret)
 		return ret;
@@ -144,7 +144,7 @@ static int __init pvfs2_init(void)
 	if (ret &lt; 0)
 		goto cleanup_op;
 
-	ret = pvfs2_inode_cache_initialize();
+	ret = orangefs_inode_cache_initialize();
 	if (ret &lt; 0)
 		goto cleanup_req;
 
@@ -153,9 +153,9 @@ static int __init pvfs2_init(void)
 		goto cleanup_inode;
 
 	/* Initialize the pvfsdev subsystem. */
-	ret = pvfs2_dev_init();
+	ret = orangefs_dev_init();
 	if (ret &lt; 0) {
-		gossip_err("pvfs2: could not initialize device subsystem %d!\n",
+		gossip_err("orangefs: could not initialize device subsystem %d!\n",
 			   ret);
 		goto cleanup_kiocb;
 	}
@@ -197,17 +197,17 @@ static int __init pvfs2_init(void)
 	if (ret)
 		goto out;
 
-	pvfs2_debugfs_init();
-	pvfs2_kernel_debug_init();
+	orangefs_debugfs_init();
+	orangefs_kernel_debug_init();
 	orangefs_sysfs_init();
 
-	ret = register_filesystem(&amp;pvfs2_fs_type);
+	ret = register_filesystem(&amp;orangefs_fs_type);
 	if (ret == 0) {
-		pr_info("pvfs2: module version %s loaded\n", PVFS2_VERSION);
+		pr_info("orangefs: module version %s loaded\n", ORANGEFS_VERSION);
 		return 0;
 	}
 
-	pvfs2_debugfs_cleanup();
+	orangefs_debugfs_cleanup();
 	orangefs_sysfs_exit();
 	fsid_key_table_finalize();
 
@@ -215,13 +215,13 @@ static int __init pvfs2_init(void)
 	kfree(htable_ops_in_progress);
 
 cleanup_device:
-	pvfs2_dev_cleanup();
+	orangefs_dev_cleanup();
 
 cleanup_kiocb:
 	kiocb_cache_finalize();
 
 cleanup_inode:
-	pvfs2_inode_cache_finalize();
+	orangefs_inode_cache_finalize();
 
 cleanup_req:
 	dev_req_cache_finalize();
@@ -230,29 +230,29 @@ static int __init pvfs2_init(void)
 	op_cache_finalize();
 
 err:
-	bdi_destroy(&amp;pvfs2_backing_dev_info);
+	bdi_destroy(&amp;orangefs_backing_dev_info);
 
 out:
 	return ret;
 }
 
-static void __exit pvfs2_exit(void)
+static void __exit orangefs_exit(void)
 {
 	int i = 0;
-	struct pvfs2_kernel_op_s *cur_op = NULL;
+	struct orangefs_kernel_op_s *cur_op = NULL;
 
-	gossip_debug(GOSSIP_INIT_DEBUG, "pvfs2: pvfs2_exit called\n");
+	gossip_debug(GOSSIP_INIT_DEBUG, "orangefs: orangefs_exit called\n");
 
-	unregister_filesystem(&amp;pvfs2_fs_type);
-	pvfs2_debugfs_cleanup();
+	unregister_filesystem(&amp;orangefs_fs_type);
+	orangefs_debugfs_cleanup();
 	orangefs_sysfs_exit();
 	fsid_key_table_finalize();
-	pvfs2_dev_cleanup();
+	orangefs_dev_cleanup();
 	/* clear out all pending upcall op requests */
-	spin_lock(&amp;pvfs2_request_list_lock);
-	while (!list_empty(&amp;pvfs2_request_list)) {
-		cur_op = list_entry(pvfs2_request_list.next,
-				    struct pvfs2_kernel_op_s,
+	spin_lock(&amp;orangefs_request_list_lock);
+	while (!list_empty(&amp;orangefs_request_list)) {
+		cur_op = list_entry(orangefs_request_list.next,
+				    struct orangefs_kernel_op_s,
 				    list);
 		list_del(&amp;cur_op-&gt;list);
 		gossip_debug(GOSSIP_INIT_DEBUG,
@@ -260,26 +260,26 @@ static void __exit pvfs2_exit(void)
 			     cur_op-&gt;upcall.type);
 		op_release(cur_op);
 	}
-	spin_unlock(&amp;pvfs2_request_list_lock);
+	spin_unlock(&amp;orangefs_request_list_lock);
 
 	for (i = 0; i &lt; hash_table_size; i++)
 		while (!list_empty(&amp;htable_ops_in_progress[i])) {
 			cur_op = list_entry(htable_ops_in_progress[i].next,
-					    struct pvfs2_kernel_op_s,
+					    struct orangefs_kernel_op_s,
 					    list);
 			op_release(cur_op);
 		}
 
 	kiocb_cache_finalize();
-	pvfs2_inode_cache_finalize();
+	orangefs_inode_cache_finalize();
 	dev_req_cache_finalize();
 	op_cache_finalize();
 
 	kfree(htable_ops_in_progress);
 
-	bdi_destroy(&amp;pvfs2_backing_dev_info);
+	bdi_destroy(&amp;orangefs_backing_dev_info);
 
-	pr_info("pvfs2: module version %s unloaded\n", PVFS2_VERSION);
+	pr_info("orangefs: module version %s unloaded\n", ORANGEFS_VERSION);
 }
 
 /*
@@ -291,8 +291,8 @@ void purge_inprogress_ops(void)
 	int i;
 
 	for (i = 0; i &lt; hash_table_size; i++) {
-		struct pvfs2_kernel_op_s *op;
-		struct pvfs2_kernel_op_s *next;
+		struct orangefs_kernel_op_s *op;
+		struct orangefs_kernel_op_s *next;
 
 		list_for_each_entry_safe(op,
 					 next,
@@ -311,5 +311,5 @@ void purge_inprogress_ops(void)
 	}
 }
 
-module_init(pvfs2_init);
-module_exit(pvfs2_exit);
+module_init(orangefs_init);
+module_exit(orangefs_exit);
diff --git a/fs/orangefs/pvfs2-sysfs.c b/fs/orangefs/pvfs2-sysfs.c
index ea635b5e431b..f04de2593c79 100644
--- a/fs/orangefs/pvfs2-sysfs.c
+++ b/fs/orangefs/pvfs2-sysfs.c
@@ -669,13 +669,13 @@ static ssize_t sysfs_int_show(char *kobj_id, char *buf, void *attr)
 			rc = scnprintf(buf,
 				       PAGE_SIZE,
 				       "%lu\n",
-				       g_pvfs2_stats.reads);
+				       g_orangefs_stats.reads);
 			goto out;
 		} else if (!strcmp(stats_orangefs_attr-&gt;attr.name, "writes")) {
 			rc = scnprintf(buf,
 				       PAGE_SIZE,
 				       "%lu\n",
-				       g_pvfs2_stats.writes);
+				       g_orangefs_stats.writes);
 			goto out;
 		} else {
 			goto out;
@@ -752,7 +752,7 @@ static ssize_t int_store(struct orangefs_obj *orangefs_obj,
  */
 static int sysfs_service_op_show(char *kobj_id, char *buf, void *attr)
 {
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int rc = 0;
 	char *ser_op_type = NULL;
 	struct orangefs_attribute *orangefs_attr;
@@ -768,9 +768,9 @@ static int sysfs_service_op_show(char *kobj_id, char *buf, void *attr)
 		     kobj_id);
 
 	if (strcmp(kobj_id, PC_KOBJ_ID))
-		op_alloc_type = PVFS2_VFS_OP_PARAM;
+		op_alloc_type = ORANGEFS_VFS_OP_PARAM;
 	else
-		op_alloc_type = PVFS2_VFS_OP_PERF_COUNT;
+		op_alloc_type = ORANGEFS_VFS_OP_PERF_COUNT;
 
 	new_op = op_alloc(op_alloc_type);
 	if (!new_op) {
@@ -788,113 +788,113 @@ static int sysfs_service_op_show(char *kobj_id, char *buf, void *attr)
 	}
 
 	if (strcmp(kobj_id, PC_KOBJ_ID))
-		new_op-&gt;upcall.req.param.type = PVFS2_PARAM_REQUEST_GET;
+		new_op-&gt;upcall.req.param.type = ORANGEFS_PARAM_REQUEST_GET;
 
 	if (!strcmp(kobj_id, ORANGEFS_KOBJ_ID)) {
 		orangefs_attr = (struct orangefs_attribute *)attr;
 
 		if (!strcmp(orangefs_attr-&gt;attr.name, "perf_history_size"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;
+				ORANGEFS_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;
 		else if (!strcmp(orangefs_attr-&gt;attr.name,
 				 "perf_time_interval_secs"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;
+				ORANGEFS_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;
 		else if (!strcmp(orangefs_attr-&gt;attr.name,
 				 "perf_counter_reset"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_PERF_RESET;
+				ORANGEFS_PARAM_REQUEST_OP_PERF_RESET;
 
 	} else if (!strcmp(kobj_id, ACACHE_KOBJ_ID)) {
 		acache_attr = (struct acache_orangefs_attribute *)attr;
 
 		if (!strcmp(acache_attr-&gt;attr.name, "timeout_msecs"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;
+				ORANGEFS_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;
 
 		if (!strcmp(acache_attr-&gt;attr.name, "hard_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;
 
 		if (!strcmp(acache_attr-&gt;attr.name, "soft_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;
 
 		if (!strcmp(acache_attr-&gt;attr.name, "reclaim_percentage"))
 			new_op-&gt;upcall.req.param.op =
-			  PVFS2_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;
+			  ORANGEFS_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;
 
 	} else if (!strcmp(kobj_id, CAPCACHE_KOBJ_ID)) {
 		capcache_attr = (struct capcache_orangefs_attribute *)attr;
 
 		if (!strcmp(capcache_attr-&gt;attr.name, "timeout_secs"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;
+				ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;
 
 		if (!strcmp(capcache_attr-&gt;attr.name, "hard_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;
 
 		if (!strcmp(capcache_attr-&gt;attr.name, "soft_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;
 
 		if (!strcmp(capcache_attr-&gt;attr.name, "reclaim_percentage"))
 			new_op-&gt;upcall.req.param.op =
-			  PVFS2_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;
+			  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;
 
 	} else if (!strcmp(kobj_id, CCACHE_KOBJ_ID)) {
 		ccache_attr = (struct ccache_orangefs_attribute *)attr;
 
 		if (!strcmp(ccache_attr-&gt;attr.name, "timeout_secs"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;
+				ORANGEFS_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;
 
 		if (!strcmp(ccache_attr-&gt;attr.name, "hard_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;
 
 		if (!strcmp(ccache_attr-&gt;attr.name, "soft_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;
 
 		if (!strcmp(ccache_attr-&gt;attr.name, "reclaim_percentage"))
 			new_op-&gt;upcall.req.param.op =
-			  PVFS2_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;
+			  ORANGEFS_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;
 
 	} else if (!strcmp(kobj_id, NCACHE_KOBJ_ID)) {
 		ncache_attr = (struct ncache_orangefs_attribute *)attr;
 
 		if (!strcmp(ncache_attr-&gt;attr.name, "timeout_msecs"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;
+				ORANGEFS_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;
 
 		if (!strcmp(ncache_attr-&gt;attr.name, "hard_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;
 
 		if (!strcmp(ncache_attr-&gt;attr.name, "soft_limit"))
 			new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;
+				ORANGEFS_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;
 
 		if (!strcmp(ncache_attr-&gt;attr.name, "reclaim_percentage"))
 			new_op-&gt;upcall.req.param.op =
-			  PVFS2_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;
+			  ORANGEFS_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;
 
 	} else if (!strcmp(kobj_id, PC_KOBJ_ID)) {
 		pc_attr = (struct pc_orangefs_attribute *)attr;
 
 		if (!strcmp(pc_attr-&gt;attr.name, ACACHE_KOBJ_ID))
 			new_op-&gt;upcall.req.perf_count.type =
-				PVFS2_PERF_COUNT_REQUEST_ACACHE;
+				ORANGEFS_PERF_COUNT_REQUEST_ACACHE;
 
 		if (!strcmp(pc_attr-&gt;attr.name, CAPCACHE_KOBJ_ID))
 			new_op-&gt;upcall.req.perf_count.type =
-				PVFS2_PERF_COUNT_REQUEST_CAPCACHE;
+				ORANGEFS_PERF_COUNT_REQUEST_CAPCACHE;
 
 		if (!strcmp(pc_attr-&gt;attr.name, NCACHE_KOBJ_ID))
 			new_op-&gt;upcall.req.perf_count.type =
-				PVFS2_PERF_COUNT_REQUEST_NCACHE;
+				ORANGEFS_PERF_COUNT_REQUEST_NCACHE;
 
 	} else {
 		gossip_err("sysfs_service_op_show: unknown kobj_id:%s:\n",
@@ -905,15 +905,15 @@ static int sysfs_service_op_show(char *kobj_id, char *buf, void *attr)
 
 
 	if (strcmp(kobj_id, PC_KOBJ_ID))
-		ser_op_type = "pvfs2_param";
+		ser_op_type = "orangefs_param";
 	else
-		ser_op_type = "pvfs2_perf_count";
+		ser_op_type = "orangefs_perf_count";
 
 	/*
 	 * The service_operation will return an errno return code on
 	 * error, and zero on success.
 	 */
-	rc = service_operation(new_op, ser_op_type, PVFS2_OP_INTERRUPTIBLE);
+	rc = service_operation(new_op, ser_op_type, ORANGEFS_OP_INTERRUPTIBLE);
 
 out:
 	if (!rc) {
@@ -1025,7 +1025,7 @@ static ssize_t
  */
 static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 {
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int val = 0;
 	int rc = 0;
 	struct orangefs_attribute *orangefs_attr;
@@ -1038,7 +1038,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		     "sysfs_service_op_store: id:%s:\n",
 		     kobj_id);
 
-	new_op = op_alloc(PVFS2_VFS_OP_PARAM);
+	new_op = op_alloc(ORANGEFS_VFS_OP_PARAM);
 	if (!new_op) {
 		rc = -ENOMEM;
 		goto out;
@@ -1066,7 +1066,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		if (!strcmp(orangefs_attr-&gt;attr.name, "perf_history_size")) {
 			if (val &gt; 0) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;
+				  ORANGEFS_PARAM_REQUEST_OP_PERF_HISTORY_SIZE;
 			} else {
 				rc = 0;
 				goto out;
@@ -1075,7 +1075,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 				   "perf_time_interval_secs")) {
 			if (val &gt; 0) {
 				new_op-&gt;upcall.req.param.op =
-				PVFS2_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;
+				ORANGEFS_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS;
 			} else {
 				rc = 0;
 				goto out;
@@ -1084,7 +1084,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 				   "perf_counter_reset")) {
 			if ((val == 0) || (val == 1)) {
 				new_op-&gt;upcall.req.param.op =
-					PVFS2_PARAM_REQUEST_OP_PERF_RESET;
+					ORANGEFS_PARAM_REQUEST_OP_PERF_RESET;
 			} else {
 				rc = 0;
 				goto out;
@@ -1097,7 +1097,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		if (!strcmp(acache_attr-&gt;attr.name, "hard_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1105,7 +1105,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(acache_attr-&gt;attr.name, "soft_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1114,7 +1114,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 				   "reclaim_percentage")) {
 			if ((val &gt; -1) &amp;&amp; (val &lt; 101)) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;
+				  ORANGEFS_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE;
 			} else {
 				rc = 0;
 				goto out;
@@ -1122,7 +1122,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(acache_attr-&gt;attr.name, "timeout_msecs")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;
+				  ORANGEFS_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS;
 			} else {
 				rc = 0;
 				goto out;
@@ -1135,7 +1135,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		if (!strcmp(capcache_attr-&gt;attr.name, "hard_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1143,7 +1143,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(capcache_attr-&gt;attr.name, "soft_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1152,7 +1152,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 				   "reclaim_percentage")) {
 			if ((val &gt; -1) &amp;&amp; (val &lt; 101)) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;
+				  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE;
 			} else {
 				rc = 0;
 				goto out;
@@ -1160,7 +1160,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(capcache_attr-&gt;attr.name, "timeout_secs")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;
+				  ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS;
 			} else {
 				rc = 0;
 				goto out;
@@ -1173,7 +1173,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		if (!strcmp(ccache_attr-&gt;attr.name, "hard_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1181,7 +1181,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(ccache_attr-&gt;attr.name, "soft_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1190,7 +1190,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 				   "reclaim_percentage")) {
 			if ((val &gt; -1) &amp;&amp; (val &lt; 101)) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;
+				  ORANGEFS_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE;
 			} else {
 				rc = 0;
 				goto out;
@@ -1198,7 +1198,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(ccache_attr-&gt;attr.name, "timeout_secs")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;
+				  ORANGEFS_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS;
 			} else {
 				rc = 0;
 				goto out;
@@ -1211,7 +1211,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		if (!strcmp(ncache_attr-&gt;attr.name, "hard_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1219,7 +1219,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(ncache_attr-&gt;attr.name, "soft_limit")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;
+				  ORANGEFS_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT;
 			} else {
 				rc = 0;
 				goto out;
@@ -1228,7 +1228,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 				   "reclaim_percentage")) {
 			if ((val &gt; -1) &amp;&amp; (val &lt; 101)) {
 				new_op-&gt;upcall.req.param.op =
-					PVFS2_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;
+					ORANGEFS_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE;
 			} else {
 				rc = 0;
 				goto out;
@@ -1236,7 +1236,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		} else if (!strcmp(ncache_attr-&gt;attr.name, "timeout_msecs")) {
 			if (val &gt; -1) {
 				new_op-&gt;upcall.req.param.op =
-				  PVFS2_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;
+				  ORANGEFS_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS;
 			} else {
 				rc = 0;
 				goto out;
@@ -1250,7 +1250,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 		goto out;
 	}
 
-	new_op-&gt;upcall.req.param.type = PVFS2_PARAM_REQUEST_SET;
+	new_op-&gt;upcall.req.param.type = ORANGEFS_PARAM_REQUEST_SET;
 
 	new_op-&gt;upcall.req.param.value = val;
 
@@ -1258,7 +1258,7 @@ static int sysfs_service_op_store(char *kobj_id, const char *buf, void *attr)
 	 * The service_operation will return a errno return code on
 	 * error, and zero on success.
 	 */
-	rc = service_operation(new_op, "pvfs2_param", PVFS2_OP_INTERRUPTIBLE);
+	rc = service_operation(new_op, "orangefs_param", ORANGEFS_OP_INTERRUPTIBLE);
 
 	if (rc &lt; 0) {
 		gossip_err("sysfs_service_op_store: service op returned:%d:\n",
diff --git a/fs/orangefs/pvfs2-utils.c b/fs/orangefs/pvfs2-utils.c
index 1180a2480d2b..d132c5f712a4 100644
--- a/fs/orangefs/pvfs2-utils.c
+++ b/fs/orangefs/pvfs2-utils.c
@@ -8,67 +8,67 @@
 #include "pvfs2-dev-proto.h"
 #include "pvfs2-bufmap.h"
 
-__s32 fsid_of_op(struct pvfs2_kernel_op_s *op)
+__s32 fsid_of_op(struct orangefs_kernel_op_s *op)
 {
-	__s32 fsid = PVFS_FS_ID_NULL;
+	__s32 fsid = ORANGEFS_FS_ID_NULL;
 
 	if (op) {
 		switch (op-&gt;upcall.type) {
-		case PVFS2_VFS_OP_FILE_IO:
+		case ORANGEFS_VFS_OP_FILE_IO:
 			fsid = op-&gt;upcall.req.io.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_LOOKUP:
+		case ORANGEFS_VFS_OP_LOOKUP:
 			fsid = op-&gt;upcall.req.lookup.parent_refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_CREATE:
+		case ORANGEFS_VFS_OP_CREATE:
 			fsid = op-&gt;upcall.req.create.parent_refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_GETATTR:
+		case ORANGEFS_VFS_OP_GETATTR:
 			fsid = op-&gt;upcall.req.getattr.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_REMOVE:
+		case ORANGEFS_VFS_OP_REMOVE:
 			fsid = op-&gt;upcall.req.remove.parent_refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_MKDIR:
+		case ORANGEFS_VFS_OP_MKDIR:
 			fsid = op-&gt;upcall.req.mkdir.parent_refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_READDIR:
+		case ORANGEFS_VFS_OP_READDIR:
 			fsid = op-&gt;upcall.req.readdir.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_SETATTR:
+		case ORANGEFS_VFS_OP_SETATTR:
 			fsid = op-&gt;upcall.req.setattr.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_SYMLINK:
+		case ORANGEFS_VFS_OP_SYMLINK:
 			fsid = op-&gt;upcall.req.sym.parent_refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_RENAME:
+		case ORANGEFS_VFS_OP_RENAME:
 			fsid = op-&gt;upcall.req.rename.old_parent_refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_STATFS:
+		case ORANGEFS_VFS_OP_STATFS:
 			fsid = op-&gt;upcall.req.statfs.fs_id;
 			break;
-		case PVFS2_VFS_OP_TRUNCATE:
+		case ORANGEFS_VFS_OP_TRUNCATE:
 			fsid = op-&gt;upcall.req.truncate.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_MMAP_RA_FLUSH:
+		case ORANGEFS_VFS_OP_MMAP_RA_FLUSH:
 			fsid = op-&gt;upcall.req.ra_cache_flush.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_FS_UMOUNT:
+		case ORANGEFS_VFS_OP_FS_UMOUNT:
 			fsid = op-&gt;upcall.req.fs_umount.fs_id;
 			break;
-		case PVFS2_VFS_OP_GETXATTR:
+		case ORANGEFS_VFS_OP_GETXATTR:
 			fsid = op-&gt;upcall.req.getxattr.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_SETXATTR:
+		case ORANGEFS_VFS_OP_SETXATTR:
 			fsid = op-&gt;upcall.req.setxattr.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_LISTXATTR:
+		case ORANGEFS_VFS_OP_LISTXATTR:
 			fsid = op-&gt;upcall.req.listxattr.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_REMOVEXATTR:
+		case ORANGEFS_VFS_OP_REMOVEXATTR:
 			fsid = op-&gt;upcall.req.removexattr.refn.fs_id;
 			break;
-		case PVFS2_VFS_OP_FSYNC:
+		case ORANGEFS_VFS_OP_FSYNC:
 			fsid = op-&gt;upcall.req.fsync.refn.fs_id;
 			break;
 		default:
@@ -78,20 +78,20 @@ __s32 fsid_of_op(struct pvfs2_kernel_op_s *op)
 	return fsid;
 }
 
-static void pvfs2_set_inode_flags(struct inode *inode,
-				  struct PVFS_sys_attr_s *attrs)
+static void orangefs_set_inode_flags(struct inode *inode,
+				     struct ORANGEFS_sys_attr_s *attrs)
 {
-	if (attrs-&gt;flags &amp; PVFS_IMMUTABLE_FL)
+	if (attrs-&gt;flags &amp; ORANGEFS_IMMUTABLE_FL)
 		inode-&gt;i_flags |= S_IMMUTABLE;
 	else
 		inode-&gt;i_flags &amp;= ~S_IMMUTABLE;
 
-	if (attrs-&gt;flags &amp; PVFS_APPEND_FL)
+	if (attrs-&gt;flags &amp; ORANGEFS_APPEND_FL)
 		inode-&gt;i_flags |= S_APPEND;
 	else
 		inode-&gt;i_flags &amp;= ~S_APPEND;
 
-	if (attrs-&gt;flags &amp; PVFS_NOATIME_FL)
+	if (attrs-&gt;flags &amp; ORANGEFS_NOATIME_FL)
 		inode-&gt;i_flags |= S_NOATIME;
 	else
 		inode-&gt;i_flags &amp;= ~S_NOATIME;
@@ -100,12 +100,12 @@ static void pvfs2_set_inode_flags(struct inode *inode,
 
 /* NOTE: symname is ignored unless the inode is a sym link */
 static int copy_attributes_to_inode(struct inode *inode,
-				    struct PVFS_sys_attr_s *attrs,
+				    struct ORANGEFS_sys_attr_s *attrs,
 				    char *symname)
 {
 	int ret = -1;
 	int perm_mode = 0;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 	loff_t inode_size = 0;
 	loff_t rounded_up_size = 0;
 
@@ -127,24 +127,24 @@ static int copy_attributes_to_inode(struct inode *inode,
 	gossip_debug(GOSSIP_UTILS_DEBUG,
 		     "attrs-&gt;mask = %x (objtype = %s)\n",
 		     attrs-&gt;mask,
-		     attrs-&gt;objtype == PVFS_TYPE_METAFILE ? "file" :
-		     attrs-&gt;objtype == PVFS_TYPE_DIRECTORY ? "directory" :
-		     attrs-&gt;objtype == PVFS_TYPE_SYMLINK ? "symlink" :
+		     attrs-&gt;objtype == ORANGEFS_TYPE_METAFILE ? "file" :
+		     attrs-&gt;objtype == ORANGEFS_TYPE_DIRECTORY ? "directory" :
+		     attrs-&gt;objtype == ORANGEFS_TYPE_SYMLINK ? "symlink" :
 			"invalid/unknown");
 
 	switch (attrs-&gt;objtype) {
-	case PVFS_TYPE_METAFILE:
-		pvfs2_set_inode_flags(inode, attrs);
-		if (attrs-&gt;mask &amp; PVFS_ATTR_SYS_SIZE) {
+	case ORANGEFS_TYPE_METAFILE:
+		orangefs_set_inode_flags(inode, attrs);
+		if (attrs-&gt;mask &amp; ORANGEFS_ATTR_SYS_SIZE) {
 			inode_size = (loff_t) attrs-&gt;size;
 			rounded_up_size =
 			    (inode_size + (4096 - (inode_size % 4096)));
 
-			pvfs2_lock_inode(inode);
+			orangefs_lock_inode(inode);
 			inode-&gt;i_bytes = inode_size;
 			inode-&gt;i_blocks =
 			    (unsigned long)(rounded_up_size / 512);
-			pvfs2_unlock_inode(inode);
+			orangefs_unlock_inode(inode);
 
 			/*
 			 * NOTE: make sure all the places we're called
@@ -155,7 +155,7 @@ static int copy_attributes_to_inode(struct inode *inode,
 			inode-&gt;i_size = inode_size;
 		}
 		break;
-	case PVFS_TYPE_SYMLINK:
+	case ORANGEFS_TYPE_SYMLINK:
 		if (symname != NULL) {
 			inode-&gt;i_size = (loff_t) strlen(symname);
 			break;
@@ -164,9 +164,9 @@ static int copy_attributes_to_inode(struct inode *inode,
 	default:
 		inode-&gt;i_size = PAGE_CACHE_SIZE;
 
-		pvfs2_lock_inode(inode);
+		orangefs_lock_inode(inode);
 		inode_set_bytes(inode, inode-&gt;i_size);
-		pvfs2_unlock_inode(inode);
+		orangefs_unlock_inode(inode);
 		break;
 	}
 
@@ -179,30 +179,30 @@ static int copy_attributes_to_inode(struct inode *inode,
 	inode-&gt;i_mtime.tv_nsec = 0;
 	inode-&gt;i_ctime.tv_nsec = 0;
 
-	if (attrs-&gt;perms &amp; PVFS_O_EXECUTE)
+	if (attrs-&gt;perms &amp; ORANGEFS_O_EXECUTE)
 		perm_mode |= S_IXOTH;
-	if (attrs-&gt;perms &amp; PVFS_O_WRITE)
+	if (attrs-&gt;perms &amp; ORANGEFS_O_WRITE)
 		perm_mode |= S_IWOTH;
-	if (attrs-&gt;perms &amp; PVFS_O_READ)
+	if (attrs-&gt;perms &amp; ORANGEFS_O_READ)
 		perm_mode |= S_IROTH;
 
-	if (attrs-&gt;perms &amp; PVFS_G_EXECUTE)
+	if (attrs-&gt;perms &amp; ORANGEFS_G_EXECUTE)
 		perm_mode |= S_IXGRP;
-	if (attrs-&gt;perms &amp; PVFS_G_WRITE)
+	if (attrs-&gt;perms &amp; ORANGEFS_G_WRITE)
 		perm_mode |= S_IWGRP;
-	if (attrs-&gt;perms &amp; PVFS_G_READ)
+	if (attrs-&gt;perms &amp; ORANGEFS_G_READ)
 		perm_mode |= S_IRGRP;
 
-	if (attrs-&gt;perms &amp; PVFS_U_EXECUTE)
+	if (attrs-&gt;perms &amp; ORANGEFS_U_EXECUTE)
 		perm_mode |= S_IXUSR;
-	if (attrs-&gt;perms &amp; PVFS_U_WRITE)
+	if (attrs-&gt;perms &amp; ORANGEFS_U_WRITE)
 		perm_mode |= S_IWUSR;
-	if (attrs-&gt;perms &amp; PVFS_U_READ)
+	if (attrs-&gt;perms &amp; ORANGEFS_U_READ)
 		perm_mode |= S_IRUSR;
 
-	if (attrs-&gt;perms &amp; PVFS_G_SGID)
+	if (attrs-&gt;perms &amp; ORANGEFS_G_SGID)
 		perm_mode |= S_ISGID;
-	if (attrs-&gt;perms &amp; PVFS_U_SUID)
+	if (attrs-&gt;perms &amp; ORANGEFS_U_SUID)
 		perm_mode |= S_ISUID;
 
 	inode-&gt;i_mode = perm_mode;
@@ -216,11 +216,11 @@ static int copy_attributes_to_inode(struct inode *inode,
 	}
 
 	switch (attrs-&gt;objtype) {
-	case PVFS_TYPE_METAFILE:
+	case ORANGEFS_TYPE_METAFILE:
 		inode-&gt;i_mode |= S_IFREG;
 		ret = 0;
 		break;
-	case PVFS_TYPE_DIRECTORY:
+	case ORANGEFS_TYPE_DIRECTORY:
 		inode-&gt;i_mode |= S_IFDIR;
 		/* NOTE: we have no good way to keep nlink consistent
 		 * for directories across clients; keep constant at 1.
@@ -230,17 +230,17 @@ static int copy_attributes_to_inode(struct inode *inode,
 		set_nlink(inode, 1);
 		ret = 0;
 		break;
-	case PVFS_TYPE_SYMLINK:
+	case ORANGEFS_TYPE_SYMLINK:
 		inode-&gt;i_mode |= S_IFLNK;
 
 		/* copy link target to inode private data */
-		if (pvfs2_inode &amp;&amp; symname) {
-			strncpy(pvfs2_inode-&gt;link_target,
+		if (orangefs_inode &amp;&amp; symname) {
+			strncpy(orangefs_inode-&gt;link_target,
 				symname,
-				PVFS_NAME_MAX);
+				ORANGEFS_NAME_MAX);
 			gossip_debug(GOSSIP_UTILS_DEBUG,
 				     "Copied attr link target %s\n",
-				     pvfs2_inode-&gt;link_target);
+				     orangefs_inode-&gt;link_target);
 		}
 		gossip_debug(GOSSIP_UTILS_DEBUG,
 			     "symlink mode %o\n",
@@ -248,12 +248,12 @@ static int copy_attributes_to_inode(struct inode *inode,
 		ret = 0;
 		break;
 	default:
-		gossip_err("pvfs2: copy_attributes_to_inode: got invalid attribute type %x\n",
+		gossip_err("orangefs: copy_attributes_to_inode: got invalid attribute type %x\n",
 			attrs-&gt;objtype);
 	}
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "pvfs2: copy_attributes_to_inode: setting i_mode to %o, i_size to %lu\n",
+		     "orangefs: copy_attributes_to_inode: setting i_mode to %o, i_size to %lu\n",
 		     inode-&gt;i_mode,
 		     (unsigned long)i_size_read(inode));
 
@@ -265,7 +265,7 @@ static int copy_attributes_to_inode(struct inode *inode,
  * anything, so don't bother copying it into the sys_attr object here.
  */
 static inline int copy_attributes_from_inode(struct inode *inode,
-					     struct PVFS_sys_attr_s *attrs,
+					     struct ORANGEFS_sys_attr_s *attrs,
 					     struct iattr *iattr)
 {
 	umode_t tmp_mode;
@@ -285,36 +285,36 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 	attrs-&gt;mask = 0;
 	if (iattr-&gt;ia_valid &amp; ATTR_UID) {
 		attrs-&gt;owner = from_kuid(current_user_ns(), iattr-&gt;ia_uid);
-		attrs-&gt;mask |= PVFS_ATTR_SYS_UID;
+		attrs-&gt;mask |= ORANGEFS_ATTR_SYS_UID;
 		gossip_debug(GOSSIP_UTILS_DEBUG, "(UID) %d\n", attrs-&gt;owner);
 	}
 	if (iattr-&gt;ia_valid &amp; ATTR_GID) {
 		attrs-&gt;group = from_kgid(current_user_ns(), iattr-&gt;ia_gid);
-		attrs-&gt;mask |= PVFS_ATTR_SYS_GID;
+		attrs-&gt;mask |= ORANGEFS_ATTR_SYS_GID;
 		gossip_debug(GOSSIP_UTILS_DEBUG, "(GID) %d\n", attrs-&gt;group);
 	}
 
 	if (iattr-&gt;ia_valid &amp; ATTR_ATIME) {
-		attrs-&gt;mask |= PVFS_ATTR_SYS_ATIME;
+		attrs-&gt;mask |= ORANGEFS_ATTR_SYS_ATIME;
 		if (iattr-&gt;ia_valid &amp; ATTR_ATIME_SET) {
 			attrs-&gt;atime =
-			    pvfs2_convert_time_field(&amp;iattr-&gt;ia_atime);
-			attrs-&gt;mask |= PVFS_ATTR_SYS_ATIME_SET;
+			    orangefs_convert_time_field(&amp;iattr-&gt;ia_atime);
+			attrs-&gt;mask |= ORANGEFS_ATTR_SYS_ATIME_SET;
 		}
 	}
 	if (iattr-&gt;ia_valid &amp; ATTR_MTIME) {
-		attrs-&gt;mask |= PVFS_ATTR_SYS_MTIME;
+		attrs-&gt;mask |= ORANGEFS_ATTR_SYS_MTIME;
 		if (iattr-&gt;ia_valid &amp; ATTR_MTIME_SET) {
 			attrs-&gt;mtime =
-			    pvfs2_convert_time_field(&amp;iattr-&gt;ia_mtime);
-			attrs-&gt;mask |= PVFS_ATTR_SYS_MTIME_SET;
+			    orangefs_convert_time_field(&amp;iattr-&gt;ia_mtime);
+			attrs-&gt;mask |= ORANGEFS_ATTR_SYS_MTIME_SET;
 		}
 	}
 	if (iattr-&gt;ia_valid &amp; ATTR_CTIME)
-		attrs-&gt;mask |= PVFS_ATTR_SYS_CTIME;
+		attrs-&gt;mask |= ORANGEFS_ATTR_SYS_CTIME;
 
 	/*
-	 * PVFS2 cannot set size with a setattr operation.  Probably not likely
+	 * ORANGEFS cannot set size with a setattr operation.  Probably not likely
 	 * to be requested through the VFS, but just in case, don't worry about
 	 * ATTR_SIZE
 	 */
@@ -342,21 +342,21 @@ static inline int copy_attributes_from_inode(struct inode *inode,
 			return -EINVAL;
 		}
 
-		attrs-&gt;perms = PVFS_util_translate_mode(tmp_mode);
-		attrs-&gt;mask |= PVFS_ATTR_SYS_PERM;
+		attrs-&gt;perms = ORANGEFS_util_translate_mode(tmp_mode);
+		attrs-&gt;mask |= ORANGEFS_ATTR_SYS_PERM;
 	}
 
 	return 0;
 }
 
 /*
- * issues a pvfs2 getattr request and fills in the appropriate inode
+ * issues a orangefs getattr request and fills in the appropriate inode
  * attributes if successful.  returns 0 on success; -errno otherwise
  */
-int pvfs2_inode_getattr(struct inode *inode, __u32 getattr_mask)
+int orangefs_inode_getattr(struct inode *inode, __u32 getattr_mask)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
 	int ret = -EINVAL;
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
@@ -364,10 +364,10 @@ int pvfs2_inode_getattr(struct inode *inode, __u32 getattr_mask)
 		     __func__,
 		     get_khandle_from_ino(inode));
 
-	new_op = op_alloc(PVFS2_VFS_OP_GETATTR);
+	new_op = op_alloc(ORANGEFS_VFS_OP_GETATTR);
 	if (!new_op)
 		return -ENOMEM;
-	new_op-&gt;upcall.req.getattr.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.getattr.refn = orangefs_inode-&gt;refn;
 	new_op-&gt;upcall.req.getattr.mask = getattr_mask;
 
 	ret = service_operation(new_op, __func__,
@@ -384,17 +384,17 @@ int pvfs2_inode_getattr(struct inode *inode, __u32 getattr_mask)
 	}
 
 	/*
-	 * Store blksize in pvfs2 specific part of inode structure; we are
+	 * Store blksize in orangefs specific part of inode structure; we are
 	 * only going to use this to report to stat to make sure it doesn't
 	 * perturb any inode related code paths.
 	 */
 	if (new_op-&gt;downcall.resp.getattr.attributes.objtype ==
-			PVFS_TYPE_METAFILE) {
-		pvfs2_inode-&gt;blksize =
+			ORANGEFS_TYPE_METAFILE) {
+		orangefs_inode-&gt;blksize =
 			new_op-&gt;downcall.resp.getattr.attributes.blksize;
 	} else {
 		/* mimic behavior of generic_fillattr() for other types. */
-		pvfs2_inode-&gt;blksize = (1 &lt;&lt; inode-&gt;i_blkbits);
+		orangefs_inode-&gt;blksize = (1 &lt;&lt; inode-&gt;i_blkbits);
 
 	}
 
@@ -402,8 +402,8 @@ int pvfs2_inode_getattr(struct inode *inode, __u32 getattr_mask)
 	gossip_debug(GOSSIP_UTILS_DEBUG,
 		     "Getattr on handle %pU, "
 		     "fsid %d\n  (inode ct = %d) returned %d\n",
-		     &amp;pvfs2_inode-&gt;refn.khandle,
-		     pvfs2_inode-&gt;refn.fs_id,
+		     &amp;orangefs_inode-&gt;refn.khandle,
+		     orangefs_inode-&gt;refn.fs_id,
 		     (int)atomic_read(&amp;inode-&gt;i_count),
 		     ret);
 
@@ -412,20 +412,20 @@ int pvfs2_inode_getattr(struct inode *inode, __u32 getattr_mask)
 }
 
 /*
- * issues a pvfs2 setattr request to make sure the new attribute values
+ * issues a orangefs setattr request to make sure the new attribute values
  * take effect if successful.  returns 0 on success; -errno otherwise
  */
-int pvfs2_inode_setattr(struct inode *inode, struct iattr *iattr)
+int orangefs_inode_setattr(struct inode *inode, struct iattr *iattr)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
 	int ret;
 
-	new_op = op_alloc(PVFS2_VFS_OP_SETATTR);
+	new_op = op_alloc(ORANGEFS_VFS_OP_SETATTR);
 	if (!new_op)
 		return -ENOMEM;
 
-	new_op-&gt;upcall.req.setattr.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.setattr.refn = orangefs_inode-&gt;refn;
 	ret = copy_attributes_from_inode(inode,
 		       &amp;new_op-&gt;upcall.req.setattr.attributes,
 		       iattr);
@@ -438,7 +438,7 @@ int pvfs2_inode_setattr(struct inode *inode, struct iattr *iattr)
 				get_interruptible_flag(inode));
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "pvfs2_inode_setattr: returning %d\n",
+		     "orangefs_inode_setattr: returning %d\n",
 		     ret);
 
 	/* when request is serviced properly, free req op struct */
@@ -449,16 +449,16 @@ int pvfs2_inode_setattr(struct inode *inode, struct iattr *iattr)
 	 * ctime flags.
 	 */
 	if (ret == 0) {
-		ClearAtimeFlag(pvfs2_inode);
-		ClearMtimeFlag(pvfs2_inode);
-		ClearCtimeFlag(pvfs2_inode);
-		ClearModeFlag(pvfs2_inode);
+		ClearAtimeFlag(orangefs_inode);
+		ClearMtimeFlag(orangefs_inode);
+		ClearCtimeFlag(orangefs_inode);
+		ClearModeFlag(orangefs_inode);
 	}
 
 	return ret;
 }
 
-int pvfs2_flush_inode(struct inode *inode)
+int orangefs_flush_inode(struct inode *inode)
 {
 	/*
 	 * If it is a dirty inode, this function gets called.
@@ -472,7 +472,7 @@ int pvfs2_flush_inode(struct inode *inode)
 	int ctime_flag;
 	int atime_flag;
 	int mode_flag;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 
 	memset(&amp;wbattr, 0, sizeof(wbattr));
 
@@ -481,14 +481,14 @@ int pvfs2_flush_inode(struct inode *inode)
 	 * will prevent multiple processes from all trying to flush the same
 	 * inode if they call close() simultaneously
 	 */
-	mtime_flag = MtimeFlag(pvfs2_inode);
-	ClearMtimeFlag(pvfs2_inode);
-	ctime_flag = CtimeFlag(pvfs2_inode);
-	ClearCtimeFlag(pvfs2_inode);
-	atime_flag = AtimeFlag(pvfs2_inode);
-	ClearAtimeFlag(pvfs2_inode);
-	mode_flag = ModeFlag(pvfs2_inode);
-	ClearModeFlag(pvfs2_inode);
+	mtime_flag = MtimeFlag(orangefs_inode);
+	ClearMtimeFlag(orangefs_inode);
+	ctime_flag = CtimeFlag(orangefs_inode);
+	ClearCtimeFlag(orangefs_inode);
+	atime_flag = AtimeFlag(orangefs_inode);
+	ClearAtimeFlag(orangefs_inode);
+	mode_flag = ModeFlag(orangefs_inode);
+	ClearModeFlag(orangefs_inode);
 
 	/*  -- Lazy atime,mtime and ctime update --
 	 * Note: all times are dictated by server in the new scheme
@@ -510,56 +510,56 @@ int pvfs2_flush_inode(struct inode *inode)
 	}
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "*********** pvfs2_flush_inode: %pU "
+		     "*********** orangefs_flush_inode: %pU "
 		     "(ia_valid %d)\n",
 		     get_khandle_from_ino(inode),
 		     wbattr.ia_valid);
 	if (wbattr.ia_valid == 0) {
 		gossip_debug(GOSSIP_UTILS_DEBUG,
-			     "pvfs2_flush_inode skipping setattr()\n");
+			     "orangefs_flush_inode skipping setattr()\n");
 		return 0;
 	}
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "pvfs2_flush_inode (%pU) writing mode %o\n",
+		     "orangefs_flush_inode (%pU) writing mode %o\n",
 		     get_khandle_from_ino(inode),
 		     inode-&gt;i_mode);
 
-	ret = pvfs2_inode_setattr(inode, &amp;wbattr);
+	ret = orangefs_inode_setattr(inode, &amp;wbattr);
 
 	return ret;
 }
 
-int pvfs2_unmount_sb(struct super_block *sb)
+int orangefs_unmount_sb(struct super_block *sb)
 {
 	int ret = -EINVAL;
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "pvfs2_unmount_sb called on sb %p\n",
+		     "orangefs_unmount_sb called on sb %p\n",
 		     sb);
 
-	new_op = op_alloc(PVFS2_VFS_OP_FS_UMOUNT);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FS_UMOUNT);
 	if (!new_op)
 		return -ENOMEM;
-	new_op-&gt;upcall.req.fs_umount.id = PVFS2_SB(sb)-&gt;id;
-	new_op-&gt;upcall.req.fs_umount.fs_id = PVFS2_SB(sb)-&gt;fs_id;
-	strncpy(new_op-&gt;upcall.req.fs_umount.pvfs2_config_server,
-		PVFS2_SB(sb)-&gt;devname,
-		PVFS_MAX_SERVER_ADDR_LEN);
+	new_op-&gt;upcall.req.fs_umount.id = ORANGEFS_SB(sb)-&gt;id;
+	new_op-&gt;upcall.req.fs_umount.fs_id = ORANGEFS_SB(sb)-&gt;fs_id;
+	strncpy(new_op-&gt;upcall.req.fs_umount.orangefs_config_server,
+		ORANGEFS_SB(sb)-&gt;devname,
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "Attempting PVFS2 Unmount via host %s\n",
-		     new_op-&gt;upcall.req.fs_umount.pvfs2_config_server);
+		     "Attempting ORANGEFS Unmount via host %s\n",
+		     new_op-&gt;upcall.req.fs_umount.orangefs_config_server);
 
-	ret = service_operation(new_op, "pvfs2_fs_umount", 0);
+	ret = service_operation(new_op, "orangefs_fs_umount", 0);
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "pvfs2_unmount: got return value of %d\n", ret);
+		     "orangefs_unmount: got return value of %d\n", ret);
 	if (ret)
 		sb = ERR_PTR(ret);
 	else
-		PVFS2_SB(sb)-&gt;mount_pending = 1;
+		ORANGEFS_SB(sb)-&gt;mount_pending = 1;
 
 	op_release(new_op);
 	return ret;
@@ -569,42 +569,42 @@ int pvfs2_unmount_sb(struct super_block *sb)
  * NOTE: on successful cancellation, be sure to return -EINTR, as
  * that's the return value the caller expects
  */
-int pvfs2_cancel_op_in_progress(__u64 tag)
+int orangefs_cancel_op_in_progress(__u64 tag)
 {
 	int ret = -EINVAL;
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "pvfs2_cancel_op_in_progress called on tag %llu\n",
+		     "orangefs_cancel_op_in_progress called on tag %llu\n",
 		     llu(tag));
 
-	new_op = op_alloc(PVFS2_VFS_OP_CANCEL);
+	new_op = op_alloc(ORANGEFS_VFS_OP_CANCEL);
 	if (!new_op)
 		return -ENOMEM;
 	new_op-&gt;upcall.req.cancel.op_tag = tag;
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "Attempting PVFS2 operation cancellation of tag %llu\n",
+		     "Attempting ORANGEFS operation cancellation of tag %llu\n",
 		     llu(new_op-&gt;upcall.req.cancel.op_tag));
 
-	ret = service_operation(new_op, "pvfs2_cancel", PVFS2_OP_CANCELLATION);
+	ret = service_operation(new_op, "orangefs_cancel", ORANGEFS_OP_CANCELLATION);
 
 	gossip_debug(GOSSIP_UTILS_DEBUG,
-		     "pvfs2_cancel_op_in_progress: got return value of %d\n",
+		     "orangefs_cancel_op_in_progress: got return value of %d\n",
 		     ret);
 
 	op_release(new_op);
 	return ret;
 }
 
-void pvfs2_op_initialize(struct pvfs2_kernel_op_s *op)
+void orangefs_op_initialize(struct orangefs_kernel_op_s *op)
 {
 	if (op) {
 		spin_lock(&amp;op-&gt;lock);
 		op-&gt;io_completed = 0;
 
-		op-&gt;upcall.type = PVFS2_VFS_OP_INVALID;
-		op-&gt;downcall.type = PVFS2_VFS_OP_INVALID;
+		op-&gt;upcall.type = ORANGEFS_VFS_OP_INVALID;
+		op-&gt;downcall.type = ORANGEFS_VFS_OP_INVALID;
 		op-&gt;downcall.status = -1;
 
 		op-&gt;op_state = OP_VFS_STATE_UNKNOWN;
@@ -613,7 +613,7 @@ void pvfs2_op_initialize(struct pvfs2_kernel_op_s *op)
 	}
 }
 
-void pvfs2_make_bad_inode(struct inode *inode)
+void orangefs_make_bad_inode(struct inode *inode)
 {
 	if (is_root_handle(inode)) {
 		/*
@@ -655,10 +655,10 @@ void set_signals(sigset_t *sigset)
 
 /*
  * The following is a very dirty hack that is now a permanent part of the
- * PVFS2 protocol. See protocol.h for more error definitions.
+ * ORANGEFS protocol. See protocol.h for more error definitions.
  */
 
-/* The order matches include/pvfs2-types.h in the OrangeFS source. */
+/* The order matches include/orangefs-types.h in the OrangeFS source. */
 static int PINT_errno_mapping[] = {
 	0, EPERM, ENOENT, EINTR, EIO, ENXIO, EBADF, EAGAIN, ENOMEM,
 	EFAULT, EBUSY, EEXIST, ENODEV, ENOTDIR, EISDIR, EINVAL, EMFILE,
@@ -672,7 +672,7 @@ static int PINT_errno_mapping[] = {
 	EACCES, ECONNRESET, ERANGE
 };
 
-int pvfs2_normalize_to_errno(__s32 error_code)
+int orangefs_normalize_to_errno(__s32 error_code)
 {
 	__u32 i;
 
@@ -684,24 +684,24 @@ int pvfs2_normalize_to_errno(__s32 error_code)
 	 * server.
 	 */
 	} else if (error_code &gt; 0) {
-		gossip_err("pvfs2: error status receieved.\n");
-		gossip_err("pvfs2: assuming error code is inverted.\n");
+		gossip_err("orangefs: error status receieved.\n");
+		gossip_err("orangefs: assuming error code is inverted.\n");
 		error_code = -error_code;
 	}
 
 	/*
-	 * XXX: This is very bad since error codes from PVFS2 may not be
+	 * XXX: This is very bad since error codes from ORANGEFS may not be
 	 * suitable for return into userspace.
 	 */
 
 	/*
-	 * Convert PVFS2 error values into errno values suitable for return
+	 * Convert ORANGEFS error values into errno values suitable for return
 	 * from the kernel.
 	 */
-	if ((-error_code) &amp; PVFS_NON_ERRNO_ERROR_BIT) {
+	if ((-error_code) &amp; ORANGEFS_NON_ERRNO_ERROR_BIT) {
 		if (((-error_code) &amp;
-		    (PVFS_ERROR_NUMBER_BITS|PVFS_NON_ERRNO_ERROR_BIT|
-		    PVFS_ERROR_BIT)) == PVFS_ECANCEL) {
+		    (ORANGEFS_ERROR_NUMBER_BITS|ORANGEFS_NON_ERRNO_ERROR_BIT|
+		    ORANGEFS_ERROR_BIT)) == ORANGEFS_ECANCEL) {
 			/*
 			 * cancellation error codes generally correspond to
 			 * a timeout from the client's perspective
@@ -709,30 +709,30 @@ int pvfs2_normalize_to_errno(__s32 error_code)
 			error_code = -ETIMEDOUT;
 		} else {
 			/* assume a default error code */
-			gossip_err("pvfs2: warning: got error code without errno equivalent: %d.\n", error_code);
+			gossip_err("orangefs: warning: got error code without errno equivalent: %d.\n", error_code);
 			error_code = -EINVAL;
 		}
 
-	/* Convert PVFS2 encoded errno values into regular errno values. */
-	} else if ((-error_code) &amp; PVFS_ERROR_BIT) {
-		i = (-error_code) &amp; ~(PVFS_ERROR_BIT|PVFS_ERROR_CLASS_BITS);
+	/* Convert ORANGEFS encoded errno values into regular errno values. */
+	} else if ((-error_code) &amp; ORANGEFS_ERROR_BIT) {
+		i = (-error_code) &amp; ~(ORANGEFS_ERROR_BIT|ORANGEFS_ERROR_CLASS_BITS);
 		if (i &lt; sizeof(PINT_errno_mapping)/sizeof(*PINT_errno_mapping))
 			error_code = -PINT_errno_mapping[i];
 		else
 			error_code = -EINVAL;
 
 	/*
-	 * Only PVFS2 protocol error codes should ever come here. Otherwise
+	 * Only ORANGEFS protocol error codes should ever come here. Otherwise
 	 * there is a bug somewhere.
 	 */
 	} else {
-		gossip_err("pvfs2: pvfs2_normalize_to_errno: got error code which is not from PVFS2.\n");
+		gossip_err("orangefs: orangefs_normalize_to_errno: got error code which is not from ORANGEFS.\n");
 	}
 	return error_code;
 }
 
 #define NUM_MODES 11
-__s32 PVFS_util_translate_mode(int mode)
+__s32 ORANGEFS_util_translate_mode(int mode)
 {
 	int ret = 0;
 	int i = 0;
@@ -742,16 +742,16 @@ __s32 PVFS_util_translate_mode(int mode)
 		S_IXUSR, S_IWUSR, S_IRUSR,
 		S_ISGID, S_ISUID
 	};
-	static int pvfs2_modes[NUM_MODES] = {
-		PVFS_O_EXECUTE, PVFS_O_WRITE, PVFS_O_READ,
-		PVFS_G_EXECUTE, PVFS_G_WRITE, PVFS_G_READ,
-		PVFS_U_EXECUTE, PVFS_U_WRITE, PVFS_U_READ,
-		PVFS_G_SGID, PVFS_U_SUID
+	static int orangefs_modes[NUM_MODES] = {
+		ORANGEFS_O_EXECUTE, ORANGEFS_O_WRITE, ORANGEFS_O_READ,
+		ORANGEFS_G_EXECUTE, ORANGEFS_G_WRITE, ORANGEFS_G_READ,
+		ORANGEFS_U_EXECUTE, ORANGEFS_U_WRITE, ORANGEFS_U_READ,
+		ORANGEFS_G_SGID, ORANGEFS_U_SUID
 	};
 
 	for (i = 0; i &lt; NUM_MODES; i++)
 		if (mode &amp; modes[i])
-			ret |= pvfs2_modes[i];
+			ret |= orangefs_modes[i];
 
 	return ret;
 }
@@ -813,10 +813,10 @@ int orangefs_prepare_cdm_array(char *debug_array_string)
 		       (unsigned long long *)&amp;(cdm_array[i].mask1),
 		       (unsigned long long *)&amp;(cdm_array[i].mask2));
 
-		if (!strcmp(cdm_array[i].keyword, PVFS2_VERBOSE))
+		if (!strcmp(cdm_array[i].keyword, ORANGEFS_VERBOSE))
 			client_verbose_index = i;
 
-		if (!strcmp(cdm_array[i].keyword, PVFS2_ALL))
+		if (!strcmp(cdm_array[i].keyword, ORANGEFS_ALL))
 			client_all_index = i;
 
 		cds_head = cds_delimiter + 1;
@@ -952,7 +952,7 @@ void debug_mask_to_string(void *mask, int type)
 		element_count = num_kmod_keyword_mask_map;
 	}
 
-	memset(debug_string, 0, PVFS2_MAX_DEBUG_STRING_LEN);
+	memset(debug_string, 0, ORANGEFS_MAX_DEBUG_STRING_LEN);
 
 	/*
 	 * Some keywords, like "all" or "verbose", are amalgams of
@@ -998,13 +998,13 @@ void do_k_string(void *k_mask, int index)
 	if (*mask &amp; s_kmod_keyword_mask_map[index].mask_val) {
 		if ((strlen(kernel_debug_string) +
 		     strlen(s_kmod_keyword_mask_map[index].keyword))
-			&lt; PVFS2_MAX_DEBUG_STRING_LEN - 1) {
+			&lt; ORANGEFS_MAX_DEBUG_STRING_LEN - 1) {
 				strcat(kernel_debug_string,
 				       s_kmod_keyword_mask_map[index].keyword);
 				strcat(kernel_debug_string, ",");
 			} else {
 				gossip_err("%s: overflow!\n", __func__);
-				strcpy(kernel_debug_string, PVFS2_ALL);
+				strcpy(kernel_debug_string, ORANGEFS_ALL);
 				goto out;
 			}
 	}
@@ -1025,13 +1025,13 @@ void do_c_string(void *c_mask, int index)
 	    (mask-&gt;mask2 &amp; cdm_array[index].mask2)) {
 		if ((strlen(client_debug_string) +
 		     strlen(cdm_array[index].keyword) + 1)
-			&lt; PVFS2_MAX_DEBUG_STRING_LEN - 2) {
+			&lt; ORANGEFS_MAX_DEBUG_STRING_LEN - 2) {
 				strcat(client_debug_string,
 				       cdm_array[index].keyword);
 				strcat(client_debug_string, ",");
 			} else {
 				gossip_err("%s: overflow!\n", __func__);
-				strcpy(client_debug_string, PVFS2_ALL);
+				strcpy(client_debug_string, ORANGEFS_ALL);
 				goto out;
 			}
 	}
@@ -1043,7 +1043,7 @@ int keyword_is_amalgam(char *keyword)
 {
 	int rc = 0;
 
-	if ((!strcmp(keyword, PVFS2_ALL)) || (!strcmp(keyword, PVFS2_VERBOSE)))
+	if ((!strcmp(keyword, ORANGEFS_ALL)) || (!strcmp(keyword, ORANGEFS_VERBOSE)))
 		rc = 1;
 
 	return rc;
@@ -1067,14 +1067,14 @@ int check_amalgam_keyword(void *mask, int type)
 
 		if ((c_mask-&gt;mask1 == cdm_array[client_all_index].mask1) &amp;&amp;
 		    (c_mask-&gt;mask2 == cdm_array[client_all_index].mask2)) {
-			strcpy(client_debug_string, PVFS2_ALL);
+			strcpy(client_debug_string, ORANGEFS_ALL);
 			rc = 1;
 			goto out;
 		}
 
 		if ((c_mask-&gt;mask1 == cdm_array[client_verbose_index].mask1) &amp;&amp;
 		    (c_mask-&gt;mask2 == cdm_array[client_verbose_index].mask2)) {
-			strcpy(client_debug_string, PVFS2_VERBOSE);
+			strcpy(client_debug_string, ORANGEFS_VERBOSE);
 			rc = 1;
 			goto out;
 		}
@@ -1083,7 +1083,7 @@ int check_amalgam_keyword(void *mask, int type)
 		k_mask = (__u64 *) mask;
 
 		if (*k_mask &gt;= s_kmod_keyword_mask_map[k_all_index].mask_val) {
-			strcpy(kernel_debug_string, PVFS2_ALL);
+			strcpy(kernel_debug_string, ORANGEFS_ALL);
 			rc = 1;
 			goto out;
 		}
diff --git a/fs/orangefs/super.c b/fs/orangefs/super.c
index 45db0772a767..c104de1ae5de 100644
--- a/fs/orangefs/super.c
+++ b/fs/orangefs/super.c
@@ -10,13 +10,13 @@
 
 #include &lt;linux/parser.h&gt;
 
-/* a cache for pvfs2-inode objects (i.e. pvfs2 inode private data) */
-static struct kmem_cache *pvfs2_inode_cache;
+/* a cache for orangefs-inode objects (i.e. orangefs inode private data) */
+static struct kmem_cache *orangefs_inode_cache;
 
-/* list for storing pvfs2 specific superblocks in use */
-LIST_HEAD(pvfs2_superblocks);
+/* list for storing orangefs specific superblocks in use */
+LIST_HEAD(orangefs_superblocks);
 
-DEFINE_SPINLOCK(pvfs2_superblocks_lock);
+DEFINE_SPINLOCK(orangefs_superblocks_lock);
 
 enum {
 	Opt_intr,
@@ -37,7 +37,7 @@ static const match_table_t tokens = {
 static int parse_mount_options(struct super_block *sb, char *options,
 		int silent)
 {
-	struct pvfs2_sb_info_s *pvfs2_sb = PVFS2_SB(sb);
+	struct orangefs_sb_info_s *orangefs_sb = ORANGEFS_SB(sb);
 	substring_t args[MAX_OPT_ARGS];
 	char *p;
 
@@ -46,8 +46,8 @@ static int parse_mount_options(struct super_block *sb, char *options,
 	 * to zero, ie, initialize to unset.
 	 */
 	sb-&gt;s_flags &amp;= ~MS_POSIXACL;
-	pvfs2_sb-&gt;flags &amp;= ~PVFS2_OPT_INTR;
-	pvfs2_sb-&gt;flags &amp;= ~PVFS2_OPT_LOCAL_LOCK;
+	orangefs_sb-&gt;flags &amp;= ~ORANGEFS_OPT_INTR;
+	orangefs_sb-&gt;flags &amp;= ~ORANGEFS_OPT_LOCAL_LOCK;
 
 	while ((p = strsep(&amp;options, ",")) != NULL) {
 		int token;
@@ -61,10 +61,10 @@ static int parse_mount_options(struct super_block *sb, char *options,
 			sb-&gt;s_flags |= MS_POSIXACL;
 			break;
 		case Opt_intr:
-			pvfs2_sb-&gt;flags |= PVFS2_OPT_INTR;
+			orangefs_sb-&gt;flags |= ORANGEFS_OPT_INTR;
 			break;
 		case Opt_local_lock:
-			pvfs2_sb-&gt;flags |= PVFS2_OPT_LOCAL_LOCK;
+			orangefs_sb-&gt;flags |= ORANGEFS_OPT_LOCAL_LOCK;
 			break;
 		default:
 			goto fail;
@@ -78,24 +78,24 @@ static int parse_mount_options(struct super_block *sb, char *options,
 	return -EINVAL;
 }
 
-static void pvfs2_inode_cache_ctor(void *req)
+static void orangefs_inode_cache_ctor(void *req)
 {
-	struct pvfs2_inode_s *pvfs2_inode = req;
+	struct orangefs_inode_s *orangefs_inode = req;
 
-	inode_init_once(&amp;pvfs2_inode-&gt;vfs_inode);
-	init_rwsem(&amp;pvfs2_inode-&gt;xattr_sem);
+	inode_init_once(&amp;orangefs_inode-&gt;vfs_inode);
+	init_rwsem(&amp;orangefs_inode-&gt;xattr_sem);
 
-	pvfs2_inode-&gt;vfs_inode.i_version = 1;
+	orangefs_inode-&gt;vfs_inode.i_version = 1;
 }
 
-static struct inode *pvfs2_alloc_inode(struct super_block *sb)
+static struct inode *orangefs_alloc_inode(struct super_block *sb)
 {
-	struct pvfs2_inode_s *pvfs2_inode;
+	struct orangefs_inode_s *orangefs_inode;
 
-	pvfs2_inode = kmem_cache_alloc(pvfs2_inode_cache,
-				       PVFS2_CACHE_ALLOC_FLAGS);
-	if (pvfs2_inode == NULL) {
-		gossip_err("Failed to allocate pvfs2_inode\n");
+	orangefs_inode = kmem_cache_alloc(orangefs_inode_cache,
+				       ORANGEFS_CACHE_ALLOC_FLAGS);
+	if (orangefs_inode == NULL) {
+		gossip_err("Failed to allocate orangefs_inode\n");
 		return NULL;
 	}
 
@@ -103,71 +103,71 @@ static struct inode *pvfs2_alloc_inode(struct super_block *sb)
 	 * We want to clear everything except for rw_semaphore and the
 	 * vfs_inode.
 	 */
-	memset(&amp;pvfs2_inode-&gt;refn.khandle, 0, 16);
-	pvfs2_inode-&gt;refn.fs_id = PVFS_FS_ID_NULL;
-	pvfs2_inode-&gt;last_failed_block_index_read = 0;
-	memset(pvfs2_inode-&gt;link_target, 0, sizeof(pvfs2_inode-&gt;link_target));
-	pvfs2_inode-&gt;pinode_flags = 0;
+	memset(&amp;orangefs_inode-&gt;refn.khandle, 0, 16);
+	orangefs_inode-&gt;refn.fs_id = ORANGEFS_FS_ID_NULL;
+	orangefs_inode-&gt;last_failed_block_index_read = 0;
+	memset(orangefs_inode-&gt;link_target, 0, sizeof(orangefs_inode-&gt;link_target));
+	orangefs_inode-&gt;pinode_flags = 0;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_alloc_inode: allocated %p\n",
-		     &amp;pvfs2_inode-&gt;vfs_inode);
-	return &amp;pvfs2_inode-&gt;vfs_inode;
+		     "orangefs_alloc_inode: allocated %p\n",
+		     &amp;orangefs_inode-&gt;vfs_inode);
+	return &amp;orangefs_inode-&gt;vfs_inode;
 }
 
-static void pvfs2_destroy_inode(struct inode *inode)
+static void orangefs_destroy_inode(struct inode *inode)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 			"%s: deallocated %p destroying inode %pU\n",
-			__func__, pvfs2_inode, get_khandle_from_ino(inode));
+			__func__, orangefs_inode, get_khandle_from_ino(inode));
 
-	kmem_cache_free(pvfs2_inode_cache, pvfs2_inode);
+	kmem_cache_free(orangefs_inode_cache, orangefs_inode);
 }
 
 /*
  * NOTE: information filled in here is typically reflected in the
  * output of the system command 'df'
 */
-static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
+static int orangefs_statfs(struct dentry *dentry, struct kstatfs *buf)
 {
 	int ret = -ENOMEM;
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int flags = 0;
 	struct super_block *sb = NULL;
 
 	sb = dentry-&gt;d_sb;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_statfs: called on sb %p (fs_id is %d)\n",
+		     "orangefs_statfs: called on sb %p (fs_id is %d)\n",
 		     sb,
-		     (int)(PVFS2_SB(sb)-&gt;fs_id));
+		     (int)(ORANGEFS_SB(sb)-&gt;fs_id));
 
-	new_op = op_alloc(PVFS2_VFS_OP_STATFS);
+	new_op = op_alloc(ORANGEFS_VFS_OP_STATFS);
 	if (!new_op)
 		return ret;
-	new_op-&gt;upcall.req.statfs.fs_id = PVFS2_SB(sb)-&gt;fs_id;
+	new_op-&gt;upcall.req.statfs.fs_id = ORANGEFS_SB(sb)-&gt;fs_id;
 
-	if (PVFS2_SB(sb)-&gt;flags &amp; PVFS2_OPT_INTR)
-		flags = PVFS2_OP_INTERRUPTIBLE;
+	if (ORANGEFS_SB(sb)-&gt;flags &amp; ORANGEFS_OPT_INTR)
+		flags = ORANGEFS_OP_INTERRUPTIBLE;
 
-	ret = service_operation(new_op, "pvfs2_statfs", flags);
+	ret = service_operation(new_op, "orangefs_statfs", flags);
 
 	if (new_op-&gt;downcall.status &lt; 0)
 		goto out_op_release;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_statfs: got %ld blocks available | "
+		     "orangefs_statfs: got %ld blocks available | "
 		     "%ld blocks total | %ld block size\n",
 		     (long)new_op-&gt;downcall.resp.statfs.blocks_avail,
 		     (long)new_op-&gt;downcall.resp.statfs.blocks_total,
 		     (long)new_op-&gt;downcall.resp.statfs.block_size);
 
 	buf-&gt;f_type = sb-&gt;s_magic;
-	memcpy(&amp;buf-&gt;f_fsid, &amp;PVFS2_SB(sb)-&gt;fs_id, sizeof(buf-&gt;f_fsid));
+	memcpy(&amp;buf-&gt;f_fsid, &amp;ORANGEFS_SB(sb)-&gt;fs_id, sizeof(buf-&gt;f_fsid));
 	buf-&gt;f_bsize = new_op-&gt;downcall.resp.statfs.block_size;
-	buf-&gt;f_namelen = PVFS2_NAME_LEN;
+	buf-&gt;f_namelen = ORANGEFS_NAME_LEN;
 
 	buf-&gt;f_blocks = (sector_t) new_op-&gt;downcall.resp.statfs.blocks_total;
 	buf-&gt;f_bfree = (sector_t) new_op-&gt;downcall.resp.statfs.blocks_avail;
@@ -178,7 +178,7 @@ static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
 
 out_op_release:
 	op_release(new_op);
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_statfs: returning %d\n", ret);
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_statfs: returning %d\n", ret);
 	return ret;
 }
 
@@ -186,9 +186,9 @@ static int pvfs2_statfs(struct dentry *dentry, struct kstatfs *buf)
  * Remount as initiated by VFS layer.  We just need to reparse the mount
  * options, no need to signal pvfs2-client-core about it.
  */
-static int pvfs2_remount_fs(struct super_block *sb, int *flags, char *data)
+static int orangefs_remount_fs(struct super_block *sb, int *flags, char *data)
 {
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_remount_fs: called\n");
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_remount_fs: called\n");
 	return parse_mount_options(sb, data, 1);
 }
 
@@ -207,33 +207,33 @@ static int pvfs2_remount_fs(struct super_block *sb, int *flags, char *data)
  * the client regains all of the mount information from us.
  * NOTE: this function assumes that the request_mutex is already acquired!
  */
-int pvfs2_remount(struct super_block *sb)
+int orangefs_remount(struct super_block *sb)
 {
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_kernel_op_s *new_op;
 	int ret = -EINVAL;
 
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_remount: called\n");
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_remount: called\n");
 
-	new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);
 	if (!new_op)
 		return -ENOMEM;
-	strncpy(new_op-&gt;upcall.req.fs_mount.pvfs2_config_server,
-		PVFS2_SB(sb)-&gt;devname,
-		PVFS_MAX_SERVER_ADDR_LEN);
+	strncpy(new_op-&gt;upcall.req.fs_mount.orangefs_config_server,
+		ORANGEFS_SB(sb)-&gt;devname,
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "Attempting PVFS2 Remount via host %s\n",
-		     new_op-&gt;upcall.req.fs_mount.pvfs2_config_server);
+		     "Attempting ORANGEFS Remount via host %s\n",
+		     new_op-&gt;upcall.req.fs_mount.orangefs_config_server);
 
 	/*
 	 * we assume that the calling function has already acquire the
 	 * request_mutex to prevent other operations from bypassing
 	 * this one
 	 */
-	ret = service_operation(new_op, "pvfs2_remount",
-		PVFS2_OP_PRIORITY | PVFS2_OP_NO_SEMAPHORE);
+	ret = service_operation(new_op, "orangefs_remount",
+		ORANGEFS_OP_PRIORITY | ORANGEFS_OP_NO_SEMAPHORE);
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_remount: mount got return value of %d\n",
+		     "orangefs_remount: mount got return value of %d\n",
 		     ret);
 	if (ret == 0) {
 		/*
@@ -241,8 +241,8 @@ int pvfs2_remount(struct super_block *sb)
 		 * short-lived mapping that the system interface uses
 		 * to map this superblock to a particular mount entry
 		 */
-		PVFS2_SB(sb)-&gt;id = new_op-&gt;downcall.resp.fs_mount.id;
-		PVFS2_SB(sb)-&gt;mount_pending = 0;
+		ORANGEFS_SB(sb)-&gt;id = new_op-&gt;downcall.resp.fs_mount.id;
+		ORANGEFS_SB(sb)-&gt;mount_pending = 0;
 	}
 
 	op_release(new_op);
@@ -259,54 +259,54 @@ void fsid_key_table_finalize(void)
 }
 
 /* Called whenever the VFS dirties the inode in response to atime updates */
-static void pvfs2_dirty_inode(struct inode *inode, int flags)
+static void orangefs_dirty_inode(struct inode *inode, int flags)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_dirty_inode: %pU\n",
+		     "orangefs_dirty_inode: %pU\n",
 		     get_khandle_from_ino(inode));
-	SetAtimeFlag(pvfs2_inode);
+	SetAtimeFlag(orangefs_inode);
 }
 
-static const struct super_operations pvfs2_s_ops = {
-	.alloc_inode = pvfs2_alloc_inode,
-	.destroy_inode = pvfs2_destroy_inode,
-	.dirty_inode = pvfs2_dirty_inode,
+static const struct super_operations orangefs_s_ops = {
+	.alloc_inode = orangefs_alloc_inode,
+	.destroy_inode = orangefs_destroy_inode,
+	.dirty_inode = orangefs_dirty_inode,
 	.drop_inode = generic_delete_inode,
-	.statfs = pvfs2_statfs,
-	.remount_fs = pvfs2_remount_fs,
+	.statfs = orangefs_statfs,
+	.remount_fs = orangefs_remount_fs,
 	.show_options = generic_show_options,
 };
 
-static struct dentry *pvfs2_fh_to_dentry(struct super_block *sb,
+static struct dentry *orangefs_fh_to_dentry(struct super_block *sb,
 				  struct fid *fid,
 				  int fh_len,
 				  int fh_type)
 {
-	struct pvfs2_object_kref refn;
+	struct orangefs_object_kref refn;
 
 	if (fh_len &lt; 5 || fh_type &gt; 2)
 		return NULL;
 
-	PVFS_khandle_from(&amp;(refn.khandle), fid-&gt;raw, 16);
+	ORANGEFS_khandle_from(&amp;(refn.khandle), fid-&gt;raw, 16);
 	refn.fs_id = (u32) fid-&gt;raw[4];
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "fh_to_dentry: handle %pU, fs_id %d\n",
 		     &amp;refn.khandle,
 		     refn.fs_id);
 
-	return d_obtain_alias(pvfs2_iget(sb, &amp;refn));
+	return d_obtain_alias(orangefs_iget(sb, &amp;refn));
 }
 
-static int pvfs2_encode_fh(struct inode *inode,
+static int orangefs_encode_fh(struct inode *inode,
 		    __u32 *fh,
 		    int *max_len,
 		    struct inode *parent)
 {
 	int len = parent ? 10 : 5;
 	int type = 1;
-	struct pvfs2_object_kref refn;
+	struct orangefs_object_kref refn;
 
 	if (*max_len &lt; len) {
 		gossip_lerr("fh buffer is too small for encoding\n");
@@ -315,8 +315,8 @@ static int pvfs2_encode_fh(struct inode *inode,
 		goto out;
 	}
 
-	refn = PVFS2_I(inode)-&gt;refn;
-	PVFS_khandle_to(&amp;refn.khandle, fh, 16);
+	refn = ORANGEFS_I(inode)-&gt;refn;
+	ORANGEFS_khandle_to(&amp;refn.khandle, fh, 16);
 	fh[4] = refn.fs_id;
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
@@ -326,8 +326,8 @@ static int pvfs2_encode_fh(struct inode *inode,
 
 
 	if (parent) {
-		refn = PVFS2_I(parent)-&gt;refn;
-		PVFS_khandle_to(&amp;refn.khandle, (char *) fh + 20, 16);
+		refn = ORANGEFS_I(parent)-&gt;refn;
+		ORANGEFS_khandle_to(&amp;refn.khandle, (char *) fh + 20, 16);
 		fh[9] = refn.fs_id;
 
 		type = 2;
@@ -342,30 +342,30 @@ static int pvfs2_encode_fh(struct inode *inode,
 	return type;
 }
 
-static struct export_operations pvfs2_export_ops = {
-	.encode_fh = pvfs2_encode_fh,
-	.fh_to_dentry = pvfs2_fh_to_dentry,
+static struct export_operations orangefs_export_ops = {
+	.encode_fh = orangefs_encode_fh,
+	.fh_to_dentry = orangefs_fh_to_dentry,
 };
 
-static int pvfs2_fill_sb(struct super_block *sb,
-		struct pvfs2_fs_mount_response *fs_mount,
+static int orangefs_fill_sb(struct super_block *sb,
+		struct orangefs_fs_mount_response *fs_mount,
 		void *data, int silent)
 {
 	int ret = -EINVAL;
 	struct inode *root = NULL;
 	struct dentry *root_dentry = NULL;
-	struct pvfs2_object_kref root_object;
+	struct orangefs_object_kref root_object;
 
-	/* alloc and init our private pvfs2 sb info */
+	/* alloc and init our private orangefs sb info */
 	sb-&gt;s_fs_info =
-		kzalloc(sizeof(struct pvfs2_sb_info_s), PVFS2_GFP_FLAGS);
-	if (!PVFS2_SB(sb))
+		kzalloc(sizeof(struct orangefs_sb_info_s), ORANGEFS_GFP_FLAGS);
+	if (!ORANGEFS_SB(sb))
 		return -ENOMEM;
-	PVFS2_SB(sb)-&gt;sb = sb;
+	ORANGEFS_SB(sb)-&gt;sb = sb;
 
-	PVFS2_SB(sb)-&gt;root_khandle = fs_mount-&gt;root_khandle;
-	PVFS2_SB(sb)-&gt;fs_id = fs_mount-&gt;fs_id;
-	PVFS2_SB(sb)-&gt;id = fs_mount-&gt;id;
+	ORANGEFS_SB(sb)-&gt;root_khandle = fs_mount-&gt;root_khandle;
+	ORANGEFS_SB(sb)-&gt;fs_id = fs_mount-&gt;fs_id;
+	ORANGEFS_SB(sb)-&gt;id = fs_mount-&gt;id;
 
 	if (data) {
 		ret = parse_mount_options(sb, data, silent);
@@ -374,23 +374,23 @@ static int pvfs2_fill_sb(struct super_block *sb,
 	}
 
 	/* Hang the xattr handlers off the superblock */
-	sb-&gt;s_xattr = pvfs2_xattr_handlers;
-	sb-&gt;s_magic = PVFS2_SUPER_MAGIC;
-	sb-&gt;s_op = &amp;pvfs2_s_ops;
-	sb-&gt;s_d_op = &amp;pvfs2_dentry_operations;
+	sb-&gt;s_xattr = orangefs_xattr_handlers;
+	sb-&gt;s_magic = ORANGEFS_SUPER_MAGIC;
+	sb-&gt;s_op = &amp;orangefs_s_ops;
+	sb-&gt;s_d_op = &amp;orangefs_dentry_operations;
 
-	sb-&gt;s_blocksize = pvfs_bufmap_size_query();
-	sb-&gt;s_blocksize_bits = pvfs_bufmap_shift_query();
+	sb-&gt;s_blocksize = orangefs_bufmap_size_query();
+	sb-&gt;s_blocksize_bits = orangefs_bufmap_shift_query();
 	sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;
 
-	root_object.khandle = PVFS2_SB(sb)-&gt;root_khandle;
-	root_object.fs_id = PVFS2_SB(sb)-&gt;fs_id;
+	root_object.khandle = ORANGEFS_SB(sb)-&gt;root_khandle;
+	root_object.fs_id = ORANGEFS_SB(sb)-&gt;fs_id;
 	gossip_debug(GOSSIP_SUPER_DEBUG,
 		     "get inode %pU, fsid %d\n",
 		     &amp;root_object.khandle,
 		     root_object.fs_id);
 
-	root = pvfs2_iget(sb, &amp;root_object);
+	root = orangefs_iget(sb, &amp;root_object);
 	if (IS_ERR(root))
 		return PTR_ERR(root);
 
@@ -404,23 +404,23 @@ static int pvfs2_fill_sb(struct super_block *sb,
 	if (!root_dentry)
 		return -ENOMEM;
 
-	sb-&gt;s_export_op = &amp;pvfs2_export_ops;
+	sb-&gt;s_export_op = &amp;orangefs_export_ops;
 	sb-&gt;s_root = root_dentry;
 	return 0;
 }
 
-struct dentry *pvfs2_mount(struct file_system_type *fst,
+struct dentry *orangefs_mount(struct file_system_type *fst,
 			   int flags,
 			   const char *devname,
 			   void *data)
 {
 	int ret = -EINVAL;
 	struct super_block *sb = ERR_PTR(-EINVAL);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_kernel_op_s *new_op;
 	struct dentry *d = ERR_PTR(-EINVAL);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_mount: called with devname %s\n",
+		     "orangefs_mount: called with devname %s\n",
 		     devname);
 
 	if (!devname) {
@@ -428,25 +428,25 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 		return ERR_PTR(-EINVAL);
 	}
 
-	new_op = op_alloc(PVFS2_VFS_OP_FS_MOUNT);
+	new_op = op_alloc(ORANGEFS_VFS_OP_FS_MOUNT);
 	if (!new_op)
 		return ERR_PTR(-ENOMEM);
 
-	strncpy(new_op-&gt;upcall.req.fs_mount.pvfs2_config_server,
+	strncpy(new_op-&gt;upcall.req.fs_mount.orangefs_config_server,
 		devname,
-		PVFS_MAX_SERVER_ADDR_LEN);
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "Attempting PVFS2 Mount via host %s\n",
-		     new_op-&gt;upcall.req.fs_mount.pvfs2_config_server);
+		     "Attempting ORANGEFS Mount via host %s\n",
+		     new_op-&gt;upcall.req.fs_mount.orangefs_config_server);
 
-	ret = service_operation(new_op, "pvfs2_mount", 0);
+	ret = service_operation(new_op, "orangefs_mount", 0);
 	gossip_debug(GOSSIP_SUPER_DEBUG,
-		     "pvfs2_mount: mount got return value of %d\n", ret);
+		     "orangefs_mount: mount got return value of %d\n", ret);
 	if (ret)
 		goto free_op;
 
-	if (new_op-&gt;downcall.resp.fs_mount.fs_id == PVFS_FS_ID_NULL) {
+	if (new_op-&gt;downcall.resp.fs_mount.fs_id == ORANGEFS_FS_ID_NULL) {
 		gossip_err("ERROR: Retrieved null fs_id\n");
 		ret = -EINVAL;
 		goto free_op;
@@ -459,7 +459,7 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 		goto free_op;
 	}
 
-	ret = pvfs2_fill_sb(sb,
+	ret = orangefs_fill_sb(sb,
 	      &amp;new_op-&gt;downcall.resp.fs_mount, data,
 	      flags &amp; MS_SILENT ? 1 : 0);
 
@@ -472,25 +472,25 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	 * on successful mount, store the devname and data
 	 * used
 	 */
-	strncpy(PVFS2_SB(sb)-&gt;devname,
+	strncpy(ORANGEFS_SB(sb)-&gt;devname,
 		devname,
-		PVFS_MAX_SERVER_ADDR_LEN);
+		ORANGEFS_MAX_SERVER_ADDR_LEN);
 
 	/* mount_pending must be cleared */
-	PVFS2_SB(sb)-&gt;mount_pending = 0;
+	ORANGEFS_SB(sb)-&gt;mount_pending = 0;
 
 	/*
-	 * finally, add this sb to our list of known pvfs2
+	 * finally, add this sb to our list of known orangefs
 	 * sb's
 	 */
-	add_pvfs2_sb(sb);
+	add_orangefs_sb(sb);
 	op_release(new_op);
 	return dget(sb-&gt;s_root);
 
 free_op:
-	gossip_err("pvfs2_mount: mount request failed with %d\n", ret);
+	gossip_err("orangefs_mount: mount request failed with %d\n", ret);
 	if (ret == -EINVAL) {
-		gossip_err("Ensure that all pvfs2-servers have the same FS configuration files\n");
+		gossip_err("Ensure that all orangefs-servers have the same FS configuration files\n");
 		gossip_err("Look at pvfs2-client-core log file (typically /tmp/pvfs2-client.log) for more details\n");
 	}
 
@@ -499,43 +499,43 @@ struct dentry *pvfs2_mount(struct file_system_type *fst,
 	return d;
 }
 
-void pvfs2_kill_sb(struct super_block *sb)
+void orangefs_kill_sb(struct super_block *sb)
 {
-	gossip_debug(GOSSIP_SUPER_DEBUG, "pvfs2_kill_sb: called\n");
+	gossip_debug(GOSSIP_SUPER_DEBUG, "orangefs_kill_sb: called\n");
 
 	/*
 	 * issue the unmount to userspace to tell it to remove the
 	 * dynamic mount info it has for this superblock
 	 */
-	pvfs2_unmount_sb(sb);
+	orangefs_unmount_sb(sb);
 
-	/* remove the sb from our list of pvfs2 specific sb's */
-	remove_pvfs2_sb(sb);
+	/* remove the sb from our list of orangefs specific sb's */
+	remove_orangefs_sb(sb);
 
 	/* provided sb cleanup */
 	kill_anon_super(sb);
 
-	/* free the pvfs2 superblock private data */
-	kfree(PVFS2_SB(sb));
+	/* free the orangefs superblock private data */
+	kfree(ORANGEFS_SB(sb));
 }
 
-int pvfs2_inode_cache_initialize(void)
+int orangefs_inode_cache_initialize(void)
 {
-	pvfs2_inode_cache = kmem_cache_create("pvfs2_inode_cache",
-					      sizeof(struct pvfs2_inode_s),
+	orangefs_inode_cache = kmem_cache_create("orangefs_inode_cache",
+					      sizeof(struct orangefs_inode_s),
 					      0,
-					      PVFS2_CACHE_CREATE_FLAGS,
-					      pvfs2_inode_cache_ctor);
+					      ORANGEFS_CACHE_CREATE_FLAGS,
+					      orangefs_inode_cache_ctor);
 
-	if (!pvfs2_inode_cache) {
-		gossip_err("Cannot create pvfs2_inode_cache\n");
+	if (!orangefs_inode_cache) {
+		gossip_err("Cannot create orangefs_inode_cache\n");
 		return -ENOMEM;
 	}
 	return 0;
 }
 
-int pvfs2_inode_cache_finalize(void)
+int orangefs_inode_cache_finalize(void)
 {
-	kmem_cache_destroy(pvfs2_inode_cache);
+	kmem_cache_destroy(orangefs_inode_cache);
 	return 0;
 }
diff --git a/fs/orangefs/symlink.c b/fs/orangefs/symlink.c
index 2adfceff7730..321f626b190b 100644
--- a/fs/orangefs/symlink.c
+++ b/fs/orangefs/symlink.c
@@ -8,9 +8,9 @@
 #include "pvfs2-kernel.h"
 #include "pvfs2-bufmap.h"
 
-static const char *pvfs2_follow_link(struct dentry *dentry, void **cookie)
+static const char *orangefs_follow_link(struct dentry *dentry, void **cookie)
 {
-	char *target =  PVFS2_I(dentry-&gt;d_inode)-&gt;link_target;
+	char *target =  ORANGEFS_I(dentry-&gt;d_inode)-&gt;link_target;
 
 	gossip_debug(GOSSIP_INODE_DEBUG,
 		     "%s: called on %s (target is %p)\n",
@@ -21,11 +21,11 @@ static const char *pvfs2_follow_link(struct dentry *dentry, void **cookie)
 	return target;
 }
 
-struct inode_operations pvfs2_symlink_inode_operations = {
+struct inode_operations orangefs_symlink_inode_operations = {
 	.readlink = generic_readlink,
-	.follow_link = pvfs2_follow_link,
-	.setattr = pvfs2_setattr,
-	.getattr = pvfs2_getattr,
-	.listxattr = pvfs2_listxattr,
+	.follow_link = orangefs_follow_link,
+	.setattr = orangefs_setattr,
+	.getattr = orangefs_getattr,
+	.listxattr = orangefs_listxattr,
 	.setxattr = generic_setxattr,
 };
diff --git a/fs/orangefs/upcall.h b/fs/orangefs/upcall.h
index 0805778a8185..781cbc38523a 100644
--- a/fs/orangefs/upcall.h
+++ b/fs/orangefs/upcall.h
@@ -12,68 +12,68 @@
  * 32-64 bit interaction issues between
  * client-core and device
  */
-struct pvfs2_io_request_s {
+struct orangefs_io_request_s {
 	__s32 async_vfs_io;
 	__s32 buf_index;
 	__s32 count;
 	__s32 __pad1;
 	__s64 offset;
-	struct pvfs2_object_kref refn;
-	enum PVFS_io_type io_type;
+	struct orangefs_object_kref refn;
+	enum ORANGEFS_io_type io_type;
 	__s32 readahead_size;
 };
 
-struct pvfs2_lookup_request_s {
+struct orangefs_lookup_request_s {
 	__s32 sym_follow;
 	__s32 __pad1;
-	struct pvfs2_object_kref parent_refn;
-	char d_name[PVFS2_NAME_LEN];
+	struct orangefs_object_kref parent_refn;
+	char d_name[ORANGEFS_NAME_LEN];
 };
 
-struct pvfs2_create_request_s {
-	struct pvfs2_object_kref parent_refn;
-	struct PVFS_sys_attr_s attributes;
-	char d_name[PVFS2_NAME_LEN];
+struct orangefs_create_request_s {
+	struct orangefs_object_kref parent_refn;
+	struct ORANGEFS_sys_attr_s attributes;
+	char d_name[ORANGEFS_NAME_LEN];
 };
 
-struct pvfs2_symlink_request_s {
-	struct pvfs2_object_kref parent_refn;
-	struct PVFS_sys_attr_s attributes;
-	char entry_name[PVFS2_NAME_LEN];
-	char target[PVFS2_NAME_LEN];
+struct orangefs_symlink_request_s {
+	struct orangefs_object_kref parent_refn;
+	struct ORANGEFS_sys_attr_s attributes;
+	char entry_name[ORANGEFS_NAME_LEN];
+	char target[ORANGEFS_NAME_LEN];
 };
 
-struct pvfs2_getattr_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_getattr_request_s {
+	struct orangefs_object_kref refn;
 	__u32 mask;
 	__u32 __pad1;
 };
 
-struct pvfs2_setattr_request_s {
-	struct pvfs2_object_kref refn;
-	struct PVFS_sys_attr_s attributes;
+struct orangefs_setattr_request_s {
+	struct orangefs_object_kref refn;
+	struct ORANGEFS_sys_attr_s attributes;
 };
 
-struct pvfs2_remove_request_s {
-	struct pvfs2_object_kref parent_refn;
-	char d_name[PVFS2_NAME_LEN];
+struct orangefs_remove_request_s {
+	struct orangefs_object_kref parent_refn;
+	char d_name[ORANGEFS_NAME_LEN];
 };
 
-struct pvfs2_mkdir_request_s {
-	struct pvfs2_object_kref parent_refn;
-	struct PVFS_sys_attr_s attributes;
-	char d_name[PVFS2_NAME_LEN];
+struct orangefs_mkdir_request_s {
+	struct orangefs_object_kref parent_refn;
+	struct ORANGEFS_sys_attr_s attributes;
+	char d_name[ORANGEFS_NAME_LEN];
 };
 
-struct pvfs2_readdir_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_readdir_request_s {
+	struct orangefs_object_kref refn;
 	__u64 token;
 	__s32 max_dirent_count;
 	__s32 buf_index;
 };
 
-struct pvfs2_readdirplus_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_readdirplus_request_s {
+	struct orangefs_object_kref refn;
 	__u64 token;
 	__s32 max_dirent_count;
 	__u32 mask;
@@ -81,130 +81,130 @@ struct pvfs2_readdirplus_request_s {
 	__s32 __pad1;
 };
 
-struct pvfs2_rename_request_s {
-	struct pvfs2_object_kref old_parent_refn;
-	struct pvfs2_object_kref new_parent_refn;
-	char d_old_name[PVFS2_NAME_LEN];
-	char d_new_name[PVFS2_NAME_LEN];
+struct orangefs_rename_request_s {
+	struct orangefs_object_kref old_parent_refn;
+	struct orangefs_object_kref new_parent_refn;
+	char d_old_name[ORANGEFS_NAME_LEN];
+	char d_new_name[ORANGEFS_NAME_LEN];
 };
 
-struct pvfs2_statfs_request_s {
+struct orangefs_statfs_request_s {
 	__s32 fs_id;
 	__s32 __pad1;
 };
 
-struct pvfs2_truncate_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_truncate_request_s {
+	struct orangefs_object_kref refn;
 	__s64 size;
 };
 
-struct pvfs2_mmap_ra_cache_flush_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_mmap_ra_cache_flush_request_s {
+	struct orangefs_object_kref refn;
 };
 
-struct pvfs2_fs_mount_request_s {
-	char pvfs2_config_server[PVFS_MAX_SERVER_ADDR_LEN];
+struct orangefs_fs_mount_request_s {
+	char orangefs_config_server[ORANGEFS_MAX_SERVER_ADDR_LEN];
 };
 
-struct pvfs2_fs_umount_request_s {
+struct orangefs_fs_umount_request_s {
 	__s32 id;
 	__s32 fs_id;
-	char pvfs2_config_server[PVFS_MAX_SERVER_ADDR_LEN];
+	char orangefs_config_server[ORANGEFS_MAX_SERVER_ADDR_LEN];
 };
 
-struct pvfs2_getxattr_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_getxattr_request_s {
+	struct orangefs_object_kref refn;
 	__s32 key_sz;
 	__s32 __pad1;
-	char key[PVFS_MAX_XATTR_NAMELEN];
+	char key[ORANGEFS_MAX_XATTR_NAMELEN];
 };
 
-struct pvfs2_setxattr_request_s {
-	struct pvfs2_object_kref refn;
-	struct PVFS_keyval_pair keyval;
+struct orangefs_setxattr_request_s {
+	struct orangefs_object_kref refn;
+	struct ORANGEFS_keyval_pair keyval;
 	__s32 flags;
 	__s32 __pad1;
 };
 
-struct pvfs2_listxattr_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_listxattr_request_s {
+	struct orangefs_object_kref refn;
 	__s32 requested_count;
 	__s32 __pad1;
 	__u64 token;
 };
 
-struct pvfs2_removexattr_request_s {
-	struct pvfs2_object_kref refn;
+struct orangefs_removexattr_request_s {
+	struct orangefs_object_kref refn;
 	__s32 key_sz;
 	__s32 __pad1;
-	char key[PVFS_MAX_XATTR_NAMELEN];
+	char key[ORANGEFS_MAX_XATTR_NAMELEN];
 };
 
-struct pvfs2_op_cancel_s {
+struct orangefs_op_cancel_s {
 	__u64 op_tag;
 };
 
-struct pvfs2_fsync_request_s {
-	struct pvfs2_object_kref refn;
-};
-
-enum pvfs2_param_request_type {
-	PVFS2_PARAM_REQUEST_SET = 1,
-	PVFS2_PARAM_REQUEST_GET = 2
-};
-
-enum pvfs2_param_request_op {
-	PVFS2_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS = 1,
-	PVFS2_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT = 2,
-	PVFS2_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT = 3,
-	PVFS2_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE = 4,
-	PVFS2_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS = 5,
-	PVFS2_PARAM_REQUEST_OP_PERF_HISTORY_SIZE = 6,
-	PVFS2_PARAM_REQUEST_OP_PERF_RESET = 7,
-	PVFS2_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS = 8,
-	PVFS2_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT = 9,
-	PVFS2_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT = 10,
-	PVFS2_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE = 11,
-	PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_TIMEOUT_MSECS = 12,
-	PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_HARD_LIMIT = 13,
-	PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_SOFT_LIMIT = 14,
-	PVFS2_PARAM_REQUEST_OP_STATIC_ACACHE_RECLAIM_PERCENTAGE = 15,
-	PVFS2_PARAM_REQUEST_OP_CLIENT_DEBUG = 16,
-	PVFS2_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS = 17,
-	PVFS2_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT = 18,
-	PVFS2_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT = 19,
-	PVFS2_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE = 20,
-	PVFS2_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS = 21,
-	PVFS2_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT = 22,
-	PVFS2_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT = 23,
-	PVFS2_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE = 24,
-	PVFS2_PARAM_REQUEST_OP_TWO_MASK_VALUES = 25,
-};
-
-struct pvfs2_param_request_s {
-	enum pvfs2_param_request_type type;
-	enum pvfs2_param_request_op op;
+struct orangefs_fsync_request_s {
+	struct orangefs_object_kref refn;
+};
+
+enum orangefs_param_request_type {
+	ORANGEFS_PARAM_REQUEST_SET = 1,
+	ORANGEFS_PARAM_REQUEST_GET = 2
+};
+
+enum orangefs_param_request_op {
+	ORANGEFS_PARAM_REQUEST_OP_ACACHE_TIMEOUT_MSECS = 1,
+	ORANGEFS_PARAM_REQUEST_OP_ACACHE_HARD_LIMIT = 2,
+	ORANGEFS_PARAM_REQUEST_OP_ACACHE_SOFT_LIMIT = 3,
+	ORANGEFS_PARAM_REQUEST_OP_ACACHE_RECLAIM_PERCENTAGE = 4,
+	ORANGEFS_PARAM_REQUEST_OP_PERF_TIME_INTERVAL_SECS = 5,
+	ORANGEFS_PARAM_REQUEST_OP_PERF_HISTORY_SIZE = 6,
+	ORANGEFS_PARAM_REQUEST_OP_PERF_RESET = 7,
+	ORANGEFS_PARAM_REQUEST_OP_NCACHE_TIMEOUT_MSECS = 8,
+	ORANGEFS_PARAM_REQUEST_OP_NCACHE_HARD_LIMIT = 9,
+	ORANGEFS_PARAM_REQUEST_OP_NCACHE_SOFT_LIMIT = 10,
+	ORANGEFS_PARAM_REQUEST_OP_NCACHE_RECLAIM_PERCENTAGE = 11,
+	ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_TIMEOUT_MSECS = 12,
+	ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_HARD_LIMIT = 13,
+	ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_SOFT_LIMIT = 14,
+	ORANGEFS_PARAM_REQUEST_OP_STATIC_ACACHE_RECLAIM_PERCENTAGE = 15,
+	ORANGEFS_PARAM_REQUEST_OP_CLIENT_DEBUG = 16,
+	ORANGEFS_PARAM_REQUEST_OP_CCACHE_TIMEOUT_SECS = 17,
+	ORANGEFS_PARAM_REQUEST_OP_CCACHE_HARD_LIMIT = 18,
+	ORANGEFS_PARAM_REQUEST_OP_CCACHE_SOFT_LIMIT = 19,
+	ORANGEFS_PARAM_REQUEST_OP_CCACHE_RECLAIM_PERCENTAGE = 20,
+	ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_TIMEOUT_SECS = 21,
+	ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_HARD_LIMIT = 22,
+	ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_SOFT_LIMIT = 23,
+	ORANGEFS_PARAM_REQUEST_OP_CAPCACHE_RECLAIM_PERCENTAGE = 24,
+	ORANGEFS_PARAM_REQUEST_OP_TWO_MASK_VALUES = 25,
+};
+
+struct orangefs_param_request_s {
+	enum orangefs_param_request_type type;
+	enum orangefs_param_request_op op;
 	__s64 value;
-	char s_value[PVFS2_MAX_DEBUG_STRING_LEN];
+	char s_value[ORANGEFS_MAX_DEBUG_STRING_LEN];
 };
 
-enum pvfs2_perf_count_request_type {
-	PVFS2_PERF_COUNT_REQUEST_ACACHE = 1,
-	PVFS2_PERF_COUNT_REQUEST_NCACHE = 2,
-	PVFS2_PERF_COUNT_REQUEST_CAPCACHE = 3,
+enum orangefs_perf_count_request_type {
+	ORANGEFS_PERF_COUNT_REQUEST_ACACHE = 1,
+	ORANGEFS_PERF_COUNT_REQUEST_NCACHE = 2,
+	ORANGEFS_PERF_COUNT_REQUEST_CAPCACHE = 3,
 };
 
-struct pvfs2_perf_count_request_s {
-	enum pvfs2_perf_count_request_type type;
+struct orangefs_perf_count_request_s {
+	enum orangefs_perf_count_request_type type;
 	__s32 __pad1;
 };
 
-struct pvfs2_fs_key_request_s {
+struct orangefs_fs_key_request_s {
 	__s32 fsid;
 	__s32 __pad1;
 };
 
-struct pvfs2_upcall_s {
+struct orangefs_upcall_s {
 	__s32 type;
 	__u32 uid;
 	__u32 gid;
@@ -215,31 +215,31 @@ struct pvfs2_upcall_s {
 	char *trailer_buf;
 
 	union {
-		struct pvfs2_io_request_s io;
-		struct pvfs2_lookup_request_s lookup;
-		struct pvfs2_create_request_s create;
-		struct pvfs2_symlink_request_s sym;
-		struct pvfs2_getattr_request_s getattr;
-		struct pvfs2_setattr_request_s setattr;
-		struct pvfs2_remove_request_s remove;
-		struct pvfs2_mkdir_request_s mkdir;
-		struct pvfs2_readdir_request_s readdir;
-		struct pvfs2_readdirplus_request_s readdirplus;
-		struct pvfs2_rename_request_s rename;
-		struct pvfs2_statfs_request_s statfs;
-		struct pvfs2_truncate_request_s truncate;
-		struct pvfs2_mmap_ra_cache_flush_request_s ra_cache_flush;
-		struct pvfs2_fs_mount_request_s fs_mount;
-		struct pvfs2_fs_umount_request_s fs_umount;
-		struct pvfs2_getxattr_request_s getxattr;
-		struct pvfs2_setxattr_request_s setxattr;
-		struct pvfs2_listxattr_request_s listxattr;
-		struct pvfs2_removexattr_request_s removexattr;
-		struct pvfs2_op_cancel_s cancel;
-		struct pvfs2_fsync_request_s fsync;
-		struct pvfs2_param_request_s param;
-		struct pvfs2_perf_count_request_s perf_count;
-		struct pvfs2_fs_key_request_s fs_key;
+		struct orangefs_io_request_s io;
+		struct orangefs_lookup_request_s lookup;
+		struct orangefs_create_request_s create;
+		struct orangefs_symlink_request_s sym;
+		struct orangefs_getattr_request_s getattr;
+		struct orangefs_setattr_request_s setattr;
+		struct orangefs_remove_request_s remove;
+		struct orangefs_mkdir_request_s mkdir;
+		struct orangefs_readdir_request_s readdir;
+		struct orangefs_readdirplus_request_s readdirplus;
+		struct orangefs_rename_request_s rename;
+		struct orangefs_statfs_request_s statfs;
+		struct orangefs_truncate_request_s truncate;
+		struct orangefs_mmap_ra_cache_flush_request_s ra_cache_flush;
+		struct orangefs_fs_mount_request_s fs_mount;
+		struct orangefs_fs_umount_request_s fs_umount;
+		struct orangefs_getxattr_request_s getxattr;
+		struct orangefs_setxattr_request_s setxattr;
+		struct orangefs_listxattr_request_s listxattr;
+		struct orangefs_removexattr_request_s removexattr;
+		struct orangefs_op_cancel_s cancel;
+		struct orangefs_fsync_request_s fsync;
+		struct orangefs_param_request_s param;
+		struct orangefs_perf_count_request_s perf_count;
+		struct orangefs_fs_key_request_s fs_key;
 	} req;
 };
 
diff --git a/fs/orangefs/waitqueue.c b/fs/orangefs/waitqueue.c
index d7b0eba043ab..cfc8dc59c4eb 100644
--- a/fs/orangefs/waitqueue.c
+++ b/fs/orangefs/waitqueue.c
@@ -25,10 +25,10 @@
  */
 void purge_waiting_ops(void)
 {
-	struct pvfs2_kernel_op_s *op;
+	struct orangefs_kernel_op_s *op;
 
-	spin_lock(&amp;pvfs2_request_list_lock);
-	list_for_each_entry(op, &amp;pvfs2_request_list, list) {
+	spin_lock(&amp;orangefs_request_list_lock);
+	list_for_each_entry(op, &amp;orangefs_request_list, list) {
 		gossip_debug(GOSSIP_WAIT_DEBUG,
 			     "pvfs2-client-core: purging op tag %llu %s\n",
 			     llu(op-&gt;tag),
@@ -38,11 +38,11 @@ void purge_waiting_ops(void)
 		spin_unlock(&amp;op-&gt;lock);
 		wake_up_interruptible(&amp;op-&gt;waitq);
 	}
-	spin_unlock(&amp;pvfs2_request_list_lock);
+	spin_unlock(&amp;orangefs_request_list_lock);
 }
 
 /*
- * submits a PVFS2 operation and waits for it to complete
+ * submits a ORANGEFS operation and waits for it to complete
  *
  * Note op-&gt;downcall.status will contain the status of the operation (in
  * errno format), whether provided by pvfs2-client or a result of failure to
@@ -51,7 +51,7 @@ void purge_waiting_ops(void)
  *
  * Returns contents of op-&gt;downcall.status for convenience
  */
-int service_operation(struct pvfs2_kernel_op_s *op,
+int service_operation(struct orangefs_kernel_op_s *op,
 		      const char *op_name,
 		      int flags)
 {
@@ -70,30 +70,30 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 retry_servicing:
 	op-&gt;downcall.status = 0;
 	gossip_debug(GOSSIP_WAIT_DEBUG,
-		     "pvfs2: service_operation: %s %p\n",
+		     "orangefs: service_operation: %s %p\n",
 		     op_name,
 		     op);
 	gossip_debug(GOSSIP_WAIT_DEBUG,
-		     "pvfs2: operation posted by process: %s, pid: %i\n",
+		     "orangefs: operation posted by process: %s, pid: %i\n",
 		     current-&gt;comm,
 		     current-&gt;pid);
 
 	/* mask out signals if this operation is not to be interrupted */
-	if (!(flags &amp; PVFS2_OP_INTERRUPTIBLE))
+	if (!(flags &amp; ORANGEFS_OP_INTERRUPTIBLE))
 		block_signals(&amp;orig_sigset);
 
-	if (!(flags &amp; PVFS2_OP_NO_SEMAPHORE)) {
+	if (!(flags &amp; ORANGEFS_OP_NO_SEMAPHORE)) {
 		ret = mutex_lock_interruptible(&amp;request_mutex);
 		/*
 		 * check to see if we were interrupted while waiting for
 		 * semaphore
 		 */
 		if (ret &lt; 0) {
-			if (!(flags &amp; PVFS2_OP_INTERRUPTIBLE))
+			if (!(flags &amp; ORANGEFS_OP_INTERRUPTIBLE))
 				set_signals(&amp;orig_sigset);
 			op-&gt;downcall.status = ret;
 			gossip_debug(GOSSIP_WAIT_DEBUG,
-				     "pvfs2: service_operation interrupted.\n");
+				     "orangefs: service_operation interrupted.\n");
 			return ret;
 		}
 	}
@@ -116,7 +116,7 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 	}
 
 	/* queue up the operation */
-	if (flags &amp; PVFS2_OP_PRIORITY) {
+	if (flags &amp; ORANGEFS_OP_PRIORITY) {
 		add_priority_op_to_request_list(op);
 	} else {
 		gossip_debug(GOSSIP_WAIT_DEBUG,
@@ -125,17 +125,17 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 		add_op_to_request_list(op);
 	}
 
-	if (!(flags &amp; PVFS2_OP_NO_SEMAPHORE))
+	if (!(flags &amp; ORANGEFS_OP_NO_SEMAPHORE))
 		mutex_unlock(&amp;request_mutex);
 
 	/*
 	 * If we are asked to service an asynchronous operation from
 	 * VFS perspective, we are done.
 	 */
-	if (flags &amp; PVFS2_OP_ASYNC)
+	if (flags &amp; ORANGEFS_OP_ASYNC)
 		return 0;
 
-	if (flags &amp; PVFS2_OP_CANCELLATION) {
+	if (flags &amp; ORANGEFS_OP_CANCELLATION) {
 		gossip_debug(GOSSIP_WAIT_DEBUG,
 			     "%s:"
 			     "About to call wait_for_cancellation_downcall.\n",
@@ -148,25 +148,25 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 	if (ret &lt; 0) {
 		/* failed to get matching downcall */
 		if (ret == -ETIMEDOUT) {
-			gossip_err("pvfs2: %s -- wait timed out; aborting attempt.\n",
+			gossip_err("orangefs: %s -- wait timed out; aborting attempt.\n",
 				   op_name);
 		}
 		op-&gt;downcall.status = ret;
 	} else {
 		/* got matching downcall; make sure status is in errno format */
 		op-&gt;downcall.status =
-		    pvfs2_normalize_to_errno(op-&gt;downcall.status);
+		    orangefs_normalize_to_errno(op-&gt;downcall.status);
 		ret = op-&gt;downcall.status;
 	}
 
-	if (!(flags &amp; PVFS2_OP_INTERRUPTIBLE))
+	if (!(flags &amp; ORANGEFS_OP_INTERRUPTIBLE))
 		set_signals(&amp;orig_sigset);
 
 	BUG_ON(ret != op-&gt;downcall.status);
 	/* retry if operation has not been serviced and if requested */
 	if (!op_state_serviced(op) &amp;&amp; op-&gt;downcall.status == -EAGAIN) {
 		gossip_debug(GOSSIP_WAIT_DEBUG,
-			     "pvfs2: tag %llu (%s)"
+			     "orangefs: tag %llu (%s)"
 			     " -- operation to be retried (%d attempt)\n",
 			     llu(op-&gt;tag),
 			     op_name,
@@ -204,17 +204,17 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 			 * memory system can be initialized.
 			 */
 			spin_lock_irqsave(&amp;op-&gt;lock, irqflags);
-			add_wait_queue(&amp;pvfs2_bufmap_init_waitq, &amp;wait_entry);
+			add_wait_queue(&amp;orangefs_bufmap_init_waitq, &amp;wait_entry);
 			spin_unlock_irqrestore(&amp;op-&gt;lock, irqflags);
 
 			set_current_state(TASK_INTERRUPTIBLE);
 
 			/*
-			 * Wait for pvfs_bufmap_initialize() to wake me up
+			 * Wait for orangefs_bufmap_initialize() to wake me up
 			 * within the allotted time.
 			 */
 			ret = schedule_timeout(MSECS_TO_JIFFIES
-				(1000 * PVFS2_BUFMAP_WAIT_TIMEOUT_SECS));
+				(1000 * ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS));
 
 			gossip_debug(GOSSIP_WAIT_DEBUG,
 				     "Value returned from schedule_timeout:"
@@ -225,14 +225,14 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 				     get_bufmap_init());
 
 			spin_lock_irqsave(&amp;op-&gt;lock, irqflags);
-			remove_wait_queue(&amp;pvfs2_bufmap_init_waitq,
+			remove_wait_queue(&amp;orangefs_bufmap_init_waitq,
 					  &amp;wait_entry);
 			spin_unlock_irqrestore(&amp;op-&gt;lock, irqflags);
 
 			if (get_bufmap_init() == 0) {
 				gossip_err("%s:The shared memory system has not started in %d seconds after the client core restarted.  Aborting user's request(%s).\n",
 					   __func__,
-					   PVFS2_BUFMAP_WAIT_TIMEOUT_SECS,
+					   ORANGEFS_BUFMAP_WAIT_TIMEOUT_SECS,
 					   get_opname_string(op));
 				return -EIO;
 			}
@@ -246,14 +246,14 @@ int service_operation(struct pvfs2_kernel_op_s *op,
 	}
 
 	gossip_debug(GOSSIP_WAIT_DEBUG,
-		     "pvfs2: service_operation %s returning: %d for %p.\n",
+		     "orangefs: service_operation %s returning: %d for %p.\n",
 		     op_name,
 		     ret,
 		     op);
 	return ret;
 }
 
-void pvfs2_clean_up_interrupted_operation(struct pvfs2_kernel_op_s *op)
+void orangefs_clean_up_interrupted_operation(struct orangefs_kernel_op_s *op)
 {
 	/*
 	 * handle interrupted cases depending on what state we were in when
@@ -339,7 +339,7 @@ void pvfs2_clean_up_interrupted_operation(struct pvfs2_kernel_op_s *op)
  * operation since client-core seems to be exiting too often
  * or if we were interrupted.
  */
-int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op)
+int wait_for_matching_downcall(struct orangefs_kernel_op_s *op)
 {
 	int ret = -EINVAL;
 	DECLARE_WAITQUEUE(wait_entry, current);
@@ -386,7 +386,7 @@ int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op)
 						     op,
 						     op-&gt;attempts);
 					ret = -ETIMEDOUT;
-					pvfs2_clean_up_interrupted_operation
+					orangefs_clean_up_interrupted_operation
 					    (op);
 					break;
 				}
@@ -403,7 +403,7 @@ int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op)
 			 * core starts, and so on...
 			 */
 			if (op_state_purged(op)) {
-				ret = (op-&gt;attempts &lt; PVFS2_PURGE_RETRY_COUNT) ?
+				ret = (op-&gt;attempts &lt; ORANGEFS_PURGE_RETRY_COUNT) ?
 					 -EAGAIN :
 					 -EIO;
 				spin_unlock(&amp;op-&gt;lock);
@@ -415,7 +415,7 @@ int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op)
 					     llu(op-&gt;tag),
 					     op,
 					     op-&gt;attempts);
-				pvfs2_clean_up_interrupted_operation(op);
+				orangefs_clean_up_interrupted_operation(op);
 				break;
 			}
 			spin_unlock(&amp;op-&gt;lock);
@@ -429,7 +429,7 @@ int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op)
 			     __func__,
 			     llu(op-&gt;tag),
 			     op);
-		pvfs2_clean_up_interrupted_operation(op);
+		orangefs_clean_up_interrupted_operation(op);
 		ret = -EINTR;
 		break;
 	}
@@ -452,7 +452,7 @@ int wait_for_matching_downcall(struct pvfs2_kernel_op_s *op)
  *      cancellation upcall anyway.  the only way to exit this is to either
  *      timeout or have the cancellation be serviced properly.
  */
-int wait_for_cancellation_downcall(struct pvfs2_kernel_op_s *op)
+int wait_for_cancellation_downcall(struct orangefs_kernel_op_s *op)
 {
 	int ret = -EINVAL;
 	DECLARE_WAITQUEUE(wait_entry, current);
@@ -482,7 +482,7 @@ int wait_for_cancellation_downcall(struct pvfs2_kernel_op_s *op)
 				     __func__,
 				     llu(op-&gt;tag),
 				     op);
-			pvfs2_clean_up_interrupted_operation(op);
+			orangefs_clean_up_interrupted_operation(op);
 			ret = -EINTR;
 			break;
 		}
@@ -502,7 +502,7 @@ int wait_for_cancellation_downcall(struct pvfs2_kernel_op_s *op)
 				     "%s:*** operation timed out: %p\n",
 				     __func__,
 				     op);
-			pvfs2_clean_up_interrupted_operation(op);
+			orangefs_clean_up_interrupted_operation(op);
 			ret = -ETIMEDOUT;
 			break;
 		}
diff --git a/fs/orangefs/xattr.c b/fs/orangefs/xattr.c
index b683daab7425..aeb3c3083591 100644
--- a/fs/orangefs/xattr.c
+++ b/fs/orangefs/xattr.c
@@ -15,8 +15,8 @@
 #include &lt;linux/xattr.h&gt;
 
 
-#define SYSTEM_PVFS2_KEY "system.pvfs2."
-#define SYSTEM_PVFS2_KEY_LEN 13
+#define SYSTEM_ORANGEFS_KEY "system.pvfs2."
+#define SYSTEM_ORANGEFS_KEY_LEN 13
 
 /*
  * this function returns
@@ -24,15 +24,15 @@
  *     of a listxattr.
  *   1 if the key corresponding to name is meant to be returned as part of
  *     a listxattr.
- * The ones that start SYSTEM_PVFS2_KEY are the ones to avoid printing.
+ * The ones that start SYSTEM_ORANGEFS_KEY are the ones to avoid printing.
  */
 static int is_reserved_key(const char *key, size_t size)
 {
 
-	if (size &lt; SYSTEM_PVFS2_KEY_LEN)
+	if (size &lt; SYSTEM_ORANGEFS_KEY_LEN)
 		return 1;
 
-	return strncmp(key, SYSTEM_PVFS2_KEY, SYSTEM_PVFS2_KEY_LEN) ?  1 : 0;
+	return strncmp(key, SYSTEM_ORANGEFS_KEY, SYSTEM_ORANGEFS_KEY_LEN) ?  1 : 0;
 }
 
 static inline int convert_to_internal_xattr_flags(int setxattr_flags)
@@ -41,10 +41,10 @@ static inline int convert_to_internal_xattr_flags(int setxattr_flags)
 
 	if (setxattr_flags &amp; XATTR_REPLACE) {
 		/* Attribute must exist! */
-		internal_flag = PVFS_XATTR_REPLACE;
+		internal_flag = ORANGEFS_XATTR_REPLACE;
 	} else if (setxattr_flags &amp; XATTR_CREATE) {
 		/* Attribute must not exist */
-		internal_flag = PVFS_XATTR_CREATE;
+		internal_flag = ORANGEFS_XATTR_CREATE;
 	}
 	return internal_flag;
 }
@@ -59,11 +59,11 @@ static inline int convert_to_internal_xattr_flags(int setxattr_flags)
  * unless the key does not exist for the file and/or if
  * there were errors in fetching the attribute value.
  */
-ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
+ssize_t orangefs_inode_getxattr(struct inode *inode, const char *prefix,
 		const char *name, void *buffer, size_t size)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
 	ssize_t ret = -ENOMEM;
 	ssize_t length = 0;
 	int fsuid;
@@ -74,10 +74,10 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 		     __func__, prefix, name, size);
 
 	if (name == NULL || (size &gt; 0 &amp;&amp; buffer == NULL)) {
-		gossip_err("pvfs2_inode_getxattr: bogus NULL pointers\n");
+		gossip_err("orangefs_inode_getxattr: bogus NULL pointers\n");
 		return -EINVAL;
 	}
-	if ((strlen(name) + strlen(prefix)) &gt;= PVFS_MAX_XATTR_NAMELEN) {
+	if ((strlen(name) + strlen(prefix)) &gt;= ORANGEFS_MAX_XATTR_NAMELEN) {
 		gossip_err("Invalid key length (%d)\n",
 			   (int)(strlen(name) + strlen(prefix)));
 		return -EINVAL;
@@ -94,15 +94,15 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 		     fsuid,
 		     fsgid);
 
-	down_read(&amp;pvfs2_inode-&gt;xattr_sem);
+	down_read(&amp;orangefs_inode-&gt;xattr_sem);
 
-	new_op = op_alloc(PVFS2_VFS_OP_GETXATTR);
+	new_op = op_alloc(ORANGEFS_VFS_OP_GETXATTR);
 	if (!new_op)
 		goto out_unlock;
 
-	new_op-&gt;upcall.req.getxattr.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.getxattr.refn = orangefs_inode-&gt;refn;
 	ret = snprintf((char *)new_op-&gt;upcall.req.getxattr.key,
-		       PVFS_MAX_XATTR_NAMELEN, "%s%s", prefix, name);
+		       ORANGEFS_MAX_XATTR_NAMELEN, "%s%s", prefix, name);
 
 	/*
 	 * NOTE: Although keys are meant to be NULL terminated textual
@@ -111,13 +111,13 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 	 */
 	new_op-&gt;upcall.req.getxattr.key_sz = ret + 1;
 
-	ret = service_operation(new_op, "pvfs2_inode_getxattr",
+	ret = service_operation(new_op, "orangefs_inode_getxattr",
 				get_interruptible_flag(inode));
 	if (ret != 0) {
 		if (ret == -ENOENT) {
 			ret = -ENODATA;
 			gossip_debug(GOSSIP_XATTR_DEBUG,
-				     "pvfs2_inode_getxattr: inode %pU key %s"
+				     "orangefs_inode_getxattr: inode %pU key %s"
 				     " does not exist!\n",
 				     get_khandle_from_ino(inode),
 				     (char *)new_op-&gt;upcall.req.getxattr.key);
@@ -149,7 +149,7 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 	memset(buffer, 0, size);
 	memcpy(buffer, new_op-&gt;downcall.resp.getxattr.val, length);
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-	     "pvfs2_inode_getxattr: inode %pU "
+	     "orangefs_inode_getxattr: inode %pU "
 	     "key %s key_sz %d, val_len %d\n",
 	     get_khandle_from_ino(inode),
 	     (char *)new_op-&gt;
@@ -163,44 +163,44 @@ ssize_t pvfs2_inode_getxattr(struct inode *inode, const char *prefix,
 out_release_op:
 	op_release(new_op);
 out_unlock:
-	up_read(&amp;pvfs2_inode-&gt;xattr_sem);
+	up_read(&amp;orangefs_inode-&gt;xattr_sem);
 	return ret;
 }
 
-static int pvfs2_inode_removexattr(struct inode *inode,
+static int orangefs_inode_removexattr(struct inode *inode,
 			    const char *prefix,
 			    const char *name,
 			    int flags)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op = NULL;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op = NULL;
 	int ret = -ENOMEM;
 
-	down_write(&amp;pvfs2_inode-&gt;xattr_sem);
-	new_op = op_alloc(PVFS2_VFS_OP_REMOVEXATTR);
+	down_write(&amp;orangefs_inode-&gt;xattr_sem);
+	new_op = op_alloc(ORANGEFS_VFS_OP_REMOVEXATTR);
 	if (!new_op)
 		goto out_unlock;
 
-	new_op-&gt;upcall.req.removexattr.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.removexattr.refn = orangefs_inode-&gt;refn;
 	/*
 	 * NOTE: Although keys are meant to be NULL terminated
 	 * textual strings, I am going to explicitly pass the
 	 * length just in case we change this later on...
 	 */
 	ret = snprintf((char *)new_op-&gt;upcall.req.removexattr.key,
-		       PVFS_MAX_XATTR_NAMELEN,
+		       ORANGEFS_MAX_XATTR_NAMELEN,
 		       "%s%s",
 		       (prefix ? prefix : ""),
 		       name);
 	new_op-&gt;upcall.req.removexattr.key_sz = ret + 1;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_removexattr: key %s, key_sz %d\n",
+		     "orangefs_inode_removexattr: key %s, key_sz %d\n",
 		     (char *)new_op-&gt;upcall.req.removexattr.key,
 		     (int)new_op-&gt;upcall.req.removexattr.key_sz);
 
 	ret = service_operation(new_op,
-				"pvfs2_inode_removexattr",
+				"orangefs_inode_removexattr",
 				get_interruptible_flag(inode));
 	if (ret == -ENOENT) {
 		/*
@@ -213,11 +213,11 @@ static int pvfs2_inode_removexattr(struct inode *inode,
 	}
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_removexattr: returning %d\n", ret);
+		     "orangefs_inode_removexattr: returning %d\n", ret);
 
 	op_release(new_op);
 out_unlock:
-	up_write(&amp;pvfs2_inode-&gt;xattr_sem);
+	up_write(&amp;orangefs_inode-&gt;xattr_sem);
 	return ret;
 }
 
@@ -227,11 +227,11 @@ static int pvfs2_inode_removexattr(struct inode *inode,
  * Returns a -ve number on error and 0 on success.  Key is text, but value
  * can be binary!
  */
-int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
+int orangefs_inode_setxattr(struct inode *inode, const char *prefix,
 		const char *name, const void *value, size_t size, int flags)
 {
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
 	int internal_flag = 0;
 	int ret = -ENOMEM;
 
@@ -240,9 +240,9 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 		     __func__, prefix, name, size);
 
 	if (size &lt; 0 ||
-	    size &gt;= PVFS_MAX_XATTR_VALUELEN ||
+	    size &gt;= ORANGEFS_MAX_XATTR_VALUELEN ||
 	    flags &lt; 0) {
-		gossip_err("pvfs2_inode_setxattr: bogus values of size(%d), flags(%d)\n",
+		gossip_err("orangefs_inode_setxattr: bogus values of size(%d), flags(%d)\n",
 			   (int)size,
 			   flags);
 		return -EINVAL;
@@ -250,23 +250,23 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 
 	if (name == NULL ||
 	    (size &gt; 0 &amp;&amp; value == NULL)) {
-		gossip_err("pvfs2_inode_setxattr: bogus NULL pointers!\n");
+		gossip_err("orangefs_inode_setxattr: bogus NULL pointers!\n");
 		return -EINVAL;
 	}
 
 	internal_flag = convert_to_internal_xattr_flags(flags);
 
 	if (prefix) {
-		if (strlen(name) + strlen(prefix) &gt;= PVFS_MAX_XATTR_NAMELEN) {
+		if (strlen(name) + strlen(prefix) &gt;= ORANGEFS_MAX_XATTR_NAMELEN) {
 			gossip_err
-			    ("pvfs2_inode_setxattr: bogus key size (%d)\n",
+			    ("orangefs_inode_setxattr: bogus key size (%d)\n",
 			     (int)(strlen(name) + strlen(prefix)));
 			return -EINVAL;
 		}
 	} else {
-		if (strlen(name) &gt;= PVFS_MAX_XATTR_NAMELEN) {
+		if (strlen(name) &gt;= ORANGEFS_MAX_XATTR_NAMELEN) {
 			gossip_err
-			    ("pvfs2_inode_setxattr: bogus key size (%d)\n",
+			    ("orangefs_inode_setxattr: bogus key size (%d)\n",
 			     (int)(strlen(name)));
 			return -EINVAL;
 		}
@@ -278,7 +278,7 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 			     "removing xattr (%s%s)\n",
 			     prefix,
 			     name);
-		return pvfs2_inode_removexattr(inode, prefix, name, flags);
+		return orangefs_inode_removexattr(inode, prefix, name, flags);
 	}
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
@@ -286,13 +286,13 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 		     get_khandle_from_ino(inode),
 		     name);
 
-	down_write(&amp;pvfs2_inode-&gt;xattr_sem);
-	new_op = op_alloc(PVFS2_VFS_OP_SETXATTR);
+	down_write(&amp;orangefs_inode-&gt;xattr_sem);
+	new_op = op_alloc(ORANGEFS_VFS_OP_SETXATTR);
 	if (!new_op)
 		goto out_unlock;
 
 
-	new_op-&gt;upcall.req.setxattr.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.setxattr.refn = orangefs_inode-&gt;refn;
 	new_op-&gt;upcall.req.setxattr.flags = internal_flag;
 	/*
 	 * NOTE: Although keys are meant to be NULL terminated textual
@@ -300,7 +300,7 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 	 * case we change this later on...
 	 */
 	ret = snprintf((char *)new_op-&gt;upcall.req.setxattr.keyval.key,
-		       PVFS_MAX_XATTR_NAMELEN,
+		       ORANGEFS_MAX_XATTR_NAMELEN,
 		       "%s%s",
 		       prefix, name);
 	new_op-&gt;upcall.req.setxattr.keyval.key_sz = ret + 1;
@@ -308,24 +308,24 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
 	new_op-&gt;upcall.req.setxattr.keyval.val_sz = size;
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_setxattr: key %s, key_sz %d "
+		     "orangefs_inode_setxattr: key %s, key_sz %d "
 		     " value size %zd\n",
 		     (char *)new_op-&gt;upcall.req.setxattr.keyval.key,
 		     (int)new_op-&gt;upcall.req.setxattr.keyval.key_sz,
 		     size);
 
 	ret = service_operation(new_op,
-				"pvfs2_inode_setxattr",
+				"orangefs_inode_setxattr",
 				get_interruptible_flag(inode));
 
 	gossip_debug(GOSSIP_XATTR_DEBUG,
-		     "pvfs2_inode_setxattr: returning %d\n",
+		     "orangefs_inode_setxattr: returning %d\n",
 		     ret);
 
 	/* when request is serviced properly, free req op struct */
 	op_release(new_op);
 out_unlock:
-	up_write(&amp;pvfs2_inode-&gt;xattr_sem);
+	up_write(&amp;orangefs_inode-&gt;xattr_sem);
 	return ret;
 }
 
@@ -336,12 +336,12 @@ int pvfs2_inode_setxattr(struct inode *inode, const char *prefix,
  * subsequent memory allocations. Thus our return value is always the size of
  * all the keys unless there were errors in fetching the keys!
  */
-ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
+ssize_t orangefs_listxattr(struct dentry *dentry, char *buffer, size_t size)
 {
 	struct inode *inode = dentry-&gt;d_inode;
-	struct pvfs2_inode_s *pvfs2_inode = PVFS2_I(inode);
-	struct pvfs2_kernel_op_s *new_op;
-	__u64 token = PVFS_ITERATE_START;
+	struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
+	struct orangefs_kernel_op_s *new_op;
+	__u64 token = ORANGEFS_ITERATE_START;
 	ssize_t ret = -ENOMEM;
 	ssize_t total = 0;
 	ssize_t length = 0;
@@ -358,8 +358,8 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 		return -EINVAL;
 	}
 
-	down_read(&amp;pvfs2_inode-&gt;xattr_sem);
-	new_op = op_alloc(PVFS2_VFS_OP_LISTXATTR);
+	down_read(&amp;orangefs_inode-&gt;xattr_sem);
+	new_op = op_alloc(ORANGEFS_VFS_OP_LISTXATTR);
 	if (!new_op)
 		goto out_unlock;
 
@@ -368,10 +368,10 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 
 try_again:
 	key_size = 0;
-	new_op-&gt;upcall.req.listxattr.refn = pvfs2_inode-&gt;refn;
+	new_op-&gt;upcall.req.listxattr.refn = orangefs_inode-&gt;refn;
 	new_op-&gt;upcall.req.listxattr.token = token;
 	new_op-&gt;upcall.req.listxattr.requested_count =
-	    (size == 0) ? 0 : PVFS_MAX_XATTR_LISTLEN;
+	    (size == 0) ? 0 : ORANGEFS_MAX_XATTR_LISTLEN;
 	ret = service_operation(new_op, __func__,
 				get_interruptible_flag(inode));
 	if (ret != 0)
@@ -384,7 +384,7 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 		 * up allocating memory rather than us...
 		 */
 		total = new_op-&gt;downcall.resp.listxattr.returned_count *
-			PVFS_MAX_XATTR_NAMELEN;
+			ORANGEFS_MAX_XATTR_NAMELEN;
 		goto done;
 	}
 
@@ -429,7 +429,7 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	 * fetching more keys!
 	 */
 	token = new_op-&gt;downcall.resp.listxattr.token;
-	if (token != PVFS_ITERATE_END)
+	if (token != ORANGEFS_ITERATE_END)
 		goto try_again;
 
 done:
@@ -443,88 +443,88 @@ ssize_t pvfs2_listxattr(struct dentry *dentry, char *buffer, size_t size)
 	if (ret == 0)
 		ret = total;
 out_unlock:
-	up_read(&amp;pvfs2_inode-&gt;xattr_sem);
+	up_read(&amp;orangefs_inode-&gt;xattr_sem);
 	return ret;
 }
 
-static int pvfs2_xattr_set_default(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   const void *buffer,
-				   size_t size,
-				   int flags)
+static int orangefs_xattr_set_default(const struct xattr_handler *handler,
+				      struct dentry *dentry,
+				      const char *name,
+				      const void *buffer,
+				      size_t size,
+				      int flags)
 {
-	return pvfs2_inode_setxattr(dentry-&gt;d_inode,
-				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+	return orangefs_inode_setxattr(dentry-&gt;d_inode,
+				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
 				    name,
 				    buffer,
 				    size,
 				    flags);
 }
 
-static int pvfs2_xattr_get_default(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   void *buffer,
-				   size_t size)
+static int orangefs_xattr_get_default(const struct xattr_handler *handler,
+				      struct dentry *dentry,
+				      const char *name,
+				      void *buffer,
+				      size_t size)
 {
-	return pvfs2_inode_getxattr(dentry-&gt;d_inode,
-				    PVFS2_XATTR_NAME_DEFAULT_PREFIX,
+	return orangefs_inode_getxattr(dentry-&gt;d_inode,
+				    ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
 				    name,
 				    buffer,
 				    size);
 
 }
 
-static int pvfs2_xattr_set_trusted(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   const void *buffer,
-				   size_t size,
-				   int flags)
+static int orangefs_xattr_set_trusted(const struct xattr_handler *handler,
+				     struct dentry *dentry,
+				     const char *name,
+				     const void *buffer,
+				     size_t size,
+				     int flags)
 {
-	return pvfs2_inode_setxattr(dentry-&gt;d_inode,
-				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,
+	return orangefs_inode_setxattr(dentry-&gt;d_inode,
+				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
 				    name,
 				    buffer,
 				    size,
 				    flags);
 }
 
-static int pvfs2_xattr_get_trusted(const struct xattr_handler *handler,
-				   struct dentry *dentry,
-				   const char *name,
-				   void *buffer,
-				   size_t size)
+static int orangefs_xattr_get_trusted(const struct xattr_handler *handler,
+				      struct dentry *dentry,
+				      const char *name,
+				      void *buffer,
+				      size_t size)
 {
-	return pvfs2_inode_getxattr(dentry-&gt;d_inode,
-				    PVFS2_XATTR_NAME_TRUSTED_PREFIX,
+	return orangefs_inode_getxattr(dentry-&gt;d_inode,
+				    ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
 				    name,
 				    buffer,
 				    size);
 }
 
-static struct xattr_handler pvfs2_xattr_trusted_handler = {
-	.prefix = PVFS2_XATTR_NAME_TRUSTED_PREFIX,
-	.get = pvfs2_xattr_get_trusted,
-	.set = pvfs2_xattr_set_trusted,
+static struct xattr_handler orangefs_xattr_trusted_handler = {
+	.prefix = ORANGEFS_XATTR_NAME_TRUSTED_PREFIX,
+	.get = orangefs_xattr_get_trusted,
+	.set = orangefs_xattr_set_trusted,
 };
 
-static struct xattr_handler pvfs2_xattr_default_handler = {
+static struct xattr_handler orangefs_xattr_default_handler = {
 	/*
 	 * NOTE: this is set to be the empty string.
 	 * so that all un-prefixed xattrs keys get caught
 	 * here!
 	 */
-	.prefix = PVFS2_XATTR_NAME_DEFAULT_PREFIX,
-	.get = pvfs2_xattr_get_default,
-	.set = pvfs2_xattr_set_default,
+	.prefix = ORANGEFS_XATTR_NAME_DEFAULT_PREFIX,
+	.get = orangefs_xattr_get_default,
+	.set = orangefs_xattr_set_default,
 };
 
-const struct xattr_handler *pvfs2_xattr_handlers[] = {
+const struct xattr_handler *orangefs_xattr_handlers[] = {
 	&amp;posix_acl_access_xattr_handler,
 	&amp;posix_acl_default_xattr_handler,
-	&amp;pvfs2_xattr_trusted_handler,
-	&amp;pvfs2_xattr_default_handler,
+	&amp;orangefs_xattr_trusted_handler,
+	&amp;orangefs_xattr_default_handler,
 	NULL
 };</pre><hr><pre>commit 786b4557075ae0d8a23e73c316dc4204b41ccb4d
Author: Bill Moss &lt;bmoss@clemson.edu&gt;
Date:   Thu Apr 17 16:03:40 2008 -0700

    iwlwifi: fix debug messages during scanning
    
    direct_mask will be set when we are not associated and requesting a
    direct scan. The second debug print will be confusing as priv-&gt;essid
    is not set at that time and it will thus print "&lt;hidden&gt;" while it is
    known to which AP a direct scan is requested - as previous debug message
    also indicates.
    
    Now make all debugging consistent.
    
    Signed-off-by: Bill Moss &lt;bmoss@clemson.edu&gt;
    Signed-off-by: Reinette Chatre &lt;reinette.chatre@intel.com&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl3945-base.c b/drivers/net/wireless/iwlwifi/iwl3945-base.c
index d723c474f810..13925b627e3b 100644
--- a/drivers/net/wireless/iwlwifi/iwl3945-base.c
+++ b/drivers/net/wireless/iwlwifi/iwl3945-base.c
@@ -6292,12 +6292,17 @@ static void iwl3945_bg_request_scan(struct work_struct *data)
 		       priv-&gt;direct_ssid, priv-&gt;direct_ssid_len);
 		direct_mask = 1;
 	} else if (!iwl3945_is_associated(priv) &amp;&amp; priv-&gt;essid_len) {
+		IWL_DEBUG_SCAN
+		  ("Kicking off one direct scan for '%s' when not associated\n",
+		   iwl3945_escape_essid(priv-&gt;essid, priv-&gt;essid_len));
 		scan-&gt;direct_scan[0].id = WLAN_EID_SSID;
 		scan-&gt;direct_scan[0].len = priv-&gt;essid_len;
 		memcpy(scan-&gt;direct_scan[0].ssid, priv-&gt;essid, priv-&gt;essid_len);
 		direct_mask = 1;
-	} else
+	} else {
+		IWL_DEBUG_SCAN("Kicking off one indirect scan.\n");
 		direct_mask = 0;
+	}
 
 	/* We don't build a direct scan probe request; the uCode will do
 	 * that based on the direct_mask added to each channel entry */
@@ -6335,23 +6340,18 @@ static void iwl3945_bg_request_scan(struct work_struct *data)
 	if (priv-&gt;iw_mode == IEEE80211_IF_TYPE_MNTR)
 		scan-&gt;filter_flags = RXON_FILTER_PROMISC_MSK;
 
-	if (direct_mask) {
-		IWL_DEBUG_SCAN
-		    ("Initiating direct scan for %s.\n",
-		     iwl3945_escape_essid(priv-&gt;essid, priv-&gt;essid_len));
+	if (direct_mask)
 		scan-&gt;channel_count =
 			iwl3945_get_channels_for_scan(
 				priv, band, 1, /* active */
 				direct_mask,
 				(void *)&amp;scan-&gt;data[le16_to_cpu(scan-&gt;tx_cmd.len)]);
-	} else {
-		IWL_DEBUG_SCAN("Initiating indirect scan.\n");
+	else
 		scan-&gt;channel_count =
 			iwl3945_get_channels_for_scan(
 				priv, band, 0, /* passive */
 				direct_mask,
 				(void *)&amp;scan-&gt;data[le16_to_cpu(scan-&gt;tx_cmd.len)]);
-	}
 
 	cmd.len += le16_to_cpu(scan-&gt;tx_cmd.len) +
 	    scan-&gt;channel_count * sizeof(struct iwl3945_scan_channel);
diff --git a/drivers/net/wireless/iwlwifi/iwl4965-base.c b/drivers/net/wireless/iwlwifi/iwl4965-base.c
index 6d077aff9cb6..883b42f7e998 100644
--- a/drivers/net/wireless/iwlwifi/iwl4965-base.c
+++ b/drivers/net/wireless/iwlwifi/iwl4965-base.c
@@ -5813,11 +5813,15 @@ static void iwl4965_bg_request_scan(struct work_struct *data)
 		       priv-&gt;direct_ssid, priv-&gt;direct_ssid_len);
 		direct_mask = 1;
 	} else if (!iwl_is_associated(priv) &amp;&amp; priv-&gt;essid_len) {
+		IWL_DEBUG_SCAN
+		  ("Kicking off one direct scan for '%s' when not associated\n",
+		   iwl4965_escape_essid(priv-&gt;essid, priv-&gt;essid_len));
 		scan-&gt;direct_scan[0].id = WLAN_EID_SSID;
 		scan-&gt;direct_scan[0].len = priv-&gt;essid_len;
 		memcpy(scan-&gt;direct_scan[0].ssid, priv-&gt;essid, priv-&gt;essid_len);
 		direct_mask = 1;
 	} else {
+		IWL_DEBUG_SCAN("Kicking off one indirect scan.\n");
 		direct_mask = 0;
 	}
 
@@ -5870,23 +5874,18 @@ static void iwl4965_bg_request_scan(struct work_struct *data)
 	if (priv-&gt;iw_mode == IEEE80211_IF_TYPE_MNTR)
 		scan-&gt;filter_flags = RXON_FILTER_PROMISC_MSK;
 
-	if (direct_mask) {
-		IWL_DEBUG_SCAN
-		    ("Initiating direct scan for %s.\n",
-		     iwl4965_escape_essid(priv-&gt;essid, priv-&gt;essid_len));
+	if (direct_mask)
 		scan-&gt;channel_count =
 			iwl4965_get_channels_for_scan(
 				priv, band, 1, /* active */
 				direct_mask,
 				(void *)&amp;scan-&gt;data[le16_to_cpu(scan-&gt;tx_cmd.len)]);
-	} else {
-		IWL_DEBUG_SCAN("Initiating indirect scan.\n");
+	else
 		scan-&gt;channel_count =
 			iwl4965_get_channels_for_scan(
 				priv, band, 0, /* passive */
 				direct_mask,
 				(void *)&amp;scan-&gt;data[le16_to_cpu(scan-&gt;tx_cmd.len)]);
-	}
 
 	cmd.len += le16_to_cpu(scan-&gt;tx_cmd.len) +
 	    scan-&gt;channel_count * sizeof(struct iwl4965_scan_channel);</pre><hr><pre>commit 107acb23ba763197d390ae9ffd347f3e2a524d39
Author: Bill Moss &lt;bmoss@clemson.edu&gt;
Date:   Wed Oct 10 16:23:55 2007 -0400

    [PATCH] mac80211: honor IW_SCAN_THIS_ESSID in siwscan ioctl
    
    This patch fixes the problem of associating with wpa_secured hidden
    AP.  Please try out.
    
    The original author of this patch is Bill Moss &lt;bmoss@clemson.edu&gt;
    
    Signed-off-by: Abhijeet Kolekar &lt;abhijeet.kolekar@intel.com&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/net/mac80211/ieee80211_ioctl.c b/net/mac80211/ieee80211_ioctl.c
index 6b4b0d5880db..a57fed77db27 100644
--- a/net/mac80211/ieee80211_ioctl.c
+++ b/net/mac80211/ieee80211_ioctl.c
@@ -511,32 +511,40 @@ static int ieee80211_ioctl_giwap(struct net_device *dev,
 
 static int ieee80211_ioctl_siwscan(struct net_device *dev,
 				   struct iw_request_info *info,
-				   struct iw_point *data, char *extra)
+				   union iwreq_data *wrqu, char *extra)
 {
 	struct ieee80211_local *local = wdev_priv(dev-&gt;ieee80211_ptr);
 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	struct iw_scan_req *req = NULL;
 	u8 *ssid = NULL;
 	size_t ssid_len = 0;
 
 	if (!netif_running(dev))
 		return -ENETDOWN;
 
-	switch (sdata-&gt;type) {
-	case IEEE80211_IF_TYPE_STA:
-	case IEEE80211_IF_TYPE_IBSS:
-		if (local-&gt;scan_flags &amp; IEEE80211_SCAN_MATCH_SSID) {
-			ssid = sdata-&gt;u.sta.ssid;
-			ssid_len = sdata-&gt;u.sta.ssid_len;
-		}
-		break;
-	case IEEE80211_IF_TYPE_AP:
-		if (local-&gt;scan_flags &amp; IEEE80211_SCAN_MATCH_SSID) {
-			ssid = sdata-&gt;u.ap.ssid;
-			ssid_len = sdata-&gt;u.ap.ssid_len;
+	if (wrqu-&gt;data.length == sizeof(struct iw_scan_req) &amp;&amp;
+	    wrqu-&gt;data.flags &amp; IW_SCAN_THIS_ESSID) {
+		req = (struct iw_scan_req *)extra;
+		ssid = req-&gt;essid;
+		ssid_len = req-&gt;essid_len;
+	} else {
+		switch (sdata-&gt;type) {
+		case IEEE80211_IF_TYPE_STA:
+		case IEEE80211_IF_TYPE_IBSS:
+			if (local-&gt;scan_flags &amp; IEEE80211_SCAN_MATCH_SSID) {
+				ssid = sdata-&gt;u.sta.ssid;
+				ssid_len = sdata-&gt;u.sta.ssid_len;
+			}
+			break;
+		case IEEE80211_IF_TYPE_AP:
+			if (local-&gt;scan_flags &amp; IEEE80211_SCAN_MATCH_SSID) {
+				ssid = sdata-&gt;u.ap.ssid;
+				ssid_len = sdata-&gt;u.ap.ssid_len;
+			}
+			break;
+		default:
+			return -EOPNOTSUPP;
 		}
-		break;
-	default:
-		return -EOPNOTSUPP;
 	}
 
 	return ieee80211_sta_req_scan(dev, ssid, ssid_len);</pre><hr><pre>commit b191608a451e75ed7f979cac268f5f423176feb3
Author: Bill Moss &lt;bmoss@clemson.edu&gt;
Date:   Wed Feb 15 08:50:18 2006 +0800

    [PATCH] ipw2200: Add signal level to iwlist scan output
    
    This patch does two things. It uses the parameter IW_QUAL_DBM which is new
    in WE-19 to cause signal level and noise to be reported in dBm by the
    wireless tools. It also defines the signal level as an unsigned integer
    so that the signal level will be reported by iwlist iface scan.
    
    Signed-off-by: Bill Moss &lt;bmoss@clemson.edu&gt;
    Signed-off-by: Zhu Yi &lt;yi.zhu@intel.com&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/drivers/net/wireless/ipw2200.c b/drivers/net/wireless/ipw2200.c
index b2bbdf982b01..c38d6a5fe9a3 100644
--- a/drivers/net/wireless/ipw2200.c
+++ b/drivers/net/wireless/ipw2200.c
@@ -7831,7 +7831,8 @@ static void ipw_rx(struct ipw_priv *priv)
 					    le16_to_cpu(pkt-&gt;u.frame.rssi_dbm) -
 					    IPW_RSSI_TO_DBM,
 					.signal =
-					    le16_to_cpu(pkt-&gt;u.frame.signal),
+					    le16_to_cpu(pkt-&gt;u.frame.rssi_dbm) -
+					    IPW_RSSI_TO_DBM + 0x100,
 					.noise =
 					    le16_to_cpu(pkt-&gt;u.frame.noise),
 					.rate = pkt-&gt;u.frame.rate,
@@ -8358,7 +8359,7 @@ static int ipw_wx_get_range(struct net_device *dev,
 	range-&gt;max_qual.qual = 100;
 	/* TODO: Find real max RSSI and stick here */
 	range-&gt;max_qual.level = 0;
-	range-&gt;max_qual.noise = priv-&gt;ieee-&gt;worst_rssi + 0x100;
+	range-&gt;max_qual.noise = 0;
 	range-&gt;max_qual.updated = 7;	/* Updated all three */
 
 	range-&gt;avg_qual.qual = 70;
@@ -9568,7 +9569,7 @@ static struct iw_statistics *ipw_get_wireless_stats(struct net_device *dev)
 	wstats-&gt;qual.level = average_value(&amp;priv-&gt;average_rssi);
 	wstats-&gt;qual.noise = average_value(&amp;priv-&gt;average_noise);
 	wstats-&gt;qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |
-	    IW_QUAL_NOISE_UPDATED;
+	    IW_QUAL_NOISE_UPDATED | IW_QUAL_DBM;
 
 	wstats-&gt;miss.beacon = average_value(&amp;priv-&gt;average_missed_beacons);
 	wstats-&gt;discard.retries = priv-&gt;last_tx_failures;</pre><hr><pre>commit f8a1af6bbc63218cabce742a7a291ac7c08bbd00
Author: Mike Murphy &lt;mamurph@cs.clemson.edu&gt;
Date:   Sun Feb 22 01:19:23 2009 -0500

    PATCH [2/2] Documentation/filesystems/sysfs.txt: fix descriptions of device attributes
    
    Fix descriptions of device attributes to be consistent with the actual
    implementations in include/linux/device.h
    
    Signed-off-by: Mike Murphy &lt;mamurph[at]cs.clemson.edu&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/Documentation/filesystems/sysfs.txt b/Documentation/filesystems/sysfs.txt
index 9e9c348275a9..7e81e37c0b1e 100644
--- a/Documentation/filesystems/sysfs.txt
+++ b/Documentation/filesystems/sysfs.txt
@@ -2,8 +2,10 @@
 sysfs - _The_ filesystem for exporting kernel objects. 
 
 Patrick Mochel	&lt;mochel@osdl.org&gt;
+Mike Murphy &lt;mamurph@cs.clemson.edu&gt;
 
-10 January 2003
+Revised:    22 February 2009
+Original:   10 January 2003
 
 
 What it is:
@@ -64,12 +66,13 @@ An attribute definition is simply:
 
 struct attribute {
         char                    * name;
+        struct module		*owner;
         mode_t                  mode;
 };
 
 
-int sysfs_create_file(struct kobject * kobj, struct attribute * attr);
-void sysfs_remove_file(struct kobject * kobj, struct attribute * attr);
+int sysfs_create_file(struct kobject * kobj, const struct attribute * attr);
+void sysfs_remove_file(struct kobject * kobj, const struct attribute * attr);
 
 
 A bare attribute contains no means to read or write the value of the
@@ -80,9 +83,11 @@ a specific object type.
 For example, the driver model defines struct device_attribute like:
 
 struct device_attribute {
-        struct attribute        attr;
-        ssize_t (*show)(struct device * dev, char * buf);
-        ssize_t (*store)(struct device * dev, const char * buf);
+	struct attribute	attr;
+	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
+			char *buf);
+	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count);
 };
 
 int device_create_file(struct device *, struct device_attribute *);
@@ -90,12 +95,8 @@ void device_remove_file(struct device *, struct device_attribute *);
 
 It also defines this helper for defining device attributes: 
 
-#define DEVICE_ATTR(_name, _mode, _show, _store)      \
-struct device_attribute dev_attr_##_name = {            \
-        .attr = {.name  = __stringify(_name) , .mode   = _mode },      \
-        .show   = _show,                                \
-        .store  = _store,                               \
-};
+#define DEVICE_ATTR(_name, _mode, _show, _store) \
+struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)
 
 For example, declaring
 
@@ -107,9 +108,9 @@ static struct device_attribute dev_attr_foo = {
        .attr	= {
 		.name = "foo",
 		.mode = S_IWUSR | S_IRUGO,
+		.show = show_foo,
+		.store = store_foo,
 	},
-	.show = show_foo,
-	.store = store_foo,
 };
 
 
@@ -161,10 +162,12 @@ To read or write attributes, show() or store() methods must be
 specified when declaring the attribute. The method types should be as
 simple as those defined for device attributes:
 
-        ssize_t (*show)(struct device * dev, char * buf);
-        ssize_t (*store)(struct device * dev, const char * buf);
+ssize_t (*show)(struct device * dev, struct device_attribute * attr,
+                char * buf);
+ssize_t (*store)(struct device * dev, struct device_attribute * attr,
+                 const char * buf);
 
-IOW, they should take only an object and a buffer as parameters. 
+IOW, they should take only an object, an attribute, and a buffer as parameters.
 
 
 sysfs allocates a buffer of size (PAGE_SIZE) and passes it to the
@@ -299,14 +302,16 @@ The following interface layers currently exist in sysfs:
 Structure:
 
 struct device_attribute {
-        struct attribute        attr;
-        ssize_t (*show)(struct device * dev, char * buf);
-        ssize_t (*store)(struct device * dev, const char * buf);
+	struct attribute	attr;
+	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
+			char *buf);
+	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count);
 };
 
 Declaring:
 
-DEVICE_ATTR(_name, _str, _mode, _show, _store);
+DEVICE_ATTR(_name, _mode, _show, _store);
 
 Creation/Removal:
 
@@ -342,7 +347,8 @@ Structure:
 struct driver_attribute {
         struct attribute        attr;
         ssize_t (*show)(struct device_driver *, char * buf);
-        ssize_t (*store)(struct device_driver *, const char * buf);
+        ssize_t (*store)(struct device_driver *, const char * buf,
+                         size_t count);
 };
 
 Declaring:</pre><hr><pre>commit 245127dbe9ea1e5a93aae0d3ede09992f1e99f53
Author: Mike Murphy &lt;mamurph@cs.clemson.edu&gt;
Date:   Sun Feb 22 01:17:14 2009 -0500

    PATCH [1/2] Documentation/driver-model/device.txt: fix struct device_attribute
    
    Fix the presented definition of struct device_attribute to match the
    actual definition in include/linux/device.h
    
    Signed-off-by: Mike Murphy &lt;mamurph[at]cs.clemson.edu&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/Documentation/driver-model/device.txt b/Documentation/driver-model/device.txt
index a05ec50f8004..a7cbfff40d07 100644
--- a/Documentation/driver-model/device.txt
+++ b/Documentation/driver-model/device.txt
@@ -127,9 +127,11 @@ void unlock_device(struct device * dev);
 Attributes
 ~~~~~~~~~~
 struct device_attribute {
-        struct attribute        attr;
-        ssize_t (*show)(struct device * dev, char * buf, size_t count, loff_t off);
-        ssize_t (*store)(struct device * dev, const char * buf, size_t count, loff_t off);
+	struct attribute	attr;
+	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
+			char *buf);
+	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count);
 };
 
 Attributes of devices can be exported via drivers using a simple</pre>
    <div class="pagination">
        <span>[1]</span>
    <div>
</body>
