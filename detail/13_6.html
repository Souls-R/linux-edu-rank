<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Washington</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Washington</h1>
    <div class="pagination">
        <a href='13_5.html'>&lt;&lt;Prev</a><a href='13.html'>1</a><a href='13_2.html'>2</a><a href='13_3.html'>3</a><a href='13_4.html'>4</a><a href='13_5.html'>5</a><span>[6]</span><a href='13_7.html'>7</a><a href='13_8.html'>8</a><a href='13_7.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 4263108c2a9028544cf4037fa4e72000ee456c33
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Mon Mar 21 15:27:34 2011 -0700

    iwlwifi: set default aggregation frame limit to 63
    
    This gives much better performance at fast 3x3 rates (up to ~160 Mbps).
    The scheduler will still make most decisions about batch size based on
    available packets and RX parameters.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Wey-Yi Guy &lt;wey-yi.w.guy@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-commands.h b/drivers/net/wireless/iwlwifi/iwl-commands.h
index 288391558afd..cc2151482f31 100644
--- a/drivers/net/wireless/iwlwifi/iwl-commands.h
+++ b/drivers/net/wireless/iwlwifi/iwl-commands.h
@@ -2132,7 +2132,7 @@ struct iwl_link_qual_general_params {
 #define LINK_QUAL_AGG_DISABLE_START_MAX	(255)
 #define LINK_QUAL_AGG_DISABLE_START_MIN	(0)
 
-#define LINK_QUAL_AGG_FRAME_LIMIT_DEF	(31)
+#define LINK_QUAL_AGG_FRAME_LIMIT_DEF	(63)
 #define LINK_QUAL_AGG_FRAME_LIMIT_MAX	(63)
 #define LINK_QUAL_AGG_FRAME_LIMIT_MIN	(0)
 </pre><hr><pre>commit 2520546aecc969372080448a2422b39eedb2a528
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Fri Mar 18 18:48:55 2011 -0700

    iwlwifi: add RATE_MCS_RATE_MSK
    
    Throughout the code we use rate_n_flags &amp; 0xff to extract the lower byte
    of the rate_n_flags u32 that contains the information about the rate.
    Add a #define and remove the use of the magic number.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Wey-Yi Guy &lt;wey-yi.w.guy@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-rs.c b/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
index 63b58ecb0dc6..e394e49228ba 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
@@ -115,13 +115,18 @@ const struct iwl_rate_info iwl_rates[IWL_RATE_COUNT] = {
 	/* FIXME:RS:          ^^    should be INV (legacy) */
 };
 
+static inline u8 rs_extract_rate(u32 rate_n_flags)
+{
+	return (u8)(rate_n_flags &amp; RATE_MCS_RATE_MSK);
+}
+
 static int iwl_hwrate_to_plcp_idx(u32 rate_n_flags)
 {
 	int idx = 0;
 
 	/* HT rate format */
 	if (rate_n_flags &amp; RATE_MCS_HT_MSK) {
-		idx = (rate_n_flags &amp; 0xff);
+		idx = rs_extract_rate(rate_n_flags);
 
 		if (idx &gt;= IWL_RATE_MIMO3_6M_PLCP)
 			idx = idx - IWL_RATE_MIMO3_6M_PLCP;
@@ -138,7 +143,8 @@ static int iwl_hwrate_to_plcp_idx(u32 rate_n_flags)
 	/* legacy rate format, search for match in table */
 	} else {
 		for (idx = 0; idx &lt; ARRAY_SIZE(iwl_rates); idx++)
-			if (iwl_rates[idx].plcp == (rate_n_flags &amp; 0xFF))
+			if (iwl_rates[idx].plcp ==
+					rs_extract_rate(rate_n_flags))
 				return idx;
 	}
 
@@ -239,11 +245,6 @@ static const struct iwl_rate_mcs_info iwl_rate_mcs[IWL_RATE_COUNT] = {
 
 #define MCS_INDEX_PER_STREAM	(8)
 
-static inline u8 rs_extract_rate(u32 rate_n_flags)
-{
-	return (u8)(rate_n_flags &amp; 0xFF);
-}
-
 static void rs_rate_scale_clear_window(struct iwl_rate_scale_data *window)
 {
 	window-&gt;data = 0;
diff --git a/drivers/net/wireless/iwlwifi/iwl-agn.h b/drivers/net/wireless/iwlwifi/iwl-agn.h
index 4f7c9ce9d8bd..39313acb9cc7 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn.h
+++ b/drivers/net/wireless/iwlwifi/iwl-agn.h
@@ -310,7 +310,7 @@ static inline u32 iwl_ant_idx_to_flags(u8 ant_idx)
 
 static inline u8 iwl_hw_get_rate(__le32 rate_n_flags)
 {
-	return le32_to_cpu(rate_n_flags) &amp; 0xFF;
+	return le32_to_cpu(rate_n_flags) &amp; RATE_MCS_RATE_MSK;
 }
 
 static inline __le32 iwl_hw_set_rate_n_flags(u8 rate, u32 flags)
diff --git a/drivers/net/wireless/iwlwifi/iwl-commands.h b/drivers/net/wireless/iwlwifi/iwl-commands.h
index ca42ffa63ed7..288391558afd 100644
--- a/drivers/net/wireless/iwlwifi/iwl-commands.h
+++ b/drivers/net/wireless/iwlwifi/iwl-commands.h
@@ -324,6 +324,8 @@ struct iwl3945_power_per_rate {
 #define RATE_MCS_SPATIAL_MSK 0x18
 #define RATE_MCS_HT_DUP_POS 5
 #define RATE_MCS_HT_DUP_MSK 0x20
+/* Both legacy and HT use bits 7:0 as the CCK/OFDM rate or HT MCS */
+#define RATE_MCS_RATE_MSK 0xff
 
 /* Bit 8: (1) HT format, (0) legacy format in bits 7:0 */
 #define RATE_MCS_FLAGS_POS 8</pre><hr><pre>commit d0eb633431ec922f8f9b2040f46d9b42a4cec193
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Wed Mar 16 17:17:36 2011 -0700

    iwlwifi: cleanup and bugfix tx aggregation code
    
    Since the driver split, there's no need for no_agg_framecnt_info since
    all devices have this set to false. Secondly, the compressed block ack
    handling code was broken. Fix this.
    
    (1) A shift less than zero simply implies that the buffer wrapped, this
    is expected. Remove the incorrect comment.
    
    (2) The (agg-&gt;frame_count &gt; (64-sh)) condition can happen if the last
    frame is dropped. E.g., if I send 7 frames and the 6th is received but
    the 7th is lost, the other side may only shift the window 6, not 7
    frames since the last bit is a 0. This is perfectly fine behavior and
    doesn't invalidate the feedback.
    
    (3) Store the feedback from a Compressed BA in the first newly received
    frame, rather than the start of the window. This way it will get
    processed by the rate selection code. Feedback stored in a non-received
    frame is likely to get overwritten by the retransmission.
        This is based on the approach taken by minstrel_ht.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Wey-Yi Guy &lt;wey-yi.w.guy@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-tx.c b/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
index fb63a03a395e..cb8eacd5fdb5 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
@@ -1263,11 +1263,11 @@ static int iwlagn_tx_status_reply_compressed_ba(struct iwl_priv *priv,
 				 struct iwl_compressed_ba_resp *ba_resp)
 
 {
-	int i, sh, ack;
+	int sh;
 	u16 seq_ctl = le16_to_cpu(ba_resp-&gt;seq_ctl);
 	u16 scd_flow = le16_to_cpu(ba_resp-&gt;scd_flow);
-	int successes = 0;
 	struct ieee80211_tx_info *info;
+	u64 bitmap, sent_bitmap;
 
 	if (unlikely(!agg-&gt;wait_for_ba))  {
 		if (unlikely(ba_resp-&gt;bitmap))
@@ -1281,70 +1281,42 @@ static int iwlagn_tx_status_reply_compressed_ba(struct iwl_priv *priv,
 
 	/* Calculate shift to align block-ack bits with our Tx window bits */
 	sh = agg-&gt;start_idx - SEQ_TO_INDEX(seq_ctl &gt;&gt; 4);
-	if (sh &lt; 0) /* tbw something is wrong with indices */
+	if (sh &lt; 0)
 		sh += 0x100;
 
-	if (agg-&gt;frame_count &gt; (64 - sh)) {
-		IWL_DEBUG_TX_REPLY(priv, "more frames than bitmap size");
-		return -1;
-	}
-	if (!priv-&gt;cfg-&gt;base_params-&gt;no_agg_framecnt_info &amp;&amp; ba_resp-&gt;txed) {
+	/*
+	 * Check for success or failure according to the
+	 * transmitted bitmap and block-ack bitmap
+	 */
+	bitmap = le64_to_cpu(ba_resp-&gt;bitmap) &gt;&gt; sh;
+	sent_bitmap = bitmap &amp; agg-&gt;bitmap;
+
+	/* Sanity check values reported by uCode */
+	if (ba_resp-&gt;txed_2_done &gt; ba_resp-&gt;txed) {
+		IWL_DEBUG_TX_REPLY(priv,
+			"bogus sent(%d) and ack(%d) count\n",
+			ba_resp-&gt;txed, ba_resp-&gt;txed_2_done);
 		/*
-		 * sent and ack information provided by uCode
-		 * use it instead of figure out ourself
+		 * set txed_2_done = txed,
+		 * so it won't impact rate scale
 		 */
-		if (ba_resp-&gt;txed_2_done &gt; ba_resp-&gt;txed) {
-			IWL_DEBUG_TX_REPLY(priv,
-				"bogus sent(%d) and ack(%d) count\n",
-				ba_resp-&gt;txed, ba_resp-&gt;txed_2_done);
-			/*
-			 * set txed_2_done = txed,
-			 * so it won't impact rate scale
-			 */
-			ba_resp-&gt;txed = ba_resp-&gt;txed_2_done;
-		}
-		IWL_DEBUG_HT(priv, "agg frames sent:%d, acked:%d\n",
-				ba_resp-&gt;txed, ba_resp-&gt;txed_2_done);
-	} else {
-		u64 bitmap, sent_bitmap;
-
-		/* don't use 64-bit values for now */
-		bitmap = le64_to_cpu(ba_resp-&gt;bitmap) &gt;&gt; sh;
-
-		/* check for success or failure according to the
-		 * transmitted bitmap and block-ack bitmap */
-		sent_bitmap = bitmap &amp; agg-&gt;bitmap;
-
-		/* For each frame attempted in aggregation,
-		 * update driver's record of tx frame's status. */
-		i = 0;
-		while (sent_bitmap) {
-			ack = sent_bitmap &amp; 1ULL;
-			successes += ack;
-			IWL_DEBUG_TX_REPLY(priv, "%s ON i=%d idx=%d raw=%d\n",
-				ack ? "ACK" : "NACK", i,
-				(agg-&gt;start_idx + i) &amp; 0xff,
-				agg-&gt;start_idx + i);
-			sent_bitmap &gt;&gt;= 1;
-			++i;
-		}
+		ba_resp-&gt;txed = ba_resp-&gt;txed_2_done;
+	}
+	IWL_DEBUG_HT(priv, "agg frames sent:%d, acked:%d\n",
+			ba_resp-&gt;txed, ba_resp-&gt;txed_2_done);
 
-		IWL_DEBUG_TX_REPLY(priv, "Bitmap %llx\n",
-				   (unsigned long long)bitmap);
+	/* Find the first ACKed frame to store the TX status */
+	while (sent_bitmap &amp;&amp; !(sent_bitmap &amp; 1)) {
+		agg-&gt;start_idx = (agg-&gt;start_idx + 1) &amp; 0xff;
+		sent_bitmap &gt;&gt;= 1;
 	}
 
 	info = IEEE80211_SKB_CB(priv-&gt;txq[scd_flow].txb[agg-&gt;start_idx].skb);
 	memset(&amp;info-&gt;status, 0, sizeof(info-&gt;status));
 	info-&gt;flags |= IEEE80211_TX_STAT_ACK;
 	info-&gt;flags |= IEEE80211_TX_STAT_AMPDU;
-	if (!priv-&gt;cfg-&gt;base_params-&gt;no_agg_framecnt_info &amp;&amp; ba_resp-&gt;txed) {
-		info-&gt;status.ampdu_ack_len = ba_resp-&gt;txed_2_done;
-		info-&gt;status.ampdu_len = ba_resp-&gt;txed;
-
-	} else {
-		info-&gt;status.ampdu_ack_len = successes;
-		info-&gt;status.ampdu_len = agg-&gt;frame_count;
-	}
+	info-&gt;status.ampdu_ack_len = ba_resp-&gt;txed_2_done;
+	info-&gt;status.ampdu_len = ba_resp-&gt;txed;
 	iwlagn_hwrate_to_tx_control(priv, agg-&gt;rate_n_flags, info);
 
 	return 0;
diff --git a/drivers/net/wireless/iwlwifi/iwl-core.h b/drivers/net/wireless/iwlwifi/iwl-core.h
index 1f4f6dd18009..3e680af7ff70 100644
--- a/drivers/net/wireless/iwlwifi/iwl-core.h
+++ b/drivers/net/wireless/iwlwifi/iwl-core.h
@@ -281,8 +281,6 @@ struct iwl_mod_params {
  * @chain_noise_calib_by_driver: driver has the capability to perform
  *	chain noise calibration operation
  * @shadow_reg_enable: HW shadhow register bit
- * @no_agg_framecnt_info: uCode do not provide aggregation frame count
- *	information
  */
 struct iwl_base_params {
 	int eeprom_size;
@@ -312,7 +310,6 @@ struct iwl_base_params {
 	const bool sensitivity_calib_by_driver;
 	const bool chain_noise_calib_by_driver;
 	const bool shadow_reg_enable;
-	const bool no_agg_framecnt_info;
 };
 /*
  * @advanced_bt_coexist: support advanced bt coexist</pre><hr><pre>commit 374920cb0512f5938fdf1f5af4f9afa7502dd0f9
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Wed Mar 16 19:16:36 2011 -0700

    iwlwifi: limit number of attempts for highest HT rate
    
    When filling out its rate scale table, iwlwifi repeats the first HT rate
    IWL_HT_NUMBER_TRY times. The hardware scheduler will stop using
    aggregation for any frame that fails LINK_QUAL_AGG_DISABLE_START_DEF
    times. Currently, both these constants equal 3.
    
    If iwlwifi probes a faster rate than the link supports, all frames in a
    (potentially tens of frames large) batch will fail IWL_HT_NUMBER_TRY
    times. Because this happens to be as large as
    LINK_QUAL_AGG_DISABLE_START_DEF, all frames will then be sent
    individually. This leads to a short, but performance-degrading window
    where the legacy stop-and-wait MAC takes over.
    
    Bounding the initial rate by (LINK_QUAL_AGG_DISABLE_START_DEF-1)
    attempts makes the third try use a lower rate and hence more be likely
    to succeed. This somewhat mitigates the above described behavior.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Wey-Yi Guy &lt;wey-yi.w.guy@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-rs.c b/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
index d03b4734c892..63b58ecb0dc6 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
@@ -2912,7 +2912,8 @@ static void rs_fill_link_cmd(struct iwl_priv *priv,
 		ant_toggle_cnt = 1;
 		repeat_rate = IWL_NUMBER_TRY;
 	} else {
-		repeat_rate = IWL_HT_NUMBER_TRY;
+		repeat_rate = min(IWL_HT_NUMBER_TRY,
+				  LINK_QUAL_AGG_DISABLE_START_DEF - 1);
 	}
 
 	lq_cmd-&gt;general_params.mimo_delimiter =</pre><hr><pre>commit 8d5eab5aa676378b4c9daa62d10d08a0bca04677
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Wed Mar 9 03:10:18 2011 -0800

    mac80211: update minstrel_ht sample rate when probe is set
    
    Waiting until the status is received can cause the same rate to be
    probed multiple times consecutively.
    
    Cc: Felix Fietkau &lt;nbd@openwrt.org&gt;
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index 775cf155e94b..bce14fbfc3b6 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -415,10 +415,8 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 		mi-&gt;sample_count--;
 	}
 
-	if (info-&gt;flags &amp; IEEE80211_TX_CTL_RATE_CTRL_PROBE) {
+	if (info-&gt;flags &amp; IEEE80211_TX_CTL_RATE_CTRL_PROBE)
 		mi-&gt;sample_packets += info-&gt;status.ampdu_len;
-		minstrel_next_sample_idx(mi);
-	}
 
 	for (i = 0; !last; i++) {
 		last = (i == IEEE80211_TX_MAX_RATES - 1) ||
@@ -551,13 +549,14 @@ minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 	sample_idx = sample_table[mg-&gt;column][mg-&gt;index];
 	mr = &amp;mg-&gt;rates[sample_idx];
 	sample_idx += mi-&gt;sample_group * MCS_GROUP_RATES;
+	minstrel_next_sample_idx(mi);
 
 	/*
 	 * When not using MRR, do not sample if the probability is already
 	 * higher than 95% to avoid wasting airtime
 	 */
 	if (!mp-&gt;has_mrr &amp;&amp; (mr-&gt;probability &gt; MINSTREL_FRAC(95, 100)))
-		goto next;
+		return -1;
 
 	/*
 	 * Make sure that lower rates get sampled only occasionally,
@@ -566,17 +565,13 @@ minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 	if (minstrel_get_duration(sample_idx) &gt;
 	    minstrel_get_duration(mi-&gt;max_tp_rate)) {
 		if (mr-&gt;sample_skipped &lt; 20)
-			goto next;
+			return -1;
 
 		if (mi-&gt;sample_slow++ &gt; 2)
-			goto next;
+			return -1;
 	}
 
 	return sample_idx;
-
-next:
-	minstrel_next_sample_idx(mi);
-	return -1;
 }
 
 static void</pre><hr><pre>commit 278c2f6faafebe28b9776918ce5fbaef9795c141
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Mon Jun 14 13:10:29 2010 -0700

    iwlwifi: update LQ for bcast station on channel change
    
    The rate table in the bcast LQ is computed only when the station is
    allocated, and chooses the lowest rate for the band. Because of when this
    occurs, this is the 2.4 GHz band and uses the 0x420a (CCK, 1 Mbps) rate. In 5 GHz
    beaconing mode, this rate will prevent beacons from being sent and any other
    packets from being received.
    
    We can fix this by re-initializing the bcast station's LQ command when the
    channel is changed.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Reinette Chatre &lt;reinette.chatre@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-1000.c b/drivers/net/wireless/iwlwifi/iwl-1000.c
index 24743b97ba35..1daf159914ad 100644
--- a/drivers/net/wireless/iwlwifi/iwl-1000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-1000.c
@@ -217,6 +217,7 @@ static struct iwl_lib_ops iwl1000_lib = {
 		.set_ct_kill = iwl1000_set_ct_threshold,
 	 },
 	.manage_ibss_station = iwlagn_manage_ibss_station,
+	.update_bcast_station = iwl_update_bcast_station,
 	.debugfs_ops = {
 		.rx_stats_read = iwl_ucode_rx_stats_read,
 		.tx_stats_read = iwl_ucode_tx_stats_read,
diff --git a/drivers/net/wireless/iwlwifi/iwl-4965.c b/drivers/net/wireless/iwlwifi/iwl-4965.c
index 67526a1be025..1dd3bc4c107e 100644
--- a/drivers/net/wireless/iwlwifi/iwl-4965.c
+++ b/drivers/net/wireless/iwlwifi/iwl-4965.c
@@ -2280,6 +2280,7 @@ static struct iwl_lib_ops iwl4965_lib = {
 		.set_ct_kill = iwl4965_set_ct_threshold,
 	},
 	.manage_ibss_station = iwlagn_manage_ibss_station,
+	.update_bcast_station = iwl_update_bcast_station,
 	.debugfs_ops = {
 		.rx_stats_read = iwl_ucode_rx_stats_read,
 		.tx_stats_read = iwl_ucode_tx_stats_read,
diff --git a/drivers/net/wireless/iwlwifi/iwl-5000.c b/drivers/net/wireless/iwlwifi/iwl-5000.c
index fa2dbb56177c..b8f3e20f2c80 100644
--- a/drivers/net/wireless/iwlwifi/iwl-5000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-5000.c
@@ -393,6 +393,7 @@ static struct iwl_lib_ops iwl5000_lib = {
 		.set_ct_kill = iwl5000_set_ct_threshold,
 	 },
 	.manage_ibss_station = iwlagn_manage_ibss_station,
+	.update_bcast_station = iwl_update_bcast_station,
 	.debugfs_ops = {
 		.rx_stats_read = iwl_ucode_rx_stats_read,
 		.tx_stats_read = iwl_ucode_tx_stats_read,
@@ -455,6 +456,7 @@ static struct iwl_lib_ops iwl5150_lib = {
 		.set_ct_kill = iwl5150_set_ct_threshold,
 	 },
 	.manage_ibss_station = iwlagn_manage_ibss_station,
+	.update_bcast_station = iwl_update_bcast_station,
 	.debugfs_ops = {
 		.rx_stats_read = iwl_ucode_rx_stats_read,
 		.tx_stats_read = iwl_ucode_tx_stats_read,
diff --git a/drivers/net/wireless/iwlwifi/iwl-6000.c b/drivers/net/wireless/iwlwifi/iwl-6000.c
index c909a9c5e5e1..61cf0b3e88c2 100644
--- a/drivers/net/wireless/iwlwifi/iwl-6000.c
+++ b/drivers/net/wireless/iwlwifi/iwl-6000.c
@@ -318,6 +318,7 @@ static struct iwl_lib_ops iwl6000_lib = {
 		.set_calib_version = iwl6000_set_calib_version,
 	 },
 	.manage_ibss_station = iwlagn_manage_ibss_station,
+	.update_bcast_station = iwl_update_bcast_station,
 	.debugfs_ops = {
 		.rx_stats_read = iwl_ucode_rx_stats_read,
 		.tx_stats_read = iwl_ucode_tx_stats_read,
diff --git a/drivers/net/wireless/iwlwifi/iwl-core.c b/drivers/net/wireless/iwlwifi/iwl-core.c
index 329e5107b5c3..f47a58ff3252 100644
--- a/drivers/net/wireless/iwlwifi/iwl-core.c
+++ b/drivers/net/wireless/iwlwifi/iwl-core.c
@@ -2110,6 +2110,9 @@ int iwl_mac_config(struct ieee80211_hw *hw, u32 changed)
 		iwl_set_flags_for_band(priv, conf-&gt;channel-&gt;band, priv-&gt;vif);
 		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
 
+		if (priv-&gt;cfg-&gt;ops-&gt;lib-&gt;update_bcast_station)
+			ret = priv-&gt;cfg-&gt;ops-&gt;lib-&gt;update_bcast_station(priv);
+
  set_ch_out:
 		/* The list of supported rates and rate mask can be different
 		 * for each band; since the band may have changed, reset
diff --git a/drivers/net/wireless/iwlwifi/iwl-core.h b/drivers/net/wireless/iwlwifi/iwl-core.h
index cdcb51d8bc21..15930e064022 100644
--- a/drivers/net/wireless/iwlwifi/iwl-core.h
+++ b/drivers/net/wireless/iwlwifi/iwl-core.h
@@ -196,6 +196,7 @@ struct iwl_lib_ops {
 	/* station management */
 	int (*manage_ibss_station)(struct iwl_priv *priv,
 				   struct ieee80211_vif *vif, bool add);
+	int (*update_bcast_station)(struct iwl_priv *priv);
 	/* recover from tx queue stall */
 	void (*recover_from_tx_stall)(unsigned long data);
 	/* check for plcp health */
diff --git a/drivers/net/wireless/iwlwifi/iwl-sta.c b/drivers/net/wireless/iwlwifi/iwl-sta.c
index 6a9cd08bd449..9511f03f07e0 100644
--- a/drivers/net/wireless/iwlwifi/iwl-sta.c
+++ b/drivers/net/wireless/iwlwifi/iwl-sta.c
@@ -1259,6 +1259,36 @@ int iwl_alloc_bcast_station(struct iwl_priv *priv, bool init_lq)
 }
 EXPORT_SYMBOL_GPL(iwl_alloc_bcast_station);
 
+/**
+ * iwl_update_bcast_station - update broadcast station's LQ command
+ *
+ * Only used by iwlagn. Placed here to have all bcast station management
+ * code together.
+ */
+int iwl_update_bcast_station(struct iwl_priv *priv)
+{
+	unsigned long flags;
+	struct iwl_link_quality_cmd *link_cmd;
+	u8 sta_id = priv-&gt;hw_params.bcast_sta_id;
+
+	link_cmd = iwl_sta_alloc_lq(priv, sta_id);
+	if (!link_cmd) {
+		IWL_ERR(priv, "Unable to initialize rate scaling for bcast station.\n");
+		return -ENOMEM;
+	}
+
+	spin_lock_irqsave(&amp;priv-&gt;sta_lock, flags);
+	if (priv-&gt;stations[sta_id].lq)
+		kfree(priv-&gt;stations[sta_id].lq);
+	else
+		IWL_DEBUG_INFO(priv, "Bcast station rate scaling has not been initialized yet.\n");
+	priv-&gt;stations[sta_id].lq = link_cmd;
+	spin_unlock_irqrestore(&amp;priv-&gt;sta_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iwl_update_bcast_station);
+
 void iwl_dealloc_bcast_station(struct iwl_priv *priv)
 {
 	unsigned long flags;
diff --git a/drivers/net/wireless/iwlwifi/iwl-sta.h b/drivers/net/wireless/iwlwifi/iwl-sta.h
index 619bb99d85cf..ba95b1a590a5 100644
--- a/drivers/net/wireless/iwlwifi/iwl-sta.h
+++ b/drivers/net/wireless/iwlwifi/iwl-sta.h
@@ -60,6 +60,7 @@ void iwl_restore_stations(struct iwl_priv *priv);
 void iwl_clear_ucode_stations(struct iwl_priv *priv);
 int iwl_alloc_bcast_station(struct iwl_priv *priv, bool init_lq);
 void iwl_dealloc_bcast_station(struct iwl_priv *priv);
+int iwl_update_bcast_station(struct iwl_priv *priv);
 int iwl_get_free_ucode_key_index(struct iwl_priv *priv);
 int iwl_send_add_sta(struct iwl_priv *priv,
 		     struct iwl_addsta_cmd *sta, u8 flags);</pre><hr><pre>commit f668da2f150948a961d359c65b5e9d62da1290e2
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Tue May 25 10:22:49 2010 -0700

    iwlwifi: fix wrapping when handling aggregated batches
    
    Fairly complex code in iwlagn_tx_status_reply_tx handle the status reports for
    aggregated packet batches sent by the NIC. This code aims to handle the case
    where the NIC retransmits failed packets from a previous batch; the status
    information for these packets can sometimes be inserted in the middle of a
    batch and are actually not in order by sequence number! (I verified this can
    happen with printk's in the function.)
    
    The code in question adaptively identifies the "first" frame of the batch,
    taking into account that it may not be the one corresponding to the first agg
    status report, and also handles the case when the set of sent packets wraps the
    256-character entry buffer. It generates the agg-&gt;bitmap field of sent packets
    which is later compared to the BlockAck response from the receiver to see which
    frames of those sent in this batch were ACKed. A small logic error (wrapping by
    0xff==255 instead of 0x100==256) was causing the agg-&gt;bitmap to be set
    incorrectly.
    
    Fix this wrapping code, and add extensive comments to clarify what is going on.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Reinette Chatre &lt;reinette.chatre@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-lib.c b/drivers/net/wireless/iwlwifi/iwl-agn-lib.c
index d339881e1d8f..3577c1eeb77b 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-lib.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-lib.c
@@ -93,6 +93,12 @@ static int iwlagn_tx_status_reply_tx(struct iwl_priv *priv,
 	} else {
 		/* Two or more frames were attempted; expect block-ack */
 		u64 bitmap = 0;
+
+		/*
+		 * Start is the lowest frame sent. It may not be the first
+		 * frame in the batch; we figure this out dynamically during
+		 * the following loop.
+		 */
 		int start = agg-&gt;start_idx;
 
 		/* Construct bit-map of pending frames within Tx window */
@@ -131,25 +137,58 @@ static int iwlagn_tx_status_reply_tx(struct iwl_priv *priv,
 			IWL_DEBUG_TX_REPLY(priv, "AGG Frame i=%d idx %d seq=%d\n",
 					   i, idx, SEQ_TO_SN(sc));
 
+			/*
+			 * sh -&gt; how many frames ahead of the starting frame is
+			 * the current one?
+			 *
+			 * Note that all frames sent in the batch must be in a
+			 * 64-frame window, so this number should be in [0,63].
+			 * If outside of this window, then we've found a new
+			 * "first" frame in the batch and need to change start.
+			 */
 			sh = idx - start;
-			if (sh &gt; 64) {
-				sh = (start - idx) + 0xff;
+
+			/*
+			 * If &gt;= 64, out of window. start must be at the front
+			 * of the circular buffer, idx must be near the end of
+			 * the buffer, and idx is the new "first" frame. Shift
+			 * the indices around.
+			 */
+			if (sh &gt;= 64) {
+				/* Shift bitmap by start - idx, wrapped */
+				sh = 0x100 - idx + start;
 				bitmap = bitmap &lt;&lt; sh;
+				/* Now idx is the new start so sh = 0 */
 				sh = 0;
 				start = idx;
-			} else if (sh &lt; -64)
-				sh  = 0xff - (start - idx);
-			else if (sh &lt; 0) {
+			/*
+			 * If &lt;= -64 then wraps the 256-pkt circular buffer
+			 * (e.g., start = 255 and idx = 0, sh should be 1)
+			 */
+			} else if (sh &lt;= -64) {
+				sh  = 0x100 - start + idx;
+			/*
+			 * If &lt; 0 but &gt; -64, out of window. idx is before start
+			 * but not wrapped. Shift the indices around.
+			 */
+			} else if (sh &lt; 0) {
+				/* Shift by how far start is ahead of idx */
 				sh = start - idx;
-				start = idx;
 				bitmap = bitmap &lt;&lt; sh;
+				/* Now idx is the new start so sh = 0 */
+				start = idx;
 				sh = 0;
 			}
+			/* Sequence number start + sh was sent in this batch */
 			bitmap |= 1ULL &lt;&lt; sh;
 			IWL_DEBUG_TX_REPLY(priv, "start=%d bitmap=0x%llx\n",
 					   start, (unsigned long long)bitmap);
 		}
 
+		/*
+		 * Store the bitmap and possibly the new start, if we wrapped
+		 * the buffer above
+		 */
 		agg-&gt;bitmap = bitmap;
 		agg-&gt;start_idx = start;
 		IWL_DEBUG_TX_REPLY(priv, "Frames %d start_idx=%d bitmap=0x%llx\n",</pre><hr><pre>commit 02cd8dee6e10d6ab7161a3c6f36a60f8894fafdd
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Mon May 24 18:41:30 2010 -0700

    iwlwifi: parse block ack responses correctly
    
    Compressed BlockAck frames store the ACKs/NACKs in a 64-bit bitmap that starts
    at the sequence number of the first frame sent in the aggregated batch. Note
    that this is a selective ACKnowledgement following selective retransmission;
    e.g., if frames 1,4-5 in a batch are ACKed then the next transmission will
    include frames 2-3,6-10 (7 frames). In this latter case, the Compressed
    BlockAck will not have all meaningful information in the low order bits -- the
    semantically meaningful bits of the BA will be 0x1f3 (where the low-order frame
    is seq 2).
    
    The driver code originally just looked at the lower (in this case, 7) bits of
    the BlockAck. In this case, the lower 7 bits of 0x1f3 =&gt; only 5 packets,
    maximum, could ever be ACKed. In reality it should be looking at all of the
    bits, filtered by those corresponding to packets that were actually sent. This
    flaw meant that the number of correctly ACked packets could be significantly
    underreported and might result in asynchronous state between TX and RX sides as
    well as driver and uCode.
    
    Fix this and also add a shortcut that doesn't require the code to loop through
    all 64 bits of the bitmap but rather stops when no higher packets are ACKed.
    
    In my experiments this fix greatly reduces throughput swing, making throughput
    stable and high. It is also likely related to some of the stalls observed in
    aggregation mode and maybe some of the buffer underruns observed, e.g.,
    
    http://bugzilla.intellinuxwireless.org/show_bug.cgi?id=1968
    http://bugzilla.intellinuxwireless.org/show_bug.cgi?id=2098
    http://bugzilla.intellinuxwireless.org/show_bug.cgi?id=2018
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Reinette Chatre &lt;reinette.chatre@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-tx.c b/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
index 0d3e13b2442f..10a0acdb9dd4 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
@@ -1208,7 +1208,7 @@ static int iwlagn_tx_status_reply_compressed_ba(struct iwl_priv *priv,
 	int i, sh, ack;
 	u16 seq_ctl = le16_to_cpu(ba_resp-&gt;seq_ctl);
 	u16 scd_flow = le16_to_cpu(ba_resp-&gt;scd_flow);
-	u64 bitmap;
+	u64 bitmap, sent_bitmap;
 	int successes = 0;
 	struct ieee80211_tx_info *info;
 
@@ -1236,16 +1236,19 @@ static int iwlagn_tx_status_reply_compressed_ba(struct iwl_priv *priv,
 
 	/* check for success or failure according to the
 	 * transmitted bitmap and block-ack bitmap */
-	bitmap &amp;= agg-&gt;bitmap;
+	sent_bitmap = bitmap &amp; agg-&gt;bitmap;
 
 	/* For each frame attempted in aggregation,
 	 * update driver's record of tx frame's status. */
-	for (i = 0; i &lt; agg-&gt;frame_count ; i++) {
-		ack = bitmap &amp; (1ULL &lt;&lt; i);
-		successes += !!ack;
+	i = 0;
+	while (sent_bitmap) {
+		ack = sent_bitmap &amp; 1ULL;
+		successes += ack;
 		IWL_DEBUG_TX_REPLY(priv, "%s ON i=%d idx=%d raw=%d\n",
 			ack ? "ACK" : "NACK", i, (agg-&gt;start_idx + i) &amp; 0xff,
 			agg-&gt;start_idx + i);
+		sent_bitmap &gt;&gt;= 1;
+		++i;
 	}
 
 	info = IEEE80211_SKB_CB(priv-&gt;txq[scd_flow].txb[agg-&gt;start_idx].skb);</pre><hr><pre>commit e3a3cd8789e1daf1b5af70d3252cab50cd3824c9
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Sun Apr 18 09:27:58 2010 -0700

    iwlwifi: set AMPDU status variables correctly
    
    The TX status code is currently abusing the ampdu_ack_map field (a bitmap) to
    count the number of successfully received frames.  The comments in mac80211.h
    show there are actually three different, relevant variables, of which we are
    currently using two, both incorrectly. Fix this by making
    
    - ampdu_ack_len -&gt; the number of ACKed frames (i.e. successes)
    - ampdu_ack_map -&gt; the bitmap
    - ampdu_len -&gt; the total number of frames sent (i.e., attempts)
    
    to match the header file (and verified with ath9k's usage) and updating Intel's
    RS code to match.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: Reinette Chatre &lt;reinette.chatre@intel.com&gt;

diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-rs.c b/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
index 8f8d5e3e688d..f01f242659c3 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-rs.c
@@ -867,14 +867,14 @@ static void rs_tx_status(void *priv_r, struct ieee80211_supported_band *sband,
 		rs_get_tbl_info_from_mcs(tx_rate, priv-&gt;band, &amp;tbl_type,
 				&amp;rs_index);
 		rs_collect_tx_data(curr_tbl, rs_index,
-				   info-&gt;status.ampdu_ack_len,
-				   info-&gt;status.ampdu_ack_map);
+				   info-&gt;status.ampdu_len,
+				   info-&gt;status.ampdu_ack_len);
 
 		/* Update success/fail counts if not searching for new mode */
 		if (lq_sta-&gt;stay_in_tbl) {
-			lq_sta-&gt;total_success += info-&gt;status.ampdu_ack_map;
-			lq_sta-&gt;total_failed += (info-&gt;status.ampdu_ack_len -
-					info-&gt;status.ampdu_ack_map);
+			lq_sta-&gt;total_success += info-&gt;status.ampdu_ack_len;
+			lq_sta-&gt;total_failed += (info-&gt;status.ampdu_len -
+					info-&gt;status.ampdu_ack_len);
 		}
 	} else {
 	/*
diff --git a/drivers/net/wireless/iwlwifi/iwl-agn-tx.c b/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
index 95e263f1d117..c2a5c85542bf 100644
--- a/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
+++ b/drivers/net/wireless/iwlwifi/iwl-agn-tx.c
@@ -1233,8 +1233,9 @@ static int iwlagn_tx_status_reply_compressed_ba(struct iwl_priv *priv,
 	memset(&amp;info-&gt;status, 0, sizeof(info-&gt;status));
 	info-&gt;flags |= IEEE80211_TX_STAT_ACK;
 	info-&gt;flags |= IEEE80211_TX_STAT_AMPDU;
-	info-&gt;status.ampdu_ack_map = successes;
-	info-&gt;status.ampdu_ack_len = agg-&gt;frame_count;
+	info-&gt;status.ampdu_ack_len = successes;
+	info-&gt;status.ampdu_ack_map = bitmap;
+	info-&gt;status.ampdu_len = agg-&gt;frame_count;
 	iwlagn_hwrate_to_tx_control(priv, agg-&gt;rate_n_flags, info);
 
 	IWL_DEBUG_TX_REPLY(priv, "Bitmap %llx\n", (unsigned long long)bitmap);</pre><hr><pre>commit 93d95b12b3ba06e0e1f3e43a370ee61539d8cb90
Author: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
Date:   Sun Apr 18 09:28:18 2010 -0700

    mac80211: fix typo in comments
    
    The flag is called IEEE80211_TX_STAT_AMPDU rather than using the whole word
    STATUS.
    
    Signed-off-by: Daniel Halperin &lt;dhalperi@cs.washington.edu&gt;
    Signed-off-by: John W. Linville &lt;linville@tuxdriver.com&gt;

diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 75056dde3817..c49e6adcd8fa 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -397,11 +397,11 @@ struct ieee80211_tx_rate {
  * @status: union for status data
  * @driver_data: array of driver_data pointers
  * @ampdu_ack_len: number of acked aggregated frames.
- * 	relevant only if IEEE80211_TX_STATUS_AMPDU was set.
+ * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
  * @ampdu_ack_map: block ack bit map for the aggregation.
- * 	relevant only if IEEE80211_TX_STATUS_AMPDU was set.
+ * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
  * @ampdu_len: number of aggregated frames.
- * 	relevant only if IEEE80211_TX_STATUS_AMPDU was set.
+ * 	relevant only if IEEE80211_TX_STAT_AMPDU was set.
  * @ack_signal: signal strength of the ACK frame
  */
 struct ieee80211_tx_info {</pre>
    <div class="pagination">
        <a href='13_5.html'>&lt;&lt;Prev</a><a href='13.html'>1</a><a href='13_2.html'>2</a><a href='13_3.html'>3</a><a href='13_4.html'>4</a><a href='13_5.html'>5</a><span>[6]</span><a href='13_7.html'>7</a><a href='13_8.html'>8</a><a href='13_7.html'>Next&gt;&gt;</a>
    <div>
</body>
