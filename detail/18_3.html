<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Queensland</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Queensland</h1>
    <div class="pagination">
        <a href='18_2.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><span>[3]</span><a href='18_4.html'>4</a><a href='18_5.html'>5</a><a href='18_6.html'>6</a><a href='18_7.html'>7</a><a href='18_4.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 11a9eff9b66b1cf860faa84084328d798d18834c
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 23:18:36 2007 -0300

    V4L/DVB (6651): xc2028: mask off type correctly when searching for standard-specific types
    
    When searching for standard-specific analog firmware, only certain
    type bits are valid, much like for DTV.  Mask them off when finding
    the firmware to load.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028-types.h b/drivers/media/video/tuner-xc2028-types.h
index 6cee48193c47..c0dc6ec19f09 100644
--- a/drivers/media/video/tuner-xc2028-types.h
+++ b/drivers/media/video/tuner-xc2028-types.h
@@ -43,6 +43,8 @@
 /* There's a FM | BASE firmware + FM specific firmware (std=0) */
 #define	FM		(1&lt;&lt;10)
 
+#define STD_SPECIFIC_TYPES (MTS|FM|LCD|NOGD)
+
 /* Applies only for FM firmware
    Makes it use RF input 1 (pin #2) instead of input 2 (pin #4)
  */
diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 115738d75f3e..5b646fed340f 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -403,7 +403,9 @@ static int seek_firmware(struct dvb_frontend *fe, unsigned int type,
 	else if (type &amp; SCODE)
 		type &amp;= SCODE_TYPES;
 	else if (type &amp; DTV_TYPES)
-		type = type &amp; DTV_TYPES;
+		type &amp;= DTV_TYPES;
+	else if (type &amp; STD_SPECIFIC_TYPES)
+		type &amp;= STD_SPECIFIC_TYPES;
 
 	/* Seek for exact match */
 	for (i = 0; i &lt; priv-&gt;firm_size; i++) {</pre><hr><pre>commit 47bd5bc6486a5288aa3002533c24c8e9e564f9ac
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 23:11:37 2007 -0300

    V4L/DVB (6650): xc2028: base firmwares should have std0
    
    When loading BASE firmware, we must use std = 0.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 8f9ccaee9bb5..115738d75f3e 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -614,6 +614,7 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 	unsigned int		type = 0;
 	struct firmware_properties new_fw;
 	u16			version, hwmodel;
+	v4l2_std_id		std0;
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
@@ -690,7 +691,9 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 	if (rc &lt; 0)
 		goto fail;
 
-	rc = load_firmware(fe, BASE | new_fw.type, &amp;new_fw.id);
+	/* BASE firmwares are all std0 */
+	std0 = 0;
+	rc = load_firmware(fe, BASE | new_fw.type, &amp;std0);
 	if (rc &lt; 0) {
 		tuner_err("Error %d while loading base firmware\n",
 			  rc);
@@ -700,7 +703,7 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 	/* Load INIT1, if needed */
 	tuner_dbg("Load init1 firmware, if exists\n");
 
-	rc = load_firmware(fe, BASE | INIT1 | new_fw.type, &amp;new_fw.id);
+	rc = load_firmware(fe, BASE | INIT1 | new_fw.type, &amp;std0);
 	if (rc &lt; 0 &amp;&amp; rc != -ENOENT) {
 		tuner_err("Error %d while loading init1 firmware\n",
 			  rc);</pre><hr><pre>commit aeb012bbf460171b75ba17dc064a543f7256521f
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 21:57:10 2007 -0300

    V4L/DVB (6649): Add support for the DViCO FusionHDTV Dual Digital 4
    
    Add support for DViCO's Dual Digital 4 with xc3028 tuner, zl10353 DVB-T
    demodulator and a new-style I2C IR remote control receiver.
    
    This would not have been possible without the work of and advice from
    Mike Krufky, who originally got the Dual Digital 4 and second-gen DVB-T
    NANO devices working with the out-of-tree XC3028 driver.
    
    I converted it to use the in-tree XC3028 driver (after making it suitable
    for our use), and added the IR remote control support based on his advice.
    
    NB: a firmware package is required to use this device.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/dvb/dvb-usb/cxusb.c b/drivers/media/dvb/dvb-usb/cxusb.c
index 74eeb168f241..ec8516ac8105 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.c
+++ b/drivers/media/dvb/dvb-usb/cxusb.c
@@ -15,7 +15,7 @@
  *
  * Copyright (C) 2005 Patrick Boettcher (patrick.boettcher@desy.de)
  * Copyright (C) 2006 Michael Krufky (mkrufky@linuxtv.org)
- * Copyright (C) 2006 Chris Pascoe (c.pascoe@itee.uq.edu.au)
+ * Copyright (C) 2006, 2007 Chris Pascoe (c.pascoe@itee.uq.edu.au)
  *
  *   This program is free software; you can redistribute it and/or modify it
  *   under the terms of the GNU General Public License as published by the Free
@@ -30,6 +30,8 @@
 #include "mt352.h"
 #include "mt352_priv.h"
 #include "zl10353.h"
+#include "tuner-xc2028.h"
+#include "tuner-xc2028-types.h"
 
 /* debug */
 static int dvb_usb_cxusb_debug;
@@ -73,6 +75,29 @@ static void cxusb_gpio_tuner(struct dvb_usb_device *d, int onoff)
 	st-&gt;gpio_write_state[GPIO_TUNER] = onoff;
 }
 
+static int cxusb_bluebird_gpio_rw(struct dvb_usb_device *d, u8 changemask,
+				 u8 newval)
+{
+	u8 o[2], gpio_state;
+	int rc;
+
+	o[0] = 0xff &amp; ~changemask;	/* mask of bits to keep */
+	o[1] = newval &amp; changemask;	/* new values for bits  */
+
+	rc = cxusb_ctrl_msg(d, CMD_BLUEBIRD_GPIO_RW, o, 2, &amp;gpio_state, 1);
+	if (rc &lt; 0 || (gpio_state &amp; changemask) != (newval &amp; changemask))
+		deb_info("bluebird_gpio_write failed.\n");
+
+	return rc &lt; 0 ? rc : gpio_state;
+}
+
+static void cxusb_bluebird_gpio_pulse(struct dvb_usb_device *d, u8 pin, int low)
+{
+	cxusb_bluebird_gpio_rw(d, pin, low ? 0 : pin);
+	msleep(5);
+	cxusb_bluebird_gpio_rw(d, pin, low ? pin : 0);
+}
+
 /* I2C */
 static int cxusb_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],
 			  int num)
@@ -210,6 +235,34 @@ static int cxusb_rc_query(struct dvb_usb_device *d, u32 *event, int *state)
 	return 0;
 }
 
+static int cxusb_bluebird2_rc_query(struct dvb_usb_device *d, u32 *event,
+				    int *state)
+{
+	struct dvb_usb_rc_key *keymap = d-&gt;props.rc_key_map;
+	u8 ircode[4];
+	int i;
+	struct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,
+			       .buf = ircode, .len = 4 };
+
+	*event = 0;
+	*state = REMOTE_NO_KEY_PRESSED;
+
+	if (cxusb_i2c_xfer(&amp;d-&gt;i2c_adap, &amp;msg, 1) != 1)
+		return 0;
+
+	for (i = 0; i &lt; d-&gt;props.rc_key_map_size; i++) {
+		if (keymap[i].custom == ircode[1] &amp;&amp;
+		    keymap[i].data == ircode[2]) {
+			*event = keymap[i].event;
+			*state = REMOTE_KEY_PRESSED;
+
+			return 0;
+		}
+	}
+
+	return 0;
+}
+
 static struct dvb_usb_rc_key dvico_mce_rc_keys[] = {
 	{ 0xfe, 0x02, KEY_TV },
 	{ 0xfe, 0x0e, KEY_MP3 },
@@ -364,6 +417,13 @@ static struct mt352_config cxusb_mt352_config = {
 	.demod_init    = cxusb_mt352_demod_init,
 };
 
+static struct zl10353_config cxusb_zl10353_xc3028_config = {
+	.demod_address = 0x0f,
+	.if2 = 4560,
+	.no_tuner = 1,
+	.parallel_ts = 1,
+};
+
 /* Callbacks for DVB USB */
 static int cxusb_fmd1216me_tuner_attach(struct dvb_usb_adapter *adap)
 {
@@ -399,6 +459,52 @@ static int cxusb_lgh064f_tuner_attach(struct dvb_usb_adapter *adap)
 	return 0;
 }
 
+static int dvico_bluebird_xc2028_callback(void *ptr, int command, int arg)
+{
+	struct dvb_usb_device *d = ptr;
+
+	switch (command) {
+	case XC2028_TUNER_RESET:
+		deb_info("%s: XC2028_TUNER_RESET %d\n", __FUNCTION__, arg);
+		cxusb_bluebird_gpio_pulse(d, 0x01, 1);
+		break;
+	case XC2028_RESET_CLK:
+		deb_info("%s: XC2028_RESET_CLK %d\n", __FUNCTION__, arg);
+		break;
+	default:
+		deb_info("%s: unknown command %d, arg %d\n", __FUNCTION__,
+			 command, arg);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int cxusb_dvico_xc3028_tuner_attach(struct dvb_usb_adapter *adap)
+{
+	struct dvb_frontend	 *fe;
+	struct xc2028_config	  cfg = {
+		.i2c_adap  = &amp;adap-&gt;dev-&gt;i2c_adap,
+		.i2c_addr  = 0x61,
+		.video_dev = adap-&gt;dev,
+		.callback  = dvico_bluebird_xc2028_callback,
+	};
+	static struct xc2028_ctrl ctl = {
+		.type        = XC2028_FIRM_NORMAL,
+		.fname       = "xc3028-dvico-au-01.fw",
+		.max_len     = 64,
+		.scode_table = ZARLINK456,
+	};
+
+	fe = dvb_attach(xc2028_attach, adap-&gt;fe, &amp;cfg);
+	if (fe == NULL || fe-&gt;ops.tuner_ops.set_config == NULL)
+		return -EIO;
+
+	fe-&gt;ops.tuner_ops.set_config(fe, &amp;ctl);
+
+	return 0;
+}
+
 static int cxusb_cx22702_frontend_attach(struct dvb_usb_adapter *adap)
 {
 	u8 b;
@@ -460,6 +566,46 @@ static int cxusb_dee1601_frontend_attach(struct dvb_usb_adapter *adap)
 	return -EIO;
 }
 
+static int cxusb_dualdig4_frontend_attach(struct dvb_usb_adapter *adap)
+{
+	u8 ircode[4];
+	int i;
+	struct i2c_msg msg = { .addr = 0x6b, .flags = I2C_M_RD,
+			       .buf = ircode, .len = 4 };
+
+	if (usb_set_interface(adap-&gt;dev-&gt;udev, 0, 1) &lt; 0)
+		err("set interface failed");
+
+	cxusb_ctrl_msg(adap-&gt;dev, CMD_DIGITAL, NULL, 0, NULL, 0);
+
+	/* reset the tuner and demodulator */
+	cxusb_bluebird_gpio_rw(adap-&gt;dev, 0x04, 0);
+	cxusb_bluebird_gpio_pulse(adap-&gt;dev, 0x01, 1);
+	cxusb_bluebird_gpio_pulse(adap-&gt;dev, 0x02, 1);
+
+	if ((adap-&gt;fe = dvb_attach(zl10353_attach,
+				   &amp;cxusb_zl10353_xc3028_config,
+				   &amp;adap-&gt;dev-&gt;i2c_adap)) == NULL)
+		return -EIO;
+
+	/* try to determine if there is no IR decoder on the I2C bus */
+	for (i = 0; adap-&gt;dev-&gt;props.rc_key_map != NULL &amp;&amp; i &lt; 5; i++) {
+		msleep(20);
+		if (cxusb_i2c_xfer(&amp;adap-&gt;dev-&gt;i2c_adap, &amp;msg, 1) != 1)
+			goto no_IR;
+		if (ircode[0] == 0 &amp;&amp; ircode[1] == 0)
+			continue;
+		if (ircode[2] + ircode[3] != 0xff) {
+no_IR:
+			adap-&gt;dev-&gt;props.rc_key_map = NULL;
+			info("No IR receiver detected on this device.");
+			break;
+		}
+	}
+
+	return 0;
+}
+
 /*
  * DViCO bluebird firmware needs the "warm" product ID to be patched into the
  * firmware file before download.
@@ -492,6 +638,7 @@ static struct dvb_usb_device_properties cxusb_bluebird_lgh064f_properties;
 static struct dvb_usb_device_properties cxusb_bluebird_dee1601_properties;
 static struct dvb_usb_device_properties cxusb_bluebird_lgz201_properties;
 static struct dvb_usb_device_properties cxusb_bluebird_dtt7579_properties;
+static struct dvb_usb_device_properties cxusb_bluebird_dualdig4_properties;
 
 static int cxusb_probe(struct usb_interface *intf,
 		       const struct usb_device_id *id)
@@ -500,7 +647,8 @@ static int cxusb_probe(struct usb_interface *intf,
 		dvb_usb_device_init(intf,&amp;cxusb_bluebird_lgh064f_properties,THIS_MODULE,NULL) == 0 ||
 		dvb_usb_device_init(intf,&amp;cxusb_bluebird_dee1601_properties,THIS_MODULE,NULL) == 0 ||
 		dvb_usb_device_init(intf,&amp;cxusb_bluebird_lgz201_properties,THIS_MODULE,NULL) == 0 ||
-		dvb_usb_device_init(intf,&amp;cxusb_bluebird_dtt7579_properties,THIS_MODULE,NULL) == 0) {
+		dvb_usb_device_init(intf,&amp;cxusb_bluebird_dtt7579_properties,THIS_MODULE,NULL) == 0 ||
+		dvb_usb_device_init(intf,&amp;cxusb_bluebird_dualdig4_properties,THIS_MODULE,NULL) == 0) {
 		return 0;
 	}
 
@@ -521,6 +669,7 @@ static struct usb_device_id cxusb_table [] = {
 	{ USB_DEVICE(USB_VID_DVICO, USB_PID_DIGITALNOW_BLUEBIRD_DUAL_1_WARM) },
 	{ USB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_2_COLD) },
 	{ USB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_2_WARM) },
+	{ USB_DEVICE(USB_VID_DVICO, USB_PID_DVICO_BLUEBIRD_DUAL_4) },
 	{}		/* Terminating entry */
 };
 MODULE_DEVICE_TABLE (usb, cxusb_table);
@@ -779,6 +928,53 @@ static struct dvb_usb_device_properties cxusb_bluebird_dtt7579_properties = {
 	}
 };
 
+static struct dvb_usb_device_properties cxusb_bluebird_dualdig4_properties = {
+	.caps = DVB_USB_IS_AN_I2C_ADAPTER,
+
+	.usb_ctrl         = CYPRESS_FX2,
+
+	.size_of_priv     = sizeof(struct cxusb_state),
+
+	.num_adapters = 1,
+	.adapter = {
+		{
+			.streaming_ctrl   = cxusb_streaming_ctrl,
+			.frontend_attach  = cxusb_dualdig4_frontend_attach,
+			.tuner_attach     = cxusb_dvico_xc3028_tuner_attach,
+			/* parameter for the MPEG2-data transfer */
+			.stream = {
+				.type = USB_BULK,
+				.count = 5,
+				.endpoint = 0x02,
+				.u = {
+					.bulk = {
+						.buffersize = 8192,
+					}
+				}
+			},
+		},
+	},
+
+	.power_ctrl       = cxusb_power_ctrl,
+
+	.i2c_algo         = &amp;cxusb_i2c_algo,
+
+	.generic_bulk_ctrl_endpoint = 0x01,
+
+	.rc_interval      = 100,
+	.rc_key_map       = dvico_mce_rc_keys,
+	.rc_key_map_size  = ARRAY_SIZE(dvico_mce_rc_keys),
+	.rc_query         = cxusb_bluebird2_rc_query,
+
+	.num_device_descs = 1,
+	.devices = {
+		{   "DViCO FusionHDTV DVB-T Dual Digital 4",
+			{ NULL },
+			{ &amp;cxusb_table[13], NULL },
+		},
+	}
+};
+
 static struct usb_driver cxusb_driver = {
 	.name		= "dvb_usb_cxusb",
 	.probe		= cxusb_probe,
diff --git a/drivers/media/dvb/dvb-usb/cxusb.h b/drivers/media/dvb/dvb-usb/cxusb.h
index 79ca7abb89a5..4768a2c35517 100644
--- a/drivers/media/dvb/dvb-usb/cxusb.h
+++ b/drivers/media/dvb/dvb-usb/cxusb.h
@@ -5,6 +5,8 @@
 #include "dvb-usb.h"
 
 /* usb commands - some of it are guesses, don't have a reference yet */
+#define CMD_BLUEBIRD_GPIO_RW 0x05
+
 #define CMD_I2C_WRITE     0x08
 #define CMD_I2C_READ      0x09
 
diff --git a/drivers/media/dvb/dvb-usb/dvb-usb-ids.h b/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
index d6d96308cbaa..6f14c853ffea 100644
--- a/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
+++ b/drivers/media/dvb/dvb-usb/dvb-usb-ids.h
@@ -147,6 +147,7 @@
 #define USB_PID_DVICO_BLUEBIRD_DUAL_1_WARM		0xdb51
 #define USB_PID_DVICO_BLUEBIRD_DUAL_2_COLD		0xdb58
 #define USB_PID_DVICO_BLUEBIRD_DUAL_2_WARM		0xdb59
+#define USB_PID_DVICO_BLUEBIRD_DUAL_4			0xdb78
 #define USB_PID_DIGITALNOW_BLUEBIRD_DUAL_1_COLD		0xdb54
 #define USB_PID_DIGITALNOW_BLUEBIRD_DUAL_1_WARM		0xdb55
 #define USB_PID_MEDION_MD95700				0x0932</pre><hr><pre>commit 45819c381fc4fb342dc091f30eef4b56193e34d5
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 11:41:20 2007 -0300

    V4L/DVB (6648): xc2028: add sleep hook
    
    Add sleep method to enable putting the tuner into standby mode.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index cc6fa2fa859b..8f9ccaee9bb5 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -929,6 +929,28 @@ static int xc2028_set_params(struct dvb_frontend *fe,
 
 }
 
+static int xc2028_sleep(struct dvb_frontend *fe)
+{
+	struct xc2028_data *priv = fe-&gt;tuner_priv;
+	int rc = 0;
+
+	tuner_dbg("%s called\n", __FUNCTION__);
+
+	mutex_lock(&amp;priv-&gt;lock);
+
+	if (priv-&gt;firm_version &lt; 0x0202)
+		rc = send_seq(priv, {0x00, 0x08, 0x00, 0x00});
+	else
+		rc = send_seq(priv, {0x80, 0x08, 0x00, 0x00});
+
+	priv-&gt;cur_fw.type = 0;	/* need firmware reload */
+
+	mutex_unlock(&amp;priv-&gt;lock);
+
+	return rc;
+}
+
+
 static int xc2028_dvb_release(struct dvb_frontend *fe)
 {
 	struct xc2028_data *priv = fe-&gt;tuner_priv;
@@ -1009,6 +1031,7 @@ static const struct dvb_tuner_ops xc2028_dvb_tuner_ops = {
 	.get_frequency     = xc2028_get_frequency,
 	.get_rf_strength   = xc2028_signal,
 	.set_params        = xc2028_set_params,
+	.sleep             = xc2028_sleep,
 
 };
 </pre><hr><pre>commit 8bf799a6217f6336fb95f37bf1b130003404bd7b
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 11:35:45 2007 -0300

    V4L/DVB (6647): xc2028: retry firmware load if tuner does not respond
    
    In practice, the tuner occasionally fails to respond correctly after a
    firmware load.  Retry the firmware load if the firmware/hardware version
    we read back from the tuner after programming does not match what we
    expect.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 8140d8ad0792..cc6fa2fa859b 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -75,6 +75,9 @@ struct xc2028_data {
 	int			firm_size;
 	__u16			firm_version;
 
+	__u16			hwmodel;
+	__u16			hwvers;
+
 	struct xc2028_ctrl	ctrl;
 
 	struct firmware_properties cur_fw;
@@ -607,7 +610,7 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 			  v4l2_std_id std, fe_bandwidth_t bandwidth)
 {
 	struct xc2028_data      *priv = fe-&gt;tuner_priv;
-	int			rc = 0;
+	int			rc = 0, is_retry = 0;
 	unsigned int		type = 0;
 	struct firmware_properties new_fw;
 	u16			version, hwmodel;
@@ -654,6 +657,7 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 		};
 	}
 
+retry:
 	new_fw.type = type;
 	new_fw.id = std;
 	new_fw.std_req = std;
@@ -739,14 +743,34 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 			&amp;new_fw.id, new_fw.scode_nr);
 
 check_device:
-	xc2028_get_reg(priv, 0x0004, &amp;version);
-	xc2028_get_reg(priv, 0x0008, &amp;hwmodel);
+	if (xc2028_get_reg(priv, 0x0004, &amp;version) &lt; 0 ||
+	    xc2028_get_reg(priv, 0x0008, &amp;hwmodel) &lt; 0) {
+		tuner_err("Unable to read tuner registers.\n");
+		goto fail;
+	}
 
 	tuner_info("Device is Xceive %d version %d.%d, "
 		   "firmware version %d.%d\n",
 		   hwmodel, (version &amp; 0xf000) &gt;&gt; 12, (version &amp; 0xf00) &gt;&gt; 8,
 		   (version &amp; 0xf0) &gt;&gt; 4, version &amp; 0xf);
 
+	/* Check firmware version against what we downloaded. */
+	if (priv-&gt;firm_version != ((version &amp; 0xf0) &lt;&lt; 4 | (version &amp; 0x0f))) {
+		tuner_err("Incorrect readback of firmware version.\n");
+		goto fail;
+	}
+
+	/* Check that the tuner hardware model remains consistent over time. */
+	if (priv-&gt;hwmodel == 0 &amp;&amp; (hwmodel == 2028 || hwmodel == 3028)) {
+		priv-&gt;hwmodel = hwmodel;
+		priv-&gt;hwvers  = version &amp; 0xff00;
+	} else if (priv-&gt;hwmodel == 0 || priv-&gt;hwmodel != hwmodel ||
+		   priv-&gt;hwvers != (version &amp; 0xff00)) {
+		tuner_err("Read invalid device hardware information - tuner "
+			  "hung?\n");
+		goto fail;
+	}
+
 	memcpy(&amp;priv-&gt;cur_fw, &amp;new_fw, sizeof(priv-&gt;cur_fw));
 
 	/*
@@ -761,6 +785,13 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 
 fail:
 	memset(&amp;priv-&gt;cur_fw, 0, sizeof(priv-&gt;cur_fw));
+	if (!is_retry) {
+		msleep(50);
+		is_retry = 1;
+		tuner_dbg("Retrying firmware load\n");
+		goto retry;
+	}
+
 	if (rc == -ENOENT)
 		rc = -EINVAL;
 	return rc;</pre><hr><pre>commit e0f0b37a3e624440b1b0e8a5978b367895226e75
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 11:22:03 2007 -0300

    V4L/DVB (6646): xc2028: rework firmware (re)loading process
    
    Define a list of valid "firmware types" for each combination of BASE,
    DTV and SCODEs.  By masking the appropriate firmware bits off we can
    just use one "type" for the firmware searching and also flag when we
    are looking for a BASE, DTV or SCODE type firmware.  This makes it
    much easier to track if we need to change device modes or flash an
    individual firmware part.
    
    Add a structure to remember what firmware properties we have.  This
    contains the currently loaded/wanted  base firmware (type), video std
    (id), video std requested (std_req), scode file and number in use.
    
    Incorporate said structure into the tuner private data.
    
    When checking whether the current firmware needs to be reloaded, first
    figure out exactly what "type" of firmware we want (base, std and
    scode), and then proceed to load the appropriate matching base,
    std-specific and scode records iff there are any changes required.
    This removes guesswork from the process because we no longer need to
    individually code a check for every tuning parameter's interactions.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028-types.h b/drivers/media/video/tuner-xc2028-types.h
index a9e2e0562d99..6cee48193c47 100644
--- a/drivers/media/video/tuner-xc2028-types.h
+++ b/drivers/media/video/tuner-xc2028-types.h
@@ -8,6 +8,7 @@
 
 /* BASE firmware should be loaded before any other firmware */
 #define BASE		(1&lt;&lt;0)
+#define BASE_TYPES	(BASE|F8MHZ|MTS|FM|INPUT1|INPUT2|INIT1)
 
 /* F8MHZ marks BASE firmwares for 8 MHz Bandwidth */
 #define F8MHZ		(1&lt;&lt;1)
@@ -37,6 +38,8 @@
 #define DTV78		(1&lt;&lt;8)
 #define DTV8		(1&lt;&lt;9)
 
+#define DTV_TYPES	(D2620|D2633|DTV6|QAM|DTV7|DTV78|DTV8|ATSC)
+
 /* There's a FM | BASE firmware + FM specific firmware (std=0) */
 #define	FM		(1&lt;&lt;10)
 
@@ -60,6 +63,7 @@
 /* Old firmwares were broken into init0 and init1 */
 #define INIT1		(1&lt;&lt;14)
 
+/* SCODE firmware selects particular behaviours */
 #define MONO           (1 &lt;&lt; 15)
 #define ATSC           (1 &lt;&lt; 16)
 #define IF             (1 &lt;&lt; 17)
@@ -76,6 +80,10 @@
 #define INPUT2         (1 &lt;&lt; 28)
 #define SCODE          (1 &lt;&lt; 29)
 
+#define SCODE_TYPES	(MTS|DTV6|QAM|DTV7|DTV78|DTV8|LCD|NOGD|MONO|ATSC|IF| \
+			 LG60|ATI638|OREN538|OREN36|TOYOTA388|TOYOTA794|     \
+			 DIBCOM52|ZARLINK456|CHINA|F6MHZ|SCODE)
+
 /* Newer types to be moved to videodev2.h */
 
 #define V4L2_STD_SECAM_K3	(0x04000000)
diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index a5efd5f6e57c..8140d8ad0792 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -54,6 +54,14 @@ struct firmware_description {
 	unsigned int  size;
 };
 
+struct firmware_properties {
+	unsigned int	type;
+	v4l2_std_id	id;
+	v4l2_std_id	std_req;
+	unsigned int	scode_table;
+	int 		scode_nr;
+};
+
 struct xc2028_data {
 	struct list_head        xc2028_list;
 	struct tuner_i2c_props  i2c_props;
@@ -69,14 +77,7 @@ struct xc2028_data {
 
 	struct xc2028_ctrl	ctrl;
 
-	v4l2_std_id		firm_type;	   /* video stds supported
-							by current firmware */
-	fe_bandwidth_t		bandwidth;	   /* Firmware bandwidth:
-							      6M, 7M or 8M */
-	int			need_load_generic; /* The generic firmware
-							      were loaded? */
-	enum tuner_mode	mode;
-	struct i2c_client	*i2c_client;
+	struct firmware_properties cur_fw;
 
 	struct mutex lock;
 };
@@ -234,7 +235,8 @@ static void free_firmware(struct xc2028_data *priv)
 
 	priv-&gt;firm = NULL;
 	priv-&gt;firm_size = 0;
-	priv-&gt;need_load_generic = 1;
+
+	memset(&amp;priv-&gt;cur_fw, 0, sizeof(priv-&gt;cur_fw));
 }
 
 static int load_all_firmwares(struct dvb_frontend *fe)
@@ -393,6 +395,13 @@ static int seek_firmware(struct dvb_frontend *fe, unsigned int type,
 	if (((type &amp; ~SCODE) == 0) &amp;&amp; (*id == 0))
 		*id = V4L2_STD_PAL;
 
+	if (type &amp; BASE)
+		type &amp;= BASE_TYPES;
+	else if (type &amp; SCODE)
+		type &amp;= SCODE_TYPES;
+	else if (type &amp; DTV_TYPES)
+		type = type &amp; DTV_TYPES;
+
 	/* Seek for exact match */
 	for (i = 0; i &lt; priv-&gt;firm_size; i++) {
 		if ((type == priv-&gt;firm[i].type) &amp;&amp; (*id == priv-&gt;firm[i].id))
@@ -598,11 +607,10 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 			  v4l2_std_id std, fe_bandwidth_t bandwidth)
 {
 	struct xc2028_data      *priv = fe-&gt;tuner_priv;
-	int			rc;
+	int			rc = 0;
+	unsigned int		type = 0;
+	struct firmware_properties new_fw;
 	u16			version, hwmodel;
-	v4l2_std_id		std0 = 0;
-	unsigned int		type0 = 0, type = 0;
-	int			change_digital_bandwidth;
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
@@ -617,61 +625,19 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 			return rc;
 	}
 
-	tuner_dbg("I am in mode %u and I should switch to mode %i\n",
-		   priv-&gt;mode, new_mode);
-
-	/* first of all, determine whether we have switched the mode */
-	if (new_mode != priv-&gt;mode) {
-		priv-&gt;mode = new_mode;
-		priv-&gt;need_load_generic = 1;
-	}
-
-	change_digital_bandwidth = (priv-&gt;mode == T_DIGITAL_TV
-				    &amp;&amp; bandwidth != priv-&gt;bandwidth) ? 1 : 0;
-	tuner_dbg("old bandwidth %u, new bandwidth %u\n", priv-&gt;bandwidth,
-		   bandwidth);
-
-	if (priv-&gt;need_load_generic) {
-		/* Reset is needed before loading firmware */
-		rc = priv-&gt;tuner_callback(priv-&gt;video_dev,
-					  XC2028_TUNER_RESET, 0);
-		if (rc &lt; 0)
-			return rc;
-
-		type0 = BASE;
-
-		if (priv-&gt;ctrl.type == XC2028_FIRM_MTS)
-			type0 |= MTS;
-
-		if (bandwidth == BANDWIDTH_7_MHZ ||
-		    bandwidth == BANDWIDTH_8_MHZ)
-			type0 |= F8MHZ;
-
-		/* FIXME: How to load FM and FM|INPUT1 firmwares? */
-
-		rc = load_firmware(fe, type0, &amp;std0);
-		if (rc &lt; 0) {
-			tuner_err("Error %d while loading generic firmware\n",
-				  rc);
-			return rc;
-		}
-
-		priv-&gt;need_load_generic = 0;
-		priv-&gt;firm_type = 0;
-		if (priv-&gt;mode == T_DIGITAL_TV)
-			change_digital_bandwidth = 1;
-	}
+	if (priv-&gt;ctrl.type == XC2028_FIRM_MTS)
+		type |= MTS;
+	if (bandwidth == BANDWIDTH_7_MHZ || bandwidth == BANDWIDTH_8_MHZ)
+		type |= F8MHZ;
 
-	tuner_dbg("I should change bandwidth %u\n", change_digital_bandwidth);
+	/* FIXME: How to load FM and FM|INPUT1 firmwares? */
 
-	if (change_digital_bandwidth) {
+	if (new_mode == T_DIGITAL_TV) {
 		if (priv-&gt;ctrl.d2633)
 			type |= D2633;
 		else
 			type |= D2620;
 
-		/* FIXME: When should select a DTV78 firmware?
-		 */
 		switch (bandwidth) {
 		case BANDWIDTH_8_MHZ:
 			type |= DTV8;
@@ -683,49 +649,96 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 			/* FIXME: Should allow select also ATSC */
 			type |= DTV6 | QAM;
 			break;
-
 		default:
 			tuner_err("error: bandwidth not supported.\n");
 		};
-		priv-&gt;bandwidth = bandwidth;
 	}
 
-	if (!change_digital_bandwidth &amp;&amp; priv-&gt;mode == T_DIGITAL_TV)
-		return 0;
+	new_fw.type = type;
+	new_fw.id = std;
+	new_fw.std_req = std;
+	new_fw.scode_table = SCODE | priv-&gt;ctrl.scode_table;
+	new_fw.scode_nr = 0;
+
+	tuner_dbg("checking firmware, user requested type=");
+	if (debug) {
+		dump_firm_type(new_fw.type);
+		printk("(%x), id %016llx, scode_tbl ", new_fw.type,
+		       (unsigned long long)new_fw.std_req);
+		dump_firm_type(priv-&gt;ctrl.scode_table);
+		printk("(%x), scode_nr %d\n", priv-&gt;ctrl.scode_table,
+		       new_fw.scode_nr);
+	}
+
+	/* No need to reload base firmware if it matches */
+	if (((BASE | new_fw.type) &amp; BASE_TYPES) ==
+	    (priv-&gt;cur_fw.type &amp; BASE_TYPES)) {
+		tuner_dbg("BASE firmware not changed.\n");
+		goto skip_base;
+	}
+
+	/* Updating BASE - forget about all currently loaded firmware */
+	memset(&amp;priv-&gt;cur_fw, 0, sizeof(priv-&gt;cur_fw));
+
+	/* Reset is needed before loading firmware */
+	rc = priv-&gt;tuner_callback(priv-&gt;video_dev,
+				  XC2028_TUNER_RESET, 0);
+	if (rc &lt; 0)
+		goto fail;
+
+	rc = load_firmware(fe, BASE | new_fw.type, &amp;new_fw.id);
+	if (rc &lt; 0) {
+		tuner_err("Error %d while loading base firmware\n",
+			  rc);
+		goto fail;
+	}
 
 	/* Load INIT1, if needed */
 	tuner_dbg("Load init1 firmware, if exists\n");
-	type0 = BASE | INIT1;
-	if (priv-&gt;ctrl.type == XC2028_FIRM_MTS)
-		type0 |= MTS;
 
-	/* FIXME: Should handle errors - if INIT1 found */
-	rc = load_firmware(fe, type0, &amp;std0);
+	rc = load_firmware(fe, BASE | INIT1 | new_fw.type, &amp;new_fw.id);
+	if (rc &lt; 0 &amp;&amp; rc != -ENOENT) {
+		tuner_err("Error %d while loading init1 firmware\n",
+			  rc);
+		goto fail;
+	}
 
-	/* FIXME: Should add support for FM radio
+skip_base:
+	/*
+	 * No need to reload standard specific firmware if base firmware
+	 * was not reloaded and requested video standards have not changed.
 	 */
-
-	if (priv-&gt;ctrl.type == XC2028_FIRM_MTS)
-		type |= MTS;
-
-	if (priv-&gt;firm_type &amp; std) {
+	if (priv-&gt;cur_fw.type == (BASE | new_fw.type) &amp;&amp;
+	    priv-&gt;cur_fw.std_req == std) {
 		tuner_dbg("Std-specific firmware already loaded.\n");
-		return 0;
+		goto skip_std_specific;
 	}
 
+	/* Reloading std-specific firmware forces a SCODE update */
+	priv-&gt;cur_fw.scode_table = 0;
+
 	/* Add audio hack to std mask */
-	std |= parse_audio_std_option();
+	if (new_mode == T_ANALOG_TV)
+		new_fw.id |= parse_audio_std_option();
 
-	rc = load_firmware(fe, type, &amp;std);
+	rc = load_firmware(fe, new_fw.type, &amp;new_fw.id);
 	if (rc &lt; 0)
-		return rc;
+		goto fail;
+
+skip_std_specific:
+	if (priv-&gt;cur_fw.scode_table == new_fw.scode_table &amp;&amp;
+	    priv-&gt;cur_fw.scode_nr == new_fw.scode_nr) {
+		tuner_dbg("SCODE firmware already loaded.\n");
+		goto check_device;
+	}
 
 	/* Load SCODE firmware, if exists */
-	tuner_dbg("Trying to load scode 0\n");
-	type |= SCODE;
+	tuner_dbg("Trying to load scode %d\n", new_fw.scode_nr);
 
-	rc = load_scode(fe, type, &amp;std, 0);
+	rc = load_scode(fe, new_fw.type | new_fw.scode_table,
+			&amp;new_fw.id, new_fw.scode_nr);
 
+check_device:
 	xc2028_get_reg(priv, 0x0004, &amp;version);
 	xc2028_get_reg(priv, 0x0008, &amp;hwmodel);
 
@@ -734,9 +747,23 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 		   hwmodel, (version &amp; 0xf000) &gt;&gt; 12, (version &amp; 0xf00) &gt;&gt; 8,
 		   (version &amp; 0xf0) &gt;&gt; 4, version &amp; 0xf);
 
-	priv-&gt;firm_type = std;
+	memcpy(&amp;priv-&gt;cur_fw, &amp;new_fw, sizeof(priv-&gt;cur_fw));
+
+	/*
+	 * By setting BASE in cur_fw.type only after successfully loading all
+	 * firmwares, we can:
+	 * 1. Identify that BASE firmware with type=0 has been loaded;
+	 * 2. Tell whether BASE firmware was just changed the next time through.
+	 */
+	priv-&gt;cur_fw.type |= BASE;
 
 	return 0;
+
+fail:
+	memset(&amp;priv-&gt;cur_fw, 0, sizeof(priv-&gt;cur_fw));
+	if (rc == -ENOENT)
+		rc = -EINVAL;
+	return rc;
 }
 
 static int xc2028_signal(struct dvb_frontend *fe, u16 *strength)
@@ -785,16 +812,10 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 	mutex_lock(&amp;priv-&gt;lock);
 
 	/* HACK: It seems that specific firmware need to be reloaded
-	   when freq is changed */
-
-	priv-&gt;firm_type = 0;
-
-	/* Reset GPIO 1 */
-	rc = priv-&gt;tuner_callback(priv-&gt;video_dev, XC2028_TUNER_RESET, 0);
-	if (rc &lt; 0)
-		goto ret;
+	   when watching analog TV and freq is changed */
+	if (new_mode != T_DIGITAL_TV)
+		priv-&gt;cur_fw.type = 0;
 
-	msleep(10);
 	tuner_dbg("should set frequency %d kHz\n", freq / 1000);
 
 	if (check_firmware(fe, new_mode, std, bandwidth) &lt; 0)
@@ -802,7 +823,7 @@ static int generic_set_tv_freq(struct dvb_frontend *fe, u32 freq /* in Hz */ ,
 
 	if (new_mode == T_DIGITAL_TV) {
 		offset = 2750000;
-		if (priv-&gt;bandwidth == BANDWIDTH_7_MHZ)
+		if (priv-&gt;cur_fw.type &amp; DTV7)
 			offset -= 500000;
 	}
 
@@ -994,9 +1015,6 @@ void *xc2028_attach(struct dvb_frontend *fe, struct xc2028_config *cfg)
 			return NULL;
 		}
 
-		priv-&gt;bandwidth = BANDWIDTH_6_MHZ;
-		priv-&gt;need_load_generic = 1;
-		priv-&gt;mode = T_UNINITIALIZED;
 		priv-&gt;i2c_props.addr = cfg-&gt;i2c_addr;
 		priv-&gt;i2c_props.adap = cfg-&gt;i2c_adap;
 		priv-&gt;video_dev = video_dev;
diff --git a/drivers/media/video/tuner-xc2028.h b/drivers/media/video/tuner-xc2028.h
index 4edc4b735c84..16259b14ce90 100644
--- a/drivers/media/video/tuner-xc2028.h
+++ b/drivers/media/video/tuner-xc2028.h
@@ -21,6 +21,7 @@ struct xc2028_ctrl {
 	char			*fname;
 	int			max_len;
 	int			d2633:1;
+	unsigned int		scode_table;
 };
 
 struct xc2028_config {</pre><hr><pre>commit 59a636e50f339f91880b3a1e395829c43cc6541a
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 10:23:17 2007 -0300

    V4L/DVB (6645): xc2028: allow selection of D2633 firmware
    
    Add a bit to select D2633 DTV firmware to struct xc2028_ctrl, so that it can
    be enabled via .set_config.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index fbaab68fd05c..a5efd5f6e57c 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -665,9 +665,10 @@ static int check_firmware(struct dvb_frontend *fe, enum tuner_mode new_mode,
 	tuner_dbg("I should change bandwidth %u\n", change_digital_bandwidth);
 
 	if (change_digital_bandwidth) {
-
-		/*FIXME: Should allow selecting between D2620 and D2633 */
-		type |= D2620;
+		if (priv-&gt;ctrl.d2633)
+			type |= D2633;
+		else
+			type |= D2620;
 
 		/* FIXME: When should select a DTV78 firmware?
 		 */
diff --git a/drivers/media/video/tuner-xc2028.h b/drivers/media/video/tuner-xc2028.h
index a20eeb4935d0..4edc4b735c84 100644
--- a/drivers/media/video/tuner-xc2028.h
+++ b/drivers/media/video/tuner-xc2028.h
@@ -20,6 +20,7 @@ struct xc2028_ctrl {
 	enum xc2028_firm_type	type;
 	char			*fname;
 	int			max_len;
+	int			d2633:1;
 };
 
 struct xc2028_config {</pre><hr><pre>commit d7b22c5cfef28d21051331622f9595993a083cc4
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 10:12:45 2007 -0300

    V4L/DVB (6644): xc2028: use correct offset into scode firmware
    
    When validating and loading SCODE firmware we need to take into account the
    two-byte size header before each entry.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index 3edf5be47197..fbaab68fd05c 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -565,9 +565,17 @@ static int load_scode(struct dvb_frontend *fe, unsigned int type,
 
 	p = priv-&gt;firm[pos].ptr;
 
-	if ((priv-&gt;firm[pos].size != 12 * 16) || (scode &gt;= 16))
+	/* 16 SCODE entries per file; each SCODE entry is 12 bytes and
+	 * has a 2-byte size header in the firmware format. */
+	if (priv-&gt;firm[pos].size != 14 * 16 || scode &gt;= 16 ||
+	    le16_to_cpu(*(__u16 *)(p + 14 * scode)) != 12)
 		return -EINVAL;
 
+	tuner_info("Loading SCODE for type=");
+	dump_firm_type(priv-&gt;firm[pos].type);
+	printk("(%x), id %016llx.\n", priv-&gt;firm[pos].type,
+	       (unsigned long long)*id);
+
 	if (priv-&gt;firm_version &lt; 0x0202)
 		rc = send_seq(priv, {0x20, 0x00, 0x00, 0x00});
 	else
@@ -575,7 +583,7 @@ static int load_scode(struct dvb_frontend *fe, unsigned int type,
 	if (rc &lt; 0)
 		return -EIO;
 
-	rc = i2c_send(priv, p + 12 * scode, 12);
+	rc = i2c_send(priv, p + 14 * scode + 2, 12);
 	if (rc &lt; 0)
 		return -EIO;
 </pre><hr><pre>commit b1535293dc816f01b0934718c370f9533c7d635e
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 10:04:06 2007 -0300

    V4L/DVB (6643): xc2028: use best match instead of first partial match during firmware selection
    
    Rather than picking the first video standard firmware that supports any of
    the standards that the user has requested, try to select one that supports
    as many of them as possible.  This improves the likelihood that the firmware
    we select will support the user's desired TV standard.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index e19449603d73..3edf5be47197 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -377,9 +377,13 @@ static int seek_firmware(struct dvb_frontend *fe, unsigned int type,
 			 v4l2_std_id *id)
 {
 	struct xc2028_data *priv = fe-&gt;tuner_priv;
-	int                i;
+	int                 i, best_i = -1, best_nr_matches = 0;
 
-	tuner_dbg("%s called\n", __FUNCTION__);
+	tuner_dbg("%s called, want type=", __FUNCTION__);
+	if (debug) {
+		dump_firm_type(type);
+		printk("(%x), id %016llx.\n", type, (unsigned long long)*id);
+	}
 
 	if (!priv-&gt;firm) {
 		tuner_err("Error! firmware not loaded\n");
@@ -397,20 +401,45 @@ static int seek_firmware(struct dvb_frontend *fe, unsigned int type,
 
 	/* Seek for generic video standard match */
 	for (i = 0; i &lt; priv-&gt;firm_size; i++) {
-		if ((type == priv-&gt;firm[i].type) &amp;&amp; (*id &amp; priv-&gt;firm[i].id))
-			goto found;
+		v4l2_std_id match_mask;
+		int nr_matches;
+
+		if (type != priv-&gt;firm[i].type)
+			continue;
+
+		match_mask = *id &amp; priv-&gt;firm[i].id;
+		if (!match_mask)
+			continue;
+
+		if ((*id &amp; match_mask) == *id)
+			goto found; /* Supports all the requested standards */
+
+		nr_matches = hweight64(match_mask);
+		if (nr_matches &gt; best_nr_matches) {
+			best_nr_matches = nr_matches;
+			best_i = i;
+		}
+	}
+
+	if (best_nr_matches &gt; 0) {
+		tuner_dbg("Selecting best matching firmware (%d bits) for "
+			  "type=", best_nr_matches);
+		dump_firm_type(type);
+		printk("(%x), id %016llx:\n", type, (unsigned long long)*id);
+		i = best_i;
+		goto found;
 	}
 
 	/*FIXME: Would make sense to seek for type "hint" match ? */
 
-	i = -EINVAL;
+	i = -ENOENT;
 	goto ret;
 
 found:
 	*id = priv-&gt;firm[i].id;
 
 ret:
-	tuner_dbg("%s firmware for type=", (i &lt; 0)? "Can't find": "Found");
+	tuner_dbg("%s firmware for type=", (i &lt; 0) ? "Can't find" : "Found");
 	if (debug) {
 		dump_firm_type(type);
 		printk("(%x), id %016llx.\n", type, (unsigned long long)*id);
@@ -432,8 +461,9 @@ static int load_firmware(struct dvb_frontend *fe, unsigned int type,
 		return pos;
 
 	tuner_info("Loading firmware for type=");
-	dump_firm_type(type);
-	printk("(%x), id %016llx.\n", type, (unsigned long long)*id);
+	dump_firm_type(priv-&gt;firm[pos].type);
+	printk("(%x), id %016llx.\n", priv-&gt;firm[pos].type,
+	       (unsigned long long)*id);
 
 	p = priv-&gt;firm[pos].ptr;
 	endp = p + priv-&gt;firm[pos].size;</pre><hr><pre>commit 0a196b6fa9b42a2bb49733b37565aaaa97ffb07f
Author: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
Date:   Mon Nov 19 09:29:59 2007 -0300

    V4L/DVB (6642): xc2028: don't duplicate max_len in priv
    
    There is no need to duplicate the max_len field from the ctrl structure
    in the private data.  If we use it directly from priv-&gt;ctrl, we can memcpy
    the structure (apart from strings) to reduce maintenance as it grows.
    
    Enforce a minimum max_len length of 8 data bytes (+ 1 address byte) as seems
    to be required by the tuner.
    
    Also, use kstrdup instead of open coding the string duplication.
    
    Signed-off-by: Chris Pascoe &lt;c.pascoe@itee.uq.edu.au&gt;
    Signed-off-by: Mauro Carvalho Chehab &lt;mchehab@infradead.org&gt;

diff --git a/drivers/media/video/tuner-xc2028.c b/drivers/media/video/tuner-xc2028.c
index c921d6009a8b..e19449603d73 100644
--- a/drivers/media/video/tuner-xc2028.c
+++ b/drivers/media/video/tuner-xc2028.c
@@ -75,9 +75,6 @@ struct xc2028_data {
 							      6M, 7M or 8M */
 	int			need_load_generic; /* The generic firmware
 							      were loaded? */
-
-	int			max_len;	/* Max firmware chunk */
-
 	enum tuner_mode	mode;
 	struct i2c_client	*i2c_client;
 
@@ -426,7 +423,7 @@ static int load_firmware(struct dvb_frontend *fe, unsigned int type,
 {
 	struct xc2028_data *priv = fe-&gt;tuner_priv;
 	int                pos, rc;
-	unsigned char      *p, *endp, buf[priv-&gt;max_len];
+	unsigned char      *p, *endp, buf[priv-&gt;ctrl.max_len];
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
@@ -505,8 +502,8 @@ static int load_firmware(struct dvb_frontend *fe, unsigned int type,
 
 		/* Sends message chunks */
 		while (size &gt; 0) {
-			int len = (size &lt; priv-&gt;max_len - 1) ?
-				   size : priv-&gt;max_len - 1;
+			int len = (size &lt; priv-&gt;ctrl.max_len - 1) ?
+				   size : priv-&gt;ctrl.max_len - 1;
 
 			memcpy(buf + 1, p, len);
 
@@ -881,32 +878,30 @@ static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)
 {
 	struct xc2028_data *priv = fe-&gt;tuner_priv;
 	struct xc2028_ctrl *p    = priv_cfg;
+	int                 rc   = 0;
 
 	tuner_dbg("%s called\n", __FUNCTION__);
 
 	mutex_lock(&amp;priv-&gt;lock);
 
-	priv-&gt;ctrl.type = p-&gt;type;
-
-	if (p-&gt;fname) {
-		kfree(priv-&gt;ctrl.fname);
+	kfree(priv-&gt;ctrl.fname);
+	free_firmware(priv);
 
-		priv-&gt;ctrl.fname = kmalloc(strlen(p-&gt;fname) + 1, GFP_KERNEL);
-		if (priv-&gt;ctrl.fname == NULL) {
-			mutex_unlock(&amp;priv-&gt;lock);
-			return -ENOMEM;
-		}
+	memcpy(&amp;priv-&gt;ctrl, p, sizeof(priv-&gt;ctrl));
+	priv-&gt;ctrl.fname = NULL;
 
-		free_firmware(priv);
-		strcpy(priv-&gt;ctrl.fname, p-&gt;fname);
+	if (p-&gt;fname) {
+		priv-&gt;ctrl.fname = kstrdup(p-&gt;fname, GFP_KERNEL);
+		if (priv-&gt;ctrl.fname == NULL)
+			rc = -ENOMEM;
 	}
 
-	if (p-&gt;max_len &gt; 0)
-		priv-&gt;max_len = p-&gt;max_len;
+	if (priv-&gt;ctrl.max_len &lt; 9)
+		priv-&gt;ctrl.max_len = 13;
 
 	mutex_unlock(&amp;priv-&gt;lock);
 
-	return 0;
+	return rc;
 }
 
 static const struct dvb_tuner_ops xc2028_dvb_tuner_ops = {
@@ -967,7 +962,7 @@ void *xc2028_attach(struct dvb_frontend *fe, struct xc2028_config *cfg)
 		priv-&gt;i2c_props.adap = cfg-&gt;i2c_adap;
 		priv-&gt;video_dev = video_dev;
 		priv-&gt;tuner_callback = cfg-&gt;callback;
-		priv-&gt;max_len = 13;
+		priv-&gt;ctrl.max_len = 13;
 
 		mutex_init(&amp;priv-&gt;lock);
 </pre>
    <div class="pagination">
        <a href='18_2.html'>&lt;&lt;Prev</a><a href='18.html'>1</a><a href='18_2.html'>2</a><span>[3]</span><a href='18_4.html'>4</a><a href='18_5.html'>5</a><a href='18_6.html'>6</a><a href='18_7.html'>7</a><a href='18_4.html'>Next&gt;&gt;</a>
    <div>
</body>
