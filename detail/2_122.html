<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_121.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><span>[122]</span><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_123.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 8bb54ab573ecd1b4fe2ed66416a8d99a86e65316
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:08:49 2006 -0400

    usbcore: add usb_device_driver definition
    
    This patch (as732) adds a usb_device_driver structure, for representing
    drivers that manage an entire USB device as opposed to just an
    interface.  Support routines like usb_register_device_driver,
    usb_deregister_device_driver, usb_probe_device, and usb_unbind_device
    are also added.
    
    Unlike an earlier version of this patch, the new code is type-safe.  To
    accomplish this, the existing struct driver embedded in struct
    usb_driver had to be wrapped in an intermediate wrapper.  This enables
    the core to tell at runtime whether a particular struct driver belongs
    to a device driver or to an interface driver.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index 8dcf2cd0c569..0d4b5dcee3ab 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -84,7 +84,7 @@ static int usb_create_newid_file(struct usb_driver *usb_drv)
 		goto exit;
 
 	if (usb_drv-&gt;probe != NULL)
-		error = sysfs_create_file(&amp;usb_drv-&gt;driver.kobj,
+		error = sysfs_create_file(&amp;usb_drv-&gt;drvwrap.driver.kobj,
 					  &amp;driver_attr_new_id.attr);
 exit:
 	return error;
@@ -96,7 +96,7 @@ static void usb_remove_newid_file(struct usb_driver *usb_drv)
 		return;
 
 	if (usb_drv-&gt;probe != NULL)
-		sysfs_remove_file(&amp;usb_drv-&gt;driver.kobj,
+		sysfs_remove_file(&amp;usb_drv-&gt;drvwrap.driver.kobj,
 				  &amp;driver_attr_new_id.attr);
 }
 
@@ -143,18 +143,55 @@ static const struct usb_device_id *usb_match_dynamic_id(struct usb_interface *in
 }
 
 
-/* called from driver core with usb_bus_type.subsys writelock */
+/* called from driver core with dev locked */
+static int usb_probe_device(struct device *dev)
+{
+	struct usb_device_driver *udriver = to_usb_device_driver(dev-&gt;driver);
+	struct usb_device *udev;
+	int error = -ENODEV;
+
+	dev_dbg(dev, "%s\n", __FUNCTION__);
+
+	if (!is_usb_device(dev))	/* Sanity check */
+		return error;
+
+	udev = to_usb_device(dev);
+
+	/* FIXME: resume a suspended device */
+	if (udev-&gt;state == USB_STATE_SUSPENDED)
+		return -EHOSTUNREACH;
+
+	/* TODO: Add real matching code */
+
+	error = udriver-&gt;probe(udev);
+	return error;
+}
+
+/* called from driver core with dev locked */
+static int usb_unbind_device(struct device *dev)
+{
+	struct usb_device_driver *udriver = to_usb_device_driver(dev-&gt;driver);
+
+	udriver-&gt;disconnect(to_usb_device(dev));
+	return 0;
+}
+
+
+/* called from driver core with dev locked */
 static int usb_probe_interface(struct device *dev)
 {
-	struct usb_interface * intf = to_usb_interface(dev);
-	struct usb_driver * driver = to_usb_driver(dev-&gt;driver);
+	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
+	struct usb_interface *intf;
 	const struct usb_device_id *id;
 	int error = -ENODEV;
 
 	dev_dbg(dev, "%s\n", __FUNCTION__);
 
-	if (!driver-&gt;probe)
+	if (is_usb_device(dev))		/* Sanity check */
 		return error;
+
+	intf = to_usb_interface(dev);
+
 	/* FIXME we'd much prefer to just resume it ... */
 	if (interface_to_usbdev(intf)-&gt;state == USB_STATE_SUSPENDED)
 		return -EHOSTUNREACH;
@@ -182,19 +219,18 @@ static int usb_probe_interface(struct device *dev)
 	return error;
 }
 
-/* called from driver core with usb_bus_type.subsys writelock */
+/* called from driver core with dev locked */
 static int usb_unbind_interface(struct device *dev)
 {
+	struct usb_driver *driver = to_usb_driver(dev-&gt;driver);
 	struct usb_interface *intf = to_usb_interface(dev);
-	struct usb_driver *driver = to_usb_driver(intf-&gt;dev.driver);
 
 	intf-&gt;condition = USB_INTERFACE_UNBINDING;
 
 	/* release all urbs for this interface */
 	usb_disable_interface(interface_to_usbdev(intf), intf);
 
-	if (driver &amp;&amp; driver-&gt;disconnect)
-		driver-&gt;disconnect(intf);
+	driver-&gt;disconnect(intf);
 
 	/* reset other interface state */
 	usb_set_interface(interface_to_usbdev(intf),
@@ -235,7 +271,7 @@ int usb_driver_claim_interface(struct usb_driver *driver,
 	if (dev-&gt;driver)
 		return -EBUSY;
 
-	dev-&gt;driver = &amp;driver-&gt;driver;
+	dev-&gt;driver = &amp;driver-&gt;drvwrap.driver;
 	usb_set_intfdata(iface, priv);
 	iface-&gt;condition = USB_INTERFACE_BOUND;
 	mark_active(iface);
@@ -270,7 +306,7 @@ void usb_driver_release_interface(struct usb_driver *driver,
 	struct device *dev = &amp;iface-&gt;dev;
 
 	/* this should never happen, don't release something that's not ours */
-	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
+	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;drvwrap.driver)
 		return;
 
 	/* don't release from within disconnect() */
@@ -433,24 +469,37 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_match_id);
 
 int usb_device_match(struct device *dev, struct device_driver *drv)
 {
-	struct usb_interface *intf;
-	struct usb_driver *usb_drv;
-	const struct usb_device_id *id;
-
-	/* check for generic driver, which we don't match any device with */
-	if (drv == &amp;usb_generic_driver)
-		return 0;
+	/* devices and interfaces are handled separately */
+	if (is_usb_device(dev)) {
 
-	intf = to_usb_interface(dev);
-	usb_drv = to_usb_driver(drv);
+		/* interface drivers never match devices */
+		if (!is_usb_device_driver(drv))
+			return 0;
 
-	id = usb_match_id(intf, usb_drv-&gt;id_table);
-	if (id)
+		/* TODO: Add real matching code */
 		return 1;
 
-	id = usb_match_dynamic_id(intf, usb_drv);
-	if (id)
-		return 1;
+	} else {
+		struct usb_interface *intf;
+		struct usb_driver *usb_drv;
+		const struct usb_device_id *id;
+
+		/* device drivers never match interfaces */
+		if (is_usb_device_driver(drv))
+			return 0;
+
+		intf = to_usb_interface(dev);
+		usb_drv = to_usb_driver(drv);
+
+		id = usb_match_id(intf, usb_drv-&gt;id_table);
+		if (id)
+			return 1;
+
+		id = usb_match_dynamic_id(intf, usb_drv);
+		if (id)
+			return 1;
+	}
+
 	return 0;
 }
 
@@ -481,14 +530,13 @@ static int usb_uevent(struct device *dev, char **envp, int num_envp,
 	/* driver is often null here; dev_dbg() would oops */
 	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
 
-	/* Must check driver_data here, as on remove driver is always NULL */
-	if ((dev-&gt;driver == &amp;usb_generic_driver) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+	if (is_usb_device(dev))
 		return 0;
-
-	intf = to_usb_interface(dev);
-	usb_dev = interface_to_usbdev (intf);
-	alt = intf-&gt;cur_altsetting;
+	else {
+		intf = to_usb_interface(dev);
+		usb_dev = interface_to_usbdev(intf);
+		alt = intf-&gt;cur_altsetting;
+	}
 
 	if (usb_dev-&gt;devnum &lt; 0) {
 		pr_debug ("usb %s: already deleted?\n", dev-&gt;bus_id);
@@ -569,13 +617,71 @@ static int usb_uevent(struct device *dev, char **envp,
 #endif	/* CONFIG_HOTPLUG */
 
 /**
- * usb_register_driver - register a USB driver
- * @new_driver: USB operations for the driver
+ * usb_register_device_driver - register a USB device (not interface) driver
+ * @new_udriver: USB operations for the device driver
  * @owner: module owner of this driver.
  *
- * Registers a USB driver with the USB core.  The list of unattached
- * interfaces will be rescanned whenever a new driver is added, allowing
- * the new driver to attach to any recognized devices.
+ * Registers a USB device driver with the USB core.  The list of
+ * unattached devices will be rescanned whenever a new driver is
+ * added, allowing the new driver to attach to any recognized devices.
+ * Returns a negative error code on failure and 0 on success.
+ */
+int usb_register_device_driver(struct usb_device_driver *new_udriver,
+		struct module *owner)
+{
+	int retval = 0;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	new_udriver-&gt;drvwrap.for_devices = 1;
+	new_udriver-&gt;drvwrap.driver.name = (char *) new_udriver-&gt;name;
+	new_udriver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;
+	new_udriver-&gt;drvwrap.driver.probe = usb_probe_device;
+	new_udriver-&gt;drvwrap.driver.remove = usb_unbind_device;
+	new_udriver-&gt;drvwrap.driver.owner = owner;
+
+	retval = driver_register(&amp;new_udriver-&gt;drvwrap.driver);
+
+	if (!retval) {
+		pr_info("%s: registered new device driver %s\n",
+			usbcore_name, new_udriver-&gt;name);
+		usbfs_update_special();
+	} else {
+		printk(KERN_ERR "%s: error %d registering device "
+			"	driver %s\n",
+			usbcore_name, retval, new_udriver-&gt;name);
+	}
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(usb_register_device_driver);
+
+/**
+ * usb_deregister_device_driver - unregister a USB device (not interface) driver
+ * @udriver: USB operations of the device driver to unregister
+ * Context: must be able to sleep
+ *
+ * Unlinks the specified driver from the internal USB driver list.
+ */
+void usb_deregister_device_driver(struct usb_device_driver *udriver)
+{
+	pr_info("%s: deregistering device driver %s\n",
+			usbcore_name, udriver-&gt;name);
+
+	driver_unregister(&amp;udriver-&gt;drvwrap.driver);
+	usbfs_update_special();
+}
+EXPORT_SYMBOL_GPL(usb_deregister_device_driver);
+
+/**
+ * usb_register_driver - register a USB interface driver
+ * @new_driver: USB operations for the interface driver
+ * @owner: module owner of this driver.
+ *
+ * Registers a USB interface driver with the USB core.  The list of
+ * unattached interfaces will be rescanned whenever a new driver is
+ * added, allowing the new driver to attach to any recognized interfaces.
  * Returns a negative error code on failure and 0 on success.
  *
  * NOTE: if you want your driver to use the USB major number, you must call
@@ -589,23 +695,25 @@ int usb_register_driver(struct usb_driver *new_driver, struct module *owner)
 	if (usb_disabled())
 		return -ENODEV;
 
-	new_driver-&gt;driver.name = (char *)new_driver-&gt;name;
-	new_driver-&gt;driver.bus = &amp;usb_bus_type;
-	new_driver-&gt;driver.probe = usb_probe_interface;
-	new_driver-&gt;driver.remove = usb_unbind_interface;
-	new_driver-&gt;driver.owner = owner;
+	new_driver-&gt;drvwrap.for_devices = 0;
+	new_driver-&gt;drvwrap.driver.name = (char *) new_driver-&gt;name;
+	new_driver-&gt;drvwrap.driver.bus = &amp;usb_bus_type;
+	new_driver-&gt;drvwrap.driver.probe = usb_probe_interface;
+	new_driver-&gt;drvwrap.driver.remove = usb_unbind_interface;
+	new_driver-&gt;drvwrap.driver.owner = owner;
 	spin_lock_init(&amp;new_driver-&gt;dynids.lock);
 	INIT_LIST_HEAD(&amp;new_driver-&gt;dynids.list);
 
-	retval = driver_register(&amp;new_driver-&gt;driver);
+	retval = driver_register(&amp;new_driver-&gt;drvwrap.driver);
 
 	if (!retval) {
-		pr_info("%s: registered new driver %s\n",
+		pr_info("%s: registered new interface driver %s\n",
 			usbcore_name, new_driver-&gt;name);
 		usbfs_update_special();
 		usb_create_newid_file(new_driver);
 	} else {
-		printk(KERN_ERR "%s: error %d registering driver %s\n",
+		printk(KERN_ERR "%s: error %d registering interface "
+			"	driver %s\n",
 			usbcore_name, retval, new_driver-&gt;name);
 	}
 
@@ -614,8 +722,8 @@ int usb_register_driver(struct usb_driver *new_driver, struct module *owner)
 EXPORT_SYMBOL_GPL_FUTURE(usb_register_driver);
 
 /**
- * usb_deregister - unregister a USB driver
- * @driver: USB operations of the driver to unregister
+ * usb_deregister - unregister a USB interface driver
+ * @driver: USB operations of the interface driver to unregister
  * Context: must be able to sleep
  *
  * Unlinks the specified driver from the internal USB driver list.
@@ -626,11 +734,12 @@ EXPORT_SYMBOL_GPL_FUTURE(usb_register_driver);
  */
 void usb_deregister(struct usb_driver *driver)
 {
-	pr_info("%s: deregistering driver %s\n", usbcore_name, driver-&gt;name);
+	pr_info("%s: deregistering interface driver %s\n",
+			usbcore_name, driver-&gt;name);
 
 	usb_remove_newid_file(driver);
 	usb_free_dynids(driver);
-	driver_unregister(&amp;driver-&gt;driver);
+	driver_unregister(&amp;driver-&gt;drvwrap.driver);
 
 	usbfs_update_special();
 }
@@ -655,7 +764,7 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
 	 * marked for FREEZE as soon as their children are already idled.
 	 * But those semantics are useless, so we equate the two (sigh).
 	 */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
+	if (is_usb_device(dev)) {
 		if (dev-&gt;power.power_state.event == message.event)
 			return 0;
 		/* we need to rule out bogus requests through sysfs */
@@ -665,8 +774,7 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
  		return usb_port_suspend(to_usb_device(dev));
 	}
 
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+	if (dev-&gt;driver == NULL)
 		return 0;
 
 	intf = to_usb_interface(dev);
@@ -705,15 +813,14 @@ static int usb_generic_resume(struct device *dev)
 	dev-&gt;power.power_state.event = PM_EVENT_ON;
 
 	/* devices resume through their hubs */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
+	if (is_usb_device(dev)) {
 		udev = to_usb_device(dev);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return 0;
 		return usb_port_resume(udev);
 	}
 
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data)) {
+	if (dev-&gt;driver == NULL) {
 		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
 		return 0;
 	}
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index 7bab9769b34f..fa6f34a12b4b 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -21,14 +21,12 @@
 #include &lt;linux/usb.h&gt;
 #include "usb.h"
 
-static int generic_probe(struct device *dev)
+static int generic_probe(struct usb_device *udev)
 {
 	return 0;
 }
-static int generic_remove(struct device *dev)
+static void generic_disconnect(struct usb_device *udev)
 {
-	struct usb_device *udev = to_usb_device(dev);
-
 	/* if this is only an unbind, not a physical disconnect, then
 	 * unconfigure the device */
 	if (udev-&gt;state == USB_STATE_CONFIGURED)
@@ -37,17 +35,10 @@ static int generic_remove(struct device *dev)
 	/* in case the call failed or the device was suspended */
 	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
 		usb_disable_device(udev, 0);
-	return 0;
 }
 
-struct device_driver usb_generic_driver = {
-	.owner = THIS_MODULE,
+struct usb_device_driver usb_generic_driver = {
 	.name =	"usb",
-	.bus = &amp;usb_bus_type,
 	.probe = generic_probe,
-	.remove = generic_remove,
+	.disconnect = generic_disconnect,
 };
-
-/* Fun hack to determine if the struct device is a
- * usb device or a usb interface. */
-int usb_generic_driver_data;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index 0b8c67bcde60..6dfbc284369b 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -123,7 +123,7 @@ static int __find_interface(struct device * dev, void * data)
 	struct usb_interface *intf;
 
 	/* can't look at usb devices, only interfaces */
-	if (dev-&gt;driver == &amp;usb_generic_driver)
+	if (is_usb_device(dev))
 		return 0;
 
 	intf = to_usb_interface(dev);
@@ -149,7 +149,8 @@ struct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)
 
 	argb.minor = minor;
 	argb.interface = NULL;
-	driver_for_each_device(&amp;drv-&gt;driver, NULL, &amp;argb, __find_interface);
+	driver_for_each_device(&amp;drv-&gt;drvwrap.driver, NULL, &amp;argb,
+			__find_interface);
 	return argb.interface;
 }
 
@@ -204,11 +205,13 @@ usb_alloc_dev(struct usb_device *parent, struct usb_bus *bus, unsigned port1)
 	device_initialize(&amp;dev-&gt;dev);
 	dev-&gt;dev.bus = &amp;usb_bus_type;
 	dev-&gt;dev.dma_mask = bus-&gt;controller-&gt;dma_mask;
-	dev-&gt;dev.driver_data = &amp;usb_generic_driver_data;
-	dev-&gt;dev.driver = &amp;usb_generic_driver;
+	dev-&gt;dev.driver = &amp;usb_generic_driver.drvwrap.driver;
 	dev-&gt;dev.release = usb_release_dev;
 	dev-&gt;state = USB_STATE_ATTACHED;
 
+	/* This magic assignment distinguishes devices from interfaces */
+	dev-&gt;dev.platform_data = &amp;usb_generic_driver;
+
 	INIT_LIST_HEAD(&amp;dev-&gt;ep0.urb_list);
 	dev-&gt;ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;
 	dev-&gt;ep0.desc.bDescriptorType = USB_DT_ENDPOINT;
@@ -838,7 +841,7 @@ static int __init usb_init(void)
 	retval = usb_hub_init();
 	if (retval)
 		goto hub_init_failed;
-	retval = driver_register(&amp;usb_generic_driver);
+	retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);
 	if (!retval)
 		goto out;
 
@@ -868,7 +871,7 @@ static void __exit usb_exit(void)
 	if (nousb)
 		return;
 
-	driver_unregister(&amp;usb_generic_driver);
+	usb_deregister_device_driver(&amp;usb_generic_driver);
 	usb_major_cleanup();
 	usbfs_cleanup();
 	usb_deregister(&amp;usbfs_driver);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 82d397a6f773..1d25ccac7832 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -34,8 +34,24 @@ extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
 extern struct bus_type usb_bus_type;
-extern struct device_driver usb_generic_driver;
-extern int usb_generic_driver_data;
+extern struct usb_device_driver usb_generic_driver;
+
+/* Here's how we tell apart devices and interfaces.  Luckily there's
+ * no such thing as a platform USB device, so we can steal the use
+ * of the platform_data field. */
+
+static inline int is_usb_device(struct device *dev)
+{
+	return dev-&gt;platform_data == &amp;usb_generic_driver;
+}
+
+/* Do the same for device drivers and interface drivers. */
+
+static inline int is_usb_device_driver(struct device_driver *drv)
+{
+	return container_of(drv, struct usbdrv_wrap, driver)-&gt;
+			for_devices;
+}
 
 /* Interfaces and their "power state" are owned by usbcore */
 
diff --git a/include/linux/usb.h b/include/linux/usb.h
index d2bd0c8e0154..b4ccce6d0982 100644
--- a/include/linux/usb.h
+++ b/include/linux/usb.h
@@ -540,7 +540,17 @@ struct usb_dynids {
 };
 
 /**
- * struct usb_driver - identifies USB driver to usbcore
+ * struct usbdrv_wrap - wrapper for driver-model structure
+ * @driver: The driver-model core driver structure.
+ * @for_devices: Non-zero for device drivers, 0 for interface drivers.
+ */
+struct usbdrv_wrap {
+	struct device_driver driver;
+	int for_devices;
+};
+
+/**
+ * struct usb_driver - identifies USB interface driver to usbcore
  * @name: The driver name should be unique among USB drivers,
  *	and should normally be the same as the module name.
  * @probe: Called to see if the driver is willing to manage a particular
@@ -567,12 +577,12 @@ struct usb_dynids {
  *	or your driver's probe function will never get called.
  * @dynids: used internally to hold the list of dynamically added device
  *	ids for this driver.
- * @driver: the driver model core driver structure.
+ * @drvwrap: Driver-model core structure wrapper.
  * @no_dynamic_id: if set to 1, the USB core will not allow dynamic ids to be
  *	added to this driver by preventing the sysfs file from being created.
  *
- * USB drivers must provide a name, probe() and disconnect() methods,
- * and an id_table.  Other driver fields are optional.
+ * USB interface drivers must provide a name, probe() and disconnect()
+ * methods, and an id_table.  Other driver fields are optional.
  *
  * The id_table is used in hotplugging.  It holds a set of descriptors,
  * and specialized data may be associated with each entry.  That table
@@ -606,10 +616,40 @@ struct usb_driver {
 	const struct usb_device_id *id_table;
 
 	struct usb_dynids dynids;
-	struct device_driver driver;
+	struct usbdrv_wrap drvwrap;
 	unsigned int no_dynamic_id:1;
 };
-#define	to_usb_driver(d) container_of(d, struct usb_driver, driver)
+#define	to_usb_driver(d) container_of(d, struct usb_driver, drvwrap.driver)
+
+/**
+ * struct usb_device_driver - identifies USB device driver to usbcore
+ * @name: The driver name should be unique among USB drivers,
+ *	and should normally be the same as the module name.
+ * @probe: Called to see if the driver is willing to manage a particular
+ *	device.  If it is, probe returns zero and uses dev_set_drvdata()
+ *	to associate driver-specific data with the device.  If unwilling
+ *	to manage the device, return a negative errno value.
+ * @disconnect: Called when the device is no longer accessible, usually
+ *	because it has been (or is being) disconnected or the driver's
+ *	module is being unloaded.
+ * @suspend: Called when the device is going to be suspended by the system.
+ * @resume: Called when the device is being resumed by the system.
+ * @drvwrap: Driver-model core structure wrapper.
+ *
+ * USB drivers must provide all the fields listed above except drvwrap.
+ */
+struct usb_device_driver {
+	const char *name;
+
+	int (*probe) (struct usb_device *udev);
+	void (*disconnect) (struct usb_device *udev);
+
+	int (*suspend) (struct usb_device *udev, pm_message_t message);
+	int (*resume) (struct usb_device *udev);
+	struct usbdrv_wrap drvwrap;
+};
+#define	to_usb_device_driver(d) container_of(d, struct usb_device_driver, \
+		drvwrap.driver)
 
 extern struct bus_type usb_bus_type;
 
@@ -633,13 +673,17 @@ struct usb_class_driver {
  * use these in module_init()/module_exit()
  * and don't forget MODULE_DEVICE_TABLE(usb, ...)
  */
-int usb_register_driver(struct usb_driver *, struct module *);
+extern int usb_register_driver(struct usb_driver *, struct module *);
 static inline int usb_register(struct usb_driver *driver)
 {
 	return usb_register_driver(driver, THIS_MODULE);
 }
 extern void usb_deregister(struct usb_driver *);
 
+extern int usb_register_device_driver(struct usb_device_driver *,
+			struct module *);
+extern void usb_deregister_device_driver(struct usb_device_driver *);
+
 extern int usb_register_dev(struct usb_interface *intf,
 			    struct usb_class_driver *class_driver);
 extern void usb_deregister_dev(struct usb_interface *intf,</pre><hr><pre>commit 36e56a34586783c7986ce09d39db80b27c95ce24
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:08:06 2006 -0400

    usbcore: move code among source files
    
    This revised patch (as713b) moves a few routines among source files in
    usbcore.  Some driver-related code in usb.c (claiming interfaces and
    matching IDs) is moved to driver.c, where it belongs.  Also the
    usb_generic stuff in driver.c is moved to a new source file: generic.c.
    (That's the reason for revising the patch.)  Although not very big now,
    it will get bigger in a later patch.
    
    None of the code has been changed; it has only been re-arranged.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/Makefile b/drivers/usb/core/Makefile
index ec510922af63..34e9bac319b4 100644
--- a/drivers/usb/core/Makefile
+++ b/drivers/usb/core/Makefile
@@ -4,7 +4,7 @@
 
 usbcore-objs	:= usb.o hub.o hcd.o urb.o message.o driver.o \
 			config.o file.o buffer.o sysfs.o endpoint.o \
-			devio.o notify.o
+			devio.o notify.o generic.o
 
 ifeq ($(CONFIG_PCI),y)
 	usbcore-objs	+= hcd-pci.o
diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c
index ec8906501415..8dcf2cd0c569 100644
--- a/drivers/usb/core/driver.c
+++ b/drivers/usb/core/driver.c
@@ -17,7 +17,8 @@
  *
  * NOTE! This is not actually a driver at all, rather this is
  * just a collection of helper routines that implement the
- * generic USB things that the real drivers can use..
+ * matching, probing, releasing, suspending and resuming for
+ * real drivers.
  *
  */
 
@@ -34,38 +35,6 @@ struct usb_dynid {
 	struct usb_device_id id;
 };
 
-
-static int generic_probe(struct device *dev)
-{
-	return 0;
-}
-static int generic_remove(struct device *dev)
-{
-	struct usb_device *udev = to_usb_device(dev);
-
-	/* if this is only an unbind, not a physical disconnect, then
-	 * unconfigure the device */
-	if (udev-&gt;state == USB_STATE_CONFIGURED)
-		usb_set_configuration(udev, 0);
-
-	/* in case the call failed or the device was suspended */
-	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
-		usb_disable_device(udev, 0);
-	return 0;
-}
-
-struct device_driver usb_generic_driver = {
-	.owner = THIS_MODULE,
-	.name =	"usb",
-	.bus = &amp;usb_bus_type,
-	.probe = generic_probe,
-	.remove = generic_remove,
-};
-
-/* Fun hack to determine if the struct device is a
- * usb device or a usb interface. */
-int usb_generic_driver_data;
-
 #ifdef CONFIG_HOTPLUG
 
 /*
@@ -238,6 +207,89 @@ static int usb_unbind_interface(struct device *dev)
 	return 0;
 }
 
+/**
+ * usb_driver_claim_interface - bind a driver to an interface
+ * @driver: the driver to be bound
+ * @iface: the interface to which it will be bound; must be in the
+ *	usb device's active configuration
+ * @priv: driver data associated with that interface
+ *
+ * This is used by usb device drivers that need to claim more than one
+ * interface on a device when probing (audio and acm are current examples).
+ * No device driver should directly modify internal usb_interface or
+ * usb_device structure members.
+ *
+ * Few drivers should need to use this routine, since the most natural
+ * way to bind to an interface is to return the private data from
+ * the driver's probe() method.
+ *
+ * Callers must own the device lock and the driver model's usb_bus_type.subsys
+ * writelock.  So driver probe() entries don't need extra locking,
+ * but other call contexts may need to explicitly claim those locks.
+ */
+int usb_driver_claim_interface(struct usb_driver *driver,
+				struct usb_interface *iface, void* priv)
+{
+	struct device *dev = &amp;iface-&gt;dev;
+
+	if (dev-&gt;driver)
+		return -EBUSY;
+
+	dev-&gt;driver = &amp;driver-&gt;driver;
+	usb_set_intfdata(iface, priv);
+	iface-&gt;condition = USB_INTERFACE_BOUND;
+	mark_active(iface);
+
+	/* if interface was already added, bind now; else let
+	 * the future device_add() bind it, bypassing probe()
+	 */
+	if (device_is_registered(dev))
+		device_bind_driver(dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(usb_driver_claim_interface);
+
+/**
+ * usb_driver_release_interface - unbind a driver from an interface
+ * @driver: the driver to be unbound
+ * @iface: the interface from which it will be unbound
+ *
+ * This can be used by drivers to release an interface without waiting
+ * for their disconnect() methods to be called.  In typical cases this
+ * also causes the driver disconnect() method to be called.
+ *
+ * This call is synchronous, and may not be used in an interrupt context.
+ * Callers must own the device lock and the driver model's usb_bus_type.subsys
+ * writelock.  So driver disconnect() entries don't need extra locking,
+ * but other call contexts may need to explicitly claim those locks.
+ */
+void usb_driver_release_interface(struct usb_driver *driver,
+					struct usb_interface *iface)
+{
+	struct device *dev = &amp;iface-&gt;dev;
+
+	/* this should never happen, don't release something that's not ours */
+	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
+		return;
+
+	/* don't release from within disconnect() */
+	if (iface-&gt;condition != USB_INTERFACE_BOUND)
+		return;
+
+	/* don't release if the interface hasn't been added yet */
+	if (device_is_registered(dev)) {
+		iface-&gt;condition = USB_INTERFACE_UNBINDING;
+		device_release_driver(dev);
+	}
+
+	dev-&gt;driver = NULL;
+	usb_set_intfdata(iface, NULL);
+	iface-&gt;condition = USB_INTERFACE_UNBOUND;
+	mark_quiesced(iface);
+}
+EXPORT_SYMBOL(usb_driver_release_interface);
+
 /* returns 0 if no match, 1 if match */
 static int usb_match_one_id(struct usb_interface *interface,
 			    const struct usb_device_id *id)
@@ -402,6 +454,120 @@ int usb_device_match(struct device *dev, struct device_driver *drv)
 	return 0;
 }
 
+#ifdef	CONFIG_HOTPLUG
+
+/*
+ * This sends an uevent to userspace, typically helping to load driver
+ * or other modules, configure the device, and more.  Drivers can provide
+ * a MODULE_DEVICE_TABLE to help with module loading subtasks.
+ *
+ * We're called either from khubd (the typical case) or from root hub
+ * (init, kapmd, modprobe, rmmod, etc), but the agents need to handle
+ * delays in event delivery.  Use sysfs (and DEVPATH) to make sure the
+ * device (and this configuration!) are still present.
+ */
+static int usb_uevent(struct device *dev, char **envp, int num_envp,
+		      char *buffer, int buffer_size)
+{
+	struct usb_interface *intf;
+	struct usb_device *usb_dev;
+	struct usb_host_interface *alt;
+	int i = 0;
+	int length = 0;
+
+	if (!dev)
+		return -ENODEV;
+
+	/* driver is often null here; dev_dbg() would oops */
+	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
+
+	/* Must check driver_data here, as on remove driver is always NULL */
+	if ((dev-&gt;driver == &amp;usb_generic_driver) ||
+	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+		return 0;
+
+	intf = to_usb_interface(dev);
+	usb_dev = interface_to_usbdev (intf);
+	alt = intf-&gt;cur_altsetting;
+
+	if (usb_dev-&gt;devnum &lt; 0) {
+		pr_debug ("usb %s: already deleted?\n", dev-&gt;bus_id);
+		return -ENODEV;
+	}
+	if (!usb_dev-&gt;bus) {
+		pr_debug ("usb %s: bus removed?\n", dev-&gt;bus_id);
+		return -ENODEV;
+	}
+
+#ifdef	CONFIG_USB_DEVICEFS
+	/* If this is available, userspace programs can directly read
+	 * all the device descriptors we don't tell them about.  Or
+	 * even act as usermode drivers.
+	 *
+	 * FIXME reduce hardwired intelligence here
+	 */
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "DEVICE=/proc/bus/usb/%03d/%03d",
+			   usb_dev-&gt;bus-&gt;busnum, usb_dev-&gt;devnum))
+		return -ENOMEM;
+#endif
+
+	/* per-device configurations are common */
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "PRODUCT=%x/%x/%x",
+			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
+			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
+			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice)))
+		return -ENOMEM;
+
+	/* class-based driver binding models */
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "TYPE=%d/%d/%d",
+			   usb_dev-&gt;descriptor.bDeviceClass,
+			   usb_dev-&gt;descriptor.bDeviceSubClass,
+			   usb_dev-&gt;descriptor.bDeviceProtocol))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "INTERFACE=%d/%d/%d",
+			   alt-&gt;desc.bInterfaceClass,
+			   alt-&gt;desc.bInterfaceSubClass,
+			   alt-&gt;desc.bInterfaceProtocol))
+		return -ENOMEM;
+
+	if (add_uevent_var(envp, num_envp, &amp;i,
+			   buffer, buffer_size, &amp;length,
+			   "MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
+			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
+			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
+			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice),
+			   usb_dev-&gt;descriptor.bDeviceClass,
+			   usb_dev-&gt;descriptor.bDeviceSubClass,
+			   usb_dev-&gt;descriptor.bDeviceProtocol,
+			   alt-&gt;desc.bInterfaceClass,
+			   alt-&gt;desc.bInterfaceSubClass,
+			   alt-&gt;desc.bInterfaceProtocol))
+		return -ENOMEM;
+
+	envp[i] = NULL;
+
+	return 0;
+}
+
+#else
+
+static int usb_uevent(struct device *dev, char **envp,
+			int num_envp, char *buffer, int buffer_size)
+{
+	return -ENODEV;
+}
+
+#endif	/* CONFIG_HOTPLUG */
+
 /**
  * usb_register_driver - register a USB driver
  * @new_driver: USB operations for the driver
@@ -469,3 +635,119 @@ void usb_deregister(struct usb_driver *driver)
 	usbfs_update_special();
 }
 EXPORT_SYMBOL_GPL_FUTURE(usb_deregister);
+
+#ifdef CONFIG_PM
+
+static int verify_suspended(struct device *dev, void *unused)
+{
+	if (dev-&gt;driver == NULL)
+		return 0;
+	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
+}
+
+static int usb_generic_suspend(struct device *dev, pm_message_t message)
+{
+	struct usb_interface	*intf;
+	struct usb_driver	*driver;
+	int			status;
+
+	/* USB devices enter SUSPEND state through their hubs, but can be
+	 * marked for FREEZE as soon as their children are already idled.
+	 * But those semantics are useless, so we equate the two (sigh).
+	 */
+	if (dev-&gt;driver == &amp;usb_generic_driver) {
+		if (dev-&gt;power.power_state.event == message.event)
+			return 0;
+		/* we need to rule out bogus requests through sysfs */
+		status = device_for_each_child(dev, NULL, verify_suspended);
+		if (status)
+			return status;
+ 		return usb_port_suspend(to_usb_device(dev));
+	}
+
+	if ((dev-&gt;driver == NULL) ||
+	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
+		return 0;
+
+	intf = to_usb_interface(dev);
+	driver = to_usb_driver(dev-&gt;driver);
+
+	/* with no hardware, USB interfaces only use FREEZE and ON states */
+	if (!is_active(intf))
+		return 0;
+
+	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
+		status = driver-&gt;suspend(intf, message);
+		if (status)
+			dev_err(dev, "%s error %d\n", "suspend", status);
+		else
+			mark_quiesced(intf);
+	} else {
+		// FIXME else if there's no suspend method, disconnect...
+		dev_warn(dev, "no suspend for driver %s?\n", driver-&gt;name);
+		mark_quiesced(intf);
+		status = 0;
+	}
+	return status;
+}
+
+static int usb_generic_resume(struct device *dev)
+{
+	struct usb_interface	*intf;
+	struct usb_driver	*driver;
+	struct usb_device	*udev;
+	int			status;
+
+	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
+		return 0;
+
+	/* mark things as "on" immediately, no matter what errors crop up */
+	dev-&gt;power.power_state.event = PM_EVENT_ON;
+
+	/* devices resume through their hubs */
+	if (dev-&gt;driver == &amp;usb_generic_driver) {
+		udev = to_usb_device(dev);
+		if (udev-&gt;state == USB_STATE_NOTATTACHED)
+			return 0;
+		return usb_port_resume(udev);
+	}
+
+	if ((dev-&gt;driver == NULL) ||
+	    (dev-&gt;driver_data == &amp;usb_generic_driver_data)) {
+		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
+		return 0;
+	}
+
+	intf = to_usb_interface(dev);
+	driver = to_usb_driver(dev-&gt;driver);
+
+	udev = interface_to_usbdev(intf);
+	if (udev-&gt;state == USB_STATE_NOTATTACHED)
+		return 0;
+
+	/* if driver was suspended, it has a resume method;
+	 * however, sysfs can wrongly mark things as suspended
+	 * (on the "no suspend method" FIXME path above)
+	 */
+	if (driver-&gt;resume) {
+		status = driver-&gt;resume(intf);
+		if (status) {
+			dev_err(dev, "%s error %d\n", "resume", status);
+			mark_quiesced(intf);
+		}
+	} else
+		dev_warn(dev, "no resume for driver %s?\n", driver-&gt;name);
+	return 0;
+}
+
+#endif /* CONFIG_PM */
+
+struct bus_type usb_bus_type = {
+	.name =		"usb",
+	.match =	usb_device_match,
+	.uevent =	usb_uevent,
+#ifdef CONFIG_PM
+	.suspend =	usb_generic_suspend,
+	.resume =	usb_generic_resume,
+#endif
+};
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
new file mode 100644
index 000000000000..7bab9769b34f
--- /dev/null
+++ b/drivers/usb/core/generic.c
@@ -0,0 +1,53 @@
+/*
+ * drivers/usb/generic.c - generic driver for USB devices (not interfaces)
+ *
+ * (C) Copyright 2005 Greg Kroah-Hartman &lt;gregkh@suse.de&gt;
+ *
+ * based on drivers/usb/usb.c which had the following copyrights:
+ *	(C) Copyright Linus Torvalds 1999
+ *	(C) Copyright Johannes Erdfelt 1999-2001
+ *	(C) Copyright Andreas Gal 1999
+ *	(C) Copyright Gregory P. Smith 1999
+ *	(C) Copyright Deti Fliegl 1999 (new USB architecture)
+ *	(C) Copyright Randy Dunlap 2000
+ *	(C) Copyright David Brownell 2000-2004
+ *	(C) Copyright Yggdrasil Computing, Inc. 2000
+ *		(usb_device_id matching changes by Adam J. Richter)
+ *	(C) Copyright Greg Kroah-Hartman 2002-2003
+ *
+ */
+
+#include &lt;linux/config.h&gt;
+#include &lt;linux/usb.h&gt;
+#include "usb.h"
+
+static int generic_probe(struct device *dev)
+{
+	return 0;
+}
+static int generic_remove(struct device *dev)
+{
+	struct usb_device *udev = to_usb_device(dev);
+
+	/* if this is only an unbind, not a physical disconnect, then
+	 * unconfigure the device */
+	if (udev-&gt;state == USB_STATE_CONFIGURED)
+		usb_set_configuration(udev, 0);
+
+	/* in case the call failed or the device was suspended */
+	if (udev-&gt;state &gt;= USB_STATE_CONFIGURED)
+		usb_disable_device(udev, 0);
+	return 0;
+}
+
+struct device_driver usb_generic_driver = {
+	.owner = THIS_MODULE,
+	.name =	"usb",
+	.bus = &amp;usb_bus_type,
+	.probe = generic_probe,
+	.remove = generic_remove,
+};
+
+/* Fun hack to determine if the struct device is a
+ * usb device or a usb interface. */
+int usb_generic_driver_data;
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index b28a31b20308..0b8c67bcde60 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -112,87 +112,6 @@ struct usb_host_interface *usb_altnum_to_altsetting(struct usb_interface *intf,
 	return NULL;
 }
 
-/**
- * usb_driver_claim_interface - bind a driver to an interface
- * @driver: the driver to be bound
- * @iface: the interface to which it will be bound; must be in the
- *	usb device's active configuration
- * @priv: driver data associated with that interface
- *
- * This is used by usb device drivers that need to claim more than one
- * interface on a device when probing (audio and acm are current examples).
- * No device driver should directly modify internal usb_interface or
- * usb_device structure members.
- *
- * Few drivers should need to use this routine, since the most natural
- * way to bind to an interface is to return the private data from
- * the driver's probe() method.
- *
- * Callers must own the device lock and the driver model's usb_bus_type.subsys
- * writelock.  So driver probe() entries don't need extra locking,
- * but other call contexts may need to explicitly claim those locks.
- */
-int usb_driver_claim_interface(struct usb_driver *driver,
-				struct usb_interface *iface, void* priv)
-{
-	struct device *dev = &amp;iface-&gt;dev;
-
-	if (dev-&gt;driver)
-		return -EBUSY;
-
-	dev-&gt;driver = &amp;driver-&gt;driver;
-	usb_set_intfdata(iface, priv);
-	iface-&gt;condition = USB_INTERFACE_BOUND;
-	mark_active(iface);
-
-	/* if interface was already added, bind now; else let
-	 * the future device_add() bind it, bypassing probe()
-	 */
-	if (device_is_registered(dev))
-		device_bind_driver(dev);
-
-	return 0;
-}
-
-/**
- * usb_driver_release_interface - unbind a driver from an interface
- * @driver: the driver to be unbound
- * @iface: the interface from which it will be unbound
- *
- * This can be used by drivers to release an interface without waiting
- * for their disconnect() methods to be called.  In typical cases this
- * also causes the driver disconnect() method to be called.
- *
- * This call is synchronous, and may not be used in an interrupt context.
- * Callers must own the device lock and the driver model's usb_bus_type.subsys
- * writelock.  So driver disconnect() entries don't need extra locking,
- * but other call contexts may need to explicitly claim those locks.
- */
-void usb_driver_release_interface(struct usb_driver *driver,
-					struct usb_interface *iface)
-{
-	struct device *dev = &amp;iface-&gt;dev;
-
-	/* this should never happen, don't release something that's not ours */
-	if (!dev-&gt;driver || dev-&gt;driver != &amp;driver-&gt;driver)
-		return;
-
-	/* don't release from within disconnect() */
-	if (iface-&gt;condition != USB_INTERFACE_BOUND)
-		return;
-
-	/* don't release if the interface hasn't been added yet */
-	if (device_is_registered(dev)) {
-		iface-&gt;condition = USB_INTERFACE_UNBINDING;
-		device_release_driver(dev);
-	}
-
-	dev-&gt;driver = NULL;
-	usb_set_intfdata(iface, NULL);
-	iface-&gt;condition = USB_INTERFACE_UNBOUND;
-	mark_quiesced(iface);
-}
-
 struct find_interface_arg {
 	int minor;
 	struct usb_interface *interface;
@@ -234,120 +153,6 @@ struct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)
 	return argb.interface;
 }
 
-#ifdef	CONFIG_HOTPLUG
-
-/*
- * This sends an uevent to userspace, typically helping to load driver
- * or other modules, configure the device, and more.  Drivers can provide
- * a MODULE_DEVICE_TABLE to help with module loading subtasks.
- *
- * We're called either from khubd (the typical case) or from root hub
- * (init, kapmd, modprobe, rmmod, etc), but the agents need to handle
- * delays in event delivery.  Use sysfs (and DEVPATH) to make sure the
- * device (and this configuration!) are still present.
- */
-static int usb_uevent(struct device *dev, char **envp, int num_envp,
-		      char *buffer, int buffer_size)
-{
-	struct usb_interface *intf;
-	struct usb_device *usb_dev;
-	struct usb_host_interface *alt;
-	int i = 0;
-	int length = 0;
-
-	if (!dev)
-		return -ENODEV;
-
-	/* driver is often null here; dev_dbg() would oops */
-	pr_debug ("usb %s: uevent\n", dev-&gt;bus_id);
-
-	/* Must check driver_data here, as on remove driver is always NULL */
-	if ((dev-&gt;driver == &amp;usb_generic_driver) || 
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
-		return 0;
-
-	intf = to_usb_interface(dev);
-	usb_dev = interface_to_usbdev (intf);
-	alt = intf-&gt;cur_altsetting;
-
-	if (usb_dev-&gt;devnum &lt; 0) {
-		pr_debug ("usb %s: already deleted?\n", dev-&gt;bus_id);
-		return -ENODEV;
-	}
-	if (!usb_dev-&gt;bus) {
-		pr_debug ("usb %s: bus removed?\n", dev-&gt;bus_id);
-		return -ENODEV;
-	}
-
-#ifdef	CONFIG_USB_DEVICEFS
-	/* If this is available, userspace programs can directly read
-	 * all the device descriptors we don't tell them about.  Or
-	 * even act as usermode drivers.
-	 *
-	 * FIXME reduce hardwired intelligence here
-	 */
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "DEVICE=/proc/bus/usb/%03d/%03d",
-			   usb_dev-&gt;bus-&gt;busnum, usb_dev-&gt;devnum))
-		return -ENOMEM;
-#endif
-
-	/* per-device configurations are common */
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "PRODUCT=%x/%x/%x",
-			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
-			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
-			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice)))
-		return -ENOMEM;
-
-	/* class-based driver binding models */
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "TYPE=%d/%d/%d",
-			   usb_dev-&gt;descriptor.bDeviceClass,
-			   usb_dev-&gt;descriptor.bDeviceSubClass,
-			   usb_dev-&gt;descriptor.bDeviceProtocol))
-		return -ENOMEM;
-
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "INTERFACE=%d/%d/%d",
-			   alt-&gt;desc.bInterfaceClass,
-			   alt-&gt;desc.bInterfaceSubClass,
-			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
-
-	if (add_uevent_var(envp, num_envp, &amp;i,
-			   buffer, buffer_size, &amp;length,
-			   "MODALIAS=usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02X",
-			   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),
-			   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),
-			   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice),
-			   usb_dev-&gt;descriptor.bDeviceClass,
-			   usb_dev-&gt;descriptor.bDeviceSubClass,
-			   usb_dev-&gt;descriptor.bDeviceProtocol,
-			   alt-&gt;desc.bInterfaceClass,
-			   alt-&gt;desc.bInterfaceSubClass,
-			   alt-&gt;desc.bInterfaceProtocol))
-		return -ENOMEM;
-
-	envp[i] = NULL;
-
-	return 0;
-}
-
-#else
-
-static int usb_uevent(struct device *dev, char **envp,
-			int num_envp, char *buffer, int buffer_size)
-{
-	return -ENODEV;
-}
-
-#endif	/* CONFIG_HOTPLUG */
-
 /**
  * usb_release_dev - free a usb device structure when all users of it are finished.
  * @dev: device that's been disconnected
@@ -990,116 +795,6 @@ void usb_buffer_unmap_sg (struct usb_device *dev, unsigned pipe,
 			usb_pipein (pipe) ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 }
 
-static int verify_suspended(struct device *dev, void *unused)
-{
-	if (dev-&gt;driver == NULL)
-		return 0;
-	return (dev-&gt;power.power_state.event == PM_EVENT_ON) ? -EBUSY : 0;
-}
-
-static int usb_generic_suspend(struct device *dev, pm_message_t message)
-{
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	int			status;
-
-	/* USB devices enter SUSPEND state through their hubs, but can be
-	 * marked for FREEZE as soon as their children are already idled.
-	 * But those semantics are useless, so we equate the two (sigh).
-	 */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
-		if (dev-&gt;power.power_state.event == message.event)
-			return 0;
-		/* we need to rule out bogus requests through sysfs */
-		status = device_for_each_child(dev, NULL, verify_suspended);
-		if (status)
-			return status;
- 		return usb_port_suspend(to_usb_device(dev));
-	}
-
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data))
-		return 0;
-
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
-
-	/* with no hardware, USB interfaces only use FREEZE and ON states */
-	if (!is_active(intf))
-		return 0;
-
-	if (driver-&gt;suspend &amp;&amp; driver-&gt;resume) {
-		status = driver-&gt;suspend(intf, message);
-		if (status)
-			dev_err(dev, "%s error %d\n", "suspend", status);
-		else
-			mark_quiesced(intf);
-	} else {
-		// FIXME else if there's no suspend method, disconnect...
-		dev_warn(dev, "no suspend for driver %s?\n", driver-&gt;name);
-		mark_quiesced(intf);
-		status = 0;
-	}
-	return status;
-}
-
-static int usb_generic_resume(struct device *dev)
-{
-	struct usb_interface	*intf;
-	struct usb_driver	*driver;
-	struct usb_device	*udev;
-	int			status;
-
-	if (dev-&gt;power.power_state.event == PM_EVENT_ON)
-		return 0;
-
-	/* mark things as "on" immediately, no matter what errors crop up */
-	dev-&gt;power.power_state.event = PM_EVENT_ON;
-
-	/* devices resume through their hubs */
-	if (dev-&gt;driver == &amp;usb_generic_driver) {
-		udev = to_usb_device(dev);
-		if (udev-&gt;state == USB_STATE_NOTATTACHED)
-			return 0;
-		return usb_port_resume(udev);
-	}
-
-	if ((dev-&gt;driver == NULL) ||
-	    (dev-&gt;driver_data == &amp;usb_generic_driver_data)) {
-		dev-&gt;power.power_state.event = PM_EVENT_FREEZE;
-		return 0;
-	}
-
-	intf = to_usb_interface(dev);
-	driver = to_usb_driver(dev-&gt;driver);
-
-	udev = interface_to_usbdev(intf);
-	if (udev-&gt;state == USB_STATE_NOTATTACHED)
-		return 0;
-
-	/* if driver was suspended, it has a resume method;
-	 * however, sysfs can wrongly mark things as suspended
-	 * (on the "no suspend method" FIXME path above)
-	 */
-	if (driver-&gt;resume) {
-		status = driver-&gt;resume(intf);
-		if (status) {
-			dev_err(dev, "%s error %d\n", "resume", status);
-			mark_quiesced(intf);
-		}
-	} else
-		dev_warn(dev, "no resume for driver %s?\n", driver-&gt;name);
-	return 0;
-}
-
-struct bus_type usb_bus_type = {
-	.name =		"usb",
-	.match =	usb_device_match,
-	.uevent =	usb_uevent,
-	.suspend =	usb_generic_suspend,
-	.resume =	usb_generic_resume,
-};
-
 /* format to disable USB on kernel command line is: nousb */
 __module_param_call("", nousb, param_set_bool, param_get_bool, &amp;nousb, 0444);
 
@@ -1203,8 +898,6 @@ EXPORT_SYMBOL(usb_hub_tt_clear_buffer);
 
 EXPORT_SYMBOL(usb_lock_device_for_reset);
 
-EXPORT_SYMBOL(usb_driver_claim_interface);
-EXPORT_SYMBOL(usb_driver_release_interface);
 EXPORT_SYMBOL(usb_find_interface);
 EXPORT_SYMBOL(usb_ifnum_to_if);
 EXPORT_SYMBOL(usb_altnum_to_altsetting);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 5a4eff5eec86..82d397a6f773 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -33,9 +33,9 @@ extern void usb_host_cleanup(void);
 extern int usb_port_suspend(struct usb_device *dev);
 extern int usb_port_resume(struct usb_device *dev);
 
+extern struct bus_type usb_bus_type;
 extern struct device_driver usb_generic_driver;
 extern int usb_generic_driver_data;
-extern int usb_device_match(struct device *dev, struct device_driver *drv);
 
 /* Interfaces and their "power state" are owned by usbcore */
 </pre><hr><pre>commit 140d8f687457c40a66af362838fac0d7893e7df5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:07:21 2006 -0400

    usbcore: rename usb_suspend_device to usb_port_suspend
    
    This revised patch (as715b) renames usb_suspend_device to
    usb_port_suspend, usb_resume_device to usb_port_resume, and
    finish_device_resume to finish_port_resume.  There was no objection to
    the original version of the patch so this should be okay to apply.
    
    The revision was needed only because I have re-arranged the order of the
    earlier patches.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 26c8cb5f3e67..b00514d9a605 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -1407,9 +1407,9 @@ int usb_new_device(struct usb_device *udev)
 		 * (Includes HNP test device.)
 		 */
 		if (udev-&gt;bus-&gt;b_hnp_enable || udev-&gt;bus-&gt;is_b_host) {
-			static int __usb_suspend_device(struct usb_device *,
+			static int __usb_port_suspend(struct usb_device *,
 						int port1);
-			err = __usb_suspend_device(udev, udev-&gt;bus-&gt;otg_port);
+			err = __usb_port_suspend(udev, udev-&gt;bus-&gt;otg_port);
 			if (err &lt; 0)
 				dev_dbg(&amp;udev-&gt;dev, "HNP fail, %d\n", err);
 		}
@@ -1684,7 +1684,7 @@ static int hub_port_suspend(struct usb_hub *hub, int port1,
  * the root hub for their bus goes into global suspend ... so we don't
  * (falsely) update the device power state to say it suspended.
  */
-static int __usb_suspend_device (struct usb_device *udev, int port1)
+static int __usb_port_suspend (struct usb_device *udev, int port1)
 {
 	int	status = 0;
 
@@ -1712,8 +1712,8 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 		}
 	}
 
-	/* we only change a device's upstream USB link.
-	 * root hubs have no upstream USB link.
+	/* we change the device's upstream USB link,
+	 * but root hubs have no upstream USB link.
 	 */
 	if (udev-&gt;parent)
 		status = hub_port_suspend(hdev_to_hub(udev-&gt;parent), port1,
@@ -1727,14 +1727,14 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
 #endif
 
 /*
- * usb_suspend_device - suspend a usb device
+ * usb_port_suspend - suspend a usb device's upstream port
  * @udev: device that's no longer in active use
  * Context: must be able to sleep; device not locked; pm locks held
  *
  * Suspends a USB device that isn't in active use, conserving power.
  * Devices may wake out of a suspend, if anything important happens,
  * using the remote wakeup mechanism.  They may also be taken out of
- * suspend by the host, using usb_resume_device().  It's also routine
+ * suspend by the host, using usb_port_resume().  It's also routine
  * to disconnect devices while they are suspended.
  *
  * This only affects the USB hardware for a device; its interfaces
@@ -1746,12 +1746,12 @@ static int __usb_suspend_device (struct usb_device *udev, int port1)
  *
  * Returns 0 on success, else negative errno.
  */
-int usb_suspend_device(struct usb_device *udev)
+int usb_port_suspend(struct usb_device *udev)
 {
 #ifdef	CONFIG_USB_SUSPEND
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
-	return __usb_suspend_device(udev, udev-&gt;portnum);
+	return __usb_port_suspend(udev, udev-&gt;portnum);
 #else
 	/* NOTE:  udev-&gt;state unchanged, it's not lying ... */
 	udev-&gt;dev.power.power_state = PMSG_SUSPEND;
@@ -1767,7 +1767,7 @@ int usb_suspend_device(struct usb_device *udev)
  * resume (by host) or remote wakeup (by device) ... now see what changed
  * in the tree that's rooted at this device.
  */
-static int finish_device_resume(struct usb_device *udev)
+static int finish_port_resume(struct usb_device *udev)
 {
 	int	status;
 	u16	devstatus;
@@ -1891,7 +1891,7 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 			/* TRSMRCY = 10 msec */
 			msleep(10);
 			if (udev)
-				status = finish_device_resume(udev);
+				status = finish_port_resume(udev);
 		}
 	}
 	if (status &lt; 0)
@@ -1903,7 +1903,7 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
 #endif
 
 /*
- * usb_resume_device - re-activate a suspended usb device
+ * usb_port_resume - re-activate a suspended usb device's upstream port
  * @udev: device to re-activate
  * Context: must be able to sleep; device not locked; pm locks held
  *
@@ -1915,14 +1915,16 @@ hub_port_resume(struct usb_hub *hub, int port1, struct usb_device *udev)
  *
  * Returns 0 on success, else negative errno.
  */
-int usb_resume_device(struct usb_device *udev)
+int usb_port_resume(struct usb_device *udev)
 {
 	int	status;
 
 	if (udev-&gt;state == USB_STATE_NOTATTACHED)
 		return -ENODEV;
 
-	/* selective resume of one downstream hub-to-device port */
+	/* we change the device's upstream USB link,
+	 * but root hubs have no upstream USB link.
+	 */
 	if (udev-&gt;parent) {
 #ifdef	CONFIG_USB_SUSPEND
 		if (udev-&gt;state == USB_STATE_SUSPENDED) {
@@ -1934,7 +1936,7 @@ int usb_resume_device(struct usb_device *udev)
 #endif
 			status = 0;
 	} else
-		status = finish_device_resume(udev);
+		status = finish_port_resume(udev);
 	if (status &lt; 0)
 		dev_dbg(&amp;udev-&gt;dev, "can't resume, status %d\n",
 			status);
@@ -1962,7 +1964,7 @@ static int remote_wakeup(struct usb_device *udev)
 		dev_dbg(&amp;udev-&gt;dev, "RESUME (wakeup)\n");
 		/* TRSMRCY = 10 msec */
 		msleep(10);
-		status = finish_device_resume(udev);
+		status = finish_port_resume(udev);
 	}
 	usb_unlock_device(udev);
 #endif
@@ -2069,7 +2071,7 @@ static int hub_resume(struct usb_interface *intf)
 		if (portstat &amp; USB_PORT_STAT_SUSPEND)
 			status = hub_port_resume(hub, port1, udev);
 		else {
-			status = finish_device_resume(udev);
+			status = finish_port_resume(udev);
 			if (status &lt; 0) {
 				dev_dbg(&amp;intf-&gt;dev, "resume port %d --&gt; %d\n",
 					port1, status);
@@ -3128,6 +3130,7 @@ int usb_reset_device(struct usb_device *udev)
 	hub_port_logical_disconnect(parent_hub, port1);
 	return -ENODEV;
 }
+EXPORT_SYMBOL(usb_reset_device);
 
 /**
  * usb_reset_composite_device - warn interface drivers and perform a USB port reset
@@ -3206,3 +3209,4 @@ int usb_reset_composite_device(struct usb_device *udev,
 
 	return ret;
 }
+EXPORT_SYMBOL(usb_reset_composite_device);
diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c
index ab766e0fe4ef..b28a31b20308 100644
--- a/drivers/usb/core/usb.c
+++ b/drivers/usb/core/usb.c
@@ -1014,7 +1014,7 @@ static int usb_generic_suspend(struct device *dev, pm_message_t message)
 		status = device_for_each_child(dev, NULL, verify_suspended);
 		if (status)
 			return status;
- 		return usb_suspend_device (to_usb_device(dev));
+ 		return usb_port_suspend(to_usb_device(dev));
 	}
 
 	if ((dev-&gt;driver == NULL) ||
@@ -1061,7 +1061,7 @@ static int usb_generic_resume(struct device *dev)
 		udev = to_usb_device(dev);
 		if (udev-&gt;state == USB_STATE_NOTATTACHED)
 			return 0;
-		return usb_resume_device (to_usb_device(dev));
+		return usb_port_resume(udev);
 	}
 
 	if ((dev-&gt;driver == NULL) ||
@@ -1209,9 +1209,6 @@ EXPORT_SYMBOL(usb_find_interface);
 EXPORT_SYMBOL(usb_ifnum_to_if);
 EXPORT_SYMBOL(usb_altnum_to_altsetting);
 
-EXPORT_SYMBOL(usb_reset_device);
-EXPORT_SYMBOL(usb_reset_composite_device);
-
 EXPORT_SYMBOL(__usb_get_extra_descriptor);
 
 EXPORT_SYMBOL(usb_find_device);
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 1217fbbe5829..5a4eff5eec86 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -30,8 +30,8 @@ extern void usb_major_cleanup(void);
 extern int usb_host_init(void);
 extern void usb_host_cleanup(void);
 
-extern int usb_suspend_device(struct usb_device *dev);
-extern int usb_resume_device(struct usb_device *dev);
+extern int usb_port_suspend(struct usb_device *dev);
+extern int usb_port_resume(struct usb_device *dev);
 
 extern struct device_driver usb_generic_driver;
 extern int usb_generic_driver_data;</pre><hr><pre>commit 121e287cb554f3d3402c85a1950d852691b08f5c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:06:36 2006 -0400

    usb-skeleton: don't submit URBs after disconnection
    
    This patch (as712b) is a slight revision of one submitted earlier.  It
    fixes the usb-skeleton example driver so that it won't try to submit
    URBs after skel_disconnect() has returned.  This could cause errors, if
    the driver was unbound and then a different driver was bound to the
    device.  It also fixes a couple of small bugs in the skel_write()
    routine.
    
    The revised patch uses a slightly different test, suggested by Dave
    Brownell, for determining whether to free a transfer buffer.  It's a
    little clearer than the earlier version.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/usb-skeleton.c b/drivers/usb/usb-skeleton.c
index b362039792b3..33f0e81c58d3 100644
--- a/drivers/usb/usb-skeleton.c
+++ b/drivers/usb/usb-skeleton.c
@@ -1,5 +1,5 @@
 /*
- * USB Skeleton driver - 2.0
+ * USB Skeleton driver - 2.1
  *
  * Copyright (C) 2001-2004 Greg Kroah-Hartman (greg@kroah.com)
  *
@@ -8,8 +8,7 @@
  *	published by the Free Software Foundation, version 2.
  *
  * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c 
- * but has been rewritten to be easy to read and use, as no locks are now
- * needed anymore.
+ * but has been rewritten to be easier to read and use.
  *
  */
 
@@ -21,6 +20,7 @@
 #include &lt;linux/kref.h&gt;
 #include &lt;asm/uaccess.h&gt;
 #include &lt;linux/usb.h&gt;
+#include &lt;linux/mutex.h&gt;
 
 
 /* Define these values to match your devices */
@@ -52,6 +52,7 @@ struct usb_skel {
 	__u8			bulk_in_endpointAddr;	/* the address of the bulk in endpoint */
 	__u8			bulk_out_endpointAddr;	/* the address of the bulk out endpoint */
 	struct kref		kref;
+	struct mutex		io_mutex;		/* synchronize I/O with disconnect */
 };
 #define to_skel_dev(d) container_of(d, struct usb_skel, kref)
 
@@ -119,7 +120,13 @@ static ssize_t skel_read(struct file *file, char *buffer, size_t count, loff_t *
 	int bytes_read;
 
 	dev = (struct usb_skel *)file-&gt;private_data;
-	
+
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	if (!dev-&gt;interface) {		/* disconnect() was called */
+		retval = -ENODEV;
+		goto exit;
+	}
+
 	/* do a blocking bulk read to get data from the device */
 	retval = usb_bulk_msg(dev-&gt;udev,
 			      usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;bulk_in_endpointAddr),
@@ -135,6 +142,8 @@ static ssize_t skel_read(struct file *file, char *buffer, size_t count, loff_t *
 			retval = bytes_read;
 	}
 
+exit:
+	mutex_unlock(&amp;dev-&gt;io_mutex);
 	return retval;
 }
 
@@ -179,6 +188,12 @@ static ssize_t skel_write(struct file *file, const char *user_buffer, size_t cou
 		goto exit;
 	}
 
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	if (!dev-&gt;interface) {		/* disconnect() was called */
+		retval = -ENODEV;
+		goto error;
+	}
+
 	/* create a urb, and a buffer for it, and copy the data to the urb */
 	urb = usb_alloc_urb(0, GFP_KERNEL);
 	if (!urb) {
@@ -213,13 +228,18 @@ static ssize_t skel_write(struct file *file, const char *user_buffer, size_t cou
 	/* release our reference to this urb, the USB core will eventually free it entirely */
 	usb_free_urb(urb);
 
-exit:
+	mutex_unlock(&amp;dev-&gt;io_mutex);
 	return writesize;
 
 error:
-	usb_buffer_free(dev-&gt;udev, writesize, buf, urb-&gt;transfer_dma);
-	usb_free_urb(urb);
+	if (urb) {
+		usb_buffer_free(dev-&gt;udev, writesize, buf, urb-&gt;transfer_dma);
+		usb_free_urb(urb);
+	}
+	mutex_unlock(&amp;dev-&gt;io_mutex);
 	up(&amp;dev-&gt;limit_sem);
+
+exit:
 	return retval;
 }
 
@@ -258,6 +278,7 @@ static int skel_probe(struct usb_interface *interface, const struct usb_device_i
 	}
 	kref_init(&amp;dev-&gt;kref);
 	sema_init(&amp;dev-&gt;limit_sem, WRITES_IN_FLIGHT);
+	mutex_init(&amp;dev-&gt;io_mutex);
 
 	dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));
 	dev-&gt;interface = interface;
@@ -334,6 +355,11 @@ static void skel_disconnect(struct usb_interface *interface)
 	/* give back our minor */
 	usb_deregister_dev(interface, &amp;skel_class);
 
+	/* prevent more I/O from starting */
+	mutex_lock(&amp;dev-&gt;io_mutex);
+	dev-&gt;interface = NULL;
+	mutex_unlock(&amp;dev-&gt;io_mutex);
+
 	unlock_kernel();
 
 	/* decrement our usage count */</pre><hr><pre>commit 349710c3a79c0405911b8b604953f0c665e17756
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:05:56 2006 -0400

    usbfs: detect device unregistration
    
    This patch (as711b) is a revised version of an earlier submission.  It
    modifies the usbfs code to detect when a device has been unregistered from
    usbfs, even if the device is still connected.  Although this can't happen
    now, it will be able to happen after the upcoming changes to usb_generic.
    
    Nobody objected to this patch when it was submitted before, so it should
    be okay to apply this version.  The revision is merely to take into
    account the changes introduced by as723, which touches the same driver.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index d8b0476237f3..e84f19d4089c 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -90,9 +90,10 @@ MODULE_PARM_DESC (usbfs_snoop, "true to log all usbfs traffic");
 
 #define	MAX_USBFS_BUFFER_SIZE	16384
 
-static inline int connected (struct usb_device *dev)
+static inline int connected (struct dev_state *ps)
 {
-	return dev-&gt;state != USB_STATE_NOTATTACHED;
+	return (!list_empty(&amp;ps-&gt;list) &amp;&amp;
+			ps-&gt;dev-&gt;state != USB_STATE_NOTATTACHED);
 }
 
 static loff_t usbdev_lseek(struct file *file, loff_t offset, int orig)
@@ -130,7 +131,7 @@ static ssize_t usbdev_read(struct file *file, char __user *buf, size_t nbytes, l
 
 	pos = *ppos;
 	usb_lock_device(dev);
-	if (!connected(dev)) {
+	if (!connected(ps)) {
 		ret = -ENODEV;
 		goto err;
 	} else if (pos &lt; 0) {
@@ -1326,7 +1327,7 @@ static int proc_ioctl(struct dev_state *ps, struct usbdevfs_ioctl *ctl)
 		}
 	}
 
-	if (!connected(ps-&gt;dev)) {
+	if (!connected(ps)) {
 		kfree(buf);
 		return -ENODEV;
 	}
@@ -1425,7 +1426,7 @@ static int usbdev_ioctl(struct inode *inode, struct file *file, unsigned int cmd
 	if (!(file-&gt;f_mode &amp; FMODE_WRITE))
 		return -EPERM;
 	usb_lock_device(dev);
-	if (!connected(dev)) {
+	if (!connected(ps)) {
 		usb_unlock_device(dev);
 		return -ENODEV;
 	}
@@ -1566,7 +1567,7 @@ static unsigned int usbdev_poll(struct file *file, struct poll_table_struct *wai
 	poll_wait(file, &amp;ps-&gt;wait, wait);
 	if (file-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !list_empty(&amp;ps-&gt;async_completed))
 		mask |= POLLOUT | POLLWRNORM;
-	if (!connected(ps-&gt;dev))
+	if (!connected(ps))
 		mask |= POLLERR | POLLHUP;
 	return mask;
 }</pre><hr><pre>commit 4a2a8a2cce86b9d001378cc25acb5c61e6ca7d63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Jul 1 22:05:01 2006 -0400

    usbfs: private mutex for open, release, and remove
    
    The usbfs code doesn't provide sufficient mutual exclusion among open,
    release, and remove.  Release vs. remove is okay because they both
    acquire the device lock, but open is not exclusive with either one.  All
    three routines modify the udev-&gt;filelist linked list, so they must not
    run concurrently.
    
    Apparently someone gave this a minimum amount of thought in the past by
    explicitly acquiring the BKL at the start of the usbdev_open routine.
    Oddly enough, there's a comment pointing out that locking is unnecessary
    because chrdev_open already has acquired the BKL.
    
    But this ignores the point that the files in /proc/bus/usb/* are not
    char device files; they are regular files and so they don't get any
    special locking.  Furthermore it's necessary to acquire the same lock in
    the release and remove routines, which the code does not do.
    
    Yet another problem arises because the same file_operations structure is
    accessible through both the /proc/bus/usb/* and /dev/usb/usbdev* file
    nodes.  Even when one of them has been removed, it's still possible for
    userspace to open the other.  So simple locking around the individual
    remove routines is insufficient; we need to lock the entire
    usb_notify_remove_device notifier chain.
    
    Rather than rely on the BKL, this patch (as723) introduces a new private
    mutex for the purpose.  Holding the BKL while invoking a notifier chain
    doesn't seem like a good idea.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c
index 32e03000420c..d8b0476237f3 100644
--- a/drivers/usb/core/devio.c
+++ b/drivers/usb/core/devio.c
@@ -59,6 +59,9 @@
 #define USB_DEVICE_MAX			USB_MAXBUS * 128
 static struct class *usb_device_class;
 
+/* Mutual exclusion for removal, open, and release */
+DEFINE_MUTEX(usbfs_mutex);
+
 struct async {
 	struct list_head asynclist;
 	struct dev_state *ps;
@@ -541,15 +544,13 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	struct dev_state *ps;
 	int ret;
 
-	/* 
-	 * no locking necessary here, as chrdev_open has the kernel lock
-	 * (still acquire the kernel lock for safety)
-	 */
+	/* Protect against simultaneous removal or release */
+	mutex_lock(&amp;usbfs_mutex);
+
 	ret = -ENOMEM;
 	if (!(ps = kmalloc(sizeof(struct dev_state), GFP_KERNEL)))
-		goto out_nolock;
+		goto out;
 
-	lock_kernel();
 	ret = -ENOENT;
 	/* check if we are called from a real node or usbfs */
 	if (imajor(inode) == USB_DEVICE_MAJOR)
@@ -579,9 +580,8 @@ static int usbdev_open(struct inode *inode, struct file *file)
 	list_add_tail(&amp;ps-&gt;list, &amp;dev-&gt;filelist);
 	file-&gt;private_data = ps;
  out:
-	unlock_kernel();
- out_nolock:
-        return ret;
+	mutex_unlock(&amp;usbfs_mutex);
+	return ret;
 }
 
 static int usbdev_release(struct inode *inode, struct file *file)
@@ -591,7 +591,12 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	unsigned int ifnum;
 
 	usb_lock_device(dev);
+
+	/* Protect against simultaneous open */
+	mutex_lock(&amp;usbfs_mutex);
 	list_del_init(&amp;ps-&gt;list);
+	mutex_unlock(&amp;usbfs_mutex);
+
 	for (ifnum = 0; ps-&gt;ifclaimed &amp;&amp; ifnum &lt; 8*sizeof(ps-&gt;ifclaimed);
 			ifnum++) {
 		if (test_bit(ifnum, &amp;ps-&gt;ifclaimed))
@@ -600,9 +605,8 @@ static int usbdev_release(struct inode *inode, struct file *file)
 	destroy_all_async(ps);
 	usb_unlock_device(dev);
 	usb_put_dev(dev);
-	ps-&gt;dev = NULL;
 	kfree(ps);
-        return 0;
+	return 0;
 }
 
 static int proc_control(struct dev_state *ps, void __user *arg)
diff --git a/drivers/usb/core/notify.c b/drivers/usb/core/notify.c
index b042676af0a5..6b36897ca151 100644
--- a/drivers/usb/core/notify.c
+++ b/drivers/usb/core/notify.c
@@ -50,8 +50,11 @@ void usb_notify_add_device(struct usb_device *udev)
 
 void usb_notify_remove_device(struct usb_device *udev)
 {
+	/* Protect against simultaneous usbfs open */
+	mutex_lock(&amp;usbfs_mutex);
 	blocking_notifier_call_chain(&amp;usb_notifier_list,
 			USB_DEVICE_REMOVE, udev);
+	mutex_unlock(&amp;usbfs_mutex);
 }
 
 void usb_notify_add_bus(struct usb_bus *ubus)
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 49f69236b420..1217fbbe5829 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -59,6 +59,7 @@ static inline int is_active(struct usb_interface *f)
 extern const char *usbcore_name;
 
 /* usbfs stuff */
+extern struct mutex usbfs_mutex;
 extern struct usb_driver usbfs_driver;
 extern struct file_operations usbfs_devices_fops;
 extern struct file_operations usbfs_device_file_operations;</pre><hr><pre>commit b6eb2d84d2bb01e9fcc46a032a3429b4747b1c47
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Jul 6 15:37:42 2006 -0400

    usbcore: add configuration_string to attribute group
    
    This patch (as737b) does a very small cleanup of core/sysfs.c by adding
    the configuration_string attribute file to the existing attribute group
    instead of treating it separately.  It doesn't need this separate
    treatment because unlike the other device string attributes, it changes
    along with the active configuration.
    
    The patch also fixes a simple typo (which, oddly enough, doesn't seem to
    bother the compiler).
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/core/sysfs.c b/drivers/usb/core/sysfs.c
index dec973affb0f..cd2286246f6a 100644
--- a/drivers/usb/core/sysfs.c
+++ b/drivers/usb/core/sysfs.c
@@ -60,7 +60,7 @@ static ssize_t
 set_bConfigurationValue (struct device *dev, struct device_attribute *attr,
 		const char *buf, size_t count)
 {
-	struct usb_device	*udev = udev = to_usb_device (dev);
+	struct usb_device	*udev = to_usb_device (dev);
 	int			config, value;
 
 	if (sscanf (buf, "%u", &amp;config) != 1 || config &gt; 255)
@@ -186,6 +186,7 @@ usb_descriptor_attr (bMaxPacketSize0, "%d\n")
 
 static struct attribute *dev_attrs[] = {
 	/* current configuration's attributes */
+	&amp;dev_attr_configuration.attr,
 	&amp;dev_attr_bNumInterfaces.attr,
 	&amp;dev_attr_bConfigurationValue.attr,
 	&amp;dev_attr_bmAttributes.attr,
@@ -221,7 +222,6 @@ void usb_create_sysfs_dev_files (struct usb_device *udev)
 		device_create_file (dev, &amp;dev_attr_product);
 	if (udev-&gt;serial)
 		device_create_file (dev, &amp;dev_attr_serial);
-	device_create_file (dev, &amp;dev_attr_configuration);
 	usb_create_ep_files(dev, &amp;udev-&gt;ep0, udev);
 }
 
@@ -238,7 +238,6 @@ void usb_remove_sysfs_dev_files (struct usb_device *udev)
 		device_remove_file(dev, &amp;dev_attr_product);
 	if (udev-&gt;serial)
 		device_remove_file(dev, &amp;dev_attr_serial);
-	device_remove_file (dev, &amp;dev_attr_configuration);
 }
 
 /* Interface fields */</pre><hr><pre>commit b97b196c9d351a501ed89fc836e4e2fe71ff93c9
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Thu Sep 14 15:18:54 2006 -0400

    USB: unusual_devs entry for Lacie DVD+-RW
    
    This patch (as781) adds an entry to unusual_devs.h for the Lacie DVD+-RW
    drive.  Apparently its USB interface has requirements similar to the
    Genesys Logic interface; it doesn't like data to be sent too soon after
    a command.
    
    This fixes Bugzilla #6817.
    
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Phil Dibowitz &lt;phil@ipom.com&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h
index b130e170b4a8..4b06ac34430f 100644
--- a/drivers/usb/storage/unusual_devs.h
+++ b/drivers/usb/storage/unusual_devs.h
@@ -631,6 +631,13 @@ UNUSUAL_DEV(  0x0595, 0x4343, 0x0000, 0x2210,
 		"Digital Camera EX-20 DSC",
 		US_SC_8070, US_PR_DEVICE, NULL, 0 ),
 
+/* Reported by &lt;Hendryk.Pfeiffer@gmx.de&gt; */
+UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,
+		"LaCie",
+		"DVD+-RW",
+		US_SC_DEVICE, US_PR_DEVICE, NULL,
+		US_FL_GO_SLOW ),
+
 /* Submitted by Joel Bourquard &lt;numlock@freesurf.ch&gt;
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don't.</pre><hr><pre>commit 7e9f4b2d3e21e87c26025810413ef1592834e63b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 18 16:28:06 2006 -0400

    Driver core: Don't call put methods while holding a spinlock
    
    The klist utility routines currently call _put methods while holding a
    spinlock.  This is of course illegal; a put routine could try to
    unregister a device and hence need to sleep.
    
    No problems have arisen until now because in many cases klist removals
    were done synchronously, so the _put methods were never actually used.
    In other cases we may simply have been lucky.
    
    This patch (as784) reworks the klist routines so that _put methods are
    called only _after_ the klist's spinlock has been released.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/lib/klist.c b/lib/klist.c
index 9c94f0b163a1..120bd175aa78 100644
--- a/lib/klist.c
+++ b/lib/klist.c
@@ -123,12 +123,10 @@ EXPORT_SYMBOL_GPL(klist_add_tail);
 static void klist_release(struct kref * kref)
 {
 	struct klist_node * n = container_of(kref, struct klist_node, n_ref);
-	void (*put)(struct klist_node *) = n-&gt;n_klist-&gt;put;
+
 	list_del(&amp;n-&gt;n_node);
 	complete(&amp;n-&gt;n_removed);
 	n-&gt;n_klist = NULL;
-	if (put)
-		put(n);
 }
 
 static int klist_dec_and_del(struct klist_node * n)
@@ -145,10 +143,14 @@ static int klist_dec_and_del(struct klist_node * n)
 void klist_del(struct klist_node * n)
 {
 	struct klist * k = n-&gt;n_klist;
+	void (*put)(struct klist_node *) = k-&gt;put;
 
 	spin_lock(&amp;k-&gt;k_lock);
-	klist_dec_and_del(n);
+	if (!klist_dec_and_del(n))
+		put = NULL;
 	spin_unlock(&amp;k-&gt;k_lock);
+	if (put)
+		put(n);
 }
 
 EXPORT_SYMBOL_GPL(klist_del);
@@ -161,10 +163,7 @@ EXPORT_SYMBOL_GPL(klist_del);
 
 void klist_remove(struct klist_node * n)
 {
-	struct klist * k = n-&gt;n_klist;
-	spin_lock(&amp;k-&gt;k_lock);
-	klist_dec_and_del(n);
-	spin_unlock(&amp;k-&gt;k_lock);
+	klist_del(n);
 	wait_for_completion(&amp;n-&gt;n_removed);
 }
 
@@ -260,12 +259,15 @@ static struct klist_node * to_klist_node(struct list_head * n)
 struct klist_node * klist_next(struct klist_iter * i)
 {
 	struct list_head * next;
+	struct klist_node * lnode = i-&gt;i_cur;
 	struct klist_node * knode = NULL;
+	void (*put)(struct klist_node *) = i-&gt;i_klist-&gt;put;
 
 	spin_lock(&amp;i-&gt;i_klist-&gt;k_lock);
-	if (i-&gt;i_cur) {
-		next = i-&gt;i_cur-&gt;n_node.next;
-		klist_dec_and_del(i-&gt;i_cur);
+	if (lnode) {
+		next = lnode-&gt;n_node.next;
+		if (!klist_dec_and_del(lnode))
+			put = NULL;
 	} else
 		next = i-&gt;i_head-&gt;next;
 
@@ -275,6 +277,8 @@ struct klist_node * klist_next(struct klist_iter * i)
 	}
 	i-&gt;i_cur = knode;
 	spin_unlock(&amp;i-&gt;i_klist-&gt;k_lock);
+	if (put &amp;&amp; lnode)
+		put(lnode);
 	return knode;
 }
 </pre><hr><pre>commit 81107bf531d2524afbcd61f3b4ad57a71295d591
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 18 16:24:28 2006 -0400

    Driver core: Remove unneeded routines from driver core
    
    This patch (as783) simplifies the driver core slightly by removing four
    unnecessary _get and _put methods.
    
    It is vital that when a driver is removed from its bus's klist of
    registered drivers, or when a device is removed from a driver's klist
    of bound devices, that the klist updates complete synchronously.
    Otherwise the kernel might try binding an unregistered driver to a
    newly-registered device, or adding a device to the klist for a new
    driver before it has been removed from the old driver's klist.
    
    Since the removals must be synchronous, they don't need to update any
    reference counts.  Hence the _get and _put methods can be dispensed
    with.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@suse.de&gt;

diff --git a/drivers/base/bus.c b/drivers/base/bus.c
index 636af538a2b5..12173d16bea7 100644
--- a/drivers/base/bus.c
+++ b/drivers/base/bus.c
@@ -696,22 +696,6 @@ static void klist_devices_put(struct klist_node *n)
 	put_device(dev);
 }
 
-static void klist_drivers_get(struct klist_node *n)
-{
-	struct device_driver *drv = container_of(n, struct device_driver,
-						 knode_bus);
-
-	get_driver(drv);
-}
-
-static void klist_drivers_put(struct klist_node *n)
-{
-	struct device_driver *drv = container_of(n, struct device_driver,
-						 knode_bus);
-
-	put_driver(drv);
-}
-
 /**
  *	bus_register - register a bus with the system.
  *	@bus:	bus.
@@ -747,7 +731,7 @@ int bus_register(struct bus_type * bus)
 		goto bus_drivers_fail;
 
 	klist_init(&amp;bus-&gt;klist_devices, klist_devices_get, klist_devices_put);
-	klist_init(&amp;bus-&gt;klist_drivers, klist_drivers_get, klist_drivers_put);
+	klist_init(&amp;bus-&gt;klist_drivers, NULL, NULL);
 	bus_add_attrs(bus);
 
 	pr_debug("bus type '%s' registered\n", bus-&gt;name);
diff --git a/drivers/base/driver.c b/drivers/base/driver.c
index 562600dd540a..1214cbd17d86 100644
--- a/drivers/base/driver.c
+++ b/drivers/base/driver.c
@@ -142,20 +142,6 @@ void put_driver(struct device_driver * drv)
 	kobject_put(&amp;drv-&gt;kobj);
 }
 
-static void klist_devices_get(struct klist_node *n)
-{
-	struct device *dev = container_of(n, struct device, knode_driver);
-
-	get_device(dev);
-}
-
-static void klist_devices_put(struct klist_node *n)
-{
-	struct device *dev = container_of(n, struct device, knode_driver);
-
-	put_device(dev);
-}
-
 /**
  *	driver_register - register driver with bus
  *	@drv:	driver to register
@@ -175,7 +161,7 @@ int driver_register(struct device_driver * drv)
 	    (drv-&gt;bus-&gt;shutdown &amp;&amp; drv-&gt;shutdown)) {
 		printk(KERN_WARNING "Driver '%s' needs updating - please use bus_type methods\n", drv-&gt;name);
 	}
-	klist_init(&amp;drv-&gt;klist_devices, klist_devices_get, klist_devices_put);
+	klist_init(&amp;drv-&gt;klist_devices, NULL, NULL);
 	init_completion(&amp;drv-&gt;unloaded);
 	return bus_add_driver(drv);
 }</pre>
    <div class="pagination">
        <a href='2_121.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><a href='2_9.html'>9</a><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><span>[122]</span><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_123.html'>Next&gt;&gt;</a>
    <div>
</body>
