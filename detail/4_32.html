<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_31.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><span>[32]</span><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_33.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 7c11337d9d81cde0a08a0da63cbfb20653890fa1
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jun 4 18:50:06 2008 -0400

    nfsd: remove three unused NFS4_ACE_* defines
    
    These flag bits aren't used by either the protocol or our
    implementation, so I don't know why they were here.
    
    Thanks to Johann Dahm for running across these.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: Johann Dahm &lt;jdahm@umich.edu&gt;

diff --git a/include/linux/nfs4.h b/include/linux/nfs4.h
index 8726491de154..ea0366769484 100644
--- a/include/linux/nfs4.h
+++ b/include/linux/nfs4.h
@@ -65,9 +65,6 @@
 #define NFS4_ACE_SUCCESSFUL_ACCESS_ACE_FLAG   0x00000010
 #define NFS4_ACE_FAILED_ACCESS_ACE_FLAG       0x00000020
 #define NFS4_ACE_IDENTIFIER_GROUP             0x00000040
-#define NFS4_ACE_OWNER                        0x00000080
-#define NFS4_ACE_GROUP                        0x00000100
-#define NFS4_ACE_EVERYONE                     0x00000200
 
 #define NFS4_ACE_READ_DATA                    0x00000001
 #define NFS4_ACE_LIST_DIRECTORY               0x00000001</pre><hr><pre>commit 3b12cd9862d5f560031d90bda78952ab55e36b24
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon May 5 17:17:44 2008 -0400

    nfsd: add dprintk of compound return
    
    We already print each operation of the compound when debugging is turned
    on; printing the result could also help with remote debugging.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index c309c881bd4e..313484380a9b 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -952,6 +952,7 @@ nfsd4_proc_compound(struct svc_rqst *rqstp,
 out:
 	nfsd4_release_compoundargs(args);
 	cstate_free(cstate);
+	dprintk("nfsv4 compound returned %d\n", ntohl(status));
 	return status;
 }
 </pre><hr><pre>commit 68432a03f8ff93a9eecee95cc8f02e7fe2025cc9
Merge: d71a4dd72e67 a6f911c04e20
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Tue May 20 19:57:38 2008 -0400

    Merge branch 'from-tomtucker' into for-2.6.26
</pre><hr><pre>commit d71a4dd72e67210ae0767ccae69c79f1c933ff64
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Fri May 9 12:01:19 2008 -0700

    svcrpc: fix proc/net/rpc/auth.unix.ip/content display
    
    Commit f15364bd4cf8799a7677b6daeed7b67d9139d974 ("IPv6 support for NFS
    server export caches") dropped a couple spaces, rendering the output
    here difficult to read.
    
    (However note that we expect the output to be parsed only by humans, not
    machines, so this shouldn't have broken any userland software.)
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/net/sunrpc/svcauth_unix.c b/net/sunrpc/svcauth_unix.c
index 3f30ee6006ae..f24800f2c098 100644
--- a/net/sunrpc/svcauth_unix.c
+++ b/net/sunrpc/svcauth_unix.c
@@ -278,7 +278,7 @@ static int ip_map_show(struct seq_file *m,
 		dom = im-&gt;m_client-&gt;h.name;
 
 	if (ipv6_addr_v4mapped(&amp;addr)) {
-		seq_printf(m, "%s" NIPQUAD_FMT "%s\n",
+		seq_printf(m, "%s " NIPQUAD_FMT " %s\n",
 			im-&gt;m_class,
 			ntohl(addr.s6_addr32[3]) &gt;&gt; 24 &amp; 0xff,
 			ntohl(addr.s6_addr32[3]) &gt;&gt; 16 &amp; 0xff,
@@ -286,7 +286,7 @@ static int ip_map_show(struct seq_file *m,
 			ntohl(addr.s6_addr32[3]) &gt;&gt;  0 &amp; 0xff,
 			dom);
 	} else {
-		seq_printf(m, "%s" NIP6_FMT "%s\n",
+		seq_printf(m, "%s " NIP6_FMT " %s\n",
 			im-&gt;m_class, NIP6(addr), dom);
 	}
 	return 0;</pre><hr><pre>commit 88dd0be3874566796fa4ffbdf927a53c4a6a2f4b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon May 5 19:47:29 2008 -0400

    nfsd: reorder printk in do_probe_callback to avoid use-after-free
    
    We're currently dereferencing the client after we drop our reference
    count to it.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4callback.c b/fs/nfsd/nfs4callback.c
index 0b3ffa9840c2..4d4760e687c3 100644
--- a/fs/nfsd/nfs4callback.c
+++ b/fs/nfsd/nfs4callback.c
@@ -419,9 +419,9 @@ static int do_probe_callback(void *data)
 out_release_client:
 	rpc_shutdown_client(client);
 out_err:
-	put_nfs4_client(clp);
 	dprintk("NFSD: warning: no callback path to client %.*s\n",
 		(int)clp-&gt;cl_name.len, clp-&gt;cl_name.data);
+	put_nfs4_client(clp);
 	return status;
 }
 </pre><hr><pre>commit b55e0ba19cd2d83317a7f1dbb626080951442ab3
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Mon Apr 28 18:22:50 2008 -0400

    nfsd: remove unnecessary atomic ops
    
    These bit operations don't need to be atomic.  They're all done under a
    single big mutex anyway.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 8799b8708188..5c97d47676ae 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1579,8 +1579,8 @@ nfs4_upgrade_open(struct svc_rqst *rqstp, struct svc_fh *cur_fh, struct nfs4_sta
 	}
 	/* remember the open */
 	filp-&gt;f_mode |= open-&gt;op_share_access;
-	set_bit(open-&gt;op_share_access, &amp;stp-&gt;st_access_bmap);
-	set_bit(open-&gt;op_share_deny, &amp;stp-&gt;st_deny_bmap);
+	__set_bit(open-&gt;op_share_access, &amp;stp-&gt;st_access_bmap);
+	__set_bit(open-&gt;op_share_deny, &amp;stp-&gt;st_deny_bmap);
 
 	return nfs_ok;
 }</pre><hr><pre>commit 38def50fabc479dc96ea6bd2cb2526e0dfc36fa4
Author: Fred Isaman &lt;iisaman@citi.umich.edu&gt;
Date:   Thu May 1 20:03:22 2008 +0300

    nfs: fix race in nfs_dirty_request
    
    When called from nfs_flush_incompatible, the req is not locked, so
    req-&gt;wb_page might be set to NULL before it is used by PageWriteback.
    
    Signed-off-by: Fred Isaman &lt;iisaman@citi.umich.edu&gt;
    Signed-off-by: Benny Halevy &lt;bhalevy@panasas.com&gt;
    Signed-off-by: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/nfs/write.c b/fs/nfs/write.c
index 1ade11d1ba07..6d8ace3e3259 100644
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -415,7 +415,7 @@ nfs_dirty_request(struct nfs_page *req)
 
 	if (page == NULL || test_bit(PG_NEED_COMMIT, &amp;req-&gt;wb_flags))
 		return 0;
-	return !PageWriteback(req-&gt;wb_page);
+	return !PageWriteback(page);
 }
 
 #if defined(CONFIG_NFS_V3) || defined(CONFIG_NFS_V4)</pre><hr><pre>commit dceba9944181b1fd5993417b5c8fa0e3dda38f8d
Author: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
Date:   Tue Apr 29 01:01:22 2008 -0700

    keys: check starting keyring as part of search
    
    Check the starting keyring as part of the search to (a) see if that is what
    we're searching for, and (b) to check it is still valid for searching.
    
    The scenario: User in process A does things that cause things to be created in
    its process session keyring.  The user then does an su to another user and
    starts a new process, B.  The two processes now share the same process session
    keyring.
    
    Process B does an NFS access which results in an upcall to gssd.  When gssd
    attempts to instantiate the context key (to be linked into the process session
    keyring), it is denied access even though it has an authorization key.
    
    The order of calls is:
    
       keyctl_instantiate_key()
          lookup_user_key()                             (the default: case)
             search_process_keyrings(current)
                search_process_keyrings(rka-&gt;context)   (recursive call)
                   keyring_search_aux()
    
    keyring_search_aux() verifies the keys and keyrings underneath the top-level
    keyring it is given, but that top-level keyring is neither fully validated nor
    checked to see if it is the thing being searched for.
    
    This patch changes keyring_search_aux() to:
    1) do more validation on the top keyring it is given and
    2) check whether that top-level keyring is the thing being searched for
    
    Signed-off-by: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
    Signed-off-by: David Howells &lt;dhowells@redhat.com&gt;
    Cc: Paul Moore &lt;paul.moore@hp.com&gt;
    Cc: Chris Wright &lt;chrisw@sous-sol.org&gt;
    Cc: Stephen Smalley &lt;sds@tycho.nsa.gov&gt;
    Cc: James Morris &lt;jmorris@namei.org&gt;
    Cc: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
    Cc: Trond Myklebust &lt;trond.myklebust@fys.uio.no&gt;
    Cc: "J. Bruce Fields" &lt;bfields@fieldses.org&gt;
    Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/security/keys/keyring.c b/security/keys/keyring.c
index 88292e3dee96..70f0c313c888 100644
--- a/security/keys/keyring.c
+++ b/security/keys/keyring.c
@@ -292,7 +292,7 @@ key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 
 	struct keyring_list *keylist;
 	struct timespec now;
-	unsigned long possessed;
+	unsigned long possessed, kflags;
 	struct key *keyring, *key;
 	key_ref_t key_ref;
 	long err;
@@ -319,6 +319,32 @@ key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 	err = -EAGAIN;
 	sp = 0;
 
+	/* firstly we should check to see if this top-level keyring is what we
+	 * are looking for */
+	key_ref = ERR_PTR(-EAGAIN);
+	kflags = keyring-&gt;flags;
+	if (keyring-&gt;type == type &amp;&amp; match(keyring, description)) {
+		key = keyring;
+
+		/* check it isn't negative and hasn't expired or been
+		 * revoked */
+		if (kflags &amp; (1 &lt;&lt; KEY_FLAG_REVOKED))
+			goto error_2;
+		if (key-&gt;expiry &amp;&amp; now.tv_sec &gt;= key-&gt;expiry)
+			goto error_2;
+		key_ref = ERR_PTR(-ENOKEY);
+		if (kflags &amp; (1 &lt;&lt; KEY_FLAG_NEGATIVE))
+			goto error_2;
+		goto found;
+	}
+
+	/* otherwise, the top keyring must not be revoked, expired, or
+	 * negatively instantiated if we are to search it */
+	key_ref = ERR_PTR(-EAGAIN);
+	if (kflags &amp; ((1 &lt;&lt; KEY_FLAG_REVOKED) | (1 &lt;&lt; KEY_FLAG_NEGATIVE)) ||
+	    (keyring-&gt;expiry &amp;&amp; now.tv_sec &gt;= keyring-&gt;expiry))
+		goto error_2;
+
 	/* start processing a new keyring */
 descend:
 	if (test_bit(KEY_FLAG_REVOKED, &amp;keyring-&gt;flags))
@@ -331,13 +357,14 @@ key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 	/* iterate through the keys in this keyring first */
 	for (kix = 0; kix &lt; keylist-&gt;nkeys; kix++) {
 		key = keylist-&gt;keys[kix];
+		kflags = key-&gt;flags;
 
 		/* ignore keys not of this type */
 		if (key-&gt;type != type)
 			continue;
 
 		/* skip revoked keys and expired keys */
-		if (test_bit(KEY_FLAG_REVOKED, &amp;key-&gt;flags))
+		if (kflags &amp; (1 &lt;&lt; KEY_FLAG_REVOKED))
 			continue;
 
 		if (key-&gt;expiry &amp;&amp; now.tv_sec &gt;= key-&gt;expiry)
@@ -352,8 +379,8 @@ key_ref_t keyring_search_aux(key_ref_t keyring_ref,
 					context, KEY_SEARCH) &lt; 0)
 			continue;
 
-		/* we set a different error code if we find a negative key */
-		if (test_bit(KEY_FLAG_NEGATIVE, &amp;key-&gt;flags)) {
+		/* we set a different error code if we pass a negative key */
+		if (kflags &amp; (1 &lt;&lt; KEY_FLAG_NEGATIVE)) {
 			err = -ENOKEY;
 			continue;
 		}</pre><hr><pre>commit e36cd4a2873c398ba188f16e4087cce7f00a1506
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Apr 24 16:59:30 2008 -0400

    nfsd: don't allow setting ctime over v4
    
    Presumably this is left over from earlier drafts of v4, which listed
    TIME_METADATA as writeable.  It's read-only in rfc 3530, and shouldn't
    be modifiable anyway.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;

diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c
index 1ba7ad981935..c513bbdf2d36 100644
--- a/fs/nfsd/nfs4xdr.c
+++ b/fs/nfsd/nfs4xdr.c
@@ -376,20 +376,6 @@ nfsd4_decode_fattr(struct nfsd4_compoundargs *argp, u32 *bmval, struct iattr *ia
 			goto xdr_error;
 		}
 	}
-	if (bmval[1] &amp; FATTR4_WORD1_TIME_METADATA) {
-		/* We require the high 32 bits of 'seconds' to be 0, and we ignore
-		   all 32 bits of 'nseconds'. */
-		READ_BUF(12);
-		len += 12;
-		READ32(dummy32);
-		if (dummy32)
-			return nfserr_inval;
-		READ32(iattr-&gt;ia_ctime.tv_sec);
-		READ32(iattr-&gt;ia_ctime.tv_nsec);
-		if (iattr-&gt;ia_ctime.tv_nsec &gt;= (u32)1000000000)
-			return nfserr_inval;
-		iattr-&gt;ia_valid |= ATTR_CTIME;
-	}
 	if (bmval[1] &amp; FATTR4_WORD1_TIME_MODIFY_SET) {
 		READ_BUF(4);
 		len += 4;
diff --git a/include/linux/nfsd/nfsd.h b/include/linux/nfsd/nfsd.h
index 21ee440dd3e7..41d30c9c9de6 100644
--- a/include/linux/nfsd/nfsd.h
+++ b/include/linux/nfsd/nfsd.h
@@ -329,7 +329,7 @@ extern struct timeval	nfssvc_boot;
 (FATTR4_WORD0_SIZE              | FATTR4_WORD0_ACL                                         )
 #define NFSD_WRITEABLE_ATTRS_WORD1                                                          \
 (FATTR4_WORD1_MODE              | FATTR4_WORD1_OWNER         | FATTR4_WORD1_OWNER_GROUP     \
- | FATTR4_WORD1_TIME_ACCESS_SET | FATTR4_WORD1_TIME_METADATA | FATTR4_WORD1_TIME_MODIFY_SET)
+ | FATTR4_WORD1_TIME_ACCESS_SET | FATTR4_WORD1_TIME_MODIFY_SET)
 
 #endif /* CONFIG_NFSD_V4 */
 </pre><hr><pre>commit 1a747ee0cc11a198f9e2435add821bd0dfedb7c1
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Thu Apr 24 10:08:22 2008 -0400

    locks: don't call -&gt;copy_lock methods on return of conflicting locks
    
    The file_lock structure is used both as a heavy-weight representation of
    an active lock, with pointers to reference-counted structures, etc., and
    as a simple container for parameters that describe a file lock.
    
    The conflicting lock returned from __posix_lock_file is an example of
    the latter; so don't call the filesystem or lock manager callbacks when
    copying to it.  This also saves the need for an unnecessary
    locks_init_lock in the nfsv4 server.
    
    Thanks to Trond for pointing out the error.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Cc: Trond Myklebust &lt;Trond.Myklebust@netapp.com&gt;

diff --git a/fs/lockd/svclock.c b/fs/lockd/svclock.c
index 1f122c1940af..4d81553d2948 100644
--- a/fs/lockd/svclock.c
+++ b/fs/lockd/svclock.c
@@ -632,7 +632,7 @@ nlmsvc_update_deferred_block(struct nlm_block *block, struct file_lock *conf,
 		block-&gt;b_flags |= B_TIMED_OUT;
 	if (conf) {
 		if (block-&gt;b_fl)
-			locks_copy_lock(block-&gt;b_fl, conf);
+			__locks_copy_lock(block-&gt;b_fl, conf);
 	}
 }
 
diff --git a/fs/locks.c b/fs/locks.c
index 2e0fa661e423..e1ea2fe03681 100644
--- a/fs/locks.c
+++ b/fs/locks.c
@@ -224,7 +224,7 @@ static void locks_copy_private(struct file_lock *new, struct file_lock *fl)
 /*
  * Initialize a new lock from an existing file_lock structure.
  */
-static void __locks_copy_lock(struct file_lock *new, const struct file_lock *fl)
+void __locks_copy_lock(struct file_lock *new, const struct file_lock *fl)
 {
 	new-&gt;fl_owner = fl-&gt;fl_owner;
 	new-&gt;fl_pid = fl-&gt;fl_pid;
@@ -833,7 +833,7 @@ static int __posix_lock_file(struct inode *inode, struct file_lock *request, str
 			if (!posix_locks_conflict(request, fl))
 				continue;
 			if (conflock)
-				locks_copy_lock(conflock, fl);
+				__locks_copy_lock(conflock, fl);
 			error = -EAGAIN;
 			if (!(request-&gt;fl_flags &amp; FL_SLEEP))
 				goto out;
diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 55dfdd71f1b0..8799b8708188 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2712,9 +2712,6 @@ nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 	* Note: locks.c uses the BKL to protect the inode's lock list.
 	*/
 
-	/* XXX?: Just to divert the locks_release_private at the start of
-	 * locks_copy_lock: */
-	locks_init_lock(&amp;conflock);
 	err = vfs_lock_file(filp, cmd, &amp;file_lock, &amp;conflock);
 	switch (-err) {
 	case 0: /* success! */
diff --git a/include/linux/fs.h b/include/linux/fs.h
index cc2be2cf7d41..6556f2f967e5 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -973,6 +973,7 @@ extern int do_sync_mapping_range(struct address_space *mapping, loff_t offset,
 /* fs/locks.c */
 extern void locks_init_lock(struct file_lock *);
 extern void locks_copy_lock(struct file_lock *, struct file_lock *);
+extern void __locks_copy_lock(struct file_lock *, const struct file_lock *);
 extern void locks_remove_posix(struct file *, fl_owner_t);
 extern void locks_remove_flock(struct file *);
 extern void posix_test_lock(struct file *, struct file_lock *);</pre>
    <div class="pagination">
        <a href='4_31.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><span>[32]</span><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><a href='4_52.html'>52</a><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_33.html'>Next&gt;&gt;</a>
    <div>
</body>
