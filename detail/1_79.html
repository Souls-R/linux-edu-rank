<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_78.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><span>[79]</span><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_80.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit eb8abb927ae2fd1730e24ea94cd9527f3c086292
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Tue Nov 2 09:34:50 2010 -0400

    ext4: Remove useless spinlock in ext4_getattr()
    
    Linus noted, and complained to me, that doing while lots of "git diff"'s
    of kernel sources, these spinlocks were responsible for 27% of the
    spinlock cost on his two-processor system as reported by perf.
    
    Git was doing lots of parallel stats, and this was putting a lot of
    pressure on ext4_getattr().  A spinlock to protect a single
    memory-to-memory copy is pointless, so remove it.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 191616470466..4d78342f3bf0 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -5410,9 +5410,7 @@ int ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,
 	 * will return the blocks that include the delayed allocation
 	 * blocks for this file.
 	 */
-	spin_lock(&amp;EXT4_I(inode)-&gt;i_block_reservation_lock);
 	delalloc_blocks = EXT4_I(inode)-&gt;i_reserved_data_blocks;
-	spin_unlock(&amp;EXT4_I(inode)-&gt;i_block_reservation_lock);
 
 	stat-&gt;blocks += (delalloc_blocks &lt;&lt; inode-&gt;i_sb-&gt;s_blocksize_bits)&gt;&gt;9;
 	return 0;</pre><hr><pre>commit b1142e8fec6a594723e5054055a7b53379b90490
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Thu Oct 28 17:33:57 2010 -0400

    ext4: BUG_ON fix: check if page has buffers before calling page_buffers()
    
    We need to make check if a page does not have buffes by checking
    page_has_buffers(page) before calling page_buffers(page) in
    ext4_writepage().  Otherwise page_buffers() could throw a BUG_ON.
    
    Thanks also to Markus Trippelsdorf and Avinash Kurup who also reported
    the problem.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reported-by: Sedat Dilek &lt;sedat.dilek@googlemail.com&gt;
    Tested-by: Sedat Dilek &lt;sedat.dilek@googlemail.com&gt;

diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 2d6c6c8c036d..191616470466 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2718,7 +2718,7 @@ static int ext4_writepage(struct page *page,
 	 * try to create them using __block_write_begin.  If this
 	 * fails, redirty the page and move on.
 	 */
-	if (!page_buffers(page)) {
+	if (!page_has_buffers(page)) {
 		if (__block_write_begin(page, 0, len,
 					noalloc_get_block_write)) {
 		redirty_page:
@@ -2732,12 +2732,10 @@ static int ext4_writepage(struct page *page,
 	if (walk_page_buffers(NULL, page_bufs, 0, len, NULL,
 			      ext4_bh_delay_or_unwritten)) {
 		/*
-		 * We don't want to do block allocation So redirty the
-		 * page and return We may reach here when we do a
-		 * journal commit via
-		 * journal_submit_inode_data_buffers.  If we don't
-		 * have mapping block we just ignore them. We can also
-		 * reach here via shrink_page_list
+		 * We don't want to do block allocation, so redirty
+		 * the page and return.  We may reach here when we do
+		 * a journal commit via journal_submit_inode_data_buffers.
+		 * We can also reach here via shrink_page_list
 		 */
 		goto redirty_page;
 	}</pre><hr><pre>commit a107e5a3a473a2ea62bd5af24e11b84adf1486ff
Merge: e3e1288e86a0 a269029d0e21
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 23:44:47 2010 -0400

    Merge branch 'next' into upstream-merge
    
    Conflicts:
            fs/ext4/inode.c
            fs/ext4/mballoc.c
            include/trace/events/ext4.h

diff --cc fs/ext4/extents.c
index 06328d3e5717,a17a676a3106..0554c48cb1fd
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -2538,74 -2491,19 +2491,18 @@@ void ext4_ext_release(struct super_bloc
  /* FIXME!! we need to try to merge to left or right after zero-out  */
  static int ext4_ext_zeroout(struct inode *inode, struct ext4_extent *ex)
  {
+ 	ext4_fsblk_t ee_pblock;
+ 	unsigned int ee_len;
  	int ret;
- 	struct bio *bio;
- 	int blkbits, blocksize;
- 	sector_t ee_pblock;
- 	struct completion event;
- 	unsigned int ee_len, len, done, offset;
  
- 
- 	blkbits   = inode-&gt;i_blkbits;
- 	blocksize = inode-&gt;i_sb-&gt;s_blocksize;
  	ee_len    = ext4_ext_get_actual_len(ex);
- 	ee_pblock = ext_pblock(ex);
- 
- 	/* convert ee_pblock to 512 byte sectors */
- 	ee_pblock = ee_pblock &lt;&lt; (blkbits - 9);
- 
- 	while (ee_len &gt; 0) {
- 
- 		if (ee_len &gt; BIO_MAX_PAGES)
- 			len = BIO_MAX_PAGES;
- 		else
- 			len = ee_len;
- 
- 		bio = bio_alloc(GFP_NOIO, len);
- 		if (!bio)
- 			return -ENOMEM;
+ 	ee_pblock = ext4_ext_pblock(ex);
  
- 		bio-&gt;bi_sector = ee_pblock;
- 		bio-&gt;bi_bdev   = inode-&gt;i_sb-&gt;s_bdev;
 -	ret = sb_issue_zeroout(inode-&gt;i_sb, ee_pblock, ee_len,
 -			       GFP_NOFS, BLKDEV_IFL_WAIT);
++	ret = sb_issue_zeroout(inode-&gt;i_sb, ee_pblock, ee_len, GFP_NOFS);
+ 	if (ret &gt; 0)
+ 		ret = 0;
  
- 		done = 0;
- 		offset = 0;
- 		while (done &lt; len) {
- 			ret = bio_add_page(bio, ZERO_PAGE(0),
- 							blocksize, offset);
- 			if (ret != blocksize) {
- 				/*
- 				 * We can't add any more pages because of
- 				 * hardware limitations.  Start a new bio.
- 				 */
- 				break;
- 			}
- 			done++;
- 			offset += blocksize;
- 			if (offset &gt;= PAGE_CACHE_SIZE)
- 				offset = 0;
- 		}
- 
- 		init_completion(&amp;event);
- 		bio-&gt;bi_private = &amp;event;
- 		bio-&gt;bi_end_io = bi_complete;
- 		submit_bio(WRITE, bio);
- 		wait_for_completion(&amp;event);
- 
- 		if (!test_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags)) {
- 			bio_put(bio);
- 			return -EIO;
- 		}
- 		bio_put(bio);
- 		ee_len    -= done;
- 		ee_pblock += done  &lt;&lt; (blkbits - 9);
- 	}
- 	return 0;
+ 	return ret;
  }
  
  #define EXT4_EXT_ZERO_LEN 7
diff --cc fs/ext4/ialloc.c
index 45853e0d1f21,509f429f71e8..1ce240a23ebb
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@@ -1205,3 -1220,110 +1220,109 @@@ unsigned long ext4_count_dirs(struct su
  	}
  	return count;
  }
+ 
+ /*
+  * Zeroes not yet zeroed inode table - just write zeroes through the whole
+  * inode table. Must be called without any spinlock held. The only place
+  * where it is called from on active part of filesystem is ext4lazyinit
+  * thread, so we do not need any special locks, however we have to prevent
+  * inode allocation from the current group, so we take alloc_sem lock, to
+  * block ext4_claim_inode until we are finished.
+  */
+ extern int ext4_init_inode_table(struct super_block *sb, ext4_group_t group,
+ 				 int barrier)
+ {
+ 	struct ext4_group_info *grp = ext4_get_group_info(sb, group);
+ 	struct ext4_sb_info *sbi = EXT4_SB(sb);
+ 	struct ext4_group_desc *gdp = NULL;
+ 	struct buffer_head *group_desc_bh;
+ 	handle_t *handle;
+ 	ext4_fsblk_t blk;
+ 	int num, ret = 0, used_blks = 0;
 -	unsigned long flags = BLKDEV_IFL_WAIT;
+ 
+ 	/* This should not happen, but just to be sure check this */
+ 	if (sb-&gt;s_flags &amp; MS_RDONLY) {
+ 		ret = 1;
+ 		goto out;
+ 	}
+ 
+ 	gdp = ext4_get_group_desc(sb, group, &amp;group_desc_bh);
+ 	if (!gdp)
+ 		goto out;
+ 
+ 	/*
+ 	 * We do not need to lock this, because we are the only one
+ 	 * handling this flag.
+ 	 */
+ 	if (gdp-&gt;bg_flags &amp; cpu_to_le16(EXT4_BG_INODE_ZEROED))
+ 		goto out;
+ 
+ 	handle = ext4_journal_start_sb(sb, 1);
+ 	if (IS_ERR(handle)) {
+ 		ret = PTR_ERR(handle);
+ 		goto out;
+ 	}
+ 
+ 	down_write(&amp;grp-&gt;alloc_sem);
+ 	/*
+ 	 * If inode bitmap was already initialized there may be some
+ 	 * used inodes so we need to skip blocks with used inodes in
+ 	 * inode table.
+ 	 */
+ 	if (!(gdp-&gt;bg_flags &amp; cpu_to_le16(EXT4_BG_INODE_UNINIT)))
+ 		used_blks = DIV_ROUND_UP((EXT4_INODES_PER_GROUP(sb) -
+ 			    ext4_itable_unused_count(sb, gdp)),
+ 			    sbi-&gt;s_inodes_per_block);
+ 
+ 	if ((used_blks &lt; 0) || (used_blks &gt; sbi-&gt;s_itb_per_group)) {
+ 		ext4_error(sb, "Something is wrong with group %u\n"
+ 			   "Used itable blocks: %d"
+ 			   "itable unused count: %u\n",
+ 			   group, used_blks,
+ 			   ext4_itable_unused_count(sb, gdp));
+ 		ret = 1;
+ 		goto out;
+ 	}
+ 
+ 	blk = ext4_inode_table(sb, gdp) + used_blks;
+ 	num = sbi-&gt;s_itb_per_group - used_blks;
+ 
+ 	BUFFER_TRACE(group_desc_bh, "get_write_access");
+ 	ret = ext4_journal_get_write_access(handle,
+ 					    group_desc_bh);
+ 	if (ret)
+ 		goto err_out;
+ 
+ 	/*
+ 	 * Skip zeroout if the inode table is full. But we set the ZEROED
+ 	 * flag anyway, because obviously, when it is full it does not need
+ 	 * further zeroing.
+ 	 */
+ 	if (unlikely(num == 0))
+ 		goto skip_zeroout;
+ 
+ 	ext4_debug("going to zero out inode table in group %d\n",
+ 		   group);
 -	if (barrier)
 -		flags |= BLKDEV_IFL_BARRIER;
 -	ret = sb_issue_zeroout(sb, blk, num, GFP_NOFS, flags);
++	ret = sb_issue_zeroout(sb, blk, num, GFP_NOFS);
+ 	if (ret &lt; 0)
+ 		goto err_out;
++	if (barrier)
++		blkdev_issue_flush(sb-&gt;s_bdev, GFP_NOFS, NULL);
+ 
+ skip_zeroout:
+ 	ext4_lock_group(sb, group);
+ 	gdp-&gt;bg_flags |= cpu_to_le16(EXT4_BG_INODE_ZEROED);
+ 	gdp-&gt;bg_checksum = ext4_group_desc_csum(sbi, group, gdp);
+ 	ext4_unlock_group(sb, group);
+ 
+ 	BUFFER_TRACE(group_desc_bh,
+ 		     "call ext4_handle_dirty_metadata");
+ 	ret = ext4_handle_dirty_metadata(handle, NULL,
+ 					 group_desc_bh);
+ 
+ err_out:
+ 	up_write(&amp;grp-&gt;alloc_sem);
+ 	ext4_journal_stop(handle);
+ out:
+ 	return ret;
+ }
diff --cc fs/ext4/inode.c
index 49635ef236f8,3ba237b0b2aa..2d6c6c8c036d
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -2030,86 -2062,32 +2062,32 @@@ static int mpage_da_submit_io(struct mp
  			BUG_ON(!PageLocked(page));
  			BUG_ON(PageWriteback(page));
  
- 			pages_skipped = mpd-&gt;wbc-&gt;pages_skipped;
- 			err = mapping-&gt;a_ops-&gt;writepage(page, mpd-&gt;wbc);
- 			if (!err &amp;&amp; (pages_skipped == mpd-&gt;wbc-&gt;pages_skipped))
- 				/*
- 				 * have successfully written the page
- 				 * without skipping the same
- 				 */
- 				mpd-&gt;pages_written++;
  			/*
- 			 * In error case, we have to continue because
- 			 * remaining pages are still locked
- 			 * XXX: unlock and re-dirty them?
+ 			 * If the page does not have buffers (for
+ 			 * whatever reason), try to create them using
 -			 * block_prepare_write.  If this fails,
++			 * __block_write_begin.  If this fails,
+ 			 * redirty the page and move on.
  			 */
- 			if (ret == 0)
- 				ret = err;
- 		}
- 		pagevec_release(&amp;pvec);
- 	}
- 	return ret;
- }
- 
- /*
-  * mpage_put_bnr_to_bhs - walk blocks and assign them actual numbers
-  *
-  * the function goes through all passed space and put actual disk
-  * block numbers into buffer heads, dropping BH_Delay and BH_Unwritten
-  */
- static void mpage_put_bnr_to_bhs(struct mpage_da_data *mpd,
- 				 struct ext4_map_blocks *map)
- {
- 	struct inode *inode = mpd-&gt;inode;
- 	struct address_space *mapping = inode-&gt;i_mapping;
- 	int blocks = map-&gt;m_len;
- 	sector_t pblock = map-&gt;m_pblk, cur_logical;
- 	struct buffer_head *head, *bh;
- 	pgoff_t index, end;
- 	struct pagevec pvec;
- 	int nr_pages, i;
- 
- 	index = map-&gt;m_lblk &gt;&gt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);
- 	end = (map-&gt;m_lblk + blocks - 1) &gt;&gt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);
- 	cur_logical = index &lt;&lt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);
- 
- 	pagevec_init(&amp;pvec, 0);
- 
- 	while (index &lt;= end) {
- 		/* XXX: optimize tail */
- 		nr_pages = pagevec_lookup(&amp;pvec, mapping, index, PAGEVEC_SIZE);
- 		if (nr_pages == 0)
- 			break;
- 		for (i = 0; i &lt; nr_pages; i++) {
- 			struct page *page = pvec.pages[i];
- 
- 			index = page-&gt;index;
- 			if (index &gt; end)
- 				break;
- 			index++;
- 
- 			BUG_ON(!PageLocked(page));
- 			BUG_ON(PageWriteback(page));
- 			BUG_ON(!page_has_buffers(page));
- 
- 			bh = page_buffers(page);
- 			head = bh;
- 
- 			/* skip blocks out of the range */
- 			do {
- 				if (cur_logical &gt;= map-&gt;m_lblk)
- 					break;
- 				cur_logical++;
- 			} while ((bh = bh-&gt;b_this_page) != head);
+ 			if (!page_has_buffers(page)) {
 -				if (block_prepare_write(page, 0, len,
++				if (__block_write_begin(page, 0, len,
+ 						noalloc_get_block_write)) {
+ 				redirty_page:
+ 					redirty_page_for_writepage(mpd-&gt;wbc,
+ 								   page);
+ 					unlock_page(page);
+ 					continue;
+ 				}
+ 				commit_write = 1;
+ 			}
  
+ 			bh = page_bufs = page_buffers(page);
+ 			block_start = 0;
  			do {
- 				if (cur_logical &gt;= map-&gt;m_lblk + blocks)
- 					break;
- 
- 				if (buffer_delay(bh) || buffer_unwritten(bh)) {
- 
- 					BUG_ON(bh-&gt;b_bdev != inode-&gt;i_sb-&gt;s_bdev);
- 
+ 				if (!bh)
+ 					goto redirty_page;
+ 				if (map &amp;&amp; (cur_logical &gt;= map-&gt;m_lblk) &amp;&amp;
+ 				    (cur_logical &lt;= (map-&gt;m_lblk +
+ 						     (map-&gt;m_len - 1)))) {
  					if (buffer_delay(bh)) {
  						clear_buffer_delay(bh);
  						bh-&gt;b_blocknr = pblock;
@@@ -2712,18 -2714,15 +2713,15 @@@ static int ext4_writepage(struct page *
  	else
  		len = PAGE_CACHE_SIZE;
  
- 	if (page_has_buffers(page)) {
- 		page_bufs = page_buffers(page);
- 		if (walk_page_buffers(NULL, page_bufs, 0, len, NULL,
- 					ext4_bh_delay_or_unwritten)) {
- 			/*
- 			 * We don't want to do  block allocation
- 			 * So redirty the page and return
- 			 * We may reach here when we do a journal commit
- 			 * via journal_submit_inode_data_buffers.
- 			 * If we don't have mapping block we just ignore
- 			 * them. We can also reach here via shrink_page_list
- 			 */
+ 	/*
+ 	 * If the page does not have buffers (for whatever reason),
 -	 * try to create them using block_prepare_write.  If this
++	 * try to create them using __block_write_begin.  If this
+ 	 * fails, redirty the page and move on.
+ 	 */
+ 	if (!page_buffers(page)) {
 -		if (block_prepare_write(page, 0, len,
++		if (__block_write_begin(page, 0, len,
+ 					noalloc_get_block_write)) {
+ 		redirty_page:
  			redirty_page_for_writepage(wbc, page);
  			unlock_page(page);
  			return 0;
diff --cc fs/ext4/mballoc.c
index 42f77b1dc72d,328ea9cec57b..c58eba34724a
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@@ -2567,8 -2613,8 +2614,8 @@@ static inline int ext4_issue_discard(st
  	discard_block = block + ext4_group_first_block_no(sb, block_group);
  	trace_ext4_discard_blocks(sb,
  			(unsigned long long) discard_block, count);
 -	ret = sb_issue_discard(sb, discard_block, count);
 +	ret = sb_issue_discard(sb, discard_block, count, GFP_NOFS, 0);
- 	if (ret == EOPNOTSUPP) {
+ 	if (ret == -EOPNOTSUPP) {
  		ext4_warning(sb, "discard not supported, disabling");
  		clear_opt(EXT4_SB(sb)-&gt;s_mount_opt, DISCARD);
  	}
diff --cc fs/ext4/resize.c
index ca5c8aa00a2f,f398474e2784..dc963929de65
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@@ -226,23 -226,13 +226,13 @@@ static int setup_new_group_blocks(struc
  	}
  
  	/* Zero out all of the reserved backup group descriptor table blocks */
- 	for (i = 0, bit = gdblocks + 1, block = start + bit;
- 	     i &lt; reserved_gdb; i++, block++, bit++) {
- 		struct buffer_head *gdb;
- 
- 		ext4_debug("clear reserved block %#04llx (+%d)\n", block, bit);
- 
- 		if ((err = extend_or_restart_transaction(handle, 1, bh)))
- 			goto exit_bh;
+ 	ext4_debug("clear inode table blocks %#04llx -&gt; %#04llx\n",
+ 			block, sbi-&gt;s_itb_per_group);
+ 	err = sb_issue_zeroout(sb, gdblocks + start + 1, reserved_gdb,
 -			       GFP_NOFS, BLKDEV_IFL_WAIT);
++			       GFP_NOFS);
+ 	if (err)
+ 		goto exit_bh;
  
- 		if (IS_ERR(gdb = bclean(handle, sb, block))) {
- 			err = PTR_ERR(gdb);
- 			goto exit_bh;
- 		}
- 		ext4_handle_dirty_metadata(handle, NULL, gdb);
- 		ext4_set_bit(bit, bh-&gt;b_data);
- 		brelse(gdb);
- 	}
  	ext4_debug("mark block bitmap %#04llx (+%llu)\n", input-&gt;block_bitmap,
  		   input-&gt;block_bitmap - start);
  	ext4_set_bit(input-&gt;block_bitmap - start, bh-&gt;b_data);
@@@ -251,23 -241,13 +241,12 @@@
  	ext4_set_bit(input-&gt;inode_bitmap - start, bh-&gt;b_data);
  
  	/* Zero out all of the inode table blocks */
- 	for (i = 0, block = input-&gt;inode_table, bit = block - start;
- 	     i &lt; sbi-&gt;s_itb_per_group; i++, bit++, block++) {
- 		struct buffer_head *it;
- 
- 		ext4_debug("clear inode block %#04llx (+%d)\n", block, bit);
- 
- 		if ((err = extend_or_restart_transaction(handle, 1, bh)))
- 			goto exit_bh;
- 
- 		if (IS_ERR(it = bclean(handle, sb, block))) {
- 			err = PTR_ERR(it);
- 			goto exit_bh;
- 		}
- 		ext4_handle_dirty_metadata(handle, NULL, it);
- 		brelse(it);
- 		ext4_set_bit(bit, bh-&gt;b_data);
- 	}
+ 	block = input-&gt;inode_table;
+ 	ext4_debug("clear inode table blocks %#04llx -&gt; %#04llx\n",
+ 			block, sbi-&gt;s_itb_per_group);
 -	err = sb_issue_zeroout(sb, block, sbi-&gt;s_itb_per_group,
 -			       GFP_NOFS, BLKDEV_IFL_WAIT);
++	err = sb_issue_zeroout(sb, block, sbi-&gt;s_itb_per_group, GFP_NOFS);
+ 	if (err)
+ 		goto exit_bh;
  
  	if ((err = extend_or_restart_transaction(handle, 2, bh)))
  		goto exit_bh;
diff --cc include/linux/blkdev.h
index 646b462d04df,e5cb4d029689..5027a599077d
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -883,14 -932,23 +883,22 @@@ extern int blkdev_issue_flush(struct bl
  extern int blkdev_issue_discard(struct block_device *bdev, sector_t sector,
  		sector_t nr_sects, gfp_t gfp_mask, unsigned long flags);
  extern int blkdev_issue_zeroout(struct block_device *bdev, sector_t sector,
 -			sector_t nr_sects, gfp_t gfp_mask, unsigned long flags);
 -static inline int sb_issue_discard(struct super_block *sb,
 -				   sector_t block, sector_t nr_blocks)
 +			sector_t nr_sects, gfp_t gfp_mask);
 +static inline int sb_issue_discard(struct super_block *sb, sector_t block,
 +		sector_t nr_blocks, gfp_t gfp_mask, unsigned long flags)
  {
 -	block &lt;&lt;= (sb-&gt;s_blocksize_bits - 9);
 -	nr_blocks &lt;&lt;= (sb-&gt;s_blocksize_bits - 9);
 -	return blkdev_issue_discard(sb-&gt;s_bdev, block, nr_blocks, GFP_NOFS,
 -				   BLKDEV_IFL_WAIT | BLKDEV_IFL_BARRIER);
 +	return blkdev_issue_discard(sb-&gt;s_bdev, block &lt;&lt; (sb-&gt;s_blocksize_bits - 9),
 +				    nr_blocks &lt;&lt; (sb-&gt;s_blocksize_bits - 9),
 +				    gfp_mask, flags);
  }
+ static inline int sb_issue_zeroout(struct super_block *sb, sector_t block,
 -		sector_t nr_blocks, gfp_t gfp_mask, unsigned long flags)
++		sector_t nr_blocks, gfp_t gfp_mask)
+ {
+ 	return blkdev_issue_zeroout(sb-&gt;s_bdev,
+ 				    block &lt;&lt; (sb-&gt;s_blocksize_bits - 9),
+ 				    nr_blocks &lt;&lt; (sb-&gt;s_blocksize_bits - 9),
 -				    gfp_mask, flags);
++				    gfp_mask);
+ }
  
  extern int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm);
  
diff --cc include/linux/fs.h
index b2a6009cba10,7008268e9b5a..6ed7ace74b7c
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -32,11 -32,17 +32,17 @@@
  #define SEEK_END	2	/* seek relative to end of file */
  #define SEEK_MAX	SEEK_END
  
+ struct fstrim_range {
+ 	uint64_t start;
+ 	uint64_t len;
+ 	uint64_t minlen;
+ };
+ 
  /* And dynamically-tunable limits and defaults: */
  struct files_stat_struct {
 -	int nr_files;		/* read only */
 -	int nr_free_files;	/* read only */
 -	int max_files;		/* tunable */
 +	unsigned long nr_files;		/* read only */
 +	unsigned long nr_free_files;	/* read only */
 +	unsigned long max_files;		/* tunable */
  };
  
  struct inodes_stat_t {
diff --cc include/trace/events/ext4.h
index 6bcb00645de4,8f59db107bbb..289010d3270b
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@@ -228,7 -245,7 +245,6 @@@ TRACE_EVENT(ext4_da_writepages
  		__field(	long,	pages_skipped		)
  		__field(	loff_t,	range_start		)
  		__field(	loff_t,	range_end		)
--		__field(	char,	nonblocking		)
  		__field(	char,	for_kupdate		)
  		__field(	char,	for_reclaim		)
  		__field(	char,	range_cyclic		)
@@@ -248,14 -267,11 +265,14 @@@
  		__entry-&gt;writeback_index = inode-&gt;i_mapping-&gt;writeback_index;
  	),
  
- 	TP_printk("dev %s ino %lu nr_to_write %ld pages_skipped %ld "
 -	TP_printk("dev %d,%d ino %lu nr_to_write %ld pages_skipped %ld range_start %llu range_end %llu nonblocking %d for_kupdate %d for_reclaim %d range_cyclic %d writeback_index %lu",
++	TP_printk("dev %d,%d ino %lu nr_to_write %ld pages_skipped %ld "
 +		  "range_start %llu range_end %llu "
 +		  "for_kupdate %d for_reclaim %d "
 +		  "range_cyclic %d writeback_index %lu",
- 		  jbd2_dev_to_name(__entry-&gt;dev),
+ 		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
  		  (unsigned long) __entry-&gt;ino, __entry-&gt;nr_to_write,
  		  __entry-&gt;pages_skipped, __entry-&gt;range_start,
 -		  __entry-&gt;range_end, __entry-&gt;nonblocking,
 +		  __entry-&gt;range_end,
  		  __entry-&gt;for_kupdate, __entry-&gt;for_reclaim,
  		  __entry-&gt;range_cyclic,
  		  (unsigned long) __entry-&gt;writeback_index)</pre><hr><pre>commit a269029d0e2192046be4c07ed78a45022469ee4c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 22:08:50 2010 -0400

    ext4,jbd2: convert tracepoints to use major/minor numbers
    
    Unfortunately perf can't deal with anything other than direct structure
    accesses in the TP_printk() section.  It will drop dead when it sees
    jbd2_dev_to_name() in the "print fmt" section of the tracepoint.
    
    Addresses-Google-Bug: 3138508
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index b5f4938d612d..8f59db107bbb 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -21,7 +21,8 @@ TRACE_EVENT(ext4_free_inode,
 	TP_ARGS(inode),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	umode_t, mode			)
 		__field(	uid_t,	uid			)
@@ -30,7 +31,8 @@ TRACE_EVENT(ext4_free_inode,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;mode	= inode-&gt;i_mode;
 		__entry-&gt;uid	= inode-&gt;i_uid;
@@ -38,9 +40,10 @@ TRACE_EVENT(ext4_free_inode,
 		__entry-&gt;blocks	= inode-&gt;i_blocks;
 	),
 
-	TP_printk("dev %s ino %lu mode 0%o uid %u gid %u blocks %llu",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;mode, __entry-&gt;uid, __entry-&gt;gid,
+	TP_printk("dev %d,%d ino %lu mode 0%o uid %u gid %u blocks %llu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;mode,
+		  __entry-&gt;uid, __entry-&gt;gid,
 		  (unsigned long long) __entry-&gt;blocks)
 );
 
@@ -50,20 +53,22 @@ TRACE_EVENT(ext4_request_inode,
 	TP_ARGS(dir, mode),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	dir			)
 		__field(	umode_t, mode			)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= dir-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(dir-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(dir-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;dir	= dir-&gt;i_ino;
 		__entry-&gt;mode	= mode;
 	),
 
-	TP_printk("dev %s dir %lu mode 0%o",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;dir,
-		  __entry-&gt;mode)
+	TP_printk("dev %d,%d dir %lu mode 0%o",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;dir, __entry-&gt;mode)
 );
 
 TRACE_EVENT(ext4_allocate_inode,
@@ -72,21 +77,24 @@ TRACE_EVENT(ext4_allocate_inode,
 	TP_ARGS(inode, dir, mode),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	ino_t,	dir			)
 		__field(	umode_t, mode			)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;dir	= dir-&gt;i_ino;
 		__entry-&gt;mode	= mode;
 	),
 
-	TP_printk("dev %s ino %lu dir %lu mode 0%o",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu dir %lu mode 0%o",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  (unsigned long) __entry-&gt;dir, __entry-&gt;mode)
 );
 
@@ -98,7 +106,8 @@ DECLARE_EVENT_CLASS(ext4__write_begin,
 	TP_ARGS(inode, pos, len, flags),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	loff_t,	pos			)
 		__field(	unsigned int, len		)
@@ -106,15 +115,17 @@ DECLARE_EVENT_CLASS(ext4__write_begin,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;pos	= pos;
 		__entry-&gt;len	= len;
 		__entry-&gt;flags	= flags;
 	),
 
-	TP_printk("dev %s ino %lu pos %llu len %u flags %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu pos %llu len %u flags %u",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;pos, __entry-&gt;len, __entry-&gt;flags)
 );
 
@@ -141,7 +152,8 @@ DECLARE_EVENT_CLASS(ext4__write_end,
 	TP_ARGS(inode, pos, len, copied),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	loff_t,	pos			)
 		__field(	unsigned int, len		)
@@ -149,16 +161,18 @@ DECLARE_EVENT_CLASS(ext4__write_end,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;pos	= pos;
 		__entry-&gt;len	= len;
 		__entry-&gt;copied	= copied;
 	),
 
-	TP_printk("dev %s ino %lu pos %llu len %u copied %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;pos, __entry-&gt;len, __entry-&gt;copied)
+	TP_printk("dev %d,%d ino %lu pos %llu len %u copied %u",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;pos,
+		  __entry-&gt;len, __entry-&gt;copied)
 );
 
 DEFINE_EVENT(ext4__write_end, ext4_ordered_write_end,
@@ -199,21 +213,23 @@ TRACE_EVENT(ext4_writepage,
 	TP_ARGS(inode, page),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	pgoff_t, index			)
 
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;index	= page-&gt;index;
 	),
 
-	TP_printk("dev %s ino %lu page_index %lu",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;index)
+	TP_printk("dev %d,%d ino %lu page_index %lu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;index)
 );
 
 TRACE_EVENT(ext4_da_writepages,
@@ -222,7 +238,8 @@ TRACE_EVENT(ext4_da_writepages,
 	TP_ARGS(inode, wbc),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	long,	nr_to_write		)
 		__field(	long,	pages_skipped		)
@@ -236,7 +253,8 @@ TRACE_EVENT(ext4_da_writepages,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino		= inode-&gt;i_ino;
 		__entry-&gt;nr_to_write	= wbc-&gt;nr_to_write;
 		__entry-&gt;pages_skipped	= wbc-&gt;pages_skipped;
@@ -249,8 +267,8 @@ TRACE_EVENT(ext4_da_writepages,
 		__entry-&gt;writeback_index = inode-&gt;i_mapping-&gt;writeback_index;
 	),
 
-	TP_printk("dev %s ino %lu nr_to_write %ld pages_skipped %ld range_start %llu range_end %llu nonblocking %d for_kupdate %d for_reclaim %d range_cyclic %d writeback_index %lu",
-		  jbd2_dev_to_name(__entry-&gt;dev),
+	TP_printk("dev %d,%d ino %lu nr_to_write %ld pages_skipped %ld range_start %llu range_end %llu nonblocking %d for_kupdate %d for_reclaim %d range_cyclic %d writeback_index %lu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
 		  (unsigned long) __entry-&gt;ino, __entry-&gt;nr_to_write,
 		  __entry-&gt;pages_skipped, __entry-&gt;range_start,
 		  __entry-&gt;range_end, __entry-&gt;nonblocking,
@@ -265,7 +283,8 @@ TRACE_EVENT(ext4_da_write_pages,
 	TP_ARGS(inode, mpd),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	__u64,	b_blocknr		)
 		__field(	__u32,	b_size			)
@@ -276,7 +295,8 @@ TRACE_EVENT(ext4_da_write_pages,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino		= inode-&gt;i_ino;
 		__entry-&gt;b_blocknr	= mpd-&gt;b_blocknr;
 		__entry-&gt;b_size		= mpd-&gt;b_size;
@@ -286,8 +306,9 @@ TRACE_EVENT(ext4_da_write_pages,
 		__entry-&gt;pages_written	= mpd-&gt;pages_written;
 	),
 
-	TP_printk("dev %s ino %lu b_blocknr %llu b_size %u b_state 0x%04x first_page %lu io_done %d pages_written %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu b_blocknr %llu b_size %u b_state 0x%04x first_page %lu io_done %d pages_written %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;b_blocknr, __entry-&gt;b_size,
 		  __entry-&gt;b_state, __entry-&gt;first_page,
 		  __entry-&gt;io_done, __entry-&gt;pages_written)
@@ -300,7 +321,8 @@ TRACE_EVENT(ext4_da_writepages_result,
 	TP_ARGS(inode, wbc, ret, pages_written),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	int,	ret			)
 		__field(	int,	pages_written		)
@@ -310,7 +332,8 @@ TRACE_EVENT(ext4_da_writepages_result,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino		= inode-&gt;i_ino;
 		__entry-&gt;ret		= ret;
 		__entry-&gt;pages_written	= pages_written;
@@ -319,8 +342,8 @@ TRACE_EVENT(ext4_da_writepages_result,
 		__entry-&gt;writeback_index = inode-&gt;i_mapping-&gt;writeback_index;
 	),
 
-	TP_printk("dev %s ino %lu ret %d pages_written %d pages_skipped %ld more_io %d writeback_index %lu",
-		  jbd2_dev_to_name(__entry-&gt;dev),
+	TP_printk("dev %d,%d ino %lu ret %d pages_written %d pages_skipped %ld more_io %d writeback_index %lu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
 		  (unsigned long) __entry-&gt;ino, __entry-&gt;ret,
 		  __entry-&gt;pages_written, __entry-&gt;pages_skipped,
 		  __entry-&gt;more_io,
@@ -334,20 +357,23 @@ TRACE_EVENT(ext4_discard_blocks,
 	TP_ARGS(sb, blk, count),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	__u64,	blk			)
 		__field(	__u64,	count			)
 
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(sb-&gt;s_dev);
 		__entry-&gt;blk	= blk;
 		__entry-&gt;count	= count;
 	),
 
-	TP_printk("dev %s blk %llu count %llu",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;blk, __entry-&gt;count)
+	TP_printk("dev %d,%d blk %llu count %llu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  __entry-&gt;blk, __entry-&gt;count)
 );
 
 DECLARE_EVENT_CLASS(ext4__mb_new_pa,
@@ -357,7 +383,8 @@ DECLARE_EVENT_CLASS(ext4__mb_new_pa,
 	TP_ARGS(ac, pa),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	__u64,	pa_pstart		)
 		__field(	__u32,	pa_len			)
@@ -366,16 +393,18 @@ DECLARE_EVENT_CLASS(ext4__mb_new_pa,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= ac-&gt;ac_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(ac-&gt;ac_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(ac-&gt;ac_sb-&gt;s_dev);
 		__entry-&gt;ino		= ac-&gt;ac_inode-&gt;i_ino;
 		__entry-&gt;pa_pstart	= pa-&gt;pa_pstart;
 		__entry-&gt;pa_len		= pa-&gt;pa_len;
 		__entry-&gt;pa_lstart	= pa-&gt;pa_lstart;
 	),
 
-	TP_printk("dev %s ino %lu pstart %llu len %u lstart %llu",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;pa_pstart, __entry-&gt;pa_len, __entry-&gt;pa_lstart)
+	TP_printk("dev %d,%d ino %lu pstart %llu len %u lstart %llu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;pa_pstart,
+		  __entry-&gt;pa_len, __entry-&gt;pa_lstart)
 );
 
 DEFINE_EVENT(ext4__mb_new_pa, ext4_mb_new_inode_pa,
@@ -403,7 +432,8 @@ TRACE_EVENT(ext4_mb_release_inode_pa,
 	TP_ARGS(sb, inode, pa, block, count),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	__u64,	block			)
 		__field(	__u32,	count			)
@@ -411,15 +441,16 @@ TRACE_EVENT(ext4_mb_release_inode_pa,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(sb-&gt;s_dev);
 		__entry-&gt;ino		= inode-&gt;i_ino;
 		__entry-&gt;block		= block;
 		__entry-&gt;count		= count;
 	),
 
-	TP_printk("dev %s ino %lu block %llu count %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;block, __entry-&gt;count)
+	TP_printk("dev %d,%d ino %lu block %llu count %u",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;block, __entry-&gt;count)
 );
 
 TRACE_EVENT(ext4_mb_release_group_pa,
@@ -429,20 +460,23 @@ TRACE_EVENT(ext4_mb_release_group_pa,
 	TP_ARGS(sb, pa),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	__u64,	pa_pstart		)
 		__field(	__u32,	pa_len			)
 
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(sb-&gt;s_dev);
 		__entry-&gt;pa_pstart	= pa-&gt;pa_pstart;
 		__entry-&gt;pa_len		= pa-&gt;pa_len;
 	),
 
-	TP_printk("dev %s pstart %llu len %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;pa_pstart, __entry-&gt;pa_len)
+	TP_printk("dev %d,%d pstart %llu len %u",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  __entry-&gt;pa_pstart, __entry-&gt;pa_len)
 );
 
 TRACE_EVENT(ext4_discard_preallocations,
@@ -451,18 +485,21 @@ TRACE_EVENT(ext4_discard_preallocations,
 	TP_ARGS(inode),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 	),
 
-	TP_printk("dev %s ino %lu",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino)
+	TP_printk("dev %d,%d ino %lu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino)
 );
 
 TRACE_EVENT(ext4_mb_discard_preallocations,
@@ -471,18 +508,20 @@ TRACE_EVENT(ext4_mb_discard_preallocations,
 	TP_ARGS(sb, needed),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	int,	needed			)
 
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(sb-&gt;s_dev);
 		__entry-&gt;needed	= needed;
 	),
 
-	TP_printk("dev %s needed %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;needed)
+	TP_printk("dev %d,%d needed %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor, __entry-&gt;needed)
 );
 
 TRACE_EVENT(ext4_request_blocks,
@@ -491,7 +530,8 @@ TRACE_EVENT(ext4_request_blocks,
 	TP_ARGS(ar),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	unsigned int, flags		)
 		__field(	unsigned int, len		)
@@ -504,7 +544,8 @@ TRACE_EVENT(ext4_request_blocks,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= ar-&gt;inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(ar-&gt;inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(ar-&gt;inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= ar-&gt;inode-&gt;i_ino;
 		__entry-&gt;flags	= ar-&gt;flags;
 		__entry-&gt;len	= ar-&gt;len;
@@ -516,8 +557,9 @@ TRACE_EVENT(ext4_request_blocks,
 		__entry-&gt;pright	= ar-&gt;pright;
 	),
 
-	TP_printk("dev %s ino %lu flags %u len %u lblk %llu goal %llu lleft %llu lright %llu pleft %llu pright %llu ",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu flags %u len %u lblk %llu goal %llu lleft %llu lright %llu pleft %llu pright %llu ",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;flags, __entry-&gt;len,
 		  (unsigned long long) __entry-&gt;logical,
 		  (unsigned long long) __entry-&gt;goal,
@@ -533,7 +575,8 @@ TRACE_EVENT(ext4_allocate_blocks,
 	TP_ARGS(ar, block),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	__u64,	block			)
 		__field(	unsigned int, flags		)
@@ -547,7 +590,8 @@ TRACE_EVENT(ext4_allocate_blocks,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= ar-&gt;inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(ar-&gt;inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(ar-&gt;inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= ar-&gt;inode-&gt;i_ino;
 		__entry-&gt;block	= block;
 		__entry-&gt;flags	= ar-&gt;flags;
@@ -560,9 +604,10 @@ TRACE_EVENT(ext4_allocate_blocks,
 		__entry-&gt;pright	= ar-&gt;pright;
 	),
 
-	TP_printk("dev %s ino %lu flags %u len %u block %llu lblk %llu goal %llu lleft %llu lright %llu pleft %llu pright %llu ",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;flags, __entry-&gt;len, __entry-&gt;block,
+	TP_printk("dev %d,%d ino %lu flags %u len %u block %llu lblk %llu goal %llu lleft %llu lright %llu pleft %llu pright %llu ",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;flags,
+		  __entry-&gt;len, __entry-&gt;block,
 		  (unsigned long long) __entry-&gt;logical,
 		  (unsigned long long) __entry-&gt;goal,
 		  (unsigned long long) __entry-&gt;lleft,
@@ -578,7 +623,8 @@ TRACE_EVENT(ext4_free_blocks,
 	TP_ARGS(inode, block, count, flags),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(      umode_t, mode			)
 		__field(	__u64,	block			)
@@ -587,7 +633,8 @@ TRACE_EVENT(ext4_free_blocks,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino		= inode-&gt;i_ino;
 		__entry-&gt;mode		= inode-&gt;i_mode;
 		__entry-&gt;block		= block;
@@ -595,8 +642,9 @@ TRACE_EVENT(ext4_free_blocks,
 		__entry-&gt;flags		= flags;
 	),
 
-	TP_printk("dev %s ino %lu mode 0%o block %llu count %lu flags %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu mode 0%o block %llu count %lu flags %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;mode, __entry-&gt;block, __entry-&gt;count,
 		  __entry-&gt;flags)
 );
@@ -607,7 +655,8 @@ TRACE_EVENT(ext4_sync_file,
 	TP_ARGS(file, datasync),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	ino_t,	parent			)
 		__field(	int,	datasync		)
@@ -616,14 +665,16 @@ TRACE_EVENT(ext4_sync_file,
 	TP_fast_assign(
 		struct dentry *dentry = file-&gt;f_path.dentry;
 
-		__entry-&gt;dev		= dentry-&gt;d_inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(dentry-&gt;d_inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(dentry-&gt;d_inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino		= dentry-&gt;d_inode-&gt;i_ino;
 		__entry-&gt;datasync	= datasync;
 		__entry-&gt;parent		= dentry-&gt;d_parent-&gt;d_inode-&gt;i_ino;
 	),
 
-	TP_printk("dev %s ino %ld parent %ld datasync %d ",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %ld parent %ld datasync %d ",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  (unsigned long) __entry-&gt;parent, __entry-&gt;datasync)
 );
 
@@ -633,18 +684,20 @@ TRACE_EVENT(ext4_sync_fs,
 	TP_ARGS(sb, wait),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	int,	wait			)
 
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(sb-&gt;s_dev);
 		__entry-&gt;wait	= wait;
 	),
 
-	TP_printk("dev %s wait %d", jbd2_dev_to_name(__entry-&gt;dev),
-		  __entry-&gt;wait)
+	TP_printk("dev %d,%d wait %d", __entry-&gt;dev_major,
+		  __entry-&gt;dev_minor, __entry-&gt;wait)
 );
 
 TRACE_EVENT(ext4_alloc_da_blocks,
@@ -653,21 +706,24 @@ TRACE_EVENT(ext4_alloc_da_blocks,
 	TP_ARGS(inode),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field( unsigned int,	data_blocks	)
 		__field( unsigned int,	meta_blocks	)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;data_blocks = EXT4_I(inode)-&gt;i_reserved_data_blocks;
 		__entry-&gt;meta_blocks = EXT4_I(inode)-&gt;i_reserved_meta_blocks;
 	),
 
-	TP_printk("dev %s ino %lu data_blocks %u meta_blocks %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu data_blocks %u meta_blocks %u",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;data_blocks, __entry-&gt;meta_blocks)
 );
 
@@ -677,7 +733,8 @@ TRACE_EVENT(ext4_mballoc_alloc,
 	TP_ARGS(ac),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	__u16,	found			)
 		__field(	__u16,	groups			)
@@ -700,7 +757,8 @@ TRACE_EVENT(ext4_mballoc_alloc,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino		= ac-&gt;ac_inode-&gt;i_ino;
 		__entry-&gt;found		= ac-&gt;ac_found;
 		__entry-&gt;flags		= ac-&gt;ac_flags;
@@ -722,10 +780,11 @@ TRACE_EVENT(ext4_mballoc_alloc,
 		__entry-&gt;result_len	= ac-&gt;ac_f_ex.fe_len;
 	),
 
-	TP_printk("dev %s inode %lu orig %u/%d/%u@%u goal %u/%d/%u@%u "
+	TP_printk("dev %d,%d inode %lu orig %u/%d/%u@%u goal %u/%d/%u@%u "
 		  "result %u/%d/%u@%u blks %u grps %u cr %u flags 0x%04x "
 		  "tail %u broken %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;orig_group, __entry-&gt;orig_start,
 		  __entry-&gt;orig_len, __entry-&gt;orig_logical,
 		  __entry-&gt;goal_group, __entry-&gt;goal_start,
@@ -743,7 +802,8 @@ TRACE_EVENT(ext4_mballoc_prealloc,
 	TP_ARGS(ac),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	__u32, 	orig_logical		)
 		__field(	  int,	orig_start		)
@@ -756,7 +816,8 @@ TRACE_EVENT(ext4_mballoc_prealloc,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(ac-&gt;ac_inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino		= ac-&gt;ac_inode-&gt;i_ino;
 		__entry-&gt;orig_logical	= ac-&gt;ac_o_ex.fe_logical;
 		__entry-&gt;orig_start	= ac-&gt;ac_o_ex.fe_start;
@@ -768,8 +829,9 @@ TRACE_EVENT(ext4_mballoc_prealloc,
 		__entry-&gt;result_len	= ac-&gt;ac_b_ex.fe_len;
 	),
 
-	TP_printk("dev %s inode %lu orig %u/%d/%u@%u result %u/%d/%u@%u",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d inode %lu orig %u/%d/%u@%u result %u/%d/%u@%u",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;orig_group, __entry-&gt;orig_start,
 		  __entry-&gt;orig_len, __entry-&gt;orig_logical,
 		  __entry-&gt;result_group, __entry-&gt;result_start,
@@ -786,7 +848,8 @@ DECLARE_EVENT_CLASS(ext4__mballoc,
 	TP_ARGS(sb, inode, group, start, len),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	  int,	result_start		)
 		__field(	__u32, 	result_group		)
@@ -794,15 +857,17 @@ DECLARE_EVENT_CLASS(ext4__mballoc,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= sb-&gt;s_dev;
+		__entry-&gt;dev_major	= MAJOR(sb-&gt;s_dev);
+		__entry-&gt;dev_minor	= MINOR(sb-&gt;s_dev);
 		__entry-&gt;ino		= inode ? inode-&gt;i_ino : 0;
 		__entry-&gt;result_start	= start;
 		__entry-&gt;result_group	= group;
 		__entry-&gt;result_len	= len;
 	),
 
-	TP_printk("dev %s inode %lu extent %u/%d/%u ",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d inode %lu extent %u/%d/%u ",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;result_group, __entry-&gt;result_start,
 		  __entry-&gt;result_len)
 );
@@ -835,7 +900,8 @@ TRACE_EVENT(ext4_forget,
 	TP_ARGS(inode, is_metadata, block),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	umode_t, mode			)
 		__field(	int,	is_metadata		)
@@ -843,16 +909,18 @@ TRACE_EVENT(ext4_forget,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;mode	= inode-&gt;i_mode;
 		__entry-&gt;is_metadata = is_metadata;
 		__entry-&gt;block	= block;
 	),
 
-	TP_printk("dev %s ino %lu mode 0%o is_metadata %d block %llu",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;mode, __entry-&gt;is_metadata, __entry-&gt;block)
+	TP_printk("dev %d,%d ino %lu mode 0%o is_metadata %d block %llu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;mode,
+		  __entry-&gt;is_metadata, __entry-&gt;block)
 );
 
 TRACE_EVENT(ext4_da_update_reserve_space,
@@ -861,7 +929,8 @@ TRACE_EVENT(ext4_da_update_reserve_space,
 	TP_ARGS(inode, used_blocks),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	umode_t, mode			)
 		__field(	__u64,	i_blocks		)
@@ -872,7 +941,8 @@ TRACE_EVENT(ext4_da_update_reserve_space,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;mode	= inode-&gt;i_mode;
 		__entry-&gt;i_blocks = inode-&gt;i_blocks;
@@ -882,9 +952,10 @@ TRACE_EVENT(ext4_da_update_reserve_space,
 		__entry-&gt;allocated_meta_blocks = EXT4_I(inode)-&gt;i_allocated_meta_blocks;
 	),
 
-	TP_printk("dev %s ino %lu mode 0%o i_blocks %llu used_blocks %d reserved_data_blocks %d reserved_meta_blocks %d allocated_meta_blocks %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
-		  __entry-&gt;mode,  (unsigned long long) __entry-&gt;i_blocks,
+	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu used_blocks %d reserved_data_blocks %d reserved_meta_blocks %d allocated_meta_blocks %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino, __entry-&gt;mode,
+		  (unsigned long long) __entry-&gt;i_blocks,
 		  __entry-&gt;used_blocks, __entry-&gt;reserved_data_blocks,
 		  __entry-&gt;reserved_meta_blocks, __entry-&gt;allocated_meta_blocks)
 );
@@ -895,7 +966,8 @@ TRACE_EVENT(ext4_da_reserve_space,
 	TP_ARGS(inode, md_needed),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	umode_t, mode			)
 		__field(	__u64,	i_blocks		)
@@ -905,7 +977,8 @@ TRACE_EVENT(ext4_da_reserve_space,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;mode	= inode-&gt;i_mode;
 		__entry-&gt;i_blocks = inode-&gt;i_blocks;
@@ -914,8 +987,9 @@ TRACE_EVENT(ext4_da_reserve_space,
 		__entry-&gt;reserved_meta_blocks = EXT4_I(inode)-&gt;i_reserved_meta_blocks;
 	),
 
-	TP_printk("dev %s ino %lu mode 0%o i_blocks %llu md_needed %d reserved_data_blocks %d reserved_meta_blocks %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu md_needed %d reserved_data_blocks %d reserved_meta_blocks %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;mode, (unsigned long long) __entry-&gt;i_blocks,
 		  __entry-&gt;md_needed, __entry-&gt;reserved_data_blocks,
 		  __entry-&gt;reserved_meta_blocks)
@@ -927,7 +1001,8 @@ TRACE_EVENT(ext4_da_release_space,
 	TP_ARGS(inode, freed_blocks),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 		__field(	umode_t, mode			)
 		__field(	__u64,	i_blocks		)
@@ -938,7 +1013,8 @@ TRACE_EVENT(ext4_da_release_space,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 		__entry-&gt;mode	= inode-&gt;i_mode;
 		__entry-&gt;i_blocks = inode-&gt;i_blocks;
@@ -948,8 +1024,9 @@ TRACE_EVENT(ext4_da_release_space,
 		__entry-&gt;allocated_meta_blocks = EXT4_I(inode)-&gt;i_allocated_meta_blocks;
 	),
 
-	TP_printk("dev %s ino %lu mode 0%o i_blocks %llu freed_blocks %d reserved_data_blocks %d reserved_meta_blocks %d allocated_meta_blocks %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino,
+	TP_printk("dev %d,%d ino %lu mode 0%o i_blocks %llu freed_blocks %d reserved_data_blocks %d reserved_meta_blocks %d allocated_meta_blocks %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino,
 		  __entry-&gt;mode, (unsigned long long) __entry-&gt;i_blocks,
 		  __entry-&gt;freed_blocks, __entry-&gt;reserved_data_blocks,
 		  __entry-&gt;reserved_meta_blocks, __entry-&gt;allocated_meta_blocks)
@@ -961,18 +1038,20 @@ DECLARE_EVENT_CLASS(ext4__bitmap_load,
 	TP_ARGS(sb, group),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	__u32,	group			)
 
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(sb-&gt;s_dev);
 		__entry-&gt;group	= group;
 	),
 
-	TP_printk("dev %s group %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;group)
+	TP_printk("dev %d,%d group %u",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor, __entry-&gt;group)
 );
 
 DEFINE_EVENT(ext4__bitmap_load, ext4_mb_bitmap_load,
diff --git a/include/trace/events/jbd2.h b/include/trace/events/jbd2.h
index bf16545cc977..7447ea9305b5 100644
--- a/include/trace/events/jbd2.h
+++ b/include/trace/events/jbd2.h
@@ -17,17 +17,19 @@ TRACE_EVENT(jbd2_checkpoint,
 	TP_ARGS(journal, result),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,	dev_major		)
+		__field(	int,	dev_minor		)
 		__field(	int,	result			)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= journal-&gt;j_fs_dev-&gt;bd_dev;
+		__entry-&gt;dev_major	= MAJOR(journal-&gt;j_fs_dev-&gt;bd_dev);
+		__entry-&gt;dev_minor	= MINOR(journal-&gt;j_fs_dev-&gt;bd_dev);
 		__entry-&gt;result		= result;
 	),
 
-	TP_printk("dev %s result %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;result)
+	TP_printk("dev %d,%d result %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor, __entry-&gt;result)
 );
 
 DECLARE_EVENT_CLASS(jbd2_commit,
@@ -37,20 +39,22 @@ DECLARE_EVENT_CLASS(jbd2_commit,
 	TP_ARGS(journal, commit_transaction),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	char,	sync_commit		  )
 		__field(	int,	transaction		  )
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= journal-&gt;j_fs_dev-&gt;bd_dev;
+		__entry-&gt;dev_major	= MAJOR(journal-&gt;j_fs_dev-&gt;bd_dev);
+		__entry-&gt;dev_minor	= MINOR(journal-&gt;j_fs_dev-&gt;bd_dev);
 		__entry-&gt;sync_commit = commit_transaction-&gt;t_synchronous_commit;
 		__entry-&gt;transaction	= commit_transaction-&gt;t_tid;
 	),
 
-	TP_printk("dev %s transaction %d sync %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;transaction,
-		  __entry-&gt;sync_commit)
+	TP_printk("dev %d,%d transaction %d sync %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  __entry-&gt;transaction, __entry-&gt;sync_commit)
 );
 
 DEFINE_EVENT(jbd2_commit, jbd2_start_commit,
@@ -87,22 +91,24 @@ TRACE_EVENT(jbd2_end_commit,
 	TP_ARGS(journal, commit_transaction),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	char,	sync_commit		  )
 		__field(	int,	transaction		  )
 		__field(	int,	head		  	  )
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= journal-&gt;j_fs_dev-&gt;bd_dev;
+		__entry-&gt;dev_major	= MAJOR(journal-&gt;j_fs_dev-&gt;bd_dev);
+		__entry-&gt;dev_minor	= MINOR(journal-&gt;j_fs_dev-&gt;bd_dev);
 		__entry-&gt;sync_commit = commit_transaction-&gt;t_synchronous_commit;
 		__entry-&gt;transaction	= commit_transaction-&gt;t_tid;
 		__entry-&gt;head		= journal-&gt;j_tail_sequence;
 	),
 
-	TP_printk("dev %s transaction %d sync %d head %d",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;transaction,
-		  __entry-&gt;sync_commit, __entry-&gt;head)
+	TP_printk("dev %d,%d transaction %d sync %d head %d",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  __entry-&gt;transaction, __entry-&gt;sync_commit, __entry-&gt;head)
 );
 
 TRACE_EVENT(jbd2_submit_inode_data,
@@ -111,17 +117,20 @@ TRACE_EVENT(jbd2_submit_inode_data,
 	TP_ARGS(inode),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	ino_t,	ino			)
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev	= inode-&gt;i_sb-&gt;s_dev;
+		__entry-&gt;dev_major = MAJOR(inode-&gt;i_sb-&gt;s_dev);
+		__entry-&gt;dev_minor = MINOR(inode-&gt;i_sb-&gt;s_dev);
 		__entry-&gt;ino	= inode-&gt;i_ino;
 	),
 
-	TP_printk("dev %s ino %lu",
-		  jbd2_dev_to_name(__entry-&gt;dev), (unsigned long) __entry-&gt;ino)
+	TP_printk("dev %d,%d ino %lu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  (unsigned long) __entry-&gt;ino)
 );
 
 TRACE_EVENT(jbd2_run_stats,
@@ -131,7 +140,8 @@ TRACE_EVENT(jbd2_run_stats,
 	TP_ARGS(dev, tid, stats),
 
 	TP_STRUCT__entry(
-		__field(		dev_t,	dev		)
+		__field(		  int,	dev_major	)
+		__field(		  int,	dev_minor	)
 		__field(	unsigned long,	tid		)
 		__field(	unsigned long,	wait		)
 		__field(	unsigned long,	running		)
@@ -144,7 +154,8 @@ TRACE_EVENT(jbd2_run_stats,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= dev;
+		__entry-&gt;dev_major	= MAJOR(dev);
+		__entry-&gt;dev_minor	= MINOR(dev);
 		__entry-&gt;tid		= tid;
 		__entry-&gt;wait		= stats-&gt;rs_wait;
 		__entry-&gt;running	= stats-&gt;rs_running;
@@ -156,9 +167,9 @@ TRACE_EVENT(jbd2_run_stats,
 		__entry-&gt;blocks_logged	= stats-&gt;rs_blocks_logged;
 	),
 
-	TP_printk("dev %s tid %lu wait %u running %u locked %u flushing %u "
+	TP_printk("dev %d,%d tid %lu wait %u running %u locked %u flushing %u "
 		  "logging %u handle_count %u blocks %u blocks_logged %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;tid,
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor, __entry-&gt;tid,
 		  jiffies_to_msecs(__entry-&gt;wait),
 		  jiffies_to_msecs(__entry-&gt;running),
 		  jiffies_to_msecs(__entry-&gt;locked),
@@ -175,7 +186,8 @@ TRACE_EVENT(jbd2_checkpoint_stats,
 	TP_ARGS(dev, tid, stats),
 
 	TP_STRUCT__entry(
-		__field(		dev_t,	dev		)
+		__field(		  int,	dev_major	)
+		__field(		  int,	dev_minor	)
 		__field(	unsigned long,	tid		)
 		__field(	unsigned long,	chp_time	)
 		__field(		__u32,	forced_to_close	)
@@ -184,7 +196,8 @@ TRACE_EVENT(jbd2_checkpoint_stats,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= dev;
+		__entry-&gt;dev_major	= MAJOR(dev);
+		__entry-&gt;dev_minor	= MINOR(dev);
 		__entry-&gt;tid		= tid;
 		__entry-&gt;chp_time	= stats-&gt;cs_chp_time;
 		__entry-&gt;forced_to_close= stats-&gt;cs_forced_to_close;
@@ -192,9 +205,9 @@ TRACE_EVENT(jbd2_checkpoint_stats,
 		__entry-&gt;dropped	= stats-&gt;cs_dropped;
 	),
 
-	TP_printk("dev %s tid %lu chp_time %u forced_to_close %u "
+	TP_printk("dev %d,%d tid %lu chp_time %u forced_to_close %u "
 		  "written %u dropped %u",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;tid,
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor, __entry-&gt;tid,
 		  jiffies_to_msecs(__entry-&gt;chp_time),
 		  __entry-&gt;forced_to_close, __entry-&gt;written, __entry-&gt;dropped)
 );
@@ -207,7 +220,8 @@ TRACE_EVENT(jbd2_cleanup_journal_tail,
 	TP_ARGS(journal, first_tid, block_nr, freed),
 
 	TP_STRUCT__entry(
-		__field(	dev_t,	dev			)
+		__field(	int,   dev_major                )
+		__field(	int,   dev_minor                )
 		__field(	tid_t,	tail_sequence		)
 		__field(	tid_t,	first_tid		)
 		__field(unsigned long,	block_nr		)
@@ -215,16 +229,18 @@ TRACE_EVENT(jbd2_cleanup_journal_tail,
 	),
 
 	TP_fast_assign(
-		__entry-&gt;dev		= journal-&gt;j_fs_dev-&gt;bd_dev;
+		__entry-&gt;dev_major	= MAJOR(journal-&gt;j_fs_dev-&gt;bd_dev);
+		__entry-&gt;dev_minor	= MINOR(journal-&gt;j_fs_dev-&gt;bd_dev);
 		__entry-&gt;tail_sequence	= journal-&gt;j_tail_sequence;
 		__entry-&gt;first_tid	= first_tid;
 		__entry-&gt;block_nr	= block_nr;
 		__entry-&gt;freed		= freed;
 	),
 
-	TP_printk("dev %s from %u to %u offset %lu freed %lu",
-		  jbd2_dev_to_name(__entry-&gt;dev), __entry-&gt;tail_sequence,
-		  __entry-&gt;first_tid, __entry-&gt;block_nr, __entry-&gt;freed)
+	TP_printk("dev %d,%d from %u to %u offset %lu freed %lu",
+		  __entry-&gt;dev_major, __entry-&gt;dev_minor,
+		  __entry-&gt;tail_sequence, __entry-&gt;first_tid,
+		  __entry-&gt;block_nr, __entry-&gt;freed)
 );
 
 #endif /* _TRACE_JBD2_H */</pre><hr><pre>commit 61d08673de1fe68bfba86203258377bf39f234b6
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 21:30:15 2010 -0400

    ext4: rename mark_bitmap_end() to ext4_mark_bitmap_end()
    
    Fix a namespace leak from fs/ext4
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index a12cefc20c76..14c3af26c671 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -171,7 +171,8 @@ unsigned ext4_init_block_bitmap(struct super_block *sb, struct buffer_head *bh,
 		 * less than the blocksize * 8 ( which is the size
 		 * of bitmap ), set rest of the block bitmap to 1
 		 */
-		mark_bitmap_end(group_blocks, sb-&gt;s_blocksize * 8, bh-&gt;b_data);
+		ext4_mark_bitmap_end(group_blocks, sb-&gt;s_blocksize * 8,
+				     bh-&gt;b_data);
 	}
 	return free_blocks - ext4_group_used_meta_blocks(sb, block_group, gdp);
 }
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index c0570a68a2bc..202668c5607d 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1664,7 +1664,7 @@ extern struct inode * ext4_orphan_get(struct super_block *, unsigned long);
 extern unsigned long ext4_count_free_inodes(struct super_block *);
 extern unsigned long ext4_count_dirs(struct super_block *);
 extern void ext4_check_inodes_bitmap(struct super_block *);
-extern void mark_bitmap_end(int start_bit, int end_bit, char *bitmap);
+extern void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap);
 extern int ext4_init_inode_table(struct super_block *sb,
 				 ext4_group_t group, int barrier);
 
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 9666e4c6efb4..509f429f71e8 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -50,7 +50,7 @@
  * need to use it within a single byte (to ensure we get endianness right).
  * We can use memset for the rest of the bitmap as there are no other users.
  */
-void mark_bitmap_end(int start_bit, int end_bit, char *bitmap)
+void ext4_mark_bitmap_end(int start_bit, int end_bit, char *bitmap)
 {
 	int i;
 
@@ -86,7 +86,7 @@ static unsigned ext4_init_inode_bitmap(struct super_block *sb,
 	}
 
 	memset(bh-&gt;b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8);
-	mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb-&gt;s_blocksize * 8,
+	ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb-&gt;s_blocksize * 8,
 			bh-&gt;b_data);
 
 	return EXT4_INODES_PER_GROUP(sb);
diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index 2f5e347de48b..f398474e2784 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -252,7 +252,8 @@ static int setup_new_group_blocks(struct super_block *sb,
 	if ((err = extend_or_restart_transaction(handle, 2, bh)))
 		goto exit_bh;
 
-	mark_bitmap_end(input-&gt;blocks_count, sb-&gt;s_blocksize * 8, bh-&gt;b_data);
+	ext4_mark_bitmap_end(input-&gt;blocks_count, sb-&gt;s_blocksize * 8,
+			     bh-&gt;b_data);
 	ext4_handle_dirty_metadata(handle, NULL, bh);
 	brelse(bh);
 	/* Mark unused entries in inode bitmap used */
@@ -263,8 +264,8 @@ static int setup_new_group_blocks(struct super_block *sb,
 		goto exit_journal;
 	}
 
-	mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb-&gt;s_blocksize * 8,
-			bh-&gt;b_data);
+	ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb-&gt;s_blocksize * 8,
+			     bh-&gt;b_data);
 	ext4_handle_dirty_metadata(handle, NULL, bh);
 exit_bh:
 	brelse(bh);</pre><hr><pre>commit 4a873a472b3bbcfd425d7ae210afdec28c04e2e5
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 21:30:14 2010 -0400

    ext4: move flush_completed_IO to fs/ext4/fsync.c and make it static
    
    Fix a namespace leak by moving the function to the file where it is
    used and making it static.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index ac1afc148b36..c0570a68a2bc 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1721,7 +1721,6 @@ extern int ext4_block_truncate_page(handle_t *handle,
 		struct address_space *mapping, loff_t from);
 extern int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf);
 extern qsize_t *ext4_get_reserved_space(struct inode *inode);
-extern int flush_completed_IO(struct inode *inode);
 extern void ext4_da_update_reserve_space(struct inode *inode,
 					int used, int quota_claim);
 /* ioctl.c */
diff --git a/fs/ext4/fsync.c b/fs/ext4/fsync.c
index 592adf2e546e..1c701f635961 100644
--- a/fs/ext4/fsync.c
+++ b/fs/ext4/fsync.c
@@ -34,6 +34,89 @@
 
 #include &lt;trace/events/ext4.h&gt;
 
+static void dump_completed_IO(struct inode * inode)
+{
+#ifdef	EXT4_DEBUG
+	struct list_head *cur, *before, *after;
+	ext4_io_end_t *io, *io0, *io1;
+	unsigned long flags;
+
+	if (list_empty(&amp;EXT4_I(inode)-&gt;i_completed_io_list)){
+		ext4_debug("inode %lu completed_io list is empty\n", inode-&gt;i_ino);
+		return;
+	}
+
+	ext4_debug("Dump inode %lu completed_io list \n", inode-&gt;i_ino);
+	spin_lock_irqsave(&amp;EXT4_I(inode)-&gt;i_completed_io_lock, flags);
+	list_for_each_entry(io, &amp;EXT4_I(inode)-&gt;i_completed_io_list, list){
+		cur = &amp;io-&gt;list;
+		before = cur-&gt;prev;
+		io0 = container_of(before, ext4_io_end_t, list);
+		after = cur-&gt;next;
+		io1 = container_of(after, ext4_io_end_t, list);
+
+		ext4_debug("io 0x%p from inode %lu,prev 0x%p,next 0x%p\n",
+			    io, inode-&gt;i_ino, io0, io1);
+	}
+	spin_unlock_irqrestore(&amp;EXT4_I(inode)-&gt;i_completed_io_lock, flags);
+#endif
+}
+
+/*
+ * This function is called from ext4_sync_file().
+ *
+ * When IO is completed, the work to convert unwritten extents to
+ * written is queued on workqueue but may not get immediately
+ * scheduled. When fsync is called, we need to ensure the
+ * conversion is complete before fsync returns.
+ * The inode keeps track of a list of pending/completed IO that
+ * might needs to do the conversion. This function walks through
+ * the list and convert the related unwritten extents for completed IO
+ * to written.
+ * The function return the number of pending IOs on success.
+ */
+static int flush_completed_IO(struct inode *inode)
+{
+	ext4_io_end_t *io;
+	struct ext4_inode_info *ei = EXT4_I(inode);
+	unsigned long flags;
+	int ret = 0;
+	int ret2 = 0;
+
+	if (list_empty(&amp;ei-&gt;i_completed_io_list))
+		return ret;
+
+	dump_completed_IO(inode);
+	spin_lock_irqsave(&amp;ei-&gt;i_completed_io_lock, flags);
+	while (!list_empty(&amp;ei-&gt;i_completed_io_list)){
+		io = list_entry(ei-&gt;i_completed_io_list.next,
+				ext4_io_end_t, list);
+		/*
+		 * Calling ext4_end_io_nolock() to convert completed
+		 * IO to written.
+		 *
+		 * When ext4_sync_file() is called, run_queue() may already
+		 * about to flush the work corresponding to this io structure.
+		 * It will be upset if it founds the io structure related
+		 * to the work-to-be schedule is freed.
+		 *
+		 * Thus we need to keep the io structure still valid here after
+		 * convertion finished. The io structure has a flag to
+		 * avoid double converting from both fsync and background work
+		 * queue work.
+		 */
+		spin_unlock_irqrestore(&amp;ei-&gt;i_completed_io_lock, flags);
+		ret = ext4_end_io_nolock(io);
+		spin_lock_irqsave(&amp;ei-&gt;i_completed_io_lock, flags);
+		if (ret &lt; 0)
+			ret2 = ret;
+		else
+			list_del_init(&amp;io-&gt;list);
+	}
+	spin_unlock_irqrestore(&amp;ei-&gt;i_completed_io_lock, flags);
+	return (ret2 &lt; 0) ? ret2 : 0;
+}
+
 /*
  * If we're not journaling and this is a just-created file, we have to
  * sync our parent directory (if it was freshly created) since
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 7a83c2793956..9e60d0b8fa75 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -3626,89 +3626,6 @@ static int ext4_get_block_write(struct inode *inode, sector_t iblock,
 			       EXT4_GET_BLOCKS_IO_CREATE_EXT);
 }
 
-static void dump_completed_IO(struct inode * inode)
-{
-#ifdef	EXT4_DEBUG
-	struct list_head *cur, *before, *after;
-	ext4_io_end_t *io, *io0, *io1;
-	unsigned long flags;
-
-	if (list_empty(&amp;EXT4_I(inode)-&gt;i_completed_io_list)){
-		ext4_debug("inode %lu completed_io list is empty\n", inode-&gt;i_ino);
-		return;
-	}
-
-	ext4_debug("Dump inode %lu completed_io list \n", inode-&gt;i_ino);
-	spin_lock_irqsave(&amp;EXT4_I(inode)-&gt;i_completed_io_lock, flags);
-	list_for_each_entry(io, &amp;EXT4_I(inode)-&gt;i_completed_io_list, list){
-		cur = &amp;io-&gt;list;
-		before = cur-&gt;prev;
-		io0 = container_of(before, ext4_io_end_t, list);
-		after = cur-&gt;next;
-		io1 = container_of(after, ext4_io_end_t, list);
-
-		ext4_debug("io 0x%p from inode %lu,prev 0x%p,next 0x%p\n",
-			    io, inode-&gt;i_ino, io0, io1);
-	}
-	spin_unlock_irqrestore(&amp;EXT4_I(inode)-&gt;i_completed_io_lock, flags);
-#endif
-}
-
-/*
- * This function is called from ext4_sync_file().
- *
- * When IO is completed, the work to convert unwritten extents to
- * written is queued on workqueue but may not get immediately
- * scheduled. When fsync is called, we need to ensure the
- * conversion is complete before fsync returns.
- * The inode keeps track of a list of pending/completed IO that
- * might needs to do the conversion. This function walks through
- * the list and convert the related unwritten extents for completed IO
- * to written.
- * The function return the number of pending IOs on success.
- */
-int flush_completed_IO(struct inode *inode)
-{
-	ext4_io_end_t *io;
-	struct ext4_inode_info *ei = EXT4_I(inode);
-	unsigned long flags;
-	int ret = 0;
-	int ret2 = 0;
-
-	if (list_empty(&amp;ei-&gt;i_completed_io_list))
-		return ret;
-
-	dump_completed_IO(inode);
-	spin_lock_irqsave(&amp;ei-&gt;i_completed_io_lock, flags);
-	while (!list_empty(&amp;ei-&gt;i_completed_io_list)){
-		io = list_entry(ei-&gt;i_completed_io_list.next,
-				ext4_io_end_t, list);
-		/*
-		 * Calling ext4_end_io_nolock() to convert completed
-		 * IO to written.
-		 *
-		 * When ext4_sync_file() is called, run_queue() may already
-		 * about to flush the work corresponding to this io structure.
-		 * It will be upset if it founds the io structure related
-		 * to the work-to-be schedule is freed.
-		 *
-		 * Thus we need to keep the io structure still valid here after
-		 * convertion finished. The io structure has a flag to
-		 * avoid double converting from both fsync and background work
-		 * queue work.
-		 */
-		spin_unlock_irqrestore(&amp;ei-&gt;i_completed_io_lock, flags);
-		ret = ext4_end_io_nolock(io);
-		spin_lock_irqsave(&amp;ei-&gt;i_completed_io_lock, flags);
-		if (ret &lt; 0)
-			ret2 = ret;
-		else
-			list_del_init(&amp;io-&gt;list);
-	}
-	spin_unlock_irqrestore(&amp;ei-&gt;i_completed_io_lock, flags);
-	return (ret2 &lt; 0) ? ret2 : 0;
-}
-
 static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,
 			    ssize_t size, void *private, int ret,
 			    bool is_async)</pre><hr><pre>commit bf89d16f6ef5389f1b9d8046e838ec87b9b3f8b9
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 21:30:14 2010 -0400

    ext4: rename {ext,idx}_pblock and inline small extent functions
    
    Cleanup namespace leaks from fs/ext4 and the inline trivial functions
    ext4_{ext,idx}_pblock() and ext4_{ext,idx}_store_pblock() since the
    code size actually shrinks when we make these functions inline,
    they're so trivial.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/ext4_extents.h b/fs/ext4/ext4_extents.h
index e427082e9ffc..28ce70fd9cd0 100644
--- a/fs/ext4/ext4_extents.h
+++ b/fs/ext4/ext4_extents.h
@@ -225,11 +225,60 @@ static inline void ext4_ext_mark_initialized(struct ext4_extent *ext)
 	ext-&gt;ee_len = cpu_to_le16(ext4_ext_get_actual_len(ext));
 }
 
+/*
+ * ext4_ext_pblock:
+ * combine low and high parts of physical block number into ext4_fsblk_t
+ */
+static inline ext4_fsblk_t ext4_ext_pblock(struct ext4_extent *ex)
+{
+	ext4_fsblk_t block;
+
+	block = le32_to_cpu(ex-&gt;ee_start_lo);
+	block |= ((ext4_fsblk_t) le16_to_cpu(ex-&gt;ee_start_hi) &lt;&lt; 31) &lt;&lt; 1;
+	return block;
+}
+
+/*
+ * ext4_idx_pblock:
+ * combine low and high parts of a leaf physical block number into ext4_fsblk_t
+ */
+static inline ext4_fsblk_t ext4_idx_pblock(struct ext4_extent_idx *ix)
+{
+	ext4_fsblk_t block;
+
+	block = le32_to_cpu(ix-&gt;ei_leaf_lo);
+	block |= ((ext4_fsblk_t) le16_to_cpu(ix-&gt;ei_leaf_hi) &lt;&lt; 31) &lt;&lt; 1;
+	return block;
+}
+
+/*
+ * ext4_ext_store_pblock:
+ * stores a large physical block number into an extent struct,
+ * breaking it into parts
+ */
+static inline void ext4_ext_store_pblock(struct ext4_extent *ex,
+					 ext4_fsblk_t pb)
+{
+	ex-&gt;ee_start_lo = cpu_to_le32((unsigned long) (pb &amp; 0xffffffff));
+	ex-&gt;ee_start_hi = cpu_to_le16((unsigned long) ((pb &gt;&gt; 31) &gt;&gt; 1) &amp;
+				      0xffff);
+}
+
+/*
+ * ext4_idx_store_pblock:
+ * stores a large physical block number into an index struct,
+ * breaking it into parts
+ */
+static inline void ext4_idx_store_pblock(struct ext4_extent_idx *ix,
+					 ext4_fsblk_t pb)
+{
+	ix-&gt;ei_leaf_lo = cpu_to_le32((unsigned long) (pb &amp; 0xffffffff));
+	ix-&gt;ei_leaf_hi = cpu_to_le16((unsigned long) ((pb &gt;&gt; 31) &gt;&gt; 1) &amp;
+				     0xffff);
+}
+
 extern int ext4_ext_calc_metadata_amount(struct inode *inode,
 					 sector_t lblocks);
-extern ext4_fsblk_t ext_pblock(struct ext4_extent *ex);
-extern ext4_fsblk_t idx_pblock(struct ext4_extent_idx *);
-extern void ext4_ext_store_pblock(struct ext4_extent *, ext4_fsblk_t);
 extern int ext4_extent_tree_init(handle_t *, struct inode *);
 extern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,
 						   int num,
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index bd95375314ab..20e6c3c65fa1 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -44,55 +44,6 @@
 #include "ext4_jbd2.h"
 #include "ext4_extents.h"
 
-
-/*
- * ext_pblock:
- * combine low and high parts of physical block number into ext4_fsblk_t
- */
-ext4_fsblk_t ext_pblock(struct ext4_extent *ex)
-{
-	ext4_fsblk_t block;
-
-	block = le32_to_cpu(ex-&gt;ee_start_lo);
-	block |= ((ext4_fsblk_t) le16_to_cpu(ex-&gt;ee_start_hi) &lt;&lt; 31) &lt;&lt; 1;
-	return block;
-}
-
-/*
- * idx_pblock:
- * combine low and high parts of a leaf physical block number into ext4_fsblk_t
- */
-ext4_fsblk_t idx_pblock(struct ext4_extent_idx *ix)
-{
-	ext4_fsblk_t block;
-
-	block = le32_to_cpu(ix-&gt;ei_leaf_lo);
-	block |= ((ext4_fsblk_t) le16_to_cpu(ix-&gt;ei_leaf_hi) &lt;&lt; 31) &lt;&lt; 1;
-	return block;
-}
-
-/*
- * ext4_ext_store_pblock:
- * stores a large physical block number into an extent struct,
- * breaking it into parts
- */
-void ext4_ext_store_pblock(struct ext4_extent *ex, ext4_fsblk_t pb)
-{
-	ex-&gt;ee_start_lo = cpu_to_le32((unsigned long) (pb &amp; 0xffffffff));
-	ex-&gt;ee_start_hi = cpu_to_le16((unsigned long) ((pb &gt;&gt; 31) &gt;&gt; 1) &amp; 0xffff);
-}
-
-/*
- * ext4_idx_store_pblock:
- * stores a large physical block number into an index struct,
- * breaking it into parts
- */
-static void ext4_idx_store_pblock(struct ext4_extent_idx *ix, ext4_fsblk_t pb)
-{
-	ix-&gt;ei_leaf_lo = cpu_to_le32((unsigned long) (pb &amp; 0xffffffff));
-	ix-&gt;ei_leaf_hi = cpu_to_le16((unsigned long) ((pb &gt;&gt; 31) &gt;&gt; 1) &amp; 0xffff);
-}
-
 static int ext4_ext_truncate_extend_restart(handle_t *handle,
 					    struct inode *inode,
 					    int needed)
@@ -169,7 +120,8 @@ static ext4_fsblk_t ext4_ext_find_goal(struct inode *inode,
 		/* try to predict block placement */
 		ex = path[depth].p_ext;
 		if (ex)
-			return ext_pblock(ex)+(block-le32_to_cpu(ex-&gt;ee_block));
+			return (ext4_ext_pblock(ex) +
+				(block - le32_to_cpu(ex-&gt;ee_block)));
 
 		/* it looks like index is empty;
 		 * try to find starting block from index itself */
@@ -354,7 +306,7 @@ ext4_ext_max_entries(struct inode *inode, int depth)
 
 static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
 {
-	ext4_fsblk_t block = ext_pblock(ext);
+	ext4_fsblk_t block = ext4_ext_pblock(ext);
 	int len = ext4_ext_get_actual_len(ext);
 
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
@@ -363,7 +315,7 @@ static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
 static int ext4_valid_extent_idx(struct inode *inode,
 				struct ext4_extent_idx *ext_idx)
 {
-	ext4_fsblk_t block = idx_pblock(ext_idx);
+	ext4_fsblk_t block = ext4_idx_pblock(ext_idx);
 
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, 1);
 }
@@ -463,13 +415,13 @@ static void ext4_ext_show_path(struct inode *inode, struct ext4_ext_path *path)
 	for (k = 0; k &lt;= l; k++, path++) {
 		if (path-&gt;p_idx) {
 		  ext_debug("  %d-&gt;%llu", le32_to_cpu(path-&gt;p_idx-&gt;ei_block),
-			    idx_pblock(path-&gt;p_idx));
+			    ext4_idx_pblock(path-&gt;p_idx));
 		} else if (path-&gt;p_ext) {
 			ext_debug("  %d:[%d]%d:%llu ",
 				  le32_to_cpu(path-&gt;p_ext-&gt;ee_block),
 				  ext4_ext_is_uninitialized(path-&gt;p_ext),
 				  ext4_ext_get_actual_len(path-&gt;p_ext),
-				  ext_pblock(path-&gt;p_ext));
+				  ext4_ext_pblock(path-&gt;p_ext));
 		} else
 			ext_debug("  []");
 	}
@@ -494,7 +446,7 @@ static void ext4_ext_show_leaf(struct inode *inode, struct ext4_ext_path *path)
 	for (i = 0; i &lt; le16_to_cpu(eh-&gt;eh_entries); i++, ex++) {
 		ext_debug("%d:[%d]%d:%llu ", le32_to_cpu(ex-&gt;ee_block),
 			  ext4_ext_is_uninitialized(ex),
-			  ext4_ext_get_actual_len(ex), ext_pblock(ex));
+			  ext4_ext_get_actual_len(ex), ext4_ext_pblock(ex));
 	}
 	ext_debug("\n");
 }
@@ -545,7 +497,7 @@ ext4_ext_binsearch_idx(struct inode *inode,
 
 	path-&gt;p_idx = l - 1;
 	ext_debug("  -&gt; %d-&gt;%lld ", le32_to_cpu(path-&gt;p_idx-&gt;ei_block),
-		  idx_pblock(path-&gt;p_idx));
+		  ext4_idx_pblock(path-&gt;p_idx));
 
 #ifdef CHECK_BINSEARCH
 	{
@@ -614,7 +566,7 @@ ext4_ext_binsearch(struct inode *inode,
 	path-&gt;p_ext = l - 1;
 	ext_debug("  -&gt; %d:%llu:[%d]%d ",
 			le32_to_cpu(path-&gt;p_ext-&gt;ee_block),
-			ext_pblock(path-&gt;p_ext),
+			ext4_ext_pblock(path-&gt;p_ext),
 			ext4_ext_is_uninitialized(path-&gt;p_ext),
 			ext4_ext_get_actual_len(path-&gt;p_ext));
 
@@ -682,7 +634,7 @@ ext4_ext_find_extent(struct inode *inode, ext4_lblk_t block,
 			  ppos, le16_to_cpu(eh-&gt;eh_entries), le16_to_cpu(eh-&gt;eh_max));
 
 		ext4_ext_binsearch_idx(inode, path + ppos, block);
-		path[ppos].p_block = idx_pblock(path[ppos].p_idx);
+		path[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);
 		path[ppos].p_depth = i;
 		path[ppos].p_ext = NULL;
 
@@ -721,7 +673,7 @@ ext4_ext_find_extent(struct inode *inode, ext4_lblk_t block,
 	ext4_ext_binsearch(inode, path + ppos, block);
 	/* if not an empty leaf */
 	if (path[ppos].p_ext)
-		path[ppos].p_block = ext_pblock(path[ppos].p_ext);
+		path[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);
 
 	ext4_ext_show_path(inode, path);
 
@@ -917,7 +869,7 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 			EXT_MAX_EXTENT(path[depth].p_hdr)) {
 		ext_debug("move %d:%llu:[%d]%d in new leaf %llu\n",
 				le32_to_cpu(path[depth].p_ext-&gt;ee_block),
-				ext_pblock(path[depth].p_ext),
+				ext4_ext_pblock(path[depth].p_ext),
 				ext4_ext_is_uninitialized(path[depth].p_ext),
 				ext4_ext_get_actual_len(path[depth].p_ext),
 				newblock);
@@ -1007,7 +959,7 @@ static int ext4_ext_split(handle_t *handle, struct inode *inode,
 		while (path[i].p_idx &lt;= EXT_MAX_INDEX(path[i].p_hdr)) {
 			ext_debug("%d: move %d:%llu in new index %llu\n", i,
 					le32_to_cpu(path[i].p_idx-&gt;ei_block),
-					idx_pblock(path[i].p_idx),
+					ext4_idx_pblock(path[i].p_idx),
 					newblock);
 			/*memmove(++fidx, path[i].p_idx++,
 					sizeof(struct ext4_extent_idx));
@@ -1146,7 +1098,7 @@ static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,
 	ext_debug("new root: num %d(%d), lblock %d, ptr %llu\n",
 		  le16_to_cpu(neh-&gt;eh_entries), le16_to_cpu(neh-&gt;eh_max),
 		  le32_to_cpu(EXT_FIRST_INDEX(neh)-&gt;ei_block),
-		  idx_pblock(EXT_FIRST_INDEX(neh)));
+		  ext4_idx_pblock(EXT_FIRST_INDEX(neh)));
 
 	neh-&gt;eh_depth = cpu_to_le16(path-&gt;p_depth + 1);
 	err = ext4_ext_dirty(handle, inode, curp);
@@ -1286,7 +1238,7 @@ static int ext4_ext_search_left(struct inode *inode,
 	}
 
 	*logical = le32_to_cpu(ex-&gt;ee_block) + ee_len - 1;
-	*phys = ext_pblock(ex) + ee_len - 1;
+	*phys = ext4_ext_pblock(ex) + ee_len - 1;
 	return 0;
 }
 
@@ -1342,7 +1294,7 @@ static int ext4_ext_search_right(struct inode *inode,
 			}
 		}
 		*logical = le32_to_cpu(ex-&gt;ee_block);
-		*phys = ext_pblock(ex);
+		*phys = ext4_ext_pblock(ex);
 		return 0;
 	}
 
@@ -1357,7 +1309,7 @@ static int ext4_ext_search_right(struct inode *inode,
 		/* next allocated block in this leaf */
 		ex++;
 		*logical = le32_to_cpu(ex-&gt;ee_block);
-		*phys = ext_pblock(ex);
+		*phys = ext4_ext_pblock(ex);
 		return 0;
 	}
 
@@ -1376,7 +1328,7 @@ static int ext4_ext_search_right(struct inode *inode,
 	 * follow it and find the closest allocated
 	 * block to the right */
 	ix++;
-	block = idx_pblock(ix);
+	block = ext4_idx_pblock(ix);
 	while (++depth &lt; path-&gt;p_depth) {
 		bh = sb_bread(inode-&gt;i_sb, block);
 		if (bh == NULL)
@@ -1388,7 +1340,7 @@ static int ext4_ext_search_right(struct inode *inode,
 			return -EIO;
 		}
 		ix = EXT_FIRST_INDEX(eh);
-		block = idx_pblock(ix);
+		block = ext4_idx_pblock(ix);
 		put_bh(bh);
 	}
 
@@ -1402,7 +1354,7 @@ static int ext4_ext_search_right(struct inode *inode,
 	}
 	ex = EXT_FIRST_EXTENT(eh);
 	*logical = le32_to_cpu(ex-&gt;ee_block);
-	*phys = ext_pblock(ex);
+	*phys = ext4_ext_pblock(ex);
 	put_bh(bh);
 	return 0;
 }
@@ -1573,7 +1525,7 @@ ext4_can_extents_be_merged(struct inode *inode, struct ext4_extent *ex1,
 		return 0;
 #endif
 
-	if (ext_pblock(ex1) + ext1_ee_len == ext_pblock(ex2))
+	if (ext4_ext_pblock(ex1) + ext1_ee_len == ext4_ext_pblock(ex2))
 		return 1;
 	return 0;
 }
@@ -1706,11 +1658,12 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,
 	if (ex &amp;&amp; !(flag &amp; EXT4_GET_BLOCKS_PRE_IO)
 		&amp;&amp; ext4_can_extents_be_merged(inode, ex, newext)) {
 		ext_debug("append [%d]%d block to %d:[%d]%d (from %llu)\n",
-				ext4_ext_is_uninitialized(newext),
-				ext4_ext_get_actual_len(newext),
-				le32_to_cpu(ex-&gt;ee_block),
-				ext4_ext_is_uninitialized(ex),
-				ext4_ext_get_actual_len(ex), ext_pblock(ex));
+			  ext4_ext_is_uninitialized(newext),
+			  ext4_ext_get_actual_len(newext),
+			  le32_to_cpu(ex-&gt;ee_block),
+			  ext4_ext_is_uninitialized(ex),
+			  ext4_ext_get_actual_len(ex),
+			  ext4_ext_pblock(ex));
 		err = ext4_ext_get_access(handle, inode, path + depth);
 		if (err)
 			return err;
@@ -1780,7 +1733,7 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,
 		/* there is no extent in this leaf, create first one */
 		ext_debug("first extent in the leaf: %d:%llu:[%d]%d\n",
 				le32_to_cpu(newext-&gt;ee_block),
-				ext_pblock(newext),
+				ext4_ext_pblock(newext),
 				ext4_ext_is_uninitialized(newext),
 				ext4_ext_get_actual_len(newext));
 		path[depth].p_ext = EXT_FIRST_EXTENT(eh);
@@ -1794,7 +1747,7 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,
 			ext_debug("insert %d:%llu:[%d]%d after: nearest 0x%p, "
 					"move %d from 0x%p to 0x%p\n",
 					le32_to_cpu(newext-&gt;ee_block),
-					ext_pblock(newext),
+					ext4_ext_pblock(newext),
 					ext4_ext_is_uninitialized(newext),
 					ext4_ext_get_actual_len(newext),
 					nearex, len, nearex + 1, nearex + 2);
@@ -1808,7 +1761,7 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,
 		ext_debug("insert %d:%llu:[%d]%d before: nearest 0x%p, "
 				"move %d from 0x%p to 0x%p\n",
 				le32_to_cpu(newext-&gt;ee_block),
-				ext_pblock(newext),
+				ext4_ext_pblock(newext),
 				ext4_ext_is_uninitialized(newext),
 				ext4_ext_get_actual_len(newext),
 				nearex, len, nearex + 1, nearex + 2);
@@ -1819,7 +1772,7 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,
 	le16_add_cpu(&amp;eh-&gt;eh_entries, 1);
 	nearex = path[depth].p_ext;
 	nearex-&gt;ee_block = newext-&gt;ee_block;
-	ext4_ext_store_pblock(nearex, ext_pblock(newext));
+	ext4_ext_store_pblock(nearex, ext4_ext_pblock(newext));
 	nearex-&gt;ee_len = newext-&gt;ee_len;
 
 merge:
@@ -1923,7 +1876,7 @@ static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
 		} else {
 			cbex.ec_block = le32_to_cpu(ex-&gt;ee_block);
 			cbex.ec_len = ext4_ext_get_actual_len(ex);
-			cbex.ec_start = ext_pblock(ex);
+			cbex.ec_start = ext4_ext_pblock(ex);
 			cbex.ec_type = EXT4_EXT_CACHE_EXTENT;
 		}
 
@@ -2073,7 +2026,7 @@ static int ext4_ext_rm_idx(handle_t *handle, struct inode *inode,
 
 	/* free index block */
 	path--;
-	leaf = idx_pblock(path-&gt;p_idx);
+	leaf = ext4_idx_pblock(path-&gt;p_idx);
 	if (unlikely(path-&gt;p_hdr-&gt;eh_entries == 0)) {
 		EXT4_ERROR_INODE(inode, "path-&gt;p_hdr-&gt;eh_entries == 0");
 		return -EIO;
@@ -2181,7 +2134,7 @@ static int ext4_remove_blocks(handle_t *handle, struct inode *inode,
 		ext4_fsblk_t start;
 
 		num = le32_to_cpu(ex-&gt;ee_block) + ee_len - from;
-		start = ext_pblock(ex) + ee_len - num;
+		start = ext4_ext_pblock(ex) + ee_len - num;
 		ext_debug("free last %u blocks starting %llu\n", num, start);
 		ext4_free_blocks(handle, inode, 0, start, num, flags);
 	} else if (from == le32_to_cpu(ex-&gt;ee_block)
@@ -2310,7 +2263,7 @@ ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
 			goto out;
 
 		ext_debug("new extent: %u:%u:%llu\n", block, num,
-				ext_pblock(ex));
+				ext4_ext_pblock(ex));
 		ex--;
 		ex_ee_block = le32_to_cpu(ex-&gt;ee_block);
 		ex_ee_len = ext4_ext_get_actual_len(ex);
@@ -2421,9 +2374,9 @@ static int ext4_ext_remove_space(struct inode *inode, ext4_lblk_t start)
 			struct buffer_head *bh;
 			/* go to the next level */
 			ext_debug("move to level %d (block %llu)\n",
-				  i + 1, idx_pblock(path[i].p_idx));
+				  i + 1, ext4_idx_pblock(path[i].p_idx));
 			memset(path + i + 1, 0, sizeof(*path));
-			bh = sb_bread(sb, idx_pblock(path[i].p_idx));
+			bh = sb_bread(sb, ext4_idx_pblock(path[i].p_idx));
 			if (!bh) {
 				/* should we reset i_size? */
 				err = -EIO;
@@ -2543,7 +2496,7 @@ static int ext4_ext_zeroout(struct inode *inode, struct ext4_extent *ex)
 	int ret;
 
 	ee_len    = ext4_ext_get_actual_len(ex);
-	ee_pblock = ext_pblock(ex);
+	ee_pblock = ext4_ext_pblock(ex);
 
 	ret = sb_issue_zeroout(inode-&gt;i_sb, ee_pblock, ee_len,
 			       GFP_NOFS, BLKDEV_IFL_WAIT);
@@ -2596,12 +2549,12 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 	ee_block = le32_to_cpu(ex-&gt;ee_block);
 	ee_len = ext4_ext_get_actual_len(ex);
 	allocated = ee_len - (map-&gt;m_lblk - ee_block);
-	newblock = map-&gt;m_lblk - ee_block + ext_pblock(ex);
+	newblock = map-&gt;m_lblk - ee_block + ext4_ext_pblock(ex);
 
 	ex2 = ex;
 	orig_ex.ee_block = ex-&gt;ee_block;
 	orig_ex.ee_len   = cpu_to_le16(ee_len);
-	ext4_ext_store_pblock(&amp;orig_ex, ext_pblock(ex));
+	ext4_ext_store_pblock(&amp;orig_ex, ext4_ext_pblock(ex));
 
 	/*
 	 * It is safe to convert extent to initialized via explicit
@@ -2620,7 +2573,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 		/* update the extent length and mark as initialized */
 		ex-&gt;ee_block = orig_ex.ee_block;
 		ex-&gt;ee_len   = orig_ex.ee_len;
-		ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+		ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 		ext4_ext_dirty(handle, inode, path + depth);
 		/* zeroed the full extent */
 		return allocated;
@@ -2655,7 +2608,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 			ex-&gt;ee_block = orig_ex.ee_block;
 			ex-&gt;ee_len   = cpu_to_le16(ee_len - allocated);
 			ext4_ext_mark_uninitialized(ex);
-			ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+			ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 			ext4_ext_dirty(handle, inode, path + depth);
 
 			ex3 = &amp;newex;
@@ -2670,7 +2623,8 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 					goto fix_extent_len;
 				ex-&gt;ee_block = orig_ex.ee_block;
 				ex-&gt;ee_len   = orig_ex.ee_len;
-				ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+				ext4_ext_store_pblock(ex,
+					ext4_ext_pblock(&amp;orig_ex));
 				ext4_ext_dirty(handle, inode, path + depth);
 				/* blocks available from map-&gt;m_lblk */
 				return allocated;
@@ -2727,7 +2681,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 			/* update the extent length and mark as initialized */
 			ex-&gt;ee_block = orig_ex.ee_block;
 			ex-&gt;ee_len   = orig_ex.ee_len;
-			ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+			ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 			ext4_ext_dirty(handle, inode, path + depth);
 			/* zeroed the full extent */
 			/* blocks available from map-&gt;m_lblk */
@@ -2778,7 +2732,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 			/* update the extent length and mark as initialized */
 			ex-&gt;ee_block = orig_ex.ee_block;
 			ex-&gt;ee_len   = orig_ex.ee_len;
-			ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+			ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 			ext4_ext_dirty(handle, inode, path + depth);
 			/* zero out the first half */
 			/* blocks available from map-&gt;m_lblk */
@@ -2847,7 +2801,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 		/* update the extent length and mark as initialized */
 		ex-&gt;ee_block = orig_ex.ee_block;
 		ex-&gt;ee_len   = orig_ex.ee_len;
-		ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+		ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 		ext4_ext_dirty(handle, inode, path + depth);
 		/* zero out the first half */
 		return allocated;
@@ -2860,7 +2814,7 @@ static int ext4_ext_convert_to_initialized(handle_t *handle,
 fix_extent_len:
 	ex-&gt;ee_block = orig_ex.ee_block;
 	ex-&gt;ee_len   = orig_ex.ee_len;
-	ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+	ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 	ext4_ext_mark_uninitialized(ex);
 	ext4_ext_dirty(handle, inode, path + depth);
 	return err;
@@ -2918,12 +2872,12 @@ static int ext4_split_unwritten_extents(handle_t *handle,
 	ee_block = le32_to_cpu(ex-&gt;ee_block);
 	ee_len = ext4_ext_get_actual_len(ex);
 	allocated = ee_len - (map-&gt;m_lblk - ee_block);
-	newblock = map-&gt;m_lblk - ee_block + ext_pblock(ex);
+	newblock = map-&gt;m_lblk - ee_block + ext4_ext_pblock(ex);
 
 	ex2 = ex;
 	orig_ex.ee_block = ex-&gt;ee_block;
 	orig_ex.ee_len   = cpu_to_le16(ee_len);
-	ext4_ext_store_pblock(&amp;orig_ex, ext_pblock(ex));
+	ext4_ext_store_pblock(&amp;orig_ex, ext4_ext_pblock(ex));
 
 	/*
 	 * It is safe to convert extent to initialized via explicit
@@ -2972,7 +2926,7 @@ static int ext4_split_unwritten_extents(handle_t *handle,
 			/* update the extent length and mark as initialized */
 			ex-&gt;ee_block = orig_ex.ee_block;
 			ex-&gt;ee_len   = orig_ex.ee_len;
-			ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+			ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 			ext4_ext_dirty(handle, inode, path + depth);
 			/* zeroed the full extent */
 			/* blocks available from map-&gt;m_lblk */
@@ -3044,7 +2998,7 @@ static int ext4_split_unwritten_extents(handle_t *handle,
 		/* update the extent length and mark as initialized */
 		ex-&gt;ee_block = orig_ex.ee_block;
 		ex-&gt;ee_len   = orig_ex.ee_len;
-		ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+		ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 		ext4_ext_dirty(handle, inode, path + depth);
 		/* zero out the first half */
 		return allocated;
@@ -3057,7 +3011,7 @@ static int ext4_split_unwritten_extents(handle_t *handle,
 fix_extent_len:
 	ex-&gt;ee_block = orig_ex.ee_block;
 	ex-&gt;ee_len   = orig_ex.ee_len;
-	ext4_ext_store_pblock(ex, ext_pblock(&amp;orig_ex));
+	ext4_ext_store_pblock(ex, ext4_ext_pblock(&amp;orig_ex));
 	ext4_ext_mark_uninitialized(ex);
 	ext4_ext_dirty(handle, inode, path + depth);
 	return err;
@@ -3347,7 +3301,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 			/* block is already allocated */
 			newblock = map-&gt;m_lblk
 				   - le32_to_cpu(newex.ee_block)
-				   + ext_pblock(&amp;newex);
+				   + ext4_ext_pblock(&amp;newex);
 			/* number of remaining blocks in the extent */
 			allocated = ext4_ext_get_actual_len(&amp;newex) -
 				(map-&gt;m_lblk - le32_to_cpu(newex.ee_block));
@@ -3385,7 +3339,7 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 	ex = path[depth].p_ext;
 	if (ex) {
 		ext4_lblk_t ee_block = le32_to_cpu(ex-&gt;ee_block);
-		ext4_fsblk_t ee_start = ext_pblock(ex);
+		ext4_fsblk_t ee_start = ext4_ext_pblock(ex);
 		unsigned short ee_len;
 
 		/*
@@ -3513,13 +3467,13 @@ int ext4_ext_map_blocks(handle_t *handle, struct inode *inode,
 		/* not a good idea to call discard here directly,
 		 * but otherwise we'd need to call it every free() */
 		ext4_discard_preallocations(inode);
-		ext4_free_blocks(handle, inode, 0, ext_pblock(&amp;newex),
+		ext4_free_blocks(handle, inode, 0, ext4_ext_pblock(&amp;newex),
 				 ext4_ext_get_actual_len(&amp;newex), 0);
 		goto out2;
 	}
 
 	/* previous routine could use block we allocated */
-	newblock = ext_pblock(&amp;newex);
+	newblock = ext4_ext_pblock(&amp;newex);
 	allocated = ext4_ext_get_actual_len(&amp;newex);
 	if (allocated &gt; map-&gt;m_len)
 		allocated = map-&gt;m_len;
diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c
index 1765c2c50a9b..25f3a974b725 100644
--- a/fs/ext4/migrate.c
+++ b/fs/ext4/migrate.c
@@ -412,7 +412,7 @@ static int free_ext_idx(handle_t *handle, struct inode *inode,
 	struct buffer_head *bh;
 	struct ext4_extent_header *eh;
 
-	block = idx_pblock(ix);
+	block = ext4_idx_pblock(ix);
 	bh = sb_bread(inode-&gt;i_sb, block);
 	if (!bh)
 		return -EIO;
diff --git a/fs/ext4/move_extent.c b/fs/ext4/move_extent.c
index 5f1ed9fc913c..b9f3e7862f13 100644
--- a/fs/ext4/move_extent.c
+++ b/fs/ext4/move_extent.c
@@ -85,7 +85,7 @@ mext_next_extent(struct inode *inode, struct ext4_ext_path *path,
 	if (EXT_LAST_EXTENT(path[ppos].p_hdr) &gt; path[ppos].p_ext) {
 		/* leaf block */
 		*extent = ++path[ppos].p_ext;
-		path[ppos].p_block = ext_pblock(path[ppos].p_ext);
+		path[ppos].p_block = ext4_ext_pblock(path[ppos].p_ext);
 		return 0;
 	}
 
@@ -96,7 +96,7 @@ mext_next_extent(struct inode *inode, struct ext4_ext_path *path,
 
 			/* index block */
 			path[ppos].p_idx++;
-			path[ppos].p_block = idx_pblock(path[ppos].p_idx);
+			path[ppos].p_block = ext4_idx_pblock(path[ppos].p_idx);
 			if (path[ppos+1].p_bh)
 				brelse(path[ppos+1].p_bh);
 			path[ppos+1].p_bh =
@@ -111,7 +111,7 @@ mext_next_extent(struct inode *inode, struct ext4_ext_path *path,
 				path[cur_ppos].p_idx =
 					EXT_FIRST_INDEX(path[cur_ppos].p_hdr);
 				path[cur_ppos].p_block =
-					idx_pblock(path[cur_ppos].p_idx);
+					ext4_idx_pblock(path[cur_ppos].p_idx);
 				if (path[cur_ppos+1].p_bh)
 					brelse(path[cur_ppos+1].p_bh);
 				path[cur_ppos+1].p_bh = sb_bread(inode-&gt;i_sb,
@@ -133,7 +133,7 @@ mext_next_extent(struct inode *inode, struct ext4_ext_path *path,
 			path[leaf_ppos].p_ext = *extent =
 				EXT_FIRST_EXTENT(path[leaf_ppos].p_hdr);
 			path[leaf_ppos].p_block =
-					ext_pblock(path[leaf_ppos].p_ext);
+					ext4_ext_pblock(path[leaf_ppos].p_ext);
 			return 0;
 		}
 	}
@@ -249,7 +249,7 @@ mext_insert_across_blocks(handle_t *handle, struct inode *orig_inode,
 			 */
 			o_end-&gt;ee_block = end_ext-&gt;ee_block;
 			o_end-&gt;ee_len = end_ext-&gt;ee_len;
-			ext4_ext_store_pblock(o_end, ext_pblock(end_ext));
+			ext4_ext_store_pblock(o_end, ext4_ext_pblock(end_ext));
 		}
 
 		o_start-&gt;ee_len = start_ext-&gt;ee_len;
@@ -276,7 +276,7 @@ mext_insert_across_blocks(handle_t *handle, struct inode *orig_inode,
 		 */
 		o_end-&gt;ee_block = end_ext-&gt;ee_block;
 		o_end-&gt;ee_len = end_ext-&gt;ee_len;
-		ext4_ext_store_pblock(o_end, ext_pblock(end_ext));
+		ext4_ext_store_pblock(o_end, ext4_ext_pblock(end_ext));
 
 		/*
 		 * Set 0 to the extent block if new_ext was
@@ -361,7 +361,7 @@ mext_insert_inside_block(struct ext4_extent *o_start,
 	/* Insert new entry */
 	if (new_ext-&gt;ee_len) {
 		o_start[i] = *new_ext;
-		ext4_ext_store_pblock(&amp;o_start[i++], ext_pblock(new_ext));
+		ext4_ext_store_pblock(&amp;o_start[i++], ext4_ext_pblock(new_ext));
 	}
 
 	/* Insert end entry */
@@ -488,7 +488,7 @@ mext_leaf_block(handle_t *handle, struct inode *orig_inode,
 	start_ext.ee_len = end_ext.ee_len = 0;
 
 	new_ext.ee_block = cpu_to_le32(*from);
-	ext4_ext_store_pblock(&amp;new_ext, ext_pblock(dext));
+	ext4_ext_store_pblock(&amp;new_ext, ext4_ext_pblock(dext));
 	new_ext.ee_len = dext-&gt;ee_len;
 	new_ext_alen = ext4_ext_get_actual_len(&amp;new_ext);
 	new_ext_end = le32_to_cpu(new_ext.ee_block) + new_ext_alen - 1;
@@ -553,7 +553,7 @@ mext_leaf_block(handle_t *handle, struct inode *orig_inode,
 		copy_extent_status(oext, &amp;end_ext);
 		end_ext_alen = ext4_ext_get_actual_len(&amp;end_ext);
 		ext4_ext_store_pblock(&amp;end_ext,
-			(ext_pblock(o_end) + oext_alen - end_ext_alen));
+			(ext4_ext_pblock(o_end) + oext_alen - end_ext_alen));
 		end_ext.ee_block =
 			cpu_to_le32(le32_to_cpu(o_end-&gt;ee_block) +
 			oext_alen - end_ext_alen);
@@ -604,7 +604,7 @@ mext_calc_swap_extents(struct ext4_extent *tmp_dext,
 	/* When tmp_dext is too large, pick up the target range. */
 	diff = donor_off - le32_to_cpu(tmp_dext-&gt;ee_block);
 
-	ext4_ext_store_pblock(tmp_dext, ext_pblock(tmp_dext) + diff);
+	ext4_ext_store_pblock(tmp_dext, ext4_ext_pblock(tmp_dext) + diff);
 	tmp_dext-&gt;ee_block =
 			cpu_to_le32(le32_to_cpu(tmp_dext-&gt;ee_block) + diff);
 	tmp_dext-&gt;ee_len = cpu_to_le16(le16_to_cpu(tmp_dext-&gt;ee_len) - diff);
@@ -613,7 +613,7 @@ mext_calc_swap_extents(struct ext4_extent *tmp_dext,
 		tmp_dext-&gt;ee_len = cpu_to_le16(max_count);
 
 	orig_diff = orig_off - le32_to_cpu(tmp_oext-&gt;ee_block);
-	ext4_ext_store_pblock(tmp_oext, ext_pblock(tmp_oext) + orig_diff);
+	ext4_ext_store_pblock(tmp_oext, ext4_ext_pblock(tmp_oext) + orig_diff);
 
 	/* Adjust extent length if donor extent is larger than orig */
 	if (ext4_ext_get_actual_len(tmp_dext) &gt;</pre><hr><pre>commit 1f109d5a17b438c4a54cbf6fd87a249e3d72fb21
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 21:30:14 2010 -0400

    ext4: make various ext4 functions be static
    
    These functions have no need to be exported beyond file context.
    
    No functions needed to be moved for this commit; just some function
    declarations changed to be static and removed from header files.
    
    (A similar patch was submitted by Eric Sandeen, but I wanted to handle
    code movement in separate patches to make sure code changes didn't
    accidentally get dropped.)
    
    Signed-off-by: Eric Sandeen &lt;sandeen@redhat.com&gt;
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c
index bd30799a43ed..a12cefc20c76 100644
--- a/fs/ext4/balloc.c
+++ b/fs/ext4/balloc.c
@@ -489,7 +489,7 @@ void ext4_add_groupblocks(handle_t *handle, struct super_block *sb,
  * Check if filesystem has nblocks free &amp; available for allocation.
  * On success return 1, return 0 on failure.
  */
-int ext4_has_free_blocks(struct ext4_sb_info *sbi, s64 nblocks)
+static int ext4_has_free_blocks(struct ext4_sb_info *sbi, s64 nblocks)
 {
 	s64 free_blocks, dirty_blocks, root_blocks;
 	struct percpu_counter *fbc = &amp;sbi-&gt;s_freeblocks_counter;
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 5d72c261d7e9..ac1afc148b36 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1558,8 +1558,6 @@ ext4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)
 void ext4_get_group_no_and_offset(struct super_block *sb, ext4_fsblk_t blocknr,
 			ext4_group_t *blockgrpp, ext4_grpblk_t *offsetp);
 
-extern struct proc_dir_entry *ext4_proc_root;
-
 /*
  * Timeout and state flag for lazy initialization inode thread.
  */
@@ -1623,7 +1621,6 @@ extern unsigned long ext4_bg_num_gdb(struct super_block *sb,
 extern ext4_fsblk_t ext4_new_meta_blocks(handle_t *handle, struct inode *inode,
 			ext4_fsblk_t goal, unsigned long *count, int *errp);
 extern int ext4_claim_free_blocks(struct ext4_sb_info *sbi, s64 nblocks);
-extern int ext4_has_free_blocks(struct ext4_sb_info *sbi, s64 nblocks);
 extern void ext4_add_groupblocks(handle_t *handle, struct super_block *sb,
 				ext4_fsblk_t block, unsigned long count);
 extern ext4_fsblk_t ext4_count_free_blocks(struct super_block *);
@@ -1667,10 +1664,6 @@ extern struct inode * ext4_orphan_get(struct super_block *, unsigned long);
 extern unsigned long ext4_count_free_inodes(struct super_block *);
 extern unsigned long ext4_count_dirs(struct super_block *);
 extern void ext4_check_inodes_bitmap(struct super_block *);
-extern unsigned ext4_init_inode_bitmap(struct super_block *sb,
-				       struct buffer_head *bh,
-				       ext4_group_t group,
-				       struct ext4_group_desc *desc);
 extern void mark_bitmap_end(int start_bit, int end_bit, char *bitmap);
 extern int ext4_init_inode_table(struct super_block *sb,
 				 ext4_group_t group, int barrier);
@@ -1723,7 +1716,6 @@ extern void ext4_get_inode_flags(struct ext4_inode_info *);
 extern int ext4_alloc_da_blocks(struct inode *inode);
 extern void ext4_set_aops(struct inode *inode);
 extern int ext4_writepage_trans_blocks(struct inode *);
-extern int ext4_meta_trans_blocks(struct inode *, int nrblocks, int idxblocks);
 extern int ext4_chunk_trans_blocks(struct inode *, int nrblocks);
 extern int ext4_block_truncate_page(handle_t *handle,
 		struct address_space *mapping, loff_t from);
diff --git a/fs/ext4/ext4_extents.h b/fs/ext4/ext4_extents.h
index bdb6ce7e2eb4..e427082e9ffc 100644
--- a/fs/ext4/ext4_extents.h
+++ b/fs/ext4/ext4_extents.h
@@ -237,19 +237,9 @@ extern int ext4_ext_calc_credits_for_single_extent(struct inode *inode,
 extern int ext4_can_extents_be_merged(struct inode *inode,
 				      struct ext4_extent *ex1,
 				      struct ext4_extent *ex2);
-extern int ext4_ext_try_to_merge(struct inode *inode,
-				 struct ext4_ext_path *path,
-				 struct ext4_extent *);
-extern unsigned int ext4_ext_check_overlap(struct inode *, struct ext4_extent *, struct ext4_ext_path *);
 extern int ext4_ext_insert_extent(handle_t *, struct inode *, struct ext4_ext_path *, struct ext4_extent *, int);
-extern int ext4_ext_walk_space(struct inode *, ext4_lblk_t, ext4_lblk_t,
-							ext_prepare_callback, void *);
 extern struct ext4_ext_path *ext4_ext_find_extent(struct inode *, ext4_lblk_t,
 							struct ext4_ext_path *);
-extern int ext4_ext_search_left(struct inode *, struct ext4_ext_path *,
-						ext4_lblk_t *, ext4_fsblk_t *);
-extern int ext4_ext_search_right(struct inode *, struct ext4_ext_path *,
-						ext4_lblk_t *, ext4_fsblk_t *);
 extern void ext4_ext_drop_refs(struct ext4_ext_path *);
 extern int ext4_ext_check_inode(struct inode *inode);
 #endif /* _EXT4_EXTENTS */
diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index a1e20c8c4e0c..bd95375314ab 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -739,9 +739,9 @@ ext4_ext_find_extent(struct inode *inode, ext4_lblk_t block,
  * insert new index [@logical;@ptr] into the block at @curp;
  * check where to insert: before @curp or after @curp
  */
-int ext4_ext_insert_index(handle_t *handle, struct inode *inode,
-				struct ext4_ext_path *curp,
-				int logical, ext4_fsblk_t ptr)
+static int ext4_ext_insert_index(handle_t *handle, struct inode *inode,
+				 struct ext4_ext_path *curp,
+				 int logical, ext4_fsblk_t ptr)
 {
 	struct ext4_extent_idx *ix;
 	int len, err;
@@ -1232,9 +1232,9 @@ static int ext4_ext_create_new_leaf(handle_t *handle, struct inode *inode,
  * returns 0 at @phys
  * return value contains 0 (success) or error code
  */
-int
-ext4_ext_search_left(struct inode *inode, struct ext4_ext_path *path,
-			ext4_lblk_t *logical, ext4_fsblk_t *phys)
+static int ext4_ext_search_left(struct inode *inode,
+				struct ext4_ext_path *path,
+				ext4_lblk_t *logical, ext4_fsblk_t *phys)
 {
 	struct ext4_extent_idx *ix;
 	struct ext4_extent *ex;
@@ -1297,9 +1297,9 @@ ext4_ext_search_left(struct inode *inode, struct ext4_ext_path *path,
  * returns 0 at @phys
  * return value contains 0 (success) or error code
  */
-int
-ext4_ext_search_right(struct inode *inode, struct ext4_ext_path *path,
-			ext4_lblk_t *logical, ext4_fsblk_t *phys)
+static int ext4_ext_search_right(struct inode *inode,
+				 struct ext4_ext_path *path,
+				 ext4_lblk_t *logical, ext4_fsblk_t *phys)
 {
 	struct buffer_head *bh = NULL;
 	struct ext4_extent_header *eh;
@@ -1585,9 +1585,9 @@ ext4_can_extents_be_merged(struct inode *inode, struct ext4_extent *ex1,
  * Returns 0 if the extents (ex and ex+1) were _not_ merged and returns
  * 1 if they got merged.
  */
-int ext4_ext_try_to_merge(struct inode *inode,
-			  struct ext4_ext_path *path,
-			  struct ext4_extent *ex)
+static int ext4_ext_try_to_merge(struct inode *inode,
+				 struct ext4_ext_path *path,
+				 struct ext4_extent *ex)
 {
 	struct ext4_extent_header *eh;
 	unsigned int depth, len;
@@ -1632,9 +1632,9 @@ int ext4_ext_try_to_merge(struct inode *inode,
  * such that there will be no overlap, and then returns 1.
  * If there is no overlap found, it returns 0.
  */
-unsigned int ext4_ext_check_overlap(struct inode *inode,
-				    struct ext4_extent *newext,
-				    struct ext4_ext_path *path)
+static unsigned int ext4_ext_check_overlap(struct inode *inode,
+					   struct ext4_extent *newext,
+					   struct ext4_ext_path *path)
 {
 	ext4_lblk_t b1, b2;
 	unsigned int depth, len1;
@@ -1845,9 +1845,9 @@ int ext4_ext_insert_extent(handle_t *handle, struct inode *inode,
 	return err;
 }
 
-int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
-			ext4_lblk_t num, ext_prepare_callback func,
-			void *cbdata)
+static int ext4_ext_walk_space(struct inode *inode, ext4_lblk_t block,
+			       ext4_lblk_t num, ext_prepare_callback func,
+			       void *cbdata)
 {
 	struct ext4_ext_path *path = NULL;
 	struct ext4_ext_cache cbex;
diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c
index 87d228aae6b0..9666e4c6efb4 100644
--- a/fs/ext4/ialloc.c
+++ b/fs/ext4/ialloc.c
@@ -65,9 +65,10 @@ void mark_bitmap_end(int start_bit, int end_bit, char *bitmap)
 }
 
 /* Initializes an uninitialized inode bitmap */
-unsigned ext4_init_inode_bitmap(struct super_block *sb, struct buffer_head *bh,
-				ext4_group_t block_group,
-				struct ext4_group_desc *gdp)
+static unsigned ext4_init_inode_bitmap(struct super_block *sb,
+				       struct buffer_head *bh,
+				       ext4_group_t block_group,
+				       struct ext4_group_desc *gdp)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 
@@ -414,8 +415,8 @@ struct orlov_stats {
  * for a particular block group or flex_bg.  If flex_size is 1, then g
  * is a block group number; otherwise it is flex_bg number.
  */
-void get_orlov_stats(struct super_block *sb, ext4_group_t g,
-		       int flex_size, struct orlov_stats *stats)
+static void get_orlov_stats(struct super_block *sb, ext4_group_t g,
+			    int flex_size, struct orlov_stats *stats)
 {
 	struct ext4_group_desc *desc;
 	struct flex_groups *flex_group = EXT4_SB(sb)-&gt;s_flex_groups;
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 45fc5bdb7d67..7a83c2793956 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -5543,7 +5543,7 @@ static int ext4_index_trans_blocks(struct inode *inode, int nrblocks, int chunk)
  *
  * Also account for superblock, inode, quota and xattr blocks
  */
-int ext4_meta_trans_blocks(struct inode *inode, int nrblocks, int chunk)
+static int ext4_meta_trans_blocks(struct inode *inode, int nrblocks, int chunk)
 {
 	ext4_group_t groups, ngroups = ext4_get_groups_count(inode-&gt;i_sb);
 	int gdpblocks;
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 94e60038e05d..158d1bca8769 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -53,7 +53,7 @@
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/ext4.h&gt;
 
-struct proc_dir_entry *ext4_proc_root;
+static struct proc_dir_entry *ext4_proc_root;
 static struct kset *ext4_kset;
 struct ext4_lazy_init *ext4_li_info;
 struct mutex ext4_li_mtx;</pre><hr><pre>commit 5dabfc78dcedbe46cb2e4872dde448de3cec2979
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 21:30:14 2010 -0400

    ext4: rename {exit,init}_ext4_*() to ext4_{exit,init}_*()
    
    This is a cleanup to avoid namespace leaks out of fs/ext4
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/block_validity.c b/fs/ext4/block_validity.c
index 68bab70dd139..fac90f3fba80 100644
--- a/fs/ext4/block_validity.c
+++ b/fs/ext4/block_validity.c
@@ -29,7 +29,7 @@ struct ext4_system_zone {
 
 static struct kmem_cache *ext4_system_zone_cachep;
 
-int __init init_ext4_system_zone(void)
+int __init ext4_init_system_zone(void)
 {
 	ext4_system_zone_cachep = KMEM_CACHE(ext4_system_zone, 0);
 	if (ext4_system_zone_cachep == NULL)
@@ -37,7 +37,7 @@ int __init init_ext4_system_zone(void)
 	return 0;
 }
 
-void exit_ext4_system_zone(void)
+void ext4_exit_system_zone(void)
 {
 	kmem_cache_destroy(ext4_system_zone_cachep);
 }
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 98dde2b7dd6f..5d72c261d7e9 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1684,8 +1684,8 @@ extern ext4_fsblk_t ext4_mb_new_blocks(handle_t *,
 				struct ext4_allocation_request *, int *);
 extern int ext4_mb_reserve_blocks(struct super_block *, int);
 extern void ext4_discard_preallocations(struct inode *);
-extern int __init init_ext4_mballoc(void);
-extern void exit_ext4_mballoc(void);
+extern int __init ext4_init_mballoc(void);
+extern void ext4_exit_mballoc(void);
 extern void ext4_free_blocks(handle_t *handle, struct inode *inode,
 			     struct buffer_head *bh, ext4_fsblk_t block,
 			     unsigned long count, int flags);
@@ -2040,8 +2040,8 @@ extern const struct inode_operations ext4_fast_symlink_inode_operations;
 /* block_validity */
 extern void ext4_release_system_zone(struct super_block *sb);
 extern int ext4_setup_system_zone(struct super_block *sb);
-extern int __init init_ext4_system_zone(void);
-extern void exit_ext4_system_zone(void);
+extern int __init ext4_init_system_zone(void);
+extern void ext4_exit_system_zone(void);
 extern int ext4_data_block_valid(struct ext4_sb_info *sbi,
 				 ext4_fsblk_t start_blk,
 				 unsigned int count);
@@ -2070,8 +2070,8 @@ extern int ext4_move_extents(struct file *o_filp, struct file *d_filp,
 			     __u64 len, __u64 *moved_len);
 
 /* page-io.c */
-extern int __init init_ext4_pageio(void);
-extern void exit_ext4_pageio(void);
+extern int __init ext4_init_pageio(void);
+extern void ext4_exit_pageio(void);
 extern void ext4_free_io_end(ext4_io_end_t *io);
 extern ext4_io_end_t *ext4_init_io_end(struct inode *inode, gfp_t flags);
 extern int ext4_end_io_nolock(ext4_io_end_t *io);
diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c
index e3bcc06b4906..381ac565786a 100644
--- a/fs/ext4/mballoc.c
+++ b/fs/ext4/mballoc.c
@@ -2705,7 +2705,7 @@ static void ext4_remove_debugfs_entry(void)
 
 #endif
 
-int __init init_ext4_mballoc(void)
+int __init ext4_init_mballoc(void)
 {
 	ext4_pspace_cachep = KMEM_CACHE(ext4_prealloc_space,
 					SLAB_RECLAIM_ACCOUNT);
@@ -2730,7 +2730,7 @@ int __init init_ext4_mballoc(void)
 	return 0;
 }
 
-void exit_ext4_mballoc(void)
+void ext4_exit_mballoc(void)
 {
 	int i;
 	/*
diff --git a/fs/ext4/page-io.c b/fs/ext4/page-io.c
index b972ca50f851..46a7d6a9d976 100644
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@ -32,7 +32,7 @@
 
 static struct kmem_cache *io_page_cachep, *io_end_cachep;
 
-int __init init_ext4_pageio(void)
+int __init ext4_init_pageio(void)
 {
 	io_page_cachep = KMEM_CACHE(ext4_io_page, SLAB_RECLAIM_ACCOUNT);
 	if (io_page_cachep == NULL)
@@ -46,7 +46,7 @@ int __init init_ext4_pageio(void)
 	return 0;
 }
 
-void exit_ext4_pageio(void)
+void ext4_exit_pageio(void)
 {
 	kmem_cache_destroy(io_end_cachep);
 	kmem_cache_destroy(io_page_cachep);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index c9e06c647ce8..94e60038e05d 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -4770,15 +4770,15 @@ int __init ext4_init_feat_adverts(void)
 	return ret;
 }
 
-static int __init init_ext4_fs(void)
+static int __init ext4_init_fs(void)
 {
 	int err;
 
 	ext4_check_flag_values();
-	err = init_ext4_pageio();
+	err = ext4_init_pageio();
 	if (err)
 		return err;
-	err = init_ext4_system_zone();
+	err = ext4_init_system_zone();
 	if (err)
 		goto out5;
 	ext4_kset = kset_create_and_add("ext4", NULL, fs_kobj);
@@ -4788,11 +4788,11 @@ static int __init init_ext4_fs(void)
 
 	err = ext4_init_feat_adverts();
 
-	err = init_ext4_mballoc();
+	err = ext4_init_mballoc();
 	if (err)
 		goto out3;
 
-	err = init_ext4_xattr();
+	err = ext4_init_xattr();
 	if (err)
 		goto out2;
 	err = init_inodecache();
@@ -4812,37 +4812,37 @@ static int __init init_ext4_fs(void)
 	unregister_as_ext3();
 	destroy_inodecache();
 out1:
-	exit_ext4_xattr();
+	ext4_exit_xattr();
 out2:
-	exit_ext4_mballoc();
+	ext4_exit_mballoc();
 out3:
 	kfree(ext4_feat);
 	remove_proc_entry("fs/ext4", NULL);
 	kset_unregister(ext4_kset);
 out4:
-	exit_ext4_system_zone();
+	ext4_exit_system_zone();
 out5:
-	exit_ext4_pageio();
+	ext4_exit_pageio();
 	return err;
 }
 
-static void __exit exit_ext4_fs(void)
+static void __exit ext4_exit_fs(void)
 {
 	ext4_destroy_lazyinit_thread();
 	unregister_as_ext2();
 	unregister_as_ext3();
 	unregister_filesystem(&amp;ext4_fs_type);
 	destroy_inodecache();
-	exit_ext4_xattr();
-	exit_ext4_mballoc();
+	ext4_exit_xattr();
+	ext4_exit_mballoc();
 	remove_proc_entry("fs/ext4", NULL);
 	kset_unregister(ext4_kset);
-	exit_ext4_system_zone();
-	exit_ext4_pageio();
+	ext4_exit_system_zone();
+	ext4_exit_pageio();
 }
 
 MODULE_AUTHOR("Remy Card, Stephen Tweedie, Andrew Morton, Andreas Dilger, Theodore Ts'o and others");
 MODULE_DESCRIPTION("Fourth Extended Filesystem");
 MODULE_LICENSE("GPL");
-module_init(init_ext4_fs)
-module_exit(exit_ext4_fs)
+module_init(ext4_init_fs)
+module_exit(ext4_exit_fs)
diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c
index 3a8cd8dff1ad..fa4b899da4b3 100644
--- a/fs/ext4/xattr.c
+++ b/fs/ext4/xattr.c
@@ -1588,7 +1588,7 @@ static void ext4_xattr_rehash(struct ext4_xattr_header *header,
 #undef BLOCK_HASH_SHIFT
 
 int __init
-init_ext4_xattr(void)
+ext4_init_xattr(void)
 {
 	ext4_xattr_cache = mb_cache_create("ext4_xattr", 6);
 	if (!ext4_xattr_cache)
@@ -1597,7 +1597,7 @@ init_ext4_xattr(void)
 }
 
 void
-exit_ext4_xattr(void)
+ext4_exit_xattr(void)
 {
 	if (ext4_xattr_cache)
 		mb_cache_destroy(ext4_xattr_cache);
diff --git a/fs/ext4/xattr.h b/fs/ext4/xattr.h
index 518e96e43905..281dd8353652 100644
--- a/fs/ext4/xattr.h
+++ b/fs/ext4/xattr.h
@@ -83,8 +83,8 @@ extern void ext4_xattr_put_super(struct super_block *);
 extern int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,
 			    struct ext4_inode *raw_inode, handle_t *handle);
 
-extern int init_ext4_xattr(void);
-extern void exit_ext4_xattr(void);
+extern int __init ext4_init_xattr(void);
+extern void ext4_exit_xattr(void);
 
 extern const struct xattr_handler *ext4_xattr_handlers[];
 
@@ -121,14 +121,14 @@ ext4_xattr_put_super(struct super_block *sb)
 {
 }
 
-static inline int
+static __init inline int
 init_ext4_xattr(void)
 {
 	return 0;
 }
 
 static inline void
-exit_ext4_xattr(void)
+ext4_exit_xattr(void)
 {
 }
 </pre><hr><pre>commit 7f93cff90fa9be6ed45f6189e136153d1d8631b0
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Wed Oct 27 21:30:13 2010 -0400

    ext4: fix kernel oops if the journal superblock has a non-zero j_errno
    
    Commit 84061e0 fixed an accounting bug only to introduce the
    possibility of a kernel OOPS if the journal has a non-zero j_errno
    field indicating that the file system had detected a fs inconsistency.
    After the journal replay, if the journal superblock indicates that the
    file system has an error, this indication is transfered to the file
    system and then ext4_commit_super() is called to write this to the
    disk.
    
    But since the percpu counters are now initialized after the journal
    replay, the call to ext4_commit_super() will cause a kernel oops since
    it needs to use the percpu counters the ext4 superblock structure.
    
    The fix is to skip setting the ext4 free block and free inode fields
    if the percpu counter has not been set.
    
    Thanks to Ken Sumrall for reporting and analyzing the root causes of
    this bug.
    
    Addresses-Google-Bug: #3054080
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index 9ce3b67b7269..c9e06c647ce8 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -3964,9 +3964,12 @@ static int ext4_commit_super(struct super_block *sb, int sync)
 	else
 		es-&gt;s_kbytes_written =
 			cpu_to_le64(EXT4_SB(sb)-&gt;s_kbytes_written);
-	ext4_free_blocks_count_set(es, percpu_counter_sum_positive(
+	if (percpu_counter_initialized(&amp;EXT4_SB(sb)-&gt;s_freeblocks_counter))
+		ext4_free_blocks_count_set(es, percpu_counter_sum_positive(
 					&amp;EXT4_SB(sb)-&gt;s_freeblocks_counter));
-	es-&gt;s_free_inodes_count = cpu_to_le32(percpu_counter_sum_positive(
+	if (percpu_counter_initialized(&amp;EXT4_SB(sb)-&gt;s_freeinodes_counter))
+		es-&gt;s_free_inodes_count =
+			cpu_to_le32(percpu_counter_sum_positive(
 					&amp;EXT4_SB(sb)-&gt;s_freeinodes_counter));
 	sb-&gt;s_dirt = 0;
 	BUFFER_TRACE(sbh, "marking dirty");
diff --git a/include/linux/percpu_counter.h b/include/linux/percpu_counter.h
index 8a7d510ffa9c..46f6ba56fa91 100644
--- a/include/linux/percpu_counter.h
+++ b/include/linux/percpu_counter.h
@@ -78,6 +78,11 @@ static inline s64 percpu_counter_read_positive(struct percpu_counter *fbc)
 	return 1;
 }
 
+static inline int percpu_counter_initialized(struct percpu_counter *fbc)
+{
+	return (fbc-&gt;counters != NULL);
+}
+
 #else
 
 struct percpu_counter {
@@ -143,6 +148,11 @@ static inline s64 percpu_counter_sum(struct percpu_counter *fbc)
 	return percpu_counter_read(fbc);
 }
 
+static inline int percpu_counter_initialized(struct percpu_counter *fbc)
+{
+	return 1;
+}
+
 #endif	/* CONFIG_SMP */
 
 static inline void percpu_counter_inc(struct percpu_counter *fbc)</pre>
    <div class="pagination">
        <a href='1_78.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><a href='1_41.html'>41</a><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><span>[79]</span><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_80.html'>Next&gt;&gt;</a>
    <div>
</body>
