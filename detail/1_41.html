<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Massachusetts Institute of Technology</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Massachusetts Institute of Technology</h1>
    <div class="pagination">
        <a href='1_40.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><span>[41]</span><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_42.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit 202ee5df38b33f7ea28286807a0b548b49613194
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Apr 21 14:37:55 2014 -0400

    ext4: add a new spinlock i_raw_lock to protect the ext4's raw inode
    
    To avoid potential data races, use a spinlock which protects the raw
    (on-disk) inode.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 86c2cda208ea..1d08a1b51bdd 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -875,6 +875,8 @@ struct ext4_inode_info {
 	struct inode vfs_inode;
 	struct jbd2_inode *jinode;
 
+	spinlock_t i_raw_lock;	/* protects updates to the raw inode */
+
 	/*
 	 * File creation time. Its function is same as that of
 	 * struct timespec i_{a,c,m}time in the generic inode.
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 7dfbcbba67d5..9b3c52fbe86d 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -4305,12 +4305,15 @@ static int ext4_do_update_inode(handle_t *handle,
 	struct ext4_inode *raw_inode = ext4_raw_inode(iloc);
 	struct ext4_inode_info *ei = EXT4_I(inode);
 	struct buffer_head *bh = iloc-&gt;bh;
+	struct super_block *sb = inode-&gt;i_sb;
 	int err = 0, rc, block;
-	int need_datasync = 0;
+	int need_datasync = 0, set_large_file = 0;
 	uid_t i_uid;
 	gid_t i_gid;
 
-	/* For fields not not tracking in the in-memory inode,
+	spin_lock(&amp;ei-&gt;i_raw_lock);
+
+	/* For fields not tracked in the in-memory inode,
 	 * initialise them to zero for new inodes. */
 	if (ext4_test_inode_state(inode, EXT4_STATE_NEW))
 		memset(raw_inode, 0, EXT4_SB(inode-&gt;i_sb)-&gt;s_inode_size);
@@ -4348,8 +4351,10 @@ static int ext4_do_update_inode(handle_t *handle,
 	EXT4_INODE_SET_XTIME(i_atime, inode, raw_inode);
 	EXT4_EINODE_SET_XTIME(i_crtime, ei, raw_inode);
 
-	if (ext4_inode_blocks_set(handle, raw_inode, ei))
+	if (ext4_inode_blocks_set(handle, raw_inode, ei)) {
+		spin_unlock(&amp;ei-&gt;i_raw_lock);
 		goto out_brelse;
+	}
 	raw_inode-&gt;i_dtime = cpu_to_le32(ei-&gt;i_dtime);
 	raw_inode-&gt;i_flags = cpu_to_le32(ei-&gt;i_flags &amp; 0xFFFFFFFF);
 	if (likely(!test_opt2(inode-&gt;i_sb, HURD_COMPAT)))
@@ -4361,24 +4366,11 @@ static int ext4_do_update_inode(handle_t *handle,
 		need_datasync = 1;
 	}
 	if (ei-&gt;i_disksize &gt; 0x7fffffffULL) {
-		struct super_block *sb = inode-&gt;i_sb;
 		if (!EXT4_HAS_RO_COMPAT_FEATURE(sb,
 				EXT4_FEATURE_RO_COMPAT_LARGE_FILE) ||
 				EXT4_SB(sb)-&gt;s_es-&gt;s_rev_level ==
-				cpu_to_le32(EXT4_GOOD_OLD_REV)) {
-			/* If this is the first large file
-			 * created, add a flag to the superblock.
-			 */
-			err = ext4_journal_get_write_access(handle,
-					EXT4_SB(sb)-&gt;s_sbh);
-			if (err)
-				goto out_brelse;
-			ext4_update_dynamic_rev(sb);
-			EXT4_SET_RO_COMPAT_FEATURE(sb,
-					EXT4_FEATURE_RO_COMPAT_LARGE_FILE);
-			ext4_handle_sync(handle);
-			err = ext4_handle_dirty_super(handle, sb);
-		}
+		    cpu_to_le32(EXT4_GOOD_OLD_REV))
+			set_large_file = 1;
 	}
 	raw_inode-&gt;i_generation = cpu_to_le32(inode-&gt;i_generation);
 	if (S_ISCHR(inode-&gt;i_mode) || S_ISBLK(inode-&gt;i_mode)) {
@@ -4410,12 +4402,23 @@ static int ext4_do_update_inode(handle_t *handle,
 
 	ext4_inode_csum_set(inode, raw_inode, ei);
 
+	spin_unlock(&amp;ei-&gt;i_raw_lock);
+
 	BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
 	rc = ext4_handle_dirty_metadata(handle, NULL, bh);
 	if (!err)
 		err = rc;
 	ext4_clear_inode_state(inode, EXT4_STATE_NEW);
-
+	if (set_large_file) {
+		err = ext4_journal_get_write_access(handle, EXT4_SB(sb)-&gt;s_sbh);
+		if (err)
+			goto out_brelse;
+		ext4_update_dynamic_rev(sb);
+		EXT4_SET_RO_COMPAT_FEATURE(sb,
+					   EXT4_FEATURE_RO_COMPAT_LARGE_FILE);
+		ext4_handle_sync(handle);
+		err = ext4_handle_dirty_super(handle, sb);
+	}
 	ext4_update_inode_fsync_trans(handle, inode, need_datasync);
 out_brelse:
 	brelse(bh);
diff --git a/fs/ext4/super.c b/fs/ext4/super.c
index c4895c195e00..1f8cb1812723 100644
--- a/fs/ext4/super.c
+++ b/fs/ext4/super.c
@@ -879,6 +879,7 @@ static struct inode *ext4_alloc_inode(struct super_block *sb)
 		return NULL;
 
 	ei-&gt;vfs_inode.i_version = 1;
+	spin_lock_init(&amp;ei-&gt;i_raw_lock);
 	INIT_LIST_HEAD(&amp;ei-&gt;i_prealloc_list);
 	spin_lock_init(&amp;ei-&gt;i_prealloc_lock);
 	ext4_es_init_tree(&amp;ei-&gt;i_es_tree);</pre><hr><pre>commit f5ccfe1ddbaf9d923a3ebdadcb1e5e32d83e9c28
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Apr 21 14:37:52 2014 -0400

    ext4: fix locking for O_APPEND writes
    
    Al Viro pointed out that locking for O_APPEND writes was problematic,
    since the location of the write isn't known until after we take the
    i_mutex, which impacts the ext4_unaligned_aio() and s_bitmap_maxbytes
    check.
    
    For O_APPEND always assume that the write is unaligned so call
    ext4_unwritten_wait().  And to solve the second problem, take the
    i_mutex earlier before we start the s_bitmap_maxbytes check.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 3736d9dfe325..7d55a591deba 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -106,17 +106,37 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 
 	BUG_ON(iocb-&gt;ki_pos != pos);
 
+	/*
+	 * Unaligned direct AIO must be serialized; see comment above
+	 * In the case of O_APPEND, assume that we must always serialize
+	 */
+	if (o_direct &amp;&amp;
+	    ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &amp;&amp;
+	    !is_sync_kiocb(iocb) &amp;&amp;
+	    (file-&gt;f_flags &amp; O_APPEND ||
+	     ext4_unaligned_aio(inode, iov, nr_segs, pos))) {
+		aio_mutex = ext4_aio_mutex(inode);
+		mutex_lock(aio_mutex);
+		ext4_unwritten_wait(inode);
+	}
+
+	mutex_lock(&amp;inode-&gt;i_mutex);
+	if (file-&gt;f_flags &amp; O_APPEND)
+		iocb-&gt;ki_pos = pos = i_size_read(inode);
+
 	/*
 	 * If we have encountered a bitmap-format file, the size limit
 	 * is smaller than s_maxbytes, which is for extent-mapped files.
 	 */
-
 	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
 		struct ext4_sb_info *sbi = EXT4_SB(inode-&gt;i_sb);
 
-		if ((pos &gt; sbi-&gt;s_bitmap_maxbytes ||
-		    (pos == sbi-&gt;s_bitmap_maxbytes &amp;&amp; length &gt; 0)))
-			return -EFBIG;
+		if ((pos &gt; sbi-&gt;s_bitmap_maxbytes) ||
+		    (pos == sbi-&gt;s_bitmap_maxbytes &amp;&amp; length &gt; 0)) {
+			mutex_unlock(&amp;inode-&gt;i_mutex);
+			ret = -EFBIG;
+			goto errout;
+		}
 
 		if (pos + length &gt; sbi-&gt;s_bitmap_maxbytes) {
 			nr_segs = iov_shorten((struct iovec *)iov, nr_segs,
@@ -125,16 +145,6 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 	}
 
 	if (o_direct) {
-		/* Unaligned direct AIO must be serialized; see comment above */
-		if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &amp;&amp;
-		    !is_sync_kiocb(iocb) &amp;&amp;
-		    ext4_unaligned_aio(inode, iov, nr_segs, pos)) {
-			aio_mutex = ext4_aio_mutex(inode);
-			mutex_lock(aio_mutex);
-			ext4_unwritten_wait(inode);
-		}
-
-		mutex_lock(&amp;inode-&gt;i_mutex);
 		blk_start_plug(&amp;plug);
 
 		iocb-&gt;private = &amp;overwrite;
@@ -167,8 +177,7 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 			if (err == len &amp;&amp; (map.m_flags &amp; EXT4_MAP_MAPPED))
 				overwrite = 1;
 		}
-	} else
-		mutex_lock(&amp;inode-&gt;i_mutex);
+	}
 
 	ret = __generic_file_aio_write(iocb, iov, nr_segs);
 	mutex_unlock(&amp;inode-&gt;i_mutex);
@@ -183,6 +192,7 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 	if (o_direct)
 		blk_finish_plug(&amp;plug);
 
+errout:
 	if (aio_mutex)
 		mutex_unlock(aio_mutex);
 	return ret;</pre><hr><pre>commit 7ed07ba8c3e6160e0af3adc0f59561de154c4c2e
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Apr 21 14:36:30 2014 -0400

    ext4: factor out common code in ext4_file_write()
    
    This shouldn't change any logic flow; just delete duplicated code.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 20f1c03b6077..3736d9dfe325 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -97,8 +97,9 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 {
 	struct file *file = iocb-&gt;ki_filp;
 	struct inode *inode = file_inode(iocb-&gt;ki_filp);
+	struct mutex *aio_mutex = NULL;
 	struct blk_plug plug;
-	int unaligned_aio = 0;
+	int o_direct = file-&gt;f_flags &amp; O_DIRECT;
 	int overwrite = 0;
 	size_t length = iov_length(iov, nr_segs);
 	ssize_t ret;
@@ -123,15 +124,13 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 		}
 	}
 
-	if (unlikely(iocb-&gt;ki_filp-&gt;f_flags &amp; O_DIRECT)) {
-		if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &amp;&amp;
-		    !is_sync_kiocb(iocb))
-			unaligned_aio = ext4_unaligned_aio(inode, iov,
-							   nr_segs, pos);
-
+	if (o_direct) {
 		/* Unaligned direct AIO must be serialized; see comment above */
-		if (unaligned_aio) {
-			mutex_lock(ext4_aio_mutex(inode));
+		if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &amp;&amp;
+		    !is_sync_kiocb(iocb) &amp;&amp;
+		    ext4_unaligned_aio(inode, iov, nr_segs, pos)) {
+			aio_mutex = ext4_aio_mutex(inode);
+			mutex_lock(aio_mutex);
 			ext4_unwritten_wait(inode);
 		}
 
@@ -141,7 +140,7 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 		iocb-&gt;private = &amp;overwrite;
 
 		/* check whether we do a DIO overwrite or not */
-		if (ext4_should_dioread_nolock(inode) &amp;&amp; !unaligned_aio &amp;&amp;
+		if (ext4_should_dioread_nolock(inode) &amp;&amp; !aio_mutex &amp;&amp;
 		    !file-&gt;f_mapping-&gt;nrpages &amp;&amp; pos + length &lt;= i_size_read(inode)) {
 			struct ext4_map_blocks map;
 			unsigned int blkbits = inode-&gt;i_blkbits;
@@ -168,35 +167,24 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 			if (err == len &amp;&amp; (map.m_flags &amp; EXT4_MAP_MAPPED))
 				overwrite = 1;
 		}
-
-		ret = __generic_file_aio_write(iocb, iov, nr_segs);
-		mutex_unlock(&amp;inode-&gt;i_mutex);
-
-		if (ret &gt; 0) {
-			ssize_t err;
-
-			err = generic_write_sync(file, iocb-&gt;ki_pos - ret, ret);
-			if (err &lt; 0)
-				ret = err;
-		}
-		blk_finish_plug(&amp;plug);
-
-		if (unaligned_aio)
-			mutex_unlock(ext4_aio_mutex(inode));
-	} else {
+	} else
 		mutex_lock(&amp;inode-&gt;i_mutex);
-		ret = __generic_file_aio_write(iocb, iov, nr_segs);
-		mutex_unlock(&amp;inode-&gt;i_mutex);
 
-		if (ret &gt; 0) {
-			ssize_t err;
+	ret = __generic_file_aio_write(iocb, iov, nr_segs);
+	mutex_unlock(&amp;inode-&gt;i_mutex);
 
-			err = generic_write_sync(file, iocb-&gt;ki_pos - ret, ret);
-			if (err &lt; 0)
-				ret = err;
-		}
+	if (ret &gt; 0) {
+		ssize_t err;
+
+		err = generic_write_sync(file, iocb-&gt;ki_pos - ret, ret);
+		if (err &lt; 0)
+			ret = err;
 	}
+	if (o_direct)
+		blk_finish_plug(&amp;plug);
 
+	if (aio_mutex)
+		mutex_unlock(aio_mutex);
 	return ret;
 }
 </pre><hr><pre>commit 8ad2850f44831919f63f0e58d7203e65d5b3914c
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Apr 21 14:26:57 2014 -0400

    ext4: move ext4_file_dio_write() into ext4_file_write()
    
    This commit doesn't actually change anything; it just moves code
    around in preparation for some code simplification work.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 79b77a51a322..20f1c03b6077 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -92,82 +92,15 @@ ext4_unaligned_aio(struct inode *inode, const struct iovec *iov,
 }
 
 static ssize_t
-ext4_file_dio_write(struct kiocb *iocb, const struct iovec *iov,
-		    unsigned long nr_segs, loff_t pos)
+ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
+		unsigned long nr_segs, loff_t pos)
 {
 	struct file *file = iocb-&gt;ki_filp;
-	struct inode *inode = file-&gt;f_mapping-&gt;host;
+	struct inode *inode = file_inode(iocb-&gt;ki_filp);
 	struct blk_plug plug;
 	int unaligned_aio = 0;
-	ssize_t ret;
 	int overwrite = 0;
 	size_t length = iov_length(iov, nr_segs);
-
-	if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &amp;&amp;
-	    !is_sync_kiocb(iocb))
-		unaligned_aio = ext4_unaligned_aio(inode, iov, nr_segs, pos);
-
-	/* Unaligned direct AIO must be serialized; see comment above */
-	if (unaligned_aio) {
-		mutex_lock(ext4_aio_mutex(inode));
-		ext4_unwritten_wait(inode);
-	}
-
-	mutex_lock(&amp;inode-&gt;i_mutex);
-	blk_start_plug(&amp;plug);
-
-	iocb-&gt;private = &amp;overwrite;
-
-	/* check whether we do a DIO overwrite or not */
-	if (ext4_should_dioread_nolock(inode) &amp;&amp; !unaligned_aio &amp;&amp;
-	    !file-&gt;f_mapping-&gt;nrpages &amp;&amp; pos + length &lt;= i_size_read(inode)) {
-		struct ext4_map_blocks map;
-		unsigned int blkbits = inode-&gt;i_blkbits;
-		int err, len;
-
-		map.m_lblk = pos &gt;&gt; blkbits;
-		map.m_len = (EXT4_BLOCK_ALIGN(pos + length, blkbits) &gt;&gt; blkbits)
-			- map.m_lblk;
-		len = map.m_len;
-
-		err = ext4_map_blocks(NULL, inode, &amp;map, 0);
-		/*
-		 * 'err==len' means that all of blocks has been preallocated no
-		 * matter they are initialized or not.  For excluding
-		 * unwritten extents, we need to check m_flags.  There are
-		 * two conditions that indicate for initialized extents.
-		 * 1) If we hit extent cache, EXT4_MAP_MAPPED flag is returned;
-		 * 2) If we do a real lookup, non-flags are returned.
-		 * So we should check these two conditions.
-		 */
-		if (err == len &amp;&amp; (map.m_flags &amp; EXT4_MAP_MAPPED))
-			overwrite = 1;
-	}
-
-	ret = __generic_file_aio_write(iocb, iov, nr_segs);
-	mutex_unlock(&amp;inode-&gt;i_mutex);
-
-	if (ret &gt; 0) {
-		ssize_t err;
-
-		err = generic_write_sync(file, iocb-&gt;ki_pos - ret, ret);
-		if (err &lt; 0)
-			ret = err;
-	}
-	blk_finish_plug(&amp;plug);
-
-	if (unaligned_aio)
-		mutex_unlock(ext4_aio_mutex(inode));
-
-	return ret;
-}
-
-static ssize_t
-ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
-		unsigned long nr_segs, loff_t pos)
-{
-	struct file *file = iocb-&gt;ki_filp;
-	struct inode *inode = file_inode(iocb-&gt;ki_filp);
 	ssize_t ret;
 
 	BUG_ON(iocb-&gt;ki_pos != pos);
@@ -179,7 +112,6 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 
 	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
 		struct ext4_sb_info *sbi = EXT4_SB(inode-&gt;i_sb);
-		size_t length = iov_length(iov, nr_segs);
 
 		if ((pos &gt; sbi-&gt;s_bitmap_maxbytes ||
 		    (pos == sbi-&gt;s_bitmap_maxbytes &amp;&amp; length &gt; 0)))
@@ -191,9 +123,67 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 		}
 	}
 
-	if (unlikely(iocb-&gt;ki_filp-&gt;f_flags &amp; O_DIRECT))
-		ret = ext4_file_dio_write(iocb, iov, nr_segs, pos);
-	else {
+	if (unlikely(iocb-&gt;ki_filp-&gt;f_flags &amp; O_DIRECT)) {
+		if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS) &amp;&amp;
+		    !is_sync_kiocb(iocb))
+			unaligned_aio = ext4_unaligned_aio(inode, iov,
+							   nr_segs, pos);
+
+		/* Unaligned direct AIO must be serialized; see comment above */
+		if (unaligned_aio) {
+			mutex_lock(ext4_aio_mutex(inode));
+			ext4_unwritten_wait(inode);
+		}
+
+		mutex_lock(&amp;inode-&gt;i_mutex);
+		blk_start_plug(&amp;plug);
+
+		iocb-&gt;private = &amp;overwrite;
+
+		/* check whether we do a DIO overwrite or not */
+		if (ext4_should_dioread_nolock(inode) &amp;&amp; !unaligned_aio &amp;&amp;
+		    !file-&gt;f_mapping-&gt;nrpages &amp;&amp; pos + length &lt;= i_size_read(inode)) {
+			struct ext4_map_blocks map;
+			unsigned int blkbits = inode-&gt;i_blkbits;
+			int err, len;
+
+			map.m_lblk = pos &gt;&gt; blkbits;
+			map.m_len = (EXT4_BLOCK_ALIGN(pos + length, blkbits) &gt;&gt; blkbits)
+				- map.m_lblk;
+			len = map.m_len;
+
+			err = ext4_map_blocks(NULL, inode, &amp;map, 0);
+			/*
+			 * 'err==len' means that all of blocks has
+			 * been preallocated no matter they are
+			 * initialized or not.  For excluding
+			 * unwritten extents, we need to check
+			 * m_flags.  There are two conditions that
+			 * indicate for initialized extents.  1) If we
+			 * hit extent cache, EXT4_MAP_MAPPED flag is
+			 * returned; 2) If we do a real lookup,
+			 * non-flags are returned.  So we should check
+			 * these two conditions.
+			 */
+			if (err == len &amp;&amp; (map.m_flags &amp; EXT4_MAP_MAPPED))
+				overwrite = 1;
+		}
+
+		ret = __generic_file_aio_write(iocb, iov, nr_segs);
+		mutex_unlock(&amp;inode-&gt;i_mutex);
+
+		if (ret &gt; 0) {
+			ssize_t err;
+
+			err = generic_write_sync(file, iocb-&gt;ki_pos - ret, ret);
+			if (err &lt; 0)
+				ret = err;
+		}
+		blk_finish_plug(&amp;plug);
+
+		if (unaligned_aio)
+			mutex_unlock(ext4_aio_mutex(inode));
+	} else {
 		mutex_lock(&amp;inode-&gt;i_mutex);
 		ret = __generic_file_aio_write(iocb, iov, nr_segs);
 		mutex_unlock(&amp;inode-&gt;i_mutex);</pre><hr><pre>commit 7608e61044e7636a2ca04ff33fa1ff9697d1df88
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Apr 21 14:26:28 2014 -0400

    ext4: inline generic_file_aio_write() into ext4_file_write()
    
    Copy generic_file_aio_write() into ext4_file_write().  This is part of
    a patch series which allows us to simplify ext4_file_write() and
    ext4_file_dio_write(), by calling __generic_file_aio_write() directly.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Jan Kara &lt;jack@suse.cz&gt;

diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index bf0e772b6a03..79b77a51a322 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -113,8 +113,6 @@ ext4_file_dio_write(struct kiocb *iocb, const struct iovec *iov,
 		ext4_unwritten_wait(inode);
 	}
 
-	BUG_ON(iocb-&gt;ki_pos != pos);
-
 	mutex_lock(&amp;inode-&gt;i_mutex);
 	blk_start_plug(&amp;plug);
 
@@ -168,9 +166,12 @@ static ssize_t
 ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 		unsigned long nr_segs, loff_t pos)
 {
+	struct file *file = iocb-&gt;ki_filp;
 	struct inode *inode = file_inode(iocb-&gt;ki_filp);
 	ssize_t ret;
 
+	BUG_ON(iocb-&gt;ki_pos != pos);
+
 	/*
 	 * If we have encountered a bitmap-format file, the size limit
 	 * is smaller than s_maxbytes, which is for extent-mapped files.
@@ -192,8 +193,19 @@ ext4_file_write(struct kiocb *iocb, const struct iovec *iov,
 
 	if (unlikely(iocb-&gt;ki_filp-&gt;f_flags &amp; O_DIRECT))
 		ret = ext4_file_dio_write(iocb, iov, nr_segs, pos);
-	else
-		ret = generic_file_aio_write(iocb, iov, nr_segs, pos);
+	else {
+		mutex_lock(&amp;inode-&gt;i_mutex);
+		ret = __generic_file_aio_write(iocb, iov, nr_segs);
+		mutex_unlock(&amp;inode-&gt;i_mutex);
+
+		if (ret &gt; 0) {
+			ssize_t err;
+
+			err = generic_write_sync(file, iocb-&gt;ki_pos - ret, ret);
+			if (err &lt; 0)
+				ret = err;
+		}
+	}
 
 	return ret;
 }</pre><hr><pre>commit 86f1ca3889142d5959362c5694db3f3dc26f377a
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri Apr 18 11:52:11 2014 -0400

    ext4: use EINVAL if not a regular file in ext4_collapse_range()
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index 2f49b12a4c40..9b9251adb400 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -5404,7 +5404,7 @@ int ext4_collapse_range(struct inode *inode, loff_t offset, loff_t len)
 		return -EINVAL;
 
 	if (!S_ISREG(inode-&gt;i_mode))
-		return -EOPNOTSUPP;
+		return -EINVAL;
 
 	trace_ext4_collapse_range(inode, offset, len);
 </pre><hr><pre>commit 50e02fd84543d82e663000e780e0ec0cfde52283
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Mon Apr 14 23:37:35 2014 -0400

    ext4: remove temporary shim used to merge COLLAPSE_RANGE and ZERO_RANGE
    
    In retrospect, this was a bad way to handle things, since it limited
    testing of these patches.  We should just get the VFS level changes
    merged in first.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;

diff --git a/include/trace/events/ext4.h b/include/trace/events/ext4.h
index 010ea89eeb0e..6a1a0245474f 100644
--- a/include/trace/events/ext4.h
+++ b/include/trace/events/ext4.h
@@ -16,15 +16,6 @@ struct mpage_da_data;
 struct ext4_map_blocks;
 struct extent_status;
 
-/* shim until we merge in the xfs_collapse_range branch */
-#ifndef FALLOC_FL_COLLAPSE_RANGE
-#define FALLOC_FL_COLLAPSE_RANGE	0x08
-#endif
-
-#ifndef FALLOC_FL_ZERO_RANGE
-#define FALLOC_FL_ZERO_RANGE           0x10
-#endif
-
 #define EXT4_I(inode) (container_of(inode, struct ext4_inode_info, vfs_inode))
 
 #define show_mballoc_flags(flags) __print_flags(flags, "|",	\</pre><hr><pre>commit 40c406c74eb9eed58ae7d4d12a0197f7279c9499
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Apr 12 22:53:53 2014 -0400

    ext4: COLLAPSE_RANGE only works on extent-based files
    
    Unfortunately, we weren't checking to make sure of this the inode was
    extent-based before attempt operate on it.  Hilarity ensues.
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: Namjae Jeon &lt;namjae.jeon@samsung.com&gt;

diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c
index f24ef8697609..96e0a4bc8faa 100644
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@ -4878,9 +4878,6 @@ long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)
 	if (mode &amp; FALLOC_FL_PUNCH_HOLE)
 		return ext4_punch_hole(inode, offset, len);
 
-	if (mode &amp; FALLOC_FL_COLLAPSE_RANGE)
-		return ext4_collapse_range(inode, offset, len);
-
 	ret = ext4_convert_inline_data(inode);
 	if (ret)
 		return ret;
@@ -4892,6 +4889,9 @@ long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)
 	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))
 		return -EOPNOTSUPP;
 
+	if (mode &amp; FALLOC_FL_COLLAPSE_RANGE)
+		return ext4_collapse_range(inode, offset, len);
+
 	if (mode &amp; FALLOC_FL_ZERO_RANGE)
 		return ext4_zero_range(file, offset, len, mode);
 </pre><hr><pre>commit 6e6358fc3c3c862bfe9a5bc029d3f8ce43dc9765
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Sat Apr 12 12:45:25 2014 -0400

    ext4: use i_size_read in ext4_unaligned_aio()
    
    We haven't taken i_mutex yet, so we need to use i_size_read().
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/file.c b/fs/ext4/file.c
index 6db7f7db7777..bc765591101a 100644
--- a/fs/ext4/file.c
+++ b/fs/ext4/file.c
@@ -82,7 +82,7 @@ ext4_unaligned_aio(struct inode *inode, const struct iovec *iov,
 	size_t count = iov_length(iov, nr_segs);
 	loff_t final_size = pos + count;
 
-	if (pos &gt;= inode-&gt;i_size)
+	if (pos &gt;= i_size_read(inode))
 		return 0;
 
 	if ((pos &amp; blockmask) || (final_size &amp; blockmask))</pre><hr><pre>commit 622cad1325e404598fe3b148c3fa640dbaabc235
Author: Theodore Ts'o &lt;tytso@mit.edu&gt;
Date:   Fri Apr 11 10:35:17 2014 -0400

    ext4: move ext4_update_i_disksize() into mpage_map_and_submit_extent()
    
    The function ext4_update_i_disksize() is used in only one place, in
    the function mpage_map_and_submit_extent().  Move its code to simplify
    the code paths, and also move the call to ext4_mark_inode_dirty() into
    the i_data_sem's critical region, to be consistent with all of the
    other places where we update i_disksize.  That way, we also keep the
    raw_inode's i_disksize protected, to avoid the following race:
    
          CPU #1                                 CPU #2
    
       down_write(&amp;i_data_sem)
       Modify i_disk_size
       up_write(&amp;i_data_sem)
                                            down_write(&amp;i_data_sem)
                                            Modify i_disk_size
                                            Copy i_disk_size to on-disk inode
                                            up_write(&amp;i_data_sem)
       Copy i_disk_size to on-disk inode
    
    Signed-off-by: "Theodore Ts'o" &lt;tytso@mit.edu&gt;
    Reviewed-by: Jan Kara &lt;jack@suse.cz&gt;
    Cc: stable@vger.kernel.org

diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index f1c65dc7cc0a..66946aa62127 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -2466,23 +2466,6 @@ static inline void ext4_update_i_disksize(struct inode *inode, loff_t newsize)
 	up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
 }
 
-/*
- * Update i_disksize after writeback has been started. Races with truncate
- * are avoided by checking i_size under i_data_sem.
- */
-static inline void ext4_wb_update_i_disksize(struct inode *inode, loff_t newsize)
-{
-	loff_t i_size;
-
-	down_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
-	i_size = i_size_read(inode);
-	if (newsize &gt; i_size)
-		newsize = i_size;
-	if (newsize &gt; EXT4_I(inode)-&gt;i_disksize)
-		EXT4_I(inode)-&gt;i_disksize = newsize;
-	up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
-}
-
 struct ext4_group_info {
 	unsigned long   bb_state;
 	struct rb_root  bb_free_root;
diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c
index 7b93df9aa182..f023f0cb46fc 100644
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@ -2247,13 +2247,23 @@ static int mpage_map_and_submit_extent(handle_t *handle,
 			return err;
 	} while (map-&gt;m_len);
 
-	/* Update on-disk size after IO is submitted */
+	/*
+	 * Update on-disk size after IO is submitted.  Races with
+	 * truncate are avoided by checking i_size under i_data_sem.
+	 */
 	disksize = ((loff_t)mpd-&gt;first_page) &lt;&lt; PAGE_CACHE_SHIFT;
 	if (disksize &gt; EXT4_I(inode)-&gt;i_disksize) {
 		int err2;
-
-		ext4_wb_update_i_disksize(inode, disksize);
+		loff_t i_size;
+
+		down_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
+		i_size = i_size_read(inode);
+		if (disksize &gt; i_size)
+			disksize = i_size;
+		if (disksize &gt; EXT4_I(inode)-&gt;i_disksize)
+			EXT4_I(inode)-&gt;i_disksize = disksize;
 		err2 = ext4_mark_inode_dirty(handle, inode);
+		up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
 		if (err2)
 			ext4_error(inode-&gt;i_sb,
 				   "Failed to mark inode %lu dirty",</pre>
    <div class="pagination">
        <a href='1_40.html'>&lt;&lt;Prev</a><a href='1.html'>1</a><a href='1_2.html'>2</a><a href='1_3.html'>3</a><a href='1_4.html'>4</a><a href='1_5.html'>5</a><a href='1_6.html'>6</a><a href='1_7.html'>7</a><a href='1_8.html'>8</a><a href='1_9.html'>9</a><a href='1_10.html'>10</a><a href='1_11.html'>11</a><a href='1_12.html'>12</a><a href='1_13.html'>13</a><a href='1_14.html'>14</a><a href='1_15.html'>15</a><a href='1_16.html'>16</a><a href='1_17.html'>17</a><a href='1_18.html'>18</a><a href='1_19.html'>19</a><a href='1_20.html'>20</a><a href='1_21.html'>21</a><a href='1_22.html'>22</a><a href='1_23.html'>23</a><a href='1_24.html'>24</a><a href='1_25.html'>25</a><a href='1_26.html'>26</a><a href='1_27.html'>27</a><a href='1_28.html'>28</a><a href='1_29.html'>29</a><a href='1_30.html'>30</a><a href='1_31.html'>31</a><a href='1_32.html'>32</a><a href='1_33.html'>33</a><a href='1_34.html'>34</a><a href='1_35.html'>35</a><a href='1_36.html'>36</a><a href='1_37.html'>37</a><a href='1_38.html'>38</a><a href='1_39.html'>39</a><a href='1_40.html'>40</a><span>[41]</span><a href='1_42.html'>42</a><a href='1_43.html'>43</a><a href='1_44.html'>44</a><a href='1_45.html'>45</a><a href='1_46.html'>46</a><a href='1_47.html'>47</a><a href='1_48.html'>48</a><a href='1_49.html'>49</a><a href='1_50.html'>50</a><a href='1_51.html'>51</a><a href='1_52.html'>52</a><a href='1_53.html'>53</a><a href='1_54.html'>54</a><a href='1_55.html'>55</a><a href='1_56.html'>56</a><a href='1_57.html'>57</a><a href='1_58.html'>58</a><a href='1_59.html'>59</a><a href='1_60.html'>60</a><a href='1_61.html'>61</a><a href='1_62.html'>62</a><a href='1_63.html'>63</a><a href='1_64.html'>64</a><a href='1_65.html'>65</a><a href='1_66.html'>66</a><a href='1_67.html'>67</a><a href='1_68.html'>68</a><a href='1_69.html'>69</a><a href='1_70.html'>70</a><a href='1_71.html'>71</a><a href='1_72.html'>72</a><a href='1_73.html'>73</a><a href='1_74.html'>74</a><a href='1_75.html'>75</a><a href='1_76.html'>76</a><a href='1_77.html'>77</a><a href='1_78.html'>78</a><a href='1_79.html'>79</a><a href='1_80.html'>80</a><a href='1_81.html'>81</a><a href='1_82.html'>82</a><a href='1_83.html'>83</a><a href='1_84.html'>84</a><a href='1_85.html'>85</a><a href='1_86.html'>86</a><a href='1_87.html'>87</a><a href='1_88.html'>88</a><a href='1_89.html'>89</a><a href='1_90.html'>90</a><a href='1_91.html'>91</a><a href='1_92.html'>92</a><a href='1_93.html'>93</a><a href='1_94.html'>94</a><a href='1_95.html'>95</a><a href='1_96.html'>96</a><a href='1_97.html'>97</a><a href='1_98.html'>98</a><a href='1_99.html'>99</a><a href='1_100.html'>100</a><a href='1_101.html'>101</a><a href='1_102.html'>102</a><a href='1_103.html'>103</a><a href='1_104.html'>104</a><a href='1_105.html'>105</a><a href='1_106.html'>106</a><a href='1_107.html'>107</a><a href='1_108.html'>108</a><a href='1_109.html'>109</a><a href='1_110.html'>110</a><a href='1_111.html'>111</a><a href='1_112.html'>112</a><a href='1_113.html'>113</a><a href='1_114.html'>114</a><a href='1_115.html'>115</a><a href='1_116.html'>116</a><a href='1_117.html'>117</a><a href='1_118.html'>118</a><a href='1_119.html'>119</a><a href='1_120.html'>120</a><a href='1_121.html'>121</a><a href='1_122.html'>122</a><a href='1_123.html'>123</a><a href='1_124.html'>124</a><a href='1_125.html'>125</a><a href='1_126.html'>126</a><a href='1_127.html'>127</a><a href='1_128.html'>128</a><a href='1_129.html'>129</a><a href='1_130.html'>130</a><a href='1_131.html'>131</a><a href='1_132.html'>132</a><a href='1_133.html'>133</a><a href='1_134.html'>134</a><a href='1_135.html'>135</a><a href='1_136.html'>136</a><a href='1_137.html'>137</a><a href='1_138.html'>138</a><a href='1_139.html'>139</a><a href='1_140.html'>140</a><a href='1_141.html'>141</a><a href='1_142.html'>142</a><a href='1_143.html'>143</a><a href='1_144.html'>144</a><a href='1_145.html'>145</a><a href='1_146.html'>146</a><a href='1_147.html'>147</a><a href='1_148.html'>148</a><a href='1_149.html'>149</a><a href='1_150.html'>150</a><a href='1_151.html'>151</a><a href='1_152.html'>152</a><a href='1_153.html'>153</a><a href='1_154.html'>154</a><a href='1_42.html'>Next&gt;&gt;</a>
    <div>
</body>
