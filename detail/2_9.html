<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Harvard University</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Harvard University</h1>
    <div class="pagination">
        <a href='2_8.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><span>[9]</span><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_10.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit afaa2e745a246c5ab95103a65b1ed00101e1bc63
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Nov 2 09:58:21 2020 -0500

    USB: Add NO_LPM quirk for Kingston flash drive
    
    In Bugzilla #208257, Julien Humbert reports that a 32-GB Kingston
    flash drive spontaneously disconnects and reconnects, over and over.
    Testing revealed that disabling Link Power Management for the drive
    fixed the problem.
    
    This patch adds a quirk entry for that drive to turn off LPM permanently.
    
    CC: Hans de Goede &lt;jwrdegoede@fedoraproject.org&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Reported-and-tested-by: Julien Humbert &lt;julroy67@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20201102145821.GA1478741@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index 10574fa3f927..a1e3a037a289 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -378,6 +378,9 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
 
+	/* Kingston DataTraveler 3.0 */
+	{ USB_DEVICE(0x0951, 0x1666), .driver_info = USB_QUIRK_NO_LPM },
+
 	/* X-Rite/Gretag-Macbeth Eye-One Pro display colorimeter */
 	{ USB_DEVICE(0x0971, 0x2000), .driver_info = USB_QUIRK_NO_SET_INTF },
 </pre><hr><pre>commit 9270e1a744f8ed953009b0e94b26ed0912d9ec1c
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Sat Oct 3 21:40:22 2020 -0400

    tools: memory-model: Document that the LKMM can easily miss control dependencies
    
    Add a small section to the litmus-tests.txt documentation file for
    the Linux Kernel Memory Model explaining that the memory model often
    fails to recognize certain control dependencies.
    
    Suggested-by: Akira Yokosawa &lt;akiyks@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Reviewed-by: Joel Fernandes (Google) &lt;joel@joelfernandes.org&gt;
    Signed-off-by: Paul E. McKenney &lt;paulmck@kernel.org&gt;

diff --git a/tools/memory-model/Documentation/litmus-tests.txt b/tools/memory-model/Documentation/litmus-tests.txt
index 2f840dcd15cf..8a9d5d2787f9 100644
--- a/tools/memory-model/Documentation/litmus-tests.txt
+++ b/tools/memory-model/Documentation/litmus-tests.txt
@@ -946,6 +946,23 @@ Limitations of the Linux-kernel memory model (LKMM) include:
 	carrying a dependency, then the compiler can break that dependency
 	by substituting a constant of that value.
 
+	Conversely, LKMM sometimes doesn't recognize that a particular
+	optimization is not allowed, and as a result, thinks that a
+	dependency is not present (because the optimization would break it).
+	The memory model misses some pretty obvious control dependencies
+	because of this limitation.  A simple example is:
+
+		r1 = READ_ONCE(x);
+		if (r1 == 0)
+			smp_mb();
+		WRITE_ONCE(y, 1);
+
+	There is a control dependency from the READ_ONCE to the WRITE_ONCE,
+	even when r1 is nonzero, but LKMM doesn't realize this and thinks
+	that the write may execute before the read if r1 != 0.  (Yes, that
+	doesn't make sense if you think about it, but the memory model's
+	intelligence is limited.)
+
 2.	Multiple access sizes for a single variable are not supported,
 	and neither are misaligned or partially overlapping accesses.
 </pre><hr><pre>commit fb6f076d543414cec709401ec65e5f8e6985d77a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 28 11:22:17 2020 -0400

    USB: hub: Add Kconfig option to reduce number of port initialization retries
    
    Description based on one by Yasushi Asano:
    
    According to 6.7.22 A-UUT “Device No Response” for connection timeout
    of USB OTG and EH automated compliance plan v1.2, enumeration failure
    has to be detected within 30 seconds.  However, the old and new
    enumeration schemes each make a total of 12 attempts, and each attempt
    can take 5 seconds to time out, so the PET test fails.
    
    This patch adds a new Kconfig option (CONFIG_USB_FEW_INIT_RETRIES);
    when the option is set all the initialization retry loops except the
    outermost are reduced to a single iteration.  This reduces the total
    number of attempts to four, allowing Linux hosts to pass the PET test.
    
    The new option is disabled by default to preserve the existing
    behavior.  The reduced number of retries may fail to initialize a few
    devices that currently do work, but for the most part there should be
    no change.  And in cases where the initialization does fail, it will
    fail much more quickly.
    
    Reported-and-tested-by: yasushi asano &lt;yazzep@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20200928152217.GB134701@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/Kconfig b/drivers/usb/core/Kconfig
index dfacc478a8fc..351ede4b5de2 100644
--- a/drivers/usb/core/Kconfig
+++ b/drivers/usb/core/Kconfig
@@ -32,6 +32,20 @@ config USB_DEFAULT_PERSIST
 	  If you have any questions about this, say Y here, only say N
 	  if you know exactly what you are doing.
 
+config USB_FEW_INIT_RETRIES
+	bool "Limit USB device initialization to only a few retries"
+	help
+	  When a new USB device is detected, the kernel tries very hard
+	  to initialize and enumerate it, with lots of nested retry loops.
+	  This almost always works, but when it fails it can take a long time.
+	  This option tells the kernel to make only a few retry attempts,
+	  so that the total time required for a failed initialization is
+	  no more than 30 seconds (as required by the USB OTG spec).
+
+	  Say N here unless you require new-device enumeration failure to
+	  occur within 30 seconds (as might be needed in an embedded
+	  application).
+
 config USB_DYNAMIC_MINORS
 	bool "Dynamic USB minor allocation"
 	help
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 70eaf4ab236f..17202b2ee063 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2705,10 +2705,20 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 }
 
 
+#ifdef CONFIG_USB_FEW_INIT_RETRIES
+#define PORT_RESET_TRIES	2
+#define SET_ADDRESS_TRIES	1
+#define GET_DESCRIPTOR_TRIES	1
+#define GET_MAXPACKET0_TRIES	1
+#define PORT_INIT_TRIES		4
+
+#else
 #define PORT_RESET_TRIES	5
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
+#define GET_MAXPACKET0_TRIES	3
 #define PORT_INIT_TRIES		4
+#endif	/* CONFIG_USB_FEW_INIT_RETRIES */
 
 #define HUB_ROOT_RESET_TIME	60	/* times are in msec */
 #define HUB_SHORT_RESET_TIME	10
@@ -4691,7 +4701,8 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 			 * 255 is for WUSB devices, we actually need to use
 			 * 512 (WUSB1.0[4.8.1]).
 			 */
-			for (operations = 0; operations &lt; 3; ++operations) {
+			for (operations = 0; operations &lt; GET_MAXPACKET0_TRIES;
+					++operations) {
 				buf-&gt;bMaxPacketSize0 = 0;
 				r = usb_control_msg(udev, usb_rcvaddr0pipe(),
 					USB_REQ_GET_DESCRIPTOR, USB_DIR_IN,</pre><hr><pre>commit 19502e6911e4ef4a036344eed36274bb18225033
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Sep 28 11:20:50 2020 -0400

    USB: hub: Clean up use of port initialization schemes and retries
    
    The SET_CONFIG_TRIES macro in hub.c is badly named; it controls the
    number of port-initialization retry attempts rather than the number of
    Set-Configuration attempts.  Furthermore, the USE_NEW_SCHEME macro and
    use_new_scheme() function are written in a very confusing manner,
    making it almost impossible to figure out exactly what they do or
    check that they are correct.
    
    This patch renames SET_CONFIG_TRIES to PORT_INIT_TRIES, removes
    USE_NEW_SCHEME entirely, and rewrites use_new_scheme() to be much more
    transparent, with added comments explaining how it works.  The patch
    also pulls the single call site of use_new_scheme() out from the
    Get-Descriptor retry loop (where it returns the same value each time)
    and renames the local variable used to store the result.
    
    The overall effect is a minor cleanup.  However, there is one
    functional change: If the "use_both_schemes" module parameter isn't
    set (by default it is set), the existing code does only two retry
    iterations.  After this patch it will always perform four, regardless
    of the parameter's value.
    
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Link: https://lore.kernel.org/r/20200928152050.GA134701@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index 5b768b80d1ee..70eaf4ab236f 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -2708,8 +2708,7 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 #define PORT_RESET_TRIES	5
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
-#define SET_CONFIG_TRIES	(2 * (use_both_schemes + 1))
-#define USE_NEW_SCHEME(i, scheme)	((i) / 2 == (int)(scheme))
+#define PORT_INIT_TRIES		4
 
 #define HUB_ROOT_RESET_TIME	60	/* times are in msec */
 #define HUB_SHORT_RESET_TIME	10
@@ -2717,23 +2716,31 @@ static unsigned hub_is_wusb(struct usb_hub *hub)
 #define HUB_LONG_RESET_TIME	200
 #define HUB_RESET_TIMEOUT	800
 
-/*
- * "New scheme" enumeration causes an extra state transition to be
- * exposed to an xhci host and causes USB3 devices to receive control
- * commands in the default state.  This has been seen to cause
- * enumeration failures, so disable this enumeration scheme for USB3
- * devices.
- */
 static bool use_new_scheme(struct usb_device *udev, int retry,
 			   struct usb_port *port_dev)
 {
 	int old_scheme_first_port =
-		port_dev-&gt;quirks &amp; USB_PORT_QUIRK_OLD_SCHEME;
+		(port_dev-&gt;quirks &amp; USB_PORT_QUIRK_OLD_SCHEME) ||
+		old_scheme_first;
 
+	/*
+	 * "New scheme" enumeration causes an extra state transition to be
+	 * exposed to an xhci host and causes USB3 devices to receive control
+	 * commands in the default state.  This has been seen to cause
+	 * enumeration failures, so disable this enumeration scheme for USB3
+	 * devices.
+	 */
 	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)
 		return false;
 
-	return USE_NEW_SCHEME(retry, old_scheme_first_port || old_scheme_first);
+	/*
+	 * If use_both_schemes is set, use the first scheme (whichever
+	 * it is) for the larger half of the retries, then use the other
+	 * scheme.  Otherwise, use the first scheme for all the retries.
+	 */
+	if (use_both_schemes &amp;&amp; retry &gt;= (PORT_INIT_TRIES + 1) / 2)
+		return old_scheme_first_port;	/* Second half */
+	return !old_scheme_first_port;		/* First half or all */
 }
 
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?
@@ -4545,6 +4552,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	const char		*speed;
 	int			devnum = udev-&gt;devnum;
 	const char		*driver_name;
+	bool			do_new_scheme;
 
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
@@ -4657,14 +4665,13 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 	 * first 8 bytes of the device descriptor to get the ep0 maxpacket
 	 * value.
 	 */
-	for (retries = 0; retries &lt; GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {
-		bool did_new_scheme = false;
+	do_new_scheme = use_new_scheme(udev, retry_counter, port_dev);
 
-		if (use_new_scheme(udev, retry_counter, port_dev)) {
+	for (retries = 0; retries &lt; GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {
+		if (do_new_scheme) {
 			struct usb_device_descriptor *buf;
 			int r = 0;
 
-			did_new_scheme = true;
 			retval = hub_enable_device(udev);
 			if (retval &lt; 0) {
 				dev_err(&amp;udev-&gt;dev,
@@ -4773,11 +4780,7 @@ hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,
 			 *  - read ep0 maxpacket even for high and low speed,
 			 */
 			msleep(10);
-			/* use_new_scheme() checks the speed which may have
-			 * changed since the initial look so we cache the result
-			 * in did_new_scheme
-			 */
-			if (did_new_scheme)
+			if (do_new_scheme)
 				break;
 		}
 
@@ -5106,7 +5109,7 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		unit_load = 100;
 
 	status = 0;
-	for (i = 0; i &lt; SET_CONFIG_TRIES; i++) {
+	for (i = 0; i &lt; PORT_INIT_TRIES; i++) {
 
 		/* reallocate for each attempt, since references
 		 * to the previous one can escape in various ways
@@ -5239,7 +5242,7 @@ static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 			break;
 
 		/* When halfway through our retry count, power-cycle the port */
-		if (i == (SET_CONFIG_TRIES / 2) - 1) {
+		if (i == (PORT_INIT_TRIES - 1) / 2) {
 			dev_info(&amp;port_dev-&gt;dev, "attempt power cycle\n");
 			usb_hub_set_port_power(hdev, hub, port1, false);
 			msleep(2 * hub_power_on_good_delay(hub));
@@ -5770,7 +5773,7 @@ static int usb_reset_and_verify_device(struct usb_device *udev)
 	bos = udev-&gt;bos;
 	udev-&gt;bos = NULL;
 
-	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
+	for (i = 0; i &lt; PORT_INIT_TRIES; ++i) {
 
 		/* ep0 maxpacket size may change; let the HCD know about it.
 		 * Other endpoints will be handled by re-enumeration. */</pre><hr><pre>commit 9b719c7119e77e8ddeefe4772c554d2863579c2b
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 21 10:55:46 2020 +0800

    USB: UDC: net2272: Fix memory leaks
    
    Like net2280 (on which it was based), the net2272 UDC driver has a
    problem with leaking memory along some of its failure pathways.  It
    also has another problem, not previously noted, in that some of the
    failure pathways will call usb_del_gadget_udc() without first calling
    usb_add_gadget_udc_release().  And it leaks memory by calling kfree()
    when it should call put_device().
    
    Until now it has been impossible to handle the memory leaks, because of
    lack of support in the UDC core for separately initializing and adding
    gadgets, or for separately deleting and freeing gadgets.  An earlier
    patch in this series adds the necessary support, making it possible to
    fix the outstanding problems properly.
    
    This patch adds an "added" flag to the net2272 structure to indicate
    whether or not the gadget has been registered (and thus whether or not
    to call usb_del_gadget()), and it fixes the deallocation issues by
    calling usb_put_gadget() at the appropriate places.
    
    A similar memory leak issue, apparently never before recognized, stems
    from the fact that the driver never initializes the drvdata field in
    the gadget's embedded struct device!  Evidently this wasn't noticed
    because the pointer is only ever used as an argument to kfree(), which
    doesn't mind getting called with a NULL pointer. In fact, the drvdata
    for gadget device will be written by usb_composite_dev structure if
    any gadget class is loaded, so it needs to use usb_gadget structure
    to get net2280 private data.
    
    CC: Anton Vasilyev &lt;vasilyev@ispras.ru&gt;
    CC: Evgeny Novikov &lt;novikov@ispras.ru&gt;
    CC: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Reviewed-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@kernel.org&gt;

diff --git a/drivers/usb/gadget/udc/net2272.c b/drivers/usb/gadget/udc/net2272.c
index 440bcb3b6c23..23a735641c3d 100644
--- a/drivers/usb/gadget/udc/net2272.c
+++ b/drivers/usb/gadget/udc/net2272.c
@@ -2195,7 +2195,8 @@ static int net2272_present(struct net2272 *dev)
 static void
 net2272_gadget_release(struct device *_dev)
 {
-	struct net2272 *dev = dev_get_drvdata(_dev);
+	struct net2272 *dev = container_of(_dev, struct net2272, gadget.dev);
+
 	kfree(dev);
 }
 
@@ -2204,7 +2205,8 @@ net2272_gadget_release(struct device *_dev)
 static void
 net2272_remove(struct net2272 *dev)
 {
-	usb_del_gadget_udc(&amp;dev-&gt;gadget);
+	if (dev-&gt;added)
+		usb_del_gadget(&amp;dev-&gt;gadget);
 	free_irq(dev-&gt;irq, dev);
 	iounmap(dev-&gt;base_addr);
 	device_remove_file(dev-&gt;dev, &amp;dev_attr_registers);
@@ -2234,6 +2236,7 @@ static struct net2272 *net2272_probe_init(struct device *dev, unsigned int irq)
 
 	/* the "gadget" abstracts/virtualizes the controller */
 	ret-&gt;gadget.name = driver_name;
+	usb_initialize_gadget(dev, &amp;ret-&gt;gadget, net2272_gadget_release);
 
 	return ret;
 }
@@ -2272,10 +2275,10 @@ net2272_probe_fin(struct net2272 *dev, unsigned int irqflags)
 	if (ret)
 		goto err_irq;
 
-	ret = usb_add_gadget_udc_release(dev-&gt;dev, &amp;dev-&gt;gadget,
-			net2272_gadget_release);
+	ret = usb_add_gadget(&amp;dev-&gt;gadget);
 	if (ret)
 		goto err_add_udc;
+	dev-&gt;added = 1;
 
 	return 0;
 
@@ -2450,7 +2453,7 @@ net2272_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	if (pci_enable_device(pdev) &lt; 0) {
 		ret = -ENODEV;
-		goto err_free;
+		goto err_put;
 	}
 
 	pci_set_master(pdev);
@@ -2473,8 +2476,8 @@ net2272_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 
  err_pci:
 	pci_disable_device(pdev);
- err_free:
-	kfree(dev);
+ err_put:
+	usb_put_gadget(&amp;dev-&gt;gadget);
 
 	return ret;
 }
@@ -2535,7 +2538,7 @@ net2272_pci_remove(struct pci_dev *pdev)
 
 	pci_disable_device(pdev);
 
-	kfree(dev);
+	usb_put_gadget(&amp;dev-&gt;gadget);
 }
 
 /* Table of matching PCI IDs */
@@ -2648,7 +2651,7 @@ net2272_plat_probe(struct platform_device *pdev)
  err_req:
 	release_mem_region(base, len);
  err:
-	kfree(dev);
+	usb_put_gadget(&amp;dev-&gt;gadget);
 
 	return ret;
 }
@@ -2663,7 +2666,7 @@ net2272_plat_remove(struct platform_device *pdev)
 	release_mem_region(pdev-&gt;resource[0].start,
 		resource_size(&amp;pdev-&gt;resource[0]));
 
-	kfree(dev);
+	usb_put_gadget(&amp;dev-&gt;gadget);
 
 	return 0;
 }
diff --git a/drivers/usb/gadget/udc/net2272.h b/drivers/usb/gadget/udc/net2272.h
index 87d0ab9ffeeb..c669308111c2 100644
--- a/drivers/usb/gadget/udc/net2272.h
+++ b/drivers/usb/gadget/udc/net2272.h
@@ -441,6 +441,7 @@ struct net2272 {
 	unsigned protocol_stall:1,
 	         softconnect:1,
 	         wakeup:1,
+		 added:1,
 	         dma_eot_polarity:1,
 	         dma_dack_polarity:1,
 	         dma_dreq_polarity:1,</pre><hr><pre>commit f770fbec4165b1acfabdeadb01ad6008d2c537b5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 21 10:55:45 2020 +0800

    USB: UDC: net2280: Fix memory leaks
    
    As Anton and Evgeny have noted, the net2280 UDC driver has a problem
    with leaking memory along some of its failure pathways.  It also has
    another problem, not previously noted, in that some of the failure
    pathways will call usb_del_gadget_udc() without first calling
    usb_add_gadget_udc_release().  And it leaks memory by calling kfree()
    when it should call put_device().
    
    Previous attempts to fix the problems have failed because of lack of
    support in the UDC core for separately initializing and adding
    gadgets, or for separately deleting and freeing gadgets.  The previous
    patch in this series adds the necessary support, making it possible to
    fix the outstanding problems properly.
    
    This patch adds an "added" flag to the net2280 structure to indicate
    whether or not the gadget has been registered (and thus whether or not
    to call usb_del_gadget()), and it fixes the deallocation issues by
    calling usb_put_gadget() at the appropriate point.
    
    A similar memory leak issue, apparently never before recognized, stems
    from the fact that the driver never initializes the drvdata field in
    the gadget's embedded struct device!  Evidently this wasn't noticed
    because the pointer is only ever used as an argument to kfree(), which
    doesn't mind getting called with a NULL pointer. In fact, the drvdata
    for gadget device will be written by usb_composite_dev structure if
    any gadget class is loaded, so it needs to use usb_gadget structure
    to get net2280 private data.
    
    CC: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Reported-by: Anton Vasilyev &lt;vasilyev@ispras.ru&gt;
    Reported-by: Evgeny Novikov &lt;novikov@ispras.ru&gt;
    Reviewed-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@kernel.org&gt;

diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c
index 7530bd9a08c4..d50bc6e19f2a 100644
--- a/drivers/usb/gadget/udc/net2280.c
+++ b/drivers/usb/gadget/udc/net2280.c
@@ -3561,7 +3561,7 @@ static irqreturn_t net2280_irq(int irq, void *_dev)
 
 static void gadget_release(struct device *_dev)
 {
-	struct net2280	*dev = dev_get_drvdata(_dev);
+	struct net2280	*dev = container_of(_dev, struct net2280, gadget.dev);
 
 	kfree(dev);
 }
@@ -3572,7 +3572,8 @@ static void net2280_remove(struct pci_dev *pdev)
 {
 	struct net2280		*dev = pci_get_drvdata(pdev);
 
-	usb_del_gadget_udc(&amp;dev-&gt;gadget);
+	if (dev-&gt;added)
+		usb_del_gadget(&amp;dev-&gt;gadget);
 
 	BUG_ON(dev-&gt;driver);
 
@@ -3603,6 +3604,7 @@ static void net2280_remove(struct pci_dev *pdev)
 	device_remove_file(&amp;pdev-&gt;dev, &amp;dev_attr_registers);
 
 	ep_info(dev, "unbind\n");
+	usb_put_gadget(&amp;dev-&gt;gadget);
 }
 
 /* wrap this driver around the specified device, but
@@ -3624,6 +3626,7 @@ static int net2280_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 
 	pci_set_drvdata(pdev, dev);
+	usb_initialize_gadget(&amp;pdev-&gt;dev, &amp;dev-&gt;gadget, gadget_release);
 	spin_lock_init(&amp;dev-&gt;lock);
 	dev-&gt;quirks = id-&gt;driver_data;
 	dev-&gt;pdev = pdev;
@@ -3774,10 +3777,10 @@ static int net2280_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (retval)
 		goto done;
 
-	retval = usb_add_gadget_udc_release(&amp;pdev-&gt;dev, &amp;dev-&gt;gadget,
-			gadget_release);
+	retval = usb_add_gadget(&amp;dev-&gt;gadget);
 	if (retval)
 		goto done;
+	dev-&gt;added = 1;
 	return 0;
 
 done:
diff --git a/drivers/usb/gadget/udc/net2280.h b/drivers/usb/gadget/udc/net2280.h
index 85d3ca1698ba..7da3dc1e9729 100644
--- a/drivers/usb/gadget/udc/net2280.h
+++ b/drivers/usb/gadget/udc/net2280.h
@@ -156,6 +156,7 @@ struct net2280 {
 					softconnect : 1,
 					got_irq : 1,
 					region:1,
+					added:1,
 					u1_enable:1,
 					u2_enable:1,
 					ltm_enable:1,</pre><hr><pre>commit 3301c215a2bb94b5a0afcb444bbe9bf2a395a65d
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Fri Aug 21 10:55:44 2020 +0800

    USB: UDC: Expand device model API interface
    
    The routines used by the UDC core to interface with the kernel's
    device model, namely usb_add_gadget_udc(),
    usb_add_gadget_udc_release(), and usb_del_gadget_udc(), provide access
    to only a subset of the device model's full API.  They include
    functionality equivalent to device_register() and device_unregister()
    for gadgets, but they omit device_initialize(), device_add(),
    device_del(), get_device(), and put_device().
    
    This patch expands the UDC API by adding usb_initialize_gadget(),
    usb_add_gadget(), usb_del_gadget(), usb_get_gadget(), and
    usb_put_gadget() to fill in the gap.  It rewrites the existing
    routines to call the new ones.
    
    CC: Anton Vasilyev &lt;vasilyev@ispras.ru&gt;
    CC: Evgeny Novikov &lt;novikov@ispras.ru&gt;
    CC: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
    Reviewed-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    Signed-off-by: Peter Chen &lt;peter.chen@nxp.com&gt;
    Signed-off-by: Felipe Balbi &lt;balbi@kernel.org&gt;

diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
index 4f82bcd31fd3..2b6770d9fb3f 100644
--- a/drivers/usb/gadget/udc/core.c
+++ b/drivers/usb/gadget/udc/core.c
@@ -1164,21 +1164,18 @@ static int check_pending_gadget_drivers(struct usb_udc *udc)
 }
 
 /**
- * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
+ * usb_initialize_gadget - initialize a gadget and its embedded struct device
  * @parent: the parent device to this udc. Usually the controller driver's
  * device.
- * @gadget: the gadget to be added to the list.
+ * @gadget: the gadget to be initialized.
  * @release: a gadget release function.
  *
  * Returns zero on success, negative errno otherwise.
  * Calls the gadget release function in the latter case.
  */
-int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
+void usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,
 		void (*release)(struct device *dev))
 {
-	struct usb_udc		*udc;
-	int			ret = -ENOMEM;
-
 	dev_set_name(&amp;gadget-&gt;dev, "gadget");
 	INIT_WORK(&amp;gadget-&gt;work, usb_gadget_state_work);
 	gadget-&gt;dev.parent = parent;
@@ -1189,17 +1186,32 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
 		gadget-&gt;dev.release = usb_udc_nop_release;
 
 	device_initialize(&amp;gadget-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(usb_initialize_gadget);
+
+/**
+ * usb_add_gadget - adds a new gadget to the udc class driver list
+ * @gadget: the gadget to be added to the list.
+ *
+ * Returns zero on success, negative errno otherwise.
+ * Does not do a final usb_put_gadget() if an error occurs.
+ */
+int usb_add_gadget(struct usb_gadget *gadget)
+{
+	struct usb_udc		*udc;
+	int			ret = -ENOMEM;
 
 	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
 	if (!udc)
-		goto err_put_gadget;
+		goto error;
 
 	device_initialize(&amp;udc-&gt;dev);
 	udc-&gt;dev.release = usb_udc_release;
 	udc-&gt;dev.class = udc_class;
 	udc-&gt;dev.groups = usb_udc_attr_groups;
-	udc-&gt;dev.parent = parent;
-	ret = dev_set_name(&amp;udc-&gt;dev, "%s", kobject_name(&amp;parent-&gt;kobj));
+	udc-&gt;dev.parent = gadget-&gt;dev.parent;
+	ret = dev_set_name(&amp;udc-&gt;dev, "%s",
+			kobject_name(&amp;gadget-&gt;dev.parent-&gt;kobj));
 	if (ret)
 		goto err_put_udc;
 
@@ -1242,8 +1254,30 @@ int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
  err_put_udc:
 	put_device(&amp;udc-&gt;dev);
 
- err_put_gadget:
-	put_device(&amp;gadget-&gt;dev);
+ error:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(usb_add_gadget);
+
+/**
+ * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
+ * @parent: the parent device to this udc. Usually the controller driver's
+ * device.
+ * @gadget: the gadget to be added to the list.
+ * @release: a gadget release function.
+ *
+ * Returns zero on success, negative errno otherwise.
+ * Calls the gadget release function in the latter case.
+ */
+int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,
+		void (*release)(struct device *dev))
+{
+	int	ret;
+
+	usb_initialize_gadget(parent, gadget, release);
+	ret = usb_add_gadget(gadget);
+	if (ret)
+		usb_put_gadget(gadget);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(usb_add_gadget_udc_release);
@@ -1311,13 +1345,14 @@ static void usb_gadget_remove_driver(struct usb_udc *udc)
 }
 
 /**
- * usb_del_gadget_udc - deletes @udc from udc_list
+ * usb_del_gadget - deletes @udc from udc_list
  * @gadget: the gadget to be removed.
  *
- * This, will call usb_gadget_unregister_driver() if
+ * This will call usb_gadget_unregister_driver() if
  * the @udc is still busy.
+ * It will not do a final usb_put_gadget().
  */
-void usb_del_gadget_udc(struct usb_gadget *gadget)
+void usb_del_gadget(struct usb_gadget *gadget)
 {
 	struct usb_udc *udc = gadget-&gt;udc;
 
@@ -1340,7 +1375,20 @@ void usb_del_gadget_udc(struct usb_gadget *gadget)
 	kobject_uevent(&amp;udc-&gt;dev.kobj, KOBJ_REMOVE);
 	flush_work(&amp;gadget-&gt;work);
 	device_unregister(&amp;udc-&gt;dev);
-	device_unregister(&amp;gadget-&gt;dev);
+	device_del(&amp;gadget-&gt;dev);
+}
+EXPORT_SYMBOL_GPL(usb_del_gadget);
+
+/**
+ * usb_del_gadget_udc - deletes @udc from udc_list
+ * @gadget: the gadget to be removed.
+ *
+ * Calls usb_del_gadget() and does a final usb_put_gadget().
+ */
+void usb_del_gadget_udc(struct usb_gadget *gadget)
+{
+	usb_del_gadget(gadget);
+	usb_put_gadget(gadget);
 	memset(&amp;gadget-&gt;dev, 0x00, sizeof(gadget-&gt;dev));
 }
 EXPORT_SYMBOL_GPL(usb_del_gadget_udc);
diff --git a/include/linux/usb/gadget.h b/include/linux/usb/gadget.h
index 52ce1f6b8f83..e7351d64f11f 100644
--- a/include/linux/usb/gadget.h
+++ b/include/linux/usb/gadget.h
@@ -436,6 +436,7 @@ struct usb_gadget {
 };
 #define work_to_gadget(w)	(container_of((w), struct usb_gadget, work))
 
+/* Interface to the device model */
 static inline void set_gadget_data(struct usb_gadget *gadget, void *data)
 	{ dev_set_drvdata(&amp;gadget-&gt;dev, data); }
 static inline void *get_gadget_data(struct usb_gadget *gadget)
@@ -444,6 +445,26 @@ static inline struct usb_gadget *dev_to_usb_gadget(struct device *dev)
 {
 	return container_of(dev, struct usb_gadget, dev);
 }
+static inline struct usb_gadget *usb_get_gadget(struct usb_gadget *gadget)
+{
+	get_device(&amp;gadget-&gt;dev);
+	return gadget;
+}
+static inline void usb_put_gadget(struct usb_gadget *gadget)
+{
+	put_device(&amp;gadget-&gt;dev);
+}
+extern void usb_initialize_gadget(struct device *parent,
+		struct usb_gadget *gadget, void (*release)(struct device *dev));
+extern int usb_add_gadget(struct usb_gadget *gadget);
+extern void usb_del_gadget(struct usb_gadget *gadget);
+
+/* Legacy device-model interface */
+extern int usb_add_gadget_udc_release(struct device *parent,
+		struct usb_gadget *gadget, void (*release)(struct device *dev));
+extern int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);
+extern void usb_del_gadget_udc(struct usb_gadget *gadget);
+extern char *usb_get_gadget_udc_name(void);
 
 /* iterates the non-control endpoints; 'tmp' is a struct usb_ep pointer */
 #define gadget_for_each_ep(tmp, gadget) \
@@ -735,12 +756,6 @@ int usb_gadget_probe_driver(struct usb_gadget_driver *driver);
  */
 int usb_gadget_unregister_driver(struct usb_gadget_driver *driver);
 
-extern int usb_add_gadget_udc_release(struct device *parent,
-		struct usb_gadget *gadget, void (*release)(struct device *dev));
-extern int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);
-extern void usb_del_gadget_udc(struct usb_gadget *gadget);
-extern char *usb_get_gadget_udc_name(void);
-
 /*-------------------------------------------------------------------------*/
 
 /* utility to simplify dealing with string descriptors */</pre><hr><pre>commit 20934c0de13b49a072fb1e0ca79fe0fe0e40eae5
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 26 10:32:29 2020 -0400

    usb: storage: Add unusual_uas entry for Sony PSZ drives
    
    The PSZ-HA* family of USB disk drives from Sony can't handle the
    REPORT OPCODES command when using the UAS protocol.  This patch adds
    an appropriate quirks entry.
    
    Reported-and-tested-by: Till Dörges &lt;doerges@pre-sense.de&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/20200826143229.GB400430@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/storage/unusual_uas.h b/drivers/usb/storage/unusual_uas.h
index 971f8a4354c8..711ab240058c 100644
--- a/drivers/usb/storage/unusual_uas.h
+++ b/drivers/usb/storage/unusual_uas.h
@@ -28,6 +28,13 @@
  * and don't forget to CC: the USB development list &lt;linux-usb@vger.kernel.org&gt;
  */
 
+/* Reported-by: Till Dörges &lt;doerges@pre-sense.de&gt; */
+UNUSUAL_DEV(0x054c, 0x087d, 0x0000, 0x9999,
+		"Sony",
+		"PSZ-HA*",
+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
+		US_FL_NO_REPORT_OPCODES),
+
 /* Reported-by: Julian Groß &lt;julian.g@posteo.de&gt; */
 UNUSUAL_DEV(0x059f, 0x105f, 0x0000, 0x9999,
 		"LaCie",</pre><hr><pre>commit 068834a2773b6a12805105cfadbb3d4229fc6e0a
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Wed Aug 26 15:46:24 2020 -0400

    USB: quirks: Ignore duplicate endpoint on Sound Devices MixPre-D
    
    The Sound Devices MixPre-D audio card suffers from the same defect
    as the Sound Devices USBPre2: an endpoint shared between a normal
    audio interface and a vendor-specific interface, in violation of the
    USB spec.  Since the USB core now treats duplicated endpoints as bugs
    and ignores them, the audio endpoint isn't available and the card
    can't be used for audio capture.
    
    Along the same lines as commit bdd1b147b802 ("USB: quirks: blacklist
    duplicate ep on Sound Devices USBPre2"), this patch adds a quirks
    entry saying to ignore ep5in for interface 1, leaving it available for
    use with standard audio interface 2.
    
    Reported-and-tested-by: Jean-Christophe Barnoud &lt;jcbarnoud@gmail.com&gt;
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Fixes: 3e4f8e21c4f2 ("USB: core: fix check for duplicate endpoints")
    Link: https://lore.kernel.org/r/20200826194624.GA412633@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c
index d1f38956b210..f232914de5fd 100644
--- a/drivers/usb/core/quirks.c
+++ b/drivers/usb/core/quirks.c
@@ -370,6 +370,10 @@ static const struct usb_device_id usb_quirk_list[] = {
 	{ USB_DEVICE(0x0926, 0x0202), .driver_info =
 			USB_QUIRK_ENDPOINT_IGNORE },
 
+	/* Sound Devices MixPre-D */
+	{ USB_DEVICE(0x0926, 0x0208), .driver_info =
+			USB_QUIRK_ENDPOINT_IGNORE },
+
 	/* Keytouch QWERTY Panel keyboard */
 	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
@@ -511,6 +515,7 @@ static const struct usb_device_id usb_amd_resume_quirk_list[] = {
  */
 static const struct usb_device_id usb_endpoint_ignore[] = {
 	{ USB_DEVICE_INTERFACE_NUMBER(0x0926, 0x0202, 1), .driver_info = 0x85 },
+	{ USB_DEVICE_INTERFACE_NUMBER(0x0926, 0x0208, 1), .driver_info = 0x85 },
 	{ }
 };
 </pre><hr><pre>commit f176ede3a3bde5b398a6777a7f9ff091baa2d3ff
Author: Alan Stern &lt;stern@rowland.harvard.edu&gt;
Date:   Mon Aug 10 14:29:54 2020 -0400

    USB: yurex: Fix bad gfp argument
    
    The syzbot fuzzer identified a bug in the yurex driver: It passes
    GFP_KERNEL as a memory-allocation flag to usb_submit_urb() at a time
    when its state is TASK_INTERRUPTIBLE, not TASK_RUNNING:
    
    do not call blocking ops when !TASK_RUNNING; state=1 set at [&lt;00000000370c7c68&gt;] prepare_to_wait+0xb1/0x2a0 kernel/sched/wait.c:247
    WARNING: CPU: 1 PID: 340 at kernel/sched/core.c:7253 __might_sleep+0x135/0x190
    kernel/sched/core.c:7253
    Kernel panic - not syncing: panic_on_warn set ...
    CPU: 1 PID: 340 Comm: syz-executor677 Not tainted 5.8.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google
    01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0xf6/0x16e lib/dump_stack.c:118
     panic+0x2aa/0x6e1 kernel/panic.c:231
     __warn.cold+0x20/0x50 kernel/panic.c:600
     report_bug+0x1bd/0x210 lib/bug.c:198
     handle_bug+0x41/0x80 arch/x86/kernel/traps.c:234
     exc_invalid_op+0x14/0x40 arch/x86/kernel/traps.c:254
     asm_exc_invalid_op+0x12/0x20 arch/x86/include/asm/idtentry.h:536
    RIP: 0010:__might_sleep+0x135/0x190 kernel/sched/core.c:7253
    Code: 65 48 8b 1c 25 40 ef 01 00 48 8d 7b 10 48 89 fe 48 c1 ee 03 80 3c 06 00 75
    2b 48 8b 73 10 48 c7 c7 e0 9e 06 86 e8 ed 12 f6 ff &lt;0f&gt; 0b e9 46 ff ff ff e8 1f
    b2 4b 00 e9 29 ff ff ff e8 15 b2 4b 00
    RSP: 0018:ffff8881cdb77a28 EFLAGS: 00010282
    RAX: 0000000000000000 RBX: ffff8881c6458000 RCX: 0000000000000000
    RDX: ffff8881c6458000 RSI: ffffffff8129ec93 RDI: ffffed1039b6ef37
    RBP: ffffffff86fdade2 R08: 0000000000000001 R09: ffff8881db32f54f
    R10: 0000000000000000 R11: 0000000030343354 R12: 00000000000001f2
    R13: 0000000000000000 R14: 0000000000000068 R15: ffffffff83c1b1aa
     slab_pre_alloc_hook.constprop.0+0xea/0x200 mm/slab.h:498
     slab_alloc_node mm/slub.c:2816 [inline]
     slab_alloc mm/slub.c:2900 [inline]
     kmem_cache_alloc_trace+0x46/0x220 mm/slub.c:2917
     kmalloc include/linux/slab.h:554 [inline]
     dummy_urb_enqueue+0x7a/0x880 drivers/usb/gadget/udc/dummy_hcd.c:1251
     usb_hcd_submit_urb+0x2b2/0x22d0 drivers/usb/core/hcd.c:1547
     usb_submit_urb+0xb4e/0x13e0 drivers/usb/core/urb.c:570
     yurex_write+0x3ea/0x820 drivers/usb/misc/yurex.c:495
    
    This patch changes the call to use GFP_ATOMIC instead of GFP_KERNEL.
    
    Reported-and-tested-by: syzbot+c2c3302f9c601a4b1be2@syzkaller.appspotmail.com
    Signed-off-by: Alan Stern &lt;stern@rowland.harvard.edu&gt;
    CC: &lt;stable@vger.kernel.org&gt;
    Link: https://lore.kernel.org/r/20200810182954.GB307778@rowland.harvard.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/usb/misc/yurex.c b/drivers/usb/misc/yurex.c
index 6e7d34e7fec4..b2e09883c7e2 100644
--- a/drivers/usb/misc/yurex.c
+++ b/drivers/usb/misc/yurex.c
@@ -492,7 +492,7 @@ static ssize_t yurex_write(struct file *file, const char __user *user_buffer,
 	prepare_to_wait(&amp;dev-&gt;waitq, &amp;wait, TASK_INTERRUPTIBLE);
 	dev_dbg(&amp;dev-&gt;interface-&gt;dev, "%s - submit %c\n", __func__,
 		dev-&gt;cntl_buffer[0]);
-	retval = usb_submit_urb(dev-&gt;cntl_urb, GFP_KERNEL);
+	retval = usb_submit_urb(dev-&gt;cntl_urb, GFP_ATOMIC);
 	if (retval &gt;= 0)
 		timeout = schedule_timeout(YUREX_WRITE_TIMEOUT);
 	finish_wait(&amp;dev-&gt;waitq, &amp;wait);</pre>
    <div class="pagination">
        <a href='2_8.html'>&lt;&lt;Prev</a><a href='2.html'>1</a><a href='2_2.html'>2</a><a href='2_3.html'>3</a><a href='2_4.html'>4</a><a href='2_5.html'>5</a><a href='2_6.html'>6</a><a href='2_7.html'>7</a><a href='2_8.html'>8</a><span>[9]</span><a href='2_10.html'>10</a><a href='2_11.html'>11</a><a href='2_12.html'>12</a><a href='2_13.html'>13</a><a href='2_14.html'>14</a><a href='2_15.html'>15</a><a href='2_16.html'>16</a><a href='2_17.html'>17</a><a href='2_18.html'>18</a><a href='2_19.html'>19</a><a href='2_20.html'>20</a><a href='2_21.html'>21</a><a href='2_22.html'>22</a><a href='2_23.html'>23</a><a href='2_24.html'>24</a><a href='2_25.html'>25</a><a href='2_26.html'>26</a><a href='2_27.html'>27</a><a href='2_28.html'>28</a><a href='2_29.html'>29</a><a href='2_30.html'>30</a><a href='2_31.html'>31</a><a href='2_32.html'>32</a><a href='2_33.html'>33</a><a href='2_34.html'>34</a><a href='2_35.html'>35</a><a href='2_36.html'>36</a><a href='2_37.html'>37</a><a href='2_38.html'>38</a><a href='2_39.html'>39</a><a href='2_40.html'>40</a><a href='2_41.html'>41</a><a href='2_42.html'>42</a><a href='2_43.html'>43</a><a href='2_44.html'>44</a><a href='2_45.html'>45</a><a href='2_46.html'>46</a><a href='2_47.html'>47</a><a href='2_48.html'>48</a><a href='2_49.html'>49</a><a href='2_50.html'>50</a><a href='2_51.html'>51</a><a href='2_52.html'>52</a><a href='2_53.html'>53</a><a href='2_54.html'>54</a><a href='2_55.html'>55</a><a href='2_56.html'>56</a><a href='2_57.html'>57</a><a href='2_58.html'>58</a><a href='2_59.html'>59</a><a href='2_60.html'>60</a><a href='2_61.html'>61</a><a href='2_62.html'>62</a><a href='2_63.html'>63</a><a href='2_64.html'>64</a><a href='2_65.html'>65</a><a href='2_66.html'>66</a><a href='2_67.html'>67</a><a href='2_68.html'>68</a><a href='2_69.html'>69</a><a href='2_70.html'>70</a><a href='2_71.html'>71</a><a href='2_72.html'>72</a><a href='2_73.html'>73</a><a href='2_74.html'>74</a><a href='2_75.html'>75</a><a href='2_76.html'>76</a><a href='2_77.html'>77</a><a href='2_78.html'>78</a><a href='2_79.html'>79</a><a href='2_80.html'>80</a><a href='2_81.html'>81</a><a href='2_82.html'>82</a><a href='2_83.html'>83</a><a href='2_84.html'>84</a><a href='2_85.html'>85</a><a href='2_86.html'>86</a><a href='2_87.html'>87</a><a href='2_88.html'>88</a><a href='2_89.html'>89</a><a href='2_90.html'>90</a><a href='2_91.html'>91</a><a href='2_92.html'>92</a><a href='2_93.html'>93</a><a href='2_94.html'>94</a><a href='2_95.html'>95</a><a href='2_96.html'>96</a><a href='2_97.html'>97</a><a href='2_98.html'>98</a><a href='2_99.html'>99</a><a href='2_100.html'>100</a><a href='2_101.html'>101</a><a href='2_102.html'>102</a><a href='2_103.html'>103</a><a href='2_104.html'>104</a><a href='2_105.html'>105</a><a href='2_106.html'>106</a><a href='2_107.html'>107</a><a href='2_108.html'>108</a><a href='2_109.html'>109</a><a href='2_110.html'>110</a><a href='2_111.html'>111</a><a href='2_112.html'>112</a><a href='2_113.html'>113</a><a href='2_114.html'>114</a><a href='2_115.html'>115</a><a href='2_116.html'>116</a><a href='2_117.html'>117</a><a href='2_118.html'>118</a><a href='2_119.html'>119</a><a href='2_120.html'>120</a><a href='2_121.html'>121</a><a href='2_122.html'>122</a><a href='2_123.html'>123</a><a href='2_124.html'>124</a><a href='2_125.html'>125</a><a href='2_126.html'>126</a><a href='2_127.html'>127</a><a href='2_128.html'>128</a><a href='2_129.html'>129</a><a href='2_130.html'>130</a><a href='2_131.html'>131</a><a href='2_132.html'>132</a><a href='2_133.html'>133</a><a href='2_134.html'>134</a><a href='2_135.html'>135</a><a href='2_136.html'>136</a><a href='2_137.html'>137</a><a href='2_138.html'>138</a><a href='2_139.html'>139</a><a href='2_140.html'>140</a><a href='2_10.html'>Next&gt;&gt;</a>
    <div>
</body>
