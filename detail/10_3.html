<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by Virginia Tech</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by Virginia Tech</h1>
    <div class="pagination">
        <a href='10_2.html'>&lt;&lt;Prev</a><a href='10.html'>1</a><a href='10_2.html'>2</a><span>[3]</span><a href='10_4.html'>4</a><a href='10_5.html'>5</a><a href='10_6.html'>6</a><a href='10_7.html'>7</a><a href='10_8.html'>8</a><a href='10_9.html'>9</a><a href='10_10.html'>10</a><a href='10_11.html'>11</a><a href='10_12.html'>12</a><a href='10_4.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ed5916c1e8db99eeab6cbbf7cba150a5cee90c0f
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Tue Nov 12 16:12:32 2019 -0500

    staging: exfat: Clean up the namespace pollution part 2
    
    Rename all the bdev_* to exfat_bdev_*
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112211238.156490-7-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index 5efba3d4259b..5044523ccb97 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -842,13 +842,13 @@ int multi_sector_read(struct super_block *sb, sector_t sec,
 int multi_sector_write(struct super_block *sb, sector_t sec,
 		       struct buffer_head *bh, s32 num_secs, bool sync);
 
-void bdev_open(struct super_block *sb);
-void bdev_close(struct super_block *sb);
-int bdev_read(struct super_block *sb, sector_t secno,
+void exfat_bdev_open(struct super_block *sb);
+void exfat_bdev_close(struct super_block *sb);
+int exfat_bdev_read(struct super_block *sb, sector_t secno,
 	      struct buffer_head **bh, u32 num_secs, bool read);
-int bdev_write(struct super_block *sb, sector_t secno,
+int exfat_bdev_write(struct super_block *sb, sector_t secno,
 	       struct buffer_head *bh, u32 num_secs, bool sync);
-int bdev_sync(struct super_block *sb);
+int exfat_bdev_sync(struct super_block *sb);
 
 extern const u8 uni_upcase[];
 #endif /* _EXFAT_H */
diff --git a/drivers/staging/exfat/exfat_blkdev.c b/drivers/staging/exfat/exfat_blkdev.c
index 0abae041f632..7bcd98b13109 100644
--- a/drivers/staging/exfat/exfat_blkdev.c
+++ b/drivers/staging/exfat/exfat_blkdev.c
@@ -8,7 +8,7 @@
 #include &lt;linux/fs.h&gt;
 #include "exfat.h"
 
-void bdev_open(struct super_block *sb)
+void exfat_bdev_open(struct super_block *sb)
 {
 	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
 
@@ -23,14 +23,14 @@ void bdev_open(struct super_block *sb)
 	p_bd-&gt;opened = true;
 }
 
-void bdev_close(struct super_block *sb)
+void exfat_bdev_close(struct super_block *sb)
 {
 	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
 
 	p_bd-&gt;opened = false;
 }
 
-int bdev_read(struct super_block *sb, sector_t secno, struct buffer_head **bh,
+int exfat_bdev_read(struct super_block *sb, sector_t secno, struct buffer_head **bh,
 	      u32 num_secs, bool read)
 {
 	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
@@ -65,7 +65,7 @@ int bdev_read(struct super_block *sb, sector_t secno, struct buffer_head **bh,
 	return -EIO;
 }
 
-int bdev_write(struct super_block *sb, sector_t secno, struct buffer_head *bh,
+int exfat_bdev_write(struct super_block *sb, sector_t secno, struct buffer_head *bh,
 	       u32 num_secs, bool sync)
 {
 	s32 count;
@@ -118,7 +118,7 @@ int bdev_write(struct super_block *sb, sector_t secno, struct buffer_head *bh,
 	return -EIO;
 }
 
-int bdev_sync(struct super_block *sb)
+int exfat_bdev_sync(struct super_block *sb)
 {
 	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
 #ifdef CONFIG_EXFAT_KERNEL_DEBUG
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index 2dc07e81bad0..5a01fc25f31d 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -2569,7 +2569,7 @@ int sector_read(struct super_block *sb, sector_t sec, struct buffer_head **bh,
 	}
 
 	if (!p_fs-&gt;dev_ejected) {
-		ret = bdev_read(sb, sec, bh, 1, read);
+		ret = exfat_bdev_read(sb, sec, bh, 1, read);
 		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
@@ -2598,7 +2598,7 @@ int sector_write(struct super_block *sb, sector_t sec, struct buffer_head *bh,
 	}
 
 	if (!p_fs-&gt;dev_ejected) {
-		ret = bdev_write(sb, sec, bh, 1, sync);
+		ret = exfat_bdev_write(sb, sec, bh, 1, sync);
 		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
@@ -2621,7 +2621,7 @@ int multi_sector_read(struct super_block *sb, sector_t sec,
 	}
 
 	if (!p_fs-&gt;dev_ejected) {
-		ret = bdev_read(sb, sec, bh, num_secs, read);
+		ret = exfat_bdev_read(sb, sec, bh, num_secs, read);
 		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
@@ -2649,7 +2649,7 @@ int multi_sector_write(struct super_block *sb, sector_t sec,
 	}
 
 	if (!p_fs-&gt;dev_ejected) {
-		ret = bdev_write(sb, sec, bh, num_secs, sync);
+		ret = exfat_bdev_write(sb, sec, bh, num_secs, sync);
 		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
diff --git a/drivers/staging/exfat/exfat_super.c b/drivers/staging/exfat/exfat_super.c
index 259cb5a7bd81..3828150bca3f 100644
--- a/drivers/staging/exfat/exfat_super.c
+++ b/drivers/staging/exfat/exfat_super.c
@@ -289,7 +289,7 @@ static DEFINE_MUTEX(z_mutex);
 static inline void fs_sync(struct super_block *sb, bool do_sync)
 {
 	if (do_sync)
-		bdev_sync(sb);
+		exfat_bdev_sync(sb);
 }
 
 /*
@@ -361,7 +361,7 @@ static int ffsMountVol(struct super_block *sb)
 	p_fs-&gt;dev_ejected = 0;
 
 	/* open the block device */
-	bdev_open(sb);
+	exfat_bdev_open(sb);
 
 	if (p_bd-&gt;sector_size &lt; sb-&gt;s_blocksize) {
 		printk(KERN_INFO "EXFAT: maont failed - sector size %d less than blocksize %ld\n",
@@ -385,7 +385,7 @@ static int ffsMountVol(struct super_block *sb)
 	/* check the validity of PBR */
 	if (GET16_A(p_pbr-&gt;signature) != PBR_SIGNATURE) {
 		brelse(tmp_bh);
-		bdev_close(sb);
+		exfat_bdev_close(sb);
 		ret = -EFSCORRUPTED;
 		goto out;
 	}
@@ -407,26 +407,26 @@ static int ffsMountVol(struct super_block *sb)
 	brelse(tmp_bh);
 
 	if (ret) {
-		bdev_close(sb);
+		exfat_bdev_close(sb);
 		goto out;
 	}
 
 	ret = load_alloc_bitmap(sb);
 	if (ret) {
-		bdev_close(sb);
+		exfat_bdev_close(sb);
 		goto out;
 	}
 	ret = load_upcase_table(sb);
 	if (ret) {
 		free_alloc_bitmap(sb);
-		bdev_close(sb);
+		exfat_bdev_close(sb);
 		goto out;
 	}
 
 	if (p_fs-&gt;dev_ejected) {
 		free_upcase_table(sb);
 		free_alloc_bitmap(sb);
-		bdev_close(sb);
+		exfat_bdev_close(sb);
 		ret = -EIO;
 		goto out;
 	}
@@ -461,7 +461,7 @@ static int ffsUmountVol(struct super_block *sb)
 	buf_release_all(sb);
 
 	/* close the block device */
-	bdev_close(sb);
+	exfat_bdev_close(sb);
 
 	if (p_fs-&gt;dev_ejected) {
 		pr_info("[EXFAT] unmounted with media errors. Device is already ejected.\n");</pre><hr><pre>commit 19e2bfe6ed135ed45d6adb6860181cad49dbb90e
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Tue Nov 12 16:12:31 2019 -0500

    staging: exfat: Clean up the namespace pollution part 1
    
    Everything referenced in the struct fs_func exfat_fs_func is located
    in that same .c file.  Make them static and remove from exfat.h
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112211238.156490-6-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index 470e409ef536..5efba3d4259b 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -759,13 +759,8 @@ void fs_error(struct super_block *sb);
 
 /* cluster management functions */
 s32 clear_cluster(struct super_block *sb, u32 clu);
-s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
-			struct chain_t *p_chain);
-void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
-			s32 do_relse);
 u32 find_last_cluster(struct super_block *sb, struct chain_t *p_chain);
 s32 count_num_clusters(struct super_block *sb, struct chain_t *dir);
-s32 exfat_count_used_clusters(struct super_block *sb);
 void exfat_chain_cont_cluster(struct super_block *sb, u32 chain, s32 len);
 
 /* allocation bitmap management functions */
@@ -781,29 +776,11 @@ s32 load_upcase_table(struct super_block *sb);
 void free_upcase_table(struct super_block *sb);
 
 /* dir entry management functions */
-u32 exfat_get_entry_type(struct dentry_t *p_entry);
-void exfat_set_entry_type(struct dentry_t *p_entry, u32 type);
-u32 exfat_get_entry_attr(struct dentry_t *p_entry);
-void exfat_set_entry_attr(struct dentry_t *p_entry, u32 attr);
-u8 exfat_get_entry_flag(struct dentry_t *p_entry);
-void exfat_set_entry_flag(struct dentry_t *p_entry, u8 flag);
-u32 exfat_get_entry_clu0(struct dentry_t *p_entry);
-void exfat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu);
-u64 exfat_get_entry_size(struct dentry_t *p_entry);
-void exfat_set_entry_size(struct dentry_t *p_entry, u64 size);
 struct timestamp_t *tm_current(struct timestamp_t *tm);
-void exfat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
-			  u8 mode);
-void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
-			  u8 mode);
-s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-			 s32 entry, u32 type, u32 start_clu, u64 size);
 void init_file_entry(struct file_dentry_t *ep, u32 type);
 void init_strm_entry(struct strm_dentry_t *ep, u8 flags, u32 start_clu,
 		     u64 size);
 void init_name_entry(struct name_dentry_t *ep, u16 *uniname);
-void exfat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-			    s32 entry, s32 order, s32 num_entries);
 
 s32 find_location(struct super_block *sb, struct chain_t *p_dir, s32 entry,
 		  sector_t *sector, s32 *offset);
@@ -822,11 +799,6 @@ s32 search_deleted_or_unused_entry(struct super_block *sb,
 				   struct chain_t *p_dir, s32 num_entries);
 s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir,
 		     s32 num_entries);
-s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-			 struct uni_name_t *p_uniname, s32 num_entries,
-			 struct dos_name_t *p_dosname, u32 type);
-s32 exfat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
-			    s32 entry, struct dentry_t *p_entry);
 s32 count_dos_name_entries(struct super_block *sb, struct chain_t *p_dir,
 			   u32 type);
 void update_dir_checksum(struct super_block *sb, struct chain_t *p_dir,
@@ -839,12 +811,8 @@ bool is_dir_empty(struct super_block *sb, struct chain_t *p_dir);
 s32 get_num_entries_and_dos_name(struct super_block *sb, struct chain_t *p_dir,
 				 struct uni_name_t *p_uniname, s32 *entries,
 				 struct dos_name_t *p_dosname);
-void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
-				       struct chain_t *p_dir, s32 entry,
-				       u16 *uniname);
 s32 extract_uni_name_from_name_entry(struct name_dentry_t *ep,
 				     u16 *uniname, s32 order);
-s32 exfat_calc_num_entries(struct uni_name_t *p_uniname);
 u16 calc_checksum_2byte(void *data, s32 len, u16 chksum, s32 type);
 
 /* name resolution functions */
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index c3454e883e3c..2dc07e81bad0 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -156,7 +156,7 @@ s32 clear_cluster(struct super_block *sb, u32 clu)
 	return ret;
 }
 
-s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
+static s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 			struct chain_t *p_chain)
 {
 	s32 num_clusters = 0;
@@ -235,7 +235,7 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 	return num_clusters;
 }
 
-void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
+static void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 			s32 do_relse)
 {
 	s32 num_clusters = 0;
@@ -341,7 +341,7 @@ s32 count_num_clusters(struct super_block *sb, struct chain_t *p_chain)
 	return count;
 }
 
-s32 exfat_count_used_clusters(struct super_block *sb)
+static s32 exfat_count_used_clusters(struct super_block *sb)
 {
 	int i, map_i, map_b, count = 0;
 	u8 k;
@@ -785,7 +785,7 @@ void free_upcase_table(struct super_block *sb)
  *  Directory Entry Management Functions
  */
 
-u32 exfat_get_entry_type(struct dentry_t *p_entry)
+static u32 exfat_get_entry_type(struct dentry_t *p_entry)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
@@ -830,7 +830,7 @@ u32 exfat_get_entry_type(struct dentry_t *p_entry)
 	return TYPE_BENIGN_SEC;
 }
 
-void exfat_set_entry_type(struct dentry_t *p_entry, u32 type)
+static void exfat_set_entry_type(struct dentry_t *p_entry, u32 type)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
@@ -860,56 +860,56 @@ void exfat_set_entry_type(struct dentry_t *p_entry, u32 type)
 	}
 }
 
-u32 exfat_get_entry_attr(struct dentry_t *p_entry)
+static u32 exfat_get_entry_attr(struct dentry_t *p_entry)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
 	return (u32)GET16_A(ep-&gt;attr);
 }
 
-void exfat_set_entry_attr(struct dentry_t *p_entry, u32 attr)
+static void exfat_set_entry_attr(struct dentry_t *p_entry, u32 attr)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
 
 	SET16_A(ep-&gt;attr, (u16)attr);
 }
 
-u8 exfat_get_entry_flag(struct dentry_t *p_entry)
+static u8 exfat_get_entry_flag(struct dentry_t *p_entry)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	return ep-&gt;flags;
 }
 
-void exfat_set_entry_flag(struct dentry_t *p_entry, u8 flags)
+static void exfat_set_entry_flag(struct dentry_t *p_entry, u8 flags)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	ep-&gt;flags = flags;
 }
 
-u32 exfat_get_entry_clu0(struct dentry_t *p_entry)
+static u32 exfat_get_entry_clu0(struct dentry_t *p_entry)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	return GET32_A(ep-&gt;start_clu);
 }
 
-void exfat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu)
+static void exfat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	SET32_A(ep-&gt;start_clu, start_clu);
 }
 
-u64 exfat_get_entry_size(struct dentry_t *p_entry)
+static u64 exfat_get_entry_size(struct dentry_t *p_entry)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
 	return GET64_A(ep-&gt;valid_size);
 }
 
-void exfat_set_entry_size(struct dentry_t *p_entry, u64 size)
+static void exfat_set_entry_size(struct dentry_t *p_entry, u64 size)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
 
@@ -917,7 +917,7 @@ void exfat_set_entry_size(struct dentry_t *p_entry, u64 size)
 	SET64_A(ep-&gt;size, size);
 }
 
-void exfat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
+static void exfat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 			  u8 mode)
 {
 	u16 t = 0x00, d = 0x21;
@@ -946,7 +946,7 @@ void exfat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 	tp-&gt;year = (d &gt;&gt; 9);
 }
 
-void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
+static void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 			  u8 mode)
 {
 	u16 t, d;
@@ -971,7 +971,7 @@ void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 	}
 }
 
-s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
+static s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			 s32 entry, u32 type, u32 start_clu, u64 size)
 {
 	sector_t sector;
@@ -1086,7 +1086,7 @@ void init_name_entry(struct name_dentry_t *ep, u16 *uniname)
 	}
 }
 
-void exfat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
+static void exfat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			    s32 entry, s32 order, s32 num_entries)
 {
 	int i;
@@ -1670,7 +1670,7 @@ s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir, s32 num_entries
  * -1 : (root dir, ".") it is the root dir itself
  * -2 : entry with the name does not exist
  */
-s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
+static s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			 struct uni_name_t *p_uniname, s32 num_entries,
 			 struct dos_name_t *p_dosname, u32 type)
 {
@@ -1813,7 +1813,7 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 	return -2;
 }
 
-s32 exfat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
+static s32 exfat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
 			    s32 entry, struct dentry_t *p_entry)
 {
 	int i, count = 0;
@@ -1976,7 +1976,7 @@ s32 get_num_entries_and_dos_name(struct super_block *sb, struct chain_t *p_dir,
 	return 0;
 }
 
-void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
+static void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
 				       struct chain_t *p_dir, s32 entry,
 				       u16 *uniname)
 {
@@ -2030,7 +2030,7 @@ s32 extract_uni_name_from_name_entry(struct name_dentry_t *ep, u16 *uniname,
 	return len;
 }
 
-s32 exfat_calc_num_entries(struct uni_name_t *p_uniname)
+static s32 exfat_calc_num_entries(struct uni_name_t *p_uniname)
 {
 	s32 len;
 </pre><hr><pre>commit 35a829c1b797d1a927bf54b6a958e154eb248026
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Tue Nov 12 16:12:30 2019 -0500

    staging: exfat: Remove FAT/VFAT mount support, part 4
    
    The code simplification from the previous patch rendered a few more
    routines unreferenced, so heave them over the side as well.
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112211238.156490-5-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index 9ea865f607af..470e409ef536 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -729,14 +729,7 @@ static inline struct exfat_inode_info *EXFAT_I(struct inode *inode)
 
 /* NLS management function */
 u16 nls_upper(struct super_block *sb, u16 a);
-int nls_dosname_cmp(struct super_block *sb, u8 *a, u8 *b);
 int nls_uniname_cmp(struct super_block *sb, u16 *a, u16 *b);
-void nls_uniname_to_dosname(struct super_block *sb,
-			    struct dos_name_t *p_dosname,
-			    struct uni_name_t *p_uniname, bool *p_lossy);
-void nls_dosname_to_uniname(struct super_block *sb,
-			    struct uni_name_t *p_uniname,
-			    struct dos_name_t *p_dosname);
 void nls_uniname_to_cstring(struct super_block *sb, u8 *p_cstring,
 			    struct uni_name_t *p_uniname);
 void nls_cstring_to_uniname(struct super_block *sb,
@@ -805,10 +798,6 @@ void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 			  u8 mode);
 s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			 s32 entry, u32 type, u32 start_clu, u64 size);
-s32 exfat_init_ext_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-			     s32 entry, s32 num_entries,
-			     struct uni_name_t *p_uniname,
-		struct dos_name_t *p_dosname);
 void init_file_entry(struct file_dentry_t *ep, u32 type);
 void init_strm_entry(struct strm_dentry_t *ep, u8 flags, u32 start_clu,
 		     u64 size);
@@ -850,25 +839,17 @@ bool is_dir_empty(struct super_block *sb, struct chain_t *p_dir);
 s32 get_num_entries_and_dos_name(struct super_block *sb, struct chain_t *p_dir,
 				 struct uni_name_t *p_uniname, s32 *entries,
 				 struct dos_name_t *p_dosname);
-void get_uni_name_from_dos_entry(struct super_block *sb,
-				 struct dos_dentry_t *ep,
-				 struct uni_name_t *p_uniname, u8 mode);
 void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
 				       struct chain_t *p_dir, s32 entry,
 				       u16 *uniname);
 s32 extract_uni_name_from_name_entry(struct name_dentry_t *ep,
 				     u16 *uniname, s32 order);
-s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
-			  struct dos_name_t *p_dosname);
-void fat_attach_count_to_dos_name(u8 *dosname, s32 count);
-s32 fat_calc_num_entries(struct uni_name_t *p_uniname);
 s32 exfat_calc_num_entries(struct uni_name_t *p_uniname);
 u16 calc_checksum_2byte(void *data, s32 len, u16 chksum, s32 type);
 
 /* name resolution functions */
 s32 resolve_path(struct inode *inode, char *path, struct chain_t *p_dir,
 		 struct uni_name_t *p_uniname);
-s32 resolve_name(u8 *name, u8 **arg);
 
 /* file operation functions */
 s32 exfat_mount(struct super_block *sb, struct pbr_sector_t *p_pbr);
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index 77b826dfdeda..c3454e883e3c 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -1976,21 +1976,6 @@ s32 get_num_entries_and_dos_name(struct super_block *sb, struct chain_t *p_dir,
 	return 0;
 }
 
-void get_uni_name_from_dos_entry(struct super_block *sb,
-				 struct dos_dentry_t *ep,
-				 struct uni_name_t *p_uniname, u8 mode)
-{
-	struct dos_name_t dos_name;
-
-	if (mode == 0x0)
-		dos_name.name_case = 0x0;
-	else
-		dos_name.name_case = ep-&gt;lcase;
-
-	memcpy(dos_name.name, ep-&gt;name, DOS_NAME_LENGTH);
-	nls_dosname_to_uniname(sb, p_uniname, &amp;dos_name);
-}
-
 void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
 				       struct chain_t *p_dir, s32 entry,
 				       u16 *uniname)
@@ -2045,128 +2030,6 @@ s32 extract_uni_name_from_name_entry(struct name_dentry_t *ep, u16 *uniname,
 	return len;
 }
 
-s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
-			  struct dos_name_t *p_dosname)
-{
-	int i, j, count = 0;
-	bool count_begin = false;
-	s32 dentries_per_clu;
-	u32 type;
-	u8 bmap[128/* 1 ~ 1023 */];
-	struct chain_t clu;
-	struct dos_dentry_t *ep;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-
-	memset(bmap, 0, sizeof(bmap));
-	exfat_bitmap_set(bmap, 0);
-
-	if (p_dir-&gt;dir == CLUSTER_32(0)) /* FAT16 root_dir */
-		dentries_per_clu = p_fs-&gt;dentries_in_root;
-	else
-		dentries_per_clu = p_fs-&gt;dentries_per_clu;
-
-	clu.dir = p_dir-&gt;dir;
-	clu.flags = p_dir-&gt;flags;
-
-	while (clu.dir != CLUSTER_32(~0)) {
-		if (p_fs-&gt;dev_ejected)
-			break;
-
-		for (i = 0; i &lt; dentries_per_clu; i++) {
-			ep = (struct dos_dentry_t *)get_entry_in_dir(sb, &amp;clu,
-								     i, NULL);
-			if (!ep)
-				return -ENOENT;
-
-			type = p_fs-&gt;fs_func-&gt;get_entry_type((struct dentry_t *)
-							     ep);
-
-			if (type == TYPE_UNUSED)
-				break;
-			if ((type != TYPE_FILE) &amp;&amp; (type != TYPE_DIR))
-				continue;
-
-			count = 0;
-			count_begin = false;
-
-			for (j = 0; j &lt; 8; j++) {
-				if (ep-&gt;name[j] == ' ')
-					break;
-
-				if (ep-&gt;name[j] == '~') {
-					count_begin = true;
-				} else if (count_begin) {
-					if ((ep-&gt;name[j] &gt;= '0') &amp;&amp;
-					    (ep-&gt;name[j] &lt;= '9')) {
-						count = count * 10 +
-							(ep-&gt;name[j] - '0');
-					} else {
-						count = 0;
-						count_begin = false;
-					}
-				}
-			}
-
-			if ((count &gt; 0) &amp;&amp; (count &lt; 1024))
-				exfat_bitmap_set(bmap, count);
-		}
-
-		if (p_dir-&gt;dir == CLUSTER_32(0))
-			break; /* FAT16 root_dir */
-
-		if (FAT_read(sb, clu.dir, &amp;clu.dir) != 0)
-			return -EIO;
-	}
-
-	count = 0;
-	for (i = 0; i &lt; 128; i++) {
-		if (bmap[i] != 0xFF) {
-			for (j = 0; j &lt; 8; j++) {
-				if (exfat_bitmap_test(&amp;bmap[i], j) == 0) {
-					count = (i &lt;&lt; 3) + j;
-					break;
-				}
-			}
-			if (count != 0)
-				break;
-		}
-	}
-
-	if ((count == 0) || (count &gt;= 1024))
-		return -EEXIST;
-	fat_attach_count_to_dos_name(p_dosname-&gt;name, count);
-
-	/* Now dos_name has DOS~????.EXT */
-	return 0;
-}
-
-void fat_attach_count_to_dos_name(u8 *dosname, s32 count)
-{
-	int i, j, length;
-	char str_count[6];
-
-	snprintf(str_count, sizeof(str_count), "~%d", count);
-	length = strlen(str_count);
-
-	i = 0;
-	j = 0;
-	while (j &lt;= (8 - length)) {
-		i = j;
-		if (dosname[j] == ' ')
-			break;
-		if (dosname[j] &amp; 0x80)
-			j += 2;
-		else
-			j++;
-	}
-
-	for (j = 0; j &lt; length; i++, j++)
-		dosname[i] = (u8)str_count[j];
-
-	if (i == 7)
-		dosname[7] = ' ';
-}
-
 s32 exfat_calc_num_entries(struct uni_name_t *p_uniname)
 {
 	s32 len;
diff --git a/drivers/staging/exfat/exfat_nls.c b/drivers/staging/exfat/exfat_nls.c
index a5c4b68925fb..91e8b0c4dce7 100644
--- a/drivers/staging/exfat/exfat_nls.c
+++ b/drivers/staging/exfat/exfat_nls.c
@@ -7,13 +7,6 @@
 #include &lt;linux/nls.h&gt;
 #include "exfat.h"
 
-static u16 bad_dos_chars[] = {
-	/* + , ; = [ ] */
-	0x002B, 0x002C, 0x003B, 0x003D, 0x005B, 0x005D,
-	0xFF0B, 0xFF0C, 0xFF1B, 0xFF1D, 0xFF3B, 0xFF3D,
-	0
-};
-
 static u16 bad_uni_chars[] = {
 	/* " * / : &lt; &gt; ? \ | */
 	0x0022,         0x002A, 0x002F, 0x003A,
@@ -96,11 +89,6 @@ static u16 *nls_wstrchr(u16 *str, u16 wchar)
 	return NULL;
 }
 
-int nls_dosname_cmp(struct super_block *sb, u8 *a, u8 *b)
-{
-	return strncmp(a, b, DOS_NAME_LENGTH);
-}
-
 int nls_uniname_cmp(struct super_block *sb, u16 *a, u16 *b)
 {
 	int i;
@@ -114,186 +102,6 @@ int nls_uniname_cmp(struct super_block *sb, u16 *a, u16 *b)
 	return 0;
 }
 
-void nls_uniname_to_dosname(struct super_block *sb,
-			    struct dos_name_t *p_dosname,
-			    struct uni_name_t *p_uniname, bool *p_lossy)
-{
-	int i, j, len;
-	bool lossy = false;
-	u8 buf[MAX_CHARSET_SIZE];
-	u8 lower = 0, upper = 0;
-	u8 *dosname = p_dosname-&gt;name;
-	u16 *uniname = p_uniname-&gt;name;
-	u16 *p, *last_period;
-	struct nls_table *nls = EXFAT_SB(sb)-&gt;nls_disk;
-
-	for (i = 0; i &lt; DOS_NAME_LENGTH; i++)
-		*(dosname + i) = ' ';
-
-	if (!nls_uniname_cmp(sb, uniname, (u16 *)UNI_CUR_DIR_NAME)) {
-		*(dosname) = '.';
-		p_dosname-&gt;name_case = 0x0;
-		if (p_lossy)
-			*p_lossy = false;
-		return;
-	}
-
-	if (!nls_uniname_cmp(sb, uniname, (u16 *)UNI_PAR_DIR_NAME)) {
-		*(dosname) = '.';
-		*(dosname + 1) = '.';
-		p_dosname-&gt;name_case = 0x0;
-		if (p_lossy)
-			*p_lossy = false;
-		return;
-	}
-
-	/* search for the last embedded period */
-	last_period = NULL;
-	for (p = uniname; *p; p++) {
-		if (*p == (u16)'.')
-			last_period = p;
-	}
-
-	i = 0;
-	while (i &lt; DOS_NAME_LENGTH) {
-		if (i == 8) {
-			if (!last_period)
-				break;
-
-			if (uniname &lt;= last_period) {
-				if (uniname &lt; last_period)
-					lossy = true;
-				uniname = last_period + 1;
-			}
-		}
-
-		if (*uniname == (u16)'\0') {
-			break;
-		} else if (*uniname == (u16)' ') {
-			lossy = true;
-		} else if (*uniname == (u16)'.') {
-			if (uniname &lt; last_period)
-				lossy = true;
-			else
-				i = 8;
-		} else if (nls_wstrchr(bad_dos_chars, *uniname)) {
-			lossy = true;
-			*(dosname + i) = '_';
-			i++;
-		} else {
-			len = convert_uni_to_ch(nls, buf, *uniname, &amp;lossy);
-
-			if (len &gt; 1) {
-				if ((i &gt;= 8) &amp;&amp; ((i + len) &gt; DOS_NAME_LENGTH))
-					break;
-
-				if ((i &lt; 8) &amp;&amp; ((i + len) &gt; 8)) {
-					i = 8;
-					continue;
-				}
-
-				lower = 0xFF;
-
-				for (j = 0; j &lt; len; j++, i++)
-					*(dosname + i) = *(buf + j);
-			} else { /* len == 1 */
-				if ((*buf &gt;= 'a') &amp;&amp; (*buf &lt;= 'z')) {
-					*(dosname + i) = *buf - ('a' - 'A');
-
-					if (i &lt; 8)
-						lower |= 0x08;
-					else
-						lower |= 0x10;
-				} else if ((*buf &gt;= 'A') &amp;&amp; (*buf &lt;= 'Z')) {
-					*(dosname + i) = *buf;
-
-					if (i &lt; 8)
-						upper |= 0x08;
-					else
-						upper |= 0x10;
-				} else {
-					*(dosname + i) = *buf;
-				}
-				i++;
-			}
-		}
-
-		uniname++;
-	}
-
-	if (*dosname == 0xE5)
-		*dosname = 0x05;
-
-	if (*uniname != 0x0)
-		lossy = true;
-
-	if (upper &amp; lower)
-		p_dosname-&gt;name_case = 0xFF;
-	else
-		p_dosname-&gt;name_case = lower;
-
-	if (p_lossy)
-		*p_lossy = lossy;
-}
-
-void nls_dosname_to_uniname(struct super_block *sb,
-			    struct uni_name_t *p_uniname,
-			    struct dos_name_t *p_dosname)
-{
-	int i = 0, j, n = 0;
-	u8 buf[DOS_NAME_LENGTH + 2];
-	u8 *dosname = p_dosname-&gt;name;
-	u16 *uniname = p_uniname-&gt;name;
-	struct nls_table *nls = EXFAT_SB(sb)-&gt;nls_disk;
-
-	if (*dosname == 0x05) {
-		*buf = 0xE5;
-		i++;
-		n++;
-	}
-
-	for (; i &lt; 8; i++, n++) {
-		if (*(dosname + i) == ' ')
-			break;
-
-		if ((*(dosname + i) &gt;= 'A') &amp;&amp; (*(dosname + i) &lt;= 'Z') &amp;&amp;
-		    (p_dosname-&gt;name_case &amp; 0x08))
-			*(buf + n) = *(dosname + i) + ('a' - 'A');
-		else
-			*(buf + n) = *(dosname + i);
-	}
-	if (*(dosname + 8) != ' ') {
-		*(buf + n) = '.';
-		n++;
-	}
-
-	for (i = 8; i &lt; DOS_NAME_LENGTH; i++, n++) {
-		if (*(dosname + i) == ' ')
-			break;
-
-		if ((*(dosname + i) &gt;= 'A') &amp;&amp; (*(dosname + i) &lt;= 'Z') &amp;&amp;
-		    (p_dosname-&gt;name_case &amp; 0x10))
-			*(buf + n) = *(dosname + i) + ('a' - 'A');
-		else
-			*(buf + n) = *(dosname + i);
-	}
-	*(buf + n) = '\0';
-
-	i = 0;
-	j = 0;
-	while (j &lt; (MAX_NAME_LENGTH - 1)) {
-		if (*(buf + i) == '\0')
-			break;
-
-		i += convert_ch_to_uni(nls, uniname, (buf + i), NULL);
-
-		uniname++;
-		j++;
-	}
-
-	*uniname = (u16)'\0';
-}
-
 void nls_uniname_to_cstring(struct super_block *sb, u8 *p_cstring,
 			    struct uni_name_t *p_uniname)
 {</pre><hr><pre>commit 2a17b09fdecd580c88a5b80fd7ccd33bee576e4d
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Tue Nov 12 16:12:29 2019 -0500

    staging: exfat: Remove FAT/VFAT mount support, part 3
    
    In this patch, we straighten out most of the cases where the
    code was testing 'p_fs-&gt;vol_type == EXFAT' and '!= EXFAT'
    
    There's still some ?: ops and a few places where the code
    is doing checks for '.' and '..' that require looking at,
    but those are future patches
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112211238.156490-4-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat_cache.c b/drivers/staging/exfat/exfat_cache.c
index 28a67f8139ea..1d344c5f3e15 100644
--- a/drivers/staging/exfat/exfat_cache.c
+++ b/drivers/staging/exfat/exfat_cache.c
@@ -202,107 +202,22 @@ static int __FAT_read(struct super_block *sb, u32 loc, u32 *content)
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
 	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
 
-	if (p_fs-&gt;vol_type == FAT12) {
-		sec = p_fs-&gt;FAT1_start_sector +
-			((loc + (loc &gt;&gt; 1)) &gt;&gt; p_bd-&gt;sector_size_bits);
-		off = (loc + (loc &gt;&gt; 1)) &amp; p_bd-&gt;sector_size_mask;
-
-		if (off == (p_bd-&gt;sector_size - 1)) {
-			fat_sector = FAT_getblk(sb, sec);
-			if (!fat_sector)
-				return -1;
-
-			_content = (u32)fat_sector[off];
-
-			fat_sector = FAT_getblk(sb, ++sec);
-			if (!fat_sector)
-				return -1;
-
-			_content |= (u32)fat_sector[0] &lt;&lt; 8;
-		} else {
-			fat_sector = FAT_getblk(sb, sec);
-			if (!fat_sector)
-				return -1;
-
-			fat_entry = &amp;fat_sector[off];
-			_content = GET16(fat_entry);
-		}
-
-		if (loc &amp; 1)
-			_content &gt;&gt;= 4;
-
-		_content &amp;= 0x00000FFF;
-
-		if (_content &gt;= CLUSTER_16(0x0FF8)) {
-			*content = CLUSTER_32(~0);
-			return 0;
-		}
-		*content = CLUSTER_32(_content);
-		return 0;
-	} else if (p_fs-&gt;vol_type == FAT16) {
-		sec = p_fs-&gt;FAT1_start_sector +
-			(loc &gt;&gt; (p_bd-&gt;sector_size_bits - 1));
-		off = (loc &lt;&lt; 1) &amp; p_bd-&gt;sector_size_mask;
-
-		fat_sector = FAT_getblk(sb, sec);
-		if (!fat_sector)
-			return -1;
-
-		fat_entry = &amp;fat_sector[off];
-
-		_content = GET16_A(fat_entry);
-
-		_content &amp;= 0x0000FFFF;
-
-		if (_content &gt;= CLUSTER_16(0xFFF8)) {
-			*content = CLUSTER_32(~0);
-			return 0;
-		}
-		*content = CLUSTER_32(_content);
-		return 0;
-	} else if (p_fs-&gt;vol_type == FAT32) {
-		sec = p_fs-&gt;FAT1_start_sector +
-			(loc &gt;&gt; (p_bd-&gt;sector_size_bits - 2));
-		off = (loc &lt;&lt; 2) &amp; p_bd-&gt;sector_size_mask;
-
-		fat_sector = FAT_getblk(sb, sec);
-		if (!fat_sector)
-			return -1;
+	sec = p_fs-&gt;FAT1_start_sector +
+		(loc &gt;&gt; (p_bd-&gt;sector_size_bits - 2));
+	off = (loc &lt;&lt; 2) &amp; p_bd-&gt;sector_size_mask;
 
-		fat_entry = &amp;fat_sector[off];
+	fat_sector = FAT_getblk(sb, sec);
+	if (!fat_sector)
+		return -1;
 
-		_content = GET32_A(fat_entry);
+	fat_entry = &amp;fat_sector[off];
+	_content = GET32_A(fat_entry);
 
-		_content &amp;= 0x0FFFFFFF;
-
-		if (_content &gt;= CLUSTER_32(0x0FFFFFF8)) {
-			*content = CLUSTER_32(~0);
-			return 0;
-		}
-		*content = CLUSTER_32(_content);
-		return 0;
-	} else if (p_fs-&gt;vol_type == EXFAT) {
-		sec = p_fs-&gt;FAT1_start_sector +
-			(loc &gt;&gt; (p_bd-&gt;sector_size_bits - 2));
-		off = (loc &lt;&lt; 2) &amp; p_bd-&gt;sector_size_mask;
-
-		fat_sector = FAT_getblk(sb, sec);
-		if (!fat_sector)
-			return -1;
-
-		fat_entry = &amp;fat_sector[off];
-		_content = GET32_A(fat_entry);
-
-		if (_content &gt;= CLUSTER_32(0xFFFFFFF8)) {
-			*content = CLUSTER_32(~0);
-			return 0;
-		}
-		*content = CLUSTER_32(_content);
+	if (_content &gt;= CLUSTER_32(0xFFFFFFF8)) {
+		*content = CLUSTER_32(~0);
 		return 0;
 	}
-
-	/* Unknown volume type, throw in the towel and go home */
-	*content = CLUSTER_32(~0);
+	*content = CLUSTER_32(_content);
 	return 0;
 }
 
@@ -330,101 +245,17 @@ static s32 __FAT_write(struct super_block *sb, u32 loc, u32 content)
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
 	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
 
-	if (p_fs-&gt;vol_type == FAT12) {
-		content &amp;= 0x00000FFF;
+	sec = p_fs-&gt;FAT1_start_sector + (loc &gt;&gt;
+					 (p_bd-&gt;sector_size_bits - 2));
+	off = (loc &lt;&lt; 2) &amp; p_bd-&gt;sector_size_mask;
 
-		sec = p_fs-&gt;FAT1_start_sector +
-			((loc + (loc &gt;&gt; 1)) &gt;&gt; p_bd-&gt;sector_size_bits);
-		off = (loc + (loc &gt;&gt; 1)) &amp; p_bd-&gt;sector_size_mask;
+	fat_sector = FAT_getblk(sb, sec);
+	if (!fat_sector)
+		return -1;
 
-		fat_sector = FAT_getblk(sb, sec);
-		if (!fat_sector)
-			return -1;
+	fat_entry = &amp;fat_sector[off];
 
-		if (loc &amp; 1) { /* odd */
-			content &lt;&lt;= 4;
-
-			if (off == (p_bd-&gt;sector_size - 1)) {
-				fat_sector[off] = (u8)(content |
-						       (fat_sector[off] &amp;
-							0x0F));
-				FAT_modify(sb, sec);
-
-				fat_sector = FAT_getblk(sb, ++sec);
-				if (!fat_sector)
-					return -1;
-
-				fat_sector[0] = (u8)(content &gt;&gt; 8);
-			} else {
-				fat_entry = &amp;fat_sector[off];
-				content |= GET16(fat_entry) &amp; 0x000F;
-
-				SET16(fat_entry, content);
-			}
-		} else { /* even */
-			fat_sector[off] = (u8)(content);
-
-			if (off == (p_bd-&gt;sector_size - 1)) {
-				fat_sector[off] = (u8)(content);
-				FAT_modify(sb, sec);
-
-				fat_sector = FAT_getblk(sb, ++sec);
-				if (!fat_sector)
-					return -1;
-				fat_sector[0] = (u8)((fat_sector[0] &amp; 0xF0) |
-						     (content &gt;&gt; 8));
-			} else {
-				fat_entry = &amp;fat_sector[off];
-				content |= GET16(fat_entry) &amp; 0xF000;
-
-				SET16(fat_entry, content);
-			}
-		}
-	}
-
-	else if (p_fs-&gt;vol_type == FAT16) {
-		content &amp;= 0x0000FFFF;
-
-		sec = p_fs-&gt;FAT1_start_sector + (loc &gt;&gt;
-						 (p_bd-&gt;sector_size_bits - 1));
-		off = (loc &lt;&lt; 1) &amp; p_bd-&gt;sector_size_mask;
-
-		fat_sector = FAT_getblk(sb, sec);
-		if (!fat_sector)
-			return -1;
-
-		fat_entry = &amp;fat_sector[off];
-
-		SET16_A(fat_entry, content);
-	} else if (p_fs-&gt;vol_type == FAT32) {
-		content &amp;= 0x0FFFFFFF;
-
-		sec = p_fs-&gt;FAT1_start_sector + (loc &gt;&gt;
-						 (p_bd-&gt;sector_size_bits - 2));
-		off = (loc &lt;&lt; 2) &amp; p_bd-&gt;sector_size_mask;
-
-		fat_sector = FAT_getblk(sb, sec);
-		if (!fat_sector)
-			return -1;
-
-		fat_entry = &amp;fat_sector[off];
-
-		content |= GET32_A(fat_entry) &amp; 0xF0000000;
-
-		SET32_A(fat_entry, content);
-	} else { /* p_fs-&gt;vol_type == EXFAT */
-		sec = p_fs-&gt;FAT1_start_sector + (loc &gt;&gt;
-						 (p_bd-&gt;sector_size_bits - 2));
-		off = (loc &lt;&lt; 2) &amp; p_bd-&gt;sector_size_mask;
-
-		fat_sector = FAT_getblk(sb, sec);
-		if (!fat_sector)
-			return -1;
-
-		fat_entry = &amp;fat_sector[off];
-
-		SET32_A(fat_entry, content);
-	}
+	SET32_A(fat_entry, content);
 
 	FAT_modify(sb, sec);
 	return 0;
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index ed9e4521ec04..77b826dfdeda 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -20,15 +20,6 @@ static void __set_sb_dirty(struct super_block *sb)
 
 static u8 name_buf[MAX_PATH_LENGTH * MAX_CHARSET_SIZE];
 
-static char *reserved_names[] = {
-	"AUX     ", "CON     ", "NUL     ", "PRN     ",
-	"COM1    ", "COM2    ", "COM3    ", "COM4    ",
-	"COM5    ", "COM6    ", "COM7    ", "COM8    ", "COM9    ",
-	"LPT1    ", "LPT2    ", "LPT3    ", "LPT4    ",
-	"LPT5    ", "LPT6    ", "LPT7    ", "LPT8    ", "LPT9    ",
-	NULL
-};
-
 static u8 free_bit[] = {
 	0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, /*   0 ~  19 */
 	0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, /*  20 ~  39 */
@@ -99,25 +90,23 @@ void fs_set_vol_flags(struct super_block *sb, u32 new_flag)
 
 	p_fs-&gt;vol_flag = new_flag;
 
-	if (p_fs-&gt;vol_type == EXFAT) {
-		if (!p_fs-&gt;pbr_bh) {
-			if (sector_read(sb, p_fs-&gt;PBR_sector,
-					&amp;p_fs-&gt;pbr_bh, 1) != 0)
-				return;
-		}
+	if (!p_fs-&gt;pbr_bh) {
+		if (sector_read(sb, p_fs-&gt;PBR_sector,
+				&amp;p_fs-&gt;pbr_bh, 1) != 0)
+			return;
+	}
 
-		p_pbr = (struct pbr_sector_t *)p_fs-&gt;pbr_bh-&gt;b_data;
-		p_bpb = (struct bpbex_t *)p_pbr-&gt;bpb;
-		SET16(p_bpb-&gt;vol_flags, (u16)new_flag);
+	p_pbr = (struct pbr_sector_t *)p_fs-&gt;pbr_bh-&gt;b_data;
+	p_bpb = (struct bpbex_t *)p_pbr-&gt;bpb;
+	SET16(p_bpb-&gt;vol_flags, (u16)new_flag);
 
-		/* XXX duyoung
-		 * what can we do here? (cuz fs_set_vol_flags() is void)
-		 */
-		if ((new_flag == VOL_DIRTY) &amp;&amp; (!buffer_dirty(p_fs-&gt;pbr_bh)))
-			sector_write(sb, p_fs-&gt;PBR_sector, p_fs-&gt;pbr_bh, 1);
-		else
-			sector_write(sb, p_fs-&gt;PBR_sector, p_fs-&gt;pbr_bh, 0);
-	}
+	/* XXX duyoung
+	 * what can we do here? (cuz fs_set_vol_flags() is void)
+	 */
+	if ((new_flag == VOL_DIRTY) &amp;&amp; (!buffer_dirty(p_fs-&gt;pbr_bh)))
+		sector_write(sb, p_fs-&gt;PBR_sector, p_fs-&gt;pbr_bh, 1);
+	else
+		sector_write(sb, p_fs-&gt;PBR_sector, p_fs-&gt;pbr_bh, 0);
 }
 
 void fs_error(struct super_block *sb)
@@ -1613,10 +1602,8 @@ s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir, s32 num_entries
 		if (p_fs-&gt;dev_ejected)
 			break;
 
-		if (p_fs-&gt;vol_type == EXFAT) {
-			if (p_dir-&gt;dir != p_fs-&gt;root_dir)
-				size = i_size_read(inode);
-		}
+		if (p_dir-&gt;dir != p_fs-&gt;root_dir)
+			size = i_size_read(inode);
 
 		last_clu = find_last_cluster(sb, p_dir);
 		clu.dir = last_clu + 1;
@@ -1653,21 +1640,19 @@ s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir, s32 num_entries
 		p_dir-&gt;size++;
 
 		/* (3) update the directory entry */
-		if (p_fs-&gt;vol_type == EXFAT) {
-			if (p_dir-&gt;dir != p_fs-&gt;root_dir) {
-				size += p_fs-&gt;cluster_size;
-
-				ep = get_entry_in_dir(sb, &amp;fid-&gt;dir,
-						      fid-&gt;entry + 1, &amp;sector);
-				if (!ep)
-					return -ENOENT;
-				p_fs-&gt;fs_func-&gt;set_entry_size(ep, size);
-				p_fs-&gt;fs_func-&gt;set_entry_flag(ep, p_dir-&gt;flags);
-				buf_modify(sb, sector);
-
-				update_dir_checksum(sb, &amp;fid-&gt;dir,
-						    fid-&gt;entry);
-			}
+		if (p_dir-&gt;dir != p_fs-&gt;root_dir) {
+			size += p_fs-&gt;cluster_size;
+
+			ep = get_entry_in_dir(sb, &amp;fid-&gt;dir,
+					      fid-&gt;entry + 1, &amp;sector);
+			if (!ep)
+				return -ENOENT;
+			p_fs-&gt;fs_func-&gt;set_entry_size(ep, size);
+			p_fs-&gt;fs_func-&gt;set_entry_flag(ep, p_dir-&gt;flags);
+			buf_modify(sb, sector);
+
+			update_dir_checksum(sb, &amp;fid-&gt;dir,
+					    fid-&gt;entry);
 		}
 
 		i_size_write(inode, i_size_read(inode) + p_fs-&gt;cluster_size);
@@ -1979,36 +1964,13 @@ s32 get_num_entries_and_dos_name(struct super_block *sb, struct chain_t *p_dir,
 				 struct uni_name_t *p_uniname, s32 *entries,
 				 struct dos_name_t *p_dosname)
 {
-	s32 ret, num_entries;
-	bool lossy = false;
-	char **r;
+	s32 num_entries;
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
 
 	num_entries = p_fs-&gt;fs_func-&gt;calc_num_entries(p_uniname);
 	if (num_entries == 0)
 		return -EINVAL;
 
-	if (p_fs-&gt;vol_type != EXFAT) {
-		nls_uniname_to_dosname(sb, p_dosname, p_uniname, &amp;lossy);
-
-		if (lossy) {
-			ret = fat_generate_dos_name(sb, p_dir, p_dosname);
-			if (ret)
-				return ret;
-		} else {
-			for (r = reserved_names; *r; r++) {
-				if (!strncmp((void *)p_dosname-&gt;name, *r, 8))
-					return -EINVAL;
-			}
-
-			if (p_dosname-&gt;name_case != 0xFF)
-				num_entries = 1;
-		}
-
-		if (num_entries &gt; 1)
-			p_dosname-&gt;name_case = 0x0;
-	}
-
 	*entries = num_entries;
 
 	return 0;
@@ -2392,7 +2354,7 @@ s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 	s32 ret, dentry, num_entries;
 	u64 size;
 	struct chain_t clu;
-	struct dos_name_t dos_name, dot_name;
+	struct dos_name_t dos_name;
 	struct super_block *sb = inode-&gt;i_sb;
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
 	struct fs_func *fs_func = p_fs-&gt;fs_func;
@@ -2422,45 +2384,7 @@ s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 	if (ret != 0)
 		return ret;
 
-	if (p_fs-&gt;vol_type == EXFAT) {
-		size = p_fs-&gt;cluster_size;
-	} else {
-		size = 0;
-
-		/* initialize the . and .. entry
-		 * Information for . points to itself
-		 * Information for .. points to parent dir
-		 */
-
-		dot_name.name_case = 0x0;
-		memcpy(dot_name.name, DOS_CUR_DIR_NAME, DOS_NAME_LENGTH);
-
-		ret = fs_func-&gt;init_dir_entry(sb, &amp;clu, 0, TYPE_DIR, clu.dir,
-					      0);
-		if (ret != 0)
-			return ret;
-
-		ret = fs_func-&gt;init_ext_entry(sb, &amp;clu, 0, 1, NULL, &amp;dot_name);
-		if (ret != 0)
-			return ret;
-
-		memcpy(dot_name.name, DOS_PAR_DIR_NAME, DOS_NAME_LENGTH);
-
-		if (p_dir-&gt;dir == p_fs-&gt;root_dir)
-			ret = fs_func-&gt;init_dir_entry(sb, &amp;clu, 1, TYPE_DIR,
-						      CLUSTER_32(0), 0);
-		else
-			ret = fs_func-&gt;init_dir_entry(sb, &amp;clu, 1, TYPE_DIR,
-						      p_dir-&gt;dir, 0);
-
-		if (ret != 0)
-			return ret;
-
-		ret = p_fs-&gt;fs_func-&gt;init_ext_entry(sb, &amp;clu, 1, 1, NULL,
-						    &amp;dot_name);
-		if (ret != 0)
-			return ret;
-	}
+	size = p_fs-&gt;cluster_size;
 
 	/* (2) update the directory entry */
 	/* make sub-dir entry in parent directory */
@@ -2626,23 +2550,21 @@ s32 rename_file(struct inode *inode, struct chain_t *p_dir, s32 oldentry,
 		buf_modify(sb, sector_new);
 		buf_unlock(sb, sector_old);
 
-		if (p_fs-&gt;vol_type == EXFAT) {
-			epold = get_entry_in_dir(sb, p_dir, oldentry + 1,
-						 &amp;sector_old);
-			buf_lock(sb, sector_old);
-			epnew = get_entry_in_dir(sb, p_dir, newentry + 1,
-						 &amp;sector_new);
-
-			if (!epold || !epnew) {
-				buf_unlock(sb, sector_old);
-				return -ENOENT;
-			}
+		epold = get_entry_in_dir(sb, p_dir, oldentry + 1,
+					 &amp;sector_old);
+		buf_lock(sb, sector_old);
+		epnew = get_entry_in_dir(sb, p_dir, newentry + 1,
+					 &amp;sector_new);
 
-			memcpy((void *)epnew, (void *)epold, DENTRY_SIZE);
-			buf_modify(sb, sector_new);
+		if (!epold || !epnew) {
 			buf_unlock(sb, sector_old);
+			return -ENOENT;
 		}
 
+		memcpy((void *)epnew, (void *)epold, DENTRY_SIZE);
+		buf_modify(sb, sector_new);
+		buf_unlock(sb, sector_old);
+
 		ret = fs_func-&gt;init_ext_entry(sb, p_dir, newentry,
 					      num_new_entries, p_uniname,
 					      &amp;dos_name);
@@ -2681,7 +2603,6 @@ s32 move_file(struct inode *inode, struct chain_t *p_olddir, s32 oldentry,
 {
 	s32 ret, newentry, num_new_entries, num_old_entries;
 	sector_t sector_mov, sector_new;
-	struct chain_t clu;
 	struct dos_name_t dos_name;
 	struct dentry_t *epmov, *epnew;
 	struct super_block *sb = inode-&gt;i_sb;
@@ -2736,36 +2657,20 @@ s32 move_file(struct inode *inode, struct chain_t *p_olddir, s32 oldentry,
 	buf_modify(sb, sector_new);
 	buf_unlock(sb, sector_mov);
 
-	if (p_fs-&gt;vol_type == EXFAT) {
-		epmov = get_entry_in_dir(sb, p_olddir, oldentry + 1,
-					 &amp;sector_mov);
-		buf_lock(sb, sector_mov);
-		epnew = get_entry_in_dir(sb, p_newdir, newentry + 1,
-					 &amp;sector_new);
-		if (!epmov || !epnew) {
-			buf_unlock(sb, sector_mov);
-			return -ENOENT;
-		}
-
-		memcpy((void *)epnew, (void *)epmov, DENTRY_SIZE);
-		buf_modify(sb, sector_new);
+	epmov = get_entry_in_dir(sb, p_olddir, oldentry + 1,
+				 &amp;sector_mov);
+	buf_lock(sb, sector_mov);
+	epnew = get_entry_in_dir(sb, p_newdir, newentry + 1,
+				 &amp;sector_new);
+	if (!epmov || !epnew) {
 		buf_unlock(sb, sector_mov);
-	} else if (fs_func-&gt;get_entry_type(epnew) == TYPE_DIR) {
-		/* change ".." pointer to new parent dir */
-		clu.dir = fs_func-&gt;get_entry_clu0(epnew);
-		clu.flags = 0x01;
-
-		epnew = get_entry_in_dir(sb, &amp;clu, 1, &amp;sector_new);
-		if (!epnew)
-			return -ENOENT;
-
-		if (p_newdir-&gt;dir == p_fs-&gt;root_dir)
-			fs_func-&gt;set_entry_clu0(epnew, CLUSTER_32(0));
-		else
-			fs_func-&gt;set_entry_clu0(epnew, p_newdir-&gt;dir);
-		buf_modify(sb, sector_new);
+		return -ENOENT;
 	}
 
+	memcpy((void *)epnew, (void *)epmov, DENTRY_SIZE);
+	buf_modify(sb, sector_new);
+	buf_unlock(sb, sector_mov);
+
 	ret = fs_func-&gt;init_ext_entry(sb, p_newdir, newentry, num_new_entries,
 				      p_uniname, &amp;dos_name);
 	if (ret != 0)
diff --git a/drivers/staging/exfat/exfat_super.c b/drivers/staging/exfat/exfat_super.c
index 0ebf342122da..259cb5a7bd81 100644
--- a/drivers/staging/exfat/exfat_super.c
+++ b/drivers/staging/exfat/exfat_super.c
@@ -411,25 +411,21 @@ static int ffsMountVol(struct super_block *sb)
 		goto out;
 	}
 
-	if (p_fs-&gt;vol_type == EXFAT) {
-		ret = load_alloc_bitmap(sb);
-		if (ret) {
-			bdev_close(sb);
-			goto out;
-		}
-		ret = load_upcase_table(sb);
-		if (ret) {
-			free_alloc_bitmap(sb);
-			bdev_close(sb);
-			goto out;
-		}
+	ret = load_alloc_bitmap(sb);
+	if (ret) {
+		bdev_close(sb);
+		goto out;
+	}
+	ret = load_upcase_table(sb);
+	if (ret) {
+		free_alloc_bitmap(sb);
+		bdev_close(sb);
+		goto out;
 	}
 
 	if (p_fs-&gt;dev_ejected) {
-		if (p_fs-&gt;vol_type == EXFAT) {
-			free_upcase_table(sb);
-			free_alloc_bitmap(sb);
-		}
+		free_upcase_table(sb);
+		free_alloc_bitmap(sb);
 		bdev_close(sb);
 		ret = -EIO;
 		goto out;
@@ -458,10 +454,8 @@ static int ffsUmountVol(struct super_block *sb)
 	fs_sync(sb, true);
 	fs_set_vol_flags(sb, VOL_CLEAN);
 
-	if (p_fs-&gt;vol_type == EXFAT) {
-		free_upcase_table(sb);
-		free_alloc_bitmap(sb);
-	}
+	free_upcase_table(sb);
+	free_alloc_bitmap(sb);
 
 	FAT_release_all(sb);
 	buf_release_all(sb);
@@ -593,22 +587,13 @@ static int ffsLookupFile(struct inode *inode, char *path, struct file_id_t *fid)
 		fid-&gt;size = 0;
 		fid-&gt;start_clu = p_fs-&gt;root_dir;
 	} else {
-		if (p_fs-&gt;vol_type == EXFAT) {
-			es = get_entry_set_in_dir(sb, &amp;dir, dentry,
-						  ES_2_ENTRIES, &amp;ep);
-			if (!es) {
-				ret =  -ENOENT;
-				goto out;
-			}
-			ep2 = ep + 1;
-		} else {
-			ep = get_entry_in_dir(sb, &amp;dir, dentry, NULL);
-			if (!ep) {
-				ret =  -ENOENT;
-				goto out;
-			}
-			ep2 = ep;
+		es = get_entry_set_in_dir(sb, &amp;dir, dentry,
+					  ES_2_ENTRIES, &amp;ep);
+		if (!es) {
+			ret =  -ENOENT;
+			goto out;
 		}
+		ep2 = ep + 1;
 
 		fid-&gt;type = p_fs-&gt;fs_func-&gt;get_entry_type(ep);
 		fid-&gt;rwoffset = 0;
@@ -624,8 +609,7 @@ static int ffsLookupFile(struct inode *inode, char *path, struct file_id_t *fid)
 			fid-&gt;start_clu = p_fs-&gt;fs_func-&gt;get_entry_clu0(ep2);
 		}
 
-		if (p_fs-&gt;vol_type == EXFAT)
-			release_entry_set(es);
+		release_entry_set(es);
 	}
 
 	if (p_fs-&gt;dev_ejected)
@@ -812,7 +796,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 	s32 num_clusters, num_alloc, num_alloced = (s32)~0;
 	int ret = 0;
 	u32 clu, last_clu;
-	sector_t LogSector, sector = 0;
+	sector_t LogSector;
 	u64 oneblkwrite, write_bytes;
 	struct chain_t new_clu;
 	struct timestamp_t tm;
@@ -1001,25 +985,15 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 	brelse(tmp_bh);
 
 	/* (3) update the direcoty entry */
-	if (p_fs-&gt;vol_type == EXFAT) {
-		es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
-					  ES_ALL_ENTRIES, &amp;ep);
-		if (!es)
-			goto err_out;
-		ep2 = ep + 1;
-	} else {
-		ep = get_entry_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry, &amp;sector);
-		if (!ep)
-			goto err_out;
-		ep2 = ep;
-	}
+	es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
+				  ES_ALL_ENTRIES, &amp;ep);
+	if (!es)
+		goto err_out;
+	ep2 = ep + 1;
 
 	p_fs-&gt;fs_func-&gt;set_entry_time(ep, tm_current(&amp;tm), TM_MODIFY);
 	p_fs-&gt;fs_func-&gt;set_entry_attr(ep, fid-&gt;attr);
 
-	if (p_fs-&gt;vol_type != EXFAT)
-		buf_modify(sb, sector);
-
 	if (modified) {
 		if (p_fs-&gt;fs_func-&gt;get_entry_flag(ep2) != fid-&gt;flags)
 			p_fs-&gt;fs_func-&gt;set_entry_flag(ep2, fid-&gt;flags);
@@ -1029,15 +1003,10 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 
 		if (p_fs-&gt;fs_func-&gt;get_entry_clu0(ep2) != fid-&gt;start_clu)
 			p_fs-&gt;fs_func-&gt;set_entry_clu0(ep2, fid-&gt;start_clu);
-
-		if (p_fs-&gt;vol_type != EXFAT)
-			buf_modify(sb, sector);
 	}
 
-	if (p_fs-&gt;vol_type == EXFAT) {
-		update_dir_checksum_with_entry_set(sb, es);
-		release_entry_set(es);
-	}
+	update_dir_checksum_with_entry_set(sb, es);
+	release_entry_set(es);
 
 #ifndef CONFIG_EXFAT_DELAYED_SYNC
 	fs_sync(sb, true);
@@ -1067,7 +1036,6 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 	s32 num_clusters;
 	u32 last_clu = CLUSTER_32(0);
 	int ret = 0;
-	sector_t sector = 0;
 	struct chain_t clu;
 	struct timestamp_t tm;
 	struct dentry_t *ep, *ep2;
@@ -1132,22 +1100,13 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 	}
 
 	/* (1) update the directory entry */
-	if (p_fs-&gt;vol_type == EXFAT) {
-		es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
-					  ES_ALL_ENTRIES, &amp;ep);
-		if (!es) {
-			ret = -ENOENT;
-			goto out;
-			}
-		ep2 = ep + 1;
-	} else {
-		ep = get_entry_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry, &amp;sector);
-		if (!ep) {
-			ret = -ENOENT;
-			goto out;
+	es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
+				  ES_ALL_ENTRIES, &amp;ep);
+	if (!es) {
+		ret = -ENOENT;
+		goto out;
 		}
-		ep2 = ep;
-	}
+	ep2 = ep + 1;
 
 	p_fs-&gt;fs_func-&gt;set_entry_time(ep, tm_current(&amp;tm), TM_MODIFY);
 	p_fs-&gt;fs_func-&gt;set_entry_attr(ep, fid-&gt;attr);
@@ -1158,12 +1117,8 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 		p_fs-&gt;fs_func-&gt;set_entry_clu0(ep2, CLUSTER_32(0));
 	}
 
-	if (p_fs-&gt;vol_type != EXFAT) {
-		buf_modify(sb, sector);
-	} else {
-		update_dir_checksum_with_entry_set(sb, es);
-		release_entry_set(es);
-	}
+	update_dir_checksum_with_entry_set(sb, es);
+	release_entry_set(es);
 
 	/* (2) cut off from the FAT chain */
 	if (last_clu != CLUSTER_32(0)) {
@@ -1436,19 +1391,11 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 	mutex_lock(&amp;p_fs-&gt;v_mutex);
 
 	/* get the directory entry of given file */
-	if (p_fs-&gt;vol_type == EXFAT) {
-		es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
-					  ES_ALL_ENTRIES, &amp;ep);
-		if (!es) {
-			ret = -ENOENT;
-			goto out;
-		}
-	} else {
-		ep = get_entry_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry, &amp;sector);
-		if (!ep) {
-			ret = -ENOENT;
-			goto out;
-		}
+	es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
+				  ES_ALL_ENTRIES, &amp;ep);
+	if (!es) {
+		ret = -ENOENT;
+		goto out;
 	}
 
 	type = p_fs-&gt;fs_func-&gt;get_entry_type(ep);
@@ -1460,8 +1407,7 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 		else
 			ret = -EINVAL;
 
-		if (p_fs-&gt;vol_type == EXFAT)
-			release_entry_set(es);
+		release_entry_set(es);
 		goto out;
 	}
 
@@ -1471,12 +1417,8 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 	fid-&gt;attr = attr;
 	p_fs-&gt;fs_func-&gt;set_entry_attr(ep, attr);
 
-	if (p_fs-&gt;vol_type != EXFAT) {
-		buf_modify(sb, sector);
-	} else {
-		update_dir_checksum_with_entry_set(sb, es);
-		release_entry_set(es);
-	}
+	update_dir_checksum_with_entry_set(sb, es);
+	release_entry_set(es);
 
 #ifndef CONFIG_EXFAT_DELAYED_SYNC
 	fs_sync(sb, true);
@@ -1495,7 +1437,6 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 
 static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 {
-	sector_t sector = 0;
 	s32 count;
 	int ret = 0;
 	struct chain_t dir;
@@ -1552,23 +1493,13 @@ static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 	}
 
 	/* get the directory entry of given file or directory */
-	if (p_fs-&gt;vol_type == EXFAT) {
-		es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
-					  ES_2_ENTRIES, &amp;ep);
-		if (!es) {
-			ret = -ENOENT;
-			goto out;
-		}
-		ep2 = ep + 1;
-	} else {
-		ep = get_entry_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry, &amp;sector);
-		if (!ep) {
-			ret = -ENOENT;
-			goto out;
-		}
-		ep2 = ep;
-		buf_lock(sb, sector);
+	es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
+				  ES_2_ENTRIES, &amp;ep);
+	if (!es) {
+		ret = -ENOENT;
+		goto out;
 	}
+	ep2 = ep + 1;
 
 	/* set FILE_INFO structure using the acquired struct dentry_t */
 	info-&gt;Attr = p_fs-&gt;fs_func-&gt;get_entry_attr(ep);
@@ -1599,25 +1530,13 @@ static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 	 */
 	p_fs-&gt;fs_func-&gt;get_uni_name_from_ext_entry(sb, &amp;fid-&gt;dir, fid-&gt;entry,
 						   uni_name.name);
-	if (*uni_name.name == 0x0 &amp;&amp; p_fs-&gt;vol_type != EXFAT)
-		get_uni_name_from_dos_entry(sb, (struct dos_dentry_t *)ep,
-					    &amp;uni_name, 0x1);
 	nls_uniname_to_cstring(sb, info-&gt;Name, &amp;uni_name);
 
-	if (p_fs-&gt;vol_type == EXFAT) {
-		info-&gt;NumSubdirs = 2;
-	} else {
-		buf_unlock(sb, sector);
-		get_uni_name_from_dos_entry(sb, (struct dos_dentry_t *)ep,
-					    &amp;uni_name, 0x0);
-		nls_uniname_to_cstring(sb, info-&gt;ShortName, &amp;uni_name);
-		info-&gt;NumSubdirs = 0;
-	}
+	info-&gt;NumSubdirs = 2;
 
 	info-&gt;Size = p_fs-&gt;fs_func-&gt;get_entry_size(ep2);
 
-	if (p_fs-&gt;vol_type == EXFAT)
-		release_entry_set(es);
+	release_entry_set(es);
 
 	if (is_dir) {
 		dir.dir = fid-&gt;start_clu;
@@ -1648,7 +1567,6 @@ static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 
 static int ffsWriteStat(struct inode *inode, struct dir_entry_t *info)
 {
-	sector_t sector = 0;
 	int ret = 0;
 	struct timestamp_t tm;
 	struct dentry_t *ep, *ep2;
@@ -1676,23 +1594,13 @@ static int ffsWriteStat(struct inode *inode, struct dir_entry_t *info)
 	fs_set_vol_flags(sb, VOL_DIRTY);
 
 	/* get the directory entry of given file or directory */
-	if (p_fs-&gt;vol_type == EXFAT) {
-		es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
-					  ES_ALL_ENTRIES, &amp;ep);
-		if (!es) {
-			ret = -ENOENT;
-			goto out;
-		}
-		ep2 = ep + 1;
-	} else {
-		/* for other than exfat */
-		ep = get_entry_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry, &amp;sector);
-		if (!ep) {
-			ret = -ENOENT;
-			goto out;
-		}
-		ep2 = ep;
+	es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
+				  ES_ALL_ENTRIES, &amp;ep);
+	if (!es) {
+		ret = -ENOENT;
+		goto out;
 	}
+	ep2 = ep + 1;
 
 	p_fs-&gt;fs_func-&gt;set_entry_attr(ep, info-&gt;Attr);
 
@@ -1715,12 +1623,8 @@ static int ffsWriteStat(struct inode *inode, struct dir_entry_t *info)
 
 	p_fs-&gt;fs_func-&gt;set_entry_size(ep2, info-&gt;Size);
 
-	if (p_fs-&gt;vol_type != EXFAT) {
-		buf_modify(sb, sector);
-	} else {
-		update_dir_checksum_with_entry_set(sb, es);
-		release_entry_set(es);
-	}
+	update_dir_checksum_with_entry_set(sb, es);
+	release_entry_set(es);
 
 	if (p_fs-&gt;dev_ejected)
 		ret = -EIO;
@@ -1740,7 +1644,6 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 	bool modified = false;
 	u32 last_clu;
 	int ret = 0;
-	sector_t sector = 0;
 	struct chain_t new_clu;
 	struct dentry_t *ep;
 	struct entry_set_cache_t *es = NULL;
@@ -1830,28 +1733,17 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 		num_clusters += num_alloced;
 		*clu = new_clu.dir;
 
-		if (p_fs-&gt;vol_type == EXFAT) {
-			es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
-						  ES_ALL_ENTRIES, &amp;ep);
-			if (!es) {
-				ret = -ENOENT;
-				goto out;
-			}
-			/* get stream entry */
-			ep++;
+		es = get_entry_set_in_dir(sb, &amp;fid-&gt;dir, fid-&gt;entry,
+					  ES_ALL_ENTRIES, &amp;ep);
+		if (!es) {
+			ret = -ENOENT;
+			goto out;
 		}
+		/* get stream entry */
+		ep++;
 
 		/* (3) update directory entry */
 		if (modified) {
-			if (p_fs-&gt;vol_type != EXFAT) {
-				ep = get_entry_in_dir(sb, &amp;fid-&gt;dir,
-						      fid-&gt;entry, &amp;sector);
-				if (!ep) {
-					ret = -ENOENT;
-					goto out;
-				}
-			}
-
 			if (p_fs-&gt;fs_func-&gt;get_entry_flag(ep) != fid-&gt;flags)
 				p_fs-&gt;fs_func-&gt;set_entry_flag(ep, fid-&gt;flags);
 
@@ -1859,14 +1751,10 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 				p_fs-&gt;fs_func-&gt;set_entry_clu0(ep,
 							      fid-&gt;start_clu);
 
-			if (p_fs-&gt;vol_type != EXFAT)
-				buf_modify(sb, sector);
 		}
 
-		if (p_fs-&gt;vol_type == EXFAT) {
-			update_dir_checksum_with_entry_set(sb, es);
-			release_entry_set(es);
-		}
+		update_dir_checksum_with_entry_set(sb, es);
+		release_entry_set(es);
 
 		/* add number of new blocks to inode */
 		inode-&gt;i_blocks += num_alloced &lt;&lt; (p_fs-&gt;cluster_size_bits - 9);
@@ -2060,25 +1948,13 @@ static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 			*uni_name.name = 0x0;
 			fs_func-&gt;get_uni_name_from_ext_entry(sb, &amp;dir, dentry,
 							     uni_name.name);
-			if (*uni_name.name == 0x0 &amp;&amp; p_fs-&gt;vol_type != EXFAT)
-				get_uni_name_from_dos_entry(sb,
-						(struct dos_dentry_t *)ep,
-						&amp;uni_name, 0x1);
 			nls_uniname_to_cstring(sb, dir_entry-&gt;Name, &amp;uni_name);
 			buf_unlock(sb, sector);
 
-			if (p_fs-&gt;vol_type == EXFAT) {
-				ep = get_entry_in_dir(sb, &amp;clu, i + 1, NULL);
-				if (!ep) {
-					ret = -ENOENT;
-					goto out;
-				}
-			} else {
-				get_uni_name_from_dos_entry(sb,
-						(struct dos_dentry_t *)ep,
-						&amp;uni_name, 0x0);
-				nls_uniname_to_cstring(sb, dir_entry-&gt;ShortName,
-						       &amp;uni_name);
+			ep = get_entry_in_dir(sb, &amp;clu, i + 1, NULL);
+			if (!ep) {
+				ret = -ENOENT;
+				goto out;
 			}
 
 			dir_entry-&gt;Size = fs_func-&gt;get_entry_size(ep);
@@ -3056,7 +2932,6 @@ static int exfat_bmap(struct inode *inode, sector_t sector, sector_t *phys,
 	struct super_block *sb = inode-&gt;i_sb;
 	struct exfat_sb_info *sbi = EXFAT_SB(sb);
 	struct fs_info_t *p_fs = &amp;sbi-&gt;fs_info;
-	struct bd_info_t *p_bd = &amp;sbi-&gt;bd_info;
 	const unsigned long blocksize = sb-&gt;s_blocksize;
 	const unsigned char blocksize_bits = sb-&gt;s_blocksize_bits;
 	sector_t last_block;
@@ -3066,18 +2941,6 @@ static int exfat_bmap(struct inode *inode, sector_t sector, sector_t *phys,
 	*phys = 0;
 	*mapped_blocks = 0;
 
-	if ((p_fs-&gt;vol_type == FAT12) || (p_fs-&gt;vol_type == FAT16)) {
-		if (inode-&gt;i_ino == EXFAT_ROOT_INO) {
-			if (sector &lt;
-			    (p_fs-&gt;dentries_in_root &gt;&gt;
-			     (p_bd-&gt;sector_size_bits - DENTRY_SIZE_BITS))) {
-				*phys = sector + p_fs-&gt;root_start_sector;
-				*mapped_blocks = 1;
-			}
-			return 0;
-		}
-	}
-
 	last_block = (i_size_read(inode) + (blocksize - 1)) &gt;&gt; blocksize_bits;
 	if (sector &gt;= last_block) {
 		if (*create == 0)
@@ -3823,7 +3686,6 @@ static int exfat_fill_super(struct super_block *sb, void *data, int silent)
 	struct exfat_sb_info *sbi;
 	int debug, ret;
 	long error;
-	char buf[50];
 
 	/*
 	 * GFP_KERNEL is ok here, because while we do hold the
@@ -3870,17 +3732,6 @@ static int exfat_fill_super(struct super_block *sb, void *data, int silent)
 	 * if (FAT_FIRST_ENT(sb, media) != first)
 	 */
 
-	/* codepage is not meaningful in exfat */
-	if (sbi-&gt;fs_info.vol_type != EXFAT) {
-		error = -EINVAL;
-		sprintf(buf, "cp%d", sbi-&gt;options.codepage);
-		sbi-&gt;nls_disk = load_nls(buf);
-		if (!sbi-&gt;nls_disk) {
-			pr_err("[EXFAT] Codepage %s not found\n", buf);
-			goto out_fail2;
-		}
-	}
-
 	sbi-&gt;nls_io = load_nls(sbi-&gt;options.iocharset);
 
 	error = -ENOMEM;</pre><hr><pre>commit 7c6d78eb7c9c55952e354fe9fd212d45d9af0807
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Tue Nov 12 16:12:28 2019 -0500

    staging: exfat: Remove FAT/VFAT mount support, part 2
    
    Remove no longer referenced FAT/VFAT routines.
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112211238.156490-3-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index 68f79e13af2b..9ea865f607af 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -766,17 +766,12 @@ void fs_error(struct super_block *sb);
 
 /* cluster management functions */
 s32 clear_cluster(struct super_block *sb, u32 clu);
-s32 fat_alloc_cluster(struct super_block *sb, s32 num_alloc,
-		      struct chain_t *p_chain);
 s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 			struct chain_t *p_chain);
-void fat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
-		      s32 do_relse);
 void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 			s32 do_relse);
 u32 find_last_cluster(struct super_block *sb, struct chain_t *p_chain);
 s32 count_num_clusters(struct super_block *sb, struct chain_t *dir);
-s32 fat_count_used_clusters(struct super_block *sb);
 s32 exfat_count_used_clusters(struct super_block *sb);
 void exfat_chain_cont_cluster(struct super_block *sb, u32 chain, s32 len);
 
@@ -793,63 +788,36 @@ s32 load_upcase_table(struct super_block *sb);
 void free_upcase_table(struct super_block *sb);
 
 /* dir entry management functions */
-u32 fat_get_entry_type(struct dentry_t *p_entry);
 u32 exfat_get_entry_type(struct dentry_t *p_entry);
-void fat_set_entry_type(struct dentry_t *p_entry, u32 type);
 void exfat_set_entry_type(struct dentry_t *p_entry, u32 type);
-u32 fat_get_entry_attr(struct dentry_t *p_entry);
 u32 exfat_get_entry_attr(struct dentry_t *p_entry);
-void fat_set_entry_attr(struct dentry_t *p_entry, u32 attr);
 void exfat_set_entry_attr(struct dentry_t *p_entry, u32 attr);
-u8 fat_get_entry_flag(struct dentry_t *p_entry);
 u8 exfat_get_entry_flag(struct dentry_t *p_entry);
-void fat_set_entry_flag(struct dentry_t *p_entry, u8 flag);
 void exfat_set_entry_flag(struct dentry_t *p_entry, u8 flag);
-u32 fat_get_entry_clu0(struct dentry_t *p_entry);
 u32 exfat_get_entry_clu0(struct dentry_t *p_entry);
-void fat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu);
 void exfat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu);
-u64 fat_get_entry_size(struct dentry_t *p_entry);
 u64 exfat_get_entry_size(struct dentry_t *p_entry);
-void fat_set_entry_size(struct dentry_t *p_entry, u64 size);
 void exfat_set_entry_size(struct dentry_t *p_entry, u64 size);
 struct timestamp_t *tm_current(struct timestamp_t *tm);
-void fat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
-			u8 mode);
 void exfat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 			  u8 mode);
-void fat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
-			u8 mode);
 void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 			  u8 mode);
-s32 fat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir, s32 entry,
-		       u32 type, u32 start_clu, u64 size);
 s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			 s32 entry, u32 type, u32 start_clu, u64 size);
-s32 fat_init_ext_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-			   s32 entry, s32 num_entries,
-			   struct uni_name_t *p_uniname,
-			   struct dos_name_t *p_dosname);
 s32 exfat_init_ext_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			     s32 entry, s32 num_entries,
 			     struct uni_name_t *p_uniname,
 		struct dos_name_t *p_dosname);
-void init_dos_entry(struct dos_dentry_t *ep, u32 type, u32 start_clu);
-void init_ext_entry(struct ext_dentry_t *ep, s32 order, u8 chksum,
-		    u16 *uniname);
 void init_file_entry(struct file_dentry_t *ep, u32 type);
 void init_strm_entry(struct strm_dentry_t *ep, u8 flags, u32 start_clu,
 		     u64 size);
 void init_name_entry(struct name_dentry_t *ep, u16 *uniname);
-void fat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-			  s32 entry, s32 order, s32 num_entries);
 void exfat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			    s32 entry, s32 order, s32 num_entries);
 
 s32 find_location(struct super_block *sb, struct chain_t *p_dir, s32 entry,
 		  sector_t *sector, s32 *offset);
-struct dentry_t *get_entry_with_sector(struct super_block *sb, sector_t sector,
-				       s32 offset);
 struct dentry_t *get_entry_in_dir(struct super_block *sb, struct chain_t *p_dir,
 				  s32 entry, sector_t *sector);
 struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
@@ -865,14 +833,9 @@ s32 search_deleted_or_unused_entry(struct super_block *sb,
 				   struct chain_t *p_dir, s32 num_entries);
 s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir,
 		     s32 num_entries);
-s32 fat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-		       struct uni_name_t *p_uniname, s32 num_entries,
-		       struct dos_name_t *p_dosname, u32 type);
 s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			 struct uni_name_t *p_uniname, s32 num_entries,
 			 struct dos_name_t *p_dosname, u32 type);
-s32 fat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
-			  s32 entry, struct dentry_t *p_entry);
 s32 exfat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
 			    s32 entry, struct dentry_t *p_entry);
 s32 count_dos_name_entries(struct super_block *sb, struct chain_t *p_dir,
@@ -890,14 +853,9 @@ s32 get_num_entries_and_dos_name(struct super_block *sb, struct chain_t *p_dir,
 void get_uni_name_from_dos_entry(struct super_block *sb,
 				 struct dos_dentry_t *ep,
 				 struct uni_name_t *p_uniname, u8 mode);
-void fat_get_uni_name_from_ext_entry(struct super_block *sb,
-				     struct chain_t *p_dir, s32 entry,
-				     u16 *uniname);
 void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
 				       struct chain_t *p_dir, s32 entry,
 				       u16 *uniname);
-s32 extract_uni_name_from_ext_entry(struct ext_dentry_t *ep,
-				    u16 *uniname, s32 order);
 s32 extract_uni_name_from_name_entry(struct name_dentry_t *ep,
 				     u16 *uniname, s32 order);
 s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
@@ -905,9 +863,7 @@ s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
 void fat_attach_count_to_dos_name(u8 *dosname, s32 count);
 s32 fat_calc_num_entries(struct uni_name_t *p_uniname);
 s32 exfat_calc_num_entries(struct uni_name_t *p_uniname);
-u8 calc_checksum_1byte(void *data, s32 len, u8 chksum);
 u16 calc_checksum_2byte(void *data, s32 len, u16 chksum, s32 type);
-u32 calc_checksum_4byte(void *data, s32 len, u32 chksum, s32 type);
 
 /* name resolution functions */
 s32 resolve_path(struct inode *inode, char *path, struct chain_t *p_dir,
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index 89bed7460162..ed9e4521ec04 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -167,60 +167,6 @@ s32 clear_cluster(struct super_block *sb, u32 clu)
 	return ret;
 }
 
-s32 fat_alloc_cluster(struct super_block *sb, s32 num_alloc,
-		      struct chain_t *p_chain)
-{
-	int i, num_clusters = 0;
-	u32 new_clu, last_clu = CLUSTER_32(~0), read_clu;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-
-	new_clu = p_chain-&gt;dir;
-	if (new_clu == CLUSTER_32(~0))
-		new_clu = p_fs-&gt;clu_srch_ptr;
-	else if (new_clu &gt;= p_fs-&gt;num_clusters)
-		new_clu = 2;
-
-	__set_sb_dirty(sb);
-
-	p_chain-&gt;dir = CLUSTER_32(~0);
-
-	for (i = 2; i &lt; p_fs-&gt;num_clusters; i++) {
-		if (FAT_read(sb, new_clu, &amp;read_clu) != 0)
-			return -1;
-
-		if (read_clu == CLUSTER_32(0)) {
-			if (FAT_write(sb, new_clu, CLUSTER_32(~0)) &lt; 0)
-				return -1;
-			num_clusters++;
-
-			if (p_chain-&gt;dir == CLUSTER_32(~0)) {
-				p_chain-&gt;dir = new_clu;
-			} else {
-				if (FAT_write(sb, last_clu, new_clu) &lt; 0)
-					return -1;
-			}
-
-			last_clu = new_clu;
-
-			if ((--num_alloc) == 0) {
-				p_fs-&gt;clu_srch_ptr = new_clu;
-				if (p_fs-&gt;used_clusters != UINT_MAX)
-					p_fs-&gt;used_clusters += num_clusters;
-
-				return num_clusters;
-			}
-		}
-		if ((++new_clu) &gt;= p_fs-&gt;num_clusters)
-			new_clu = 2;
-	}
-
-	p_fs-&gt;clu_srch_ptr = new_clu;
-	if (p_fs-&gt;used_clusters != UINT_MAX)
-		p_fs-&gt;used_clusters += num_clusters;
-
-	return num_clusters;
-}
-
 s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 			struct chain_t *p_chain)
 {
@@ -300,47 +246,6 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 	return num_clusters;
 }
 
-void fat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
-		      s32 do_relse)
-{
-	s32 num_clusters = 0;
-	u32 clu, prev;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-	int i;
-	sector_t sector;
-
-	if ((p_chain-&gt;dir == CLUSTER_32(0)) || (p_chain-&gt;dir == CLUSTER_32(~0)))
-		return;
-	__set_sb_dirty(sb);
-	clu = p_chain-&gt;dir;
-
-	if (p_chain-&gt;size &lt;= 0)
-		return;
-
-	do {
-		if (p_fs-&gt;dev_ejected)
-			break;
-
-		if (do_relse) {
-			sector = START_SECTOR(clu);
-			for (i = 0; i &lt; p_fs-&gt;sectors_per_clu; i++)
-				buf_release(sb, sector + i);
-		}
-
-		prev = clu;
-		if (FAT_read(sb, clu, &amp;clu) == -1)
-			break;
-
-		if (FAT_write(sb, prev, CLUSTER_32(0)) &lt; 0)
-			break;
-		num_clusters++;
-
-	} while (clu != CLUSTER_32(~0));
-
-	if (p_fs-&gt;used_clusters != UINT_MAX)
-		p_fs-&gt;used_clusters -= num_clusters;
-}
-
 void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 			s32 do_relse)
 {
@@ -447,22 +352,6 @@ s32 count_num_clusters(struct super_block *sb, struct chain_t *p_chain)
 	return count;
 }
 
-s32 fat_count_used_clusters(struct super_block *sb)
-{
-	int i, count = 0;
-	u32 clu;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-
-	for (i = 2; i &lt; p_fs-&gt;num_clusters; i++) {
-		if (FAT_read(sb, i, &amp;clu) != 0)
-			break;
-		if (clu != CLUSTER_32(0))
-			count++;
-	}
-
-	return count;
-}
-
 s32 exfat_count_used_clusters(struct super_block *sb)
 {
 	int i, map_i, map_b, count = 0;
@@ -907,28 +796,6 @@ void free_upcase_table(struct super_block *sb)
  *  Directory Entry Management Functions
  */
 
-u32 fat_get_entry_type(struct dentry_t *p_entry)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	if (*ep-&gt;name == 0x0)
-		return TYPE_UNUSED;
-
-	else if (*ep-&gt;name == 0xE5)
-		return TYPE_DELETED;
-
-	else if (ep-&gt;attr == ATTR_EXTEND)
-		return TYPE_EXTEND;
-
-	else if ((ep-&gt;attr &amp; (ATTR_SUBDIR | ATTR_VOLUME)) == ATTR_VOLUME)
-		return TYPE_VOLUME;
-
-	else if ((ep-&gt;attr &amp; (ATTR_SUBDIR | ATTR_VOLUME)) == ATTR_SUBDIR)
-		return TYPE_DIR;
-
-	return TYPE_FILE;
-}
-
 u32 exfat_get_entry_type(struct dentry_t *p_entry)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
@@ -974,29 +841,6 @@ u32 exfat_get_entry_type(struct dentry_t *p_entry)
 	return TYPE_BENIGN_SEC;
 }
 
-void fat_set_entry_type(struct dentry_t *p_entry, u32 type)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	if (type == TYPE_UNUSED)
-		*ep-&gt;name = 0x0;
-
-	else if (type == TYPE_DELETED)
-		*ep-&gt;name = 0xE5;
-
-	else if (type == TYPE_EXTEND)
-		ep-&gt;attr = ATTR_EXTEND;
-
-	else if (type == TYPE_DIR)
-		ep-&gt;attr = ATTR_SUBDIR;
-
-	else if (type == TYPE_FILE)
-		ep-&gt;attr = ATTR_ARCHIVE;
-
-	else if (type == TYPE_SYMLINK)
-		ep-&gt;attr = ATTR_ARCHIVE | ATTR_SYMLINK;
-}
-
 void exfat_set_entry_type(struct dentry_t *p_entry, u32 type)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
@@ -1027,13 +871,6 @@ void exfat_set_entry_type(struct dentry_t *p_entry, u32 type)
 	}
 }
 
-u32 fat_get_entry_attr(struct dentry_t *p_entry)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	return (u32)ep-&gt;attr;
-}
-
 u32 exfat_get_entry_attr(struct dentry_t *p_entry)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
@@ -1041,13 +878,6 @@ u32 exfat_get_entry_attr(struct dentry_t *p_entry)
 	return (u32)GET16_A(ep-&gt;attr);
 }
 
-void fat_set_entry_attr(struct dentry_t *p_entry, u32 attr)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	ep-&gt;attr = (u8)attr;
-}
-
 void exfat_set_entry_attr(struct dentry_t *p_entry, u32 attr)
 {
 	struct file_dentry_t *ep = (struct file_dentry_t *)p_entry;
@@ -1055,11 +885,6 @@ void exfat_set_entry_attr(struct dentry_t *p_entry, u32 attr)
 	SET16_A(ep-&gt;attr, (u16)attr);
 }
 
-u8 fat_get_entry_flag(struct dentry_t *p_entry)
-{
-	return 0x01;
-}
-
 u8 exfat_get_entry_flag(struct dentry_t *p_entry)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
@@ -1067,10 +892,6 @@ u8 exfat_get_entry_flag(struct dentry_t *p_entry)
 	return ep-&gt;flags;
 }
 
-void fat_set_entry_flag(struct dentry_t *p_entry, u8 flags)
-{
-}
-
 void exfat_set_entry_flag(struct dentry_t *p_entry, u8 flags)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
@@ -1078,14 +899,6 @@ void exfat_set_entry_flag(struct dentry_t *p_entry, u8 flags)
 	ep-&gt;flags = flags;
 }
 
-u32 fat_get_entry_clu0(struct dentry_t *p_entry)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	return ((u32)GET16_A(ep-&gt;start_clu_hi) &lt;&lt; 16) |
-		GET16_A(ep-&gt;start_clu_lo);
-}
-
 u32 exfat_get_entry_clu0(struct dentry_t *p_entry)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
@@ -1093,14 +906,6 @@ u32 exfat_get_entry_clu0(struct dentry_t *p_entry)
 	return GET32_A(ep-&gt;start_clu);
 }
 
-void fat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	SET16_A(ep-&gt;start_clu_lo, CLUSTER_16(start_clu));
-	SET16_A(ep-&gt;start_clu_hi, CLUSTER_16(start_clu &gt;&gt; 16));
-}
-
 void exfat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
@@ -1108,13 +913,6 @@ void exfat_set_entry_clu0(struct dentry_t *p_entry, u32 start_clu)
 	SET32_A(ep-&gt;start_clu, start_clu);
 }
 
-u64 fat_get_entry_size(struct dentry_t *p_entry)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	return (u64)GET32_A(ep-&gt;size);
-}
-
 u64 exfat_get_entry_size(struct dentry_t *p_entry)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
@@ -1122,13 +920,6 @@ u64 exfat_get_entry_size(struct dentry_t *p_entry)
 	return GET64_A(ep-&gt;valid_size);
 }
 
-void fat_set_entry_size(struct dentry_t *p_entry, u64 size)
-{
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	SET32_A(ep-&gt;size, (u32)size);
-}
-
 void exfat_set_entry_size(struct dentry_t *p_entry, u64 size)
 {
 	struct strm_dentry_t *ep = (struct strm_dentry_t *)p_entry;
@@ -1137,31 +928,6 @@ void exfat_set_entry_size(struct dentry_t *p_entry, u64 size)
 	SET64_A(ep-&gt;size, size);
 }
 
-void fat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
-			u8 mode)
-{
-	u16 t = 0x00, d = 0x21;
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	switch (mode) {
-	case TM_CREATE:
-		t = GET16_A(ep-&gt;create_time);
-		d = GET16_A(ep-&gt;create_date);
-		break;
-	case TM_MODIFY:
-		t = GET16_A(ep-&gt;modify_time);
-		d = GET16_A(ep-&gt;modify_date);
-		break;
-	}
-
-	tp-&gt;sec  = (t &amp; 0x001F) &lt;&lt; 1;
-	tp-&gt;min  = (t &gt;&gt; 5) &amp; 0x003F;
-	tp-&gt;hour = (t &gt;&gt; 11);
-	tp-&gt;day  = (d &amp; 0x001F);
-	tp-&gt;mon  = (d &gt;&gt; 5) &amp; 0x000F;
-	tp-&gt;year = (d &gt;&gt; 9);
-}
-
 void exfat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 			  u8 mode)
 {
@@ -1191,27 +957,6 @@ void exfat_get_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 	tp-&gt;year = (d &gt;&gt; 9);
 }
 
-void fat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
-			u8 mode)
-{
-	u16 t, d;
-	struct dos_dentry_t *ep = (struct dos_dentry_t *)p_entry;
-
-	t = (tp-&gt;hour &lt;&lt; 11) | (tp-&gt;min &lt;&lt; 5) | (tp-&gt;sec &gt;&gt; 1);
-	d = (tp-&gt;year &lt;&lt;  9) | (tp-&gt;mon &lt;&lt; 5) |  tp-&gt;day;
-
-	switch (mode) {
-	case TM_CREATE:
-		SET16_A(ep-&gt;create_time, t);
-		SET16_A(ep-&gt;create_date, d);
-		break;
-	case TM_MODIFY:
-		SET16_A(ep-&gt;modify_time, t);
-		SET16_A(ep-&gt;modify_date, d);
-		break;
-	}
-}
-
 void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 			  u8 mode)
 {
@@ -1237,23 +982,6 @@ void exfat_set_entry_time(struct dentry_t *p_entry, struct timestamp_t *tp,
 	}
 }
 
-s32 fat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir, s32 entry,
-		       u32 type, u32 start_clu, u64 size)
-{
-	sector_t sector;
-	struct dos_dentry_t *dos_ep;
-
-	dos_ep = (struct dos_dentry_t *)get_entry_in_dir(sb, p_dir, entry,
-							 &amp;sector);
-	if (!dos_ep)
-		return -EIO;
-
-	init_dos_entry(dos_ep, type, start_clu);
-	buf_modify(sb, sector);
-
-	return 0;
-}
-
 s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			 s32 entry, u32 type, u32 start_clu, u64 size)
 {
@@ -1330,70 +1058,6 @@ static s32 exfat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
 	return 0;
 }
 
-void init_dos_entry(struct dos_dentry_t *ep, u32 type, u32 start_clu)
-{
-	struct timestamp_t tm, *tp;
-
-	fat_set_entry_type((struct dentry_t *)ep, type);
-	SET16_A(ep-&gt;start_clu_lo, CLUSTER_16(start_clu));
-	SET16_A(ep-&gt;start_clu_hi, CLUSTER_16(start_clu &gt;&gt; 16));
-	SET32_A(ep-&gt;size, 0);
-
-	tp = tm_current(&amp;tm);
-	fat_set_entry_time((struct dentry_t *)ep, tp, TM_CREATE);
-	fat_set_entry_time((struct dentry_t *)ep, tp, TM_MODIFY);
-	SET16_A(ep-&gt;access_date, 0);
-	ep-&gt;create_time_ms = 0;
-}
-
-void init_ext_entry(struct ext_dentry_t *ep, s32 order, u8 chksum, u16 *uniname)
-{
-	int i;
-	bool end = false;
-
-	fat_set_entry_type((struct dentry_t *)ep, TYPE_EXTEND);
-	ep-&gt;order = (u8)order;
-	ep-&gt;sysid = 0;
-	ep-&gt;checksum = chksum;
-	SET16_A(ep-&gt;start_clu, 0);
-
-	for (i = 0; i &lt; 10; i += 2) {
-		if (!end) {
-			SET16(ep-&gt;unicode_0_4 + i, *uniname);
-			if (*uniname == 0x0)
-				end = true;
-			else
-				uniname++;
-		} else {
-			SET16(ep-&gt;unicode_0_4 + i, 0xFFFF);
-		}
-	}
-
-	for (i = 0; i &lt; 12; i += 2) {
-		if (!end) {
-			SET16_A(ep-&gt;unicode_5_10 + i, *uniname);
-			if (*uniname == 0x0)
-				end = true;
-			else
-				uniname++;
-		} else {
-			SET16_A(ep-&gt;unicode_5_10 + i, 0xFFFF);
-		}
-	}
-
-	for (i = 0; i &lt; 4; i += 2) {
-		if (!end) {
-			SET16_A(ep-&gt;unicode_11_12 + i, *uniname);
-			if (*uniname == 0x0)
-				end = true;
-			else
-				uniname++;
-		} else {
-			SET16_A(ep-&gt;unicode_11_12 + i, 0xFFFF);
-		}
-	}
-}
-
 void init_file_entry(struct file_dentry_t *ep, u32 type)
 {
 	struct timestamp_t tm, *tp;
@@ -1433,24 +1097,6 @@ void init_name_entry(struct name_dentry_t *ep, u16 *uniname)
 	}
 }
 
-void fat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-		s32 entry, s32 order, s32 num_entries)
-{
-	int i;
-	sector_t sector;
-	struct dentry_t *ep;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-
-	for (i = num_entries - 1; i &gt;= order; i--) {
-		ep = get_entry_in_dir(sb, p_dir, entry - i, &amp;sector);
-		if (!ep)
-			return;
-
-		p_fs-&gt;fs_func-&gt;set_entry_type(ep, TYPE_DELETED);
-		buf_modify(sb, sector);
-	}
-}
-
 void exfat_delete_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 			    s32 entry, s32 order, s32 num_entries)
 {
@@ -1583,19 +1229,6 @@ s32 find_location(struct super_block *sb, struct chain_t *p_dir, s32 entry,
 	return 0;
 }
 
-struct dentry_t *get_entry_with_sector(struct super_block *sb, sector_t sector,
-				       s32 offset)
-{
-	u8 *buf;
-
-	buf = buf_getblk(sb, sector);
-
-	if (!buf)
-		return NULL;
-
-	return (struct dentry_t *)(buf + offset);
-}
-
 struct dentry_t *get_entry_in_dir(struct super_block *sb, struct chain_t *p_dir,
 				  s32 entry, sector_t *sector)
 {
@@ -1866,46 +1499,6 @@ s32 write_whole_entry_set(struct super_block *sb, struct entry_set_cache_t *es)
 						    es-&gt;num_entries);
 }
 
-/* write back some entries in entry set */
-s32 write_partial_entries_in_entry_set(struct super_block *sb,
-				       struct entry_set_cache_t *es,
-				       struct dentry_t *ep, u32 count)
-{
-	s32 ret, byte_offset, off;
-	u32 clu = 0;
-	sector_t sec;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
-	struct chain_t dir;
-
-	/* vaidity check */
-	if (ep + count  &gt; ((struct dentry_t *)&amp;es-&gt;__buf) + es-&gt;num_entries)
-		return -EINVAL;
-
-	dir.dir = GET_CLUSTER_FROM_SECTOR(es-&gt;sector);
-	dir.flags = es-&gt;alloc_flag;
-	dir.size = 0xffffffff;		/* XXX */
-
-	byte_offset = (es-&gt;sector - START_SECTOR(dir.dir)) &lt;&lt;
-			p_bd-&gt;sector_size_bits;
-	byte_offset += ((void **)ep - &amp;es-&gt;__buf) + es-&gt;offset;
-
-	ret = _walk_fat_chain(sb, &amp;dir, byte_offset, &amp;clu);
-	if (ret != 0)
-		return ret;
-
-	/* byte offset in cluster */
-	byte_offset &amp;= p_fs-&gt;cluster_size - 1;
-
-	/* byte offset in sector    */
-	off = byte_offset &amp; p_bd-&gt;sector_size_mask;
-
-	/* sector offset in cluster */
-	sec = byte_offset &gt;&gt; p_bd-&gt;sector_size_bits;
-	sec += START_SECTOR(clu);
-	return __write_partial_entries_in_entry_set(sb, es, sec, off, count);
-}
-
 /* search EMPTY CONTINUOUS "num_entries" entries */
 s32 search_deleted_or_unused_entry(struct super_block *sb,
 				   struct chain_t *p_dir, s32 num_entries)
@@ -2087,104 +1680,6 @@ s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir, s32 num_entries
 	return dentry;
 }
 
-/* return values of fat_find_dir_entry()
- * &gt;= 0 : return dir entiry position with the name in dir
- * -1 : (root dir, ".") it is the root dir itself
- * -2 : entry with the name does not exist
- */
-s32 fat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
-		       struct uni_name_t *p_uniname, s32 num_entries,
-		       struct dos_name_t *p_dosname, u32 type)
-{
-	int i, dentry = 0, len;
-	s32 order = 0;
-	bool is_feasible_entry = true, has_ext_entry = false;
-	s32 dentries_per_clu;
-	u32 entry_type;
-	u16 entry_uniname[14], *uniname = NULL, unichar;
-	struct chain_t clu;
-	struct dentry_t *ep;
-	struct dos_dentry_t *dos_ep;
-	struct ext_dentry_t *ext_ep;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-
-	if (p_dir-&gt;dir == p_fs-&gt;root_dir) {
-		if ((!nls_uniname_cmp(sb, p_uniname-&gt;name,
-				      (u16 *)UNI_CUR_DIR_NAME)) ||
-			(!nls_uniname_cmp(sb, p_uniname-&gt;name,
-					  (u16 *)UNI_PAR_DIR_NAME)))
-			return -1; // special case, root directory itself
-	}
-
-	if (p_dir-&gt;dir == CLUSTER_32(0)) /* FAT16 root_dir */
-		dentries_per_clu = p_fs-&gt;dentries_in_root;
-	else
-		dentries_per_clu = p_fs-&gt;dentries_per_clu;
-
-	clu.dir = p_dir-&gt;dir;
-	clu.flags = p_dir-&gt;flags;
-
-	while (clu.dir != CLUSTER_32(~0)) {
-		if (p_fs-&gt;dev_ejected)
-			break;
-
-		for (i = 0; i &lt; dentries_per_clu; i++, dentry++) {
-			ep = get_entry_in_dir(sb, &amp;clu, i, NULL);
-			if (!ep)
-				return -2;
-
-			entry_type = p_fs-&gt;fs_func-&gt;get_entry_type(ep);
-
-			if ((entry_type == TYPE_FILE) || (entry_type == TYPE_DIR)) {
-				if ((type == TYPE_ALL) || (type == entry_type)) {
-					if (is_feasible_entry &amp;&amp; has_ext_entry)
-						return dentry;
-
-					dos_ep = (struct dos_dentry_t *)ep;
-					if (!nls_dosname_cmp(sb, p_dosname-&gt;name, dos_ep-&gt;name))
-						return dentry;
-				}
-				is_feasible_entry = true;
-				has_ext_entry = false;
-			} else if (entry_type == TYPE_EXTEND) {
-				if (is_feasible_entry) {
-					ext_ep = (struct ext_dentry_t *)ep;
-					if (ext_ep-&gt;order &gt; 0x40) {
-						order = (s32)(ext_ep-&gt;order - 0x40);
-						uniname = p_uniname-&gt;name + 13 * (order - 1);
-					} else {
-						order = (s32)ext_ep-&gt;order;
-						uniname -= 13;
-					}
-
-					len = extract_uni_name_from_ext_entry(ext_ep, entry_uniname, order);
-
-					unichar = *(uniname + len);
-					*(uniname + len) = 0x0;
-
-					if (nls_uniname_cmp(sb, uniname, entry_uniname))
-						is_feasible_entry = false;
-
-					*(uniname + len) = unichar;
-				}
-				has_ext_entry = true;
-			} else if (entry_type == TYPE_UNUSED) {
-				return -2;
-			}
-			is_feasible_entry = true;
-			has_ext_entry = false;
-		}
-
-		if (p_dir-&gt;dir == CLUSTER_32(0))
-			break; /* FAT16 root_dir */
-
-		if (FAT_read(sb, clu.dir, &amp;clu.dir) != 0)
-			return -2;
-	}
-
-	return -2;
-}
-
 /* return values of exfat_find_dir_entry()
  * &gt;= 0 : return dir entiry position with the name in dir
  * -1 : (root dir, ".") it is the root dir itself
@@ -2333,36 +1828,6 @@ s32 exfat_find_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 	return -2;
 }
 
-s32 fat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
-			  s32 entry, struct dentry_t *p_entry)
-{
-	s32 count = 0;
-	u8 chksum;
-	struct dos_dentry_t *dos_ep = (struct dos_dentry_t *)p_entry;
-	struct ext_dentry_t *ext_ep;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-
-	chksum = calc_checksum_1byte((void *)dos_ep-&gt;name, DOS_NAME_LENGTH, 0);
-
-	for (entry--; entry &gt;= 0; entry--) {
-		ext_ep = (struct ext_dentry_t *)get_entry_in_dir(sb, p_dir,
-								 entry, NULL);
-		if (!ext_ep)
-			return -1;
-
-		if ((p_fs-&gt;fs_func-&gt;get_entry_type((struct dentry_t *)ext_ep) ==
-		     TYPE_EXTEND) &amp;&amp; (ext_ep-&gt;checksum == chksum)) {
-			count++;
-			if (ext_ep-&gt;order &gt; 0x40)
-				return count;
-		} else {
-			return count;
-		}
-	}
-
-	return count;
-}
-
 s32 exfat_count_ext_entries(struct super_block *sb, struct chain_t *p_dir,
 			    s32 entry, struct dentry_t *p_entry)
 {
@@ -2564,33 +2029,6 @@ void get_uni_name_from_dos_entry(struct super_block *sb,
 	nls_dosname_to_uniname(sb, p_uniname, &amp;dos_name);
 }
 
-void fat_get_uni_name_from_ext_entry(struct super_block *sb,
-				     struct chain_t *p_dir, s32 entry,
-				     u16 *uniname)
-{
-	int i;
-	struct ext_dentry_t *ep;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-
-	for (entry--, i = 1; entry &gt;= 0; entry--, i++) {
-		ep = (struct ext_dentry_t *)get_entry_in_dir(sb, p_dir, entry,
-							     NULL);
-		if (!ep)
-			return;
-
-		if (p_fs-&gt;fs_func-&gt;get_entry_type((struct dentry_t *)ep) ==
-		    TYPE_EXTEND) {
-			extract_uni_name_from_ext_entry(ep, uniname, i);
-			if (ep-&gt;order &gt; 0x40)
-				return;
-		} else {
-			return;
-		}
-
-		uniname += 13;
-	}
-}
-
 void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
 				       struct chain_t *p_dir, s32 entry,
 				       u16 *uniname)
@@ -2628,51 +2066,6 @@ void exfat_get_uni_name_from_ext_entry(struct super_block *sb,
 	release_entry_set(es);
 }
 
-s32 extract_uni_name_from_ext_entry(struct ext_dentry_t *ep, u16 *uniname,
-				    s32 order)
-{
-	int i, len = 0;
-
-	for (i = 0; i &lt; 10; i += 2) {
-		*uniname = GET16(ep-&gt;unicode_0_4 + i);
-		if (*uniname == 0x0)
-			return len;
-		uniname++;
-		len++;
-	}
-
-	if (order &lt; 20) {
-		for (i = 0; i &lt; 12; i += 2) {
-			*uniname = GET16_A(ep-&gt;unicode_5_10 + i);
-			if (*uniname == 0x0)
-				return len;
-			uniname++;
-			len++;
-		}
-	} else {
-		for (i = 0; i &lt; 8; i += 2) {
-			*uniname = GET16_A(ep-&gt;unicode_5_10 + i);
-			if (*uniname == 0x0)
-				return len;
-			uniname++;
-			len++;
-		}
-		*uniname = 0x0; /* uniname[MAX_NAME_LENGTH-1] */
-		return len;
-	}
-
-	for (i = 0; i &lt; 4; i += 2) {
-		*uniname = GET16_A(ep-&gt;unicode_11_12 + i);
-		if (*uniname == 0x0)
-			return len;
-		uniname++;
-		len++;
-	}
-
-	*uniname = 0x0;
-	return len;
-}
-
 s32 extract_uni_name_from_name_entry(struct name_dentry_t *ep, u16 *uniname,
 				     s32 order)
 {
@@ -2812,18 +2205,6 @@ void fat_attach_count_to_dos_name(u8 *dosname, s32 count)
 		dosname[7] = ' ';
 }
 
-s32 fat_calc_num_entries(struct uni_name_t *p_uniname)
-{
-	s32 len;
-
-	len = p_uniname-&gt;name_len;
-	if (len == 0)
-		return 0;
-
-	/* 1 dos name entry + extended entries */
-	return (len - 1) / 13 + 2;
-}
-
 s32 exfat_calc_num_entries(struct uni_name_t *p_uniname)
 {
 	s32 len;</pre><hr><pre>commit 04a991cd9066dd182602a82e234bf91b1ea423d7
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Tue Nov 12 16:12:27 2019 -0500

    staging: exfat: Remove FAT/VFAT mount support, part 1
    
    Remove the top-level mount functionality, to make this driver handle
    only exfat file systems.
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112211238.156490-2-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/Kconfig b/drivers/staging/exfat/Kconfig
index ce32dfe33bec..0130019cbec2 100644
--- a/drivers/staging/exfat/Kconfig
+++ b/drivers/staging/exfat/Kconfig
@@ -6,15 +6,6 @@ config EXFAT_FS
 	help
 	  This adds support for the exFAT file system.
 
-config EXFAT_DONT_MOUNT_VFAT
-	bool "Prohibit mounting of fat/vfat filesystems by exFAT"
-	depends on EXFAT_FS
-	default y
-	help
-	  By default, the exFAT driver will only mount exFAT filesystems, and refuse
-	  to mount fat/vfat filesystems.  Set this to 'n' to allow the exFAT driver
-	  to mount these filesystems.
-
 config EXFAT_DISCARD
 	bool "enable discard support"
 	depends on EXFAT_FS
diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index 72cf40e123de..68f79e13af2b 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -915,8 +915,6 @@ s32 resolve_path(struct inode *inode, char *path, struct chain_t *p_dir,
 s32 resolve_name(u8 *name, u8 **arg);
 
 /* file operation functions */
-s32 fat16_mount(struct super_block *sb, struct pbr_sector_t *p_pbr);
-s32 fat32_mount(struct super_block *sb, struct pbr_sector_t *p_pbr);
 s32 exfat_mount(struct super_block *sb, struct pbr_sector_t *p_pbr);
 s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 	       struct uni_name_t *p_uniname, struct file_id_t *fid);
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index 1f0ef94bdd47..89bed7460162 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -1284,57 +1284,6 @@ s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 	return 0;
 }
 
-static s32 fat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
-			      s32 entry, s32 num_entries,
-			      struct uni_name_t *p_uniname,
-			      struct dos_name_t *p_dosname)
-{
-	int i;
-	sector_t sector;
-	u8 chksum;
-	u16 *uniname = p_uniname-&gt;name;
-	struct dos_dentry_t *dos_ep;
-	struct ext_dentry_t *ext_ep;
-
-	dos_ep = (struct dos_dentry_t *)get_entry_in_dir(sb, p_dir, entry,
-							 &amp;sector);
-	if (!dos_ep)
-		return -EIO;
-
-	dos_ep-&gt;lcase = p_dosname-&gt;name_case;
-	memcpy(dos_ep-&gt;name, p_dosname-&gt;name, DOS_NAME_LENGTH);
-	buf_modify(sb, sector);
-
-	if ((--num_entries) &gt; 0) {
-		chksum = calc_checksum_1byte((void *)dos_ep-&gt;name,
-					     DOS_NAME_LENGTH, 0);
-
-		for (i = 1; i &lt; num_entries; i++) {
-			ext_ep = (struct ext_dentry_t *)get_entry_in_dir(sb,
-									 p_dir,
-									 entry - i,
-									 &amp;sector);
-			if (!ext_ep)
-				return -EIO;
-
-			init_ext_entry(ext_ep, i, chksum, uniname);
-			buf_modify(sb, sector);
-			uniname += 13;
-		}
-
-		ext_ep = (struct ext_dentry_t *)get_entry_in_dir(sb, p_dir,
-								 entry - i,
-								 &amp;sector);
-		if (!ext_ep)
-			return -EIO;
-
-		init_ext_entry(ext_ep, i + 0x40, chksum, uniname);
-		buf_modify(sb, sector);
-	}
-
-	return 0;
-}
-
 static s32 exfat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
 				s32 entry, s32 num_entries,
 				struct uni_name_t *p_uniname,
@@ -2981,148 +2930,6 @@ s32 resolve_path(struct inode *inode, char *path, struct chain_t *p_dir,
 /*
  *  File Operation Functions
  */
-static struct fs_func fat_fs_func = {
-	.alloc_cluster = fat_alloc_cluster,
-	.free_cluster = fat_free_cluster,
-	.count_used_clusters = fat_count_used_clusters,
-
-	.init_dir_entry = fat_init_dir_entry,
-	.init_ext_entry = fat_init_ext_entry,
-	.find_dir_entry = fat_find_dir_entry,
-	.delete_dir_entry = fat_delete_dir_entry,
-	.get_uni_name_from_ext_entry = fat_get_uni_name_from_ext_entry,
-	.count_ext_entries = fat_count_ext_entries,
-	.calc_num_entries = fat_calc_num_entries,
-
-	.get_entry_type = fat_get_entry_type,
-	.set_entry_type = fat_set_entry_type,
-	.get_entry_attr = fat_get_entry_attr,
-	.set_entry_attr = fat_set_entry_attr,
-	.get_entry_flag = fat_get_entry_flag,
-	.set_entry_flag = fat_set_entry_flag,
-	.get_entry_clu0 = fat_get_entry_clu0,
-	.set_entry_clu0 = fat_set_entry_clu0,
-	.get_entry_size = fat_get_entry_size,
-	.set_entry_size = fat_set_entry_size,
-	.get_entry_time = fat_get_entry_time,
-	.set_entry_time = fat_set_entry_time,
-};
-
-s32 fat16_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
-{
-	s32 num_reserved, num_root_sectors;
-	struct bpb16_t *p_bpb = (struct bpb16_t *)p_pbr-&gt;bpb;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
-
-	if (p_bpb-&gt;num_fats == 0)
-		return -EFSCORRUPTED;
-
-	num_root_sectors = GET16(p_bpb-&gt;num_root_entries) &lt;&lt; DENTRY_SIZE_BITS;
-	num_root_sectors = ((num_root_sectors - 1) &gt;&gt;
-			    p_bd-&gt;sector_size_bits) + 1;
-
-	p_fs-&gt;sectors_per_clu = p_bpb-&gt;sectors_per_clu;
-	p_fs-&gt;sectors_per_clu_bits = ilog2(p_bpb-&gt;sectors_per_clu);
-	p_fs-&gt;cluster_size_bits = p_fs-&gt;sectors_per_clu_bits +
-				  p_bd-&gt;sector_size_bits;
-	p_fs-&gt;cluster_size = 1 &lt;&lt; p_fs-&gt;cluster_size_bits;
-
-	p_fs-&gt;num_FAT_sectors = GET16(p_bpb-&gt;num_fat_sectors);
-
-	p_fs-&gt;FAT1_start_sector = p_fs-&gt;PBR_sector + GET16(p_bpb-&gt;num_reserved);
-	if (p_bpb-&gt;num_fats == 1)
-		p_fs-&gt;FAT2_start_sector = p_fs-&gt;FAT1_start_sector;
-	else
-		p_fs-&gt;FAT2_start_sector = p_fs-&gt;FAT1_start_sector +
-					  p_fs-&gt;num_FAT_sectors;
-
-	p_fs-&gt;root_start_sector = p_fs-&gt;FAT2_start_sector +
-				  p_fs-&gt;num_FAT_sectors;
-	p_fs-&gt;data_start_sector = p_fs-&gt;root_start_sector + num_root_sectors;
-
-	p_fs-&gt;num_sectors = GET16(p_bpb-&gt;num_sectors);
-	if (p_fs-&gt;num_sectors == 0)
-		p_fs-&gt;num_sectors = GET32(p_bpb-&gt;num_huge_sectors);
-
-	num_reserved = p_fs-&gt;data_start_sector - p_fs-&gt;PBR_sector;
-	p_fs-&gt;num_clusters = ((p_fs-&gt;num_sectors - num_reserved) &gt;&gt;
-			      p_fs-&gt;sectors_per_clu_bits) + 2;
-	/* because the cluster index starts with 2 */
-
-	if (p_fs-&gt;num_clusters &lt; FAT12_THRESHOLD)
-		p_fs-&gt;vol_type = FAT12;
-	else
-		p_fs-&gt;vol_type = FAT16;
-	p_fs-&gt;vol_id = GET32(p_bpb-&gt;vol_serial);
-
-	p_fs-&gt;root_dir = 0;
-	p_fs-&gt;dentries_in_root = GET16(p_bpb-&gt;num_root_entries);
-	p_fs-&gt;dentries_per_clu = 1 &lt;&lt; (p_fs-&gt;cluster_size_bits -
-				       DENTRY_SIZE_BITS);
-
-	p_fs-&gt;vol_flag = VOL_CLEAN;
-	p_fs-&gt;clu_srch_ptr = 2;
-	p_fs-&gt;used_clusters = UINT_MAX;
-
-	p_fs-&gt;fs_func = &amp;fat_fs_func;
-
-	return 0;
-}
-
-s32 fat32_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
-{
-	s32 num_reserved;
-	struct bpb32_t *p_bpb = (struct bpb32_t *)p_pbr-&gt;bpb;
-	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
-
-	if (p_bpb-&gt;num_fats == 0)
-		return -EFSCORRUPTED;
-
-	p_fs-&gt;sectors_per_clu = p_bpb-&gt;sectors_per_clu;
-	p_fs-&gt;sectors_per_clu_bits = ilog2(p_bpb-&gt;sectors_per_clu);
-	p_fs-&gt;cluster_size_bits = p_fs-&gt;sectors_per_clu_bits +
-				  p_bd-&gt;sector_size_bits;
-	p_fs-&gt;cluster_size = 1 &lt;&lt; p_fs-&gt;cluster_size_bits;
-
-	p_fs-&gt;num_FAT_sectors = GET32(p_bpb-&gt;num_fat32_sectors);
-
-	p_fs-&gt;FAT1_start_sector = p_fs-&gt;PBR_sector + GET16(p_bpb-&gt;num_reserved);
-	if (p_bpb-&gt;num_fats == 1)
-		p_fs-&gt;FAT2_start_sector = p_fs-&gt;FAT1_start_sector;
-	else
-		p_fs-&gt;FAT2_start_sector = p_fs-&gt;FAT1_start_sector +
-					  p_fs-&gt;num_FAT_sectors;
-
-	p_fs-&gt;root_start_sector = p_fs-&gt;FAT2_start_sector +
-				  p_fs-&gt;num_FAT_sectors;
-	p_fs-&gt;data_start_sector = p_fs-&gt;root_start_sector;
-
-	p_fs-&gt;num_sectors = GET32(p_bpb-&gt;num_huge_sectors);
-	num_reserved = p_fs-&gt;data_start_sector - p_fs-&gt;PBR_sector;
-
-	p_fs-&gt;num_clusters = ((p_fs-&gt;num_sectors - num_reserved) &gt;&gt;
-			      p_fs-&gt;sectors_per_clu_bits) + 2;
-	/* because the cluster index starts with 2 */
-
-	p_fs-&gt;vol_type = FAT32;
-	p_fs-&gt;vol_id = GET32(p_bpb-&gt;vol_serial);
-
-	p_fs-&gt;root_dir = GET32(p_bpb-&gt;root_cluster);
-	p_fs-&gt;dentries_in_root = 0;
-	p_fs-&gt;dentries_per_clu = 1 &lt;&lt; (p_fs-&gt;cluster_size_bits -
-				       DENTRY_SIZE_BITS);
-
-	p_fs-&gt;vol_flag = VOL_CLEAN;
-	p_fs-&gt;clu_srch_ptr = 2;
-	p_fs-&gt;used_clusters = UINT_MAX;
-
-	p_fs-&gt;fs_func = &amp;fat_fs_func;
-
-	return 0;
-}
-
 static struct fs_func exfat_fs_func = {
 	.alloc_cluster = exfat_alloc_cluster,
 	.free_cluster = exfat_free_cluster,
diff --git a/drivers/staging/exfat/exfat_super.c b/drivers/staging/exfat/exfat_super.c
index 4c8afe60d48b..0ebf342122da 100644
--- a/drivers/staging/exfat/exfat_super.c
+++ b/drivers/staging/exfat/exfat_super.c
@@ -396,16 +396,10 @@ static int ffsMountVol(struct super_block *sb)
 			break;
 
 	if (i &lt; 53) {
-#ifdef CONFIG_EXFAT_DONT_MOUNT_VFAT
+		/* Not sure how we'd get here, but complain if it does */
 		ret = -EINVAL;
 		pr_info("EXFAT: Attempted to mount VFAT filesystem\n");
 		goto out;
-#else
-		if (GET16(p_pbr-&gt;bpb + 11)) /* num_fat_sectors */
-			ret = fat16_mount(sb, p_pbr);
-		else
-			ret = fat32_mount(sb, p_pbr);
-#endif
 	} else {
 		ret = exfat_mount(sb, p_pbr);
 	}</pre><hr><pre>commit ecbc9e989f62e59cdd3e87b1e7babacc765041ba
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Mon Nov 11 21:09:57 2019 -0500

    staging: exfat: Correct return code
    
    Use -ENOTEMPTY rather than -EEXIST for attempting to remove
    a directory that still has files in it.
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112021000.42091-10-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat_super.c b/drivers/staging/exfat/exfat_super.c
index 3e13e002cd14..4c8afe60d48b 100644
--- a/drivers/staging/exfat/exfat_super.c
+++ b/drivers/staging/exfat/exfat_super.c
@@ -2167,7 +2167,7 @@ static int ffsRemoveDir(struct inode *inode, struct file_id_t *fid)
 	clu_to_free.flags = fid-&gt;flags;
 
 	if (!is_dir_empty(sb, &amp;clu_to_free)) {
-		ret = -EEXIST;
+		ret = -ENOTEMPTY;
 		goto out;
 	}
 </pre><hr><pre>commit ad03f80f7b7229f39623f6a11fe8cb07cab1c05e
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Mon Nov 11 21:09:56 2019 -0500

    staging: exfat: Collapse redundant return code translations
    
    Now that we no longer use odd internal return codes, we can
    heave the translation code over the side, and just pass the
    error code back up the call chain.
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112021000.42091-9-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat_super.c b/drivers/staging/exfat/exfat_super.c
index 7941944ec09f..3e13e002cd14 100644
--- a/drivers/staging/exfat/exfat_super.c
+++ b/drivers/staging/exfat/exfat_super.c
@@ -650,7 +650,7 @@ static int ffsCreateFile(struct inode *inode, char *path, u8 mode,
 	struct uni_name_t uni_name;
 	struct super_block *sb = inode-&gt;i_sb;
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-	int ret;
+	int ret = 0;
 
 	/* check the validity of pointer parameters */
 	if (!fid || !path || (*path == '\0'))
@@ -2366,19 +2366,9 @@ static int exfat_create(struct inode *dir, struct dentry *dentry, umode_t mode,
 	pr_debug("%s entered\n", __func__);
 
 	err = ffsCreateFile(dir, (u8 *)dentry-&gt;d_name.name, FM_REGULAR, &amp;fid);
-	if (err) {
-		if (err == -EINVAL)
-			err = -EINVAL;
-		else if (err == -EEXIST)
-			err = -EEXIST;
-		else if (err == -ENOSPC)
-			err = -ENOSPC;
-		else if (err == -ENAMETOOLONG)
-			err = -ENAMETOOLONG;
-		else
-			err = -EIO;
+	if (err)
 		goto out;
-	}
+
 	INC_IVERSION(dir);
 	curtime = current_time(dir);
 	dir-&gt;i_ctime = curtime;
@@ -2543,13 +2533,9 @@ static int exfat_unlink(struct inode *dir, struct dentry *dentry)
 	EXFAT_I(inode)-&gt;fid.size = i_size_read(inode);
 
 	err = ffsRemoveFile(dir, &amp;(EXFAT_I(inode)-&gt;fid));
-	if (err) {
-		if (err == -EPERM)
-			err = -EPERM;
-		else
-			err = -EIO;
+	if (err)
 		goto out;
-	}
+
 	INC_IVERSION(dir);
 	curtime = current_time(dir);
 	dir-&gt;i_mtime = curtime;
@@ -2589,27 +2575,14 @@ static int exfat_symlink(struct inode *dir, struct dentry *dentry,
 	pr_debug("%s entered\n", __func__);
 
 	err = ffsCreateFile(dir, (u8 *)dentry-&gt;d_name.name, FM_SYMLINK, &amp;fid);
-	if (err) {
-		if (err == -EINVAL)
-			err = -EINVAL;
-		else if (err == -EEXIST)
-			err = -EEXIST;
-		else if (err == -ENOSPC)
-			err = -ENOSPC;
-		else
-			err = -EIO;
+	if (err)
 		goto out;
-	}
+
 
 	err = ffsWriteFile(dir, &amp;fid, (char *)target, len, &amp;ret);
 
 	if (err) {
 		ffsRemoveFile(dir, &amp;fid);
-
-		if (err == -ENOSPC)
-			err = -ENOSPC;
-		else
-			err = -EIO;
 		goto out;
 	}
 
@@ -2666,19 +2639,9 @@ static int exfat_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
 	pr_debug("%s entered\n", __func__);
 
 	err = ffsCreateDir(dir, (u8 *)dentry-&gt;d_name.name, &amp;fid);
-	if (err) {
-		if (err == -EINVAL)
-			err = -EINVAL;
-		else if (err == -EEXIST)
-			err = -EEXIST;
-		else if (err == -ENOSPC)
-			err = -ENOSPC;
-		else if (err == -ENAMETOOLONG)
-			err = -ENAMETOOLONG;
-		else
-			err = -EIO;
+	if (err)
 		goto out;
-	}
+
 	INC_IVERSION(dir);
 	curtime = current_time(dir);
 	dir-&gt;i_ctime = curtime;
@@ -2727,19 +2690,9 @@ static int exfat_rmdir(struct inode *dir, struct dentry *dentry)
 	EXFAT_I(inode)-&gt;fid.size = i_size_read(inode);
 
 	err = ffsRemoveDir(dir, &amp;(EXFAT_I(inode)-&gt;fid));
-	if (err) {
-		if (err == -EINVAL)
-			err = -EINVAL;
-		else if (err == -EEXIST)
-			err = -ENOTEMPTY;
-		else if (err == -ENOENT)
-			err = -ENOENT;
-		else if (err == -EBUSY)
-			err = -EBUSY;
-		else
-			err = -EIO;
+	if (err)
 		goto out;
-	}
+
 	INC_IVERSION(dir);
 	curtime = current_time(dir);
 	dir-&gt;i_mtime = curtime;
@@ -2787,21 +2740,9 @@ static int exfat_rename(struct inode *old_dir, struct dentry *old_dentry,
 
 	err = ffsMoveFile(old_dir, &amp;(EXFAT_I(old_inode)-&gt;fid), new_dir,
 			  new_dentry);
-	if (err) {
-		if (err == -EPERM)
-			err = -EPERM;
-		else if (err == -EINVAL)
-			err = -EINVAL;
-		else if (err == -EEXIST)
-			err = -EEXIST;
-		else if (err == -ENOENT)
-			err = -ENOENT;
-		else if (err == -ENOSPC)
-			err = -ENOSPC;
-		else
-			err = -EIO;
+	if (err)
 		goto out;
-	}
+
 	INC_IVERSION(new_dir);
 	curtime = current_time(new_dir);
 	new_dir-&gt;i_ctime = curtime;
@@ -3161,12 +3102,7 @@ static int exfat_bmap(struct inode *inode, sector_t sector, sector_t *phys,
 
 	err = ffsMapCluster(inode, clu_offset, &amp;cluster);
 
-	if (err) {
-		if (err == -ENOSPC)
-			return -ENOSPC;
-		else
-			return -EIO;
-	} else if (cluster != CLUSTER_32(~0)) {
+	if (!err &amp;&amp; (cluster != CLUSTER_32(~0))) {
 		*phys = START_SECTOR(cluster) + sec_offset;
 		*mapped_blocks = p_fs-&gt;sectors_per_clu - sec_offset;
 	}</pre><hr><pre>commit 4b18672132332d3ec429ea9370d0b380dae730cd
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Mon Nov 11 21:09:55 2019 -0500

    staging: exfat: Clean up return codes - FFS_SUCCESS
    
    Convert FFS_SUCCESS to 0.
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112021000.42091-8-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index b3fc9bb06c24..72cf40e123de 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -208,9 +208,6 @@ static inline u16 get_row_index(u16 i)
 #define FM_REGULAR              0x00
 #define FM_SYMLINK              0x40
 
-/* return values */
-#define FFS_SUCCESS             0
-
 #define NUM_UPCASE              2918
 
 #define DOS_CUR_DIR_NAME        ".          "
diff --git a/drivers/staging/exfat/exfat_cache.c b/drivers/staging/exfat/exfat_cache.c
index 467b93630d86..28a67f8139ea 100644
--- a/drivers/staging/exfat/exfat_cache.c
+++ b/drivers/staging/exfat/exfat_cache.c
@@ -462,7 +462,7 @@ u8 *FAT_getblk(struct super_block *sb, sector_t sec)
 
 	FAT_cache_insert_hash(sb, bp);
 
-	if (sector_read(sb, sec, &amp;bp-&gt;buf_bh, 1) != FFS_SUCCESS) {
+	if (sector_read(sb, sec, &amp;bp-&gt;buf_bh, 1) != 0) {
 		FAT_cache_remove_hash(bp);
 		bp-&gt;drv = -1;
 		bp-&gt;sec = ~0;
@@ -582,7 +582,7 @@ static u8 *__buf_getblk(struct super_block *sb, sector_t sec)
 
 	buf_cache_insert_hash(sb, bp);
 
-	if (sector_read(sb, sec, &amp;bp-&gt;buf_bh, 1) != FFS_SUCCESS) {
+	if (sector_read(sb, sec, &amp;bp-&gt;buf_bh, 1) != 0) {
 		buf_cache_remove_hash(bp);
 		bp-&gt;drv = -1;
 		bp-&gt;sec = ~0;
diff --git a/drivers/staging/exfat/exfat_core.c b/drivers/staging/exfat/exfat_core.c
index ffcad6867ecb..1f0ef94bdd47 100644
--- a/drivers/staging/exfat/exfat_core.c
+++ b/drivers/staging/exfat/exfat_core.c
@@ -102,7 +102,7 @@ void fs_set_vol_flags(struct super_block *sb, u32 new_flag)
 	if (p_fs-&gt;vol_type == EXFAT) {
 		if (!p_fs-&gt;pbr_bh) {
 			if (sector_read(sb, p_fs-&gt;PBR_sector,
-					&amp;p_fs-&gt;pbr_bh, 1) != FFS_SUCCESS)
+					&amp;p_fs-&gt;pbr_bh, 1) != 0)
 				return;
 		}
 
@@ -139,7 +139,7 @@ void fs_error(struct super_block *sb)
 s32 clear_cluster(struct super_block *sb, u32 clu)
 {
 	sector_t s, n;
-	s32 ret = FFS_SUCCESS;
+	s32 ret = 0;
 	struct buffer_head *tmp_bh = NULL;
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
 	struct bd_info_t *p_bd = &amp;(EXFAT_SB(sb)-&gt;bd_info);
@@ -154,12 +154,12 @@ s32 clear_cluster(struct super_block *sb, u32 clu)
 
 	for (; s &lt; n; s++) {
 		ret = sector_read(sb, s, &amp;tmp_bh, 0);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 
 		memset((char *)tmp_bh-&gt;b_data, 0x0, p_bd-&gt;sector_size);
 		ret = sector_write(sb, s, tmp_bh, 0);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			break;
 	}
 
@@ -251,7 +251,7 @@ s32 exfat_alloc_cluster(struct super_block *sb, s32 num_alloc,
 			}
 		}
 
-		if (set_alloc_bitmap(sb, new_clu - 2) != FFS_SUCCESS)
+		if (set_alloc_bitmap(sb, new_clu - 2) != 0)
 			return -EIO;
 
 		num_clusters++;
@@ -370,7 +370,7 @@ void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 					buf_release(sb, sector + i);
 			}
 
-			if (clr_alloc_bitmap(sb, clu - 2) != FFS_SUCCESS)
+			if (clr_alloc_bitmap(sb, clu - 2) != 0)
 				break;
 			clu++;
 
@@ -387,7 +387,7 @@ void exfat_free_cluster(struct super_block *sb, struct chain_t *p_chain,
 					buf_release(sb, sector + i);
 			}
 
-			if (clr_alloc_bitmap(sb, clu - 2) != FFS_SUCCESS)
+			if (clr_alloc_bitmap(sb, clu - 2) != 0)
 				break;
 
 			if (FAT_read(sb, clu, &amp;clu) == -1)
@@ -552,7 +552,7 @@ s32 load_alloc_bitmap(struct super_block *sb)
 				for (j = 0; j &lt; p_fs-&gt;map_sectors; j++) {
 					p_fs-&gt;vol_amap[j] = NULL;
 					ret = sector_read(sb, sector + j, &amp;p_fs-&gt;vol_amap[j], 1);
-					if (ret != FFS_SUCCESS) {
+					if (ret != 0) {
 						/*  release all buffers and free vol_amap */
 						i = 0;
 						while (i &lt; j)
@@ -565,7 +565,7 @@ s32 load_alloc_bitmap(struct super_block *sb)
 				}
 
 				p_fs-&gt;pbr_bh = NULL;
-				return FFS_SUCCESS;
+				return 0;
 			}
 		}
 
@@ -721,7 +721,7 @@ static s32 __load_upcase_table(struct super_block *sb, sector_t sector,
 
 	while (sector &lt; end_sector) {
 		ret = sector_read(sb, sector, &amp;tmp_bh, 1);
-		if (ret != FFS_SUCCESS) {
+		if (ret != 0) {
 			pr_debug("sector read (0x%llX)fail\n",
 				 (unsigned long long)sector);
 			goto error;
@@ -772,7 +772,7 @@ static s32 __load_upcase_table(struct super_block *sb, sector_t sector,
 	if (index &gt;= 0xFFFF &amp;&amp; utbl_checksum == checksum) {
 		if (tmp_bh)
 			brelse(tmp_bh);
-		return FFS_SUCCESS;
+		return 0;
 	}
 	ret = -EINVAL;
 error:
@@ -833,7 +833,7 @@ static s32 __load_default_upcase_table(struct super_block *sb)
 	}
 
 	if (index &gt;= 0xFFFF)
-		return FFS_SUCCESS;
+		return 0;
 
 error:
 	/* FATAL error: default upcase table has error */
@@ -878,9 +878,9 @@ s32 load_upcase_table(struct super_block *sb)
 			sector = START_SECTOR(tbl_clu);
 			num_sectors = ((tbl_size - 1) &gt;&gt; p_bd-&gt;sector_size_bits) + 1;
 			if (__load_upcase_table(sb, sector, num_sectors,
-						GET32_A(ep-&gt;checksum)) != FFS_SUCCESS)
+						GET32_A(ep-&gt;checksum)) != 0)
 				break;
-			return FFS_SUCCESS;
+			return 0;
 		}
 		if (FAT_read(sb, clu.dir, &amp;clu.dir) != 0)
 			return -EIO;
@@ -1251,7 +1251,7 @@ s32 fat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir, s32 entry,
 	init_dos_entry(dos_ep, type, start_clu);
 	buf_modify(sb, sector);
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
@@ -1281,7 +1281,7 @@ s32 exfat_init_dir_entry(struct super_block *sb, struct chain_t *p_dir,
 	init_strm_entry(strm_ep, flags, start_clu, size);
 	buf_modify(sb, sector);
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 static s32 fat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
@@ -1332,7 +1332,7 @@ static s32 fat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
 		buf_modify(sb, sector);
 	}
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 static s32 exfat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
@@ -1378,7 +1378,7 @@ static s32 exfat_init_ext_entry(struct super_block *sb, struct chain_t *p_dir,
 
 	update_dir_checksum(sb, p_dir, entry);
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 void init_dos_entry(struct dos_dentry_t *ep, u32 type, u32 start_clu)
@@ -1599,7 +1599,7 @@ static s32 _walk_fat_chain(struct super_block *sb, struct chain_t *p_dir,
 
 	if (clu)
 		*clu = cur_clu;
-	return FFS_SUCCESS;
+	return 0;
 }
 
 s32 find_location(struct super_block *sb, struct chain_t *p_dir, s32 entry,
@@ -1618,7 +1618,7 @@ s32 find_location(struct super_block *sb, struct chain_t *p_dir, s32 entry,
 		*sector += p_fs-&gt;root_start_sector;
 	} else {
 		ret = _walk_fat_chain(sb, p_dir, off, &amp;clu);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 
 		/* byte offset in cluster */
@@ -1631,7 +1631,7 @@ s32 find_location(struct super_block *sb, struct chain_t *p_dir, s32 entry,
 		*sector = off &gt;&gt; p_bd-&gt;sector_size_bits;
 		*sector += START_SECTOR(clu);
 	}
-	return FFS_SUCCESS;
+	return 0;
 }
 
 struct dentry_t *get_entry_with_sector(struct super_block *sb, sector_t sector,
@@ -1654,7 +1654,7 @@ struct dentry_t *get_entry_in_dir(struct super_block *sb, struct chain_t *p_dir,
 	sector_t sec;
 	u8 *buf;
 
-	if (find_location(sb, p_dir, entry, &amp;sec, &amp;off) != FFS_SUCCESS)
+	if (find_location(sb, p_dir, entry, &amp;sec, &amp;off) != 0)
 		return NULL;
 
 	buf = buf_getblk(sb, sec);
@@ -1708,7 +1708,7 @@ struct entry_set_cache_t *get_entry_set_in_dir(struct super_block *sb,
 
 	byte_offset = entry &lt;&lt; DENTRY_SIZE_BITS;
 	ret = _walk_fat_chain(sb, p_dir, byte_offset, &amp;clu);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return NULL;
 
 	/* byte offset in cluster */
@@ -1903,7 +1903,7 @@ static s32 __write_partial_entries_in_entry_set(struct super_block *sb,
 	}
 
 	pr_debug("%s exited successfully\n", __func__);
-	return FFS_SUCCESS;
+	return 0;
 err_out:
 	pr_debug("%s failed\n", __func__);
 	return -EINVAL;
@@ -1942,7 +1942,7 @@ s32 write_partial_entries_in_entry_set(struct super_block *sb,
 	byte_offset += ((void **)ep - &amp;es-&gt;__buf) + es-&gt;offset;
 
 	ret = _walk_fat_chain(sb, &amp;dir, byte_offset, &amp;clu);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return ret;
 
 	/* byte offset in cluster */
@@ -2086,7 +2086,7 @@ s32 find_empty_entry(struct inode *inode, struct chain_t *p_dir, s32 num_entries
 		if (ret &lt; 1)
 			return -EIO;
 
-		if (clear_cluster(sb, clu.dir) != FFS_SUCCESS)
+		if (clear_cluster(sb, clu.dir) != 0)
 			return -EIO;
 
 		/* (2) append to the FAT chain */
@@ -2597,7 +2597,7 @@ s32 get_num_entries_and_dos_name(struct super_block *sb, struct chain_t *p_dir,
 
 	*entries = num_entries;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 void get_uni_name_from_dos_entry(struct super_block *sb,
@@ -2833,7 +2833,7 @@ s32 fat_generate_dos_name(struct super_block *sb, struct chain_t *p_dir,
 	fat_attach_count_to_dos_name(p_dosname-&gt;name, count);
 
 	/* Now dos_name has DOS~????.EXT */
-	return FFS_SUCCESS;
+	return 0;
 }
 
 void fat_attach_count_to_dos_name(u8 *dosname, s32 count)
@@ -2975,7 +2975,7 @@ s32 resolve_path(struct inode *inode, char *path, struct chain_t *p_dir,
 	p_dir-&gt;size = (s32)(fid-&gt;size &gt;&gt; p_fs-&gt;cluster_size_bits);
 	p_dir-&gt;flags = fid-&gt;flags;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 /*
@@ -3067,7 +3067,7 @@ s32 fat16_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
 
 	p_fs-&gt;fs_func = &amp;fat_fs_func;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 s32 fat32_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
@@ -3120,7 +3120,7 @@ s32 fat32_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
 
 	p_fs-&gt;fs_func = &amp;fat_fs_func;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 static struct fs_func exfat_fs_func = {
@@ -3195,7 +3195,7 @@ s32 exfat_mount(struct super_block *sb, struct pbr_sector_t *p_pbr)
 
 	p_fs-&gt;fs_func = &amp;exfat_fs_func;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 s32 create_dir(struct inode *inode, struct chain_t *p_dir,
@@ -3231,7 +3231,7 @@ s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 		return -ENOSPC;
 
 	ret = clear_cluster(sb, clu.dir);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return ret;
 
 	if (p_fs-&gt;vol_type == EXFAT) {
@@ -3249,11 +3249,11 @@ s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 
 		ret = fs_func-&gt;init_dir_entry(sb, &amp;clu, 0, TYPE_DIR, clu.dir,
 					      0);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 
 		ret = fs_func-&gt;init_ext_entry(sb, &amp;clu, 0, 1, NULL, &amp;dot_name);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 
 		memcpy(dot_name.name, DOS_PAR_DIR_NAME, DOS_NAME_LENGTH);
@@ -3265,12 +3265,12 @@ s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 			ret = fs_func-&gt;init_dir_entry(sb, &amp;clu, 1, TYPE_DIR,
 						      p_dir-&gt;dir, 0);
 
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 
 		ret = p_fs-&gt;fs_func-&gt;init_ext_entry(sb, &amp;clu, 1, 1, NULL,
 						    &amp;dot_name);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 	}
 
@@ -3278,12 +3278,12 @@ s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 	/* make sub-dir entry in parent directory */
 	ret = fs_func-&gt;init_dir_entry(sb, p_dir, dentry, TYPE_DIR, clu.dir,
 				      size);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return ret;
 
 	ret = fs_func-&gt;init_ext_entry(sb, p_dir, dentry, num_entries, p_uniname,
 				      &amp;dos_name);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return ret;
 
 	fid-&gt;dir.dir = p_dir-&gt;dir;
@@ -3300,7 +3300,7 @@ s32 create_dir(struct inode *inode, struct chain_t *p_dir,
 	fid-&gt;rwoffset = 0;
 	fid-&gt;hint_last_off = -1;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 s32 create_file(struct inode *inode, struct chain_t *p_dir,
@@ -3328,12 +3328,12 @@ s32 create_file(struct inode *inode, struct chain_t *p_dir,
 	 */
 	ret = fs_func-&gt;init_dir_entry(sb, p_dir, dentry, TYPE_FILE | mode,
 				      CLUSTER_32(0), 0);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return ret;
 
 	ret = fs_func-&gt;init_ext_entry(sb, p_dir, dentry, num_entries, p_uniname,
 				      &amp;dos_name);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return ret;
 
 	fid-&gt;dir.dir = p_dir-&gt;dir;
@@ -3350,7 +3350,7 @@ s32 create_file(struct inode *inode, struct chain_t *p_dir,
 	fid-&gt;rwoffset = 0;
 	fid-&gt;hint_last_off = -1;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 void remove_file(struct inode *inode, struct chain_t *p_dir, s32 entry)
@@ -3458,7 +3458,7 @@ s32 rename_file(struct inode *inode, struct chain_t *p_dir, s32 oldentry,
 		ret = fs_func-&gt;init_ext_entry(sb, p_dir, newentry,
 					      num_new_entries, p_uniname,
 					      &amp;dos_name);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 
 		fs_func-&gt;delete_dir_entry(sb, p_dir, oldentry, 0,
@@ -3477,14 +3477,14 @@ s32 rename_file(struct inode *inode, struct chain_t *p_dir, s32 oldentry,
 		ret = fs_func-&gt;init_ext_entry(sb, p_dir, oldentry,
 					      num_new_entries, p_uniname,
 					      &amp;dos_name);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			return ret;
 
 		fs_func-&gt;delete_dir_entry(sb, p_dir, oldentry, num_new_entries,
 					  num_old_entries);
 	}
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 s32 move_file(struct inode *inode, struct chain_t *p_olddir, s32 oldentry,
@@ -3580,7 +3580,7 @@ s32 move_file(struct inode *inode, struct chain_t *p_olddir, s32 oldentry,
 
 	ret = fs_func-&gt;init_ext_entry(sb, p_newdir, newentry, num_new_entries,
 				      p_uniname, &amp;dos_name);
-	if (ret != FFS_SUCCESS)
+	if (ret != 0)
 		return ret;
 
 	fs_func-&gt;delete_dir_entry(sb, p_olddir, oldentry, 0, num_old_entries);
@@ -3591,7 +3591,7 @@ s32 move_file(struct inode *inode, struct chain_t *p_olddir, s32 oldentry,
 
 	fid-&gt;entry = newentry;
 
-	return FFS_SUCCESS;
+	return 0;
 }
 
 /*
@@ -3614,7 +3614,7 @@ int sector_read(struct super_block *sb, sector_t sec, struct buffer_head **bh,
 
 	if (!p_fs-&gt;dev_ejected) {
 		ret = bdev_read(sb, sec, bh, 1, read);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
 
@@ -3643,7 +3643,7 @@ int sector_write(struct super_block *sb, sector_t sec, struct buffer_head *bh,
 
 	if (!p_fs-&gt;dev_ejected) {
 		ret = bdev_write(sb, sec, bh, 1, sync);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
 
@@ -3666,7 +3666,7 @@ int multi_sector_read(struct super_block *sb, sector_t sec,
 
 	if (!p_fs-&gt;dev_ejected) {
 		ret = bdev_read(sb, sec, bh, num_secs, read);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
 
@@ -3694,7 +3694,7 @@ int multi_sector_write(struct super_block *sb, sector_t sec,
 
 	if (!p_fs-&gt;dev_ejected) {
 		ret = bdev_write(sb, sec, bh, num_secs, sync);
-		if (ret != FFS_SUCCESS)
+		if (ret != 0)
 			p_fs-&gt;dev_ejected = 1;
 	}
 
diff --git a/drivers/staging/exfat/exfat_super.c b/drivers/staging/exfat/exfat_super.c
index 2f199d78bfa6..7941944ec09f 100644
--- a/drivers/staging/exfat/exfat_super.c
+++ b/drivers/staging/exfat/exfat_super.c
@@ -373,7 +373,7 @@ static int ffsMountVol(struct super_block *sb)
 		sb_set_blocksize(sb, p_bd-&gt;sector_size);
 
 	/* read Sector 0 */
-	if (sector_read(sb, 0, &amp;tmp_bh, 1) != FFS_SUCCESS) {
+	if (sector_read(sb, 0, &amp;tmp_bh, 1) != 0) {
 		ret = -EIO;
 		goto out;
 	}
@@ -452,7 +452,7 @@ static int ffsMountVol(struct super_block *sb)
 static int ffsUmountVol(struct super_block *sb)
 {
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
-	int err = FFS_SUCCESS;
+	int err = 0;
 
 	pr_info("[EXFAT] trying to unmount...\n");
 
@@ -493,7 +493,7 @@ static int ffsUmountVol(struct super_block *sb)
 
 static int ffsGetVolInfo(struct super_block *sb, struct vol_info_t *info)
 {
-	int err = FFS_SUCCESS;
+	int err = 0;
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
 
 	/* check the validity of pointer parameters */
@@ -523,7 +523,7 @@ static int ffsGetVolInfo(struct super_block *sb, struct vol_info_t *info)
 
 static int ffsSyncVol(struct super_block *sb, bool do_sync)
 {
-	int err = FFS_SUCCESS;
+	int err = 0;
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);
 
 	/* acquire the lock for file system critical section */
@@ -776,13 +776,13 @@ static int ffsReadFile(struct inode *inode, struct file_id_t *fid, void *buffer,
 
 		if ((offset == 0) &amp;&amp; (oneblkread == p_bd-&gt;sector_size)) {
 			if (sector_read(sb, LogSector, &amp;tmp_bh, 1) !=
-			    FFS_SUCCESS)
+			    0)
 				goto err_out;
 			memcpy((char *)buffer + read_bytes,
 			       (char *)tmp_bh-&gt;b_data, (s32)oneblkread);
 		} else {
 			if (sector_read(sb, LogSector, &amp;tmp_bh, 1) !=
-			    FFS_SUCCESS)
+			    0)
 				goto err_out;
 			memcpy((char *)buffer + read_bytes,
 			       (char *)tmp_bh-&gt;b_data + offset,
@@ -852,7 +852,7 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 	if (count == 0) {
 		if (wcount)
 			*wcount = 0;
-		ret = FFS_SUCCESS;
+		ret = 0;
 		goto out;
 	}
 
@@ -962,12 +962,12 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 
 		if ((offset == 0) &amp;&amp; (oneblkwrite == p_bd-&gt;sector_size)) {
 			if (sector_read(sb, LogSector, &amp;tmp_bh, 0) !=
-			    FFS_SUCCESS)
+			    0)
 				goto err_out;
 			memcpy((char *)tmp_bh-&gt;b_data,
 			       (char *)buffer + write_bytes, (s32)oneblkwrite);
 			if (sector_write(sb, LogSector, tmp_bh, 0) !=
-			    FFS_SUCCESS) {
+			    0) {
 				brelse(tmp_bh);
 				goto err_out;
 			}
@@ -975,18 +975,18 @@ static int ffsWriteFile(struct inode *inode, struct file_id_t *fid,
 			if ((offset &gt; 0) ||
 			    ((fid-&gt;rwoffset + oneblkwrite) &lt; fid-&gt;size)) {
 				if (sector_read(sb, LogSector, &amp;tmp_bh, 1) !=
-				    FFS_SUCCESS)
+				    0)
 					goto err_out;
 			} else {
 				if (sector_read(sb, LogSector, &amp;tmp_bh, 0) !=
-				    FFS_SUCCESS)
+				    0)
 					goto err_out;
 			}
 
 			memcpy((char *)tmp_bh-&gt;b_data + offset,
 			       (char *)buffer + write_bytes, (s32)oneblkwrite);
 			if (sector_write(sb, LogSector, tmp_bh, 0) !=
-			    FFS_SUCCESS) {
+			    0) {
 				brelse(tmp_bh);
 				goto err_out;
 			}
@@ -1100,7 +1100,7 @@ static int ffsTruncateFile(struct inode *inode, u64 old_size, u64 new_size)
 	}
 
 	if (old_size &lt;= new_size) {
-		ret = FFS_SUCCESS;
+		ret = 0;
 		goto out;
 	}
 
@@ -1319,7 +1319,7 @@ static int ffsMoveFile(struct inode *old_parent_inode, struct file_id_t *fid,
 		ret = move_file(new_parent_inode, &amp;olddir, dentry, &amp;newdir,
 				&amp;uni_name, fid);
 
-	if ((ret == FFS_SUCCESS) &amp;&amp; new_inode) {
+	if ((ret == 0) &amp;&amp; new_inode) {
 		/* delete entries of new_dir */
 		ep = get_entry_in_dir(sb, p_dir, new_entry, NULL);
 		if (!ep)
@@ -1350,7 +1350,7 @@ static int ffsMoveFile(struct inode *old_parent_inode, struct file_id_t *fid,
 static int ffsRemoveFile(struct inode *inode, struct file_id_t *fid)
 {
 	s32 dentry;
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	struct chain_t dir, clu_to_free;
 	struct dentry_t *ep;
 	struct super_block *sb = inode-&gt;i_sb;
@@ -1414,7 +1414,7 @@ static int ffsRemoveFile(struct inode *inode, struct file_id_t *fid)
 static int ffsSetAttr(struct inode *inode, u32 attr)
 {
 	u32 type;
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	sector_t sector = 0;
 	struct dentry_t *ep;
 	struct super_block *sb = inode-&gt;i_sb;
@@ -1426,7 +1426,7 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 	if (fid-&gt;attr == attr) {
 		if (p_fs-&gt;dev_ejected)
 			return -EIO;
-		return FFS_SUCCESS;
+		return 0;
 	}
 
 	if (is_dir) {
@@ -1434,7 +1434,7 @@ static int ffsSetAttr(struct inode *inode, u32 attr)
 		    (fid-&gt;entry == -1)) {
 			if (p_fs-&gt;dev_ejected)
 				return -EIO;
-			return FFS_SUCCESS;
+			return 0;
 		}
 	}
 
@@ -1503,7 +1503,7 @@ static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 {
 	sector_t sector = 0;
 	s32 count;
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	struct chain_t dir;
 	struct uni_name_t uni_name;
 	struct timestamp_t tm;
@@ -1655,7 +1655,7 @@ static int ffsReadStat(struct inode *inode, struct dir_entry_t *info)
 static int ffsWriteStat(struct inode *inode, struct dir_entry_t *info)
 {
 	sector_t sector = 0;
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	struct timestamp_t tm;
 	struct dentry_t *ep, *ep2;
 	struct entry_set_cache_t *es = NULL;
@@ -1674,7 +1674,7 @@ static int ffsWriteStat(struct inode *inode, struct dir_entry_t *info)
 		    (fid-&gt;entry == -1)) {
 			if (p_fs-&gt;dev_ejected)
 				ret = -EIO;
-			ret = FFS_SUCCESS;
+			ret = 0;
 			goto out;
 		}
 	}
@@ -1745,7 +1745,7 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 	s32 num_clusters, num_alloced;
 	bool modified = false;
 	u32 last_clu;
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	sector_t sector = 0;
 	struct chain_t new_clu;
 	struct dentry_t *ep;
@@ -1898,7 +1898,7 @@ static int ffsMapCluster(struct inode *inode, s32 clu_offset, u32 *clu)
 
 static int ffsCreateDir(struct inode *inode, char *path, struct file_id_t *fid)
 {
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	struct chain_t dir;
 	struct uni_name_t uni_name;
 	struct super_block *sb = inode-&gt;i_sb;
@@ -1939,7 +1939,7 @@ static int ffsCreateDir(struct inode *inode, char *path, struct file_id_t *fid)
 static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 {
 	int i, dentry, clu_offset;
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	s32 dentries_per_clu, dentries_per_clu_bits = 0;
 	u32 type;
 	sector_t sector;
@@ -2138,7 +2138,7 @@ static int ffsReadDir(struct inode *inode, struct dir_entry_t *dir_entry)
 static int ffsRemoveDir(struct inode *inode, struct file_id_t *fid)
 {
 	s32 dentry;
-	int ret = FFS_SUCCESS;
+	int ret = 0;
 	struct chain_t dir, clu_to_free;
 	struct super_block *sb = inode-&gt;i_sb;
 	struct fs_info_t *p_fs = &amp;(EXFAT_SB(sb)-&gt;fs_info);</pre><hr><pre>commit 97eab6cee3a6ac679a2f531a248df3c994182522
Author: Valdis Kletnieks &lt;valdis.kletnieks@vt.edu&gt;
Date:   Mon Nov 11 21:09:54 2019 -0500

    staging: exfat: Clean up return codes - remove unused codes
    
    There are 6 FFS_* error values not used at all. Remove them.
    
    Signed-off-by: Valdis Kletnieks &lt;Valdis.Kletnieks@vt.edu&gt;
    Link: https://lore.kernel.org/r/20191112021000.42091-7-Valdis.Kletnieks@vt.edu
    Signed-off-by: Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;

diff --git a/drivers/staging/exfat/exfat.h b/drivers/staging/exfat/exfat.h
index 443fafe1d89d..b3fc9bb06c24 100644
--- a/drivers/staging/exfat/exfat.h
+++ b/drivers/staging/exfat/exfat.h
@@ -210,12 +210,6 @@ static inline u16 get_row_index(u16 i)
 
 /* return values */
 #define FFS_SUCCESS             0
-#define FFS_MOUNTED             3
-#define FFS_NOTMOUNTED          4
-#define FFS_ALIGNMENTERR        5
-#define FFS_SEMAPHOREERR        6
-#define FFS_NOTOPENED           12
-#define FFS_MAXOPENED           13
 
 #define NUM_UPCASE              2918
 </pre>
    <div class="pagination">
        <a href='10_2.html'>&lt;&lt;Prev</a><a href='10.html'>1</a><a href='10_2.html'>2</a><span>[3]</span><a href='10_4.html'>4</a><a href='10_5.html'>5</a><a href='10_6.html'>6</a><a href='10_7.html'>7</a><a href='10_8.html'>8</a><a href='10_9.html'>9</a><a href='10_10.html'>10</a><a href='10_11.html'>11</a><a href='10_12.html'>12</a><a href='10_4.html'>Next&gt;&gt;</a>
    <div>
</body>
