<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patches contributed by University of Michigan - Ann Arbor</title>
    <style>
    .pagination {
        border-top: 1px solid #ddd;
        border-bottom: 1px solid #ddd;
        overflow-wrap: break-word;
    }
    .pagination a, .pagination span {
        margin: 0 4px;
    }

    </style>
</head>
<body>
    <h1>Patches contributed by University of Michigan - Ann Arbor</h1>
    <div class="pagination">
        <a href='4_51.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><span>[52]</span><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_53.html'>Next&gt;&gt;</a>
    </div>
    <hr>
    <pre>commit ae8b625313db4dd4b060962c2a02f3a2837ca61b
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:32 2006 -0800

    [PATCH] nfsd4: no replays on unconfirmed owners
    
    We shouldn't check for replays until after checking whether the open owner is
    confirmed.  Clients are allowed to reuse openowners without bumping the seqid.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index e13d2233ff8c..dc792b6b4513 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1465,8 +1465,16 @@ nfsd4_process_open1(struct nfsd4_open *open)
 	sop = find_openstateowner_str(strhashval, open);
 	if (sop) {
 		open-&gt;op_stateowner = sop;
-		/* check for replay */
-		if (open-&gt;op_seqid == sop-&gt;so_seqid - 1){
+		if (!sop-&gt;so_confirmed) {
+			/* Replace any unconfirmed stateowner without
+			 * even checking for replays */
+			clp = sop-&gt;so_client;
+			release_stateowner(sop);
+		} else if (open-&gt;op_seqid == sop-&gt;so_seqid) {
+			/* normal case */
+			goto renew;
+		} else if (open-&gt;op_seqid == sop-&gt;so_seqid - 1) {
+			/* replay */
 			if (sop-&gt;so_replay.rp_buflen)
 				return NFSERR_REPLAY_ME;
 			else {
@@ -1480,19 +1488,9 @@ nfsd4_process_open1(struct nfsd4_open *open)
 					" replay with no replay cache\n");
 				goto renew;
 			}
-		} else if (sop-&gt;so_confirmed) {
-			if (open-&gt;op_seqid == sop-&gt;so_seqid)
-				goto renew;
+		} else {
 			status = nfserr_bad_seqid;
 			goto out;
-		} else {
-			/* If we get here, we received an OPEN for an
-			 * unconfirmed nfs4_stateowner. Since the seqid's are
-			 * different, purge the existing nfs4_stateowner, and
-			 * instantiate a new one.
-			 */
-			clp = sop-&gt;so_client;
-			release_stateowner(sop);
 		}
 	} else {
 		/* nfs4_stateowner not found.</pre><hr><pre>commit a525825df15221a95d4c1f5a291d9fde77ef10bc
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:30 2006 -0800

    [PATCH] nfsd4: handle replays of failed open reclaims
    
    We need to make sure open reclaims are marked confirmed immediately so that we
    can handle replays even if they fail (e.g.  with a seqid-incrementing error).
    (See 8.1.8.)
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 2a1766ce216f..69ee182575ab 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -210,6 +210,7 @@ nfsd4_open(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open
 				goto out;
 			break;
 		case NFS4_OPEN_CLAIM_PREVIOUS:
+			open-&gt;op_stateowner-&gt;so_confirmed = 1;
 			/*
 			 * The CURRENT_FH is already set to the file being
 			 * opened.  (1) set open-&gt;op_cinfo, (2) set
@@ -221,6 +222,7 @@ nfsd4_open(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_open
 				goto out;
 			break;
              	case NFS4_OPEN_CLAIM_DELEGATE_PREV:
+			open-&gt;op_stateowner-&gt;so_confirmed = 1;
 			printk("NFSD: unsupported OPEN claim type %d\n",
 				open-&gt;op_claim_type);
 			status = nfserr_notsupp;</pre><hr><pre>commit c2642ab05b855d2d3b850ddf90dbb02b1b9358ac
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:29 2006 -0800

    [PATCH] nfsd4: recovery lookup dir check
    
    Make sure we get a directory when we look up the recovery directory.
    
    Thanks to Christoph Hellwig for the bug report.
    
    Based on feedback from Christoph and others, we may remove the need for this
    lookup and just pass in a file descriptor from userspace instead, and/or
    completely move the directory handling to userspace.  For now we're just
    fixing the obvious bugs.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index 64f4af3651a1..06da7506363c 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -399,9 +399,10 @@ nfsd4_init_recdir(char *rec_dirname)
 
 	nfs4_save_user(&amp;uid, &amp;gid);
 
-	status = path_lookup(rec_dirname, LOOKUP_FOLLOW, &amp;rec_dir);
-	if (status == -ENOENT)
-		printk("NFSD: recovery directory %s doesn't exist\n",
+	status = path_lookup(rec_dirname, LOOKUP_FOLLOW | LOOKUP_DIRECTORY,
+			&amp;rec_dir);
+	if (status)
+		printk("NFSD: unable to find recovery directory %s\n",
 				rec_dirname);
 
 	if (!status)</pre><hr><pre>commit d22749b62f3e12de26b86a200f9a5bf7afe3590e
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:27 2006 -0800

    [PATCH] nfsd4: fix open of recovery directory
    
    We should be opening this directory RDONLY, not RDWR.
    
    Thanks to Christoph Hellwig for the bug report.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index be963a133aaa..64f4af3651a1 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -222,8 +222,7 @@ nfsd4_list_rec_dir(struct dentry *dir, recdir_func *f)
 
 	nfs4_save_user(&amp;uid, &amp;gid);
 
-	filp = dentry_open(dget(dir), mntget(rec_dir.mnt),
-			O_RDWR);
+	filp = dentry_open(dget(dir), mntget(rec_dir.mnt), O_RDONLY);
 	status = PTR_ERR(filp);
 	if (IS_ERR(filp))
 		goto out;</pre><hr><pre>commit 5fb8b49e2955cc473929c5994b8389111daed59d
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:26 2006 -0800

    [PATCH] svcrpc: gss: svc context creation error handling
    
    Allow mechanisms to return more varied errors on the context creation
    downcall.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index fdad66dc9a9f..23632d84d8d7 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -420,7 +420,8 @@ static int rsc_parse(struct cache_detail *cd,
 			gss_mech_put(gm);
 			goto out;
 		}
-		if (gss_import_sec_context(buf, len, gm, &amp;rsci.mechctx)) {
+		status = gss_import_sec_context(buf, len, gm, &amp;rsci.mechctx);
+		if (status) {
 			gss_mech_put(gm);
 			goto out;
 		}</pre><hr><pre>commit 91a4762e0ab0880fa00e8f0b7a052e4929d867a6
Author: Kevin Coffman &lt;kwc@citi.umich.edu&gt;
Date:   Wed Jan 18 17:43:25 2006 -0800

    [PATCH] svcrpc: gss: server context init failure handling
    
    We require the server's gssd to create a completed context before asking the
    kernel to send a final context init reply.  However, gssd could be buggy, or
    under some bizarre circumstances we might purge the context from our cache
    before we get the chance to use it here.
    
    Handle this case by returning GSS_S_NO_CONTEXT to the client.
    
    Also move the relevant code here to a separate function rather than nesting
    excessively.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index d2ccc7e8faab..fdad66dc9a9f 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -755,6 +755,21 @@ svcauth_gss_set_client(struct svc_rqst *rqstp)
 	return SVC_OK;
 }
 
+static inline int
+gss_write_init_verf(struct svc_rqst *rqstp, struct rsi *rsip)
+{
+	struct rsc *rsci;
+
+	if (rsip-&gt;major_status != GSS_S_COMPLETE)
+		return gss_write_null_verf(rqstp);
+	rsci = gss_svc_searchbyctx(&amp;rsip-&gt;out_handle);
+	if (rsci == NULL) {
+		rsip-&gt;major_status = GSS_S_NO_CONTEXT;
+		return gss_write_null_verf(rqstp);
+	}
+	return gss_write_verf(rqstp, rsci-&gt;mechctx, GSS_SEQ_WIN);
+}
+
 /*
  * Accept an rpcsec packet.
  * If context establishment, punt to user space
@@ -890,18 +905,8 @@ svcauth_gss_accept(struct svc_rqst *rqstp, u32 *authp)
 		case -ENOENT:
 			goto drop;
 		case 0:
-			if (rsip-&gt;major_status == GSS_S_COMPLETE) {
-				rsci = gss_svc_searchbyctx(&amp;rsip-&gt;out_handle);
-				if (!rsci) {
-					goto drop;
-				}
-				if (gss_write_verf(rqstp, rsci-&gt;mechctx,
-							GSS_SEQ_WIN))
-					goto drop;
-			} else {
-				if (gss_write_null_verf(rqstp))
-					goto drop;
-			}
+			if (gss_write_init_verf(rqstp, rsip))
+				goto drop;
 			if (resv-&gt;iov_len + 4 &gt; PAGE_SIZE)
 				goto drop;
 			svc_putu32(resv, rpc_success);</pre><hr><pre>commit 822f1005ae1f3a4a8b136f38a6933d3f719f4c4a
Author: Andy Adamson &lt;andros@citi.umich.edu&gt;
Date:   Wed Jan 18 17:43:24 2006 -0800

    [PATCH] svcrpc: gss: handle the GSS_S_CONTINUE
    
    Kerberos context initiation is handled in a single round trip, but other
    mechanisms (including spkm3) may require more, so we need to handle the
    GSS_S_CONTINUE case in svcauth_gss_accept.  Send a null verifier.
    
    Signed-off-by: Andy Adamson &lt;andros@citi.umich.edu&gt;
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c
index e4ada15ed856..d2ccc7e8faab 100644
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@ -585,6 +585,20 @@ gss_verify_header(struct svc_rqst *rqstp, struct rsc *rsci,
 	return SVC_OK;
 }
 
+static int
+gss_write_null_verf(struct svc_rqst *rqstp)
+{
+	u32     *p;
+
+	svc_putu32(rqstp-&gt;rq_res.head, htonl(RPC_AUTH_NULL));
+	p = rqstp-&gt;rq_res.head-&gt;iov_base + rqstp-&gt;rq_res.head-&gt;iov_len;
+	/* don't really need to check if head-&gt;iov_len &gt; PAGE_SIZE ... */
+	*p++ = 0;
+	if (!xdr_ressize_check(rqstp, p))
+		return -1;
+	return 0;
+}
+
 static int
 gss_write_verf(struct svc_rqst *rqstp, struct gss_ctx *ctx_id, u32 seq)
 {
@@ -876,12 +890,18 @@ svcauth_gss_accept(struct svc_rqst *rqstp, u32 *authp)
 		case -ENOENT:
 			goto drop;
 		case 0:
-			rsci = gss_svc_searchbyctx(&amp;rsip-&gt;out_handle);
-			if (!rsci) {
-				goto drop;
+			if (rsip-&gt;major_status == GSS_S_COMPLETE) {
+				rsci = gss_svc_searchbyctx(&amp;rsip-&gt;out_handle);
+				if (!rsci) {
+					goto drop;
+				}
+				if (gss_write_verf(rqstp, rsci-&gt;mechctx,
+							GSS_SEQ_WIN))
+					goto drop;
+			} else {
+				if (gss_write_null_verf(rqstp))
+					goto drop;
 			}
-			if (gss_write_verf(rqstp, rsci-&gt;mechctx, GSS_SEQ_WIN))
-				goto drop;
 			if (resv-&gt;iov_len + 4 &gt; PAGE_SIZE)
 				goto drop;
 			svc_putu32(resv, rpc_success);</pre><hr><pre>commit fd44527707f2697fd2959e8bdb321ae588d150e2
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:23 2006 -0800

    [PATCH] nfsd4: operation debugging
    
    Simple, useful debugging printk: print the number of each op as we process it.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4proc.c b/fs/nfsd/nfs4proc.c
index 361b4007d4a0..2a1766ce216f 100644
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@ -768,6 +768,8 @@ nfsd4_proc_compound(struct svc_rqst *rqstp,
 	while (!status &amp;&amp; resp-&gt;opcnt &lt; args-&gt;opcnt) {
 		op = &amp;args-&gt;ops[resp-&gt;opcnt++];
 
+		dprintk("nfsv4 compound op #%d: %d\n", resp-&gt;opcnt, op-&gt;opnum);
+
 		/*
 		 * The XDR decode routines may have pre-set op-&gt;status;
 		 * for example, if there is a miscellaneous XDR error</pre><hr><pre>commit 796dadfd02eda1e3e6e42ecc8379d8b1c1523ddf
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:22 2006 -0800

    [PATCH] nfsd4: fix check_for_locks
    
    Fix some bad logic.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 3510e2ca40d2..e13d2233ff8c 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -2989,9 +2989,10 @@ check_for_locks(struct file *filp, struct nfs4_stateowner *lowner)
 
 	lock_kernel();
 	for (flpp = &amp;inode-&gt;i_flock; *flpp != NULL; flpp = &amp;(*flpp)-&gt;fl_next) {
-		if ((*flpp)-&gt;fl_owner == (fl_owner_t)lowner)
+		if ((*flpp)-&gt;fl_owner == (fl_owner_t)lowner) {
 			status = 1;
 			goto out;
+		}
 	}
 out:
 	unlock_kernel();</pre><hr><pre>commit 04ef59548470b81829e8593c1b39776ce0534d68
Author: J. Bruce Fields &lt;bfields@fieldses.org&gt;
Date:   Wed Jan 18 17:43:21 2006 -0800

    [PATCH] nfsd4: remove release_state_owner()
    
    It's confusing having both release_stateowner() and release_state_owner().
    
    And as it turns out, release_state_owner() is short and only called from one
    place; so just remove it.
    
    Also note the confirmed check is superfluous there--preprocess_seqid_op
    already check this.
    
    And remove a redundant comment and a superfluous line assignment while we're
    at it.
    
    Signed-off-by: J. Bruce Fields &lt;bfields@citi.umich.edu&gt;
    Signed-off-by: Neil Brown &lt;neilb@suse.de&gt;
    Signed-off-by: Andrew Morton &lt;akpm@osdl.org&gt;
    Signed-off-by: Linus Torvalds &lt;torvalds@osdl.org&gt;

diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c
index 578ea521c827..3510e2ca40d2 100644
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@ -1178,7 +1178,6 @@ release_stateid(struct nfs4_stateid *stp, int flags)
 		locks_remove_posix(filp, (fl_owner_t) stp-&gt;st_stateowner);
 	put_nfs4_file(stp-&gt;st_file);
 	kmem_cache_free(stateid_slab, stp);
-	stp = NULL;
 }
 
 static void
@@ -1191,22 +1190,6 @@ move_to_close_lru(struct nfs4_stateowner *sop)
 	sop-&gt;so_time = get_seconds();
 }
 
-static void
-release_state_owner(struct nfs4_stateid *stp, int flag)
-{
-	struct nfs4_stateowner *sop = stp-&gt;st_stateowner;
-
-	dprintk("NFSD: release_state_owner\n");
-	release_stateid(stp, flag);
-
-	/* place unused nfs4_stateowners on so_close_lru list to be
-	 * released by the laundromat service after the lease period
-	 * to enable us to handle CLOSE replay
-	 */
-	if (sop-&gt;so_confirmed &amp;&amp; list_empty(&amp;sop-&gt;so_stateids))
-		move_to_close_lru(sop);
-}
-
 static int
 cmp_owner_str(struct nfs4_stateowner *sop, struct xdr_netobj *owner, clientid_t *clid) {
 	return ((sop-&gt;so_owner.len == owner-&gt;len) &amp;&amp; 
@@ -2423,15 +2406,19 @@ nfsd4_close(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nfsd4_clos
 					CHECK_FH | OPEN_STATE | CLOSE_STATE,
 					&amp;close-&gt;cl_stateowner, &amp;stp, NULL)))
 		goto out; 
-	/*
-	*  Return success, but first update the stateid.
-	*/
 	status = nfs_ok;
 	update_stateid(&amp;stp-&gt;st_stateid);
 	memcpy(&amp;close-&gt;cl_stateid, &amp;stp-&gt;st_stateid, sizeof(stateid_t));
 
-	/* release_state_owner() calls nfsd_close() if needed */
-	release_state_owner(stp, OPEN_STATE);
+	/* release_stateid() calls nfsd_close() if needed */
+	release_stateid(stp, OPEN_STATE);
+
+	/* place unused nfs4_stateowners on so_close_lru list to be
+	 * released by the laundromat service after the lease period
+	 * to enable us to handle CLOSE replay
+	 */
+	if (list_empty(&amp;close-&gt;cl_stateowner-&gt;so_stateids))
+		move_to_close_lru(close-&gt;cl_stateowner);
 out:
 	if (close-&gt;cl_stateowner) {
 		nfs4_get_stateowner(close-&gt;cl_stateowner);</pre>
    <div class="pagination">
        <a href='4_51.html'>&lt;&lt;Prev</a><a href='4.html'>1</a><a href='4_2.html'>2</a><a href='4_3.html'>3</a><a href='4_4.html'>4</a><a href='4_5.html'>5</a><a href='4_6.html'>6</a><a href='4_7.html'>7</a><a href='4_8.html'>8</a><a href='4_9.html'>9</a><a href='4_10.html'>10</a><a href='4_11.html'>11</a><a href='4_12.html'>12</a><a href='4_13.html'>13</a><a href='4_14.html'>14</a><a href='4_15.html'>15</a><a href='4_16.html'>16</a><a href='4_17.html'>17</a><a href='4_18.html'>18</a><a href='4_19.html'>19</a><a href='4_20.html'>20</a><a href='4_21.html'>21</a><a href='4_22.html'>22</a><a href='4_23.html'>23</a><a href='4_24.html'>24</a><a href='4_25.html'>25</a><a href='4_26.html'>26</a><a href='4_27.html'>27</a><a href='4_28.html'>28</a><a href='4_29.html'>29</a><a href='4_30.html'>30</a><a href='4_31.html'>31</a><a href='4_32.html'>32</a><a href='4_33.html'>33</a><a href='4_34.html'>34</a><a href='4_35.html'>35</a><a href='4_36.html'>36</a><a href='4_37.html'>37</a><a href='4_38.html'>38</a><a href='4_39.html'>39</a><a href='4_40.html'>40</a><a href='4_41.html'>41</a><a href='4_42.html'>42</a><a href='4_43.html'>43</a><a href='4_44.html'>44</a><a href='4_45.html'>45</a><a href='4_46.html'>46</a><a href='4_47.html'>47</a><a href='4_48.html'>48</a><a href='4_49.html'>49</a><a href='4_50.html'>50</a><a href='4_51.html'>51</a><span>[52]</span><a href='4_53.html'>53</a><a href='4_54.html'>54</a><a href='4_55.html'>55</a><a href='4_56.html'>56</a><a href='4_57.html'>57</a><a href='4_53.html'>Next&gt;&gt;</a>
    <div>
</body>
